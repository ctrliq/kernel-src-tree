x86/speculation: Restore speculation related MSRs during S3 resume

jira LE-1907
cve CVE-2023-20593
Rebuild_History Non-Buildable kernel-4.18.0-477.27.1.el8_8
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit e2a1256b17b16f9b9adf1b6fea56819e7b68e463
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.27.1.el8_8/e2a1256b.failed

After resuming from suspend-to-RAM, the MSRs that control CPU's
speculative execution behavior are not being restored on the boot CPU.

These MSRs are used to mitigate speculative execution vulnerabilities.
Not restoring them correctly may leave the CPU vulnerable.  Secondary
CPU's MSRs are correctly being restored at S3 resume by
identify_secondary_cpu().

During S3 resume, restore these MSRs for boot CPU when restoring its
processor state.

Fixes: 772439717dbf ("x86/bugs/intel: Set proper CPU features and setup RDS")
	Reported-by: Neelima Krishnan <neelima.krishnan@intel.com>
	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Tested-by: Neelima Krishnan <neelima.krishnan@intel.com>
	Acked-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e2a1256b17b16f9b9adf1b6fea56819e7b68e463)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/power/cpu.c
diff --cc arch/x86/power/cpu.c
index f48756c903d4,3822666fb73d..000000000000
--- a/arch/x86/power/cpu.c
+++ b/arch/x86/power/cpu.c
@@@ -446,9 -468,60 +446,66 @@@ static const struct dmi_system_id msr_s
  	{}
  };
  
++<<<<<<< HEAD
 +static int pm_check_save_msr(void)
 +{
 +	dmi_check_system(msr_save_dmi_table);
++=======
+ static int msr_save_cpuid_features(const struct x86_cpu_id *c)
+ {
+ 	u32 cpuid_msr_id[] = {
+ 		MSR_AMD64_CPUID_FN_1,
+ 	};
+ 
+ 	pr_info("x86/pm: family %#hx cpu detected, MSR saving is needed during suspending.\n",
+ 		c->family);
+ 
+ 	return msr_build_context(cpuid_msr_id, ARRAY_SIZE(cpuid_msr_id));
+ }
+ 
+ static const struct x86_cpu_id msr_save_cpu_table[] = {
+ 	X86_MATCH_VENDOR_FAM(AMD, 0x15, &msr_save_cpuid_features),
+ 	X86_MATCH_VENDOR_FAM(AMD, 0x16, &msr_save_cpuid_features),
+ 	{}
+ };
+ 
+ typedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);
+ static int pm_cpu_check(const struct x86_cpu_id *c)
+ {
+ 	const struct x86_cpu_id *m;
+ 	int ret = 0;
+ 
+ 	m = x86_match_cpu(msr_save_cpu_table);
+ 	if (m) {
+ 		pm_cpu_match_t fn;
+ 
+ 		fn = (pm_cpu_match_t)m->driver_data;
+ 		ret = fn(m);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void pm_save_spec_msr(void)
+ {
+ 	u32 spec_msr_id[] = {
+ 		MSR_IA32_SPEC_CTRL,
+ 		MSR_IA32_TSX_CTRL,
+ 		MSR_TSX_FORCE_ABORT,
+ 		MSR_IA32_MCU_OPT_CTRL,
+ 		MSR_AMD64_LS_CFG,
+ 	};
+ 
+ 	msr_build_context(spec_msr_id, ARRAY_SIZE(spec_msr_id));
+ }
+ 
+ static int pm_check_save_msr(void)
+ {
+ 	dmi_check_system(msr_save_dmi_table);
+ 	pm_cpu_check(msr_save_cpu_table);
+ 	pm_save_spec_msr();
+ 
++>>>>>>> e2a1256b17b1 (x86/speculation: Restore speculation related MSRs during S3 resume)
  	return 0;
  }
  
* Unmerged path arch/x86/power/cpu.c
