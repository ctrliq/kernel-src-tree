drm/amd/display: Explicitly specify update type per plane info change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-511.el8
commit-author Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
commit aa5fdb1ab5b6559ce6ebe11dd78177c8487f02e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-511.el8/aa5fdb1a.failed

[Why]
The bit for flip addr is being set causing the determination for
FAST vs MEDIUM to always return MEDIUM when plane info is provided
as a surface update. This causes extreme stuttering for the typical
atomic update path on Linux.

[How]
Don't use update_flags->raw for determining FAST vs MEDIUM. It's too
fragile to changes like this.

Explicitly specify the update type per update flag instead. It's not
as clever as checking the bits itself but at least it's correct.

	Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
	Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
	Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
	Acked-by: Eryk Brol <Eryk.Brol@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit aa5fdb1ab5b6559ce6ebe11dd78177c8487f02e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/core/dc.c
diff --cc drivers/gpu/drm/amd/display/dc/core/dc.c
index 9ec0a343efad,257e632a3a1a..000000000000
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@@ -2428,17 -1372,17 +2428,31 @@@ static enum surface_update_type get_pla
  		update_flags->bits.global_alpha_change = 1;
  		elevate_update_type(&update_type, UPDATE_TYPE_MED);
  	}
++<<<<<<< HEAD
 +
 +	if (u->plane_info->dcc.enable != u->surface->dcc.enable
 +			|| u->plane_info->dcc.dcc_ind_blk != u->surface->dcc.dcc_ind_blk
 +			|| u->plane_info->dcc.meta_pitch != u->surface->dcc.meta_pitch) {
 +		/* During DCC on/off, stutter period is calculated before
 +		 * DCC has fully transitioned. This results in incorrect
 +		 * stutter period calculation. Triggering a full update will
 +		 * recalculate stutter period.
 +		 */
 +		update_flags->bits.dcc_change = 1;
 +		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
++=======
+ 
+ 	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level) {
+ 		update_flags->bits.sdr_white_level = 1;
+ 		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+ 	}
+ 
+ 	if (u->plane_info->dcc.enable != u->surface->dcc.enable
+ 			|| u->plane_info->dcc.grph.independent_64b_blks != u->surface->dcc.grph.independent_64b_blks
+ 			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch) {
+ 		update_flags->bits.dcc_change = 1;
+ 		elevate_update_type(&update_type, UPDATE_TYPE_MED);
++>>>>>>> aa5fdb1ab5b6 (drm/amd/display: Explicitly specify update type per plane info change)
  	}
  
  	if (resource_pixel_format_to_bpp(u->plane_info->format) !=
@@@ -2450,8 -1394,9 +2464,14 @@@
  		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
  	}
  
++<<<<<<< HEAD
 +	if (u->plane_info->plane_size.surface_pitch != u->surface->plane_size.surface_pitch
 +			|| u->plane_info->plane_size.chroma_pitch != u->surface->plane_size.chroma_pitch) {
++=======
+ 	if (u->plane_info->plane_size.grph.surface_pitch != u->surface->plane_size.grph.surface_pitch
+ 			|| u->plane_info->plane_size.video.luma_pitch != u->surface->plane_size.video.luma_pitch
+ 			|| u->plane_info->plane_size.video.chroma_pitch != u->surface->plane_size.video.chroma_pitch) {
++>>>>>>> aa5fdb1ab5b6 (drm/amd/display: Explicitly specify update type per plane info change)
  		update_flags->bits.plane_size_change = 1;
  		elevate_update_type(&update_type, UPDATE_TYPE_MED);
  	}
@@@ -2540,11 -1482,10 +2560,18 @@@ static enum surface_update_type det_sur
  	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
  	union surface_update_flags *update_flags = &u->surface->update_flags;
  
++<<<<<<< HEAD
 +	if (u->flip_addr)
 +		update_flags->bits.addr_update = 1;
 +
 +	if (!is_surface_in_context(context, u->surface) || u->surface->force_full_update) {
 +		update_flags->raw = 0xFFFFFFFF;
++=======
+ 	update_flags->raw = 0; // Reset all flags
+ 
+ 	if (!is_surface_in_context(context, u->surface)) {
+ 		update_flags->bits.new_plane = 1;
++>>>>>>> aa5fdb1ab5b6 (drm/amd/display: Explicitly specify update type per plane info change)
  		return UPDATE_TYPE_FULL;
  	}
  
@@@ -2556,13 -1500,9 +2583,19 @@@
  	type = get_scaling_info_update_type(u);
  	elevate_update_type(&overall_type, type);
  
++<<<<<<< HEAD
 +	if (u->flip_addr) {
 +		update_flags->bits.addr_update = 1;
 +		if (u->flip_addr->address.tmz_surface != u->surface->address.tmz_surface) {
 +			update_flags->bits.tmz_changed = 1;
 +			elevate_update_type(&overall_type, UPDATE_TYPE_FULL);
 +		}
 +	}
++=======
+ 	if (u->flip_addr)
+ 		update_flags->bits.addr_update = 1;
+ 
++>>>>>>> aa5fdb1ab5b6 (drm/amd/display: Explicitly specify update type per plane info change)
  	if (u->in_transfer_func)
  		update_flags->bits.in_transfer_func_change = 1;
  
* Unmerged path drivers/gpu/drm/amd/display/dc/core/dc.c
