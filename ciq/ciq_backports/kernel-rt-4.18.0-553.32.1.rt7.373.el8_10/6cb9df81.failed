gfs2: fix double destroy_workqueue error

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.32.1.rt7.373.el8_10
commit-author Julian Sun <sunjunchao2870@gmail.com>
commit 6cb9df81a2c462b89d2f9611009ab43ae8717841
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.32.1.rt7.373.el8_10/6cb9df81.failed

When gfs2_fill_super() fails, destroy_workqueue() is called within
gfs2_gl_hash_clear(), and the subsequent code path calls
destroy_workqueue() on the same work queue again.

This issue can be fixed by setting the work queue pointer to NULL after
the first destroy_workqueue() call and checking for a NULL pointer
before attempting to destroy the work queue again.

	Reported-by: syzbot+d34c2a269ed512c531b0@syzkaller.appspotmail.com
Closes: https://syzkaller.appspot.com/bug?extid=d34c2a269ed512c531b0
Fixes: 30e388d57367 ("gfs2: Switch to a per-filesystem glock workqueue")
	Cc: stable@vger.kernel.org
	Signed-off-by: Julian Sun <sunjunchao2870@gmail.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6cb9df81a2c462b89d2f9611009ab43ae8717841)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
#	fs/gfs2/ops_fstype.c
diff --cc fs/gfs2/glock.c
index 755846f2501f,269c3bc7fced..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -2172,6 -2250,8 +2172,11 @@@ void gfs2_gl_hash_clear(struct gfs2_sb
  	gfs2_lm_unmount(sdp);
  	gfs2_free_dead_glocks(sdp);
  	glock_hash_walk(dump_glock_func, sdp);
++<<<<<<< HEAD
++=======
+ 	destroy_workqueue(sdp->sd_glock_wq);
+ 	sdp->sd_glock_wq = NULL;
++>>>>>>> 6cb9df81a2c4 (gfs2: fix double destroy_workqueue error)
  }
  
  static const char *state2str(unsigned state)
diff --cc fs/gfs2/ops_fstype.c
index 65032e10b64a,e83d293c3614..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -1287,6 -1306,9 +1287,12 @@@ fail_debug
  	gfs2_sys_fs_del(sdp);
  fail_delete_wq:
  	destroy_workqueue(sdp->sd_delete_wq);
++<<<<<<< HEAD
++=======
+ fail_glock_wq:
+ 	if (sdp->sd_glock_wq)
+ 		destroy_workqueue(sdp->sd_glock_wq);
++>>>>>>> 6cb9df81a2c4 (gfs2: fix double destroy_workqueue error)
  fail_free:
  	free_sbd(sdp);
  	sb->s_fs_info = NULL;
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/ops_fstype.c
