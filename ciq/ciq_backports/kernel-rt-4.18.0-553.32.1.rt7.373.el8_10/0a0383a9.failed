gfs2: Rename GLF_REPLY_PENDING to GLF_HAVE_REPLY

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.32.1.rt7.373.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 0a0383a93e5d28f2873a72b8378c2b36404e431e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.32.1.rt7.373.el8_10/0a0383a9.failed

The GLF_REPLY_PENDING flag indicates to glock_work_func() that in
response to a locking request, DLM has sent a reply that needs to be
processed.  A flag with that name could as well indicate that we are
waiting on a reply from DLM, however.  To disambiguate these two cases,
rename the flag to GLF_HAVE_REPLY.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 0a0383a93e5d28f2873a72b8378c2b36404e431e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index dae036f75465,34af0e7db98b..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -1550,9 -1642,9 +1550,9 @@@ int gfs2_glock_nq(struct gfs2_holder *g
  	add_to_queue(gh);
  	if (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&
  		     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {
- 		set_bit(GLF_REPLY_PENDING, &gl->gl_flags);
+ 		set_bit(GLF_HAVE_REPLY, &gl->gl_flags);
  		gl->gl_lockref.count++;
 -		gfs2_glock_queue_work(gl, 0);
 +		__gfs2_glock_queue_work(gl, 0);
  	}
  	run_queue(gl, 1);
  	spin_unlock(&gl->gl_lockref.lock);
@@@ -1897,8 -1993,8 +1897,13 @@@ void gfs2_glock_complete(struct gfs2_gl
  	}
  
  	gl->gl_lockref.count++;
++<<<<<<< HEAD
 +	set_bit(GLF_REPLY_PENDING, &gl->gl_flags);
 +	__gfs2_glock_queue_work(gl, 0);
++=======
+ 	set_bit(GLF_HAVE_REPLY, &gl->gl_flags);
+ 	gfs2_glock_queue_work(gl, 0);
++>>>>>>> 0a0383a93e5d (gfs2: Rename GLF_REPLY_PENDING to GLF_HAVE_REPLY)
  	spin_unlock(&gl->gl_lockref.lock);
  }
  
@@@ -2093,8 -2186,8 +2098,13 @@@ static void thaw_glock(struct gfs2_gloc
  		return;
  
  	spin_lock(&gl->gl_lockref.lock);
++<<<<<<< HEAD
 +	set_bit(GLF_REPLY_PENDING, &gl->gl_flags);
 +	__gfs2_glock_queue_work(gl, 0);
++=======
+ 	set_bit(GLF_HAVE_REPLY, &gl->gl_flags);
+ 	gfs2_glock_queue_work(gl, 0);
++>>>>>>> 0a0383a93e5d (gfs2: Rename GLF_REPLY_PENDING to GLF_HAVE_REPLY)
  	spin_unlock(&gl->gl_lockref.lock);
  }
  
* Unmerged path fs/gfs2/glock.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bce238196547..07ad6e37642c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -325,7 +325,7 @@ enum {
 	GLF_DIRTY			= 6,
 	GLF_LFLUSH			= 7,
 	GLF_INVALIDATE_IN_PROGRESS	= 8,
-	GLF_REPLY_PENDING		= 9,
+	GLF_HAVE_REPLY			= 9,
 	GLF_INITIAL			= 10,
 	GLF_FROZEN			= 11,
 	GLF_INSTANTIATE_IN_PROG		= 12, /* instantiate happening now */
diff --git a/fs/gfs2/trace_gfs2.h b/fs/gfs2/trace_gfs2.h
index a5deb9f86831..3721f0333dd7 100644
--- a/fs/gfs2/trace_gfs2.h
+++ b/fs/gfs2/trace_gfs2.h
@@ -53,7 +53,7 @@
 	{(1UL << GLF_DIRTY),			"y" },		\
 	{(1UL << GLF_LFLUSH),			"f" },		\
 	{(1UL << GLF_INVALIDATE_IN_PROGRESS),	"i" },		\
-	{(1UL << GLF_REPLY_PENDING),		"r" },		\
+	{(1UL << GLF_HAVE_REPLY),		"r" },		\
 	{(1UL << GLF_INITIAL),			"I" },		\
 	{(1UL << GLF_FROZEN),			"F" },		\
 	{(1UL << GLF_LRU),			"L" },		\
