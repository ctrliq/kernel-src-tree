gfs2: Only defer deletes when we have an iopen glock

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.32.1.rt7.373.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit c5b7a2400edc458b22133d5e5394bea26eab1923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.32.1.rt7.373.el8_10/c5b7a240.failed

The mechanism to defer deleting unlinked inodes is tied to
delete_work_func(), which is tied to iopen glocks.  When we don't have
an iopen glock, we must carry out deletes immediately instead.

Fixes a NULL pointer dereference in gfs2_evict_inode().

Fixes: 8c21c2c71e66 ("gfs2: Call gfs2_queue_verify_delete from gfs2_evict_inode")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit c5b7a2400edc458b22133d5e5394bea26eab1923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index a0ec4e506f04,92a3b6ddafdc..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1531,15 -1498,18 +1531,25 @@@ static void gfs2_evict_inode(struct ino
  	if (!sdp->sd_jdesc)
  		goto out;
  
 +	gfs2_holder_mark_uninitialized(&gh);
  	behavior = evict_should_delete(inode, &gh);
 -	if (behavior == EVICT_SHOULD_DEFER_DELETE &&
 -	    !test_bit(SDF_KILL, &sdp->sd_flags)) {
 +	if (behavior == EVICT_SHOULD_DEFER_DELETE) {
  		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
  
++<<<<<<< HEAD
 +		gfs2_glock_hold(io_gl);
 +		if (!gfs2_queue_verify_delete(io_gl))
 +			gfs2_glock_put(io_gl);
 +		goto out;
++=======
+ 		if (io_gl) {
+ 			gfs2_glock_hold(io_gl);
+ 			if (!gfs2_queue_verify_delete(io_gl, true))
+ 				gfs2_glock_put(io_gl);
+ 			goto out;
+ 		}
+ 		behavior = EVICT_SHOULD_DELETE;
++>>>>>>> c5b7a2400edc (gfs2: Only defer deletes when we have an iopen glock)
  	}
  	if (behavior == EVICT_SHOULD_DELETE)
  		ret = evict_unlinked_inode(inode);
* Unmerged path fs/gfs2/super.c
