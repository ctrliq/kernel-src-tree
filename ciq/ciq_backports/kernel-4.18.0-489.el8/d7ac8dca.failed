nvme: quiet user passthrough command errors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-489.el8
commit-author Keith Busch <kbusch@kernel.org>
commit d7ac8dca938cd60cf7bd9a89a229a173c6bcba87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-489.el8/d7ac8dca.failed

The driver is spamming the kernel logs for entirely harmless errors from
user space submitting unsupported commands. Just silence the errors.
The application has direct access to command status, so there's no need
to log these.

And since every passthrough command now uses the quiet flag, move the
setting to the common initializer.

	Signed-off-by: Keith Busch <kbusch@kernel.org>
	Reviewed-by: Alan Adamson <alan.adamson@oracle.com>
	Reviewed-by: Jens Axboe <axboe@kernel.dk>
	Reviewed-by: Kanchan Joshi <joshi.k@samsung.com>
	Reviewed-by: Chaitanya Kulkarni <kch@nvidia.com>
	Reviewed-by: Daniel Wagner <dwagner@suse.de>
	Tested-by: Alan Adamson <alan.adamson@oracle.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit d7ac8dca938cd60cf7bd9a89a229a173c6bcba87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/core.c
index cd5b9c069e0c,da55ce45ac70..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -695,34 -673,12 +695,35 @@@ static inline void nvme_init_request(st
  
  	req->cmd_flags |= REQ_FAILFAST_DRIVER;
  	if (req->mq_hctx->type == HCTX_TYPE_POLL)
 -		req->cmd_flags |= REQ_POLLED;
 +		req->cmd_flags |= REQ_HIPRI;
  	nvme_clear_nvme_request(req);
+ 	req->rq_flags |= RQF_QUIET;
  	memcpy(nvme_req(req)->cmd, cmd, sizeof(*cmd));
  }
 -EXPORT_SYMBOL_GPL(nvme_init_request);
 +
 +struct request *nvme_alloc_request(struct request_queue *q,
 +		struct nvme_command *cmd, blk_mq_req_flags_t flags)
 +{
 +	struct request *req;
 +
 +	req = blk_mq_alloc_request(q, nvme_req_op(cmd), flags);
 +	if (!IS_ERR(req))
 +		nvme_init_request(req, cmd);
 +	return req;
 +}
 +EXPORT_SYMBOL_GPL(nvme_alloc_request);
 +
 +static struct request *nvme_alloc_request_qid(struct request_queue *q,
 +		struct nvme_command *cmd, blk_mq_req_flags_t flags, int qid)
 +{
 +	struct request *req;
 +
 +	req = blk_mq_alloc_request_hctx(q, nvme_req_op(cmd), flags,
 +			qid ? qid - 1 : 0);
 +	if (!IS_ERR(req))
 +		nvme_init_request(req, cmd);
 +	return req;
 +}
  
  /*
   * For something we're not in a state to send to the device the default action
@@@ -1153,8 -1038,7 +1154,12 @@@ int __nvme_submit_sync_cmd(struct reque
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	req->rq_flags |= RQF_QUIET;
 +	ret = nvme_execute_rq(NULL, req, at_head);
++=======
+ 	ret = nvme_execute_rq(req, at_head);
++>>>>>>> d7ac8dca938c (nvme: quiet user passthrough command errors)
  	if (result && ret >= 0)
  		*result = nvme_req(req)->result;
   out:
@@@ -1342,10 -1222,12 +1347,14 @@@ static void nvme_keep_alive_work(struc
  		nvme_reset_ctrl(ctrl);
  		return;
  	}
 -	nvme_init_request(rq, &ctrl->ka_cmd);
  
  	rq->timeout = ctrl->kato * HZ;
 -	rq->end_io = nvme_keep_alive_end_io;
  	rq->end_io_data = ctrl;
++<<<<<<< HEAD
 +	blk_execute_rq_nowait(rq->q, NULL, rq, 0, nvme_keep_alive_end_io);
++=======
+ 	blk_execute_rq_nowait(rq, false);
++>>>>>>> d7ac8dca938c (nvme: quiet user passthrough command errors)
  }
  
  static void nvme_start_keep_alive(struct nvme_ctrl *ctrl)
diff --cc drivers/nvme/host/pci.c
index bebcba0ec28d,02b5578773a1..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -1277,9 -1432,11 +1277,13 @@@ static enum blk_eh_timer_return nvme_ti
  		atomic_inc(&dev->ctrl.abort_limit);
  		return BLK_EH_RESET_TIMER;
  	}
 -	nvme_init_request(abort_req, &cmd);
  
 -	abort_req->end_io = abort_endio;
  	abort_req->end_io_data = NULL;
++<<<<<<< HEAD
 +	blk_execute_rq_nowait(abort_req->q, NULL, abort_req, 0, abort_endio);
++=======
+ 	blk_execute_rq_nowait(abort_req, false);
++>>>>>>> d7ac8dca938c (nvme: quiet user passthrough command errors)
  
  	/*
  	 * The aborted req will be completed on receiving the abort req.
@@@ -2325,9 -2485,11 +2329,13 @@@ static int nvme_delete_queue(struct nvm
  	req->end_io_data = nvmeq;
  
  	init_completion(&nvmeq->delete_done);
++<<<<<<< HEAD
 +	blk_execute_rq_nowait(q, NULL, req, false,
 +			opcode == nvme_admin_delete_cq ?
 +				nvme_del_cq_end : nvme_del_queue_end);
++=======
+ 	blk_execute_rq_nowait(req, false);
++>>>>>>> d7ac8dca938c (nvme: quiet user passthrough command errors)
  	return 0;
  }
  
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/pci.c
