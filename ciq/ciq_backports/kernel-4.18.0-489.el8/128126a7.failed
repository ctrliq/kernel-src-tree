nvme: mark internal passthru request RQF_QUIET

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-489.el8
commit-author Chaitanya Kulkarni <kch@nvidia.com>
commit 128126a7943622424350752a71be5bb95e7946db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-489.el8/128126a7.failed

Most of the internal passthru commands use __nvme_submit_sync_cmd()
interface. There are few places we open code the request submission :-

1. nvme_keep_alive_work(struct work_struct *work)
2. nvme_timeout(struct request *req, bool reserved)
3. nvme_delete_queue(struct nvme_queue *nvmeq, u8 opcode)

Mark the internal passthru request quiet so that we can skip the verbose
error message from nvme_log_error() in nvme_end_req() completion path,
this will be consistent with what we have in __nvme_submit_sync_cmd().

	Signed-off-by: Chaitanya Kulkarni <kch@nvidia.com>
	Reviewed-by: Alan Adamson <alan.adamson@oracle.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 128126a7943622424350752a71be5bb95e7946db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/core.c
index 03081591aab2,42f9772abc4d..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1345,7 -1206,9 +1345,12 @@@ static void nvme_keep_alive_work(struc
  
  	rq->timeout = ctrl->kato * HZ;
  	rq->end_io_data = ctrl;
++<<<<<<< HEAD
 +	blk_execute_rq_nowait(rq->q, NULL, rq, 0, nvme_keep_alive_end_io);
++=======
+ 	rq->rq_flags |= RQF_QUIET;
+ 	blk_execute_rq_nowait(rq, false, nvme_keep_alive_end_io);
++>>>>>>> 128126a79436 (nvme: mark internal passthru request RQF_QUIET)
  }
  
  static void nvme_start_keep_alive(struct nvme_ctrl *ctrl)
diff --cc drivers/nvme/host/pci.c
index c6f7108c00c4,f326261456ac..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -1267,9 -1436,11 +1267,14 @@@ static enum blk_eh_timer_return nvme_ti
  		atomic_inc(&dev->ctrl.abort_limit);
  		return BLK_EH_RESET_TIMER;
  	}
 -	nvme_init_request(abort_req, &cmd);
  
  	abort_req->end_io_data = NULL;
++<<<<<<< HEAD
 +	blk_execute_rq_nowait(abort_req->q, NULL, abort_req, 0, abort_endio);
++=======
+ 	abort_req->rq_flags |= RQF_QUIET;
+ 	blk_execute_rq_nowait(abort_req, false, abort_endio);
++>>>>>>> 128126a79436 (nvme: mark internal passthru request RQF_QUIET)
  
  	/*
  	 * The aborted req will be completed on receiving the abort req.
@@@ -2314,9 -2487,9 +2319,15 @@@ static int nvme_delete_queue(struct nvm
  	req->end_io_data = nvmeq;
  
  	init_completion(&nvmeq->delete_done);
++<<<<<<< HEAD
 +	blk_execute_rq_nowait(q, NULL, req, false,
 +			opcode == nvme_admin_delete_cq ?
 +				nvme_del_cq_end : nvme_del_queue_end);
++=======
+ 	req->rq_flags |= RQF_QUIET;
+ 	blk_execute_rq_nowait(req, false, opcode == nvme_admin_delete_cq ?
+ 			nvme_del_cq_end : nvme_del_queue_end);
++>>>>>>> 128126a79436 (nvme: mark internal passthru request RQF_QUIET)
  	return 0;
  }
  
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/pci.c
