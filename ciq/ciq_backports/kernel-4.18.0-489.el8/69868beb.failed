dm ioctl: assert _hash_lock is held in __hash_remove

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-489.el8
commit-author Mike Snitzer <snitzer@kernel.org>
commit 69868bebfe8e9a47b0d8a12f7473b8a3b7239ef3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-489.el8/69868beb.failed

Also update dm_early_create() to take _hash_lock when calling both
__get_name_cell and __hash_remove -- given dm_early_create()'s early
boot usecase this locking isn't about correctness but it allows
lockdep_assert_held() to be added to __hash_remove.

	Signed-off-by: Mike Snitzer <snitzer@kernel.org>
(cherry picked from commit 69868bebfe8e9a47b0d8a12f7473b8a3b7239ef3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-ioctl.c
diff --cc drivers/md/dm-ioctl.c
index 107291f8753c,067dfc08d4c3..000000000000
--- a/drivers/md/dm-ioctl.c
+++ b/drivers/md/dm-ioctl.c
@@@ -2100,3 -2168,110 +2102,113 @@@ out
  	return r;
  }
  EXPORT_SYMBOL_GPL(dm_copy_name_and_uuid);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * dm_early_create - create a mapped device in early boot.
+  *
+  * @dmi: Contains main information of the device mapping to be created.
+  * @spec_array: array of pointers to struct dm_target_spec. Describes the
+  * mapping table of the device.
+  * @target_params_array: array of strings with the parameters to a specific
+  * target.
+  *
+  * Instead of having the struct dm_target_spec and the parameters for every
+  * target embedded at the end of struct dm_ioctl (as performed in a normal
+  * ioctl), pass them as arguments, so the caller doesn't need to serialize them.
+  * The size of the spec_array and target_params_array is given by
+  * @dmi->target_count.
+  * This function is supposed to be called in early boot, so locking mechanisms
+  * to protect against concurrent loads are not required.
+  */
+ int __init dm_early_create(struct dm_ioctl *dmi,
+ 			   struct dm_target_spec **spec_array,
+ 			   char **target_params_array)
+ {
+ 	int r, m = DM_ANY_MINOR;
+ 	struct dm_table *t, *old_map;
+ 	struct mapped_device *md;
+ 	unsigned int i;
+ 
+ 	if (!dmi->target_count)
+ 		return -EINVAL;
+ 
+ 	r = check_name(dmi->name);
+ 	if (r)
+ 		return r;
+ 
+ 	if (dmi->flags & DM_PERSISTENT_DEV_FLAG)
+ 		m = MINOR(huge_decode_dev(dmi->dev));
+ 
+ 	/* alloc dm device */
+ 	r = dm_create(m, &md);
+ 	if (r)
+ 		return r;
+ 
+ 	/* hash insert */
+ 	r = dm_hash_insert(dmi->name, *dmi->uuid ? dmi->uuid : NULL, md);
+ 	if (r)
+ 		goto err_destroy_dm;
+ 
+ 	/* alloc table */
+ 	r = dm_table_create(&t, get_mode(dmi), dmi->target_count, md);
+ 	if (r)
+ 		goto err_hash_remove;
+ 
+ 	/* add targets */
+ 	for (i = 0; i < dmi->target_count; i++) {
+ 		r = dm_table_add_target(t, spec_array[i]->target_type,
+ 					(sector_t) spec_array[i]->sector_start,
+ 					(sector_t) spec_array[i]->length,
+ 					target_params_array[i]);
+ 		if (r) {
+ 			DMERR("error adding target to table");
+ 			goto err_destroy_table;
+ 		}
+ 	}
+ 
+ 	/* finish table */
+ 	r = dm_table_complete(t);
+ 	if (r)
+ 		goto err_destroy_table;
+ 
+ 	/* setup md->queue to reflect md's type (may block) */
+ 	r = dm_setup_md_queue(md, t);
+ 	if (r) {
+ 		DMERR("unable to set up device queue for new table.");
+ 		goto err_destroy_table;
+ 	}
+ 
+ 	/* Set new map */
+ 	dm_suspend(md, 0);
+ 	old_map = dm_swap_table(md, t);
+ 	if (IS_ERR(old_map)) {
+ 		r = PTR_ERR(old_map);
+ 		goto err_destroy_table;
+ 	}
+ 	set_disk_ro(dm_disk(md), !!(dmi->flags & DM_READONLY_FLAG));
+ 
+ 	/* resume device */
+ 	r = dm_resume(md);
+ 	if (r)
+ 		goto err_destroy_table;
+ 
+ 	DMINFO("%s (%s) is ready", md->disk->disk_name, dmi->name);
+ 	dm_put(md);
+ 	return 0;
+ 
+ err_destroy_table:
+ 	dm_table_destroy(t);
+ err_hash_remove:
+ 	down_write(&_hash_lock);
+ 	(void) __hash_remove(__get_name_cell(dmi->name));
+ 	up_write(&_hash_lock);
+ 	/* release reference from __get_name_cell */
+ 	dm_put(md);
+ err_destroy_dm:
+ 	dm_put(md);
+ 	dm_destroy(md);
+ 	return r;
+ }
++>>>>>>> 69868bebfe8e (dm ioctl: assert _hash_lock is held in __hash_remove)
* Unmerged path drivers/md/dm-ioctl.c
