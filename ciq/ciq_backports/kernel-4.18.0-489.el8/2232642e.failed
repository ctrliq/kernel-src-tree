ipvs: add sysctl_run_estimation to support disable estimation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-489.el8
commit-author Dust Li <dust.li@linux.alibaba.com>
commit 2232642ec3fb4aad6ae4da1e109f55a0e7f2d204
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-489.el8/2232642e.failed

estimation_timer will iterate the est_list to do estimation
for each ipvs stats. When there are lots of services, the
list can be very large.
We found that estimation_timer() run for more then 200ms on a
machine with 104 CPU and 50K services.

yunhong-cgl jiang report the same phenomenon before:
https://www.spinics.net/lists/lvs-devel/msg05426.html

In some cases(for example a large K8S cluster with many ipvs services),
ipvs estimation may not be needed. So adding a sysctl blob to allow
users to disable this completely.

Default is: 1 (enable)

	Cc: yunhong-cgl jiang <xintian1976@gmail.com>
	Signed-off-by: Dust Li <dust.li@linux.alibaba.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Acked-by: Simon Horman <horms@verge.net.au>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 2232642ec3fb4aad6ae4da1e109f55a0e7f2d204)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_ctl.c
diff --cc net/netfilter/ipvs/ip_vs_ctl.c
index 3df39b3d2c8c,cbea5a68afb5..000000000000
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@@ -3941,11 -4096,8 +3947,16 @@@ static int __net_init ip_vs_control_net
  	tbl[idx++].data = &ipvs->sysctl_conn_reuse_mode;
  	tbl[idx++].data = &ipvs->sysctl_schedule_icmp;
  	tbl[idx++].data = &ipvs->sysctl_ignore_tunneled;
++<<<<<<< HEAD
 +#ifdef CONFIG_IP_VS_DEBUG
 +	/* Global sysctls must be ro in non-init netns */
 +	if (!net_eq(net, &init_net))
 +		tbl[idx++].mode = 0444;
 +#endif
++=======
+ 	ipvs->sysctl_run_estimation = 1;
+ 	tbl[idx++].data = &ipvs->sysctl_run_estimation;
++>>>>>>> 2232642ec3fb (ipvs: add sysctl_run_estimation to support disable estimation)
  
  	ipvs->sysctl_hdr = register_net_sysctl(net, "net/ipv4/vs", tbl);
  	if (ipvs->sysctl_hdr == NULL) {
diff --git a/Documentation/networking/ipvs-sysctl.txt b/Documentation/networking/ipvs-sysctl.txt
index fc531c29a2e8..4bb763654d17 100644
--- a/Documentation/networking/ipvs-sysctl.txt
+++ b/Documentation/networking/ipvs-sysctl.txt
@@ -291,3 +291,14 @@ sync_version - INTEGER
 
 	Kernels with this sync_version entry are able to receive messages
 	of both version 1 and version 2 of the synchronisation protocol.
+
+run_estimation - BOOLEAN
+	0 - disabled
+	not 0 - enabled (default)
+
+	If disabled, the estimation will be stop, and you can't see
+	any update on speed estimation data.
+
+	You can always re-enable estimation by setting this value to 1.
+	But be careful, the first estimation after re-enable is not
+	accurate.
diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index f259a804d389..929cc203270e 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -920,6 +920,7 @@ struct netns_ipvs {
 	int			sysctl_conn_reuse_mode;
 	int			sysctl_schedule_icmp;
 	int			sysctl_ignore_tunneled;
+	int			sysctl_run_estimation;
 
 	/* ip_vs_lblc */
 	int			sysctl_lblc_expiration;
@@ -1054,6 +1055,11 @@ static inline int sysctl_cache_bypass(struct netns_ipvs *ipvs)
 	return ipvs->sysctl_cache_bypass;
 }
 
+static inline int sysctl_run_estimation(struct netns_ipvs *ipvs)
+{
+	return ipvs->sysctl_run_estimation;
+}
+
 #else
 
 static inline int sysctl_sync_threshold(struct netns_ipvs *ipvs)
@@ -1141,6 +1147,11 @@ static inline int sysctl_cache_bypass(struct netns_ipvs *ipvs)
 	return 0;
 }
 
+static inline int sysctl_run_estimation(struct netns_ipvs *ipvs)
+{
+	return 1;
+}
+
 #endif
 
 /* IPVS core functions
* Unmerged path net/netfilter/ipvs/ip_vs_ctl.c
diff --git a/net/netfilter/ipvs/ip_vs_est.c b/net/netfilter/ipvs/ip_vs_est.c
index 489055091a9b..338e04fa6fbe 100644
--- a/net/netfilter/ipvs/ip_vs_est.c
+++ b/net/netfilter/ipvs/ip_vs_est.c
@@ -104,6 +104,9 @@ static void estimation_timer(struct timer_list *t)
 	u64 rate;
 	struct netns_ipvs *ipvs = from_timer(ipvs, t, est_timer);
 
+	if (!sysctl_run_estimation(ipvs))
+		goto skip;
+
 	spin_lock(&ipvs->est_lock);
 	list_for_each_entry(e, &ipvs->est_list, list) {
 		s = container_of(e, struct ip_vs_stats, est);
@@ -135,6 +138,8 @@ static void estimation_timer(struct timer_list *t)
 		spin_unlock(&s->lock);
 	}
 	spin_unlock(&ipvs->est_lock);
+
+skip:
 	mod_timer(&ipvs->est_timer, jiffies + 2*HZ);
 }
 
