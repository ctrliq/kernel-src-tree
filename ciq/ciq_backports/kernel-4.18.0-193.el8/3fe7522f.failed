locking/lockdep: Avoid a Clang warning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Arnd Bergmann <arnd@arndb.de>
commit 3fe7522fb766f6ee76bf7bc2837f1e3cc52c4e27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3fe7522f.failed

Clang warns about a tentative array definition without a length:

  kernel/locking/lockdep.c:845:12: error: tentative array definition assumed to have one element [-Werror]

There is no real reason to do this here, so just set the same length as
in the real definition later in the same file.  It has to be hidden in
an #ifdef or annotated __maybe_unused though, to avoid the unused-variable
warning if CONFIG_PROVE_LOCKING is disabled.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Bart Van Assche <bvanassche@acm.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Frederic Weisbecker <frederic@kernel.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Joel Fernandes (Google) <joel@joelfernandes.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Will Deacon <will.deacon@arm.com>
Link: https://lkml.kernel.org/r/20190307075222.3424524-1-arnd@arndb.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 3fe7522fb766f6ee76bf7bc2837f1e3cc52c4e27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/lockdep.c
diff --cc kernel/locking/lockdep.c
index aed5c03ce876,35a144dfddf5..000000000000
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@@ -750,8 -790,195 +750,184 @@@ static bool assign_lock_key(struct lock
  	return true;
  }
  
 -#ifdef CONFIG_DEBUG_LOCKDEP
 -
 -/* Check whether element @e occurs in list @h */
 -static bool in_list(struct list_head *e, struct list_head *h)
 -{
 -	struct list_head *f;
 -
 -	list_for_each(f, h) {
 -		if (e == f)
 -			return true;
 -	}
 -
 -	return false;
 -}
 -
  /*
++<<<<<<< HEAD
 + * Initialize the lock_classes[] array elements.
++=======
+  * Check whether entry @e occurs in any of the locks_after or locks_before
+  * lists.
+  */
+ static bool in_any_class_list(struct list_head *e)
+ {
+ 	struct lock_class *class;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(lock_classes); i++) {
+ 		class = &lock_classes[i];
+ 		if (in_list(e, &class->locks_after) ||
+ 		    in_list(e, &class->locks_before))
+ 			return true;
+ 	}
+ 	return false;
+ }
+ 
+ static bool class_lock_list_valid(struct lock_class *c, struct list_head *h)
+ {
+ 	struct lock_list *e;
+ 
+ 	list_for_each_entry(e, h, entry) {
+ 		if (e->links_to != c) {
+ 			printk(KERN_INFO "class %s: mismatch for lock entry %ld; class %s <> %s",
+ 			       c->name ? : "(?)",
+ 			       (unsigned long)(e - list_entries),
+ 			       e->links_to && e->links_to->name ?
+ 			       e->links_to->name : "(?)",
+ 			       e->class && e->class->name ? e->class->name :
+ 			       "(?)");
+ 			return false;
+ 		}
+ 	}
+ 	return true;
+ }
+ 
+ #ifdef CONFIG_PROVE_LOCKING
+ static u16 chain_hlocks[MAX_LOCKDEP_CHAIN_HLOCKS];
+ #endif
+ 
+ static bool check_lock_chain_key(struct lock_chain *chain)
+ {
+ #ifdef CONFIG_PROVE_LOCKING
+ 	u64 chain_key = 0;
+ 	int i;
+ 
+ 	for (i = chain->base; i < chain->base + chain->depth; i++)
+ 		chain_key = iterate_chain_key(chain_key, chain_hlocks[i] + 1);
+ 	/*
+ 	 * The 'unsigned long long' casts avoid that a compiler warning
+ 	 * is reported when building tools/lib/lockdep.
+ 	 */
+ 	if (chain->chain_key != chain_key) {
+ 		printk(KERN_INFO "chain %lld: key %#llx <> %#llx\n",
+ 		       (unsigned long long)(chain - lock_chains),
+ 		       (unsigned long long)chain->chain_key,
+ 		       (unsigned long long)chain_key);
+ 		return false;
+ 	}
+ #endif
+ 	return true;
+ }
+ 
+ static bool in_any_zapped_class_list(struct lock_class *class)
+ {
+ 	struct pending_free *pf;
+ 	int i;
+ 
+ 	for (i = 0, pf = delayed_free.pf; i < ARRAY_SIZE(delayed_free.pf); i++, pf++) {
+ 		if (in_list(&class->lock_entry, &pf->zapped))
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static bool __check_data_structures(void)
+ {
+ 	struct lock_class *class;
+ 	struct lock_chain *chain;
+ 	struct hlist_head *head;
+ 	struct lock_list *e;
+ 	int i;
+ 
+ 	/* Check whether all classes occur in a lock list. */
+ 	for (i = 0; i < ARRAY_SIZE(lock_classes); i++) {
+ 		class = &lock_classes[i];
+ 		if (!in_list(&class->lock_entry, &all_lock_classes) &&
+ 		    !in_list(&class->lock_entry, &free_lock_classes) &&
+ 		    !in_any_zapped_class_list(class)) {
+ 			printk(KERN_INFO "class %px/%s is not in any class list\n",
+ 			       class, class->name ? : "(?)");
+ 			return false;
+ 		}
+ 	}
+ 
+ 	/* Check whether all classes have valid lock lists. */
+ 	for (i = 0; i < ARRAY_SIZE(lock_classes); i++) {
+ 		class = &lock_classes[i];
+ 		if (!class_lock_list_valid(class, &class->locks_before))
+ 			return false;
+ 		if (!class_lock_list_valid(class, &class->locks_after))
+ 			return false;
+ 	}
+ 
+ 	/* Check the chain_key of all lock chains. */
+ 	for (i = 0; i < ARRAY_SIZE(chainhash_table); i++) {
+ 		head = chainhash_table + i;
+ 		hlist_for_each_entry_rcu(chain, head, entry) {
+ 			if (!check_lock_chain_key(chain))
+ 				return false;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Check whether all list entries that are in use occur in a class
+ 	 * lock list.
+ 	 */
+ 	for_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {
+ 		e = list_entries + i;
+ 		if (!in_any_class_list(&e->entry)) {
+ 			printk(KERN_INFO "list entry %d is not in any class list; class %s <> %s\n",
+ 			       (unsigned int)(e - list_entries),
+ 			       e->class->name ? : "(?)",
+ 			       e->links_to->name ? : "(?)");
+ 			return false;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Check whether all list entries that are not in use do not occur in
+ 	 * a class lock list.
+ 	 */
+ 	for_each_clear_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {
+ 		e = list_entries + i;
+ 		if (in_any_class_list(&e->entry)) {
+ 			printk(KERN_INFO "list entry %d occurs in a class list; class %s <> %s\n",
+ 			       (unsigned int)(e - list_entries),
+ 			       e->class && e->class->name ? e->class->name :
+ 			       "(?)",
+ 			       e->links_to && e->links_to->name ?
+ 			       e->links_to->name : "(?)");
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ int check_consistency = 0;
+ module_param(check_consistency, int, 0644);
+ 
+ static void check_data_structures(void)
+ {
+ 	static bool once = false;
+ 
+ 	if (check_consistency && !once) {
+ 		if (!__check_data_structures()) {
+ 			once = true;
+ 			WARN_ON(once);
+ 		}
+ 	}
+ }
+ 
+ #else /* CONFIG_DEBUG_LOCKDEP */
+ 
+ static inline void check_data_structures(void) { }
+ 
+ #endif /* CONFIG_DEBUG_LOCKDEP */
+ 
+ /*
+  * Initialize the lock_classes[] array elements, the free_lock_classes list
+  * and also the delayed_free structure.
++>>>>>>> 3fe7522fb766 (locking/lockdep: Avoid a Clang warning)
   */
  static void init_data_structures_once(void)
  {
* Unmerged path kernel/locking/lockdep.c
