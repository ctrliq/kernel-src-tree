pps: Fix a use-after-free

jira LE-12345
Rebuild_History Non-Buildable kernel-5.14.0-570.12.1.el9_6
commit-author Calvin Owens <calvin@wbinvd.org>
commit c79a39dc8d060b9e64e8b0fa9d245d44befeefbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.12.1.el9_6/c79a39dc.failed

On a board running ntpd and gpsd, I'm seeing a consistent use-after-free
in sys_exit() from gpsd when rebooting:

    pps pps1: removed
    ------------[ cut here ]------------
    kobject: '(null)' (00000000db4bec24): is not initialized, yet kobject_put() is being called.
    WARNING: CPU: 2 PID: 440 at lib/kobject.c:734 kobject_put+0x120/0x150
    CPU: 2 UID: 299 PID: 440 Comm: gpsd Not tainted 6.11.0-rc6-00308-gb31c44928842 #1
    Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT)
    pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : kobject_put+0x120/0x150
    lr : kobject_put+0x120/0x150
    sp : ffffffc0803d3ae0
    x29: ffffffc0803d3ae0 x28: ffffff8042dc9738 x27: 0000000000000001
    x26: 0000000000000000 x25: ffffff8042dc9040 x24: ffffff8042dc9440
    x23: ffffff80402a4620 x22: ffffff8042ef4bd0 x21: ffffff80405cb600
    x20: 000000000008001b x19: ffffff8040b3b6e0 x18: 0000000000000000
    x17: 0000000000000000 x16: 0000000000000000 x15: 696e6920746f6e20
    x14: 7369203a29343263 x13: 205d303434542020 x12: 0000000000000000
    x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
    x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000
    x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000
    x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000
    Call trace:
     kobject_put+0x120/0x150
     cdev_put+0x20/0x3c
     __fput+0x2c4/0x2d8
     ____fput+0x1c/0x38
     task_work_run+0x70/0xfc
     do_exit+0x2a0/0x924
     do_group_exit+0x34/0x90
     get_signal+0x7fc/0x8c0
     do_signal+0x128/0x13b4
     do_notify_resume+0xdc/0x160
     el0_svc+0xd4/0xf8
     el0t_64_sync_handler+0x140/0x14c
     el0t_64_sync+0x190/0x194
    ---[ end trace 0000000000000000 ]---

...followed by more symptoms of corruption, with similar stacks:

    refcount_t: underflow; use-after-free.
    kernel BUG at lib/list_debug.c:62!
    Kernel panic - not syncing: Oops - BUG: Fatal exception

This happens because pps_device_destruct() frees the pps_device with the
embedded cdev immediately after calling cdev_del(), but, as the comment
above cdev_del() notes, fops for previously opened cdevs are still
callable even after cdev_del() returns. I think this bug has always
been there: I can't explain why it suddenly started happening every time
I reboot this particular board.

In commit d953e0e837e6 ("pps: Fix a use-after free bug when
unregistering a source."), George Spelvin suggested removing the
embedded cdev. That seems like the simplest way to fix this, so I've
implemented his suggestion, using __register_chrdev() with pps_idr
becoming the source of truth for which minor corresponds to which
device.

But now that pps_idr defines userspace visibility instead of cdev_add(),
we need to be sure the pps->dev refcount can't reach zero while
userspace can still find it again. So, the idr_remove() call moves to
pps_unregister_cdev(), and pps_idr now holds a reference to pps->dev.

    pps_core: source serial1 got cdev (251:1)
    <...>
    pps pps1: removed
    pps_core: unregistering pps1
    pps_core: deallocating pps1

Fixes: d953e0e837e6 ("pps: Fix a use-after free bug when unregistering a source.")
	Cc: stable@vger.kernel.org
	Signed-off-by: Calvin Owens <calvin@wbinvd.org>
	Reviewed-by: Michal Schmidt <mschmidt@redhat.com>
Link: https://lore.kernel.org/r/a17975fd5ae99385791929e563f72564edbcf28f.1731383727.git.calvin@wbinvd.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c79a39dc8d060b9e64e8b0fa9d245d44befeefbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ptp/ptp_ocp.c
diff --cc drivers/ptp/ptp_ocp.c
index 0d1034e3ed0f,120db96d9e95..000000000000
--- a/drivers/ptp/ptp_ocp.c
+++ b/drivers/ptp/ptp_ocp.c
@@@ -254,36 -1630,2807 +254,2828 @@@ ptp_ocp_tod_info(struct ptp_ocp *bp
  	ctrl &= ~(TOD_CTRL_DISABLE_FMT_A | TOD_CTRL_DISABLE_FMT_B);
  	iowrite32(ctrl, &bp->tod->ctrl);
  
 +	ctrl = ioread32(&bp->tod->ctrl);
 +	idx = ctrl & TOD_CTRL_PROTOCOL ? 4 : 0;
 +	idx += (ctrl >> 16) & 3;
 +	dev_info(&bp->pdev->dev, "control: %x\n", ctrl);
 +	dev_info(&bp->pdev->dev, "TOD Protocol %s %s\n", proto_name[idx],
 +		 ctrl & TOD_CTRL_ENABLE ? "enabled" : "");
 +
 +	idx = (ctrl >> TOD_CTRL_GNSS_SHIFT) & TOD_CTRL_GNSS_MASK;
 +	if (idx < ARRAY_SIZE(gnss_name))
 +		dev_info(&bp->pdev->dev, "GNSS %s\n", gnss_name[idx]);
 +
 +	reg = ioread32(&bp->tod->status);
 +	dev_info(&bp->pdev->dev, "status: %x\n", reg);
 +
 +	reg = ioread32(&bp->tod->correction_sec);
 +	dev_info(&bp->pdev->dev, "correction: %d\n", reg);
 +
  	reg = ioread32(&bp->tod->utc_status);
 -	if (reg & TOD_STATUS_UTC_VALID)
 -		ptp_ocp_utc_distribute(bp, reg & TOD_STATUS_UTC_MASK);
 +	dev_info(&bp->pdev->dev, "utc_status: %x\n", reg);
 +	dev_info(&bp->pdev->dev, "utc_offset: %d  valid:%d  leap_valid:%d\n",
 +		 reg & TOD_STATUS_UTC_MASK, reg & TOD_STATUS_UTC_VALID ? 1 : 0,
 +		 reg & TOD_STATUS_LEAP_VALID ? 1 : 0);
  }
  
 -static const char *
 -ptp_ocp_tod_proto_name(const int idx)
 +static void
 +ptp_ocp_info(struct ptp_ocp *bp)
  {
 -	static const char * const proto_name[] = {
 -		"NMEA", "NMEA_ZDA", "NMEA_RMC", "NMEA_none",
 -		"UBX", "UBX_UTC", "UBX_LS", "UBX_none"
 +	static const char * const clock_name[] = {
 +		"NO", "TOD", "IRIG", "PPS", "PTP", "RTC", "REGS", "EXT"
  	};
++<<<<<<< HEAD
++=======
+ 	return proto_name[idx];
+ }
+ 
+ static const char *
+ ptp_ocp_tod_gnss_name(int idx)
+ {
+ 	static const char * const gnss_name[] = {
+ 		"ALL", "COMBINED", "GPS", "GLONASS", "GALILEO", "BEIDOU",
+ 		"Unknown"
+ 	};
+ 	if (idx >= ARRAY_SIZE(gnss_name))
+ 		idx = ARRAY_SIZE(gnss_name) - 1;
+ 	return gnss_name[idx];
+ }
+ 
+ static const char *
+ ptp_ocp_tty_port_name(int idx)
+ {
+ 	static const char * const tty_name[] = {
+ 		"GNSS", "GNSS2", "MAC", "NMEA"
+ 	};
+ 	return tty_name[idx];
+ }
+ 
+ struct ptp_ocp_nvmem_match_info {
+ 	struct ptp_ocp *bp;
+ 	const void * const tag;
+ };
+ 
+ static int
+ ptp_ocp_nvmem_match(struct device *dev, const void *data)
+ {
+ 	const struct ptp_ocp_nvmem_match_info *info = data;
+ 
+ 	dev = dev->parent;
+ 	if (!i2c_verify_client(dev) || info->tag != dev->platform_data)
+ 		return 0;
+ 
+ 	while ((dev = dev->parent))
+ 		if (dev->driver && !strcmp(dev->driver->name, KBUILD_MODNAME))
+ 			return info->bp == dev_get_drvdata(dev);
+ 	return 0;
+ }
+ 
+ static inline struct nvmem_device *
+ ptp_ocp_nvmem_device_get(struct ptp_ocp *bp, const void * const tag)
+ {
+ 	struct ptp_ocp_nvmem_match_info info = { .bp = bp, .tag = tag };
+ 
+ 	return nvmem_device_find(&info, ptp_ocp_nvmem_match);
+ }
+ 
+ static inline void
+ ptp_ocp_nvmem_device_put(struct nvmem_device **nvmemp)
+ {
+ 	if (!IS_ERR_OR_NULL(*nvmemp))
+ 		nvmem_device_put(*nvmemp);
+ 	*nvmemp = NULL;
+ }
+ 
+ static void
+ ptp_ocp_read_eeprom(struct ptp_ocp *bp)
+ {
+ 	const struct ptp_ocp_eeprom_map *map;
+ 	struct nvmem_device *nvmem;
+ 	const void *tag;
+ 	int ret;
+ 
+ 	if (!bp->i2c_ctrl)
+ 		return;
+ 
+ 	tag = NULL;
+ 	nvmem = NULL;
+ 
+ 	for (map = bp->eeprom_map; map->len; map++) {
+ 		if (map->tag != tag) {
+ 			tag = map->tag;
+ 			ptp_ocp_nvmem_device_put(&nvmem);
+ 		}
+ 		if (!nvmem) {
+ 			nvmem = ptp_ocp_nvmem_device_get(bp, tag);
+ 			if (IS_ERR(nvmem)) {
+ 				ret = PTR_ERR(nvmem);
+ 				goto fail;
+ 			}
+ 		}
+ 		ret = nvmem_device_read(nvmem, map->off, map->len,
+ 					BP_MAP_ENTRY_ADDR(bp, map));
+ 		if (ret != map->len)
+ 			goto fail;
+ 	}
+ 
+ 	bp->has_eeprom_data = true;
+ 
+ out:
+ 	ptp_ocp_nvmem_device_put(&nvmem);
+ 	return;
+ 
+ fail:
+ 	dev_err(&bp->pdev->dev, "could not read eeprom: %d\n", ret);
+ 	goto out;
+ }
+ 
+ static struct device *
+ ptp_ocp_find_flash(struct ptp_ocp *bp)
+ {
+ 	struct device *dev, *last;
+ 
+ 	last = NULL;
+ 	dev = &bp->spi_flash->dev;
+ 
+ 	while ((dev = device_find_any_child(dev))) {
+ 		if (!strcmp("mtd", dev_bus_name(dev)))
+ 			break;
+ 		put_device(last);
+ 		last = dev;
+ 	}
+ 	put_device(last);
+ 
+ 	return dev;
+ }
+ 
+ static int
+ ptp_ocp_devlink_fw_image(struct devlink *devlink, const struct firmware *fw,
+ 			 const u8 **data, size_t *size)
+ {
+ 	struct ptp_ocp *bp = devlink_priv(devlink);
+ 	const struct ptp_ocp_firmware_header *hdr;
+ 	size_t offset, length;
+ 	u16 crc;
+ 
+ 	hdr = (const struct ptp_ocp_firmware_header *)fw->data;
+ 	if (memcmp(hdr->magic, OCP_FIRMWARE_MAGIC_HEADER, 4)) {
+ 		devlink_flash_update_status_notify(devlink,
+ 			"No firmware header found, cancel firmware upgrade",
+ 			NULL, 0, 0);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (be16_to_cpu(hdr->pci_vendor_id) != bp->pdev->vendor ||
+ 	    be16_to_cpu(hdr->pci_device_id) != bp->pdev->device) {
+ 		devlink_flash_update_status_notify(devlink,
+ 			"Firmware image compatibility check failed",
+ 			NULL, 0, 0);
+ 		return -EINVAL;
+ 	}
+ 
+ 	offset = sizeof(*hdr);
+ 	length = be32_to_cpu(hdr->image_size);
+ 	if (length != (fw->size - offset)) {
+ 		devlink_flash_update_status_notify(devlink,
+ 			"Firmware image size check failed",
+ 			NULL, 0, 0);
+ 		return -EINVAL;
+ 	}
+ 
+ 	crc = crc16(0xffff, &fw->data[offset], length);
+ 	if (be16_to_cpu(hdr->crc) != crc) {
+ 		devlink_flash_update_status_notify(devlink,
+ 			"Firmware image CRC check failed",
+ 			NULL, 0, 0);
+ 		return -EINVAL;
+ 	}
+ 
+ 	*data = &fw->data[offset];
+ 	*size = length;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ptp_ocp_devlink_flash(struct devlink *devlink, struct device *dev,
+ 		      const struct firmware *fw)
+ {
+ 	struct mtd_info *mtd = dev_get_drvdata(dev);
+ 	struct ptp_ocp *bp = devlink_priv(devlink);
+ 	size_t off, len, size, resid, wrote;
+ 	struct erase_info erase;
+ 	size_t base, blksz;
+ 	const u8 *data;
+ 	int err;
+ 
+ 	err = ptp_ocp_devlink_fw_image(devlink, fw, &data, &size);
+ 	if (err)
+ 		goto out;
+ 
+ 	off = 0;
+ 	base = bp->flash_start;
+ 	blksz = 4096;
+ 	resid = size;
+ 
+ 	while (resid) {
+ 		devlink_flash_update_status_notify(devlink, "Flashing",
+ 						   NULL, off, size);
+ 
+ 		len = min_t(size_t, resid, blksz);
+ 		erase.addr = base + off;
+ 		erase.len = blksz;
+ 
+ 		err = mtd_erase(mtd, &erase);
+ 		if (err)
+ 			goto out;
+ 
+ 		err = mtd_write(mtd, base + off, len, &wrote, data + off);
+ 		if (err)
+ 			goto out;
+ 
+ 		off += blksz;
+ 		resid -= len;
+ 	}
+ out:
+ 	return err;
+ }
+ 
+ static int
+ ptp_ocp_devlink_flash_update(struct devlink *devlink,
+ 			     struct devlink_flash_update_params *params,
+ 			     struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp *bp = devlink_priv(devlink);
+ 	struct device *dev;
+ 	const char *msg;
+ 	int err;
+ 
+ 	dev = ptp_ocp_find_flash(bp);
+ 	if (!dev) {
+ 		dev_err(&bp->pdev->dev, "Can't find Flash SPI adapter\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	devlink_flash_update_status_notify(devlink, "Preparing to flash",
+ 					   NULL, 0, 0);
+ 
+ 	err = ptp_ocp_devlink_flash(devlink, dev, params->fw);
+ 
+ 	msg = err ? "Flash error" : "Flash complete";
+ 	devlink_flash_update_status_notify(devlink, msg, NULL, 0, 0);
+ 
+ 	put_device(dev);
+ 	return err;
+ }
+ 
+ static int
+ ptp_ocp_devlink_info_get(struct devlink *devlink, struct devlink_info_req *req,
+ 			 struct netlink_ext_ack *extack)
+ {
+ 	struct ptp_ocp *bp = devlink_priv(devlink);
+ 	const char *fw_image;
+ 	char buf[32];
+ 	int err;
+ 
+ 	fw_image = bp->fw_loader ? "loader" : "fw";
+ 	sprintf(buf, "%d.%d", bp->fw_tag, bp->fw_version);
+ 	err = devlink_info_version_running_put(req, fw_image, buf);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!bp->has_eeprom_data) {
+ 		ptp_ocp_read_eeprom(bp);
+ 		if (!bp->has_eeprom_data)
+ 			return 0;
+ 	}
+ 
+ 	sprintf(buf, "%pM", bp->serial);
+ 	err = devlink_info_serial_number_put(req, buf);
+ 	if (err)
+ 		return err;
+ 
+ 	err = devlink_info_version_fixed_put(req,
+ 			DEVLINK_INFO_VERSION_GENERIC_BOARD_ID,
+ 			bp->board_id);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ static const struct devlink_ops ptp_ocp_devlink_ops = {
+ 	.flash_update = ptp_ocp_devlink_flash_update,
+ 	.info_get = ptp_ocp_devlink_info_get,
+ };
+ 
+ static void __iomem *
+ __ptp_ocp_get_mem(struct ptp_ocp *bp, resource_size_t start, int size)
+ {
+ 	struct resource res = DEFINE_RES_MEM_NAMED(start, size, "ptp_ocp");
+ 
+ 	return devm_ioremap_resource(&bp->pdev->dev, &res);
+ }
+ 
+ static void __iomem *
+ ptp_ocp_get_mem(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	resource_size_t start;
+ 
+ 	start = pci_resource_start(bp->pdev, 0) + r->offset;
+ 	return __ptp_ocp_get_mem(bp, start, r->size);
+ }
+ 
+ static int
+ ptp_ocp_register_spi(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	struct ptp_ocp_flash_info *info;
+ 	struct pci_dev *pdev = bp->pdev;
+ 	struct platform_device *p;
+ 	struct resource res[2];
+ 	resource_size_t start;
+ 	int id;
+ 
+ 	start = pci_resource_start(pdev, 0) + r->offset;
+ 	res[0] = DEFINE_RES_MEM(start, r->size);
+ 	res[1] = DEFINE_RES_IRQ(pci_irq_vector(pdev, r->irq_vec));
+ 
+ 	info = r->extra;
+ 	id = pci_dev_id(pdev) << 1;
+ 	id += info->pci_offset;
+ 
+ 	p = platform_device_register_resndata(&pdev->dev, info->name, id,
+ 					      res, ARRAY_SIZE(res), info->data,
+ 					      info->data_size);
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
+ 	bp_assign_entry(bp, r, p);
+ 
+ 	return 0;
+ }
+ 
+ static struct platform_device *
+ ptp_ocp_i2c_bus(struct pci_dev *pdev, struct ocp_resource *r, int id)
+ {
+ 	struct ptp_ocp_i2c_info *info;
+ 	struct resource res[2];
+ 	resource_size_t start;
+ 
+ 	info = r->extra;
+ 	start = pci_resource_start(pdev, 0) + r->offset;
+ 	res[0] = DEFINE_RES_MEM(start, r->size);
+ 	res[1] = DEFINE_RES_IRQ(pci_irq_vector(pdev, r->irq_vec));
+ 
+ 	return platform_device_register_resndata(&pdev->dev, info->name,
+ 						 id, res, ARRAY_SIZE(res),
+ 						 info->data, info->data_size);
+ }
+ 
+ static int
+ ptp_ocp_register_i2c(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	struct pci_dev *pdev = bp->pdev;
+ 	struct ptp_ocp_i2c_info *info;
+ 	struct platform_device *p;
+ 	struct clk_hw *clk;
+ 	char buf[32];
+ 	int id;
+ 
+ 	info = r->extra;
+ 	id = pci_dev_id(bp->pdev);
+ 
+ 	sprintf(buf, "AXI.%d", id);
+ 	clk = clk_hw_register_fixed_rate(&pdev->dev, buf, NULL, 0,
+ 					 info->fixed_rate);
+ 	if (IS_ERR(clk))
+ 		return PTR_ERR(clk);
+ 	bp->i2c_clk = clk;
+ 
+ 	sprintf(buf, "%s.%d", info->name, id);
+ 	devm_clk_hw_register_clkdev(&pdev->dev, clk, NULL, buf);
+ 	p = ptp_ocp_i2c_bus(bp->pdev, r, id);
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
+ 	bp_assign_entry(bp, r, p);
+ 
+ 	return 0;
+ }
+ 
+ /* The expectation is that this is triggered only on error. */
+ static irqreturn_t
+ ptp_ocp_signal_irq(int irq, void *priv)
+ {
+ 	struct ptp_ocp_ext_src *ext = priv;
+ 	struct signal_reg __iomem *reg = ext->mem;
+ 	struct ptp_ocp *bp = ext->bp;
+ 	u32 enable, status;
+ 	int gen;
+ 
+ 	gen = ext->info->index - 1;
+ 
+ 	enable = ioread32(&reg->enable);
+ 	status = ioread32(&reg->status);
+ 
+ 	/* disable generator on error */
+ 	if (status || !enable) {
+ 		iowrite32(0, &reg->intr_mask);
+ 		iowrite32(0, &reg->enable);
+ 		bp->signal[gen].running = false;
+ 	}
+ 
+ 	iowrite32(0, &reg->intr);	/* ack interrupt */
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int
+ ptp_ocp_signal_set(struct ptp_ocp *bp, int gen, struct ptp_ocp_signal *s)
+ {
+ 	struct ptp_system_timestamp sts;
+ 	struct timespec64 ts;
+ 	ktime_t start_ns;
+ 	int err;
+ 
+ 	if (!s->period)
+ 		return 0;
+ 
+ 	if (!s->pulse)
+ 		s->pulse = ktime_divns(s->period * s->duty, 100);
+ 
+ 	err = ptp_ocp_gettimex(&bp->ptp_info, &ts, &sts);
+ 	if (err)
+ 		return err;
+ 
+ 	start_ns = ktime_set(ts.tv_sec, ts.tv_nsec) + NSEC_PER_MSEC;
+ 	if (!s->start) {
+ 		/* roundup() does not work on 32-bit systems */
+ 		s->start = DIV64_U64_ROUND_UP(start_ns, s->period);
+ 		s->start = ktime_add(s->start, s->phase);
+ 	}
+ 
+ 	if (s->duty < 1 || s->duty > 99)
+ 		return -EINVAL;
+ 
+ 	if (s->pulse < 1 || s->pulse > s->period)
+ 		return -EINVAL;
+ 
+ 	if (s->start < start_ns)
+ 		return -EINVAL;
+ 
+ 	bp->signal[gen] = *s;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ptp_ocp_signal_from_perout(struct ptp_ocp *bp, int gen,
+ 			   struct ptp_perout_request *req)
+ {
+ 	struct ptp_ocp_signal s = { };
+ 
+ 	s.polarity = bp->signal[gen].polarity;
+ 	s.period = ktime_set(req->period.sec, req->period.nsec);
+ 	if (!s.period)
+ 		return 0;
+ 
+ 	if (req->flags & PTP_PEROUT_DUTY_CYCLE) {
+ 		s.pulse = ktime_set(req->on.sec, req->on.nsec);
+ 		s.duty = ktime_divns(s.pulse * 100, s.period);
+ 	}
+ 
+ 	if (req->flags & PTP_PEROUT_PHASE)
+ 		s.phase = ktime_set(req->phase.sec, req->phase.nsec);
+ 	else
+ 		s.start = ktime_set(req->start.sec, req->start.nsec);
+ 
+ 	return ptp_ocp_signal_set(bp, gen, &s);
+ }
+ 
+ static int
+ ptp_ocp_signal_enable(void *priv, u32 req, bool enable)
+ {
+ 	struct ptp_ocp_ext_src *ext = priv;
+ 	struct signal_reg __iomem *reg = ext->mem;
+ 	struct ptp_ocp *bp = ext->bp;
+ 	struct timespec64 ts;
+ 	int gen;
+ 
+ 	gen = ext->info->index - 1;
+ 
+ 	iowrite32(0, &reg->intr_mask);
+ 	iowrite32(0, &reg->enable);
+ 	bp->signal[gen].running = false;
+ 	if (!enable)
+ 		return 0;
+ 
+ 	ts = ktime_to_timespec64(bp->signal[gen].start);
+ 	iowrite32(ts.tv_sec, &reg->start_sec);
+ 	iowrite32(ts.tv_nsec, &reg->start_ns);
+ 
+ 	ts = ktime_to_timespec64(bp->signal[gen].period);
+ 	iowrite32(ts.tv_sec, &reg->period_sec);
+ 	iowrite32(ts.tv_nsec, &reg->period_ns);
+ 
+ 	ts = ktime_to_timespec64(bp->signal[gen].pulse);
+ 	iowrite32(ts.tv_sec, &reg->pulse_sec);
+ 	iowrite32(ts.tv_nsec, &reg->pulse_ns);
+ 
+ 	iowrite32(bp->signal[gen].polarity, &reg->polarity);
+ 	iowrite32(0, &reg->repeat_count);
+ 
+ 	iowrite32(0, &reg->intr);		/* clear interrupt state */
+ 	iowrite32(1, &reg->intr_mask);		/* enable interrupt */
+ 	iowrite32(3, &reg->enable);		/* valid & enable */
+ 
+ 	bp->signal[gen].running = true;
+ 
+ 	return 0;
+ }
+ 
+ static irqreturn_t
+ ptp_ocp_ts_irq(int irq, void *priv)
+ {
+ 	struct ptp_ocp_ext_src *ext = priv;
+ 	struct ts_reg __iomem *reg = ext->mem;
+ 	struct ptp_clock_event ev;
+ 	u32 sec, nsec;
+ 
+ 	if (ext == ext->bp->pps) {
+ 		if (ext->bp->pps_req_map & OCP_REQ_PPS) {
+ 			ev.type = PTP_CLOCK_PPS;
+ 			ptp_clock_event(ext->bp->ptp, &ev);
+ 		}
+ 
+ 		if ((ext->bp->pps_req_map & ~OCP_REQ_PPS) == 0)
+ 			goto out;
+ 	}
+ 
+ 	/* XXX should fix API - this converts s/ns -> ts -> s/ns */
+ 	sec = ioread32(&reg->time_sec);
+ 	nsec = ioread32(&reg->time_ns);
+ 
+ 	ev.type = PTP_CLOCK_EXTTS;
+ 	ev.index = ext->info->index;
+ 	ev.timestamp = sec * NSEC_PER_SEC + nsec;
+ 
+ 	ptp_clock_event(ext->bp->ptp, &ev);
+ 
+ out:
+ 	iowrite32(1, &reg->intr);	/* write 1 to ack */
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int
+ ptp_ocp_ts_enable(void *priv, u32 req, bool enable)
+ {
+ 	struct ptp_ocp_ext_src *ext = priv;
+ 	struct ts_reg __iomem *reg = ext->mem;
+ 	struct ptp_ocp *bp = ext->bp;
+ 
+ 	if (ext == bp->pps) {
+ 		u32 old_map = bp->pps_req_map;
+ 
+ 		if (enable)
+ 			bp->pps_req_map |= req;
+ 		else
+ 			bp->pps_req_map &= ~req;
+ 
+ 		/* if no state change, just return */
+ 		if ((!!old_map ^ !!bp->pps_req_map) == 0)
+ 			return 0;
+ 	}
+ 
+ 	if (enable) {
+ 		iowrite32(1, &reg->enable);
+ 		iowrite32(1, &reg->intr_mask);
+ 		iowrite32(1, &reg->intr);
+ 	} else {
+ 		iowrite32(0, &reg->intr_mask);
+ 		iowrite32(0, &reg->enable);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ ptp_ocp_unregister_ext(struct ptp_ocp_ext_src *ext)
+ {
+ 	ext->info->enable(ext, ~0, false);
+ 	pci_free_irq(ext->bp->pdev, ext->irq_vec, ext);
+ 	kfree(ext);
+ }
+ 
+ static int
+ ptp_ocp_register_ext(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	struct pci_dev *pdev = bp->pdev;
+ 	struct ptp_ocp_ext_src *ext;
+ 	int err;
+ 
+ 	ext = kzalloc(sizeof(*ext), GFP_KERNEL);
+ 	if (!ext)
+ 		return -ENOMEM;
+ 
+ 	ext->mem = ptp_ocp_get_mem(bp, r);
+ 	if (IS_ERR(ext->mem)) {
+ 		err = PTR_ERR(ext->mem);
+ 		goto out;
+ 	}
+ 
+ 	ext->bp = bp;
+ 	ext->info = r->extra;
+ 	ext->irq_vec = r->irq_vec;
+ 
+ 	err = pci_request_irq(pdev, r->irq_vec, ext->info->irq_fcn, NULL,
+ 			      ext, "ocp%d.%s", bp->id, r->name);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Could not get irq %d\n", r->irq_vec);
+ 		goto out;
+ 	}
+ 
+ 	bp_assign_entry(bp, r, ext);
+ 
+ 	return 0;
+ 
+ out:
+ 	kfree(ext);
+ 	return err;
+ }
+ 
+ static int
+ ptp_ocp_serial_line(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	struct pci_dev *pdev = bp->pdev;
+ 	struct uart_8250_port uart;
+ 
+ 	/* Setting UPF_IOREMAP and leaving port.membase unspecified lets
+ 	 * the serial port device claim and release the pci resource.
+ 	 */
+ 	memset(&uart, 0, sizeof(uart));
+ 	uart.port.dev = &pdev->dev;
+ 	uart.port.iotype = UPIO_MEM;
+ 	uart.port.regshift = 2;
+ 	uart.port.mapbase = pci_resource_start(pdev, 0) + r->offset;
+ 	uart.port.irq = pci_irq_vector(pdev, r->irq_vec);
+ 	uart.port.uartclk = 50000000;
+ 	uart.port.flags = UPF_FIXED_TYPE | UPF_IOREMAP | UPF_NO_THRE_TEST;
+ 	uart.port.type = PORT_16550A;
+ 
+ 	return serial8250_register_8250_port(&uart);
+ }
+ 
+ static int
+ ptp_ocp_register_serial(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	struct ptp_ocp_serial_port *p = (struct ptp_ocp_serial_port *)r->extra;
+ 	struct ptp_ocp_serial_port port = {};
+ 
+ 	port.line = ptp_ocp_serial_line(bp, r);
+ 	if (port.line < 0)
+ 		return port.line;
+ 
+ 	if (p)
+ 		port.baud = p->baud;
+ 
+ 	bp_assign_entry(bp, r, port);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ptp_ocp_register_mem(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	void __iomem *mem;
+ 
+ 	mem = ptp_ocp_get_mem(bp, r);
+ 	if (IS_ERR(mem))
+ 		return PTR_ERR(mem);
+ 
+ 	bp_assign_entry(bp, r, mem);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ ptp_ocp_nmea_out_init(struct ptp_ocp *bp)
+ {
+ 	if (!bp->nmea_out)
+ 		return;
+ 
+ 	iowrite32(0, &bp->nmea_out->ctrl);		/* disable */
+ 	iowrite32(7, &bp->nmea_out->uart_baud);		/* 115200 */
+ 	iowrite32(1, &bp->nmea_out->ctrl);		/* enable */
+ }
+ 
+ static void
+ _ptp_ocp_signal_init(struct ptp_ocp_signal *s, struct signal_reg __iomem *reg)
+ {
+ 	u32 val;
+ 
+ 	iowrite32(0, &reg->enable);		/* disable */
+ 
+ 	val = ioread32(&reg->polarity);
+ 	s->polarity = val ? true : false;
+ 	s->duty = 50;
+ }
+ 
+ static void
+ ptp_ocp_signal_init(struct ptp_ocp *bp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < 4; i++)
+ 		if (bp->signal_out[i])
+ 			_ptp_ocp_signal_init(&bp->signal[i],
+ 					     bp->signal_out[i]->mem);
+ }
+ 
+ static void
+ ptp_ocp_attr_group_del(struct ptp_ocp *bp)
+ {
+ 	sysfs_remove_groups(&bp->dev.kobj, bp->attr_group);
+ 	kfree(bp->attr_group);
+ }
+ 
+ static int
+ ptp_ocp_attr_group_add(struct ptp_ocp *bp,
+ 		       const struct ocp_attr_group *attr_tbl)
+ {
+ 	int count, i;
+ 	int err;
+ 
+ 	count = 0;
+ 	for (i = 0; attr_tbl[i].cap; i++)
+ 		if (attr_tbl[i].cap & bp->fw_cap)
+ 			count++;
+ 
+ 	bp->attr_group = kcalloc(count + 1, sizeof(struct attribute_group *),
+ 				 GFP_KERNEL);
+ 	if (!bp->attr_group)
+ 		return -ENOMEM;
+ 
+ 	count = 0;
+ 	for (i = 0; attr_tbl[i].cap; i++)
+ 		if (attr_tbl[i].cap & bp->fw_cap)
+ 			bp->attr_group[count++] = attr_tbl[i].group;
+ 
+ 	err = sysfs_create_groups(&bp->dev.kobj, bp->attr_group);
+ 	if (err)
+ 		bp->attr_group[0] = NULL;
+ 
+ 	return err;
+ }
+ 
+ static void
+ ptp_ocp_enable_fpga(u32 __iomem *reg, u32 bit, bool enable)
+ {
+ 	u32 ctrl;
+ 	bool on;
+ 
+ 	ctrl = ioread32(reg);
+ 	on = ctrl & bit;
+ 	if (on ^ enable) {
+ 		ctrl &= ~bit;
+ 		ctrl |= enable ? bit : 0;
+ 		iowrite32(ctrl, reg);
+ 	}
+ }
+ 
+ static void
+ ptp_ocp_irig_out(struct ptp_ocp *bp, bool enable)
+ {
+ 	return ptp_ocp_enable_fpga(&bp->irig_out->ctrl,
+ 				   IRIG_M_CTRL_ENABLE, enable);
+ }
+ 
+ static void
+ ptp_ocp_irig_in(struct ptp_ocp *bp, bool enable)
+ {
+ 	return ptp_ocp_enable_fpga(&bp->irig_in->ctrl,
+ 				   IRIG_S_CTRL_ENABLE, enable);
+ }
+ 
+ static void
+ ptp_ocp_dcf_out(struct ptp_ocp *bp, bool enable)
+ {
+ 	return ptp_ocp_enable_fpga(&bp->dcf_out->ctrl,
+ 				   DCF_M_CTRL_ENABLE, enable);
+ }
+ 
+ static void
+ ptp_ocp_dcf_in(struct ptp_ocp *bp, bool enable)
+ {
+ 	return ptp_ocp_enable_fpga(&bp->dcf_in->ctrl,
+ 				   DCF_S_CTRL_ENABLE, enable);
+ }
+ 
+ static void
+ __handle_signal_outputs(struct ptp_ocp *bp, u32 val)
+ {
+ 	ptp_ocp_irig_out(bp, val & 0x00100010);
+ 	ptp_ocp_dcf_out(bp, val & 0x00200020);
+ }
+ 
+ static void
+ __handle_signal_inputs(struct ptp_ocp *bp, u32 val)
+ {
+ 	ptp_ocp_irig_in(bp, val & 0x00100010);
+ 	ptp_ocp_dcf_in(bp, val & 0x00200020);
+ }
+ 
+ static u32
+ ptp_ocp_sma_fb_get(struct ptp_ocp *bp, int sma_nr)
+ {
+ 	u32 __iomem *gpio;
+ 	u32 shift;
+ 
+ 	if (bp->sma[sma_nr - 1].fixed_fcn)
+ 		return (sma_nr - 1) & 1;
+ 
+ 	if (bp->sma[sma_nr - 1].mode == SMA_MODE_IN)
+ 		gpio = sma_nr > 2 ? &bp->sma_map2->gpio1 : &bp->sma_map1->gpio1;
+ 	else
+ 		gpio = sma_nr > 2 ? &bp->sma_map1->gpio2 : &bp->sma_map2->gpio2;
+ 	shift = sma_nr & 1 ? 0 : 16;
+ 
+ 	return (ioread32(gpio) >> shift) & 0xffff;
+ }
+ 
+ static int
+ ptp_ocp_sma_fb_set_output(struct ptp_ocp *bp, int sma_nr, u32 val)
+ {
+ 	u32 reg, mask, shift;
+ 	unsigned long flags;
+ 	u32 __iomem *gpio;
+ 
+ 	gpio = sma_nr > 2 ? &bp->sma_map1->gpio2 : &bp->sma_map2->gpio2;
+ 	shift = sma_nr & 1 ? 0 : 16;
+ 
+ 	mask = 0xffff << (16 - shift);
+ 
+ 	spin_lock_irqsave(&bp->lock, flags);
+ 
+ 	reg = ioread32(gpio);
+ 	reg = (reg & mask) | (val << shift);
+ 
+ 	__handle_signal_outputs(bp, reg);
+ 
+ 	iowrite32(reg, gpio);
+ 
+ 	spin_unlock_irqrestore(&bp->lock, flags);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ptp_ocp_sma_fb_set_inputs(struct ptp_ocp *bp, int sma_nr, u32 val)
+ {
+ 	u32 reg, mask, shift;
+ 	unsigned long flags;
+ 	u32 __iomem *gpio;
+ 
+ 	gpio = sma_nr > 2 ? &bp->sma_map2->gpio1 : &bp->sma_map1->gpio1;
+ 	shift = sma_nr & 1 ? 0 : 16;
+ 
+ 	mask = 0xffff << (16 - shift);
+ 
+ 	spin_lock_irqsave(&bp->lock, flags);
+ 
+ 	reg = ioread32(gpio);
+ 	reg = (reg & mask) | (val << shift);
+ 
+ 	__handle_signal_inputs(bp, reg);
+ 
+ 	iowrite32(reg, gpio);
+ 
+ 	spin_unlock_irqrestore(&bp->lock, flags);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ ptp_ocp_sma_fb_init(struct ptp_ocp *bp)
+ {
+ 	struct dpll_pin_properties prop = {
+ 		.board_label = NULL,
+ 		.type = DPLL_PIN_TYPE_EXT,
+ 		.capabilities = DPLL_PIN_CAPABILITIES_DIRECTION_CAN_CHANGE,
+ 		.freq_supported_num = ARRAY_SIZE(ptp_ocp_sma_freq),
+ 		.freq_supported = ptp_ocp_sma_freq,
+ 
+ 	};
+ 	u32 reg;
+ 	int i;
+ 
+ 	/* defaults */
+ 	for (i = 0; i < OCP_SMA_NUM; i++) {
+ 		bp->sma[i].default_fcn = i & 1;
+ 		bp->sma[i].dpll_prop = prop;
+ 		bp->sma[i].dpll_prop.board_label =
+ 			bp->ptp_info.pin_config[i].name;
+ 	}
+ 	bp->sma[0].mode = SMA_MODE_IN;
+ 	bp->sma[1].mode = SMA_MODE_IN;
+ 	bp->sma[2].mode = SMA_MODE_OUT;
+ 	bp->sma[3].mode = SMA_MODE_OUT;
+ 	/* If no SMA1 map, the pin functions and directions are fixed. */
+ 	if (!bp->sma_map1) {
+ 		for (i = 0; i < OCP_SMA_NUM; i++) {
+ 			bp->sma[i].fixed_fcn = true;
+ 			bp->sma[i].fixed_dir = true;
+ 			bp->sma[1].dpll_prop.capabilities &=
+ 				~DPLL_PIN_CAPABILITIES_DIRECTION_CAN_CHANGE;
+ 		}
+ 		return;
+ 	}
+ 
+ 	/* If SMA2 GPIO output map is all 1, it is not present.
+ 	 * This indicates the firmware has fixed direction SMA pins.
+ 	 */
+ 	reg = ioread32(&bp->sma_map2->gpio2);
+ 	if (reg == 0xffffffff) {
+ 		for (i = 0; i < OCP_SMA_NUM; i++)
+ 			bp->sma[i].fixed_dir = true;
+ 	} else {
+ 		reg = ioread32(&bp->sma_map1->gpio1);
+ 		bp->sma[0].mode = reg & BIT(15) ? SMA_MODE_IN : SMA_MODE_OUT;
+ 		bp->sma[1].mode = reg & BIT(31) ? SMA_MODE_IN : SMA_MODE_OUT;
+ 
+ 		reg = ioread32(&bp->sma_map1->gpio2);
+ 		bp->sma[2].mode = reg & BIT(15) ? SMA_MODE_OUT : SMA_MODE_IN;
+ 		bp->sma[3].mode = reg & BIT(31) ? SMA_MODE_OUT : SMA_MODE_IN;
+ 	}
+ }
+ 
+ static const struct ocp_sma_op ocp_fb_sma_op = {
+ 	.tbl		= { ptp_ocp_sma_in, ptp_ocp_sma_out },
+ 	.init		= ptp_ocp_sma_fb_init,
+ 	.get		= ptp_ocp_sma_fb_get,
+ 	.set_inputs	= ptp_ocp_sma_fb_set_inputs,
+ 	.set_output	= ptp_ocp_sma_fb_set_output,
+ };
+ 
+ static const struct ocp_sma_op ocp_adva_sma_op = {
+ 	.tbl		= { ptp_ocp_adva_sma_in, ptp_ocp_adva_sma_out },
+ 	.init		= ptp_ocp_sma_fb_init,
+ 	.get		= ptp_ocp_sma_fb_get,
+ 	.set_inputs	= ptp_ocp_sma_fb_set_inputs,
+ 	.set_output	= ptp_ocp_sma_fb_set_output,
+ };
+ 
+ static int
+ ptp_ocp_set_pins(struct ptp_ocp *bp)
+ {
+ 	struct ptp_pin_desc *config;
+ 	int i;
+ 
+ 	config = kcalloc(4, sizeof(*config), GFP_KERNEL);
+ 	if (!config)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		sprintf(config[i].name, "sma%d", i + 1);
+ 		config[i].index = i;
+ 	}
+ 
+ 	bp->ptp_info.n_pins = 4;
+ 	bp->ptp_info.pin_config = config;
+ 
+ 	return 0;
+ }
+ 
+ static void
+ ptp_ocp_fb_set_version(struct ptp_ocp *bp)
+ {
+ 	u64 cap = OCP_CAP_BASIC;
+ 	u32 version;
+ 
+ 	version = ioread32(&bp->image->version);
+ 
+ 	/* if lower 16 bits are empty, this is the fw loader. */
+ 	if ((version & 0xffff) == 0) {
+ 		version = version >> 16;
+ 		bp->fw_loader = true;
+ 	}
+ 
+ 	bp->fw_tag = version >> 15;
+ 	bp->fw_version = version & 0x7fff;
+ 
+ 	if (bp->fw_tag) {
+ 		/* FPGA firmware */
+ 		if (version >= 5)
+ 			cap |= OCP_CAP_SIGNAL | OCP_CAP_FREQ;
+ 	} else {
+ 		/* SOM firmware */
+ 		if (version >= 19)
+ 			cap |= OCP_CAP_SIGNAL;
+ 		if (version >= 20)
+ 			cap |= OCP_CAP_FREQ;
+ 	}
+ 
+ 	bp->fw_cap = cap;
+ }
+ 
+ /* FB specific board initializers; last "resource" registered. */
+ static int
+ ptp_ocp_fb_board_init(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	int err;
+ 
+ 	bp->flash_start = 1024 * 4096;
+ 	bp->eeprom_map = fb_eeprom_map;
+ 	bp->fw_version = ioread32(&bp->image->version);
+ 	bp->sma_op = &ocp_fb_sma_op;
+ 
+ 	ptp_ocp_fb_set_version(bp);
+ 
+ 	ptp_ocp_tod_init(bp);
+ 	ptp_ocp_nmea_out_init(bp);
+ 	ptp_ocp_signal_init(bp);
+ 
+ 	err = ptp_ocp_attr_group_add(bp, fb_timecard_groups);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ptp_ocp_set_pins(bp);
+ 	if (err)
+ 		return err;
+ 	ptp_ocp_sma_init(bp);
+ 
+ 	return ptp_ocp_init_clock(bp, r->extra);
+ }
+ 
+ static bool
+ ptp_ocp_allow_irq(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	bool allow = !r->irq_vec || r->irq_vec < bp->n_irqs;
+ 
+ 	if (!allow)
+ 		dev_err(&bp->pdev->dev, "irq %d out of range, skipping %s\n",
+ 			r->irq_vec, r->name);
+ 	return allow;
+ }
+ 
+ static int
+ ptp_ocp_register_resources(struct ptp_ocp *bp, kernel_ulong_t driver_data)
+ {
+ 	struct ocp_resource *r, *table;
+ 	int err = 0;
+ 
+ 	table = (struct ocp_resource *)driver_data;
+ 	for (r = table; r->setup; r++) {
+ 		if (!ptp_ocp_allow_irq(bp, r))
+ 			continue;
+ 		err = r->setup(bp, r);
+ 		if (err) {
+ 			dev_err(&bp->pdev->dev,
+ 				"Could not register %s: err %d\n",
+ 				r->name, err);
+ 			break;
+ 		}
+ 	}
+ 	return err;
+ }
+ 
+ static void
+ ptp_ocp_art_sma_init(struct ptp_ocp *bp)
+ {
+ 	struct dpll_pin_properties prop = {
+ 		.board_label = NULL,
+ 		.type = DPLL_PIN_TYPE_EXT,
+ 		.capabilities = 0,
+ 		.freq_supported_num = ARRAY_SIZE(ptp_ocp_sma_freq),
+ 		.freq_supported = ptp_ocp_sma_freq,
+ 
+ 	};
+ 	u32 reg;
+ 	int i;
+ 
+ 	/* defaults */
+ 	bp->sma[0].mode = SMA_MODE_IN;
+ 	bp->sma[1].mode = SMA_MODE_IN;
+ 	bp->sma[2].mode = SMA_MODE_OUT;
+ 	bp->sma[3].mode = SMA_MODE_OUT;
+ 
+ 	bp->sma[0].default_fcn = 0x08;	/* IN: 10Mhz */
+ 	bp->sma[1].default_fcn = 0x01;	/* IN: PPS1 */
+ 	bp->sma[2].default_fcn = 0x10;	/* OUT: 10Mhz */
+ 	bp->sma[3].default_fcn = 0x02;	/* OUT: PHC */
+ 
+ 	for (i = 0; i < OCP_SMA_NUM; i++) {
+ 		/* If no SMA map, the pin functions and directions are fixed. */
+ 		bp->sma[i].dpll_prop = prop;
+ 		bp->sma[i].dpll_prop.board_label =
+ 			bp->ptp_info.pin_config[i].name;
+ 		if (!bp->art_sma) {
+ 			bp->sma[i].fixed_fcn = true;
+ 			bp->sma[i].fixed_dir = true;
+ 			continue;
+ 		}
+ 		reg = ioread32(&bp->art_sma->map[i].gpio);
+ 
+ 		switch (reg & 0xff) {
+ 		case 0:
+ 			bp->sma[i].fixed_fcn = true;
+ 			bp->sma[i].fixed_dir = true;
+ 			break;
+ 		case 1:
+ 		case 8:
+ 			bp->sma[i].mode = SMA_MODE_IN;
+ 			bp->sma[i].dpll_prop.capabilities =
+ 				DPLL_PIN_CAPABILITIES_DIRECTION_CAN_CHANGE;
+ 			break;
+ 		default:
+ 			bp->sma[i].mode = SMA_MODE_OUT;
+ 			bp->sma[i].dpll_prop.capabilities =
+ 				DPLL_PIN_CAPABILITIES_DIRECTION_CAN_CHANGE;
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static u32
+ ptp_ocp_art_sma_get(struct ptp_ocp *bp, int sma_nr)
+ {
+ 	if (bp->sma[sma_nr - 1].fixed_fcn)
+ 		return bp->sma[sma_nr - 1].default_fcn;
+ 
+ 	return ioread32(&bp->art_sma->map[sma_nr - 1].gpio) & 0xff;
+ }
+ 
+ /* note: store 0 is considered invalid. */
+ static int
+ ptp_ocp_art_sma_set(struct ptp_ocp *bp, int sma_nr, u32 val)
+ {
+ 	unsigned long flags;
+ 	u32 __iomem *gpio;
+ 	int err = 0;
+ 	u32 reg;
+ 
+ 	val &= SMA_SELECT_MASK;
+ 	if (hweight32(val) > 1)
+ 		return -EINVAL;
+ 
+ 	gpio = &bp->art_sma->map[sma_nr - 1].gpio;
+ 
+ 	spin_lock_irqsave(&bp->lock, flags);
+ 	reg = ioread32(gpio);
+ 	if (((reg >> 16) & val) == 0) {
+ 		err = -EOPNOTSUPP;
+ 	} else {
+ 		reg = (reg & 0xff00) | (val & 0xff);
+ 		iowrite32(reg, gpio);
+ 	}
+ 	spin_unlock_irqrestore(&bp->lock, flags);
+ 
+ 	return err;
+ }
+ 
+ static const struct ocp_sma_op ocp_art_sma_op = {
+ 	.tbl		= { ptp_ocp_art_sma_in, ptp_ocp_art_sma_out },
+ 	.init		= ptp_ocp_art_sma_init,
+ 	.get		= ptp_ocp_art_sma_get,
+ 	.set_inputs	= ptp_ocp_art_sma_set,
+ 	.set_output	= ptp_ocp_art_sma_set,
+ };
+ 
+ /* ART specific board initializers; last "resource" registered. */
+ static int
+ ptp_ocp_art_board_init(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	int err;
+ 
+ 	bp->flash_start = 0x1000000;
+ 	bp->eeprom_map = art_eeprom_map;
+ 	bp->fw_cap = OCP_CAP_BASIC;
+ 	bp->fw_version = ioread32(&bp->reg->version);
+ 	bp->fw_tag = 2;
+ 	bp->sma_op = &ocp_art_sma_op;
+ 
+ 	/* Enable MAC serial port during initialisation */
+ 	iowrite32(1, &bp->board_config->mro50_serial_activate);
+ 
+ 	err = ptp_ocp_set_pins(bp);
+ 	if (err)
+ 		return err;
+ 	ptp_ocp_sma_init(bp);
+ 
+ 	err = ptp_ocp_attr_group_add(bp, art_timecard_groups);
+ 	if (err)
+ 		return err;
+ 
+ 	return ptp_ocp_init_clock(bp, r->extra);
+ }
+ 
+ /* ADVA specific board initializers; last "resource" registered. */
+ static int
+ ptp_ocp_adva_board_init(struct ptp_ocp *bp, struct ocp_resource *r)
+ {
+ 	int err;
+ 	u32 version;
+ 
+ 	bp->flash_start = 0xA00000;
+ 	bp->eeprom_map = fb_eeprom_map;
+ 	bp->sma_op = &ocp_adva_sma_op;
+ 
+ 	version = ioread32(&bp->image->version);
+ 	/* if lower 16 bits are empty, this is the fw loader. */
+ 	if ((version & 0xffff) == 0) {
+ 		version = version >> 16;
+ 		bp->fw_loader = true;
+ 	}
+ 	bp->fw_tag = 3;
+ 	bp->fw_version = version & 0xffff;
+ 	bp->fw_cap = OCP_CAP_BASIC | OCP_CAP_SIGNAL | OCP_CAP_FREQ;
+ 
+ 	ptp_ocp_tod_init(bp);
+ 	ptp_ocp_nmea_out_init(bp);
+ 	ptp_ocp_signal_init(bp);
+ 
+ 	err = ptp_ocp_attr_group_add(bp, adva_timecard_groups);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ptp_ocp_set_pins(bp);
+ 	if (err)
+ 		return err;
+ 	ptp_ocp_sma_init(bp);
+ 
+ 	return ptp_ocp_init_clock(bp, r->extra);
+ }
+ 
+ static ssize_t
+ ptp_ocp_show_output(const struct ocp_selector *tbl, u32 val, char *buf,
+ 		    int def_val)
+ {
+ 	const char *name;
+ 	ssize_t count;
+ 
+ 	count = sysfs_emit(buf, "OUT: ");
+ 	name = ptp_ocp_select_name_from_val(tbl, val);
+ 	if (!name)
+ 		name = ptp_ocp_select_name_from_val(tbl, def_val);
+ 	count += sysfs_emit_at(buf, count, "%s\n", name);
+ 	return count;
+ }
+ 
+ static ssize_t
+ ptp_ocp_show_inputs(const struct ocp_selector *tbl, u32 val, char *buf,
+ 		    int def_val)
+ {
+ 	const char *name;
+ 	ssize_t count;
+ 	int i;
+ 
+ 	count = sysfs_emit(buf, "IN: ");
+ 	for (i = 0; tbl[i].name; i++) {
+ 		if (val & tbl[i].value) {
+ 			name = tbl[i].name;
+ 			count += sysfs_emit_at(buf, count, "%s ", name);
+ 		}
+ 	}
+ 	if (!val && def_val >= 0) {
+ 		name = ptp_ocp_select_name_from_val(tbl, def_val);
+ 		count += sysfs_emit_at(buf, count, "%s ", name);
+ 	}
+ 	if (count)
+ 		count--;
+ 	count += sysfs_emit_at(buf, count, "\n");
+ 	return count;
+ }
+ 
+ static int
+ sma_parse_inputs(const struct ocp_selector * const tbl[], const char *buf,
+ 		 enum ptp_ocp_sma_mode *mode)
+ {
+ 	int idx, count, dir;
+ 	char **argv;
+ 	int ret;
+ 
+ 	argv = argv_split(GFP_KERNEL, buf, &count);
+ 	if (!argv)
+ 		return -ENOMEM;
+ 
+ 	ret = -EINVAL;
+ 	if (!count)
+ 		goto out;
+ 
+ 	idx = 0;
+ 	dir = *mode == SMA_MODE_IN ? 0 : 1;
+ 	if (!strcasecmp("IN:", argv[0])) {
+ 		dir = 0;
+ 		idx++;
+ 	}
+ 	if (!strcasecmp("OUT:", argv[0])) {
+ 		dir = 1;
+ 		idx++;
+ 	}
+ 	*mode = dir == 0 ? SMA_MODE_IN : SMA_MODE_OUT;
+ 
+ 	ret = 0;
+ 	for (; idx < count; idx++)
+ 		ret |= ptp_ocp_select_val_from_name(tbl[dir], argv[idx]);
+ 	if (ret < 0)
+ 		ret = -EINVAL;
+ 
+ out:
+ 	argv_free(argv);
+ 	return ret;
+ }
+ 
+ static ssize_t
+ ptp_ocp_sma_show(struct ptp_ocp *bp, int sma_nr, char *buf,
+ 		 int default_in_val, int default_out_val)
+ {
+ 	struct ptp_ocp_sma_connector *sma = &bp->sma[sma_nr - 1];
+ 	const struct ocp_selector * const *tbl;
+ 	u32 val;
+ 
+ 	tbl = bp->sma_op->tbl;
+ 	val = ptp_ocp_sma_get(bp, sma_nr) & SMA_SELECT_MASK;
+ 
+ 	if (sma->mode == SMA_MODE_IN) {
+ 		if (sma->disabled)
+ 			val = SMA_DISABLE;
+ 		return ptp_ocp_show_inputs(tbl[0], val, buf, default_in_val);
+ 	}
+ 
+ 	return ptp_ocp_show_output(tbl[1], val, buf, default_out_val);
+ }
+ 
+ static ssize_t
+ sma1_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return ptp_ocp_sma_show(bp, 1, buf, 0, 1);
+ }
+ 
+ static ssize_t
+ sma2_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return ptp_ocp_sma_show(bp, 2, buf, -1, 1);
+ }
+ 
+ static ssize_t
+ sma3_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return ptp_ocp_sma_show(bp, 3, buf, -1, 0);
+ }
+ 
+ static ssize_t
+ sma4_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return ptp_ocp_sma_show(bp, 4, buf, -1, 1);
+ }
+ 
+ static int
+ ptp_ocp_sma_store_val(struct ptp_ocp *bp, int val, enum ptp_ocp_sma_mode mode, int sma_nr)
+ {
+ 	struct ptp_ocp_sma_connector *sma = &bp->sma[sma_nr - 1];
+ 
+ 	if (sma->fixed_dir && (mode != sma->mode || val & SMA_DISABLE))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (sma->fixed_fcn) {
+ 		if (val != sma->default_fcn)
+ 			return -EOPNOTSUPP;
+ 		return 0;
+ 	}
+ 
+ 	sma->disabled = !!(val & SMA_DISABLE);
+ 
+ 	if (mode != sma->mode) {
+ 		if (mode == SMA_MODE_IN)
+ 			ptp_ocp_sma_set_output(bp, sma_nr, 0);
+ 		else
+ 			ptp_ocp_sma_set_inputs(bp, sma_nr, 0);
+ 		sma->mode = mode;
+ 	}
+ 
+ 	if (!sma->fixed_dir)
+ 		val |= SMA_ENABLE;		/* add enable bit */
+ 
+ 	if (sma->disabled)
+ 		val = 0;
+ 
+ 	if (mode == SMA_MODE_IN)
+ 		val = ptp_ocp_sma_set_inputs(bp, sma_nr, val);
+ 	else
+ 		val = ptp_ocp_sma_set_output(bp, sma_nr, val);
+ 
+ 	return val;
+ }
+ 
+ static int
+ ptp_ocp_sma_store(struct ptp_ocp *bp, const char *buf, int sma_nr)
+ {
+ 	struct ptp_ocp_sma_connector *sma = &bp->sma[sma_nr - 1];
+ 	enum ptp_ocp_sma_mode mode;
+ 	int val;
+ 
+ 	mode = sma->mode;
+ 	val = sma_parse_inputs(bp->sma_op->tbl, buf, &mode);
+ 	if (val < 0)
+ 		return val;
+ 	return ptp_ocp_sma_store_val(bp, val, mode, sma_nr);
+ }
+ 
+ static ssize_t
+ sma1_store(struct device *dev, struct device_attribute *attr,
+ 	   const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = ptp_ocp_sma_store(bp, buf, 1);
+ 	return err ? err : count;
+ }
+ 
+ static ssize_t
+ sma2_store(struct device *dev, struct device_attribute *attr,
+ 	   const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = ptp_ocp_sma_store(bp, buf, 2);
+ 	return err ? err : count;
+ }
+ 
+ static ssize_t
+ sma3_store(struct device *dev, struct device_attribute *attr,
+ 	   const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = ptp_ocp_sma_store(bp, buf, 3);
+ 	return err ? err : count;
+ }
+ 
+ static ssize_t
+ sma4_store(struct device *dev, struct device_attribute *attr,
+ 	   const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = ptp_ocp_sma_store(bp, buf, 4);
+ 	return err ? err : count;
+ }
+ static DEVICE_ATTR_RW(sma1);
+ static DEVICE_ATTR_RW(sma2);
+ static DEVICE_ATTR_RW(sma3);
+ static DEVICE_ATTR_RW(sma4);
+ 
+ static ssize_t
+ available_sma_inputs_show(struct device *dev,
+ 			  struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return ptp_ocp_select_table_show(bp->sma_op->tbl[0], buf);
+ }
+ static DEVICE_ATTR_RO(available_sma_inputs);
+ 
+ static ssize_t
+ available_sma_outputs_show(struct device *dev,
+ 			   struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return ptp_ocp_select_table_show(bp->sma_op->tbl[1], buf);
+ }
+ static DEVICE_ATTR_RO(available_sma_outputs);
+ 
+ #define EXT_ATTR_RO(_group, _name, _val)				\
+ 	struct dev_ext_attribute dev_attr_##_group##_val##_##_name =	\
+ 		{ __ATTR_RO(_name), (void *)_val }
+ #define EXT_ATTR_RW(_group, _name, _val)				\
+ 	struct dev_ext_attribute dev_attr_##_group##_val##_##_name =	\
+ 		{ __ATTR_RW(_name), (void *)_val }
+ #define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)
+ 
+ /* period [duty [phase [polarity]]] */
+ static ssize_t
+ signal_store(struct device *dev, struct device_attribute *attr,
+ 	     const char *buf, size_t count)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	struct ptp_ocp_signal s = { };
+ 	int gen = (uintptr_t)ea->var;
+ 	int argc, err;
+ 	char **argv;
+ 
+ 	argv = argv_split(GFP_KERNEL, buf, &argc);
+ 	if (!argv)
+ 		return -ENOMEM;
+ 
+ 	err = -EINVAL;
+ 	s.duty = bp->signal[gen].duty;
+ 	s.phase = bp->signal[gen].phase;
+ 	s.period = bp->signal[gen].period;
+ 	s.polarity = bp->signal[gen].polarity;
+ 
+ 	switch (argc) {
+ 	case 4:
+ 		argc--;
+ 		err = kstrtobool(argv[argc], &s.polarity);
+ 		if (err)
+ 			goto out;
+ 		fallthrough;
+ 	case 3:
+ 		argc--;
+ 		err = kstrtou64(argv[argc], 0, &s.phase);
+ 		if (err)
+ 			goto out;
+ 		fallthrough;
+ 	case 2:
+ 		argc--;
+ 		err = kstrtoint(argv[argc], 0, &s.duty);
+ 		if (err)
+ 			goto out;
+ 		fallthrough;
+ 	case 1:
+ 		argc--;
+ 		err = kstrtou64(argv[argc], 0, &s.period);
+ 		if (err)
+ 			goto out;
+ 		break;
+ 	default:
+ 		goto out;
+ 	}
+ 
+ 	err = ptp_ocp_signal_set(bp, gen, &s);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ptp_ocp_signal_enable(bp->signal_out[gen], gen, s.period != 0);
+ 
+ out:
+ 	argv_free(argv);
+ 	return err ? err : count;
+ }
+ 
+ static ssize_t
+ signal_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	struct ptp_ocp_signal *signal;
+ 	struct timespec64 ts;
+ 	ssize_t count;
+ 	int i;
+ 
+ 	i = (uintptr_t)ea->var;
+ 	signal = &bp->signal[i];
+ 
+ 	count = sysfs_emit(buf, "%llu %d %llu %d", signal->period,
+ 			   signal->duty, signal->phase, signal->polarity);
+ 
+ 	ts = ktime_to_timespec64(signal->start);
+ 	count += sysfs_emit_at(buf, count, " %ptT TAI\n", &ts);
+ 
+ 	return count;
+ }
+ static EXT_ATTR_RW(signal, signal, 0);
+ static EXT_ATTR_RW(signal, signal, 1);
+ static EXT_ATTR_RW(signal, signal, 2);
+ static EXT_ATTR_RW(signal, signal, 3);
+ 
+ static ssize_t
+ duty_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int i = (uintptr_t)ea->var;
+ 
+ 	return sysfs_emit(buf, "%d\n", bp->signal[i].duty);
+ }
+ static EXT_ATTR_RO(signal, duty, 0);
+ static EXT_ATTR_RO(signal, duty, 1);
+ static EXT_ATTR_RO(signal, duty, 2);
+ static EXT_ATTR_RO(signal, duty, 3);
+ 
+ static ssize_t
+ period_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int i = (uintptr_t)ea->var;
+ 
+ 	return sysfs_emit(buf, "%llu\n", bp->signal[i].period);
+ }
+ static EXT_ATTR_RO(signal, period, 0);
+ static EXT_ATTR_RO(signal, period, 1);
+ static EXT_ATTR_RO(signal, period, 2);
+ static EXT_ATTR_RO(signal, period, 3);
+ 
+ static ssize_t
+ phase_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int i = (uintptr_t)ea->var;
+ 
+ 	return sysfs_emit(buf, "%llu\n", bp->signal[i].phase);
+ }
+ static EXT_ATTR_RO(signal, phase, 0);
+ static EXT_ATTR_RO(signal, phase, 1);
+ static EXT_ATTR_RO(signal, phase, 2);
+ static EXT_ATTR_RO(signal, phase, 3);
+ 
+ static ssize_t
+ polarity_show(struct device *dev, struct device_attribute *attr,
+ 	      char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int i = (uintptr_t)ea->var;
+ 
+ 	return sysfs_emit(buf, "%d\n", bp->signal[i].polarity);
+ }
+ static EXT_ATTR_RO(signal, polarity, 0);
+ static EXT_ATTR_RO(signal, polarity, 1);
+ static EXT_ATTR_RO(signal, polarity, 2);
+ static EXT_ATTR_RO(signal, polarity, 3);
+ 
+ static ssize_t
+ running_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int i = (uintptr_t)ea->var;
+ 
+ 	return sysfs_emit(buf, "%d\n", bp->signal[i].running);
+ }
+ static EXT_ATTR_RO(signal, running, 0);
+ static EXT_ATTR_RO(signal, running, 1);
+ static EXT_ATTR_RO(signal, running, 2);
+ static EXT_ATTR_RO(signal, running, 3);
+ 
+ static ssize_t
+ start_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int i = (uintptr_t)ea->var;
+ 	struct timespec64 ts;
+ 
+ 	ts = ktime_to_timespec64(bp->signal[i].start);
+ 	return sysfs_emit(buf, "%llu.%lu\n", ts.tv_sec, ts.tv_nsec);
+ }
+ static EXT_ATTR_RO(signal, start, 0);
+ static EXT_ATTR_RO(signal, start, 1);
+ static EXT_ATTR_RO(signal, start, 2);
+ static EXT_ATTR_RO(signal, start, 3);
+ 
+ static ssize_t
+ seconds_store(struct device *dev, struct device_attribute *attr,
+ 	      const char *buf, size_t count)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int idx = (uintptr_t)ea->var;
+ 	u32 val;
+ 	int err;
+ 
+ 	err = kstrtou32(buf, 0, &val);
+ 	if (err)
+ 		return err;
+ 	if (val > 0xff)
+ 		return -EINVAL;
+ 
+ 	if (val)
+ 		val = (val << 8) | 0x1;
+ 
+ 	iowrite32(val, &bp->freq_in[idx]->ctrl);
+ 
+ 	return count;
+ }
+ 
+ static ssize_t
+ seconds_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int idx = (uintptr_t)ea->var;
+ 	u32 val;
+ 
+ 	val = ioread32(&bp->freq_in[idx]->ctrl);
+ 	if (val & 1)
+ 		val = (val >> 8) & 0xff;
+ 	else
+ 		val = 0;
+ 
+ 	return sysfs_emit(buf, "%u\n", val);
+ }
+ static EXT_ATTR_RW(freq, seconds, 0);
+ static EXT_ATTR_RW(freq, seconds, 1);
+ static EXT_ATTR_RW(freq, seconds, 2);
+ static EXT_ATTR_RW(freq, seconds, 3);
+ 
+ static ssize_t
+ frequency_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int idx = (uintptr_t)ea->var;
+ 	u32 val;
+ 
+ 	val = ioread32(&bp->freq_in[idx]->status);
+ 	if (val & FREQ_STATUS_ERROR)
+ 		return sysfs_emit(buf, "error\n");
+ 	if (val & FREQ_STATUS_OVERRUN)
+ 		return sysfs_emit(buf, "overrun\n");
+ 	if (val & FREQ_STATUS_VALID)
+ 		return sysfs_emit(buf, "%lu\n", val & FREQ_STATUS_MASK);
+ 	return 0;
+ }
+ static EXT_ATTR_RO(freq, frequency, 0);
+ static EXT_ATTR_RO(freq, frequency, 1);
+ static EXT_ATTR_RO(freq, frequency, 2);
+ static EXT_ATTR_RO(freq, frequency, 3);
+ 
+ static ssize_t
+ ptp_ocp_tty_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dev_ext_attribute *ea = to_ext_attr(attr);
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return sysfs_emit(buf, "ttyS%d", bp->port[(uintptr_t)ea->var].line);
+ }
+ 
+ static umode_t
+ ptp_ocp_timecard_tty_is_visible(struct kobject *kobj, struct attribute *attr, int n)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));
+ 	struct ptp_ocp_serial_port *port;
+ 	struct device_attribute *dattr;
+ 	struct dev_ext_attribute *ea;
+ 
+ 	if (strncmp(attr->name, "tty", 3))
+ 		return attr->mode;
+ 
+ 	dattr = container_of(attr, struct device_attribute, attr);
+ 	ea = container_of(dattr, struct dev_ext_attribute, attr);
+ 	port = &bp->port[(uintptr_t)ea->var];
+ 	return port->line == -1 ? 0 : 0444;
+ }
+ 
+ #define EXT_TTY_ATTR_RO(_name, _val)			\
+ 	struct dev_ext_attribute dev_attr_tty##_name =	\
+ 		{ __ATTR(tty##_name, 0444, ptp_ocp_tty_show, NULL), (void *)_val }
+ 
+ static EXT_TTY_ATTR_RO(GNSS, PORT_GNSS);
+ static EXT_TTY_ATTR_RO(GNSS2, PORT_GNSS2);
+ static EXT_TTY_ATTR_RO(MAC, PORT_MAC);
+ static EXT_TTY_ATTR_RO(NMEA, PORT_NMEA);
+ static struct attribute *ptp_ocp_timecard_tty_attrs[] = {
+ 	&dev_attr_ttyGNSS.attr.attr,
+ 	&dev_attr_ttyGNSS2.attr.attr,
+ 	&dev_attr_ttyMAC.attr.attr,
+ 	&dev_attr_ttyNMEA.attr.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group ptp_ocp_timecard_tty_group = {
+ 	.name = "tty",
+ 	.attrs = ptp_ocp_timecard_tty_attrs,
+ 	.is_visible = ptp_ocp_timecard_tty_is_visible,
+ };
+ 
+ static ssize_t
+ serialnum_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	if (!bp->has_eeprom_data)
+ 		ptp_ocp_read_eeprom(bp);
+ 
+ 	return sysfs_emit(buf, "%pM\n", bp->serial);
+ }
+ static DEVICE_ATTR_RO(serialnum);
+ 
+ static ssize_t
+ gnss_sync_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	ssize_t ret;
+ 
+ 	if (bp->gnss_lost)
+ 		ret = sysfs_emit(buf, "LOST @ %ptT\n", &bp->gnss_lost);
+ 	else
+ 		ret = sysfs_emit(buf, "SYNC\n");
+ 
+ 	return ret;
+ }
+ static DEVICE_ATTR_RO(gnss_sync);
+ 
+ static ssize_t
+ utc_tai_offset_show(struct device *dev,
+ 		    struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return sysfs_emit(buf, "%d\n", bp->utc_tai_offset);
+ }
+ 
+ static ssize_t
+ utc_tai_offset_store(struct device *dev,
+ 		     struct device_attribute *attr,
+ 		     const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int err;
+ 	u32 val;
+ 
+ 	err = kstrtou32(buf, 0, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	ptp_ocp_utc_distribute(bp, val);
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(utc_tai_offset);
+ 
+ static ssize_t
+ ts_window_adjust_show(struct device *dev,
+ 		      struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	return sysfs_emit(buf, "%d\n", bp->ts_window_adjust);
+ }
+ 
+ static ssize_t
+ ts_window_adjust_store(struct device *dev,
+ 		       struct device_attribute *attr,
+ 		       const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	int err;
+ 	u32 val;
+ 
+ 	err = kstrtou32(buf, 0, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	bp->ts_window_adjust = val;
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(ts_window_adjust);
+ 
+ static ssize_t
+ irig_b_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	u32 val;
+ 
+ 	val = ioread32(&bp->irig_out->ctrl);
+ 	val = (val >> 16) & 0x07;
+ 	return sysfs_emit(buf, "%d\n", val);
+ }
+ 
+ static ssize_t
+ irig_b_mode_store(struct device *dev,
+ 		  struct device_attribute *attr,
+ 		  const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	unsigned long flags;
+ 	int err;
+ 	u32 reg;
+ 	u8 val;
+ 
+ 	err = kstrtou8(buf, 0, &val);
+ 	if (err)
+ 		return err;
+ 	if (val > 7)
+ 		return -EINVAL;
+ 
+ 	reg = ((val & 0x7) << 16);
+ 
+ 	spin_lock_irqsave(&bp->lock, flags);
+ 	iowrite32(0, &bp->irig_out->ctrl);		/* disable */
+ 	iowrite32(reg, &bp->irig_out->ctrl);		/* change mode */
+ 	iowrite32(reg | IRIG_M_CTRL_ENABLE, &bp->irig_out->ctrl);
+ 	spin_unlock_irqrestore(&bp->lock, flags);
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(irig_b_mode);
+ 
+ static ssize_t
+ clock_source_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	const char *p;
+ 	u32 select;
+ 
+ 	select = ioread32(&bp->reg->select);
+ 	p = ptp_ocp_select_name_from_val(ptp_ocp_clock, select >> 16);
+ 
+ 	return sysfs_emit(buf, "%s\n", p);
+ }
+ 
+ static ssize_t
+ clock_source_store(struct device *dev, struct device_attribute *attr,
+ 		   const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	unsigned long flags;
+ 	int val;
+ 
+ 	val = ptp_ocp_select_val_from_name(ptp_ocp_clock, buf);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	spin_lock_irqsave(&bp->lock, flags);
+ 	iowrite32(val, &bp->reg->select);
+ 	spin_unlock_irqrestore(&bp->lock, flags);
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(clock_source);
+ 
+ static ssize_t
+ available_clock_sources_show(struct device *dev,
+ 			     struct device_attribute *attr, char *buf)
+ {
+ 	return ptp_ocp_select_table_show(ptp_ocp_clock, buf);
+ }
+ static DEVICE_ATTR_RO(available_clock_sources);
+ 
+ static ssize_t
+ clock_status_drift_show(struct device *dev,
+ 			struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	u32 val;
+ 	int res;
+ 
+ 	val = ioread32(&bp->reg->status_drift);
+ 	res = (val & ~INT_MAX) ? -1 : 1;
+ 	res *= (val & INT_MAX);
+ 	return sysfs_emit(buf, "%d\n", res);
+ }
+ static DEVICE_ATTR_RO(clock_status_drift);
+ 
+ static ssize_t
+ clock_status_offset_show(struct device *dev,
+ 			 struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	u32 val;
+ 	int res;
+ 
+ 	val = ioread32(&bp->reg->status_offset);
+ 	res = (val & ~INT_MAX) ? -1 : 1;
+ 	res *= (val & INT_MAX);
+ 	return sysfs_emit(buf, "%d\n", res);
+ }
+ static DEVICE_ATTR_RO(clock_status_offset);
+ 
+ static ssize_t
+ tod_correction_show(struct device *dev,
+ 		    struct device_attribute *attr, char *buf)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	u32 val;
+ 	int res;
+ 
+ 	val = ioread32(&bp->tod->adj_sec);
+ 	res = (val & ~INT_MAX) ? -1 : 1;
+ 	res *= (val & INT_MAX);
+ 	return sysfs_emit(buf, "%d\n", res);
+ }
+ 
+ static ssize_t
+ tod_correction_store(struct device *dev, struct device_attribute *attr,
+ 		     const char *buf, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 	unsigned long flags;
+ 	int err, res;
+ 	u32 val = 0;
+ 
+ 	err = kstrtos32(buf, 0, &res);
+ 	if (err)
+ 		return err;
+ 	if (res < 0) {
+ 		res *= -1;
+ 		val |= BIT(31);
+ 	}
+ 	val |= res;
+ 
+ 	spin_lock_irqsave(&bp->lock, flags);
+ 	iowrite32(val, &bp->tod->adj_sec);
+ 	spin_unlock_irqrestore(&bp->lock, flags);
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(tod_correction);
+ 
+ #define _DEVICE_SIGNAL_GROUP_ATTRS(_nr)					\
+ 	static struct attribute *fb_timecard_signal##_nr##_attrs[] = {	\
+ 		&dev_attr_signal##_nr##_signal.attr.attr,		\
+ 		&dev_attr_signal##_nr##_duty.attr.attr,			\
+ 		&dev_attr_signal##_nr##_phase.attr.attr,		\
+ 		&dev_attr_signal##_nr##_period.attr.attr,		\
+ 		&dev_attr_signal##_nr##_polarity.attr.attr,		\
+ 		&dev_attr_signal##_nr##_running.attr.attr,		\
+ 		&dev_attr_signal##_nr##_start.attr.attr,		\
+ 		NULL,							\
+ 	}
+ 
+ #define DEVICE_SIGNAL_GROUP(_name, _nr)					\
+ 	_DEVICE_SIGNAL_GROUP_ATTRS(_nr);				\
+ 	static const struct attribute_group				\
+ 			fb_timecard_signal##_nr##_group = {		\
+ 		.name = #_name,						\
+ 		.attrs = fb_timecard_signal##_nr##_attrs,		\
+ }
+ 
+ DEVICE_SIGNAL_GROUP(gen1, 0);
+ DEVICE_SIGNAL_GROUP(gen2, 1);
+ DEVICE_SIGNAL_GROUP(gen3, 2);
+ DEVICE_SIGNAL_GROUP(gen4, 3);
+ 
+ #define _DEVICE_FREQ_GROUP_ATTRS(_nr)					\
+ 	static struct attribute *fb_timecard_freq##_nr##_attrs[] = {	\
+ 		&dev_attr_freq##_nr##_seconds.attr.attr,		\
+ 		&dev_attr_freq##_nr##_frequency.attr.attr,		\
+ 		NULL,							\
+ 	}
+ 
+ #define DEVICE_FREQ_GROUP(_name, _nr)					\
+ 	_DEVICE_FREQ_GROUP_ATTRS(_nr);					\
+ 	static const struct attribute_group				\
+ 			fb_timecard_freq##_nr##_group = {		\
+ 		.name = #_name,						\
+ 		.attrs = fb_timecard_freq##_nr##_attrs,			\
+ }
+ 
+ DEVICE_FREQ_GROUP(freq1, 0);
+ DEVICE_FREQ_GROUP(freq2, 1);
+ DEVICE_FREQ_GROUP(freq3, 2);
+ DEVICE_FREQ_GROUP(freq4, 3);
+ 
+ static ssize_t
+ disciplining_config_read(struct file *filp, struct kobject *kobj,
+ 			 struct bin_attribute *bin_attr, char *buf,
+ 			 loff_t off, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));
+ 	size_t size = OCP_ART_CONFIG_SIZE;
+ 	struct nvmem_device *nvmem;
+ 	ssize_t err;
+ 
+ 	nvmem = ptp_ocp_nvmem_device_get(bp, NULL);
+ 	if (IS_ERR(nvmem))
+ 		return PTR_ERR(nvmem);
+ 
+ 	if (off > size) {
+ 		err = 0;
+ 		goto out;
+ 	}
+ 
+ 	if (off + count > size)
+ 		count = size - off;
+ 
+ 	// the configuration is in the very beginning of the EEPROM
+ 	err = nvmem_device_read(nvmem, off, count, buf);
+ 	if (err != count) {
+ 		err = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ out:
+ 	ptp_ocp_nvmem_device_put(&nvmem);
+ 
+ 	return err;
+ }
+ 
+ static ssize_t
+ disciplining_config_write(struct file *filp, struct kobject *kobj,
+ 			  struct bin_attribute *bin_attr, char *buf,
+ 			  loff_t off, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));
+ 	struct nvmem_device *nvmem;
+ 	ssize_t err;
+ 
+ 	/* Allow write of the whole area only */
+ 	if (off || count != OCP_ART_CONFIG_SIZE)
+ 		return -EFAULT;
+ 
+ 	nvmem = ptp_ocp_nvmem_device_get(bp, NULL);
+ 	if (IS_ERR(nvmem))
+ 		return PTR_ERR(nvmem);
+ 
+ 	err = nvmem_device_write(nvmem, 0x00, count, buf);
+ 	if (err != count)
+ 		err = -EFAULT;
+ 
+ 	ptp_ocp_nvmem_device_put(&nvmem);
+ 
+ 	return err;
+ }
+ static BIN_ATTR_RW(disciplining_config, OCP_ART_CONFIG_SIZE);
+ 
+ static ssize_t
+ temperature_table_read(struct file *filp, struct kobject *kobj,
+ 		       struct bin_attribute *bin_attr, char *buf,
+ 		       loff_t off, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));
+ 	size_t size = OCP_ART_TEMP_TABLE_SIZE;
+ 	struct nvmem_device *nvmem;
+ 	ssize_t err;
+ 
+ 	nvmem = ptp_ocp_nvmem_device_get(bp, NULL);
+ 	if (IS_ERR(nvmem))
+ 		return PTR_ERR(nvmem);
+ 
+ 	if (off > size) {
+ 		err = 0;
+ 		goto out;
+ 	}
+ 
+ 	if (off + count > size)
+ 		count = size - off;
+ 
+ 	// the configuration is in the very beginning of the EEPROM
+ 	err = nvmem_device_read(nvmem, 0x90 + off, count, buf);
+ 	if (err != count) {
+ 		err = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ out:
+ 	ptp_ocp_nvmem_device_put(&nvmem);
+ 
+ 	return err;
+ }
+ 
+ static ssize_t
+ temperature_table_write(struct file *filp, struct kobject *kobj,
+ 			struct bin_attribute *bin_attr, char *buf,
+ 			loff_t off, size_t count)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));
+ 	struct nvmem_device *nvmem;
+ 	ssize_t err;
+ 
+ 	/* Allow write of the whole area only */
+ 	if (off || count != OCP_ART_TEMP_TABLE_SIZE)
+ 		return -EFAULT;
+ 
+ 	nvmem = ptp_ocp_nvmem_device_get(bp, NULL);
+ 	if (IS_ERR(nvmem))
+ 		return PTR_ERR(nvmem);
+ 
+ 	err = nvmem_device_write(nvmem, 0x90, count, buf);
+ 	if (err != count)
+ 		err = -EFAULT;
+ 
+ 	ptp_ocp_nvmem_device_put(&nvmem);
+ 
+ 	return err;
+ }
+ static BIN_ATTR_RW(temperature_table, OCP_ART_TEMP_TABLE_SIZE);
+ 
+ static struct attribute *fb_timecard_attrs[] = {
+ 	&dev_attr_serialnum.attr,
+ 	&dev_attr_gnss_sync.attr,
+ 	&dev_attr_clock_source.attr,
+ 	&dev_attr_available_clock_sources.attr,
+ 	&dev_attr_sma1.attr,
+ 	&dev_attr_sma2.attr,
+ 	&dev_attr_sma3.attr,
+ 	&dev_attr_sma4.attr,
+ 	&dev_attr_available_sma_inputs.attr,
+ 	&dev_attr_available_sma_outputs.attr,
+ 	&dev_attr_clock_status_drift.attr,
+ 	&dev_attr_clock_status_offset.attr,
+ 	&dev_attr_irig_b_mode.attr,
+ 	&dev_attr_utc_tai_offset.attr,
+ 	&dev_attr_ts_window_adjust.attr,
+ 	&dev_attr_tod_correction.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group fb_timecard_group = {
+ 	.attrs = fb_timecard_attrs,
+ };
+ 
+ static const struct ocp_attr_group fb_timecard_groups[] = {
+ 	{ .cap = OCP_CAP_BASIC,	    .group = &fb_timecard_group },
+ 	{ .cap = OCP_CAP_BASIC,	    .group = &ptp_ocp_timecard_tty_group },
+ 	{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal0_group },
+ 	{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal1_group },
+ 	{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal2_group },
+ 	{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal3_group },
+ 	{ .cap = OCP_CAP_FREQ,	    .group = &fb_timecard_freq0_group },
+ 	{ .cap = OCP_CAP_FREQ,	    .group = &fb_timecard_freq1_group },
+ 	{ .cap = OCP_CAP_FREQ,	    .group = &fb_timecard_freq2_group },
+ 	{ .cap = OCP_CAP_FREQ,	    .group = &fb_timecard_freq3_group },
+ 	{ },
+ };
+ 
+ static struct attribute *art_timecard_attrs[] = {
+ 	&dev_attr_serialnum.attr,
+ 	&dev_attr_clock_source.attr,
+ 	&dev_attr_available_clock_sources.attr,
+ 	&dev_attr_utc_tai_offset.attr,
+ 	&dev_attr_ts_window_adjust.attr,
+ 	&dev_attr_sma1.attr,
+ 	&dev_attr_sma2.attr,
+ 	&dev_attr_sma3.attr,
+ 	&dev_attr_sma4.attr,
+ 	&dev_attr_available_sma_inputs.attr,
+ 	&dev_attr_available_sma_outputs.attr,
+ 	NULL,
+ };
+ 
+ static struct bin_attribute *bin_art_timecard_attrs[] = {
+ 	&bin_attr_disciplining_config,
+ 	&bin_attr_temperature_table,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group art_timecard_group = {
+ 	.attrs = art_timecard_attrs,
+ 	.bin_attrs = bin_art_timecard_attrs,
+ };
+ 
+ static const struct ocp_attr_group art_timecard_groups[] = {
+ 	{ .cap = OCP_CAP_BASIC,	    .group = &art_timecard_group },
+ 	{ .cap = OCP_CAP_BASIC,	    .group = &ptp_ocp_timecard_tty_group },
+ 	{ },
+ };
+ 
+ static struct attribute *adva_timecard_attrs[] = {
+ 	&dev_attr_serialnum.attr,
+ 	&dev_attr_gnss_sync.attr,
+ 	&dev_attr_clock_source.attr,
+ 	&dev_attr_available_clock_sources.attr,
+ 	&dev_attr_sma1.attr,
+ 	&dev_attr_sma2.attr,
+ 	&dev_attr_sma3.attr,
+ 	&dev_attr_sma4.attr,
+ 	&dev_attr_available_sma_inputs.attr,
+ 	&dev_attr_available_sma_outputs.attr,
+ 	&dev_attr_clock_status_drift.attr,
+ 	&dev_attr_clock_status_offset.attr,
+ 	&dev_attr_ts_window_adjust.attr,
+ 	&dev_attr_tod_correction.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group adva_timecard_group = {
+ 	.attrs = adva_timecard_attrs,
+ };
+ 
+ static const struct ocp_attr_group adva_timecard_groups[] = {
+ 	{ .cap = OCP_CAP_BASIC,	    .group = &adva_timecard_group },
+ 	{ .cap = OCP_CAP_BASIC,	    .group = &ptp_ocp_timecard_tty_group },
+ 	{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal0_group },
+ 	{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal1_group },
+ 	{ .cap = OCP_CAP_FREQ,	    .group = &fb_timecard_freq0_group },
+ 	{ .cap = OCP_CAP_FREQ,	    .group = &fb_timecard_freq1_group },
+ 	{ },
+ };
+ 
+ static void
+ gpio_input_map(char *buf, struct ptp_ocp *bp, u16 map[][2], u16 bit,
+ 	       const char *def)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		if (bp->sma[i].mode != SMA_MODE_IN)
+ 			continue;
+ 		if (map[i][0] & (1 << bit)) {
+ 			sprintf(buf, "sma%d", i + 1);
+ 			return;
+ 		}
+ 	}
+ 	if (!def)
+ 		def = "----";
+ 	strcpy(buf, def);
+ }
+ 
+ static void
+ gpio_output_map(char *buf, struct ptp_ocp *bp, u16 map[][2], u16 bit)
+ {
+ 	char *ans = buf;
+ 	int i;
+ 
+ 	strcpy(ans, "----");
+ 	for (i = 0; i < 4; i++) {
+ 		if (bp->sma[i].mode != SMA_MODE_OUT)
+ 			continue;
+ 		if (map[i][1] & (1 << bit))
+ 			ans += sprintf(ans, "sma%d ", i + 1);
+ 	}
+ }
+ 
+ static void
+ _signal_summary_show(struct seq_file *s, struct ptp_ocp *bp, int nr)
+ {
+ 	struct signal_reg __iomem *reg = bp->signal_out[nr]->mem;
+ 	struct ptp_ocp_signal *signal = &bp->signal[nr];
+ 	char label[8];
+ 	bool on;
+ 	u32 val;
+ 
+ 	if (!signal)
+ 		return;
+ 
+ 	on = signal->running;
+ 	sprintf(label, "GEN%d", nr + 1);
+ 	seq_printf(s, "%7s: %s, period:%llu duty:%d%% phase:%llu pol:%d",
+ 		   label, on ? " ON" : "OFF",
+ 		   signal->period, signal->duty, signal->phase,
+ 		   signal->polarity);
+ 
+ 	val = ioread32(&reg->enable);
+ 	seq_printf(s, " [%x", val);
+ 	val = ioread32(&reg->status);
+ 	seq_printf(s, " %x]", val);
+ 
+ 	seq_printf(s, " start:%llu\n", signal->start);
+ }
+ 
+ static void
+ _frequency_summary_show(struct seq_file *s, int nr,
+ 			struct frequency_reg __iomem *reg)
+ {
+ 	char label[8];
+ 	bool on;
+ 	u32 val;
+ 
+ 	if (!reg)
+ 		return;
+ 
+ 	sprintf(label, "FREQ%d", nr + 1);
+ 	val = ioread32(&reg->ctrl);
+ 	on = val & 1;
+ 	val = (val >> 8) & 0xff;
+ 	seq_printf(s, "%7s: %s, sec:%u",
+ 		   label,
+ 		   on ? " ON" : "OFF",
+ 		   val);
+ 
+ 	val = ioread32(&reg->status);
+ 	if (val & FREQ_STATUS_ERROR)
+ 		seq_printf(s, ", error");
+ 	if (val & FREQ_STATUS_OVERRUN)
+ 		seq_printf(s, ", overrun");
+ 	if (val & FREQ_STATUS_VALID)
+ 		seq_printf(s, ", freq %lu Hz", val & FREQ_STATUS_MASK);
+ 	seq_printf(s, "  reg:%x\n", val);
+ }
+ 
+ static int
+ ptp_ocp_summary_show(struct seq_file *s, void *data)
+ {
+ 	struct device *dev = s->private;
+ 	struct ptp_system_timestamp sts;
+ 	struct ts_reg __iomem *ts_reg;
+ 	char *buf, *src, *mac_src;
+ 	struct timespec64 ts;
+ 	struct ptp_ocp *bp;
+ 	u16 sma_val[4][2];
+ 	u32 ctrl, val;
+ 	bool on, map;
+ 	int i;
+ 
+ 	buf = (char *)__get_free_page(GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	bp = dev_get_drvdata(dev);
+ 
+ 	seq_printf(s, "%7s: /dev/ptp%d\n", "PTP", ptp_clock_index(bp->ptp));
+ 	for (i = 0; i < __PORT_COUNT; i++) {
+ 		if (bp->port[i].line != -1)
+ 			seq_printf(s, "%7s: /dev/ttyS%d\n", ptp_ocp_tty_port_name(i),
+ 				   bp->port[i].line);
+ 	}
+ 
+ 	memset(sma_val, 0xff, sizeof(sma_val));
+ 	if (bp->sma_map1) {
+ 		u32 reg;
+ 
+ 		reg = ioread32(&bp->sma_map1->gpio1);
+ 		sma_val[0][0] = reg & 0xffff;
+ 		sma_val[1][0] = reg >> 16;
+ 
+ 		reg = ioread32(&bp->sma_map1->gpio2);
+ 		sma_val[2][1] = reg & 0xffff;
+ 		sma_val[3][1] = reg >> 16;
+ 
+ 		reg = ioread32(&bp->sma_map2->gpio1);
+ 		sma_val[2][0] = reg & 0xffff;
+ 		sma_val[3][0] = reg >> 16;
+ 
+ 		reg = ioread32(&bp->sma_map2->gpio2);
+ 		sma_val[0][1] = reg & 0xffff;
+ 		sma_val[1][1] = reg >> 16;
+ 	}
+ 
+ 	sma1_show(dev, NULL, buf);
+ 	seq_printf(s, "   sma1: %04x,%04x %s",
+ 		   sma_val[0][0], sma_val[0][1], buf);
+ 
+ 	sma2_show(dev, NULL, buf);
+ 	seq_printf(s, "   sma2: %04x,%04x %s",
+ 		   sma_val[1][0], sma_val[1][1], buf);
+ 
+ 	sma3_show(dev, NULL, buf);
+ 	seq_printf(s, "   sma3: %04x,%04x %s",
+ 		   sma_val[2][0], sma_val[2][1], buf);
+ 
+ 	sma4_show(dev, NULL, buf);
+ 	seq_printf(s, "   sma4: %04x,%04x %s",
+ 		   sma_val[3][0], sma_val[3][1], buf);
+ 
+ 	if (bp->ts0) {
+ 		ts_reg = bp->ts0->mem;
+ 		on = ioread32(&ts_reg->enable);
+ 		src = "GNSS1";
+ 		seq_printf(s, "%7s: %s, src: %s\n", "TS0",
+ 			   on ? " ON" : "OFF", src);
+ 	}
+ 
+ 	if (bp->ts1) {
+ 		ts_reg = bp->ts1->mem;
+ 		on = ioread32(&ts_reg->enable);
+ 		gpio_input_map(buf, bp, sma_val, 2, NULL);
+ 		seq_printf(s, "%7s: %s, src: %s\n", "TS1",
+ 			   on ? " ON" : "OFF", buf);
+ 	}
+ 
+ 	if (bp->ts2) {
+ 		ts_reg = bp->ts2->mem;
+ 		on = ioread32(&ts_reg->enable);
+ 		gpio_input_map(buf, bp, sma_val, 3, NULL);
+ 		seq_printf(s, "%7s: %s, src: %s\n", "TS2",
+ 			   on ? " ON" : "OFF", buf);
+ 	}
+ 
+ 	if (bp->ts3) {
+ 		ts_reg = bp->ts3->mem;
+ 		on = ioread32(&ts_reg->enable);
+ 		gpio_input_map(buf, bp, sma_val, 6, NULL);
+ 		seq_printf(s, "%7s: %s, src: %s\n", "TS3",
+ 			   on ? " ON" : "OFF", buf);
+ 	}
+ 
+ 	if (bp->ts4) {
+ 		ts_reg = bp->ts4->mem;
+ 		on = ioread32(&ts_reg->enable);
+ 		gpio_input_map(buf, bp, sma_val, 7, NULL);
+ 		seq_printf(s, "%7s: %s, src: %s\n", "TS4",
+ 			   on ? " ON" : "OFF", buf);
+ 	}
+ 
+ 	if (bp->pps) {
+ 		ts_reg = bp->pps->mem;
+ 		src = "PHC";
+ 		on = ioread32(&ts_reg->enable);
+ 		map = !!(bp->pps_req_map & OCP_REQ_TIMESTAMP);
+ 		seq_printf(s, "%7s: %s, src: %s\n", "TS5",
+ 			   on && map ? " ON" : "OFF", src);
+ 
+ 		map = !!(bp->pps_req_map & OCP_REQ_PPS);
+ 		seq_printf(s, "%7s: %s, src: %s\n", "PPS",
+ 			   on && map ? " ON" : "OFF", src);
+ 	}
+ 
+ 	if (bp->fw_cap & OCP_CAP_SIGNAL)
+ 		for (i = 0; i < 4; i++)
+ 			_signal_summary_show(s, bp, i);
+ 
+ 	if (bp->fw_cap & OCP_CAP_FREQ)
+ 		for (i = 0; i < 4; i++)
+ 			_frequency_summary_show(s, i, bp->freq_in[i]);
+ 
+ 	if (bp->irig_out) {
+ 		ctrl = ioread32(&bp->irig_out->ctrl);
+ 		on = ctrl & IRIG_M_CTRL_ENABLE;
+ 		val = ioread32(&bp->irig_out->status);
+ 		gpio_output_map(buf, bp, sma_val, 4);
+ 		seq_printf(s, "%7s: %s, error: %d, mode %d, out: %s\n", "IRIG",
+ 			   on ? " ON" : "OFF", val, (ctrl >> 16), buf);
+ 	}
+ 
+ 	if (bp->irig_in) {
+ 		on = ioread32(&bp->irig_in->ctrl) & IRIG_S_CTRL_ENABLE;
+ 		val = ioread32(&bp->irig_in->status);
+ 		gpio_input_map(buf, bp, sma_val, 4, NULL);
+ 		seq_printf(s, "%7s: %s, error: %d, src: %s\n", "IRIG in",
+ 			   on ? " ON" : "OFF", val, buf);
+ 	}
+ 
+ 	if (bp->dcf_out) {
+ 		on = ioread32(&bp->dcf_out->ctrl) & DCF_M_CTRL_ENABLE;
+ 		val = ioread32(&bp->dcf_out->status);
+ 		gpio_output_map(buf, bp, sma_val, 5);
+ 		seq_printf(s, "%7s: %s, error: %d, out: %s\n", "DCF",
+ 			   on ? " ON" : "OFF", val, buf);
+ 	}
+ 
+ 	if (bp->dcf_in) {
+ 		on = ioread32(&bp->dcf_in->ctrl) & DCF_S_CTRL_ENABLE;
+ 		val = ioread32(&bp->dcf_in->status);
+ 		gpio_input_map(buf, bp, sma_val, 5, NULL);
+ 		seq_printf(s, "%7s: %s, error: %d, src: %s\n", "DCF in",
+ 			   on ? " ON" : "OFF", val, buf);
+ 	}
+ 
+ 	if (bp->nmea_out) {
+ 		on = ioread32(&bp->nmea_out->ctrl) & 1;
+ 		val = ioread32(&bp->nmea_out->status);
+ 		seq_printf(s, "%7s: %s, error: %d\n", "NMEA",
+ 			   on ? " ON" : "OFF", val);
+ 	}
+ 
+ 	/* compute src for PPS1, used below. */
+ 	if (bp->pps_select) {
+ 		val = ioread32(&bp->pps_select->gpio1);
+ 		src = &buf[80];
+ 		mac_src = "GNSS1";
+ 		if (val & 0x01) {
+ 			gpio_input_map(src, bp, sma_val, 0, NULL);
+ 			mac_src = src;
+ 		} else if (val & 0x02) {
+ 			src = "MAC";
+ 		} else if (val & 0x04) {
+ 			src = "GNSS1";
+ 		} else {
+ 			src = "----";
+ 			mac_src = src;
+ 		}
+ 	} else {
+ 		src = "?";
+ 		mac_src = src;
+ 	}
+ 	seq_printf(s, "MAC PPS1 src: %s\n", mac_src);
+ 
+ 	gpio_input_map(buf, bp, sma_val, 1, "GNSS2");
+ 	seq_printf(s, "MAC PPS2 src: %s\n", buf);
+ 
+ 	/* assumes automatic switchover/selection */
+ 	val = ioread32(&bp->reg->select);
+ 	switch (val >> 16) {
+ 	case 0:
+ 		sprintf(buf, "----");
+ 		break;
+ 	case 2:
+ 		sprintf(buf, "IRIG");
+ 		break;
+ 	case 3:
+ 		sprintf(buf, "%s via PPS1", src);
+ 		break;
+ 	case 6:
+ 		sprintf(buf, "DCF");
+ 		break;
+ 	default:
+ 		strcpy(buf, "unknown");
+ 		break;
+ 	}
+ 	seq_printf(s, "%7s: %s, state: %s\n", "PHC src", buf,
+ 		   bp->sync ? "sync" : "unsynced");
+ 
+ 	if (!ptp_ocp_gettimex(&bp->ptp_info, &ts, &sts)) {
+ 		struct timespec64 sys_ts;
+ 		s64 pre_ns, post_ns, ns;
+ 
+ 		pre_ns = timespec64_to_ns(&sts.pre_ts);
+ 		post_ns = timespec64_to_ns(&sts.post_ts);
+ 		ns = (pre_ns + post_ns) / 2;
+ 		ns += (s64)bp->utc_tai_offset * NSEC_PER_SEC;
+ 		sys_ts = ns_to_timespec64(ns);
+ 
+ 		seq_printf(s, "%7s: %lld.%ld == %ptT TAI\n", "PHC",
+ 			   ts.tv_sec, ts.tv_nsec, &ts);
+ 		seq_printf(s, "%7s: %lld.%ld == %ptT UTC offset %d\n", "SYS",
+ 			   sys_ts.tv_sec, sys_ts.tv_nsec, &sys_ts,
+ 			   bp->utc_tai_offset);
+ 		seq_printf(s, "%7s: PHC:SYS offset: %lld  window: %lld\n", "",
+ 			   timespec64_to_ns(&ts) - ns,
+ 			   post_ns - pre_ns);
+ 	}
+ 
+ 	free_page((unsigned long)buf);
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(ptp_ocp_summary);
+ 
+ static int
+ ptp_ocp_tod_status_show(struct seq_file *s, void *data)
+ {
+ 	struct device *dev = s->private;
+ 	struct ptp_ocp *bp;
+ 	u32 val;
+ 	int idx;
+ 
+ 	bp = dev_get_drvdata(dev);
+ 
+ 	val = ioread32(&bp->tod->ctrl);
+ 	if (!(val & TOD_CTRL_ENABLE)) {
+ 		seq_printf(s, "TOD Slave disabled\n");
+ 		return 0;
+ 	}
+ 	seq_printf(s, "TOD Slave enabled, Control Register 0x%08X\n", val);
+ 
+ 	idx = val & TOD_CTRL_PROTOCOL ? 4 : 0;
+ 	idx += (val >> 16) & 3;
+ 	seq_printf(s, "Protocol %s\n", ptp_ocp_tod_proto_name(idx));
+ 
+ 	idx = (val >> TOD_CTRL_GNSS_SHIFT) & TOD_CTRL_GNSS_MASK;
+ 	seq_printf(s, "GNSS %s\n", ptp_ocp_tod_gnss_name(idx));
+ 
+ 	val = ioread32(&bp->tod->version);
+ 	seq_printf(s, "TOD Version %d.%d.%d\n",
+ 		val >> 24, (val >> 16) & 0xff, val & 0xffff);
+ 
+ 	val = ioread32(&bp->tod->status);
+ 	seq_printf(s, "Status register: 0x%08X\n", val);
+ 
+ 	val = ioread32(&bp->tod->adj_sec);
+ 	idx = (val & ~INT_MAX) ? -1 : 1;
+ 	idx *= (val & INT_MAX);
+ 	seq_printf(s, "Correction seconds: %d\n", idx);
+ 
+ 	val = ioread32(&bp->tod->utc_status);
+ 	seq_printf(s, "UTC status register: 0x%08X\n", val);
+ 	seq_printf(s, "UTC offset: %ld  valid:%d\n",
+ 		val & TOD_STATUS_UTC_MASK, val & TOD_STATUS_UTC_VALID ? 1 : 0);
+ 	seq_printf(s, "Leap second info valid:%d, Leap second announce %d\n",
+ 		val & TOD_STATUS_LEAP_VALID ? 1 : 0,
+ 		val & TOD_STATUS_LEAP_ANNOUNCE ? 1 : 0);
+ 
+ 	val = ioread32(&bp->tod->leap);
+ 	seq_printf(s, "Time to next leap second (in sec): %d\n", (s32) val);
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(ptp_ocp_tod_status);
+ 
+ static struct dentry *ptp_ocp_debugfs_root;
+ 
+ static void
+ ptp_ocp_debugfs_add_device(struct ptp_ocp *bp)
+ {
+ 	struct dentry *d;
+ 
+ 	d = debugfs_create_dir(dev_name(&bp->dev), ptp_ocp_debugfs_root);
+ 	bp->debug_root = d;
+ 	debugfs_create_file("summary", 0444, bp->debug_root,
+ 			    &bp->dev, &ptp_ocp_summary_fops);
+ 	if (bp->tod)
+ 		debugfs_create_file("tod_status", 0444, bp->debug_root,
+ 				    &bp->dev, &ptp_ocp_tod_status_fops);
+ }
+ 
+ static void
+ ptp_ocp_debugfs_remove_device(struct ptp_ocp *bp)
+ {
+ 	debugfs_remove_recursive(bp->debug_root);
+ }
+ 
+ static void
+ ptp_ocp_debugfs_init(void)
+ {
+ 	ptp_ocp_debugfs_root = debugfs_create_dir("timecard", NULL);
+ }
+ 
+ static void
+ ptp_ocp_debugfs_fini(void)
+ {
+ 	debugfs_remove_recursive(ptp_ocp_debugfs_root);
+ }
+ 
+ static void
+ ptp_ocp_dev_release(struct device *dev)
+ {
+ 	struct ptp_ocp *bp = dev_get_drvdata(dev);
+ 
+ 	mutex_lock(&ptp_ocp_lock);
+ 	idr_remove(&ptp_ocp_idr, bp->id);
+ 	mutex_unlock(&ptp_ocp_lock);
+ }
+ 
+ static int
+ ptp_ocp_device_init(struct ptp_ocp *bp, struct pci_dev *pdev)
+ {
+ 	int i, err;
+ 
+ 	mutex_lock(&ptp_ocp_lock);
+ 	err = idr_alloc(&ptp_ocp_idr, bp, 0, 0, GFP_KERNEL);
+ 	mutex_unlock(&ptp_ocp_lock);
+ 	if (err < 0) {
+ 		dev_err(&pdev->dev, "idr_alloc failed: %d\n", err);
+ 		return err;
+ 	}
+ 	bp->id = err;
+ 
+ 	bp->ptp_info = ptp_ocp_clock_info;
+ 	spin_lock_init(&bp->lock);
+ 
+ 	for (i = 0; i < __PORT_COUNT; i++)
+ 		bp->port[i].line = -1;
+ 
+ 	bp->pdev = pdev;
+ 
+ 	device_initialize(&bp->dev);
+ 	dev_set_name(&bp->dev, "ocp%d", bp->id);
+ 	bp->dev.class = &timecard_class;
+ 	bp->dev.parent = &pdev->dev;
+ 	bp->dev.release = ptp_ocp_dev_release;
+ 	dev_set_drvdata(&bp->dev, bp);
+ 
+ 	err = device_add(&bp->dev);
+ 	if (err) {
+ 		dev_err(&bp->dev, "device add failed: %d\n", err);
+ 		goto out;
+ 	}
+ 
+ 	pci_set_drvdata(pdev, bp);
+ 
+ 	return 0;
+ 
+ out:
+ 	put_device(&bp->dev);
+ 	return err;
+ }
+ 
+ static void
+ ptp_ocp_symlink(struct ptp_ocp *bp, struct device *child, const char *link)
+ {
+ 	struct device *dev = &bp->dev;
+ 
+ 	if (sysfs_create_link(&dev->kobj, &child->kobj, link))
+ 		dev_err(dev, "%s symlink failed\n", link);
+ }
+ 
+ static void
+ ptp_ocp_link_child(struct ptp_ocp *bp, const char *name, const char *link)
+ {
+ 	struct device *dev, *child;
+ 
+ 	dev = &bp->pdev->dev;
+ 
+ 	child = device_find_child_by_name(dev, name);
+ 	if (!child) {
+ 		dev_err(dev, "Could not find device %s\n", name);
+ 		return;
+ 	}
+ 
+ 	ptp_ocp_symlink(bp, child, link);
+ 	put_device(child);
+ }
+ 
+ static int
+ ptp_ocp_complete(struct ptp_ocp *bp)
+ {
+ 	struct pps_device *pps;
+ 	char buf[32];
+ 
+ 	sprintf(buf, "ptp%d", ptp_clock_index(bp->ptp));
+ 	ptp_ocp_link_child(bp, buf, "ptp");
+ 
+ 	pps = pps_lookup_dev(bp->ptp);
+ 	if (pps)
+ 		ptp_ocp_symlink(bp, &pps->dev, "pps");
+ 
+ 	ptp_ocp_debugfs_add_device(bp);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ ptp_ocp_phc_info(struct ptp_ocp *bp)
+ {
+ 	struct timespec64 ts;
++>>>>>>> c79a39dc8d06 (pps: Fix a use-after-free)
  	u32 version, select;
  
  	version = ioread32(&bp->reg->version);
diff --git a/drivers/pps/clients/pps-gpio.c b/drivers/pps/clients/pps-gpio.c
index 35799e6401c9..cc3eb6fb5161 100644
--- a/drivers/pps/clients/pps-gpio.c
+++ b/drivers/pps/clients/pps-gpio.c
@@ -214,8 +214,8 @@ static int pps_gpio_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	dev_info(data->pps->dev, "Registered IRQ %d as PPS source\n",
-		 data->irq);
+	dev_dbg(&data->pps->dev, "Registered IRQ %d as PPS source\n",
+		data->irq);
 
 	return 0;
 }
diff --git a/drivers/pps/clients/pps-ktimer.c b/drivers/pps/clients/pps-ktimer.c
index d33106bd7a29..2f465549b843 100644
--- a/drivers/pps/clients/pps-ktimer.c
+++ b/drivers/pps/clients/pps-ktimer.c
@@ -56,7 +56,7 @@ static struct pps_source_info pps_ktimer_info = {
 
 static void __exit pps_ktimer_exit(void)
 {
-	dev_info(pps->dev, "ktimer PPS source unregistered\n");
+	dev_dbg(&pps->dev, "ktimer PPS source unregistered\n");
 
 	del_timer_sync(&ktimer);
 	pps_unregister_source(pps);
@@ -74,7 +74,7 @@ static int __init pps_ktimer_init(void)
 	timer_setup(&ktimer, pps_ktimer_event, 0);
 	mod_timer(&ktimer, jiffies + HZ);
 
-	dev_info(pps->dev, "ktimer PPS source registered\n");
+	dev_dbg(&pps->dev, "ktimer PPS source registered\n");
 
 	return 0;
 }
diff --git a/drivers/pps/clients/pps-ldisc.c b/drivers/pps/clients/pps-ldisc.c
index 443d6bae19d1..fa5660f3c4b7 100644
--- a/drivers/pps/clients/pps-ldisc.c
+++ b/drivers/pps/clients/pps-ldisc.c
@@ -32,7 +32,7 @@ static void pps_tty_dcd_change(struct tty_struct *tty, bool active)
 	pps_event(pps, &ts, active ? PPS_CAPTUREASSERT :
 			PPS_CAPTURECLEAR, NULL);
 
-	dev_dbg(pps->dev, "PPS %s at %lu\n",
+	dev_dbg(&pps->dev, "PPS %s at %lu\n",
 			active ? "assert" : "clear", jiffies);
 }
 
@@ -69,7 +69,7 @@ static int pps_tty_open(struct tty_struct *tty)
 		goto err_unregister;
 	}
 
-	dev_info(pps->dev, "source \"%s\" added\n", info.path);
+	dev_dbg(&pps->dev, "source \"%s\" added\n", info.path);
 
 	return 0;
 
@@ -89,7 +89,7 @@ static void pps_tty_close(struct tty_struct *tty)
 	if (WARN_ON(!pps))
 		return;
 
-	dev_info(pps->dev, "removed\n");
+	dev_info(&pps->dev, "removed\n");
 	pps_unregister_source(pps);
 }
 
diff --git a/drivers/pps/clients/pps_parport.c b/drivers/pps/clients/pps_parport.c
index 7a41fb7b0dec..a4e11f5a97fe 100644
--- a/drivers/pps/clients/pps_parport.c
+++ b/drivers/pps/clients/pps_parport.c
@@ -83,7 +83,7 @@ static void parport_irq(void *handle)
 	/* check the signal (no signal means the pulse is lost this time) */
 	if (!signal_is_set(port)) {
 		local_irq_restore(flags);
-		dev_err(dev->pps->dev, "lost the signal\n");
+		dev_err(&dev->pps->dev, "lost the signal\n");
 		goto out_assert;
 	}
 
@@ -100,7 +100,7 @@ static void parport_irq(void *handle)
 	/* timeout */
 	dev->cw_err++;
 	if (dev->cw_err >= CLEAR_WAIT_MAX_ERRORS) {
-		dev_err(dev->pps->dev, "disabled clear edge capture after %d"
+		dev_err(&dev->pps->dev, "disabled clear edge capture after %d"
 				" timeouts\n", dev->cw_err);
 		dev->cw = 0;
 		dev->cw_err = 0;
diff --git a/drivers/pps/kapi.c b/drivers/pps/kapi.c
index d9d566f70ed1..92d1b62ea239 100644
--- a/drivers/pps/kapi.c
+++ b/drivers/pps/kapi.c
@@ -41,7 +41,7 @@ static void pps_add_offset(struct pps_ktime *ts, struct pps_ktime *offset)
 static void pps_echo_client_default(struct pps_device *pps, int event,
 		void *data)
 {
-	dev_info(pps->dev, "echo %s %s\n",
+	dev_info(&pps->dev, "echo %s %s\n",
 		event & PPS_CAPTUREASSERT ? "assert" : "",
 		event & PPS_CAPTURECLEAR ? "clear" : "");
 }
@@ -112,7 +112,7 @@ struct pps_device *pps_register_source(struct pps_source_info *info,
 		goto kfree_pps;
 	}
 
-	dev_info(pps->dev, "new PPS source %s\n", info->name);
+	dev_dbg(&pps->dev, "new PPS source %s\n", info->name);
 
 	return pps;
 
@@ -166,7 +166,7 @@ void pps_event(struct pps_device *pps, struct pps_event_time *ts, int event,
 	/* check event type */
 	BUG_ON((event & (PPS_CAPTUREASSERT | PPS_CAPTURECLEAR)) == 0);
 
-	dev_dbg(pps->dev, "PPS event at %lld.%09ld\n",
+	dev_dbg(&pps->dev, "PPS event at %lld.%09ld\n",
 			(s64)ts->ts_real.tv_sec, ts->ts_real.tv_nsec);
 
 	timespec_to_pps_ktime(&ts_real, ts->ts_real);
@@ -188,7 +188,7 @@ void pps_event(struct pps_device *pps, struct pps_event_time *ts, int event,
 		/* Save the time stamp */
 		pps->assert_tu = ts_real;
 		pps->assert_sequence++;
-		dev_dbg(pps->dev, "capture assert seq #%u\n",
+		dev_dbg(&pps->dev, "capture assert seq #%u\n",
 			pps->assert_sequence);
 
 		captured = ~0;
@@ -202,7 +202,7 @@ void pps_event(struct pps_device *pps, struct pps_event_time *ts, int event,
 		/* Save the time stamp */
 		pps->clear_tu = ts_real;
 		pps->clear_sequence++;
-		dev_dbg(pps->dev, "capture clear seq #%u\n",
+		dev_dbg(&pps->dev, "capture clear seq #%u\n",
 			pps->clear_sequence);
 
 		captured = ~0;
diff --git a/drivers/pps/kc.c b/drivers/pps/kc.c
index 50dc59af45be..fbd23295afd7 100644
--- a/drivers/pps/kc.c
+++ b/drivers/pps/kc.c
@@ -43,11 +43,11 @@ int pps_kc_bind(struct pps_device *pps, struct pps_bind_args *bind_args)
 			pps_kc_hardpps_mode = 0;
 			pps_kc_hardpps_dev = NULL;
 			spin_unlock_irq(&pps_kc_hardpps_lock);
-			dev_info(pps->dev, "unbound kernel"
+			dev_info(&pps->dev, "unbound kernel"
 					" consumer\n");
 		} else {
 			spin_unlock_irq(&pps_kc_hardpps_lock);
-			dev_err(pps->dev, "selected kernel consumer"
+			dev_err(&pps->dev, "selected kernel consumer"
 					" is not bound\n");
 			return -EINVAL;
 		}
@@ -57,11 +57,11 @@ int pps_kc_bind(struct pps_device *pps, struct pps_bind_args *bind_args)
 			pps_kc_hardpps_mode = bind_args->edge;
 			pps_kc_hardpps_dev = pps;
 			spin_unlock_irq(&pps_kc_hardpps_lock);
-			dev_info(pps->dev, "bound kernel consumer: "
+			dev_info(&pps->dev, "bound kernel consumer: "
 				"edge=0x%x\n", bind_args->edge);
 		} else {
 			spin_unlock_irq(&pps_kc_hardpps_lock);
-			dev_err(pps->dev, "another kernel consumer"
+			dev_err(&pps->dev, "another kernel consumer"
 					" is already bound\n");
 			return -EINVAL;
 		}
@@ -83,7 +83,7 @@ void pps_kc_remove(struct pps_device *pps)
 		pps_kc_hardpps_mode = 0;
 		pps_kc_hardpps_dev = NULL;
 		spin_unlock_irq(&pps_kc_hardpps_lock);
-		dev_info(pps->dev, "unbound kernel consumer"
+		dev_info(&pps->dev, "unbound kernel consumer"
 				" on device removal\n");
 	} else
 		spin_unlock_irq(&pps_kc_hardpps_lock);
diff --git a/drivers/pps/pps.c b/drivers/pps/pps.c
index 5d19baae6a38..63f96357eb9f 100644
--- a/drivers/pps/pps.c
+++ b/drivers/pps/pps.c
@@ -25,7 +25,7 @@
  * Local variables
  */
 
-static dev_t pps_devt;
+static int pps_major;
 static struct class *pps_class;
 
 static DEFINE_MUTEX(pps_idr_lock);
@@ -62,7 +62,7 @@ static int pps_cdev_pps_fetch(struct pps_device *pps, struct pps_fdata *fdata)
 	else {
 		unsigned long ticks;
 
-		dev_dbg(pps->dev, "timeout %lld.%09d\n",
+		dev_dbg(&pps->dev, "timeout %lld.%09d\n",
 				(long long) fdata->timeout.sec,
 				fdata->timeout.nsec);
 		ticks = fdata->timeout.sec * HZ;
@@ -80,7 +80,7 @@ static int pps_cdev_pps_fetch(struct pps_device *pps, struct pps_fdata *fdata)
 
 	/* Check for pending signals */
 	if (err == -ERESTARTSYS) {
-		dev_dbg(pps->dev, "pending signal caught\n");
+		dev_dbg(&pps->dev, "pending signal caught\n");
 		return -EINTR;
 	}
 
@@ -98,7 +98,7 @@ static long pps_cdev_ioctl(struct file *file,
 
 	switch (cmd) {
 	case PPS_GETPARAMS:
-		dev_dbg(pps->dev, "PPS_GETPARAMS\n");
+		dev_dbg(&pps->dev, "PPS_GETPARAMS\n");
 
 		spin_lock_irq(&pps->lock);
 
@@ -114,7 +114,7 @@ static long pps_cdev_ioctl(struct file *file,
 		break;
 
 	case PPS_SETPARAMS:
-		dev_dbg(pps->dev, "PPS_SETPARAMS\n");
+		dev_dbg(&pps->dev, "PPS_SETPARAMS\n");
 
 		/* Check the capabilities */
 		if (!capable(CAP_SYS_TIME))
@@ -124,14 +124,14 @@ static long pps_cdev_ioctl(struct file *file,
 		if (err)
 			return -EFAULT;
 		if (!(params.mode & (PPS_CAPTUREASSERT | PPS_CAPTURECLEAR))) {
-			dev_dbg(pps->dev, "capture mode unspecified (%x)\n",
+			dev_dbg(&pps->dev, "capture mode unspecified (%x)\n",
 								params.mode);
 			return -EINVAL;
 		}
 
 		/* Check for supported capabilities */
 		if ((params.mode & ~pps->info.mode) != 0) {
-			dev_dbg(pps->dev, "unsupported capabilities (%x)\n",
+			dev_dbg(&pps->dev, "unsupported capabilities (%x)\n",
 								params.mode);
 			return -EINVAL;
 		}
@@ -144,7 +144,7 @@ static long pps_cdev_ioctl(struct file *file,
 		/* Restore the read only parameters */
 		if ((params.mode & (PPS_TSFMT_TSPEC | PPS_TSFMT_NTPFP)) == 0) {
 			/* section 3.3 of RFC 2783 interpreted */
-			dev_dbg(pps->dev, "time format unspecified (%x)\n",
+			dev_dbg(&pps->dev, "time format unspecified (%x)\n",
 								params.mode);
 			pps->params.mode |= PPS_TSFMT_TSPEC;
 		}
@@ -165,7 +165,7 @@ static long pps_cdev_ioctl(struct file *file,
 		break;
 
 	case PPS_GETCAP:
-		dev_dbg(pps->dev, "PPS_GETCAP\n");
+		dev_dbg(&pps->dev, "PPS_GETCAP\n");
 
 		err = put_user(pps->info.mode, iuarg);
 		if (err)
@@ -176,7 +176,7 @@ static long pps_cdev_ioctl(struct file *file,
 	case PPS_FETCH: {
 		struct pps_fdata fdata;
 
-		dev_dbg(pps->dev, "PPS_FETCH\n");
+		dev_dbg(&pps->dev, "PPS_FETCH\n");
 
 		err = copy_from_user(&fdata, uarg, sizeof(struct pps_fdata));
 		if (err)
@@ -206,7 +206,7 @@ static long pps_cdev_ioctl(struct file *file,
 	case PPS_KC_BIND: {
 		struct pps_bind_args bind_args;
 
-		dev_dbg(pps->dev, "PPS_KC_BIND\n");
+		dev_dbg(&pps->dev, "PPS_KC_BIND\n");
 
 		/* Check the capabilities */
 		if (!capable(CAP_SYS_TIME))
@@ -218,7 +218,7 @@ static long pps_cdev_ioctl(struct file *file,
 
 		/* Check for supported capabilities */
 		if ((bind_args.edge & ~pps->info.mode) != 0) {
-			dev_err(pps->dev, "unsupported capabilities (%x)\n",
+			dev_err(&pps->dev, "unsupported capabilities (%x)\n",
 					bind_args.edge);
 			return -EINVAL;
 		}
@@ -227,7 +227,7 @@ static long pps_cdev_ioctl(struct file *file,
 		if (bind_args.tsformat != PPS_TSFMT_TSPEC ||
 				(bind_args.edge & ~PPS_CAPTUREBOTH) != 0 ||
 				bind_args.consumer != PPS_KC_HARDPPS) {
-			dev_err(pps->dev, "invalid kernel consumer bind"
+			dev_err(&pps->dev, "invalid kernel consumer bind"
 					" parameters (%x)\n", bind_args.edge);
 			return -EINVAL;
 		}
@@ -259,7 +259,7 @@ static long pps_cdev_compat_ioctl(struct file *file,
 		struct pps_fdata fdata;
 		int err;
 
-		dev_dbg(pps->dev, "PPS_FETCH\n");
+		dev_dbg(&pps->dev, "PPS_FETCH\n");
 
 		err = copy_from_user(&compat, uarg, sizeof(struct pps_fdata_compat));
 		if (err)
@@ -296,20 +296,36 @@ static long pps_cdev_compat_ioctl(struct file *file,
 #define pps_cdev_compat_ioctl	NULL
 #endif
 
+static struct pps_device *pps_idr_get(unsigned long id)
+{
+	struct pps_device *pps;
+
+	mutex_lock(&pps_idr_lock);
+	pps = idr_find(&pps_idr, id);
+	if (pps)
+		get_device(&pps->dev);
+
+	mutex_unlock(&pps_idr_lock);
+	return pps;
+}
+
 static int pps_cdev_open(struct inode *inode, struct file *file)
 {
-	struct pps_device *pps = container_of(inode->i_cdev,
-						struct pps_device, cdev);
+	struct pps_device *pps = pps_idr_get(iminor(inode));
+
+	if (!pps)
+		return -ENODEV;
+
 	file->private_data = pps;
-	kobject_get(&pps->dev->kobj);
 	return 0;
 }
 
 static int pps_cdev_release(struct inode *inode, struct file *file)
 {
-	struct pps_device *pps = container_of(inode->i_cdev,
-						struct pps_device, cdev);
-	kobject_put(&pps->dev->kobj);
+	struct pps_device *pps = file->private_data;
+
+	WARN_ON(pps->id != iminor(inode));
+	put_device(&pps->dev);
 	return 0;
 }
 
@@ -332,22 +348,13 @@ static void pps_device_destruct(struct device *dev)
 {
 	struct pps_device *pps = dev_get_drvdata(dev);
 
-	cdev_del(&pps->cdev);
-
-	/* Now we can release the ID for re-use */
 	pr_debug("deallocating pps%d\n", pps->id);
-	mutex_lock(&pps_idr_lock);
-	idr_remove(&pps_idr, pps->id);
-	mutex_unlock(&pps_idr_lock);
-
-	kfree(dev);
 	kfree(pps);
 }
 
 int pps_register_cdev(struct pps_device *pps)
 {
 	int err;
-	dev_t devt;
 
 	mutex_lock(&pps_idr_lock);
 	/*
@@ -364,40 +371,29 @@ int pps_register_cdev(struct pps_device *pps)
 		goto out_unlock;
 	}
 	pps->id = err;
-	mutex_unlock(&pps_idr_lock);
-
-	devt = MKDEV(MAJOR(pps_devt), pps->id);
-
-	cdev_init(&pps->cdev, &pps_cdev_fops);
-	pps->cdev.owner = pps->info.owner;
 
-	err = cdev_add(&pps->cdev, devt, 1);
-	if (err) {
-		pr_err("%s: failed to add char device %d:%d\n",
-				pps->info.name, MAJOR(pps_devt), pps->id);
+	pps->dev.class = pps_class;
+	pps->dev.parent = pps->info.dev;
+	pps->dev.devt = MKDEV(pps_major, pps->id);
+	dev_set_drvdata(&pps->dev, pps);
+	dev_set_name(&pps->dev, "pps%d", pps->id);
+	err = device_register(&pps->dev);
+	if (err)
 		goto free_idr;
-	}
-	pps->dev = device_create(pps_class, pps->info.dev, devt, pps,
-							"pps%d", pps->id);
-	if (IS_ERR(pps->dev)) {
-		err = PTR_ERR(pps->dev);
-		goto del_cdev;
-	}
 
 	/* Override the release function with our own */
-	pps->dev->release = pps_device_destruct;
+	pps->dev.release = pps_device_destruct;
 
-	pr_debug("source %s got cdev (%d:%d)\n", pps->info.name,
-			MAJOR(pps_devt), pps->id);
+	pr_debug("source %s got cdev (%d:%d)\n", pps->info.name, pps_major,
+		 pps->id);
 
+	get_device(&pps->dev);
+	mutex_unlock(&pps_idr_lock);
 	return 0;
 
-del_cdev:
-	cdev_del(&pps->cdev);
-
 free_idr:
-	mutex_lock(&pps_idr_lock);
 	idr_remove(&pps_idr, pps->id);
+	put_device(&pps->dev);
 out_unlock:
 	mutex_unlock(&pps_idr_lock);
 	return err;
@@ -407,7 +403,13 @@ void pps_unregister_cdev(struct pps_device *pps)
 {
 	pr_debug("unregistering pps%d\n", pps->id);
 	pps->lookup_cookie = NULL;
-	device_destroy(pps_class, pps->dev->devt);
+	device_destroy(pps_class, pps->dev.devt);
+
+	/* Now we can release the ID for re-use */
+	mutex_lock(&pps_idr_lock);
+	idr_remove(&pps_idr, pps->id);
+	put_device(&pps->dev);
+	mutex_unlock(&pps_idr_lock);
 }
 
 /*
@@ -427,6 +429,11 @@ void pps_unregister_cdev(struct pps_device *pps)
  * so that it will not be used again, even if the pps device cannot
  * be removed from the idr due to pending references holding the minor
  * number in use.
+ *
+ * Since pps_idr holds a reference to the device, the returned
+ * pps_device is guaranteed to be valid until pps_unregister_cdev() is
+ * called on it. But after calling pps_unregister_cdev(), it may be
+ * freed at any time.
  */
 struct pps_device *pps_lookup_dev(void const *cookie)
 {
@@ -449,13 +456,11 @@ EXPORT_SYMBOL(pps_lookup_dev);
 static void __exit pps_exit(void)
 {
 	class_destroy(pps_class);
-	unregister_chrdev_region(pps_devt, PPS_MAX_SOURCES);
+	__unregister_chrdev(pps_major, 0, PPS_MAX_SOURCES, "pps");
 }
 
 static int __init pps_init(void)
 {
-	int err;
-
 	pps_class = class_create("pps");
 	if (IS_ERR(pps_class)) {
 		pr_err("failed to allocate class\n");
@@ -463,8 +468,9 @@ static int __init pps_init(void)
 	}
 	pps_class->dev_groups = pps_groups;
 
-	err = alloc_chrdev_region(&pps_devt, 0, PPS_MAX_SOURCES, "pps");
-	if (err < 0) {
+	pps_major = __register_chrdev(0, 0, PPS_MAX_SOURCES, "pps",
+				      &pps_cdev_fops);
+	if (pps_major < 0) {
 		pr_err("failed to allocate char device region\n");
 		goto remove_class;
 	}
@@ -477,8 +483,7 @@ static int __init pps_init(void)
 
 remove_class:
 	class_destroy(pps_class);
-
-	return err;
+	return pps_major;
 }
 
 subsys_initcall(pps_init);
* Unmerged path drivers/ptp/ptp_ocp.c
diff --git a/include/linux/pps_kernel.h b/include/linux/pps_kernel.h
index 78c8ac4951b5..c7abce28ed29 100644
--- a/include/linux/pps_kernel.h
+++ b/include/linux/pps_kernel.h
@@ -56,8 +56,7 @@ struct pps_device {
 
 	unsigned int id;			/* PPS source unique ID */
 	void const *lookup_cookie;		/* For pps_lookup_dev() only */
-	struct cdev cdev;
-	struct device *dev;
+	struct device dev;
 	struct fasync_struct *async_queue;	/* fasync method */
 	spinlock_t lock;
 };
