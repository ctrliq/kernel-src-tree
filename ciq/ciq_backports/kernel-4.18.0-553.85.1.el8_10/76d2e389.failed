NFS: Fix a race when updating an existing write

jira KERNEL-186
cve CVE-2025-39697
Rebuild_History Non-Buildable kernel-4.18.0-553.85.1.el8_10
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 76d2e3890fb169168c73f2e4f8375c7cc24a765e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.85.1.el8_10/76d2e389.failed

After nfs_lock_and_join_requests() tests for whether the request is
still attached to the mapping, nothing prevents a call to
nfs_inode_remove_request() from succeeding until we actually lock the
page group.
The reason is that whoever called nfs_inode_remove_request() doesn't
necessarily have a lock on the page group head.

So in order to avoid races, let's take the page group lock earlier in
nfs_lock_and_join_requests(), and hold it across the removal of the
request in nfs_inode_remove_request().

	Reported-by: Jeff Layton <jlayton@kernel.org>
	Tested-by: Joe Quanaim <jdq@meta.com>
	Tested-by: Andrew Steffen <aksteffen@meta.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
Fixes: bd37d6fce184 ("NFSv4: Convert nfs_lock_and_join_requests() to use nfs_page_find_head_request()")
	Cc: stable@vger.kernel.org
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 76d2e3890fb169168c73f2e4f8375c7cc24a765e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/write.c
diff --cc fs/nfs/write.c
index 320ba093a736,8b7c04737967..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -147,32 -153,15 +147,22 @@@ nfs_page_set_inode_ref(struct nfs_page 
  	}
  }
  
- static int
- nfs_cancel_remove_inode(struct nfs_page *req, struct inode *inode)
+ static void nfs_cancel_remove_inode(struct nfs_page *req, struct inode *inode)
  {
- 	int ret;
- 
- 	if (!test_bit(PG_REMOVE, &req->wb_flags))
- 		return 0;
- 	ret = nfs_page_group_lock(req);
- 	if (ret)
- 		return ret;
  	if (test_and_clear_bit(PG_REMOVE, &req->wb_flags))
  		nfs_page_set_inode_ref(req, inode);
- 	nfs_page_group_unlock(req);
- 	return 0;
  }
  
 -/**
 - * nfs_folio_find_head_request - find head request associated with a folio
 - * @folio: pointer to folio
 +static struct nfs_page *
 +nfs_page_private_request(struct page *page)
 +{
 +	if (!PagePrivate(page))
 +		return NULL;
 +	return (struct nfs_page *)page_private(page);
 +}
 +
 +/*
 + * nfs_page_find_head_request_locked - find head request associated with @page
   *
   * must be called while holding the inode lock.
   *
@@@ -563,20 -562,50 +553,48 @@@ nfs_lock_and_join_requests(struct page 
  	 * reference to the whole page group - the group will not be destroyed
  	 * until the head reference is released.
  	 */
++<<<<<<< HEAD
 +	head = nfs_find_and_lock_page_request(page);
 +	if (IS_ERR_OR_NULL(head))
 +		return head;
++=======
+ retry:
+ 	head = nfs_folio_find_head_request(folio);
+ 	if (!head)
+ 		return NULL;
+ 
+ 	while (!nfs_lock_request(head)) {
+ 		ret = nfs_wait_on_request(head);
+ 		if (ret < 0) {
+ 			nfs_release_request(head);
+ 			return ERR_PTR(ret);
+ 		}
+ 	}
+ 
+ 	ret = nfs_page_group_lock(head);
+ 	if (ret < 0)
+ 		goto out_unlock;
+ 
+ 	/* Ensure that nobody removed the request before we locked it */
+ 	if (head != folio->private) {
+ 		nfs_page_group_unlock(head);
+ 		nfs_unlock_and_release_request(head);
+ 		goto retry;
+ 	}
+ 
+ 	nfs_cancel_remove_inode(head, inode);
++>>>>>>> 76d2e3890fb1 (NFS: Fix a race when updating an existing write)
  
  	/* lock each request in the page group */
 -	for (subreq = head->wb_this_page;
 -	     subreq != head;
 -	     subreq = subreq->wb_this_page) {
 -		ret = nfs_page_group_lock_subreq(head, subreq);
 -		if (ret < 0)
 -			goto out_unlock;
 +	ret = nfs_page_group_lock_subrequests(head);
 +	if (ret < 0) {
 +		nfs_unlock_and_release_request(head);
 +		return ERR_PTR(ret);
  	}
  
 -	nfs_page_group_unlock(head);
 +	nfs_join_page_group(head, inode);
  
 -	nfs_init_cinfo_from_inode(&cinfo, inode);
 -	nfs_join_page_group(head, &cinfo, inode);
  	return head;
 -
 -out_unlock:
 -	nfs_unlock_and_release_request(head);
 -	return ERR_PTR(ret);
  }
  
  static void nfs_write_error(struct nfs_page *req, int error)
@@@ -764,26 -773,26 +782,34 @@@ static void nfs_inode_add_request(struc
   */
  static void nfs_inode_remove_request(struct nfs_page *req)
  {
 -	struct nfs_inode *nfsi = NFS_I(nfs_page_to_inode(req));
 +	struct address_space *mapping = page_file_mapping(req->wb_page);
 +	struct inode *inode = mapping->host;
 +	struct nfs_inode *nfsi = NFS_I(inode);
 +	struct nfs_page *head;
  
++<<<<<<< HEAD
 +	if (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {
 +		head = req->wb_head;
++=======
+ 	nfs_page_group_lock(req);
+ 	if (nfs_page_group_sync_on_bit_locked(req, PG_REMOVE)) {
+ 		struct folio *folio = nfs_page_to_folio(req->wb_head);
+ 		struct address_space *mapping = folio->mapping;
++>>>>>>> 76d2e3890fb1 (NFS: Fix a race when updating an existing write)
  
 -		spin_lock(&mapping->i_private_lock);
 -		if (likely(folio)) {
 -			folio->private = NULL;
 -			folio_clear_private(folio);
 -			clear_bit(PG_MAPPED, &req->wb_head->wb_flags);
 +		spin_lock(&mapping->private_lock);
 +		if (likely(head->wb_page && !PageSwapCache(head->wb_page))) {
 +			set_page_private(head->wb_page, 0);
 +			ClearPagePrivate(head->wb_page);
 +			clear_bit(PG_MAPPED, &head->wb_flags);
  		}
 -		spin_unlock(&mapping->i_private_lock);
 +		spin_unlock(&mapping->private_lock);
  	}
+ 	nfs_page_group_unlock(req);
  
  	if (test_and_clear_bit(PG_INODE_REF, &req->wb_flags)) {
 -		atomic_long_dec(&nfsi->nrequests);
  		nfs_release_request(req);
 +		atomic_long_dec(&nfsi->nrequests);
  	}
  }
  
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index 9f10091ad777..2e195c92f3f5 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -309,13 +309,14 @@ nfs_page_group_unlock(struct nfs_page *req)
 	nfs_page_clear_headlock(req);
 }
 
-/*
- * nfs_page_group_sync_on_bit_locked
+/**
+ * nfs_page_group_sync_on_bit_locked - Test if all requests have @bit set
+ * @req: request in page group
+ * @bit: PG_* bit that is used to sync page group
  *
  * must be called with page group lock held
  */
-static bool
-nfs_page_group_sync_on_bit_locked(struct nfs_page *req, unsigned int bit)
+bool nfs_page_group_sync_on_bit_locked(struct nfs_page *req, unsigned int bit)
 {
 	struct nfs_page *head = req->wb_head;
 	struct nfs_page *tmp;
* Unmerged path fs/nfs/write.c
diff --git a/include/linux/nfs_page.h b/include/linux/nfs_page.h
index f0373a6cb5fb..b244ba806544 100644
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@ -149,6 +149,7 @@ extern	void nfs_join_page_group(struct nfs_page *head, struct inode *inode);
 extern int nfs_page_group_lock(struct nfs_page *);
 extern void nfs_page_group_unlock(struct nfs_page *);
 extern bool nfs_page_group_sync_on_bit(struct nfs_page *, unsigned int);
+extern bool nfs_page_group_sync_on_bit_locked(struct nfs_page *, unsigned int);
 extern	int nfs_page_set_headlock(struct nfs_page *req);
 extern void nfs_page_clear_headlock(struct nfs_page *req);
 extern bool nfs_async_iocounter_wait(struct rpc_task *, struct nfs_lock_context *);
