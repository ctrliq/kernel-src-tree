cifs: get rid of unneeded conditional in cifs_get_num_sgs()

jira LE-2169
Rebuild_History Non-Buildable kernel-4.18.0-553.27.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit 89542781737a783d94ace958548caa0651bfbc5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.27.1.el8_10/89542781.failed

Just have @skip set to 0 after first iterations of the two nested
loops.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 89542781737a783d94ace958548caa0651bfbc5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsglob.h
diff --cc fs/cifs/cifsglob.h
index e889d829743c,b26e824d6a0c..000000000000
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@@ -2002,4 -2143,82 +2002,85 @@@ static inline size_t ntlmssp_workstatio
  	return sizeof(ses->workstation_name);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void move_cifs_info_to_smb2(struct smb2_file_all_info *dst, const FILE_ALL_INFO *src)
+ {
+ 	memcpy(dst, src, (size_t)((u8 *)&src->AccessFlags - (u8 *)src));
+ 	dst->AccessFlags = src->AccessFlags;
+ 	dst->CurrentByteOffset = src->CurrentByteOffset;
+ 	dst->Mode = src->Mode;
+ 	dst->AlignmentRequirement = src->AlignmentRequirement;
+ 	dst->FileNameLength = src->FileNameLength;
+ }
+ 
+ static inline unsigned int cifs_get_num_sgs(const struct smb_rqst *rqst,
+ 					    int num_rqst,
+ 					    const u8 *sig)
+ {
+ 	unsigned int len, skip;
+ 	unsigned int nents = 0;
+ 	unsigned long addr;
+ 	int i, j;
+ 
+ 	/*
+ 	 * The first rqst has a transform header where the first 20 bytes are
+ 	 * not part of the encrypted blob.
+ 	 */
+ 	skip = 20;
+ 
+ 	/* Assumes the first rqst has a transform header as the first iov.
+ 	 * I.e.
+ 	 * rqst[0].rq_iov[0]  is transform header
+ 	 * rqst[0].rq_iov[1+] data to be encrypted/decrypted
+ 	 * rqst[1+].rq_iov[0+] data to be encrypted/decrypted
+ 	 */
+ 	for (i = 0; i < num_rqst; i++) {
+ 		for (j = 0; j < rqst[i].rq_nvec; j++) {
+ 			struct kvec *iov = &rqst[i].rq_iov[j];
+ 
+ 			addr = (unsigned long)iov->iov_base + skip;
+ 			if (unlikely(is_vmalloc_addr((void *)addr))) {
+ 				len = iov->iov_len - skip;
+ 				nents += DIV_ROUND_UP(offset_in_page(addr) + len,
+ 						      PAGE_SIZE);
+ 			} else {
+ 				nents++;
+ 			}
+ 			skip = 0;
+ 		}
+ 		nents += rqst[i].rq_npages;
+ 	}
+ 	nents += DIV_ROUND_UP(offset_in_page(sig) + SMB2_SIGNATURE_SIZE, PAGE_SIZE);
+ 	return nents;
+ }
+ 
+ /* We can not use the normal sg_set_buf() as we will sometimes pass a
+  * stack object as buf.
+  */
+ static inline struct scatterlist *cifs_sg_set_buf(struct scatterlist *sg,
+ 						  const void *buf,
+ 						  unsigned int buflen)
+ {
+ 	unsigned long addr = (unsigned long)buf;
+ 	unsigned int off = offset_in_page(addr);
+ 
+ 	addr &= PAGE_MASK;
+ 	if (unlikely(is_vmalloc_addr((void *)addr))) {
+ 		do {
+ 			unsigned int len = min_t(unsigned int, buflen, PAGE_SIZE - off);
+ 
+ 			sg_set_page(sg++, vmalloc_to_page((void *)addr), len, off);
+ 
+ 			off = 0;
+ 			addr += PAGE_SIZE;
+ 			buflen -= len;
+ 		} while (buflen);
+ 	} else {
+ 		sg_set_page(sg++, virt_to_page(addr), buflen, off);
+ 	}
+ 	return sg;
+ }
+ 
++>>>>>>> 89542781737a (cifs: get rid of unneeded conditional in cifs_get_num_sgs())
  #endif	/* _CIFS_GLOB_H */
* Unmerged path fs/cifs/cifsglob.h
