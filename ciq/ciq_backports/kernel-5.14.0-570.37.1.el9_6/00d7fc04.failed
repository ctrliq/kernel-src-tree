x86/cpu: Add cpu_type to struct x86_cpu_id

jira LE-4018
Rebuild_History Non-Buildable kernel-5.14.0-570.37.1.el9_6
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit 00d7fc04b703eb3e9d61dd3eac02a34c466e9f12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.37.1.el9_6/00d7fc04.failed

In addition to matching vendor/family/model/feature, for hybrid variants it is
required to also match cpu-type. For example, some CPU vulnerabilities like
RFDS only affect a specific cpu-type.

To be able to also match CPUs based on their type, add a new field "type" to
struct x86_cpu_id which is used by the CPU-matching tables. Introduce
X86_CPU_TYPE_ANY for the cases that don't care about the cpu-type.

  [ bp: Massage commit message. ]

	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
Link: https://lore.kernel.org/r/20250311-add-cpu-type-v8-3-e8514dcaaff2@linux.intel.com
(cherry picked from commit 00d7fc04b703eb3e9d61dd3eac02a34c466e9f12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpu_device_id.h
diff --cc arch/x86/include/asm/cpu_device_id.h
index f794121850a7,6be777a06944..000000000000
--- a/arch/x86/include/asm/cpu_device_id.h
+++ b/arch/x86/include/asm/cpu_device_id.h
@@@ -75,19 -74,7 +75,23 @@@
   * into another macro at the usage site for good reasons, then please
   * start this local macro with X86_MATCH to allow easy grepping.
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE(_vendor, _family, _model, \
 +						    _steppings, _feature, _data) { \
 +	.vendor		= X86_VENDOR_##_vendor,				\
 +	.family		= _family,					\
 +	.model		= _model,					\
 +	.steppings	= _steppings,					\
 +	.feature	= _feature,					\
 +	.flags		= X86_CPU_ID_FLAG_ENTRY_VALID,			\
 +	.driver_data	= (unsigned long) _data				\
 +}
 +
 +#define X86_MATCH_VENDORID_FAM_MODEL_STEPPINGS_FEATURE(_vendor, _family, _model, \
 +						    _steppings, _feature, _data) { \
++=======
+ #define X86_MATCH_CPU(_vendor, _family, _model, _steppings, _feature, _type, _data) { \
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  	.vendor		= _vendor,					\
  	.family		= _family,					\
  	.model		= _model,					\
@@@ -124,13 -94,10 +129,19 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is casted to unsigned long internally.
 + *
 + * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
 + * set to wildcards.
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VENDOR_FAM_FEATURE(vendor, family, feature, data)	\
 +	X86_MATCH_VENDOR_FAM_MODEL_FEATURE(vendor, family,		\
 +					   X86_MODEL_ANY, feature, data)
++=======
+ #define X86_MATCH_VENDOR_FAM_FEATURE(vendor, family, feature, data)		\
+ 	X86_MATCH_CPU(X86_VENDOR_##vendor, family, X86_MODEL_ANY,		\
+ 		      X86_STEPPING_ANY, feature, X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  /**
   * X86_MATCH_VENDOR_FEATURE - Macro for matching vendor and CPU feature
@@@ -140,12 -107,10 +151,18 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is casted to unsigned long internally.
 + *
 + * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
 + * set to wildcards.
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VENDOR_FEATURE(vendor, feature, data)			\
 +	X86_MATCH_VENDOR_FAM_FEATURE(vendor, X86_FAMILY_ANY, feature, data)
++=======
+ #define X86_MATCH_VENDOR_FEATURE(vendor, feature, data)				\
+ 	X86_MATCH_CPU(X86_VENDOR_##vendor, X86_FAMILY_ANY, X86_MODEL_ANY,	\
+ 		      X86_STEPPING_ANY, feature, X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  /**
   * X86_MATCH_FEATURE - Macro for matching a CPU feature
@@@ -153,12 -118,10 +170,18 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is casted to unsigned long internally.
 + *
 + * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
 + * set to wildcards.
   */
++<<<<<<< HEAD
 +#define X86_MATCH_FEATURE(feature, data)				\
 +	X86_MATCH_VENDOR_FEATURE(ANY, feature, data)
++=======
+ #define X86_MATCH_FEATURE(feature, data)					\
+ 	X86_MATCH_CPU(X86_VENDOR_ANY, X86_FAMILY_ANY, X86_MODEL_ANY,		\
+ 		      X86_STEPPING_ANY, feature, X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  /**
   * X86_MATCH_VENDOR_FAM_MODEL - Match vendor, family and model
@@@ -169,13 -132,10 +192,19 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is casted to unsigned long internally.
 + *
 + * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
 + * set to wildcards.
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VENDOR_FAM_MODEL(vendor, family, model, data)		\
 +	X86_MATCH_VENDOR_FAM_MODEL_FEATURE(vendor, family, model,	\
 +					   X86_FEATURE_ANY, data)
++=======
+ #define X86_MATCH_VENDOR_FAM_MODEL(vendor, family, model, data)			\
+ 	X86_MATCH_CPU(X86_VENDOR_##vendor, family, model, X86_STEPPING_ANY,	\
+ 		      X86_FEATURE_ANY, X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  /**
   * X86_MATCH_VENDOR_FAM - Match vendor and family
@@@ -185,32 -145,10 +214,38 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is casted to unsigned long internally.
 + *
 + * All other missing arguments to X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
 + * set of wildcards.
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VENDOR_FAM(vendor, family, data)			\
 +	X86_MATCH_VENDOR_FAM_MODEL(vendor, family, X86_MODEL_ANY, data)
 +
 +/**
 + * X86_MATCH_INTEL_FAM6_MODEL - Match vendor INTEL, family 6 and model
 + * @model:	The model name without the INTEL_FAM6_ prefix or ANY
 + *		The model name is expanded to INTEL_FAM6_@model internally
 + * @data:	Driver specific data or NULL. The internal storage
 + *		format is unsigned long. The supplied value, pointer
 + *		etc. is casted to unsigned long internally.
 + *
 + * The vendor is set to INTEL, the family to 6 and all other missing
 + * arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are set to wildcards.
 + *
 + * See X86_MATCH_VENDOR_FAM_MODEL_FEATURE() for further information.
 + */
 +#define X86_MATCH_INTEL_FAM6_MODEL(model, data)				\
 +	X86_MATCH_VENDOR_FAM_MODEL(INTEL, 6, INTEL_FAM6_##model, data)
 +
 +#define X86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(model, steppings, data)	\
 +	X86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE(INTEL, 6, INTEL_FAM6_##model, \
 +						     steppings, X86_FEATURE_ANY, data)
++=======
+ #define X86_MATCH_VENDOR_FAM(vendor, family, data)				\
+ 	X86_MATCH_CPU(X86_VENDOR_##vendor, family, X86_MODEL_ANY,		\
+ 		      X86_STEPPING_ANY, X86_FEATURE_ANY, X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  /**
   * X86_MATCH_VFM - Match encoded vendor/family/model
@@@ -218,16 -156,12 +253,22 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is cast to unsigned long internally.
 + *
 + * Stepping and feature are set to wildcards
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VFM(vfm, data)			\
 +	X86_MATCH_VENDORID_FAM_MODEL_STEPPINGS_FEATURE(	\
 +		VFM_VENDOR(vfm),			\
 +		VFM_FAMILY(vfm),			\
 +		VFM_MODEL(vfm),				\
 +		X86_STEPPING_ANY, X86_FEATURE_ANY, data)
++=======
+ #define X86_MATCH_VFM(vfm, data)						\
+ 	X86_MATCH_CPU(VFM_VENDOR(vfm), VFM_FAMILY(vfm),	VFM_MODEL(vfm),		\
+ 		      X86_STEPPING_ANY, X86_FEATURE_ANY, X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
 -#define __X86_STEPPINGS(mins, maxs)    GENMASK(maxs, mins)
  /**
   * X86_MATCH_VFM_STEPS - Match encoded vendor/family/model and steppings
   *			 range.
@@@ -237,15 -171,11 +278,22 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is cast to unsigned long internally.
 + *
 + * feature is set to wildcard
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VFM_STEPPINGS(vfm, steppings, data)	\
 +	X86_MATCH_VENDORID_FAM_MODEL_STEPPINGS_FEATURE(	\
 +		VFM_VENDOR(vfm),			\
 +		VFM_FAMILY(vfm),			\
 +		VFM_MODEL(vfm),				\
 +		steppings, X86_FEATURE_ANY, data)
++=======
+ #define X86_MATCH_VFM_STEPS(vfm, min_step, max_step, data)			\
+ 	X86_MATCH_CPU(VFM_VENDOR(vfm), VFM_FAMILY(vfm), VFM_MODEL(vfm),		\
+ 		      __X86_STEPPINGS(min_step, max_step), X86_FEATURE_ANY,	\
+ 		      X86_CPU_TYPE_ANY, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  /**
   * X86_MATCH_VFM_FEATURE - Match encoded vendor/family/model/feature
@@@ -254,43 -184,24 +302,61 @@@
   * @data:	Driver specific data or NULL. The internal storage
   *		format is unsigned long. The supplied value, pointer
   *		etc. is cast to unsigned long internally.
 + *
 + * Steppings is set to wildcard
   */
++<<<<<<< HEAD
 +#define X86_MATCH_VFM_FEATURE(vfm, feature, data)	\
 +	X86_MATCH_VENDORID_FAM_MODEL_STEPPINGS_FEATURE(	\
 +		VFM_VENDOR(vfm),			\
 +		VFM_FAMILY(vfm),			\
 +		VFM_MODEL(vfm),				\
 +		X86_STEPPING_ANY, feature, data)
 +
 +/*
 + * Match specific microcode revisions.
 + *
 + * vendor/family/model/stepping must be all set.
 + *
 + * Only checks against the boot CPU.  When mixed-stepping configs are
 + * valid for a CPU model, add a quirk for every valid stepping and
 + * do the fine-tuning in the quirk handler.
 + */
 +
 +struct x86_cpu_desc {
 +	u8	x86_family;
 +	u8	x86_vendor;
 +	u8	x86_model;
 +	u8	x86_stepping;
 +	u32	x86_microcode_rev;
 +};
 +
 +#define INTEL_CPU_DESC(vfm, stepping, revision) {		\
 +	.x86_family		= VFM_FAMILY(vfm),		\
 +	.x86_vendor		= VFM_VENDOR(vfm),		\
 +	.x86_model		= VFM_MODEL(vfm),		\
 +	.x86_stepping		= (stepping),			\
 +	.x86_microcode_rev	= (revision),			\
 +}
++=======
+ #define X86_MATCH_VFM_FEATURE(vfm, feature, data)				\
+ 	X86_MATCH_CPU(VFM_VENDOR(vfm), VFM_FAMILY(vfm), VFM_MODEL(vfm),		\
+ 		      X86_STEPPING_ANY, feature, X86_CPU_TYPE_ANY, data)
+ 
+ /**
+  * X86_MATCH_VFM_CPU_TYPE - Match encoded vendor/family/model/type
+  * @vfm:	Encoded 8-bits each for vendor, family, model
+  * @type:	CPU type e.g. P-core, E-core
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is cast to unsigned long internally.
+  */
+ #define X86_MATCH_VFM_CPU_TYPE(vfm, type, data)				\
+ 	X86_MATCH_CPU(VFM_VENDOR(vfm), VFM_FAMILY(vfm), VFM_MODEL(vfm),	\
+ 		      X86_STEPPING_ANY, X86_FEATURE_ANY, type, data)
++>>>>>>> 00d7fc04b703 (x86/cpu: Add cpu_type to struct x86_cpu_id)
  
  extern const struct x86_cpu_id *x86_match_cpu(const struct x86_cpu_id *match);
 -extern bool x86_match_min_microcode_rev(const struct x86_cpu_id *table);
 +extern bool x86_cpu_has_min_microcode_rev(const struct x86_cpu_desc *table);
  
  #endif /* _ASM_X86_CPU_DEVICE_ID */
* Unmerged path arch/x86/include/asm/cpu_device_id.h
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index fd6bf714b9c8..0e4e0ee31d14 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -679,6 +679,7 @@ struct x86_cpu_id {
 	__u16 feature;	/* bit index */
 	/* Solely for kernel-internal use: DO NOT EXPORT to userspace! */
 	__u16 flags;
+	__u8  type;
 	kernel_ulong_t driver_data;
 };
 
@@ -688,6 +689,7 @@ struct x86_cpu_id {
 #define X86_MODEL_ANY  0
 #define X86_STEPPING_ANY 0
 #define X86_FEATURE_ANY 0	/* Same as FPU, you can't test for that */
+#define X86_CPU_TYPE_ANY 0
 
 /*
  * Generic table type for matching CPU features.
