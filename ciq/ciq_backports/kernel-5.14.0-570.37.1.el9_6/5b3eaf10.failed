x86/platform/atom: Switch to new Intel CPU model defines

jira LE-4018
Rebuild_History Non-Buildable kernel-5.14.0-570.37.1.el9_6
commit-author Tony Luck <tony.luck@intel.com>
commit 5b3eaf10e2e0a3df5c8dfd6aabc6aec435383ba0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.37.1.el9_6/5b3eaf10.failed

New CPU #defines encode vendor and family as well as model.

	Signed-off-by: Tony Luck <tony.luck@intel.com>
Link: https://lore.kernel.org/r/20240531203706.233365-4-tony.luck@intel.com
	Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
	Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
(cherry picked from commit 5b3eaf10e2e0a3df5c8dfd6aabc6aec435383ba0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/atom/punit_atom_debug.c
diff --cc arch/x86/platform/atom/punit_atom_debug.c
index f8ed5f66cd20,44c30ce6360a..000000000000
--- a/arch/x86/platform/atom/punit_atom_debug.c
+++ b/arch/x86/platform/atom/punit_atom_debug.c
@@@ -117,14 -120,58 +117,64 @@@ static void punit_dbgfs_unregister(void
  	debugfs_remove_recursive(punit_dbg_file);
  }
  
++<<<<<<< HEAD
 +#define X86_MATCH(model, data)						 \
 +	X86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL, 6, INTEL_FAM6_##model, \
 +					   X86_FEATURE_MWAIT, data)
++=======
+ #if defined(CONFIG_ACPI) && defined(CONFIG_SUSPEND)
+ static const struct punit_device *punit_dev;
+ 
+ static void punit_s2idle_check(void)
+ {
+ 	const struct punit_device *punit_devp;
+ 	u32 punit_pwr_status, dstate;
+ 	int status;
+ 
+ 	for (punit_devp = punit_dev; punit_devp->name; punit_devp++) {
+ 		/* Skip MIO, it is on till the very last moment */
+ 		if (punit_devp->reg == MIO_SS_PM)
+ 			continue;
+ 
+ 		status = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,
+ 				       punit_devp->reg, &punit_pwr_status);
+ 		if (status) {
+ 			pr_err("%s read failed\n", punit_devp->name);
+ 		} else  {
+ 			dstate = (punit_pwr_status >> punit_devp->sss_pos) & 3;
+ 			if (!dstate)
+ 				pr_err("%s is in D0 prior to s2idle\n", punit_devp->name);
+ 		}
+ 	}
+ }
+ 
+ static struct acpi_s2idle_dev_ops punit_s2idle_ops = {
+ 	.check = punit_s2idle_check,
+ };
+ 
+ static void punit_s2idle_check_register(struct punit_device *punit_device)
+ {
+ 	punit_dev = punit_device;
+ 	acpi_register_lps0_dev(&punit_s2idle_ops);
+ }
+ 
+ static void punit_s2idle_check_unregister(void)
+ {
+ 	acpi_unregister_lps0_dev(&punit_s2idle_ops);
+ }
+ #else
+ static void punit_s2idle_check_register(struct punit_device *punit_device) {}
+ static void punit_s2idle_check_unregister(void) {}
+ #endif
+ 
+ #define X86_MATCH(vfm, data)					 \
+ 	X86_MATCH_VFM_FEATURE(vfm, X86_FEATURE_MWAIT, data)
++>>>>>>> 5b3eaf10e2e0 (x86/platform/atom: Switch to new Intel CPU model defines)
  
  static const struct x86_cpu_id intel_punit_cpu_ids[] = {
- 	X86_MATCH(ATOM_SILVERMONT,		&punit_device_byt),
- 	X86_MATCH(ATOM_SILVERMONT_MID,		&punit_device_tng),
- 	X86_MATCH(ATOM_AIRMONT,			&punit_device_cht),
+ 	X86_MATCH(INTEL_ATOM_SILVERMONT,	&punit_device_byt),
+ 	X86_MATCH(INTEL_ATOM_SILVERMONT_MID,	&punit_device_tng),
+ 	X86_MATCH(INTEL_ATOM_AIRMONT,		&punit_device_cht),
  	{}
  };
  MODULE_DEVICE_TABLE(x86cpu, intel_punit_cpu_ids);
* Unmerged path arch/x86/platform/atom/punit_atom_debug.c
