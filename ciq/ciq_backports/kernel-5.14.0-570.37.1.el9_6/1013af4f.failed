mm/hugetlb: fix huge_pmd_unshare() vs GUP-fast race

jira LE-4018
cve CVE-2025-38085
Rebuild_History Non-Buildable kernel-5.14.0-570.37.1.el9_6
commit-author Jann Horn <jannh@google.com>
commit 1013af4f585fccc4d3e5c5824d174de2257f7d6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.37.1.el9_6/1013af4f.failed

huge_pmd_unshare() drops a reference on a page table that may have
previously been shared across processes, potentially turning it into a
normal page table used in another process in which unrelated VMAs can
afterwards be installed.

If this happens in the middle of a concurrent gup_fast(), gup_fast() could
end up walking the page tables of another process.  While I don't see any
way in which that immediately leads to kernel memory corruption, it is
really weird and unexpected.

Fix it with an explicit broadcast IPI through tlb_remove_table_sync_one(),
just like we do in khugepaged when removing page tables for a THP
collapse.

Link: https://lkml.kernel.org/r/20250528-hugetlb-fixes-splitrace-v2-2-1329349bad1a@google.com
Link: https://lkml.kernel.org/r/20250527-hugetlb-fixes-splitrace-v1-2-f4136f5ec58a@google.com
Fixes: 39dde65c9940 ("[PATCH] shared page table for hugetlb page")
	Signed-off-by: Jann Horn <jannh@google.com>
	Reviewed-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
	Cc: Liam Howlett <liam.howlett@oracle.com>
	Cc: Muchun Song <muchun.song@linux.dev>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 1013af4f585fccc4d3e5c5824d174de2257f7d6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hugetlb.c
diff --cc mm/hugetlb.c
index 9bd3d9ecf80c,8746ed2fec13..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -7147,7 -7629,14 +7147,18 @@@ int huge_pmd_unshare(struct mm_struct *
  		return 0;
  
  	pud_clear(pud);
++<<<<<<< HEAD
 +	put_page(virt_to_page(ptep));
++=======
+ 	/*
+ 	 * Once our caller drops the rmap lock, some other process might be
+ 	 * using this page table as a normal, non-hugetlb page table.
+ 	 * Wait for pending gup_fast() in other threads to finish before letting
+ 	 * that happen.
+ 	 */
+ 	tlb_remove_table_sync_one();
+ 	ptdesc_pmd_pts_dec(virt_to_ptdesc(ptep));
++>>>>>>> 1013af4f585f (mm/hugetlb: fix huge_pmd_unshare() vs GUP-fast race)
  	mm_dec_nr_pmds(mm);
  	return 1;
  }
* Unmerged path mm/hugetlb.c
