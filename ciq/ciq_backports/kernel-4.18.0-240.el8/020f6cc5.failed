netfilter: conntrack: avoid use-after free on rmmod

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 020f6cc5f75511c5974cfd454f224365bc0c2df4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/020f6cc5.failed

When the conntrack module is removed, we call nf_ct_iterate_destroy via
nf_ct_l4proto_unregister().

Problem is that nf_conntrack_proto_fini() gets called after the
conntrack hash table has already been freed.

Just remove the l4proto unregister call, its unecessary as the
nf_ct_protos[] array gets free'd right after anyway.

v2: add comment wrt. missing unreg call.

Fixes: a0ae2562c6c4b2 ("netfilter: conntrack: remove l3proto abstraction")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 020f6cc5f75511c5974cfd454f224365bc0c2df4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto.c
diff --cc net/netfilter/nf_conntrack_proto.c
index 928ff492bf36,30070732ee50..000000000000
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@@ -570,6 -395,562 +570,565 @@@ void nf_ct_l4proto_pernet_unregister(st
  }
  EXPORT_SYMBOL_GPL(nf_ct_l4proto_pernet_unregister);
  
++<<<<<<< HEAD
++=======
+ static unsigned int ipv4_helper(void *priv,
+ 				struct sk_buff *skb,
+ 				const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 	const struct nf_conn_help *help;
+ 	const struct nf_conntrack_helper *helper;
+ 
+ 	/* This is where we call the helper: as the packet goes out. */
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		return NF_ACCEPT;
+ 
+ 	help = nfct_help(ct);
+ 	if (!help)
+ 		return NF_ACCEPT;
+ 
+ 	/* rcu_read_lock()ed by nf_hook_thresh */
+ 	helper = rcu_dereference(help->helper);
+ 	if (!helper)
+ 		return NF_ACCEPT;
+ 
+ 	return helper->help(skb, skb_network_offset(skb) + ip_hdrlen(skb),
+ 			    ct, ctinfo);
+ }
+ 
+ static unsigned int ipv4_confirm(void *priv,
+ 				 struct sk_buff *skb,
+ 				 const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		goto out;
+ 
+ 	/* adjust seqs for loopback traffic only in outgoing direction */
+ 	if (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&
+ 	    !nf_is_loopback_packet(skb)) {
+ 		if (!nf_ct_seq_adjust(skb, ct, ctinfo, ip_hdrlen(skb))) {
+ 			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);
+ 			return NF_DROP;
+ 		}
+ 	}
+ out:
+ 	/* We've seen it coming out the other side: confirm it */
+ 	return nf_conntrack_confirm(skb);
+ }
+ 
+ static unsigned int ipv4_conntrack_in(void *priv,
+ 				      struct sk_buff *skb,
+ 				      const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(state->net, PF_INET, state->hook, skb);
+ }
+ 
+ static unsigned int ipv4_conntrack_local(void *priv,
+ 					 struct sk_buff *skb,
+ 					 const struct nf_hook_state *state)
+ {
+ 	if (ip_is_fragment(ip_hdr(skb))) { /* IP_NODEFRAG setsockopt set */
+ 		enum ip_conntrack_info ctinfo;
+ 		struct nf_conn *tmpl;
+ 
+ 		tmpl = nf_ct_get(skb, &ctinfo);
+ 		if (tmpl && nf_ct_is_template(tmpl)) {
+ 			/* when skipping ct, clear templates to avoid fooling
+ 			 * later targets/matches
+ 			 */
+ 			skb->_nfct = 0;
+ 			nf_ct_put(tmpl);
+ 		}
+ 		return NF_ACCEPT;
+ 	}
+ 
+ 	return nf_conntrack_in(state->net, PF_INET, state->hook, skb);
+ }
+ 
+ /* Connection tracking may drop packets, but never alters them, so
+  * make it the first hook.
+  */
+ static const struct nf_hook_ops ipv4_conntrack_ops[] = {
+ 	{
+ 		.hook		= ipv4_conntrack_in,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_PRE_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv4_conntrack_local,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_OUT,
+ 		.priority	= NF_IP_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv4_helper,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv4_confirm,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,
+ 	},
+ 	{
+ 		.hook		= ipv4_helper,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv4_confirm,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,
+ 	},
+ };
+ 
+ /* Fast function for those who don't want to parse /proc (and I don't
+  * blame them).
+  * Reversing the socket's dst/src point of view gives us the reply
+  * mapping.
+  */
+ static int
+ getorigdst(struct sock *sk, int optval, void __user *user, int *len)
+ {
+ 	const struct inet_sock *inet = inet_sk(sk);
+ 	const struct nf_conntrack_tuple_hash *h;
+ 	struct nf_conntrack_tuple tuple;
+ 
+ 	memset(&tuple, 0, sizeof(tuple));
+ 
+ 	lock_sock(sk);
+ 	tuple.src.u3.ip = inet->inet_rcv_saddr;
+ 	tuple.src.u.tcp.port = inet->inet_sport;
+ 	tuple.dst.u3.ip = inet->inet_daddr;
+ 	tuple.dst.u.tcp.port = inet->inet_dport;
+ 	tuple.src.l3num = PF_INET;
+ 	tuple.dst.protonum = sk->sk_protocol;
+ 	release_sock(sk);
+ 
+ 	/* We only do TCP and SCTP at the moment: is there a better way? */
+ 	if (tuple.dst.protonum != IPPROTO_TCP &&
+ 	    tuple.dst.protonum != IPPROTO_SCTP) {
+ 		pr_debug("SO_ORIGINAL_DST: Not a TCP/SCTP socket\n");
+ 		return -ENOPROTOOPT;
+ 	}
+ 
+ 	if ((unsigned int)*len < sizeof(struct sockaddr_in)) {
+ 		pr_debug("SO_ORIGINAL_DST: len %d not %zu\n",
+ 			 *len, sizeof(struct sockaddr_in));
+ 		return -EINVAL;
+ 	}
+ 
+ 	h = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);
+ 	if (h) {
+ 		struct sockaddr_in sin;
+ 		struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+ 
+ 		sin.sin_family = AF_INET;
+ 		sin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]
+ 			.tuple.dst.u.tcp.port;
+ 		sin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]
+ 			.tuple.dst.u3.ip;
+ 		memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+ 
+ 		pr_debug("SO_ORIGINAL_DST: %pI4 %u\n",
+ 			 &sin.sin_addr.s_addr, ntohs(sin.sin_port));
+ 		nf_ct_put(ct);
+ 		if (copy_to_user(user, &sin, sizeof(sin)) != 0)
+ 			return -EFAULT;
+ 		else
+ 			return 0;
+ 	}
+ 	pr_debug("SO_ORIGINAL_DST: Can't find %pI4/%u-%pI4/%u.\n",
+ 		 &tuple.src.u3.ip, ntohs(tuple.src.u.tcp.port),
+ 		 &tuple.dst.u3.ip, ntohs(tuple.dst.u.tcp.port));
+ 	return -ENOENT;
+ }
+ 
+ static struct nf_sockopt_ops so_getorigdst = {
+ 	.pf		= PF_INET,
+ 	.get_optmin	= SO_ORIGINAL_DST,
+ 	.get_optmax	= SO_ORIGINAL_DST + 1,
+ 	.get		= getorigdst,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int
+ ipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)
+ {
+ 	struct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };
+ 	const struct ipv6_pinfo *inet6 = inet6_sk(sk);
+ 	const struct inet_sock *inet = inet_sk(sk);
+ 	const struct nf_conntrack_tuple_hash *h;
+ 	struct sockaddr_in6 sin6;
+ 	struct nf_conn *ct;
+ 	__be32 flow_label;
+ 	int bound_dev_if;
+ 
+ 	lock_sock(sk);
+ 	tuple.src.u3.in6 = sk->sk_v6_rcv_saddr;
+ 	tuple.src.u.tcp.port = inet->inet_sport;
+ 	tuple.dst.u3.in6 = sk->sk_v6_daddr;
+ 	tuple.dst.u.tcp.port = inet->inet_dport;
+ 	tuple.dst.protonum = sk->sk_protocol;
+ 	bound_dev_if = sk->sk_bound_dev_if;
+ 	flow_label = inet6->flow_label;
+ 	release_sock(sk);
+ 
+ 	if (tuple.dst.protonum != IPPROTO_TCP &&
+ 	    tuple.dst.protonum != IPPROTO_SCTP)
+ 		return -ENOPROTOOPT;
+ 
+ 	if (*len < 0 || (unsigned int)*len < sizeof(sin6))
+ 		return -EINVAL;
+ 
+ 	h = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);
+ 	if (!h) {
+ 		pr_debug("IP6T_SO_ORIGINAL_DST: Can't find %pI6c/%u-%pI6c/%u.\n",
+ 			 &tuple.src.u3.ip6, ntohs(tuple.src.u.tcp.port),
+ 			 &tuple.dst.u3.ip6, ntohs(tuple.dst.u.tcp.port));
+ 		return -ENOENT;
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+ 
+ 	sin6.sin6_family = AF_INET6;
+ 	sin6.sin6_port = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port;
+ 	sin6.sin6_flowinfo = flow_label & IPV6_FLOWINFO_MASK;
+ 	memcpy(&sin6.sin6_addr,
+ 	       &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.in6,
+ 	       sizeof(sin6.sin6_addr));
+ 
+ 	nf_ct_put(ct);
+ 	sin6.sin6_scope_id = ipv6_iface_scope_id(&sin6.sin6_addr, bound_dev_if);
+ 	return copy_to_user(user, &sin6, sizeof(sin6)) ? -EFAULT : 0;
+ }
+ 
+ static struct nf_sockopt_ops so_getorigdst6 = {
+ 	.pf		= NFPROTO_IPV6,
+ 	.get_optmin	= IP6T_SO_ORIGINAL_DST,
+ 	.get_optmax	= IP6T_SO_ORIGINAL_DST + 1,
+ 	.get		= ipv6_getorigdst,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ static unsigned int ipv6_confirm(void *priv,
+ 				 struct sk_buff *skb,
+ 				 const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 	unsigned char pnum = ipv6_hdr(skb)->nexthdr;
+ 	int protoff;
+ 	__be16 frag_off;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		goto out;
+ 
+ 	protoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &pnum,
+ 				   &frag_off);
+ 	if (protoff < 0 || (frag_off & htons(~0x7)) != 0) {
+ 		pr_debug("proto header not found\n");
+ 		goto out;
+ 	}
+ 
+ 	/* adjust seqs for loopback traffic only in outgoing direction */
+ 	if (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&
+ 	    !nf_is_loopback_packet(skb)) {
+ 		if (!nf_ct_seq_adjust(skb, ct, ctinfo, protoff)) {
+ 			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);
+ 			return NF_DROP;
+ 		}
+ 	}
+ out:
+ 	/* We've seen it coming out the other side: confirm it */
+ 	return nf_conntrack_confirm(skb);
+ }
+ 
+ static unsigned int ipv6_conntrack_in(void *priv,
+ 				      struct sk_buff *skb,
+ 				      const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(state->net, PF_INET6, state->hook, skb);
+ }
+ 
+ static unsigned int ipv6_conntrack_local(void *priv,
+ 					 struct sk_buff *skb,
+ 					 const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(state->net, PF_INET6, state->hook, skb);
+ }
+ 
+ static unsigned int ipv6_helper(void *priv,
+ 				struct sk_buff *skb,
+ 				const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	const struct nf_conn_help *help;
+ 	const struct nf_conntrack_helper *helper;
+ 	enum ip_conntrack_info ctinfo;
+ 	__be16 frag_off;
+ 	int protoff;
+ 	u8 nexthdr;
+ 
+ 	/* This is where we call the helper: as the packet goes out. */
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		return NF_ACCEPT;
+ 
+ 	help = nfct_help(ct);
+ 	if (!help)
+ 		return NF_ACCEPT;
+ 	/* rcu_read_lock()ed by nf_hook_thresh */
+ 	helper = rcu_dereference(help->helper);
+ 	if (!helper)
+ 		return NF_ACCEPT;
+ 
+ 	nexthdr = ipv6_hdr(skb)->nexthdr;
+ 	protoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,
+ 				   &frag_off);
+ 	if (protoff < 0 || (frag_off & htons(~0x7)) != 0) {
+ 		pr_debug("proto header not found\n");
+ 		return NF_ACCEPT;
+ 	}
+ 
+ 	return helper->help(skb, protoff, ct, ctinfo);
+ }
+ 
+ static const struct nf_hook_ops ipv6_conntrack_ops[] = {
+ 	{
+ 		.hook		= ipv6_conntrack_in,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_PRE_ROUTING,
+ 		.priority	= NF_IP6_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv6_conntrack_local,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_OUT,
+ 		.priority	= NF_IP6_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv6_helper,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP6_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv6_confirm,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP6_PRI_LAST,
+ 	},
+ 	{
+ 		.hook		= ipv6_helper,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP6_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv6_confirm,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP6_PRI_LAST - 1,
+ 	},
+ };
+ #endif
+ 
+ static int nf_ct_netns_do_get(struct net *net, u8 nfproto)
+ {
+ 	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
+ 	int err = 0;
+ 
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 
+ 	switch (nfproto) {
+ 	case NFPROTO_IPV4:
+ 		cnet->users4++;
+ 		if (cnet->users4 > 1)
+ 			goto out_unlock;
+ 		err = nf_defrag_ipv4_enable(net);
+ 		if (err) {
+ 			cnet->users4 = 0;
+ 			goto out_unlock;
+ 		}
+ 
+ 		err = nf_register_net_hooks(net, ipv4_conntrack_ops,
+ 					    ARRAY_SIZE(ipv4_conntrack_ops));
+ 		if (err)
+ 			cnet->users4 = 0;
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case NFPROTO_IPV6:
+ 		cnet->users6++;
+ 		if (cnet->users6 > 1)
+ 			goto out_unlock;
+ 		err = nf_defrag_ipv6_enable(net);
+ 		if (err < 0) {
+ 			cnet->users6 = 0;
+ 			goto out_unlock;
+ 		}
+ 
+ 		err = nf_register_net_hooks(net, ipv6_conntrack_ops,
+ 					    ARRAY_SIZE(ipv6_conntrack_ops));
+ 		if (err)
+ 			cnet->users6 = 0;
+ 		break;
+ #endif
+ 	default:
+ 		err = -EPROTO;
+ 		break;
+ 	}
+  out_unlock:
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ 	return err;
+ }
+ 
+ static void nf_ct_netns_do_put(struct net *net, u8 nfproto)
+ {
+ 	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
+ 
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 	switch (nfproto) {
+ 	case NFPROTO_IPV4:
+ 		if (cnet->users4 && (--cnet->users4 == 0))
+ 			nf_unregister_net_hooks(net, ipv4_conntrack_ops,
+ 						ARRAY_SIZE(ipv4_conntrack_ops));
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case NFPROTO_IPV6:
+ 		if (cnet->users6 && (--cnet->users6 == 0))
+ 			nf_unregister_net_hooks(net, ipv6_conntrack_ops,
+ 						ARRAY_SIZE(ipv6_conntrack_ops));
+ 		break;
+ #endif
+ 	}
+ 
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ }
+ 
+ int nf_ct_netns_get(struct net *net, u8 nfproto)
+ {
+ 	int err;
+ 
+ 	if (nfproto == NFPROTO_INET) {
+ 		err = nf_ct_netns_do_get(net, NFPROTO_IPV4);
+ 		if (err < 0)
+ 			goto err1;
+ 		err = nf_ct_netns_do_get(net, NFPROTO_IPV6);
+ 		if (err < 0)
+ 			goto err2;
+ 	} else {
+ 		err = nf_ct_netns_do_get(net, nfproto);
+ 		if (err < 0)
+ 			goto err1;
+ 	}
+ 	return 0;
+ 
+ err2:
+ 	nf_ct_netns_put(net, NFPROTO_IPV4);
+ err1:
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(nf_ct_netns_get);
+ 
+ void nf_ct_netns_put(struct net *net, uint8_t nfproto)
+ {
+ 	if (nfproto == NFPROTO_INET) {
+ 		nf_ct_netns_do_put(net, NFPROTO_IPV4);
+ 		nf_ct_netns_do_put(net, NFPROTO_IPV6);
+ 	} else {
+ 		nf_ct_netns_do_put(net, nfproto);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(nf_ct_netns_put);
+ 
+ static const struct nf_conntrack_l4proto * const builtin_l4proto[] = {
+ 	&nf_conntrack_l4proto_tcp4,
+ 	&nf_conntrack_l4proto_udp4,
+ 	&nf_conntrack_l4proto_icmp,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp4,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	&nf_conntrack_l4proto_sctp4,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ 	&nf_conntrack_l4proto_udplite4,
+ #endif
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	&nf_conntrack_l4proto_tcp6,
+ 	&nf_conntrack_l4proto_udp6,
+ 	&nf_conntrack_l4proto_icmpv6,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp6,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	&nf_conntrack_l4proto_sctp6,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ 	&nf_conntrack_l4proto_udplite6,
+ #endif
+ #endif /* CONFIG_IPV6 */
+ };
+ 
+ int nf_conntrack_proto_init(void)
+ {
+ 	int ret = 0;
+ 
+ 	ret = nf_register_sockopt(&so_getorigdst);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	ret = nf_register_sockopt(&so_getorigdst6);
+ 	if (ret < 0)
+ 		goto cleanup_sockopt;
+ #endif
+ 	ret = nf_ct_l4proto_register(builtin_l4proto,
+ 				     ARRAY_SIZE(builtin_l4proto));
+ 	if (ret < 0)
+ 		goto cleanup_sockopt2;
+ 
+ 	return ret;
+ cleanup_sockopt2:
+ 	nf_unregister_sockopt(&so_getorigdst);
+ #if IS_ENABLED(CONFIG_IPV6)
+ cleanup_sockopt:
+ 	nf_unregister_sockopt(&so_getorigdst6);
+ #endif
+ 	return ret;
+ }
+ 
+ void nf_conntrack_proto_fini(void)
+ {
+ 	unsigned int i;
+ 
+ 	nf_unregister_sockopt(&so_getorigdst);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	nf_unregister_sockopt(&so_getorigdst6);
+ #endif
+ 	/* No need to call nf_ct_l4proto_unregister(), the register
+ 	 * tables are free'd here anyway.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(nf_ct_protos); i++)
+ 		kfree(nf_ct_protos[i]);
+ }
+ 
++>>>>>>> 020f6cc5f755 (netfilter: conntrack: avoid use-after free on rmmod)
  int nf_conntrack_proto_pernet_init(struct net *net)
  {
  	int err;
* Unmerged path net/netfilter/nf_conntrack_proto.c
