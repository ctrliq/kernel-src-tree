netfilter: conntrack: allow sctp hearbeat after connection re-use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit cc5453a5b7e90c39f713091a7ebc53c1f87d1700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cc5453a5.failed

If an sctp connection gets re-used, heartbeats are flagged as invalid
because their vtag doesn't match.

Handle this in a similar way as TCP conntrack when it suspects that the
endpoints and conntrack are out-of-sync.

When a HEARTBEAT request fails its vtag validation, flag this in the
conntrack state and accept the packet.

When a HEARTBEAT_ACK is received with an invalid vtag in the reverse
direction after we allowed such a HEARTBEAT through, assume we are
out-of-sync and re-set the vtag info.

v2: remove left-over snippet from an older incarnation that moved
    new_state/old_state assignments, thats not needed so keep that
    as-is.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit cc5453a5b7e90c39f713091a7ebc53c1f87d1700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto_sctp.c
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index d72492231b01,810cca24b399..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -291,8 -369,13 +293,9 @@@ static int sctp_packet(struct nf_conn *
  	const struct sctp_chunkhdr *sch;
  	struct sctp_chunkhdr _sch;
  	u_int32_t offset, count;
 -	unsigned int *timeouts;
  	unsigned long map[256 / sizeof(unsigned long)] = { 0 };
+ 	bool ignore = false;
  
 -	if (sctp_error(skb, dataoff, state))
 -		return -NF_ACCEPT;
 -
  	sh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);
  	if (sh == NULL)
  		goto out;
@@@ -379,6 -497,14 +406,17 @@@
  	}
  	spin_unlock_bh(&ct->lock);
  
++<<<<<<< HEAD
++=======
+ 	/* allow but do not refresh timeout */
+ 	if (ignore)
+ 		return NF_ACCEPT;
+ 
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = nf_sctp_pernet(nf_ct_net(ct))->timeouts;
+ 
++>>>>>>> cc5453a5b7e9 (netfilter: conntrack: allow sctp hearbeat after connection re-use)
  	nf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);
  
  	if (old_state == SCTP_CONNTRACK_COOKIE_ECHOED &&
diff --git a/include/linux/netfilter/nf_conntrack_sctp.h b/include/linux/netfilter/nf_conntrack_sctp.h
index 9a33f171aa82..625f491b95de 100644
--- a/include/linux/netfilter/nf_conntrack_sctp.h
+++ b/include/linux/netfilter/nf_conntrack_sctp.h
@@ -9,6 +9,8 @@ struct ip_ct_sctp {
 	enum sctp_conntrack state;
 
 	__be32 vtag[IP_CT_DIR_MAX];
+	u8 last_dir;
+	u8 flags;
 };
 
 #endif /* _NF_CONNTRACK_SCTP_H */
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
