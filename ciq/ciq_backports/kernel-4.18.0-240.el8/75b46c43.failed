gfs2: Fix oversight in gfs2_ail1_flush

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 75b46c437f6b0f8e37032a407c7373f85f5c26a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/75b46c43.failed

Ordinarily, function gfs2_ail1_start_one issues a write request
for one item on the ail1 list, then returns -EBUSY. This makes the
caller, gfs2_ail1_flush, loop around and start another. However,
it was not clearing the -EBUSY return code each time through the loop.
So on rare occasions, like when the wbc runs out of nr_to_write, it
remained set to -EBUSY, which triggered an error and withdraw.

This patch sets the return code to 0 each time through the restart
loop so this won't happen anymore.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 75b46c437f6b0f8e37032a407c7373f85f5c26a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index 5a2ff16daaae,3a75843ae580..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -153,12 -188,18 +153,25 @@@ void gfs2_ail1_flush(struct gfs2_sbd *s
  	struct list_head *head = &sdp->sd_ail1_list;
  	struct gfs2_trans *tr;
  	struct blk_plug plug;
++<<<<<<< HEAD
 +	bool withdraw = false;
++=======
+ 	int ret;
+ 	unsigned long flush_start = jiffies;
++>>>>>>> 75b46c437f6b (gfs2: Fix oversight in gfs2_ail1_flush)
  
  	trace_gfs2_ail_flush(sdp, wbc, 1);
  	blk_start_plug(&plug);
  	spin_lock(&sdp->sd_ail_lock);
  restart:
++<<<<<<< HEAD
++=======
+ 	ret = 0;
+ 	if (time_after(jiffies, flush_start + (HZ * 600))) {
+ 		dump_ail_list(sdp);
+ 		goto out;
+ 	}
++>>>>>>> 75b46c437f6b (gfs2: Fix oversight in gfs2_ail1_flush)
  	list_for_each_entry_reverse(tr, head, tr_list) {
  		if (wbc->nr_to_write <= 0)
  			break;
* Unmerged path fs/gfs2/log.c
