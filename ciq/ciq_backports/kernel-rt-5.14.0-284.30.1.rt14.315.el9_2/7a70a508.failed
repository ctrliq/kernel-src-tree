iomap: Add __iomap_put_folio helper

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-5.14.0-284.30.1.rt14.315.el9_2
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 7a70a5085ed028b4fd132447cbaea9b73113bca9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-5.14.0-284.30.1.rt14.315.el9_2/7a70a508.failed

Add an __iomap_put_folio() helper to encapsulate unlocking the folio,
calling ->page_done(), and putting the folio.  Use the new helper in
iomap_write_begin() and iomap_write_end().

This effectively doesn't change the way the code works, but prepares for
successive improvements.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 7a70a5085ed028b4fd132447cbaea9b73113bca9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/buffered-io.c
diff --cc fs/iomap/buffered-io.c
index 03a8dcf6cf9d,c045689b6af8..000000000000
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@@ -581,8 -575,21 +581,21 @@@ static int __iomap_write_begin(const st
  	return 0;
  }
  
+ static void __iomap_put_folio(struct iomap_iter *iter, loff_t pos, size_t ret,
+ 		struct folio *folio)
+ {
+ 	const struct iomap_page_ops *page_ops = iter->iomap.page_ops;
+ 
+ 	if (folio)
+ 		folio_unlock(folio);
+ 	if (page_ops && page_ops->page_done)
+ 		page_ops->page_done(iter->inode, pos, ret, &folio->page);
+ 	if (folio)
+ 		folio_put(folio);
+ }
+ 
  static int iomap_write_begin_inline(const struct iomap_iter *iter,
 -		struct folio *folio)
 +		struct page *page)
  {
  	/* needs more work for the tailpacking case; disable for now */
  	if (WARN_ON_ONCE(iomap_iter_srcmap(iter)->offset != 0))
@@@ -611,11 -625,12 +624,20 @@@ static int iomap_write_begin(struct iom
  			return status;
  	}
  
++<<<<<<< HEAD
 +	page = grab_cache_page_write_begin(iter->inode->i_mapping,
 +				pos >> PAGE_SHIFT, AOP_FLAG_NOFS);
 +	if (!page) {
 +		status = -ENOMEM;
 +		goto out_no_page;
++=======
+ 	folio = __filemap_get_folio(iter->inode->i_mapping, pos >> PAGE_SHIFT,
+ 			fgp, mapping_gfp_mask(iter->inode->i_mapping));
+ 	if (!folio) {
+ 		status = (iter->flags & IOMAP_NOWAIT) ? -EAGAIN : -ENOMEM;
+ 		__iomap_put_folio(iter, pos, 0, NULL);
+ 		return status;
++>>>>>>> 7a70a5085ed0 (iomap: Add __iomap_put_folio helper)
  	}
  
  	/*
@@@ -652,13 -670,9 +674,14 @@@
  	return 0;
  
  out_unlock:
++<<<<<<< HEAD
 +	unlock_page(page);
 +	put_page(page);
++=======
+ 	__iomap_put_folio(iter, pos, 0, folio);
++>>>>>>> 7a70a5085ed0 (iomap: Add __iomap_put_folio helper)
  	iomap_write_failed(iter->inode, pos, len);
  
- out_no_page:
- 	if (page_ops && page_ops->page_done)
- 		page_ops->page_done(iter->inode, pos, 0, NULL);
  	return status;
  }
  
@@@ -705,9 -720,8 +728,8 @@@ static size_t iomap_write_end_inline(co
  
  /* Returns the number of bytes copied.  May be 0.  Cannot be an errno. */
  static size_t iomap_write_end(struct iomap_iter *iter, loff_t pos, size_t len,
 -		size_t copied, struct folio *folio)
 +		size_t copied, struct page *page)
  {
- 	const struct iomap_page_ops *page_ops = iter->iomap.page_ops;
  	const struct iomap *srcmap = iomap_iter_srcmap(iter);
  	loff_t old_size = iter->inode->i_size;
  	size_t ret;
@@@ -730,14 -744,10 +752,21 @@@
  		i_size_write(iter->inode, pos + ret);
  		iter->iomap.flags |= IOMAP_F_SIZE_CHANGED;
  	}
++<<<<<<< HEAD
 +	unlock_page(page);
 +
 +	if (old_size < pos)
 +		pagecache_isize_extended(iter->inode, old_size, pos);
 +	if (page_ops && page_ops->page_done)
 +		page_ops->page_done(iter->inode, pos, ret, page);
 +	put_page(page);
 +
++=======
+ 	__iomap_put_folio(iter, pos, ret, folio);
+ 
+ 	if (old_size < pos)
+ 		pagecache_isize_extended(iter->inode, old_size, pos);
++>>>>>>> 7a70a5085ed0 (iomap: Add __iomap_put_folio helper)
  	if (ret < len)
  		iomap_write_failed(iter->inode, pos + ret, len - ret);
  	return ret;
* Unmerged path fs/iomap/buffered-io.c
