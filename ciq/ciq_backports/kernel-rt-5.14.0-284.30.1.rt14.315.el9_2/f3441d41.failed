rxrpc: Copy client call parameters into rxrpc_call earlier

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-5.14.0-284.30.1.rt14.315.el9_2
commit-author David Howells <dhowells@redhat.com>
commit f3441d4125fc98995858550a5521b8d7daf0504a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-5.14.0-284.30.1.rt14.315.el9_2/f3441d41.failed

Copy client call parameters into rxrpc_call earlier so that that can be
used to convey them to the connection code - which can then be offloaded to
the I/O thread.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit f3441d4125fc98995858550a5521b8d7daf0504a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/rxrpc.h
#	net/rxrpc/call_accept.c
#	net/rxrpc/call_object.c
#	net/rxrpc/io_thread.c
diff --cc include/trace/events/rxrpc.h
index 2a52121d73a0,8bd48358f757..000000000000
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@@ -16,44 -16,129 +16,78 @@@
  /*
   * Declare tracing information enums and their string mappings for display.
   */
 -#define rxrpc_call_poke_traces \
 -	EM(rxrpc_call_poke_error,		"Error")	\
 -	EM(rxrpc_call_poke_idle,		"Idle")		\
 -	EM(rxrpc_call_poke_start,		"Start")	\
 -	EM(rxrpc_call_poke_timer,		"Timer")	\
 -	E_(rxrpc_call_poke_timer_now,		"Timer-now")
 -
  #define rxrpc_skb_traces \
 -	EM(rxrpc_skb_eaten_by_unshare,		"ETN unshare  ") \
 -	EM(rxrpc_skb_eaten_by_unshare_nomem,	"ETN unshar-nm") \
 -	EM(rxrpc_skb_get_ack,			"GET ack      ") \
 -	EM(rxrpc_skb_get_conn_work,		"GET conn-work") \
 -	EM(rxrpc_skb_get_to_recvmsg,		"GET to-recv  ") \
 -	EM(rxrpc_skb_get_to_recvmsg_oos,	"GET to-recv-o") \
 -	EM(rxrpc_skb_new_encap_rcv,		"NEW encap-rcv") \
 -	EM(rxrpc_skb_new_error_report,		"NEW error-rpt") \
 -	EM(rxrpc_skb_new_jumbo_subpacket,	"NEW jumbo-sub") \
 -	EM(rxrpc_skb_new_unshared,		"NEW unshared ") \
 -	EM(rxrpc_skb_put_ack,			"PUT ack      ") \
 -	EM(rxrpc_skb_put_conn_work,		"PUT conn-work") \
 -	EM(rxrpc_skb_put_error_report,		"PUT error-rep") \
 -	EM(rxrpc_skb_put_input,			"PUT input    ") \
 -	EM(rxrpc_skb_put_jumbo_subpacket,	"PUT jumbo-sub") \
 -	EM(rxrpc_skb_put_lose,			"PUT lose     ") \
 -	EM(rxrpc_skb_put_purge,			"PUT purge    ") \
 -	EM(rxrpc_skb_put_rotate,		"PUT rotate   ") \
 -	EM(rxrpc_skb_put_unknown,		"PUT unknown  ") \
 -	EM(rxrpc_skb_see_conn_work,		"SEE conn-work") \
 -	EM(rxrpc_skb_see_local_work,		"SEE locl-work") \
 -	EM(rxrpc_skb_see_recvmsg,		"SEE recvmsg  ") \
 -	EM(rxrpc_skb_see_reject,		"SEE reject   ") \
 -	EM(rxrpc_skb_see_rotate,		"SEE rotate   ") \
 -	E_(rxrpc_skb_see_version,		"SEE version  ")
 +	EM(rxrpc_skb_ack,			"ACK") \
 +	EM(rxrpc_skb_cleaned,			"CLN") \
 +	EM(rxrpc_skb_cloned_jumbo,		"CLJ") \
 +	EM(rxrpc_skb_freed,			"FRE") \
 +	EM(rxrpc_skb_got,			"GOT") \
 +	EM(rxrpc_skb_lost,			"*L*") \
 +	EM(rxrpc_skb_new,			"NEW") \
 +	EM(rxrpc_skb_purged,			"PUR") \
 +	EM(rxrpc_skb_received,			"RCV") \
 +	EM(rxrpc_skb_rotated,			"ROT") \
 +	EM(rxrpc_skb_seen,			"SEE") \
 +	EM(rxrpc_skb_unshared,			"UNS") \
 +	E_(rxrpc_skb_unshared_nomem,		"US0")
  
  #define rxrpc_local_traces \
++<<<<<<< HEAD
 +	EM(rxrpc_local_got,			"GOT") \
 +	EM(rxrpc_local_new,			"NEW") \
 +	EM(rxrpc_local_processing,		"PRO") \
 +	EM(rxrpc_local_put,			"PUT") \
 +	EM(rxrpc_local_queued,			"QUE") \
 +	E_(rxrpc_local_tx_ack,			"TAK")
++=======
+ 	EM(rxrpc_local_free,			"FREE        ") \
+ 	EM(rxrpc_local_get_call,		"GET call    ") \
+ 	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
+ 	EM(rxrpc_local_get_for_use,		"GET for-use ") \
+ 	EM(rxrpc_local_get_peer,		"GET peer    ") \
+ 	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
+ 	EM(rxrpc_local_get_queue,		"GET queue   ") \
+ 	EM(rxrpc_local_new,			"NEW         ") \
+ 	EM(rxrpc_local_processing,		"PROCESSING  ") \
+ 	EM(rxrpc_local_put_already_queued,	"PUT alreadyq") \
+ 	EM(rxrpc_local_put_bind,		"PUT bind    ") \
+ 	EM(rxrpc_local_put_call,		"PUT call    ") \
+ 	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
+ 	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
+ 	EM(rxrpc_local_put_peer,		"PUT peer    ") \
+ 	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
+ 	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
+ 	EM(rxrpc_local_put_queue,		"PUT queue   ") \
+ 	EM(rxrpc_local_queued,			"QUEUED      ") \
+ 	EM(rxrpc_local_see_tx_ack,		"SEE tx-ack  ") \
+ 	EM(rxrpc_local_stop,			"STOP        ") \
+ 	EM(rxrpc_local_stopped,			"STOPPED     ") \
+ 	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
+ 	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
+ 	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
+ 	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
+ 	EM(rxrpc_local_unuse_work,		"UNU work    ") \
+ 	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
+ 	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
+ 	EM(rxrpc_local_use_peer_keepalive,	"USE peer-kpa") \
+ 	E_(rxrpc_local_use_work,		"USE work    ")
++>>>>>>> f3441d4125fc (rxrpc: Copy client call parameters into rxrpc_call earlier)
  
  #define rxrpc_peer_traces \
 -	EM(rxrpc_peer_free,			"FREE        ") \
 -	EM(rxrpc_peer_get_accept,		"GET accept  ") \
 -	EM(rxrpc_peer_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
 -	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
 -	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
 -	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
 -	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
 -	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
 -	EM(rxrpc_peer_new_client,		"NEW client  ") \
 -	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
 -	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
 -	EM(rxrpc_peer_put_call,			"PUT call    ") \
 -	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
 -	EM(rxrpc_peer_put_discard_tmp,		"PUT disc-tmp") \
 -	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
 -	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
 -
 -#define rxrpc_bundle_traces \
 -	EM(rxrpc_bundle_free,			"FREE        ") \
 -	EM(rxrpc_bundle_get_client_call,	"GET clt-call") \
 -	EM(rxrpc_bundle_get_client_conn,	"GET clt-conn") \
 -	EM(rxrpc_bundle_get_service_conn,	"GET svc-conn") \
 -	EM(rxrpc_bundle_put_conn,		"PUT conn    ") \
 -	EM(rxrpc_bundle_put_discard,		"PUT discard ") \
 -	E_(rxrpc_bundle_new,			"NEW         ")
 +	EM(rxrpc_peer_got,			"GOT") \
 +	EM(rxrpc_peer_new,			"NEW") \
 +	EM(rxrpc_peer_processing,		"PRO") \
 +	E_(rxrpc_peer_put,			"PUT")
  
  #define rxrpc_conn_traces \
 -	EM(rxrpc_conn_free,			"FREE        ") \
 -	EM(rxrpc_conn_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_conn_get_call_input,		"GET inp-call") \
 -	EM(rxrpc_conn_get_conn_input,		"GET inp-conn") \
 -	EM(rxrpc_conn_get_idle,			"GET idle    ") \
 -	EM(rxrpc_conn_get_poke,			"GET poke    ") \
 -	EM(rxrpc_conn_get_service_conn,		"GET svc-conn") \
 -	EM(rxrpc_conn_new_client,		"NEW client  ") \
 -	EM(rxrpc_conn_new_service,		"NEW service ") \
 -	EM(rxrpc_conn_put_call,			"PUT call    ") \
 -	EM(rxrpc_conn_put_call_input,		"PUT inp-call") \
 -	EM(rxrpc_conn_put_conn_input,		"PUT inp-conn") \
 -	EM(rxrpc_conn_put_discard,		"PUT discard ") \
 -	EM(rxrpc_conn_put_discard_idle,		"PUT disc-idl") \
 -	EM(rxrpc_conn_put_local_dead,		"PUT loc-dead") \
 -	EM(rxrpc_conn_put_noreuse,		"PUT noreuse ") \
 -	EM(rxrpc_conn_put_poke,			"PUT poke    ") \
 -	EM(rxrpc_conn_put_service_reaped,	"PUT svc-reap") \
 -	EM(rxrpc_conn_put_unbundle,		"PUT unbundle") \
 -	EM(rxrpc_conn_put_unidle,		"PUT unidle  ") \
 -	EM(rxrpc_conn_queue_challenge,		"QUE chall   ") \
 -	EM(rxrpc_conn_queue_retry_work,		"QUE retry-wk") \
 -	EM(rxrpc_conn_queue_rx_work,		"QUE rx-work ") \
 -	EM(rxrpc_conn_queue_timer,		"QUE timer   ") \
 -	EM(rxrpc_conn_see_new_service_conn,	"SEE new-svc ") \
 -	EM(rxrpc_conn_see_reap_service,		"SEE reap-svc") \
 -	E_(rxrpc_conn_see_work,			"SEE work    ")
 +	EM(rxrpc_conn_got,			"GOT") \
 +	EM(rxrpc_conn_new_client,		"NWc") \
 +	EM(rxrpc_conn_new_service,		"NWs") \
 +	EM(rxrpc_conn_put_client,		"PTc") \
 +	EM(rxrpc_conn_put_service,		"PTs") \
 +	EM(rxrpc_conn_queued,			"QUE") \
 +	EM(rxrpc_conn_reap_service,		"RPs") \
 +	E_(rxrpc_conn_seen,			"SEE")
  
  #define rxrpc_client_traces \
  	EM(rxrpc_client_activate_chans,		"Activa") \
@@@ -82,10 -167,11 +116,11 @@@
  	EM(rxrpc_call_get_userid,		"GET user-id ") \
  	EM(rxrpc_call_new_client,		"NEW client  ") \
  	EM(rxrpc_call_new_prealloc_service,	"NEW prealloc") \
 +	EM(rxrpc_call_put_already_queued,	"PUT alreadyq") \
  	EM(rxrpc_call_put_discard_prealloc,	"PUT disc-pre") \
+ 	EM(rxrpc_call_put_discard_error,	"PUT disc-err") \
  	EM(rxrpc_call_put_input,		"PUT input   ") \
  	EM(rxrpc_call_put_kernel,		"PUT kernel  ") \
 -	EM(rxrpc_call_put_poke,			"PUT poke    ") \
  	EM(rxrpc_call_put_recvmsg,		"PUT recvmsg ") \
  	EM(rxrpc_call_put_release_sock,		"PUT rls-sock") \
  	EM(rxrpc_call_put_release_sock_tba,	"PUT rls-sk-a") \
diff --cc net/rxrpc/call_accept.c
index afe1f587aaf0,8bc327aa2beb..000000000000
--- a/net/rxrpc/call_accept.c
+++ b/net/rxrpc/call_accept.c
@@@ -321,7 -322,8 +322,12 @@@ static struct rxrpc_call *rxrpc_alloc_i
  	call->conn = conn;
  	call->security = conn->security;
  	call->security_ix = conn->security_ix;
++<<<<<<< HEAD
 +	call->peer = rxrpc_get_peer(conn->params.peer);
++=======
+ 	call->peer = rxrpc_get_peer(conn->peer, rxrpc_peer_get_accept);
+ 	call->dest_srx = peer->srx;
++>>>>>>> f3441d4125fc (rxrpc: Copy client call parameters into rxrpc_call earlier)
  	call->cong_ssthresh = call->peer->cong_ssthresh;
  	call->tx_last_sent = ktime_get_real();
  	return call;
diff --cc net/rxrpc/call_object.c
index ad495d0d21a8,2622d06bb0d6..000000000000
--- a/net/rxrpc/call_object.c
+++ b/net/rxrpc/call_object.c
@@@ -45,6 -45,24 +45,27 @@@ static struct semaphore rxrpc_call_limi
  static struct semaphore rxrpc_kernel_call_limiter =
  	__SEMAPHORE_INITIALIZER(rxrpc_kernel_call_limiter, 1000);
  
++<<<<<<< HEAD
++=======
+ void rxrpc_poke_call(struct rxrpc_call *call, enum rxrpc_call_poke_trace what)
+ {
+ 	struct rxrpc_local *local = call->local;
+ 	bool busy;
+ 
+ 	if (call->state < RXRPC_CALL_COMPLETE) {
+ 		spin_lock_bh(&local->lock);
+ 		busy = !list_empty(&call->attend_link);
+ 		trace_rxrpc_poke_call(call, busy, what);
+ 		if (!busy) {
+ 			rxrpc_get_call(call, rxrpc_call_get_poke);
+ 			list_add_tail(&call->attend_link, &local->call_attend_q);
+ 		}
+ 		spin_unlock_bh(&local->lock);
+ 		rxrpc_wake_up_io_thread(local);
+ 	}
+ }
+ 
++>>>>>>> f3441d4125fc (rxrpc: Copy client call parameters into rxrpc_call earlier)
  static void rxrpc_call_timer_expired(struct timer_list *t)
  {
  	struct rxrpc_call *call = from_timer(call, t, timer);
@@@ -669,9 -647,33 +706,18 @@@ void rxrpc_cleanup_call(struct rxrpc_ca
  		rxrpc_put_txbuf(txb, rxrpc_txbuf_put_cleaned);
  	}
  	rxrpc_put_txbuf(call->tx_pending, rxrpc_txbuf_put_cleaned);
++<<<<<<< HEAD
 +	rxrpc_free_skb(call->acks_soft_tbl, rxrpc_skb_cleaned);
++=======
+ 	rxrpc_free_skb(call->acks_soft_tbl, rxrpc_skb_put_ack);
+ 	rxrpc_put_connection(call->conn, rxrpc_conn_put_call);
+ 	rxrpc_put_peer(call->peer, rxrpc_peer_put_call);
+ 	rxrpc_put_local(call->local, rxrpc_local_put_call);
+ 	call_rcu(&call->rcu, rxrpc_rcu_free_call);
+ }
++>>>>>>> f3441d4125fc (rxrpc: Copy client call parameters into rxrpc_call earlier)
  
 -/*
 - * clean up a call
 - */
 -void rxrpc_cleanup_call(struct rxrpc_call *call)
 -{
 -	memset(&call->sock_node, 0xcd, sizeof(call->sock_node));
 -
 -	ASSERTCMP(call->state, ==, RXRPC_CALL_COMPLETE);
 -	ASSERT(test_bit(RXRPC_CALL_RELEASED, &call->flags));
 -
 -	del_timer_sync(&call->timer);
 -	cancel_work(&call->processor);
 -
 -	if (rcu_read_lock_held() || work_busy(&call->processor))
 -		/* Can't use the rxrpc workqueue as we need to cancel/flush
 -		 * something that may be running/waiting there.
 -		 */
 -		schedule_work(&call->destroyer);
 -	else
 -		rxrpc_destroy_call(&call->destroyer);
 +	call_rcu(&call->rcu, rxrpc_rcu_destroy_call);
  }
  
  /*
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path include/trace/events/rxrpc.h
diff --git a/net/rxrpc/ar-internal.h b/net/rxrpc/ar-internal.h
index 46ce41afb431..1e6f71b1818f 100644
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@ -508,6 +508,7 @@ enum rxrpc_call_flag {
 	RXRPC_CALL_UPGRADE,		/* Service upgrade was requested for the call */
 	RXRPC_CALL_DELAY_ACK_PENDING,	/* DELAY ACK generation is pending */
 	RXRPC_CALL_IDLE_ACK_PENDING,	/* IDLE ACK generation is pending */
+	RXRPC_CALL_EXCLUSIVE,		/* The call uses a once-only connection */
 };
 
 /*
@@ -570,10 +571,13 @@ struct rxrpc_call {
 	struct rcu_head		rcu;
 	struct rxrpc_connection	*conn;		/* connection carrying call */
 	struct rxrpc_peer	*peer;		/* Peer record for remote address */
+	struct rxrpc_local	*local;		/* Representation of local endpoint */
 	struct rxrpc_sock __rcu	*socket;	/* socket responsible */
 	struct rxrpc_net	*rxnet;		/* Network namespace to which call belongs */
+	struct key		*key;		/* Security details */
 	const struct rxrpc_security *security;	/* applied security module */
 	struct mutex		user_mutex;	/* User access mutex */
+	struct sockaddr_rxrpc	dest_srx;	/* Destination address */
 	unsigned long		delay_ack_at;	/* When DELAY ACK needs to happen */
 	unsigned long		ack_lost_at;	/* When ACK is figured as lost */
 	unsigned long		resend_at;	/* When next resend needs to happen */
@@ -607,11 +611,11 @@ struct rxrpc_call {
 	enum rxrpc_call_state	state;		/* current state of call */
 	enum rxrpc_call_completion completion;	/* Call completion condition */
 	refcount_t		ref;
-	u16			service_id;	/* service ID */
 	u8			security_ix;	/* Security type */
 	enum rxrpc_interruptibility interruptibility; /* At what point call may be interrupted */
 	u32			call_id;	/* call ID on connection  */
 	u32			cid;		/* connection ID plus channel index */
+	u32			security_level;	/* Security level selected */
 	int			debug_id;	/* debug ID for printks */
 	unsigned short		rx_pkt_offset;	/* Current recvmsg packet offset */
 	unsigned short		rx_pkt_len;	/* Current recvmsg packet len */
@@ -1097,6 +1101,7 @@ extern const struct rxrpc_security rxkad;
 int __init rxrpc_init_security(void);
 const struct rxrpc_security *rxrpc_security_lookup(u8);
 void rxrpc_exit_security(void);
+int rxrpc_init_client_call_security(struct rxrpc_call *);
 int rxrpc_init_client_conn_security(struct rxrpc_connection *);
 const struct rxrpc_security *rxrpc_get_incoming_security(struct rxrpc_sock *,
 							 struct sk_buff *);
* Unmerged path net/rxrpc/call_accept.c
* Unmerged path net/rxrpc/call_object.c
diff --git a/net/rxrpc/conn_client.c b/net/rxrpc/conn_client.c
index 827c1308297c..d866116f0809 100644
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@ -538,7 +538,7 @@ static void rxrpc_activate_one_channel(struct rxrpc_connection *conn,
 	call->call_id	= call_id;
 	call->security	= conn->security;
 	call->security_ix = conn->security_ix;
-	call->service_id = conn->service_id;
+	call->dest_srx.srx_service = conn->service_id;
 
 	trace_rxrpc_connect_call(call);
 	_net("CONNECT call %08x:%08x as call %d on conn %d",
* Unmerged path net/rxrpc/io_thread.c
diff --git a/net/rxrpc/output.c b/net/rxrpc/output.c
index 71b6fea4598b..3d20fc088459 100644
--- a/net/rxrpc/output.c
+++ b/net/rxrpc/output.c
@@ -358,7 +358,7 @@ int rxrpc_send_abort_packet(struct rxrpc_call *call)
 	pkt.whdr.userStatus	= 0;
 	pkt.whdr.securityIndex	= call->security_ix;
 	pkt.whdr._rsvd		= 0;
-	pkt.whdr.serviceId	= htons(call->service_id);
+	pkt.whdr.serviceId	= htons(call->dest_srx.srx_service);
 	pkt.abort_code		= htonl(call->abort_code);
 
 	iov[0].iov_base	= &pkt;
diff --git a/net/rxrpc/proc.c b/net/rxrpc/proc.c
index fae22a8b38d6..bdd82542c5b6 100644
--- a/net/rxrpc/proc.c
+++ b/net/rxrpc/proc.c
@@ -49,8 +49,6 @@ static void rxrpc_call_seq_stop(struct seq_file *seq, void *v)
 static int rxrpc_call_seq_show(struct seq_file *seq, void *v)
 {
 	struct rxrpc_local *local;
-	struct rxrpc_sock *rx;
-	struct rxrpc_peer *peer;
 	struct rxrpc_call *call;
 	struct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));
 	unsigned long timeout = 0;
@@ -69,22 +67,13 @@ static int rxrpc_call_seq_show(struct seq_file *seq, void *v)
 
 	call = list_entry(v, struct rxrpc_call, link);
 
-	rx = rcu_dereference(call->socket);
-	if (rx) {
-		local = READ_ONCE(rx->local);
-		if (local)
-			sprintf(lbuff, "%pISpc", &local->srx.transport);
-		else
-			strcpy(lbuff, "no_local");
-	} else {
-		strcpy(lbuff, "no_socket");
-	}
-
-	peer = call->peer;
-	if (peer)
-		sprintf(rbuff, "%pISpc", &peer->srx.transport);
+	local = call->local;
+	if (local)
+		sprintf(lbuff, "%pISpc", &local->srx.transport);
 	else
-		strcpy(rbuff, "no_connection");
+		strcpy(lbuff, "no_local");
+
+	sprintf(rbuff, "%pISpc", &call->dest_srx.transport);
 
 	if (call->state != RXRPC_CALL_SERVER_PREALLOC) {
 		timeout = READ_ONCE(call->expect_rx_by);
@@ -98,7 +87,7 @@ static int rxrpc_call_seq_show(struct seq_file *seq, void *v)
 		   " %-8.8s %08x %08x %08x %02x %08x %02x %08x %06lx\n",
 		   lbuff,
 		   rbuff,
-		   call->service_id,
+		   call->dest_srx.srx_service,
 		   call->cid,
 		   call->call_id,
 		   rxrpc_is_service_call(call) ? "Svc" : "Clt",
diff --git a/net/rxrpc/recvmsg.c b/net/rxrpc/recvmsg.c
index c84d2b620396..e5d500489794 100644
--- a/net/rxrpc/recvmsg.c
+++ b/net/rxrpc/recvmsg.c
@@ -490,11 +490,9 @@ int rxrpc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
 	}
 
 	if (msg->msg_name && call->peer) {
-		struct sockaddr_rxrpc *srx = msg->msg_name;
-		size_t len = sizeof(call->peer->srx);
+		size_t len = sizeof(call->dest_srx);
 
-		memcpy(msg->msg_name, &call->peer->srx, len);
-		srx->srx_service = call->service_id;
+		memcpy(msg->msg_name, &call->dest_srx, len);
 		msg->msg_namelen = len;
 	}
 
@@ -639,7 +637,7 @@ int rxrpc_kernel_recv_data(struct socket *sock, struct rxrpc_call *call,
 out:
 	rxrpc_transmit_ack_packets(call->peer->local);
 	if (_service)
-		*_service = call->service_id;
+		*_service = call->dest_srx.srx_service;
 	mutex_unlock(&call->user_mutex);
 	_leave(" = %d [%zu,%d]", ret, iov_iter_count(iter), *_abort);
 	return ret;
diff --git a/net/rxrpc/security.c b/net/rxrpc/security.c
index 50cb5f1ee0c0..a6d9f701e961 100644
--- a/net/rxrpc/security.c
+++ b/net/rxrpc/security.c
@@ -62,6 +62,36 @@ const struct rxrpc_security *rxrpc_security_lookup(u8 security_index)
 	return rxrpc_security_types[security_index];
 }
 
+/*
+ * Initialise the security on a client call.
+ */
+int rxrpc_init_client_call_security(struct rxrpc_call *call)
+{
+	const struct rxrpc_security *sec;
+	struct rxrpc_key_token *token;
+	struct key *key = call->key;
+	int ret;
+
+	if (!key)
+		return 0;
+
+	ret = key_validate(key);
+	if (ret < 0)
+		return ret;
+
+	for (token = key->payload.data[0]; token; token = token->next) {
+		sec = rxrpc_security_lookup(token->security_index);
+		if (sec)
+			goto found;
+	}
+	return -EKEYREJECTED;
+
+found:
+	call->security = sec;
+	_leave(" = 0");
+	return 0;
+}
+
 /*
  * initialise the security on a client connection
  */
diff --git a/net/rxrpc/txbuf.c b/net/rxrpc/txbuf.c
index 96bfee89927b..a2261db074e3 100644
--- a/net/rxrpc/txbuf.c
+++ b/net/rxrpc/txbuf.c
@@ -44,7 +44,7 @@ struct rxrpc_txbuf *rxrpc_alloc_txbuf(struct rxrpc_call *call, u8 packet_type,
 		txb->wire.userStatus	= 0;
 		txb->wire.securityIndex	= call->security_ix;
 		txb->wire._rsvd		= 0;
-		txb->wire.serviceId	= htons(call->service_id);
+		txb->wire.serviceId	= htons(call->dest_srx.srx_service);
 
 		trace_rxrpc_txbuf(txb->debug_id,
 				  txb->call_debug_id, txb->seq, 1,
