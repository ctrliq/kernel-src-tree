rxrpc: Move the client conn cache management to the I/O thread

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-5.14.0-284.30.1.rt14.315.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 0d6bf319bc5aba4535bb46e1b607973688a2248a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-5.14.0-284.30.1.rt14.315.el9_2/0d6bf319.failed

Move the management of the client connection cache to the I/O thread rather
than managing it from the namespace as an aggregate across all the local
endpoints within the namespace.

This will allow a load of locking to be got rid of in a future patch as
only the I/O thread will be looking at the this.

The downside is that the total number of cached connections on the system
can get higher because the limit is now per-local rather than per-netns.
We can, however, keep the number of client conns in use across the entire
netfs and use that to reduce the expiration time of idle connection.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 0d6bf319bc5aba4535bb46e1b607973688a2248a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rxrpc/ar-internal.h
#	net/rxrpc/conn_client.c
#	net/rxrpc/io_thread.c
#	net/rxrpc/local_object.c
#	net/rxrpc/net_ns.c
diff --cc net/rxrpc/ar-internal.h
index 46ce41afb431,de84061a5447..000000000000
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@@ -73,13 -76,7 +73,15 @@@ struct rxrpc_net 
  
  	bool			live;
  
- 	bool			kill_all_client_conns;
  	atomic_t		nr_client_conns;
++<<<<<<< HEAD
 +	spinlock_t		client_conn_cache_lock; /* Lock for ->*_client_conns */
 +	spinlock_t		client_conn_discard_lock; /* Prevent multiple discarders */
 +	struct list_head	idle_client_conns;
 +	struct work_struct	client_conn_reaper;
 +	struct timer_list	client_conn_reap_timer;
++=======
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  
  	struct hlist_head	local_endpoints;
  	struct mutex		local_mutex;	/* Lock for ->local_endpoints */
@@@ -276,18 -277,27 +278,32 @@@ struct rxrpc_local 
  	struct rcu_head		rcu;
  	atomic_t		active_users;	/* Number of users of the local endpoint */
  	refcount_t		ref;		/* Number of references to the structure */
 -	struct net		*net;		/* The network namespace */
 -	struct rxrpc_net	*rxnet;		/* Our bits in the network namespace */
 +	struct rxrpc_net	*rxnet;		/* The network ns in which this resides */
  	struct hlist_node	link;
  	struct socket		*socket;	/* my UDP socket */
 -	struct task_struct	*io_thread;
 -	struct completion	io_thread_ready; /* Indication that the I/O thread started */
 +	struct work_struct	processor;
 +	struct list_head	ack_tx_queue;	/* List of ACKs that need sending */
 +	spinlock_t		ack_tx_lock;	/* ACK list lock */
  	struct rxrpc_sock __rcu	*service;	/* Service(s) listening on this endpoint */
  	struct rw_semaphore	defrag_sem;	/* control re-enablement of IP DF bit */
++<<<<<<< HEAD
 +	struct sk_buff_head	reject_queue;	/* packets awaiting rejection */
 +	struct sk_buff_head	event_queue;	/* endpoint event packets awaiting processing */
++=======
+ 	struct sk_buff_head	rx_queue;	/* Received packets */
+ 	struct list_head	conn_attend_q;	/* Conns requiring immediate attention */
+ 	struct list_head	call_attend_q;	/* Calls requiring immediate attention */
+ 
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	struct rb_root		client_bundles;	/* Client connection bundles by socket params */
  	spinlock_t		client_bundles_lock; /* Lock for client_bundles */
+ 	bool			kill_all_client_conns;
+ 	spinlock_t		client_conn_cache_lock; /* Lock for ->*_client_conns */
+ 	struct list_head	idle_client_conns;
+ 	struct timer_list	client_conn_reap_timer;
+ 	unsigned long		client_conn_flags;
+ #define RXRPC_CLIENT_CONN_REAP_TIMER	0	/* The client conn reap timer expired */
+ 
  	spinlock_t		lock;		/* access lock */
  	rwlock_t		services_lock;	/* lock for services list */
  	int			debug_id;	/* debug ID for printks */
@@@ -860,19 -939,16 +876,25 @@@ static inline bool rxrpc_is_client_call
  extern unsigned int rxrpc_reap_client_connections;
  extern unsigned long rxrpc_conn_idle_client_expiry;
  extern unsigned long rxrpc_conn_idle_client_fast_expiry;
 -
 -void rxrpc_destroy_client_conn_ids(struct rxrpc_local *local);
 -struct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *, enum rxrpc_bundle_trace);
 -void rxrpc_put_bundle(struct rxrpc_bundle *, enum rxrpc_bundle_trace);
 -int rxrpc_connect_call(struct rxrpc_call *call, gfp_t gfp);
 +extern struct idr rxrpc_client_conn_ids;
 +
 +void rxrpc_destroy_client_conn_ids(void);
 +struct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *);
 +void rxrpc_put_bundle(struct rxrpc_bundle *);
 +int rxrpc_connect_call(struct rxrpc_sock *, struct rxrpc_call *,
 +		       struct rxrpc_conn_parameters *, struct sockaddr_rxrpc *,
 +		       gfp_t);
  void rxrpc_expose_client_call(struct rxrpc_call *);
  void rxrpc_disconnect_client_call(struct rxrpc_bundle *, struct rxrpc_call *);
++<<<<<<< HEAD
 +void rxrpc_put_client_conn(struct rxrpc_connection *);
 +void rxrpc_discard_expired_client_conns(struct work_struct *);
 +void rxrpc_destroy_all_client_connections(struct rxrpc_net *);
++=======
+ void rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle);
+ void rxrpc_put_client_conn(struct rxrpc_connection *, enum rxrpc_conn_trace);
+ void rxrpc_discard_expired_client_conns(struct rxrpc_local *local);
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  void rxrpc_clean_up_local_conns(struct rxrpc_local *);
  
  /*
diff --cc net/rxrpc/conn_client.c
index 827c1308297c,ebb43f65ebc5..000000000000
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@@ -571,7 -578,7 +571,11 @@@ static void rxrpc_activate_one_channel(
   */
  static void rxrpc_unidle_conn(struct rxrpc_bundle *bundle, struct rxrpc_connection *conn)
  {
++<<<<<<< HEAD
 +	struct rxrpc_net *rxnet = bundle->params.local->rxnet;
++=======
+ 	struct rxrpc_local *local = bundle->local;
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	bool drop_ref;
  
  	if (!list_empty(&conn->cache_link)) {
@@@ -581,9 -588,9 +585,9 @@@
  			list_del_init(&conn->cache_link);
  			drop_ref = true;
  		}
- 		spin_unlock(&rxnet->client_conn_cache_lock);
+ 		spin_unlock(&local->client_conn_cache_lock);
  		if (drop_ref)
 -			rxrpc_put_connection(conn, rxrpc_conn_put_unidle);
 +			rxrpc_put_connection(conn);
  	}
  }
  
@@@ -700,22 -707,18 +704,31 @@@ out
   * find a connection for a call
   * - called in process context with IRQs enabled
   */
 -int rxrpc_connect_call(struct rxrpc_call *call, gfp_t gfp)
 +int rxrpc_connect_call(struct rxrpc_sock *rx,
 +		       struct rxrpc_call *call,
 +		       struct rxrpc_conn_parameters *cp,
 +		       struct sockaddr_rxrpc *srx,
 +		       gfp_t gfp)
  {
  	struct rxrpc_bundle *bundle;
++<<<<<<< HEAD
 +	struct rxrpc_net *rxnet = cp->local->rxnet;
++=======
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	int ret = 0;
  
  	_enter("{%d,%lx},", call->debug_id, call->user_call_ID);
  
++<<<<<<< HEAD
 +	rxrpc_discard_expired_client_conns(&rxnet->client_conn_reaper);
 +
 +	bundle = rxrpc_prep_call(rx, call, cp, srx, gfp);
++=======
+ 	rxrpc_get_call(call, rxrpc_call_get_io_thread);
+ 
+ 	bundle = rxrpc_prep_call(call, gfp);
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	if (IS_ERR(bundle)) {
 -		rxrpc_put_call(call, rxrpc_call_get_io_thread);
  		ret = PTR_ERR(bundle);
  		goto out;
  	}
@@@ -797,7 -801,7 +810,11 @@@ void rxrpc_disconnect_client_call(struc
  {
  	struct rxrpc_connection *conn;
  	struct rxrpc_channel *chan = NULL;
++<<<<<<< HEAD
 +	struct rxrpc_net *rxnet = bundle->params.local->rxnet;
++=======
+ 	struct rxrpc_local *local = bundle->local;
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	unsigned int channel;
  	bool may_reuse;
  	u32 cid;
@@@ -887,12 -890,12 +904,19 @@@
  		trace_rxrpc_client(conn, channel, rxrpc_client_to_idle);
  		conn->idle_timestamp = jiffies;
  
++<<<<<<< HEAD
 +		rxrpc_get_connection(conn);
 +		spin_lock(&rxnet->client_conn_cache_lock);
 +		list_move_tail(&conn->cache_link, &rxnet->idle_client_conns);
 +		spin_unlock(&rxnet->client_conn_cache_lock);
- 
- 		rxrpc_set_client_reap_timer(rxnet);
++=======
+ 		rxrpc_get_connection(conn, rxrpc_conn_get_idle);
+ 		spin_lock(&local->client_conn_cache_lock);
+ 		list_move_tail(&conn->cache_link, &local->idle_client_conns);
+ 		spin_unlock(&local->client_conn_cache_lock);
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
+ 
+ 		rxrpc_set_client_reap_timer(local);
  	}
  
  out:
@@@ -1009,12 -995,6 +1031,15 @@@ void rxrpc_discard_expired_client_conns
  		return;
  	}
  
++<<<<<<< HEAD
 +	/* Don't double up on the discarding */
 +	if (!spin_trylock(&rxnet->client_conn_discard_lock)) {
 +		_leave(" [already]");
 +		return;
 +	}
 +
++=======
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	/* We keep an estimate of what the number of conns ought to be after
  	 * we've discarded some so that we don't overdo the discarding.
  	 */
@@@ -1051,10 -1031,12 +1076,10 @@@ next
  	trace_rxrpc_client(conn, -1, rxrpc_client_discard);
  	list_del_init(&conn->cache_link);
  
- 	spin_unlock(&rxnet->client_conn_cache_lock);
+ 	spin_unlock(&local->client_conn_cache_lock);
  
  	rxrpc_unbundle_conn(conn);
 -	/* Drop the ->cache_link ref */
 -	rxrpc_put_connection(conn, rxrpc_conn_put_discard_idle);
 +	rxrpc_put_connection(conn); /* Drop the ->cache_link ref */
  
  	nr_conns--;
  	goto next;
@@@ -1068,32 -1050,11 +1093,36 @@@ not_yet_expired
  	 * then things get messier.
  	 */
  	_debug("not yet");
- 	if (!rxnet->kill_all_client_conns)
- 		timer_reduce(&rxnet->client_conn_reap_timer, conn_expires_at);
+ 	if (!local->kill_all_client_conns)
+ 		timer_reduce(&local->client_conn_reap_timer, conn_expires_at);
  
  out:
++<<<<<<< HEAD
 +	spin_unlock(&rxnet->client_conn_cache_lock);
 +	spin_unlock(&rxnet->client_conn_discard_lock);
 +	_leave("");
 +}
 +
 +/*
 + * Preemptively destroy all the client connection records rather than waiting
 + * for them to time out
 + */
 +void rxrpc_destroy_all_client_connections(struct rxrpc_net *rxnet)
 +{
 +	_enter("");
 +
 +	spin_lock(&rxnet->client_conn_cache_lock);
 +	rxnet->kill_all_client_conns = true;
 +	spin_unlock(&rxnet->client_conn_cache_lock);
 +
 +	del_timer_sync(&rxnet->client_conn_reap_timer);
 +
 +	if (!rxrpc_queue_work(&rxnet->client_conn_reaper))
 +		_debug("destroy: queue failed");
 +
++=======
+ 	spin_unlock(&local->client_conn_cache_lock);
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  	_leave("");
  }
  
@@@ -1108,11 -1068,18 +1136,17 @@@ void rxrpc_clean_up_local_conns(struct 
  
  	_enter("");
  
- 	spin_lock(&rxnet->client_conn_cache_lock);
+ 	spin_lock(&local->client_conn_cache_lock);
+ 	local->kill_all_client_conns = true;
+ 	spin_unlock(&local->client_conn_cache_lock);
+ 
+ 	del_timer_sync(&local->client_conn_reap_timer);
  
- 	list_for_each_entry_safe(conn, tmp, &rxnet->idle_client_conns,
+ 	spin_lock(&local->client_conn_cache_lock);
+ 
+ 	list_for_each_entry_safe(conn, tmp, &local->idle_client_conns,
  				 cache_link) {
 -		if (conn->local == local) {
 -			atomic_dec(&conn->active);
 +		if (conn->params.local == local) {
  			trace_rxrpc_client(conn, -1, rxrpc_client_discard);
  			list_move(&conn->cache_link, &graveyard);
  		}
diff --cc net/rxrpc/local_object.c
index 846558613c7f,9bc8d08ca12c..000000000000
--- a/net/rxrpc/local_object.c
+++ b/net/rxrpc/local_object.c
@@@ -81,16 -105,23 +91,30 @@@ static struct rxrpc_local *rxrpc_alloc_
  	if (local) {
  		refcount_set(&local->ref, 1);
  		atomic_set(&local->active_users, 1);
 -		local->net = net;
 -		local->rxnet = rxrpc_net(net);
 +		local->rxnet = rxnet;
  		INIT_HLIST_NODE(&local->link);
 +		INIT_WORK(&local->processor, rxrpc_local_processor);
 +		INIT_LIST_HEAD(&local->ack_tx_queue);
 +		spin_lock_init(&local->ack_tx_lock);
  		init_rwsem(&local->defrag_sem);
++<<<<<<< HEAD
 +		skb_queue_head_init(&local->reject_queue);
 +		skb_queue_head_init(&local->event_queue);
++=======
+ 		init_completion(&local->io_thread_ready);
+ 		skb_queue_head_init(&local->rx_queue);
+ 		INIT_LIST_HEAD(&local->conn_attend_q);
+ 		INIT_LIST_HEAD(&local->call_attend_q);
+ 
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  		local->client_bundles = RB_ROOT;
  		spin_lock_init(&local->client_bundles_lock);
+ 		local->kill_all_client_conns = false;
+ 		spin_lock_init(&local->client_conn_cache_lock);
+ 		INIT_LIST_HEAD(&local->idle_client_conns);
+ 		timer_setup(&local->client_conn_reap_timer,
+ 			    rxrpc_client_conn_reap_timeout, 0);
+ 
  		spin_lock_init(&local->lock);
  		rwlock_init(&local->services_lock);
  		local->debug_id = atomic_inc_return(&rxrpc_debug_id);
diff --cc net/rxrpc/net_ns.c
index 84242c0e467c,a0319c040c25..000000000000
--- a/net/rxrpc/net_ns.c
+++ b/net/rxrpc/net_ns.c
@@@ -63,14 -54,6 +54,17 @@@ static __net_init int rxrpc_init_net(st
  		    rxrpc_service_conn_reap_timeout, 0);
  
  	atomic_set(&rxnet->nr_client_conns, 0);
++<<<<<<< HEAD
 +	rxnet->kill_all_client_conns = false;
 +	spin_lock_init(&rxnet->client_conn_cache_lock);
 +	spin_lock_init(&rxnet->client_conn_discard_lock);
 +	INIT_LIST_HEAD(&rxnet->idle_client_conns);
 +	INIT_WORK(&rxnet->client_conn_reaper,
 +		  rxrpc_discard_expired_client_conns);
 +	timer_setup(&rxnet->client_conn_reap_timer,
 +		    rxrpc_client_conn_reap_timeout, 0);
++=======
++>>>>>>> 0d6bf319bc5a (rxrpc: Move the client conn cache management to the I/O thread)
  
  	INIT_HLIST_HEAD(&rxnet->local_endpoints);
  	mutex_init(&rxnet->local_mutex);
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path net/rxrpc/ar-internal.h
* Unmerged path net/rxrpc/conn_client.c
diff --git a/net/rxrpc/conn_object.c b/net/rxrpc/conn_object.c
index 156bd26daf74..10f581ced60b 100644
--- a/net/rxrpc/conn_object.c
+++ b/net/rxrpc/conn_object.c
@@ -462,7 +462,6 @@ void rxrpc_destroy_all_connections(struct rxrpc_net *rxnet)
 	_enter("");
 
 	atomic_dec(&rxnet->nr_conns);
-	rxrpc_destroy_all_client_connections(rxnet);
 
 	del_timer_sync(&rxnet->service_conn_reap_timer);
 	rxrpc_queue_work(&rxnet->service_conn_reaper);
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path net/rxrpc/local_object.c
* Unmerged path net/rxrpc/net_ns.c
