rxrpc: Implement a mechanism to send an event notification to a connection

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-5.14.0-284.30.1.rt14.315.el9_2
commit-author David Howells <dhowells@redhat.com>
commit f2cce89a074e6d2991dddc94f6b6ebe1576b8459
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-5.14.0-284.30.1.rt14.315.el9_2/f2cce89a.failed

Provide a means by which an event notification can be sent to a connection
through such that the I/O thread can pick it up and handle it rather than
doing it in a separate workqueue.

This is then used to move the deferred final ACK of a call into the I/O
thread rather than a separate work queue as part of the drive to do all
transmission from the I/O thread.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit f2cce89a074e6d2991dddc94f6b6ebe1576b8459)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/rxrpc.h
#	net/rxrpc/ar-internal.h
#	net/rxrpc/conn_object.c
#	net/rxrpc/io_thread.c
#	net/rxrpc/local_object.c
diff --cc include/trace/events/rxrpc.h
index 2a52121d73a0,b969756f97fc..000000000000
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@@ -16,44 -16,122 +16,73 @@@
  /*
   * Declare tracing information enums and their string mappings for display.
   */
 -#define rxrpc_call_poke_traces \
 -	EM(rxrpc_call_poke_abort,		"Abort")	\
 -	EM(rxrpc_call_poke_complete,		"Compl")	\
 -	EM(rxrpc_call_poke_error,		"Error")	\
 -	EM(rxrpc_call_poke_idle,		"Idle")		\
 -	EM(rxrpc_call_poke_start,		"Start")	\
 -	EM(rxrpc_call_poke_timer,		"Timer")	\
 -	E_(rxrpc_call_poke_timer_now,		"Timer-now")
 -
  #define rxrpc_skb_traces \
 -	EM(rxrpc_skb_eaten_by_unshare,		"ETN unshare  ") \
 -	EM(rxrpc_skb_eaten_by_unshare_nomem,	"ETN unshar-nm") \
 -	EM(rxrpc_skb_get_conn_work,		"GET conn-work") \
 -	EM(rxrpc_skb_get_local_work,		"GET locl-work") \
 -	EM(rxrpc_skb_get_reject_work,		"GET rej-work ") \
 -	EM(rxrpc_skb_get_to_recvmsg,		"GET to-recv  ") \
 -	EM(rxrpc_skb_get_to_recvmsg_oos,	"GET to-recv-o") \
 -	EM(rxrpc_skb_new_encap_rcv,		"NEW encap-rcv") \
 -	EM(rxrpc_skb_new_error_report,		"NEW error-rpt") \
 -	EM(rxrpc_skb_new_jumbo_subpacket,	"NEW jumbo-sub") \
 -	EM(rxrpc_skb_new_unshared,		"NEW unshared ") \
 -	EM(rxrpc_skb_put_conn_work,		"PUT conn-work") \
 -	EM(rxrpc_skb_put_error_report,		"PUT error-rep") \
 -	EM(rxrpc_skb_put_input,			"PUT input    ") \
 -	EM(rxrpc_skb_put_jumbo_subpacket,	"PUT jumbo-sub") \
 -	EM(rxrpc_skb_put_purge,			"PUT purge    ") \
 -	EM(rxrpc_skb_put_rotate,		"PUT rotate   ") \
 -	EM(rxrpc_skb_put_unknown,		"PUT unknown  ") \
 -	EM(rxrpc_skb_see_conn_work,		"SEE conn-work") \
 -	EM(rxrpc_skb_see_recvmsg,		"SEE recvmsg  ") \
 -	EM(rxrpc_skb_see_reject,		"SEE reject   ") \
 -	EM(rxrpc_skb_see_rotate,		"SEE rotate   ") \
 -	E_(rxrpc_skb_see_version,		"SEE version  ")
 +	EM(rxrpc_skb_ack,			"ACK") \
 +	EM(rxrpc_skb_cleaned,			"CLN") \
 +	EM(rxrpc_skb_cloned_jumbo,		"CLJ") \
 +	EM(rxrpc_skb_freed,			"FRE") \
 +	EM(rxrpc_skb_got,			"GOT") \
 +	EM(rxrpc_skb_lost,			"*L*") \
 +	EM(rxrpc_skb_new,			"NEW") \
 +	EM(rxrpc_skb_purged,			"PUR") \
 +	EM(rxrpc_skb_received,			"RCV") \
 +	EM(rxrpc_skb_rotated,			"ROT") \
 +	EM(rxrpc_skb_seen,			"SEE") \
 +	EM(rxrpc_skb_unshared,			"UNS") \
 +	E_(rxrpc_skb_unshared_nomem,		"US0")
  
  #define rxrpc_local_traces \
 -	EM(rxrpc_local_free,			"FREE        ") \
 -	EM(rxrpc_local_get_call,		"GET call    ") \
 -	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
 -	EM(rxrpc_local_get_for_use,		"GET for-use ") \
 -	EM(rxrpc_local_get_peer,		"GET peer    ") \
 -	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
 -	EM(rxrpc_local_new,			"NEW         ") \
 -	EM(rxrpc_local_put_bind,		"PUT bind    ") \
 -	EM(rxrpc_local_put_call,		"PUT call    ") \
 -	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
 -	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
 -	EM(rxrpc_local_put_peer,		"PUT peer    ") \
 -	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
 -	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
 -	EM(rxrpc_local_stop,			"STOP        ") \
 -	EM(rxrpc_local_stopped,			"STOPPED     ") \
 -	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
 -	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
 -	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
 -	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
 -	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
 -	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
 -	E_(rxrpc_local_use_peer_keepalive,	"USE peer-kpa")
 +	EM(rxrpc_local_got,			"GOT") \
 +	EM(rxrpc_local_new,			"NEW") \
 +	EM(rxrpc_local_processing,		"PRO") \
 +	EM(rxrpc_local_put,			"PUT") \
 +	EM(rxrpc_local_queued,			"QUE") \
 +	E_(rxrpc_local_tx_ack,			"TAK")
  
  #define rxrpc_peer_traces \
 -	EM(rxrpc_peer_free,			"FREE        ") \
 -	EM(rxrpc_peer_get_accept,		"GET accept  ") \
 -	EM(rxrpc_peer_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
 -	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
 -	EM(rxrpc_peer_get_input,		"GET input   ") \
 -	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
 -	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
 -	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
 -	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
 -	EM(rxrpc_peer_new_client,		"NEW client  ") \
 -	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
 -	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
 -	EM(rxrpc_peer_put_call,			"PUT call    ") \
 -	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
 -	EM(rxrpc_peer_put_discard_tmp,		"PUT disc-tmp") \
 -	EM(rxrpc_peer_put_input,		"PUT input   ") \
 -	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
 -	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
 -
 -#define rxrpc_bundle_traces \
 -	EM(rxrpc_bundle_free,			"FREE        ") \
 -	EM(rxrpc_bundle_get_client_call,	"GET clt-call") \
 -	EM(rxrpc_bundle_get_client_conn,	"GET clt-conn") \
 -	EM(rxrpc_bundle_get_service_conn,	"GET svc-conn") \
 -	EM(rxrpc_bundle_put_conn,		"PUT conn    ") \
 -	EM(rxrpc_bundle_put_discard,		"PUT discard ") \
 -	E_(rxrpc_bundle_new,			"NEW         ")
 +	EM(rxrpc_peer_got,			"GOT") \
 +	EM(rxrpc_peer_new,			"NEW") \
 +	EM(rxrpc_peer_processing,		"PRO") \
 +	E_(rxrpc_peer_put,			"PUT")
  
  #define rxrpc_conn_traces \
++<<<<<<< HEAD
 +	EM(rxrpc_conn_got,			"GOT") \
 +	EM(rxrpc_conn_new_client,		"NWc") \
 +	EM(rxrpc_conn_new_service,		"NWs") \
 +	EM(rxrpc_conn_put_client,		"PTc") \
 +	EM(rxrpc_conn_put_service,		"PTs") \
 +	EM(rxrpc_conn_queued,			"QUE") \
 +	EM(rxrpc_conn_reap_service,		"RPs") \
 +	E_(rxrpc_conn_seen,			"SEE")
++=======
+ 	EM(rxrpc_conn_free,			"FREE        ") \
+ 	EM(rxrpc_conn_get_activate_call,	"GET act-call") \
+ 	EM(rxrpc_conn_get_call_input,		"GET inp-call") \
+ 	EM(rxrpc_conn_get_conn_input,		"GET inp-conn") \
+ 	EM(rxrpc_conn_get_idle,			"GET idle    ") \
+ 	EM(rxrpc_conn_get_poke_timer,		"GET poke    ") \
+ 	EM(rxrpc_conn_get_service_conn,		"GET svc-conn") \
+ 	EM(rxrpc_conn_new_client,		"NEW client  ") \
+ 	EM(rxrpc_conn_new_service,		"NEW service ") \
+ 	EM(rxrpc_conn_put_call,			"PUT call    ") \
+ 	EM(rxrpc_conn_put_call_input,		"PUT inp-call") \
+ 	EM(rxrpc_conn_put_conn_input,		"PUT inp-conn") \
+ 	EM(rxrpc_conn_put_discard,		"PUT discard ") \
+ 	EM(rxrpc_conn_put_discard_idle,		"PUT disc-idl") \
+ 	EM(rxrpc_conn_put_local_dead,		"PUT loc-dead") \
+ 	EM(rxrpc_conn_put_noreuse,		"PUT noreuse ") \
+ 	EM(rxrpc_conn_put_poke,			"PUT poke    ") \
+ 	EM(rxrpc_conn_put_service_reaped,	"PUT svc-reap") \
+ 	EM(rxrpc_conn_put_unbundle,		"PUT unbundle") \
+ 	EM(rxrpc_conn_put_unidle,		"PUT unidle  ") \
+ 	EM(rxrpc_conn_put_work,			"PUT work    ") \
+ 	EM(rxrpc_conn_queue_challenge,		"QUE chall   ") \
+ 	EM(rxrpc_conn_queue_rx_work,		"QUE rx-work ") \
+ 	EM(rxrpc_conn_see_new_service_conn,	"SEE new-svc ") \
+ 	EM(rxrpc_conn_see_reap_service,		"SEE reap-svc") \
+ 	E_(rxrpc_conn_see_work,			"SEE work    ")
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  
  #define rxrpc_client_traces \
  	EM(rxrpc_client_activate_chans,		"Activa") \
diff --cc net/rxrpc/ar-internal.h
index 46ce41afb431,d82d7f36cdaa..000000000000
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@@ -276,16 -284,17 +277,22 @@@ struct rxrpc_local 
  	struct rcu_head		rcu;
  	atomic_t		active_users;	/* Number of users of the local endpoint */
  	refcount_t		ref;		/* Number of references to the structure */
 -	struct net		*net;		/* The network namespace */
 -	struct rxrpc_net	*rxnet;		/* Our bits in the network namespace */
 +	struct rxrpc_net	*rxnet;		/* The network ns in which this resides */
  	struct hlist_node	link;
  	struct socket		*socket;	/* my UDP socket */
 -	struct task_struct	*io_thread;
 -	struct completion	io_thread_ready; /* Indication that the I/O thread started */
 +	struct work_struct	processor;
 +	struct list_head	ack_tx_queue;	/* List of ACKs that need sending */
 +	spinlock_t		ack_tx_lock;	/* ACK list lock */
  	struct rxrpc_sock __rcu	*service;	/* Service(s) listening on this endpoint */
  	struct rw_semaphore	defrag_sem;	/* control re-enablement of IP DF bit */
++<<<<<<< HEAD
 +	struct sk_buff_head	reject_queue;	/* packets awaiting rejection */
 +	struct sk_buff_head	event_queue;	/* endpoint event packets awaiting processing */
++=======
+ 	struct sk_buff_head	rx_queue;	/* Received packets */
+ 	struct list_head	conn_attend_q;	/* Conns requiring immediate attention */
+ 	struct list_head	call_attend_q;	/* Calls requiring immediate attention */
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  	struct rb_root		client_bundles;	/* Client connection bundles by socket params */
  	spinlock_t		client_bundles_lock; /* Lock for client_bundles */
  	spinlock_t		lock;		/* access lock */
@@@ -424,9 -439,14 +431,17 @@@ struct rxrpc_bundle 
   */
  struct rxrpc_connection {
  	struct rxrpc_conn_proto	proto;
++<<<<<<< HEAD
 +	struct rxrpc_conn_parameters params;
++=======
+ 	struct rxrpc_local	*local;		/* Representation of local endpoint */
+ 	struct rxrpc_peer	*peer;		/* Remote endpoint */
+ 	struct rxrpc_net	*rxnet;		/* Network namespace to which call belongs */
+ 	struct key		*key;		/* Security details */
+ 	struct list_head	attend_link;	/* Link in local->conn_attend_q */
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  
  	refcount_t		ref;
 -	atomic_t		active;		/* Active count for service conns */
  	struct rcu_head		rcu;
  	struct list_head	cache_link;
  
@@@ -878,8 -903,12 +893,13 @@@ void rxrpc_clean_up_local_conns(struct 
  /*
   * conn_event.c
   */
 -void rxrpc_conn_retransmit_call(struct rxrpc_connection *conn, struct sk_buff *skb,
 -				unsigned int channel);
  void rxrpc_process_connection(struct work_struct *);
  void rxrpc_process_delayed_final_acks(struct rxrpc_connection *, bool);
++<<<<<<< HEAD
++=======
+ int rxrpc_input_conn_packet(struct rxrpc_connection *conn, struct sk_buff *skb);
+ void rxrpc_input_conn_event(struct rxrpc_connection *conn, struct sk_buff *skb);
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  
  /*
   * conn_object.c
@@@ -887,18 -916,21 +907,26 @@@
  extern unsigned int rxrpc_connection_expiry;
  extern unsigned int rxrpc_closed_conn_expiry;
  
++<<<<<<< HEAD
 +struct rxrpc_connection *rxrpc_alloc_connection(gfp_t);
 +struct rxrpc_connection *rxrpc_find_connection_rcu(struct rxrpc_local *,
 +						   struct sk_buff *,
 +						   struct rxrpc_peer **);
++=======
+ void rxrpc_poke_conn(struct rxrpc_connection *conn, enum rxrpc_conn_trace why);
+ struct rxrpc_connection *rxrpc_alloc_connection(struct rxrpc_net *, gfp_t);
+ struct rxrpc_connection *rxrpc_find_client_connection_rcu(struct rxrpc_local *,
+ 							  struct sockaddr_rxrpc *,
+ 							  struct sk_buff *);
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  void __rxrpc_disconnect_call(struct rxrpc_connection *, struct rxrpc_call *);
  void rxrpc_disconnect_call(struct rxrpc_call *);
 -void rxrpc_kill_client_conn(struct rxrpc_connection *);
 -void rxrpc_queue_conn(struct rxrpc_connection *, enum rxrpc_conn_trace);
 -void rxrpc_see_connection(struct rxrpc_connection *, enum rxrpc_conn_trace);
 -struct rxrpc_connection *rxrpc_get_connection(struct rxrpc_connection *,
 -					      enum rxrpc_conn_trace);
 -struct rxrpc_connection *rxrpc_get_connection_maybe(struct rxrpc_connection *,
 -						    enum rxrpc_conn_trace);
 -void rxrpc_put_connection(struct rxrpc_connection *, enum rxrpc_conn_trace);
 +void rxrpc_kill_connection(struct rxrpc_connection *);
 +bool rxrpc_queue_conn(struct rxrpc_connection *);
 +void rxrpc_see_connection(struct rxrpc_connection *);
 +struct rxrpc_connection *rxrpc_get_connection(struct rxrpc_connection *);
 +struct rxrpc_connection *rxrpc_get_connection_maybe(struct rxrpc_connection *);
 +void rxrpc_put_service_conn(struct rxrpc_connection *);
  void rxrpc_service_connection_reaper(struct work_struct *);
  void rxrpc_destroy_all_connections(struct rxrpc_net *);
  
diff --cc net/rxrpc/conn_object.c
index 156bd26daf74,281f59e356f5..000000000000
--- a/net/rxrpc/conn_object.c
+++ b/net/rxrpc/conn_object.c
@@@ -19,14 -19,34 +19,36 @@@
  unsigned int __read_mostly rxrpc_connection_expiry = 10 * 60;
  unsigned int __read_mostly rxrpc_closed_conn_expiry = 10;
  
 -static void rxrpc_clean_up_connection(struct work_struct *work);
 -static void rxrpc_set_service_reap_timer(struct rxrpc_net *rxnet,
 -					 unsigned long reap_at);
 +static void rxrpc_destroy_connection(struct rcu_head *);
  
+ void rxrpc_poke_conn(struct rxrpc_connection *conn, enum rxrpc_conn_trace why)
+ {
+ 	struct rxrpc_local *local = conn->local;
+ 	bool busy;
+ 
+ 	if (WARN_ON_ONCE(!local))
+ 		return;
+ 
+ 	spin_lock_bh(&local->lock);
+ 	busy = !list_empty(&conn->attend_link);
+ 	if (!busy) {
+ 		rxrpc_get_connection(conn, why);
+ 		list_add_tail(&conn->attend_link, &local->conn_attend_q);
+ 	}
+ 	spin_unlock_bh(&local->lock);
+ 	rxrpc_wake_up_io_thread(local);
+ }
+ 
  static void rxrpc_connection_timer(struct timer_list *timer)
  {
  	struct rxrpc_connection *conn =
  		container_of(timer, struct rxrpc_connection, timer);
  
++<<<<<<< HEAD
 +	rxrpc_queue_conn(conn);
++=======
+ 	rxrpc_poke_conn(conn, rxrpc_conn_get_poke_timer);
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  }
  
  /*
diff --cc net/rxrpc/local_object.c
index 846558613c7f,8ef6cd8defa4..000000000000
--- a/net/rxrpc/local_object.c
+++ b/net/rxrpc/local_object.c
@@@ -81,14 -94,14 +81,21 @@@ static struct rxrpc_local *rxrpc_alloc_
  	if (local) {
  		refcount_set(&local->ref, 1);
  		atomic_set(&local->active_users, 1);
 -		local->net = net;
 -		local->rxnet = rxrpc_net(net);
 +		local->rxnet = rxnet;
  		INIT_HLIST_NODE(&local->link);
 +		INIT_WORK(&local->processor, rxrpc_local_processor);
 +		INIT_LIST_HEAD(&local->ack_tx_queue);
 +		spin_lock_init(&local->ack_tx_lock);
  		init_rwsem(&local->defrag_sem);
++<<<<<<< HEAD
 +		skb_queue_head_init(&local->reject_queue);
 +		skb_queue_head_init(&local->event_queue);
++=======
+ 		init_completion(&local->io_thread_ready);
+ 		skb_queue_head_init(&local->rx_queue);
+ 		INIT_LIST_HEAD(&local->conn_attend_q);
+ 		INIT_LIST_HEAD(&local->call_attend_q);
++>>>>>>> f2cce89a074e (rxrpc: Implement a mechanism to send an event notification to a connection)
  		local->client_bundles = RB_ROOT;
  		spin_lock_init(&local->client_bundles_lock);
  		spin_lock_init(&local->lock);
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path include/trace/events/rxrpc.h
* Unmerged path net/rxrpc/ar-internal.h
diff --git a/net/rxrpc/conn_event.c b/net/rxrpc/conn_event.c
index abf03a5b1d31..cd4e27da2c8d 100644
--- a/net/rxrpc/conn_event.c
+++ b/net/rxrpc/conn_event.c
@@ -430,10 +430,6 @@ static void rxrpc_do_process_connection(struct rxrpc_connection *conn)
 	if (test_and_clear_bit(RXRPC_CONN_EV_CHALLENGE, &conn->events))
 		rxrpc_secure_connection(conn);
 
-	/* Process delayed ACKs whose time has come. */
-	if (conn->flags & RXRPC_CONN_FINAL_ACK_MASK)
-		rxrpc_process_delayed_final_acks(conn, false);
-
 	/* go through the conn-level event packets, releasing the ref on this
 	 * connection that each one has when we've finished with it */
 	while ((skb = skb_dequeue(&conn->rx_queue))) {
@@ -483,3 +479,13 @@ void rxrpc_process_connection(struct work_struct *work)
 	_leave("");
 	return;
 }
+
+/*
+ * Input a connection event.
+ */
+void rxrpc_input_conn_event(struct rxrpc_connection *conn, struct sk_buff *skb)
+{
+	/* Process delayed ACKs whose time has come. */
+	if (conn->flags & RXRPC_CONN_FINAL_ACK_MASK)
+		rxrpc_process_delayed_final_acks(conn, false);
+}
* Unmerged path net/rxrpc/conn_object.c
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path net/rxrpc/local_object.c
