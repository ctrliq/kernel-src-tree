rxrpc: Implement a mechanism to send an event notification to a call

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-5.14.0-284.30.1.rt14.315.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 15f661dc95daec9b38e8e4cc931c95afe0ae0cef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-5.14.0-284.30.1.rt14.315.el9_2/15f661dc.failed

Provide a means by which an event notification can be sent to a call such
that the I/O thread can process it rather than it being done in a separate
workqueue.  This will allow a lot of locking to be removed.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 15f661dc95daec9b38e8e4cc931c95afe0ae0cef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/rxrpc.h
#	net/rxrpc/ar-internal.h
#	net/rxrpc/input.c
#	net/rxrpc/io_thread.c
#	net/rxrpc/local_object.c
diff --cc include/trace/events/rxrpc.h
index 2a52121d73a0,0b12d96c7921..000000000000
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@@ -16,44 -16,127 +16,51 @@@
  /*
   * Declare tracing information enums and their string mappings for display.
   */
+ #define rxrpc_call_poke_traces \
+ 	EM(rxrpc_call_poke_error,		"Error")	\
+ 	EM(rxrpc_call_poke_idle,		"Idle")		\
+ 	EM(rxrpc_call_poke_start,		"Start")	\
+ 	EM(rxrpc_call_poke_timer,		"Timer")	\
+ 	E_(rxrpc_call_poke_timer_now,		"Timer-now")
+ 
  #define rxrpc_skb_traces \
 -	EM(rxrpc_skb_eaten_by_unshare,		"ETN unshare  ") \
 -	EM(rxrpc_skb_eaten_by_unshare_nomem,	"ETN unshar-nm") \
 -	EM(rxrpc_skb_get_ack,			"GET ack      ") \
 -	EM(rxrpc_skb_get_conn_work,		"GET conn-work") \
 -	EM(rxrpc_skb_get_to_recvmsg,		"GET to-recv  ") \
 -	EM(rxrpc_skb_get_to_recvmsg_oos,	"GET to-recv-o") \
 -	EM(rxrpc_skb_new_encap_rcv,		"NEW encap-rcv") \
 -	EM(rxrpc_skb_new_error_report,		"NEW error-rpt") \
 -	EM(rxrpc_skb_new_jumbo_subpacket,	"NEW jumbo-sub") \
 -	EM(rxrpc_skb_new_unshared,		"NEW unshared ") \
 -	EM(rxrpc_skb_put_ack,			"PUT ack      ") \
 -	EM(rxrpc_skb_put_conn_work,		"PUT conn-work") \
 -	EM(rxrpc_skb_put_error_report,		"PUT error-rep") \
 -	EM(rxrpc_skb_put_input,			"PUT input    ") \
 -	EM(rxrpc_skb_put_jumbo_subpacket,	"PUT jumbo-sub") \
 -	EM(rxrpc_skb_put_lose,			"PUT lose     ") \
 -	EM(rxrpc_skb_put_purge,			"PUT purge    ") \
 -	EM(rxrpc_skb_put_rotate,		"PUT rotate   ") \
 -	EM(rxrpc_skb_put_unknown,		"PUT unknown  ") \
 -	EM(rxrpc_skb_see_conn_work,		"SEE conn-work") \
 -	EM(rxrpc_skb_see_local_work,		"SEE locl-work") \
 -	EM(rxrpc_skb_see_recvmsg,		"SEE recvmsg  ") \
 -	EM(rxrpc_skb_see_reject,		"SEE reject   ") \
 -	EM(rxrpc_skb_see_rotate,		"SEE rotate   ") \
 -	E_(rxrpc_skb_see_version,		"SEE version  ")
 +	EM(rxrpc_skb_ack,			"ACK") \
 +	EM(rxrpc_skb_cleaned,			"CLN") \
 +	EM(rxrpc_skb_cloned_jumbo,		"CLJ") \
 +	EM(rxrpc_skb_freed,			"FRE") \
 +	EM(rxrpc_skb_got,			"GOT") \
 +	EM(rxrpc_skb_lost,			"*L*") \
 +	EM(rxrpc_skb_new,			"NEW") \
 +	EM(rxrpc_skb_purged,			"PUR") \
 +	EM(rxrpc_skb_received,			"RCV") \
 +	EM(rxrpc_skb_rotated,			"ROT") \
 +	EM(rxrpc_skb_seen,			"SEE") \
 +	EM(rxrpc_skb_unshared,			"UNS") \
 +	E_(rxrpc_skb_unshared_nomem,		"US0")
  
  #define rxrpc_local_traces \
 -	EM(rxrpc_local_free,			"FREE        ") \
 -	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
 -	EM(rxrpc_local_get_for_use,		"GET for-use ") \
 -	EM(rxrpc_local_get_peer,		"GET peer    ") \
 -	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
 -	EM(rxrpc_local_get_queue,		"GET queue   ") \
 -	EM(rxrpc_local_new,			"NEW         ") \
 -	EM(rxrpc_local_processing,		"PROCESSING  ") \
 -	EM(rxrpc_local_put_already_queued,	"PUT alreadyq") \
 -	EM(rxrpc_local_put_bind,		"PUT bind    ") \
 -	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
 -	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
 -	EM(rxrpc_local_put_peer,		"PUT peer    ") \
 -	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
 -	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
 -	EM(rxrpc_local_put_queue,		"PUT queue   ") \
 -	EM(rxrpc_local_queued,			"QUEUED      ") \
 -	EM(rxrpc_local_see_tx_ack,		"SEE tx-ack  ") \
 -	EM(rxrpc_local_stop,			"STOP        ") \
 -	EM(rxrpc_local_stopped,			"STOPPED     ") \
 -	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
 -	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
 -	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
 -	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
 -	EM(rxrpc_local_unuse_work,		"UNU work    ") \
 -	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
 -	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
 -	EM(rxrpc_local_use_peer_keepalive,	"USE peer-kpa") \
 -	E_(rxrpc_local_use_work,		"USE work    ")
 +	EM(rxrpc_local_got,			"GOT") \
 +	EM(rxrpc_local_new,			"NEW") \
 +	EM(rxrpc_local_processing,		"PRO") \
 +	EM(rxrpc_local_put,			"PUT") \
 +	EM(rxrpc_local_queued,			"QUE") \
 +	E_(rxrpc_local_tx_ack,			"TAK")
  
  #define rxrpc_peer_traces \
 -	EM(rxrpc_peer_free,			"FREE        ") \
 -	EM(rxrpc_peer_get_accept,		"GET accept  ") \
 -	EM(rxrpc_peer_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
 -	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
 -	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
 -	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
 -	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
 -	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
 -	EM(rxrpc_peer_new_client,		"NEW client  ") \
 -	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
 -	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
 -	EM(rxrpc_peer_put_call,			"PUT call    ") \
 -	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
 -	EM(rxrpc_peer_put_discard_tmp,		"PUT disc-tmp") \
 -	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
 -	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
 -
 -#define rxrpc_bundle_traces \
 -	EM(rxrpc_bundle_free,			"FREE        ") \
 -	EM(rxrpc_bundle_get_client_call,	"GET clt-call") \
 -	EM(rxrpc_bundle_get_client_conn,	"GET clt-conn") \
 -	EM(rxrpc_bundle_get_service_conn,	"GET svc-conn") \
 -	EM(rxrpc_bundle_put_conn,		"PUT conn    ") \
 -	EM(rxrpc_bundle_put_discard,		"PUT discard ") \
 -	E_(rxrpc_bundle_new,			"NEW         ")
 +	EM(rxrpc_peer_got,			"GOT") \
 +	EM(rxrpc_peer_new,			"NEW") \
 +	EM(rxrpc_peer_processing,		"PRO") \
 +	E_(rxrpc_peer_put,			"PUT")
  
  #define rxrpc_conn_traces \
 -	EM(rxrpc_conn_free,			"FREE        ") \
 -	EM(rxrpc_conn_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_conn_get_call_input,		"GET inp-call") \
 -	EM(rxrpc_conn_get_conn_input,		"GET inp-conn") \
 -	EM(rxrpc_conn_get_idle,			"GET idle    ") \
 -	EM(rxrpc_conn_get_poke,			"GET poke    ") \
 -	EM(rxrpc_conn_get_service_conn,		"GET svc-conn") \
 -	EM(rxrpc_conn_new_client,		"NEW client  ") \
 -	EM(rxrpc_conn_new_service,		"NEW service ") \
 -	EM(rxrpc_conn_put_call,			"PUT call    ") \
 -	EM(rxrpc_conn_put_call_input,		"PUT inp-call") \
 -	EM(rxrpc_conn_put_conn_input,		"PUT inp-conn") \
 -	EM(rxrpc_conn_put_discard,		"PUT discard ") \
 -	EM(rxrpc_conn_put_discard_idle,		"PUT disc-idl") \
 -	EM(rxrpc_conn_put_local_dead,		"PUT loc-dead") \
 -	EM(rxrpc_conn_put_noreuse,		"PUT noreuse ") \
 -	EM(rxrpc_conn_put_poke,			"PUT poke    ") \
 -	EM(rxrpc_conn_put_service_reaped,	"PUT svc-reap") \
 -	EM(rxrpc_conn_put_unbundle,		"PUT unbundle") \
 -	EM(rxrpc_conn_put_unidle,		"PUT unidle  ") \
 -	EM(rxrpc_conn_queue_challenge,		"QUE chall   ") \
 -	EM(rxrpc_conn_queue_retry_work,		"QUE retry-wk") \
 -	EM(rxrpc_conn_queue_rx_work,		"QUE rx-work ") \
 -	EM(rxrpc_conn_queue_timer,		"QUE timer   ") \
 -	EM(rxrpc_conn_see_new_service_conn,	"SEE new-svc ") \
 -	EM(rxrpc_conn_see_reap_service,		"SEE reap-svc") \
 -	E_(rxrpc_conn_see_work,			"SEE work    ")
 +	EM(rxrpc_conn_got,			"GOT") \
 +	EM(rxrpc_conn_new_client,		"NWc") \
 +	EM(rxrpc_conn_new_service,		"NWs") \
 +	EM(rxrpc_conn_put_client,		"PTc") \
 +	EM(rxrpc_conn_put_service,		"PTs") \
 +	EM(rxrpc_conn_queued,			"QUE") \
 +	EM(rxrpc_conn_reap_service,		"RPs") \
 +	E_(rxrpc_conn_seen,			"SEE")
  
  #define rxrpc_client_traces \
  	EM(rxrpc_client_activate_chans,		"Activa") \
@@@ -305,6 -386,8 +314,11 @@@
  #define EM(a, b) a,
  #define E_(a, b) a
  
++<<<<<<< HEAD
++=======
+ enum rxrpc_bundle_trace		{ rxrpc_bundle_traces } __mode(byte);
+ enum rxrpc_call_poke_trace	{ rxrpc_call_poke_traces } __mode(byte);
++>>>>>>> 15f661dc95da (rxrpc: Implement a mechanism to send an event notification to a call)
  enum rxrpc_call_trace		{ rxrpc_call_traces } __mode(byte);
  enum rxrpc_client_trace		{ rxrpc_client_traces } __mode(byte);
  enum rxrpc_congest_change	{ rxrpc_congest_changes } __mode(byte);
@@@ -334,6 -417,8 +348,11 @@@ enum rxrpc_txqueue_trace	{ rxrpc_txqueu
  #define EM(a, b) TRACE_DEFINE_ENUM(a);
  #define E_(a, b) TRACE_DEFINE_ENUM(a);
  
++<<<<<<< HEAD
++=======
+ rxrpc_bundle_traces;
+ rxrpc_call_poke_traces;
++>>>>>>> 15f661dc95da (rxrpc: Implement a mechanism to send an event notification to a call)
  rxrpc_call_traces;
  rxrpc_client_traces;
  rxrpc_congest_changes;
diff --cc net/rxrpc/ar-internal.h
index 46ce41afb431,a80655fa9dfb..000000000000
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@@ -286,6 -291,8 +286,11 @@@ struct rxrpc_local 
  	struct rw_semaphore	defrag_sem;	/* control re-enablement of IP DF bit */
  	struct sk_buff_head	reject_queue;	/* packets awaiting rejection */
  	struct sk_buff_head	event_queue;	/* endpoint event packets awaiting processing */
++<<<<<<< HEAD
++=======
+ 	struct sk_buff_head	rx_queue;	/* Received packets */
+ 	struct list_head	call_attend_q;	/* Calls requiring immediate attention */
++>>>>>>> 15f661dc95da (rxrpc: Implement a mechanism to send an event notification to a call)
  	struct rb_root		client_bundles;	/* Client connection bundles by socket params */
  	spinlock_t		client_bundles_lock; /* Lock for client_bundles */
  	spinlock_t		lock;		/* access lock */
@@@ -942,7 -954,20 +949,24 @@@ void rxrpc_unpublish_service_conn(struc
  /*
   * input.c
   */
++<<<<<<< HEAD
 +int rxrpc_input_packet(struct sock *, struct sk_buff *);
++=======
+ void rxrpc_input_call_event(struct rxrpc_call *, struct sk_buff *);
+ void rxrpc_input_implicit_end_call(struct rxrpc_sock *, struct rxrpc_connection *,
+ 				   struct rxrpc_call *);
+ 
+ /*
+  * io_thread.c
+  */
+ int rxrpc_encap_rcv(struct sock *, struct sk_buff *);
+ void rxrpc_error_report(struct sock *);
+ int rxrpc_io_thread(void *data);
+ static inline void rxrpc_wake_up_io_thread(struct rxrpc_local *local)
+ {
+ 	wake_up_process(local->io_thread);
+ }
++>>>>>>> 15f661dc95da (rxrpc: Implement a mechanism to send an event notification to a call)
  
  /*
   * insecure.c
diff --cc net/rxrpc/input.c
index b5326e160685,036f02371051..000000000000
--- a/net/rxrpc/input.c
+++ b/net/rxrpc/input.c
@@@ -1030,8 -1017,7 +1030,12 @@@ static void rxrpc_input_abort(struct rx
  /*
   * Process an incoming call packet.
   */
++<<<<<<< HEAD
 +static void rxrpc_input_call_packet(struct rxrpc_call *call,
 +				    struct sk_buff *skb)
++=======
+ void rxrpc_input_call_event(struct rxrpc_call *call, struct sk_buff *skb)
++>>>>>>> 15f661dc95da (rxrpc: Implement a mechanism to send an event notification to a call)
  {
  	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
  	unsigned long timo;
diff --cc net/rxrpc/local_object.c
index 846558613c7f,03f491cc23ef..000000000000
--- a/net/rxrpc/local_object.c
+++ b/net/rxrpc/local_object.c
@@@ -89,6 -103,8 +89,11 @@@ static struct rxrpc_local *rxrpc_alloc_
  		init_rwsem(&local->defrag_sem);
  		skb_queue_head_init(&local->reject_queue);
  		skb_queue_head_init(&local->event_queue);
++<<<<<<< HEAD
++=======
+ 		skb_queue_head_init(&local->rx_queue);
+ 		INIT_LIST_HEAD(&local->call_attend_q);
++>>>>>>> 15f661dc95da (rxrpc: Implement a mechanism to send an event notification to a call)
  		local->client_bundles = RB_ROOT;
  		spin_lock_init(&local->client_bundles_lock);
  		spin_lock_init(&local->lock);
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path include/trace/events/rxrpc.h
* Unmerged path net/rxrpc/ar-internal.h
diff --git a/net/rxrpc/call_object.c b/net/rxrpc/call_object.c
index ad495d0d21a8..8ebc61af6932 100644
--- a/net/rxrpc/call_object.c
+++ b/net/rxrpc/call_object.c
@@ -45,6 +45,29 @@ static struct semaphore rxrpc_call_limiter =
 static struct semaphore rxrpc_kernel_call_limiter =
 	__SEMAPHORE_INITIALIZER(rxrpc_kernel_call_limiter, 1000);
 
+void rxrpc_poke_call(struct rxrpc_call *call, enum rxrpc_call_poke_trace what)
+{
+	struct rxrpc_local *local;
+	struct rxrpc_peer *peer = call->peer;
+	bool busy;
+
+	if (WARN_ON_ONCE(!peer))
+		return;
+	local = peer->local;
+
+	if (call->state < RXRPC_CALL_COMPLETE) {
+		spin_lock_bh(&local->lock);
+		busy = !list_empty(&call->attend_link);
+		trace_rxrpc_poke_call(call, busy, what);
+		if (!busy) {
+			rxrpc_get_call(call, rxrpc_call_get_poke);
+			list_add_tail(&call->attend_link, &local->call_attend_q);
+		}
+		spin_unlock_bh(&local->lock);
+		rxrpc_wake_up_io_thread(local);
+	}
+}
+
 static void rxrpc_call_timer_expired(struct timer_list *t)
 {
 	struct rxrpc_call *call = from_timer(call, t, timer);
@@ -145,6 +168,7 @@ struct rxrpc_call *rxrpc_alloc_call(struct rxrpc_sock *rx, gfp_t gfp,
 	INIT_LIST_HEAD(&call->accept_link);
 	INIT_LIST_HEAD(&call->recvmsg_link);
 	INIT_LIST_HEAD(&call->sock_link);
+	INIT_LIST_HEAD(&call->attend_link);
 	INIT_LIST_HEAD(&call->tx_buffer);
 	skb_queue_head_init(&call->recvmsg_queue);
 	skb_queue_head_init(&call->rx_oos_queue);
* Unmerged path net/rxrpc/input.c
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path net/rxrpc/local_object.c
