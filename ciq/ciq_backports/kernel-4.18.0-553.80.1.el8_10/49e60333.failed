blk-mq: Remove the hctx 'run' debugfs attribute

jira LE-4559
Rebuild_History Non-Buildable kernel-4.18.0-553.80.1.el8_10
commit-author Bart Van Assche <bvanassche@acm.org>
commit 49e60333d743ae32db3bdde2f93bc818482dd741
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.80.1.el8_10/49e60333.failed

Nobody uses the debugfs hctx 'run' attribute. Hence remove this
attribute and also the code that updates the corresponding member
variable.

	Suggested-by: Jens Axboe <axboe@kernel.dk>
	Cc: Gabriel Ryan <gabe@cs.columbia.edu>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
Link: https://lore.kernel.org/r/20240117203609.4122520-1-bvanassche@acm.org
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 49e60333d743ae32db3bdde2f93bc818482dd741)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-debugfs.c
#	include/linux/blk-mq.h
diff --cc block/blk-mq-debugfs.c
index 249cccf5675b,94668e72ab09..000000000000
--- a/block/blk-mq-debugfs.c
+++ b/block/blk-mq-debugfs.c
@@@ -540,87 -479,6 +540,90 @@@ out
  	return res;
  }
  
++<<<<<<< HEAD
 +static int hctx_io_poll_show(void *data, struct seq_file *m)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +
 +	seq_printf(m, "considered=%lu\n", hctx->poll_considered);
 +	seq_printf(m, "invoked=%lu\n", hctx->poll_invoked);
 +	seq_printf(m, "success=%lu\n", hctx->poll_success);
 +	return 0;
 +}
 +
 +static ssize_t hctx_io_poll_write(void *data, const char __user *buf,
 +				  size_t count, loff_t *ppos)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +
 +	hctx->poll_considered = hctx->poll_invoked = hctx->poll_success = 0;
 +	return count;
 +}
 +
 +static int hctx_dispatched_show(void *data, struct seq_file *m)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +	int i;
 +
 +	seq_printf(m, "%8u\t%lu\n", 0U, hctx->dispatched[0]);
 +
 +	for (i = 1; i < BLK_MQ_MAX_DISPATCH_ORDER - 1; i++) {
 +		unsigned int d = 1U << (i - 1);
 +
 +		seq_printf(m, "%8u\t%lu\n", d, hctx->dispatched[i]);
 +	}
 +
 +	seq_printf(m, "%8u+\t%lu\n", 1U << (i - 1), hctx->dispatched[i]);
 +	return 0;
 +}
 +
 +static ssize_t hctx_dispatched_write(void *data, const char __user *buf,
 +				     size_t count, loff_t *ppos)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +	int i;
 +
 +	for (i = 0; i < BLK_MQ_MAX_DISPATCH_ORDER; i++)
 +		hctx->dispatched[i] = 0;
 +	return count;
 +}
 +
 +static int hctx_queued_show(void *data, struct seq_file *m)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +
 +	seq_printf(m, "%lu\n", hctx->queued);
 +	return 0;
 +}
 +
 +static ssize_t hctx_queued_write(void *data, const char __user *buf,
 +				 size_t count, loff_t *ppos)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +
 +	hctx->queued = 0;
 +	return count;
 +}
 +
 +static int hctx_run_show(void *data, struct seq_file *m)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +
 +	seq_printf(m, "%lu\n", hctx->run);
 +	return 0;
 +}
 +
 +static ssize_t hctx_run_write(void *data, const char __user *buf, size_t count,
 +			      loff_t *ppos)
 +{
 +	struct blk_mq_hw_ctx *hctx = data;
 +
 +	hctx->run = 0;
 +	return count;
 +}
 +
++=======
++>>>>>>> 49e60333d743 (blk-mq: Remove the hctx 'run' debugfs attribute)
  static int hctx_active_show(void *data, struct seq_file *m)
  {
  	struct blk_mq_hw_ctx *hctx = data;
@@@ -800,10 -607,6 +803,13 @@@ static const struct blk_mq_debugfs_att
  	{"tags_bitmap", 0400, hctx_tags_bitmap_show},
  	{"sched_tags", 0400, hctx_sched_tags_show},
  	{"sched_tags_bitmap", 0400, hctx_sched_tags_bitmap_show},
++<<<<<<< HEAD
 +	{"io_poll", 0600, hctx_io_poll_show, hctx_io_poll_write},
 +	{"dispatched", 0600, hctx_dispatched_show, hctx_dispatched_write},
 +	{"queued", 0600, hctx_queued_show, hctx_queued_write},
 +	{"run", 0600, hctx_run_show, hctx_run_write},
++=======
++>>>>>>> 49e60333d743 (blk-mq: Remove the hctx 'run' debugfs attribute)
  	{"active", 0400, hctx_active_show},
  	{"dispatch_busy", 0400, hctx_dispatch_busy_show},
  	{"type", 0400, hctx_type_show},
diff --cc include/linux/blk-mq.h
index 40aee1dbb6d3,7a8150a5f051..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -15,60 -285,137 +15,64 @@@ struct blk_flush_queue
   */
  struct blk_mq_hw_ctx {
  	struct {
 -		/** @lock: Protects the dispatch list. */
  		spinlock_t		lock;
 -		/**
 -		 * @dispatch: Used for requests that are ready to be
 -		 * dispatched to the hardware but for some reason (e.g. lack of
 -		 * resources) could not be sent to the hardware. As soon as the
 -		 * driver can send new requests, requests at this list will
 -		 * be sent first for a fairer dispatch.
 -		 */
  		struct list_head	dispatch;
 -		 /**
 -		  * @state: BLK_MQ_S_* flags. Defines the state of the hw
 -		  * queue (active, scheduled to restart, stopped).
 -		  */
 -		unsigned long		state;
 +		unsigned long		state;		/* BLK_MQ_S_* flags */
  	} ____cacheline_aligned_in_smp;
  
 -	/**
 -	 * @run_work: Used for scheduling a hardware queue run at a later time.
 -	 */
  	struct delayed_work	run_work;
 -	/** @cpumask: Map of available CPUs where this hctx can run. */
  	cpumask_var_t		cpumask;
 -	/**
 -	 * @next_cpu: Used by blk_mq_hctx_next_cpu() for round-robin CPU
 -	 * selection from @cpumask.
 -	 */
  	int			next_cpu;
 -	/**
 -	 * @next_cpu_batch: Counter of how many works left in the batch before
 -	 * changing to the next CPU.
 -	 */
  	int			next_cpu_batch;
  
 -	/** @flags: BLK_MQ_F_* flags. Defines the behaviour of the queue. */
 -	unsigned long		flags;
 +	unsigned long		flags;		/* BLK_MQ_F_* flags */
  
 -	/**
 -	 * @sched_data: Pointer owned by the IO scheduler attached to a request
 -	 * queue. It's up to the IO scheduler how to use this pointer.
 -	 */
  	void			*sched_data;
 -	/**
 -	 * @queue: Pointer to the request queue that owns this hardware context.
 -	 */
  	struct request_queue	*queue;
 -	/** @fq: Queue of requests that need to perform a flush operation. */
  	struct blk_flush_queue	*fq;
  
 -	/**
 -	 * @driver_data: Pointer to data owned by the block driver that created
 -	 * this hctx
 -	 */
  	void			*driver_data;
  
 -	/**
 -	 * @ctx_map: Bitmap for each software queue. If bit is on, there is a
 -	 * pending request in that software queue.
 -	 */
  	struct sbitmap		ctx_map;
  
 -	/**
 -	 * @dispatch_from: Software queue to be used when no scheduler was
 -	 * selected.
 -	 */
  	struct blk_mq_ctx	*dispatch_from;
 -	/**
 -	 * @dispatch_busy: Number used by blk_mq_update_dispatch_busy() to
 -	 * decide if the hw_queue is busy using Exponential Weighted Moving
 -	 * Average algorithm.
 -	 */
  	unsigned int		dispatch_busy;
  
 -	/** @type: HCTX_TYPE_* flags. Type of hardware queue. */
  	unsigned short		type;
 -	/** @nr_ctx: Number of software queues. */
  	unsigned short		nr_ctx;
 -	/** @ctxs: Array of software queues. */
  	struct blk_mq_ctx	**ctxs;
  
 -	/** @dispatch_wait_lock: Lock for dispatch_wait queue. */
  	spinlock_t		dispatch_wait_lock;
 -	/**
 -	 * @dispatch_wait: Waitqueue to put requests when there is no tag
 -	 * available at the moment, to wait for another try in the future.
 -	 */
  	wait_queue_entry_t	dispatch_wait;
 -
 -	/**
 -	 * @wait_index: Index of next available dispatch_wait queue to insert
 -	 * requests.
 -	 */
  	atomic_t		wait_index;
  
 -	/**
 -	 * @tags: Tags owned by the block driver. A tag at this set is only
 -	 * assigned when a request is dispatched from a hardware queue.
 -	 */
  	struct blk_mq_tags	*tags;
 -	/**
 -	 * @sched_tags: Tags owned by I/O scheduler. If there is an I/O
 -	 * scheduler associated with a request queue, a tag is assigned when
 -	 * that request is allocated. Else, this member is not used.
 -	 */
  	struct blk_mq_tags	*sched_tags;
  
++<<<<<<< HEAD
 +	unsigned long		queued;
 +	unsigned long		run;
 +#define BLK_MQ_MAX_DISPATCH_ORDER	7
 +	unsigned long		dispatched[BLK_MQ_MAX_DISPATCH_ORDER];
 +
++=======
+ 	/** @numa_node: NUMA node the storage adapter has been connected to. */
++>>>>>>> 49e60333d743 (blk-mq: Remove the hctx 'run' debugfs attribute)
  	unsigned int		numa_node;
 -	/** @queue_num: Index of this hardware queue. */
  	unsigned int		queue_num;
  
 -	/**
 -	 * @nr_active: Number of active requests. Only used when a tag set is
 -	 * shared across request queues.
 -	 */
  	atomic_t		nr_active;
 +	RH_KABI_DEPRECATE(unsigned int,	nr_expired)
  
 -	/** @cpuhp_online: List to store request if CPU is going to die */
 -	struct hlist_node	cpuhp_online;
 -	/** @cpuhp_dead: List to store request if some CPU die. */
  	struct hlist_node	cpuhp_dead;
 -	/** @kobj: Kernel object for sysfs. */
  	struct kobject		kobj;
  
 +	unsigned long		poll_considered;
 +	unsigned long		poll_invoked;
 +	unsigned long		poll_success;
 +
  #ifdef CONFIG_BLK_DEBUG_FS
 -	/**
 -	 * @debugfs_dir: debugfs directory for this hardware queue. Named
 -	 * as cpu<cpu_number>.
 -	 */
  	struct dentry		*debugfs_dir;
 -	/** @sched_debugfs_dir:	debugfs directory for the scheduler. */
  	struct dentry		*sched_debugfs_dir;
  #endif
  
* Unmerged path block/blk-mq-debugfs.c
diff --git a/block/blk-mq-sched.c b/block/blk-mq-sched.c
index 8b2bc859cc7f..8cd0e1e12e6e 100644
--- a/block/blk-mq-sched.c
+++ b/block/blk-mq-sched.c
@@ -358,8 +358,6 @@ void blk_mq_sched_dispatch_requests(struct blk_mq_hw_ctx *hctx)
 	if (unlikely(blk_mq_hctx_stopped(hctx) || blk_queue_quiesced(q)))
 		return;
 
-	hctx->run++;
-
 	/*
 	 * A return of -EAGAIN is an indication that hctx->dispatch is not
 	 * empty and we must run again in order to avoid starving flushes.
* Unmerged path include/linux/blk-mq.h
