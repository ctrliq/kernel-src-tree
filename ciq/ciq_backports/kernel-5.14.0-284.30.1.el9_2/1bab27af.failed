rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 1bab27af6b88b5c811f99de4812b5590f20d1cb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/1bab27af.failed

Use the information now stored in struct rxrpc_call to configure the
connection bundle and thence the connection, rather than using the
rxrpc_conn_parameters struct.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 1bab27af6b88b5c811f99de4812b5590f20d1cb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/rxrpc.h
#	net/rxrpc/af_rxrpc.c
#	net/rxrpc/ar-internal.h
#	net/rxrpc/call_object.c
#	net/rxrpc/conn_client.c
#	net/rxrpc/conn_object.c
#	net/rxrpc/sendmsg.c
diff --cc include/trace/events/rxrpc.h
index 2a52121d73a0,e2f6b79d5517..000000000000
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@@ -16,44 -16,223 +16,74 @@@
  /*
   * Declare tracing information enums and their string mappings for display.
   */
 -#define rxrpc_abort_reasons \
 -	/* AFS errors */						\
 -	EM(afs_abort_general_error,		"afs-error")		\
 -	EM(afs_abort_interrupted,		"afs-intr")		\
 -	EM(afs_abort_oom,			"afs-oom")		\
 -	EM(afs_abort_op_not_supported,		"afs-op-notsupp")	\
 -	EM(afs_abort_probeuuid_negative,	"afs-probeuuid-neg")	\
 -	EM(afs_abort_send_data_error,		"afs-send-data")	\
 -	EM(afs_abort_unmarshal_error,		"afs-unmarshal")	\
 -	/* rxperf errors */						\
 -	EM(rxperf_abort_general_error,		"rxperf-error")		\
 -	EM(rxperf_abort_oom,			"rxperf-oom")		\
 -	EM(rxperf_abort_op_not_supported,	"rxperf-op-notsupp")	\
 -	EM(rxperf_abort_unmarshal_error,	"rxperf-unmarshal")	\
 -	/* RxKAD security errors */					\
 -	EM(rxkad_abort_1_short_check,		"rxkad1-short-check")	\
 -	EM(rxkad_abort_1_short_data,		"rxkad1-short-data")	\
 -	EM(rxkad_abort_1_short_encdata,		"rxkad1-short-encdata")	\
 -	EM(rxkad_abort_1_short_header,		"rxkad1-short-hdr")	\
 -	EM(rxkad_abort_2_short_check,		"rxkad2-short-check")	\
 -	EM(rxkad_abort_2_short_data,		"rxkad2-short-data")	\
 -	EM(rxkad_abort_2_short_header,		"rxkad2-short-hdr")	\
 -	EM(rxkad_abort_2_short_len,		"rxkad2-short-len")	\
 -	EM(rxkad_abort_bad_checksum,		"rxkad2-bad-cksum")	\
 -	EM(rxkad_abort_chall_key_expired,	"rxkad-chall-key-exp")	\
 -	EM(rxkad_abort_chall_level,		"rxkad-chall-level")	\
 -	EM(rxkad_abort_chall_no_key,		"rxkad-chall-nokey")	\
 -	EM(rxkad_abort_chall_short,		"rxkad-chall-short")	\
 -	EM(rxkad_abort_chall_version,		"rxkad-chall-version")	\
 -	EM(rxkad_abort_resp_bad_callid,		"rxkad-resp-bad-callid") \
 -	EM(rxkad_abort_resp_bad_checksum,	"rxkad-resp-bad-cksum")	\
 -	EM(rxkad_abort_resp_bad_param,		"rxkad-resp-bad-param")	\
 -	EM(rxkad_abort_resp_call_ctr,		"rxkad-resp-call-ctr") \
 -	EM(rxkad_abort_resp_call_state,		"rxkad-resp-call-state") \
 -	EM(rxkad_abort_resp_key_expired,	"rxkad-resp-key-exp")	\
 -	EM(rxkad_abort_resp_key_rejected,	"rxkad-resp-key-rej")	\
 -	EM(rxkad_abort_resp_level,		"rxkad-resp-level")	\
 -	EM(rxkad_abort_resp_nokey,		"rxkad-resp-nokey")	\
 -	EM(rxkad_abort_resp_ooseq,		"rxkad-resp-ooseq")	\
 -	EM(rxkad_abort_resp_short,		"rxkad-resp-short")	\
 -	EM(rxkad_abort_resp_short_tkt,		"rxkad-resp-short-tkt")	\
 -	EM(rxkad_abort_resp_tkt_aname,		"rxkad-resp-tk-aname")	\
 -	EM(rxkad_abort_resp_tkt_expired,	"rxkad-resp-tk-exp")	\
 -	EM(rxkad_abort_resp_tkt_future,		"rxkad-resp-tk-future")	\
 -	EM(rxkad_abort_resp_tkt_inst,		"rxkad-resp-tk-inst")	\
 -	EM(rxkad_abort_resp_tkt_len,		"rxkad-resp-tk-len")	\
 -	EM(rxkad_abort_resp_tkt_realm,		"rxkad-resp-tk-realm")	\
 -	EM(rxkad_abort_resp_tkt_short,		"rxkad-resp-tk-short")	\
 -	EM(rxkad_abort_resp_tkt_sinst,		"rxkad-resp-tk-sinst")	\
 -	EM(rxkad_abort_resp_tkt_sname,		"rxkad-resp-tk-sname")	\
 -	EM(rxkad_abort_resp_unknown_tkt,	"rxkad-resp-unknown-tkt") \
 -	EM(rxkad_abort_resp_version,		"rxkad-resp-version")	\
 -	/* rxrpc errors */						\
 -	EM(rxrpc_abort_call_improper_term,	"call-improper-term")	\
 -	EM(rxrpc_abort_call_reset,		"call-reset")		\
 -	EM(rxrpc_abort_call_sendmsg,		"call-sendmsg")		\
 -	EM(rxrpc_abort_call_sock_release,	"call-sock-rel")	\
 -	EM(rxrpc_abort_call_sock_release_tba,	"call-sock-rel-tba")	\
 -	EM(rxrpc_abort_call_timeout,		"call-timeout")		\
 -	EM(rxrpc_abort_no_service_key,		"no-serv-key")		\
 -	EM(rxrpc_abort_nomem,			"nomem")		\
 -	EM(rxrpc_abort_service_not_offered,	"serv-not-offered")	\
 -	EM(rxrpc_abort_shut_down,		"shut-down")		\
 -	EM(rxrpc_abort_unsupported_security,	"unsup-sec")		\
 -	EM(rxrpc_badmsg_bad_abort,		"bad-abort")		\
 -	EM(rxrpc_badmsg_bad_jumbo,		"bad-jumbo")		\
 -	EM(rxrpc_badmsg_short_ack,		"short-ack")		\
 -	EM(rxrpc_badmsg_short_ack_info,		"short-ack-info")	\
 -	EM(rxrpc_badmsg_short_hdr,		"short-hdr")		\
 -	EM(rxrpc_badmsg_unsupported_packet,	"unsup-pkt")		\
 -	EM(rxrpc_badmsg_zero_call,		"zero-call")		\
 -	EM(rxrpc_badmsg_zero_seq,		"zero-seq")		\
 -	EM(rxrpc_badmsg_zero_service,		"zero-service")		\
 -	EM(rxrpc_eproto_ackr_outside_window,	"ackr-out-win")		\
 -	EM(rxrpc_eproto_ackr_sack_overflow,	"ackr-sack-over")	\
 -	EM(rxrpc_eproto_ackr_short_sack,	"ackr-short-sack")	\
 -	EM(rxrpc_eproto_ackr_zero,		"ackr-zero")		\
 -	EM(rxrpc_eproto_bad_upgrade,		"bad-upgrade")		\
 -	EM(rxrpc_eproto_data_after_last,	"data-after-last")	\
 -	EM(rxrpc_eproto_different_last,		"diff-last")		\
 -	EM(rxrpc_eproto_early_reply,		"early-reply")		\
 -	EM(rxrpc_eproto_improper_term,		"improper-term")	\
 -	EM(rxrpc_eproto_no_client_call,		"no-cl-call")		\
 -	EM(rxrpc_eproto_no_client_conn,		"no-cl-conn")		\
 -	EM(rxrpc_eproto_no_service_call,	"no-sv-call")		\
 -	EM(rxrpc_eproto_reupgrade,		"re-upgrade")		\
 -	EM(rxrpc_eproto_rxnull_challenge,	"rxnull-chall")		\
 -	EM(rxrpc_eproto_rxnull_response,	"rxnull-resp")		\
 -	EM(rxrpc_eproto_tx_rot_last,		"tx-rot-last")		\
 -	EM(rxrpc_eproto_unexpected_ack,		"unex-ack")		\
 -	EM(rxrpc_eproto_unexpected_ackall,	"unex-ackall")		\
 -	EM(rxrpc_eproto_unexpected_implicit_end, "unex-impl-end")	\
 -	EM(rxrpc_eproto_unexpected_reply,	"unex-reply")		\
 -	EM(rxrpc_eproto_wrong_security,		"wrong-sec")		\
 -	EM(rxrpc_recvmsg_excess_data,		"recvmsg-excess")	\
 -	EM(rxrpc_recvmsg_short_data,		"recvmsg-short")	\
 -	E_(rxrpc_sendmsg_late_send,		"sendmsg-late")
 -
 -#define rxrpc_call_poke_traces \
 -	EM(rxrpc_call_poke_abort,		"Abort")	\
 -	EM(rxrpc_call_poke_complete,		"Compl")	\
 -	EM(rxrpc_call_poke_error,		"Error")	\
 -	EM(rxrpc_call_poke_idle,		"Idle")		\
 -	EM(rxrpc_call_poke_start,		"Start")	\
 -	EM(rxrpc_call_poke_timer,		"Timer")	\
 -	E_(rxrpc_call_poke_timer_now,		"Timer-now")
 -
  #define rxrpc_skb_traces \
 -	EM(rxrpc_skb_eaten_by_unshare,		"ETN unshare  ") \
 -	EM(rxrpc_skb_eaten_by_unshare_nomem,	"ETN unshar-nm") \
 -	EM(rxrpc_skb_get_conn_secured,		"GET conn-secd") \
 -	EM(rxrpc_skb_get_conn_work,		"GET conn-work") \
 -	EM(rxrpc_skb_get_local_work,		"GET locl-work") \
 -	EM(rxrpc_skb_get_reject_work,		"GET rej-work ") \
 -	EM(rxrpc_skb_get_to_recvmsg,		"GET to-recv  ") \
 -	EM(rxrpc_skb_get_to_recvmsg_oos,	"GET to-recv-o") \
 -	EM(rxrpc_skb_new_encap_rcv,		"NEW encap-rcv") \
 -	EM(rxrpc_skb_new_error_report,		"NEW error-rpt") \
 -	EM(rxrpc_skb_new_jumbo_subpacket,	"NEW jumbo-sub") \
 -	EM(rxrpc_skb_new_unshared,		"NEW unshared ") \
 -	EM(rxrpc_skb_put_conn_secured,		"PUT conn-secd") \
 -	EM(rxrpc_skb_put_conn_work,		"PUT conn-work") \
 -	EM(rxrpc_skb_put_error_report,		"PUT error-rep") \
 -	EM(rxrpc_skb_put_input,			"PUT input    ") \
 -	EM(rxrpc_skb_put_jumbo_subpacket,	"PUT jumbo-sub") \
 -	EM(rxrpc_skb_put_purge,			"PUT purge    ") \
 -	EM(rxrpc_skb_put_rotate,		"PUT rotate   ") \
 -	EM(rxrpc_skb_put_unknown,		"PUT unknown  ") \
 -	EM(rxrpc_skb_see_conn_work,		"SEE conn-work") \
 -	EM(rxrpc_skb_see_recvmsg,		"SEE recvmsg  ") \
 -	EM(rxrpc_skb_see_reject,		"SEE reject   ") \
 -	EM(rxrpc_skb_see_rotate,		"SEE rotate   ") \
 -	E_(rxrpc_skb_see_version,		"SEE version  ")
 +	EM(rxrpc_skb_ack,			"ACK") \
 +	EM(rxrpc_skb_cleaned,			"CLN") \
 +	EM(rxrpc_skb_cloned_jumbo,		"CLJ") \
 +	EM(rxrpc_skb_freed,			"FRE") \
 +	EM(rxrpc_skb_got,			"GOT") \
 +	EM(rxrpc_skb_lost,			"*L*") \
 +	EM(rxrpc_skb_new,			"NEW") \
 +	EM(rxrpc_skb_purged,			"PUR") \
 +	EM(rxrpc_skb_received,			"RCV") \
 +	EM(rxrpc_skb_rotated,			"ROT") \
 +	EM(rxrpc_skb_seen,			"SEE") \
 +	EM(rxrpc_skb_unshared,			"UNS") \
 +	E_(rxrpc_skb_unshared_nomem,		"US0")
  
  #define rxrpc_local_traces \
 -	EM(rxrpc_local_free,			"FREE        ") \
 -	EM(rxrpc_local_get_call,		"GET call    ") \
 -	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
 -	EM(rxrpc_local_get_for_use,		"GET for-use ") \
 -	EM(rxrpc_local_get_peer,		"GET peer    ") \
 -	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
 -	EM(rxrpc_local_new,			"NEW         ") \
 -	EM(rxrpc_local_put_bind,		"PUT bind    ") \
 -	EM(rxrpc_local_put_call,		"PUT call    ") \
 -	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
 -	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
 -	EM(rxrpc_local_put_peer,		"PUT peer    ") \
 -	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
 -	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
 -	EM(rxrpc_local_stop,			"STOP        ") \
 -	EM(rxrpc_local_stopped,			"STOPPED     ") \
 -	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
 -	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
 -	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
 -	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
 -	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
 -	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
 -	E_(rxrpc_local_use_peer_keepalive,	"USE peer-kpa")
 +	EM(rxrpc_local_got,			"GOT") \
 +	EM(rxrpc_local_new,			"NEW") \
 +	EM(rxrpc_local_processing,		"PRO") \
 +	EM(rxrpc_local_put,			"PUT") \
 +	EM(rxrpc_local_queued,			"QUE") \
 +	E_(rxrpc_local_tx_ack,			"TAK")
  
  #define rxrpc_peer_traces \
++<<<<<<< HEAD
 +	EM(rxrpc_peer_got,			"GOT") \
 +	EM(rxrpc_peer_new,			"NEW") \
 +	EM(rxrpc_peer_processing,		"PRO") \
 +	E_(rxrpc_peer_put,			"PUT")
++=======
+ 	EM(rxrpc_peer_free,			"FREE        ") \
+ 	EM(rxrpc_peer_get_accept,		"GET accept  ") \
+ 	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
+ 	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
+ 	EM(rxrpc_peer_get_input,		"GET input   ") \
+ 	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
+ 	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
+ 	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
+ 	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
+ 	EM(rxrpc_peer_new_client,		"NEW client  ") \
+ 	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
+ 	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
+ 	EM(rxrpc_peer_put_call,			"PUT call    ") \
+ 	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
+ 	EM(rxrpc_peer_put_input,		"PUT input   ") \
+ 	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
+ 	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
+ 
+ #define rxrpc_bundle_traces \
+ 	EM(rxrpc_bundle_free,			"FREE        ") \
+ 	EM(rxrpc_bundle_get_client_call,	"GET clt-call") \
+ 	EM(rxrpc_bundle_get_client_conn,	"GET clt-conn") \
+ 	EM(rxrpc_bundle_get_service_conn,	"GET svc-conn") \
+ 	EM(rxrpc_bundle_put_call,		"PUT call    ") \
+ 	EM(rxrpc_bundle_put_conn,		"PUT conn    ") \
+ 	EM(rxrpc_bundle_put_discard,		"PUT discard ") \
+ 	E_(rxrpc_bundle_new,			"NEW         ")
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  
  #define rxrpc_conn_traces \
 -	EM(rxrpc_conn_free,			"FREE        ") \
 -	EM(rxrpc_conn_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_conn_get_call_input,		"GET inp-call") \
 -	EM(rxrpc_conn_get_conn_input,		"GET inp-conn") \
 -	EM(rxrpc_conn_get_idle,			"GET idle    ") \
 -	EM(rxrpc_conn_get_poke_abort,		"GET pk-abort") \
 -	EM(rxrpc_conn_get_poke_timer,		"GET poke    ") \
 -	EM(rxrpc_conn_get_service_conn,		"GET svc-conn") \
 -	EM(rxrpc_conn_new_client,		"NEW client  ") \
 -	EM(rxrpc_conn_new_service,		"NEW service ") \
 -	EM(rxrpc_conn_put_call,			"PUT call    ") \
 -	EM(rxrpc_conn_put_call_input,		"PUT inp-call") \
 -	EM(rxrpc_conn_put_conn_input,		"PUT inp-conn") \
 -	EM(rxrpc_conn_put_discard,		"PUT discard ") \
 -	EM(rxrpc_conn_put_discard_idle,		"PUT disc-idl") \
 -	EM(rxrpc_conn_put_local_dead,		"PUT loc-dead") \
 -	EM(rxrpc_conn_put_noreuse,		"PUT noreuse ") \
 -	EM(rxrpc_conn_put_poke,			"PUT poke    ") \
 -	EM(rxrpc_conn_put_service_reaped,	"PUT svc-reap") \
 -	EM(rxrpc_conn_put_unbundle,		"PUT unbundle") \
 -	EM(rxrpc_conn_put_unidle,		"PUT unidle  ") \
 -	EM(rxrpc_conn_put_work,			"PUT work    ") \
 -	EM(rxrpc_conn_queue_challenge,		"QUE chall   ") \
 -	EM(rxrpc_conn_queue_retry_work,		"QUE retry-wk") \
 -	EM(rxrpc_conn_queue_rx_work,		"QUE rx-work ") \
 -	EM(rxrpc_conn_see_new_service_conn,	"SEE new-svc ") \
 -	EM(rxrpc_conn_see_reap_service,		"SEE reap-svc") \
 -	E_(rxrpc_conn_see_work,			"SEE work    ")
 +	EM(rxrpc_conn_got,			"GOT") \
 +	EM(rxrpc_conn_new_client,		"NWc") \
 +	EM(rxrpc_conn_new_service,		"NWs") \
 +	EM(rxrpc_conn_put_client,		"PTc") \
 +	EM(rxrpc_conn_put_service,		"PTs") \
 +	EM(rxrpc_conn_queued,			"QUE") \
 +	EM(rxrpc_conn_reap_service,		"RPs") \
 +	E_(rxrpc_conn_seen,			"SEE")
  
  #define rxrpc_client_traces \
  	EM(rxrpc_client_activate_chans,		"Activa") \
diff --cc net/rxrpc/af_rxrpc.c
index 0f4d34f420f0,f4e1ffff2ba4..000000000000
--- a/net/rxrpc/af_rxrpc.c
+++ b/net/rxrpc/af_rxrpc.c
@@@ -328,7 -328,6 +328,10 @@@ struct rxrpc_call *rxrpc_kernel_begin_c
  		mutex_unlock(&call->user_mutex);
  	}
  
++<<<<<<< HEAD
 +	rxrpc_put_peer(cp.peer);
++=======
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	_leave(" = %p", call);
  	return call;
  }
diff --cc net/rxrpc/ar-internal.h
index 46ce41afb431,2740c6333114..000000000000
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@@ -403,7 -424,10 +402,14 @@@ enum rxrpc_conn_proto_state 
   * RxRPC client connection bundle.
   */
  struct rxrpc_bundle {
++<<<<<<< HEAD
 +	struct rxrpc_conn_parameters params;
++=======
+ 	struct rxrpc_local	*local;		/* Representation of local endpoint */
+ 	struct rxrpc_peer	*peer;		/* Remote endpoint */
+ 	struct key		*key;		/* Security details */
+ 	const struct rxrpc_security *security;	/* applied security module */
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	refcount_t		ref;
  	atomic_t		active;		/* Number of active users */
  	unsigned int		debug_id;
@@@ -569,11 -593,15 +575,12 @@@ enum rxrpc_congest_mode 
  struct rxrpc_call {
  	struct rcu_head		rcu;
  	struct rxrpc_connection	*conn;		/* connection carrying call */
+ 	struct rxrpc_bundle	*bundle;	/* Connection bundle to use */
  	struct rxrpc_peer	*peer;		/* Peer record for remote address */
 -	struct rxrpc_local	*local;		/* Representation of local endpoint */
  	struct rxrpc_sock __rcu	*socket;	/* socket responsible */
  	struct rxrpc_net	*rxnet;		/* Network namespace to which call belongs */
 -	struct key		*key;		/* Security details */
  	const struct rxrpc_security *security;	/* applied security module */
  	struct mutex		user_mutex;	/* User access mutex */
 -	struct sockaddr_rxrpc	dest_srx;	/* Destination address */
  	unsigned long		delay_ack_at;	/* When DELAY ACK needs to happen */
  	unsigned long		ack_lost_at;	/* When ACK is figured as lost */
  	unsigned long		resend_at;	/* When next resend needs to happen */
@@@ -860,17 -891,15 +867,28 @@@ static inline bool rxrpc_is_client_call
  extern unsigned int rxrpc_reap_client_connections;
  extern unsigned long rxrpc_conn_idle_client_expiry;
  extern unsigned long rxrpc_conn_idle_client_fast_expiry;
 -
 +extern struct idr rxrpc_client_conn_ids;
 +
++<<<<<<< HEAD
 +void rxrpc_destroy_client_conn_ids(void);
 +struct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *);
 +void rxrpc_put_bundle(struct rxrpc_bundle *);
 +int rxrpc_connect_call(struct rxrpc_sock *, struct rxrpc_call *,
 +		       struct rxrpc_conn_parameters *, struct sockaddr_rxrpc *,
 +		       gfp_t);
 +void rxrpc_expose_client_call(struct rxrpc_call *);
 +void rxrpc_disconnect_client_call(struct rxrpc_bundle *, struct rxrpc_call *);
 +void rxrpc_put_client_conn(struct rxrpc_connection *);
++=======
+ void rxrpc_destroy_client_conn_ids(struct rxrpc_local *local);
+ struct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *, enum rxrpc_bundle_trace);
+ void rxrpc_put_bundle(struct rxrpc_bundle *, enum rxrpc_bundle_trace);
+ int rxrpc_connect_call(struct rxrpc_call *call, gfp_t gfp);
+ void rxrpc_expose_client_call(struct rxrpc_call *);
+ void rxrpc_disconnect_client_call(struct rxrpc_bundle *, struct rxrpc_call *);
+ void rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle);
+ void rxrpc_put_client_conn(struct rxrpc_connection *, enum rxrpc_conn_trace);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  void rxrpc_discard_expired_client_conns(struct work_struct *);
  void rxrpc_destroy_all_client_connections(struct rxrpc_net *);
  void rxrpc_clean_up_local_conns(struct rxrpc_local *);
diff --cc net/rxrpc/call_object.c
index ad495d0d21a8,835e9781afc6..000000000000
--- a/net/rxrpc/call_object.c
+++ b/net/rxrpc/call_object.c
@@@ -633,19 -640,34 +633,35 @@@ static void rxrpc_destroy_call(struct w
  }
  
  /*
 - * Final call destruction - but must be done in process context.
 + * Final call destruction under RCU.
   */
 -static void rxrpc_destroy_call(struct work_struct *work)
 +static void rxrpc_rcu_destroy_call(struct rcu_head *rcu)
  {
 -	struct rxrpc_call *call = container_of(work, struct rxrpc_call, destroyer);
 -	struct rxrpc_txbuf *txb;
 -
 -	del_timer_sync(&call->timer);
 +	struct rxrpc_call *call = container_of(rcu, struct rxrpc_call, rcu);
  
 -	rxrpc_cleanup_ring(call);
 -	while ((txb = list_first_entry_or_null(&call->tx_sendmsg,
 -					       struct rxrpc_txbuf, call_link))) {
 -		list_del(&txb->call_link);
 -		rxrpc_put_txbuf(txb, rxrpc_txbuf_put_cleaned);
 +	if (in_softirq()) {
 +		INIT_WORK(&call->processor, rxrpc_destroy_call);
 +		if (!rxrpc_queue_work(&call->processor))
 +			BUG();
 +	} else {
 +		rxrpc_destroy_call(&call->processor);
  	}
++<<<<<<< HEAD
++=======
+ 	while ((txb = list_first_entry_or_null(&call->tx_buffer,
+ 					       struct rxrpc_txbuf, call_link))) {
+ 		list_del(&txb->call_link);
+ 		rxrpc_put_txbuf(txb, rxrpc_txbuf_put_cleaned);
+ 	}
+ 
+ 	rxrpc_put_txbuf(call->tx_pending, rxrpc_txbuf_put_cleaned);
+ 	rxrpc_put_connection(call->conn, rxrpc_conn_put_call);
+ 	rxrpc_deactivate_bundle(call->bundle);
+ 	rxrpc_put_bundle(call->bundle, rxrpc_bundle_put_call);
+ 	rxrpc_put_peer(call->peer, rxrpc_peer_put_call);
+ 	rxrpc_put_local(call->local, rxrpc_local_put_call);
+ 	call_rcu(&call->rcu, rxrpc_rcu_free_call);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  }
  
  /*
diff --cc net/rxrpc/conn_client.c
index 827c1308297c,c0db7722571e..000000000000
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@@ -34,13 -34,10 +34,20 @@@ __read_mostly unsigned int rxrpc_reap_c
  __read_mostly unsigned long rxrpc_conn_idle_client_expiry = 2 * 60 * HZ;
  __read_mostly unsigned long rxrpc_conn_idle_client_fast_expiry = 2 * HZ;
  
++<<<<<<< HEAD
 +/*
 + * We use machine-unique IDs for our client connections.
 + */
 +DEFINE_IDR(rxrpc_client_conn_ids);
 +static DEFINE_SPINLOCK(rxrpc_conn_id_lock);
 +
 +static void rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle);
++=======
+ static void rxrpc_activate_bundle(struct rxrpc_bundle *bundle)
+ {
+ 	atomic_inc(&bundle->active);
+ }
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  
  /*
   * Get a connection ID and epoch for a client connection from the global pool.
@@@ -122,8 -119,14 +129,19 @@@ static struct rxrpc_bundle *rxrpc_alloc
  
  	bundle = kzalloc(sizeof(*bundle), gfp);
  	if (bundle) {
++<<<<<<< HEAD
 +		bundle->params = *cp;
 +		rxrpc_get_peer(bundle->params.peer);
++=======
+ 		bundle->local		= call->local;
+ 		bundle->peer		= rxrpc_get_peer(call->peer, rxrpc_peer_get_bundle);
+ 		bundle->key		= key_get(call->key);
+ 		bundle->security	= call->security;
+ 		bundle->exclusive	= test_bit(RXRPC_CALL_EXCLUSIVE, &call->flags);
+ 		bundle->upgrade		= test_bit(RXRPC_CALL_UPGRADE, &call->flags);
+ 		bundle->service_id	= call->dest_srx.srx_service;
+ 		bundle->security_level	= call->security_level;
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  		refcount_set(&bundle->ref, 1);
  		atomic_set(&bundle->active, 1);
  		spin_lock_init(&bundle->channel_lock);
@@@ -140,21 -148,25 +158,41 @@@ struct rxrpc_bundle *rxrpc_get_bundle(s
  
  static void rxrpc_free_bundle(struct rxrpc_bundle *bundle)
  {
++<<<<<<< HEAD
 +	rxrpc_put_peer(bundle->params.peer);
++=======
+ 	trace_rxrpc_bundle(bundle->debug_id, 1, rxrpc_bundle_free);
+ 	rxrpc_put_peer(bundle->peer, rxrpc_peer_put_bundle);
+ 	key_put(bundle->key);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	kfree(bundle);
  }
  
 -void rxrpc_put_bundle(struct rxrpc_bundle *bundle, enum rxrpc_bundle_trace why)
 +void rxrpc_put_bundle(struct rxrpc_bundle *bundle)
  {
++<<<<<<< HEAD
 +	unsigned int d = bundle->debug_id;
 +	bool dead;
 +	int r;
 +
 +	dead = __refcount_dec_and_test(&bundle->ref, &r);
 +
 +	_debug("PUT B=%x %d", d, r - 1);
 +	if (dead)
 +		rxrpc_free_bundle(bundle);
++=======
+ 	unsigned int id;
+ 	bool dead;
+ 	int r;
+ 
+ 	if (bundle) {
+ 		id = bundle->debug_id;
+ 		dead = __refcount_dec_and_test(&bundle->ref, &r);
+ 		trace_rxrpc_bundle(id, r - 1, why);
+ 		if (dead)
+ 			rxrpc_free_bundle(bundle);
+ 	}
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  }
  
  /*
@@@ -285,11 -305,11 +326,19 @@@ static struct rxrpc_bundle *rxrpc_look_
  	while (p) {
  		bundle = rb_entry(p, struct rxrpc_bundle, local_node);
  
++<<<<<<< HEAD
 +#define cmp(X) ((long)bundle->params.X - (long)cp->X)
 +		diff = (cmp(peer) ?:
 +			cmp(key) ?:
 +			cmp(security_level) ?:
 +			cmp(upgrade));
++=======
+ #define cmp(X, Y) ((long)(X) - (long)(Y))
+ 		diff = (cmp(bundle->peer, call->peer) ?:
+ 			cmp(bundle->key, call->key) ?:
+ 			cmp(bundle->security_level, call->security_level) ?:
+ 			cmp(bundle->upgrade, upgrade));
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  #undef cmp
  		if (diff < 0)
  			p = p->rb_left;
@@@ -314,11 -334,11 +363,19 @@@
  		parent = *pp;
  		bundle = rb_entry(parent, struct rxrpc_bundle, local_node);
  
++<<<<<<< HEAD
 +#define cmp(X) ((long)bundle->params.X - (long)cp->X)
 +		diff = (cmp(peer) ?:
 +			cmp(key) ?:
 +			cmp(security_level) ?:
 +			cmp(upgrade));
++=======
+ #define cmp(X, Y) ((long)(X) - (long)(Y))
+ 		diff = (cmp(bundle->peer, call->peer) ?:
+ 			cmp(bundle->key, call->key) ?:
+ 			cmp(bundle->security_level, call->security_level) ?:
+ 			cmp(bundle->upgrade, upgrade));
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  #undef cmp
  		if (diff < 0)
  			pp = &(*pp)->rb_left;
@@@ -332,19 -352,19 +389,28 @@@
  	candidate->debug_id = atomic_inc_return(&rxrpc_bundle_id);
  	rb_link_node(&candidate->local_node, parent, pp);
  	rb_insert_color(&candidate->local_node, &local->client_bundles);
++<<<<<<< HEAD
 +	rxrpc_get_bundle(candidate);
++=======
+ 	call->bundle = rxrpc_get_bundle(candidate, rxrpc_bundle_get_client_call);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	spin_unlock(&local->client_bundles_lock);
- 	_leave(" = %u [new]", candidate->debug_id);
- 	return candidate;
+ 	_leave(" = B=%u [new]", call->bundle->debug_id);
+ 	return call->bundle;
  
  found_bundle_free:
  	rxrpc_free_bundle(candidate);
  found_bundle:
++<<<<<<< HEAD
 +	rxrpc_get_bundle(bundle);
 +	atomic_inc(&bundle->active);
++=======
+ 	call->bundle = rxrpc_get_bundle(bundle, rxrpc_bundle_get_client_call);
+ 	rxrpc_activate_bundle(bundle);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	spin_unlock(&local->client_bundles_lock);
- 	_leave(" = %u [found]", bundle->debug_id);
- 	return bundle;
+ 	_leave(" = B=%u [found]", call->bundle->debug_id);
+ 	return call->bundle;
  }
  
  /*
@@@ -363,8 -379,8 +425,13 @@@ static struct rxrpc_bundle *rxrpc_prep_
  
  	_enter("{%d,%lx},", call->debug_id, call->user_call_ID);
  
++<<<<<<< HEAD
 +	cp->peer = rxrpc_lookup_peer(rx, cp->local, srx, gfp);
 +	if (!cp->peer)
++=======
+ 	call->peer = rxrpc_lookup_peer(call->local, &call->dest_srx, gfp);
+ 	if (!call->peer)
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  		goto error;
  
  	call->tx_last_sent = ktime_get_real();
@@@ -532,21 -546,16 +597,25 @@@ static void rxrpc_activate_one_channel(
  
  	rxrpc_see_call(call, rxrpc_call_see_activate_client);
  	list_del_init(&call->chan_wait_link);
++<<<<<<< HEAD
 +	call->peer	= rxrpc_get_peer(conn->params.peer);
 +	call->conn	= rxrpc_get_connection(conn);
++=======
+ 	call->conn	= rxrpc_get_connection(conn, rxrpc_conn_get_activate_call);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	call->cid	= conn->proto.cid | channel;
  	call->call_id	= call_id;
 -	call->dest_srx.srx_service = conn->service_id;
 +	call->security	= conn->security;
 +	call->security_ix = conn->security_ix;
 +	call->service_id = conn->service_id;
  
  	trace_rxrpc_connect_call(call);
 +	_net("CONNECT call %08x:%08x as call %d on conn %d",
 +	     call->cid, call->call_id, call->debug_id, conn->debug_id);
  
 -	write_lock(&call->state_lock);
 +	write_lock_bh(&call->state_lock);
  	call->state = RXRPC_CALL_CLIENT_SEND_REQUEST;
 -	write_unlock(&call->state_lock);
 +	write_unlock_bh(&call->state_lock);
  
  	/* Paired with the read barrier in rxrpc_connect_call().  This orders
  	 * cid and epoch in the connection wrt to call_id without the need to
@@@ -714,8 -720,11 +780,14 @@@ int rxrpc_connect_call(struct rxrpc_cal
  
  	rxrpc_discard_expired_client_conns(&rxnet->client_conn_reaper);
  
++<<<<<<< HEAD
 +	bundle = rxrpc_prep_call(rx, call, cp, srx, gfp);
++=======
+ 	rxrpc_get_call(call, rxrpc_call_get_io_thread);
+ 
+ 	bundle = rxrpc_prep_call(call, gfp);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	if (IS_ERR(bundle)) {
 -		rxrpc_put_call(call, rxrpc_call_get_io_thread);
  		ret = PTR_ERR(bundle);
  		goto out;
  	}
@@@ -730,9 -739,6 +802,12 @@@ granted_channel
  	/* Paired with the write barrier in rxrpc_activate_one_channel(). */
  	smp_rmb();
  
++<<<<<<< HEAD
 +out_put_bundle:
 +	rxrpc_deactivate_bundle(bundle);
 +	rxrpc_put_bundle(bundle);
++=======
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  out:
  	_leave(" = %d", ret);
  	return ret;
@@@ -936,13 -943,17 +1011,21 @@@ static void rxrpc_unbundle_conn(struct 
  /*
   * Drop the active count on a bundle.
   */
- static void rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle)
+ void rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle)
  {
++<<<<<<< HEAD
 +	struct rxrpc_local *local = bundle->params.local;
++=======
+ 	struct rxrpc_local *local;
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	bool need_put = false;
  
+ 	if (!bundle)
+ 		return;
+ 
+ 	local = bundle->local;
  	if (atomic_dec_and_lock(&bundle->active, &local->client_bundles_lock)) {
 -		if (!bundle->exclusive) {
 +		if (!bundle->params.exclusive) {
  			_debug("erase bundle");
  			rb_erase(&bundle->local_node, &local->client_bundles);
  			need_put = true;
diff --cc net/rxrpc/conn_object.c
index 156bd26daf74,2a7d5378300c..000000000000
--- a/net/rxrpc/conn_object.c
+++ b/net/rxrpc/conn_object.c
@@@ -210,50 -199,28 +210,59 @@@ void rxrpc_disconnect_call(struct rxrpc
  	call->peer->cong_ssthresh = call->cong_ssthresh;
  
  	if (!hlist_unhashed(&call->error_link)) {
 -		spin_lock(&call->peer->lock);
 -		hlist_del_init(&call->error_link);
 -		spin_unlock(&call->peer->lock);
 +		spin_lock_bh(&call->peer->lock);
 +		hlist_del_rcu(&call->error_link);
 +		spin_unlock_bh(&call->peer->lock);
  	}
  
++<<<<<<< HEAD
 +	if (rxrpc_is_client_call(call))
 +		return rxrpc_disconnect_client_call(conn->bundle, call);
++=======
+ 	if (rxrpc_is_client_call(call)) {
+ 		rxrpc_disconnect_client_call(call->bundle, call);
+ 	} else {
+ 		spin_lock(&conn->bundle->channel_lock);
+ 		__rxrpc_disconnect_call(conn, call);
+ 		spin_unlock(&conn->bundle->channel_lock);
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  
 -		conn->idle_timestamp = jiffies;
 -		if (atomic_dec_and_test(&conn->active))
 -			rxrpc_set_service_reap_timer(conn->rxnet,
 -						     jiffies + rxrpc_connection_expiry);
 -	}
 +	spin_lock(&conn->bundle->channel_lock);
 +	__rxrpc_disconnect_call(conn, call);
 +	spin_unlock(&conn->bundle->channel_lock);
 +
 +	set_bit(RXRPC_CALL_DISCONNECTED, &call->flags);
 +	conn->idle_timestamp = jiffies;
 +}
 +
 +/*
 + * Kill off a connection.
 + */
 +void rxrpc_kill_connection(struct rxrpc_connection *conn)
 +{
 +	struct rxrpc_net *rxnet = conn->params.local->rxnet;
 +
 +	ASSERT(!rcu_access_pointer(conn->channels[0].call) &&
 +	       !rcu_access_pointer(conn->channels[1].call) &&
 +	       !rcu_access_pointer(conn->channels[2].call) &&
 +	       !rcu_access_pointer(conn->channels[3].call));
 +	ASSERT(list_empty(&conn->cache_link));
 +
 +	write_lock(&rxnet->conn_lock);
 +	list_del_init(&conn->proc_link);
 +	write_unlock(&rxnet->conn_lock);
 +
 +	/* Drain the Rx queue.  Note that even though we've unpublished, an
 +	 * incoming packet could still be being added to our Rx queue, so we
 +	 * will need to drain it again in the RCU cleanup handler.
 +	 */
 +	rxrpc_purge_queue(&conn->rx_queue);
  
 -	rxrpc_put_call(call, rxrpc_call_put_io_thread);
 +	/* Leave final destruction to RCU.  The connection processor work item
 +	 * must carry a ref on the connection to prevent us getting here whilst
 +	 * it is queued or running.
 +	 */
 +	call_rcu(&conn->rcu, rxrpc_destroy_connection);
  }
  
  /*
diff --cc net/rxrpc/sendmsg.c
index 45c09f0de6fe,2a003c3a9897..000000000000
--- a/net/rxrpc/sendmsg.c
+++ b/net/rxrpc/sendmsg.c
@@@ -604,7 -564,6 +604,10 @@@ rxrpc_new_client_call_for_sendmsg(struc
  				     atomic_inc_return(&rxrpc_debug_id));
  	/* The socket is now unlocked */
  
++<<<<<<< HEAD
 +	rxrpc_put_peer(cp.peer);
++=======
++>>>>>>> 1bab27af6b88 (rxrpc: Set up a connection bundle from a call, not rxrpc_conn_parameters)
  	_leave(" = %p\n", call);
  	return call;
  }
* Unmerged path include/trace/events/rxrpc.h
* Unmerged path net/rxrpc/af_rxrpc.c
* Unmerged path net/rxrpc/ar-internal.h
* Unmerged path net/rxrpc/call_object.c
* Unmerged path net/rxrpc/conn_client.c
* Unmerged path net/rxrpc/conn_object.c
* Unmerged path net/rxrpc/sendmsg.c
