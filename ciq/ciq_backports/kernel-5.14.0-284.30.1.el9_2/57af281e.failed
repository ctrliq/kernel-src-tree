rxrpc: Tidy up abort generation infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 57af281e5389b6fefedb3685f86847cbb0055f75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/57af281e.failed

Tidy up the abort generation infrastructure in the following ways:

 (1) Create an enum and string mapping table to list the reasons an abort
     might be generated in tracing.

 (2) Replace the 3-char string with the values from (1) in the places that
     use that to log the abort source.  This gets rid of a memcpy() in the
     tracepoint.

 (3) Subsume the rxrpc_rx_eproto tracepoint with the rxrpc_abort tracepoint
     and use values from (1) to indicate the trace reason.

 (4) Always make a call to an abort function at the point of the abort
     rather than stashing the values into variables and using goto to get
     to a place where it reported.  The C optimiser will collapse the calls
     together as appropriate.  The abort functions return a value that can
     be returned directly if appropriate.

Note that this extends into afs also at the points where that generates an
abort.  To aid with this, the afs sources need to #define
RXRPC_TRACE_ONLY_DEFINE_ENUMS before including the rxrpc tracing header
because they don't have access to the rxrpc internal structures that some
of the tracepoints make use of.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 57af281e5389b6fefedb3685f86847cbb0055f75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/rxrpc.h
#	net/rxrpc/ar-internal.h
#	net/rxrpc/call_accept.c
#	net/rxrpc/call_event.c
#	net/rxrpc/call_object.c
#	net/rxrpc/conn_event.c
#	net/rxrpc/input.c
#	net/rxrpc/insecure.c
#	net/rxrpc/io_thread.c
#	net/rxrpc/recvmsg.c
#	net/rxrpc/rxkad.c
#	net/rxrpc/sendmsg.c
diff --cc include/trace/events/rxrpc.h
index 2a52121d73a0,caeabd50e049..000000000000
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@@ -16,44 -16,222 +16,154 @@@
  /*
   * Declare tracing information enums and their string mappings for display.
   */
++<<<<<<< HEAD
++=======
+ #define rxrpc_abort_reasons \
+ 	/* AFS errors */						\
+ 	EM(afs_abort_general_error,		"afs-error")		\
+ 	EM(afs_abort_interrupted,		"afs-intr")		\
+ 	EM(afs_abort_oom,			"afs-oom")		\
+ 	EM(afs_abort_op_not_supported,		"afs-op-notsupp")	\
+ 	EM(afs_abort_probeuuid_negative,	"afs-probeuuid-neg")	\
+ 	EM(afs_abort_send_data_error,		"afs-send-data")	\
+ 	EM(afs_abort_unmarshal_error,		"afs-unmarshal")	\
+ 	/* rxperf errors */						\
+ 	EM(rxperf_abort_general_error,		"rxperf-error")		\
+ 	EM(rxperf_abort_oom,			"rxperf-oom")		\
+ 	EM(rxperf_abort_op_not_supported,	"rxperf-op-notsupp")	\
+ 	EM(rxperf_abort_unmarshal_error,	"rxperf-unmarshal")	\
+ 	/* RxKAD security errors */					\
+ 	EM(rxkad_abort_1_short_check,		"rxkad1-short-check")	\
+ 	EM(rxkad_abort_1_short_data,		"rxkad1-short-data")	\
+ 	EM(rxkad_abort_1_short_encdata,		"rxkad1-short-encdata")	\
+ 	EM(rxkad_abort_1_short_header,		"rxkad1-short-hdr")	\
+ 	EM(rxkad_abort_2_short_check,		"rxkad2-short-check")	\
+ 	EM(rxkad_abort_2_short_data,		"rxkad2-short-data")	\
+ 	EM(rxkad_abort_2_short_header,		"rxkad2-short-hdr")	\
+ 	EM(rxkad_abort_2_short_len,		"rxkad2-short-len")	\
+ 	EM(rxkad_abort_bad_checksum,		"rxkad2-bad-cksum")	\
+ 	EM(rxkad_abort_chall_key_expired,	"rxkad-chall-key-exp")	\
+ 	EM(rxkad_abort_chall_level,		"rxkad-chall-level")	\
+ 	EM(rxkad_abort_chall_no_key,		"rxkad-chall-nokey")	\
+ 	EM(rxkad_abort_chall_short,		"rxkad-chall-short")	\
+ 	EM(rxkad_abort_chall_version,		"rxkad-chall-version")	\
+ 	EM(rxkad_abort_resp_bad_callid,		"rxkad-resp-bad-callid") \
+ 	EM(rxkad_abort_resp_bad_checksum,	"rxkad-resp-bad-cksum")	\
+ 	EM(rxkad_abort_resp_bad_param,		"rxkad-resp-bad-param")	\
+ 	EM(rxkad_abort_resp_call_ctr,		"rxkad-resp-call-ctr") \
+ 	EM(rxkad_abort_resp_call_state,		"rxkad-resp-call-state") \
+ 	EM(rxkad_abort_resp_key_expired,	"rxkad-resp-key-exp")	\
+ 	EM(rxkad_abort_resp_key_rejected,	"rxkad-resp-key-rej")	\
+ 	EM(rxkad_abort_resp_level,		"rxkad-resp-level")	\
+ 	EM(rxkad_abort_resp_nokey,		"rxkad-resp-nokey")	\
+ 	EM(rxkad_abort_resp_ooseq,		"rxkad-resp-ooseq")	\
+ 	EM(rxkad_abort_resp_short,		"rxkad-resp-short")	\
+ 	EM(rxkad_abort_resp_short_tkt,		"rxkad-resp-short-tkt")	\
+ 	EM(rxkad_abort_resp_tkt_aname,		"rxkad-resp-tk-aname")	\
+ 	EM(rxkad_abort_resp_tkt_expired,	"rxkad-resp-tk-exp")	\
+ 	EM(rxkad_abort_resp_tkt_future,		"rxkad-resp-tk-future")	\
+ 	EM(rxkad_abort_resp_tkt_inst,		"rxkad-resp-tk-inst")	\
+ 	EM(rxkad_abort_resp_tkt_len,		"rxkad-resp-tk-len")	\
+ 	EM(rxkad_abort_resp_tkt_realm,		"rxkad-resp-tk-realm")	\
+ 	EM(rxkad_abort_resp_tkt_short,		"rxkad-resp-tk-short")	\
+ 	EM(rxkad_abort_resp_tkt_sinst,		"rxkad-resp-tk-sinst")	\
+ 	EM(rxkad_abort_resp_tkt_sname,		"rxkad-resp-tk-sname")	\
+ 	EM(rxkad_abort_resp_unknown_tkt,	"rxkad-resp-unknown-tkt") \
+ 	EM(rxkad_abort_resp_version,		"rxkad-resp-version")	\
+ 	/* rxrpc errors */						\
+ 	EM(rxrpc_abort_call_improper_term,	"call-improper-term")	\
+ 	EM(rxrpc_abort_call_reset,		"call-reset")		\
+ 	EM(rxrpc_abort_call_sendmsg,		"call-sendmsg")		\
+ 	EM(rxrpc_abort_call_sock_release,	"call-sock-rel")	\
+ 	EM(rxrpc_abort_call_sock_release_tba,	"call-sock-rel-tba")	\
+ 	EM(rxrpc_abort_call_timeout,		"call-timeout")		\
+ 	EM(rxrpc_abort_no_service_key,		"no-serv-key")		\
+ 	EM(rxrpc_abort_nomem,			"nomem")		\
+ 	EM(rxrpc_abort_service_not_offered,	"serv-not-offered")	\
+ 	EM(rxrpc_abort_shut_down,		"shut-down")		\
+ 	EM(rxrpc_abort_unsupported_security,	"unsup-sec")		\
+ 	EM(rxrpc_badmsg_bad_abort,		"bad-abort")		\
+ 	EM(rxrpc_badmsg_bad_jumbo,		"bad-jumbo")		\
+ 	EM(rxrpc_badmsg_short_ack,		"short-ack")		\
+ 	EM(rxrpc_badmsg_short_ack_info,		"short-ack-info")	\
+ 	EM(rxrpc_badmsg_short_hdr,		"short-hdr")		\
+ 	EM(rxrpc_badmsg_unsupported_packet,	"unsup-pkt")		\
+ 	EM(rxrpc_badmsg_zero_call,		"zero-call")		\
+ 	EM(rxrpc_badmsg_zero_seq,		"zero-seq")		\
+ 	EM(rxrpc_badmsg_zero_service,		"zero-service")		\
+ 	EM(rxrpc_eproto_ackr_outside_window,	"ackr-out-win")		\
+ 	EM(rxrpc_eproto_ackr_sack_overflow,	"ackr-sack-over")	\
+ 	EM(rxrpc_eproto_ackr_short_sack,	"ackr-short-sack")	\
+ 	EM(rxrpc_eproto_ackr_zero,		"ackr-zero")		\
+ 	EM(rxrpc_eproto_bad_upgrade,		"bad-upgrade")		\
+ 	EM(rxrpc_eproto_data_after_last,	"data-after-last")	\
+ 	EM(rxrpc_eproto_different_last,		"diff-last")		\
+ 	EM(rxrpc_eproto_early_reply,		"early-reply")		\
+ 	EM(rxrpc_eproto_improper_term,		"improper-term")	\
+ 	EM(rxrpc_eproto_no_client_call,		"no-cl-call")		\
+ 	EM(rxrpc_eproto_no_client_conn,		"no-cl-conn")		\
+ 	EM(rxrpc_eproto_no_service_call,	"no-sv-call")		\
+ 	EM(rxrpc_eproto_reupgrade,		"re-upgrade")		\
+ 	EM(rxrpc_eproto_rxnull_challenge,	"rxnull-chall")		\
+ 	EM(rxrpc_eproto_rxnull_response,	"rxnull-resp")		\
+ 	EM(rxrpc_eproto_tx_rot_last,		"tx-rot-last")		\
+ 	EM(rxrpc_eproto_unexpected_ack,		"unex-ack")		\
+ 	EM(rxrpc_eproto_unexpected_ackall,	"unex-ackall")		\
+ 	EM(rxrpc_eproto_unexpected_implicit_end, "unex-impl-end")	\
+ 	EM(rxrpc_eproto_unexpected_reply,	"unex-reply")		\
+ 	EM(rxrpc_eproto_wrong_security,		"wrong-sec")		\
+ 	EM(rxrpc_recvmsg_excess_data,		"recvmsg-excess")	\
+ 	EM(rxrpc_recvmsg_short_data,		"recvmsg-short")	\
+ 	E_(rxrpc_sendmsg_late_send,		"sendmsg-late")
+ 
+ #define rxrpc_call_poke_traces \
+ 	EM(rxrpc_call_poke_abort,		"Abort")	\
+ 	EM(rxrpc_call_poke_complete,		"Compl")	\
+ 	EM(rxrpc_call_poke_error,		"Error")	\
+ 	EM(rxrpc_call_poke_idle,		"Idle")		\
+ 	EM(rxrpc_call_poke_start,		"Start")	\
+ 	EM(rxrpc_call_poke_timer,		"Timer")	\
+ 	E_(rxrpc_call_poke_timer_now,		"Timer-now")
+ 
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  #define rxrpc_skb_traces \
 -	EM(rxrpc_skb_eaten_by_unshare,		"ETN unshare  ") \
 -	EM(rxrpc_skb_eaten_by_unshare_nomem,	"ETN unshar-nm") \
 -	EM(rxrpc_skb_get_conn_work,		"GET conn-work") \
 -	EM(rxrpc_skb_get_local_work,		"GET locl-work") \
 -	EM(rxrpc_skb_get_reject_work,		"GET rej-work ") \
 -	EM(rxrpc_skb_get_to_recvmsg,		"GET to-recv  ") \
 -	EM(rxrpc_skb_get_to_recvmsg_oos,	"GET to-recv-o") \
 -	EM(rxrpc_skb_new_encap_rcv,		"NEW encap-rcv") \
 -	EM(rxrpc_skb_new_error_report,		"NEW error-rpt") \
 -	EM(rxrpc_skb_new_jumbo_subpacket,	"NEW jumbo-sub") \
 -	EM(rxrpc_skb_new_unshared,		"NEW unshared ") \
 -	EM(rxrpc_skb_put_conn_work,		"PUT conn-work") \
 -	EM(rxrpc_skb_put_error_report,		"PUT error-rep") \
 -	EM(rxrpc_skb_put_input,			"PUT input    ") \
 -	EM(rxrpc_skb_put_jumbo_subpacket,	"PUT jumbo-sub") \
 -	EM(rxrpc_skb_put_purge,			"PUT purge    ") \
 -	EM(rxrpc_skb_put_rotate,		"PUT rotate   ") \
 -	EM(rxrpc_skb_put_unknown,		"PUT unknown  ") \
 -	EM(rxrpc_skb_see_conn_work,		"SEE conn-work") \
 -	EM(rxrpc_skb_see_recvmsg,		"SEE recvmsg  ") \
 -	EM(rxrpc_skb_see_reject,		"SEE reject   ") \
 -	EM(rxrpc_skb_see_rotate,		"SEE rotate   ") \
 -	E_(rxrpc_skb_see_version,		"SEE version  ")
 +	EM(rxrpc_skb_ack,			"ACK") \
 +	EM(rxrpc_skb_cleaned,			"CLN") \
 +	EM(rxrpc_skb_cloned_jumbo,		"CLJ") \
 +	EM(rxrpc_skb_freed,			"FRE") \
 +	EM(rxrpc_skb_got,			"GOT") \
 +	EM(rxrpc_skb_lost,			"*L*") \
 +	EM(rxrpc_skb_new,			"NEW") \
 +	EM(rxrpc_skb_purged,			"PUR") \
 +	EM(rxrpc_skb_received,			"RCV") \
 +	EM(rxrpc_skb_rotated,			"ROT") \
 +	EM(rxrpc_skb_seen,			"SEE") \
 +	EM(rxrpc_skb_unshared,			"UNS") \
 +	E_(rxrpc_skb_unshared_nomem,		"US0")
  
  #define rxrpc_local_traces \
 -	EM(rxrpc_local_free,			"FREE        ") \
 -	EM(rxrpc_local_get_call,		"GET call    ") \
 -	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
 -	EM(rxrpc_local_get_for_use,		"GET for-use ") \
 -	EM(rxrpc_local_get_peer,		"GET peer    ") \
 -	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
 -	EM(rxrpc_local_new,			"NEW         ") \
 -	EM(rxrpc_local_put_bind,		"PUT bind    ") \
 -	EM(rxrpc_local_put_call,		"PUT call    ") \
 -	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
 -	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
 -	EM(rxrpc_local_put_peer,		"PUT peer    ") \
 -	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
 -	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
 -	EM(rxrpc_local_stop,			"STOP        ") \
 -	EM(rxrpc_local_stopped,			"STOPPED     ") \
 -	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
 -	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
 -	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
 -	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
 -	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
 -	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
 -	E_(rxrpc_local_use_peer_keepalive,	"USE peer-kpa")
 +	EM(rxrpc_local_got,			"GOT") \
 +	EM(rxrpc_local_new,			"NEW") \
 +	EM(rxrpc_local_processing,		"PRO") \
 +	EM(rxrpc_local_put,			"PUT") \
 +	EM(rxrpc_local_queued,			"QUE") \
 +	E_(rxrpc_local_tx_ack,			"TAK")
  
  #define rxrpc_peer_traces \
 -	EM(rxrpc_peer_free,			"FREE        ") \
 -	EM(rxrpc_peer_get_accept,		"GET accept  ") \
 -	EM(rxrpc_peer_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
 -	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
 -	EM(rxrpc_peer_get_input,		"GET input   ") \
 -	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
 -	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
 -	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
 -	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
 -	EM(rxrpc_peer_new_client,		"NEW client  ") \
 -	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
 -	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
 -	EM(rxrpc_peer_put_call,			"PUT call    ") \
 -	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
 -	EM(rxrpc_peer_put_discard_tmp,		"PUT disc-tmp") \
 -	EM(rxrpc_peer_put_input,		"PUT input   ") \
 -	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
 -	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
 -
 -#define rxrpc_bundle_traces \
 -	EM(rxrpc_bundle_free,			"FREE        ") \
 -	EM(rxrpc_bundle_get_client_call,	"GET clt-call") \
 -	EM(rxrpc_bundle_get_client_conn,	"GET clt-conn") \
 -	EM(rxrpc_bundle_get_service_conn,	"GET svc-conn") \
 -	EM(rxrpc_bundle_put_conn,		"PUT conn    ") \
 -	EM(rxrpc_bundle_put_discard,		"PUT discard ") \
 -	E_(rxrpc_bundle_new,			"NEW         ")
 +	EM(rxrpc_peer_got,			"GOT") \
 +	EM(rxrpc_peer_new,			"NEW") \
 +	EM(rxrpc_peer_processing,		"PRO") \
 +	E_(rxrpc_peer_put,			"PUT")
  
  #define rxrpc_conn_traces \
 -	EM(rxrpc_conn_free,			"FREE        ") \
 -	EM(rxrpc_conn_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_conn_get_call_input,		"GET inp-call") \
 -	EM(rxrpc_conn_get_conn_input,		"GET inp-conn") \
 -	EM(rxrpc_conn_get_idle,			"GET idle    ") \
 -	EM(rxrpc_conn_get_poke_abort,		"GET pk-abort") \
 -	EM(rxrpc_conn_get_poke_timer,		"GET poke    ") \
 -	EM(rxrpc_conn_get_service_conn,		"GET svc-conn") \
 -	EM(rxrpc_conn_new_client,		"NEW client  ") \
 -	EM(rxrpc_conn_new_service,		"NEW service ") \
 -	EM(rxrpc_conn_put_call,			"PUT call    ") \
 -	EM(rxrpc_conn_put_call_input,		"PUT inp-call") \
 -	EM(rxrpc_conn_put_conn_input,		"PUT inp-conn") \
 -	EM(rxrpc_conn_put_discard,		"PUT discard ") \
 -	EM(rxrpc_conn_put_discard_idle,		"PUT disc-idl") \
 -	EM(rxrpc_conn_put_local_dead,		"PUT loc-dead") \
 -	EM(rxrpc_conn_put_noreuse,		"PUT noreuse ") \
 -	EM(rxrpc_conn_put_poke,			"PUT poke    ") \
 -	EM(rxrpc_conn_put_service_reaped,	"PUT svc-reap") \
 -	EM(rxrpc_conn_put_unbundle,		"PUT unbundle") \
 -	EM(rxrpc_conn_put_unidle,		"PUT unidle  ") \
 -	EM(rxrpc_conn_put_work,			"PUT work    ") \
 -	EM(rxrpc_conn_queue_challenge,		"QUE chall   ") \
 -	EM(rxrpc_conn_queue_retry_work,		"QUE retry-wk") \
 -	EM(rxrpc_conn_queue_rx_work,		"QUE rx-work ") \
 -	EM(rxrpc_conn_see_new_service_conn,	"SEE new-svc ") \
 -	EM(rxrpc_conn_see_reap_service,		"SEE reap-svc") \
 -	E_(rxrpc_conn_see_work,			"SEE work    ")
 +	EM(rxrpc_conn_got,			"GOT") \
 +	EM(rxrpc_conn_new_client,		"NWc") \
 +	EM(rxrpc_conn_new_service,		"NWs") \
 +	EM(rxrpc_conn_put_client,		"PTc") \
 +	EM(rxrpc_conn_put_service,		"PTs") \
 +	EM(rxrpc_conn_queued,			"QUE") \
 +	EM(rxrpc_conn_reap_service,		"RPs") \
 +	E_(rxrpc_conn_seen,			"SEE")
  
  #define rxrpc_client_traces \
  	EM(rxrpc_client_activate_chans,		"Activa") \
@@@ -305,6 -480,9 +415,12 @@@
  #define EM(a, b) a,
  #define E_(a, b) a
  
++<<<<<<< HEAD
++=======
+ enum rxrpc_abort_reason		{ rxrpc_abort_reasons } __mode(byte);
+ enum rxrpc_bundle_trace		{ rxrpc_bundle_traces } __mode(byte);
+ enum rxrpc_call_poke_trace	{ rxrpc_call_poke_traces } __mode(byte);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  enum rxrpc_call_trace		{ rxrpc_call_traces } __mode(byte);
  enum rxrpc_client_trace		{ rxrpc_client_traces } __mode(byte);
  enum rxrpc_congest_change	{ rxrpc_congest_changes } __mode(byte);
@@@ -334,6 -515,9 +453,12 @@@ enum rxrpc_txqueue_trace	{ rxrpc_txqueu
  #define EM(a, b) TRACE_DEFINE_ENUM(a);
  #define E_(a, b) TRACE_DEFINE_ENUM(a);
  
++<<<<<<< HEAD
++=======
+ rxrpc_abort_reasons;
+ rxrpc_bundle_traces;
+ rxrpc_call_poke_traces;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  rxrpc_call_traces;
  rxrpc_client_traces;
  rxrpc_congest_changes;
@@@ -1661,8 -1885,51 +1763,10 @@@ TRACE_EVENT(rxrpc_txbuf
  		      __entry->ref)
  	    );
  
 -TRACE_EVENT(rxrpc_poke_call,
 -	    TP_PROTO(struct rxrpc_call *call, bool busy,
 -		     enum rxrpc_call_poke_trace what),
 -
 -	    TP_ARGS(call, busy, what),
 -
 -	    TP_STRUCT__entry(
 -		    __field(unsigned int,		call_debug_id	)
 -		    __field(bool,			busy		)
 -		    __field(enum rxrpc_call_poke_trace,	what		)
 -			     ),
 -
 -	    TP_fast_assign(
 -		    __entry->call_debug_id = call->debug_id;
 -		    __entry->busy = busy;
 -		    __entry->what = what;
 -			   ),
 -
 -	    TP_printk("c=%08x %s%s",
 -		      __entry->call_debug_id,
 -		      __print_symbolic(__entry->what, rxrpc_call_poke_traces),
 -		      __entry->busy ? "!" : "")
 -	    );
 -
 -TRACE_EVENT(rxrpc_call_poked,
 -	    TP_PROTO(struct rxrpc_call *call),
 -
 -	    TP_ARGS(call),
 -
 -	    TP_STRUCT__entry(
 -		    __field(unsigned int,		call_debug_id	)
 -			     ),
 -
 -	    TP_fast_assign(
 -		    __entry->call_debug_id = call->debug_id;
 -			   ),
 -
 -	    TP_printk("c=%08x",
 -		      __entry->call_debug_id)
 -	    );
 -
  #undef EM
  #undef E_
+ 
+ #endif /* RXRPC_TRACE_ONLY_DEFINE_ENUMS */
  #endif /* _TRACE_RXRPC_H */
  
  /* This part must be outside protection */
diff --cc net/rxrpc/ar-internal.h
index 46ce41afb431,120ce3ccbb22..000000000000
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@@ -602,7 -627,11 +602,15 @@@ struct rxrpc_call 
  	unsigned long		events;
  	spinlock_t		notify_lock;	/* Kernel notification lock */
  	rwlock_t		state_lock;	/* lock for state transition */
++<<<<<<< HEAD
 +	u32			abort_code;	/* Local/remote abort code */
++=======
+ 	unsigned int		send_abort_why; /* Why the abort [enum rxrpc_abort_reason] */
+ 	s32			send_abort;	/* Abort code to be sent */
+ 	short			send_abort_err;	/* Error to be associated with the abort */
+ 	rxrpc_seq_t		send_abort_seq;	/* DATA packet that incurred the abort (or 0) */
+ 	s32			abort_code;	/* Local/remote abort code */
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	int			error;		/* Local error incurred */
  	enum rxrpc_call_state	state;		/* current state of call */
  	enum rxrpc_call_completion completion;	/* Call completion condition */
@@@ -793,9 -819,11 +801,17 @@@ extern struct workqueue_struct *rxrpc_w
   */
  int rxrpc_service_prealloc(struct rxrpc_sock *, gfp_t);
  void rxrpc_discard_prealloc(struct rxrpc_sock *);
++<<<<<<< HEAD
 +struct rxrpc_call *rxrpc_new_incoming_call(struct rxrpc_local *,
 +					   struct rxrpc_sock *,
 +					   struct sk_buff *);
++=======
+ bool rxrpc_new_incoming_call(struct rxrpc_local *local,
+ 			     struct rxrpc_peer *peer,
+ 			     struct rxrpc_connection *conn,
+ 			     struct sockaddr_rxrpc *peer_srx,
+ 			     struct sk_buff *skb);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  void rxrpc_accept_incoming_calls(struct rxrpc_local *);
  int rxrpc_user_charge_accept(struct rxrpc_sock *, unsigned long);
  
@@@ -815,7 -843,7 +831,11 @@@ void rxrpc_reduce_call_timer(struct rxr
  			     unsigned long now,
  			     enum rxrpc_timer_trace why);
  
++<<<<<<< HEAD
 +void rxrpc_delete_call_timer(struct rxrpc_call *call);
++=======
+ bool rxrpc_input_call_event(struct rxrpc_call *call, struct sk_buff *skb);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
  /*
   * call_object.c
@@@ -878,8 -905,20 +898,25 @@@ void rxrpc_clean_up_local_conns(struct 
  /*
   * conn_event.c
   */
++<<<<<<< HEAD
 +void rxrpc_process_connection(struct work_struct *);
 +void rxrpc_process_delayed_final_acks(struct rxrpc_connection *, bool);
++=======
+ void rxrpc_conn_retransmit_call(struct rxrpc_connection *conn, struct sk_buff *skb,
+ 				unsigned int channel);
+ int rxrpc_abort_conn(struct rxrpc_connection *conn, struct sk_buff *skb,
+ 		     s32 abort_code, int err, enum rxrpc_abort_reason why);
+ void rxrpc_process_connection(struct work_struct *);
+ void rxrpc_process_delayed_final_acks(struct rxrpc_connection *, bool);
+ bool rxrpc_input_conn_packet(struct rxrpc_connection *conn, struct sk_buff *skb);
+ void rxrpc_input_conn_event(struct rxrpc_connection *conn, struct sk_buff *skb);
+ 
+ static inline bool rxrpc_is_conn_aborted(const struct rxrpc_connection *conn)
+ {
+ 	/* Order reading the abort info after the state check. */
+ 	return smp_load_acquire(&conn->state) == RXRPC_CONN_ABORTED;
+ }
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
  /*
   * conn_object.c
@@@ -942,7 -973,27 +979,31 @@@ void rxrpc_unpublish_service_conn(struc
  /*
   * input.c
   */
++<<<<<<< HEAD
 +int rxrpc_input_packet(struct sock *, struct sk_buff *);
++=======
+ void rxrpc_congestion_degrade(struct rxrpc_call *);
+ void rxrpc_input_call_packet(struct rxrpc_call *, struct sk_buff *);
+ void rxrpc_implicit_end_call(struct rxrpc_call *, struct sk_buff *);
+ 
+ /*
+  * io_thread.c
+  */
+ int rxrpc_encap_rcv(struct sock *, struct sk_buff *);
+ void rxrpc_error_report(struct sock *);
+ bool rxrpc_direct_abort(struct sk_buff *skb, enum rxrpc_abort_reason why,
+ 			s32 abort_code, int err);
+ int rxrpc_io_thread(void *data);
+ static inline void rxrpc_wake_up_io_thread(struct rxrpc_local *local)
+ {
+ 	wake_up_process(local->io_thread);
+ }
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
+ 
+ static inline bool rxrpc_protocol_error(struct sk_buff *skb, enum rxrpc_abort_reason why)
+ {
+ 	return rxrpc_direct_abort(skb, why, RX_PROTOCOL_ERROR, -EPROTO);
+ }
  
  /*
   * insecure.c
@@@ -1106,6 -1169,8 +1164,11 @@@ struct key *rxrpc_look_up_server_securi
  /*
   * sendmsg.c
   */
++<<<<<<< HEAD
++=======
+ bool rxrpc_propose_abort(struct rxrpc_call *call, s32 abort_code, int error,
+ 			 enum rxrpc_abort_reason why);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  int rxrpc_do_sendmsg(struct rxrpc_sock *, struct msghdr *, size_t);
  
  /*
diff --cc net/rxrpc/call_accept.c
index afe1f587aaf0,a132d486dea0..000000000000
--- a/net/rxrpc/call_accept.c
+++ b/net/rxrpc/call_accept.c
@@@ -334,26 -321,50 +334,63 @@@ static struct rxrpc_call *rxrpc_alloc_i
   * If this is for a kernel service, when we allocate the call, it will have
   * three refs on it: (1) the kernel service, (2) the user_call_ID tree, (3) the
   * retainer ref obtained from the backlog buffer.  Prealloc calls for userspace
 - * services only have the ref from the backlog buffer.
 + * services only have the ref from the backlog buffer.  We want to pass this
 + * ref to non-BH context to dispose of.
   *
   * If we want to report an error, we mark the skb with the packet type and
 - * abort code and return false.
 + * abort code and return NULL.
 + *
 + * The call is returned with the user access mutex held.
   */
++<<<<<<< HEAD
 +struct rxrpc_call *rxrpc_new_incoming_call(struct rxrpc_local *local,
 +					   struct rxrpc_sock *rx,
 +					   struct sk_buff *skb)
++=======
+ bool rxrpc_new_incoming_call(struct rxrpc_local *local,
+ 			     struct rxrpc_peer *peer,
+ 			     struct rxrpc_connection *conn,
+ 			     struct sockaddr_rxrpc *peer_srx,
+ 			     struct sk_buff *skb)
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  {
 -	const struct rxrpc_security *sec = NULL;
  	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
 +	const struct rxrpc_security *sec = NULL;
 +	struct rxrpc_connection *conn;
 +	struct rxrpc_peer *peer = NULL;
  	struct rxrpc_call *call = NULL;
 -	struct rxrpc_sock *rx;
  
  	_enter("");
  
++<<<<<<< HEAD
++=======
+ 	/* Don't set up a call for anything other than a DATA packet. */
+ 	if (sp->hdr.type != RXRPC_PACKET_TYPE_DATA)
+ 		return rxrpc_protocol_error(skb, rxrpc_eproto_no_service_call);
+ 
+ 	rcu_read_lock();
+ 
+ 	/* Weed out packets to services we're not offering.  Packets that would
+ 	 * begin a call are explicitly rejected and the rest are just
+ 	 * discarded.
+ 	 */
+ 	rx = rcu_dereference(local->service);
+ 	if (!rx || (sp->hdr.serviceId != rx->srx.srx_service &&
+ 		    sp->hdr.serviceId != rx->second_service)
+ 	    ) {
+ 		if (sp->hdr.type == RXRPC_PACKET_TYPE_DATA &&
+ 		    sp->hdr.seq == 1)
+ 			goto unsupported_service;
+ 		goto discard;
+ 	}
+ 
+ 	if (!conn) {
+ 		sec = rxrpc_get_incoming_security(rx, skb);
+ 		if (!sec)
+ 			goto unsupported_security;
+ 	}
+ 
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	spin_lock(&rx->incoming_lock);
  	if (rx->sk.sk_state == RXRPC_SERVER_LISTEN_DISABLED ||
  	    rx->sk.sk_state == RXRPC_CLOSE) {
@@@ -394,50 -391,43 +429,73 @@@
  		rx->notify_new_call(&rx->sk, call, call->user_call_ID);
  
  	spin_lock(&conn->state_lock);
 -	if (conn->state == RXRPC_CONN_SERVICE_UNSECURED) {
 +	switch (conn->state) {
 +	case RXRPC_CONN_SERVICE_UNSECURED:
  		conn->state = RXRPC_CONN_SERVICE_CHALLENGING;
  		set_bit(RXRPC_CONN_EV_CHALLENGE, &call->conn->events);
 -		rxrpc_queue_conn(call->conn, rxrpc_conn_queue_challenge);
 +		rxrpc_queue_conn(call->conn);
 +		break;
 +
 +	case RXRPC_CONN_SERVICE:
 +		write_lock(&call->state_lock);
 +		if (call->state < RXRPC_CALL_COMPLETE)
 +			call->state = RXRPC_CALL_SERVER_RECV_REQUEST;
 +		write_unlock(&call->state_lock);
 +		break;
 +
 +	case RXRPC_CONN_REMOTELY_ABORTED:
 +		rxrpc_set_call_completion(call, RXRPC_CALL_REMOTELY_ABORTED,
 +					  conn->abort_code, conn->error);
 +		break;
 +	case RXRPC_CONN_LOCALLY_ABORTED:
 +		rxrpc_abort_call("CON", call, sp->hdr.seq,
 +				 conn->abort_code, conn->error);
 +		break;
 +	default:
 +		BUG();
  	}
  	spin_unlock(&conn->state_lock);
 -
  	spin_unlock(&rx->incoming_lock);
 -	rcu_read_unlock();
  
 -	if (hlist_unhashed(&call->error_link)) {
 -		spin_lock(&call->peer->lock);
 -		hlist_add_head(&call->error_link, &call->peer->error_targets);
 -		spin_unlock(&call->peer->lock);
 -	}
 +	rxrpc_send_ping(call, skb);
 +
 +	/* We have to discard the prealloc queue's ref here and rely on a
 +	 * combination of the RCU read lock and refs held either by the socket
 +	 * (recvmsg queue, to-be-accepted queue or user ID tree) or the kernel
 +	 * service to prevent the call from being deallocated too early.
 +	 */
 +	rxrpc_put_call(call, rxrpc_call_put_discard_prealloc);
  
  	_leave(" = %p{%d}", call, call->debug_id);
++<<<<<<< HEAD
 +	return call;
 +
 +no_call:
 +	spin_unlock(&rx->incoming_lock);
 +	_leave(" = NULL [%u]", skb->mark);
 +	return NULL;
++=======
+ 	rxrpc_input_call_event(call, skb);
+ 	rxrpc_put_call(call, rxrpc_call_put_input);
+ 	return true;
+ 
+ unsupported_service:
+ 	rcu_read_unlock();
+ 	return rxrpc_direct_abort(skb, rxrpc_abort_service_not_offered,
+ 				  RX_INVALID_OPERATION, -EOPNOTSUPP);
+ unsupported_security:
+ 	rcu_read_unlock();
+ 	return rxrpc_direct_abort(skb, rxrpc_abort_service_not_offered,
+ 				  RX_INVALID_OPERATION, -EKEYREJECTED);
+ no_call:
+ 	spin_unlock(&rx->incoming_lock);
+ 	rcu_read_unlock();
+ 	_leave(" = f [%u]", skb->mark);
+ 	return false;
+ discard:
+ 	rcu_read_unlock();
+ 	return true;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  /*
diff --cc net/rxrpc/call_event.c
index a95f4604cb29,695aeb70d1a6..000000000000
--- a/net/rxrpc/call_event.c
+++ b/net/rxrpc/call_event.c
@@@ -294,13 -254,91 +294,17 @@@ out
  /*
   * Handle retransmission and deferred ACK/abort generation.
   */
++<<<<<<< HEAD
 +void rxrpc_process_call(struct work_struct *work)
++=======
+ bool rxrpc_input_call_event(struct rxrpc_call *call, struct sk_buff *skb)
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  {
 +	struct rxrpc_call *call =
 +		container_of(work, struct rxrpc_call, processor);
  	unsigned long now, next, t;
 +	unsigned int iterations = 0;
  	rxrpc_serial_t ackr_serial;
 -	bool resend = false, expired = false;
 -	s32 abort_code;
  
  	rxrpc_see_call(call, rxrpc_call_see_input);
  
@@@ -308,26 -346,21 +312,35 @@@
  	_enter("{%d,%s,%lx}",
  	       call->debug_id, rxrpc_call_states[call->state], call->events);
  
 -	if (call->state == RXRPC_CALL_COMPLETE)
 -		goto out;
 -
 +recheck_state:
 +	/* Limit the number of times we do this before returning to the manager */
 +	iterations++;
 +	if (iterations > 5)
 +		goto requeue;
 +
++<<<<<<< HEAD
 +	if (test_and_clear_bit(RXRPC_CALL_EV_ABORT, &call->events)) {
 +		rxrpc_send_abort_packet(call);
 +		goto recheck_state;
++=======
+ 	/* Handle abort request locklessly, vs rxrpc_propose_abort(). */
+ 	abort_code = smp_load_acquire(&call->send_abort);
+ 	if (abort_code) {
+ 		rxrpc_abort_call(call, 0, call->send_abort, call->send_abort_err,
+ 				 call->send_abort_why);
+ 		goto out;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	}
  
 -	if (skb && skb->mark == RXRPC_SKB_MARK_ERROR)
 -		goto out;
 +	if (READ_ONCE(call->acks_hard_ack) != call->tx_bottom)
 +		rxrpc_shrink_call_tx_buffer(call);
 +
 +	if (call->state == RXRPC_CALL_COMPLETE) {
 +		rxrpc_delete_call_timer(call);
 +		goto out_put;
 +	}
  
 -	/* If we see our async-event poke, check for timeout trippage. */
 +	/* Work out if any timeouts tripped */
  	now = jiffies;
  	t = READ_ONCE(call->expect_rx_by);
  	if (time_after_eq(now, t)) {
@@@ -392,56 -440,61 +405,62 @@@
  		if (test_bit(RXRPC_CALL_RX_HEARD, &call->flags) &&
  		    (int)call->conn->hi_serial - (int)call->rx_serial > 0) {
  			trace_rxrpc_call_reset(call);
- 			rxrpc_abort_call("EXP", call, 0, RX_CALL_DEAD, -ECONNRESET);
+ 			rxrpc_abort_call(call, 0, RX_CALL_DEAD, -ECONNRESET,
+ 					 rxrpc_abort_call_reset);
  		} else {
- 			rxrpc_abort_call("EXP", call, 0, RX_CALL_TIMEOUT, -ETIME);
+ 			rxrpc_abort_call(call, 0, RX_CALL_TIMEOUT, -ETIME,
+ 					 rxrpc_abort_call_timeout);
  		}
 -		goto out;
 +		set_bit(RXRPC_CALL_EV_ABORT, &call->events);
 +		goto recheck_state;
  	}
  
 -	if (test_and_clear_bit(RXRPC_CALL_EV_ACK_LOST, &call->events))
 +	if (test_and_clear_bit(RXRPC_CALL_EV_ACK_LOST, &call->events)) {
 +		call->acks_lost_top = call->tx_top;
  		rxrpc_send_ACK(call, RXRPC_ACK_PING, 0,
  			       rxrpc_propose_ack_ping_for_lost_ack);
 +	}
  
 -	if (resend && call->state != RXRPC_CALL_CLIENT_RECV_REPLY)
 -		rxrpc_resend(call, NULL);
 -
 -	if (test_and_clear_bit(RXRPC_CALL_RX_IS_IDLE, &call->flags))
 -		rxrpc_send_ACK(call, RXRPC_ACK_IDLE, 0,
 -			       rxrpc_propose_ack_rx_idle);
 -
 -	if (atomic_read(&call->ackr_nr_unacked) > 2)
 -		rxrpc_send_ACK(call, RXRPC_ACK_IDLE, 0,
 -			       rxrpc_propose_ack_input_data);
 +	if (test_and_clear_bit(RXRPC_CALL_EV_RESEND, &call->events) &&
 +	    call->state != RXRPC_CALL_CLIENT_RECV_REPLY) {
 +		rxrpc_resend(call, now);
 +		goto recheck_state;
 +	}
  
  	/* Make sure the timer is restarted */
 -	if (call->state != RXRPC_CALL_COMPLETE) {
 -		next = call->expect_rx_by;
 +	next = call->expect_rx_by;
  
  #define set(T) { t = READ_ONCE(T); if (time_before(t, next)) next = t; }
  
 -		set(call->expect_req_by);
 -		set(call->expect_term_by);
 -		set(call->delay_ack_at);
 -		set(call->ack_lost_at);
 -		set(call->resend_at);
 -		set(call->keepalive_at);
 -		set(call->ping_at);
 +	set(call->expect_req_by);
 +	set(call->expect_term_by);
 +	set(call->delay_ack_at);
 +	set(call->ack_lost_at);
 +	set(call->resend_at);
 +	set(call->keepalive_at);
 +	set(call->ping_at);
 +
 +	now = jiffies;
 +	if (time_after_eq(now, next))
 +		goto recheck_state;
  
 -		now = jiffies;
 -		if (time_after_eq(now, next))
 -			rxrpc_poke_call(call, rxrpc_call_poke_timer_now);
 +	rxrpc_reduce_call_timer(call, next, now, rxrpc_timer_restart);
  
 -		rxrpc_reduce_call_timer(call, next, now, rxrpc_timer_restart);
 -	}
 +	/* other events may have been raised since we started checking */
 +	if (call->events && call->state < RXRPC_CALL_COMPLETE)
 +		goto requeue;
  
 +out_put:
 +	rxrpc_put_call(call, rxrpc_call_put_work);
  out:
 -	if (call->state == RXRPC_CALL_COMPLETE) {
 -		del_timer_sync(&call->timer);
 -		if (!test_bit(RXRPC_CALL_DISCONNECTED, &call->flags))
 -			rxrpc_disconnect_call(call);
 -		if (call->security)
 -			call->security->free_call_crypto(call);
 -	}
 -	if (call->acks_hard_ack != call->tx_bottom)
 -		rxrpc_shrink_call_tx_buffer(call);
  	_leave("");
++<<<<<<< HEAD
 +	return;
 +
 +requeue:
 +	__rxrpc_queue_call(call, rxrpc_call_queue_requeue);
 +	goto out;
++=======
+ 	return true;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
diff --cc net/rxrpc/call_object.c
index ad495d0d21a8,705f6e26cc75..000000000000
--- a/net/rxrpc/call_object.c
+++ b/net/rxrpc/call_object.c
@@@ -571,7 -581,8 +571,12 @@@ void rxrpc_release_calls_on_socket(stru
  		call = list_entry(rx->to_be_accepted.next,
  				  struct rxrpc_call, accept_link);
  		list_del(&call->accept_link);
++<<<<<<< HEAD
 +		rxrpc_abort_call("SKR", call, 0, RX_CALL_DEAD, -ECONNRESET);
++=======
+ 		rxrpc_propose_abort(call, RX_CALL_DEAD, -ECONNRESET,
+ 				    rxrpc_abort_call_sock_release_tba);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		rxrpc_put_call(call, rxrpc_call_put_release_sock_tba);
  	}
  
@@@ -579,8 -590,8 +584,13 @@@
  		call = list_entry(rx->sock_calls.next,
  				  struct rxrpc_call, sock_link);
  		rxrpc_get_call(call, rxrpc_call_get_release_sock);
++<<<<<<< HEAD
 +		rxrpc_abort_call("SKT", call, 0, RX_CALL_DEAD, -ECONNRESET);
 +		rxrpc_send_abort_packet(call);
++=======
+ 		rxrpc_propose_abort(call, RX_CALL_DEAD, -ECONNRESET,
+ 				    rxrpc_abort_call_sock_release);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		rxrpc_release_call(rx, call);
  		rxrpc_put_call(call, rxrpc_call_put_release_sock);
  	}
diff --cc net/rxrpc/conn_event.c
index abf03a5b1d31,485d7f0fed2c..000000000000
--- a/net/rxrpc/conn_event.c
+++ b/net/rxrpc/conn_event.c
@@@ -17,11 -17,65 +17,68 @@@
  #include "ar-internal.h"
  
  /*
++<<<<<<< HEAD
++=======
+  * Set the completion state on an aborted connection.
+  */
+ static bool rxrpc_set_conn_aborted(struct rxrpc_connection *conn, struct sk_buff *skb,
+ 				   s32 abort_code, int err,
+ 				   enum rxrpc_call_completion compl)
+ {
+ 	bool aborted = false;
+ 
+ 	if (conn->state != RXRPC_CONN_ABORTED) {
+ 		spin_lock(&conn->state_lock);
+ 		if (conn->state != RXRPC_CONN_ABORTED) {
+ 			conn->abort_code = abort_code;
+ 			conn->error	 = err;
+ 			conn->completion = compl;
+ 			/* Order the abort info before the state change. */
+ 			smp_store_release(&conn->state, RXRPC_CONN_ABORTED);
+ 			set_bit(RXRPC_CONN_DONT_REUSE, &conn->flags);
+ 			set_bit(RXRPC_CONN_EV_ABORT_CALLS, &conn->events);
+ 			aborted = true;
+ 		}
+ 		spin_unlock(&conn->state_lock);
+ 	}
+ 
+ 	return aborted;
+ }
+ 
+ /*
+  * Mark a socket buffer to indicate that the connection it's on should be aborted.
+  */
+ int rxrpc_abort_conn(struct rxrpc_connection *conn, struct sk_buff *skb,
+ 		     s32 abort_code, int err, enum rxrpc_abort_reason why)
+ {
+ 	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
+ 
+ 	if (rxrpc_set_conn_aborted(conn, skb, abort_code, err,
+ 				   RXRPC_CALL_LOCALLY_ABORTED)) {
+ 		trace_rxrpc_abort(0, why, sp->hdr.cid, sp->hdr.callNumber,
+ 				  sp->hdr.seq, abort_code, err);
+ 		rxrpc_poke_conn(conn, rxrpc_conn_get_poke_abort);
+ 	}
+ 	return -EPROTO;
+ }
+ 
+ /*
+  * Mark a connection as being remotely aborted.
+  */
+ static bool rxrpc_input_conn_abort(struct rxrpc_connection *conn,
+ 				   struct sk_buff *skb)
+ {
+ 	return rxrpc_set_conn_aborted(conn, skb, skb->priority, -ECONNABORTED,
+ 				      RXRPC_CALL_REMOTELY_ABORTED);
+ }
+ 
+ /*
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
   * Retransmit terminal ACK or ABORT of the previous call.
   */
 -void rxrpc_conn_retransmit_call(struct rxrpc_connection *conn,
 -				struct sk_buff *skb,
 -				unsigned int channel)
 +static void rxrpc_conn_retransmit_call(struct rxrpc_connection *conn,
 +				       struct sk_buff *skb,
 +				       unsigned int channel)
  {
  	struct rxrpc_skb_priv *sp = skb ? rxrpc_skb(skb) : NULL;
  	struct rxrpc_channel *chan;
@@@ -354,26 -298,9 +410,32 @@@ static int rxrpc_process_event(struct r
   */
  static void rxrpc_secure_connection(struct rxrpc_connection *conn)
  {
++<<<<<<< HEAD
 +	u32 abort_code;
 +	int ret;
 +
 +	_enter("{%d}", conn->debug_id);
 +
 +	ASSERT(conn->security_ix != 0);
 +
 +	if (conn->security->issue_challenge(conn) < 0) {
 +		abort_code = RX_CALL_DEAD;
 +		ret = -ENOMEM;
 +		goto abort;
 +	}
 +
 +	_leave("");
 +	return;
 +
 +abort:
 +	_debug("abort %d, %d", ret, abort_code);
 +	rxrpc_abort_connection(conn, ret, abort_code);
 +	_leave(" [aborted]");
++=======
+ 	if (conn->security->issue_challenge(conn) < 0)
+ 		rxrpc_abort_conn(conn, NULL, RX_CALL_DEAD, -ENOMEM,
+ 				 rxrpc_abort_nomem);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  /*
@@@ -472,14 -379,73 +534,80 @@@ void rxrpc_process_connection(struct wo
  	struct rxrpc_connection *conn =
  		container_of(work, struct rxrpc_connection, processor);
  
 -	rxrpc_see_connection(conn, rxrpc_conn_see_work);
 +	rxrpc_see_connection(conn);
  
 -	if (__rxrpc_use_local(conn->local, rxrpc_local_use_conn_work)) {
 +	if (__rxrpc_use_local(conn->params.local)) {
  		rxrpc_do_process_connection(conn);
 -		rxrpc_unuse_local(conn->local, rxrpc_local_unuse_conn_work);
 +		rxrpc_unuse_local(conn->params.local);
  	}
++<<<<<<< HEAD
 +
 +	rxrpc_put_connection(conn);
 +	_leave("");
 +	return;
++=======
+ }
+ 
+ /*
+  * post connection-level events to the connection
+  * - this includes challenges, responses, some aborts and call terminal packet
+  *   retransmission.
+  */
+ static void rxrpc_post_packet_to_conn(struct rxrpc_connection *conn,
+ 				      struct sk_buff *skb)
+ {
+ 	_enter("%p,%p", conn, skb);
+ 
+ 	rxrpc_get_skb(skb, rxrpc_skb_get_conn_work);
+ 	skb_queue_tail(&conn->rx_queue, skb);
+ 	rxrpc_queue_conn(conn, rxrpc_conn_queue_rx_work);
+ }
+ 
+ /*
+  * Input a connection-level packet.
+  */
+ bool rxrpc_input_conn_packet(struct rxrpc_connection *conn, struct sk_buff *skb)
+ {
+ 	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
+ 
+ 	switch (sp->hdr.type) {
+ 	case RXRPC_PACKET_TYPE_BUSY:
+ 		/* Just ignore BUSY packets for now. */
+ 		return true;
+ 
+ 	case RXRPC_PACKET_TYPE_ABORT:
+ 		if (rxrpc_is_conn_aborted(conn))
+ 			return true;
+ 		rxrpc_input_conn_abort(conn, skb);
+ 		rxrpc_abort_calls(conn);
+ 		return true;
+ 
+ 	case RXRPC_PACKET_TYPE_CHALLENGE:
+ 	case RXRPC_PACKET_TYPE_RESPONSE:
+ 		if (rxrpc_is_conn_aborted(conn)) {
+ 			if (conn->completion == RXRPC_CALL_LOCALLY_ABORTED)
+ 				rxrpc_send_conn_abort(conn);
+ 			return true;
+ 		}
+ 		rxrpc_post_packet_to_conn(conn, skb);
+ 		return true;
+ 
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return true;
+ 	}
+ }
+ 
+ /*
+  * Input a connection event.
+  */
+ void rxrpc_input_conn_event(struct rxrpc_connection *conn, struct sk_buff *skb)
+ {
+ 	if (test_and_clear_bit(RXRPC_CONN_EV_ABORT_CALLS, &conn->events))
+ 		rxrpc_abort_calls(conn);
+ 
+ 	/* Process delayed ACKs whose time has come. */
+ 	if (conn->flags & RXRPC_CONN_FINAL_ACK_MASK)
+ 		rxrpc_process_delayed_final_acks(conn, false);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
diff --cc net/rxrpc/input.c
index b5326e160685,bd69ff2d9082..000000000000
--- a/net/rxrpc/input.c
+++ b/net/rxrpc/input.c
@@@ -9,13 -9,10 +9,17 @@@
  
  #include "ar-internal.h"
  
- static void rxrpc_proto_abort(const char *why,
- 			      struct rxrpc_call *call, rxrpc_seq_t seq)
+ static void rxrpc_proto_abort(struct rxrpc_call *call, rxrpc_seq_t seq,
+ 			      enum rxrpc_abort_reason why)
  {
++<<<<<<< HEAD
 +	if (rxrpc_abort_call(why, call, seq, RX_PROTOCOL_ERROR, -EBADMSG)) {
 +		set_bit(RXRPC_CALL_EV_ABORT, &call->events);
 +		rxrpc_queue_call(call, rxrpc_call_queue_abort);
 +	}
++=======
+ 	rxrpc_abort_call(call, seq, RX_PROTOCOL_ERROR, -EBADMSG, why);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  /*
@@@ -359,17 -366,14 +364,26 @@@ static void rxrpc_input_data_one(struc
  
  	if (last) {
  		if (test_and_set_bit(RXRPC_CALL_RX_LAST, &call->flags) &&
++<<<<<<< HEAD
 +		    seq + 1 != wtop) {
 +			rxrpc_proto_abort("LSN", call, seq);
 +			goto err_free;
 +		}
++=======
+ 		    seq + 1 != wtop)
+ 			return rxrpc_proto_abort(call, seq, rxrpc_eproto_different_last);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	} else {
  		if (test_bit(RXRPC_CALL_RX_LAST, &call->flags) &&
  		    after_eq(seq, wtop)) {
  			pr_warn("Packet beyond last: c=%x q=%x window=%x-%x wlimit=%x\n",
  				call->debug_id, seq, window, wtop, wlimit);
++<<<<<<< HEAD
 +			rxrpc_proto_abort("LSA", call, seq);
 +			goto err_free;
++=======
+ 			return rxrpc_proto_abort(call, seq, rxrpc_eproto_data_after_last);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		}
  	}
  
@@@ -596,11 -578,11 +610,16 @@@ static void rxrpc_input_data(struct rxr
  	if ((state == RXRPC_CALL_CLIENT_SEND_REQUEST ||
  	     state == RXRPC_CALL_CLIENT_AWAIT_REPLY) &&
  	    !rxrpc_receiving_reply(call))
 -		goto out_notify;
 +		goto out;
  
  	if (!rxrpc_input_split_jumbo(call, skb)) {
++<<<<<<< HEAD
 +		rxrpc_proto_abort("VLD", call, sp->hdr.seq);
 +		goto out;
++=======
+ 		rxrpc_proto_abort(call, sp->hdr.seq, rxrpc_badmsg_bad_jumbo);
+ 		goto out_notify;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	}
  	skb = NULL;
  
@@@ -810,10 -761,8 +829,15 @@@ static void rxrpc_input_ack(struct rxrp
  	_enter("");
  
  	offset = sizeof(struct rxrpc_wire_header);
++<<<<<<< HEAD
 +	if (skb_copy_bits(skb, offset, &ack, sizeof(ack)) < 0) {
 +		rxrpc_proto_abort("XAK", call, 0);
 +		goto out_not_locked;
 +	}
++=======
+ 	if (skb_copy_bits(skb, offset, &ack, sizeof(ack)) < 0)
+ 		return rxrpc_proto_abort(call, 0, rxrpc_badmsg_short_ack);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	offset += sizeof(ack);
  
  	ack_serial = sp->hdr.serial;
@@@ -892,10 -841,8 +916,15 @@@
  	info.rxMTU = 0;
  	ioffset = offset + nr_acks + 3;
  	if (skb->len >= ioffset + sizeof(info) &&
++<<<<<<< HEAD
 +	    skb_copy_bits(skb, ioffset, &info, sizeof(info)) < 0) {
 +		rxrpc_proto_abort("XAI", call, 0);
 +		goto out_not_locked;
 +	}
++=======
+ 	    skb_copy_bits(skb, ioffset, &info, sizeof(info)) < 0)
+ 		return rxrpc_proto_abort(call, 0, rxrpc_badmsg_short_ack_info);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
  	if (nr_acks > 0)
  		skb_condense(skb);
@@@ -931,10 -864,8 +960,15 @@@
  	if (info.rxMTU)
  		rxrpc_input_ackinfo(call, skb, &info);
  
++<<<<<<< HEAD
 +	if (first_soft_ack == 0) {
 +		rxrpc_proto_abort("AK0", call, 0);
 +		goto out;
 +	}
++=======
+ 	if (first_soft_ack == 0)
+ 		return rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_zero);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
  	/* Ignore ACKs unless we are or have just been transmitting. */
  	switch (READ_ONCE(call->state)) {
@@@ -948,41 -879,23 +982,58 @@@
  	}
  
  	if (before(hard_ack, call->acks_hard_ack) ||
++<<<<<<< HEAD
 +	    after(hard_ack, call->tx_top)) {
 +		rxrpc_proto_abort("AKW", call, 0);
 +		goto out;
 +	}
 +	if (nr_acks > call->tx_top - hard_ack) {
 +		rxrpc_proto_abort("AKN", call, 0);
 +		goto out;
 +	}
 +
 +	if (after(hard_ack, call->acks_hard_ack)) {
 +		if (rxrpc_rotate_tx_window(call, hard_ack, &summary)) {
 +			rxrpc_end_tx_phase(call, false, "ETA");
 +			goto out;
++=======
+ 	    after(hard_ack, call->tx_top))
+ 		return rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_outside_window);
+ 	if (nr_acks > call->tx_top - hard_ack)
+ 		return rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_sack_overflow);
+ 
+ 	if (after(hard_ack, call->acks_hard_ack)) {
+ 		if (rxrpc_rotate_tx_window(call, hard_ack, &summary)) {
+ 			rxrpc_end_tx_phase(call, false, rxrpc_eproto_unexpected_ack);
+ 			return;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		}
  	}
  
  	if (nr_acks > 0) {
++<<<<<<< HEAD
 +		if (offset > (int)skb->len - nr_acks) {
 +			rxrpc_proto_abort("XSA", call, 0);
 +			goto out;
 +		}
 +
 +		spin_lock(&call->acks_ack_lock);
 +		skb_old = call->acks_soft_tbl;
 +		call->acks_soft_tbl = skb;
 +		spin_unlock(&call->acks_ack_lock);
 +
++=======
+ 		if (offset > (int)skb->len - nr_acks)
+ 			return rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_short_sack);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		rxrpc_input_soft_acks(call, skb->data + offset, first_soft_ack,
  				      nr_acks, &summary);
 +		skb_put = NULL;
 +	} else if (call->acks_soft_tbl) {
 +		spin_lock(&call->acks_ack_lock);
 +		skb_old = call->acks_soft_tbl;
 +		call->acks_soft_tbl = NULL;
 +		spin_unlock(&call->acks_ack_lock);
  	}
  
  	if (test_bit(RXRPC_CALL_TX_LAST, &call->flags) &&
@@@ -1006,12 -914,8 +1057,16 @@@ static void rxrpc_input_ackall(struct r
  {
  	struct rxrpc_ack_summary summary = { 0 };
  
 +	spin_lock(&call->input_lock);
 +
  	if (rxrpc_rotate_tx_window(call, call->tx_top, &summary))
++<<<<<<< HEAD
 +		rxrpc_end_tx_phase(call, false, "ETL");
 +
 +	spin_unlock(&call->input_lock);
++=======
+ 		rxrpc_end_tx_phase(call, false, rxrpc_eproto_unexpected_ackall);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  /*
@@@ -1050,12 -960,10 +1105,19 @@@ static void rxrpc_input_call_packet(str
  
  	switch (sp->hdr.type) {
  	case RXRPC_PACKET_TYPE_DATA:
++<<<<<<< HEAD
 +		rxrpc_input_data(call, skb);
 +		goto no_free;
 +
 +	case RXRPC_PACKET_TYPE_ACK:
 +		rxrpc_input_ack(call, skb);
 +		goto no_free;
++=======
+ 		return rxrpc_input_data(call, skb);
+ 
+ 	case RXRPC_PACKET_TYPE_ACK:
+ 		return rxrpc_input_ack(call, skb);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
  	case RXRPC_PACKET_TYPE_BUSY:
  		/* Just ignore BUSY packets from the server; the retry and
@@@ -1098,10 -998,8 +1158,15 @@@ static void rxrpc_input_implicit_end_ca
  	case RXRPC_CALL_COMPLETE:
  		break;
  	default:
++<<<<<<< HEAD
 +		if (rxrpc_abort_call("IMP", call, 0, RX_CALL_DEAD, -ESHUTDOWN)) {
 +			set_bit(RXRPC_CALL_EV_ABORT, &call->events);
 +			rxrpc_queue_call(call, rxrpc_call_queue_abort);
 +		}
++=======
+ 		rxrpc_abort_call(call, 0, RX_CALL_DEAD, -ESHUTDOWN,
+ 				 rxrpc_eproto_improper_term);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		trace_rxrpc_improper_term(call);
  		break;
  	}
diff --cc net/rxrpc/insecure.c
index 0eb8471bfc53,34353b6e584b..000000000000
--- a/net/rxrpc/insecure.c
+++ b/net/rxrpc/insecure.c
@@@ -43,25 -43,17 +43,35 @@@ static void none_free_call_crypto(struc
  }
  
  static int none_respond_to_challenge(struct rxrpc_connection *conn,
 -				     struct sk_buff *skb)
 +				     struct sk_buff *skb,
 +				     u32 *_abort_code)
  {
++<<<<<<< HEAD
 +	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
 +
 +	trace_rxrpc_rx_eproto(NULL, sp->hdr.serial,
 +			      tracepoint_string("chall_none"));
 +	return -EPROTO;
++=======
+ 	return rxrpc_abort_conn(conn, skb, RX_PROTOCOL_ERROR, -EPROTO,
+ 				rxrpc_eproto_rxnull_challenge);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  static int none_verify_response(struct rxrpc_connection *conn,
 -				struct sk_buff *skb)
 +				struct sk_buff *skb,
 +				u32 *_abort_code)
  {
++<<<<<<< HEAD
 +	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
 +
 +	trace_rxrpc_rx_eproto(NULL, sp->hdr.serial,
 +			      tracepoint_string("resp_none"));
 +	return -EPROTO;
++=======
+ 	return rxrpc_abort_conn(conn, skb, RX_PROTOCOL_ERROR, -EPROTO,
+ 				rxrpc_eproto_rxnull_response);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  static void none_clear(struct rxrpc_connection *conn)
diff --cc net/rxrpc/recvmsg.c
index c84d2b620396,59b521b82aec..000000000000
--- a/net/rxrpc/recvmsg.c
+++ b/net/rxrpc/recvmsg.c
@@@ -131,9 -131,11 +131,17 @@@ bool rxrpc_abort_call(struct rxrpc_cal
  {
  	bool ret;
  
++<<<<<<< HEAD
 +	write_lock_bh(&call->state_lock);
 +	ret = __rxrpc_abort_call(why, call, seq, abort_code, error);
 +	write_unlock_bh(&call->state_lock);
++=======
+ 	write_lock(&call->state_lock);
+ 	ret = __rxrpc_abort_call(call, seq, abort_code, error, why);
+ 	write_unlock(&call->state_lock);
+ 	if (ret && test_bit(RXRPC_CALL_EXPOSED, &call->flags))
+ 		rxrpc_send_abort_packet(call);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	return ret;
  }
  
diff --cc net/rxrpc/rxkad.c
index 36cf40442a7e,e52cb8058156..000000000000
--- a/net/rxrpc/rxkad.c
+++ b/net/rxrpc/rxkad.c
@@@ -627,12 -593,12 +593,12 @@@ static int rxkad_verify_packet(struct r
  		cksum = 1; /* zero checksums are not permitted */
  
  	if (cksum != sp->hdr.cksum) {
- 		aborted = rxrpc_abort_eproto(call, skb, "rxkad_csum", "VCK",
- 					     RXKADSEALEDINCON);
- 		goto protocol_error;
+ 		ret = rxrpc_abort_eproto(call, skb, RXKADSEALEDINCON,
+ 					 rxkad_abort_bad_checksum);
+ 		goto out;
  	}
  
 -	switch (call->conn->security_level) {
 +	switch (call->conn->params.security_level) {
  	case RXRPC_SECURITY_PLAIN:
  		ret = 0;
  		break;
@@@ -828,27 -789,24 +790,34 @@@ static int rxkad_respond_to_challenge(s
  	struct rxkad_challenge challenge;
  	struct rxkad_response *resp;
  	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
- 	const char *eproto;
- 	u32 version, nonce, min_level, abort_code;
- 	int ret;
+ 	u32 version, nonce, min_level;
+ 	int ret = -EPROTO;
  
 -	_enter("{%d,%x}", conn->debug_id, key_serial(conn->key));
 +	_enter("{%d,%x}", conn->debug_id, key_serial(conn->params.key));
 +
++<<<<<<< HEAD
 +	eproto = tracepoint_string("chall_no_key");
 +	abort_code = RX_PROTOCOL_ERROR;
 +	if (!conn->params.key)
 +		goto protocol_error;
  
 +	abort_code = RXKADEXPIRED;
 +	ret = key_validate(conn->params.key);
++=======
+ 	if (!conn->key)
+ 		return rxrpc_abort_conn(conn, skb, RX_PROTOCOL_ERROR, -EPROTO,
+ 					rxkad_abort_chall_no_key);
+ 
+ 	ret = key_validate(conn->key);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	if (ret < 0)
- 		goto other_error;
+ 		return rxrpc_abort_conn(conn, skb, RXKADEXPIRED, ret,
+ 					rxkad_abort_chall_key_expired);
  
- 	eproto = tracepoint_string("chall_short");
- 	abort_code = RXKADPACKETSHORT;
  	if (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),
  			  &challenge, sizeof(challenge)) < 0)
- 		goto protocol_error;
+ 		return rxrpc_abort_conn(conn, skb, RXKADPACKETSHORT, -EPROTO,
+ 					rxkad_abort_chall_short);
  
  	version = ntohl(challenge.version);
  	nonce = ntohl(challenge.nonce);
@@@ -856,17 -814,15 +825,22 @@@
  
  	trace_rxrpc_rx_challenge(conn, sp->hdr.serial, version, nonce, min_level);
  
- 	eproto = tracepoint_string("chall_ver");
- 	abort_code = RXKADINCONSISTENCY;
  	if (version != RXKAD_VERSION)
- 		goto protocol_error;
+ 		return rxrpc_abort_conn(conn, skb, RXKADINCONSISTENCY, -EPROTO,
+ 					rxkad_abort_chall_version);
  
++<<<<<<< HEAD
 +	abort_code = RXKADLEVELFAIL;
 +	ret = -EACCES;
 +	if (conn->params.security_level < min_level)
 +		goto other_error;
++=======
+ 	if (conn->security_level < min_level)
+ 		return rxrpc_abort_conn(conn, skb, RXKADLEVELFAIL, -EACCES,
+ 					rxkad_abort_chall_level);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
 -	token = conn->key->payload.data[0];
 +	token = conn->params.key->payload.data[0];
  
  	/* build the response packet */
  	resp = kzalloc(sizeof(struct rxkad_response), GFP_NOFS);
@@@ -893,13 -849,6 +867,16 @@@
  		ret = rxkad_send_response(conn, &sp->hdr, resp, token->kad);
  	kfree(resp);
  	return ret;
++<<<<<<< HEAD
 +
 +protocol_error:
 +	trace_rxrpc_rx_eproto(NULL, sp->hdr.serial, eproto);
 +	ret = -EPROTO;
 +other_error:
 +	*_abort_code = abort_code;
 +	return ret;
++=======
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  /*
@@@ -910,11 -859,9 +887,10 @@@ static int rxkad_decrypt_ticket(struct 
  				struct sk_buff *skb,
  				void *ticket, size_t ticket_len,
  				struct rxrpc_crypt *_session_key,
 -				time64_t *_expiry)
 +				time64_t *_expiry,
 +				u32 *_abort_code)
  {
  	struct skcipher_request *req;
- 	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
  	struct rxrpc_crypt iv, key;
  	struct scatterlist sg[1];
  	struct in_addr addr;
@@@ -1033,19 -974,9 +1003,22 @@@
  	_debug("KIV SNAME: %s", name);
  
  	/* get the service instance name */
- 	name = Z(INST);
+ 	name = Z(INST, sinst);
  	_debug("KIV SINST: %s", name);
  	return 0;
++<<<<<<< HEAD
 +
 +bad_ticket:
 +	trace_rxrpc_rx_eproto(NULL, sp->hdr.serial, eproto);
 +	abort_code = RXKADBADTICKET;
 +	ret = -EPROTO;
 +other_error:
 +	*_abort_code = abort_code;
 +	return ret;
 +temporary_error:
 +	return ret;
++=======
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  }
  
  /*
@@@ -1104,22 -1033,18 +1076,26 @@@ static int rxkad_verify_response(struc
  
  	server_key = rxrpc_look_up_server_security(conn, skb, 0, 0);
  	if (IS_ERR(server_key)) {
- 		switch (PTR_ERR(server_key)) {
+ 		ret = PTR_ERR(server_key);
+ 		switch (ret) {
  		case -ENOKEY:
- 			abort_code = RXKADUNKNOWNKEY;
- 			break;
+ 			return rxrpc_abort_conn(conn, skb, RXKADUNKNOWNKEY, ret,
+ 						rxkad_abort_resp_nokey);
  		case -EKEYEXPIRED:
- 			abort_code = RXKADEXPIRED;
- 			break;
+ 			return rxrpc_abort_conn(conn, skb, RXKADEXPIRED, ret,
+ 						rxkad_abort_resp_key_expired);
  		default:
- 			abort_code = RXKADNOAUTH;
- 			break;
+ 			return rxrpc_abort_conn(conn, skb, RXKADNOAUTH, ret,
+ 						rxkad_abort_resp_key_rejected);
  		}
++<<<<<<< HEAD
 +		trace_rxrpc_abort(0, "SVK",
 +				  sp->hdr.cid, sp->hdr.callNumber, sp->hdr.seq,
 +				  abort_code, PTR_ERR(server_key));
 +		*_abort_code = abort_code;
 +		return -EPROTO;
++=======
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	}
  
  	ret = -ENOMEM;
@@@ -1160,15 -1089,15 +1140,15 @@@
  	if (!ticket)
  		goto temporary_error_free_resp;
  
- 	eproto = tracepoint_string("rxkad_tkt_short");
- 	abort_code = RXKADPACKETSHORT;
- 	ret = skb_copy_bits(skb, sizeof(struct rxrpc_wire_header) + sizeof(*response),
- 			    ticket, ticket_len);
- 	if (ret < 0)
- 		goto temporary_error_free_ticket;
+ 	if (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header) + sizeof(*response),
+ 			  ticket, ticket_len) < 0) {
+ 		rxrpc_abort_conn(conn, skb, RXKADPACKETSHORT, -EPROTO,
+ 				 rxkad_abort_resp_short_tkt);
+ 		goto protocol_error;
+ 	}
  
  	ret = rxkad_decrypt_ticket(conn, server_key, skb, ticket, ticket_len,
 -				   &session_key, &expiry);
 +				   &session_key, &expiry, _abort_code);
  	if (ret < 0)
  		goto temporary_error_free_ticket;
  
@@@ -1216,17 -1153,19 +1204,23 @@@
  	}
  	spin_unlock(&conn->bundle->channel_lock);
  
- 	eproto = tracepoint_string("rxkad_rsp_seq");
- 	abort_code = RXKADOUTOFSEQUENCE;
- 	if (ntohl(response->encrypted.inc_nonce) != conn->rxkad.nonce + 1)
+ 	if (ntohl(response->encrypted.inc_nonce) != conn->rxkad.nonce + 1) {
+ 		rxrpc_abort_conn(conn, skb, RXKADOUTOFSEQUENCE, -EPROTO,
+ 				 rxkad_abort_resp_ooseq);
  		goto protocol_error_free;
+ 	}
  
- 	eproto = tracepoint_string("rxkad_rsp_level");
- 	abort_code = RXKADLEVELFAIL;
  	level = ntohl(response->encrypted.level);
- 	if (level > RXRPC_SECURITY_ENCRYPT)
+ 	if (level > RXRPC_SECURITY_ENCRYPT) {
+ 		rxrpc_abort_conn(conn, skb, RXKADLEVELFAIL, -EPROTO,
+ 				 rxkad_abort_resp_level);
  		goto protocol_error_free;
++<<<<<<< HEAD
 +	conn->params.security_level = level;
++=======
+ 	}
+ 	conn->security_level = level;
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  
  	/* create a key to hold the security data and expiration time - after
  	 * this the connection security can be handled in exactly the same way
@@@ -1246,9 -1185,7 +1240,13 @@@ protocol_error_free
  	kfree(ticket);
  protocol_error:
  	kfree(response);
++<<<<<<< HEAD
 +	trace_rxrpc_rx_eproto(NULL, sp->hdr.serial, eproto);
 +	key_put(server_key);
 +	*_abort_code = abort_code;
++=======
+ 	key_put(server_key);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  	return -EPROTO;
  
  temporary_error_free_ticket:
diff --cc net/rxrpc/sendmsg.c
index 45c09f0de6fe,d67808b659f1..000000000000
--- a/net/rxrpc/sendmsg.c
+++ b/net/rxrpc/sendmsg.c
@@@ -18,6 -18,27 +18,30 @@@
  #include "ar-internal.h"
  
  /*
++<<<<<<< HEAD
++=======
+  * Propose an abort to be made in the I/O thread.
+  */
+ bool rxrpc_propose_abort(struct rxrpc_call *call, s32 abort_code, int error,
+ 			 enum rxrpc_abort_reason why)
+ {
+ 	_enter("{%d},%d,%d,%u", call->debug_id, abort_code, error, why);
+ 
+ 	if (!call->send_abort && call->state < RXRPC_CALL_COMPLETE) {
+ 		call->send_abort_why = why;
+ 		call->send_abort_err = error;
+ 		call->send_abort_seq = 0;
+ 		/* Request abort locklessly vs rxrpc_input_call_event(). */
+ 		smp_store_release(&call->send_abort, abort_code);
+ 		rxrpc_poke_call(call, rxrpc_call_poke_abort);
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
   * Return true if there's sufficient Tx queue space.
   */
  static bool rxrpc_check_tx_space(struct rxrpc_call *call, rxrpc_seq_t *_tx_win)
@@@ -724,9 -684,9 +748,14 @@@ int rxrpc_do_sendmsg(struct rxrpc_sock 
  		/* it's too late for this call */
  		ret = -ESHUTDOWN;
  	} else if (p.command == RXRPC_CMD_SEND_ABORT) {
++<<<<<<< HEAD
++=======
+ 		rxrpc_propose_abort(call, p.abort_code, -ECONNABORTED,
+ 				    rxrpc_abort_call_sendmsg);
++>>>>>>> 57af281e5389 (rxrpc: Tidy up abort generation infrastructure)
  		ret = 0;
 +		if (rxrpc_abort_call("CMD", call, 0, p.abort_code, -ECONNABORTED))
 +			ret = rxrpc_send_abort_packet(call);
  	} else if (p.command != RXRPC_CMD_SEND_DATA) {
  		ret = -EINVAL;
  	} else {
@@@ -818,14 -780,10 +849,14 @@@ bool rxrpc_kernel_abort_call(struct soc
  {
  	bool aborted;
  
- 	_enter("{%d},%d,%d,%s", call->debug_id, abort_code, error, why);
+ 	_enter("{%d},%d,%d,%u", call->debug_id, abort_code, error, why);
  
  	mutex_lock(&call->user_mutex);
 -	aborted = rxrpc_propose_abort(call, abort_code, error, why);
 +
 +	aborted = rxrpc_abort_call(why, call, 0, abort_code, error);
 +	if (aborted)
 +		rxrpc_send_abort_packet(call);
 +
  	mutex_unlock(&call->user_mutex);
  	return aborted;
  }
* Unmerged path net/rxrpc/io_thread.c
diff --git a/fs/afs/cmservice.c b/fs/afs/cmservice.c
index 0a090d614e76..6fcc09201697 100644
--- a/fs/afs/cmservice.c
+++ b/fs/afs/cmservice.c
@@ -13,6 +13,8 @@
 #include "internal.h"
 #include "afs_cm.h"
 #include "protocol_yfs.h"
+#define RXRPC_TRACE_ONLY_DEFINE_ENUMS
+#include <trace/events/rxrpc.h>
 
 static int afs_deliver_cb_init_call_back_state(struct afs_call *);
 static int afs_deliver_cb_init_call_back_state3(struct afs_call *);
@@ -191,7 +193,7 @@ static void afs_cm_destructor(struct afs_call *call)
  * Abort a service call from within an action function.
  */
 static void afs_abort_service_call(struct afs_call *call, u32 abort_code, int error,
-				   const char *why)
+				   enum rxrpc_abort_reason why)
 {
 	rxrpc_kernel_abort_call(call->net->socket, call->rxcall,
 				abort_code, error, why);
@@ -469,7 +471,7 @@ static void SRXAFSCB_ProbeUuid(struct work_struct *work)
 	if (memcmp(r, &call->net->uuid, sizeof(call->net->uuid)) == 0)
 		afs_send_empty_reply(call);
 	else
-		afs_abort_service_call(call, 1, 1, "K-1");
+		afs_abort_service_call(call, 1, 1, afs_abort_probeuuid_negative);
 
 	afs_put_call(call);
 	_leave("");
diff --git a/fs/afs/rxrpc.c b/fs/afs/rxrpc.c
index eccc3cd0cb70..cfff7f9ccc33 100644
--- a/fs/afs/rxrpc.c
+++ b/fs/afs/rxrpc.c
@@ -13,6 +13,8 @@
 #include "internal.h"
 #include "afs_cm.h"
 #include "protocol_yfs.h"
+#define RXRPC_TRACE_ONLY_DEFINE_ENUMS
+#include <trace/events/rxrpc.h>
 
 struct workqueue_struct *afs_async_calls;
 
@@ -397,7 +399,8 @@ void afs_make_call(struct afs_addr_cursor *ac, struct afs_call *call, gfp_t gfp)
 error_do_abort:
 	if (ret != -ECONNABORTED) {
 		rxrpc_kernel_abort_call(call->net->socket, rxcall,
-					RX_USER_ABORT, ret, "KSD");
+					RX_USER_ABORT, ret,
+					afs_abort_send_data_error);
 	} else {
 		len = 0;
 		iov_iter_kvec(&msg.msg_iter, READ, NULL, 0, 0);
@@ -527,7 +530,8 @@ static void afs_deliver_to_call(struct afs_call *call)
 		case -ENOTSUPP:
 			abort_code = RXGEN_OPCODE;
 			rxrpc_kernel_abort_call(call->net->socket, call->rxcall,
-						abort_code, ret, "KIV");
+						abort_code, ret,
+						afs_abort_op_not_supported);
 			goto local_abort;
 		case -EIO:
 			pr_err("kAFS: Call %u in bad state %u\n",
@@ -542,12 +546,14 @@ static void afs_deliver_to_call(struct afs_call *call)
 			if (state != AFS_CALL_CL_AWAIT_REPLY)
 				abort_code = RXGEN_SS_UNMARSHAL;
 			rxrpc_kernel_abort_call(call->net->socket, call->rxcall,
-						abort_code, ret, "KUM");
+						abort_code, ret,
+						afs_abort_unmarshal_error);
 			goto local_abort;
 		default:
 			abort_code = RX_CALL_DEAD;
 			rxrpc_kernel_abort_call(call->net->socket, call->rxcall,
-						abort_code, ret, "KER");
+						abort_code, ret,
+						afs_abort_general_error);
 			goto local_abort;
 		}
 	}
@@ -619,7 +625,8 @@ long afs_wait_for_call_to_complete(struct afs_call *call,
 			/* Kill off the call if it's still live. */
 			_debug("call interrupted");
 			if (rxrpc_kernel_abort_call(call->net->socket, call->rxcall,
-						    RX_USER_ABORT, -EINTR, "KWI"))
+						    RX_USER_ABORT, -EINTR,
+						    afs_abort_interrupted))
 				afs_set_call_complete(call, -EINTR, 0);
 		}
 	}
@@ -836,7 +843,8 @@ void afs_send_empty_reply(struct afs_call *call)
 	case -ENOMEM:
 		_debug("oom");
 		rxrpc_kernel_abort_call(net->socket, call->rxcall,
-					RXGEN_SS_MARSHAL, -ENOMEM, "KOO");
+					RXGEN_SS_MARSHAL, -ENOMEM,
+					afs_abort_oom);
 		fallthrough;
 	default:
 		_leave(" [error]");
@@ -878,7 +886,8 @@ void afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)
 	if (n == -ENOMEM) {
 		_debug("oom");
 		rxrpc_kernel_abort_call(net->socket, call->rxcall,
-					RXGEN_SS_MARSHAL, -ENOMEM, "KOO");
+					RXGEN_SS_MARSHAL, -ENOMEM,
+					afs_abort_oom);
 	}
 	_leave(" [error]");
 }
diff --git a/include/net/af_rxrpc.h b/include/net/af_rxrpc.h
index dc033f08191e..b54fd2568eda 100644
--- a/include/net/af_rxrpc.h
+++ b/include/net/af_rxrpc.h
@@ -15,6 +15,7 @@ struct key;
 struct sock;
 struct socket;
 struct rxrpc_call;
+enum rxrpc_abort_reason;
 
 enum rxrpc_interruptibility {
 	RXRPC_INTERRUPTIBLE,	/* Call is interruptible */
@@ -55,7 +56,7 @@ int rxrpc_kernel_send_data(struct socket *, struct rxrpc_call *,
 int rxrpc_kernel_recv_data(struct socket *, struct rxrpc_call *,
 			   struct iov_iter *, size_t *, bool, u32 *, u16 *);
 bool rxrpc_kernel_abort_call(struct socket *, struct rxrpc_call *,
-			     u32, int, const char *);
+			     u32, int, enum rxrpc_abort_reason);
 void rxrpc_kernel_end_call(struct socket *, struct rxrpc_call *);
 void rxrpc_kernel_get_peer(struct socket *, struct rxrpc_call *,
 			   struct sockaddr_rxrpc *);
* Unmerged path include/trace/events/rxrpc.h
* Unmerged path net/rxrpc/ar-internal.h
* Unmerged path net/rxrpc/call_accept.c
* Unmerged path net/rxrpc/call_event.c
* Unmerged path net/rxrpc/call_object.c
* Unmerged path net/rxrpc/conn_event.c
* Unmerged path net/rxrpc/input.c
* Unmerged path net/rxrpc/insecure.c
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path net/rxrpc/recvmsg.c
* Unmerged path net/rxrpc/rxkad.c
diff --git a/net/rxrpc/rxperf.c b/net/rxrpc/rxperf.c
index d33a109e846c..16dcabb71ebe 100644
--- a/net/rxrpc/rxperf.c
+++ b/net/rxrpc/rxperf.c
@@ -10,6 +10,8 @@
 #include <linux/slab.h>
 #include <net/sock.h>
 #include <net/af_rxrpc.h>
+#define RXRPC_TRACE_ONLY_DEFINE_ENUMS
+#include <trace/events/rxrpc.h>
 
 MODULE_DESCRIPTION("rxperf test server (afs)");
 MODULE_AUTHOR("Red Hat, Inc.");
@@ -307,12 +309,14 @@ static void rxperf_deliver_to_call(struct work_struct *work)
 		case -EOPNOTSUPP:
 			abort_code = RXGEN_OPCODE;
 			rxrpc_kernel_abort_call(rxperf_socket, call->rxcall,
-						abort_code, ret, "GOP");
+						abort_code, ret,
+						rxperf_abort_op_not_supported);
 			goto call_complete;
 		case -ENOTSUPP:
 			abort_code = RX_USER_ABORT;
 			rxrpc_kernel_abort_call(rxperf_socket, call->rxcall,
-						abort_code, ret, "GUA");
+						abort_code, ret,
+						rxperf_abort_op_not_supported);
 			goto call_complete;
 		case -EIO:
 			pr_err("Call %u in bad state %u\n",
@@ -324,11 +328,13 @@ static void rxperf_deliver_to_call(struct work_struct *work)
 		case -ENOMEM:
 		case -EFAULT:
 			rxrpc_kernel_abort_call(rxperf_socket, call->rxcall,
-						RXGEN_SS_UNMARSHAL, ret, "GUM");
+						RXGEN_SS_UNMARSHAL, ret,
+						rxperf_abort_unmarshal_error);
 			goto call_complete;
 		default:
 			rxrpc_kernel_abort_call(rxperf_socket, call->rxcall,
-						RX_CALL_DEAD, ret, "GER");
+						RX_CALL_DEAD, ret,
+						rxperf_abort_general_error);
 			goto call_complete;
 		}
 	}
@@ -523,7 +529,8 @@ static int rxperf_process_call(struct rxperf_call *call)
 
 	if (n == -ENOMEM)
 		rxrpc_kernel_abort_call(rxperf_socket, call->rxcall,
-					RXGEN_SS_MARSHAL, -ENOMEM, "GOM");
+					RXGEN_SS_MARSHAL, -ENOMEM,
+					rxperf_abort_oom);
 	return n;
 }
 
diff --git a/net/rxrpc/security.c b/net/rxrpc/security.c
index 50cb5f1ee0c0..0e72a31bda34 100644
--- a/net/rxrpc/security.c
+++ b/net/rxrpc/security.c
@@ -114,21 +114,15 @@ const struct rxrpc_security *rxrpc_get_incoming_security(struct rxrpc_sock *rx,
 
 	sec = rxrpc_security_lookup(sp->hdr.securityIndex);
 	if (!sec) {
-		trace_rxrpc_abort(0, "SVS",
-				  sp->hdr.cid, sp->hdr.callNumber, sp->hdr.seq,
-				  RX_INVALID_OPERATION, EKEYREJECTED);
-		skb->mark = RXRPC_SKB_MARK_REJECT_ABORT;
-		skb->priority = RX_INVALID_OPERATION;
+		rxrpc_direct_abort(skb, rxrpc_abort_unsupported_security,
+				   RX_INVALID_OPERATION, -EKEYREJECTED);
 		return NULL;
 	}
 
 	if (sp->hdr.securityIndex != RXRPC_SECURITY_NONE &&
 	    !rx->securities) {
-		trace_rxrpc_abort(0, "SVR",
-				  sp->hdr.cid, sp->hdr.callNumber, sp->hdr.seq,
-				  RX_INVALID_OPERATION, EKEYREJECTED);
-		skb->mark = RXRPC_SKB_MARK_REJECT_ABORT;
-		skb->priority = sec->no_key_abort;
+		rxrpc_direct_abort(skb, rxrpc_abort_no_service_key,
+				   sec->no_key_abort, -EKEYREJECTED);
 		return NULL;
 	}
 
* Unmerged path net/rxrpc/sendmsg.c
