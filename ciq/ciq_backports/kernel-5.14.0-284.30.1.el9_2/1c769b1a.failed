ice: Remove LAG+SRIOV mutual exclusion

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author Dave Ertman <david.m.ertman@intel.com>
commit 1c769b1a303f7a3b447fc7244340b77823bdbfdc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/1c769b1a.failed

There was a change previously to stop SR-IOV and LAG from existing on the
same interface.  This was to prevent the violation of LACP (Link
Aggregation Control Protocol).  The method to achieve this was to add a
no-op Rx handler onto the netdev when SR-IOV VFs were present, thus
blocking bonding, bridging, etc from claiming the interface by adding
its own Rx handler.  Also, when an interface was added into a aggregate,
then the SR-IOV capability was set to false.

There are some users that have in house solutions using both SR-IOV and
bridging/bonding that this method interferes with (e.g. creating duplicate
VFs on the bonded interfaces and failing between them when the interface
fails over).

It makes more sense to provide the most functionality
possible, the restriction on co-existence of these features will be
removed.  No additional functionality is currently being provided beyond
what existed before the co-existence restriction was put into place.  It is
up to the end user to not implement a solution that would interfere with
existing network protocols.

	Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
	Signed-off-by: Wojciech Drewek <wojciech.drewek@intel.com>
	Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 1c769b1a303f7a3b447fc7244340b77823bdbfdc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lag.h
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_sriov.c
diff --cc drivers/net/ethernet/intel/ice/ice_lag.h
index c2e3688dd8fd,2c373676c42f..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lag.h
+++ b/drivers/net/ethernet/intel/ice/ice_lag.h
@@@ -24,12 -24,7 +24,16 @@@ struct ice_lag 
  	struct net_device *upper_netdev; /* upper bonding netdev */
  	struct notifier_block notif_block;
  	u8 bonded:1; /* currently bonded */
++<<<<<<< HEAD
 +	u8 master:1; /* this is a master */
 +	u8 handler:1; /* did we register a rx_netdev_handler */
 +	/* each thing blocking bonding will increment this value by one.
 +	 * If this value is zero, then bonding is allowed.
 +	 */
 +	u16 dis_lag;
++=======
+ 	u8 primary:1; /* this is primary */
++>>>>>>> 1c769b1a303f (ice: Remove LAG+SRIOV mutual exclusion)
  	u8 role;
  };
  
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 58d483e2f539,3de9556b89ac..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -2633,24 -2703,11 +2633,29 @@@ ice_vsi_setup(struct ice_pf *pf, struc
  
  	if (!vsi->agg_node)
  		ice_set_agg_vsi(vsi);
 -
  	return vsi;
  
++<<<<<<< HEAD
 +unroll_clear_rings:
 +	ice_vsi_clear_rings(vsi);
 +unroll_vector_base:
 +	/* reclaim SW interrupts back to the common pool */
 +	ice_free_res(pf->irq_tracker, vsi->base_vector, vsi->idx);
 +	pf->num_avail_sw_msix += vsi->num_q_vectors;
 +unroll_alloc_q_vector:
 +	ice_vsi_free_q_vectors(vsi);
 +unroll_vsi_init:
 +	ice_vsi_delete(vsi);
 +unroll_get_qs:
 +	ice_vsi_put_qs(vsi);
 +unroll_vsi_alloc:
 +	if (vsi_type == ICE_VSI_VF)
 +		ice_enable_lag(pf->lag);
 +	ice_vsi_clear(vsi);
++=======
+ err_vsi_cfg:
+ 	ice_vsi_free(vsi);
++>>>>>>> 1c769b1a303f (ice: Remove LAG+SRIOV mutual exclusion)
  
  	return NULL;
  }
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.c
index f4907a3c2d19,a7e7debb1428..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.c
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.c
@@@ -1060,9 -979,6 +1060,12 @@@ int ice_sriov_configure(struct pci_dev 
  	if (!num_vfs) {
  		if (!pci_vfs_assigned(pdev)) {
  			ice_free_vfs(pf);
++<<<<<<< HEAD
 +			ice_mbx_deinit_snapshot(&pf->hw);
 +			if (pf->lag)
 +				ice_enable_lag(pf->lag);
++=======
++>>>>>>> 1c769b1a303f (ice: Remove LAG+SRIOV mutual exclusion)
  			return 0;
  		}
  
@@@ -1074,14 -990,6 +1077,17 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = ice_pci_sriov_ena(pf, num_vfs);
 +	if (err) {
 +		ice_mbx_deinit_snapshot(&pf->hw);
 +		return err;
 +	}
 +
 +	if (pf->lag)
 +		ice_disable_lag(pf->lag);
++=======
++>>>>>>> 1c769b1a303f (ice: Remove LAG+SRIOV mutual exclusion)
  	return num_vfs;
  }
  
diff --git a/Documentation/networking/device_drivers/ethernet/intel/ice.rst b/Documentation/networking/device_drivers/ethernet/intel/ice.rst
index b56b3653af13..6af579037d87 100644
--- a/Documentation/networking/device_drivers/ethernet/intel/ice.rst
+++ b/Documentation/networking/device_drivers/ethernet/intel/ice.rst
@@ -84,24 +84,6 @@ Once the VM shuts down, or otherwise releases the VF, the command will
 complete.
 
 
-Important notes for SR-IOV and Link Aggregation
------------------------------------------------
-Link Aggregation is mutually exclusive with SR-IOV.
-
-- If Link Aggregation is active, SR-IOV VFs cannot be created on the PF.
-- If SR-IOV is active, you cannot set up Link Aggregation on the interface.
-
-Bridging and MACVLAN are also affected by this. If you wish to use bridging or
-MACVLAN with SR-IOV, you must set up bridging or MACVLAN before enabling
-SR-IOV. If you are using bridging or MACVLAN in conjunction with SR-IOV, and
-you want to remove the interface from the bridge or MACVLAN, you must follow
-these steps:
-
-1. Destroy SR-IOV VFs if they exist
-2. Remove the interface from the bridge or MACVLAN
-3. Recreate SRIOV VFs as needed
-
-
 Additional Features and Configurations
 ======================================
 
diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index c6f76873a5d7..98b8d05e3986 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -797,25 +797,6 @@ static inline bool ice_is_switchdev_running(struct ice_pf *pf)
 	return pf->switchdev.is_running;
 }
 
-/**
- * ice_set_sriov_cap - enable SRIOV in PF flags
- * @pf: PF struct
- */
-static inline void ice_set_sriov_cap(struct ice_pf *pf)
-{
-	if (pf->hw.func_caps.common_cap.sr_iov_1_1)
-		set_bit(ICE_FLAG_SRIOV_CAPABLE, pf->flags);
-}
-
-/**
- * ice_clear_sriov_cap - disable SRIOV in PF flags
- * @pf: PF struct
- */
-static inline void ice_clear_sriov_cap(struct ice_pf *pf)
-{
-	clear_bit(ICE_FLAG_SRIOV_CAPABLE, pf->flags);
-}
-
 #define ICE_FD_STAT_CTR_BLOCK_COUNT	256
 #define ICE_FD_STAT_PF_IDX(base_idx) \
 			((base_idx) * ICE_FD_STAT_CTR_BLOCK_COUNT)
diff --git a/drivers/net/ethernet/intel/ice/ice_lag.c b/drivers/net/ethernet/intel/ice/ice_lag.c
index c9f7393b783d..8df94ab47433 100644
--- a/drivers/net/ethernet/intel/ice/ice_lag.c
+++ b/drivers/net/ethernet/intel/ice/ice_lag.c
@@ -6,15 +6,6 @@
 #include "ice.h"
 #include "ice_lag.h"
 
-/**
- * ice_lag_nop_handler - no-op Rx handler to disable LAG
- * @pskb: pointer to skb pointer
- */
-rx_handler_result_t ice_lag_nop_handler(struct sk_buff __always_unused **pskb)
-{
-	return RX_HANDLER_PASS;
-}
-
 /**
  * ice_lag_set_primary - set PF LAG state as Primary
  * @lag: LAG info struct
@@ -158,7 +149,6 @@ ice_lag_link(struct ice_lag *lag, struct netdev_notifier_changeupper_info *info)
 		lag->upper_netdev = upper;
 	}
 
-	ice_clear_sriov_cap(pf);
 	ice_clear_rdma_cap(pf);
 
 	lag->bonded = true;
@@ -205,7 +195,6 @@ ice_lag_unlink(struct ice_lag *lag,
 	}
 
 	lag->peer_netdev = NULL;
-	ice_set_sriov_cap(pf);
 	ice_set_rdma_cap(pf);
 	lag->bonded = false;
 	lag->role = ICE_LAG_NONE;
@@ -229,7 +218,6 @@ static void ice_lag_unregister(struct ice_lag *lag, struct net_device *netdev)
 	if (lag->upper_netdev) {
 		dev_put(lag->upper_netdev);
 		lag->upper_netdev = NULL;
-		ice_set_sriov_cap(pf);
 		ice_set_rdma_cap(pf);
 	}
 	/* perform some cleanup in case we come back */
* Unmerged path drivers/net/ethernet/intel/ice/ice_lag.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.c
