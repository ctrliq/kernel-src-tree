KVM: x86/mmu: Move TDP MMU VM init/uninit behind tdp_mmu_enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Matlack <dmatlack@google.com>
commit 991c8047b740f192a057d5f22df2f91f087cdb72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/991c8047.failed

Move kvm_mmu_{init,uninit}_tdp_mmu() behind tdp_mmu_enabled. This makes
these functions consistent with the rest of the calls into the TDP MMU
from mmu.c, and which is now possible since tdp_mmu_enabled is only
modified when the x86 vendor module is loaded. i.e. It will never change
during the lifetime of a VM.

This change also enabled removing the stub definitions for 32-bit KVM,
as the compiler will just optimize the calls out like it does for all
the other TDP MMU functions.

No functional change intended.

	Signed-off-by: David Matlack <dmatlack@google.com>
	Reviewed-by: Isaku Yamahata <isaku.yamahata@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20220921173546.2674386-3-dmatlack@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 991c8047b740f192a057d5f22df2f91f087cdb72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
#	arch/x86/kvm/mmu/tdp_mmu.h
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index bf2ccf9debca,7e5952e95d3b..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -18,9 -15,6 +18,12 @@@ int kvm_mmu_init_tdp_mmu(struct kvm *kv
  {
  	struct workqueue_struct *wq;
  
++<<<<<<< HEAD
 +	if (!tdp_enabled || !READ_ONCE(tdp_mmu_enabled))
 +		return 0;
 +
++=======
++>>>>>>> 991c8047b740 (KVM: x86/mmu: Move TDP MMU VM init/uninit behind tdp_mmu_enabled)
  	wq = alloc_workqueue("kvm", WQ_UNBOUND|WQ_MEM_RECLAIM|WQ_CPU_INTENSIVE, 0);
  	if (!wq)
  		return -ENOMEM;
@@@ -48,9 -39,6 +51,12 @@@ static __always_inline bool kvm_lockdep
  
  void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm)
  {
++<<<<<<< HEAD
 +	if (!kvm->arch.tdp_mmu_enabled)
 +		return;
 +
++=======
++>>>>>>> 991c8047b740 (KVM: x86/mmu: Move TDP MMU VM init/uninit behind tdp_mmu_enabled)
  	/* Also waits for any queued work items.  */
  	destroy_workqueue(kvm->arch.tdp_mmu_zap_wq);
  
diff --cc arch/x86/kvm/mmu/tdp_mmu.h
index c163f7cc23ca,e4ab2dac269d..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.h
+++ b/arch/x86/kvm/mmu/tdp_mmu.h
@@@ -5,6 -5,11 +5,14 @@@
  
  #include <linux/kvm_host.h>
  
++<<<<<<< HEAD
++=======
+ #include "spte.h"
+ 
+ int kvm_mmu_init_tdp_mmu(struct kvm *kvm);
+ void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm);
+ 
++>>>>>>> 991c8047b740 (KVM: x86/mmu: Move TDP MMU VM init/uninit behind tdp_mmu_enabled)
  hpa_t kvm_tdp_mmu_get_vcpu_root_hpa(struct kvm_vcpu *vcpu);
  
  __must_check static inline bool kvm_tdp_mmu_get_root(struct kvm_mmu_page *root)
diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index 45e102be9788..8b3ebc68dc8b 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -5964,9 +5964,11 @@ int kvm_mmu_init_vm(struct kvm *kvm)
 	INIT_LIST_HEAD(&kvm->arch.lpage_disallowed_mmu_pages);
 	spin_lock_init(&kvm->arch.mmu_unsync_pages_lock);
 
-	r = kvm_mmu_init_tdp_mmu(kvm);
-	if (r < 0)
-		return r;
+	if (tdp_mmu_enabled) {
+		r = kvm_mmu_init_tdp_mmu(kvm);
+		if (r < 0)
+			return r;
+	}
 
 	node->track_write = kvm_mmu_pte_write;
 	node->track_flush_slot = kvm_mmu_invalidate_zap_pages_in_memslot;
@@ -5996,7 +5998,8 @@ void kvm_mmu_uninit_vm(struct kvm *kvm)
 
 	kvm_page_track_unregister_notifier(kvm, node);
 
-	kvm_mmu_uninit_tdp_mmu(kvm);
+	if (tdp_mmu_enabled)
+		kvm_mmu_uninit_tdp_mmu(kvm);
 
 	mmu_free_vm_memory_caches(kvm);
 }
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.h
