hugetlbfs: don't delete error page from pagecache

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author James Houghton <jthoughton@google.com>
commit 8625147cafaa9ba74713d682f5185eb62cb2aedb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/8625147c.failed

This change is very similar to the change that was made for shmem [1], and
it solves the same problem but for HugeTLBFS instead.

Currently, when poison is found in a HugeTLB page, the page is removed
from the page cache.  That means that attempting to map or read that
hugepage in the future will result in a new hugepage being allocated
instead of notifying the user that the page was poisoned.  As [1] states,
this is effectively memory corruption.

The fix is to leave the page in the page cache.  If the user attempts to
use a poisoned HugeTLB page with a syscall, the syscall will fail with
EIO, the same error code that shmem uses.  For attempts to map the page,
the thread will get a BUS_MCEERR_AR SIGBUS.

[1]: commit a76054266661 ("mm: shmem: don't truncate page if memory failure happens")

Link: https://lkml.kernel.org/r/20221018200125.848471-1-jthoughton@google.com
	Signed-off-by: James Houghton <jthoughton@google.com>
	Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
	Reviewed-by: Naoya Horiguchi <naoya.horiguchi@nec.com>
	Tested-by: Naoya Horiguchi <naoya.horiguchi@nec.com>
	Reviewed-by: Yang Shi <shy828301@gmail.com>
	Cc: Axel Rasmussen <axelrasmussen@google.com>
	Cc: James Houghton <jthoughton@google.com>
	Cc: Miaohe Lin <linmiaohe@huawei.com>
	Cc: Muchun Song <songmuchun@bytedance.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 8625147cafaa9ba74713d682f5185eb62cb2aedb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/hugetlbfs/inode.c
diff --cc fs/hugetlbfs/inode.c
index 8df63c4292ac,df7772335dc0..000000000000
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@@ -992,13 -1117,6 +998,16 @@@ static int hugetlbfs_migrate_page(struc
  static int hugetlbfs_error_remove_page(struct address_space *mapping,
  				struct page *page)
  {
++<<<<<<< HEAD
 +	struct inode *inode = mapping->host;
 +	pgoff_t index = page->index;
 +
 +	remove_huge_page(page);
 +	if (unlikely(hugetlb_unreserve_pages(inode, index, index + 1, 1)))
 +		hugetlb_fix_reserve_counts(inode);
 +
++=======
++>>>>>>> 8625147cafaa (hugetlbfs: don't delete error page from pagecache)
  	return 0;
  }
  
* Unmerged path fs/hugetlbfs/inode.c
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index ee6cf9943b86..71807a734b3c 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -6013,6 +6013,10 @@ int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
 	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
 	spin_lock(ptl);
 
+	ret = -EIO;
+	if (PageHWPoison(page))
+		goto out_release_unlock;
+
 	/*
 	 * Recheck the i_size after holding PT lock to make sure not
 	 * to leave any page mapped (as page_mapped()) beyond the end
diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index b3ab957ca0d3..6fb5a8213941 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -1033,6 +1033,7 @@ static int me_huge_page(struct page_state *ps, struct page *p)
 	int res;
 	struct page *hpage = compound_head(p);
 	struct address_space *mapping;
+	bool extra_pins = false;
 
 	if (!PageHuge(hpage))
 		return MF_DELAYED;
@@ -1040,6 +1041,8 @@ static int me_huge_page(struct page_state *ps, struct page *p)
 	mapping = page_mapping(hpage);
 	if (mapping) {
 		res = truncate_error_page(hpage, page_to_pfn(p), mapping);
+		/* The page is kept in page cache. */
+		extra_pins = true;
 		unlock_page(hpage);
 	} else {
 		res = MF_FAILED;
@@ -1057,7 +1060,7 @@ static int me_huge_page(struct page_state *ps, struct page *p)
 		}
 	}
 
-	if (has_extra_refcount(ps, p, false))
+	if (has_extra_refcount(ps, p, extra_pins))
 		res = MF_FAILED;
 
 	return res;
