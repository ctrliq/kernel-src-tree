rxrpc: Fix a couple of potential use-after-frees

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 0e50d999903c009b6a9cd2277c82d6798d982e31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/0e50d999.failed

At the end of rxrpc_recvmsg(), if a call is found, the call is put and then
a trace line is emitted referencing that call in a couple of places - but
the call may have been deallocated by the time those traces happen.

Fix this by stashing the call debug_id in a variable and passing that to
the tracepoint rather than the call pointer.

Fixes: 849979051cbc ("rxrpc: Add a tracepoint to follow what recvmsg does")
	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e50d999903c009b6a9cd2277c82d6798d982e31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rxrpc/recvmsg.c
diff --cc net/rxrpc/recvmsg.c
index c84d2b620396,6ebd6440a2b7..000000000000
--- a/net/rxrpc/recvmsg.c
+++ b/net/rxrpc/recvmsg.c
@@@ -452,9 -449,10 +453,10 @@@ try_again
  		list_del_init(&call->recvmsg_link);
  	else
  		rxrpc_get_call(call, rxrpc_call_get_recvmsg);
 -	write_unlock(&rx->recvmsg_lock);
 +	write_unlock_bh(&rx->recvmsg_lock);
  
- 	trace_rxrpc_recvmsg(call, rxrpc_recvmsg_dequeue, 0);
+ 	call_debug_id = call->debug_id;
+ 	trace_rxrpc_recvmsg(call_debug_id, rxrpc_recvmsg_dequeue, 0);
  
  	/* We're going to drop the socket lock, so we need to lock the call
  	 * against interference by sendmsg.
@@@ -543,10 -538,10 +545,15 @@@ error_unlock_call
  
  error_requeue_call:
  	if (!(flags & MSG_PEEK)) {
 -		write_lock(&rx->recvmsg_lock);
 +		write_lock_bh(&rx->recvmsg_lock);
  		list_add(&call->recvmsg_link, &rx->recvmsg_q);
++<<<<<<< HEAD
 +		write_unlock_bh(&rx->recvmsg_lock);
 +		trace_rxrpc_recvmsg(call, rxrpc_recvmsg_requeue, 0);
++=======
+ 		write_unlock(&rx->recvmsg_lock);
+ 		trace_rxrpc_recvmsg(call_debug_id, rxrpc_recvmsg_requeue, 0);
++>>>>>>> 0e50d999903c (rxrpc: Fix a couple of potential use-after-frees)
  	} else {
  		rxrpc_put_call(call, rxrpc_call_put_recvmsg);
  	}
diff --git a/include/trace/events/rxrpc.h b/include/trace/events/rxrpc.h
index 2a52121d73a0..467bbd2c2def 100644
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@ -972,10 +972,10 @@ TRACE_EVENT(rxrpc_receive,
 	    );
 
 TRACE_EVENT(rxrpc_recvmsg,
-	    TP_PROTO(struct rxrpc_call *call, enum rxrpc_recvmsg_trace why,
+	    TP_PROTO(unsigned int call_debug_id, enum rxrpc_recvmsg_trace why,
 		     int ret),
 
-	    TP_ARGS(call, why, ret),
+	    TP_ARGS(call_debug_id, why, ret),
 
 	    TP_STRUCT__entry(
 		    __field(unsigned int,		call		)
@@ -984,7 +984,7 @@ TRACE_EVENT(rxrpc_recvmsg,
 			     ),
 
 	    TP_fast_assign(
-		    __entry->call = call ? call->debug_id : 0;
+		    __entry->call = call_debug_id;
 		    __entry->why = why;
 		    __entry->ret = ret;
 			   ),
* Unmerged path net/rxrpc/recvmsg.c
