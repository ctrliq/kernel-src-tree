KEYS: use kfree_sensitive with key

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author Mahmoud Adam <mngyadam@amazon.com>
commit 9f3fa6bc4ff8515da1349c44a77e7327bd2f4788
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/9f3fa6bc.failed

key might contain private part of the key, so better use
kfree_sensitive to free it

	Signed-off-by: Mahmoud Adam <mngyadam@amazon.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 9f3fa6bc4ff8515da1349c44a77e7327bd2f4788)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/public_key.c
diff --cc crypto/asymmetric_keys/public_key.c
index 4fefb219bfdc,abeecb8329b3..000000000000
--- a/crypto/asymmetric_keys/public_key.c
+++ b/crypto/asymmetric_keys/public_key.c
@@@ -134,30 -183,87 +134,34 @@@ static int software_key_query(const str
  	ptr = pkey_pack_u32(ptr, pkey->paramlen);
  	memcpy(ptr, pkey->params, pkey->paramlen);
  
 -	if (issig) {
 -		sig = crypto_alloc_sig(alg_name, 0, 0);
 -		if (IS_ERR(sig)) {
 -			ret = PTR_ERR(sig);
 -			goto error_free_key;
 -		}
 -
 -		if (pkey->key_is_private)
 -			ret = crypto_sig_set_privkey(sig, key, pkey->keylen);
 -		else
 -			ret = crypto_sig_set_pubkey(sig, key, pkey->keylen);
 -		if (ret < 0)
 -			goto error_free_tfm;
 -
 -		len = crypto_sig_maxsize(sig);
 -
 -		info->supported_ops = KEYCTL_SUPPORTS_VERIFY;
 -		if (pkey->key_is_private)
 -			info->supported_ops |= KEYCTL_SUPPORTS_SIGN;
 -
 -		if (strcmp(params->encoding, "pkcs1") == 0) {
 -			info->supported_ops |= KEYCTL_SUPPORTS_ENCRYPT;
 -			if (pkey->key_is_private)
 -				info->supported_ops |= KEYCTL_SUPPORTS_DECRYPT;
 -		}
 -	} else {
 -		tfm = crypto_alloc_akcipher(alg_name, 0, 0);
 -		if (IS_ERR(tfm)) {
 -			ret = PTR_ERR(tfm);
 -			goto error_free_key;
 -		}
 -
 -		if (pkey->key_is_private)
 -			ret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);
 -		else
 -			ret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);
 -		if (ret < 0)
 -			goto error_free_tfm;
 -
 -		len = crypto_akcipher_maxsize(tfm);
 -
 -		info->supported_ops = KEYCTL_SUPPORTS_ENCRYPT;
 -		if (pkey->key_is_private)
 -			info->supported_ops |= KEYCTL_SUPPORTS_DECRYPT;
 -	}
 +	if (pkey->key_is_private)
 +		ret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);
 +	else
 +		ret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);
 +	if (ret < 0)
 +		goto error_free_key;
  
 +	len = crypto_akcipher_maxsize(tfm);
  	info->key_size = len * 8;
 -
 -	if (strncmp(pkey->pkey_algo, "ecdsa", 5) == 0) {
 -		/*
 -		 * ECDSA key sizes are much smaller than RSA, and thus could
 -		 * operate on (hashed) inputs that are larger than key size.
 -		 * For example SHA384-hashed input used with secp256r1
 -		 * based keys.  Set max_data_size to be at least as large as
 -		 * the largest supported hash size (SHA512)
 -		 */
 -		info->max_data_size = 64;
 -
 -		/*
 -		 * Verify takes ECDSA-Sig (described in RFC 5480) as input,
 -		 * which is actually 2 'key_size'-bit integers encoded in
 -		 * ASN.1.  Account for the ASN.1 encoding overhead here.
 -		 */
 -		info->max_sig_size = 2 * (len + 3) + 2;
 -	} else {
 -		info->max_data_size = len;
 -		info->max_sig_size = len;
 -	}
 -
 +	info->max_data_size = len;
 +	info->max_sig_size = len;
  	info->max_enc_size = len;
  	info->max_dec_size = len;
 -
 +	info->supported_ops = (KEYCTL_SUPPORTS_ENCRYPT |
 +			       KEYCTL_SUPPORTS_VERIFY);
 +	if (pkey->key_is_private)
 +		info->supported_ops |= (KEYCTL_SUPPORTS_DECRYPT |
 +					KEYCTL_SUPPORTS_SIGN);
  	ret = 0;
  
 -error_free_tfm:
 -	if (issig)
 -		crypto_free_sig(sig);
 -	else
 -		crypto_free_akcipher(tfm);
  error_free_key:
++<<<<<<< HEAD
 +	kfree(key);
 +error_free_tfm:
 +	crypto_free_akcipher(tfm);
++=======
+ 	kfree_sensitive(key);
++>>>>>>> 9f3fa6bc4ff8 (KEYS: use kfree_sensitive with key)
  	pr_devel("<==%s() = %d\n", __func__, ret);
  	return ret;
  }
@@@ -197,7 -294,135 +201,139 @@@ static int software_key_eds_op(struct k
  	key = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,
  		      GFP_KERNEL);
  	if (!key)
++<<<<<<< HEAD
 +		goto error_free_req;
++=======
+ 		return -ENOMEM;
+ 
+ 	memcpy(key, pkey->key, pkey->keylen);
+ 	ptr = key + pkey->keylen;
+ 	ptr = pkey_pack_u32(ptr, pkey->algo);
+ 	ptr = pkey_pack_u32(ptr, pkey->paramlen);
+ 	memcpy(ptr, pkey->params, pkey->paramlen);
+ 
+ 	if (issig) {
+ 		sig = crypto_alloc_sig(alg_name, 0, 0);
+ 		if (IS_ERR(sig)) {
+ 			ret = PTR_ERR(sig);
+ 			goto error_free_key;
+ 		}
+ 
+ 		if (pkey->key_is_private)
+ 			ret = crypto_sig_set_privkey(sig, key, pkey->keylen);
+ 		else
+ 			ret = crypto_sig_set_pubkey(sig, key, pkey->keylen);
+ 		if (ret)
+ 			goto error_free_tfm;
+ 
+ 		ksz = crypto_sig_maxsize(sig);
+ 	} else {
+ 		tfm = crypto_alloc_akcipher(alg_name, 0, 0);
+ 		if (IS_ERR(tfm)) {
+ 			ret = PTR_ERR(tfm);
+ 			goto error_free_key;
+ 		}
+ 
+ 		if (pkey->key_is_private)
+ 			ret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);
+ 		else
+ 			ret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);
+ 		if (ret)
+ 			goto error_free_tfm;
+ 
+ 		ksz = crypto_akcipher_maxsize(tfm);
+ 	}
+ 
+ 	ret = -EINVAL;
+ 
+ 	/* Perform the encryption calculation. */
+ 	switch (params->op) {
+ 	case kernel_pkey_encrypt:
+ 		if (issig)
+ 			break;
+ 		ret = crypto_akcipher_sync_encrypt(tfm, in, params->in_len,
+ 						   out, params->out_len);
+ 		break;
+ 	case kernel_pkey_decrypt:
+ 		if (issig)
+ 			break;
+ 		ret = crypto_akcipher_sync_decrypt(tfm, in, params->in_len,
+ 						   out, params->out_len);
+ 		break;
+ 	case kernel_pkey_sign:
+ 		if (!issig)
+ 			break;
+ 		ret = crypto_sig_sign(sig, in, params->in_len,
+ 				      out, params->out_len);
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	if (ret == 0)
+ 		ret = ksz;
+ 
+ error_free_tfm:
+ 	if (issig)
+ 		crypto_free_sig(sig);
+ 	else
+ 		crypto_free_akcipher(tfm);
+ error_free_key:
+ 	kfree_sensitive(key);
+ 	pr_devel("<==%s() = %d\n", __func__, ret);
+ 	return ret;
+ }
+ 
+ /*
+  * Verify a signature using a public key.
+  */
+ int public_key_verify_signature(const struct public_key *pkey,
+ 				const struct public_key_signature *sig)
+ {
+ 	char alg_name[CRYPTO_MAX_ALG_NAME];
+ 	struct crypto_sig *tfm;
+ 	char *key, *ptr;
+ 	bool issig;
+ 	int ret;
+ 
+ 	pr_devel("==>%s()\n", __func__);
+ 
+ 	BUG_ON(!pkey);
+ 	BUG_ON(!sig);
+ 	BUG_ON(!sig->s);
+ 
+ 	/*
+ 	 * If the signature specifies a public key algorithm, it *must* match
+ 	 * the key's actual public key algorithm.
+ 	 *
+ 	 * Small exception: ECDSA signatures don't specify the curve, but ECDSA
+ 	 * keys do.  So the strings can mismatch slightly in that case:
+ 	 * "ecdsa-nist-*" for the key, but "ecdsa" for the signature.
+ 	 */
+ 	if (sig->pkey_algo) {
+ 		if (strcmp(pkey->pkey_algo, sig->pkey_algo) != 0 &&
+ 		    (strncmp(pkey->pkey_algo, "ecdsa-", 6) != 0 ||
+ 		     strcmp(sig->pkey_algo, "ecdsa") != 0))
+ 			return -EKEYREJECTED;
+ 	}
+ 
+ 	ret = software_key_determine_akcipher(pkey, sig->encoding,
+ 					      sig->hash_algo, alg_name,
+ 					      &issig, kernel_pkey_verify);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	tfm = crypto_alloc_sig(alg_name, 0, 0);
+ 	if (IS_ERR(tfm))
+ 		return PTR_ERR(tfm);
+ 
+ 	key = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,
+ 		      GFP_KERNEL);
+ 	if (!key) {
+ 		ret = -ENOMEM;
+ 		goto error_free_tfm;
+ 	}
++>>>>>>> 9f3fa6bc4ff8 (KEYS: use kfree_sensitive with key)
  
  	memcpy(key, pkey->key, pkey->keylen);
  	ptr = key + pkey->keylen;
@@@ -212,176 -437,13 +348,180 @@@
  	if (ret)
  		goto error_free_key;
  
 -	ret = crypto_sig_verify(tfm, sig->s, sig->s_size,
 -				sig->digest, sig->digest_size);
 +	sg_init_one(&in_sg, in, params->in_len);
 +	sg_init_one(&out_sg, out, params->out_len);
 +	akcipher_request_set_crypt(req, &in_sg, &out_sg, params->in_len,
 +				   params->out_len);
 +	crypto_init_wait(&cwait);
 +	akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |
 +				      CRYPTO_TFM_REQ_MAY_SLEEP,
 +				      crypto_req_done, &cwait);
 +
 +	/* Perform the encryption calculation. */
 +	switch (params->op) {
 +	case kernel_pkey_encrypt:
 +		ret = crypto_akcipher_encrypt(req);
 +		break;
 +	case kernel_pkey_decrypt:
 +		ret = crypto_akcipher_decrypt(req);
 +		break;
 +	case kernel_pkey_sign:
 +		ret = crypto_akcipher_sign(req);
 +		break;
 +	default:
 +		BUG();
 +	}
 +
 +	ret = crypto_wait_req(ret, &cwait);
 +	if (ret == 0)
 +		ret = req->dst_len;
  
  error_free_key:
++<<<<<<< HEAD
 +	kfree(key);
 +error_free_req:
 +	akcipher_request_free(req);
++=======
+ 	kfree_sensitive(key);
++>>>>>>> 9f3fa6bc4ff8 (KEYS: use kfree_sensitive with key)
 +error_free_tfm:
 +	crypto_free_akcipher(tfm);
 +	pr_devel("<==%s() = %d\n", __func__, ret);
 +	return ret;
 +}
 +
 +#if IS_REACHABLE(CONFIG_CRYPTO_SM2)
 +static int cert_sig_digest_update(const struct public_key_signature *sig,
 +				  struct crypto_akcipher *tfm_pkey)
 +{
 +	struct crypto_shash *tfm;
 +	struct shash_desc *desc;
 +	size_t desc_size;
 +	unsigned char dgst[SM3_DIGEST_SIZE];
 +	int ret;
 +
 +	BUG_ON(!sig->data);
 +
 +	ret = sm2_compute_z_digest(tfm_pkey, SM2_DEFAULT_USERID,
 +					SM2_DEFAULT_USERID_LEN, dgst);
 +	if (ret)
 +		return ret;
 +
 +	tfm = crypto_alloc_shash(sig->hash_algo, 0, 0);
 +	if (IS_ERR(tfm))
 +		return PTR_ERR(tfm);
 +
 +	desc_size = crypto_shash_descsize(tfm) + sizeof(*desc);
 +	desc = kzalloc(desc_size, GFP_KERNEL);
 +	if (!desc) {
 +		ret = -ENOMEM;
 +		goto error_free_tfm;
 +	}
 +
 +	desc->tfm = tfm;
 +
 +	ret = crypto_shash_init(desc);
 +	if (ret < 0)
 +		goto error_free_desc;
 +
 +	ret = crypto_shash_update(desc, dgst, SM3_DIGEST_SIZE);
 +	if (ret < 0)
 +		goto error_free_desc;
 +
 +	ret = crypto_shash_finup(desc, sig->data, sig->data_size, sig->digest);
 +
 +error_free_desc:
 +	kfree(desc);
 +error_free_tfm:
 +	crypto_free_shash(tfm);
 +	return ret;
 +}
 +#else
 +static inline int cert_sig_digest_update(
 +	const struct public_key_signature *sig,
 +	struct crypto_akcipher *tfm_pkey)
 +{
 +	return -ENOTSUPP;
 +}
 +#endif /* ! IS_REACHABLE(CONFIG_CRYPTO_SM2) */
 +
 +/*
 + * Verify a signature using a public key.
 + */
 +int public_key_verify_signature(const struct public_key *pkey,
 +				const struct public_key_signature *sig)
 +{
 +	struct crypto_wait cwait;
 +	struct crypto_akcipher *tfm;
 +	struct akcipher_request *req;
 +	struct scatterlist src_sg[2];
 +	char alg_name[CRYPTO_MAX_ALG_NAME];
 +	char *key, *ptr;
 +	int ret;
 +
 +	pr_devel("==>%s()\n", __func__);
 +
 +	BUG_ON(!pkey);
 +	BUG_ON(!sig);
 +	BUG_ON(!sig->s);
 +
 +	ret = software_key_determine_akcipher(sig->encoding,
 +					      sig->hash_algo,
 +					      pkey, alg_name);
 +	if (ret < 0)
 +		return ret;
 +
 +	tfm = crypto_alloc_akcipher(alg_name, 0, 0);
 +	if (IS_ERR(tfm))
 +		return PTR_ERR(tfm);
 +
 +	ret = -ENOMEM;
 +	req = akcipher_request_alloc(tfm, GFP_KERNEL);
 +	if (!req)
 +		goto error_free_tfm;
 +
 +	key = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,
 +		      GFP_KERNEL);
 +	if (!key)
 +		goto error_free_req;
 +
 +	memcpy(key, pkey->key, pkey->keylen);
 +	ptr = key + pkey->keylen;
 +	ptr = pkey_pack_u32(ptr, pkey->algo);
 +	ptr = pkey_pack_u32(ptr, pkey->paramlen);
 +	memcpy(ptr, pkey->params, pkey->paramlen);
 +
 +	if (pkey->key_is_private)
 +		ret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);
 +	else
 +		ret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);
 +	if (ret)
 +		goto error_free_key;
 +
 +	if (sig->pkey_algo && strcmp(sig->pkey_algo, "sm2") == 0 &&
 +	    sig->data_size) {
 +		ret = cert_sig_digest_update(sig, tfm);
 +		if (ret)
 +			goto error_free_key;
 +	}
 +
 +	sg_init_table(src_sg, 2);
 +	sg_set_buf(&src_sg[0], sig->s, sig->s_size);
 +	sg_set_buf(&src_sg[1], sig->digest, sig->digest_size);
 +	akcipher_request_set_crypt(req, src_sg, NULL, sig->s_size,
 +				   sig->digest_size);
 +	crypto_init_wait(&cwait);
 +	akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |
 +				      CRYPTO_TFM_REQ_MAY_SLEEP,
 +				      crypto_req_done, &cwait);
 +	ret = crypto_wait_req(crypto_akcipher_verify(req), &cwait);
 +
 +error_free_key:
 +	kfree(key);
 +error_free_req:
 +	akcipher_request_free(req);
  error_free_tfm:
 -	crypto_free_sig(tfm);
 +	crypto_free_akcipher(tfm);
  	pr_devel("<==%s() = %d\n", __func__, ret);
  	if (WARN_ON_ONCE(ret > 0))
  		ret = -EINVAL;
* Unmerged path crypto/asymmetric_keys/public_key.c
