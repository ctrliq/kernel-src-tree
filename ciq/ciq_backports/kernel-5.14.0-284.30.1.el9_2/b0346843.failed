rxrpc: Transmit ACKs at the point of generation

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit b0346843b1076b34a0278ff601f8f287535cb064
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/b0346843.failed

For ACKs generated inside the I/O thread, transmit the ACK at the point of
generation.  Where the ACK is generated outside of the I/O thread, it's
offloaded to the I/O thread to transmit it.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit b0346843b1076b34a0278ff601f8f287535cb064)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/rxrpc.h
#	net/rxrpc/ar-internal.h
#	net/rxrpc/call_event.c
#	net/rxrpc/io_thread.c
#	net/rxrpc/local_object.c
#	net/rxrpc/output.c
diff --cc include/trace/events/rxrpc.h
index 2a52121d73a0,049b52e7aa6a..000000000000
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@@ -16,44 -16,121 +16,70 @@@
  /*
   * Declare tracing information enums and their string mappings for display.
   */
 -#define rxrpc_call_poke_traces \
 -	EM(rxrpc_call_poke_error,		"Error")	\
 -	EM(rxrpc_call_poke_idle,		"Idle")		\
 -	EM(rxrpc_call_poke_start,		"Start")	\
 -	EM(rxrpc_call_poke_timer,		"Timer")	\
 -	E_(rxrpc_call_poke_timer_now,		"Timer-now")
 -
  #define rxrpc_skb_traces \
 -	EM(rxrpc_skb_eaten_by_unshare,		"ETN unshare  ") \
 -	EM(rxrpc_skb_eaten_by_unshare_nomem,	"ETN unshar-nm") \
 -	EM(rxrpc_skb_get_conn_work,		"GET conn-work") \
 -	EM(rxrpc_skb_get_local_work,		"GET locl-work") \
 -	EM(rxrpc_skb_get_reject_work,		"GET rej-work ") \
 -	EM(rxrpc_skb_get_to_recvmsg,		"GET to-recv  ") \
 -	EM(rxrpc_skb_get_to_recvmsg_oos,	"GET to-recv-o") \
 -	EM(rxrpc_skb_new_encap_rcv,		"NEW encap-rcv") \
 -	EM(rxrpc_skb_new_error_report,		"NEW error-rpt") \
 -	EM(rxrpc_skb_new_jumbo_subpacket,	"NEW jumbo-sub") \
 -	EM(rxrpc_skb_new_unshared,		"NEW unshared ") \
 -	EM(rxrpc_skb_put_conn_work,		"PUT conn-work") \
 -	EM(rxrpc_skb_put_error_report,		"PUT error-rep") \
 -	EM(rxrpc_skb_put_input,			"PUT input    ") \
 -	EM(rxrpc_skb_put_jumbo_subpacket,	"PUT jumbo-sub") \
 -	EM(rxrpc_skb_put_purge,			"PUT purge    ") \
 -	EM(rxrpc_skb_put_rotate,		"PUT rotate   ") \
 -	EM(rxrpc_skb_put_unknown,		"PUT unknown  ") \
 -	EM(rxrpc_skb_see_conn_work,		"SEE conn-work") \
 -	EM(rxrpc_skb_see_recvmsg,		"SEE recvmsg  ") \
 -	EM(rxrpc_skb_see_reject,		"SEE reject   ") \
 -	EM(rxrpc_skb_see_rotate,		"SEE rotate   ") \
 -	E_(rxrpc_skb_see_version,		"SEE version  ")
 +	EM(rxrpc_skb_ack,			"ACK") \
 +	EM(rxrpc_skb_cleaned,			"CLN") \
 +	EM(rxrpc_skb_cloned_jumbo,		"CLJ") \
 +	EM(rxrpc_skb_freed,			"FRE") \
 +	EM(rxrpc_skb_got,			"GOT") \
 +	EM(rxrpc_skb_lost,			"*L*") \
 +	EM(rxrpc_skb_new,			"NEW") \
 +	EM(rxrpc_skb_purged,			"PUR") \
 +	EM(rxrpc_skb_received,			"RCV") \
 +	EM(rxrpc_skb_rotated,			"ROT") \
 +	EM(rxrpc_skb_seen,			"SEE") \
 +	EM(rxrpc_skb_unshared,			"UNS") \
 +	E_(rxrpc_skb_unshared_nomem,		"US0")
  
  #define rxrpc_local_traces \
++<<<<<<< HEAD
 +	EM(rxrpc_local_got,			"GOT") \
 +	EM(rxrpc_local_new,			"NEW") \
 +	EM(rxrpc_local_processing,		"PRO") \
 +	EM(rxrpc_local_put,			"PUT") \
 +	EM(rxrpc_local_queued,			"QUE") \
 +	E_(rxrpc_local_tx_ack,			"TAK")
++=======
+ 	EM(rxrpc_local_free,			"FREE        ") \
+ 	EM(rxrpc_local_get_call,		"GET call    ") \
+ 	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
+ 	EM(rxrpc_local_get_for_use,		"GET for-use ") \
+ 	EM(rxrpc_local_get_peer,		"GET peer    ") \
+ 	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
+ 	EM(rxrpc_local_new,			"NEW         ") \
+ 	EM(rxrpc_local_put_bind,		"PUT bind    ") \
+ 	EM(rxrpc_local_put_call,		"PUT call    ") \
+ 	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
+ 	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
+ 	EM(rxrpc_local_put_peer,		"PUT peer    ") \
+ 	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
+ 	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
+ 	EM(rxrpc_local_stop,			"STOP        ") \
+ 	EM(rxrpc_local_stopped,			"STOPPED     ") \
+ 	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
+ 	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
+ 	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
+ 	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
+ 	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
+ 	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
+ 	E_(rxrpc_local_use_peer_keepalive,	"USE peer-kpa")
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  
  #define rxrpc_peer_traces \
 -	EM(rxrpc_peer_free,			"FREE        ") \
 -	EM(rxrpc_peer_get_accept,		"GET accept  ") \
 -	EM(rxrpc_peer_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
 -	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
 -	EM(rxrpc_peer_get_input,		"GET input   ") \
 -	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
 -	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
 -	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
 -	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
 -	EM(rxrpc_peer_new_client,		"NEW client  ") \
 -	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
 -	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
 -	EM(rxrpc_peer_put_call,			"PUT call    ") \
 -	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
 -	EM(rxrpc_peer_put_discard_tmp,		"PUT disc-tmp") \
 -	EM(rxrpc_peer_put_input,		"PUT input   ") \
 -	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
 -	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
 -
 -#define rxrpc_bundle_traces \
 -	EM(rxrpc_bundle_free,			"FREE        ") \
 -	EM(rxrpc_bundle_get_client_call,	"GET clt-call") \
 -	EM(rxrpc_bundle_get_client_conn,	"GET clt-conn") \
 -	EM(rxrpc_bundle_get_service_conn,	"GET svc-conn") \
 -	EM(rxrpc_bundle_put_conn,		"PUT conn    ") \
 -	EM(rxrpc_bundle_put_discard,		"PUT discard ") \
 -	E_(rxrpc_bundle_new,			"NEW         ")
 +	EM(rxrpc_peer_got,			"GOT") \
 +	EM(rxrpc_peer_new,			"NEW") \
 +	EM(rxrpc_peer_processing,		"PRO") \
 +	E_(rxrpc_peer_put,			"PUT")
  
  #define rxrpc_conn_traces \
 -	EM(rxrpc_conn_free,			"FREE        ") \
 -	EM(rxrpc_conn_get_activate_call,	"GET act-call") \
 -	EM(rxrpc_conn_get_call_input,		"GET inp-call") \
 -	EM(rxrpc_conn_get_conn_input,		"GET inp-conn") \
 -	EM(rxrpc_conn_get_idle,			"GET idle    ") \
 -	EM(rxrpc_conn_get_poke,			"GET poke    ") \
 -	EM(rxrpc_conn_get_service_conn,		"GET svc-conn") \
 -	EM(rxrpc_conn_new_client,		"NEW client  ") \
 -	EM(rxrpc_conn_new_service,		"NEW service ") \
 -	EM(rxrpc_conn_put_call,			"PUT call    ") \
 -	EM(rxrpc_conn_put_call_input,		"PUT inp-call") \
 -	EM(rxrpc_conn_put_conn_input,		"PUT inp-conn") \
 -	EM(rxrpc_conn_put_discard,		"PUT discard ") \
 -	EM(rxrpc_conn_put_discard_idle,		"PUT disc-idl") \
 -	EM(rxrpc_conn_put_local_dead,		"PUT loc-dead") \
 -	EM(rxrpc_conn_put_noreuse,		"PUT noreuse ") \
 -	EM(rxrpc_conn_put_poke,			"PUT poke    ") \
 -	EM(rxrpc_conn_put_service_reaped,	"PUT svc-reap") \
 -	EM(rxrpc_conn_put_unbundle,		"PUT unbundle") \
 -	EM(rxrpc_conn_put_unidle,		"PUT unidle  ") \
 -	EM(rxrpc_conn_queue_challenge,		"QUE chall   ") \
 -	EM(rxrpc_conn_queue_retry_work,		"QUE retry-wk") \
 -	EM(rxrpc_conn_queue_rx_work,		"QUE rx-work ") \
 -	EM(rxrpc_conn_queue_timer,		"QUE timer   ") \
 -	EM(rxrpc_conn_see_new_service_conn,	"SEE new-svc ") \
 -	EM(rxrpc_conn_see_reap_service,		"SEE reap-svc") \
 -	E_(rxrpc_conn_see_work,			"SEE work    ")
 +	EM(rxrpc_conn_got,			"GOT") \
 +	EM(rxrpc_conn_new_client,		"NWc") \
 +	EM(rxrpc_conn_new_service,		"NWs") \
 +	EM(rxrpc_conn_put_client,		"PTc") \
 +	EM(rxrpc_conn_put_service,		"PTs") \
 +	EM(rxrpc_conn_queued,			"QUE") \
 +	EM(rxrpc_conn_reap_service,		"RPs") \
 +	E_(rxrpc_conn_seen,			"SEE")
  
  #define rxrpc_client_traces \
  	EM(rxrpc_client_activate_chans,		"Activa") \
@@@ -77,8 -154,7 +103,11 @@@
  	EM(rxrpc_call_get_recvmsg,		"GET recvmsg ") \
  	EM(rxrpc_call_get_release_sock,		"GET rel-sock") \
  	EM(rxrpc_call_get_sendmsg,		"GET sendmsg ") \
++<<<<<<< HEAD
 +	EM(rxrpc_call_get_send_ack,		"GET send-ack") \
 +	EM(rxrpc_call_get_timer,		"GET timer   ") \
++=======
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  	EM(rxrpc_call_get_userid,		"GET user-id ") \
  	EM(rxrpc_call_new_client,		"NEW client  ") \
  	EM(rxrpc_call_new_prealloc_service,	"NEW prealloc") \
@@@ -89,17 -165,10 +118,16 @@@
  	EM(rxrpc_call_put_recvmsg,		"PUT recvmsg ") \
  	EM(rxrpc_call_put_release_sock,		"PUT rls-sock") \
  	EM(rxrpc_call_put_release_sock_tba,	"PUT rls-sk-a") \
- 	EM(rxrpc_call_put_send_ack,		"PUT send-ack") \
  	EM(rxrpc_call_put_sendmsg,		"PUT sendmsg ") \
 +	EM(rxrpc_call_put_timer,		"PUT timer   ") \
 +	EM(rxrpc_call_put_timer_already,	"PUT timer-al") \
  	EM(rxrpc_call_put_unnotify,		"PUT unnotify") \
  	EM(rxrpc_call_put_userid_exists,	"PUT u-exists") \
 +	EM(rxrpc_call_put_work,			"PUT work    ") \
 +	EM(rxrpc_call_queue_abort,		"QUE abort   ") \
 +	EM(rxrpc_call_queue_requeue,		"QUE requeue ") \
 +	EM(rxrpc_call_queue_resend,		"QUE resend  ") \
 +	EM(rxrpc_call_queue_timer,		"QUE timer   ") \
  	EM(rxrpc_call_see_accept,		"SEE accept  ") \
  	EM(rxrpc_call_see_activate_client,	"SEE act-clnt") \
  	EM(rxrpc_call_see_connect_failed,	"SEE con-fail") \
diff --cc net/rxrpc/ar-internal.h
index 46ce41afb431,e7dccab7b741..000000000000
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@@ -279,13 -286,11 +279,17 @@@ struct rxrpc_local 
  	struct rxrpc_net	*rxnet;		/* The network ns in which this resides */
  	struct hlist_node	link;
  	struct socket		*socket;	/* my UDP socket */
++<<<<<<< HEAD
 +	struct work_struct	processor;
 +	struct list_head	ack_tx_queue;	/* List of ACKs that need sending */
 +	spinlock_t		ack_tx_lock;	/* ACK list lock */
++=======
+ 	struct task_struct	*io_thread;
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  	struct rxrpc_sock __rcu	*service;	/* Service(s) listening on this endpoint */
  	struct rw_semaphore	defrag_sem;	/* control re-enablement of IP DF bit */
 -	struct sk_buff_head	rx_queue;	/* Received packets */
 -	struct list_head	call_attend_q;	/* Calls requiring immediate attention */
 +	struct sk_buff_head	reject_queue;	/* packets awaiting rejection */
 +	struct sk_buff_head	event_queue;	/* endpoint event packets awaiting processing */
  	struct rb_root		client_bundles;	/* Client connection bundles by socket params */
  	spinlock_t		client_bundles_lock; /* Lock for client_bundles */
  	spinlock_t		lock;		/* access lock */
@@@ -739,9 -758,8 +743,8 @@@ struct rxrpc_send_params 
   */
  struct rxrpc_txbuf {
  	struct rcu_head		rcu;
 -	struct list_head	call_link;	/* Link in call->tx_sendmsg/tx_buffer */
 +	struct list_head	call_link;	/* Link in call->tx_queue */
  	struct list_head	tx_link;	/* Link in live Enc queue or Tx queue */
- 	struct rxrpc_call	*call;		/* Call to which belongs */
  	ktime_t			last_sent;	/* Time at which last transmitted */
  	refcount_t		ref;
  	rxrpc_seq_t		seq;		/* Sequence number of this packet */
@@@ -1009,11 -1044,12 +1012,11 @@@ static inline struct rxrpc_net *rxrpc_n
  /*
   * output.c
   */
- void rxrpc_transmit_ack_packets(struct rxrpc_local *);
+ int rxrpc_send_ack_packet(struct rxrpc_call *call, struct rxrpc_txbuf *txb);
  int rxrpc_send_abort_packet(struct rxrpc_call *);
  int rxrpc_send_data_packet(struct rxrpc_call *, struct rxrpc_txbuf *);
 -void rxrpc_reject_packet(struct rxrpc_local *local, struct sk_buff *skb);
 +void rxrpc_reject_packets(struct rxrpc_local *);
  void rxrpc_send_keepalive(struct rxrpc_peer *);
 -void rxrpc_transmit_one(struct rxrpc_call *call, struct rxrpc_txbuf *txb);
  
  /*
   * peer_event.c
diff --cc net/rxrpc/call_event.c
index a95f4604cb29,b2cf448fb02c..000000000000
--- a/net/rxrpc/call_event.c
+++ b/net/rxrpc/call_event.c
@@@ -69,7 -69,6 +69,10 @@@ void rxrpc_propose_delay_ACK(struct rxr
  void rxrpc_send_ACK(struct rxrpc_call *call, u8 ack_reason,
  		    rxrpc_serial_t serial, enum rxrpc_propose_ack_trace why)
  {
++<<<<<<< HEAD
 +	struct rxrpc_local *local = call->conn->params.local;
++=======
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  	struct rxrpc_txbuf *txb;
  
  	if (test_bit(RXRPC_CALL_DISCONNECTED, &call->flags))
@@@ -101,22 -95,9 +104,28 @@@
  	txb->ack.reason		= ack_reason;
  	txb->ack.nAcks		= 0;
  
++<<<<<<< HEAD
 +	if (!rxrpc_try_get_call(call, rxrpc_call_get_send_ack)) {
 +		rxrpc_put_txbuf(txb, rxrpc_txbuf_put_nomem);
 +		return;
 +	}
 +
 +	spin_lock_bh(&local->ack_tx_lock);
 +	list_add_tail(&txb->tx_link, &local->ack_tx_queue);
 +	spin_unlock_bh(&local->ack_tx_lock);
 +	trace_rxrpc_send_ack(call, why, ack_reason, serial);
 +
 +	if (in_task()) {
 +		rxrpc_transmit_ack_packets(call->peer->local);
 +	} else {
 +		rxrpc_get_local(local);
 +		rxrpc_queue_local(local);
 +	}
++=======
+ 	trace_rxrpc_send_ack(call, why, ack_reason, serial);
+ 	rxrpc_send_ack_packet(call, txb);
+ 	rxrpc_put_txbuf(txb, rxrpc_txbuf_put_ack_tx);
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  }
  
  /*
@@@ -291,6 -251,83 +300,86 @@@ out
  	_leave("");
  }
  
++<<<<<<< HEAD
++=======
+ static bool rxrpc_tx_window_has_space(struct rxrpc_call *call)
+ {
+ 	unsigned int winsize = min_t(unsigned int, call->tx_winsize,
+ 				     call->cong_cwnd + call->cong_extra);
+ 	rxrpc_seq_t window = call->acks_hard_ack, wtop = window + winsize;
+ 	rxrpc_seq_t tx_top = call->tx_top;
+ 	int space;
+ 
+ 	space = wtop - tx_top;
+ 	return space > 0;
+ }
+ 
+ /*
+  * Decant some if the sendmsg prepared queue into the transmission buffer.
+  */
+ static void rxrpc_decant_prepared_tx(struct rxrpc_call *call)
+ {
+ 	struct rxrpc_txbuf *txb;
+ 
+ 	if (rxrpc_is_client_call(call) &&
+ 	    !test_bit(RXRPC_CALL_EXPOSED, &call->flags))
+ 		rxrpc_expose_client_call(call);
+ 
+ 	while ((txb = list_first_entry_or_null(&call->tx_sendmsg,
+ 					       struct rxrpc_txbuf, call_link))) {
+ 		spin_lock(&call->tx_lock);
+ 		list_del(&txb->call_link);
+ 		spin_unlock(&call->tx_lock);
+ 
+ 		call->tx_top = txb->seq;
+ 		list_add_tail(&txb->call_link, &call->tx_buffer);
+ 
+ 		rxrpc_transmit_one(call, txb);
+ 
+ 		if (!rxrpc_tx_window_has_space(call))
+ 			break;
+ 	}
+ }
+ 
+ static void rxrpc_transmit_some_data(struct rxrpc_call *call)
+ {
+ 	switch (call->state) {
+ 	case RXRPC_CALL_SERVER_ACK_REQUEST:
+ 		if (list_empty(&call->tx_sendmsg))
+ 			return;
+ 		fallthrough;
+ 
+ 	case RXRPC_CALL_SERVER_SEND_REPLY:
+ 	case RXRPC_CALL_SERVER_AWAIT_ACK:
+ 	case RXRPC_CALL_CLIENT_SEND_REQUEST:
+ 	case RXRPC_CALL_CLIENT_AWAIT_REPLY:
+ 		if (!rxrpc_tx_window_has_space(call))
+ 			return;
+ 		if (list_empty(&call->tx_sendmsg)) {
+ 			rxrpc_inc_stat(call->rxnet, stat_tx_data_underflow);
+ 			return;
+ 		}
+ 		rxrpc_decant_prepared_tx(call);
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ }
+ 
+ /*
+  * Ping the other end to fill our RTT cache and to retrieve the rwind
+  * and MTU parameters.
+  */
+ static void rxrpc_send_initial_ping(struct rxrpc_call *call)
+ {
+ 	if (call->peer->rtt_count < 3 ||
+ 	    ktime_before(ktime_add_ms(call->peer->rtt_last_req, 1000),
+ 			 ktime_get_real()))
+ 		rxrpc_send_ACK(call, RXRPC_ACK_PING, 0,
+ 			       rxrpc_propose_ack_ping_for_params);
+ }
+ 
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  /*
   * Handle retransmission and deferred ACK/abort generation.
   */
diff --cc net/rxrpc/local_object.c
index 846558613c7f,44222923c0d1..000000000000
--- a/net/rxrpc/local_object.c
+++ b/net/rxrpc/local_object.c
@@@ -83,12 -96,9 +83,15 @@@ static struct rxrpc_local *rxrpc_alloc_
  		atomic_set(&local->active_users, 1);
  		local->rxnet = rxnet;
  		INIT_HLIST_NODE(&local->link);
++<<<<<<< HEAD
 +		INIT_WORK(&local->processor, rxrpc_local_processor);
 +		INIT_LIST_HEAD(&local->ack_tx_queue);
 +		spin_lock_init(&local->ack_tx_lock);
++=======
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
  		init_rwsem(&local->defrag_sem);
 -		skb_queue_head_init(&local->rx_queue);
 -		INIT_LIST_HEAD(&local->call_attend_q);
 +		skb_queue_head_init(&local->reject_queue);
 +		skb_queue_head_init(&local->event_queue);
  		local->client_bundles = RB_ROOT;
  		spin_lock_init(&local->client_bundles_lock);
  		spin_lock_init(&local->lock);
diff --cc net/rxrpc/output.c
index 71b6fea4598b,3d8c9f830ee0..000000000000
--- a/net/rxrpc/output.c
+++ b/net/rxrpc/output.c
@@@ -279,44 -271,6 +278,47 @@@ int rxrpc_send_ack_packet(struct rxrpc_
  }
  
  /*
++<<<<<<< HEAD
 + * ACK transmitter for a local endpoint.  The UDP socket locks around each
 + * transmission, so we can only transmit one packet at a time, ACK, DATA or
 + * otherwise.
 + */
 +void rxrpc_transmit_ack_packets(struct rxrpc_local *local)
 +{
 +	LIST_HEAD(queue);
 +	int ret;
 +
 +	trace_rxrpc_local(local->debug_id, rxrpc_local_tx_ack,
 +			  refcount_read(&local->ref), NULL);
 +
 +	if (list_empty(&local->ack_tx_queue))
 +		return;
 +
 +	spin_lock_bh(&local->ack_tx_lock);
 +	list_splice_tail_init(&local->ack_tx_queue, &queue);
 +	spin_unlock_bh(&local->ack_tx_lock);
 +
 +	while (!list_empty(&queue)) {
 +		struct rxrpc_txbuf *txb =
 +			list_entry(queue.next, struct rxrpc_txbuf, tx_link);
 +
 +		ret = rxrpc_send_ack_packet(local, txb);
 +		if (ret < 0 && ret != -ECONNRESET) {
 +			spin_lock_bh(&local->ack_tx_lock);
 +			list_splice_init(&queue, &local->ack_tx_queue);
 +			spin_unlock_bh(&local->ack_tx_lock);
 +			break;
 +		}
 +
 +		list_del_init(&txb->tx_link);
 +		rxrpc_put_call(txb->call, rxrpc_call_put_send_ack);
 +		rxrpc_put_txbuf(txb, rxrpc_txbuf_put_ack_tx);
 +	}
 +}
 +
 +/*
++=======
++>>>>>>> b0346843b107 (rxrpc: Transmit ACKs at the point of generation)
   * Send an ABORT call packet.
   */
  int rxrpc_send_abort_packet(struct rxrpc_call *call)
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path include/trace/events/rxrpc.h
* Unmerged path net/rxrpc/ar-internal.h
* Unmerged path net/rxrpc/call_event.c
* Unmerged path net/rxrpc/io_thread.c
* Unmerged path net/rxrpc/local_object.c
* Unmerged path net/rxrpc/output.c
diff --git a/net/rxrpc/recvmsg.c b/net/rxrpc/recvmsg.c
index c84d2b620396..3bf238af5798 100644
--- a/net/rxrpc/recvmsg.c
+++ b/net/rxrpc/recvmsg.c
@@ -323,7 +323,6 @@ static int rxrpc_recvmsg_data(struct socket *sock, struct rxrpc_call *call,
 				ret = ret2;
 				goto out;
 			}
-			rxrpc_transmit_ack_packets(call->peer->local);
 		} else {
 			trace_rxrpc_recvdata(call, rxrpc_recvmsg_cont, seq,
 					     rx_pkt_offset, rx_pkt_len, 0);
@@ -507,7 +506,6 @@ int rxrpc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
 		if (ret == -EAGAIN)
 			ret = 0;
 
-		rxrpc_transmit_ack_packets(call->peer->local);
 		if (!skb_queue_empty(&call->recvmsg_queue))
 			rxrpc_notify_socket(call);
 		break;
@@ -637,7 +635,6 @@ int rxrpc_kernel_recv_data(struct socket *sock, struct rxrpc_call *call,
 read_phase_complete:
 	ret = 1;
 out:
-	rxrpc_transmit_ack_packets(call->peer->local);
 	if (_service)
 		*_service = call->service_id;
 	mutex_unlock(&call->user_mutex);
diff --git a/net/rxrpc/sendmsg.c b/net/rxrpc/sendmsg.c
index 1fde52736bb8..c3046f3307b0 100644
--- a/net/rxrpc/sendmsg.c
+++ b/net/rxrpc/sendmsg.c
@@ -335,8 +335,6 @@ static int rxrpc_send_data(struct rxrpc_sock *rx,
 		rxrpc_see_txbuf(txb, rxrpc_txbuf_see_send_more);
 
 	do {
-		rxrpc_transmit_ack_packets(call->peer->local);
-
 		if (!txb) {
 			size_t remain, bufsize, chunk, offset;
 
diff --git a/net/rxrpc/txbuf.c b/net/rxrpc/txbuf.c
index 96bfee89927b..fcfa1bfa923c 100644
--- a/net/rxrpc/txbuf.c
+++ b/net/rxrpc/txbuf.c
@@ -26,7 +26,6 @@ struct rxrpc_txbuf *rxrpc_alloc_txbuf(struct rxrpc_call *call, u8 packet_type,
 		INIT_LIST_HEAD(&txb->call_link);
 		INIT_LIST_HEAD(&txb->tx_link);
 		refcount_set(&txb->ref, 1);
-		txb->call		= call;
 		txb->call_debug_id	= call->debug_id;
 		txb->debug_id		= atomic_inc_return(&rxrpc_txbuf_debug_ids);
 		txb->space		= sizeof(txb->data);
