rxrpc: trace: Don't use __builtin_return_address for rxrpc_local tracing

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 0fde882fc9ee9cc2e66e8c5a5a93c83932d7ca95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/0fde882f.failed

In rxrpc tracing, use enums to generate lists of points of interest rather
than __builtin_return_address() for the rxrpc_local tracepoint

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 0fde882fc9ee9cc2e66e8c5a5a93c83932d7ca95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rxrpc/call_accept.c
#	net/rxrpc/conn_client.c
#	net/rxrpc/conn_event.c
#	net/rxrpc/conn_object.c
#	net/rxrpc/local_object.c
diff --cc net/rxrpc/call_accept.c
index 48790ee77019,1b12d4e28373..000000000000
--- a/net/rxrpc/call_accept.c
+++ b/net/rxrpc/call_accept.c
@@@ -305,8 -305,8 +305,13 @@@ static struct rxrpc_call *rxrpc_alloc_i
  		b->conn_backlog[conn_tail] = NULL;
  		smp_store_release(&b->conn_backlog_tail,
  				  (conn_tail + 1) & (RXRPC_BACKLOG_MAX - 1));
++<<<<<<< HEAD
 +		conn->params.local = rxrpc_get_local(local);
 +		conn->params.peer = peer;
++=======
+ 		conn->local = rxrpc_get_local(local, rxrpc_local_get_prealloc_conn);
+ 		conn->peer = peer;
++>>>>>>> 0fde882fc9ee (rxrpc: trace: Don't use __builtin_return_address for rxrpc_local tracing)
  		rxrpc_see_connection(conn);
  		rxrpc_new_incoming_connection(rx, conn, sec, skb);
  	} else {
diff --cc net/rxrpc/conn_client.c
index f11c97e28d2a,9a69b4c1b182..000000000000
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@@ -196,9 -207,9 +196,15 @@@ rxrpc_alloc_client_connection(struct rx
  	write_unlock(&rxnet->conn_lock);
  
  	rxrpc_get_bundle(bundle);
++<<<<<<< HEAD
 +	rxrpc_get_peer(conn->params.peer);
 +	rxrpc_get_local(conn->params.local);
 +	key_get(conn->params.key);
++=======
+ 	rxrpc_get_peer(conn->peer);
+ 	rxrpc_get_local(conn->local, rxrpc_local_get_client_conn);
+ 	key_get(conn->key);
++>>>>>>> 0fde882fc9ee (rxrpc: trace: Don't use __builtin_return_address for rxrpc_local tracing)
  
  	trace_rxrpc_conn(conn->debug_id, rxrpc_conn_new_client,
  			 refcount_read(&conn->ref),
diff --cc net/rxrpc/conn_event.c
index abf03a5b1d31,225edaf019f1..000000000000
--- a/net/rxrpc/conn_event.c
+++ b/net/rxrpc/conn_event.c
@@@ -474,9 -474,9 +474,15 @@@ void rxrpc_process_connection(struct wo
  
  	rxrpc_see_connection(conn);
  
++<<<<<<< HEAD
 +	if (__rxrpc_use_local(conn->params.local)) {
 +		rxrpc_do_process_connection(conn);
 +		rxrpc_unuse_local(conn->params.local);
++=======
+ 	if (__rxrpc_use_local(conn->local, rxrpc_local_use_conn_work)) {
+ 		rxrpc_do_process_connection(conn);
+ 		rxrpc_unuse_local(conn->local, rxrpc_local_unuse_conn_work);
++>>>>>>> 0fde882fc9ee (rxrpc: trace: Don't use __builtin_return_address for rxrpc_local tracing)
  	}
  
  	rxrpc_put_connection(conn);
diff --cc net/rxrpc/conn_object.c
index 156bd26daf74,725359afeac0..000000000000
--- a/net/rxrpc/conn_object.c
+++ b/net/rxrpc/conn_object.c
@@@ -362,13 -360,13 +362,19 @@@ static void rxrpc_destroy_connection(st
  	rxrpc_purge_queue(&conn->rx_queue);
  
  	conn->security->clear(conn);
 -	key_put(conn->key);
 +	key_put(conn->params.key);
  	rxrpc_put_bundle(conn->bundle);
 -	rxrpc_put_peer(conn->peer);
 +	rxrpc_put_peer(conn->params.peer);
  
++<<<<<<< HEAD
 +	if (atomic_dec_and_test(&conn->params.local->rxnet->nr_conns))
 +		wake_up_var(&conn->params.local->rxnet->nr_conns);
 +	rxrpc_put_local(conn->params.local);
++=======
+ 	if (atomic_dec_and_test(&conn->local->rxnet->nr_conns))
+ 		wake_up_var(&conn->local->rxnet->nr_conns);
+ 	rxrpc_put_local(conn->local, rxrpc_local_put_kill_conn);
++>>>>>>> 0fde882fc9ee (rxrpc: trace: Don't use __builtin_return_address for rxrpc_local tracing)
  
  	kfree(conn);
  	_leave("");
diff --cc net/rxrpc/local_object.c
index 846558613c7f,1617ce651b9b..000000000000
--- a/net/rxrpc/local_object.c
+++ b/net/rxrpc/local_object.c
@@@ -214,10 -228,9 +214,10 @@@ struct rxrpc_local *rxrpc_lookup_local(
  		 * we're attempting to use a local address that the dying
  		 * object is still using.
  		 */
- 		if (!rxrpc_use_local(local))
+ 		if (!rxrpc_use_local(local, rxrpc_local_use_lookup))
  			break;
  
 +		age = "old";
  		goto found;
  	}
  
@@@ -452,7 -467,7 +459,11 @@@ static void rxrpc_local_rcu(struct rcu_
  
  	ASSERT(!work_pending(&local->processor));
  
++<<<<<<< HEAD
 +	_net("DESTROY LOCAL %d", local->debug_id);
++=======
+ 	rxrpc_see_local(local, rxrpc_local_free);
++>>>>>>> 0fde882fc9ee (rxrpc: trace: Don't use __builtin_return_address for rxrpc_local tracing)
  	kfree(local);
  	_leave("");
  }
diff --git a/include/trace/events/rxrpc.h b/include/trace/events/rxrpc.h
index 2b77f9a75bf7..015569845b1d 100644
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@ -32,12 +32,35 @@
 	E_(rxrpc_skb_unshared_nomem,		"US0")
 
 #define rxrpc_local_traces \
-	EM(rxrpc_local_got,			"GOT") \
-	EM(rxrpc_local_new,			"NEW") \
-	EM(rxrpc_local_processing,		"PRO") \
-	EM(rxrpc_local_put,			"PUT") \
-	EM(rxrpc_local_queued,			"QUE") \
-	E_(rxrpc_local_tx_ack,			"TAK")
+	EM(rxrpc_local_free,			"FREE        ") \
+	EM(rxrpc_local_get_client_conn,		"GET conn-cln") \
+	EM(rxrpc_local_get_for_use,		"GET for-use ") \
+	EM(rxrpc_local_get_peer,		"GET peer    ") \
+	EM(rxrpc_local_get_prealloc_conn,	"GET conn-pre") \
+	EM(rxrpc_local_get_queue,		"GET queue   ") \
+	EM(rxrpc_local_new,			"NEW         ") \
+	EM(rxrpc_local_processing,		"PROCESSING  ") \
+	EM(rxrpc_local_put_already_queued,	"PUT alreadyq") \
+	EM(rxrpc_local_put_bind,		"PUT bind    ") \
+	EM(rxrpc_local_put_for_use,		"PUT for-use ") \
+	EM(rxrpc_local_put_kill_conn,		"PUT conn-kil") \
+	EM(rxrpc_local_put_peer,		"PUT peer    ") \
+	EM(rxrpc_local_put_prealloc_conn,	"PUT conn-pre") \
+	EM(rxrpc_local_put_release_sock,	"PUT rel-sock") \
+	EM(rxrpc_local_put_queue,		"PUT queue   ") \
+	EM(rxrpc_local_queued,			"QUEUED      ") \
+	EM(rxrpc_local_see_tx_ack,		"SEE tx-ack  ") \
+	EM(rxrpc_local_stop,			"STOP        ") \
+	EM(rxrpc_local_stopped,			"STOPPED     ") \
+	EM(rxrpc_local_unuse_bind,		"UNU bind    ") \
+	EM(rxrpc_local_unuse_conn_work,		"UNU conn-wrk") \
+	EM(rxrpc_local_unuse_peer_keepalive,	"UNU peer-kpa") \
+	EM(rxrpc_local_unuse_release_sock,	"UNU rel-sock") \
+	EM(rxrpc_local_unuse_work,		"UNU work    ") \
+	EM(rxrpc_local_use_conn_work,		"USE conn-wrk") \
+	EM(rxrpc_local_use_lookup,		"USE lookup  ") \
+	EM(rxrpc_local_use_peer_keepalive,	"USE peer-kpa") \
+	E_(rxrpc_local_use_work,		"USE work    ")
 
 #define rxrpc_peer_traces \
 	EM(rxrpc_peer_got,			"GOT") \
@@ -345,29 +368,29 @@ rxrpc_txqueue_traces;
 
 TRACE_EVENT(rxrpc_local,
 	    TP_PROTO(unsigned int local_debug_id, enum rxrpc_local_trace op,
-		     int usage, const void *where),
+		     int ref, int usage),
 
-	    TP_ARGS(local_debug_id, op, usage, where),
+	    TP_ARGS(local_debug_id, op, ref, usage),
 
 	    TP_STRUCT__entry(
 		    __field(unsigned int,	local		)
 		    __field(int,		op		)
+		    __field(int,		ref		)
 		    __field(int,		usage		)
-		    __field(const void *,	where		)
 			     ),
 
 	    TP_fast_assign(
 		    __entry->local = local_debug_id;
 		    __entry->op = op;
+		    __entry->ref = ref;
 		    __entry->usage = usage;
-		    __entry->where = where;
 			   ),
 
-	    TP_printk("L=%08x %s u=%d sp=%pSR",
+	    TP_printk("L=%08x %s r=%d u=%d",
 		      __entry->local,
 		      __print_symbolic(__entry->op, rxrpc_local_traces),
-		      __entry->usage,
-		      __entry->where)
+		      __entry->ref,
+		      __entry->usage)
 	    );
 
 TRACE_EVENT(rxrpc_peer,
diff --git a/net/rxrpc/af_rxrpc.c b/net/rxrpc/af_rxrpc.c
index aacdd96a9886..989ebca899f3 100644
--- a/net/rxrpc/af_rxrpc.c
+++ b/net/rxrpc/af_rxrpc.c
@@ -194,8 +194,8 @@ static int rxrpc_bind(struct socket *sock, struct sockaddr *saddr, int len)
 
 service_in_use:
 	write_unlock(&local->services_lock);
-	rxrpc_unuse_local(local);
-	rxrpc_put_local(local);
+	rxrpc_unuse_local(local, rxrpc_local_unuse_bind);
+	rxrpc_put_local(local, rxrpc_local_put_bind);
 	ret = -EADDRINUSE;
 error_unlock:
 	release_sock(&rx->sk);
@@ -888,8 +888,8 @@ static int rxrpc_release_sock(struct sock *sk)
 	flush_workqueue(rxrpc_workqueue);
 	rxrpc_purge_queue(&sk->sk_receive_queue);
 
-	rxrpc_unuse_local(rx->local);
-	rxrpc_put_local(rx->local);
+	rxrpc_unuse_local(rx->local, rxrpc_local_unuse_release_sock);
+	rxrpc_put_local(rx->local, rxrpc_local_put_release_sock);
 	rx->local = NULL;
 	key_put(rx->key);
 	rx->key = NULL;
diff --git a/net/rxrpc/ar-internal.h b/net/rxrpc/ar-internal.h
index a3a29390e12b..6862c96af81a 100644
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@ -967,22 +967,45 @@ extern void rxrpc_process_local_events(struct rxrpc_local *);
  * local_object.c
  */
 struct rxrpc_local *rxrpc_lookup_local(struct net *, const struct sockaddr_rxrpc *);
-struct rxrpc_local *rxrpc_get_local(struct rxrpc_local *);
-struct rxrpc_local *rxrpc_get_local_maybe(struct rxrpc_local *);
-void rxrpc_put_local(struct rxrpc_local *);
-struct rxrpc_local *rxrpc_use_local(struct rxrpc_local *);
-void rxrpc_unuse_local(struct rxrpc_local *);
+struct rxrpc_local *rxrpc_get_local(struct rxrpc_local *, enum rxrpc_local_trace);
+struct rxrpc_local *rxrpc_get_local_maybe(struct rxrpc_local *, enum rxrpc_local_trace);
+void rxrpc_put_local(struct rxrpc_local *, enum rxrpc_local_trace);
+struct rxrpc_local *rxrpc_use_local(struct rxrpc_local *, enum rxrpc_local_trace);
+void rxrpc_unuse_local(struct rxrpc_local *, enum rxrpc_local_trace);
 void rxrpc_queue_local(struct rxrpc_local *);
 void rxrpc_destroy_all_locals(struct rxrpc_net *);
 
-static inline bool __rxrpc_unuse_local(struct rxrpc_local *local)
+static inline bool __rxrpc_unuse_local(struct rxrpc_local *local,
+				       enum rxrpc_local_trace why)
 {
-	return atomic_dec_return(&local->active_users) == 0;
+	unsigned int debug_id = local->debug_id;
+	int r, u;
+
+	r = refcount_read(&local->ref);
+	u = atomic_dec_return(&local->active_users);
+	trace_rxrpc_local(debug_id, why, r, u);
+	return u == 0;
+}
+
+static inline bool __rxrpc_use_local(struct rxrpc_local *local,
+				     enum rxrpc_local_trace why)
+{
+	int r, u;
+
+	r = refcount_read(&local->ref);
+	u = atomic_fetch_add_unless(&local->active_users, 1, 0);
+	trace_rxrpc_local(local->debug_id, why, r, u);
+	return u != 0;
 }
 
-static inline bool __rxrpc_use_local(struct rxrpc_local *local)
+static inline void rxrpc_see_local(struct rxrpc_local *local,
+				   enum rxrpc_local_trace why)
 {
-	return atomic_fetch_add_unless(&local->active_users, 1, 0) != 0;
+	int r, u;
+
+	r = refcount_read(&local->ref);
+	u = atomic_read(&local->active_users);
+	trace_rxrpc_local(local->debug_id, why, r, u);
 }
 
 /*
* Unmerged path net/rxrpc/call_accept.c
diff --git a/net/rxrpc/call_event.c b/net/rxrpc/call_event.c
index 349f3df569ba..124b67e6ab5c 100644
--- a/net/rxrpc/call_event.c
+++ b/net/rxrpc/call_event.c
@@ -114,7 +114,7 @@ void rxrpc_send_ACK(struct rxrpc_call *call, u8 ack_reason,
 	if (in_task()) {
 		rxrpc_transmit_ack_packets(call->peer->local);
 	} else {
-		rxrpc_get_local(local);
+		rxrpc_get_local(local, rxrpc_local_get_queue);
 		rxrpc_queue_local(local);
 	}
 }
* Unmerged path net/rxrpc/conn_client.c
* Unmerged path net/rxrpc/conn_event.c
* Unmerged path net/rxrpc/conn_object.c
diff --git a/net/rxrpc/input.c b/net/rxrpc/input.c
index 10f17c28bbfa..b1495c5c517b 100644
--- a/net/rxrpc/input.c
+++ b/net/rxrpc/input.c
@@ -1134,7 +1134,7 @@ static void rxrpc_post_packet_to_local(struct rxrpc_local *local,
 {
 	_enter("%p,%p", local, skb);
 
-	if (rxrpc_get_local_maybe(local)) {
+	if (rxrpc_get_local_maybe(local, rxrpc_local_get_queue)) {
 		skb_queue_tail(&local->event_queue, skb);
 		rxrpc_queue_local(local);
 	} else {
@@ -1147,7 +1147,7 @@ static void rxrpc_post_packet_to_local(struct rxrpc_local *local,
  */
 static void rxrpc_reject_packet(struct rxrpc_local *local, struct sk_buff *skb)
 {
-	if (rxrpc_get_local_maybe(local)) {
+	if (rxrpc_get_local_maybe(local, rxrpc_local_get_queue)) {
 		skb_queue_tail(&local->reject_queue, skb);
 		rxrpc_queue_local(local);
 	} else {
* Unmerged path net/rxrpc/local_object.c
diff --git a/net/rxrpc/output.c b/net/rxrpc/output.c
index 635acf3dbd77..bb8f5677b696 100644
--- a/net/rxrpc/output.c
+++ b/net/rxrpc/output.c
@@ -288,8 +288,7 @@ void rxrpc_transmit_ack_packets(struct rxrpc_local *local)
 	LIST_HEAD(queue);
 	int ret;
 
-	trace_rxrpc_local(local->debug_id, rxrpc_local_tx_ack,
-			  refcount_read(&local->ref), NULL);
+	rxrpc_see_local(local, rxrpc_local_see_tx_ack);
 
 	if (list_empty(&local->ack_tx_queue))
 		return;
diff --git a/net/rxrpc/peer_event.c b/net/rxrpc/peer_event.c
index 88bc1a201b3e..ced9124643ae 100644
--- a/net/rxrpc/peer_event.c
+++ b/net/rxrpc/peer_event.c
@@ -315,7 +315,7 @@ static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet,
 		if (!rxrpc_get_peer_maybe(peer))
 			continue;
 
-		if (__rxrpc_use_local(peer->local)) {
+		if (__rxrpc_use_local(peer->local, rxrpc_local_use_peer_keepalive)) {
 			spin_unlock_bh(&rxnet->peer_hash_lock);
 
 			keepalive_at = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;
@@ -338,7 +338,7 @@ static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet,
 			spin_lock_bh(&rxnet->peer_hash_lock);
 			list_add_tail(&peer->keepalive_link,
 				      &rxnet->peer_keepalive[slot & mask]);
-			rxrpc_unuse_local(peer->local);
+			rxrpc_unuse_local(peer->local, rxrpc_local_unuse_peer_keepalive);
 		}
 		rxrpc_put_peer_locked(peer);
 	}
diff --git a/net/rxrpc/peer_object.c b/net/rxrpc/peer_object.c
index 041a51225c5f..16393781953f 100644
--- a/net/rxrpc/peer_object.c
+++ b/net/rxrpc/peer_object.c
@@ -217,7 +217,7 @@ struct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *local, gfp_t gfp)
 	peer = kzalloc(sizeof(struct rxrpc_peer), gfp);
 	if (peer) {
 		refcount_set(&peer->ref, 1);
-		peer->local = rxrpc_get_local(local);
+		peer->local = rxrpc_get_local(local, rxrpc_local_get_peer);
 		INIT_HLIST_HEAD(&peer->error_targets);
 		peer->service_conns = RB_ROOT;
 		seqlock_init(&peer->service_conn_lock);
@@ -296,7 +296,7 @@ static struct rxrpc_peer *rxrpc_create_peer(struct rxrpc_sock *rx,
 
 static void rxrpc_free_peer(struct rxrpc_peer *peer)
 {
-	rxrpc_put_local(peer->local);
+	rxrpc_put_local(peer->local, rxrpc_local_put_peer);
 	kfree_rcu(peer, rcu);
 }
 
