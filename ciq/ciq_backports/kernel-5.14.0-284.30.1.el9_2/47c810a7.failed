rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 47c810a79844462d3468d831edc00971757693e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/47c810a7.failed

In rxrpc tracing, use enums to generate lists of points of interest rather
than __builtin_return_address() for the rxrpc_peer tracepoint

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 47c810a79844462d3468d831edc00971757693e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rxrpc/call_accept.c
#	net/rxrpc/conn_client.c
#	net/rxrpc/conn_object.c
#	net/rxrpc/peer_event.c
#	net/rxrpc/peer_object.c
diff --cc net/rxrpc/call_accept.c
index 48790ee77019,f6bc3b07c3e5..000000000000
--- a/net/rxrpc/call_accept.c
+++ b/net/rxrpc/call_accept.c
@@@ -323,7 -325,7 +325,11 @@@ static struct rxrpc_call *rxrpc_alloc_i
  	call->conn = conn;
  	call->security = conn->security;
  	call->security_ix = conn->security_ix;
++<<<<<<< HEAD
 +	call->peer = rxrpc_get_peer(conn->params.peer);
++=======
+ 	call->peer = rxrpc_get_peer(conn->peer, rxrpc_peer_get_accept);
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  	call->cong_ssthresh = call->peer->cong_ssthresh;
  	call->tx_last_sent = ktime_get_real();
  	return call;
diff --cc net/rxrpc/conn_client.c
index f11c97e28d2a,9444da235a48..000000000000
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@@ -122,8 -122,13 +122,18 @@@ static struct rxrpc_bundle *rxrpc_alloc
  
  	bundle = kzalloc(sizeof(*bundle), gfp);
  	if (bundle) {
++<<<<<<< HEAD
 +		bundle->params = *cp;
 +		rxrpc_get_peer(bundle->params.peer);
++=======
+ 		bundle->local		= cp->local;
+ 		bundle->peer		= rxrpc_get_peer(cp->peer, rxrpc_peer_get_bundle);
+ 		bundle->key		= cp->key;
+ 		bundle->exclusive	= cp->exclusive;
+ 		bundle->upgrade		= cp->upgrade;
+ 		bundle->service_id	= cp->service_id;
+ 		bundle->security_level	= cp->security_level;
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  		refcount_set(&bundle->ref, 1);
  		atomic_set(&bundle->active, 1);
  		spin_lock_init(&bundle->channel_lock);
@@@ -140,7 -145,7 +150,11 @@@ struct rxrpc_bundle *rxrpc_get_bundle(s
  
  static void rxrpc_free_bundle(struct rxrpc_bundle *bundle)
  {
++<<<<<<< HEAD
 +	rxrpc_put_peer(bundle->params.peer);
++=======
+ 	rxrpc_put_peer(bundle->peer, rxrpc_peer_put_bundle);
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  	kfree(bundle);
  }
  
@@@ -196,9 -207,9 +210,15 @@@ rxrpc_alloc_client_connection(struct rx
  	write_unlock(&rxnet->conn_lock);
  
  	rxrpc_get_bundle(bundle);
++<<<<<<< HEAD
 +	rxrpc_get_peer(conn->params.peer);
 +	rxrpc_get_local(conn->params.local);
 +	key_get(conn->params.key);
++=======
+ 	rxrpc_get_peer(conn->peer, rxrpc_peer_get_client_conn);
+ 	rxrpc_get_local(conn->local, rxrpc_local_get_client_conn);
+ 	key_get(conn->key);
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  
  	trace_rxrpc_conn(conn->debug_id, rxrpc_conn_new_client,
  			 refcount_read(&conn->ref),
@@@ -532,7 -543,7 +552,11 @@@ static void rxrpc_activate_one_channel(
  
  	rxrpc_see_call(call);
  	list_del_init(&call->chan_wait_link);
++<<<<<<< HEAD
 +	call->peer	= rxrpc_get_peer(conn->params.peer);
++=======
+ 	call->peer	= rxrpc_get_peer(conn->peer, rxrpc_peer_get_activate_call);
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  	call->conn	= rxrpc_get_connection(conn);
  	call->cid	= conn->proto.cid | channel;
  	call->call_id	= call_id;
diff --cc net/rxrpc/conn_object.c
index 156bd26daf74,554ee5dd3325..000000000000
--- a/net/rxrpc/conn_object.c
+++ b/net/rxrpc/conn_object.c
@@@ -362,13 -360,13 +362,17 @@@ static void rxrpc_destroy_connection(st
  	rxrpc_purge_queue(&conn->rx_queue);
  
  	conn->security->clear(conn);
 -	key_put(conn->key);
 +	key_put(conn->params.key);
  	rxrpc_put_bundle(conn->bundle);
++<<<<<<< HEAD
 +	rxrpc_put_peer(conn->params.peer);
++=======
+ 	rxrpc_put_peer(conn->peer, rxrpc_peer_put_conn);
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  
 -	if (atomic_dec_and_test(&conn->local->rxnet->nr_conns))
 -		wake_up_var(&conn->local->rxnet->nr_conns);
 -	rxrpc_put_local(conn->local, rxrpc_local_put_kill_conn);
 +	if (atomic_dec_and_test(&conn->params.local->rxnet->nr_conns))
 +		wake_up_var(&conn->params.local->rxnet->nr_conns);
 +	rxrpc_put_local(conn->params.local);
  
  	kfree(conn);
  	_leave("");
diff --cc net/rxrpc/peer_event.c
index 88bc1a201b3e,5e97d321ac38..000000000000
--- a/net/rxrpc/peer_event.c
+++ b/net/rxrpc/peer_event.c
@@@ -179,8 -167,8 +179,13 @@@ void rxrpc_error_report(struct sock *sk
  		return;
  	}
  
++<<<<<<< HEAD
 +	peer = rxrpc_lookup_peer_icmp_rcu(local, skb, &srx);
 +	if (peer && !rxrpc_get_peer_maybe(peer))
++=======
+ 	peer = rxrpc_lookup_peer_local_rcu(local, skb, &srx);
+ 	if (peer && !rxrpc_get_peer_maybe(peer, rxrpc_peer_get_input_error))
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  		peer = NULL;
  	if (!peer) {
  		rcu_read_unlock();
@@@ -203,9 -187,10 +208,9 @@@
  	}
  
  	rxrpc_store_error(peer, serr);
 -out:
  	rcu_read_unlock();
  	rxrpc_free_skb(skb, rxrpc_skb_freed);
- 	rxrpc_put_peer(peer);
+ 	rxrpc_put_peer(peer, rxrpc_peer_put_input_error);
  
  	_leave("");
  }
@@@ -312,10 -263,10 +317,10 @@@ static void rxrpc_peer_keepalive_dispat
  				  struct rxrpc_peer, keepalive_link);
  
  		list_del_init(&peer->keepalive_link);
- 		if (!rxrpc_get_peer_maybe(peer))
+ 		if (!rxrpc_get_peer_maybe(peer, rxrpc_peer_get_keepalive))
  			continue;
  
 -		if (__rxrpc_use_local(peer->local, rxrpc_local_use_peer_keepalive)) {
 +		if (__rxrpc_use_local(peer->local)) {
  			spin_unlock_bh(&rxnet->peer_hash_lock);
  
  			keepalive_at = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;
@@@ -338,9 -289,9 +343,9 @@@
  			spin_lock_bh(&rxnet->peer_hash_lock);
  			list_add_tail(&peer->keepalive_link,
  				      &rxnet->peer_keepalive[slot & mask]);
 -			rxrpc_unuse_local(peer->local, rxrpc_local_unuse_peer_keepalive);
 +			rxrpc_unuse_local(peer->local);
  		}
- 		rxrpc_put_peer_locked(peer);
+ 		rxrpc_put_peer_locked(peer, rxrpc_peer_put_keepalive);
  	}
  
  	spin_unlock_bh(&rxnet->peer_hash_lock);
diff --cc net/rxrpc/peer_object.c
index 041a51225c5f,9e682a60a800..000000000000
--- a/net/rxrpc/peer_object.c
+++ b/net/rxrpc/peer_object.c
@@@ -296,7 -294,8 +296,12 @@@ static struct rxrpc_peer *rxrpc_create_
  
  static void rxrpc_free_peer(struct rxrpc_peer *peer)
  {
++<<<<<<< HEAD
 +	rxrpc_put_local(peer->local);
++=======
+ 	trace_rxrpc_peer(peer->debug_id, 0, rxrpc_peer_free);
+ 	rxrpc_put_local(peer->local, rxrpc_local_put_peer);
++>>>>>>> 47c810a79844 (rxrpc: trace: Don't use __builtin_return_address for rxrpc_peer tracing)
  	kfree_rcu(peer, rcu);
  }
  
diff --git a/include/trace/events/rxrpc.h b/include/trace/events/rxrpc.h
index 2b77f9a75bf7..48139e30feb2 100644
--- a/include/trace/events/rxrpc.h
+++ b/include/trace/events/rxrpc.h
@@ -40,10 +40,23 @@
 	E_(rxrpc_local_tx_ack,			"TAK")
 
 #define rxrpc_peer_traces \
-	EM(rxrpc_peer_got,			"GOT") \
-	EM(rxrpc_peer_new,			"NEW") \
-	EM(rxrpc_peer_processing,		"PRO") \
-	E_(rxrpc_peer_put,			"PUT")
+	EM(rxrpc_peer_free,			"FREE        ") \
+	EM(rxrpc_peer_get_accept,		"GET accept  ") \
+	EM(rxrpc_peer_get_activate_call,	"GET act-call") \
+	EM(rxrpc_peer_get_bundle,		"GET bundle  ") \
+	EM(rxrpc_peer_get_client_conn,		"GET cln-conn") \
+	EM(rxrpc_peer_get_input_error,		"GET inpt-err") \
+	EM(rxrpc_peer_get_keepalive,		"GET keepaliv") \
+	EM(rxrpc_peer_get_lookup_client,	"GET look-cln") \
+	EM(rxrpc_peer_get_service_conn,		"GET srv-conn") \
+	EM(rxrpc_peer_new_client,		"NEW client  ") \
+	EM(rxrpc_peer_new_prealloc,		"NEW prealloc") \
+	EM(rxrpc_peer_put_bundle,		"PUT bundle  ") \
+	EM(rxrpc_peer_put_call,			"PUT call    ") \
+	EM(rxrpc_peer_put_conn,			"PUT conn    ") \
+	EM(rxrpc_peer_put_discard_tmp,		"PUT disc-tmp") \
+	EM(rxrpc_peer_put_input_error,		"PUT inpt-err") \
+	E_(rxrpc_peer_put_keepalive,		"PUT keepaliv")
 
 #define rxrpc_conn_traces \
 	EM(rxrpc_conn_got,			"GOT") \
@@ -371,30 +384,26 @@ TRACE_EVENT(rxrpc_local,
 	    );
 
 TRACE_EVENT(rxrpc_peer,
-	    TP_PROTO(unsigned int peer_debug_id, enum rxrpc_peer_trace op,
-		     int usage, const void *where),
+	    TP_PROTO(unsigned int peer_debug_id, int ref, enum rxrpc_peer_trace why),
 
-	    TP_ARGS(peer_debug_id, op, usage, where),
+	    TP_ARGS(peer_debug_id, ref, why),
 
 	    TP_STRUCT__entry(
 		    __field(unsigned int,	peer		)
-		    __field(int,		op		)
-		    __field(int,		usage		)
-		    __field(const void *,	where		)
+		    __field(int,		ref		)
+		    __field(int,		why		)
 			     ),
 
 	    TP_fast_assign(
 		    __entry->peer = peer_debug_id;
-		    __entry->op = op;
-		    __entry->usage = usage;
-		    __entry->where = where;
+		    __entry->ref = ref;
+		    __entry->why = why;
 			   ),
 
-	    TP_printk("P=%08x %s u=%d sp=%pSR",
+	    TP_printk("P=%08x %s r=%d",
 		      __entry->peer,
-		      __print_symbolic(__entry->op, rxrpc_peer_traces),
-		      __entry->usage,
-		      __entry->where)
+		      __print_symbolic(__entry->why, rxrpc_peer_traces),
+		      __entry->ref)
 	    );
 
 TRACE_EVENT(rxrpc_conn,
diff --git a/net/rxrpc/af_rxrpc.c b/net/rxrpc/af_rxrpc.c
index aacdd96a9886..9e2728a89cff 100644
--- a/net/rxrpc/af_rxrpc.c
+++ b/net/rxrpc/af_rxrpc.c
@@ -328,7 +328,7 @@ struct rxrpc_call *rxrpc_kernel_begin_call(struct socket *sock,
 		mutex_unlock(&call->user_mutex);
 	}
 
-	rxrpc_put_peer(cp.peer);
+	rxrpc_put_peer(cp.peer, rxrpc_peer_put_discard_tmp);
 	_leave(" = %p", call);
 	return call;
 }
diff --git a/net/rxrpc/ar-internal.h b/net/rxrpc/ar-internal.h
index a3a29390e12b..202fd30f33aa 100644
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@ -1028,14 +1028,15 @@ struct rxrpc_peer *rxrpc_lookup_peer_rcu(struct rxrpc_local *,
 					 const struct sockaddr_rxrpc *);
 struct rxrpc_peer *rxrpc_lookup_peer(struct rxrpc_sock *, struct rxrpc_local *,
 				     struct sockaddr_rxrpc *, gfp_t);
-struct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *, gfp_t);
+struct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *, gfp_t,
+				    enum rxrpc_peer_trace);
 void rxrpc_new_incoming_peer(struct rxrpc_sock *, struct rxrpc_local *,
 			     struct rxrpc_peer *);
 void rxrpc_destroy_all_peers(struct rxrpc_net *);
-struct rxrpc_peer *rxrpc_get_peer(struct rxrpc_peer *);
-struct rxrpc_peer *rxrpc_get_peer_maybe(struct rxrpc_peer *);
-void rxrpc_put_peer(struct rxrpc_peer *);
-void rxrpc_put_peer_locked(struct rxrpc_peer *);
+struct rxrpc_peer *rxrpc_get_peer(struct rxrpc_peer *, enum rxrpc_peer_trace);
+struct rxrpc_peer *rxrpc_get_peer_maybe(struct rxrpc_peer *, enum rxrpc_peer_trace);
+void rxrpc_put_peer(struct rxrpc_peer *, enum rxrpc_peer_trace);
+void rxrpc_put_peer_locked(struct rxrpc_peer *, enum rxrpc_peer_trace);
 
 /*
  * proc.c
* Unmerged path net/rxrpc/call_accept.c
diff --git a/net/rxrpc/call_object.c b/net/rxrpc/call_object.c
index 1befe22cd301..c91349f1efaa 100644
--- a/net/rxrpc/call_object.c
+++ b/net/rxrpc/call_object.c
@@ -640,7 +640,7 @@ static void rxrpc_destroy_call(struct work_struct *work)
 	rxrpc_delete_call_timer(call);
 
 	rxrpc_put_connection(call->conn);
-	rxrpc_put_peer(call->peer);
+	rxrpc_put_peer(call->peer, rxrpc_peer_put_call);
 	kmem_cache_free(rxrpc_call_jar, call);
 	if (atomic_dec_and_test(&rxnet->nr_calls))
 		wake_up_var(&rxnet->nr_calls);
* Unmerged path net/rxrpc/conn_client.c
* Unmerged path net/rxrpc/conn_object.c
* Unmerged path net/rxrpc/peer_event.c
* Unmerged path net/rxrpc/peer_object.c
diff --git a/net/rxrpc/sendmsg.c b/net/rxrpc/sendmsg.c
index e5fd8a95bf71..cfe0badba0b3 100644
--- a/net/rxrpc/sendmsg.c
+++ b/net/rxrpc/sendmsg.c
@@ -604,7 +604,7 @@ rxrpc_new_client_call_for_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg,
 				     atomic_inc_return(&rxrpc_debug_id));
 	/* The socket is now unlocked */
 
-	rxrpc_put_peer(cp.peer);
+	rxrpc_put_peer(cp.peer, rxrpc_peer_put_discard_tmp);
 	_leave(" = %p\n", call);
 	return call;
 }
