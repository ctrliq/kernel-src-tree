rxrpc: Separate call retransmission from other conn events

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-284.30.1.el9_2
commit-author David Howells <dhowells@redhat.com>
commit 30df927b936b2ef21eb07dce9c141c7897609643
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-284.30.1.el9_2/30df927b.failed

Call the rxrpc_conn_retransmit_call() directly from rxrpc_input_packet()
rather than calling it via connection event handling.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 30df927b936b2ef21eb07dce9c141c7897609643)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rxrpc/conn_event.c
#	net/rxrpc/io_thread.c
diff --cc net/rxrpc/conn_event.c
index abf03a5b1d31,dfd29882126f..000000000000
--- a/net/rxrpc/conn_event.c
+++ b/net/rxrpc/conn_event.c
@@@ -472,14 -454,64 +454,73 @@@ void rxrpc_process_connection(struct wo
  	struct rxrpc_connection *conn =
  		container_of(work, struct rxrpc_connection, processor);
  
 -	rxrpc_see_connection(conn, rxrpc_conn_see_work);
 +	rxrpc_see_connection(conn);
  
 -	if (__rxrpc_use_local(conn->local, rxrpc_local_use_conn_work)) {
 +	if (__rxrpc_use_local(conn->params.local)) {
  		rxrpc_do_process_connection(conn);
++<<<<<<< HEAD
 +		rxrpc_unuse_local(conn->params.local);
 +	}
 +
 +	rxrpc_put_connection(conn);
 +	_leave("");
 +	return;
++=======
+ 		rxrpc_unuse_local(conn->local, rxrpc_local_unuse_conn_work);
+ 	}
+ }
+ 
+ /*
+  * post connection-level events to the connection
+  * - this includes challenges, responses, some aborts and call terminal packet
+  *   retransmission.
+  */
+ static void rxrpc_post_packet_to_conn(struct rxrpc_connection *conn,
+ 				      struct sk_buff *skb)
+ {
+ 	_enter("%p,%p", conn, skb);
+ 
+ 	rxrpc_get_skb(skb, rxrpc_skb_get_conn_work);
+ 	skb_queue_tail(&conn->rx_queue, skb);
+ 	rxrpc_queue_conn(conn, rxrpc_conn_queue_rx_work);
+ }
+ 
+ /*
+  * Input a connection-level packet.
+  */
+ int rxrpc_input_conn_packet(struct rxrpc_connection *conn, struct sk_buff *skb)
+ {
+ 	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);
+ 
+ 	if (conn->state >= RXRPC_CONN_REMOTELY_ABORTED) {
+ 		_leave(" = -ECONNABORTED [%u]", conn->state);
+ 		return 0;
+ 	}
+ 
+ 	_enter("{%d},{%u,%%%u},", conn->debug_id, sp->hdr.type, sp->hdr.serial);
+ 
+ 	switch (sp->hdr.type) {
+ 	case RXRPC_PACKET_TYPE_BUSY:
+ 		/* Just ignore BUSY packets for now. */
+ 		return 0;
+ 
+ 	case RXRPC_PACKET_TYPE_ABORT:
+ 		conn->error = -ECONNABORTED;
+ 		conn->abort_code = skb->priority;
+ 		conn->state = RXRPC_CONN_REMOTELY_ABORTED;
+ 		set_bit(RXRPC_CONN_DONT_REUSE, &conn->flags);
+ 		rxrpc_abort_calls(conn, RXRPC_CALL_REMOTELY_ABORTED, sp->hdr.serial);
+ 		return 0;
+ 
+ 	case RXRPC_PACKET_TYPE_CHALLENGE:
+ 	case RXRPC_PACKET_TYPE_RESPONSE:
+ 		rxrpc_post_packet_to_conn(conn, skb);
+ 		return 0;
+ 
+ 	default:
+ 		trace_rxrpc_rx_eproto(NULL, sp->hdr.serial,
+ 				      tracepoint_string("bad_conn_pkt"));
+ 		return -EPROTO;
+ 	}
++>>>>>>> 30df927b936b (rxrpc: Separate call retransmission from other conn events)
  }
* Unmerged path net/rxrpc/io_thread.c
diff --git a/net/rxrpc/ar-internal.h b/net/rxrpc/ar-internal.h
index 46ce41afb431..66956022c308 100644
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@ -878,6 +878,8 @@ void rxrpc_clean_up_local_conns(struct rxrpc_local *);
 /*
  * conn_event.c
  */
+void rxrpc_conn_retransmit_call(struct rxrpc_connection *conn, struct sk_buff *skb,
+				unsigned int channel);
 void rxrpc_process_connection(struct work_struct *);
 void rxrpc_process_delayed_final_acks(struct rxrpc_connection *, bool);
 
* Unmerged path net/rxrpc/conn_event.c
* Unmerged path net/rxrpc/io_thread.c
