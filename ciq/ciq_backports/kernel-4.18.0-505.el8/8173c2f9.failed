ice: properly alloc ICE_VSI_LB

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
commit 8173c2f9a1a4a5afcf465a62bc8b616c1fef252d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/8173c2f9.failed

Devlink reload patchset introduced regression. ICE_VSI_LB wasn't
taken into account when doing default allocation. Fix it by adding a
case for ICE_VSI_LB in ice_vsi_alloc_def().

Fixes: 6624e780a577 ("ice: split ice_vsi_setup into smaller functions")
	Reported-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Acked-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Signed-off-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Reviewed-by: Alexander Lobakin <aleksander.lobakin@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8173c2f9a1a4a5afcf465a62bc8b616c1fef252d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index dc99c12b0643,781475480ff2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -448,15 -545,105 +448,111 @@@ static irqreturn_t ice_eswitch_msix_cle
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_vsi_alloc_stat_arrays - Allocate statistics arrays
+  * @vsi: VSI pointer
+  */
+ static int ice_vsi_alloc_stat_arrays(struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_stats *vsi_stat;
+ 	struct ice_pf *pf = vsi->back;
+ 
+ 	if (vsi->type == ICE_VSI_CHNL)
+ 		return 0;
+ 	if (!pf->vsi_stats)
+ 		return -ENOENT;
+ 
+ 	if (pf->vsi_stats[vsi->idx])
+ 	/* realloc will happen in rebuild path */
+ 		return 0;
+ 
+ 	vsi_stat = kzalloc(sizeof(*vsi_stat), GFP_KERNEL);
+ 	if (!vsi_stat)
+ 		return -ENOMEM;
+ 
+ 	vsi_stat->tx_ring_stats =
+ 		kcalloc(vsi->alloc_txq, sizeof(*vsi_stat->tx_ring_stats),
+ 			GFP_KERNEL);
+ 	if (!vsi_stat->tx_ring_stats)
+ 		goto err_alloc_tx;
+ 
+ 	vsi_stat->rx_ring_stats =
+ 		kcalloc(vsi->alloc_rxq, sizeof(*vsi_stat->rx_ring_stats),
+ 			GFP_KERNEL);
+ 	if (!vsi_stat->rx_ring_stats)
+ 		goto err_alloc_rx;
+ 
+ 	pf->vsi_stats[vsi->idx] = vsi_stat;
+ 
+ 	return 0;
+ 
+ err_alloc_rx:
+ 	kfree(vsi_stat->rx_ring_stats);
+ err_alloc_tx:
+ 	kfree(vsi_stat->tx_ring_stats);
+ 	kfree(vsi_stat);
+ 	pf->vsi_stats[vsi->idx] = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ /**
+  * ice_vsi_alloc_def - set default values for already allocated VSI
+  * @vsi: ptr to VSI
+  * @ch: ptr to channel
+  */
+ static int
+ ice_vsi_alloc_def(struct ice_vsi *vsi, struct ice_channel *ch)
+ {
+ 	if (vsi->type != ICE_VSI_CHNL) {
+ 		ice_vsi_set_num_qs(vsi);
+ 		if (ice_vsi_alloc_arrays(vsi))
+ 			return -ENOMEM;
+ 	}
+ 
+ 	switch (vsi->type) {
+ 	case ICE_VSI_SWITCHDEV_CTRL:
+ 		/* Setup eswitch MSIX irq handler for VSI */
+ 		vsi->irq_handler = ice_eswitch_msix_clean_rings;
+ 		break;
+ 	case ICE_VSI_PF:
+ 		/* Setup default MSIX irq handler for VSI */
+ 		vsi->irq_handler = ice_msix_clean_rings;
+ 		break;
+ 	case ICE_VSI_CTRL:
+ 		/* Setup ctrl VSI MSIX irq handler */
+ 		vsi->irq_handler = ice_msix_clean_ctrl_vsi;
+ 		break;
+ 	case ICE_VSI_CHNL:
+ 		if (!ch)
+ 			return -EINVAL;
+ 
+ 		vsi->num_rxq = ch->num_rxq;
+ 		vsi->num_txq = ch->num_txq;
+ 		vsi->next_base_q = ch->base_q;
+ 		break;
+ 	case ICE_VSI_VF:
+ 	case ICE_VSI_LB:
+ 		break;
+ 	default:
+ 		ice_vsi_free_arrays(vsi);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> 8173c2f9a1a4 (ice: properly alloc ICE_VSI_LB)
   * ice_vsi_alloc - Allocates the next available struct VSI in the PF
   * @pf: board private structure
 + * @vsi_type: type of VSI
 + * @ch: ptr to channel
 + * @vf: VF for ICE_VSI_VF and ICE_VSI_CTRL
   *
 - * Reserves a VSI index from the PF and allocates an empty VSI structure
 - * without a type. The VSI structure must later be initialized by calling
 - * ice_vsi_cfg().
 + * The VF pointer is used for ICE_VSI_VF and ICE_VSI_CTRL. For ICE_VSI_CTRL,
 + * it may be NULL in the case there is no association with a VF. For
 + * ICE_VSI_VF the VF pointer *must not* be NULL.
   *
   * returns a pointer to a VSI on success, NULL on failure.
   */
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
