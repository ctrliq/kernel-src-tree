ice: xsk: drop power of 2 ring size restriction for AF_XDP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Maciej Fijalkowski <maciej.fijalkowski@intel.com>
commit b3056ae2b57858b02b376b3fed6077040caf14b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/b3056ae2.failed

We had multiple customers in the past months that reported commit
296f13ff3854 ("ice: xsk: Force rings to be sized to power of 2")
makes them unable to use ring size of 8160 in conjunction with AF_XDP.
Remove this restriction.

Fixes: 296f13ff3854 ("ice: xsk: Force rings to be sized to power of 2")
CC: Alasdair McWilliam <alasdair.mcwilliam@outlook.com>
	Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Tested-by: George Kuruvinakunnel <george.kuruvinakunnel@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit b3056ae2b57858b02b376b3fed6077040caf14b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_xsk.c
diff --cc drivers/net/ethernet/intel/ice/ice_xsk.c
index 97259fed7f51,056c904b83cc..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_xsk.c
+++ b/drivers/net/ethernet/intel/ice/ice_xsk.c
@@@ -474,22 -459,83 +467,60 @@@ bool ice_alloc_rx_bufs_zc(struct ice_rx
  
  		rx_desc++;
  		xdp++;
 -	}
 -
 -	return buffs;
 -}
 -
 -/**
 - * __ice_alloc_rx_bufs_zc - allocate a number of Rx buffers
 - * @rx_ring: Rx ring
 - * @count: The number of buffers to allocate
 - *
 - * Place the @count of descriptors onto Rx ring. Handle the ring wrap
 - * for case where space from next_to_use up to the end of ring is less
 - * than @count. Finally do a tail bump.
 - *
 - * Returns true if all allocations were successful, false if any fail.
 - */
 -static bool __ice_alloc_rx_bufs_zc(struct ice_rx_ring *rx_ring, u16 count)
 -{
 -	u32 nb_buffs_extra = 0, nb_buffs = 0;
 -	union ice_32b_rx_flex_desc *rx_desc;
 -	u16 ntu = rx_ring->next_to_use;
 -	u16 total_count = count;
 -	struct xdp_buff **xdp;
 -
 -	rx_desc = ICE_RX_DESC(rx_ring, ntu);
 -	xdp = ice_xdp_buf(rx_ring, ntu);
 +		ntu++;
  
 -	if (ntu + count >= rx_ring->count) {
 -		nb_buffs_extra = ice_fill_rx_descs(rx_ring->xsk_pool, xdp,
 -						   rx_desc,
 -						   rx_ring->count - ntu);
 -		if (nb_buffs_extra != rx_ring->count - ntu) {
 -			ntu += nb_buffs_extra;
 -			goto exit;
 +		if (unlikely(ntu == rx_ring->count)) {
 +			rx_desc = ICE_RX_DESC(rx_ring, 0);
 +			xdp = rx_ring->xdp_buf;
 +			ntu = 0;
  		}
 -		rx_desc = ICE_RX_DESC(rx_ring, 0);
 -		xdp = ice_xdp_buf(rx_ring, 0);
 -		ntu = 0;
 -		count -= nb_buffs_extra;
 -		ice_release_rx_desc(rx_ring, 0);
 +	} while (--count);
 +
 +	if (rx_ring->next_to_use != ntu) {
 +		/* clear the status bits for the next_to_use descriptor */
 +		rx_desc->wb.status_error0 = 0;
 +		ice_release_rx_desc(rx_ring, ntu);
  	}
  
++<<<<<<< HEAD
 +	return ok;
++=======
+ 	nb_buffs = ice_fill_rx_descs(rx_ring->xsk_pool, xdp, rx_desc, count);
+ 
+ 	ntu += nb_buffs;
+ 	if (ntu == rx_ring->count)
+ 		ntu = 0;
+ 
+ exit:
+ 	if (rx_ring->next_to_use != ntu)
+ 		ice_release_rx_desc(rx_ring, ntu);
+ 
+ 	return total_count == (nb_buffs_extra + nb_buffs);
+ }
+ 
+ /**
+  * ice_alloc_rx_bufs_zc - allocate a number of Rx buffers
+  * @rx_ring: Rx ring
+  * @count: The number of buffers to allocate
+  *
+  * Wrapper for internal allocation routine; figure out how many tail
+  * bumps should take place based on the given threshold
+  *
+  * Returns true if all calls to internal alloc routine succeeded
+  */
+ bool ice_alloc_rx_bufs_zc(struct ice_rx_ring *rx_ring, u16 count)
+ {
+ 	u16 rx_thresh = ICE_RING_QUARTER(rx_ring);
+ 	u16 leftover, i, tail_bumps;
+ 
+ 	tail_bumps = count / rx_thresh;
+ 	leftover = count - (tail_bumps * rx_thresh);
+ 
+ 	for (i = 0; i < tail_bumps; i++)
+ 		if (!__ice_alloc_rx_bufs_zc(rx_ring, rx_thresh))
+ 			return false;
+ 	return __ice_alloc_rx_bufs_zc(rx_ring, leftover);
++>>>>>>> b3056ae2b578 (ice: xsk: drop power of 2 ring size restriction for AF_XDP)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_xsk.c
