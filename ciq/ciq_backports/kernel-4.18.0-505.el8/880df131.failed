kernfs: kernfs_find_and_get_node_by_ino() should only look up activated nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Tejun Heo <tj@kernel.org>
commit 880df131617393252f1fff701ed5b7b6d14c52c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/880df131.failed

kernfs node can be created in two separate steps - allocation and
activation.  This is used to make kernfs nodes visible only after the
internal states attached to the node are fully initialized.
kernfs_find_and_get_node_by_id() currently allows lookups of nodes
which aren't activated yet and thus can expose nodes are which are
still being prepped by kernfs users.

Fix it by disallowing lookups of nodes which aren't activated yet.

kernfs_find_and_get_node_by_ino()

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
(cherry picked from commit 880df131617393252f1fff701ed5b7b6d14c52c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/dir.c
diff --cc fs/kernfs/dir.c
index 8df6c1ed5bee,beabb585a7d8..000000000000
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@@ -674,38 -708,25 +674,48 @@@ struct kernfs_node *kernfs_find_and_get
  {
  	struct kernfs_node *kn;
  
 -	spin_lock(&kernfs_idr_lock);
 -
 +	rcu_read_lock();
  	kn = idr_find(&root->ino_idr, ino);
  	if (!kn)
 -		goto err_unlock;
 +		goto out;
 +
 +	/*
++<<<<<<< HEAD
 +	 * Since kernfs_node is freed in RCU, it's possible an old node for ino
 +	 * is freed, but reused before RCU grace period. But a freed node (see
 +	 * kernfs_put) or an incompletedly initialized node (see
 +	 * __kernfs_new_node) should have 'count' 0. We can use this fact to
 +	 * filter out such node.
 +	 */
 +	if (!atomic_inc_not_zero(&kn->count)) {
 +		kn = NULL;
 +		goto out;
 +	}
  
  	/*
 +	 * The node could be a new node or a reused node. If it's a new node,
 +	 * we are ok. If it's reused because of RCU (because of
 +	 * SLAB_TYPESAFE_BY_RCU), the __kernfs_new_node always sets its 'ino'
 +	 * before 'count'. So if 'count' is uptodate, 'ino' should be uptodate,
 +	 * hence we can use 'ino' to filter stale node.
 +	 */
 +	if (kernfs_ino(kn) != ino)
 +		goto out;
 +	rcu_read_unlock();
++=======
+ 	 * ACTIVATED is protected with kernfs_mutex but it was clear when
+ 	 * @kn was added to idr and we just wanna see it set.  No need to
+ 	 * grab kernfs_mutex.
+ 	 */
+ 	if (unlikely(!(kn->flags & KERNFS_ACTIVATED) ||
+ 		     !atomic_inc_not_zero(&kn->count)))
+ 		goto err_unlock;
++>>>>>>> 880df1316173 (kernfs: kernfs_find_and_get_node_by_ino() should only look up activated nodes)
  
 -	spin_unlock(&kernfs_idr_lock);
  	return kn;
 -err_unlock:
 -	spin_unlock(&kernfs_idr_lock);
 +out:
 +	rcu_read_unlock();
 +	kernfs_put(kn);
  	return NULL;
  }
  
* Unmerged path fs/kernfs/dir.c
