ice: remove comment about not supporting driver reinit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 503d473c983bf04b978d97f522e6039723caf224
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/503d473c.failed

Since commit 31c8db2c4fa7 ("ice: implement devlink reinit action"), the ice
driver does support driver re-initialization via devlink reload. Remove the
stale comment indicating that the driver lacks this support from the
ice_devlink_ops structure.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Cc: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 503d473c983bf04b978d97f522e6039723caf224)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_devlink.c
diff --cc drivers/net/ethernet/intel/ice/ice_devlink.c
index b46d27c224ed,bc44cc220818..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_devlink.c
+++ b/drivers/net/ethernet/intel/ice/ice_devlink.c
@@@ -711,12 -736,526 +711,19 @@@ ice_devlink_port_unsplit(struct devlin
  	return ice_devlink_port_split(devlink, port, 1, extack);
  }
  
 -/**
 - * ice_tear_down_devlink_rate_tree - removes devlink-rate exported tree
 - * @pf: pf struct
 - *
 - * This function tears down tree exported during VF's creation.
 - */
 -void ice_tear_down_devlink_rate_tree(struct ice_pf *pf)
 -{
 -	struct devlink *devlink;
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 -
 -	devlink = priv_to_devlink(pf);
 -
 -	devl_lock(devlink);
 -	mutex_lock(&pf->vfs.table_lock);
 -	ice_for_each_vf(pf, bkt, vf) {
 -		if (vf->devlink_port.devlink_rate)
 -			devl_rate_leaf_destroy(&vf->devlink_port);
 -	}
 -	mutex_unlock(&pf->vfs.table_lock);
 -
 -	devl_rate_nodes_destroy(devlink);
 -	devl_unlock(devlink);
 -}
 -
 -/**
 - * ice_enable_custom_tx - try to enable custom Tx feature
 - * @pf: pf struct
 - *
 - * This function tries to enable custom Tx feature,
 - * it's not possible to enable it, if DCB or ADQ is active.
 - */
 -static bool ice_enable_custom_tx(struct ice_pf *pf)
 -{
 -	struct ice_port_info *pi = ice_get_main_vsi(pf)->port_info;
 -	struct device *dev = ice_pf_to_dev(pf);
 -
 -	if (pi->is_custom_tx_enabled)
 -		/* already enabled, return true */
 -		return true;
 -
 -	if (ice_is_adq_active(pf)) {
 -		dev_err(dev, "ADQ active, can't modify Tx scheduler tree\n");
 -		return false;
 -	}
 -
 -	if (ice_is_dcb_active(pf)) {
 -		dev_err(dev, "DCB active, can't modify Tx scheduler tree\n");
 -		return false;
 -	}
 -
 -	pi->is_custom_tx_enabled = true;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_traverse_tx_tree - traverse Tx scheduler tree
 - * @devlink: devlink struct
 - * @node: current node, used for recursion
 - * @tc_node: tc_node struct, that is treated as a root
 - * @pf: pf struct
 - *
 - * This function traverses Tx scheduler tree and exports
 - * entire structure to the devlink-rate.
 - */
 -static void ice_traverse_tx_tree(struct devlink *devlink, struct ice_sched_node *node,
 -				 struct ice_sched_node *tc_node, struct ice_pf *pf)
 -{
 -	struct devlink_rate *rate_node = NULL;
 -	struct ice_vf *vf;
 -	int i;
 -
 -	if (node->parent == tc_node) {
 -		/* create root node */
 -		rate_node = devl_rate_node_create(devlink, node, node->name, NULL);
 -	} else if (node->vsi_handle &&
 -		   pf->vsi[node->vsi_handle]->vf) {
 -		vf = pf->vsi[node->vsi_handle]->vf;
 -		if (!vf->devlink_port.devlink_rate)
 -			/* leaf nodes doesn't have children
 -			 * so we don't set rate_node
 -			 */
 -			devl_rate_leaf_create(&vf->devlink_port, node,
 -					      node->parent->rate_node);
 -	} else if (node->info.data.elem_type != ICE_AQC_ELEM_TYPE_LEAF &&
 -		   node->parent->rate_node) {
 -		rate_node = devl_rate_node_create(devlink, node, node->name,
 -						  node->parent->rate_node);
 -	}
 -
 -	if (rate_node && !IS_ERR(rate_node))
 -		node->rate_node = rate_node;
 -
 -	for (i = 0; i < node->num_children; i++)
 -		ice_traverse_tx_tree(devlink, node->children[i], tc_node, pf);
 -}
 -
 -/**
 - * ice_devlink_rate_init_tx_topology - export Tx scheduler tree to devlink rate
 - * @devlink: devlink struct
 - * @vsi: main vsi struct
 - *
 - * This function finds a root node, then calls ice_traverse_tx tree, which
 - * traverses the tree and exports it's contents to devlink rate.
 - */
 -int ice_devlink_rate_init_tx_topology(struct devlink *devlink, struct ice_vsi *vsi)
 -{
 -	struct ice_port_info *pi = vsi->port_info;
 -	struct ice_sched_node *tc_node;
 -	struct ice_pf *pf = vsi->back;
 -	int i;
 -
 -	tc_node = pi->root->children[0];
 -	mutex_lock(&pi->sched_lock);
 -	devl_lock(devlink);
 -	for (i = 0; i < tc_node->num_children; i++)
 -		ice_traverse_tx_tree(devlink, tc_node->children[i], tc_node, pf);
 -	devl_unlock(devlink);
 -	mutex_unlock(&pi->sched_lock);
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_set_object_tx_share - sets node scheduling parameter
 - * @pi: devlink struct instance
 - * @node: node struct instance
 - * @bw: bandwidth in bytes per second
 - * @extack: extended netdev ack structure
 - *
 - * This function sets ICE_MIN_BW scheduling BW limit.
 - */
 -static int ice_set_object_tx_share(struct ice_port_info *pi, struct ice_sched_node *node,
 -				   u64 bw, struct netlink_ext_ack *extack)
 -{
 -	int status;
 -
 -	mutex_lock(&pi->sched_lock);
 -	/* converts bytes per second to kilo bits per second */
 -	node->tx_share = div_u64(bw, 125);
 -	status = ice_sched_set_node_bw_lmt(pi, node, ICE_MIN_BW, node->tx_share);
 -	mutex_unlock(&pi->sched_lock);
 -
 -	if (status)
 -		NL_SET_ERR_MSG_MOD(extack, "Can't set scheduling node tx_share");
 -
 -	return status;
 -}
 -
 -/**
 - * ice_set_object_tx_max - sets node scheduling parameter
 - * @pi: devlink struct instance
 - * @node: node struct instance
 - * @bw: bandwidth in bytes per second
 - * @extack: extended netdev ack structure
 - *
 - * This function sets ICE_MAX_BW scheduling BW limit.
 - */
 -static int ice_set_object_tx_max(struct ice_port_info *pi, struct ice_sched_node *node,
 -				 u64 bw, struct netlink_ext_ack *extack)
 -{
 -	int status;
 -
 -	mutex_lock(&pi->sched_lock);
 -	/* converts bytes per second value to kilo bits per second */
 -	node->tx_max = div_u64(bw, 125);
 -	status = ice_sched_set_node_bw_lmt(pi, node, ICE_MAX_BW, node->tx_max);
 -	mutex_unlock(&pi->sched_lock);
 -
 -	if (status)
 -		NL_SET_ERR_MSG_MOD(extack, "Can't set scheduling node tx_max");
 -
 -	return status;
 -}
 -
 -/**
 - * ice_set_object_tx_priority - sets node scheduling parameter
 - * @pi: devlink struct instance
 - * @node: node struct instance
 - * @priority: value representing priority for strict priority arbitration
 - * @extack: extended netdev ack structure
 - *
 - * This function sets priority of node among siblings.
 - */
 -static int ice_set_object_tx_priority(struct ice_port_info *pi, struct ice_sched_node *node,
 -				      u32 priority, struct netlink_ext_ack *extack)
 -{
 -	int status;
 -
 -	if (priority >= 8) {
 -		NL_SET_ERR_MSG_MOD(extack, "Priority should be less than 8");
 -		return -EINVAL;
 -	}
 -
 -	mutex_lock(&pi->sched_lock);
 -	node->tx_priority = priority;
 -	status = ice_sched_set_node_priority(pi, node, node->tx_priority);
 -	mutex_unlock(&pi->sched_lock);
 -
 -	if (status)
 -		NL_SET_ERR_MSG_MOD(extack, "Can't set scheduling node tx_priority");
 -
 -	return status;
 -}
 -
 -/**
 - * ice_set_object_tx_weight - sets node scheduling parameter
 - * @pi: devlink struct instance
 - * @node: node struct instance
 - * @weight: value represeting relative weight for WFQ arbitration
 - * @extack: extended netdev ack structure
 - *
 - * This function sets node weight for WFQ algorithm.
 - */
 -static int ice_set_object_tx_weight(struct ice_port_info *pi, struct ice_sched_node *node,
 -				    u32 weight, struct netlink_ext_ack *extack)
 -{
 -	int status;
 -
 -	if (weight > 200 || weight < 1) {
 -		NL_SET_ERR_MSG_MOD(extack, "Weight must be between 1 and 200");
 -		return -EINVAL;
 -	}
 -
 -	mutex_lock(&pi->sched_lock);
 -	node->tx_weight = weight;
 -	status = ice_sched_set_node_weight(pi, node, node->tx_weight);
 -	mutex_unlock(&pi->sched_lock);
 -
 -	if (status)
 -		NL_SET_ERR_MSG_MOD(extack, "Can't set scheduling node tx_weight");
 -
 -	return status;
 -}
 -
 -/**
 - * ice_get_pi_from_dev_rate - get port info from devlink_rate
 - * @rate_node: devlink struct instance
 - *
 - * This function returns corresponding port_info struct of devlink_rate
 - */
 -static struct ice_port_info *ice_get_pi_from_dev_rate(struct devlink_rate *rate_node)
 -{
 -	struct ice_pf *pf = devlink_priv(rate_node->devlink);
 -
 -	return ice_get_main_vsi(pf)->port_info;
 -}
 -
 -static int ice_devlink_rate_node_new(struct devlink_rate *rate_node, void **priv,
 -				     struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node;
 -	struct ice_port_info *pi;
 -
 -	pi = ice_get_pi_from_dev_rate(rate_node);
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_node->devlink)))
 -		return -EBUSY;
 -
 -	/* preallocate memory for ice_sched_node */
 -	node = devm_kzalloc(ice_hw_to_dev(pi->hw), sizeof(*node), GFP_KERNEL);
 -	*priv = node;
 -
 -	return 0;
 -}
 -
 -static int ice_devlink_rate_node_del(struct devlink_rate *rate_node, void *priv,
 -				     struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node, *tc_node;
 -	struct ice_port_info *pi;
 -
 -	pi = ice_get_pi_from_dev_rate(rate_node);
 -	tc_node = pi->root->children[0];
 -	node = priv;
 -
 -	if (!rate_node->parent || !node || tc_node == node || !extack)
 -		return 0;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_node->devlink)))
 -		return -EBUSY;
 -
 -	/* can't allow to delete a node with children */
 -	if (node->num_children)
 -		return -EINVAL;
 -
 -	mutex_lock(&pi->sched_lock);
 -	ice_free_sched_node(pi, node);
 -	mutex_unlock(&pi->sched_lock);
 -
 -	return 0;
 -}
 -
 -static int ice_devlink_rate_leaf_tx_max_set(struct devlink_rate *rate_leaf, void *priv,
 -					    u64 tx_max, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_leaf->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_max(ice_get_pi_from_dev_rate(rate_leaf),
 -				     node, tx_max, extack);
 -}
 -
 -static int ice_devlink_rate_leaf_tx_share_set(struct devlink_rate *rate_leaf, void *priv,
 -					      u64 tx_share, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_leaf->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_share(ice_get_pi_from_dev_rate(rate_leaf), node,
 -				       tx_share, extack);
 -}
 -
 -static int ice_devlink_rate_leaf_tx_priority_set(struct devlink_rate *rate_leaf, void *priv,
 -						 u32 tx_priority, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_leaf->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_priority(ice_get_pi_from_dev_rate(rate_leaf), node,
 -					  tx_priority, extack);
 -}
 -
 -static int ice_devlink_rate_leaf_tx_weight_set(struct devlink_rate *rate_leaf, void *priv,
 -					       u32 tx_weight, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_leaf->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_weight(ice_get_pi_from_dev_rate(rate_leaf), node,
 -					tx_weight, extack);
 -}
 -
 -static int ice_devlink_rate_node_tx_max_set(struct devlink_rate *rate_node, void *priv,
 -					    u64 tx_max, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_node->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_max(ice_get_pi_from_dev_rate(rate_node),
 -				     node, tx_max, extack);
 -}
 -
 -static int ice_devlink_rate_node_tx_share_set(struct devlink_rate *rate_node, void *priv,
 -					      u64 tx_share, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_node->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_share(ice_get_pi_from_dev_rate(rate_node),
 -				       node, tx_share, extack);
 -}
 -
 -static int ice_devlink_rate_node_tx_priority_set(struct devlink_rate *rate_node, void *priv,
 -						 u32 tx_priority, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_node->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_priority(ice_get_pi_from_dev_rate(rate_node),
 -					  node, tx_priority, extack);
 -}
 -
 -static int ice_devlink_rate_node_tx_weight_set(struct devlink_rate *rate_node, void *priv,
 -					       u32 tx_weight, struct netlink_ext_ack *extack)
 -{
 -	struct ice_sched_node *node = priv;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(rate_node->devlink)))
 -		return -EBUSY;
 -
 -	if (!node)
 -		return 0;
 -
 -	return ice_set_object_tx_weight(ice_get_pi_from_dev_rate(rate_node),
 -					node, tx_weight, extack);
 -}
 -
 -static int ice_devlink_set_parent(struct devlink_rate *devlink_rate,
 -				  struct devlink_rate *parent,
 -				  void *priv, void *parent_priv,
 -				  struct netlink_ext_ack *extack)
 -{
 -	struct ice_port_info *pi = ice_get_pi_from_dev_rate(devlink_rate);
 -	struct ice_sched_node *tc_node, *node, *parent_node;
 -	u16 num_nodes_added;
 -	u32 first_node_teid;
 -	u32 node_teid;
 -	int status;
 -
 -	tc_node = pi->root->children[0];
 -	node = priv;
 -
 -	if (!extack)
 -		return 0;
 -
 -	if (!ice_enable_custom_tx(devlink_priv(devlink_rate->devlink)))
 -		return -EBUSY;
 -
 -	if (!parent) {
 -		if (!node || tc_node == node || node->num_children)
 -			return -EINVAL;
 -
 -		mutex_lock(&pi->sched_lock);
 -		ice_free_sched_node(pi, node);
 -		mutex_unlock(&pi->sched_lock);
 -
 -		return 0;
 -	}
 -
 -	parent_node = parent_priv;
 -
 -	/* if the node doesn't exist, create it */
 -	if (!node->parent) {
 -		mutex_lock(&pi->sched_lock);
 -		status = ice_sched_add_elems(pi, tc_node, parent_node,
 -					     parent_node->tx_sched_layer + 1,
 -					     1, &num_nodes_added, &first_node_teid,
 -					     &node);
 -		mutex_unlock(&pi->sched_lock);
 -
 -		if (status) {
 -			NL_SET_ERR_MSG_MOD(extack, "Can't add a new node");
 -			return status;
 -		}
 -
 -		if (devlink_rate->tx_share)
 -			ice_set_object_tx_share(pi, node, devlink_rate->tx_share, extack);
 -		if (devlink_rate->tx_max)
 -			ice_set_object_tx_max(pi, node, devlink_rate->tx_max, extack);
 -		if (devlink_rate->tx_priority)
 -			ice_set_object_tx_priority(pi, node, devlink_rate->tx_priority, extack);
 -		if (devlink_rate->tx_weight)
 -			ice_set_object_tx_weight(pi, node, devlink_rate->tx_weight, extack);
 -	} else {
 -		node_teid = le32_to_cpu(node->info.node_teid);
 -		mutex_lock(&pi->sched_lock);
 -		status = ice_sched_move_nodes(pi, parent_node, 1, &node_teid);
 -		mutex_unlock(&pi->sched_lock);
 -
 -		if (status)
 -			NL_SET_ERR_MSG_MOD(extack, "Can't move existing node to a new parent");
 -	}
 -
 -	return status;
 -}
 -
 -/**
 - * ice_devlink_reload_up - do reload up after reinit
 - * @devlink: pointer to the devlink instance reloading
 - * @action: the action requested
 - * @limit: limits imposed by userspace, such as not resetting
 - * @actions_performed: on return, indicate what actions actually performed
 - * @extack: netlink extended ACK structure
 - */
 -static int
 -ice_devlink_reload_up(struct devlink *devlink,
 -		      enum devlink_reload_action action,
 -		      enum devlink_reload_limit limit,
 -		      u32 *actions_performed,
 -		      struct netlink_ext_ack *extack)
 -{
 -	struct ice_pf *pf = devlink_priv(devlink);
 -
 -	switch (action) {
 -	case DEVLINK_RELOAD_ACTION_DRIVER_REINIT:
 -		*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
 -		return ice_load(pf);
 -	case DEVLINK_RELOAD_ACTION_FW_ACTIVATE:
 -		*actions_performed = BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE);
 -		return ice_devlink_reload_empr_finish(pf, extack);
 -	default:
 -		WARN_ON(1);
 -		return -EOPNOTSUPP;
 -	}
 -}
 -
  static const struct devlink_ops ice_devlink_ops = {
  	.supported_flash_update_params = DEVLINK_SUPPORT_FLASH_UPDATE_OVERWRITE_MASK,
++<<<<<<< HEAD
 +	.reload_actions = BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE),
 +	/* The ice driver currently does not support driver reinit */
 +	.reload_down = ice_devlink_reload_empr_start,
 +	.reload_up = ice_devlink_reload_empr_finish,
++=======
+ 	.reload_actions = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |
+ 			  BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE),
+ 	.reload_down = ice_devlink_reload_down,
+ 	.reload_up = ice_devlink_reload_up,
++>>>>>>> 503d473c983b (ice: remove comment about not supporting driver reinit)
  	.port_split = ice_devlink_port_split,
  	.port_unsplit = ice_devlink_port_unsplit,
  	.eswitch_mode_get = ice_eswitch_mode_get,
* Unmerged path drivers/net/ethernet/intel/ice/ice_devlink.c
