kernfs: use 64bit inos if ino_t is 64bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Tejun Heo <tj@kernel.org>
commit 40430452fd5da1509177ac597b394614cd3a121f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/40430452.failed

Each kernfs_node is identified with a 64bit ID.  The low 32bit is
exposed as ino and the high gen.  While this already allows using inos
as keys by looking up with wildcard generation number of 0, it's
adding unnecessary complications for 64bit ino archs which can
directly use kernfs_node IDs as inos to uniquely identify each cgroup
instance.

This patch exposes IDs directly as inos on 64bit ino archs.  The
conversion is mostly straight-forward.

* 32bit ino archs behave the same as before.  64bit ino archs now use
  the whole 64bit ID as ino and the generation number is fixed at 1.

* 64bit inos still use the same idr allocator which gurantees that the
  lower 32bits identify the current live instance uniquely and the
  high 32bits are incremented whenever the low bits wrap.  As the
  upper 32bits are no longer used as gen and we don't wanna start ino
  allocation with 33rd bit set, the initial value for highbits
  allocation is changed to 0 on 64bit ino archs.

* blktrace exposes two 32bit numbers - (INO,GEN) pair - to identify
  the issuing cgroup.  Userland builds FILEID_INO32_GEN fids from
  these numbers to look up the cgroups.  To remain compatible with the
  behavior, always output (LOW32,HIGH32) which will be constructed
  back to the original 64bit ID by __kernfs_fh_to_dentry().

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
(cherry picked from commit 40430452fd5da1509177ac597b394614cd3a121f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/dir.c
#	kernel/trace/blktrace.c
diff --cc fs/kernfs/dir.c
index 6d794c22d88d,b2d9f79c4a7c..000000000000
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@@ -602,13 -640,9 +602,13 @@@ static struct kernfs_node *__kernfs_new
  	if (ret < 0)
  		goto err_out2;
  
- 	kn->id = (u64)gen << 32 | ret;
+ 	kn->id = (u64)id_highbits << 32 | ret;
  
 -	atomic_set(&kn->count, 1);
 +	/*
 +	 * set ino first. This RELEASE is paired with atomic_inc_not_zero in
 +	 * kernfs_find_and_get_node_by_ino
 +	 */
 +	atomic_set_release(&kn->count, 1);
  	atomic_set(&kn->active, KN_DEACTIVATED_BIAS);
  	RB_CLEAR_NODE(&kn->rb);
  
@@@ -679,42 -713,35 +679,54 @@@ struct kernfs_node *kernfs_find_and_get
  	ino_t ino = kernfs_id_ino(id);
  	u32 gen = kernfs_id_gen(id);
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	kn = idr_find(&root->ino_idr, ino);
++=======
+ 	spin_lock(&kernfs_idr_lock);
+ 
+ 	kn = idr_find(&root->ino_idr, (u32)ino);
++>>>>>>> 40430452fd5d (kernfs: use 64bit inos if ino_t is 64bit)
  	if (!kn)
 -		goto err_unlock;
 +		goto out;
  
- 	/* 0 matches all generations */
- 	if (unlikely(gen && kernfs_gen(kn) != gen))
- 		goto err_unlock;
+ 	if (sizeof(ino_t) >= sizeof(u64)) {
+ 		/* we looked up with the low 32bits, compare the whole */
+ 		if (kernfs_ino(kn) != ino)
+ 			goto err_unlock;
+ 	} else {
+ 		/* 0 matches all generations */
+ 		if (unlikely(gen && kernfs_gen(kn) != gen))
+ 			goto err_unlock;
+ 	}
  
  	/*
 -	 * ACTIVATED is protected with kernfs_mutex but it was clear when
 -	 * @kn was added to idr and we just wanna see it set.  No need to
 -	 * grab kernfs_mutex.
 +	 * Since kernfs_node is freed in RCU, it's possible an old node for ino
 +	 * is freed, but reused before RCU grace period. But a freed node (see
 +	 * kernfs_put) or an incompletedly initialized node (see
 +	 * __kernfs_new_node) should have 'count' 0. We can use this fact to
 +	 * filter out such node.
  	 */
 -	if (unlikely(!(kn->flags & KERNFS_ACTIVATED) ||
 -		     !atomic_inc_not_zero(&kn->count)))
 -		goto err_unlock;
 +	if (!atomic_inc_not_zero(&kn->count)) {
 +		kn = NULL;
 +		goto out;
 +	}
 +
 +	/*
 +	 * The node could be a new node or a reused node. If it's a new node,
 +	 * we are ok. If it's reused because of RCU (because of
 +	 * SLAB_TYPESAFE_BY_RCU), the __kernfs_new_node always sets its 'ino'
 +	 * before 'count'. So if 'count' is uptodate, 'ino' should be uptodate,
 +	 * hence we can use 'ino' to filter stale node.
 +	 */
 +	if (kernfs_ino(kn) != ino)
 +		goto out;
 +	rcu_read_unlock();
  
 -	spin_unlock(&kernfs_idr_lock);
  	return kn;
 -err_unlock:
 -	spin_unlock(&kernfs_idr_lock);
 +out:
 +	rcu_read_unlock();
 +	kernfs_put(kn);
  	return NULL;
  }
  
@@@ -930,9 -954,18 +942,19 @@@ struct kernfs_root *kernfs_create_root(
  		return ERR_PTR(-ENOMEM);
  
  	idr_init(&root->ino_idr);
 +	init_rwsem(&root->kernfs_rwsem);
  	INIT_LIST_HEAD(&root->supers);
- 	root->next_generation = 1;
+ 
+ 	/*
+ 	 * On 64bit ino setups, id is ino.  On 32bit, low 32bits are ino.
+ 	 * High bits generation.  The starting value for both ino and
+ 	 * genenration is 1.  Initialize upper 32bit allocation
+ 	 * accordingly.
+ 	 */
+ 	if (sizeof(ino_t) >= sizeof(u64))
+ 		root->id_highbits = 0;
+ 	else
+ 		root->id_highbits = 1;
  
  	kn = __kernfs_new_node(root, NULL, "", S_IFDIR | S_IRUGO | S_IXUGO,
  			       GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,
diff --cc kernel/trace/blktrace.c
index 5c9fa4807876,a7dac5b63f3f..000000000000
--- a/kernel/trace/blktrace.c
+++ b/kernel/trace/blktrace.c
@@@ -1321,12 -1261,25 +1321,30 @@@ static void blk_log_action(struct trace
  			trace_seq_printf(&iter->seq, "%3d,%-3d %s %2s %3s ",
  				 MAJOR(t->device), MINOR(t->device),
  				 blkcg_name_buf, act, rwbs);
- 		} else
+ 		} else {
+ 			/*
+ 			 * The cgid portion used to be "INO,GEN".  Userland
+ 			 * builds a FILEID_INO32_GEN fid out of them and
+ 			 * opens the cgroup using open_by_handle_at(2).
+ 			 * While 32bit ino setups are still the same, 64bit
+ 			 * ones now use the 64bit ino as the whole ID and
+ 			 * no longer use generation.
+ 			 *
+ 			 * Regarldess of the content, always output
+ 			 * "LOW32,HIGH32" so that FILEID_INO32_GEN fid can
+ 			 * be mapped back to @id on both 64 and 32bit ino
+ 			 * setups.  See __kernfs_fh_to_dentry().
+ 			 */
  			trace_seq_printf(&iter->seq,
- 				 "%3d,%-3d %lx,%-x %2s %3s ",
+ 				 "%3d,%-3d %llx,%-llx %2s %3s ",
  				 MAJOR(t->device), MINOR(t->device),
++<<<<<<< HEAD
 +				 (unsigned long)kernfs_id_ino(id), kernfs_id_gen(id),
 +				 act, rwbs);
++=======
+ 				 id & U32_MAX, id >> 32, act, rwbs);
+ 		}
++>>>>>>> 40430452fd5d (kernfs: use 64bit inos if ino_t is 64bit)
  	} else
  		trace_seq_printf(&iter->seq, "%3d,%-3d %2s %3s ",
  				 MAJOR(t->device), MINOR(t->device), act, rwbs);
* Unmerged path fs/kernfs/dir.c
diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index a86b64ed4dac..c17c29f13fcb 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -88,9 +88,10 @@ static struct dentry *__kernfs_fh_to_dentry(struct super_block *sb,
 	case FILEID_INO32_GEN:
 	case FILEID_INO32_GEN_PARENT:
 		/*
-		 * blk_log_action() exposes (ino,gen) pair without type and
-		 * userland can call us with generic fid constructed from
-		 * them.  Combine it back to ID.  See blk_log_action().
+		 * blk_log_action() exposes "LOW32,HIGH32" pair without
+		 * type and userland can call us with generic fid
+		 * constructed from them.  Combine it back to ID.  See
+		 * blk_log_action().
 		 */
 		id = ((u64)fid->i32.gen << 32) | fid->i32.ino;
 		break;
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 7c74c8e3cfe8..af9b50dfd58e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -166,8 +166,8 @@ struct kernfs_node {
 	void			*priv;
 
 	/*
-	 * 64bit unique ID.  Lower 32bits carry the inode number and lower
-	 * generation.
+	 * 64bit unique ID.  On 64bit ino setups, id is the ino.  On 32bit,
+	 * the low 32bits are ino and upper generation.
 	 */
 	RH_KABI_REPLACE(union kernfs_node_id	id,
 			u64			id)
@@ -209,8 +209,8 @@ struct kernfs_root {
 
 	/* private fields, do not use outside kernfs proper */
 	struct idr		ino_idr;
-	u32			last_ino;
-	u32			next_generation;
+	u32			last_id_lowbits;
+	u32			id_highbits;
 	struct kernfs_syscall_ops *syscall_ops;
 
 	/* list of kernfs_super_info of this root, protected by kernfs_rwsem */
@@ -317,12 +317,20 @@ static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 
 static inline ino_t kernfs_id_ino(u64 id)
 {
-	return (u32)id;
+	/* id is ino if ino_t is 64bit; otherwise, low 32bits */
+	if (sizeof(ino_t) >= sizeof(u64))
+		return id;
+	else
+		return (u32)id;
 }
 
 static inline u32 kernfs_id_gen(u64 id)
 {
-	return id >> 32;
+	/* gen is fixed at 1 if ino_t is 64bit; otherwise, high 32bits */
+	if (sizeof(ino_t) >= sizeof(u64))
+		return 1;
+	else
+		return id >> 32;
 }
 
 static inline ino_t kernfs_ino(struct kernfs_node *kn)
* Unmerged path kernel/trace/blktrace.c
