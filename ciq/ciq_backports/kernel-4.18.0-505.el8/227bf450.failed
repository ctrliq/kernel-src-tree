ice: move VSI delete outside deconfig

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
commit 227bf4500aaaec1e06b527317e05adf42f0da8b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/227bf450.failed

In deconfig VSI shouldn't be deleted from hw.

Rewrite VSI delete function to reflect that sometimes it is only needed
to remove VSI from hw without freeing the memory:
ice_vsi_delete() -> delete from HW and free memory
ice_vsi_delete_from_hw() -> delete only from HW

Value returned from ice_vsi_free() is never used. Change return type to
void.

	Signed-off-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 227bf4500aaaec1e06b527317e05adf42f0da8b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_lib.h
#	drivers/net/ethernet/intel/ice/ice_main.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 5a7867ad1ffd,1b83f67d1029..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -353,10 -453,8 +353,12 @@@ static void ice_vsi_free_arrays(struct 
   *
   * This deallocates the VSI's queue resources, removes it from the PF's
   * VSI array if necessary, and deallocates the VSI
-  *
-  * Returns 0 on success, negative on failure
   */
++<<<<<<< HEAD
 +int ice_vsi_clear(struct ice_vsi *vsi)
++=======
+ static void ice_vsi_free(struct ice_vsi *vsi)
++>>>>>>> 227bf4500aaa (ice: move VSI delete outside deconfig)
  {
  	struct ice_pf *pf = NULL;
  	struct device *dev;
@@@ -2637,30 -2841,137 +2640,118 @@@ ice_vsi_setup(struct ice_pf *pf, struc
  		goto unroll_vsi_init;
  	}
  
 -	return 0;
 +	/* configure VSI nodes based on number of queues and TC's */
 +	ice_for_each_traffic_class(i) {
 +		if (!(vsi->tc_cfg.ena_tc & BIT(i)))
 +			continue;
  
++<<<<<<< HEAD
 +		if (vsi->type == ICE_VSI_CHNL) {
 +			if (!vsi->alloc_txq && vsi->num_txq)
 +				max_txqs[i] = vsi->num_txq;
 +			else
 +				max_txqs[i] = pf->num_lan_tx;
 +		} else {
 +			max_txqs[i] = vsi->alloc_txq;
 +		}
++=======
+ unroll_vector_base:
+ 	/* reclaim SW interrupts back to the common pool */
+ 	ice_free_res(pf->irq_tracker, vsi->base_vector, vsi->idx);
+ 	pf->num_avail_sw_msix += vsi->num_q_vectors;
+ unroll_alloc_q_vector:
+ 	ice_vsi_free_q_vectors(vsi);
+ unroll_vsi_init:
+ 	ice_vsi_delete_from_hw(vsi);
+ unroll_get_qs:
+ 	ice_vsi_put_qs(vsi);
+ unroll_vsi_alloc_stat:
+ 	ice_vsi_free_stats(vsi);
+ unroll_vsi_alloc:
+ 	ice_vsi_free_arrays(vsi);
+ 	return ret;
+ }
+ 
+ /**
+  * ice_vsi_cfg - configure VSI and tc on it
+  * @vsi: pointer to VSI
+  * @vf: pointer to VF to which this VSI connects. This field is used primarily
+  *      for the ICE_VSI_VF type. Other VSI types should pass NULL.
+  * @ch: ptr to channel
+  */
+ int ice_vsi_cfg(struct ice_vsi *vsi, struct ice_vf *vf, struct ice_channel *ch)
+ {
+ 	int ret;
+ 
+ 	ret = ice_vsi_cfg_def(vsi, vf, ch);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = ice_vsi_cfg_tc_lan(vsi->back, vsi);
+ 	if (ret)
+ 		ice_vsi_decfg(vsi);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * ice_vsi_decfg - remove all VSI configuration
+  * @vsi: pointer to VSI
+  */
+ void ice_vsi_decfg(struct ice_vsi *vsi)
+ {
+ 	struct ice_pf *pf = vsi->back;
+ 	int err;
+ 
+ 	/* The Rx rule will only exist to remove if the LLDP FW
+ 	 * engine is currently stopped
+ 	 */
+ 	if (!ice_is_safe_mode(pf) && vsi->type == ICE_VSI_PF &&
+ 	    !test_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags))
+ 		ice_cfg_sw_lldp(vsi, false, false);
+ 
+ 	ice_fltr_remove_all(vsi);
+ 	ice_rm_vsi_lan_cfg(vsi->port_info, vsi->idx);
+ 	err = ice_rm_vsi_rdma_cfg(vsi->port_info, vsi->idx);
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(pf), "Failed to remove RDMA scheduler config for VSI %u, err %d\n",
+ 			vsi->vsi_num, err);
+ 
+ 	if (ice_is_xdp_ena_vsi(vsi))
+ 		/* return value check can be skipped here, it always returns
+ 		 * 0 if reset is in progress
+ 		 */
+ 		ice_destroy_xdp_rings(vsi);
+ 
+ 	ice_vsi_clear_rings(vsi);
+ 	ice_vsi_free_q_vectors(vsi);
+ 	ice_vsi_put_qs(vsi);
+ 	ice_vsi_free_arrays(vsi);
+ 
+ 	/* SR-IOV determines needed MSIX resources all at once instead of per
+ 	 * VSI since when VFs are spawned we know how many VFs there are and how
+ 	 * many interrupts each VF needs. SR-IOV MSIX resources are also
+ 	 * cleared in the same manner.
+ 	 */
+ 	if (vsi->type == ICE_VSI_CTRL && vsi->vf) {
+ 		ice_free_vf_ctrl_res(pf, vsi);
+ 	} else if (vsi->type != ICE_VSI_VF) {
+ 		/* reclaim SW interrupts back to the common pool */
+ 		ice_free_res(pf->irq_tracker, vsi->base_vector, vsi->idx);
+ 		pf->num_avail_sw_msix += vsi->num_q_vectors;
+ 		vsi->base_vector = 0;
++>>>>>>> 227bf4500aaa (ice: move VSI delete outside deconfig)
  	}
  
 -	if (vsi->type == ICE_VSI_VF &&
 -	    vsi->agg_node && vsi->agg_node->valid)
 -		vsi->agg_node->num_vsis--;
 -	if (vsi->agg_node) {
 -		vsi->agg_node->valid = false;
 -		vsi->agg_node->agg_id = 0;
 -	}
 -}
 -
 -/**
 - * ice_vsi_setup - Set up a VSI by a given type
 - * @pf: board private structure
 - * @pi: pointer to the port_info instance
 - * @vsi_type: VSI type
 - * @vf: pointer to VF to which this VSI connects. This field is used primarily
 - *      for the ICE_VSI_VF type. Other VSI types should pass NULL.
 - * @ch: ptr to channel
 - *
 - * This allocates the sw VSI structure and its queue resources.
 - *
 - * Returns pointer to the successfully allocated and configured VSI sw struct on
 - * success, NULL on failure.
 - */
 -struct ice_vsi *
 -ice_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi,
 -	      enum ice_vsi_type vsi_type, struct ice_vf *vf,
 -	      struct ice_channel *ch)
 -{
 -	struct device *dev = ice_pf_to_dev(pf);
 -	struct ice_vsi *vsi;
 -	int ret;
 -
 -	vsi = ice_vsi_alloc(pf, pi, vsi_type, ch, vf);
 -	if (!vsi) {
 -		dev_err(dev, "could not allocate VSI\n");
 -		return NULL;
 +	dev_dbg(dev, "vsi->tc_cfg.ena_tc = %d\n", vsi->tc_cfg.ena_tc);
 +	ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
 +			      max_txqs);
 +	if (ret) {
 +		dev_err(dev, "VSI %d failed lan queue config, error %d\n",
 +			vsi->vsi_num, ret);
 +		goto unroll_clear_rings;
  	}
  
 -	ret = ice_vsi_cfg(vsi, vf, ch);
 -	if (ret)
 -		goto err_vsi_cfg;
 -
  	/* Add switch rule to drop all Tx Flow Control Frames, of look up
  	 * type ETHERTYPE from VSIs, and restrict malicious VF from sending
  	 * out PAUSE or PFC frames. If enabled, FW can still send FC frames.
@@@ -3087,7 -3310,7 +3178,11 @@@ int ice_vsi_release(struct ice_vsi *vsi
  	 * for ex: during rmmod.
  	 */
  	if (!ice_is_reset_in_progress(pf->state))
++<<<<<<< HEAD
 +		ice_vsi_clear(vsi);
++=======
+ 		ice_vsi_delete(vsi);
++>>>>>>> 227bf4500aaa (ice: move VSI delete outside deconfig)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/intel/ice/ice_lib.h
index dcdf69a693e9,8905f8721a76..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_lib.h
@@@ -42,7 -42,6 +42,10 @@@ void ice_cfg_sw_lldp(struct ice_vsi *vs
  int ice_set_link(struct ice_vsi *vsi, bool ena);
  
  void ice_vsi_delete(struct ice_vsi *vsi);
++<<<<<<< HEAD
 +int ice_vsi_clear(struct ice_vsi *vsi);
++=======
++>>>>>>> 227bf4500aaa (ice: move VSI delete outside deconfig)
  
  int ice_vsi_cfg_tc(struct ice_vsi *vsi, u8 ena_tc);
  
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index 4662285d8d28,a8920bc46982..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -8404,12 -8573,9 +8404,15 @@@ static void ice_remove_q_channels(struc
  		/* clear the VSI from scheduler tree */
  		ice_rm_vsi_lan_cfg(ch->ch_vsi->port_info, ch->ch_vsi->idx);
  
- 		/* Delete VSI from FW */
+ 		/* Delete VSI from FW, PF and HW VSI arrays */
  		ice_vsi_delete(ch->ch_vsi);
  
++<<<<<<< HEAD
 +		/* Delete VSI from PF and HW VSI arrays */
 +		ice_vsi_clear(ch->ch_vsi);
 +
++=======
++>>>>>>> 227bf4500aaa (ice: move VSI delete outside deconfig)
  		/* free the channel */
  		kfree(ch);
  	}
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
