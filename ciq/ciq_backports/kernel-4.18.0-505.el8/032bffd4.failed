fanotify,audit: Allow audit to use the full permission event response

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Richard Guy Briggs <rgb@redhat.com>
commit 032bffd494e3924cc8b854b696ef9b5b7396b883
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/032bffd4.failed

This patch passes the full response so that the audit function can use all
of it. The audit function was updated to log the additional information in
the AUDIT_FANOTIFY record.

Currently the only type of fanotify info that is defined is an audit
rule number, but convert it to hex encoding to future-proof the field.
Hex encoding suggested by Paul Moore <paul@paul-moore.com>.

The {subj,obj}_trust values are {0,1,2}, corresponding to no, yes, unknown.

Sample records:
  type=FANOTIFY msg=audit(1600385147.372:590): resp=2 fan_type=1 fan_info=3137 subj_trust=3 obj_trust=5
  type=FANOTIFY msg=audit(1659730979.839:284): resp=1 fan_type=0 fan_info=0 subj_trust=2 obj_trust=2

	Suggested-by: Steve Grubb <sgrubb@redhat.com>
Link: https://lore.kernel.org/r/3075502.aeNJFYEL58@x2
	Tested-by: Steve Grubb <sgrubb@redhat.com>
	Acked-by: Steve Grubb <sgrubb@redhat.com>
	Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <bcb6d552e517b8751ece153e516d8b073459069c.1675373475.git.rgb@redhat.com>
(cherry picked from commit 032bffd494e3924cc8b854b696ef9b5b7396b883)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/audit.h
#	kernel/auditsc.c
diff --cc include/linux/audit.h
index e3ee332a7338,31086a72e32a..000000000000
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@@ -404,7 -417,7 +405,11 @@@ extern void __audit_log_capset(const st
  extern void __audit_mmap_fd(int fd, int flags);
  extern void __audit_openat2_how(struct open_how *how);
  extern void __audit_log_kern_module(char *name);
++<<<<<<< HEAD
 +extern void __audit_fanotify(unsigned int response);
++=======
+ extern void __audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar);
++>>>>>>> 032bffd494e3 (fanotify,audit: Allow audit to use the full permission event response)
  extern void __audit_tk_injoffset(struct timespec64 offset);
  extern void __audit_ntp_log(const struct audit_ntp_data *ad);
  extern void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,
@@@ -511,10 -524,10 +516,14 @@@ static inline void audit_log_kern_modul
  		__audit_log_kern_module(name);
  }
  
++<<<<<<< HEAD
 +static inline void audit_fanotify(unsigned int response)
++=======
+ static inline void audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar)
++>>>>>>> 032bffd494e3 (fanotify,audit: Allow audit to use the full permission event response)
  {
  	if (!audit_dummy_context())
- 		__audit_fanotify(response);
+ 		__audit_fanotify(response, friar);
  }
  
  static inline void audit_tk_injoffset(struct timespec64 offset)
@@@ -663,7 -680,7 +672,11 @@@ static inline void audit_log_kern_modul
  {
  }
  
++<<<<<<< HEAD
 +static inline void audit_fanotify(unsigned int response)
++=======
+ static inline void audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar)
++>>>>>>> 032bffd494e3 (fanotify,audit: Allow audit to use the full permission event response)
  { }
  
  static inline void audit_tk_injoffset(struct timespec64 offset)
diff --cc kernel/auditsc.c
index 5738817d705e,5a5994659b44..000000000000
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@@ -2686,10 -2878,21 +2687,25 @@@ void __audit_log_kern_module(char *name
  	context->type = AUDIT_KERN_MODULE;
  }
  
++<<<<<<< HEAD
 +void __audit_fanotify(unsigned int response)
- {
- 	audit_log(audit_context(), GFP_KERNEL,
- 		AUDIT_FANOTIFY,	"resp=%u", response);
++=======
+ void __audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar)
++>>>>>>> 032bffd494e3 (fanotify,audit: Allow audit to use the full permission event response)
+ {
+ 	/* {subj,obj}_trust values are {0,1,2}: no,yes,unknown */
+ 	switch (friar->hdr.type) {
+ 	case FAN_RESPONSE_INFO_NONE:
+ 		audit_log(audit_context(), GFP_KERNEL, AUDIT_FANOTIFY,
+ 			  "resp=%u fan_type=%u fan_info=0 subj_trust=2 obj_trust=2",
+ 			  response, FAN_RESPONSE_INFO_NONE);
+ 		break;
+ 	case FAN_RESPONSE_INFO_AUDIT_RULE:
+ 		audit_log(audit_context(), GFP_KERNEL, AUDIT_FANOTIFY,
+ 			  "resp=%u fan_type=%u fan_info=%X subj_trust=%u obj_trust=%u",
+ 			  response, friar->hdr.type, friar->rule_number,
+ 			  friar->subj_trust, friar->obj_trust);
+ 	}
  }
  
  void __audit_tk_injoffset(struct timespec64 offset)
diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c
index 3d7ae3d3bdf1..60afdc51b461 100644
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -108,7 +108,8 @@ static int fanotify_get_response(struct fsnotify_group *group,
 
 	/* Check if the response should be audited */
 	if (event->response & FAN_AUDIT)
-		audit_fanotify(event->response & ~FAN_AUDIT);
+		audit_fanotify(event->response & ~FAN_AUDIT,
+			       &event->audit_rule);
 
 	pr_debug("%s: group=%p event=%p about to return ret=%d\n", __func__,
 		 group, event, ret);
* Unmerged path include/linux/audit.h
* Unmerged path kernel/auditsc.c
