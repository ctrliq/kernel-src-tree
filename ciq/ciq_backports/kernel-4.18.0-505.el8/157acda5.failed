ice: drop unnecessary VF parameter from several VSI functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-505.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 157acda5b1faf896cbe46e8860be02baac2b7f83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-505.el8/157acda5.failed

The vsi->vf pointer gets assigned early on during ice_vsi_alloc. Several
functions currently take a VF pointer, but they can just use the existing
vsi->vf pointer as needed. Modify these functions to drop the unnecessary
VF parameter.

Note that ice_vsi_cfg is not changed as a following change will refactor so
that the VF pointer is assigned during ice_vsi_cfg rather than
ice_vsi_alloc.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Tested-by: Marek Szlosek <marek.szlosek@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 157acda5b1faf896cbe46e8860be02baac2b7f83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index dc99c12b0643,da64216e680e..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -448,8 -545,101 +448,103 @@@ static irqreturn_t ice_eswitch_msix_cle
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_vsi_alloc_stat_arrays - Allocate statistics arrays
+  * @vsi: VSI pointer
+  */
+ static int ice_vsi_alloc_stat_arrays(struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_stats *vsi_stat;
+ 	struct ice_pf *pf = vsi->back;
+ 
+ 	if (vsi->type == ICE_VSI_CHNL)
+ 		return 0;
+ 	if (!pf->vsi_stats)
+ 		return -ENOENT;
+ 
+ 	if (pf->vsi_stats[vsi->idx])
+ 	/* realloc will happen in rebuild path */
+ 		return 0;
+ 
+ 	vsi_stat = kzalloc(sizeof(*vsi_stat), GFP_KERNEL);
+ 	if (!vsi_stat)
+ 		return -ENOMEM;
+ 
+ 	vsi_stat->tx_ring_stats =
+ 		kcalloc(vsi->alloc_txq, sizeof(*vsi_stat->tx_ring_stats),
+ 			GFP_KERNEL);
+ 	if (!vsi_stat->tx_ring_stats)
+ 		goto err_alloc_tx;
+ 
+ 	vsi_stat->rx_ring_stats =
+ 		kcalloc(vsi->alloc_rxq, sizeof(*vsi_stat->rx_ring_stats),
+ 			GFP_KERNEL);
+ 	if (!vsi_stat->rx_ring_stats)
+ 		goto err_alloc_rx;
+ 
+ 	pf->vsi_stats[vsi->idx] = vsi_stat;
+ 
+ 	return 0;
+ 
+ err_alloc_rx:
+ 	kfree(vsi_stat->rx_ring_stats);
+ err_alloc_tx:
+ 	kfree(vsi_stat->tx_ring_stats);
+ 	kfree(vsi_stat);
+ 	pf->vsi_stats[vsi->idx] = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ /**
+  * ice_vsi_alloc_def - set default values for already allocated VSI
+  * @vsi: ptr to VSI
+  * @ch: ptr to channel
+  */
+ static int
+ ice_vsi_alloc_def(struct ice_vsi *vsi, struct ice_channel *ch)
+ {
+ 	if (vsi->type != ICE_VSI_CHNL) {
+ 		ice_vsi_set_num_qs(vsi);
+ 		if (ice_vsi_alloc_arrays(vsi))
+ 			return -ENOMEM;
+ 	}
+ 
+ 	switch (vsi->type) {
+ 	case ICE_VSI_SWITCHDEV_CTRL:
+ 		/* Setup eswitch MSIX irq handler for VSI */
+ 		vsi->irq_handler = ice_eswitch_msix_clean_rings;
+ 		break;
+ 	case ICE_VSI_PF:
+ 		/* Setup default MSIX irq handler for VSI */
+ 		vsi->irq_handler = ice_msix_clean_rings;
+ 		break;
+ 	case ICE_VSI_CTRL:
+ 		/* Setup ctrl VSI MSIX irq handler */
+ 		vsi->irq_handler = ice_msix_clean_ctrl_vsi;
+ 		break;
+ 	case ICE_VSI_CHNL:
+ 		if (!ch)
+ 			return -EINVAL;
+ 
+ 		vsi->num_rxq = ch->num_rxq;
+ 		vsi->num_txq = ch->num_txq;
+ 		vsi->next_base_q = ch->base_q;
+ 		break;
+ 	case ICE_VSI_VF:
+ 		break;
+ 	default:
+ 		ice_vsi_free_arrays(vsi);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> 157acda5b1fa (ice: drop unnecessary VF parameter from several VSI functions)
   * ice_vsi_alloc - Allocates the next available struct VSI in the PF
   * @pf: board private structure
 - * @pi: pointer to the port_info instance
   * @vsi_type: type of VSI
   * @ch: ptr to channel
   * @vf: VF for ICE_VSI_VF and ICE_VSI_CTRL
@@@ -2497,45 -2634,91 +2592,130 @@@ static void ice_set_agg_vsi(struct ice_
  }
  
  /**
++<<<<<<< HEAD
 + * ice_vsi_setup - Set up a VSI by a given type
 + * @pf: board private structure
 + * @pi: pointer to the port_info instance
 + * @vsi_type: VSI type
 + * @vf: pointer to VF to which this VSI connects. This field is used primarily
 + *      for the ICE_VSI_VF type. Other VSI types should pass NULL.
++=======
+  * ice_free_vf_ctrl_res - Free the VF control VSI resource
+  * @pf: pointer to PF structure
+  * @vsi: the VSI to free resources for
+  *
+  * Check if the VF control VSI resource is still in use. If no VF is using it
+  * any more, release the VSI resource. Otherwise, leave it to be cleaned up
+  * once no other VF uses it.
+  */
+ static void ice_free_vf_ctrl_res(struct ice_pf *pf,  struct ice_vsi *vsi)
+ {
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	rcu_read_lock();
+ 	ice_for_each_vf_rcu(pf, bkt, vf) {
+ 		if (vf != vsi->vf && vf->ctrl_vsi_idx != ICE_NO_VSI) {
+ 			rcu_read_unlock();
+ 			return;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	/* No other VFs left that have control VSI. It is now safe to reclaim
+ 	 * SW interrupts back to the common pool.
+ 	 */
+ 	ice_free_res(pf->irq_tracker, vsi->base_vector,
+ 		     ICE_RES_VF_CTRL_VEC_ID);
+ 	pf->num_avail_sw_msix += vsi->num_q_vectors;
+ }
+ 
+ static int ice_vsi_cfg_tc_lan(struct ice_pf *pf, struct ice_vsi *vsi)
+ {
+ 	u16 max_txqs[ICE_MAX_TRAFFIC_CLASS] = { 0 };
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	int ret, i;
+ 
+ 	/* configure VSI nodes based on number of queues and TC's */
+ 	ice_for_each_traffic_class(i) {
+ 		if (!(vsi->tc_cfg.ena_tc & BIT(i)))
+ 			continue;
+ 
+ 		if (vsi->type == ICE_VSI_CHNL) {
+ 			if (!vsi->alloc_txq && vsi->num_txq)
+ 				max_txqs[i] = vsi->num_txq;
+ 			else
+ 				max_txqs[i] = pf->num_lan_tx;
+ 		} else {
+ 			max_txqs[i] = vsi->alloc_txq;
+ 		}
+ 	}
+ 
+ 	dev_dbg(dev, "vsi->tc_cfg.ena_tc = %d\n", vsi->tc_cfg.ena_tc);
+ 	ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
+ 			      max_txqs);
+ 	if (ret) {
+ 		dev_err(dev, "VSI %d failed lan queue config, error %d\n",
+ 			vsi->vsi_num, ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vsi_cfg_def - configure default VSI based on the type
+  * @vsi: pointer to VSI
++>>>>>>> 157acda5b1fa (ice: drop unnecessary VF parameter from several VSI functions)
   * @ch: ptr to channel
 - * @init_vsi: is this an initialization or a reconfigure of the VSI
 + *
 + * This allocates the sw VSI structure and its queue resources.
 + *
 + * Returns pointer to the successfully allocated and configured VSI sw struct on
 + * success, NULL on failure.
   */
++<<<<<<< HEAD
 +struct ice_vsi *
 +ice_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi,
 +	      enum ice_vsi_type vsi_type, struct ice_vf *vf,
 +	      struct ice_channel *ch)
++=======
+ static int
+ ice_vsi_cfg_def(struct ice_vsi *vsi, struct ice_channel *ch, int init_vsi)
++>>>>>>> 157acda5b1fa (ice: drop unnecessary VF parameter from several VSI functions)
  {
 -	struct device *dev = ice_pf_to_dev(vsi->back);
 -	struct ice_pf *pf = vsi->back;
 -	int ret;
 +	u16 max_txqs[ICE_MAX_TRAFFIC_CLASS] = { 0 };
 +	struct device *dev = ice_pf_to_dev(pf);
 +	struct ice_vsi *vsi;
 +	int ret, i;
 +
 +	if (vsi_type == ICE_VSI_CHNL)
 +		vsi = ice_vsi_alloc(pf, vsi_type, ch, NULL);
 +	else if (vsi_type == ICE_VSI_VF || vsi_type == ICE_VSI_CTRL)
 +		vsi = ice_vsi_alloc(pf, vsi_type, NULL, vf);
 +	else
 +		vsi = ice_vsi_alloc(pf, vsi_type, NULL, NULL);
 +
 +	if (!vsi) {
 +		dev_err(dev, "could not allocate VSI\n");
 +		return NULL;
 +	}
  
 +	vsi->port_info = pi;
  	vsi->vsw = pf->first_sw;
++<<<<<<< HEAD
 +	if (vsi->type == ICE_VSI_PF)
 +		vsi->ethtype = ETH_P_PAUSE;
++=======
+ 
+ 	ret = ice_vsi_alloc_def(vsi, ch);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* allocate memory for Tx/Rx ring stat pointers */
+ 	if (ice_vsi_alloc_stat_arrays(vsi))
+ 		goto unroll_vsi_alloc;
++>>>>>>> 157acda5b1fa (ice: drop unnecessary VF parameter from several VSI functions)
  
  	ice_alloc_fd_res(vsi);
  
@@@ -2637,30 -2838,139 +2817,120 @@@
  		goto unroll_vsi_init;
  	}
  
 -	return 0;
 +	/* configure VSI nodes based on number of queues and TC's */
 +	ice_for_each_traffic_class(i) {
 +		if (!(vsi->tc_cfg.ena_tc & BIT(i)))
 +			continue;
  
++<<<<<<< HEAD
 +		if (vsi->type == ICE_VSI_CHNL) {
 +			if (!vsi->alloc_txq && vsi->num_txq)
 +				max_txqs[i] = vsi->num_txq;
 +			else
 +				max_txqs[i] = pf->num_lan_tx;
 +		} else {
 +			max_txqs[i] = vsi->alloc_txq;
 +		}
++=======
+ unroll_vector_base:
+ 	/* reclaim SW interrupts back to the common pool */
+ 	ice_free_res(pf->irq_tracker, vsi->base_vector, vsi->idx);
+ 	pf->num_avail_sw_msix += vsi->num_q_vectors;
+ unroll_alloc_q_vector:
+ 	ice_vsi_free_q_vectors(vsi);
+ unroll_vsi_init:
+ 	ice_vsi_delete_from_hw(vsi);
+ unroll_get_qs:
+ 	ice_vsi_put_qs(vsi);
+ unroll_vsi_alloc_stat:
+ 	ice_vsi_free_stats(vsi);
+ unroll_vsi_alloc:
+ 	ice_vsi_free_arrays(vsi);
+ 	return ret;
+ }
+ 
+ /**
+  * ice_vsi_cfg - configure VSI and tc on it
+  * @vsi: pointer to VSI
+  * @vf: pointer to VF to which this VSI connects. This field is used primarily
+  *      for the ICE_VSI_VF type. Other VSI types should pass NULL.
+  * @ch: ptr to channel
+  * @init_vsi: is this an initialization or a reconfigure of the VSI
+  */
+ int ice_vsi_cfg(struct ice_vsi *vsi, struct ice_vf *vf, struct ice_channel *ch,
+ 		int init_vsi)
+ {
+ 	int ret;
+ 
+ 	ret = ice_vsi_cfg_def(vsi, ch, init_vsi);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = ice_vsi_cfg_tc_lan(vsi->back, vsi);
+ 	if (ret)
+ 		ice_vsi_decfg(vsi);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * ice_vsi_decfg - remove all VSI configuration
+  * @vsi: pointer to VSI
+  */
+ void ice_vsi_decfg(struct ice_vsi *vsi)
+ {
+ 	struct ice_pf *pf = vsi->back;
+ 	int err;
+ 
+ 	/* The Rx rule will only exist to remove if the LLDP FW
+ 	 * engine is currently stopped
+ 	 */
+ 	if (!ice_is_safe_mode(pf) && vsi->type == ICE_VSI_PF &&
+ 	    !test_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags))
+ 		ice_cfg_sw_lldp(vsi, false, false);
+ 
+ 	ice_fltr_remove_all(vsi);
+ 	ice_rm_vsi_lan_cfg(vsi->port_info, vsi->idx);
+ 	err = ice_rm_vsi_rdma_cfg(vsi->port_info, vsi->idx);
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(pf), "Failed to remove RDMA scheduler config for VSI %u, err %d\n",
+ 			vsi->vsi_num, err);
+ 
+ 	if (ice_is_xdp_ena_vsi(vsi))
+ 		/* return value check can be skipped here, it always returns
+ 		 * 0 if reset is in progress
+ 		 */
+ 		ice_destroy_xdp_rings(vsi);
+ 
+ 	ice_vsi_clear_rings(vsi);
+ 	ice_vsi_free_q_vectors(vsi);
+ 	ice_vsi_put_qs(vsi);
+ 	ice_vsi_free_arrays(vsi);
+ 
+ 	/* SR-IOV determines needed MSIX resources all at once instead of per
+ 	 * VSI since when VFs are spawned we know how many VFs there are and how
+ 	 * many interrupts each VF needs. SR-IOV MSIX resources are also
+ 	 * cleared in the same manner.
+ 	 */
+ 	if (vsi->type == ICE_VSI_CTRL && vsi->vf) {
+ 		ice_free_vf_ctrl_res(pf, vsi);
+ 	} else if (vsi->type != ICE_VSI_VF) {
+ 		/* reclaim SW interrupts back to the common pool */
+ 		ice_free_res(pf->irq_tracker, vsi->base_vector, vsi->idx);
+ 		pf->num_avail_sw_msix += vsi->num_q_vectors;
+ 		vsi->base_vector = 0;
++>>>>>>> 157acda5b1fa (ice: drop unnecessary VF parameter from several VSI functions)
  	}
  
 -	if (vsi->type == ICE_VSI_VF &&
 -	    vsi->agg_node && vsi->agg_node->valid)
 -		vsi->agg_node->num_vsis--;
 -	if (vsi->agg_node) {
 -		vsi->agg_node->valid = false;
 -		vsi->agg_node->agg_id = 0;
 -	}
 -}
 -
 -/**
 - * ice_vsi_setup - Set up a VSI by a given type
 - * @pf: board private structure
 - * @pi: pointer to the port_info instance
 - * @vsi_type: VSI type
 - * @vf: pointer to VF to which this VSI connects. This field is used primarily
 - *      for the ICE_VSI_VF type. Other VSI types should pass NULL.
 - * @ch: ptr to channel
 - *
 - * This allocates the sw VSI structure and its queue resources.
 - *
 - * Returns pointer to the successfully allocated and configured VSI sw struct on
 - * success, NULL on failure.
 - */
 -struct ice_vsi *
 -ice_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi,
 -	      enum ice_vsi_type vsi_type, struct ice_vf *vf,
 -	      struct ice_channel *ch)
 -{
 -	struct device *dev = ice_pf_to_dev(pf);
 -	struct ice_vsi *vsi;
 -	int ret;
 -
 -	vsi = ice_vsi_alloc(pf, pi, vsi_type, ch, vf);
 -	if (!vsi) {
 -		dev_err(dev, "could not allocate VSI\n");
 -		return NULL;
 +	dev_dbg(dev, "vsi->tc_cfg.ena_tc = %d\n", vsi->tc_cfg.ena_tc);
 +	ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
 +			      max_txqs);
 +	if (ret) {
 +		dev_err(dev, "VSI %d failed lan queue config, error %d\n",
 +			vsi->vsi_num, ret);
 +		goto unroll_clear_rings;
  	}
  
 -	ret = ice_vsi_cfg(vsi, vf, ch, ICE_VSI_FLAG_INIT);
 -	if (ret)
 -		goto err_vsi_cfg;
 -
  	/* Add switch rule to drop all Tx Flow Control Frames, of look up
  	 * type ETHERTYPE from VSIs, and restrict malicious VF from sending
  	 * out PAUSE or PFC frames. If enabled, FW can still send FC frames.
@@@ -3239,156 -3497,21 +3509,164 @@@ int ice_vsi_rebuild(struct ice_vsi *vsi
  
  	prev_num_q_vectors = ice_vsi_rebuild_get_coalesce(vsi, coalesce);
  
++<<<<<<< HEAD
 +	ice_rm_vsi_lan_cfg(vsi->port_info, vsi->idx);
 +	ret = ice_rm_vsi_rdma_cfg(vsi->port_info, vsi->idx);
++=======
+ 	prev_txq = vsi->num_txq;
+ 	prev_rxq = vsi->num_rxq;
+ 
+ 	ice_vsi_decfg(vsi);
+ 	ret = ice_vsi_cfg_def(vsi, vsi->ch, init_vsi);
++>>>>>>> 157acda5b1fa (ice: drop unnecessary VF parameter from several VSI functions)
  	if (ret)
 -		goto err_vsi_cfg;
 +		dev_err(ice_pf_to_dev(vsi->back), "Failed to remove RDMA scheduler config for VSI %u, err %d\n",
 +			vsi->vsi_num, ret);
 +	ice_vsi_free_q_vectors(vsi);
 +
 +	/* SR-IOV determines needed MSIX resources all at once instead of per
 +	 * VSI since when VFs are spawned we know how many VFs there are and how
 +	 * many interrupts each VF needs. SR-IOV MSIX resources are also
 +	 * cleared in the same manner.
 +	 */
 +	if (vtype != ICE_VSI_VF) {
 +		/* reclaim SW interrupts back to the common pool */
 +		ice_free_res(pf->irq_tracker, vsi->base_vector, vsi->idx);
 +		pf->num_avail_sw_msix += vsi->num_q_vectors;
 +		vsi->base_vector = 0;
 +	}
 +
 +	if (ice_is_xdp_ena_vsi(vsi))
 +		/* return value check can be skipped here, it always returns
 +		 * 0 if reset is in progress
 +		 */
 +		ice_destroy_xdp_rings(vsi);
 +	ice_vsi_put_qs(vsi);
 +	ice_vsi_clear_rings(vsi);
 +	ice_vsi_free_arrays(vsi);
 +	if (vtype == ICE_VSI_VF)
 +		ice_vsi_set_num_qs(vsi, vsi->vf);
 +	else
 +		ice_vsi_set_num_qs(vsi, NULL);
 +
 +	ret = ice_vsi_alloc_arrays(vsi);
 +	if (ret < 0)
 +		goto err_vsi;
 +
 +	ice_vsi_get_qs(vsi);
 +
 +	ice_alloc_fd_res(vsi);
 +	ice_vsi_set_tc_cfg(vsi);
 +
 +	/* Initialize VSI struct elements and create VSI in FW */
 +	ret = ice_vsi_init(vsi, init_vsi);
 +	if (ret < 0)
 +		goto err_vsi;
 +
 +	switch (vtype) {
 +	case ICE_VSI_CTRL:
 +	case ICE_VSI_SWITCHDEV_CTRL:
 +	case ICE_VSI_PF:
 +		ret = ice_vsi_alloc_q_vectors(vsi);
 +		if (ret)
 +			goto err_rings;
 +
 +		ret = ice_vsi_setup_vector_base(vsi);
 +		if (ret)
 +			goto err_vectors;
 +
 +		ret = ice_vsi_set_q_vectors_reg_idx(vsi);
 +		if (ret)
 +			goto err_vectors;
 +
 +		ret = ice_vsi_alloc_rings(vsi);
 +		if (ret)
 +			goto err_vectors;
 +
 +		ice_vsi_map_rings_to_vectors(vsi);
 +
 +		vsi->stat_offsets_loaded = false;
 +		if (ice_is_xdp_ena_vsi(vsi)) {
 +			ret = ice_vsi_determine_xdp_res(vsi);
 +			if (ret)
 +				goto err_vectors;
 +			ret = ice_prepare_xdp_rings(vsi, vsi->xdp_prog);
 +			if (ret)
 +				goto err_vectors;
 +		}
 +		/* ICE_VSI_CTRL does not need RSS so skip RSS processing */
 +		if (vtype != ICE_VSI_CTRL)
 +			/* Do not exit if configuring RSS had an issue, at
 +			 * least receive traffic on first queue. Hence no
 +			 * need to capture return value
 +			 */
 +			if (test_bit(ICE_FLAG_RSS_ENA, pf->flags))
 +				ice_vsi_cfg_rss_lut_key(vsi);
 +
 +		/* disable or enable CRC stripping */
 +		if (vsi->netdev)
 +			ice_vsi_cfg_crc_strip(vsi, !!(vsi->netdev->features &
 +					      NETIF_F_RXFCS));
 +
 +		break;
 +	case ICE_VSI_VF:
 +		ret = ice_vsi_alloc_q_vectors(vsi);
 +		if (ret)
 +			goto err_rings;
 +
 +		ret = ice_vsi_set_q_vectors_reg_idx(vsi);
 +		if (ret)
 +			goto err_vectors;
 +
 +		ret = ice_vsi_alloc_rings(vsi);
 +		if (ret)
 +			goto err_vectors;
 +
 +		vsi->stat_offsets_loaded = false;
 +		break;
 +	case ICE_VSI_CHNL:
 +		if (test_bit(ICE_FLAG_RSS_ENA, pf->flags)) {
 +			ice_vsi_cfg_rss_lut_key(vsi);
 +			ice_vsi_set_rss_flow_fld(vsi);
 +		}
 +		break;
 +	default:
 +		break;
 +	}
 +
 +	/* configure VSI nodes based on number of queues and TC's */
 +	for (i = 0; i < vsi->tc_cfg.numtc; i++) {
 +		/* configure VSI nodes based on number of queues and TC's.
 +		 * ADQ creates VSIs for each TC/Channel but doesn't
 +		 * allocate queues instead it reconfigures the PF queues
 +		 * as per the TC command. So max_txqs should point to the
 +		 * PF Tx queues.
 +		 */
 +		if (vtype == ICE_VSI_CHNL)
 +			max_txqs[i] = pf->num_lan_tx;
 +		else
 +			max_txqs[i] = vsi->alloc_txq;
 +
 +		if (ice_is_xdp_ena_vsi(vsi))
 +			max_txqs[i] += vsi->num_xdp_txq;
 +	}
 +
 +	if (test_bit(ICE_FLAG_TC_MQPRIO, pf->flags))
 +		/* If MQPRIO is set, means channel code path, hence for main
 +		 * VSI's, use TC as 1
 +		 */
 +		ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, 1, max_txqs);
 +	else
 +		ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx,
 +				      vsi->tc_cfg.ena_tc, max_txqs);
  
 -	ret = ice_vsi_cfg_tc_lan(pf, vsi);
  	if (ret) {
 -		if (init_vsi & ICE_VSI_FLAG_INIT) {
 +		dev_err(ice_pf_to_dev(pf), "VSI %d failed lan queue config, error %d\n",
 +			vsi->vsi_num, ret);
 +		if (init_vsi) {
  			ret = -EIO;
 -			goto err_vsi_cfg_tc_lan;
 +			goto err_vectors;
  		} else {
 -			kfree(coalesce);
  			return ice_schedule_reset(pf, ICE_RESET_PFR);
  		}
  	}
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
