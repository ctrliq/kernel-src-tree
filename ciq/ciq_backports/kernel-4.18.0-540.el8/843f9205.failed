net: usb: ax88179_178a: clean up pm calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-540.el8
commit-author Justin Chen <justinpopo6@gmail.com>
commit 843f92052da7694e846e8e12bbe2342845d2033e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-540.el8/843f9205.failed

Instead of passing in_pm flags all over the place, use the private
struct to handle in_pm mode.

	Signed-off-by: Justin Chen <justinpopo6@gmail.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 843f92052da7694e846e8e12bbe2342845d2033e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/ax88179_178a.c
diff --cc drivers/net/usb/ax88179_178a.c
index a5749233f0e8,c641fd4970d1..000000000000
--- a/drivers/net/usb/ax88179_178a.c
+++ b/drivers/net/usb/ax88179_178a.c
@@@ -223,7 -226,7 +238,11 @@@ static int __ax88179_read_cmd(struct us
  }
  
  static int __ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
++<<<<<<< HEAD
 +			       u16 size, void *data, int in_pm)
++=======
+ 			       u16 size, const void *data)
++>>>>>>> 843f92052da7 (net: usb: ax88179_178a: clean up pm calls)
  {
  	int ret;
  	int (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);
@@@ -263,47 -266,6 +282,50 @@@ static void ax88179_write_cmd_async(str
  	}
  }
  
++<<<<<<< HEAD
 +static int ax88179_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
 +				 u16 index, u16 size, void *data)
 +{
 +	int ret;
 +
 +	if (2 == size) {
 +		u16 buf;
 +		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);
 +		le16_to_cpus(&buf);
 +		*((u16 *)data) = buf;
 +	} else if (4 == size) {
 +		u32 buf;
 +		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);
 +		le32_to_cpus(&buf);
 +		*((u32 *)data) = buf;
 +	} else {
 +		ret = __ax88179_read_cmd(dev, cmd, value, index, size, data, 1);
 +	}
 +
 +	return ret;
 +}
 +
 +static int ax88179_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
 +				  u16 index, u16 size, void *data)
 +{
 +	int ret;
 +
 +	if (2 == size) {
 +		u16 buf;
 +		buf = *((u16 *)data);
 +		cpu_to_le16s(&buf);
 +		ret = __ax88179_write_cmd(dev, cmd, value, index,
 +					  size, &buf, 1);
 +	} else {
 +		ret = __ax88179_write_cmd(dev, cmd, value, index,
 +					  size, data, 1);
 +	}
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 843f92052da7 (net: usb: ax88179_178a: clean up pm calls)
  static int ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
  			    u16 size, void *data)
  {
@@@ -476,18 -442,8 +502,13 @@@ static int ax88179_auto_detach(struct u
  {
  	u16 tmp16;
  	u8 tmp8;
++<<<<<<< HEAD
 +	int (*fnr)(struct usbnet *, u8, u16, u16, u16, void *);
 +	int (*fnw)(struct usbnet *, u8, u16, u16, u16, void *);
++=======
++>>>>>>> 843f92052da7 (net: usb: ax88179_178a: clean up pm calls)
  
- 	if (!in_pm) {
- 		fnr = ax88179_read_cmd;
- 		fnw = ax88179_write_cmd;
- 	} else {
- 		fnr = ax88179_read_cmd_nopm;
- 		fnw = ax88179_write_cmd_nopm;
- 	}
- 
- 	if (fnr(dev, AX_ACCESS_EEPROM, 0x43, 1, 2, &tmp16) < 0)
+ 	if (ax88179_read_cmd(dev, AX_ACCESS_EEPROM, 0x43, 1, 2, &tmp16) < 0)
  		return 0;
  
  	if ((tmp16 == 0xFFFF) || (!(tmp16 & 0x0100)))
* Unmerged path drivers/net/usb/ax88179_178a.c
