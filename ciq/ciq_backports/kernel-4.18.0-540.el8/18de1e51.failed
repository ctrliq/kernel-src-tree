gve: add gve_features_check()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-540.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 18de1e517ed37ebaf33e771e46faf052e966e163
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-540.el8/18de1e51.failed

It is suboptimal to attempt skb linearization from ndo_start_xmit()
if a gso skb has pathological layout, or if host stack does not have
access to the payload (TCP direct). Linearization of large skbs
can also fail under memory pressure.

We should instead have an ndo_features_check() so that we can
fallback to GSO, which is supported even for TCP direct,
and generally much more efficient (no payload copy).

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Bailey Forrest <bcf@google.com>
	Cc: Willem de Bruijn <willemb@google.com>
	Cc: Jeroen de Borst <jeroendb@google.com>
	Cc: Praveen Kaligineedi <pkaligineedi@google.com>
	Cc: Shailend Chand <shailend@google.com>
	Cc: Ziwei Xiao <ziweixiao@google.com>
	Reviewed-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 18de1e517ed37ebaf33e771e46faf052e966e163)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/google/gve/gve_tx_dqo.c
diff --cc drivers/net/ethernet/google/gve/gve_tx_dqo.c
index b76143bfd594,f59c4710f118..000000000000
--- a/drivers/net/ethernet/google/gve/gve_tx_dqo.c
+++ b/drivers/net/ethernet/google/gve/gve_tx_dqo.c
@@@ -635,26 -864,27 +645,49 @@@ static int gve_try_tx_skb(struct gve_pr
  	int num_buffer_descs;
  	int total_num_descs;
  
++<<<<<<< HEAD
 +	if (skb_is_gso(skb)) {
 +		/* If TSO doesn't meet HW requirements, attempt to linearize the
 +		 * packet.
++=======
+ 	if (skb_is_gso(skb) && unlikely(ipv6_hopopt_jumbo_remove(skb)))
+ 		goto drop;
+ 
+ 	if (tx->dqo.qpl) {
+ 		/* We do not need to verify the number of buffers used per
+ 		 * packet or per segment in case of TSO as with 2K size buffers
+ 		 * none of the TX packet rules would be violated.
+ 		 *
+ 		 * gve_can_send_tso() checks that each TCP segment of gso_size is
+ 		 * not distributed over more than 9 SKB frags..
++>>>>>>> 18de1e517ed3 (gve: add gve_features_check())
  		 */
 -		num_buffer_descs = DIV_ROUND_UP(skb->len, GVE_TX_BUF_SIZE_DQO);
 +		if (unlikely(!gve_can_send_tso(skb) &&
 +			     skb_linearize(skb) < 0)) {
 +			net_err_ratelimited("%s: Failed to transmit TSO packet\n",
 +					    priv->dev->name);
 +			goto drop;
 +		}
 +
 +		num_buffer_descs = gve_num_buffer_descs_needed(skb);
  	} else {
  		num_buffer_descs = gve_num_buffer_descs_needed(skb);
++<<<<<<< HEAD
 +
 +		if (unlikely(num_buffer_descs > GVE_TX_MAX_DATA_DESCS)) {
 +			if (unlikely(skb_linearize(skb) < 0))
 +				goto drop;
 +
 +			num_buffer_descs = 1;
++=======
+ 		if (!skb_is_gso(skb)) {
+ 			if (unlikely(num_buffer_descs > GVE_TX_MAX_DATA_DESCS)) {
+ 				if (unlikely(skb_linearize(skb) < 0))
+ 					goto drop;
+ 
+ 				num_buffer_descs = 1;
+ 			}
++>>>>>>> 18de1e517ed3 (gve: add gve_features_check())
  		}
  	}
  
diff --git a/drivers/net/ethernet/google/gve/gve_dqo.h b/drivers/net/ethernet/google/gve/gve_dqo.h
index 1eb4d5fd8561..c36b93f0de15 100644
--- a/drivers/net/ethernet/google/gve/gve_dqo.h
+++ b/drivers/net/ethernet/google/gve/gve_dqo.h
@@ -33,6 +33,9 @@
 #define GVE_DEALLOCATE_COMPL_TIMEOUT 60
 
 netdev_tx_t gve_tx_dqo(struct sk_buff *skb, struct net_device *dev);
+netdev_features_t gve_features_check_dqo(struct sk_buff *skb,
+					 struct net_device *dev,
+					 netdev_features_t features);
 bool gve_tx_poll_dqo(struct gve_notify_block *block, bool do_clean);
 int gve_rx_poll_dqo(struct gve_notify_block *block, int budget);
 int gve_tx_alloc_rings_dqo(struct gve_priv *priv);
diff --git a/drivers/net/ethernet/google/gve/gve_main.c b/drivers/net/ethernet/google/gve/gve_main.c
index eaa59b839505..4a2ff7ef126f 100644
--- a/drivers/net/ethernet/google/gve/gve_main.c
+++ b/drivers/net/ethernet/google/gve/gve_main.c
@@ -79,6 +79,18 @@ static int gve_verify_driver_compatibility(struct gve_priv *priv)
 	return err;
 }
 
+static netdev_features_t gve_features_check(struct sk_buff *skb,
+					    struct net_device *dev,
+					    netdev_features_t features)
+{
+	struct gve_priv *priv = netdev_priv(dev);
+
+	if (!gve_is_gqi(priv))
+		return gve_features_check_dqo(skb, dev, features);
+
+	return features;
+}
+
 static netdev_tx_t gve_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct gve_priv *priv = netdev_priv(dev);
@@ -1870,6 +1882,7 @@ static int gve_set_features(struct net_device *netdev,
 
 static const struct net_device_ops gve_netdev_ops = {
 	.ndo_start_xmit		=	gve_start_xmit,
+	.ndo_features_check	=	gve_features_check,
 	.ndo_open		=	gve_open,
 	.ndo_stop		=	gve_close,
 	.ndo_get_stats64	=	gve_get_stats,
* Unmerged path drivers/net/ethernet/google/gve/gve_tx_dqo.c
