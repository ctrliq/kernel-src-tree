cpufreq: intel_pstate: hybrid: Use known scaling factor for P-cores

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.15.1.rt7.278.el8_8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit f5c8cf2a4992dd929fa0c2f25c09ee69b8dcbce1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.15.1.rt7.278.el8_8/f5c8cf2a.failed

Commit 46573fd6369f ("cpufreq: intel_pstate: hybrid: Rework HWP
calibration") attempted to use the information from CPPC (the nominal
performance in particular) to obtain the scaling factor allowing the
frequency to be computed if the HWP performance level of the given CPU
is known or vice versa.

However, it turns out that on some platforms this doesn't work, because
the CPPC information on them does not align with the contents of the
MSR_HWP_CAPABILITIES registers.

This basically means that the only way to make intel_pstate work on all
of the hybrid platforms to date is to use the observation that on all
of them the scaling factor between the HWP performance levels and
frequency for P-cores is 78741 (approximately 100000/1.27).  For
E-cores it is 100000, which is the same as for all of the non-hybrid
"core" platforms and does not require any changes.

Accordingly, make intel_pstate use 78741 as the scaling factor between
HWP performance levels and frequency for P-cores on all hybrid platforms
and drop the dependency of the HWP calibration code on CPPC.

Fixes: 46573fd6369f ("cpufreq: intel_pstate: hybrid: Rework HWP calibration")
	Reported-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Tested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Cc: 5.15+ <stable@vger.kernel.org> # 5.15+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit f5c8cf2a4992dd929fa0c2f25c09ee69b8dcbce1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 3dee3fe5c18e,6ff73c30769f..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -531,12 -522,10 +522,19 @@@ static void intel_pstate_hybrid_hwp_adj
  {
  	int perf_ctl_max_phys = cpu->pstate.max_pstate_physical;
  	int perf_ctl_scaling = cpu->pstate.perf_ctl_scaling;
++<<<<<<< HEAD
 +	int perf_ctl_turbo = pstate_funcs.get_turbo();
 +	int turbo_freq = perf_ctl_turbo * perf_ctl_scaling;
 +	int scaling = cpu->pstate.scaling;
 +
 +	pr_debug("CPU%d: perf_ctl_max_phys = %d\n", cpu->cpu, perf_ctl_max_phys);
 +	pr_debug("CPU%d: perf_ctl_max = %d\n", cpu->cpu, pstate_funcs.get_max());
++=======
+ 	int perf_ctl_turbo = pstate_funcs.get_turbo(cpu->cpu);
+ 	int scaling = cpu->pstate.scaling;
+ 
+ 	pr_debug("CPU%d: perf_ctl_max_phys = %d\n", cpu->cpu, perf_ctl_max_phys);
++>>>>>>> f5c8cf2a4992 (cpufreq: intel_pstate: hybrid: Use known scaling factor for P-cores)
  	pr_debug("CPU%d: perf_ctl_turbo = %d\n", cpu->cpu, perf_ctl_turbo);
  	pr_debug("CPU%d: perf_ctl_scaling = %d\n", cpu->cpu, perf_ctl_scaling);
  	pr_debug("CPU%d: HWP_CAP guaranteed = %d\n", cpu->cpu, cpu->pstate.max_pstate);
* Unmerged path drivers/cpufreq/intel_pstate.c
