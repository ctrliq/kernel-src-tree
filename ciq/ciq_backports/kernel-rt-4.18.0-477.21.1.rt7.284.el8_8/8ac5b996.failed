xfs: fix off-by-one-block in xfs_discard_folio()

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.21.1.rt7.284.el8_8
commit-author Dave Chinner <dchinner@redhat.com>
commit 8ac5b996bf5199f15b7687ceae989f8b2a410dda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.21.1.rt7.284.el8_8/8ac5b996.failed

The recent writeback corruption fixes changed the code in
xfs_discard_folio() to calculate a byte range to for punching
delalloc extents. A mistake was made in using round_up(pos) for the
end offset, because when pos points at the first byte of a block, it
does not get rounded up to point to the end byte of the block. hence
the punch range is short, and this leads to unexpected behaviour in
certain cases in xfs_bmap_punch_delalloc_range.

e.g. pos = 0 means we call xfs_bmap_punch_delalloc_range(0,0), so
there is no previous extent and it rounds up the punch to the end of
the delalloc extent it found at offset 0, not the end of the range
given to xfs_bmap_punch_delalloc_range().

Fix this by handling the zero block offset case correctly.

Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=217030
Link: https://lore.kernel.org/linux-xfs/Y+vOfaxIWX1c%2Fyy9@bfoster/
Fixes: 7348b322332d ("xfs: xfs_bmap_punch_delalloc_range() should take a byte range")
	Reported-by: Pengfei Xu <pengfei.xu@intel.com>
Found-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 8ac5b996bf5199f15b7687ceae989f8b2a410dda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_aops.c
diff --cc fs/xfs/xfs_aops.c
index 60870f8fd954,2ef78aa1d3f6..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -426,40 -449,44 +426,54 @@@ xfs_prepare_ioend
  }
  
  /*
-  * If the page has delalloc blocks on it, we need to punch them out before we
-  * invalidate the page.  If we don't, we leave a stale delalloc mapping on the
-  * inode that can trip up a later direct I/O read operation on the same region.
+  * If the folio has delalloc blocks on it, the caller is asking us to punch them
+  * out. If we don't, we can leave a stale delalloc mapping covered by a clean
+  * page that needs to be dirtied again before the delalloc mapping can be
+  * converted. This stale delalloc mapping can trip up a later direct I/O read
+  * operation on the same region.
   *
-  * We prevent this by truncating away the delalloc regions on the page.  Because
+  * We prevent this by truncating away the delalloc regions on the folio. Because
   * they are delalloc, we can do this without needing a transaction. Indeed - if
   * we get ENOSPC errors, we have to be able to do this truncation without a
-  * transaction as there is no space left for block reservation (typically why we
-  * see a ENOSPC in writeback).
+  * transaction as there is no space left for block reservation (typically why
+  * we see a ENOSPC in writeback).
   */
  static void
 -xfs_discard_folio(
 -	struct folio		*folio,
 -	loff_t			pos)
 +xfs_discard_page(
 +	struct page		*page)
  {
 -	struct xfs_inode	*ip = XFS_I(folio->mapping->host);
 +	struct inode		*inode = page->mapping->host;
 +	struct xfs_inode	*ip = XFS_I(inode);
  	struct xfs_mount	*mp = ip->i_mount;
 +	loff_t			offset = page_offset(page);
 +	xfs_fileoff_t		start_fsb = XFS_B_TO_FSBT(mp, offset);
  	int			error;
  
 -	if (xfs_is_shutdown(mp))
 -		return;
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		goto out_invalidate;
  
  	xfs_alert_ratelimited(mp,
 -		"page discard on page "PTR_FMT", inode 0x%llx, pos %llu.",
 -			folio, ip->i_ino, pos);
 -
 +		"page discard on page "PTR_FMT", inode 0x%llx, offset %llu.",
 +			page, ip->i_ino, offset);
 +
++<<<<<<< HEAD
 +	error = xfs_bmap_punch_delalloc_range(ip, start_fsb,
 +			PAGE_SIZE / i_blocksize(inode));
 +	if (error && !XFS_FORCED_SHUTDOWN(mp))
++=======
+ 	/*
+ 	 * The end of the punch range is always the offset of the the first
+ 	 * byte of the next folio. Hence the end offset is only dependent on the
+ 	 * folio itself and not the start offset that is passed in.
+ 	 */
+ 	error = xfs_bmap_punch_delalloc_range(ip, pos,
+ 				folio_pos(folio) + folio_size(folio));
+ 
+ 	if (error && !xfs_is_shutdown(mp))
++>>>>>>> 8ac5b996bf51 (xfs: fix off-by-one-block in xfs_discard_folio())
  		xfs_alert(mp, "page discard unable to remove delalloc mapping.");
 +out_invalidate:
 +	iomap_invalidatepage(page, 0, PAGE_SIZE);
  }
  
  static const struct iomap_writeback_ops xfs_writeback_ops = {
* Unmerged path fs/xfs/xfs_aops.c
