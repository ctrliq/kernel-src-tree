iomap: switch iomap_fiemap to use iomap_iter

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.21.1.rt7.284.el8_8
commit-author Christoph Hellwig <hch@lst.de>
commit 7892386d35715d14c469ec98b6deab037e2e2232
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.21.1.rt7.284.el8_8/7892386d.failed

Rewrite the ->fiemap implementation based on iomap_iter.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 7892386d35715d14c469ec98b6deab037e2e2232)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/fiemap.c
diff --cc fs/iomap/fiemap.c
index 7f843772f7dc,acad09a8c188..000000000000
--- a/fs/iomap/fiemap.c
+++ b/fs/iomap/fiemap.c
@@@ -6,14 -6,10 +6,9 @@@
  #include <linux/compiler.h>
  #include <linux/fs.h>
  #include <linux/iomap.h>
 -#include <linux/fiemap.h>
  
- struct fiemap_ctx {
- 	struct fiemap_extent_info *fi;
- 	struct iomap prev;
- };
- 
  static int iomap_to_fiemap(struct fiemap_extent_info *fi,
- 		struct iomap *iomap, u32 flags)
+ 		const struct iomap *iomap, u32 flags)
  {
  	switch (iomap->type) {
  	case IOMAP_HOLE:
@@@ -67,40 -61,26 +60,53 @@@ static loff_t iomap_fiemap_iter(const s
  int iomap_fiemap(struct inode *inode, struct fiemap_extent_info *fi,
  		u64 start, u64 len, const struct iomap_ops *ops)
  {
- 	struct fiemap_ctx ctx;
- 	loff_t ret;
+ 	struct iomap_iter iter = {
+ 		.inode		= inode,
+ 		.pos		= start,
+ 		.len		= len,
+ 		.flags		= IOMAP_REPORT,
+ 	};
+ 	struct iomap prev = {
+ 		.type		= IOMAP_HOLE,
+ 	};
+ 	int ret;
  
++<<<<<<< HEAD
 +	memset(&ctx, 0, sizeof(ctx));
 +	ctx.fi = fi;
 +	ctx.prev.type = IOMAP_HOLE;
 +
 +	ret = fiemap_check_flags(fi, FIEMAP_FLAG_SYNC);
 +	if (ret)
 +		return ret;
 +
 +	if (fi->fi_flags & FIEMAP_FLAG_SYNC) {
 +		ret = filemap_write_and_wait(inode->i_mapping);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	while (len > 0) {
 +		ret = iomap_apply(inode, start, len, IOMAP_REPORT, ops, &ctx,
 +				iomap_fiemap_actor);
 +		/* inode with no (attribute) mapping will give ENOENT */
 +		if (ret == -ENOENT)
 +			break;
 +		if (ret < 0)
 +			return ret;
 +		if (ret == 0)
 +			break;
++=======
+ 	ret = fiemap_prep(inode, fi, start, &iter.len, 0);
+ 	if (ret)
+ 		return ret;
  
- 		start += ret;
- 		len -= ret;
- 	}
+ 	while ((ret = iomap_iter(&iter, ops)) > 0)
+ 		iter.processed = iomap_fiemap_iter(&iter, fi, &prev);
++>>>>>>> 7892386d3571 (iomap: switch iomap_fiemap to use iomap_iter)
  
- 	if (ctx.prev.type != IOMAP_HOLE) {
- 		ret = iomap_to_fiemap(fi, &ctx.prev, FIEMAP_EXTENT_LAST);
+ 	if (prev.type != IOMAP_HOLE) {
+ 		ret = iomap_to_fiemap(fi, &prev, FIEMAP_EXTENT_LAST);
  		if (ret < 0)
  			return ret;
  	}
* Unmerged path fs/iomap/fiemap.c
