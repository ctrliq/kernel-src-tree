tracing/osnoise: Make osnoise_instances static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Daniel Bristot de Oliveira <bristot@kernel.org>
commit d7458bc0d8b409460713228d2ed279addb38947a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/d7458bc0.failed

Make the struct list_head osnoise_instances definition static.

Link: https://lore.kernel.org/all/202111120052.ZuikQSJi-lkp@intel.com/
Link: https://lkml.kernel.org/r/d001f0eeac66e2b2eeec7d2a15e9e7abede0453a.1636667971.git.bristot@kernel.org

	Cc: Ingo Molnar <mingo@redhat.com>
Fixes: dae181349f1e ("tracing/osnoise: Support a list of trace_array *tr")
	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Daniel Bristot de Oliveira <bristot@kernel.org>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit d7458bc0d8b409460713228d2ed279addb38947a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_osnoise.c
diff --cc kernel/trace/trace_osnoise.c
index 0910c9b6898e,7520d43aed55..000000000000
--- a/kernel/trace/trace_osnoise.c
+++ b/kernel/trace/trace_osnoise.c
@@@ -51,6 -49,100 +51,103 @@@ static struct trace_array	*osnoise_trac
  #define DEFAULT_TIMERLAT_PRIO	95			/* FIFO 95 */
  
  /*
++<<<<<<< HEAD
++=======
+  * trace_array of the enabled osnoise/timerlat instances.
+  */
+ struct osnoise_instance {
+ 	struct list_head	list;
+ 	struct trace_array	*tr;
+ };
+ 
+ static struct list_head osnoise_instances;
+ 
+ static bool osnoise_has_registered_instances(void)
+ {
+ 	return !!list_first_or_null_rcu(&osnoise_instances,
+ 					struct osnoise_instance,
+ 					list);
+ }
+ 
+ /*
+  * osnoise_instance_registered - check if a tr is already registered
+  */
+ static int osnoise_instance_registered(struct trace_array *tr)
+ {
+ 	struct osnoise_instance *inst;
+ 	int found = 0;
+ 
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(inst, &osnoise_instances, list) {
+ 		if (inst->tr == tr)
+ 			found = 1;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return found;
+ }
+ 
+ /*
+  * osnoise_register_instance - register a new trace instance
+  *
+  * Register a trace_array *tr in the list of instances running
+  * osnoise/timerlat tracers.
+  */
+ static int osnoise_register_instance(struct trace_array *tr)
+ {
+ 	struct osnoise_instance *inst;
+ 
+ 	/*
+ 	 * register/unregister serialization is provided by trace's
+ 	 * trace_types_lock.
+ 	 */
+ 	lockdep_assert_held(&trace_types_lock);
+ 
+ 	inst = kmalloc(sizeof(*inst), GFP_KERNEL);
+ 	if (!inst)
+ 		return -ENOMEM;
+ 
+ 	INIT_LIST_HEAD_RCU(&inst->list);
+ 	inst->tr = tr;
+ 	list_add_tail_rcu(&inst->list, &osnoise_instances);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  *  osnoise_unregister_instance - unregister a registered trace instance
+  *
+  * Remove the trace_array *tr from the list of instances running
+  * osnoise/timerlat tracers.
+  */
+ static void osnoise_unregister_instance(struct trace_array *tr)
+ {
+ 	struct osnoise_instance *inst;
+ 	int found = 0;
+ 
+ 	/*
+ 	 * register/unregister serialization is provided by trace's
+ 	 * trace_types_lock.
+ 	 */
+ 	lockdep_assert_held(&trace_types_lock);
+ 
+ 	list_for_each_entry_rcu(inst, &osnoise_instances, list) {
+ 		if (inst->tr == tr) {
+ 			list_del_rcu(&inst->list);
+ 			found = 1;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found)
+ 		return;
+ 
+ 	synchronize_rcu();
+ 	kfree(inst);
+ }
+ 
+ /*
++>>>>>>> d7458bc0d8b4 (tracing/osnoise: Make osnoise_instances static)
   * NMI runtime info.
   */
  struct osn_nmi {
* Unmerged path kernel/trace/trace_osnoise.c
