NFSD: Add helper to decode OPEN's openflag4 argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit e6ec04b27bfb4869c0e35fbcf24333d379f101d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/e6ec04b2.failed

Refactor for clarity.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit e6ec04b27bfb4869c0e35fbcf24333d379f101d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 730647def9cd,59d0290b242e..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -913,6 -946,70 +913,73 @@@ nfsd4_decode_lookup(struct nfsd4_compou
  	return nfsd4_decode_component4(argp, &lookup->lo_name, &lookup->lo_len);
  }
  
++<<<<<<< HEAD
++=======
+ static __be32
+ nfsd4_decode_createhow4(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)
+ {
+ 	__be32 status;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &open->op_createmode) < 0)
+ 		return nfserr_bad_xdr;
+ 	switch (open->op_createmode) {
+ 	case NFS4_CREATE_UNCHECKED:
+ 	case NFS4_CREATE_GUARDED:
+ 		status = nfsd4_decode_fattr4(argp, open->op_bmval,
+ 					     ARRAY_SIZE(open->op_bmval),
+ 					     &open->op_iattr, &open->op_acl,
+ 					     &open->op_label, &open->op_umask);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	case NFS4_CREATE_EXCLUSIVE:
+ 		status = nfsd4_decode_verifier4(argp, &open->op_verf);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	case NFS4_CREATE_EXCLUSIVE4_1:
+ 		if (argp->minorversion < 1)
+ 			return nfserr_bad_xdr;
+ 		status = nfsd4_decode_verifier4(argp, &open->op_verf);
+ 		if (status)
+ 			return status;
+ 		status = nfsd4_decode_fattr4(argp, open->op_bmval,
+ 					     ARRAY_SIZE(open->op_bmval),
+ 					     &open->op_iattr, &open->op_acl,
+ 					     &open->op_label, &open->op_umask);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	default:
+ 		return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_openflag4(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)
+ {
+ 	__be32 status;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &open->op_create) < 0)
+ 		return nfserr_bad_xdr;
+ 	switch (open->op_create) {
+ 	case NFS4_OPEN_NOCREATE:
+ 		break;
+ 	case NFS4_OPEN_CREATE:
+ 		status = nfsd4_decode_createhow4(argp, open);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	default:
+ 		return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
++>>>>>>> e6ec04b27bfb (NFSD: Add helper to decode OPEN's openflag4 argument)
  static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)
  {
  	__be32 *p;
@@@ -1024,45 -1104,9 +1091,51 @@@ nfsd4_decode_open(struct nfsd4_compound
  	status = nfsd4_decode_opaque(argp, &open->op_owner);
  	if (status)
  		goto xdr_error;
++<<<<<<< HEAD
 +	READ_BUF(4);
 +	open->op_create = be32_to_cpup(p++);
 +	switch (open->op_create) {
 +	case NFS4_OPEN_NOCREATE:
 +		break;
 +	case NFS4_OPEN_CREATE:
 +		READ_BUF(4);
 +		open->op_createmode = be32_to_cpup(p++);
 +		switch (open->op_createmode) {
 +		case NFS4_CREATE_UNCHECKED:
 +		case NFS4_CREATE_GUARDED:
 +			status = nfsd4_decode_fattr(argp, open->op_bmval,
 +				&open->op_iattr, &open->op_acl, &open->op_label,
 +				&open->op_umask);
 +			if (status)
 +				goto out;
 +			break;
 +		case NFS4_CREATE_EXCLUSIVE:
 +			READ_BUF(NFS4_VERIFIER_SIZE);
 +			COPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);
 +			break;
 +		case NFS4_CREATE_EXCLUSIVE4_1:
 +			if (argp->minorversion < 1)
 +				goto xdr_error;
 +			READ_BUF(NFS4_VERIFIER_SIZE);
 +			COPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);
 +			status = nfsd4_decode_fattr(argp, open->op_bmval,
 +				&open->op_iattr, &open->op_acl, &open->op_label,
 +				&open->op_umask);
 +			if (status)
 +				goto out;
 +			break;
 +		default:
 +			goto xdr_error;
 +		}
 +		break;
 +	default:
 +		goto xdr_error;
 +	}
++=======
+ 	status = nfsd4_decode_openflag4(argp, open);
+ 	if (status)
+ 		return status;
++>>>>>>> e6ec04b27bfb (NFSD: Add helper to decode OPEN's openflag4 argument)
  
  	/* open_claim */
  	READ_BUF(4);
* Unmerged path fs/nfsd/nfs4xdr.c
