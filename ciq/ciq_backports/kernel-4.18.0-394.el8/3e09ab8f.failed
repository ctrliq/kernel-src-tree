xfs: move the di_flags2 field to struct xfs_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 3e09ab8fdc4d4c9d0afee7a63a3b39e5ade3c863
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/3e09ab8f.failed

In preparation of removing the historic icinode struct, move the flags2
field into the containing xfs_inode structure.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 3e09ab8fdc4d4c9d0afee7a63a3b39e5ade3c863)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_inode_buf.h
#	fs/xfs/xfs_file.c
#	fs/xfs/xfs_icache.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_inode.h
#	fs/xfs/xfs_inode_item.c
#	fs/xfs/xfs_ioctl.c
#	fs/xfs/xfs_itable.c
#	fs/xfs/xfs_reflink.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 671aeb012e3f,82ee4b6ca787..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -239,8 -240,8 +239,13 @@@ xfs_inode_from_disk
  		inode_set_iversion_queried(inode,
  					   be64_to_cpu(from->di_changecount));
  		to->di_crtime = xfs_inode_from_disk_ts(from, from->di_crtime);
++<<<<<<< HEAD
 +		to->di_flags2 = be64_to_cpu(from->di_flags2);
 +		to->di_cowextsize = be32_to_cpu(from->di_cowextsize);
++=======
+ 		ip->i_diflags2 = be64_to_cpu(from->di_flags2);
+ 		ip->i_cowextsize = be32_to_cpu(from->di_cowextsize);
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	}
  
  	error = xfs_iformat_data_fork(ip, from);
@@@ -318,8 -319,8 +323,13 @@@ xfs_inode_to_disk
  		to->di_version = 3;
  		to->di_changecount = cpu_to_be64(inode_peek_iversion(inode));
  		to->di_crtime = xfs_inode_to_disk_ts(ip, from->di_crtime);
++<<<<<<< HEAD
 +		to->di_flags2 = cpu_to_be64(from->di_flags2);
 +		to->di_cowextsize = cpu_to_be32(from->di_cowextsize);
++=======
+ 		to->di_flags2 = cpu_to_be64(ip->i_diflags2);
+ 		to->di_cowextsize = cpu_to_be32(ip->i_cowextsize);
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  		to->di_ino = cpu_to_be64(ip->i_ino);
  		to->di_lsn = cpu_to_be64(lsn);
  		memset(to->di_pad2, 0, sizeof(to->di_pad2));
diff --cc fs/xfs/libxfs/xfs_inode_buf.h
index 406f66799288,2f6015acfda8..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.h
+++ b/fs/xfs/libxfs/xfs_inode_buf.h
@@@ -16,16 -16,6 +16,19 @@@ struct xfs_dinode
   * format specific structures at the appropriate time.
   */
  struct xfs_icdinode {
++<<<<<<< HEAD
 +	uint16_t	di_flushiter;	/* incremented on flush */
 +	xfs_fsize_t	di_size;	/* number of bytes in file */
 +	xfs_rfsblock_t	di_nblocks;	/* # of direct & btree blocks used */
 +	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
 +	uint8_t		di_forkoff;	/* attr fork offs, <<3 for 64b align */
 +	uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
 +
 +	uint64_t	di_flags2;	/* more random flags */
 +	uint32_t	di_cowextsize;	/* basic cow extent size for file */
 +
++=======
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	struct timespec64 di_crtime;	/* time created */
  };
  
diff --cc fs/xfs/xfs_file.c
index d7d8b957f1f5,396ef36dcd0a..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1150,10 -1159,10 +1150,15 @@@ xfs_file_remap_range
  	 */
  	cowextsize = 0;
  	if (pos_in == 0 && len == i_size_read(inode_in) &&
- 	    (src->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE) &&
+ 	    (src->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE) &&
  	    pos_out == 0 && len >= i_size_read(inode_out) &&
++<<<<<<< HEAD
 +	    !(dest->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE))
 +		cowextsize = src->i_d.di_cowextsize;
++=======
+ 	    !(dest->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE))
+ 		cowextsize = src->i_cowextsize;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  
  	ret = xfs_reflink_update_dest(dest, pos_out + len, cowextsize,
  			remap_flags);
diff --cc fs/xfs/xfs_icache.c
index 7ea1c183137f,2fd4a39acb46..000000000000
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@@ -64,9 -63,9 +64,15 @@@ xfs_inode_alloc
  	memset(&ip->i_df, 0, sizeof(ip->i_df));
  	ip->i_flags = 0;
  	ip->i_delayed_blks = 0;
++<<<<<<< HEAD
 +	ip->i_d.di_flags2 = mp->m_ino_geo.new_diflags2;
 +	ip->i_d.di_nblocks = 0;
 +	ip->i_d.di_forkoff = 0;
++=======
+ 	ip->i_diflags2 = mp->m_ino_geo.new_diflags2;
+ 	ip->i_nblocks = 0;
+ 	ip->i_forkoff = 0;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	ip->i_sick = 0;
  	ip->i_checked = 0;
  	INIT_WORK(&ip->i_ioend_work, xfs_end_io);
diff --cc fs/xfs/xfs_inode.c
index d856a2225b9c,5aff2f9db751..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -80,8 -80,8 +80,13 @@@ xfs_get_cowextsz_hint
  	xfs_extlen_t		a, b;
  
  	a = 0;
++<<<<<<< HEAD
 +	if (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE)
 +		a = ip->i_d.di_cowextsize;
++=======
+ 	if (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 		a = ip->i_cowextsize;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	b = xfs_get_extsz_hint(ip);
  
  	a = max(a, b);
@@@ -654,9 -654,7 +659,13 @@@ uin
  xfs_ip2xflags(
  	struct xfs_inode	*ip)
  {
++<<<<<<< HEAD
 +	struct xfs_icdinode	*dic = &ip->i_d;
 +
 +	return _xfs_dic2xflags(dic->di_flags, dic->di_flags2, XFS_IFORK_Q(ip));
++=======
+ 	return _xfs_dic2xflags(ip->i_diflags, ip->i_diflags2, XFS_IFORK_Q(ip));
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  }
  
  /*
@@@ -752,12 -750,12 +761,18 @@@ xfs_inode_inherit_flags2
  	struct xfs_inode	*ip,
  	const struct xfs_inode	*pip)
  {
++<<<<<<< HEAD
 +	if (pip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE) {
 +		ip->i_d.di_flags2 |= XFS_DIFLAG2_COWEXTSIZE;
 +		ip->i_d.di_cowextsize = pip->i_d.di_cowextsize;
++=======
+ 	if (pip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE) {
+ 		ip->i_diflags2 |= XFS_DIFLAG2_COWEXTSIZE;
+ 		ip->i_cowextsize = pip->i_cowextsize;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	}
- 	if (pip->i_d.di_flags2 & XFS_DIFLAG2_DAX)
- 		ip->i_d.di_flags2 |= XFS_DIFLAG2_DAX;
+ 	if (pip->i_diflags2 & XFS_DIFLAG2_DAX)
+ 		ip->i_diflags2 |= XFS_DIFLAG2_DAX;
  }
  
  /*
@@@ -857,9 -858,9 +872,9 @@@ xfs_init_new_inode
  		break;
  	case S_IFREG:
  	case S_IFDIR:
 -		if (pip && (pip->i_diflags & XFS_DIFLAG_ANY))
 +		if (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY))
  			xfs_inode_inherit_flags(ip, pip);
- 		if (pip && (pip->i_d.di_flags2 & XFS_DIFLAG2_ANY))
+ 		if (pip && (pip->i_diflags2 & XFS_DIFLAG2_ANY))
  			xfs_inode_inherit_flags2(ip, pip);
  		/* FALLTHROUGH */
  	case S_IFLNK:
@@@ -2584,9 -2609,9 +2599,15 @@@ xfs_ifree
  	}
  
  	VFS_I(ip)->i_mode = 0;		/* mark incore inode as free */
++<<<<<<< HEAD
 +	ip->i_d.di_flags = 0;
 +	ip->i_d.di_flags2 = ip->i_mount->m_ino_geo.new_diflags2;
 +	ip->i_d.di_forkoff = 0;		/* mark the attr fork not in use */
++=======
+ 	ip->i_diflags = 0;
+ 	ip->i_diflags2 = ip->i_mount->m_ino_geo.new_diflags2;
+ 	ip->i_forkoff = 0;		/* mark the attr fork not in use */
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	ip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;
  	if (xfs_iflags_test(ip, XFS_IPRESERVE_DM_FIELDS))
  		xfs_iflags_clear(ip, XFS_IPRESERVE_DM_FIELDS);
diff --cc fs/xfs/xfs_inode.h
index ab59fceed361,5d5f86ed23e9..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -54,7 -54,18 +54,19 @@@ typedef struct xfs_inode 
  	/* Miscellaneous state. */
  	unsigned long		i_flags;	/* see defined flags below */
  	uint64_t		i_delayed_blks;	/* count of delay alloc blks */
 -	xfs_fsize_t		i_disk_size;	/* number of bytes in file */
 -	xfs_rfsblock_t		i_nblocks;	/* # of direct & btree blocks */
  	prid_t			i_projid;	/* owner's project id */
++<<<<<<< HEAD
++=======
+ 	xfs_extlen_t		i_extsize;	/* basic/minimum extent size */
+ 	/* cowextsize is only used for v3 inodes, flushiter for v1/2 */
+ 	union {
+ 		xfs_extlen_t	i_cowextsize;	/* basic cow extent size */
+ 		uint16_t	i_flushiter;	/* incremented on flush */
+ 	};
+ 	uint8_t			i_forkoff;	/* attr fork offset >> 3 */
+ 	uint16_t		i_diflags;	/* XFS_DIFLAG_... */
+ 	uint64_t		i_diflags2;	/* XFS_DIFLAG2_... */
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  
  	struct xfs_icdinode	i_d;		/* most of ondisk inode */
  
diff --cc fs/xfs/xfs_inode_item.c
index 342023fbc07e,1284672fda02..000000000000
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@@ -401,8 -387,8 +401,13 @@@ xfs_inode_to_log_dinode
  		to->di_version = 3;
  		to->di_changecount = inode_peek_iversion(inode);
  		to->di_crtime = xfs_inode_to_log_dinode_ts(ip, from->di_crtime);
++<<<<<<< HEAD
 +		to->di_flags2 = from->di_flags2;
 +		to->di_cowextsize = from->di_cowextsize;
++=======
+ 		to->di_flags2 = ip->i_diflags2;
+ 		to->di_cowextsize = ip->i_cowextsize;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  		to->di_ino = ip->i_ino;
  		to->di_lsn = lsn;
  		memset(to->di_pad2, 0, sizeof(to->di_pad2));
diff --cc fs/xfs/xfs_ioctl.c
index 0b05f7dd7822,5a54a096cdd1..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1116,9 -1120,11 +1116,16 @@@ xfs_fill_fsxattr
  	struct xfs_ifork	*ifp = attr ? ip->i_afp : &ip->i_df;
  
  	simple_fill_fsxattr(fa, xfs_ip2xflags(ip));
++<<<<<<< HEAD
 +	fa->fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;
 +	fa->fsx_cowextsize = ip->i_d.di_cowextsize <<
 +			ip->i_mount->m_sb.sb_blocklog;
++=======
+ 
+ 	fa->fsx_extsize = XFS_FSB_TO_B(mp, ip->i_extsize);
+ 	if (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 		fa->fsx_cowextsize = XFS_FSB_TO_B(mp, ip->i_cowextsize);
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	fa->fsx_projid = ip->i_projid;
  	if (ifp && (ifp->if_flags & XFS_IFEXTENTS))
  		fa->fsx_nextents = xfs_iext_count(ifp);
@@@ -1232,12 -1238,12 +1239,17 @@@ xfs_ioctl_setattr_xflags
  		return -EINVAL;
  
  	/* diflags2 only valid for v3 inodes. */
- 	di_flags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);
- 	if (di_flags2 && !xfs_sb_version_has_v3inode(&mp->m_sb))
+ 	i_flags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);
+ 	if (i_flags2 && !xfs_sb_version_has_v3inode(&mp->m_sb))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	ip->i_d.di_flags = xfs_flags2diflags(ip, fa->fsx_xflags);
 +	ip->i_d.di_flags2 = di_flags2;
++=======
+ 	ip->i_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);
+ 	ip->i_diflags2 = i_flags2;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  
  	xfs_diflags_to_iflags(ip, false);
  	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);
@@@ -1511,16 -1520,17 +1523,27 @@@ xfs_ioctl_setattr
  	 * extent size hint should be set on the inode. If no extent size flags
  	 * are set on the inode then unconditionally clear the extent size hint.
  	 */
 -	if (ip->i_diflags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
 -		ip->i_extsize = XFS_B_TO_FSB(mp, fa->fsx_extsize);
 +	if (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
 +		ip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;
 +	else
++<<<<<<< HEAD
 +		ip->i_d.di_extsize = 0;
 +	if (xfs_sb_version_has_v3inode(&mp->m_sb) &&
 +	    (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE))
 +		ip->i_d.di_cowextsize = fa->fsx_cowextsize >>
 +				mp->m_sb.sb_blocklog;
  	else
 +		ip->i_d.di_cowextsize = 0;
++=======
+ 		ip->i_extsize = 0;
+ 
+ 	if (xfs_sb_version_has_v3inode(&mp->m_sb)) {
+ 		if (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 			ip->i_cowextsize = XFS_B_TO_FSB(mp, fa->fsx_cowextsize);
+ 		else
+ 			ip->i_cowextsize = 0;
+ 	}
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  
  	error = xfs_trans_commit(tp);
  
@@@ -1566,7 -1575,7 +1589,11 @@@ xfs_ioc_getxflags
  {
  	unsigned int		flags;
  
++<<<<<<< HEAD
 +	flags = xfs_di2lxflags(ip->i_d.di_flags, ip->i_d.di_flags2);
++=======
+ 	flags = xfs_di2lxflags(ip->i_diflags, ip->i_diflags2);
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	if (copy_to_user(arg, &flags, sizeof(flags)))
  		return -EFAULT;
  	return 0;
diff --cc fs/xfs/xfs_itable.c
index 434d70c7cd93,8799e38bd466..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -111,8 -113,8 +111,13 @@@ xfs_bulkstat_one_int
  	if (xfs_sb_version_has_v3inode(&mp->m_sb)) {
  		buf->bs_btime = dic->di_crtime.tv_sec;
  		buf->bs_btime_nsec = dic->di_crtime.tv_nsec;
++<<<<<<< HEAD
 +		if (dic->di_flags2 & XFS_DIFLAG2_COWEXTSIZE)
 +			buf->bs_cowextsize_blks = dic->di_cowextsize;
++=======
+ 		if (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 			buf->bs_cowextsize_blks = ip->i_cowextsize;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	}
  
  	switch (ip->i_df.if_format) {
diff --cc fs/xfs/xfs_reflink.c
index 64704535cdc3,323506a6b339..000000000000
--- a/fs/xfs/xfs_reflink.c
+++ b/fs/xfs/xfs_reflink.c
@@@ -934,8 -934,8 +934,13 @@@ xfs_reflink_update_dest
  	}
  
  	if (cowextsize) {
++<<<<<<< HEAD
 +		dest->i_d.di_cowextsize = cowextsize;
 +		dest->i_d.di_flags2 |= XFS_DIFLAG2_COWEXTSIZE;
++=======
+ 		dest->i_cowextsize = cowextsize;
+ 		dest->i_diflags2 |= XFS_DIFLAG2_COWEXTSIZE;
++>>>>>>> 3e09ab8fdc4d (xfs: move the di_flags2 field to struct xfs_inode)
  	}
  
  	xfs_trans_log_inode(tp, dest, XFS_ILOG_CORE);
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.h
diff --git a/fs/xfs/libxfs/xfs_trans_inode.c b/fs/xfs/libxfs/xfs_trans_inode.c
index 4f02cb439ab5..102920303454 100644
--- a/fs/xfs/libxfs/xfs_trans_inode.c
+++ b/fs/xfs/libxfs/xfs_trans_inode.c
@@ -138,7 +138,7 @@ xfs_trans_log_inode(
 	if ((flags & (XFS_ILOG_CORE | XFS_ILOG_TIMESTAMP)) &&
 	    xfs_sb_version_hasbigtime(&ip->i_mount->m_sb) &&
 	    !xfs_inode_has_bigtime(ip)) {
-		ip->i_d.di_flags2 |= XFS_DIFLAG2_BIGTIME;
+		ip->i_diflags2 |= XFS_DIFLAG2_BIGTIME;
 		flags |= XFS_ILOG_CORE;
 	}
 
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index 4289f7de99b7..3dee8dcede0c 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -1323,9 +1323,9 @@ xfs_swap_extent_rmap(
 	 * rmap functions when we go to fix up the rmaps.  The flags
 	 * will be switch for reals later.
 	 */
-	tip_flags2 = tip->i_d.di_flags2;
-	if (ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK)
-		tip->i_d.di_flags2 |= XFS_DIFLAG2_REFLINK;
+	tip_flags2 = tip->i_diflags2;
+	if (ip->i_diflags2 & XFS_DIFLAG2_REFLINK)
+		tip->i_diflags2 |= XFS_DIFLAG2_REFLINK;
 
 	offset_fsb = 0;
 	end_fsb = XFS_B_TO_FSB(ip->i_mount, i_size_read(VFS_I(ip)));
@@ -1412,12 +1412,12 @@ xfs_swap_extent_rmap(
 		offset_fsb += ilen;
 	}
 
-	tip->i_d.di_flags2 = tip_flags2;
+	tip->i_diflags2 = tip_flags2;
 	return 0;
 
 out:
 	trace_xfs_swap_extent_rmap_error(ip, error, _RET_IP_);
-	tip->i_d.di_flags2 = tip_flags2;
+	tip->i_diflags2 = tip_flags2;
 	return error;
 }
 
@@ -1715,13 +1715,13 @@ xfs_swap_extents(
 		goto out_trans_cancel;
 
 	/* Do we have to swap reflink flags? */
-	if ((ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK) ^
-	    (tip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK)) {
-		f = ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK;
-		ip->i_d.di_flags2 &= ~XFS_DIFLAG2_REFLINK;
-		ip->i_d.di_flags2 |= tip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK;
-		tip->i_d.di_flags2 &= ~XFS_DIFLAG2_REFLINK;
-		tip->i_d.di_flags2 |= f & XFS_DIFLAG2_REFLINK;
+	if ((ip->i_diflags2 & XFS_DIFLAG2_REFLINK) ^
+	    (tip->i_diflags2 & XFS_DIFLAG2_REFLINK)) {
+		f = ip->i_diflags2 & XFS_DIFLAG2_REFLINK;
+		ip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;
+		ip->i_diflags2 |= tip->i_diflags2 & XFS_DIFLAG2_REFLINK;
+		tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;
+		tip->i_diflags2 |= f & XFS_DIFLAG2_REFLINK;
 	}
 
 	/* Swap the cow forks. */
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path fs/xfs/xfs_icache.c
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_inode.h
* Unmerged path fs/xfs/xfs_inode_item.c
* Unmerged path fs/xfs/xfs_ioctl.c
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 1a5880c79e28..1b56688db622 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -1210,7 +1210,7 @@ xfs_inode_should_enable_dax(
 		return false;
 	if (ip->i_mount->m_flags & XFS_MOUNT_DAX_ALWAYS)
 		return true;
-	if (ip->i_d.di_flags2 & XFS_DIFLAG2_DAX)
+	if (ip->i_diflags2 & XFS_DIFLAG2_DAX)
 		return true;
 	return false;
 }
* Unmerged path fs/xfs/xfs_itable.c
* Unmerged path fs/xfs/xfs_reflink.c
