SUNRPC: Change return value type of .pc_decode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit c44b31c263798ec34614dd394c31ef1a2e7e716e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/c44b31c2.failed

Returning an undecorated integer is an age-old trope, but it's
not clear (even to previous experts in this code) that the only
valid return values are 1 and 0. These functions do not return
a negative errno, rpc_stat value, or a positive length.

Document there are only two valid return values by having
.pc_decode return only true or false.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit c44b31c263798ec34614dd394c31ef1a2e7e716e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/lockd/xdr.c
#	fs/lockd/xdr4.c
#	fs/nfsd/nfs2acl.c
#	fs/nfsd/nfs3acl.c
#	fs/nfsd/nfs3xdr.c
#	fs/nfsd/nfs4xdr.c
#	fs/nfsd/nfsd.h
#	fs/nfsd/nfssvc.c
#	fs/nfsd/nfsxdr.c
#	fs/nfsd/xdr.h
#	fs/nfsd/xdr3.h
#	fs/nfsd/xdr4.h
#	include/linux/lockd/xdr.h
#	include/linux/lockd/xdr4.h
#	include/linux/sunrpc/svc.h
diff --cc fs/lockd/xdr.c
index 9235e60b1769,622c2ca37dbf..000000000000
--- a/fs/lockd/xdr.c
+++ b/fs/lockd/xdr.c
@@@ -145,16 -145,15 +145,26 @@@ svcxdr_encode_testrply(struct xdr_strea
   * Decode Call arguments
   */
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_void(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_testargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	u32 exclusive;
  
@@@ -167,13 -166,12 +177,18 @@@
  	if (exclusive)
  		argp->lock.fl.fl_type = F_WRLCK;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_lockargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	u32 exclusive;
  
@@@ -188,18 -186,17 +203,23 @@@
  	if (exclusive)
  		argp->lock.fl.fl_type = F_WRLCK;
  	if (xdr_stream_decode_bool(xdr, &argp->reclaim) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &argp->state) < 0)
- 		return 0;
+ 		return false;
  	argp->monitor = 1;		/* monitor client by default */
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_cancargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	u32 exclusive;
  
@@@ -214,43 -211,41 +234,58 @@@
  	if (exclusive)
  		argp->lock.fl.fl_type = F_WRLCK;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_unlockargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  
  	if (!svcxdr_decode_cookie(xdr, &argp->cookie))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_lock(xdr, &argp->lock))
- 		return 0;
+ 		return false;
  	argp->lock.fl.fl_type = F_UNLCK;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_res(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_res *resp = rqstp->rq_argp;
  
  	if (!svcxdr_decode_cookie(xdr, &resp->cookie))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_stats(xdr, &resp->status))
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_reboot(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_reboot *argp = rqstp->rq_argp;
 -	__be32 *p;
  	u32 len;
  
  	if (xdr_stream_decode_u32(xdr, &len) < 0)
@@@ -263,19 -258,18 +298,24 @@@
  	argp->len = len;
  	argp->mon = (char *)p;
  	if (xdr_stream_decode_u32(xdr, &argp->state) < 0)
- 		return 0;
+ 		return false;
  	p = xdr_inline_decode(xdr, SM_PRIV_SIZE);
  	if (!p)
- 		return 0;
+ 		return false;
  	memcpy(&argp->priv.data, p, sizeof(argp->priv.data));
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	struct nlm_lock	*lock = &argp->lock;
  
@@@ -284,26 -278,25 +324,31 @@@
  	lock->svid = ~(u32)0;
  
  	if (!svcxdr_decode_cookie(xdr, &argp->cookie))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_fhandle(xdr, &lock->fh))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_owner(xdr, &lock->oh))
- 		return 0;
+ 		return false;
  	/* XXX: Range checks are missing in the original code */
  	if (xdr_stream_decode_u32(xdr, &argp->fsm_mode) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &argp->fsm_access) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_decode_notify(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	struct nlm_lock	*lock = &argp->lock;
  
diff --cc fs/lockd/xdr4.c
index 98e957e4566c,45551dee26b4..000000000000
--- a/fs/lockd/xdr4.c
+++ b/fs/lockd/xdr4.c
@@@ -144,16 -144,15 +144,26 @@@ svcxdr_encode_testrply(struct xdr_strea
   * Decode Call arguments
   */
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_void(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_testargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	u32 exclusive;
  
@@@ -166,13 -165,12 +176,18 @@@
  	if (exclusive)
  		argp->lock.fl.fl_type = F_WRLCK;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_lockargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	u32 exclusive;
  
@@@ -187,68 -185,66 +202,89 @@@
  	if (exclusive)
  		argp->lock.fl.fl_type = F_WRLCK;
  	if (xdr_stream_decode_bool(xdr, &argp->reclaim) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &argp->state) < 0)
- 		return 0;
+ 		return false;
  	argp->monitor = 1;		/* monitor client by default */
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_cancargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	u32 exclusive;
  
  	if (!svcxdr_decode_cookie(xdr, &argp->cookie))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_bool(xdr, &argp->block) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_bool(xdr, &exclusive) < 0)
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_lock(xdr, &argp->lock))
- 		return 0;
+ 		return false;
  	if (exclusive)
  		argp->lock.fl.fl_type = F_WRLCK;
- 	return 1;
+ 
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_unlockargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  
  	if (!svcxdr_decode_cookie(xdr, &argp->cookie))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_lock(xdr, &argp->lock))
- 		return 0;
+ 		return false;
  	argp->lock.fl.fl_type = F_UNLCK;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_res(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_res *resp = rqstp->rq_argp;
  
  	if (!svcxdr_decode_cookie(xdr, &resp->cookie))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_stats(xdr, &resp->status))
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_reboot(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_reboot *argp = rqstp->rq_argp;
 -	__be32 *p;
  	u32 len;
  
  	if (xdr_stream_decode_u32(xdr, &len) < 0)
@@@ -261,19 -257,18 +297,24 @@@
  	argp->len = len;
  	argp->mon = (char *)p;
  	if (xdr_stream_decode_u32(xdr, &argp->state) < 0)
- 		return 0;
+ 		return false;
  	p = xdr_inline_decode(xdr, SM_PRIV_SIZE);
  	if (!p)
- 		return 0;
+ 		return false;
  	memcpy(&argp->priv.data, p, sizeof(argp->priv.data));
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	struct nlm_lock	*lock = &argp->lock;
  
@@@ -282,26 -277,25 +323,31 @@@
  	lock->svid = ~(u32)0;
  
  	if (!svcxdr_decode_cookie(xdr, &argp->cookie))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_fhandle(xdr, &lock->fh))
- 		return 0;
+ 		return false;
  	if (!svcxdr_decode_owner(xdr, &lock->oh))
- 		return 0;
+ 		return false;
  	/* XXX: Range checks are missing in the original code */
  	if (xdr_stream_decode_u32(xdr, &argp->fsm_mode) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &argp->fsm_access) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_decode_notify(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nlm_args *argp = rqstp->rq_argp;
  	struct nlm_lock	*lock = &argp->lock;
  
diff --cc fs/nfsd/nfs2acl.c
index 8703326fc165,cf6ba5e7937e..000000000000
--- a/fs/nfsd/nfs2acl.c
+++ b/fs/nfsd/nfs2acl.c
@@@ -186,43 -188,43 +186,58 @@@ out
   * XDR decode functions
   */
  
++<<<<<<< HEAD
 +static int nfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_getaclargs *argp = rqstp->rq_argp;
  
  	if (!svcxdr_decode_fhandle(xdr, &argp->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &argp->mask) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +static int nfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_setaclargs *argp = rqstp->rq_argp;
  
  	if (!svcxdr_decode_fhandle(xdr, &argp->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &argp->mask) < 0)
- 		return 0;
+ 		return false;
  	if (argp->mask & ~NFS_ACL_MASK)
- 		return 0;
+ 		return false;
  	if (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_ACL) ?
  				   &argp->acl_access : NULL))
- 		return 0;
+ 		return false;
  	if (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_DFACL) ?
  				   &argp->acl_default : NULL))
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +static int nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_accessargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_fhandle(xdr, &args->fh))
diff --cc fs/nfsd/nfs3acl.c
index bcb2fc5c7b99,9e9f6afb2e00..000000000000
--- a/fs/nfsd/nfs3acl.c
+++ b/fs/nfsd/nfs3acl.c
@@@ -125,43 -127,38 +125,70 @@@ out
   * XDR decode functions
   */
  
++<<<<<<< HEAD
 +static int nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_getaclargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->mask) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +static int nfs3svc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfs3svc_decode_setaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 -	struct nfsd3_setaclargs *argp = rqstp->rq_argp;
 +	struct nfsd3_setaclargs *args = rqstp->rq_argp;
 +	struct kvec *head = rqstp->rq_arg.head;
 +	unsigned int base;
 +	int n;
  
++<<<<<<< HEAD
 +	p = nfs3svc_decode_fh(p, &args->fh);
 +	if (!p)
 +		return 0;
 +	args->mask = ntohl(*p++);
 +	if (args->mask & ~NFS_ACL_MASK ||
 +	    !xdr_argsize_check(rqstp, p))
 +		return 0;
 +
 +	base = (char *)p - (char *)head->iov_base;
 +	n = nfsacl_decode(&rqstp->rq_arg, base, NULL,
 +			  (args->mask & NFS_ACL) ?
 +			  &args->acl_access : NULL);
 +	if (n > 0)
 +		n = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,
 +				  (args->mask & NFS_DFACL) ?
 +				  &args->acl_default : NULL);
 +	return (n > 0);
++=======
+ 	if (!svcxdr_decode_nfs_fh3(xdr, &argp->fh))
+ 		return false;
+ 	if (xdr_stream_decode_u32(xdr, &argp->mask) < 0)
+ 		return false;
+ 	if (argp->mask & ~NFS_ACL_MASK)
+ 		return false;
+ 	if (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_ACL) ?
+ 				   &argp->acl_access : NULL))
+ 		return false;
+ 	if (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_DFACL) ?
+ 				   &argp->acl_default : NULL))
+ 		return false;
+ 
+ 	return true;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  }
  
  /*
diff --cc fs/nfsd/nfs3xdr.c
index 657ede6555bb,1f3de46d24d4..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -645,19 -556,17 +645,29 @@@ void fill_post_wcc(struct svc_fh *fhp
   * XDR decode functions
   */
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_fhandleargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_fhandle *args = rqstp->rq_argp;
  
  	return svcxdr_decode_nfs_fh3(xdr, &args->fh);
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_sattrargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_nfs_fh3(xdr, &args->fh) &&
@@@ -665,63 -574,56 +675,83 @@@
  		svcxdr_decode_sattrguard3(xdr, args);
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_diropargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_diropargs3(xdr, &args->fh, &args->name, &args->len);
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_accessargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_accessargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->access) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_readargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u64(xdr, &args->offset) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_writeargs *args = rqstp->rq_argp;
  	u32 max_blocksize = svc_max_payload(rqstp);
 +	struct kvec *head = rqstp->rq_arg.head;
 +	struct kvec *tail = rqstp->rq_arg.tail;
 +	size_t remaining;
  
  	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u64(xdr, &args->offset) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->stable) < 0)
- 		return 0;
+ 		return false;
  
  	/* opaque data */
  	if (xdr_stream_decode_u32(xdr, &args->len) < 0)
@@@ -729,26 -631,20 +759,40 @@@
  
  	/* request sanity */
  	if (args->count != args->len)
++<<<<<<< HEAD
 +		return 0;
 +	remaining = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len;
 +	remaining -= xdr_stream_pos(xdr);
 +	if (remaining < xdr_align_size(args->len))
 +		return 0;
++=======
+ 		return false;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  	if (args->count > max_blocksize) {
  		args->count = max_blocksize;
  		args->len = max_blocksize;
  	}
++<<<<<<< HEAD
 +
 +	args->first.iov_base = xdr->p;
 +	args->first.iov_len = head->iov_len - xdr_stream_pos(xdr);
++=======
+ 	if (!xdr_stream_subsegment(xdr, &args->payload, args->count))
+ 		return false;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_createargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_createargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_diropargs3(xdr, &args->fh, &args->name, &args->len))
@@@ -762,18 -658,17 +806,23 @@@
  	case NFS3_CREATE_EXCLUSIVE:
  		args->verf = xdr_inline_decode(xdr, NFS3_CREATEVERFSIZE);
  		if (!args->verf)
- 			return 0;
+ 			return false;
  		break;
  	default:
- 		return 0;
+ 		return false;
  	}
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_createargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_diropargs3(xdr, &args->fh,
@@@ -781,10 -676,9 +830,15 @@@
  		svcxdr_decode_sattr3(rqstp, xdr, &args->attrs);
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_symlinkargs *args = rqstp->rq_argp;
  	struct kvec *head = rqstp->rq_arg.head;
  	struct kvec *tail = rqstp->rq_arg.tail;
@@@ -806,13 -700,12 +860,18 @@@
  	args->first.iov_base = xdr->p;
  	args->first.iov_len = head->iov_len - xdr_stream_pos(xdr);
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_mknodargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_mknodargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_mknodargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_diropargs3(xdr, &args->fh, &args->name, &args->len))
@@@ -832,16 -725,15 +891,21 @@@
  		/* Valid XDR but illegal file types */
  		break;
  	default:
- 		return 0;
+ 		return false;
  	}
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_renameargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_diropargs3(xdr, &args->ffh,
@@@ -850,10 -742,9 +914,15 @@@
  					 &args->tname, &args->tlen);
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_linkargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_nfs_fh3(xdr, &args->ffh) &&
@@@ -861,42 -752,49 +930,86 @@@
  					 &args->tname, &args->tlen);
  }
  
++<<<<<<< HEAD
 +int
 +nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p)
 +{
 +	struct nfsd3_readdirargs *args = rqstp->rq_argp;
 +
 +	p = decode_fh(p, &args->fh);
 +	if (!p)
 +		return 0;
 +	p = xdr_decode_hyper(p, &args->cookie);
 +	args->verf   = p; p += 2;
 +	args->dircount = ~0;
 +	args->count  = ntohl(*p++);
 +
 +	return xdr_argsize_check(rqstp, p);
 +}
 +
 +int
 +nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
  {
  	struct nfsd3_readdirargs *args = rqstp->rq_argp;
  
+ 	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
+ 		return false;
+ 	if (xdr_stream_decode_u64(xdr, &args->cookie) < 0)
+ 		return false;
+ 	args->verf = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);
+ 	if (!args->verf)
+ 		return false;
+ 	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ bool
+ nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
+ {
+ 	struct nfsd3_readdirargs *args = rqstp->rq_argp;
 -	u32 dircount;
+ 
++<<<<<<< HEAD
 +	p = decode_fh(p, &args->fh);
 +	if (!p)
 +		return 0;
 +	p = xdr_decode_hyper(p, &args->cookie);
 +	args->verf     = p; p += 2;
 +	args->dircount = ntohl(*p++);
 +	args->count    = ntohl(*p++);
 +
 +	return xdr_argsize_check(rqstp, p);
 +}
 +
 +int
 +nfs3svc_decode_commitargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ 	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
+ 		return false;
+ 	if (xdr_stream_decode_u64(xdr, &args->cookie) < 0)
+ 		return false;
+ 	args->verf = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);
+ 	if (!args->verf)
+ 		return false;
+ 	/* dircount is ignored */
+ 	if (xdr_stream_decode_u32(xdr, &dircount) < 0)
+ 		return false;
+ 	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ bool
+ nfs3svc_decode_commitargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_commitargs *args = rqstp->rq_argp;
  
  	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
diff --cc fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7,dd1ee9ada7dd..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -2147,43 -2322,53 +2147,78 @@@ nfsd4_opnum_in_range(struct nfsd4_compo
  	return true;
  }
  
++<<<<<<< HEAD
 +static __be32
++=======
+ static bool
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  nfsd4_decode_compound(struct nfsd4_compoundargs *argp)
  {
 +	DECODE_HEAD;
  	struct nfsd4_op *op;
  	bool cachethis = false;
  	int auth_slack= argp->rqstp->rq_auth_slack;
  	int max_reply = auth_slack + 8; /* opcnt, status */
  	int readcount = 0;
  	int readbytes = 0;
 -	__be32 *p;
  	int i;
  
++<<<<<<< HEAD
 +	READ_BUF(4);
 +	argp->taglen = be32_to_cpup(p++);
 +	READ_BUF(argp->taglen);
 +	SAVEMEM(argp->tag, argp->taglen);
 +	READ_BUF(8);
 +	argp->minorversion = be32_to_cpup(p++);
 +	argp->opcnt = be32_to_cpup(p++);
 +	max_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);
++=======
+ 	if (xdr_stream_decode_u32(argp->xdr, &argp->taglen) < 0)
+ 		return false;
+ 	max_reply += XDR_UNIT;
+ 	argp->tag = NULL;
+ 	if (unlikely(argp->taglen)) {
+ 		if (argp->taglen > NFSD4_MAX_TAGLEN)
+ 			return false;
+ 		p = xdr_inline_decode(argp->xdr, argp->taglen);
+ 		if (!p)
+ 			return false;
+ 		argp->tag = svcxdr_savemem(argp, p, argp->taglen);
+ 		if (!argp->tag)
+ 			return false;
+ 		max_reply += xdr_align_size(argp->taglen);
+ 	}
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &argp->minorversion) < 0)
+ 		return false;
+ 	if (xdr_stream_decode_u32(argp->xdr, &argp->opcnt) < 0)
+ 		return false;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  
 +	if (argp->taglen > NFSD4_MAX_TAGLEN)
 +		goto xdr_error;
  	/*
  	 * NFS4ERR_RESOURCE is a more helpful error than GARBAGE_ARGS
  	 * here, so we return success at the xdr level so that
  	 * nfsd4_proc can handle this is an NFS-level error.
  	 */
  	if (argp->opcnt > NFSD_MAX_OPS_PER_COMPOUND)
++<<<<<<< HEAD
 +		return 0;
++=======
+ 		return true;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  
  	if (argp->opcnt > ARRAY_SIZE(argp->iops)) {
  		argp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);
  		if (!argp->ops) {
  			argp->ops = argp->iops;
  			dprintk("nfsd: couldn't allocate room for COMPOUND\n");
++<<<<<<< HEAD
 +			goto xdr_error;
++=======
+ 			return false;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  		}
  	}
  
@@@ -2195,7 -2380,7 +2230,11 @@@
  		op->replay = NULL;
  
  		if (xdr_stream_decode_u32(argp->xdr, &op->opnum) < 0)
++<<<<<<< HEAD
 +			return nfserr_bad_xdr;
++=======
+ 			return false;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  		if (nfsd4_opnum_in_range(argp, op)) {
  			op->status = nfsd4_dec_ops[op->opnum](argp, &op->u);
  			if (op->status != nfs_ok)
@@@ -2242,7 -2427,7 +2281,11 @@@
  	if (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)
  		clear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);
  
++<<<<<<< HEAD
 +	DECODE_TAIL;
++=======
+ 	return true;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  }
  
  static __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode,
@@@ -5011,8 -5411,8 +5054,13 @@@ void nfsd4_release_compoundargs(struct 
  	}
  }
  
++<<<<<<< HEAD
 +int
 +nfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs4svc_decode_compoundargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
  	struct nfsd4_compoundargs *args = rqstp->rq_argp;
  
diff --cc fs/nfsd/nfsd.h
index 6f7f06b891ab,bfcddd4c7534..000000000000
--- a/fs/nfsd/nfsd.h
+++ b/fs/nfsd/nfsd.h
@@@ -77,7 -78,8 +77,12 @@@ extern const struct seq_operations nfs_
   */
  struct nfsd_voidargs { };
  struct nfsd_voidres { };
++<<<<<<< HEAD
 +int		nfssvc_decode_voidarg(struct svc_rqst *rqstp, __be32 *p);
++=======
+ bool		nfssvc_decode_voidarg(struct svc_rqst *rqstp,
+ 				      struct xdr_stream *xdr);
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  int		nfssvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p);
  
  /*
diff --cc fs/nfsd/nfssvc.c
index 5e028e1a2313,beb564e8a3db..000000000000
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@@ -1060,13 -1064,13 +1060,17 @@@ out_encode_err
  /**
   * nfssvc_decode_voidarg - Decode void arguments
   * @rqstp: Server RPC transaction context
 - * @xdr: XDR stream positioned at arguments to decode
 + * @p: buffer containing arguments to decode
   *
   * Return values:
-  *   %0: Arguments were not valid
-  *   %1: Decoding was successful
+  *   %false: Arguments were not valid
+  *   %true: Decoding was successful
   */
++<<<<<<< HEAD
 +int nfssvc_decode_voidarg(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool nfssvc_decode_voidarg(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
  	return 1;
  }
diff --cc fs/nfsd/nfsxdr.c
index 1c01c0cb3914,b5817a41b3de..000000000000
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@@ -272,94 -272,81 +272,130 @@@ svcxdr_encode_fattr(struct svc_rqst *rq
   * XDR decode functions
   */
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_fhandleargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_fhandle *args = rqstp->rq_argp;
  
  	return svcxdr_decode_fhandle(xdr, &args->fh);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_sattrargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_fhandle(xdr, &args->fh) &&
  		svcxdr_decode_sattr(rqstp, xdr, &args->attrs);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_diropargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_diropargs(xdr, &args->fh, &args->name, &args->len);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_readargs *args = rqstp->rq_argp;
  	u32 totalcount;
  
  	if (!svcxdr_decode_fhandle(xdr, &args->fh))
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->offset) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
- 		return 0;
+ 		return false;
  	/* totalcount is ignored */
  	if (xdr_stream_decode_u32(xdr, &totalcount) < 0)
- 		return 0;
+ 		return false;
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_writeargs *args = rqstp->rq_argp;
 +	struct kvec *head = rqstp->rq_arg.head;
 +	struct kvec *tail = rqstp->rq_arg.tail;
  	u32 beginoffset, totalcount;
 +	size_t remaining;
  
  	if (!svcxdr_decode_fhandle(xdr, &args->fh))
- 		return 0;
+ 		return false;
  	/* beginoffset is ignored */
  	if (xdr_stream_decode_u32(xdr, &beginoffset) < 0)
- 		return 0;
+ 		return false;
  	if (xdr_stream_decode_u32(xdr, &args->offset) < 0)
- 		return 0;
+ 		return false;
  	/* totalcount is ignored */
  	if (xdr_stream_decode_u32(xdr, &totalcount) < 0)
- 		return 0;
+ 		return false;
  
  	/* opaque data */
  	if (xdr_stream_decode_u32(xdr, &args->len) < 0)
- 		return 0;
+ 		return false;
  	if (args->len > NFSSVC_MAXBLKSIZE_V2)
++<<<<<<< HEAD
 +		return 0;
 +	remaining = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len;
 +	remaining -= xdr_stream_pos(xdr);
 +	if (remaining < xdr_align_size(args->len))
 +		return 0;
 +	args->first.iov_base = xdr->p;
 +	args->first.iov_len = head->iov_len - xdr_stream_pos(xdr);
++=======
+ 		return false;
+ 	if (!xdr_stream_subsegment(xdr, &args->payload, args->len))
+ 		return false;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_createargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_createargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_diropargs(xdr, &args->fh,
@@@ -367,10 -354,9 +403,15 @@@
  		svcxdr_decode_sattr(rqstp, xdr, &args->attrs);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_renameargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_diropargs(xdr, &args->ffh,
@@@ -379,10 -365,9 +420,15 @@@
  					&args->tname, &args->tlen);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_linkargs *args = rqstp->rq_argp;
  
  	return svcxdr_decode_fhandle(xdr, &args->ffh) &&
@@@ -390,10 -375,9 +436,15 @@@
  					&args->tname, &args->tlen);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd_symlinkargs *args = rqstp->rq_argp;
  	struct kvec *head = rqstp->rq_arg.head;
  
@@@ -411,20 -395,19 +462,36 @@@
  	return svcxdr_decode_sattr(rqstp, xdr, &args->attrs);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p)
 +{
 +	struct nfsd_readdirargs *args = rqstp->rq_argp;
 +
 +	p = decode_fh(p, &args->fh);
 +	if (!p)
 +		return 0;
 +	args->cookie = ntohl(*p++);
 +	args->count  = ntohl(*p++);
 +	args->count  = min_t(u32, args->count, PAGE_SIZE);
 +	args->buffer = page_address(*(rqstp->rq_next_page++));
 +
 +	return xdr_argsize_check(rqstp, p);
++=======
+ bool
+ nfssvc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)
+ {
+ 	struct nfsd_readdirargs *args = rqstp->rq_argp;
+ 
+ 	if (!svcxdr_decode_fhandle(xdr, &args->fh))
+ 		return false;
+ 	if (xdr_stream_decode_u32(xdr, &args->cookie) < 0)
+ 		return false;
+ 	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
+ 		return false;
+ 
+ 	return true;
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  }
  
  /*
diff --cc fs/nfsd/xdr.h
index 6f3851dc237e,31be7d30e64e..000000000000
--- a/fs/nfsd/xdr.h
+++ b/fs/nfsd/xdr.h
@@@ -140,16 -141,17 +140,30 @@@ union nfsd_xdrstore 
  #define NFS2_SVC_XDRSIZE	sizeof(union nfsd_xdrstore)
  
  
++<<<<<<< HEAD
 +int nfssvc_decode_fhandleargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_sattrargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_diropargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_readargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_writeargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_createargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_renameargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_linkargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_symlinkargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_readdirargs(struct svc_rqst *, __be32 *);
++=======
+ bool nfssvc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ 
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  int nfssvc_encode_statres(struct svc_rqst *, __be32 *);
  int nfssvc_encode_attrstatres(struct svc_rqst *, __be32 *);
  int nfssvc_encode_diropres(struct svc_rqst *, __be32 *);
diff --cc fs/nfsd/xdr3.h
index 05db8ca205b1,ef72bc4868da..000000000000
--- a/fs/nfsd/xdr3.h
+++ b/fs/nfsd/xdr3.h
@@@ -266,21 -265,22 +266,40 @@@ union nfsd3_xdrstore 
  
  #define NFS3_SVC_XDRSIZE		sizeof(union nfsd3_xdrstore)
  
++<<<<<<< HEAD
 +int nfs3svc_decode_fhandleargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_sattrargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_diropargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_accessargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_readargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_writeargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_createargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_mkdirargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_mknodargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_renameargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_linkargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_symlinkargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_readdirargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_readdirplusargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_commitargs(struct svc_rqst *, __be32 *);
++=======
+ bool nfs3svc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_accessargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_mknodargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_commitargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ 
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  int nfs3svc_encode_getattrres(struct svc_rqst *, __be32 *);
  int nfs3svc_encode_wccstat(struct svc_rqst *, __be32 *);
  int nfs3svc_encode_lookupres(struct svc_rqst *, __be32 *);
diff --cc fs/nfsd/xdr4.h
index 4ef0f6d3f1d7,8812256cd520..000000000000
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@@ -750,7 -756,7 +750,11 @@@ set_change_info(struct nfsd4_change_inf
  
  
  bool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp);
++<<<<<<< HEAD
 +int nfs4svc_decode_compoundargs(struct svc_rqst *, __be32 *);
++=======
+ bool nfs4svc_decode_compoundargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  int nfs4svc_encode_compoundres(struct svc_rqst *, __be32 *);
  __be32 nfsd4_check_resp_size(struct nfsd4_compoundres *, u32);
  void nfsd4_encode_operation(struct nfsd4_compoundres *, struct nfsd4_op *);
diff --cc include/linux/lockd/xdr.h
index a98309c0121c,e1362244f909..000000000000
--- a/include/linux/lockd/xdr.h
+++ b/include/linux/lockd/xdr.h
@@@ -96,18 -96,19 +96,31 @@@ struct nlm_reboot 
   */
  #define NLMSVC_XDRSIZE		sizeof(struct nlm_args)
  
++<<<<<<< HEAD
 +int	nlmsvc_decode_testargs(struct svc_rqst *, __be32 *);
++=======
+ bool	nlmsvc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ 
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  int	nlmsvc_encode_testres(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_lockargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_cancargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_unlockargs(struct svc_rqst *, __be32 *);
  int	nlmsvc_encode_res(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_res(struct svc_rqst *, __be32 *);
  int	nlmsvc_encode_void(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_void(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_shareargs(struct svc_rqst *, __be32 *);
  int	nlmsvc_encode_shareres(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_notify(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_reboot(struct svc_rqst *, __be32 *);
  
  #endif /* LOCKD_XDR_H */
diff --cc include/linux/lockd/xdr4.h
index 5ae766f26e04,376b8f6a3763..000000000000
--- a/include/linux/lockd/xdr4.h
+++ b/include/linux/lockd/xdr4.h
@@@ -22,21 -22,20 +22,33 @@@
  #define	nlm4_fbig		cpu_to_be32(NLM_FBIG)
  #define	nlm4_failed		cpu_to_be32(NLM_FAILED)
  
++<<<<<<< HEAD
++=======
+ bool	nlm4svc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr);
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  
 +
 +int	nlm4svc_decode_testargs(struct svc_rqst *, __be32 *);
  int	nlm4svc_encode_testres(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_lockargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_cancargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_unlockargs(struct svc_rqst *, __be32 *);
  int	nlm4svc_encode_res(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_res(struct svc_rqst *, __be32 *);
  int	nlm4svc_encode_void(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_void(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_shareargs(struct svc_rqst *, __be32 *);
  int	nlm4svc_encode_shareres(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_notify(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_reboot(struct svc_rqst *, __be32 *);
  
  extern const struct rpc_version nlm_version4;
  
diff --cc include/linux/sunrpc/svc.h
index 6940c6b319c7,d6109fa7a57b..000000000000
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@@ -452,7 -454,8 +452,12 @@@ struct svc_procedure 
  	/* process the request: */
  	__be32			(*pc_func)(struct svc_rqst *);
  	/* XDR decode args: */
++<<<<<<< HEAD
 +	int			(*pc_decode)(struct svc_rqst *, __be32 *data);
++=======
+ 	bool			(*pc_decode)(struct svc_rqst *rqstp,
+ 					     struct xdr_stream *xdr);
++>>>>>>> c44b31c26379 (SUNRPC: Change return value type of .pc_decode)
  	/* XDR encode result: */
  	int			(*pc_encode)(struct svc_rqst *, __be32 *data);
  	/* XDR free result: */
* Unmerged path fs/lockd/xdr.c
* Unmerged path fs/lockd/xdr4.c
* Unmerged path fs/nfsd/nfs2acl.c
* Unmerged path fs/nfsd/nfs3acl.c
* Unmerged path fs/nfsd/nfs3xdr.c
* Unmerged path fs/nfsd/nfs4xdr.c
* Unmerged path fs/nfsd/nfsd.h
* Unmerged path fs/nfsd/nfssvc.c
* Unmerged path fs/nfsd/nfsxdr.c
* Unmerged path fs/nfsd/xdr.h
* Unmerged path fs/nfsd/xdr3.h
* Unmerged path fs/nfsd/xdr4.h
* Unmerged path include/linux/lockd/xdr.h
* Unmerged path include/linux/lockd/xdr4.h
* Unmerged path include/linux/sunrpc/svc.h
