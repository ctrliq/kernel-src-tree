arm64: sync kernel APIAKey when installing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit 3fabb43818c9bfe7c4084badfa21d4e8187021a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/3fabb438.failed

A direct write to a APxxKey_EL1 register requires a context
synchronization event to ensure that indirect reads made by subsequent
instructions (e.g. AUTIASP, PACIASP) observe the new value.

When we initialize the boot task's APIAKey in boot_init_stack_canary()
via ptrauth_keys_switch_kernel() we miss the necessary ISB, and so there
is a window where instructions are not guaranteed to use the new APIAKey
value. This has been observed to result in boot-time crashes where
PACIASP and AUTIASP within a function used a mixture of the old and new
key values.

Fix this by having ptrauth_keys_switch_kernel() synchronize the new key
value with an ISB. At the same time, __ptrauth_key_install() is renamed
to __ptrauth_key_install_nosync() so that it is obvious that this
performs no synchronization itself.

Fixes: 28321582334c261c ("arm64: initialize ptrauth keys for kernel booting task")
	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Reported-by: Will Deacon <will@kernel.org>
	Cc: Amit Daniel Kachhap <amit.kachhap@arm.com>
	Cc: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
	Tested-by: Will Deacon <will@kernel.org>
(cherry picked from commit 3fabb43818c9bfe7c4084badfa21d4e8187021a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/pointer_auth.h
diff --cc arch/arm64/include/asm/pointer_auth.h
index 0ef8e7fb9ddd,c6b4f0603024..000000000000
--- a/arch/arm64/include/asm/pointer_auth.h
+++ b/arch/arm64/include/asm/pointer_auth.h
@@@ -50,17 -54,19 +50,31 @@@ do {								
  	write_sysreg_s(__pki_v.hi, SYS_ ## k ## KEYHI_EL1);	\
  } while (0)
  
 -static __always_inline void ptrauth_keys_init_kernel(struct ptrauth_keys_kernel *keys)
 +static inline void ptrauth_keys_switch_user(struct ptrauth_keys_user *keys)
  {
++<<<<<<< HEAD
 +	if (system_supports_address_auth()) {
 +		__ptrauth_key_install(APIA, keys->apia);
 +		__ptrauth_key_install(APIB, keys->apib);
 +		__ptrauth_key_install(APDA, keys->apda);
 +		__ptrauth_key_install(APDB, keys->apdb);
 +	}
 +
 +	if (system_supports_generic_auth())
 +		__ptrauth_key_install(APGA, keys->apga);
++=======
+ 	if (system_supports_address_auth())
+ 		get_random_bytes(&keys->apia, sizeof(keys->apia));
+ }
+ 
+ static __always_inline void ptrauth_keys_switch_kernel(struct ptrauth_keys_kernel *keys)
+ {
+ 	if (!system_supports_address_auth())
+ 		return;
+ 
+ 	__ptrauth_key_install_nosync(APIA, keys->apia);
+ 	isb();
++>>>>>>> 3fabb43818c9 (arm64: sync kernel APIAKey when installing)
  }
  
  extern int ptrauth_prctl_reset_keys(struct task_struct *tsk, unsigned long arg);
* Unmerged path arch/arm64/include/asm/pointer_auth.h
