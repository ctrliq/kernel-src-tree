sched/headers: Split out open-coded prototypes into kernel/sched/smp.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Ingo Molnar <mingo@kernel.org>
commit 1f8db4150536431b031585ecc2a6793f69245de2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/1f8db415.failed

Move the prototypes for sched_ttwu_pending() and send_call_function_single_ipi()
into the newly created kernel/sched/smp.h header, to make sure they are all
the same, and to architectures happy that use -Wmissing-prototypes.

	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1f8db4150536431b031585ecc2a6793f69245de2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/smp.c
diff --cc kernel/smp.c
index db3e44b3aed3,4dec04f7fdc5..000000000000
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@@ -21,11 -22,9 +21,17 @@@
  #include <linux/hypervisor.h>
  
  #include "smpboot.h"
++<<<<<<< HEAD
 +
 +enum {
 +	CSD_FLAG_LOCK		= 0x01,
 +	CSD_FLAG_SYNCHRONOUS	= 0x02,
 +};
++=======
+ #include "sched/smp.h"
+ 
+ #define CSD_TYPE(_csd)	((_csd)->flags & CSD_FLAG_TYPE_MASK)
++>>>>>>> 1f8db4150536 (sched/headers: Split out open-coded prototypes into kernel/sched/smp.h)
  
  struct call_function_data {
  	call_single_data_t	__percpu *csd;
@@@ -134,6 -133,23 +140,26 @@@ static __always_inline void csd_unlock(
  
  static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);
  
++<<<<<<< HEAD
++=======
+ void __smp_call_single_queue(int cpu, struct llist_node *node)
+ {
+ 	/*
+ 	 * The list addition should be visible before sending the IPI
+ 	 * handler locks the list to pull the entry off it because of
+ 	 * normal cache coherency rules implied by spinlocks.
+ 	 *
+ 	 * If IPIs can go out of order to the cache coherency protocol
+ 	 * in an architecture, sufficient synchronisation should be added
+ 	 * to arch code to make it appear to obey cache coherency WRT
+ 	 * locking and barrier primitives. Generic code isn't really
+ 	 * equipped to do the right thing...
+ 	 */
+ 	if (llist_add(node, &per_cpu(call_single_queue, cpu)))
+ 		send_call_function_single_ipi(cpu);
+ }
+ 
++>>>>>>> 1f8db4150536 (sched/headers: Split out open-coded prototypes into kernel/sched/smp.h)
  /*
   * Insert a previously allocated call_single_data_t element
   * for execution on the given CPU. data must already have
@@@ -191,15 -192,9 +217,19 @@@ static int generic_exec_single(int cpu
  void generic_smp_call_function_single_interrupt(void)
  {
  	flush_smp_call_function_queue(true);
 -}
  
++<<<<<<< HEAD
 +	/*
 +	 * Handle irq works queued remotely by irq_work_queue_on().
 +	 * Smp functions above are typically synchronous so they
 +	 * better run first since some other CPUs may be busy waiting
 +	 * for them.
 +	 */
 +	irq_work_run();
 +}
++=======
+ extern void irq_work_single(void *);
++>>>>>>> 1f8db4150536 (sched/headers: Split out open-coded prototypes into kernel/sched/smp.h)
  
  /**
   * flush_smp_call_function_queue - Flush pending smp-call-function callbacks
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 631f3e8030ae..fccd504277e5 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -24,6 +24,7 @@
 #include "../smpboot.h"
 
 #include "pelt.h"
+#include "smp.h"
 
 /*
  * Export tracepoints that act as a bare tracehook (ie: have no trace event
diff --git a/kernel/sched/smp.h b/kernel/sched/smp.h
new file mode 100644
index 000000000000..9620e323162c
--- /dev/null
+++ b/kernel/sched/smp.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Scheduler internal SMP callback types and methods between the scheduler
+ * and other internal parts of the core kernel:
+ */
+
+extern void sched_ttwu_pending(void *arg);
+
+extern void send_call_function_single_ipi(int cpu);
* Unmerged path kernel/smp.c
