rcutorture: Add crude tests for mem_dump_obj()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Paul E. McKenney <paulmck@kernel.org>
commit 0d3dd2c8eadb7d4404b8788f552fb2b824fe2c7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/0d3dd2c8.failed

This commit adds a few crude tests for mem_dump_obj() to rcutorture
runs.  Just to prevent bitrot, you understand!

	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
(cherry picked from commit 0d3dd2c8eadb7d4404b8788f552fb2b824fe2c7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slab_common.c
#	mm/util.c
diff --cc mm/slab_common.c
index c4ccaa31690d,4c6107e39f9a..000000000000
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@@ -619,6 -602,8 +620,11 @@@ void kmem_dump_obj(void *object
  		pr_info("    %pS\n", kp.kp_stack[i]);
  	}
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(kmem_dump_obj);
+ #endif
++>>>>>>> 0d3dd2c8eadb (rcutorture: Add crude tests for mem_dump_obj())
  
  #ifndef CONFIG_SLOB
  /* Create a cache during boot when no slab services are available yet */
diff --cc mm/util.c
index 39b3e63edeae,c37e24d5fa43..000000000000
--- a/mm/util.c
+++ b/mm/util.c
@@@ -870,3 -1014,5 +870,8 @@@ void mem_dump_obj(void *object
  	}
  	pr_cont(" non-slab/vmalloc memory.\n");
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(mem_dump_obj);
+ #endif
++>>>>>>> 0d3dd2c8eadb (rcutorture: Add crude tests for mem_dump_obj())
diff --git a/kernel/rcu/rcutorture.c b/kernel/rcu/rcutorture.c
index f8fd7949d02e..0fe9af6cf17f 100644
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@ -1866,6 +1866,45 @@ rcu_torture_stats(void *arg)
 		torture_shutdown_absorb("rcu_torture_stats");
 	} while (!torture_must_stop());
 	torture_kthread_stopping("rcu_torture_stats");
+
+	{
+		struct rcu_head *rhp;
+		struct kmem_cache *kcp;
+		static int z;
+
+		kcp = kmem_cache_create("rcuscale", 136, 8, SLAB_STORE_USER, NULL);
+		rhp = kmem_cache_alloc(kcp, GFP_KERNEL);
+		pr_alert("mem_dump_obj() slab test: rcu_torture_stats = %px, &rhp = %px, rhp = %px, &z = %px\n", stats_task, &rhp, rhp, &z);
+		pr_alert("mem_dump_obj(ZERO_SIZE_PTR):");
+		mem_dump_obj(ZERO_SIZE_PTR);
+		pr_alert("mem_dump_obj(NULL):");
+		mem_dump_obj(NULL);
+		pr_alert("mem_dump_obj(%px):", &rhp);
+		mem_dump_obj(&rhp);
+		pr_alert("mem_dump_obj(%px):", rhp);
+		mem_dump_obj(rhp);
+		pr_alert("mem_dump_obj(%px):", &rhp->func);
+		mem_dump_obj(&rhp->func);
+		pr_alert("mem_dump_obj(%px):", &z);
+		mem_dump_obj(&z);
+		kmem_cache_free(kcp, rhp);
+		kmem_cache_destroy(kcp);
+		rhp = kmalloc(sizeof(*rhp), GFP_KERNEL);
+		pr_alert("mem_dump_obj() kmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\n", stats_task, &rhp, rhp);
+		pr_alert("mem_dump_obj(kmalloc %px):", rhp);
+		mem_dump_obj(rhp);
+		pr_alert("mem_dump_obj(kmalloc %px):", &rhp->func);
+		mem_dump_obj(&rhp->func);
+		kfree(rhp);
+		rhp = vmalloc(4096);
+		pr_alert("mem_dump_obj() vmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\n", stats_task, &rhp, rhp);
+		pr_alert("mem_dump_obj(vmalloc %px):", rhp);
+		mem_dump_obj(rhp);
+		pr_alert("mem_dump_obj(vmalloc %px):", &rhp->func);
+		mem_dump_obj(&rhp->func);
+		vfree(rhp);
+	}
+
 	return 0;
 }
 
* Unmerged path mm/slab_common.c
* Unmerged path mm/util.c
