arm64: map FDT as RW for early_init_dt_scan()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Hsin-Yi Wang <hsinyi@chromium.org>
commit e112b032a72c78f15d0c803c5dc6be444c2e6c66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/e112b032.failed

Currently in arm64, FDT is mapped to RO before it's passed to
early_init_dt_scan(). However, there might be some codes
(eg. commit "fdt: add support for rng-seed") that need to modify FDT
during init. Map FDT to RO after early fixups are done.

	Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
	Reviewed-by: Stephen Boyd <swboyd@chromium.org>
	Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit e112b032a72c78f15d0c803c5dc6be444c2e6c66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/kaslr.c
#	arch/arm64/mm/mmu.c
diff --cc arch/arm64/kernel/kaslr.c
index edcd765b944c,d94a3e41cef9..000000000000
--- a/arch/arm64/kernel/kaslr.c
+++ b/arch/arm64/kernel/kaslr.c
@@@ -106,11 -90,9 +103,16 @@@ u64 __init kaslr_early_init(u64 dt_phys
  	 * attempt at mapping the FDT in setup_machine()
  	 */
  	early_fixmap_init();
++<<<<<<< HEAD
 +	fdt = __fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL);
 +	if (!fdt) {
 +		kaslr_status = KASLR_DISABLED_FDT_REMAP;
++=======
+ 	fdt = fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL);
+ 	if (!fdt)
++>>>>>>> e112b032a72c (arm64: map FDT as RW for early_init_dt_scan())
  		return 0;
 +	}
  
  	/*
  	 * Retrieve (and wipe) the seed from the FDT
diff --cc arch/arm64/mm/mmu.c
index b0ffa0f7db57,54e93583085c..000000000000
--- a/arch/arm64/mm/mmu.c
+++ b/arch/arm64/mm/mmu.c
@@@ -1252,17 -929,9 +1252,23 @@@ void *__init fixmap_remap_fdt(phys_addr
  	return dt_virt;
  }
  
++<<<<<<< HEAD
 +void *__init fixmap_remap_fdt(phys_addr_t dt_phys)
 +{
 +	void *dt_virt;
 +	int size;
 +
 +	dt_virt = __fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL_RO);
 +	if (!dt_virt)
 +		return NULL;
 +
 +	memblock_reserve(dt_phys, size);
 +	return dt_virt;
++=======
+ int __init arch_ioremap_p4d_supported(void)
+ {
+ 	return 0;
++>>>>>>> e112b032a72c (arm64: map FDT as RW for early_init_dt_scan())
  }
  
  int __init arch_ioremap_pud_supported(void)
diff --git a/arch/arm64/include/asm/mmu.h b/arch/arm64/include/asm/mmu.h
index 1106839e0d6f..338c9e1fe5c8 100644
--- a/arch/arm64/include/asm/mmu.h
+++ b/arch/arm64/include/asm/mmu.h
@@ -94,7 +94,7 @@ extern void init_mem_pgprot(void);
 extern void create_pgd_mapping(struct mm_struct *mm, phys_addr_t phys,
 			       unsigned long virt, phys_addr_t size,
 			       pgprot_t prot, bool page_mappings_only);
-extern void *fixmap_remap_fdt(phys_addr_t dt_phys);
+extern void *fixmap_remap_fdt(phys_addr_t dt_phys, int *size, pgprot_t prot);
 extern void mark_linear_text_alias_ro(void);
 extern bool kaslr_requires_kpti(void);
 
* Unmerged path arch/arm64/kernel/kaslr.c
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index 3beffa3f4fd4..231a48f367a9 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -181,9 +181,13 @@ static void __init smp_build_mpidr_hash(void)
 
 static void __init setup_machine_fdt(phys_addr_t dt_phys)
 {
-	void *dt_virt = fixmap_remap_fdt(dt_phys);
+	int size;
+	void *dt_virt = fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL);
 	const char *name;
 
+	if (dt_virt)
+		memblock_reserve(dt_phys, size);
+
 	if (!dt_virt || !early_init_dt_scan(dt_virt)) {
 		pr_crit("\n"
 			"Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n"
@@ -195,6 +199,9 @@ static void __init setup_machine_fdt(phys_addr_t dt_phys)
 			cpu_relax();
 	}
 
+	/* Early fixups are done, map the FDT as read-only now */
+	fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL_RO);
+
 	name = of_flat_dt_get_machine_name();
 	if (!name)
 		return;
* Unmerged path arch/arm64/mm/mmu.c
