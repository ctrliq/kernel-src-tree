mm/page_owner: record task command name

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Waiman Long <longman@redhat.com>
commit 865ed6a3278654ce4a55eb74c5283eeb82ad4699
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/865ed6a3.failed

The page_owner information currently includes the pid of the calling
task.  That is useful as long as the task is still running.  Otherwise,
the number is meaningless.  To have more information about the
allocating tasks that had exited by the time the page_owner information
is retrieved, we need to store the command name of the task.

Add a new comm field into page_owner structure to store the command name
and display it when the page_owner information is retrieved.

Link: https://lkml.kernel.org/r/20220202203036.744010-5-longman@redhat.com
	Signed-off-by: Waiman Long <longman@redhat.com>
	Acked-by: Rafael Aquini <aquini@redhat.com>
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Mike Rapoport <rppt@kernel.org>
	Cc: Petr Mladek <pmladek@suse.com>
	Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Sergey Senozhatsky <senozhatsky@chromium.org>
	Cc: Steven Rostedt (Google) <rostedt@goodmis.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 865ed6a3278654ce4a55eb74c5283eeb82ad4699)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_owner.c
diff --cc mm/page_owner.c
index d199c5bc2d6c,d56afa9c792e..000000000000
--- a/mm/page_owner.c
+++ b/mm/page_owner.c
@@@ -230,13 -235,14 +233,14 @@@ void __copy_page_owner(struct page *old
  	new_page_owner->pid = old_page_owner->pid;
  	new_page_owner->ts_nsec = old_page_owner->ts_nsec;
  	new_page_owner->free_ts_nsec = old_page_owner->ts_nsec;
+ 	strcpy(new_page_owner->comm, old_page_owner->comm);
  
  	/*
 -	 * We don't clear the bit on the old folio as it's going to be freed
 +	 * We don't clear the bit on the oldpage as it's going to be freed
  	 * after migration. Until then, the info can be useful in case of
 -	 * a bug, and the overall stats will be off a bit only temporarily.
 +	 * a bug, and the overal stats will be off a bit only temporarily.
  	 * Also, migrate_misplaced_transhuge_page() can still fail the
 -	 * migration and then we want the old folio to retain the info. But
 +	 * migration and then we want the oldpage to retain the info. But
  	 * in that case we also don't need to explicitly clear the info from
  	 * the new page, which will be freed.
  	 */
@@@ -382,20 -382,18 +386,26 @@@ print_page_owner(char __user *buf, size
  	if (!kbuf)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ret = snprintf(kbuf, count,
 +			"Page allocated via order %u, mask %#x(%pGg), pid %d, ts %llu ns, free_ts %llu ns\n",
++=======
+ 	ret = scnprintf(kbuf, count,
+ 			"Page allocated via order %u, mask %#x(%pGg), pid %d (%s), ts %llu ns, free_ts %llu ns\n",
++>>>>>>> 865ed6a32786 (mm/page_owner: record task command name)
  			page_owner->order, page_owner->gfp_mask,
  			&page_owner->gfp_mask, page_owner->pid,
- 			page_owner->ts_nsec, page_owner->free_ts_nsec);
+ 			page_owner->comm, page_owner->ts_nsec,
+ 			page_owner->free_ts_nsec);
  
 +	if (ret >= count)
 +		goto err;
 +
  	/* Print information relevant to grouping pages by mobility */
  	pageblock_mt = get_pageblock_migratetype(page);
 -	page_mt  = gfp_migratetype(page_owner->gfp_mask);
 -	ret += scnprintf(kbuf + ret, count - ret,
 -			"PFN %lu type %s Block %lu type %s Flags %pGp\n",
 +	page_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);
 +	ret += snprintf(kbuf + ret, count - ret,
 +			"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\n",
  			pfn,
  			migratetype_names[page_mt],
  			pfn >> pageblock_order,
@@@ -464,17 -454,16 +474,18 @@@ void __dump_page_owner(const struct pag
  	else
  		pr_alert("page_owner tracks the page as freed\n");
  
- 	pr_alert("page last allocated via order %u, migratetype %s, gfp_mask %#x(%pGg), pid %d, ts %llu, free_ts %llu\n",
+ 	pr_alert("page last allocated via order %u, migratetype %s, gfp_mask %#x(%pGg), pid %d (%s), ts %llu, free_ts %llu\n",
  		 page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask,
- 		 page_owner->pid, page_owner->ts_nsec, page_owner->free_ts_nsec);
+ 		 page_owner->pid, page_owner->comm, page_owner->ts_nsec,
+ 		 page_owner->free_ts_nsec);
  
  	handle = READ_ONCE(page_owner->handle);
 -	if (!handle)
 +	if (!handle) {
  		pr_alert("page_owner allocation stack trace missing\n");
 -	else
 -		stack_depot_print(handle);
 +	} else {
 +		nr_entries = stack_depot_fetch(handle, &entries);
 +		stack_trace_print(entries, nr_entries, 0);
 +	}
  
  	handle = READ_ONCE(page_owner->free_handle);
  	if (!handle) {
* Unmerged path mm/page_owner.c
