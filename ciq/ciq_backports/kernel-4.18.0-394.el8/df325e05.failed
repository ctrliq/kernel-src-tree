arm64: Validate tagged addresses in access_ok() called from kernel threads

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Catalin Marinas <catalin.marinas@arm.com>
commit df325e05a682e9c624f471835c35bd3f870d5e8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/df325e05.failed

__range_ok(), invoked from access_ok(), clears the tag of the user
address only if CONFIG_ARM64_TAGGED_ADDR_ABI is enabled and the thread
opted in to the relaxed ABI. The latter sets the TIF_TAGGED_ADDR thread
flag. In the case of asynchronous I/O (e.g. io_submit()), the
access_ok() may be called from a kernel thread. Since kernel threads
don't have TIF_TAGGED_ADDR set, access_ok() will fail for valid tagged
user addresses. Example from the ffs_user_copy_worker() thread:

	use_mm(io_data->mm);
	ret = ffs_copy_to_iter(io_data->buf, ret, &io_data->data);
	unuse_mm(io_data->mm);

Relax the __range_ok() check to always untag the user address if called
in the context of a kernel thread. The user pointers would have already
been checked via aio_setup_rw() -> import_{single_range,iovec}() at the
time of the asynchronous I/O request.

Fixes: 63f0c6037965 ("arm64: Introduce prctl() options to control the tagged user addresses ABI")
	Cc: <stable@vger.kernel.org> # 5.4.x-
	Cc: Will Deacon <will@kernel.org>
	Reported-by: Evgenii Stepanov <eugenis@google.com>
	Tested-by: Evgenii Stepanov <eugenis@google.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit df325e05a682e9c624f471835c35bd3f870d5e8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/uaccess.h
diff --cc arch/arm64/include/asm/uaccess.h
index f8ed29514f60,cccb03e1ab1f..000000000000
--- a/arch/arm64/include/asm/uaccess.h
+++ b/arch/arm64/include/asm/uaccess.h
@@@ -74,7 -62,14 +74,18 @@@ static inline unsigned long __range_ok(
  {
  	unsigned long ret, limit = current_thread_info()->addr_limit;
  
++<<<<<<< HEAD
 +	addr = untagged_addr(addr);
++=======
+ 	/*
+ 	 * Asynchronous I/O running in a kernel thread does not have the
+ 	 * TIF_TAGGED_ADDR flag of the process owning the mm, so always untag
+ 	 * the user address before checking.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_ARM64_TAGGED_ADDR_ABI) &&
+ 	    (current->flags & PF_KTHREAD || test_thread_flag(TIF_TAGGED_ADDR)))
+ 		addr = untagged_addr(addr);
++>>>>>>> df325e05a682 (arm64: Validate tagged addresses in access_ok() called from kernel threads)
  
  	__chk_user_ptr(addr);
  	asm volatile(
* Unmerged path arch/arm64/include/asm/uaccess.h
