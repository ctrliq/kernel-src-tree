xfs: don't expose misaligned extszinherit hints to userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 5aa5b278237f356f86205c4b03d4cc64a293850a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/5aa5b278.failed

Commit 603f000b15f2 changed xfs_ioctl_setattr_check_extsize to reject an
attempt to set an EXTSZINHERIT extent size hint on a directory with
RTINHERIT set if the hint isn't a multiple of the realtime extent size.
However, I have recently discovered that it is possible to change the
realtime extent size when adding a rt device to a filesystem, which
means that the existence of directories with misaligned inherited hints
is not an accident.

As a result, it's possible that someone could have set a valid hint and
added an rt volume with a different rt extent size, which invalidates
the ondisk hints.  After such a sequence, FSGETXATTR will report a
misaligned hint, which FSSETXATTR will trip over, causing confusion if
the user was doing the usual GET/SET sequence to change some other
attribute.  Change xfs_fill_fsxattr to omit the hint if it isn't aligned
properly.

Fixes: 603f000b15f2 ("xfs: validate extsz hints against rt extent size when rtinherit is set")
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 5aa5b278237f356f86205c4b03d4cc64a293850a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_ioctl.c
index 0b05f7dd7822,16039ea10ac9..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1110,17 -1057,36 +1110,42 @@@ xfs_di2lxflags
  static void
  xfs_fill_fsxattr(
  	struct xfs_inode	*ip,
 -	int			whichfork,
 -	struct fileattr		*fa)
 +	bool			attr,
 +	struct fsxattr		*fa)
  {
 -	struct xfs_mount	*mp = ip->i_mount;
 -	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
 -
 +	struct xfs_ifork	*ifp = attr ? ip->i_afp : &ip->i_df;
 +
++<<<<<<< HEAD
 +	simple_fill_fsxattr(fa, xfs_ip2xflags(ip));
 +	fa->fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;
 +	fa->fsx_cowextsize = ip->i_d.di_cowextsize <<
 +			ip->i_mount->m_sb.sb_blocklog;
++=======
+ 	fileattr_fill_xflags(fa, xfs_ip2xflags(ip));
+ 
+ 	if (ip->i_diflags & XFS_DIFLAG_EXTSIZE) {
+ 		fa->fsx_extsize = XFS_FSB_TO_B(mp, ip->i_extsize);
+ 	} else if (ip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) {
+ 		/*
+ 		 * Don't let a misaligned extent size hint on a directory
+ 		 * escape to userspace if it won't pass the setattr checks
+ 		 * later.
+ 		 */
+ 		if ((ip->i_diflags & XFS_DIFLAG_RTINHERIT) &&
+ 		    ip->i_extsize % mp->m_sb.sb_rextsize > 0) {
+ 			fa->fsx_xflags &= ~(FS_XFLAG_EXTSIZE |
+ 					    FS_XFLAG_EXTSZINHERIT);
+ 			fa->fsx_extsize = 0;
+ 		} else {
+ 			fa->fsx_extsize = XFS_FSB_TO_B(mp, ip->i_extsize);
+ 		}
+ 	}
+ 
+ 	if (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 		fa->fsx_cowextsize = XFS_FSB_TO_B(mp, ip->i_cowextsize);
++>>>>>>> 5aa5b278237f (xfs: don't expose misaligned extszinherit hints to userspace)
  	fa->fsx_projid = ip->i_projid;
 -	if (ifp && !xfs_need_iread_extents(ifp))
 +	if (ifp && (ifp->if_flags & XFS_IFEXTENTS))
  		fa->fsx_nextents = xfs_iext_count(ifp);
  	else
  		fa->fsx_nextents = xfs_ifork_nextents(ifp);
* Unmerged path fs/xfs/xfs_ioctl.c
