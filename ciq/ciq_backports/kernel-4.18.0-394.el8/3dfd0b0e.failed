NFSD: Replace READ* macros in nfsd4_decode_clone()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 3dfd0b0e15671e2b4047ccb9222432f0b2d930be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/3dfd0b0e.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 3dfd0b0e15671e2b4047ccb9222432f0b2d930be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 974b50936d99,baf17d29097a..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -560,21 -572,9 +560,9 @@@ nfsd4_decode_fattr(struct nfsd4_compoun
  	if (attrlist4_count != xdr_stream_pos(argp->xdr) - starting_pos)
  		return nfserr_bad_xdr;
  
 -	return nfs_ok;
 +	DECODE_TAIL;
  }
  
- static __be32
- nfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)
- {
- 	DECODE_HEAD;
- 
- 	READ_BUF(sizeof(stateid_t));
- 	sid->si_generation = be32_to_cpup(p++);
- 	COPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));
- 
- 	DECODE_TAIL;
- }
- 
  static __be32
  nfsd4_decode_stateid4(struct nfsd4_compoundargs *argp, stateid_t *sid)
  {
@@@ -1766,23 -1907,45 +1754,65 @@@ nfsd4_decode_fallocate(struct nfsd4_com
  	return nfs_ok;
  }
  
++<<<<<<< HEAD
 +static __be32
 +nfsd4_decode_clone(struct nfsd4_compoundargs *argp, struct nfsd4_clone *clone)
 +{
 +	DECODE_HEAD;
 +
 +	status = nfsd4_decode_stateid(argp, &clone->cl_src_stateid);
 +	if (status)
 +		return status;
 +	status = nfsd4_decode_stateid(argp, &clone->cl_dst_stateid);
 +	if (status)
 +		return status;
 +
 +	READ_BUF(8 + 8 + 8);
 +	p = xdr_decode_hyper(p, &clone->cl_src_pos);
 +	p = xdr_decode_hyper(p, &clone->cl_dst_pos);
 +	p = xdr_decode_hyper(p, &clone->cl_count);
 +	DECODE_TAIL;
++=======
+ static __be32 nfsd4_decode_nl4_server(struct nfsd4_compoundargs *argp,
+ 				      struct nl4_server *ns)
+ {
+ 	struct nfs42_netaddr *naddr;
+ 	__be32 *p;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &ns->nl4_type) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	/* currently support for 1 inter-server source server */
+ 	switch (ns->nl4_type) {
+ 	case NL4_NETADDR:
+ 		naddr = &ns->u.nl4_addr;
+ 
+ 		if (xdr_stream_decode_u32(argp->xdr, &naddr->netid_len) < 0)
+ 			return nfserr_bad_xdr;
+ 		if (naddr->netid_len > RPCBIND_MAXNETIDLEN)
+ 			return nfserr_bad_xdr;
+ 
+ 		p = xdr_inline_decode(argp->xdr, naddr->netid_len);
+ 		if (!p)
+ 			return nfserr_bad_xdr;
+ 		memcpy(naddr->netid, p, naddr->netid_len);
+ 
+ 		if (xdr_stream_decode_u32(argp->xdr, &naddr->addr_len) < 0)
+ 			return nfserr_bad_xdr;
+ 		if (naddr->addr_len > RPCBIND_MAXUADDRLEN)
+ 			return nfserr_bad_xdr;
+ 
+ 		p = xdr_inline_decode(argp->xdr, naddr->addr_len);
+ 		if (!p)
+ 			return nfserr_bad_xdr;
+ 		memcpy(naddr->addr, p, naddr->addr_len);
+ 		break;
+ 	default:
+ 		return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
++>>>>>>> 3dfd0b0e1567 (NFSD: Replace READ* macros in nfsd4_decode_clone())
  }
  
  static __be32
* Unmerged path fs/nfsd/nfs4xdr.c
