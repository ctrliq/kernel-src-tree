xfs: remove XFS_IFEXTENTS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit b2197a36c0ef5b35a0ed83de744610a462da1ad3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/b2197a36.failed

The in-memory XFS_IFEXTENTS is now only used to check if an inode with
extents still needs the extents to be read into memory before doing
operations that need the extent map.  Add a new xfs_need_iread_extents
helper that returns true for btree format forks that do not have any
entries in the in-memory extent btree, and use that instead of checking
the XFS_IFEXTENTS flag.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit b2197a36c0ef5b35a0ed83de744610a462da1ad3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr_leaf.c
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_inode_fork.c
#	fs/xfs/libxfs/xfs_inode_fork.h
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/libxfs/xfs_attr_leaf.c
index d6ef69ab1c67,556184b63061..000000000000
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@@ -651,13 -651,8 +651,15 @@@ xfs_attr_shortform_create
  	trace_xfs_attr_sf_create(args);
  
  	ASSERT(ifp->if_bytes == 0);
- 	if (ifp->if_format == XFS_DINODE_FMT_EXTENTS) {
- 		ifp->if_flags &= ~XFS_IFEXTENTS;	/* just in case */
+ 	if (ifp->if_format == XFS_DINODE_FMT_EXTENTS)
  		ifp->if_format = XFS_DINODE_FMT_LOCAL;
++<<<<<<< HEAD
 +		ifp->if_flags |= XFS_IFINLINE;
 +	} else {
 +		ASSERT(ifp->if_flags & XFS_IFINLINE);
 +	}
++=======
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
  	xfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);
  	hdr = (struct xfs_attr_sf_hdr *)ifp->if_u1.if_data;
  	memset(hdr, 0, sizeof(*hdr));
diff --cc fs/xfs/libxfs/xfs_bmap.c
index a7275f2219c2,7e3b9b01431e..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -803,8 -805,6 +803,11 @@@ xfs_bmap_local_to_extents_empty
  	ASSERT(ifp->if_nextents == 0);
  
  	xfs_bmap_forkoff_reset(ip, whichfork);
++<<<<<<< HEAD
 +	ifp->if_flags &= ~XFS_IFINLINE;
 +	ifp->if_flags |= XFS_IFEXTENTS;
++=======
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
  	ifp->if_u1.if_root = NULL;
  	ifp->if_height = 0;
  	ifp->if_format = XFS_DINODE_FMT_EXTENTS;
@@@ -848,7 -848,6 +851,10 @@@ xfs_bmap_local_to_extents
  
  	flags = 0;
  	error = 0;
++<<<<<<< HEAD
 +	ASSERT((ifp->if_flags & (XFS_IFINLINE|XFS_IFEXTENTS)) == XFS_IFINLINE);
++=======
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
  	memset(&args, 0, sizeof(args));
  	args.tp = tp;
  	args.mp = ip->i_mount;
@@@ -1092,11 -1095,7 +1098,15 @@@ xfs_bmap_add_attrfork
  		goto trans_cancel;
  	ASSERT(ip->i_afp == NULL);
  
++<<<<<<< HEAD
 +	ip->i_afp = kmem_cache_zalloc(xfs_ifork_zone,
 +				      GFP_KERNEL | __GFP_NOFAIL);
 +
 +	ip->i_afp->if_format = XFS_DINODE_FMT_EXTENTS;
 +	ip->i_afp->if_flags = XFS_IFEXTENTS;
++=======
+ 	ip->i_afp = xfs_ifork_alloc(XFS_DINODE_FMT_EXTENTS, 0);
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
  	logflags = 0;
  	switch (ip->i_df.if_format) {
  	case XFS_DINODE_FMT_LOCAL:
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index d7590929c929,1d174909f9bd..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -60,8 -60,6 +60,11 @@@ xfs_init_local_fork
  	}
  
  	ifp->if_bytes = size;
++<<<<<<< HEAD
 +	ifp->if_flags &= ~XFS_IFEXTENTS;
 +	ifp->if_flags |= XFS_IFINLINE;
++=======
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
  }
  
  /*
diff --cc fs/xfs/libxfs/xfs_inode_fork.h
index 6b350307666e,a6f7897b6887..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@@ -28,12 -27,6 +27,15 @@@ struct xfs_ifork 
  };
  
  /*
++<<<<<<< HEAD
 + * Per-fork incore inode flags.
 + */
 +#define	XFS_IFINLINE	0x01	/* Inline data is read in */
 +#define	XFS_IFEXTENTS	0x02	/* All extent pointers are read in */
 +
 +/*
++=======
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
   * Worst-case increase in the fork extent count when we're adding a single
   * extent to a fork and there's no possibility of splitting an existing mapping.
   */
diff --cc fs/xfs/xfs_inode.c
index 663e877a1d44,17c2d8b18283..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -873,6 -859,20 +868,23 @@@ xfs_init_new_inode
  	}
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * If we need to create attributes immediately after allocating the
+ 	 * inode, initialise an empty attribute fork right now. We use the
+ 	 * default fork offset for attributes here as we don't know exactly what
+ 	 * size or how many attributes we might be adding. We can do this
+ 	 * safely here because we know the data fork is completely empty and
+ 	 * this saves us from needing to run a separate transaction to set the
+ 	 * fork offset in the immediate future.
+ 	 */
+ 	if (init_xattrs && xfs_sb_version_hasattr(&mp->m_sb)) {
+ 		ip->i_forkoff = xfs_default_attroffset(ip) >> 3;
+ 		ip->i_afp = xfs_ifork_alloc(XFS_DINODE_FMT_EXTENTS, 0);
+ 	}
+ 
+ 	/*
++>>>>>>> b2197a36c0ef (xfs: remove XFS_IFEXTENTS)
  	 * Log the new values stuffed into the inode.
  	 */
  	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
* Unmerged path fs/xfs/libxfs/xfs_attr_leaf.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
diff --git a/fs/xfs/libxfs/xfs_dir2_sf.c b/fs/xfs/libxfs/xfs_dir2_sf.c
index 8c4f76bba88b..de0c51c687dd 100644
--- a/fs/xfs/libxfs/xfs_dir2_sf.c
+++ b/fs/xfs/libxfs/xfs_dir2_sf.c
@@ -827,7 +827,6 @@ xfs_dir2_sf_create(
 	 * convert it to local format.
 	 */
 	if (dp->i_df.if_format == XFS_DINODE_FMT_EXTENTS) {
-		dp->i_df.if_flags &= ~XFS_IFEXTENTS;	/* just in case */
 		dp->i_df.if_format = XFS_DINODE_FMT_LOCAL;
 		xfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);
 		dp->i_df.if_flags |= XFS_IFINLINE;
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.h
diff --git a/fs/xfs/scrub/bmap.c b/fs/xfs/scrub/bmap.c
index 924d7e343731..b5ebf1d1b4db 100644
--- a/fs/xfs/scrub/bmap.c
+++ b/fs/xfs/scrub/bmap.c
@@ -447,7 +447,7 @@ xchk_bmap_btree(
 	int			error;
 
 	/* Load the incore bmap cache if it's not loaded. */
-	info->was_loaded = ifp->if_flags & XFS_IFEXTENTS;
+	info->was_loaded = !xfs_need_iread_extents(ifp);
 
 	error = xfs_iread_extents(sc->tp, ip, whichfork);
 	if (!xchk_fblock_process_error(sc, whichfork, 0, &error))
@@ -673,10 +673,6 @@ xchk_bmap(
 		/* No mappings to check. */
 		goto out;
 	case XFS_DINODE_FMT_EXTENTS:
-		if (!(ifp->if_flags & XFS_IFEXTENTS)) {
-			xchk_fblock_set_corrupt(sc, whichfork, 0);
-			goto out;
-		}
 		break;
 	case XFS_DINODE_FMT_BTREE:
 		if (whichfork == XFS_COW_FORK) {
diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index d54b31cc5434..403539b09bd7 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -300,8 +300,7 @@ xfs_map_blocks(
 	cow_fsb = NULLFILEOFF;
 	whichfork = XFS_DATA_FORK;
 	xfs_ilock(ip, XFS_ILOCK_SHARED);
-	ASSERT(ip->i_df.if_format != XFS_DINODE_FMT_BTREE ||
-	       (ip->i_df.if_flags & XFS_IFEXTENTS));
+	ASSERT(!xfs_need_iread_extents(&ip->i_df));
 
 	/*
 	 * Check if this is offset is covered by a COW extents, and if yes use
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index c240d29fdc85..fc58005a9d1d 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -554,7 +554,7 @@ xfs_bmap_punch_delalloc_range(
 	struct xfs_iext_cursor	icur;
 	int			error = 0;
 
-	ASSERT(ifp->if_flags & XFS_IFEXTENTS);
+	ASSERT(!xfs_need_iread_extents(ifp));
 
 	xfs_ilock(ip, XFS_ILOCK_EXCL);
 	if (!xfs_iext_lookup_extent_before(ip, ifp, &end_fsb, &icur, &got))
@@ -625,7 +625,7 @@ xfs_can_free_eofblocks(
 		return false;
 
 	/* If we haven't read in the extent list, then don't do it now. */
-	if (!(ip->i_df.if_flags & XFS_IFEXTENTS))
+	if (xfs_need_iread_extents(&ip->i_df))
 		return false;
 
 	/*
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 0b05f7dd7822..82231dd82290 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -1120,7 +1120,7 @@ xfs_fill_fsxattr(
 	fa->fsx_cowextsize = ip->i_d.di_cowextsize <<
 			ip->i_mount->m_sb.sb_blocklog;
 	fa->fsx_projid = ip->i_projid;
-	if (ifp && (ifp->if_flags & XFS_IFEXTENTS))
+	if (ifp && !xfs_need_iread_extents(ifp))
 		fa->fsx_nextents = xfs_iext_count(ifp);
 	else
 		fa->fsx_nextents = xfs_ifork_nextents(ifp);
diff --git a/fs/xfs/xfs_iomap.c b/fs/xfs/xfs_iomap.c
index 8ad84b4e35a6..d800144d6c78 100644
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@ -159,7 +159,7 @@ xfs_iomap_eof_align_last_fsb(
 	struct xfs_bmbt_irec	irec;
 	struct xfs_iext_cursor	icur;
 
-	ASSERT(ifp->if_flags & XFS_IFEXTENTS);
+	ASSERT(!xfs_need_iread_extents(ifp));
 
 	/*
 	 * Always round up the allocation request to the extent hint boundary.
@@ -667,7 +667,7 @@ xfs_ilock_for_iomap(
 	 * is an opencoded xfs_ilock_data_map_shared() call but with
 	 * non-blocking behaviour.
 	 */
-	if (!(ip->i_df.if_flags & XFS_IFEXTENTS)) {
+	if (xfs_need_iread_extents(&ip->i_df)) {
 		if (flags & IOMAP_NOWAIT)
 			return -EAGAIN;
 		mode = XFS_ILOCK_EXCL;
diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c
index 6b6bafbb12c3..05659a2421a0 100644
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@ -384,7 +384,7 @@ xfs_inactive_symlink_rmt(
 	xfs_trans_t	*tp;
 
 	mp = ip->i_mount;
-	ASSERT(ip->i_df.if_flags & XFS_IFEXTENTS);
+	ASSERT(!xfs_need_iread_extents(&ip->i_df));
 	/*
 	 * We're freeing a symlink that has some
 	 * blocks allocated to it.  Free the
