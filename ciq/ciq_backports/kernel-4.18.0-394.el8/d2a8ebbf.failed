kernel.h: split out container_of() and typeof_member() macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit d2a8ebbf8192b84b11f1b204c4f7c602df32aeac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/d2a8ebbf.failed

kernel.h is being used as a dump for all kinds of stuff for a long time.
Here is the attempt cleaning it up by splitting out container_of() and
typeof_member() macros.

For time being include new header back to kernel.h to avoid twisted
indirected includes for existing users.

Note, there are _a lot_ of headers and modules that include kernel.h
solely for one of these macros and this allows to unburden compiler for
the twisted inclusion paths and to make new code cleaner in the future.

Link: https://lkml.kernel.org/r/20211013170417.87909-3-andriy.shevchenko@linux.intel.com
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Boqun Feng <boqun.feng@gmail.com>
	Cc: Brendan Higgins <brendanhiggins@google.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Jonathan Cameron <jic23@kernel.org>
	Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
	Cc: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Thorsten Leemhuis <regressions@leemhuis.info>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Will Deacon <will@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d2a8ebbf8192b84b11f1b204c4f7c602df32aeac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kernel.h
diff --cc include/linux/kernel.h
index 53d39a685da6,ed4465757cec..000000000000
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@@ -9,15 -9,20 +9,16 @@@
  #include <linux/stddef.h>
  #include <linux/types.h>
  #include <linux/compiler.h>
+ #include <linux/container_of.h>
  #include <linux/bitops.h>
 -#include <linux/kstrtox.h>
  #include <linux/log2.h>
 -#include <linux/math.h>
  #include <linux/minmax.h>
  #include <linux/typecheck.h>
 -#include <linux/panic.h>
  #include <linux/printk.h>
  #include <linux/build_bug.h>
 -#include <linux/static_call_types.h>
  #include <asm/byteorder.h>
 -
  #include <uapi/linux/kernel.h>
 +#include <asm/div64.h>
  
  #define STACK_MAGIC	0xdeadbeef
  
@@@ -53,97 -53,6 +54,100 @@@
  }					\
  )
  
++<<<<<<< HEAD
 +/*
 + * This looks more complex than it should be. But we need to
 + * get the type for the ~ right in round_down (it needs to be
 + * as wide as the result!), and we want to evaluate the macro
 + * arguments just once each.
 + */
 +#define __round_mask(x, y) ((__typeof__(x))((y)-1))
 +#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)
 +#define round_down(x, y) ((x) & ~__round_mask(x, y))
 +
 +/**
 + * FIELD_SIZEOF - get the size of a struct's field
 + * @t: the target struct
 + * @f: the target struct's field
 + * Return: the size of @f in the struct definition without having a
 + * declared instance of @t.
 + */
 +#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))
 +
 +#define typeof_member(T, m)	typeof(((T*)0)->m)
 +
 +#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP
 +
 +#define DIV_ROUND_DOWN_ULL(ll, d) \
 +	({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })
 +
 +#define DIV_ROUND_UP_ULL(ll, d)		DIV_ROUND_DOWN_ULL((ll) + (d) - 1, (d))
 +
 +#if BITS_PER_LONG == 32
 +# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)
 +#else
 +# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)
 +#endif
 +
 +/* The `const' in roundup() prevents gcc-3.3 from calling __divdi3 */
 +#define roundup(x, y) (					\
 +{							\
 +	const typeof(y) __y = y;			\
 +	(((x) + (__y - 1)) / __y) * __y;		\
 +}							\
 +)
 +#define rounddown(x, y) (				\
 +{							\
 +	typeof(x) __x = (x);				\
 +	__x - (__x % (y));				\
 +}							\
 +)
 +
 +/*
 + * Divide positive or negative dividend by positive or negative divisor
 + * and round to closest integer. Result is undefined for negative
 + * divisors if the dividend variable type is unsigned and for negative
 + * dividends if the divisor variable type is unsigned.
 + */
 +#define DIV_ROUND_CLOSEST(x, divisor)(			\
 +{							\
 +	typeof(x) __x = x;				\
 +	typeof(divisor) __d = divisor;			\
 +	(((typeof(x))-1) > 0 ||				\
 +	 ((typeof(divisor))-1) > 0 ||			\
 +	 (((__x) > 0) == ((__d) > 0))) ?		\
 +		(((__x) + ((__d) / 2)) / (__d)) :	\
 +		(((__x) - ((__d) / 2)) / (__d));	\
 +}							\
 +)
 +/*
 + * Same as above but for u64 dividends. divisor must be a 32-bit
 + * number.
 + */
 +#define DIV_ROUND_CLOSEST_ULL(x, divisor)(		\
 +{							\
 +	typeof(divisor) __d = divisor;			\
 +	unsigned long long _tmp = (x) + (__d) / 2;	\
 +	do_div(_tmp, __d);				\
 +	_tmp;						\
 +}							\
 +)
 +
 +/*
 + * Multiplies an integer by a fraction, while avoiding unnecessary
 + * overflow or loss of precision.
 + */
 +#define mult_frac(x, numer, denom)(			\
 +{							\
 +	typeof(x) quot = (x) / (denom);			\
 +	typeof(x) rem  = (x) % (denom);			\
 +	(quot * (numer)) + ((rem * (numer)) / (denom));	\
 +}							\
 +)
 +
 +
++=======
++>>>>>>> d2a8ebbf8192 (kernel.h: split out container_of() and typeof_member() macros)
  #define _RET_IP_		(unsigned long)__builtin_return_address(0)
  #define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })
  
diff --git a/include/linux/container_of.h b/include/linux/container_of.h
new file mode 100644
index 000000000000..dd56019838c6
--- /dev/null
+++ b/include/linux/container_of.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_CONTAINER_OF_H
+#define _LINUX_CONTAINER_OF_H
+
+#include <linux/build_bug.h>
+#include <linux/err.h>
+
+#define typeof_member(T, m)	typeof(((T*)0)->m)
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({				\
+	void *__mptr = (void *)(ptr);					\
+	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
+			 !__same_type(*(ptr), void),			\
+			 "pointer type mismatch in container_of()");	\
+	((type *)(__mptr - offsetof(type, member))); })
+
+/**
+ * container_of_safe - cast a member of a structure out to the containing structure
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.
+ */
+#define container_of_safe(ptr, type, member) ({				\
+	void *__mptr = (void *)(ptr);					\
+	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
+			 !__same_type(*(ptr), void),			\
+			 "pointer type mismatch in container_of()");	\
+	IS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :			\
+		((type *)(__mptr - offsetof(type, member))); })
+
+#endif	/* _LINUX_CONTAINER_OF_H */
* Unmerged path include/linux/kernel.h
