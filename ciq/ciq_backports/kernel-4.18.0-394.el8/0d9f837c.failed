driver core: Export device_driver_attach()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 0d9f837c6958a4c14e6bcb5c5edf6c851d65f507
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/0d9f837c.failed

This is intended as a replacement API for device_bind_driver(). It has at
least the following benefits:

- Internal locking. Few of the users of device_bind_driver() follow the
  locking rules

- Calls device driver probe() internally. Notably this means that devm
  support for probe works correctly as probe() error will call
  devres_release_all()

- struct device_driver -> dev_groups is supported

- Simplified calling convention, no need to manually call probe().

The general usage is for situations that already know what driver to bind
and need to ensure the bind is synchronized with other logic. Call
device_driver_attach() after device_add().

If probe() returns a failure then this will be preserved up through to the
error return of device_driver_attach().

	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: https://lore.kernel.org/r/20210617142218.1877096-6-hch@lst.de
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit 0d9f837c6958a4c14e6bcb5c5edf6c851d65f507)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/device.h
diff --cc include/linux/device.h
index da6e1db2c903,d8b9c9e7d493..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1648,14 -845,16 +1648,25 @@@ static inline void *dev_get_platdata(co
   * Manual binding of a device to driver. See drivers/base/bus.c
   * for information on use.
   */
++<<<<<<< HEAD
 +extern int __must_check device_bind_driver(struct device *dev);
 +extern void device_release_driver(struct device *dev);
 +extern int  __must_check device_attach(struct device *dev);
 +extern int __must_check driver_attach(struct device_driver *drv);
 +extern void device_initial_probe(struct device *dev);
 +extern int __must_check device_reprobe(struct device *dev);
++=======
+ int __must_check device_driver_attach(struct device_driver *drv,
+ 				      struct device *dev);
+ int __must_check device_bind_driver(struct device *dev);
+ void device_release_driver(struct device *dev);
+ int  __must_check device_attach(struct device *dev);
+ int __must_check driver_attach(struct device_driver *drv);
+ void device_initial_probe(struct device *dev);
+ int __must_check device_reprobe(struct device *dev);
++>>>>>>> 0d9f837c6958 (driver core: Export device_driver_attach())
  
 -bool device_is_bound(struct device *dev);
 +extern bool device_is_bound(struct device *dev);
  
  /*
   * Easy functions for dynamically creating devices on the fly
diff --git a/drivers/base/base.h b/drivers/base/base.h
index a0d7b1c3b6a4..5d652ff90aa5 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -140,7 +140,6 @@ extern int driver_add_groups(struct device_driver *drv,
 			     const struct attribute_group **groups);
 extern void driver_remove_groups(struct device_driver *drv,
 				 const struct attribute_group **groups);
-int device_driver_attach(struct device_driver *drv, struct device *dev);
 void device_driver_detach(struct device *dev);
 
 extern char *make_class_name(const char *name, struct kobject *kobj);
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 532d8dcbb5eb..a0c100086d8f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -513,6 +513,8 @@ static void driver_sysfs_remove(struct device *dev)
  * from a driver's probe() method.)
  *
  * This function must be called with the device lock held.
+ *
+ * Callers should prefer to use device_driver_attach() instead.
  */
 int device_bind_driver(struct device *dev)
 {
@@ -1031,6 +1033,7 @@ int device_driver_attach(struct device_driver *drv, struct device *dev)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(device_driver_attach);
 
 static void __driver_attach_async_helper(void *_dev, async_cookie_t cookie)
 {
* Unmerged path include/linux/device.h
