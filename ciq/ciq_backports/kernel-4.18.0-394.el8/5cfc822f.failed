NFSD: Remove macros that are no longer used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 5cfc822f3e77b0477e6602d399116130317f537a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/5cfc822f.failed

Now that all the NFSv4 decoder functions have been converted to
make direct calls to the xdr helpers, remove the unused C macros.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 5cfc822f3e77b0477e6602d399116130317f537a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
#	fs/nfsd/xdr4.h
diff --cc fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7,7142b0501451..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -98,122 -102,6 +98,125 @@@ check_filename(char *str, int len
  	return 0;
  }
  
++<<<<<<< HEAD
 +#define DECODE_HEAD				\
 +	__be32 *p;				\
 +	__be32 status
 +#define DECODE_TAIL				\
 +	status = 0;				\
 +out:						\
 +	return status;				\
 +xdr_error:					\
 +	dprintk("NFSD: xdr error (%s:%d)\n",	\
 +			__FILE__, __LINE__);	\
 +	status = nfserr_bad_xdr;		\
 +	goto out
 +
 +#define READMEM(x,nbytes) do {			\
 +	x = (char *)p;				\
 +	p += XDR_QUADLEN(nbytes);		\
 +} while (0)
 +#define SAVEMEM(x,nbytes) do {			\
 +	if (!(x = (p==argp->tmp || p == argp->tmpp) ? \
 + 		savemem(argp, p, nbytes) :	\
 + 		(char *)p)) {			\
 +		dprintk("NFSD: xdr error (%s:%d)\n", \
 +				__FILE__, __LINE__); \
 +		goto xdr_error;			\
 +		}				\
 +	p += XDR_QUADLEN(nbytes);		\
 +} while (0)
 +#define COPYMEM(x,nbytes) do {			\
 +	memcpy((x), p, nbytes);			\
 +	p += XDR_QUADLEN(nbytes);		\
 +} while (0)
 +
 +/* READ_BUF, read_buf(): nbytes must be <= PAGE_SIZE */
 +#define READ_BUF(nbytes)  do {			\
 +	if (nbytes <= (u32)((char *)argp->end - (char *)argp->p)) {	\
 +		p = argp->p;			\
 +		argp->p += XDR_QUADLEN(nbytes);	\
 +	} else if (!(p = read_buf(argp, nbytes))) { \
 +		dprintk("NFSD: xdr error (%s:%d)\n", \
 +				__FILE__, __LINE__); \
 +		goto xdr_error;			\
 +	}					\
 +} while (0)
 +
 +static void next_decode_page(struct nfsd4_compoundargs *argp)
 +{
 +	argp->p = page_address(argp->pagelist[0]);
 +	argp->pagelist++;
 +	if (argp->pagelen < PAGE_SIZE) {
 +		argp->end = argp->p + XDR_QUADLEN(argp->pagelen);
 +		argp->pagelen = 0;
 +	} else {
 +		argp->end = argp->p + (PAGE_SIZE>>2);
 +		argp->pagelen -= PAGE_SIZE;
 +	}
 +}
 +
 +static __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)
 +{
 +	/* We want more bytes than seem to be available.
 +	 * Maybe we need a new page, maybe we have just run out
 +	 */
 +	unsigned int avail = (char *)argp->end - (char *)argp->p;
 +	__be32 *p;
 +
 +	if (argp->pagelen == 0) {
 +		struct kvec *vec = &argp->rqstp->rq_arg.tail[0];
 +
 +		if (!argp->tail) {
 +			argp->tail = true;
 +			avail = vec->iov_len;
 +			argp->p = vec->iov_base;
 +			argp->end = vec->iov_base + avail;
 +		}
 +
 +		if (avail < nbytes)
 +			return NULL;
 +
 +		p = argp->p;
 +		argp->p += XDR_QUADLEN(nbytes);
 +		return p;
 +	}
 +
 +	if (avail + argp->pagelen < nbytes)
 +		return NULL;
 +	if (avail + PAGE_SIZE < nbytes) /* need more than a page !! */
 +		return NULL;
 +	/* ok, we can do it with the current plus the next page */
 +	if (nbytes <= sizeof(argp->tmp))
 +		p = argp->tmp;
 +	else {
 +		kfree(argp->tmpp);
 +		p = argp->tmpp = kmalloc(nbytes, GFP_KERNEL);
 +		if (!p)
 +			return NULL;
 +		
 +	}
 +	/*
 +	 * The following memcpy is safe because read_buf is always
 +	 * called with nbytes > avail, and the two cases above both
 +	 * guarantee p points to at least nbytes bytes.
 +	 */
 +	memcpy(p, argp->p, avail);
 +	next_decode_page(argp);
 +	memcpy(((char*)p)+avail, argp->p, (nbytes - avail));
 +	argp->p += XDR_QUADLEN(nbytes - avail);
 +	return p;
 +}
 +
 +static unsigned int compoundargs_bytes_left(struct nfsd4_compoundargs *argp)
 +{
 +	unsigned int this = (char *)argp->end - (char *)argp->p;
 +
 +	return this + argp->pagelen;
 +}
 +
++=======
++>>>>>>> 5cfc822f3e77 (NFSD: Remove macros that are no longer used)
  static int zero_clientid(clientid_t *clid)
  {
  	return (clid->cl_boot == 0) && (clid->cl_id == 0);
@@@ -5016,19 -5421,10 +5019,23 @@@ nfs4svc_decode_compoundargs(struct svc_
  {
  	struct nfsd4_compoundargs *args = rqstp->rq_argp;
  
++<<<<<<< HEAD
 +	if (rqstp->rq_arg.head[0].iov_len % 4) {
 +		/* client is nuts */
 +		dprintk("%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)",
 +			__func__, svc_addr(rqstp), be32_to_cpu(rqstp->rq_xid));
 +		return 0;
 +	}
 +	args->p = p;
 +	args->end = rqstp->rq_arg.head[0].iov_base + rqstp->rq_arg.head[0].iov_len;
 +	args->pagelist = rqstp->rq_arg.pages;
 +	args->pagelen = rqstp->rq_arg.page_len;
 +	args->tail = false;
 +	args->tmpp = NULL;
++=======
+ 	/* svcxdr_tmp_alloc */
++>>>>>>> 5cfc822f3e77 (NFSD: Remove macros that are no longer used)
  	args->to_free = NULL;
 -
 -	args->xdr = &rqstp->rq_arg_stream;
  	args->ops = args->iops;
  	args->rqstp = rqstp;
  
diff --cc fs/nfsd/xdr4.h
index 4ef0f6d3f1d7,e12fbe382e3f..000000000000
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@@ -671,15 -689,8 +664,19 @@@ struct svcxdr_tmpbuf 
  
  struct nfsd4_compoundargs {
  	/* scratch variables for XDR decode */
++<<<<<<< HEAD
 +	__be32 *			p;
 +	__be32 *			end;
 +	struct page **			pagelist;
 +	int				pagelen;
 +	bool				tail;
 +	__be32				tmp[8];
 +	__be32 *			tmpp;
++=======
+ 	struct xdr_stream		*xdr;
++>>>>>>> 5cfc822f3e77 (NFSD: Remove macros that are no longer used)
  	struct svcxdr_tmpbuf		*to_free;
 +
  	struct svc_rqst			*rqstp;
  
  	u32				taglen;
* Unmerged path fs/nfsd/nfs4xdr.c
* Unmerged path fs/nfsd/xdr4.h
