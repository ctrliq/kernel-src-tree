NFSD: Clean up after updating NFSv3 ACL encoders

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 1416f435303d81070c6bcf5a4a9b4ed0f7a9f013
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/1416f435.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 1416f435303d81070c6bcf5a4a9b4ed0f7a9f013)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3xdr.c
diff --cc fs/nfsd/nfs3xdr.c
index 657ede6555bb,fcfa0d611b93..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -377,62 -389,6 +370,65 @@@ svcxdr_encode_fattr3(struct svc_rqst *r
  	return true;
  }
  
++<<<<<<< HEAD
 +static __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)
 +{
 +	u64 f;
 +	switch(fsid_source(fhp)) {
 +	default:
 +	case FSIDSOURCE_DEV:
 +		p = xdr_encode_hyper(p, (u64)huge_encode_dev
 +				     (fhp->fh_dentry->d_sb->s_dev));
 +		break;
 +	case FSIDSOURCE_FSID:
 +		p = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);
 +		break;
 +	case FSIDSOURCE_UUID:
 +		f = ((u64*)fhp->fh_export->ex_uuid)[0];
 +		f ^= ((u64*)fhp->fh_export->ex_uuid)[1];
 +		p = xdr_encode_hyper(p, f);
 +		break;
 +	}
 +	return p;
 +}
 +
 +static __be32 *
 +encode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,
 +	      struct kstat *stat)
 +{
 +	struct user_namespace *userns = nfsd_user_namespace(rqstp);
 +	*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);
 +	*p++ = htonl((u32) (stat->mode & S_IALLUGO));
 +	*p++ = htonl((u32) stat->nlink);
 +	*p++ = htonl((u32) from_kuid_munged(userns, stat->uid));
 +	*p++ = htonl((u32) from_kgid_munged(userns, stat->gid));
 +	if (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {
 +		p = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);
 +	} else {
 +		p = xdr_encode_hyper(p, (u64) stat->size);
 +	}
 +	p = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);
 +	*p++ = htonl((u32) MAJOR(stat->rdev));
 +	*p++ = htonl((u32) MINOR(stat->rdev));
 +	p = encode_fsid(p, fhp);
 +	p = xdr_encode_hyper(p, stat->ino);
 +	p = encode_time3(p, &stat->atime);
 +	p = encode_time3(p, &stat->mtime);
 +	p = encode_time3(p, &stat->ctime);
 +
 +	return p;
 +}
 +
 +static __be32 *
 +encode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 +{
 +	/* Attributes to follow */
 +	*p++ = xdr_one;
 +	return encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);
 +}
 +
++=======
++>>>>>>> 1416f435303d (NFSD: Clean up after updating NFSv3 ACL encoders)
  static bool
  svcxdr_encode_wcc_attr(struct xdr_stream *xdr, const struct svc_fh *fhp)
  {
@@@ -502,37 -458,6 +498,40 @@@ no_post_op_attrs
  }
  
  /*
++<<<<<<< HEAD
 + * Encode post-operation attributes.
 + * The inode may be NULL if the call failed because of a stale file
 + * handle. In this case, no attributes are returned.
 + */
 +static __be32 *
 +encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 +{
 +	struct dentry *dentry = fhp->fh_dentry;
 +	if (dentry && d_really_is_positive(dentry)) {
 +	        __be32 err;
 +		struct kstat stat;
 +
 +		err = fh_getattr(fhp, &stat);
 +		if (!err) {
 +			*p++ = xdr_one;		/* attributes follow */
 +			lease_get_mtime(d_inode(dentry), &stat.mtime);
 +			return encode_fattr3(rqstp, p, fhp, &stat);
 +		}
 +	}
 +	*p++ = xdr_zero;
 +	return p;
 +}
 +
 +/* Helper for NFSv3 ACLs */
 +__be32 *
 +nfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 +{
 +	return encode_post_op_attr(rqstp, p, fhp);
 +}
 +
 +/*
++=======
++>>>>>>> 1416f435303d (NFSD: Clean up after updating NFSv3 ACL encoders)
   * Encode weak cache consistency data
   */
  static bool
* Unmerged path fs/nfsd/nfs3xdr.c
diff --git a/fs/nfsd/xdr3.h b/fs/nfsd/xdr3.h
index 05db8ca205b1..f7a5ddcb2111 100644
--- a/fs/nfsd/xdr3.h
+++ b/fs/nfsd/xdr3.h
@@ -308,8 +308,6 @@ int nfs3svc_encode_entry_plus(void *, const char *name,
 				int namlen, loff_t offset, u64 ino,
 				unsigned int);
 /* Helper functions for NFSv3 ACL code */
-__be32 *nfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p,
-				struct svc_fh *fhp);
 bool svcxdr_decode_nfs_fh3(struct xdr_stream *xdr, struct svc_fh *fhp);
 bool svcxdr_encode_nfsstat3(struct xdr_stream *xdr, __be32 status);
 bool svcxdr_encode_post_op_attr(struct svc_rqst *rqstp, struct xdr_stream *xdr,
