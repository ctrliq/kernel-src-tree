arm64: traps: Allow force_signal_inject to pass esr error code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Amit Daniel Kachhap <amit.kachhap@arm.com>
commit 4ef333b2d10680b5d966a733ed7171f72164fcd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/4ef333b2.failed

Some error signal need to pass proper ARM esr error code to userspace to
better identify the cause of the signal. So the function
force_signal_inject is extended to pass this as a parameter. The
existing code is not affected by this change.

	Signed-off-by: Amit Daniel Kachhap <amit.kachhap@arm.com>
	Reviewed-by: Dave Martin <Dave.Martin@arm.com>
Link: https://lore.kernel.org/r/20200914083656.21428-3-amit.kachhap@arm.com
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 4ef333b2d10680b5d966a733ed7171f72164fcd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/traps.c
diff --cc arch/arm64/kernel/traps.c
index 11c11d2edd5a,29fd00fe94f2..000000000000
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@@ -459,10 -455,10 +459,10 @@@ void arm64_notify_segfault(unsigned lon
  		code = SEGV_ACCERR;
  	mmap_read_unlock(current->mm);
  
- 	force_signal_inject(SIGSEGV, code, addr);
+ 	force_signal_inject(SIGSEGV, code, addr, 0);
  }
  
 -void do_undefinstr(struct pt_regs *regs)
 +asmlinkage void __exception do_undefinstr(struct pt_regs *regs)
  {
  	/* check for AArch32 breakpoint instructions */
  	if (!aarch32_break_handler(regs))
@@@ -471,9 -467,17 +471,21 @@@
  	if (call_undef_hook(regs) == 0)
  		return;
  
++<<<<<<< HEAD
 +	force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc);
 +	BUG_ON(!user_mode(regs));
++=======
+ 	BUG_ON(!user_mode(regs));
+ 	force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc, 0);
+ }
+ NOKPROBE_SYMBOL(do_undefinstr);
+ 
+ void do_bti(struct pt_regs *regs)
+ {
+ 	BUG_ON(!user_mode(regs));
+ 	force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc, 0);
++>>>>>>> 4ef333b2d106 (arm64: traps: Allow force_signal_inject to pass esr error code)
  }
 -NOKPROBE_SYMBOL(do_bti);
  
  #define __user_cache_maint(insn, address, res)			\
  	if (address >= user_addr_max()) {			\
diff --git a/arch/arm64/include/asm/traps.h b/arch/arm64/include/asm/traps.h
index f9c1aa6167d2..1e9058eedc4e 100644
--- a/arch/arm64/include/asm/traps.h
+++ b/arch/arm64/include/asm/traps.h
@@ -35,7 +35,7 @@ struct undef_hook {
 
 void register_undef_hook(struct undef_hook *hook);
 void unregister_undef_hook(struct undef_hook *hook);
-void force_signal_inject(int signal, int code, unsigned long address);
+void force_signal_inject(int signal, int code, unsigned long address, unsigned int err);
 void arm64_notify_segfault(unsigned long addr);
 void arm64_force_sig_fault(int signo, int code, void __user *addr, const char *str);
 void arm64_force_sig_mceerr(int code, void __user *addr, short lsb, const char *str);
diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c
index 462f42965524..a57e7cb80d3c 100644
--- a/arch/arm64/kernel/fpsimd.c
+++ b/arch/arm64/kernel/fpsimd.c
@@ -323,7 +323,7 @@ static void fpsimd_save(void)
 				 * re-enter user with corrupt state.
 				 * There's no way to recover, so kill it:
 				 */
-				force_signal_inject(SIGKILL, SI_KERNEL, 0);
+				force_signal_inject(SIGKILL, SI_KERNEL, 0, 0);
 				return;
 			}
 
@@ -948,7 +948,7 @@ asmlinkage void do_sve_acc(unsigned int esr, struct pt_regs *regs)
 {
 	/* Even if we chose not to use SVE, the hardware could still trap: */
 	if (unlikely(!system_supports_sve()) || WARN_ON(is_compat_task())) {
-		force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc);
+		force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc, 0);
 		return;
 	}
 
* Unmerged path arch/arm64/kernel/traps.c
