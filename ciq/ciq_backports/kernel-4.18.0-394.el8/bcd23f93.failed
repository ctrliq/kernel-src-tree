regmap-irq: Introduce inverted status registers support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Maxim Kochetkov <fido_max@inbox.ru>
commit bcd23f93d3984a94d64ce0b6bbfa3789c0e8ebaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/bcd23f93.failed

Some interrupt controllers have inverted status register:
cleared bits is active interrupts and set bits is inactive interrupts,
so add inverted status support to the framework.

	Signed-off-by: Maxim Kochetkov <fido_max@inbox.ru>
Link: https://lore.kernel.org/r/20210525034204.5272-1-fido_max@inbox.ru
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit bcd23f93d3984a94d64ce0b6bbfa3789c0e8ebaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/regmap.h
diff --cc include/linux/regmap.h
index 978a110b9d3e,f5f08dd0a116..000000000000
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@@ -1114,6 -1440,16 +1114,19 @@@ struct regmap_irq 
   * @clear_ack:  Use this to set 1 and 0 or vice-versa to clear interrupts.
   * @wake_invert: Inverted wake register: cleared bits are wake enabled.
   * @type_invert: Invert the type flags.
++<<<<<<< HEAD
++=======
+  * @type_in_mask: Use the mask registers for controlling irq type. For
+  *                interrupts defining type_rising/falling_mask use mask_base
+  *                for edge configuration and never update bits in type_base.
+  * @clear_on_unmask: For chips with interrupts cleared on read: read the status
+  *                   registers before unmasking interrupts to clear any bits
+  *                   set when they were masked.
+  * @not_fixed_stride: Used when chip peripherals are not laid out with fixed
+  * 		      stride. Must be used with sub_reg_offsets containing the
+  * 		      offsets to each peripheral.
+  * @status_invert: Inverted status register: cleared bits are active interrupts.
++>>>>>>> bcd23f93d398 (regmap-irq: Introduce inverted status registers support)
   * @runtime_pm:  Hold a runtime PM lock on the device when accessing it.
   *
   * @num_regs:    Number of registers in each control bank.
@@@ -1153,6 -1499,10 +1166,13 @@@ struct regmap_irq_chip 
  	bool wake_invert:1;
  	bool runtime_pm:1;
  	bool type_invert:1;
++<<<<<<< HEAD
++=======
+ 	bool type_in_mask:1;
+ 	bool clear_on_unmask:1;
+ 	bool not_fixed_stride:1;
+ 	bool status_invert:1;
++>>>>>>> bcd23f93d398 (regmap-irq: Introduce inverted status registers support)
  
  	int num_regs;
  
diff --git a/drivers/base/regmap/regmap-irq.c b/drivers/base/regmap/regmap-irq.c
index cfce97e25f84..798645ec565b 100644
--- a/drivers/base/regmap/regmap-irq.c
+++ b/drivers/base/regmap/regmap-irq.c
@@ -355,6 +355,10 @@ static irqreturn_t regmap_irq_thread(int irq, void *d)
 		}
 	}
 
+	if (chip->status_invert)
+		for (i = 0; i < data->chip->num_regs; i++)
+			data->status_buf[i] = ~data->status_buf[i];
+
 	/*
 	 * Ignore masked IRQs and ack if we need to; we ack early so
 	 * there is no race between handling and acknowleding the
@@ -585,6 +589,9 @@ int regmap_add_irq_chip_fwnode(struct fwnode_handle *fwnode,
 			goto err_alloc;
 		}
 
+		if (chip->status_invert)
+			d->status_buf[i] = ~d->status_buf[i];
+
 		if (d->status_buf[i] && (chip->ack_base || chip->use_ack)) {
 			reg = chip->ack_base +
 				(i * map->reg_stride * d->irq_reg_stride);
* Unmerged path include/linux/regmap.h
