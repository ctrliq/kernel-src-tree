NFS: Default change_attr_type to NFS4_CHANGE_TYPE_IS_UNDEFINED

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit eea413308f2e6deb00f061f18081a53f3ecc8cc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/eea41330.failed

Both NFSv3 and NFSv2 generate their change attribute from the ctime
value that was supplied by the server. However the problem is that there
are plenty of servers out there with ctime resolutions of 1ms or worse.
In a modern performance system, this is insufficient when trying to
decide which is the most recent set of attributes when, for instance, a
READ or GETATTR call races with a WRITE or SETATTR.

For this reason, let's revert to labelling the NFSv2/v3 change
attributes as NFS4_CHANGE_TYPE_IS_UNDEFINED. This will ensure we protect
against such races.

Fixes: 7b24dacf0840 ("NFS: Another inode revalidation improvement")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Tested-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit eea413308f2e6deb00f061f18081a53f3ecc8cc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs3xdr.c
#	fs/nfs/proc.c
diff --cc fs/nfs/nfs3xdr.c
index abbebc47d61b,9274c9c5efea..000000000000
--- a/fs/nfs/nfs3xdr.c
+++ b/fs/nfs/nfs3xdr.c
@@@ -2227,6 -2227,7 +2227,10 @@@ static int decode_fsinfo3resok(struct x
  
  	/* ignore properties */
  	result->lease_time = 0;
++<<<<<<< HEAD
++=======
+ 	result->change_attr_type = NFS4_CHANGE_TYPE_IS_UNDEFINED;
++>>>>>>> eea413308f2e (NFS: Default change_attr_type to NFS4_CHANGE_TYPE_IS_UNDEFINED)
  	return 0;
  }
  
diff --cc fs/nfs/proc.c
index 73ab7c59d3a7,ecc4e717808c..000000000000
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@@ -91,6 -91,7 +91,10 @@@ nfs_proc_get_root(struct nfs_server *se
  	info->dtpref = fsinfo.tsize;
  	info->maxfilesize = 0x7FFFFFFF;
  	info->lease_time = 0;
++<<<<<<< HEAD
++=======
+ 	info->change_attr_type = NFS4_CHANGE_TYPE_IS_UNDEFINED;
++>>>>>>> eea413308f2e (NFS: Default change_attr_type to NFS4_CHANGE_TYPE_IS_UNDEFINED)
  	return 0;
  }
  
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index a0989d931520..b2b2c26bfb9e 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -1779,8 +1779,10 @@ static int nfs_inode_finish_partial_attr_update(const struct nfs_fattr *fattr,
 		NFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_OTHER |
 		NFS_INO_INVALID_NLINK;
 	unsigned long cache_validity = NFS_I(inode)->cache_validity;
+	enum nfs4_change_attr_type ctype = NFS_SERVER(inode)->change_attr_type;
 
-	if (!(cache_validity & NFS_INO_INVALID_CHANGE) &&
+	if (ctype != NFS4_CHANGE_TYPE_IS_UNDEFINED &&
+	    !(cache_validity & NFS_INO_INVALID_CHANGE) &&
 	    (cache_validity & check_valid) != 0 &&
 	    (fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&
 	    nfs_inode_attrs_cmp_monotonic(fattr, inode) == 0)
* Unmerged path fs/nfs/nfs3xdr.c
* Unmerged path fs/nfs/proc.c
