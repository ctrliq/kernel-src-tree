arm64: pgtable: Implement p[mu]d_valid() and check in set_p[mu]d()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Will Deacon <will.deacon@arm.com>
commit 0795edaf3f1ff1ea58048515211280db004bbd68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/0795edaf.failed

Now that our walk-cache invalidation routines imply a DSB before the
invalidation, we no longer need one when we are clearing an entry during
unmap.

	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 0795edaf3f1ff1ea58048515211280db004bbd68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/pgtable.h
diff --cc arch/arm64/include/asm/pgtable.h
index 785faded4722,2ab2031b778c..000000000000
--- a/arch/arm64/include/asm/pgtable.h
+++ b/arch/arm64/include/asm/pgtable.h
@@@ -468,31 -429,12 +469,33 @@@ extern pgprot_t phys_mem_access_prot(st
  				 PUD_TYPE_TABLE)
  #endif
  
 +extern pgd_t init_pg_dir[PTRS_PER_PGD];
 +extern pgd_t init_pg_end[];
 +extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 +extern pgd_t idmap_pg_dir[PTRS_PER_PGD];
 +extern pgd_t tramp_pg_dir[PTRS_PER_PGD];
 +
 +extern void set_swapper_pgd(pgd_t *pgdp, pgd_t pgd);
 +
 +static inline bool in_swapper_pgdir(void *addr)
 +{
 +	return ((unsigned long)addr & PAGE_MASK) ==
 +	        ((unsigned long)swapper_pg_dir & PAGE_MASK);
 +}
 +
  static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
  {
 +#ifdef __PAGETABLE_PMD_FOLDED
 +	if (in_swapper_pgdir(pmdp)) {
 +		set_swapper_pgd((pgd_t *)pmdp, __pgd(pmd_val(pmd)));
 +		return;
 +	}
 +#endif /* __PAGETABLE_PMD_FOLDED */
 +
  	WRITE_ONCE(*pmdp, pmd);
- 	dsb(ishst);
+ 
+ 	if (pmd_valid(pmd))
+ 		dsb(ishst);
  }
  
  static inline void pmd_clear(pmd_t *pmdp)
@@@ -537,19 -480,14 +540,25 @@@ static inline void pte_unmap(pte_t *pte
  #define pud_none(pud)		(!pud_val(pud))
  #define pud_bad(pud)		(!(pud_val(pud) & PUD_TABLE_BIT))
  #define pud_present(pud)	pte_present(pud_pte(pud))
++<<<<<<< HEAD
 +#define pud_leaf(pud)		pud_sect(pud)
++=======
+ #define pud_valid(pud)		pte_valid(pud_pte(pud))
++>>>>>>> 0795edaf3f1f (arm64: pgtable: Implement p[mu]d_valid() and check in set_p[mu]d())
  
  static inline void set_pud(pud_t *pudp, pud_t pud)
  {
 +#ifdef __PAGETABLE_PUD_FOLDED
 +	if (in_swapper_pgdir(pudp)) {
 +		set_swapper_pgd((pgd_t *)pudp, __pgd(pud_val(pud)));
 +		return;
 +	}
 +#endif /* __PAGETABLE_PUD_FOLDED */
 +
  	WRITE_ONCE(*pudp, pud);
- 	dsb(ishst);
+ 
+ 	if (pud_valid(pud))
+ 		dsb(ishst);
  }
  
  static inline void pud_clear(pud_t *pudp)
* Unmerged path arch/arm64/include/asm/pgtable.h
