RDMA/rxe: Move crc32 init code to rxe_icrc.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit add2b3b80e3a9b8f06562efe79b44809f64640db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/add2b3b8.failed

This patch collects the code from rxe_register_device() that sets up the
crc32 calculation into a subroutine rxe_icrc_init() in rxe_icrc.c.

Link: https://lore.kernel.org/r/20210707040040.15434-8-rpearsonhpe@gmail.com
	Signed-off-by: Bob Pearson <rpearsonhpe@gmail.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit add2b3b80e3a9b8f06562efe79b44809f64640db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_icrc.c
diff --cc drivers/infiniband/sw/rxe/rxe_icrc.c
index 2edcc7327109,62bcdfc8e96a..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_icrc.c
+++ b/drivers/infiniband/sw/rxe/rxe_icrc.c
@@@ -7,6 -9,43 +9,46 @@@
  #include "rxe.h"
  #include "rxe_loc.h"
  
++<<<<<<< HEAD
++=======
+ int rxe_icrc_init(struct rxe_dev *rxe)
+ {
+ 	struct crypto_shash *tfm;
+ 
+ 	tfm = crypto_alloc_shash("crc32", 0, 0);
+ 	if (IS_ERR(tfm)) {
+ 		pr_warn("failed to init crc32 algorithm err:%ld\n",
+ 			       PTR_ERR(tfm));
+ 		return PTR_ERR(tfm);
+ 	}
+ 
+ 	rxe->tfm = tfm;
+ 
+ 	return 0;
+ }
+ 
+ static u32 rxe_crc32(struct rxe_dev *rxe, u32 crc, void *next, size_t len)
+ {
+ 	u32 icrc;
+ 	int err;
+ 
+ 	SHASH_DESC_ON_STACK(shash, rxe->tfm);
+ 
+ 	shash->tfm = rxe->tfm;
+ 	*(u32 *)shash_desc_ctx(shash) = crc;
+ 	err = crypto_shash_update(shash, next, len);
+ 	if (unlikely(err)) {
+ 		pr_warn_ratelimited("failed crc calculation, err: %d\n", err);
+ 		return crc32_le(crc, next, len);
+ 	}
+ 
+ 	icrc = *(u32 *)shash_desc_ctx(shash);
+ 	barrier_data(shash_desc_ctx(shash));
+ 
+ 	return icrc;
+ }
+ 
++>>>>>>> add2b3b80e3a (RDMA/rxe: Move crc32 init code to rxe_icrc.c)
  /* Compute a partial ICRC for all the IB transport headers. */
  static u32 rxe_icrc_hdr(struct sk_buff *skb, struct rxe_pkt_info *pkt)
  {
diff --git a/drivers/infiniband/sw/rxe/rxe.h b/drivers/infiniband/sw/rxe/rxe.h
index 586bc28974ef..a4d9f974301b 100644
--- a/drivers/infiniband/sw/rxe/rxe.h
+++ b/drivers/infiniband/sw/rxe/rxe.h
@@ -14,7 +14,6 @@
 
 #include <linux/module.h>
 #include <linux/skbuff.h>
-#include <linux/crc32.h>
 
 #include <rdma/ib_verbs.h>
 #include <rdma/ib_user_verbs.h>
* Unmerged path drivers/infiniband/sw/rxe/rxe_icrc.c
diff --git a/drivers/infiniband/sw/rxe/rxe_loc.h b/drivers/infiniband/sw/rxe/rxe_loc.h
index 76f3265c35f5..06f97d3d7020 100644
--- a/drivers/infiniband/sw/rxe/rxe_loc.h
+++ b/drivers/infiniband/sw/rxe/rxe_loc.h
@@ -194,6 +194,7 @@ int rxe_requester(void *arg);
 int rxe_responder(void *arg);
 
 /* rxe_icrc.c */
+int rxe_icrc_init(struct rxe_dev *rxe);
 int rxe_icrc_check(struct sk_buff *skb, struct rxe_pkt_info *pkt);
 void rxe_icrc_generate(struct sk_buff *skb, struct rxe_pkt_info *pkt);
 
diff --git a/drivers/infiniband/sw/rxe/rxe_verbs.c b/drivers/infiniband/sw/rxe/rxe_verbs.c
index fa4365563ed6..89ba4816d3ee 100644
--- a/drivers/infiniband/sw/rxe/rxe_verbs.c
+++ b/drivers/infiniband/sw/rxe/rxe_verbs.c
@@ -1154,7 +1154,6 @@ int rxe_register_device(struct rxe_dev *rxe, const char *ibdev_name)
 {
 	int err;
 	struct ib_device *dev = &rxe->ib_dev;
-	struct crypto_shash *tfm;
 
 	strscpy(dev->node_desc, "rxe", sizeof(dev->node_desc));
 
@@ -1173,13 +1172,9 @@ int rxe_register_device(struct rxe_dev *rxe, const char *ibdev_name)
 	if (err)
 		return err;
 
-	tfm = crypto_alloc_shash("crc32", 0, 0);
-	if (IS_ERR(tfm)) {
-		pr_err("failed to allocate crc algorithm err:%ld\n",
-		       PTR_ERR(tfm));
-		return PTR_ERR(tfm);
-	}
-	rxe->tfm = tfm;
+	err = rxe_icrc_init(rxe);
+	if (err)
+		return err;
 
 	err = ib_register_device(dev, ibdev_name, NULL);
 	if (err)
