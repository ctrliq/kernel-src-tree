NFS: Don't store NFS_INO_REVAL_FORCED

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit cc7f2dae63bca9579d65a46f3bf2c48a15961e19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/cc7f2dae.failed

NFS_INO_REVAL_FORCED is intended to tell us that the cache needs
revalidation despite the fact that we hold a delegation. We shouldn't
need to store it anymore, though.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit cc7f2dae63bca9579d65a46f3bf2c48a15961e19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/inode.c
index 5aab6b527a4e,7fa914e24fc4..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -213,10 -199,10 +213,17 @@@ void nfs_set_cache_invalid(struct inod
  
  	if (have_delegation) {
  		if (!(flags & NFS_INO_REVAL_FORCED))
++<<<<<<< HEAD
 +			flags &= ~NFS_INO_INVALID_OTHER;
 +		flags &= ~(NFS_INO_INVALID_CHANGE
 +				| NFS_INO_INVALID_SIZE
 +				| NFS_INO_INVALID_XATTR);
++=======
+ 			flags &= ~(NFS_INO_INVALID_MODE |
+ 				   NFS_INO_INVALID_OTHER |
+ 				   NFS_INO_INVALID_XATTR);
+ 		flags &= ~(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);
++>>>>>>> cc7f2dae63bc (NFS: Don't store NFS_INO_REVAL_FORCED)
  	} else if (flags & NFS_INO_REVAL_PAGECACHE)
  		flags |= NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE;
  
@@@ -2145,9 -2130,8 +2142,14 @@@ static int nfs_update_inode(struct inod
  			attr_changed = true;
  		}
  	} else if (server->caps & NFS_CAP_MODE) {
++<<<<<<< HEAD
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_OTHER
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_MODE;
++>>>>>>> cc7f2dae63bc (NFS: Don't store NFS_INO_REVAL_FORCED)
  		cache_revalidated = false;
  	}
  
@@@ -2187,9 -2169,8 +2187,14 @@@
  			attr_changed = true;
  		}
  	} else if (server->caps & NFS_CAP_NLINK) {
++<<<<<<< HEAD
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_OTHER
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_NLINK;
++>>>>>>> cc7f2dae63bc (NFS: Don't store NFS_INO_REVAL_FORCED)
  		cache_revalidated = false;
  	}
  
diff --cc fs/nfs/nfs4proc.c
index 2b64b461b599,bcbb057d5529..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -5429,11 -5477,7 +5429,15 @@@ static void nfs4_bitmask_set(__u32 bitm
  	if (cache_validity & NFS_INO_INVALID_BLOCKS)
  		bitmask[1] |= FATTR4_WORD1_SPACE_USED;
  
++<<<<<<< HEAD
 +	if (nfs4_have_delegation(inode, FMODE_READ) &&
 +	    !(cache_validity & NFS_INO_REVAL_FORCED))
 +		bitmask[0] &= ~FATTR4_WORD0_SIZE;
 +	else if (cache_validity &
 +		 (NFS_INO_INVALID_SIZE | NFS_INO_REVAL_PAGECACHE))
++=======
+ 	if (cache_validity & NFS_INO_INVALID_SIZE)
++>>>>>>> cc7f2dae63bc (NFS: Don't store NFS_INO_REVAL_FORCED)
  		bitmask[0] |= FATTR4_WORD0_SIZE;
  
  	for (i = 0; i < NFS4_BITMASK_SZ; i++)
diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c
index 37ef480bdc9b..fd34aa5d7e57 100644
--- a/fs/nfs/delegation.c
+++ b/fs/nfs/delegation.c
@@ -480,6 +480,22 @@ int nfs_inode_set_delegation(struct inode *inode, const struct cred *cred,
 	if (freeme == NULL)
 		goto out;
 add_new:
+	/*
+	 * If we didn't revalidate the change attribute before setting
+	 * the delegation, then pre-emptively ask for a full attribute
+	 * cache revalidation.
+	 */
+	spin_lock(&inode->i_lock);
+	if (NFS_I(inode)->cache_validity & NFS_INO_INVALID_CHANGE)
+		nfs_set_cache_invalid(inode,
+			NFS_INO_INVALID_ATIME | NFS_INO_INVALID_CTIME |
+			NFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |
+			NFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_NLINK |
+			NFS_INO_INVALID_OTHER | NFS_INO_INVALID_DATA |
+			NFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL |
+			NFS_INO_INVALID_XATTR);
+	spin_unlock(&inode->i_lock);
+
 	list_add_tail_rcu(&delegation->super_list, &server->delegations);
 	rcu_assign_pointer(nfsi->delegation, delegation);
 	delegation = NULL;
@@ -487,11 +503,6 @@ int nfs_inode_set_delegation(struct inode *inode, const struct cred *cred,
 	atomic_long_inc(&nfs_active_delegations);
 
 	trace_nfs4_set_delegation(inode, type);
-
-	spin_lock(&inode->i_lock);
-	if (NFS_I(inode)->cache_validity & (NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ATIME))
-		NFS_I(inode)->cache_validity |= NFS_INO_REVAL_FORCED;
-	spin_unlock(&inode->i_lock);
 out:
 	spin_unlock(&clp->cl_lock);
 	if (delegation != NULL)
diff --git a/fs/nfs/delegation.h b/fs/nfs/delegation.h
index 9b00a0b7f832..c19b4fd20781 100644
--- a/fs/nfs/delegation.h
+++ b/fs/nfs/delegation.h
@@ -84,8 +84,7 @@ int nfs4_inode_make_writeable(struct inode *inode);
 
 static inline int nfs_have_delegated_attributes(struct inode *inode)
 {
-	return NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&
-		!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);
+	return NFS_PROTO(inode)->have_delegation(inode, FMODE_READ);
 }
 
 #endif
* Unmerged path fs/nfs/inode.c
* Unmerged path fs/nfs/nfs4proc.c
