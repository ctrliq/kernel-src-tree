open: don't silently ignore unknown O-flags in openat2()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christian Brauner <christian.brauner@ubuntu.com>
commit cfe80306a0dd6d363934913e47c3f30d71b721e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/cfe80306.failed

The new openat2() syscall verifies that no unknown O-flag values are
set and returns an error to userspace if they are while the older open
syscalls like open() and openat() simply ignore unknown flag values:

  #define O_FLAG_CURRENTLY_INVALID (1 << 31)
  struct open_how how = {
          .flags = O_RDONLY | O_FLAG_CURRENTLY_INVALID,
          .resolve = 0,
  };

  /* fails */
  fd = openat2(-EBADF, "/dev/null", &how, sizeof(how));

  /* succeeds */
  fd = openat(-EBADF, "/dev/null", O_RDONLY | O_FLAG_CURRENTLY_INVALID);

However, openat2() silently truncates the upper 32 bits meaning:

  #define O_FLAG_CURRENTLY_INVALID_LOWER32 (1 << 31)
  #define O_FLAG_CURRENTLY_INVALID_UPPER32 (1 << 40)

  struct open_how how_lowe32 = {
          .flags = O_RDONLY | O_FLAG_CURRENTLY_INVALID_LOWER32,
  };

  struct open_how how_upper32 = {
          .flags = O_RDONLY | O_FLAG_CURRENTLY_INVALID_UPPER32,
  };

  /* fails */
  fd = openat2(-EBADF, "/dev/null", &how_lower32, sizeof(how_lower32));

  /* succeeds */
  fd = openat2(-EBADF, "/dev/null", &how_upper32, sizeof(how_upper32));

Fix this by preventing the immediate truncation in build_open_flags().

There's a snafu here though stripping FMODE_* directly from flags would
cause the upper 32 bits to be truncated as well due to integer promotion
rules since FMODE_* is unsigned int, O_* are signed ints (yuck).

In addition, struct open_flags currently defines flags to be 32 bit
which is reasonable. If we simply were to bump it to 64 bit we would
need to change a lot of code preemptively which doesn't seem worth it.
So simply add a compile-time check verifying that all currently known
O_* flags are within the 32 bit range and fail to build if they aren't
anymore.

This change shouldn't regress old open syscalls since they silently
truncate any unknown values anyway. It is a tiny semantic change for
openat2() but it is very unlikely people pass ing > 32 bit unknown flags
and the syscall is relatively new too.

Link: https://lore.kernel.org/r/20210528092417.3942079-3-brauner@kernel.org
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Aleksa Sarai <cyphar@cyphar.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: linux-fsdevel@vger.kernel.org
	Reported-by: Richard Guy Briggs <rgb@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Aleksa Sarai <cyphar@cyphar.com>
	Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
	Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
(cherry picked from commit cfe80306a0dd6d363934913e47c3f30d71b721e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/open.c
diff --cc fs/open.c
index d6677a68e98d,53bc0573c0ec..000000000000
--- a/fs/open.c
+++ b/fs/open.c
@@@ -967,24 -981,85 +967,58 @@@ struct file *open_with_fake_path(const 
  }
  EXPORT_SYMBOL(open_with_fake_path);
  
 -#define WILL_CREATE(flags)	(flags & (O_CREAT | __O_TMPFILE))
 -#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
 -
 -inline struct open_how build_open_how(int flags, umode_t mode)
 +inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)
  {
++<<<<<<< HEAD
 +	int lookup_flags = 0;
 +	int acc_mode = ACC_MODE(flags);
 +
++=======
+ 	struct open_how how = {
+ 		.flags = flags & VALID_OPEN_FLAGS,
+ 		.mode = mode & S_IALLUGO,
+ 	};
+ 
+ 	/* O_PATH beats everything else. */
+ 	if (how.flags & O_PATH)
+ 		how.flags &= O_PATH_FLAGS;
+ 	/* Modes should only be set for create-like flags. */
+ 	if (!WILL_CREATE(how.flags))
+ 		how.mode = 0;
+ 	return how;
+ }
+ 
+ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
+ {
+ 	u64 flags = how->flags;
+ 	u64 strip = FMODE_NONOTIFY | O_CLOEXEC;
+ 	int lookup_flags = 0;
+ 	int acc_mode = ACC_MODE(flags);
+ 
+ 	BUILD_BUG_ON_MSG(upper_32_bits(VALID_OPEN_FLAGS),
+ 			 "struct open_flags doesn't yet handle flags > 32 bits");
+ 
+ 	/*
+ 	 * Strip flags that either shouldn't be set by userspace like
+ 	 * FMODE_NONOTIFY or that aren't relevant in determining struct
+ 	 * open_flags like O_CLOEXEC.
+ 	 */
+ 	flags &= ~strip;
+ 
++>>>>>>> cfe80306a0dd (open: don't silently ignore unknown O-flags in openat2())
  	/*
 -	 * Older syscalls implicitly clear all of the invalid flags or argument
 -	 * values before calling build_open_flags(), but openat2(2) checks all
 -	 * of its arguments.
 +	 * Clear out all open flags we don't know about so that we don't report
 +	 * them in fcntl(F_GETFD) or similar interfaces.
  	 */
 -	if (flags & ~VALID_OPEN_FLAGS)
 -		return -EINVAL;
 -	if (how->resolve & ~VALID_RESOLVE_FLAGS)
 -		return -EINVAL;
 +	flags &= VALID_OPEN_FLAGS;
  
 -	/* Scoping flags are mutually exclusive. */
 -	if ((how->resolve & RESOLVE_BENEATH) && (how->resolve & RESOLVE_IN_ROOT))
 -		return -EINVAL;
 -
 -	/* Deal with the mode. */
 -	if (WILL_CREATE(flags)) {
 -		if (how->mode & ~S_IALLUGO)
 -			return -EINVAL;
 -		op->mode = how->mode | S_IFREG;
 -	} else {
 -		if (how->mode != 0)
 -			return -EINVAL;
 +	if (flags & (O_CREAT | __O_TMPFILE))
 +		op->mode = (mode & S_IALLUGO) | S_IFREG;
 +	else
  		op->mode = 0;
 -	}
  
 -	/*
 -	 * In order to ensure programs get explicit errors when trying to use
 -	 * O_TMPFILE on old kernels, O_TMPFILE is implemented such that it
 -	 * looks like (O_DIRECTORY|O_RDWR & ~O_CREAT) to old kernels. But we
 -	 * have to require userspace to explicitly set it.
 -	 */
 -	if (flags & __O_TMPFILE) {
 -		if ((flags & O_TMPFILE_MASK) != O_TMPFILE)
 -			return -EINVAL;
 -		if (!(acc_mode & MAY_WRITE))
 -			return -EINVAL;
 -	}
 -	if (flags & O_PATH) {
 -		/* O_PATH only permits certain other flags to be set. */
 -		if (flags & ~O_PATH_FLAGS)
 -			return -EINVAL;
 -		acc_mode = 0;
 -	}
 +	/* Must never be set by userspace */
 +	flags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;
  
  	/*
  	 * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only
* Unmerged path fs/open.c
