NFSD: Add tracepoints for EXCHANGEID edge cases

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit e8f80c5545ec5794644b48537449e48b009d608d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/e8f80c55.failed

Some of the most common cases are traced. Enough infrastructure is
now in place that more can be added later, as needed.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit e8f80c5545ec5794644b48537449e48b009d608d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/trace.h
diff --cc fs/nfsd/trace.h
index 2c7ada5dbc70,39b7caea4664..000000000000
--- a/fs/nfsd/trace.h
+++ b/fs/nfsd/trace.h
@@@ -592,15 -617,167 +592,71 @@@ TRACE_EVENT(nfsd_clid_inuse_err
  		__entry->cl_id = clp->cl_clientid.cl_id;
  		memcpy(__entry->addr, &clp->cl_addr,
  			sizeof(struct sockaddr_in6));
 -		__entry->flavor = clp->cl_cred.cr_flavor;
 -		memcpy(__entry->verifier, (void *)&clp->cl_verifier,
 -		       NFS4_VERIFIER_SIZE);
 -		memcpy(__get_str(name), clp->cl_name.data, clp->cl_name.len);
 -		__get_str(name)[clp->cl_name.len] = '\0';
 +		__entry->namelen = clp->cl_name.len;
 +		memcpy(__get_dynamic_array(name), clp->cl_name.data,
 +			clp->cl_name.len);
  	),
 -	TP_printk("addr=%pISpc name='%s' verifier=0x%s flavor=%s client=%08x:%08x",
 -		__entry->addr, __get_str(name),
 -		__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE),
 -		show_nfsd_authflavor(__entry->flavor),
 +	TP_printk("nfs4_clientid %.*s already in use by %pISpc, client %08x:%08x",
 +		__entry->namelen, __get_str(name), __entry->addr,
  		__entry->cl_boot, __entry->cl_id)
++<<<<<<< HEAD
++=======
+ );
+ 
+ #define DEFINE_CLID_EVENT(name) \
+ DEFINE_EVENT(nfsd_clid_class, nfsd_clid_##name, \
+ 	TP_PROTO(const struct nfs4_client *clp), \
+ 	TP_ARGS(clp))
+ 
+ DEFINE_CLID_EVENT(fresh);
+ DEFINE_CLID_EVENT(confirmed_r);
+ 
+ /*
+  * from fs/nfsd/filecache.h
+  */
+ TRACE_DEFINE_ENUM(NFSD_FILE_HASHED);
+ TRACE_DEFINE_ENUM(NFSD_FILE_PENDING);
+ TRACE_DEFINE_ENUM(NFSD_FILE_BREAK_READ);
+ TRACE_DEFINE_ENUM(NFSD_FILE_BREAK_WRITE);
+ TRACE_DEFINE_ENUM(NFSD_FILE_REFERENCED);
+ 
+ #define show_nf_flags(val)						\
+ 	__print_flags(val, "|",						\
+ 		{ 1 << NFSD_FILE_HASHED,	"HASHED" },		\
+ 		{ 1 << NFSD_FILE_PENDING,	"PENDING" },		\
+ 		{ 1 << NFSD_FILE_BREAK_READ,	"BREAK_READ" },		\
+ 		{ 1 << NFSD_FILE_BREAK_WRITE,	"BREAK_WRITE" },	\
+ 		{ 1 << NFSD_FILE_REFERENCED,	"REFERENCED"})
+ 
+ DECLARE_EVENT_CLASS(nfsd_file_class,
+ 	TP_PROTO(struct nfsd_file *nf),
+ 	TP_ARGS(nf),
+ 	TP_STRUCT__entry(
+ 		__field(unsigned int, nf_hashval)
+ 		__field(void *, nf_inode)
+ 		__field(int, nf_ref)
+ 		__field(unsigned long, nf_flags)
+ 		__field(unsigned char, nf_may)
+ 		__field(struct file *, nf_file)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->nf_hashval = nf->nf_hashval;
+ 		__entry->nf_inode = nf->nf_inode;
+ 		__entry->nf_ref = refcount_read(&nf->nf_ref);
+ 		__entry->nf_flags = nf->nf_flags;
+ 		__entry->nf_may = nf->nf_may;
+ 		__entry->nf_file = nf->nf_file;
+ 	),
+ 	TP_printk("hash=0x%x inode=%p ref=%d flags=%s may=%s file=%p",
+ 		__entry->nf_hashval,
+ 		__entry->nf_inode,
+ 		__entry->nf_ref,
+ 		show_nf_flags(__entry->nf_flags),
+ 		show_nfsd_may_flags(__entry->nf_may),
+ 		__entry->nf_file)
++>>>>>>> e8f80c5545ec (NFSD: Add tracepoints for EXCHANGEID edge cases)
  )
  
 -#define DEFINE_NFSD_FILE_EVENT(name) \
 -DEFINE_EVENT(nfsd_file_class, name, \
 -	TP_PROTO(struct nfsd_file *nf), \
 -	TP_ARGS(nf))
 -
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_alloc);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_put_final);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_unhash);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_put);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_unhash_and_release_locked);
 -
 -TRACE_EVENT(nfsd_file_acquire,
 -	TP_PROTO(struct svc_rqst *rqstp, unsigned int hash,
 -		 struct inode *inode, unsigned int may_flags,
 -		 struct nfsd_file *nf, __be32 status),
 -
 -	TP_ARGS(rqstp, hash, inode, may_flags, nf, status),
 -
 -	TP_STRUCT__entry(
 -		__field(u32, xid)
 -		__field(unsigned int, hash)
 -		__field(void *, inode)
 -		__field(unsigned long, may_flags)
 -		__field(int, nf_ref)
 -		__field(unsigned long, nf_flags)
 -		__field(unsigned long, nf_may)
 -		__field(struct file *, nf_file)
 -		__field(u32, status)
 -	),
 -
 -	TP_fast_assign(
 -		__entry->xid = be32_to_cpu(rqstp->rq_xid);
 -		__entry->hash = hash;
 -		__entry->inode = inode;
 -		__entry->may_flags = may_flags;
 -		__entry->nf_ref = nf ? refcount_read(&nf->nf_ref) : 0;
 -		__entry->nf_flags = nf ? nf->nf_flags : 0;
 -		__entry->nf_may = nf ? nf->nf_may : 0;
 -		__entry->nf_file = nf ? nf->nf_file : NULL;
 -		__entry->status = be32_to_cpu(status);
 -	),
 -
 -	TP_printk("xid=0x%x hash=0x%x inode=%p may_flags=%s ref=%d nf_flags=%s nf_may=%s nf_file=%p status=%u",
 -			__entry->xid, __entry->hash, __entry->inode,
 -			show_nfsd_may_flags(__entry->may_flags),
 -			__entry->nf_ref, show_nf_flags(__entry->nf_flags),
 -			show_nfsd_may_flags(__entry->nf_may),
 -			__entry->nf_file, __entry->status)
 -);
 -
 -DECLARE_EVENT_CLASS(nfsd_file_search_class,
 -	TP_PROTO(struct inode *inode, unsigned int hash, int found),
 -	TP_ARGS(inode, hash, found),
 -	TP_STRUCT__entry(
 -		__field(struct inode *, inode)
 -		__field(unsigned int, hash)
 -		__field(int, found)
 -	),
 -	TP_fast_assign(
 -		__entry->inode = inode;
 -		__entry->hash = hash;
 -		__entry->found = found;
 -	),
 -	TP_printk("hash=0x%x inode=%p found=%d", __entry->hash,
 -			__entry->inode, __entry->found)
 -);
 -
 -#define DEFINE_NFSD_FILE_SEARCH_EVENT(name)				\
 -DEFINE_EVENT(nfsd_file_search_class, name,				\
 -	TP_PROTO(struct inode *inode, unsigned int hash, int found),	\
 -	TP_ARGS(inode, hash, found))
 -
 -DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode_sync);
 -DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode);
 -DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_is_cached);
 -
 -TRACE_EVENT(nfsd_file_fsnotify_handle_event,
 -	TP_PROTO(struct inode *inode, u32 mask),
 -	TP_ARGS(inode, mask),
 -	TP_STRUCT__entry(
 -		__field(struct inode *, inode)
 -		__field(unsigned int, nlink)
 -		__field(umode_t, mode)
 -		__field(u32, mask)
 -	),
 -	TP_fast_assign(
 -		__entry->inode = inode;
 -		__entry->nlink = inode->i_nlink;
 -		__entry->mode = inode->i_mode;
 -		__entry->mask = mask;
 -	),
 -	TP_printk("inode=%p nlink=%u mode=0%ho mask=0x%x", __entry->inode,
 -			__entry->nlink, __entry->mode, __entry->mask)
 -);
 -
  #include "cache.h"
  
  TRACE_DEFINE_ENUM(RC_DROPIT);
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 968845cb8307..e66c780741b5 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3131,6 +3131,7 @@ nfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 			}
 			/* case 6 */
 			exid->flags |= EXCHGID4_FLAG_CONFIRMED_R;
+			trace_nfsd_clid_confirmed_r(conf);
 			goto out_copy;
 		}
 		if (!creds_match) { /* case 3 */
@@ -3143,6 +3144,7 @@ nfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		}
 		if (verfs_match) { /* case 2 */
 			conf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;
+			trace_nfsd_clid_confirmed_r(conf);
 			goto out_copy;
 		}
 		/* case 5, client reboot */
@@ -3156,11 +3158,13 @@ nfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		goto out;
 	}
 
-	unconf  = find_unconfirmed_client_by_name(&exid->clname, nn);
+	unconf = find_unconfirmed_client_by_name(&exid->clname, nn);
 	if (unconf) /* case 4, possible retry or client restart */
 		unhash_client_locked(unconf);
 
-	/* case 1 (normal case) */
+	/* case 1, new owner ID */
+	trace_nfsd_clid_fresh(new);
+
 out_new:
 	if (conf) {
 		status = mark_client_expired_locked(conf);
@@ -3189,8 +3193,10 @@ nfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 out_nolock:
 	if (new)
 		expire_client(new);
-	if (unconf)
+	if (unconf) {
+		trace_nfsd_clid_expire_unconf(&unconf->cl_clientid);
 		expire_client(unconf);
+	}
 	return status;
 }
 
* Unmerged path fs/nfsd/trace.h
