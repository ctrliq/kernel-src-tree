NFSD: Replace READ* macros in nfsd4_decode_layoutreturn()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 645fcad371420913c30e9aca80fc0a38f3acf432
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/645fcad3.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 645fcad371420913c30e9aca80fc0a38f3acf432)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 33849a6c07cd,4a4cf3ea16f9..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -612,18 -624,171 +612,177 @@@ nfsd4_decode_state_owner4(struct nfsd4_
  	return nfsd4_decode_opaque(argp, owner);
  }
  
 -#ifdef CONFIG_NFSD_PNFS
 -static __be32
 -nfsd4_decode_deviceid4(struct nfsd4_compoundargs *argp,
 -		       struct nfsd4_deviceid *devid)
 +static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
  {
++<<<<<<< HEAD
 +	DECODE_HEAD;
 +	struct user_namespace *userns = nfsd_user_namespace(argp->rqstp);
 +	u32 dummy, uid, gid;
 +	char *machine_name;
 +	int i;
 +	int nr_secflavs;
++=======
+ 	__be32 *p;
+ 
+ 	p = xdr_inline_decode(argp->xdr, NFS4_DEVICEID4_SIZE);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	memcpy(devid, p, sizeof(*devid));
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_layoutupdate4(struct nfsd4_compoundargs *argp,
+ 			   struct nfsd4_layoutcommit *lcp)
+ {
+ 	if (xdr_stream_decode_u32(argp->xdr, &lcp->lc_layout_type) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_layout_type < LAYOUT_NFSV4_1_FILES)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_layout_type >= LAYOUT_TYPE_MAX)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &lcp->lc_up_len) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_up_len > 0) {
+ 		lcp->lc_up_layout = xdr_inline_decode(argp->xdr, lcp->lc_up_len);
+ 		if (!lcp->lc_up_layout)
+ 			return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_layoutreturn4(struct nfsd4_compoundargs *argp,
+ 			   struct nfsd4_layoutreturn *lrp)
+ {
+ 	__be32 status;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &lrp->lr_return_type) < 0)
+ 		return nfserr_bad_xdr;
+ 	switch (lrp->lr_return_type) {
+ 	case RETURN_FILE:
+ 		if (xdr_stream_decode_u64(argp->xdr, &lrp->lr_seg.offset) < 0)
+ 			return nfserr_bad_xdr;
+ 		if (xdr_stream_decode_u64(argp->xdr, &lrp->lr_seg.length) < 0)
+ 			return nfserr_bad_xdr;
+ 		status = nfsd4_decode_stateid4(argp, &lrp->lr_sid);
+ 		if (status)
+ 			return status;
+ 		if (xdr_stream_decode_u32(argp->xdr, &lrp->lrf_body_len) < 0)
+ 			return nfserr_bad_xdr;
+ 		if (lrp->lrf_body_len > 0) {
+ 			lrp->lrf_body = xdr_inline_decode(argp->xdr, lrp->lrf_body_len);
+ 			if (!lrp->lrf_body)
+ 				return nfserr_bad_xdr;
+ 		}
+ 		break;
+ 	case RETURN_FSID:
+ 	case RETURN_ALL:
+ 		lrp->lr_seg.offset = 0;
+ 		lrp->lr_seg.length = NFS4_MAX_UINT64;
+ 		break;
+ 	default:
+ 		return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ #endif /* CONFIG_NFSD_PNFS */
+ 
+ static __be32
+ nfsd4_decode_sessionid4(struct nfsd4_compoundargs *argp,
+ 			struct nfs4_sessionid *sessionid)
+ {
+ 	__be32 *p;
+ 
+ 	p = xdr_inline_decode(argp->xdr, NFS4_MAX_SESSIONID_LEN);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	memcpy(sessionid->data, p, sizeof(sessionid->data));
+ 	return nfs_ok;
+ }
+ 
+ /* Defined in Appendix A of RFC 5531 */
+ static __be32
+ nfsd4_decode_authsys_parms(struct nfsd4_compoundargs *argp,
+ 			   struct nfsd4_cb_sec *cbs)
+ {
+ 	u32 stamp, gidcount, uid, gid;
+ 	__be32 *p, status;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &stamp) < 0)
+ 		return nfserr_bad_xdr;
+ 	/* machine name */
+ 	status = nfsd4_decode_ignored_string(argp, 255);
+ 	if (status)
+ 		return status;
+ 	if (xdr_stream_decode_u32(argp->xdr, &uid) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &gid) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &gidcount) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (gidcount > 16)
+ 		return nfserr_bad_xdr;
+ 	p = xdr_inline_decode(argp->xdr, gidcount << 2);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	if (cbs->flavor == (u32)(-1)) {
+ 		struct user_namespace *userns = nfsd_user_namespace(argp->rqstp);
+ 
+ 		kuid_t kuid = make_kuid(userns, uid);
+ 		kgid_t kgid = make_kgid(userns, gid);
+ 		if (uid_valid(kuid) && gid_valid(kgid)) {
+ 			cbs->uid = kuid;
+ 			cbs->gid = kgid;
+ 			cbs->flavor = RPC_AUTH_UNIX;
+ 		} else {
+ 			dprintk("RPC_AUTH_UNIX with invalid uid or gid, ignoring!\n");
+ 		}
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_gss_cb_handles4(struct nfsd4_compoundargs *argp,
+ 			     struct nfsd4_cb_sec *cbs)
+ {
+ 	__be32 status;
+ 	u32 service;
+ 
+ 	dprintk("RPC_AUTH_GSS callback secflavor not supported!\n");
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &service) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (service < RPC_GSS_SVC_NONE || service > RPC_GSS_SVC_PRIVACY)
+ 		return nfserr_bad_xdr;
+ 	/* gcbp_handle_from_server */
+ 	status = nfsd4_decode_ignored_string(argp, 0);
+ 	if (status)
+ 		return status;
+ 	/* gcbp_handle_from_client */
+ 	status = nfsd4_decode_ignored_string(argp, 0);
+ 	if (status)
+ 		return status;
+ 
+ 	return nfs_ok;
+ }
+ 
+ /* a counted array of callback_sec_parms4 items */
+ static __be32
+ nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
+ {
+ 	u32 i, secflavor, nr_secflavs;
+ 	__be32 status;
++>>>>>>> 645fcad37142 (NFSD: Replace READ* macros in nfsd4_decode_layoutreturn())
  
  	/* callback_sec_params4 */
 -	if (xdr_stream_decode_u32(argp->xdr, &nr_secflavs) < 0)
 -		return nfserr_bad_xdr;
 +	READ_BUF(4);
 +	nr_secflavs = be32_to_cpup(p++);
  	if (nr_secflavs)
  		cbs->flavor = (u32)(-1);
  	else
* Unmerged path fs/nfsd/nfs4xdr.c
