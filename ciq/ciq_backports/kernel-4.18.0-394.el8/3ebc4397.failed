mm/page_owner: use scnprintf() to avoid excessive buffer overrun check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Waiman Long <longman@redhat.com>
commit 3ebc439761273274ea00258da84d997841f01e72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/3ebc4397.failed

The snprintf() function can return a length greater than the given input
size.  That will require a check for buffer overrun after each
invocation of snprintf().  scnprintf(), on the other hand, will never
return a greater length.

By using scnprintf() in selected places, we can avoid some buffer
overrun checks except after stack_depot_snprint() and after the last
snprintf().

Link: https://lkml.kernel.org/r/20220202203036.744010-3-longman@redhat.com
	Signed-off-by: Waiman Long <longman@redhat.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Reviewed-by: Sergey Senozhatsky <senozhatsky@chromium.org>
	Acked-by: Rafael Aquini <aquini@redhat.com>
	Acked-by: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Petr Mladek <pmladek@suse.com>
	Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Steven Rostedt (Google) <rostedt@goodmis.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3ebc439761273274ea00258da84d997841f01e72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_owner.c
diff --cc mm/page_owner.c
index 2da0e96ddc7e,28dac73e0542..000000000000
--- a/mm/page_owner.c
+++ b/mm/page_owner.c
@@@ -348,25 -344,18 +348,32 @@@ print_page_owner(char __user *buf, size
  			&page_owner->gfp_mask, page_owner->pid,
  			page_owner->ts_nsec, page_owner->free_ts_nsec);
  
- 	if (ret >= count)
- 		goto err;
- 
  	/* Print information relevant to grouping pages by mobility */
  	pageblock_mt = get_pageblock_migratetype(page);
++<<<<<<< HEAD
 +	page_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);
 +	ret += snprintf(kbuf + ret, count - ret,
 +			"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\n",
++=======
+ 	page_mt  = gfp_migratetype(page_owner->gfp_mask);
+ 	ret += scnprintf(kbuf + ret, count - ret,
+ 			"PFN %lu type %s Block %lu type %s Flags %pGp\n",
++>>>>>>> 3ebc43976127 (mm/page_owner: use scnprintf() to avoid excessive buffer overrun check)
  			pfn,
  			migratetype_names[page_mt],
  			pfn >> pageblock_order,
  			migratetype_names[pageblock_mt],
 -			&page->flags);
 +			page->flags, &page->flags);
 +
++<<<<<<< HEAD
 +	if (ret >= count)
 +		goto err;
  
 +	nr_entries = stack_depot_fetch(handle, &entries);
 +	ret += stack_trace_snprint(kbuf + ret, count - ret, entries, nr_entries, 0);
++=======
+ 	ret += stack_depot_snprint(handle, kbuf + ret, count - ret, 0);
++>>>>>>> 3ebc43976127 (mm/page_owner: use scnprintf() to avoid excessive buffer overrun check)
  	if (ret >= count)
  		goto err;
  
* Unmerged path mm/page_owner.c
