arm64: add support for the AMU extension v1

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Ionela Voinescu <ionela.voinescu@arm.com>
commit 2c9d45b43c39e26fd2a73f2203321cdaee98b58b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/2c9d45b4.failed

The activity monitors extension is an optional extension introduced
by the ARMv8.4 CPU architecture. This implements basic support for
version 1 of the activity monitors architecture, AMUv1.

This support includes:
- Extension detection on each CPU (boot, secondary, hotplugged)
- Register interface for AMU aarch64 registers

	Signed-off-by: Ionela Voinescu <ionela.voinescu@arm.com>
	Reviewed-by: Valentin Schneider <valentin.schneider@arm.com>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Marc Zyngier <maz@kernel.org>
	Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
	Cc: Will Deacon <will@kernel.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 2c9d45b43c39e26fd2a73f2203321cdaee98b58b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/cpucaps.h
#	arch/arm64/include/asm/cpufeature.h
#	arch/arm64/include/asm/sysreg.h
diff --cc arch/arm64/include/asm/cpucaps.h
index 7115f7a85078,185e44aa2713..000000000000
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@@ -61,18 -50,16 +61,32 @@@
  #define ARM64_HAS_GENERIC_AUTH_ARCH		40
  #define ARM64_HAS_GENERIC_AUTH_IMP_DEF		41
  #define ARM64_HAS_IRQ_PRIO_MASKING		42
++<<<<<<< HEAD
 +#define ARM64_WORKAROUND_CAVIUM_TX2_219_TVM	43
 +#define ARM64_WORKAROUND_CAVIUM_TX2_219_PRFM	44
 +#define ARM64_WORKAROUND_1463225		45
 +#define ARM64_WORKAROUND_1542419		46
 +#define ARM64_HAS_32BIT_EL1			47
 +#define ARM64_WORKAROUND_NVIDIA_CARMEL_CNP	48
 +#define ARM64_HAS_ARMv8_4_TTL			49
 +#define ARM64_HAS_TLB_RANGE			50
 +#define ARM64_HAS_DCPODP			51
 +#define ARM64_HAS_E0PD				52
 +#define ARM64_HAS_RNG				53
 +
 +#define ARM64_NCAPS				54
++=======
+ #define ARM64_HAS_DCPODP			43
+ #define ARM64_WORKAROUND_1463225		44
+ #define ARM64_WORKAROUND_CAVIUM_TX2_219_TVM	45
+ #define ARM64_WORKAROUND_CAVIUM_TX2_219_PRFM	46
+ #define ARM64_WORKAROUND_1542419		47
+ #define ARM64_WORKAROUND_SPECULATIVE_AT_NVHE	48
+ #define ARM64_HAS_E0PD				49
+ #define ARM64_HAS_RNG				50
+ #define ARM64_HAS_AMU_EXTN			51
+ 
+ #define ARM64_NCAPS				52
++>>>>>>> 2c9d45b43c39 (arm64: add support for the AMU extension v1)
  
  #endif /* __ASM_CPUCAPS_H */
diff --cc arch/arm64/include/asm/cpufeature.h
index 650f8b001f11,485e069d8768..000000000000
--- a/arch/arm64/include/asm/cpufeature.h
+++ b/arch/arm64/include/asm/cpufeature.h
@@@ -731,25 -665,24 +731,33 @@@ static inline u32 id_aa64mmfr0_parange_
  	}
  }
  
 -/* Check whether hardware update of the Access flag is supported */
 -static inline bool cpu_has_hw_af(void)
 +static inline unsigned int get_vmid_bits(u64 mmfr1)
  {
 -	u64 mmfr1;
 +	int vmid_bits;
  
 -	if (!IS_ENABLED(CONFIG_ARM64_HW_AFDBM))
 -		return false;
 +	vmid_bits = cpuid_feature_extract_unsigned_field(mmfr1,
 +						ID_AA64MMFR1_VMIDBITS_SHIFT);
 +	if (vmid_bits == ID_AA64MMFR1_VMIDBITS_16)
 +		return 16;
  
 -	mmfr1 = read_cpuid(ID_AA64MMFR1_EL1);
 -	return cpuid_feature_extract_unsigned_field(mmfr1,
 -						ID_AA64MMFR1_HADBS_SHIFT);
 +	/*
 +	 * Return the default here even if any reserved
 +	 * value is fetched from the system register.
 +	 */
 +	return 8;
  }
  
++<<<<<<< HEAD
 +u32 get_kvm_ipa_limit(void);
 +
 +extern int do_emulate_mrs(struct pt_regs *regs, u32 sys_reg, u32 rt);
++=======
+ #ifdef CONFIG_ARM64_AMU_EXTN
+ /* Check whether the cpu supports the Activity Monitors Unit (AMU) */
+ extern bool cpu_has_amu_feat(int cpu);
+ #endif
+ 
++>>>>>>> 2c9d45b43c39 (arm64: add support for the AMU extension v1)
  #endif /* __ASSEMBLY__ */
  
  #endif
diff --cc arch/arm64/include/asm/sysreg.h
index ac5b8295681a,085d248f824e..000000000000
--- a/arch/arm64/include/asm/sysreg.h
+++ b/arch/arm64/include/asm/sysreg.h
@@@ -412,8 -386,6 +412,11 @@@
  #define SYS_TPIDR_EL0			sys_reg(3, 3, 13, 0, 2)
  #define SYS_TPIDRRO_EL0			sys_reg(3, 3, 13, 0, 3)
  
++<<<<<<< HEAD
 +#define SYS_SCXTNUM_EL0			sys_reg(3, 3, 13, 0, 7)
 +
++=======
++>>>>>>> 2c9d45b43c39 (arm64: add support for the AMU extension v1)
  /* Definitions for system register interface to AMU for ARMv8.4 onwards */
  #define SYS_AM_EL0(crm, op2)		sys_reg(3, 3, 13, (crm), (op2))
  #define SYS_AMCR_EL0			SYS_AM_EL0(2, 0)
@@@ -440,9 -412,9 +443,15 @@@
   */
  
  #define SYS_AMEVCNTR0_EL0(n)		SYS_AM_EL0(4 + ((n) >> 3), (n) & 7)
++<<<<<<< HEAD
 +#define SYS_AMEVTYPER0_EL0(n)		SYS_AM_EL0(6 + ((n) >> 3), (n) & 7)
 +#define SYS_AMEVCNTR1_EL0(n)		SYS_AM_EL0(12 + ((n) >> 3), (n) & 7)
 +#define SYS_AMEVTYPER1_EL0(n)		SYS_AM_EL0(14 + ((n) >> 3), (n) & 7)
++=======
+ #define SYS_AMEVTYPE0_EL0(n)		SYS_AM_EL0(6 + ((n) >> 3), (n) & 7)
+ #define SYS_AMEVCNTR1_EL0(n)		SYS_AM_EL0(12 + ((n) >> 3), (n) & 7)
+ #define SYS_AMEVTYPE1_EL0(n)		SYS_AM_EL0(14 + ((n) >> 3), (n) & 7)
++>>>>>>> 2c9d45b43c39 (arm64: add support for the AMU extension v1)
  
  /* AMU v1: Fixed (architecturally defined) activity monitors */
  #define SYS_AMEVCNTR0_CORE_EL0		SYS_AMEVCNTR0_EL0(0)
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index e2a64679ab25..930af6756f48 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1441,6 +1441,33 @@ config ARM64_TLB_RANGE
 
 endmenu
 
+menu "ARMv8.4 architectural features"
+
+config ARM64_AMU_EXTN
+	bool "Enable support for the Activity Monitors Unit CPU extension"
+	default y
+	help
+	  The activity monitors extension is an optional extension introduced
+	  by the ARMv8.4 CPU architecture. This enables support for version 1
+	  of the activity monitors architecture, AMUv1.
+
+	  To enable the use of this extension on CPUs that implement it, say Y.
+
+	  Note that for architectural reasons, firmware _must_ implement AMU
+	  support when running on CPUs that present the activity monitors
+	  extension. The required support is present in:
+	    * Version 1.5 and later of the ARM Trusted Firmware
+
+	  For kernels that have this configuration enabled but boot with broken
+	  firmware, you may need to say N here until the firmware is fixed.
+	  Otherwise you may experience firmware panics or lockups when
+	  accessing the counter registers. Even if you are not observing these
+	  symptoms, the values returned by the register reads might not
+	  correctly reflect reality. Most commonly, the value read will be 0,
+	  indicating that the counter is not enabled.
+
+endmenu
+
 menu "ARMv8.5 architectural features"
 
 config ARM64_E0PD
* Unmerged path arch/arm64/include/asm/cpucaps.h
* Unmerged path arch/arm64/include/asm/cpufeature.h
* Unmerged path arch/arm64/include/asm/sysreg.h
diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c
index cd0347fe5991..219d5032f300 100644
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@ -175,6 +175,7 @@ static const struct arm64_ftr_bits ftr_id_aa64pfr0[] = {
 	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64PFR0_CSV3_SHIFT, 4, 0),
 	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64PFR0_CSV2_SHIFT, 4, 0),
 	ARM64_FTR_BITS(FTR_VISIBLE, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64PFR0_DIT_SHIFT, 4, 0),
+	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64PFR0_AMU_SHIFT, 4, 0),
 	ARM64_FTR_BITS(FTR_VISIBLE_IF_IS_ENABLED(CONFIG_ARM64_SVE),
 				   FTR_STRICT, FTR_LOWER_SAFE, ID_AA64PFR0_SVE_SHIFT, 4, 0),
 	ARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64PFR0_RAS_SHIFT, 4, 0),
@@ -1257,6 +1258,53 @@ static bool has_hw_dbm(const struct arm64_cpu_capabilities *cap,
 
 #endif
 
+#ifdef CONFIG_ARM64_AMU_EXTN
+
+/*
+ * The "amu_cpus" cpumask only signals that the CPU implementation for the
+ * flagged CPUs supports the Activity Monitors Unit (AMU) but does not provide
+ * information regarding all the events that it supports. When a CPU bit is
+ * set in the cpumask, the user of this feature can only rely on the presence
+ * of the 4 fixed counters for that CPU. But this does not guarantee that the
+ * counters are enabled or access to these counters is enabled by code
+ * executed at higher exception levels (firmware).
+ */
+static struct cpumask amu_cpus __read_mostly;
+
+bool cpu_has_amu_feat(int cpu)
+{
+	return cpumask_test_cpu(cpu, &amu_cpus);
+}
+
+static void cpu_amu_enable(struct arm64_cpu_capabilities const *cap)
+{
+	if (has_cpuid_feature(cap, SCOPE_LOCAL_CPU)) {
+		pr_info("detected CPU%d: Activity Monitors Unit (AMU)\n",
+			smp_processor_id());
+		cpumask_set_cpu(smp_processor_id(), &amu_cpus);
+	}
+}
+
+static bool has_amu(const struct arm64_cpu_capabilities *cap,
+		    int __unused)
+{
+	/*
+	 * The AMU extension is a non-conflicting feature: the kernel can
+	 * safely run a mix of CPUs with and without support for the
+	 * activity monitors extension. Therefore, unconditionally enable
+	 * the capability to allow any late CPU to use the feature.
+	 *
+	 * With this feature unconditionally enabled, the cpu_enable
+	 * function will be called for all CPUs that match the criteria,
+	 * including secondary and hotplugged, marking this feature as
+	 * present on that respective CPU. The enable function will also
+	 * print a detection message.
+	 */
+
+	return true;
+}
+#endif
+
 #ifdef CONFIG_ARM64_VHE
 static bool runs_at_el2(const struct arm64_cpu_capabilities *entry, int __unused)
 {
@@ -1546,6 +1594,24 @@ static const struct arm64_cpu_capabilities arm64_features[] = {
 		.cpu_enable = cpu_clear_disr,
 	},
 #endif /* CONFIG_ARM64_RAS_EXTN */
+#ifdef CONFIG_ARM64_AMU_EXTN
+	{
+		/*
+		 * The feature is enabled by default if CONFIG_ARM64_AMU_EXTN=y.
+		 * Therefore, don't provide .desc as we don't want the detection
+		 * message to be shown until at least one CPU is detected to
+		 * support the feature.
+		 */
+		.capability = ARM64_HAS_AMU_EXTN,
+		.type = ARM64_CPUCAP_WEAK_LOCAL_CPU_FEATURE,
+		.matches = has_amu,
+		.sys_reg = SYS_ID_AA64PFR0_EL1,
+		.sign = FTR_UNSIGNED,
+		.field_pos = ID_AA64PFR0_AMU_SHIFT,
+		.min_field_value = ID_AA64PFR0_AMU,
+		.cpu_enable = cpu_amu_enable,
+	},
+#endif /* CONFIG_ARM64_AMU_EXTN */
 	{
 		.desc = "Data cache clean to the PoU not required for I/D coherence",
 		.capability = ARM64_HAS_CACHE_IDC,
