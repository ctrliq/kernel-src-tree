arm64: Introduce prctl() options to control the tagged user addresses ABI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Catalin Marinas <catalin.marinas@arm.com>
commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/63f0c603.failed

It is not desirable to relax the ABI to allow tagged user addresses into
the kernel indiscriminately. This patch introduces a prctl() interface
for enabling or disabling the tagged ABI with a global sysctl control
for preventing applications from enabling the relaxed ABI (meant for
testing user-space prctl() return error checking without reconfiguring
the kernel). The ABI properties are inherited by threads of the same
application and fork()'ed children but cleared on execve(). A Kconfig
option allows the overall disabling of the relaxed ABI.

The PR_SET_TAGGED_ADDR_CTRL will be expanded in the future to handle
MTE-specific settings like imprecise vs precise exceptions.

	Reviewed-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/Kconfig
#	arch/arm64/include/asm/processor.h
#	arch/arm64/kernel/process.c
#	include/uapi/linux/prctl.h
#	kernel/sys.c
diff --cc arch/arm64/Kconfig
index 82242c7b1305,5d254178b9ca..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -1196,9 -1102,74 +1196,78 @@@ config RODATA_FULL_DEFAULT_ENABLE
  	  This requires the linear region to be mapped down to pages,
  	  which may adversely affect performance in some cases.
  
++<<<<<<< HEAD
++=======
+ config ARM64_SW_TTBR0_PAN
+ 	bool "Emulate Privileged Access Never using TTBR0_EL1 switching"
+ 	help
+ 	  Enabling this option prevents the kernel from accessing
+ 	  user-space memory directly by pointing TTBR0_EL1 to a reserved
+ 	  zeroed area and reserved ASID. The user access routines
+ 	  restore the valid TTBR0_EL1 temporarily.
+ 
+ config ARM64_TAGGED_ADDR_ABI
+ 	bool "Enable the tagged user addresses syscall ABI"
+ 	default y
+ 	help
+ 	  When this option is enabled, user applications can opt in to a
+ 	  relaxed ABI via prctl() allowing tagged addresses to be passed
+ 	  to system calls as pointer arguments. For details, see
+ 	  Documentation/arm64/tagged-address-abi.txt.
+ 
+ menuconfig COMPAT
+ 	bool "Kernel support for 32-bit EL0"
+ 	depends on ARM64_4K_PAGES || EXPERT
+ 	select COMPAT_BINFMT_ELF if BINFMT_ELF
+ 	select HAVE_UID16
+ 	select OLD_SIGSUSPEND3
+ 	select COMPAT_OLD_SIGACTION
+ 	help
+ 	  This option enables support for a 32-bit EL0 running under a 64-bit
+ 	  kernel at EL1. AArch32-specific components such as system calls,
+ 	  the user helper functions, VFP support and the ptrace interface are
+ 	  handled appropriately by the kernel.
+ 
+ 	  If you use a page size other than 4KB (i.e, 16KB or 64KB), please be aware
+ 	  that you will only be able to execute AArch32 binaries that were compiled
+ 	  with page size aligned segments.
+ 
+ 	  If you want to execute 32-bit userspace applications, say Y.
+ 
+ if COMPAT
+ 
+ config KUSER_HELPERS
+ 	bool "Enable kuser helpers page for 32 bit applications"
+ 	default y
+ 	help
+ 	  Warning: disabling this option may break 32-bit user programs.
+ 
+ 	  Provide kuser helpers to compat tasks. The kernel provides
+ 	  helper code to userspace in read only form at a fixed location
+ 	  to allow userspace to be independent of the CPU type fitted to
+ 	  the system. This permits binaries to be run on ARMv4 through
+ 	  to ARMv8 without modification.
+ 
+ 	  See Documentation/arm/kernel_user_helpers.rst for details.
+ 
+ 	  However, the fixed address nature of these helpers can be used
+ 	  by ROP (return orientated programming) authors when creating
+ 	  exploits.
+ 
+ 	  If all of the binaries and libraries which run on your platform
+ 	  are built specifically for your platform, and make no use of
+ 	  these helpers, then you can turn this option off to hinder
+ 	  such exploits. However, in that case, if a binary or library
+ 	  relying on those helpers is run, it will not function correctly.
+ 
+ 	  Say N here only if you are absolutely certain that you do not
+ 	  need these helpers; otherwise, the safe option is to say Y.
+ 
+ 
++>>>>>>> 63f0c6037965 (arm64: Introduce prctl() options to control the tagged user addresses ABI)
  menuconfig ARMV8_DEPRECATED
  	bool "Emulate deprecated/obsolete ARMv8 instructions"
 +	depends on COMPAT
  	depends on SYSCTL
  	help
  	  Legacy software support may require certain instructions
diff --cc arch/arm64/include/asm/processor.h
index 74c421a18b2c,28eed40ffc12..000000000000
--- a/arch/arm64/include/asm/processor.h
+++ b/arch/arm64/include/asm/processor.h
@@@ -321,5 -306,28 +321,31 @@@ extern void __init minsigstksz_setup(vo
  /* PR_PAC_RESET_KEYS prctl */
  #define PAC_RESET_KEYS(tsk, arg)	ptrauth_prctl_reset_keys(tsk, arg)
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_TAGGED_ADDR_ABI
+ /* PR_{SET,GET}_TAGGED_ADDR_CTRL prctl */
+ long set_tagged_addr_ctrl(unsigned long arg);
+ long get_tagged_addr_ctrl(void);
+ #define SET_TAGGED_ADDR_CTRL(arg)	set_tagged_addr_ctrl(arg)
+ #define GET_TAGGED_ADDR_CTRL()		get_tagged_addr_ctrl()
+ #endif
+ 
+ /*
+  * For CONFIG_GCC_PLUGIN_STACKLEAK
+  *
+  * These need to be macros because otherwise we get stuck in a nightmare
+  * of header definitions for the use of task_stack_page.
+  */
+ 
+ #define current_top_of_stack()							\
+ ({										\
+ 	struct stack_info _info;						\
+ 	BUG_ON(!on_accessible_stack(current, current_stack_pointer, &_info));	\
+ 	_info.high;								\
+ })
+ #define on_thread_stack()	(on_task_stack(current, current_stack_pointer, NULL))
+ 
++>>>>>>> 63f0c6037965 (arm64: Introduce prctl() options to control the tagged user addresses ABI)
  #endif /* __ASSEMBLY__ */
  #endif /* __ASM_PROCESSOR_H */
diff --cc arch/arm64/kernel/process.c
index edf46401e230,76b7c55026aa..000000000000
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@@ -28,9 -17,9 +28,10 @@@
  #include <linux/sched/task.h>
  #include <linux/sched/task_stack.h>
  #include <linux/kernel.h>
 +#include <linux/lockdep.h>
  #include <linux/mm.h>
  #include <linux/stddef.h>
+ #include <linux/sysctl.h>
  #include <linux/unistd.h>
  #include <linux/user.h>
  #include <linux/delay.h>
@@@ -578,18 -575,66 +587,84 @@@ void arch_setup_new_exec(void
  	ptrauth_thread_init_user(current);
  }
  
++<<<<<<< HEAD
 +asmlinkage void __sched arm64_preempt_schedule_irq(void)
 +{
 +	lockdep_assert_irqs_disabled();
 +
 +	/*
 +	 * Preempting a task from an IRQ means we leave copies of PSTATE
 +	 * on the stack. cpufeature's enable calls may modify PSTATE, but
 +	 * resuming one of these preempted tasks would undo those changes.
 +	 *
 +	 * Only allow a task to be preempted once cpufeatures have been
 +	 * enabled.
 +	 */
 +	if (system_capabilities_finalized())
 +		preempt_schedule_irq();
 +}
++=======
+ #ifdef CONFIG_ARM64_TAGGED_ADDR_ABI
+ /*
+  * Control the relaxed ABI allowing tagged user addresses into the kernel.
+  */
+ static unsigned int tagged_addr_prctl_allowed = 1;
+ 
+ long set_tagged_addr_ctrl(unsigned long arg)
+ {
+ 	if (!tagged_addr_prctl_allowed)
+ 		return -EINVAL;
+ 	if (is_compat_task())
+ 		return -EINVAL;
+ 	if (arg & ~PR_TAGGED_ADDR_ENABLE)
+ 		return -EINVAL;
+ 
+ 	update_thread_flag(TIF_TAGGED_ADDR, arg & PR_TAGGED_ADDR_ENABLE);
+ 
+ 	return 0;
+ }
+ 
+ long get_tagged_addr_ctrl(void)
+ {
+ 	if (!tagged_addr_prctl_allowed)
+ 		return -EINVAL;
+ 	if (is_compat_task())
+ 		return -EINVAL;
+ 
+ 	if (test_thread_flag(TIF_TAGGED_ADDR))
+ 		return PR_TAGGED_ADDR_ENABLE;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Global sysctl to disable the tagged user addresses support. This control
+  * only prevents the tagged address ABI enabling via prctl() and does not
+  * disable it for tasks that already opted in to the relaxed ABI.
+  */
+ static int zero;
+ static int one = 1;
+ 
+ static struct ctl_table tagged_addr_sysctl_table[] = {
+ 	{
+ 		.procname	= "tagged_addr",
+ 		.mode		= 0644,
+ 		.data		= &tagged_addr_prctl_allowed,
+ 		.maxlen		= sizeof(int),
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &one,
+ 	},
+ 	{ }
+ };
+ 
+ static int __init tagged_addr_init(void)
+ {
+ 	if (!register_sysctl("abi", tagged_addr_sysctl_table))
+ 		return -EINVAL;
+ 	return 0;
+ }
+ 
+ core_initcall(tagged_addr_init);
+ #endif	/* CONFIG_ARM64_TAGGED_ADDR_ABI */
++>>>>>>> 63f0c6037965 (arm64: Introduce prctl() options to control the tagged user addresses ABI)
diff --cc include/uapi/linux/prctl.h
index 947191def935,2e927b3e9d6c..000000000000
--- a/include/uapi/linux/prctl.h
+++ b/include/uapi/linux/prctl.h
@@@ -229,8 -229,9 +229,15 @@@ struct prctl_mm_map 
  # define PR_PAC_APDBKEY			(1UL << 3)
  # define PR_PAC_APGAKEY			(1UL << 4)
  
++<<<<<<< HEAD
 +/* Control reclaim behavior when allocating memory */
 +#define PR_SET_IO_FLUSHER		57
 +#define PR_GET_IO_FLUSHER		58
++=======
+ /* Tagged user address controls for arm64 */
+ #define PR_SET_TAGGED_ADDR_CTRL		55
+ #define PR_GET_TAGGED_ADDR_CTRL		56
+ # define PR_TAGGED_ADDR_ENABLE		(1UL << 0)
++>>>>>>> 63f0c6037965 (arm64: Introduce prctl() options to control the tagged user addresses ABI)
  
  #endif /* _LINUX_PRCTL_H */
diff --cc kernel/sys.c
index 871c0848f05c,c6c4d5358bd3..000000000000
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@@ -2496,28 -2498,11 +2502,36 @@@ SYSCALL_DEFINE5(prctl, int, option, uns
  			return -EINVAL;
  		error = PAC_RESET_KEYS(me, arg2);
  		break;
++<<<<<<< HEAD
 +	case PR_SET_IO_FLUSHER:
 +		if (!capable(CAP_SYS_RESOURCE))
 +			return -EPERM;
 +
 +		if (arg3 || arg4 || arg5)
 +			return -EINVAL;
 +
 +		if (arg2 == 1)
 +			current->flags |= PR_IO_FLUSHER;
 +		else if (!arg2)
 +			current->flags &= ~PR_IO_FLUSHER;
 +		else
 +			return -EINVAL;
 +		break;
 +	case PR_GET_IO_FLUSHER:
 +		if (!capable(CAP_SYS_RESOURCE))
 +			return -EPERM;
 +
 +		if (arg2 || arg3 || arg4 || arg5)
 +			return -EINVAL;
 +
 +		error = (current->flags & PR_IO_FLUSHER) == PR_IO_FLUSHER;
++=======
+ 	case PR_SET_TAGGED_ADDR_CTRL:
+ 		error = SET_TAGGED_ADDR_CTRL(arg2);
+ 		break;
+ 	case PR_GET_TAGGED_ADDR_CTRL:
+ 		error = GET_TAGGED_ADDR_CTRL();
++>>>>>>> 63f0c6037965 (arm64: Introduce prctl() options to control the tagged user addresses ABI)
  		break;
  	default:
  		error = -EINVAL;
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/include/asm/processor.h
diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
index f1d032be628a..354a31d2b737 100644
--- a/arch/arm64/include/asm/thread_info.h
+++ b/arch/arm64/include/asm/thread_info.h
@@ -99,6 +99,7 @@ void arch_release_task_struct(struct task_struct *tsk);
 #define TIF_SVE			23	/* Scalable Vector Extension in use */
 #define TIF_SVE_VL_INHERIT	24	/* Inherit sve_vl_onexec across exec */
 #define TIF_SSBD		25	/* Wants SSB mitigation */
+#define TIF_TAGGED_ADDR		26	/* Allow tagged user addresses */
 
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h
index 3145cbdaa143..a2efaa0ee04b 100644
--- a/arch/arm64/include/asm/uaccess.h
+++ b/arch/arm64/include/asm/uaccess.h
@@ -74,7 +74,9 @@ static inline unsigned long __range_ok(const void __user *addr, unsigned long si
 {
 	unsigned long ret, limit = current_thread_info()->addr_limit;
 
-	addr = untagged_addr(addr);
+	if (IS_ENABLED(CONFIG_ARM64_TAGGED_ADDR_ABI) &&
+	    test_thread_flag(TIF_TAGGED_ADDR))
+		addr = untagged_addr(addr);
 
 	__chk_user_ptr(addr);
 	asm volatile(
* Unmerged path arch/arm64/kernel/process.c
* Unmerged path include/uapi/linux/prctl.h
* Unmerged path kernel/sys.c
