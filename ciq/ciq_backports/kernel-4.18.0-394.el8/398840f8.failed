openat2: reject RESOLVE_BENEATH|RESOLVE_IN_ROOT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Aleksa Sarai <cyphar@cyphar.com>
commit 398840f8bb935d33c64df4ec4fed77a7d24c267d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/398840f8.failed

This was an oversight in the original implementation, as it makes no
sense to specify both scoping flags to the same openat2(2) invocation
(before this patch, the result of such an invocation was equivalent to
RESOLVE_IN_ROOT being ignored).

This is a userspace-visible ABI change, but the only user of openat2(2)
at the moment is LXC which doesn't specify both flags and so no
userspace programs will break as a result.

Fixes: fddb5d430ad9 ("open: introduce openat2(2) syscall")
	Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
	Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
	Cc: <stable@vger.kernel.org> # v5.6+
Link: https://lore.kernel.org/r/20201027235044.5240-2-cyphar@cyphar.com
	Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
(cherry picked from commit 398840f8bb935d33c64df4ec4fed77a7d24c267d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/open.c
diff --cc fs/open.c
index d6677a68e98d,4d7537ae59df..000000000000
--- a/fs/open.c
+++ b/fs/open.c
@@@ -972,19 -996,53 +972,34 @@@ inline int build_open_flags(int flags, 
  	int lookup_flags = 0;
  	int acc_mode = ACC_MODE(flags);
  
 -	/* Must never be set by userspace */
 -	flags &= ~(FMODE_NONOTIFY | O_CLOEXEC);
 -
  	/*
 -	 * Older syscalls implicitly clear all of the invalid flags or argument
 -	 * values before calling build_open_flags(), but openat2(2) checks all
 -	 * of its arguments.
 +	 * Clear out all open flags we don't know about so that we don't report
 +	 * them in fcntl(F_GETFD) or similar interfaces.
  	 */
 -	if (flags & ~VALID_OPEN_FLAGS)
 -		return -EINVAL;
 -	if (how->resolve & ~VALID_RESOLVE_FLAGS)
 -		return -EINVAL;
 +	flags &= VALID_OPEN_FLAGS;
  
++<<<<<<< HEAD
 +	if (flags & (O_CREAT | __O_TMPFILE))
 +		op->mode = (mode & S_IALLUGO) | S_IFREG;
 +	else
++=======
+ 	/* Scoping flags are mutually exclusive. */
+ 	if ((how->resolve & RESOLVE_BENEATH) && (how->resolve & RESOLVE_IN_ROOT))
+ 		return -EINVAL;
+ 
+ 	/* Deal with the mode. */
+ 	if (WILL_CREATE(flags)) {
+ 		if (how->mode & ~S_IALLUGO)
+ 			return -EINVAL;
+ 		op->mode = how->mode | S_IFREG;
+ 	} else {
+ 		if (how->mode != 0)
+ 			return -EINVAL;
++>>>>>>> 398840f8bb93 (openat2: reject RESOLVE_BENEATH|RESOLVE_IN_ROOT)
  		op->mode = 0;
 -	}
  
 -	/*
 -	 * In order to ensure programs get explicit errors when trying to use
 -	 * O_TMPFILE on old kernels, O_TMPFILE is implemented such that it
 -	 * looks like (O_DIRECTORY|O_RDWR & ~O_CREAT) to old kernels. But we
 -	 * have to require userspace to explicitly set it.
 -	 */
 -	if (flags & __O_TMPFILE) {
 -		if ((flags & O_TMPFILE_MASK) != O_TMPFILE)
 -			return -EINVAL;
 -		if (!(acc_mode & MAY_WRITE))
 -			return -EINVAL;
 -	}
 -	if (flags & O_PATH) {
 -		/* O_PATH only permits certain other flags to be set. */
 -		if (flags & ~O_PATH_FLAGS)
 -			return -EINVAL;
 -		acc_mode = 0;
 -	}
 +	/* Must never be set by userspace */
 +	flags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;
  
  	/*
  	 * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only
* Unmerged path fs/open.c
