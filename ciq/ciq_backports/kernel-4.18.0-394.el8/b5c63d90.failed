powerpc/vas: Return paste instruction failure if no active window

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Haren Myneni <haren@linux.ibm.com>
commit b5c63d90cc2de8ac6724fec84d1d72cfebcae41d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/b5c63d90.failed

The VAS window may not be active if the system looses credits and
the NX generates page fault when it receives request on unmap
paste address.

The kernel handles the fault by remap new paste address if the
window is active again, Otherwise return the paste instruction
failure if the executed instruction that caused the fault was
a paste.

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Haren Myneni <haren@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/492b9aefd593061d51dda67ee4d2fc449c000dce.camel@linux.ibm.com

(cherry picked from commit b5c63d90cc2de8ac6724fec84d1d72cfebcae41d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/ppc-opcode.h
diff --cc arch/powerpc/include/asm/ppc-opcode.h
index cc437f53bbc6,82f1f0041c6f..000000000000
--- a/arch/powerpc/include/asm/ppc-opcode.h
+++ b/arch/powerpc/include/asm/ppc-opcode.h
@@@ -284,26 -261,13 +284,31 @@@
  #define PPC_INST_MCRXR_MASK		0xfc0007fe
  #define PPC_INST_MFSPR_PVR		0x7c1f42a6
  #define PPC_INST_MFSPR_PVR_MASK		0xfc1ffffe
 +#define PPC_INST_MFTMR			0x7c0002dc
 +#define PPC_INST_MSGSND			0x7c00019c
 +#define PPC_INST_MSGCLR			0x7c0001dc
 +#define PPC_INST_MSGSYNC		0x7c0006ec
 +#define PPC_INST_MSGSNDP		0x7c00011c
 +#define PPC_INST_MSGCLRP		0x7c00015c
  #define PPC_INST_MTMSRD			0x7c000164
++<<<<<<< HEAD
 +#define PPC_INST_MTTMR			0x7c0003dc
 +#define PPC_INST_NOP			0x60000000
 +#define PPC_INST_PASTE			0x7c20070d
++=======
+ #define PPC_INST_PASTE			0x7c20070d
+ #define PPC_INST_PASTE_MASK		0xfc2007ff
++>>>>>>> b5c63d90cc2d (powerpc/vas: Return paste instruction failure if no active window)
  #define PPC_INST_POPCNTB		0x7c0000f4
  #define PPC_INST_POPCNTB_MASK		0xfc0007fe
 +#define PPC_INST_POPCNTD		0x7c0003f4
 +#define PPC_INST_POPCNTW		0x7c0002f4
  #define PPC_INST_RFEBB			0x4c000124
 +#define PPC_INST_RFCI			0x4c000066
 +#define PPC_INST_RFDI			0x4c00004e
  #define PPC_INST_RFID			0x4c000024
 +#define PPC_INST_RFMCI			0x4c00004c
 +#define PPC_INST_MFSPR			0x7c0002a6
  #define PPC_INST_MFSPR_DSCR		0x7c1102a6
  #define PPC_INST_MFSPR_DSCR_MASK	0xfc1ffffe
  #define PPC_INST_MTSPR_DSCR		0x7c1103a6
* Unmerged path arch/powerpc/include/asm/ppc-opcode.h
diff --git a/arch/powerpc/platforms/book3s/vas-api.c b/arch/powerpc/platforms/book3s/vas-api.c
index a202045d55cd..6d1a659be519 100644
--- a/arch/powerpc/platforms/book3s/vas-api.c
+++ b/arch/powerpc/platforms/book3s/vas-api.c
@@ -352,6 +352,41 @@ static int coproc_release(struct inode *inode, struct file *fp)
 	return 0;
 }
 
+/*
+ * If the executed instruction that caused the fault was a paste, then
+ * clear regs CR0[EQ], advance NIP, and return 0. Else return error code.
+ */
+static int do_fail_paste(void)
+{
+	struct pt_regs *regs = current->thread.regs;
+	u32 instword;
+
+	if (WARN_ON_ONCE(!regs))
+		return -EINVAL;
+
+	if (WARN_ON_ONCE(!user_mode(regs)))
+		return -EINVAL;
+
+	/*
+	 * If we couldn't translate the instruction, the driver should
+	 * return success without handling the fault, it will be retried
+	 * or the instruction fetch will fault.
+	 */
+	if (get_user(instword, (u32 __user *)(regs->nip)))
+		return -EAGAIN;
+
+	/*
+	 * Not a paste instruction, driver may fail the fault.
+	 */
+	if ((instword & PPC_INST_PASTE_MASK) != PPC_INST_PASTE)
+		return -ENOENT;
+
+	regs->ccr &= ~0xe0000000;	/* Clear CR0[0-2] to fail paste */
+	regs_add_return_ip(regs, 4);	/* Emulate the paste */
+
+	return 0;
+}
+
 /*
  * This fault handler is invoked when the core generates page fault on
  * the paste address. Happens if the kernel closes window in hypervisor
@@ -365,6 +400,7 @@ static vm_fault_t vas_mmap_fault(struct vm_fault *vmf)
 	struct vas_window *txwin;
 	vm_fault_t fault;
 	u64 paste_addr;
+	int ret;
 
 	/*
 	 * window is not opened. Shouldn't expect this error.
@@ -409,6 +445,24 @@ static vm_fault_t vas_mmap_fault(struct vm_fault *vmf)
 	}
 	mutex_unlock(&txwin->task_ref.mmap_mutex);
 
+	/*
+	 * Received this fault due to closing the actual window.
+	 * It can happen during migration or lost credits.
+	 * Since no mapping, return the paste instruction failure
+	 * to the user space.
+	 */
+	ret = do_fail_paste();
+	/*
+	 * The user space can retry several times until success (needed
+	 * for migration) or should fallback to SW compression or
+	 * manage with the existing open windows if available.
+	 * Looking at sysfs interface, it can determine whether these
+	 * failures are coming during migration or core removal:
+	 * nr_used_credits > nr_total_credits when lost credits
+	 */
+	if (!ret || (ret == -EAGAIN))
+		return VM_FAULT_NOPAGE;
+
 	return VM_FAULT_SIGBUS;
 }
 
