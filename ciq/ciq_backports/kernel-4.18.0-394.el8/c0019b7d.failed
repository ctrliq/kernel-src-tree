NFSD: Fix exposure in nfsd4_decode_bitmap()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit c0019b7db1d7ac62c711cda6b357a659d46428fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/c0019b7d.failed

rtm@csail.mit.edu reports:
> nfsd4_decode_bitmap4() will write beyond bmval[bmlen-1] if the RPC
> directs it to do so. This can cause nfsd4_decode_state_protect4_a()
> to write client-supplied data beyond the end of
> nfsd4_exchange_id.spo_must_allow[] when called by
> nfsd4_decode_exchange_id().

Rewrite the loops so nfsd4_decode_bitmap() cannot iterate beyond
@bmlen.

Reported by: rtm@csail.mit.edu
Fixes: d1c263a031e8 ("NFSD: Replace READ* macros in nfsd4_decode_fattr()")
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit c0019b7db1d7ac62c711cda6b357a659d46428fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7,5bdfaa43c99d..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -348,29 -246,143 +348,42 @@@ nfsd4_decode_nfstime4(struct nfsd4_comp
  }
  
  static __be32
 -nfsd4_decode_verifier4(struct nfsd4_compoundargs *argp, nfs4_verifier *verf)
 +nfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)
  {
 -	__be32 *p;
 +	u32 bmlen;
 +	DECODE_HEAD;
  
 -	p = xdr_inline_decode(argp->xdr, NFS4_VERIFIER_SIZE);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	memcpy(verf->data, p, sizeof(verf->data));
 -	return nfs_ok;
 -}
 +	bmval[0] = 0;
 +	bmval[1] = 0;
 +	bmval[2] = 0;
  
 -/**
 - * nfsd4_decode_bitmap4 - Decode an NFSv4 bitmap4
 - * @argp: NFSv4 compound argument structure
 - * @bmval: pointer to an array of u32's to decode into
 - * @bmlen: size of the @bmval array
 - *
 - * The server needs to return nfs_ok rather than nfserr_bad_xdr when
 - * encountering bitmaps containing bits it does not recognize. This
 - * includes bits in bitmap words past WORDn, where WORDn is the last
 - * bitmap WORD the implementation currently supports. Thus we are
 - * careful here to simply ignore bits in bitmap words that this
 - * implementation has yet to support explicitly.
 - *
 - * Return values:
 - *   %nfs_ok: @bmval populated successfully
 - *   %nfserr_bad_xdr: the encoded bitmap was invalid
 - */
 -static __be32
 -nfsd4_decode_bitmap4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen)
 -{
 -	u32 i, count;
 -	__be32 *p;
 +	READ_BUF(4);
 +	bmlen = be32_to_cpup(p++);
 +	if (bmlen > 1000)
 +		goto xdr_error;
  
++<<<<<<< HEAD
 +	READ_BUF(bmlen << 2);
 +	if (bmlen > 0)
 +		bmval[0] = be32_to_cpup(p++);
 +	if (bmlen > 1)
 +		bmval[1] = be32_to_cpup(p++);
 +	if (bmlen > 2)
 +		bmval[2] = be32_to_cpup(p++);
++=======
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 	/* request sanity */
+ 	if (count > 1000)
+ 		return nfserr_bad_xdr;
+ 	p = xdr_inline_decode(argp->xdr, count << 2);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	for (i = 0; i < bmlen; i++)
+ 		bmval[i] = (i < count) ? be32_to_cpup(p++) : 0;
++>>>>>>> c0019b7db1d7 (NFSD: Fix exposure in nfsd4_decode_bitmap())
  
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_nfsace4(struct nfsd4_compoundargs *argp, struct nfs4_ace *ace)
 -{
 -	__be32 *p, status;
 -	u32 length;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &ace->type) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &ace->flag) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &ace->access_mask) < 0)
 -		return nfserr_bad_xdr;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, length);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	ace->whotype = nfs4_acl_get_whotype((char *)p, length);
 -	if (ace->whotype != NFS4_ACL_WHO_NAMED)
 -		status = nfs_ok;
 -	else if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)
 -		status = nfsd_map_name_to_gid(argp->rqstp,
 -				(char *)p, length, &ace->who_gid);
 -	else
 -		status = nfsd_map_name_to_uid(argp->rqstp,
 -				(char *)p, length, &ace->who_uid);
 -
 -	return status;
 -}
 -
 -/* A counted array of nfsace4's */
 -static noinline __be32
 -nfsd4_decode_acl(struct nfsd4_compoundargs *argp, struct nfs4_acl **acl)
 -{
 -	struct nfs4_ace *ace;
 -	__be32 status;
 -	u32 count;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
 -		return nfserr_bad_xdr;
 -
 -	if (count > xdr_stream_remaining(argp->xdr) / 20)
 -		/*
 -		 * Even with 4-byte names there wouldn't be
 -		 * space for that many aces; something fishy is
 -		 * going on:
 -		 */
 -		return nfserr_fbig;
 -
 -	*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(count));
 -	if (*acl == NULL)
 -		return nfserr_jukebox;
 -
 -	(*acl)->naces = count;
 -	for (ace = (*acl)->aces; ace < (*acl)->aces + count; ace++) {
 -		status = nfsd4_decode_nfsace4(argp, ace);
 -		if (status)
 -			return status;
 -	}
 -
 -	return nfs_ok;
 -}
 -
 -static noinline __be32
 -nfsd4_decode_security_label(struct nfsd4_compoundargs *argp,
 -			    struct xdr_netobj *label)
 -{
 -	u32 lfs, pi, length;
 -	__be32 *p;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &lfs) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &pi) < 0)
 -		return nfserr_bad_xdr;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
 -		return nfserr_bad_xdr;
 -	if (length > NFS4_MAXLABELLEN)
 -		return nfserr_badlabel;
 -	p = xdr_inline_decode(argp->xdr, length);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	label->len = length;
 -	label->data = svcxdr_dupstr(argp, p, length);
 -	if (!label->data)
 -		return nfserr_jukebox;
 -
 -	return nfs_ok;
 +	DECODE_TAIL;
  }
  
  static __be32
* Unmerged path fs/nfsd/nfs4xdr.c
