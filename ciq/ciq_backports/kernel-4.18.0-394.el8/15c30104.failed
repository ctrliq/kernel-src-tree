blk-cgroup: fix missing put device in error path from blkg_conf_pref()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Yu Kuai <yukuai3@huawei.com>
commit 15c30104965101b8e76b24d27035569d6613a7d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/15c30104.failed

If blk_queue_enter() failed due to queue is dying, the
blkdev_put_no_open() is needed because blkcg_conf_open_bdev() succeeded.

Fixes: 0c9d338c8443 ("blk-cgroup: synchronize blkg creation against policy deactivation")
	Signed-off-by: Yu Kuai <yukuai3@huawei.com>
	Acked-by: Tejun Heo <tj@kernel.org>
Link: https://lore.kernel.org/r/20211102020705.2321858-1-yukuai3@huawei.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 15c30104965101b8e76b24d27035569d6613a7d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-cgroup.c
diff --cc block/blk-cgroup.c
index dce32aa3e90c,663aabfeba18..000000000000
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@@ -665,11 -628,19 +665,23 @@@ int blkg_conf_prep(struct blkcg *blkcg
  	struct blkcg_gq *blkg;
  	int ret;
  
 -	bdev = blkcg_conf_open_bdev(&input);
 -	if (IS_ERR(bdev))
 -		return PTR_ERR(bdev);
 +	disk = blkcg_conf_get_disk(&input);
 +	if (IS_ERR(disk))
 +		return PTR_ERR(disk);
  
++<<<<<<< HEAD
 +	q = disk->queue;
++=======
+ 	q = bdev_get_queue(bdev);
+ 
+ 	/*
+ 	 * blkcg_deactivate_policy() requires queue to be frozen, we can grab
+ 	 * q_usage_counter to prevent concurrent with blkcg_deactivate_policy().
+ 	 */
+ 	ret = blk_queue_enter(q, 0);
+ 	if (ret)
+ 		goto fail;
++>>>>>>> 15c301049651 (blk-cgroup: fix missing put device in error path from blkg_conf_pref())
  
  	rcu_read_lock();
  	spin_lock_irq(&q->queue_lock);
@@@ -750,8 -722,10 +762,14 @@@ fail_preloaded
  fail_unlock:
  	spin_unlock_irq(&q->queue_lock);
  	rcu_read_unlock();
+ fail_exit_queue:
+ 	blk_queue_exit(q);
  fail:
++<<<<<<< HEAD
 +	put_disk_and_module(disk);
++=======
+ 	blkdev_put_no_open(bdev);
++>>>>>>> 15c301049651 (blk-cgroup: fix missing put device in error path from blkg_conf_pref())
  	/*
  	 * If queue was bypassing, we should retry.  Do so after a
  	 * short msleep().  It isn't strictly necessary but queue
* Unmerged path block/blk-cgroup.c
