NFSD: Replace READ* macros in nfsd4_decode_compound()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit d9b74bdac6f24afc3101b6a5b6f59842610c9c94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/d9b74bda.failed

And clean-up: Now that we have removed the DECODE_TAIL macro from
nfsd4_decode_compound(), we observe that there's no benefit for
nfsd4_decode_compound() to return nfs_ok or nfserr_bad_xdr only to
have its sole caller convert those values to one or zero,
respectively. Have nfsd4_decode_compound() return 1/0 instead.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit d9b74bdac6f24afc3101b6a5b6f59842610c9c94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7,f8b5750aae4e..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -259,71 -186,80 +259,82 @@@ svcxdr_dupstr(struct nfsd4_compoundarg
  	return p;
  }
  
 -/*
 - * NFSv4 basic data type decoders
 - */
 -
 -/*
 - * This helper handles variable-length opaques which belong to protocol
 - * elements that this implementation does not support.
 - */
++<<<<<<< HEAD
  static __be32
 -nfsd4_decode_ignored_string(struct nfsd4_compoundargs *argp, u32 maxlen)
 +svcxdr_construct_vector(struct nfsd4_compoundargs *argp, struct kvec *head,
 +			struct page ***pagelist, u32 buflen)
  {
 -	u32 len;
 +	int avail;
 +	int len;
 +	int pages;
  
 -	if (xdr_stream_decode_u32(argp->xdr, &len) < 0)
 -		return nfserr_bad_xdr;
 -	if (maxlen && len > maxlen)
 -		return nfserr_bad_xdr;
 -	if (!xdr_inline_decode(argp->xdr, len))
 +	/* Sorry .. no magic macros for this.. *
 +	 * READ_BUF(write->wr_buflen);
 +	 * SAVEMEM(write->wr_buf, write->wr_buflen);
 +	 */
 +	avail = (char *)argp->end - (char *)argp->p;
 +	if (avail + argp->pagelen < buflen) {
 +		dprintk("NFSD: xdr error (%s:%d)\n",
 +			       __FILE__, __LINE__);
  		return nfserr_bad_xdr;
 +	}
 +	head->iov_base = argp->p;
 +	head->iov_len = avail;
 +	*pagelist = argp->pagelist;
  
 -	return nfs_ok;
 -}
 +	len = XDR_QUADLEN(buflen) << 2;
 +	if (len >= avail) {
 +		len -= avail;
  
 -static __be32
 -nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)
 -{
 -	__be32 *p;
 -	u32 len;
 +		pages = len >> PAGE_SHIFT;
 +		argp->pagelist += pages;
 +		argp->pagelen -= pages * PAGE_SIZE;
 +		len -= pages * PAGE_SIZE;
  
 -	if (xdr_stream_decode_u32(argp->xdr, &len) < 0)
 -		return nfserr_bad_xdr;
 -	if (len == 0 || len > NFS4_OPAQUE_LIMIT)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, len);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	o->data = svcxdr_tmpalloc(argp, len);
 -	if (!o->data)
 -		return nfserr_jukebox;
 -	o->len = len;
 -	memcpy(o->data, p, len);
 +		next_decode_page(argp);
 +	}
 +	argp->p += XDR_QUADLEN(len);
  
 -	return nfs_ok;
 +	return 0;
  }
  
 -static __be32
 -nfsd4_decode_component4(struct nfsd4_compoundargs *argp, char **namp, u32 *lenp)
 +/**
 + * savemem - duplicate a chunk of memory for later processing
 + * @argp: NFSv4 compound argument structure to be freed with
 + * @p: pointer to be duplicated
 + * @nbytes: length to be duplicated
 + *
 + * Returns a pointer to a copy of @nbytes bytes of memory at @p
 + * that are preserved until processing of the NFSv4 compound
 + * operation described by @argp finishes.
 + */
 +static char *savemem(struct nfsd4_compoundargs *argp, __be32 *p, int nbytes)
  {
 -	__be32 *p, status;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, lenp) < 0)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, *lenp);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	status = check_filename((char *)p, *lenp);
 -	if (status)
 -		return status;
 -	*namp = svcxdr_tmpalloc(argp, *lenp);
 -	if (!*namp)
 -		return nfserr_jukebox;
 -	memcpy(*namp, p, *lenp);
 +	void *ret;
  
 -	return nfs_ok;
 +	ret = svcxdr_tmpalloc(argp, nbytes);
 +	if (!ret)
 +		return NULL;
 +	memcpy(ret, p, nbytes);
 +	return ret;
  }
  
++=======
++/*
++ * NFSv4 basic data type decoders
++ */
++
++/*
++ * This helper handles variable-length opaques which belong to protocol
++ * elements that this implementation does not support.
++ */
++>>>>>>> d9b74bdac6f2 (NFSD: Replace READ* macros in nfsd4_decode_compound())
  static __be32
 -nfsd4_decode_nfstime4(struct nfsd4_compoundargs *argp, struct timespec64 *tv)
 +nfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec64 *tv)
  {
 -	__be32 *p;
 +	DECODE_HEAD;
  
 -	p = xdr_inline_decode(argp->xdr, XDR_UNIT * 3);
 -	if (!p)
 -		return nfserr_bad_xdr;
 +	READ_BUF(12);
  	p = xdr_decode_hyper(p, &tv->tv_sec);
  	tv->tv_nsec = be32_to_cpup(p++);
  	if (tv->tv_nsec >= (u32)1000000000)
* Unmerged path fs/nfsd/nfs4xdr.c
