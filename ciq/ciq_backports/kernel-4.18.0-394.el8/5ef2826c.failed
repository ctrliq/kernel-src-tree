NFSD: Update the NFSv3 COMMIT3res encoder to use struct xdr_stream

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 5ef2826c761079e27904c85034df34e601b82d94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/5ef2826c.failed

As an additional clean up, encode_wcc_data() is removed because it
is now no longer used.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 5ef2826c761079e27904c85034df34e601b82d94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3xdr.c
diff --cc fs/nfsd/nfs3xdr.c
index 3fa16aaa5ee2,eab14b52db20..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -546,28 -554,9 +538,34 @@@ neither
  	return true;
  }
  
++<<<<<<< HEAD
 +/*
 + * Enocde weak cache consistency data
 + */
 +static __be32 *
 +encode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 +{
 +	struct dentry	*dentry = fhp->fh_dentry;
 +
 +	if (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {
 +		if (fhp->fh_pre_saved) {
 +			*p++ = xdr_one;
 +			p = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);
 +			p = encode_time3(p, &fhp->fh_pre_mtime);
 +			p = encode_time3(p, &fhp->fh_pre_ctime);
 +		} else {
 +			*p++ = xdr_zero;
 +		}
 +		return encode_saved_post_attr(rqstp, p, fhp);
 +	}
 +	/* no pre- or post-attrs */
 +	*p++ = xdr_zero;
 +	return encode_post_op_attr(rqstp, p, fhp);
++=======
+ static bool fs_supports_change_attribute(struct super_block *sb)
+ {
+ 	return sb->s_flags & SB_I_VERSION || sb->s_export_op->fetch_iversion;
++>>>>>>> 5ef2826c7610 (NFSD: Update the NFSv3 COMMIT3res encoder to use struct xdr_stream)
  }
  
  /*
@@@ -1502,20 -1516,24 +1500,37 @@@ nfs3svc_encode_pathconfres(struct svc_r
  int
  nfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p)
  {
+ 	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_commitres *resp = rqstp->rq_resp;
 +	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
 +	__be32 verf[2];
  
++<<<<<<< HEAD
 +	*p++ = resp->status;
 +	p = encode_wcc_data(rqstp, p, &resp->fh);
 +	/* Write verifier */
 +	if (resp->status == 0) {
 +		/* unique identifier, y2038 overflow can be ignored */
 +		nfsd_copy_boot_verifier(verf, nn);
 +		*p++ = verf[0];
 +		*p++ = verf[1];
++=======
+ 	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
+ 		return 0;
+ 	switch (resp->status) {
+ 	case nfs_ok:
+ 		if (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))
+ 			return 0;
+ 		if (!svcxdr_encode_writeverf3(xdr, resp->verf))
+ 			return 0;
+ 		break;
+ 	default:
+ 		if (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))
+ 			return 0;
++>>>>>>> 5ef2826c7610 (NFSD: Update the NFSv3 COMMIT3res encoder to use struct xdr_stream)
  	}
- 	return xdr_ressize_check(rqstp, p);
+ 
+ 	return 1;
  }
  
  /*
* Unmerged path fs/nfsd/nfs3xdr.c
