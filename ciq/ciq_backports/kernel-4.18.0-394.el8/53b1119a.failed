NFSD: Fix READDIR buffer overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 53b1119a6e5028b125f431a0116ba73510d82a72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/53b1119a.failed

If a client sends a READDIR count argument that is too small (say,
zero), then the buffer size calculation in the new init_dirlist
helper functions results in an underflow, allowing the XDR stream
functions to write beyond the actual buffer.

This calculation has always been suspect. NFSD has never sanity-
checked the READDIR count argument, but the old entry encoders
managed the problem correctly.

With the commits below, entry encoding changed, exposing the
underflow to the pointer arithmetic in xdr_reserve_space().

Modern NFS clients attempt to retrieve as much data as possible
for each READDIR request. Also, we have no unit tests that
exercise the behavior of READDIR at the lower bound of @count
values. Thus this case was missed during testing.

	Reported-by: Anatoly Trosinenko <anatoly.trosinenko@gmail.com>
Fixes: f5dcccd647da ("NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream")
Fixes: 7f87fc2d34d4 ("NFSD: Update NFSv3 READDIR entry encoders to use struct xdr_stream")
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 53b1119a6e5028b125f431a0116ba73510d82a72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3proc.c
#	fs/nfsd/nfsproc.c
diff --cc fs/nfsd/nfs3proc.c
index 24c93358935f,15dac36ca852..000000000000
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@@ -439,19 -438,29 +439,43 @@@ nfsd3_proc_link(struct svc_rqst *rqstp
  
  static void nfsd3_init_dirlist_pages(struct svc_rqst *rqstp,
  				     struct nfsd3_readdirres *resp,
- 				     int count)
+ 				     u32 count)
  {
++<<<<<<< HEAD
 +	count = min_t(u32, count, svc_max_payload(rqstp));
++=======
+ 	struct xdr_buf *buf = &resp->dirlist;
+ 	struct xdr_stream *xdr = &resp->xdr;
+ 
+ 	count = clamp(count, (u32)(XDR_UNIT * 2), svc_max_payload(rqstp));
++>>>>>>> 53b1119a6e50 (NFSD: Fix READDIR buffer overflow)
  
 -	memset(buf, 0, sizeof(*buf));
 +	/* Convert byte count to number of words (i.e. >> 2),
 +	 * and reserve room for the NULL ptr & eof flag (-2 words) */
 +	resp->buflen = (count >> 2) - 2;
  
++<<<<<<< HEAD
 +	resp->buffer = page_address(*rqstp->rq_next_page);
 +	while (count > 0) {
 +		rqstp->rq_next_page++;
 +		count -= PAGE_SIZE;
 +	}
++=======
+ 	/* Reserve room for the NULL ptr & eof flag (-2 words) */
+ 	buf->buflen = count - XDR_UNIT * 2;
+ 	buf->pages = rqstp->rq_next_page;
+ 	rqstp->rq_next_page += (buf->buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;
+ 
+ 	/* This is xdr_init_encode(), but it assumes that
+ 	 * the head kvec has already been consumed. */
+ 	xdr_set_scratch_buffer(xdr, NULL, 0);
+ 	xdr->buf = buf;
+ 	xdr->page_ptr = buf->pages;
+ 	xdr->iov = NULL;
+ 	xdr->p = page_address(*buf->pages);
+ 	xdr->end = (void *)xdr->p + min_t(u32, buf->buflen, PAGE_SIZE);
+ 	xdr->rqst = NULL;
++>>>>>>> 53b1119a6e50 (NFSD: Fix READDIR buffer overflow)
  }
  
  /*
diff --cc fs/nfsd/nfsproc.c
index ac1e929b2596,de282f3273c5..000000000000
--- a/fs/nfsd/nfsproc.c
+++ b/fs/nfsd/nfsproc.c
@@@ -555,6 -554,33 +555,36 @@@ nfsd_proc_rmdir(struct svc_rqst *rqstp
  	return rpc_success;
  }
  
++<<<<<<< HEAD
++=======
+ static void nfsd_init_dirlist_pages(struct svc_rqst *rqstp,
+ 				    struct nfsd_readdirres *resp,
+ 				    u32 count)
+ {
+ 	struct xdr_buf *buf = &resp->dirlist;
+ 	struct xdr_stream *xdr = &resp->xdr;
+ 
+ 	count = clamp(count, (u32)(XDR_UNIT * 2), svc_max_payload(rqstp));
+ 
+ 	memset(buf, 0, sizeof(*buf));
+ 
+ 	/* Reserve room for the NULL ptr & eof flag (-2 words) */
+ 	buf->buflen = count - XDR_UNIT * 2;
+ 	buf->pages = rqstp->rq_next_page;
+ 	rqstp->rq_next_page++;
+ 
+ 	/* This is xdr_init_encode(), but it assumes that
+ 	 * the head kvec has already been consumed. */
+ 	xdr_set_scratch_buffer(xdr, NULL, 0);
+ 	xdr->buf = buf;
+ 	xdr->page_ptr = buf->pages;
+ 	xdr->iov = NULL;
+ 	xdr->p = page_address(*buf->pages);
+ 	xdr->end = (void *)xdr->p + min_t(u32, buf->buflen, PAGE_SIZE);
+ 	xdr->rqst = NULL;
+ }
+ 
++>>>>>>> 53b1119a6e50 (NFSD: Fix READDIR buffer overflow)
  /*
   * Read a portion of a directory.
   */
* Unmerged path fs/nfsd/nfs3proc.c
* Unmerged path fs/nfsd/nfsproc.c
