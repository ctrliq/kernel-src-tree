NFSD: Replace READ* macros in nfsd4_decode_layoutcommit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 5185980d8a23001c2317c290129ab7ab20067e20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/5185980d.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 5185980d8a23001c2317c290129ab7ab20067e20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 548b4663be81,0b8f7dedfdfb..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -318,20 -207,73 +318,6 @@@ static char *savemem(struct nfsd4_compo
  	return ret;
  }
  
 -
 -/*
 - * NFSv4 basic data type decoders
 - */
 -
 -/*
 - * This helper handles variable-length opaques which belong to protocol
 - * elements that this implementation does not support.
 - */
--static __be32
- nfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec64 *tv)
 -nfsd4_decode_ignored_string(struct nfsd4_compoundargs *argp, u32 maxlen)
--{
- 	DECODE_HEAD;
 -	u32 len;
--
- 	READ_BUF(12);
- 	p = xdr_decode_hyper(p, &tv->tv_sec);
- 	tv->tv_nsec = be32_to_cpup(p++);
- 	if (tv->tv_nsec >= (u32)1000000000)
- 		return nfserr_inval;
 -	if (xdr_stream_decode_u32(argp->xdr, &len) < 0)
 -		return nfserr_bad_xdr;
 -	if (maxlen && len > maxlen)
 -		return nfserr_bad_xdr;
 -	if (!xdr_inline_decode(argp->xdr, len))
 -		return nfserr_bad_xdr;
--
- 	DECODE_TAIL;
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)
 -{
 -	__be32 *p;
 -	u32 len;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &len) < 0)
 -		return nfserr_bad_xdr;
 -	if (len == 0 || len > NFS4_OPAQUE_LIMIT)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, len);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	o->data = svcxdr_tmpalloc(argp, len);
 -	if (!o->data)
 -		return nfserr_jukebox;
 -	o->len = len;
 -	memcpy(o->data, p, len);
 -
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_component4(struct nfsd4_compoundargs *argp, char **namp, u32 *lenp)
 -{
 -	__be32 *p, status;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, lenp) < 0)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, *lenp);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	status = check_filename((char *)p, *lenp);
 -	if (status)
 -		return status;
 -	*namp = svcxdr_tmpalloc(argp, *lenp);
 -	if (!*namp)
 -		return nfserr_jukebox;
 -	memcpy(*namp, p, *lenp);
 -
 -	return nfs_ok;
--}
--
  static __be32
  nfsd4_decode_nfstime4(struct nfsd4_compoundargs *argp, struct timespec64 *tv)
  {
@@@ -612,18 -624,134 +598,140 @@@ nfsd4_decode_state_owner4(struct nfsd4_
  	return nfsd4_decode_opaque(argp, owner);
  }
  
 -#ifdef CONFIG_NFSD_PNFS
 -static __be32
 -nfsd4_decode_deviceid4(struct nfsd4_compoundargs *argp,
 -		       struct nfsd4_deviceid *devid)
 +static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
  {
++<<<<<<< HEAD
 +	DECODE_HEAD;
 +	struct user_namespace *userns = nfsd_user_namespace(argp->rqstp);
 +	u32 dummy, uid, gid;
 +	char *machine_name;
 +	int i;
 +	int nr_secflavs;
++=======
+ 	__be32 *p;
+ 
+ 	p = xdr_inline_decode(argp->xdr, NFS4_DEVICEID4_SIZE);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	memcpy(devid, p, sizeof(*devid));
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_layoutupdate4(struct nfsd4_compoundargs *argp,
+ 			   struct nfsd4_layoutcommit *lcp)
+ {
+ 	if (xdr_stream_decode_u32(argp->xdr, &lcp->lc_layout_type) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_layout_type < LAYOUT_NFSV4_1_FILES)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_layout_type >= LAYOUT_TYPE_MAX)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &lcp->lc_up_len) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_up_len > 0) {
+ 		lcp->lc_up_layout = xdr_inline_decode(argp->xdr, lcp->lc_up_len);
+ 		if (!lcp->lc_up_layout)
+ 			return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ #endif /* CONFIG_NFSD_PNFS */
+ 
+ static __be32
+ nfsd4_decode_sessionid4(struct nfsd4_compoundargs *argp,
+ 			struct nfs4_sessionid *sessionid)
+ {
+ 	__be32 *p;
+ 
+ 	p = xdr_inline_decode(argp->xdr, NFS4_MAX_SESSIONID_LEN);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	memcpy(sessionid->data, p, sizeof(sessionid->data));
+ 	return nfs_ok;
+ }
+ 
+ /* Defined in Appendix A of RFC 5531 */
+ static __be32
+ nfsd4_decode_authsys_parms(struct nfsd4_compoundargs *argp,
+ 			   struct nfsd4_cb_sec *cbs)
+ {
+ 	u32 stamp, gidcount, uid, gid;
+ 	__be32 *p, status;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &stamp) < 0)
+ 		return nfserr_bad_xdr;
+ 	/* machine name */
+ 	status = nfsd4_decode_ignored_string(argp, 255);
+ 	if (status)
+ 		return status;
+ 	if (xdr_stream_decode_u32(argp->xdr, &uid) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &gid) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &gidcount) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (gidcount > 16)
+ 		return nfserr_bad_xdr;
+ 	p = xdr_inline_decode(argp->xdr, gidcount << 2);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	if (cbs->flavor == (u32)(-1)) {
+ 		struct user_namespace *userns = nfsd_user_namespace(argp->rqstp);
+ 
+ 		kuid_t kuid = make_kuid(userns, uid);
+ 		kgid_t kgid = make_kgid(userns, gid);
+ 		if (uid_valid(kuid) && gid_valid(kgid)) {
+ 			cbs->uid = kuid;
+ 			cbs->gid = kgid;
+ 			cbs->flavor = RPC_AUTH_UNIX;
+ 		} else {
+ 			dprintk("RPC_AUTH_UNIX with invalid uid or gid, ignoring!\n");
+ 		}
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_gss_cb_handles4(struct nfsd4_compoundargs *argp,
+ 			     struct nfsd4_cb_sec *cbs)
+ {
+ 	__be32 status;
+ 	u32 service;
+ 
+ 	dprintk("RPC_AUTH_GSS callback secflavor not supported!\n");
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &service) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (service < RPC_GSS_SVC_NONE || service > RPC_GSS_SVC_PRIVACY)
+ 		return nfserr_bad_xdr;
+ 	/* gcbp_handle_from_server */
+ 	status = nfsd4_decode_ignored_string(argp, 0);
+ 	if (status)
+ 		return status;
+ 	/* gcbp_handle_from_client */
+ 	status = nfsd4_decode_ignored_string(argp, 0);
+ 	if (status)
+ 		return status;
+ 
+ 	return nfs_ok;
+ }
+ 
+ /* a counted array of callback_sec_parms4 items */
+ static __be32
+ nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
+ {
+ 	u32 i, secflavor, nr_secflavs;
+ 	__be32 status;
++>>>>>>> 5185980d8a23 (NFSD: Replace READ* macros in nfsd4_decode_layoutcommit())
  
  	/* callback_sec_params4 */
 -	if (xdr_stream_decode_u32(argp->xdr, &nr_secflavs) < 0)
 -		return nfserr_bad_xdr;
 +	READ_BUF(4);
 +	nr_secflavs = be32_to_cpup(p++);
  	if (nr_secflavs)
  		cbs->flavor = (u32)(-1);
  	else
@@@ -1632,29 -1789,57 +1740,64 @@@ static __be3
  nfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,
  		struct nfsd4_getdeviceinfo *gdev)
  {
 -	__be32 status;
 -
 -	status = nfsd4_decode_deviceid4(argp, &gdev->gd_devid);
 -	if (status)
 -		return status;
 -	if (xdr_stream_decode_u32(argp->xdr, &gdev->gd_layout_type) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &gdev->gd_maxcount) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_uint32_array(argp->xdr,
 -					   &gdev->gd_notify_types, 1) < 0)
 -		return nfserr_bad_xdr;
 -
 -	return nfs_ok;
 +	DECODE_HEAD;
 +	u32 num, i;
 +
 +	READ_BUF(sizeof(struct nfsd4_deviceid) + 3 * 4);
 +	COPYMEM(&gdev->gd_devid, sizeof(struct nfsd4_deviceid));
 +	gdev->gd_layout_type = be32_to_cpup(p++);
 +	gdev->gd_maxcount = be32_to_cpup(p++);
 +	num = be32_to_cpup(p++);
 +	if (num) {
 +		if (num > 1000)
 +			goto xdr_error;
 +		READ_BUF(4 * num);
 +		gdev->gd_notify_types = be32_to_cpup(p++);
 +		for (i = 1; i < num; i++) {
 +			if (be32_to_cpup(p++)) {
 +				status = nfserr_inval;
 +				goto out;
 +			}
 +		}
 +	}
 +	DECODE_TAIL;
  }
  
+ static __be32
+ nfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,
+ 			  struct nfsd4_layoutcommit *lcp)
+ {
+ 	__be32 *p, status;
+ 
+ 	if (xdr_stream_decode_u64(argp->xdr, &lcp->lc_seg.offset) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u64(argp->xdr, &lcp->lc_seg.length) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_bool(argp->xdr, &lcp->lc_reclaim) < 0)
+ 		return nfserr_bad_xdr;
+ 	status = nfsd4_decode_stateid4(argp, &lcp->lc_sid);
+ 	if (status)
+ 		return status;
+ 	if (xdr_stream_decode_u32(argp->xdr, &lcp->lc_newoffset) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (lcp->lc_newoffset) {
+ 		if (xdr_stream_decode_u64(argp->xdr, &lcp->lc_last_wr) < 0)
+ 			return nfserr_bad_xdr;
+ 	} else
+ 		lcp->lc_last_wr = 0;
+ 	p = xdr_inline_decode(argp->xdr, XDR_UNIT);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_item_is_present(p)) {
+ 		status = nfsd4_decode_nfstime4(argp, &lcp->lc_mtime);
+ 		if (status)
+ 			return status;
+ 	} else {
+ 		lcp->lc_mtime.tv_nsec = UTIME_NOW;
+ 	}
+ 	return nfsd4_decode_layoutupdate4(argp, lcp);
+ }
+ 
  static __be32
  nfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,
  		struct nfsd4_layoutget *lgp)
* Unmerged path fs/nfsd/nfs4xdr.c
