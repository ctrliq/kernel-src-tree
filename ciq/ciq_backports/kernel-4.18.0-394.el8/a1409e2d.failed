NFSD: Count bytes instead of pages in the NFSv3 READDIR encoder

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit a1409e2de4f11034c8eb30775cc3e37039a4ef13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/a1409e2d.failed

Clean up: Counting the bytes used by each returned directory entry
seems less brittle to me than trying to measure consumed pages after
the fact.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit a1409e2de4f11034c8eb30775cc3e37039a4ef13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3proc.c
diff --cc fs/nfsd/nfs3proc.c
index 5d8b39219ffb,791d77363acd..000000000000
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@@ -483,29 -481,7 +481,33 @@@ nfsd3_proc_readdir(struct svc_rqst *rqs
  	resp->status = nfsd_readdir(rqstp, &resp->fh, &offset,
  				    &resp->common, nfs3svc_encode_entry);
  	memcpy(resp->verf, argp->verf, 8);
++<<<<<<< HEAD
 +	count = 0;
 +	for (p = rqstp->rq_respages + 1; p < rqstp->rq_next_page; p++) {
 +		page_addr = page_address(*p);
 +
 +		if (((caddr_t)resp->buffer >= page_addr) &&
 +		    ((caddr_t)resp->buffer < page_addr + PAGE_SIZE)) {
 +			count += (caddr_t)resp->buffer - page_addr;
 +			break;
 +		}
 +		count += PAGE_SIZE;
 +	}
 +	resp->count = count >> 2;
 +	if (resp->offset) {
 +		if (unlikely(resp->offset1)) {
 +			/* we ended up with offset on a page boundary */
 +			*resp->offset = htonl(offset >> 32);
 +			*resp->offset1 = htonl(offset & 0xffffffff);
 +			resp->offset1 = NULL;
 +		} else {
 +			xdr_encode_hyper(resp->offset, offset);
 +		}
 +		resp->offset = NULL;
 +	}
++=======
+ 	nfs3svc_encode_cookie3(resp, offset);
++>>>>>>> a1409e2de4f1 (NFSD: Count bytes instead of pages in the NFSv3 READDIR encoder)
  
  	return rpc_success;
  }
@@@ -549,28 -523,7 +549,32 @@@ nfsd3_proc_readdirplus(struct svc_rqst 
  	resp->status = nfsd_readdir(rqstp, &resp->fh, &offset,
  				    &resp->common, nfs3svc_encode_entry_plus);
  	memcpy(resp->verf, argp->verf, 8);
++<<<<<<< HEAD
 +	for (p = rqstp->rq_respages + 1; p < rqstp->rq_next_page; p++) {
 +		page_addr = page_address(*p);
 +
 +		if (((caddr_t)resp->buffer >= page_addr) &&
 +		    ((caddr_t)resp->buffer < page_addr + PAGE_SIZE)) {
 +			count += (caddr_t)resp->buffer - page_addr;
 +			break;
 +		}
 +		count += PAGE_SIZE;
 +	}
 +	resp->count = count >> 2;
 +	if (resp->offset) {
 +		if (unlikely(resp->offset1)) {
 +			/* we ended up with offset on a page boundary */
 +			*resp->offset = htonl(offset >> 32);
 +			*resp->offset1 = htonl(offset & 0xffffffff);
 +			resp->offset1 = NULL;
 +		} else {
 +			xdr_encode_hyper(resp->offset, offset);
 +		}
 +		resp->offset = NULL;
 +	}
++=======
+ 	nfs3svc_encode_cookie3(resp, offset);
++>>>>>>> a1409e2de4f1 (NFSD: Count bytes instead of pages in the NFSv3 READDIR encoder)
  
  out:
  	return rpc_success;
* Unmerged path fs/nfsd/nfs3proc.c
diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.c
index 3fa16aaa5ee2..8bc34f67d3c1 100644
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -1340,6 +1340,7 @@ encode_entry(struct readdir_cd *ccd, const char *name, int namlen,
 		return -EINVAL;
 	}
 
+	cd->count += num_entry_words;
 	cd->buflen -= num_entry_words;
 	cd->buffer = p;
 	cd->common.err = nfs_ok;
