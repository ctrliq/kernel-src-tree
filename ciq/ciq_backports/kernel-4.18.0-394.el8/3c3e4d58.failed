RDMA/rxe: Delete _locked() APIs for pool objects

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit 3c3e4d582bdc461081abea9de54eb4112a9a6283
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/3c3e4d58.failed

Since caller managed locks for indexed objects are no longer used these
APIs are deleted.

Link: https://lore.kernel.org/r/20220304000808.225811-5-rpearsonhpe@gmail.com
	Signed-off-by: Bob Pearson <rpearsonhpe@gmail.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 3c3e4d582bdc461081abea9de54eb4112a9a6283)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_pool.c
#	drivers/infiniband/sw/rxe/rxe_pool.h
diff --cc drivers/infiniband/sw/rxe/rxe_pool.c
index e7b233608b61,2e3543dde000..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.c
+++ b/drivers/infiniband/sw/rxe/rxe_pool.c
@@@ -217,90 -189,7 +217,94 @@@ static int rxe_insert_index(struct rxe_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int rxe_insert_key(struct rxe_pool *pool, struct rxe_pool_entry *new)
 +{
 +	struct rb_node **link = &pool->key.tree.rb_node;
 +	struct rb_node *parent = NULL;
 +	struct rxe_pool_entry *elem;
 +	int cmp;
 +
 +	while (*link) {
 +		parent = *link;
 +		elem = rb_entry(parent, struct rxe_pool_entry, key_node);
 +
 +		cmp = memcmp((u8 *)elem + pool->key.key_offset,
 +			     (u8 *)new + pool->key.key_offset, pool->key.key_size);
 +
 +		if (cmp == 0) {
 +			pr_warn("key already exists!\n");
 +			return -EINVAL;
 +		}
 +
 +		if (cmp > 0)
 +			link = &(*link)->rb_left;
 +		else
 +			link = &(*link)->rb_right;
 +	}
 +
 +	rb_link_node(&new->key_node, parent, link);
 +	rb_insert_color(&new->key_node, &pool->key.tree);
 +
 +	return 0;
 +}
 +
 +int __rxe_add_key_locked(struct rxe_pool_entry *elem, void *key)
 +{
 +	struct rxe_pool *pool = elem->pool;
 +	int err;
 +
 +	memcpy((u8 *)elem + pool->key.key_offset, key, pool->key.key_size);
 +	err = rxe_insert_key(pool, elem);
 +
 +	return err;
 +}
 +
 +int __rxe_add_key(struct rxe_pool_entry *elem, void *key)
 +{
 +	struct rxe_pool *pool = elem->pool;
 +	unsigned long flags;
 +	int err;
 +
 +	write_lock_irqsave(&pool->pool_lock, flags);
 +	err = __rxe_add_key_locked(elem, key);
 +	write_unlock_irqrestore(&pool->pool_lock, flags);
 +
 +	return err;
 +}
 +
 +void __rxe_drop_key_locked(struct rxe_pool_entry *elem)
 +{
 +	struct rxe_pool *pool = elem->pool;
 +
 +	rb_erase(&elem->key_node, &pool->key.tree);
 +}
 +
 +void __rxe_drop_key(struct rxe_pool_entry *elem)
 +{
 +	struct rxe_pool *pool = elem->pool;
 +	unsigned long flags;
 +
 +	write_lock_irqsave(&pool->pool_lock, flags);
 +	__rxe_drop_key_locked(elem);
 +	write_unlock_irqrestore(&pool->pool_lock, flags);
 +}
 +
 +int __rxe_add_index_locked(struct rxe_pool_entry *elem)
 +{
 +	struct rxe_pool *pool = elem->pool;
 +	int err;
 +
 +	elem->index = alloc_index(pool);
 +	err = rxe_insert_index(pool, elem);
 +
 +	return err;
 +}
 +
 +int __rxe_add_index(struct rxe_pool_entry *elem)
++=======
+ int __rxe_add_index(struct rxe_pool_elem *elem)
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
  {
  	struct rxe_pool *pool = elem->pool;
  	unsigned long flags;
@@@ -313,15 -203,7 +318,19 @@@
  	return err;
  }
  
++<<<<<<< HEAD
 +void __rxe_drop_index_locked(struct rxe_pool_entry *elem)
 +{
 +	struct rxe_pool *pool = elem->pool;
 +
 +	clear_bit(elem->index - pool->index.min_index, pool->index.table);
 +	rb_erase(&elem->index_node, &pool->index.tree);
 +}
 +
 +void __rxe_drop_index(struct rxe_pool_entry *elem)
++=======
+ void __rxe_drop_index(struct rxe_pool_elem *elem)
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
  {
  	struct rxe_pool *pool = elem->pool;
  	unsigned long flags;
@@@ -331,11 -214,13 +341,12 @@@
  	write_unlock_irqrestore(&pool->pool_lock, flags);
  }
  
 -void *rxe_alloc(struct rxe_pool *pool)
++<<<<<<< HEAD
 +void *rxe_alloc_locked(struct rxe_pool *pool)
  {
 -	struct rxe_pool_elem *elem;
 -	void *obj;
 -
 -	if (WARN_ON(!(pool->flags & RXE_POOL_ALLOC)))
 -		return NULL;
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
  
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
@@@ -356,33 -242,11 +367,35 @@@ out_cnt
  	return NULL;
  }
  
 -int __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_elem *elem)
++=======
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
 +void *rxe_alloc(struct rxe_pool *pool)
  {
 -	if (WARN_ON(pool->flags & RXE_POOL_ALLOC))
 -		return -EINVAL;
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
 +
 +	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
 +		goto out_cnt;
 +
 +	obj = kzalloc(info->size, GFP_KERNEL);
 +	if (!obj)
 +		goto out_cnt;
  
 +	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
 +
 +	elem->pool = pool;
 +	kref_init(&elem->ref_cnt);
 +
 +	return obj;
 +
 +out_cnt:
 +	atomic_dec(&pool->num_elem);
 +	return NULL;
 +}
 +
 +int __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_entry *elem)
 +{
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
  
@@@ -415,13 -279,14 +428,21 @@@ void rxe_elem_release(struct kref *kref
  	atomic_dec(&pool->num_elem);
  }
  
- void *rxe_pool_get_index_locked(struct rxe_pool *pool, u32 index)
+ void *rxe_pool_get_index(struct rxe_pool *pool, u32 index)
  {
++<<<<<<< HEAD
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	struct rb_node *node;
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
++=======
+ 	struct rxe_pool_elem *elem;
+ 	struct rb_node *node;
+ 	unsigned long flags;
+ 	void *obj;
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
  
+ 	read_lock_irqsave(&pool->pool_lock, flags);
  	node = pool->index.tree.rb_node;
  
  	while (node) {
@@@ -437,53 -302,7 +458,56 @@@
  
  	if (node) {
  		kref_get(&elem->ref_cnt);
 -		obj = elem->obj;
 +		obj = (u8 *)elem - info->elem_offset;
 +	} else {
 +		obj = NULL;
 +	}
++<<<<<<< HEAD
 +
 +	return obj;
 +}
 +
 +void *rxe_pool_get_index(struct rxe_pool *pool, u32 index)
 +{
 +	u8 *obj;
 +	unsigned long flags;
 +
 +	read_lock_irqsave(&pool->pool_lock, flags);
 +	obj = rxe_pool_get_index_locked(pool, index);
++=======
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
 +	read_unlock_irqrestore(&pool->pool_lock, flags);
 +
 +	return obj;
 +}
 +
 +void *rxe_pool_get_key_locked(struct rxe_pool *pool, void *key)
 +{
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	struct rb_node *node;
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
 +	int cmp;
 +
 +	node = pool->key.tree.rb_node;
 +
 +	while (node) {
 +		elem = rb_entry(node, struct rxe_pool_entry, key_node);
 +
 +		cmp = memcmp((u8 *)elem + pool->key.key_offset,
 +			     key, pool->key.key_size);
 +
 +		if (cmp > 0)
 +			node = node->rb_left;
 +		else if (cmp < 0)
 +			node = node->rb_right;
 +		else
 +			break;
 +	}
 +
 +	if (node) {
 +		kref_get(&elem->ref_cnt);
 +		obj = (u8 *)elem - info->elem_offset;
  	} else {
  		obj = NULL;
  	}
diff --cc drivers/infiniband/sw/rxe/rxe_pool.h
index 837585fdbc34,7fec5d96d695..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.h
+++ b/drivers/infiniband/sw/rxe/rxe_pool.h
@@@ -86,66 -72,25 +84,71 @@@ void rxe_pool_cleanup(struct rxe_pool *
  void *rxe_alloc(struct rxe_pool *pool);
  
  /* connect already allocated object to pool */
 -int __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_elem *elem);
 +int __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_entry *elem);
  
 -#define rxe_add_to_pool(pool, obj) __rxe_add_to_pool(pool, &(obj)->elem)
 +#define rxe_add_to_pool(pool, obj) __rxe_add_to_pool(pool, &(obj)->pelem)
  
  /* assign an index to an indexed object and insert object into
-  *  pool's rb tree holding and not holding the pool_lock
+  * pool's rb tree
   */
++<<<<<<< HEAD
 +int __rxe_add_index_locked(struct rxe_pool_entry *elem);
 +
 +#define rxe_add_index_locked(obj) __rxe_add_index_locked(&(obj)->pelem)
 +
 +int __rxe_add_index(struct rxe_pool_entry *elem);
++=======
+ int __rxe_add_index(struct rxe_pool_elem *elem);
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
 +
 +#define rxe_add_index(obj) __rxe_add_index(&(obj)->pelem)
  
 -#define rxe_add_index(obj) __rxe_add_index(&(obj)->elem)
++<<<<<<< HEAD
 +/* drop an index and remove object from rb tree
 + * holding and not holding the pool_lock
 + */
 +void __rxe_drop_index_locked(struct rxe_pool_entry *elem);
 +
 +#define rxe_drop_index_locked(obj) __rxe_drop_index_locked(&(obj)->pelem)
  
 +void __rxe_drop_index(struct rxe_pool_entry *elem);
++=======
+ /* drop an index and remove object from rb tree */
+ void __rxe_drop_index(struct rxe_pool_elem *elem);
++>>>>>>> 3c3e4d582bdc (RDMA/rxe: Delete _locked() APIs for pool objects)
  
 -#define rxe_drop_index(obj) __rxe_drop_index(&(obj)->elem)
 +#define rxe_drop_index(obj) __rxe_drop_index(&(obj)->pelem)
 +
 +/* assign a key to a keyed object and insert object into
 + * pool's rb tree holding and not holding pool_lock
 + */
 +int __rxe_add_key_locked(struct rxe_pool_entry *elem, void *key);
 +
 +#define rxe_add_key_locked(obj, key) __rxe_add_key_locked(&(obj)->pelem, key)
 +
 +int __rxe_add_key(struct rxe_pool_entry *elem, void *key);
 +
 +#define rxe_add_key(obj, key) __rxe_add_key(&(obj)->pelem, key)
 +
 +/* remove elem from rb tree holding and not holding the pool_lock */
 +void __rxe_drop_key_locked(struct rxe_pool_entry *elem);
 +
 +#define rxe_drop_key_locked(obj) __rxe_drop_key_locked(&(obj)->pelem)
 +
 +void __rxe_drop_key(struct rxe_pool_entry *elem);
 +
 +#define rxe_drop_key(obj) __rxe_drop_key(&(obj)->pelem)
  
- /* lookup an indexed object from index holding and not holding the pool_lock.
-  * takes a reference on object
-  */
- void *rxe_pool_get_index_locked(struct rxe_pool *pool, u32 index);
- 
+ /* lookup an indexed object from index. takes a reference on object */
  void *rxe_pool_get_index(struct rxe_pool *pool, u32 index);
  
 +/* lookup keyed object from key holding and not holding the pool_lock.
 + * takes a reference on the objecti
 + */
 +void *rxe_pool_get_key_locked(struct rxe_pool *pool, void *key);
 +
 +void *rxe_pool_get_key(struct rxe_pool *pool, void *key);
 +
  /* cleanup an object when all references are dropped */
  void rxe_elem_release(struct kref *kref);
  
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.c
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.h
