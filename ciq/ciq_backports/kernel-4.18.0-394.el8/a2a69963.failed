arm64: cpufeature: Add an overview comment for the cpufeature framework

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Will Deacon <will@kernel.org>
commit a2a69963524dc4aebba047732dce5d256a70bb3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/a2a69963.failed

Now that Suzuki isn't within throwing distance, I thought I'd better add
a rough overview comment to cpufeature.c so that it doesn't take me days
to remember how it works next time.

	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
Link: https://lore.kernel.org/r/20200421142922.18950-9-will@kernel.org
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit a2a69963524dc4aebba047732dce5d256a70bb3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpufeature.c
diff --cc arch/arm64/kernel/cpufeature.c
index 6cafbb498e71,c1d44d127baa..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -3,17 -4,55 +3,69 @@@
   *
   * Copyright (C) 2015 ARM Ltd.
   *
++<<<<<<< HEAD
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
 + * published by the Free Software Foundation.
 + *
 + * This program is distributed in the hope that it will be useful,
 + * but WITHOUT ANY WARRANTY; without even the implied warranty of
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 + * GNU General Public License for more details.
 + *
 + * You should have received a copy of the GNU General Public License
 + * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++=======
+  * A note for the weary kernel hacker: the code here is confusing and hard to
+  * follow! That's partly because it's solving a nasty problem, but also because
+  * there's a little bit of over-abstraction that tends to obscure what's going
+  * on behind a maze of helper functions and macros.
+  *
+  * The basic problem is that hardware folks have started gluing together CPUs
+  * with distinct architectural features; in some cases even creating SoCs where
+  * user-visible instructions are available only on a subset of the available
+  * cores. We try to address this by snapshotting the feature registers of the
+  * boot CPU and comparing these with the feature registers of each secondary
+  * CPU when bringing them up. If there is a mismatch, then we update the
+  * snapshot state to indicate the lowest-common denominator of the feature,
+  * known as the "safe" value. This snapshot state can be queried to view the
+  * "sanitised" value of a feature register.
+  *
+  * The sanitised register values are used to decide which capabilities we
+  * have in the system. These may be in the form of traditional "hwcaps"
+  * advertised to userspace or internal "cpucaps" which are used to configure
+  * things like alternative patching and static keys. While a feature mismatch
+  * may result in a TAINT_CPU_OUT_OF_SPEC kernel taint, a capability mismatch
+  * may prevent a CPU from being onlined at all.
+  *
+  * Some implementation details worth remembering:
+  *
+  * - Mismatched features are *always* sanitised to a "safe" value, which
+  *   usually indicates that the feature is not supported.
+  *
+  * - A mismatched feature marked with FTR_STRICT will cause a "SANITY CHECK"
+  *   warning when onlining an offending CPU and the kernel will be tainted
+  *   with TAINT_CPU_OUT_OF_SPEC.
+  *
+  * - Features marked as FTR_VISIBLE have their sanitised value visible to
+  *   userspace. FTR_VISIBLE features in registers that are only visible
+  *   to EL0 by trapping *must* have a corresponding HWCAP so that late
+  *   onlining of CPUs cannot lead to features disappearing at runtime.
+  *
+  * - A "feature" is typically a 4-bit register field. A "capability" is the
+  *   high-level description derived from the sanitised field value.
+  *
+  * - Read the Arm ARM (DDI 0487F.a) section D13.1.3 ("Principles of the ID
+  *   scheme for fields in ID registers") to understand when feature fields
+  *   may be signed or unsigned (FTR_SIGNED and FTR_UNSIGNED accordingly).
+  *
+  * - KVM exposes its own view of the feature registers to guest operating
+  *   systems regardless of FTR_VISIBLE. This is typically driven from the
+  *   sanitised register values to allow virtual CPUs to be migrated between
+  *   arbitrary physical CPUs, but some features not present on the host are
+  *   also advertised and emulated. Look at sys_reg_descs[] for the gory
+  *   details.
++>>>>>>> a2a69963524d (arm64: cpufeature: Add an overview comment for the cpufeature framework)
   */
  
  #define pr_fmt(fmt) "CPU features: " fmt
* Unmerged path arch/arm64/kernel/cpufeature.c
