arm64: ptrauth: Add bootup/runtime flags for __cpu_setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Amit Daniel Kachhap <amit.kachhap@arm.com>
commit df3551011b8188e7a9291a66c2c0a04c4eb9d8eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/df355101.failed

This patch allows __cpu_setup to be invoked with one of these flags,
ARM64_CPU_BOOT_PRIMARY, ARM64_CPU_BOOT_SECONDARY or ARM64_CPU_RUNTIME.
This is required as some cpufeatures need different handling during
different scenarios.

The input parameter in x0 is preserved till the end to be used inside
this function.

There should be no functional change with this patch and is useful
for the subsequent ptrauth patch which utilizes it. Some upcoming
arm cpufeatures can also utilize these flags.

	Suggested-by: James Morse <james.morse@arm.com>
	Signed-off-by: Amit Daniel Kachhap <amit.kachhap@arm.com>
	Reviewed-by: Vincenzo Frascino <Vincenzo.Frascino@arm.com>
	Reviewed-by: James Morse <james.morse@arm.com>
	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit df3551011b8188e7a9291a66c2c0a04c4eb9d8eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/proc.S
diff --cc arch/arm64/mm/proc.S
index 768b1405972d,ea0db1744c29..000000000000
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@@ -420,23 -408,25 +420,31 @@@ ENDPROC(idmap_kpti_install_ng_mappings
  /*
   *	__cpu_setup
   *
-  *	Initialise the processor for turning the MMU on.  Return in x0 the
-  *	value of the SCTLR_EL1 register.
+  *	Initialise the processor for turning the MMU on.
+  *
+  * Input:
+  *	x0 with a flag ARM64_CPU_BOOT_PRIMARY/ARM64_CPU_BOOT_SECONDARY/ARM64_CPU_RUNTIME.
+  * Output:
+  *	Return in x0 the value of the SCTLR_EL1 register.
   */
  	.pushsection ".idmap.text", "awx"
 -SYM_FUNC_START(__cpu_setup)
 +ENTRY(__cpu_setup)
  	tlbi	vmalle1				// Invalidate local TLB
  	dsb	nsh
  
- 	mov	x0, #3 << 20
- 	msr	cpacr_el1, x0			// Enable FP/ASIMD
- 	mov	x0, #1 << 12			// Reset mdscr_el1 and disable
- 	msr	mdscr_el1, x0			// access to the DCC from EL0
+ 	mov	x1, #3 << 20
+ 	msr	cpacr_el1, x1			// Enable FP/ASIMD
+ 	mov	x1, #1 << 12			// Reset mdscr_el1 and disable
+ 	msr	mdscr_el1, x1			// access to the DCC from EL0
  	isb					// Unmask debug exceptions now,
  	enable_dbg				// since this is per-cpu
++<<<<<<< HEAD
 +	reset_pmuserenr_el0 x0			// Disable PMU access from EL0
 +	reset_amuserenr_el0 x0			// Disable AMU access from EL0
 +
++=======
+ 	reset_pmuserenr_el0 x1			// Disable PMU access from EL0
++>>>>>>> df3551011b81 (arm64: ptrauth: Add bootup/runtime flags for __cpu_setup)
  	/*
  	 * Memory region attributes
  	 */
@@@ -482,5 -468,9 +486,9 @@@
  1:
  #endif	/* CONFIG_ARM64_HW_AFDBM */
  	msr	tcr_el1, x10
+ 	/*
+ 	 * Prepare SCTLR
+ 	 */
+ 	mov_q	x0, SCTLR_EL1_SET
  	ret					// return to head.S
 -SYM_FUNC_END(__cpu_setup)
 +ENDPROC(__cpu_setup)
diff --git a/arch/arm64/include/asm/smp.h b/arch/arm64/include/asm/smp.h
index a9c5715016b5..f7e92b5db60b 100644
--- a/arch/arm64/include/asm/smp.h
+++ b/arch/arm64/include/asm/smp.h
@@ -34,6 +34,14 @@
 #define CPU_STUCK_REASON_52_BIT_VA	(UL(1) << CPU_STUCK_REASON_SHIFT)
 #define CPU_STUCK_REASON_NO_GRAN	(UL(2) << CPU_STUCK_REASON_SHIFT)
 
+/* Possible options for __cpu_setup */
+/* Option to setup primary cpu */
+#define ARM64_CPU_BOOT_PRIMARY		(1)
+/* Option to setup secondary cpus */
+#define ARM64_CPU_BOOT_SECONDARY	(2)
+/* Option to setup cpus for different cpu run time services */
+#define ARM64_CPU_RUNTIME		(3)
+
 #ifndef __ASSEMBLY__
 
 #include <asm/percpu.h>
diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
index e3713313312f..40b3b8ae0170 100644
--- a/arch/arm64/kernel/head.S
+++ b/arch/arm64/kernel/head.S
@@ -127,6 +127,7 @@ ENTRY(stext)
 	 * On return, the CPU will be ready for the MMU to be turned on and
 	 * the TCR will have been set.
 	 */
+	mov	x0, #ARM64_CPU_BOOT_PRIMARY
 	bl	__cpu_setup			// initialise processor
 	b	__primary_switch
 ENDPROC(stext)
@@ -720,6 +721,7 @@ secondary_startup:
 	 * Common entry point for secondary CPUs.
 	 */
 	bl	__cpu_secondary_check52bitva
+	mov	x0, #ARM64_CPU_BOOT_SECONDARY
 	bl	__cpu_setup			// initialise processor
 	adrp	x1, swapper_pg_dir
 	bl	__enable_mmu
diff --git a/arch/arm64/kernel/sleep.S b/arch/arm64/kernel/sleep.S
index 63ad2757c19c..ebfd3e7752e9 100644
--- a/arch/arm64/kernel/sleep.S
+++ b/arch/arm64/kernel/sleep.S
@@ -3,6 +3,7 @@
 #include <linux/linkage.h>
 #include <asm/asm-offsets.h>
 #include <asm/assembler.h>
+#include <asm/smp.h>
 
 	.text
 /*
@@ -99,6 +100,7 @@ ENDPROC(__cpu_suspend_enter)
 	.pushsection ".idmap.text", "awx"
 ENTRY(cpu_resume)
 	bl	el2_setup		// if in EL2 drop to EL1 cleanly
+	mov	x0, #ARM64_CPU_RUNTIME
 	bl	__cpu_setup
 	/* enable the MMU early - so we can access sleep_save_stash by va */
 	adrp	x1, swapper_pg_dir
* Unmerged path arch/arm64/mm/proc.S
