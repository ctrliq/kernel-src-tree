smp: Process pending softirqs in flush_smp_call_function_from_idle()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit 66040b2d5d41f85cb1a752a75260595344c5ec3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/66040b2d.failed

send_call_function_single_ipi() may wake an idle CPU without sending an
IPI. The woken up CPU will process the SMP-functions in
flush_smp_call_function_from_idle(). Any raised softirq from within the
SMP-function call will not be processed.
Should the CPU have no tasks assigned, then it will go back to idle with
pending softirqs and the NOHZ will rightfully complain.

Process pending softirqs on return from flush_smp_call_function_queue().

Fixes: b2a02fc43a1f4 ("smp: Optimize send_call_function_single_ipi()")
	Reported-by: Jens Axboe <axboe@kernel.dk>
	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20210123201027.3262800-2-bigeasy@linutronix.de
(cherry picked from commit 66040b2d5d41f85cb1a752a75260595344c5ec3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/smp.c
diff --cc kernel/smp.c
index db3e44b3aed3,aeb0adfa0606..000000000000
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@@ -268,13 -403,57 +269,37 @@@ static void flush_smp_call_function_que
  	/*
  	 * Second; run all !SYNC callbacks.
  	 */
 -	prev = NULL;
 -	llist_for_each_entry_safe(csd, csd_next, entry, node.llist) {
 -		int type = CSD_TYPE(csd);
 -
 -		if (type != CSD_TYPE_TTWU) {
 -			if (prev) {
 -				prev->next = &csd_next->node.llist;
 -			} else {
 -				entry = &csd_next->node.llist;
 -			}
 -
 -			if (type == CSD_TYPE_ASYNC) {
 -				smp_call_func_t func = csd->func;
 -				void *info = csd->info;
 -
 -				csd_lock_record(csd);
 -				csd_unlock(csd);
 -				func(info);
 -				csd_lock_record(NULL);
 -			} else if (type == CSD_TYPE_IRQ_WORK) {
 -				irq_work_single(csd);
 -			}
 +	llist_for_each_entry_safe(csd, csd_next, entry, llist) {
 +		smp_call_func_t func = csd->func;
 +		void *info = csd->info;
  
 -		} else {
 -			prev = &csd->node.llist;
 -		}
 +		csd_unlock(csd);
 +		func(info);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Third; only CSD_TYPE_TTWU is left, issue those.
+ 	 */
+ 	if (entry)
+ 		sched_ttwu_pending(entry);
+ }
+ 
+ void flush_smp_call_function_from_idle(void)
+ {
+ 	unsigned long flags;
+ 
+ 	if (llist_empty(this_cpu_ptr(&call_single_queue)))
+ 		return;
+ 
+ 	local_irq_save(flags);
+ 	flush_smp_call_function_queue(true);
+ 	if (local_softirq_pending())
+ 		do_softirq();
+ 
+ 	local_irq_restore(flags);
++>>>>>>> 66040b2d5d41 (smp: Process pending softirqs in flush_smp_call_function_from_idle())
  }
  
  /*
* Unmerged path kernel/smp.c
