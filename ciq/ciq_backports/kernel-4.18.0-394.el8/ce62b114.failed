NFS: Split attribute support out from the server capabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit ce62b114bbad9346641d16853c528ba01513e1b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/ce62b114.failed

There are lots of attributes, and they are crowding out the bit space.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit ce62b114bbad9346641d16853c528ba01513e1b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
diff --cc fs/nfs/inode.c
index 5aab6b527a4e,6d04ebb4f084..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -485,8 -471,8 +486,13 @@@ nfs_fhget(struct super_block *sb, struc
  		inode->i_mode = fattr->mode;
  		nfsi->cache_validity = 0;
  		if ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0
++<<<<<<< HEAD
 +				&& nfs_server_capable(inode, NFS_CAP_MODE))
 +			nfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);
++=======
+ 				&& (fattr_supported & NFS_ATTR_FATTR_MODE))
+ 			nfs_set_cache_invalid(inode, NFS_INO_INVALID_MODE);
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		/* Why so? Because we want revalidate for devices/FIFOs, and
  		 * that's precisely what we have in nfs_file_inode_operations.
  		 */
@@@ -551,11 -537,11 +557,16 @@@
  			nfs_set_cache_invalid(inode, NFS_INO_INVALID_SIZE);
  		if (fattr->valid & NFS_ATTR_FATTR_NLINK)
  			set_nlink(inode, fattr->nlink);
++<<<<<<< HEAD
 +		else if (nfs_server_capable(inode, NFS_CAP_NLINK))
 +			nfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);
++=======
+ 		else if (fattr_supported & NFS_ATTR_FATTR_NLINK)
+ 			nfs_set_cache_invalid(inode, NFS_INO_INVALID_NLINK);
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		if (fattr->valid & NFS_ATTR_FATTR_OWNER)
  			inode->i_uid = fattr->uid;
- 		else if (nfs_server_capable(inode, NFS_CAP_OWNER))
+ 		else if (fattr_supported & NFS_ATTR_FATTR_OWNER)
  			nfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);
  		if (fattr->valid & NFS_ATTR_FATTR_GROUP)
  			inode->i_gid = fattr->gid;
@@@ -570,12 -559,10 +584,13 @@@
  			 * report the blocks in 512byte units
  			 */
  			inode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);
- 		} else if (fattr->size != 0)
+ 		} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED &&
+ 			   fattr->size != 0)
  			nfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);
  
 +		if (nfsi->cache_validity != 0)
 +			nfsi->cache_validity |= NFS_INO_REVAL_FORCED;
 +
  		nfs_setsecurity(inode, fattr, label);
  
  		nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);
@@@ -2076,19 -2071,17 +2091,31 @@@ static int nfs_update_inode(struct inod
  
  	if (fattr->valid & NFS_ATTR_FATTR_MTIME) {
  		inode->i_mtime = fattr->mtime;
++<<<<<<< HEAD
 +	} else if (server->caps & NFS_CAP_MTIME) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_MTIME
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_MTIME) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_MTIME;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
  	if (fattr->valid & NFS_ATTR_FATTR_CTIME) {
  		inode->i_ctime = fattr->ctime;
++<<<<<<< HEAD
 +	} else if (server->caps & NFS_CAP_CTIME) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_CTIME
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_CTIME) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_CTIME;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
@@@ -2125,13 -2117,11 +2152,19 @@@
  		cache_revalidated = false;
  	}
  
 +
  	if (fattr->valid & NFS_ATTR_FATTR_ATIME)
  		inode->i_atime = fattr->atime;
++<<<<<<< HEAD
 +	else if (server->caps & NFS_CAP_ATIME) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_ATIME
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	else if (fattr_supported & NFS_ATTR_FATTR_ATIME) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_ATIME;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
@@@ -2144,10 -2134,9 +2177,16 @@@
  				| NFS_INO_INVALID_ACL;
  			attr_changed = true;
  		}
++<<<<<<< HEAD
 +	} else if (server->caps & NFS_CAP_MODE) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_OTHER
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_MODE) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_MODE;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
@@@ -2158,10 -2147,9 +2197,16 @@@
  			inode->i_uid = fattr->uid;
  			attr_changed = true;
  		}
++<<<<<<< HEAD
 +	} else if (server->caps & NFS_CAP_OWNER) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_OTHER
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_OWNER) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_OTHER;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
@@@ -2172,10 -2160,9 +2217,16 @@@
  			inode->i_gid = fattr->gid;
  			attr_changed = true;
  		}
++<<<<<<< HEAD
 +	} else if (server->caps & NFS_CAP_OWNER_GROUP) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_OTHER
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_GROUP) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_OTHER;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
@@@ -2186,10 -2173,9 +2237,16 @@@
  			set_nlink(inode, fattr->nlink);
  			attr_changed = true;
  		}
++<<<<<<< HEAD
 +	} else if (server->caps & NFS_CAP_NLINK) {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_OTHER
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_NLINK) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_NLINK;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
@@@ -2198,12 -2184,17 +2255,24 @@@
  		 * report the blocks in 512byte units
  		 */
  		inode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);
- 	} else if (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_BLOCKS;
+ 		cache_revalidated = false;
+ 	}
+ 
+ 	if (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED) {
  		inode->i_blocks = fattr->du.nfs2.blocks;
++<<<<<<< HEAD
 +	else {
 +		nfsi->cache_validity |= save_cache_validity &
 +				(NFS_INO_INVALID_BLOCKS
 +				| NFS_INO_REVAL_FORCED);
++=======
+ 	} else if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED) {
+ 		nfsi->cache_validity |=
+ 			save_cache_validity & NFS_INO_INVALID_BLOCKS;
++>>>>>>> ce62b114bbad (NFS: Split attribute support out from the server capabilities)
  		cache_revalidated = false;
  	}
  
diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 801c79552d56..1eaf126803e6 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -698,9 +698,18 @@ static int nfs_init_server(struct nfs_server *server,
 	/* Initialise the client representation from the mount data */
 	server->flags = ctx->flags;
 	server->options = ctx->options;
-	server->caps |= NFS_CAP_HARDLINKS|NFS_CAP_SYMLINKS|NFS_CAP_FILEID|
-		NFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|NFS_CAP_OWNER_GROUP|
-		NFS_CAP_ATIME|NFS_CAP_CTIME|NFS_CAP_MTIME;
+	server->caps |= NFS_CAP_HARDLINKS | NFS_CAP_SYMLINKS;
+
+	switch (clp->rpc_ops->version) {
+	case 2:
+		server->fattr_valid = NFS_ATTR_FATTR_V2;
+		break;
+	case 3:
+		server->fattr_valid = NFS_ATTR_FATTR_V3;
+		break;
+	default:
+		server->fattr_valid = NFS_ATTR_FATTR_V4;
+	}
 
 	if (ctx->rsize)
 		server->rsize = nfs_block_size(ctx->rsize, NULL);
* Unmerged path fs/nfs/inode.c
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 2b64b461b599..32efc1188524 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -3856,12 +3856,9 @@ static int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *f
 			res.attr_bitmask[2] &= FATTR4_WORD2_NFS42_MASK;
 		}
 		memcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));
-		server->caps &= ~(NFS_CAP_ACLS|NFS_CAP_HARDLINKS|
-				NFS_CAP_SYMLINKS|NFS_CAP_FILEID|
-				NFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|
-				NFS_CAP_OWNER_GROUP|NFS_CAP_ATIME|
-				NFS_CAP_CTIME|NFS_CAP_MTIME|
-				NFS_CAP_SECURITY_LABEL);
+		server->caps &= ~(NFS_CAP_ACLS | NFS_CAP_HARDLINKS |
+				  NFS_CAP_SYMLINKS| NFS_CAP_SECURITY_LABEL);
+		server->fattr_valid = NFS_ATTR_FATTR_V4;
 		if (res.attr_bitmask[0] & FATTR4_WORD0_ACL &&
 				res.acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)
 			server->caps |= NFS_CAP_ACLS;
@@ -3869,25 +3866,29 @@ static int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *f
 			server->caps |= NFS_CAP_HARDLINKS;
 		if (res.has_symlinks != 0)
 			server->caps |= NFS_CAP_SYMLINKS;
-		if (res.attr_bitmask[0] & FATTR4_WORD0_FILEID)
-			server->caps |= NFS_CAP_FILEID;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_MODE)
-			server->caps |= NFS_CAP_MODE;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS)
-			server->caps |= NFS_CAP_NLINK;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_OWNER)
-			server->caps |= NFS_CAP_OWNER;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP)
-			server->caps |= NFS_CAP_OWNER_GROUP;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS)
-			server->caps |= NFS_CAP_ATIME;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA)
-			server->caps |= NFS_CAP_CTIME;
-		if (res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY)
-			server->caps |= NFS_CAP_MTIME;
+		if (!(res.attr_bitmask[0] & FATTR4_WORD0_FILEID))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_FILEID;
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_MODE))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_MODE;
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_NLINK;
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_OWNER))
+			server->fattr_valid &= ~(NFS_ATTR_FATTR_OWNER |
+				NFS_ATTR_FATTR_OWNER_NAME);
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP))
+			server->fattr_valid &= ~(NFS_ATTR_FATTR_GROUP |
+				NFS_ATTR_FATTR_GROUP_NAME);
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_SPACE_USED))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_SPACE_USED;
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_ATIME;
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_CTIME;
+		if (!(res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_MTIME;
 #ifdef CONFIG_NFS_V4_SECURITY_LABEL
-		if (res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL)
-			server->caps |= NFS_CAP_SECURITY_LABEL;
+		if (!(res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL))
+			server->fattr_valid &= ~NFS_ATTR_FATTR_V4_SECURITY_LABEL;
 #endif
 		memcpy(server->attr_bitmask_nl, res.attr_bitmask,
 				sizeof(server->attr_bitmask));
diff --git a/include/linux/nfs_fs_sb.h b/include/linux/nfs_fs_sb.h
index 9381c29e8349..069cbb87dade 100644
--- a/include/linux/nfs_fs_sb.h
+++ b/include/linux/nfs_fs_sb.h
@@ -186,6 +186,8 @@ struct nfs_server {
 	dev_t			s_dev;		/* superblock dev numbers */
 	struct nfs_auth_info	auth_info;	/* parsed auth flavors */
 
+	__u64			fattr_valid;	/* Valid attributes */
+
 #ifdef CONFIG_NFS_FSCACHE
 	struct nfs_fscache_key	*fscache_key;	/* unique key for superblock */
 	struct fscache_cookie	*fscache;	/* superblock cookie */
@@ -263,16 +265,7 @@ struct nfs_server {
 #define NFS_CAP_SYMLINKS	(1U << 2)
 #define NFS_CAP_ACLS		(1U << 3)
 #define NFS_CAP_ATOMIC_OPEN	(1U << 4)
-/* #define NFS_CAP_CHANGE_ATTR	(1U << 5) */
 #define NFS_CAP_LGOPEN		(1U << 5)
-#define NFS_CAP_FILEID		(1U << 6)
-#define NFS_CAP_MODE		(1U << 7)
-#define NFS_CAP_NLINK		(1U << 8)
-#define NFS_CAP_OWNER		(1U << 9)
-#define NFS_CAP_OWNER_GROUP	(1U << 10)
-#define NFS_CAP_ATIME		(1U << 11)
-#define NFS_CAP_CTIME		(1U << 12)
-#define NFS_CAP_MTIME		(1U << 13)
 #define NFS_CAP_POSIX_LOCK	(1U << 14)
 #define NFS_CAP_UIDGID_NOMAP	(1U << 15)
 #define NFS_CAP_STATEID_NFSV41	(1U << 16)
