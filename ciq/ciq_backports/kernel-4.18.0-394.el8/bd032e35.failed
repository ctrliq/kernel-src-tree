devlink: Allow control devlink ops behavior through feature mask

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit bd032e35c568ff7cfa347aa4ddd6491e2453f00c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/bd032e35.failed

Introduce new devlink call to set feature mask to control devlink
behavior during device initialization phase after devlink_alloc()
is already called.

This allows us to set reload ops based on device property which
is not known at the beginning of driver initialization.

For the sake of simplicity, this API lacks any type of locking and
needs to be called before devlink_register() to make sure that no
parallel access to the ops is possible at this stage.

	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit bd032e35c568ff7cfa347aa4ddd6491e2453f00c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_devlink.c
#	drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_devlink.c
#	drivers/net/ethernet/mellanox/mlx4/main.c
#	drivers/net/ethernet/mellanox/mlxsw/core.c
#	drivers/net/netdevsim/dev.c
#	include/net/devlink.h
#	net/core/devlink.c
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index 28ac4693da3c,05e850a40b36..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -4036,9 -4024,10 +4036,15 @@@ static int mlx4_init_one(struct pci_de
  	if (ret)
  		goto err_params_unregister;
  
++<<<<<<< HEAD
 +	devlink_params_publish(devlink);
++=======
+ 	pci_save_state(pdev);
+ 	devlink_set_features(devlink, DEVLINK_F_RELOAD);
+ 	devlink_register(devlink);
++>>>>>>> bd032e35c568 (devlink: Allow control devlink ops behavior through feature mask)
  	devlink_reload_enable(devlink);
 +	pci_save_state(pdev);
  	return 0;
  
  err_params_unregister:
diff --cc drivers/net/ethernet/mellanox/mlxsw/core.c
index 7e9a7cb31720,0f1567149a54..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/core.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.c
@@@ -2009,11 -2001,17 +2009,17 @@@ __mlxsw_core_bus_device_register(const 
  	if (err)
  		goto err_env_init;
  
 -	if (mlxsw_driver->init) {
 -		err = mlxsw_driver->init(mlxsw_core, mlxsw_bus_info, extack);
 -		if (err)
 -			goto err_driver_init;
 -	}
 +	mlxsw_core->is_initialized = true;
 +	devlink_params_publish(devlink);
  
++<<<<<<< HEAD
 +	if (!reload)
++=======
+ 	if (!reload) {
+ 		devlink_set_features(devlink, DEVLINK_F_RELOAD);
+ 		devlink_register(devlink);
++>>>>>>> bd032e35c568 (devlink: Allow control devlink ops behavior through feature mask)
  		devlink_reload_enable(devlink);
 -	}
  
  	return 0;
  
diff --cc drivers/net/netdevsim/dev.c
index a3dd545b2aec,520c019dbad5..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -1510,9 -1510,10 +1510,15 @@@ int nsim_dev_probe(struct nsim_bus_dev 
  	if (err)
  		goto err_psample_exit;
  
++<<<<<<< HEAD
 +	devlink_params_publish(devlink);
++=======
+ 	nsim_dev->esw_mode = DEVLINK_ESWITCH_MODE_LEGACY;
+ 	devlink_set_features(devlink, DEVLINK_F_RELOAD);
+ 	devlink_register(devlink);
++>>>>>>> bd032e35c568 (devlink: Allow control devlink ops behavior through feature mask)
  	devlink_reload_enable(devlink);
 +	nsim_dev->esw_mode = DEVLINK_ESWITCH_MODE_LEGACY;
  	return 0;
  
  err_psample_exit:
diff --cc include/net/devlink.h
index f60a6c23bf25,287f18b88293..000000000000
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@@ -1549,13 -1500,16 +1554,18 @@@ struct net *devlink_net(const struct de
   * Drivers that operate on real HW must use devlink_alloc() instead.
   */
  struct devlink *devlink_alloc_ns(const struct devlink_ops *ops,
 -				 size_t priv_size, struct net *net,
 -				 struct device *dev);
 +				 size_t priv_size, struct net *net);
  static inline struct devlink *devlink_alloc(const struct devlink_ops *ops,
 -					    size_t priv_size,
 -					    struct device *dev)
 +					    size_t priv_size)
  {
 -	return devlink_alloc_ns(ops, priv_size, &init_net, dev);
 +	return devlink_alloc_ns(ops, priv_size, &init_net);
  }
++<<<<<<< HEAD
 +int devlink_register(struct devlink *devlink, struct device *dev);
++=======
+ void devlink_set_features(struct devlink *devlink, u64 features);
+ void devlink_register(struct devlink *devlink);
++>>>>>>> bd032e35c568 (devlink: Allow control devlink ops behavior through feature mask)
  void devlink_unregister(struct devlink *devlink);
  void devlink_reload_enable(struct devlink *devlink);
  void devlink_reload_disable(struct devlink *devlink);
diff --cc net/core/devlink.c
index 3e56c892bf42,1931caa0ce1e..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -34,6 -30,64 +34,67 @@@
  #define CREATE_TRACE_POINTS
  #include <trace/events/devlink.h>
  
++<<<<<<< HEAD
++=======
+ #define DEVLINK_RELOAD_STATS_ARRAY_SIZE \
+ 	(__DEVLINK_RELOAD_LIMIT_MAX * __DEVLINK_RELOAD_ACTION_MAX)
+ 
+ struct devlink_dev_stats {
+ 	u32 reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];
+ 	u32 remote_reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];
+ };
+ 
+ struct devlink {
+ 	u32 index;
+ 	struct list_head port_list;
+ 	struct list_head rate_list;
+ 	struct list_head sb_list;
+ 	struct list_head dpipe_table_list;
+ 	struct list_head resource_list;
+ 	struct list_head param_list;
+ 	struct list_head region_list;
+ 	struct list_head reporter_list;
+ 	struct mutex reporters_lock; /* protects reporter_list */
+ 	struct devlink_dpipe_headers *dpipe_headers;
+ 	struct list_head trap_list;
+ 	struct list_head trap_group_list;
+ 	struct list_head trap_policer_list;
+ 	const struct devlink_ops *ops;
+ 	u64 features;
+ 	struct xarray snapshot_ids;
+ 	struct devlink_dev_stats stats;
+ 	struct device *dev;
+ 	possible_net_t _net;
+ 	/* Serializes access to devlink instance specific objects such as
+ 	 * port, sb, dpipe, resource, params, region, traps and more.
+ 	 */
+ 	struct mutex lock;
+ 	u8 reload_failed:1,
+ 	   reload_enabled:1;
+ 	refcount_t refcount;
+ 	struct completion comp;
+ 	char priv[0] __aligned(NETDEV_ALIGN);
+ };
+ 
+ void *devlink_priv(struct devlink *devlink)
+ {
+ 	return &devlink->priv;
+ }
+ EXPORT_SYMBOL_GPL(devlink_priv);
+ 
+ struct devlink *priv_to_devlink(void *priv)
+ {
+ 	return container_of(priv, struct devlink, priv);
+ }
+ EXPORT_SYMBOL_GPL(priv_to_devlink);
+ 
+ struct device *devlink_to_dev(const struct devlink *devlink)
+ {
+ 	return devlink->dev;
+ }
+ EXPORT_SYMBOL_GPL(devlink_to_dev);
+ 
++>>>>>>> bd032e35c568 (devlink: Allow control devlink ops behavior through feature mask)
  static struct devlink_dpipe_field devlink_dpipe_fields_ethernet[] = {
  	{
  		.name = "destination mac",
@@@ -8975,10 -9175,10 +9055,10 @@@ void devlink_unregister(struct devlink 
  	wait_for_completion(&devlink->comp);
  
  	mutex_lock(&devlink_mutex);
- 	WARN_ON(devlink_reload_supported(devlink->ops) &&
+ 	WARN_ON(devlink->features & DEVLINK_F_RELOAD &&
  		devlink->reload_enabled);
 -	devlink_notify_unregister(devlink);
 -	xa_clear_mark(&devlinks, devlink->index, DEVLINK_REGISTERED);
 +	devlink_notify(devlink, DEVLINK_CMD_DEL);
 +	list_del(&devlink->list);
  	mutex_unlock(&devlink_mutex);
  }
  EXPORT_SYMBOL_GPL(devlink_unregister);
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_devlink.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_devlink.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_devlink.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_devlink.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index a4a44e0ddcc8..fc153fb2bc6d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@ -670,6 +670,7 @@ int mlx5_devlink_register(struct devlink *devlink, struct device *dev)
 	if (err)
 		goto traps_reg_err;
 
+	devlink_set_features(devlink, DEVLINK_F_RELOAD);
 	return 0;
 
 traps_reg_err:
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/core.c
* Unmerged path drivers/net/netdevsim/dev.c
* Unmerged path include/net/devlink.h
* Unmerged path net/core/devlink.c
