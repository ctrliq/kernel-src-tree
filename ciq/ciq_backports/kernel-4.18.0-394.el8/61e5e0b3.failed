NFSD: Replace READ* macros in nfsd4_decode_open()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 61e5e0b3ec713d1365008c8af3fe5fdd262e2a60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/61e5e0b3.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 61e5e0b3ec713d1365008c8af3fe5fdd262e2a60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 10163c9081a1,ece7af152fb1..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -1010,101 -1138,18 +1009,108 @@@ nfsd4_decode_open(struct nfsd4_compound
  	status = nfsd4_decode_share_access(argp, &open->op_share_access,
  					   &open->op_deleg_want, &dummy);
  	if (status)
- 		goto xdr_error;
+ 		return status;
  	status = nfsd4_decode_share_deny(argp, &open->op_share_deny);
  	if (status)
- 		goto xdr_error;
- 	READ_BUF(sizeof(clientid_t));
- 	COPYMEM(&open->op_clientid, sizeof(clientid_t));
- 	status = nfsd4_decode_opaque(argp, &open->op_owner);
+ 		return status;
+ 	status = nfsd4_decode_state_owner4(argp, &open->op_clientid,
+ 					   &open->op_owner);
  	if (status)
++<<<<<<< HEAD
 +		goto xdr_error;
 +	READ_BUF(4);
 +	open->op_create = be32_to_cpup(p++);
 +	switch (open->op_create) {
 +	case NFS4_OPEN_NOCREATE:
 +		break;
 +	case NFS4_OPEN_CREATE:
 +		READ_BUF(4);
 +		open->op_createmode = be32_to_cpup(p++);
 +		switch (open->op_createmode) {
 +		case NFS4_CREATE_UNCHECKED:
 +		case NFS4_CREATE_GUARDED:
 +			status = nfsd4_decode_fattr(argp, open->op_bmval,
 +				&open->op_iattr, &open->op_acl, &open->op_label,
 +				&open->op_umask);
 +			if (status)
 +				goto out;
 +			break;
 +		case NFS4_CREATE_EXCLUSIVE:
 +			READ_BUF(NFS4_VERIFIER_SIZE);
 +			COPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);
 +			break;
 +		case NFS4_CREATE_EXCLUSIVE4_1:
 +			if (argp->minorversion < 1)
 +				goto xdr_error;
 +			READ_BUF(NFS4_VERIFIER_SIZE);
 +			COPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);
 +			status = nfsd4_decode_fattr(argp, open->op_bmval,
 +				&open->op_iattr, &open->op_acl, &open->op_label,
 +				&open->op_umask);
 +			if (status)
 +				goto out;
 +			break;
 +		default:
 +			goto xdr_error;
 +		}
 +		break;
 +	default:
 +		goto xdr_error;
 +	}
 +
 +	/* open_claim */
 +	READ_BUF(4);
 +	open->op_claim_type = be32_to_cpup(p++);
 +	switch (open->op_claim_type) {
 +	case NFS4_OPEN_CLAIM_NULL:
 +	case NFS4_OPEN_CLAIM_DELEGATE_PREV:
 +		READ_BUF(4);
 +		open->op_fname.len = be32_to_cpup(p++);
 +		READ_BUF(open->op_fname.len);
 +		SAVEMEM(open->op_fname.data, open->op_fname.len);
 +		if ((status = check_filename(open->op_fname.data, open->op_fname.len)))
 +			return status;
 +		break;
 +	case NFS4_OPEN_CLAIM_PREVIOUS:
 +		READ_BUF(4);
 +		open->op_delegate_type = be32_to_cpup(p++);
 +		break;
 +	case NFS4_OPEN_CLAIM_DELEGATE_CUR:
 +		status = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);
 +		if (status)
 +			return status;
 +		READ_BUF(4);
 +		open->op_fname.len = be32_to_cpup(p++);
 +		READ_BUF(open->op_fname.len);
 +		SAVEMEM(open->op_fname.data, open->op_fname.len);
 +		if ((status = check_filename(open->op_fname.data, open->op_fname.len)))
 +			return status;
 +		break;
 +	case NFS4_OPEN_CLAIM_FH:
 +	case NFS4_OPEN_CLAIM_DELEG_PREV_FH:
 +		if (argp->minorversion < 1)
 +			goto xdr_error;
 +		/* void */
 +		break;
 +	case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
 +		if (argp->minorversion < 1)
 +			goto xdr_error;
 +		status = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);
 +		if (status)
 +			return status;
 +		break;
 +	default:
 +		goto xdr_error;
 +	}
 +
 +	DECODE_TAIL;
++=======
+ 		return status;
+ 	status = nfsd4_decode_openflag4(argp, open);
+ 	if (status)
+ 		return status;
+ 	return nfsd4_decode_open_claim4(argp, open);
++>>>>>>> 61e5e0b3ec71 (NFSD: Replace READ* macros in nfsd4_decode_open())
  }
  
  static __be32
* Unmerged path fs/nfsd/nfs4xdr.c
