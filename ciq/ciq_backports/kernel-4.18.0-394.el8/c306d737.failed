NFSD: Deprecate NFS_OFFSET_MAX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit c306d737691ef84305d4ed0d302c63db2932f0bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/c306d737.failed

NFS_OFFSET_MAX was introduced way back in Linux v2.3.y before there
was a kernel-wide OFFSET_MAX value. As a clean up, replace the last
few uses of it with its generic equivalent, and get rid of it.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit c306d737691ef84305d4ed0d302c63db2932f0bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3xdr.c
diff --cc fs/nfsd/nfs3xdr.c
index 18d860ea6e32,0293b8d65f10..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -1232,163 -1032,159 +1232,206 @@@ out
   */
  void nfs3svc_encode_cookie3(struct nfsd3_readdirres *resp, u64 offset)
  {
 -	__be64 cookie = cpu_to_be64(offset);
 -
 -	if (!resp->cookie_offset)
 +	if (!resp->offset)
  		return;
 -	write_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,
 -			       sizeof(cookie));
 -	resp->cookie_offset = 0;
 +
 +	if (resp->offset1) {
 +		/* we ended up with offset on a page boundary */
 +		*resp->offset = cpu_to_be32(offset >> 32);
 +		*resp->offset1 = cpu_to_be32(offset & 0xffffffff);
 +		resp->offset1 = NULL;
 +	} else {
 +		xdr_encode_hyper(resp->offset, offset);
 +	}
 +	resp->offset = NULL;
  }
  
++<<<<<<< HEAD
 +/*
 + * Encode a directory entry. This one works for both normal readdir
 + * and readdirplus.
 + * The normal readdir reply requires 2 (fileid) + 1 (stringlen)
 + * + string + 2 (cookie) + 1 (next) words, i.e. 6 + strlen.
 + * 
 + * The readdirplus baggage is 1+21 words for post_op_attr, plus the
 + * file handle.
++=======
+ static bool
+ svcxdr_encode_entry3_common(struct nfsd3_readdirres *resp, const char *name,
+ 			    int namlen, loff_t offset, u64 ino)
+ {
+ 	struct xdr_buf *dirlist = &resp->dirlist;
+ 	struct xdr_stream *xdr = &resp->xdr;
+ 
+ 	if (xdr_stream_encode_item_present(xdr) < 0)
+ 		return false;
+ 	/* fileid */
+ 	if (xdr_stream_encode_u64(xdr, ino) < 0)
+ 		return false;
+ 	/* name */
+ 	if (xdr_stream_encode_opaque(xdr, name, min(namlen, NFS3_MAXNAMLEN)) < 0)
+ 		return false;
+ 	/* cookie */
+ 	resp->cookie_offset = dirlist->len;
+ 	if (xdr_stream_encode_u64(xdr, OFFSET_MAX) < 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /**
+  * nfs3svc_encode_entry3 - encode one NFSv3 READDIR entry
+  * @data: directory context
+  * @name: name of the object to be encoded
+  * @namlen: length of that name, in bytes
+  * @offset: the offset of the previous entry
+  * @ino: the fileid of this entry
+  * @d_type: unused
+  *
+  * Return values:
+  *   %0: Entry was successfully encoded.
+  *   %-EINVAL: An encoding problem occured, secondary status code in resp->common.err
+  *
+  * On exit, the following fields are updated:
+  *   - resp->xdr
+  *   - resp->common.err
+  *   - resp->cookie_offset
++>>>>>>> c306d737691e (NFSD: Deprecate NFS_OFFSET_MAX)
   */
 -int nfs3svc_encode_entry3(void *data, const char *name, int namlen,
 -			  loff_t offset, u64 ino, unsigned int d_type)
 +
 +#define NFS3_ENTRY_BAGGAGE	(2 + 1 + 2 + 1)
 +#define NFS3_ENTRYPLUS_BAGGAGE	(1 + 21 + 1 + (NFS3_FHSIZE >> 2))
 +static int
 +encode_entry(struct readdir_cd *ccd, const char *name, int namlen,
 +	     loff_t offset, u64 ino, unsigned int d_type, int plus)
  {
 -	struct readdir_cd *ccd = data;
 -	struct nfsd3_readdirres *resp = container_of(ccd,
 -						     struct nfsd3_readdirres,
 -						     common);
 -	unsigned int starting_length = resp->dirlist.len;
 +	struct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,
 +		       					common);
 +	__be32		*p = cd->buffer;
 +	caddr_t		curr_page_addr = NULL;
 +	struct page **	page;
 +	int		slen;		/* string (name) length */
 +	int		elen;		/* estimated entry length in words */
 +	int		num_entry_words = 0;	/* actual number of words */
  
 -	/* The offset cookie for the previous entry */
 -	nfs3svc_encode_cookie3(resp, offset);
 +	nfs3svc_encode_cookie3(cd, offset);
  
 -	if (!svcxdr_encode_entry3_common(resp, name, namlen, offset, ino))
 -		goto out_toosmall;
 +	/*
 +	dprintk("encode_entry(%.*s @%ld%s)\n",
 +		namlen, name, (long) offset, plus? " plus" : "");
 +	 */
  
 -	xdr_commit_encode(&resp->xdr);
 -	resp->common.err = nfs_ok;
 -	return 0;
 +	/* truncate filename if too long */
 +	namlen = min(namlen, NFS3_MAXNAMLEN);
  
 -out_toosmall:
 -	resp->cookie_offset = 0;
 -	resp->common.err = nfserr_toosmall;
 -	resp->dirlist.len = starting_length;
 -	return -EINVAL;
 -}
 +	slen = XDR_QUADLEN(namlen);
 +	elen = slen + NFS3_ENTRY_BAGGAGE
 +		+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);
  
 -static bool
 -svcxdr_encode_entry3_plus(struct nfsd3_readdirres *resp, const char *name,
 -			  int namlen, u64 ino)
 -{
 -	struct xdr_stream *xdr = &resp->xdr;
 -	struct svc_fh *fhp = &resp->scratch;
 -	bool result;
 +	if (cd->buflen < elen) {
 +		cd->common.err = nfserr_toosmall;
 +		return -EINVAL;
 +	}
  
 -	result = false;
 -	fh_init(fhp, NFS3_FHSIZE);
 -	if (compose_entry_fh(resp, fhp, name, namlen, ino) != nfs_ok)
 -		goto out_noattrs;
 +	/* determine which page in rq_respages[] we are currently filling */
 +	for (page = cd->rqstp->rq_respages + 1;
 +				page < cd->rqstp->rq_next_page; page++) {
 +		curr_page_addr = page_address(*page);
  
 -	if (!svcxdr_encode_post_op_attr(resp->rqstp, xdr, fhp))
 -		goto out;
 -	if (!svcxdr_encode_post_op_fh3(xdr, fhp))
 -		goto out;
 -	result = true;
 +		if (((caddr_t)cd->buffer >= curr_page_addr) &&
 +		    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))
 +			break;
 +	}
  
 -out:
 -	fh_put(fhp);
 -	return result;
 +	if ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {
 +		/* encode entry in current page */
  
 -out_noattrs:
 -	if (xdr_stream_encode_item_absent(xdr) < 0)
 -		return false;
 -	if (xdr_stream_encode_item_absent(xdr) < 0)
 -		return false;
 -	return true;
 -}
 +		p = encode_entry_baggage(cd, p, name, namlen, ino);
  
 -/**
 - * nfs3svc_encode_entryplus3 - encode one NFSv3 READDIRPLUS entry
 - * @data: directory context
 - * @name: name of the object to be encoded
 - * @namlen: length of that name, in bytes
 - * @offset: the offset of the previous entry
 - * @ino: the fileid of this entry
 - * @d_type: unused
 - *
 - * Return values:
 - *   %0: Entry was successfully encoded.
 - *   %-EINVAL: An encoding problem occured, secondary status code in resp->common.err
 - *
 - * On exit, the following fields are updated:
 - *   - resp->xdr
 - *   - resp->common.err
 - *   - resp->cookie_offset
 - */
 -int nfs3svc_encode_entryplus3(void *data, const char *name, int namlen,
 -			      loff_t offset, u64 ino, unsigned int d_type)
 -{
 -	struct readdir_cd *ccd = data;
 -	struct nfsd3_readdirres *resp = container_of(ccd,
 -						     struct nfsd3_readdirres,
 -						     common);
 -	unsigned int starting_length = resp->dirlist.len;
 +		if (plus)
 +			p = encode_entryplus_baggage(cd, p, name, namlen, ino);
 +		num_entry_words = p - cd->buffer;
 +	} else if (*(page+1) != NULL) {
 +		/* temporarily encode entry into next page, then move back to
 +		 * current and next page in rq_respages[] */
 +		__be32 *p1, *tmp;
 +		int len1, len2;
  
 -	/* The offset cookie for the previous entry */
 -	nfs3svc_encode_cookie3(resp, offset);
 +		/* grab next page for temporary storage of entry */
 +		p1 = tmp = page_address(*(page+1));
  
 -	if (!svcxdr_encode_entry3_common(resp, name, namlen, offset, ino))
 -		goto out_toosmall;
 -	if (!svcxdr_encode_entry3_plus(resp, name, namlen, ino))
 -		goto out_toosmall;
 +		p1 = encode_entry_baggage(cd, p1, name, namlen, ino);
  
 -	xdr_commit_encode(&resp->xdr);
 -	resp->common.err = nfs_ok;
 +		if (plus)
 +			p1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);
 +
 +		/* determine entry word length and lengths to go in pages */
 +		num_entry_words = p1 - tmp;
 +		len1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;
 +		if ((num_entry_words << 2) < len1) {
 +			/* the actual number of words in the entry is less
 +			 * than elen and can still fit in the current page
 +			 */
 +			memmove(p, tmp, num_entry_words << 2);
 +			p += num_entry_words;
 +
 +			/* update offset */
 +			cd->offset = cd->buffer + (cd->offset - tmp);
 +		} else {
 +			unsigned int offset_r = (cd->offset - tmp) << 2;
 +
 +			/* update pointer to offset location.
 +			 * This is a 64bit quantity, so we need to
 +			 * deal with 3 cases:
 +			 *  -	entirely in first page
 +			 *  -	entirely in second page
 +			 *  -	4 bytes in each page
 +			 */
 +			if (offset_r + 8 <= len1) {
 +				cd->offset = p + (cd->offset - tmp);
 +			} else if (offset_r >= len1) {
 +				cd->offset -= len1 >> 2;
 +			} else {
 +				/* sitting on the fence */
 +				BUG_ON(offset_r != len1 - 4);
 +				cd->offset = p + (cd->offset - tmp);
 +				cd->offset1 = tmp;
 +			}
 +
 +			len2 = (num_entry_words << 2) - len1;
 +
 +			/* move from temp page to current and next pages */
 +			memmove(p, tmp, len1);
 +			memmove(tmp, (caddr_t)tmp+len1, len2);
 +
 +			p = tmp + (len2 >> 2);
 +		}
 +	}
 +	else {
 +		cd->common.err = nfserr_toosmall;
 +		return -EINVAL;
 +	}
 +
 +	cd->buflen -= num_entry_words;
 +	cd->buffer = p;
 +	cd->common.err = nfs_ok;
  	return 0;
  
 -out_toosmall:
 -	resp->cookie_offset = 0;
 -	resp->common.err = nfserr_toosmall;
 -	resp->dirlist.len = starting_length;
 -	return -EINVAL;
 +}
 +
 +int
 +nfs3svc_encode_entry(void *cd, const char *name,
 +		     int namlen, loff_t offset, u64 ino, unsigned int d_type)
 +{
 +	return encode_entry(cd, name, namlen, offset, ino, d_type, 0);
 +}
 +
 +int
 +nfs3svc_encode_entry_plus(void *cd, const char *name,
 +			  int namlen, loff_t offset, u64 ino,
 +			  unsigned int d_type)
 +{
 +	return encode_entry(cd, name, namlen, offset, ino, d_type, 1);
  }
  
  static bool
* Unmerged path fs/nfsd/nfs3xdr.c
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7..689aca62395e 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -3324,7 +3324,7 @@ nfsd4_encode_dirent(void *ccdv, const char *name, int namlen,
 	p = xdr_reserve_space(xdr, 3*4 + namlen);
 	if (!p)
 		goto fail;
-	p = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */
+	p = xdr_encode_hyper(p, OFFSET_MAX);        /* offset of next entry */
 	p = xdr_encode_array(p, name, namlen);      /* name length & name */
 
 	nfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);
diff --git a/include/linux/nfs.h b/include/linux/nfs.h
index 0dc7ad38a0da..b06375e88e58 100644
--- a/include/linux/nfs.h
+++ b/include/linux/nfs.h
@@ -36,14 +36,6 @@ static inline void nfs_copy_fh(struct nfs_fh *target, const struct nfs_fh *sourc
 	memcpy(target->data, source->data, source->size);
 }
 
-
-/*
- * This is really a general kernel constant, but since nothing like
- * this is defined in the kernel headers, I have to do it here.
- */
-#define NFS_OFFSET_MAX		((__s64)((~(__u64)0) >> 1))
-
-
 enum nfs3_stable_how {
 	NFS_UNSTABLE = 0,
 	NFS_DATA_SYNC = 1,
