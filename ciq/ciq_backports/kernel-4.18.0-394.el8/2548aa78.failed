NFSD: Add a separate decoder to handle state_protect_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 2548aa784d760567c2a77cbd8b7c55b211167c37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/2548aa78.failed

Refactor for clarity and de-duplication of code.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 2548aa784d760567c2a77cbd8b7c55b211167c37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index a7c80f4dce78,07716e747ea2..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -348,35 -304,152 +348,66 @@@ nfsd4_decode_nfstime4(struct nfsd4_comp
  }
  
  static __be32
++<<<<<<< HEAD
 +nfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)
 +{
 +	u32 bmlen;
 +	DECODE_HEAD;
 +
 +	bmval[0] = 0;
 +	bmval[1] = 0;
 +	bmval[2] = 0;
 +
 +	READ_BUF(4);
 +	bmlen = be32_to_cpup(p++);
 +	if (bmlen > 1000)
 +		goto xdr_error;
 +
 +	READ_BUF(bmlen << 2);
 +	if (bmlen > 0)
 +		bmval[0] = be32_to_cpup(p++);
 +	if (bmlen > 1)
 +		bmval[1] = be32_to_cpup(p++);
 +	if (bmlen > 2)
 +		bmval[2] = be32_to_cpup(p++);
 +
 +	DECODE_TAIL;
 +}
 +
++=======
+ nfsd4_decode_verifier4(struct nfsd4_compoundargs *argp, nfs4_verifier *verf)
+ {
+ 	__be32 *p;
+ 
+ 	p = xdr_inline_decode(argp->xdr, NFS4_VERIFIER_SIZE);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	memcpy(verf->data, p, sizeof(verf->data));
+ 	return nfs_ok;
+ }
+ 
+ /**
+  * nfsd4_decode_bitmap4 - Decode an NFSv4 bitmap4
+  * @argp: NFSv4 compound argument structure
+  * @bmval: pointer to an array of u32's to decode into
+  * @bmlen: size of the @bmval array
+  *
+  * The server needs to return nfs_ok rather than nfserr_bad_xdr when
+  * encountering bitmaps containing bits it does not recognize. This
+  * includes bits in bitmap words past WORDn, where WORDn is the last
+  * bitmap WORD the implementation currently supports. Thus we are
+  * careful here to simply ignore bits in bitmap words that this
+  * implementation has yet to support explicitly.
+  *
+  * Return values:
+  *   %nfs_ok: @bmval populated successfully
+  *   %nfserr_bad_xdr: the encoded bitmap was invalid
+  */
++>>>>>>> 2548aa784d76 (NFSD: Add a separate decoder to handle state_protect_ops)
  static __be32
 -nfsd4_decode_bitmap4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen)
 -{
 -	u32 i, count;
 -	__be32 *p;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
 -		return nfserr_bad_xdr;
 -	/* request sanity */
 -	if (count > 1000)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, count << 2);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	i = 0;
 -	while (i < count)
 -		bmval[i++] = be32_to_cpup(p++);
 -	while (i < bmlen)
 -		bmval[i++] = 0;
 -
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_nfsace4(struct nfsd4_compoundargs *argp, struct nfs4_ace *ace)
 -{
 -	__be32 *p, status;
 -	u32 length;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &ace->type) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &ace->flag) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &ace->access_mask) < 0)
 -		return nfserr_bad_xdr;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, length);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	ace->whotype = nfs4_acl_get_whotype((char *)p, length);
 -	if (ace->whotype != NFS4_ACL_WHO_NAMED)
 -		status = nfs_ok;
 -	else if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)
 -		status = nfsd_map_name_to_gid(argp->rqstp,
 -				(char *)p, length, &ace->who_gid);
 -	else
 -		status = nfsd_map_name_to_uid(argp->rqstp,
 -				(char *)p, length, &ace->who_uid);
 -
 -	return status;
 -}
 -
 -/* A counted array of nfsace4's */
 -static noinline __be32
 -nfsd4_decode_acl(struct nfsd4_compoundargs *argp, struct nfs4_acl **acl)
 -{
 -	struct nfs4_ace *ace;
 -	__be32 status;
 -	u32 count;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
 -		return nfserr_bad_xdr;
 -
 -	if (count > xdr_stream_remaining(argp->xdr) / 20)
 -		/*
 -		 * Even with 4-byte names there wouldn't be
 -		 * space for that many aces; something fishy is
 -		 * going on:
 -		 */
 -		return nfserr_fbig;
 -
 -	*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(count));
 -	if (*acl == NULL)
 -		return nfserr_jukebox;
 -
 -	(*acl)->naces = count;
 -	for (ace = (*acl)->aces; ace < (*acl)->aces + count; ace++) {
 -		status = nfsd4_decode_nfsace4(argp, ace);
 -		if (status)
 -			return status;
 -	}
 -
 -	return nfs_ok;
 -}
 -
 -static noinline __be32
 -nfsd4_decode_security_label(struct nfsd4_compoundargs *argp,
 -			    struct xdr_netobj *label)
 -{
 -	u32 lfs, pi, length;
 -	__be32 *p;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &lfs) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &pi) < 0)
 -		return nfserr_bad_xdr;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
 -		return nfserr_bad_xdr;
 -	if (length > NFS4_MAXLABELLEN)
 -		return nfserr_badlabel;
 -	p = xdr_inline_decode(argp->xdr, length);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	label->len = length;
 -	label->data = svcxdr_dupstr(argp, p, length);
 -	if (!label->data)
 -		return nfserr_jukebox;
 -
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_fattr4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen,
 -		    struct iattr *iattr, struct nfs4_acl **acl,
 -		    struct xdr_netobj *label, int *umask)
 +nfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,
 +		   struct iattr *iattr, struct nfs4_acl **acl,
 +		   struct xdr_netobj *label, int *umask)
  {
  	unsigned int starting_pos;
  	u32 attrlist4_count;
@@@ -1384,6 -1454,40 +1415,24 @@@ static __be32 nfsd4_decode_backchannel_
  	return nfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);
  }
  
 -static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)
 -{
 -	u32 use_conn_in_rdma_mode;
 -	__be32 status;
 -
 -	status = nfsd4_decode_sessionid4(argp, &bcts->sessionid);
 -	if (status)
 -		return status;
 -	if (xdr_stream_decode_u32(argp->xdr, &bcts->dir) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &use_conn_in_rdma_mode) < 0)
 -		return nfserr_bad_xdr;
 -
 -	return nfs_ok;
 -}
 -
+ static __be32
+ nfsd4_decode_state_protect_ops(struct nfsd4_compoundargs *argp,
+ 			       struct nfsd4_exchange_id *exid)
+ {
+ 	__be32 status;
+ 
+ 	status = nfsd4_decode_bitmap4(argp, exid->spo_must_enforce,
+ 				      ARRAY_SIZE(exid->spo_must_enforce));
+ 	if (status)
+ 		return nfserr_bad_xdr;
+ 	status = nfsd4_decode_bitmap4(argp, exid->spo_must_allow,
+ 				      ARRAY_SIZE(exid->spo_must_allow));
+ 	if (status)
+ 		return nfserr_bad_xdr;
+ 
+ 	return nfs_ok;
+ }
+ 
  static __be32
  nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
  			 struct nfsd4_exchange_id *exid)
* Unmerged path fs/nfsd/nfs4xdr.c
