driver core: Flow the return code from ->probe() through to sysfs bind

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit ef6dcbdd8eb2f44dce70a3abecc32d43cc5f3e64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/ef6dcbdd.failed

Currently really_probe() returns 1 on success and 0 if the probe() call
fails. This return code arrangement is designed to be useful for
__device_attach_driver() which is walking the device list and trying every
driver. 0 means to keep trying.

However, it is not useful for the other places that call through to
really_probe() that do actually want to see the probe() return code.

For instance bind_store() would be better to return the actual error code
from the driver's probe method, not discarding it and returning -ENODEV.

Reorganize things so that really_probe() returns the error code from
->probe as a (inverted) positive number, and 0 for successful attach.

With this, __device_attach_driver can ignore the (positive) probe errors,
return 1 to exit the loop for a successful binding and pass on the
other negative errors, while device_driver_attach simplify inverts the
positive errors and returns all errors to the sysfs code.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
Link: https://lore.kernel.org/r/20210617142218.1877096-4-hch@lst.de
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit ef6dcbdd8eb2f44dce70a3abecc32d43cc5f3e64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
diff --cc drivers/base/dd.c
index 532d8dcbb5eb,25341f52198c..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -610,14 -604,14 +610,25 @@@ re_probe
  			goto probe_failed;
  	}
  
++<<<<<<< HEAD
 +	if (dev->bus->probe) {
 +		ret = dev->bus->probe(dev);
 +		if (ret)
 +			goto probe_failed;
 +	} else if (drv->probe) {
 +		ret = drv->probe(dev);
 +		if (ret)
 +			goto probe_failed;
++=======
+ 	probe_ret = call_driver_probe(dev, drv);
+ 	if (probe_ret) {
+ 		/*
+ 		 * Return probe errors as positive values so that the callers
+ 		 * can distinguish them from other errors.
+ 		 */
+ 		ret = -probe_ret;
+ 		goto probe_failed;
++>>>>>>> ef6dcbdd8eb2 (driver core: Flow the return code from ->probe() through to sysfs bind)
  	}
  
  	if (device_add_groups(dev, drv->dev_groups)) {
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index b5fd2195d819..8222c3f50514 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -211,13 +211,9 @@ static ssize_t bind_store(struct device_driver *drv, const char *buf,
 	dev = bus_find_device_by_name(bus, NULL, buf);
 	if (dev && driver_match_device(drv, dev)) {
 		err = device_driver_attach(drv, dev);
-
-		if (err > 0) {
+		if (!err) {
 			/* success */
 			err = count;
-		} else if (err == 0) {
-			/* driver didn't accept device */
-			err = -ENODEV;
 		}
 	}
 	put_device(dev);
* Unmerged path drivers/base/dd.c
