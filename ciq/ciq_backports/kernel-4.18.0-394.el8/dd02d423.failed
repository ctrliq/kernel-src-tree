sched/cpuacct: Fix user/system in shown cpuacct.usage*

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Andrey Ryabinin <arbn@yandex-team.com>
commit dd02d4234c9a2214a81c57a16484304a1a51872a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/dd02d423.failed

cpuacct has 2 different ways of accounting and showing user
and system times.

The first one uses cpuacct_account_field() to account times
and cpuacct.stat file to expose them. And this one seems to work ok.

The second one is uses cpuacct_charge() function for accounting and
set of cpuacct.usage* files to show times. Despite some attempts to
fix it in the past it still doesn't work. Sometimes while running KVM
guest the cpuacct_charge() accounts most of the guest time as
system time. This doesn't match with user&system times shown in
cpuacct.stat or proc/<pid>/stat.

Demonstration:
 # git clone https://github.com/aryabinin/kvmsample
 # make
 # mkdir /sys/fs/cgroup/cpuacct/test
 # echo $$ > /sys/fs/cgroup/cpuacct/test/tasks
 # ./kvmsample &
 # for i in {1..5}; do cat /sys/fs/cgroup/cpuacct/test/cpuacct.usage_sys; sleep 1; done
 1976535645
 2979839428
 3979832704
 4983603153
 5983604157

Use cpustats accounted in cpuacct_account_field() as the source
of user/sys times for cpuacct.usage* files. Make cpuacct_charge()
to account only summary execution time.

Fixes: d740037fac70 ("sched/cpuacct: Split usage accounting into user_usage and sys_usage")
	Signed-off-by: Andrey Ryabinin <arbn@yandex-team.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/20211115164607.23784-3-arbn@yandex-team.com
(cherry picked from commit dd02d4234c9a2214a81c57a16484304a1a51872a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/cpuacct.c
diff --cc kernel/sched/cpuacct.c
index a96e8f6e6f19,9de7dd51beb0..000000000000
--- a/kernel/sched/cpuacct.c
+++ b/kernel/sched/cpuacct.c
@@@ -113,17 -110,20 +110,20 @@@ static u64 cpuacct_cpuusage_read(struc
  	/*
  	 * Take rq->lock to make 64-bit read safe on 32-bit platforms.
  	 */
 -	raw_spin_rq_lock_irq(cpu_rq(cpu));
 +	raw_spin_lock_irq(&cpu_rq(cpu)->lock);
  #endif
  
- 	if (index == CPUACCT_STAT_NSTATS) {
- 		int i = 0;
- 
- 		data = 0;
- 		for (i = 0; i < CPUACCT_STAT_NSTATS; i++)
- 			data += cpuusage->usages[i];
- 	} else {
- 		data = cpuusage->usages[index];
+ 	switch (index) {
+ 	case CPUACCT_STAT_USER:
+ 		data = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];
+ 		break;
+ 	case CPUACCT_STAT_SYSTEM:
+ 		data = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +
+ 			cpustat[CPUTIME_SOFTIRQ];
+ 		break;
+ 	case CPUACCT_STAT_NSTATS:
+ 		data = *cpuusage;
+ 		break;
  	}
  
  #ifndef CONFIG_64BIT
@@@ -142,14 -146,15 +146,15 @@@ static void cpuacct_cpuusage_write(stru
  	/*
  	 * Take rq->lock to make 64-bit write safe on 32-bit platforms.
  	 */
 -	raw_spin_rq_lock_irq(cpu_rq(cpu));
 +	raw_spin_lock_irq(&cpu_rq(cpu)->lock);
  #endif
- 
- 	for (i = 0; i < CPUACCT_STAT_NSTATS; i++)
- 		cpuusage->usages[i] = val;
+ 	*cpuusage = 0;
+ 	cpustat[CPUTIME_USER] = cpustat[CPUTIME_NICE] = 0;
+ 	cpustat[CPUTIME_SYSTEM] = cpustat[CPUTIME_IRQ] = 0;
+ 	cpustat[CPUTIME_SOFTIRQ] = 0;
  
  #ifndef CONFIG_64BIT
 -	raw_spin_rq_unlock_irq(cpu_rq(cpu));
 +	raw_spin_unlock_irq(&cpu_rq(cpu)->lock);
  #endif
  }
  
@@@ -244,25 -249,10 +249,29 @@@ static int cpuacct_all_seq_show(struct 
  	seq_puts(m, "\n");
  
  	for_each_possible_cpu(cpu) {
- 		struct cpuacct_usage *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);
- 
  		seq_printf(m, "%d", cpu);
++<<<<<<< HEAD
 +
 +		for (index = 0; index < CPUACCT_STAT_NSTATS; index++) {
 +#ifndef CONFIG_64BIT
 +			/*
 +			 * Take rq->lock to make 64-bit read safe on 32-bit
 +			 * platforms.
 +			 */
 +			raw_spin_lock_irq(&cpu_rq(cpu)->lock);
 +#endif
 +
 +			seq_printf(m, " %llu", cpuusage->usages[index]);
 +
 +#ifndef CONFIG_64BIT
 +			raw_spin_unlock_irq(&cpu_rq(cpu)->lock);
 +#endif
 +		}
++=======
+ 		for (index = 0; index < CPUACCT_STAT_NSTATS; index++)
+ 			seq_printf(m, " %llu",
+ 				   cpuacct_cpuusage_read(ca, cpu, index));
++>>>>>>> dd02d4234c9a (sched/cpuacct: Fix user/system in shown cpuacct.usage*)
  		seq_puts(m, "\n");
  	}
  	return 0;
* Unmerged path kernel/sched/cpuacct.c
