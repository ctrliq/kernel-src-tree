xfs: move the di_forkoff field to struct xfs_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 7821ea302dca72469c558e382d6e4ae09232b7a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/7821ea30.failed

In preparation of removing the historic icinode struct, move the
forkoff field into the containing xfs_inode structure.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 7821ea302dca72469c558e382d6e4ae09232b7a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_inode_buf.h
#	fs/xfs/xfs_icache.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_inode.h
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 671aeb012e3f,df16b05e60c4..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -226,10 -227,10 +226,17 @@@ xfs_inode_from_disk
  	inode->i_mtime = xfs_inode_from_disk_ts(from, from->di_mtime);
  	inode->i_ctime = xfs_inode_from_disk_ts(from, from->di_ctime);
  
++<<<<<<< HEAD
 +	to->di_size = be64_to_cpu(from->di_size);
 +	to->di_nblocks = be64_to_cpu(from->di_nblocks);
 +	to->di_extsize = be32_to_cpu(from->di_extsize);
 +	to->di_forkoff = from->di_forkoff;
++=======
+ 	ip->i_disk_size = be64_to_cpu(from->di_size);
+ 	ip->i_nblocks = be64_to_cpu(from->di_nblocks);
+ 	ip->i_extsize = be32_to_cpu(from->di_extsize);
+ 	ip->i_forkoff = from->di_forkoff;
++>>>>>>> 7821ea302dca (xfs: move the di_forkoff field to struct xfs_inode)
  	to->di_flags	= be16_to_cpu(from->di_flags);
  
  	if (from->di_dmevmask || from->di_dmstate)
@@@ -305,12 -306,12 +312,12 @@@ xfs_inode_to_disk
  	to->di_gen = cpu_to_be32(inode->i_generation);
  	to->di_mode = cpu_to_be16(inode->i_mode);
  
 -	to->di_size = cpu_to_be64(ip->i_disk_size);
 -	to->di_nblocks = cpu_to_be64(ip->i_nblocks);
 -	to->di_extsize = cpu_to_be32(ip->i_extsize);
 +	to->di_size = cpu_to_be64(from->di_size);
 +	to->di_nblocks = cpu_to_be64(from->di_nblocks);
 +	to->di_extsize = cpu_to_be32(from->di_extsize);
  	to->di_nextents = cpu_to_be32(xfs_ifork_nextents(&ip->i_df));
  	to->di_anextents = cpu_to_be16(xfs_ifork_nextents(ip->i_afp));
- 	to->di_forkoff = from->di_forkoff;
+ 	to->di_forkoff = ip->i_forkoff;
  	to->di_aformat = xfs_ifork_format(ip->i_afp);
  	to->di_flags = cpu_to_be16(from->di_flags);
  
diff --cc fs/xfs/libxfs/xfs_inode_buf.h
index 406f66799288,39f4ad4419fe..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.h
+++ b/fs/xfs/libxfs/xfs_inode_buf.h
@@@ -16,11 -16,6 +16,14 @@@ struct xfs_dinode
   * format specific structures at the appropriate time.
   */
  struct xfs_icdinode {
++<<<<<<< HEAD
 +	uint16_t	di_flushiter;	/* incremented on flush */
 +	xfs_fsize_t	di_size;	/* number of bytes in file */
 +	xfs_rfsblock_t	di_nblocks;	/* # of direct & btree blocks used */
 +	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
 +	uint8_t		di_forkoff;	/* attr fork offs, <<3 for 64b align */
++=======
++>>>>>>> 7821ea302dca (xfs: move the di_forkoff field to struct xfs_inode)
  	uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
  
  	uint64_t	di_flags2;	/* more random flags */
diff --cc fs/xfs/xfs_icache.c
index 7ea1c183137f,ee8cb3844fdf..000000000000
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@@ -65,8 -64,8 +65,13 @@@ xfs_inode_alloc
  	ip->i_flags = 0;
  	ip->i_delayed_blks = 0;
  	ip->i_d.di_flags2 = mp->m_ino_geo.new_diflags2;
++<<<<<<< HEAD
 +	ip->i_d.di_nblocks = 0;
 +	ip->i_d.di_forkoff = 0;
++=======
+ 	ip->i_nblocks = 0;
+ 	ip->i_forkoff = 0;
++>>>>>>> 7821ea302dca (xfs: move the di_forkoff field to struct xfs_inode)
  	ip->i_sick = 0;
  	ip->i_checked = 0;
  	INIT_WORK(&ip->i_ioend_work, xfs_end_io);
diff --cc fs/xfs/xfs_inode.c
index d856a2225b9c,3e53235bea2a..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -873,6 -876,20 +873,23 @@@ xfs_init_new_inode
  	}
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * If we need to create attributes immediately after allocating the
+ 	 * inode, initialise an empty attribute fork right now. We use the
+ 	 * default fork offset for attributes here as we don't know exactly what
+ 	 * size or how many attributes we might be adding. We can do this
+ 	 * safely here because we know the data fork is completely empty and
+ 	 * this saves us from needing to run a separate transaction to set the
+ 	 * fork offset in the immediate future.
+ 	 */
+ 	if (init_xattrs) {
+ 		ip->i_forkoff = xfs_default_attroffset(ip) >> 3;
+ 		ip->i_afp = xfs_ifork_alloc(XFS_DINODE_FMT_EXTENTS, 0);
+ 	}
+ 
+ 	/*
++>>>>>>> 7821ea302dca (xfs: move the di_forkoff field to struct xfs_inode)
  	 * Log the new values stuffed into the inode.
  	 */
  	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
@@@ -3412,10 -3442,10 +3429,10 @@@ xfs_iflush
  			"total extents = %d, nblocks = %Ld, ptr "PTR_FMT,
  			__func__, ip->i_ino,
  			ip->i_df.if_nextents + xfs_ifork_nextents(ip->i_afp),
 -			ip->i_nblocks, ip);
 +			ip->i_d.di_nblocks, ip);
  		goto flush_out;
  	}
- 	if (XFS_TEST_ERROR(ip->i_d.di_forkoff > mp->m_sb.sb_inodesize,
+ 	if (XFS_TEST_ERROR(ip->i_forkoff > mp->m_sb.sb_inodesize,
  				mp, XFS_ERRTAG_IFLUSH_6)) {
  		xfs_alert_tag(mp, XFS_PTAG_IFLUSH,
  			"%s: bad inode %Lu, forkoff 0x%x, ptr "PTR_FMT,
diff --cc fs/xfs/xfs_inode.h
index ab59fceed361,5e16098bdbcf..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -54,7 -54,16 +54,17 @@@ typedef struct xfs_inode 
  	/* Miscellaneous state. */
  	unsigned long		i_flags;	/* see defined flags below */
  	uint64_t		i_delayed_blks;	/* count of delay alloc blks */
 -	xfs_fsize_t		i_disk_size;	/* number of bytes in file */
 -	xfs_rfsblock_t		i_nblocks;	/* # of direct & btree blocks */
  	prid_t			i_projid;	/* owner's project id */
++<<<<<<< HEAD
++=======
+ 	xfs_extlen_t		i_extsize;	/* basic/minimum extent size */
+ 	/* cowextsize is only used for v3 inodes, flushiter for v1/2 */
+ 	union {
+ 		xfs_extlen_t	i_cowextsize;	/* basic cow extent size */
+ 		uint16_t	i_flushiter;	/* incremented on flush */
+ 	};
+ 	uint8_t			i_forkoff;	/* attr fork offset >> 3 */
++>>>>>>> 7821ea302dca (xfs: move the di_forkoff field to struct xfs_inode)
  
  	struct xfs_icdinode	i_d;		/* most of ondisk inode */
  
diff --git a/fs/xfs/libxfs/xfs_attr_leaf.c b/fs/xfs/libxfs/xfs_attr_leaf.c
index d6ef69ab1c67..23e2bf3341a0 100644
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@ -518,10 +518,10 @@ xfs_attr_copy_value(
  * Query whether the total requested number of attr fork bytes of extended
  * attribute space will be able to fit inline.
  *
- * Returns zero if not, else the di_forkoff fork offset to be used in the
+ * Returns zero if not, else the i_forkoff fork offset to be used in the
  * literal area for attribute data once the new bytes have been added.
  *
- * di_forkoff must be 8 byte aligned, hence is stored as a >>3 value;
+ * i_forkoff must be 8 byte aligned, hence is stored as a >>3 value;
  * special case for dev/uuid inodes, they have fixed size data forks.
  */
 int
@@ -560,7 +560,7 @@ xfs_attr_shortform_bytesfit(
 	 * literal area rebalancing.
 	 */
 	if (bytes <= XFS_IFORK_ASIZE(dp))
-		return dp->i_d.di_forkoff;
+		return dp->i_forkoff;
 
 	/*
 	 * For attr2 we can try to move the forkoff if there is space in the
@@ -581,7 +581,7 @@ xfs_attr_shortform_bytesfit(
 		 * minimum offset only needs to be the space required for
 		 * the btree root.
 		 */
-		if (!dp->i_d.di_forkoff && dp->i_df.if_bytes >
+		if (!dp->i_forkoff && dp->i_df.if_bytes >
 		    xfs_default_attroffset(dp))
 			dsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);
 		break;
@@ -592,10 +592,10 @@ xfs_attr_shortform_bytesfit(
 		 * minforkoff to where the btree root can finish so we have
 		 * plenty of room for attrs
 		 */
-		if (dp->i_d.di_forkoff) {
-			if (offset < dp->i_d.di_forkoff)
+		if (dp->i_forkoff) {
+			if (offset < dp->i_forkoff)
 				return 0;
-			return dp->i_d.di_forkoff;
+			return dp->i_forkoff;
 		}
 		dsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);
 		break;
@@ -730,7 +730,7 @@ xfs_attr_shortform_add(
 
 	dp = args->dp;
 	mp = dp->i_mount;
-	dp->i_d.di_forkoff = forkoff;
+	dp->i_forkoff = forkoff;
 
 	ifp = dp->i_afp;
 	ASSERT(ifp->if_flags & XFS_IFINLINE);
@@ -770,7 +770,7 @@ xfs_attr_fork_remove(
 	xfs_idestroy_fork(ip->i_afp);
 	kmem_cache_free(xfs_ifork_zone, ip->i_afp);
 	ip->i_afp = NULL;
-	ip->i_d.di_forkoff = 0;
+	ip->i_forkoff = 0;
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 }
 
@@ -821,8 +821,8 @@ xfs_attr_shortform_remove(
 		xfs_attr_fork_remove(dp, args->trans);
 	} else {
 		xfs_idata_realloc(dp, -size, XFS_ATTR_FORK);
-		dp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);
-		ASSERT(dp->i_d.di_forkoff);
+		dp->i_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);
+		ASSERT(dp->i_forkoff);
 		ASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||
 				(args->op_flags & XFS_DA_OP_ADDNAME) ||
 				!(mp->m_flags & XFS_MOUNT_ATTR2) ||
diff --git a/fs/xfs/libxfs/xfs_bmap.c b/fs/xfs/libxfs/xfs_bmap.c
index 09b89e8dc50f..fe335dc5945a 100644
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@ -66,13 +66,13 @@ xfs_bmap_compute_maxlevels(
 	 * either a signed 32-bit number for the data fork, or a signed 16-bit
 	 * number for the attr fork.
 	 *
-	 * Note that we can no longer assume that if we are in ATTR1 that
-	 * the fork offset of all the inodes will be
-	 * (xfs_default_attroffset(ip) >> 3) because we could have mounted
-	 * with ATTR2 and then mounted back with ATTR1, keeping the
-	 * di_forkoff's fixed but probably at various positions. Therefore,
-	 * for both ATTR1 and ATTR2 we have to assume the worst case scenario
-	 * of a minimum size available.
+	 * Note that we can no longer assume that if we are in ATTR1 that the
+	 * fork offset of all the inodes will be
+	 * (xfs_default_attroffset(ip) >> 3) because we could have mounted with
+	 * ATTR2 and then mounted back with ATTR1, keeping the i_forkoff's fixed
+	 * but probably at various positions. Therefore, for both ATTR1 and
+	 * ATTR2 we have to assume the worst case scenario of a minimum size
+	 * available.
 	 */
 	if (whichfork == XFS_DATA_FORK) {
 		maxleafents = MAXEXTNUM;
@@ -205,9 +205,9 @@ xfs_default_attroffset(
 }
 
 /*
- * Helper routine to reset inode di_forkoff field when switching
- * attribute fork from local to extent format - we reset it where
- * possible to make space available for inline data fork extents.
+ * Helper routine to reset inode i_forkoff field when switching attribute fork
+ * from local to extent format - we reset it where possible to make space
+ * available for inline data fork extents.
  */
 STATIC void
 xfs_bmap_forkoff_reset(
@@ -219,8 +219,8 @@ xfs_bmap_forkoff_reset(
 	    ip->i_df.if_format != XFS_DINODE_FMT_BTREE) {
 		uint	dfl_forkoff = xfs_default_attroffset(ip) >> 3;
 
-		if (dfl_forkoff > ip->i_d.di_forkoff)
-			ip->i_d.di_forkoff = dfl_forkoff;
+		if (dfl_forkoff > ip->i_forkoff)
+			ip->i_forkoff = dfl_forkoff;
 	}
 }
 
@@ -1036,14 +1036,14 @@ xfs_bmap_set_attrforkoff(
 {
 	switch (ip->i_df.if_format) {
 	case XFS_DINODE_FMT_DEV:
-		ip->i_d.di_forkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;
+		ip->i_forkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;
 		break;
 	case XFS_DINODE_FMT_LOCAL:
 	case XFS_DINODE_FMT_EXTENTS:
 	case XFS_DINODE_FMT_BTREE:
-		ip->i_d.di_forkoff = xfs_attr_shortform_bytesfit(ip, size);
-		if (!ip->i_d.di_forkoff)
-			ip->i_d.di_forkoff = xfs_default_attroffset(ip) >> 3;
+		ip->i_forkoff = xfs_attr_shortform_bytesfit(ip, size);
+		if (!ip->i_forkoff)
+			ip->i_forkoff = xfs_default_attroffset(ip) >> 3;
 		else if ((ip->i_mount->m_flags & XFS_MOUNT_ATTR2) && version)
 			*version = 2;
 		break;
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.h
diff --git a/fs/xfs/libxfs/xfs_inode_fork.h b/fs/xfs/libxfs/xfs_inode_fork.h
index 9e2137cd7372..115841c0f532 100644
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@ -99,8 +99,8 @@ struct xfs_ifork {
  * Fork handling.
  */
 
-#define XFS_IFORK_Q(ip)			((ip)->i_d.di_forkoff != 0)
-#define XFS_IFORK_BOFF(ip)		((int)((ip)->i_d.di_forkoff << 3))
+#define XFS_IFORK_Q(ip)			((ip)->i_forkoff != 0)
+#define XFS_IFORK_BOFF(ip)		((int)((ip)->i_forkoff << 3))
 
 #define XFS_IFORK_PTR(ip,w)		\
 	((w) == XFS_DATA_FORK ? \
* Unmerged path fs/xfs/xfs_icache.c
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_inode.h
diff --git a/fs/xfs/xfs_inode_item.c b/fs/xfs/xfs_inode_item.c
index 342023fbc07e..f44868d345c4 100644
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@ -388,7 +388,7 @@ xfs_inode_to_log_dinode(
 	to->di_extsize = from->di_extsize;
 	to->di_nextents = xfs_ifork_nextents(&ip->i_df);
 	to->di_anextents = xfs_ifork_nextents(ip->i_afp);
-	to->di_forkoff = from->di_forkoff;
+	to->di_forkoff = ip->i_forkoff;
 	to->di_aformat = xfs_ifork_format(ip->i_afp);
 	to->di_flags = from->di_flags;
 
