NFSD: Replace READ* macros in nfsd4_decode_fattr()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit d1c263a031e876ac3ca5223c728e4d98ed50b3c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/d1c263a0.failed

Let's be more careful to avoid overrunning the memory that backs
the bitmap array. This requires updating the synopsis of
nfsd4_decode_fattr().

Bruce points out that a server needs to be careful to return nfs_ok
when a client presents bitmap bits the server doesn't support. This
includes bits in bitmap words the server might not yet support.

The current READ* based implementation is good about that, but that
requirement hasn't been documented.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit d1c263a031e876ac3ca5223c728e4d98ed50b3c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 148fec779d69,180769337d54..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -373,20 -260,150 +373,161 @@@ nfsd4_decode_bitmap(struct nfsd4_compou
  	DECODE_TAIL;
  }
  
+ /**
+  * nfsd4_decode_bitmap4 - Decode an NFSv4 bitmap4
+  * @argp: NFSv4 compound argument structure
+  * @bmval: pointer to an array of u32's to decode into
+  * @bmlen: size of the @bmval array
+  *
+  * The server needs to return nfs_ok rather than nfserr_bad_xdr when
+  * encountering bitmaps containing bits it does not recognize. This
+  * includes bits in bitmap words past WORDn, where WORDn is the last
+  * bitmap WORD the implementation currently supports. Thus we are
+  * careful here to simply ignore bits in bitmap words that this
+  * implementation has yet to support explicitly.
+  *
+  * Return values:
+  *   %nfs_ok: @bmval populated successfully
+  *   %nfserr_bad_xdr: the encoded bitmap was invalid
+  */
+ static __be32
+ nfsd4_decode_bitmap4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen)
+ {
+ 	u32 i, count;
+ 	__be32 *p;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 	/* request sanity */
+ 	if (count > 1000)
+ 		return nfserr_bad_xdr;
+ 	p = xdr_inline_decode(argp->xdr, count << 2);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	i = 0;
+ 	while (i < count)
+ 		bmval[i++] = be32_to_cpup(p++);
+ 	while (i < bmlen)
+ 		bmval[i++] = 0;
+ 
+ 	return nfs_ok;
+ }
+ 
  static __be32
++<<<<<<< HEAD
 +nfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,
 +		   struct iattr *iattr, struct nfs4_acl **acl,
 +		   struct xdr_netobj *label, int *umask)
 +{
 +	unsigned int starting_pos;
 +	u32 attrlist4_count;
 +	u32 dummy32;
 +	char *buf;
++=======
+ nfsd4_decode_nfsace4(struct nfsd4_compoundargs *argp, struct nfs4_ace *ace)
+ {
+ 	__be32 *p, status;
+ 	u32 length;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &ace->type) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &ace->flag) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &ace->access_mask) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
+ 		return nfserr_bad_xdr;
+ 	p = xdr_inline_decode(argp->xdr, length);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	ace->whotype = nfs4_acl_get_whotype((char *)p, length);
+ 	if (ace->whotype != NFS4_ACL_WHO_NAMED)
+ 		status = nfs_ok;
+ 	else if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)
+ 		status = nfsd_map_name_to_gid(argp->rqstp,
+ 				(char *)p, length, &ace->who_gid);
+ 	else
+ 		status = nfsd_map_name_to_uid(argp->rqstp,
+ 				(char *)p, length, &ace->who_uid);
+ 
+ 	return status;
+ }
+ 
+ /* A counted array of nfsace4's */
+ static noinline __be32
+ nfsd4_decode_acl(struct nfsd4_compoundargs *argp, struct nfs4_acl **acl)
+ {
+ 	struct nfs4_ace *ace;
+ 	__be32 status;
+ 	u32 count;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (count > xdr_stream_remaining(argp->xdr) / 20)
+ 		/*
+ 		 * Even with 4-byte names there wouldn't be
+ 		 * space for that many aces; something fishy is
+ 		 * going on:
+ 		 */
+ 		return nfserr_fbig;
+ 
+ 	*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(count));
+ 	if (*acl == NULL)
+ 		return nfserr_jukebox;
+ 
+ 	(*acl)->naces = count;
+ 	for (ace = (*acl)->aces; ace < (*acl)->aces + count; ace++) {
+ 		status = nfsd4_decode_nfsace4(argp, ace);
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ static noinline __be32
+ nfsd4_decode_security_label(struct nfsd4_compoundargs *argp,
+ 			    struct xdr_netobj *label)
+ {
+ 	u32 lfs, pi, length;
+ 	__be32 *p;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &lfs) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &pi) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (length > NFS4_MAXLABELLEN)
+ 		return nfserr_badlabel;
+ 	p = xdr_inline_decode(argp->xdr, length);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	label->len = length;
+ 	label->data = svcxdr_dupstr(argp, p, length);
+ 	if (!label->data)
+ 		return nfserr_jukebox;
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_fattr4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen,
+ 		    struct iattr *iattr, struct nfs4_acl **acl,
+ 		    struct xdr_netobj *label, int *umask)
+ {
+ 	unsigned int starting_pos;
+ 	u32 attrlist4_count;
+ 	__be32 *p, status;
++>>>>>>> d1c263a031e8 (NFSD: Replace READ* macros in nfsd4_decode_fattr())
  
- 	DECODE_HEAD;
  	iattr->ia_valid = 0;
- 	if ((status = nfsd4_decode_bitmap(argp, bmval)))
- 		return status;
+ 	status = nfsd4_decode_bitmap4(argp, bmval, bmlen);
+ 	if (status)
+ 		return nfserr_bad_xdr;
  
  	if (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0
  	    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1
* Unmerged path fs/nfsd/nfs4xdr.c
