arm64: Fix PTRACE_SYSEMU semantics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Keno Fischer <keno@juliacomputing.com>
commit 1cf6022bd9161081215028203919c33fcfa6debb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/1cf6022b.failed

Quoth the man page:
```
       If the tracee was restarted by PTRACE_SYSCALL or PTRACE_SYSEMU, the
       tracee enters syscall-enter-stop just prior to entering any system
       call (which will not be executed if the restart was using
       PTRACE_SYSEMU, regardless of any change made to registers at this
       point or how the tracee is restarted after this stop).
```

The parenthetical comment is currently true on x86 and powerpc,
but not currently true on arm64. arm64 re-checks the _TIF_SYSCALL_EMU
flag after the syscall entry ptrace stop. However, at this point,
it reflects which method was used to re-start the syscall
at the entry stop, rather than the method that was used to reach it.
Fix that by recording the original flag before performing the ptrace
stop, bringing the behavior in line with documentation and x86/powerpc.

Fixes: f086f67485c5 ("arm64: ptrace: add support for syscall emulation")
	Cc: <stable@vger.kernel.org> # 5.3.x-
	Signed-off-by: Keno Fischer <keno@juliacomputing.com>
	Acked-by: Will Deacon <will@kernel.org>
	Tested-by: Sudeep Holla <sudeep.holla@arm.com>
	Tested-by: Bin Lu <Bin.Lu@arm.com>
[catalin.marinas@arm.com: moved 'flags' bit masking]
[catalin.marinas@arm.com: changed 'flags' type to unsigned long]
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 1cf6022bd9161081215028203919c33fcfa6debb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/ptrace.c
diff --cc arch/arm64/kernel/ptrace.c
index e7125cb2c489,e7b01904f180..000000000000
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@@ -1717,11 -1829,16 +1717,21 @@@ static void tracehook_report_syscall(st
  
  int syscall_trace_enter(struct pt_regs *regs)
  {
++<<<<<<< HEAD
 +	if (test_thread_flag(TIF_SYSCALL_TRACE))
 +		tracehook_report_syscall(regs, PTRACE_SYSCALL_ENTER);
++=======
+ 	unsigned long flags = READ_ONCE(current_thread_info()->flags);
+ 
+ 	if (flags & (_TIF_SYSCALL_EMU | _TIF_SYSCALL_TRACE)) {
+ 		tracehook_report_syscall(regs, PTRACE_SYSCALL_ENTER);
+ 		if (!in_syscall(regs) || (flags & _TIF_SYSCALL_EMU))
+ 			return -1;
+ 	}
++>>>>>>> 1cf6022bd916 (arm64: Fix PTRACE_SYSEMU semantics)
  
  	/* Do the secure computing after ptrace; failures should be fast. */
 -	if (secure_computing() == -1)
 +	if (secure_computing(NULL) == -1)
  		return -1;
  
  	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
* Unmerged path arch/arm64/kernel/ptrace.c
