NFSD: Update READDIR3args decoders to use struct xdr_stream

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 9cedc2e64c296efb3bebe93a0ceeb5e71e8d722d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/9cedc2e6.failed

As an additional clean up, neither nfsd3_proc_readdir() nor
nfsd3_proc_readdirplus() make use of the dircount argument, so
remove it from struct nfsd3_readdirargs.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 9cedc2e64c296efb3bebe93a0ceeb5e71e8d722d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3xdr.c
diff --cc fs/nfsd/nfs3xdr.c
index 10cec0d1df59,eb55be106a04..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -553,53 -559,43 +553,77 @@@ nfs3svc_decode_linkargs(struct svc_rqs
  int
  nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p)
  {
+ 	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_readdirargs *args = rqstp->rq_argp;
 +	int len;
 +	u32 max_blocksize = svc_max_payload(rqstp);
  
- 	p = decode_fh(p, &args->fh);
- 	if (!p)
+ 	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
+ 		return 0;
+ 	if (xdr_stream_decode_u64(xdr, &args->cookie) < 0)
+ 		return 0;
+ 	args->verf = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);
+ 	if (!args->verf)
  		return 0;
+ 	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
+ 		return 0;
++<<<<<<< HEAD
 +	p = xdr_decode_hyper(p, &args->cookie);
 +	args->verf   = p; p += 2;
 +	args->dircount = ~0;
 +	args->count  = ntohl(*p++);
 +	len = args->count  = min_t(u32, args->count, max_blocksize);
 +
 +	while (len > 0) {
 +		struct page *p = *(rqstp->rq_next_page++);
 +		if (!args->buffer)
 +			args->buffer = page_address(p);
 +		len -= PAGE_SIZE;
 +	}
++=======
++>>>>>>> 9cedc2e64c29 (NFSD: Update READDIR3args decoders to use struct xdr_stream)
  
- 	return xdr_argsize_check(rqstp, p);
+ 	return 1;
  }
  
  int
  nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p)
  {
+ 	struct xdr_stream *xdr = &rqstp->rq_arg_stream;
  	struct nfsd3_readdirargs *args = rqstp->rq_argp;
++<<<<<<< HEAD
 +	int len;
 +	u32 max_blocksize = svc_max_payload(rqstp);
++=======
+ 	u32 dircount;
++>>>>>>> 9cedc2e64c29 (NFSD: Update READDIR3args decoders to use struct xdr_stream)
  
- 	p = decode_fh(p, &args->fh);
- 	if (!p)
+ 	if (!svcxdr_decode_nfs_fh3(xdr, &args->fh))
+ 		return 0;
+ 	if (xdr_stream_decode_u64(xdr, &args->cookie) < 0)
+ 		return 0;
+ 	args->verf = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);
+ 	if (!args->verf)
+ 		return 0;
+ 	/* dircount is ignored */
+ 	if (xdr_stream_decode_u32(xdr, &dircount) < 0)
+ 		return 0;
+ 	if (xdr_stream_decode_u32(xdr, &args->count) < 0)
  		return 0;
- 	p = xdr_decode_hyper(p, &args->cookie);
- 	args->verf     = p; p += 2;
- 	args->dircount = ntohl(*p++);
- 	args->count    = ntohl(*p++);
  
++<<<<<<< HEAD
 +	len = args->count = min(args->count, max_blocksize);
 +	while (len > 0) {
 +		struct page *p = *(rqstp->rq_next_page++);
 +		if (!args->buffer)
 +			args->buffer = page_address(p);
 +		len -= PAGE_SIZE;
 +	}
 +
 +	return xdr_argsize_check(rqstp, p);
++=======
+ 	return 1;
++>>>>>>> 9cedc2e64c29 (NFSD: Update READDIR3args decoders to use struct xdr_stream)
  }
  
  int
* Unmerged path fs/nfsd/nfs3xdr.c
diff --git a/fs/nfsd/xdr3.h b/fs/nfsd/xdr3.h
index c1b61c7ed463..08f777cd14d8 100644
--- a/fs/nfsd/xdr3.h
+++ b/fs/nfsd/xdr3.h
@@ -90,7 +90,6 @@ struct nfsd3_symlinkargs {
 struct nfsd3_readdirargs {
 	struct svc_fh		fh;
 	__u64			cookie;
-	__u32			dircount;
 	__u32			count;
 	__be32 *		verf;
 	__be32 *		buffer;
