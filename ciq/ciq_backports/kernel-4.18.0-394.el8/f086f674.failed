arm64: ptrace: add support for syscall emulation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Sudeep Holla <sudeep.holla@arm.com>
commit f086f67485c5c126bcec4b0e96ac7319a2e59ab8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/f086f674.failed

Add PTRACE_SYSEMU and PTRACE_SYSEMU_SINGLESTEP support on arm64.
We don't need any special handling for PTRACE_SYSEMU_SINGLESTEP.

It's quite difficult to generalize handling PTRACE_SYSEMU cross
architectures and avoid calls to tracehook_report_syscall_entry twice.
Different architecture have different mechanism to indicate NO_SYSCALL
and trying to generalise adds more code for no gain.

	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit f086f67485c5c126bcec4b0e96ac7319a2e59ab8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/thread_info.h
diff --cc arch/arm64/include/asm/thread_info.h
index f1d032be628a,c285d1ce7186..000000000000
--- a/arch/arm64/include/asm/thread_info.h
+++ b/arch/arm64/include/asm/thread_info.h
@@@ -75,7 -75,8 +75,12 @@@ void arch_release_task_struct(struct ta
   *  TIF_SYSCALL_TRACE	- syscall trace active
   *  TIF_SYSCALL_TRACEPOINT - syscall tracepoint for ftrace
   *  TIF_SYSCALL_AUDIT	- syscall auditing
++<<<<<<< HEAD
 + *  TIF_SECCOMP		- syscall secure computing
++=======
+  *  TIF_SYSCALL_EMU     - syscall emulation active
+  *  TIF_SECOMP		- syscall secure computing
++>>>>>>> f086f67485c5 (arm64: ptrace: add support for syscall emulation)
   *  TIF_SIGPENDING	- signal pending
   *  TIF_NEED_RESCHED	- rescheduling necessary
   *  TIF_NOTIFY_RESUME	- callback before returning to user
* Unmerged path arch/arm64/include/asm/thread_info.h
diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
index 7b9fce444faf..0206ed3de3d3 100644
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@ -1717,8 +1717,12 @@ static void tracehook_report_syscall(struct pt_regs *regs,
 
 int syscall_trace_enter(struct pt_regs *regs)
 {
-	if (test_thread_flag(TIF_SYSCALL_TRACE))
+	if (test_thread_flag(TIF_SYSCALL_TRACE) ||
+		test_thread_flag(TIF_SYSCALL_EMU)) {
 		tracehook_report_syscall(regs, PTRACE_SYSCALL_ENTER);
+		if (!in_syscall(regs) || test_thread_flag(TIF_SYSCALL_EMU))
+			return -1;
+	}
 
 	/* Do the secure computing after ptrace; failures should be fast. */
 	if (secure_computing(NULL) == -1)
