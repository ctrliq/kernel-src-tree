NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit f5dcccd647da513a89f3b6ca392b0c1eb050b9fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/f5dcccd6.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit f5dcccd647da513a89f3b6ca392b0c1eb050b9fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfsproc.c
#	fs/nfsd/nfsxdr.c
#	fs/nfsd/xdr.h
diff --cc fs/nfsd/nfsproc.c
index ac1e929b2596,86d438fbd576..000000000000
--- a/fs/nfsd/nfsproc.c
+++ b/fs/nfsd/nfsproc.c
@@@ -555,6 -555,33 +555,36 @@@ nfsd_proc_rmdir(struct svc_rqst *rqstp
  	return rpc_success;
  }
  
++<<<<<<< HEAD
++=======
+ static void nfsd_init_dirlist_pages(struct svc_rqst *rqstp,
+ 				    struct nfsd_readdirres *resp,
+ 				    int count)
+ {
+ 	struct xdr_buf *buf = &resp->dirlist;
+ 	struct xdr_stream *xdr = &resp->xdr;
+ 
+ 	count = min_t(u32, count, PAGE_SIZE);
+ 
+ 	memset(buf, 0, sizeof(*buf));
+ 
+ 	/* Reserve room for the NULL ptr & eof flag (-2 words) */
+ 	buf->buflen = count - sizeof(__be32) * 2;
+ 	buf->pages = rqstp->rq_next_page;
+ 	rqstp->rq_next_page++;
+ 
+ 	/* This is xdr_init_encode(), but it assumes that
+ 	 * the head kvec has already been consumed. */
+ 	xdr_set_scratch_buffer(xdr, NULL, 0);
+ 	xdr->buf = buf;
+ 	xdr->page_ptr = buf->pages;
+ 	xdr->iov = NULL;
+ 	xdr->p = page_address(*buf->pages);
+ 	xdr->end = xdr->p + (PAGE_SIZE >> 2);
+ 	xdr->rqst = NULL;
+ }
+ 
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  /*
   * Read a portion of a directory.
   */
@@@ -570,26 -596,14 +600,34 @@@ nfsd_proc_readdir(struct svc_rqst *rqst
  		SVCFH_fmt(&argp->fh),		
  		argp->count, argp->cookie);
  
 -	nfsd_init_dirlist_pages(rqstp, resp, argp->count);
 +	/* Shrink to the client read size */
 +	count = (argp->count >> 2) - 2;
  
++<<<<<<< HEAD
 +	/* Make sure we've room for the NULL ptr & eof flag */
 +	count -= 2;
 +	if (count < 0)
 +		count = 0;
 +
 +	resp->buffer = argp->buffer;
 +	resp->offset = NULL;
 +	resp->buflen = count;
++=======
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  	resp->common.err = nfs_ok;
- 	/* Read directory and encode entries on the fly */
+ 	resp->cookie_offset = 0;
  	offset = argp->cookie;
  	resp->status = nfsd_readdir(rqstp, &argp->fh, &offset,
++<<<<<<< HEAD
 +				    &resp->common, nfssvc_encode_entry);
 +
 +	resp->count = resp->buffer - argp->buffer;
 +	if (resp->offset)
 +		*resp->offset = htonl(offset);
++=======
+ 				    &resp->common, nfs2svc_encode_entry);
+ 	nfssvc_encode_nfscookie(resp, offset);
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  
  	fh_put(&argp->fh);
  	return rpc_success;
diff --cc fs/nfsd/nfsxdr.c
index 0d6a28d055ec,1102d40ded03..000000000000
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@@ -572,17 -574,22 +572,33 @@@ nfssvc_encode_readres(struct svc_rqst *
  int
  nfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p)
  {
 -	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_readdirres *resp = rqstp->rq_resp;
+ 	struct xdr_buf *dirlist = &resp->dirlist;
  
++<<<<<<< HEAD
 +	*p++ = resp->status;
 +	if (resp->status != nfs_ok)
 +		return xdr_ressize_check(rqstp, p);
 +
 +	xdr_ressize_check(rqstp, p);
 +	p = resp->buffer;
 +	*p++ = 0;			/* no more entries */
 +	*p++ = htonl((resp->common.err == nfserr_eof));
 +	rqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;
++=======
+ 	if (!svcxdr_encode_stat(xdr, resp->status))
+ 		return 0;
+ 	switch (resp->status) {
+ 	case nfs_ok:
+ 		xdr_write_pages(xdr, dirlist->pages, 0, dirlist->len);
+ 		/* no more entries */
+ 		if (xdr_stream_encode_item_absent(xdr) < 0)
+ 			return 0;
+ 		if (xdr_stream_encode_bool(xdr, resp->common.err == nfserr_eof) < 0)
+ 			return 0;
+ 		break;
+ 	}
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  
  	return 1;
  }
@@@ -612,6 -619,93 +628,96 @@@ nfssvc_encode_statfsres(struct svc_rqs
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * nfssvc_encode_nfscookie - Encode a directory offset cookie
+  * @resp: readdir result context
+  * @offset: offset cookie to encode
+  *
+  * The buffer space for the offset cookie has already been reserved
+  * by svcxdr_encode_entry_common().
+  */
+ void nfssvc_encode_nfscookie(struct nfsd_readdirres *resp, u32 offset)
+ {
+ 	__be32 cookie = cpu_to_be32(offset);
+ 
+ 	if (!resp->cookie_offset)
+ 		return;
+ 
+ 	write_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,
+ 			       sizeof(cookie));
+ 	resp->cookie_offset = 0;
+ }
+ 
+ static bool
+ svcxdr_encode_entry_common(struct nfsd_readdirres *resp, const char *name,
+ 			   int namlen, loff_t offset, u64 ino)
+ {
+ 	struct xdr_buf *dirlist = &resp->dirlist;
+ 	struct xdr_stream *xdr = &resp->xdr;
+ 
+ 	if (xdr_stream_encode_item_present(xdr) < 0)
+ 		return false;
+ 	/* fileid */
+ 	if (xdr_stream_encode_u32(xdr, (u32)ino) < 0)
+ 		return false;
+ 	/* name */
+ 	if (xdr_stream_encode_opaque(xdr, name, min(namlen, NFS2_MAXNAMLEN)) < 0)
+ 		return false;
+ 	/* cookie */
+ 	resp->cookie_offset = dirlist->len;
+ 	if (xdr_stream_encode_u32(xdr, ~0U) < 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /**
+  * nfs2svc_encode_entry - encode one NFSv2 READDIR entry
+  * @data: directory context
+  * @name: name of the object to be encoded
+  * @namlen: length of that name, in bytes
+  * @offset: the offset of the previous entry
+  * @ino: the fileid of this entry
+  * @d_type: unused
+  *
+  * Return values:
+  *   %0: Entry was successfully encoded.
+  *   %-EINVAL: An encoding problem occured, secondary status code in resp->common.err
+  *
+  * On exit, the following fields are updated:
+  *   - resp->xdr
+  *   - resp->common.err
+  *   - resp->cookie_offset
+  */
+ int nfs2svc_encode_entry(void *data, const char *name, int namlen,
+ 			 loff_t offset, u64 ino, unsigned int d_type)
+ {
+ 	struct readdir_cd *ccd = data;
+ 	struct nfsd_readdirres *resp = container_of(ccd,
+ 						    struct nfsd_readdirres,
+ 						    common);
+ 	unsigned int starting_length = resp->dirlist.len;
+ 
+ 	/* The offset cookie for the previous entry */
+ 	nfssvc_encode_nfscookie(resp, offset);
+ 
+ 	if (!svcxdr_encode_entry_common(resp, name, namlen, offset, ino))
+ 		goto out_toosmall;
+ 
+ 	xdr_commit_encode(&resp->xdr);
+ 	resp->common.err = nfs_ok;
+ 	return 0;
+ 
+ out_toosmall:
+ 	resp->cookie_offset = 0;
+ 	resp->common.err = nfserr_toosmall;
+ 	resp->dirlist.len = starting_length;
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  int
  nfssvc_encode_entry(void *ccdv, const char *name,
  		    int namlen, loff_t offset, u64 ino, unsigned int d_type)
diff --cc fs/nfsd/xdr.h
index d5a6096482b0,082f262a1bf9..000000000000
--- a/fs/nfsd/xdr.h
+++ b/fs/nfsd/xdr.h
@@@ -115,6 -118,8 +119,11 @@@ struct nfsd_readdirres 
  	__be32 *		buffer;
  	int			buflen;
  	__be32 *		offset;
++<<<<<<< HEAD
++=======
+ 	struct page		*page;
+ 	unsigned int		cookie_offset;
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  };
  
  struct nfsd_statfsres {
@@@ -158,6 -163,9 +167,12 @@@ int nfssvc_encode_readres(struct svc_rq
  int nfssvc_encode_statfsres(struct svc_rqst *, __be32 *);
  int nfssvc_encode_readdirres(struct svc_rqst *, __be32 *);
  
++<<<<<<< HEAD
++=======
+ void nfssvc_encode_nfscookie(struct nfsd_readdirres *resp, u32 offset);
+ int nfs2svc_encode_entry(void *data, const char *name, int namlen,
+ 			 loff_t offset, u64 ino, unsigned int d_type);
++>>>>>>> f5dcccd647da (NFSD: Update the NFSv2 READDIR entry encoder to use struct xdr_stream)
  int nfssvc_encode_entry(void *, const char *name,
  			int namlen, loff_t offset, u64 ino, unsigned int);
  
* Unmerged path fs/nfsd/nfsproc.c
* Unmerged path fs/nfsd/nfsxdr.c
* Unmerged path fs/nfsd/xdr.h
