arm64: ftrace: Ensure module ftrace trampoline is coherent with I-side

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Will Deacon <will@kernel.org>
commit b6143d10d23ebb4a77af311e8b8b7f019d0163e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/b6143d10.failed

The initial support for dynamic ftrace trampolines in modules made use
of an indirect branch which loaded its target from the beginning of
a special section (e71a4e1bebaf7 ("arm64: ftrace: add support for far
branches to dynamic ftrace")). Since no instructions were being patched,
no cache maintenance was needed. However, later in be0f272bfc83 ("arm64:
ftrace: emit ftrace-mod.o contents through code") this code was reworked
to output the trampoline instructions directly into the PLT entry but,
unfortunately, the necessary cache maintenance was overlooked.

Add a call to __flush_icache_range() after writing the new trampoline
instructions but before patching in the branch to the trampoline.

	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: James Morse <james.morse@arm.com>
	Cc: <stable@vger.kernel.org>
Fixes: be0f272bfc83 ("arm64: ftrace: emit ftrace-mod.o contents through code")
	Signed-off-by: Will Deacon <will@kernel.org>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit b6143d10d23ebb4a77af311e8b8b7f019d0163e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/ftrace.c
diff --cc arch/arm64/kernel/ftrace.c
index 08ee5022d537,171773257974..000000000000
--- a/arch/arm64/kernel/ftrace.c
+++ b/arch/arm64/kernel/ftrace.c
@@@ -103,12 -100,16 +103,19 @@@ int ftrace_make_call(struct dyn_ftrace 
  		 * to be revisited if support for multiple ftrace entry points
  		 * is added in the future, but for now, the pr_err() below
  		 * deals with a theoretical issue only.
 -		 *
 -		 * Note that PLTs are place relative, and plt_entries_equal()
 -		 * checks whether they point to the same target. Here, we need
 -		 * to check if the actual opcodes are in fact identical,
 -		 * regardless of the offset in memory so use memcmp() instead.
  		 */
++<<<<<<< HEAD
 +		trampoline = get_plt_entry(addr);
 +		if (!plt_entries_equal(mod->arch.ftrace_trampoline,
 +				       &trampoline)) {
 +			if (!plt_entries_equal(mod->arch.ftrace_trampoline,
 +					       &(struct plt_entry){})) {
++=======
+ 		dst = mod->arch.ftrace_trampoline;
+ 		trampoline = get_plt_entry(addr, dst);
+ 		if (memcmp(dst, &trampoline, sizeof(trampoline))) {
+ 			if (plt_entry_is_initialized(dst)) {
++>>>>>>> b6143d10d23e (arm64: ftrace: Ensure module ftrace trampoline is coherent with I-side)
  				pr_err("ftrace: far branches to multiple entry points unsupported inside a single module\n");
  				return -EINVAL;
  			}
* Unmerged path arch/arm64/kernel/ftrace.c
