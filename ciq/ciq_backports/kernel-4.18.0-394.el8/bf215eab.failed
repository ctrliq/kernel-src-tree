mm/page_owner.c: record tgid

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Yixuan Cao <caoyixuan2019@email.szu.edu.cn>
commit bf215eab785a30756ea1e53b62a5638d1177a795
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/bf215eab.failed

In a single-threaded process, the pid in kernel task_struct is the same
as the tgid, which can mark the process of page allocation.  But in a
multithreaded process, only the task_struct of the thread leader has the
same pid as tgid, and the pids of other threads are different from tgid.
Therefore, tgid is recorded to provide effective information for
debugging and data statistics of multithreaded programs.

This can also be achieved by observing the task name (executable file
name) for a specific process.  However, when the same program is started
multiple times, the task name is the same and the tgid is different.
Therefore, in the debugging of multi-threaded programs, combined with
the task name and tgid, more accurate runtime information of a certain
run of the program can be obtained.

Link: https://lkml.kernel.org/r/20220219180450.2399-1-caoyixuan2019@email.szu.edu.cn
	Signed-off-by: Yixuan Cao <caoyixuan2019@email.szu.edu.cn>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Rafael Aquini <aquini@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bf215eab785a30756ea1e53b62a5638d1177a795)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_owner.c
diff --cc mm/page_owner.c
index d199c5bc2d6c,fb3a05fdebdb..000000000000
--- a/mm/page_owner.c
+++ b/mm/page_owner.c
@@@ -29,7 -29,9 +29,8 @@@ struct page_owner 
  	depot_stack_handle_t free_handle;
  	u64 ts_nsec;
  	u64 free_ts_nsec;
 -	char comm[TASK_COMM_LEN];
  	pid_t pid;
+ 	pid_t tgid;
  };
  
  static bool page_owner_enabled = false;
@@@ -162,7 -166,10 +163,8 @@@ static inline void __set_page_owner_han
  		page_owner->gfp_mask = gfp_mask;
  		page_owner->last_migrate_reason = -1;
  		page_owner->pid = current->pid;
+ 		page_owner->tgid = current->tgid;
  		page_owner->ts_nsec = local_clock();
 -		strlcpy(page_owner->comm, current->comm,
 -			sizeof(page_owner->comm));
  		__set_bit(PAGE_EXT_OWNER, &page_ext->flags);
  		__set_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags);
  
@@@ -228,15 -235,17 +230,16 @@@ void __copy_page_owner(struct page *old
  		old_page_owner->last_migrate_reason;
  	new_page_owner->handle = old_page_owner->handle;
  	new_page_owner->pid = old_page_owner->pid;
+ 	new_page_owner->tgid = old_page_owner->tgid;
  	new_page_owner->ts_nsec = old_page_owner->ts_nsec;
  	new_page_owner->free_ts_nsec = old_page_owner->ts_nsec;
 -	strcpy(new_page_owner->comm, old_page_owner->comm);
  
  	/*
 -	 * We don't clear the bit on the old folio as it's going to be freed
 +	 * We don't clear the bit on the oldpage as it's going to be freed
  	 * after migration. Until then, the info can be useful in case of
 -	 * a bug, and the overall stats will be off a bit only temporarily.
 +	 * a bug, and the overal stats will be off a bit only temporarily.
  	 * Also, migrate_misplaced_transhuge_page() can still fail the
 -	 * migration and then we want the old folio to retain the info. But
 +	 * migration and then we want the oldpage to retain the info. But
  	 * in that case we also don't need to explicitly clear the info from
  	 * the new page, which will be freed.
  	 */
@@@ -382,14 -385,12 +385,23 @@@ print_page_owner(char __user *buf, size
  	if (!kbuf)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ret = snprintf(kbuf, count,
 +			"Page allocated via order %u, mask %#x(%pGg), pid %d, ts %llu ns, free_ts %llu ns\n",
 +			page_owner->order, page_owner->gfp_mask,
 +			&page_owner->gfp_mask, page_owner->pid,
 +			page_owner->ts_nsec, page_owner->free_ts_nsec);
 +
 +	if (ret >= count)
 +		goto err;
++=======
+ 	ret = scnprintf(kbuf, count,
+ 			"Page allocated via order %u, mask %#x(%pGg), pid %d, tgid %d (%s), ts %llu ns, free_ts %llu ns\n",
+ 			page_owner->order, page_owner->gfp_mask,
+ 			&page_owner->gfp_mask, page_owner->pid,
+ 			page_owner->tgid, page_owner->comm,
+ 			page_owner->ts_nsec, page_owner->free_ts_nsec);
++>>>>>>> bf215eab785a (mm/page_owner.c: record tgid)
  
  	/* Print information relevant to grouping pages by mobility */
  	pageblock_mt = get_pageblock_migratetype(page);
@@@ -464,17 -457,16 +476,24 @@@ void __dump_page_owner(const struct pag
  	else
  		pr_alert("page_owner tracks the page as freed\n");
  
++<<<<<<< HEAD
 +	pr_alert("page last allocated via order %u, migratetype %s, gfp_mask %#x(%pGg), pid %d, ts %llu, free_ts %llu\n",
 +		 page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask,
 +		 page_owner->pid, page_owner->ts_nsec, page_owner->free_ts_nsec);
++=======
+ 	pr_alert("page last allocated via order %u, migratetype %s, gfp_mask %#x(%pGg), pid %d, tgid %d (%s), ts %llu, free_ts %llu\n",
+ 		 page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask,
+ 		 page_owner->pid, page_owner->tgid, page_owner->comm,
+ 		 page_owner->ts_nsec, page_owner->free_ts_nsec);
++>>>>>>> bf215eab785a (mm/page_owner.c: record tgid)
  
  	handle = READ_ONCE(page_owner->handle);
 -	if (!handle)
 +	if (!handle) {
  		pr_alert("page_owner allocation stack trace missing\n");
 -	else
 -		stack_depot_print(handle);
 +	} else {
 +		nr_entries = stack_depot_fetch(handle, &entries);
 +		stack_trace_print(entries, nr_entries, 0);
 +	}
  
  	handle = READ_ONCE(page_owner->free_handle);
  	if (!handle) {
* Unmerged path mm/page_owner.c
