arm64: Remove asmlinkage from updated functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author James Morse <james.morse@arm.com>
commit afa7c0e5b965cdb945ad8a2e2973c6d7e19969f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/afa7c0e5.failed

Now that the callers of these functions have moved into C, they no longer
need the asmlinkage annotation. Remove it.

	Signed-off-by: James Morse <james.morse@arm.com>
	Acked-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit afa7c0e5b965cdb945ad8a2e2973c6d7e19969f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/exception.h
#	arch/arm64/kernel/traps.c
#	arch/arm64/mm/fault.c
diff --cc arch/arm64/include/asm/exception.h
index 55a461d97487,4d5f3b5f50cd..000000000000
--- a/arch/arm64/include/asm/exception.h
+++ b/arch/arm64/include/asm/exception.h
@@@ -42,5 -32,22 +42,25 @@@ static inline u32 disr_to_esr(u64 disr
  }
  
  asmlinkage void enter_from_user_mode(void);
++<<<<<<< HEAD
++=======
+ void do_mem_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs);
+ void do_sp_pc_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs);
+ void do_undefinstr(struct pt_regs *regs);
+ asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr);
+ void do_debug_exception(unsigned long addr_if_watchpoint, unsigned int esr,
+ 			struct pt_regs *regs);
+ void do_fpsimd_acc(unsigned int esr, struct pt_regs *regs);
+ void do_sve_acc(unsigned int esr, struct pt_regs *regs);
+ void do_fpsimd_exc(unsigned int esr, struct pt_regs *regs);
+ void do_sysinstr(unsigned int esr, struct pt_regs *regs);
+ void do_sp_pc_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs);
+ void bad_el0_sync(struct pt_regs *regs, int reason, unsigned int esr);
+ void do_cp15instr(unsigned int esr, struct pt_regs *regs);
+ void el0_svc_handler(struct pt_regs *regs);
+ void el0_svc_compat_handler(struct pt_regs *regs);
+ void do_el0_ia_bp_hardening(unsigned long addr,  unsigned int esr,
+ 			    struct pt_regs *regs);
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  
  #endif	/* __ASM_EXCEPTION_H */
diff --cc arch/arm64/kernel/traps.c
index ccfd884c601f,54ebe24ef4b1..000000000000
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@@ -402,7 -394,7 +402,11 @@@ void arm64_notify_segfault(unsigned lon
  	force_signal_inject(SIGSEGV, code, addr);
  }
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_undefinstr(struct pt_regs *regs)
++=======
+ void do_undefinstr(struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	/* check for AArch32 breakpoint instructions */
  	if (!aarch32_break_handler(regs))
@@@ -685,7 -669,7 +689,11 @@@ static const struct sys64_hook cp15_64_
  	{},
  };
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_cp15instr(unsigned int esr, struct pt_regs *regs)
++=======
+ void do_cp15instr(unsigned int esr, struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	const struct sys64_hook *hook, *hook_base;
  
@@@ -723,9 -707,10 +731,13 @@@
  	 */
  	do_undefinstr(regs);
  }
 -NOKPROBE_SYMBOL(do_cp15instr);
  #endif
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_sysinstr(unsigned int esr, struct pt_regs *regs)
++=======
+ void do_sysinstr(unsigned int esr, struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	const struct sys64_hook *hook;
  
diff --cc arch/arm64/mm/fault.c
index a1fbfca74da1,cb13f4daa878..000000000000
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@@ -761,8 -733,7 +761,12 @@@ static const struct fault_info fault_in
  	{ do_bad,		SIGKILL, SI_KERNEL,	"unknown 63"			},
  };
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_mem_abort(unsigned long addr, unsigned int esr,
 +					 struct pt_regs *regs)
++=======
+ void do_mem_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	const struct fault_info *inf = esr_to_fault_info(esr);
  
@@@ -778,16 -749,17 +782,25 @@@
  	arm64_notify_die(inf->name, regs,
  			 inf->sig, inf->code, (void __user *)addr, esr);
  }
 -NOKPROBE_SYMBOL(do_mem_abort);
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_el0_irq_bp_hardening(void)
++=======
+ void do_el0_irq_bp_hardening(void)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	/* PC has already been checked in entry.S */
  	arm64_apply_bp_hardening();
  }
 -NOKPROBE_SYMBOL(do_el0_irq_bp_hardening);
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_el0_ia_bp_hardening(unsigned long addr,
 +						   unsigned int esr,
 +						   struct pt_regs *regs)
++=======
+ void do_el0_ia_bp_hardening(unsigned long addr,  unsigned int esr,
+ 			    struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	/*
  	 * We've taken an instruction abort from userspace and not yet
@@@ -800,11 -772,9 +813,15 @@@
  	local_daif_restore(DAIF_PROCCTX);
  	do_mem_abort(addr, esr, regs);
  }
 -NOKPROBE_SYMBOL(do_el0_ia_bp_hardening);
  
++<<<<<<< HEAD
 +
 +asmlinkage void __exception do_sp_pc_abort(unsigned long addr,
 +					   unsigned int esr,
 +					   struct pt_regs *regs)
++=======
+ void do_sp_pc_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	if (user_mode(regs)) {
  		if (!is_ttbr0_addr(instruction_pointer(regs)))
@@@ -876,10 -892,10 +893,15 @@@ cortex_a76_erratum_1463225_debug_handle
  	return 0;
  }
  #endif /* CONFIG_ARM64_ERRATUM_1463225 */
 -NOKPROBE_SYMBOL(cortex_a76_erratum_1463225_debug_handler);
  
++<<<<<<< HEAD
 +asmlinkage void __exception do_debug_exception(unsigned long addr_if_watchpoint,
 +					       unsigned int esr,
 +					       struct pt_regs *regs)
++=======
+ void do_debug_exception(unsigned long addr_if_watchpoint, unsigned int esr,
+ 			struct pt_regs *regs)
++>>>>>>> afa7c0e5b965 (arm64: Remove asmlinkage from updated functions)
  {
  	const struct fault_info *inf = esr_to_debug_fault_info(esr);
  	unsigned long pc = instruction_pointer(regs);
* Unmerged path arch/arm64/include/asm/exception.h
diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c
index daf41eb1ff47..cddae9c36abe 100644
--- a/arch/arm64/kernel/fpsimd.c
+++ b/arch/arm64/kernel/fpsimd.c
@@ -933,7 +933,7 @@ void fpsimd_release_task(struct task_struct *dead_task)
  * would have disabled the SVE access trap for userspace during
  * ret_to_user, making an SVE access trap impossible in that case.
  */
-asmlinkage void do_sve_acc(unsigned int esr, struct pt_regs *regs)
+void do_sve_acc(unsigned int esr, struct pt_regs *regs)
 {
 	/* Even if we chose not to use SVE, the hardware could still trap: */
 	if (unlikely(!system_supports_sve()) || WARN_ON(is_compat_task())) {
@@ -960,7 +960,7 @@ asmlinkage void do_sve_acc(unsigned int esr, struct pt_regs *regs)
 /*
  * Trapped FP/ASIMD access.
  */
-asmlinkage void do_fpsimd_acc(unsigned int esr, struct pt_regs *regs)
+void do_fpsimd_acc(unsigned int esr, struct pt_regs *regs)
 {
 	/* TODO: implement lazy context saving/restoring */
 	WARN_ON(1);
@@ -969,7 +969,7 @@ asmlinkage void do_fpsimd_acc(unsigned int esr, struct pt_regs *regs)
 /*
  * Raise a SIGFPE for the current process.
  */
-asmlinkage void do_fpsimd_exc(unsigned int esr, struct pt_regs *regs)
+void do_fpsimd_exc(unsigned int esr, struct pt_regs *regs)
 {
 	unsigned int si_code = FPE_FLTUNK;
 
diff --git a/arch/arm64/kernel/syscall.c b/arch/arm64/kernel/syscall.c
index 871c739f060a..9a9d98a443fc 100644
--- a/arch/arm64/kernel/syscall.c
+++ b/arch/arm64/kernel/syscall.c
@@ -154,14 +154,14 @@ static inline void sve_user_discard(void)
 	sve_user_disable();
 }
 
-asmlinkage void el0_svc_handler(struct pt_regs *regs)
+void el0_svc_handler(struct pt_regs *regs)
 {
 	sve_user_discard();
 	el0_svc_common(regs, regs->regs[8], __NR_syscalls, sys_call_table);
 }
 
 #ifdef CONFIG_COMPAT
-asmlinkage void el0_svc_compat_handler(struct pt_regs *regs)
+void el0_svc_compat_handler(struct pt_regs *regs)
 {
 	el0_svc_common(regs, regs->regs[7], __NR_compat_syscalls,
 		       compat_sys_call_table);
* Unmerged path arch/arm64/kernel/traps.c
* Unmerged path arch/arm64/mm/fault.c
