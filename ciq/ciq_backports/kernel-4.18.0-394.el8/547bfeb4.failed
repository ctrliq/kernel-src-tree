NFSD: Add a separate decoder for ssv_sp_parms

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 547bfeb4cd8d491aabbd656d5a6f410cb4249b4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/547bfeb4.failed

Refactor for clarity.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 547bfeb4cd8d491aabbd656d5a6f410cb4249b4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index a7c80f4dce78,35b2668b572e..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -1384,6 -1454,82 +1384,85 @@@ static __be32 nfsd4_decode_backchannel_
  	return nfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);
  }
  
++<<<<<<< HEAD
++=======
+ static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)
+ {
+ 	u32 use_conn_in_rdma_mode;
+ 	__be32 status;
+ 
+ 	status = nfsd4_decode_sessionid4(argp, &bcts->sessionid);
+ 	if (status)
+ 		return status;
+ 	if (xdr_stream_decode_u32(argp->xdr, &bcts->dir) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &use_conn_in_rdma_mode) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_state_protect_ops(struct nfsd4_compoundargs *argp,
+ 			       struct nfsd4_exchange_id *exid)
+ {
+ 	__be32 status;
+ 
+ 	status = nfsd4_decode_bitmap4(argp, exid->spo_must_enforce,
+ 				      ARRAY_SIZE(exid->spo_must_enforce));
+ 	if (status)
+ 		return nfserr_bad_xdr;
+ 	status = nfsd4_decode_bitmap4(argp, exid->spo_must_allow,
+ 				      ARRAY_SIZE(exid->spo_must_allow));
+ 	if (status)
+ 		return nfserr_bad_xdr;
+ 
+ 	return nfs_ok;
+ }
+ 
+ /*
+  * This implementation currently does not support SP4_SSV.
+  * This decoder simply skips over these arguments.
+  */
+ static noinline __be32
+ nfsd4_decode_ssv_sp_parms(struct nfsd4_compoundargs *argp,
+ 			  struct nfsd4_exchange_id *exid)
+ {
+ 	u32 count, window, num_gss_handles;
+ 	__be32 status;
+ 
+ 	/* ssp_ops */
+ 	status = nfsd4_decode_state_protect_ops(argp, exid);
+ 	if (status)
+ 		return status;
+ 
+ 	/* ssp_hash_algs<> */
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 	while (count--) {
+ 		status = nfsd4_decode_ignored_string(argp, 0);
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	/* ssp_encr_algs<> */
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 	while (count--) {
+ 		status = nfsd4_decode_ignored_string(argp, 0);
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &window) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &num_gss_handles) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	return nfs_ok;
+ }
+ 
++>>>>>>> 547bfeb4cd8d (NFSD: Add a separate decoder for ssv_sp_parms)
  static __be32
  nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
  			 struct nfsd4_exchange_id *exid)
@@@ -1408,50 -1554,14 +1487,56 @@@
  	case SP4_NONE:
  		break;
  	case SP4_MACH_CRED:
 -		status = nfsd4_decode_state_protect_ops(argp, exid);
 +		/* spo_must_enforce */
 +		status = nfsd4_decode_bitmap(argp,
 +					exid->spo_must_enforce);
  		if (status)
 -			return status;
 +			goto out;
 +		/* spo_must_allow */
 +		status = nfsd4_decode_bitmap(argp, exid->spo_must_allow);
 +		if (status)
 +			goto out;
  		break;
  	case SP4_SSV:
++<<<<<<< HEAD
 +		/* ssp_ops */
 +		READ_BUF(4);
 +		dummy = be32_to_cpup(p++);
 +		READ_BUF(dummy * 4);
 +		p += dummy;
 +
 +		READ_BUF(4);
 +		dummy = be32_to_cpup(p++);
 +		READ_BUF(dummy * 4);
 +		p += dummy;
 +
 +		/* ssp_hash_algs<> */
 +		READ_BUF(4);
 +		tmp = be32_to_cpup(p++);
 +		while (tmp--) {
 +			READ_BUF(4);
 +			dummy = be32_to_cpup(p++);
 +			READ_BUF(dummy);
 +			p += XDR_QUADLEN(dummy);
 +		}
 +
 +		/* ssp_encr_algs<> */
 +		READ_BUF(4);
 +		tmp = be32_to_cpup(p++);
 +		while (tmp--) {
 +			READ_BUF(4);
 +			dummy = be32_to_cpup(p++);
 +			READ_BUF(dummy);
 +			p += XDR_QUADLEN(dummy);
 +		}
 +
 +		/* ignore ssp_window and ssp_num_gss_handles: */
 +		READ_BUF(8);
++=======
+ 		status = nfsd4_decode_ssv_sp_parms(argp, exid);
+ 		if (status)
+ 			return status;
++>>>>>>> 547bfeb4cd8d (NFSD: Add a separate decoder for ssv_sp_parms)
  		break;
  	default:
  		goto xdr_error;
* Unmerged path fs/nfsd/nfs4xdr.c
