Revert "RDMA/core: Fix ib_qp_usecnt_dec() called when error"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 7922d3de4d270a9aedb71212fc0d5ae697ced516
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/7922d3de.failed

This reverts commit 7c4a539ec38f4ce400a0f3fcb5ff6c940fcd67bb. which causes
to the following error in mlx4.

  Destroy of kernel CQ shouldn't fail
  WARNING: CPU: 4 PID: 18064 at include/rdma/ib_verbs.h:3936 mlx4_ib_dealloc_xrcd+0x12e/0x1b0 [mlx4_ib]
  Modules linked in: bonding ib_ipoib ip_gre ipip tunnel4 geneve rdma_ucm nf_tables ib_umad mlx4_en mlx4_ib ib_uverbs mlx4_core ip6_gre gre ip6_tunnel tunnel6 iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter overlay fuse [last unloaded: mlx4_core]
  CPU: 4 PID: 18064 Comm: ibv_xsrq_pingpo Not tainted 5.17.0-rc7_master_62c6ecb #1
  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
  RIP: 0010:mlx4_ib_dealloc_xrcd+0x12e/0x1b0 [mlx4_ib]
  Code: 1e 93 08 00 40 80 fd 01 0f 87 fa f1 04 00 83 e5 01 0f 85 2b ff ff ff 48 c7 c7 20 4f b6 a0 c6 05 fd 92 08 00 01 e8 47 c9 82 e2 <0f> 0b e9 11 ff ff ff 0f b6 2d eb 92 08 00 40 80 fd 01 0f 87 b1 f1
  RSP: 0018:ffff8881a4957750 EFLAGS: 00010286
  RAX: 0000000000000000 RBX: ffff8881ac4b6800 RCX: 0000000000000000
  RDX: 0000000000000027 RSI: 0000000000000004 RDI: ffffed103492aedc
  RBP: 0000000000000000 R08: 0000000000000001 R09: ffff8884d2e378eb
  R10: ffffed109a5c6f1d R11: 0000000000000001 R12: ffff888132620000
  R13: ffff8881a4957a90 R14: ffff8881aa2d4000 R15: ffff8881a4957ad0
  FS:  00007f0401747740(0000) GS:ffff8884d2e00000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 000055f8ae036118 CR3: 000000012fe94005 CR4: 0000000000370ea0
  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
  Call Trace:
   <TASK>
   ib_dealloc_xrcd_user+0xce/0x120 [ib_core]
   ib_uverbs_dealloc_xrcd+0xad/0x210 [ib_uverbs]
   uverbs_free_xrcd+0xe8/0x190 [ib_uverbs]
   destroy_hw_idr_uobject+0x7a/0x130 [ib_uverbs]
   uverbs_destroy_uobject+0x164/0x730 [ib_uverbs]
   uobj_destroy+0x72/0xf0 [ib_uverbs]
   ib_uverbs_cmd_verbs+0x19fb/0x3110 [ib_uverbs]
   ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]
   __x64_sys_ioctl+0x856/0x1550
   do_syscall_64+0x3d/0x90
   entry_SYSCALL_64_after_hwframe+0x44/0xae

Fixes: 7c4a539ec38f ("RDMA/core: Fix ib_qp_usecnt_dec() called when error")
Link: https://lore.kernel.org/r/74c11029adaf449b3b9228a77cc82f39e9e892c8.1646851220.git.leonro@nvidia.com
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 7922d3de4d270a9aedb71212fc0d5ae697ced516)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/verbs.c
diff --cc drivers/infiniband/core/verbs.c
index e77032057254,a9819c40a140..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -1191,22 -1192,143 +1191,90 @@@ static struct ib_qp *create_xrc_qp_user
  	return qp;
  }
  
++<<<<<<< HEAD
++=======
+ static struct ib_qp *create_qp(struct ib_device *dev, struct ib_pd *pd,
+ 			       struct ib_qp_init_attr *attr,
+ 			       struct ib_udata *udata,
+ 			       struct ib_uqp_object *uobj, const char *caller)
+ {
+ 	struct ib_udata dummy = {};
+ 	struct ib_qp *qp;
+ 	int ret;
+ 
+ 	if (!dev->ops.create_qp)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	qp = rdma_zalloc_drv_obj_numa(dev, ib_qp);
+ 	if (!qp)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	qp->device = dev;
+ 	qp->pd = pd;
+ 	qp->uobject = uobj;
+ 	qp->real_qp = qp;
+ 
+ 	qp->qp_type = attr->qp_type;
+ 	qp->rwq_ind_tbl = attr->rwq_ind_tbl;
+ 	qp->srq = attr->srq;
+ 	qp->event_handler = attr->event_handler;
+ 	qp->port = attr->port_num;
+ 	qp->qp_context = attr->qp_context;
+ 
+ 	spin_lock_init(&qp->mr_lock);
+ 	INIT_LIST_HEAD(&qp->rdma_mrs);
+ 	INIT_LIST_HEAD(&qp->sig_mrs);
+ 
+ 	qp->send_cq = attr->send_cq;
+ 	qp->recv_cq = attr->recv_cq;
+ 
+ 	rdma_restrack_new(&qp->res, RDMA_RESTRACK_QP);
+ 	WARN_ONCE(!udata && !caller, "Missing kernel QP owner");
+ 	rdma_restrack_set_name(&qp->res, udata ? NULL : caller);
+ 	ret = dev->ops.create_qp(qp, attr, udata);
+ 	if (ret)
+ 		goto err_create;
+ 
+ 	/*
+ 	 * TODO: The mlx4 internally overwrites send_cq and recv_cq.
+ 	 * Unfortunately, it is not an easy task to fix that driver.
+ 	 */
+ 	qp->send_cq = attr->send_cq;
+ 	qp->recv_cq = attr->recv_cq;
+ 
+ 	ret = ib_create_qp_security(qp, dev);
+ 	if (ret)
+ 		goto err_security;
+ 
+ 	rdma_restrack_add(&qp->res);
+ 	return qp;
+ 
+ err_security:
+ 	qp->device->ops.destroy_qp(qp, udata ? &dummy : NULL);
+ err_create:
+ 	rdma_restrack_put(&qp->res);
+ 	kfree(qp);
+ 	return ERR_PTR(ret);
+ 
+ }
+ 
++>>>>>>> 7922d3de4d27 (Revert "RDMA/core: Fix ib_qp_usecnt_dec() called when error")
  /**
 - * ib_create_qp_user - Creates a QP associated with the specified protection
 + * ib_create_named_qp - Creates a kernel QP associated with the specified protection
   *   domain.
 - * @dev: IB device
   * @pd: The protection domain associated with the QP.
 - * @attr: A list of initial attributes required to create the
 + * @qp_init_attr: A list of initial attributes required to create the
   *   QP.  If QP creation succeeds, then the attributes are updated to
   *   the actual capabilities of the created QP.
 - * @udata: User data
 - * @uobj: uverbs obect
   * @caller: caller's build-time module name
 + *
 + * NOTE: for user qp use ib_create_qp_user with valid udata!
   */
 -struct ib_qp *ib_create_qp_user(struct ib_device *dev, struct ib_pd *pd,
 -				struct ib_qp_init_attr *attr,
 -				struct ib_udata *udata,
 -				struct ib_uqp_object *uobj, const char *caller)
 -{
 -	struct ib_qp *qp, *xrc_qp;
 -
 -	if (attr->qp_type == IB_QPT_XRC_TGT)
 -		qp = create_qp(dev, pd, attr, NULL, NULL, caller);
 -	else
 -		qp = create_qp(dev, pd, attr, udata, uobj, NULL);
 -	if (attr->qp_type != IB_QPT_XRC_TGT || IS_ERR(qp))
 -		return qp;
 -
 -	xrc_qp = create_xrc_qp_user(qp, attr);
 -	if (IS_ERR(xrc_qp)) {
 -		ib_destroy_qp(qp);
 -		return xrc_qp;
 -	}
 -
 -	xrc_qp->uobject = uobj;
 -	return xrc_qp;
 -}
 -EXPORT_SYMBOL(ib_create_qp_user);
 -
 -void ib_qp_usecnt_inc(struct ib_qp *qp)
 +struct ib_qp *ib_create_named_qp(struct ib_pd *pd,
 +				 struct ib_qp_init_attr *qp_init_attr,
 +				 const char *caller)
  {
 -	if (qp->pd)
 -		atomic_inc(&qp->pd->usecnt);
 -	if (qp->send_cq)
 -		atomic_inc(&qp->send_cq->usecnt);
 -	if (qp->recv_cq)
 -		atomic_inc(&qp->recv_cq->usecnt);
 -	if (qp->srq)
 -		atomic_inc(&qp->srq->usecnt);
 -	if (qp->rwq_ind_tbl)
 -		atomic_inc(&qp->rwq_ind_tbl->usecnt);
 -}
 -EXPORT_SYMBOL(ib_qp_usecnt_inc);
 -
 -void ib_qp_usecnt_dec(struct ib_qp *qp)
 -{
 -	if (qp->rwq_ind_tbl)
 -		atomic_dec(&qp->rwq_ind_tbl->usecnt);
 -	if (qp->srq)
 -		atomic_dec(&qp->srq->usecnt);
 -	if (qp->recv_cq)
 -		atomic_dec(&qp->recv_cq->usecnt);
 -	if (qp->send_cq)
 -		atomic_dec(&qp->send_cq->usecnt);
 -	if (qp->pd)
 -		atomic_dec(&qp->pd->usecnt);
 -}
 -EXPORT_SYMBOL(ib_qp_usecnt_dec);
 -
 -struct ib_qp *ib_create_qp_kernel(struct ib_pd *pd,
 -				  struct ib_qp_init_attr *qp_init_attr,
 -				  const char *caller)
 -{
 -	struct ib_device *device = pd->device;
 +	struct ib_device *device = pd ? pd->device : qp_init_attr->xrcd->device;
  	struct ib_qp *qp;
  	int ret;
  
@@@ -1223,29 -1345,7 +1291,33 @@@
  	if (IS_ERR(qp))
  		return qp;
  
++<<<<<<< HEAD
 +	ret = ib_create_qp_security(qp, device);
 +	if (ret)
 +		goto err;
 +
 +	if (qp_init_attr->qp_type == IB_QPT_XRC_TGT) {
 +		struct ib_qp *xrc_qp =
 +			create_xrc_qp_user(qp, qp_init_attr);
 +
 +		if (IS_ERR(xrc_qp)) {
 +			ret = PTR_ERR(xrc_qp);
 +			goto err;
 +		}
 +		return xrc_qp;
 +	}
 +
 +	if (qp_init_attr->recv_cq)
 +		atomic_inc(&qp_init_attr->recv_cq->usecnt);
 +	if (qp->srq)
 +		atomic_inc(&qp_init_attr->srq->usecnt);
 +
 +	atomic_inc(&pd->usecnt);
 +	if (qp_init_attr->send_cq)
 +		atomic_inc(&qp_init_attr->send_cq->usecnt);
++=======
+ 	ib_qp_usecnt_inc(qp);
++>>>>>>> 7922d3de4d27 (Revert "RDMA/core: Fix ib_qp_usecnt_dec() called when error")
  
  	if (qp_init_attr->cap.max_rdma_ctxs) {
  		ret = rdma_rw_init_mrs(qp, qp_init_attr);
diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c
index 9eca370b8ef4..08220d4acba5 100644
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@ -1443,6 +1443,7 @@ static int create_qp(struct uverbs_attr_bundle *attrs,
 		ret = PTR_ERR(qp);
 		goto err_put;
 	}
+	ib_qp_usecnt_inc(qp);
 
 	if (cmd->qp_type != IB_QPT_XRC_TGT) {
 		ret = ib_create_qp_security(qp, device);
diff --git a/drivers/infiniband/core/uverbs_std_types_qp.c b/drivers/infiniband/core/uverbs_std_types_qp.c
index 070994ed133d..9558fe11060f 100644
--- a/drivers/infiniband/core/uverbs_std_types_qp.c
+++ b/drivers/infiniband/core/uverbs_std_types_qp.c
@@ -258,6 +258,7 @@ static int UVERBS_HANDLER(UVERBS_METHOD_QP_CREATE)(
 		ret = PTR_ERR(qp);
 		goto err_put;
 	}
+	ib_qp_usecnt_inc(qp);
 
 	if (attr.qp_type != IB_QPT_XRC_TGT) {
 		atomic_inc(&pd->usecnt);
* Unmerged path drivers/infiniband/core/verbs.c
