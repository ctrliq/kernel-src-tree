NFSD: Replace READ* macros that decode the fattr4 security label attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit dabe91828f92cd493e9e75efbc10f9878d2a73fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/dabe9182.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit dabe91828f92cd493e9e75efbc10f9878d2a73fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 148fec779d69,4e87d035632a..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -374,6 -261,97 +374,100 @@@ nfsd4_decode_bitmap(struct nfsd4_compou
  }
  
  static __be32
++<<<<<<< HEAD
++=======
+ nfsd4_decode_nfsace4(struct nfsd4_compoundargs *argp, struct nfs4_ace *ace)
+ {
+ 	__be32 *p, status;
+ 	u32 length;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &ace->type) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &ace->flag) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &ace->access_mask) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
+ 		return nfserr_bad_xdr;
+ 	p = xdr_inline_decode(argp->xdr, length);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	ace->whotype = nfs4_acl_get_whotype((char *)p, length);
+ 	if (ace->whotype != NFS4_ACL_WHO_NAMED)
+ 		status = nfs_ok;
+ 	else if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)
+ 		status = nfsd_map_name_to_gid(argp->rqstp,
+ 				(char *)p, length, &ace->who_gid);
+ 	else
+ 		status = nfsd_map_name_to_uid(argp->rqstp,
+ 				(char *)p, length, &ace->who_uid);
+ 
+ 	return status;
+ }
+ 
+ /* A counted array of nfsace4's */
+ static noinline __be32
+ nfsd4_decode_acl(struct nfsd4_compoundargs *argp, struct nfs4_acl **acl)
+ {
+ 	struct nfs4_ace *ace;
+ 	__be32 status;
+ 	u32 count;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (count > xdr_stream_remaining(argp->xdr) / 20)
+ 		/*
+ 		 * Even with 4-byte names there wouldn't be
+ 		 * space for that many aces; something fishy is
+ 		 * going on:
+ 		 */
+ 		return nfserr_fbig;
+ 
+ 	*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(count));
+ 	if (*acl == NULL)
+ 		return nfserr_jukebox;
+ 
+ 	(*acl)->naces = count;
+ 	for (ace = (*acl)->aces; ace < (*acl)->aces + count; ace++) {
+ 		status = nfsd4_decode_nfsace4(argp, ace);
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
+ static noinline __be32
+ nfsd4_decode_security_label(struct nfsd4_compoundargs *argp,
+ 			    struct xdr_netobj *label)
+ {
+ 	u32 lfs, pi, length;
+ 	__be32 *p;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &lfs) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &pi) < 0)
+ 		return nfserr_bad_xdr;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &length) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (length > NFS4_MAXLABELLEN)
+ 		return nfserr_badlabel;
+ 	p = xdr_inline_decode(argp->xdr, length);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	label->len = length;
+ 	label->data = svcxdr_dupstr(argp, p, length);
+ 	if (!label->data)
+ 		return nfserr_jukebox;
+ 
+ 	return nfs_ok;
+ }
+ 
+ static __be32
++>>>>>>> dabe91828f92 (NFSD: Replace READ* macros that decode the fattr4 security label attribute)
  nfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,
  		   struct iattr *iattr, struct nfs4_acl **acl,
  		   struct xdr_netobj *label, int *umask)
* Unmerged path fs/nfsd/nfs4xdr.c
