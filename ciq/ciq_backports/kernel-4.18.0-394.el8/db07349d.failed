xfs: move the di_flags field to struct xfs_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit db07349da2f564742c0f23528691991e641e315e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/db07349d.failed

In preparation of removing the historic icinode struct, move the flags
field into the containing xfs_inode structure.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit db07349da2f564742c0f23528691991e641e315e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_inode_buf.h
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_inode.h
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 671aeb012e3f,6c81474a94a5..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -226,11 -227,11 +226,19 @@@ xfs_inode_from_disk
  	inode->i_mtime = xfs_inode_from_disk_ts(from, from->di_mtime);
  	inode->i_ctime = xfs_inode_from_disk_ts(from, from->di_ctime);
  
++<<<<<<< HEAD
 +	to->di_size = be64_to_cpu(from->di_size);
 +	to->di_nblocks = be64_to_cpu(from->di_nblocks);
 +	to->di_extsize = be32_to_cpu(from->di_extsize);
 +	to->di_forkoff = from->di_forkoff;
 +	to->di_flags	= be16_to_cpu(from->di_flags);
++=======
+ 	ip->i_disk_size = be64_to_cpu(from->di_size);
+ 	ip->i_nblocks = be64_to_cpu(from->di_nblocks);
+ 	ip->i_extsize = be32_to_cpu(from->di_extsize);
+ 	ip->i_forkoff = from->di_forkoff;
+ 	ip->i_diflags	= be16_to_cpu(from->di_flags);
++>>>>>>> db07349da2f5 (xfs: move the di_flags field to struct xfs_inode)
  
  	if (from->di_dmevmask || from->di_dmstate)
  		xfs_iflags_set(ip, XFS_IPRESERVE_DM_FIELDS);
@@@ -305,14 -306,14 +313,14 @@@ xfs_inode_to_disk
  	to->di_gen = cpu_to_be32(inode->i_generation);
  	to->di_mode = cpu_to_be16(inode->i_mode);
  
 -	to->di_size = cpu_to_be64(ip->i_disk_size);
 -	to->di_nblocks = cpu_to_be64(ip->i_nblocks);
 -	to->di_extsize = cpu_to_be32(ip->i_extsize);
 +	to->di_size = cpu_to_be64(from->di_size);
 +	to->di_nblocks = cpu_to_be64(from->di_nblocks);
 +	to->di_extsize = cpu_to_be32(from->di_extsize);
  	to->di_nextents = cpu_to_be32(xfs_ifork_nextents(&ip->i_df));
  	to->di_anextents = cpu_to_be16(xfs_ifork_nextents(ip->i_afp));
 -	to->di_forkoff = ip->i_forkoff;
 +	to->di_forkoff = from->di_forkoff;
  	to->di_aformat = xfs_ifork_format(ip->i_afp);
- 	to->di_flags = cpu_to_be16(from->di_flags);
+ 	to->di_flags = cpu_to_be16(ip->i_diflags);
  
  	if (xfs_sb_version_has_v3inode(&ip->i_mount->m_sb)) {
  		to->di_version = 3;
diff --cc fs/xfs/libxfs/xfs_inode_buf.h
index 406f66799288,cfad369e7350..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.h
+++ b/fs/xfs/libxfs/xfs_inode_buf.h
@@@ -16,15 -16,7 +16,18 @@@ struct xfs_dinode
   * format specific structures at the appropriate time.
   */
  struct xfs_icdinode {
++<<<<<<< HEAD
 +	uint16_t	di_flushiter;	/* incremented on flush */
 +	xfs_fsize_t	di_size;	/* number of bytes in file */
 +	xfs_rfsblock_t	di_nblocks;	/* # of direct & btree blocks used */
 +	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
 +	uint8_t		di_forkoff;	/* attr fork offs, <<3 for 64b align */
 +	uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
 +
++=======
++>>>>>>> db07349da2f5 (xfs: move the di_flags field to struct xfs_inode)
  	uint64_t	di_flags2;	/* more random flags */
 +	uint32_t	di_cowextsize;	/* basic cow extent size for file */
  
  	struct timespec64 di_crtime;	/* time created */
  };
diff --cc fs/xfs/xfs_inode.c
index d856a2225b9c,97044b5b9578..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -60,8 -60,8 +60,13 @@@ xfs_get_extsz_hint
  	 */
  	if (xfs_is_always_cow_inode(ip))
  		return 0;
++<<<<<<< HEAD
 +	if ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)
 +		return ip->i_d.di_extsize;
++=======
+ 	if ((ip->i_diflags & XFS_DIFLAG_EXTSIZE) && ip->i_extsize)
+ 		return ip->i_extsize;
++>>>>>>> db07349da2f5 (xfs: move the di_flags field to struct xfs_inode)
  	if (XFS_IS_REALTIME_INODE(ip))
  		return ip->i_mount->m_sb.sb_rextsize;
  	return 0;
@@@ -708,42 -708,42 +713,42 @@@ xfs_inode_inherit_flags
  	umode_t			mode = VFS_I(ip)->i_mode;
  
  	if (S_ISDIR(mode)) {
- 		if (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)
+ 		if (pip->i_diflags & XFS_DIFLAG_RTINHERIT)
  			di_flags |= XFS_DIFLAG_RTINHERIT;
- 		if (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {
+ 		if (pip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) {
  			di_flags |= XFS_DIFLAG_EXTSZINHERIT;
 -			ip->i_extsize = pip->i_extsize;
 +			ip->i_d.di_extsize = pip->i_d.di_extsize;
  		}
- 		if (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)
+ 		if (pip->i_diflags & XFS_DIFLAG_PROJINHERIT)
  			di_flags |= XFS_DIFLAG_PROJINHERIT;
  	} else if (S_ISREG(mode)) {
- 		if ((pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT) &&
+ 		if ((pip->i_diflags & XFS_DIFLAG_RTINHERIT) &&
  		    xfs_sb_version_hasrealtime(&ip->i_mount->m_sb))
  			di_flags |= XFS_DIFLAG_REALTIME;
- 		if (pip->i_d.di_flags & XFS_DIFLAG_EXTSZINHERIT) {
+ 		if (pip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) {
  			di_flags |= XFS_DIFLAG_EXTSIZE;
 -			ip->i_extsize = pip->i_extsize;
 +			ip->i_d.di_extsize = pip->i_d.di_extsize;
  		}
  	}
- 	if ((pip->i_d.di_flags & XFS_DIFLAG_NOATIME) &&
+ 	if ((pip->i_diflags & XFS_DIFLAG_NOATIME) &&
  	    xfs_inherit_noatime)
  		di_flags |= XFS_DIFLAG_NOATIME;
- 	if ((pip->i_d.di_flags & XFS_DIFLAG_NODUMP) &&
+ 	if ((pip->i_diflags & XFS_DIFLAG_NODUMP) &&
  	    xfs_inherit_nodump)
  		di_flags |= XFS_DIFLAG_NODUMP;
- 	if ((pip->i_d.di_flags & XFS_DIFLAG_SYNC) &&
+ 	if ((pip->i_diflags & XFS_DIFLAG_SYNC) &&
  	    xfs_inherit_sync)
  		di_flags |= XFS_DIFLAG_SYNC;
- 	if ((pip->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) &&
+ 	if ((pip->i_diflags & XFS_DIFLAG_NOSYMLINKS) &&
  	    xfs_inherit_nosymlinks)
  		di_flags |= XFS_DIFLAG_NOSYMLINKS;
- 	if ((pip->i_d.di_flags & XFS_DIFLAG_NODEFRAG) &&
+ 	if ((pip->i_diflags & XFS_DIFLAG_NODEFRAG) &&
  	    xfs_inherit_nodefrag)
  		di_flags |= XFS_DIFLAG_NODEFRAG;
- 	if (pip->i_d.di_flags & XFS_DIFLAG_FILESTREAM)
+ 	if (pip->i_diflags & XFS_DIFLAG_FILESTREAM)
  		di_flags |= XFS_DIFLAG_FILESTREAM;
  
- 	ip->i_d.di_flags |= di_flags;
+ 	ip->i_diflags |= di_flags;
  }
  
  /* Propagate di_flags2 from a parent inode to a child inode. */
@@@ -836,8 -839,8 +841,13 @@@ xfs_init_new_inode
  	inode->i_atime = tv;
  	inode->i_ctime = tv;
  
++<<<<<<< HEAD
 +	ip->i_d.di_extsize = 0;
 +	ip->i_d.di_flags = 0;
++=======
+ 	ip->i_extsize = 0;
+ 	ip->i_diflags = 0;
++>>>>>>> db07349da2f5 (xfs: move the di_flags field to struct xfs_inode)
  
  	if (xfs_sb_version_has_v3inode(&mp->m_sb)) {
  		inode_set_iversion(inode, 1);
@@@ -2584,9 -2611,9 +2594,9 @@@ xfs_ifree
  	}
  
  	VFS_I(ip)->i_mode = 0;		/* mark incore inode as free */
- 	ip->i_d.di_flags = 0;
+ 	ip->i_diflags = 0;
  	ip->i_d.di_flags2 = ip->i_mount->m_ino_geo.new_diflags2;
 -	ip->i_forkoff = 0;		/* mark the attr fork not in use */
 +	ip->i_d.di_forkoff = 0;		/* mark the attr fork not in use */
  	ip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;
  	if (xfs_iflags_test(ip, XFS_IPRESERVE_DM_FIELDS))
  		xfs_iflags_clear(ip, XFS_IPRESERVE_DM_FIELDS);
diff --cc fs/xfs/xfs_inode.h
index ab59fceed361,5a6c85e7209f..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -54,7 -54,17 +54,18 @@@ typedef struct xfs_inode 
  	/* Miscellaneous state. */
  	unsigned long		i_flags;	/* see defined flags below */
  	uint64_t		i_delayed_blks;	/* count of delay alloc blks */
 -	xfs_fsize_t		i_disk_size;	/* number of bytes in file */
 -	xfs_rfsblock_t		i_nblocks;	/* # of direct & btree blocks */
  	prid_t			i_projid;	/* owner's project id */
++<<<<<<< HEAD
++=======
+ 	xfs_extlen_t		i_extsize;	/* basic/minimum extent size */
+ 	/* cowextsize is only used for v3 inodes, flushiter for v1/2 */
+ 	union {
+ 		xfs_extlen_t	i_cowextsize;	/* basic cow extent size */
+ 		uint16_t	i_flushiter;	/* incremented on flush */
+ 	};
+ 	uint8_t			i_forkoff;	/* attr fork offset >> 3 */
+ 	uint16_t		i_diflags;	/* XFS_DIFLAG_... */
++>>>>>>> db07349da2f5 (xfs: move the di_flags field to struct xfs_inode)
  
  	struct xfs_icdinode	i_d;		/* most of ondisk inode */
  
diff --cc fs/xfs/xfs_ioctl.c
index 0b05f7dd7822,cf54cf58e2db..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1511,16 -1520,17 +1511,21 @@@ xfs_ioctl_setattr
  	 * extent size hint should be set on the inode. If no extent size flags
  	 * are set on the inode then unconditionally clear the extent size hint.
  	 */
++<<<<<<< HEAD
 +	if (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
 +		ip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;
++=======
+ 	if (ip->i_diflags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
+ 		ip->i_extsize = XFS_B_TO_FSB(mp, fa->fsx_extsize);
++>>>>>>> db07349da2f5 (xfs: move the di_flags field to struct xfs_inode)
  	else
 -		ip->i_extsize = 0;
 -
 -	if (xfs_sb_version_has_v3inode(&mp->m_sb)) {
 -		if (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE)
 -			ip->i_cowextsize = XFS_B_TO_FSB(mp, fa->fsx_cowextsize);
 -		else
 -			ip->i_cowextsize = 0;
 -	}
 +		ip->i_d.di_extsize = 0;
 +	if (xfs_sb_version_has_v3inode(&mp->m_sb) &&
 +	    (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE))
 +		ip->i_d.di_cowextsize = fa->fsx_cowextsize >>
 +				mp->m_sb.sb_blocklog;
 +	else
 +		ip->i_d.di_cowextsize = 0;
  
  	error = xfs_trans_commit(tp);
  
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index 976659190d27..e8962ddd4ba3 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -183,7 +183,7 @@ xfs_bmbt_update_cursor(
 	struct xfs_btree_cur	*dst)
 {
 	ASSERT((dst->bc_tp->t_firstblock != NULLFSBLOCK) ||
-	       (dst->bc_ino.ip->i_d.di_flags & XFS_DIFLAG_REALTIME));
+	       (dst->bc_ino.ip->i_diflags & XFS_DIFLAG_REALTIME));
 
 	dst->bc_ino.allocated += src->bc_ino.allocated;
 	dst->bc_tp->t_firstblock = src->bc_tp->t_firstblock;
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.h
diff --git a/fs/xfs/libxfs/xfs_rtbitmap.c b/fs/xfs/libxfs/xfs_rtbitmap.c
index fe3a49575ff3..483375c6a735 100644
--- a/fs/xfs/libxfs/xfs_rtbitmap.c
+++ b/fs/xfs/libxfs/xfs_rtbitmap.c
@@ -997,8 +997,8 @@ xfs_rtfree_extent(
 	 */
 	if (tp->t_frextents_delta + mp->m_sb.sb_frextents ==
 	    mp->m_sb.sb_rextents) {
-		if (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))
-			mp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;
+		if (!(mp->m_rbmip->i_diflags & XFS_DIFLAG_NEWRTBM))
+			mp->m_rbmip->i_diflags |= XFS_DIFLAG_NEWRTBM;
 		*(uint64_t *)&VFS_I(mp->m_rbmip)->i_atime = 0;
 		xfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);
 	}
diff --git a/fs/xfs/scrub/common.c b/fs/xfs/scrub/common.c
index 6bbe295c2f7a..9376d7794354 100644
--- a/fs/xfs/scrub/common.c
+++ b/fs/xfs/scrub/common.c
@@ -820,7 +820,7 @@ xchk_metadata_inode_forks(
 		return 0;
 
 	/* Metadata inodes don't live on the rt device. */
-	if (sc->ip->i_d.di_flags & XFS_DIFLAG_REALTIME) {
+	if (sc->ip->i_diflags & XFS_DIFLAG_REALTIME) {
 		xchk_ino_set_corrupt(sc, sc->ip->i_ino);
 		return 0;
 	}
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index 4289f7de99b7..5dfb21c52a04 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -439,7 +439,7 @@ xfs_getbmap(
 		}
 
 		if (xfs_get_extsz_hint(ip) ||
-		    (ip->i_d.di_flags &
+		    (ip->i_diflags &
 		     (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND)))
 			max_len = mp->m_super->s_maxbytes;
 		else
@@ -620,7 +620,7 @@ xfs_can_free_eofblocks(struct xfs_inode *ip, bool force)
 	 * Do not free real preallocated or append-only files unless the file
 	 * has delalloc blocks and we are forced to remove them.
 	 */
-	if (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))
+	if (ip->i_diflags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))
 		if (!force || ip->i_delayed_blks == 0)
 			return false;
 
diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c
index d7d8b957f1f5..0926c60ed589 100644
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@ -89,9 +89,9 @@ xfs_update_prealloc_flags(
 	}
 
 	if (flags & XFS_PREALLOC_SET)
-		ip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;
+		ip->i_diflags |= XFS_DIFLAG_PREALLOC;
 	if (flags & XFS_PREALLOC_CLEAR)
-		ip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;
+		ip->i_diflags &= ~XFS_DIFLAG_PREALLOC;
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 	if (flags & XFS_PREALLOC_SYNC)
diff --git a/fs/xfs/xfs_filestream.h b/fs/xfs/xfs_filestream.h
index 5cc7665e93c9..3af963743e4d 100644
--- a/fs/xfs/xfs_filestream.h
+++ b/fs/xfs/xfs_filestream.h
@@ -22,7 +22,7 @@ xfs_inode_is_filestream(
 	struct xfs_inode	*ip)
 {
 	return (ip->i_mount->m_flags & XFS_MOUNT_FILESTREAMS) ||
-		(ip->i_d.di_flags & XFS_DIFLAG_FILESTREAM);
+		(ip->i_diflags & XFS_DIFLAG_FILESTREAM);
 }
 
 #endif /* __XFS_FILESTREAM_H__ */
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_inode.h
diff --git a/fs/xfs/xfs_inode_item.c b/fs/xfs/xfs_inode_item.c
index 342023fbc07e..5faeaa96635c 100644
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@ -390,7 +390,7 @@ xfs_inode_to_log_dinode(
 	to->di_anextents = xfs_ifork_nextents(ip->i_afp);
 	to->di_forkoff = from->di_forkoff;
 	to->di_aformat = xfs_ifork_format(ip->i_afp);
-	to->di_flags = from->di_flags;
+	to->di_flags = ip->i_diflags;
 
 	xfs_copy_dm_fields_to_log_dinode(ip, to);
 
* Unmerged path fs/xfs/xfs_ioctl.c
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 1a5880c79e28..36e875382015 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -545,11 +545,11 @@ xfs_vn_getattr(
 	 * Note: If you add another clause to set an attribute flag, please
 	 * update attributes_mask below.
 	 */
-	if (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)
+	if (ip->i_diflags & XFS_DIFLAG_IMMUTABLE)
 		stat->attributes |= STATX_ATTR_IMMUTABLE;
-	if (ip->i_d.di_flags & XFS_DIFLAG_APPEND)
+	if (ip->i_diflags & XFS_DIFLAG_APPEND)
 		stat->attributes |= STATX_ATTR_APPEND;
-	if (ip->i_d.di_flags & XFS_DIFLAG_NODUMP)
+	if (ip->i_diflags & XFS_DIFLAG_NODUMP)
 		stat->attributes |= STATX_ATTR_NODUMP;
 
 	stat->attributes_mask |= (STATX_ATTR_IMMUTABLE |
diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h
index af6be9b9ccdf..7688663b9773 100644
--- a/fs/xfs/xfs_linux.h
+++ b/fs/xfs/xfs_linux.h
@@ -233,7 +233,7 @@ int xfs_rw_bdev(struct block_device *bdev, sector_t sector, unsigned int count,
  * configured realtime device.
  */
 #define XFS_IS_REALTIME_INODE(ip)			\
-	(((ip)->i_d.di_flags & XFS_DIFLAG_REALTIME) &&	\
+	(((ip)->i_diflags & XFS_DIFLAG_REALTIME) &&	\
 	 (ip)->i_mount->m_rtdev_targp)
 #define XFS_IS_REALTIME_MOUNT(mp) ((mp)->m_rtdev_targp ? 1 : 0)
 #else
diff --git a/fs/xfs/xfs_rtalloc.c b/fs/xfs/xfs_rtalloc.c
index 161b0e8992ba..79fda6099c3c 100644
--- a/fs/xfs/xfs_rtalloc.c
+++ b/fs/xfs/xfs_rtalloc.c
@@ -1318,8 +1318,8 @@ xfs_rtpick_extent(
 	ASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));
 
 	seqp = (uint64_t *)&VFS_I(mp->m_rbmip)->i_atime;
-	if (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM)) {
-		mp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;
+	if (!(mp->m_rbmip->i_diflags & XFS_DIFLAG_NEWRTBM)) {
+		mp->m_rbmip->i_diflags |= XFS_DIFLAG_NEWRTBM;
 		*seqp = 0;
 	}
 	seq = *seqp;
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index cb55e77ebc47..2818f071e9a7 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -836,13 +836,13 @@ xfs_fs_statfs(
 	statp->f_ffree = max_t(int64_t, ffree, 0);
 
 
-	if ((ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
+	if ((ip->i_diflags & XFS_DIFLAG_PROJINHERIT) &&
 	    ((mp->m_qflags & (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))) ==
 			      (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))
 		xfs_qm_statvfs(ip, statp);
 
 	if (XFS_IS_REALTIME_MOUNT(mp) &&
-	    (ip->i_d.di_flags & (XFS_DIFLAG_RTINHERIT | XFS_DIFLAG_REALTIME))) {
+	    (ip->i_diflags & (XFS_DIFLAG_RTINHERIT | XFS_DIFLAG_REALTIME))) {
 		statp->f_blocks = sbp->sb_rblocks;
 		statp->f_bavail = statp->f_bfree =
 			sbp->sb_frextents * sbp->sb_rextsize;
diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c
index 6b6bafbb12c3..c0cfc57af01b 100644
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@ -217,7 +217,7 @@ xfs_symlink(
 	/*
 	 * Check whether the directory allows new symlinks or not.
 	 */
-	if (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {
+	if (dp->i_diflags & XFS_DIFLAG_NOSYMLINKS) {
 		error = -EPERM;
 		goto out_trans_cancel;
 	}
