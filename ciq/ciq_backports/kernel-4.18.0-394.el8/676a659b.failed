xfs: retry allocations when locality-based search fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 676a659b60afb13166371580f3f6f434e9ba6f21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/676a659b.failed

If a realtime allocation fails because we can't find a sufficiently
large free extent satisfying locality rules, relax the locality rules
and try again.  This reduces the occurrence of short writes to realtime
files when the write size is large and the free space is fragmented.

This was originally discovered by running generic/186 with the realtime
reflink patchset and a 128k cow extent size hint, but the short write
symptoms can manifest with a 128k extent size hint and no reflink, so
apply the fix now.

	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Allison Henderson <allison.henderson@oracle.com>
(cherry picked from commit 676a659b60afb13166371580f3f6f434e9ba6f21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index c240d29fdc85,0936f3a96fe6..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -71,18 -71,24 +71,34 @@@ xfs_zero_extent
  #ifdef CONFIG_XFS_RT
  int
  xfs_bmap_rtalloc(
 -	struct xfs_bmalloca	*ap)
 +	struct xfs_bmalloca	*ap)	/* bmap alloc argument struct */
  {
++<<<<<<< HEAD
 +	int		error;		/* error return value */
 +	xfs_mount_t	*mp;		/* mount point structure */
 +	xfs_extlen_t	prod = 0;	/* product factor for allocators */
 +	xfs_extlen_t	mod = 0;	/* product factor for allocators */
 +	xfs_extlen_t	ralen = 0;	/* realtime allocation length */
 +	xfs_extlen_t	align;		/* minimum allocation alignment */
 +	xfs_rtblock_t	rtb;
++=======
+ 	struct xfs_mount	*mp = ap->ip->i_mount;
+ 	xfs_fileoff_t		orig_offset = ap->offset;
+ 	xfs_rtblock_t		rtb;
+ 	xfs_extlen_t		prod = 0;  /* product factor for allocators */
+ 	xfs_extlen_t		mod = 0;   /* product factor for allocators */
+ 	xfs_extlen_t		ralen = 0; /* realtime allocation length */
+ 	xfs_extlen_t		align;     /* minimum allocation alignment */
+ 	xfs_extlen_t		orig_length = ap->length;
+ 	xfs_extlen_t		minlen = mp->m_sb.sb_rextsize;
+ 	xfs_extlen_t		raminlen;
+ 	bool			rtlocked = false;
+ 	bool			ignore_locality = false;
+ 	int			error;
++>>>>>>> 676a659b60af (xfs: retry allocations when locality-based search fails)
  
 +	mp = ap->ip->i_mount;
  	align = xfs_get_extsz_hint(ap->ip);
 -retry:
  	prod = align / mp->m_sb.sb_rextsize;
  	error = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,
  					align, 1, ap->eof, 0,
@@@ -141,11 -159,15 +157,14 @@@
  	/*
  	 * Realtime allocation, done through xfs_rtallocate_extent.
  	 */
- 	do_div(ap->blkno, mp->m_sb.sb_rextsize);
+ 	if (ignore_locality)
+ 		ap->blkno = 0;
+ 	else
+ 		do_div(ap->blkno, mp->m_sb.sb_rextsize);
  	rtb = ap->blkno;
  	ap->length = ralen;
 -	raminlen = max_t(xfs_extlen_t, 1, minlen / mp->m_sb.sb_rextsize);
 -	error = xfs_rtallocate_extent(ap->tp, ap->blkno, raminlen, ap->length,
 -			&ralen, ap->wasdel, prod, &rtb);
 +	error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1, ap->length,
 +				&ralen, ap->wasdel, prod, &rtb);
  	if (error)
  		return error;
  
@@@ -164,10 -184,34 +183,38 @@@
  		 */
  		xfs_trans_mod_dquot_byino(ap->tp, ap->ip,
  			ap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :
 -					XFS_TRANS_DQ_RTBCOUNT, ap->length);
 -		return 0;
 +					XFS_TRANS_DQ_RTBCOUNT, (long) ralen);
 +	} else {
 +		ap->length = 0;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (align > mp->m_sb.sb_rextsize) {
+ 		/*
+ 		 * We previously enlarged the request length to try to satisfy
+ 		 * an extent size hint.  The allocator didn't return anything,
+ 		 * so reset the parameters to the original values and try again
+ 		 * without alignment criteria.
+ 		 */
+ 		ap->offset = orig_offset;
+ 		ap->length = orig_length;
+ 		minlen = align = mp->m_sb.sb_rextsize;
+ 		goto retry;
+ 	}
+ 
+ 	if (!ignore_locality && ap->blkno != 0) {
+ 		/*
+ 		 * If we can't allocate near a specific rt extent, try again
+ 		 * without locality criteria.
+ 		 */
+ 		ignore_locality = true;
+ 		goto retry;
+ 	}
+ 
+ 	ap->blkno = NULLFSBLOCK;
+ 	ap->length = 0;
++>>>>>>> 676a659b60af (xfs: retry allocations when locality-based search fails)
  	return 0;
  }
  #endif /* CONFIG_XFS_RT */
* Unmerged path fs/xfs/xfs_bmap_util.c
