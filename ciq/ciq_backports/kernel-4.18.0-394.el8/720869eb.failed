NFS: Separate tracking of file mode cache validity from the uid/gid

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 720869eb19f3161980d6d4631d3df7e8c5355993
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/720869eb.failed

chown()/chgrp() and chmod() are separate operations, and in addition,
there are mode operations that are performed automatically by the
server. So let's track mode validity separately from the file ownership
validity.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 720869eb19f3161980d6d4631d3df7e8c5355993)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/dir.c
#	fs/nfs/inode.c
#	fs/nfs/nfs4proc.c
#	fs/nfs/nfstrace.h
#	include/linux/nfs_fs.h
diff --cc fs/nfs/dir.c
index 5ac7490c4e59,d2835d211a73..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -2998,9 -3006,10 +2998,14 @@@ out_notsup
  	if (mask & MAY_NOT_BLOCK)
  		return -ECHILD;
  
++<<<<<<< HEAD
 +	res = nfs_revalidate_inode(NFS_SERVER(inode), inode);
++=======
+ 	res = nfs_revalidate_inode(inode, NFS_INO_INVALID_MODE |
+ 						  NFS_INO_INVALID_OTHER);
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  	if (res == 0)
 -		res = generic_permission(&init_user_ns, inode, mask);
 +		res = generic_permission(inode, mask);
  	goto out;
  }
  EXPORT_SYMBOL_GPL(nfs_permission);
diff --cc fs/nfs/inode.c
index 8e864cad6b0c,81e3e140e923..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -801,18 -789,32 +802,41 @@@ static void nfs_readdirplus_parent_cach
  	dput(parent);
  }
  
 -static u32 nfs_get_valid_attrmask(struct inode *inode)
 +static bool nfs_need_revalidate_inode(struct inode *inode)
  {
++<<<<<<< HEAD
 +	if (NFS_I(inode)->cache_validity &
 +			(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))
 +		return true;
 +	if (nfs_attribute_cache_expired(inode))
 +		return true;
 +	return false;
++=======
+ 	unsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);
+ 	u32 reply_mask = STATX_INO | STATX_TYPE;
+ 
+ 	if (!(cache_validity & NFS_INO_INVALID_ATIME))
+ 		reply_mask |= STATX_ATIME;
+ 	if (!(cache_validity & NFS_INO_INVALID_CTIME))
+ 		reply_mask |= STATX_CTIME;
+ 	if (!(cache_validity & NFS_INO_INVALID_MTIME))
+ 		reply_mask |= STATX_MTIME;
+ 	if (!(cache_validity & NFS_INO_INVALID_SIZE))
+ 		reply_mask |= STATX_SIZE;
+ 	if (!(cache_validity & NFS_INO_INVALID_NLINK))
+ 		reply_mask |= STATX_NLINK;
+ 	if (!(cache_validity & NFS_INO_INVALID_MODE))
+ 		reply_mask |= STATX_MODE;
+ 	if (!(cache_validity & NFS_INO_INVALID_OTHER))
+ 		reply_mask |= STATX_UID | STATX_GID;
+ 	if (!(cache_validity & NFS_INO_INVALID_BLOCKS))
+ 		reply_mask |= STATX_BLOCKS;
+ 	return reply_mask;
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  }
  
 -int nfs_getattr(struct user_namespace *mnt_userns, const struct path *path,
 -		struct kstat *stat, u32 request_mask, unsigned int query_flags)
 +int nfs_getattr(const struct path *path, struct kstat *stat,
 +		u32 request_mask, unsigned int query_flags)
  {
  	struct inode *inode = d_inode(path->dentry);
  	struct nfs_server *server = NFS_SERVER(inode);
@@@ -871,7 -873,11 +895,15 @@@
  		do_update |= cache_validity & NFS_INO_INVALID_MTIME;
  	if (request_mask & STATX_SIZE)
  		do_update |= cache_validity & NFS_INO_INVALID_SIZE;
++<<<<<<< HEAD
 +	if (request_mask & (STATX_UID | STATX_GID | STATX_MODE | STATX_NLINK))
++=======
+ 	if (request_mask & STATX_NLINK)
+ 		do_update |= cache_validity & NFS_INO_INVALID_NLINK;
+ 	if (request_mask & STATX_MODE)
+ 		do_update |= cache_validity & NFS_INO_INVALID_MODE;
+ 	if (request_mask & (STATX_UID | STATX_GID))
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  		do_update |= cache_validity & NFS_INO_INVALID_OTHER;
  	if (request_mask & STATX_BLOCKS)
  		do_update |= cache_validity & NFS_INO_INVALID_BLOCKS;
@@@ -1949,6 -1951,8 +1981,11 @@@ static int nfs_update_inode(struct inod
  					| NFS_INO_INVALID_MTIME
  					| NFS_INO_INVALID_SIZE
  					| NFS_INO_INVALID_BLOCKS
++<<<<<<< HEAD
++=======
+ 					| NFS_INO_INVALID_NLINK
+ 					| NFS_INO_INVALID_MODE
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  					| NFS_INO_INVALID_OTHER;
  				if (S_ISDIR(inode->i_mode))
  					nfs_force_lookup_revalidate(inode);
diff --cc fs/nfs/nfs4proc.c
index 599edfec3dbe,bc90f2a12d5d..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -5402,10 -5434,12 +5405,18 @@@ static void nfs4_bitmask_set(__u32 bitm
  		bitmask[0] |= FATTR4_WORD0_CHANGE;
  	if (cache_validity & NFS_INO_INVALID_ATIME)
  		bitmask[1] |= FATTR4_WORD1_TIME_ACCESS;
+ 	if (cache_validity & NFS_INO_INVALID_MODE)
+ 		bitmask[1] |= FATTR4_WORD1_MODE;
  	if (cache_validity & NFS_INO_INVALID_OTHER)
++<<<<<<< HEAD
 +		bitmask[1] |= FATTR4_WORD1_MODE | FATTR4_WORD1_OWNER |
 +				FATTR4_WORD1_OWNER_GROUP |
 +				FATTR4_WORD1_NUMLINKS;
++=======
+ 		bitmask[1] |= FATTR4_WORD1_OWNER | FATTR4_WORD1_OWNER_GROUP;
+ 	if (cache_validity & NFS_INO_INVALID_NLINK)
+ 		bitmask[1] |= FATTR4_WORD1_NUMLINKS;
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  	if (label && label->len && cache_validity & NFS_INO_INVALID_LABEL)
  		bitmask[2] |= FATTR4_WORD2_SECURITY_LABEL;
  	if (cache_validity & NFS_INO_INVALID_CTIME)
diff --cc fs/nfs/nfstrace.h
index 2f72045b3d3a,41a161cd31f6..000000000000
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@@ -48,6 -48,8 +48,11 @@@ TRACE_DEFINE_ENUM(NFS_INO_INVALID_OTHER
  TRACE_DEFINE_ENUM(NFS_INO_DATA_INVAL_DEFER);
  TRACE_DEFINE_ENUM(NFS_INO_INVALID_BLOCKS);
  TRACE_DEFINE_ENUM(NFS_INO_INVALID_XATTR);
++<<<<<<< HEAD
++=======
+ TRACE_DEFINE_ENUM(NFS_INO_INVALID_NLINK);
+ TRACE_DEFINE_ENUM(NFS_INO_INVALID_MODE);
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  
  #define nfs_show_cache_validity(v) \
  	__print_flags(v, "|", \
@@@ -65,7 -67,9 +70,13 @@@
  			{ NFS_INO_INVALID_OTHER, "INVALID_OTHER" }, \
  			{ NFS_INO_DATA_INVAL_DEFER, "DATA_INVAL_DEFER" }, \
  			{ NFS_INO_INVALID_BLOCKS, "INVALID_BLOCKS" }, \
++<<<<<<< HEAD
 +			{ NFS_INO_INVALID_XATTR, "INVALID_XATTR" })
++=======
+ 			{ NFS_INO_INVALID_XATTR, "INVALID_XATTR" }, \
+ 			{ NFS_INO_INVALID_NLINK, "INVALID_NLINK" }, \
+ 			{ NFS_INO_INVALID_MODE, "INVALID_MODE" })
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  
  TRACE_DEFINE_ENUM(NFS_INO_ADVISE_RDPLUS);
  TRACE_DEFINE_ENUM(NFS_INO_STALE);
diff --cc include/linux/nfs_fs.h
index 469010ea1e47,ffba254d2098..000000000000
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@@ -245,11 -246,15 +245,21 @@@ struct nfs4_copy_state 
  				BIT(13)		/* Deferred cache invalidation */
  #define NFS_INO_INVALID_BLOCKS	BIT(14)         /* cached blocks are invalid */
  #define NFS_INO_INVALID_XATTR	BIT(15)		/* xattrs are invalid */
++<<<<<<< HEAD
++=======
+ #define NFS_INO_INVALID_NLINK	BIT(16)		/* cached nlinks is invalid */
+ #define NFS_INO_INVALID_MODE	BIT(17)		/* cached mode is invalid */
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  
  #define NFS_INO_INVALID_ATTR	(NFS_INO_INVALID_CHANGE \
  		| NFS_INO_INVALID_CTIME \
  		| NFS_INO_INVALID_MTIME \
  		| NFS_INO_INVALID_SIZE \
++<<<<<<< HEAD
++=======
+ 		| NFS_INO_INVALID_NLINK \
+ 		| NFS_INO_INVALID_MODE \
++>>>>>>> 720869eb19f3 (NFS: Separate tracking of file mode cache validity from the uid/gid)
  		| NFS_INO_INVALID_OTHER)	/* inode metadata is invalid */
  
  /*
* Unmerged path fs/nfs/dir.c
* Unmerged path fs/nfs/inode.c
* Unmerged path fs/nfs/nfs4proc.c
* Unmerged path fs/nfs/nfstrace.h
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 4cfbae489405..872ec155844f 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -1593,7 +1593,7 @@ static int nfs_writeback_done(struct rpc_task *task,
 	/* Deal with the suid/sgid bit corner case */
 	if (nfs_should_remove_suid(inode)) {
 		spin_lock(&inode->i_lock);
-		nfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);
+		nfs_set_cache_invalid(inode, NFS_INO_INVALID_MODE);
 		spin_unlock(&inode->i_lock);
 	}
 	return 0;
* Unmerged path include/linux/nfs_fs.h
