NFSD: Replace READ* macros that decode the fattr4 umask attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 66f0476c704c86d44aa9da19d4753df66f2dbc96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/66f0476c.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 66f0476c704c86d44aa9da19d4753df66f2dbc96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 148fec779d69,934cbae85ea7..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -380,8 -358,6 +380,11 @@@ nfsd4_decode_fattr(struct nfsd4_compoun
  {
  	unsigned int starting_pos;
  	u32 attrlist4_count;
++<<<<<<< HEAD
 +	u32 dummy32;
 +	char *buf;
++=======
++>>>>>>> 66f0476c704c (NFSD: Replace READ* macros that decode the fattr4 umask attribute)
  
  	DECODE_HEAD;
  	iattr->ia_valid = 0;
@@@ -530,29 -468,21 +533,32 @@@
  	label->len = 0;
  	if (IS_ENABLED(CONFIG_NFSD_V4_SECURITY_LABEL) &&
  	    bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {
 -		status = nfsd4_decode_security_label(argp, label);
 -		if (status)
 -			return status;
 +		READ_BUF(4);
 +		dummy32 = be32_to_cpup(p++); /* lfs: we don't use it */
 +		READ_BUF(4);
 +		dummy32 = be32_to_cpup(p++); /* pi: we don't use it either */
 +		READ_BUF(4);
 +		dummy32 = be32_to_cpup(p++);
 +		READ_BUF(dummy32);
 +		if (dummy32 > NFS4_MAXLABELLEN)
 +			return nfserr_badlabel;
 +		READMEM(buf, dummy32);
 +		label->len = dummy32;
 +		label->data = svcxdr_dupstr(argp, buf, dummy32);
 +		if (!label->data)
 +			return nfserr_jukebox;
  	}
  	if (bmval[2] & FATTR4_WORD2_MODE_UMASK) {
+ 		u32 mode, mask;
+ 
  		if (!umask)
- 			goto xdr_error;
- 		READ_BUF(8);
- 		dummy32 = be32_to_cpup(p++);
- 		iattr->ia_mode = dummy32 & (S_IFMT | S_IALLUGO);
- 		dummy32 = be32_to_cpup(p++);
- 		*umask = dummy32 & S_IRWXUGO;
+ 			return nfserr_bad_xdr;
+ 		if (xdr_stream_decode_u32(argp->xdr, &mode) < 0)
+ 			return nfserr_bad_xdr;
+ 		iattr->ia_mode = mode & (S_IFMT | S_IALLUGO);
+ 		if (xdr_stream_decode_u32(argp->xdr, &mask) < 0)
+ 			return nfserr_bad_xdr;
+ 		*umask = mask & S_IRWXUGO;
  		iattr->ia_valid |= ATTR_MODE;
  	}
  
* Unmerged path fs/nfsd/nfs4xdr.c
