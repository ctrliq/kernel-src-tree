xfs: move the di_nblocks field to struct xfs_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 6e73a545f91e128d8dd7da1769dca200225f5d82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/6e73a545.failed

In preparation of removing the historic icinode struct, move the nblocks
field into the containing xfs_inode structure.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 6e73a545f91e128d8dd7da1769dca200225f5d82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_inode_buf.h
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_inode.h
#	fs/xfs/xfs_inode_item.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 671aeb012e3f,e699669039c3..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -226,8 -226,8 +226,13 @@@ xfs_inode_from_disk
  	inode->i_mtime = xfs_inode_from_disk_ts(from, from->di_mtime);
  	inode->i_ctime = xfs_inode_from_disk_ts(from, from->di_ctime);
  
++<<<<<<< HEAD
 +	to->di_size = be64_to_cpu(from->di_size);
 +	to->di_nblocks = be64_to_cpu(from->di_nblocks);
++=======
+ 	ip->i_disk_size = be64_to_cpu(from->di_size);
+ 	ip->i_nblocks = be64_to_cpu(from->di_nblocks);
++>>>>>>> 6e73a545f91e (xfs: move the di_nblocks field to struct xfs_inode)
  	to->di_extsize = be32_to_cpu(from->di_extsize);
  	to->di_forkoff = from->di_forkoff;
  	to->di_flags	= be16_to_cpu(from->di_flags);
@@@ -305,8 -305,8 +310,13 @@@ xfs_inode_to_disk
  	to->di_gen = cpu_to_be32(inode->i_generation);
  	to->di_mode = cpu_to_be16(inode->i_mode);
  
++<<<<<<< HEAD
 +	to->di_size = cpu_to_be64(from->di_size);
 +	to->di_nblocks = cpu_to_be64(from->di_nblocks);
++=======
+ 	to->di_size = cpu_to_be64(ip->i_disk_size);
+ 	to->di_nblocks = cpu_to_be64(ip->i_nblocks);
++>>>>>>> 6e73a545f91e (xfs: move the di_nblocks field to struct xfs_inode)
  	to->di_extsize = cpu_to_be32(from->di_extsize);
  	to->di_nextents = cpu_to_be32(xfs_ifork_nextents(&ip->i_df));
  	to->di_anextents = cpu_to_be16(xfs_ifork_nextents(ip->i_afp));
diff --cc fs/xfs/libxfs/xfs_inode_buf.h
index 406f66799288,f4e1a9010b0a..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.h
+++ b/fs/xfs/libxfs/xfs_inode_buf.h
@@@ -17,8 -17,6 +17,11 @@@ struct xfs_dinode
   */
  struct xfs_icdinode {
  	uint16_t	di_flushiter;	/* incremented on flush */
++<<<<<<< HEAD
 +	xfs_fsize_t	di_size;	/* number of bytes in file */
 +	xfs_rfsblock_t	di_nblocks;	/* # of direct & btree blocks used */
++=======
++>>>>>>> 6e73a545f91e (xfs: move the di_nblocks field to struct xfs_inode)
  	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
  	uint8_t		di_forkoff;	/* attr fork offs, <<3 for 64b align */
  	uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
diff --cc fs/xfs/xfs_inode.c
index d856a2225b9c,30abf7975924..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -824,12 -826,13 +824,12 @@@ xfs_init_new_inode
  	 * (and only if the irix_sgid_inherit compatibility variable is set).
  	 */
  	if (irix_sgid_inherit &&
 -	    (inode->i_mode & S_ISGID) &&
 -	    !in_group_p(i_gid_into_mnt(mnt_userns, inode)))
 +	    (inode->i_mode & S_ISGID) && !in_group_p(inode->i_gid))
  		inode->i_mode &= ~S_ISGID;
  
 -	ip->i_disk_size = 0;
 +	ip->i_d.di_size = 0;
  	ip->i_df.if_nextents = 0;
- 	ASSERT(ip->i_d.di_nblocks == 0);
+ 	ASSERT(ip->i_nblocks == 0);
  
  	tv = current_time(inode);
  	inode->i_mtime = tv;
@@@ -2558,8 -2585,8 +2558,13 @@@ xfs_ifree
  	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
  	ASSERT(VFS_I(ip)->i_nlink == 0);
  	ASSERT(ip->i_df.if_nextents == 0);
++<<<<<<< HEAD
 +	ASSERT(ip->i_d.di_size == 0 || !S_ISREG(VFS_I(ip)->i_mode));
 +	ASSERT(ip->i_d.di_nblocks == 0);
++=======
+ 	ASSERT(ip->i_disk_size == 0 || !S_ISREG(VFS_I(ip)->i_mode));
+ 	ASSERT(ip->i_nblocks == 0);
++>>>>>>> 6e73a545f91e (xfs: move the di_nblocks field to struct xfs_inode)
  
  	/*
  	 * Pull the on-disk inode from the AGI unlinked list.
diff --cc fs/xfs/xfs_inode.h
index ab59fceed361,687bb41f7da4..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -54,6 -54,8 +54,11 @@@ typedef struct xfs_inode 
  	/* Miscellaneous state. */
  	unsigned long		i_flags;	/* see defined flags below */
  	uint64_t		i_delayed_blks;	/* count of delay alloc blks */
++<<<<<<< HEAD
++=======
+ 	xfs_fsize_t		i_disk_size;	/* number of bytes in file */
+ 	xfs_rfsblock_t		i_nblocks;	/* # of direct & btree blocks */
++>>>>>>> 6e73a545f91e (xfs: move the di_nblocks field to struct xfs_inode)
  	prid_t			i_projid;	/* owner's project id */
  
  	struct xfs_icdinode	i_d;		/* most of ondisk inode */
diff --cc fs/xfs/xfs_inode_item.c
index 342023fbc07e,1d01cabc2db1..000000000000
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@@ -383,8 -369,8 +383,13 @@@ xfs_inode_to_log_dinode
  	to->di_gen = inode->i_generation;
  	to->di_mode = inode->i_mode;
  
++<<<<<<< HEAD
 +	to->di_size = from->di_size;
 +	to->di_nblocks = from->di_nblocks;
++=======
+ 	to->di_size = ip->i_disk_size;
+ 	to->di_nblocks = ip->i_nblocks;
++>>>>>>> 6e73a545f91e (xfs: move the di_nblocks field to struct xfs_inode)
  	to->di_extsize = from->di_extsize;
  	to->di_nextents = xfs_ifork_nextents(&ip->i_df);
  	to->di_anextents = xfs_ifork_nextents(ip->i_afp);
diff --git a/fs/xfs/libxfs/xfs_bmap.c b/fs/xfs/libxfs/xfs_bmap.c
index 09b89e8dc50f..0c5b126b642a 100644
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@ -624,7 +624,7 @@ xfs_bmap_btree_to_extents(
 		return error;
 	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, whichfork);
 	xfs_bmap_add_free(cur->bc_tp, cbno, 1, &oinfo);
-	ip->i_d.di_nblocks--;
+	ip->i_nblocks--;
 	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
 	xfs_trans_binval(tp, cbp);
 	if (cur->bc_bufs[0] == cbp)
@@ -726,7 +726,7 @@ xfs_bmap_extents_to_btree(
 	       args.agno >= XFS_FSB_TO_AGNO(mp, tp->t_firstblock));
 	tp->t_firstblock = args.fsbno;
 	cur->bc_ino.allocated++;
-	ip->i_d.di_nblocks++;
+	ip->i_nblocks++;
 	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);
 	error = xfs_trans_get_buf(tp, mp->m_ddev_targp,
 			XFS_FSB_TO_DADDR(mp, args.fsbno),
@@ -908,7 +908,7 @@ xfs_bmap_local_to_extents(
 	xfs_iext_insert(ip, &icur, &rec, 0);
 
 	ifp->if_nextents = 1;
-	ip->i_d.di_nblocks = 1;
+	ip->i_nblocks = 1;
 	xfs_trans_mod_dquot_byino(tp, ip,
 		XFS_TRANS_DQ_BCOUNT, 1L);
 	flags |= xfs_ilog_fext(whichfork);
@@ -3444,7 +3444,7 @@ xfs_bmap_btalloc_accounting(
 	}
 
 	/* data/attr fork only */
-	ap->ip->i_d.di_nblocks += args->len;
+	ap->ip->i_nblocks += args->len;
 	xfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);
 	if (ap->wasdel) {
 		ap->ip->i_delayed_blks -= args->len;
@@ -4766,7 +4766,7 @@ xfs_bmapi_remap(
 		ASSERT(got.br_startoff - bno >= len);
 	}
 
-	ip->i_d.di_nblocks += len;
+	ip->i_nblocks += len;
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 
 	if (ifp->if_flags & XFS_IFBROOT) {
@@ -5357,7 +5357,7 @@ xfs_bmap_del_extent_real(
 	 * Adjust inode # blocks in the file.
 	 */
 	if (nblks)
-		ip->i_d.di_nblocks -= nblks;
+		ip->i_nblocks -= nblks;
 	/*
 	 * Adjust quota data.
 	 */
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index 976659190d27..520db0c8f10a 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -260,7 +260,7 @@ xfs_bmbt_alloc_block(
 	ASSERT(args.len == 1);
 	cur->bc_tp->t_firstblock = args.fsbno;
 	cur->bc_ino.allocated++;
-	cur->bc_ino.ip->i_d.di_nblocks++;
+	cur->bc_ino.ip->i_nblocks++;
 	xfs_trans_log_inode(args.tp, cur->bc_ino.ip, XFS_ILOG_CORE);
 	xfs_trans_mod_dquot_byino(args.tp, cur->bc_ino.ip,
 			XFS_TRANS_DQ_BCOUNT, 1L);
@@ -287,7 +287,7 @@ xfs_bmbt_free_block(
 
 	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, cur->bc_ino.whichfork);
 	xfs_bmap_add_free(cur->bc_tp, fsbno, 1, &oinfo);
-	ip->i_d.di_nblocks--;
+	ip->i_nblocks--;
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
diff --git a/fs/xfs/libxfs/xfs_da_btree.c b/fs/xfs/libxfs/xfs_da_btree.c
index e46bc03365db..83ac9771bfb5 100644
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@ -2145,7 +2145,7 @@ xfs_da_grow_inode_int(
 	struct xfs_trans	*tp = args->trans;
 	struct xfs_inode	*dp = args->dp;
 	int			w = args->whichfork;
-	xfs_rfsblock_t		nblks = dp->i_d.di_nblocks;
+	xfs_rfsblock_t		nblks = dp->i_nblocks;
 	struct xfs_bmbt_irec	map, *mapp;
 	int			nmap, error, got, i, mapi;
 
@@ -2211,7 +2211,7 @@ xfs_da_grow_inode_int(
 	}
 
 	/* account for newly allocated blocks in reserved blocks total */
-	args->total -= dp->i_d.di_nblocks - nblks;
+	args->total -= dp->i_nblocks - nblks;
 
 out_free_map:
 	if (mapp != &map)
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.h
diff --git a/fs/xfs/libxfs/xfs_inode_fork.c b/fs/xfs/libxfs/xfs_inode_fork.c
index 55bb3e6342b9..ad7c4512168d 100644
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@ -194,7 +194,7 @@ xfs_iformat_btree(
 		     nrecs == 0 ||
 		     XFS_BMDR_SPACE_CALC(nrecs) >
 					XFS_DFORK_SIZE(dip, mp, whichfork) ||
-		     ifp->if_nextents > ip->i_d.di_nblocks) ||
+		     ifp->if_nextents > ip->i_nblocks) ||
 		     level == 0 || level > XFS_BM_MAXLEVELS(mp, whichfork)) {
 		xfs_warn(mp, "corrupt inode %Lu (btree).",
 					(unsigned long long) ip->i_ino);
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index 4289f7de99b7..422882826180 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -154,7 +154,7 @@ xfs_bmap_rtalloc(
 		ap->blkno *= mp->m_sb.sb_rextsize;
 		ralen *= mp->m_sb.sb_rextsize;
 		ap->length = ralen;
-		ap->ip->i_d.di_nblocks += ralen;
+		ap->ip->i_nblocks += ralen;
 		xfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);
 		if (ap->wasdel)
 			ap->ip->i_delayed_blks -= ralen;
@@ -1476,9 +1476,9 @@ xfs_swap_extent_forks(
 	/*
 	 * Fix the on-disk inode values
 	 */
-	tmp = (uint64_t)ip->i_d.di_nblocks;
-	ip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;
-	tip->i_d.di_nblocks = tmp + taforkblks - aforkblks;
+	tmp = (uint64_t)ip->i_nblocks;
+	ip->i_nblocks = tip->i_nblocks - taforkblks + aforkblks;
+	tip->i_nblocks = tmp + taforkblks - aforkblks;
 
 	/*
 	 * The extents in the source inode could still contain speculative
diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c
index 7ea1c183137f..baa003514bf9 100644
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@ -65,7 +65,7 @@ xfs_inode_alloc(
 	ip->i_flags = 0;
 	ip->i_delayed_blks = 0;
 	ip->i_d.di_flags2 = mp->m_ino_geo.new_diflags2;
-	ip->i_d.di_nblocks = 0;
+	ip->i_nblocks = 0;
 	ip->i_d.di_forkoff = 0;
 	ip->i_sick = 0;
 	ip->i_checked = 0;
@@ -310,7 +310,7 @@ xfs_iget_check_free_state(
 			return -EFSCORRUPTED;
 		}
 
-		if (ip->i_d.di_nblocks != 0) {
+		if (ip->i_nblocks != 0) {
 			xfs_warn(ip->i_mount,
 "Corruption detected! Free inode 0x%llx has blocks allocated!",
 				ip->i_ino);
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_inode.h
* Unmerged path fs/xfs/xfs_inode_item.c
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 1a5880c79e28..743e43313e0a 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -531,8 +531,7 @@ xfs_vn_getattr(
 	stat->atime = inode->i_atime;
 	stat->mtime = inode->i_mtime;
 	stat->ctime = inode->i_ctime;
-	stat->blocks =
-		XFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);
+	stat->blocks = XFS_FSB_TO_BB(mp, ip->i_nblocks + ip->i_delayed_blks);
 
 	if (xfs_sb_version_has_v3inode(&mp->m_sb)) {
 		if (request_mask & STATX_BTIME) {
diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c
index 434d70c7cd93..b9918a38587b 100644
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@ -130,7 +130,7 @@ xfs_bulkstat_one_int(
 	case XFS_DINODE_FMT_BTREE:
 		buf->bs_rdev = 0;
 		buf->bs_blksize = mp->m_sb.sb_blocksize;
-		buf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;
+		buf->bs_blocks = ip->i_nblocks + ip->i_delayed_blks;
 		break;
 	}
 	xfs_iunlock(ip, XFS_ILOCK_SHARED);
diff --git a/fs/xfs/xfs_qm.c b/fs/xfs/xfs_qm.c
index 75ee3dd5b0ac..e520771edcac 100644
--- a/fs/xfs/xfs_qm.c
+++ b/fs/xfs/xfs_qm.c
@@ -991,7 +991,7 @@ xfs_qm_reset_dqcounts_buf(
 	 * trans_reserve. But, this gets called during quotacheck, and that
 	 * happens only at mount time which is single threaded.
 	 */
-	if (qip->i_d.di_nblocks == 0)
+	if (qip->i_nblocks == 0)
 		return 0;
 
 	map = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), 0);
@@ -1173,7 +1173,7 @@ xfs_qm_dqusage_adjust(
 		xfs_bmap_count_leaves(ifp, &rtblks);
 	}
 
-	nblks = (xfs_qcnt_t)ip->i_d.di_nblocks - rtblks;
+	nblks = (xfs_qcnt_t)ip->i_nblocks - rtblks;
 
 	/*
 	 * Add the (disk blocks and inode) resources occupied by this
@@ -1778,11 +1778,11 @@ xfs_qm_vop_chown(
 	ASSERT(prevdq);
 	ASSERT(prevdq != newdq);
 
-	xfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));
+	xfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_nblocks));
 	xfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);
 
 	/* the sparkling new dquot */
-	xfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);
+	xfs_trans_mod_dquot(tp, newdq, bfield, ip->i_nblocks);
 	xfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);
 
 	/*
diff --git a/fs/xfs/xfs_quotaops.c b/fs/xfs/xfs_quotaops.c
index d27c0e852c0b..88d70c236a54 100644
--- a/fs/xfs/xfs_quotaops.c
+++ b/fs/xfs/xfs_quotaops.c
@@ -35,7 +35,7 @@ xfs_qm_fill_state(
 		tempqip = true;
 	}
 	tstate->flags |= QCI_SYSFILE;
-	tstate->blocks = ip->i_d.di_nblocks;
+	tstate->blocks = ip->i_nblocks;
 	tstate->nextents = ip->i_df.if_nextents;
 	tstate->spc_timelimit = (u32)defq->blk.time;
 	tstate->ino_timelimit = (u32)defq->ino.time;
diff --git a/fs/xfs/xfs_trans.c b/fs/xfs/xfs_trans.c
index f821fa201f62..8694a01da223 100644
--- a/fs/xfs/xfs_trans.c
+++ b/fs/xfs/xfs_trans.c
@@ -1183,7 +1183,7 @@ xfs_trans_alloc_ichange(
 		 * though that part is only semi-transactional.
 		 */
 		error = xfs_trans_reserve_quota_bydquots(tp, mp, udqp, gdqp,
-				pdqp, ip->i_d.di_nblocks + ip->i_delayed_blks,
+				pdqp, ip->i_nblocks + ip->i_delayed_blks,
 				1, qflags);
 		if ((error == -EDQUOT || error == -ENOSPC) && !retried) {
 			xfs_trans_cancel(tp);
