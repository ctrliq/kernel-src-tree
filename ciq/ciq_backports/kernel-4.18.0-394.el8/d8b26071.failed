NFSD: simplify struct nfsfh

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author NeilBrown <neilb@suse.de>
commit d8b26071e65e80a348602b939e333242f989221b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/d8b26071.failed

Most of the fields in 'struct knfsd_fh' are 2 levels deep (a union and a
struct) and are accessed using macros like:

 #define fh_FOO fh_base.fh_new.fb_FOO

This patch makes the union and struct anonymous, so that "fh_FOO" can be
a name directly within 'struct knfsd_fh' and the #defines aren't needed.

The file handle as a whole is sometimes accessed as "fh_base" or
"fh_base.fh_pad", neither of which are particularly helpful names.
As the struct holding the filehandle is now anonymous, we
cannot use the name of that, so we union it with 'fh_raw' and use that
where the raw filehandle is needed.  fh_raw also ensure the structure is
large enough for the largest possible filehandle.

fh_raw is a 'char' array, removing any need to cast it for memcpy etc.

SVCFH_fmt() is simplified using the "%ph" printk format.  This
changes the appearance of filehandles in dprintk() debugging, making
them a little more precise.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: NeilBrown <neilb@suse.de>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit d8b26071e65e80a348602b939e333242f989221b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4proc.c
#	fs/nfsd/nfsfh.h
diff --cc fs/nfsd/nfs4proc.c
index 64ce01620a25,3f7e59ec4e32..000000000000
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@@ -504,9 -518,17 +504,9 @@@ nfsd4_putfh(struct svc_rqst *rqstp, str
  
  	fh_put(&cstate->current_fh);
  	cstate->current_fh.fh_handle.fh_size = putfh->pf_fhlen;
- 	memcpy(&cstate->current_fh.fh_handle.fh_base, putfh->pf_fhval,
+ 	memcpy(&cstate->current_fh.fh_handle.fh_raw, putfh->pf_fhval,
  	       putfh->pf_fhlen);
 -	ret = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);
 -#ifdef CONFIG_NFSD_V4_2_INTER_SSC
 -	if (ret == nfserr_stale && putfh->no_verify) {
 -		SET_FH_FLAG(&cstate->current_fh, NFSD4_FH_FOREIGN);
 -		ret = 0;
 -	}
 -#endif
 -	return ret;
 +	return fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);
  }
  
  static __be32
@@@ -1139,6 -1161,327 +1139,330 @@@ void nfsd4_shutdown_copy(struct nfs4_cl
  	while ((copy = nfsd4_get_copy(clp)) != NULL)
  		nfsd4_stop_copy(copy);
  }
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NFSD_V4_2_INTER_SSC
+ 
+ extern struct file *nfs42_ssc_open(struct vfsmount *ss_mnt,
+ 				   struct nfs_fh *src_fh,
+ 				   nfs4_stateid *stateid);
+ extern void nfs42_ssc_close(struct file *filep);
+ 
+ extern void nfs_sb_deactive(struct super_block *sb);
+ 
+ #define NFSD42_INTERSSC_MOUNTOPS "vers=4.2,addr=%s,sec=sys"
+ 
+ /*
+  * setup a work entry in the ssc delayed unmount list.
+  */
+ static __be32 nfsd4_ssc_setup_dul(struct nfsd_net *nn, char *ipaddr,
+ 		struct nfsd4_ssc_umount_item **retwork, struct vfsmount **ss_mnt)
+ {
+ 	struct nfsd4_ssc_umount_item *ni = 0;
+ 	struct nfsd4_ssc_umount_item *work = NULL;
+ 	struct nfsd4_ssc_umount_item *tmp;
+ 	DEFINE_WAIT(wait);
+ 
+ 	*ss_mnt = NULL;
+ 	*retwork = NULL;
+ 	work = kzalloc(sizeof(*work), GFP_KERNEL);
+ try_again:
+ 	spin_lock(&nn->nfsd_ssc_lock);
+ 	list_for_each_entry_safe(ni, tmp, &nn->nfsd_ssc_mount_list, nsui_list) {
+ 		if (strncmp(ni->nsui_ipaddr, ipaddr, sizeof(ni->nsui_ipaddr)))
+ 			continue;
+ 		/* found a match */
+ 		if (ni->nsui_busy) {
+ 			/*  wait - and try again */
+ 			prepare_to_wait(&nn->nfsd_ssc_waitq, &wait,
+ 				TASK_INTERRUPTIBLE);
+ 			spin_unlock(&nn->nfsd_ssc_lock);
+ 
+ 			/* allow 20secs for mount/unmount for now - revisit */
+ 			if (signal_pending(current) ||
+ 					(schedule_timeout(20*HZ) == 0)) {
+ 				kfree(work);
+ 				return nfserr_eagain;
+ 			}
+ 			finish_wait(&nn->nfsd_ssc_waitq, &wait);
+ 			goto try_again;
+ 		}
+ 		*ss_mnt = ni->nsui_vfsmount;
+ 		refcount_inc(&ni->nsui_refcnt);
+ 		spin_unlock(&nn->nfsd_ssc_lock);
+ 		kfree(work);
+ 
+ 		/* return vfsmount in ss_mnt */
+ 		return 0;
+ 	}
+ 	if (work) {
+ 		strncpy(work->nsui_ipaddr, ipaddr, sizeof(work->nsui_ipaddr));
+ 		refcount_set(&work->nsui_refcnt, 2);
+ 		work->nsui_busy = true;
+ 		list_add_tail(&work->nsui_list, &nn->nfsd_ssc_mount_list);
+ 		*retwork = work;
+ 	}
+ 	spin_unlock(&nn->nfsd_ssc_lock);
+ 	return 0;
+ }
+ 
+ static void nfsd4_ssc_update_dul_work(struct nfsd_net *nn,
+ 		struct nfsd4_ssc_umount_item *work, struct vfsmount *ss_mnt)
+ {
+ 	/* set nsui_vfsmount, clear busy flag and wakeup waiters */
+ 	spin_lock(&nn->nfsd_ssc_lock);
+ 	work->nsui_vfsmount = ss_mnt;
+ 	work->nsui_busy = false;
+ 	wake_up_all(&nn->nfsd_ssc_waitq);
+ 	spin_unlock(&nn->nfsd_ssc_lock);
+ }
+ 
+ static void nfsd4_ssc_cancel_dul_work(struct nfsd_net *nn,
+ 		struct nfsd4_ssc_umount_item *work)
+ {
+ 	spin_lock(&nn->nfsd_ssc_lock);
+ 	list_del(&work->nsui_list);
+ 	wake_up_all(&nn->nfsd_ssc_waitq);
+ 	spin_unlock(&nn->nfsd_ssc_lock);
+ 	kfree(work);
+ }
+ 
+ /*
+  * Support one copy source server for now.
+  */
+ static __be32
+ nfsd4_interssc_connect(struct nl4_server *nss, struct svc_rqst *rqstp,
+ 		       struct vfsmount **mount)
+ {
+ 	struct file_system_type *type;
+ 	struct vfsmount *ss_mnt;
+ 	struct nfs42_netaddr *naddr;
+ 	struct sockaddr_storage tmp_addr;
+ 	size_t tmp_addrlen, match_netid_len = 3;
+ 	char *startsep = "", *endsep = "", *match_netid = "tcp";
+ 	char *ipaddr, *dev_name, *raw_data;
+ 	int len, raw_len;
+ 	__be32 status = nfserr_inval;
+ 	struct nfsd4_ssc_umount_item *work = NULL;
+ 	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
+ 
+ 	naddr = &nss->u.nl4_addr;
+ 	tmp_addrlen = rpc_uaddr2sockaddr(SVC_NET(rqstp), naddr->addr,
+ 					 naddr->addr_len,
+ 					 (struct sockaddr *)&tmp_addr,
+ 					 sizeof(tmp_addr));
+ 	if (tmp_addrlen == 0)
+ 		goto out_err;
+ 
+ 	if (tmp_addr.ss_family == AF_INET6) {
+ 		startsep = "[";
+ 		endsep = "]";
+ 		match_netid = "tcp6";
+ 		match_netid_len = 4;
+ 	}
+ 
+ 	if (naddr->netid_len != match_netid_len ||
+ 		strncmp(naddr->netid, match_netid, naddr->netid_len))
+ 		goto out_err;
+ 
+ 	/* Construct the raw data for the vfs_kern_mount call */
+ 	len = RPC_MAX_ADDRBUFLEN + 1;
+ 	ipaddr = kzalloc(len, GFP_KERNEL);
+ 	if (!ipaddr)
+ 		goto out_err;
+ 
+ 	rpc_ntop((struct sockaddr *)&tmp_addr, ipaddr, len);
+ 
+ 	/* 2 for ipv6 endsep and startsep. 3 for ":/" and trailing '/0'*/
+ 
+ 	raw_len = strlen(NFSD42_INTERSSC_MOUNTOPS) + strlen(ipaddr);
+ 	raw_data = kzalloc(raw_len, GFP_KERNEL);
+ 	if (!raw_data)
+ 		goto out_free_ipaddr;
+ 
+ 	snprintf(raw_data, raw_len, NFSD42_INTERSSC_MOUNTOPS, ipaddr);
+ 
+ 	status = nfserr_nodev;
+ 	type = get_fs_type("nfs");
+ 	if (!type)
+ 		goto out_free_rawdata;
+ 
+ 	/* Set the server:<export> for the vfs_kern_mount call */
+ 	dev_name = kzalloc(len + 5, GFP_KERNEL);
+ 	if (!dev_name)
+ 		goto out_free_rawdata;
+ 	snprintf(dev_name, len + 5, "%s%s%s:/", startsep, ipaddr, endsep);
+ 
+ 	status = nfsd4_ssc_setup_dul(nn, ipaddr, &work, &ss_mnt);
+ 	if (status)
+ 		goto out_free_devname;
+ 	if (ss_mnt)
+ 		goto out_done;
+ 
+ 	/* Use an 'internal' mount: SB_KERNMOUNT -> MNT_INTERNAL */
+ 	ss_mnt = vfs_kern_mount(type, SB_KERNMOUNT, dev_name, raw_data);
+ 	module_put(type->owner);
+ 	if (IS_ERR(ss_mnt)) {
+ 		status = nfserr_nodev;
+ 		if (work)
+ 			nfsd4_ssc_cancel_dul_work(nn, work);
+ 		goto out_free_devname;
+ 	}
+ 	if (work)
+ 		nfsd4_ssc_update_dul_work(nn, work, ss_mnt);
+ out_done:
+ 	status = 0;
+ 	*mount = ss_mnt;
+ 
+ out_free_devname:
+ 	kfree(dev_name);
+ out_free_rawdata:
+ 	kfree(raw_data);
+ out_free_ipaddr:
+ 	kfree(ipaddr);
+ out_err:
+ 	return status;
+ }
+ 
+ static void
+ nfsd4_interssc_disconnect(struct vfsmount *ss_mnt)
+ {
+ 	nfs_do_sb_deactive(ss_mnt->mnt_sb);
+ 	mntput(ss_mnt);
+ }
+ 
+ /*
+  * Verify COPY destination stateid.
+  *
+  * Connect to the source server with NFSv4.1.
+  * Create the source struct file for nfsd_copy_range.
+  * Called with COPY cstate:
+  *    SAVED_FH: source filehandle
+  *    CURRENT_FH: destination filehandle
+  */
+ static __be32
+ nfsd4_setup_inter_ssc(struct svc_rqst *rqstp,
+ 		      struct nfsd4_compound_state *cstate,
+ 		      struct nfsd4_copy *copy, struct vfsmount **mount)
+ {
+ 	struct svc_fh *s_fh = NULL;
+ 	stateid_t *s_stid = &copy->cp_src_stateid;
+ 	__be32 status = nfserr_inval;
+ 
+ 	/* Verify the destination stateid and set dst struct file*/
+ 	status = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,
+ 					    &copy->cp_dst_stateid,
+ 					    WR_STATE, &copy->nf_dst, NULL);
+ 	if (status)
+ 		goto out;
+ 
+ 	status = nfsd4_interssc_connect(&copy->cp_src, rqstp, mount);
+ 	if (status)
+ 		goto out;
+ 
+ 	s_fh = &cstate->save_fh;
+ 
+ 	copy->c_fh.size = s_fh->fh_handle.fh_size;
+ 	memcpy(copy->c_fh.data, &s_fh->fh_handle.fh_raw, copy->c_fh.size);
+ 	copy->stateid.seqid = cpu_to_be32(s_stid->si_generation);
+ 	memcpy(copy->stateid.other, (void *)&s_stid->si_opaque,
+ 	       sizeof(stateid_opaque_t));
+ 
+ 	status = 0;
+ out:
+ 	return status;
+ }
+ 
+ static void
+ nfsd4_cleanup_inter_ssc(struct vfsmount *ss_mnt, struct nfsd_file *src,
+ 			struct nfsd_file *dst)
+ {
+ 	bool found = false;
+ 	long timeout;
+ 	struct nfsd4_ssc_umount_item *tmp;
+ 	struct nfsd4_ssc_umount_item *ni = NULL;
+ 	struct nfsd_net *nn = net_generic(dst->nf_net, nfsd_net_id);
+ 
+ 	nfs42_ssc_close(src->nf_file);
+ 	nfsd_file_put(dst);
+ 	fput(src->nf_file);
+ 
+ 	if (!nn) {
+ 		mntput(ss_mnt);
+ 		return;
+ 	}
+ 	spin_lock(&nn->nfsd_ssc_lock);
+ 	timeout = msecs_to_jiffies(nfsd4_ssc_umount_timeout);
+ 	list_for_each_entry_safe(ni, tmp, &nn->nfsd_ssc_mount_list, nsui_list) {
+ 		if (ni->nsui_vfsmount->mnt_sb == ss_mnt->mnt_sb) {
+ 			list_del(&ni->nsui_list);
+ 			/*
+ 			 * vfsmount can be shared by multiple exports,
+ 			 * decrement refcnt. If the count drops to 1 it
+ 			 * will be unmounted when nsui_expire expires.
+ 			 */
+ 			refcount_dec(&ni->nsui_refcnt);
+ 			ni->nsui_expire = jiffies + timeout;
+ 			list_add_tail(&ni->nsui_list, &nn->nfsd_ssc_mount_list);
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	spin_unlock(&nn->nfsd_ssc_lock);
+ 	if (!found) {
+ 		mntput(ss_mnt);
+ 		return;
+ 	}
+ }
+ 
+ #else /* CONFIG_NFSD_V4_2_INTER_SSC */
+ 
+ static __be32
+ nfsd4_setup_inter_ssc(struct svc_rqst *rqstp,
+ 		      struct nfsd4_compound_state *cstate,
+ 		      struct nfsd4_copy *copy,
+ 		      struct vfsmount **mount)
+ {
+ 	*mount = NULL;
+ 	return nfserr_inval;
+ }
+ 
+ static void
+ nfsd4_cleanup_inter_ssc(struct vfsmount *ss_mnt, struct nfsd_file *src,
+ 			struct nfsd_file *dst)
+ {
+ }
+ 
+ static void
+ nfsd4_interssc_disconnect(struct vfsmount *ss_mnt)
+ {
+ }
+ 
+ static struct file *nfs42_ssc_open(struct vfsmount *ss_mnt,
+ 				   struct nfs_fh *src_fh,
+ 				   nfs4_stateid *stateid)
+ {
+ 	return NULL;
+ }
+ #endif /* CONFIG_NFSD_V4_2_INTER_SSC */
+ 
+ static __be32
+ nfsd4_setup_intra_ssc(struct svc_rqst *rqstp,
+ 		      struct nfsd4_compound_state *cstate,
+ 		      struct nfsd4_copy *copy)
+ {
+ 	return nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid,
+ 				 &copy->nf_src, &copy->cp_dst_stateid,
+ 				 &copy->nf_dst);
+ }
+ 
+ static void
+ nfsd4_cleanup_intra_ssc(struct nfsd_file *src, struct nfsd_file *dst)
+ {
+ 	nfsd_file_put(src);
+ 	nfsd_file_put(dst);
+ }
++>>>>>>> d8b26071e65e (NFSD: simplify struct nfsfh)
  
  static void nfsd4_cb_offload_release(struct nfsd4_callback *cb)
  {
diff --cc fs/nfsd/nfsfh.h
index 3e0996ce0ea1,d11e4b6870d6..000000000000
--- a/fs/nfsd/nfsfh.h
+++ b/fs/nfsd/nfsfh.h
@@@ -10,8 -10,56 +10,60 @@@
  
  #include <linux/crc32.h>
  #include <linux/sunrpc/svc.h>
 +#include <uapi/linux/nfsd/nfsfh.h>
  #include <linux/iversion.h>
++<<<<<<< HEAD
++=======
+ #include <linux/exportfs.h>
+ #include <linux/nfs4.h>
+ 
+ /*
+  * The file handle starts with a sequence of four-byte words.
+  * The first word contains a version number (1) and three descriptor bytes
+  * that tell how the remaining 3 variable length fields should be handled.
+  * These three bytes are auth_type, fsid_type and fileid_type.
+  *
+  * All four-byte values are in host-byte-order.
+  *
+  * The auth_type field is deprecated and must be set to 0.
+  *
+  * The fsid_type identifies how the filesystem (or export point) is
+  *    encoded.
+  *  Current values:
+  *     0  - 4 byte device id (ms-2-bytes major, ls-2-bytes minor), 4byte inode number
+  *        NOTE: we cannot use the kdev_t device id value, because kdev_t.h
+  *              says we mustn't.  We must break it up and reassemble.
+  *     1  - 4 byte user specified identifier
+  *     2  - 4 byte major, 4 byte minor, 4 byte inode number - DEPRECATED
+  *     3  - 4 byte device id, encoded for user-space, 4 byte inode number
+  *     4  - 4 byte inode number and 4 byte uuid
+  *     5  - 8 byte uuid
+  *     6  - 16 byte uuid
+  *     7  - 8 byte inode number and 16 byte uuid
+  *
+  * The fileid_type identifies how the file within the filesystem is encoded.
+  *   The values for this field are filesystem specific, exccept that
+  *   filesystems must not use the values '0' or '0xff'. 'See enum fid_type'
+  *   in include/linux/exportfs.h for currently registered values.
+  */
+ 
+ struct knfsd_fh {
+ 	unsigned int	fh_size;	/*
+ 					 * Points to the current size while
+ 					 * building a new file handle.
+ 					 */
+ 	union {
+ 		char			fh_raw[NFS4_FHSIZE];
+ 		struct {
+ 			u8		fh_version;	/* == 1 */
+ 			u8		fh_auth_type;	/* deprecated */
+ 			u8		fh_fsid_type;
+ 			u8		fh_fileid_type;
+ 			u32		fh_fsid[]; /* flexible-array member */
+ 		};
+ 	};
+ };
++>>>>>>> d8b26071e65e (NFSD: simplify struct nfsfh)
  
  static inline __u32 ino_t_to_u32(ino_t ino)
  {
diff --git a/fs/nfsd/flexfilelayout.c b/fs/nfsd/flexfilelayout.c
index db7ef07ae50c..2e2f1d5e9f62 100644
--- a/fs/nfsd/flexfilelayout.c
+++ b/fs/nfsd/flexfilelayout.c
@@ -61,7 +61,7 @@ nfsd4_ff_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,
 		goto out_error;
 
 	fl->fh.size = fhp->fh_handle.fh_size;
-	memcpy(fl->fh.data, &fhp->fh_handle.fh_base, fl->fh.size);
+	memcpy(fl->fh.data, &fhp->fh_handle.fh_raw, fl->fh.size);
 
 	/* Give whole file layout segments */
 	seg->offset = 0;
diff --git a/fs/nfsd/lockd.c b/fs/nfsd/lockd.c
index 3f5b3d7b62b7..9f6eb091db08 100644
--- a/fs/nfsd/lockd.c
+++ b/fs/nfsd/lockd.c
@@ -33,7 +33,7 @@ nlm_fopen(struct svc_rqst *rqstp, struct nfs_fh *f, struct file **filp)
 	/* must initialize before using! but maxsize doesn't matter */
 	fh_init(&fh,0);
 	fh.fh_handle.fh_size = f->size;
-	memcpy((char*)&fh.fh_handle.fh_base, f->data, f->size);
+	memcpy(&fh.fh_handle.fh_raw, f->data, f->size);
 	fh.fh_export = NULL;
 
 	nfserr = nfsd_open(rqstp, &fh, S_IFREG, NFSD_MAY_LOCK, filp);
diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.c
index 657ede6555bb..56a31775ce3b 100644
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -99,7 +99,7 @@ svcxdr_decode_nfs_fh3(struct xdr_stream *xdr, struct svc_fh *fhp)
 		return false;
 	fh_init(fhp, NFS3_FHSIZE);
 	fhp->fh_handle.fh_size = size;
-	memcpy(&fhp->fh_handle.fh_base, p, size);
+	memcpy(&fhp->fh_handle.fh_raw, p, size);
 
 	return true;
 }
@@ -138,7 +138,7 @@ svcxdr_encode_nfs_fh3(struct xdr_stream *xdr, const struct svc_fh *fhp)
 	*p++ = cpu_to_be32(size);
 	if (size)
 		p[XDR_QUADLEN(size) - 1] = 0;
-	memcpy(p, &fhp->fh_handle.fh_base, size);
+	memcpy(p, &fhp->fh_handle.fh_raw, size);
 
 	return true;
 }
diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 8d90f801f69a..e792be9b34ae 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -121,7 +121,7 @@ static void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)
 
 	BUG_ON(length > NFS4_FHSIZE);
 	p = xdr_reserve_space(xdr, 4 + length);
-	xdr_encode_opaque(p, &fh->fh_base, length);
+	xdr_encode_opaque(p, &fh->fh_raw, length);
 }
 
 /*
* Unmerged path fs/nfsd/nfs4proc.c
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index ccf52d47e9ec..9b90e9663d79 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -949,7 +949,7 @@ static int delegation_blocked(struct knfsd_fh *fh)
 		}
 		spin_unlock(&blocked_delegations_lock);
 	}
-	hash = jhash(&fh->fh_base, fh->fh_size, 0);
+	hash = jhash(&fh->fh_raw, fh->fh_size, 0);
 	if (test_bit(hash&255, bd->set[0]) &&
 	    test_bit((hash>>8)&255, bd->set[0]) &&
 	    test_bit((hash>>16)&255, bd->set[0]))
@@ -968,7 +968,7 @@ static void block_delegations(struct knfsd_fh *fh)
 	u32 hash;
 	struct bloom_pair *bd = &blocked_delegations;
 
-	hash = jhash(&fh->fh_base, fh->fh_size, 0);
+	hash = jhash(&fh->fh_raw, fh->fh_size, 0);
 
 	spin_lock(&blocked_delegations_lock);
 	__set_bit(hash&255, bd->set[bd->new]);
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7..6671baba4bda 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -2925,7 +2925,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
 		p = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);
 		if (!p)
 			goto out_resource;
-		p = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,
+		p = xdr_encode_opaque(p, &fhp->fh_handle.fh_raw,
 					fhp->fh_handle.fh_size);
 	}
 	if (bmval0 & FATTR4_WORD0_FILEID) {
@@ -3485,7 +3485,7 @@ nfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh
 	p = xdr_reserve_space(xdr, len + 4);
 	if (!p)
 		return nfserr_resource;
-	p = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);
+	p = xdr_encode_opaque(p, &fhp->fh_handle.fh_raw, len);
 	return 0;
 }
 
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index cd6a0e787367..d693778647ba 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -393,12 +393,12 @@ static ssize_t write_filehandle(struct file *file, char *buf, size_t size)
 	auth_domain_put(dom);
 	if (len)
 		return len;
-	
+
 	mesg = buf;
 	len = SIMPLE_TRANSACTION_LIMIT;
-	qword_addhex(&mesg, &len, (char*)&fh.fh_base, fh.fh_size);
+	qword_addhex(&mesg, &len, fh.fh_raw, fh.fh_size);
 	mesg[-1] = '\n';
-	return mesg - buf;	
+	return mesg - buf;
 }
 
 /*
diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 3d9e44b1141f..326e75faa960 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -671,16 +671,11 @@ fh_put(struct svc_fh *fhp)
 char * SVCFH_fmt(struct svc_fh *fhp)
 {
 	struct knfsd_fh *fh = &fhp->fh_handle;
+	static char buf[2+1+1+64*3+1];
 
-	static char buf[80];
-	sprintf(buf, "%d: %08x %08x %08x %08x %08x %08x",
-		fh->fh_size,
-		fh->fh_base.fh_pad[0],
-		fh->fh_base.fh_pad[1],
-		fh->fh_base.fh_pad[2],
-		fh->fh_base.fh_pad[3],
-		fh->fh_base.fh_pad[4],
-		fh->fh_base.fh_pad[5]);
+	if (fh->fh_size < 0 || fh->fh_size> 64)
+		return "bad-fh";
+	sprintf(buf, "%d: %*ph", fh->fh_size, fh->fh_size, fh->fh_raw);
 	return buf;
 }
 
* Unmerged path fs/nfsd/nfsfh.h
diff --git a/fs/nfsd/nfsxdr.c b/fs/nfsd/nfsxdr.c
index 1c01c0cb3914..018b9ccfd97f 100644
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@ -64,7 +64,7 @@ svcxdr_decode_fhandle(struct xdr_stream *xdr, struct svc_fh *fhp)
 	if (!p)
 		return false;
 	fh_init(fhp, NFS_FHSIZE);
-	memcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);
+	memcpy(&fhp->fh_handle.fh_raw, p, NFS_FHSIZE);
 	fhp->fh_handle.fh_size = NFS_FHSIZE;
 
 	return true;
@@ -78,7 +78,7 @@ svcxdr_encode_fhandle(struct xdr_stream *xdr, const struct svc_fh *fhp)
 	p = xdr_reserve_space(xdr, NFS_FHSIZE);
 	if (!p)
 		return false;
-	memcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);
+	memcpy(p, &fhp->fh_handle.fh_raw, NFS_FHSIZE);
 
 	return true;
 }
