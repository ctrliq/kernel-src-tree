NFSD: Fix ia_size underflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit e6faac3f58c7c4176b66f63def17a34232a17b0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/e6faac3f.failed

iattr::ia_size is a loff_t, which is a signed 64-bit type. NFSv3 and
NFSv4 both define file size as an unsigned 64-bit type. Thus there
is a range of valid file size values an NFS client can send that is
already larger than Linux can handle.

Currently decode_fattr4() dumps a full u64 value into ia_size. If
that value happens to be larger than S64_MAX, then ia_size
underflows. I'm about to fix up the NFSv3 behavior as well, so let's
catch the underflow in the common code path: nfsd_setattr().

	Cc: stable@vger.kernel.org
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit e6faac3f58c7c4176b66f63def17a34232a17b0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/vfs.c
diff --cc fs/nfsd/vfs.c
index 8086e322a414,0cccceb105e7..000000000000
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@@ -474,7 -435,11 +474,15 @@@ nfsd_setattr(struct svc_rqst *rqstp, st
  			.ia_size	= iap->ia_size,
  		};
  
++<<<<<<< HEAD
 +		host_err = notify_change(dentry, &size_attr, NULL);
++=======
+ 		host_err = -EFBIG;
+ 		if (iap->ia_size < 0)
+ 			goto out_unlock;
+ 
+ 		host_err = notify_change(&init_user_ns, dentry, &size_attr, NULL);
++>>>>>>> e6faac3f58c7 (NFSD: Fix ia_size underflow)
  		if (host_err)
  			goto out_unlock;
  		iap->ia_valid &= ~ATTR_SIZE;
* Unmerged path fs/nfsd/vfs.c
