NFSv4: setlease should return EAGAIN if locks are not available

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit df2c7b951f439a0342495a4a049d808f679c474c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/df2c7b95.failed

Instead of returning ENOLCK when we can't hand out a lease, we should be
returning EAGAIN.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit df2c7b951f439a0342495a4a049d808f679c474c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index ace738e70ec6,e4efb7bccd7e..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -7386,6 -7438,43 +7386,46 @@@ nfs4_proc_lock(struct file *filp, int c
  	return nfs4_retry_setlk(state, cmd, request);
  }
  
++<<<<<<< HEAD
++=======
+ static int nfs4_delete_lease(struct file *file, void **priv)
+ {
+ 	return generic_setlease(file, F_UNLCK, NULL, priv);
+ }
+ 
+ static int nfs4_add_lease(struct file *file, long arg, struct file_lock **lease,
+ 			  void **priv)
+ {
+ 	struct inode *inode = file_inode(file);
+ 	fmode_t type = arg == F_RDLCK ? FMODE_READ : FMODE_WRITE;
+ 	int ret;
+ 
+ 	/* No delegation, no lease */
+ 	if (!nfs4_have_delegation(inode, type))
+ 		return -EAGAIN;
+ 	ret = generic_setlease(file, arg, lease, priv);
+ 	if (ret || nfs4_have_delegation(inode, type))
+ 		return ret;
+ 	/* We raced with a delegation return */
+ 	nfs4_delete_lease(file, priv);
+ 	return -EAGAIN;
+ }
+ 
+ int nfs4_proc_setlease(struct file *file, long arg, struct file_lock **lease,
+ 		       void **priv)
+ {
+ 	switch (arg) {
+ 	case F_RDLCK:
+ 	case F_WRLCK:
+ 		return nfs4_add_lease(file, arg, lease, priv);
+ 	case F_UNLCK:
+ 		return nfs4_delete_lease(file, priv);
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
++>>>>>>> df2c7b951f43 (NFSv4: setlease should return EAGAIN if locks are not available)
  int nfs4_lock_delegation_recall(struct file_lock *fl, struct nfs4_state *state, const nfs4_stateid *stateid)
  {
  	struct nfs_server *server = NFS_SERVER(state->inode);
* Unmerged path fs/nfs/nfs4proc.c
