xfs: use a union for i_cowextsize and i_flushiter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit ee7b83fd365e32beaa405d60b8c42f42ec5f42c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/ee7b83fd.failed

The i_cowextsize field is only used for v3 inodes, and the i_flushiter
field is only used for v1/v2 inodes.  Use a union to pack the inode a
littler better after adding a few missing guards around their usage.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit ee7b83fd365e32beaa405d60b8c42f42ec5f42c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_inode.h
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 671aeb012e3f,88ec7be551a8..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -193,7 -193,8 +193,12 @@@ xfs_inode_from_disk
  	 * inode. If the inode is unused, mode is zero and we shouldn't mess
  	 * with the uninitialized part of it.
  	 */
++<<<<<<< HEAD
 +	to->di_flushiter = be16_to_cpu(from->di_flushiter);
++=======
+ 	if (!xfs_sb_version_has_v3inode(&ip->i_mount->m_sb))
+ 		ip->i_flushiter = be16_to_cpu(from->di_flushiter);
++>>>>>>> ee7b83fd365e (xfs: use a union for i_cowextsize and i_flushiter)
  	inode->i_generation = be32_to_cpu(from->di_gen);
  	inode->i_mode = be16_to_cpu(from->di_mode);
  	if (!inode->i_mode)
diff --cc fs/xfs/xfs_inode.c
index d856a2225b9c,e483c380afd1..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -3454,8 -3483,10 +3454,15 @@@ xfs_iflush
  	xfs_inode_to_disk(ip, dip, iip->ili_item.li_lsn);
  
  	/* Wrap, we never let the log put out DI_MAX_FLUSH */
++<<<<<<< HEAD
 +	if (ip->i_d.di_flushiter == DI_MAX_FLUSH)
 +		ip->i_d.di_flushiter = 0;
++=======
+ 	if (!xfs_sb_version_has_v3inode(&mp->m_sb)) {
+ 		if (ip->i_flushiter == DI_MAX_FLUSH)
+ 			ip->i_flushiter = 0;
+ 	}
++>>>>>>> ee7b83fd365e (xfs: use a union for i_cowextsize and i_flushiter)
  
  	xfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);
  	if (XFS_IFORK_Q(ip))
diff --cc fs/xfs/xfs_inode.h
index ab59fceed361,7a877db8ac56..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -54,7 -54,15 +54,16 @@@ typedef struct xfs_inode 
  	/* Miscellaneous state. */
  	unsigned long		i_flags;	/* see defined flags below */
  	uint64_t		i_delayed_blks;	/* count of delay alloc blks */
 -	xfs_fsize_t		i_disk_size;	/* number of bytes in file */
 -	xfs_rfsblock_t		i_nblocks;	/* # of direct & btree blocks */
  	prid_t			i_projid;	/* owner's project id */
++<<<<<<< HEAD
++=======
+ 	xfs_extlen_t		i_extsize;	/* basic/minimum extent size */
+ 	/* cowextsize is only used for v3 inodes, flushiter for v1/2 */
+ 	union {
+ 		xfs_extlen_t	i_cowextsize;	/* basic cow extent size */
+ 		uint16_t	i_flushiter;	/* incremented on flush */
+ 	};
++>>>>>>> ee7b83fd365e (xfs: use a union for i_cowextsize and i_flushiter)
  
  	struct xfs_icdinode	i_d;		/* most of ondisk inode */
  
diff --cc fs/xfs/xfs_ioctl.c
index 0b05f7dd7822,2028a4aa2bb2..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1116,9 -1120,11 +1116,16 @@@ xfs_fill_fsxattr
  	struct xfs_ifork	*ifp = attr ? ip->i_afp : &ip->i_df;
  
  	simple_fill_fsxattr(fa, xfs_ip2xflags(ip));
++<<<<<<< HEAD
 +	fa->fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;
 +	fa->fsx_cowextsize = ip->i_d.di_cowextsize <<
 +			ip->i_mount->m_sb.sb_blocklog;
++=======
+ 
+ 	fa->fsx_extsize = XFS_FSB_TO_B(mp, ip->i_extsize);
+ 	if (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 		fa->fsx_cowextsize = XFS_FSB_TO_B(mp, ip->i_cowextsize);
++>>>>>>> ee7b83fd365e (xfs: use a union for i_cowextsize and i_flushiter)
  	fa->fsx_projid = ip->i_projid;
  	if (ifp && (ifp->if_flags & XFS_IFEXTENTS))
  		fa->fsx_nextents = xfs_iext_count(ifp);
@@@ -1512,15 -1521,16 +1519,26 @@@ xfs_ioctl_setattr
  	 * are set on the inode then unconditionally clear the extent size hint.
  	 */
  	if (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
 -		ip->i_extsize = XFS_B_TO_FSB(mp, fa->fsx_extsize);
 +		ip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;
 +	else
++<<<<<<< HEAD
 +		ip->i_d.di_extsize = 0;
 +	if (xfs_sb_version_has_v3inode(&mp->m_sb) &&
 +	    (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE))
 +		ip->i_d.di_cowextsize = fa->fsx_cowextsize >>
 +				mp->m_sb.sb_blocklog;
  	else
 +		ip->i_d.di_cowextsize = 0;
++=======
+ 		ip->i_extsize = 0;
+ 
+ 	if (xfs_sb_version_has_v3inode(&mp->m_sb)) {
+ 		if (ip->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE)
+ 			ip->i_cowextsize = XFS_B_TO_FSB(mp, fa->fsx_cowextsize);
+ 		else
+ 			ip->i_cowextsize = 0;
+ 	}
++>>>>>>> ee7b83fd365e (xfs: use a union for i_cowextsize and i_flushiter)
  
  	error = xfs_trans_commit(tp);
  
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_inode.h
* Unmerged path fs/xfs/xfs_ioctl.c
