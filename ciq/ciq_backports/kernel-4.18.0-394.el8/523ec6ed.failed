NFSD: Add a helper to decode state_protect4_a

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 523ec6ed6fb80fd1537d748a06bffd060a8b3235
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/523ec6ed.failed

Refactor for clarity.

Also, remove a stale comment. Commit ed94164398c9 ("nfsd: implement
machine credential support for some operations") added support for
SP4_MACH_CRED, so state_protect_a is no longer completely ignored.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 523ec6ed6fb80fd1537d748a06bffd060a8b3235)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index a7c80f4dce78,08909c7975dc..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -1384,79 -1454,129 +1384,94 @@@ static __be32 nfsd4_decode_backchannel_
  	return nfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);
  }
  
 -static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)
 -{
 -	u32 use_conn_in_rdma_mode;
 -	__be32 status;
 -
 -	status = nfsd4_decode_sessionid4(argp, &bcts->sessionid);
 -	if (status)
 -		return status;
 -	if (xdr_stream_decode_u32(argp->xdr, &bcts->dir) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &use_conn_in_rdma_mode) < 0)
 -		return nfserr_bad_xdr;
 -
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_state_protect_ops(struct nfsd4_compoundargs *argp,
 -			       struct nfsd4_exchange_id *exid)
 -{
 -	__be32 status;
 -
 -	status = nfsd4_decode_bitmap4(argp, exid->spo_must_enforce,
 -				      ARRAY_SIZE(exid->spo_must_enforce));
 -	if (status)
 -		return nfserr_bad_xdr;
 -	status = nfsd4_decode_bitmap4(argp, exid->spo_must_allow,
 -				      ARRAY_SIZE(exid->spo_must_allow));
 -	if (status)
 -		return nfserr_bad_xdr;
 -
 -	return nfs_ok;
 -}
 -
 -/*
 - * This implementation currently does not support SP4_SSV.
 - * This decoder simply skips over these arguments.
 - */
 -static noinline __be32
 -nfsd4_decode_ssv_sp_parms(struct nfsd4_compoundargs *argp,
 -			  struct nfsd4_exchange_id *exid)
 -{
 -	u32 count, window, num_gss_handles;
 -	__be32 status;
 -
 -	/* ssp_ops */
 -	status = nfsd4_decode_state_protect_ops(argp, exid);
 -	if (status)
 -		return status;
 -
 -	/* ssp_hash_algs<> */
 -	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
 -		return nfserr_bad_xdr;
 -	while (count--) {
 -		status = nfsd4_decode_ignored_string(argp, 0);
 -		if (status)
 -			return status;
 -	}
 -
 -	/* ssp_encr_algs<> */
 -	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
 -		return nfserr_bad_xdr;
 -	while (count--) {
 -		status = nfsd4_decode_ignored_string(argp, 0);
 -		if (status)
 -			return status;
 -	}
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &window) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &num_gss_handles) < 0)
 -		return nfserr_bad_xdr;
 -
 -	return nfs_ok;
 -}
 -
  static __be32
- nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
- 			 struct nfsd4_exchange_id *exid)
+ nfsd4_decode_state_protect4_a(struct nfsd4_compoundargs *argp,
+ 			      struct nfsd4_exchange_id *exid)
  {
++<<<<<<< HEAD
 +	int dummy, tmp;
 +	DECODE_HEAD;
++=======
+ 	__be32 status;
++>>>>>>> 523ec6ed6fb8 (NFSD: Add a helper to decode state_protect4_a)
  
- 	READ_BUF(NFS4_VERIFIER_SIZE);
- 	COPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);
- 
- 	status = nfsd4_decode_opaque(argp, &exid->clname);
- 	if (status)
+ 	if (xdr_stream_decode_u32(argp->xdr, &exid->spa_how) < 0)
  		return nfserr_bad_xdr;
- 
- 	READ_BUF(4);
- 	exid->flags = be32_to_cpup(p++);
- 
- 	/* Ignore state_protect4_a */
- 	READ_BUF(4);
- 	exid->spa_how = be32_to_cpup(p++);
  	switch (exid->spa_how) {
  	case SP4_NONE:
  		break;
  	case SP4_MACH_CRED:
 -		status = nfsd4_decode_state_protect_ops(argp, exid);
 +		/* spo_must_enforce */
 +		status = nfsd4_decode_bitmap(argp,
 +					exid->spo_must_enforce);
  		if (status)
 -			return status;
 +			goto out;
 +		/* spo_must_allow */
 +		status = nfsd4_decode_bitmap(argp, exid->spo_must_allow);
 +		if (status)
 +			goto out;
  		break;
  	case SP4_SSV:
 -		status = nfsd4_decode_ssv_sp_parms(argp, exid);
 -		if (status)
 -			return status;
 +		/* ssp_ops */
 +		READ_BUF(4);
 +		dummy = be32_to_cpup(p++);
 +		READ_BUF(dummy * 4);
 +		p += dummy;
 +
 +		READ_BUF(4);
 +		dummy = be32_to_cpup(p++);
 +		READ_BUF(dummy * 4);
 +		p += dummy;
 +
 +		/* ssp_hash_algs<> */
 +		READ_BUF(4);
 +		tmp = be32_to_cpup(p++);
 +		while (tmp--) {
 +			READ_BUF(4);
 +			dummy = be32_to_cpup(p++);
 +			READ_BUF(dummy);
 +			p += XDR_QUADLEN(dummy);
 +		}
 +
 +		/* ssp_encr_algs<> */
 +		READ_BUF(4);
 +		tmp = be32_to_cpup(p++);
 +		while (tmp--) {
 +			READ_BUF(4);
 +			dummy = be32_to_cpup(p++);
 +			READ_BUF(dummy);
 +			p += XDR_QUADLEN(dummy);
 +		}
 +
 +		/* ignore ssp_window and ssp_num_gss_handles: */
 +		READ_BUF(8);
  		break;
  	default:
- 		goto xdr_error;
+ 		return nfserr_bad_xdr;
  	}
  
+ 	return nfs_ok;
+ }
+ 
+ static __be32
+ nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
+ 			 struct nfsd4_exchange_id *exid)
+ {
+ 	DECODE_HEAD;
+ 	int dummy;
+ 
+ 	status = nfsd4_decode_verifier4(argp, &exid->verifier);
+ 	if (status)
+ 		return status;
+ 	status = nfsd4_decode_opaque(argp, &exid->clname);
+ 	if (status)
+ 		return status;
+ 	if (xdr_stream_decode_u32(argp->xdr, &exid->flags) < 0)
+ 		return nfserr_bad_xdr;
+ 	status = nfsd4_decode_state_protect4_a(argp, exid);
+ 	if (status)
+ 		return status;
+ 
  	READ_BUF(4);    /* nfs_impl_id4 array length */
  	dummy = be32_to_cpup(p++);
  
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 6f6bdee77e66..45b4034a4e34 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3047,7 +3047,7 @@ nfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 
 	rpc_ntop(sa, addr_str, sizeof(addr_str));
 	dprintk("%s rqstp=%p exid=%p clname.len=%u clname.data=%p "
-		"ip_addr=%s flags %x, spa_how %d\n",
+		"ip_addr=%s flags %x, spa_how %u\n",
 		__func__, rqstp, exid, exid->clname.len, exid->clname.data,
 		addr_str, exid->flags, exid->spa_how);
 
* Unmerged path fs/nfsd/nfs4xdr.c
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index dee632ecc00d..d308aad748f5 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -428,7 +428,7 @@ struct nfsd4_exchange_id {
 	u32		flags;
 	clientid_t	clientid;
 	u32		seqid;
-	int		spa_how;
+	u32		spa_how;
 	u32             spo_must_enforce[3];
 	u32             spo_must_allow[3];
 	struct xdr_netobj nii_domain;
