NFSv4.2 add tracepoint to OFFLOAD_CANCEL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Olga Kornievskaia <kolga@netapp.com>
commit 127becabad7bef13b2e2ab795953cf8e9cce8aab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/127becab.failed

Add tracepoint to OFFLOAD_CANCEL operation.

	Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 127becabad7bef13b2e2ab795953cf8e9cce8aab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4trace.h
diff --cc fs/nfs/nfs4trace.h
index 456af62515fa,6ee6ad3674a2..000000000000
--- a/fs/nfs/nfs4trace.h
+++ b/fs/nfs/nfs4trace.h
@@@ -2770,6 -2406,96 +2770,99 @@@ TRACE_EVENT(nfs4_clone
  			__entry->len
  		)
  );
++<<<<<<< HEAD
++=======
+ 
+ TRACE_EVENT(nfs4_copy_notify,
+ 		TP_PROTO(
+ 			const struct inode *inode,
+ 			const struct nfs42_copy_notify_args *args,
+ 			const struct nfs42_copy_notify_res *res,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(inode, args, res, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned long, error)
+ 			__field(u32, fhandle)
+ 			__field(u32, fileid)
+ 			__field(dev_t, dev)
+ 			__field(int, stateid_seq)
+ 			__field(u32, stateid_hash)
+ 			__field(int, res_stateid_seq)
+ 			__field(u32, res_stateid_hash)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			const struct nfs_inode *nfsi = NFS_I(inode);
+ 
+ 			__entry->fileid = nfsi->fileid;
+ 			__entry->dev = inode->i_sb->s_dev;
+ 			__entry->fhandle = nfs_fhandle_hash(args->cna_src_fh);
+ 			__entry->stateid_seq =
+ 				be32_to_cpu(args->cna_src_stateid.seqid);
+ 			__entry->stateid_hash =
+ 				nfs_stateid_hash(&args->cna_src_stateid);
+ 			if (error) {
+ 				__entry->error = -error;
+ 				__entry->res_stateid_seq = 0;
+ 				__entry->res_stateid_hash = 0;
+ 			} else {
+ 				__entry->error = 0;
+ 				__entry->res_stateid_seq =
+ 					be32_to_cpu(res->cnr_stateid.seqid);
+ 				__entry->res_stateid_hash =
+ 					nfs_stateid_hash(&res->cnr_stateid);
+ 			}
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%ld (%s) fileid=%02x:%02x:%llu fhandle=0x%08x "
+ 			"stateid=%d:0x%08x res_stateid=%d:0x%08x",
+ 			-__entry->error,
+ 			show_nfs4_status(__entry->error),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->fileid,
+ 			__entry->fhandle,
+ 			__entry->stateid_seq, __entry->stateid_hash,
+ 			__entry->res_stateid_seq, __entry->res_stateid_hash
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs4_offload_cancel,
+ 		TP_PROTO(
+ 			const struct nfs42_offload_status_args *args,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(args, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned long, error)
+ 			__field(u32, fhandle)
+ 			__field(int, stateid_seq)
+ 			__field(u32, stateid_hash)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->fhandle = nfs_fhandle_hash(args->osa_src_fh);
+ 			__entry->error = error < 0 ? -error : 0;
+ 			__entry->stateid_seq =
+ 				be32_to_cpu(args->osa_stateid.seqid);
+ 			__entry->stateid_hash =
+ 				nfs_stateid_hash(&args->osa_stateid);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%ld (%s) fhandle=0x%08x stateid=%d:0x%08x",
+ 			-__entry->error,
+ 			show_nfs4_status(__entry->error),
+ 			__entry->fhandle,
+ 			__entry->stateid_seq, __entry->stateid_hash
+ 		)
+ );
++>>>>>>> 127becabad7b (NFSv4.2 add tracepoint to OFFLOAD_CANCEL)
  #endif /* CONFIG_NFS_V4_2 */
  
  #endif /* CONFIG_NFS_V4_1 */
diff --git a/fs/nfs/nfs42proc.c b/fs/nfs/nfs42proc.c
index 53467ad59aae..d6f3022bda48 100644
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@ -446,6 +446,7 @@ static void nfs42_offload_cancel_done(struct rpc_task *task, void *calldata)
 {
 	struct nfs42_offloadcancel_data *data = calldata;
 
+	trace_nfs4_offload_cancel(&data->args, task->tk_status);
 	nfs41_sequence_done(task, &data->res.osr_seq_res);
 	if (task->tk_status &&
 		nfs4_async_handle_error(task, data->seq_server, NULL,
* Unmerged path fs/nfs/nfs4trace.h
