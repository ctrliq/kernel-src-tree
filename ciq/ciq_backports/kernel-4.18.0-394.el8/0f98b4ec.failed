xfs: rename variable mp to parsing_mp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Pavel Reichl <preichl@redhat.com>
commit 0f98b4ece18da9d8287bb4cc4e8f78b8760ea0d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/0f98b4ec.failed

Rename mp variable to parsisng_mp so it is easy to distinguish
between current mount point handle and handle for mount point
which mount options are being parsed.

	Suggested-by: Eric Sandeen <sandeen@redhat.com>
	Signed-off-by: Pavel Reichl <preichl@redhat.com>

	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 0f98b4ece18da9d8287bb4cc4e8f78b8760ea0d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index cb55e77ebc47,afef24465c16..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1168,17 -1166,10 +1168,22 @@@ xfs_fs_parse_param
  			return -ENOMEM;
  		return 0;
  	case Opt_allocsize:
 +	case Opt_biosize:
  		if (suffix_kstrtoint(param->string, 10, &size))
  			return -EINVAL;
++<<<<<<< HEAD
 +		/*
 +		 * RHEL:
 +		 * preserve historical behavior and ignore allocsize=1
 +		 */
 +		if (size == 1)
 +			break;
 +		mp->m_allocsize_log = ffs(size) - 1;
 +		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
++=======
+ 		parsing_mp->m_allocsize_log = ffs(size) - 1;
+ 		parsing_mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
++>>>>>>> 0f98b4ece18d (xfs: rename variable mp to parsing_mp)
  		return 0;
  	case Opt_grpid:
  	case Opt_bsdgroups:
@@@ -1186,61 -1177,48 +1191,61 @@@
  		return 0;
  	case Opt_nogrpid:
  	case Opt_sysvgroups:
- 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		parsing_mp->m_flags &= ~XFS_MOUNT_GRPID;
  		return 0;
  	case Opt_wsync:
- 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 		parsing_mp->m_flags |= XFS_MOUNT_WSYNC;
  		return 0;
  	case Opt_norecovery:
- 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		parsing_mp->m_flags |= XFS_MOUNT_NORECOVERY;
  		return 0;
  	case Opt_noalign:
- 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		parsing_mp->m_flags |= XFS_MOUNT_NOALIGN;
  		return 0;
  	case Opt_swalloc:
- 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		parsing_mp->m_flags |= XFS_MOUNT_SWALLOC;
  		return 0;
  	case Opt_sunit:
- 		mp->m_dalign = result.uint_32;
+ 		parsing_mp->m_dalign = result.uint_32;
  		return 0;
  	case Opt_swidth:
- 		mp->m_swidth = result.uint_32;
+ 		parsing_mp->m_swidth = result.uint_32;
  		return 0;
  	case Opt_inode32:
- 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		parsing_mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
  		return 0;
  	case Opt_inode64:
- 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		parsing_mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
  		return 0;
  	case Opt_nouuid:
- 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		parsing_mp->m_flags |= XFS_MOUNT_NOUUID;
  		return 0;
 +	case Opt_ikeep:
 +		mp->m_flags |= XFS_MOUNT_IKEEP;
 +		return 0;
 +	case Opt_noikeep:
 +		mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +		return 0;
  	case Opt_largeio:
- 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		parsing_mp->m_flags |= XFS_MOUNT_LARGEIO;
  		return 0;
  	case Opt_nolargeio:
- 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		parsing_mp->m_flags &= ~XFS_MOUNT_LARGEIO;
  		return 0;
 +	case Opt_attr2:
 +		mp->m_flags |= XFS_MOUNT_ATTR2;
 +		return 0;
 +	case Opt_noattr2:
 +		mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +		mp->m_flags |= XFS_MOUNT_NOATTR2;
 +		return 0;
  	case Opt_filestreams:
- 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		parsing_mp->m_flags |= XFS_MOUNT_FILESTREAMS;
  		return 0;
  	case Opt_noquota:
- 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
- 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
- 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		parsing_mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		parsing_mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		parsing_mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
  		return 0;
  	case Opt_quota:
  	case Opt_uquota:
@@@ -1279,14 -1257,32 +1284,35 @@@
  		return 0;
  #ifdef CONFIG_FS_DAX
  	case Opt_dax:
- 		xfs_mount_set_dax_mode(mp, XFS_DAX_ALWAYS);
+ 		xfs_mount_set_dax_mode(parsing_mp, XFS_DAX_ALWAYS);
  		return 0;
  	case Opt_dax_enum:
- 		xfs_mount_set_dax_mode(mp, result.uint_32);
+ 		xfs_mount_set_dax_mode(parsing_mp, result.uint_32);
  		return 0;
  #endif
++<<<<<<< HEAD
++=======
+ 	/* Following mount options will be removed in September 2025 */
+ 	case Opt_ikeep:
+ 		xfs_warn(parsing_mp, "%s mount option is deprecated.", param->key);
+ 		parsing_mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		xfs_warn(parsing_mp, "%s mount option is deprecated.", param->key);
+ 		parsing_mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_attr2:
+ 		xfs_warn(parsing_mp, "%s mount option is deprecated.", param->key);
+ 		parsing_mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		xfs_warn(parsing_mp, "%s mount option is deprecated.", param->key);
+ 		parsing_mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		parsing_mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
++>>>>>>> 0f98b4ece18d (xfs: rename variable mp to parsing_mp)
  	default:
- 		xfs_warn(mp, "unknown mount option [%s].", param->key);
+ 		xfs_warn(parsing_mp, "unknown mount option [%s].", param->key);
  		return -EINVAL;
  	}
  
* Unmerged path fs/xfs/xfs_super.c
