NFSD: Remove trace_nfsd_clid_inuse_err

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 0bfaacac57e64aa342f865b8ddcab06ca59a6f83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/0bfaacac.failed

This tracepoint has been replaced by nfsd_clid_cred_mismatch and
nfsd_clid_verf_mismatch, and can simply be removed.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 0bfaacac57e64aa342f865b8ddcab06ca59a6f83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/trace.h
diff --cc fs/nfsd/trace.h
index 2c7ada5dbc70,1265d6f058ee..000000000000
--- a/fs/nfsd/trace.h
+++ b/fs/nfsd/trace.h
@@@ -577,30 -596,146 +577,173 @@@ TRACE_EVENT(nfsd_clid_verf_mismatch
  	)
  );
  
++<<<<<<< HEAD
 +TRACE_EVENT(nfsd_clid_inuse_err,
 +	TP_PROTO(const struct nfs4_client *clp),
 +	TP_ARGS(clp),
 +	TP_STRUCT__entry(
 +		__field(u32, cl_boot)
 +		__field(u32, cl_id)
 +		__array(unsigned char, addr, sizeof(struct sockaddr_in6))
 +		__field(unsigned int, namelen)
 +		__dynamic_array(unsigned char, name, clp->cl_name.len)
 +	),
 +	TP_fast_assign(
 +		__entry->cl_boot = clp->cl_clientid.cl_boot;
 +		__entry->cl_id = clp->cl_clientid.cl_id;
 +		memcpy(__entry->addr, &clp->cl_addr,
 +			sizeof(struct sockaddr_in6));
 +		__entry->namelen = clp->cl_name.len;
 +		memcpy(__get_dynamic_array(name), clp->cl_name.data,
 +			clp->cl_name.len);
 +	),
 +	TP_printk("nfs4_clientid %.*s already in use by %pISpc, client %08x:%08x",
 +		__entry->namelen, __get_str(name), __entry->addr,
 +		__entry->cl_boot, __entry->cl_id)
 +)
 +
++=======
+ /*
+  * from fs/nfsd/filecache.h
+  */
+ TRACE_DEFINE_ENUM(NFSD_FILE_HASHED);
+ TRACE_DEFINE_ENUM(NFSD_FILE_PENDING);
+ TRACE_DEFINE_ENUM(NFSD_FILE_BREAK_READ);
+ TRACE_DEFINE_ENUM(NFSD_FILE_BREAK_WRITE);
+ TRACE_DEFINE_ENUM(NFSD_FILE_REFERENCED);
+ 
+ #define show_nf_flags(val)						\
+ 	__print_flags(val, "|",						\
+ 		{ 1 << NFSD_FILE_HASHED,	"HASHED" },		\
+ 		{ 1 << NFSD_FILE_PENDING,	"PENDING" },		\
+ 		{ 1 << NFSD_FILE_BREAK_READ,	"BREAK_READ" },		\
+ 		{ 1 << NFSD_FILE_BREAK_WRITE,	"BREAK_WRITE" },	\
+ 		{ 1 << NFSD_FILE_REFERENCED,	"REFERENCED"})
+ 
+ DECLARE_EVENT_CLASS(nfsd_file_class,
+ 	TP_PROTO(struct nfsd_file *nf),
+ 	TP_ARGS(nf),
+ 	TP_STRUCT__entry(
+ 		__field(unsigned int, nf_hashval)
+ 		__field(void *, nf_inode)
+ 		__field(int, nf_ref)
+ 		__field(unsigned long, nf_flags)
+ 		__field(unsigned char, nf_may)
+ 		__field(struct file *, nf_file)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->nf_hashval = nf->nf_hashval;
+ 		__entry->nf_inode = nf->nf_inode;
+ 		__entry->nf_ref = refcount_read(&nf->nf_ref);
+ 		__entry->nf_flags = nf->nf_flags;
+ 		__entry->nf_may = nf->nf_may;
+ 		__entry->nf_file = nf->nf_file;
+ 	),
+ 	TP_printk("hash=0x%x inode=%p ref=%d flags=%s may=%s file=%p",
+ 		__entry->nf_hashval,
+ 		__entry->nf_inode,
+ 		__entry->nf_ref,
+ 		show_nf_flags(__entry->nf_flags),
+ 		show_nfsd_may_flags(__entry->nf_may),
+ 		__entry->nf_file)
+ )
+ 
+ #define DEFINE_NFSD_FILE_EVENT(name) \
+ DEFINE_EVENT(nfsd_file_class, name, \
+ 	TP_PROTO(struct nfsd_file *nf), \
+ 	TP_ARGS(nf))
+ 
+ DEFINE_NFSD_FILE_EVENT(nfsd_file_alloc);
+ DEFINE_NFSD_FILE_EVENT(nfsd_file_put_final);
+ DEFINE_NFSD_FILE_EVENT(nfsd_file_unhash);
+ DEFINE_NFSD_FILE_EVENT(nfsd_file_put);
+ DEFINE_NFSD_FILE_EVENT(nfsd_file_unhash_and_release_locked);
+ 
+ TRACE_EVENT(nfsd_file_acquire,
+ 	TP_PROTO(struct svc_rqst *rqstp, unsigned int hash,
+ 		 struct inode *inode, unsigned int may_flags,
+ 		 struct nfsd_file *nf, __be32 status),
+ 
+ 	TP_ARGS(rqstp, hash, inode, may_flags, nf, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(u32, xid)
+ 		__field(unsigned int, hash)
+ 		__field(void *, inode)
+ 		__field(unsigned long, may_flags)
+ 		__field(int, nf_ref)
+ 		__field(unsigned long, nf_flags)
+ 		__field(unsigned long, nf_may)
+ 		__field(struct file *, nf_file)
+ 		__field(u32, status)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = be32_to_cpu(rqstp->rq_xid);
+ 		__entry->hash = hash;
+ 		__entry->inode = inode;
+ 		__entry->may_flags = may_flags;
+ 		__entry->nf_ref = nf ? refcount_read(&nf->nf_ref) : 0;
+ 		__entry->nf_flags = nf ? nf->nf_flags : 0;
+ 		__entry->nf_may = nf ? nf->nf_may : 0;
+ 		__entry->nf_file = nf ? nf->nf_file : NULL;
+ 		__entry->status = be32_to_cpu(status);
+ 	),
+ 
+ 	TP_printk("xid=0x%x hash=0x%x inode=%p may_flags=%s ref=%d nf_flags=%s nf_may=%s nf_file=%p status=%u",
+ 			__entry->xid, __entry->hash, __entry->inode,
+ 			show_nfsd_may_flags(__entry->may_flags),
+ 			__entry->nf_ref, show_nf_flags(__entry->nf_flags),
+ 			show_nfsd_may_flags(__entry->nf_may),
+ 			__entry->nf_file, __entry->status)
+ );
+ 
+ DECLARE_EVENT_CLASS(nfsd_file_search_class,
+ 	TP_PROTO(struct inode *inode, unsigned int hash, int found),
+ 	TP_ARGS(inode, hash, found),
+ 	TP_STRUCT__entry(
+ 		__field(struct inode *, inode)
+ 		__field(unsigned int, hash)
+ 		__field(int, found)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->inode = inode;
+ 		__entry->hash = hash;
+ 		__entry->found = found;
+ 	),
+ 	TP_printk("hash=0x%x inode=%p found=%d", __entry->hash,
+ 			__entry->inode, __entry->found)
+ );
+ 
+ #define DEFINE_NFSD_FILE_SEARCH_EVENT(name)				\
+ DEFINE_EVENT(nfsd_file_search_class, name,				\
+ 	TP_PROTO(struct inode *inode, unsigned int hash, int found),	\
+ 	TP_ARGS(inode, hash, found))
+ 
+ DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode_sync);
+ DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode);
+ DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_is_cached);
+ 
+ TRACE_EVENT(nfsd_file_fsnotify_handle_event,
+ 	TP_PROTO(struct inode *inode, u32 mask),
+ 	TP_ARGS(inode, mask),
+ 	TP_STRUCT__entry(
+ 		__field(struct inode *, inode)
+ 		__field(unsigned int, nlink)
+ 		__field(umode_t, mode)
+ 		__field(u32, mask)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->inode = inode;
+ 		__entry->nlink = inode->i_nlink;
+ 		__entry->mode = inode->i_mode;
+ 		__entry->mask = mask;
+ 	),
+ 	TP_printk("inode=%p nlink=%u mode=0%ho mask=0x%x", __entry->inode,
+ 			__entry->nlink, __entry->mode, __entry->mask)
+ );
+ 
++>>>>>>> 0bfaacac57e6 (NFSD: Remove trace_nfsd_clid_inuse_err)
  #include "cache.h"
  
  TRACE_DEFINE_ENUM(RC_DROPIT);
* Unmerged path fs/nfsd/trace.h
