SUNRPC: Change return value type of .pc_encode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 130e2054d4a652a2bd79fb1557ddcd19c053cb37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/130e2054.failed

Returning an undecorated integer is an age-old trope, but it's
not clear (even to previous experts in this code) that the only
valid return values are 1 and 0. These functions do not return
a negative errno, rpc_stat value, or a positive length.

Document there are only two valid return values by having
.pc_encode return only true or false.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 130e2054d4a652a2bd79fb1557ddcd19c053cb37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/lockd/xdr.c
#	fs/lockd/xdr4.c
#	fs/nfs/callback_xdr.c
#	fs/nfsd/nfs2acl.c
#	fs/nfsd/nfs3acl.c
#	fs/nfsd/nfs3xdr.c
#	fs/nfsd/nfs4xdr.c
#	fs/nfsd/nfsd.h
#	fs/nfsd/nfssvc.c
#	fs/nfsd/nfsxdr.c
#	fs/nfsd/xdr.h
#	fs/nfsd/xdr3.h
#	fs/nfsd/xdr4.h
#	include/linux/lockd/xdr.h
#	include/linux/lockd/xdr4.h
#	include/linux/sunrpc/svc.h
diff --cc fs/lockd/xdr.c
index 9235e60b1769,2fb5748dae0c..000000000000
--- a/fs/lockd/xdr.c
+++ b/fs/lockd/xdr.c
@@@ -320,36 -313,33 +320,56 @@@ nlmsvc_decode_notify(struct svc_rqst *r
   * Encode Reply results
   */
  
++<<<<<<< HEAD
 +int
 +nlmsvc_encode_void(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_encode_testres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_encode_testres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nlm_res *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_cookie(xdr, &resp->cookie) &&
  		svcxdr_encode_testrply(xdr, resp);
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_encode_res(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_encode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nlm_res *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_cookie(xdr, &resp->cookie) &&
  		svcxdr_encode_stats(xdr, resp->status);
  }
  
++<<<<<<< HEAD
 +int
 +nlmsvc_encode_shareres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlmsvc_encode_shareres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nlm_res *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_cookie(xdr, &resp->cookie))
diff --cc fs/lockd/xdr4.c
index 98e957e4566c,856267c0864b..000000000000
--- a/fs/lockd/xdr4.c
+++ b/fs/lockd/xdr4.c
@@@ -318,36 -312,33 +318,56 @@@ nlm4svc_decode_notify(struct svc_rqst *
   * Encode Reply results
   */
  
++<<<<<<< HEAD
 +int
 +nlm4svc_encode_void(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_encode_testres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_encode_testres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nlm_res *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_cookie(xdr, &resp->cookie) &&
  		svcxdr_encode_testrply(xdr, resp);
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_encode_res(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_encode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nlm_res *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_cookie(xdr, &resp->cookie) &&
  		svcxdr_encode_stats(xdr, resp->status);
  }
  
++<<<<<<< HEAD
 +int
 +nlm4svc_encode_shareres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nlm4svc_encode_shareres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nlm_res *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_cookie(xdr, &resp->cookie))
diff --cc fs/nfs/callback_xdr.c
index 4c48d85f6517,a67c41ec545f..000000000000
--- a/fs/nfs/callback_xdr.c
+++ b/fs/nfs/callback_xdr.c
@@@ -67,9 -67,9 +67,15 @@@ static __be32 nfs4_callback_null(struc
   * svc_process_common() looks for an XDR encoder to know when
   * not to drop a Reply.
   */
++<<<<<<< HEAD
 +static int nfs4_encode_void(struct svc_rqst *rqstp, __be32 *p)
 +{
 +	return xdr_ressize_check(rqstp, p);
++=======
+ static bool nfs4_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)
+ {
+ 	return true;
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  }
  
  static __be32 decode_string(struct xdr_stream *xdr, unsigned int *len,
diff --cc fs/nfsd/nfs2acl.c
index 8703326fc165,367551bddfc6..000000000000
--- a/fs/nfsd/nfs2acl.c
+++ b/fs/nfsd/nfs2acl.c
@@@ -238,9 -240,9 +238,14 @@@ static int nfsaclsvc_decode_accessargs(
   */
  
  /* GETACL */
++<<<<<<< HEAD
 +static int nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_getaclres *resp = rqstp->rq_resp;
  	struct dentry *dentry = resp->fh.fh_dentry;
  	struct inode *inode;
@@@ -278,9 -280,9 +283,14 @@@
  }
  
  /* ACCESS */
++<<<<<<< HEAD
 +static int nfsaclsvc_encode_accessres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfsaclsvc_encode_accessres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_accessres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_stat(xdr, resp->status))
diff --cc fs/nfsd/nfs3acl.c
index bcb2fc5c7b99,35b2ebda14da..000000000000
--- a/fs/nfsd/nfs3acl.c
+++ b/fs/nfsd/nfs3acl.c
@@@ -169,9 -166,9 +169,14 @@@ static int nfs3svc_decode_setaclargs(st
   */
  
  /* GETACL */
++<<<<<<< HEAD
 +static int nfs3svc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfs3svc_encode_getaclres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_getaclres *resp = rqstp->rq_resp;
  	struct dentry *dentry = resp->fh.fh_dentry;
  	struct kvec *head = rqstp->rq_res.head;
@@@ -221,9 -218,9 +226,14 @@@
  }
  
  /* SETACL */
++<<<<<<< HEAD
 +static int nfs3svc_encode_setaclres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ static bool
+ nfs3svc_encode_setaclres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_attrstat *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_nfsstat3(xdr, resp->status) &&
diff --cc fs/nfsd/nfs3xdr.c
index 657ede6555bb,c3ac1b6aa3aa..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -914,10 -812,9 +914,15 @@@ nfs3svc_decode_commitargs(struct svc_rq
   */
  
  /* GETATTR */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_getattrres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_getattrres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_attrstat *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -934,10 -831,9 +939,15 @@@
  }
  
  /* SETATTR, REMOVE, RMDIR */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_wccstat(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_wccstat(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_attrstat *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_nfsstat3(xdr, resp->status) &&
@@@ -945,9 -841,9 +955,14 @@@
  }
  
  /* LOOKUP */
++<<<<<<< HEAD
 +int nfs3svc_encode_lookupres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_lookupres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_diropres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -970,10 -866,9 +985,15 @@@
  }
  
  /* ACCESS */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_accessres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_accessres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_accessres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -994,10 -889,9 +1014,15 @@@
  }
  
  /* READLINK */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_readlinkres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_readlinkres *resp = rqstp->rq_resp;
  	struct kvec *head = rqstp->rq_res.head;
  
@@@ -1022,10 -916,9 +1047,15 @@@
  }
  
  /* READ */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_readres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_readres *resp = rqstp->rq_resp;
  	struct kvec *head = rqstp->rq_res.head;
  
@@@ -1055,31 -948,36 +1085,63 @@@
  }
  
  /* WRITE */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_writeres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_writeres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
  	struct nfsd3_writeres *resp = rqstp->rq_resp;
 +	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
 +	__be32 verf[2];
 +
++<<<<<<< HEAD
 +	*p++ = resp->status;
 +	p = encode_wcc_data(rqstp, p, &resp->fh);
 +	if (resp->status == 0) {
 +		*p++ = htonl(resp->count);
 +		*p++ = htonl(resp->committed);
 +		/* unique identifier, y2038 overflow can be ignored */
 +		nfsd_copy_boot_verifier(verf, nn);
 +		*p++ = verf[0];
 +		*p++ = verf[1];
 +	}
 +	return xdr_ressize_check(rqstp, p);
 +}
  
 +/* CREATE, MKDIR, SYMLINK, MKNOD */
 +int
 +nfs3svc_encode_createres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ 	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
+ 		return false;
+ 	switch (resp->status) {
+ 	case nfs_ok:
+ 		if (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))
+ 			return false;
+ 		if (xdr_stream_encode_u32(xdr, resp->count) < 0)
+ 			return false;
+ 		if (xdr_stream_encode_u32(xdr, resp->committed) < 0)
+ 			return false;
+ 		if (!svcxdr_encode_writeverf3(xdr, resp->verf))
+ 			return false;
+ 		break;
+ 	default:
+ 		if (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /* CREATE, MKDIR, SYMLINK, MKNOD */
+ bool
+ nfs3svc_encode_createres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_diropres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -1102,10 -1000,9 +1164,15 @@@
  }
  
  /* RENAME */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_renameres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_renameres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_renameres *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_nfsstat3(xdr, resp->status) &&
@@@ -1114,10 -1011,9 +1181,15 @@@
  }
  
  /* LINK */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_linkres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_linkres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_linkres *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_nfsstat3(xdr, resp->status) &&
@@@ -1126,44 -1022,33 +1198,73 @@@
  }
  
  /* READDIR */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_readdirres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
  	struct nfsd3_readdirres *resp = rqstp->rq_resp;
 -	struct xdr_buf *dirlist = &resp->dirlist;
  
++<<<<<<< HEAD
 +	*p++ = resp->status;
 +	p = encode_post_op_attr(rqstp, p, &resp->fh);
 +
 +	if (resp->status == 0) {
 +		/* stupid readdir cookie */
 +		memcpy(p, resp->verf, 8); p += 2;
 +		xdr_ressize_check(rqstp, p);
 +		if (rqstp->rq_res.head[0].iov_len + (2<<2) > PAGE_SIZE)
 +			return 1; /*No room for trailer */
 +		rqstp->rq_res.page_len = (resp->count) << 2;
 +
 +		/* add the 'tail' to the end of the 'head' page - page 0. */
 +		rqstp->rq_res.tail[0].iov_base = p;
 +		*p++ = 0;		/* no more entries */
 +		*p++ = htonl(resp->common.err == nfserr_eof);
 +		rqstp->rq_res.tail[0].iov_len = 2<<2;
 +		return 1;
 +	} else
 +		return xdr_ressize_check(rqstp, p);
 +}
 +
 +static __be32 *
 +encode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,
 +	     int namlen, u64 ino)
 +{
 +	*p++ = xdr_one;				 /* mark entry present */
 +	p    = xdr_encode_hyper(p, ino);	 /* file id */
 +	p    = xdr_encode_array(p, name, namlen);/* name length & name */
 +
 +	cd->offset = p;				/* remember pointer */
 +	p = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */
 +
 +	return p;
++=======
+ 	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
+ 		return false;
+ 	switch (resp->status) {
+ 	case nfs_ok:
+ 		if (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))
+ 			return false;
+ 		if (!svcxdr_encode_cookieverf3(xdr, resp->verf))
+ 			return false;
+ 		xdr_write_pages(xdr, dirlist->pages, 0, dirlist->len);
+ 		/* no more entries */
+ 		if (xdr_stream_encode_item_absent(xdr) < 0)
+ 			return false;
+ 		if (xdr_stream_encode_bool(xdr, resp->common.err == nfserr_eof) < 0)
+ 			return false;
+ 		break;
+ 	default:
+ 		if (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))
+ 			return false;
+ 	}
+ 
+ 	return true;
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  }
  
  static __be32
@@@ -1414,10 -1275,9 +1515,15 @@@ svcxdr_encode_fsstat3resok(struct xdr_s
  }
  
  /* FSSTAT */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_fsstatres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_fsstatres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -1461,10 -1321,9 +1567,15 @@@ svcxdr_encode_fsinfo3resok(struct xdr_s
  }
  
  /* FSINFO */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_fsinfores(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_fsinfores(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_fsinfores *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -1504,10 -1363,9 +1615,15 @@@ svcxdr_encode_pathconf3resok(struct xdr
  }
  
  /* PATHCONF */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_pathconfres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_pathconfres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_pathconfres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
@@@ -1528,23 -1386,26 +1644,46 @@@
  }
  
  /* COMMIT */
++<<<<<<< HEAD
 +int
 +nfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs3svc_encode_commitres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
  	struct nfsd3_commitres *resp = rqstp->rq_resp;
 -
 +	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
 +	__be32 verf[2];
 +
++<<<<<<< HEAD
 +	*p++ = resp->status;
 +	p = encode_wcc_data(rqstp, p, &resp->fh);
 +	/* Write verifier */
 +	if (resp->status == 0) {
 +		/* unique identifier, y2038 overflow can be ignored */
 +		nfsd_copy_boot_verifier(verf, nn);
 +		*p++ = verf[0];
 +		*p++ = verf[1];
 +	}
 +	return xdr_ressize_check(rqstp, p);
++=======
+ 	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
+ 		return false;
+ 	switch (resp->status) {
+ 	case nfs_ok:
+ 		if (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))
+ 			return false;
+ 		if (!svcxdr_encode_writeverf3(xdr, resp->verf))
+ 			return false;
+ 		break;
+ 	default:
+ 		if (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))
+ 			return false;
+ 	}
+ 
+ 	return true;
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  }
  
  /*
diff --cc fs/nfsd/nfs4xdr.c
index cf0d08d4c2a7,9b609aac47e1..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -5032,14 -5421,17 +5032,19 @@@ nfs4svc_decode_compoundargs(struct svc_
  	args->ops = args->iops;
  	args->rqstp = rqstp;
  
 -	return nfsd4_decode_compound(args);
 +	return !nfsd4_decode_compound(args);
  }
  
++<<<<<<< HEAD
 +int
 +nfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfs4svc_encode_compoundres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
  	struct nfsd4_compoundres *resp = rqstp->rq_resp;
 -	struct xdr_buf *buf = xdr->buf;
 -	__be32 *p;
 +	struct xdr_buf *buf = resp->xdr.buf;
  
  	WARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +
  				 buf->tail[0].iov_len);
@@@ -5055,11 -5452,5 +5060,11 @@@
  	*p++ = htonl(resp->opcnt);
  
  	nfsd4_sequence_done(resp);
- 	return 1;
+ 	return true;
  }
 +
 +/*
 + * Local variables:
 + *  c-basic-offset: 8
 + * End:
 + */
diff --cc fs/nfsd/nfsd.h
index 6f7f06b891ab,498e5a489826..000000000000
--- a/fs/nfsd/nfsd.h
+++ b/fs/nfsd/nfsd.h
@@@ -77,8 -78,10 +77,15 @@@ extern const struct seq_operations nfs_
   */
  struct nfsd_voidargs { };
  struct nfsd_voidres { };
++<<<<<<< HEAD
 +int		nfssvc_decode_voidarg(struct svc_rqst *rqstp, __be32 *p);
 +int		nfssvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p);
++=======
+ bool		nfssvc_decode_voidarg(struct svc_rqst *rqstp,
+ 				      struct xdr_stream *xdr);
+ bool		nfssvc_encode_voidres(struct svc_rqst *rqstp,
+ 				      struct xdr_stream *xdr);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  
  /*
   * Function prototypes.
diff --cc fs/nfsd/nfssvc.c
index 5e028e1a2313,362e819ff06a..000000000000
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@@ -1074,15 -1075,15 +1074,21 @@@ int nfssvc_decode_voidarg(struct svc_rq
  /**
   * nfssvc_encode_voidres - Encode void results
   * @rqstp: Server RPC transaction context
 - * @xdr: XDR stream into which to encode results
 + * @p: buffer in which to encode results
   *
   * Return values:
-  *   %0: Local error while encoding
-  *   %1: Encoding was successful
+  *   %false: Local error while encoding
+  *   %true: Encoding was successful
   */
++<<<<<<< HEAD
 +int nfssvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p)
 +{
 +        return xdr_ressize_check(rqstp, p);
++=======
+ bool nfssvc_encode_voidres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
+ {
+ 	return true;
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  }
  
  int nfsd_pool_stats_open(struct inode *inode, struct file *file)
diff --cc fs/nfsd/nfsxdr.c
index 1c01c0cb3914,aba8520b4b8b..000000000000
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@@ -431,19 -414,17 +431,29 @@@ nfssvc_decode_readdirargs(struct svc_rq
   * XDR encode functions
   */
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_statres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_statres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_stat *resp = rqstp->rq_resp;
  
  	return svcxdr_encode_stat(xdr, resp->status);
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_attrstatres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_attrstatres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_attrstat *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_stat(xdr, resp->status))
@@@ -455,13 -436,12 +465,18 @@@
  		break;
  	}
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_diropres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_diropres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_diropres *resp = rqstp->rq_resp;
  
  	if (!svcxdr_encode_stat(xdr, resp->status))
@@@ -475,13 -455,12 +490,18 @@@
  		break;
  	}
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_readlinkres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_readlinkres *resp = rqstp->rq_resp;
  	struct kvec *head = rqstp->rq_res.head;
  
@@@ -497,13 -476,12 +517,18 @@@
  		break;
  	}
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_readres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_readres *resp = rqstp->rq_resp;
  	struct kvec *head = rqstp->rq_res.head;
  
@@@ -522,36 -500,40 +547,61 @@@
  		break;
  	}
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_readdirres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
  	struct nfsd_readdirres *resp = rqstp->rq_resp;
 -	struct xdr_buf *dirlist = &resp->dirlist;
  
++<<<<<<< HEAD
 +	*p++ = resp->status;
 +	if (resp->status != nfs_ok)
 +		return xdr_ressize_check(rqstp, p);
 +
 +	xdr_ressize_check(rqstp, p);
 +	p = resp->buffer;
 +	*p++ = 0;			/* no more entries */
 +	*p++ = htonl((resp->common.err == nfserr_eof));
 +	rqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;
++=======
+ 	if (!svcxdr_encode_stat(xdr, resp->status))
+ 		return false;
+ 	switch (resp->status) {
+ 	case nfs_ok:
+ 		xdr_write_pages(xdr, dirlist->pages, 0, dirlist->len);
+ 		/* no more entries */
+ 		if (xdr_stream_encode_item_absent(xdr) < 0)
+ 			return false;
+ 		if (xdr_stream_encode_bool(xdr, resp->common.err == nfserr_eof) < 0)
+ 			return false;
+ 		break;
+ 	}
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  
- 	return 1;
+ 	return true;
  }
  
++<<<<<<< HEAD
 +int
 +nfssvc_encode_statfsres(struct svc_rqst *rqstp, __be32 *p)
++=======
+ bool
+ nfssvc_encode_statfsres(struct svc_rqst *rqstp, struct xdr_stream *xdr)
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  {
 +	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd_statfsres *resp = rqstp->rq_resp;
  	struct kstatfs	*stat = &resp->stats;
 -	__be32 *p;
  
  	if (!svcxdr_encode_stat(xdr, resp->status))
- 		return 0;
+ 		return false;
  	switch (resp->status) {
  	case nfs_ok:
  		p = xdr_reserve_space(xdr, XDR_UNIT * 5);
@@@ -565,52 -547,94 +615,52 @@@
  		break;
  	}
  
- 	return 1;
+ 	return true;
  }
  
 -/**
 - * nfssvc_encode_nfscookie - Encode a directory offset cookie
 - * @resp: readdir result context
 - * @offset: offset cookie to encode
 - *
 - * The buffer space for the offset cookie has already been reserved
 - * by svcxdr_encode_entry_common().
 - */
 -void nfssvc_encode_nfscookie(struct nfsd_readdirres *resp, u32 offset)
 +int
 +nfssvc_encode_entry(void *ccdv, const char *name,
 +		    int namlen, loff_t offset, u64 ino, unsigned int d_type)
  {
 -	__be32 cookie = cpu_to_be32(offset);
 +	struct readdir_cd *ccd = ccdv;
 +	struct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);
 +	__be32	*p = cd->buffer;
 +	int	buflen, slen;
  
 -	if (!resp->cookie_offset)
 -		return;
 -
 -	write_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,
 -			       sizeof(cookie));
 -	resp->cookie_offset = 0;
 -}
 -
 -static bool
 -svcxdr_encode_entry_common(struct nfsd_readdirres *resp, const char *name,
 -			   int namlen, loff_t offset, u64 ino)
 -{
 -	struct xdr_buf *dirlist = &resp->dirlist;
 -	struct xdr_stream *xdr = &resp->xdr;
 -
 -	if (xdr_stream_encode_item_present(xdr) < 0)
 -		return false;
 -	/* fileid */
 -	if (xdr_stream_encode_u32(xdr, (u32)ino) < 0)
 -		return false;
 -	/* name */
 -	if (xdr_stream_encode_opaque(xdr, name, min(namlen, NFS2_MAXNAMLEN)) < 0)
 -		return false;
 -	/* cookie */
 -	resp->cookie_offset = dirlist->len;
 -	if (xdr_stream_encode_u32(xdr, ~0U) < 0)
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * nfssvc_encode_entry - encode one NFSv2 READDIR entry
 - * @data: directory context
 - * @name: name of the object to be encoded
 - * @namlen: length of that name, in bytes
 - * @offset: the offset of the previous entry
 - * @ino: the fileid of this entry
 - * @d_type: unused
 - *
 - * Return values:
 - *   %0: Entry was successfully encoded.
 - *   %-EINVAL: An encoding problem occured, secondary status code in resp->common.err
 - *
 - * On exit, the following fields are updated:
 - *   - resp->xdr
 - *   - resp->common.err
 - *   - resp->cookie_offset
 - */
 -int nfssvc_encode_entry(void *data, const char *name, int namlen,
 -			loff_t offset, u64 ino, unsigned int d_type)
 -{
 -	struct readdir_cd *ccd = data;
 -	struct nfsd_readdirres *resp = container_of(ccd,
 -						    struct nfsd_readdirres,
 -						    common);
 -	unsigned int starting_length = resp->dirlist.len;
 +	/*
 +	dprintk("nfsd: entry(%.*s off %ld ino %ld)\n",
 +			namlen, name, offset, ino);
 +	 */
  
 -	/* The offset cookie for the previous entry */
 -	nfssvc_encode_nfscookie(resp, offset);
 +	if (offset > ~((u32) 0)) {
 +		cd->common.err = nfserr_fbig;
 +		return -EINVAL;
 +	}
 +	if (cd->offset)
 +		*cd->offset = htonl(offset);
  
 -	if (!svcxdr_encode_entry_common(resp, name, namlen, offset, ino))
 -		goto out_toosmall;
 +	/* truncate filename */
 +	namlen = min(namlen, NFS2_MAXNAMLEN);
 +	slen = XDR_QUADLEN(namlen);
  
 -	xdr_commit_encode(&resp->xdr);
 -	resp->common.err = nfs_ok;
 +	if ((buflen = cd->buflen - slen - 4) < 0) {
 +		cd->common.err = nfserr_toosmall;
 +		return -EINVAL;
 +	}
 +	if (ino > ~((u32) 0)) {
 +		cd->common.err = nfserr_fbig;
 +		return -EINVAL;
 +	}
 +	*p++ = xdr_one;				/* mark entry present */
 +	*p++ = htonl((u32) ino);		/* file id */
 +	p    = xdr_encode_array(p, name, namlen);/* name length & name */
 +	cd->offset = p;			/* remember pointer */
 +	*p++ = htonl(~0U);		/* offset of next entry */
 +
 +	cd->buflen = buflen;
 +	cd->buffer = p;
 +	cd->common.err = nfs_ok;
  	return 0;
 -
 -out_toosmall:
 -	resp->cookie_offset = 0;
 -	resp->common.err = nfserr_toosmall;
 -	resp->dirlist.len = starting_length;
 -	return -EINVAL;
  }
  
  /*
diff --cc fs/nfsd/xdr.h
index 6f3851dc237e,528fb299430e..000000000000
--- a/fs/nfsd/xdr.h
+++ b/fs/nfsd/xdr.h
@@@ -140,26 -141,28 +140,40 @@@ union nfsd_xdrstore 
  #define NFS2_SVC_XDRSIZE	sizeof(union nfsd_xdrstore)
  
  
 -bool nfssvc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool nfssvc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -
 +int nfssvc_decode_fhandleargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_sattrargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_diropargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_readargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_writeargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_createargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_renameargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_linkargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_symlinkargs(struct svc_rqst *, __be32 *);
 +int nfssvc_decode_readdirargs(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_statres(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_attrstatres(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_diropres(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_readlinkres(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_readres(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_statfsres(struct svc_rqst *, __be32 *);
 +int nfssvc_encode_readdirres(struct svc_rqst *, __be32 *);
 +
++<<<<<<< HEAD
 +int nfssvc_encode_entry(void *, const char *name,
 +			int namlen, loff_t offset, u64 ino, unsigned int);
++=======
+ bool nfssvc_encode_statres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_encode_attrstatres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_encode_diropres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_encode_readlinkres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_encode_readres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_encode_statfsres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfssvc_encode_readdirres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ 
+ void nfssvc_encode_nfscookie(struct nfsd_readdirres *resp, u32 offset);
+ int nfssvc_encode_entry(void *data, const char *name, int namlen,
+ 			loff_t offset, u64 ino, unsigned int d_type);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  
  void nfssvc_release_attrstat(struct svc_rqst *rqstp);
  void nfssvc_release_diropres(struct svc_rqst *rqstp);
diff --cc fs/nfsd/xdr3.h
index 05db8ca205b1,03fe4e21306c..000000000000
--- a/fs/nfsd/xdr3.h
+++ b/fs/nfsd/xdr3.h
@@@ -266,36 -265,37 +266,70 @@@ union nfsd3_xdrstore 
  
  #define NFS3_SVC_XDRSIZE		sizeof(union nfsd3_xdrstore)
  
++<<<<<<< HEAD
 +int nfs3svc_decode_fhandleargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_sattrargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_diropargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_accessargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_readargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_writeargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_createargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_mkdirargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_mknodargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_renameargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_linkargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_symlinkargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_readdirargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_readdirplusargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_decode_commitargs(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_getattrres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_wccstat(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_lookupres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_accessres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_readlinkres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_readres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_writeres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_createres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_renameres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_linkres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_readdirres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_fsstatres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_fsinfores(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_pathconfres(struct svc_rqst *, __be32 *);
 +int nfs3svc_encode_commitres(struct svc_rqst *, __be32 *);
++=======
+ bool nfs3svc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_accessargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_mknodargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_decode_commitargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ 
+ bool nfs3svc_encode_getattrres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_wccstat(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_lookupres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_accessres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_readlinkres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_readres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_writeres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_createres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_renameres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_linkres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_readdirres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_fsstatres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_fsinfores(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_pathconfres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs3svc_encode_commitres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  
  void nfs3svc_release_fhandle(struct svc_rqst *);
  void nfs3svc_release_fhandle2(struct svc_rqst *);
diff --cc fs/nfsd/xdr4.h
index 4ef0f6d3f1d7,846ab6df9d48..000000000000
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@@ -750,8 -757,8 +750,13 @@@ set_change_info(struct nfsd4_change_inf
  
  
  bool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp);
++<<<<<<< HEAD
 +int nfs4svc_decode_compoundargs(struct svc_rqst *, __be32 *);
 +int nfs4svc_encode_compoundres(struct svc_rqst *, __be32 *);
++=======
+ bool nfs4svc_decode_compoundargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool nfs4svc_encode_compoundres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  __be32 nfsd4_check_resp_size(struct nfsd4_compoundres *, u32);
  void nfsd4_encode_operation(struct nfsd4_compoundres *, struct nfsd4_op *);
  void nfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op);
diff --cc include/linux/lockd/xdr.h
index a98309c0121c,398f70093cd3..000000000000
--- a/include/linux/lockd/xdr.h
+++ b/include/linux/lockd/xdr.h
@@@ -96,18 -96,19 +96,35 @@@ struct nlm_reboot 
   */
  #define NLMSVC_XDRSIZE		sizeof(struct nlm_args)
  
++<<<<<<< HEAD
 +int	nlmsvc_decode_testargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_encode_testres(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_lockargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_cancargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_unlockargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_encode_res(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_res(struct svc_rqst *, __be32 *);
 +int	nlmsvc_encode_void(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_void(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_shareargs(struct svc_rqst *, __be32 *);
 +int	nlmsvc_encode_shareres(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_notify(struct svc_rqst *, __be32 *);
 +int	nlmsvc_decode_reboot(struct svc_rqst *, __be32 *);
++=======
+ bool	nlmsvc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ 
+ bool	nlmsvc_encode_testres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_encode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlmsvc_encode_shareres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  
  #endif /* LOCKD_XDR_H */
diff --cc include/linux/lockd/xdr4.h
index 5ae766f26e04,9a6b55da8fd6..000000000000
--- a/include/linux/lockd/xdr4.h
+++ b/include/linux/lockd/xdr4.h
@@@ -22,21 -22,20 +22,28 @@@
  #define	nlm4_fbig		cpu_to_be32(NLM_FBIG)
  #define	nlm4_failed		cpu_to_be32(NLM_FAILED)
  
 -bool	nlm4svc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr);
 -bool	nlm4svc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr);
  
++<<<<<<< HEAD
 +
 +int	nlm4svc_decode_testargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_encode_testres(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_lockargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_cancargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_unlockargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_encode_res(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_res(struct svc_rqst *, __be32 *);
 +int	nlm4svc_encode_void(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_void(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_shareargs(struct svc_rqst *, __be32 *);
 +int	nlm4svc_encode_shareres(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_notify(struct svc_rqst *, __be32 *);
 +int	nlm4svc_decode_reboot(struct svc_rqst *, __be32 *);
++=======
+ bool	nlm4svc_encode_testres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_encode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr);
+ bool	nlm4svc_encode_shareres(struct svc_rqst *rqstp, struct xdr_stream *xdr);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  
  extern const struct rpc_version nlm_version4;
  
diff --cc include/linux/sunrpc/svc.h
index 6940c6b319c7,0ae28ae6caf2..000000000000
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@@ -452,9 -454,11 +452,14 @@@ struct svc_procedure 
  	/* process the request: */
  	__be32			(*pc_func)(struct svc_rqst *);
  	/* XDR decode args: */
 -	bool			(*pc_decode)(struct svc_rqst *rqstp,
 -					     struct xdr_stream *xdr);
 +	int			(*pc_decode)(struct svc_rqst *, __be32 *data);
  	/* XDR encode result: */
++<<<<<<< HEAD
 +	int			(*pc_encode)(struct svc_rqst *, __be32 *data);
++=======
+ 	bool			(*pc_encode)(struct svc_rqst *rqstp,
+ 					     struct xdr_stream *xdr);
++>>>>>>> 130e2054d4a6 (SUNRPC: Change return value type of .pc_encode)
  	/* XDR free result: */
  	void			(*pc_release)(struct svc_rqst *);
  	unsigned int		pc_argsize;	/* argument struct size */
* Unmerged path fs/lockd/xdr.c
* Unmerged path fs/lockd/xdr4.c
* Unmerged path fs/nfs/callback_xdr.c
* Unmerged path fs/nfsd/nfs2acl.c
* Unmerged path fs/nfsd/nfs3acl.c
* Unmerged path fs/nfsd/nfs3xdr.c
* Unmerged path fs/nfsd/nfs4xdr.c
* Unmerged path fs/nfsd/nfsd.h
* Unmerged path fs/nfsd/nfssvc.c
* Unmerged path fs/nfsd/nfsxdr.c
* Unmerged path fs/nfsd/xdr.h
* Unmerged path fs/nfsd/xdr3.h
* Unmerged path fs/nfsd/xdr4.h
* Unmerged path include/linux/lockd/xdr.h
* Unmerged path include/linux/lockd/xdr4.h
* Unmerged path include/linux/sunrpc/svc.h
