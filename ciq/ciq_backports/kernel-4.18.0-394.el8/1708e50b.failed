NFSD: Add helper to decode OPEN's open_claim4 argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 1708e50b0145f393acbec9e319bdf0e33f765d25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/1708e50b.failed

Refactor for clarity.

Note that op_fname is the only instance of an NFSv4 filename stored
in a struct xdr_netobj. Convert it to a u32/char * pair so that the
new nfsd4_decode_filename() helper can be used.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 1708e50b0145f393acbec9e319bdf0e33f765d25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 10163c9081a1,c15d5f8ef191..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -975,23 -1072,55 +975,72 @@@ static __be32 nfsd4_decode_share_deny(s
  	return nfs_ok;
  }
  
 +static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)
 +{
 +	__be32 *p;
 +
 +	READ_BUF(4);
 +	o->len = be32_to_cpup(p++);
 +
 +	if (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)
 +		return nfserr_bad_xdr;
 +
 +	READ_BUF(o->len);
 +	SAVEMEM(o->data, o->len);
 +	return nfs_ok;
 +xdr_error:
 +	return nfserr_bad_xdr;
 +}
 +
+ static __be32
+ nfsd4_decode_open_claim4(struct nfsd4_compoundargs *argp,
+ 			 struct nfsd4_open *open)
+ {
+ 	__be32 status;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &open->op_claim_type) < 0)
+ 		return nfserr_bad_xdr;
+ 	switch (open->op_claim_type) {
+ 	case NFS4_OPEN_CLAIM_NULL:
+ 	case NFS4_OPEN_CLAIM_DELEGATE_PREV:
+ 		status = nfsd4_decode_component4(argp, &open->op_fname,
+ 						 &open->op_fnamelen);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	case NFS4_OPEN_CLAIM_PREVIOUS:
+ 		if (xdr_stream_decode_u32(argp->xdr, &open->op_delegate_type) < 0)
+ 			return nfserr_bad_xdr;
+ 		break;
+ 	case NFS4_OPEN_CLAIM_DELEGATE_CUR:
+ 		status = nfsd4_decode_stateid4(argp, &open->op_delegate_stateid);
+ 		if (status)
+ 			return status;
+ 		status = nfsd4_decode_component4(argp, &open->op_fname,
+ 						 &open->op_fnamelen);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	case NFS4_OPEN_CLAIM_FH:
+ 	case NFS4_OPEN_CLAIM_DELEG_PREV_FH:
+ 		if (argp->minorversion < 1)
+ 			return nfserr_bad_xdr;
+ 		/* void */
+ 		break;
+ 	case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
+ 		if (argp->minorversion < 1)
+ 			return nfserr_bad_xdr;
+ 		status = nfsd4_decode_stateid4(argp, &open->op_delegate_stateid);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	default:
+ 		return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
  static __be32
  nfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)
  {
@@@ -1019,90 -1148,10 +1068,97 @@@
  	status = nfsd4_decode_opaque(argp, &open->op_owner);
  	if (status)
  		goto xdr_error;
++<<<<<<< HEAD
 +	READ_BUF(4);
 +	open->op_create = be32_to_cpup(p++);
 +	switch (open->op_create) {
 +	case NFS4_OPEN_NOCREATE:
 +		break;
 +	case NFS4_OPEN_CREATE:
 +		READ_BUF(4);
 +		open->op_createmode = be32_to_cpup(p++);
 +		switch (open->op_createmode) {
 +		case NFS4_CREATE_UNCHECKED:
 +		case NFS4_CREATE_GUARDED:
 +			status = nfsd4_decode_fattr(argp, open->op_bmval,
 +				&open->op_iattr, &open->op_acl, &open->op_label,
 +				&open->op_umask);
 +			if (status)
 +				goto out;
 +			break;
 +		case NFS4_CREATE_EXCLUSIVE:
 +			READ_BUF(NFS4_VERIFIER_SIZE);
 +			COPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);
 +			break;
 +		case NFS4_CREATE_EXCLUSIVE4_1:
 +			if (argp->minorversion < 1)
 +				goto xdr_error;
 +			READ_BUF(NFS4_VERIFIER_SIZE);
 +			COPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);
 +			status = nfsd4_decode_fattr(argp, open->op_bmval,
 +				&open->op_iattr, &open->op_acl, &open->op_label,
 +				&open->op_umask);
 +			if (status)
 +				goto out;
 +			break;
 +		default:
 +			goto xdr_error;
 +		}
 +		break;
 +	default:
 +		goto xdr_error;
 +	}
 +
 +	/* open_claim */
 +	READ_BUF(4);
 +	open->op_claim_type = be32_to_cpup(p++);
 +	switch (open->op_claim_type) {
 +	case NFS4_OPEN_CLAIM_NULL:
 +	case NFS4_OPEN_CLAIM_DELEGATE_PREV:
 +		READ_BUF(4);
 +		open->op_fname.len = be32_to_cpup(p++);
 +		READ_BUF(open->op_fname.len);
 +		SAVEMEM(open->op_fname.data, open->op_fname.len);
 +		if ((status = check_filename(open->op_fname.data, open->op_fname.len)))
 +			return status;
 +		break;
 +	case NFS4_OPEN_CLAIM_PREVIOUS:
 +		READ_BUF(4);
 +		open->op_delegate_type = be32_to_cpup(p++);
 +		break;
 +	case NFS4_OPEN_CLAIM_DELEGATE_CUR:
 +		status = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);
 +		if (status)
 +			return status;
 +		READ_BUF(4);
 +		open->op_fname.len = be32_to_cpup(p++);
 +		READ_BUF(open->op_fname.len);
 +		SAVEMEM(open->op_fname.data, open->op_fname.len);
 +		if ((status = check_filename(open->op_fname.data, open->op_fname.len)))
 +			return status;
 +		break;
 +	case NFS4_OPEN_CLAIM_FH:
 +	case NFS4_OPEN_CLAIM_DELEG_PREV_FH:
 +		if (argp->minorversion < 1)
 +			goto xdr_error;
 +		/* void */
 +		break;
 +	case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
 +		if (argp->minorversion < 1)
 +			goto xdr_error;
 +		status = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);
 +		if (status)
 +			return status;
 +		break;
 +	default:
 +		goto xdr_error;
 +	}
++=======
+ 	status = nfsd4_decode_openflag4(argp, open);
+ 	if (status)
+ 		return status;
+ 	status = nfsd4_decode_open_claim4(argp, open);
++>>>>>>> 1708e50b0145 (NFSD: Add helper to decode OPEN's open_claim4 argument)
  
  	DECODE_TAIL;
  }
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 4b0ecedb99b1..e6a184302e86 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -255,8 +255,8 @@ do_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, stru
 		 * in NFSv4 as in v3 except EXCLUSIVE4_1.
 		 */
 		current->fs->umask = open->op_umask;
-		status = do_nfsd_create(rqstp, current_fh, open->op_fname.data,
-					open->op_fname.len, &open->op_iattr,
+		status = do_nfsd_create(rqstp, current_fh, open->op_fname,
+					open->op_fnamelen, &open->op_iattr,
 					*resfh, open->op_createmode,
 					(u32 *)open->op_verf.data,
 					&open->op_truncate, &open->op_created);
@@ -281,7 +281,7 @@ do_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, stru
 		 * a chance to an acquire a delegation if appropriate.
 		 */
 		status = nfsd_lookup(rqstp, current_fh,
-				     open->op_fname.data, open->op_fname.len, *resfh);
+				     open->op_fname, open->op_fnamelen, *resfh);
 	if (status)
 		goto out;
 	status = nfsd_check_obj_isreg(*resfh);
@@ -358,7 +358,7 @@ nfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	bool reclaim = false;
 
 	dprintk("NFSD: nfsd4_open filename %.*s op_openowner %p\n",
-		(int)open->op_fname.len, open->op_fname.data,
+		(int)open->op_fnamelen, open->op_fname,
 		open->op_openowner);
 
 	/* This check required by spec. */
* Unmerged path fs/nfsd/nfs4xdr.c
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index dee632ecc00d..300b0ae9a458 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -246,7 +246,8 @@ struct nfsd4_listxattrs {
 
 struct nfsd4_open {
 	u32		op_claim_type;      /* request */
-	struct xdr_netobj op_fname;	    /* request - everything but CLAIM_PREV */
+	u32		op_fnamelen;
+	char *		op_fname;	    /* request - everything but CLAIM_PREV */
 	u32		op_delegate_type;   /* request - CLAIM_PREV only */
 	stateid_t       op_delegate_stateid; /* request - response */
 	u32		op_why_no_deleg;    /* response - DELEG_NONE_EXT only */
