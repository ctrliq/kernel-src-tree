md: properly unwind when failing to add the kobject in md_alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 7ad1069166c0ccdd572d27e01cc7f7f84477df1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/7ad10691.failed

Add proper error handling to delete the gendisk when failing to add
the md kobject and clean up the error unwinding in general.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 7ad1069166c0ccdd572d27e01cc7f7f84477df1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index bfa78d108ea7,c6b15ff0074f..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -5723,20 -5683,13 +5723,26 @@@ static int md_alloc(dev_t dev, char *na
  		mddev->hold_active = UNTIL_STOP;
  
  	error = -ENOMEM;
++<<<<<<< HEAD
 +	mddev->queue = blk_alloc_queue_rh(md_make_request, NUMA_NO_NODE);
 +	if (!mddev->queue)
 +		goto abort;
++=======
+ 	disk = blk_alloc_disk(NUMA_NO_NODE);
+ 	if (!disk)
+ 		goto out_unlock_disks_mutex;
++>>>>>>> 7ad1069166c0 (md: properly unwind when failing to add the kobject in md_alloc)
  
 +	blk_set_stacking_limits(&mddev->queue->limits);
 +
 +	disk = alloc_disk(1 << shift);
 +	if (!disk) {
 +		blk_cleanup_queue(mddev->queue);
 +		mddev->queue = NULL;
 +		goto abort;
 +	}
  	disk->major = MAJOR(mddev->unit);
  	disk->first_minor = unit << shift;
 -	disk->minors = 1 << shift;
  	if (name)
  		strcpy(disk->disk_name, name);
  	else if (partitioned)
@@@ -5752,28 -5707,26 +5758,25 @@@
  	 * remove it now.
  	 */
  	disk->flags |= GENHD_FL_EXT_DEVT;
 -	disk->events |= DISK_EVENT_MEDIA_CHANGE;
  	mddev->gendisk = disk;
  	error = add_disk(disk);
- 	if (error) {
- 		blk_cleanup_disk(disk);
- 		goto abort;
- 	}
+ 	if (error)
+ 		goto out_cleanup_disk;
  
  	error = kobject_add(&mddev->kobj, &disk_to_dev(disk)->kobj, "%s", "md");
- 	if (error) {
- 		/* This isn't possible, but as kobject_init_and_add is marked
- 		 * __must_check, we must do something with the result
- 		 */
- 		pr_debug("md: cannot register %s/md - name in use\n",
- 			 disk->disk_name);
- 		error = 0;
- 	}
-  abort:
- 	if (!error && mddev->kobj.sd) {
- 		kobject_uevent(&mddev->kobj, KOBJ_ADD);
- 		mddev->sysfs_state = sysfs_get_dirent_safe(mddev->kobj.sd, "array_state");
- 		mddev->sysfs_level = sysfs_get_dirent_safe(mddev->kobj.sd, "level");
- 	}
+ 	if (error)
+ 		goto out_del_gendisk;
+ 
+ 	kobject_uevent(&mddev->kobj, KOBJ_ADD);
+ 	mddev->sysfs_state = sysfs_get_dirent_safe(mddev->kobj.sd, "array_state");
+ 	mddev->sysfs_level = sysfs_get_dirent_safe(mddev->kobj.sd, "level");
+ 	goto out_unlock_disks_mutex;
+ 
+ out_del_gendisk:
+ 	del_gendisk(disk);
+ out_cleanup_disk:
+ 	blk_cleanup_disk(disk);
+ out_unlock_disks_mutex:
  	mutex_unlock(&disks_mutex);
  	mddev_put(mddev);
  	return error;
* Unmerged path drivers/md/md.c
