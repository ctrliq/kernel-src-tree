eth: fwnode: change the return type of mac address helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 8017c4d8173cfe086420dc5710d631cabd03ef67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/8017c4d8.failed

fwnode_get_mac_address() and device_get_mac_address()
return a pointer to the buffer that was passed to them
on success or NULL on failure. None of the callers
care about the actual value, only if it's NULL or not.

These semantics differ from of_get_mac_address() which
returns an int so to avoid confusion make the device
helpers return an errno.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8017c4d8173cfe086420dc5710d631cabd03ef67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/ethernet/faraday/ftgmac100.c
#	drivers/net/ethernet/microchip/enc28j60.c
#	drivers/net/ethernet/qualcomm/emac/emac.c
#	drivers/net/ethernet/socionext/netsec.c
#	include/linux/etherdevice.h
#	net/ethernet/eth.c
diff --cc drivers/net/ethernet/broadcom/genet/bcmgenet.c
index 116c5aeea2f7,30c5dcaea802..000000000000
--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
@@@ -3559,10 -4078,21 +3559,25 @@@ static int bcmgenet_probe(struct platfo
  	/* If this is an internal GPHY, power it on now, before UniMAC is
  	 * brought out of reset as absolutely no UniMAC activity is allowed
  	 */
 -	if (device_get_phy_mode(&pdev->dev) == PHY_INTERFACE_MODE_INTERNAL)
 +	if (dn && !of_property_read_string(dn, "phy-mode", &phy_mode_str) &&
 +	    !strcasecmp(phy_mode_str, "internal"))
  		bcmgenet_power_up(priv, GENET_POWER_PASSIVE);
  
++<<<<<<< HEAD
++=======
+ 	if (pd && !IS_ERR_OR_NULL(pd->mac_address))
+ 		eth_hw_addr_set(dev, pd->mac_address);
+ 	else
+ 		if (device_get_mac_address(&pdev->dev, dev->dev_addr, ETH_ALEN))
+ 			if (has_acpi_companion(&pdev->dev))
+ 				bcmgenet_get_hw_addr(priv, dev->dev_addr);
+ 
+ 	if (!is_valid_ether_addr(dev->dev_addr)) {
+ 		dev_warn(&pdev->dev, "using random Ethernet MAC\n");
+ 		eth_hw_addr_random(dev);
+ 	}
+ 
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
  	reset_umac(priv);
  
  	err = bcmgenet_mii_init(dev);
diff --cc drivers/net/ethernet/faraday/ftgmac100.c
index e4431a01ea29,8de9c99a18fb..000000000000
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@@ -192,11 -182,9 +192,15 @@@ static void ftgmac100_initial_mac(struc
  	u8 mac[ETH_ALEN];
  	unsigned int m;
  	unsigned int l;
- 	void *addr;
  
++<<<<<<< HEAD
 +	addr = device_get_mac_address(priv->dev, mac, ETH_ALEN);
 +	if (addr) {
 +		ether_addr_copy(priv->netdev->dev_addr, mac);
++=======
+ 	if (!device_get_mac_address(priv->dev, mac, ETH_ALEN)) {
+ 		eth_hw_addr_set(priv->netdev, mac);
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
  		dev_info(priv->dev, "Read MAC address %pM from device tree\n",
  			 mac);
  		return;
diff --cc drivers/net/ethernet/microchip/enc28j60.c
index a0923585e1c4,fa62311d326a..000000000000
--- a/drivers/net/ethernet/microchip/enc28j60.c
+++ b/drivers/net/ethernet/microchip/enc28j60.c
@@@ -1586,10 -1572,10 +1586,16 @@@ static int enc28j60_probe(struct spi_de
  		goto error_irq;
  	}
  
++<<<<<<< HEAD
 +	ret = of_get_mac_address(spi->dev.of_node, dev->dev_addr);
 +	if (ret)
++=======
+ 	if (!device_get_mac_address(&spi->dev, macaddr, sizeof(macaddr)))
+ 		eth_hw_addr_set(dev, macaddr);
+ 	else
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
  		eth_hw_addr_random(dev);
 +
  	enc28j60_set_hw_macaddr(dev);
  
  	/* Board setup must set the relevant edge trigger type;
diff --cc drivers/net/ethernet/qualcomm/emac/emac.c
index 36f4564d0b72,2e913508fbeb..000000000000
--- a/drivers/net/ethernet/qualcomm/emac/emac.c
+++ b/drivers/net/ethernet/qualcomm/emac/emac.c
@@@ -557,8 -549,8 +557,13 @@@ static int emac_probe_resources(struct 
  	int ret = 0;
  
  	/* get mac address */
++<<<<<<< HEAD
 +	if (device_get_mac_address(&pdev->dev, maddr, ETH_ALEN))
 +		ether_addr_copy(netdev->dev_addr, maddr);
++=======
+ 	if (!device_get_mac_address(&pdev->dev, maddr, ETH_ALEN))
+ 		eth_hw_addr_set(netdev, maddr);
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
  	else
  		eth_hw_addr_random(netdev);
  
diff --cc drivers/net/ethernet/socionext/netsec.c
index 63c23f878c12,f8dd7fa5f632..000000000000
--- a/drivers/net/ethernet/socionext/netsec.c
+++ b/drivers/net/ethernet/socionext/netsec.c
@@@ -1609,12 -2034,12 +1609,18 @@@ static int netsec_probe(struct platform
  		goto free_ndev;
  	}
  
++<<<<<<< HEAD
 +	mac = device_get_mac_address(&pdev->dev, macbuf, sizeof(macbuf));
 +	if (mac)
 +		ether_addr_copy(ndev->dev_addr, mac);
++=======
+ 	ret = device_get_mac_address(&pdev->dev, macbuf, sizeof(macbuf));
+ 	if (!ret)
+ 		eth_hw_addr_set(ndev, macbuf);
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
  
  	if (priv->eeprom_base &&
- 	    (!mac || !is_valid_ether_addr(ndev->dev_addr))) {
+ 	    (ret || !is_valid_ether_addr(ndev->dev_addr))) {
  		void __iomem *macp = priv->eeprom_base +
  					NETSEC_EEPROM_MAC_ADDRESS;
  
diff --cc include/linux/etherdevice.h
index d76c6b361d63,8299f1cd9175..000000000000
--- a/include/linux/etherdevice.h
+++ b/include/linux/etherdevice.h
@@@ -31,9 -26,15 +31,17 @@@
  
  #ifdef __KERNEL__
  struct device;
 -struct fwnode_handle;
 -
  int eth_platform_get_mac_address(struct device *dev, u8 *mac_addr);
  unsigned char *arch_get_platform_mac_address(void);
++<<<<<<< HEAD
 +u32 eth_get_headlen(const struct net_device *dev, void *data, unsigned int len);
++=======
+ int nvmem_get_mac_address(struct device *dev, void *addrbuf);
+ int device_get_mac_address(struct device *dev, char *addr, int alen);
+ int fwnode_get_mac_address(struct fwnode_handle *fwnode, char *addr, int alen);
+ 
+ u32 eth_get_headlen(const struct net_device *dev, const void *data, u32 len);
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
  __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev);
  extern const struct header_ops eth_header_ops;
  
diff --cc net/ethernet/eth.c
index 7856f07680f6,70692f5b514c..000000000000
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@@ -558,3 -522,103 +558,106 @@@ int eth_platform_get_mac_address(struc
  	return 0;
  }
  EXPORT_SYMBOL(eth_platform_get_mac_address);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * nvmem_get_mac_address - Obtain the MAC address from an nvmem cell named
+  * 'mac-address' associated with given device.
+  *
+  * @dev:	Device with which the mac-address cell is associated.
+  * @addrbuf:	Buffer to which the MAC address will be copied on success.
+  *
+  * Returns 0 on success or a negative error number on failure.
+  */
+ int nvmem_get_mac_address(struct device *dev, void *addrbuf)
+ {
+ 	struct nvmem_cell *cell;
+ 	const void *mac;
+ 	size_t len;
+ 
+ 	cell = nvmem_cell_get(dev, "mac-address");
+ 	if (IS_ERR(cell))
+ 		return PTR_ERR(cell);
+ 
+ 	mac = nvmem_cell_read(cell, &len);
+ 	nvmem_cell_put(cell);
+ 
+ 	if (IS_ERR(mac))
+ 		return PTR_ERR(mac);
+ 
+ 	if (len != ETH_ALEN || !is_valid_ether_addr(mac)) {
+ 		kfree(mac);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ether_addr_copy(addrbuf, mac);
+ 	kfree(mac);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(nvmem_get_mac_address);
+ 
+ static int fwnode_get_mac_addr(struct fwnode_handle *fwnode,
+ 			       const char *name, char *addr, int alen)
+ {
+ 	int ret;
+ 
+ 	if (alen != ETH_ALEN)
+ 		return -EINVAL;
+ 
+ 	ret = fwnode_property_read_u8_array(fwnode, name, addr, alen);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!is_valid_ether_addr(addr))
+ 		return -EINVAL;
+ 	return 0;
+ }
+ 
+ /**
+  * fwnode_get_mac_address - Get the MAC from the firmware node
+  * @fwnode:	Pointer to the firmware node
+  * @addr:	Address of buffer to store the MAC in
+  * @alen:	Length of the buffer pointed to by addr, should be ETH_ALEN
+  *
+  * Search the firmware node for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+  * address. If that isn't set, then 'local-mac-address' is checked next,
+  * because that is the default address.  If that isn't set, then the obsolete
+  * 'address' is checked, just in case we're using an old device tree.
+  *
+  * Note that the 'address' property is supposed to contain a virtual address of
+  * the register set, but some DTS files have redefined that property to be the
+  * MAC address.
+  *
+  * All-zero MAC addresses are rejected, because those could be properties that
+  * exist in the firmware tables, but were not updated by the firmware.  For
+  * example, the DTS could define 'mac-address' and 'local-mac-address', with
+  * zero MAC addresses.  Some older U-Boots only initialized 'local-mac-address'.
+  * In this case, the real MAC is in 'local-mac-address', and 'mac-address'
+  * exists but is all zeros.
+  */
+ int fwnode_get_mac_address(struct fwnode_handle *fwnode, char *addr, int alen)
+ {
+ 	if (!fwnode_get_mac_addr(fwnode, "mac-address", addr, alen) ||
+ 	    !fwnode_get_mac_addr(fwnode, "local-mac-address", addr, alen) ||
+ 	    !fwnode_get_mac_addr(fwnode, "address", addr, alen))
+ 		return 0;
+ 
+ 	return -ENOENT;
+ }
+ EXPORT_SYMBOL(fwnode_get_mac_address);
+ 
+ /**
+  * device_get_mac_address - Get the MAC for a given device
+  * @dev:	Pointer to the device
+  * @addr:	Address of buffer to store the MAC in
+  * @alen:	Length of the buffer pointed to by addr, should be ETH_ALEN
+  */
+ int device_get_mac_address(struct device *dev, char *addr, int alen)
+ {
+ 	return fwnode_get_mac_address(dev_fwnode(dev), addr, alen);
+ }
+ EXPORT_SYMBOL(device_get_mac_address);
++>>>>>>> 8017c4d8173c (eth: fwnode: change the return type of mac address helpers)
diff --git a/drivers/net/ethernet/apm/xgene-v2/main.c b/drivers/net/ethernet/apm/xgene-v2/main.c
index 44f8d4e82751..ff6db0dd34a1 100644
--- a/drivers/net/ethernet/apm/xgene-v2/main.c
+++ b/drivers/net/ethernet/apm/xgene-v2/main.c
@@ -48,7 +48,7 @@ static int xge_get_resources(struct xge_pdata *pdata)
 		return -ENOMEM;
 	}
 
-	if (!device_get_mac_address(dev, ndev->dev_addr, ETH_ALEN))
+	if (device_get_mac_address(dev, ndev->dev_addr, ETH_ALEN))
 		eth_hw_addr_random(ndev);
 
 	memcpy(ndev->perm_addr, ndev->dev_addr, ndev->addr_len);
diff --git a/drivers/net/ethernet/apm/xgene/xgene_enet_main.c b/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
index c98730df10e8..0fd034238aa7 100644
--- a/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
@@ -1748,7 +1748,7 @@ static int xgene_enet_get_resources(struct xgene_enet_pdata *pdata)
 		xgene_get_port_id_acpi(dev, pdata);
 #endif
 
-	if (!device_get_mac_address(dev, ndev->dev_addr, ETH_ALEN))
+	if (device_get_mac_address(dev, ndev->dev_addr, ETH_ALEN))
 		eth_hw_addr_random(ndev);
 
 	memcpy(ndev->perm_addr, ndev->dev_addr, ndev->addr_len);
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
index 4f48cbdcf77f..bb3068a94ed5 100644
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
@@ -1384,10 +1384,10 @@ static int acpi_get_mac_address(struct device *dev, struct acpi_device *adev,
 				u8 *dst)
 {
 	u8 mac[ETH_ALEN];
-	u8 *addr;
+	int ret;
 
-	addr = fwnode_get_mac_address(acpi_fwnode_handle(adev), mac, ETH_ALEN);
-	if (!addr) {
+	ret = fwnode_get_mac_address(acpi_fwnode_handle(adev), mac, ETH_ALEN);
+	if (ret) {
 		dev_err(dev, "MAC address invalid: %pM\n", mac);
 		return -EINVAL;
 	}
* Unmerged path drivers/net/ethernet/faraday/ftgmac100.c
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_enet.c b/drivers/net/ethernet/hisilicon/hns/hns_enet.c
index 735a7886d902..91a8187a1636 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_enet.c
@@ -1233,7 +1233,7 @@ static void hns_init_mac_addr(struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 
-	if (!device_get_mac_address(priv->dev, ndev->dev_addr, ETH_ALEN)) {
+	if (device_get_mac_address(priv->dev, ndev->dev_addr, ETH_ALEN)) {
 		eth_hw_addr_random(ndev);
 		dev_warn(priv->dev, "No valid mac, use random mac %pM",
 			 ndev->dev_addr);
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index 9638dce58ba2..58e76a472d85 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@ -4140,7 +4140,7 @@ static void mvpp2_port_copy_mac_addr(struct net_device *dev, struct mvpp2 *priv,
 	char hw_mac_addr[ETH_ALEN] = {0};
 	char fw_mac_addr[ETH_ALEN];
 
-	if (fwnode_get_mac_address(fwnode, fw_mac_addr, ETH_ALEN)) {
+	if (!fwnode_get_mac_address(fwnode, fw_mac_addr, ETH_ALEN)) {
 		*mac_from = "firmware node";
 		ether_addr_copy(dev->dev_addr, fw_mac_addr);
 		return;
* Unmerged path drivers/net/ethernet/microchip/enc28j60.c
* Unmerged path drivers/net/ethernet/qualcomm/emac/emac.c
* Unmerged path drivers/net/ethernet/socionext/netsec.c
* Unmerged path include/linux/etherdevice.h
* Unmerged path net/ethernet/eth.c
