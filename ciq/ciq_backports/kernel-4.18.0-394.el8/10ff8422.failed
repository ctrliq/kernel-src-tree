NFSD: Add a helper to decode nfs_impl_id4

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 10ff84228197f47401833495ba19a50131323b4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/10ff8422.failed

Refactor for clarity.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 10ff84228197f47401833495ba19a50131323b4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index a7c80f4dce78,867896060878..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -1377,108 -1558,60 +1377,155 @@@ nfsd4_decode_release_lockowner(struct n
  	return nfs_ok;
  }
  
 +static __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)
 +{
 +	if (xdr_stream_decode_u32(argp->xdr, &bc->bc_cb_program) < 0)
 +		return nfserr_bad_xdr;
 +	return nfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);
 +}
 +
+ static __be32
+ nfsd4_decode_nfs_impl_id4(struct nfsd4_compoundargs *argp,
+ 			  struct nfsd4_exchange_id *exid)
+ {
+ 	__be32 status;
+ 	u32 count;
+ 
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 	switch (count) {
+ 	case 0:
+ 		break;
+ 	case 1:
+ 		/* Note that RFC 8881 places no length limit on
+ 		 * nii_domain, but this implementation permits no
+ 		 * more than NFS4_OPAQUE_LIMIT bytes */
+ 		status = nfsd4_decode_opaque(argp, &exid->nii_domain);
+ 		if (status)
+ 			return status;
+ 		/* Note that RFC 8881 places no length limit on
+ 		 * nii_name, but this implementation permits no
+ 		 * more than NFS4_OPAQUE_LIMIT bytes */
+ 		status = nfsd4_decode_opaque(argp, &exid->nii_name);
+ 		if (status)
+ 			return status;
+ 		status = nfsd4_decode_nfstime4(argp, &exid->nii_time);
+ 		if (status)
+ 			return status;
+ 		break;
+ 	default:
+ 		return nfserr_bad_xdr;
+ 	}
+ 
+ 	return nfs_ok;
+ }
+ 
  static __be32
  nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
  			 struct nfsd4_exchange_id *exid)
  {
++<<<<<<< HEAD
 +	int dummy, tmp;
 +	DECODE_HEAD;
++=======
+ 	__be32 status;
++>>>>>>> 10ff84228197 (NFSD: Add a helper to decode nfs_impl_id4)
 +
 +	READ_BUF(NFS4_VERIFIER_SIZE);
 +	COPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);
  
 -	status = nfsd4_decode_verifier4(argp, &exid->verifier);
 -	if (status)
 -		return status;
  	status = nfsd4_decode_opaque(argp, &exid->clname);
  	if (status)
 -		return status;
 -	if (xdr_stream_decode_u32(argp->xdr, &exid->flags) < 0)
  		return nfserr_bad_xdr;
++<<<<<<< HEAD
 +
 +	READ_BUF(4);
 +	exid->flags = be32_to_cpup(p++);
 +
 +	/* Ignore state_protect4_a */
 +	READ_BUF(4);
 +	exid->spa_how = be32_to_cpup(p++);
 +	switch (exid->spa_how) {
 +	case SP4_NONE:
 +		break;
 +	case SP4_MACH_CRED:
 +		/* spo_must_enforce */
 +		status = nfsd4_decode_bitmap(argp,
 +					exid->spo_must_enforce);
 +		if (status)
 +			goto out;
 +		/* spo_must_allow */
 +		status = nfsd4_decode_bitmap(argp, exid->spo_must_allow);
 +		if (status)
 +			goto out;
 +		break;
 +	case SP4_SSV:
 +		/* ssp_ops */
 +		READ_BUF(4);
 +		dummy = be32_to_cpup(p++);
 +		READ_BUF(dummy * 4);
 +		p += dummy;
 +
 +		READ_BUF(4);
 +		dummy = be32_to_cpup(p++);
 +		READ_BUF(dummy * 4);
 +		p += dummy;
 +
 +		/* ssp_hash_algs<> */
 +		READ_BUF(4);
 +		tmp = be32_to_cpup(p++);
 +		while (tmp--) {
 +			READ_BUF(4);
 +			dummy = be32_to_cpup(p++);
 +			READ_BUF(dummy);
 +			p += XDR_QUADLEN(dummy);
 +		}
 +
 +		/* ssp_encr_algs<> */
 +		READ_BUF(4);
 +		tmp = be32_to_cpup(p++);
 +		while (tmp--) {
 +			READ_BUF(4);
 +			dummy = be32_to_cpup(p++);
 +			READ_BUF(dummy);
 +			p += XDR_QUADLEN(dummy);
 +		}
 +
 +		/* ignore ssp_window and ssp_num_gss_handles: */
 +		READ_BUF(8);
 +		break;
 +	default:
 +		goto xdr_error;
 +	}
 +
 +	READ_BUF(4);    /* nfs_impl_id4 array length */
 +	dummy = be32_to_cpup(p++);
 +
 +	if (dummy > 1)
 +		goto xdr_error;
 +
 +	if (dummy == 1) {
 +		status = nfsd4_decode_opaque(argp, &exid->nii_domain);
 +		if (status)
 +			goto xdr_error;
 +
 +		/* nii_name */
 +		status = nfsd4_decode_opaque(argp, &exid->nii_name);
 +		if (status)
 +			goto xdr_error;
 +
 +		/* nii_date */
 +		status = nfsd4_decode_time(argp, &exid->nii_time);
 +		if (status)
 +			goto xdr_error;
 +	}
 +	DECODE_TAIL;
++=======
+ 	status = nfsd4_decode_state_protect4_a(argp, exid);
+ 	if (status)
+ 		return status;
+ 	return nfsd4_decode_nfs_impl_id4(argp, exid);
++>>>>>>> 10ff84228197 (NFSD: Add a helper to decode nfs_impl_id4)
  }
  
  static __be32
* Unmerged path fs/nfsd/nfs4xdr.c
