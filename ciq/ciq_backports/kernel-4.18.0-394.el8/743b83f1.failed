netfilter: nft_socket: only do sk lookups when indev is available

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Florian Westphal <fw@strlen.de>
commit 743b83f15d4069ea57c3e40996bf4a1077e0cdc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/743b83f1.failed

Check if the incoming interface is available and NFT_BREAK
in case neither skb->sk nor input device are set.

Because nf_sk_lookup_slow*() assume packet headers are in the
'in' direction, use in postrouting is not going to yield a meaningful
result.  Same is true for the forward chain, so restrict the use
to prerouting, input and output.

Use in output work if a socket is already attached to the skb.

Fixes: 554ced0a6e29 ("netfilter: nf_tables: add support for native socket matching")
Reported-and-tested-by: Topi Miettinen <toiwoton@gmail.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 743b83f15d4069ea57c3e40996bf4a1077e0cdc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_socket.c
diff --cc net/netfilter/nft_socket.c
index 9649ed60b72b,05ae5a338b6f..000000000000
--- a/net/netfilter/nft_socket.c
+++ b/net/netfilter/nft_socket.c
@@@ -14,6 -16,70 +14,73 @@@ struct nft_socket 
  	};
  };
  
++<<<<<<< HEAD
++=======
+ static void nft_socket_wildcard(const struct nft_pktinfo *pkt,
+ 				struct nft_regs *regs, struct sock *sk,
+ 				u32 *dest)
+ {
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		nft_reg_store8(dest, inet_sk(sk)->inet_rcv_saddr == 0);
+ 		break;
+ #if IS_ENABLED(CONFIG_NF_TABLES_IPV6)
+ 	case NFPROTO_IPV6:
+ 		nft_reg_store8(dest, ipv6_addr_any(&sk->sk_v6_rcv_saddr));
+ 		break;
+ #endif
+ 	default:
+ 		regs->verdict.code = NFT_BREAK;
+ 		return;
+ 	}
+ }
+ 
+ #ifdef CONFIG_SOCK_CGROUP_DATA
+ static noinline bool
+ nft_sock_get_eval_cgroupv2(u32 *dest, struct sock *sk, const struct nft_pktinfo *pkt, u32 level)
+ {
+ 	struct cgroup *cgrp;
+ 
+ 	if (!sk_fullsock(sk))
+ 		return false;
+ 
+ 	cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);
+ 	if (level > cgrp->level)
+ 		return false;
+ 
+ 	memcpy(dest, &cgrp->ancestor_ids[level], sizeof(u64));
+ 
+ 	return true;
+ }
+ #endif
+ 
+ static struct sock *nft_socket_do_lookup(const struct nft_pktinfo *pkt)
+ {
+ 	const struct net_device *indev = nft_in(pkt);
+ 	const struct sk_buff *skb = pkt->skb;
+ 	struct sock *sk = NULL;
+ 
+ 	if (!indev)
+ 		return NULL;
+ 
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		sk = nf_sk_lookup_slow_v4(nft_net(pkt), skb, indev);
+ 		break;
+ #if IS_ENABLED(CONFIG_NF_TABLES_IPV6)
+ 	case NFPROTO_IPV6:
+ 		sk = nf_sk_lookup_slow_v6(nft_net(pkt), skb, indev);
+ 		break;
+ #endif
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		break;
+ 	}
+ 
+ 	return sk;
+ }
+ 
++>>>>>>> 743b83f15d40 (netfilter: nft_socket: only do sk lookups when indev is available)
  static void nft_socket_eval(const struct nft_expr *expr,
  			    struct nft_regs *regs,
  			    const struct nft_pktinfo *pkt)
@@@ -27,20 -93,7 +94,24 @@@
  		sk = NULL;
  
  	if (!sk)
++<<<<<<< HEAD
 +		switch(nft_pf(pkt)) {
 +		case NFPROTO_IPV4:
 +			sk = nf_sk_lookup_slow_v4(nft_net(pkt), skb, nft_in(pkt));
 +			break;
 +#if IS_ENABLED(CONFIG_NF_SOCKET_IPV6)
 +		case NFPROTO_IPV6:
 +			sk = nf_sk_lookup_slow_v6(nft_net(pkt), skb, nft_in(pkt));
 +			break;
 +#endif
 +		default:
 +			WARN_ON_ONCE(1);
 +			regs->verdict.code = NFT_BREAK;
 +			return;
 +		}
++=======
+ 		sk = nft_socket_do_lookup(pkt);
++>>>>>>> 743b83f15d40 (netfilter: nft_socket: only do sk lookups when indev is available)
  
  	if (!sk) {
  		regs->verdict.code = NFT_BREAK;
@@@ -112,6 -209,44 +183,44 @@@ static int nft_socket_dump(struct sk_bu
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool nft_socket_reduce(struct nft_regs_track *track,
+ 			      const struct nft_expr *expr)
+ {
+ 	const struct nft_socket *priv = nft_expr_priv(expr);
+ 	const struct nft_socket *socket;
+ 
+ 	if (!nft_reg_track_cmp(track, expr, priv->dreg)) {
+ 		nft_reg_track_update(track, expr, priv->dreg, priv->len);
+ 		return false;
+ 	}
+ 
+ 	socket = nft_expr_priv(track->regs[priv->dreg].selector);
+ 	if (priv->key != socket->key ||
+ 	    priv->dreg != socket->dreg ||
+ 	    priv->level != socket->level) {
+ 		nft_reg_track_update(track, expr, priv->dreg, priv->len);
+ 		return false;
+ 	}
+ 
+ 	if (!track->regs[priv->dreg].bitwise)
+ 		return true;
+ 
+ 	return nft_expr_reduce_bitwise(track, expr);
+ }
+ 
+ static int nft_socket_validate(const struct nft_ctx *ctx,
+ 			       const struct nft_expr *expr,
+ 			       const struct nft_data **data)
+ {
+ 	return nft_chain_validate_hooks(ctx->chain,
+ 					(1 << NF_INET_PRE_ROUTING) |
+ 					(1 << NF_INET_LOCAL_IN) |
+ 					(1 << NF_INET_LOCAL_OUT));
+ }
+ 
++>>>>>>> 743b83f15d40 (netfilter: nft_socket: only do sk lookups when indev is available)
  static struct nft_expr_type nft_socket_type;
  static const struct nft_expr_ops nft_socket_ops = {
  	.type		= &nft_socket_type,
@@@ -119,6 -254,8 +228,11 @@@
  	.eval		= nft_socket_eval,
  	.init		= nft_socket_init,
  	.dump		= nft_socket_dump,
++<<<<<<< HEAD
++=======
+ 	.validate	= nft_socket_validate,
+ 	.reduce		= nft_socket_reduce,
++>>>>>>> 743b83f15d40 (netfilter: nft_socket: only do sk lookups when indev is available)
  };
  
  static struct nft_expr_type nft_socket_type __read_mostly = {
* Unmerged path net/netfilter/nft_socket.c
