devlink: Annotate devlink API calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit b88f7b1203bf481af58291c28957aaab09503f43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/b88f7b12.failed

Initial annotation patch to separate calls that needs to be executed
before or after devlink_register().

	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit b88f7b1203bf481af58291c28957aaab09503f43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index 3e56c892bf42,276e1e421eb4..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -96,8 -149,25 +96,24 @@@ static const struct nla_policy devlink_
  				 DEVLINK_PORT_FN_STATE_ACTIVE),
  };
  
 -static DEFINE_XARRAY_FLAGS(devlinks, XA_FLAGS_ALLOC);
 -#define DEVLINK_REGISTERED XA_MARK_1
 +static LIST_HEAD(devlink_list);
  
+ /* devlink instances are open to the access from the user space after
+  * devlink_register() call. Such logical barrier allows us to have certain
+  * expectations related to locking.
+  *
+  * Before *_register() - we are in initialization stage and no parallel
+  * access possible to the devlink instance. All drivers perform that phase
+  * by implicitly holding device_lock.
+  *
+  * After *_register() - users and driver can access devlink instance at
+  * the same time.
+  */
+ #define ASSERT_DEVLINK_REGISTERED(d)                                           \
+ 	WARN_ON_ONCE(!xa_get_mark(&devlinks, (d)->index, DEVLINK_REGISTERED))
+ #define ASSERT_DEVLINK_NOT_REGISTERED(d)                                       \
+ 	WARN_ON_ONCE(xa_get_mark(&devlinks, (d)->index, DEVLINK_REGISTERED))
+ 
  /* devlink_mutex
   *
   * An overall lock guarding every operation coming from userspace.
@@@ -8950,17 -9126,17 +8966,24 @@@ EXPORT_SYMBOL_GPL(devlink_alloc_ns)
   *	devlink_register - Register devlink instance
   *
   *	@devlink: devlink
 + *	@dev: parent device
   */
 -void devlink_register(struct devlink *devlink)
 +int devlink_register(struct devlink *devlink, struct device *dev)
  {
++<<<<<<< HEAD
 +	WARN_ON(devlink->dev);
 +	devlink->dev = dev;
++=======
+ 	ASSERT_DEVLINK_NOT_REGISTERED(devlink);
+ 	/* Make sure that we are in .probe() routine */
+ 	device_lock_assert(devlink->dev);
+ 
++>>>>>>> b88f7b1203bf (devlink: Annotate devlink API calls)
  	mutex_lock(&devlink_mutex);
 -	xa_set_mark(&devlinks, devlink->index, DEVLINK_REGISTERED);
 -	devlink_notify_register(devlink);
 +	list_add_tail(&devlink->list, &devlink_list);
 +	devlink_notify(devlink, DEVLINK_CMD_NEW);
  	mutex_unlock(&devlink_mutex);
 +	return 0;
  }
  EXPORT_SYMBOL_GPL(devlink_register);
  
* Unmerged path net/core/devlink.c
