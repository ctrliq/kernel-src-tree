netfilter: nft_payload: don't allow th access for fragments

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Florian Westphal <fw@strlen.de>
commit a9e8503def0fd4ed89ade1f61c315f904581d439
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/a9e8503d.failed

Loads relative to ->thoff naturally expect that this points to the
transport header, but this is only true if pkt->fragoff == 0.

This has little effect for rulesets with connection tracking/nat because
these enable ip defra. For other rulesets this prevents false matches.

Fixes: 96518518cc41 ("netfilter: add nftables")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a9e8503def0fd4ed89ade1f61c315f904581d439)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_payload.c
diff --cc net/netfilter/nft_exthdr.c
index e6c8c81a3f6c,9e927ab4df15..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -70,10 -167,10 +70,14 @@@ nft_tcp_header_pointer(const struct nft
  {
  	struct tcphdr *tcph;
  
++<<<<<<< HEAD
 +	if (!pkt->tprot_set || pkt->tprot != IPPROTO_TCP)
++=======
+ 	if (pkt->tprot != IPPROTO_TCP || pkt->fragoff)
++>>>>>>> a9e8503def0f (netfilter: nft_payload: don't allow th access for fragments)
  		return NULL;
  
 -	tcph = skb_header_pointer(pkt->skb, nft_thoff(pkt), sizeof(*tcph), buffer);
 +	tcph = skb_header_pointer(pkt->skb, pkt->xt.thoff, sizeof(*tcph), buffer);
  	if (!tcph)
  		return NULL;
  
diff --cc net/netfilter/nft_payload.c
index 15b7d8b4b79e,5cc06aef4345..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -64,6 -79,45 +64,48 @@@ nft_payload_copy_vlan(u32 *d, const str
  	return skb_copy_bits(skb, offset + mac_off, dst_u8, len) == 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __nft_payload_inner_offset(struct nft_pktinfo *pkt)
+ {
+ 	unsigned int thoff = nft_thoff(pkt);
+ 
+ 	if (!(pkt->flags & NFT_PKTINFO_L4PROTO) || pkt->fragoff)
+ 		return -1;
+ 
+ 	switch (pkt->tprot) {
+ 	case IPPROTO_UDP:
+ 		pkt->inneroff = thoff + sizeof(struct udphdr);
+ 		break;
+ 	case IPPROTO_TCP: {
+ 		struct tcphdr *th, _tcph;
+ 
+ 		th = skb_header_pointer(pkt->skb, thoff, sizeof(_tcph), &_tcph);
+ 		if (!th)
+ 			return -1;
+ 
+ 		pkt->inneroff = thoff + __tcp_hdrlen(th);
+ 		}
+ 		break;
+ 	default:
+ 		return -1;
+ 	}
+ 
+ 	pkt->flags |= NFT_PKTINFO_INNER;
+ 
+ 	return 0;
+ }
+ 
+ static int nft_payload_inner_offset(const struct nft_pktinfo *pkt)
+ {
+ 	if (!(pkt->flags & NFT_PKTINFO_INNER) &&
+ 	    __nft_payload_inner_offset((struct nft_pktinfo *)pkt) < 0)
+ 		return -1;
+ 
+ 	return pkt->inneroff;
+ }
+ 
++>>>>>>> a9e8503def0f (netfilter: nft_payload: don't allow th access for fragments)
  void nft_payload_eval(const struct nft_expr *expr,
  		      struct nft_regs *regs,
  		      const struct nft_pktinfo *pkt)
@@@ -93,12 -147,18 +135,22 @@@
  		offset = skb_network_offset(skb);
  		break;
  	case NFT_PAYLOAD_TRANSPORT_HEADER:
++<<<<<<< HEAD
 +		if (!pkt->tprot_set)
++=======
+ 		if (!(pkt->flags & NFT_PKTINFO_L4PROTO) || pkt->fragoff)
+ 			goto err;
+ 		offset = nft_thoff(pkt);
+ 		break;
+ 	case NFT_PAYLOAD_INNER_HEADER:
+ 		offset = nft_payload_inner_offset(pkt);
+ 		if (offset < 0)
++>>>>>>> a9e8503def0f (netfilter: nft_payload: don't allow th access for fragments)
  			goto err;
 +		offset = pkt->xt.thoff;
  		break;
  	default:
 -		WARN_ON_ONCE(1);
 -		goto err;
 +		BUG();
  	}
  	offset += priv->offset;
  
@@@ -598,12 -688,18 +650,22 @@@ static void nft_payload_set_eval(const 
  		offset = skb_network_offset(skb);
  		break;
  	case NFT_PAYLOAD_TRANSPORT_HEADER:
++<<<<<<< HEAD
 +		if (!pkt->tprot_set)
++=======
+ 		if (!(pkt->flags & NFT_PKTINFO_L4PROTO) || pkt->fragoff)
+ 			goto err;
+ 		offset = nft_thoff(pkt);
+ 		break;
+ 	case NFT_PAYLOAD_INNER_HEADER:
+ 		offset = nft_payload_inner_offset(pkt);
+ 		if (offset < 0)
++>>>>>>> a9e8503def0f (netfilter: nft_payload: don't allow th access for fragments)
  			goto err;
 +		offset = pkt->xt.thoff;
  		break;
  	default:
 -		WARN_ON_ONCE(1);
 -		goto err;
 +		BUG();
  	}
  
  	csum_offset = offset + priv->csum_offset;
@@@ -631,7 -728,8 +693,12 @@@
  	if (priv->csum_type == NFT_PAYLOAD_CSUM_SCTP &&
  	    pkt->tprot == IPPROTO_SCTP &&
  	    skb->ip_summed != CHECKSUM_PARTIAL) {
++<<<<<<< HEAD
 +		if (nft_payload_csum_sctp(skb, pkt->xt.thoff))
++=======
+ 		if (pkt->fragoff == 0 &&
+ 		    nft_payload_csum_sctp(skb, nft_thoff(pkt)))
++>>>>>>> a9e8503def0f (netfilter: nft_payload: don't allow th access for fragments)
  			goto err;
  	}
  
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_payload.c
