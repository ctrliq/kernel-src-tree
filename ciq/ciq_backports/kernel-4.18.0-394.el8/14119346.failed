NFSD: Remove unused NFSv3 directory entry encoders

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 1411934627f9fe31a36ac8c43179ce9b63edce5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/14119346.failed

Clean up.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 1411934627f9fe31a36ac8c43179ce9b63edce5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3xdr.c
#	fs/nfsd/xdr3.h
diff --cc fs/nfsd/nfs3xdr.c
index 3fa16aaa5ee2,646bbfc5b779..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -145,16 -148,32 +145,6 @@@ svcxdr_encode_post_op_fh3(struct xdr_st
  	return true;
  }
  
- static __be32 *
- encode_fh(__be32 *p, struct svc_fh *fhp)
 -static bool
 -svcxdr_encode_cookieverf3(struct xdr_stream *xdr, const __be32 *verf)
--{
- 	unsigned int size = fhp->fh_handle.fh_size;
- 	*p++ = htonl(size);
- 	if (size) p[XDR_QUADLEN(size)-1]=0;
- 	memcpy(p, &fhp->fh_handle.fh_base, size);
- 	return p + XDR_QUADLEN(size);
 -	__be32 *p;
 -
 -	p = xdr_reserve_space(xdr, NFS3_COOKIEVERFSIZE);
 -	if (!p)
 -		return false;
 -	memcpy(p, verf, NFS3_COOKIEVERFSIZE);
 -
 -	return true;
 -}
 -
 -static bool
 -svcxdr_encode_writeverf3(struct xdr_stream *xdr, const __be32 *verf)
 -{
 -	__be32 *p;
 -
 -	p = xdr_reserve_space(xdr, NFS3_WRITEVERFSIZE);
 -	if (!p)
 -		return false;
 -	memcpy(p, verf, NFS3_WRITEVERFSIZE);
 -
 -	return true;
--}
--
  static bool
  svcxdr_decode_filename3(struct xdr_stream *xdr, char **name, unsigned int *len)
  {
@@@ -1110,43 -1127,33 +1100,29 @@@ nfs3svc_encode_linkres(struct svc_rqst 
  int
  nfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p)
  {
 -	struct xdr_stream *xdr = &rqstp->rq_res_stream;
  	struct nfsd3_readdirres *resp = rqstp->rq_resp;
 -	struct xdr_buf *dirlist = &resp->dirlist;
 -
 -	if (!svcxdr_encode_nfsstat3(xdr, resp->status))
 -		return 0;
 -	switch (resp->status) {
 -	case nfs_ok:
 -		if (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))
 -			return 0;
 -		if (!svcxdr_encode_cookieverf3(xdr, resp->verf))
 -			return 0;
 -		xdr_write_pages(xdr, dirlist->pages, 0, dirlist->len);
 -		/* no more entries */
 -		if (xdr_stream_encode_item_absent(xdr) < 0)
 -			return 0;
 -		if (xdr_stream_encode_bool(xdr, resp->common.err == nfserr_eof) < 0)
 -			return 0;
 -		break;
 -	default:
 -		if (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))
 -			return 0;
 -	}
  
 -	return 1;
 +	*p++ = resp->status;
 +	p = encode_post_op_attr(rqstp, p, &resp->fh);
 +
 +	if (resp->status == 0) {
 +		/* stupid readdir cookie */
 +		memcpy(p, resp->verf, 8); p += 2;
 +		xdr_ressize_check(rqstp, p);
 +		if (rqstp->rq_res.head[0].iov_len + (2<<2) > PAGE_SIZE)
 +			return 1; /*No room for trailer */
 +		rqstp->rq_res.page_len = (resp->count) << 2;
 +
 +		/* add the 'tail' to the end of the 'head' page - page 0. */
 +		rqstp->rq_res.tail[0].iov_base = p;
 +		*p++ = 0;		/* no more entries */
 +		*p++ = htonl(resp->common.err == nfserr_eof);
 +		rqstp->rq_res.tail[0].iov_len = 2<<2;
 +		return 1;
 +	} else
 +		return xdr_ressize_check(rqstp, p);
  }
  
- static __be32 *
- encode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,
- 	     int namlen, u64 ino)
- {
- 	*p++ = xdr_one;				 /* mark entry present */
- 	p    = xdr_encode_hyper(p, ino);	 /* file id */
- 	p    = xdr_encode_array(p, name, namlen);/* name length & name */
- 
- 	cd->offset = p;				/* remember pointer */
- 	p = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */
- 
- 	return p;
- }
- 
  static __be32
  compose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,
  		 const char *name, int namlen, u64 ino)
@@@ -1185,181 -1192,167 +1161,201 @@@ out
  	return rv;
  }
  
 -/**
 - * nfs3svc_encode_cookie3 - Encode a directory offset cookie
 - * @resp: readdir result context
 - * @offset: offset cookie to encode
 - *
 - * The buffer space for the offset cookie has already been reserved
 - * by svcxdr_encode_entry3_common().
 - */
 -void nfs3svc_encode_cookie3(struct nfsd3_readdirres *resp, u64 offset)
++<<<<<<< HEAD
 +static __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)
  {
 -	__be64 cookie = cpu_to_be64(offset);
 +	struct svc_fh	*fh = &cd->scratch;
 +	__be32 err;
  
 -	if (!resp->cookie_offset)
 -		return;
 -	write_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,
 -			       sizeof(cookie));
 -	resp->cookie_offset = 0;
 +	fh_init(fh, NFS3_FHSIZE);
 +	err = compose_entry_fh(cd, fh, name, namlen, ino);
 +	if (err) {
 +		*p++ = 0;
 +		*p++ = 0;
 +		goto out;
 +	}
 +	p = encode_post_op_attr(cd->rqstp, p, fh);
 +	*p++ = xdr_one;			/* yes, a file handle follows */
 +	p = encode_fh(p, fh);
 +out:
 +	fh_put(fh);
 +	return p;
  }
  
 -static bool
 -svcxdr_encode_entry3_common(struct nfsd3_readdirres *resp, const char *name,
 -			    int namlen, loff_t offset, u64 ino)
 -{
 -	struct xdr_buf *dirlist = &resp->dirlist;
 -	struct xdr_stream *xdr = &resp->xdr;
 +/*
 + * Encode a directory entry. This one works for both normal readdir
 + * and readdirplus.
 + * The normal readdir reply requires 2 (fileid) + 1 (stringlen)
 + * + string + 2 (cookie) + 1 (next) words, i.e. 6 + strlen.
 + * 
 + * The readdirplus baggage is 1+21 words for post_op_attr, plus the
 + * file handle.
 + */
  
 -	if (xdr_stream_encode_item_present(xdr) < 0)
 -		return false;
 -	/* fileid */
 -	if (xdr_stream_encode_u64(xdr, ino) < 0)
 -		return false;
 -	/* name */
 -	if (xdr_stream_encode_opaque(xdr, name, min(namlen, NFS3_MAXNAMLEN)) < 0)
 -		return false;
 -	/* cookie */
 -	resp->cookie_offset = dirlist->len;
 -	if (xdr_stream_encode_u64(xdr, NFS_OFFSET_MAX) < 0)
 -		return false;
 +#define NFS3_ENTRY_BAGGAGE	(2 + 1 + 2 + 1)
 +#define NFS3_ENTRYPLUS_BAGGAGE	(1 + 21 + 1 + (NFS3_FHSIZE >> 2))
 +static int
 +encode_entry(struct readdir_cd *ccd, const char *name, int namlen,
 +	     loff_t offset, u64 ino, unsigned int d_type, int plus)
 +{
 +	struct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,
 +		       					common);
 +	__be32		*p = cd->buffer;
 +	caddr_t		curr_page_addr = NULL;
 +	struct page **	page;
 +	int		slen;		/* string (name) length */
 +	int		elen;		/* estimated entry length in words */
 +	int		num_entry_words = 0;	/* actual number of words */
 +
 +	if (cd->offset) {
 +		u64 offset64 = offset;
 +
 +		if (unlikely(cd->offset1)) {
 +			/* we ended up with offset on a page boundary */
 +			*cd->offset = htonl(offset64 >> 32);
 +			*cd->offset1 = htonl(offset64 & 0xffffffff);
 +			cd->offset1 = NULL;
 +		} else {
 +			xdr_encode_hyper(cd->offset, offset64);
 +		}
 +		cd->offset = NULL;
 +	}
  
 -	return true;
 -}
 +	/*
 +	dprintk("encode_entry(%.*s @%ld%s)\n",
 +		namlen, name, (long) offset, plus? " plus" : "");
 +	 */
  
 -/**
 - * nfs3svc_encode_entry3 - encode one NFSv3 READDIR entry
 - * @data: directory context
 - * @name: name of the object to be encoded
 - * @namlen: length of that name, in bytes
 - * @offset: the offset of the previous entry
 - * @ino: the fileid of this entry
 - * @d_type: unused
 - *
 - * Return values:
 - *   %0: Entry was successfully encoded.
 - *   %-EINVAL: An encoding problem occured, secondary status code in resp->common.err
 - *
 - * On exit, the following fields are updated:
 - *   - resp->xdr
 - *   - resp->common.err
 - *   - resp->cookie_offset
 - */
 -int nfs3svc_encode_entry3(void *data, const char *name, int namlen,
 -			  loff_t offset, u64 ino, unsigned int d_type)
 -{
 -	struct readdir_cd *ccd = data;
 -	struct nfsd3_readdirres *resp = container_of(ccd,
 -						     struct nfsd3_readdirres,
 -						     common);
 -	unsigned int starting_length = resp->dirlist.len;
 +	/* truncate filename if too long */
 +	namlen = min(namlen, NFS3_MAXNAMLEN);
  
 -	/* The offset cookie for the previous entry */
 -	nfs3svc_encode_cookie3(resp, offset);
 +	slen = XDR_QUADLEN(namlen);
 +	elen = slen + NFS3_ENTRY_BAGGAGE
 +		+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);
  
 -	if (!svcxdr_encode_entry3_common(resp, name, namlen, offset, ino))
 -		goto out_toosmall;
 +	if (cd->buflen < elen) {
 +		cd->common.err = nfserr_toosmall;
 +		return -EINVAL;
 +	}
  
 -	xdr_commit_encode(&resp->xdr);
 -	resp->common.err = nfs_ok;
 -	return 0;
 +	/* determine which page in rq_respages[] we are currently filling */
 +	for (page = cd->rqstp->rq_respages + 1;
 +				page < cd->rqstp->rq_next_page; page++) {
 +		curr_page_addr = page_address(*page);
  
 -out_toosmall:
 -	resp->cookie_offset = 0;
 -	resp->common.err = nfserr_toosmall;
 -	resp->dirlist.len = starting_length;
 -	return -EINVAL;
 -}
 +		if (((caddr_t)cd->buffer >= curr_page_addr) &&
 +		    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))
 +			break;
 +	}
  
 -static bool
 -svcxdr_encode_entry3_plus(struct nfsd3_readdirres *resp, const char *name,
 -			  int namlen, u64 ino)
 -{
 -	struct xdr_stream *xdr = &resp->xdr;
 -	struct svc_fh *fhp = &resp->scratch;
 -	bool result;
 +	if ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {
 +		/* encode entry in current page */
  
 -	result = false;
 -	fh_init(fhp, NFS3_FHSIZE);
 -	if (compose_entry_fh(resp, fhp, name, namlen, ino) != nfs_ok)
 -		goto out_noattrs;
 +		p = encode_entry_baggage(cd, p, name, namlen, ino);
  
 -	if (!svcxdr_encode_post_op_attr(resp->rqstp, xdr, fhp))
 -		goto out;
 -	if (!svcxdr_encode_post_op_fh3(xdr, fhp))
 -		goto out;
 -	result = true;
 +		if (plus)
 +			p = encode_entryplus_baggage(cd, p, name, namlen, ino);
 +		num_entry_words = p - cd->buffer;
 +	} else if (*(page+1) != NULL) {
 +		/* temporarily encode entry into next page, then move back to
 +		 * current and next page in rq_respages[] */
 +		__be32 *p1, *tmp;
 +		int len1, len2;
  
 -out:
 -	fh_put(fhp);
 -	return result;
 +		/* grab next page for temporary storage of entry */
 +		p1 = tmp = page_address(*(page+1));
 +
 +		p1 = encode_entry_baggage(cd, p1, name, namlen, ino);
 +
 +		if (plus)
 +			p1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);
 +
 +		/* determine entry word length and lengths to go in pages */
 +		num_entry_words = p1 - tmp;
 +		len1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;
 +		if ((num_entry_words << 2) < len1) {
 +			/* the actual number of words in the entry is less
 +			 * than elen and can still fit in the current page
 +			 */
 +			memmove(p, tmp, num_entry_words << 2);
 +			p += num_entry_words;
 +
 +			/* update offset */
 +			cd->offset = cd->buffer + (cd->offset - tmp);
 +		} else {
 +			unsigned int offset_r = (cd->offset - tmp) << 2;
 +
 +			/* update pointer to offset location.
 +			 * This is a 64bit quantity, so we need to
 +			 * deal with 3 cases:
 +			 *  -	entirely in first page
 +			 *  -	entirely in second page
 +			 *  -	4 bytes in each page
 +			 */
 +			if (offset_r + 8 <= len1) {
 +				cd->offset = p + (cd->offset - tmp);
 +			} else if (offset_r >= len1) {
 +				cd->offset -= len1 >> 2;
 +			} else {
 +				/* sitting on the fence */
 +				BUG_ON(offset_r != len1 - 4);
 +				cd->offset = p + (cd->offset - tmp);
 +				cd->offset1 = tmp;
 +			}
 +
 +			len2 = (num_entry_words << 2) - len1;
 +
 +			/* move from temp page to current and next pages */
 +			memmove(p, tmp, len1);
 +			memmove(tmp, (caddr_t)tmp+len1, len2);
 +
 +			p = tmp + (len2 >> 2);
 +		}
 +	}
 +	else {
 +		cd->common.err = nfserr_toosmall;
 +		return -EINVAL;
 +	}
 +
 +	cd->buflen -= num_entry_words;
 +	cd->buffer = p;
 +	cd->common.err = nfs_ok;
 +	return 0;
  
 -out_noattrs:
 -	if (xdr_stream_encode_item_absent(xdr) < 0)
 -		return false;
 -	if (xdr_stream_encode_item_absent(xdr) < 0)
 -		return false;
 -	return true;
  }
  
 +int
 +nfs3svc_encode_entry(void *cd, const char *name,
 +		     int namlen, loff_t offset, u64 ino, unsigned int d_type)
 +{
 +	return encode_entry(cd, name, namlen, offset, ino, d_type, 0);
 +}
 +
 +int
 +nfs3svc_encode_entry_plus(void *cd, const char *name,
 +			  int namlen, loff_t offset, u64 ino,
 +			  unsigned int d_type)
 +{
 +	return encode_entry(cd, name, namlen, offset, ino, d_type, 1);
++=======
+ /**
 - * nfs3svc_encode_entryplus3 - encode one NFSv3 READDIRPLUS entry
 - * @data: directory context
 - * @name: name of the object to be encoded
 - * @namlen: length of that name, in bytes
 - * @offset: the offset of the previous entry
 - * @ino: the fileid of this entry
 - * @d_type: unused
 - *
 - * Return values:
 - *   %0: Entry was successfully encoded.
 - *   %-EINVAL: An encoding problem occured, secondary status code in resp->common.err
++ * nfs3svc_encode_cookie3 - Encode a directory offset cookie
++ * @resp: readdir result context
++ * @offset: offset cookie to encode
+  *
 - * On exit, the following fields are updated:
 - *   - resp->xdr
 - *   - resp->common.err
 - *   - resp->cookie_offset
++ * The buffer space for the offset cookie has already been reserved
++ * by svcxdr_encode_entry3_common().
+  */
 -int nfs3svc_encode_entryplus3(void *data, const char *name, int namlen,
 -			      loff_t offset, u64 ino, unsigned int d_type)
++void nfs3svc_encode_cookie3(struct nfsd3_readdirres *resp, u64 offset)
+ {
 -	struct readdir_cd *ccd = data;
 -	struct nfsd3_readdirres *resp = container_of(ccd,
 -						     struct nfsd3_readdirres,
 -						     common);
 -	unsigned int starting_length = resp->dirlist.len;
 -
 -	/* The offset cookie for the previous entry */
 -	nfs3svc_encode_cookie3(resp, offset);
 -
 -	if (!svcxdr_encode_entry3_common(resp, name, namlen, offset, ino))
 -		goto out_toosmall;
 -	if (!svcxdr_encode_entry3_plus(resp, name, namlen, ino))
 -		goto out_toosmall;
 -
 -	xdr_commit_encode(&resp->xdr);
 -	resp->common.err = nfs_ok;
 -	return 0;
++	__be64 cookie = cpu_to_be64(offset);
+ 
 -out_toosmall:
++	if (!resp->cookie_offset)
++		return;
++	write_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,
++			       sizeof(cookie));
+ 	resp->cookie_offset = 0;
 -	resp->common.err = nfserr_toosmall;
 -	resp->dirlist.len = starting_length;
 -	return -EINVAL;
++>>>>>>> 1411934627f9 (NFSD: Remove unused NFSv3 directory entry encoders)
  }
  
  static bool
diff --cc fs/nfsd/xdr3.h
index 8759e771bbc6,b851458373db..000000000000
--- a/fs/nfsd/xdr3.h
+++ b/fs/nfsd/xdr3.h
@@@ -169,19 -169,17 +169,26 @@@ struct nfsd3_linkres 
  };
  
  struct nfsd3_readdirres {
 -	/* Components of the reply */
  	__be32			status;
  	struct svc_fh		fh;
++<<<<<<< HEAD
 +	/* Just to save kmalloc on every readdirplus entry (svc_fh is a
 +	 * little large for the stack): */
 +	struct svc_fh		scratch;
 +	int			count;
++=======
++>>>>>>> 1411934627f9 (NFSD: Remove unused NFSv3 directory entry encoders)
  	__be32			verf[2];
  
 -	/* Used to encode the reply's entry list */
 -	struct xdr_stream	xdr;
 -	struct xdr_buf		dirlist;
 -	struct svc_fh		scratch;
  	struct readdir_cd	common;
++<<<<<<< HEAD
 +	__be32 *		buffer;
 +	int			buflen;
 +	__be32 *		offset;
 +	__be32 *		offset1;
++=======
+ 	unsigned int		cookie_offset;
++>>>>>>> 1411934627f9 (NFSD: Remove unused NFSv3 directory entry encoders)
  	struct svc_rqst *	rqstp;
  
  };
@@@ -299,12 -298,12 +306,21 @@@ int nfs3svc_encode_commitres(struct svc
  
  void nfs3svc_release_fhandle(struct svc_rqst *);
  void nfs3svc_release_fhandle2(struct svc_rqst *);
++<<<<<<< HEAD
 +int nfs3svc_encode_entry(void *, const char *name,
 +				int namlen, loff_t offset, u64 ino,
 +				unsigned int);
 +int nfs3svc_encode_entry_plus(void *, const char *name,
 +				int namlen, loff_t offset, u64 ino,
 +				unsigned int);
++=======
+ 
+ void nfs3svc_encode_cookie3(struct nfsd3_readdirres *resp, u64 offset);
+ int nfs3svc_encode_entry3(void *data, const char *name, int namlen,
+ 			  loff_t offset, u64 ino, unsigned int d_type);
+ int nfs3svc_encode_entryplus3(void *data, const char *name, int namlen,
+ 			      loff_t offset, u64 ino, unsigned int d_type);
++>>>>>>> 1411934627f9 (NFSD: Remove unused NFSv3 directory entry encoders)
  /* Helper functions for NFSv3 ACL code */
  __be32 *nfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p,
  				struct svc_fh *fhp);
* Unmerged path fs/nfsd/nfs3xdr.c
* Unmerged path fs/nfsd/xdr3.h
