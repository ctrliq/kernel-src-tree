RDMA/core: Create clean QP creations interface for uverbs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit d2b10794fc1312f856d67d0a6454aaa3ae96c595
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/d2b10794.failed

Unify create QP creation interface to make clean approach to create
XRC_TGT and regular QPs.

Link: https://lore.kernel.org/r/5cd50e7d8ad9112545a1a61dea62799a5cb3224a.1628014762.git.leonro@nvidia.com
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit d2b10794fc1312f856d67d0a6454aaa3ae96c595)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/core_priv.h
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/verbs.c
diff --cc drivers/infiniband/core/core_priv.h
index 98de555ab173,f66f48d860ec..000000000000
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@@ -316,46 -316,13 +316,56 @@@ struct ib_device *ib_device_get_by_inde
  void nldev_init(void);
  void nldev_exit(void);
  
++<<<<<<< HEAD
 +static inline struct ib_qp *
 +_ib_create_qp(struct ib_device *dev, struct ib_pd *pd,
 +	      struct ib_qp_init_attr *attr, struct ib_udata *udata,
 +	      struct ib_uqp_object *uobj, const char *caller)
 +{
 +	struct ib_qp *qp;
 +
 +	if (!dev->ops.create_qp)
 +		return ERR_PTR(-EOPNOTSUPP);
 +
 +	qp = dev->ops.create_qp(pd, attr, udata);
 +	if (IS_ERR(qp))
 +		return qp;
 +
 +	qp->device = dev;
 +	qp->pd = pd;
 +	qp->uobject = uobj;
 +	qp->real_qp = qp;
 +
 +	qp->qp_type = attr->qp_type;
 +	qp->rwq_ind_tbl = attr->rwq_ind_tbl;
 +	qp->send_cq = attr->send_cq;
 +	qp->recv_cq = attr->recv_cq;
 +	qp->srq = attr->srq;
 +	qp->rwq_ind_tbl = attr->rwq_ind_tbl;
 +	qp->event_handler = attr->event_handler;
 +	qp->port = attr->port_num;
 +	qp->qp_context = attr->qp_context;
 +
 +	atomic_set(&qp->usecnt, 0);
 +	spin_lock_init(&qp->mr_lock);
 +	INIT_LIST_HEAD(&qp->rdma_mrs);
 +	INIT_LIST_HEAD(&qp->sig_mrs);
 +
 +	rdma_restrack_new(&qp->res, RDMA_RESTRACK_QP);
 +	WARN_ONCE(!udata && !caller, "Missing kernel QP owner");
 +	rdma_restrack_set_name(&qp->res, udata ? NULL : caller);
 +	rdma_restrack_add(&qp->res);
 +	return qp;
 +}
++=======
+ struct ib_qp *ib_create_qp_user(struct ib_device *dev, struct ib_pd *pd,
+ 				struct ib_qp_init_attr *attr,
+ 				struct ib_udata *udata,
+ 				struct ib_uqp_object *uobj, const char *caller);
+ 
+ void ib_qp_usecnt_inc(struct ib_qp *qp);
+ void ib_qp_usecnt_dec(struct ib_qp *qp);
++>>>>>>> d2b10794fc13 (RDMA/core: Create clean QP creations interface for uverbs)
  
  struct rdma_dev_addr;
  int rdma_resolve_ip_route(struct sockaddr *src_addr,
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 7d7b5054308d,740e6b2efe0e..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -1447,26 -1441,8 +1443,29 @@@ static int create_qp(struct uverbs_attr
  		ret = PTR_ERR(qp);
  		goto err_put;
  	}
 -	ib_qp_usecnt_inc(qp);
  
++<<<<<<< HEAD
 +	if (cmd->qp_type != IB_QPT_XRC_TGT) {
 +		ret = ib_create_qp_security(qp, device);
 +		if (ret)
 +			goto err_cb;
 +
 +		atomic_inc(&pd->usecnt);
 +		if (attr.send_cq)
 +			atomic_inc(&attr.send_cq->usecnt);
 +		if (attr.recv_cq)
 +			atomic_inc(&attr.recv_cq->usecnt);
 +		if (attr.srq)
 +			atomic_inc(&attr.srq->usecnt);
 +		if (ind_tbl)
 +			atomic_inc(&ind_tbl->usecnt);
 +	} else {
 +		/* It is done in _ib_create_qp for other QP types */
 +		qp->uobject = obj;
 +	}
 +
++=======
++>>>>>>> d2b10794fc13 (RDMA/core: Create clean QP creations interface for uverbs)
  	obj->uevent.uobject.object = qp;
  	obj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);
  	if (obj->uevent.event_file)
diff --cc drivers/infiniband/core/verbs.c
index 15688810fb77,89a2b21976d6..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -1199,22 -1200,140 +1199,157 @@@ static struct ib_qp *create_xrc_qp_user
  	return qp;
  }
  
++<<<<<<< HEAD
 +/**
 + * ib_create_named_qp - Creates a kernel QP associated with the specified protection
 + *   domain.
 + * @pd: The protection domain associated with the QP.
 + * @qp_init_attr: A list of initial attributes required to create the
 + *   QP.  If QP creation succeeds, then the attributes are updated to
 + *   the actual capabilities of the created QP.
 + * @caller: caller's build-time module name
 + *
 + * NOTE: for user qp use ib_create_qp_user with valid udata!
 + */
 +struct ib_qp *ib_create_named_qp(struct ib_pd *pd,
 +				 struct ib_qp_init_attr *qp_init_attr,
 +				 const char *caller)
++=======
+ static struct ib_qp *create_qp(struct ib_device *dev, struct ib_pd *pd,
+ 			       struct ib_qp_init_attr *attr,
+ 			       struct ib_udata *udata,
+ 			       struct ib_uqp_object *uobj, const char *caller)
  {
- 	struct ib_device *device = pd ? pd->device : qp_init_attr->xrcd->device;
+ 	struct ib_udata dummy = {};
+ 	struct ib_qp *qp;
+ 	int ret;
+ 
+ 	if (!dev->ops.create_qp)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	qp = rdma_zalloc_drv_obj_numa(dev, ib_qp);
+ 	if (!qp)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	qp->device = dev;
+ 	qp->pd = pd;
+ 	qp->uobject = uobj;
+ 	qp->real_qp = qp;
+ 
+ 	qp->qp_type = attr->qp_type;
+ 	qp->rwq_ind_tbl = attr->rwq_ind_tbl;
+ 	qp->srq = attr->srq;
+ 	qp->event_handler = attr->event_handler;
+ 	qp->port = attr->port_num;
+ 	qp->qp_context = attr->qp_context;
+ 
+ 	spin_lock_init(&qp->mr_lock);
+ 	INIT_LIST_HEAD(&qp->rdma_mrs);
+ 	INIT_LIST_HEAD(&qp->sig_mrs);
+ 
+ 	rdma_restrack_new(&qp->res, RDMA_RESTRACK_QP);
+ 	WARN_ONCE(!udata && !caller, "Missing kernel QP owner");
+ 	rdma_restrack_set_name(&qp->res, udata ? NULL : caller);
+ 	ret = dev->ops.create_qp(qp, attr, udata);
+ 	if (ret)
+ 		goto err_create;
+ 
+ 	/*
+ 	 * TODO: The mlx4 internally overwrites send_cq and recv_cq.
+ 	 * Unfortunately, it is not an easy task to fix that driver.
+ 	 */
+ 	qp->send_cq = attr->send_cq;
+ 	qp->recv_cq = attr->recv_cq;
+ 
+ 	ret = ib_create_qp_security(qp, dev);
+ 	if (ret)
+ 		goto err_security;
+ 
+ 	rdma_restrack_add(&qp->res);
+ 	return qp;
+ 
+ err_security:
+ 	qp->device->ops.destroy_qp(qp, udata ? &dummy : NULL);
+ err_create:
+ 	rdma_restrack_put(&qp->res);
+ 	kfree(qp);
+ 	return ERR_PTR(ret);
+ 
+ }
+ 
+ /**
+  * ib_create_qp_user - Creates a QP associated with the specified protection
+  *   domain.
+  * @dev: IB device
+  * @pd: The protection domain associated with the QP.
+  * @attr: A list of initial attributes required to create the
+  *   QP.  If QP creation succeeds, then the attributes are updated to
+  *   the actual capabilities of the created QP.
+  * @udata: User data
+  * @uobj: uverbs obect
+  * @caller: caller's build-time module name
+  */
+ struct ib_qp *ib_create_qp_user(struct ib_device *dev, struct ib_pd *pd,
+ 				struct ib_qp_init_attr *attr,
+ 				struct ib_udata *udata,
+ 				struct ib_uqp_object *uobj, const char *caller)
+ {
+ 	struct ib_qp *qp, *xrc_qp;
+ 
+ 	if (attr->qp_type == IB_QPT_XRC_TGT)
+ 		qp = create_qp(dev, pd, attr, NULL, NULL, caller);
+ 	else
+ 		qp = create_qp(dev, pd, attr, udata, uobj, NULL);
+ 	if (attr->qp_type != IB_QPT_XRC_TGT || IS_ERR(qp))
+ 		return qp;
+ 
+ 	xrc_qp = create_xrc_qp_user(qp, attr);
+ 	if (IS_ERR(xrc_qp)) {
+ 		ib_destroy_qp(qp);
+ 		return xrc_qp;
+ 	}
+ 
+ 	xrc_qp->uobject = uobj;
+ 	return xrc_qp;
+ }
+ EXPORT_SYMBOL(ib_create_qp_user);
+ 
+ void ib_qp_usecnt_inc(struct ib_qp *qp)
+ {
+ 	if (qp->pd)
+ 		atomic_inc(&qp->pd->usecnt);
+ 	if (qp->send_cq)
+ 		atomic_inc(&qp->send_cq->usecnt);
+ 	if (qp->recv_cq)
+ 		atomic_inc(&qp->recv_cq->usecnt);
+ 	if (qp->srq)
+ 		atomic_inc(&qp->srq->usecnt);
+ 	if (qp->rwq_ind_tbl)
+ 		atomic_inc(&qp->rwq_ind_tbl->usecnt);
+ }
+ EXPORT_SYMBOL(ib_qp_usecnt_inc);
+ 
+ void ib_qp_usecnt_dec(struct ib_qp *qp)
+ {
+ 	if (qp->rwq_ind_tbl)
+ 		atomic_dec(&qp->rwq_ind_tbl->usecnt);
+ 	if (qp->srq)
+ 		atomic_dec(&qp->srq->usecnt);
+ 	if (qp->recv_cq)
+ 		atomic_dec(&qp->recv_cq->usecnt);
+ 	if (qp->send_cq)
+ 		atomic_dec(&qp->send_cq->usecnt);
+ 	if (qp->pd)
+ 		atomic_dec(&qp->pd->usecnt);
+ }
+ EXPORT_SYMBOL(ib_qp_usecnt_dec);
+ 
+ struct ib_qp *ib_create_qp_kernel(struct ib_pd *pd,
+ 				  struct ib_qp_init_attr *qp_init_attr,
+ 				  const char *caller)
++>>>>>>> d2b10794fc13 (RDMA/core: Create clean QP creations interface for uverbs)
+ {
+ 	struct ib_device *device = pd->device;
  	struct ib_qp *qp;
  	int ret;
  
@@@ -1231,29 -1350,7 +1366,33 @@@
  	if (IS_ERR(qp))
  		return qp;
  
++<<<<<<< HEAD
 +	ret = ib_create_qp_security(qp, device);
 +	if (ret)
 +		goto err;
 +
 +	if (qp_init_attr->qp_type == IB_QPT_XRC_TGT) {
 +		struct ib_qp *xrc_qp =
 +			create_xrc_qp_user(qp, qp_init_attr);
 +
 +		if (IS_ERR(xrc_qp)) {
 +			ret = PTR_ERR(xrc_qp);
 +			goto err;
 +		}
 +		return xrc_qp;
 +	}
 +
 +	if (qp_init_attr->recv_cq)
 +		atomic_inc(&qp_init_attr->recv_cq->usecnt);
 +	if (qp->srq)
 +		atomic_inc(&qp_init_attr->srq->usecnt);
 +
 +	atomic_inc(&pd->usecnt);
 +	if (qp_init_attr->send_cq)
 +		atomic_inc(&qp_init_attr->send_cq->usecnt);
++=======
+ 	ib_qp_usecnt_inc(qp);
++>>>>>>> d2b10794fc13 (RDMA/core: Create clean QP creations interface for uverbs)
  
  	if (qp_init_attr->cap.max_rdma_ctxs) {
  		ret = rdma_rw_init_mrs(qp, qp_init_attr);
* Unmerged path drivers/infiniband/core/core_priv.h
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
diff --git a/drivers/infiniband/core/uverbs_std_types_qp.c b/drivers/infiniband/core/uverbs_std_types_qp.c
index 070994ed133d..79449009d720 100644
--- a/drivers/infiniband/core/uverbs_std_types_qp.c
+++ b/drivers/infiniband/core/uverbs_std_types_qp.c
@@ -248,12 +248,8 @@ static int UVERBS_HANDLER(UVERBS_METHOD_QP_CREATE)(
 	set_caps(&attr, &cap, true);
 	mutex_init(&obj->mcast_lock);
 
-	if (attr.qp_type == IB_QPT_XRC_TGT)
-		qp = ib_create_qp(pd, &attr);
-	else
-		qp = _ib_create_qp(device, pd, &attr, &attrs->driver_udata, obj,
-				   NULL);
-
+	qp = ib_create_qp_user(device, pd, &attr, &attrs->driver_udata, obj,
+			       KBUILD_MODNAME);
 	if (IS_ERR(qp)) {
 		ret = PTR_ERR(qp);
 		goto err_put;
@@ -273,8 +269,6 @@ static int UVERBS_HANDLER(UVERBS_METHOD_QP_CREATE)(
 		obj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object,
 					  uobject);
 		atomic_inc(&obj->uxrcd->refcnt);
-		/* It is done in _ib_create_qp for other QP types */
-		qp->uobject = obj;
 	}
 
 	obj->uevent.uobject.object = qp;
* Unmerged path drivers/infiniband/core/verbs.c
