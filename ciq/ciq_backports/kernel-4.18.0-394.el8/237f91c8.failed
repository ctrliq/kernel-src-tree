NFSD: Add tracepoints for SETCLIENTID edge cases

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 237f91c85acef206a33bc02f3c4e856128fd7994
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/237f91c8.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 237f91c85acef206a33bc02f3c4e856128fd7994)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/trace.h
diff --cc fs/nfsd/trace.h
index 2c7ada5dbc70,33fba6dbdc4a..000000000000
--- a/fs/nfsd/trace.h
+++ b/fs/nfsd/trace.h
@@@ -492,7 -511,12 +492,16 @@@ DEFINE_EVENT(nfsd_clientid_class, nfsd_
  	TP_PROTO(const clientid_t *clid), \
  	TP_ARGS(clid))
  
++<<<<<<< HEAD
 +DEFINE_CLIENTID_EVENT(expired);
++=======
+ DEFINE_CLIENTID_EVENT(expire_unconf);
+ DEFINE_CLIENTID_EVENT(reclaim_complete);
+ DEFINE_CLIENTID_EVENT(confirmed);
+ DEFINE_CLIENTID_EVENT(destroyed);
+ DEFINE_CLIENTID_EVENT(admin_expired);
+ DEFINE_CLIENTID_EVENT(replaced);
++>>>>>>> 237f91c85ace (NFSD: Add tracepoints for SETCLIENTID edge cases)
  DEFINE_CLIENTID_EVENT(purged);
  DEFINE_CLIENTID_EVENT(renew);
  DEFINE_CLIENTID_EVENT(stale);
@@@ -577,29 -601,181 +586,88 @@@ TRACE_EVENT(nfsd_clid_verf_mismatch
  	)
  );
  
++<<<<<<< HEAD
 +TRACE_EVENT(nfsd_clid_inuse_err,
 +	TP_PROTO(const struct nfs4_client *clp),
 +	TP_ARGS(clp),
++=======
+ DECLARE_EVENT_CLASS(nfsd_clid_class,
+ 	TP_PROTO(const struct nfs4_client *clp),
+ 	TP_ARGS(clp),
+ 	TP_STRUCT__entry(
+ 		__field(u32, cl_boot)
+ 		__field(u32, cl_id)
+ 		__array(unsigned char, addr, sizeof(struct sockaddr_in6))
+ 		__field(unsigned long, flavor)
+ 		__array(unsigned char, verifier, NFS4_VERIFIER_SIZE)
+ 		__dynamic_array(char, name, clp->cl_name.len + 1)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->cl_boot = clp->cl_clientid.cl_boot;
+ 		__entry->cl_id = clp->cl_clientid.cl_id;
+ 		memcpy(__entry->addr, &clp->cl_addr,
+ 			sizeof(struct sockaddr_in6));
+ 		__entry->flavor = clp->cl_cred.cr_flavor;
+ 		memcpy(__entry->verifier, (void *)&clp->cl_verifier,
+ 		       NFS4_VERIFIER_SIZE);
+ 		memcpy(__get_str(name), clp->cl_name.data, clp->cl_name.len);
+ 		__get_str(name)[clp->cl_name.len] = '\0';
+ 	),
+ 	TP_printk("addr=%pISpc name='%s' verifier=0x%s flavor=%s client=%08x:%08x",
+ 		__entry->addr, __get_str(name),
+ 		__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE),
+ 		show_nfsd_authflavor(__entry->flavor),
+ 		__entry->cl_boot, __entry->cl_id)
+ );
+ 
+ #define DEFINE_CLID_EVENT(name) \
+ DEFINE_EVENT(nfsd_clid_class, nfsd_clid_##name, \
+ 	TP_PROTO(const struct nfs4_client *clp), \
+ 	TP_ARGS(clp))
+ 
+ DEFINE_CLID_EVENT(fresh);
+ 
+ /*
+  * from fs/nfsd/filecache.h
+  */
+ TRACE_DEFINE_ENUM(NFSD_FILE_HASHED);
+ TRACE_DEFINE_ENUM(NFSD_FILE_PENDING);
+ TRACE_DEFINE_ENUM(NFSD_FILE_BREAK_READ);
+ TRACE_DEFINE_ENUM(NFSD_FILE_BREAK_WRITE);
+ TRACE_DEFINE_ENUM(NFSD_FILE_REFERENCED);
+ 
+ #define show_nf_flags(val)						\
+ 	__print_flags(val, "|",						\
+ 		{ 1 << NFSD_FILE_HASHED,	"HASHED" },		\
+ 		{ 1 << NFSD_FILE_PENDING,	"PENDING" },		\
+ 		{ 1 << NFSD_FILE_BREAK_READ,	"BREAK_READ" },		\
+ 		{ 1 << NFSD_FILE_BREAK_WRITE,	"BREAK_WRITE" },	\
+ 		{ 1 << NFSD_FILE_REFERENCED,	"REFERENCED"})
+ 
+ DECLARE_EVENT_CLASS(nfsd_file_class,
+ 	TP_PROTO(struct nfsd_file *nf),
+ 	TP_ARGS(nf),
++>>>>>>> 237f91c85ace (NFSD: Add tracepoints for SETCLIENTID edge cases)
  	TP_STRUCT__entry(
 -		__field(unsigned int, nf_hashval)
 -		__field(void *, nf_inode)
 -		__field(int, nf_ref)
 -		__field(unsigned long, nf_flags)
 -		__field(unsigned char, nf_may)
 -		__field(struct file *, nf_file)
 -	),
 -	TP_fast_assign(
 -		__entry->nf_hashval = nf->nf_hashval;
 -		__entry->nf_inode = nf->nf_inode;
 -		__entry->nf_ref = refcount_read(&nf->nf_ref);
 -		__entry->nf_flags = nf->nf_flags;
 -		__entry->nf_may = nf->nf_may;
 -		__entry->nf_file = nf->nf_file;
 -	),
 -	TP_printk("hash=0x%x inode=%p ref=%d flags=%s may=%s file=%p",
 -		__entry->nf_hashval,
 -		__entry->nf_inode,
 -		__entry->nf_ref,
 -		show_nf_flags(__entry->nf_flags),
 -		show_nfsd_may_flags(__entry->nf_may),
 -		__entry->nf_file)
 -)
 -
 -#define DEFINE_NFSD_FILE_EVENT(name) \
 -DEFINE_EVENT(nfsd_file_class, name, \
 -	TP_PROTO(struct nfsd_file *nf), \
 -	TP_ARGS(nf))
 -
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_alloc);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_put_final);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_unhash);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_put);
 -DEFINE_NFSD_FILE_EVENT(nfsd_file_unhash_and_release_locked);
 -
 -TRACE_EVENT(nfsd_file_acquire,
 -	TP_PROTO(struct svc_rqst *rqstp, unsigned int hash,
 -		 struct inode *inode, unsigned int may_flags,
 -		 struct nfsd_file *nf, __be32 status),
 -
 -	TP_ARGS(rqstp, hash, inode, may_flags, nf, status),
 -
 -	TP_STRUCT__entry(
 -		__field(u32, xid)
 -		__field(unsigned int, hash)
 -		__field(void *, inode)
 -		__field(unsigned long, may_flags)
 -		__field(int, nf_ref)
 -		__field(unsigned long, nf_flags)
 -		__field(unsigned long, nf_may)
 -		__field(struct file *, nf_file)
 -		__field(u32, status)
 -	),
 -
 -	TP_fast_assign(
 -		__entry->xid = be32_to_cpu(rqstp->rq_xid);
 -		__entry->hash = hash;
 -		__entry->inode = inode;
 -		__entry->may_flags = may_flags;
 -		__entry->nf_ref = nf ? refcount_read(&nf->nf_ref) : 0;
 -		__entry->nf_flags = nf ? nf->nf_flags : 0;
 -		__entry->nf_may = nf ? nf->nf_may : 0;
 -		__entry->nf_file = nf ? nf->nf_file : NULL;
 -		__entry->status = be32_to_cpu(status);
 -	),
 -
 -	TP_printk("xid=0x%x hash=0x%x inode=%p may_flags=%s ref=%d nf_flags=%s nf_may=%s nf_file=%p status=%u",
 -			__entry->xid, __entry->hash, __entry->inode,
 -			show_nfsd_may_flags(__entry->may_flags),
 -			__entry->nf_ref, show_nf_flags(__entry->nf_flags),
 -			show_nfsd_may_flags(__entry->nf_may),
 -			__entry->nf_file, __entry->status)
 -);
 -
 -DECLARE_EVENT_CLASS(nfsd_file_search_class,
 -	TP_PROTO(struct inode *inode, unsigned int hash, int found),
 -	TP_ARGS(inode, hash, found),
 -	TP_STRUCT__entry(
 -		__field(struct inode *, inode)
 -		__field(unsigned int, hash)
 -		__field(int, found)
 -	),
 -	TP_fast_assign(
 -		__entry->inode = inode;
 -		__entry->hash = hash;
 -		__entry->found = found;
 -	),
 -	TP_printk("hash=0x%x inode=%p found=%d", __entry->hash,
 -			__entry->inode, __entry->found)
 -);
 -
 -#define DEFINE_NFSD_FILE_SEARCH_EVENT(name)				\
 -DEFINE_EVENT(nfsd_file_search_class, name,				\
 -	TP_PROTO(struct inode *inode, unsigned int hash, int found),	\
 -	TP_ARGS(inode, hash, found))
 -
 -DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode_sync);
 -DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode);
 -DEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_is_cached);
 -
 -TRACE_EVENT(nfsd_file_fsnotify_handle_event,
 -	TP_PROTO(struct inode *inode, u32 mask),
 -	TP_ARGS(inode, mask),
 -	TP_STRUCT__entry(
 -		__field(struct inode *, inode)
 -		__field(unsigned int, nlink)
 -		__field(umode_t, mode)
 -		__field(u32, mask)
 +		__field(u32, cl_boot)
 +		__field(u32, cl_id)
 +		__array(unsigned char, addr, sizeof(struct sockaddr_in6))
 +		__field(unsigned int, namelen)
 +		__dynamic_array(unsigned char, name, clp->cl_name.len)
  	),
  	TP_fast_assign(
 -		__entry->inode = inode;
 -		__entry->nlink = inode->i_nlink;
 -		__entry->mode = inode->i_mode;
 -		__entry->mask = mask;
 +		__entry->cl_boot = clp->cl_clientid.cl_boot;
 +		__entry->cl_id = clp->cl_clientid.cl_id;
 +		memcpy(__entry->addr, &clp->cl_addr,
 +			sizeof(struct sockaddr_in6));
 +		__entry->namelen = clp->cl_name.len;
 +		memcpy(__get_dynamic_array(name), clp->cl_name.data,
 +			clp->cl_name.len);
  	),
 -	TP_printk("inode=%p nlink=%u mode=0%ho mask=0x%x", __entry->inode,
 -			__entry->nlink, __entry->mode, __entry->mask)
 -);
 +	TP_printk("nfs4_clientid %.*s already in use by %pISpc, client %08x:%08x",
 +		__entry->namelen, __get_str(name), __entry->addr,
 +		__entry->cl_boot, __entry->cl_id)
 +)
  
  #include "cache.h"
  
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 968845cb8307..e0bc5dc12b50 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3927,11 +3927,9 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	new = create_client(clname, rqstp, &clverifier);
 	if (new == NULL)
 		return nfserr_jukebox;
-	/* Cases below refer to rfc 3530 section 14.2.33: */
 	spin_lock(&nn->client_lock);
 	conf = find_confirmed_client_by_name(&clname, nn);
 	if (conf && client_has_state(conf)) {
-		/* case 0: */
 		status = nfserr_clid_inuse;
 		if (clp_used_exchangeid(conf))
 			goto out;
@@ -3943,7 +3941,6 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	unconf = find_unconfirmed_client_by_name(&clname, nn);
 	if (unconf)
 		unhash_client_locked(unconf);
-	/* We need to handle only case 1: probable callback update */
 	if (conf) {
 		if (same_verf(&conf->cl_verifier, &clverifier)) {
 			copy_clid(new, conf);
@@ -3951,7 +3948,8 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		} else
 			trace_nfsd_clid_verf_mismatch(conf, rqstp,
 						      &clverifier);
-	}
+	} else
+		trace_nfsd_clid_fresh(new);
 	new->cl_minorversion = 0;
 	gen_callback(new, setclid, rqstp);
 	add_to_unconfirmed(new);
@@ -3964,12 +3962,13 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	spin_unlock(&nn->client_lock);
 	if (new)
 		free_client(new);
-	if (unconf)
+	if (unconf) {
+		trace_nfsd_clid_expire_unconf(&unconf->cl_clientid);
 		expire_client(unconf);
+	}
 	return status;
 }
 
-
 __be32
 nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 			struct nfsd4_compound_state *cstate,
@@ -4006,21 +4005,19 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 		trace_nfsd_clid_cred_mismatch(conf, rqstp);
 		goto out;
 	}
-	/* cases below refer to rfc 3530 section 14.2.34: */
 	if (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {
 		if (conf && same_verf(&confirm, &conf->cl_confirm)) {
-			/* case 2: probable retransmit */
 			status = nfs_ok;
-		} else /* case 4: client hasn't noticed we rebooted yet? */
+		} else
 			status = nfserr_stale_clientid;
 		goto out;
 	}
 	status = nfs_ok;
-	if (conf) { /* case 1: callback update */
+	if (conf) {
 		old = unconf;
 		unhash_client_locked(old);
 		nfsd4_change_callback(conf, &unconf->cl_cb_conn);
-	} else { /* case 3: normal case; new or rebooted client */
+	} else {
 		old = find_confirmed_client_by_name(&unconf->cl_name, nn);
 		if (old) {
 			status = nfserr_clid_inuse;
* Unmerged path fs/nfsd/trace.h
