RDMA/core: Fix ib_qp_usecnt_dec() called when error

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Yajun Deng <yajun.deng@linux.dev>
commit 7c4a539ec38f4ce400a0f3fcb5ff6c940fcd67bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/7c4a539e.failed

ib_destroy_qp() would called by ib_create_qp_user() if error, the former
contains ib_qp_usecnt_dec(), but ib_qp_usecnt_inc() was not called before.

So move ib_qp_usecnt_inc() into create_qp().

Fixes: d2b10794fc13 ("RDMA/core: Create clean QP creations interface for uverbs")
Link: https://lore.kernel.org/r/20220303024232.2847388-1-yajun.deng@linux.dev
	Signed-off-by: Yajun Deng <yajun.deng@linux.dev>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 7c4a539ec38f4ce400a0f3fcb5ff6c940fcd67bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/verbs.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 9eca370b8ef4,4437f834c0a7..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -1443,25 -1437,6 +1443,28 @@@ static int create_qp(struct uverbs_attr
  		ret = PTR_ERR(qp);
  		goto err_put;
  	}
++<<<<<<< HEAD
 +
 +	if (cmd->qp_type != IB_QPT_XRC_TGT) {
 +		ret = ib_create_qp_security(qp, device);
 +		if (ret)
 +			goto err_cb;
 +
 +		atomic_inc(&pd->usecnt);
 +		if (attr.send_cq)
 +			atomic_inc(&attr.send_cq->usecnt);
 +		if (attr.recv_cq)
 +			atomic_inc(&attr.recv_cq->usecnt);
 +		if (attr.srq)
 +			atomic_inc(&attr.srq->usecnt);
 +		if (ind_tbl)
 +			atomic_inc(&ind_tbl->usecnt);
 +	} else {
 +		/* It is done in _ib_create_qp for other QP types */
 +		qp->uobject = obj;
 +	}
++=======
++>>>>>>> 7c4a539ec38f (RDMA/core: Fix ib_qp_usecnt_dec() called when error)
  
  	obj->uevent.uobject.object = qp;
  	obj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);
diff --cc drivers/infiniband/core/verbs.c
index e77032057254,bc9a83f1ca2d..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -1191,22 -1192,144 +1191,91 @@@ static struct ib_qp *create_xrc_qp_user
  	return qp;
  }
  
++<<<<<<< HEAD
++=======
+ static struct ib_qp *create_qp(struct ib_device *dev, struct ib_pd *pd,
+ 			       struct ib_qp_init_attr *attr,
+ 			       struct ib_udata *udata,
+ 			       struct ib_uqp_object *uobj, const char *caller)
+ {
+ 	struct ib_udata dummy = {};
+ 	struct ib_qp *qp;
+ 	int ret;
+ 
+ 	if (!dev->ops.create_qp)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	qp = rdma_zalloc_drv_obj_numa(dev, ib_qp);
+ 	if (!qp)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	qp->device = dev;
+ 	qp->pd = pd;
+ 	qp->uobject = uobj;
+ 	qp->real_qp = qp;
+ 
+ 	qp->qp_type = attr->qp_type;
+ 	qp->rwq_ind_tbl = attr->rwq_ind_tbl;
+ 	qp->srq = attr->srq;
+ 	qp->event_handler = attr->event_handler;
+ 	qp->port = attr->port_num;
+ 	qp->qp_context = attr->qp_context;
+ 
+ 	spin_lock_init(&qp->mr_lock);
+ 	INIT_LIST_HEAD(&qp->rdma_mrs);
+ 	INIT_LIST_HEAD(&qp->sig_mrs);
+ 
+ 	qp->send_cq = attr->send_cq;
+ 	qp->recv_cq = attr->recv_cq;
+ 
+ 	rdma_restrack_new(&qp->res, RDMA_RESTRACK_QP);
+ 	WARN_ONCE(!udata && !caller, "Missing kernel QP owner");
+ 	rdma_restrack_set_name(&qp->res, udata ? NULL : caller);
+ 	ret = dev->ops.create_qp(qp, attr, udata);
+ 	if (ret)
+ 		goto err_create;
+ 
+ 	/*
+ 	 * TODO: The mlx4 internally overwrites send_cq and recv_cq.
+ 	 * Unfortunately, it is not an easy task to fix that driver.
+ 	 */
+ 	qp->send_cq = attr->send_cq;
+ 	qp->recv_cq = attr->recv_cq;
+ 
+ 	ret = ib_create_qp_security(qp, dev);
+ 	if (ret)
+ 		goto err_security;
+ 
+ 	ib_qp_usecnt_inc(qp);
+ 	rdma_restrack_add(&qp->res);
+ 	return qp;
+ 
+ err_security:
+ 	qp->device->ops.destroy_qp(qp, udata ? &dummy : NULL);
+ err_create:
+ 	rdma_restrack_put(&qp->res);
+ 	kfree(qp);
+ 	return ERR_PTR(ret);
+ 
+ }
+ 
++>>>>>>> 7c4a539ec38f (RDMA/core: Fix ib_qp_usecnt_dec() called when error)
  /**
 - * ib_create_qp_user - Creates a QP associated with the specified protection
 + * ib_create_named_qp - Creates a kernel QP associated with the specified protection
   *   domain.
 - * @dev: IB device
   * @pd: The protection domain associated with the QP.
 - * @attr: A list of initial attributes required to create the
 + * @qp_init_attr: A list of initial attributes required to create the
   *   QP.  If QP creation succeeds, then the attributes are updated to
   *   the actual capabilities of the created QP.
 - * @udata: User data
 - * @uobj: uverbs obect
   * @caller: caller's build-time module name
 + *
 + * NOTE: for user qp use ib_create_qp_user with valid udata!
   */
 -struct ib_qp *ib_create_qp_user(struct ib_device *dev, struct ib_pd *pd,
 -				struct ib_qp_init_attr *attr,
 -				struct ib_udata *udata,
 -				struct ib_uqp_object *uobj, const char *caller)
 -{
 -	struct ib_qp *qp, *xrc_qp;
 -
 -	if (attr->qp_type == IB_QPT_XRC_TGT)
 -		qp = create_qp(dev, pd, attr, NULL, NULL, caller);
 -	else
 -		qp = create_qp(dev, pd, attr, udata, uobj, NULL);
 -	if (attr->qp_type != IB_QPT_XRC_TGT || IS_ERR(qp))
 -		return qp;
 -
 -	xrc_qp = create_xrc_qp_user(qp, attr);
 -	if (IS_ERR(xrc_qp)) {
 -		ib_destroy_qp(qp);
 -		return xrc_qp;
 -	}
 -
 -	xrc_qp->uobject = uobj;
 -	return xrc_qp;
 -}
 -EXPORT_SYMBOL(ib_create_qp_user);
 -
 -void ib_qp_usecnt_inc(struct ib_qp *qp)
 +struct ib_qp *ib_create_named_qp(struct ib_pd *pd,
 +				 struct ib_qp_init_attr *qp_init_attr,
 +				 const char *caller)
  {
 -	if (qp->pd)
 -		atomic_inc(&qp->pd->usecnt);
 -	if (qp->send_cq)
 -		atomic_inc(&qp->send_cq->usecnt);
 -	if (qp->recv_cq)
 -		atomic_inc(&qp->recv_cq->usecnt);
 -	if (qp->srq)
 -		atomic_inc(&qp->srq->usecnt);
 -	if (qp->rwq_ind_tbl)
 -		atomic_inc(&qp->rwq_ind_tbl->usecnt);
 -}
 -EXPORT_SYMBOL(ib_qp_usecnt_inc);
 -
 -void ib_qp_usecnt_dec(struct ib_qp *qp)
 -{
 -	if (qp->rwq_ind_tbl)
 -		atomic_dec(&qp->rwq_ind_tbl->usecnt);
 -	if (qp->srq)
 -		atomic_dec(&qp->srq->usecnt);
 -	if (qp->recv_cq)
 -		atomic_dec(&qp->recv_cq->usecnt);
 -	if (qp->send_cq)
 -		atomic_dec(&qp->send_cq->usecnt);
 -	if (qp->pd)
 -		atomic_dec(&qp->pd->usecnt);
 -}
 -EXPORT_SYMBOL(ib_qp_usecnt_dec);
 -
 -struct ib_qp *ib_create_qp_kernel(struct ib_pd *pd,
 -				  struct ib_qp_init_attr *qp_init_attr,
 -				  const char *caller)
 -{
 -	struct ib_device *device = pd->device;
 +	struct ib_device *device = pd ? pd->device : qp_init_attr->xrcd->device;
  	struct ib_qp *qp;
  	int ret;
  
@@@ -1223,30 -1346,6 +1292,33 @@@
  	if (IS_ERR(qp))
  		return qp;
  
++<<<<<<< HEAD
 +	ret = ib_create_qp_security(qp, device);
 +	if (ret)
 +		goto err;
 +
 +	if (qp_init_attr->qp_type == IB_QPT_XRC_TGT) {
 +		struct ib_qp *xrc_qp =
 +			create_xrc_qp_user(qp, qp_init_attr);
 +
 +		if (IS_ERR(xrc_qp)) {
 +			ret = PTR_ERR(xrc_qp);
 +			goto err;
 +		}
 +		return xrc_qp;
 +	}
 +
 +	if (qp_init_attr->recv_cq)
 +		atomic_inc(&qp_init_attr->recv_cq->usecnt);
 +	if (qp->srq)
 +		atomic_inc(&qp_init_attr->srq->usecnt);
 +
 +	atomic_inc(&pd->usecnt);
 +	if (qp_init_attr->send_cq)
 +		atomic_inc(&qp_init_attr->send_cq->usecnt);
 +
++=======
++>>>>>>> 7c4a539ec38f (RDMA/core: Fix ib_qp_usecnt_dec() called when error)
  	if (qp_init_attr->cap.max_rdma_ctxs) {
  		ret = rdma_rw_init_mrs(qp, qp_init_attr);
  		if (ret)
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/verbs.c
