NFS: Remove the nfs4_label argument from nfs_setsecurity

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Anna Schumaker <Anna.Schumaker@Netapp.com>
commit dd225cb3b02b827271a2284f89102fc81efcbf6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/dd225cb3.failed

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit dd225cb3b02b827271a2284f89102fc81efcbf6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
diff --cc fs/nfs/inode.c
index f9c9b5107815,dd53704c3f40..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -583,13 -575,11 +581,17 @@@ nfs_fhget(struct super_block *sb, struc
  			 * report the blocks in 512byte units
  			 */
  			inode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);
 -		} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED &&
 -			   fattr->size != 0)
 +		} else if (fattr->size != 0)
  			nfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);
  
++<<<<<<< HEAD
 +		if (nfsi->cache_validity != 0)
 +			nfsi->cache_validity |= NFS_INO_REVAL_FORCED;
 +
 +		nfs_setsecurity(inode, fattr, label);
++=======
+ 		nfs_setsecurity(inode, fattr);
++>>>>>>> dd225cb3b02b (NFS: Remove the nfs4_label argument from nfs_setsecurity)
  
  		nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);
  		nfsi->attrtimeo_timestamp = now;
@@@ -1248,7 -1250,7 +1250,11 @@@ __nfs_revalidate_inode(struct nfs_serve
  	if (nfsi->cache_validity & NFS_INO_INVALID_ACL)
  		nfs_zap_acl_cache(inode);
  
++<<<<<<< HEAD
 +	nfs_setsecurity(inode, fattr, label);
++=======
+ 	nfs_setsecurity(inode, fattr);
++>>>>>>> dd225cb3b02b (NFS: Remove the nfs4_label argument from nfs_setsecurity)
  
  	dfprintk(PAGECACHE, "NFS: (%s/%Lu) revalidation complete\n",
  		inode->i_sb->s_id,
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 146f89918d5d..899a6a0d5eed 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -681,8 +681,7 @@ void nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry,
 			nfs_set_verifier(dentry, dir_verifier);
 			status = nfs_refresh_inode(d_inode(dentry), entry->fattr);
 			if (!status)
-				nfs_setsecurity(d_inode(dentry), entry->fattr,
-						entry->fattr->label);
+				nfs_setsecurity(d_inode(dentry), entry->fattr);
 			goto out;
 		} else {
 			d_invalidate(dentry);
@@ -1522,7 +1521,7 @@ nfs_lookup_revalidate_dentry(struct inode *dir, struct dentry *dentry,
 	if (nfs_refresh_inode(inode, fattr) < 0)
 		goto out;
 
-	nfs_setsecurity(inode, fattr, fattr->label);
+	nfs_setsecurity(inode, fattr);
 	nfs_set_verifier(dentry, dir_verifier);
 
 	/* set a readdirplus hint that we had a cache miss */
diff --git a/fs/nfs/getroot.c b/fs/nfs/getroot.c
index 62da603ef9a7..e3b2f37bbbdf 100644
--- a/fs/nfs/getroot.c
+++ b/fs/nfs/getroot.c
@@ -152,7 +152,7 @@ int nfs_get_root(struct super_block *s, struct fs_context *fc)
 		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
 		server->caps &= ~NFS_CAP_SECURITY_LABEL;
 
-	nfs_setsecurity(inode, fsinfo.fattr, fsinfo.fattr->label);
+	nfs_setsecurity(inode, fsinfo.fattr);
 	error = 0;
 
 out_fattr:
* Unmerged path fs/nfs/inode.c
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 341e1b3bbde5..0f8bea766516 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -3158,8 +3158,7 @@ static int _nfs4_do_open(struct inode *dir,
 			if (status == 0) {
 				nfs_setattr_update_inode(state->inode, sattr,
 						opendata->o_res.f_attr);
-				nfs_setsecurity(state->inode, opendata->o_res.f_attr,
-						opendata->o_res.f_attr->label);
+				nfs_setsecurity(state->inode, opendata->o_res.f_attr);
 			}
 			sattr->ia_valid = ia_old;
 		}
@@ -4236,7 +4235,7 @@ nfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
 	status = nfs4_do_setattr(inode, cred, fattr, sattr, ctx, NULL);
 	if (status == 0) {
 		nfs_setattr_update_inode(inode, sattr, fattr);
-		nfs_setsecurity(inode, fattr, fattr->label);
+		nfs_setsecurity(inode, fattr);
 	}
 	return status;
 }
@@ -4753,7 +4752,7 @@ static int _nfs4_proc_link(struct inode *inode, struct inode *dir, const struct
 				       NFS_INO_INVALID_DATA);
 		status = nfs_post_op_update_inode(inode, res.fattr);
 		if (!status)
-			nfs_setsecurity(inode, res.fattr, res.fattr->label);
+			nfs_setsecurity(inode, res.fattr);
 	}
 
 out:
@@ -6018,7 +6017,7 @@ nfs4_set_security_label(struct inode *inode, const void *buf, size_t buflen)
 
 	status = nfs4_do_set_security_label(inode, &ilabel, fattr);
 	if (status == 0)
-		nfs_setsecurity(inode, fattr, fattr->label);
+		nfs_setsecurity(inode, fattr);
 
 	return status;
 }
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index 1ed12c30a9db..7d6ff965e33b 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -397,8 +397,7 @@ extern int nfs_revalidate_mapping(struct inode *inode, struct address_space *map
 extern int nfs_revalidate_mapping_rcu(struct inode *inode);
 extern int nfs_setattr(struct dentry *, struct iattr *);
 extern void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr, struct nfs_fattr *);
-extern void nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr,
-				struct nfs4_label *label);
+extern void nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr);
 extern struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx);
 extern void put_nfs_open_context(struct nfs_open_context *ctx);
 extern struct nfs_open_context *nfs_find_open_context(struct inode *inode, const struct cred *cred, fmode_t mode);
