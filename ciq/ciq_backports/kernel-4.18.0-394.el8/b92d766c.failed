RDMA/rxe: Save object pointer in pool element

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit b92d766c87022fc82cd6da774010b71ee92fc3d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/b92d766c.failed

In rxe_pool.c currently there are many cases where it is necessary to
compute the offset from a pool element struct to the object containing it
in a type independent way where the offset is different for each type.  By
saving a pointer to the object when they are created extra work can be
saved.

Link: https://lore.kernel.org/r/20211103050241.61293-5-rpearsonhpe@gmail.com
	Signed-off-by: Bob Pearson <rpearsonhpe@gmail.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit b92d766c87022fc82cd6da774010b71ee92fc3d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_pool.c
diff --cc drivers/infiniband/sw/rxe/rxe_pool.c
index cac10e75f06a,276101016848..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.c
+++ b/drivers/infiniband/sw/rxe/rxe_pool.c
@@@ -225,10 -222,11 +225,11 @@@ static int rxe_insert_key(struct rxe_po
  
  	while (*link) {
  		parent = *link;
 -		elem = rb_entry(parent, struct rxe_pool_elem, key_node);
 +		elem = rb_entry(parent, struct rxe_pool_entry, key_node);
  
  		cmp = memcmp((u8 *)elem + pool->key.key_offset,
- 			     (u8 *)new + pool->key.key_offset, pool->key.key_size);
+ 			     (u8 *)new + pool->key.key_offset,
+ 			     pool->key.key_size);
  
  		if (cmp == 0) {
  			pr_warn("key already exists!\n");
@@@ -332,9 -326,8 +333,14 @@@ void __rxe_drop_index(struct rxe_pool_e
  
  void *rxe_alloc_locked(struct rxe_pool *pool)
  {
++<<<<<<< HEAD
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
++=======
+ 	struct rxe_pool_elem *elem;
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
@@@ -343,9 -336,10 +349,14 @@@
  	if (!obj)
  		goto out_cnt;
  
++<<<<<<< HEAD
 +	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
++=======
+ 	elem = (struct rxe_pool_elem *)((u8 *)obj + pool->elem_offset);
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
  	elem->pool = pool;
+ 	elem->obj = obj;
  	kref_init(&elem->ref_cnt);
  
  	return obj;
@@@ -357,9 -351,8 +368,14 @@@ out_cnt
  
  void *rxe_alloc(struct rxe_pool *pool)
  {
++<<<<<<< HEAD
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
++=======
+ 	struct rxe_pool_elem *elem;
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
@@@ -368,9 -361,10 +384,14 @@@
  	if (!obj)
  		goto out_cnt;
  
++<<<<<<< HEAD
 +	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
++=======
+ 	elem = (struct rxe_pool_elem *)((u8 *)obj + pool->elem_offset);
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
  	elem->pool = pool;
+ 	elem->obj = obj;
  	kref_init(&elem->ref_cnt);
  
  	return obj;
@@@ -397,17 -392,16 +419,25 @@@ out_cnt
  
  void rxe_elem_release(struct kref *kref)
  {
 -	struct rxe_pool_elem *elem =
 -		container_of(kref, struct rxe_pool_elem, ref_cnt);
 +	struct rxe_pool_entry *elem =
 +		container_of(kref, struct rxe_pool_entry, ref_cnt);
  	struct rxe_pool *pool = elem->pool;
++<<<<<<< HEAD
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
 +	u8 *obj;
++=======
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
  	if (pool->cleanup)
  		pool->cleanup(elem);
  
  	if (!(pool->flags & RXE_POOL_NO_ALLOC)) {
++<<<<<<< HEAD
 +		obj = (u8 *)elem - info->elem_offset;
++=======
+ 		obj = elem->obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  		kfree(obj);
  	}
  
@@@ -416,10 -410,9 +446,15 @@@
  
  void *rxe_pool_get_index_locked(struct rxe_pool *pool, u32 index)
  {
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
  	struct rb_node *node;
++<<<<<<< HEAD
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
++=======
+ 	struct rxe_pool_elem *elem;
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
  	node = pool->index.tree.rb_node;
  
@@@ -436,7 -429,7 +471,11 @@@
  
  	if (node) {
  		kref_get(&elem->ref_cnt);
++<<<<<<< HEAD
 +		obj = (u8 *)elem - info->elem_offset;
++=======
+ 		obj = elem->obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  	} else {
  		obj = NULL;
  	}
@@@ -446,22 -439,20 +485,31 @@@
  
  void *rxe_pool_get_index(struct rxe_pool *pool, u32 index)
  {
++<<<<<<< HEAD
 +	u8 *obj;
 +	unsigned long flags;
++=======
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
 -	read_lock_bh(&pool->pool_lock);
 +	read_lock_irqsave(&pool->pool_lock, flags);
  	obj = rxe_pool_get_index_locked(pool, index);
 -	read_unlock_bh(&pool->pool_lock);
 +	read_unlock_irqrestore(&pool->pool_lock, flags);
  
  	return obj;
  }
  
  void *rxe_pool_get_key_locked(struct rxe_pool *pool, void *key)
  {
 +	const struct rxe_type_info *info = &rxe_type_info[pool->type];
  	struct rb_node *node;
++<<<<<<< HEAD
 +	struct rxe_pool_entry *elem;
 +	u8 *obj;
++=======
+ 	struct rxe_pool_elem *elem;
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  	int cmp;
  
  	node = pool->key.tree.rb_node;
@@@ -482,7 -473,7 +530,11 @@@
  
  	if (node) {
  		kref_get(&elem->ref_cnt);
++<<<<<<< HEAD
 +		obj = (u8 *)elem - info->elem_offset;
++=======
+ 		obj = elem->obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  	} else {
  		obj = NULL;
  	}
@@@ -492,12 -483,11 +544,16 @@@
  
  void *rxe_pool_get_key(struct rxe_pool *pool, void *key)
  {
++<<<<<<< HEAD
 +	u8 *obj;
 +	unsigned long flags;
++=======
+ 	void *obj;
++>>>>>>> b92d766c8702 (RDMA/rxe: Save object pointer in pool element)
  
 -	read_lock_bh(&pool->pool_lock);
 +	read_lock_irqsave(&pool->pool_lock, flags);
  	obj = rxe_pool_get_key_locked(pool, key);
 -	read_unlock_bh(&pool->pool_lock);
 +	read_unlock_irqrestore(&pool->pool_lock, flags);
  
  	return obj;
  }
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.c
diff --git a/drivers/infiniband/sw/rxe/rxe_pool.h b/drivers/infiniband/sw/rxe/rxe_pool.h
index 8ecd9f870aea..27d721b667dd 100644
--- a/drivers/infiniband/sw/rxe/rxe_pool.h
+++ b/drivers/infiniband/sw/rxe/rxe_pool.h
@@ -34,6 +34,7 @@ struct rxe_pool_entry;
 
 struct rxe_pool_entry {
 	struct rxe_pool		*pool;
+	void			*obj;
 	struct kref		ref_cnt;
 	struct list_head	list;
 
