NFSD: Replace READ* macros that decode the fattr4 acl attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit c941a96823cf52e742606b486b81ab346bf111c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/c941a968.failed

Refactor for clarity and to move infrequently-used code out of line.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit c941a96823cf52e742606b486b81ab346bf111c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index a7f48888e0d0,ac2f25949716..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -394,46 -345,9 +458,52 @@@ nfsd4_decode_fattr(struct nfsd4_compoun
  		iattr->ia_valid |= ATTR_SIZE;
  	}
  	if (bmval[0] & FATTR4_WORD0_ACL) {
++<<<<<<< HEAD
 +		u32 nace;
 +		struct nfs4_ace *ace;
 +
 +		READ_BUF(4);
 +		nace = be32_to_cpup(p++);
 +
 +		if (nace > compoundargs_bytes_left(argp)/20)
 +			/*
 +			 * Even with 4-byte names there wouldn't be
 +			 * space for that many aces; something fishy is
 +			 * going on:
 +			 */
 +			return nfserr_fbig;
 +
 +		*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));
 +		if (*acl == NULL)
 +			return nfserr_jukebox;
 +
 +		(*acl)->naces = nace;
 +		for (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {
 +			READ_BUF(16);
 +			ace->type = be32_to_cpup(p++);
 +			ace->flag = be32_to_cpup(p++);
 +			ace->access_mask = be32_to_cpup(p++);
 +			dummy32 = be32_to_cpup(p++);
 +			READ_BUF(dummy32);
 +			READMEM(buf, dummy32);
 +			ace->whotype = nfs4_acl_get_whotype(buf, dummy32);
 +			status = nfs_ok;
 +			if (ace->whotype != NFS4_ACL_WHO_NAMED)
 +				;
 +			else if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)
 +				status = nfsd_map_name_to_gid(argp->rqstp,
 +						buf, dummy32, &ace->who_gid);
 +			else
 +				status = nfsd_map_name_to_uid(argp->rqstp,
 +						buf, dummy32, &ace->who_uid);
 +			if (status)
 +				return status;
 +		}
++=======
+ 		status = nfsd4_decode_acl(argp, acl);
+ 		if (status)
+ 			return status;
++>>>>>>> c941a96823cf (NFSD: Replace READ* macros that decode the fattr4 acl attribute)
  	} else
  		*acl = NULL;
  	if (bmval[1] & FATTR4_WORD1_MODE) {
* Unmerged path fs/nfsd/nfs4xdr.c
