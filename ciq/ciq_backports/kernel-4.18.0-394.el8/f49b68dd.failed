SUNRPC: xdr_stream_subsegment() must handle non-zero page_bases

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit f49b68ddc9d7dddf1530312108a648dd815a2f30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/f49b68dd.failed

xdr_stream_subsegment() was introduced in commit c1346a1216ab
("NFSD: Replace the internals of the READ_BUF() macro").

There are two call sites for xdr_stream_subsegment(). One is
nfsd4_decode_write(), and the other is nfsd4_decode_setxattr().
Currently neither of these call sites calls this API when
xdr_buf::page_base is a non-zero value.

However, I'm about to add a case where page_base will sometimes not
be zero when nfsd4_decode_write() invokes this API. Replace the
logic in xdr_stream_subsegment() that advances to the next data item
in the xdr_stream with something more generic in order to handle
this new use case.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit f49b68ddc9d7dddf1530312108a648dd815a2f30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xdr.c
diff --cc net/sunrpc/xdr.c
index 0e0145352099,df194cc07035..000000000000
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@@ -1624,6 -1625,53 +1624,56 @@@ int xdr_buf_subsegment(const struct xdr
  EXPORT_SYMBOL_GPL(xdr_buf_subsegment);
  
  /**
++<<<<<<< HEAD
++=======
+  * xdr_stream_subsegment - set @subbuf to a portion of @xdr
+  * @xdr: an xdr_stream set up for decoding
+  * @subbuf: the result buffer
+  * @nbytes: length of @xdr to extract, in bytes
+  *
+  * Sets up @subbuf to represent a portion of @xdr. The portion
+  * starts at the current offset in @xdr, and extends for a length
+  * of @nbytes. If this is successful, @xdr is advanced to the next
+  * XDR data item following that portion.
+  *
+  * Return values:
+  *   %true: @subbuf has been initialized, and @xdr has been advanced.
+  *   %false: a bounds error has occurred
+  */
+ bool xdr_stream_subsegment(struct xdr_stream *xdr, struct xdr_buf *subbuf,
+ 			   unsigned int nbytes)
+ {
+ 	unsigned int start = xdr_stream_pos(xdr);
+ 	unsigned int remaining, len;
+ 
+ 	/* Extract @subbuf and bounds-check the fn arguments */
+ 	if (xdr_buf_subsegment(xdr->buf, subbuf, start, nbytes))
+ 		return false;
+ 
+ 	/* Advance @xdr by @nbytes */
+ 	for (remaining = nbytes; remaining;) {
+ 		if (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))
+ 			return false;
+ 
+ 		len = (char *)xdr->end - (char *)xdr->p;
+ 		if (remaining <= len) {
+ 			xdr->p = (__be32 *)((char *)xdr->p +
+ 					(remaining + xdr_pad_size(nbytes)));
+ 			break;
+ 		}
+ 
+ 		xdr->p = (__be32 *)((char *)xdr->p + len);
+ 		xdr->end = xdr->p;
+ 		remaining -= len;
+ 	}
+ 
+ 	xdr_stream_set_pos(xdr, start + nbytes);
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(xdr_stream_subsegment);
+ 
+ /**
++>>>>>>> f49b68ddc9d7 (SUNRPC: xdr_stream_subsegment() must handle non-zero page_bases)
   * xdr_buf_trim - lop at most "len" bytes off the end of "buf"
   * @buf: buf to be trimmed
   * @len: number of bytes to reduce "buf" by
* Unmerged path net/sunrpc/xdr.c
