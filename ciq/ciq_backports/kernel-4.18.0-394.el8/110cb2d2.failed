NFS: Instrument i_size_write()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 110cb2d2f9326030f13b7ec85d6d482934ea5462
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/110cb2d2.failed

Generate a trace event whenever the NFS client modifies the size of
a file. These new events aid troubleshooting workloads that trigger
races around size updates.

There are four new trace points, all named nfs_size_something so
they are easy to grep for or enable as a group with a single glob.

Size updated on the server:

  kworker/u24:10-194   [010]   369.939174: nfs_size_update:      fileid=00:28:2 fhandle=0x36fbbe51 version=1752899344277980615 cursize=250471 newsize=172083

Server-side size update reported via NFSv3 WCC attributes:

             fsx-1387  [006]   380.760686: nfs_size_wcc:         fileid=00:28:2 fhandle=0x36fbbe51 version=1752899355909932456 cursize=146792 newsize=171216

File has been truncated locally:

             fsx-1387  [007]   369.437421: nfs_size_truncate:    fileid=00:28:2 fhandle=0x36fbbe51 version=1752899231200117272 cursize=215244 newsize=0

File has been extended locally:

             fsx-1387  [007]   369.439213: nfs_size_grow:        fileid=00:28:2 fhandle=0x36fbbe51 version=1752899343704248410 cursize=258048 newsize=262144

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 110cb2d2f9326030f13b7ec85d6d482934ea5462)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfstrace.h
diff --cc fs/nfs/nfstrace.h
index 2f72045b3d3a,44fd016a8e65..000000000000
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@@ -266,21 -231,55 +266,73 @@@ TRACE_EVENT(nfs_access_exit
  		)
  );
  
++<<<<<<< HEAD
 +TRACE_DEFINE_ENUM(LOOKUP_FOLLOW);
 +TRACE_DEFINE_ENUM(LOOKUP_DIRECTORY);
 +TRACE_DEFINE_ENUM(LOOKUP_AUTOMOUNT);
 +TRACE_DEFINE_ENUM(LOOKUP_PARENT);
 +TRACE_DEFINE_ENUM(LOOKUP_REVAL);
 +TRACE_DEFINE_ENUM(LOOKUP_RCU);
 +TRACE_DEFINE_ENUM(LOOKUP_NO_REVAL);
 +TRACE_DEFINE_ENUM(LOOKUP_OPEN);
 +TRACE_DEFINE_ENUM(LOOKUP_CREATE);
 +TRACE_DEFINE_ENUM(LOOKUP_EXCL);
 +TRACE_DEFINE_ENUM(LOOKUP_RENAME_TARGET);
 +TRACE_DEFINE_ENUM(LOOKUP_JUMPED);
 +TRACE_DEFINE_ENUM(LOOKUP_ROOT);
 +TRACE_DEFINE_ENUM(LOOKUP_EMPTY);
 +TRACE_DEFINE_ENUM(LOOKUP_DOWN);
++=======
+ DECLARE_EVENT_CLASS(nfs_update_size_class,
+ 		TP_PROTO(
+ 			const struct inode *inode,
+ 			loff_t new_size
+ 		),
+ 
+ 		TP_ARGS(inode, new_size),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u32, fhandle)
+ 			__field(u64, fileid)
+ 			__field(u64, version)
+ 			__field(loff_t, cur_size)
+ 			__field(loff_t, new_size)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			const struct nfs_inode *nfsi = NFS_I(inode);
+ 
+ 			__entry->dev = inode->i_sb->s_dev;
+ 			__entry->fhandle = nfs_fhandle_hash(&nfsi->fh);
+ 			__entry->fileid = nfsi->fileid;
+ 			__entry->version = inode_peek_iversion_raw(inode);
+ 			__entry->cur_size = i_size_read(inode);
+ 			__entry->new_size = new_size;
+ 		),
+ 
+ 		TP_printk(
+ 			"fileid=%02x:%02x:%llu fhandle=0x%08x version=%llu cursize=%lld newsize=%lld",
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->fileid,
+ 			__entry->fhandle, __entry->version,
+ 			__entry->cur_size, __entry->new_size
+ 		)
+ );
+ 
+ #define DEFINE_NFS_UPDATE_SIZE_EVENT(name) \
+ 	DEFINE_EVENT(nfs_update_size_class, nfs_size_##name, \
+ 			TP_PROTO( \
+ 				const struct inode *inode, \
+ 				loff_t new_size \
+ 			), \
+ 			TP_ARGS(inode, new_size))
+ 
+ DEFINE_NFS_UPDATE_SIZE_EVENT(truncate);
+ DEFINE_NFS_UPDATE_SIZE_EVENT(wcc);
+ DEFINE_NFS_UPDATE_SIZE_EVENT(update);
+ DEFINE_NFS_UPDATE_SIZE_EVENT(grow);
++>>>>>>> 110cb2d2f932 (NFS: Instrument i_size_write())
  
  #define show_lookup_flags(flags) \
  	__print_flags(flags, "|", \
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index a0989d931520..96e722dc2c88 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -678,6 +678,7 @@ static int nfs_vmtruncate(struct inode * inode, loff_t offset)
 	if (err)
 		goto out;
 
+	trace_nfs_size_truncate(inode, offset);
 	i_size_write(inode, offset);
 	/* Optimisation */
 	if (offset == 0)
@@ -1447,6 +1448,7 @@ static void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)
 			&& (fattr->valid & NFS_ATTR_FATTR_SIZE)
 			&& i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size)
 			&& !nfs_have_writebacks(inode)) {
+		trace_nfs_size_wcc(inode, fattr->size);
 		i_size_write(inode, nfs_size_to_loff_t(fattr->size));
 	}
 }
@@ -2100,16 +2102,11 @@ static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)
 			/* Do we perhaps have any outstanding writes, or has
 			 * the file grown beyond our last write? */
 			if (!nfs_have_writebacks(inode) || new_isize > cur_isize) {
+				trace_nfs_size_update(inode, new_isize);
 				i_size_write(inode, new_isize);
 				if (!have_writers)
 					invalid |= NFS_INO_INVALID_DATA;
 			}
-			dprintk("NFS: isize change on server for file %s/%ld "
-					"(%Ld to %Ld)\n",
-					inode->i_sb->s_id,
-					inode->i_ino,
-					(long long)cur_isize,
-					(long long)new_isize);
 		}
 		if (new_isize == 0 &&
 		    !(fattr->valid & (NFS_ATTR_FATTR_SPACE_USED |
* Unmerged path fs/nfs/nfstrace.h
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 175909e01c98..77cd2a230dfb 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -287,6 +287,7 @@ static void nfs_grow_file(struct page *page, unsigned int offset, unsigned int c
 	end = page_file_offset(page) + ((loff_t)offset+count);
 	if (i_size >= end)
 		goto out;
+	trace_nfs_size_grow(inode, end);
 	i_size_write(inode, end);
 	NFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_SIZE;
 	nfs_inc_stats(inode, NFSIOS_EXTENDWRITE);
