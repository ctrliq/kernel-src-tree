eth: fwnode: remove the addr len from mac helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 0a14501ed818ff51eed237bbe5009d0d784e4450
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/0a14501e.failed

All callers pass in ETH_ALEN and the function itself
will return -EINVAL for any other address length.
Just assume it's ETH_ALEN like all other mac address
helpers (nvm, of, platform).

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0a14501ed818ff51eed237bbe5009d0d784e4450)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/apm/xgene-v2/main.c
#	drivers/net/ethernet/apm/xgene/xgene_enet_main.c
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/ethernet/cavium/thunder/thunder_bgx.c
#	drivers/net/ethernet/faraday/ftgmac100.c
#	drivers/net/ethernet/hisilicon/hns/hns_enet.c
#	drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
#	drivers/net/ethernet/microchip/enc28j60.c
#	drivers/net/ethernet/qualcomm/emac/emac.c
#	drivers/net/ethernet/socionext/netsec.c
#	include/linux/etherdevice.h
#	net/ethernet/eth.c
diff --cc drivers/net/ethernet/apm/xgene-v2/main.c
index 44f8d4e82751,d1ebd153b7a8..000000000000
--- a/drivers/net/ethernet/apm/xgene-v2/main.c
+++ b/drivers/net/ethernet/apm/xgene-v2/main.c
@@@ -48,7 -36,7 +48,11 @@@ static int xge_get_resources(struct xge
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	if (!device_get_mac_address(dev, ndev->dev_addr, ETH_ALEN))
++=======
+ 	if (device_get_mac_address(dev, ndev->dev_addr))
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		eth_hw_addr_random(ndev);
  
  	memcpy(ndev->perm_addr, ndev->dev_addr, ndev->addr_len);
diff --cc drivers/net/ethernet/apm/xgene/xgene_enet_main.c
index c98730df10e8,4a5bf13ffae2..000000000000
--- a/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
@@@ -1748,7 -1731,7 +1748,11 @@@ static int xgene_enet_get_resources(str
  		xgene_get_port_id_acpi(dev, pdata);
  #endif
  
++<<<<<<< HEAD
 +	if (!device_get_mac_address(dev, ndev->dev_addr, ETH_ALEN))
++=======
+ 	if (device_get_mac_address(dev, ndev->dev_addr))
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		eth_hw_addr_random(ndev);
  
  	memcpy(ndev->perm_addr, ndev->dev_addr, ndev->addr_len);
diff --cc drivers/net/ethernet/broadcom/genet/bcmgenet.c
index 116c5aeea2f7,e61b687d33ba..000000000000
--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
@@@ -3559,10 -4078,21 +3559,25 @@@ static int bcmgenet_probe(struct platfo
  	/* If this is an internal GPHY, power it on now, before UniMAC is
  	 * brought out of reset as absolutely no UniMAC activity is allowed
  	 */
 -	if (device_get_phy_mode(&pdev->dev) == PHY_INTERFACE_MODE_INTERNAL)
 +	if (dn && !of_property_read_string(dn, "phy-mode", &phy_mode_str) &&
 +	    !strcasecmp(phy_mode_str, "internal"))
  		bcmgenet_power_up(priv, GENET_POWER_PASSIVE);
  
++<<<<<<< HEAD
++=======
+ 	if (pd && !IS_ERR_OR_NULL(pd->mac_address))
+ 		eth_hw_addr_set(dev, pd->mac_address);
+ 	else
+ 		if (device_get_mac_address(&pdev->dev, dev->dev_addr))
+ 			if (has_acpi_companion(&pdev->dev))
+ 				bcmgenet_get_hw_addr(priv, dev->dev_addr);
+ 
+ 	if (!is_valid_ether_addr(dev->dev_addr)) {
+ 		dev_warn(&pdev->dev, "using random Ethernet MAC\n");
+ 		eth_hw_addr_random(dev);
+ 	}
+ 
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  	reset_umac(priv);
  
  	err = bcmgenet_mii_init(dev);
diff --cc drivers/net/ethernet/cavium/thunder/thunder_bgx.c
index 4f48cbdcf77f,574a32f23f96..000000000000
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
@@@ -1384,10 -1387,10 +1384,15 @@@ static int acpi_get_mac_address(struct 
  				u8 *dst)
  {
  	u8 mac[ETH_ALEN];
 -	int ret;
 +	u8 *addr;
  
++<<<<<<< HEAD
 +	addr = fwnode_get_mac_address(acpi_fwnode_handle(adev), mac, ETH_ALEN);
 +	if (!addr) {
++=======
+ 	ret = fwnode_get_mac_address(acpi_fwnode_handle(adev), mac);
+ 	if (ret) {
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		dev_err(dev, "MAC address invalid: %pM\n", mac);
  		return -EINVAL;
  	}
diff --cc drivers/net/ethernet/faraday/ftgmac100.c
index e4431a01ea29,86c2986395de..000000000000
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@@ -192,11 -182,9 +192,16 @@@ static void ftgmac100_initial_mac(struc
  	u8 mac[ETH_ALEN];
  	unsigned int m;
  	unsigned int l;
 +	void *addr;
  
++<<<<<<< HEAD
 +	addr = device_get_mac_address(priv->dev, mac, ETH_ALEN);
 +	if (addr) {
 +		ether_addr_copy(priv->netdev->dev_addr, mac);
++=======
+ 	if (!device_get_mac_address(priv->dev, mac)) {
+ 		eth_hw_addr_set(priv->netdev, mac);
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		dev_info(priv->dev, "Read MAC address %pM from device tree\n",
  			 mac);
  		return;
diff --cc drivers/net/ethernet/hisilicon/hns/hns_enet.c
index 735a7886d902,1195f64fb161..000000000000
--- a/drivers/net/ethernet/hisilicon/hns/hns_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_enet.c
@@@ -1233,7 -1212,7 +1233,11 @@@ static void hns_init_mac_addr(struct ne
  {
  	struct hns_nic_priv *priv = netdev_priv(ndev);
  
++<<<<<<< HEAD
 +	if (!device_get_mac_address(priv->dev, ndev->dev_addr, ETH_ALEN)) {
++=======
+ 	if (device_get_mac_address(priv->dev, ndev->dev_addr)) {
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		eth_hw_addr_random(ndev);
  		dev_warn(priv->dev, "No valid mac, use random mac %pM",
  			 ndev->dev_addr);
diff --cc drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index 9638dce58ba2,ad3be55cce68..000000000000
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@@ -4140,9 -6081,9 +4140,13 @@@ static void mvpp2_port_copy_mac_addr(st
  	char hw_mac_addr[ETH_ALEN] = {0};
  	char fw_mac_addr[ETH_ALEN];
  
++<<<<<<< HEAD
 +	if (fwnode_get_mac_address(fwnode, fw_mac_addr, ETH_ALEN)) {
++=======
+ 	if (!fwnode_get_mac_address(fwnode, fw_mac_addr)) {
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		*mac_from = "firmware node";
 -		eth_hw_addr_set(dev, fw_mac_addr);
 +		ether_addr_copy(dev->dev_addr, fw_mac_addr);
  		return;
  	}
  
diff --cc drivers/net/ethernet/microchip/enc28j60.c
index a0923585e1c4,cca8aa70cfc9..000000000000
--- a/drivers/net/ethernet/microchip/enc28j60.c
+++ b/drivers/net/ethernet/microchip/enc28j60.c
@@@ -1586,10 -1572,10 +1586,16 @@@ static int enc28j60_probe(struct spi_de
  		goto error_irq;
  	}
  
++<<<<<<< HEAD
 +	ret = of_get_mac_address(spi->dev.of_node, dev->dev_addr);
 +	if (ret)
++=======
+ 	if (!device_get_mac_address(&spi->dev, macaddr))
+ 		eth_hw_addr_set(dev, macaddr);
+ 	else
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  		eth_hw_addr_random(dev);
 +
  	enc28j60_set_hw_macaddr(dev);
  
  	/* Board setup must set the relevant edge trigger type;
diff --cc drivers/net/ethernet/qualcomm/emac/emac.c
index 36f4564d0b72,b1b324f45fe7..000000000000
--- a/drivers/net/ethernet/qualcomm/emac/emac.c
+++ b/drivers/net/ethernet/qualcomm/emac/emac.c
@@@ -557,8 -549,8 +557,13 @@@ static int emac_probe_resources(struct 
  	int ret = 0;
  
  	/* get mac address */
++<<<<<<< HEAD
 +	if (device_get_mac_address(&pdev->dev, maddr, ETH_ALEN))
 +		ether_addr_copy(netdev->dev_addr, maddr);
++=======
+ 	if (!device_get_mac_address(&pdev->dev, maddr))
+ 		eth_hw_addr_set(netdev, maddr);
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  	else
  		eth_hw_addr_random(netdev);
  
diff --cc drivers/net/ethernet/socionext/netsec.c
index 63c23f878c12,7e3dd07ac94e..000000000000
--- a/drivers/net/ethernet/socionext/netsec.c
+++ b/drivers/net/ethernet/socionext/netsec.c
@@@ -1609,12 -2034,12 +1609,18 @@@ static int netsec_probe(struct platform
  		goto free_ndev;
  	}
  
++<<<<<<< HEAD
 +	mac = device_get_mac_address(&pdev->dev, macbuf, sizeof(macbuf));
 +	if (mac)
 +		ether_addr_copy(ndev->dev_addr, mac);
++=======
+ 	ret = device_get_mac_address(&pdev->dev, macbuf);
+ 	if (!ret)
+ 		eth_hw_addr_set(ndev, macbuf);
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  
  	if (priv->eeprom_base &&
 -	    (ret || !is_valid_ether_addr(ndev->dev_addr))) {
 +	    (!mac || !is_valid_ether_addr(ndev->dev_addr))) {
  		void __iomem *macp = priv->eeprom_base +
  					NETSEC_EEPROM_MAC_ADDRESS;
  
diff --cc include/linux/etherdevice.h
index d76c6b361d63,bb612c7382e3..000000000000
--- a/include/linux/etherdevice.h
+++ b/include/linux/etherdevice.h
@@@ -31,9 -26,15 +31,17 @@@
  
  #ifdef __KERNEL__
  struct device;
 -struct fwnode_handle;
 -
  int eth_platform_get_mac_address(struct device *dev, u8 *mac_addr);
  unsigned char *arch_get_platform_mac_address(void);
++<<<<<<< HEAD
 +u32 eth_get_headlen(const struct net_device *dev, void *data, unsigned int len);
++=======
+ int nvmem_get_mac_address(struct device *dev, void *addrbuf);
+ int device_get_mac_address(struct device *dev, char *addr);
+ int fwnode_get_mac_address(struct fwnode_handle *fwnode, char *addr);
+ 
+ u32 eth_get_headlen(const struct net_device *dev, const void *data, u32 len);
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
  __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev);
  extern const struct header_ops eth_header_ops;
  
diff --cc net/ethernet/eth.c
index 7856f07680f6,29447a61d3ec..000000000000
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@@ -558,3 -522,98 +558,101 @@@ int eth_platform_get_mac_address(struc
  	return 0;
  }
  EXPORT_SYMBOL(eth_platform_get_mac_address);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * nvmem_get_mac_address - Obtain the MAC address from an nvmem cell named
+  * 'mac-address' associated with given device.
+  *
+  * @dev:	Device with which the mac-address cell is associated.
+  * @addrbuf:	Buffer to which the MAC address will be copied on success.
+  *
+  * Returns 0 on success or a negative error number on failure.
+  */
+ int nvmem_get_mac_address(struct device *dev, void *addrbuf)
+ {
+ 	struct nvmem_cell *cell;
+ 	const void *mac;
+ 	size_t len;
+ 
+ 	cell = nvmem_cell_get(dev, "mac-address");
+ 	if (IS_ERR(cell))
+ 		return PTR_ERR(cell);
+ 
+ 	mac = nvmem_cell_read(cell, &len);
+ 	nvmem_cell_put(cell);
+ 
+ 	if (IS_ERR(mac))
+ 		return PTR_ERR(mac);
+ 
+ 	if (len != ETH_ALEN || !is_valid_ether_addr(mac)) {
+ 		kfree(mac);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ether_addr_copy(addrbuf, mac);
+ 	kfree(mac);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(nvmem_get_mac_address);
+ 
+ static int fwnode_get_mac_addr(struct fwnode_handle *fwnode,
+ 			       const char *name, char *addr)
+ {
+ 	int ret;
+ 
+ 	ret = fwnode_property_read_u8_array(fwnode, name, addr, ETH_ALEN);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!is_valid_ether_addr(addr))
+ 		return -EINVAL;
+ 	return 0;
+ }
+ 
+ /**
+  * fwnode_get_mac_address - Get the MAC from the firmware node
+  * @fwnode:	Pointer to the firmware node
+  * @addr:	Address of buffer to store the MAC in
+  *
+  * Search the firmware node for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+  * address. If that isn't set, then 'local-mac-address' is checked next,
+  * because that is the default address.  If that isn't set, then the obsolete
+  * 'address' is checked, just in case we're using an old device tree.
+  *
+  * Note that the 'address' property is supposed to contain a virtual address of
+  * the register set, but some DTS files have redefined that property to be the
+  * MAC address.
+  *
+  * All-zero MAC addresses are rejected, because those could be properties that
+  * exist in the firmware tables, but were not updated by the firmware.  For
+  * example, the DTS could define 'mac-address' and 'local-mac-address', with
+  * zero MAC addresses.  Some older U-Boots only initialized 'local-mac-address'.
+  * In this case, the real MAC is in 'local-mac-address', and 'mac-address'
+  * exists but is all zeros.
+  */
+ int fwnode_get_mac_address(struct fwnode_handle *fwnode, char *addr)
+ {
+ 	if (!fwnode_get_mac_addr(fwnode, "mac-address", addr) ||
+ 	    !fwnode_get_mac_addr(fwnode, "local-mac-address", addr) ||
+ 	    !fwnode_get_mac_addr(fwnode, "address", addr))
+ 		return 0;
+ 
+ 	return -ENOENT;
+ }
+ EXPORT_SYMBOL(fwnode_get_mac_address);
+ 
+ /**
+  * device_get_mac_address - Get the MAC for a given device
+  * @dev:	Pointer to the device
+  * @addr:	Address of buffer to store the MAC in
+  */
+ int device_get_mac_address(struct device *dev, char *addr)
+ {
+ 	return fwnode_get_mac_address(dev_fwnode(dev), addr);
+ }
+ EXPORT_SYMBOL(device_get_mac_address);
++>>>>>>> 0a14501ed818 (eth: fwnode: remove the addr len from mac helpers)
* Unmerged path drivers/net/ethernet/apm/xgene-v2/main.c
* Unmerged path drivers/net/ethernet/apm/xgene/xgene_enet_main.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/cavium/thunder/thunder_bgx.c
* Unmerged path drivers/net/ethernet/faraday/ftgmac100.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_enet.c
* Unmerged path drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
* Unmerged path drivers/net/ethernet/microchip/enc28j60.c
* Unmerged path drivers/net/ethernet/qualcomm/emac/emac.c
diff --git a/drivers/net/ethernet/smsc/smsc911x.c b/drivers/net/ethernet/smsc/smsc911x.c
index c009407618d9..98a1e6be8571 100644
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@ -2391,7 +2391,7 @@ static int smsc911x_probe_config(struct smsc911x_platform_config *config,
 		phy_interface = PHY_INTERFACE_MODE_NA;
 	config->phy_interface = phy_interface;
 
-	device_get_mac_address(dev, config->mac, ETH_ALEN);
+	device_get_mac_address(dev, config->mac);
 
 	err = device_property_read_u32(dev, "reg-io-width", &width);
 	if (err == -ENXIO)
* Unmerged path drivers/net/ethernet/socionext/netsec.c
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index a750b1560a00..3619b962e3c0 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -3248,7 +3248,7 @@ static int ath10k_core_probe_fw(struct ath10k *ar)
 		ath10k_debug_print_board_info(ar);
 	}
 
-	device_get_mac_address(ar->dev, ar->mac_addr, sizeof(ar->mac_addr));
+	device_get_mac_address(ar->dev, ar->mac_addr);
 
 	ret = ath10k_core_init_firmware_features(ar);
 	if (ret) {
* Unmerged path include/linux/etherdevice.h
* Unmerged path net/ethernet/eth.c
