NFSD: Replace READ* macros in nfsd4_decode_bind_conn_to_session()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 571e0451c4de0a545960ffaea16d969931afc563
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/571e0451.failed

A dedicated sessionid4 decoder is introduced that will be used by
other operation decoders in subsequent patches.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 571e0451c4de0a545960ffaea16d969931afc563)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index a7c80f4dce78,a35075e7900a..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -612,18 -664,96 +612,38 @@@ nfsd4_decode_state_owner4(struct nfsd4_
  	return nfsd4_decode_opaque(argp, owner);
  }
  
++<<<<<<< HEAD
 +static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
++=======
+ static __be32
+ nfsd4_decode_sessionid4(struct nfsd4_compoundargs *argp,
+ 			struct nfs4_sessionid *sessionid)
+ {
+ 	__be32 *p;
+ 
+ 	p = xdr_inline_decode(argp->xdr, NFS4_MAX_SESSIONID_LEN);
+ 	if (!p)
+ 		return nfserr_bad_xdr;
+ 	memcpy(sessionid->data, p, sizeof(sessionid->data));
+ 	return nfs_ok;
+ }
+ 
+ /* Defined in Appendix A of RFC 5531 */
+ static __be32
+ nfsd4_decode_authsys_parms(struct nfsd4_compoundargs *argp,
+ 			   struct nfsd4_cb_sec *cbs)
++>>>>>>> 571e0451c4de (NFSD: Replace READ* macros in nfsd4_decode_bind_conn_to_session())
  {
 -	u32 stamp, gidcount, uid, gid;
 -	__be32 *p, status;
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &stamp) < 0)
 -		return nfserr_bad_xdr;
 -	/* machine name */
 -	status = nfsd4_decode_ignored_string(argp, 255);
 -	if (status)
 -		return status;
 -	if (xdr_stream_decode_u32(argp->xdr, &uid) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &gid) < 0)
 -		return nfserr_bad_xdr;
 -	if (xdr_stream_decode_u32(argp->xdr, &gidcount) < 0)
 -		return nfserr_bad_xdr;
 -	if (gidcount > 16)
 -		return nfserr_bad_xdr;
 -	p = xdr_inline_decode(argp->xdr, gidcount << 2);
 -	if (!p)
 -		return nfserr_bad_xdr;
 -	if (cbs->flavor == (u32)(-1)) {
 -		struct user_namespace *userns = nfsd_user_namespace(argp->rqstp);
 -
 -		kuid_t kuid = make_kuid(userns, uid);
 -		kgid_t kgid = make_kgid(userns, gid);
 -		if (uid_valid(kuid) && gid_valid(kgid)) {
 -			cbs->uid = kuid;
 -			cbs->gid = kgid;
 -			cbs->flavor = RPC_AUTH_UNIX;
 -		} else {
 -			dprintk("RPC_AUTH_UNIX with invalid uid or gid, ignoring!\n");
 -		}
 -	}
 -
 -	return nfs_ok;
 -}
 -
 -static __be32
 -nfsd4_decode_gss_cb_handles4(struct nfsd4_compoundargs *argp,
 -			     struct nfsd4_cb_sec *cbs)
 -{
 -	__be32 status;
 -	u32 service;
 -
 -	dprintk("RPC_AUTH_GSS callback secflavor not supported!\n");
 -
 -	if (xdr_stream_decode_u32(argp->xdr, &service) < 0)
 -		return nfserr_bad_xdr;
 -	if (service < RPC_GSS_SVC_NONE || service > RPC_GSS_SVC_PRIVACY)
 -		return nfserr_bad_xdr;
 -	/* gcbp_handle_from_server */
 -	status = nfsd4_decode_ignored_string(argp, 0);
 -	if (status)
 -		return status;
 -	/* gcbp_handle_from_client */
 -	status = nfsd4_decode_ignored_string(argp, 0);
 -	if (status)
 -		return status;
 -
 -	return nfs_ok;
 -}
 -
 -/* a counted array of callback_sec_parms4 items */
 -static __be32
 -nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
 -{
 -	u32 i, secflavor, nr_secflavs;
 -	__be32 status;
 +	DECODE_HEAD;
 +	struct user_namespace *userns = nfsd_user_namespace(argp->rqstp);
 +	u32 dummy, uid, gid;
 +	char *machine_name;
 +	int i;
 +	int nr_secflavs;
  
  	/* callback_sec_params4 */
 -	if (xdr_stream_decode_u32(argp->xdr, &nr_secflavs) < 0)
 -		return nfserr_bad_xdr;
 +	READ_BUF(4);
 +	nr_secflavs = be32_to_cpup(p++);
  	if (nr_secflavs)
  		cbs->flavor = (u32)(-1);
  	else
* Unmerged path fs/nfsd/nfs4xdr.c
