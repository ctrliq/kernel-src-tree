tracing/osnoise: Support a list of trace_array *tr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Daniel Bristot de Oliveira <bristot@kernel.org>
commit dae181349f1e9d279f171afc708d2824ab35a86f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/dae18134.failed

osnoise/timerlat were built to run a single instance, and for this,
a single variable is enough to store the current struct trace_array
*tr with information about the tracing instance. This is done via
the *osnoise_trace variable. A trace_array represents a trace instance.

In preparation to support multiple instances, replace the
*osnoise_trace variable with an RCU protected list of instances.

The operations that refer to an instance now propagate to all
elements of the list (all instances).

Also, replace the osnoise_busy variable with a check if the list
has elements (busy).

No functional change is expected with this patch, i.e., only one
instance is allowed yet.

Link: https://lkml.kernel.org/r/91d006e889b9a5d1ff258fe6077f021ae3f26372.1635702894.git.bristot@kernel.org

	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Tom Zanussi <zanussi@kernel.org>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Juri Lelli <juri.lelli@redhat.com>
	Cc: Clark Williams <williams@redhat.com>
	Cc: John Kacur <jkacur@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Cc: Daniel Bristot de Oliveira <bristot@kernel.org>
	Cc: linux-rt-users@vger.kernel.org
	Cc: linux-trace-devel@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Daniel Bristot de Oliveira <bristot@kernel.org>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit dae181349f1e9d279f171afc708d2824ab35a86f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_osnoise.c
diff --cc kernel/trace/trace_osnoise.c
index 60adf8c7f9ff,490615f6d721..000000000000
--- a/kernel/trace/trace_osnoise.c
+++ b/kernel/trace/trace_osnoise.c
@@@ -393,24 -477,15 +482,20 @@@ static void print_timerlat_headers(stru
  }
  #endif /* CONFIG_PREEMPT_RT */
  
- /*
-  * Record an timerlat_sample into the tracer buffer.
-  */
- static void trace_timerlat_sample(struct timerlat_sample *sample)
+ static void
+ __trace_timerlat_sample(struct timerlat_sample *sample, struct trace_buffer *buffer)
  {
- 	struct trace_array *tr = osnoise_trace;
  	struct trace_event_call *call = &event_osnoise;
- 	struct trace_buffer *buffer = tr->array_buffer.buffer;
  	struct ring_buffer_event *event;
  	struct timerlat_entry *entry;
 +	unsigned long flags;
 +	int pc;
 +
 +	pc = preempt_count();
 +	local_save_flags(flags);
  
  	event = trace_buffer_lock_reserve(buffer, TRACE_TIMERLAT, sizeof(*entry),
 -					  tracing_gen_ctx());
 +					  flags, pc);
  	if (!event)
  		return;
  	entry	= ring_buffer_event_data(event);
@@@ -461,34 -552,18 +562,31 @@@ static void timerlat_save_stack(int ski
  	return;
  
  }
- /*
-  * timerlat_dump_stack - dump a stack trace previously saved
-  *
-  * Dump a saved stack trace into the trace buffer.
-  */
- static void timerlat_dump_stack(void)
+ 
+ static void
+ __timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)
  {
  	struct trace_event_call *call = &event_osnoise;
- 	struct trace_array *tr = osnoise_trace;
- 	struct trace_buffer *buffer = tr->array_buffer.buffer;
  	struct ring_buffer_event *event;
- 	struct trace_stack *fstack;
  	struct stack_entry *entry;
++<<<<<<< HEAD
 +	unsigned int size;
 +	unsigned long flags;
 +	int pc;
 +
 +	preempt_disable_notrace();
 +	fstack = this_cpu_ptr(&trace_stack);
 +	size = fstack->stack_size;
++=======
++>>>>>>> dae181349f1e (tracing/osnoise: Support a list of trace_array *tr)
 +
 +	pc = preempt_count();
 +	local_save_flags(flags);
  
  	event = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,
 -					  tracing_gen_ctx());
 +					  flags, pc);
  	if (!event)
- 		goto out;
+ 		return;
  
  	entry = ring_buffer_event_data(event);
  
@@@ -1247,9 -1367,7 +1390,13 @@@ static int run_osnoise(void
  
  	trace_osnoise_sample(&s);
  
++<<<<<<< HEAD
 +	/* Keep a running maximum ever recorded osnoise "latency" */
 +	if (max_noise > tr->max_latency)
 +		tr->max_latency = max_noise;
++=======
+ 	notify_new_max_latency(max_noise);
++>>>>>>> dae181349f1e (tracing/osnoise: Support a list of trace_array *tr)
  
  	if (osnoise_data.stop_tracing_total)
  		if (s.noise > osnoise_data.stop_tracing_total)
@@@ -1378,9 -1495,7 +1524,13 @@@ static enum hrtimer_restart timerlat_ir
  
  	trace_timerlat_sample(&s);
  
++<<<<<<< HEAD
 +	/* Keep a running maximum ever recorded os noise "latency" */
 +	if (diff > tr->max_latency)
 +		tr->max_latency = diff;
++=======
+ 	notify_new_max_latency(diff);
++>>>>>>> dae181349f1e (tracing/osnoise: Support a list of trace_array *tr)
  
  	if (osnoise_data.stop_tracing)
  		if (time_to_us(diff) >= osnoise_data.stop_tracing)
* Unmerged path kernel/trace/trace_osnoise.c
