NFSD: Replace READ* macros in nfsd4_decode_copy()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit e8febea7190bcbd1e608093acb67f2a5009556aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/e8febea7.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit e8febea7190bcbd1e608093acb67f2a5009556aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index d9370e90652b,42b5e8392f47..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -1788,24 -1941,95 +1788,68 @@@ nfsd4_decode_clone(struct nfsd4_compoun
  static __be32
  nfsd4_decode_copy(struct nfsd4_compoundargs *argp, struct nfsd4_copy *copy)
  {
++<<<<<<< HEAD
 +	DECODE_HEAD;
++=======
+ 	struct nl4_server *ns_dummy;
+ 	u32 consecutive, i, count;
+ 	__be32 status;
++>>>>>>> e8febea7190b (NFSD: Replace READ* macros in nfsd4_decode_copy())
  
- 	status = nfsd4_decode_stateid(argp, &copy->cp_src_stateid);
+ 	status = nfsd4_decode_stateid4(argp, &copy->cp_src_stateid);
  	if (status)
  		return status;
- 	status = nfsd4_decode_stateid(argp, &copy->cp_dst_stateid);
+ 	status = nfsd4_decode_stateid4(argp, &copy->cp_dst_stateid);
  	if (status)
  		return status;
+ 	if (xdr_stream_decode_u64(argp->xdr, &copy->cp_src_pos) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u64(argp->xdr, &copy->cp_dst_pos) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u64(argp->xdr, &copy->cp_count) < 0)
+ 		return nfserr_bad_xdr;
+ 	/* ca_consecutive: we always do consecutive copies */
+ 	if (xdr_stream_decode_u32(argp->xdr, &consecutive) < 0)
+ 		return nfserr_bad_xdr;
+ 	if (xdr_stream_decode_u32(argp->xdr, &copy->cp_synchronous) < 0)
+ 		return nfserr_bad_xdr;
  
++<<<<<<< HEAD
 +	READ_BUF(8 + 8 + 8 + 4 + 4 + 4);
 +	p = xdr_decode_hyper(p, &copy->cp_src_pos);
 +	p = xdr_decode_hyper(p, &copy->cp_dst_pos);
 +	p = xdr_decode_hyper(p, &copy->cp_count);
 +	p++; /* ca_consecutive: we always do consecutive copies */
 +	copy->cp_synchronous = be32_to_cpup(p++);
 +	/* tmp = be32_to_cpup(p); Source server list not supported */
++=======
+ 	if (xdr_stream_decode_u32(argp->xdr, &count) < 0)
+ 		return nfserr_bad_xdr;
+ 	copy->cp_intra = false;
+ 	if (count == 0) { /* intra-server copy */
+ 		copy->cp_intra = true;
+ 		return nfs_ok;
+ 	}
  
- 	DECODE_TAIL;
+ 	/* decode all the supplied server addresses but use only the first */
+ 	status = nfsd4_decode_nl4_server(argp, &copy->cp_src);
+ 	if (status)
+ 		return status;
+ 
+ 	ns_dummy = kmalloc(sizeof(struct nl4_server), GFP_KERNEL);
+ 	if (ns_dummy == NULL)
+ 		return nfserrno(-ENOMEM);	/* XXX: jukebox? */
+ 	for (i = 0; i < count - 1; i++) {
+ 		status = nfsd4_decode_nl4_server(argp, ns_dummy);
+ 		if (status) {
+ 			kfree(ns_dummy);
+ 			return status;
+ 		}
+ 	}
+ 	kfree(ns_dummy);
++>>>>>>> e8febea7190b (NFSD: Replace READ* macros in nfsd4_decode_copy())
+ 
+ 	return nfs_ok;
  }
  
  static __be32
* Unmerged path fs/nfsd/nfs4xdr.c
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index dee632ecc00d..8bf037bee67c 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -547,7 +547,7 @@ struct nfsd4_copy {
 	u64		cp_count;
 
 	/* both */
-	bool		cp_synchronous;
+	u32			cp_synchronous;
 
 	/* response */
 	struct nfsd42_write_res	cp_res;
