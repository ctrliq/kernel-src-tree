arm64: initialize and switch ptrauth kernel keys

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-394.el8
commit-author Kristina Martsenko <kristina.martsenko@arm.com>
commit 33e45234987ea3ed4b05fc512f4441696478f12d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-394.el8/33e45234.failed

Set up keys to use pointer authentication within the kernel. The kernel
will be compiled with APIAKey instructions, the other keys are currently
unused. Each task is given its own APIAKey, which is initialized during
fork. The key is changed during context switch and on kernel entry from
EL0.

The keys for idle threads need to be set before calling any C functions,
because it is not possible to enter and exit a function with different
keys.

	Reviewed-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
	Reviewed-by: Vincenzo Frascino <Vincenzo.Frascino@arm.com>
	Signed-off-by: Kristina Martsenko <kristina.martsenko@arm.com>
[Amit: Modified secondary cores key structure, comments]
	Signed-off-by: Amit Daniel Kachhap <amit.kachhap@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 33e45234987ea3ed4b05fc512f4441696478f12d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/asm_pointer_auth.h
#	arch/arm64/include/asm/pointer_auth.h
#	arch/arm64/kernel/asm-offsets.c
#	arch/arm64/kernel/entry.S
#	arch/arm64/mm/proc.S
diff --cc arch/arm64/include/asm/pointer_auth.h
index 1e1215eb8d01,aa956ca5f2c2..000000000000
--- a/arch/arm64/include/asm/pointer_auth.h
+++ b/arch/arm64/include/asm/pointer_auth.h
@@@ -50,17 -54,10 +54,24 @@@ do {								
  	write_sysreg_s(__pki_v.hi, SYS_ ## k ## KEYHI_EL1);	\
  } while (0)
  
++<<<<<<< HEAD
 +static inline void ptrauth_keys_switch_user(struct ptrauth_keys_user *keys)
 +{
 +	if (system_supports_address_auth()) {
 +		__ptrauth_key_install(APIA, keys->apia);
 +		__ptrauth_key_install(APIB, keys->apib);
 +		__ptrauth_key_install(APDA, keys->apda);
 +		__ptrauth_key_install(APDB, keys->apdb);
 +	}
 +
 +	if (system_supports_generic_auth())
 +		__ptrauth_key_install(APGA, keys->apga);
++=======
+ static inline void ptrauth_keys_init_kernel(struct ptrauth_keys_kernel *keys)
+ {
+ 	if (system_supports_address_auth())
+ 		get_random_bytes(&keys->apia, sizeof(keys->apia));
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
  }
  
  extern int ptrauth_prctl_reset_keys(struct task_struct *tsk, unsigned long arg);
@@@ -78,20 -75,15 +89,30 @@@ static inline unsigned long ptrauth_str
  }
  
  #define ptrauth_thread_init_user(tsk)					\
++<<<<<<< HEAD
 +do {									\
 +	struct task_struct *__ptiu_tsk = (tsk);				\
 +	ptrauth_keys_init_user(&__ptiu_tsk->thread.keys_user);		\
 +	ptrauth_keys_switch_user(&__ptiu_tsk->thread.keys_user);		\
 +} while (0)
 +
 +#define ptrauth_thread_switch(tsk)	\
 +	ptrauth_keys_switch_user(&(tsk)->thread.keys_user)
++=======
+ 	ptrauth_keys_init_user(&(tsk)->thread.keys_user)
+ #define ptrauth_thread_init_kernel(tsk)					\
+ 	ptrauth_keys_init_kernel(&(tsk)->thread.keys_kernel)
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
  
  #else /* CONFIG_ARM64_PTR_AUTH */
  #define ptrauth_prctl_reset_keys(tsk, arg)	(-EINVAL)
  #define ptrauth_strip_insn_pac(lr)	(lr)
  #define ptrauth_thread_init_user(tsk)
++<<<<<<< HEAD
 +#define ptrauth_thread_switch(tsk)
++=======
+ #define ptrauth_thread_init_kernel(tsk)
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
  #endif /* CONFIG_ARM64_PTR_AUTH */
  
  #endif /* __ASM_POINTER_AUTH_H */
diff --cc arch/arm64/kernel/asm-offsets.c
index 513e9a22c07a,9981a0a5a87f..000000000000
--- a/arch/arm64/kernel/asm-offsets.c
+++ b/arch/arm64/kernel/asm-offsets.c
@@@ -51,6 -40,10 +51,13 @@@ int main(void
  #endif
    BLANK();
    DEFINE(THREAD_CPU_CONTEXT,	offsetof(struct task_struct, thread.cpu_context));
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_PTR_AUTH
+   DEFINE(THREAD_KEYS_USER,	offsetof(struct task_struct, thread.keys_user));
+   DEFINE(THREAD_KEYS_KERNEL,	offsetof(struct task_struct, thread.keys_kernel));
+ #endif
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
    BLANK();
    DEFINE(S_X0,			offsetof(struct pt_regs, regs[0]));
    DEFINE(S_X2,			offsetof(struct pt_regs, regs[2]));
@@@ -98,8 -92,11 +105,11 @@@
    BLANK();
    DEFINE(CPU_BOOT_STACK,	offsetof(struct secondary_data, stack));
    DEFINE(CPU_BOOT_TASK,		offsetof(struct secondary_data, task));
+ #ifdef CONFIG_ARM64_PTR_AUTH
+   DEFINE(CPU_BOOT_PTRAUTH_KEY,	offsetof(struct secondary_data, ptrauth_key));
+ #endif
    BLANK();
 -#ifdef CONFIG_KVM_ARM_HOST
 +#ifdef CONFIG_KVM
    DEFINE(VCPU_CONTEXT,		offsetof(struct kvm_vcpu, arch.ctxt));
    DEFINE(VCPU_FAULT_DISR,	offsetof(struct kvm_vcpu, arch.fault.disr_el1));
    DEFINE(VCPU_WORKAROUND_FLAGS,	offsetof(struct kvm_vcpu, arch.workaround_flags));
@@@ -146,5 -135,14 +156,17 @@@
    DEFINE(SDEI_EVENT_INTREGS,	offsetof(struct sdei_registered_event, interrupted_regs));
    DEFINE(SDEI_EVENT_PRIORITY,	offsetof(struct sdei_registered_event, priority));
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_PTR_AUTH
+   DEFINE(PTRAUTH_USER_KEY_APIA,		offsetof(struct ptrauth_keys_user, apia));
+   DEFINE(PTRAUTH_USER_KEY_APIB,		offsetof(struct ptrauth_keys_user, apib));
+   DEFINE(PTRAUTH_USER_KEY_APDA,		offsetof(struct ptrauth_keys_user, apda));
+   DEFINE(PTRAUTH_USER_KEY_APDB,		offsetof(struct ptrauth_keys_user, apdb));
+   DEFINE(PTRAUTH_USER_KEY_APGA,		offsetof(struct ptrauth_keys_user, apga));
+   DEFINE(PTRAUTH_KERNEL_KEY_APIA,	offsetof(struct ptrauth_keys_kernel, apia));
+   BLANK();
+ #endif
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
    return 0;
  }
diff --cc arch/arm64/kernel/entry.S
index 2ca4c88164f6,3dad2d000e3c..000000000000
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@@ -185,14 -176,9 +185,15 @@@ alternative_cb_en
  	ldr	x19, [tsk, #TSK_TI_FLAGS]
  	disable_step_tsk x19, x20
  
 -	apply_ssbd 1, x22, x23
 +	apply_ssbd 1, 1f, x22, x23
 +
 +#ifdef CONFIG_ARM64_SSBD
 +	ldp	x0, x1, [sp, #16 * 0]
 +	ldp	x2, x3, [sp, #16 * 1]
 +#endif
 +1:
  
+ 	ptrauth_keys_install_kernel tsk, x20, x22, x23
  	.else
  	add	x21, sp, #S_FRAME_SIZE
  	get_current_task tsk
@@@ -357,8 -343,10 +358,15 @@@ alternative_else_nop_endi
  	msr	cntkctl_el1, x1
  4:
  #endif
++<<<<<<< HEAD
 +	apply_ssbd 0, 5f, x0, x1
 +5:
++=======
+ 	/* No kernel C function calls after this as user keys are set. */
+ 	ptrauth_keys_install_user tsk, x0, x1, x2
+ 
+ 	apply_ssbd 0, x0, x1
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
  	.endif
  
  	msr	elr_el1, x21			// set up the return data
diff --cc arch/arm64/mm/proc.S
index 768b1405972d,5a11a895e923..000000000000
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@@ -482,5 -469,51 +482,54 @@@ ENTRY(__cpu_setup
  1:
  #endif	/* CONFIG_ARM64_HW_AFDBM */
  	msr	tcr_el1, x10
++<<<<<<< HEAD
++=======
+ 	mov	x1, x0
+ 	/*
+ 	 * Prepare SCTLR
+ 	 */
+ 	mov_q	x0, SCTLR_EL1_SET
+ 
+ #ifdef CONFIG_ARM64_PTR_AUTH
+ 	/* No ptrauth setup for run time cpus */
+ 	cmp	x1, #ARM64_CPU_RUNTIME
+ 	b.eq	3f
+ 
+ 	/* Check if the CPU supports ptrauth */
+ 	mrs	x2, id_aa64isar1_el1
+ 	ubfx	x2, x2, #ID_AA64ISAR1_APA_SHIFT, #8
+ 	cbz	x2, 3f
+ 
+ 	/*
+ 	 * The primary cpu keys are reset here and can be
+ 	 * re-initialised with some proper values later.
+ 	 */
+ 	msr_s	SYS_APIAKEYLO_EL1, xzr
+ 	msr_s	SYS_APIAKEYHI_EL1, xzr
+ 
+ 	/* Just enable ptrauth for primary cpu */
+ 	cmp	x1, #ARM64_CPU_BOOT_PRIMARY
+ 	b.eq	2f
+ 
+ 	/* if !system_supports_address_auth() then skip enable */
+ alternative_if_not ARM64_HAS_ADDRESS_AUTH
+ 	b	3f
+ alternative_else_nop_endif
+ 
+ 	/* Install ptrauth key for secondary cpus */
+ 	adr_l	x2, secondary_data
+ 	ldr	x3, [x2, #CPU_BOOT_TASK]	// get secondary_data.task
+ 	cbz	x3, 2f				// check for slow booting cpus
+ 	ldp	x3, x4, [x2, #CPU_BOOT_PTRAUTH_KEY]
+ 	msr_s	SYS_APIAKEYLO_EL1, x3
+ 	msr_s	SYS_APIAKEYHI_EL1, x4
+ 
+ 2:	/* Enable ptrauth instructions */
+ 	ldr	x2, =SCTLR_ELx_ENIA | SCTLR_ELx_ENIB | \
+ 		     SCTLR_ELx_ENDA | SCTLR_ELx_ENDB
+ 	orr	x0, x0, x2
+ 3:
+ #endif
++>>>>>>> 33e45234987e (arm64: initialize and switch ptrauth kernel keys)
  	ret					// return to head.S
 -SYM_FUNC_END(__cpu_setup)
 +ENDPROC(__cpu_setup)
* Unmerged path arch/arm64/include/asm/asm_pointer_auth.h
* Unmerged path arch/arm64/include/asm/asm_pointer_auth.h
* Unmerged path arch/arm64/include/asm/pointer_auth.h
diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
index 2cb356549e37..a4788ae1731d 100644
--- a/arch/arm64/include/asm/processor.h
+++ b/arch/arm64/include/asm/processor.h
@@ -166,6 +166,7 @@ struct thread_struct {
 	struct debug_info	debug;		/* debugging */
 #ifdef CONFIG_ARM64_PTR_AUTH
 	struct ptrauth_keys_user	keys_user;
+	struct ptrauth_keys_kernel	keys_kernel;
 #endif
 };
 
diff --git a/arch/arm64/include/asm/smp.h b/arch/arm64/include/asm/smp.h
index a9c5715016b5..7107e5ee7529 100644
--- a/arch/arm64/include/asm/smp.h
+++ b/arch/arm64/include/asm/smp.h
@@ -41,6 +41,7 @@
 #include <linux/threads.h>
 #include <linux/cpumask.h>
 #include <linux/thread_info.h>
+#include <asm/pointer_auth.h>
 
 DECLARE_PER_CPU_READ_MOSTLY(int, cpu_number);
 
@@ -98,6 +99,9 @@ asmlinkage void secondary_start_kernel(void);
 struct secondary_data {
 	void *stack;
 	struct task_struct *task;
+#ifdef CONFIG_ARM64_PTR_AUTH
+	struct ptrauth_keys_kernel ptrauth_key;
+#endif
 	long status;
 };
 
* Unmerged path arch/arm64/kernel/asm-offsets.c
* Unmerged path arch/arm64/kernel/entry.S
diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index f8b247d2b055..4917a3ae1423 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -376,6 +376,8 @@ int copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	 */
 	fpsimd_flush_task_state(p);
 
+	ptrauth_thread_init_kernel(p);
+
 	if (likely(!(p->flags & PF_KTHREAD))) {
 		*childregs = *current_pt_regs();
 		childregs->regs[0] = 0;
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index 524a1a84285f..18ab00012d92 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -123,6 +123,10 @@ int __cpu_up(unsigned int cpu, struct task_struct *idle)
 	 */
 	secondary_data.task = idle;
 	secondary_data.stack = task_stack_page(idle) + THREAD_SIZE;
+#if defined(CONFIG_ARM64_PTR_AUTH)
+	secondary_data.ptrauth_key.apia.lo = idle->thread.keys_kernel.apia.lo;
+	secondary_data.ptrauth_key.apia.hi = idle->thread.keys_kernel.apia.hi;
+#endif
 	update_cpu_boot_status(CPU_MMU_OFF);
 	__flush_dcache_area(&secondary_data, sizeof(secondary_data));
 
@@ -145,6 +149,10 @@ int __cpu_up(unsigned int cpu, struct task_struct *idle)
 	pr_crit("CPU%u: failed to come online\n", cpu);
 	secondary_data.task = NULL;
 	secondary_data.stack = NULL;
+#if defined(CONFIG_ARM64_PTR_AUTH)
+	secondary_data.ptrauth_key.apia.lo = 0;
+	secondary_data.ptrauth_key.apia.hi = 0;
+#endif
 	__flush_dcache_area(&secondary_data, sizeof(secondary_data));
 	status = READ_ONCE(secondary_data.status);
 	if (status == CPU_MMU_OFF)
* Unmerged path arch/arm64/mm/proc.S
