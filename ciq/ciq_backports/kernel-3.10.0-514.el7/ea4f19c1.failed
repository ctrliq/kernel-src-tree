net: sctp: spare unnecessary comparison in sctp_trans_elect_best

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sctp: spare unnecessary comparison in sctp_trans_elect_best (Xin Long) [1333696]
Rebuild_FUZZ: 95.93%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit ea4f19c1f81d4bf709c74e3789ec785828bc6e51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ea4f19c1.failed

When both transports are the same, we don't have to go down that
road only to realize that we will return the very same transport.
We are guaranteed that curr is always non-NULL. Therefore, just
short-circuit this special case.

	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Acked-by: Vlad Yasevich <vyasevich@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ea4f19c1f81d4bf709c74e3789ec785828bc6e51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/associola.c
diff --cc net/sctp/associola.c
index 95613ef42a0c,104fae489ad4..000000000000
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@@ -1295,72 -1187,193 +1295,124 @@@ void sctp_assoc_update(struct sctp_asso
  }
  
  /* Update the retran path for sending a retransmitted packet.
 - * See also RFC4960, 6.4. Multi-Homed SCTP Endpoints:
 - *
 - *   When there is outbound data to send and the primary path
 - *   becomes inactive (e.g., due to failures), or where the
 - *   SCTP user explicitly requests to send data to an
 - *   inactive destination transport address, before reporting
 - *   an error to its ULP, the SCTP endpoint should try to send
 - *   the data to an alternate active destination transport
 - *   address if one exists.
 - *
 - *   When retransmitting data that timed out, if the endpoint
 - *   is multihomed, it should consider each source-destination
 - *   address pair in its retransmission selection policy.
 - *   When retransmitting timed-out data, the endpoint should
 - *   attempt to pick the most divergent source-destination
 - *   pair from the original source-destination pair to which
 - *   the packet was transmitted.
 - *
 - *   Note: Rules for picking the most divergent source-destination
 - *   pair are an implementation decision and are not specified
 - *   within this document.
 - *
 - * Our basic strategy is to round-robin transports in priorities
 - * according to sctp_state_prio_map[] e.g., if no such
 - * transport with state SCTP_ACTIVE exists, round-robin through
 - * SCTP_UNKNOWN, etc. You get the picture.
 + * Round-robin through the active transports, else round-robin
 + * through the inactive transports as this is the next best thing
 + * we can try.
   */
++<<<<<<< HEAD
++=======
+ static const u8 sctp_trans_state_to_prio_map[] = {
+ 	[SCTP_ACTIVE]	= 3,	/* best case */
+ 	[SCTP_UNKNOWN]	= 2,
+ 	[SCTP_PF]	= 1,
+ 	[SCTP_INACTIVE] = 0,	/* worst case */
+ };
+ 
+ static u8 sctp_trans_score(const struct sctp_transport *trans)
+ {
+ 	return sctp_trans_state_to_prio_map[trans->state];
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,
+ 						   struct sctp_transport *trans2)
+ {
+ 	if (trans1->error_count > trans2->error_count) {
+ 		return trans2;
+ 	} else if (trans1->error_count == trans2->error_count &&
+ 		   ktime_after(trans2->last_time_heard,
+ 			       trans1->last_time_heard)) {
+ 		return trans2;
+ 	} else {
+ 		return trans1;
+ 	}
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,
+ 						    struct sctp_transport *best)
+ {
+ 	u8 score_curr, score_best;
+ 
+ 	if (best == NULL || curr == best)
+ 		return curr;
+ 
+ 	score_curr = sctp_trans_score(curr);
+ 	score_best = sctp_trans_score(best);
+ 
+ 	/* First, try a score-based selection if both transport states
+ 	 * differ. If we're in a tie, lets try to make a more clever
+ 	 * decision here based on error counts and last time heard.
+ 	 */
+ 	if (score_curr > score_best)
+ 		return curr;
+ 	else if (score_curr == score_best)
+ 		return sctp_trans_elect_tie(curr, best);
+ 	else
+ 		return best;
+ }
+ 
++>>>>>>> ea4f19c1f81d (net: sctp: spare unnecessary comparison in sctp_trans_elect_best)
  void sctp_assoc_update_retran_path(struct sctp_association *asoc)
  {
 -	struct sctp_transport *trans = asoc->peer.retran_path;
 -	struct sctp_transport *trans_next = NULL;
 +	struct sctp_transport *t, *next;
 +	struct list_head *head = &asoc->peer.transport_addr_list;
 +	struct list_head *pos;
  
 -	/* We're done as we only have the one and only path. */
  	if (asoc->peer.transport_count == 1)
  		return;
 -	/* If active_path and retran_path are the same and active,
 -	 * then this is the only active path. Use it.
 -	 */
 -	if (asoc->peer.active_path == asoc->peer.retran_path &&
 -	    asoc->peer.active_path->state == SCTP_ACTIVE)
 -		return;
  
 -	/* Iterate from retran_path's successor back to retran_path. */
 -	for (trans = list_next_entry(trans, transports); 1;
 -	     trans = list_next_entry(trans, transports)) {
 -		/* Manually skip the head element. */
 -		if (&trans->transports == &asoc->peer.transport_addr_list)
 -			continue;
 -		if (trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		trans_next = sctp_trans_elect_best(trans, trans_next);
 -		/* Active is good enough for immediate return. */
 -		if (trans_next->state == SCTP_ACTIVE)
 -			break;
 -		/* We've reached the end, time to update path. */
 -		if (trans == asoc->peer.retran_path)
 -			break;
 -	}
 +	/* Find the next transport in a round-robin fashion. */
 +	t = asoc->peer.retran_path;
 +	pos = &t->transports;
 +	next = NULL;
  
 -	asoc->peer.retran_path = trans_next;
 +	while (1) {
 +		/* Skip the head. */
 +		if (pos->next == head)
 +			pos = head->next;
 +		else
 +			pos = pos->next;
  
 -	pr_debug("%s: association:%p updated new path to addr:%pISpc\n",
 -		 __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);
 -}
 +		t = list_entry(pos, struct sctp_transport, transports);
  
 -static void sctp_select_active_and_retran_path(struct sctp_association *asoc)
 -{
 -	struct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;
 -	struct sctp_transport *trans_pf = NULL;
 -
 -	/* Look for the two most recently used active transports. */
 -	list_for_each_entry(trans, &asoc->peer.transport_addr_list,
 -			    transports) {
 -		/* Skip uninteresting transports. */
 -		if (trans->state == SCTP_INACTIVE ||
 -		    trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		/* Keep track of the best PF transport from our
 -		 * list in case we don't find an active one.
 +		/* We have exhausted the list, but didn't find any
 +		 * other active transports.  If so, use the next
 +		 * transport.
  		 */
 -		if (trans->state == SCTP_PF) {
 -			trans_pf = sctp_trans_elect_best(trans, trans_pf);
 -			continue;
 -		}
 -		/* For active transports, pick the most recent ones. */
 -		if (trans_pri == NULL ||
 -		    ktime_after(trans->last_time_heard,
 -				trans_pri->last_time_heard)) {
 -			trans_sec = trans_pri;
 -			trans_pri = trans;
 -		} else if (trans_sec == NULL ||
 -			   ktime_after(trans->last_time_heard,
 -				       trans_sec->last_time_heard)) {
 -			trans_sec = trans;
 +		if (t == asoc->peer.retran_path) {
 +			t = next;
 +			break;
  		}
 -	}
  
 -	/* RFC 2960 6.4 Multi-Homed SCTP Endpoints
 -	 *
 -	 * By default, an endpoint should always transmit to the primary
 -	 * path, unless the SCTP user explicitly specifies the
 -	 * destination transport address (and possibly source transport
 -	 * address) to use. [If the primary is active but not most recent,
 -	 * bump the most recently used transport.]
 -	 */
 -	if ((asoc->peer.primary_path->state == SCTP_ACTIVE ||
 -	     asoc->peer.primary_path->state == SCTP_UNKNOWN) &&
 -	     asoc->peer.primary_path != trans_pri) {
 -		trans_sec = trans_pri;
 -		trans_pri = asoc->peer.primary_path;
 -	}
 +		/* Try to find an active transport. */
  
 -	/* We did not find anything useful for a possible retransmission
 -	 * path; either primary path that we found is the the same as
 -	 * the current one, or we didn't generally find an active one.
 -	 */
 -	if (trans_sec == NULL)
 -		trans_sec = trans_pri;
 -
 -	/* If we failed to find a usable transport, just camp on the
 -	 * primary or retran, even if they are inactive, if possible
 -	 * pick a PF iff it's the better choice.
 -	 */
 -	if (trans_pri == NULL) {
 -		trans_pri = sctp_trans_elect_best(asoc->peer.primary_path,
 -						  asoc->peer.retran_path);
 -		trans_pri = sctp_trans_elect_best(trans_pri, trans_pf);
 -		trans_sec = asoc->peer.primary_path;
 +		if ((t->state == SCTP_ACTIVE) ||
 +		    (t->state == SCTP_UNKNOWN)) {
 +			break;
 +		} else {
 +			/* Keep track of the next transport in case
 +			 * we don't find any active transport.
 +			 */
 +			if (t->state != SCTP_UNCONFIRMED && !next)
 +				next = t;
 +		}
  	}
  
 -	/* Set the active and retran transports. */
 -	asoc->peer.active_path = trans_pri;
 -	asoc->peer.retran_path = trans_sec;
 +	if (t)
 +		asoc->peer.retran_path = t;
 +	else
 +		t = asoc->peer.retran_path;
 +
 +	SCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_update_retran_path:association"
 +				 " %p addr: ",
 +				 " port: %d\n",
 +				 asoc,
 +				 (&t->ipaddr),
 +				 ntohs(t->ipaddr.v4.sin_port));
  }
  
 -struct sctp_transport *
 -sctp_assoc_choose_alter_transport(struct sctp_association *asoc,
 -				  struct sctp_transport *last_sent_to)
 +/* Choose the transport for sending retransmit packet.  */
 +struct sctp_transport *sctp_assoc_choose_alter_transport(
 +	struct sctp_association *asoc, struct sctp_transport *last_sent_to)
  {
  	/* If this is the first time packet is sent, use the active path,
  	 * else use the retran path. If the last packet was sent over the
* Unmerged path net/sctp/associola.c
