iommu/vt-d: Fix leaked ioremap mapping

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] vt-d: Fix leaked ioremap mapping (Jeff Moyer) [1345801 1348502 1348836 1350149 1350156]
Rebuild_FUZZ: 91.43%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 50690762cfe32abadbaa5b22bebe3855e5b8ede8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/50690762.failed

iommu_load_old_irte() appears to leak the old_irte mapping after use.

	Cc: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 50690762cfe32abadbaa5b22bebe3855e5b8ede8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel_irq_remapping.c
diff --cc drivers/iommu/intel_irq_remapping.c
index 9b2ae1ba29ab,27cdfa84ec5b..000000000000
--- a/drivers/iommu/intel_irq_remapping.c
+++ b/drivers/iommu/intel_irq_remapping.c
@@@ -424,11 -382,61 +424,64 @@@ static int set_msi_sid(struct irte *irt
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int iommu_load_old_irte(struct intel_iommu *iommu)
+ {
+ 	struct irte *old_ir_table;
+ 	phys_addr_t irt_phys;
+ 	unsigned int i;
+ 	size_t size;
+ 	u64 irta;
+ 
+ 	if (!is_kdump_kernel()) {
+ 		pr_warn("IRQ remapping was enabled on %s but we are not in kdump mode\n",
+ 			iommu->name);
+ 		clear_ir_pre_enabled(iommu);
+ 		iommu_disable_irq_remapping(iommu);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Check whether the old ir-table has the same size as ours */
+ 	irta = dmar_readq(iommu->reg + DMAR_IRTA_REG);
+ 	if ((irta & INTR_REMAP_TABLE_REG_SIZE_MASK)
+ 	     != INTR_REMAP_TABLE_REG_SIZE)
+ 		return -EINVAL;
+ 
+ 	irt_phys = irta & VTD_PAGE_MASK;
+ 	size     = INTR_REMAP_TABLE_ENTRIES*sizeof(struct irte);
+ 
+ 	/* Map the old IR table */
+ 	old_ir_table = ioremap_cache(irt_phys, size);
+ 	if (!old_ir_table)
+ 		return -ENOMEM;
+ 
+ 	/* Copy data over */
+ 	memcpy(iommu->ir_table->base, old_ir_table, size);
+ 
+ 	__iommu_flush_cache(iommu, iommu->ir_table->base, size);
+ 
+ 	/*
+ 	 * Now check the table for used entries and mark those as
+ 	 * allocated in the bitmap
+ 	 */
+ 	for (i = 0; i < INTR_REMAP_TABLE_ENTRIES; i++) {
+ 		if (iommu->ir_table->base[i].present)
+ 			bitmap_set(iommu->ir_table->bitmap, i, 1);
+ 	}
+ 
+ 	iounmap(old_ir_table);
+ 
+ 	return 0;
+ }
+ 
+ 
++>>>>>>> 50690762cfe3 (iommu/vt-d: Fix leaked ioremap mapping)
  static void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)
  {
 -	unsigned long flags;
  	u64 addr;
  	u32 sts;
 +	unsigned long flags;
  
  	addr = virt_to_phys((void *)iommu->ir_table->base);
  
* Unmerged path drivers/iommu/intel_irq_remapping.c
