xfs: add configuration handlers for specific errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Carlos Maiolino <cmaiolino@redhat.com>
commit e0a431b3a3cc3d0a4c38ccfca8c7320fde40efb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e0a431b3.failed

now most of the infrastructure is in place, we can start adding
support for configuring specific errors such as ENODEV, ENOSPC, EIO,
etc. Add these error configurations and configure them all to have
appropriate behaviours. That is, all will be configured to retry
forever by default, except for ENODEV, which is an unrecoverable
error, so it will be configured to not retry on error

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit e0a431b3a3cc3d0a4c38ccfca8c7320fde40efb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_sysfs.c
diff --cc fs/xfs/xfs_mount.h
index fe5c55265429,72ec3e3c988e..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -37,6 -37,32 +37,35 @@@ enum 
  	XFS_LOWSP_MAX,
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * Error Configuration
+  *
+  * Error classes define the subsystem the configuration belongs to.
+  * Error numbers define the errors that are configurable.
+  */
+ enum {
+ 	XFS_ERR_METADATA,
+ 	XFS_ERR_CLASS_MAX,
+ };
+ enum {
+ 	XFS_ERR_DEFAULT,
+ 	XFS_ERR_EIO,
+ 	XFS_ERR_ENOSPC,
+ 	XFS_ERR_ENODEV,
+ 	XFS_ERR_ERRNO_MAX,
+ };
+ 
+ #define XFS_ERR_RETRY_FOREVER	-1
+ 
+ struct xfs_error_cfg {
+ 	struct xfs_kobj	kobj;
+ 	int		max_retries;
+ 	unsigned long	retry_timeout;	/* in jiffies, 0 = no timeout */
+ };
+ 
++>>>>>>> e0a431b3a3cc (xfs: add configuration handlers for specific errors)
  typedef struct xfs_mount {
  	struct super_block	*m_super;
  	xfs_tid_t		m_tid;		/* next unused tid for fs */
diff --cc fs/xfs/xfs_sysfs.c
index 641d625eb334,084a606840a1..000000000000
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@@ -304,3 -363,245 +304,248 @@@ struct kobj_type xfs_log_ktype = 
  	.sysfs_ops = &xfs_sysfs_ops,
  	.default_attrs = xfs_log_attrs,
  };
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Metadata IO error configuration
+  *
+  * The sysfs structure here is:
+  *	...xfs/<dev>/error/<class>/<errno>/<error_attrs>
+  *
+  * where <class> allows us to discriminate between data IO and metadata IO,
+  * and any other future type of IO (e.g. special inode or directory error
+  * handling) we care to support.
+  */
+ static inline struct xfs_error_cfg *
+ to_error_cfg(struct kobject *kobject)
+ {
+ 	struct xfs_kobj *kobj = to_kobj(kobject);
+ 	return container_of(kobj, struct xfs_error_cfg, kobj);
+ }
+ 
+ static ssize_t
+ max_retries_show(
+ 	struct kobject	*kobject,
+ 	char		*buf)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%d\n", cfg->max_retries);
+ }
+ 
+ static ssize_t
+ max_retries_store(
+ 	struct kobject	*kobject,
+ 	const char	*buf,
+ 	size_t		count)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 	int		ret;
+ 	int		val;
+ 
+ 	ret = kstrtoint(buf, 0, &val);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (val < -1)
+ 		return -EINVAL;
+ 
+ 	cfg->max_retries = val;
+ 	return count;
+ }
+ XFS_SYSFS_ATTR_RW(max_retries);
+ 
+ static ssize_t
+ retry_timeout_seconds_show(
+ 	struct kobject	*kobject,
+ 	char		*buf)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%ld\n",
+ 			jiffies_to_msecs(cfg->retry_timeout) / MSEC_PER_SEC);
+ }
+ 
+ static ssize_t
+ retry_timeout_seconds_store(
+ 	struct kobject	*kobject,
+ 	const char	*buf,
+ 	size_t		count)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 	int		ret;
+ 	int		val;
+ 
+ 	ret = kstrtoint(buf, 0, &val);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* 1 day timeout maximum */
+ 	if (val < 0 || val > 86400)
+ 		return -EINVAL;
+ 
+ 	cfg->retry_timeout = msecs_to_jiffies(val * MSEC_PER_SEC);
+ 	return count;
+ }
+ XFS_SYSFS_ATTR_RW(retry_timeout_seconds);
+ 
+ static struct attribute *xfs_error_attrs[] = {
+ 	ATTR_LIST(max_retries),
+ 	ATTR_LIST(retry_timeout_seconds),
+ 	NULL,
+ };
+ 
+ 
+ struct kobj_type xfs_error_cfg_ktype = {
+ 	.release = xfs_sysfs_release,
+ 	.sysfs_ops = &xfs_sysfs_ops,
+ 	.default_attrs = xfs_error_attrs,
+ };
+ 
+ struct kobj_type xfs_error_ktype = {
+ 	.release = xfs_sysfs_release,
+ };
+ 
+ /*
+  * Error initialization tables. These need to be ordered in the same
+  * order as the enums used to index the array. All class init tables need to
+  * define a "default" behaviour as the first entry, all other entries can be
+  * empty.
+  */
+ struct xfs_error_init {
+ 	char		*name;
+ 	int		max_retries;
+ 	int		retry_timeout;	/* in seconds */
+ };
+ 
+ static const struct xfs_error_init xfs_error_meta_init[XFS_ERR_ERRNO_MAX] = {
+ 	{ .name = "default",
+ 	  .max_retries = XFS_ERR_RETRY_FOREVER,
+ 	  .retry_timeout = 0,
+ 	},
+ 	{ .name = "EIO",
+ 	  .max_retries = XFS_ERR_RETRY_FOREVER,
+ 	  .retry_timeout = 0,
+ 	},
+ 	{ .name = "ENOSPC",
+ 	  .max_retries = XFS_ERR_RETRY_FOREVER,
+ 	  .retry_timeout = 0,
+ 	},
+ 	{ .name = "ENODEV",
+ 	  .max_retries = 0,
+ 	},
+ };
+ 
+ static int
+ xfs_error_sysfs_init_class(
+ 	struct xfs_mount	*mp,
+ 	int			class,
+ 	const char		*parent_name,
+ 	struct xfs_kobj		*parent_kobj,
+ 	const struct xfs_error_init init[])
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			error;
+ 	int			i;
+ 
+ 	ASSERT(class < XFS_ERR_CLASS_MAX);
+ 
+ 	error = xfs_sysfs_init(parent_kobj, &xfs_error_ktype,
+ 				&mp->m_error_kobj, parent_name);
+ 	if (error)
+ 		return error;
+ 
+ 	for (i = 0; i < XFS_ERR_ERRNO_MAX; i++) {
+ 		cfg = &mp->m_error_cfg[class][i];
+ 		error = xfs_sysfs_init(&cfg->kobj, &xfs_error_cfg_ktype,
+ 					parent_kobj, init[i].name);
+ 		if (error)
+ 			goto out_error;
+ 
+ 		cfg->max_retries = init[i].max_retries;
+ 		cfg->retry_timeout = msecs_to_jiffies(
+ 					init[i].retry_timeout * MSEC_PER_SEC);
+ 	}
+ 	return 0;
+ 
+ out_error:
+ 	/* unwind the entries that succeeded */
+ 	for (i--; i >= 0; i--) {
+ 		cfg = &mp->m_error_cfg[class][i];
+ 		xfs_sysfs_del(&cfg->kobj);
+ 	}
+ 	xfs_sysfs_del(parent_kobj);
+ 	return error;
+ }
+ 
+ int
+ xfs_error_sysfs_init(
+ 	struct xfs_mount	*mp)
+ {
+ 	int			error;
+ 
+ 	/* .../xfs/<dev>/error/ */
+ 	error = xfs_sysfs_init(&mp->m_error_kobj, &xfs_error_ktype,
+ 				&mp->m_kobj, "error");
+ 	if (error)
+ 		return error;
+ 
+ 	/* .../xfs/<dev>/error/metadata/ */
+ 	error = xfs_error_sysfs_init_class(mp, XFS_ERR_METADATA,
+ 				"metadata", &mp->m_error_meta_kobj,
+ 				xfs_error_meta_init);
+ 	if (error)
+ 		goto out_error;
+ 
+ 	return 0;
+ 
+ out_error:
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ 	return error;
+ }
+ 
+ void
+ xfs_error_sysfs_del(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			i, j;
+ 
+ 	for (i = 0; i < XFS_ERR_CLASS_MAX; i++) {
+ 		for (j = 0; j < XFS_ERR_ERRNO_MAX; j++) {
+ 			cfg = &mp->m_error_cfg[i][j];
+ 
+ 			xfs_sysfs_del(&cfg->kobj);
+ 		}
+ 	}
+ 	xfs_sysfs_del(&mp->m_error_meta_kobj);
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ }
+ 
+ struct xfs_error_cfg *
+ xfs_error_get_cfg(
+ 	struct xfs_mount	*mp,
+ 	int			error_class,
+ 	int			error)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 
+ 	switch (error) {
+ 	case EIO:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_EIO];
+ 		break;
+ 	case ENOSPC:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_ENOSPC];
+ 		break;
+ 	case ENODEV:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_ENODEV];
+ 		break;
+ 	default:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_DEFAULT];
+ 		break;
+ 	}
+ 
+ 	return cfg;
+ }
++>>>>>>> e0a431b3a3cc (xfs: add configuration handlers for specific errors)
* Unmerged path fs/xfs/xfs_mount.h
* Unmerged path fs/xfs/xfs_sysfs.c
