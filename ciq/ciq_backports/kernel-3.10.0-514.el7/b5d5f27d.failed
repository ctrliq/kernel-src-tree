x86/topology: Fix logical package mapping

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] topology: Fix logical package mapping (Jiri Olsa) [1084618]
Rebuild_FUZZ: 94.87%
commit-author Peter Zijlstra <peterz@infradead.org>
commit b5d5f27d938fb6fc8d3202704e699d2694a02da6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5d5f27d.failed

That first branch testing pkg against __max_logical_packages is wrong,
because if the first pkg id is larger, then the find_first_zero will
find us logical package id 0. However, if the second pkg id is indeed
0, we'll again claim it without testing if it was already taken.

Also, it fails to print the mapping.

Fixes: 1f12e32f4cd5 ("x86/topology: Create logical package id")
	Reported-by: Xiong Zhou <jencce.kernel@gmail.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: aherrmann@suse.com
	Cc: bp@alien8.de
	Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
Link: http://lkml.kernel.org/r/20160317095220.GO6344@twins.programming.kicks-ass.net
Link: http://lkml.kernel.org/r/20160318150538.482393396@infradead.org
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit b5d5f27d938fb6fc8d3202704e699d2694a02da6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/smpboot.c
diff --cc arch/x86/kernel/smpboot.c
index 7dbc496614e0,64b669dcbf23..000000000000
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@@ -233,7 -256,93 +233,97 @@@ static void notrace start_secondary(voi
  	x86_cpuinit.setup_percpu_clockev();
  
  	wmb();
++<<<<<<< HEAD
 +	cpu_startup_entry(CPUHP_ONLINE);
++=======
+ 	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);
+ }
+ 
+ int topology_update_package_map(unsigned int apicid, unsigned int cpu)
+ {
+ 	unsigned int new, pkg = apicid >> boot_cpu_data.x86_coreid_bits;
+ 
+ 	/* Called from early boot ? */
+ 	if (!physical_package_map)
+ 		return 0;
+ 
+ 	if (pkg >= max_physical_pkg_id)
+ 		return -EINVAL;
+ 
+ 	/* Set the logical package id */
+ 	if (test_and_set_bit(pkg, physical_package_map))
+ 		goto found;
+ 
+ 	new = find_first_zero_bit(logical_package_map, __max_logical_packages);
+ 	if (new >= __max_logical_packages) {
+ 		physical_to_logical_pkg[pkg] = -1;
+ 		pr_warn("APIC(%x) Package %u exceeds logical package map\n",
+ 			apicid, pkg);
+ 		return -ENOSPC;
+ 	}
+ 	set_bit(new, logical_package_map);
+ 	pr_info("APIC(%x) Converting physical %u to logical package %u\n",
+ 		apicid, pkg, new);
+ 	physical_to_logical_pkg[pkg] = new;
+ 
+ found:
+ 	cpu_data(cpu).logical_proc_id = physical_to_logical_pkg[pkg];
+ 	return 0;
+ }
+ 
+ /**
+  * topology_phys_to_logical_pkg - Map a physical package id to a logical
+  *
+  * Returns logical package id or -1 if not found
+  */
+ int topology_phys_to_logical_pkg(unsigned int phys_pkg)
+ {
+ 	if (phys_pkg >= max_physical_pkg_id)
+ 		return -1;
+ 	return physical_to_logical_pkg[phys_pkg];
+ }
+ EXPORT_SYMBOL(topology_phys_to_logical_pkg);
+ 
+ static void __init smp_init_package_map(void)
+ {
+ 	unsigned int ncpus, cpu;
+ 	size_t size;
+ 
+ 	/*
+ 	 * Today neither Intel nor AMD support heterogenous systems. That
+ 	 * might change in the future....
+ 	 */
+ 	ncpus = boot_cpu_data.x86_max_cores * smp_num_siblings;
+ 	__max_logical_packages = DIV_ROUND_UP(nr_cpu_ids, ncpus);
+ 
+ 	/*
+ 	 * Possibly larger than what we need as the number of apic ids per
+ 	 * package can be smaller than the actual used apic ids.
+ 	 */
+ 	max_physical_pkg_id = DIV_ROUND_UP(MAX_LOCAL_APIC, ncpus);
+ 	size = max_physical_pkg_id * sizeof(unsigned int);
+ 	physical_to_logical_pkg = kmalloc(size, GFP_KERNEL);
+ 	memset(physical_to_logical_pkg, 0xff, size);
+ 	size = BITS_TO_LONGS(max_physical_pkg_id) * sizeof(unsigned long);
+ 	physical_package_map = kzalloc(size, GFP_KERNEL);
+ 	size = BITS_TO_LONGS(__max_logical_packages) * sizeof(unsigned long);
+ 	logical_package_map = kzalloc(size, GFP_KERNEL);
+ 
+ 	pr_info("Max logical packages: %u\n", __max_logical_packages);
+ 
+ 	for_each_present_cpu(cpu) {
+ 		unsigned int apicid = apic->cpu_present_to_apicid(cpu);
+ 
+ 		if (apicid == BAD_APICID || !apic->apic_id_valid(apicid))
+ 			continue;
+ 		if (!topology_update_package_map(apicid, cpu))
+ 			continue;
+ 		pr_warn("CPU %u APICId %x disabled\n", cpu, apicid);
+ 		per_cpu(x86_bios_cpu_apicid, cpu) = BAD_APICID;
+ 		set_cpu_possible(cpu, false);
+ 		set_cpu_present(cpu, false);
+ 	}
++>>>>>>> b5d5f27d938f (x86/topology: Fix logical package mapping)
  }
  
  void __init smp_store_boot_cpu_info(void)
* Unmerged path arch/x86/kernel/smpboot.c
