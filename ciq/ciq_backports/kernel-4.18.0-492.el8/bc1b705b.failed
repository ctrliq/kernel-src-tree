x86/MCE/AMD: Clear DFR errors found in THR handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Yazen Ghannam <yazen.ghannam@amd.com>
commit bc1b705b0eee4c645ad8b3bbff3c8a66e9688362
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/bc1b705b.failed

AMD's MCA Thresholding feature counts errors of all severity levels, not
just correctable errors. If a deferred error causes the threshold limit
to be reached (it was the error that caused the overflow), then both a
deferred error interrupt and a thresholding interrupt will be triggered.

The order of the interrupts is not guaranteed. If the threshold
interrupt handler is executed first, then it will clear MCA_STATUS for
the error. It will not check or clear MCA_DESTAT which also holds a copy
of the deferred error. When the deferred error interrupt handler runs it
will not find an error in MCA_STATUS, but it will find the error in
MCA_DESTAT. This will cause two errors to be logged.

Check for deferred errors when handling a threshold interrupt. If a bank
contains a deferred error, then clear the bank's MCA_DESTAT register.

Define a new helper function to do the deferred error check and clearing
of MCA_DESTAT.

  [ bp: Simplify, convert comment to passive voice. ]

Fixes: 37d43acfd79f ("x86/mce/AMD: Redo error logging from APIC LVT interrupt handlers")
	Signed-off-by: Yazen Ghannam <yazen.ghannam@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20220621155943.33623-1-yazen.ghannam@amd.com
(cherry picked from commit bc1b705b0eee4c645ad8b3bbff3c8a66e9688362)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mce/amd.c
diff --cc arch/x86/kernel/cpu/mce/amd.c
index 22e71069e196,10fb5b5c9efa..000000000000
--- a/arch/x86/kernel/cpu/mce/amd.c
+++ b/arch/x86/kernel/cpu/mce/amd.c
@@@ -1002,20 -817,9 +1020,18 @@@ static bool _log_error_deferred(unsigne
   */
  static void log_error_deferred(unsigned int bank)
  {
++<<<<<<< HEAD
 +	bool defrd;
 +
 +	defrd = _log_error_bank(bank, msr_ops.status(bank),
 +					msr_ops.addr(bank), 0);
 +
 +	if (!mce_flags.smca)
++=======
+ 	if (_log_error_deferred(bank, 0))
++>>>>>>> bc1b705b0eee (x86/MCE/AMD: Clear DFR errors found in THR handler)
  		return;
  
- 	/* Clear MCA_DESTAT if we logged the deferred error from MCA_STATUS. */
- 	if (defrd) {
- 		wrmsrl(MSR_AMD64_SMCA_MCx_DESTAT(bank), 0);
- 		return;
- 	}
- 
  	/*
  	 * Only deferred errors are logged in MCA_DE{STAT,ADDR} so just check
  	 * for a valid error.
@@@ -1035,7 -839,7 +1051,11 @@@ static void amd_deferred_error_interrup
  
  static void log_error_thresholding(unsigned int bank, u64 misc)
  {
++<<<<<<< HEAD
 +	_log_error_bank(bank, msr_ops.status(bank), msr_ops.addr(bank), misc);
++=======
+ 	_log_error_deferred(bank, misc);
++>>>>>>> bc1b705b0eee (x86/MCE/AMD: Clear DFR errors found in THR handler)
  }
  
  static void log_and_reset_block(struct threshold_block *block)
* Unmerged path arch/x86/kernel/cpu/mce/amd.c
