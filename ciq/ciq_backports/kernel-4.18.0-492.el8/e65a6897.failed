iommu/vt-d: Add a fix for devices need extra dtlb flush

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Jacob Pan <jacob.jun.pan@linux.intel.com>
commit e65a6897be5e4939d477c4969a05e12d90b08409
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/e65a6897.failed

QAT devices on Intel Sapphire Rapids and Emerald Rapids have a defect in
address translation service (ATS). These devices may inadvertently issue
ATS invalidation completion before posted writes initiated with
translated address that utilized translations matching the invalidation
address range, violating the invalidation completion ordering.

This patch adds an extra device TLB invalidation for the affected devices,
it is needed to ensure no more posted writes with translated address
following the invalidation completion. Therefore, the ordering is
preserved and data-corruption is prevented.

Device TLBs are invalidated under the following six conditions:
1. Device driver does DMA API unmap IOVA
2. Device driver unbind a PASID from a process, sva_unbind_device()
3. PASID is torn down, after PASID cache is flushed. e.g. process
exit_mmap() due to crash
4. Under SVA usage, called by mmu_notifier.invalidate_range() where
VM has to free pages that were unmapped
5. userspace driver unmaps a DMA buffer
6. Cache invalidation in vSVA usage (upcoming)

For #1 and #2, device drivers are responsible for stopping DMA traffic
before unmap/unbind. For #3, iommu driver gets mmu_notifier to
invalidate TLB the same way as normal user unmap which will do an extra
invalidation. The dTLB invalidation after PASID cache flush does not
need an extra invalidation.

Therefore, we only need to deal with #4 and #5 in this patch. #1 is also
covered by this patch due to common code path with #5.

	Tested-by: Yuzhang Luo <yuzhang.luo@intel.com>
	Reviewed-by: Ashok Raj <ashok.raj@intel.com>
	Reviewed-by: Kevin Tian <kevin.tian@intel.com>
	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
Link: https://lore.kernel.org/r/20221130062449.1360063-1-jacob.jun.pan@linux.intel.com
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit e65a6897be5e4939d477c4969a05e12d90b08409)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel/iommu.c
#	include/linux/intel-iommu.h
diff --cc drivers/iommu/intel/iommu.c
index 5f174639e11b,587eebe39820..000000000000
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@@ -1576,23 -1391,30 +1576,45 @@@ static void domain_update_iotlb(struct 
  			has_iotlb_device = true;
  			break;
  		}
 +
 +	if (!has_iotlb_device) {
 +		struct subdev_domain_info *sinfo;
 +
 +		list_for_each_entry(sinfo, &domain->subdevices, link_domain) {
 +			info = get_domain_info(sinfo->pdev);
 +			if (info && info->ats_enabled) {
 +				has_iotlb_device = true;
 +				break;
 +			}
 +		}
  	}
 +
  	domain->has_iotlb_device = has_iotlb_device;
 -	spin_unlock_irqrestore(&domain->lock, flags);
  }
  
++<<<<<<< HEAD
 +static void iommu_enable_dev_iotlb(struct device_domain_info *info)
++=======
+ /*
+  * The extra devTLB flush quirk impacts those QAT devices with PCI device
+  * IDs ranging from 0x4940 to 0x4943. It is exempted from risky_device()
+  * check because it applies only to the built-in QAT devices and it doesn't
+  * grant additional privileges.
+  */
+ #define BUGGY_QAT_DEVID_MASK 0x494c
+ static bool dev_needs_extra_dtlb_flush(struct pci_dev *pdev)
+ {
+ 	if (pdev->vendor != PCI_VENDOR_ID_INTEL)
+ 		return false;
+ 
+ 	if ((pdev->device & 0xfffc) != BUGGY_QAT_DEVID_MASK)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static void iommu_enable_pci_caps(struct device_domain_info *info)
++>>>>>>> e65a6897be5e (iommu/vt-d: Add a fix for devices need extra dtlb flush)
  {
  	struct pci_dev *pdev;
  
@@@ -5308,14 -4481,53 +5331,55 @@@ static bool intel_iommu_capable(enum io
  
  static struct iommu_device *intel_iommu_probe_device(struct device *dev)
  {
 -	struct pci_dev *pdev = dev_is_pci(dev) ? to_pci_dev(dev) : NULL;
 -	struct device_domain_info *info;
  	struct intel_iommu *iommu;
 -	u8 bus, devfn;
  
 -	iommu = device_to_iommu(dev, &bus, &devfn);
 -	if (!iommu || !iommu->iommu.ops)
 +	iommu = device_to_iommu(dev, NULL, NULL);
 +	if (!iommu)
  		return ERR_PTR(-ENODEV);
  
++<<<<<<< HEAD
 +	if (translation_pre_enabled(iommu))
 +		dev_iommu_priv_set(dev, DEFER_DEVICE_DOMAIN_INFO);
++=======
+ 	info = kzalloc(sizeof(*info), GFP_KERNEL);
+ 	if (!info)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (dev_is_real_dma_subdevice(dev)) {
+ 		info->bus = pdev->bus->number;
+ 		info->devfn = pdev->devfn;
+ 		info->segment = pci_domain_nr(pdev->bus);
+ 	} else {
+ 		info->bus = bus;
+ 		info->devfn = devfn;
+ 		info->segment = iommu->segment;
+ 	}
+ 
+ 	info->dev = dev;
+ 	info->iommu = iommu;
+ 	if (dev_is_pci(dev)) {
+ 		if (ecap_dev_iotlb_support(iommu->ecap) &&
+ 		    pci_ats_supported(pdev) &&
+ 		    dmar_ats_supported(pdev, iommu)) {
+ 			info->ats_supported = 1;
+ 			info->dtlb_extra_inval = dev_needs_extra_dtlb_flush(pdev);
+ 		}
+ 		if (sm_supported(iommu)) {
+ 			if (pasid_supported(iommu)) {
+ 				int features = pci_pasid_features(pdev);
+ 
+ 				if (features >= 0)
+ 					info->pasid_supported = features | 1;
+ 			}
+ 
+ 			if (info->ats_supported && ecap_prs(iommu->ecap) &&
+ 			    pci_pri_supported(pdev))
+ 				info->pri_supported = 1;
+ 		}
+ 	}
+ 
+ 	dev_iommu_priv_set(dev, info);
++>>>>>>> e65a6897be5e (iommu/vt-d: Add a fix for devices need extra dtlb flush)
  
  	return &iommu->iommu;
  }
diff --cc include/linux/intel-iommu.h
index fcd9af6275ba,db9df7c3790c..000000000000
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@@ -655,7 -623,7 +655,11 @@@ struct device_domain_info 
  	u8 pri_enabled:1;
  	u8 ats_supported:1;
  	u8 ats_enabled:1;
++<<<<<<< HEAD:include/linux/intel-iommu.h
 +	u8 auxd_enabled:1;	/* Multiple domains per device */
++=======
+ 	u8 dtlb_extra_inval:1;	/* Quirk for devices need extra flush */
++>>>>>>> e65a6897be5e (iommu/vt-d: Add a fix for devices need extra dtlb flush):drivers/iommu/intel/iommu.h
  	u8 ats_qdep;
  	struct device *dev; /* it's NULL for PCIe-to-PCI bridge */
  	struct intel_iommu *iommu; /* IOMMU used by this device */
* Unmerged path drivers/iommu/intel/iommu.c
diff --git a/drivers/iommu/intel/svm.c b/drivers/iommu/intel/svm.c
index aef3cf79477f..211c969f9765 100644
--- a/drivers/iommu/intel/svm.c
+++ b/drivers/iommu/intel/svm.c
@@ -209,10 +209,13 @@ static void __flush_svm_range_dev(struct intel_svm *svm,
 		return;
 
 	qi_flush_piotlb(sdev->iommu, sdev->did, svm->pasid, address, pages, ih);
-	if (info->ats_enabled)
+	if (info->ats_enabled) {
 		qi_flush_dev_iotlb_pasid(sdev->iommu, sdev->sid, info->pfsid,
 					 svm->pasid, sdev->qdep, address,
 					 order_base_2(pages));
+		quirk_extra_dev_tlb_flush(info, address, order_base_2(pages),
+					  svm->pasid, sdev->qdep);
+	}
 }
 
 static void intel_flush_svm_range_dev(struct intel_svm *svm,
* Unmerged path include/linux/intel-iommu.h
