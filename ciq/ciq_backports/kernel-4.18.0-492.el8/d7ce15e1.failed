x86/split_lock: Enumerate architectural split lock disable bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Fenghua Yu <fenghua.yu@intel.com>
commit d7ce15e1d4162ab5e56dead10d4ae69a6b5c8ee8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/d7ce15e1.failed

The December 2022 edition of the Intel Instruction Set Extensions manual
defined that the split lock disable bit in the IA32_CORE_CAPABILITIES MSR
is (and retrospectively always has been) architectural.

Remove all the model specific checks except for Ice Lake variants which are
still needed because these CPU models do not enumerate presence of the
IA32_CORE_CAPABILITIES MSR.

Originally-by: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
Link: https://lore.kernel.org/lkml/20220701131958.687066-1-fenghua.yu@intel.com/t/#mada243bee0915532a6adef6a9e32d244d1a9aef4
(cherry picked from commit d7ce15e1d4162ab5e56dead10d4ae69a6b5c8ee8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel.c
diff --cc arch/x86/kernel/cpu/intel.c
index 9c339d27742e,1c648b09e053..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -1299,43 -1451,13 +1299,39 @@@ void handle_bus_lock(struct pt_regs *re
  }
  
  /*
++<<<<<<< HEAD
 + * This function is called only when switching between tasks with
 + * different split-lock detection modes. It sets the MSR for the
 + * mode of the new task. This is right most of the time, but since
 + * the MSR is shared by hyperthreads on a physical core there can
 + * be glitches when the two threads need different modes.
 + */
 +void switch_to_sld(unsigned long tifn)
 +{
 +	sld_update_msr(!(tifn & _TIF_SLD));
 +}
 +
 +/*
 + * Bits in the IA32_CORE_CAPABILITIES are not architectural, so they should
 + * only be trusted if it is confirmed that a CPU model implements a
 + * specific feature at a particular bit position.
 + *
 + * The possible driver data field values:
 + *
 + * - 0: CPU models that are known to have the per-core split-lock detection
 + *	feature even though they do not enumerate IA32_CORE_CAPABILITIES.
 + *
 + * - 1: CPU models which may enumerate IA32_CORE_CAPABILITIES and if so use
 + *      bit 5 to enumerate the per-core split-lock detection feature.
++=======
+  * CPU models that are known to have the per-core split-lock detection
+  * feature even though they do not enumerate IA32_CORE_CAPABILITIES.
++>>>>>>> d7ce15e1d416 (x86/split_lock: Enumerate architectural split lock disable bit)
   */
  static const struct x86_cpu_id split_lock_cpu_ids[] __initconst = {
- 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,		0),
- 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,		0),
- 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,		0),
- 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT,	1),
- 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_D,	1),
- 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_L,	1),
- 	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L,		1),
- 	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE,		1),
- 	X86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X,	1),
- 	X86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE,		1),
- 	X86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L,		1),
- 	X86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE,		1),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,	0),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,	0),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,	0),
  	{}
  };
  
@@@ -1347,24 -1469,28 +1343,31 @@@ static void __init split_lock_setup(str
  	if (boot_cpu_has(X86_FEATURE_HYPERVISOR))
  		return;
  
+ 	/* Check for CPUs that have support but do not enumerate it: */
  	m = x86_match_cpu(split_lock_cpu_ids);
- 	if (!m)
- 		return;
+ 	if (m)
+ 		goto supported;
  
- 	switch (m->driver_data) {
- 	case 0:
- 		break;
- 	case 1:
- 		if (!cpu_has(c, X86_FEATURE_CORE_CAPABILITIES))
- 			return;
- 		rdmsrl(MSR_IA32_CORE_CAPS, ia32_core_caps);
- 		if (!(ia32_core_caps & MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT))
- 			return;
- 		break;
- 	default:
+ 	if (!cpu_has(c, X86_FEATURE_CORE_CAPABILITIES))
  		return;
- 	}
  
+ 	/*
+ 	 * Not all bits in MSR_IA32_CORE_CAPS are architectural, but
+ 	 * MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT is.  All CPUs that set
+ 	 * it have split lock detection.
+ 	 */
+ 	rdmsrl(MSR_IA32_CORE_CAPS, ia32_core_caps);
+ 	if (ia32_core_caps & MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT)
+ 		goto supported;
+ 
++<<<<<<< HEAD
++=======
+ 	/* CPU is not in the model list and does not have the MSR bit: */
+ 	return;
+ 
+ supported:
+ 	cpu_model_supports_sld = true;
++>>>>>>> d7ce15e1d416 (x86/split_lock: Enumerate architectural split lock disable bit)
  	__split_lock_setup();
  }
  
* Unmerged path arch/x86/kernel/cpu/intel.c
