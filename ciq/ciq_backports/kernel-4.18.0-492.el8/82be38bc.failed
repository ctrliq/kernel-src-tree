xfs: fix overfilling of reserve pool

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 82be38bcf8a2e056b4c99ce79a3827fa743df6ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/82be38bc.failed

Due to cycling of m_sb_lock, it's possible for multiple callers of
xfs_reserve_blocks to race at changing the pool size, subtracting blocks
from fdblocks, and actually putting it in the pool.  The result of all
this is that we can overfill the reserve pool to hilarious levels.

xfs_mod_fdblocks, when called with a positive value, already knows how
to take freed blocks and either fill the reserve until it's full, or put
them in fdblocks.  Use that instead of setting m_resblks_avail directly.

	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 82be38bcf8a2e056b4c99ce79a3827fa743df6ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsops.c
diff --cc fs/xfs/xfs_fsops.c
index 88edfa51e5ca,5b5b68affe66..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -435,46 -430,36 +435,62 @@@ xfs_reserve_blocks
  	 * If the request is larger than the current reservation, reserve the
  	 * blocks before we update the reserve counters. Sample m_fdblocks and
  	 * perform a partial reservation if the request exceeds free space.
 -	 *
 -	 * The code below estimates how many blocks it can request from
 -	 * fdblocks to stash in the reserve pool.  This is a classic TOCTOU
 -	 * race since fdblocks updates are not always coordinated via
 -	 * m_sb_lock.  Set the reserve size even if there's not enough free
 -	 * space to fill it because mod_fdblocks will refill an undersized
 -	 * reserve when it can.
  	 */
 -	free = percpu_counter_sum(&mp->m_fdblocks) -
 -						xfs_fdblocks_unavailable(mp);
 -	delta = request - mp->m_resblks;
 -	mp->m_resblks = request;
 -	if (delta > 0 && free > 0) {
 +	error = -ENOSPC;
 +	do {
 +		free = percpu_counter_sum(&mp->m_fdblocks) -
 +						mp->m_alloc_set_aside;
 +		if (free <= 0)
 +			break;
 +
 +		delta = request - mp->m_resblks;
 +		lcounter = free - delta;
 +		if (lcounter < 0)
 +			/* We can't satisfy the request, just get what we can */
 +			fdblks_delta = free;
 +		else
 +			fdblks_delta = delta;
 +
  		/*
  		 * We'll either succeed in getting space from the free block
++<<<<<<< HEAD
 +		 * count or we'll get an ENOSPC. If we get a ENOSPC, it means
 +		 * things changed while we were calculating fdblks_delta and so
 +		 * we should try again to see if there is anything left to
 +		 * reserve.
 +		 *
 +		 * Don't set the reserved flag here - we don't want to reserve
 +		 * the extra reserve blocks from the reserve.....
++=======
+ 		 * count or we'll get an ENOSPC.  Don't set the reserved flag
+ 		 * here - we don't want to reserve the extra reserve blocks
+ 		 * from the reserve.
+ 		 *
+ 		 * The desired reserve size can change after we drop the lock.
+ 		 * Use mod_fdblocks to put the space into the reserve or into
+ 		 * fdblocks as appropriate.
++>>>>>>> 82be38bcf8a2 (xfs: fix overfilling of reserve pool)
  		 */
 -		fdblks_delta = min(free, delta);
  		spin_unlock(&mp->m_sb_lock);
  		error = xfs_mod_fdblocks(mp, -fdblks_delta, 0);
++<<<<<<< HEAD
 +		spin_lock(&mp->m_sb_lock);
 +	} while (error == -ENOSPC);
 +
 +	/*
 +	 * Update the reserve counters if blocks have been successfully
 +	 * allocated.
 +	 */
 +	if (!error && fdblks_delta) {
 +		mp->m_resblks += fdblks_delta;
 +		mp->m_resblks_avail += fdblks_delta;
++=======
+ 		if (!error)
+ 			xfs_mod_fdblocks(mp, fdblks_delta, 0);
+ 		spin_lock(&mp->m_sb_lock);
++>>>>>>> 82be38bcf8a2 (xfs: fix overfilling of reserve pool)
  	}
 +
  out:
  	if (outval) {
  		outval->resblks = mp->m_resblks;
* Unmerged path fs/xfs/xfs_fsops.c
