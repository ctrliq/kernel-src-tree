KVM: arm64: PMU: Don't save PMCR_EL0.{C,P} for the vCPU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Reiji Watanabe <reijiw@google.com>
commit f6da81f650fa47b61b847488f3938d43f90d093d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/f6da81f6.failed

Presently, when a guest writes 1 to PMCR_EL0.{C,P}, which is WO/RAZ,
KVM saves the register value, including these bits.
When userspace reads the register using KVM_GET_ONE_REG, KVM returns
the saved register value as it is (the saved value might have these
bits set).  This could result in userspace setting these bits on the
destination during migration.  Consequently, KVM may end up resetting
the vPMU counter registers (PMCCNTR_EL0 and/or PMEVCNTR<n>_EL0) to
zero on the first KVM_RUN after migration.

Fix this by not saving those bits when a guest writes 1 to those bits.

Fixes: ab9468340d2b ("arm64: KVM: Add access handler for PMCR register")
	Cc: stable@vger.kernel.org
	Reviewed-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Reiji Watanabe <reijiw@google.com>
Link: https://lore.kernel.org/r/20230313033234.1475987-1-reijiw@google.com
	Signed-off-by: Oliver Upton <oliver.upton@linux.dev>
(cherry picked from commit f6da81f650fa47b61b847488f3938d43f90d093d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/pmu-emul.c
diff --cc arch/arm64/kvm/pmu-emul.c
index a4e7294c3e8c,c243b10f3e15..000000000000
--- a/arch/arm64/kvm/pmu-emul.c
+++ b/arch/arm64/kvm/pmu-emul.c
@@@ -560,14 -529,24 +560,27 @@@ void kvm_pmu_software_increment(struct 
   */
  void kvm_pmu_handle_pmcr(struct kvm_vcpu *vcpu, u64 val)
  {
 +	unsigned long mask = kvm_pmu_valid_counter_mask(vcpu);
  	int i;
  
++<<<<<<< HEAD
++=======
+ 	if (!kvm_vcpu_has_pmu(vcpu))
+ 		return;
+ 
+ 	/* Fixup PMCR_EL0 to reconcile the PMU version and the LP bit */
+ 	if (!kvm_pmu_is_3p5(vcpu))
+ 		val &= ~ARMV8_PMU_PMCR_LP;
+ 
+ 	/* The reset bits don't indicate any state, and shouldn't be saved. */
+ 	__vcpu_sys_reg(vcpu, PMCR_EL0) = val & ~(ARMV8_PMU_PMCR_C | ARMV8_PMU_PMCR_P);
+ 
++>>>>>>> f6da81f650fa (KVM: arm64: PMU: Don't save PMCR_EL0.{C,P} for the vCPU)
  	if (val & ARMV8_PMU_PMCR_E) {
  		kvm_pmu_enable_counter_mask(vcpu,
 -		       __vcpu_sys_reg(vcpu, PMCNTENSET_EL0));
 +		       __vcpu_sys_reg(vcpu, PMCNTENSET_EL0) & mask);
  	} else {
 -		kvm_pmu_disable_counter_mask(vcpu,
 -		       __vcpu_sys_reg(vcpu, PMCNTENSET_EL0));
 +		kvm_pmu_disable_counter_mask(vcpu, mask);
  	}
  
  	if (val & ARMV8_PMU_PMCR_C)
* Unmerged path arch/arm64/kvm/pmu-emul.c
