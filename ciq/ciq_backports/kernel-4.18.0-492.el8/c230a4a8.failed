xfs: fix potential log item leak

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Dave Chinner <dchinner@redhat.com>
commit c230a4a85bcdbfc1a7415deec6caf04e8fca1301
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/c230a4a8.failed

Ever since we added shadown format buffers to the log items, log
items need to handle the item being released with shadow buffers
attached. Due to the fact this requirement was added at the same
time we added new rmap/reflink intents, we missed the cleanup of
those items.

In theory, this means shadow buffers can be leaked in a very small
window when a shutdown is initiated. Testing with KASAN shows this
leak does not happen in practice - we haven't identified a single
leak in several years of shutdown testing since ~v4.8 kernels.

However, the intent whiteout cleanup mechanism results in every
cancelled intent in exactly the same state as this tiny race window
creates and so if intents down clean up shadow buffers on final
release we will leak the shadow buffer for just about every intent
we create.

Hence we start with this patch to close this condition off and
ensure that when whiteouts start to be used we don't leak lots of
memory.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Allison Henderson <allison.henderson@oracle.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit c230a4a85bcdbfc1a7415deec6caf04e8fca1301)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_item.c
#	fs/xfs/xfs_icreate_item.c
#	fs/xfs/xfs_refcount_item.c
#	fs/xfs/xfs_rmap_item.c
diff --cc fs/xfs/xfs_bmap_item.c
index 2344757ede63,2c8b686e2a11..000000000000
--- a/fs/xfs/xfs_bmap_item.c
+++ b/fs/xfs/xfs_bmap_item.c
@@@ -40,7 -39,8 +40,12 @@@ STATIC voi
  xfs_bui_item_free(
  	struct xfs_bui_log_item	*buip)
  {
++<<<<<<< HEAD
 +	kmem_cache_free(xfs_bui_zone, buip);
++=======
+ 	kmem_free(buip->bui_item.li_lv_shadow);
+ 	kmem_cache_free(xfs_bui_cache, buip);
++>>>>>>> c230a4a85bcd (xfs: fix potential log item leak)
  }
  
  /*
@@@ -199,7 -199,8 +204,12 @@@ xfs_bud_item_release
  	struct xfs_bud_log_item	*budp = BUD_ITEM(lip);
  
  	xfs_bui_release(budp->bud_buip);
++<<<<<<< HEAD
 +	kmem_cache_free(xfs_bud_zone, budp);
++=======
+ 	kmem_free(budp->bud_item.li_lv_shadow);
+ 	kmem_cache_free(xfs_bud_cache, budp);
++>>>>>>> c230a4a85bcd (xfs: fix potential log item leak)
  }
  
  static const struct xfs_item_ops xfs_bud_item_ops = {
diff --cc fs/xfs/xfs_icreate_item.c
index 9b3994b9c716,b05314d48176..000000000000
--- a/fs/xfs/xfs_icreate_item.c
+++ b/fs/xfs/xfs_icreate_item.c
@@@ -63,7 -63,8 +63,12 @@@ STATIC voi
  xfs_icreate_item_release(
  	struct xfs_log_item	*lip)
  {
++<<<<<<< HEAD
 +	kmem_cache_free(xfs_icreate_zone, ICR_ITEM(lip));
++=======
+ 	kmem_free(ICR_ITEM(lip)->ic_item.li_lv_shadow);
+ 	kmem_cache_free(xfs_icreate_cache, ICR_ITEM(lip));
++>>>>>>> c230a4a85bcd (xfs: fix potential log item leak)
  }
  
  static const struct xfs_item_ops xfs_icreate_item_ops = {
diff --cc fs/xfs/xfs_refcount_item.c
index 07ebccbbf4df,10474fe389e1..000000000000
--- a/fs/xfs/xfs_refcount_item.c
+++ b/fs/xfs/xfs_refcount_item.c
@@@ -204,7 -205,8 +205,12 @@@ xfs_cud_item_release
  	struct xfs_cud_log_item	*cudp = CUD_ITEM(lip);
  
  	xfs_cui_release(cudp->cud_cuip);
++<<<<<<< HEAD
 +	kmem_cache_free(xfs_cud_zone, cudp);
++=======
+ 	kmem_free(cudp->cud_item.li_lv_shadow);
+ 	kmem_cache_free(xfs_cud_cache, cudp);
++>>>>>>> c230a4a85bcd (xfs: fix potential log item leak)
  }
  
  static const struct xfs_item_ops xfs_cud_item_ops = {
diff --cc fs/xfs/xfs_rmap_item.c
index 49cebd68b672,6c0b56ebdbe1..000000000000
--- a/fs/xfs/xfs_rmap_item.c
+++ b/fs/xfs/xfs_rmap_item.c
@@@ -227,7 -228,8 +228,12 @@@ xfs_rud_item_release
  	struct xfs_rud_log_item	*rudp = RUD_ITEM(lip);
  
  	xfs_rui_release(rudp->rud_ruip);
++<<<<<<< HEAD
 +	kmem_cache_free(xfs_rud_zone, rudp);
++=======
+ 	kmem_free(rudp->rud_item.li_lv_shadow);
+ 	kmem_cache_free(xfs_rud_cache, rudp);
++>>>>>>> c230a4a85bcd (xfs: fix potential log item leak)
  }
  
  static const struct xfs_item_ops xfs_rud_item_ops = {
* Unmerged path fs/xfs/xfs_bmap_item.c
* Unmerged path fs/xfs/xfs_icreate_item.c
* Unmerged path fs/xfs/xfs_refcount_item.c
* Unmerged path fs/xfs/xfs_rmap_item.c
