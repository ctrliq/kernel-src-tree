iomap: Fix inline extent handling in iomap_readpage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit d8af404ffce71448f29bbc19a05e3d095baf98eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/d8af404f.failed

Before commit 740499c78408 ("iomap: fix the iomap_readpage_actor return
value for inline data"), when hitting an IOMAP_INLINE extent,
iomap_readpage_actor would report having read the entire page.  Since
then, it only reports having read the inline data (iomap->length).

This will force iomap_readpage into another iteration, and the
filesystem will report an unaligned hole after the IOMAP_INLINE extent.
But iomap_readpage_actor (now iomap_readpage_iter) isn't prepared to
deal with unaligned extents, it will get things wrong on filesystems
with a block size smaller than the page size, and we'll eventually run
into the following warning in iomap_iter_advance:

  WARN_ON_ONCE(iter->processed > iomap_length(iter));

Fix that by changing iomap_readpage_iter to return 0 when hitting an
inline extent; this will cause iomap_iter to stop immediately.

To fix readahead as well, change iomap_readahead_iter to pass on
iomap_readpage_iter return values less than or equal to zero.

Fixes: 740499c78408 ("iomap: fix the iomap_readpage_actor return value for inline data")
	Cc: stable@vger.kernel.org # v5.15+
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit d8af404ffce71448f29bbc19a05e3d095baf98eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/buffered-io.c
diff --cc fs/iomap/buffered-io.c
index a9fecbda715a,fe10d8a30f6b..000000000000
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@@ -268,12 -256,17 +268,22 @@@ iomap_readpage_actor(struct inode *inod
  	unsigned poff, plen;
  	sector_t sector;
  
++<<<<<<< HEAD
 +	if (iomap->type == IOMAP_INLINE)
 +		return min(iomap_read_inline_data(inode, page, iomap), length);
++=======
+ 	if (iomap->type == IOMAP_INLINE) {
+ 		loff_t ret = iomap_read_inline_data(iter, page);
+ 
+ 		if (ret < 0)
+ 			return ret;
+ 		return 0;
+ 	}
++>>>>>>> d8af404ffce7 (iomap: Fix inline extent handling in iomap_readpage)
  
  	/* zero post-eof blocks as the page may be mapped */
 -	iop = iomap_page_create(iter->inode, page);
 -	iomap_adjust_read_range(iter->inode, iop, &pos, length, &poff, &plen);
 +	iop = iomap_page_create(inode, page);
 +	iomap_adjust_read_range(inode, iop, &pos, length, &poff, &plen);
  	if (plen == 0)
  		goto done;
  
@@@ -396,8 -374,9 +406,14 @@@ iomap_readahead_actor(struct inode *ino
  			ctx->cur_page = readahead_page(ctx->rac);
  			ctx->cur_page_in_bio = false;
  		}
++<<<<<<< HEAD
 +		ret = iomap_readpage_actor(inode, pos + done, length - done,
 +				ctx, iomap, srcmap);
++=======
+ 		ret = iomap_readpage_iter(iter, ctx, done);
+ 		if (ret <= 0)
+ 			return ret;
++>>>>>>> d8af404ffce7 (iomap: Fix inline extent handling in iomap_readpage)
  	}
  
  	return done;
* Unmerged path fs/iomap/buffered-io.c
