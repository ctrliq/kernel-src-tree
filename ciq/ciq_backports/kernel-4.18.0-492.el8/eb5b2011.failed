iommu/vt-d: Avoid unnecessary global IRTE cache invalidation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit eb5b20114b9710d1dcd4118dbf01b081c104bbc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/eb5b2011.failed

Some VT-d hardware implementations invalidate all interrupt remapping
hardware translation caches as part of SIRTP flow. The VT-d spec adds
a ESIRTPS (Enhanced Set Interrupt Remap Table Pointer Support, section
11.4.2 in VT-d spec) capability bit to indicate this.

The spec also states in 11.4.4 that hardware also performs global
invalidation on all interrupt remapping caches as part of Interrupt
Remapping Disable operation if ESIRTPS capability bit is set.

This checks the ESIRTPS capability bit and skip software global cache
invalidation if it's set.

	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
	Reviewed-by: Kevin Tian <kevin.tian@intel.com>
Link: https://lore.kernel.org/r/20220921065741.3572495-1-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit eb5b20114b9710d1dcd4118dbf01b081c104bbc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/intel-iommu.h
diff --cc include/linux/intel-iommu.h
index fcd9af6275ba,bddf6c69587d..000000000000
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@@ -157,7 -146,8 +157,12 @@@
  /*
   * Decoding Capability Register
   */
++<<<<<<< HEAD:include/linux/intel-iommu.h
 +#define cap_5lp_support(c)	(((c) >> 60) & 1)
++=======
+ #define cap_esirtps(c)		(((c) >> 62) & 1)
+ #define cap_fl5lp_support(c)	(((c) >> 60) & 1)
++>>>>>>> eb5b20114b97 (iommu/vt-d: Avoid unnecessary global IRTE cache invalidation):drivers/iommu/intel/iommu.h
  #define cap_pi_support(c)	(((c) >> 59) & 1)
  #define cap_fl1gp_support(c)	(((c) >> 56) & 1)
  #define cap_read_drain(c)	(((c) >> 55) & 1)
diff --git a/drivers/iommu/intel/irq_remapping.c b/drivers/iommu/intel/irq_remapping.c
index 52954ff11df7..782246ace733 100644
--- a/drivers/iommu/intel/irq_remapping.c
+++ b/drivers/iommu/intel/irq_remapping.c
@@ -500,7 +500,8 @@ static void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)
 	 * Global invalidation of interrupt entry cache to make sure the
 	 * hardware uses the new irq remapping table.
 	 */
-	qi_global_iec(iommu);
+	if (!cap_esirtps(iommu->cap))
+		qi_global_iec(iommu);
 }
 
 static void iommu_enable_irq_remapping(struct intel_iommu *iommu)
@@ -686,7 +687,8 @@ static void iommu_disable_irq_remapping(struct intel_iommu *iommu)
 	 * global invalidation of interrupt entry cache before disabling
 	 * interrupt-remapping.
 	 */
-	qi_global_iec(iommu);
+	if (!cap_esirtps(iommu->cap))
+		qi_global_iec(iommu);
 
 	raw_spin_lock_irqsave(&iommu->register_lock, flags);
 
* Unmerged path include/linux/intel-iommu.h
