fuse: wait for writepages in syncfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 660585b56e63ca034ad506ea53c807c5cdca3196
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/660585b5.failed

In case of fuse the MM subsystem doesn't guarantee that page writeback
completes by the time ->sync_fs() is called.  This is because fuse
completes page writeback immediately to prevent DoS of memory reclaim by
the userspace file server.

This means that fuse itself must ensure that writes are synced before
sending the SYNCFS request to the server.

Introduce sync buckets, that hold a counter for the number of outstanding
write requests.  On syncfs replace the current bucket with a new one and
wait until the old bucket's counter goes down to zero.

It is possible to have multiple syncfs calls in parallel, in which case
there could be more than one waited-on buckets.  Descendant buckets must
not complete until the parent completes.  Add a count to the child (new)
bucket until the (parent) old bucket completes.

Use RCU protection to dereference the current bucket and to wake up an
emptied bucket.  Use fc->lock to protect against parallel assignments to
the current bucket.

This leaves just the counter to be a possible scalability issue.  The
fc->num_waiting counter has a similar issue, so both should be addressed at
the same time.

	Reported-by: Amir Goldstein <amir73il@gmail.com>
Fixes: 2d82ab251ef0 ("virtiofs: propagate sync() to file server")
	Cc: <stable@vger.kernel.org> # v5.14
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 660585b56e63ca034ad506ea53c807c5cdca3196)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/fuse_i.h
#	fs/fuse/inode.c
diff --cc fs/fuse/fuse_i.h
index a9efff536da9,f166e24dd48b..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -876,6 -899,37 +886,40 @@@ static inline bool fuse_is_bad(struct i
  	return unlikely(test_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state));
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
+ 					     struct fuse_page_desc **desc)
+ {
+ 	struct page **pages;
+ 
+ 	pages = kzalloc(npages * (sizeof(struct page *) +
+ 				  sizeof(struct fuse_page_desc)), flags);
+ 	*desc = (void *) (pages + npages);
+ 
+ 	return pages;
+ }
+ 
+ static inline void fuse_page_descs_length_init(struct fuse_page_desc *descs,
+ 					       unsigned int index,
+ 					       unsigned int nr_pages)
+ {
+ 	int i;
+ 
+ 	for (i = index; i < index + nr_pages; i++)
+ 		descs[i].length = PAGE_SIZE - descs[i].offset;
+ }
+ 
+ static inline void fuse_sync_bucket_dec(struct fuse_sync_bucket *bucket)
+ {
+ 	/* Need RCU protection to prevent use after free after the decrement */
+ 	rcu_read_lock();
+ 	if (atomic_dec_and_test(&bucket->count))
+ 		wake_up(&bucket->waitq);
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> 660585b56e63 (fuse: wait for writepages in syncfs)
  /** Device operations */
  extern const struct file_operations fuse_dev_operations;
  
diff --cc fs/fuse/inode.c
index 4bd2074981c1,2187211893ff..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -510,6 -506,98 +510,101 @@@ static int fuse_statfs(struct dentry *d
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct fuse_sync_bucket *fuse_sync_bucket_alloc(void)
+ {
+ 	struct fuse_sync_bucket *bucket;
+ 
+ 	bucket = kzalloc(sizeof(*bucket), GFP_KERNEL | __GFP_NOFAIL);
+ 	if (bucket) {
+ 		init_waitqueue_head(&bucket->waitq);
+ 		/* Initial active count */
+ 		atomic_set(&bucket->count, 1);
+ 	}
+ 	return bucket;
+ }
+ 
+ static void fuse_sync_fs_writes(struct fuse_conn *fc)
+ {
+ 	struct fuse_sync_bucket *bucket, *new_bucket;
+ 	int count;
+ 
+ 	new_bucket = fuse_sync_bucket_alloc();
+ 	spin_lock(&fc->lock);
+ 	bucket = rcu_dereference_protected(fc->curr_bucket, 1);
+ 	count = atomic_read(&bucket->count);
+ 	WARN_ON(count < 1);
+ 	/* No outstanding writes? */
+ 	if (count == 1) {
+ 		spin_unlock(&fc->lock);
+ 		kfree(new_bucket);
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * Completion of new bucket depends on completion of this bucket, so add
+ 	 * one more count.
+ 	 */
+ 	atomic_inc(&new_bucket->count);
+ 	rcu_assign_pointer(fc->curr_bucket, new_bucket);
+ 	spin_unlock(&fc->lock);
+ 	/*
+ 	 * Drop initial active count.  At this point if all writes in this and
+ 	 * ancestor buckets complete, the count will go to zero and this task
+ 	 * will be woken up.
+ 	 */
+ 	atomic_dec(&bucket->count);
+ 
+ 	wait_event(bucket->waitq, atomic_read(&bucket->count) == 0);
+ 
+ 	/* Drop temp count on descendant bucket */
+ 	fuse_sync_bucket_dec(new_bucket);
+ 	kfree_rcu(bucket, rcu);
+ }
+ 
+ static int fuse_sync_fs(struct super_block *sb, int wait)
+ {
+ 	struct fuse_mount *fm = get_fuse_mount_super(sb);
+ 	struct fuse_conn *fc = fm->fc;
+ 	struct fuse_syncfs_in inarg;
+ 	FUSE_ARGS(args);
+ 	int err;
+ 
+ 	/*
+ 	 * Userspace cannot handle the wait == 0 case.  Avoid a
+ 	 * gratuitous roundtrip.
+ 	 */
+ 	if (!wait)
+ 		return 0;
+ 
+ 	/* The filesystem is being unmounted.  Nothing to do. */
+ 	if (!sb->s_root)
+ 		return 0;
+ 
+ 	if (!fc->sync_fs)
+ 		return 0;
+ 
+ 	fuse_sync_fs_writes(fc);
+ 
+ 	memset(&inarg, 0, sizeof(inarg));
+ 	args.in_numargs = 1;
+ 	args.in_args[0].size = sizeof(inarg);
+ 	args.in_args[0].value = &inarg;
+ 	args.opcode = FUSE_SYNCFS;
+ 	args.nodeid = get_node_id(sb->s_root->d_inode);
+ 	args.out_numargs = 0;
+ 
+ 	err = fuse_simple_request(fm, &args);
+ 	if (err == -ENOSYS) {
+ 		fc->sync_fs = 0;
+ 		err = 0;
+ 	}
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 660585b56e63 (fuse: wait for writepages in syncfs)
  enum {
  	OPT_SOURCE,
  	OPT_SUBTYPE,
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index f0fa5fbbcc57..62719361c7f9 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -383,6 +383,7 @@ struct fuse_writepage_args {
 	struct list_head queue_entry;
 	struct fuse_writepage_args *next;
 	struct inode *inode;
+	struct fuse_sync_bucket *bucket;
 };
 
 static struct fuse_writepage_args *fuse_find_writeback(struct fuse_inode *fi,
@@ -1668,6 +1669,9 @@ static void fuse_writepage_free(struct fuse_writepage_args *wpa)
 	struct fuse_args_pages *ap = &wpa->ia.ap;
 	int i;
 
+	if (wpa->bucket)
+		fuse_sync_bucket_dec(wpa->bucket);
+
 	for (i = 0; i < ap->num_pages; i++)
 		__free_page(ap->pages[i]);
 
@@ -1931,6 +1935,20 @@ static struct fuse_writepage_args *fuse_writepage_args_alloc(void)
 
 }
 
+static void fuse_writepage_add_to_bucket(struct fuse_conn *fc,
+					 struct fuse_writepage_args *wpa)
+{
+	if (!fc->sync_fs)
+		return;
+
+	rcu_read_lock();
+	/* Prevent resurrection of dead bucket in unlikely race with syncfs */
+	do {
+		wpa->bucket = rcu_dereference(fc->curr_bucket);
+	} while (unlikely(!atomic_inc_not_zero(&wpa->bucket->count)));
+	rcu_read_unlock();
+}
+
 static int fuse_writepage_locked(struct page *page)
 {
 	struct address_space *mapping = page->mapping;
@@ -1958,6 +1976,7 @@ static int fuse_writepage_locked(struct page *page)
 	if (!wpa->ia.ff)
 		goto err_nofile;
 
+	fuse_writepage_add_to_bucket(fc, wpa);
 	fuse_write_args_fill(&wpa->ia, wpa->ia.ff, page_offset(page), 0);
 
 	copy_highpage(tmp_page, page);
@@ -2208,6 +2227,8 @@ static int fuse_writepages_fill(struct page *page,
 			__free_page(tmp_page);
 			goto out_unlock;
 		}
+		fuse_writepage_add_to_bucket(fc, wpa);
+
 		data->max_pages = 1;
 
 		ap = &wpa->ia.ap;
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path fs/fuse/inode.c
