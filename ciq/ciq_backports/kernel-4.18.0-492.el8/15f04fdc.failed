xfs: remove infinite loop when reserving free block pool

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 15f04fdc75aaaa1cccb0b8b3af1be290e118a7bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/15f04fdc.failed

Infinite loops in kernel code are scary.  Calls to xfs_reserve_blocks
should be rare (people should just use the defaults!) so we really don't
need to try so hard.  Simplify the logic here by removing the infinite
loop.

	Cc: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 15f04fdc75aaaa1cccb0b8b3af1be290e118a7bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsops.c
diff --cc fs/xfs/xfs_fsops.c
index 88edfa51e5ca,3c6d9d6836ef..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -435,32 -430,23 +435,41 @@@ xfs_reserve_blocks
  	 * If the request is larger than the current reservation, reserve the
  	 * blocks before we update the reserve counters. Sample m_fdblocks and
  	 * perform a partial reservation if the request exceeds free space.
+ 	 *
+ 	 * The code below estimates how many blocks it can request from
+ 	 * fdblocks to stash in the reserve pool.  This is a classic TOCTOU
+ 	 * race since fdblocks updates are not always coordinated via
+ 	 * m_sb_lock.
  	 */
++<<<<<<< HEAD
 +	error = -ENOSPC;
 +	do {
 +		free = percpu_counter_sum(&mp->m_fdblocks) -
 +						mp->m_alloc_set_aside;
 +		if (free <= 0)
 +			break;
 +
 +		delta = request - mp->m_resblks;
 +		lcounter = free - delta;
 +		if (lcounter < 0)
 +			/* We can't satisfy the request, just get what we can */
 +			fdblks_delta = free;
 +		else
 +			fdblks_delta = delta;
 +
++=======
+ 	free = percpu_counter_sum(&mp->m_fdblocks) -
+ 						xfs_fdblocks_unavailable(mp);
+ 	delta = request - mp->m_resblks;
+ 	if (delta > 0 && free > 0) {
++>>>>>>> 15f04fdc75aa (xfs: remove infinite loop when reserving free block pool)
  		/*
  		 * We'll either succeed in getting space from the free block
- 		 * count or we'll get an ENOSPC. If we get a ENOSPC, it means
- 		 * things changed while we were calculating fdblks_delta and so
- 		 * we should try again to see if there is anything left to
- 		 * reserve.
- 		 *
- 		 * Don't set the reserved flag here - we don't want to reserve
- 		 * the extra reserve blocks from the reserve.....
+ 		 * count or we'll get an ENOSPC.  Don't set the reserved flag
+ 		 * here - we don't want to reserve the extra reserve blocks
+ 		 * from the reserve.
  		 */
+ 		fdblks_delta = min(free, delta);
  		spin_unlock(&mp->m_sb_lock);
  		error = xfs_mod_fdblocks(mp, -fdblks_delta, 0);
  		spin_lock(&mp->m_sb_lock);
* Unmerged path fs/xfs/xfs_fsops.c
