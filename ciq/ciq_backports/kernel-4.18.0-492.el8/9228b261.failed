KVM: arm64: PMU: Fix GET_ONE_REG for vPMC regs to return the current value

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Reiji Watanabe <reijiw@google.com>
commit 9228b26194d1cc00449f12f306f53ef2e234a55b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/9228b261.failed

Have KVM_GET_ONE_REG for vPMU counter (vPMC) registers (PMCCNTR_EL0
and PMEVCNTR<n>_EL0) return the sum of the register value in the sysreg
file and the current perf event counter value.

Values of vPMC registers are saved in sysreg files on certain occasions.
These saved values don't represent the current values of the vPMC
registers if the perf events for the vPMCs count events after the save.
The current values of those registers are the sum of the sysreg file
value and the current perf event counter value.  But, when userspace
reads those registers (using KVM_GET_ONE_REG), KVM returns the sysreg
file value to userspace (not the sum value).

Fix this to return the sum value for KVM_GET_ONE_REG.

Fixes: 051ff581ce70 ("arm64: KVM: Add access handler for event counter register")
	Cc: stable@vger.kernel.org
	Reviewed-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Reiji Watanabe <reijiw@google.com>
Link: https://lore.kernel.org/r/20230313033208.1475499-1-reijiw@google.com
	Signed-off-by: Oliver Upton <oliver.upton@linux.dev>
(cherry picked from commit 9228b26194d1cc00449f12f306f53ef2e234a55b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/sys_regs.c
diff --cc arch/arm64/kvm/sys_regs.c
index 9b1b80dadfc3,1b2c161120be..000000000000
--- a/arch/arm64/kvm/sys_regs.c
+++ b/arch/arm64/kvm/sys_regs.c
@@@ -1063,10 -1082,14 +1079,16 @@@ static bool access_pmuserenr(struct kvm
  	{ SYS_DESC(SYS_DBGWCRn_EL1(n)),					\
  	  trap_wcr, reset_wcr, 0, 0,  get_wcr, set_wcr }
  
 -#define PMU_SYS_REG(r)						\
 -	SYS_DESC(r), .reset = reset_pmu_reg, .visibility = pmu_visibility
 -
  /* Macro to expand the PMEVCNTRn_EL0 register */
  #define PMU_PMEVCNTR_EL0(n)						\
++<<<<<<< HEAD
 +	{ SYS_DESC(SYS_PMEVCNTRn_EL0(n)),					\
 +	  access_pmu_evcntr, reset_unknown, (PMEVCNTR0_EL0 + n), }
++=======
+ 	{ PMU_SYS_REG(SYS_PMEVCNTRn_EL0(n)),				\
+ 	  .reset = reset_pmevcntr, .get_user = get_pmu_evcntr,		\
+ 	  .access = access_pmu_evcntr, .reg = (PMEVCNTR0_EL0 + n), }
++>>>>>>> 9228b26194d1 (KVM: arm64: PMU: Fix GET_ONE_REG for vPMC regs to return the current value)
  
  /* Macro to expand the PMEVTYPERn_EL0 register */
  #define PMU_PMEVTYPER_EL0(n)						\
@@@ -1658,21 -1968,42 +1680,52 @@@ static const struct sys_reg_desc sys_re
  	{ SYS_DESC(SYS_CNTKCTL_EL1), NULL, reset_val, CNTKCTL_EL1, 0},
  
  	{ SYS_DESC(SYS_CCSIDR_EL1), access_ccsidr },
 -	{ SYS_DESC(SYS_CLIDR_EL1), access_clidr, reset_clidr, CLIDR_EL1,
 -	  .set_user = set_clidr },
 -	{ SYS_DESC(SYS_CCSIDR2_EL1), undef_access },
 -	{ SYS_DESC(SYS_SMIDR_EL1), undef_access },
 +	{ SYS_DESC(SYS_CLIDR_EL1), access_clidr },
  	{ SYS_DESC(SYS_CSSELR_EL1), access_csselr, reset_unknown, CSSELR_EL1 },
  	{ SYS_DESC(SYS_CTR_EL0), access_ctr },
 -	{ SYS_DESC(SYS_SVCR), undef_access },
  
++<<<<<<< HEAD
 +	{ SYS_DESC(SYS_PMCR_EL0), access_pmcr, reset_pmcr, PMCR_EL0 },
 +	{ SYS_DESC(SYS_PMCNTENSET_EL0), access_pmcnten, reset_unknown, PMCNTENSET_EL0 },
 +	{ SYS_DESC(SYS_PMCNTENCLR_EL0), access_pmcnten, reset_unknown, PMCNTENSET_EL0 },
 +	{ SYS_DESC(SYS_PMOVSCLR_EL0), access_pmovs, reset_unknown, PMOVSSET_EL0 },
 +	{ SYS_DESC(SYS_PMSWINC_EL0), access_pmswinc, reset_unknown, PMSWINC_EL0 },
 +	{ SYS_DESC(SYS_PMSELR_EL0), access_pmselr, reset_unknown, PMSELR_EL0 },
 +	{ SYS_DESC(SYS_PMCEID0_EL0), access_pmceid },
 +	{ SYS_DESC(SYS_PMCEID1_EL0), access_pmceid },
 +	{ SYS_DESC(SYS_PMCCNTR_EL0), access_pmu_evcntr, reset_unknown, PMCCNTR_EL0 },
 +	{ SYS_DESC(SYS_PMXEVTYPER_EL0), access_pmu_evtyper },
 +	{ SYS_DESC(SYS_PMXEVCNTR_EL0), access_pmu_evcntr },
++=======
+ 	{ PMU_SYS_REG(SYS_PMCR_EL0), .access = access_pmcr,
+ 	  .reset = reset_pmcr, .reg = PMCR_EL0 },
+ 	{ PMU_SYS_REG(SYS_PMCNTENSET_EL0),
+ 	  .access = access_pmcnten, .reg = PMCNTENSET_EL0 },
+ 	{ PMU_SYS_REG(SYS_PMCNTENCLR_EL0),
+ 	  .access = access_pmcnten, .reg = PMCNTENSET_EL0 },
+ 	{ PMU_SYS_REG(SYS_PMOVSCLR_EL0),
+ 	  .access = access_pmovs, .reg = PMOVSSET_EL0 },
+ 	/*
+ 	 * PM_SWINC_EL0 is exposed to userspace as RAZ/WI, as it was
+ 	 * previously (and pointlessly) advertised in the past...
+ 	 */
+ 	{ PMU_SYS_REG(SYS_PMSWINC_EL0),
+ 	  .get_user = get_raz_reg, .set_user = set_wi_reg,
+ 	  .access = access_pmswinc, .reset = NULL },
+ 	{ PMU_SYS_REG(SYS_PMSELR_EL0),
+ 	  .access = access_pmselr, .reset = reset_pmselr, .reg = PMSELR_EL0 },
+ 	{ PMU_SYS_REG(SYS_PMCEID0_EL0),
+ 	  .access = access_pmceid, .reset = NULL },
+ 	{ PMU_SYS_REG(SYS_PMCEID1_EL0),
+ 	  .access = access_pmceid, .reset = NULL },
+ 	{ PMU_SYS_REG(SYS_PMCCNTR_EL0),
+ 	  .access = access_pmu_evcntr, .reset = reset_unknown,
+ 	  .reg = PMCCNTR_EL0, .get_user = get_pmu_evcntr},
+ 	{ PMU_SYS_REG(SYS_PMXEVTYPER_EL0),
+ 	  .access = access_pmu_evtyper, .reset = NULL },
+ 	{ PMU_SYS_REG(SYS_PMXEVCNTR_EL0),
+ 	  .access = access_pmu_evcntr, .reset = NULL },
++>>>>>>> 9228b26194d1 (KVM: arm64: PMU: Fix GET_ONE_REG for vPMC regs to return the current value)
  	/*
  	 * PMUSERENR_EL0 resets as unknown in 64bit mode while it resets as zero
  	 * in 32bit mode. Here we choose to reset it as zero for consistency.
* Unmerged path arch/arm64/kvm/sys_regs.c
