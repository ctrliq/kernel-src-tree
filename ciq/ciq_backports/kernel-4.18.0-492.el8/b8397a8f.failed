iommu/dma: Explicitly sort PCI DMA windows

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit b8397a8f4ebc0b84eefd990dc08995ba2ae9015c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/b8397a8f.failed

Originally, creating the dma_ranges resource list in pre-sorted fashion
was the simplest and most efficient way to enforce the order required by
iova_reserve_pci_windows(). However since then at least one PCI host
driver is now re-sorting the list for its own probe-time processing,
which doesn't seem entirely unreasonable, so that basic assumption no
longer holds. Make iommu-dma robust and get the sort order it needs by
explicitly sorting, which means we can also save the effort at creation
time and just build the list in whatever natural order the DT had.

	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
	Reviewed-by: Rob Herring <robh@kernel.org>
Link: https://lore.kernel.org/r/35661036a7e4160850895f9b37f35408b6a29f2f.1652091160.git.robin.murphy@arm.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit b8397a8f4ebc0b84eefd990dc08995ba2ae9015c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/of.c
diff --cc drivers/pci/of.c
index 4c620c773d14,8f0ebaf9ae85..000000000000
--- a/drivers/pci/of.c
+++ b/drivers/pci/of.c
@@@ -354,6 -360,42 +354,45 @@@ int devm_of_pci_get_host_bridge_resourc
  		pci_add_resource_offset(resources, res,	res->start - range.pci_addr);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Check for dma-ranges property */
+ 	if (!ib_resources)
+ 		return 0;
+ 	err = of_pci_dma_range_parser_init(&parser, dev_node);
+ 	if (err)
+ 		return 0;
+ 
+ 	dev_dbg(dev, "Parsing dma-ranges property...\n");
+ 	for_each_of_pci_range(&parser, &range) {
+ 		/*
+ 		 * If we failed translation or got a zero-sized region
+ 		 * then skip this range
+ 		 */
+ 		if (((range.flags & IORESOURCE_TYPE_BITS) != IORESOURCE_MEM) ||
+ 		    range.cpu_addr == OF_BAD_ADDR || range.size == 0)
+ 			continue;
+ 
+ 		dev_info(dev, "  %6s %#012llx..%#012llx -> %#012llx\n",
+ 			 "IB MEM", range.cpu_addr,
+ 			 range.cpu_addr + range.size - 1, range.pci_addr);
+ 
+ 
+ 		err = of_pci_range_to_resource(&range, dev_node, &tmp_res);
+ 		if (err)
+ 			continue;
+ 
+ 		res = devm_kmemdup(dev, &tmp_res, sizeof(tmp_res), GFP_KERNEL);
+ 		if (!res) {
+ 			err = -ENOMEM;
+ 			goto failed;
+ 		}
+ 
+ 		pci_add_resource_offset(ib_resources, res,
+ 					res->start - range.pci_addr);
+ 	}
+ 
++>>>>>>> b8397a8f4ebc (iommu/dma: Explicitly sort PCI DMA windows)
  	return 0;
  
  failed:
diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c
index 4d6e282a8626..f6f65e20c171 100644
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -32,6 +32,7 @@
 #include <linux/iommu.h>
 #include <linux/iova.h>
 #include <linux/irq.h>
+#include <linux/list_sort.h>
 #include <linux/mm.h>
 #include <linux/mutex.h>
 #include <linux/pci.h>
@@ -428,6 +429,15 @@ static int cookie_init_hw_msi_region(struct iommu_dma_cookie *cookie,
 	return 0;
 }
 
+static int iommu_dma_ranges_sort(void *priv, const struct list_head *a,
+		const struct list_head *b)
+{
+	struct resource_entry *res_a = list_entry(a, typeof(*res_a), node);
+	struct resource_entry *res_b = list_entry(b, typeof(*res_b), node);
+
+	return res_a->res->start > res_b->res->start;
+}
+
 static int iova_reserve_pci_windows(struct pci_dev *dev,
 		struct iova_domain *iovad)
 {
@@ -446,6 +456,7 @@ static int iova_reserve_pci_windows(struct pci_dev *dev,
 	}
 
 	/* Get reserved DMA windows from host bridge */
+	list_sort(NULL, &bridge->dma_ranges, iommu_dma_ranges_sort);
 	resource_list_for_each_entry(window, &bridge->dma_ranges) {
 		end = window->res->start - window->offset;
 resv_iova:
@@ -454,7 +465,7 @@ static int iova_reserve_pci_windows(struct pci_dev *dev,
 			hi = iova_pfn(iovad, end);
 			reserve_iova(iovad, lo, hi);
 		} else if (end < start) {
-			/* dma_ranges list should be sorted */
+			/* DMA ranges should be non-overlapping */
 			dev_err(&dev->dev,
 				"Failed to reserve IOVA [%pa-%pa]\n",
 				&start, &end);
* Unmerged path drivers/pci/of.c
