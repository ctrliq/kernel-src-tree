fuse: extend FUSE_SETXATTR request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Vivek Goyal <vgoyal@redhat.com>
commit 52a4c95f4d24b8bcb50745732f7b9f8513c49c5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/52a4c95f.failed

Fuse client needs to send additional information to file server when it
calls SETXATTR(system.posix_acl_access), so add extra flags field to the
structure.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 52a4c95f4d24b8bcb50745732f7b9f8513c49c5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/inode.c
#	include/uapi/linux/fuse.h
diff --cc fs/fuse/inode.c
index 4bd2074981c1,06a68cfa76d8..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -1103,16 -1097,13 +1105,20 @@@ void fuse_send_init(struct fuse_mount *
  		FUSE_PARALLEL_DIROPS | FUSE_HANDLE_KILLPRIV | FUSE_POSIX_ACL |
  		FUSE_ABORT_ERROR | FUSE_MAX_PAGES | FUSE_CACHE_SYMLINKS |
  		FUSE_NO_OPENDIR_SUPPORT | FUSE_EXPLICIT_INVAL_DATA |
++<<<<<<< HEAD
 +		FUSE_HANDLE_KILLPRIV_V2 | FUSE_INIT_EXT | FUSE_HAS_EXPIRE_ONLY;
++=======
+ 		FUSE_HANDLE_KILLPRIV_V2 | FUSE_SETXATTR_EXT;
++>>>>>>> 52a4c95f4d24 (fuse: extend FUSE_SETXATTR request)
  #ifdef CONFIG_FUSE_DAX
  	if (fm->fc->dax)
 -		ia->in.flags |= FUSE_MAP_ALIGNMENT;
 +		flags |= FUSE_MAP_ALIGNMENT;
  #endif
  	if (fm->fc->auto_submounts)
 -		ia->in.flags |= FUSE_SUBMOUNTS;
 +		flags |= FUSE_SUBMOUNTS;
 +
 +	ia->in.flags = flags;
 +	ia->in.flags2 = flags >> 32;
  
  	ia->args.opcode = FUSE_INIT;
  	ia->args.in_numargs = 1;
diff --cc include/uapi/linux/fuse.h
index 7a5f9382dbb4,390f7b4c889d..000000000000
--- a/include/uapi/linux/fuse.h
+++ b/include/uapi/linux/fuse.h
@@@ -179,8 -179,7 +179,12 @@@
   *  7.33
   *  - add FUSE_HANDLE_KILLPRIV_V2, FUSE_WRITE_KILL_SUIDGID, FATTR_KILL_SUIDGID
   *  - add FUSE_OPEN_KILL_SUIDGID
++<<<<<<< HEAD
 + *  - add FUSE_EXPIRE_ONLY flag to fuse_notify_inval_entry
 + *  - add FUSE_HAS_EXPIRE_ONLY
++=======
+  *  - extend fuse_setxattr_in, add FUSE_SETXATTR_EXT
++>>>>>>> 52a4c95f4d24 (fuse: extend FUSE_SETXATTR request)
   */
  
  #ifndef _LINUX_FUSE_H
@@@ -330,9 -331,7 +334,13 @@@ struct fuse_file_lock 
   *			does not have CAP_FSETID. Additionally upon
   *			write/truncate sgid is killed only if file has group
   *			execute permission. (Same as Linux VFS behavior).
++<<<<<<< HEAD
 + * FUSE_INIT_EXT: extended fuse_init_in request
 + * FUSE_INIT_RESERVED: reserved, do not use
 + * FUSE_HAS_EXPIRE_ONLY: kernel supports expiry-only entry invalidation
++=======
+  * FUSE_SETXATTR_EXT:	Server supports extended struct fuse_setxattr_in
++>>>>>>> 52a4c95f4d24 (fuse: extend FUSE_SETXATTR request)
   */
  #define FUSE_ASYNC_READ		(1 << 0)
  #define FUSE_POSIX_LOCKS	(1 << 1)
@@@ -363,10 -362,7 +371,14 @@@
  #define FUSE_MAP_ALIGNMENT	(1 << 26)
  #define FUSE_SUBMOUNTS		(1 << 27)
  #define FUSE_HANDLE_KILLPRIV_V2	(1 << 28)
++<<<<<<< HEAD
 +#define FUSE_INIT_EXT		(1 << 30)
 +#define FUSE_INIT_RESERVED	(1 << 31)
 +/* bits 32..63 get shifted down 32 bits into the flags2 field */
 +#define FUSE_HAS_EXPIRE_ONLY	(1ULL << 35)
++=======
+ #define FUSE_SETXATTR_EXT	(1 << 29)
++>>>>>>> 52a4c95f4d24 (fuse: extend FUSE_SETXATTR request)
  
  /**
   * CUSE INIT request/reply flags
diff --git a/fs/fuse/acl.c b/fs/fuse/acl.c
index f529075a2ce8..592682619bb4 100644
--- a/fs/fuse/acl.c
+++ b/fs/fuse/acl.c
@@ -93,7 +93,7 @@ int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 			return ret;
 		}
 
-		ret = fuse_setxattr(inode, name, value, size, 0);
+		ret = fuse_setxattr(inode, name, value, size, 0, 0);
 		kfree(value);
 	} else {
 		ret = fuse_removexattr(inode, name);
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a9efff536da9..49b41f32f22a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -672,6 +672,9 @@ struct fuse_conn {
 	/** Is setxattr not implemented by fs? */
 	unsigned no_setxattr:1;
 
+	/** Does file server support extended setxattr */
+	unsigned setxattr_ext:1;
+
 	/** Is getxattr not implemented by fs? */
 	unsigned no_getxattr:1;
 
@@ -1175,7 +1178,7 @@ void fuse_unlock_inode(struct inode *inode, bool locked);
 bool fuse_lock_inode(struct inode *inode);
 
 int fuse_setxattr(struct inode *inode, const char *name, const void *value,
-		  size_t size, int flags);
+		  size_t size, int flags, unsigned int extra_flags);
 ssize_t fuse_getxattr(struct inode *inode, const char *name, void *value,
 		      size_t size);
 ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size);
* Unmerged path fs/fuse/inode.c
diff --git a/fs/fuse/xattr.c b/fs/fuse/xattr.c
index cdea18de94f7..caa1d7277c1b 100644
--- a/fs/fuse/xattr.c
+++ b/fs/fuse/xattr.c
@@ -12,7 +12,7 @@
 #include <linux/posix_acl_xattr.h>
 
 int fuse_setxattr(struct inode *inode, const char *name, const void *value,
-		  size_t size, int flags)
+		  size_t size, int flags, unsigned int extra_flags)
 {
 	struct fuse_mount *fm = get_fuse_mount(inode);
 	FUSE_ARGS(args);
@@ -25,10 +25,13 @@ int fuse_setxattr(struct inode *inode, const char *name, const void *value,
 	memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	inarg.flags = flags;
+	inarg.setxattr_flags = extra_flags;
+
 	args.opcode = FUSE_SETXATTR;
 	args.nodeid = get_node_id(inode);
 	args.in_numargs = 3;
-	args.in_args[0].size = sizeof(inarg);
+	args.in_args[0].size = fm->fc->setxattr_ext ?
+		sizeof(inarg) : FUSE_COMPAT_SETXATTR_IN_SIZE;
 	args.in_args[0].value = &inarg;
 	args.in_args[1].size = strlen(name) + 1;
 	args.in_args[1].value = name;
@@ -198,7 +201,7 @@ static int fuse_xattr_set(const struct xattr_handler *handler,
 	if (!value)
 		return fuse_removexattr(inode, name);
 
-	return fuse_setxattr(inode, name, value, size, flags);
+	return fuse_setxattr(inode, name, value, size, flags, 0);
 }
 
 static bool no_xattr_list(struct dentry *dentry)
* Unmerged path include/uapi/linux/fuse.h
