xfs: always succeed at setting the reserve pool size

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 0baa2657dc4d79202148be79a3dc36c35f425060
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/0baa2657.failed

Nowadays, xfs_mod_fdblocks will always choose to fill the reserve pool
with freed blocks before adding to fdblocks.  Therefore, we can change
the behavior of xfs_reserve_blocks slightly -- setting the target size
of the pool should always succeed, since a deficiency will eventually
be made up as blocks get freed.

	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 0baa2657dc4d79202148be79a3dc36c35f425060)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsops.c
diff --cc fs/xfs/xfs_fsops.c
index 88edfa51e5ca,5c2bea1e12a8..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -435,46 -430,37 +435,71 @@@ xfs_reserve_blocks
  	 * If the request is larger than the current reservation, reserve the
  	 * blocks before we update the reserve counters. Sample m_fdblocks and
  	 * perform a partial reservation if the request exceeds free space.
++<<<<<<< HEAD
 +	 */
 +	error = -ENOSPC;
 +	do {
 +		free = percpu_counter_sum(&mp->m_fdblocks) -
 +						mp->m_alloc_set_aside;
 +		if (free <= 0)
 +			break;
 +
 +		delta = request - mp->m_resblks;
 +		lcounter = free - delta;
 +		if (lcounter < 0)
 +			/* We can't satisfy the request, just get what we can */
 +			fdblks_delta = free;
 +		else
 +			fdblks_delta = delta;
 +
++=======
+ 	 *
+ 	 * The code below estimates how many blocks it can request from
+ 	 * fdblocks to stash in the reserve pool.  This is a classic TOCTOU
+ 	 * race since fdblocks updates are not always coordinated via
+ 	 * m_sb_lock.  Set the reserve size even if there's not enough free
+ 	 * space to fill it because mod_fdblocks will refill an undersized
+ 	 * reserve when it can.
+ 	 */
+ 	free = percpu_counter_sum(&mp->m_fdblocks) -
+ 						xfs_fdblocks_unavailable(mp);
+ 	delta = request - mp->m_resblks;
+ 	mp->m_resblks = request;
+ 	if (delta > 0 && free > 0) {
++>>>>>>> 0baa2657dc4d (xfs: always succeed at setting the reserve pool size)
  		/*
  		 * We'll either succeed in getting space from the free block
 -		 * count or we'll get an ENOSPC.  Don't set the reserved flag
 -		 * here - we don't want to reserve the extra reserve blocks
 -		 * from the reserve.
 +		 * count or we'll get an ENOSPC. If we get a ENOSPC, it means
 +		 * things changed while we were calculating fdblks_delta and so
 +		 * we should try again to see if there is anything left to
 +		 * reserve.
 +		 *
 +		 * Don't set the reserved flag here - we don't want to reserve
 +		 * the extra reserve blocks from the reserve.....
  		 */
 -		fdblks_delta = min(free, delta);
  		spin_unlock(&mp->m_sb_lock);
  		error = xfs_mod_fdblocks(mp, -fdblks_delta, 0);
  		spin_lock(&mp->m_sb_lock);
 +	} while (error == -ENOSPC);
  
++<<<<<<< HEAD
 +	/*
 +	 * Update the reserve counters if blocks have been successfully
 +	 * allocated.
 +	 */
 +	if (!error && fdblks_delta) {
 +		mp->m_resblks += fdblks_delta;
 +		mp->m_resblks_avail += fdblks_delta;
++=======
+ 		/*
+ 		 * Update the reserve counters if blocks have been successfully
+ 		 * allocated.
+ 		 */
+ 		if (!error)
+ 			mp->m_resblks_avail += fdblks_delta;
++>>>>>>> 0baa2657dc4d (xfs: always succeed at setting the reserve pool size)
  	}
 +
  out:
  	if (outval) {
  		outval->resblks = mp->m_resblks;
* Unmerged path fs/xfs/xfs_fsops.c
