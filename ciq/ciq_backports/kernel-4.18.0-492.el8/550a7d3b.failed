fuse: add a flag FUSE_SETXATTR_ACL_KILL_SGID to kill SGID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-492.el8
commit-author Vivek Goyal <vgoyal@redhat.com>
commit 550a7d3bc0c4049ef8d36ff4d9ed7082ee8cb5ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-492.el8/550a7d3b.failed

When posix access ACL is set, it can have an effect on file mode and it can
also need to clear SGID if.

- None of caller's group/supplementary groups match file owner group.
AND
- Caller is not priviliged (No CAP_FSETID).

As of now fuser server is responsible for changing the file mode as
well. But it does not know whether to clear SGID or not.

So add a flag FUSE_SETXATTR_ACL_KILL_SGID and send this info with SETXATTR
to let file server know that sgid needs to be cleared as well.

	Reported-by: Luis Henriques <lhenriques@suse.de>
	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 550a7d3bc0c4049ef8d36ff4d9ed7082ee8cb5ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/acl.c
#	include/uapi/linux/fuse.h
diff --cc fs/fuse/acl.c
index f529075a2ce8,52b165319be1..000000000000
--- a/fs/fuse/acl.c
+++ b/fs/fuse/acl.c
@@@ -93,7 -95,11 +94,15 @@@ int fuse_set_acl(struct inode *inode, s
  			return ret;
  		}
  
++<<<<<<< HEAD
 +		ret = fuse_setxattr(inode, name, value, size, 0);
++=======
+ 		if (!in_group_p(i_gid_into_mnt(&init_user_ns, inode)) &&
+ 		    !capable_wrt_inode_uidgid(&init_user_ns, inode, CAP_FSETID))
+ 			extra_flags |= FUSE_SETXATTR_ACL_KILL_SGID;
+ 
+ 		ret = fuse_setxattr(inode, name, value, size, 0, extra_flags);
++>>>>>>> 550a7d3bc0c4 (fuse: add a flag FUSE_SETXATTR_ACL_KILL_SGID to kill SGID)
  		kfree(value);
  	} else {
  		ret = fuse_removexattr(inode, name);
diff --cc include/uapi/linux/fuse.h
index 7a5f9382dbb4,271ae90a9bb7..000000000000
--- a/include/uapi/linux/fuse.h
+++ b/include/uapi/linux/fuse.h
@@@ -179,8 -179,8 +179,13 @@@
   *  7.33
   *  - add FUSE_HANDLE_KILLPRIV_V2, FUSE_WRITE_KILL_SUIDGID, FATTR_KILL_SUIDGID
   *  - add FUSE_OPEN_KILL_SUIDGID
++<<<<<<< HEAD
 + *  - add FUSE_EXPIRE_ONLY flag to fuse_notify_inval_entry
 + *  - add FUSE_HAS_EXPIRE_ONLY
++=======
+  *  - extend fuse_setxattr_in, add FUSE_SETXATTR_EXT
+  *  - add FUSE_SETXATTR_ACL_KILL_SGID
++>>>>>>> 550a7d3bc0c4 (fuse: add a flag FUSE_SETXATTR_ACL_KILL_SGID to kill SGID)
   */
  
  #ifndef _LINUX_FUSE_H
@@@ -459,10 -456,10 +464,17 @@@ struct fuse_file_lock 
  #define FUSE_OPEN_KILL_SUIDGID	(1 << 0)
  
  /**
++<<<<<<< HEAD
 + * notify_inval_entry flags
 + * FUSE_EXPIRE_ONLY
 + */
 +#define FUSE_EXPIRE_ONLY		(1 << 0)
++=======
+  * setxattr flags
+  * FUSE_SETXATTR_ACL_KILL_SGID: Clear SGID when system.posix_acl_access is set
+  */
+ #define FUSE_SETXATTR_ACL_KILL_SGID	(1 << 0)
++>>>>>>> 550a7d3bc0c4 (fuse: add a flag FUSE_SETXATTR_ACL_KILL_SGID to kill SGID)
  
  enum fuse_opcode {
  	FUSE_LOOKUP		= 1,
* Unmerged path fs/fuse/acl.c
* Unmerged path include/uapi/linux/fuse.h
