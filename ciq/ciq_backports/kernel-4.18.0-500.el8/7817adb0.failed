usb: typec: Only attempt to link USB ports if there is fwnode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-500.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 7817adb03cfb52ebb5bdb25fd9fc8f683a1a09d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-500.el8/7817adb0.failed

The code that creates the links to the USB ports attached to
a connector inside the system assumed that the ACPI nodes
(fwnodes) always exist for the connectors, but it can not do
that.

There is no guarantee that every USB Type-C connector has
ACPI device node representing it in the ACPI tables, and
even if there are the nodes in the ACPI tables, the _STA
method in those nodes may still return 0 (which means the
device does not exist from ACPI PoW).

This fixes NULL pointer dereference that happens if the
nodes are missing.

Fixes: 730b49aac426 ("usb: typec: port-mapper: Convert to the component framework")
Reported-and-tested-by: Robert Święcki <robert@swiecki.net>
	Reported-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
	Tested-by: Marc Zyngier <maz@kernel.org>
	Acked-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20220124090228.41396-2-heikki.krogerus@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7817adb03cfb52ebb5bdb25fd9fc8f683a1a09d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/port-mapper.c
diff --cc drivers/usb/typec/port-mapper.c
index 9b0991bdf391,b6e0c6acc628..000000000000
--- a/drivers/usb/typec/port-mapper.c
+++ b/drivers/usb/typec/port-mapper.c
@@@ -247,33 -54,29 +247,45 @@@ static int each_port(struct device *por
  
  int typec_link_ports(struct typec_port *con)
  {
 -	struct each_port_arg arg = { .port = con, .match = NULL };
 +	int ret = 0;
  
++<<<<<<< HEAD
 +	con->pld = get_pld(&con->dev);
 +	if (!con->pld)
 +		return 0;
++=======
+ 	if (!has_acpi_companion(&con->dev))
+ 		return 0;
+ 
+ 	bus_for_each_dev(&acpi_bus_type, NULL, &arg, typec_port_match);
++>>>>>>> 7817adb03cfb (usb: typec: Only attempt to link USB ports if there is fwnode)
  
 -	/*
 -	 * REVISIT: Now each connector can have only a single component master.
 -	 * So far only the USB ports connected to the USB Type-C connector share
 -	 * the _PLD with it, but if there one day is something else (like maybe
 -	 * the DisplayPort ACPI device object) that also shares the _PLD with
 -	 * the connector, every one of those needs to have its own component
 -	 * master, because each different type of component needs to be bind to
 -	 * the connector independently of the other components. That requires
 -	 * improvements to the component framework. Right now you can only have
 -	 * one master per device.
 -	 */
 -	return component_master_add_with_match(&con->dev, &typec_aggregate_ops, arg.match);
 +	ret = usb_for_each_port(&con->dev, each_port);
 +	if (ret)
 +		typec_unlink_ports(con);
 +
 +	return ret;
  }
  
  void typec_unlink_ports(struct typec_port *con)
  {
++<<<<<<< HEAD
 +	struct port_node *node;
 +	struct port_node *tmp;
 +
 +	mutex_lock(&con->port_list_lock);
 +
 +	list_for_each_entry_safe(node, tmp, &con->port_list, list) {
 +		__unlink_port(con, node);
 +		remove_port_node(node);
 +		put_device(&con->dev);
 +	}
 +
 +	mutex_unlock(&con->port_list_lock);
 +
 +	free_pld(con->pld);
++=======
+ 	if (has_acpi_companion(&con->dev))
+ 		component_master_del(&con->dev, &typec_aggregate_ops);
++>>>>>>> 7817adb03cfb (usb: typec: Only attempt to link USB ports if there is fwnode)
  }
* Unmerged path drivers/usb/typec/port-mapper.c
