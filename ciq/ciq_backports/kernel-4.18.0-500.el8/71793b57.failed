usb: typec: mux: Allow multiple mux_devs per mux

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-500.el8
commit-author Bjorn Andersson <bjorn.andersson@linaro.org>
commit 71793b579ba6825d221445e3cfcd50da427b4f0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-500.el8/71793b57.failed

In the Qualcomm platforms the USB/DP PHY handles muxing and orientation
switching of the SuperSpeed lines, but the SBU lines needs to be
connected and switched by external (to the SoC) hardware.

It's therefor necessary to be able to have the TypeC controller operate
multiple TypeC muxes and switches. Use the newly introduced indirection
object to handle this, to avoid having to taint the TypeC controllers
with knowledge about the downstream hardware configuration.

The max number of devs per indirection is set to 3, which account for
being able to mux/switch the USB HS, SS and SBU lines, as per defined
defined in the usb-c-connector binding. This number could be grown if
need arrises at a later point in time.

	Acked-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
Link: https://lore.kernel.org/r/20220422222351.1297276-6-bjorn.andersson@linaro.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 71793b579ba6825d221445e3cfcd50da427b4f0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/mux.c
diff --cc drivers/usb/typec/mux.c
index 709aad875d93,fd55c2c516a5..000000000000
--- a/drivers/usb/typec/mux.c
+++ b/drivers/usb/typec/mux.c
@@@ -17,12 -17,19 +17,22 @@@
  #include "class.h"
  #include "mux.h"
  
++<<<<<<< HEAD
++=======
+ #define TYPEC_MUX_MAX_DEVS	3
+ 
+ struct typec_switch {
+ 	struct typec_switch_dev *sw_devs[TYPEC_MUX_MAX_DEVS];
+ 	unsigned int num_sw_devs;
+ };
+ 
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  static int switch_fwnode_match(struct device *dev, const void *fwnode)
  {
 -	if (!is_typec_switch_dev(dev))
 +	if (!is_typec_switch(dev))
  		return 0;
  
 -	return dev_fwnode(dev) == fwnode;
 +	return device_match_fwnode(dev, fwnode);
  }
  
  static void *typec_switch_match(struct fwnode_handle *fwnode, const char *id,
@@@ -63,14 -70,50 +73,60 @@@
   */
  struct typec_switch *fwnode_typec_switch_get(struct fwnode_handle *fwnode)
  {
++<<<<<<< HEAD
++=======
+ 	struct typec_switch_dev *sw_devs[TYPEC_MUX_MAX_DEVS];
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  	struct typec_switch *sw;
+ 	int count;
+ 	int err;
+ 	int i;
  
++<<<<<<< HEAD
 +	sw = fwnode_connection_find_match(fwnode, "orientation-switch", NULL,
 +					  typec_switch_match);
 +	if (!IS_ERR_OR_NULL(sw))
 +		WARN_ON(!try_module_get(sw->dev.parent->driver->owner));
++=======
+ 	sw = kzalloc(sizeof(*sw), GFP_KERNEL);
+ 	if (!sw)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	count = fwnode_connection_find_matches(fwnode, "orientation-switch", NULL,
+ 					       typec_switch_match,
+ 					       (void **)sw_devs,
+ 					       ARRAY_SIZE(sw_devs));
+ 	if (count <= 0) {
+ 		kfree(sw);
+ 		return NULL;
+ 	}
+ 
+ 	for (i = 0; i < count; i++) {
+ 		if (IS_ERR(sw_devs[i])) {
+ 			err = PTR_ERR(sw_devs[i]);
+ 			goto put_sw_devs;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < count; i++) {
+ 		WARN_ON(!try_module_get(sw_devs[i]->dev.parent->driver->owner));
+ 		sw->sw_devs[i] = sw_devs[i];
+ 	}
+ 
+ 	sw->num_sw_devs = count;
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  
  	return sw;
+ 
+ put_sw_devs:
+ 	for (i = 0; i < count; i++) {
+ 		if (!IS_ERR(sw_devs[i]))
+ 			put_device(&sw_devs[i]->dev);
+ 	}
+ 
+ 	kfree(sw);
+ 
+ 	return ERR_PTR(err);
  }
  EXPORT_SYMBOL_GPL(fwnode_typec_switch_get);
  
@@@ -82,10 -125,19 +138,26 @@@
   */
  void typec_switch_put(struct typec_switch *sw)
  {
++<<<<<<< HEAD
 +	if (!IS_ERR_OR_NULL(sw)) {
 +		module_put(sw->dev.parent->driver->owner);
 +		put_device(&sw->dev);
 +	}
++=======
+ 	struct typec_switch_dev *sw_dev;
+ 	unsigned int i;
+ 
+ 	if (IS_ERR_OR_NULL(sw))
+ 		return;
+ 
+ 	for (i = 0; i < sw->num_sw_devs; i++) {
+ 		sw_dev = sw->sw_devs[i];
+ 
+ 		module_put(sw_dev->dev.parent->driver->owner);
+ 		put_device(&sw_dev->dev);
+ 	}
+ 	kfree(sw);
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  }
  EXPORT_SYMBOL_GPL(typec_switch_put);
  
@@@ -151,10 -203,22 +223,29 @@@ EXPORT_SYMBOL_GPL(typec_switch_register
  int typec_switch_set(struct typec_switch *sw,
  		     enum typec_orientation orientation)
  {
++<<<<<<< HEAD
 +	if (IS_ERR_OR_NULL(sw))
 +		return 0;
 +
 +	return sw->set(sw, orientation);
++=======
+ 	struct typec_switch_dev *sw_dev;
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	if (IS_ERR_OR_NULL(sw))
+ 		return 0;
+ 
+ 	for (i = 0; i < sw->num_sw_devs; i++) {
+ 		sw_dev = sw->sw_devs[i];
+ 
+ 		ret = sw_dev->set(sw_dev, orientation);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  }
  EXPORT_SYMBOL_GPL(typec_switch_set);
  
@@@ -185,12 -249,17 +276,20 @@@ EXPORT_SYMBOL_GPL(typec_switch_get_drvd
  
  /* ------------------------------------------------------------------------- */
  
++<<<<<<< HEAD
++=======
+ struct typec_mux {
+ 	struct typec_mux_dev *mux_devs[TYPEC_MUX_MAX_DEVS];
+ 	unsigned int num_mux_devs;
+ };
+ 
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  static int mux_fwnode_match(struct device *dev, const void *fwnode)
  {
 -	if (!is_typec_mux_dev(dev))
 +	if (!is_typec_mux(dev))
  		return 0;
  
 -	return dev_fwnode(dev) == fwnode;
 +	return device_match_fwnode(dev, fwnode);
  }
  
  static void *typec_mux_match(struct fwnode_handle *fwnode, const char *id,
@@@ -269,14 -334,50 +368,60 @@@ find_mux
  struct typec_mux *fwnode_typec_mux_get(struct fwnode_handle *fwnode,
  				       const struct typec_altmode_desc *desc)
  {
++<<<<<<< HEAD
++=======
+ 	struct typec_mux_dev *mux_devs[TYPEC_MUX_MAX_DEVS];
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  	struct typec_mux *mux;
+ 	int count;
+ 	int err;
+ 	int i;
  
++<<<<<<< HEAD
 +	mux = fwnode_connection_find_match(fwnode, "mode-switch", (void *)desc,
 +					   typec_mux_match);
 +	if (!IS_ERR_OR_NULL(mux))
 +		WARN_ON(!try_module_get(mux->dev.parent->driver->owner));
++=======
+ 	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+ 	if (!mux)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	count = fwnode_connection_find_matches(fwnode, "mode-switch",
+ 					       (void *)desc, typec_mux_match,
+ 					       (void **)mux_devs,
+ 					       ARRAY_SIZE(mux_devs));
+ 	if (count <= 0) {
+ 		kfree(mux);
+ 		return NULL;
+ 	}
+ 
+ 	for (i = 0; i < count; i++) {
+ 		if (IS_ERR(mux_devs[i])) {
+ 			err = PTR_ERR(mux_devs[i]);
+ 			goto put_mux_devs;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < count; i++) {
+ 		WARN_ON(!try_module_get(mux_devs[i]->dev.parent->driver->owner));
+ 		mux->mux_devs[i] = mux_devs[i];
+ 	}
+ 
+ 	mux->num_mux_devs = count;
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  
  	return mux;
+ 
+ put_mux_devs:
+ 	for (i = 0; i < count; i++) {
+ 		if (!IS_ERR(mux_devs[i]))
+ 			put_device(&mux_devs[i]->dev);
+ 	}
+ 
+ 	kfree(mux);
+ 
+ 	return ERR_PTR(err);
  }
  EXPORT_SYMBOL_GPL(fwnode_typec_mux_get);
  
@@@ -288,19 -389,39 +433,53 @@@
   */
  void typec_mux_put(struct typec_mux *mux)
  {
++<<<<<<< HEAD
 +	if (!IS_ERR_OR_NULL(mux)) {
 +		module_put(mux->dev.parent->driver->owner);
 +		put_device(&mux->dev);
 +	}
++=======
+ 	struct typec_mux_dev *mux_dev;
+ 	unsigned int i;
+ 
+ 	if (IS_ERR_OR_NULL(mux))
+ 		return;
+ 
+ 	for (i = 0; i < mux->num_mux_devs; i++) {
+ 		mux_dev = mux->mux_devs[i];
+ 		module_put(mux_dev->dev.parent->driver->owner);
+ 		put_device(&mux_dev->dev);
+ 	}
+ 	kfree(mux);
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  }
  EXPORT_SYMBOL_GPL(typec_mux_put);
  
  int typec_mux_set(struct typec_mux *mux, struct typec_mux_state *state)
  {
++<<<<<<< HEAD
 +	if (IS_ERR_OR_NULL(mux))
 +		return 0;
 +
 +	return mux->set(mux, state);
++=======
+ 	struct typec_mux_dev *mux_dev;
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	if (IS_ERR_OR_NULL(mux))
+ 		return 0;
+ 
+ 	for (i = 0; i < mux->num_mux_devs; i++) {
+ 		mux_dev = mux->mux_devs[i];
+ 
+ 		ret = mux_dev->set(mux_dev, state);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 71793b579ba6 (usb: typec: mux: Allow multiple mux_devs per mux)
  }
  EXPORT_SYMBOL_GPL(typec_mux_set);
  
* Unmerged path drivers/usb/typec/mux.c
