device property: Fix fwnode_graph_devcon_match() fwnode leak

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-500.el8
commit-author Sakari Ailus <sakari.ailus@linux.intel.com>
commit 4a7f4110f79163fd53ea65438041994ed615e3af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-500.el8/4a7f4110.failed

For each endpoint it encounters, fwnode_graph_devcon_match() checks
whether the endpoint's remote port parent device is available. If it is
not, it ignores the endpoint but does not put the reference to the remote
endpoint port parent fwnode. For available devices the fwnode handle
reference is put as expected.

Put the reference for unavailable devices now.

Fixes: 637e9e52b185 ("device connection: Find device connections also from device graphs")
	Cc: 5.1+ <stable@vger.kernel.org> # 5.1+
	Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 4a7f4110f79163fd53ea65438041994ed615e3af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
diff --cc drivers/base/property.c
index 84d4ed7dac6a,b7b3a7b86006..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -1291,3 -1147,78 +1291,81 @@@ const void *device_get_match_data(struc
  	return fwnode_call_ptr_op(dev_fwnode(dev), device_get_match_data, dev);
  }
  EXPORT_SYMBOL_GPL(device_get_match_data);
++<<<<<<< HEAD
++=======
+ 
+ static void *
+ fwnode_graph_devcon_match(struct fwnode_handle *fwnode, const char *con_id,
+ 			  void *data, devcon_match_fn_t match)
+ {
+ 	struct fwnode_handle *node;
+ 	struct fwnode_handle *ep;
+ 	void *ret;
+ 
+ 	fwnode_graph_for_each_endpoint(fwnode, ep) {
+ 		node = fwnode_graph_get_remote_port_parent(ep);
+ 		if (!fwnode_device_is_available(node)) {
+ 			fwnode_handle_put(node);
+ 			continue;
+ 		}
+ 
+ 		ret = match(node, con_id, data);
+ 		fwnode_handle_put(node);
+ 		if (ret) {
+ 			fwnode_handle_put(ep);
+ 			return ret;
+ 		}
+ 	}
+ 	return NULL;
+ }
+ 
+ static void *
+ fwnode_devcon_match(struct fwnode_handle *fwnode, const char *con_id,
+ 		    void *data, devcon_match_fn_t match)
+ {
+ 	struct fwnode_handle *node;
+ 	void *ret;
+ 	int i;
+ 
+ 	for (i = 0; ; i++) {
+ 		node = fwnode_find_reference(fwnode, con_id, i);
+ 		if (IS_ERR(node))
+ 			break;
+ 
+ 		ret = match(node, NULL, data);
+ 		fwnode_handle_put(node);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * fwnode_connection_find_match - Find connection from a device node
+  * @fwnode: Device node with the connection
+  * @con_id: Identifier for the connection
+  * @data: Data for the match function
+  * @match: Function to check and convert the connection description
+  *
+  * Find a connection with unique identifier @con_id between @fwnode and another
+  * device node. @match will be used to convert the connection description to
+  * data the caller is expecting to be returned.
+  */
+ void *fwnode_connection_find_match(struct fwnode_handle *fwnode,
+ 				   const char *con_id, void *data,
+ 				   devcon_match_fn_t match)
+ {
+ 	void *ret;
+ 
+ 	if (!fwnode || !match)
+ 		return NULL;
+ 
+ 	ret = fwnode_graph_devcon_match(fwnode, con_id, data, match);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return fwnode_devcon_match(fwnode, con_id, data, match);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_connection_find_match);
++>>>>>>> 4a7f4110f791 (device property: Fix fwnode_graph_devcon_match() fwnode leak)
* Unmerged path drivers/base/property.c
