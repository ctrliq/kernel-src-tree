usb: typec: tipd: Add short-circuit for no irqs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-500.el8
commit-author Sven Peter <sven@svenpeter.dev>
commit c7260e29dd208e5134147e5614d3413b4014b685
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-500.el8/c7260e29.failed

If no interrupts are set in IntEventX directly skip to the end of the
interrupt handler and return IRQ_NONE instead of IRQ_HANDLED.
This possibly allows to detect spurious interrupts if the i2c bus is fast
enough.

	Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Sven Peter <sven@svenpeter.dev>
Link: https://lore.kernel.org/r/20210928155502.71372-4-sven@svenpeter.dev
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c7260e29dd208e5134147e5614d3413b4014b685)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/tipd/core.c
diff --cc drivers/usb/typec/tipd/core.c
index 6e64a81907c2,e785e4aa2d4b..000000000000
--- a/drivers/usb/typec/tipd/core.c
+++ b/drivers/usb/typec/tipd/core.c
@@@ -423,42 -479,23 +423,49 @@@ static irqreturn_t tps6598x_interrupt(i
  	}
  	trace_tps6598x_irq(event1, event2);
  
++<<<<<<< HEAD
 +	ret = tps6598x_read32(tps, TPS_REG_STATUS, &status);
 +	if (ret) {
 +		dev_err(tps->dev, "%s: failed to read status\n", __func__);
++=======
+ 	if (!(event1 | event2))
+ 		goto err_unlock;
+ 
+ 	if (!tps6598x_read_status(tps, &status))
++>>>>>>> c7260e29dd20 (usb: typec: tipd: Add short-circuit for no irqs)
  		goto err_clear_ints;
 +	}
 +	trace_tps6598x_status(status);
  
 -	if ((event1 | event2) & TPS_REG_INT_POWER_STATUS_UPDATE)
 -		if (!tps6598x_read_power_status(tps))
 +	if ((event1 | event2) & TPS_REG_INT_POWER_STATUS_UPDATE) {
 +		ret = tps6598x_read16(tps, TPS_REG_POWER_STATUS, &pwr_status);
 +		if (ret < 0) {
 +			dev_err(tps->dev, "failed to read power status: %d\n", ret);
  			goto err_clear_ints;
 +		}
 +		trace_tps6598x_power_status(pwr_status);
 +	}
  
 -	if ((event1 | event2) & TPS_REG_INT_DATA_STATUS_UPDATE)
 -		if (!tps6598x_read_data_status(tps))
 +	if ((event1 | event2) & TPS_REG_INT_DATA_STATUS_UPDATE) {
 +		ret = tps6598x_read32(tps, TPS_REG_DATA_STATUS, &data_status);
 +		if (ret < 0) {
 +			dev_err(tps->dev, "failed to read data status: %d\n", ret);
  			goto err_clear_ints;
 +		}
 +		trace_tps6598x_data_status(data_status);
 +	}
  
  	/* Handle plug insert or removal */
 -	if ((event1 | event2) & TPS_REG_INT_PLUG_EVENT)
 -		tps6598x_handle_plug_event(tps, status);
 +	if ((event1 | event2) & TPS_REG_INT_PLUG_EVENT) {
 +		if (status & TPS_STATUS_PLUG_PRESENT) {
 +			ret = tps6598x_connect(tps, status);
 +			if (ret)
 +				dev_err(tps->dev,
 +					"failed to register partner\n");
 +		} else {
 +			tps6598x_disconnect(tps, status);
 +		}
 +	}
  
  err_clear_ints:
  	tps6598x_write64(tps, TPS_REG_INT_CLEAR1, event1);
* Unmerged path drivers/usb/typec/tipd/core.c
