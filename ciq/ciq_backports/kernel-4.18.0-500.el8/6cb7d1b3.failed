media: Switch to use dev_err_probe() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-500.el8
commit-author Yang Yingliang <yangyingliang@huawei.com>
commit 6cb7d1b3ff83e98e852db9739892c4643a31804b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-500.el8/6cb7d1b3.failed

In the probe path, dev_err() can be replaced with dev_err_probe()
which will check if error code is -EPROBE_DEFER.

	Reviewed-by: Sean Young <sean@mess.org>
	Reviewed-by: Ricardo Ribalda <ribalda@chromium.org>
	Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
	Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
(cherry picked from commit 6cb7d1b3ff83e98e852db9739892c4643a31804b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/i2c/ad5820.c
#	drivers/media/i2c/imx274.c
#	drivers/media/platform/exynos4-is/media-dev.c
#	drivers/media/platform/mediatek/mdp/mtk_mdp_comp.c
#	drivers/media/platform/stm32/stm32-cec.c
#	drivers/media/platform/stm32/stm32-dcmi.c
#	drivers/media/platform/xilinx/xilinx-csi2rxss.c
diff --cc drivers/media/i2c/ad5820.c
index 034ebf754007,44c26af49071..000000000000
--- a/drivers/media/i2c/ad5820.c
+++ b/drivers/media/i2c/ad5820.c
@@@ -305,13 -300,16 +305,19 @@@ static int ad5820_probe(struct i2c_clie
  		return -ENOMEM;
  
  	coil->vana = devm_regulator_get(&client->dev, "VANA");
- 	if (IS_ERR(coil->vana)) {
- 		ret = PTR_ERR(coil->vana);
- 		if (ret != -EPROBE_DEFER)
- 			dev_err(&client->dev, "could not get regulator for vana\n");
- 		return ret;
- 	}
- 
+ 	if (IS_ERR(coil->vana))
+ 		return dev_err_probe(&client->dev, PTR_ERR(coil->vana),
+ 				     "could not get regulator for vana\n");
+ 
++<<<<<<< HEAD
++=======
+ 	coil->enable_gpio = devm_gpiod_get_optional(&client->dev, "enable",
+ 						    GPIOD_OUT_LOW);
+ 	if (IS_ERR(coil->enable_gpio))
+ 		return dev_err_probe(&client->dev, PTR_ERR(coil->enable_gpio),
+ 				     "could not get enable gpio\n");
+ 
++>>>>>>> 6cb7d1b3ff83 (media: Switch to use dev_err_probe() helper)
  	mutex_init(&coil->power_lock);
  
  	v4l2_i2c_subdev_init(&coil->subdev, client, &ad5820_ops);
diff --cc drivers/media/i2c/imx274.c
index b5c18562e917,9219f3c9594b..000000000000
--- a/drivers/media/i2c/imx274.c
+++ b/drivers/media/i2c/imx274.c
@@@ -1659,12 -2057,11 +1659,17 @@@ static int imx274_probe(struct i2c_clie
  	}
  
  	/* initialize sensor reset gpio */
 -	imx274->reset_gpio = devm_gpiod_get_optional(dev, "reset",
 +	imx274->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",
  						     GPIOD_OUT_HIGH);
  	if (IS_ERR(imx274->reset_gpio)) {
++<<<<<<< HEAD
 +		if (PTR_ERR(imx274->reset_gpio) != -EPROBE_DEFER)
 +			dev_err(&client->dev, "Reset GPIO not setup in DT");
 +		ret = PTR_ERR(imx274->reset_gpio);
++=======
+ 		ret = dev_err_probe(dev, PTR_ERR(imx274->reset_gpio),
+ 				    "Reset GPIO not setup in DT\n");
++>>>>>>> 6cb7d1b3ff83 (media: Switch to use dev_err_probe() helper)
  		goto err_me;
  	}
  
diff --cc drivers/media/platform/exynos4-is/media-dev.c
index 0be6e93dc9f5,98a60f01129d..000000000000
--- a/drivers/media/platform/exynos4-is/media-dev.c
+++ b/drivers/media/platform/exynos4-is/media-dev.c
@@@ -1451,12 -1467,11 +1451,18 @@@ static int fimc_md_probe(struct platfor
  
  	ret = fimc_md_get_clocks(fmd);
  	if (ret)
 -		goto err_v4l2dev;
 +		goto err_md;
  
++<<<<<<< HEAD:drivers/media/platform/exynos4-is/media-dev.c
 +	ret = fimc_md_get_pinctrl(fmd);
 +	if (ret < 0) {
 +		if (ret != EPROBE_DEFER)
 +			dev_err(dev, "Failed to get pinctrl: %d\n", ret);
++=======
+ 	pinctrl = devm_pinctrl_get(dev);
+ 	if (IS_ERR(pinctrl)) {
+ 		ret = dev_err_probe(dev, PTR_ERR(pinctrl), "Failed to get pinctrl\n");
++>>>>>>> 6cb7d1b3ff83 (media: Switch to use dev_err_probe() helper):drivers/media/platform/samsung/exynos4-is/media-dev.c
  		goto err_clk;
  	}
  
diff --cc drivers/media/platform/stm32/stm32-cec.c
index 7c496bc1cf38,7b2db46a5722..000000000000
--- a/drivers/media/platform/stm32/stm32-cec.c
+++ b/drivers/media/platform/stm32/stm32-cec.c
@@@ -279,10 -288,9 +279,16 @@@ static int stm32_cec_probe(struct platf
  		return ret;
  
  	cec->clk_cec = devm_clk_get(&pdev->dev, "cec");
++<<<<<<< HEAD:drivers/media/platform/stm32/stm32-cec.c
 +	if (IS_ERR(cec->clk_cec)) {
 +		dev_err(&pdev->dev, "Cannot get cec clock\n");
 +		return PTR_ERR(cec->clk_cec);
 +	}
++=======
+ 	if (IS_ERR(cec->clk_cec))
+ 		return dev_err_probe(&pdev->dev, PTR_ERR(cec->clk_cec),
+ 				     "Cannot get cec clock\n");
++>>>>>>> 6cb7d1b3ff83 (media: Switch to use dev_err_probe() helper):drivers/media/cec/platform/stm32/stm32-cec.c
  
  	ret = clk_prepare(cec->clk_cec);
  	if (ret) {
diff --cc drivers/media/platform/stm32/stm32-dcmi.c
index c6c1c23bf132,ad8e9742e1ae..000000000000
--- a/drivers/media/platform/stm32/stm32-dcmi.c
+++ b/drivers/media/platform/stm32/stm32-dcmi.c
@@@ -1682,10 -1946,9 +1682,16 @@@ static int dcmi_probe(struct platform_d
  		return -ENOMEM;
  
  	dcmi->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
++<<<<<<< HEAD:drivers/media/platform/stm32/stm32-dcmi.c
 +	if (IS_ERR(dcmi->rstc)) {
 +		dev_err(&pdev->dev, "Could not get reset control\n");
 +		return -ENODEV;
 +	}
++=======
+ 	if (IS_ERR(dcmi->rstc))
+ 		return dev_err_probe(&pdev->dev, PTR_ERR(dcmi->rstc),
+ 				     "Could not get reset control\n");
++>>>>>>> 6cb7d1b3ff83 (media: Switch to use dev_err_probe() helper):drivers/media/platform/st/stm32/stm32-dcmi.c
  
  	/* Get bus characteristics from devicetree */
  	np = of_graph_get_next_endpoint(np, NULL);
@@@ -1726,36 -1994,23 +1732,47 @@@
  	}
  
  	dcmi->regs = devm_ioremap_resource(&pdev->dev, dcmi->res);
 -	if (IS_ERR(dcmi->regs))
 +	if (IS_ERR(dcmi->regs)) {
 +		dev_err(&pdev->dev, "Could not map registers\n");
  		return PTR_ERR(dcmi->regs);
 +	}
 +
 +	ret = devm_request_threaded_irq(&pdev->dev, irq, dcmi_irq_callback,
 +					dcmi_irq_thread, IRQF_ONESHOT,
 +					dev_name(&pdev->dev), dcmi);
 +	if (ret) {
 +		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
 +		return -ENODEV;
 +	}
  
  	mclk = devm_clk_get(&pdev->dev, "mclk");
++<<<<<<< HEAD:drivers/media/platform/stm32/stm32-dcmi.c
 +	if (IS_ERR(mclk)) {
 +		dev_err(&pdev->dev, "Unable to get mclk\n");
 +		return PTR_ERR(mclk);
 +	}
 +
 +	chan = dma_request_slave_channel(&pdev->dev, "tx");
 +	if (!chan) {
 +		dev_info(&pdev->dev, "Unable to request DMA channel, defer probing\n");
 +		return -EPROBE_DEFER;
 +	}
++=======
+ 	if (IS_ERR(mclk))
+ 		return dev_err_probe(&pdev->dev, PTR_ERR(mclk),
+ 				     "Unable to get mclk\n");
+ 
+ 	chan = dma_request_chan(&pdev->dev, "tx");
+ 	if (IS_ERR(chan))
+ 		return dev_err_probe(&pdev->dev, PTR_ERR(chan),
+ 				     "Failed to request DMA channel\n");
++>>>>>>> 6cb7d1b3ff83 (media: Switch to use dev_err_probe() helper):drivers/media/platform/st/stm32/stm32-dcmi.c
  
 -	dcmi->dma_max_burst = UINT_MAX;
 -	ret = dma_get_slave_caps(chan, &caps);
 -	if (!ret && caps.max_sg_burst)
 -		dcmi->dma_max_burst = caps.max_sg_burst	* DMA_SLAVE_BUSWIDTH_4_BYTES;
 +	ret = clk_prepare(mclk);
 +	if (ret) {
 +		dev_err(&pdev->dev, "Unable to prepare mclk %p\n", mclk);
 +		goto err_dma_release;
 +	}
  
  	spin_lock_init(&dcmi->irqlock);
  	mutex_init(&dcmi->lock);
* Unmerged path drivers/media/platform/mediatek/mdp/mtk_mdp_comp.c
* Unmerged path drivers/media/platform/xilinx/xilinx-csi2rxss.c
* Unmerged path drivers/media/i2c/ad5820.c
* Unmerged path drivers/media/i2c/imx274.c
diff --git a/drivers/media/i2c/tc358743.c b/drivers/media/i2c/tc358743.c
index 35b746965ba1..ae7294ad9ef9 100644
--- a/drivers/media/i2c/tc358743.c
+++ b/drivers/media/i2c/tc358743.c
@@ -1902,12 +1902,9 @@ static int tc358743_probe_of(struct tc358743_state *state)
 	int ret = -EINVAL;
 
 	refclk = devm_clk_get(dev, "refclk");
-	if (IS_ERR(refclk)) {
-		if (PTR_ERR(refclk) != -EPROBE_DEFER)
-			dev_err(dev, "failed to get refclk: %ld\n",
-				PTR_ERR(refclk));
-		return PTR_ERR(refclk);
-	}
+	if (IS_ERR(refclk))
+		return dev_err_probe(dev, PTR_ERR(refclk),
+				     "failed to get refclk\n");
 
 	ep = of_graph_get_next_endpoint(dev->of_node, NULL);
 	if (!ep) {
* Unmerged path drivers/media/platform/exynos4-is/media-dev.c
* Unmerged path drivers/media/platform/mediatek/mdp/mtk_mdp_comp.c
diff --git a/drivers/media/platform/omap3isp/isp.c b/drivers/media/platform/omap3isp/isp.c
index 4e93840f43cb..3214bb97e896 100644
--- a/drivers/media/platform/omap3isp/isp.c
+++ b/drivers/media/platform/omap3isp/isp.c
@@ -1875,8 +1875,7 @@ static int isp_initialize_modules(struct isp_device *isp)
 
 	ret = omap3isp_ccp2_init(isp);
 	if (ret < 0) {
-		if (ret != -EPROBE_DEFER)
-			dev_err(isp->dev, "CCP2 initialization failed\n");
+		dev_err_probe(isp->dev, ret, "CCP2 initialization failed\n");
 		goto error_ccp2;
 	}
 
* Unmerged path drivers/media/platform/stm32/stm32-cec.c
* Unmerged path drivers/media/platform/stm32/stm32-dcmi.c
* Unmerged path drivers/media/platform/xilinx/xilinx-csi2rxss.c
diff --git a/drivers/media/rc/gpio-ir-recv.c b/drivers/media/rc/gpio-ir-recv.c
index 3d99b51384ac..86758259c888 100644
--- a/drivers/media/rc/gpio-ir-recv.c
+++ b/drivers/media/rc/gpio-ir-recv.c
@@ -58,13 +58,9 @@ static int gpio_ir_recv_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	gpio_dev->gpiod = devm_gpiod_get(dev, NULL, GPIOD_IN);
-	if (IS_ERR(gpio_dev->gpiod)) {
-		rc = PTR_ERR(gpio_dev->gpiod);
-		/* Just try again if this happens */
-		if (rc != -EPROBE_DEFER)
-			dev_err(dev, "error getting gpio (%d)\n", rc);
-		return rc;
-	}
+	if (IS_ERR(gpio_dev->gpiod))
+		return dev_err_probe(dev, PTR_ERR(gpio_dev->gpiod),
+				     "error getting gpio\n");
 	gpio_dev->irq = gpiod_to_irq(gpio_dev->gpiod);
 	if (gpio_dev->irq < 0)
 		return gpio_dev->irq;
diff --git a/drivers/media/rc/gpio-ir-tx.c b/drivers/media/rc/gpio-ir-tx.c
index cd476cab9782..893f91788886 100644
--- a/drivers/media/rc/gpio-ir-tx.c
+++ b/drivers/media/rc/gpio-ir-tx.c
@@ -137,12 +137,9 @@ static int gpio_ir_tx_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	gpio_ir->gpio = devm_gpiod_get(&pdev->dev, NULL, GPIOD_OUT_LOW);
-	if (IS_ERR(gpio_ir->gpio)) {
-		if (PTR_ERR(gpio_ir->gpio) != -EPROBE_DEFER)
-			dev_err(&pdev->dev, "Failed to get gpio (%ld)\n",
-				PTR_ERR(gpio_ir->gpio));
-		return PTR_ERR(gpio_ir->gpio);
-	}
+	if (IS_ERR(gpio_ir->gpio))
+		return dev_err_probe(&pdev->dev, PTR_ERR(gpio_ir->gpio),
+				     "Failed to get gpio\n");
 
 	rcdev->priv = gpio_ir;
 	rcdev->driver_name = DRIVER_NAME;
diff --git a/drivers/media/rc/ir-rx51.c b/drivers/media/rc/ir-rx51.c
index 8a93f7468622..4b0591f7feae 100644
--- a/drivers/media/rc/ir-rx51.c
+++ b/drivers/media/rc/ir-rx51.c
@@ -241,13 +241,8 @@ static int ir_rx51_probe(struct platform_device *dev)
 	struct rc_dev *rcdev;
 
 	pwm = pwm_get(&dev->dev, NULL);
-	if (IS_ERR(pwm)) {
-		int err = PTR_ERR(pwm);
-
-		if (err != -EPROBE_DEFER)
-			dev_err(&dev->dev, "pwm_get failed: %d\n", err);
-		return err;
-	}
+	if (IS_ERR(pwm))
+		return dev_err_probe(&dev->dev, PTR_ERR(pwm), "pwm_get failed\n");
 
 	/* Use default, in case userspace does not set the carrier */
 	ir_rx51.freq = DIV_ROUND_CLOSEST(pwm_get_period(pwm), NSEC_PER_SEC);
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
index 2c9667ed04fc..e1590eda704d 100644
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -1250,12 +1250,9 @@ static int uvc_gpio_parse(struct uvc_device *dev)
 		return PTR_ERR_OR_ZERO(gpio_privacy);
 
 	irq = gpiod_to_irq(gpio_privacy);
-	if (irq < 0) {
-		if (irq != EPROBE_DEFER)
-			dev_err(&dev->udev->dev,
-				"No IRQ for privacy GPIO (%d)\n", irq);
-		return irq;
-	}
+	if (irq < 0)
+		return dev_err_probe(&dev->udev->dev, irq,
+				     "No IRQ for privacy GPIO\n");
 
 	unit = uvc_alloc_entity(UVC_EXT_GPIO_UNIT, UVC_EXT_GPIO_UNIT_ID, 0, 1);
 	if (!unit)
