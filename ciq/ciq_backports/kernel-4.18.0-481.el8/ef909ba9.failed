powerpc/lib/feature-fixups: Use PPC_RAW_xxx() macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Christophe Leroy <christophe.leroy@csgroup.eu>
commit ef909ba954145e35c9e21352133e5e99c64ab3f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/ef909ba9.failed

Use PPC_RAW_xxx() macros instead of open coding assembly
opcodes.

	Signed-off-by: Christophe Leroy <christophe.leroy@csgroup.eu>
[mpe: Fix bad converison in do_stf_exit_barrier_fixups()]
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/e79cd8e111ca13bf8c61a384bac365aa7e207647.1621506159.git.christophe.leroy@csgroup.eu

(cherry picked from commit ef909ba954145e35c9e21352133e5e99c64ab3f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/ppc-opcode.h
#	arch/powerpc/lib/feature-fixups.c
diff --cc arch/powerpc/include/asm/ppc-opcode.h
index 22dd691f9b58,34ee13fb9315..000000000000
--- a/arch/powerpc/include/asm/ppc-opcode.h
+++ b/arch/powerpc/include/asm/ppc-opcode.h
@@@ -505,54 -363,58 +505,77 @@@
  #endif
  
  /* Base instruction encoding */
 -#define PPC_RAW_CP_ABORT		(0x7c00068c)
 +#define PPC_RAW_CP_ABORT		(PPC_INST_CP_ABORT)
  #define PPC_RAW_COPY(a, b)		(PPC_INST_COPY | ___PPC_RA(a) | ___PPC_RB(b))
 -#define PPC_RAW_DARN(t, l)		(0x7c0005e6 | ___PPC_RT(t) | (((l) & 0x3) << 16))
 -#define PPC_RAW_DCBAL(a, b)		(0x7c2005ec | __PPC_RA(a) | __PPC_RB(b))
 -#define PPC_RAW_DCBZL(a, b)		(0x7c2007ec | __PPC_RA(a) | __PPC_RB(b))
 -#define PPC_RAW_LQARX(t, a, b, eh)	(0x7c000228 | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | __PPC_EH(eh))
 -#define PPC_RAW_LDARX(t, a, b, eh)	(0x7c0000a8 | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | __PPC_EH(eh))
 -#define PPC_RAW_LWARX(t, a, b, eh)	(0x7c000028 | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | __PPC_EH(eh))
 -#define PPC_RAW_PHWSYNC			(0x7c8004ac)
 -#define PPC_RAW_PLWSYNC			(0x7ca004ac)
 -#define PPC_RAW_STQCX(t, a, b)		(0x7c00016d | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b))
 -#define PPC_RAW_MADDHD(t, a, b, c)	(0x10000030 | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | ___PPC_RC(c))
 -#define PPC_RAW_MADDHDU(t, a, b, c)	(0x10000031 | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | ___PPC_RC(c))
 -#define PPC_RAW_MADDLD(t, a, b, c)	(0x10000033 | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | ___PPC_RC(c))
 -#define PPC_RAW_MSGSND(b)		(0x7c00019c | ___PPC_RB(b))
 -#define PPC_RAW_MSGSYNC			(0x7c0006ec)
 -#define PPC_RAW_MSGCLR(b)		(0x7c0001dc | ___PPC_RB(b))
 -#define PPC_RAW_MSGSNDP(b)		(0x7c00011c | ___PPC_RB(b))
 -#define PPC_RAW_MSGCLRP(b)		(0x7c00015c | ___PPC_RB(b))
 -#define PPC_RAW_PASTE(a, b)		(0x7c20070d | ___PPC_RA(a) | ___PPC_RB(b))
 +#define PPC_RAW_DARN(t, l)		(PPC_INST_DARN | ___PPC_RT(t) | (((l) & 0x3) << 16))
 +#define PPC_RAW_DCBAL(a, b)		(PPC_INST_DCBAL | __PPC_RA(a) | __PPC_RB(b))
 +#define PPC_RAW_DCBZL(a, b)		(PPC_INST_DCBZL | __PPC_RA(a) | __PPC_RB(b))
 +#define PPC_RAW_LQARX(t, a, b, eh)	(PPC_INST_LQARX | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | __PPC_EH(eh))
 +#define PPC_RAW_LDARX(t, a, b, eh)	(PPC_INST_LDARX | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | __PPC_EH(eh))
 +#define PPC_RAW_LWARX(t, a, b, eh)	(PPC_INST_LWARX | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | __PPC_EH(eh))
 +#define PPC_RAW_PHWSYNC			(PPC_INST_PHWSYNC)
 +#define PPC_RAW_PLWSYNC			(PPC_INST_PLWSYNC)
 +#define PPC_RAW_STQCX(t, a, b)		(PPC_INST_STQCX | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b))
 +#define PPC_RAW_MADDHD(t, a, b, c)	(PPC_INST_MADDHD | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | ___PPC_RC(c))
 +#define PPC_RAW_MADDHDU(t, a, b, c)	(PPC_INST_MADDHDU | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | ___PPC_RC(c))
 +#define PPC_RAW_MADDLD(t, a, b, c)	(PPC_INST_MADDLD | ___PPC_RT(t) | ___PPC_RA(a) | ___PPC_RB(b) | ___PPC_RC(c))
 +#define PPC_RAW_MSGSND(b)		(PPC_INST_MSGSND | ___PPC_RB(b))
 +#define PPC_RAW_MSGSYNC			(PPC_INST_MSGSYNC)
 +#define PPC_RAW_MSGCLR(b)		(PPC_INST_MSGCLR | ___PPC_RB(b))
 +#define PPC_RAW_MSGSNDP(b)		(PPC_INST_MSGSNDP | ___PPC_RB(b))
 +#define PPC_RAW_MSGCLRP(b)		(PPC_INST_MSGCLRP | ___PPC_RB(b))
 +#define PPC_RAW_PASTE(a, b)		(PPC_INST_PASTE | ___PPC_RA(a) | ___PPC_RB(b))
  #define PPC_RAW_POPCNTB(a, s)		(PPC_INST_POPCNTB | __PPC_RA(a) | __PPC_RS(s))
 -#define PPC_RAW_POPCNTD(a, s)		(0x7c0003f4 | __PPC_RA(a) | __PPC_RS(s))
 -#define PPC_RAW_POPCNTW(a, s)		(0x7c0002f4 | __PPC_RA(a) | __PPC_RS(s))
 -#define PPC_RAW_RFCI			(0x4c000066)
 -#define PPC_RAW_RFDI			(0x4c00004e)
 -#define PPC_RAW_RFMCI			(0x4c00004c)
 -#define PPC_RAW_TLBILX(t, a, b)		(0x7c000024 | __PPC_T_TLB(t) | 	__PPC_RA0(a) | __PPC_RB(b))
 -#define PPC_RAW_WAIT(w)			(0x7c00007c | __PPC_WC(w))
 -#define PPC_RAW_TLBIE(lp, a)		(0x7c000264 | ___PPC_RB(a) | ___PPC_RS(lp))
 +#define PPC_RAW_POPCNTD(a, s)		(PPC_INST_POPCNTD | __PPC_RA(a) | __PPC_RS(s))
 +#define PPC_RAW_POPCNTW(a, s)		(PPC_INST_POPCNTW | __PPC_RA(a) | __PPC_RS(s))
 +#define PPC_RAW_RFCI			(PPC_INST_RFCI)
 +#define PPC_RAW_RFDI			(PPC_INST_RFDI)
 +#define PPC_RAW_RFMCI			(PPC_INST_RFMCI)
 +#define PPC_RAW_TLBILX(t, a, b)		(PPC_INST_TLBILX | __PPC_T_TLB(t) | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_WAIT(w)			(PPC_INST_WAIT | __PPC_WC(w))
 +#define PPC_RAW_TLBIE(lp, a)		(PPC_INST_TLBIE | ___PPC_RB(a) | ___PPC_RS(lp))
  #define PPC_RAW_TLBIE_5(rb, rs, ric, prs, r) \
 -	(0x7c000264 | ___PPC_RB(rb) | ___PPC_RS(rs) | ___PPC_RIC(ric) | ___PPC_PRS(prs) | ___PPC_R(r))
 +	(PPC_INST_TLBIE | ___PPC_RB(rb) | ___PPC_RS(rs) | ___PPC_RIC(ric) | ___PPC_PRS(prs) | ___PPC_R(r))
  #define PPC_RAW_TLBIEL(rb, rs, ric, prs, r) \
++<<<<<<< HEAD
 +	(PPC_INST_TLBIEL | ___PPC_RB(rb) | ___PPC_RS(rs) | ___PPC_RIC(ric) | ___PPC_PRS(prs) | ___PPC_R(r))
 +#define PPC_RAW_TLBSRX_DOT(a, b)	(PPC_INST_TLBSRX_DOT | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_TLBIVAX(a, b)		(PPC_INST_TLBIVAX | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_ERATWE(s, a, w)		(PPC_INST_ERATWE | __PPC_RS(s) | __PPC_RA(a) | __PPC_WS(w))
 +#define PPC_RAW_ERATRE(s, a, w)		(PPC_INST_ERATRE | __PPC_RS(s) | __PPC_RA(a) | __PPC_WS(w))
 +#define PPC_RAW_ERATILX(t, a, b)	(PPC_INST_ERATILX | __PPC_T_TLB(t) | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_ERATIVAX(s, a, b)	(PPC_INST_ERATIVAX | __PPC_RS(s) | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_ERATSX(t, a, w)		(PPC_INST_ERATSX | __PPC_RS(t) | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_ERATSX_DOT(t, a, w)	(PPC_INST_ERATSX_DOT | __PPC_RS(t) | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_SLBFEE_DOT(t, b)	(PPC_INST_SLBFEE | __PPC_RT(t) | __PPC_RB(b))
 +#define __PPC_RAW_SLBFEE_DOT(t, b)	(PPC_INST_SLBFEE | ___PPC_RT(t) | ___PPC_RB(b))
 +#define PPC_RAW_ICBT(c, a, b)		(PPC_INST_ICBT | __PPC_CT(c) | __PPC_RA0(a) | __PPC_RB(b))
 +#define PPC_RAW_LBZCIX(t, a, b)		(PPC_INST_LBZCIX | __PPC_RT(t) | __PPC_RA(a) | __PPC_RB(b))
 +#define PPC_RAW_STBCIX(s, a, b)		(PPC_INST_STBCIX | __PPC_RS(s) | __PPC_RA(a) | __PPC_RB(b))
 +#define PPC_RAW_DCBFPS(a, b)		(PPC_INST_DCBF | ___PPC_RA(a) | ___PPC_RB(b) | (4 << 21))
 +#define PPC_RAW_DCBSTPS(a, b)		(PPC_INST_DCBF | ___PPC_RA(a) | ___PPC_RB(b) | (6 << 21))
++=======
+ 	(0x7c000224 | ___PPC_RB(rb) | ___PPC_RS(rs) | ___PPC_RIC(ric) | ___PPC_PRS(prs) | ___PPC_R(r))
+ #define PPC_RAW_TLBSRX_DOT(a, b)	(0x7c0006a5 | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_TLBIVAX(a, b)		(0x7c000624 | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_ERATWE(s, a, w)		(0x7c0001a6 | __PPC_RS(s) | __PPC_RA(a) | __PPC_WS(w))
+ #define PPC_RAW_ERATRE(s, a, w)		(0x7c000166 | __PPC_RS(s) | __PPC_RA(a) | __PPC_WS(w))
+ #define PPC_RAW_ERATILX(t, a, b)	(0x7c000066 | __PPC_T_TLB(t) | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_ERATIVAX(s, a, b)	(0x7c000666 | __PPC_RS(s) | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_ERATSX(t, a, w)		(0x7c000126 | __PPC_RS(t) | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_ERATSX_DOT(t, a, w)	(0x7c000127 | __PPC_RS(t) | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_SLBFEE_DOT(t, b)	(0x7c0007a7 | __PPC_RT(t) | __PPC_RB(b))
+ #define __PPC_RAW_SLBFEE_DOT(t, b)	(0x7c0007a7 | ___PPC_RT(t) | ___PPC_RB(b))
+ #define PPC_RAW_ICBT(c, a, b)		(0x7c00002c | __PPC_CT(c) | __PPC_RA0(a) | __PPC_RB(b))
+ #define PPC_RAW_LBZCIX(t, a, b)		(0x7c0006aa | __PPC_RT(t) | __PPC_RA(a) | __PPC_RB(b))
+ #define PPC_RAW_STBCIX(s, a, b)		(0x7c0007aa | __PPC_RS(s) | __PPC_RA(a) | __PPC_RB(b))
+ #define PPC_RAW_DCBFPS(a, b)		(0x7c0000ac | ___PPC_RA(a) | ___PPC_RB(b) | (4 << 21))
+ #define PPC_RAW_DCBSTPS(a, b)		(0x7c0000ac | ___PPC_RA(a) | ___PPC_RB(b) | (6 << 21))
+ #define PPC_RAW_SC()			(0x44000002)
+ #define PPC_RAW_SYNC()			(0x7c0004ac)
+ #define PPC_RAW_ISYNC()			(0x4c00012c)
+ 
++>>>>>>> ef909ba95414 (powerpc/lib/feature-fixups: Use PPC_RAW_xxx() macros)
  /*
   * Define what the VSX XX1 form instructions will look like, then add
   * the 128 bit load store instructions based on that.
@@@ -688,7 -563,11 +711,15 @@@
  /* sldi = rldicl Rx, Ry, 64-n, n */
  #define PPC_RAW_SRDI(d, a, i)		PPC_RAW_RLDICL(d, a, 64-(i), i)
  
++<<<<<<< HEAD
 +#define PPC_RAW_NEG(d, a)		(PPC_INST_NEG | ___PPC_RT(d) | ___PPC_RA(a))
++=======
+ #define PPC_RAW_NEG(d, a)		(0x7c0000d0 | ___PPC_RT(d) | ___PPC_RA(a))
+ 
+ #define PPC_RAW_MFSPR(d, spr)		(0x7c0002a6 | ___PPC_RT(d) | __PPC_SPR(spr))
+ #define PPC_RAW_MTSPR(spr, d)		(0x7c0003a6 | ___PPC_RS(d) | __PPC_SPR(spr))
+ #define PPC_RAW_EIEIO()			(0x7c0006ac)
++>>>>>>> ef909ba95414 (powerpc/lib/feature-fixups: Use PPC_RAW_xxx() macros)
  
  /* Deal with instructions that older assemblers aren't aware of */
  #define	PPC_BCCTR_FLUSH		stringify_in_c(.long PPC_INST_BCCTR_FLUSH)
diff --cc arch/powerpc/lib/feature-fixups.c
index 8148a2040bce,91bd2000d180..000000000000
--- a/arch/powerpc/lib/feature-fixups.c
+++ b/arch/powerpc/lib/feature-fixups.c
@@@ -129,12 -125,12 +129,12 @@@ void do_stf_entry_barrier_fixups(enum s
  	long *start, *end;
  	int i;
  
 -	start = PTRRELOC(&__start___stf_entry_barrier_fixup);
 +	start = PTRRELOC(&__start___stf_entry_barrier_fixup),
  	end = PTRRELOC(&__stop___stf_entry_barrier_fixup);
  
- 	instrs[0] = 0x60000000; /* nop */
- 	instrs[1] = 0x60000000; /* nop */
- 	instrs[2] = 0x60000000; /* nop */
+ 	instrs[0] = PPC_RAW_NOP();
+ 	instrs[1] = PPC_RAW_NOP();
+ 	instrs[2] = PPC_RAW_NOP();
  
  	i = 0;
  	if (types & STF_BARRIER_FALLBACK) {
@@@ -181,15 -177,15 +181,15 @@@ void do_stf_exit_barrier_fixups(enum st
  	long *start, *end;
  	int i;
  
 -	start = PTRRELOC(&__start___stf_exit_barrier_fixup);
 +	start = PTRRELOC(&__start___stf_exit_barrier_fixup),
  	end = PTRRELOC(&__stop___stf_exit_barrier_fixup);
  
- 	instrs[0] = 0x60000000; /* nop */
- 	instrs[1] = 0x60000000; /* nop */
- 	instrs[2] = 0x60000000; /* nop */
- 	instrs[3] = 0x60000000; /* nop */
- 	instrs[4] = 0x60000000; /* nop */
- 	instrs[5] = 0x60000000; /* nop */
+ 	instrs[0] = PPC_RAW_NOP();
+ 	instrs[1] = PPC_RAW_NOP();
+ 	instrs[2] = PPC_RAW_NOP();
+ 	instrs[3] = PPC_RAW_NOP();
+ 	instrs[4] = PPC_RAW_NOP();
+ 	instrs[5] = PPC_RAW_NOP();
  
  	i = 0;
  	if (types & STF_BARRIER_FALLBACK || types & STF_BARRIER_SYNC_ORI) {
@@@ -310,12 -305,9 +309,18 @@@ static int __do_entry_flush_fixups(voi
  	long *start, *end;
  	int i;
  
++<<<<<<< HEAD
 +	start = PTRRELOC(&__start___entry_flush_fixup);
 +	end = PTRRELOC(&__stop___entry_flush_fixup);
 +
 +	instrs[0] = 0x60000000; /* nop */
 +	instrs[1] = 0x60000000; /* nop */
 +	instrs[2] = 0x60000000; /* nop */
++=======
+ 	instrs[0] = PPC_RAW_NOP();
+ 	instrs[1] = PPC_RAW_NOP();
+ 	instrs[2] = PPC_RAW_NOP();
++>>>>>>> ef909ba95414 (powerpc/lib/feature-fixups: Use PPC_RAW_xxx() macros)
  
  	i = 0;
  	if (types == L1D_FLUSH_FALLBACK) {
@@@ -330,8 -322,35 +335,8 @@@
  	}
  
  	if (types & L1D_FLUSH_MTTRIG)
- 		instrs[i++] = 0x7c12dba6; /* mtspr TRIG2,r0 (SPR #882) */
+ 		instrs[i++] = PPC_RAW_MTSPR(SPRN_TRIG2, _R0);
  
 -	/*
 -	 * If we're patching in or out the fallback flush we need to be careful about the
 -	 * order in which we patch instructions. That's because it's possible we could
 -	 * take a page fault after patching one instruction, so the sequence of
 -	 * instructions must be safe even in a half patched state.
 -	 *
 -	 * To make that work, when patching in the fallback flush we patch in this order:
 -	 *  - the mflr		(dest)
 -	 *  - the mtlr		(dest + 2)
 -	 *  - the branch	(dest + 1)
 -	 *
 -	 * That ensures the sequence is safe to execute at any point. In contrast if we
 -	 * patch the mtlr last, it's possible we could return from the branch and not
 -	 * restore LR, leading to a crash later.
 -	 *
 -	 * When patching out the fallback flush (either with nops or another flush type),
 -	 * we patch in this order:
 -	 *  - the branch	(dest + 1)
 -	 *  - the mtlr		(dest + 2)
 -	 *  - the mflr		(dest)
 -	 *
 -	 * Note we are protected by stop_machine() from other CPUs executing the code in a
 -	 * semi-patched state.
 -	 */
 -
 -	start = PTRRELOC(&__start___entry_flush_fixup);
 -	end = PTRRELOC(&__stop___entry_flush_fixup);
  	for (i = 0; start < end; start++, i++) {
  		dest = (void *)start + *start;
  
@@@ -377,12 -417,12 +382,12 @@@ void do_rfi_flush_fixups(enum l1d_flush
  	long *start, *end;
  	int i;
  
 -	start = PTRRELOC(&__start___rfi_flush_fixup);
 +	start = PTRRELOC(&__start___rfi_flush_fixup),
  	end = PTRRELOC(&__stop___rfi_flush_fixup);
  
- 	instrs[0] = 0x60000000; /* nop */
- 	instrs[1] = 0x60000000; /* nop */
- 	instrs[2] = 0x60000000; /* nop */
+ 	instrs[0] = PPC_RAW_NOP();
+ 	instrs[1] = PPC_RAW_NOP();
+ 	instrs[2] = PPC_RAW_NOP();
  
  	if (types & L1D_FLUSH_FALLBACK)
  		/* b .+16 to fallback flush */
* Unmerged path arch/powerpc/include/asm/ppc-opcode.h
diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h
index 221c2253b797..c0502bd31cbb 100644
--- a/arch/powerpc/include/asm/reg.h
+++ b/arch/powerpc/include/asm/reg.h
@@ -386,6 +386,7 @@
 #define SPRN_PMMAR	0x356	/* Power Management Memory Activity Register */
 #define SPRN_PSSCR	0x357	/* Processor Stop Status and Control Register (ISA 3.0) */
 #define SPRN_PSSCR_PR	0x337	/* PSSCR ISA 3.0, privileged mode access */
+#define SPRN_TRIG2	0x372
 #define SPRN_PMCR	0x374	/* Power Management Control Register */
 #define SPRN_RWMR	0x375	/* Region-Weighting Mode Register */
 
* Unmerged path arch/powerpc/lib/feature-fixups.c
