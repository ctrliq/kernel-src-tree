net/mlx5: Store IPsec ESN update work in XFRM state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit c674df973ad8af2074c834788e167332d81309fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/c674df97.failed

mlx5 IPsec code updated ESN through workqueue with allocation calls
in the data path, which can be saved easily if the work is created
during XFRM state initialization routine.

The locking used later in the work didn't protect from anything because
change of HW context is possible during XFRM state add or delete only,
which can cancel work and make sure that it is not running.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit c674df973ad8af2074c834788e167332d81309fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
index 3364320a61a4,bbfb6643ed80..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
@@@ -267,16 -270,8 +259,13 @@@ static void mlx5_ipsec_offload_delete_s
  	mlx5_destroy_ipsec_obj(sa_ctx->dev, sa_ctx->ipsec_obj_id);
  	mlx5_destroy_encryption_key(sa_ctx->dev, sa_ctx->enc_key_id);
  	kfree(sa_ctx);
- 	mxfrm->sa_ctx = NULL;
- 	mutex_unlock(&mxfrm->lock);
  }
  
 +static int mlx5_ipsec_offload_init(struct mlx5_core_dev *mdev)
 +{
 +	return 0;
 +}
 +
  static int mlx5_modify_ipsec_obj(struct mlx5_core_dev *mdev,
  				 struct mlx5_ipsec_obj_attrs *attrs,
  				 u32 ipsec_id)
@@@ -356,28 -339,55 +333,68 @@@ static void mlx5_ipsec_offload_esp_modi
  				    &ipsec_attrs,
  				    mxfrm->sa_ctx->ipsec_obj_id);
  
- change_sw_xfrm_attrs:
  	if (!err)
  		memcpy(&xfrm->attrs, attrs, sizeof(xfrm->attrs));
- 
- 	mutex_unlock(&mxfrm->lock);
- 	return err;
  }
  
 -void *mlx5_accel_esp_create_hw_context(struct mlx5_core_dev *mdev,
 -				       struct mlx5_accel_esp_xfrm *xfrm,
 -				       u32 *sa_handle)
 +static const struct mlx5_accel_ipsec_ops ipsec_offload_ops = {
 +	.device_caps = mlx5_ipsec_offload_device_caps,
 +	.create_hw_context = mlx5_ipsec_offload_create_sa_ctx,
 +	.free_hw_context = mlx5_ipsec_offload_delete_sa_ctx,
 +	.init = mlx5_ipsec_offload_init,
 +	.esp_create_xfrm = mlx5_ipsec_offload_esp_create_xfrm,
 +	.esp_destroy_xfrm = mlx5_ipsec_offload_esp_destroy_xfrm,
 +	.esp_modify_xfrm = mlx5_ipsec_offload_esp_modify_xfrm,
 +};
 +
 +const struct mlx5_accel_ipsec_ops *mlx5_ipsec_offload_ops(struct mlx5_core_dev *mdev)
  {
 -	__be32 saddr[4] = {}, daddr[4] = {};
 +	if (!mlx5_ipsec_offload_device_caps(mdev))
 +		return NULL;
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +	return &ipsec_offload_ops;
++=======
+ 	if (!xfrm->attrs.is_ipv6) {
+ 		saddr[3] = xfrm->attrs.saddr.a4;
+ 		daddr[3] = xfrm->attrs.daddr.a4;
+ 	} else {
+ 		memcpy(saddr, xfrm->attrs.saddr.a6, sizeof(saddr));
+ 		memcpy(daddr, xfrm->attrs.daddr.a6, sizeof(daddr));
+ 	}
+ 
+ 	return mlx5_ipsec_offload_create_sa_ctx(mdev, xfrm, saddr, daddr,
+ 						xfrm->attrs.spi,
+ 						xfrm->attrs.is_ipv6, sa_handle);
+ }
+ 
+ void mlx5_accel_esp_free_hw_context(struct mlx5_core_dev *mdev, void *context)
+ {
+ 	mlx5_ipsec_offload_delete_sa_ctx(context);
+ }
+ 
+ struct mlx5_accel_esp_xfrm *
+ mlx5_accel_esp_create_xfrm(struct mlx5_core_dev *mdev,
+ 			   const struct mlx5_accel_esp_xfrm_attrs *attrs)
+ {
+ 	struct mlx5_accel_esp_xfrm *xfrm;
+ 
+ 	xfrm = mlx5_ipsec_offload_esp_create_xfrm(mdev, attrs);
+ 	if (IS_ERR(xfrm))
+ 		return xfrm;
+ 
+ 	xfrm->mdev = mdev;
+ 	return xfrm;
+ }
+ 
+ void mlx5_accel_esp_destroy_xfrm(struct mlx5_accel_esp_xfrm *xfrm)
+ {
+ 	mlx5_ipsec_offload_esp_destroy_xfrm(xfrm);
+ }
+ 
+ void mlx5_accel_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
+ 				const struct mlx5_accel_esp_xfrm_attrs *attrs)
+ {
+ 	mlx5_ipsec_offload_esp_modify_xfrm(xfrm, attrs);
++>>>>>>> c674df973ad8 (net/mlx5: Store IPsec ESN update work in XFRM state):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
index 027d80b77b28,8283cf273a63..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
@@@ -377,11 -375,8 +388,11 @@@ static void mlx5e_xfrm_free_state(struc
  	struct mlx5e_ipsec_sa_entry *sa_entry = to_ipsec_sa_entry(x);
  	struct mlx5e_priv *priv = netdev_priv(x->xso.dev);
  
 +	if (!sa_entry)
 +		return;
 +
  	if (sa_entry->hw_context) {
- 		flush_workqueue(sa_entry->ipsec->wq);
+ 		cancel_work_sync(&sa_entry->modify_work.work);
  		mlx5e_accel_ipsec_fs_del_rule(priv, &sa_entry->xfrm->attrs,
  					      &sa_entry->ipsec_rule);
  		mlx5_accel_esp_free_hw_context(sa_entry->xfrm->mdev, sa_entry->hw_context);
@@@ -406,7 -402,7 +417,11 @@@ int mlx5e_ipsec_init(struct mlx5e_priv 
  
  	hash_init(ipsec->sadb_rx);
  	spin_lock_init(&ipsec->sadb_rx_lock);
++<<<<<<< HEAD
 +	ipsec->en_priv = priv;
++=======
+ 	ipsec->mdev = priv->mdev;
++>>>>>>> c674df973ad8 (net/mlx5: Store IPsec ESN update work in XFRM state)
  	ipsec->wq = alloc_ordered_workqueue("mlx5e_ipsec: %s", 0,
  					    priv->netdev->name);
  	if (!ipsec->wq) {
@@@ -427,9 -432,8 +442,8 @@@ void mlx5e_ipsec_cleanup(struct mlx5e_p
  	if (!ipsec)
  		return;
  
 -	mlx5e_accel_ipsec_fs_cleanup(ipsec);
 +	mlx5e_accel_ipsec_fs_cleanup(priv);
  	destroy_workqueue(ipsec->wq);
- 
  	kfree(ipsec);
  	priv->ipsec = NULL;
  }
@@@ -452,34 -456,10 +466,13 @@@ static bool mlx5e_ipsec_offload_ok(stru
  static void mlx5e_xfrm_advance_esn_state(struct xfrm_state *x)
  {
  	struct mlx5e_ipsec_sa_entry *sa_entry = to_ipsec_sa_entry(x);
- 	struct mlx5e_ipsec_modify_state_work *modify_work;
+ 	struct mlx5e_ipsec_modify_state_work *modify_work =
+ 		&sa_entry->modify_work;
  	bool need_update;
  
 +	if (!sa_entry)
 +		return;
 +
  	need_update = mlx5e_ipsec_update_esn_state(sa_entry);
  	if (!need_update)
  		return;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
index 45f71910d196,35a751faeb33..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
@@@ -79,7 -61,7 +79,11 @@@ struct mlx5e_accel_fs_esp
  struct mlx5e_ipsec_tx;
  
  struct mlx5e_ipsec {
++<<<<<<< HEAD
 +	struct mlx5e_priv *en_priv;
++=======
+ 	struct mlx5_core_dev *mdev;
++>>>>>>> c674df973ad8 (net/mlx5: Store IPsec ESN update work in XFRM state)
  	DECLARE_HASHTABLE(sadb_rx, MLX5E_IPSEC_SADB_RX_BITS);
  	spinlock_t sadb_rx_lock; /* Protects sadb_rx */
  	struct mlx5e_ipsec_sw_stats sw_stats;
@@@ -112,9 -98,9 +121,10 @@@ struct mlx5e_ipsec_sa_entry 
  			  struct xfrm_offload *xo);
  	u32 ipsec_obj_id;
  	struct mlx5e_ipsec_rule ipsec_rule;
+ 	struct mlx5e_ipsec_modify_state_work modify_work;
  };
  
 +void mlx5e_ipsec_build_inverse_table(void);
  int mlx5e_ipsec_init(struct mlx5e_priv *priv);
  void mlx5e_ipsec_cleanup(struct mlx5e_priv *priv);
  void mlx5e_ipsec_build_netdev(struct mlx5e_priv *priv);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
diff --git a/include/linux/mlx5/accel.h b/include/linux/mlx5/accel.h
index f00a934bbd6f..d80c22900b31 100644
--- a/include/linux/mlx5/accel.h
+++ b/include/linux/mlx5/accel.h
@@ -127,8 +127,8 @@ struct mlx5_accel_esp_xfrm *
 mlx5_accel_esp_create_xfrm(struct mlx5_core_dev *mdev,
 			   const struct mlx5_accel_esp_xfrm_attrs *attrs);
 void mlx5_accel_esp_destroy_xfrm(struct mlx5_accel_esp_xfrm *xfrm);
-int mlx5_accel_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
-			       const struct mlx5_accel_esp_xfrm_attrs *attrs);
+void mlx5_accel_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
+				const struct mlx5_accel_esp_xfrm_attrs *attrs);
 
 #else
 
@@ -142,9 +142,11 @@ mlx5_accel_esp_create_xfrm(struct mlx5_core_dev *mdev,
 }
 static inline void
 mlx5_accel_esp_destroy_xfrm(struct mlx5_accel_esp_xfrm *xfrm) {}
-static inline int
+static inline void
 mlx5_accel_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
-			   const struct mlx5_accel_esp_xfrm_attrs *attrs) { return -EOPNOTSUPP; }
+			   const struct mlx5_accel_esp_xfrm_attrs *attrs)
+{
+}
 
 #endif /* CONFIG_MLX5_ACCEL */
 #endif /* __MLX5_ACCEL_H__ */
