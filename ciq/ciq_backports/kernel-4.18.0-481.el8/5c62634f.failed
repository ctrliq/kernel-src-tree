namespace: make timens_on_fork() return nothing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Hui Su <sh_def@163.com>
commit 5c62634fc65101d350cbd47722fb76f02693059d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/5c62634f.failed

timens_on_fork() always return 0, and maybe not
need to judge the return value in copy_namespaces().

So make timens_on_fork() return nothing and do not
judge its return val in copy_namespaces().

	Signed-off-by: Hui Su <sh_def@163.com>
Link: https://lore.kernel.org/r/20201117161750.GA45121@rlk
	Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
(cherry picked from commit 5c62634fc65101d350cbd47722fb76f02693059d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/namespace.c
diff --cc kernel/time/namespace.c
index c56b0f0bdd44,e0f9509b17c3..000000000000
--- a/kernel/time/namespace.c
+++ b/kernel/time/namespace.c
@@@ -312,17 -315,13 +312,21 @@@ void timens_on_fork(struct nsproxy *nsp
  
  	/* create_new_namespaces() already incremented the ref counter */
  	if (nsproxy->time_ns == nsproxy->time_ns_for_children)
- 		return 0;
+ 		return;
  
 +	timens_set_vvar_page(tsk, ns);
 +
 +	vdso_join_timens(tsk, ns);
 +
  	get_time_ns(ns);
  	put_time_ns(nsproxy->time_ns);
  	nsproxy->time_ns = ns;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	timens_commit(tsk, ns);
++>>>>>>> 5c62634fc651 (namespace: make timens_on_fork() return nothing)
  }
  
  static struct user_namespace *timens_owner(struct ns_common *ns)
diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 824d54e057eb..0d69d073a426 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -44,7 +44,7 @@ struct time_namespace *copy_time_ns(unsigned long flags,
 				    struct user_namespace *user_ns,
 				    struct time_namespace *old_ns);
 void free_time_ns(struct kref *kref);
-int timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk);
+void timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk);
 struct vdso_data *arch_get_vdso_data(void *vvar_page);
 
 static inline void put_time_ns(struct time_namespace *ns)
@@ -116,10 +116,10 @@ struct time_namespace *copy_time_ns(unsigned long flags,
 	return old_ns;
 }
 
-static inline int timens_on_fork(struct nsproxy *nsproxy,
+static inline void timens_on_fork(struct nsproxy *nsproxy,
 				 struct task_struct *tsk)
 {
-	return 0;
+	return;
 }
 
 static inline void timens_add_monotonic(struct timespec64 *ts) { }
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index 586c9e2017dc..db0c3f570461 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -155,7 +155,6 @@ int copy_namespaces(unsigned long flags, struct task_struct *tsk)
 	struct nsproxy *old_ns = tsk->nsproxy;
 	struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);
 	struct nsproxy *new_ns;
-	int ret;
 
 	if (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
 			      CLONE_NEWPID | CLONE_NEWNET |
@@ -182,11 +181,7 @@ int copy_namespaces(unsigned long flags, struct task_struct *tsk)
 	if (IS_ERR(new_ns))
 		return  PTR_ERR(new_ns);
 
-	ret = timens_on_fork(new_ns, tsk);
-	if (ret) {
-		free_nsproxy(new_ns);
-		return ret;
-	}
+	timens_on_fork(new_ns, tsk);
 
 	tsk->nsproxy = new_ns;
 	return 0;
* Unmerged path kernel/time/namespace.c
