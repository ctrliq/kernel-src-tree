net-sysctl: factor out cpumask parsing helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 135746c61fa6d7f66dc079027304eaa4d35fe942
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/135746c6.failed

Will be used by the following patch to avoid code
duplication. No functional changes intended.

The only difference is that now flow_limit_cpu_sysctl() will
always compute the flow limit mask on each read operation,
even when read() will not return any byte to user-space.

Note that the new helper is placed under a new #ifdef at
the file start to better fit the usage in the later patch

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 135746c61fa6d7f66dc079027304eaa4d35fe942)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/sysctl_net_core.c
diff --cc net/core/sysctl_net_core.c
index 5ff9b3d67973,6935ecdc84b0..000000000000
--- a/net/core/sysctl_net_core.c
+++ b/net/core/sysctl_net_core.c
@@@ -36,9 -35,46 +36,49 @@@ static int net_msg_warn;	/* Unused, bu
  int sysctl_fb_tunnels_only_for_init_net __read_mostly = 0;
  EXPORT_SYMBOL(sysctl_fb_tunnels_only_for_init_net);
  
++<<<<<<< HEAD
++=======
+ /* 0 - Keep current behavior:
+  *     IPv4: inherit all current settings from init_net
+  *     IPv6: reset all settings to default
+  * 1 - Both inherit all current settings from init_net
+  * 2 - Both reset all settings to default
+  * 3 - Both inherit all settings from current netns
+  */
+ int sysctl_devconf_inherit_init_net __read_mostly;
+ EXPORT_SYMBOL(sysctl_devconf_inherit_init_net);
+ 
+ #if IS_ENABLED(CONFIG_NET_FLOW_LIMIT)
+ static void dump_cpumask(void *buffer, size_t *lenp, loff_t *ppos,
+ 			 struct cpumask *mask)
+ {
+ 	char kbuf[128];
+ 	int len;
+ 
+ 	if (*ppos || !*lenp) {
+ 		*lenp = 0;
+ 		return;
+ 	}
+ 
+ 	len = min(sizeof(kbuf) - 1, *lenp);
+ 	len = scnprintf(kbuf, len, "%*pb", cpumask_pr_args(mask));
+ 	if (!len) {
+ 		*lenp = 0;
+ 		return;
+ 	}
+ 
+ 	if (len < *lenp)
+ 		kbuf[len++] = '\n';
+ 	memcpy(buffer, kbuf, len);
+ 	*lenp = len;
+ 	*ppos += len;
+ }
+ #endif
+ 
++>>>>>>> 135746c61fa6 (net-sysctl: factor out cpumask parsing helper)
  #ifdef CONFIG_RPS
  static int rps_sock_flow_sysctl(struct ctl_table *table, int write,
 -				void *buffer, size_t *lenp, loff_t *ppos)
 +				void __user *buffer, size_t *lenp, loff_t *ppos)
  {
  	unsigned int orig_size, size;
  	int ret, i;
@@@ -165,20 -191,7 +198,24 @@@ write_unlock
  		}
  		rcu_read_unlock();
  
++<<<<<<< HEAD
 +		len = min(sizeof(kbuf) - 1, *lenp);
 +		len = scnprintf(kbuf, len, "%*pb", cpumask_pr_args(mask));
 +		if (!len) {
 +			*lenp = 0;
 +			goto done;
 +		}
 +		if (len < *lenp)
 +			kbuf[len++] = '\n';
 +		if (copy_to_user(buffer, kbuf, len)) {
 +			ret = -EFAULT;
 +			goto done;
 +		}
 +		*lenp = len;
 +		*ppos += len;
++=======
+ 		dump_cpumask(buffer, lenp, ppos, mask);
++>>>>>>> 135746c61fa6 (net-sysctl: factor out cpumask parsing helper)
  	}
  
  done:
* Unmerged path net/core/sysctl_net_core.c
