net/mlx5: E-switch, Set to legacy mode if failed to change switchdev mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Chris Mi <cmi@nvidia.com>
commit e12de39c07a7872c1ac7250311bb60b74ff29f25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/e12de39c.failed

No need to rollback to the other mode because probably will fail
again. Just set to legacy mode and clear fdb table created flag.
So that fdb table will not be cleared again.

Fixes: f019679ea5f2 ("net/mlx5: E-switch, Remove dependency between sriov and eswitch mode")
	Signed-off-by: Chris Mi <cmi@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit e12de39c07a7872c1ac7250311bb60b74ff29f25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index b4f03e2a26bb,2169486c4bfb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1353,6 -1351,31 +1353,7 @@@ void mlx5_eswitch_disable_locked(struc
  		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
  		 esw->esw_funcs.num_vfs, esw->enabled_vports);
  
 -	mlx5_eswitch_unload_vf_vports(esw, esw->esw_funcs.num_vfs);
 -	if (clear_vf)
 -		mlx5_eswitch_clear_vf_vports_info(esw);
 -	/* If disabling sriov in switchdev mode, free meta rules here
 -	 * because it depends on num_vfs.
 -	 */
 -	if (esw->mode == MLX5_ESWITCH_OFFLOADS) {
 -		struct devlink *devlink = priv_to_devlink(esw->dev);
 -
 -		devl_rate_nodes_destroy(devlink);
 -	}
 -
 -	esw->esw_funcs.num_vfs = 0;
 -
 -unlock:
 -	up_write(&esw->mode_lock);
 -}
 -
 -/* Free resources for corresponding eswitch mode. It is called by devlink
 - * when changing eswitch mode or modprobe when unloading driver.
 - */
 -void mlx5_eswitch_disable_locked(struct mlx5_eswitch *esw)
 -{
 -	struct devlink *devlink = priv_to_devlink(esw->dev);
 -
++<<<<<<< HEAD
  	/* Notify eswitch users that it is exiting from current mode.
  	 * So that it can do necessary cleanup before the eswitch is disabled.
  	 */
@@@ -1360,26 -1383,24 +1361,36 @@@
  
  	mlx5_eswitch_event_handlers_unregister(esw);
  
 -	esw_info(esw->dev, "Disable: mode(%s), nvfs(%d), active vports(%d)\n",
 -		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
 -		 esw->esw_funcs.num_vfs, esw->enabled_vports);
 +	if (esw->mode == MLX5_ESWITCH_LEGACY)
 +		esw_legacy_disable(esw);
 +	else if (esw->mode == MLX5_ESWITCH_OFFLOADS)
 +		esw_offloads_disable(esw);
 +
 +	old_mode = esw->mode;
 +	esw->mode = MLX5_ESWITCH_NONE;
 +
 +	if (old_mode == MLX5_ESWITCH_OFFLOADS)
 +		mlx5_rescan_drivers(esw->dev);
  
 +	devlink_rate_nodes_destroy(devlink);
 +
 +	mlx5_esw_acls_ns_cleanup(esw);
++=======
+ 	if (esw->fdb_table.flags & MLX5_ESW_FDB_CREATED) {
+ 		esw->fdb_table.flags &= ~MLX5_ESW_FDB_CREATED;
+ 		if (esw->mode == MLX5_ESWITCH_OFFLOADS)
+ 			esw_offloads_disable(esw);
+ 		else if (esw->mode == MLX5_ESWITCH_LEGACY)
+ 			esw_legacy_disable(esw);
+ 		mlx5_esw_acls_ns_cleanup(esw);
+ 	}
++>>>>>>> e12de39c07a7 (net/mlx5: E-switch, Set to legacy mode if failed to change switchdev mode)
  
 -	if (esw->mode == MLX5_ESWITCH_OFFLOADS)
 -		devl_rate_nodes_destroy(devlink);
 +	if (clear_vf)
 +		mlx5_eswitch_clear_vf_vports_info(esw);
  }
  
 -void mlx5_eswitch_disable(struct mlx5_eswitch *esw)
 +void mlx5_eswitch_disable(struct mlx5_eswitch *esw, bool clear_vf)
  {
  	if (!mlx5_esw_allowed(esw))
  		return;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 401935638776,728ca9f2bb9d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -2199,20 -2310,15 +2199,25 @@@ out
  static int esw_offloads_start(struct mlx5_eswitch *esw,
  			      struct netlink_ext_ack *extack)
  {
- 	int err, err1;
+ 	int err;
  
 -	esw->mode = MLX5_ESWITCH_OFFLOADS;
 -	err = mlx5_eswitch_enable_locked(esw, esw->dev->priv.sriov.num_vfs);
 +	mlx5_eswitch_disable_locked(esw, false);
 +	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_OFFLOADS,
 +					 esw->dev->priv.sriov.num_vfs);
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack,
  				   "Failed setting eswitch to offloads");
++<<<<<<< HEAD
 +		err1 = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_LEGACY,
 +						  MLX5_ESWITCH_IGNORE_NUM_VFS);
 +		if (err1) {
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "Failed setting eswitch back to legacy");
 +		}
++=======
+ 		esw->mode = MLX5_ESWITCH_LEGACY;
+ 		mlx5_rescan_drivers(esw->dev);
++>>>>>>> e12de39c07a7 (net/mlx5: E-switch, Set to legacy mode if failed to change switchdev mode)
  	}
  	if (esw->offloads.inline_mode == MLX5_INLINE_MODE_NONE) {
  		if (mlx5_eswitch_inline_mode_get(esw,
@@@ -3255,20 -3384,12 +3260,27 @@@ err_metadata
  static int esw_offloads_stop(struct mlx5_eswitch *esw,
  			     struct netlink_ext_ack *extack)
  {
- 	int err, err1;
+ 	int err;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_locked(esw, false);
 +	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_LEGACY,
 +					 MLX5_ESWITCH_IGNORE_NUM_VFS);
 +	if (err) {
 +		NL_SET_ERR_MSG_MOD(extack, "Failed setting eswitch to legacy");
 +		err1 = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_OFFLOADS,
 +						  MLX5_ESWITCH_IGNORE_NUM_VFS);
 +		if (err1) {
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "Failed setting eswitch back to offloads");
 +		}
 +	}
++=======
+ 	esw->mode = MLX5_ESWITCH_LEGACY;
+ 	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_IGNORE_NUM_VFS);
+ 	if (err)
+ 		NL_SET_ERR_MSG_MOD(extack, "Failed setting eswitch to legacy");
++>>>>>>> e12de39c07a7 (net/mlx5: E-switch, Set to legacy mode if failed to change switchdev mode)
  
  	return err;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
