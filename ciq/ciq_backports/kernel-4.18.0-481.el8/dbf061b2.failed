perf/x86/uncore: Factor out uncore_device_to_die()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Kan Liang <kan.liang@linux.intel.com>
commit dbf061b26221fa1a99e6489dd61f5b4ee97a24e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/dbf061b2.failed

The same code is used to retrieve the logical die ID with a given PCI
device in both the discovery code and the code that supports a system
with > 8 nodes.

Factor out uncore_device_to_die() to replace the duplicate code.

No functional change.

	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Tested-by: Michael Petlan <mpetlan@redhat.com>
Link: https://lore.kernel.org/r/20230112200105.733466-2-kan.liang@linux.intel.com
(cherry picked from commit dbf061b26221fa1a99e6489dd61f5b4ee97a24e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/uncore_discovery.c
#	arch/x86/events/intel/uncore_snbep.c
diff --cc arch/x86/events/intel/uncore_discovery.c
index 8084b84e251e,08af92af2be2..000000000000
--- a/arch/x86/events/intel/uncore_discovery.c
+++ b/arch/x86/events/intel/uncore_discovery.c
@@@ -43,19 -43,7 +43,23 @@@ static int get_device_die_id(struct pci
  	if (node < 0)
  		return logical_die_id++;
  
++<<<<<<< HEAD
 +	for_each_cpu(cpu, cpumask_of_node(node)) {
 +		struct cpuinfo_x86 *c = &cpu_data(cpu);
 +
 +		if (c->initialized && cpu_to_node(cpu) == node)
 +			return c->_rh.logical_die_id;
 +	}
 +
 +	/*
 +	 * All CPUs of a node may be offlined. For this case,
 +	 * the PCI and MMIO type of uncore blocks which are
 +	 * enumerated by the device will be unavailable.
 +	 */
 +	return -1;
++=======
+ 	return uncore_device_to_die(dev);
++>>>>>>> dbf061b26221 (perf/x86/uncore: Factor out uncore_device_to_die())
  }
  
  #define __node_2_type(cur)	\
diff --cc arch/x86/events/intel/uncore_snbep.c
index 3ce3cdd04c7a,31acc96ccb69..000000000000
--- a/arch/x86/events/intel/uncore_snbep.c
+++ b/arch/x86/events/intel/uncore_snbep.c
@@@ -1465,15 -1462,8 +1462,16 @@@ static int snbep_pci2phy_map_init(int d
  				break;
  			}
  
- 			die_id = -1;
- 			for_each_cpu(cpu, cpumask_of_pcibus(ubox_dev->bus)) {
- 				struct cpuinfo_x86 *c = &cpu_data(cpu);
+ 			map->pbus_to_dieid[bus] = die_id = uncore_device_to_die(ubox_dev);
  
++<<<<<<< HEAD
 +				if (c->initialized && cpu_to_node(cpu) == node) {
 +					map->pbus_to_dieid[bus] = die_id = c->_rh.logical_die_id;
 +					break;
 +				}
 +			}
++=======
++>>>>>>> dbf061b26221 (perf/x86/uncore: Factor out uncore_device_to_die())
  			raw_spin_unlock(&pci2phy_map_lock);
  
  			if (WARN_ON_ONCE(die_id == -1)) {
diff --git a/arch/x86/events/intel/uncore.c b/arch/x86/events/intel/uncore.c
index c070445a5c26..f0de7d848c29 100644
--- a/arch/x86/events/intel/uncore.c
+++ b/arch/x86/events/intel/uncore.c
@@ -64,6 +64,21 @@ int uncore_die_to_segment(int die)
 	return bus ? pci_domain_nr(bus) : -EINVAL;
 }
 
+int uncore_device_to_die(struct pci_dev *dev)
+{
+	int node = pcibus_to_node(dev->bus);
+	int cpu;
+
+	for_each_cpu(cpu, cpumask_of_pcibus(dev->bus)) {
+		struct cpuinfo_x86 *c = &cpu_data(cpu);
+
+		if (c->initialized && cpu_to_node(cpu) == node)
+			return c->logical_die_id;
+	}
+
+	return -1;
+}
+
 static void uncore_free_pcibus_map(void)
 {
 	struct pci2phy_map *map, *tmp;
diff --git a/arch/x86/events/intel/uncore.h b/arch/x86/events/intel/uncore.h
index e278e2e7c051..8d493bea9eb6 100644
--- a/arch/x86/events/intel/uncore.h
+++ b/arch/x86/events/intel/uncore.h
@@ -208,6 +208,7 @@ struct pci2phy_map {
 struct pci2phy_map *__find_pci2phy_map(int segment);
 int uncore_pcibus_to_dieid(struct pci_bus *bus);
 int uncore_die_to_segment(int die);
+int uncore_device_to_die(struct pci_dev *dev);
 
 ssize_t uncore_event_show(struct device *dev,
 			  struct device_attribute *attr, char *buf);
* Unmerged path arch/x86/events/intel/uncore_discovery.c
* Unmerged path arch/x86/events/intel/uncore_snbep.c
