powerpc/bpf/64: add support for BPF_ATOMIC bitwise operations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Hari Bathini <hbathini@linux.ibm.com>
commit 65112709115f48f16d7082bcabf173d08622e69f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/65112709.failed

Adding instructions for ppc64 for

atomic[64]_and
atomic[64]_or
atomic[64]_xor

	Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
	Tested-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com> (ppc64le)
	Reviewed-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20220610155552.25892-2-hbathini@linux.ibm.com

(cherry picked from commit 65112709115f48f16d7082bcabf173d08622e69f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/net/bpf_jit_comp64.c
diff --cc arch/powerpc/net/bpf_jit_comp64.c
index 3361fea2cdf5,c421bedd0e98..000000000000
--- a/arch/powerpc/net/bpf_jit_comp64.c
+++ b/arch/powerpc/net/bpf_jit_comp64.c
@@@ -736,41 -777,42 +736,76 @@@ emit_clear
  		 * BPF_STX ATOMIC (atomic ops)
  		 */
  		case BPF_STX | BPF_ATOMIC | BPF_W:
++<<<<<<< HEAD
 +			if (imm != BPF_ADD) {
 +				pr_err_ratelimited(
 +					"eBPF filter atomic op code %02x (@%d) unsupported\n",
 +					code, i);
 +				return -ENOTSUPP;
 +			}
 +
 +			/* *(u32 *)(dst + off) += src */
 +
 +			/* Get EA into TMP_REG_1 */
 +			EMIT(PPC_RAW_ADDI(b2p[TMP_REG_1], dst_reg, off));
 +			tmp_idx = ctx->idx * 4;
 +			/* load value from memory into TMP_REG_2 */
 +			EMIT(PPC_RAW_LWARX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1], 0));
 +			/* add value from src_reg into this */
 +			EMIT(PPC_RAW_ADD(b2p[TMP_REG_2], b2p[TMP_REG_2], src_reg));
 +			/* store result back */
 +			EMIT(PPC_RAW_STWCX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1]));
 +			/* we're done if this succeeded */
 +			PPC_BCC_SHORT(COND_NE, tmp_idx);
 +			break;
 +		case BPF_STX | BPF_ATOMIC | BPF_DW:
 +			if (imm != BPF_ADD) {
++=======
+ 		case BPF_STX | BPF_ATOMIC | BPF_DW:
+ 			/* Get offset into TMP_REG_1 */
+ 			EMIT(PPC_RAW_LI(tmp1_reg, off));
+ 			tmp_idx = ctx->idx * 4;
+ 			/* load value from memory into TMP_REG_2 */
+ 			if (size == BPF_DW)
+ 				EMIT(PPC_RAW_LDARX(tmp2_reg, tmp1_reg, dst_reg, 0));
+ 			else
+ 				EMIT(PPC_RAW_LWARX(tmp2_reg, tmp1_reg, dst_reg, 0));
+ 
+ 			switch (imm) {
+ 			case BPF_ADD:
+ 				EMIT(PPC_RAW_ADD(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			case BPF_AND:
+ 				EMIT(PPC_RAW_AND(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			case BPF_OR:
+ 				EMIT(PPC_RAW_OR(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			case BPF_XOR:
+ 				EMIT(PPC_RAW_XOR(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			default:
++>>>>>>> 65112709115f (powerpc/bpf/64: add support for BPF_ATOMIC bitwise operations)
  				pr_err_ratelimited(
  					"eBPF filter atomic op code %02x (@%d) unsupported\n",
  					code, i);
- 				return -ENOTSUPP;
+ 				return -EOPNOTSUPP;
  			}
- 			/* *(u64 *)(dst + off) += src */
  
++<<<<<<< HEAD
 +			EMIT(PPC_RAW_ADDI(b2p[TMP_REG_1], dst_reg, off));
 +			tmp_idx = ctx->idx * 4;
 +			EMIT(PPC_RAW_LDARX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1], 0));
 +			EMIT(PPC_RAW_ADD(b2p[TMP_REG_2], b2p[TMP_REG_2], src_reg));
 +			EMIT(PPC_RAW_STDCX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1]));
++=======
+ 			/* store result back */
+ 			if (size == BPF_DW)
+ 				EMIT(PPC_RAW_STDCX(tmp2_reg, tmp1_reg, dst_reg));
+ 			else
+ 				EMIT(PPC_RAW_STWCX(tmp2_reg, tmp1_reg, dst_reg));
+ 			/* we're done if this succeeded */
++>>>>>>> 65112709115f (powerpc/bpf/64: add support for BPF_ATOMIC bitwise operations)
  			PPC_BCC_SHORT(COND_NE, tmp_idx);
  			break;
  
* Unmerged path arch/powerpc/net/bpf_jit_comp64.c
