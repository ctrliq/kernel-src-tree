net: phy: Introduce phy related fwnode functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Calvin Johnson <calvin.johnson@oss.nxp.com>
commit 425775ed31a6fac8b66ab077f7936fafad895ef6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/425775ed.failed

Define fwnode_phy_find_device() to iterate an mdiobus and find the
phy device of the provided phy fwnode. Additionally define
device_phy_find_device() to find phy device of provided device.

Define fwnode_get_phy_node() to get phy_node using named reference.

	Signed-off-by: Calvin Johnson <calvin.johnson@oss.nxp.com>
	Signed-off-by: Ioana Ciornei <ioana.ciornei@nxp.com>
	Acked-by: Grant Likely <grant.likely@arm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 425775ed31a6fac8b66ab077f7936fafad895ef6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy_device.c
#	include/linux/phy.h
diff --cc drivers/net/phy/phy_device.c
index ed7226c4a52f,786f464216dd..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -2855,6 -2877,90 +2856,93 @@@ static bool phy_drv_supports_irq(struc
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * fwnode_mdio_find_device - Given a fwnode, find the mdio_device
+  * @fwnode: pointer to the mdio_device's fwnode
+  *
+  * If successful, returns a pointer to the mdio_device with the embedded
+  * struct device refcount incremented by one, or NULL on failure.
+  * The caller should call put_device() on the mdio_device after its use.
+  */
+ struct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode)
+ {
+ 	struct device *d;
+ 
+ 	if (!fwnode)
+ 		return NULL;
+ 
+ 	d = bus_find_device_by_fwnode(&mdio_bus_type, fwnode);
+ 	if (!d)
+ 		return NULL;
+ 
+ 	return to_mdio_device(d);
+ }
+ EXPORT_SYMBOL(fwnode_mdio_find_device);
+ 
+ /**
+  * fwnode_phy_find_device - For provided phy_fwnode, find phy_device.
+  *
+  * @phy_fwnode: Pointer to the phy's fwnode.
+  *
+  * If successful, returns a pointer to the phy_device with the embedded
+  * struct device refcount incremented by one, or NULL on failure.
+  */
+ struct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode)
+ {
+ 	struct mdio_device *mdiodev;
+ 
+ 	mdiodev = fwnode_mdio_find_device(phy_fwnode);
+ 	if (!mdiodev)
+ 		return NULL;
+ 
+ 	if (mdiodev->flags & MDIO_DEVICE_FLAG_PHY)
+ 		return to_phy_device(&mdiodev->dev);
+ 
+ 	put_device(&mdiodev->dev);
+ 
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(fwnode_phy_find_device);
+ 
+ /**
+  * device_phy_find_device - For the given device, get the phy_device
+  * @dev: Pointer to the given device
+  *
+  * Refer return conditions of fwnode_phy_find_device().
+  */
+ struct phy_device *device_phy_find_device(struct device *dev)
+ {
+ 	return fwnode_phy_find_device(dev_fwnode(dev));
+ }
+ EXPORT_SYMBOL_GPL(device_phy_find_device);
+ 
+ /**
+  * fwnode_get_phy_node - Get the phy_node using the named reference.
+  * @fwnode: Pointer to fwnode from which phy_node has to be obtained.
+  *
+  * Refer return conditions of fwnode_find_reference().
+  * For ACPI, only "phy-handle" is supported. Legacy DT properties "phy"
+  * and "phy-device" are not supported in ACPI. DT supports all the three
+  * named references to the phy node.
+  */
+ struct fwnode_handle *fwnode_get_phy_node(struct fwnode_handle *fwnode)
+ {
+ 	struct fwnode_handle *phy_node;
+ 
+ 	/* Only phy-handle is used for ACPI */
+ 	phy_node = fwnode_find_reference(fwnode, "phy-handle", 0);
+ 	if (is_acpi_node(fwnode) || !IS_ERR(phy_node))
+ 		return phy_node;
+ 	phy_node = fwnode_find_reference(fwnode, "phy", 0);
+ 	if (IS_ERR(phy_node))
+ 		phy_node = fwnode_find_reference(fwnode, "phy-device", 0);
+ 	return phy_node;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_get_phy_node);
+ 
+ /**
++>>>>>>> 425775ed31a6 (net: phy: Introduce phy related fwnode functions)
   * phy_probe - probe and init a PHY device
   * @dev: device to probe and init
   *
diff --cc include/linux/phy.h
index 812a0b236a34,f9b5fb099fa6..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -1322,11 -1377,38 +1322,44 @@@ struct phy_device *phy_device_create(st
  				     bool is_c45,
  				     struct phy_c45_device_ids *c45_ids);
  #if IS_ENABLED(CONFIG_PHYLIB)
++<<<<<<< HEAD
++=======
+ struct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode);
+ struct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode);
+ struct phy_device *device_phy_find_device(struct device *dev);
+ struct fwnode_handle *fwnode_get_phy_node(struct fwnode_handle *fwnode);
++>>>>>>> 425775ed31a6 (net: phy: Introduce phy related fwnode functions)
  struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
  int phy_device_register(struct phy_device *phy);
  void phy_device_free(struct phy_device *phydev);
  #else
  static inline
++<<<<<<< HEAD
++=======
+ struct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode)
+ {
+ 	return 0;
+ }
+ 
+ static inline
+ struct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode)
+ {
+ 	return NULL;
+ }
+ 
+ static inline struct phy_device *device_phy_find_device(struct device *dev)
+ {
+ 	return NULL;
+ }
+ 
+ static inline
+ struct fwnode_handle *fwnode_get_phy_node(struct fwnode_handle *fwnode)
+ {
+ 	return NULL;
+ }
+ 
+ static inline
++>>>>>>> 425775ed31a6 (net: phy: Introduce phy related fwnode functions)
  struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)
  {
  	return NULL;
* Unmerged path drivers/net/phy/phy_device.c
* Unmerged path include/linux/phy.h
