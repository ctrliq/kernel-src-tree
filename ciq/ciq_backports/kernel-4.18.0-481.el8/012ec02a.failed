netdevsim: convert driver to use unlocked devlink API during init/fini

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Jiri Pirko <jiri@nvidia.com>
commit 012ec02ae4410207f796a9b280a60b80b6cc790a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/012ec02a.failed

Prepare for devlink reload being called with devlink->lock held and
convert the netdevsim driver to use unlocked devlink API during init and
fini flows. Take devl_lock() in reload_down() and reload_up() ops in the
meantime before reload cmd is converted to take the lock itself.

	Signed-off-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 012ec02ae4410207f796a9b280a60b80b6cc790a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/dev.c
#	drivers/net/netdevsim/fib.c
diff --cc drivers/net/netdevsim/dev.c
index 37f2b650e9d9,5802e80e8fe1..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -487,6 -487,12 +487,15 @@@ static int nsim_dev_resources_register(
  		return err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Resources for nexthops */
+ 	err = devl_resource_register(devlink, "nexthops", (u64)-1,
+ 				     NSIM_RESOURCE_NEXTHOPS,
+ 				     DEVLINK_RESOURCE_ID_PARENT_TOP,
+ 				     &params);
+ 
++>>>>>>> 012ec02ae441 (netdevsim: convert driver to use unlocked devlink API during init/fini)
  out:
  	return err;
  }
@@@ -1636,9 -1647,9 +1638,8 @@@ static void nsim_dev_reload_destroy(str
  		if (nsim_esw_mode_is_switchdev(nsim_dev))
  			nsim_esw_legacy_enable(nsim_dev, NULL);
  	}
- 	devl_unlock(devlink);
  
  	nsim_dev_port_del_all(nsim_dev);
 -	nsim_dev_hwstats_exit(nsim_dev);
  	nsim_dev_psample_exit(nsim_dev);
  	nsim_dev_health_exit(nsim_dev);
  	nsim_fib_destroy(devlink, nsim_dev->fib_data);
diff --cc drivers/net/netdevsim/fib.c
index 15ad41fb5b87,94e7512bef94..000000000000
--- a/drivers/net/netdevsim/fib.c
+++ b/drivers/net/netdevsim/fib.c
@@@ -914,30 -1559,44 +914,53 @@@ struct nsim_fib_data *nsim_fib_create(s
  				    nsim_fib_dump_inconsistent, extack);
  	if (err) {
  		pr_err("Failed to register fib notifier\n");
 -		goto err_nexthop_nb_unregister;
 -	}
 -
 +		goto err_rhashtable_destroy;
 +	}
 +
++<<<<<<< HEAD
 +	devlink_resource_occ_get_register(devlink,
 +					  NSIM_RESOURCE_IPV4_FIB,
 +					  nsim_fib_ipv4_resource_occ_get,
 +					  data);
 +	devlink_resource_occ_get_register(devlink,
 +					  NSIM_RESOURCE_IPV4_FIB_RULES,
 +					  nsim_fib_ipv4_rules_res_occ_get,
 +					  data);
 +	devlink_resource_occ_get_register(devlink,
 +					  NSIM_RESOURCE_IPV6_FIB,
 +					  nsim_fib_ipv6_resource_occ_get,
 +					  data);
 +	devlink_resource_occ_get_register(devlink,
 +					  NSIM_RESOURCE_IPV6_FIB_RULES,
 +					  nsim_fib_ipv6_rules_res_occ_get,
 +					  data);
++=======
+ 	devl_resource_occ_get_register(devlink,
+ 				       NSIM_RESOURCE_IPV4_FIB,
+ 				       nsim_fib_ipv4_resource_occ_get,
+ 				       data);
+ 	devl_resource_occ_get_register(devlink,
+ 				       NSIM_RESOURCE_IPV4_FIB_RULES,
+ 				       nsim_fib_ipv4_rules_res_occ_get,
+ 				       data);
+ 	devl_resource_occ_get_register(devlink,
+ 				       NSIM_RESOURCE_IPV6_FIB,
+ 				       nsim_fib_ipv6_resource_occ_get,
+ 				       data);
+ 	devl_resource_occ_get_register(devlink,
+ 				       NSIM_RESOURCE_IPV6_FIB_RULES,
+ 				       nsim_fib_ipv6_rules_res_occ_get,
+ 				       data);
+ 	devl_resource_occ_get_register(devlink,
+ 				       NSIM_RESOURCE_NEXTHOPS,
+ 				       nsim_fib_nexthops_res_occ_get,
+ 				       data);
++>>>>>>> 012ec02ae441 (netdevsim: convert driver to use unlocked devlink API during init/fini)
  	return data;
  
 -err_nexthop_nb_unregister:
 -	unregister_nexthop_notifier(devlink_net(devlink), &data->nexthop_nb);
 -err_rhashtable_fib_destroy:
 -	flush_work(&data->fib_event_work);
 +err_rhashtable_destroy:
  	rhashtable_free_and_destroy(&data->fib_rt_ht, nsim_fib_rt_free,
  				    data);
 -err_rhashtable_nexthop_destroy:
 -	rhashtable_free_and_destroy(&data->nexthop_ht, nsim_nexthop_free,
 -				    data);
 -	mutex_destroy(&data->fib_lock);
 -err_debugfs_exit:
 -	mutex_destroy(&data->nh_lock);
 -	nsim_fib_debugfs_exit(data);
  err_data_free:
  	kfree(data);
  	return ERR_PTR(err);
@@@ -945,17 -1604,27 +968,30 @@@
  
  void nsim_fib_destroy(struct devlink *devlink, struct nsim_fib_data *data)
  {
++<<<<<<< HEAD
 +	devlink_resource_occ_get_unregister(devlink,
 +					    NSIM_RESOURCE_IPV6_FIB_RULES);
 +	devlink_resource_occ_get_unregister(devlink,
 +					    NSIM_RESOURCE_IPV6_FIB);
 +	devlink_resource_occ_get_unregister(devlink,
 +					    NSIM_RESOURCE_IPV4_FIB_RULES);
 +	devlink_resource_occ_get_unregister(devlink,
 +					    NSIM_RESOURCE_IPV4_FIB);
++=======
+ 	devl_resource_occ_get_unregister(devlink,
+ 					 NSIM_RESOURCE_NEXTHOPS);
+ 	devl_resource_occ_get_unregister(devlink,
+ 					 NSIM_RESOURCE_IPV6_FIB_RULES);
+ 	devl_resource_occ_get_unregister(devlink,
+ 					 NSIM_RESOURCE_IPV6_FIB);
+ 	devl_resource_occ_get_unregister(devlink,
+ 					 NSIM_RESOURCE_IPV4_FIB_RULES);
+ 	devl_resource_occ_get_unregister(devlink,
+ 					 NSIM_RESOURCE_IPV4_FIB);
++>>>>>>> 012ec02ae441 (netdevsim: convert driver to use unlocked devlink API during init/fini)
  	unregister_fib_notifier(devlink_net(devlink), &data->fib_nb);
 -	unregister_nexthop_notifier(devlink_net(devlink), &data->nexthop_nb);
 -	flush_work(&data->fib_event_work);
  	rhashtable_free_and_destroy(&data->fib_rt_ht, nsim_fib_rt_free,
  				    data);
 -	rhashtable_free_and_destroy(&data->nexthop_ht, nsim_nexthop_free,
 -				    data);
 -	WARN_ON_ONCE(!list_empty(&data->fib_event_queue));
  	WARN_ON_ONCE(!list_empty(&data->fib_rt_list));
 -	mutex_destroy(&data->fib_lock);
 -	mutex_destroy(&data->nh_lock);
 -	nsim_fib_debugfs_exit(data);
  	kfree(data);
  }
diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index e0828422492c..05323bbd4507 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -72,16 +72,7 @@ new_port_store(struct device *dev, struct device_attribute *attr,
 	if (ret)
 		return ret;
 
-	if (!mutex_trylock(&nsim_bus_dev->nsim_bus_reload_lock))
-		return -EBUSY;
-
-	if (nsim_bus_dev->in_reload) {
-		mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
-		return -EBUSY;
-	}
-
 	ret = nsim_drv_port_add(nsim_bus_dev, NSIM_DEV_PORT_TYPE_PF, port_index);
-	mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
 	return ret ? ret : count;
 }
 
@@ -102,16 +93,7 @@ del_port_store(struct device *dev, struct device_attribute *attr,
 	if (ret)
 		return ret;
 
-	if (!mutex_trylock(&nsim_bus_dev->nsim_bus_reload_lock))
-		return -EBUSY;
-
-	if (nsim_bus_dev->in_reload) {
-		mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
-		return -EBUSY;
-	}
-
 	ret = nsim_drv_port_del(nsim_bus_dev, NSIM_DEV_PORT_TYPE_PF, port_index);
-	mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
 	return ret ? ret : count;
 }
 
@@ -299,7 +281,6 @@ nsim_bus_dev_new(unsigned int id, unsigned int port_count, unsigned int num_queu
 	nsim_bus_dev->num_queues = num_queues;
 	nsim_bus_dev->initial_net = current->nsproxy->net_ns;
 	nsim_bus_dev->max_vfs = NSIM_BUS_DEV_MAX_VFS;
-	mutex_init(&nsim_bus_dev->nsim_bus_reload_lock);
 	/* Disallow using nsim_bus_dev */
 	smp_store_release(&nsim_bus_dev->init, false);
 
* Unmerged path drivers/net/netdevsim/dev.c
* Unmerged path drivers/net/netdevsim/fib.c
diff --git a/drivers/net/netdevsim/netdevsim.h b/drivers/net/netdevsim/netdevsim.h
index 432fde77dd7b..9d56db0d42e0 100644
--- a/drivers/net/netdevsim/netdevsim.h
+++ b/drivers/net/netdevsim/netdevsim.h
@@ -352,9 +352,6 @@ struct nsim_bus_dev {
 				  */
 	unsigned int max_vfs;
 	unsigned int num_vfs;
-	/* Lock for devlink->reload_enabled in netdevsim module */
-	struct mutex nsim_bus_reload_lock;
-	bool in_reload;
 	bool init;
 };
 
diff --git a/include/net/devlink.h b/include/net/devlink.h
index f7e21a59492e..d02cf77057a9 100644
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@ -1481,6 +1481,7 @@ struct device *devlink_to_dev(const struct devlink *devlink);
 
 /* Devlink instance explicit locking */
 void devl_lock(struct devlink *devlink);
+int devl_trylock(struct devlink *devlink);
 void devl_unlock(struct devlink *devlink);
 void devl_assert_locked(struct devlink *devlink);
 bool devl_lock_is_held(struct devlink *devlink);
diff --git a/net/core/devlink.c b/net/core/devlink.c
index 571e4c3d21fd..2588f4d99763 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -250,6 +250,12 @@ void devl_lock(struct devlink *devlink)
 }
 EXPORT_SYMBOL_GPL(devl_lock);
 
+int devl_trylock(struct devlink *devlink)
+{
+	return mutex_trylock(&devlink->lock);
+}
+EXPORT_SYMBOL_GPL(devl_trylock);
+
 void devl_unlock(struct devlink *devlink)
 {
 	mutex_unlock(&devlink->lock);
