xfs: add selinux labels to whiteout inodes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Eric Sandeen <sandeen@redhat.com>
commit 70b589a37e1aba892c1e5d41957b0042f9eb031b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/70b589a3.failed

We got a report that "renameat2() with flags=RENAME_WHITEOUT doesn't
apply an SELinux label on xfs" as it does on other filesystems
(for example, ext4 and tmpfs.)  While I'm not quite sure how labels
may interact w/ whiteout files, leaving them as unlabeled seems
inconsistent at best. Now that xfs_init_security is not static,
rename it to xfs_inode_init_security per dchinner's suggestion.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 70b589a37e1aba892c1e5d41957b0042f9eb031b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index af9a6531c6af,296e253bcfcd..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -2988,13 -3031,17 +2988,19 @@@ out_trans_abort
   */
  static int
  xfs_rename_alloc_whiteout(
++<<<<<<< HEAD
++=======
+ 	struct user_namespace	*mnt_userns,
+ 	struct xfs_name		*src_name,
++>>>>>>> 70b589a37e1a (xfs: add selinux labels to whiteout inodes)
  	struct xfs_inode	*dp,
  	struct xfs_inode	**wip)
  {
  	struct xfs_inode	*tmpfile;
+ 	struct qstr		name;
  	int			error;
  
 -	error = xfs_create_tmpfile(mnt_userns, dp, S_IFCHR | WHITEOUT_MODE,
 -				   &tmpfile);
 +	error = xfs_create_tmpfile(dp, S_IFCHR | WHITEOUT_MODE, &tmpfile);
  	if (error)
  		return error;
  
@@@ -3046,8 -3104,8 +3061,13 @@@ xfs_rename
  	 * appropriately.
  	 */
  	if (flags & RENAME_WHITEOUT) {
++<<<<<<< HEAD
 +		ASSERT(!(flags & (RENAME_NOREPLACE | RENAME_EXCHANGE)));
 +		error = xfs_rename_alloc_whiteout(target_dp, &wip);
++=======
+ 		error = xfs_rename_alloc_whiteout(mnt_userns, src_name,
+ 						  target_dp, &wip);
++>>>>>>> 70b589a37e1a (xfs: add selinux labels to whiteout inodes)
  		if (error)
  			return error;
  
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 17be43a6a4a5..195af6029df5 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -70,9 +70,8 @@ xfs_initxattrs(
  * these attrs can be journalled at inode creation time (along with the
  * inode, of course, such that log replay can't cause these to be lost).
  */
-
-STATIC int
-xfs_init_security(
+int
+xfs_inode_init_security(
 	struct inode	*inode,
 	struct inode	*dir,
 	const struct qstr *qstr)
@@ -117,7 +116,7 @@ xfs_cleanup_inode(
 
 	/* Oh, the horror.
 	 * If we can't add the ACL or we fail in
-	 * xfs_init_security we must back out.
+	 * xfs_inode_init_security we must back out.
 	 * ENOSPC can hit here, among other things.
 	 */
 	xfs_dentry_to_name(&teardown, dentry);
@@ -202,7 +201,7 @@ xfs_generic_create(
 
 	inode = VFS_I(ip);
 
-	error = xfs_init_security(inode, dir, &dentry->d_name);
+	error = xfs_inode_init_security(inode, dir, &dentry->d_name);
 	if (unlikely(error))
 		goto out_cleanup_inode;
 
@@ -415,7 +414,7 @@ xfs_vn_symlink(
 
 	inode = VFS_I(cip);
 
-	error = xfs_init_security(inode, dir, &dentry->d_name);
+	error = xfs_inode_init_security(inode, dir, &dentry->d_name);
 	if (unlikely(error))
 		goto out_cleanup_inode;
 
diff --git a/fs/xfs/xfs_iops.h b/fs/xfs/xfs_iops.h
index 99ca745c1071..ecbd7222af57 100644
--- a/fs/xfs/xfs_iops.h
+++ b/fs/xfs/xfs_iops.h
@@ -16,4 +16,7 @@ extern ssize_t xfs_vn_listxattr(struct dentry *, char *data, size_t size);
 extern void xfs_setattr_time(struct xfs_inode *ip, struct iattr *iattr);
 extern int xfs_vn_setattr_size(struct dentry *dentry, struct iattr *vap);
 
+int xfs_inode_init_security(struct inode *inode, struct inode *dir,
+		const struct qstr *qstr);
+
 #endif /* __XFS_IOPS_H__ */
