net: stmmac: convert to phylink_generic_validate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
commit 04a0683f7db446e23cba69ae97706ae63ee5f74e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/04a0683f.failed

Convert stmmac to use phylink_generic_validate() now that we have the
MAC capabilities and supported interfaces filled in, and we have the
PCS validation handled via the PCS operations.

	Tested-by: Wong Vee Khee <vee.khee.wong@linux.intel.com> # Intel EHL            Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04a0683f7db446e23cba69ae97706ae63ee5f74e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 28392c7b9479,0fd96a98f489..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -902,111 -936,6 +902,114 @@@ static void stmmac_mac_flow_ctrl(struc
  			priv->pause, tx_cnt);
  }
  
++<<<<<<< HEAD
 +static void stmmac_validate(struct phylink_config *config,
 +			    unsigned long *supported,
 +			    struct phylink_link_state *state)
 +{
 +	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 +	__ETHTOOL_DECLARE_LINK_MODE_MASK(mac_supported) = { 0, };
 +	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
 +	int tx_cnt = priv->plat->tx_queues_to_use;
 +	int max_speed = priv->plat->max_speed;
 +
 +	phylink_set(mac_supported, 10baseT_Half);
 +	phylink_set(mac_supported, 10baseT_Full);
 +	phylink_set(mac_supported, 100baseT_Half);
 +	phylink_set(mac_supported, 100baseT_Full);
 +	phylink_set(mac_supported, 1000baseT_Half);
 +	phylink_set(mac_supported, 1000baseT_Full);
 +	phylink_set(mac_supported, 1000baseKX_Full);
 +
 +	phylink_set(mac_supported, Autoneg);
 +	phylink_set(mac_supported, Pause);
 +	phylink_set(mac_supported, Asym_Pause);
 +	phylink_set_port_modes(mac_supported);
 +
 +	/* Cut down 1G if asked to */
 +	if ((max_speed > 0) && (max_speed < 1000)) {
 +		phylink_set(mask, 1000baseT_Full);
 +		phylink_set(mask, 1000baseX_Full);
 +	} else if (priv->plat->has_xgmac) {
 +		if (!max_speed || (max_speed >= 2500)) {
 +			phylink_set(mac_supported, 2500baseT_Full);
 +			phylink_set(mac_supported, 2500baseX_Full);
 +		}
 +		if (!max_speed || (max_speed >= 5000)) {
 +			phylink_set(mac_supported, 5000baseT_Full);
 +		}
 +		if (!max_speed || (max_speed >= 10000)) {
 +			phylink_set(mac_supported, 10000baseSR_Full);
 +			phylink_set(mac_supported, 10000baseLR_Full);
 +			phylink_set(mac_supported, 10000baseER_Full);
 +			phylink_set(mac_supported, 10000baseLRM_Full);
 +			phylink_set(mac_supported, 10000baseT_Full);
 +			phylink_set(mac_supported, 10000baseKX4_Full);
 +			phylink_set(mac_supported, 10000baseKR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 25000)) {
 +			phylink_set(mac_supported, 25000baseCR_Full);
 +			phylink_set(mac_supported, 25000baseKR_Full);
 +			phylink_set(mac_supported, 25000baseSR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 40000)) {
 +			phylink_set(mac_supported, 40000baseKR4_Full);
 +			phylink_set(mac_supported, 40000baseCR4_Full);
 +			phylink_set(mac_supported, 40000baseSR4_Full);
 +			phylink_set(mac_supported, 40000baseLR4_Full);
 +		}
 +		if (!max_speed || (max_speed >= 50000)) {
 +			phylink_set(mac_supported, 50000baseCR2_Full);
 +			phylink_set(mac_supported, 50000baseKR2_Full);
 +			phylink_set(mac_supported, 50000baseSR2_Full);
 +			phylink_set(mac_supported, 50000baseKR_Full);
 +			phylink_set(mac_supported, 50000baseSR_Full);
 +			phylink_set(mac_supported, 50000baseCR_Full);
 +			phylink_set(mac_supported, 50000baseLR_ER_FR_Full);
 +			phylink_set(mac_supported, 50000baseDR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 100000)) {
 +			phylink_set(mac_supported, 100000baseKR4_Full);
 +			phylink_set(mac_supported, 100000baseSR4_Full);
 +			phylink_set(mac_supported, 100000baseCR4_Full);
 +			phylink_set(mac_supported, 100000baseLR4_ER4_Full);
 +			phylink_set(mac_supported, 100000baseKR2_Full);
 +			phylink_set(mac_supported, 100000baseSR2_Full);
 +			phylink_set(mac_supported, 100000baseCR2_Full);
 +			phylink_set(mac_supported, 100000baseLR2_ER2_FR2_Full);
 +			phylink_set(mac_supported, 100000baseDR2_Full);
 +		}
 +	}
 +
 +	/* Half-Duplex can only work with single queue */
 +	if (tx_cnt > 1) {
 +		phylink_set(mask, 10baseT_Half);
 +		phylink_set(mask, 100baseT_Half);
 +		phylink_set(mask, 1000baseT_Half);
 +	}
 +
 +	linkmode_and(supported, supported, mac_supported);
 +	linkmode_andnot(supported, supported, mask);
 +
 +	linkmode_and(state->advertising, state->advertising, mac_supported);
 +	linkmode_andnot(state->advertising, state->advertising, mask);
 +
 +	/* If PCS is supported, check which modes it supports. */
 +	if (priv->hw->xpcs)
 +		xpcs_validate(priv->hw->xpcs_args, supported, state);
 +}
 +
 +static void stmmac_mac_pcs_get_state(struct phylink_config *config,
 +				     struct phylink_link_state *state)
 +{
 +	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 +
 +	state->link = 0;
 +	stmmac_xpcs_get_state(priv, priv->hw->xpcs_args, state);
 +}
 +
++=======
++>>>>>>> 04a0683f7db4 (net: stmmac: convert to phylink_generic_validate())
  static void stmmac_mac_config(struct phylink_config *config, unsigned int mode,
  			      const struct phylink_link_state *state)
  {
@@@ -1152,10 -1072,8 +1155,14 @@@ static void stmmac_mac_link_up(struct p
  }
  
  static const struct phylink_mac_ops stmmac_phylink_mac_ops = {
++<<<<<<< HEAD
 +	.validate = stmmac_validate,
 +	.mac_pcs_get_state = stmmac_mac_pcs_get_state,
++=======
+ 	.validate = phylink_generic_validate,
++>>>>>>> 04a0683f7db4 (net: stmmac: convert to phylink_generic_validate())
  	.mac_config = stmmac_mac_config,
 +	.mac_an_restart = stmmac_mac_an_restart,
  	.mac_link_down = stmmac_mac_link_down,
  	.mac_link_up = stmmac_mac_link_up,
  };
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
