net: stmmac: work around sporadic tx issue on link-up

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit a3a57bf07de23fe1ff779e0fdf710aa581c3ff73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/a3a57bf0.failed

This is a follow-up to the discussion in [0]. It seems to me that
at least the IP version used on Amlogic SoC's sometimes has a problem
if register MAC_CTRL_REG is written whilst the chip is still processing
a previous write. But that's just a guess.
Adding a delay between two writes to this register helps, but we can
also simply omit the offending second write. This patch uses the second
approach and is based on a suggestion from Qi Duan.
Benefit of this approach is that we can save few register writes, also
on not affected chip versions.

[0] https://www.spinics.net/lists/netdev/msg831526.html

Fixes: bfab27a146ed ("stmmac: add the experimental PCI support")
	Suggested-by: Qi Duan <qi.duan@amlogic.com>
	Suggested-by: Jerome Brunet <jbrunet@baylibre.com>
	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
Link: https://lore.kernel.org/r/e99857ce-bd90-5093-ca8c-8cd480b5a0a2@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit a3a57bf07de23fe1ff779e0fdf710aa581c3ff73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 98e95c49f625,592d29abcb1c..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -1057,12 -986,10 +1057,17 @@@ static void stmmac_mac_link_up(struct p
  			       bool tx_pause, bool rx_pause)
  {
  	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
- 	u32 ctrl;
+ 	u32 old_ctrl, ctrl;
  
++<<<<<<< HEAD
 +	stmmac_xpcs_link_up(priv, priv->hw->xpcs_args, speed, interface);
 +
 +	ctrl = readl(priv->ioaddr + MAC_CTRL_REG);
 +	ctrl &= ~priv->hw->link.speed_mask;
++=======
+ 	old_ctrl = readl(priv->ioaddr + MAC_CTRL_REG);
+ 	ctrl = old_ctrl & ~priv->hw->link.speed_mask;
++>>>>>>> a3a57bf07de2 (net: stmmac: work around sporadic tx issue on link-up)
  
  	if (interface == PHY_INTERFACE_MODE_USXGMII) {
  		switch (speed) {
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c b/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
index 9e38659769d1..647e6a7a3e38 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
@@ -268,14 +268,18 @@ EXPORT_SYMBOL_GPL(stmmac_set_mac_addr);
 /* Enable disable MAC RX/TX */
 void stmmac_set_mac(void __iomem *ioaddr, bool enable)
 {
-	u32 value = readl(ioaddr + MAC_CTRL_REG);
+	u32 old_val, value;
+
+	old_val = readl(ioaddr + MAC_CTRL_REG);
+	value = old_val;
 
 	if (enable)
 		value |= MAC_ENABLE_RX | MAC_ENABLE_TX;
 	else
 		value &= ~(MAC_ENABLE_TX | MAC_ENABLE_RX);
 
-	writel(value, ioaddr + MAC_CTRL_REG);
+	if (value != old_val)
+		writel(value, ioaddr + MAC_CTRL_REG);
 }
 
 void stmmac_get_mac_addr(void __iomem *ioaddr, unsigned char *addr,
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
