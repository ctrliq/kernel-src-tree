regmap: Make regmap_noinc_read() return -ENOTSUPP if map->read isn't set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Javier Martinez Canillas <javierm@redhat.com>
commit f6e5c3850d1174bf3ca53457d64e6665f48c9041
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/f6e5c385.failed

Before adding support to define bulk read/write callbacks in regmap_config
by the commit d77e74561368 ("regmap: Add bulk read/write callbacks into
regmap_config"), the regmap_noinc_read() function returned an errno early
a map->bus->read callback wasn't set.

But that commit dropped the check and now a call to _regmap_raw_read() is
attempted even when bulk read operations are not supported. That function
checks for map->read anyways but there's no point to continue if the read
can't succeed.

Also is a fragile assumption to make so is better to make it fail earlier.

Fixes: d77e74561368 ("regmap: Add bulk read/write callbacks into regmap_config")
	Signed-off-by: Javier Martinez Canillas <javierm@redhat.com>
Link: https://lore.kernel.org/r/20220616073435.1988219-3-javierm@redhat.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit f6e5c3850d1174bf3ca53457d64e6665f48c9041)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regmap.c
diff --cc drivers/base/regmap/regmap.c
index a5fdb7dad64b,f37f80a52115..000000000000
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@@ -2626,7 -2878,69 +2626,73 @@@ int regmap_raw_read(struct regmap *map
  EXPORT_SYMBOL_GPL(regmap_raw_read);
  
  /**
++<<<<<<< HEAD
 + * regmap_field_read() - Read a value to a single register field
++=======
+  * regmap_noinc_read(): Read data from a register without incrementing the
+  *			register number
+  *
+  * @map: Register map to read from
+  * @reg: Register to read from
+  * @val: Pointer to data buffer
+  * @val_len: Length of output buffer in bytes.
+  *
+  * The regmap API usually assumes that bulk read operations will read a
+  * range of registers. Some devices have certain registers for which a read
+  * operation read will read from an internal FIFO.
+  *
+  * The target register must be volatile but registers after it can be
+  * completely unrelated cacheable registers.
+  *
+  * This will attempt multiple reads as required to read val_len bytes.
+  *
+  * A value of zero will be returned on success, a negative errno will be
+  * returned in error cases.
+  */
+ int regmap_noinc_read(struct regmap *map, unsigned int reg,
+ 		      void *val, size_t val_len)
+ {
+ 	size_t read_len;
+ 	int ret;
+ 
+ 	if (!map->read)
+ 		return -ENOTSUPP;
+ 
+ 	if (val_len % map->format.val_bytes)
+ 		return -EINVAL;
+ 	if (!IS_ALIGNED(reg, map->reg_stride))
+ 		return -EINVAL;
+ 	if (val_len == 0)
+ 		return -EINVAL;
+ 
+ 	map->lock(map->lock_arg);
+ 
+ 	if (!regmap_volatile(map, reg) || !regmap_readable_noinc(map, reg)) {
+ 		ret = -EINVAL;
+ 		goto out_unlock;
+ 	}
+ 
+ 	while (val_len) {
+ 		if (map->max_raw_read && map->max_raw_read < val_len)
+ 			read_len = map->max_raw_read;
+ 		else
+ 			read_len = val_len;
+ 		ret = _regmap_raw_read(map, reg, val, read_len, true);
+ 		if (ret)
+ 			goto out_unlock;
+ 		val = ((u8 *)val) + read_len;
+ 		val_len -= read_len;
+ 	}
+ 
+ out_unlock:
+ 	map->unlock(map->lock_arg);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(regmap_noinc_read);
+ 
+ /**
+  * regmap_field_read(): Read a value to a single register field
++>>>>>>> f6e5c3850d11 (regmap: Make regmap_noinc_read() return -ENOTSUPP if map->read isn't set)
   *
   * @field: Register field to read from
   * @val: Pointer to store read value
* Unmerged path drivers/base/regmap/regmap.c
