net: pcs: xpcs: add CL37 1000BASE-X AN support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Ong Boon Leong <boon.leong.ong@intel.com>
commit b47aec885bcd672ebca2108a8b7e9ce3e3982775
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/b47aec88.failed

For CL37 1000BASE-X AN, DW xPCS does not support C22 method but offers
C45 vendor-specific MII MMD for programming.

We also add the ability to disable Autoneg (through ethtool for certain
network switch that supports 1000BASE-X (1000Mbps and Full-Duplex) but
not Autoneg capability.

v4: Fixes to comment from Russell King. Thanks!
    https://patchwork.kernel.org/comment/24894239/
    Make xpcs_modify_changed() as private, change to use
    mdiodev_modify_changed() for cleaner code.

v3: Fixes to issues spotted by Russell King. Thanks!
    https://patchwork.kernel.org/comment/24890210/
    Use phylink_mii_c22_pcs_decode_state(), remove unnecessary
    interrupt clearing and skip speed & duplex setting if AN
    is enabled.

v2: Fixes to issues spotted by Russell King in v1. Thanks!
    https://patchwork.kernel.org/comment/24826650/
    Use phylink_mii_c22_pcs_encode_advertisement() and implement
    C45 MII ADV handling since IP only support C45 access.

	Tested-by: Emilio Riva <emilio.riva@ericsson.com>
	Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
	Reviewed-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b47aec885bcd672ebca2108a8b7e9ce3e3982775)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/pcs/pcs-xpcs.c
#	drivers/net/pcs/pcs-xpcs.h
#	include/linux/pcs/pcs-xpcs.h
diff --cc drivers/net/pcs/pcs-xpcs.c
index c10bb5d22b5b,a5d520e34ea3..000000000000
--- a/drivers/net/pcs/pcs-xpcs.c
+++ b/drivers/net/pcs/pcs-xpcs.c
@@@ -158,6 -77,23 +158,26 @@@ static const int xpcs_sgmii_features[] 
  	__ETHTOOL_LINK_MODE_MASK_NBITS,
  };
  
++<<<<<<< HEAD
++=======
+ static const int xpcs_1000basex_features[] = {
+ 	ETHTOOL_LINK_MODE_Pause_BIT,
+ 	ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 	ETHTOOL_LINK_MODE_Autoneg_BIT,
+ 	ETHTOOL_LINK_MODE_1000baseX_Full_BIT,
+ 	__ETHTOOL_LINK_MODE_MASK_NBITS,
+ };
+ 
+ static const int xpcs_2500basex_features[] = {
+ 	ETHTOOL_LINK_MODE_Pause_BIT,
+ 	ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 	ETHTOOL_LINK_MODE_Autoneg_BIT,
+ 	ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+ 	ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+ 	__ETHTOOL_LINK_MODE_MASK_NBITS,
+ };
+ 
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  static const phy_interface_t xpcs_usxgmii_interfaces[] = {
  	PHY_INTERFACE_MODE_USXGMII,
  };
@@@ -174,11 -110,22 +194,28 @@@ static const phy_interface_t xpcs_sgmii
  	PHY_INTERFACE_MODE_SGMII,
  };
  
++<<<<<<< HEAD
++=======
+ static const phy_interface_t xpcs_1000basex_interfaces[] = {
+ 	PHY_INTERFACE_MODE_1000BASEX,
+ };
+ 
+ static const phy_interface_t xpcs_2500basex_interfaces[] = {
+ 	PHY_INTERFACE_MODE_2500BASEX,
+ 	PHY_INTERFACE_MODE_MAX,
+ };
+ 
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  enum {
  	DW_XPCS_USXGMII,
  	DW_XPCS_10GKR,
  	DW_XPCS_XLGMII,
  	DW_XPCS_SGMII,
++<<<<<<< HEAD
++=======
+ 	DW_XPCS_1000BASEX,
+ 	DW_XPCS_2500BASEX,
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  	DW_XPCS_INTERFACE_MAX,
  };
  
@@@ -254,7 -202,15 +291,19 @@@ static int xpcs_write(struct mdio_xpcs_
  	return mdiobus_c45_write(bus, addr, dev, reg, val);
  }
  
++<<<<<<< HEAD
 +static int xpcs_read_vendor(struct mdio_xpcs_args *xpcs, int dev, u32 reg)
++=======
+ static int xpcs_modify_changed(struct dw_xpcs *xpcs, int dev, u32 reg,
+ 			       u16 mask, u16 set)
+ {
+ 	u32 reg_addr = mdiobus_c45_addr(dev, reg);
+ 
+ 	return mdiodev_modify_changed(xpcs->mdiodev, reg_addr, mask, set);
+ }
+ 
+ static int xpcs_read_vendor(struct dw_xpcs *xpcs, int dev, u32 reg)
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  {
  	return xpcs_read(xpcs, dev, DW_VENDOR | reg);
  }
@@@ -301,6 -257,8 +350,11 @@@ static int xpcs_soft_reset(struct mdio_
  		dev = MDIO_MMD_PCS;
  		break;
  	case DW_AN_C37_SGMII:
++<<<<<<< HEAD
++=======
+ 	case DW_2500BASEX:
+ 	case DW_AN_C37_1000BASEX:
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  		dev = MDIO_MMD_VEND2;
  		break;
  	default:
@@@ -819,8 -794,92 +873,97 @@@ static int xpcs_config_aneg_c37_sgmii(s
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int xpcs_config(struct mdio_xpcs_args *xpcs,
 +		       const struct phylink_link_state *state)
++=======
+ static int xpcs_config_aneg_c37_1000basex(struct dw_xpcs *xpcs, unsigned int mode,
+ 					  const unsigned long *advertising)
+ {
+ 	phy_interface_t interface = PHY_INTERFACE_MODE_1000BASEX;
+ 	int ret, mdio_ctrl, adv;
+ 	bool changed = 0;
+ 
+ 	/* According to Chap 7.12, to set 1000BASE-X C37 AN, AN must
+ 	 * be disabled first:-
+ 	 * 1) VR_MII_MMD_CTRL Bit(12)[AN_ENABLE] = 0b
+ 	 * 2) VR_MII_AN_CTRL Bit(2:1)[PCS_MODE] = 00b (1000BASE-X C37)
+ 	 */
+ 	mdio_ctrl = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL);
+ 	if (mdio_ctrl < 0)
+ 		return mdio_ctrl;
+ 
+ 	if (mdio_ctrl & AN_CL37_EN) {
+ 		ret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL,
+ 				 mdio_ctrl & ~AN_CL37_EN);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	ret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_CTRL);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret &= ~DW_VR_MII_PCS_MODE_MASK;
+ 	ret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_CTRL, ret);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	/* Check for advertising changes and update the C45 MII ADV
+ 	 * register accordingly.
+ 	 */
+ 	adv = phylink_mii_c22_pcs_encode_advertisement(interface,
+ 						       advertising);
+ 	if (adv >= 0) {
+ 		ret = xpcs_modify_changed(xpcs, MDIO_MMD_VEND2,
+ 					  MII_ADVERTISE, 0xffff, adv);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		changed = ret;
+ 	}
+ 
+ 	/* Clear CL37 AN complete status */
+ 	ret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_INTR_STS, 0);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (phylink_autoneg_inband(mode) &&
+ 	    linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, advertising)) {
+ 		ret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL,
+ 				 mdio_ctrl | AN_CL37_EN);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	return changed;
+ }
+ 
+ static int xpcs_config_2500basex(struct dw_xpcs *xpcs)
+ {
+ 	int ret;
+ 
+ 	ret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_DIG_CTRL1);
+ 	if (ret < 0)
+ 		return ret;
+ 	ret |= DW_VR_MII_DIG_CTRL1_2G5_EN;
+ 	ret &= ~DW_VR_MII_DIG_CTRL1_MAC_AUTO_SW;
+ 	ret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_DIG_CTRL1, ret);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL);
+ 	if (ret < 0)
+ 		return ret;
+ 	ret &= ~AN_CL37_EN;
+ 	ret |= SGMII_SPEED_SS6;
+ 	ret &= ~SGMII_SPEED_SS13;
+ 	return xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL, ret);
+ }
+ 
+ int xpcs_do_config(struct dw_xpcs *xpcs, phy_interface_t interface,
+ 		   unsigned int mode, const unsigned long *advertising)
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  {
  	const struct xpcs_compat *compat;
  	int ret;
@@@ -838,7 -897,18 +981,22 @@@
  		}
  		break;
  	case DW_AN_C37_SGMII:
++<<<<<<< HEAD
 +		ret = xpcs_config_aneg_c37_sgmii(xpcs);
++=======
+ 		ret = xpcs_config_aneg_c37_sgmii(xpcs, mode);
+ 		if (ret)
+ 			return ret;
+ 		break;
+ 	case DW_AN_C37_1000BASEX:
+ 		ret = xpcs_config_aneg_c37_1000basex(xpcs, mode,
+ 						     advertising);
+ 		if (ret)
+ 			return ret;
+ 		break;
+ 	case DW_2500BASEX:
+ 		ret = xpcs_config_2500basex(xpcs);
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  		if (ret)
  			return ret;
  		break;
@@@ -924,9 -1011,33 +1082,37 @@@ static int xpcs_get_state_c37_sgmii(str
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int xpcs_get_state(struct mdio_xpcs_args *xpcs,
 +			  struct phylink_link_state *state)
++=======
+ static int xpcs_get_state_c37_1000basex(struct dw_xpcs *xpcs,
+ 					struct phylink_link_state *state)
+ {
+ 	int lpa, bmsr;
+ 
+ 	if (state->an_enabled) {
+ 		/* Reset link state */
+ 		state->link = false;
+ 
+ 		lpa = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_LPA);
+ 		if (lpa < 0 || lpa & LPA_RFAULT)
+ 			return lpa;
+ 
+ 		bmsr = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_BMSR);
+ 		if (bmsr < 0)
+ 			return bmsr;
+ 
+ 		phylink_mii_c22_pcs_decode_state(state, bmsr, lpa);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void xpcs_get_state(struct phylink_pcs *pcs,
+ 			   struct phylink_link_state *state)
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  {
 -	struct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);
  	const struct xpcs_compat *compat;
  	int ret;
  
@@@ -942,26 -1056,109 +1128,90 @@@
  		break;
  	case DW_AN_C37_SGMII:
  		ret = xpcs_get_state_c37_sgmii(xpcs, state);
 -		if (ret) {
 -			pr_err("xpcs_get_state_c37_sgmii returned %pe\n",
 -			       ERR_PTR(ret));
 -		}
 +		if (ret)
 +			return ret;
  		break;
+ 	case DW_AN_C37_1000BASEX:
+ 		ret = xpcs_get_state_c37_1000basex(xpcs, state);
+ 		if (ret) {
+ 			pr_err("xpcs_get_state_c37_1000basex returned %pe\n",
+ 			       ERR_PTR(ret));
+ 		}
+ 		break;
  	default:
 -		return;
 -	}
 -}
 -
 -static void xpcs_link_up_sgmii(struct dw_xpcs *xpcs, unsigned int mode,
 -			       int speed, int duplex)
 -{
 -	int val, ret;
 -
 -	if (phylink_autoneg_inband(mode))
 -		return;
 -
 -	switch (speed) {
 -	case SPEED_1000:
 -		val = BMCR_SPEED1000;
 -		break;
 -	case SPEED_100:
 -		val = BMCR_SPEED100;
 -		break;
 -	case SPEED_10:
 -		val = BMCR_SPEED10;
 -		break;
 -	default:
 -		return;
 +		return -1;
  	}
  
 -	if (duplex == DUPLEX_FULL)
 -		val |= BMCR_FULLDPLX;
 -
 -	ret = xpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, val);
 -	if (ret)
 -		pr_err("%s: xpcs_write returned %pe\n", __func__, ERR_PTR(ret));
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static int xpcs_link_up(struct mdio_xpcs_args *xpcs, int speed,
 +			phy_interface_t interface)
++=======
+ static void xpcs_link_up_1000basex(struct dw_xpcs *xpcs, unsigned int mode,
+ 				   int speed, int duplex)
+ {
+ 	int val, ret;
+ 
+ 	if (phylink_autoneg_inband(mode))
+ 		return;
+ 
+ 	switch (speed) {
+ 	case SPEED_1000:
+ 		val = BMCR_SPEED1000;
+ 		break;
+ 	case SPEED_100:
+ 	case SPEED_10:
+ 	default:
+ 		pr_err("%s: speed = %d\n", __func__, speed);
+ 		return;
+ 	}
+ 
+ 	if (duplex == DUPLEX_FULL)
+ 		val |= BMCR_FULLDPLX;
+ 	else
+ 		pr_err("%s: half duplex not supported\n", __func__);
+ 
+ 	ret = xpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, val);
+ 	if (ret)
+ 		pr_err("%s: xpcs_write returned %pe\n", __func__, ERR_PTR(ret));
+ }
+ 
+ void xpcs_link_up(struct phylink_pcs *pcs, unsigned int mode,
+ 		  phy_interface_t interface, int speed, int duplex)
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  {
 -	struct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);
 -
  	if (interface == PHY_INTERFACE_MODE_USXGMII)
  		return xpcs_config_usxgmii(xpcs, speed);
++<<<<<<< HEAD
 +
 +	return 0;
 +}
 +
 +static u32 xpcs_get_id(struct mdio_xpcs_args *xpcs)
++=======
+ 	if (interface == PHY_INTERFACE_MODE_SGMII)
+ 		return xpcs_link_up_sgmii(xpcs, mode, speed, duplex);
+ 	if (interface == PHY_INTERFACE_MODE_1000BASEX)
+ 		return xpcs_link_up_1000basex(xpcs, mode, speed, duplex);
+ }
+ EXPORT_SYMBOL_GPL(xpcs_link_up);
+ 
+ static void xpcs_an_restart(struct phylink_pcs *pcs)
+ {
+ 	struct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);
+ 	int ret;
+ 
+ 	ret = xpcs_read(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1);
+ 	if (ret >= 0) {
+ 		ret |= BMCR_ANRESTART;
+ 		xpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, ret);
+ 	}
+ }
+ 
+ static u32 xpcs_get_id(struct dw_xpcs *xpcs)
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  {
  	int ret;
  	u32 id;
@@@ -1026,6 -1223,45 +1276,48 @@@ static const struct xpcs_compat synopsy
  		.num_interfaces = ARRAY_SIZE(xpcs_sgmii_interfaces),
  		.an_mode = DW_AN_C37_SGMII,
  	},
++<<<<<<< HEAD
++=======
+ 	[DW_XPCS_1000BASEX] = {
+ 		.supported = xpcs_1000basex_features,
+ 		.interface = xpcs_1000basex_interfaces,
+ 		.num_interfaces = ARRAY_SIZE(xpcs_1000basex_interfaces),
+ 		.an_mode = DW_AN_C37_1000BASEX,
+ 	},
+ 	[DW_XPCS_2500BASEX] = {
+ 		.supported = xpcs_2500basex_features,
+ 		.interface = xpcs_2500basex_interfaces,
+ 		.num_interfaces = ARRAY_SIZE(xpcs_2500basex_features),
+ 		.an_mode = DW_2500BASEX,
+ 	},
+ };
+ 
+ static const struct xpcs_compat nxp_sja1105_xpcs_compat[DW_XPCS_INTERFACE_MAX] = {
+ 	[DW_XPCS_SGMII] = {
+ 		.supported = xpcs_sgmii_features,
+ 		.interface = xpcs_sgmii_interfaces,
+ 		.num_interfaces = ARRAY_SIZE(xpcs_sgmii_interfaces),
+ 		.an_mode = DW_AN_C37_SGMII,
+ 		.pma_config = nxp_sja1105_sgmii_pma_config,
+ 	},
+ };
+ 
+ static const struct xpcs_compat nxp_sja1110_xpcs_compat[DW_XPCS_INTERFACE_MAX] = {
+ 	[DW_XPCS_SGMII] = {
+ 		.supported = xpcs_sgmii_features,
+ 		.interface = xpcs_sgmii_interfaces,
+ 		.num_interfaces = ARRAY_SIZE(xpcs_sgmii_interfaces),
+ 		.an_mode = DW_AN_C37_SGMII,
+ 		.pma_config = nxp_sja1110_sgmii_pma_config,
+ 	},
+ 	[DW_XPCS_2500BASEX] = {
+ 		.supported = xpcs_2500basex_features,
+ 		.interface = xpcs_2500basex_interfaces,
+ 		.num_interfaces = ARRAY_SIZE(xpcs_2500basex_interfaces),
+ 		.an_mode = DW_2500BASEX,
+ 		.pma_config = nxp_sja1110_2500basex_pma_config,
+ 	},
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  };
  
  static const struct xpcs_id xpcs_id_list[] = {
@@@ -1036,10 -1272,26 +1328,23 @@@
  	},
  };
  
++<<<<<<< HEAD
 +struct mdio_xpcs_args *xpcs_create(struct mdio_device *mdiodev,
 +				   phy_interface_t interface)
++=======
+ static const struct phylink_pcs_ops xpcs_phylink_ops = {
+ 	.pcs_validate = xpcs_validate,
+ 	.pcs_config = xpcs_config,
+ 	.pcs_get_state = xpcs_get_state,
+ 	.pcs_an_restart = xpcs_an_restart,
+ 	.pcs_link_up = xpcs_link_up,
+ };
+ 
+ struct dw_xpcs *xpcs_create(struct mdio_device *mdiodev,
+ 			    phy_interface_t interface)
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  {
 -	struct dw_xpcs *xpcs;
 +	struct mdio_xpcs_args *xpcs;
  	u32 xpcs_id;
  	int i, ret;
  
diff --cc include/linux/pcs/pcs-xpcs.h
index 57a199393d63,d2da1e0b4a92..000000000000
--- a/include/linux/pcs/pcs-xpcs.h
+++ b/include/linux/pcs/pcs-xpcs.h
@@@ -13,6 -13,11 +13,11 @@@
  /* AN mode */
  #define DW_AN_C73			1
  #define DW_AN_C37_SGMII			2
++<<<<<<< HEAD
++=======
+ #define DW_2500BASEX			3
+ #define DW_AN_C37_1000BASEX		4
++>>>>>>> b47aec885bcd (net: pcs: xpcs: add CL37 1000BASE-X AN support)
  
  struct xpcs_id;
  
* Unmerged path drivers/net/pcs/pcs-xpcs.h
* Unmerged path drivers/net/pcs/pcs-xpcs.c
* Unmerged path drivers/net/pcs/pcs-xpcs.h
* Unmerged path include/linux/pcs/pcs-xpcs.h
