regmap: Wire up regmap_config provided bulk write in missed functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Javier Martinez Canillas <javierm@redhat.com>
commit 1db43c8ad90ce07311a3ef9af7ace758d79224f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/1db43c8a.failed

There are some functions that were missed by commit d77e74561368 ("regmap:
Add bulk read/write callbacks into regmap_config") when support to define
bulk read/write callbacks in regmap_config was introduced.

The regmap_bulk_write() and regmap_noinc_write() functions weren't changed
to use the added map->write instead of the map->bus->write handler.

Also, the regmap_can_raw_write() was not modified to take map->write into
account. So will only return true if a bus with a .write callback is set.

Fixes: d77e74561368 ("regmap: Add bulk read/write callbacks into regmap_config")
	Signed-off-by: Javier Martinez Canillas <javierm@redhat.com>
Link: https://lore.kernel.org/r/20220616073435.1988219-4-javierm@redhat.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 1db43c8ad90ce07311a3ef9af7ace758d79224f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regmap.c
diff --cc drivers/base/regmap/regmap.c
index a5fdb7dad64b,c3517ccc3159..000000000000
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@@ -1944,6 -2128,68 +1943,71 @@@ int regmap_raw_write(struct regmap *map
  EXPORT_SYMBOL_GPL(regmap_raw_write);
  
  /**
++<<<<<<< HEAD
++=======
+  * regmap_noinc_write(): Write data from a register without incrementing the
+  *			register number
+  *
+  * @map: Register map to write to
+  * @reg: Register to write to
+  * @val: Pointer to data buffer
+  * @val_len: Length of output buffer in bytes.
+  *
+  * The regmap API usually assumes that bulk bus write operations will write a
+  * range of registers. Some devices have certain registers for which a write
+  * operation can write to an internal FIFO.
+  *
+  * The target register must be volatile but registers after it can be
+  * completely unrelated cacheable registers.
+  *
+  * This will attempt multiple writes as required to write val_len bytes.
+  *
+  * A value of zero will be returned on success, a negative errno will be
+  * returned in error cases.
+  */
+ int regmap_noinc_write(struct regmap *map, unsigned int reg,
+ 		      const void *val, size_t val_len)
+ {
+ 	size_t write_len;
+ 	int ret;
+ 
+ 	if (!map->write)
+ 		return -ENOTSUPP;
+ 
+ 	if (val_len % map->format.val_bytes)
+ 		return -EINVAL;
+ 	if (!IS_ALIGNED(reg, map->reg_stride))
+ 		return -EINVAL;
+ 	if (val_len == 0)
+ 		return -EINVAL;
+ 
+ 	map->lock(map->lock_arg);
+ 
+ 	if (!regmap_volatile(map, reg) || !regmap_writeable_noinc(map, reg)) {
+ 		ret = -EINVAL;
+ 		goto out_unlock;
+ 	}
+ 
+ 	while (val_len) {
+ 		if (map->max_raw_write && map->max_raw_write < val_len)
+ 			write_len = map->max_raw_write;
+ 		else
+ 			write_len = val_len;
+ 		ret = _regmap_raw_write(map, reg, val, write_len, true);
+ 		if (ret)
+ 			goto out_unlock;
+ 		val = ((u8 *)val) + write_len;
+ 		val_len -= write_len;
+ 	}
+ 
+ out_unlock:
+ 	map->unlock(map->lock_arg);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(regmap_noinc_write);
+ 
+ /**
++>>>>>>> 1db43c8ad90c (regmap: Wire up regmap_config provided bulk write in missed functions)
   * regmap_field_update_bits_base() - Perform a read/modify/write cycle a
   *                                   register field.
   *
* Unmerged path drivers/base/regmap/regmap.c
