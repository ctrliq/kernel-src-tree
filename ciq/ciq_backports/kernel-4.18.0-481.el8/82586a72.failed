PM: runtime: Avoid device usage count underflows

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 82586a721595fde2c1bc0dac7deed2fe9d42c106
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/82586a72.failed

A PM-runtime device usage count underflow is potentially critical,
because it may cause a device to be suspended when it is expected to
be operational.  It is also a programming problem that would be good
to catch and warn about.

For this reason, (1) make rpm_check_suspend_allowed() return an error
when the device usage count is negative to prevent devices from being
suspended in that case, (2) introduce rpm_drop_usage_count() that will
detect device usage count underflows, warn about them and fix them up,
and (3) use it to drop the usage count in a few places instead of
atomic_dec_and_test().

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 82586a721595fde2c1bc0dac7deed2fe9d42c106)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/runtime.c
diff --cc drivers/base/power/runtime.c
index 038c3f9e4bfb,23bea81160e5..000000000000
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@@ -1025,8 -1077,13 +1045,16 @@@ int __pm_runtime_idle(struct device *de
  	int retval;
  
  	if (rpmflags & RPM_GET_PUT) {
++<<<<<<< HEAD
 +		if (!atomic_dec_and_test(&dev->power.usage_count))
++=======
+ 		retval = rpm_drop_usage_count(dev);
+ 		if (retval < 0) {
+ 			return retval;
+ 		} else if (retval > 0) {
+ 			trace_rpm_usage_rcuidle(dev, rpmflags);
++>>>>>>> 82586a721595 (PM: runtime: Avoid device usage count underflows)
  			return 0;
 -		}
  	}
  
  	might_sleep_if(!(rpmflags & RPM_ASYNC) && !dev->power.irq_safe);
@@@ -1057,8 -1115,13 +1086,16 @@@ int __pm_runtime_suspend(struct device 
  	int retval;
  
  	if (rpmflags & RPM_GET_PUT) {
++<<<<<<< HEAD
 +		if (!atomic_dec_and_test(&dev->power.usage_count))
++=======
+ 		retval = rpm_drop_usage_count(dev);
+ 		if (retval < 0) {
+ 			return retval;
+ 		} else if (retval > 0) {
+ 			trace_rpm_usage_rcuidle(dev, rpmflags);
++>>>>>>> 82586a721595 (PM: runtime: Avoid device usage count underflows)
  			return 0;
 -		}
  	}
  
  	might_sleep_if(!(rpmflags & RPM_ASYNC) && !dev->power.irq_safe);
@@@ -1488,8 -1561,11 +1527,14 @@@ void pm_runtime_allow(struct device *de
  		goto out;
  
  	dev->power.runtime_auto = true;
- 	if (atomic_dec_and_test(&dev->power.usage_count))
+ 	ret = rpm_drop_usage_count(dev);
+ 	if (ret == 0)
  		rpm_idle(dev, RPM_AUTO | RPM_ASYNC);
++<<<<<<< HEAD
++=======
+ 	else if (ret > 0)
+ 		trace_rpm_usage_rcuidle(dev, RPM_AUTO | RPM_ASYNC);
++>>>>>>> 82586a721595 (PM: runtime: Avoid device usage count underflows)
  
   out:
  	spin_unlock_irq(&dev->power.lock);
* Unmerged path drivers/base/power/runtime.c
