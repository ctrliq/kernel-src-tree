net/mlx5: Use devl_ API for rate nodes destroy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Moshe Shemesh <moshe@nvidia.com>
commit 03f9c47d0f7983bc73854ee34be6814b580ac7fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/03f9c47d.failed

Use devl_rate_nodes_destroy() instead of devlink_rate_nodes_destroy().
Add devlink instance lock in the driver paths to this function to have
it locked while calling devl_ API function.

This will be used by the downstream patch to invoke
mlx5_devlink_eswitch_mode_set() with devlink lock held.

	Signed-off-by: Moshe Shemesh <moshe@nvidia.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 03f9c47d0f7983bc73854ee34be6814b580ac7fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 7af76810cb8f,571114e4878f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1335,56 -1327,90 +1335,114 @@@ int mlx5_eswitch_enable(struct mlx5_esw
  	return ret;
  }
  
++<<<<<<< HEAD
 +void mlx5_eswitch_disable_locked(struct mlx5_eswitch *esw, bool clear_vf)
++=======
+ /* When disabling sriov, free driver level resources. */
+ void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw, bool clear_vf)
+ {
+ 	struct devlink *devlink;
+ 
+ 	if (!mlx5_esw_allowed(esw))
+ 		return;
+ 
+ 	devlink = priv_to_devlink(esw->dev);
+ 	devl_lock(devlink);
+ 	down_write(&esw->mode_lock);
+ 	/* If driver is unloaded, this function is called twice by remove_one()
+ 	 * and mlx5_unload(). Prevent the second call.
+ 	 */
+ 	if (!esw->esw_funcs.num_vfs && !clear_vf)
+ 		goto unlock;
+ 
+ 	esw_info(esw->dev, "Unload vfs: mode(%s), nvfs(%d), active vports(%d)\n",
+ 		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
+ 		 esw->esw_funcs.num_vfs, esw->enabled_vports);
+ 
+ 	mlx5_eswitch_unload_vf_vports(esw, esw->esw_funcs.num_vfs);
+ 	if (clear_vf)
+ 		mlx5_eswitch_clear_vf_vports_info(esw);
+ 	/* If disabling sriov in switchdev mode, free meta rules here
+ 	 * because it depends on num_vfs.
+ 	 */
+ 	if (esw->mode == MLX5_ESWITCH_OFFLOADS) {
+ 		struct devlink *devlink = priv_to_devlink(esw->dev);
+ 
+ 		esw_offloads_del_send_to_vport_meta_rules(esw);
+ 		devl_rate_nodes_destroy(devlink);
+ 	}
+ 
+ 	esw->esw_funcs.num_vfs = 0;
+ 
+ unlock:
+ 	up_write(&esw->mode_lock);
+ 	devl_unlock(devlink);
+ }
+ 
+ /* Free resources for corresponding eswitch mode. It is called by devlink
+  * when changing eswitch mode or modprobe when unloading driver.
+  */
+ void mlx5_eswitch_disable_locked(struct mlx5_eswitch *esw)
++>>>>>>> 03f9c47d0f79 (net/mlx5: Use devl_ API for rate nodes destroy)
  {
  	struct devlink *devlink = priv_to_devlink(esw->dev);
 +	int old_mode;
  
 -	/* Notify eswitch users that it is exiting from current mode.
 -	 * So that it can do necessary cleanup before the eswitch is disabled.
 -	 */
 -	mlx5_esw_mode_change_notify(esw, MLX5_ESWITCH_LEGACY);
 +	lockdep_assert_held_exclusive(&esw->mode_lock);
  
 -	mlx5_eswitch_event_handlers_unregister(esw);
 +	if (esw->mode == MLX5_ESWITCH_NONE)
 +		return;
  
  	esw_info(esw->dev, "Disable: mode(%s), nvfs(%d), active vports(%d)\n",
  		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
  		 esw->esw_funcs.num_vfs, esw->enabled_vports);
  
 -	esw->fdb_table.flags &= ~MLX5_ESW_FDB_CREATED;
 -	if (esw->mode == MLX5_ESWITCH_OFFLOADS)
 -		esw_offloads_disable(esw);
 -	else if (esw->mode == MLX5_ESWITCH_LEGACY)
 +	/* Notify eswitch users that it is exiting from current mode.
 +	 * So that it can do necessary cleanup before the eswitch is disabled.
 +	 */
 +	mlx5_esw_mode_change_notify(esw, MLX5_ESWITCH_NONE);
 +
 +	mlx5_eswitch_event_handlers_unregister(esw);
 +
 +	if (esw->mode == MLX5_ESWITCH_LEGACY)
  		esw_legacy_disable(esw);
 +	else if (esw->mode == MLX5_ESWITCH_OFFLOADS)
 +		esw_offloads_disable(esw);
 +
 +	old_mode = esw->mode;
 +	esw->mode = MLX5_ESWITCH_NONE;
 +
 +	if (old_mode == MLX5_ESWITCH_OFFLOADS)
 +		mlx5_rescan_drivers(esw->dev);
 +
 +	devlink_rate_nodes_destroy(devlink);
 +
  	mlx5_esw_acls_ns_cleanup(esw);
  
++<<<<<<< HEAD
 +	if (clear_vf)
 +		mlx5_eswitch_clear_vf_vports_info(esw);
++=======
+ 	if (esw->mode == MLX5_ESWITCH_OFFLOADS)
+ 		devl_rate_nodes_destroy(devlink);
++>>>>>>> 03f9c47d0f79 (net/mlx5: Use devl_ API for rate nodes destroy)
  }
  
 -void mlx5_eswitch_disable(struct mlx5_eswitch *esw)
 +void mlx5_eswitch_disable(struct mlx5_eswitch *esw, bool clear_vf)
  {
+ 	struct devlink *devlink;
+ 
  	if (!mlx5_esw_allowed(esw))
  		return;
  
  	mlx5_lag_disable_change(esw->dev);
+ 	devlink = priv_to_devlink(esw->dev);
+ 	devl_lock(devlink);
  	down_write(&esw->mode_lock);
 -	mlx5_eswitch_disable_locked(esw);
 +	mlx5_eswitch_disable_locked(esw, clear_vf);
 +	esw->esw_funcs.num_vfs = 0;
  	up_write(&esw->mode_lock);
+ 	devl_unlock(devlink);
  	mlx5_lag_enable_change(esw->dev);
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index aaa5e6840908,f1640e4cb719..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -3395,6 -3377,9 +3395,12 @@@ int mlx5_devlink_eswitch_mode_set(struc
  	if (cur_mlx5_mode == mlx5_mode)
  		goto unlock;
  
++<<<<<<< HEAD
++=======
+ 	devl_lock(devlink);
+ 	mlx5_eswitch_disable_locked(esw);
+ 	devl_unlock(devlink);
++>>>>>>> 03f9c47d0f79 (net/mlx5: Use devl_ API for rate nodes destroy)
  	if (mode == DEVLINK_ESWITCH_MODE_SWITCHDEV) {
  		if (mlx5_devlink_trap_get_num_active(esw->dev)) {
  			NL_SET_ERR_MSG_MOD(extack,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
