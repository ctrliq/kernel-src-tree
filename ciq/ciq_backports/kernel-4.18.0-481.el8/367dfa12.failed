net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Moshe Shemesh <moshe@nvidia.com>
commit 367dfa1212050b9418b890a2f74a3550e31b571d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/367dfa12.failed

The function mlx5_eswtich_mode_callback_enter() was added as a temporary
workaround once devlink instance lock was added to devlink eswitch
callbacks. However, code review and testing show that all the callbacks
part to eswitch_mode_set don't take devlink instance lock in any flow
and so unlocking devlink instance lock while entering these functions is
not needed.

Remove devl_lock from mlx5_eswtich_mode_callback_enter() and devl_unlock
from mlx5_eswtich_mode_callback_exit(). Also remove the functions
mlx5_eswtich_mode_callback_enter()/exit() as they are not needed any
more. The callback eswitch_mode_set will be treated separately in the
following patches.

	Signed-off-by: Moshe Shemesh <moshe@nvidia.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 367dfa1212050b9418b890a2f74a3550e31b571d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index aaa5e6840908,3bd843e6d66a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -3330,36 -3342,6 +3330,39 @@@ static int esw_inline_mode_to_devlink(u
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int eswitch_devlink_esw_mode_check(const struct mlx5_eswitch *esw)
 +{
 +	/* devlink commands in NONE eswitch mode are currently supported only
 +	 * on ECPF.
 +	 */
 +	return (esw->mode == MLX5_ESWITCH_NONE &&
 +		!mlx5_core_is_ecpf_esw_manager(esw->dev)) ? -EOPNOTSUPP : 0;
 +}
 +
 +/* FIXME: devl_unlock() followed by devl_lock() inside driver callback
 + * is never correct and prone to races. It's a transitional workaround,
 + * never repeat this pattern.
 + *
 + * This code MUST be fixed before removing devlink_mutex as it is safe
 + * to do only because of that mutex.
 + */
 +static void mlx5_eswtich_mode_callback_enter(struct devlink *devlink,
 +					     struct mlx5_eswitch *esw)
 +{
 +	devl_unlock(devlink);
 +	down_write(&esw->mode_lock);
 +}
 +
 +static void mlx5_eswtich_mode_callback_exit(struct devlink *devlink,
 +					    struct mlx5_eswitch *esw)
 +{
 +	up_write(&esw->mode_lock);
 +	devl_lock(devlink);
 +}
 +
++=======
++>>>>>>> 367dfa121205 (net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter)
  int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,
  				  struct netlink_ext_ack *extack)
  {
@@@ -3426,14 -3410,9 +3429,20 @@@ int mlx5_devlink_eswitch_mode_get(struc
  	if (IS_ERR(esw))
  		return PTR_ERR(esw);
  
++<<<<<<< HEAD
 +	mlx5_eswtich_mode_callback_enter(devlink, esw);
 +	err = eswitch_devlink_esw_mode_check(esw);
 +	if (err)
 +		goto unlock;
 +
 +	err = esw_mode_to_devlink(esw->mode, mode);
 +unlock:
 +	mlx5_eswtich_mode_callback_exit(devlink, esw);
++=======
+ 	down_write(&esw->mode_lock);
+ 	err = esw_mode_to_devlink(esw->mode, mode);
+ 	up_write(&esw->mode_lock);
++>>>>>>> 367dfa121205 (net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter)
  	return err;
  }
  
@@@ -3480,10 -3459,7 +3489,14 @@@ int mlx5_devlink_eswitch_inline_mode_se
  	if (IS_ERR(esw))
  		return PTR_ERR(esw);
  
++<<<<<<< HEAD
 +	mlx5_eswtich_mode_callback_enter(devlink, esw);
 +	err = eswitch_devlink_esw_mode_check(esw);
 +	if (err)
 +		goto out;
++=======
+ 	down_write(&esw->mode_lock);
++>>>>>>> 367dfa121205 (net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter)
  
  	switch (MLX5_CAP_ETH(dev, wqe_inline_mode)) {
  	case MLX5_CAP_INLINE_MODE_NOT_REQUIRED:
@@@ -3534,14 -3510,9 +3547,20 @@@ int mlx5_devlink_eswitch_inline_mode_ge
  	if (IS_ERR(esw))
  		return PTR_ERR(esw);
  
++<<<<<<< HEAD
 +	mlx5_eswtich_mode_callback_enter(devlink, esw);
 +	err = eswitch_devlink_esw_mode_check(esw);
 +	if (err)
 +		goto unlock;
 +
 +	err = esw_inline_mode_to_devlink(esw->offloads.inline_mode, mode);
 +unlock:
 +	mlx5_eswtich_mode_callback_exit(devlink, esw);
++=======
+ 	down_write(&esw->mode_lock);
+ 	err = esw_inline_mode_to_devlink(esw->offloads.inline_mode, mode);
+ 	up_write(&esw->mode_lock);
++>>>>>>> 367dfa121205 (net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter)
  	return err;
  }
  
@@@ -3557,10 -3528,7 +3576,14 @@@ int mlx5_devlink_eswitch_encap_mode_set
  	if (IS_ERR(esw))
  		return PTR_ERR(esw);
  
++<<<<<<< HEAD
 +	mlx5_eswtich_mode_callback_enter(devlink, esw);
 +	err = eswitch_devlink_esw_mode_check(esw);
 +	if (err)
 +		goto unlock;
++=======
+ 	down_write(&esw->mode_lock);
++>>>>>>> 367dfa121205 (net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter)
  
  	if (encap != DEVLINK_ESWITCH_ENCAP_MODE_NONE &&
  	    (!MLX5_CAP_ESW_FLOWTABLE_FDB(dev, reformat) ||
@@@ -3617,15 -3584,10 +3640,22 @@@ int mlx5_devlink_eswitch_encap_mode_get
  	if (IS_ERR(esw))
  		return PTR_ERR(esw);
  
++<<<<<<< HEAD
 +	mlx5_eswtich_mode_callback_enter(devlink, esw);
 +	err = eswitch_devlink_esw_mode_check(esw);
 +	if (err)
 +		goto unlock;
 +
 +	*encap = esw->offloads.encap;
 +unlock:
 +	mlx5_eswtich_mode_callback_exit(devlink, esw);
 +	return err;
++=======
+ 	down_write(&esw->mode_lock);
+ 	*encap = esw->offloads.encap;
+ 	up_write(&esw->mode_lock);
+ 	return 0;
++>>>>>>> 367dfa121205 (net/mlx5: Remove devl_unlock from mlx5_eswtich_mode_callback_enter)
  }
  
  static bool
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
