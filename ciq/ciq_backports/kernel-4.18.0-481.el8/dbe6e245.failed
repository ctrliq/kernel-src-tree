powerpc/bpf/64: add support for atomic fetch operations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Hari Bathini <hbathini@linux.ibm.com>
commit dbe6e2456fb0263a5a961a92836d2cebdbca979c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/dbe6e245.failed

Adding instructions for ppc64 for

atomic[64]_fetch_add
atomic[64]_fetch_and
atomic[64]_fetch_or
atomic[64]_fetch_xor

	Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
	Tested-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com> (ppc64le)
	Reviewed-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20220610155552.25892-3-hbathini@linux.ibm.com

(cherry picked from commit dbe6e2456fb0263a5a961a92836d2cebdbca979c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/net/bpf_jit_comp64.c
diff --cc arch/powerpc/net/bpf_jit_comp64.c
index 3361fea2cdf5,c53236b3a8b1..000000000000
--- a/arch/powerpc/net/bpf_jit_comp64.c
+++ b/arch/powerpc/net/bpf_jit_comp64.c
@@@ -736,43 -777,56 +736,90 @@@ emit_clear
  		 * BPF_STX ATOMIC (atomic ops)
  		 */
  		case BPF_STX | BPF_ATOMIC | BPF_W:
++<<<<<<< HEAD
 +			if (imm != BPF_ADD) {
++=======
+ 		case BPF_STX | BPF_ATOMIC | BPF_DW:
+ 			/* Get offset into TMP_REG_1 */
+ 			EMIT(PPC_RAW_LI(tmp1_reg, off));
+ 			tmp_idx = ctx->idx * 4;
+ 			/* load value from memory into TMP_REG_2 */
+ 			if (size == BPF_DW)
+ 				EMIT(PPC_RAW_LDARX(tmp2_reg, tmp1_reg, dst_reg, 0));
+ 			else
+ 				EMIT(PPC_RAW_LWARX(tmp2_reg, tmp1_reg, dst_reg, 0));
+ 
+ 			/* Save old value in _R0 */
+ 			if (imm & BPF_FETCH)
+ 				EMIT(PPC_RAW_MR(_R0, tmp2_reg));
+ 
+ 			switch (imm) {
+ 			case BPF_ADD:
+ 			case BPF_ADD | BPF_FETCH:
+ 				EMIT(PPC_RAW_ADD(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			case BPF_AND:
+ 			case BPF_AND | BPF_FETCH:
+ 				EMIT(PPC_RAW_AND(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			case BPF_OR:
+ 			case BPF_OR | BPF_FETCH:
+ 				EMIT(PPC_RAW_OR(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			case BPF_XOR:
+ 			case BPF_XOR | BPF_FETCH:
+ 				EMIT(PPC_RAW_XOR(tmp2_reg, tmp2_reg, src_reg));
+ 				break;
+ 			default:
++>>>>>>> dbe6e2456fb0 (powerpc/bpf/64: add support for atomic fetch operations)
  				pr_err_ratelimited(
  					"eBPF filter atomic op code %02x (@%d) unsupported\n",
  					code, i);
 -				return -EOPNOTSUPP;
 +				return -ENOTSUPP;
  			}
  
++<<<<<<< HEAD
 +			/* *(u32 *)(dst + off) += src */
 +
 +			/* Get EA into TMP_REG_1 */
 +			EMIT(PPC_RAW_ADDI(b2p[TMP_REG_1], dst_reg, off));
 +			tmp_idx = ctx->idx * 4;
 +			/* load value from memory into TMP_REG_2 */
 +			EMIT(PPC_RAW_LWARX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1], 0));
 +			/* add value from src_reg into this */
 +			EMIT(PPC_RAW_ADD(b2p[TMP_REG_2], b2p[TMP_REG_2], src_reg));
 +			/* store result back */
 +			EMIT(PPC_RAW_STWCX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1]));
++=======
+ 			/* store new value */
+ 			if (size == BPF_DW)
+ 				EMIT(PPC_RAW_STDCX(tmp2_reg, tmp1_reg, dst_reg));
+ 			else
+ 				EMIT(PPC_RAW_STWCX(tmp2_reg, tmp1_reg, dst_reg));
++>>>>>>> dbe6e2456fb0 (powerpc/bpf/64: add support for atomic fetch operations)
  			/* we're done if this succeeded */
  			PPC_BCC_SHORT(COND_NE, tmp_idx);
+ 
+ 			/* For the BPF_FETCH variant, get old value into src_reg */
+ 			if (imm & BPF_FETCH)
+ 				EMIT(PPC_RAW_MR(src_reg, _R0));
  			break;
 +		case BPF_STX | BPF_ATOMIC | BPF_DW:
 +			if (imm != BPF_ADD) {
 +				pr_err_ratelimited(
 +					"eBPF filter atomic op code %02x (@%d) unsupported\n",
 +					code, i);
 +				return -ENOTSUPP;
 +			}
 +			/* *(u64 *)(dst + off) += src */
 +
 +			EMIT(PPC_RAW_ADDI(b2p[TMP_REG_1], dst_reg, off));
 +			tmp_idx = ctx->idx * 4;
 +			EMIT(PPC_RAW_LDARX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1], 0));
 +			EMIT(PPC_RAW_ADD(b2p[TMP_REG_2], b2p[TMP_REG_2], src_reg));
 +			EMIT(PPC_RAW_STDCX(b2p[TMP_REG_2], 0, b2p[TMP_REG_1]));
 +			PPC_BCC_SHORT(COND_NE, tmp_idx);
 +			break;
  
  		/*
  		 * BPF_LDX
* Unmerged path arch/powerpc/net/bpf_jit_comp64.c
