can: m_can: remove a copy of the NAPI_POLL_WEIGHT define

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit e1cf330fa28acc342e527baf12298a5fd8219bad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/e1cf330f.failed

Defining local versions of NAPI_POLL_WEIGHT with the same values in
the drivers just makes refactoring harder.

Link: https://lore.kernel.org/all/20220429174446.196655-1-kuba@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
(cherry picked from commit e1cf330fa28acc342e527baf12298a5fd8219bad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/can/m_can/m_can.c
diff --cc drivers/net/can/m_can/m_can.c
index 9b449400376b,e6d2da4a9f41..000000000000
--- a/drivers/net/can/m_can/m_can.c
+++ b/drivers/net/can/m_can/m_can.c
@@@ -86,36 -77,13 +86,41 @@@ enum m_can_reg 
  	M_CAN_TXEFA	= 0xf8,
  };
  
++<<<<<<< HEAD
 +/* m_can lec values */
 +enum m_can_lec_type {
 +	LEC_NO_ERROR = 0,
 +	LEC_STUFF_ERROR,
 +	LEC_FORM_ERROR,
 +	LEC_ACK_ERROR,
 +	LEC_BIT1_ERROR,
 +	LEC_BIT0_ERROR,
 +	LEC_CRC_ERROR,
 +	LEC_UNUSED,
 +};
 +
 +enum m_can_mram_cfg {
 +	MRAM_SIDF = 0,
 +	MRAM_XIDF,
 +	MRAM_RXF0,
 +	MRAM_RXF1,
 +	MRAM_RXB,
 +	MRAM_TXE,
 +	MRAM_TXB,
 +	MRAM_CFG_NUM,
 +};
++=======
+ /* message ram configuration data length */
+ #define MRAM_CFG_LEN	8
++>>>>>>> e1cf330fa28a (can: m_can: remove a copy of the NAPI_POLL_WEIGHT define)
  
  /* Core Release Register (CREL) */
 -#define CREL_REL_MASK		GENMASK(31, 28)
 -#define CREL_STEP_MASK		GENMASK(27, 24)
 -#define CREL_SUBSTEP_MASK	GENMASK(23, 20)
 +#define CREL_REL_SHIFT		28
 +#define CREL_REL_MASK		(0xF << CREL_REL_SHIFT)
 +#define CREL_STEP_SHIFT		24
 +#define CREL_STEP_MASK		(0xF << CREL_STEP_SHIFT)
 +#define CREL_SUBSTEP_SHIFT	20
 +#define CREL_SUBSTEP_MASK	(0xF << CREL_SUBSTEP_SHIFT)
  
  /* Data Bit Timing & Prescaler Register (DBTP) */
  #define DBTP_TDC		BIT(23)
@@@ -841,7 -943,65 +846,69 @@@ end
  	return work_done;
  }
  
++<<<<<<< HEAD
 +static void m_can_echo_tx_event(struct net_device *dev)
++=======
+ static int m_can_rx_peripheral(struct net_device *dev)
+ {
+ 	struct m_can_classdev *cdev = netdev_priv(dev);
+ 	int work_done;
+ 
+ 	work_done = m_can_rx_handler(dev, NAPI_POLL_WEIGHT);
+ 
+ 	/* Don't re-enable interrupts if the driver had a fatal error
+ 	 * (e.g., FIFO read failure).
+ 	 */
+ 	if (work_done >= 0)
+ 		m_can_enable_all_interrupts(cdev);
+ 
+ 	return work_done;
+ }
+ 
+ static int m_can_poll(struct napi_struct *napi, int quota)
+ {
+ 	struct net_device *dev = napi->dev;
+ 	struct m_can_classdev *cdev = netdev_priv(dev);
+ 	int work_done;
+ 
+ 	work_done = m_can_rx_handler(dev, quota);
+ 
+ 	/* Don't re-enable interrupts if the driver had a fatal error
+ 	 * (e.g., FIFO read failure).
+ 	 */
+ 	if (work_done >= 0 && work_done < quota) {
+ 		napi_complete_done(napi, work_done);
+ 		m_can_enable_all_interrupts(cdev);
+ 	}
+ 
+ 	return work_done;
+ }
+ 
+ /* Echo tx skb and update net stats. Peripherals use rx-offload for
+  * echo. timestamp is used for peripherals to ensure correct ordering
+  * by rx-offload, and is ignored for non-peripherals.
+  */
+ static void m_can_tx_update_stats(struct m_can_classdev *cdev,
+ 				  unsigned int msg_mark,
+ 				  u32 timestamp)
+ {
+ 	struct net_device *dev = cdev->net;
+ 	struct net_device_stats *stats = &dev->stats;
+ 
+ 	if (cdev->is_peripheral)
+ 		stats->tx_bytes +=
+ 			can_rx_offload_get_echo_skb(&cdev->offload,
+ 						    msg_mark,
+ 						    timestamp,
+ 						    NULL);
+ 	else
+ 		stats->tx_bytes += can_get_echo_skb(dev, msg_mark, NULL);
+ 
+ 	stats->tx_packets++;
+ }
+ 
+ static int m_can_echo_tx_event(struct net_device *dev)
++>>>>>>> e1cf330fa28a (can: m_can: remove a copy of the NAPI_POLL_WEIGHT define)
  {
  	u32 txe_count = 0;
  	u32 m_can_txefs;
@@@ -1256,30 -1469,35 +1323,36 @@@ static int m_can_dev_setup(struct platf
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	priv = netdev_priv(dev);
 +	netif_napi_add(dev, &priv->napi, m_can_poll, M_CAN_NAPI_WEIGHT);
++=======
+ 	if (!cdev->is_peripheral)
+ 		netif_napi_add(dev, &cdev->napi,
+ 			       m_can_poll, NAPI_POLL_WEIGHT);
++>>>>>>> e1cf330fa28a (can: m_can: remove a copy of the NAPI_POLL_WEIGHT define)
  
  	/* Shared properties of all M_CAN versions */
 -	cdev->version = m_can_version;
 -	cdev->can.do_set_mode = m_can_set_mode;
 -	cdev->can.do_get_berr_counter = m_can_get_berr_counter;
 +	priv->version = m_can_version;
 +	priv->dev = dev;
 +	priv->base = addr;
 +	priv->can.do_set_mode = m_can_set_mode;
 +	priv->can.do_get_berr_counter = m_can_get_berr_counter;
  
  	/* Set M_CAN supported operations */
 -	cdev->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
 -		CAN_CTRLMODE_LISTENONLY |
 -		CAN_CTRLMODE_BERR_REPORTING |
 -		CAN_CTRLMODE_FD |
 -		CAN_CTRLMODE_ONE_SHOT;
 +	priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
 +					CAN_CTRLMODE_LISTENONLY |
 +					CAN_CTRLMODE_BERR_REPORTING |
 +					CAN_CTRLMODE_FD;
  
  	/* Set properties depending on M_CAN version */
 -	switch (cdev->version) {
 +	switch (priv->version) {
  	case 30:
  		/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.0.x */
 -		err = can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);
 -		if (err)
 -			return err;
 -		cdev->can.bittiming_const = cdev->bit_timing ?
 -			cdev->bit_timing : &m_can_bittiming_const_30X;
 -
 -		cdev->can.data_bittiming_const = cdev->data_timing ?
 -			cdev->data_timing :
 -			&m_can_data_bittiming_const_30X;
 +		can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);
 +		priv->can.bittiming_const = &m_can_bittiming_const_30X;
 +		priv->can.data_bittiming_const =
 +				&m_can_data_bittiming_const_30X;
  		break;
  	case 31:
  		/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.1.x */
@@@ -1631,50 -1956,63 +1704,77 @@@ static int m_can_plat_probe(struct plat
  	tx_fifo_size = mram_config_vals[7];
  
  	/* allocate the m_can device */
 -	net_dev = alloc_candev(sizeof_priv, tx_fifo_size);
 -	if (!net_dev) {
 -		dev_err(dev, "Failed to allocate CAN device");
 -		goto out;
 +	dev = alloc_candev(sizeof(*priv), tx_fifo_size);
 +	if (!dev) {
 +		ret = -ENOMEM;
 +		goto failed_ret;
  	}
  
 -	class_dev = netdev_priv(net_dev);
 -	class_dev->net = net_dev;
 -	class_dev->dev = dev;
 -	SET_NETDEV_DEV(net_dev, dev);
 +	priv = netdev_priv(dev);
 +	dev->irq = irq;
 +	priv->device = &pdev->dev;
 +	priv->hclk = hclk;
 +	priv->cclk = cclk;
 +	priv->can.clock.freq = clk_get_rate(cclk);
 +	priv->mram_base = mram_addr;
  
 -	m_can_of_parse_mram(class_dev, mram_config_vals);
 -out:
 -	return class_dev;
 -}
 -EXPORT_SYMBOL_GPL(m_can_class_allocate_dev);
 +	platform_set_drvdata(pdev, dev);
 +	SET_NETDEV_DEV(dev, &pdev->dev);
  
++<<<<<<< HEAD
 +	/* Enable clocks. Necessary to read Core Release in order to determine
 +	 * M_CAN version
 +	 */
 +	pm_runtime_enable(&pdev->dev);
 +	ret = m_can_clk_start(priv);
++=======
+ void m_can_class_free_dev(struct net_device *net)
+ {
+ 	free_candev(net);
+ }
+ EXPORT_SYMBOL_GPL(m_can_class_free_dev);
+ 
+ int m_can_class_register(struct m_can_classdev *cdev)
+ {
+ 	int ret;
+ 
+ 	if (cdev->pm_clock_support) {
+ 		ret = m_can_clk_start(cdev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (cdev->is_peripheral) {
+ 		ret = can_rx_offload_add_manual(cdev->net, &cdev->offload,
+ 						NAPI_POLL_WEIGHT);
+ 		if (ret)
+ 			goto clk_disable;
+ 	}
+ 
+ 	ret = m_can_dev_setup(cdev);
++>>>>>>> e1cf330fa28a (can: m_can: remove a copy of the NAPI_POLL_WEIGHT define)
 +	if (ret)
 +		goto pm_runtime_fail;
 +
 +	ret = m_can_dev_setup(pdev, dev, addr);
  	if (ret)
 -		goto rx_offload_del;
 +		goto clk_disable;
  
 -	ret = register_m_can_dev(cdev->net);
 +	ret = register_m_can_dev(dev);
  	if (ret) {
 -		dev_err(cdev->dev, "registering %s failed (err=%d)\n",
 -			cdev->net->name, ret);
 -		goto rx_offload_del;
 +		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
 +			KBUILD_MODNAME, ret);
 +		goto clk_disable;
  	}
  
 -	devm_can_led_init(cdev->net);
 +	m_can_of_parse_mram(priv, mram_config_vals);
  
 -	of_can_transceiver(cdev->net);
 +	devm_can_led_init(dev);
  
 -	dev_info(cdev->dev, "%s device registered (irq=%d, version=%d)\n",
 -		 KBUILD_MODNAME, cdev->net->irq, cdev->version);
 +	of_can_transceiver(dev);
 +
 +	dev_info(&pdev->dev, "%s device registered (irq=%d, version=%d)\n",
 +		 KBUILD_MODNAME, dev->irq, priv->version);
  
  	/* Probe finished
  	 * Stop clocks. They will be reactivated once the M_CAN device is opened
* Unmerged path drivers/net/can/m_can/m_can.c
