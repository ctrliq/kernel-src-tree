net: stmmac: fill in supported_interfaces

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
commit d194923d51c939469ad594521860450924869eca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/d194923d.failed

Fill in phylink's supported_interfaces bitmap with the PHY interface
modes which can be used to talk to the PHY.

We indicate that the PHY interface mode passed in platform data is
always supported, as this is the initial mode passed into phylink.
When there is no PCS specified, we assume that this is the only mode
that is supported - indeed, the driver appears not to support dynamic
switching of interface types at present.

When a xpcs is present, it defines the PHY interface modes that the
stmmac driver can support. Request the supported interfaces from the
xpcs driver, and pass them to phylink.

	Tested-by: Wong Vee Khee <vee.khee.wong@linux.intel.com> # Intel EHL            Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d194923d51c939469ad594521860450924869eca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 49d38e3b6733,bd20920daf7b..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -1243,6 -1194,45 +1243,48 @@@ static int stmmac_phy_setup(struct stmm
  	if (!fwnode)
  		fwnode = dev_fwnode(priv->device);
  
++<<<<<<< HEAD
++=======
+ 	/* Set the platform/firmware specified interface mode */
+ 	__set_bit(mode, priv->phylink_config.supported_interfaces);
+ 
+ 	/* If we have an xpcs, it defines which PHY interfaces are supported. */
+ 	if (priv->hw->xpcs)
+ 		xpcs_get_interfaces(priv->hw->xpcs,
+ 				    priv->phylink_config.supported_interfaces);
+ 
+ 	priv->phylink_config.mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |
+ 		MAC_10 | MAC_100;
+ 
+ 	if (!max_speed || max_speed >= 1000)
+ 		priv->phylink_config.mac_capabilities |= MAC_1000;
+ 
+ 	if (priv->plat->has_gmac4) {
+ 		if (!max_speed || max_speed >= 2500)
+ 			priv->phylink_config.mac_capabilities |= MAC_2500FD;
+ 	} else if (priv->plat->has_xgmac) {
+ 		if (!max_speed || max_speed >= 2500)
+ 			priv->phylink_config.mac_capabilities |= MAC_2500FD;
+ 		if (!max_speed || max_speed >= 5000)
+ 			priv->phylink_config.mac_capabilities |= MAC_5000FD;
+ 		if (!max_speed || max_speed >= 10000)
+ 			priv->phylink_config.mac_capabilities |= MAC_10000FD;
+ 		if (!max_speed || max_speed >= 25000)
+ 			priv->phylink_config.mac_capabilities |= MAC_25000FD;
+ 		if (!max_speed || max_speed >= 40000)
+ 			priv->phylink_config.mac_capabilities |= MAC_40000FD;
+ 		if (!max_speed || max_speed >= 50000)
+ 			priv->phylink_config.mac_capabilities |= MAC_50000FD;
+ 		if (!max_speed || max_speed >= 100000)
+ 			priv->phylink_config.mac_capabilities |= MAC_100000FD;
+ 	}
+ 
+ 	/* Half-Duplex can only work with single queue */
+ 	if (priv->plat->tx_queues_to_use > 1)
+ 		priv->phylink_config.mac_capabilities &=
+ 			~(MAC_10HD | MAC_100HD | MAC_1000HD);
+ 
++>>>>>>> d194923d51c9 (net: stmmac: fill in supported_interfaces)
  	phylink = phylink_create(&priv->phylink_config, fwnode,
  				 mode, &stmmac_phylink_mac_ops);
  	if (IS_ERR(phylink))
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
