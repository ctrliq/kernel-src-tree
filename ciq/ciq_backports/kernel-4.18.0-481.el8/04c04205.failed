bpf powerpc: Remove extra_pass from bpf_jit_build_body()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit 04c04205bc35d0ecdc57146995ca9eb957d4f379
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/04c04205.failed

In case of extra_pass, usual JIT passes are always skipped. So,
extra_pass is always false while calling bpf_jit_build_body() and
can be removed.

	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20211012123056.485795-3-hbathini@linux.ibm.com

(cherry picked from commit 04c04205bc35d0ecdc57146995ca9eb957d4f379)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/net/bpf_jit_comp.c
#	arch/powerpc/net/bpf_jit_comp32.c
diff --cc arch/powerpc/net/bpf_jit_comp.c
index 16ef5fa3992f,f39ad8d123dd..000000000000
--- a/arch/powerpc/net/bpf_jit_comp.c
+++ b/arch/powerpc/net/bpf_jit_comp.c
@@@ -227,7 -210,11 +227,15 @@@ skip_init_ctx
  		/* Now build the prologue, body code & epilogue for real. */
  		cgctx.idx = 0;
  		bpf_jit_build_prologue(code_base, &cgctx);
++<<<<<<< HEAD
 +		bpf_jit_build_body(fp, code_base, &cgctx, addrs, extra_pass);
++=======
+ 		if (bpf_jit_build_body(fp, code_base, &cgctx, addrs)) {
+ 			bpf_jit_binary_free(bpf_hdr);
+ 			fp = org_fp;
+ 			goto out_addrs;
+ 		}
++>>>>>>> 04c04205bc35 (bpf powerpc: Remove extra_pass from bpf_jit_build_body())
  		bpf_jit_build_epilogue(code_base, &cgctx);
  
  		if (bpf_jit_enable > 1)
* Unmerged path arch/powerpc/net/bpf_jit_comp32.c
diff --git a/arch/powerpc/net/bpf_jit.h b/arch/powerpc/net/bpf_jit.h
index d22140878361..7bae342f1e20 100644
--- a/arch/powerpc/net/bpf_jit.h
+++ b/arch/powerpc/net/bpf_jit.h
@@ -166,7 +166,7 @@ static inline void bpf_clear_seen_register(struct codegen_context *ctx, int i)
 
 void bpf_jit_emit_func_call_rel(u32 *image, struct codegen_context *ctx, u64 func);
 int bpf_jit_build_body(struct bpf_prog *fp, u32 *image, struct codegen_context *ctx,
-		       u32 *addrs, bool extra_pass);
+		       u32 *addrs);
 void bpf_jit_build_prologue(u32 *image, struct codegen_context *ctx);
 void bpf_jit_build_epilogue(u32 *image, struct codegen_context *ctx);
 void bpf_jit_realloc_regs(struct codegen_context *ctx);
* Unmerged path arch/powerpc/net/bpf_jit_comp.c
* Unmerged path arch/powerpc/net/bpf_jit_comp32.c
diff --git a/arch/powerpc/net/bpf_jit_comp64.c b/arch/powerpc/net/bpf_jit_comp64.c
index cbb5838adebc..bff9dfb5f965 100644
--- a/arch/powerpc/net/bpf_jit_comp64.c
+++ b/arch/powerpc/net/bpf_jit_comp64.c
@@ -298,7 +298,7 @@ asm (
 
 /* Assemble the body code between the prologue & epilogue */
 int bpf_jit_build_body(struct bpf_prog *fp, u32 *image, struct codegen_context *ctx,
-		       u32 *addrs, bool extra_pass)
+		       u32 *addrs)
 {
 	enum stf_barrier_type stf_barrier = stf_barrier_type_get();
 	const struct bpf_insn *insn = fp->insnsi;
@@ -837,7 +837,7 @@ int bpf_jit_build_body(struct bpf_prog *fp, u32 *image, struct codegen_context *
 		case BPF_JMP | BPF_CALL:
 			ctx->seen |= SEEN_FUNC;
 
-			ret = bpf_jit_get_func_addr(fp, &insn[i], extra_pass,
+			ret = bpf_jit_get_func_addr(fp, &insn[i], false,
 						    &func_addr, &func_addr_fixed);
 			if (ret < 0)
 				return ret;
