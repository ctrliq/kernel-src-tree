perf/x86/amd: Add AMD branch sampling period adjustment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Stephane Eranian <eranian@google.com>
commit ba2fe7500845a30fc845a72081999cf632051862
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/ba2fe750.failed

Add code to adjust the sampling event period when used with the Branch
Sampling feature (BRS). Given the depth of the BRS (16), the period is
reduced by that depth such that in the best case scenario, BRS saturates at
the desired sampling period. In practice, though, the processor may execute
more branches. Given a desired period P and a depth D, the kernel programs
the actual period at P - D. After P occurrences of the sampling event, the
counter overflows. It then may take X branches (skid) before the NMI is
caught and held by the hardware and BRS activates. Then, after D branches,
BRS saturates and the NMI is delivered.  With no skid, the effective period
would be (P - D) + D = P. In practice, however, it will likely be (P - D) +
X + D. There is no way to eliminate X or predict X.

	Signed-off-by: Stephane Eranian <eranian@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lore.kernel.org/r/20220322221517.2510440-7-eranian@google.com
(cherry picked from commit ba2fe7500845a30fc845a72081999cf632051862)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/perf_event.h
diff --cc arch/x86/events/perf_event.h
index 139832e590d3,d91ff2c6cefe..000000000000
--- a/arch/x86/events/perf_event.h
+++ b/arch/x86/events/perf_event.h
@@@ -1222,7 -1218,59 +1222,15 @@@ static inline bool fixed_counter_disabl
  #ifdef CONFIG_CPU_SUP_AMD
  
  int amd_pmu_init(void);
 -int amd_brs_init(void);
 -void amd_brs_disable(void);
 -void amd_brs_enable(void);
 -void amd_brs_enable_all(void);
 -void amd_brs_disable_all(void);
 -void amd_brs_drain(void);
 -void amd_brs_disable_all(void);
 -int amd_brs_setup_filter(struct perf_event *event);
 -void amd_brs_reset(void);
 -
 -static inline void amd_pmu_brs_add(struct perf_event *event)
 -{
 -	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
 -
 -	perf_sched_cb_inc(event->ctx->pmu);
 -	cpuc->lbr_users++;
 -	/*
 -	 * No need to reset BRS because it is reset
 -	 * on brs_enable() and it is saturating
 -	 */
 -}
 -
 -static inline void amd_pmu_brs_del(struct perf_event *event)
 -{
 -	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
 -
 -	cpuc->lbr_users--;
 -	WARN_ON_ONCE(cpuc->lbr_users < 0);
 -
 -	perf_sched_cb_dec(event->ctx->pmu);
 -}
 -
 -void amd_pmu_brs_sched_task(struct perf_event_context *ctx, bool sched_in);
 -
 -/*
 - * check if BRS is activated on the CPU
 - * active defined as it has non-zero users and DBG_EXT_CFG.BRSEN=1
 - */
 -static inline bool amd_brs_active(void)
 -{
 -	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
 -
 -	return cpuc->brs_active;
 -}
  
+ static inline s64 amd_brs_adjust_period(s64 period)
+ {
+ 	if (period > x86_pmu.lbr_nr)
+ 		return period - x86_pmu.lbr_nr;
+ 
+ 	return period;
+ }
+ 
  #else /* CONFIG_CPU_SUP_AMD */
  
  static inline int amd_pmu_init(void)
@@@ -1230,6 -1278,27 +1238,30 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int amd_brs_init(void)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline void amd_brs_drain(void)
+ {
+ }
+ 
+ static inline void amd_brs_enable_all(void)
+ {
+ }
+ 
+ static inline void amd_brs_disable_all(void)
+ {
+ }
+ 
+ static inline s64 amd_brs_adjust_period(s64 period)
+ {
+ 	return period;
+ }
++>>>>>>> ba2fe7500845 (perf/x86/amd: Add AMD branch sampling period adjustment)
  #endif /* CONFIG_CPU_SUP_AMD */
  
  static inline int is_pebs_pt(struct perf_event *event)
diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c
index 3c26785f234e..297441fcc6c8 100644
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@ -1331,6 +1331,13 @@ int x86_perf_event_set_period(struct perf_event *event)
 	    x86_pmu.set_topdown_event_period)
 		return x86_pmu.set_topdown_event_period(event);
 
+	/*
+	 * decrease period by the depth of the BRS feature to get
+	 * the last N taken branches and approximate the desired period
+	 */
+	if (has_branch_stack(event))
+		period = amd_brs_adjust_period(period);
+
 	/*
 	 * If we are way outside a reasonable range then just skip forward:
 	 */
* Unmerged path arch/x86/events/perf_event.h
