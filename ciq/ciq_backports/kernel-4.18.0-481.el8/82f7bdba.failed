net/mlx5: Clean IPsec FS add/delete rules

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 82f7bdba377578e09935bff59157f7361ec6919c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/82f7bdba.failed

Reuse existing struct to pass parameters instead of open code them.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 82f7bdba377578e09935bff59157f7361ec6919c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
index 027d80b77b28,81c9831ad286..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
@@@ -310,28 -307,13 +310,32 @@@ static int mlx5e_xfrm_add_state(struct 
  	/* check esn */
  	mlx5e_ipsec_update_esn_state(sa_entry);
  
 -	mlx5e_ipsec_build_accel_xfrm_attrs(sa_entry, &sa_entry->attrs);
 +	/* create xfrm */
 +	mlx5e_ipsec_build_accel_xfrm_attrs(sa_entry, &attrs);
 +	sa_entry->xfrm = mlx5_accel_esp_create_xfrm(priv->mdev, &attrs);
 +	if (IS_ERR(sa_entry->xfrm)) {
 +		err = PTR_ERR(sa_entry->xfrm);
 +		goto err_sa_entry;
 +	}
 +
++<<<<<<< HEAD
  	/* create hw context */
 -	err = mlx5_ipsec_create_sa_ctx(sa_entry);
 -	if (err)
 +	sa_entry->hw_context =
 +			mlx5_accel_esp_create_hw_context(priv->mdev,
 +							 sa_entry->xfrm,
 +							 &sa_handle);
 +	if (IS_ERR(sa_entry->hw_context)) {
 +		err = PTR_ERR(sa_entry->hw_context);
  		goto err_xfrm;
 +	}
  
 +	sa_entry->ipsec_obj_id = sa_handle;
 +	err = mlx5e_accel_ipsec_fs_add_rule(priv, &sa_entry->xfrm->attrs,
 +					    sa_entry->ipsec_obj_id,
 +					    &sa_entry->ipsec_rule);
++=======
+ 	err = mlx5e_accel_ipsec_fs_add_rule(priv, sa_entry);
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  	if (err)
  		goto err_hw_ctx;
  
@@@ -348,15 -331,11 +352,19 @@@
  	goto out;
  
  err_add_rule:
++<<<<<<< HEAD
 +	mlx5e_accel_ipsec_fs_del_rule(priv, &sa_entry->xfrm->attrs,
 +				      &sa_entry->ipsec_rule);
++=======
+ 	mlx5e_accel_ipsec_fs_del_rule(priv, sa_entry);
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  err_hw_ctx:
 -	mlx5_ipsec_free_sa_ctx(sa_entry);
 +	mlx5_accel_esp_free_hw_context(priv->mdev, sa_entry->hw_context);
  err_xfrm:
 +	mlx5_accel_esp_destroy_xfrm(sa_entry->xfrm);
 +err_sa_entry:
  	kfree(sa_entry);
 +
  out:
  	return err;
  }
@@@ -377,17 -353,9 +385,23 @@@ static void mlx5e_xfrm_free_state(struc
  	struct mlx5e_ipsec_sa_entry *sa_entry = to_ipsec_sa_entry(x);
  	struct mlx5e_priv *priv = netdev_priv(x->xso.dev);
  
++<<<<<<< HEAD
 +	if (!sa_entry)
 +		return;
 +
 +	if (sa_entry->hw_context) {
 +		flush_workqueue(sa_entry->ipsec->wq);
 +		mlx5e_accel_ipsec_fs_del_rule(priv, &sa_entry->xfrm->attrs,
 +					      &sa_entry->ipsec_rule);
 +		mlx5_accel_esp_free_hw_context(sa_entry->xfrm->mdev, sa_entry->hw_context);
 +		mlx5_accel_esp_destroy_xfrm(sa_entry->xfrm);
 +	}
 +
++=======
+ 	cancel_work_sync(&sa_entry->modify_work.work);
+ 	mlx5e_accel_ipsec_fs_del_rule(priv, sa_entry);
+ 	mlx5_ipsec_free_sa_ctx(sa_entry);
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  	kfree(sa_entry);
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
index 45f71910d196,af1467cbb7c7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
@@@ -122,12 -173,27 +122,35 @@@ void mlx5e_ipsec_build_netdev(struct ml
  struct xfrm_state *mlx5e_ipsec_sadb_rx_lookup(struct mlx5e_ipsec *dev,
  					      unsigned int handle);
  
++<<<<<<< HEAD
++=======
+ void mlx5e_accel_ipsec_fs_cleanup(struct mlx5e_ipsec *ipsec);
+ int mlx5e_accel_ipsec_fs_init(struct mlx5e_ipsec *ipsec);
+ int mlx5e_accel_ipsec_fs_add_rule(struct mlx5e_priv *priv,
+ 				  struct mlx5e_ipsec_sa_entry *sa_entry);
+ void mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_priv *priv,
+ 				   struct mlx5e_ipsec_sa_entry *sa_entry);
+ 
+ int mlx5_ipsec_create_sa_ctx(struct mlx5e_ipsec_sa_entry *sa_entry);
+ void mlx5_ipsec_free_sa_ctx(struct mlx5e_ipsec_sa_entry *sa_entry);
+ 
+ u32 mlx5_ipsec_device_caps(struct mlx5_core_dev *mdev);
+ 
+ void mlx5_accel_esp_modify_xfrm(struct mlx5e_ipsec_sa_entry *sa_entry,
+ 				const struct mlx5_accel_esp_xfrm_attrs *attrs);
+ 
+ static inline struct mlx5_core_dev *
+ mlx5e_ipsec_sa2dev(struct mlx5e_ipsec_sa_entry *sa_entry)
+ {
+ 	return sa_entry->ipsec->mdev;
+ }
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  #else
 +
 +static inline void mlx5e_ipsec_build_inverse_table(void)
 +{
 +}
 +
  static inline int mlx5e_ipsec_init(struct mlx5e_priv *priv)
  {
  	return 0;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 16bbf5ba1ee4,342828351254..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@@ -570,7 -566,7 +570,11 @@@ static int tx_add_rule(struct mlx5e_pri
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
  		netdev_err(priv->netdev, "fail to add ipsec rule attrs->action=0x%x, err=%d\n",
++<<<<<<< HEAD
 +			   attrs->action, err);
++=======
+ 				sa_entry->attrs.action, err);
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  		goto out;
  	}
  
@@@ -584,9 -580,10 +588,15 @@@ out
  }
  
  static void rx_del_rule(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +			struct mlx5_accel_esp_xfrm_attrs *attrs,
 +			struct mlx5e_ipsec_rule *ipsec_rule)
++=======
+ 			struct mlx5e_ipsec_sa_entry *sa_entry)
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  {
+ 	struct mlx5e_ipsec_rule *ipsec_rule = &sa_entry->ipsec_rule;
+ 
  	mlx5_del_flow_rules(ipsec_rule->rule);
  	ipsec_rule->rule = NULL;
  
@@@ -597,8 -595,10 +608,14 @@@
  }
  
  static void tx_del_rule(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +			struct mlx5e_ipsec_rule *ipsec_rule)
++=======
+ 			struct mlx5e_ipsec_sa_entry *sa_entry)
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  {
+ 	struct mlx5e_ipsec_rule *ipsec_rule = &sa_entry->ipsec_rule;
+ 
  	mlx5_del_flow_rules(ipsec_rule->rule);
  	ipsec_rule->rule = NULL;
  
@@@ -606,41 -606,26 +623,57 @@@
  }
  
  int mlx5e_accel_ipsec_fs_add_rule(struct mlx5e_priv *priv,
- 				  struct mlx5_accel_esp_xfrm_attrs *attrs,
- 				  u32 ipsec_obj_id,
- 				  struct mlx5e_ipsec_rule *ipsec_rule)
+ 				  struct mlx5e_ipsec_sa_entry *sa_entry)
  {
++<<<<<<< HEAD
 +	if (!priv->ipsec->rx_fs)
 +		return -EOPNOTSUPP;
 +
 +	if (attrs->action == MLX5_ACCEL_ESP_ACTION_DECRYPT)
 +		return rx_add_rule(priv, attrs, ipsec_obj_id, ipsec_rule);
 +	else
 +		return tx_add_rule(priv, attrs, ipsec_obj_id, ipsec_rule);
 +}
 +
 +void mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_priv *priv,
 +			     struct mlx5_accel_esp_xfrm_attrs *attrs,
 +			     struct mlx5e_ipsec_rule *ipsec_rule)
 +{
 +	if (!priv->ipsec->rx_fs)
 +		return;
 +
 +	if (attrs->action == MLX5_ACCEL_ESP_ACTION_DECRYPT)
 +		rx_del_rule(priv, attrs, ipsec_rule);
 +	else
 +		tx_del_rule(priv, ipsec_rule);
++=======
+ 	if (sa_entry->attrs.action == MLX5_ACCEL_ESP_ACTION_ENCRYPT)
+ 		return tx_add_rule(priv, sa_entry);
+ 
+ 	return rx_add_rule(priv, sa_entry);
+ }
+ 
+ void mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_priv *priv,
+ 				   struct mlx5e_ipsec_sa_entry *sa_entry)
+ {
+ 	if (sa_entry->attrs.action == MLX5_ACCEL_ESP_ACTION_ENCRYPT) {
+ 		tx_del_rule(priv, sa_entry);
+ 		return;
+ 	}
+ 
+ 	rx_del_rule(priv, sa_entry);
++>>>>>>> 82f7bdba3775 (net/mlx5: Clean IPsec FS add/delete rules)
  }
  
 -void mlx5e_accel_ipsec_fs_cleanup(struct mlx5e_ipsec *ipsec)
 +static void fs_cleanup_tx(struct mlx5e_priv *priv)
 +{
 +	mutex_destroy(&priv->ipsec->tx_fs->mutex);
 +	WARN_ON(priv->ipsec->tx_fs->refcnt);
 +	kfree(priv->ipsec->tx_fs);
 +	priv->ipsec->tx_fs = NULL;
 +}
 +
 +static void fs_cleanup_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5e_accel_fs_esp_prot *fs_prot;
  	struct mlx5e_accel_fs_esp *accel_esp;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
