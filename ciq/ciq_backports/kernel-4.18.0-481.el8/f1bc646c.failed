net/mlx5: Use devl_ API in mlx5_esw_offloads_devlink_port_register

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Moshe Shemesh <moshe@nvidia.com>
commit f1bc646c9a06f09aad5d8bacb87103b5573ee45e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/f1bc646c.failed

The function mlx5_esw_offloads_devlink_port_register() calls
devlink_port_register() and devlink_rate_leaf_create(). Use devl_ API to
call devl_port_register() and devl_rate_leaf_create() accordingly and
add devlink instance lock in driver paths to this function.

Similarly, use devl_ API to call devl_port_unregister() and
devl_rate_leaf_destroy() in mlx5_esw_offloads_devlink_port_unregister()
and ensure locking devlink instance lock on the paths to this function
too.

This will be used by the downstream patch to invoke
mlx5_devlink_eswitch_mode_set() with devlink lock held.

	Signed-off-by: Moshe Shemesh <moshe@nvidia.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit f1bc646c9a06f09aad5d8bacb87103b5573ee45e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
index 4311b9da7f11,a8f7618831f5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
@@@ -91,11 -91,9 +91,17 @@@ int mlx5_esw_offloads_devlink_port_regi
  	if (err)
  		goto reg_err;
  
++<<<<<<< HEAD
 +	if (vport_num != MLX5_VPORT_UPLINK) {
 +		err = devlink_rate_leaf_create(dl_port, vport);
 +		if (err)
 +			goto rate_err;
 +	}
++=======
+ 	err = devl_rate_leaf_create(dl_port, vport);
+ 	if (err)
+ 		goto rate_err;
++>>>>>>> f1bc646c9a06 (net/mlx5: Use devl_ API in mlx5_esw_offloads_devlink_port_register)
  
  	vport->dl_port = dl_port;
  	return 0;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index aaa5e6840908,1bfbc88f513f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -2169,11 -2177,12 +2169,18 @@@ out
  static int esw_offloads_start(struct mlx5_eswitch *esw,
  			      struct netlink_ext_ack *extack)
  {
+ 	struct devlink *devlink = priv_to_devlink(esw->dev);
  	int err, err1;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_locked(esw, false);
 +	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_OFFLOADS,
 +					 esw->dev->priv.sriov.num_vfs);
++=======
+ 	devl_lock(devlink);
+ 	esw->mode = MLX5_ESWITCH_OFFLOADS;
+ 	err = mlx5_eswitch_enable_locked(esw, esw->dev->priv.sriov.num_vfs);
++>>>>>>> f1bc646c9a06 (net/mlx5: Use devl_ API in mlx5_esw_offloads_devlink_port_register)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack,
  				   "Failed setting eswitch to offloads");
@@@ -3223,15 -3243,16 +3235,22 @@@ err_metadata
  static int esw_offloads_stop(struct mlx5_eswitch *esw,
  			     struct netlink_ext_ack *extack)
  {
+ 	struct devlink *devlink = priv_to_devlink(esw->dev);
  	int err, err1;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_locked(esw, false);
 +	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_LEGACY,
 +					 MLX5_ESWITCH_IGNORE_NUM_VFS);
++=======
+ 	devl_lock(devlink);
+ 	esw->mode = MLX5_ESWITCH_LEGACY;
+ 	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_IGNORE_NUM_VFS);
++>>>>>>> f1bc646c9a06 (net/mlx5: Use devl_ API in mlx5_esw_offloads_devlink_port_register)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack, "Failed setting eswitch to legacy");
 -		esw->mode = MLX5_ESWITCH_OFFLOADS;
 -		err1 = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_IGNORE_NUM_VFS);
 +		err1 = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_OFFLOADS,
 +						  MLX5_ESWITCH_IGNORE_NUM_VFS);
  		if (err1) {
  			NL_SET_ERR_MSG_MOD(extack,
  					   "Failed setting eswitch back to offloads");
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 7af76810cb8f..f556c895a7e7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1304,6 +1304,7 @@ int mlx5_eswitch_enable_locked(struct mlx5_eswitch *esw, int mode, int num_vfs)
  */
 int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int num_vfs)
 {
+	struct devlink *devlink;
 	bool toggle_lag;
 	int ret;
 
@@ -1315,6 +1316,8 @@ int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int num_vfs)
 	if (toggle_lag)
 		mlx5_lag_disable_change(esw->dev);
 
+	devlink = priv_to_devlink(esw->dev);
+	devl_lock(devlink);
 	down_write(&esw->mode_lock);
 	if (esw->mode == MLX5_ESWITCH_NONE) {
 		ret = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_LEGACY, num_vfs);
@@ -1328,6 +1331,7 @@ int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int num_vfs)
 			esw->esw_funcs.num_vfs = num_vfs;
 	}
 	up_write(&esw->mode_lock);
+	devl_unlock(devlink);
 
 	if (toggle_lag)
 		mlx5_lag_enable_change(esw->dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
