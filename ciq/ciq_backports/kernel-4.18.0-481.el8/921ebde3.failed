netfilter: nf_tables: fix nft_counters_enabled underflow at nf_tables_addchain()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 921ebde3c0d22c8cba74ce8eb3cc4626abff1ccd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/921ebde3.failed

syzbot is reporting underflow of nft_counters_enabled counter at
nf_tables_addchain() [1], for commit 43eb8949cfdffa76 ("netfilter:
nf_tables: do not leave chain stats enabled on error") missed that
nf_tables_chain_destroy() after nft_basechain_init() in the error path of
nf_tables_addchain() decrements the counter because nft_basechain_init()
makes nft_is_base_chain() return true by setting NFT_CHAIN_BASE flag.

Increment the counter immediately after returning from
nft_basechain_init().

Link:  https://syzkaller.appspot.com/bug?extid=b5d82a651b71cd8a75ab [1]
	Reported-by: syzbot <syzbot+b5d82a651b71cd8a75ab@syzkaller.appspotmail.com>
	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Tested-by: syzbot <syzbot+b5d82a651b71cd8a75ab@syzkaller.appspotmail.com>
Fixes: 43eb8949cfdffa76 ("netfilter: nf_tables: do not leave chain stats enabled on error")
	Signed-off-by: Florian Westphal <fw@strlen.de>
(cherry picked from commit 921ebde3c0d22c8cba74ce8eb3cc4626abff1ccd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index f8960d4da250,e062754dc6cc..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1983,9 -2211,14 +1983,10 @@@ static int nf_tables_addchain(struct nf
  		return -EOVERFLOW;
  
  	if (nla[NFTA_CHAIN_HOOK]) {
+ 		struct nft_stats __percpu *stats = NULL;
  		struct nft_chain_hook hook;
  
 -		if (flags & NFT_CHAIN_BINDING)
 -			return -EOPNOTSUPP;
 -
 -		err = nft_chain_parse_hook(net, nla, &hook, family, extack,
 -					   true);
 +		err = nft_chain_parse_hook(net, nla, &hook, family, true);
  		if (err < 0)
  			return err;
  
@@@ -2011,13 -2243,21 +2012,15 @@@
  		if (err < 0) {
  			nft_chain_release_hook(&hook);
  			kfree(basechain);
 +			free_percpu(stats);
  			return err;
  		}
+ 		if (stats)
+ 			static_branch_inc(&nft_counters_enabled);
  	} else {
 -		if (flags & NFT_CHAIN_BASE)
 -			return -EINVAL;
 -		if (flags & NFT_CHAIN_HW_OFFLOAD)
 -			return -EOPNOTSUPP;
 -
 -		chain = kzalloc(sizeof(*chain), GFP_KERNEL_ACCOUNT);
 +		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
  		if (chain == NULL)
  			return -ENOMEM;
 -
 -		chain->flags = flags;
  	}
  	ctx->chain = chain;
  
@@@ -2061,13 -2315,18 +2064,22 @@@
  	if (nft_is_base_chain(chain))
  		nft_trans_chain_policy(trans) = policy;
  
++<<<<<<< HEAD
++=======
+ 	err = nft_chain_add(table, chain);
+ 	if (err < 0) {
+ 		nft_trans_destroy(trans);
+ 		goto err_unregister_hook;
+ 	}
+ 
++>>>>>>> 921ebde3c0d2 (netfilter: nf_tables: fix nft_counters_enabled underflow at nf_tables_addchain())
  	table->use++;
 +	list_add_tail_rcu(&chain->list, &table->chains);
  
  	return 0;
 -err_unregister_hook:
 +err2:
  	nf_tables_unregister_hook(net, table, chain);
 -err_destroy_chain:
 +err1:
  	nf_tables_chain_destroy(ctx);
  
  	return err;
* Unmerged path net/netfilter/nf_tables_api.c
