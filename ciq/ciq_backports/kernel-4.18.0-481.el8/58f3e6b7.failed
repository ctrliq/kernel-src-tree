x86/compressed/acpi: Move EFI system table lookup to helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Michael Roth <michael.roth@amd.com>
commit 58f3e6b71f42f99ab5d0ab26ddf6e7ee5631f5db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/58f3e6b7.failed

Future patches for SEV-SNP-validated CPUID will also require early
parsing of the EFI configuration. Incrementally move the related
code into a set of helpers that can be re-used for that purpose.

	Signed-off-by: Michael Roth <michael.roth@amd.com>
	Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/r/20220307213356.2797205-26-brijesh.singh@amd.com
(cherry picked from commit 58f3e6b71f42f99ab5d0ab26ddf6e7ee5631f5db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/acpi.c
#	arch/x86/boot/compressed/efi.c
#	arch/x86/boot/compressed/misc.h
diff --cc arch/x86/boot/compressed/acpi.c
index 15255f388a85,58a3d3f3e305..000000000000
--- a/arch/x86/boot/compressed/acpi.c
+++ b/arch/x86/boot/compressed/acpi.c
@@@ -143,36 -118,22 +143,46 @@@ static acpi_physical_address kexec_get_
  static acpi_physical_address efi_get_rsdp_addr(void)
  {
  #ifdef CONFIG_EFI
- 	unsigned long systab, config_tables;
+ 	unsigned long systab_pa, config_tables;
  	unsigned int nr_tables;
++<<<<<<< HEAD
 +	struct efi_info *ei;
++=======
+ 	enum efi_type et;
++>>>>>>> 58f3e6b71f42 (x86/compressed/acpi: Move EFI system table lookup to helper)
  	bool efi_64;
 +	char *sig;
 +
 +	ei = &boot_params->efi_info;
 +	sig = (char *)&ei->efi_loader_signature;
  
 -	et = efi_get_type(boot_params);
 -	if (et == EFI_TYPE_64)
 +	if (!strncmp(sig, EFI64_LOADER_SIGNATURE, 4)) {
  		efi_64 = true;
 -	else if (et == EFI_TYPE_32)
 +	} else if (!strncmp(sig, EFI32_LOADER_SIGNATURE, 4)) {
  		efi_64 = false;
 -	else
 +	} else {
 +		debug_putstr("Wrong EFI loader signature.\n");
  		return 0;
 +	}
  
++<<<<<<< HEAD
 +	/* Get systab from boot params. */
 +#ifdef CONFIG_X86_64
 +	systab = ei->efi_systab | ((__u64)ei->efi_systab_hi << 32);
 +#else
 +	if (ei->efi_systab_hi || ei->efi_memmap_hi) {
 +		debug_putstr("Error getting RSDP address: EFI system table located above 4GB.\n");
 +		return 0;
 +	}
 +	systab = ei->efi_systab;
 +#endif
 +	if (!systab)
 +		error("EFI system table not found.");
++=======
+ 	systab_pa = efi_get_system_table(boot_params);
+ 	if (!systab_pa)
+ 		error("EFI support advertised, but unable to locate system table.");
++>>>>>>> 58f3e6b71f42 (x86/compressed/acpi: Move EFI system table lookup to helper)
  
  	/* Handle EFI bitness properly */
  	if (efi_64) {
diff --cc arch/x86/boot/compressed/misc.h
index 5bf08eb0ecdc,b2acd3ac6525..000000000000
--- a/arch/x86/boot/compressed/misc.h
+++ b/arch/x86/boot/compressed/misc.h
@@@ -168,4 -176,26 +168,29 @@@ void boot_stage2_vc(void)
  
  unsigned long sev_verify_cbit(unsigned long cr3);
  
++<<<<<<< HEAD
++=======
+ enum efi_type {
+ 	EFI_TYPE_64,
+ 	EFI_TYPE_32,
+ 	EFI_TYPE_NONE,
+ };
+ 
+ #ifdef CONFIG_EFI
+ /* helpers for early EFI config table access */
+ enum efi_type efi_get_type(struct boot_params *bp);
+ unsigned long efi_get_system_table(struct boot_params *bp);
+ #else
+ static inline enum efi_type efi_get_type(struct boot_params *bp)
+ {
+ 	return EFI_TYPE_NONE;
+ }
+ 
+ static inline unsigned long efi_get_system_table(struct boot_params *bp)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_EFI */
+ 
++>>>>>>> 58f3e6b71f42 (x86/compressed/acpi: Move EFI system table lookup to helper)
  #endif /* BOOT_COMPRESSED_MISC_H */
* Unmerged path arch/x86/boot/compressed/efi.c
* Unmerged path arch/x86/boot/compressed/acpi.c
* Unmerged path arch/x86/boot/compressed/efi.c
* Unmerged path arch/x86/boot/compressed/misc.h
