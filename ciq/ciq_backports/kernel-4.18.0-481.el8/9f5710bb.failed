fs: allow cross-vfsmount reflink/dedupe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Josef Bacik <josef@toxicpanda.com>
commit 9f5710bbfd3031dd7ce244fa26fba896d35f5342
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/9f5710bb.failed

Currently we disallow reflink and dedupe if the two files aren't on the
same vfsmount.  However we really only need to disallow it if they're
not on the same super block.  It is very common for btrfs to have a main
subvolume that is mounted and then different subvolumes mounted at
different locations.  It's allowed to reflink between these volumes, but
the vfsmount check disallows this.  Instead fix dedupe to check for the
same superblock, and simply remove the vfsmount check for reflink as it
already does the superblock check.

	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Nikolay Borisov <nborisov@suse.com>
	Signed-off-by: Josef Bacik <josef@toxicpanda.com>
	Reviewed-by: David Sterba <dsterba@suse.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 9f5710bbfd3031dd7ce244fa26fba896d35f5342)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/remap_range.c
* Unmerged path fs/remap_range.c
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 273d949bdef4..c4e4e584a4c6 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -231,9 +231,6 @@ static long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,
 
 	if (!src_file.file)
 		return -EBADF;
-	ret = -EXDEV;
-	if (src_file.file->f_path.mnt != dst_file->f_path.mnt)
-		goto fdput;
 	cloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,
 				      olen, 0);
 	if (cloned < 0)
@@ -242,7 +239,6 @@ static long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,
 		ret = -EINVAL;
 	else
 		ret = 0;
-fdput:
 	fdput(src_file);
 	return ret;
 }
* Unmerged path fs/remap_range.c
