arm64: kdump: Support crashkernel=X fall back to reserve region above DMA zones

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Zhen Lei <thunder.leizhen@huawei.com>
commit a9ae89df737756d92f0e14873339cf393f7f7eb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/a9ae89df.failed

For crashkernel=X without '@offset', select a region within DMA zones
first, and fall back to reserve region above DMA zones. This allows
users to use the same configuration on multiple platforms.

	Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
	Acked-by: Baoquan He <bhe@redhat.com>
	Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
Link: https://lore.kernel.org/r/20221116121044.1690-3-thunder.leizhen@huawei.com
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit a9ae89df737756d92f0e14873339cf393f7f7eb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/kernel-parameters.txt
#	arch/arm64/mm/init.c
diff --cc Documentation/admin-guide/kernel-parameters.txt
index f1cd78b7b989,9d458dfbec5f..000000000000
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@@ -724,7 -831,7 +724,11 @@@
  			memory region [offset, offset + size] for that kernel
  			image. If '@offset' is omitted, then a suitable offset
  			is selected automatically.
++<<<<<<< HEAD
 +			[KNL, x86_64] select a region under 4G first, and
++=======
+ 			[KNL, X86-64, ARM64] Select a region under 4G first, and
++>>>>>>> a9ae89df7377 (arm64: kdump: Support crashkernel=X fall back to reserve region above DMA zones)
  			fall back to reserve region above 4G when '@offset'
  			hasn't been specified.
  			See Documentation/admin-guide/kdump/kdump.rst for further details.
diff --cc arch/arm64/mm/init.c
index 16152fb8191b,58a0bb2c17f1..000000000000
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@@ -125,7 -132,11 +125,8 @@@ static void __init reserve_crashkernel(
  	unsigned long long crash_max = CRASH_ADDR_LOW_MAX;
  	char *cmdline = boot_command_line;
  	int ret;
+ 	bool fixed_base = false;
  
 -	if (!IS_ENABLED(CONFIG_KEXEC_CORE))
 -		return;
 -
  	/* crashkernel=X[@offset] */
  	ret = parse_crashkernel(cmdline, memblock_phys_mem_size(),
  				&crash_size, &crash_base);
@@@ -151,13 -164,26 +152,32 @@@
  	crash_size = PAGE_ALIGN(crash_size);
  
  	/* User specifies base address explicitly. */
- 	if (crash_base)
+ 	if (crash_base) {
+ 		fixed_base = true;
  		crash_max = crash_base + crash_size;
+ 	}
  
++<<<<<<< HEAD
 +	crash_base = memblock_alloc_range_nid(crash_size, CRASH_ALIGN,
 +					crash_base, crash_max,
 +					NUMA_NO_NODE, MEMBLOCK_NONE);
++=======
+ retry:
+ 	crash_base = memblock_phys_alloc_range(crash_size, CRASH_ALIGN,
+ 					       crash_base, crash_max);
++>>>>>>> a9ae89df7377 (arm64: kdump: Support crashkernel=X fall back to reserve region above DMA zones)
  	if (!crash_base) {
+ 		/*
+ 		 * If the first attempt was for low memory, fall back to
+ 		 * high memory, the minimum required low memory will be
+ 		 * reserved later.
+ 		 */
+ 		if (!fixed_base && (crash_max == CRASH_ADDR_LOW_MAX)) {
+ 			crash_max = CRASH_ADDR_HIGH_MAX;
+ 			crash_low_size = DEFAULT_CRASH_KERNEL_LOW_SIZE;
+ 			goto retry;
+ 		}
+ 
  		pr_warn("cannot allocate crashkernel (size:0x%llx)\n",
  			crash_size);
  		return;
* Unmerged path Documentation/admin-guide/kernel-parameters.txt
* Unmerged path arch/arm64/mm/init.c
