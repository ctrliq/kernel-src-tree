netfilter: nf_tables: NFTA_SET_ELEM_KEY_END requires concat and interval flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 88cccd908d51397f9754f89a937cd13fa59dee37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/88cccd90.failed

If the NFT_SET_CONCAT|NFT_SET_INTERVAL flags are set on, then the
netlink attribute NFTA_SET_ELEM_KEY_END must be specified. Otherwise,
NFTA_SET_ELEM_KEY_END should not be present.

For catch-all element, NFTA_SET_ELEM_KEY_END should not be present.
The NFT_SET_ELEM_INTERVAL_END is never used with this set flags
combination.

Fixes: 7b225d0b5c6d ("netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 88cccd908d51397f9754f89a937cd13fa59dee37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 86f330aa668c,1d14d694f654..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -5178,6 -5658,210 +5178,213 @@@ err_elem_expr_setup
  	return -ENOMEM;
  }
  
++<<<<<<< HEAD
++=======
+ struct nft_set_ext *nft_set_catchall_lookup(const struct net *net,
+ 					    const struct nft_set *set)
+ {
+ 	struct nft_set_elem_catchall *catchall;
+ 	u8 genmask = nft_genmask_cur(net);
+ 	struct nft_set_ext *ext;
+ 
+ 	list_for_each_entry_rcu(catchall, &set->catchall_list, list) {
+ 		ext = nft_set_elem_ext(set, catchall->elem);
+ 		if (nft_set_elem_active(ext, genmask) &&
+ 		    !nft_set_elem_expired(ext))
+ 			return ext;
+ 	}
+ 
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(nft_set_catchall_lookup);
+ 
+ void *nft_set_catchall_gc(const struct nft_set *set)
+ {
+ 	struct nft_set_elem_catchall *catchall, *next;
+ 	struct nft_set_ext *ext;
+ 	void *elem = NULL;
+ 
+ 	list_for_each_entry_safe(catchall, next, &set->catchall_list, list) {
+ 		ext = nft_set_elem_ext(set, catchall->elem);
+ 
+ 		if (!nft_set_elem_expired(ext) ||
+ 		    nft_set_elem_mark_busy(ext))
+ 			continue;
+ 
+ 		elem = catchall->elem;
+ 		list_del_rcu(&catchall->list);
+ 		kfree_rcu(catchall, rcu);
+ 		break;
+ 	}
+ 
+ 	return elem;
+ }
+ EXPORT_SYMBOL_GPL(nft_set_catchall_gc);
+ 
+ static int nft_setelem_catchall_insert(const struct net *net,
+ 				       struct nft_set *set,
+ 				       const struct nft_set_elem *elem,
+ 				       struct nft_set_ext **pext)
+ {
+ 	struct nft_set_elem_catchall *catchall;
+ 	u8 genmask = nft_genmask_next(net);
+ 	struct nft_set_ext *ext;
+ 
+ 	list_for_each_entry(catchall, &set->catchall_list, list) {
+ 		ext = nft_set_elem_ext(set, catchall->elem);
+ 		if (nft_set_elem_active(ext, genmask)) {
+ 			*pext = ext;
+ 			return -EEXIST;
+ 		}
+ 	}
+ 
+ 	catchall = kmalloc(sizeof(*catchall), GFP_KERNEL);
+ 	if (!catchall)
+ 		return -ENOMEM;
+ 
+ 	catchall->elem = elem->priv;
+ 	list_add_tail_rcu(&catchall->list, &set->catchall_list);
+ 
+ 	return 0;
+ }
+ 
+ static int nft_setelem_insert(const struct net *net,
+ 			      struct nft_set *set,
+ 			      const struct nft_set_elem *elem,
+ 			      struct nft_set_ext **ext, unsigned int flags)
+ {
+ 	int ret;
+ 
+ 	if (flags & NFT_SET_ELEM_CATCHALL)
+ 		ret = nft_setelem_catchall_insert(net, set, elem, ext);
+ 	else
+ 		ret = set->ops->insert(net, set, elem, ext);
+ 
+ 	return ret;
+ }
+ 
+ static bool nft_setelem_is_catchall(const struct nft_set *set,
+ 				    const struct nft_set_elem *elem)
+ {
+ 	struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);
+ 
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&
+ 	    *nft_set_ext_flags(ext) & NFT_SET_ELEM_CATCHALL)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static void nft_setelem_activate(struct net *net, struct nft_set *set,
+ 				 struct nft_set_elem *elem)
+ {
+ 	struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);
+ 
+ 	if (nft_setelem_is_catchall(set, elem)) {
+ 		nft_set_elem_change_active(net, set, ext);
+ 		nft_set_elem_clear_busy(ext);
+ 	} else {
+ 		set->ops->activate(net, set, elem);
+ 	}
+ }
+ 
+ static int nft_setelem_catchall_deactivate(const struct net *net,
+ 					   struct nft_set *set,
+ 					   struct nft_set_elem *elem)
+ {
+ 	struct nft_set_elem_catchall *catchall;
+ 	struct nft_set_ext *ext;
+ 
+ 	list_for_each_entry(catchall, &set->catchall_list, list) {
+ 		ext = nft_set_elem_ext(set, catchall->elem);
+ 		if (!nft_is_active(net, ext) ||
+ 		    nft_set_elem_mark_busy(ext))
+ 			continue;
+ 
+ 		kfree(elem->priv);
+ 		elem->priv = catchall->elem;
+ 		nft_set_elem_change_active(net, set, ext);
+ 		return 0;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int __nft_setelem_deactivate(const struct net *net,
+ 				    struct nft_set *set,
+ 				    struct nft_set_elem *elem)
+ {
+ 	void *priv;
+ 
+ 	priv = set->ops->deactivate(net, set, elem);
+ 	if (!priv)
+ 		return -ENOENT;
+ 
+ 	kfree(elem->priv);
+ 	elem->priv = priv;
+ 	set->ndeact++;
+ 
+ 	return 0;
+ }
+ 
+ static int nft_setelem_deactivate(const struct net *net,
+ 				  struct nft_set *set,
+ 				  struct nft_set_elem *elem, u32 flags)
+ {
+ 	int ret;
+ 
+ 	if (flags & NFT_SET_ELEM_CATCHALL)
+ 		ret = nft_setelem_catchall_deactivate(net, set, elem);
+ 	else
+ 		ret = __nft_setelem_deactivate(net, set, elem);
+ 
+ 	return ret;
+ }
+ 
+ static void nft_setelem_catchall_remove(const struct net *net,
+ 					const struct nft_set *set,
+ 					const struct nft_set_elem *elem)
+ {
+ 	struct nft_set_elem_catchall *catchall, *next;
+ 
+ 	list_for_each_entry_safe(catchall, next, &set->catchall_list, list) {
+ 		if (catchall->elem == elem->priv) {
+ 			list_del_rcu(&catchall->list);
+ 			kfree_rcu(catchall, rcu);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static void nft_setelem_remove(const struct net *net,
+ 			       const struct nft_set *set,
+ 			       const struct nft_set_elem *elem)
+ {
+ 	if (nft_setelem_is_catchall(set, elem))
+ 		nft_setelem_catchall_remove(net, set, elem);
+ 	else
+ 		set->ops->remove(net, set, elem);
+ }
+ 
+ static bool nft_setelem_valid_key_end(const struct nft_set *set,
+ 				      struct nlattr **nla, u32 flags)
+ {
+ 	if ((set->flags & (NFT_SET_CONCAT | NFT_SET_INTERVAL)) ==
+ 			  (NFT_SET_CONCAT | NFT_SET_INTERVAL)) {
+ 		if (flags & NFT_SET_ELEM_INTERVAL_END)
+ 			return false;
+ 		if (!nla[NFTA_SET_ELEM_KEY_END] &&
+ 		    !(flags & NFT_SET_ELEM_CATCHALL))
+ 			return false;
+ 	} else {
+ 		if (nla[NFTA_SET_ELEM_KEY_END])
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 88cccd908d51 (netfilter: nf_tables: NFTA_SET_ELEM_KEY_END requires concat and interval flags)
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr, u32 nlmsg_flags)
  {
@@@ -5638,14 -6347,18 +5848,17 @@@ static int nft_del_setelem(struct nft_c
  	if (err < 0)
  		return err;
  
 -	err = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);
 -	if (err < 0)
 -		return err;
 -
 -	if (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))
 +	if (nla[NFTA_SET_ELEM_KEY] == NULL)
  		return -EINVAL;
  
+ 	if (!nft_setelem_valid_key_end(set, nla, flags))
+ 		return -EINVAL;
+ 
  	nft_set_ext_prepare(&tmpl);
  
 +	err = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);
 +	if (err < 0)
 +		return err;
  	if (flags != 0) {
  		err = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
  		if (err < 0)
* Unmerged path net/netfilter/nf_tables_api.c
