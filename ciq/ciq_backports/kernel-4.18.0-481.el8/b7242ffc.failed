net/mlx5: Make sure that no dangling IPsec FS pointers exist

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit b7242ffc562ccf26121c85beb58e9ad40157b6fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/b7242ffc.failed

The IPsec FS code was implemented with anti-pattern there failures
in create functions left the system with dangling pointers that were
cleaned in global routines.

The less error prone approach is to make sure that failed function
cleans everything internally.

As part of this change, we remove the batch of one liners and rewrite
get/put functions to remove ambiguity.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit b7242ffc562ccf26121c85beb58e9ad40157b6fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 16bbf5ba1ee4,9d95a0025fd6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@@ -583,64 -515,34 +519,83 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
 +static void rx_del_rule(struct mlx5e_priv *priv,
 +			struct mlx5_accel_esp_xfrm_attrs *attrs,
 +			struct mlx5e_ipsec_rule *ipsec_rule)
 +{
 +	mlx5_del_flow_rules(ipsec_rule->rule);
 +	ipsec_rule->rule = NULL;
 +
 +	mlx5_modify_header_dealloc(priv->mdev, ipsec_rule->set_modify_hdr);
 +	ipsec_rule->set_modify_hdr = NULL;
 +
 +	rx_ft_put(priv, attrs->is_ipv6 ? ACCEL_FS_ESP6 : ACCEL_FS_ESP4);
 +}
 +
 +static void tx_del_rule(struct mlx5e_priv *priv,
 +			struct mlx5e_ipsec_rule *ipsec_rule)
 +{
 +	mlx5_del_flow_rules(ipsec_rule->rule);
 +	ipsec_rule->rule = NULL;
 +
 +	tx_ft_put(priv);
 +}
 +
++=======
++>>>>>>> b7242ffc562c (net/mlx5: Make sure that no dangling IPsec FS pointers exist)
  int mlx5e_accel_ipsec_fs_add_rule(struct mlx5e_priv *priv,
 -				  struct mlx5e_ipsec_sa_entry *sa_entry)
 +				  struct mlx5_accel_esp_xfrm_attrs *attrs,
 +				  u32 ipsec_obj_id,
 +				  struct mlx5e_ipsec_rule *ipsec_rule)
  {
 -	if (sa_entry->attrs.action == MLX5_ACCEL_ESP_ACTION_ENCRYPT)
 -		return tx_add_rule(priv, sa_entry);
 +	if (!priv->ipsec->rx_fs)
 +		return -EOPNOTSUPP;
  
 -	return rx_add_rule(priv, sa_entry);
 +	if (attrs->action == MLX5_ACCEL_ESP_ACTION_DECRYPT)
 +		return rx_add_rule(priv, attrs, ipsec_obj_id, ipsec_rule);
 +	else
 +		return tx_add_rule(priv, attrs, ipsec_obj_id, ipsec_rule);
  }
  
  void mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_priv *priv,
 -				   struct mlx5e_ipsec_sa_entry *sa_entry)
 +			     struct mlx5_accel_esp_xfrm_attrs *attrs,
 +			     struct mlx5e_ipsec_rule *ipsec_rule)
  {
++<<<<<<< HEAD
 +	if (!priv->ipsec->rx_fs)
++=======
+ 	struct mlx5e_ipsec_rule *ipsec_rule = &sa_entry->ipsec_rule;
+ 	struct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);
+ 
+ 	mlx5_del_flow_rules(ipsec_rule->rule);
+ 
+ 	if (sa_entry->attrs.action == MLX5_ACCEL_ESP_ACTION_ENCRYPT) {
+ 		tx_ft_put(priv);
++>>>>>>> b7242ffc562c (net/mlx5: Make sure that no dangling IPsec FS pointers exist)
  		return;
 -	}
  
++<<<<<<< HEAD
 +	if (attrs->action == MLX5_ACCEL_ESP_ACTION_DECRYPT)
 +		rx_del_rule(priv, attrs, ipsec_rule);
 +	else
 +		tx_del_rule(priv, ipsec_rule);
++=======
+ 	mlx5_modify_header_dealloc(mdev, ipsec_rule->set_modify_hdr);
+ 	rx_ft_put(priv,
+ 		  sa_entry->attrs.is_ipv6 ? ACCEL_FS_ESP6 : ACCEL_FS_ESP4);
++>>>>>>> b7242ffc562c (net/mlx5: Make sure that no dangling IPsec FS pointers exist)
  }
  
 -void mlx5e_accel_ipsec_fs_cleanup(struct mlx5e_ipsec *ipsec)
 +static void fs_cleanup_tx(struct mlx5e_priv *priv)
 +{
 +	mutex_destroy(&priv->ipsec->tx_fs->mutex);
 +	WARN_ON(priv->ipsec->tx_fs->refcnt);
 +	kfree(priv->ipsec->tx_fs);
 +	priv->ipsec->tx_fs = NULL;
 +}
 +
 +static void fs_cleanup_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5e_accel_fs_esp_prot *fs_prot;
  	struct mlx5e_accel_fs_esp *accel_esp;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
