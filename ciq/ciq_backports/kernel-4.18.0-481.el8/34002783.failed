netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 3400278328285a8c2f121904496aff5e7b610a01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/34002783.failed

The generation ID is bumped from the commit path while holding the
mutex, however, netlink dump operations rely on RCU.

This patch also adds missing cb->base_eq initialization in
nf_tables_dump_set().

Fixes: 38e029f14a97 ("netfilter: nf_tables: set NLM_F_DUMP_INTR if netlink dumping is stale")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 3400278328285a8c2f121904496aff5e7b610a01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index a774b76587b9,8b084cd669ab..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -783,9 -888,10 +783,14 @@@ static int nf_tables_dump_tables(struc
  	int family = nfmsg->nfgen_family;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cb->seq = net->nft.base_seq;
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  
 -	list_for_each_entry_rcu(table, &nft_net->tables, list) {
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (family != NFPROTO_UNSPEC && family != table->family)
  			continue;
  
@@@ -1516,11 -1699,15 +1521,16 @@@ static int nf_tables_dump_chains(struc
  	unsigned int idx = 0, s_idx = cb->args[0];
  	struct net *net = sock_net(skb->sk);
  	int family = nfmsg->nfgen_family;
 -	struct nftables_pernet *nft_net;
 -	const struct nft_table *table;
 -	const struct nft_chain *chain;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cb->seq = net->nft.base_seq;
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  
 -	list_for_each_entry_rcu(table, &nft_net->tables, list) {
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (family != NFPROTO_UNSPEC && family != table->family)
  			continue;
  
@@@ -2828,11 -3145,13 +2838,16 @@@ static int nf_tables_dump_rules(struct 
  	unsigned int idx = 0;
  	struct net *net = sock_net(skb->sk);
  	int family = nfmsg->nfgen_family;
 -	struct nftables_pernet *nft_net;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cb->seq = net->nft.base_seq;
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  
 -	list_for_each_entry_rcu(table, &nft_net->tables, list) {
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (family != NFPROTO_UNSPEC && family != table->family)
  			continue;
  
@@@ -3828,9 -4132,10 +3843,14 @@@ static int nf_tables_dump_sets(struct s
  		return skb->len;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cb->seq = net->nft.base_seq;
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  
 -	list_for_each_entry_rcu(table, &nft_net->tables, list) {
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (ctx->family != NFPROTO_UNSPEC &&
  		    ctx->family != table->family)
  			continue;
@@@ -4690,7 -5060,10 +4710,14 @@@ static int nf_tables_dump_set(struct sk
  	int event;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
+ 
+ 	list_for_each_entry_rcu(table, &nft_net->tables, list) {
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  		if (dump_ctx->ctx.family != NFPROTO_UNSPEC &&
  		    dump_ctx->ctx.family != table->family)
  			continue;
@@@ -6186,9 -6942,10 +6213,14 @@@ static int nf_tables_dump_obj(struct sk
  		reset = true;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cb->seq = net->nft.base_seq;
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  
 -	list_for_each_entry_rcu(table, &nft_net->tables, list) {
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (family != NFPROTO_UNSPEC && family != table->family)
  			continue;
  
@@@ -6935,9 -7873,11 +6967,14 @@@ static int nf_tables_dump_flowtable(str
  	const struct nft_table *table;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cb->seq = net->nft.base_seq;
++=======
+ 	nft_net = nft_pernet(net);
+ 	cb->seq = READ_ONCE(nft_net->base_seq);
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
  
 -	list_for_each_entry_rcu(table, &nft_net->tables, list) {
 +	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (family != NFPROTO_UNSPEC && family != table->family)
  			continue;
  
@@@ -7828,7 -8858,11 +7866,15 @@@ static int nf_tables_commit(struct net 
  	 * Bump generation counter, invalidate any dump in progress.
  	 * Cannot fail after this point.
  	 */
++<<<<<<< HEAD
 +	while (++net->nft.base_seq == 0);
++=======
+ 	base_seq = READ_ONCE(nft_net->base_seq);
+ 	while (++base_seq == 0)
+ 		;
++>>>>>>> 340027832828 (netfilter: nf_tables: use READ_ONCE and WRITE_ONCE for shared generation id access)
+ 
+ 	WRITE_ONCE(nft_net->base_seq, base_seq);
  
  	/* step 3. Start new generation, rules_gen_X now in use. */
  	net->nft.gencursor = nft_gencursor_next(net);
* Unmerged path net/netfilter/nf_tables_api.c
