net/mlx5: Remove devl_unlock from mlx5_devlink_eswitch_mode_set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Moshe Shemesh <moshe@nvidia.com>
commit 973598d46ede27bb3b2a54ff45135196aeb9efb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/973598d4.failed

The callback mlx5_devlink_eswitch_mode_set() had unlocked devlink as a
temporary workaround once devlink instance lock was added to devlink
eswitch callbacks. Now that all flows triggered by this function
that took devlink lock are using devl_ API and all parallel paths are
locked we can remove this workaround.

	Signed-off-by: Moshe Shemesh <moshe@nvidia.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 973598d46ede27bb3b2a54ff45135196aeb9efb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index aaa5e6840908,d3da52e3fc67..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -2171,9 -2179,8 +2171,14 @@@ static int esw_offloads_start(struct ml
  {
  	int err, err1;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_locked(esw, false);
 +	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_OFFLOADS,
 +					 esw->dev->priv.sriov.num_vfs);
++=======
+ 	esw->mode = MLX5_ESWITCH_OFFLOADS;
+ 	err = mlx5_eswitch_enable_locked(esw, esw->dev->priv.sriov.num_vfs);
++>>>>>>> 973598d46ede (net/mlx5: Remove devl_unlock from mlx5_devlink_eswitch_mode_set)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack,
  				   "Failed setting eswitch to offloads");
@@@ -3225,13 -3242,12 +3230,18 @@@ static int esw_offloads_stop(struct mlx
  {
  	int err, err1;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_locked(esw, false);
 +	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_LEGACY,
 +					 MLX5_ESWITCH_IGNORE_NUM_VFS);
++=======
+ 	esw->mode = MLX5_ESWITCH_LEGACY;
+ 	err = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_IGNORE_NUM_VFS);
++>>>>>>> 973598d46ede (net/mlx5: Remove devl_unlock from mlx5_devlink_eswitch_mode_set)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack, "Failed setting eswitch to legacy");
 -		esw->mode = MLX5_ESWITCH_OFFLOADS;
 -		err1 = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_IGNORE_NUM_VFS);
 +		err1 = mlx5_eswitch_enable_locked(esw, MLX5_ESWITCH_OFFLOADS,
 +						  MLX5_ESWITCH_IGNORE_NUM_VFS);
  		if (err1) {
  			NL_SET_ERR_MSG_MOD(extack,
  					   "Failed setting eswitch back to offloads");
@@@ -3395,6 -3372,7 +3396,10 @@@ int mlx5_devlink_eswitch_mode_set(struc
  	if (cur_mlx5_mode == mlx5_mode)
  		goto unlock;
  
++<<<<<<< HEAD
++=======
+ 	mlx5_eswitch_disable_locked(esw);
++>>>>>>> 973598d46ede (net/mlx5: Remove devl_unlock from mlx5_devlink_eswitch_mode_set)
  	if (mode == DEVLINK_ESWITCH_MODE_SWITCHDEV) {
  		if (mlx5_devlink_trap_get_num_active(esw->dev)) {
  			NL_SET_ERR_MSG_MOD(extack,
@@@ -3405,6 -3383,7 +3410,10 @@@
  		err = esw_offloads_start(esw, extack);
  	} else if (mode == DEVLINK_ESWITCH_MODE_LEGACY) {
  		err = esw_offloads_stop(esw, extack);
++<<<<<<< HEAD
++=======
+ 		mlx5_rescan_drivers(esw->dev);
++>>>>>>> 973598d46ede (net/mlx5: Remove devl_unlock from mlx5_devlink_eswitch_mode_set)
  	} else {
  		err = -EINVAL;
  	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
