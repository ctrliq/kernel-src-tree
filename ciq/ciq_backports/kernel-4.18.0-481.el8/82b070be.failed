driver core: Introduce device_find_any_child() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 82b070beae1ef55b0049768c8dc91d87565bb191
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/82b070be.failed

There are several places in the kernel where this kind of functionality is
being used. Provide a generic helper for such cases.

	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Link: https://lore.kernel.org/r/20220610120219.18988-1-andriy.shevchenko@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 82b070beae1ef55b0049768c8dc91d87565bb191)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/device.h
diff --cc include/linux/device.h
index 54b62ad9795f,424b55df0272..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1582,27 -892,28 +1582,52 @@@ static inline bool dev_removable_is_val
  /*
   * High level routines for use by the bus drivers
   */
++<<<<<<< HEAD
 +extern int __must_check device_register(struct device *dev);
 +extern void device_unregister(struct device *dev);
 +extern void device_initialize(struct device *dev);
 +extern int __must_check device_add(struct device *dev);
 +extern void device_del(struct device *dev);
 +extern int device_for_each_child(struct device *dev, void *data,
 +		     int (*fn)(struct device *dev, void *data));
 +extern int device_for_each_child_reverse(struct device *dev, void *data,
 +		     int (*fn)(struct device *dev, void *data));
 +extern struct device *device_find_child(struct device *dev, void *data,
 +				int (*match)(struct device *dev, void *data));
 +extern struct device *device_find_child_by_name(struct device *parent,
 +						const char *name);
 +extern int device_rename(struct device *dev, const char *new_name);
 +extern int device_move(struct device *dev, struct device *new_parent,
 +		       enum dpm_order dpm_order);
 +extern int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);
 +extern const char *device_get_devnode(struct device *dev,
 +				      umode_t *mode, kuid_t *uid, kgid_t *gid,
 +				      const char **tmp);
 +extern int device_is_dependent(struct device *dev, void *target);
++=======
+ int __must_check device_register(struct device *dev);
+ void device_unregister(struct device *dev);
+ void device_initialize(struct device *dev);
+ int __must_check device_add(struct device *dev);
+ void device_del(struct device *dev);
+ int device_for_each_child(struct device *dev, void *data,
+ 			  int (*fn)(struct device *dev, void *data));
+ int device_for_each_child_reverse(struct device *dev, void *data,
+ 				  int (*fn)(struct device *dev, void *data));
+ struct device *device_find_child(struct device *dev, void *data,
+ 				 int (*match)(struct device *dev, void *data));
+ struct device *device_find_child_by_name(struct device *parent,
+ 					 const char *name);
+ struct device *device_find_any_child(struct device *parent);
+ 
+ int device_rename(struct device *dev, const char *new_name);
+ int device_move(struct device *dev, struct device *new_parent,
+ 		enum dpm_order dpm_order);
+ int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);
+ const char *device_get_devnode(struct device *dev, umode_t *mode, kuid_t *uid,
+ 			       kgid_t *gid, const char **tmp);
+ int device_is_dependent(struct device *dev, void *target);
++>>>>>>> 82b070beae1e (driver core: Introduce device_find_any_child() helper)
  
  static inline bool device_supports_offline(struct device *dev)
  {
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 377ebe779f17..16f75ec04502 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3789,6 +3789,26 @@ struct device *device_find_child_by_name(struct device *parent,
 }
 EXPORT_SYMBOL_GPL(device_find_child_by_name);
 
+static int match_any(struct device *dev, void *unused)
+{
+	return 1;
+}
+
+/**
+ * device_find_any_child - device iterator for locating a child device, if any.
+ * @parent: parent struct device
+ *
+ * This is similar to the device_find_child() function above, but it
+ * returns a reference to a child device, if any.
+ *
+ * NOTE: you will need to drop the reference with put_device() after use.
+ */
+struct device *device_find_any_child(struct device *parent)
+{
+	return device_find_child(parent, NULL, match_any);
+}
+EXPORT_SYMBOL_GPL(device_find_any_child);
+
 int __init devices_init(void)
 {
 	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
* Unmerged path include/linux/device.h
