net/mlx5: Delete metadata handling logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-481.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit df439fcb1cd4fe8e8b1c4065db4ef1b544aa5d9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-481.el8/df439fcb.failed

Remove specific to FPGS IPsec metadata handling logic which is not
required for mlx5 NICs devices.

Link: https://lore.kernel.org/r/fe67a1de4fc6032a940e18c8a6461a1ccf902fc4.1649232994.git.leonro@nvidia.com
	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
(cherry picked from commit df439fcb1cd4fe8e8b1c4065db4ef1b544aa5d9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
index 3da03dc2f713,28e0500d4a48..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
@@@ -363,7 -267,6 +267,10 @@@ bool mlx5e_ipsec_handle_tx_skb(struct n
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct xfrm_offload *xo = xfrm_offload(skb);
  	struct mlx5e_ipsec_sa_entry *sa_entry;
++<<<<<<< HEAD
 +	struct mlx5e_ipsec_metadata *mdata = NULL;
++=======
++>>>>>>> df439fcb1cd4 (net/mlx5: Delete metadata handling logic)
  	struct xfrm_state *x;
  	struct sec_path *sp;
  
@@@ -414,77 -306,6 +310,80 @@@ drop
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline struct xfrm_state *
 +mlx5e_ipsec_build_sp(struct net_device *netdev, struct sk_buff *skb,
 +		     struct mlx5e_ipsec_metadata *mdata)
 +{
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
 +	struct xfrm_offload *xo;
 +	struct xfrm_state *xs;
 +	u32 sa_handle;
 +
 +	skb->sp = secpath_dup(skb->sp);
 +	if (unlikely(!skb->sp)) {
 +		atomic64_inc(&priv->ipsec->sw_stats.ipsec_rx_drop_sp_alloc);
 +		return NULL;
 +	}
 +
 +	sa_handle = be32_to_cpu(mdata->content.rx.sa_handle);
 +	xs = mlx5e_ipsec_sadb_rx_lookup(priv->ipsec, sa_handle);
 +	if (unlikely(!xs)) {
 +		atomic64_inc(&priv->ipsec->sw_stats.ipsec_rx_drop_sadb_miss);
 +		return NULL;
 +	}
 +
 +	skb->sp->xvec[skb->sp->len++] = xs;
 +	skb->sp->olen++;
 +
 +	xo = xfrm_offload(skb);
 +	xo->flags = CRYPTO_DONE;
 +	switch (mdata->syndrome) {
 +	case MLX5E_IPSEC_RX_SYNDROME_DECRYPTED:
 +		xo->status = CRYPTO_SUCCESS;
 +		if (likely(priv->ipsec->no_trailer)) {
 +			xo->flags |= XFRM_ESP_NO_TRAILER;
 +			xo->proto = mdata->content.rx.nexthdr;
 +		}
 +		break;
 +	case MLX5E_IPSEC_RX_SYNDROME_AUTH_FAILED:
 +		xo->status = CRYPTO_TUNNEL_ESP_AUTH_FAILED;
 +		break;
 +	case MLX5E_IPSEC_RX_SYNDROME_BAD_PROTO:
 +		xo->status = CRYPTO_INVALID_PROTOCOL;
 +		break;
 +	default:
 +		atomic64_inc(&priv->ipsec->sw_stats.ipsec_rx_drop_syndrome);
 +		return NULL;
 +	}
 +	return xs;
 +}
 +
 +struct sk_buff *mlx5e_ipsec_handle_rx_skb(struct net_device *netdev,
 +					  struct sk_buff *skb, u32 *cqe_bcnt)
 +{
 +	struct mlx5e_ipsec_metadata *mdata;
 +	struct xfrm_state *xs;
 +
 +	if (!is_metadata_hdr_valid(skb))
 +		return skb;
 +
 +	/* Use the metadata */
 +	mdata = (struct mlx5e_ipsec_metadata *)(skb->data + ETH_HLEN);
 +	xs = mlx5e_ipsec_build_sp(netdev, skb, mdata);
 +	if (unlikely(!xs)) {
 +		kfree_skb(skb);
 +		return NULL;
 +	}
 +
 +	remove_metadata_hdr(skb);
 +	*cqe_bcnt -= MLX5E_METADATA_ETHER_LEN;
 +
 +	return skb;
 +}
 +
++=======
++>>>>>>> df439fcb1cd4 (net/mlx5: Delete metadata handling logic)
  enum {
  	MLX5E_IPSEC_OFFLOAD_RX_SYNDROME_DECRYPTED,
  	MLX5E_IPSEC_OFFLOAD_RX_SYNDROME_AUTH_FAILED,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/accel/accel.h b/drivers/net/ethernet/mellanox/mlx5/core/accel/accel.h
deleted file mode 100644
index 82b185121edb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/accel/accel.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef __MLX5E_ACCEL_H__
-#define __MLX5E_ACCEL_H__
-
-#ifdef CONFIG_MLX5_ACCEL
-
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-
-static inline bool is_metadata_hdr_valid(struct sk_buff *skb)
-{
-	__be16 *ethtype;
-
-	if (unlikely(skb->len < ETH_HLEN + MLX5E_METADATA_ETHER_LEN))
-		return false;
-	ethtype = (__be16 *)(skb->data + ETH_ALEN * 2);
-	if (*ethtype != cpu_to_be16(MLX5E_METADATA_ETHER_TYPE))
-		return false;
-	return true;
-}
-
-static inline void remove_metadata_hdr(struct sk_buff *skb)
-{
-	struct ethhdr *old_eth;
-	struct ethhdr *new_eth;
-
-	/* Remove the metadata from the buffer */
-	old_eth = (struct ethhdr *)skb->data;
-	new_eth = (struct ethhdr *)(skb->data + MLX5E_METADATA_ETHER_LEN);
-	memmove(new_eth, old_eth, 2 * ETH_ALEN);
-	/* Ethertype is already in its new place */
-	skb_pull_inline(skb, MLX5E_METADATA_ETHER_LEN);
-}
-
-#endif /* CONFIG_MLX5_ACCEL */
-
-#endif /* __MLX5E_EN_ACCEL_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
index 6164c7f59efb..282d3abab8c5 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
@@ -116,7 +116,6 @@ struct mlx5e_ipsec_sa_entry {
 	struct mlx5e_ipsec_rule ipsec_rule;
 };
 
-void mlx5e_ipsec_build_inverse_table(void);
 int mlx5e_ipsec_init(struct mlx5e_priv *priv);
 void mlx5e_ipsec_cleanup(struct mlx5e_priv *priv);
 void mlx5e_ipsec_build_netdev(struct mlx5e_priv *priv);
@@ -125,11 +124,6 @@ struct xfrm_state *mlx5e_ipsec_sadb_rx_lookup(struct mlx5e_ipsec *dev,
 					      unsigned int handle);
 
 #else
-
-static inline void mlx5e_ipsec_build_inverse_table(void)
-{
-}
-
 static inline int mlx5e_ipsec_init(struct mlx5e_priv *priv)
 {
 	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.h b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.h
index 428881e0adcb..0ae4e12ce528 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.h
@@ -53,9 +53,6 @@ struct mlx5e_accel_tx_ipsec_state {
 
 #ifdef CONFIG_MLX5_EN_IPSEC
 
-struct sk_buff *mlx5e_ipsec_handle_rx_skb(struct net_device *netdev,
-					  struct sk_buff *skb, u32 *cqe_bcnt);
-
 void mlx5e_ipsec_inverse_table_init(void);
 void mlx5e_ipsec_set_iv_esn(struct sk_buff *skb, struct xfrm_state *x,
 			    struct xfrm_offload *xo);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 22f111312bee..da8eb0905274 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -5727,7 +5727,6 @@ int mlx5e_init(void)
 {
 	int ret;
 
-	mlx5e_ipsec_build_inverse_table();
 	mlx5e_build_ptys2ethtool_map();
 	ret = auxiliary_driver_register(&mlx5e_driver);
 	if (ret)
