x86/process: Move the buffer clearing before MONITOR

jira KERNEL-101
cve CVE-2024-36350
cve CVE-2024-36357
Rebuild_History Non-Buildable kernel-5.14.0-611.5.1.el9_7
commit-author Borislav Petkov (AMD) <bp@alien8.de>
commit 8e786a85c0a3c0fffae6244733fb576eeabd9dec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.5.1.el9_7/8e786a85.failed

Move the VERW clearing before the MONITOR so that VERW doesn't disarm it
and the machine never enters C1.

Original idea by Kim Phillips <kim.phillips@amd.com>.

	Suggested-by: Andrew Cooper <andrew.cooper3@citrix.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
(cherry picked from commit 8e786a85c0a3c0fffae6244733fb576eeabd9dec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mwait.h
#	arch/x86/kernel/process.c
diff --cc arch/x86/include/asm/mwait.h
index 6c3a6a00da9c,6ca6516c7492..000000000000
--- a/arch/x86/include/asm/mwait.h
+++ b/arch/x86/include/asm/mwait.h
@@@ -44,8 -43,6 +44,11 @@@ static __always_inline void __monitorx(
  
  static __always_inline void __mwait(u32 eax, u32 ecx)
  {
++<<<<<<< HEAD
 +	mds_idle_clear_cpu_buffers();
 +
++=======
++>>>>>>> 8e786a85c0a3 (x86/process: Move the buffer clearing before MONITOR)
  	/*
  	 * Use the instruction mnemonic with implicit operands, as the LLVM
  	 * assembler fails to assemble the mnemonic with explicit operands:
@@@ -99,7 -96,6 +102,10 @@@ static __always_inline void __mwaitx(u3
   */
  static __always_inline void __sti_mwait(u32 eax, u32 ecx)
  {
++<<<<<<< HEAD
 +	mds_idle_clear_cpu_buffers();
++=======
++>>>>>>> 8e786a85c0a3 (x86/process: Move the buffer clearing before MONITOR)
  
  	asm volatile("sti; mwait" :: "a" (eax), "c" (ecx));
  }
@@@ -114,42 -110,31 +120,50 @@@
   * New with Core Duo processors, MWAIT can take some hints based on CPU
   * capability.
   */
 -static __always_inline void mwait_idle_with_hints(u32 eax, u32 ecx)
 +static __always_inline void mwait_idle_with_hints(unsigned long eax, unsigned long ecx)
  {
+ 	if (need_resched())
+ 		return;
+ 
+ 	x86_idle_clear_cpu_buffers();
+ 
  	if (static_cpu_has_bug(X86_BUG_MONITOR) || !current_set_polling_and_test()) {
 -		const void *addr = &current_thread_info()->flags;
 +		bool ibrs_disabled = false;
 +		u64 spec_ctrl;
 +
 +		if (static_cpu_has_bug(X86_BUG_CLFLUSH_MONITOR)) {
 +			mb();
 +			clflush((void *)&current_thread_info()->flags);
 +			mb();
 +		}
  
 -		alternative_input("", "clflush (%[addr])", X86_BUG_CLFLUSH_MONITOR, [addr] "a" (addr));
 -		__monitor(addr, 0, 0);
 +		if (irqs_disabled() && (ecx & 1) &&
 +		    cpu_feature_enabled(X86_FEATURE_KERNEL_IBRS)) {
 +			/* NMI always enable IBRS on exception entry */
 +			ibrs_disabled = true;
 +			spec_ctrl = spec_ctrl_current();
 +			__this_cpu_write(x86_spec_ctrl_current, 0);
 +			native_wrmsrl(MSR_IA32_SPEC_CTRL, 0);
 +		}
 +
 +		__monitor((void *)&current_thread_info()->flags, 0, 0);
  
- 		if (!need_resched()) {
- 			if (ecx & 1) {
- 				__mwait(eax, ecx);
- 			} else {
- 				__sti_mwait(eax, ecx);
- 				raw_local_irq_disable();
- 			}
+ 		if (need_resched())
+ 			goto out;
+ 
+ 		if (ecx & 1) {
+ 			__mwait(eax, ecx);
+ 		} else {
+ 			__sti_mwait(eax, ecx);
+ 			raw_local_irq_disable();
  		}
 +		if (ibrs_disabled) {
 +			native_wrmsrl(MSR_IA32_SPEC_CTRL, spec_ctrl);
 +			__this_cpu_write(x86_spec_ctrl_current, spec_ctrl);
 +		}
  	}
+ 
+ out:
  	current_clr_polling();
  }
  
diff --cc arch/x86/kernel/process.c
index d253089e7dcb,a838be04f874..000000000000
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@@ -897,19 -907,24 +897,36 @@@ static int prefer_mwait_c1_over_halt(co
   */
  static __cpuidle void mwait_idle(void)
  {
+ 	if (need_resched())
+ 		return;
+ 
+ 	x86_idle_clear_cpu_buffers();
+ 
  	if (!current_set_polling_and_test()) {
 -		const void *addr = &current_thread_info()->flags;
 +		if (this_cpu_has(X86_BUG_CLFLUSH_MONITOR)) {
 +			mb(); /* quirk */
 +			clflush((void *)&current_thread_info()->flags);
 +			mb(); /* quirk */
 +		}
  
++<<<<<<< HEAD
 +		__monitor((void *)&current_thread_info()->flags, 0, 0);
 +		if (!need_resched()) {
 +			__sti_mwait(0, 0);
 +			raw_local_irq_disable();
 +		}
++=======
+ 		alternative_input("", "clflush (%[addr])", X86_BUG_CLFLUSH_MONITOR, [addr] "a" (addr));
+ 		__monitor(addr, 0, 0);
+ 		if (need_resched())
+ 			goto out;
+ 
+ 		__sti_mwait(0, 0);
+ 		raw_local_irq_disable();
++>>>>>>> 8e786a85c0a3 (x86/process: Move the buffer clearing before MONITOR)
  	}
+ 
+ out:
  	__current_clr_polling();
  }
  
* Unmerged path arch/x86/include/asm/mwait.h
* Unmerged path arch/x86/kernel/process.c
