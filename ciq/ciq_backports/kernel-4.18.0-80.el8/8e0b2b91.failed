x86/speculation: Use ARCH_CAPABILITIES to skip L1D flush on vmentry

jira LE-1907
cve CVE-2018-3646
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 8e0b2b916662e09dd4d09e5271cdf214c6b80e62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/8e0b2b91.failed

Bit 3 of ARCH_CAPABILITIES tells a hypervisor that L1D flush on vmentry is
not needed.  Add a new value to enum vmx_l1d_flush_state, which is used
either if there is no L1TF bug at all, or if bit 3 is set in ARCH_CAPABILITIES.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 8e0b2b916662e09dd4d09e5271cdf214c6b80e62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/vmx.h
#	arch/x86/kernel/cpu/bugs.c
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/include/asm/vmx.h
index 6aa8499e1f62,95f9107449bf..000000000000
--- a/arch/x86/include/asm/vmx.h
+++ b/arch/x86/include/asm/vmx.h
@@@ -576,4 -576,15 +576,18 @@@ enum vm_instruction_error_number 
  	VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID = 28,
  };
  
++<<<<<<< HEAD
++=======
+ enum vmx_l1d_flush_state {
+ 	VMENTER_L1D_FLUSH_AUTO,
+ 	VMENTER_L1D_FLUSH_NEVER,
+ 	VMENTER_L1D_FLUSH_COND,
+ 	VMENTER_L1D_FLUSH_ALWAYS,
+ 	VMENTER_L1D_FLUSH_EPT_DISABLED,
+ 	VMENTER_L1D_FLUSH_NOT_REQUIRED,
+ };
+ 
+ extern enum vmx_l1d_flush_state l1tf_vmx_mitigation;
+ 
++>>>>>>> 8e0b2b916662 (x86/speculation: Use ARCH_CAPABILITIES to skip L1D flush on vmentry)
  #endif
diff --cc arch/x86/kernel/cpu/bugs.c
index 017ae8349019,86f4549b7c9f..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -691,6 -746,40 +691,43 @@@ static void __init l1tf_select_mitigati
  
  #ifdef CONFIG_SYSFS
  
++<<<<<<< HEAD
++=======
+ #define L1TF_DEFAULT_MSG "Mitigation: PTE Inversion"
+ 
+ #if IS_ENABLED(CONFIG_KVM_INTEL)
+ static const char *l1tf_vmx_states[] = {
+ 	[VMENTER_L1D_FLUSH_AUTO]		= "auto",
+ 	[VMENTER_L1D_FLUSH_NEVER]		= "vulnerable",
+ 	[VMENTER_L1D_FLUSH_COND]		= "conditional cache flushes",
+ 	[VMENTER_L1D_FLUSH_ALWAYS]		= "cache flushes",
+ 	[VMENTER_L1D_FLUSH_EPT_DISABLED]	= "EPT disabled",
+ 	[VMENTER_L1D_FLUSH_NOT_REQUIRED]	= "flush not necessary"
+ };
+ 
+ static ssize_t l1tf_show_state(char *buf)
+ {
+ 	if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO)
+ 		return sprintf(buf, "%s\n", L1TF_DEFAULT_MSG);
+ 
+ 	if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_EPT_DISABLED ||
+ 	    (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER &&
+ 	     cpu_smt_control == CPU_SMT_ENABLED))
+ 		return sprintf(buf, "%s; VMX: %s\n", L1TF_DEFAULT_MSG,
+ 			       l1tf_vmx_states[l1tf_vmx_mitigation]);
+ 
+ 	return sprintf(buf, "%s; VMX: %s, SMT %s\n", L1TF_DEFAULT_MSG,
+ 		       l1tf_vmx_states[l1tf_vmx_mitigation],
+ 		       cpu_smt_control == CPU_SMT_ENABLED ? "vulnerable" : "disabled");
+ }
+ #else
+ static ssize_t l1tf_show_state(char *buf)
+ {
+ 	return sprintf(buf, "%s\n", L1TF_DEFAULT_MSG);
+ }
+ #endif
+ 
++>>>>>>> 8e0b2b916662 (x86/speculation: Use ARCH_CAPABILITIES to skip L1D flush on vmentry)
  static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
  			       char *buf, unsigned int bug)
  {
diff --cc arch/x86/kvm/vmx.c
index d9e0ef7725c0,29d6eab6920e..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -192,12 -188,150 +192,142 @@@ module_param(ple_window_max, uint, 0444
  
  extern const ulong vmx_return;
  
 -static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);
 -static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);
 -static DEFINE_MUTEX(vmx_l1d_flush_mutex);
 -
 -/* Storage for pre module init parameter parsing */
 -static enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush_param = VMENTER_L1D_FLUSH_AUTO;
 -
 -static const struct {
 -	const char *option;
 -	enum vmx_l1d_flush_state cmd;
 -} vmentry_l1d_param[] = {
 -	{"auto",	VMENTER_L1D_FLUSH_AUTO},
 -	{"never",	VMENTER_L1D_FLUSH_NEVER},
 -	{"cond",	VMENTER_L1D_FLUSH_COND},
 -	{"always",	VMENTER_L1D_FLUSH_ALWAYS},
 +enum ept_pointers_status {
 +	EPT_POINTERS_CHECK = 0,
 +	EPT_POINTERS_MATCH = 1,
 +	EPT_POINTERS_MISMATCH = 2
  };
  
++<<<<<<< HEAD
++=======
+ #define L1D_CACHE_ORDER 4
+ static void *vmx_l1d_flush_pages;
+ 
+ static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)
+ {
+ 	struct page *page;
+ 	unsigned int i;
+ 
+ 	if (!enable_ept) {
+ 		l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;
+ 		return 0;
+ 	}
+ 
+        if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {
+ 	       u64 msr;
+ 
+ 	       rdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);
+ 	       if (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {
+ 		       l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;
+ 		       return 0;
+ 	       }
+        }
+ 
+ 	/* If set to auto use the default l1tf mitigation method */
+ 	if (l1tf == VMENTER_L1D_FLUSH_AUTO) {
+ 		switch (l1tf_mitigation) {
+ 		case L1TF_MITIGATION_OFF:
+ 			l1tf = VMENTER_L1D_FLUSH_NEVER;
+ 			break;
+ 		case L1TF_MITIGATION_FLUSH_NOWARN:
+ 		case L1TF_MITIGATION_FLUSH:
+ 		case L1TF_MITIGATION_FLUSH_NOSMT:
+ 			l1tf = VMENTER_L1D_FLUSH_COND;
+ 			break;
+ 		case L1TF_MITIGATION_FULL:
+ 		case L1TF_MITIGATION_FULL_FORCE:
+ 			l1tf = VMENTER_L1D_FLUSH_ALWAYS;
+ 			break;
+ 		}
+ 	} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {
+ 		l1tf = VMENTER_L1D_FLUSH_ALWAYS;
+ 	}
+ 
+ 	if (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&
+ 	    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {
+ 		page = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);
+ 		if (!page)
+ 			return -ENOMEM;
+ 		vmx_l1d_flush_pages = page_address(page);
+ 
+ 		/*
+ 		 * Initialize each page with a different pattern in
+ 		 * order to protect against KSM in the nested
+ 		 * virtualization case.
+ 		 */
+ 		for (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {
+ 			memset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,
+ 			       PAGE_SIZE);
+ 		}
+ 	}
+ 
+ 	l1tf_vmx_mitigation = l1tf;
+ 
+ 	if (l1tf != VMENTER_L1D_FLUSH_NEVER)
+ 		static_branch_enable(&vmx_l1d_should_flush);
+ 	else
+ 		static_branch_disable(&vmx_l1d_should_flush);
+ 
+ 	if (l1tf == VMENTER_L1D_FLUSH_COND)
+ 		static_branch_enable(&vmx_l1d_flush_cond);
+ 	else
+ 		static_branch_disable(&vmx_l1d_flush_cond);
+ 	return 0;
+ }
+ 
+ static int vmentry_l1d_flush_parse(const char *s)
+ {
+ 	unsigned int i;
+ 
+ 	if (s) {
+ 		for (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {
+ 			if (sysfs_streq(s, vmentry_l1d_param[i].option))
+ 				return vmentry_l1d_param[i].cmd;
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)
+ {
+ 	int l1tf, ret;
+ 
+ 	if (!boot_cpu_has(X86_BUG_L1TF))
+ 		return 0;
+ 
+ 	l1tf = vmentry_l1d_flush_parse(s);
+ 	if (l1tf < 0)
+ 		return l1tf;
+ 
+ 	/*
+ 	 * Has vmx_init() run already? If not then this is the pre init
+ 	 * parameter parsing. In that case just store the value and let
+ 	 * vmx_init() do the proper setup after enable_ept has been
+ 	 * established.
+ 	 */
+ 	if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {
+ 		vmentry_l1d_flush_param = l1tf;
+ 		return 0;
+ 	}
+ 
+ 	mutex_lock(&vmx_l1d_flush_mutex);
+ 	ret = vmx_setup_l1d_flush(l1tf);
+ 	mutex_unlock(&vmx_l1d_flush_mutex);
+ 	return ret;
+ }
+ 
+ static int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)
+ {
+ 	return sprintf(s, "%s\n", vmentry_l1d_param[l1tf_vmx_mitigation].option);
+ }
+ 
+ static const struct kernel_param_ops vmentry_l1d_flush_ops = {
+ 	.set = vmentry_l1d_flush_set,
+ 	.get = vmentry_l1d_flush_get,
+ };
+ module_param_cb(vmentry_l1d_flush, &vmentry_l1d_flush_ops, NULL, 0644);
+ 
++>>>>>>> 8e0b2b916662 (x86/speculation: Use ARCH_CAPABILITIES to skip L1D flush on vmentry)
  struct kvm_vmx {
  	struct kvm kvm;
  
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 68b2c3150de1..a7f32dfc8713 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -70,6 +70,7 @@
 #define MSR_IA32_ARCH_CAPABILITIES	0x0000010a
 #define ARCH_CAP_RDCL_NO		(1 << 0)   /* Not susceptible to Meltdown */
 #define ARCH_CAP_IBRS_ALL		(1 << 1)   /* Enhanced IBRS support */
+#define ARCH_CAP_SKIP_VMENTRY_L1DFLUSH	(1 << 3)   /* Skip L1D flush on vmentry */
 #define ARCH_CAP_SSB_NO			(1 << 4)   /*
 						    * Not susceptible to Speculative Store Bypass
 						    * attack, so no Speculative Store Bypass
* Unmerged path arch/x86/include/asm/vmx.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
* Unmerged path arch/x86/kvm/vmx.c
