smb: client: let recv_done verify data_offset, data_length and remaining_data_length

jira KERNEL-602
cve CVE-2025-39933
Rebuild_History Non-Buildable kernel-6.12.0-124.35.1.el10_1
commit-author Stefan Metzmacher <metze@samba.org>
commit f57e53ea252363234f86674db475839e5b87102e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-124.35.1.el10_1/f57e53ea.failed

This is inspired by the related server fixes.

	Cc: Tom Talpey <tom@talpey.com>
	Cc: Long Li <longli@microsoft.com>
	Cc: linux-cifs@vger.kernel.org
	Cc: samba-technical@lists.samba.org
	Reviewed-by: Namjae Jeon <linkinjeon@kernel.org>
Fixes: f198186aa9bb ("CIFS: SMBD: Establish SMB Direct connection")
	Signed-off-by: Stefan Metzmacher <metze@samba.org>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit f57e53ea252363234f86674db475839e5b87102e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/smb/client/smbdirect.c
diff --cc fs/smb/client/smbdirect.c
index 754e94a0e07f,dafa3ed4a630..000000000000
--- a/fs/smb/client/smbdirect.c
+++ b/fs/smb/client/smbdirect.c
@@@ -454,13 -450,18 +454,25 @@@ static void smbd_post_send_credits(stru
  static void recv_done(struct ib_cq *cq, struct ib_wc *wc)
  {
  	struct smbdirect_data_transfer *data_transfer;
++<<<<<<< HEAD
 +	struct smbd_response *response =
 +		container_of(wc->wr_cqe, struct smbd_response, cqe);
 +	struct smbd_connection *info = response->info;
 +	int data_length = 0;
++=======
+ 	struct smbdirect_recv_io *response =
+ 		container_of(wc->wr_cqe, struct smbdirect_recv_io, cqe);
+ 	struct smbdirect_socket *sc = response->socket;
+ 	struct smbdirect_socket_parameters *sp = &sc->parameters;
+ 	struct smbd_connection *info =
+ 		container_of(sc, struct smbd_connection, socket);
+ 	u32 data_offset = 0;
+ 	u32 data_length = 0;
+ 	u32 remaining_data_length = 0;
++>>>>>>> f57e53ea2523 (smb: client: let recv_done verify data_offset, data_length and remaining_data_length)
  
  	log_rdma_recv(INFO, "response=0x%p type=%d wc status=%d wc opcode %d byte_len=%d pkey_index=%u\n",
 -		      response, sc->recv_io.expected, wc->status, wc->opcode,
 +		      response, response->type, wc->status, wc->opcode,
  		      wc->byte_len, wc->pkey_index);
  
  	if (wc->status != IB_WC_SUCCESS || wc->opcode != IB_WC_RECV) {
@@@ -476,27 -476,39 +488,47 @@@
  		response->sge.length,
  		DMA_FROM_DEVICE);
  
 -	switch (sc->recv_io.expected) {
 +	switch (response->type) {
  	/* SMBD negotiation response */
 -	case SMBDIRECT_EXPECT_NEGOTIATE_REP:
 -		dump_smbdirect_negotiate_resp(smbdirect_recv_io_payload(response));
 -		sc->recv_io.reassembly.full_packet_received = true;
 +	case SMBD_NEGOTIATE_RESP:
 +		dump_smbdirect_negotiate_resp(smbd_response_payload(response));
 +		info->full_packet_received = true;
  		info->negotiate_done =
  			process_negotiation_response(response, wc->byte_len);
 -		put_receive_buffer(info, response);
  		complete(&info->negotiate_completion);
 -		return;
 +		break;
  
  	/* SMBD data transfer packet */
++<<<<<<< HEAD
 +	case SMBD_TRANSFER_DATA:
 +		data_transfer = smbd_response_payload(response);
++=======
+ 	case SMBDIRECT_EXPECT_DATA_TRANSFER:
+ 		data_transfer = smbdirect_recv_io_payload(response);
+ 
+ 		if (wc->byte_len <
+ 		    offsetof(struct smbdirect_data_transfer, padding))
+ 			goto error;
+ 
+ 		remaining_data_length = le32_to_cpu(data_transfer->remaining_data_length);
+ 		data_offset = le32_to_cpu(data_transfer->data_offset);
++>>>>>>> f57e53ea2523 (smb: client: let recv_done verify data_offset, data_length and remaining_data_length)
  		data_length = le32_to_cpu(data_transfer->data_length);
+ 		if (wc->byte_len < data_offset ||
+ 		    (u64)wc->byte_len < (u64)data_offset + data_length)
+ 			goto error;
+ 
+ 		if (remaining_data_length > sp->max_fragmented_recv_size ||
+ 		    data_length > sp->max_fragmented_recv_size ||
+ 		    (u64)remaining_data_length + (u64)data_length > (u64)sp->max_fragmented_recv_size)
+ 			goto error;
  
 +		/*
 +		 * If this is a packet with data playload place the data in
 +		 * reassembly queue and wake up the reading thread
 +		 */
  		if (data_length) {
 -			if (sc->recv_io.reassembly.full_packet_received)
 +			if (info->full_packet_received)
  				response->first_segment = true;
  
  			if (le32_to_cpu(data_transfer->remaining_data_length))
* Unmerged path fs/smb/client/smbdirect.c
