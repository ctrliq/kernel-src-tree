net: asix: fix uninit value bugs

jira LE-3201
cve CVE-2021-47101
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.22.1.rt7.363.el8_10
commit-author Pavel Skripkin <paskripkin@gmail.com>
commit a786e3195d6af183033e86f0518ffd2c51c0e8ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.22.1.rt7.363.el8_10/a786e319.failed

Syzbot reported uninit-value in asix_mdio_read(). The problem was in
missing error handling. asix_read_cmd() should initialize passed stack
variable smsr, but it can fail in some cases. Then while condidition
checks possibly uninit smsr variable.

Since smsr is uninitialized stack variable, driver can misbehave,
because smsr will be random in case of asix_read_cmd() failure.
Fix it by adding error handling and just continue the loop instead of
checking uninit value.

Added helper function for checking Host_En bit, since wrong loop was used
in 4 functions and there is no need in copy-pasting code parts.

	Cc: Robert Foss <robert.foss@collabora.com>
Fixes: d9fe64e51114 ("net: asix: Add in_pm parameter")
	Reported-by: syzbot+a631ec9e717fb0423053@syzkaller.appspotmail.com
	Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a786e3195d6af183033e86f0518ffd2c51c0e8ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/asix_common.c
diff --cc drivers/net/usb/asix_common.c
index 113993e61ac8,38cda590895c..000000000000
--- a/drivers/net/usb/asix_common.c
+++ b/drivers/net/usb/asix_common.c
@@@ -499,23 -526,41 +512,38 @@@ void asix_mdio_write(struct net_device 
  			phy_id, loc, val);
  
  	mutex_lock(&dev->phy_mutex);
++<<<<<<< HEAD
 +	do {
 +		ret = asix_set_sw_mii(dev, 0);
 +		if (ret == -ENODEV)
 +			break;
 +		usleep_range(1000, 1100);
 +		ret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG,
 +				    0, 0, 1, &smsr, 0);
 +	} while (!(smsr & AX_HOST_EN) && (i++ < 30) && (ret != -ENODEV));
 +	if (ret == -ENODEV) {
 +		mutex_unlock(&dev->phy_mutex);
 +		return;
 +	}
 +
 +	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
 +		       (__u16)loc, 2, &res, 0);
 +	asix_set_hw_mii(dev, 0);
++=======
+ 
+ 	ret = asix_check_host_enable(dev, 0);
+ 	if (ret == -ENODEV)
+ 		goto out;
+ 
+ 	ret = asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2,
+ 			     &res, 0);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	ret = asix_set_hw_mii(dev, 0);
+ out:
++>>>>>>> a786e3195d6a (net: asix: fix uninit value bugs)
  	mutex_unlock(&dev->phy_mutex);
 -
 -	return ret < 0 ? ret : 0;
 -}
 -
 -void asix_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
 -{
 -	__asix_mdio_write(netdev, phy_id, loc, val);
 -}
 -
 -/* MDIO read and write wrappers for phylib */
 -int asix_mdio_bus_read(struct mii_bus *bus, int phy_id, int regnum)
 -{
 -	struct usbnet *priv = bus->priv;
 -
 -	return asix_mdio_read(priv->net, phy_id, regnum);
 -}
 -
 -int asix_mdio_bus_write(struct mii_bus *bus, int phy_id, int regnum, u16 val)
 -{
 -	struct usbnet *priv = bus->priv;
 -
 -	return __asix_mdio_write(priv->net, phy_id, regnum, val);
  }
  
  int asix_mdio_read_nopm(struct net_device *netdev, int phy_id, int loc)
* Unmerged path drivers/net/usb/asix_common.c
