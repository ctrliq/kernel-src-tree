media: cec: correctly pass on reply results

jira LE-3201
cve CVE-2024-23848
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.22.1.rt7.363.el8_10
commit-author Hans Verkuil <hverkuil-cisco@xs4all.nl>
commit f9d0ecbf56f4b90745a6adc5b59281ad8f70ab54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.22.1.rt7.363.el8_10/f9d0ecbf.failed

The results of non-blocking transmits were not correctly communicated
to userspace.

Specifically:

1) if a non-blocking transmit was canceled, then rx_status wasn't set to 0
   as it should.
2) if the non-blocking transmit succeeded, but the corresponding reply
   never arrived (aborted or timed out), then tx_status wasn't set to 0
   as it should, and rx_status was hardcoded to ABORTED instead of the
   actual reason, such as TIMEOUT. In addition, adap->ops->received() was
   never called, so drivers that want to do message processing themselves
   would not be informed of the failed reply.

	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
(cherry picked from commit f9d0ecbf56f4b90745a6adc5b59281ad8f70ab54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/cec/core/cec-adap.c
diff --cc drivers/media/cec/core/cec-adap.c
index e0e9d4808c3d,11fddb012d98..000000000000
--- a/drivers/media/cec/core/cec-adap.c
+++ b/drivers/media/cec/core/cec-adap.c
@@@ -417,10 -428,10 +427,10 @@@ static void cec_flush(struct cec_adapte
  	while (!list_empty(&adap->transmit_queue)) {
  		data = list_first_entry(&adap->transmit_queue,
  					struct cec_data, list);
- 		cec_data_cancel(data, CEC_TX_STATUS_ABORTED);
+ 		cec_data_cancel(data, CEC_TX_STATUS_ABORTED, 0);
  	}
  	if (adap->transmitting)
 -		adap->transmit_in_progress_aborted = true;
 +		cec_data_cancel(adap->transmitting, CEC_TX_STATUS_ABORTED);
  
  	/* Cancel the pending timeout work. */
  	list_for_each_entry_safe(data, n, &adap->wait_queue, list) {
@@@ -1558,6 -1577,48 +1570,51 @@@ static void cec_claim_log_addrs(struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Helper functions to enable/disable the CEC adapter.
+  *
+  * These functions are called with adap->lock held.
+  */
+ static int cec_activate_cnt_inc(struct cec_adapter *adap)
+ {
+ 	int ret;
+ 
+ 	if (adap->activate_cnt++)
+ 		return 0;
+ 
+ 	/* serialize adap_enable */
+ 	mutex_lock(&adap->devnode.lock);
+ 	adap->last_initiator = 0xff;
+ 	adap->transmit_in_progress = false;
+ 	ret = adap->ops->adap_enable(adap, true);
+ 	if (ret)
+ 		adap->activate_cnt--;
+ 	mutex_unlock(&adap->devnode.lock);
+ 	return ret;
+ }
+ 
+ static void cec_activate_cnt_dec(struct cec_adapter *adap)
+ {
+ 	if (WARN_ON(!adap->activate_cnt))
+ 		return;
+ 
+ 	if (--adap->activate_cnt)
+ 		return;
+ 
+ 	/* serialize adap_enable */
+ 	mutex_lock(&adap->devnode.lock);
+ 	WARN_ON(adap->ops->adap_enable(adap, false));
+ 	adap->last_initiator = 0xff;
+ 	adap->transmit_in_progress = false;
+ 	adap->transmit_in_progress_aborted = false;
+ 	if (adap->transmitting)
+ 		cec_data_cancel(adap->transmitting, CEC_TX_STATUS_ABORTED, 0);
+ 	mutex_unlock(&adap->devnode.lock);
+ }
+ 
++>>>>>>> f9d0ecbf56f4 (media: cec: correctly pass on reply results)
  /* Set a new physical address and send an event notifying userspace of this.
   *
   * This function is called with adap->lock held.
* Unmerged path drivers/media/cec/core/cec-adap.c
