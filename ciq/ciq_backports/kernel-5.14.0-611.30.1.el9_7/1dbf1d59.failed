net: Add locking to protect skb->dev access in ip_output

jira KERNEL-619
Rebuild_History Non-Buildable kernel-5.14.0-611.30.1.el9_7
commit-author Sharath Chandra Vurukala <quic_sharathv@quicinc.com>
commit 1dbf1d590d10a6d1978e8184f8dfe20af22d680a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.30.1.el9_7/1dbf1d59.failed

In ip_output() skb->dev is updated from the skb_dst(skb)->dev
this can become invalid when the interface is unregistered and freed,

Introduced new skb_dst_dev_rcu() function to be used instead of
skb_dst_dev() within rcu_locks in ip_output.This will ensure that
all the skb's associated with the dev being deregistered will
be transnmitted out first, before freeing the dev.

Given that ip_output() is called within an rcu_read_lock()
critical section or from a bottom-half context, it is safe to introduce
an RCU read-side critical section within it.

Multiple panic call stacks were observed when UL traffic was run
in concurrency with device deregistration from different functions,
pasting one sample for reference.

[496733.627565][T13385] Call trace:
[496733.627570][T13385] bpf_prog_ce7c9180c3b128ea_cgroupskb_egres+0x24c/0x7f0
[496733.627581][T13385] __cgroup_bpf_run_filter_skb+0x128/0x498
[496733.627595][T13385] ip_finish_output+0xa4/0xf4
[496733.627605][T13385] ip_output+0x100/0x1a0
[496733.627613][T13385] ip_send_skb+0x68/0x100
[496733.627618][T13385] udp_send_skb+0x1c4/0x384
[496733.627625][T13385] udp_sendmsg+0x7b0/0x898
[496733.627631][T13385] inet_sendmsg+0x5c/0x7c
[496733.627639][T13385] __sys_sendto+0x174/0x1e4
[496733.627647][T13385] __arm64_sys_sendto+0x28/0x3c
[496733.627653][T13385] invoke_syscall+0x58/0x11c
[496733.627662][T13385] el0_svc_common+0x88/0xf4
[496733.627669][T13385] do_el0_svc+0x2c/0xb0
[496733.627676][T13385] el0_svc+0x2c/0xa4
[496733.627683][T13385] el0t_64_sync_handler+0x68/0xb4
[496733.627689][T13385] el0t_64_sync+0x1a4/0x1a8

Changes in v3:
- Replaced WARN_ON() with  WARN_ON_ONCE(), as suggested by Willem de Bruijn.
- Dropped legacy lines mistakenly pulled in from an outdated branch.

Changes in v2:
- Addressed review comments from Eric Dumazet
- Used READ_ONCE() to prevent potential load/store tearing
- Added skb_dst_dev_rcu() and used along with rcu_read_lock() in ip_output

	Signed-off-by: Sharath Chandra Vurukala <quic_sharathv@quicinc.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: https://patch.msgid.link/20250730105118.GA26100@hu-sharathv-hyd.qualcomm.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 1dbf1d590d10a6d1978e8184f8dfe20af22d680a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/dst.h
#	net/ipv4/ip_output.c
diff --cc include/net/dst.h
index b9a7b9ce719e,bab01363bb97..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -579,6 -563,38 +579,41 @@@ static inline void skb_dst_update_pmtu_
  		dst->ops->update_pmtu(dst, NULL, skb, mtu, false);
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct net_device *dst_dev(const struct dst_entry *dst)
+ {
+ 	return READ_ONCE(dst->dev);
+ }
+ 
+ static inline struct net_device *dst_dev_rcu(const struct dst_entry *dst)
+ {
+ 	/* In the future, use rcu_dereference(dst->dev) */
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 	return READ_ONCE(dst->dev);
+ }
+ 
+ static inline struct net_device *skb_dst_dev(const struct sk_buff *skb)
+ {
+ 	return dst_dev(skb_dst(skb));
+ }
+ 
+ static inline struct net_device *skb_dst_dev_rcu(const struct sk_buff *skb)
+ {
+ 	return dst_dev_rcu(skb_dst(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net(const struct sk_buff *skb)
+ {
+ 	return dev_net(skb_dst_dev(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net_rcu(const struct sk_buff *skb)
+ {
+ 	return dev_net_rcu(skb_dst_dev(skb));
+ }
+ 
++>>>>>>> 1dbf1d590d10 (net: Add locking to protect skb->dev access in ip_output)
  struct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie);
  void dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,
  			       struct sk_buff *skb, u32 mtu, bool confirm_neigh);
diff --cc net/ipv4/ip_output.c
index dcabe4ea157b,84e7f8a2f50f..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -425,8 -425,11 +425,15 @@@ int ip_mc_output(struct net *net, struc
  
  int ip_output(struct net *net, struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct net_device *dev = skb_dst(skb)->dev, *indev = skb->dev;
++=======
+ 	struct net_device *dev, *indev = skb->dev;
+ 	int ret_val;
++>>>>>>> 1dbf1d590d10 (net: Add locking to protect skb->dev access in ip_output)
  
+ 	rcu_read_lock();
+ 	dev = skb_dst_dev_rcu(skb);
  	skb->dev = dev;
  	skb->protocol = htons(ETH_P_IP);
  
* Unmerged path include/net/dst.h
* Unmerged path net/ipv4/ip_output.c
