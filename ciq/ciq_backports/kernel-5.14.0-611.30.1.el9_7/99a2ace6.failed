net: use dst_dev_rcu() in sk_setup_caps()

jira KERNEL-619
cve CVE-2025-40170
Rebuild_History Non-Buildable kernel-5.14.0-611.30.1.el9_7
commit-author Eric Dumazet <edumazet@google.com>
commit 99a2ace61b211b0be861b07fbaa062fca4b58879
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.30.1.el9_7/99a2ace6.failed

Use RCU to protect accesses to dst->dev from sk_setup_caps()
and sk_dst_gso_max_size().

Also use dst_dev_rcu() in ip6_dst_mtu_maybe_forward(),
and ip_dst_mtu_maybe_forward().

ip4_dst_hoplimit() can use dst_dev_net_rcu().

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://patch.msgid.link/20250828195823.3958522-6-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 99a2ace61b211b0be861b07fbaa062fca4b58879)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
#	include/net/ip6_route.h
#	include/net/route.h
#	net/core/sock.c
diff --cc include/net/ip.h
index f98661f56cbd,6dbd2bf8fa9c..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -443,10 -466,15 +443,22 @@@ static inline bool ip_sk_ignore_df(cons
  static inline unsigned int ip_dst_mtu_maybe_forward(const struct dst_entry *dst,
  						    bool forwarding)
  {
++<<<<<<< HEAD
 +	const struct rtable *rt = container_of(dst, struct rtable, dst);
 +	struct net *net = dev_net(dst->dev);
 +	unsigned int mtu;
 +
++=======
+ 	const struct rtable *rt = dst_rtable(dst);
+ 	const struct net_device *dev;
+ 	unsigned int mtu, res;
+ 	struct net *net;
+ 
+ 	rcu_read_lock();
+ 
+ 	dev = dst_dev_rcu(dst);
+ 	net = dev_net_rcu(dev);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	if (READ_ONCE(net->ipv4.sysctl_ip_fwd_use_pmtu) ||
  	    ip_mtu_locked(dst) ||
  	    !forwarding) {
@@@ -460,7 -488,7 +472,11 @@@
  	if (mtu)
  		goto out;
  
++<<<<<<< HEAD
 +	mtu = READ_ONCE(dst->dev->mtu);
++=======
+ 	mtu = READ_ONCE(dev->mtu);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  
  	if (unlikely(ip_mtu_locked(dst))) {
  		if (rt->rt_uses_gateway && mtu > 576)
diff --cc include/net/ip6_route.h
index cd3ecba4415a,59f48ca3abdf..000000000000
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@@ -337,7 -337,7 +337,11 @@@ static inline unsigned int ip6_dst_mtu_
  
  	mtu = IPV6_MIN_MTU;
  	rcu_read_lock();
++<<<<<<< HEAD
 +	idev = __in6_dev_get(dst->dev);
++=======
+ 	idev = __in6_dev_get(dst_dev_rcu(dst));
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	if (idev)
  		mtu = READ_ONCE(idev->cnf.mtu6);
  	rcu_read_unlock();
diff --cc include/net/route.h
index 394a0ca765ae,f90106f383c5..000000000000
--- a/include/net/route.h
+++ b/include/net/route.h
@@@ -359,7 -390,7 +359,11 @@@ static inline int ip4_dst_hoplimit(cons
  		const struct net *net;
  
  		rcu_read_lock();
++<<<<<<< HEAD
 +		net = dev_net_rcu(dst->dev);
++=======
+ 		net = dst_dev_net_rcu(dst);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  		hoplimit = READ_ONCE(net->ipv4.sysctl_ip_default_ttl);
  		rcu_read_unlock();
  	}
diff --cc net/core/sock.c
index 56b31598b6ad,9a8290fcc35d..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -2331,17 -2578,16 +2331,21 @@@ out
  }
  EXPORT_SYMBOL_GPL(sk_clone_lock);
  
++<<<<<<< HEAD
 +void sk_free_unlock_clone(struct sock *sk)
 +{
 +	/* It is still raw copy of parent, so invalidate
 +	 * destructor and make plain sk_free() */
 +	sk->sk_destruct = NULL;
 +	bh_unlock_sock(sk);
 +	sk_free(sk);
 +}
 +EXPORT_SYMBOL_GPL(sk_free_unlock_clone);
 +
 +static u32 sk_dst_gso_max_size(struct sock *sk, struct dst_entry *dst)
++=======
+ static u32 sk_dst_gso_max_size(struct sock *sk, const struct net_device *dev)
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  {
  	bool is_ipv6 = false;
  	u32 max_size;
@@@ -2351,8 -2597,8 +2355,13 @@@
  		   !ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr));
  #endif
  	/* pairs with the WRITE_ONCE() in netif_set_gso(_ipv4)_max_size() */
++<<<<<<< HEAD
 +	max_size = is_ipv6 ? READ_ONCE(dst->dev->gso_max_size) :
 +			READ_ONCE(dst->dev->gso_ipv4_max_size);
++=======
+ 	max_size = is_ipv6 ? READ_ONCE(dev->gso_max_size) :
+ 			READ_ONCE(dev->gso_ipv4_max_size);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	if (max_size > GSO_LEGACY_MAX_SIZE && !sk_is_tcp(sk))
  		max_size = GSO_LEGACY_MAX_SIZE;
  
@@@ -2361,11 -2607,18 +2370,21 @@@
  
  void sk_setup_caps(struct sock *sk, struct dst_entry *dst)
  {
+ 	const struct net_device *dev;
  	u32 max_segs = 1;
  
++<<<<<<< HEAD
 +	sk->sk_route_caps = dst->dev->features;
 +	if (sk_is_tcp(sk))
++=======
+ 	rcu_read_lock();
+ 	dev = dst_dev_rcu(dst);
+ 	sk->sk_route_caps = dev->features;
+ 	if (sk_is_tcp(sk)) {
+ 		struct inet_connection_sock *icsk = inet_csk(sk);
+ 
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  		sk->sk_route_caps |= NETIF_F_GSO;
 -		icsk->icsk_ack.dst_quick_ack = dst_metric(dst, RTAX_QUICKACK);
 -	}
  	if (sk->sk_route_caps & NETIF_F_GSO)
  		sk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;
  	if (unlikely(sk->sk_gso_disabled))
@@@ -2375,9 -2628,9 +2394,13 @@@
  			sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
  		} else {
  			sk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;
- 			sk->sk_gso_max_size = sk_dst_gso_max_size(sk, dst);
+ 			sk->sk_gso_max_size = sk_dst_gso_max_size(sk, dev);
  			/* pairs with the WRITE_ONCE() in netif_set_gso_max_segs() */
++<<<<<<< HEAD
 +			max_segs = max_t(u32, READ_ONCE(dst->dev->gso_max_segs), 1);
++=======
+ 			max_segs = max_t(u32, READ_ONCE(dev->gso_max_segs), 1);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  		}
  	}
  	sk->sk_gso_max_segs = max_segs;
* Unmerged path include/net/ip.h
* Unmerged path include/net/ip6_route.h
* Unmerged path include/net/route.h
* Unmerged path net/core/sock.c
