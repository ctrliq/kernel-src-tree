ipv6: use RCU in ip6_output()

jira KERNEL-619
cve CVE-2025-40158
Rebuild_History Non-Buildable kernel-5.14.0-611.30.1.el9_7
commit-author Eric Dumazet <edumazet@google.com>
commit 11709573cc4e48dc34c80fc7ab9ce5b159e29695
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.30.1.el9_7/11709573.failed

Use RCU in ip6_output() in order to use dst_dev_rcu() to prevent
possible UAF.

We can remove rcu_read_lock()/rcu_read_unlock() pairs
from ip6_finish_output2().

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://patch.msgid.link/20250828195823.3958522-5-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 11709573cc4e48dc34c80fc7ab9ce5b159e29695)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index b457d59774ea,9d64c13bab5e..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -60,7 -60,7 +60,11 @@@
  static int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)
  {
  	struct dst_entry *dst = skb_dst(skb);
++<<<<<<< HEAD
 +	struct net_device *dev = dst->dev;
++=======
+ 	struct net_device *dev = dst_dev_rcu(dst);
++>>>>>>> 11709573cc4e (ipv6: use RCU in ip6_output())
  	struct inet6_dev *idev = ip6_dst_idev(dst);
  	unsigned int hh_len = LL_RESERVED_SPACE(dev);
  	const struct in6_addr *daddr, *nexthop;
@@@ -123,15 -120,13 +124,22 @@@
  
  	IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);
  
++<<<<<<< HEAD
 +	rcu_read_lock_bh();
 +	nexthop = rt6_nexthop((struct rt6_info *)dst, daddr);
++=======
+ 	nexthop = rt6_nexthop(dst_rt6_info(dst), daddr);
++>>>>>>> 11709573cc4e (ipv6: use RCU in ip6_output())
  	neigh = __ipv6_neigh_lookup_noref(dev, nexthop);
  
 -	if (IS_ERR_OR_NULL(neigh)) {
 +	if (unlikely(IS_ERR_OR_NULL(neigh))) {
  		if (unlikely(!neigh))
  			neigh = __neigh_create(&nd_tbl, nexthop, dev, false);
  		if (IS_ERR(neigh)) {
++<<<<<<< HEAD
 +			rcu_read_unlock_bh();
++=======
++>>>>>>> 11709573cc4e (ipv6: use RCU in ip6_output())
  			IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTNOROUTES);
  			kfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_CREATEFAIL);
  			return -EINVAL;
@@@ -139,7 -134,6 +147,10 @@@
  	}
  	sock_confirm_neigh(skb, neigh);
  	ret = neigh_output(neigh, skb, false);
++<<<<<<< HEAD
 +	rcu_read_unlock_bh();
++=======
++>>>>>>> 11709573cc4e (ipv6: use RCU in ip6_output())
  	return ret;
  }
  
@@@ -225,10 -226,15 +236,20 @@@ static int ip6_finish_output(struct ne
  
  int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct net_device *dev = skb_dst(skb)->dev, *indev = skb->dev;
 +	struct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));
++=======
+ 	struct dst_entry *dst = skb_dst(skb);
+ 	struct net_device *dev, *indev = skb->dev;
+ 	struct inet6_dev *idev;
+ 	int ret;
++>>>>>>> 11709573cc4e (ipv6: use RCU in ip6_output())
  
  	skb->protocol = htons(ETH_P_IPV6);
+ 	rcu_read_lock();
+ 	dev = dst_dev_rcu(dst);
+ 	idev = ip6_dst_idev(dst);
  	skb->dev = dev;
  
  	if (unlikely(!idev || READ_ONCE(idev->cnf.disable_ipv6))) {
* Unmerged path net/ipv6/ip6_output.c
