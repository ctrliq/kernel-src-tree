net: bonding: add broadcast_neighbor option for 802.3ad

jira KERNEL-619
Rebuild_History Non-Buildable kernel-5.14.0-611.30.1.el9_7
commit-author Tonghao Zhang <tonghao@bamaicloud.com>
commit ce7a381697cb3958ffe0b45e5028ac69444e9288
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.30.1.el9_7/ce7a3816.failed

Stacking technology is a type of technology used to expand ports on
Ethernet switches. It is widely used as a common access method in
large-scale Internet data center architectures. Years of practice
have proved that stacking technology has advantages and disadvantages
in high-reliability network architecture scenarios. For instance,
in stacking networking arch, conventional switch system upgrades
require multiple stacked devices to restart at the same time.
Therefore, it is inevitable that the business will be interrupted
for a while. It is for this reason that "no-stacking" in data centers
has become a trend. Additionally, when the stacking link connecting
the switches fails or is abnormal, the stack will split. Although it is
not common, it still happens in actual operation. The problem is that
after the split, it is equivalent to two switches with the same
configuration appearing in the network, causing network configuration
conflicts and ultimately interrupting the services carried by the
stacking system.

To improve network stability, "non-stacking" solutions have been
increasingly adopted, particularly by public cloud providers and
tech companies like Alibaba, Tencent, and Didi. "non-stacking" is
a method of mimicing switch stacking that convinces a LACP peer,
bonding in this case, connected to a set of "non-stacked" switches
that all of its ports are connected to a single switch
(i.e., LACP aggregator), as if those switches were stacked. This
enables the LACP peer's ports to aggregate together, and requires
(a) special switch configuration, described in the linked article,
and (b) modifications to the bonding 802.3ad (LACP) mode to send
all ARP/ND packets across all ports of the active aggregator.

Note that, with multiple aggregators, the current broadcast mode
logic will send only packets to the selected aggregator(s).

 +-----------+   +-----------+
 |  switch1  |   |  switch2  |
 +-----------+   +-----------+
         ^           ^
         |           |
      +-----------------+
      |   bond4 lacp    |
      +-----------------+
         |           |
         | NIC1      | NIC2
      +-----------------+
      |     server      |
      +-----------------+

- https://www.ruijie.com/fr-fr/support/tech-gallery/de-stack-data-center-network-architecture/

	Cc: Jay Vosburgh <jv@jvosburgh.net>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Jakub Kicinski <kuba@kernel.org>
	Cc: Paolo Abeni <pabeni@redhat.com>
	Cc: Simon Horman <horms@kernel.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Andrew Lunn <andrew+netdev@lunn.ch>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Nikolay Aleksandrov <razor@blackwall.org>
	Signed-off-by: Tonghao Zhang <tonghao@bamaicloud.com>
	Signed-off-by: Zengbing Tu <tuzengbing@didiglobal.com>
Link: https://patch.msgid.link/84d0a044514157bb856a10b6d03a1028c4883561.1751031306.git.tonghao@bamaicloud.com
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>

(cherry picked from commit ce7a381697cb3958ffe0b45e5028ac69444e9288)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_options.c
#	include/net/bond_options.h
#	include/net/bonding.h
diff --cc drivers/net/bonding/bond_main.c
index dd725ddbbe6b,12046ef51569..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -6468,6 -6508,8 +6521,11 @@@ static int __init bond_check_params(str
  	params->ad_actor_sys_prio = ad_actor_sys_prio;
  	eth_zero_addr(params->ad_actor_system);
  	params->ad_user_port_key = ad_user_port_key;
++<<<<<<< HEAD
++=======
+ 	params->coupled_control = 1;
+ 	params->broadcast_neighbor = 0;
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
  	if (packets_per_slave > 0) {
  		params->reciprocal_packets_per_slave =
  			reciprocal_value(packets_per_slave);
diff --cc drivers/net/bonding/bond_options.c
index d2c9a9013e1a,1d639a3be6ba..000000000000
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@@ -85,7 -85,10 +85,14 @@@ static int bond_option_ad_user_port_key
  					    const struct bond_opt_value *newval);
  static int bond_option_missed_max_set(struct bonding *bond,
  				      const struct bond_opt_value *newval);
++<<<<<<< HEAD
 +
++=======
+ static int bond_option_coupled_control_set(struct bonding *bond,
+ 					   const struct bond_opt_value *newval);
+ static int bond_option_broadcast_neigh_set(struct bonding *bond,
+ 					   const struct bond_opt_value *newval);
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
  
  static const struct bond_opt_value bond_mode_tbl[] = {
  	{ "balance-rr",    BOND_MODE_ROUNDROBIN,   BOND_VALFLAG_DEFAULT},
@@@ -233,6 -236,18 +240,21 @@@ static const struct bond_opt_value bond
  	{ NULL,		-1,	0},
  };
  
++<<<<<<< HEAD
++=======
+ static const struct bond_opt_value bond_coupled_control_tbl[] = {
+ 	{ "on",  1,  BOND_VALFLAG_DEFAULT},
+ 	{ "off", 0,  0},
+ 	{ NULL,  -1, 0},
+ };
+ 
+ static const struct bond_opt_value bond_broadcast_neigh_tbl[] = {
+ 	{ "off", 0, BOND_VALFLAG_DEFAULT},
+ 	{ "on",	 1, 0},
+ 	{ NULL,  -1, 0}
+ };
+ 
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
  static const struct bond_option bond_opts[BOND_OPT_LAST] = {
  	[BOND_OPT_MODE] = {
  		.id = BOND_OPT_MODE,
@@@ -497,6 -512,23 +519,26 @@@
  		.desc = "Delay between each peer notification on failover event, in milliseconds",
  		.values = bond_peer_notif_delay_tbl,
  		.set = bond_option_peer_notif_delay_set
++<<<<<<< HEAD
++=======
+ 	},
+ 	[BOND_OPT_COUPLED_CONTROL] = {
+ 		.id = BOND_OPT_COUPLED_CONTROL,
+ 		.name = "coupled_control",
+ 		.desc = "Opt into using coupled control MUX for LACP states",
+ 		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
+ 		.flags = BOND_OPTFLAG_IFDOWN,
+ 		.values = bond_coupled_control_tbl,
+ 		.set = bond_option_coupled_control_set,
+ 	},
+ 	[BOND_OPT_BROADCAST_NEIGH] = {
+ 		.id = BOND_OPT_BROADCAST_NEIGH,
+ 		.name = "broadcast_neighbor",
+ 		.desc = "Broadcast neighbor packets to all active slaves",
+ 		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
+ 		.values = bond_broadcast_neigh_tbl,
+ 		.set = bond_option_broadcast_neigh_set,
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
  	}
  };
  
@@@ -1829,3 -1853,32 +1878,35 @@@ static int bond_option_ad_user_port_key
  	bond->params.ad_user_port_key = newval->value;
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int bond_option_coupled_control_set(struct bonding *bond,
+ 					   const struct bond_opt_value *newval)
+ {
+ 	netdev_info(bond->dev, "Setting coupled_control to %s (%llu)\n",
+ 		    newval->string, newval->value);
+ 
+ 	bond->params.coupled_control = newval->value;
+ 	return 0;
+ }
+ 
+ static int bond_option_broadcast_neigh_set(struct bonding *bond,
+ 					   const struct bond_opt_value *newval)
+ {
+ 	if (bond->params.broadcast_neighbor == newval->value)
+ 		return 0;
+ 
+ 	bond->params.broadcast_neighbor = newval->value;
+ 	if (bond->dev->flags & IFF_UP) {
+ 		if (bond->params.broadcast_neighbor)
+ 			static_branch_inc(&bond_bcast_neigh_enabled);
+ 		else
+ 			static_branch_dec(&bond_bcast_neigh_enabled);
+ 	}
+ 
+ 	netdev_dbg(bond->dev, "Setting broadcast_neighbor to %s (%llu)\n",
+ 		   newval->string, newval->value);
+ 	return 0;
+ }
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
diff --cc include/net/bond_options.h
index f631d9f09941,022b122a9fb6..000000000000
--- a/include/net/bond_options.h
+++ b/include/net/bond_options.h
@@@ -76,6 -76,8 +76,11 @@@ enum 
  	BOND_OPT_MISSED_MAX,
  	BOND_OPT_NS_TARGETS,
  	BOND_OPT_PRIO,
++<<<<<<< HEAD
++=======
+ 	BOND_OPT_COUPLED_CONTROL,
+ 	BOND_OPT_BROADCAST_NEIGH,
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
  	BOND_OPT_LAST
  };
  
diff --cc include/net/bonding.h
index 92bcb3737d3c,e06f0d63b2c1..000000000000
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@@ -152,6 -150,8 +154,11 @@@ struct bond_params 
  #if IS_ENABLED(CONFIG_IPV6)
  	struct in6_addr ns_targets[BOND_MAX_NS_TARGETS];
  #endif
++<<<<<<< HEAD
++=======
+ 	int coupled_control;
+ 	int broadcast_neighbor;
++>>>>>>> ce7a381697cb (net: bonding: add broadcast_neighbor option for 802.3ad)
  
  	/* 2 bytes of padding : see ether_addr_equal_64bits() */
  	u8 ad_actor_system[ETH_ALEN + 2];
diff --git a/Documentation/networking/bonding.rst b/Documentation/networking/bonding.rst
index 5e319bc08d4b..4957a10c07ea 100644
--- a/Documentation/networking/bonding.rst
+++ b/Documentation/networking/bonding.rst
@@ -550,6 +550,12 @@ lacp_rate
 
 	The default is slow.
 
+broadcast_neighbor
+
+	Option specifying whether to broadcast ARP/ND packets to all
+	active slaves.  This option has no effect in modes other than
+	802.3ad mode.  The default is off (0).
+
 max_bonds
 
 	Specifies the number of bonding devices to create for this
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path include/net/bond_options.h
* Unmerged path include/net/bonding.h
