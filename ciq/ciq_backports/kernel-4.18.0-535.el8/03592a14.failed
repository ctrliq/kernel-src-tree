ice: allow matching on meta data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
commit 03592a14b9383bbe1c0d56e7ac4005cea10e711a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/03592a14.failed

Add meta data matching criteria in the same place as protocol matching
criteria. There is no need to add meta data as special words after
parsing all lookups. Trade meta data in the same why as other lookups.

The one difference between meta data lookups and protocol lookups is
that meta data doesn't impact how the packets looks like. Because of that
ignore it when filling testing packet.

Match on tunnel type meta data always if tunnel type is different than
TNL_LAST.

	Signed-off-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Reviewed-by: Piotr Raczynski <piotr.raczynski@intel.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Tested-by: Sujai Buvaneswaran <sujai.buvaneswaran@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 03592a14b9383bbe1c0d56e7ac4005cea10e711a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_protocol_type.h
#	drivers/net/ethernet/intel/ice/ice_switch.c
diff --cc drivers/net/ethernet/intel/ice/ice_protocol_type.h
index 454ed0bc710f,ed0ab8177c61..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_protocol_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_protocol_type.h
@@@ -212,6 -221,188 +213,191 @@@ struct ice_nvgre_hdr 
  	__be32 tni_flow;
  };
  
++<<<<<<< HEAD
++=======
+ /* Metadata information
+  *
+  * Not all MDIDs can be used by switch block. It depends on package version.
+  *
+  * MDID 16 (Rx offset)
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |  A  |   B     |   Reserved    |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = Source port where the transaction came from (3b).
+  *
+  * B = Destination TC of the packet. The TC is relative to a port (5b).
+  *
+  * MDID 17
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |      PTYPE        | Reserved  |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * PTYPE = Encodes the packet type (10b).
+  *
+  * MDID 18
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * | Packet length             | R |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * Packet length = Length of the packet in bytes
+  *		   (packet always carriers CRC) (14b).
+  * R = Reserved (2b).
+  *
+  * MDID 19
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |   Source VSI      | Reserved  |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * Source VSI = Source VSI of packet loopbacked in switch (for egress) (10b).
+  *
+  * MDID 20
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|E|F|R|R|G|H|I|J|K|L|M|N|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = DSI - set for DSI RX pkts.
+  * B = ipsec_decrypted - invalid on NIC.
+  * C = marker - this is a marker packet.
+  * D = from_network - for TX sets to 0
+  *		      for RX:
+  *		        * 1 - packet is from external link
+  *		        * 0 - packet source is from internal
+  * E = source_interface_is_rx - reflect the physical interface from where the
+  *				packet was received:
+  *				* 1 - Rx
+  *				* 0 - Tx
+  * F = from_mng - The bit signals that the packet's origin is the management.
+  * G = ucast - Outer L2 MAC address is unicast.
+  * H = mcast - Outer L2 MAC address is multicast.
+  * I = bcast - Outer L2 MAC address is broadcast.
+  * J = second_outer_mac_present - 2 outer MAC headers are present in the packet.
+  * K = STAG or BVLAN - Outer L2 header has STAG (ethernet type 0x88a8) or
+  *		       BVLAN (ethernet type 0x88a8).
+  * L = ITAG - Outer L2 header has ITAG *ethernet type 0x88e7)
+  * M = EVLAN (0x8100) - Outer L2 header has EVLAN (ethernet type 0x8100)
+  * N = EVLAN (0x9100) - Outer L2 header has EVLAN (ethernet type 0x9100)
+  */
+ #define ICE_PKT_VLAN_STAG	BIT(12)
+ #define ICE_PKT_VLAN_ITAG	BIT(13)
+ #define ICE_PKT_VLAN_EVLAN	(BIT(14) | BIT(15))
+ #define ICE_PKT_VLAN_MASK	(ICE_PKT_VLAN_STAG | ICE_PKT_VLAN_ITAG | \
+ 				ICE_PKT_VLAN_EVLAN)
+ /* MDID 21
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|E|F|G|H|I|J|R|R|K|L|M|N|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = VLAN (0x8100) - Outer L2 header has VLAN (ethernet type 0x8100)
+  * B = NSHoE - Outer L2 header has NSH (ethernet type 0x894f)
+  * C = MPLS (0x8847) - There is at least 1 MPLS tag in the outer header
+  *		       (ethernet type 0x8847)
+  * D = MPLS (0x8848) - There is at least 1 MPLS tag in the outer header
+  *		       (ethernet type 0x8848)
+  * E = multi MPLS - There is more than a single MPLS tag in the outer header
+  * F = inner MPLS - There is inner MPLS tag in the packet
+  * G = tunneled MAC - Set if the packet includes a tunneled MAC
+  * H = tunneled VLAN - Same as VLAN, but for a tunneled header
+  * I = pkt_is_frag - Packet is fragmented (ipv4 or ipv6)
+  * J = ipv6_ext - The packet has routing or destination ipv6 extension in inner
+  *		  or outer ipv6 headers
+  * K = RoCE - UDP packet detected as RoCEv2
+  * L = UDP_XSUM_0 - Set to 1 if L4 checksum is 0 in a UDP packet
+  * M = ESP - This is a ESP packet
+  * N = NAT_ESP - This is a ESP packet encapsulated in UDP NAT
+  */
+ #define ICE_PKT_TUNNEL_MAC	BIT(6)
+ #define ICE_PKT_TUNNEL_VLAN	BIT(7)
+ #define ICE_PKT_TUNNEL_MASK	(ICE_PKT_TUNNEL_MAC | ICE_PKT_TUNNEL_VLAN)
+ 
+ /* MDID 22
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|E|F|  G  |H|I|J| K |L|M|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = fin - fin flag in tcp header
+  * B = sync - sync flag in tcp header
+  * C = rst - rst flag in tcp header
+  * D = psh - psh flag in tcp header
+  * E = ack - ack flag in tcp header
+  * F = urg - urg flag in tcp header
+  * G = tunnel type (3b) - Flags used to decode tunnel type:
+  *			  * b000 - not a VXLAN/Geneve/GRE tunnel
+  *			  * b001 - VXLAN-GPE
+  *			  * b010 - VXLAN (non-GPE)
+  *			  * b011 - Geneve
+  *			  * b100 - GRE (no key, no xsum)
+  *			  * b101 - GREK (key, no xsum)
+  *			  * b110 - GREC (no key, xsum)
+  *			  * b111 - GREKC (key, xsum)
+  * H = UDP_GRE - Packet is UDP (VXLAN or VLAN_GPE or Geneve or MPLSoUDP or GRE)
+  *		 tunnel
+  * I = OAM - VXLAN/Geneve/tunneled NSH packet with the OAM bit set
+  * J = tunneled NSH - Packet has NSHoGRE or NSHoUDP
+  * K = switch (2b) - Direction on switch
+  *		     * b00 - normal
+  *		     * b01 - TX force only LAN
+  *		     * b10 - TX disable LAN
+  *		     * b11 - direct to VSI
+  * L = swpe - Represents SWPE bit in TX command
+  * M = sw_cmd - Switch command
+  *
+  * MDID 23
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|        R        |E|F|R|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = MAC error - Produced by MAC according to L2 error conditions
+  * B = PPRS no offload - FIFO overflow in PPRS or any problematic condition in
+  *			 PPRS ANA
+  * C = abort - Set when malicious packet is detected
+  * D = partial analysis - ANA's analysing got cut in the middle
+  *			 (header > 504B etc.)
+  * E = FLM - Flow director hit indication
+  * F = FDLONG - Flow direector long bucket indication
+  *
+  */
+ #define ICE_MDID_SIZE 2
+ #define ICE_META_DATA_ID_HW 255
+ 
+ enum ice_hw_metadata_id {
+ 	ICE_SOURCE_PORT_MDID = 16,
+ 	ICE_PTYPE_MDID = 17,
+ 	ICE_PACKET_LENGTH_MDID = 18,
+ 	ICE_SOURCE_VSI_MDID = 19,
+ 	ICE_PKT_VLAN_MDID = 20,
+ 	ICE_PKT_TUNNEL_MDID = 21,
+ 	ICE_PKT_TCP_MDID = 22,
+ 	ICE_PKT_ERROR_MDID = 23,
+ };
+ 
+ enum ice_hw_metadata_offset {
+ 	ICE_SOURCE_PORT_MDID_OFFSET = ICE_MDID_SIZE * ICE_SOURCE_PORT_MDID,
+ 	ICE_PTYPE_MDID_OFFSET = ICE_MDID_SIZE * ICE_PTYPE_MDID,
+ 	ICE_PACKET_LENGTH_MDID_OFFSET = ICE_MDID_SIZE * ICE_PACKET_LENGTH_MDID,
+ 	ICE_SOURCE_VSI_MDID_OFFSET = ICE_MDID_SIZE * ICE_SOURCE_VSI_MDID,
+ 	ICE_PKT_VLAN_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_VLAN_MDID,
+ 	ICE_PKT_TUNNEL_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_TUNNEL_MDID,
+ 	ICE_PKT_TCP_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_TCP_MDID,
+ 	ICE_PKT_ERROR_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_ERROR_MDID,
+ };
+ 
+ enum ice_pkt_flags {
+ 	ICE_PKT_FLAGS_VLAN = 0,
+ 	ICE_PKT_FLAGS_TUNNEL = 1,
+ 	ICE_PKT_FLAGS_TCP = 2,
+ 	ICE_PKT_FLAGS_ERROR = 3,
+ };
+ 
+ struct ice_hw_metadata {
+ 	__be16 source_port;
+ 	__be16 ptype;
+ 	__be16 packet_length;
+ 	__be16 source_vsi;
+ 	__be16 flags[4];
+ };
+ 
++>>>>>>> 03592a14b938 (ice: allow matching on meta data)
  union ice_prot_hdr {
  	struct ice_ether_hdr eth_hdr;
  	struct ice_ethtype_hdr ethertype;
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index a296d74d4420,9578bd0a2d65..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -4046,27 -4555,38 +4046,62 @@@ ice_free_res_cntr(struct ice_hw *hw, u
   * structure is added to that union.
   */
  static const struct ice_prot_ext_tbl_entry ice_prot_ext[ICE_PROTOCOL_LAST] = {
++<<<<<<< HEAD
 +	{ ICE_MAC_OFOS,		{ 0, 2, 4, 6, 8, 10, 12 } },
 +	{ ICE_MAC_IL,		{ 0, 2, 4, 6, 8, 10, 12 } },
 +	{ ICE_ETYPE_OL,		{ 0 } },
 +	{ ICE_ETYPE_IL,		{ 0 } },
 +	{ ICE_VLAN_OFOS,	{ 2, 0 } },
 +	{ ICE_IPV4_OFOS,	{ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18 } },
 +	{ ICE_IPV4_IL,		{ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18 } },
 +	{ ICE_IPV6_OFOS,	{ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
 +				 26, 28, 30, 32, 34, 36, 38 } },
 +	{ ICE_IPV6_IL,		{ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
 +				 26, 28, 30, 32, 34, 36, 38 } },
 +	{ ICE_TCP_IL,		{ 0, 2 } },
 +	{ ICE_UDP_OF,		{ 0, 2 } },
 +	{ ICE_UDP_ILOS,		{ 0, 2 } },
 +	{ ICE_VXLAN,		{ 8, 10, 12, 14 } },
 +	{ ICE_GENEVE,		{ 8, 10, 12, 14 } },
 +	{ ICE_NVGRE,            { 0, 2, 4, 6 } },
 +	{ ICE_PPPOE,		{ 0, 2, 4, 6 } },
 +	{ ICE_L2TPV3,		{ 0, 2, 4, 6, 8, 10 } },
 +	{ ICE_VLAN_EX,          { 2, 0 } },
 +	{ ICE_VLAN_IN,          { 2, 0 } },
++=======
+ 	ICE_PROTOCOL_ENTRY(ICE_MAC_OFOS, 0, 2, 4, 6, 8, 10, 12),
+ 	ICE_PROTOCOL_ENTRY(ICE_MAC_IL, 0, 2, 4, 6, 8, 10, 12),
+ 	ICE_PROTOCOL_ENTRY(ICE_ETYPE_OL, 0),
+ 	ICE_PROTOCOL_ENTRY(ICE_ETYPE_IL, 0),
+ 	ICE_PROTOCOL_ENTRY(ICE_VLAN_OFOS, 2, 0),
+ 	ICE_PROTOCOL_ENTRY(ICE_IPV4_OFOS, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18),
+ 	ICE_PROTOCOL_ENTRY(ICE_IPV4_IL,	0, 2, 4, 6, 8, 10, 12, 14, 16, 18),
+ 	ICE_PROTOCOL_ENTRY(ICE_IPV6_OFOS, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
+ 			   20, 22, 24, 26, 28, 30, 32, 34, 36, 38),
+ 	ICE_PROTOCOL_ENTRY(ICE_IPV6_IL, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
+ 			   22, 24, 26, 28, 30, 32, 34, 36, 38),
+ 	ICE_PROTOCOL_ENTRY(ICE_TCP_IL, 0, 2),
+ 	ICE_PROTOCOL_ENTRY(ICE_UDP_OF, 0, 2),
+ 	ICE_PROTOCOL_ENTRY(ICE_UDP_ILOS, 0, 2),
+ 	ICE_PROTOCOL_ENTRY(ICE_VXLAN, 8, 10, 12, 14),
+ 	ICE_PROTOCOL_ENTRY(ICE_GENEVE, 8, 10, 12, 14),
+ 	ICE_PROTOCOL_ENTRY(ICE_NVGRE, 0, 2, 4, 6),
+ 	ICE_PROTOCOL_ENTRY(ICE_GTP, 8, 10, 12, 14, 16, 18, 20, 22),
+ 	ICE_PROTOCOL_ENTRY(ICE_GTP_NO_PAY, 8, 10, 12, 14),
+ 	ICE_PROTOCOL_ENTRY(ICE_PPPOE, 0, 2, 4, 6),
+ 	ICE_PROTOCOL_ENTRY(ICE_L2TPV3, 0, 2, 4, 6, 8, 10),
+ 	ICE_PROTOCOL_ENTRY(ICE_VLAN_EX, 2, 0),
+ 	ICE_PROTOCOL_ENTRY(ICE_VLAN_IN, 2, 0),
+ 	ICE_PROTOCOL_ENTRY(ICE_HW_METADATA,
+ 			   ICE_SOURCE_PORT_MDID_OFFSET,
+ 			   ICE_PTYPE_MDID_OFFSET,
+ 			   ICE_PACKET_LENGTH_MDID_OFFSET,
+ 			   ICE_SOURCE_VSI_MDID_OFFSET,
+ 			   ICE_PKT_VLAN_MDID_OFFSET,
+ 			   ICE_PKT_TUNNEL_MDID_OFFSET,
+ 			   ICE_PKT_TCP_MDID_OFFSET,
+ 			   ICE_PKT_ERROR_MDID_OFFSET),
++>>>>>>> 03592a14b938 (ice: allow matching on meta data)
  };
  
  static struct ice_protocol_entry ice_prot_id_tbl[ICE_PROTOCOL_LAST] = {
@@@ -4747,69 -5270,6 +4783,72 @@@ ice_create_recipe_group(struct ice_hw *
  	return status;
  }
  
++<<<<<<< HEAD
 +/**
 + * ice_tun_type_match_word - determine if tun type needs a match mask
 + * @tun_type: tunnel type
 + * @mask: mask to be used for the tunnel
 + */
 +static bool ice_tun_type_match_word(enum ice_sw_tunnel_type tun_type, u16 *mask)
 +{
 +	switch (tun_type) {
 +	case ICE_SW_TUN_GENEVE:
 +	case ICE_SW_TUN_VXLAN:
 +	case ICE_SW_TUN_NVGRE:
 +		*mask = ICE_TUN_FLAG_MASK;
 +		return true;
 +
 +	default:
 +		*mask = 0;
 +		return false;
 +	}
 +}
 +
 +/**
 + * ice_add_special_words - Add words that are not protocols, such as metadata
 + * @rinfo: other information regarding the rule e.g. priority and action info
 + * @lkup_exts: lookup word structure
 + * @dvm_ena: is double VLAN mode enabled
 + */
 +static int
 +ice_add_special_words(struct ice_adv_rule_info *rinfo,
 +		      struct ice_prot_lkup_ext *lkup_exts, bool dvm_ena)
 +{
 +	u16 mask;
 +
 +	/* If this is a tunneled packet, then add recipe index to match the
 +	 * tunnel bit in the packet metadata flags.
 +	 */
 +	if (ice_tun_type_match_word(rinfo->tun_type, &mask)) {
 +		if (lkup_exts->n_val_words < ICE_MAX_CHAIN_WORDS) {
 +			u8 word = lkup_exts->n_val_words++;
 +
 +			lkup_exts->fv_words[word].prot_id = ICE_META_DATA_ID_HW;
 +			lkup_exts->fv_words[word].off = ICE_TUN_FLAG_MDID_OFF;
 +			lkup_exts->field_mask[word] = mask;
 +		} else {
 +			return -ENOSPC;
 +		}
 +	}
 +
 +	if (rinfo->vlan_type != 0 && dvm_ena) {
 +		if (lkup_exts->n_val_words < ICE_MAX_CHAIN_WORDS) {
 +			u8 word = lkup_exts->n_val_words++;
 +
 +			lkup_exts->fv_words[word].prot_id = ICE_META_DATA_ID_HW;
 +			lkup_exts->fv_words[word].off = ICE_VLAN_FLAG_MDID_OFF;
 +			lkup_exts->field_mask[word] =
 +					ICE_PKT_FLAGS_0_TO_15_VLAN_FLAGS_MASK;
 +		} else {
 +			return -ENOSPC;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 03592a14b938 (ice: allow matching on meta data)
  /* ice_get_compat_fv_bitmap - Get compatible field vector bitmap for rule
   * @hw: pointer to hardware structure
   * @rinfo: other information regarding the rule e.g. priority and action info
* Unmerged path drivers/net/ethernet/intel/ice/ice_protocol_type.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
diff --git a/drivers/net/ethernet/intel/ice/ice_switch.h b/drivers/net/ethernet/intel/ice/ice_switch.h
index d3caaa5116c8..b8043e41b864 100644
--- a/drivers/net/ethernet/intel/ice/ice_switch.h
+++ b/drivers/net/ethernet/intel/ice/ice_switch.h
@@ -177,10 +177,12 @@ struct ice_adv_rule_flags_info {
 };
 
 struct ice_adv_rule_info {
+	/* Store metadata values in rule info */
 	enum ice_sw_tunnel_type tun_type;
 	u16 vlan_type;
 	u16 fltr_rule_id;
 	u32 priority;
+	u16 src_vsi;
 	struct ice_sw_act_ctrl sw_act;
 	struct ice_adv_rule_flags_info flags_info;
 };
@@ -331,6 +333,8 @@ ice_free_res_cntr(struct ice_hw *hw, u8 type, u8 alloc_shared, u16 num_items,
 		  u16 counter_id);
 
 /* Switch/bridge related commands */
+void ice_rule_add_tunnel_metadata(struct ice_adv_lkup_elem *lkup);
+void ice_rule_add_vlan_metadata(struct ice_adv_lkup_elem *lkup);
 int
 ice_add_adv_rule(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,
 		 u16 lkups_cnt, struct ice_adv_rule_info *rinfo,
diff --git a/drivers/net/ethernet/intel/ice/ice_tc_lib.c b/drivers/net/ethernet/intel/ice/ice_tc_lib.c
index 98390439e3c8..6030e7ca797c 100644
--- a/drivers/net/ethernet/intel/ice/ice_tc_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_tc_lib.c
@@ -51,6 +51,10 @@ ice_tc_count_lkups(u32 flags, struct ice_tc_flower_lyr_2_4_hdrs *headers,
 	if (flags & (ICE_TC_FLWR_FIELD_VLAN | ICE_TC_FLWR_FIELD_VLAN_PRIO))
 		lkups_cnt++;
 
+	/* is VLAN TPID specified */
+	if (flags & ICE_TC_FLWR_FIELD_VLAN_TPID)
+		lkups_cnt++;
+
 	/* is CVLAN specified? */
 	if (flags & (ICE_TC_FLWR_FIELD_CVLAN | ICE_TC_FLWR_FIELD_CVLAN_PRIO))
 		lkups_cnt++;
@@ -77,6 +81,10 @@ ice_tc_count_lkups(u32 flags, struct ice_tc_flower_lyr_2_4_hdrs *headers,
 		     ICE_TC_FLWR_FIELD_SRC_L4_PORT))
 		lkups_cnt++;
 
+	/* matching for tunneled packets in metadata */
+	if (fltr->tunnel_type != TNL_LAST)
+		lkups_cnt++;
+
 	return lkups_cnt;
 }
 
@@ -282,6 +290,10 @@ ice_tc_fill_tunnel_outer(u32 flags, struct ice_tc_flower_fltr *fltr,
 		i++;
 	}
 
+	/* always fill matching on tunneled packets in metadata */
+	ice_rule_add_tunnel_metadata(&list[i]);
+	i++;
+
 	return i;
 }
 
@@ -352,10 +364,6 @@ ice_tc_fill_rules(struct ice_hw *hw, u32 flags,
 
 	/* copy VLAN info */
 	if (flags & (ICE_TC_FLWR_FIELD_VLAN | ICE_TC_FLWR_FIELD_VLAN_PRIO)) {
-		vlan_tpid = be16_to_cpu(headers->vlan_hdr.vlan_tpid);
-		rule_info->vlan_type =
-				ice_check_supported_vlan_tpid(vlan_tpid);
-
 		if (flags & ICE_TC_FLWR_FIELD_CVLAN)
 			list[i].type = ICE_VLAN_EX;
 		else
@@ -380,6 +388,15 @@ ice_tc_fill_rules(struct ice_hw *hw, u32 flags,
 		i++;
 	}
 
+	if (flags & ICE_TC_FLWR_FIELD_VLAN_TPID) {
+		vlan_tpid = be16_to_cpu(headers->vlan_hdr.vlan_tpid);
+		rule_info->vlan_type =
+				ice_check_supported_vlan_tpid(vlan_tpid);
+
+		ice_rule_add_vlan_metadata(&list[i]);
+		i++;
+	}
+
 	if (flags & (ICE_TC_FLWR_FIELD_CVLAN | ICE_TC_FLWR_FIELD_CVLAN_PRIO)) {
 		list[i].type = ICE_VLAN_IN;
 
@@ -1354,8 +1371,10 @@ ice_parse_cls_flower(struct net_device *filter_dev, struct ice_vsi *vsi,
 						 VLAN_PRIO_MASK);
 		}
 
-		if (match.mask->vlan_tpid)
+		if (match.mask->vlan_tpid) {
 			headers->vlan_hdr.vlan_tpid = match.key->vlan_tpid;
+			fltr->flags |= ICE_TC_FLWR_FIELD_VLAN_TPID;
+		}
 	}
 
 	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {
diff --git a/drivers/net/ethernet/intel/ice/ice_tc_lib.h b/drivers/net/ethernet/intel/ice/ice_tc_lib.h
index ff499ffecae5..4194ddf71957 100644
--- a/drivers/net/ethernet/intel/ice/ice_tc_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_tc_lib.h
@@ -32,6 +32,7 @@
 #define ICE_TC_FLWR_FIELD_L2TPV3_SESSID		BIT(26)
 #define ICE_TC_FLWR_FIELD_VLAN_PRIO		BIT(27)
 #define ICE_TC_FLWR_FIELD_CVLAN_PRIO		BIT(28)
+#define ICE_TC_FLWR_FIELD_VLAN_TPID		BIT(29)
 
 #define ICE_TC_FLOWER_MASK_32   0xFFFFFFFF
 
