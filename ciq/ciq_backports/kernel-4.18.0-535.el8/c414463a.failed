ice: move ice_is_malicious_vf() to ice_virtchnl.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit c414463ab1bb098e67f4c1a4ef64f3e97780f087
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/c414463a.failed

The ice_is_malicious_vf() function is currently implemented in ice_sriov.c
This function is not Single Root specific, and a future change is going to
refactor the ice_vc_process_vf_msg() function to call this instead of
calling it before ice_vc_process_vf_msg() in the main loop of
__ice_clean_ctrlq.

To make that change easier to review, first move this function into
ice_virtchnl.c but leave the call in __ice_clean_ctrlq() alone.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Tested-by: Marek Szlosek <marek.szlosek@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit c414463ab1bb098e67f4c1a4ef64f3e97780f087)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_sriov.c
#	drivers/net/ethernet/intel/ice/ice_sriov.h
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.c
index 5e3dfc4a023f,6fa62c3cedb0..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.c
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.c
@@@ -1776,66 -1777,3 +1776,69 @@@ void ice_restore_all_vfs_msi_state(stru
  		}
  	}
  }
++<<<<<<< HEAD
 +
 +/**
 + * ice_is_malicious_vf - helper function to detect a malicious VF
 + * @pf: ptr to struct ice_pf
 + * @event: pointer to the AQ event
 + * @num_msg_proc: the number of messages processed so far
 + * @num_msg_pending: the number of messages peinding in admin queue
 + */
 +bool
 +ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
 +		    u16 num_msg_proc, u16 num_msg_pending)
 +{
 +	s16 vf_id = le16_to_cpu(event->desc.retval);
 +	struct device *dev = ice_pf_to_dev(pf);
 +	struct ice_mbx_data mbxdata;
 +	bool malvf = false;
 +	struct ice_vf *vf;
 +	int status;
 +
 +	vf = ice_get_vf_by_id(pf, vf_id);
 +	if (!vf)
 +		return false;
 +
 +	if (test_bit(ICE_VF_STATE_DIS, vf->vf_states))
 +		goto out_put_vf;
 +
 +	mbxdata.num_msg_proc = num_msg_proc;
 +	mbxdata.num_pending_arq = num_msg_pending;
 +	mbxdata.max_num_msgs_mbx = pf->hw.mailboxq.num_rq_entries;
 +#define ICE_MBX_OVERFLOW_WATERMARK 64
 +	mbxdata.async_watermark_val = ICE_MBX_OVERFLOW_WATERMARK;
 +
 +	/* check to see if we have a malicious VF */
 +	status = ice_mbx_vf_state_handler(&pf->hw, &mbxdata, &vf->mbx_info, &malvf);
 +	if (status)
 +		dev_warn_ratelimited(dev, "Unable to check status of mailbox overflow for VF %u MAC %pM, status %d\n",
 +				     vf->vf_id, vf->dev_lan_addr, status);
 +
 +	if (malvf) {
 +		bool report_vf = false;
 +
 +		/* if the VF is malicious and we haven't let the user
 +		 * know about it, then let them know now
 +		 */
 +		status = ice_mbx_report_malvf(&pf->hw, &vf->mbx_info,
 +					      &report_vf);
 +		if (status)
 +			dev_dbg(dev, "Error reporting malicious VF\n");
 +
 +		if (report_vf) {
 +			struct ice_vsi *pf_vsi = ice_get_main_vsi(pf);
 +
 +			if (pf_vsi)
 +				dev_warn(dev, "VF MAC %pM on PF MAC %pM is generating asynchronous messages and may be overflowing the PF message queue. Please see the Adapter User Guide for more information\n",
 +					 &vf->dev_lan_addr[0],
 +					 pf_vsi->netdev->dev_addr);
 +		}
 +	}
 +
 +out_put_vf:
 +	ice_put_vf(vf);
 +	return malvf;
 +}
++=======
++>>>>>>> c414463ab1bb (ice: move ice_is_malicious_vf() to ice_virtchnl.c)
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.h
index 1082b0691a3f,346cb2666f3a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.h
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.h
@@@ -34,9 -34,6 +34,12 @@@ ice_get_vf_cfg(struct net_device *netde
  
  void ice_free_vfs(struct ice_pf *pf);
  void ice_restore_all_vfs_msi_state(struct pci_dev *pdev);
++<<<<<<< HEAD
 +bool
 +ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
 +		    u16 num_msg_proc, u16 num_msg_pending);
++=======
++>>>>>>> c414463ab1bb (ice: move ice_is_malicious_vf() to ice_virtchnl.c)
  
  int
  ice_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos,
@@@ -72,15 -69,6 +75,18 @@@ static inline void ice_print_vfs_mdd_ev
  static inline void ice_print_vf_rx_mdd_event(struct ice_vf *vf) { }
  static inline void ice_restore_all_vfs_msi_state(struct pci_dev *pdev) { }
  
++<<<<<<< HEAD
 +static inline bool
 +ice_is_malicious_vf(struct ice_pf __always_unused *pf,
 +		    struct ice_rq_event_info __always_unused *event,
 +		    u16 __always_unused num_msg_proc,
 +		    u16 __always_unused num_msg_pending)
 +{
 +	return false;
 +}
 +
++=======
++>>>>>>> c414463ab1bb (ice: move ice_is_malicious_vf() to ice_virtchnl.c)
  static inline int
  ice_sriov_configure(struct pci_dev __always_unused *pdev,
  		    int __always_unused num_vfs)
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.h
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl.c b/drivers/net/ethernet/intel/ice/ice_virtchnl.c
index 87267cca97b2..e110dbe70f61 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl.c
@@ -3835,6 +3835,51 @@ void ice_virtchnl_set_repr_ops(struct ice_vf *vf)
 	vf->virtchnl_ops = &ice_virtchnl_repr_ops;
 }
 
+/**
+ * ice_is_malicious_vf - helper function to detect a malicious VF
+ * @pf: ptr to struct ice_pf
+ * @event: pointer to the AQ event
+ * @mbxdata: data about the state of the mailbox
+ */
+bool
+ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
+		    struct ice_mbx_data *mbxdata)
+{
+	s16 vf_id = le16_to_cpu(event->desc.retval);
+	struct device *dev = ice_pf_to_dev(pf);
+	bool report_malvf = false;
+	struct ice_vf *vf;
+	int status;
+
+	vf = ice_get_vf_by_id(pf, vf_id);
+	if (!vf)
+		return false;
+
+	if (test_bit(ICE_VF_STATE_DIS, vf->vf_states))
+		goto out_put_vf;
+
+	/* check to see if we have a newly malicious VF */
+	status = ice_mbx_vf_state_handler(&pf->hw, mbxdata, &vf->mbx_info,
+					  &report_malvf);
+	if (status)
+		dev_warn_ratelimited(dev, "Unable to check status of mailbox overflow for VF %u MAC %pM, status %d\n",
+				     vf->vf_id, vf->dev_lan_addr, status);
+
+	if (report_malvf) {
+		struct ice_vsi *pf_vsi = ice_get_main_vsi(pf);
+		u8 zero_addr[ETH_ALEN] = {};
+
+		dev_warn(dev, "VF MAC %pM on PF MAC %pM is generating asynchronous messages and may be overflowing the PF message queue. Please see the Adapter User Guide for more information\n",
+			 vf->dev_lan_addr,
+			 pf_vsi ? pf_vsi->netdev->dev_addr : zero_addr);
+	}
+
+out_put_vf:
+	ice_put_vf(vf);
+
+	return vf->mbx_info.malicious;
+}
+
 /**
  * ice_vc_process_vf_msg - Process request from VF
  * @pf: pointer to the PF structure
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl.h b/drivers/net/ethernet/intel/ice/ice_virtchnl.h
index 6d5af29c855e..648a383fad85 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl.h
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl.h
@@ -63,6 +63,9 @@ int
 ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
 		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen);
 bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id);
+bool
+ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
+		    struct ice_mbx_data *mbxdata);
 void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event);
 #else /* CONFIG_PCI_IOV */
 static inline void ice_virtchnl_set_dflt_ops(struct ice_vf *vf) { }
@@ -83,6 +86,14 @@ static inline bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id)
 	return false;
 }
 
+static inline bool
+ice_is_malicious_vf(struct ice_pf __always_unused *pf,
+		    struct ice_rq_event_info __always_unused *event,
+		    struct ice_mbx_data *mbxdata)
+{
+	return false;
+}
+
 static inline void
 ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event)
 {
