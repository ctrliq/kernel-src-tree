ice: Add direction metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Marcin Szycik <marcin.szycik@linux.intel.com>
commit 0960a27bd479fdff21c14ff449dac85f86d7eb4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/0960a27b.failed

Currently it is possible to create a filter which breaks TX traffic, e.g.:

tc filter add dev $PF1 ingress protocol ip prio 1 flower ip_proto udp
dst_port $PORT action mirred egress redirect dev $VF1_PR

This adds a rule which might match both TX and RX traffic, and in TX path
the PF will actually receive the traffic, which breaks communication.

To fix this, add a match on direction metadata flag when adding a tc rule.

Because of the way metadata is currently handled, a duplicate lookup word
would appear if VLAN metadata is also added. The lookup would still work
correctly, but one word would be wasted. To prevent it, lookup 0 now always
contains all metadata. When any metadata needs to be added, it is added to
lookup 0 and lookup count is not incremented. This way, two flags residing
in the same word will take up one word, instead of two.

Note: the drop action is also affected, i.e. it will now only work in one
direction.

	Signed-off-by: Marcin Szycik <marcin.szycik@linux.intel.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
	Tested-by: Sujai Buvaneswaran <sujai.buvaneswaran@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 0960a27bd479fdff21c14ff449dac85f86d7eb4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_protocol_type.h
#	drivers/net/ethernet/intel/ice/ice_switch.c
#	drivers/net/ethernet/intel/ice/ice_switch.h
#	drivers/net/ethernet/intel/ice/ice_tc_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_protocol_type.h
index 454ed0bc710f,9812b98d107f..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_protocol_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_protocol_type.h
@@@ -212,6 -221,192 +212,195 @@@ struct ice_nvgre_hdr 
  	__be32 tni_flow;
  };
  
++<<<<<<< HEAD
++=======
+ /* Metadata information
+  *
+  * Not all MDIDs can be used by switch block. It depends on package version.
+  *
+  * MDID 16 (Rx offset)
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |  A  |   B     |   Reserved    |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = Source port where the transaction came from (3b).
+  *
+  * B = Destination TC of the packet. The TC is relative to a port (5b).
+  *
+  * MDID 17
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |      PTYPE        | Reserved  |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * PTYPE = Encodes the packet type (10b).
+  *
+  * MDID 18
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * | Packet length             | R |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * Packet length = Length of the packet in bytes
+  *		   (packet always carriers CRC) (14b).
+  * R = Reserved (2b).
+  *
+  * MDID 19
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |   Source VSI      | Reserved  |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * Source VSI = Source VSI of packet loopbacked in switch (for egress) (10b).
+  */
+ #define ICE_MDID_SOURCE_VSI_MASK GENMASK(9, 0)
+ 
+ /*
+  * MDID 20
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|E|F|R|R|G|H|I|J|K|L|M|N|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = DSI - set for DSI RX pkts.
+  * B = ipsec_decrypted - invalid on NIC.
+  * C = marker - this is a marker packet.
+  * D = from_network - for TX sets to 0
+  *		      for RX:
+  *		        * 1 - packet is from external link
+  *		        * 0 - packet source is from internal
+  * E = source_interface_is_rx - reflect the physical interface from where the
+  *				packet was received:
+  *				* 1 - Rx
+  *				* 0 - Tx
+  * F = from_mng - The bit signals that the packet's origin is the management.
+  * G = ucast - Outer L2 MAC address is unicast.
+  * H = mcast - Outer L2 MAC address is multicast.
+  * I = bcast - Outer L2 MAC address is broadcast.
+  * J = second_outer_mac_present - 2 outer MAC headers are present in the packet.
+  * K = STAG or BVLAN - Outer L2 header has STAG (ethernet type 0x88a8) or
+  *		       BVLAN (ethernet type 0x88a8).
+  * L = ITAG - Outer L2 header has ITAG *ethernet type 0x88e7)
+  * M = EVLAN (0x8100) - Outer L2 header has EVLAN (ethernet type 0x8100)
+  * N = EVLAN (0x9100) - Outer L2 header has EVLAN (ethernet type 0x9100)
+  */
+ #define ICE_PKT_FROM_NETWORK	BIT(3)
+ #define ICE_PKT_VLAN_STAG	BIT(12)
+ #define ICE_PKT_VLAN_ITAG	BIT(13)
+ #define ICE_PKT_VLAN_EVLAN	(BIT(14) | BIT(15))
+ #define ICE_PKT_VLAN_MASK	(ICE_PKT_VLAN_STAG | ICE_PKT_VLAN_ITAG | \
+ 				ICE_PKT_VLAN_EVLAN)
+ /* MDID 21
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|E|F|G|H|I|J|R|R|K|L|M|N|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = VLAN (0x8100) - Outer L2 header has VLAN (ethernet type 0x8100)
+  * B = NSHoE - Outer L2 header has NSH (ethernet type 0x894f)
+  * C = MPLS (0x8847) - There is at least 1 MPLS tag in the outer header
+  *		       (ethernet type 0x8847)
+  * D = MPLS (0x8848) - There is at least 1 MPLS tag in the outer header
+  *		       (ethernet type 0x8848)
+  * E = multi MPLS - There is more than a single MPLS tag in the outer header
+  * F = inner MPLS - There is inner MPLS tag in the packet
+  * G = tunneled MAC - Set if the packet includes a tunneled MAC
+  * H = tunneled VLAN - Same as VLAN, but for a tunneled header
+  * I = pkt_is_frag - Packet is fragmented (ipv4 or ipv6)
+  * J = ipv6_ext - The packet has routing or destination ipv6 extension in inner
+  *		  or outer ipv6 headers
+  * K = RoCE - UDP packet detected as RoCEv2
+  * L = UDP_XSUM_0 - Set to 1 if L4 checksum is 0 in a UDP packet
+  * M = ESP - This is a ESP packet
+  * N = NAT_ESP - This is a ESP packet encapsulated in UDP NAT
+  */
+ #define ICE_PKT_TUNNEL_MAC	BIT(6)
+ #define ICE_PKT_TUNNEL_VLAN	BIT(7)
+ #define ICE_PKT_TUNNEL_MASK	(ICE_PKT_TUNNEL_MAC | ICE_PKT_TUNNEL_VLAN)
+ 
+ /* MDID 22
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|E|F|  G  |H|I|J| K |L|M|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = fin - fin flag in tcp header
+  * B = sync - sync flag in tcp header
+  * C = rst - rst flag in tcp header
+  * D = psh - psh flag in tcp header
+  * E = ack - ack flag in tcp header
+  * F = urg - urg flag in tcp header
+  * G = tunnel type (3b) - Flags used to decode tunnel type:
+  *			  * b000 - not a VXLAN/Geneve/GRE tunnel
+  *			  * b001 - VXLAN-GPE
+  *			  * b010 - VXLAN (non-GPE)
+  *			  * b011 - Geneve
+  *			  * b100 - GRE (no key, no xsum)
+  *			  * b101 - GREK (key, no xsum)
+  *			  * b110 - GREC (no key, xsum)
+  *			  * b111 - GREKC (key, xsum)
+  * H = UDP_GRE - Packet is UDP (VXLAN or VLAN_GPE or Geneve or MPLSoUDP or GRE)
+  *		 tunnel
+  * I = OAM - VXLAN/Geneve/tunneled NSH packet with the OAM bit set
+  * J = tunneled NSH - Packet has NSHoGRE or NSHoUDP
+  * K = switch (2b) - Direction on switch
+  *		     * b00 - normal
+  *		     * b01 - TX force only LAN
+  *		     * b10 - TX disable LAN
+  *		     * b11 - direct to VSI
+  * L = swpe - Represents SWPE bit in TX command
+  * M = sw_cmd - Switch command
+  *
+  * MDID 23
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |A|B|C|D|        R        |E|F|R|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * A = MAC error - Produced by MAC according to L2 error conditions
+  * B = PPRS no offload - FIFO overflow in PPRS or any problematic condition in
+  *			 PPRS ANA
+  * C = abort - Set when malicious packet is detected
+  * D = partial analysis - ANA's analysing got cut in the middle
+  *			 (header > 504B etc.)
+  * E = FLM - Flow director hit indication
+  * F = FDLONG - Flow direector long bucket indication
+  *
+  */
+ #define ICE_MDID_SIZE 2
+ #define ICE_META_DATA_ID_HW 255
+ 
+ enum ice_hw_metadata_id {
+ 	ICE_SOURCE_PORT_MDID = 16,
+ 	ICE_PTYPE_MDID = 17,
+ 	ICE_PACKET_LENGTH_MDID = 18,
+ 	ICE_SOURCE_VSI_MDID = 19,
+ 	ICE_PKT_VLAN_MDID = 20,
+ 	ICE_PKT_TUNNEL_MDID = 21,
+ 	ICE_PKT_TCP_MDID = 22,
+ 	ICE_PKT_ERROR_MDID = 23,
+ };
+ 
+ enum ice_hw_metadata_offset {
+ 	ICE_SOURCE_PORT_MDID_OFFSET = ICE_MDID_SIZE * ICE_SOURCE_PORT_MDID,
+ 	ICE_PTYPE_MDID_OFFSET = ICE_MDID_SIZE * ICE_PTYPE_MDID,
+ 	ICE_PACKET_LENGTH_MDID_OFFSET = ICE_MDID_SIZE * ICE_PACKET_LENGTH_MDID,
+ 	ICE_SOURCE_VSI_MDID_OFFSET = ICE_MDID_SIZE * ICE_SOURCE_VSI_MDID,
+ 	ICE_PKT_VLAN_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_VLAN_MDID,
+ 	ICE_PKT_TUNNEL_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_TUNNEL_MDID,
+ 	ICE_PKT_TCP_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_TCP_MDID,
+ 	ICE_PKT_ERROR_MDID_OFFSET = ICE_MDID_SIZE * ICE_PKT_ERROR_MDID,
+ };
+ 
+ enum ice_pkt_flags {
+ 	ICE_PKT_FLAGS_VLAN = 0,
+ 	ICE_PKT_FLAGS_TUNNEL = 1,
+ 	ICE_PKT_FLAGS_TCP = 2,
+ 	ICE_PKT_FLAGS_ERROR = 3,
+ };
+ 
+ struct ice_hw_metadata {
+ 	__be16 source_port;
+ 	__be16 ptype;
+ 	__be16 packet_length;
+ 	__be16 source_vsi;
+ 	__be16 flags[4];
+ };
+ 
++>>>>>>> 0960a27bd479 (ice: Add direction metadata)
  union ice_prot_hdr {
  	struct ice_ether_hdr eth_hdr;
  	struct ice_ethtype_hdr ethertype;
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index b85dbb54c188,dcbb69bc9f5a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -5511,6 -6055,33 +5511,36 @@@ ice_adv_add_update_vsi_list(struct ice_
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ void ice_rule_add_tunnel_metadata(struct ice_adv_lkup_elem *lkup)
+ {
+ 	lkup->type = ICE_HW_METADATA;
+ 	lkup->m_u.metadata.flags[ICE_PKT_FLAGS_TUNNEL] |=
+ 		cpu_to_be16(ICE_PKT_TUNNEL_MASK);
+ }
+ 
+ void ice_rule_add_direction_metadata(struct ice_adv_lkup_elem *lkup)
+ {
+ 	lkup->type = ICE_HW_METADATA;
+ 	lkup->m_u.metadata.flags[ICE_PKT_FLAGS_VLAN] |=
+ 		cpu_to_be16(ICE_PKT_FROM_NETWORK);
+ }
+ 
+ void ice_rule_add_vlan_metadata(struct ice_adv_lkup_elem *lkup)
+ {
+ 	lkup->type = ICE_HW_METADATA;
+ 	lkup->m_u.metadata.flags[ICE_PKT_FLAGS_VLAN] |=
+ 		cpu_to_be16(ICE_PKT_VLAN_MASK);
+ }
+ 
+ void ice_rule_add_src_vsi_metadata(struct ice_adv_lkup_elem *lkup)
+ {
+ 	lkup->type = ICE_HW_METADATA;
+ 	lkup->m_u.metadata.source_vsi = cpu_to_be16(ICE_MDID_SOURCE_VSI_MASK);
+ }
+ 
++>>>>>>> 0960a27bd479 (ice: Add direction metadata)
  /**
   * ice_add_adv_rule - helper function to create an advanced switch rule
   * @hw: pointer to the hardware structure
diff --cc drivers/net/ethernet/intel/ice/ice_switch.h
index 7ed1360343ad,0bd4320e39df..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.h
+++ b/drivers/net/ethernet/intel/ice/ice_switch.h
@@@ -329,8 -355,13 +329,15 @@@ ice_alloc_res_cntr(struct ice_hw *hw, u
  int
  ice_free_res_cntr(struct ice_hw *hw, u8 type, u8 alloc_shared, u16 num_items,
  		  u16 counter_id);
 -int ice_share_res(struct ice_hw *hw, u16 type, u8 shared, u16 res_id);
  
  /* Switch/bridge related commands */
++<<<<<<< HEAD
++=======
+ void ice_rule_add_tunnel_metadata(struct ice_adv_lkup_elem *lkup);
+ void ice_rule_add_direction_metadata(struct ice_adv_lkup_elem *lkup);
+ void ice_rule_add_vlan_metadata(struct ice_adv_lkup_elem *lkup);
+ void ice_rule_add_src_vsi_metadata(struct ice_adv_lkup_elem *lkup);
++>>>>>>> 0960a27bd479 (ice: Add direction metadata)
  int
  ice_add_adv_rule(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,
  		 u16 lkups_cnt, struct ice_adv_rule_info *rinfo,
diff --cc drivers/net/ethernet/intel/ice/ice_tc_lib.c
index 98390439e3c8,37b54db91df2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_tc_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_tc_lib.c
@@@ -282,6 -327,9 +289,12 @@@ ice_tc_fill_tunnel_outer(u32 flags, str
  		i++;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* always fill matching on tunneled packets in metadata */
+ 	ice_rule_add_tunnel_metadata(&list[ICE_TC_METADATA_LKUP_IDX]);
+ 
++>>>>>>> 0960a27bd479 (ice: Add direction metadata)
  	return i;
  }
  
@@@ -380,6 -427,14 +396,17 @@@ ice_tc_fill_rules(struct ice_hw *hw, u3
  		i++;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (flags & ICE_TC_FLWR_FIELD_VLAN_TPID) {
+ 		vlan_tpid = be16_to_cpu(headers->vlan_hdr.vlan_tpid);
+ 		rule_info->vlan_type =
+ 				ice_check_supported_vlan_tpid(vlan_tpid);
+ 
+ 		ice_rule_add_vlan_metadata(&list[ICE_TC_METADATA_LKUP_IDX]);
+ 	}
+ 
++>>>>>>> 0960a27bd479 (ice: Add direction metadata)
  	if (flags & (ICE_TC_FLWR_FIELD_CVLAN | ICE_TC_FLWR_FIELD_CVLAN_PRIO)) {
  		list[i].type = ICE_VLAN_IN;
  
* Unmerged path drivers/net/ethernet/intel/ice/ice_protocol_type.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
