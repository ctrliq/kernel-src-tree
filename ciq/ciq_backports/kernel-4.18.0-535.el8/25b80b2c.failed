scsi: scsi_debug: Protect block_unblock_all_queues() with mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author John Garry <john.g.garry@oracle.com>
commit 25b80b2c7582ea15ba90b8007f1e1f1b8fc762b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/25b80b2c.failed

There is no reason that calls to block_unblock_all_queues() from different
context can't race with one another, so protect with the
sdebug_host_list_mutex. There's no need for a more fine-grained per shost
locking here (and we don't have a per-host lock anyway).

Also simplify some touched code in sdebug_change_qdepth().

	Signed-off-by: John Garry <john.g.garry@oracle.com>
Link: https://lore.kernel.org/r/20230327074310.1862889-5-john.g.garry@oracle.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 25b80b2c7582ea15ba90b8007f1e1f1b8fc762b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_debug.c
diff --cc drivers/scsi/scsi_debug.c
index 58c45f546123,cd05e2f87417..000000000000
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@@ -7386,16 -7358,13 +7397,20 @@@ static void sdebug_do_remove_host(bool 
  
  static int sdebug_change_qdepth(struct scsi_device *sdev, int qdepth)
  {
 -	struct sdebug_dev_info *devip = sdev->hostdata;
 -
 -	if (!devip)
 -		return	-ENODEV;
 +	int num_in_q = 0;
 +	struct sdebug_dev_info *devip;
  
+ 	mutex_lock(&sdebug_host_list_mutex);
  	block_unblock_all_queues(true);
++<<<<<<< HEAD
 +	devip = (struct sdebug_dev_info *)sdev->hostdata;
 +	if (NULL == devip) {
 +		block_unblock_all_queues(false);
 +		return	-ENODEV;
 +	}
 +	num_in_q = atomic_read(&devip->num_in_q);
++=======
++>>>>>>> 25b80b2c7582 (scsi: scsi_debug: Protect block_unblock_all_queues() with mutex)
  
  	if (qdepth > SDEBUG_CANQUEUE) {
  		qdepth = SDEBUG_CANQUEUE;
@@@ -7407,11 -7376,12 +7422,20 @@@
  	if (qdepth != sdev->queue_depth)
  		scsi_change_queue_depth(sdev, qdepth);
  
++<<<<<<< HEAD
 +	if (SDEBUG_OPT_Q_NOISE & sdebug_opts) {
 +		sdev_printk(KERN_INFO, sdev, "%s: qdepth=%d, num_in_q=%d\n",
 +			    __func__, qdepth, num_in_q);
 +	}
 +	block_unblock_all_queues(false);
++=======
+ 	block_unblock_all_queues(false);
+ 	mutex_unlock(&sdebug_host_list_mutex);
+ 
+ 	if (SDEBUG_OPT_Q_NOISE & sdebug_opts)
+ 		sdev_printk(KERN_INFO, sdev, "%s: qdepth=%d\n", __func__, qdepth);
+ 
++>>>>>>> 25b80b2c7582 (scsi: scsi_debug: Protect block_unblock_all_queues() with mutex)
  	return sdev->queue_depth;
  }
  
* Unmerged path drivers/scsi/scsi_debug.c
