scsi: scsi_debug: Fix qc_lock use in sdebug_blk_mq_poll()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Damien Le Moal <damien.lemoal@opensource.wdc.com>
commit 3fd07aecb75003fbcb0b7c3124d12f71ffd360d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/3fd07aec.failed

The use of the 'locked' boolean variable to control locking and unlocking
of the qc_lock spinlock of struct sdebug_queue confuses sparse, leading to
a warning about an unexpected unlock. Simplify the qc_lock lock/unlock
handling code of this function to avoid this warning by removing the
'locked' boolean variable. This change also fixes unlocked access to the
in_use_bm bitmap with the find_first_bit() function.

Link: https://lore.kernel.org/r/20220301113009.595857-3-damien.lemoal@opensource.wdc.com
Fixes: b05d4e481eff ("scsi: scsi_debug: Refine sdebug_blk_mq_poll()")
	Cc: stable@vger.kernel.org
	Signed-off-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3fd07aecb75003fbcb0b7c3124d12f71ffd360d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_debug.c
diff --cc drivers/scsi/scsi_debug.c
index cbf25e8d2473,25fa8e93f5a8..000000000000
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@@ -7527,12 -7520,17 +7527,14 @@@ static int sdebug_blk_mq_poll(struct Sc
  	struct sdebug_defer *sd_dp;
  
  	sqp = sdebug_q_arr + queue_num;
 -	qc_idx = find_first_bit(sqp->in_use_bm, sdebug_max_queue);
 -	if (qc_idx >= sdebug_max_queue)
 -		return 0;
 +	spin_lock_irqsave(&sqp->qc_lock, iflags);
  
+ 	spin_lock_irqsave(&sqp->qc_lock, iflags);
+ 
  	for (first = true; first || qc_idx + 1 < sdebug_max_queue; )   {
  		if (first) {
 +			qc_idx = find_first_bit(sqp->in_use_bm, sdebug_max_queue);
  			first = false;
 -			if (!test_bit(qc_idx, sqp->in_use_bm))
 -				continue;
  		} else {
  			qc_idx = find_next_bit(sqp->in_use_bm, sdebug_max_queue, qc_idx + 1);
  		}
@@@ -7585,11 -7583,15 +7587,23 @@@
  		}
  		WRITE_ONCE(sd_dp->defer_t, SDEB_DEFER_NONE);
  		spin_unlock_irqrestore(&sqp->qc_lock, iflags);
++<<<<<<< HEAD
 +		scp->scsi_done(scp); /* callback to mid level */
 +		spin_lock_irqsave(&sqp->qc_lock, iflags);
 +		num_entries++;
 +	}
 +	spin_unlock_irqrestore(&sqp->qc_lock, iflags);
++=======
+ 		scsi_done(scp); /* callback to mid level */
+ 		num_entries++;
+ 		spin_lock_irqsave(&sqp->qc_lock, iflags);
+ 		if (find_first_bit(sqp->in_use_bm, sdebug_max_queue) >= sdebug_max_queue)
+ 			break;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&sqp->qc_lock, iflags);
+ 
++>>>>>>> 3fd07aecb750 (scsi: scsi_debug: Fix qc_lock use in sdebug_blk_mq_poll())
  	if (num_entries > 0)
  		atomic_add(num_entries, &sdeb_mq_poll_count);
  	return num_entries;
* Unmerged path drivers/scsi/scsi_debug.c
