fuse: truncate pagecache on atomic_o_trunc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 76224355db7570cbe6b6f75c8929a1558828dd55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/76224355.failed

fuse_finish_open() will be called with FUSE_NOWRITE in case of atomic
O_TRUNC.  This can deadlock with fuse_wait_on_page_writeback() in
fuse_launder_page() triggered by invalidate_inode_pages2().

Fix by replacing invalidate_inode_pages2() in fuse_finish_open() with a
truncate_pagecache() call.  This makes sense regardless of FOPEN_KEEP_CACHE
or fc->writeback cache, so do it unconditionally.

	Reported-by: Xie Yongji <xieyongji@bytedance.com>
Reported-and-tested-by: syzbot+bea44a5189836d956894@syzkaller.appspotmail.com
Fixes: e4648309b85a ("fuse: truncate pending writes on O_TRUNC")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 76224355db7570cbe6b6f75c8929a1558828dd55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index 62719361c7f9,5e5efb66c7d7..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -200,10 -198,11 +200,17 @@@ void fuse_finish_open(struct inode *ino
  	struct fuse_file *ff = file->private_data;
  	struct fuse_conn *fc = get_fuse_conn(inode);
  
++<<<<<<< HEAD
 +	if (!(ff->open_flags & FOPEN_KEEP_CACHE))
 +		invalidate_inode_pages2(inode->i_mapping);
 +	if (ff->open_flags & FOPEN_NONSEEKABLE)
++=======
+ 	if (ff->open_flags & FOPEN_STREAM)
+ 		stream_open(inode, file);
+ 	else if (ff->open_flags & FOPEN_NONSEEKABLE)
++>>>>>>> 76224355db75 (fuse: truncate pagecache on atomic_o_trunc)
  		nonseekable_open(inode, file);
+ 
  	if (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {
  		struct fuse_inode *fi = get_fuse_inode(inode);
  
* Unmerged path fs/fuse/file.c
