ice: refactor ice_vf_lib to make functions static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Jan Sokolowski <jan.sokolowski@intel.com>
commit cc9c60c9edfed4fa629975848e80a45c17332b9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/cc9c60c9.failed

As following methods are not used outside ice_vf_lib,
they can be made static:
ice_vf_rebuild_host_vlan_cfg
ice_vf_rebuild_host_tx_rate_cfg
ice_vf_set_host_trust_cfg
ice_vf_rebuild_host_mac_cfg
ice_vf_rebuild_aggregator_node_cfg
ice_vf_rebuild_host_cfg
ice_set_vf_state_qs_dis
ice_vf_set_initialized

In order to achieve that, the order in which these
were defined was reorganized.

	Signed-off-by: Jan Sokolowski <jan.sokolowski@intel.com>
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit cc9c60c9edfed4fa629975848e80a45c17332b9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_vf_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_vf_lib.c
index 14da7ebaaead,20c4beaa05d8..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_vf_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_vf_lib.c
@@@ -1296,18 -1328,33 +1313,50 @@@ void ice_vf_vsi_release(struct ice_vf *
  }
  
  /**
++<<<<<<< HEAD
 + * ice_vf_set_initialized - VF is ready for VIRTCHNL communication
 + * @vf: VF to set in initialized state
 + *
 + * After this function the VF will be ready to receive/handle the
 + * VIRTCHNL_OP_GET_VF_RESOURCES message
 + */
 +void ice_vf_set_initialized(struct ice_vf *vf)
 +{
 +	ice_set_vf_state_qs_dis(vf);
 +	clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);
 +	clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);
 +	clear_bit(ICE_VF_STATE_DIS, vf->vf_states);
 +	set_bit(ICE_VF_STATE_INIT, vf->vf_states);
 +	memset(&vf->vlan_v2_caps, 0, sizeof(vf->vlan_v2_caps));
++=======
+  * ice_get_vf_ctrl_vsi - Get first VF control VSI pointer
+  * @pf: the PF private structure
+  * @vsi: pointer to the VSI
+  *
+  * Return first found VF control VSI other than the vsi
+  * passed by parameter. This function is used to determine
+  * whether new resources have to be allocated for control VSI
+  * or they can be shared with existing one.
+  *
+  * Return found VF control VSI pointer other itself. Return
+  * NULL Otherwise.
+  *
+  */
+ struct ice_vsi *ice_get_vf_ctrl_vsi(struct ice_pf *pf, struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi *ctrl_vsi = NULL;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	rcu_read_lock();
+ 	ice_for_each_vf_rcu(pf, bkt, vf) {
+ 		if (vf != vsi->vf && vf->ctrl_vsi_idx != ICE_NO_VSI) {
+ 			ctrl_vsi = pf->vsi[vf->ctrl_vsi_idx];
+ 			break;
+ 		}
+ 	}
+ 
+ 	rcu_read_unlock();
+ 	return ctrl_vsi;
++>>>>>>> cc9c60c9edfe (ice: refactor ice_vf_lib to make functions static)
  }
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_lib.c
diff --git a/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h b/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h
index 6f3293b793b5..0c7e77c0a09f 100644
--- a/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h
+++ b/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h
@@ -32,13 +32,11 @@ int ice_vsi_apply_spoofchk(struct ice_vsi *vsi, bool enable);
 bool ice_is_vf_trusted(struct ice_vf *vf);
 bool ice_vf_has_no_qs_ena(struct ice_vf *vf);
 bool ice_is_vf_link_up(struct ice_vf *vf);
-void ice_vf_rebuild_host_cfg(struct ice_vf *vf);
 void ice_vf_ctrl_invalidate_vsi(struct ice_vf *vf);
 void ice_vf_ctrl_vsi_release(struct ice_vf *vf);
 struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf);
 int ice_vf_init_host_cfg(struct ice_vf *vf, struct ice_vsi *vsi);
 void ice_vf_invalidate_vsi(struct ice_vf *vf);
 void ice_vf_vsi_release(struct ice_vf *vf);
-void ice_vf_set_initialized(struct ice_vf *vf);
 
 #endif /* _ICE_VF_LIB_PRIVATE_H_ */
