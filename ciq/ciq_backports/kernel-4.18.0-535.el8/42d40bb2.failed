ice: introduce ice_pf_src_tmr_owned

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 42d40bb21e332151da6fb689bf7d4af8195866ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/42d40bb2.failed

Add ice_pf_src_tmr_owned() macro to check the function capability bit
indicating if the current function owns the PTP hardware clock. This is
slightly shorter than the more verbose access via
hw.func_caps.ts_func_info.src_tmr_owned. Use this where possible rather
than open coding its equivalent.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 42d40bb21e332151da6fb689bf7d4af8195866ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 77eb6cc5cf05,1549890a3cbf..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -4290,13 -3985,21 +4290,24 @@@ void ice_init_feature_support(struct ic
  	case ICE_DEV_ID_E810C_BACKPLANE:
  	case ICE_DEV_ID_E810C_QSFP:
  	case ICE_DEV_ID_E810C_SFP:
 -	case ICE_DEV_ID_E810_XXV_BACKPLANE:
 -	case ICE_DEV_ID_E810_XXV_QSFP:
 -	case ICE_DEV_ID_E810_XXV_SFP:
  		ice_set_feature_support(pf, ICE_F_DSCP);
++<<<<<<< HEAD
 +		ice_set_feature_support(pf, ICE_F_PTP_EXTTS);
 +		if (ice_is_e810t(&pf->hw)) {
++=======
+ 		if (ice_is_phy_rclk_present(&pf->hw))
+ 			ice_set_feature_support(pf, ICE_F_PHY_RCLK);
+ 		/* If we don't own the timer - don't enable other caps */
+ 		if (!ice_pf_src_tmr_owned(pf))
+ 			break;
+ 		if (ice_is_cgu_present(&pf->hw))
+ 			ice_set_feature_support(pf, ICE_F_CGU);
+ 		if (ice_is_clock_mux_present_e810t(&pf->hw))
++>>>>>>> 42d40bb21e33 (ice: introduce ice_pf_src_tmr_owned)
  			ice_set_feature_support(pf, ICE_F_SMA_CTRL);
 -		if (ice_gnss_is_gps_present(&pf->hw))
 -			ice_set_feature_support(pf, ICE_F_GNSS);
 +			if (ice_gnss_is_gps_present(&pf->hw))
 +				ice_set_feature_support(pf, ICE_F_GNSS);
 +		}
  		break;
  	default:
  		break;
diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index f6ff90f05780..bb785c5a22c2 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -196,6 +196,8 @@
 
 #define ice_pf_to_dev(pf) (&((pf)->pdev->dev))
 
+#define ice_pf_src_tmr_owned(pf) ((pf)->hw.func_caps.ts_func_info.src_tmr_owned)
+
 enum ice_feature {
 	ICE_F_DSCP,
 	ICE_F_PTP_EXTTS,
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index 93d9f8364ab7..b494600b186a 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -3151,7 +3151,7 @@ static irqreturn_t ice_misc_intr(int __always_unused irq, void *data)
 
 		ena_mask &= ~PFINT_OICR_TSYN_EVNT_M;
 
-		if (hw->func_caps.ts_func_info.src_tmr_owned) {
+		if (ice_pf_src_tmr_owned(pf)) {
 			/* Save EVENTs from GLTSYN register */
 			pf->ptp.ext_ts_irq |= gltsyn_stat &
 					      (GLTSYN_STAT_EVENT0_M |
diff --git a/drivers/net/ethernet/intel/ice/ice_ptp.c b/drivers/net/ethernet/intel/ice/ice_ptp.c
index ef0fc73589be..d0c8fecc1b10 100644
--- a/drivers/net/ethernet/intel/ice/ice_ptp.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.c
@@ -436,7 +436,7 @@ static void ice_clear_ptp_clock_index(struct ice_pf *pf)
 	int err;
 
 	/* Do not clear the index if we don't own the timer */
-	if (!hw->func_caps.ts_func_info.src_tmr_owned)
+	if (!ice_pf_src_tmr_owned(pf))
 		return;
 
 	tmr_idx = hw->func_caps.ts_func_info.tmr_index_assoc;
@@ -2511,7 +2511,7 @@ void ice_ptp_reset(struct ice_pf *pf)
 	if (test_bit(ICE_PFR_REQ, pf->state))
 		goto pfr;
 
-	if (!hw->func_caps.ts_func_info.src_tmr_owned)
+	if (!ice_pf_src_tmr_owned(pf))
 		goto reset_ts;
 
 	err = ice_ptp_init_phc(hw);
@@ -2763,7 +2763,7 @@ void ice_ptp_init(struct ice_pf *pf)
 	/* If this function owns the clock hardware, it must allocate and
 	 * configure the PTP clock device to represent it.
 	 */
-	if (hw->func_caps.ts_func_info.src_tmr_owned) {
+	if (ice_pf_src_tmr_owned(pf)) {
 		err = ice_ptp_init_owner(pf);
 		if (err)
 			goto err;
