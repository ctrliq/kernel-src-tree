blk-mq: don't count completed flush data request as inflight in case of quiesce

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-535.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 0e4237ae8d159e3d28f3cd83146a46f576ffb586
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-535.el8/0e4237ae.failed

Request queue quiesce may interrupt flush sequence, and the original request
may have been marked as COMPLETE, but can't get finished because of
queue quiesce.

This way is fine from driver viewpoint, because flush sequence is block
layer concept, and it isn't related with driver.

However, driver(such as dm-rq) can call blk_mq_queue_inflight() to count &
drain inflight requests, then the wait & drain never gets done because
the completed & not-finished flush request is counted as inflight.

Fix this issue by not counting completed flush data request as inflight in
case of quiesce.

	Cc: Mike Snitzer <snitzer@kernel.org>
	Cc: David Jeffery <djeffery@redhat.com>
	Cc: John Pittman <jpittman@redhat.com>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
Link: https://lore.kernel.org/r/20231201085605.577730-1-ming.lei@redhat.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 0e4237ae8d159e3d28f3cd83146a46f576ffb586)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 4ccb2724b338,ac18f802c027..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -882,25 -1512,26 +882,48 @@@ void blk_mq_delay_kick_requeue_list(str
  }
  EXPORT_SYMBOL(blk_mq_delay_kick_requeue_list);
  
++<<<<<<< HEAD
 +struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)
 +{
 +	if (tag < tags->nr_tags) {
 +		prefetch(tags->rqs[tag]);
 +		return tags->rqs[tag];
 +	}
 +
 +	return NULL;
 +}
 +EXPORT_SYMBOL(blk_mq_tag_to_rq);
 +
 +static bool blk_mq_rq_inflight(struct blk_mq_hw_ctx *hctx, struct request *rq,
 +			       void *priv, bool reserved)
 +{
 +	/*
 +	 * If we find a request that isn't idle and the queue matches,
 +	 * we know the queue is busy. Return false to stop the iteration.
 +	 */
 +	if (blk_mq_request_started(rq) && rq->q == hctx->queue) {
++=======
+ static bool blk_is_flush_data_rq(struct request *rq)
+ {
+ 	return (rq->rq_flags & RQF_FLUSH_SEQ) && !is_flush_rq(rq);
+ }
+ 
+ static bool blk_mq_rq_inflight(struct request *rq, void *priv)
+ {
+ 	/*
+ 	 * If we find a request that isn't idle we know the queue is busy
+ 	 * as it's checked in the iter.
+ 	 * Return false to stop the iteration.
+ 	 *
+ 	 * In case of queue quiesce, if one flush data request is completed,
+ 	 * don't count it as inflight given the flush sequence is suspended,
+ 	 * and the original flush data request is invisible to driver, just
+ 	 * like other pending requests because of quiesce
+ 	 */
+ 	if (blk_mq_request_started(rq) && !(blk_queue_quiesced(rq->q) &&
+ 				blk_is_flush_data_rq(rq) &&
+ 				blk_mq_request_completed(rq))) {
++>>>>>>> 0e4237ae8d15 (blk-mq: don't count completed flush data request as inflight in case of quiesce)
  		bool *busy = priv;
  
  		*busy = true;
* Unmerged path block/blk-mq.c
