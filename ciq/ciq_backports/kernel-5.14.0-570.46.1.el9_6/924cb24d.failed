scsi: fnic: Stop using the SCSI pointer

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Bart Van Assche <bvanassche@acm.org>
commit 924cb24df4fc4d08d32fcb42fa967fdc3f2137cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/924cb24d.failed

Set .cmd_size in the SCSI host template instead of using the SCSI pointer
from struct scsi_cmnd. This patch prepares for removal of the SCSI pointer
from struct scsi_cmnd.

Link: https://lore.kernel.org/r/20220218195117.25689-23-bvanassche@acm.org
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 924cb24df4fc4d08d32fcb42fa967fdc3f2137cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic_scsi.c
diff --cc drivers/scsi/fnic/fnic_scsi.c
index 573859282533,3c00e5b88350..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -557,10 -558,9 +557,16 @@@ static int fnic_queuecommand_lck(struc
  	io_lock_acquired = 1;
  	io_req->port_id = rport->port_id;
  	io_req->start_time = jiffies;
++<<<<<<< HEAD
 +	CMD_STATE(sc) = FNIC_IOREQ_CMD_PENDING;
 +	CMD_SP(sc) = (char *)io_req;
 +	CMD_FLAGS(sc) |= FNIC_IO_INITIALIZED;
 +	sc->scsi_done = done;
++=======
+ 	fnic_priv(sc)->state = FNIC_IOREQ_CMD_PENDING;
+ 	fnic_priv(sc)->io_req = io_req;
+ 	fnic_priv(sc)->flags |= FNIC_IO_INITIALIZED;
++>>>>>>> 924cb24df4fc (scsi: fnic: Stop using the SCSI pointer)
  
  	/* create copy wq desc and enqueue it */
  	wq = &fnic->wq_copy[0];
@@@ -983,9 -982,11 +988,9 @@@ static void fnic_fcpio_icmnd_cmpl_handl
  	}
  
  	/* Break link with the SCSI command */
- 	CMD_SP(sc) = NULL;
- 	CMD_FLAGS(sc) |= FNIC_IO_DONE;
+ 	fnic_priv(sc)->io_req = NULL;
+ 	fnic_priv(sc)->flags |= FNIC_IO_DONE;
  
 -	spin_unlock_irqrestore(io_lock, flags);
 -
  	if (hdr_status != FCPIO_SUCCESS) {
  		atomic64_inc(&fnic_stats->io_stats.io_failures);
  		shost_printk(KERN_ERR, fnic->lport->host, "hdr status = %s\n",
@@@ -1192,34 -1190,30 +1196,54 @@@ static void fnic_fcpio_itmf_cmpl_handle
  
  			fnic_release_ioreq_buf(fnic, io_req, sc);
  			mempool_free(io_req, fnic->io_req_pool);
++<<<<<<< HEAD
 +			if (sc->scsi_done) {
 +				FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
 +					sc->device->host->host_no, id,
 +					sc,
 +					jiffies_to_msecs(jiffies - start_time),
 +					desc,
 +					(((u64)hdr_status << 40) |
 +					(u64)sc->cmnd[0] << 32 |
 +					(u64)sc->cmnd[2] << 24 |
 +					(u64)sc->cmnd[3] << 16 |
 +					(u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 +					(((u64)CMD_FLAGS(sc) << 32) |
 +					CMD_STATE(sc)));
 +				sc->scsi_done(sc);
 +				atomic64_dec(&fnic_stats->io_stats.active_ios);
 +				if (atomic64_read(&fnic->io_cmpl_skip))
 +					atomic64_dec(&fnic->io_cmpl_skip);
 +				else
 +					atomic64_inc(&fnic_stats->io_stats.io_completions);
 +			}
++=======
+ 			FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
+ 				   sc->device->host->host_no, id,
+ 				   sc,
+ 				   jiffies_to_msecs(jiffies - start_time),
+ 				   desc,
+ 				   (((u64)hdr_status << 40) |
+ 				    (u64)sc->cmnd[0] << 32 |
+ 				    (u64)sc->cmnd[2] << 24 |
+ 				    (u64)sc->cmnd[3] << 16 |
+ 				    (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
+ 				   fnic_flags_and_state(sc));
+ 			scsi_done(sc);
+ 			atomic64_dec(&fnic_stats->io_stats.active_ios);
+ 			if (atomic64_read(&fnic->io_cmpl_skip))
+ 				atomic64_dec(&fnic->io_cmpl_skip);
+ 			else
+ 				atomic64_inc(&fnic_stats->io_stats.io_completions);
++>>>>>>> 924cb24df4fc (scsi: fnic: Stop using the SCSI pointer)
  		}
 +
  	} else if (id & FNIC_TAG_DEV_RST) {
  		/* Completion of device reset */
- 		CMD_LR_STATUS(sc) = hdr_status;
- 		if (CMD_STATE(sc) == FNIC_IOREQ_ABTS_PENDING) {
+ 		fnic_priv(sc)->lr_status = hdr_status;
+ 		if (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {
  			spin_unlock_irqrestore(io_lock, flags);
- 			CMD_FLAGS(sc) |= FNIC_DEV_RST_ABTS_PENDING;
+ 			fnic_priv(sc)->flags |= FNIC_DEV_RST_ABTS_PENDING;
  			FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
  				  sc->device->host->host_no, id, sc,
  				  jiffies_to_msecs(jiffies - start_time),
@@@ -1419,23 -1412,22 +1441,41 @@@ cleanup_scsi_cmd
  		atomic64_inc(&fnic_stats->io_stats.io_completions);
  
  	/* Complete the command to SCSI */
++<<<<<<< HEAD
 +	if (sc->scsi_done) {
 +		if (!(CMD_FLAGS(sc) & FNIC_IO_ISSUED))
 +			shost_printk(KERN_ERR, fnic->lport->host,
 +				     "Calling done for IO not issued to fw: tag:0x%x sc:0x%p\n",
 +				     tag, sc);
 +
 +		FNIC_TRACE(fnic_cleanup_io,
 +			   sc->device->host->host_no, tag, sc,
 +			   jiffies_to_msecs(jiffies - start_time),
 +			   0, ((u64)sc->cmnd[0] << 32 |
 +			       (u64)sc->cmnd[2] << 24 |
 +			       (u64)sc->cmnd[3] << 16 |
 +			       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 +			   (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
++=======
+ 	if (!(fnic_priv(sc)->flags & FNIC_IO_ISSUED))
+ 		shost_printk(KERN_ERR, fnic->lport->host,
+ 			     "Calling done for IO not issued to fw: tag:0x%x sc:0x%p\n",
+ 			     tag, sc);
+ 
+ 	FNIC_TRACE(fnic_cleanup_io,
+ 		   sc->device->host->host_no, tag, sc,
+ 		   jiffies_to_msecs(jiffies - start_time),
+ 		   0, ((u64)sc->cmnd[0] << 32 |
+ 		       (u64)sc->cmnd[2] << 24 |
+ 		       (u64)sc->cmnd[3] << 16 |
+ 		       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
+ 		   fnic_flags_and_state(sc));
+ 
+ 	scsi_done(sc);
++>>>>>>> 924cb24df4fc (scsi: fnic: Stop using the SCSI pointer)
  
 +		sc->scsi_done(sc);
 +	}
  	return true;
  }
  
@@@ -1493,17 -1485,15 +1533,27 @@@ wq_copy_cleanup_scsi_cmd
  	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, "wq_copy_cleanup_handler:"
  		      " DID_NO_CONNECT\n");
  
++<<<<<<< HEAD
 +	if (sc->scsi_done) {
 +		FNIC_TRACE(fnic_wq_copy_cleanup_handler,
 +			  sc->device->host->host_no, id, sc,
 +			  jiffies_to_msecs(jiffies - start_time),
 +			  0, ((u64)sc->cmnd[0] << 32 |
 +			  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
 +			  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 +			  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
++=======
+ 	FNIC_TRACE(fnic_wq_copy_cleanup_handler,
+ 		   sc->device->host->host_no, id, sc,
+ 		   jiffies_to_msecs(jiffies - start_time),
+ 		   0, ((u64)sc->cmnd[0] << 32 |
+ 		       (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
+ 		       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
+ 		   fnic_flags_and_state(sc));
++>>>>>>> 924cb24df4fc (scsi: fnic: Stop using the SCSI pointer)
  
 -	scsi_done(sc);
 +		sc->scsi_done(sc);
 +	}
  }
  
  static inline int fnic_queue_abort_io_req(struct fnic *fnic, int tag,
diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 69f373b53132..e82eb0ef2605 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -89,15 +89,28 @@
 #define FNIC_DEV_RST_ABTS_PENDING       BIT(21)
 
 /*
- * Usage of the scsi_cmnd scratchpad.
+ * fnic private data per SCSI command.
  * These fields are locked by the hashed io_req_lock.
  */
-#define CMD_SP(Cmnd)		((Cmnd)->SCp.ptr)
-#define CMD_STATE(Cmnd)		((Cmnd)->SCp.phase)
-#define CMD_ABTS_STATUS(Cmnd)	((Cmnd)->SCp.Message)
-#define CMD_LR_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
-#define CMD_TAG(Cmnd)           ((Cmnd)->SCp.sent_command)
-#define CMD_FLAGS(Cmnd)         ((Cmnd)->SCp.Status)
+struct fnic_cmd_priv {
+	struct fnic_io_req *io_req;
+	enum fnic_ioreq_state state;
+	u32 flags;
+	u16 abts_status;
+	u16 lr_status;
+};
+
+static inline struct fnic_cmd_priv *fnic_priv(struct scsi_cmnd *cmd)
+{
+	return scsi_cmd_priv(cmd);
+}
+
+static inline u64 fnic_flags_and_state(struct scsi_cmnd *cmd)
+{
+	struct fnic_cmd_priv *fcmd = fnic_priv(cmd);
+
+	return ((u64)fcmd->flags << 32) | fcmd->state;
+}
 
 #define FCPIO_INVALID_CODE 0x100 /* hdr_status value unused by firmware */
 
diff --git a/drivers/scsi/fnic/fnic_main.c b/drivers/scsi/fnic/fnic_main.c
index d09d15fff065..f3eec17f5a7f 100644
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@ -124,6 +124,7 @@ static struct scsi_host_template fnic_host_template = {
 	.max_sectors = 0xffff,
 	.shost_attrs = fnic_attrs,
 	.track_queue_depth = 1,
+	.cmd_size = sizeof(struct fnic_cmd_priv),
 };
 
 static void
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
