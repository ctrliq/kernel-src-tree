scsi: fnic: Fix missing DMA mapping error in fnic_send_frame()

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Thomas Fourier <fourier.thomas@gmail.com>
commit 85d6fbc47c3087c5d048e6734926b0c36af34fe9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/85d6fbc4.failed

dma_map_XXX() can fail and should be tested for errors with
dma_mapping_error().

Fixes: a63e78eb2b0f ("scsi: fnic: Add support for fabric based solicited requests and responses")
	Signed-off-by: Thomas Fourier <fourier.thomas@gmail.com>
Link: https://lore.kernel.org/r/20250618065715.14740-2-fourier.thomas@gmail.com
	Reviewed-by: Karan Tilak Kumar <kartilak@cisco.com>
	Reviewed-by: John Menghini <jmeneghi@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 85d6fbc47c3087c5d048e6734926b0c36af34fe9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic_fcs.c
diff --cc drivers/scsi/fnic/fnic_fcs.c
index 8c3b350695e3,103ab6f1f7cd..000000000000
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@@ -1086,52 -635,15 +1086,58 @@@ static int fnic_send_frame(struct fnic 
  	int ret = 0;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	fh = fc_frame_header_get(fp);
 +	skb = fp_skb(fp);
++=======
+ 	pa = dma_map_single(&fnic->pdev->dev, frame, frame_len, DMA_TO_DEVICE);
+ 	if (dma_mapping_error(&fnic->pdev->dev, pa))
+ 		return -ENOMEM;
++>>>>>>> 85d6fbc47c30 (scsi: fnic: Fix missing DMA mapping error in fnic_send_frame())
  
 -	if ((fnic_fc_trace_set_data(fnic->fnic_num,
 -				FNIC_FC_SEND | 0x80, (char *) frame,
 -				frame_len)) != 0) {
 -		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
 -					 "fnic ctlr frame trace error");
 +	if (unlikely(fh->fh_r_ctl == FC_RCTL_ELS_REQ) &&
 +	    fcoe_ctlr_els_send(&fnic->ctlr, fnic->lport, skb))
 +		return 0;
 +
 +	if (!fnic->vlan_hw_insert) {
 +		eth_hdr_len = sizeof(*vlan_hdr) + sizeof(*fcoe_hdr);
 +		vlan_hdr = skb_push(skb, eth_hdr_len);
 +		eth_hdr = (struct ethhdr *)vlan_hdr;
 +		vlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);
 +		vlan_hdr->h_vlan_encapsulated_proto = htons(ETH_P_FCOE);
 +		vlan_hdr->h_vlan_TCI = htons(fnic->vlan_id);
 +		fcoe_hdr = (struct fcoe_hdr *)(vlan_hdr + 1);
 +	} else {
 +		eth_hdr_len = sizeof(*eth_hdr) + sizeof(*fcoe_hdr);
 +		eth_hdr = skb_push(skb, eth_hdr_len);
 +		eth_hdr->h_proto = htons(ETH_P_FCOE);
 +		fcoe_hdr = (struct fcoe_hdr *)(eth_hdr + 1);
 +	}
 +
 +	if (fnic->ctlr.map_dest)
 +		fc_fcoe_set_mac(eth_hdr->h_dest, fh->fh_d_id);
 +	else
 +		memcpy(eth_hdr->h_dest, fnic->ctlr.dest_addr, ETH_ALEN);
 +	memcpy(eth_hdr->h_source, fnic->data_src_addr, ETH_ALEN);
 +
 +	tot_len = skb->len;
 +	BUG_ON(tot_len % 4);
 +
 +	memset(fcoe_hdr, 0, sizeof(*fcoe_hdr));
 +	fcoe_hdr->fcoe_sof = fr_sof(fp);
 +	if (FC_FCOE_VER)
 +		FC_FCOE_ENCAPS_VER(fcoe_hdr, FC_FCOE_VER);
 +
 +	pa = dma_map_single(&fnic->pdev->dev, eth_hdr, tot_len, DMA_TO_DEVICE);
 +	if (dma_mapping_error(&fnic->pdev->dev, pa)) {
 +		ret = -ENOMEM;
 +		printk(KERN_ERR "DMA map failed with error %d\n", ret);
 +		goto free_skb_on_err;
 +	}
 +
 +	if ((fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_SEND,
 +				(char *)eth_hdr, tot_len)) != 0) {
 +		printk(KERN_ERR "fnic ctlr frame trace error!!!");
  	}
  
  	spin_lock_irqsave(&fnic->wq_lock[0], flags);
* Unmerged path drivers/scsi/fnic/fnic_fcs.c
