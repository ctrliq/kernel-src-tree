scsi: fnic: Modify fnic interfaces to use FDLS

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 9243626c211e4d6f5add84c5a7b141e94a2e7222
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/9243626c.failed

Modify fnic driver interfaces to use FDLS and supporting functions.

Refactor code in fnic_probe and fnic_remove.

Get fnic from shost_priv.

Add error handling in stats processing functions.

Modify some print statements.

Add support to do module unload cleanup.

Use placeholder functions/modify function declarations to not break
compilation.

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Reviewed-by: Gian Carlo Boffa <gcboffa@cisco.com>
Co-developed-by: Arun Easi <aeasi@cisco.com>
	Signed-off-by: Arun Easi <aeasi@cisco.com>
Co-developed-by: Karan Tilak Kumar <kartilak@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20241212020312.4786-12-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9243626c211e4d6f5add84c5a7b141e94a2e7222)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic.h
#	drivers/scsi/fnic/fnic_fcs.c
#	drivers/scsi/fnic/fnic_main.c
#	drivers/scsi/fnic/fnic_res.c
diff --cc drivers/scsi/fnic/fnic.h
index 73fb8245c7b7,19e8775f1bfc..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -88,16 -82,102 +88,92 @@@
  #define FNIC_DEV_RST_TERM_DONE          BIT(20)
  #define FNIC_DEV_RST_ABTS_PENDING       BIT(21)
  
++<<<<<<< HEAD
++=======
+ #define IS_FNIC_FCP_INITIATOR(fnic) (fnic->role == FNIC_ROLE_FCP_INITIATOR)
+ 
+ #define FNIC_FW_RESET_TIMEOUT        60000	/* mSec   */
+ #define FNIC_FCOE_MAX_CMD_LEN        16
+ /* Retry supported by rport (returned by PRLI service parameters) */
+ #define FNIC_FC_RP_FLAGS_RETRY            0x1
+ 
+ /* Cisco vendor id */
+ #define PCI_VENDOR_ID_CISCO						0x1137
+ #define PCI_DEVICE_ID_CISCO_VIC_FC				0x0045	/* fc vnic */
+ 
+ /* sereno pcie switch */
+ #define PCI_DEVICE_ID_CISCO_SERENO             0x004e
+ #define PCI_DEVICE_ID_CISCO_CRUZ               0x007a	/* Cruz */
+ #define PCI_DEVICE_ID_CISCO_BODEGA             0x0131	/* Bodega */
+ #define PCI_DEVICE_ID_CISCO_BEVERLY            0x025f	/* Beverly */
+ 
+ /* Sereno */
+ #define PCI_SUBDEVICE_ID_CISCO_VASONA			0x004f	/* vasona mezz */
+ #define PCI_SUBDEVICE_ID_CISCO_COTATI			0x0084	/* cotati mlom */
+ #define PCI_SUBDEVICE_ID_CISCO_LEXINGTON		0x0085	/* lexington pcie */
+ #define PCI_SUBDEVICE_ID_CISCO_ICEHOUSE			0x00cd	/* Icehouse */
+ #define PCI_SUBDEVICE_ID_CISCO_KIRKWOODLAKE		0x00ce	/* KirkwoodLake pcie */
+ #define PCI_SUBDEVICE_ID_CISCO_SUSANVILLE		0x012e	/* Susanville MLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_TORRANCE			0x0139	/* Torrance MLOM */
+ 
+ /* Cruz */
+ #define PCI_SUBDEVICE_ID_CISCO_CALISTOGA		0x012c	/* Calistoga MLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTAINVIEW		0x0137	/* Cruz Mezz */
+ /* Cruz MountTian SIOC */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTTIAN		0x014b
+ #define PCI_SUBDEVICE_ID_CISCO_CLEARLAKE		0x014d	/* ClearLake pcie */
+ /* Cruz MountTian2 SIOC */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTTIAN2		0x0157
+ #define PCI_SUBDEVICE_ID_CISCO_CLAREMONT		0x015d	/* Claremont MLOM */
+ 
+ /* Bodega */
+ /* VIC 1457 PCIe mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BRADBURY         0x0218
+ #define PCI_SUBDEVICE_ID_CISCO_BRENTWOOD        0x0217	/* VIC 1455 PCIe */
+ /* VIC 1487 PCIe mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BURLINGAME       0x021a
+ #define PCI_SUBDEVICE_ID_CISCO_BAYSIDE          0x0219	/* VIC 1485 PCIe */
+ /* VIC 1440 Mezz mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BAKERSFIELD      0x0215
+ #define PCI_SUBDEVICE_ID_CISCO_BOONVILLE        0x0216	/* VIC 1480 Mezz */
+ #define PCI_SUBDEVICE_ID_CISCO_BENICIA          0x024a	/* VIC 1495 */
+ #define PCI_SUBDEVICE_ID_CISCO_BEAUMONT         0x024b	/* VIC 1497 */
+ #define PCI_SUBDEVICE_ID_CISCO_BRISBANE         0x02af	/* VIC 1467 */
+ #define PCI_SUBDEVICE_ID_CISCO_BENTON           0x02b0	/* VIC 1477 */
+ #define PCI_SUBDEVICE_ID_CISCO_TWIN_RIVER       0x02cf	/* VIC 14425 */
+ #define PCI_SUBDEVICE_ID_CISCO_TWIN_PEAK        0x02d0	/* VIC 14825 */
+ 
+ /* Beverly */
+ #define PCI_SUBDEVICE_ID_CISCO_BERN             0x02de	/* VIC 15420 */
+ #define PCI_SUBDEVICE_ID_CISCO_STOCKHOLM        0x02dd	/* VIC 15428 */
+ #define PCI_SUBDEVICE_ID_CISCO_KRAKOW           0x02dc	/* VIC 15411 */
+ #define PCI_SUBDEVICE_ID_CISCO_LUCERNE          0x02db	/* VIC 15231 */
+ #define PCI_SUBDEVICE_ID_CISCO_TURKU            0x02e8	/* VIC 15238 */
+ #define PCI_SUBDEVICE_ID_CISCO_TURKU_PLUS       0x02f3	/* VIC 15237 */
+ #define PCI_SUBDEVICE_ID_CISCO_ZURICH           0x02df	/* VIC 15230 */
+ #define PCI_SUBDEVICE_ID_CISCO_RIGA             0x02e0	/* VIC 15427 */
+ #define PCI_SUBDEVICE_ID_CISCO_GENEVA           0x02e1	/* VIC 15422 */
+ #define PCI_SUBDEVICE_ID_CISCO_HELSINKI         0x02e4	/* VIC 15235 */
+ #define PCI_SUBDEVICE_ID_CISCO_GOTHENBURG       0x02f2	/* VIC 15425 */
+ 
+ struct fnic_pcie_device {
+ 	u32 device;
+ 	u8 *desc;
+ 	u32 subsystem_device;
+ 	u8 *subsys_desc;
+ };
+ 
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  /*
 - * fnic private data per SCSI command.
 + * Usage of the scsi_cmnd scratchpad.
   * These fields are locked by the hashed io_req_lock.
   */
 -struct fnic_cmd_priv {
 -	struct fnic_io_req *io_req;
 -	enum fnic_ioreq_state state;
 -	u32 flags;
 -	u16 abts_status;
 -	u16 lr_status;
 -};
 -
 -static inline struct fnic_cmd_priv *fnic_priv(struct scsi_cmnd *cmd)
 -{
 -	return scsi_cmd_priv(cmd);
 -}
 -
 -static inline u64 fnic_flags_and_state(struct scsi_cmnd *cmd)
 -{
 -	struct fnic_cmd_priv *fcmd = fnic_priv(cmd);
 -
 -	return ((u64)fcmd->flags << 32) | fcmd->state;
 -}
 +#define CMD_SP(Cmnd)		((Cmnd)->SCp.ptr)
 +#define CMD_STATE(Cmnd)		((Cmnd)->SCp.phase)
 +#define CMD_ABTS_STATUS(Cmnd)	((Cmnd)->SCp.Message)
 +#define CMD_LR_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
 +#define CMD_TAG(Cmnd)           ((Cmnd)->SCp.sent_command)
 +#define CMD_FLAGS(Cmnd)         ((Cmnd)->SCp.Status)
  
  #define FCPIO_INVALID_CODE 0x100 /* hdr_status value unused by firmware */
  
@@@ -229,6 -343,9 +305,12 @@@ struct fnic_cpy_wq 
  /* Per-instance private data structure */
  struct fnic {
  	int fnic_num;
++<<<<<<< HEAD
++=======
+ 	enum fnic_role_e role;
+ 	struct fnic_iport_s iport;
+ 	struct Scsi_Host *host;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	struct fc_lport *lport;
  	struct fcoe_ctlr ctlr;		/* FIP FCoE controller structure */
  	struct vnic_dev_bar bar0;
@@@ -333,14 -466,9 +415,9 @@@
  	____cacheline_aligned struct vnic_intr intr[FNIC_MSIX_INTR_MAX];
  };
  
- static inline struct fnic *fnic_from_ctlr(struct fcoe_ctlr *fip)
- {
- 	return container_of(fip, struct fnic, ctlr);
- }
- 
  extern struct workqueue_struct *fnic_event_queue;
  extern struct workqueue_struct *fnic_fip_queue;
 -extern const struct attribute_group *fnic_host_groups[];
 +extern struct device_attribute *fnic_attrs[];
  
  void fnic_clear_intr_mode(struct fnic *fnic);
  int fnic_set_intr_mode(struct fnic *fnic);
@@@ -365,12 -493,12 +442,21 @@@ void fnic_update_mac_locked(struct fni
  int fnic_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
  int fnic_abort_cmd(struct scsi_cmnd *);
  int fnic_device_reset(struct scsi_cmnd *);
++<<<<<<< HEAD
 +int fnic_host_reset(struct scsi_cmnd *);
 +int fnic_reset(struct Scsi_Host *);
 +void fnic_scsi_cleanup(struct fc_lport *);
 +void fnic_scsi_abort_io(struct fc_lport *);
 +void fnic_empty_scsi_cleanup(struct fc_lport *);
 +void fnic_exch_mgr_reset(struct fc_lport *, u32, u32);
++=======
+ int fnic_eh_host_reset_handler(struct scsi_cmnd *sc);
+ int fnic_host_reset(struct Scsi_Host *shost);
+ void fnic_reset(struct Scsi_Host *shost);
+ int fnic_issue_fc_host_lip(struct Scsi_Host *shost);
+ void fnic_get_host_port_state(struct Scsi_Host *shost);
+ void fnic_scsi_fcpio_reset(struct fnic *fnic);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  int fnic_wq_copy_cmpl_handler(struct fnic *fnic, int copy_work_to_do, unsigned int cq_index);
  int fnic_wq_cmpl_handler(struct fnic *fnic, int);
  int fnic_flogi_reg_handler(struct fnic *fnic, u32);
@@@ -379,10 -507,11 +465,15 @@@ void fnic_wq_copy_cleanup_handler(struc
  int fnic_fw_reset_handler(struct fnic *fnic);
  void fnic_terminate_rport_io(struct fc_rport *);
  const char *fnic_state_to_str(unsigned int state);
 -void fnic_mq_map_queues_cpus(struct Scsi_Host *host);
 +
  void fnic_log_q_error(struct fnic *fnic);
  void fnic_handle_link_event(struct fnic *fnic);
++<<<<<<< HEAD
 +
++=======
+ int fnic_stats_debugfs_init(struct fnic *fnic);
+ void fnic_stats_debugfs_remove(struct fnic *fnic);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  int fnic_is_abts_pending(struct fnic *, struct scsi_cmnd *);
  
  void fnic_handle_fip_frame(struct work_struct *work);
@@@ -398,4 -526,90 +489,93 @@@ fnic_chk_state_flags_locked(struct fni
  }
  void __fnic_set_state_flags(struct fnic *, unsigned long, unsigned long);
  void fnic_dump_fchost_stats(struct Scsi_Host *, struct fc_host_statistics *);
++<<<<<<< HEAD
++=======
+ void fnic_free_txq(struct list_head *head);
+ int fnic_get_desc_by_devid(struct pci_dev *pdev, char **desc,
+ 						   char **subsys_desc);
+ void fnic_fdls_link_status_change(struct fnic *fnic, int linkup);
+ void fnic_delete_fcp_tports(struct fnic *fnic);
+ void fnic_flush_tport_event_list(struct fnic *fnic);
+ int fnic_count_ioreqs_wq(struct fnic *fnic, u32 hwq, u32 portid);
+ unsigned int fnic_count_ioreqs(struct fnic *fnic, u32 portid);
+ unsigned int fnic_count_all_ioreqs(struct fnic *fnic);
+ unsigned int fnic_count_lun_ioreqs_wq(struct fnic *fnic, u32 hwq,
+ 						  struct scsi_device *device);
+ unsigned int fnic_count_lun_ioreqs(struct fnic *fnic,
+ 					   struct scsi_device *device);
+ void fnic_scsi_unload(struct fnic *fnic);
+ void fnic_scsi_unload_cleanup(struct fnic *fnic);
+ int fnic_get_debug_info(struct stats_debug_info *info,
+ 			struct fnic *fnic);
+ 
+ struct fnic_scsi_iter_data {
+ 	struct fnic *fnic;
+ 	void *data1;
+ 	void *data2;
+ 	bool (*fn)(struct fnic *fnic, struct scsi_cmnd *sc,
+ 			void *data1, void *data2);
+ };
+ 
+ static inline bool
+ fnic_io_iter_handler(struct scsi_cmnd *sc, void *iter_data)
+ {
+ 	struct fnic_scsi_iter_data *iter = iter_data;
+ 
+ 	return iter->fn(iter->fnic, sc, iter->data1, iter->data2);
+ }
+ 
+ static inline void
+ fnic_scsi_io_iter(struct fnic *fnic,
+ 		bool (*fn)(struct fnic *fnic, struct scsi_cmnd *sc,
+ 				void *data1, void *data2),
+ 		void *data1, void *data2)
+ {
+ 	struct fnic_scsi_iter_data iter_data = {
+ 		.fn = fn,
+ 		.fnic = fnic,
+ 		.data1 = data1,
+ 		.data2 = data2,
+ 	};
+ 	scsi_host_busy_iter(fnic->lport->host, fnic_io_iter_handler, &iter_data);
+ }
+ 
+ #ifdef FNIC_DEBUG
+ static inline void
+ fnic_debug_dump(struct fnic *fnic, uint8_t *u8arr, int len)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < len; i = i+8) {
+ 		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		    "%d: %02x %02x %02x %02x %02x %02x %02x %02x", i / 8,
+ 		    u8arr[i + 0], u8arr[i + 1], u8arr[i + 2], u8arr[i + 3],
+ 		    u8arr[i + 4], u8arr[i + 5], u8arr[i + 6], u8arr[i + 7]);
+ 	}
+ }
+ 
+ static inline void
+ fnic_debug_dump_fc_frame(struct fnic *fnic, struct fc_frame_header *fchdr,
+ 				int len, char *pfx)
+ {
+ 	uint32_t s_id, d_id;
+ 
+ 	s_id = ntoh24(fchdr->fh_s_id);
+ 	d_id = ntoh24(fchdr->fh_d_id);
+ 	FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		"%s packet contents: sid/did/type/oxid = 0x%x/0x%x/0x%x/0x%x (len = %d)\n",
+ 		pfx, s_id, d_id, fchdr->fh_type,
+ 		FNIC_STD_GET_OX_ID(fchdr), len);
+ 
+ 	fnic_debug_dump(fnic, (uint8_t *)fchdr, len);
+ 
+ }
+ #else /* FNIC_DEBUG */
+ static inline void
+ fnic_debug_dump(struct fnic *fnic, uint8_t *u8arr, int len) {}
+ static inline void
+ fnic_debug_dump_fc_frame(struct fnic *fnic, struct fc_frame_header *fchdr,
+ 				uint32_t len, char *pfx) {}
+ #endif /* FNIC_DEBUG */
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  #endif /* _FNIC_H_ */
diff --cc drivers/scsi/fnic/fnic_fcs.c
index 8c3b350695e3,8dba1168b652..000000000000
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@@ -26,25 -14,152 +26,158 @@@
  #include <linux/workqueue.h>
  #include <scsi/fc/fc_fip.h>
  #include <scsi/fc/fc_els.h>
 +#include <scsi/fc/fc_fcoe.h>
  #include <scsi/fc_frame.h>
  #include <scsi/libfc.h>
 -#include <scsi/scsi_transport_fc.h>
  #include "fnic_io.h"
  #include "fnic.h"
 -#include "fnic_fdls.h"
 -#include "fdls_fc.h"
 +#include "fnic_fip.h"
  #include "cq_enet_desc.h"
  #include "cq_exch_desc.h"
 -#include "fip.h"
  
 -#define MAX_RESET_WAIT_COUNT    64
 -
 -extern struct workqueue_struct *fnic_fip_queue;
 +static u8 fcoe_all_fcfs[ETH_ALEN] = FIP_ALL_FCF_MACS;
 +struct workqueue_struct *fnic_fip_queue;
  struct workqueue_struct *fnic_event_queue;
  
++<<<<<<< HEAD
 +static void fnic_set_eth_mode(struct fnic *);
 +static void fnic_fcoe_send_vlan_req(struct fnic *fnic);
 +static void fnic_fcoe_start_fcf_disc(struct fnic *fnic);
 +static void fnic_fcoe_process_vlan_resp(struct fnic *fnic, struct sk_buff *);
 +static int fnic_fcoe_vlan_check(struct fnic *fnic, u16 flag);
 +static int fnic_fcoe_handle_fip_frame(struct fnic *fnic, struct sk_buff *skb);
++=======
+ static uint8_t FCOE_ALL_FCF_MAC[6] = FC_FCOE_FLOGI_MAC;
+ 
+ /*
+  * Internal Functions
+  * This function will initialize the src_mac address to be
+  * used in outgoing frames
+  */
+ static inline void fnic_fdls_set_fcoe_srcmac(struct fnic *fnic,
+ 							 uint8_t *src_mac)
+ {
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Setting src mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 src_mac[0], src_mac[1], src_mac[2], src_mac[3],
+ 				 src_mac[4], src_mac[5]);
+ 
+ 	memcpy(fnic->iport.fpma, src_mac, 6);
+ }
+ 
+ /*
+  * This function will initialize the dst_mac address to be
+  * used in outgoing frames
+  */
+ static inline  void fnic_fdls_set_fcoe_dstmac(struct fnic *fnic,
+ 							 uint8_t *dst_mac)
+ {
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Setting dst mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 dst_mac[0], dst_mac[1], dst_mac[2], dst_mac[3],
+ 				 dst_mac[4], dst_mac[5]);
+ 
+ 	memcpy(fnic->iport.fcfmac, dst_mac, 6);
+ }
+ 
+ void fnic_get_host_port_state(struct Scsi_Host *shost)
+ {
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(shost));
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	if (!fnic->link_status)
+ 		fc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;
+ 	else if (iport->state == FNIC_IPORT_STATE_READY)
+ 		fc_host_port_state(shost) = FC_PORTSTATE_ONLINE;
+ 	else
+ 		fc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ }
+ 
+ void fnic_fdls_link_status_change(struct fnic *fnic, int linkup)
+ {
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "link up: %d, usefip: %d", linkup, iport->usefip);
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, fnic->lock_flags);
+ 
+ 	if (linkup) {
+ 		if (iport->usefip) {
+ 			iport->state = FNIC_IPORT_STATE_FIP;
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "link up: %d, usefip: %d", linkup, iport->usefip);
+ 			fnic_fcoe_send_vlan_req(fnic);
+ 		} else {
+ 			iport->state = FNIC_IPORT_STATE_FABRIC_DISC;
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "iport->state: %d", iport->state);
+ 			fnic_fdls_disc_start(iport);
+ 		}
+ 	} else {
+ 		iport->state = FNIC_IPORT_STATE_LINK_WAIT;
+ 		if (!is_zero_ether_addr(iport->fpma))
+ 			vnic_dev_del_addr(fnic->vdev, iport->fpma);
+ 		fnic_common_fip_cleanup(fnic);
+ 		fnic_fdls_link_down(iport);
+ 
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ }
+ 
+ 
+ /*
+  * FPMA can be either taken from ethhdr(dst_mac) or flogi resp
+  * or derive from FC_MAP and FCID combination. While it should be
+  * same, revisit this if there is any possibility of not-correct.
+  */
+ void fnic_fdls_learn_fcoe_macs(struct fnic_iport_s *iport, void *rx_frame,
+ 							   uint8_t *fcid)
+ {
+ 	struct fnic *fnic = iport->fnic;
+ 	struct ethhdr *ethhdr = (struct ethhdr *) rx_frame;
+ 	uint8_t fcmac[6] = { 0x0E, 0xFC, 0x00, 0x00, 0x00, 0x00 };
+ 
+ 	memcpy(&fcmac[3], fcid, 3);
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "learn fcoe: dst_mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 ethhdr->h_dest[0], ethhdr->h_dest[1],
+ 				 ethhdr->h_dest[2], ethhdr->h_dest[3],
+ 				 ethhdr->h_dest[4], ethhdr->h_dest[5]);
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "learn fcoe: fc_mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 fcmac[0], fcmac[1], fcmac[2], fcmac[3], fcmac[4],
+ 				 fcmac[5]);
+ 
+ 	fnic_fdls_set_fcoe_srcmac(fnic, fcmac);
+ 	fnic_fdls_set_fcoe_dstmac(fnic, ethhdr->h_source);
+ }
+ 
+ void fnic_fdls_init(struct fnic *fnic, int usefip)
+ {
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 
+ 	/* Initialize iPort structure */
+ 	iport->state = FNIC_IPORT_STATE_INIT;
+ 	iport->fnic = fnic;
+ 	iport->usefip = usefip;
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "iportsrcmac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 iport->hwmac[0], iport->hwmac[1], iport->hwmac[2],
+ 				 iport->hwmac[3], iport->hwmac[4], iport->hwmac[5]);
+ 
+ 	INIT_LIST_HEAD(&iport->tport_list);
+ 	INIT_LIST_HEAD(&iport->tport_list_pending_del);
+ 
+ 	fnic_fdls_disc_init(iport);
+ }
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  
  void fnic_handle_link(struct work_struct *work)
  {
diff --cc drivers/scsi/fnic/fnic_main.c
index 06fd7b543b33,44cbb04b2421..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -70,7 -63,15 +70,12 @@@ unsigned int fnic_log_level
  module_param(fnic_log_level, int, S_IRUGO|S_IWUSR);
  MODULE_PARM_DESC(fnic_log_level, "bit mask of fnic logging levels");
  
 -unsigned int fnic_fdmi_support = 1;
 -module_param(fnic_fdmi_support, int, 0644);
 -MODULE_PARM_DESC(fnic_fdmi_support, "FDMI support");
  
+ static unsigned int fnic_tgt_id_binding = 1;
+ module_param(fnic_tgt_id_binding, uint, 0644);
+ MODULE_PARM_DESC(fnic_tgt_id_binding,
+ 		 "Target ID binding (0 for none. 1 for binding by WWPN (default))");
+ 
  unsigned int io_completions = FNIC_DFLT_IO_COMPLETIONS;
  module_param(io_completions, int, S_IRUGO|S_IWUSR);
  MODULE_PARM_DESC(io_completions, "Max CQ entries to process at a time");
@@@ -165,12 -162,12 +170,17 @@@ static struct fc_function_template fnic
  	.show_starget_port_id = 1,
  	.show_rport_dev_loss_tmo = 1,
  	.set_rport_dev_loss_tmo = fnic_set_rport_dev_loss_tmo,
++<<<<<<< HEAD
 +	.issue_fc_host_lip = fnic_reset,
 +	.get_fc_host_stats = fnic_get_stats,
++=======
+ 	.issue_fc_host_lip = fnic_issue_fc_host_lip,
+ 	.get_fc_host_stats = NULL,
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	.reset_fc_host_stats = fnic_reset_host_stats,
- 	.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),
+ 	.dd_fcrport_size = sizeof(struct rport_dd_data_s),
  	.terminate_rport_io = fnic_terminate_rport_io,
- 	.bsg_request = fc_lport_bsg_request,
+ 	.bsg_request = NULL,
  };
  
  static void fnic_get_host_speed(struct Scsi_Host *shost)
@@@ -203,42 -231,11 +244,48 @@@
  	}
  }
  
+ /* Placeholder function */
  static struct fc_host_statistics *fnic_get_stats(struct Scsi_Host *host)
  {
++<<<<<<< HEAD
 +	int ret;
 +	struct fc_lport *lp = shost_priv(host);
 +	struct fnic *fnic = lport_priv(lp);
 +	struct fc_host_statistics *stats = &lp->host_stats;
 +	struct vnic_stats *vs;
 +	unsigned long flags;
 +
 +	if (time_before(jiffies, fnic->stats_time + HZ / FNIC_STATS_RATE_LIMIT))
 +		return stats;
 +	fnic->stats_time = jiffies;
 +
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	ret = vnic_dev_stats_dump(fnic->vdev, &fnic->stats);
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +
 +	if (ret) {
 +		FNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "fnic: Get vnic stats failed"
 +			      " 0x%x", ret);
 +		return stats;
 +	}
 +	vs = fnic->stats;
 +	stats->tx_frames = vs->tx.tx_unicast_frames_ok;
 +	stats->tx_words  = vs->tx.tx_unicast_bytes_ok / 4;
 +	stats->rx_frames = vs->rx.rx_unicast_frames_ok;
 +	stats->rx_words  = vs->rx.rx_unicast_bytes_ok / 4;
 +	stats->error_frames = vs->tx.tx_errors + vs->rx.rx_errors;
 +	stats->dumped_frames = vs->tx.tx_drops + vs->rx.rx_drop;
 +	stats->invalid_crc_count = vs->rx.rx_crc_errors;
 +	stats->seconds_since_last_reset =
 +			(jiffies - fnic->stats_reset_time) / HZ;
 +	stats->fcp_input_megabytes = div_u64(fnic->fcp_input_bytes, 1000000);
 +	stats->fcp_output_megabytes = div_u64(fnic->fcp_output_bytes, 1000000);
 +
++=======
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(host));
+ 	struct fc_host_statistics *stats = &fnic->fnic_stats.host_stats;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	return stats;
  }
  
@@@ -571,50 -558,117 +631,136 @@@ static int fnic_scsi_drv_init(struct fn
  	fnic->fnic_max_tag_id = host->can_queue;
  	host->max_lun = fnic->config.luns_per_tgt;
  	host->max_id = FNIC_MAX_FCP_TARGET;
- 	host->max_cmd_len = FCOE_MAX_CMD_LEN;
+ 	host->max_cmd_len = FNIC_FCOE_MAX_CMD_LEN;
  
  	host->nr_hw_queues = fnic->wq_copy_count;
 +	if (host->nr_hw_queues > 1)
 +		shost_printk(KERN_ERR, host,
 +				"fnic: blk-mq is not supported");
 +
 +	host->nr_hw_queues = fnic->wq_copy_count = 1;
  
 -	dev_info(&fnic->pdev->dev, "fnic: can_queue: %d max_lun: %llu",
 +	shost_printk(KERN_INFO, host,
 +			"fnic: can_queue: %d max_lun: %llu",
  			host->can_queue, host->max_lun);
  
 -	dev_info(&fnic->pdev->dev, "fnic: max_id: %d max_cmd_len: %d nr_hw_queues: %d",
 +	shost_printk(KERN_INFO, host,
 +			"fnic: max_id: %d max_cmd_len: %d nr_hw_queues: %d",
  			host->max_id, host->max_cmd_len, host->nr_hw_queues);
  
+ 	for (hwq = 0; hwq < fnic->wq_copy_count; hwq++) {
+ 		fnic->sw_copy_wq[hwq].ioreq_table_size = fnic->fnic_max_tag_id;
+ 		fnic->sw_copy_wq[hwq].io_req_table =
+ 			kzalloc((fnic->sw_copy_wq[hwq].ioreq_table_size + 1) *
+ 					sizeof(struct fnic_io_req *), GFP_KERNEL);
+ 	}
+ 
+ 	dev_info(&fnic->pdev->dev, "fnic copy wqs: %d, Q0 ioreq table size: %d\n",
+ 			fnic->wq_copy_count, fnic->sw_copy_wq[0].ioreq_table_size);
+ 
+ 	fnic_scsi_init(fnic);
+ 
+ 	err = scsi_add_host(fnic->lport->host, &pdev->dev);
+ 	if (err) {
+ 		dev_err(&fnic->pdev->dev, "fnic: scsi add host failed: aborting\n");
+ 		return -1;
+ 	}
+ 	fc_host_maxframe_size(fnic->lport->host) = iport->max_payload_size;
+ 	fc_host_dev_loss_tmo(fnic->lport->host) =
+ 		fnic->config.port_down_timeout / 1000;
+ 	sprintf(fc_host_symbolic_name(fnic->lport->host),
+ 			DRV_NAME " v" DRV_VERSION " over %s", fnic->name);
+ 	fc_host_port_type(fnic->lport->host) = FC_PORTTYPE_NPORT;
+ 	fc_host_node_name(fnic->lport->host) = iport->wwnn;
+ 	fc_host_port_name(fnic->lport->host) = iport->wwpn;
+ 	fc_host_supported_classes(fnic->lport->host) = FC_COS_CLASS3;
+ 	memset(fc_host_supported_fc4s(fnic->lport->host), 0,
+ 		   sizeof(fc_host_supported_fc4s(fnic->lport->host)));
+ 	fc_host_supported_fc4s(fnic->lport->host)[2] = 1;
+ 	fc_host_supported_fc4s(fnic->lport->host)[7] = 1;
+ 	fc_host_supported_speeds(fnic->lport->host) = 0;
+ 	fc_host_supported_speeds(fnic->lport->host) |= FC_PORTSPEED_8GBIT;
+ 
+ 	dev_info(&fnic->pdev->dev, "shost_data: 0x%p\n", fnic->lport->host->shost_data);
+ 	if (fnic->lport->host->shost_data != NULL) {
+ 		if (fnic_tgt_id_binding == 0) {
+ 			dev_info(&fnic->pdev->dev, "Setting target binding to NONE\n");
+ 			fc_host_tgtid_bind_type(fnic->lport->host) = FC_TGTID_BIND_NONE;
+ 		} else {
+ 			dev_info(&fnic->pdev->dev, "Setting target binding to WWPN\n");
+ 			fc_host_tgtid_bind_type(fnic->lport->host) = FC_TGTID_BIND_BY_WWPN;
+ 		}
+ 	}
+ 
+ 	fnic->io_req_pool = mempool_create_slab_pool(2, fnic_io_req_cache);
+ 	if (!fnic->io_req_pool) {
+ 		scsi_remove_host(fnic->lport->host);
+ 		return -ENOMEM;
+ 	}
+ 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void fnic_mq_map_queues_cpus(struct Scsi_Host *host)
+ {
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(host));
+ 	struct pci_dev *l_pdev = fnic->pdev;
+ 	int intr_mode = fnic->config.intr_mode;
+ 	struct blk_mq_queue_map *qmap = &host->tag_set.map[HCTX_TYPE_DEFAULT];
+ 
+ 	if (intr_mode == VNIC_DEV_INTR_MODE_MSI || intr_mode == VNIC_DEV_INTR_MODE_INTX) {
+ 		FNIC_MAIN_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"intr_mode is not msix\n");
+ 		return;
+ 	}
+ 
+ 	FNIC_MAIN_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			"qmap->nr_queues: %d\n", qmap->nr_queues);
+ 
+ 	if (l_pdev == NULL) {
+ 		FNIC_MAIN_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 						"l_pdev is null\n");
+ 		return;
+ 	}
+ 
+ 	blk_mq_pci_map_queues(qmap, l_pdev, FNIC_PCI_OFFSET);
+ }
+ 
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  static int fnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  {
- 	struct Scsi_Host *host;
- 	struct fc_lport *lp;
+ 	struct Scsi_Host *host = NULL;
  	struct fnic *fnic;
  	mempool_t *pool;
+ 	struct fnic_iport_s *iport;
  	int err = 0;
  	int fnic_id = 0;
  	int i;
  	unsigned long flags;
++<<<<<<< HEAD
++=======
+ 	char *desc, *subsys_desc;
+ 	int len;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  
  	/*
- 	 * Allocate SCSI Host and set up association between host,
- 	 * local port, and fnic
+ 	 * Allocate fnic
  	 */
++<<<<<<< HEAD
 +	lp = libfc_host_alloc(&fnic_host_template, sizeof(struct fnic));
 +	if (!lp) {
 +		printk(KERN_ERR PFX "Unable to alloc libfc local port\n");
++=======
+ 	fnic = kzalloc(sizeof(struct fnic), GFP_KERNEL);
+ 	if (!fnic) {
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  		err = -ENOMEM;
- 		goto err_out;
+ 		goto err_out_fnic_alloc;
  	}
  
- 	host = lp->host;
- 	fnic = lport_priv(lp);
+ 	iport = &fnic->iport;
  
  	fnic_id = ida_alloc(&fnic_ida, GFP_KERNEL);
  	if (fnic_id < 0) {
@@@ -622,35 -676,37 +768,49 @@@
  		err = fnic_id;
  		goto err_out_ida_alloc;
  	}
++<<<<<<< HEAD
 +	fnic->lport = lp;
 +	fnic->ctlr.lp = lp;
 +
 +	fnic->link_events = 0;
 +
 +	snprintf(fnic->name, sizeof(fnic->name) - 1, "%s%d", DRV_NAME,
 +		 host->host_no);
 +
 +	host->transportt = fnic_fc_transport;
++=======
+ 
+ 	fnic->pdev = pdev;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	fnic->fnic_num = fnic_id;
- 	fnic_stats_debugfs_init(fnic);
  
 -	/* Find model name from PCIe subsys ID */
 -	if (fnic_get_desc_by_devid(pdev, &desc, &subsys_desc) == 0) {
 -		dev_info(&fnic->pdev->dev, "Model: %s\n", subsys_desc);
 -
 -		/* Update FDMI model */
 -		fnic->subsys_desc_len = strlen(subsys_desc);
 -		len = ARRAY_SIZE(fnic->subsys_desc);
 -		if (fnic->subsys_desc_len > len)
 -			fnic->subsys_desc_len = len;
 -		memcpy(fnic->subsys_desc, subsys_desc, fnic->subsys_desc_len);
 -		dev_info(&fnic->pdev->dev, "FDMI Model: %s\n", fnic->subsys_desc);
 -	} else {
 -		fnic->subsys_desc_len = 0;
 -		dev_info(&fnic->pdev->dev, "Model: %s subsys_id: 0x%04x\n", "Unknown",
 -				pdev->subsystem_device);
 -	}
 +	/* Setup PCI resources */
 +	pci_set_drvdata(pdev, fnic);
 +
 +	fnic->pdev = pdev;
  
  	err = pci_enable_device(pdev);
  	if (err) {
++<<<<<<< HEAD
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Cannot enable PCI device, aborting.\n");
 +		goto err_out_free_hba;
++=======
+ 		dev_err(&fnic->pdev->dev, "Cannot enable PCI device, aborting.\n");
+ 		goto err_out_pci_enable_device;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  
  	err = pci_request_regions(pdev, DRV_NAME);
  	if (err) {
++<<<<<<< HEAD
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Cannot enable PCI resources, aborting\n");
 +		goto err_out_disable_device;
++=======
+ 		dev_err(&fnic->pdev->dev, "Cannot enable PCI resources, aborting\n");
+ 		goto err_out_pci_request_regions;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  
  	pci_set_master(pdev);
@@@ -663,19 -719,17 +823,19 @@@
  	if (err) {
  		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
  		if (err) {
 -			dev_err(&fnic->pdev->dev, "No usable DMA configuration "
 +			shost_printk(KERN_ERR, fnic->lport->host,
 +				     "No usable DMA configuration "
  				     "aborting\n");
- 			goto err_out_release_regions;
+ 			goto err_out_set_dma_mask;
  		}
  	}
  
  	/* Map vNIC resources from BAR0 */
  	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
 -		dev_err(&fnic->pdev->dev, "BAR0 not memory-map'able, aborting.\n");
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "BAR0 not memory-map'able, aborting.\n");
  		err = -ENODEV;
- 		goto err_out_release_regions;
+ 		goto err_out_map_bar;
  	}
  
  	fnic->bar0.vaddr = pci_iomap(pdev, 0, 0);
@@@ -683,83 -737,101 +843,130 @@@
  	fnic->bar0.len = pci_resource_len(pdev, 0);
  
  	if (!fnic->bar0.vaddr) {
 -		dev_err(&fnic->pdev->dev, "Cannot memory-map BAR0 res hdr, "
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Cannot memory-map BAR0 res hdr, "
  			     "aborting.\n");
  		err = -ENODEV;
- 		goto err_out_release_regions;
+ 		goto err_out_fnic_map_bar;
  	}
  
  	fnic->vdev = vnic_dev_register(NULL, fnic, pdev, &fnic->bar0);
  	if (!fnic->vdev) {
 -		dev_err(&fnic->pdev->dev, "vNIC registration failed, "
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "vNIC registration failed, "
  			     "aborting.\n");
  		err = -ENODEV;
- 		goto err_out_iounmap;
+ 		goto err_out_dev_register;
  	}
  
  	err = vnic_dev_cmd_init(fnic->vdev);
  	if (err) {
 -		dev_err(&fnic->pdev->dev, "vnic_dev_cmd_init() returns %d, aborting\n",
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +				"vnic_dev_cmd_init() returns %d, aborting\n",
  				err);
- 		goto err_out_vnic_unregister;
+ 		goto err_out_dev_cmd_init;
  	}
  
  	err = fnic_dev_wait(fnic->vdev, vnic_dev_open,
  			    vnic_dev_open_done, CMD_OPENF_RQ_ENABLE_THEN_POST);
  	if (err) {
++<<<<<<< HEAD
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "vNIC dev open failed, aborting.\n");
 +		goto err_out_dev_cmd_deinit;
++=======
+ 		dev_err(&fnic->pdev->dev, "vNIC dev open failed, aborting.\n");
+ 		goto err_out_dev_open;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  
  	err = vnic_dev_init(fnic->vdev, 0);
  	if (err) {
++<<<<<<< HEAD
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "vNIC dev init failed, aborting.\n");
 +		goto err_out_dev_close;
++=======
+ 		dev_err(&fnic->pdev->dev, "vNIC dev init failed, aborting.\n");
+ 		goto err_out_dev_init;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  
- 	err = vnic_dev_mac_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);
+ 	err = vnic_dev_mac_addr(fnic->vdev, iport->hwmac);
  	if (err) {
++<<<<<<< HEAD
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "vNIC get MAC addr failed \n");
 +		goto err_out_dev_close;
++=======
+ 		dev_err(&fnic->pdev->dev, "vNIC get MAC addr failed\n");
+ 		goto err_out_dev_mac_addr;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  	/* set data_src for point-to-point mode and to keep it non-zero */
- 	memcpy(fnic->data_src_addr, fnic->ctlr.ctl_src_addr, ETH_ALEN);
+ 	memcpy(fnic->data_src_addr, iport->hwmac, ETH_ALEN);
  
  	/* Get vNIC configuration */
  	err = fnic_get_vnic_config(fnic);
  	if (err) {
 -		dev_err(&fnic->pdev->dev, "Get vNIC configuration failed, "
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Get vNIC configuration failed, "
  			     "aborting.\n");
- 		goto err_out_dev_close;
+ 		goto err_out_fnic_get_config;
+ 	}
+ 
+ 	switch (fnic->config.flags & 0xff0) {
+ 	case VFCF_FC_INITIATOR:
+ 		{
+ 			host =
+ 				scsi_host_alloc(&fnic_host_template,
+ 								sizeof(struct fnic *));
+ 			if (!host) {
+ 				dev_err(&fnic->pdev->dev, "Unable to allocate scsi host\n");
+ 				err = -ENOMEM;
+ 				goto err_out_scsi_host_alloc;
+ 			}
+ 			*((struct fnic **) shost_priv(host)) = fnic;
+ 
+ 			fnic->lport->host = host;
+ 			fnic->role = FNIC_ROLE_FCP_INITIATOR;
+ 			dev_info(&fnic->pdev->dev, "fnic: %d is scsi initiator\n",
+ 					fnic->fnic_num);
+ 		}
+ 		break;
+ 	default:
+ 		dev_info(&fnic->pdev->dev, "fnic: %d has no role defined\n", fnic->fnic_num);
+ 		err = -EINVAL;
+ 		goto err_out_fnic_role;
  	}
  
 -	/* Setup PCI resources */
 -	pci_set_drvdata(pdev, fnic);
 +	fnic_scsi_drv_init(fnic);
  
  	fnic_get_res_counts(fnic);
  
  	err = fnic_set_intr_mode(fnic);
  	if (err) {
 -		dev_err(&fnic->pdev->dev, "Failed to set intr mode, "
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Failed to set intr mode, "
  			     "aborting.\n");
- 		goto err_out_dev_close;
+ 		goto err_out_fnic_set_intr_mode;
  	}
  
  	err = fnic_alloc_vnic_resources(fnic);
  	if (err) {
 -		dev_err(&fnic->pdev->dev, "Failed to alloc vNIC resources, "
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Failed to alloc vNIC resources, "
  			     "aborting.\n");
++<<<<<<< HEAD
 +		goto err_out_clear_intr;
 +	}
 +
++=======
+ 		goto err_out_fnic_alloc_vnic_res;
+ 	}
+ 	dev_info(&fnic->pdev->dev, "fnic copy wqs: %d, Q0 ioreq table size: %d\n",
+ 			fnic->wq_copy_count, fnic->sw_copy_wq[0].ioreq_table_size);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  
  	/* initialize all fnic locks */
  	spin_lock_init(&fnic->fnic_lock);
@@@ -774,17 -846,9 +981,20 @@@
  		fnic->fw_ack_index[i] = -1;
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < FNIC_IO_LOCKS; i++)
 +		spin_lock_init(&fnic->io_req_lock[i]);
 +
 +	err = -ENOMEM;
 +	fnic->io_req_pool = mempool_create_slab_pool(2, fnic_io_req_cache);
 +	if (!fnic->io_req_pool)
 +		goto err_out_free_resources;
 +
++=======
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	pool = mempool_create_slab_pool(2, fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);
  	if (!pool)
- 		goto err_out_free_ioreq_pool;
+ 		goto err_out_free_resources;
  	fnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT] = pool;
  
  	pool = mempool_create_slab_pool(2, fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);
@@@ -806,21 -876,18 +1016,29 @@@
  		/* enable directed and multicast */
  		vnic_dev_packet_filter(fnic->vdev, 1, 1, 0, 0, 0);
  		vnic_dev_add_addr(fnic->vdev, FIP_ALL_ENODE_MACS);
++<<<<<<< HEAD
 +		vnic_dev_add_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);
 +		fnic->set_vlan = fnic_set_vlan;
 +		fcoe_ctlr_init(&fnic->ctlr, FIP_MODE_AUTO);
 +		timer_setup(&fnic->fip_timer, fnic_fip_notify_timer, 0);
++=======
+ 		vnic_dev_add_addr(fnic->vdev, iport->hwmac);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  		spin_lock_init(&fnic->vlans_lock);
  		INIT_WORK(&fnic->fip_frame_work, fnic_handle_fip_frame);
 -		INIT_LIST_HEAD(&fnic->fip_frame_queue);
 -		INIT_LIST_HEAD(&fnic->vlan_list);
 -		timer_setup(&fnic->retry_fip_timer, fnic_handle_fip_timer, 0);
 -		timer_setup(&fnic->fcs_ka_timer, fnic_handle_fcs_ka_timer, 0);
 -		timer_setup(&fnic->enode_ka_timer, fnic_handle_enode_ka_timer, 0);
 -		timer_setup(&fnic->vn_ka_timer, fnic_handle_vn_ka_timer, 0);
 -		fnic->set_vlan = fnic_set_vlan;
 +		INIT_WORK(&fnic->event_work, fnic_handle_event);
 +		skb_queue_head_init(&fnic->fip_frame_queue);
 +		INIT_LIST_HEAD(&fnic->evlist);
 +		INIT_LIST_HEAD(&fnic->vlans);
  	} else {
++<<<<<<< HEAD
 +		shost_printk(KERN_INFO, fnic->lport->host,
 +			     "firmware uses non-FIP mode\n");
 +		fcoe_ctlr_init(&fnic->ctlr, FIP_MODE_NON_FIP);
 +		fnic->ctlr.state = FIP_ST_NON_FIP;
++=======
+ 		dev_info(&fnic->pdev->dev, "firmware uses non-FIP mode\n");
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  	fnic->state = FNIC_IN_FC_MODE;
  
@@@ -833,9 -900,8 +1051,14 @@@
  	/* Setup notification buffer area */
  	err = fnic_notify_set(fnic);
  	if (err) {
++<<<<<<< HEAD
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Failed to alloc notify buffer, aborting.\n");
 +		goto err_out_free_max_pool;
++=======
+ 		dev_err(&fnic->pdev->dev, "Failed to alloc notify buffer, aborting.\n");
+ 		goto err_out_fnic_notify_set;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	}
  
  	/* Setup notify timer when using MSI interrupts */
@@@ -844,113 -910,122 +1067,226 @@@
  
  	/* allocate RQ buffers and post them to RQ*/
  	for (i = 0; i < fnic->rq_count; i++) {
 +		vnic_rq_enable(&fnic->rq[i]);
  		err = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);
  		if (err) {
 -			dev_err(&fnic->pdev->dev, "fnic_alloc_rq_frame can't alloc "
 +			shost_printk(KERN_ERR, fnic->lport->host,
 +				     "fnic_alloc_rq_frame can't alloc "
  				     "frame\n");
++<<<<<<< HEAD
 +			goto err_out_free_rq_buf;
 +		}
 +	}
 +
 +	/*
 +	 * Initialization done with PCI system, hardware, firmware.
 +	 * Add host to SCSI
 +	 */
 +	err = scsi_add_host(lp->host, &pdev->dev);
 +	if (err) {
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "fnic: scsi_add_host failed...exiting\n");
 +		goto err_out_free_rq_buf;
 +	}
 +
 +	/* Start local port initiatialization */
 +
 +	lp->link_up = 0;
 +
 +	lp->max_retry_count = fnic->config.flogi_retries;
 +	lp->max_rport_retry_count = fnic->config.plogi_retries;
 +	lp->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |
 +			      FCP_SPPF_CONF_COMPL);
 +	if (fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR)
 +		lp->service_params |= FCP_SPPF_RETRY;
 +
 +	lp->boot_time = jiffies;
 +	lp->e_d_tov = fnic->config.ed_tov;
 +	lp->r_a_tov = fnic->config.ra_tov;
 +	lp->link_supported_speeds = FC_PORTSPEED_10GBIT;
 +	fc_set_wwnn(lp, fnic->config.node_wwn);
 +	fc_set_wwpn(lp, fnic->config.port_wwn);
 +
 +	fcoe_libfc_config(lp, &fnic->ctlr, &fnic_transport_template, 0);
 +
 +	if (!fc_exch_mgr_alloc(lp, FC_CLASS_3, FCPIO_HOST_EXCH_RANGE_START,
 +			       FCPIO_HOST_EXCH_RANGE_END, NULL)) {
 +		err = -ENOMEM;
 +		goto err_out_remove_scsi_host;
 +	}
 +
 +	fc_lport_init_stats(lp);
 +	fnic->stats_reset_time = jiffies;
 +
 +	fc_lport_config(lp);
 +
 +	if (fc_set_mfs(lp, fnic->config.maxdatafieldsize +
 +		       sizeof(struct fc_frame_header))) {
 +		err = -EINVAL;
 +		goto err_out_free_exch_mgr;
 +	}
 +	fc_host_maxframe_size(lp->host) = lp->mfs;
 +	fc_host_dev_loss_tmo(lp->host) = fnic->config.port_down_timeout / 1000;
 +
 +	sprintf(fc_host_symbolic_name(lp->host),
 +		DRV_NAME " v" DRV_VERSION " over %s", fnic->name);
++=======
+ 			goto err_out_alloc_rq_buf;
+ 		}
+ 	}
+ 
+ 	init_completion(&fnic->reset_completion_wait);
+ 
+ 	/* Start local port initialization */
+ 	iport->max_flogi_retries = fnic->config.flogi_retries;
+ 	iport->max_plogi_retries = fnic->config.plogi_retries;
+ 	iport->plogi_timeout = fnic->config.plogi_timeout;
+ 	iport->service_params =
+ 		(FNIC_FCP_SP_INITIATOR | FNIC_FCP_SP_RD_XRDY_DIS |
+ 		 FNIC_FCP_SP_CONF_CMPL);
+ 	if (fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR)
+ 		iport->service_params |= FNIC_FCP_SP_RETRY;
+ 
+ 	iport->boot_time = jiffies;
+ 	iport->e_d_tov = fnic->config.ed_tov;
+ 	iport->r_a_tov = fnic->config.ra_tov;
+ 	iport->link_supported_speeds = FNIC_PORTSPEED_10GBIT;
+ 	iport->wwpn = fnic->config.port_wwn;
+ 	iport->wwnn = fnic->config.node_wwn;
+ 
+ 	iport->max_payload_size = fnic->config.maxdatafieldsize;
+ 
+ 	if ((iport->max_payload_size < FNIC_MIN_DATA_FIELD_SIZE) ||
+ 		(iport->max_payload_size > FNIC_FC_MAX_PAYLOAD_LEN) ||
+ 		((iport->max_payload_size % 4) != 0)) {
+ 		iport->max_payload_size = FNIC_FC_MAX_PAYLOAD_LEN;
+ 	}
+ 
+ 	iport->flags |= FNIC_FIRST_LINK_UP;
+ 
+ 	timer_setup(&(iport->fabric.retry_timer), fdls_fabric_timer_callback,
+ 				0);
+ 
+ 	fnic->stats_reset_time = jiffies;
+ 
+ 	INIT_WORK(&fnic->link_work, fnic_handle_link);
+ 	INIT_WORK(&fnic->frame_work, fnic_handle_frame);
+ 	INIT_WORK(&fnic->tport_work, fnic_tport_event_handler);
+ 	INIT_WORK(&fnic->flush_work, fnic_flush_tx);
+ 
+ 	INIT_LIST_HEAD(&fnic->frame_queue);
+ 	INIT_LIST_HEAD(&fnic->tx_queue);
+ 	INIT_LIST_HEAD(&fnic->tport_event_list);
+ 
+ 	INIT_DELAYED_WORK(&iport->oxid_pool.schedule_oxid_free_retry,
+ 	fdls_schedule_oxid_free_retry_work);
+ 
+ 	/* Initialize the oxid reclaim list and work struct */
+ 	INIT_LIST_HEAD(&iport->oxid_pool.oxid_reclaim_list);
+ 	INIT_DELAYED_WORK(&iport->oxid_pool.oxid_reclaim_work, fdls_reclaim_oxid_handler);
+ 
+ 	/* Enable all queues */
+ 	for (i = 0; i < fnic->raw_wq_count; i++)
+ 		vnic_wq_enable(&fnic->wq[i]);
+ 	for (i = 0; i < fnic->rq_count; i++) {
+ 		if (!ioread32(&fnic->rq[i].ctrl->enable))
+ 			vnic_rq_enable(&fnic->rq[i]);
+ 	}
+ 	for (i = 0; i < fnic->wq_copy_count; i++)
+ 		vnic_wq_copy_enable(&fnic->hw_copy_wq[i]);
+ 
+ 	vnic_dev_enable(fnic->vdev);
+ 
+ 	err = fnic_request_intr(fnic);
+ 	if (err) {
+ 		dev_err(&fnic->pdev->dev, "Unable to request irq.\n");
+ 		goto err_out_fnic_request_intr;
+ 	}
+ 
+ 	fnic_notify_timer_start(fnic);
+ 
+ 	fnic_fdls_init(fnic, (fnic->config.flags & VFCF_FIP_CAPABLE));
+ 
+ 	if (IS_FNIC_FCP_INITIATOR(fnic) && fnic_scsi_drv_init(fnic))
+ 		goto err_out_scsi_drv_init;
+ 
+ 	err = fnic_stats_debugfs_init(fnic);
+ 	if (err) {
+ 		dev_err(&fnic->pdev->dev, "Failed to initialize debugfs for stats\n");
+ 		goto err_out_free_stats_debugfs;
+ 	}
+ 
+ 	for (i = 0; i < fnic->intr_count; i++)
+ 		vnic_intr_unmask(&fnic->intr[i]);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  
  	spin_lock_irqsave(&fnic_list_lock, flags);
  	list_add_tail(&fnic->list, &fnic_list);
  	spin_unlock_irqrestore(&fnic_list_lock, flags);
  
++<<<<<<< HEAD
 +	INIT_WORK(&fnic->link_work, fnic_handle_link);
 +	INIT_WORK(&fnic->frame_work, fnic_handle_frame);
 +	INIT_WORK(&fnic->flush_work, fnic_flush_tx);
 +	skb_queue_head_init(&fnic->frame_queue);
 +	skb_queue_head_init(&fnic->tx_queue);
 +
 +	/* Enable all queues */
 +	for (i = 0; i < fnic->raw_wq_count; i++)
 +		vnic_wq_enable(&fnic->wq[i]);
 +	for (i = 0; i < fnic->wq_copy_count; i++)
 +		vnic_wq_copy_enable(&fnic->hw_copy_wq[i]);
 +
 +	fc_fabric_login(lp);
 +
 +	err = fnic_request_intr(fnic);
 +	if (err) {
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "Unable to request irq.\n");
 +		goto err_out_free_exch_mgr;
 +	}
 +
 +	vnic_dev_enable(fnic->vdev);
 +
 +	for (i = 0; i < fnic->intr_count; i++)
 +		vnic_intr_unmask(&fnic->intr[i]);
 +
 +	fnic_notify_timer_start(fnic);
 +
 +	return 0;
 +
 +err_out_free_exch_mgr:
 +	fc_exch_mgr_free(lp);
 +err_out_remove_scsi_host:
 +	fc_remove_host(lp->host);
 +	scsi_remove_host(lp->host);
 +err_out_free_rq_buf:
 +	for (i = 0; i < fnic->rq_count; i++)
 +		vnic_rq_clean(&fnic->rq[i], fnic_free_rq_buf);
 +	vnic_dev_notify_unset(fnic->vdev);
 +err_out_free_max_pool:
++=======
+ 	return 0;
+ 
+ err_out_free_stats_debugfs:
+ 	fnic_stats_debugfs_remove(fnic);
+ 	scsi_remove_host(fnic->lport->host);
+ err_out_scsi_drv_init:
+ 	fnic_free_intr(fnic);
+ err_out_fnic_request_intr:
+ err_out_alloc_rq_buf:
+ 	for (i = 0; i < fnic->rq_count; i++) {
+ 		if (ioread32(&fnic->rq[i].ctrl->enable))
+ 			vnic_rq_disable(&fnic->rq[i]);
+ 		vnic_rq_clean(&fnic->rq[i], fnic_free_rq_buf);
+ 	}
+ 	vnic_dev_notify_unset(fnic->vdev);
+ err_out_fnic_notify_set:
+ 	mempool_destroy(fnic->frame_elem_pool);
+ err_out_fdls_frame_elem_pool:
+ 	mempool_destroy(fnic->frame_pool);
+ err_out_fdls_frame_pool:
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	mempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_MAX]);
  err_out_free_dflt_pool:
  	mempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT]);
@@@ -983,15 -1064,16 +1325,19 @@@ err_out_fnic_alloc
  static void fnic_remove(struct pci_dev *pdev)
  {
  	struct fnic *fnic = pci_get_drvdata(pdev);
- 	struct fc_lport *lp = fnic->lport;
  	unsigned long flags;
++<<<<<<< HEAD
++=======
  
  	/*
- 	 * Mark state so that the workqueue thread stops forwarding
- 	 * received frames and link events to the local port. ISR and
- 	 * other threads that can queue work items will also stop
- 	 * creating work items on the fnic workqueue
+ 	 * Sometimes when probe() fails and do not exit with an error code,
+ 	 * remove() gets called with 'drvdata' not set. Avoid a crash by
+ 	 * adding a defensive check.
  	 */
+ 	if (!fnic)
+ 		return;
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
+ 
  	spin_lock_irqsave(&fnic->fnic_lock, flags);
  	fnic->stop_rx_link_events = 1;
  	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
@@@ -1004,29 -1083,26 +1347,44 @@@
  	 * be no event queued for this fnic device in the workqueue
  	 */
  	flush_workqueue(fnic_event_queue);
++<<<<<<< HEAD
 +	skb_queue_purge(&fnic->frame_queue);
 +	skb_queue_purge(&fnic->tx_queue);
++=======
+ 
+ 	if (IS_FNIC_FCP_INITIATOR(fnic))
+ 		fnic_scsi_unload(fnic);
+ 
+ 	if (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)
+ 		del_timer_sync(&fnic->notify_timer);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  
  	if (fnic->config.flags & VFCF_FIP_CAPABLE) {
 -		del_timer_sync(&fnic->retry_fip_timer);
 -		del_timer_sync(&fnic->fcs_ka_timer);
 -		del_timer_sync(&fnic->enode_ka_timer);
 -		del_timer_sync(&fnic->vn_ka_timer);
 -
 -		fnic_free_txq(&fnic->fip_frame_queue);
 +		del_timer_sync(&fnic->fip_timer);
 +		skb_queue_purge(&fnic->fip_frame_queue);
  		fnic_fcoe_reset_vlans(fnic);
 +		fnic_fcoe_evlist_free(fnic);
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Log off the fabric. This stops all remote ports, dns port,
 +	 * logs off the fabric. This flushes all rport, disc, lport work
 +	 * before returning
 +	 */
 +	fc_fabric_logoff(fnic->lport);
 +
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	fnic->in_remove = 1;
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +
 +	fcoe_ctlr_destroy(&fnic->ctlr);
 +	fc_lport_destroy(lp);
++=======
+ 	if ((fnic_fdmi_support == 1) && (fnic->iport.fabric.fdmi_pending > 0))
+ 		del_timer_sync(&fnic->iport.fabric.fdmi_timer);
+ 
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	fnic_stats_debugfs_remove(fnic);
  
  	/*
@@@ -1043,9 -1116,9 +1401,15 @@@
  	list_del(&fnic->list);
  	spin_unlock_irqrestore(&fnic_list_lock, flags);
  
++<<<<<<< HEAD
 +	fc_remove_host(fnic->lport->host);
 +	scsi_remove_host(fnic->lport->host);
 +	fc_exch_mgr_free(fnic->lport);
++=======
+ 	fnic_free_txq(&fnic->frame_queue);
+ 	fnic_free_txq(&fnic->tx_queue);
+ 
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  	vnic_dev_notify_unset(fnic->vdev);
  	fnic_free_intr(fnic);
  	fnic_free_vnic_resources(fnic);
diff --cc drivers/scsi/fnic/fnic_res.c
index f7c2ee009426,763475587b7f..000000000000
--- a/drivers/scsi/fnic/fnic_res.c
+++ b/drivers/scsi/fnic/fnic_res.c
@@@ -151,40 -142,28 +156,65 @@@ int fnic_get_vnic_config(struct fnic *f
  
  	c->wq_copy_count = min_t(u16, FNIC_WQ_COPY_MAX, c->wq_copy_count);
  
++<<<<<<< HEAD
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC MAC addr %pM "
 +		     "wq/wq_copy/rq %d/%d/%d\n",
 +		     fnic->ctlr.ctl_src_addr,
 +		     c->wq_enet_desc_count, c->wq_copy_desc_count,
 +		     c->rq_desc_count);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC node wwn %llx port wwn %llx\n",
 +		     c->node_wwn, c->port_wwn);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC ed_tov %d ra_tov %d\n",
 +		     c->ed_tov, c->ra_tov);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC mtu %d intr timer %d\n",
 +		     c->maxdatafieldsize, c->intr_timer);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC flags 0x%x luns per tgt %d\n",
 +		     c->flags, c->luns_per_tgt);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC flogi_retries %d flogi timeout %d\n",
 +		     c->flogi_retries, c->flogi_timeout);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC plogi retries %d plogi timeout %d\n",
 +		     c->plogi_retries, c->plogi_timeout);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC io throttle count %d link dn timeout %d\n",
 +		     c->io_throttle_count, c->link_down_timeout);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +		     "vNIC port dn io retries %d port dn timeout %d\n",
 +		     c->port_down_io_retries, c->port_down_timeout);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +			"vNIC wq_copy_count: %d\n", c->wq_copy_count);
 +	shost_printk(KERN_INFO, fnic->lport->host,
 +			"vNIC intr mode: %d\n", c->intr_mode);
++=======
+ 	dev_info(&fnic->pdev->dev, "fNIC MAC addr %p wq/wq_copy/rq %d/%d/%d\n",
+ 			fnic->data_src_addr,
+ 		     c->wq_enet_desc_count, c->wq_copy_desc_count,
+ 		     c->rq_desc_count);
+ 	dev_info(&fnic->pdev->dev, "fNIC node wwn 0x%llx port wwn 0x%llx\n",
+ 		     c->node_wwn, c->port_wwn);
+ 	dev_info(&fnic->pdev->dev, "fNIC ed_tov %d ra_tov %d\n",
+ 		     c->ed_tov, c->ra_tov);
+ 	dev_info(&fnic->pdev->dev, "fNIC mtu %d intr timer %d\n",
+ 		     c->maxdatafieldsize, c->intr_timer);
+ 	dev_info(&fnic->pdev->dev, "fNIC flags 0x%x luns per tgt %d\n",
+ 		     c->flags, c->luns_per_tgt);
+ 	dev_info(&fnic->pdev->dev, "fNIC flogi_retries %d flogi timeout %d\n",
+ 		     c->flogi_retries, c->flogi_timeout);
+ 	dev_info(&fnic->pdev->dev, "fNIC plogi retries %d plogi timeout %d\n",
+ 		     c->plogi_retries, c->plogi_timeout);
+ 	dev_info(&fnic->pdev->dev, "fNIC io throttle count %d link dn timeout %d\n",
+ 		     c->io_throttle_count, c->link_down_timeout);
+ 	dev_info(&fnic->pdev->dev, "fNIC port dn io retries %d port dn timeout %d\n",
+ 		     c->port_down_io_retries, c->port_down_timeout);
+ 	dev_info(&fnic->pdev->dev, "fNIC wq_copy_count: %d\n", c->wq_copy_count);
+ 	dev_info(&fnic->pdev->dev, "fNIC intr mode: %d\n", c->intr_mode);
++>>>>>>> 9243626c211e (scsi: fnic: Modify fnic interfaces to use FDLS)
  
  	return 0;
  }
* Unmerged path drivers/scsi/fnic/fnic.h
diff --git a/drivers/scsi/fnic/fnic_attrs.c b/drivers/scsi/fnic/fnic_attrs.c
index 6e6e125207e0..f6fef1c02ef2 100644
--- a/drivers/scsi/fnic/fnic_attrs.c
+++ b/drivers/scsi/fnic/fnic_attrs.c
@@ -23,8 +23,8 @@
 static ssize_t fnic_show_state(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
-	struct fc_lport *lp = shost_priv(class_to_shost(dev));
-	struct fnic *fnic = lport_priv(lp);
+	struct fnic *fnic =
+		*((struct fnic **) shost_priv(class_to_shost(dev)));
 
 	return sysfs_emit(buf, "%s\n", fnic_state_str[fnic->state]);
 }
@@ -38,9 +38,13 @@ static ssize_t fnic_show_drv_version(struct device *dev,
 static ssize_t fnic_show_link_state(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct fc_lport *lp = shost_priv(class_to_shost(dev));
+	struct fnic *fnic =
+		*((struct fnic **) shost_priv(class_to_shost(dev)));
 
-	return sysfs_emit(buf, "%s\n", (lp->link_up) ? "Link Up" : "Link Down");
+	return sysfs_emit(buf, "%s\n",
+					  ((fnic->iport.state != FNIC_IPORT_STATE_INIT) &&
+					   (fnic->iport.state != FNIC_IPORT_STATE_LINK_WAIT)) ?
+					  "Link Up" : "Link Down");
 }
 
 static DEVICE_ATTR(fnic_state, S_IRUGO, fnic_show_state, NULL);
diff --git a/drivers/scsi/fnic/fnic_debugfs.c b/drivers/scsi/fnic/fnic_debugfs.c
index 1a4151ef90c1..892f48d1a91c 100644
--- a/drivers/scsi/fnic/fnic_debugfs.c
+++ b/drivers/scsi/fnic/fnic_debugfs.c
@@ -21,6 +21,9 @@
 #include <linux/vmalloc.h>
 #include "fnic.h"
 
+extern int fnic_get_debug_info(struct stats_debug_info *debug_buffer,
+							   struct fnic *fnic);
+
 static struct dentry *fnic_trace_debugfs_root;
 static struct dentry *fnic_trace_debugfs_file;
 static struct dentry *fnic_trace_enable;
@@ -607,6 +610,7 @@ static int fnic_stats_debugfs_open(struct inode *inode,
 	debug->buf_size = buf_size;
 	memset((void *)debug->debug_buffer, 0, buf_size);
 	debug->buffer_len = fnic_get_stats_data(debug, fnic_stats);
+	debug->buffer_len += fnic_get_debug_info(debug, fnic);
 
 	file->private_data = debug;
 
@@ -687,26 +691,48 @@ static const struct file_operations fnic_reset_debugfs_fops = {
  * It will create file stats and reset_stats under statistics/host# directory
  * to log per fnic stats.
  */
-void fnic_stats_debugfs_init(struct fnic *fnic)
+int fnic_stats_debugfs_init(struct fnic *fnic)
 {
+	int rc = -1;
 	char name[16];
 
 	snprintf(name, sizeof(name), "host%d", fnic->lport->host->host_no);
 
+	if (!fnic_stats_debugfs_root) {
+		pr_debug("fnic_stats root doesn't exist\n");
+		return rc;
+	}
+
 	fnic->fnic_stats_debugfs_host = debugfs_create_dir(name,
 						fnic_stats_debugfs_root);
 
+	if (!fnic->fnic_stats_debugfs_host) {
+		pr_debug("Cannot create host directory\n");
+		return rc;
+	}
+
 	fnic->fnic_stats_debugfs_file = debugfs_create_file("stats",
 						S_IFREG|S_IRUGO|S_IWUSR,
 						fnic->fnic_stats_debugfs_host,
 						fnic,
 						&fnic_stats_debugfs_fops);
 
+	if (!fnic->fnic_stats_debugfs_file) {
+		pr_debug("Cannot create host stats file\n");
+		return rc;
+	}
+
 	fnic->fnic_reset_debugfs_file = debugfs_create_file("reset_stats",
 						S_IFREG|S_IRUGO|S_IWUSR,
 						fnic->fnic_stats_debugfs_host,
 						fnic,
 						&fnic_reset_debugfs_fops);
+	if (!fnic->fnic_reset_debugfs_file) {
+		pr_debug("Cannot create host stats file\n");
+		return rc;
+	}
+	rc = 0;
+	return rc;
 }
 
 /*
* Unmerged path drivers/scsi/fnic/fnic_fcs.c
* Unmerged path drivers/scsi/fnic/fnic_main.c
* Unmerged path drivers/scsi/fnic/fnic_res.c
diff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c
index 321954ca143f..aad571cd3f3f 100644
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@ -1707,6 +1707,45 @@ void fnic_terminate_rport_io(struct fc_rport *rport)
 	fnic_rport_exch_reset(fnic, rport->port_id);
 }
 
+/*
+ * FCP-SCSI specific handling for module unload
+ *
+ */
+void fnic_scsi_unload(struct fnic *fnic)
+{
+	unsigned long flags;
+
+	/*
+	 * Mark state so that the workqueue thread stops forwarding
+	 * received frames and link events to the local port. ISR and
+	 * other threads that can queue work items will also stop
+	 * creating work items on the fnic workqueue
+	 */
+	spin_lock_irqsave(&fnic->fnic_lock, flags);
+	fnic->iport.state = FNIC_IPORT_STATE_LINK_WAIT;
+	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+
+	if (fdls_get_state(&fnic->iport.fabric) != FDLS_STATE_INIT)
+		fnic_scsi_fcpio_reset(fnic);
+
+	spin_lock_irqsave(&fnic->fnic_lock, flags);
+	fnic->in_remove = 1;
+	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+
+	fnic_flush_tport_event_list(fnic);
+	fnic_delete_fcp_tports(fnic);
+}
+
+void fnic_scsi_unload_cleanup(struct fnic *fnic)
+{
+	int hwq = 0;
+
+	fc_remove_host(fnic->host);
+	scsi_remove_host(fnic->host);
+	for (hwq = 0; hwq < fnic->wq_copy_count; hwq++)
+		kfree(fnic->sw_copy_wq[hwq].io_req_table);
+}
+
 /*
  * This function is exported to SCSI for sending abort cmnds.
  * A SCSI IO is represented by a io_req in the driver.
diff --git a/drivers/scsi/fnic/fnic_stats.h b/drivers/scsi/fnic/fnic_stats.h
index ca7ab8afa60a..324201ac7d45 100644
--- a/drivers/scsi/fnic/fnic_stats.h
+++ b/drivers/scsi/fnic/fnic_stats.h
@@ -17,6 +17,7 @@
 #ifndef _FNIC_STATS_H_
 #define _FNIC_STATS_H_
 #define FNIC_MQ_MAX_QUEUES 64
+#include <scsi/scsi_transport_fc.h>
 
 struct stats_timestamps {
 	struct timespec64 last_reset_time;
@@ -130,6 +131,7 @@ struct fnic_stats {
 	struct reset_stats reset_stats;
 	struct fw_stats fw_stats;
 	struct vlan_stats vlan_stats;
+	struct fc_host_statistics host_stats;
 	struct misc_stats misc_stats;
 };
 
diff --git a/drivers/scsi/fnic/fnic_trace.c b/drivers/scsi/fnic/fnic_trace.c
index a1d62546c584..7922435e90eb 100644
--- a/drivers/scsi/fnic/fnic_trace.c
+++ b/drivers/scsi/fnic/fnic_trace.c
@@ -472,6 +472,12 @@ int fnic_get_stats_data(struct stats_debug_info *debug,
 
 }
 
+int fnic_get_debug_info(struct stats_debug_info *info, struct fnic *fnic)
+{
+	/* Placeholder function */
+	return 0;
+}
+
 /*
  * fnic_trace_buf_init - Initialize fnic trace buffer logging facility
  *
