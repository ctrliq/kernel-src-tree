scsi: fnic: Remove always-true IS_FNIC_FCP_INITIATOR macro

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Arun Easi <aeasi@cisco.com>
commit 0620efe789a73586b5b3ed38b27d1b69b2150958
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/0620efe7.failed

IS_FNIC_FCP_INITIATOR macro is not applicable at this time.  Delete the
macro.

	Suggested-by: Dan Carpenter <dan.carpenter@linaro.org>
	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Reviewed-by: Gian Carlo Boffa <gcboffa@cisco.com>
	Signed-off-by: Arun Easi <aeasi@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20250110091655.17643-1-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0620efe789a73586b5b3ed38b27d1b69b2150958)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fdls_disc.c
#	drivers/scsi/fnic/fnic.h
#	drivers/scsi/fnic/fnic_main.c
diff --cc drivers/scsi/fnic/fnic.h
index 73fb8245c7b7,6c5f6046b1f5..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -88,16 -80,100 +88,90 @@@
  #define FNIC_DEV_RST_TERM_DONE          BIT(20)
  #define FNIC_DEV_RST_ABTS_PENDING       BIT(21)
  
++<<<<<<< HEAD
++=======
+ #define FNIC_FW_RESET_TIMEOUT        60000	/* mSec   */
+ #define FNIC_FCOE_MAX_CMD_LEN        16
+ /* Retry supported by rport (returned by PRLI service parameters) */
+ #define FNIC_FC_RP_FLAGS_RETRY            0x1
+ 
+ /* Cisco vendor id */
+ #define PCI_VENDOR_ID_CISCO						0x1137
+ #define PCI_DEVICE_ID_CISCO_VIC_FC				0x0045	/* fc vnic */
+ 
+ /* sereno pcie switch */
+ #define PCI_DEVICE_ID_CISCO_SERENO             0x004e
+ #define PCI_DEVICE_ID_CISCO_CRUZ               0x007a	/* Cruz */
+ #define PCI_DEVICE_ID_CISCO_BODEGA             0x0131	/* Bodega */
+ #define PCI_DEVICE_ID_CISCO_BEVERLY            0x025f	/* Beverly */
+ 
+ /* Sereno */
+ #define PCI_SUBDEVICE_ID_CISCO_VASONA			0x004f	/* vasona mezz */
+ #define PCI_SUBDEVICE_ID_CISCO_COTATI			0x0084	/* cotati mlom */
+ #define PCI_SUBDEVICE_ID_CISCO_LEXINGTON		0x0085	/* lexington pcie */
+ #define PCI_SUBDEVICE_ID_CISCO_ICEHOUSE			0x00cd	/* Icehouse */
+ #define PCI_SUBDEVICE_ID_CISCO_KIRKWOODLAKE		0x00ce	/* KirkwoodLake pcie */
+ #define PCI_SUBDEVICE_ID_CISCO_SUSANVILLE		0x012e	/* Susanville MLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_TORRANCE			0x0139	/* Torrance MLOM */
+ 
+ /* Cruz */
+ #define PCI_SUBDEVICE_ID_CISCO_CALISTOGA		0x012c	/* Calistoga MLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTAINVIEW		0x0137	/* Cruz Mezz */
+ /* Cruz MountTian SIOC */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTTIAN		0x014b
+ #define PCI_SUBDEVICE_ID_CISCO_CLEARLAKE		0x014d	/* ClearLake pcie */
+ /* Cruz MountTian2 SIOC */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTTIAN2		0x0157
+ #define PCI_SUBDEVICE_ID_CISCO_CLAREMONT		0x015d	/* Claremont MLOM */
+ 
+ /* Bodega */
+ /* VIC 1457 PCIe mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BRADBURY         0x0218
+ #define PCI_SUBDEVICE_ID_CISCO_BRENTWOOD        0x0217	/* VIC 1455 PCIe */
+ /* VIC 1487 PCIe mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BURLINGAME       0x021a
+ #define PCI_SUBDEVICE_ID_CISCO_BAYSIDE          0x0219	/* VIC 1485 PCIe */
+ /* VIC 1440 Mezz mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BAKERSFIELD      0x0215
+ #define PCI_SUBDEVICE_ID_CISCO_BOONVILLE        0x0216	/* VIC 1480 Mezz */
+ #define PCI_SUBDEVICE_ID_CISCO_BENICIA          0x024a	/* VIC 1495 */
+ #define PCI_SUBDEVICE_ID_CISCO_BEAUMONT         0x024b	/* VIC 1497 */
+ #define PCI_SUBDEVICE_ID_CISCO_BRISBANE         0x02af	/* VIC 1467 */
+ #define PCI_SUBDEVICE_ID_CISCO_BENTON           0x02b0	/* VIC 1477 */
+ #define PCI_SUBDEVICE_ID_CISCO_TWIN_RIVER       0x02cf	/* VIC 14425 */
+ #define PCI_SUBDEVICE_ID_CISCO_TWIN_PEAK        0x02d0	/* VIC 14825 */
+ 
+ /* Beverly */
+ #define PCI_SUBDEVICE_ID_CISCO_BERN             0x02de	/* VIC 15420 */
+ #define PCI_SUBDEVICE_ID_CISCO_STOCKHOLM        0x02dd	/* VIC 15428 */
+ #define PCI_SUBDEVICE_ID_CISCO_KRAKOW           0x02dc	/* VIC 15411 */
+ #define PCI_SUBDEVICE_ID_CISCO_LUCERNE          0x02db	/* VIC 15231 */
+ #define PCI_SUBDEVICE_ID_CISCO_TURKU            0x02e8	/* VIC 15238 */
+ #define PCI_SUBDEVICE_ID_CISCO_TURKU_PLUS       0x02f3	/* VIC 15237 */
+ #define PCI_SUBDEVICE_ID_CISCO_ZURICH           0x02df	/* VIC 15230 */
+ #define PCI_SUBDEVICE_ID_CISCO_RIGA             0x02e0	/* VIC 15427 */
+ #define PCI_SUBDEVICE_ID_CISCO_GENEVA           0x02e1	/* VIC 15422 */
+ #define PCI_SUBDEVICE_ID_CISCO_HELSINKI         0x02e4	/* VIC 15235 */
+ #define PCI_SUBDEVICE_ID_CISCO_GOTHENBURG       0x02f2	/* VIC 15425 */
+ 
+ struct fnic_pcie_device {
+ 	u32 device;
+ 	u8 *desc;
+ 	u32 subsystem_device;
+ 	u8 *subsys_desc;
+ };
+ 
++>>>>>>> 0620efe789a7 (scsi: fnic: Remove always-true IS_FNIC_FCP_INITIATOR macro)
  /*
 - * fnic private data per SCSI command.
 + * Usage of the scsi_cmnd scratchpad.
   * These fields are locked by the hashed io_req_lock.
   */
 -struct fnic_cmd_priv {
 -	struct fnic_io_req *io_req;
 -	enum fnic_ioreq_state state;
 -	u32 flags;
 -	u16 abts_status;
 -	u16 lr_status;
 -};
 -
 -static inline struct fnic_cmd_priv *fnic_priv(struct scsi_cmnd *cmd)
 -{
 -	return scsi_cmd_priv(cmd);
 -}
 -
 -static inline u64 fnic_flags_and_state(struct scsi_cmnd *cmd)
 -{
 -	struct fnic_cmd_priv *fcmd = fnic_priv(cmd);
 -
 -	return ((u64)fcmd->flags << 32) | fcmd->state;
 -}
 +#define CMD_SP(Cmnd)		((Cmnd)->SCp.ptr)
 +#define CMD_STATE(Cmnd)		((Cmnd)->SCp.phase)
 +#define CMD_ABTS_STATUS(Cmnd)	((Cmnd)->SCp.Message)
 +#define CMD_LR_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
 +#define CMD_TAG(Cmnd)           ((Cmnd)->SCp.sent_command)
 +#define CMD_FLAGS(Cmnd)         ((Cmnd)->SCp.Status)
  
  #define FCPIO_INVALID_CODE 0x100 /* hdr_status value unused by firmware */
  
diff --cc drivers/scsi/fnic/fnic_main.c
index 06fd7b543b33,3a900d540f21..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -854,58 -959,89 +854,84 @@@ static int fnic_probe(struct pci_dev *p
  		}
  	}
  
 -	init_completion(&fnic->reset_completion_wait);
 +	/*
 +	 * Initialization done with PCI system, hardware, firmware.
 +	 * Add host to SCSI
 +	 */
 +	err = scsi_add_host(lp->host, &pdev->dev);
 +	if (err) {
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			     "fnic: scsi_add_host failed...exiting\n");
 +		goto err_out_free_rq_buf;
 +	}
  
 -	/* Start local port initialization */
 -	iport->max_flogi_retries = fnic->config.flogi_retries;
 -	iport->max_plogi_retries = fnic->config.plogi_retries;
 -	iport->plogi_timeout = fnic->config.plogi_timeout;
 -	iport->service_params =
 -		(FNIC_FCP_SP_INITIATOR | FNIC_FCP_SP_RD_XRDY_DIS |
 -		 FNIC_FCP_SP_CONF_CMPL);
 -	if (fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR)
 -		iport->service_params |= FNIC_FCP_SP_RETRY;
 +	/* Start local port initiatialization */
  
 -	iport->boot_time = jiffies;
 -	iport->e_d_tov = fnic->config.ed_tov;
 -	iport->r_a_tov = fnic->config.ra_tov;
 -	iport->link_supported_speeds = FNIC_PORTSPEED_10GBIT;
 -	iport->wwpn = fnic->config.port_wwn;
 -	iport->wwnn = fnic->config.node_wwn;
 +	lp->link_up = 0;
  
 -	iport->max_payload_size = fnic->config.maxdatafieldsize;
 +	lp->max_retry_count = fnic->config.flogi_retries;
 +	lp->max_rport_retry_count = fnic->config.plogi_retries;
 +	lp->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |
 +			      FCP_SPPF_CONF_COMPL);
 +	if (fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR)
 +		lp->service_params |= FCP_SPPF_RETRY;
  
 -	if ((iport->max_payload_size < FNIC_MIN_DATA_FIELD_SIZE) ||
 -		(iport->max_payload_size > FNIC_FC_MAX_PAYLOAD_LEN) ||
 -		((iport->max_payload_size % 4) != 0)) {
 -		iport->max_payload_size = FNIC_FC_MAX_PAYLOAD_LEN;
 -	}
 +	lp->boot_time = jiffies;
 +	lp->e_d_tov = fnic->config.ed_tov;
 +	lp->r_a_tov = fnic->config.ra_tov;
 +	lp->link_supported_speeds = FC_PORTSPEED_10GBIT;
 +	fc_set_wwnn(lp, fnic->config.node_wwn);
 +	fc_set_wwpn(lp, fnic->config.port_wwn);
  
 -	iport->flags |= FNIC_FIRST_LINK_UP;
 +	fcoe_libfc_config(lp, &fnic->ctlr, &fnic_transport_template, 0);
  
 -	timer_setup(&(iport->fabric.retry_timer), fdls_fabric_timer_callback,
 -				0);
 +	if (!fc_exch_mgr_alloc(lp, FC_CLASS_3, FCPIO_HOST_EXCH_RANGE_START,
 +			       FCPIO_HOST_EXCH_RANGE_END, NULL)) {
 +		err = -ENOMEM;
 +		goto err_out_remove_scsi_host;
 +	}
  
 +	fc_lport_init_stats(lp);
  	fnic->stats_reset_time = jiffies;
  
 -	INIT_WORK(&fnic->link_work, fnic_handle_link);
 -	INIT_WORK(&fnic->frame_work, fnic_handle_frame);
 -	INIT_WORK(&fnic->tport_work, fnic_tport_event_handler);
 -	INIT_WORK(&fnic->flush_work, fnic_flush_tx);
 -
 -	INIT_LIST_HEAD(&fnic->frame_queue);
 -	INIT_LIST_HEAD(&fnic->tx_queue);
 -	INIT_LIST_HEAD(&fnic->tport_event_list);
 +	fc_lport_config(lp);
  
 -	INIT_DELAYED_WORK(&iport->oxid_pool.schedule_oxid_free_retry,
 -	fdls_schedule_oxid_free_retry_work);
 -
 -	/* Initialize the oxid reclaim list and work struct */
 -	INIT_LIST_HEAD(&iport->oxid_pool.oxid_reclaim_list);
 -	INIT_DELAYED_WORK(&iport->oxid_pool.oxid_reclaim_work, fdls_reclaim_oxid_handler);
 -
 -	/* Enable all queues */
 -	for (i = 0; i < fnic->raw_wq_count; i++)
 -		vnic_wq_enable(&fnic->wq[i]);
 -	for (i = 0; i < fnic->rq_count; i++) {
 -		if (!ioread32(&fnic->rq[i].ctrl->enable))
 -			vnic_rq_enable(&fnic->rq[i]);
 +	if (fc_set_mfs(lp, fnic->config.maxdatafieldsize +
 +		       sizeof(struct fc_frame_header))) {
 +		err = -EINVAL;
 +		goto err_out_free_exch_mgr;
  	}
 -	for (i = 0; i < fnic->wq_copy_count; i++)
 -		vnic_wq_copy_enable(&fnic->hw_copy_wq[i]);
 +	fc_host_maxframe_size(lp->host) = lp->mfs;
 +	fc_host_dev_loss_tmo(lp->host) = fnic->config.port_down_timeout / 1000;
  
++<<<<<<< HEAD
 +	sprintf(fc_host_symbolic_name(lp->host),
 +		DRV_NAME " v" DRV_VERSION " over %s", fnic->name);
++=======
+ 	vnic_dev_enable(fnic->vdev);
+ 
+ 	err = fnic_request_intr(fnic);
+ 	if (err) {
+ 		dev_err(&fnic->pdev->dev, "Unable to request irq.\n");
+ 		goto err_out_fnic_request_intr;
+ 	}
+ 
+ 	fnic_notify_timer_start(fnic);
+ 
+ 	fnic_fdls_init(fnic, (fnic->config.flags & VFCF_FIP_CAPABLE));
+ 
+ 	if (fnic_scsi_drv_init(fnic))
+ 		goto err_out_scsi_drv_init;
+ 
+ 	err = fnic_stats_debugfs_init(fnic);
+ 	if (err) {
+ 		dev_err(&fnic->pdev->dev, "Failed to initialize debugfs for stats\n");
+ 		goto err_out_free_stats_debugfs;
+ 	}
+ 
+ 	for (i = 0; i < fnic->intr_count; i++)
+ 		vnic_intr_unmask(&fnic->intr[i]);
++>>>>>>> 0620efe789a7 (scsi: fnic: Remove always-true IS_FNIC_FCP_INITIATOR macro)
  
  	spin_lock_irqsave(&fnic_list_lock, flags);
  	list_add_tail(&fnic->list, &fnic_list);
@@@ -954,29 -1070,34 +980,39 @@@ err_out_free_max_pool
  	mempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_MAX]);
  err_out_free_dflt_pool:
  	mempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT]);
 +err_out_free_ioreq_pool:
 +	mempool_destroy(fnic->io_req_pool);
  err_out_free_resources:
  	fnic_free_vnic_resources(fnic);
 -err_out_fnic_alloc_vnic_res:
 +err_out_clear_intr:
  	fnic_clear_intr_mode(fnic);
++<<<<<<< HEAD
 +err_out_dev_close:
++=======
+ err_out_fnic_set_intr_mode:
+ 	scsi_host_put(fnic->host);
+ err_out_fnic_role:
+ err_out_scsi_host_alloc:
+ err_out_fnic_get_config:
+ err_out_dev_mac_addr:
+ err_out_dev_init:
++>>>>>>> 0620efe789a7 (scsi: fnic: Remove always-true IS_FNIC_FCP_INITIATOR macro)
  	vnic_dev_close(fnic->vdev);
 -err_out_dev_open:
 -err_out_dev_cmd_init:
 +err_out_dev_cmd_deinit:
 +err_out_vnic_unregister:
  	vnic_dev_unregister(fnic->vdev);
 -err_out_dev_register:
 +err_out_iounmap:
  	fnic_iounmap(fnic);
 -err_out_fnic_map_bar:
 -err_out_map_bar:
 -err_out_set_dma_mask:
 +err_out_release_regions:
  	pci_release_regions(pdev);
 -err_out_pci_request_regions:
 +err_out_disable_device:
  	pci_disable_device(pdev);
 -err_out_pci_enable_device:
 +err_out_free_hba:
 +	fnic_stats_debugfs_remove(fnic);
  	ida_free(&fnic_ida, fnic->fnic_num);
  err_out_ida_alloc:
 -	kfree(fnic);
 -err_out_fnic_alloc:
 +	scsi_host_put(lp->host);
 +err_out:
  	return err;
  }
  
@@@ -1004,29 -1123,25 +1040,37 @@@ static void fnic_remove(struct pci_dev 
  	 * be no event queued for this fnic device in the workqueue
  	 */
  	flush_workqueue(fnic_event_queue);
++<<<<<<< HEAD
 +	skb_queue_purge(&fnic->frame_queue);
 +	skb_queue_purge(&fnic->tx_queue);
++=======
+ 
+ 	fnic_scsi_unload(fnic);
+ 
+ 	if (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)
+ 		del_timer_sync(&fnic->notify_timer);
++>>>>>>> 0620efe789a7 (scsi: fnic: Remove always-true IS_FNIC_FCP_INITIATOR macro)
  
  	if (fnic->config.flags & VFCF_FIP_CAPABLE) {
 -		del_timer_sync(&fnic->retry_fip_timer);
 -		del_timer_sync(&fnic->fcs_ka_timer);
 -		del_timer_sync(&fnic->enode_ka_timer);
 -		del_timer_sync(&fnic->vn_ka_timer);
 -
 -		fnic_free_txq(&fnic->fip_frame_queue);
 +		del_timer_sync(&fnic->fip_timer);
 +		skb_queue_purge(&fnic->fip_frame_queue);
  		fnic_fcoe_reset_vlans(fnic);
 +		fnic_fcoe_evlist_free(fnic);
  	}
  
 -	if ((fnic_fdmi_support == 1) && (fnic->iport.fabric.fdmi_pending > 0))
 -		del_timer_sync(&fnic->iport.fabric.fdmi_timer);
 +	/*
 +	 * Log off the fabric. This stops all remote ports, dns port,
 +	 * logs off the fabric. This flushes all rport, disc, lport work
 +	 * before returning
 +	 */
 +	fc_fabric_logoff(fnic->lport);
 +
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	fnic->in_remove = 1;
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  
 +	fcoe_ctlr_destroy(&fnic->ctlr);
 +	fc_lport_destroy(lp);
  	fnic_stats_debugfs_remove(fnic);
  
  	/*
@@@ -1055,8 -1167,11 +1099,14 @@@
  	fnic_iounmap(fnic);
  	pci_release_regions(pdev);
  	pci_disable_device(pdev);
 -	pci_set_drvdata(pdev, NULL);
  	ida_free(&fnic_ida, fnic->fnic_num);
++<<<<<<< HEAD
 +	scsi_host_put(lp->host);
++=======
+ 	fnic_scsi_unload_cleanup(fnic);
+ 	scsi_host_put(fnic->host);
+ 	kfree(fnic);
++>>>>>>> 0620efe789a7 (scsi: fnic: Remove always-true IS_FNIC_FCP_INITIATOR macro)
  }
  
  static struct pci_driver fnic_driver = {
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fnic.h
* Unmerged path drivers/scsi/fnic/fnic_main.c
