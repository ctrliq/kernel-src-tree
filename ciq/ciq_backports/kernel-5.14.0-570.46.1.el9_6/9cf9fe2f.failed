scsi: fnic: Add functionality in fnic to support FDLS

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 9cf9fe2f3ec5dad8b459267a9e977c0b7811b3f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/9cf9fe2f.failed

Add interfaces in fnic to use FDLS services.

Modify link up and link down functionality to use FDLS.

Replace existing interfaces to handle new functionality provided by FDLS.

Modify data types of some data members to handle new functionality.

Add processing of tports and handling of tports.

	Reported-by: kernel test robot <lkp@intel.com>
Closes: https://lore.kernel.org/oe-kbuild-all/202409292037.ZYWZwIK6-lkp@intel.com/
	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
Co-developed-by: Gian Carlo Boffa <gcboffa@cisco.com>
	Signed-off-by: Gian Carlo Boffa <gcboffa@cisco.com>
Co-developed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Signed-off-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
Co-developed-by: Arun Easi <aeasi@cisco.com>
	Signed-off-by: Arun Easi <aeasi@cisco.com>
Co-developed-by: Karan Tilak Kumar <kartilak@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20241212020312.4786-10-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9cf9fe2f3ec5dad8b459267a9e977c0b7811b3f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fdls_disc.c
#	drivers/scsi/fnic/fip.c
#	drivers/scsi/fnic/fnic.h
#	drivers/scsi/fnic/fnic_fcs.c
#	drivers/scsi/fnic/fnic_main.c
#	drivers/scsi/fnic/fnic_scsi.c
diff --cc drivers/scsi/fnic/fnic.h
index 73fb8245c7b7,0f92d57e0aac..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -88,16 -82,101 +88,91 @@@
  #define FNIC_DEV_RST_TERM_DONE          BIT(20)
  #define FNIC_DEV_RST_ABTS_PENDING       BIT(21)
  
++<<<<<<< HEAD
++=======
+ #define IS_FNIC_FCP_INITIATOR(fnic) (fnic->role == FNIC_ROLE_FCP_INITIATOR)
+ 
+ #define FNIC_FW_RESET_TIMEOUT        60000	/* mSec   */
+ /* Retry supported by rport (returned by PRLI service parameters) */
+ #define FNIC_FC_RP_FLAGS_RETRY            0x1
+ 
+ /* Cisco vendor id */
+ #define PCI_VENDOR_ID_CISCO						0x1137
+ #define PCI_DEVICE_ID_CISCO_VIC_FC				0x0045	/* fc vnic */
+ 
+ /* sereno pcie switch */
+ #define PCI_DEVICE_ID_CISCO_SERENO             0x004e
+ #define PCI_DEVICE_ID_CISCO_CRUZ               0x007a	/* Cruz */
+ #define PCI_DEVICE_ID_CISCO_BODEGA             0x0131	/* Bodega */
+ #define PCI_DEVICE_ID_CISCO_BEVERLY            0x025f	/* Beverly */
+ 
+ /* Sereno */
+ #define PCI_SUBDEVICE_ID_CISCO_VASONA			0x004f	/* vasona mezz */
+ #define PCI_SUBDEVICE_ID_CISCO_COTATI			0x0084	/* cotati mlom */
+ #define PCI_SUBDEVICE_ID_CISCO_LEXINGTON		0x0085	/* lexington pcie */
+ #define PCI_SUBDEVICE_ID_CISCO_ICEHOUSE			0x00cd	/* Icehouse */
+ #define PCI_SUBDEVICE_ID_CISCO_KIRKWOODLAKE		0x00ce	/* KirkwoodLake pcie */
+ #define PCI_SUBDEVICE_ID_CISCO_SUSANVILLE		0x012e	/* Susanville MLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_TORRANCE			0x0139	/* Torrance MLOM */
+ 
+ /* Cruz */
+ #define PCI_SUBDEVICE_ID_CISCO_CALISTOGA		0x012c	/* Calistoga MLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTAINVIEW		0x0137	/* Cruz Mezz */
+ /* Cruz MountTian SIOC */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTTIAN		0x014b
+ #define PCI_SUBDEVICE_ID_CISCO_CLEARLAKE		0x014d	/* ClearLake pcie */
+ /* Cruz MountTian2 SIOC */
+ #define PCI_SUBDEVICE_ID_CISCO_MOUNTTIAN2		0x0157
+ #define PCI_SUBDEVICE_ID_CISCO_CLAREMONT		0x015d	/* Claremont MLOM */
+ 
+ /* Bodega */
+ /* VIC 1457 PCIe mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BRADBURY         0x0218
+ #define PCI_SUBDEVICE_ID_CISCO_BRENTWOOD        0x0217	/* VIC 1455 PCIe */
+ /* VIC 1487 PCIe mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BURLINGAME       0x021a
+ #define PCI_SUBDEVICE_ID_CISCO_BAYSIDE          0x0219	/* VIC 1485 PCIe */
+ /* VIC 1440 Mezz mLOM */
+ #define PCI_SUBDEVICE_ID_CISCO_BAKERSFIELD      0x0215
+ #define PCI_SUBDEVICE_ID_CISCO_BOONVILLE        0x0216	/* VIC 1480 Mezz */
+ #define PCI_SUBDEVICE_ID_CISCO_BENICIA          0x024a	/* VIC 1495 */
+ #define PCI_SUBDEVICE_ID_CISCO_BEAUMONT         0x024b	/* VIC 1497 */
+ #define PCI_SUBDEVICE_ID_CISCO_BRISBANE         0x02af	/* VIC 1467 */
+ #define PCI_SUBDEVICE_ID_CISCO_BENTON           0x02b0	/* VIC 1477 */
+ #define PCI_SUBDEVICE_ID_CISCO_TWIN_RIVER       0x02cf	/* VIC 14425 */
+ #define PCI_SUBDEVICE_ID_CISCO_TWIN_PEAK        0x02d0	/* VIC 14825 */
+ 
+ /* Beverly */
+ #define PCI_SUBDEVICE_ID_CISCO_BERN             0x02de	/* VIC 15420 */
+ #define PCI_SUBDEVICE_ID_CISCO_STOCKHOLM        0x02dd	/* VIC 15428 */
+ #define PCI_SUBDEVICE_ID_CISCO_KRAKOW           0x02dc	/* VIC 15411 */
+ #define PCI_SUBDEVICE_ID_CISCO_LUCERNE          0x02db	/* VIC 15231 */
+ #define PCI_SUBDEVICE_ID_CISCO_TURKU            0x02e8	/* VIC 15238 */
+ #define PCI_SUBDEVICE_ID_CISCO_TURKU_PLUS       0x02f3	/* VIC 15237 */
+ #define PCI_SUBDEVICE_ID_CISCO_ZURICH           0x02df	/* VIC 15230 */
+ #define PCI_SUBDEVICE_ID_CISCO_RIGA             0x02e0	/* VIC 15427 */
+ #define PCI_SUBDEVICE_ID_CISCO_GENEVA           0x02e1	/* VIC 15422 */
+ #define PCI_SUBDEVICE_ID_CISCO_HELSINKI         0x02e4	/* VIC 15235 */
+ #define PCI_SUBDEVICE_ID_CISCO_GOTHENBURG       0x02f2	/* VIC 15425 */
+ 
+ struct fnic_pcie_device {
+ 	u32 device;
+ 	u8 *desc;
+ 	u32 subsystem_device;
+ 	u8 *subsys_desc;
+ };
+ 
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  /*
 - * fnic private data per SCSI command.
 + * Usage of the scsi_cmnd scratchpad.
   * These fields are locked by the hashed io_req_lock.
   */
 -struct fnic_cmd_priv {
 -	struct fnic_io_req *io_req;
 -	enum fnic_ioreq_state state;
 -	u32 flags;
 -	u16 abts_status;
 -	u16 lr_status;
 -};
 -
 -static inline struct fnic_cmd_priv *fnic_priv(struct scsi_cmnd *cmd)
 -{
 -	return scsi_cmd_priv(cmd);
 -}
 -
 -static inline u64 fnic_flags_and_state(struct scsi_cmnd *cmd)
 -{
 -	struct fnic_cmd_priv *fcmd = fnic_priv(cmd);
 -
 -	return ((u64)fcmd->flags << 32) | fcmd->state;
 -}
 +#define CMD_SP(Cmnd)		((Cmnd)->SCp.ptr)
 +#define CMD_STATE(Cmnd)		((Cmnd)->SCp.phase)
 +#define CMD_ABTS_STATUS(Cmnd)	((Cmnd)->SCp.Message)
 +#define CMD_LR_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
 +#define CMD_TAG(Cmnd)           ((Cmnd)->SCp.sent_command)
 +#define CMD_FLAGS(Cmnd)         ((Cmnd)->SCp.Status)
  
  #define FCPIO_INVALID_CODE 0x100 /* hdr_status value unused by firmware */
  
@@@ -127,8 -206,16 +202,18 @@@
  #define fnic_clear_state_flags(fnicp, st_flags)  \
  	__fnic_set_state_flags(fnicp, st_flags, 1)
  
++<<<<<<< HEAD
++=======
+ enum reset_states {
+ 	NOT_IN_PROGRESS = 0,
+ 	IN_PROGRESS,
+ 	RESET_ERROR
+ };
+ 
+ extern unsigned int fnic_fdmi_support;
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  extern unsigned int fnic_log_level;
  extern unsigned int io_completions;
 -extern struct workqueue_struct *fnic_event_queue;
  
  #define FNIC_MAIN_LOGGING 0x01
  #define FNIC_FCS_LOGGING 0x02
@@@ -249,6 -364,10 +334,13 @@@ struct fnic 
  	unsigned int wq_count;
  	unsigned int cq_count;
  
++<<<<<<< HEAD
++=======
+ 	struct completion reset_completion_wait;
+ 	struct mutex sgreset_mutex;
+ 	spinlock_t sgreset_lock; /* lock for sgreset */
+ 	struct scsi_cmnd *sgreset_sc;
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  	struct dentry *fnic_stats_debugfs_host;
  	struct dentry *fnic_stats_debugfs_file;
  	struct dentry *fnic_reset_debugfs_file;
@@@ -298,8 -420,15 +393,20 @@@
  	struct work_struct link_work;
  	struct work_struct frame_work;
  	struct work_struct flush_work;
++<<<<<<< HEAD
 +	struct sk_buff_head frame_queue;
 +	struct sk_buff_head tx_queue;
++=======
+ 	struct list_head frame_queue;
+ 	struct list_head tx_queue;
+ 	mempool_t *frame_pool;
+ 	mempool_t *frame_elem_pool;
+ 	struct work_struct tport_work;
+ 	struct list_head tport_event_list;
+ 
+ 	char subsys_desc[14];
+ 	int subsys_desc_len;
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  
  	/*** FIP related data members  -- start ***/
  	void (*set_vlan)(struct fnic *, u16 vlan);
@@@ -351,8 -482,12 +458,9 @@@ int fnic_request_intr(struct fnic *fnic
  int fnic_send(struct fc_lport *, struct fc_frame *);
  void fnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf);
  void fnic_handle_frame(struct work_struct *work);
+ void fnic_tport_event_handler(struct work_struct *work);
  void fnic_handle_link(struct work_struct *work);
  void fnic_handle_event(struct work_struct *work);
 -void fdls_reclaim_oxid_handler(struct work_struct *work);
 -void fdls_schedule_oxid_free(struct fnic_iport_s *iport, uint16_t *active_oxid);
 -void fdls_schedule_oxid_free_retry_work(struct work_struct *work);
  int fnic_rq_cmpl_handler(struct fnic *fnic, int);
  int fnic_alloc_rq_frame(struct vnic_rq *rq);
  void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf);
@@@ -398,4 -530,79 +507,82 @@@ fnic_chk_state_flags_locked(struct fni
  }
  void __fnic_set_state_flags(struct fnic *, unsigned long, unsigned long);
  void fnic_dump_fchost_stats(struct Scsi_Host *, struct fc_host_statistics *);
++<<<<<<< HEAD
++=======
+ void fnic_free_txq(struct list_head *head);
+ int fnic_get_desc_by_devid(struct pci_dev *pdev, char **desc,
+ 						   char **subsys_desc);
+ void fnic_fdls_link_status_change(struct fnic *fnic, int linkup);
+ void fnic_delete_fcp_tports(struct fnic *fnic);
+ void fnic_flush_tport_event_list(struct fnic *fnic);
+ 
+ struct fnic_scsi_iter_data {
+ 	struct fnic *fnic;
+ 	void *data1;
+ 	void *data2;
+ 	bool (*fn)(struct fnic *fnic, struct scsi_cmnd *sc,
+ 			void *data1, void *data2);
+ };
+ 
+ static inline bool
+ fnic_io_iter_handler(struct scsi_cmnd *sc, void *iter_data)
+ {
+ 	struct fnic_scsi_iter_data *iter = iter_data;
+ 
+ 	return iter->fn(iter->fnic, sc, iter->data1, iter->data2);
+ }
+ 
+ static inline void
+ fnic_scsi_io_iter(struct fnic *fnic,
+ 		bool (*fn)(struct fnic *fnic, struct scsi_cmnd *sc,
+ 				void *data1, void *data2),
+ 		void *data1, void *data2)
+ {
+ 	struct fnic_scsi_iter_data iter_data = {
+ 		.fn = fn,
+ 		.fnic = fnic,
+ 		.data1 = data1,
+ 		.data2 = data2,
+ 	};
+ 	scsi_host_busy_iter(fnic->lport->host, fnic_io_iter_handler, &iter_data);
+ }
+ 
+ #ifdef FNIC_DEBUG
+ static inline void
+ fnic_debug_dump(struct fnic *fnic, uint8_t *u8arr, int len)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < len; i = i+8) {
+ 		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		    "%d: %02x %02x %02x %02x %02x %02x %02x %02x", i / 8,
+ 		    u8arr[i + 0], u8arr[i + 1], u8arr[i + 2], u8arr[i + 3],
+ 		    u8arr[i + 4], u8arr[i + 5], u8arr[i + 6], u8arr[i + 7]);
+ 	}
+ }
+ 
+ static inline void
+ fnic_debug_dump_fc_frame(struct fnic *fnic, struct fc_frame_header *fchdr,
+ 				int len, char *pfx)
+ {
+ 	uint32_t s_id, d_id;
+ 
+ 	s_id = ntoh24(fchdr->fh_s_id);
+ 	d_id = ntoh24(fchdr->fh_d_id);
+ 	FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		"%s packet contents: sid/did/type/oxid = 0x%x/0x%x/0x%x/0x%x (len = %d)\n",
+ 		pfx, s_id, d_id, fchdr->fh_type,
+ 		FNIC_STD_GET_OX_ID(fchdr), len);
+ 
+ 	fnic_debug_dump(fnic, (uint8_t *)fchdr, len);
+ 
+ }
+ #else /* FNIC_DEBUG */
+ static inline void
+ fnic_debug_dump(struct fnic *fnic, uint8_t *u8arr, int len) {}
+ static inline void
+ fnic_debug_dump_fc_frame(struct fnic *fnic, struct fc_frame_header *fchdr,
+ 				uint32_t len, char *pfx) {}
+ #endif /* FNIC_DEBUG */
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  #endif /* _FNIC_H_ */
diff --cc drivers/scsi/fnic/fnic_fcs.c
index 8c3b350695e3,b2669f2ddb53..000000000000
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@@ -26,25 -14,136 +26,147 @@@
  #include <linux/workqueue.h>
  #include <scsi/fc/fc_fip.h>
  #include <scsi/fc/fc_els.h>
 +#include <scsi/fc/fc_fcoe.h>
  #include <scsi/fc_frame.h>
  #include <scsi/libfc.h>
 -#include <scsi/scsi_transport_fc.h>
  #include "fnic_io.h"
  #include "fnic.h"
 -#include "fnic_fdls.h"
 -#include "fdls_fc.h"
 +#include "fnic_fip.h"
  #include "cq_enet_desc.h"
  #include "cq_exch_desc.h"
 -#include "fip.h"
  
++<<<<<<< HEAD
 +static u8 fcoe_all_fcfs[ETH_ALEN] = FIP_ALL_FCF_MACS;
 +struct workqueue_struct *fnic_fip_queue;
 +struct workqueue_struct *fnic_event_queue;
 +
 +static void fnic_set_eth_mode(struct fnic *);
 +static void fnic_fcoe_send_vlan_req(struct fnic *fnic);
 +static void fnic_fcoe_start_fcf_disc(struct fnic *fnic);
 +static void fnic_fcoe_process_vlan_resp(struct fnic *fnic, struct sk_buff *);
 +static int fnic_fcoe_vlan_check(struct fnic *fnic, u16 flag);
 +static int fnic_fcoe_handle_fip_frame(struct fnic *fnic, struct sk_buff *skb);
++=======
+ #define MAX_RESET_WAIT_COUNT    64
+ 
+ extern struct workqueue_struct *fnic_fip_queue;
+ struct workqueue_struct *fnic_event_queue;
+ 
+ static uint8_t FCOE_ALL_FCF_MAC[6] = FC_FCOE_FLOGI_MAC;
+ 
+ /*
+  * Internal Functions
+  * This function will initialize the src_mac address to be
+  * used in outgoing frames
+  */
+ static inline void fnic_fdls_set_fcoe_srcmac(struct fnic *fnic,
+ 							 uint8_t *src_mac)
+ {
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Setting src mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 src_mac[0], src_mac[1], src_mac[2], src_mac[3],
+ 				 src_mac[4], src_mac[5]);
+ 
+ 	memcpy(fnic->iport.fpma, src_mac, 6);
+ }
+ 
+ /*
+  * This function will initialize the dst_mac address to be
+  * used in outgoing frames
+  */
+ static inline  void fnic_fdls_set_fcoe_dstmac(struct fnic *fnic,
+ 							 uint8_t *dst_mac)
+ {
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Setting dst mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 dst_mac[0], dst_mac[1], dst_mac[2], dst_mac[3],
+ 				 dst_mac[4], dst_mac[5]);
+ 
+ 	memcpy(fnic->iport.fcfmac, dst_mac, 6);
+ }
+ 
+ void fnic_fdls_link_status_change(struct fnic *fnic, int linkup)
+ {
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "link up: %d, usefip: %d", linkup, iport->usefip);
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, fnic->lock_flags);
+ 
+ 	if (linkup) {
+ 		if (iport->usefip) {
+ 			iport->state = FNIC_IPORT_STATE_FIP;
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "link up: %d, usefip: %d", linkup, iport->usefip);
+ 			fnic_fcoe_send_vlan_req(fnic);
+ 		} else {
+ 			iport->state = FNIC_IPORT_STATE_FABRIC_DISC;
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "iport->state: %d", iport->state);
+ 			fnic_fdls_disc_start(iport);
+ 		}
+ 	} else {
+ 		iport->state = FNIC_IPORT_STATE_LINK_WAIT;
+ 		if (!is_zero_ether_addr(iport->fpma))
+ 			vnic_dev_del_addr(fnic->vdev, iport->fpma);
+ 		fnic_common_fip_cleanup(fnic);
+ 		fnic_fdls_link_down(iport);
+ 
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ }
+ 
+ 
+ /*
+  * FPMA can be either taken from ethhdr(dst_mac) or flogi resp
+  * or derive from FC_MAP and FCID combination. While it should be
+  * same, revisit this if there is any possibility of not-correct.
+  */
+ void fnic_fdls_learn_fcoe_macs(struct fnic_iport_s *iport, void *rx_frame,
+ 							   uint8_t *fcid)
+ {
+ 	struct fnic *fnic = iport->fnic;
+ 	struct ethhdr *ethhdr = (struct ethhdr *) rx_frame;
+ 	uint8_t fcmac[6] = { 0x0E, 0xFC, 0x00, 0x00, 0x00, 0x00 };
+ 
+ 	memcpy(&fcmac[3], fcid, 3);
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "learn fcoe: dst_mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 ethhdr->h_dest[0], ethhdr->h_dest[1],
+ 				 ethhdr->h_dest[2], ethhdr->h_dest[3],
+ 				 ethhdr->h_dest[4], ethhdr->h_dest[5]);
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "learn fcoe: fc_mac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 fcmac[0], fcmac[1], fcmac[2], fcmac[3], fcmac[4],
+ 				 fcmac[5]);
+ 
+ 	fnic_fdls_set_fcoe_srcmac(fnic, fcmac);
+ 	fnic_fdls_set_fcoe_dstmac(fnic, ethhdr->h_source);
+ }
+ 
+ void fnic_fdls_init(struct fnic *fnic, int usefip)
+ {
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 
+ 	/* Initialize iPort structure */
+ 	iport->state = FNIC_IPORT_STATE_INIT;
+ 	iport->fnic = fnic;
+ 	iport->usefip = usefip;
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "iportsrcmac: %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 iport->hwmac[0], iport->hwmac[1], iport->hwmac[2],
+ 				 iport->hwmac[3], iport->hwmac[4], iport->hwmac[5]);
+ 
+ 	INIT_LIST_HEAD(&iport->tport_list);
+ 	INIT_LIST_HEAD(&iport->tport_list_pending_del);
+ 
+ 	fnic_fdls_disc_init(iport);
+ }
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  
  void fnic_handle_link(struct work_struct *work)
  {
@@@ -68,124 -183,86 +206,172 @@@
  	fnic->link_status = vnic_dev_link_status(fnic->vdev);
  	fnic->link_down_cnt = vnic_dev_link_down_cnt(fnic->vdev);
  
++<<<<<<< HEAD
 +	new_port_speed = vnic_dev_port_speed(fnic->vdev);
 +	atomic64_set(&fnic->fnic_stats.misc_stats.current_port_speed,
 +			new_port_speed);
 +	if (old_port_speed != new_port_speed)
 +		FNIC_MAIN_DBG(KERN_INFO, fnic->lport->host,
 +				"Current vnic speed set to :  %llu\n",
 +				new_port_speed);
- 
- 	switch (vnic_dev_port_speed(fnic->vdev)) {
- 	case DCEM_PORTSPEED_10G:
- 		fc_host_speed(fnic->lport->host)   = FC_PORTSPEED_10GBIT;
- 		fnic->lport->link_supported_speeds = FC_PORTSPEED_10GBIT;
- 		break;
- 	case DCEM_PORTSPEED_20G:
- 		fc_host_speed(fnic->lport->host)   = FC_PORTSPEED_20GBIT;
- 		fnic->lport->link_supported_speeds = FC_PORTSPEED_20GBIT;
- 		break;
- 	case DCEM_PORTSPEED_25G:
- 		fc_host_speed(fnic->lport->host)   = FC_PORTSPEED_25GBIT;
- 		fnic->lport->link_supported_speeds = FC_PORTSPEED_25GBIT;
- 		break;
- 	case DCEM_PORTSPEED_40G:
- 	case DCEM_PORTSPEED_4x10G:
- 		fc_host_speed(fnic->lport->host)   = FC_PORTSPEED_40GBIT;
- 		fnic->lport->link_supported_speeds = FC_PORTSPEED_40GBIT;
- 		break;
- 	case DCEM_PORTSPEED_100G:
- 		fc_host_speed(fnic->lport->host)   = FC_PORTSPEED_100GBIT;
- 		fnic->lport->link_supported_speeds = FC_PORTSPEED_100GBIT;
- 		break;
- 	default:
- 		fc_host_speed(fnic->lport->host)   = FC_PORTSPEED_UNKNOWN;
- 		fnic->lport->link_supported_speeds = FC_PORTSPEED_UNKNOWN;
- 		break;
++=======
+ 	while (fnic->reset_in_progress == IN_PROGRESS) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			 "fnic reset in progress. Link event needs to wait\n");
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
+ 
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "waiting for reset completion\n");
+ 		wait_for_completion_timeout(&fnic->reset_completion_wait,
+ 									msecs_to_jiffies(5000));
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "woken up from reset completion wait\n");
+ 		spin_lock_irqsave(&fnic->fnic_lock, fnic->lock_flags);
+ 
+ 		max_count++;
+ 		if (max_count >= MAX_RESET_WAIT_COUNT) {
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Rstth waited for too long. Skipping handle link event\n");
+ 			spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 			return;
+ 		}
+ 	}
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Marking fnic reset in progress\n");
+ 	fnic->reset_in_progress = IN_PROGRESS;
+ 
+ 	if ((vnic_dev_get_intr_mode(fnic->vdev) != VNIC_DEV_INTR_MODE_MSI) ||
+ 		(fnic->link_status != old_link_status)) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "old link status: %d link status: %d\n",
+ 					 old_link_status, (int) fnic->link_status);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "old down count %d down count: %d\n",
+ 					 old_link_down_cnt, (int) fnic->link_down_cnt);
  	}
  
  	if (old_link_status == fnic->link_status) {
  		if (!fnic->link_status) {
  			/* DOWN -> DOWN */
++<<<<<<< HEAD
 +			spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +			fnic_fc_trace_set_data(fnic->lport->host->host_no,
 +				FNIC_FC_LE, "Link Status: DOWN->DOWN",
 +				strlen("Link Status: DOWN->DOWN"));
 +		} else {
 +			if (old_link_down_cnt != fnic->link_down_cnt) {
 +				/* UP -> DOWN -> UP */
 +				fnic->lport->host_stats.link_failure_count++;
 +				spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +				fnic_fc_trace_set_data(
 +					fnic->lport->host->host_no,
 +					FNIC_FC_LE,
 +					"Link Status:UP_DOWN_UP",
 +					strlen("Link_Status:UP_DOWN_UP")
 +					);
 +				FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 +					     "link down\n");
 +				fcoe_ctlr_link_down(&fnic->ctlr);
 +				if (fnic->config.flags & VFCF_FIP_CAPABLE) {
 +					/* start FCoE VLAN discovery */
 +					fnic_fc_trace_set_data(
 +						fnic->lport->host->host_no,
 +						FNIC_FC_LE,
 +						"Link Status: UP_DOWN_UP_VLAN",
 +						strlen(
 +						"Link Status: UP_DOWN_UP_VLAN")
 +						);
 +					fnic_fcoe_send_vlan_req(fnic);
 +					return;
 +				}
 +				FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 +					     "link up\n");
 +				fcoe_ctlr_link_up(&fnic->ctlr);
 +			} else {
 +				/* UP -> UP */
 +				spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +				fnic_fc_trace_set_data(
 +					fnic->lport->host->host_no, FNIC_FC_LE,
 +					"Link Status: UP_UP",
 +					strlen("Link Status: UP_UP"));
++=======
+ 			spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "down->down\n");
+ 		} else {
+ 			if (old_link_down_cnt != fnic->link_down_cnt) {
+ 				/* UP -> DOWN -> UP */
+ 				spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 				FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 							 "up->down. Link down\n");
+ 				fnic_fdls_link_status_change(fnic, 0);
+ 
+ 				FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 							 "down->up. Link up\n");
+ 				fnic_fdls_link_status_change(fnic, 1);
+ 			} else {
+ 				/* UP -> UP */
+ 				spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 				FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 							 "up->up\n");
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  			}
  		}
  	} else if (fnic->link_status) {
  		/* DOWN -> UP */
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		if (fnic->config.flags & VFCF_FIP_CAPABLE) {
 +			/* start FCoE VLAN discovery */
 +			fnic_fc_trace_set_data(fnic->lport->host->host_no,
 +					       FNIC_FC_LE, "Link Status: DOWN_UP_VLAN",
 +					       strlen("Link Status: DOWN_UP_VLAN"));
 +			fnic_fcoe_send_vlan_req(fnic);
 +
 +			return;
 +		}
 +
 +		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, "link up\n");
 +		fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_LE,
 +				       "Link Status: DOWN_UP", strlen("Link Status: DOWN_UP"));
 +		fcoe_ctlr_link_up(&fnic->ctlr);
 +	} else {
 +		/* UP -> DOWN */
 +		fnic->lport->host_stats.link_failure_count++;
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, "link down\n");
 +		fnic_fc_trace_set_data(
 +			fnic->lport->host->host_no, FNIC_FC_LE,
 +			"Link Status: UP_DOWN",
 +			strlen("Link Status: UP_DOWN"));
 +		if (fnic->config.flags & VFCF_FIP_CAPABLE) {
 +			FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 +				"deleting fip-timer during link-down\n");
 +			del_timer_sync(&fnic->fip_timer);
 +		}
 +		fcoe_ctlr_link_down(&fnic->ctlr);
++=======
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "down->up. Link up\n");
+ 		fnic_fdls_link_status_change(fnic, 1);
+ 	} else {
+ 		/* UP -> DOWN */
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "up->down. Link down\n");
+ 		fnic_fdls_link_status_change(fnic, 0);
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  	}
  
+ 	spin_lock_irqsave(&fnic->fnic_lock, fnic->lock_flags);
+ 	fnic->reset_in_progress = NOT_IN_PROGRESS;
+ 	complete(&fnic->reset_completion_wait);
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Marking fnic reset completion\n");
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
  }
  
  /*
@@@ -214,56 -289,47 +398,67 @@@ void fnic_handle_frame(struct work_stru
  		 * The queue will be serviced when we get to a stable state.
  		 */
  		if (fnic->state != FNIC_IN_FC_MODE &&
- 		    fnic->state != FNIC_IN_ETH_MODE) {
- 			skb_queue_head(&fnic->frame_queue, skb);
- 			spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 			fnic->state != FNIC_IN_ETH_MODE) {
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Cannot process frame in transitional state\n");
+ 			spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
  			return;
  		}
- 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  
- 		fc_exch_recv(lp, fp);
+ 		list_del(&cur_frame->links);
+ 
+ 		/* Frames from FCP_RQ will have ethhdrs stripped off */
+ 		fchdr_offset = (cur_frame->rx_ethhdr_stripped) ?
+ 			0 : FNIC_ETH_FCOE_HDRS_OFFSET;
+ 
+ 		fnic_fdls_recv_frame(&fnic->iport, cur_frame->fp,
+ 							 cur_frame->frame_len, fchdr_offset);
+ 
+ 		kfree(cur_frame->fp);
+ 		mempool_free(cur_frame, fnic->frame_elem_pool);
  	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
  }
  
 -void fnic_handle_fip_frame(struct work_struct *work)
 +void fnic_fcoe_evlist_free(struct fnic *fnic)
  {
 -	struct fnic_frame_list *cur_frame, *next;
 -	struct fnic *fnic = container_of(work, struct fnic, fip_frame_work);
 +	struct fnic_event *fevt = NULL;
 +	struct fnic_event *next = NULL;
 +	unsigned long flags;
  
 -	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
 -				 "Processing FIP frame\n");
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	if (list_empty(&fnic->evlist)) {
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		return;
 +	}
  
 -	spin_lock_irqsave(&fnic->fnic_lock, fnic->lock_flags);
 -	list_for_each_entry_safe(cur_frame, next, &fnic->fip_frame_queue,
 -							 links) {
 +	list_for_each_entry_safe(fevt, next, &fnic->evlist, list) {
 +		list_del(&fevt->list);
 +		kfree(fevt);
 +	}
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +}
 +
 +void fnic_handle_event(struct work_struct *work)
 +{
 +	struct fnic *fnic = container_of(work, struct fnic, event_work);
 +	struct fnic_event *fevt = NULL;
 +	struct fnic_event *next = NULL;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	if (list_empty(&fnic->evlist)) {
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		return;
 +	}
 +
 +	list_for_each_entry_safe(fevt, next, &fnic->evlist, list) {
  		if (fnic->stop_rx_link_events) {
 -			list_del(&cur_frame->links);
 -			spin_unlock_irqrestore(&fnic->fnic_lock, fnic->lock_flags);
 -			kfree(cur_frame->fp);
 -			kfree(cur_frame);
 +			list_del(&fevt->list);
 +			kfree(fevt);
 +			spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  			return;
  		}
 -
  		/*
  		 * If we're in a transitional state, just re-queue and return.
  		 * The queue will be serviced when we get to a stable state.
@@@ -910,21 -499,34 +1105,38 @@@ static void fnic_rq_cmpl_frame_recv(str
  	spin_lock_irqsave(&fnic->fnic_lock, flags);
  	if (fnic->stop_rx_link_events) {
  		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 -		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
 -					 "fnic->stop_rx_link_events: %d\n",
 -					 fnic->stop_rx_link_events);
  		goto drop;
  	}
 -
 +	fr_dev(fp) = fnic->lport;
  	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++<<<<<<< HEAD
 +	if ((fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_RECV,
 +					(char *)skb->data, skb->len)) != 0) {
 +		printk(KERN_ERR "fnic ctlr frame trace error!!!");
++=======
+ 
+ 	frame_elem = mempool_alloc(fnic->frame_elem_pool,
+ 					GFP_ATOMIC | __GFP_ZERO);
+ 	if (!frame_elem) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Failed to allocate memory for frame elem");
+ 		goto drop;
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  	}
 -	frame_elem->fp = fp;
 -	frame_elem->rx_ethhdr_stripped = ethhdr_stripped;
 -	frame_elem->frame_len = bytes_written;
  
++<<<<<<< HEAD
 +	skb_queue_tail(&fnic->frame_queue, skb);
++=======
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	list_add_tail(&frame_elem->links, &fnic->frame_queue);
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  	queue_work(fnic_event_queue, &fnic->frame_work);
 -	return;
  
 +	return;
  drop:
 -	kfree(fp);
 +	dev_kfree_skb_irq(skb);
  }
  
  static int fnic_rq_cmpl_handler_cont(struct vnic_dev *vdev,
@@@ -971,35 -573,32 +1183,40 @@@ int fnic_rq_cmpl_handler(struct fnic *f
  int fnic_alloc_rq_frame(struct vnic_rq *rq)
  {
  	struct fnic *fnic = vnic_dev_priv(rq->vdev);
- 	struct sk_buff *skb;
+ 	void *buf;
  	u16 len;
  	dma_addr_t pa;
- 	int r;
+ 	int ret;
  
++<<<<<<< HEAD
 +	len = FC_FRAME_HEADROOM + FC_MAX_FRAME + FC_FRAME_TAILROOM;
 +	skb = dev_alloc_skb(len);
 +	if (!skb) {
 +		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 +			     "Unable to allocate RQ sk_buff\n");
++=======
+ 	len = FNIC_FRAME_HT_ROOM;
+ 	buf = kmalloc(len, GFP_ATOMIC);
+ 	if (!buf) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "Unable to allocate RQ buffer of size: %d\n", len);
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  		return -ENOMEM;
  	}
- 	skb_reset_mac_header(skb);
- 	skb_reset_transport_header(skb);
- 	skb_reset_network_header(skb);
- 	skb_put(skb, len);
- 	pa = dma_map_single(&fnic->pdev->dev, skb->data, len, DMA_FROM_DEVICE);
+ 
+ 	pa = dma_map_single(&fnic->pdev->dev, buf, len, DMA_FROM_DEVICE);
  	if (dma_mapping_error(&fnic->pdev->dev, pa)) {
- 		r = -ENOMEM;
- 		printk(KERN_ERR "PCI mapping failed with error %d\n", r);
- 		goto free_skb;
+ 		ret = -ENOMEM;
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "PCI mapping failed with error %d\n", ret);
+ 		goto free_buf;
  	}
  
- 	fnic_queue_rq_desc(rq, skb, pa, len);
+ 	fnic_queue_rq_desc(rq, buf, pa, len);
  	return 0;
- 
- free_skb:
- 	kfree_skb(skb);
- 	return r;
+ free_buf:
+ 	kfree(buf);
+ 	return ret;
  }
  
  void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf)
@@@ -1303,109 -890,173 +1517,281 @@@ void fnic_free_wq_buf(struct vnic_wq *w
  	buf->os_buf = NULL;
  }
  
++<<<<<<< HEAD
 +void fnic_fcoe_reset_vlans(struct fnic *fnic)
 +{
 +	unsigned long flags;
 +	struct fcoe_vlan *vlan;
 +	struct fcoe_vlan *next;
 +
 +	/*
 +	 * indicate a link down to fcoe so that all fcf's are free'd
 +	 * might not be required since we did this before sending vlan
 +	 * discovery request
 +	 */
 +	spin_lock_irqsave(&fnic->vlans_lock, flags);
 +	if (!list_empty(&fnic->vlans)) {
 +		list_for_each_entry_safe(vlan, next, &fnic->vlans, list) {
 +			list_del(&vlan->list);
 +			kfree(vlan);
 +		}
 +	}
 +	spin_unlock_irqrestore(&fnic->vlans_lock, flags);
 +}
 +
 +void fnic_handle_fip_timer(struct fnic *fnic)
 +{
 +	unsigned long flags;
 +	struct fcoe_vlan *vlan;
 +	struct fnic_stats *fnic_stats = &fnic->fnic_stats;
 +	u64 sol_time;
 +
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	if (fnic->stop_rx_link_events) {
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		return;
 +	}
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +
 +	if (fnic->ctlr.mode == FIP_MODE_NON_FIP)
 +		return;
 +
 +	spin_lock_irqsave(&fnic->vlans_lock, flags);
 +	if (list_empty(&fnic->vlans)) {
 +		spin_unlock_irqrestore(&fnic->vlans_lock, flags);
 +		/* no vlans available, try again */
 +		if (unlikely(fnic_log_level & FNIC_FCS_LOGGING))
 +			if (printk_ratelimit())
 +				shost_printk(KERN_DEBUG, fnic->lport->host,
 +						"Start VLAN Discovery\n");
 +		fnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);
 +		return;
 +	}
 +
 +	vlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);
 +	FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 +		  "fip_timer: vlan %d state %d sol_count %d\n",
 +		  vlan->vid, vlan->state, vlan->sol_count);
 +	switch (vlan->state) {
 +	case FIP_VLAN_USED:
 +		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 +			  "FIP VLAN is selected for FC transaction\n");
 +		spin_unlock_irqrestore(&fnic->vlans_lock, flags);
 +		break;
 +	case FIP_VLAN_FAILED:
 +		spin_unlock_irqrestore(&fnic->vlans_lock, flags);
 +		/* if all vlans are in failed state, restart vlan disc */
 +		if (unlikely(fnic_log_level & FNIC_FCS_LOGGING))
 +			if (printk_ratelimit())
 +				shost_printk(KERN_DEBUG, fnic->lport->host,
 +					  "Start VLAN Discovery\n");
 +		fnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);
 +		break;
 +	case FIP_VLAN_SENT:
 +		if (vlan->sol_count >= FCOE_CTLR_MAX_SOL) {
 +			/*
 +			 * no response on this vlan, remove  from the list.
 +			 * Try the next vlan
 +			 */
 +			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host,
 +				  "Dequeue this VLAN ID %d from list\n",
 +				  vlan->vid);
 +			list_del(&vlan->list);
 +			kfree(vlan);
 +			vlan = NULL;
 +			if (list_empty(&fnic->vlans)) {
 +				/* we exhausted all vlans, restart vlan disc */
 +				spin_unlock_irqrestore(&fnic->vlans_lock,
 +							flags);
 +				FNIC_FCS_DBG(KERN_INFO, fnic->lport->host,
 +					  "fip_timer: vlan list empty, "
 +					  "trigger vlan disc\n");
 +				fnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);
 +				return;
 +			}
 +			/* check the next vlan */
 +			vlan = list_first_entry(&fnic->vlans, struct fcoe_vlan,
 +							list);
 +			fnic->set_vlan(fnic, vlan->vid);
 +			vlan->state = FIP_VLAN_SENT; /* sent now */
 +		}
 +		spin_unlock_irqrestore(&fnic->vlans_lock, flags);
 +		atomic64_inc(&fnic_stats->vlan_stats.sol_expiry_count);
 +		vlan->sol_count++;
 +		sol_time = jiffies + msecs_to_jiffies
 +					(FCOE_CTLR_START_DELAY);
 +		mod_timer(&fnic->fip_timer, round_jiffies(sol_time));
 +		break;
 +	}
++=======
+ void
+ fnic_fdls_add_tport(struct fnic_iport_s *iport, struct fnic_tport_s *tport,
+ 					unsigned long flags)
+ {
+ 	struct fnic *fnic = iport->fnic;
+ 	struct fc_rport *rport;
+ 	struct fc_rport_identifiers ids;
+ 	struct rport_dd_data_s *rdd_data;
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Adding rport fcid: 0x%x", tport->fcid);
+ 
+ 	ids.node_name = tport->wwnn;
+ 	ids.port_name = tport->wwpn;
+ 	ids.port_id = tport->fcid;
+ 	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
+ 
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 	rport = fc_remote_port_add(fnic->lport->host, 0, &ids);
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	if (!rport) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "Failed to add rport for tport: 0x%x", tport->fcid);
+ 		return;
+ 	}
+ 
+ 	FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				 "Added rport fcid: 0x%x", tport->fcid);
+ 
+ 	/* Mimic these assignments in queuecommand to avoid timing issues */
+ 	rport->maxframe_size = FNIC_FC_MAX_PAYLOAD_LEN;
+ 	rport->supported_classes = FC_COS_CLASS3 | FC_RPORT_ROLE_FCP_TARGET;
+ 	rdd_data = rport->dd_data;
+ 	rdd_data->tport = tport;
+ 	rdd_data->iport = iport;
+ 	tport->rport = rport;
+ 	tport->flags |= FNIC_FDLS_SCSI_REGISTERED;
+ }
+ 
+ void
+ fnic_fdls_remove_tport(struct fnic_iport_s *iport,
+ 					   struct fnic_tport_s *tport, unsigned long flags)
+ {
+ 	struct fnic *fnic = iport->fnic;
+ 	struct rport_dd_data_s *rdd_data;
+ 
+ 	struct fc_rport *rport;
+ 
+ 	if (!tport)
+ 		return;
+ 
+ 	fdls_set_tport_state(tport, FDLS_TGT_STATE_OFFLINE);
+ 	rport = tport->rport;
+ 
+ 	if (rport) {
+ 		/* tport resource release will be done
+ 		 * after fnic_terminate_rport_io()
+ 		 */
+ 		tport->flags |= FNIC_FDLS_TPORT_DELETED;
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
+ 		/* Interface to scsi_fc_transport  */
+ 		fc_remote_port_delete(rport);
+ 
+ 		spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 		 "Deregistered and freed tport fcid: 0x%x from scsi transport fc",
+ 		 tport->fcid);
+ 
+ 		/*
+ 		 * the dd_data is allocated by fc transport
+ 		 * of size dd_fcrport_size
+ 		 */
+ 		rdd_data = rport->dd_data;
+ 		rdd_data->tport = NULL;
+ 		rdd_data->iport = NULL;
+ 		list_del(&tport->links);
+ 		kfree(tport);
+ 	} else {
+ 		fnic_del_tport_timer_sync(fnic, tport);
+ 		list_del(&tport->links);
+ 		kfree(tport);
+ 	}
+ }
+ 
+ void fnic_delete_fcp_tports(struct fnic *fnic)
+ {
+ 	struct fnic_tport_s *tport, *next;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	list_for_each_entry_safe(tport, next, &fnic->iport.tport_list, links) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "removing fcp rport fcid: 0x%x", tport->fcid);
+ 		fdls_set_tport_state(tport, FDLS_TGT_STATE_OFFLINING);
+ 		fnic_del_tport_timer_sync(fnic, tport);
+ 		fnic_fdls_remove_tport(&fnic->iport, tport, flags);
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ }
+ 
+ /**
+  * fnic_tport_event_handler() - Handler for remote port events
+  * in the tport_event_queue.
+  *
+  * @work: Handle to the remote port being dequeued
+  */
+ void fnic_tport_event_handler(struct work_struct *work)
+ {
+ 	struct fnic *fnic = container_of(work, struct fnic, tport_work);
+ 	struct fnic_tport_event_s *cur_evt, *next;
+ 	unsigned long flags;
+ 	struct fnic_tport_s *tport;
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	list_for_each_entry_safe(cur_evt, next, &fnic->tport_event_list, links) {
+ 		tport = cur_evt->arg1;
+ 		switch (cur_evt->event) {
+ 		case TGT_EV_RPORT_ADD:
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "Add rport event");
+ 			if (tport->state == FDLS_TGT_STATE_READY) {
+ 				fnic_fdls_add_tport(&fnic->iport,
+ 					(struct fnic_tport_s *) cur_evt->arg1, flags);
+ 			} else {
+ 				FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					 "Target not ready. Add rport event dropped: 0x%x",
+ 					 tport->fcid);
+ 			}
+ 			break;
+ 		case TGT_EV_RPORT_DEL:
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "Remove rport event");
+ 			if (tport->state == FDLS_TGT_STATE_OFFLINING) {
+ 				fnic_fdls_remove_tport(&fnic->iport,
+ 					   (struct fnic_tport_s *) cur_evt->arg1, flags);
+ 			} else {
+ 				FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 							 "remove rport event dropped tport fcid: 0x%x",
+ 							 tport->fcid);
+ 			}
+ 			break;
+ 		case TGT_EV_TPORT_DELETE:
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "Delete tport event");
+ 			fdls_delete_tport(tport->iport, tport);
+ 			break;
+ 		default:
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 						 "Unknown tport event");
+ 			break;
+ 		}
+ 		list_del(&cur_evt->links);
+ 		kfree(cur_evt);
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ }
+ 
+ void fnic_flush_tport_event_list(struct fnic *fnic)
+ {
+ 	struct fnic_tport_event_s *cur_evt, *next;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	list_for_each_entry_safe(cur_evt, next, &fnic->tport_event_list, links) {
+ 		list_del(&cur_evt->links);
+ 		kfree(cur_evt);
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  }
diff --cc drivers/scsi/fnic/fnic_main.c
index 06fd7b543b33,943f7d997d10..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -913,15 -936,12 +913,23 @@@ static int fnic_probe(struct pci_dev *p
  
  	INIT_WORK(&fnic->link_work, fnic_handle_link);
  	INIT_WORK(&fnic->frame_work, fnic_handle_frame);
+ 	INIT_WORK(&fnic->tport_work, fnic_tport_event_handler);
  	INIT_WORK(&fnic->flush_work, fnic_flush_tx);
++<<<<<<< HEAD
 +	skb_queue_head_init(&fnic->frame_queue);
 +	skb_queue_head_init(&fnic->tx_queue);
 +
 +	/* Enable all queues */
 +	for (i = 0; i < fnic->raw_wq_count; i++)
 +		vnic_wq_enable(&fnic->wq[i]);
 +	for (i = 0; i < fnic->wq_copy_count; i++)
 +		vnic_wq_copy_enable(&fnic->hw_copy_wq[i]);
++=======
+ 
+ 	INIT_LIST_HEAD(&fnic->frame_queue);
+ 	INIT_LIST_HEAD(&fnic->tx_queue);
+ 	INIT_LIST_HEAD(&fnic->tport_event_list);
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  
  	fc_fabric_login(lp);
  
@@@ -1004,16 -1035,22 +1012,21 @@@ static void fnic_remove(struct pci_dev 
  	 * be no event queued for this fnic device in the workqueue
  	 */
  	flush_workqueue(fnic_event_queue);
++<<<<<<< HEAD
 +	skb_queue_purge(&fnic->frame_queue);
 +	skb_queue_purge(&fnic->tx_queue);
++=======
+ 	fnic_free_txq(&fnic->frame_queue);
+ 	fnic_free_txq(&fnic->tx_queue);
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  
  	if (fnic->config.flags & VFCF_FIP_CAPABLE) {
 -		del_timer_sync(&fnic->retry_fip_timer);
 -		del_timer_sync(&fnic->fcs_ka_timer);
 -		del_timer_sync(&fnic->enode_ka_timer);
 -		del_timer_sync(&fnic->vn_ka_timer);
 -
 -		fnic_free_txq(&fnic->fip_frame_queue);
 +		del_timer_sync(&fnic->fip_timer);
 +		skb_queue_purge(&fnic->fip_frame_queue);
  		fnic_fcoe_reset_vlans(fnic);
 +		fnic_fcoe_evlist_free(fnic);
  	}
  
 -	if ((fnic_fdmi_support == 1) && (fnic->iport.fabric.fdmi_pending > 0))
 -		del_timer_sync(&fnic->iport.fabric.fdmi_timer);
 -
  	/*
  	 * Log off the fabric. This stops all remote ports, dns port,
  	 * logs off the fabric. This flushes all rport, disc, lport work
@@@ -1036,9 -1073,6 +1049,12 @@@
  	 */
  	fnic_cleanup(fnic);
  
++<<<<<<< HEAD
 +	BUG_ON(!skb_queue_empty(&fnic->frame_queue));
 +	BUG_ON(!skb_queue_empty(&fnic->tx_queue));
 +
++=======
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  	spin_lock_irqsave(&fnic_list_lock, flags);
  	list_del(&fnic->list);
  	spin_unlock_irqrestore(&fnic_list_lock, flags);
diff --cc drivers/scsi/fnic/fnic_scsi.c
index 321954ca143f,74298f9a34e5..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -212,8 -183,8 +212,13 @@@ int fnic_fw_reset_handler(struct fnic *
  	/* indicate fwreset to io path */
  	fnic_set_state_flags(fnic, FNIC_FLAGS_FWRESET);
  
++<<<<<<< HEAD
 +	skb_queue_purge(&fnic->frame_queue);
 +	skb_queue_purge(&fnic->tx_queue);
++=======
+ 	fnic_free_txq(&fnic->frame_queue);
+ 	fnic_free_txq(&fnic->tx_queue);
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  
  	/* wait for io cmpl */
  	while (atomic_read(&fnic->in_flight))
@@@ -2478,23 -2575,30 +2483,36 @@@ int fnic_reset(struct Scsi_Host *shost
   * host is offlined by SCSI.
   *
   */
- int fnic_host_reset(struct scsi_cmnd *sc)
+ int fnic_host_reset(struct Scsi_Host *shost)
  {
- 	int ret;
+ 	int ret = SUCCESS;
  	unsigned long wait_host_tmo;
- 	struct Scsi_Host *shost = sc->device->host;
- 	struct fc_lport *lp = shost_priv(shost);
- 	struct fnic *fnic = lport_priv(lp);
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(shost));
  	unsigned long flags;
+ 	struct fnic_iport_s *iport = &fnic->iport;
  
  	spin_lock_irqsave(&fnic->fnic_lock, flags);
- 	if (!fnic->internal_reset_inprogress) {
- 		fnic->internal_reset_inprogress = true;
+ 	if (fnic->reset_in_progress == NOT_IN_PROGRESS) {
+ 		fnic->reset_in_progress = IN_PROGRESS;
  	} else {
  		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			"host reset in progress skipping another host reset\n");
 +		return SUCCESS;
++=======
+ 		wait_for_completion_timeout(&fnic->reset_completion_wait,
+ 									msecs_to_jiffies(10000));
+ 
+ 		spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 		if (fnic->reset_in_progress == IN_PROGRESS) {
+ 			spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 			FNIC_SCSI_DBG(KERN_WARNING, fnic->lport->host, fnic->fnic_num,
+ 			  "Firmware reset in progress. Skipping another host reset\n");
+ 			return SUCCESS;
+ 		}
+ 		fnic->reset_in_progress = IN_PROGRESS;
++>>>>>>> 9cf9fe2f3ec5 (scsi: fnic: Add functionality in fnic to support FDLS)
  	}
  	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fip.c
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fip.c
* Unmerged path drivers/scsi/fnic/fnic.h
* Unmerged path drivers/scsi/fnic/fnic_fcs.c
* Unmerged path drivers/scsi/fnic/fnic_main.c
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
