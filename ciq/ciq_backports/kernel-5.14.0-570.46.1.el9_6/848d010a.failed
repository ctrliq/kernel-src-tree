scsi: fnic: Remove usage of host_lock

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 848d010ab934f1b4326a516396873ddae41db056
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/848d010a.failed

Remove usage of host_lock.  Replace with fnic_lock, where necessary.  fnic
does not use host_lock. fnic uses fnic_lock.  Use fnic lock to protect fnic
members in fnic_queuecommand.  Add log messages in error cases.

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20231211173617.932990-10-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 848d010ab934f1b4326a516396873ddae41db056)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic_scsi.c
diff --cc drivers/scsi/fnic/fnic_scsi.c
index a9f65dc3f089,e9acb2e7dd2e..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -490,14 -497,9 +508,20 @@@ static int fnic_queuecommand_lck(struc
  
  	atomic_inc(&fnic->in_flight);
  
++<<<<<<< HEAD
 +	/*
 +	 * Release host lock, use driver resource specific locks from here.
 +	 * Don't re-enable interrupts in case they were disabled prior to the
 +	 * caller disabling them.
 +	 */
 +	spin_unlock(lp->host->host_lock);
 +	CMD_STATE(sc) = FNIC_IOREQ_NOT_INITED;
 +	CMD_FLAGS(sc) = FNIC_NO_FLAGS;
++=======
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 	fnic_priv(sc)->state = FNIC_IOREQ_NOT_INITED;
+ 	fnic_priv(sc)->flags = FNIC_NO_FLAGS;
++>>>>>>> 848d010ab934 (scsi: fnic: Remove usage of host_lock)
  
  	/* Get a new io_req for this SCSI IO */
  	io_req = mempool_alloc(fnic->io_req_pool, GFP_ATOMIC);
@@@ -1954,11 -1951,15 +1972,11 @@@ static inline int fnic_queue_dr_io_req(
  	struct scsi_lun fc_lun;
  	int ret = 0;
  	unsigned long intr_flags;
 -	unsigned int tag = scsi_cmd_to_rq(sc)->tag;
 -
 -	if (tag == SCSI_NO_TAG)
 -		tag = io_req->tag;
  
- 	spin_lock_irqsave(host->host_lock, intr_flags);
+ 	spin_lock_irqsave(&fnic->fnic_lock, intr_flags);
  	if (unlikely(fnic_chk_state_flags_locked(fnic,
  						FNIC_FLAGS_IO_BLOCKED))) {
- 		spin_unlock_irqrestore(host->host_lock, intr_flags);
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, intr_flags);
  		return FAILED;
  	} else
  		atomic_inc(&fnic->in_flight);
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
