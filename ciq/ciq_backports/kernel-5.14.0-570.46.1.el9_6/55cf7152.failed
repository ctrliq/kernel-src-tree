scsi: fnic: Improve logs and add support for multiqueue (MQ)

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 55cf715244a7dfda42191445d97628e837158091
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/55cf7152.failed

Improve existing logs by adding fnic number, hardware queue, tag, and mqtag
in the prints.  Add logs with the above elements for effective debugging.

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Tested-by: Karan Tilak Kumar <kartilak@cisco.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20231211173617.932990-13-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 55cf715244a7dfda42191445d97628e837158091)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic_scsi.c
diff --cc drivers/scsi/fnic/fnic_scsi.c
index a9f65dc3f089,4d6db4509e75..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -366,14 -338,11 +366,18 @@@ static inline int fnic_queue_wq_copy_de
  	int_to_scsilun(sc->device->lun, &fc_lun);
  
  	/* Enqueue the descriptor in the Copy WQ */
 -	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[hwq])
 -		free_wq_copy_descs(fnic, wq, hwq);
 +	spin_lock_irqsave(&fnic->wq_copy_lock[0], intr_flags);
 +
 +	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])
 +		free_wq_copy_descs(fnic, wq);
  
  	if (unlikely(!vnic_wq_copy_desc_avail(wq))) {
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(&fnic->wq_copy_lock[0], intr_flags);
 +		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,
++=======
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  			  "fnic_queue_wq_copy_desc failure - no descriptors\n");
  		atomic64_inc(&misc_stats->io_cpwq_alloc_failures);
  		return SCSI_MLQUEUE_HOST_BUSY;
@@@ -434,19 -399,33 +438,43 @@@ static int fnic_queuecommand_lck(struc
  	int sg_count = 0;
  	unsigned long flags = 0;
  	unsigned long ptr;
 +	spinlock_t *io_lock = NULL;
  	int io_lock_acquired = 0;
  	struct fc_rport_libfc_priv *rp;
 -	uint16_t hwq = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_IO_BLOCKED)))
++=======
+ 	mqtag = blk_mq_unique_tag(rq);
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 
+ 	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_IO_BLOCKED))) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"fnic IO blocked flags: 0x%lx. Returning SCSI_MLQUEUE_HOST_BUSY\n",
+ 			fnic->state_flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return SCSI_MLQUEUE_HOST_BUSY;
 -	}
  
++<<<<<<< HEAD
 +	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_FWRESET)))
++=======
+ 	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_FWRESET))) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"fnic flags: 0x%lx. Returning SCSI_MLQUEUE_HOST_BUSY\n",
+ 			fnic->state_flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return SCSI_MLQUEUE_HOST_BUSY;
 -	}
  
  	rport = starget_to_rport(scsi_target(sc->device));
  	if (!rport) {
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  				"returning DID_NO_CONNECT for IO as rport is NULL\n");
  		sc->result = DID_NO_CONNECT << 16;
  		done(sc);
@@@ -455,7 -434,8 +483,12 @@@
  
  	ret = fc_remote_port_chkready(rport);
  	if (ret) {
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  				"rport is not ready\n");
  		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
  		sc->result = ret;
@@@ -465,7 -445,8 +498,12 @@@
  
  	rp = rport->dd_data;
  	if (!rp || rp->rp_state == RPORT_ST_DELETE) {
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  			"rport 0x%x removed, returning DID_NO_CONNECT\n",
  			rport->port_id);
  
@@@ -476,7 -457,8 +514,12 @@@
  	}
  
  	if (rp->rp_state != RPORT_ST_READY) {
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  			"rport 0x%x in state 0x%x, returning DID_IMM_RETRY\n",
  			rport->port_id, rp->rp_state);
  
@@@ -485,8 -467,13 +528,16 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (lp->state != LPORT_ST_READY || !(lp->link_up))
++=======
+ 	if (lp->state != LPORT_ST_READY || !(lp->link_up)) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"state not ready: %d/link not up: %d Returning HOST_BUSY\n",
+ 			lp->state, lp->link_up);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return SCSI_MLQUEUE_HOST_BUSY;
 -	}
  
  	atomic_inc(&fnic->in_flight);
  
@@@ -833,18 -818,38 +882,41 @@@ static void fnic_fcpio_icmnd_cmpl_handl
  	u64 cmd_trace;
  	unsigned long start_time;
  	unsigned long io_duration_time;
 -	unsigned int hwq = 0;
 -	unsigned int mqtag = 0;
 -	unsigned int tag = 0;
  
  	/* Decode the cmpl description to get the io_req id */
 -	fcpio_header_dec(&desc->hdr, &type, &hdr_status, &ftag);
 -	fcpio_tag_id_dec(&ftag, &id);
 +	fcpio_header_dec(&desc->hdr, &type, &hdr_status, &tag);
 +	fcpio_tag_id_dec(&tag, &id);
  	icmnd_cmpl = &desc->u.icmnd_cmpl;
  
++<<<<<<< HEAD
 +	if (id >= fnic->fnic_max_tag_id) {
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +			"Tag out of range tag %x hdr status = %s\n",
 +			     id, fnic_fcpio_status_to_str(hdr_status));
++=======
+ 	mqtag = id;
+ 	tag = blk_mq_unique_tag_to_tag(mqtag);
+ 	hwq = blk_mq_unique_tag_to_hwq(mqtag);
+ 
+ 	if (hwq != cq_index) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x cq index: %d ",
+ 			hwq, mqtag, tag, cq_index);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hdr status: %s icmnd completion on the wrong queue\n",
+ 			fnic_fcpio_status_to_str(hdr_status));
+ 	}
+ 
+ 	if (tag >= fnic->fnic_max_tag_id) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x cq index: %d ",
+ 			hwq, mqtag, tag, cq_index);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hdr status: %s Out of range tag\n",
+ 			fnic_fcpio_status_to_str(hdr_status));
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return;
  	}
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
  
  	sc = scsi_host_find_tag(fnic->lport->host, id);
  	WARN_ON_ONCE(!sc);
@@@ -894,13 -905,13 +966,13 @@@
  		 * set the FNIC_IO_DONE so that this doesn't get
  		 * flagged as 'out of order' if it was not aborted
  		 */
 -		fnic_priv(sc)->flags |= FNIC_IO_DONE;
 -		fnic_priv(sc)->flags |= FNIC_IO_ABTS_PENDING;
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		CMD_FLAGS(sc) |= FNIC_IO_DONE;
 +		CMD_FLAGS(sc) |= FNIC_IO_ABTS_PENDING;
 +		spin_unlock_irqrestore(io_lock, flags);
  		if(FCPIO_ABORTED == hdr_status)
 -			fnic_priv(sc)->flags |= FNIC_IO_ABORTED;
 +			CMD_FLAGS(sc) |= FNIC_IO_ABORTED;
  
- 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
  			"icmnd_cmpl abts pending "
  			  "hdr status = %s tag = 0x%x sc = 0x%p "
  			  "scsi_status = %x residual = %d\n",
@@@ -1071,16 -1083,42 +1143,47 @@@ static void fnic_fcpio_itmf_cmpl_handle
  	struct terminate_stats *term_stats = &fnic->fnic_stats.term_stats;
  	struct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;
  	unsigned long flags;
 +	spinlock_t *io_lock;
  	unsigned long start_time;
 -	unsigned int hwq = cq_index;
 -	unsigned int mqtag;
 -	unsigned int tag;
  
 -	fcpio_header_dec(&desc->hdr, &type, &hdr_status, &ftag);
 -	fcpio_tag_id_dec(&ftag, &id);
 +	fcpio_header_dec(&desc->hdr, &type, &hdr_status, &tag);
 +	fcpio_tag_id_dec(&tag, &id);
  
++<<<<<<< HEAD
 +	if ((id & FNIC_TAG_MASK) >= fnic->fnic_max_tag_id) {
 +		shost_printk(KERN_ERR, fnic->lport->host,
 +		"Tag out of range tag %x hdr status = %s\n",
 +		id, fnic_fcpio_status_to_str(hdr_status));
++=======
+ 	mqtag = id & FNIC_TAG_MASK;
+ 	tag = blk_mq_unique_tag_to_tag(id & FNIC_TAG_MASK);
+ 	hwq = blk_mq_unique_tag_to_hwq(id & FNIC_TAG_MASK);
+ 
+ 	if (hwq != cq_index) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x cq index: %d ",
+ 			hwq, mqtag, tag, cq_index);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hdr status: %s ITMF completion on the wrong queue\n",
+ 			fnic_fcpio_status_to_str(hdr_status));
+ 	}
+ 
+ 	if (tag > fnic->fnic_max_tag_id) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x cq index: %d ",
+ 			hwq, mqtag, tag, cq_index);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hdr status: %s Tag out of range\n",
+ 			fnic_fcpio_status_to_str(hdr_status));
+ 		return;
+ 	}  else if ((tag == fnic->fnic_max_tag_id) && !(id & FNIC_TAG_DEV_RST)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x cq index: %d ",
+ 			hwq, mqtag, tag, cq_index);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hdr status: %s Tag out of range\n",
+ 			fnic_fcpio_status_to_str(hdr_status));
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return;
  	}
  
@@@ -1112,17 -1162,22 +1215,31 @@@
  	if ((id & FNIC_TAG_ABORT) && (id & FNIC_TAG_DEV_RST)) {
  		/* Abort and terminate completion of device reset req */
  		/* REVISIT : Add asserts about various flags */
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "dev reset abts cmpl recd. id %x status %s\n",
 +			      id, fnic_fcpio_status_to_str(hdr_status));
 +		CMD_STATE(sc) = FNIC_IOREQ_ABTS_COMPLETE;
 +		CMD_ABTS_STATUS(sc) = hdr_status;
 +		CMD_FLAGS(sc) |= FNIC_DEV_RST_DONE;
++=======
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x hst: %s Abt/term completion received\n",
+ 			hwq, mqtag, tag,
+ 			fnic_fcpio_status_to_str(hdr_status));
+ 		fnic_priv(sc)->state = FNIC_IOREQ_ABTS_COMPLETE;
+ 		fnic_priv(sc)->abts_status = hdr_status;
+ 		fnic_priv(sc)->flags |= FNIC_DEV_RST_DONE;
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		if (io_req->abts_done)
  			complete(io_req->abts_done);
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(io_lock, flags);
  	} else if (id & FNIC_TAG_ABORT) {
  		/* Completion of abort cmd */
+ 		shost_printk(KERN_DEBUG, fnic->lport->host,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x Abort header status: %s\n",
+ 			hwq, mqtag, tag,
+ 			fnic_fcpio_status_to_str(hdr_status));
  		switch (hdr_status) {
  		case FCPIO_SUCCESS:
  			break;
@@@ -1164,12 -1219,12 +1281,12 @@@
  
  		/* If the status is IO not found consider it as success */
  		if (hdr_status == FCPIO_IO_NOT_FOUND)
 -			fnic_priv(sc)->abts_status = FCPIO_SUCCESS;
 +			CMD_ABTS_STATUS(sc) = FCPIO_SUCCESS;
  
 -		if (!(fnic_priv(sc)->flags & (FNIC_IO_ABORTED | FNIC_IO_DONE)))
 +		if (!(CMD_FLAGS(sc) & (FNIC_IO_ABORTED | FNIC_IO_DONE)))
  			atomic64_inc(&misc_stats->no_icmnd_itmf_cmpls);
  
- 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  			      "abts cmpl recd. id %d status %s\n",
  			      (int)(id & FNIC_TAG_MASK),
  			      fnic_fcpio_status_to_str(hdr_status));
@@@ -1181,87 -1236,89 +1298,139 @@@
  		 */
  		if (io_req->abts_done) {
  			complete(io_req->abts_done);
++<<<<<<< HEAD
 +			spin_unlock_irqrestore(io_lock, flags);
 +		} else {
 +			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				      "abts cmpl, completing IO\n");
 +			CMD_SP(sc) = NULL;
++=======
+ 			spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 			shost_printk(KERN_INFO, fnic->lport->host,
+ 					"hwq: %d mqtag: 0x%x tag: 0x%x Waking up abort thread\n",
+ 					hwq, mqtag, tag);
+ 		} else {
+ 			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 				"hwq: %d mqtag: 0x%x tag: 0x%x hst: %s Completing IO\n",
+ 				hwq, mqtag,
+ 				tag, fnic_fcpio_status_to_str(hdr_status));
+ 			fnic_priv(sc)->io_req = NULL;
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  			sc->result = (DID_ERROR << 16);
 -			fnic->sw_copy_wq[hwq].io_req_table[tag] = NULL;
 -			spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +
 +			spin_unlock_irqrestore(io_lock, flags);
  
  			fnic_release_ioreq_buf(fnic, io_req, sc);
  			mempool_free(io_req, fnic->io_req_pool);
 -			FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
 -				   sc->device->host->host_no, id,
 -				   sc,
 -				   jiffies_to_msecs(jiffies - start_time),
 -				   desc,
 -				   (((u64)hdr_status << 40) |
 -				    (u64)sc->cmnd[0] << 32 |
 -				    (u64)sc->cmnd[2] << 24 |
 -				    (u64)sc->cmnd[3] << 16 |
 -				    (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 -				   fnic_flags_and_state(sc));
 -			scsi_done(sc);
 -			atomic64_dec(&fnic_stats->io_stats.active_ios);
 -			if (atomic64_read(&fnic->io_cmpl_skip))
 -				atomic64_dec(&fnic->io_cmpl_skip);
 -			else
 -				atomic64_inc(&fnic_stats->io_stats.io_completions);
 +			if (sc->scsi_done) {
 +				FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
 +					sc->device->host->host_no, id,
 +					sc,
 +					jiffies_to_msecs(jiffies - start_time),
 +					desc,
 +					(((u64)hdr_status << 40) |
 +					(u64)sc->cmnd[0] << 32 |
 +					(u64)sc->cmnd[2] << 24 |
 +					(u64)sc->cmnd[3] << 16 |
 +					(u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 +					(((u64)CMD_FLAGS(sc) << 32) |
 +					CMD_STATE(sc)));
 +				sc->scsi_done(sc);
 +				atomic64_dec(&fnic_stats->io_stats.active_ios);
 +				if (atomic64_read(&fnic->io_cmpl_skip))
 +					atomic64_dec(&fnic->io_cmpl_skip);
 +				else
 +					atomic64_inc(&fnic_stats->io_stats.io_completions);
 +			}
  		}
 +
  	} else if (id & FNIC_TAG_DEV_RST) {
  		/* Completion of device reset */
++<<<<<<< HEAD
 +		CMD_LR_STATUS(sc) = hdr_status;
 +		if (CMD_STATE(sc) == FNIC_IOREQ_ABTS_PENDING) {
 +			spin_unlock_irqrestore(io_lock, flags);
 +			CMD_FLAGS(sc) |= FNIC_DEV_RST_ABTS_PENDING;
 +			FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
 +				  sc->device->host->host_no, id, sc,
 +				  jiffies_to_msecs(jiffies - start_time),
 +				  desc, 0,
 +				  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
 +			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				"Terminate pending "
 +				"dev reset cmpl recd. id %d status %s\n",
 +				(int)(id & FNIC_TAG_MASK),
 +				fnic_fcpio_status_to_str(hdr_status));
++=======
+ 		shost_printk(KERN_INFO, fnic->lport->host,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x DR hst: %s\n",
+ 			hwq, mqtag,
+ 			tag, fnic_fcpio_status_to_str(hdr_status));
+ 		fnic_priv(sc)->lr_status = hdr_status;
+ 		if (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {
+ 			spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 			fnic_priv(sc)->flags |= FNIC_DEV_RST_ABTS_PENDING;
+ 			FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
+ 				  sc->device->host->host_no, id, sc,
+ 				  jiffies_to_msecs(jiffies - start_time),
+ 				  desc, 0, fnic_flags_and_state(sc));
+ 			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 				"hwq: %d mqtag: 0x%x tag: 0x%x hst: %s Terminate pending\n",
+ 				hwq, mqtag,
+ 				tag, fnic_fcpio_status_to_str(hdr_status));
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  			return;
  		}
 -		if (fnic_priv(sc)->flags & FNIC_DEV_RST_TIMED_OUT) {
 +		if (CMD_FLAGS(sc) & FNIC_DEV_RST_TIMED_OUT) {
  			/* Need to wait for terminate completion */
 -			spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +			spin_unlock_irqrestore(io_lock, flags);
  			FNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,
  				  sc->device->host->host_no, id, sc,
  				  jiffies_to_msecs(jiffies - start_time),
++<<<<<<< HEAD
 +				  desc, 0,
 +				  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
 +			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 				  desc, 0, fnic_flags_and_state(sc));
+ 			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  				"dev reset cmpl recd after time out. "
  				"id %d status %s\n",
  				(int)(id & FNIC_TAG_MASK),
  				fnic_fcpio_status_to_str(hdr_status));
  			return;
  		}
++<<<<<<< HEAD
 +		CMD_STATE(sc) = FNIC_IOREQ_CMD_COMPLETE;
 +		CMD_FLAGS(sc) |= FNIC_DEV_RST_DONE;
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "dev reset cmpl recd. id %d status %s\n",
 +			      (int)(id & FNIC_TAG_MASK),
 +			      fnic_fcpio_status_to_str(hdr_status));
++=======
+ 		fnic_priv(sc)->state = FNIC_IOREQ_CMD_COMPLETE;
+ 		fnic_priv(sc)->flags |= FNIC_DEV_RST_DONE;
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x hst: %s DR completion received\n",
+ 			hwq, mqtag,
+ 			tag, fnic_fcpio_status_to_str(hdr_status));
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		if (io_req->dr_done)
  			complete(io_req->dr_done);
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(io_lock, flags);
  
  	} else {
  		shost_printk(KERN_ERR, fnic->lport->host,
++<<<<<<< HEAD
 +			     "Unexpected itmf io state %s tag %x\n",
 +			     fnic_ioreq_state_to_str(CMD_STATE(sc)), id);
 +		spin_unlock_irqrestore(io_lock, flags);
++=======
+ 			"%s: Unexpected itmf io state: hwq: %d tag 0x%x %s\n",
+ 			__func__, hwq, id, fnic_ioreq_state_to_str(fnic_priv(sc)->state));
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  	}
  
  }
@@@ -1355,16 -1414,31 +1524,34 @@@ static bool fnic_cleanup_io_iter(struc
  	struct fnic *fnic = data;
  	struct fnic_io_req *io_req;
  	unsigned long flags = 0;
 +	spinlock_t *io_lock;
  	unsigned long start_time = 0;
  	struct fnic_stats *fnic_stats = &fnic->fnic_stats;
 -	uint16_t hwq = 0;
 -	int tag;
 -	int mqtag;
  
 -	mqtag = blk_mq_unique_tag(rq);
 -	hwq = blk_mq_unique_tag_to_hwq(mqtag);
 -	tag = blk_mq_unique_tag_to_tag(mqtag);
 +	io_lock = fnic_io_lock_tag(fnic, tag);
 +	spin_lock_irqsave(io_lock, flags);
  
++<<<<<<< HEAD
 +	io_req = (struct fnic_io_req *)CMD_SP(sc);
 +	if ((CMD_FLAGS(sc) & FNIC_DEVICE_RESET) &&
 +	    !(CMD_FLAGS(sc) & FNIC_DEV_RST_DONE)) {
++=======
+ 	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 
+ 	fnic->sw_copy_wq[hwq].io_req_table[tag] = NULL;
+ 
+ 	io_req = fnic_priv(sc)->io_req;
+ 	if (!io_req) {
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x flags: 0x%x No ioreq. Returning\n",
+ 			hwq, mqtag, tag, fnic_priv(sc)->flags);
+ 		return true;
+ 	}
+ 
+ 	if ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&
+ 	    !(fnic_priv(sc)->flags & FNIC_DEV_RST_DONE)) {
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		/*
  		 * We will be here only when FW completes reset
  		 * without sending completions for outstanding ios.
@@@ -1397,11 -1467,10 +1584,11 @@@
  	fnic_release_ioreq_buf(fnic, io_req, sc);
  	mempool_free(io_req, fnic->io_req_pool);
  
 +cleanup_scsi_cmd:
  	sc->result = DID_TRANSPORT_DISRUPTED << 16;
- 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
- 		      "fnic_cleanup_io: tag:0x%x : sc:0x%p duration = %lu DID_TRANSPORT_DISRUPTED\n",
- 		      tag, sc, jiffies - start_time);
+ 	FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 		"mqtag:0x%x tag: 0x%x sc:0x%p duration = %lu DID_TRANSPORT_DISRUPTED\n",
+ 		mqtag, tag, sc, (jiffies - start_time));
  
  	if (atomic64_read(&fnic->io_cmpl_skip))
  		atomic64_dec(&fnic->io_cmpl_skip);
@@@ -1480,20 -1544,18 +1667,20 @@@ void fnic_wq_copy_cleanup_handler(struc
  
  wq_copy_cleanup_scsi_cmd:
  	sc->result = DID_NO_CONNECT << 16;
- 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, "wq_copy_cleanup_handler:"
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num, "wq_copy_cleanup_handler:"
  		      " DID_NO_CONNECT\n");
  
 -	FNIC_TRACE(fnic_wq_copy_cleanup_handler,
 -		   sc->device->host->host_no, id, sc,
 -		   jiffies_to_msecs(jiffies - start_time),
 -		   0, ((u64)sc->cmnd[0] << 32 |
 -		       (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
 -		       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 -		   fnic_flags_and_state(sc));
 +	if (sc->scsi_done) {
 +		FNIC_TRACE(fnic_wq_copy_cleanup_handler,
 +			  sc->device->host->host_no, id, sc,
 +			  jiffies_to_msecs(jiffies - start_time),
 +			  0, ((u64)sc->cmnd[0] << 32 |
 +			  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
 +			  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 +			  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
  
 -	scsi_done(sc);
 +		sc->scsi_done(sc);
 +	}
  }
  
  static inline int fnic_queue_abort_io_req(struct fnic *fnic, int tag,
@@@ -1512,17 -1574,17 +1699,17 @@@
  		return 1;
  	} else
  		atomic_inc(&fnic->in_flight);
 -	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +	spin_unlock_irqrestore(host->host_lock, flags);
  
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 +	spin_lock_irqsave(&fnic->wq_copy_lock[0], flags);
  
 -	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[hwq])
 -		free_wq_copy_descs(fnic, wq, hwq);
 +	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])
 +		free_wq_copy_descs(fnic, wq);
  
  	if (!vnic_wq_copy_desc_avail(wq)) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);
  		atomic_dec(&fnic->in_flight);
- 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  			"fnic_queue_abort_io_req: failure: no descriptors\n");
  		atomic64_inc(&misc_stats->abts_cpwq_alloc_failures);
  		return 1;
@@@ -1572,12 -1637,12 +1759,21 @@@ static bool fnic_rport_abort_io_iter(st
  		return true;
  	}
  
++<<<<<<< HEAD
 +	if ((CMD_FLAGS(sc) & FNIC_DEVICE_RESET) &&
 +	    (!(CMD_FLAGS(sc) & FNIC_DEV_RST_ISSUED))) {
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			"fnic_rport_exch_reset dev rst not pending sc 0x%p\n",
 +			sc);
 +		spin_unlock_irqrestore(io_lock, flags);
++=======
+ 	if ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&
+ 	    !(fnic_priv(sc)->flags & FNIC_DEV_RST_ISSUED)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d abt_tag: 0x%x flags: 0x%x Device reset is not pending\n",
+ 			hwq, abt_tag, fnic_priv(sc)->flags);
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return true;
  	}
  
@@@ -1614,10 -1679,10 +1810,10 @@@
  		      "fnic_rport_exch_reset dev rst sc 0x%p\n", sc);
  	BUG_ON(io_req->abts_done);
  
- 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  		      "fnic_rport_reset_exch: Issuing abts\n");
  
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	spin_unlock_irqrestore(io_lock, flags);
  
  	/* Now queue the abort command to firmware */
  	int_to_scsilun(sc->device->lun, &fc_lun);
@@@ -1631,17 -1696,20 +1827,27 @@@
  		 * aborted later by scsi_eh, or cleaned up during
  		 * lun reset
  		 */
++<<<<<<< HEAD
 +		spin_lock_irqsave(io_lock, flags);
 +		if (CMD_STATE(sc) == FNIC_IOREQ_ABTS_PENDING)
 +			CMD_STATE(sc) = old_ioreq_state;
 +		spin_unlock_irqrestore(io_lock, flags);
++=======
+ 		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d abt_tag: 0x%x flags: 0x%x Queuing abort failed\n",
+ 			hwq, abt_tag, fnic_priv(sc)->flags);
+ 		if (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING)
+ 			fnic_priv(sc)->state = old_ioreq_state;
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  	} else {
 -		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -		if (fnic_priv(sc)->flags & FNIC_DEVICE_RESET)
 -			fnic_priv(sc)->flags |= FNIC_DEV_RST_TERM_ISSUED;
 +		spin_lock_irqsave(io_lock, flags);
 +		if (CMD_FLAGS(sc) & FNIC_DEVICE_RESET)
 +			CMD_FLAGS(sc) |= FNIC_DEV_RST_TERM_ISSUED;
  		else
 -			fnic_priv(sc)->flags |= FNIC_IO_INTERNAL_TERM_ISSUED;
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +			CMD_FLAGS(sc) |= FNIC_IO_INTERNAL_TERM_ISSUED;
 +		spin_unlock_irqrestore(io_lock, flags);
  		atomic64_inc(&term_stats->terminates);
  		iter_data->term_cnt++;
  	}
@@@ -1888,10 -1958,10 +2094,17 @@@ int fnic_abort_cmd(struct scsi_cmnd *sc
  
  	/* IO out of order */
  
++<<<<<<< HEAD
 +	if (!(CMD_FLAGS(sc) & (FNIC_IO_ABORTED | FNIC_IO_DONE))) {
 +		spin_unlock_irqrestore(io_lock, flags);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			"Issuing Host reset due to out of order IO\n");
++=======
+ 	if (!(fnic_priv(sc)->flags & (FNIC_IO_ABORTED | FNIC_IO_DONE))) {
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 	    FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"Issuing host reset due to out of order IO\n");
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  
  		ret = FAILED;
  		goto fnic_abort_cmd_end;
@@@ -1935,9 -2006,9 +2148,9 @@@ fnic_abort_cmd_end
  		  0, ((u64)sc->cmnd[0] << 32 |
  		  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
  		  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 -		  fnic_flags_and_state(sc));
 +		  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
  
- 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  		      "Returning from abort cmd type %x %s\n", task_req,
  		      (ret == SUCCESS) ?
  		      "SUCCESS" : "FAILED");
@@@ -1962,15 -2038,15 +2175,15 @@@ static inline int fnic_queue_dr_io_req(
  		return FAILED;
  	} else
  		atomic_inc(&fnic->in_flight);
 -	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +	spin_unlock_irqrestore(host->host_lock, intr_flags);
  
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 +	spin_lock_irqsave(&fnic->wq_copy_lock[0], intr_flags);
  
 -	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[hwq])
 -		free_wq_copy_descs(fnic, wq, hwq);
 +	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])
 +		free_wq_copy_descs(fnic, wq);
  
  	if (!vnic_wq_copy_desc_avail(wq)) {
- 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  			  "queue_dr_io_req failure - no descriptors\n");
  		atomic64_inc(&misc_stats->devrst_cpwq_alloc_failures);
  		ret = -EAGAIN;
@@@ -2033,20 -2113,19 +2246,28 @@@ static bool fnic_pending_aborts_iter(st
  	 * Found IO that is still pending with firmware and
  	 * belongs to the LUN that we are resetting
  	 */
- 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  		      "Found IO in %s on lun\n",
 -		      fnic_ioreq_state_to_str(fnic_priv(sc)->state));
 +		      fnic_ioreq_state_to_str(CMD_STATE(sc)));
  
 -	if (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	if (CMD_STATE(sc) == FNIC_IOREQ_ABTS_PENDING) {
 +		spin_unlock_irqrestore(io_lock, flags);
  		return true;
  	}
++<<<<<<< HEAD
 +	if ((CMD_FLAGS(sc) & FNIC_DEVICE_RESET) &&
 +	    (!(CMD_FLAGS(sc) & FNIC_DEV_RST_ISSUED))) {
 +		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,
 +			      "%s dev rst not pending sc 0x%p\n", __func__,
 +			      sc);
 +		spin_unlock_irqrestore(io_lock, flags);
++=======
+ 	if ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&
+ 	    (!(fnic_priv(sc)->flags & FNIC_DEV_RST_ISSUED))) {
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			      "dev rst not pending sc 0x%p\n", sc);
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		return true;
  	}
  
@@@ -2066,38 -2145,40 +2287,47 @@@
  
  	BUG_ON(io_req->abts_done);
  
++<<<<<<< HEAD
 +	if (CMD_FLAGS(sc) & FNIC_DEVICE_RESET) {
 +		abt_tag |= FNIC_TAG_DEV_RST;
 +		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,
 +			      "%s: dev rst sc 0x%p\n", __func__, sc);
++=======
+ 	if (fnic_priv(sc)->flags & FNIC_DEVICE_RESET) {
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			      "dev rst sc 0x%p\n", sc);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  	}
  
 -	fnic_priv(sc)->abts_status = FCPIO_INVALID_CODE;
 +	CMD_ABTS_STATUS(sc) = FCPIO_INVALID_CODE;
  	io_req->abts_done = &tm_done;
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	spin_unlock_irqrestore(io_lock, flags);
  
  	/* Now queue the abort command to firmware */
  	int_to_scsilun(sc->device->lun, &fc_lun);
  
  	if (fnic_queue_abort_io_req(fnic, abt_tag,
  				    FCPIO_ITMF_ABT_TASK_TERM,
 -				    fc_lun.scsi_lun, io_req, hwq)) {
 -		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -		io_req = fnic_priv(sc)->io_req;
 +				    fc_lun.scsi_lun, io_req)) {
 +		spin_lock_irqsave(io_lock, flags);
 +		io_req = (struct fnic_io_req *)CMD_SP(sc);
  		if (io_req)
  			io_req->abts_done = NULL;
 -		if (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING)
 -			fnic_priv(sc)->state = old_ioreq_state;
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		if (CMD_STATE(sc) == FNIC_IOREQ_ABTS_PENDING)
 +			CMD_STATE(sc) = old_ioreq_state;
 +		spin_unlock_irqrestore(io_lock, flags);
  		iter_data->ret = FAILED;
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d abt_tag: 0x%lx Abort could not be queued\n",
+ 			hwq, abt_tag);
  		return false;
  	} else {
 -		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -		if (fnic_priv(sc)->flags & FNIC_DEVICE_RESET)
 -			fnic_priv(sc)->flags |= FNIC_DEV_RST_TERM_ISSUED;
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_lock_irqsave(io_lock, flags);
 +		if (CMD_FLAGS(sc) & FNIC_DEVICE_RESET)
 +			CMD_FLAGS(sc) |= FNIC_DEV_RST_TERM_ISSUED;
 +		spin_unlock_irqrestore(io_lock, flags);
  	}
 -	fnic_priv(sc)->flags |= FNIC_IO_INTERNAL_TERM_ISSUED;
 +	CMD_FLAGS(sc) |= FNIC_IO_INTERNAL_TERM_ISSUED;
  
  	wait_for_completion_timeout(&tm_done, msecs_to_jiffies
  				    (fnic->config.ed_tov));
@@@ -2265,14 -2349,23 +2496,18 @@@ int fnic_device_reset(struct scsi_cmnd 
  		}
  		memset(io_req, 0, sizeof(*io_req));
  		io_req->port_id = rport->port_id;
 -		io_req->tag = mqtag;
 -		fnic_priv(sc)->io_req = io_req;
 -		io_req->sc = sc;
 -
 -		if (fnic->sw_copy_wq[hwq].io_req_table[blk_mq_unique_tag_to_tag(mqtag)] != NULL)
 -			WARN(1, "fnic<%d>: %s: tag 0x%x already exists\n",
 -					fnic->fnic_num, __func__, blk_mq_unique_tag_to_tag(mqtag));
 -
 -		fnic->sw_copy_wq[hwq].io_req_table[blk_mq_unique_tag_to_tag(mqtag)] =
 -				io_req;
 +		CMD_SP(sc) = (char *)io_req;
  	}
  	io_req->dr_done = &tm_done;
 -	fnic_priv(sc)->state = FNIC_IOREQ_CMD_PENDING;
 -	fnic_priv(sc)->lr_status = FCPIO_INVALID_CODE;
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	CMD_STATE(sc) = FNIC_IOREQ_CMD_PENDING;
 +	CMD_LR_STATUS(sc) = FCPIO_INVALID_CODE;
 +	spin_unlock_irqrestore(io_lock, flags);
  
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, "TAG %x\n", tag);
++=======
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num, "TAG %x\n", mqtag);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  
  	/*
  	 * issue the device reset, if enqueue failed, clean up the ioreq
@@@ -2296,12 -2389,12 +2531,18 @@@
  	wait_for_completion_timeout(&tm_done,
  				    msecs_to_jiffies(FNIC_LUN_RESET_TIMEOUT));
  
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -	io_req = fnic_priv(sc)->io_req;
 +	spin_lock_irqsave(io_lock, flags);
 +	io_req = (struct fnic_io_req *)CMD_SP(sc);
  	if (!io_req) {
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(io_lock, flags);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				"io_req is null tag 0x%x sc 0x%p\n", tag, sc);
++=======
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 				"io_req is null mqtag 0x%x sc 0x%p\n", mqtag, sc);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  		goto fnic_device_reset_end;
  	}
  	io_req->dr_done = NULL;
@@@ -2314,10 -2407,10 +2555,10 @@@
  	 */
  	if (status == FCPIO_INVALID_CODE) {
  		atomic64_inc(&reset_stats->device_reset_timeouts);
- 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  			      "Device reset timed out\n");
 -		fnic_priv(sc)->flags |= FNIC_DEV_RST_TIMED_OUT;
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		CMD_FLAGS(sc) |= FNIC_DEV_RST_TIMED_OUT;
 +		spin_unlock_irqrestore(io_lock, flags);
  		int_to_scsilun(sc->device->lun, &fc_lun);
  		/*
  		 * Issue abort and terminate on device reset request.
@@@ -2337,14 -2430,14 +2578,21 @@@
  				wait_for_completion_timeout(&tm_done,
  				msecs_to_jiffies(FNIC_ABT_TERM_DELAY_TIMEOUT));
  			} else {
 -				spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -				fnic_priv(sc)->flags |= FNIC_DEV_RST_TERM_ISSUED;
 -				fnic_priv(sc)->state = FNIC_IOREQ_ABTS_PENDING;
 +				spin_lock_irqsave(io_lock, flags);
 +				CMD_FLAGS(sc) |= FNIC_DEV_RST_TERM_ISSUED;
 +				CMD_STATE(sc) = FNIC_IOREQ_ABTS_PENDING;
  				io_req->abts_done = &tm_done;
++<<<<<<< HEAD
 +				spin_unlock_irqrestore(io_lock, flags);
 +				FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				"Abort and terminate issued on Device reset "
 +				"tag 0x%x sc 0x%p\n", tag, sc);
++=======
+ 				spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 				FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 				"Abort and terminate issued on Device reset mqtag 0x%x sc 0x%p\n",
+ 				mqtag, sc);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  				break;
  			}
  		}
@@@ -2367,11 -2460,11 +2615,11 @@@
  
  	/* Completed, but not successful, clean up the io_req, return fail */
  	if (status != FCPIO_SUCCESS) {
 -		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 +		spin_lock_irqsave(io_lock, flags);
  		FNIC_SCSI_DBG(KERN_DEBUG,
- 			      fnic->lport->host,
+ 			      fnic->lport->host, fnic->fnic_num,
  			      "Device reset completed - failed\n");
 -		io_req = fnic_priv(sc)->io_req;
 +		io_req = (struct fnic_io_req *)CMD_SP(sc);
  		goto fnic_device_reset_clean;
  	}
  
@@@ -2383,9 -2476,9 +2631,15 @@@
  	 * succeeds
  	 */
  	if (fnic_clean_pending_aborts(fnic, sc, new_sc)) {
++<<<<<<< HEAD
 +		spin_lock_irqsave(io_lock, flags);
 +		io_req = (struct fnic_io_req *)CMD_SP(sc);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 		io_req = fnic_priv(sc)->io_req;
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  			      "Device reset failed"
  			      " since could not abort all IOs\n");
  		goto fnic_device_reset_clean;
@@@ -2416,13 -2512,14 +2670,13 @@@ fnic_device_reset_end
  		  0, ((u64)sc->cmnd[0] << 32 |
  		  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
  		  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 -		  fnic_flags_and_state(sc));
 +		  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
  
 -	if (new_sc) {
 -		fnic->sgreset_sc = NULL;
 -		mutex_unlock(&fnic->sgreset_mutex);
 -	}
 +	/* free tag if it is allocated */
 +	if (unlikely(tag_gen_flag))
 +		fnic_scsi_host_end_tag(fnic, sc);
  
- 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
  		      "Returning from device reset %s\n",
  		      (ret == SUCCESS) ?
  		      "SUCCESS" : "FAILED");
@@@ -2670,11 -2770,12 +2923,20 @@@ static bool fnic_abts_pending_iter(stru
  	 * Found IO that is still pending with firmware and
  	 * belongs to the LUN that we are resetting
  	 */
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,
 +		      "Found IO in %s on lun\n",
 +		      fnic_ioreq_state_to_str(CMD_STATE(sc)));
 +	cmd_state = CMD_STATE(sc);
 +	spin_unlock_irqrestore(io_lock, flags);
++=======
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 		"hwq: %d tag: 0x%x Found IO in state: %s on lun\n",
+ 		hwq, tag,
+ 		fnic_ioreq_state_to_str(fnic_priv(sc)->state));
+ 	cmd_state = fnic_priv(sc)->state;
+ 	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 55cf715244a7 (scsi: fnic: Improve logs and add support for multiqueue (MQ))
  	if (cmd_state == FNIC_IOREQ_ABTS_PENDING)
  		iter_data->ret = 1;
  
diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 9ebca3720f82..6abc780ff810 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -151,9 +151,11 @@ do {								\
 	FNIC_CHECK_LOGGING(FNIC_FCS_LOGGING,			\
 			 shost_printk(kern_level, host, fmt, ##args);)
 
-#define FNIC_SCSI_DBG(kern_level, host, fmt, args...)		\
+#define FNIC_SCSI_DBG(kern_level, host, fnic_num, fmt, args...)		\
 	FNIC_CHECK_LOGGING(FNIC_SCSI_LOGGING,			\
-			 shost_printk(kern_level, host, fmt, ##args);)
+			 shost_printk(kern_level, host,			\
+				"fnic<%d>: %s: %d: " fmt, fnic_num,\
+				__func__, __LINE__, ##args);)
 
 #define FNIC_ISR_DBG(kern_level, host, fnic_num, fmt, args...)		\
 	FNIC_CHECK_LOGGING(FNIC_ISR_LOGGING,			\
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
