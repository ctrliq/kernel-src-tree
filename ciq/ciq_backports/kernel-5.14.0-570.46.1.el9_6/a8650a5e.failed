scsi: fnic: Add stats and related functionality

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit a8650a5eaaf123572a7b2d6b1fe9f6b000b6b6a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/a8650a5e.failed

Add statistics and related functionality for FDLS.

Add supporting functions to display stats.

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Reviewed-by: Gian Carlo Boffa <gcboffa@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20241212020312.4786-13-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a8650a5eaaf123572a7b2d6b1fe9f6b000b6b6a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fdls_disc.c
#	drivers/scsi/fnic/fnic_main.c
#	drivers/scsi/fnic/fnic_scsi.c
#	drivers/scsi/fnic/fnic_stats.h
#	drivers/scsi/fnic/fnic_trace.c
diff --cc drivers/scsi/fnic/fnic_main.c
index 06fd7b543b33,628c9e5902a2..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -165,22 -162,38 +165,34 @@@ static struct fc_function_template fnic
  	.show_starget_port_id = 1,
  	.show_rport_dev_loss_tmo = 1,
  	.set_rport_dev_loss_tmo = fnic_set_rport_dev_loss_tmo,
++<<<<<<< HEAD
 +	.issue_fc_host_lip = fnic_reset,
++=======
+ 	.issue_fc_host_lip = fnic_issue_fc_host_lip,
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  	.get_fc_host_stats = fnic_get_stats,
  	.reset_fc_host_stats = fnic_reset_host_stats,
 -	.dd_fcrport_size = sizeof(struct rport_dd_data_s),
 +	.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),
  	.terminate_rport_io = fnic_terminate_rport_io,
 -	.bsg_request = NULL,
 +	.bsg_request = fc_lport_bsg_request,
  };
  
  static void fnic_get_host_speed(struct Scsi_Host *shost)
  {
 -	struct fnic *fnic = *((struct fnic **) shost_priv(shost));
 +	struct fc_lport *lp = shost_priv(shost);
 +	struct fnic *fnic = lport_priv(lp);
  	u32 port_speed = vnic_dev_port_speed(fnic->vdev);
+ 	struct fnic_stats *fnic_stats = &fnic->fnic_stats;
  
++<<<<<<< HEAD
++=======
+ 	FNIC_MAIN_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "port_speed: %d Mbps", port_speed);
+ 	atomic64_set(&fnic_stats->misc_stats.port_speed_in_mbps, port_speed);
+ 
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  	/* Add in other values as they get defined in fw */
  	switch (port_speed) {
 -	case DCEM_PORTSPEED_1G:
 -		fc_host_speed(shost) = FC_PORTSPEED_1GBIT;
 -		break;
 -	case DCEM_PORTSPEED_2G:
 -		fc_host_speed(shost) = FC_PORTSPEED_2GBIT;
 -		break;
 -	case DCEM_PORTSPEED_4G:
 -		fc_host_speed(shost) = FC_PORTSPEED_4GBIT;
 -		break;
 -	case DCEM_PORTSPEED_8G:
 -		fc_host_speed(shost) = FC_PORTSPEED_8GBIT;
 -		break;
  	case DCEM_PORTSPEED_10G:
  		fc_host_speed(shost) = FC_PORTSPEED_10GBIT;
  		break;
@@@ -206,13 -236,14 +218,23 @@@
  static struct fc_host_statistics *fnic_get_stats(struct Scsi_Host *host)
  {
  	int ret;
++<<<<<<< HEAD
 +	struct fc_lport *lp = shost_priv(host);
 +	struct fnic *fnic = lport_priv(lp);
 +	struct fc_host_statistics *stats = &lp->host_stats;
 +	struct vnic_stats *vs;
 +	unsigned long flags;
 +
 +	if (time_before(jiffies, fnic->stats_time + HZ / FNIC_STATS_RATE_LIMIT))
++=======
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(host));
+ 	struct fc_host_statistics *stats = &fnic->fnic_stats.host_stats;
+ 	struct vnic_stats *vs;
+ 	unsigned long flags;
+ 
+ 	if (time_before
+ 		(jiffies, fnic->stats_time + HZ / FNIC_STATS_RATE_LIMIT))
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  		return stats;
  	fnic->stats_time = jiffies;
  
@@@ -221,24 -252,22 +243,41 @@@
  	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  
  	if (ret) {
++<<<<<<< HEAD
 +		FNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "fnic: Get vnic stats failed"
 +			      " 0x%x", ret);
++=======
+ 		FNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 					  "fnic: Get vnic stats failed: 0x%x", ret);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  		return stats;
  	}
  	vs = fnic->stats;
  	stats->tx_frames = vs->tx.tx_unicast_frames_ok;
++<<<<<<< HEAD
 +	stats->tx_words  = vs->tx.tx_unicast_bytes_ok / 4;
 +	stats->rx_frames = vs->rx.rx_unicast_frames_ok;
 +	stats->rx_words  = vs->rx.rx_unicast_bytes_ok / 4;
++=======
+ 	stats->tx_words = vs->tx.tx_unicast_bytes_ok / 4;
+ 	stats->rx_frames = vs->rx.rx_unicast_frames_ok;
+ 	stats->rx_words = vs->rx.rx_unicast_bytes_ok / 4;
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  	stats->error_frames = vs->tx.tx_errors + vs->rx.rx_errors;
  	stats->dumped_frames = vs->tx.tx_drops + vs->rx.rx_drop;
  	stats->invalid_crc_count = vs->rx.rx_crc_errors;
  	stats->seconds_since_last_reset =
++<<<<<<< HEAD
 +			(jiffies - fnic->stats_reset_time) / HZ;
 +	stats->fcp_input_megabytes = div_u64(fnic->fcp_input_bytes, 1000000);
 +	stats->fcp_output_megabytes = div_u64(fnic->fcp_output_bytes, 1000000);
 +
++=======
+ 		(jiffies - fnic->stats_reset_time) / HZ;
+ 	stats->fcp_input_megabytes = div_u64(fnic->fcp_input_bytes, 1000000);
+ 	stats->fcp_output_megabytes = div_u64(fnic->fcp_output_bytes, 1000000);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  	return stats;
  }
  
diff --cc drivers/scsi/fnic/fnic_scsi.c
index 321954ca143f,e464c677e9da..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -455,9 -488,9 +455,13 @@@ static int fnic_queuecommand_lck(struc
  
  	ret = fc_remote_port_chkready(rport);
  	if (ret) {
 -		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
  				"rport is not ready\n");
++<<<<<<< HEAD
 +		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
++=======
+ 		atomic64_inc(&fnic_stats->misc_stats.tport_not_ready);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  		sc->result = ret;
  		done(sc);
  		return 0;
@@@ -1005,22 -1127,19 +1009,31 @@@ static void fnic_fcpio_icmnd_cmpl_handl
  		  ((u64)icmnd_cmpl->_resvd0[1] << 56 |
  		  (u64)icmnd_cmpl->_resvd0[0] << 48 |
  		  jiffies_to_msecs(jiffies - start_time)),
 -		  desc, cmd_trace, fnic_flags_and_state(sc));
 +		  desc, cmd_trace,
 +		  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
 +
 +	if (sc->sc_data_direction == DMA_FROM_DEVICE) {
 +		fnic->lport->host_stats.fcp_input_requests++;
 +		fnic->fcp_input_bytes += xfer_len;
 +	} else if (sc->sc_data_direction == DMA_TO_DEVICE) {
 +		fnic->lport->host_stats.fcp_output_requests++;
 +		fnic->fcp_output_bytes += xfer_len;
 +	} else
 +		fnic->lport->host_stats.fcp_control_requests++;
  
+ 	if (sc->sc_data_direction == DMA_FROM_DEVICE) {
+ 		fnic_stats->host_stats.fcp_input_requests++;
+ 		fnic->fcp_input_bytes += xfer_len;
+ 	} else if (sc->sc_data_direction == DMA_TO_DEVICE) {
+ 		fnic_stats->host_stats.fcp_output_requests++;
+ 		fnic->fcp_output_bytes += xfer_len;
+ 	} else
+ 		fnic_stats->host_stats.fcp_control_requests++;
+ 
  	/* Call SCSI completion function to complete the IO */
 -	scsi_done(sc);
 +	if (sc->scsi_done)
 +		sc->scsi_done(sc);
 +	spin_unlock_irqrestore(io_lock, flags);
  
  	mempool_free(io_req, fnic->io_req_pool);
  
@@@ -1674,37 -1923,74 +1687,59 @@@ static void fnic_rport_exch_reset(struc
  
  void fnic_terminate_rport_io(struct fc_rport *rport)
  {
 -	struct fnic_tport_s *tport;
 -	struct rport_dd_data_s *rdd_data;
 -	struct fnic_iport_s *iport = NULL;
 -	struct fnic *fnic = NULL;
 +	struct fc_rport_libfc_priv *rdata;
 +	struct fc_lport *lport;
 +	struct fnic *fnic;
  
  	if (!rport) {
 -		pr_err("rport is NULL\n");
 +		printk(KERN_ERR "fnic_terminate_rport_io: rport is NULL\n");
  		return;
  	}
 +	rdata = rport->dd_data;
  
 -	rdd_data = rport->dd_data;
 -	if (rdd_data) {
 -		tport = rdd_data->tport;
 -		if (!tport) {
 -			pr_err(
 -			"term rport io called after tport is deleted. Returning 0x%8x\n",
 -		   rport->port_id);
 -		} else {
 -			pr_err(
 -			   "term rport io called after tport is set 0x%8x\n",
 -			   rport->port_id);
 -			pr_err(
 -			   "tport maybe rediscovered\n");
 -
 -			iport = (struct fnic_iport_s *) tport->iport;
 -			fnic = iport->fnic;
 -			fnic_rport_exch_reset(fnic, rport->port_id);
 -		}
 +	if (!rdata) {
 +		printk(KERN_ERR "fnic_terminate_rport_io: rdata is NULL\n");
 +		return;
  	}
 -}
 +	lport = rdata->local_port;
  
 -/*
 - * FCP-SCSI specific handling for module unload
 - *
 - */
 -void fnic_scsi_unload(struct fnic *fnic)
 -{
 -	unsigned long flags;
 +	if (!lport) {
 +		printk(KERN_ERR "fnic_terminate_rport_io: lport is NULL\n");
 +		return;
 +	}
 +	fnic = lport_priv(lport);
 +	FNIC_SCSI_DBG(KERN_DEBUG,
 +		      fnic->lport->host, "fnic_terminate_rport_io called"
 +		      " wwpn 0x%llx, wwnn0x%llx, rport 0x%p, portid 0x%06x\n",
 +		      rport->port_name, rport->node_name, rport,
 +		      rport->port_id);
  
 -	/*
 -	 * Mark state so that the workqueue thread stops forwarding
 -	 * received frames and link events to the local port. ISR and
 -	 * other threads that can queue work items will also stop
 -	 * creating work items on the fnic workqueue
 -	 */
 -	spin_lock_irqsave(&fnic->fnic_lock, flags);
 -	fnic->iport.state = FNIC_IPORT_STATE_LINK_WAIT;
 -	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +	if (fnic->in_remove)
 +		return;
  
++<<<<<<< HEAD
 +	fnic_rport_exch_reset(fnic, rport->port_id);
++=======
+ 	if (fdls_get_state(&fnic->iport.fabric) != FDLS_STATE_INIT)
+ 		fnic_scsi_fcpio_reset(fnic);
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	fnic->in_remove = 1;
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
+ 	fnic_flush_tport_event_list(fnic);
+ 	fnic_delete_fcp_tports(fnic);
+ }
+ 
+ void fnic_scsi_unload_cleanup(struct fnic *fnic)
+ {
+ 	int hwq = 0;
+ 
+ 	fc_remove_host(fnic->lport->host);
+ 	scsi_remove_host(fnic->lport->host);
+ 	for (hwq = 0; hwq < fnic->wq_copy_count; hwq++)
+ 		kfree(fnic->sw_copy_wq[hwq].io_req_table);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  }
  
  /*
@@@ -1757,6 -2056,35 +1792,37 @@@ int fnic_abort_cmd(struct scsi_cmnd *sc
  		goto fnic_abort_cmd_end;
  	}
  
++<<<<<<< HEAD
++=======
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 	  "Abort cmd called rport fcid: 0x%x lun: %llu hwq: 0x%x mqtag: 0x%x",
+ 	  rport->port_id, sc->device->lun, hwq, mqtag);
+ 
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "Op: 0x%x flags: 0x%x\n",
+ 				  sc->cmnd[0],
+ 				  fnic_priv(sc)->flags);
+ 
+ 	if (iport->state != FNIC_IPORT_STATE_READY) {
+ 		atomic64_inc(&fnic_stats->misc_stats.iport_not_ready);
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "iport NOT in READY state");
+ 		ret = FAILED;
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_abort_cmd_end;
+ 	}
+ 
+ 	if ((tport->state != FDLS_TGT_STATE_READY) &&
+ 		(tport->state != FDLS_TGT_STATE_ADISC)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "tport state: %d\n", tport->state);
+ 		ret = FAILED;
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_abort_cmd_end;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  	/*
  	 * Avoid a race between SCSI issuing the abort and the device
  	 * completing the command.
@@@ -1822,7 -2151,7 +1888,11 @@@
  	if (fc_remote_port_chkready(rport) == 0)
  		task_req = FCPIO_ITMF_ABT_TASK;
  	else {
++<<<<<<< HEAD
 +		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
++=======
+ 		atomic64_inc(&fnic_stats->misc_stats.tport_not_ready);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  		task_req = FCPIO_ITMF_ABT_TASK_TERM;
  	}
  
@@@ -2222,16 -2571,43 +2292,41 @@@ int fnic_device_reset(struct scsi_cmnd 
  	atomic64_inc(&reset_stats->device_resets);
  
  	rport = starget_to_rport(scsi_target(sc->device));
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "Device reset called FCID 0x%x, LUN 0x%llx sc 0x%p\n",
 +		      rport->port_id, sc->device->lun, sc);
  
 -	spin_lock_irqsave(&fnic->fnic_lock, flags);
 -	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
 -		"fcid: 0x%x lun: %llu hwq: %d mqtag: 0x%x flags: 0x%x Device reset\n",
 -		rport->port_id, sc->device->lun, hwq, mqtag,
 -		fnic_priv(sc)->flags);
 -
 -	rdd_data = rport->dd_data;
 -	tport = rdd_data->tport;
 -	if (!tport) {
 -		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
 -		  "Dev rst called after tport delete! rport fcid: 0x%x lun: %llu\n",
 -		  rport->port_id, sc->device->lun);
 -		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +	if (lp->state != LPORT_ST_READY || !(lp->link_up))
  		goto fnic_device_reset_end;
++<<<<<<< HEAD
 +
 +	/* Check if remote port up */
 +	if (fc_remote_port_chkready(rport)) {
 +		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
++=======
+ 	}
+ 
+ 	if (iport->state != FNIC_IPORT_STATE_READY) {
+ 		atomic64_inc(&fnic_stats->misc_stats.iport_not_ready);
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "iport NOT in READY state");
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_device_reset_end;
+ 	}
+ 
+ 	if ((tport->state != FDLS_TGT_STATE_READY) &&
+ 		(tport->state != FDLS_TGT_STATE_ADISC)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "tport state: %d\n", tport->state);
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_device_reset_end;
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
+ 	/* Check if remote port up */
+ 	if (fc_remote_port_chkready(rport)) {
+ 		atomic64_inc(&fnic_stats->misc_stats.tport_not_ready);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  		goto fnic_device_reset_end;
  	}
  
@@@ -2707,3 -3016,76 +2802,79 @@@ int fnic_is_abts_pending(struct fnic *f
  
  	return iter_data.ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * SCSI Error handling calls driver's eh_host_reset if all prior
+  * error handling levels return FAILED. If host reset completes
+  * successfully, and if link is up, then Fabric login begins.
+  *
+  * Host Reset is the highest level of error recovery. If this fails, then
+  * host is offlined by SCSI.
+  *
+  */
+ int fnic_eh_host_reset_handler(struct scsi_cmnd *sc)
+ {
+ 	int ret = 0;
+ 	struct Scsi_Host *shost = sc->device->host;
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(shost));
+ 
+ 	FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 				  "SCSI error handling: fnic host reset");
+ 
+ 	ret = fnic_host_reset(shost);
+ 	return ret;
+ }
+ 
+ 
+ void fnic_scsi_fcpio_reset(struct fnic *fnic)
+ {
+ 	unsigned long flags;
+ 	enum fnic_state old_state;
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 	DECLARE_COMPLETION_ONSTACK(fw_reset_done);
+ 	int time_remain;
+ 
+ 	/* issue fw reset */
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	if (unlikely(fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)) {
+ 		/* fw reset is in progress, poll for its completion */
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			  "fnic is in unexpected state: %d for fw_reset\n",
+ 			  fnic->state);
+ 		return;
+ 	}
+ 
+ 	old_state = fnic->state;
+ 	fnic->state = FNIC_IN_FC_TRANS_ETH_MODE;
+ 
+ 	fnic_update_mac_locked(fnic, iport->hwmac);
+ 	fnic->fw_reset_done = &fw_reset_done;
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "Issuing fw reset\n");
+ 	if (fnic_fw_reset_handler(fnic)) {
+ 		spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 		if (fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)
+ 			fnic->state = old_state;
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 	} else {
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "Waiting for fw completion\n");
+ 		time_remain = wait_for_completion_timeout(&fw_reset_done,
+ 						  msecs_to_jiffies(FNIC_FW_RESET_TIMEOUT));
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "Woken up after fw completion timeout\n");
+ 		if (time_remain == 0) {
+ 			FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "FW reset completion timed out after %d ms)\n",
+ 				  FNIC_FW_RESET_TIMEOUT);
+ 		}
+ 		atomic64_inc(&fnic->fnic_stats.reset_stats.fw_reset_timeouts);
+ 	}
+ 	fnic->fw_reset_done = NULL;
+ }
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
diff --cc drivers/scsi/fnic/fnic_stats.h
index ca7ab8afa60a,8ddd20401a59..000000000000
--- a/drivers/scsi/fnic/fnic_stats.h
+++ b/drivers/scsi/fnic/fnic_stats.h
@@@ -141,6 -171,5 +183,10 @@@ struct stats_debug_info 
  };
  
  int fnic_get_stats_data(struct stats_debug_info *, struct fnic_stats *);
++<<<<<<< HEAD
 +void fnic_stats_debugfs_init(struct fnic *);
 +void fnic_stats_debugfs_remove(struct fnic *);
++=======
+ const char *fnic_role_to_str(unsigned int role);
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  #endif /* _FNIC_STATS_H_ */
diff --cc drivers/scsi/fnic/fnic_trace.c
index a1d62546c584,420a25332cef..000000000000
--- a/drivers/scsi/fnic/fnic_trace.c
+++ b/drivers/scsi/fnic/fnic_trace.c
@@@ -472,6 -467,60 +481,63 @@@ int fnic_get_stats_data(struct stats_de
  
  }
  
++<<<<<<< HEAD
++=======
+ int fnic_get_debug_info(struct stats_debug_info *info, struct fnic *fnic)
+ {
+ 	struct fnic_iport_s *iport = &fnic->iport;
+ 	int buf_size = info->buf_size;
+ 	int len = info->buffer_len;
+ 	struct fnic_tport_s *tport, *next;
+ 	unsigned long flags;
+ 
+ 	len += snprintf(info->debug_buffer + len, buf_size - len,
+ 					"------------------------------------------\n"
+ 					"\t\t Debug Info\n"
+ 					"------------------------------------------\n");
+ 	len += snprintf(info->debug_buffer + len, buf_size - len,
+ 					"fnic Name:%s number:%d Role:%s State:%s\n",
+ 					fnic->name, fnic->fnic_num,
+ 					fnic_role_to_str(fnic->role),
+ 					fnic_state_to_str(fnic->state));
+ 	len +=
+ 		snprintf(info->debug_buffer + len, buf_size - len,
+ 			 "iport State:%d Flags:0x%x vlan_id:%d fcid:0x%x\n",
+ 			 iport->state, iport->flags, iport->vlan_id, iport->fcid);
+ 	len +=
+ 		snprintf(info->debug_buffer + len, buf_size - len,
+ 			 "usefip:%d fip_state:%d fip_flogi_retry:%d\n",
+ 			 iport->usefip, iport->fip.state, iport->fip.flogi_retry);
+ 	len +=
+ 		snprintf(info->debug_buffer + len, buf_size - len,
+ 				 "fpma %02x:%02x:%02x:%02x:%02x:%02x",
+ 				 iport->fpma[5], iport->fpma[4], iport->fpma[3],
+ 				 iport->fpma[2], iport->fpma[1], iport->fpma[0]);
+ 	len +=
+ 		snprintf(info->debug_buffer + len, buf_size - len,
+ 				"fcfmac %02x:%02x:%02x:%02x:%02x:%02x\n",
+ 				iport->fcfmac[5], iport->fcfmac[4], iport->fcfmac[3],
+ 				iport->fcfmac[2], iport->fcfmac[1], iport->fcfmac[0]);
+ 	len +=
+ 		snprintf(info->debug_buffer + len, buf_size - len,
+ 		 "fabric state:%d flags:0x%x retry_counter:%d e_d_tov:%d r_a_tov:%d\n",
+ 		 iport->fabric.state, iport->fabric.flags,
+ 		 iport->fabric.retry_counter, iport->e_d_tov,
+ 		 iport->r_a_tov);
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	list_for_each_entry_safe(tport, next, &iport->tport_list, links) {
+ 		len += snprintf(info->debug_buffer + len, buf_size - len,
+ 		"tport fcid:0x%x state:%d flags:0x%x inflight:%d retry_counter:%d\n",
+ 		tport->fcid, tport->state, tport->flags,
+ 		atomic_read(&tport->in_flight),
+ 		tport->retry_counter);
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 	return len;
+ }
+ 
++>>>>>>> a8650a5eaaf1 (scsi: fnic: Add stats and related functionality)
  /*
   * fnic_trace_buf_init - Initialize fnic trace buffer logging facility
   *
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fdls_disc.c
diff --git a/drivers/scsi/fnic/fnic_fdls.h b/drivers/scsi/fnic/fnic_fdls.h
index 5d78eea20873..3ad3afcf63d2 100644
--- a/drivers/scsi/fnic/fnic_fdls.h
+++ b/drivers/scsi/fnic/fnic_fdls.h
@@ -305,10 +305,12 @@ struct fnic_iport_s {
 	uint16_t max_payload_size;
 	spinlock_t deleted_tport_lst_lock;
 	struct completion *flogi_reg_done;
+	struct fnic_iport_stats iport_stats;
 	char str_wwpn[20];
 	char str_wwnn[20];
-	};
-	struct rport_dd_data_s {
+};
+
+struct rport_dd_data_s {
 	struct fnic_tport_s *tport;
 	struct fnic_iport_s *iport;
 };
* Unmerged path drivers/scsi/fnic/fnic_main.c
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
* Unmerged path drivers/scsi/fnic/fnic_stats.h
* Unmerged path drivers/scsi/fnic/fnic_trace.c
