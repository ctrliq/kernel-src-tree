scsi: fnic: Modify IO path to use FDLS

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 6335be1c5009f888367db095a0442cdb256980f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/6335be1c.failed

Modify IO path to use FDLS.

Add helper functions to process IOs.

Remove unused template functions.

Clean up obsolete code.

Refactor old function definitions.

	Reported-by: kernel test robot <lkp@intel.com>
Closes: https://lore.kernel.org/oe-kbuild-all/202410210147.fQp7tYeb-lkp@intel.com/

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Reviewed-by: Gian Carlo Boffa <gcboffa@cisco.com>
	Reviewed-by: Arun Easi <aeasi@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20241212020312.4786-11-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6335be1c5009f888367db095a0442cdb256980f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic.h
#	drivers/scsi/fnic/fnic_main.c
#	drivers/scsi/fnic/fnic_scsi.c
diff --cc drivers/scsi/fnic/fnic.h
index 73fb8245c7b7,1cfd9dcb5444..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -348,11 -479,14 +348,10 @@@ int fnic_set_intr_mode_msix(struct fni
  void fnic_free_intr(struct fnic *fnic);
  int fnic_request_intr(struct fnic *fnic);
  
- int fnic_send(struct fc_lport *, struct fc_frame *);
  void fnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf);
  void fnic_handle_frame(struct work_struct *work);
 -void fnic_tport_event_handler(struct work_struct *work);
  void fnic_handle_link(struct work_struct *work);
  void fnic_handle_event(struct work_struct *work);
 -void fdls_reclaim_oxid_handler(struct work_struct *work);
 -void fdls_schedule_oxid_free(struct fnic_iport_s *iport, uint16_t *active_oxid);
 -void fdls_schedule_oxid_free_retry_work(struct work_struct *work);
  int fnic_rq_cmpl_handler(struct fnic *fnic, int);
  int fnic_alloc_rq_frame(struct vnic_rq *rq);
  void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf);
@@@ -365,12 -496,11 +364,20 @@@ void fnic_update_mac_locked(struct fni
  int fnic_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
  int fnic_abort_cmd(struct scsi_cmnd *);
  int fnic_device_reset(struct scsi_cmnd *);
++<<<<<<< HEAD
 +int fnic_host_reset(struct scsi_cmnd *);
 +int fnic_reset(struct Scsi_Host *);
 +void fnic_scsi_cleanup(struct fc_lport *);
 +void fnic_scsi_abort_io(struct fc_lport *);
 +void fnic_empty_scsi_cleanup(struct fc_lport *);
 +void fnic_exch_mgr_reset(struct fc_lport *, u32, u32);
++=======
+ int fnic_eh_host_reset_handler(struct scsi_cmnd *sc);
+ int fnic_host_reset(struct Scsi_Host *shost);
+ void fnic_reset(struct Scsi_Host *shost);
+ int fnic_issue_fc_host_lip(struct Scsi_Host *shost);
+ void fnic_scsi_fcpio_reset(struct fnic *fnic);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  int fnic_wq_copy_cmpl_handler(struct fnic *fnic, int copy_work_to_do, unsigned int cq_index);
  int fnic_wq_cmpl_handler(struct fnic *fnic, int);
  int fnic_flogi_reg_handler(struct fnic *fnic, u32);
@@@ -379,10 -509,11 +386,11 @@@ void fnic_wq_copy_cleanup_handler(struc
  int fnic_fw_reset_handler(struct fnic *fnic);
  void fnic_terminate_rport_io(struct fc_rport *);
  const char *fnic_state_to_str(unsigned int state);
 -void fnic_mq_map_queues_cpus(struct Scsi_Host *host);
 +
  void fnic_log_q_error(struct fnic *fnic);
  void fnic_handle_link_event(struct fnic *fnic);
- 
+ void fnic_stats_debugfs_init(struct fnic *fnic);
+ void fnic_stats_debugfs_remove(struct fnic *fnic);
  int fnic_is_abts_pending(struct fnic *, struct scsi_cmnd *);
  
  void fnic_handle_fip_frame(struct work_struct *work);
@@@ -398,4 -528,86 +406,89 @@@ fnic_chk_state_flags_locked(struct fni
  }
  void __fnic_set_state_flags(struct fnic *, unsigned long, unsigned long);
  void fnic_dump_fchost_stats(struct Scsi_Host *, struct fc_host_statistics *);
++<<<<<<< HEAD
++=======
+ void fnic_free_txq(struct list_head *head);
+ int fnic_get_desc_by_devid(struct pci_dev *pdev, char **desc,
+ 						   char **subsys_desc);
+ void fnic_fdls_link_status_change(struct fnic *fnic, int linkup);
+ void fnic_delete_fcp_tports(struct fnic *fnic);
+ void fnic_flush_tport_event_list(struct fnic *fnic);
+ int fnic_count_ioreqs_wq(struct fnic *fnic, u32 hwq, u32 portid);
+ unsigned int fnic_count_ioreqs(struct fnic *fnic, u32 portid);
+ unsigned int fnic_count_all_ioreqs(struct fnic *fnic);
+ unsigned int fnic_count_lun_ioreqs_wq(struct fnic *fnic, u32 hwq,
+ 						  struct scsi_device *device);
+ unsigned int fnic_count_lun_ioreqs(struct fnic *fnic,
+ 					   struct scsi_device *device);
+ 
+ struct fnic_scsi_iter_data {
+ 	struct fnic *fnic;
+ 	void *data1;
+ 	void *data2;
+ 	bool (*fn)(struct fnic *fnic, struct scsi_cmnd *sc,
+ 			void *data1, void *data2);
+ };
+ 
+ static inline bool
+ fnic_io_iter_handler(struct scsi_cmnd *sc, void *iter_data)
+ {
+ 	struct fnic_scsi_iter_data *iter = iter_data;
+ 
+ 	return iter->fn(iter->fnic, sc, iter->data1, iter->data2);
+ }
+ 
+ static inline void
+ fnic_scsi_io_iter(struct fnic *fnic,
+ 		bool (*fn)(struct fnic *fnic, struct scsi_cmnd *sc,
+ 				void *data1, void *data2),
+ 		void *data1, void *data2)
+ {
+ 	struct fnic_scsi_iter_data iter_data = {
+ 		.fn = fn,
+ 		.fnic = fnic,
+ 		.data1 = data1,
+ 		.data2 = data2,
+ 	};
+ 	scsi_host_busy_iter(fnic->lport->host, fnic_io_iter_handler, &iter_data);
+ }
+ 
+ #ifdef FNIC_DEBUG
+ static inline void
+ fnic_debug_dump(struct fnic *fnic, uint8_t *u8arr, int len)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < len; i = i+8) {
+ 		FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		    "%d: %02x %02x %02x %02x %02x %02x %02x %02x", i / 8,
+ 		    u8arr[i + 0], u8arr[i + 1], u8arr[i + 2], u8arr[i + 3],
+ 		    u8arr[i + 4], u8arr[i + 5], u8arr[i + 6], u8arr[i + 7]);
+ 	}
+ }
+ 
+ static inline void
+ fnic_debug_dump_fc_frame(struct fnic *fnic, struct fc_frame_header *fchdr,
+ 				int len, char *pfx)
+ {
+ 	uint32_t s_id, d_id;
+ 
+ 	s_id = ntoh24(fchdr->fh_s_id);
+ 	d_id = ntoh24(fchdr->fh_d_id);
+ 	FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		"%s packet contents: sid/did/type/oxid = 0x%x/0x%x/0x%x/0x%x (len = %d)\n",
+ 		pfx, s_id, d_id, fchdr->fh_type,
+ 		FNIC_STD_GET_OX_ID(fchdr), len);
+ 
+ 	fnic_debug_dump(fnic, (uint8_t *)fchdr, len);
+ 
+ }
+ #else /* FNIC_DEBUG */
+ static inline void
+ fnic_debug_dump(struct fnic *fnic, uint8_t *u8arr, int len) {}
+ static inline void
+ fnic_debug_dump_fc_frame(struct fnic *fnic, struct fc_frame_header *fchdr,
+ 				uint32_t len, char *pfx) {}
+ #endif /* FNIC_DEBUG */
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  #endif /* _FNIC_H_ */
diff --cc drivers/scsi/fnic/fnic_main.c
index 06fd7b543b33,a6c2cb49465b..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -89,13 -85,7 +89,17 @@@ static unsigned int fnic_max_qdepth = F
  module_param(fnic_max_qdepth, uint, S_IRUGO|S_IWUSR);
  MODULE_PARM_DESC(fnic_max_qdepth, "Queue depth to report for each LUN");
  
++<<<<<<< HEAD
 +static struct libfc_function_template fnic_transport_template = {
 +	.frame_send = fnic_send,
 +	.lport_set_port_id = fnic_set_port_id,
 +	.fcp_abort_io = fnic_empty_scsi_cleanup,
 +	.fcp_cleanup = fnic_empty_scsi_cleanup,
 +	.exch_mgr_reset = fnic_exch_mgr_reset
 +};
++=======
+ struct workqueue_struct *fnic_fip_queue;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  static int fnic_slave_alloc(struct scsi_device *sdev)
  {
diff --cc drivers/scsi/fnic/fnic_scsi.c
index 321954ca143f,a38672ac224e..000000000000
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@@ -102,22 -105,6 +117,25 @@@ static const char *fnic_fcpio_status_to
  	return fcpio_status_str[status];
  }
  
++<<<<<<< HEAD
 +static void fnic_cleanup_io(struct fnic *fnic);
 +
 +static inline spinlock_t *fnic_io_lock_hash(struct fnic *fnic,
 +					    struct scsi_cmnd *sc)
 +{
 +	u32 hash = scsi_cmd_to_rq(sc)->tag & (FNIC_IO_LOCKS - 1);
 +
 +	return &fnic->io_req_lock[hash];
 +}
 +
 +static inline spinlock_t *fnic_io_lock_tag(struct fnic *fnic,
 +					    int tag)
 +{
 +	return &fnic->io_req_lock[tag & (FNIC_IO_LOCKS - 1)];
 +}
 +
++=======
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  /*
   * Unmap the data buffer and sense buffer for an io_req,
   * also unmap and free the device-private scatter/gather list.
@@@ -140,11 -127,70 +158,70 @@@ static void fnic_release_ioreq_buf(stru
  				 SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
  }
  
+ static bool
+ fnic_count_portid_ioreqs_iter(struct fnic *fnic, struct scsi_cmnd *sc,
+ 				void *data1, void *data2)
+ {
+ 	u32 *portid = data1;
+ 	unsigned int *count = data2;
+ 	struct fnic_io_req *io_req = fnic_priv(sc)->io_req;
+ 
+ 	if (!io_req || (*portid && (io_req->port_id != *portid)))
+ 		return true;
+ 
+ 	*count += 1;
+ 	return true;
+ }
+ 
+ unsigned int fnic_count_ioreqs(struct fnic *fnic, u32 portid)
+ {
+ 	unsigned int count = 0;
+ 
+ 	fnic_scsi_io_iter(fnic, fnic_count_portid_ioreqs_iter,
+ 				&portid, &count);
+ 
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		      "portid = 0x%x count = %u\n", portid, count);
+ 	return count;
+ }
+ 
+ unsigned int fnic_count_all_ioreqs(struct fnic *fnic)
+ {
+ 	return fnic_count_ioreqs(fnic, 0);
+ }
+ 
+ static bool
+ fnic_count_lun_ioreqs_iter(struct fnic *fnic, struct scsi_cmnd *sc,
+ 				void *data1, void *data2)
+ {
+ 	struct scsi_device *scsi_device = data1;
+ 	unsigned int *count = data2;
+ 
+ 	if (sc->device != scsi_device || !fnic_priv(sc)->io_req)
+ 		return true;
+ 
+ 	*count += 1;
+ 	return true;
+ }
+ 
+ unsigned int
+ fnic_count_lun_ioreqs(struct fnic *fnic, struct scsi_device *scsi_device)
+ {
+ 	unsigned int count = 0;
+ 
+ 	fnic_scsi_io_iter(fnic, fnic_count_lun_ioreqs_iter,
+ 				scsi_device, &count);
+ 
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		      "lun = %p count = %u\n", scsi_device, count);
+ 	return count;
+ }
+ 
  /* Free up Copy Wq descriptors. Called with copy_wq lock held */
 -static int free_wq_copy_descs(struct fnic *fnic, struct vnic_wq_copy *wq, unsigned int hwq)
 +static int free_wq_copy_descs(struct fnic *fnic, struct vnic_wq_copy *wq)
  {
  	/* if no Ack received from firmware, then nothing to clean */
 -	if (!fnic->fw_ack_recd[hwq])
 +	if (!fnic->fw_ack_recd[0])
  		return 1;
  
  	/*
@@@ -211,9 -255,7 +289,13 @@@ int fnic_fw_reset_handler(struct fnic *
  
  	/* indicate fwreset to io path */
  	fnic_set_state_flags(fnic, FNIC_FLAGS_FWRESET);
++<<<<<<< HEAD
 +
 +	skb_queue_purge(&fnic->frame_queue);
 +	skb_queue_purge(&fnic->tx_queue);
++=======
+ 	ioreq_count = fnic_count_all_ioreqs(fnic);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	/* wait for io cmpl */
  	while (atomic_read(&fnic->in_flight))
@@@ -275,28 -319,23 +359,37 @@@ int fnic_flogi_reg_handler(struct fnic 
  		goto flogi_reg_ioreq_end;
  	}
  
- 	if (fnic->ctlr.map_dest) {
- 		eth_broadcast_addr(gw_mac);
- 		format = FCPIO_FLOGI_REG_DEF_DEST;
- 	} else {
- 		memcpy(gw_mac, fnic->ctlr.dest_addr, ETH_ALEN);
- 		format = FCPIO_FLOGI_REG_GW_DEST;
- 	}
+ 	memcpy(gw_mac, fnic->iport.fcfmac, ETH_ALEN);
+ 	format = FCPIO_FLOGI_REG_GW_DEST;
  
- 	if ((fnic->config.flags & VFCF_FIP_CAPABLE) && !fnic->ctlr.map_dest) {
+ 	if (fnic->config.flags & VFCF_FIP_CAPABLE) {
  		fnic_queue_wq_copy_desc_fip_reg(wq, SCSI_NO_TAG,
  						fc_id, gw_mac,
++<<<<<<< HEAD
 +						fnic->data_src_addr,
 +						lp->r_a_tov, lp->e_d_tov);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "FLOGI FIP reg issued fcid %x src %pM dest %pM\n",
 +			      fc_id, fnic->data_src_addr, gw_mac);
 +	} else {
 +		fnic_queue_wq_copy_desc_flogi_reg(wq, SCSI_NO_TAG,
 +						  format, fc_id, gw_mac);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "FLOGI reg issued fcid %x map %d dest %pM\n",
 +			      fc_id, fnic->ctlr.map_dest, gw_mac);
++=======
+ 						fnic->iport.fpma,
+ 						iport->r_a_tov, iport->e_d_tov);
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			      "FLOGI FIP reg issued fcid: 0x%x src %p dest %p\n",
+ 				  fc_id, fnic->iport.fpma, gw_mac);
+ 	} else {
+ 		fnic_queue_wq_copy_desc_flogi_reg(wq, SCSI_NO_TAG,
+ 						  format, fc_id, gw_mac);
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 			"FLOGI reg issued fcid 0x%x dest %p\n",
+ 			fc_id, gw_mac);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	}
  
  	atomic64_inc(&fnic->fnic_stats.fw_stats.active_fw_reqs);
@@@ -387,10 -428,10 +484,10 @@@ static inline int fnic_queue_wq_copy_de
  
  	exch_flags = 0;
  	if ((fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR) &&
- 	    (rp->flags & FC_RP_FLAGS_RETRY))
+ 		(tport->tgt_flags & FDLS_FC_RP_FLAGS_RETRY))
  		exch_flags |= FCPIO_ICMND_SRFLAG_RETRY;
  
 -	fnic_queue_wq_copy_desc_icmnd_16(wq, mqtag,
 +	fnic_queue_wq_copy_desc_icmnd_16(wq, scsi_cmd_to_rq(sc)->tag,
  					 0, exch_flags, io_req->sgl_cnt,
  					 SCSI_SENSE_BUFFERSIZE,
  					 io_req->sgl_list_pa,
@@@ -415,38 -455,31 +512,56 @@@
  	return 0;
  }
  
 -int fnic_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *sc)
 +/*
 + * fnic_queuecommand
 + * Routine to send a scsi cdb
 + * Called with host_lock held and interrupts disabled.
 + */
 +static int fnic_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
  {
++<<<<<<< HEAD
 +	const int tag = scsi_cmd_to_rq(sc)->tag;
 +	struct fc_lport *lp = shost_priv(sc->device->host);
++=======
+ 	struct request *const rq = scsi_cmd_to_rq(sc);
+ 	uint32_t mqtag = 0;
+ 	void (*done)(struct scsi_cmnd *) = scsi_done;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	struct fc_rport *rport;
  	struct fnic_io_req *io_req = NULL;
- 	struct fnic *fnic = lport_priv(lp);
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(sc->device->host));
+ 	struct fnic_iport_s *iport = NULL;
  	struct fnic_stats *fnic_stats = &fnic->fnic_stats;
  	struct vnic_wq_copy *wq;
 -	int ret = 1;
 +	int ret;
  	u64 cmd_trace;
  	int sg_count = 0;
  	unsigned long flags = 0;
  	unsigned long ptr;
 +	spinlock_t *io_lock = NULL;
  	int io_lock_acquired = 0;
++<<<<<<< HEAD
 +	struct fc_rport_libfc_priv *rp;
 +
 +	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_IO_BLOCKED)))
 +		return SCSI_MLQUEUE_HOST_BUSY;
 +
 +	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_FWRESET)))
 +		return SCSI_MLQUEUE_HOST_BUSY;
 +
 +	rport = starget_to_rport(scsi_target(sc->device));
 +	if (!rport) {
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 	uint16_t hwq = 0;
+ 	struct fnic_tport_s *tport = NULL;
+ 	struct rport_dd_data_s *rdd_data;
+ 	uint16_t lun0_delay = 0;
+ 
+ 	rport = starget_to_rport(scsi_target(sc->device));
+ 	if (!rport) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  				"returning DID_NO_CONNECT for IO as rport is NULL\n");
  		sc->result = DID_NO_CONNECT << 16;
  		done(sc);
@@@ -455,49 -488,97 +570,138 @@@
  
  	ret = fc_remote_port_chkready(rport);
  	if (ret) {
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  				"rport is not ready\n");
- 		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
  		sc->result = ret;
  		done(sc);
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	rp = rport->dd_data;
 +	if (!rp || rp->rp_state == RPORT_ST_DELETE) {
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			"rport 0x%x removed, returning DID_NO_CONNECT\n",
 +			rport->port_id);
 +
 +		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
 +		sc->result = DID_NO_CONNECT<<16;
++=======
+ 	mqtag = blk_mq_unique_tag(rq);
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	iport = &fnic->iport;
+ 
+ 	if (iport->state != FNIC_IPORT_STATE_READY) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "returning DID_NO_CONNECT for IO as iport state: %d\n",
+ 					  iport->state);
+ 		sc->result = DID_NO_CONNECT << 16;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		done(sc);
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (rp->rp_state != RPORT_ST_READY) {
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			"rport 0x%x in state 0x%x, returning DID_IMM_RETRY\n",
 +			rport->port_id, rp->rp_state);
 +
 +		sc->result = DID_IMM_RETRY << 16;
 +		done(sc);
 +		return 0;
 +	}
 +
 +	if (lp->state != LPORT_ST_READY || !(lp->link_up))
 +		return SCSI_MLQUEUE_HOST_BUSY;
++=======
+ 	/* fc_remote_port_add() may have added the tport to
+ 	 * fc_transport but dd_data not yet set
+ 	 */
+ 	rdd_data = rport->dd_data;
+ 	tport = rdd_data->tport;
+ 	if (!tport || (rdd_data->iport != iport)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "dd_data not yet set in SCSI for rport portid: 0x%x\n",
+ 					  rport->port_id);
+ 		tport = fnic_find_tport_by_fcid(iport, rport->port_id);
+ 		if (!tport) {
+ 			spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 			FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 						  "returning DID_BUS_BUSY for IO as tport not found for: 0x%x\n",
+ 						  rport->port_id);
+ 			sc->result = DID_BUS_BUSY << 16;
+ 			done(sc);
+ 			return 0;
+ 		}
+ 
+ 		/* Re-assign same params as in fnic_fdls_add_tport */
+ 		rport->maxframe_size = FNIC_FC_MAX_PAYLOAD_LEN;
+ 		rport->supported_classes =
+ 			FC_COS_CLASS3 | FC_RPORT_ROLE_FCP_TARGET;
+ 		/* the dd_data is allocated by fctransport of size dd_fcrport_size */
+ 		rdd_data = rport->dd_data;
+ 		rdd_data->tport = tport;
+ 		rdd_data->iport = iport;
+ 		tport->rport = rport;
+ 		tport->flags |= FNIC_FDLS_SCSI_REGISTERED;
+ 	}
+ 
+ 	if ((tport->state != FDLS_TGT_STATE_READY)
+ 		&& (tport->state != FDLS_TGT_STATE_ADISC)) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "returning DID_NO_CONNECT for IO as tport state: %d\n",
+ 					  tport->state);
+ 		sc->result = DID_NO_CONNECT << 16;
+ 		done(sc);
+ 		return 0;
+ 	}
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	atomic_inc(&fnic->in_flight);
+ 	atomic_inc(&tport->in_flight);
  
+ 	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_IO_BLOCKED))) {
+ 		atomic_dec(&fnic->in_flight);
+ 		atomic_dec(&tport->in_flight);
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		return SCSI_MLQUEUE_HOST_BUSY;
+ 	}
+ 
+ 	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_FWRESET))) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 		  "fnic flags FW reset: 0x%lx. Returning SCSI_MLQUEUE_HOST_BUSY\n",
+ 		  fnic->state_flags);
+ 		return SCSI_MLQUEUE_HOST_BUSY;
+ 	}
+ 
+ 	if (!tport->lun0_delay) {
+ 		lun0_delay = 1;
+ 		tport->lun0_delay++;
+ 	}
+ 
++<<<<<<< HEAD
 +	/*
 +	 * Release host lock, use driver resource specific locks from here.
 +	 * Don't re-enable interrupts in case they were disabled prior to the
 +	 * caller disabling them.
 +	 */
 +	spin_unlock(lp->host->host_lock);
 +	CMD_STATE(sc) = FNIC_IOREQ_NOT_INITED;
 +	CMD_FLAGS(sc) = FNIC_NO_FLAGS;
++=======
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
+ 	fnic_priv(sc)->state = FNIC_IOREQ_NOT_INITED;
+ 	fnic_priv(sc)->flags = FNIC_NO_FLAGS;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	/* Get a new io_req for this SCSI IO */
  	io_req = mempool_alloc(fnic->io_req_pool, GFP_ATOMIC);
@@@ -582,8 -675,7 +787,12 @@@
  			mempool_free(io_req, fnic->io_req_pool);
  		}
  		atomic_dec(&fnic->in_flight);
++<<<<<<< HEAD
 +		/* acquire host lock before returning to SCSI */
 +		spin_lock(lp->host->host_lock);
++=======
+ 		atomic_dec(&tport->in_flight);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		return ret;
  	} else {
  		atomic64_inc(&fnic_stats->io_stats.active_ios);
@@@ -608,11 -700,17 +817,22 @@@ out
  
  	/* if only we issued IO, will we have the io lock */
  	if (io_lock_acquired)
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(io_lock, flags);
  
  	atomic_dec(&fnic->in_flight);
++<<<<<<< HEAD
 +	/* acquire host lock before returning to SCSI */
 +	spin_lock(lp->host->host_lock);
++=======
+ 	atomic_dec(&tport->in_flight);
+ 
+ 	if (lun0_delay) {
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "LUN0 delay\n");
+ 		mdelay(LUN0_DELAY_TIME);
+ 	}
+ 
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	return ret;
  }
  
@@@ -654,17 -751,10 +874,11 @@@ static int fnic_fcpio_fw_reset_cmpl_han
  			/* Ready to send flogi out */
  			fnic->state = FNIC_IN_ETH_MODE;
  		} else {
 -			FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
 -				"reset failed with header status: %s\n",
 -				fnic_fcpio_status_to_str(hdr_status));
 +			FNIC_SCSI_DBG(KERN_DEBUG,
 +				      fnic->lport->host,
 +				      "fnic fw_reset : failed %s\n",
 +				      fnic_fcpio_status_to_str(hdr_status));
  
- 			/*
- 			 * Unable to change to eth mode, cannot send out flogi
- 			 * Change state to fc mode, so that subsequent Flogi
- 			 * requests from libFC will cause more attempts to
- 			 * reset the firmware. Free the cached flogi
- 			 */
  			fnic->state = FNIC_IN_FC_MODE;
  			atomic64_inc(&reset_stats->fw_reset_failures);
  			ret = -1;
@@@ -686,9 -774,9 +899,9 @@@
  	 * If fnic is being removed, or fw reset failed
  	 * free the flogi frame. Else, send it out
  	 */
- 	if (fnic->remove_wait || ret) {
+ 	if (ret) {
  		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 -		fnic_free_txq(&fnic->tx_queue);
 +		skb_queue_purge(&fnic->tx_queue);
  		goto reset_cmpl_handler_end;
  	}
  
@@@ -724,13 -812,13 +937,23 @@@ static int fnic_fcpio_flogi_reg_cmpl_ha
  
  		/* Check flogi registration completion status */
  		if (!hdr_status) {
++<<<<<<< HEAD
 +			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				      "flog reg succeeded\n");
 +			fnic->state = FNIC_IN_FC_MODE;
 +		} else {
 +			FNIC_SCSI_DBG(KERN_DEBUG,
 +				      fnic->lport->host,
 +				      "fnic flogi reg :failed %s\n",
++=======
+ 			FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 				      "FLOGI reg succeeded\n");
+ 			fnic->state = FNIC_IN_FC_MODE;
+ 		} else {
+ 			FNIC_SCSI_DBG(KERN_DEBUG,
+ 				      fnic->lport->host, fnic->fnic_num,
+ 				      "fnic flogi reg failed: %s\n",
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  				      fnic_fcpio_status_to_str(hdr_status));
  			fnic->state = FNIC_IN_ETH_MODE;
  			ret = -1;
@@@ -1005,22 -1126,10 +1231,13 @@@ static void fnic_fcpio_icmnd_cmpl_handl
  		  ((u64)icmnd_cmpl->_resvd0[1] << 56 |
  		  (u64)icmnd_cmpl->_resvd0[0] << 48 |
  		  jiffies_to_msecs(jiffies - start_time)),
 -		  desc, cmd_trace, fnic_flags_and_state(sc));
 +		  desc, cmd_trace,
 +		  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
  
- 	if (sc->sc_data_direction == DMA_FROM_DEVICE) {
- 		fnic->lport->host_stats.fcp_input_requests++;
- 		fnic->fcp_input_bytes += xfer_len;
- 	} else if (sc->sc_data_direction == DMA_TO_DEVICE) {
- 		fnic->lport->host_stats.fcp_output_requests++;
- 		fnic->fcp_output_bytes += xfer_len;
- 	} else
- 		fnic->lport->host_stats.fcp_control_requests++;
- 
  	/* Call SCSI completion function to complete the IO */
 -	scsi_done(sc);
 +	if (sc->scsi_done)
 +		sc->scsi_done(sc);
 +	spin_unlock_irqrestore(io_lock, flags);
  
  	mempool_free(io_req, fnic->io_req_pool);
  
@@@ -1351,20 -1507,35 +1568,42 @@@ int fnic_wq_copy_cmpl_handler(struct fn
  
  static bool fnic_cleanup_io_iter(struct scsi_cmnd *sc, void *data)
  {
 -	struct request *const rq = scsi_cmd_to_rq(sc);
 +	const int tag = scsi_cmd_to_rq(sc)->tag;
  	struct fnic *fnic = data;
  	struct fnic_io_req *io_req;
++<<<<<<< HEAD
 +	unsigned long flags = 0;
 +	spinlock_t *io_lock;
++=======
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	unsigned long start_time = 0;
+ 	unsigned long flags;
  	struct fnic_stats *fnic_stats = &fnic->fnic_stats;
 -	uint16_t hwq = 0;
 -	int tag;
 -	int mqtag;
  
 -	mqtag = blk_mq_unique_tag(rq);
 -	hwq = blk_mq_unique_tag_to_hwq(mqtag);
 -	tag = blk_mq_unique_tag_to_tag(mqtag);
 +	io_lock = fnic_io_lock_tag(fnic, tag);
 +	spin_lock_irqsave(io_lock, flags);
  
++<<<<<<< HEAD
 +	io_req = (struct fnic_io_req *)CMD_SP(sc);
 +	if ((CMD_FLAGS(sc) & FNIC_DEVICE_RESET) &&
 +	    !(CMD_FLAGS(sc) & FNIC_DEV_RST_DONE)) {
++=======
+ 	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 
+ 	fnic->sw_copy_wq[hwq].io_req_table[tag] = NULL;
+ 
+ 	io_req = fnic_priv(sc)->io_req;
+ 	if (!io_req) {
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			"hwq: %d mqtag: 0x%x tag: 0x%x flags: 0x%x No ioreq. Returning\n",
+ 			hwq, mqtag, tag, fnic_priv(sc)->flags);
+ 		return true;
+ 	}
+ 
+ 	if ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&
+ 		!(fnic_priv(sc)->flags & FNIC_DEV_RST_DONE)) {
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		/*
  		 * We will be here only when FW completes reset
  		 * without sending completions for outstanding ios.
@@@ -1374,20 -1545,18 +1613,32 @@@
  			complete(io_req->dr_done);
  		else if (io_req && io_req->abts_done)
  			complete(io_req->abts_done);
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(io_lock, flags);
++=======
+ 
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		return true;
 -	} else if (fnic_priv(sc)->flags & FNIC_DEVICE_RESET) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	} else if (CMD_FLAGS(sc) & FNIC_DEVICE_RESET) {
 +		spin_unlock_irqrestore(io_lock, flags);
  		return true;
  	}
 +	if (!io_req) {
 +		spin_unlock_irqrestore(io_lock, flags);
 +		goto cleanup_scsi_cmd;
 +	}
 +
++<<<<<<< HEAD
 +	CMD_SP(sc) = NULL;
  
 +	spin_unlock_irqrestore(io_lock, flags);
++=======
+ 	fnic_priv(sc)->io_req = NULL;
+ 	io_req->sc = NULL;
+ 	start_time = io_req->start_time;
+ 	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	/*
  	 * If there is a scsi_cmnd associated with this io_req, then
@@@ -1396,36 -1565,28 +1647,56 @@@
  	fnic_release_ioreq_buf(fnic, io_req, sc);
  	mempool_free(io_req, fnic->io_req_pool);
  
 +cleanup_scsi_cmd:
  	sc->result = DID_TRANSPORT_DISRUPTED << 16;
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "fnic_cleanup_io: tag:0x%x : sc:0x%p duration = %lu DID_TRANSPORT_DISRUPTED\n",
 +		      tag, sc, jiffies - start_time);
++=======
+ 	FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 	"mqtag: 0x%x tag: 0x%x sc: 0x%p duration = %lu DID_TRANSPORT_DISRUPTED\n",
+ 		mqtag, tag, sc, (jiffies - start_time));
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	if (atomic64_read(&fnic->io_cmpl_skip))
  		atomic64_dec(&fnic->io_cmpl_skip);
  	else
  		atomic64_inc(&fnic_stats->io_stats.io_completions);
  
++<<<<<<< HEAD
 +	/* Complete the command to SCSI */
 +	if (sc->scsi_done) {
 +		if (!(CMD_FLAGS(sc) & FNIC_IO_ISSUED))
 +			shost_printk(KERN_ERR, fnic->lport->host,
 +				     "Calling done for IO not issued to fw: tag:0x%x sc:0x%p\n",
 +				     tag, sc);
 +
 +		FNIC_TRACE(fnic_cleanup_io,
 +			   sc->device->host->host_no, tag, sc,
 +			   jiffies_to_msecs(jiffies - start_time),
 +			   0, ((u64)sc->cmnd[0] << 32 |
 +			       (u64)sc->cmnd[2] << 24 |
 +			       (u64)sc->cmnd[3] << 16 |
 +			       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 +			   (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
 +
 +		sc->scsi_done(sc);
 +	}
++=======
+ 	FNIC_TRACE(fnic_cleanup_io,
+ 			   sc->device->host->host_no, tag, sc,
+ 			   jiffies_to_msecs(jiffies - start_time),
+ 			   0, ((u64) sc->cmnd[0] << 32 |
+ 				   (u64) sc->cmnd[2] << 24 |
+ 				   (u64) sc->cmnd[3] << 16 |
+ 				   (u64) sc->cmnd[4] << 8 | sc->cmnd[5]),
+ 			   (((u64) fnic_priv(sc)->flags << 32) | fnic_priv(sc)->
+ 				state));
+ 
+ 	/* Complete the command to SCSI */
+ 	scsi_done(sc);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	return true;
  }
  
@@@ -1498,31 -1695,35 +1805,43 @@@ wq_copy_cleanup_scsi_cmd
  
  static inline int fnic_queue_abort_io_req(struct fnic *fnic, int tag,
  					  u32 task_req, u8 *fc_lun,
 -					  struct fnic_io_req *io_req,
 -					  unsigned int hwq)
 +					  struct fnic_io_req *io_req)
  {
 -	struct vnic_wq_copy *wq = &fnic->hw_copy_wq[hwq];
 +	struct vnic_wq_copy *wq = &fnic->hw_copy_wq[0];
 +	struct Scsi_Host *host = fnic->lport->host;
  	struct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;
  	unsigned long flags;
+ 	struct fnic_tport_s *tport = io_req->tport;
  
 -	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	spin_lock_irqsave(host->host_lock, flags);
  	if (unlikely(fnic_chk_state_flags_locked(fnic,
  						FNIC_FLAGS_IO_BLOCKED))) {
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(host->host_lock, flags);
++=======
+ 		atomic_dec(&fnic->in_flight);
+ 		atomic_dec(&tport->in_flight);
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		return 1;
  	} else
  		atomic_inc(&fnic->in_flight);
 -	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +	spin_unlock_irqrestore(host->host_lock, flags);
  
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 +	spin_lock_irqsave(&fnic->wq_copy_lock[0], flags);
  
 -	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[hwq])
 -		free_wq_copy_descs(fnic, wq, hwq);
 +	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])
 +		free_wq_copy_descs(fnic, wq);
  
  	if (!vnic_wq_copy_desc_avail(wq)) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);
  		atomic_dec(&fnic->in_flight);
++<<<<<<< HEAD
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 		atomic_dec(&tport->in_flight);
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  			"fnic_queue_abort_io_req: failure: no descriptors\n");
  		atomic64_inc(&misc_stats->abts_cpwq_alloc_failures);
  		return 1;
@@@ -1551,24 -1752,31 +1870,43 @@@ struct fnic_rport_abort_io_iter_data 
  
  static bool fnic_rport_abort_io_iter(struct scsi_cmnd *sc, void *data)
  {
 -	struct request *const rq = scsi_cmd_to_rq(sc);
  	struct fnic_rport_abort_io_iter_data *iter_data = data;
  	struct fnic *fnic = iter_data->fnic;
 -	int abt_tag = 0;
 +	int abt_tag = scsi_cmd_to_rq(sc)->tag;
  	struct fnic_io_req *io_req;
++<<<<<<< HEAD
 +	spinlock_t *io_lock;
 +	unsigned long flags;
++=======
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	struct reset_stats *reset_stats = &fnic->fnic_stats.reset_stats;
  	struct terminate_stats *term_stats = &fnic->fnic_stats.term_stats;
  	struct scsi_lun fc_lun;
  	enum fnic_ioreq_state old_ioreq_state;
++<<<<<<< HEAD
++=======
+ 	uint16_t hwq = 0;
+ 	unsigned long flags;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
 -	abt_tag = blk_mq_unique_tag(rq);
 -	hwq = blk_mq_unique_tag_to_hwq(abt_tag);
 +	io_lock = fnic_io_lock_tag(fnic, abt_tag);
 +	spin_lock_irqsave(io_lock, flags);
  
++<<<<<<< HEAD
 +	io_req = (struct fnic_io_req *)CMD_SP(sc);
 +
++=======
+ 	if (!sc) {
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 					  "sc is NULL abt_tag: 0x%x hwq: %d\n", abt_tag, hwq);
+ 		return true;
+ 	}
+ 
+ 	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 	io_req = fnic_priv(sc)->io_req;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	if (!io_req || io_req->port_id != iter_data->port_id) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(io_lock, flags);
  		return true;
  	}
  
@@@ -1585,41 -1793,42 +1923,68 @@@
  	 * Found IO that is still pending with firmware and
  	 * belongs to rport that went away
  	 */
 -	if (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	if (CMD_STATE(sc) == FNIC_IOREQ_ABTS_PENDING) {
 +		spin_unlock_irqrestore(io_lock, flags);
  		return true;
  	}
+ 
  	if (io_req->abts_done) {
  		shost_printk(KERN_ERR, fnic->lport->host,
++<<<<<<< HEAD
 +			"fnic_rport_exch_reset: io_req->abts_done is set "
 +			"state is %s\n",
 +			fnic_ioreq_state_to_str(CMD_STATE(sc)));
++=======
+ 			"fnic_rport_exch_reset: io_req->abts_done is set state is %s\n",
+ 			fnic_ioreq_state_to_str(fnic_priv(sc)->state));
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	}
  
 -	if (!(fnic_priv(sc)->flags & FNIC_IO_ISSUED)) {
 +	if (!(CMD_FLAGS(sc) & FNIC_IO_ISSUED)) {
  		shost_printk(KERN_ERR, fnic->lport->host,
++<<<<<<< HEAD
 +			     "rport_exch_reset "
 +			     "IO not yet issued %p tag 0x%x flags "
 +			     "%x state %d\n",
 +			     sc, abt_tag, CMD_FLAGS(sc), CMD_STATE(sc));
 +	}
 +	old_ioreq_state = CMD_STATE(sc);
 +	CMD_STATE(sc) = FNIC_IOREQ_ABTS_PENDING;
 +	CMD_ABTS_STATUS(sc) = FCPIO_INVALID_CODE;
 +	if (CMD_FLAGS(sc) & FNIC_DEVICE_RESET) {
 +		atomic64_inc(&reset_stats->device_reset_terminates);
 +		abt_tag |= FNIC_TAG_DEV_RST;
 +	}
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "fnic_rport_exch_reset dev rst sc 0x%p\n", sc);
 +	BUG_ON(io_req->abts_done);
 +
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 			"rport_exch_reset IO not yet issued %p abt_tag 0x%x",
+ 			sc, abt_tag);
+ 		shost_printk(KERN_ERR, fnic->lport->host,
+ 			"flags %x state %d\n", fnic_priv(sc)->flags,
+ 			fnic_priv(sc)->state);
+ 	}
+ 	old_ioreq_state = fnic_priv(sc)->state;
+ 	fnic_priv(sc)->state = FNIC_IOREQ_ABTS_PENDING;
+ 	fnic_priv(sc)->abts_status = FCPIO_INVALID_CODE;
+ 
+ 	if (fnic_priv(sc)->flags & FNIC_DEVICE_RESET) {
+ 		atomic64_inc(&reset_stats->device_reset_terminates);
+ 		abt_tag |= FNIC_TAG_DEV_RST;
+ 	}
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		      "fnic_rport_exch_reset: dev rst sc 0x%p\n", sc);
+ 	WARN_ON_ONCE(io_req->abts_done);
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		      "fnic_rport_reset_exch: Issuing abts\n");
  
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	spin_unlock_irqrestore(io_lock, flags);
  
- 	/* Now queue the abort command to firmware */
+ 	/* Queue the abort command to firmware */
  	int_to_scsilun(sc->device->lun, &fc_lun);
  
  	if (fnic_queue_abort_io_req(fnic, abt_tag,
@@@ -1648,8 -1861,10 +2014,10 @@@
  	return true;
  }
  
 -void fnic_rport_exch_reset(struct fnic *fnic, u32 port_id)
 +static void fnic_rport_exch_reset(struct fnic *fnic, u32 port_id)
  {
+ 	unsigned int io_count = 0;
+ 	unsigned long flags;
  	struct terminate_stats *term_stats = &fnic->fnic_stats.term_stats;
  	struct fnic_rport_abort_io_iter_data iter_data = {
  		.fnic = fnic,
@@@ -1657,10 -1872,9 +2025,16 @@@
  		.term_cnt = 0,
  	};
  
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG,
 +		      fnic->lport->host,
 +		      "fnic_rport_exch_reset called portid 0x%06x\n",
 +		      port_id);
++=======
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 				  "fnic rport exchange reset for tport: 0x%06x\n",
+ 				  port_id);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	if (fnic->in_remove)
  		return;
@@@ -1674,37 -1913,35 +2073,55 @@@
  
  void fnic_terminate_rport_io(struct fc_rport *rport)
  {
- 	struct fc_rport_libfc_priv *rdata;
- 	struct fc_lport *lport;
- 	struct fnic *fnic;
+ 	struct fnic_tport_s *tport;
+ 	struct rport_dd_data_s *rdd_data;
+ 	struct fnic_iport_s *iport = NULL;
+ 	struct fnic *fnic = NULL;
  
  	if (!rport) {
- 		printk(KERN_ERR "fnic_terminate_rport_io: rport is NULL\n");
+ 		pr_err("rport is NULL\n");
  		return;
  	}
- 	rdata = rport->dd_data;
  
- 	if (!rdata) {
- 		printk(KERN_ERR "fnic_terminate_rport_io: rdata is NULL\n");
- 		return;
+ 	rdd_data = rport->dd_data;
+ 	if (rdd_data) {
+ 		tport = rdd_data->tport;
+ 		if (!tport) {
+ 			pr_err(
+ 			"term rport io called after tport is deleted. Returning 0x%8x\n",
+ 		   rport->port_id);
+ 		} else {
+ 			pr_err(
+ 			   "term rport io called after tport is set 0x%8x\n",
+ 			   rport->port_id);
+ 			pr_err(
+ 			   "tport maybe rediscovered\n");
+ 
+ 			iport = (struct fnic_iport_s *) tport->iport;
+ 			fnic = iport->fnic;
+ 			fnic_rport_exch_reset(fnic, rport->port_id);
+ 		}
  	}
++<<<<<<< HEAD
 +	lport = rdata->local_port;
 +
 +	if (!lport) {
 +		printk(KERN_ERR "fnic_terminate_rport_io: lport is NULL\n");
 +		return;
 +	}
 +	fnic = lport_priv(lport);
 +	FNIC_SCSI_DBG(KERN_DEBUG,
 +		      fnic->lport->host, "fnic_terminate_rport_io called"
 +		      " wwpn 0x%llx, wwnn0x%llx, rport 0x%p, portid 0x%06x\n",
 +		      rport->port_name, rport->node_name, rport,
 +		      rport->port_id);
 +
 +	if (fnic->in_remove)
 +		return;
 +
 +	fnic_rport_exch_reset(fnic, rport->port_id);
++=======
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  }
  
  /*
@@@ -1719,7 -1957,7 +2137,11 @@@ int fnic_abort_cmd(struct scsi_cmnd *sc
  	struct fnic *fnic;
  	struct fnic_io_req *io_req = NULL;
  	struct fc_rport *rport;
++<<<<<<< HEAD
 +	spinlock_t *io_lock;
++=======
+ 	struct rport_dd_data_s *rdd_data;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	unsigned long flags;
  	unsigned long start_time = 0;
  	int ret = SUCCESS;
@@@ -1737,23 -1977,60 +2159,67 @@@
  	fc_block_scsi_eh(sc);
  
  	/* Get local-port, check ready and link up */
++<<<<<<< HEAD
 +	lp = shost_priv(sc->device->host);
 +
 +	fnic = lport_priv(lp);
++=======
+ 	fnic = *((struct fnic **) shost_priv(sc->device->host));
+ 
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	iport = &fnic->iport;
+ 
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	fnic_stats = &fnic->fnic_stats;
  	abts_stats = &fnic->fnic_stats.abts_stats;
  	term_stats = &fnic->fnic_stats.term_stats;
  
  	rport = starget_to_rport(scsi_target(sc->device));
 -	mqtag = blk_mq_unique_tag(rq);
 -	hwq = blk_mq_unique_tag_to_hwq(mqtag);
 +	FNIC_SCSI_DBG(KERN_DEBUG,
 +		fnic->lport->host,
 +		"Abort Cmd called FCID 0x%x, LUN 0x%llx TAG %x flags %x\n",
 +		rport->port_id, sc->device->lun, tag, CMD_FLAGS(sc));
  
 -	fnic_priv(sc)->flags = FNIC_NO_FLAGS;
 +	CMD_FLAGS(sc) = FNIC_NO_FLAGS;
  
- 	if (lp->state != LPORT_ST_READY || !(lp->link_up)) {
+ 	rdd_data = rport->dd_data;
+ 	tport = rdd_data->tport;
+ 
+ 	if (!tport) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			  "Abort cmd called after tport delete! rport fcid: 0x%x",
+ 			  rport->port_id);
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 			  "lun: %llu hwq: 0x%x mqtag: 0x%x Op: 0x%x flags: 0x%x\n",
+ 			  sc->device->lun, hwq, mqtag,
+ 			  sc->cmnd[0], fnic_priv(sc)->flags);
+ 		ret = FAILED;
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_abort_cmd_end;
+ 	}
+ 
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 	  "Abort cmd called rport fcid: 0x%x lun: %llu hwq: 0x%x mqtag: 0x%x",
+ 	  rport->port_id, sc->device->lun, hwq, mqtag);
+ 
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "Op: 0x%x flags: 0x%x\n",
+ 				  sc->cmnd[0],
+ 				  fnic_priv(sc)->flags);
+ 
+ 	if (iport->state != FNIC_IPORT_STATE_READY) {
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "iport NOT in READY state");
+ 		ret = FAILED;
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_abort_cmd_end;
+ 	}
+ 
+ 	if ((tport->state != FDLS_TGT_STATE_READY) &&
+ 		(tport->state != FDLS_TGT_STATE_ADISC)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "tport state: %d\n", tport->state);
  		ret = FAILED;
 -		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  		goto fnic_abort_cmd_end;
  	}
  
@@@ -1767,13 -2045,13 +2233,18 @@@
  	 * happened, the completion wont actually complete the command
  	 * and it will be considered as an aborted command
  	 *
 -	 * .io_req will not be cleared except while holding io_req_lock.
 +	 * The CMD_SP will not be cleared except while holding io_req_lock.
  	 */
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -	io_req = fnic_priv(sc)->io_req;
 +	io_lock = fnic_io_lock_hash(fnic, sc);
 +	spin_lock_irqsave(io_lock, flags);
 +	io_req = (struct fnic_io_req *)CMD_SP(sc);
  	if (!io_req) {
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(io_lock, flags);
++=======
+ 		ret = FAILED;
+ 		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		goto fnic_abort_cmd_end;
  	}
  
@@@ -1953,24 -2231,33 +2423,37 @@@ static inline int fnic_queue_dr_io_req(
  	struct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;
  	struct scsi_lun fc_lun;
  	int ret = 0;
++<<<<<<< HEAD
 +	unsigned long intr_flags;
++=======
+ 	unsigned long flags;
+ 	uint16_t hwq = 0;
+ 	uint32_t tag = 0;
+ 	struct fnic_tport_s *tport = io_req->tport;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
 -	tag = io_req->tag;
 -	hwq = blk_mq_unique_tag_to_hwq(tag);
 -	wq = &fnic->hw_copy_wq[hwq];
 -
 -	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	spin_lock_irqsave(host->host_lock, intr_flags);
  	if (unlikely(fnic_chk_state_flags_locked(fnic,
  						FNIC_FLAGS_IO_BLOCKED))) {
 -		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		spin_unlock_irqrestore(host->host_lock, intr_flags);
  		return FAILED;
- 	} else
+ 	} else {
  		atomic_inc(&fnic->in_flight);
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(host->host_lock, intr_flags);
++=======
+ 		atomic_inc(&tport->in_flight);
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 +	spin_lock_irqsave(&fnic->wq_copy_lock[0], intr_flags);
  
 -	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[hwq])
 -		free_wq_copy_descs(fnic, wq, hwq);
 +	if (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])
 +		free_wq_copy_descs(fnic, wq);
  
  	if (!vnic_wq_copy_desc_avail(wq)) {
 -		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
  			  "queue_dr_io_req failure - no descriptors\n");
  		atomic64_inc(&misc_stats->devrst_cpwq_alloc_failures);
  		ret = -EAGAIN;
@@@ -1992,8 -2280,9 +2475,9 @@@
  		  atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs));
  
  lr_io_req_end:
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	spin_unlock_irqrestore(&fnic->wq_copy_lock[0], intr_flags);
  	atomic_dec(&fnic->in_flight);
+ 	atomic_dec(&tport->in_flight);
  
  	return ret;
  }
@@@ -2197,17 -2489,23 +2680,28 @@@ int fnic_device_reset(struct scsi_cmnd 
  	struct fnic_io_req *io_req = NULL;
  	struct fc_rport *rport;
  	int status;
+ 	int count = 0;
  	int ret = FAILED;
 +	spinlock_t *io_lock;
  	unsigned long flags;
  	unsigned long start_time = 0;
  	struct scsi_lun fc_lun;
  	struct fnic_stats *fnic_stats;
  	struct reset_stats *reset_stats;
 -	int mqtag = rq->tag;
 +	int tag = rq->tag;
  	DECLARE_COMPLETION_ONSTACK(tm_done);
 +	int tag_gen_flag = 0;   /*to track tags allocated by fnic driver*/
  	bool new_sc = 0;
++<<<<<<< HEAD
++=======
+ 	uint16_t hwq = 0;
+ 	struct fnic_iport_s *iport = NULL;
+ 	struct rport_dd_data_s *rdd_data;
+ 	struct fnic_tport_s *tport;
+ 	u32 old_soft_reset_count;
+ 	u32 old_link_down_cnt;
+ 	int exit_dr = 0;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	/* Wait for rport to unblock */
  	fc_block_scsi_eh(sc);
@@@ -2222,12 -2520,38 +2716,44 @@@
  	atomic64_inc(&reset_stats->device_resets);
  
  	rport = starget_to_rport(scsi_target(sc->device));
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "Device reset called FCID 0x%x, LUN 0x%llx sc 0x%p\n",
 +		      rport->port_id, sc->device->lun, sc);
++=======
  
- 	if (lp->state != LPORT_ST_READY || !(lp->link_up))
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 		"fcid: 0x%x lun: %llu hwq: %d mqtag: 0x%x flags: 0x%x Device reset\n",
+ 		rport->port_id, sc->device->lun, hwq, mqtag,
+ 		fnic_priv(sc)->flags);
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
+ 
+ 	rdd_data = rport->dd_data;
+ 	tport = rdd_data->tport;
+ 	if (!tport) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 		  "Dev rst called after tport delete! rport fcid: 0x%x lun: %llu\n",
+ 		  rport->port_id, sc->device->lun);
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  		goto fnic_device_reset_end;
+ 	}
+ 
+ 	if (iport->state != FNIC_IPORT_STATE_READY) {
+ 		FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 					  "iport NOT in READY state");
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_device_reset_end;
+ 	}
+ 
+ 	if ((tport->state != FDLS_TGT_STATE_READY) &&
+ 		(tport->state != FDLS_TGT_STATE_ADISC)) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "tport state: %d\n", tport->state);
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		goto fnic_device_reset_end;
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  
  	/* Check if remote port up */
  	if (fc_remote_port_chkready(rport)) {
@@@ -2265,14 -2591,24 +2790,28 @@@
  		}
  		memset(io_req, 0, sizeof(*io_req));
  		io_req->port_id = rport->port_id;
++<<<<<<< HEAD
 +		CMD_SP(sc) = (char *)io_req;
++=======
+ 		io_req->tag = mqtag;
+ 		fnic_priv(sc)->io_req = io_req;
+ 		io_req->tport = tport;
+ 		io_req->sc = sc;
+ 
+ 		if (fnic->sw_copy_wq[hwq].io_req_table[blk_mq_unique_tag_to_tag(mqtag)] != NULL)
+ 			WARN(1, "fnic<%d>: %s: tag 0x%x already exists\n",
+ 					fnic->fnic_num, __func__, blk_mq_unique_tag_to_tag(mqtag));
+ 
+ 		fnic->sw_copy_wq[hwq].io_req_table[blk_mq_unique_tag_to_tag(mqtag)] =
+ 				io_req;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	}
  	io_req->dr_done = &tm_done;
 -	fnic_priv(sc)->state = FNIC_IOREQ_CMD_PENDING;
 -	fnic_priv(sc)->lr_status = FCPIO_INVALID_CODE;
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	CMD_STATE(sc) = FNIC_IOREQ_CMD_PENDING;
 +	CMD_LR_STATUS(sc) = FCPIO_INVALID_CODE;
 +	spin_unlock_irqrestore(io_lock, flags);
  
 -	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num, "TAG %x\n", mqtag);
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, "TAG %x\n", tag);
  
  	/*
  	 * issue the device reset, if enqueue failed, clean up the ioreq
@@@ -2285,10 -2621,15 +2824,15 @@@
  			io_req->dr_done = NULL;
  		goto fnic_device_reset_clean;
  	}
 -	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
 -	fnic_priv(sc)->flags |= FNIC_DEV_RST_ISSUED;
 -	spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +	spin_lock_irqsave(io_lock, flags);
 +	CMD_FLAGS(sc) |= FNIC_DEV_RST_ISSUED;
 +	spin_unlock_irqrestore(io_lock, flags);
  
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	old_link_down_cnt = iport->fnic->link_down_cnt;
+ 	old_soft_reset_count = fnic->soft_reset_count;
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
  	/*
  	 * Wait on the local completion for LUN reset.  The io_req may be
  	 * freed while we wait since we hold no lock.
@@@ -2296,17 -2637,42 +2840,47 @@@
  	wait_for_completion_timeout(&tm_done,
  				    msecs_to_jiffies(FNIC_LUN_RESET_TIMEOUT));
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(io_lock, flags);
 +	io_req = (struct fnic_io_req *)CMD_SP(sc);
++=======
+ 	/*
+ 	 * Wake up can be due to the following reasons:
+ 	 * 1) The device reset completed from target.
+ 	 * 2) Device reset timed out.
+ 	 * 3) A link-down/host_reset may have happened in between.
+ 	 * 4) The device reset was aborted and io_req->dr_done was called.
+ 	 */
+ 
+ 	exit_dr = 0;
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 	if ((old_link_down_cnt != fnic->link_down_cnt) ||
+ 		(fnic->reset_in_progress) ||
+ 		(fnic->soft_reset_count != old_soft_reset_count) ||
+ 		(iport->state != FNIC_IPORT_STATE_READY))
+ 		exit_dr = 1;
+ 
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 
+ 	spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 	io_req = fnic_priv(sc)->io_req;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	if (!io_req) {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 -		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
 -				"io_req is null mqtag 0x%x sc 0x%p\n", mqtag, sc);
 +		spin_unlock_irqrestore(io_lock, flags);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				"io_req is null tag 0x%x sc 0x%p\n", tag, sc);
  		goto fnic_device_reset_end;
  	}
+ 
+ 	if (exit_dr) {
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "Host reset called for fnic. Exit device reset\n");
+ 		io_req->dr_done = NULL;
+ 		goto fnic_device_reset_clean;
+ 	}
  	io_req->dr_done = NULL;
  
 -	status = fnic_priv(sc)->lr_status;
 +	status = CMD_LR_STATUS(sc);
  
  	/*
  	 * If lun reset not completed, bail out with failed. io_req
@@@ -2314,55 -2680,13 +2888,61 @@@
  	 */
  	if (status == FCPIO_INVALID_CODE) {
  		atomic64_inc(&reset_stats->device_reset_timeouts);
 -		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
  			      "Device reset timed out\n");
++<<<<<<< HEAD
 +		CMD_FLAGS(sc) |= FNIC_DEV_RST_TIMED_OUT;
 +		spin_unlock_irqrestore(io_lock, flags);
 +		int_to_scsilun(sc->device->lun, &fc_lun);
 +		/*
 +		 * Issue abort and terminate on device reset request.
 +		 * If q'ing of terminate fails, retry it after a delay.
 +		 */
 +		while (1) {
 +			spin_lock_irqsave(io_lock, flags);
 +			if (CMD_FLAGS(sc) & FNIC_DEV_RST_TERM_ISSUED) {
 +				spin_unlock_irqrestore(io_lock, flags);
 +				break;
 +			}
 +			spin_unlock_irqrestore(io_lock, flags);
 +			if (fnic_queue_abort_io_req(fnic,
 +				tag | FNIC_TAG_DEV_RST,
 +				FCPIO_ITMF_ABT_TASK_TERM,
 +				fc_lun.scsi_lun, io_req)) {
 +				wait_for_completion_timeout(&tm_done,
 +				msecs_to_jiffies(FNIC_ABT_TERM_DELAY_TIMEOUT));
 +			} else {
 +				spin_lock_irqsave(io_lock, flags);
 +				CMD_FLAGS(sc) |= FNIC_DEV_RST_TERM_ISSUED;
 +				CMD_STATE(sc) = FNIC_IOREQ_ABTS_PENDING;
 +				io_req->abts_done = &tm_done;
 +				spin_unlock_irqrestore(io_lock, flags);
 +				FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +				"Abort and terminate issued on Device reset "
 +				"tag 0x%x sc 0x%p\n", tag, sc);
 +				break;
 +			}
 +		}
 +		while (1) {
 +			spin_lock_irqsave(io_lock, flags);
 +			if (!(CMD_FLAGS(sc) & FNIC_DEV_RST_DONE)) {
 +				spin_unlock_irqrestore(io_lock, flags);
 +				wait_for_completion_timeout(&tm_done,
 +				msecs_to_jiffies(FNIC_LUN_RESET_TIMEOUT));
 +				break;
 +			} else {
 +				io_req = (struct fnic_io_req *)CMD_SP(sc);
 +				io_req->abts_done = NULL;
 +				goto fnic_device_reset_clean;
 +			}
 +		}
++=======
+ 		fnic_priv(sc)->flags |= FNIC_DEV_RST_TIMED_OUT;
+ 		int_to_scsilun(sc->device->lun, &fc_lun);
+ 		goto fnic_device_reset_clean;
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  	} else {
 -		spin_unlock_irqrestore(&fnic->wq_copy_lock[hwq], flags);
 +		spin_unlock_irqrestore(io_lock, flags);
  	}
  
  	/* Completed, but not successful, clean up the io_req, return fail */
@@@ -2383,11 -2707,10 +2963,18 @@@
  	 * succeeds
  	 */
  	if (fnic_clean_pending_aborts(fnic, sc, new_sc)) {
++<<<<<<< HEAD
 +		spin_lock_irqsave(io_lock, flags);
 +		io_req = (struct fnic_io_req *)CMD_SP(sc);
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			      "Device reset failed"
 +			      " since could not abort all IOs\n");
++=======
+ 		spin_lock_irqsave(&fnic->wq_copy_lock[hwq], flags);
+ 		io_req = fnic_priv(sc)->io_req;
+ 		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
+ 					  "Device reset failed: Cannot abort all IOs\n");
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		goto fnic_device_reset_clean;
  	}
  
@@@ -2416,13 -2751,25 +3012,28 @@@ fnic_device_reset_end
  		  0, ((u64)sc->cmnd[0] << 32 |
  		  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |
  		  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),
 -		  fnic_flags_and_state(sc));
 +		  (((u64)CMD_FLAGS(sc) << 32) | CMD_STATE(sc)));
  
 -	if (new_sc) {
 -		fnic->sgreset_sc = NULL;
 -		mutex_unlock(&fnic->sgreset_mutex);
 -	}
 +	/* free tag if it is allocated */
 +	if (unlikely(tag_gen_flag))
 +		fnic_scsi_host_end_tag(fnic, sc);
  
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
++=======
+ 	while ((ret == SUCCESS) && fnic_count_lun_ioreqs(fnic, sc->device)) {
+ 		if (count >= 2) {
+ 			ret = FAILED;
+ 			break;
+ 		}
+ 		FNIC_SCSI_DBG(KERN_ERR, fnic->lport->host, fnic->fnic_num,
+ 					  "Cannot clean up all IOs for the LUN\n");
+ 		schedule_timeout(msecs_to_jiffies(1000));
+ 		count++;
+ 	}
+ 
+ 	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, fnic->fnic_num,
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  		      "Returning from device reset %s\n",
  		      (ret == SUCCESS) ?
  		      "SUCCESS" : "FAILED");
@@@ -2433,68 -2780,78 +3044,96 @@@
  	return ret;
  }
  
- /* Clean up all IOs, clean up libFC local port */
- int fnic_reset(struct Scsi_Host *shost)
+ static void fnic_post_flogo_linkflap(struct fnic *fnic)
+ {
+ 	unsigned long flags;
+ 
+ 	fnic_fdls_link_status_change(fnic, 0);
+ 	spin_lock_irqsave(&fnic->fnic_lock, flags);
+ 
+ 	if (fnic->link_status) {
+ 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ 		fnic_fdls_link_status_change(fnic, 1);
+ 		return;
+ 	}
+ 	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
+ }
+ 
+ /* Logout from all the targets and simulate link flap */
+ void fnic_reset(struct Scsi_Host *shost)
  {
- 	struct fc_lport *lp;
  	struct fnic *fnic;
- 	int ret = 0;
  	struct reset_stats *reset_stats;
  
- 	lp = shost_priv(shost);
- 	fnic = lport_priv(lp);
+ 	fnic = *((struct fnic **) shost_priv(shost));
  	reset_stats = &fnic->fnic_stats.reset_stats;
  
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "fnic_reset called\n");
++=======
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "Issuing fnic reset\n");
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
  	atomic64_inc(&reset_stats->fnic_resets);
+ 	fnic_post_flogo_linkflap(fnic);
  
- 	/*
- 	 * Reset local port, this will clean up libFC exchanges,
- 	 * reset remote port sessions, and if link is up, begin flogi
- 	 */
- 	ret = fc_lport_reset(lp);
- 
++<<<<<<< HEAD
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "Returning from fnic reset %s\n",
 +		      (ret == 0) ?
 +		      "SUCCESS" : "FAILED");
++=======
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "Returning from fnic reset");
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  
- 	if (ret == 0)
- 		atomic64_inc(&reset_stats->fnic_reset_completions);
- 	else
- 		atomic64_inc(&reset_stats->fnic_reset_failures);
+ 	atomic64_inc(&reset_stats->fnic_reset_completions);
+ }
+ 
+ int fnic_issue_fc_host_lip(struct Scsi_Host *shost)
+ {
+ 	int ret = 0;
+ 	struct fnic *fnic = *((struct fnic **) shost_priv(shost));
+ 
+ 	FNIC_SCSI_DBG(KERN_INFO, fnic->lport->host, fnic->fnic_num,
+ 				  "FC host lip issued");
  
+ 	ret = fnic_host_reset(shost);
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * SCSI Error handling calls driver's eh_host_reset if all prior
 + * error handling levels return FAILED. If host reset completes
 + * successfully, and if link is up, then Fabric login begins.
 + *
 + * Host Reset is the highest level of error recovery. If this fails, then
 + * host is offlined by SCSI.
 + *
 + */
 +int fnic_host_reset(struct scsi_cmnd *sc)
++=======
+ int fnic_host_reset(struct Scsi_Host *shost)
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  {
 -	int ret = SUCCESS;
 +	int ret;
  	unsigned long wait_host_tmo;
 -	struct fnic *fnic = *((struct fnic **) shost_priv(shost));
 +	struct Scsi_Host *shost = sc->device->host;
 +	struct fc_lport *lp = shost_priv(shost);
 +	struct fnic *fnic = lport_priv(lp);
  	unsigned long flags;
 -	struct fnic_iport_s *iport = &fnic->iport;
  
  	spin_lock_irqsave(&fnic->fnic_lock, flags);
 -	if (fnic->reset_in_progress == NOT_IN_PROGRESS) {
 -		fnic->reset_in_progress = IN_PROGRESS;
 +	if (!fnic->internal_reset_inprogress) {
 +		fnic->internal_reset_inprogress = true;
  	} else {
  		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 -		wait_for_completion_timeout(&fnic->reset_completion_wait,
 -									msecs_to_jiffies(10000));
 -
 -		spin_lock_irqsave(&fnic->fnic_lock, flags);
 -		if (fnic->reset_in_progress == IN_PROGRESS) {
 -			spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 -			FNIC_SCSI_DBG(KERN_WARNING, fnic->lport->host, fnic->fnic_num,
 -			  "Firmware reset in progress. Skipping another host reset\n");
 -			return SUCCESS;
 -		}
 -		fnic->reset_in_progress = IN_PROGRESS;
 +		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +			"host reset in progress skipping another host reset\n");
 +		return SUCCESS;
  	}
  	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  
@@@ -2523,124 -2890,9 +3162,127 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * This fxn is called from libFC when host is removed
 + */
 +void fnic_scsi_abort_io(struct fc_lport *lp)
 +{
 +	int err = 0;
 +	unsigned long flags;
 +	enum fnic_state old_state;
 +	struct fnic *fnic = lport_priv(lp);
 +	DECLARE_COMPLETION_ONSTACK(remove_wait);
 +
 +	/* Issue firmware reset for fnic, wait for reset to complete */
 +retry_fw_reset:
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	if (unlikely(fnic->state == FNIC_IN_FC_TRANS_ETH_MODE) &&
 +		     fnic->link_events) {
 +		/* fw reset is in progress, poll for its completion */
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		schedule_timeout(msecs_to_jiffies(100));
 +		goto retry_fw_reset;
 +	}
 +
 +	fnic->remove_wait = &remove_wait;
 +	old_state = fnic->state;
 +	fnic->state = FNIC_IN_FC_TRANS_ETH_MODE;
 +	fnic_update_mac_locked(fnic, fnic->ctlr.ctl_src_addr);
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +
 +	err = fnic_fw_reset_handler(fnic);
 +	if (err) {
 +		spin_lock_irqsave(&fnic->fnic_lock, flags);
 +		if (fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)
 +			fnic->state = old_state;
 +		fnic->remove_wait = NULL;
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		return;
 +	}
 +
 +	/* Wait for firmware reset to complete */
 +	wait_for_completion_timeout(&remove_wait,
 +				    msecs_to_jiffies(FNIC_RMDEVICE_TIMEOUT));
 +
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	fnic->remove_wait = NULL;
 +	FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
 +		      "fnic_scsi_abort_io %s\n",
 +		      (fnic->state == FNIC_IN_ETH_MODE) ?
 +		      "SUCCESS" : "FAILED");
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +
 +}
 +
 +/*
 + * This fxn called from libFC to clean up driver IO state on link down
 + */
 +void fnic_scsi_cleanup(struct fc_lport *lp)
 +{
 +	unsigned long flags;
 +	enum fnic_state old_state;
 +	struct fnic *fnic = lport_priv(lp);
 +
 +	/* issue fw reset */
 +retry_fw_reset:
 +	spin_lock_irqsave(&fnic->fnic_lock, flags);
 +	if (unlikely(fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)) {
 +		/* fw reset is in progress, poll for its completion */
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +		schedule_timeout(msecs_to_jiffies(100));
 +		goto retry_fw_reset;
 +	}
 +	old_state = fnic->state;
 +	fnic->state = FNIC_IN_FC_TRANS_ETH_MODE;
 +	fnic_update_mac_locked(fnic, fnic->ctlr.ctl_src_addr);
 +	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +
 +	if (fnic_fw_reset_handler(fnic)) {
 +		spin_lock_irqsave(&fnic->fnic_lock, flags);
 +		if (fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)
 +			fnic->state = old_state;
 +		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 +	}
 +
 +}
 +
 +void fnic_empty_scsi_cleanup(struct fc_lport *lp)
 +{
 +}
 +
 +void fnic_exch_mgr_reset(struct fc_lport *lp, u32 sid, u32 did)
 +{
 +	struct fnic *fnic = lport_priv(lp);
 +
 +	/* Non-zero sid, nothing to do */
 +	if (sid)
 +		goto call_fc_exch_mgr_reset;
 +
 +	if (did) {
 +		fnic_rport_exch_reset(fnic, did);
 +		goto call_fc_exch_mgr_reset;
 +	}
 +
 +	/*
 +	 * sid = 0, did = 0
 +	 * link down or device being removed
 +	 */
 +	if (!fnic->in_remove)
 +		fnic_scsi_cleanup(lp);
 +	else
 +		fnic_scsi_abort_io(lp);
 +
 +	/* call libFC exch mgr reset to reset its exchanges */
 +call_fc_exch_mgr_reset:
 +	fc_exch_mgr_reset(lp, sid, did);
 +
 +}
 +
++=======
++>>>>>>> 6335be1c5009 (scsi: fnic: Modify IO path to use FDLS)
  static bool fnic_abts_pending_iter(struct scsi_cmnd *sc, void *data)
  {
 -	struct request *const rq = scsi_cmd_to_rq(sc);
  	struct fnic_pending_aborts_iter_data *iter_data = data;
  	struct fnic *fnic = iter_data->fnic;
  	int cmd_state;
* Unmerged path drivers/scsi/fnic/fnic.h
diff --git a/drivers/scsi/fnic/fnic_io.h b/drivers/scsi/fnic/fnic_io.h
index 1cb6a68c8e4e..05d30fa6a71e 100644
--- a/drivers/scsi/fnic/fnic_io.h
+++ b/drivers/scsi/fnic/fnic_io.h
@@ -19,6 +19,7 @@
 #define _FNIC_IO_H_
 
 #include <scsi/fc/fc_fcp.h>
+#include "fnic_fdls.h"
 
 #define FNIC_DFLT_SG_DESC_CNT  32
 #define FNIC_MAX_SG_DESC_CNT        256     /* Maximum descriptors per sgl */
@@ -53,6 +54,8 @@ enum fnic_ioreq_state {
 };
 
 struct fnic_io_req {
+	struct fnic_iport_s *iport;
+	struct fnic_tport_s *tport;
 	struct host_sg_desc *sgl_list; /* sgl list */
 	void *sgl_list_alloc; /* sgl list address used for free */
 	dma_addr_t sense_buf_pa; /* dma address for sense buffer*/
* Unmerged path drivers/scsi/fnic/fnic_main.c
* Unmerged path drivers/scsi/fnic/fnic_scsi.c
diff --git a/drivers/scsi/fnic/fnic_stats.h b/drivers/scsi/fnic/fnic_stats.h
index ca7ab8afa60a..d582ca7ecdea 100644
--- a/drivers/scsi/fnic/fnic_stats.h
+++ b/drivers/scsi/fnic/fnic_stats.h
@@ -141,6 +141,4 @@ struct stats_debug_info {
 };
 
 int fnic_get_stats_data(struct stats_debug_info *, struct fnic_stats *);
-void fnic_stats_debugfs_init(struct fnic *);
-void fnic_stats_debugfs_remove(struct fnic *);
 #endif /* _FNIC_STATS_H_ */
