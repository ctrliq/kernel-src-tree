scsi: fnic: Add support to handle port channel RSCN

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.46.1.el9_6
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 8d26bfcf1d2e829d37ef7f2b506b95e46f25f993
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.46.1.el9_6/8d26bfcf.failed

Add support to handle port channel RSCN.

Port channel RSCN is a Cisco vendor specific RSCN event. It is applicable
only to Cisco UCS fabrics.  If there's a change in the port channel
configuration, an RCSN is sent to fnic. This is used to serially reset the
scsi initiator fnics so that there's no all paths down scenario. The
affected fnics are added to a list that are reset with a small time gap
between them.

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Reviewed-by: Gian Carlo Boffa <gcboffa@cisco.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20241212020312.4786-15-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8d26bfcf1d2e829d37ef7f2b506b95e46f25f993)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fdls_disc.c
#	drivers/scsi/fnic/fnic.h
#	drivers/scsi/fnic/fnic_main.c
diff --cc drivers/scsi/fnic/fnic.h
index 73fb8245c7b7,b9b0a4f0b78c..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -127,9 -205,39 +127,41 @@@
  #define fnic_clear_state_flags(fnicp, st_flags)  \
  	__fnic_set_state_flags(fnicp, st_flags, 1)
  
++<<<<<<< HEAD
++=======
+ enum reset_states {
+ 	NOT_IN_PROGRESS = 0,
+ 	IN_PROGRESS,
+ 	RESET_ERROR
+ };
+ 
+ enum rscn_type {
+ 	NOT_PC_RSCN = 0,
+ 	PC_RSCN
+ };
+ 
+ enum pc_rscn_handling_status {
+ 	PC_RSCN_HANDLING_NOT_IN_PROGRESS = 0,
+ 	PC_RSCN_HANDLING_IN_PROGRESS
+ };
+ 
+ enum pc_rscn_handling_feature {
+ 	PC_RSCN_HANDLING_FEATURE_OFF = 0,
+ 	PC_RSCN_HANDLING_FEATURE_ON
+ };
+ 
+ extern unsigned int fnic_fdmi_support;
++>>>>>>> 8d26bfcf1d2e (scsi: fnic: Add support to handle port channel RSCN)
  extern unsigned int fnic_log_level;
  extern unsigned int io_completions;
 -extern struct workqueue_struct *fnic_event_queue;
  
+ extern unsigned int pc_rscn_handling_feature_flag;
+ extern spinlock_t reset_fnic_list_lock;
+ extern struct list_head reset_fnic_list;
+ extern struct workqueue_struct *reset_fnic_work_queue;
+ extern struct work_struct reset_fnic_work;
+ 
+ 
  #define FNIC_MAIN_LOGGING 0x01
  #define FNIC_FCS_LOGGING 0x02
  #define FNIC_SCSI_LOGGING 0x04
@@@ -298,8 -438,16 +331,21 @@@ struct fnic 
  	struct work_struct link_work;
  	struct work_struct frame_work;
  	struct work_struct flush_work;
++<<<<<<< HEAD
 +	struct sk_buff_head frame_queue;
 +	struct sk_buff_head tx_queue;
++=======
+ 	struct list_head frame_queue;
+ 	struct list_head tx_queue;
+ 	mempool_t *frame_pool;
+ 	mempool_t *frame_elem_pool;
+ 	struct work_struct tport_work;
+ 	struct list_head tport_event_list;
+ 
+ 	char subsys_desc[14];
+ 	int subsys_desc_len;
+ 	int pc_rscn_handling_status;
++>>>>>>> 8d26bfcf1d2e (scsi: fnic: Add support to handle port channel RSCN)
  
  	/*** FIP related data members  -- start ***/
  	void (*set_vlan)(struct fnic *, u16 vlan);
@@@ -386,10 -532,10 +432,11 @@@ void fnic_handle_link_event(struct fni
  int fnic_is_abts_pending(struct fnic *, struct scsi_cmnd *);
  
  void fnic_handle_fip_frame(struct work_struct *work);
+ void fnic_reset_work_handler(struct work_struct *work);
  void fnic_handle_fip_event(struct fnic *fnic);
  void fnic_fcoe_reset_vlans(struct fnic *fnic);
 -extern void fnic_handle_fip_timer(struct timer_list *t);
 +void fnic_fcoe_evlist_free(struct fnic *fnic);
 +extern void fnic_handle_fip_timer(struct fnic *fnic);
  
  static inline int
  fnic_chk_state_flags_locked(struct fnic *fnic, unsigned long st_flags)
diff --cc drivers/scsi/fnic/fnic_main.c
index 06fd7b543b33,40ed6b2490e2..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -89,13 -93,13 +93,23 @@@ static unsigned int fnic_max_qdepth = F
  module_param(fnic_max_qdepth, uint, S_IRUGO|S_IWUSR);
  MODULE_PARM_DESC(fnic_max_qdepth, "Queue depth to report for each LUN");
  
++<<<<<<< HEAD
 +static struct libfc_function_template fnic_transport_template = {
 +	.frame_send = fnic_send,
 +	.lport_set_port_id = fnic_set_port_id,
 +	.fcp_abort_io = fnic_empty_scsi_cleanup,
 +	.fcp_cleanup = fnic_empty_scsi_cleanup,
 +	.exch_mgr_reset = fnic_exch_mgr_reset
 +};
++=======
+ unsigned int pc_rscn_handling_feature_flag = PC_RSCN_HANDLING_FEATURE_ON;
+ module_param(pc_rscn_handling_feature_flag, uint, 0644);
+ MODULE_PARM_DESC(pc_rscn_handling_feature_flag,
+ 		 "PCRSCN handling (0 for none. 1 to handle PCRSCN (default))");
+ 
+ struct workqueue_struct *reset_fnic_work_queue;
+ struct workqueue_struct *fnic_fip_queue;
++>>>>>>> 8d26bfcf1d2e (scsi: fnic: Add support to handle port channel RSCN)
  
  static int fnic_slave_alloc(struct scsi_device *sdev)
  {
@@@ -1168,8 -1318,15 +1195,11 @@@ err_pci_register
  err_fc_transport:
  	destroy_workqueue(fnic_fip_queue);
  err_create_fip_workq:
+ 	if (pc_rscn_handling_feature_flag == PC_RSCN_HANDLING_FEATURE_ON)
+ 		destroy_workqueue(reset_fnic_work_queue);
+ err_create_reset_fnic_workq:
  	destroy_workqueue(fnic_event_queue);
  err_create_fnic_workq:
 -	kmem_cache_destroy(fdls_frame_elem_cache);
 -err_create_fdls_frame_cache_elem:
 -	kmem_cache_destroy(fdls_frame_cache);
 -err_create_fdls_frame_cache:
  	kmem_cache_destroy(fnic_io_req_cache);
  err_create_fnic_ioreq_slab:
  	kmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);
@@@ -1186,8 -1343,14 +1216,17 @@@ static void __exit fnic_cleanup_module(
  {
  	pci_unregister_driver(&fnic_driver);
  	destroy_workqueue(fnic_event_queue);
++<<<<<<< HEAD
 +	if (fnic_fip_queue)
++=======
+ 
+ 	if (pc_rscn_handling_feature_flag == PC_RSCN_HANDLING_FEATURE_ON)
+ 		destroy_workqueue(reset_fnic_work_queue);
+ 
+ 	if (fnic_fip_queue) {
+ 		flush_workqueue(fnic_fip_queue);
++>>>>>>> 8d26bfcf1d2e (scsi: fnic: Add support to handle port channel RSCN)
  		destroy_workqueue(fnic_fip_queue);
 -	}
  	kmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);
  	kmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);
  	kmem_cache_destroy(fnic_io_req_cache);
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fdls_disc.c
* Unmerged path drivers/scsi/fnic/fnic.h
diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c
index 8c3b350695e3..40efed6acd14 100644
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@ -1409,3 +1409,39 @@ void fnic_handle_fip_timer(struct fnic *fnic)
 		break;
 	}
 }
+
+void fnic_reset_work_handler(struct work_struct *work)
+{
+	struct fnic *cur_fnic, *next_fnic;
+	unsigned long reset_fnic_list_lock_flags;
+	int host_reset_ret_code;
+
+	/*
+	 * This is a single thread. It is per fnic module, not per fnic
+	 * All the fnics that need to be reset
+	 * have been serialized via the reset fnic list.
+	 */
+	spin_lock_irqsave(&reset_fnic_list_lock, reset_fnic_list_lock_flags);
+	list_for_each_entry_safe(cur_fnic, next_fnic, &reset_fnic_list, links) {
+		list_del(&cur_fnic->links);
+		spin_unlock_irqrestore(&reset_fnic_list_lock,
+							   reset_fnic_list_lock_flags);
+
+		dev_err(&cur_fnic->pdev->dev, "fnic: <%d>: issuing a host reset\n",
+			   cur_fnic->fnic_num);
+		host_reset_ret_code = fnic_host_reset(cur_fnic->host);
+		dev_err(&cur_fnic->pdev->dev,
+		   "fnic: <%d>: returned from host reset with status: %d\n",
+		   cur_fnic->fnic_num, host_reset_ret_code);
+
+		spin_lock_irqsave(&cur_fnic->fnic_lock, cur_fnic->lock_flags);
+		cur_fnic->pc_rscn_handling_status =
+			PC_RSCN_HANDLING_NOT_IN_PROGRESS;
+		spin_unlock_irqrestore(&cur_fnic->fnic_lock, cur_fnic->lock_flags);
+
+		spin_lock_irqsave(&reset_fnic_list_lock,
+						  reset_fnic_list_lock_flags);
+	}
+	spin_unlock_irqrestore(&reset_fnic_list_lock,
+						   reset_fnic_list_lock_flags);
+}
* Unmerged path drivers/scsi/fnic/fnic_main.c
