arp: Convert ioctl(SIOCGARP) to RCU.

jira LE-2742
Rebuild_History Non-Buildable kernel-5.14.0-503.31.1.el9_5
commit-author Kuniyuki Iwashima <kuniyu@amazon.com>
commit bf4ea58874df3d43f7264709cec7fe320616552c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-503.31.1.el9_5/bf4ea588.failed

ioctl(SIOCGARP) holds rtnl_lock() to get netdev by __dev_get_by_name()
and copy dev->name safely and calls neigh_lookup() later, which looks
up a neighbour entry under RCU.

Let's replace __dev_get_by_name() with dev_get_by_name_rcu() and strscpy()
with netdev_copy_name() to avoid locking rtnl_lock().

	Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Link: https://lore.kernel.org/r/20240430015813.71143-8-kuniyu@amazon.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit bf4ea58874df3d43f7264709cec7fe320616552c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/arp.c
diff --cc net/ipv4/arp.c
index 58c3109e7758,11c1519b3699..000000000000
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@@ -981,6 -1003,55 +981,58 @@@ out_of_mem
   *	User level interface (ioctl)
   */
  
++<<<<<<< HEAD
++=======
+ static struct net_device *arp_req_dev_by_name(struct net *net, struct arpreq *r,
+ 					      bool getarp)
+ {
+ 	struct net_device *dev;
+ 
+ 	if (getarp)
+ 		dev = dev_get_by_name_rcu(net, r->arp_dev);
+ 	else
+ 		dev = __dev_get_by_name(net, r->arp_dev);
+ 	if (!dev)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	/* Mmmm... It is wrong... ARPHRD_NETROM == 0 */
+ 	if (!r->arp_ha.sa_family)
+ 		r->arp_ha.sa_family = dev->type;
+ 
+ 	if ((r->arp_flags & ATF_COM) && r->arp_ha.sa_family != dev->type)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return dev;
+ }
+ 
+ static struct net_device *arp_req_dev(struct net *net, struct arpreq *r)
+ {
+ 	struct net_device *dev;
+ 	struct rtable *rt;
+ 	__be32 ip;
+ 
+ 	if (r->arp_dev[0])
+ 		return arp_req_dev_by_name(net, r, false);
+ 
+ 	if (r->arp_flags & ATF_PUBL)
+ 		return NULL;
+ 
+ 	ip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;
+ 
+ 	rt = ip_route_output(net, ip, 0, 0, 0, RT_SCOPE_LINK);
+ 	if (IS_ERR(rt))
+ 		return ERR_CAST(rt);
+ 
+ 	dev = rt->dst.dev;
+ 	ip_rt_put(rt);
+ 
+ 	if (!dev)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return dev;
+ }
+ 
++>>>>>>> bf4ea58874df (arp: Convert ioctl(SIOCGARP) to RCU.)
  /*
   *	Set (create) an ARP cache entry.
   */
@@@ -1100,23 -1165,36 +1152,50 @@@ static int arp_req_get(struct arpreq *r
  {
  	__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;
  	struct neighbour *neigh;
++<<<<<<< HEAD
 +	int err = -ENXIO;
++=======
+ 	struct net_device *dev;
+ 
+ 	if (!r->arp_dev[0])
+ 		return -ENODEV;
+ 
+ 	dev = arp_req_dev_by_name(net, r, true);
+ 	if (IS_ERR(dev))
+ 		return PTR_ERR(dev);
++>>>>>>> bf4ea58874df (arp: Convert ioctl(SIOCGARP) to RCU.)
  
  	neigh = neigh_lookup(&arp_tbl, &ip, dev);
 -	if (!neigh)
 -		return -ENXIO;
 -
 -	if (READ_ONCE(neigh->nud_state) & NUD_NOARP) {
 +	if (neigh) {
 +		if (!(READ_ONCE(neigh->nud_state) & NUD_NOARP)) {
 +			read_lock_bh(&neigh->lock);
 +			memcpy(r->arp_ha.sa_data, neigh->ha,
 +			       min((size_t)dev->addr_len, sizeof(r->arp_ha.sa_data)));
 +			r->arp_flags = arp_state_to_flags(neigh);
 +			read_unlock_bh(&neigh->lock);
 +			r->arp_ha.sa_family = dev->type;
 +			strlcpy(r->arp_dev, dev->name, sizeof(r->arp_dev));
 +			err = 0;
 +		}
  		neigh_release(neigh);
 -		return -ENXIO;
  	}
++<<<<<<< HEAD
 +	return err;
++=======
+ 
+ 	read_lock_bh(&neigh->lock);
+ 	memcpy(r->arp_ha.sa_data, neigh->ha,
+ 	       min(dev->addr_len, sizeof(r->arp_ha.sa_data_min)));
+ 	r->arp_flags = arp_state_to_flags(neigh);
+ 	read_unlock_bh(&neigh->lock);
+ 
+ 	neigh_release(neigh);
+ 
+ 	r->arp_ha.sa_family = dev->type;
+ 	netdev_copy_name(dev, r->arp_dev);
+ 
+ 	return 0;
++>>>>>>> bf4ea58874df (arp: Convert ioctl(SIOCGARP) to RCU.)
  }
  
  int arp_invalidate(struct net_device *dev, __be32 ip, bool force)
@@@ -1218,39 -1291,27 +1297,63 @@@ int arp_ioctl(struct net *net, unsigne
  	else if (*netmask && *netmask != htonl(0xFFFFFFFFUL))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	rtnl_lock();
 +	if (r.arp_dev[0]) {
 +		err = -ENODEV;
 +		dev = __dev_get_by_name(net, r.arp_dev);
 +		if (!dev)
 +			goto out;
 +
 +		/* Mmmm... It is wrong... ARPHRD_NETROM==0 */
 +		if (!r.arp_ha.sa_family)
 +			r.arp_ha.sa_family = dev->type;
 +		err = -EINVAL;
 +		if ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)
 +			goto out;
 +	} else if (cmd == SIOCGARP) {
 +		err = -ENODEV;
 +		goto out;
 +	}
 +
 +	switch (cmd) {
 +	case SIOCDARP:
 +		err = arp_req_delete(net, &r, dev);
 +		break;
 +	case SIOCSARP:
 +		err = arp_req_set(net, &r, dev);
 +		break;
 +	case SIOCGARP:
 +		err = arp_req_get(&r, dev);
 +		break;
 +	}
 +out:
 +	rtnl_unlock();
 +	if (cmd == SIOCGARP && !err && copy_to_user(arg, &r, sizeof(r)))
 +		err = -EFAULT;
++=======
+ 	switch (cmd) {
+ 	case SIOCDARP:
+ 		rtnl_lock();
+ 		err = arp_req_delete(net, &r);
+ 		rtnl_unlock();
+ 		break;
+ 	case SIOCSARP:
+ 		rtnl_lock();
+ 		err = arp_req_set(net, &r);
+ 		rtnl_unlock();
+ 		break;
+ 	case SIOCGARP:
+ 		rcu_read_lock();
+ 		err = arp_req_get(net, &r);
+ 		rcu_read_unlock();
+ 
+ 		if (!err && copy_to_user(arg, &r, sizeof(r)))
+ 			err = -EFAULT;
+ 		break;
+ 	}
+ 
++>>>>>>> bf4ea58874df (arp: Convert ioctl(SIOCGARP) to RCU.)
  	return err;
  }
  
* Unmerged path net/ipv4/arp.c
