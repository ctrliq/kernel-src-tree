string.h: Introduce memset_startat() for wiping trailing members and padding

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Kees Cook <keescook@chromium.org>
commit 6dbefad40815a61aecbcf9b552e87ef57ab8cc7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/6dbefad4.failed

A common idiom in kernel code is to wipe the contents of a structure
starting from a given member. These open-coded cases are usually difficult
to read and very sensitive to struct layout changes. Like memset_after(),
introduce a new helper, memset_startat() that takes the target struct
instance, the byte to write, and the member name where zeroing should
start.

Note that this doesn't zero padding preceding the target member. For
those cases, memset_after() should be used on the preceding member.

	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: Herbert Xu <herbert@gondor.apana.org.au>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Jakub Kicinski <kuba@kernel.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Francis Laniel <laniel_francis@privacyrequired.com>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Daniel Axtens <dja@axtens.net>
	Cc: netdev@vger.kernel.org
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 6dbefad40815a61aecbcf9b552e87ef57ab8cc7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/string.h
#	lib/memcpy_kunit.c
diff --cc include/linux/string.h
index b0bfaa82808b,5a36608144a9..000000000000
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@@ -516,6 -272,41 +516,44 @@@ static inline void memcpy_and_pad(void 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * memset_after - Set a value after a struct member to the end of a struct
+  *
+  * @obj: Address of target struct instance
+  * @v: Byte value to repeatedly write
+  * @member: after which struct member to start writing bytes
+  *
+  * This is good for clearing padding following the given member.
+  */
+ #define memset_after(obj, v, member)					\
+ ({									\
+ 	u8 *__ptr = (u8 *)(obj);					\
+ 	typeof(v) __val = (v);						\
+ 	memset(__ptr + offsetofend(typeof(*(obj)), member), __val,	\
+ 	       sizeof(*(obj)) - offsetofend(typeof(*(obj)), member));	\
+ })
+ 
+ /**
+  * memset_startat - Set a value starting at a member to the end of a struct
+  *
+  * @obj: Address of target struct instance
+  * @v: Byte value to repeatedly write
+  * @member: struct member to start writing at
+  *
+  * Note that if there is padding between the prior member and the target
+  * member, memset_after() should be used to clear the prior padding.
+  */
+ #define memset_startat(obj, v, member)					\
+ ({									\
+ 	u8 *__ptr = (u8 *)(obj);					\
+ 	typeof(v) __val = (v);						\
+ 	memset(__ptr + offsetof(typeof(*(obj)), member), __val,		\
+ 	       sizeof(*(obj)) - offsetof(typeof(*(obj)), member));	\
+ })
+ 
+ /**
++>>>>>>> 6dbefad40815 (string.h: Introduce memset_startat() for wiping trailing members and padding)
   * str_has_prefix - Test if a string has a given prefix
   * @str: The string to test
   * @prefix: The string to see if @str starts with
* Unmerged path lib/memcpy_kunit.c
* Unmerged path include/linux/string.h
* Unmerged path lib/memcpy_kunit.c
