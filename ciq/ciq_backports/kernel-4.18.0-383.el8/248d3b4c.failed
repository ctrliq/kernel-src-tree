net/mlx5e: Support flow classification into RSS contexts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit 248d3b4c9a396f89da43ec7f6becf377e69efeca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/248d3b4c.failed

Extend the existing flow classification support, to steer
flows not only directly to a receive ring, but also into
the new RSS contexts.

Create needed TIR objects on demand, and hold reference
on the RSS context.

	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 248d3b4c9a396f89da43ec7f6becf377e69efeca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
index 80d9748a46f1,bf0313e2682b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
@@@ -99,6 -31,244 +99,247 @@@ struct mlx5e_rx_res 
  	} ptp;
  };
  
++<<<<<<< HEAD
++=======
+ /* API for rx_res_rss_* */
+ 
+ static int mlx5e_rx_res_rss_init_def(struct mlx5e_rx_res *res,
+ 				     const struct mlx5e_lro_param *init_lro_param,
+ 				     unsigned int init_nch)
+ {
+ 	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
+ 	struct mlx5e_rss *rss;
+ 	int err;
+ 
+ 	if (WARN_ON(res->rss[0]))
+ 		return -EINVAL;
+ 
+ 	rss = mlx5e_rss_alloc();
+ 	if (!rss)
+ 		return -ENOMEM;
+ 
+ 	err = mlx5e_rss_init(rss, res->mdev, inner_ft_support, res->drop_rqn,
+ 			     init_lro_param);
+ 	if (err)
+ 		goto err_rss_free;
+ 
+ 	mlx5e_rss_set_indir_uniform(rss, init_nch);
+ 
+ 	res->rss[0] = rss;
+ 
+ 	return 0;
+ 
+ err_rss_free:
+ 	mlx5e_rss_free(rss);
+ 	return err;
+ }
+ 
+ int mlx5e_rx_res_rss_init(struct mlx5e_rx_res *res, u32 *rss_idx, unsigned int init_nch)
+ {
+ 	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
+ 	struct mlx5e_rss *rss;
+ 	int err, i;
+ 
+ 	for (i = 1; i < MLX5E_MAX_NUM_RSS; i++)
+ 		if (!res->rss[i])
+ 			break;
+ 
+ 	if (i == MLX5E_MAX_NUM_RSS)
+ 		return -ENOSPC;
+ 
+ 	rss = mlx5e_rss_alloc();
+ 	if (!rss)
+ 		return -ENOMEM;
+ 
+ 	err = mlx5e_rss_init_no_tirs(rss, res->mdev, inner_ft_support, res->drop_rqn);
+ 	if (err)
+ 		goto err_rss_free;
+ 
+ 	mlx5e_rss_set_indir_uniform(rss, init_nch);
+ 	if (res->rss_active)
+ 		mlx5e_rss_enable(rss, res->rss_rqns, res->rss_nch);
+ 
+ 	res->rss[i] = rss;
+ 	*rss_idx = i;
+ 
+ 	return 0;
+ 
+ err_rss_free:
+ 	mlx5e_rss_free(rss);
+ 	return err;
+ }
+ 
+ static int __mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx)
+ {
+ 	struct mlx5e_rss *rss = res->rss[rss_idx];
+ 	int err;
+ 
+ 	err = mlx5e_rss_cleanup(rss);
+ 	if (err)
+ 		return err;
+ 
+ 	mlx5e_rss_free(rss);
+ 	res->rss[rss_idx] = NULL;
+ 
+ 	return 0;
+ }
+ 
+ int mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx)
+ {
+ 	struct mlx5e_rss *rss;
+ 
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return -EINVAL;
+ 
+ 	rss = res->rss[rss_idx];
+ 	if (!rss)
+ 		return -EINVAL;
+ 
+ 	return __mlx5e_rx_res_rss_destroy(res, rss_idx);
+ }
+ 
+ static void mlx5e_rx_res_rss_destroy_all(struct mlx5e_rx_res *res)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {
+ 		struct mlx5e_rss *rss = res->rss[i];
+ 		int err;
+ 
+ 		if (!rss)
+ 			continue;
+ 
+ 		err = __mlx5e_rx_res_rss_destroy(res, i);
+ 		if (err) {
+ 			unsigned int refcount;
+ 
+ 			refcount = mlx5e_rss_refcnt_read(rss);
+ 			mlx5_core_warn(res->mdev,
+ 				       "Failed to destroy RSS context %d, refcount = %u, err = %d\n",
+ 				       i, refcount, err);
+ 		}
+ 	}
+ }
+ 
+ static void mlx5e_rx_res_rss_enable(struct mlx5e_rx_res *res)
+ {
+ 	int i;
+ 
+ 	res->rss_active = true;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {
+ 		struct mlx5e_rss *rss = res->rss[i];
+ 
+ 		if (!rss)
+ 			continue;
+ 		mlx5e_rss_enable(rss, res->rss_rqns, res->rss_nch);
+ 	}
+ }
+ 
+ static void mlx5e_rx_res_rss_disable(struct mlx5e_rx_res *res)
+ {
+ 	int i;
+ 
+ 	res->rss_active = false;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {
+ 		struct mlx5e_rss *rss = res->rss[i];
+ 
+ 		if (!rss)
+ 			continue;
+ 		mlx5e_rss_disable(rss);
+ 	}
+ }
+ 
+ /* Updates the indirection table SW shadow, does not update the HW resources yet */
+ void mlx5e_rx_res_rss_set_indir_uniform(struct mlx5e_rx_res *res, unsigned int nch)
+ {
+ 	WARN_ON_ONCE(res->rss_active);
+ 	mlx5e_rss_set_indir_uniform(res->rss[0], nch);
+ }
+ 
+ int mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,
+ 			      u32 *indir, u8 *key, u8 *hfunc)
+ {
+ 	struct mlx5e_rss *rss;
+ 
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return -EINVAL;
+ 
+ 	rss = res->rss[rss_idx];
+ 	if (!rss)
+ 		return -ENOENT;
+ 
+ 	return mlx5e_rss_get_rxfh(rss, indir, key, hfunc);
+ }
+ 
+ int mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,
+ 			      const u32 *indir, const u8 *key, const u8 *hfunc)
+ {
+ 	struct mlx5e_rss *rss;
+ 
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return -EINVAL;
+ 
+ 	rss = res->rss[rss_idx];
+ 	if (!rss)
+ 		return -ENOENT;
+ 
+ 	return mlx5e_rss_set_rxfh(rss, indir, key, hfunc, res->rss_rqns, res->rss_nch);
+ }
+ 
+ u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
+ {
+ 	struct mlx5e_rss *rss = res->rss[0];
+ 
+ 	return mlx5e_rss_get_hash_fields(rss, tt);
+ }
+ 
+ int mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt,
+ 				     u8 rx_hash_fields)
+ {
+ 	struct mlx5e_rss *rss = res->rss[0];
+ 
+ 	return mlx5e_rss_set_hash_fields(rss, tt, rx_hash_fields);
+ }
+ 
+ int mlx5e_rx_res_rss_cnt(struct mlx5e_rx_res *res)
+ {
+ 	int i, cnt;
+ 
+ 	cnt = 0;
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++)
+ 		if (res->rss[i])
+ 			cnt++;
+ 
+ 	return cnt;
+ }
+ 
+ int mlx5e_rx_res_rss_index(struct mlx5e_rx_res *res, struct mlx5e_rss *rss)
+ {
+ 	int i;
+ 
+ 	if (!rss)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++)
+ 		if (rss == res->rss[i])
+ 			return i;
+ 
+ 	return -ENOENT;
+ }
+ 
+ struct mlx5e_rss *mlx5e_rx_res_rss_get(struct mlx5e_rx_res *res, u32 rss_idx)
+ {
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return NULL;
+ 
+ 	return res->rss[rss_idx];
+ }
+ 
+ /* End of API rx_res_rss_* */
+ 
++>>>>>>> 248d3b4c9a39 (net/mlx5e: Support flow classification into RSS contexts)
  struct mlx5e_rx_res *mlx5e_rx_res_alloc(void)
  {
  	return kvzalloc(sizeof(struct mlx5e_rx_res), GFP_KERNEL);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
index 934e41a0761f,4a15942d79f7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
@@@ -61,6 -59,12 +61,15 @@@ int mlx5e_rx_res_rss_set_hash_fields(st
  				     u8 rx_hash_fields);
  int mlx5e_rx_res_lro_set_param(struct mlx5e_rx_res *res, struct mlx5e_lro_param *lro_param);
  
++<<<<<<< HEAD
++=======
+ int mlx5e_rx_res_rss_init(struct mlx5e_rx_res *res, u32 *rss_idx, unsigned int init_nch);
+ int mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx);
+ int mlx5e_rx_res_rss_cnt(struct mlx5e_rx_res *res);
+ int mlx5e_rx_res_rss_index(struct mlx5e_rx_res *res, struct mlx5e_rss *rss);
+ struct mlx5e_rss *mlx5e_rx_res_rss_get(struct mlx5e_rx_res *res, u32 rss_idx);
+ 
++>>>>>>> 248d3b4c9a39 (net/mlx5e: Support flow classification into RSS contexts)
  /* Workaround for hairpin */
  struct mlx5e_rss_params_hash mlx5e_rx_res_get_current_hash(struct mlx5e_rx_res *res);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
index c057f830a15d..00ad0d0c456d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
@@ -35,11 +35,19 @@
 #include "en/params.h"
 #include "en/xsk/pool.h"
 
+static int flow_type_to_traffic_type(u32 flow_type);
+
+static u32 flow_type_mask(u32 flow_type)
+{
+	return flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS);
+}
+
 struct mlx5e_ethtool_rule {
 	struct list_head             list;
 	struct ethtool_rx_flow_spec  flow_spec;
 	struct mlx5_flow_handle	     *rule;
 	struct mlx5e_ethtool_table   *eth_ft;
+	struct mlx5e_rss             *rss;
 };
 
 static void put_flow_table(struct mlx5e_ethtool_table *eth_ft)
@@ -66,7 +74,7 @@ static struct mlx5e_ethtool_table *get_flow_table(struct mlx5e_priv *priv,
 	int table_size;
 	int prio;
 
-	switch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {
+	switch (flow_type_mask(fs->flow_type)) {
 	case TCP_V4_FLOW:
 	case UDP_V4_FLOW:
 	case TCP_V6_FLOW:
@@ -329,7 +337,7 @@ static int set_flow_attrs(u32 *match_c, u32 *match_v,
 					     outer_headers);
 	void *outer_headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
 					     outer_headers);
-	u32 flow_type = fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT);
+	u32 flow_type = flow_type_mask(fs->flow_type);
 
 	switch (flow_type) {
 	case TCP_V4_FLOW:
@@ -397,10 +405,53 @@ static bool outer_header_zero(u32 *match_criteria)
 						  size - 1);
 }
 
+static int flow_get_tirn(struct mlx5e_priv *priv,
+			 struct mlx5e_ethtool_rule *eth_rule,
+			 struct ethtool_rx_flow_spec *fs,
+			 u32 rss_context, u32 *tirn)
+{
+	if (fs->flow_type & FLOW_RSS) {
+		struct mlx5e_lro_param lro_param;
+		struct mlx5e_rss *rss;
+		u32 flow_type;
+		int err;
+		int tt;
+
+		rss = mlx5e_rx_res_rss_get(priv->rx_res, rss_context);
+		if (!rss)
+			return -ENOENT;
+
+		flow_type = flow_type_mask(fs->flow_type);
+		tt = flow_type_to_traffic_type(flow_type);
+		if (tt < 0)
+			return -EINVAL;
+
+		lro_param = mlx5e_get_lro_param(&priv->channels.params);
+		err = mlx5e_rss_obtain_tirn(rss, tt, &lro_param, false, tirn);
+		if (err)
+			return err;
+		eth_rule->rss = rss;
+		mlx5e_rss_refcnt_inc(eth_rule->rss);
+	} else {
+		struct mlx5e_params *params = &priv->channels.params;
+		enum mlx5e_rq_group group;
+		u16 ix;
+
+		mlx5e_qid_get_ch_and_group(params, fs->ring_cookie, &ix, &group);
+
+		*tirn = group == MLX5E_RQ_GROUP_XSK ?
+			mlx5e_rx_res_get_tirn_xsk(priv->rx_res, ix) :
+			mlx5e_rx_res_get_tirn_direct(priv->rx_res, ix);
+	}
+
+	return 0;
+}
+
 static struct mlx5_flow_handle *
 add_ethtool_flow_rule(struct mlx5e_priv *priv,
+		      struct mlx5e_ethtool_rule *eth_rule,
 		      struct mlx5_flow_table *ft,
-		      struct ethtool_rx_flow_spec *fs)
+		      struct ethtool_rx_flow_spec *fs, u32 rss_context)
 {
 	struct mlx5_flow_act flow_act = { .flags = FLOW_ACT_NO_APPEND };
 	struct mlx5_flow_destination *dst = NULL;
@@ -419,23 +470,17 @@ add_ethtool_flow_rule(struct mlx5e_priv *priv,
 	if (fs->ring_cookie == RX_CLS_FLOW_DISC) {
 		flow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;
 	} else {
-		struct mlx5e_params *params = &priv->channels.params;
-		enum mlx5e_rq_group group;
-		u16 ix;
-
-		mlx5e_qid_get_ch_and_group(params, fs->ring_cookie, &ix, &group);
-
 		dst = kzalloc(sizeof(*dst), GFP_KERNEL);
 		if (!dst) {
 			err = -ENOMEM;
 			goto free;
 		}
 
+		err = flow_get_tirn(priv, eth_rule, fs, rss_context, &dst->tir_num);
+		if (err)
+			goto free;
+
 		dst->type = MLX5_FLOW_DESTINATION_TYPE_TIR;
-		if (group == MLX5E_RQ_GROUP_XSK)
-			dst->tir_num = mlx5e_rx_res_get_tirn_xsk(priv->rx_res, ix);
-		else
-			dst->tir_num = mlx5e_rx_res_get_tirn_direct(priv->rx_res, ix);
 		flow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 	}
 
@@ -459,6 +504,8 @@ static void del_ethtool_rule(struct mlx5e_priv *priv,
 {
 	if (eth_rule->rule)
 		mlx5_del_flow_rules(eth_rule->rule);
+	if (eth_rule->rss)
+		mlx5e_rss_refcnt_dec(eth_rule->rss);
 	list_del(&eth_rule->list);
 	priv->fs.ethtool.tot_num_rules--;
 	put_flow_table(eth_rule->eth_ft);
@@ -619,7 +666,7 @@ static int validate_flow(struct mlx5e_priv *priv,
 					fs->ring_cookie))
 			return -EINVAL;
 
-	switch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {
+	switch (flow_type_mask(fs->flow_type)) {
 	case ETHER_FLOW:
 		num_tuples += validate_ethter(fs);
 		break;
@@ -668,7 +715,7 @@ static int validate_flow(struct mlx5e_priv *priv,
 
 static int
 mlx5e_ethtool_flow_replace(struct mlx5e_priv *priv,
-			   struct ethtool_rx_flow_spec *fs)
+			   struct ethtool_rx_flow_spec *fs, u32 rss_context)
 {
 	struct mlx5e_ethtool_table *eth_ft;
 	struct mlx5e_ethtool_rule *eth_rule;
@@ -699,7 +746,7 @@ mlx5e_ethtool_flow_replace(struct mlx5e_priv *priv,
 		err = -EINVAL;
 		goto del_ethtool_rule;
 	}
-	rule = add_ethtool_flow_rule(priv, eth_ft->ft, fs);
+	rule = add_ethtool_flow_rule(priv, eth_rule, eth_ft->ft, fs, rss_context);
 	if (IS_ERR(rule)) {
 		err = PTR_ERR(rule);
 		goto del_ethtool_rule;
@@ -745,10 +792,20 @@ mlx5e_ethtool_get_flow(struct mlx5e_priv *priv,
 		return -EINVAL;
 
 	list_for_each_entry(eth_rule, &priv->fs.ethtool.rules, list) {
-		if (eth_rule->flow_spec.location == location) {
-			info->fs = eth_rule->flow_spec;
+		int index;
+
+		if (eth_rule->flow_spec.location != location)
+			continue;
+		if (!info)
 			return 0;
-		}
+		info->fs = eth_rule->flow_spec;
+		if (!eth_rule->rss)
+			return 0;
+		index = mlx5e_rx_res_rss_index(priv->rx_res, eth_rule->rss);
+		if (index < 0)
+			return index;
+		info->rss_context = index;
+		return 0;
 	}
 
 	return -ENOENT;
@@ -764,7 +821,7 @@ mlx5e_ethtool_get_all_flows(struct mlx5e_priv *priv,
 
 	info->data = MAX_NUM_OF_ETHTOOL_RULES;
 	while ((!err || err == -ENOENT) && idx < info->rule_cnt) {
-		err = mlx5e_ethtool_get_flow(priv, info, location);
+		err = mlx5e_ethtool_get_flow(priv, NULL, location);
 		if (!err)
 			rule_locs[idx++] = location;
 		location++;
@@ -887,7 +944,7 @@ int mlx5e_ethtool_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
 
 	switch (cmd->cmd) {
 	case ETHTOOL_SRXCLSRLINS:
-		err = mlx5e_ethtool_flow_replace(priv, &cmd->fs);
+		err = mlx5e_ethtool_flow_replace(priv, &cmd->fs, cmd->rss_context);
 		break;
 	case ETHTOOL_SRXCLSRLDEL:
 		err = mlx5e_ethtool_flow_remove(priv, cmd->fs.location);
