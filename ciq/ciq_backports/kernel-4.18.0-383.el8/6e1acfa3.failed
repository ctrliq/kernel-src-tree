netfilter: nf_tables: validate registers coming from userspace.

jira LE-1907
cve CVE-2022-1015
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6e1acfa387b9ff82cfc7db8cc3b6959221a95851
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/6e1acfa3.failed

Bail out in case userspace uses unsupported registers.

Fixes: 49499c3e6e18 ("netfilter: nf_tables: switch registers to 32 bit addressing")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6e1acfa387b9ff82cfc7db8cc3b6959221a95851)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index aa095db8d0ca,1f5a0eece0d1..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -8264,28 -9275,24 +8264,38 @@@ int nft_parse_u32_check(const struct nl
  }
  EXPORT_SYMBOL_GPL(nft_parse_u32_check);
  
++<<<<<<< HEAD
 +/**
 + *	nft_parse_register - parse a register value from a netlink attribute
 + *
 + *	@attr: netlink attribute
 + *
 + *	Parse and translate a register value from a netlink attribute.
 + *	Registers used to be 128 bit wide, these register numbers will be
 + *	mapped to the corresponding 32 bit register numbers.
 + */
 +unsigned int nft_parse_register(const struct nlattr *attr)
++=======
+ static unsigned int nft_parse_register(const struct nlattr *attr, u32 *preg)
++>>>>>>> 6e1acfa387b9 (netfilter: nf_tables: validate registers coming from userspace.)
  {
  	unsigned int reg;
  
  	reg = ntohl(nla_get_be32(attr));
  	switch (reg) {
  	case NFT_REG_VERDICT...NFT_REG_4:
- 		return reg * NFT_REG_SIZE / NFT_REG32_SIZE;
+ 		*preg = reg * NFT_REG_SIZE / NFT_REG32_SIZE;
+ 		break;
+ 	case NFT_REG32_00...NFT_REG32_15:
+ 		*preg = reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
+ 		break;
  	default:
- 		return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
+ 		return -ERANGE;
  	}
+ 
+ 	return 0;
  }
 +EXPORT_SYMBOL_GPL(nft_parse_register);
  
  /**
   *	nft_dump_register - dump a register value to a netlink attribute
@@@ -8329,26 -9327,30 +8339,52 @@@ int nft_validate_register_load(enum nft
  
  	return 0;
  }
 +EXPORT_SYMBOL_GPL(nft_validate_register_load);
  
++<<<<<<< HEAD
 +/**
 + *	nft_validate_register_store - validate an expressions' register store
 + *
 + *	@ctx: context of the expression performing the load
 + * 	@reg: the destination register number
 + * 	@data: the data to load
 + * 	@type: the data type
 + * 	@len: the length of the data
 + *
 + * 	Validate that a data load uses the appropriate data type for
 + * 	the destination register and the length is within the bounds.
 + * 	A value of NULL for the data means that its runtime gathered
 + * 	data.
 + */
 +int nft_validate_register_store(const struct nft_ctx *ctx,
 +				enum nft_registers reg,
 +				const struct nft_data *data,
 +				enum nft_data_types type, unsigned int len)
++=======
+ int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)
+ {
+ 	u32 reg;
+ 	int err;
+ 
+ 	err = nft_parse_register(attr, &reg);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = nft_validate_register_load(reg, len);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	*sreg = reg;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nft_parse_register_load);
+ 
+ static int nft_validate_register_store(const struct nft_ctx *ctx,
+ 				       enum nft_registers reg,
+ 				       const struct nft_data *data,
+ 				       enum nft_data_types type,
+ 				       unsigned int len)
++>>>>>>> 6e1acfa387b9 (netfilter: nf_tables: validate registers coming from userspace.)
  {
  	int err;
  
@@@ -8380,7 -9382,27 +8416,31 @@@
  		return 0;
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(nft_validate_register_store);
++=======
+ 
+ int nft_parse_register_store(const struct nft_ctx *ctx,
+ 			     const struct nlattr *attr, u8 *dreg,
+ 			     const struct nft_data *data,
+ 			     enum nft_data_types type, unsigned int len)
+ {
+ 	int err;
+ 	u32 reg;
+ 
+ 	err = nft_parse_register(attr, &reg);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = nft_validate_register_store(ctx, reg, data, type, len);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	*dreg = reg;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nft_parse_register_store);
++>>>>>>> 6e1acfa387b9 (netfilter: nf_tables: validate registers coming from userspace.)
  
  static const struct nla_policy nft_verdict_policy[NFTA_VERDICT_MAX + 1] = {
  	[NFTA_VERDICT_CODE]	= { .type = NLA_U32 },
* Unmerged path net/netfilter/nf_tables_api.c
