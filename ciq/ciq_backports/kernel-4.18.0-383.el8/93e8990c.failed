net: phy: rename PHY_IGNORE_INTERRUPT to PHY_MAC_INTERRUPT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 93e8990c24bee30696c02e8f6aed043333491a25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/93e8990c.failed

Some internal PHY's have their events like link change reported by the
MAC interrupt. We have PHY_IGNORE_INTERRUPT to deal with this scenario.
I'm not too happy with this name. We don't ignore interrupts, typically
there is no interrupt exposed at a PHY level. So let's rename it to
PHY_MAC_INTERRUPT. This is in line with phy_mac_interrupt(), which is
called from the MAC interrupt handler to handle PHY events.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Acked-by: Florian Fainelli <f.fainelli@gmail.com>
	Reviewed-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 93e8990c24bee30696c02e8f6aed043333491a25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/genet/bcmmii.c
#	drivers/net/ethernet/realtek/r8169_main.c
diff --cc drivers/net/ethernet/broadcom/genet/bcmmii.c
index 8f181b3c487c,5335244e4577..000000000000
--- a/drivers/net/ethernet/broadcom/genet/bcmmii.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmmii.c
@@@ -315,10 -353,13 +315,15 @@@ int bcmgenet_mii_probe(struct net_devic
  	linkmode_copy(phydev->advertising, phydev->supported);
  
  	/* The internal PHY has its link interrupts routed to the
 -	 * Ethernet MAC ISRs. On GENETv5 there is a hardware issue
 -	 * that prevents the signaling of link UP interrupts when
 -	 * the link operates at 10Mbps, so fallback to polling for
 -	 * those versions of GENET.
 +	 * Ethernet MAC ISRs
  	 */
++<<<<<<< HEAD
 +	if (priv->internal_phy)
 +		dev->phydev->irq = PHY_IGNORE_INTERRUPT;
++=======
+ 	if (priv->internal_phy && !GENET_IS_V5(priv))
+ 		dev->phydev->irq = PHY_MAC_INTERRUPT;
++>>>>>>> 93e8990c24be (net: phy: rename PHY_IGNORE_INTERRUPT to PHY_MAC_INTERRUPT)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/realtek/r8169_main.c
index dfa1eb77df8f,cbc30df4e08a..000000000000
--- a/drivers/net/ethernet/realtek/r8169_main.c
+++ b/drivers/net/ethernet/realtek/r8169_main.c
@@@ -5112,9 -5056,8 +5112,14 @@@ static int r8169_mdio_register(struct r
  	new_bus->name = "r8169";
  	new_bus->priv = tp;
  	new_bus->parent = &pdev->dev;
++<<<<<<< HEAD
 +	new_bus->irq[0] = PHY_IGNORE_INTERRUPT;
 +	snprintf(new_bus->id, MII_BUS_ID_SIZE, "r8169-%x-%x",
 +		 pci_domain_nr(pdev->bus), pci_dev_id(pdev));
++=======
+ 	new_bus->irq[0] = PHY_MAC_INTERRUPT;
+ 	snprintf(new_bus->id, MII_BUS_ID_SIZE, "r8169-%x", pci_dev_id(pdev));
++>>>>>>> 93e8990c24be (net: phy: rename PHY_IGNORE_INTERRUPT to PHY_MAC_INTERRUPT)
  
  	new_bus->read = r8169_mdio_read_reg;
  	new_bus->write = r8169_mdio_write_reg;
diff --git a/Documentation/networking/phy.rst b/Documentation/networking/phy.rst
index b2f7ec794bc8..23c70948a152 100644
--- a/Documentation/networking/phy.rst
+++ b/Documentation/networking/phy.rst
@@ -216,7 +216,7 @@ put into an unsupported state.
 Lastly, once the controller is ready to handle network traffic, you call
 phy_start(phydev).  This tells the PAL that you are ready, and configures the
 PHY to connect to the network. If the MAC interrupt of your network driver
-also handles PHY status changes, just set phydev->irq to PHY_IGNORE_INTERRUPT
+also handles PHY status changes, just set phydev->irq to PHY_MAC_INTERRUPT
 before you call phy_start and use phy_mac_interrupt() from the network
 driver. If you don't want to use interrupts, set phydev->irq to PHY_POLL.
 phy_start() enables the PHY interrupts (if applicable) and starts the
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmmii.c
* Unmerged path drivers/net/ethernet/realtek/r8169_main.c
diff --git a/drivers/net/ethernet/samsung/sxgbe/sxgbe_mdio.c b/drivers/net/ethernet/samsung/sxgbe/sxgbe_mdio.c
index 467ff7033606..d5f2f974dc3e 100644
--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_mdio.c
+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_mdio.c
@@ -206,8 +206,8 @@ int sxgbe_mdio_register(struct net_device *ndev)
 			case PHY_POLL:
 				irq_str = "POLL";
 				break;
-			case PHY_IGNORE_INTERRUPT:
-				irq_str = "IGNORE";
+			case PHY_MAC_INTERRUPT:
+				irq_str = "MAC";
 				break;
 			default:
 				sprintf(irq_num, "%d", phy->irq);
diff --git a/drivers/net/phy/icplus.c b/drivers/net/phy/icplus.c
index 993c2fe01e6e..a00a667454a9 100644
--- a/drivers/net/phy/icplus.c
+++ b/drivers/net/phy/icplus.c
@@ -188,7 +188,7 @@ static int ip175c_read_status(struct phy_device *phydev)
 		genphy_read_status(phydev);
 	else
 		/* Don't need to read status for switch ports */
-		phydev->irq = PHY_IGNORE_INTERRUPT;
+		phydev->irq = PHY_MAC_INTERRUPT;
 
 	return 0;
 }
diff --git a/drivers/net/phy/mdio-moxart.c b/drivers/net/phy/mdio-moxart.c
index b72c6d185175..f0cff584e176 100644
--- a/drivers/net/phy/mdio-moxart.c
+++ b/drivers/net/phy/mdio-moxart.c
@@ -125,7 +125,7 @@ static int moxart_mdio_probe(struct platform_device *pdev)
 	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-%d-mii", pdev->name, pdev->id);
 	bus->parent = &pdev->dev;
 
-	/* Setting PHY_IGNORE_INTERRUPT here even if it has no effect,
+	/* Setting PHY_MAC_INTERRUPT here even if it has no effect,
 	 * of_mdiobus_register() sets these PHY_POLL.
 	 * Ideally, the interrupt from MAC controller could be used to
 	 * detect link state changes, not polling, i.e. if there was
@@ -133,7 +133,7 @@ static int moxart_mdio_probe(struct platform_device *pdev)
 	 * interrupt handled in ethernet drivercode.
 	 */
 	for (i = 0; i < PHY_MAX_ADDR; i++)
-		bus->irq[i] = PHY_IGNORE_INTERRUPT;
+		bus->irq[i] = PHY_MAC_INTERRUPT;
 
 	data = bus->priv;
 	data->base = devm_platform_ioremap_resource(pdev, 0);
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 4e0c5e604593..ce603b1e39ca 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -1096,7 +1096,7 @@ void phy_state_machine(struct work_struct *work)
 	}
 
 	/* Only re-schedule a PHY state machine change if we are polling the
-	 * PHY, if PHY_IGNORE_INTERRUPT is set, then we will be moving
+	 * PHY, if PHY_MAC_INTERRUPT is set, then we will be moving
 	 * between states from phy_mac_interrupt().
 	 *
 	 * In state PHY_HALTED the PHY gets suspended, so rescheduling the
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 2a10b64942c2..df4a0adac769 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1165,8 +1165,8 @@ char *phy_attached_info_irq(struct phy_device *phydev)
 	case PHY_POLL:
 		irq_str = "POLL";
 		break;
-	case PHY_IGNORE_INTERRUPT:
-		irq_str = "IGNORE";
+	case PHY_MAC_INTERRUPT:
+		irq_str = "MAC";
 		break;
 	default:
 		snprintf(irq_num, sizeof(irq_num), "%d", phydev->irq);
diff --git a/include/linux/phy.h b/include/linux/phy.h
index e630cc93e7bc..4680db855ab7 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -79,11 +79,11 @@ extern const int phy_10gbit_features_array[1];
 
 /*
  * Set phydev->irq to PHY_POLL if interrupts are not supported,
- * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if
- * the attached driver handles the interrupt
+ * or not desired for this PHY.  Set to PHY_MAC_INTERRUPT if
+ * the attached MAC driver handles the interrupt
  */
 #define PHY_POLL		-1
-#define PHY_IGNORE_INTERRUPT	-2
+#define PHY_MAC_INTERRUPT	-2
 
 #define PHY_IS_INTERNAL		0x00000001
 #define PHY_RST_AFTER_CLK_EN	0x00000002
@@ -1159,11 +1159,11 @@ static inline int phy_clear_bits_mmd(struct phy_device *phydev, int devad,
  * @phydev: the phy_device struct
  *
  * NOTE: must be kept in sync with addition/removal of PHY_POLL and
- * PHY_IGNORE_INTERRUPT
+ * PHY_MAC_INTERRUPT
  */
 static inline bool phy_interrupt_is_valid(struct phy_device *phydev)
 {
-	return phydev->irq != PHY_POLL && phydev->irq != PHY_IGNORE_INTERRUPT;
+	return phydev->irq != PHY_POLL && phydev->irq != PHY_MAC_INTERRUPT;
 }
 
 /**
