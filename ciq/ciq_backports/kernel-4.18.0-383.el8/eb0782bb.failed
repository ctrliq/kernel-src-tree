ima: fix deadlock when traversing "ima_default_rules".

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author liqiong <liqiong@nfschina.com>
commit eb0782bbdfd0d7c4786216659277c3fd585afc0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/eb0782bb.failed

The current IMA ruleset is identified by the variable "ima_rules"
that default to "&ima_default_rules". When loading a custom policy
for the first time, the variable is updated to "&ima_policy_rules"
instead. That update isn't RCU-safe, and deadlocks are possible.
Indeed, some functions like ima_match_policy() may loop indefinitely
when traversing "ima_default_rules" with list_for_each_entry_rcu().

When iterating over the default ruleset back to head, if the list
head is "ima_default_rules", and "ima_rules" have been updated to
"&ima_policy_rules", the loop condition (&entry->list != ima_rules)
stays always true, traversing won't terminate, causing a soft lockup
and RCU stalls.

Introduce a temporary value for "ima_rules" when iterating over
the ruleset to avoid the deadlocks.

	Signed-off-by: liqiong <liqiong@nfschina.com>
	Reviewed-by: THOBY Simon <Simon.THOBY@viveris.fr>
Fixes: 38d859f991f3 ("IMA: policy can now be updated multiple times")
	Reported-by: kernel test robot <lkp@intel.com> (Fix sparse: incompatible types in comparison expression.)
	Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>
(cherry picked from commit eb0782bbdfd0d7c4786216659277c3fd585afc0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/integrity/ima/ima_policy.c
diff --cc security/integrity/ima/ima_policy.c
index cd7f59d50950,12e8adcd80a2..000000000000
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@@ -446,8 -675,9 +446,9 @@@ int ima_match_policy(struct inode *inod
  {
  	struct ima_rule_entry *entry;
  	int action = 0, actmask = flags | (flags << 1);
+ 	struct list_head *ima_rules_tmp;
  
 -	if (template_desc && !*template_desc)
 +	if (template_desc)
  		*template_desc = ima_template_desc_current();
  
  	rcu_read_lock();
@@@ -489,20 -724,53 +491,48 @@@
  	return action;
  }
  
 -/**
 - * ima_update_policy_flags() - Update global IMA variables
 - *
 - * Update ima_policy_flag and ima_setxattr_allowed_hash_algorithms
 - * based on the currently loaded policy.
 - *
 - * With ima_policy_flag, the decision to short circuit out of a function
 - * or not call the function in the first place can be made earlier.
 - *
 - * With ima_setxattr_allowed_hash_algorithms, the policy can restrict the
 - * set of hash algorithms accepted when updating the security.ima xattr of
 - * a file.
 - *
 - * Context: called after a policy update and at system initialization.
 +/*
 + * Initialize the ima_policy_flag variable based on the currently
 + * loaded policy.  Based on this flag, the decision to short circuit
 + * out of a function or not call the function in the first place
 + * can be made earlier.
   */
 -void ima_update_policy_flags(void)
 +void ima_update_policy_flag(void)
  {
  	struct ima_rule_entry *entry;
++<<<<<<< HEAD
 +
 +	list_for_each_entry(entry, ima_rules, list) {
++=======
+ 	int new_policy_flag = 0;
+ 	struct list_head *ima_rules_tmp;
+ 
+ 	rcu_read_lock();
+ 	ima_rules_tmp = rcu_dereference(ima_rules);
+ 	list_for_each_entry_rcu(entry, ima_rules_tmp, list) {
+ 		/*
+ 		 * SETXATTR_CHECK rules do not implement a full policy check
+ 		 * because rule checking would probably have an important
+ 		 * performance impact on setxattr(). As a consequence, only one
+ 		 * SETXATTR_CHECK can be active at a given time.
+ 		 * Because we want to preserve that property, we set out to use
+ 		 * atomic_cmpxchg. Either:
+ 		 * - the atomic was non-zero: a setxattr hash policy is
+ 		 *   already enforced, we do nothing
+ 		 * - the atomic was zero: no setxattr policy was set, enable
+ 		 *   the setxattr hash policy
+ 		 */
+ 		if (entry->func == SETXATTR_CHECK) {
+ 			atomic_cmpxchg(&ima_setxattr_allowed_hash_algorithms,
+ 				       0, entry->allowed_algos);
+ 			/* SETXATTR_CHECK doesn't impact ima_policy_flag */
+ 			continue;
+ 		}
+ 
++>>>>>>> eb0782bbdfd0 (ima: fix deadlock when traversing "ima_default_rules".)
  		if (entry->action & IMA_DO_MASK)
 -			new_policy_flag |= entry->action;
 +			ima_policy_flag |= entry->action;
  	}
 -	rcu_read_unlock();
  
  	ima_appraise |= (build_ima_appraise | temp_ima_appraise);
  	if (!ima_appraise)
@@@ -773,14 -1058,19 +803,26 @@@ static int ima_lsm_rule_init(struct ima
  		return -ENOMEM;
  
  	entry->lsm[lsm_rule].type = audit_type;
 -	result = ima_filter_rule_init(entry->lsm[lsm_rule].type, Audit_equal,
 -				      entry->lsm[lsm_rule].args_p,
 -				      &entry->lsm[lsm_rule].rule);
 +	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 +					   Audit_equal,
 +					   entry->lsm[lsm_rule].args_p,
 +					   &entry->lsm[lsm_rule].rule);
  	if (!entry->lsm[lsm_rule].rule) {
++<<<<<<< HEAD
 +		kfree(entry->lsm[lsm_rule].args_p);
 +		entry->lsm[lsm_rule].args_p = NULL;
 +		return -EINVAL;
++=======
+ 		pr_warn("rule for LSM \'%s\' is undefined\n",
+ 			entry->lsm[lsm_rule].args_p);
+ 
+ 		if (ima_rules == (struct list_head __rcu *)(&ima_default_rules)) {
+ 			kfree(entry->lsm[lsm_rule].args_p);
+ 			entry->lsm[lsm_rule].args_p = NULL;
+ 			result = -EINVAL;
+ 		} else
+ 			result = 0;
++>>>>>>> eb0782bbdfd0 (ima: fix deadlock when traversing "ima_default_rules".)
  	}
  
  	return result;
* Unmerged path security/integrity/ima/ima_policy.c
