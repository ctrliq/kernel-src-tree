libbpf: Remove unneeded check for flags during tc detach

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Kumar Kartikeya Dwivedi <memxor@gmail.com>
commit 4e164f8716853b879e2b1a21a12d54c57f11372e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/4e164f87.failed

Coverity complained about this being unreachable code. It is right
because we already enforce flags to be unset, so a check validating
the flag value is redundant.

Fixes: 715c5ce454a6 ("libbpf: Add low level TC-BPF management API")
	Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20210612023502.1283837-2-memxor@gmail.com
(cherry picked from commit 4e164f8716853b879e2b1a21a12d54c57f11372e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/netlink.c
diff --cc tools/lib/bpf/netlink.c
index 4676dcf5eae8,efbb50ad59d8..000000000000
--- a/tools/lib/bpf/netlink.c
+++ b/tools/lib/bpf/netlink.c
@@@ -346,37 -373,413 +346,245 @@@ int bpf_get_link_xdp_id(int ifindex, __
  	if (!ret)
  		*prog_id = get_xdp_id(&info, flags);
  
 -	return libbpf_err(ret);
 -}
 -
 -typedef int (*qdisc_config_t)(struct nlmsghdr *nh, struct tcmsg *t,
 -			      size_t maxsz);
 -
 -static int clsact_config(struct nlmsghdr *nh, struct tcmsg *t, size_t maxsz)
 -{
 -	t->tcm_parent = TC_H_CLSACT;
 -	t->tcm_handle = TC_H_MAKE(TC_H_CLSACT, 0);
 -
 -	return nlattr_add(nh, maxsz, TCA_KIND, "clsact", sizeof("clsact"));
 -}
 -
 -static int attach_point_to_config(struct bpf_tc_hook *hook,
 -				  qdisc_config_t *config)
 -{
 -	switch (OPTS_GET(hook, attach_point, 0)) {
 -	case BPF_TC_INGRESS:
 -	case BPF_TC_EGRESS:
 -	case BPF_TC_INGRESS | BPF_TC_EGRESS:
 -		if (OPTS_GET(hook, parent, 0))
 -			return -EINVAL;
 -		*config = &clsact_config;
 -		return 0;
 -	case BPF_TC_CUSTOM:
 -		return -EOPNOTSUPP;
 -	default:
 -		return -EINVAL;
 -	}
 -}
 -
 -static int tc_get_tcm_parent(enum bpf_tc_attach_point attach_point,
 -			     __u32 *parent)
 -{
 -	switch (attach_point) {
 -	case BPF_TC_INGRESS:
 -	case BPF_TC_EGRESS:
 -		if (*parent)
 -			return -EINVAL;
 -		*parent = TC_H_MAKE(TC_H_CLSACT,
 -				    attach_point == BPF_TC_INGRESS ?
 -				    TC_H_MIN_INGRESS : TC_H_MIN_EGRESS);
 -		break;
 -	case BPF_TC_CUSTOM:
 -		if (!*parent)
 -			return -EINVAL;
 -		break;
 -	default:
 -		return -EINVAL;
 -	}
 -	return 0;
 +	return ret;
  }
  
 -static int tc_qdisc_modify(struct bpf_tc_hook *hook, int cmd, int flags)
 +int libbpf_nl_get_link(int sock, unsigned int nl_pid,
 +		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie)
  {
 -	qdisc_config_t config;
 -	int ret;
  	struct {
 -		struct nlmsghdr nh;
 -		struct tcmsg tc;
 -		char buf[256];
 -	} req;
 -
 -	ret = attach_point_to_config(hook, &config);
 -	if (ret < 0)
 -		return ret;
 -
 -	memset(&req, 0, sizeof(req));
 -	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
 -	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
 -	req.nh.nlmsg_type  = cmd;
 -	req.tc.tcm_family  = AF_UNSPEC;
 -	req.tc.tcm_ifindex = OPTS_GET(hook, ifindex, 0);
 -
 -	ret = config(&req.nh, &req.tc, sizeof(req));
 -	if (ret < 0)
 -		return ret;
 -
 -	return libbpf_netlink_send_recv(&req.nh, NULL, NULL, NULL);
 -}
 -
 -static int tc_qdisc_create_excl(struct bpf_tc_hook *hook)
 -{
 -	return tc_qdisc_modify(hook, RTM_NEWQDISC, NLM_F_CREATE);
 -}
 -
 -static int tc_qdisc_delete(struct bpf_tc_hook *hook)
 -{
 -	return tc_qdisc_modify(hook, RTM_DELQDISC, 0);
 -}
 -
 -int bpf_tc_hook_create(struct bpf_tc_hook *hook)
 -{
 -	int ret;
 -
 -	if (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||
 -	    OPTS_GET(hook, ifindex, 0) <= 0)
 -		return libbpf_err(-EINVAL);
 -
 -	ret = tc_qdisc_create_excl(hook);
 -	return libbpf_err(ret);
 -}
 -
 -static int __bpf_tc_detach(const struct bpf_tc_hook *hook,
 -			   const struct bpf_tc_opts *opts,
 -			   const bool flush);
 -
 -int bpf_tc_hook_destroy(struct bpf_tc_hook *hook)
 -{
 -	if (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||
 -	    OPTS_GET(hook, ifindex, 0) <= 0)
 -		return libbpf_err(-EINVAL);
 -
 -	switch (OPTS_GET(hook, attach_point, 0)) {
 -	case BPF_TC_INGRESS:
 -	case BPF_TC_EGRESS:
 -		return libbpf_err(__bpf_tc_detach(hook, NULL, true));
 -	case BPF_TC_INGRESS | BPF_TC_EGRESS:
 -		return libbpf_err(tc_qdisc_delete(hook));
 -	case BPF_TC_CUSTOM:
 -		return libbpf_err(-EOPNOTSUPP);
 -	default:
 -		return libbpf_err(-EINVAL);
 -	}
 -}
 -
 -struct bpf_cb_ctx {
 -	struct bpf_tc_opts *opts;
 -	bool processed;
 -};
 -
 -static int __get_tc_info(void *cookie, struct tcmsg *tc, struct nlattr **tb,
 -			 bool unicast)
 -{
 -	struct nlattr *tbb[TCA_BPF_MAX + 1];
 -	struct bpf_cb_ctx *info = cookie;
 -
 -	if (!info || !info->opts)
 -		return -EINVAL;
 -	if (unicast && info->processed)
 -		return -EINVAL;
 -	if (!tb[TCA_OPTIONS])
 -		return NL_CONT;
 -
 -	libbpf_nla_parse_nested(tbb, TCA_BPF_MAX, tb[TCA_OPTIONS], NULL);
 -	if (!tbb[TCA_BPF_ID])
 -		return -EINVAL;
 -
 -	OPTS_SET(info->opts, prog_id, libbpf_nla_getattr_u32(tbb[TCA_BPF_ID]));
 -	OPTS_SET(info->opts, handle, tc->tcm_handle);
 -	OPTS_SET(info->opts, priority, TC_H_MAJ(tc->tcm_info) >> 16);
 -
 -	info->processed = true;
 -	return unicast ? NL_NEXT : NL_DONE;
 -}
 -
 -static int get_tc_info(struct nlmsghdr *nh, libbpf_dump_nlmsg_t fn,
 -		       void *cookie)
 -{
 -	struct tcmsg *tc = NLMSG_DATA(nh);
 -	struct nlattr *tb[TCA_MAX + 1];
 -
 -	libbpf_nla_parse(tb, TCA_MAX,
 -			 (struct nlattr *)((char *)tc + NLMSG_ALIGN(sizeof(*tc))),
 -			 NLMSG_PAYLOAD(nh, sizeof(*tc)), NULL);
 -	if (!tb[TCA_KIND])
 -		return NL_CONT;
 -	return __get_tc_info(cookie, tc, tb, nh->nlmsg_flags & NLM_F_ECHO);
 -}
 -
 -static int tc_add_fd_and_name(struct nlmsghdr *nh, size_t maxsz, int fd)
 -{
 -	struct bpf_prog_info info = {};
 -	__u32 info_len = sizeof(info);
 -	char name[256];
 -	int len, ret;
 -
 -	ret = bpf_obj_get_info_by_fd(fd, &info, &info_len);
 -	if (ret < 0)
 -		return ret;
 +		struct nlmsghdr nlh;
 +		struct ifinfomsg ifm;
 +	} req = {
 +		.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
 +		.nlh.nlmsg_type = RTM_GETLINK,
 +		.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,
 +		.ifm.ifi_family = AF_PACKET,
 +	};
 +	int seq = time(NULL);
  
 -	ret = nlattr_add(nh, maxsz, TCA_BPF_FD, &fd, sizeof(fd));
 -	if (ret < 0)
 -		return ret;
 -	len = snprintf(name, sizeof(name), "%s:[%u]", info.name, info.id);
 -	if (len < 0)
 +	req.nlh.nlmsg_seq = seq;
 +	if (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)
  		return -errno;
 -	if (len >= sizeof(name))
 -		return -ENAMETOOLONG;
 -	return nlattr_add(nh, maxsz, TCA_BPF_NAME, name, len + 1);
 -}
  
 -int bpf_tc_attach(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)
 -{
 -	__u32 protocol, bpf_flags, handle, priority, parent, prog_id, flags;
 -	int ret, ifindex, attach_point, prog_fd;
 -	struct bpf_cb_ctx info = {};
 -	struct nlattr *nla;
 -	struct {
 -		struct nlmsghdr nh;
 -		struct tcmsg tc;
 -		char buf[256];
 -	} req;
 +	return bpf_netlink_recv(sock, nl_pid, seq, __dump_link_nlmsg,
 +				dump_link_nlmsg, cookie);
 +}
  
 +/* RHEL-only, libbpf version workaround */
 +extern int bpf_get_link_xdp_info_v0_0_6(int ifindex, struct xdp_link_info *info,
 +					size_t info_size, __u32 flags)
 +	__attribute__((alias("bpf_get_link_xdp_info_v0_0_4")));
 +
++<<<<<<< HEAD
 +COMPAT_VERSION(bpf_get_link_xdp_info_v0_0_4,
 +	       bpf_get_link_xdp_info, LIBBPF_0.0.4)
 +DEFAULT_VERSION(bpf_get_link_xdp_info_v0_0_6,
 +	        bpf_get_link_xdp_info, LIBBPF_0.0.6)
++=======
+ 	if (!hook || !opts ||
+ 	    !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    !OPTS_VALID(opts, bpf_tc_opts))
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ifindex      = OPTS_GET(hook, ifindex, 0);
+ 	parent       = OPTS_GET(hook, parent, 0);
+ 	attach_point = OPTS_GET(hook, attach_point, 0);
+ 
+ 	handle       = OPTS_GET(opts, handle, 0);
+ 	priority     = OPTS_GET(opts, priority, 0);
+ 	prog_fd      = OPTS_GET(opts, prog_fd, 0);
+ 	prog_id      = OPTS_GET(opts, prog_id, 0);
+ 	flags        = OPTS_GET(opts, flags, 0);
+ 
+ 	if (ifindex <= 0 || !prog_fd || prog_id)
+ 		return libbpf_err(-EINVAL);
+ 	if (priority > UINT16_MAX)
+ 		return libbpf_err(-EINVAL);
+ 	if (flags & ~BPF_TC_F_REPLACE)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	flags = (flags & BPF_TC_F_REPLACE) ? NLM_F_REPLACE : NLM_F_EXCL;
+ 	protocol = ETH_P_ALL;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE |
+ 			     NLM_F_ECHO | flags;
+ 	req.nh.nlmsg_type  = RTM_NEWTFILTER;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = ifindex;
+ 	req.tc.tcm_handle  = handle;
+ 	req.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));
+ 
+ 	ret = tc_get_tcm_parent(attach_point, &parent);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	req.tc.tcm_parent = parent;
+ 
+ 	ret = nlattr_add(&req.nh, sizeof(req), TCA_KIND, "bpf", sizeof("bpf"));
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	nla = nlattr_begin_nested(&req.nh, sizeof(req), TCA_OPTIONS);
+ 	if (!nla)
+ 		return libbpf_err(-EMSGSIZE);
+ 	ret = tc_add_fd_and_name(&req.nh, sizeof(req), prog_fd);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	bpf_flags = TCA_BPF_FLAG_ACT_DIRECT;
+ 	ret = nlattr_add(&req.nh, sizeof(req), TCA_BPF_FLAGS, &bpf_flags,
+ 			 sizeof(bpf_flags));
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	nlattr_end_nested(&req.nh, nla);
+ 
+ 	info.opts = opts;
+ 
+ 	ret = libbpf_netlink_send_recv(&req.nh, get_tc_info, NULL, &info);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	if (!info.processed)
+ 		return libbpf_err(-ENOENT);
+ 	return ret;
+ }
+ 
+ static int __bpf_tc_detach(const struct bpf_tc_hook *hook,
+ 			   const struct bpf_tc_opts *opts,
+ 			   const bool flush)
+ {
+ 	__u32 protocol = 0, handle, priority, parent, prog_id, flags;
+ 	int ret, ifindex, attach_point, prog_fd;
+ 	struct {
+ 		struct nlmsghdr nh;
+ 		struct tcmsg tc;
+ 		char buf[256];
+ 	} req;
+ 
+ 	if (!hook ||
+ 	    !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    !OPTS_VALID(opts, bpf_tc_opts))
+ 		return -EINVAL;
+ 
+ 	ifindex      = OPTS_GET(hook, ifindex, 0);
+ 	parent       = OPTS_GET(hook, parent, 0);
+ 	attach_point = OPTS_GET(hook, attach_point, 0);
+ 
+ 	handle       = OPTS_GET(opts, handle, 0);
+ 	priority     = OPTS_GET(opts, priority, 0);
+ 	prog_fd      = OPTS_GET(opts, prog_fd, 0);
+ 	prog_id      = OPTS_GET(opts, prog_id, 0);
+ 	flags        = OPTS_GET(opts, flags, 0);
+ 
+ 	if (ifindex <= 0 || flags || prog_fd || prog_id)
+ 		return -EINVAL;
+ 	if (priority > UINT16_MAX)
+ 		return -EINVAL;
+ 	if (!flush) {
+ 		if (!handle || !priority)
+ 			return -EINVAL;
+ 		protocol = ETH_P_ALL;
+ 	} else {
+ 		if (handle || priority)
+ 			return -EINVAL;
+ 	}
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+ 	req.nh.nlmsg_type  = RTM_DELTFILTER;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = ifindex;
+ 	if (!flush) {
+ 		req.tc.tcm_handle = handle;
+ 		req.tc.tcm_info   = TC_H_MAKE(priority << 16, htons(protocol));
+ 	}
+ 
+ 	ret = tc_get_tcm_parent(attach_point, &parent);
+ 	if (ret < 0)
+ 		return ret;
+ 	req.tc.tcm_parent = parent;
+ 
+ 	if (!flush) {
+ 		ret = nlattr_add(&req.nh, sizeof(req), TCA_KIND,
+ 				 "bpf", sizeof("bpf"));
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	return libbpf_netlink_send_recv(&req.nh, NULL, NULL, NULL);
+ }
+ 
+ int bpf_tc_detach(const struct bpf_tc_hook *hook,
+ 		  const struct bpf_tc_opts *opts)
+ {
+ 	int ret;
+ 
+ 	if (!opts)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ret = __bpf_tc_detach(hook, opts, false);
+ 	return libbpf_err(ret);
+ }
+ 
+ int bpf_tc_query(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)
+ {
+ 	__u32 protocol, handle, priority, parent, prog_id, flags;
+ 	int ret, ifindex, attach_point, prog_fd;
+ 	struct bpf_cb_ctx info = {};
+ 	struct {
+ 		struct nlmsghdr nh;
+ 		struct tcmsg tc;
+ 		char buf[256];
+ 	} req;
+ 
+ 	if (!hook || !opts ||
+ 	    !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    !OPTS_VALID(opts, bpf_tc_opts))
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ifindex      = OPTS_GET(hook, ifindex, 0);
+ 	parent       = OPTS_GET(hook, parent, 0);
+ 	attach_point = OPTS_GET(hook, attach_point, 0);
+ 
+ 	handle       = OPTS_GET(opts, handle, 0);
+ 	priority     = OPTS_GET(opts, priority, 0);
+ 	prog_fd      = OPTS_GET(opts, prog_fd, 0);
+ 	prog_id      = OPTS_GET(opts, prog_id, 0);
+ 	flags        = OPTS_GET(opts, flags, 0);
+ 
+ 	if (ifindex <= 0 || flags || prog_fd || prog_id ||
+ 	    !handle || !priority)
+ 		return libbpf_err(-EINVAL);
+ 	if (priority > UINT16_MAX)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	protocol = ETH_P_ALL;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST;
+ 	req.nh.nlmsg_type  = RTM_GETTFILTER;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = ifindex;
+ 	req.tc.tcm_handle  = handle;
+ 	req.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));
+ 
+ 	ret = tc_get_tcm_parent(attach_point, &parent);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	req.tc.tcm_parent = parent;
+ 
+ 	ret = nlattr_add(&req.nh, sizeof(req), TCA_KIND, "bpf", sizeof("bpf"));
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 
+ 	info.opts = opts;
+ 
+ 	ret = libbpf_netlink_send_recv(&req.nh, get_tc_info, NULL, &info);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	if (!info.processed)
+ 		return libbpf_err(-ENOENT);
+ 	return ret;
+ }
++>>>>>>> 4e164f871685 (libbpf: Remove unneeded check for flags during tc detach)
* Unmerged path tools/lib/bpf/netlink.c
