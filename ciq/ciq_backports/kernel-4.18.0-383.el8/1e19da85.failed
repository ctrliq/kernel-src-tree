x86/speculation: Add eIBRS + Retpoline options

jira LE-1907
cve CVE-2022-0002
cve CVE-2022-0001
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 1e19da8522c81bf46b335f84137165741e0d82b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/1e19da85.failed

Thanks to the chaps at VUsec it is now clear that eIBRS is not
sufficient, therefore allow enabling of retpolines along with eIBRS.

Add spectre_v2=eibrs, spectre_v2=eibrs,lfence and
spectre_v2=eibrs,retpoline options to explicitly pick your preferred
means of mitigation.

Since there's new mitigations there's also user visible changes in
/sys/devices/system/cpu/vulnerabilities/spectre_v2 to reflect these
new mitigations.

  [ bp: Massage commit message, trim error messages,
    do more precise eIBRS mode checking. ]

Co-developed-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Patrick Colp <patrick.colp@oracle.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 1e19da8522c81bf46b335f84137165741e0d82b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/nospec-branch.h
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/include/asm/nospec-branch.h
index a154c2d99bc0,acbaeaf83b61..000000000000
--- a/arch/x86/include/asm/nospec-branch.h
+++ b/arch/x86/include/asm/nospec-branch.h
@@@ -223,12 -188,11 +223,20 @@@
  /* The Spectre V2 mitigation variants */
  enum spectre_v2_mitigation {
  	SPECTRE_V2_NONE,
++<<<<<<< HEAD
 +	SPECTRE_V2_RETPOLINE_GENERIC,
 +	SPECTRE_V2_RETPOLINE_AMD,
 +	SPECTRE_V2_IBRS_ENHANCED,
 +	SPECTRE_V2_IBRS,
 +	SPECTRE_V2_RETPOLINE_IBRS_USER,
 +	SPECTRE_V2_IBRS_ALWAYS,
++=======
+ 	SPECTRE_V2_RETPOLINE,
+ 	SPECTRE_V2_LFENCE,
+ 	SPECTRE_V2_EIBRS,
+ 	SPECTRE_V2_EIBRS_RETPOLINE,
+ 	SPECTRE_V2_EIBRS_LFENCE,
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  };
  
  /* The indirect branch speculation control variants */
diff --cc arch/x86/kernel/cpu/bugs.c
index 7357f251348a,79c52dd6c597..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -632,10 -664,10 +632,17 @@@ enum spectre_v2_mitigation_cmd 
  	SPECTRE_V2_CMD_FORCE,
  	SPECTRE_V2_CMD_RETPOLINE,
  	SPECTRE_V2_CMD_RETPOLINE_GENERIC,
++<<<<<<< HEAD
 +	SPECTRE_V2_CMD_RETPOLINE_AMD,
 +	SPECTRE_V2_CMD_RETPOLINE_IBRS_USER,
 +	SPECTRE_V2_CMD_IBRS,
 +	SPECTRE_V2_CMD_IBRS_ALWAYS,
++=======
+ 	SPECTRE_V2_CMD_RETPOLINE_LFENCE,
+ 	SPECTRE_V2_CMD_EIBRS,
+ 	SPECTRE_V2_CMD_EIBRS_RETPOLINE,
+ 	SPECTRE_V2_CMD_EIBRS_LFENCE,
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  };
  
  enum spectre_v2_user_cmd {
@@@ -795,12 -834,11 +809,20 @@@ set_mode
  
  static const char * const spectre_v2_strings[] = {
  	[SPECTRE_V2_NONE]			= "Vulnerable",
++<<<<<<< HEAD
 +	[SPECTRE_V2_RETPOLINE_GENERIC]		= "Mitigation: Full generic retpoline",
 +	[SPECTRE_V2_RETPOLINE_AMD]		= "Mitigation: Full AMD retpoline",
 +	[SPECTRE_V2_IBRS_ENHANCED]		= "Mitigation: Enhanced IBRS",
 +	[SPECTRE_V2_IBRS]			= "Mitigation: IBRS (kernel)",
 +	[SPECTRE_V2_RETPOLINE_IBRS_USER]	= "Mitigation: Full retpoline and IBRS (user space)",
 +	[SPECTRE_V2_IBRS_ALWAYS]		= "Mitigation: IBRS (kernel and user space)",
++=======
+ 	[SPECTRE_V2_RETPOLINE]			= "Mitigation: Retpolines",
+ 	[SPECTRE_V2_LFENCE]			= "Mitigation: LFENCE",
+ 	[SPECTRE_V2_EIBRS]			= "Mitigation: Enhanced IBRS",
+ 	[SPECTRE_V2_EIBRS_LFENCE]		= "Mitigation: Enhanced IBRS + LFENCE",
+ 	[SPECTRE_V2_EIBRS_RETPOLINE]		= "Mitigation: Enhanced IBRS + Retpolines",
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  };
  
  static const struct {
@@@ -811,12 -849,13 +833,15 @@@
  	{ "off",		SPECTRE_V2_CMD_NONE,		  false },
  	{ "on",			SPECTRE_V2_CMD_FORCE,		  true  },
  	{ "retpoline",		SPECTRE_V2_CMD_RETPOLINE,	  false },
 -	{ "retpoline,amd",	SPECTRE_V2_CMD_RETPOLINE_LFENCE,  false },
 -	{ "retpoline,lfence",	SPECTRE_V2_CMD_RETPOLINE_LFENCE,  false },
 +	{ "retpoline,amd",	SPECTRE_V2_CMD_RETPOLINE_AMD,	  false },
  	{ "retpoline,generic",	SPECTRE_V2_CMD_RETPOLINE_GENERIC, false },
+ 	{ "eibrs",		SPECTRE_V2_CMD_EIBRS,		  false },
+ 	{ "eibrs,lfence",	SPECTRE_V2_CMD_EIBRS_LFENCE,	  false },
+ 	{ "eibrs,retpoline",	SPECTRE_V2_CMD_EIBRS_RETPOLINE,	  false },
  	{ "auto",		SPECTRE_V2_CMD_AUTO,		  false },
 +	{ "ibrs",		SPECTRE_V2_CMD_IBRS,		  false },
 +	{ "ibrs_always",	SPECTRE_V2_CMD_IBRS_ALWAYS,	  false },
 +	{ "retpoline,ibrs_user", SPECTRE_V2_CMD_RETPOLINE_IBRS_USER, false},
  };
  
  static void __init spec_v2_print_cond(const char *reason, bool secure)
@@@ -852,16 -891,30 +877,41 @@@ static enum spectre_v2_mitigation_cmd _
  	}
  
  	if ((cmd == SPECTRE_V2_CMD_RETPOLINE ||
++<<<<<<< HEAD
 +	     cmd == SPECTRE_V2_CMD_RETPOLINE_AMD ||
 +	     cmd == SPECTRE_V2_CMD_RETPOLINE_GENERIC) &&
++=======
+ 	     cmd == SPECTRE_V2_CMD_RETPOLINE_LFENCE ||
+ 	     cmd == SPECTRE_V2_CMD_RETPOLINE_GENERIC ||
+ 	     cmd == SPECTRE_V2_CMD_EIBRS_LFENCE ||
+ 	     cmd == SPECTRE_V2_CMD_EIBRS_RETPOLINE) &&
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  	    !IS_ENABLED(CONFIG_RETPOLINE)) {
- 		pr_err("%s selected but not compiled in. Switching to AUTO select\n", mitigation_options[i].option);
+ 		pr_err("%s selected but not compiled in. Switching to AUTO select\n",
+ 		       mitigation_options[i].option);
  		return SPECTRE_V2_CMD_AUTO;
  	}
  
++<<<<<<< HEAD
 +	if (cmd == SPECTRE_V2_CMD_RETPOLINE_AMD &&
 +	    boot_cpu_data.x86_vendor != X86_VENDOR_AMD) {
 +		pr_err("retpoline,amd selected but CPU is not AMD. Switching to AUTO select\n");
++=======
+ 	if ((cmd == SPECTRE_V2_CMD_EIBRS ||
+ 	     cmd == SPECTRE_V2_CMD_EIBRS_LFENCE ||
+ 	     cmd == SPECTRE_V2_CMD_EIBRS_RETPOLINE) &&
+ 	    !boot_cpu_has(X86_FEATURE_IBRS_ENHANCED)) {
+ 		pr_err("%s selected but CPU doesn't have eIBRS. Switching to AUTO select\n",
+ 		       mitigation_options[i].option);
+ 		return SPECTRE_V2_CMD_AUTO;
+ 	}
+ 
+ 	if ((cmd == SPECTRE_V2_CMD_RETPOLINE_LFENCE ||
+ 	     cmd == SPECTRE_V2_CMD_EIBRS_LFENCE) &&
+ 	    !boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
+ 		pr_err("%s selected, but CPU doesn't have a serializing LFENCE. Switching to AUTO select\n",
+ 		       mitigation_options[i].option);
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  		return SPECTRE_V2_CMD_AUTO;
  	}
  
@@@ -890,86 -962,60 +959,143 @@@ static void __init spectre_v2_select_mi
  	case SPECTRE_V2_CMD_FORCE:
  	case SPECTRE_V2_CMD_AUTO:
  		if (boot_cpu_has(X86_FEATURE_IBRS_ENHANCED)) {
++<<<<<<< HEAD
 +set_ibrs_enhanced:
 +			mode = SPECTRE_V2_IBRS_ENHANCED;
 +			/* Force it so VMEXIT will restore correctly */
 +			x86_spec_ctrl_base |= SPEC_CTRL_IBRS;
 +			wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
 +			goto specv2_set_mode;
 +		}
 +
 +		/*
 +		 * For Skylake, we print a warning if IBRS isn't chosen.
 +		 */
 +		if (is_skylake_era() && boot_cpu_has(X86_FEATURE_IBRS)) {
 +			pr_warn("Using retpoline on Skylake-generation processors may not fully mitigate the vulnerability.\n");
 +			pr_warn("Add the \"spectre_v2=ibrs\" kernel boot flag to enable IBRS on Skylake systems that need full mitigation.\n");
 +		}
 +
 +		/* Fall through */
 +
 +		if (IS_ENABLED(CONFIG_RETPOLINE))
 +			goto retpoline_auto;
 +		break;
 +	case SPECTRE_V2_CMD_RETPOLINE_AMD:
 +		if (IS_ENABLED(CONFIG_RETPOLINE))
 +			goto retpoline_amd;
 +		break;
 +	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
 +		if (IS_ENABLED(CONFIG_RETPOLINE))
 +			goto retpoline_generic;
 +		break;
 +	case SPECTRE_V2_CMD_RETPOLINE:
 +		if (IS_ENABLED(CONFIG_RETPOLINE))
 +			goto retpoline_auto;
 +		break;
 +	case SPECTRE_V2_CMD_IBRS:
 +		if (spec_ctrl_enable_ibrs()) {
 +			mode = SPECTRE_V2_IBRS;
 +			goto specv2_set_mode;
 +		}
 +		goto retpoline_auto;
 +	case SPECTRE_V2_CMD_IBRS_ALWAYS:
 +		/* Fall back to IBRS_ENHANCED if feature present */
 +		if (boot_cpu_has(X86_FEATURE_IBRS_ENHANCED))
 +			goto set_ibrs_enhanced;
 +
 +		if (spec_ctrl_enable_ibrs_always()) {
 +			mode = SPECTRE_V2_IBRS_ALWAYS;
 +			goto specv2_set_mode;
 +		}
 +		goto retpoline_auto;
 +	case SPECTRE_V2_CMD_RETPOLINE_IBRS_USER:
 +		goto retpoline_auto;
 +	}
 +	pr_err("Spectre mitigation: kernel not compiled with retpoline; no mitigation available!");
 +	return;
 +
 +retpoline_auto:
 +	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
 +	retpoline_amd:
 +		if (!boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
 +			pr_err("Spectre mitigation: LFENCE not serializing, switching to generic retpoline\n");
 +			goto retpoline_generic;
 +		}
 +		mode = SPECTRE_V2_RETPOLINE_AMD;
 +		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_AMD);
 +		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 +	} else {
 +	retpoline_generic:
 +		mode = SPECTRE_V2_RETPOLINE_GENERIC;
 +		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 +	}
 +
 +	/*
 +	 * Check SPECTRE_V2_CMD_RETPOLINE_IBRS_USER mode.
 +	 */
 +	if ((cmd == SPECTRE_V2_CMD_RETPOLINE_IBRS_USER) &&
 +	    boot_cpu_has(X86_FEATURE_RETPOLINE) &&
 +	    spec_ctrl_enable_retpoline_ibrs_user())
 +		mode = SPECTRE_V2_RETPOLINE_IBRS_USER;
 +
 +specv2_set_mode:
++=======
+ 			mode = SPECTRE_V2_EIBRS;
+ 			break;
+ 		}
+ 
+ 		mode = spectre_v2_select_retpoline();
+ 		break;
+ 
+ 	case SPECTRE_V2_CMD_RETPOLINE_LFENCE:
+ 		mode = SPECTRE_V2_LFENCE;
+ 		break;
+ 
+ 	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
+ 		mode = SPECTRE_V2_RETPOLINE;
+ 		break;
+ 
+ 	case SPECTRE_V2_CMD_RETPOLINE:
+ 		mode = spectre_v2_select_retpoline();
+ 		break;
+ 
+ 	case SPECTRE_V2_CMD_EIBRS:
+ 		mode = SPECTRE_V2_EIBRS;
+ 		break;
+ 
+ 	case SPECTRE_V2_CMD_EIBRS_LFENCE:
+ 		mode = SPECTRE_V2_EIBRS_LFENCE;
+ 		break;
+ 
+ 	case SPECTRE_V2_CMD_EIBRS_RETPOLINE:
+ 		mode = SPECTRE_V2_EIBRS_RETPOLINE;
+ 		break;
+ 	}
+ 
+ 	if (spectre_v2_in_eibrs_mode(mode)) {
+ 		/* Force it so VMEXIT will restore correctly */
+ 		x86_spec_ctrl_base |= SPEC_CTRL_IBRS;
+ 		wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
+ 	}
+ 
+ 	switch (mode) {
+ 	case SPECTRE_V2_NONE:
+ 	case SPECTRE_V2_EIBRS:
+ 		break;
+ 
+ 	case SPECTRE_V2_LFENCE:
+ 	case SPECTRE_V2_EIBRS_LFENCE:
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_LFENCE);
+ 		fallthrough;
+ 
+ 	case SPECTRE_V2_RETPOLINE:
+ 	case SPECTRE_V2_EIBRS_RETPOLINE:
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
+ 		break;
+ 	}
+ 
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  	spectre_v2_enabled = mode;
  	pr_info("%s\n", spectre_v2_strings[mode]);
  
@@@ -995,8 -1041,7 +1121,12 @@@
  	 * the CPU supports Enhanced IBRS, kernel might un-intentionally not
  	 * enable IBRS around firmware calls.
  	 */
++<<<<<<< HEAD
 +	if (boot_cpu_has(X86_FEATURE_IBRS) &&
 +	   !(x86_spec_ctrl_base & SPEC_CTRL_IBRS)) {
++=======
+ 	if (boot_cpu_has(X86_FEATURE_IBRS) && !spectre_v2_in_eibrs_mode(mode)) {
++>>>>>>> 1e19da8522c8 (x86/speculation: Add eIBRS + Retpoline options)
  		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);
  		pr_info("Enabling Restricted Speculation for firmware calls\n");
  	}
* Unmerged path arch/x86/include/asm/nospec-branch.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
