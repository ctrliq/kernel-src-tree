net/mlx5e: Mutually exclude setting of TX-port-TS and MQPRIO in channel mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Aya Levin <ayal@nvidia.com>
commit 3bf1742f3c69501dec300b55917b9352428cb4dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/3bf1742f.failed

TX-port-TS hijacks the PTP traffic to a specific HW TX-queue. This
conflicts with MQPRIO in channel mode, which specifies explicitly which
TC accepts the packet. This patch mutually excludes the above
configuration.

Fixes: ec60c4581bd9 ("net/mlx5e: Support MQPRIO channel mode")
	Signed-off-by: Aya Levin <ayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 3bf1742f3c69501dec300b55917b9352428cb4dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index d829ad30e5f6,0c5197f9cea3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2897,6 -2941,76 +2897,79 @@@ static int mlx5e_setup_tc_mqprio_dcb(st
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5e_mqprio_channel_validate(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5e_ptp *ptp_channel;
+ 	int agg_count = 0;
+ 	int i;
+ 
+ 	ptp_channel = priv->channels.ptp;
+ 	if (ptp_channel && test_bit(MLX5E_PTP_STATE_TX, ptp_channel->state)) {
+ 		netdev_err(netdev,
+ 			   "Cannot activate MQPRIO mode channel since it conflicts with TX port TS\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mqprio->qopt.offset[0] != 0 || mqprio->qopt.num_tc < 1 ||
+ 	    mqprio->qopt.num_tc > MLX5E_MAX_NUM_MQPRIO_CH_TC)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < mqprio->qopt.num_tc; i++) {
+ 		if (!mqprio->qopt.count[i]) {
+ 			netdev_err(netdev, "Zero size for queue-group (%d) is not supported\n", i);
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->min_rate[i]) {
+ 			netdev_err(netdev, "Min tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->max_rate[i]) {
+ 			netdev_err(netdev, "Max tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (mqprio->qopt.offset[i] != agg_count) {
+ 			netdev_err(netdev, "Discontinuous queues config is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		agg_count += mqprio->qopt.count[i];
+ 	}
+ 
+ 	if (priv->channels.params.num_channels < agg_count) {
+ 		netdev_err(netdev, "Num of queues (%d) exceeds available (%d)\n",
+ 			   agg_count, priv->channels.params.num_channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_setup_tc_mqprio_channel(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	mlx5e_fp_preactivate preactivate;
+ 	struct mlx5e_params new_params;
+ 	bool nch_changed;
+ 	int err;
+ 
+ 	err = mlx5e_mqprio_channel_validate(priv, mqprio);
+ 	if (err)
+ 		return err;
+ 
+ 	new_params = priv->channels.params;
+ 	mlx5e_params_mqprio_channel_set(&new_params, &mqprio->qopt);
+ 
+ 	nch_changed = mlx5e_get_dcb_num_tc(&priv->channels.params) > 1;
+ 	preactivate = nch_changed ? mlx5e_num_channels_changed_ctx :
+ 		mlx5e_update_netdev_queues_ctx;
+ 	return mlx5e_safe_switch_params(priv, &new_params, preactivate, NULL, true);
+ }
+ 
++>>>>>>> 3bf1742f3c69 (net/mlx5e: Mutually exclude setting of TX-port-TS and MQPRIO in channel mode)
  static int mlx5e_setup_tc_mqprio(struct mlx5e_priv *priv,
  				 struct tc_mqprio_qopt_offload *mqprio)
  {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 3a54bd65c2b7..d30e884aa0a8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@ -1979,6 +1979,17 @@ static int set_pflag_tx_port_ts(struct net_device *netdev, bool enable)
 	}
 
 	new_params = priv->channels.params;
+	/* Don't allow enabling TX-port-TS if MQPRIO mode channel  offload is
+	 * active, since it defines explicitly which TC accepts the packet.
+	 * This conflicts with TX-port-TS hijacking the PTP traffic to a specific
+	 * HW TX-queue.
+	 */
+	if (enable && new_params.mqprio.mode == TC_MQPRIO_MODE_CHANNEL) {
+		netdev_err(priv->netdev,
+			   "%s: MQPRIO mode channel offload is active, cannot set the TX-port-TS\n",
+			   __func__);
+		return -EINVAL;
+	}
 	MLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_TX_PORT_TS, enable);
 	/* No need to verify SQ stop room as
 	 * ptpsq.txqsq.stop_room <= generic_sq->stop_room, and both
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
