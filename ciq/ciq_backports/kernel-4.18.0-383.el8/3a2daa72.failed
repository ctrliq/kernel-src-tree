bpf: Make some symbols static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Pu Lehui <pulehui@huawei.com>
commit 3a2daa7248647c0e5e165140553f9af5006e93a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/3a2daa72.failed

The sparse tool complains as follows:

kernel/bpf/syscall.c:4567:29: warning:
 symbol 'bpf_sys_bpf_proto' was not declared. Should it be static?
kernel/bpf/syscall.c:4592:29: warning:
 symbol 'bpf_sys_close_proto' was not declared. Should it be static?

This symbol is not used outside of syscall.c, so marks it static.

	Signed-off-by: Pu Lehui <pulehui@huawei.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Song Liu <songliubraving@fb.com>
Link: https://lore.kernel.org/bpf/20210519064116.240536-1-pulehui@huawei.com
(cherry picked from commit 3a2daa7248647c0e5e165140553f9af5006e93a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/syscall.c
diff --cc kernel/bpf/syscall.c
index 7aed15cc139e,1d1cd80a6e67..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -4541,3 -4527,94 +4541,97 @@@ SYSCALL_DEFINE3(bpf, int, cmd, union bp
  
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)
+ {
+ 	return __sys_bpf(cmd, USER_BPFPTR(uattr), size);
+ }
+ 
+ static bool syscall_prog_is_valid_access(int off, int size,
+ 					 enum bpf_access_type type,
+ 					 const struct bpf_prog *prog,
+ 					 struct bpf_insn_access_aux *info)
+ {
+ 	if (off < 0 || off >= U16_MAX)
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 	return true;
+ }
+ 
+ BPF_CALL_3(bpf_sys_bpf, int, cmd, void *, attr, u32, attr_size)
+ {
+ 	switch (cmd) {
+ 	case BPF_MAP_CREATE:
+ 	case BPF_MAP_UPDATE_ELEM:
+ 	case BPF_MAP_FREEZE:
+ 	case BPF_PROG_LOAD:
+ 	case BPF_BTF_LOAD:
+ 		break;
+ 	/* case BPF_PROG_TEST_RUN:
+ 	 * is not part of this list to prevent recursive test_run
+ 	 */
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 	return __sys_bpf(cmd, KERNEL_BPFPTR(attr), attr_size);
+ }
+ 
+ static const struct bpf_func_proto bpf_sys_bpf_proto = {
+ 	.func		= bpf_sys_bpf,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_ANYTHING,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ const struct bpf_func_proto * __weak
+ tracing_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	return bpf_base_func_proto(func_id);
+ }
+ 
+ BPF_CALL_1(bpf_sys_close, u32, fd)
+ {
+ 	/* When bpf program calls this helper there should not be
+ 	 * an fdget() without matching completed fdput().
+ 	 * This helper is allowed in the following callchain only:
+ 	 * sys_bpf->prog_test_run->bpf_prog->bpf_sys_close
+ 	 */
+ 	return close_fd(fd);
+ }
+ 
+ static const struct bpf_func_proto bpf_sys_close_proto = {
+ 	.func		= bpf_sys_close,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_ANYTHING,
+ };
+ 
+ static const struct bpf_func_proto *
+ syscall_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_sys_bpf:
+ 		return &bpf_sys_bpf_proto;
+ 	case BPF_FUNC_btf_find_by_name_kind:
+ 		return &bpf_btf_find_by_name_kind_proto;
+ 	case BPF_FUNC_sys_close:
+ 		return &bpf_sys_close_proto;
+ 	default:
+ 		return tracing_prog_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ const struct bpf_verifier_ops bpf_syscall_verifier_ops = {
+ 	.get_func_proto  = syscall_prog_func_proto,
+ 	.is_valid_access = syscall_prog_is_valid_access,
+ };
+ 
+ const struct bpf_prog_ops bpf_syscall_prog_ops = {
+ 	.test_run = bpf_prog_test_run_syscall,
+ };
++>>>>>>> 3a2daa724864 (bpf: Make some symbols static)
* Unmerged path kernel/bpf/syscall.c
