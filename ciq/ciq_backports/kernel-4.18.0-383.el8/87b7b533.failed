bpf: Add missing bpf_read_[un]lock_trace() for syscall program

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Yonghong Song <yhs@fb.com>
commit 87b7b5335e6995a6d64fca98fc67b92b29caac9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/87b7b533.failed

Commit 79a7f8bdb159d ("bpf: Introduce bpf_sys_bpf() helper and program type.")
added support for syscall program, which is a sleepable program.

But the program run missed bpf_read_lock_trace()/bpf_read_unlock_trace(),
which is needed to ensure proper rcu callback invocations. This patch adds
bpf_read_[un]lock_trace() properly.

Fixes: 79a7f8bdb159d ("bpf: Introduce bpf_sys_bpf() helper and program type.")
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/bpf/20210809235151.1663680-1-yhs@fb.com
(cherry picked from commit 87b7b5335e6995a6d64fca98fc67b92b29caac9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bpf/test_run.c
diff --cc net/bpf/test_run.c
index a73e52cc9bb2,caa16bf30fb5..000000000000
--- a/net/bpf/test_run.c
+++ b/net/bpf/test_run.c
@@@ -921,3 -922,49 +922,52 @@@ out
  	kfree(user_ctx);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ int bpf_prog_test_run_syscall(struct bpf_prog *prog,
+ 			      const union bpf_attr *kattr,
+ 			      union bpf_attr __user *uattr)
+ {
+ 	void __user *ctx_in = u64_to_user_ptr(kattr->test.ctx_in);
+ 	__u32 ctx_size_in = kattr->test.ctx_size_in;
+ 	void *ctx = NULL;
+ 	u32 retval;
+ 	int err = 0;
+ 
+ 	/* doesn't support data_in/out, ctx_out, duration, or repeat or flags */
+ 	if (kattr->test.data_in || kattr->test.data_out ||
+ 	    kattr->test.ctx_out || kattr->test.duration ||
+ 	    kattr->test.repeat || kattr->test.flags)
+ 		return -EINVAL;
+ 
+ 	if (ctx_size_in < prog->aux->max_ctx_offset ||
+ 	    ctx_size_in > U16_MAX)
+ 		return -EINVAL;
+ 
+ 	if (ctx_size_in) {
+ 		ctx = kzalloc(ctx_size_in, GFP_USER);
+ 		if (!ctx)
+ 			return -ENOMEM;
+ 		if (copy_from_user(ctx, ctx_in, ctx_size_in)) {
+ 			err = -EFAULT;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	rcu_read_lock_trace();
+ 	retval = bpf_prog_run_pin_on_cpu(prog, ctx);
+ 	rcu_read_unlock_trace();
+ 
+ 	if (copy_to_user(&uattr->test.retval, &retval, sizeof(u32))) {
+ 		err = -EFAULT;
+ 		goto out;
+ 	}
+ 	if (ctx_size_in)
+ 		if (copy_to_user(ctx_in, ctx, ctx_size_in))
+ 			err = -EFAULT;
+ out:
+ 	kfree(ctx);
+ 	return err;
+ }
++>>>>>>> 87b7b5335e69 (bpf: Add missing bpf_read_[un]lock_trace() for syscall program)
* Unmerged path net/bpf/test_run.c
