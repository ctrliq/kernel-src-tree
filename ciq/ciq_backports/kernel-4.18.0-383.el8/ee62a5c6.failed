libbpf: Switch to void * casting in netlink helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Kumar Kartikeya Dwivedi <memxor@gmail.com>
commit ee62a5c6bb100b6fb07f3da3818c10a24d440e10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/ee62a5c6.failed

Netlink helpers I added in 8bbb77b7c7a2 ("libbpf: Add various netlink
helpers") used char * casts everywhere, and there were a few more that
existed from before.

Convert all of them to void * cast, as it is treated equivalently by
clang/gcc for the purposes of pointer arithmetic and to follow the
convention elsewhere in the kernel/libbpf.

	Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20210619041454.417577-2-memxor@gmail.com
(cherry picked from commit ee62a5c6bb100b6fb07f3da3818c10a24d440e10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/netlink.c
#	tools/lib/bpf/nlattr.h
diff --cc tools/lib/bpf/netlink.c
index 4676dcf5eae8,39f25e09b51e..000000000000
--- a/tools/lib/bpf/netlink.c
+++ b/tools/lib/bpf/netlink.c
@@@ -346,37 -365,394 +346,212 @@@ int bpf_get_link_xdp_id(int ifindex, __
  	if (!ret)
  		*prog_id = get_xdp_id(&info, flags);
  
 -	return libbpf_err(ret);
 +	return ret;
  }
  
 -typedef int (*qdisc_config_t)(struct libbpf_nla_req *req);
 -
 -static int clsact_config(struct libbpf_nla_req *req)
 +int libbpf_nl_get_link(int sock, unsigned int nl_pid,
 +		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie)
  {
 -	req->tc.tcm_parent = TC_H_CLSACT;
 -	req->tc.tcm_handle = TC_H_MAKE(TC_H_CLSACT, 0);
 +	struct {
 +		struct nlmsghdr nlh;
 +		struct ifinfomsg ifm;
 +	} req = {
 +		.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
 +		.nlh.nlmsg_type = RTM_GETLINK,
 +		.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,
 +		.ifm.ifi_family = AF_PACKET,
 +	};
 +	int seq = time(NULL);
  
++<<<<<<< HEAD
 +	req.nlh.nlmsg_seq = seq;
 +	if (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)
++=======
+ 	return nlattr_add(req, TCA_KIND, "clsact", sizeof("clsact"));
+ }
+ 
+ static int attach_point_to_config(struct bpf_tc_hook *hook,
+ 				  qdisc_config_t *config)
+ {
+ 	switch (OPTS_GET(hook, attach_point, 0)) {
+ 	case BPF_TC_INGRESS:
+ 	case BPF_TC_EGRESS:
+ 	case BPF_TC_INGRESS | BPF_TC_EGRESS:
+ 		if (OPTS_GET(hook, parent, 0))
+ 			return -EINVAL;
+ 		*config = &clsact_config;
+ 		return 0;
+ 	case BPF_TC_CUSTOM:
+ 		return -EOPNOTSUPP;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int tc_get_tcm_parent(enum bpf_tc_attach_point attach_point,
+ 			     __u32 *parent)
+ {
+ 	switch (attach_point) {
+ 	case BPF_TC_INGRESS:
+ 	case BPF_TC_EGRESS:
+ 		if (*parent)
+ 			return -EINVAL;
+ 		*parent = TC_H_MAKE(TC_H_CLSACT,
+ 				    attach_point == BPF_TC_INGRESS ?
+ 				    TC_H_MIN_INGRESS : TC_H_MIN_EGRESS);
+ 		break;
+ 	case BPF_TC_CUSTOM:
+ 		if (!*parent)
+ 			return -EINVAL;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
+ static int tc_qdisc_modify(struct bpf_tc_hook *hook, int cmd, int flags)
+ {
+ 	qdisc_config_t config;
+ 	int ret;
+ 	struct libbpf_nla_req req;
+ 
+ 	ret = attach_point_to_config(hook, &config);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
+ 	req.nh.nlmsg_type  = cmd;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = OPTS_GET(hook, ifindex, 0);
+ 
+ 	ret = config(&req);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return libbpf_netlink_send_recv(&req, NULL, NULL, NULL);
+ }
+ 
+ static int tc_qdisc_create_excl(struct bpf_tc_hook *hook)
+ {
+ 	return tc_qdisc_modify(hook, RTM_NEWQDISC, NLM_F_CREATE | NLM_F_EXCL);
+ }
+ 
+ static int tc_qdisc_delete(struct bpf_tc_hook *hook)
+ {
+ 	return tc_qdisc_modify(hook, RTM_DELQDISC, 0);
+ }
+ 
+ int bpf_tc_hook_create(struct bpf_tc_hook *hook)
+ {
+ 	int ret;
+ 
+ 	if (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    OPTS_GET(hook, ifindex, 0) <= 0)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ret = tc_qdisc_create_excl(hook);
+ 	return libbpf_err(ret);
+ }
+ 
+ static int __bpf_tc_detach(const struct bpf_tc_hook *hook,
+ 			   const struct bpf_tc_opts *opts,
+ 			   const bool flush);
+ 
+ int bpf_tc_hook_destroy(struct bpf_tc_hook *hook)
+ {
+ 	if (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    OPTS_GET(hook, ifindex, 0) <= 0)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	switch (OPTS_GET(hook, attach_point, 0)) {
+ 	case BPF_TC_INGRESS:
+ 	case BPF_TC_EGRESS:
+ 		return libbpf_err(__bpf_tc_detach(hook, NULL, true));
+ 	case BPF_TC_INGRESS | BPF_TC_EGRESS:
+ 		return libbpf_err(tc_qdisc_delete(hook));
+ 	case BPF_TC_CUSTOM:
+ 		return libbpf_err(-EOPNOTSUPP);
+ 	default:
+ 		return libbpf_err(-EINVAL);
+ 	}
+ }
+ 
+ struct bpf_cb_ctx {
+ 	struct bpf_tc_opts *opts;
+ 	bool processed;
+ };
+ 
+ static int __get_tc_info(void *cookie, struct tcmsg *tc, struct nlattr **tb,
+ 			 bool unicast)
+ {
+ 	struct nlattr *tbb[TCA_BPF_MAX + 1];
+ 	struct bpf_cb_ctx *info = cookie;
+ 
+ 	if (!info || !info->opts)
+ 		return -EINVAL;
+ 	if (unicast && info->processed)
+ 		return -EINVAL;
+ 	if (!tb[TCA_OPTIONS])
+ 		return NL_CONT;
+ 
+ 	libbpf_nla_parse_nested(tbb, TCA_BPF_MAX, tb[TCA_OPTIONS], NULL);
+ 	if (!tbb[TCA_BPF_ID])
+ 		return -EINVAL;
+ 
+ 	OPTS_SET(info->opts, prog_id, libbpf_nla_getattr_u32(tbb[TCA_BPF_ID]));
+ 	OPTS_SET(info->opts, handle, tc->tcm_handle);
+ 	OPTS_SET(info->opts, priority, TC_H_MAJ(tc->tcm_info) >> 16);
+ 
+ 	info->processed = true;
+ 	return unicast ? NL_NEXT : NL_DONE;
+ }
+ 
+ static int get_tc_info(struct nlmsghdr *nh, libbpf_dump_nlmsg_t fn,
+ 		       void *cookie)
+ {
+ 	struct tcmsg *tc = NLMSG_DATA(nh);
+ 	struct nlattr *tb[TCA_MAX + 1];
+ 
+ 	libbpf_nla_parse(tb, TCA_MAX,
+ 			 (struct nlattr *)((void *)tc + NLMSG_ALIGN(sizeof(*tc))),
+ 			 NLMSG_PAYLOAD(nh, sizeof(*tc)), NULL);
+ 	if (!tb[TCA_KIND])
+ 		return NL_CONT;
+ 	return __get_tc_info(cookie, tc, tb, nh->nlmsg_flags & NLM_F_ECHO);
+ }
+ 
+ static int tc_add_fd_and_name(struct libbpf_nla_req *req, int fd)
+ {
+ 	struct bpf_prog_info info = {};
+ 	__u32 info_len = sizeof(info);
+ 	char name[256];
+ 	int len, ret;
+ 
+ 	ret = bpf_obj_get_info_by_fd(fd, &info, &info_len);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = nlattr_add(req, TCA_BPF_FD, &fd, sizeof(fd));
+ 	if (ret < 0)
+ 		return ret;
+ 	len = snprintf(name, sizeof(name), "%s:[%u]", info.name, info.id);
+ 	if (len < 0)
++>>>>>>> ee62a5c6bb10 (libbpf: Switch to void * casting in netlink helpers)
  		return -errno;
 -	if (len >= sizeof(name))
 -		return -ENAMETOOLONG;
 -	return nlattr_add(req, TCA_BPF_NAME, name, len + 1);
 -}
 -
 -int bpf_tc_attach(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)
 -{
 -	__u32 protocol, bpf_flags, handle, priority, parent, prog_id, flags;
 -	int ret, ifindex, attach_point, prog_fd;
 -	struct bpf_cb_ctx info = {};
 -	struct libbpf_nla_req req;
 -	struct nlattr *nla;
 -
 -	if (!hook || !opts ||
 -	    !OPTS_VALID(hook, bpf_tc_hook) ||
 -	    !OPTS_VALID(opts, bpf_tc_opts))
 -		return libbpf_err(-EINVAL);
 -
 -	ifindex      = OPTS_GET(hook, ifindex, 0);
 -	parent       = OPTS_GET(hook, parent, 0);
 -	attach_point = OPTS_GET(hook, attach_point, 0);
 -
 -	handle       = OPTS_GET(opts, handle, 0);
 -	priority     = OPTS_GET(opts, priority, 0);
 -	prog_fd      = OPTS_GET(opts, prog_fd, 0);
 -	prog_id      = OPTS_GET(opts, prog_id, 0);
 -	flags        = OPTS_GET(opts, flags, 0);
 -
 -	if (ifindex <= 0 || !prog_fd || prog_id)
 -		return libbpf_err(-EINVAL);
 -	if (priority > UINT16_MAX)
 -		return libbpf_err(-EINVAL);
 -	if (flags & ~BPF_TC_F_REPLACE)
 -		return libbpf_err(-EINVAL);
 -
 -	flags = (flags & BPF_TC_F_REPLACE) ? NLM_F_REPLACE : NLM_F_EXCL;
 -	protocol = ETH_P_ALL;
 -
 -	memset(&req, 0, sizeof(req));
 -	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
 -	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE |
 -			     NLM_F_ECHO | flags;
 -	req.nh.nlmsg_type  = RTM_NEWTFILTER;
 -	req.tc.tcm_family  = AF_UNSPEC;
 -	req.tc.tcm_ifindex = ifindex;
 -	req.tc.tcm_handle  = handle;
 -	req.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));
 -
 -	ret = tc_get_tcm_parent(attach_point, &parent);
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	req.tc.tcm_parent = parent;
 -
 -	ret = nlattr_add(&req, TCA_KIND, "bpf", sizeof("bpf"));
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	nla = nlattr_begin_nested(&req, TCA_OPTIONS);
 -	if (!nla)
 -		return libbpf_err(-EMSGSIZE);
 -	ret = tc_add_fd_and_name(&req, prog_fd);
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	bpf_flags = TCA_BPF_FLAG_ACT_DIRECT;
 -	ret = nlattr_add(&req, TCA_BPF_FLAGS, &bpf_flags, sizeof(bpf_flags));
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	nlattr_end_nested(&req, nla);
 -
 -	info.opts = opts;
 -
 -	ret = libbpf_netlink_send_recv(&req, get_tc_info, NULL, &info);
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	if (!info.processed)
 -		return libbpf_err(-ENOENT);
 -	return ret;
 -}
 -
 -static int __bpf_tc_detach(const struct bpf_tc_hook *hook,
 -			   const struct bpf_tc_opts *opts,
 -			   const bool flush)
 -{
 -	__u32 protocol = 0, handle, priority, parent, prog_id, flags;
 -	int ret, ifindex, attach_point, prog_fd;
 -	struct libbpf_nla_req req;
 -
 -	if (!hook ||
 -	    !OPTS_VALID(hook, bpf_tc_hook) ||
 -	    !OPTS_VALID(opts, bpf_tc_opts))
 -		return -EINVAL;
 -
 -	ifindex      = OPTS_GET(hook, ifindex, 0);
 -	parent       = OPTS_GET(hook, parent, 0);
 -	attach_point = OPTS_GET(hook, attach_point, 0);
 -
 -	handle       = OPTS_GET(opts, handle, 0);
 -	priority     = OPTS_GET(opts, priority, 0);
 -	prog_fd      = OPTS_GET(opts, prog_fd, 0);
 -	prog_id      = OPTS_GET(opts, prog_id, 0);
 -	flags        = OPTS_GET(opts, flags, 0);
 -
 -	if (ifindex <= 0 || flags || prog_fd || prog_id)
 -		return -EINVAL;
 -	if (priority > UINT16_MAX)
 -		return -EINVAL;
 -	if (!flush) {
 -		if (!handle || !priority)
 -			return -EINVAL;
 -		protocol = ETH_P_ALL;
 -	} else {
 -		if (handle || priority)
 -			return -EINVAL;
 -	}
 -
 -	memset(&req, 0, sizeof(req));
 -	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
 -	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
 -	req.nh.nlmsg_type  = RTM_DELTFILTER;
 -	req.tc.tcm_family  = AF_UNSPEC;
 -	req.tc.tcm_ifindex = ifindex;
 -	if (!flush) {
 -		req.tc.tcm_handle = handle;
 -		req.tc.tcm_info   = TC_H_MAKE(priority << 16, htons(protocol));
 -	}
 -
 -	ret = tc_get_tcm_parent(attach_point, &parent);
 -	if (ret < 0)
 -		return ret;
 -	req.tc.tcm_parent = parent;
 -
 -	if (!flush) {
 -		ret = nlattr_add(&req, TCA_KIND, "bpf", sizeof("bpf"));
 -		if (ret < 0)
 -			return ret;
 -	}
  
 -	return libbpf_netlink_send_recv(&req, NULL, NULL, NULL);
 +	return bpf_netlink_recv(sock, nl_pid, seq, __dump_link_nlmsg,
 +				dump_link_nlmsg, cookie);
  }
  
 -int bpf_tc_detach(const struct bpf_tc_hook *hook,
 -		  const struct bpf_tc_opts *opts)
 -{
 -	int ret;
 -
 -	if (!opts)
 -		return libbpf_err(-EINVAL);
 -
 -	ret = __bpf_tc_detach(hook, opts, false);
 -	return libbpf_err(ret);
 -}
 -
 -int bpf_tc_query(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)
 -{
 -	__u32 protocol, handle, priority, parent, prog_id, flags;
 -	int ret, ifindex, attach_point, prog_fd;
 -	struct bpf_cb_ctx info = {};
 -	struct libbpf_nla_req req;
 -
 -	if (!hook || !opts ||
 -	    !OPTS_VALID(hook, bpf_tc_hook) ||
 -	    !OPTS_VALID(opts, bpf_tc_opts))
 -		return libbpf_err(-EINVAL);
 +/* RHEL-only, libbpf version workaround */
 +extern int bpf_get_link_xdp_info_v0_0_6(int ifindex, struct xdp_link_info *info,
 +					size_t info_size, __u32 flags)
 +	__attribute__((alias("bpf_get_link_xdp_info_v0_0_4")));
  
 -	ifindex      = OPTS_GET(hook, ifindex, 0);
 -	parent       = OPTS_GET(hook, parent, 0);
 -	attach_point = OPTS_GET(hook, attach_point, 0);
 -
 -	handle       = OPTS_GET(opts, handle, 0);
 -	priority     = OPTS_GET(opts, priority, 0);
 -	prog_fd      = OPTS_GET(opts, prog_fd, 0);
 -	prog_id      = OPTS_GET(opts, prog_id, 0);
 -	flags        = OPTS_GET(opts, flags, 0);
 -
 -	if (ifindex <= 0 || flags || prog_fd || prog_id ||
 -	    !handle || !priority)
 -		return libbpf_err(-EINVAL);
 -	if (priority > UINT16_MAX)
 -		return libbpf_err(-EINVAL);
 -
 -	protocol = ETH_P_ALL;
 -
 -	memset(&req, 0, sizeof(req));
 -	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
 -	req.nh.nlmsg_flags = NLM_F_REQUEST;
 -	req.nh.nlmsg_type  = RTM_GETTFILTER;
 -	req.tc.tcm_family  = AF_UNSPEC;
 -	req.tc.tcm_ifindex = ifindex;
 -	req.tc.tcm_handle  = handle;
 -	req.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));
 -
 -	ret = tc_get_tcm_parent(attach_point, &parent);
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	req.tc.tcm_parent = parent;
 -
 -	ret = nlattr_add(&req, TCA_KIND, "bpf", sizeof("bpf"));
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -
 -	info.opts = opts;
 -
 -	ret = libbpf_netlink_send_recv(&req, get_tc_info, NULL, &info);
 -	if (ret < 0)
 -		return libbpf_err(ret);
 -	if (!info.processed)
 -		return libbpf_err(-ENOENT);
 -	return ret;
 -}
 +COMPAT_VERSION(bpf_get_link_xdp_info_v0_0_4,
 +	       bpf_get_link_xdp_info, LIBBPF_0.0.4)
 +DEFAULT_VERSION(bpf_get_link_xdp_info_v0_0_6,
 +	        bpf_get_link_xdp_info, LIBBPF_0.0.6)
diff --cc tools/lib/bpf/nlattr.h
index 6cc3ac91690f,4d15ae2ff812..000000000000
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@@ -103,4 -116,49 +103,52 @@@ int libbpf_nla_parse_nested(struct nlat
  
  int libbpf_nla_dump_errormsg(struct nlmsghdr *nlh);
  
++<<<<<<< HEAD
++=======
+ static inline struct nlattr *nla_data(struct nlattr *nla)
+ {
+ 	return (struct nlattr *)((void *)nla + NLA_HDRLEN);
+ }
+ 
+ static inline struct nlattr *req_tail(struct libbpf_nla_req *req)
+ {
+ 	return (struct nlattr *)((void *)req + NLMSG_ALIGN(req->nh.nlmsg_len));
+ }
+ 
+ static inline int nlattr_add(struct libbpf_nla_req *req, int type,
+ 			     const void *data, int len)
+ {
+ 	struct nlattr *nla;
+ 
+ 	if (NLMSG_ALIGN(req->nh.nlmsg_len) + NLA_ALIGN(NLA_HDRLEN + len) > sizeof(*req))
+ 		return -EMSGSIZE;
+ 	if (!!data != !!len)
+ 		return -EINVAL;
+ 
+ 	nla = req_tail(req);
+ 	nla->nla_type = type;
+ 	nla->nla_len = NLA_HDRLEN + len;
+ 	if (data)
+ 		memcpy(nla_data(nla), data, len);
+ 	req->nh.nlmsg_len = NLMSG_ALIGN(req->nh.nlmsg_len) + NLA_ALIGN(nla->nla_len);
+ 	return 0;
+ }
+ 
+ static inline struct nlattr *nlattr_begin_nested(struct libbpf_nla_req *req, int type)
+ {
+ 	struct nlattr *tail;
+ 
+ 	tail = req_tail(req);
+ 	if (nlattr_add(req, type | NLA_F_NESTED, NULL, 0))
+ 		return NULL;
+ 	return tail;
+ }
+ 
+ static inline void nlattr_end_nested(struct libbpf_nla_req *req,
+ 				     struct nlattr *tail)
+ {
+ 	tail->nla_len = (void *)req_tail(req) - (void *)tail;
+ }
+ 
++>>>>>>> ee62a5c6bb10 (libbpf: Switch to void * casting in netlink helpers)
  #endif /* __LIBBPF_NLATTR_H */
* Unmerged path tools/lib/bpf/netlink.c
diff --git a/tools/lib/bpf/nlattr.c b/tools/lib/bpf/nlattr.c
index b607fa9852b1..f57e77a6e40f 100644
--- a/tools/lib/bpf/nlattr.c
+++ b/tools/lib/bpf/nlattr.c
@@ -27,7 +27,7 @@ static struct nlattr *nla_next(const struct nlattr *nla, int *remaining)
 	int totlen = NLA_ALIGN(nla->nla_len);
 
 	*remaining -= totlen;
-	return (struct nlattr *) ((char *) nla + totlen);
+	return (struct nlattr *)((void *)nla + totlen);
 }
 
 static int nla_ok(const struct nlattr *nla, int remaining)
* Unmerged path tools/lib/bpf/nlattr.h
