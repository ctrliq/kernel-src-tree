libbpf: Add request buffer type for netlink messages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Kumar Kartikeya Dwivedi <memxor@gmail.com>
commit 0ae64fb6b645e0f976e08bc3c05e518856f19d00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/0ae64fb6.failed

Coverity complains about OOB writes to nlmsghdr. There is no OOB as we
write to the trailing buffer, but static analyzers and compilers may
rightfully be confused as the nlmsghdr pointer has subobject provenance
(and hence subobject bounds).

Fix this by using an explicit request structure containing the nlmsghdr,
struct tcmsg/ifinfomsg, and attribute buffer.

Also switch nh_tail (renamed to req_tail) to cast req * to char * so
that it can be understood as arithmetic on pointer to the representation
array (hence having same bound as request structure), which should
further appease analyzers.

As a bonus, callers don't have to pass sizeof(req) all the time now, as
size is implicitly obtained using the pointer. While at it, also reduce
the size of attribute buffer to 128 bytes (132 for ifinfomsg using
functions due to the padding).

Summary of problem:

  Even though C standard allows interconvertibility of pointer to first
  member and pointer to struct, for the purposes of alias analysis it
  would still consider the first as having pointer value "pointer to T"
  where T is type of first member hence having subobject bounds,
  allowing analyzers within reason to complain when object is accessed
  beyond the size of pointed to object.

  The only exception to this rule may be when a char * is formed to a
  member subobject. It is not possible for the compiler to be able to
  tell the intent of the programmer that it is a pointer to member
  object or the underlying representation array of the containing
  object, so such diagnosis is suppressed.

Fixes: 715c5ce454a6 ("libbpf: Add low level TC-BPF management API")
	Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20210619041454.417577-1-memxor@gmail.com
(cherry picked from commit 0ae64fb6b645e0f976e08bc3c05e518856f19d00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/netlink.c
#	tools/lib/bpf/nlattr.h
diff --cc tools/lib/bpf/netlink.c
index 4676dcf5eae8,bfaa9a5c50f3..000000000000
--- a/tools/lib/bpf/netlink.c
+++ b/tools/lib/bpf/netlink.c
@@@ -131,72 -154,67 +131,131 @@@ done
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int __bpf_set_link_xdp_fd_replace(int ifindex, int fd, int old_fd,
 +					 __u32 flags)
 +{
 +	int sock, seq = 0, ret;
 +	struct nlattr *nla, *nla_xdp;
 +	struct {
 +		struct nlmsghdr  nh;
 +		struct ifinfomsg ifinfo;
 +		char             attrbuf[64];
 +	} req;
 +	__u32 nl_pid = 0;
 +
 +	sock = libbpf_netlink_open(&nl_pid);
 +	if (sock < 0)
 +		return sock;
++=======
+ static int libbpf_netlink_send_recv(struct libbpf_nla_req *req,
+ 				    __dump_nlmsg_t parse_msg,
+ 				    libbpf_dump_nlmsg_t parse_attr,
+ 				    void *cookie)
+ {
+ 	__u32 nl_pid = 0;
+ 	int sock, ret;
+ 
+ 	sock = libbpf_netlink_open(&nl_pid);
+ 	if (sock < 0)
+ 		return sock;
+ 
+ 	req->nh.nlmsg_pid = 0;
+ 	req->nh.nlmsg_seq = time(NULL);
+ 
+ 	if (send(sock, req, req->nh.nlmsg_len, 0) < 0) {
+ 		ret = -errno;
+ 		goto out;
+ 	}
+ 
+ 	ret = libbpf_netlink_recv(sock, nl_pid, req->nh.nlmsg_seq,
+ 				  parse_msg, parse_attr, cookie);
+ out:
+ 	libbpf_netlink_close(sock);
+ 	return ret;
+ }
+ 
+ static int __bpf_set_link_xdp_fd_replace(int ifindex, int fd, int old_fd,
+ 					 __u32 flags)
+ {
+ 	struct nlattr *nla;
+ 	int ret;
+ 	struct libbpf_nla_req req;
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
  
  	memset(&req, 0, sizeof(req));
 -	req.nh.nlmsg_len      = NLMSG_LENGTH(sizeof(struct ifinfomsg));
 -	req.nh.nlmsg_flags    = NLM_F_REQUEST | NLM_F_ACK;
 -	req.nh.nlmsg_type     = RTM_SETLINK;
 +	req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
 +	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
 +	req.nh.nlmsg_type = RTM_SETLINK;
 +	req.nh.nlmsg_pid = 0;
 +	req.nh.nlmsg_seq = ++seq;
  	req.ifinfo.ifi_family = AF_UNSPEC;
 -	req.ifinfo.ifi_index  = ifindex;
 +	req.ifinfo.ifi_index = ifindex;
 +
++<<<<<<< HEAD
 +	/* started nested attribute for XDP */
 +	nla = (struct nlattr *)(((char *)&req)
 +				+ NLMSG_ALIGN(req.nh.nlmsg_len));
 +	nla->nla_type = NLA_F_NESTED | IFLA_XDP;
 +	nla->nla_len = NLA_HDRLEN;
 +
 +	/* add XDP fd */
 +	nla_xdp = (struct nlattr *)((char *)nla + nla->nla_len);
 +	nla_xdp->nla_type = IFLA_XDP_FD;
 +	nla_xdp->nla_len = NLA_HDRLEN + sizeof(int);
 +	memcpy((char *)nla_xdp + NLA_HDRLEN, &fd, sizeof(fd));
 +	nla->nla_len += nla_xdp->nla_len;
 +
 +	/* if user passed in any flags, add those too */
 +	if (flags) {
 +		nla_xdp = (struct nlattr *)((char *)nla + nla->nla_len);
 +		nla_xdp->nla_type = IFLA_XDP_FLAGS;
 +		nla_xdp->nla_len = NLA_HDRLEN + sizeof(flags);
 +		memcpy((char *)nla_xdp + NLA_HDRLEN, &flags, sizeof(flags));
 +		nla->nla_len += nla_xdp->nla_len;
 +	}
 +
 +	if (flags & XDP_FLAGS_REPLACE) {
 +		nla_xdp = (struct nlattr *)((char *)nla + nla->nla_len);
 +		nla_xdp->nla_type = IFLA_XDP_EXPECTED_FD;
 +		nla_xdp->nla_len = NLA_HDRLEN + sizeof(old_fd);
 +		memcpy((char *)nla_xdp + NLA_HDRLEN, &old_fd, sizeof(old_fd));
 +		nla->nla_len += nla_xdp->nla_len;
 +	}
 +
 +	req.nh.nlmsg_len += NLA_ALIGN(nla->nla_len);
  
 +	if (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {
 +		ret = -errno;
 +		goto cleanup;
 +	}
 +	ret = bpf_netlink_recv(sock, nl_pid, seq, NULL, NULL, NULL);
 +
 +cleanup:
 +	close(sock);
 +	return ret;
++=======
+ 	nla = nlattr_begin_nested(&req, IFLA_XDP);
+ 	if (!nla)
+ 		return -EMSGSIZE;
+ 	ret = nlattr_add(&req, IFLA_XDP_FD, &fd, sizeof(fd));
+ 	if (ret < 0)
+ 		return ret;
+ 	if (flags) {
+ 		ret = nlattr_add(&req, IFLA_XDP_FLAGS, &flags, sizeof(flags));
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 	if (flags & XDP_FLAGS_REPLACE) {
+ 		ret = nlattr_add(&req, IFLA_XDP_EXPECTED_FD, &old_fd,
+ 				 sizeof(old_fd));
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 	nlattr_end_nested(&req, nla);
+ 
+ 	return libbpf_netlink_send_recv(&req, NULL, NULL, NULL);
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
  }
  
  int bpf_set_link_xdp_fd_opts(int ifindex, int fd, __u32 flags,
@@@ -282,19 -303,21 +341,29 @@@ static int get_xdp_info(void *cookie, v
  	return 0;
  }
  
 -int bpf_get_link_xdp_info(int ifindex, struct xdp_link_info *info,
 -			  size_t info_size, __u32 flags)
 +static int libbpf_nl_get_link(int sock, unsigned int nl_pid,
 +			      libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie);
 +
 +int bpf_get_link_xdp_info_v0_0_4(int ifindex, struct xdp_link_info *info,
 +				 size_t info_size, __u32 flags)
  {
  	struct xdp_id_md xdp_id = {};
 +	int sock, ret;
 +	__u32 nl_pid = 0;
  	__u32 mask;
++<<<<<<< HEAD
++=======
+ 	int ret;
+ 	struct libbpf_nla_req req = {
+ 		.nh.nlmsg_len      = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
+ 		.nh.nlmsg_type     = RTM_GETLINK,
+ 		.nh.nlmsg_flags    = NLM_F_DUMP | NLM_F_REQUEST,
+ 		.ifinfo.ifi_family = AF_PACKET,
+ 	};
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
  
  	if (flags & ~XDP_FLAGS_MASK || !info_size)
 -		return libbpf_err(-EINVAL);
 +		return -EINVAL;
  
  	/* Check whether the single {HW,DRV,SKB} mode is set */
  	flags &= (XDP_FLAGS_SKB_MODE | XDP_FLAGS_DRV_MODE | XDP_FLAGS_HW_MODE);
@@@ -309,7 -328,8 +378,12 @@@
  	xdp_id.ifindex = ifindex;
  	xdp_id.flags = flags;
  
++<<<<<<< HEAD
 +	ret = libbpf_nl_get_link(sock, nl_pid, get_xdp_info, &xdp_id);
++=======
+ 	ret = libbpf_netlink_send_recv(&req, __dump_link_nlmsg,
+ 				       get_xdp_info, &xdp_id);
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
  	if (!ret) {
  		size_t sz = min(info_size, sizeof(xdp_id.info));
  
@@@ -346,37 -365,394 +420,428 @@@ int bpf_get_link_xdp_id(int ifindex, __
  	if (!ret)
  		*prog_id = get_xdp_id(&info, flags);
  
 -	return libbpf_err(ret);
 +	return ret;
 +}
 +
++<<<<<<< HEAD
 +int libbpf_nl_get_link(int sock, unsigned int nl_pid,
 +		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie)
 +{
 +	struct {
 +		struct nlmsghdr nlh;
 +		struct ifinfomsg ifm;
 +	} req = {
 +		.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
 +		.nlh.nlmsg_type = RTM_GETLINK,
 +		.nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST,
 +		.ifm.ifi_family = AF_PACKET,
 +	};
 +	int seq = time(NULL);
 +
 +	req.nlh.nlmsg_seq = seq;
 +	if (send(sock, &req, req.nlh.nlmsg_len, 0) < 0)
 +		return -errno;
 +
 +	return bpf_netlink_recv(sock, nl_pid, seq, __dump_link_nlmsg,
 +				dump_link_nlmsg, cookie);
  }
  
 +/* RHEL-only, libbpf version workaround */
 +extern int bpf_get_link_xdp_info_v0_0_6(int ifindex, struct xdp_link_info *info,
 +					size_t info_size, __u32 flags)
 +	__attribute__((alias("bpf_get_link_xdp_info_v0_0_4")));
 +
 +COMPAT_VERSION(bpf_get_link_xdp_info_v0_0_4,
 +	       bpf_get_link_xdp_info, LIBBPF_0.0.4)
 +DEFAULT_VERSION(bpf_get_link_xdp_info_v0_0_6,
 +	        bpf_get_link_xdp_info, LIBBPF_0.0.6)
++=======
+ typedef int (*qdisc_config_t)(struct libbpf_nla_req *req);
+ 
+ static int clsact_config(struct libbpf_nla_req *req)
+ {
+ 	req->tc.tcm_parent = TC_H_CLSACT;
+ 	req->tc.tcm_handle = TC_H_MAKE(TC_H_CLSACT, 0);
+ 
+ 	return nlattr_add(req, TCA_KIND, "clsact", sizeof("clsact"));
+ }
+ 
+ static int attach_point_to_config(struct bpf_tc_hook *hook,
+ 				  qdisc_config_t *config)
+ {
+ 	switch (OPTS_GET(hook, attach_point, 0)) {
+ 	case BPF_TC_INGRESS:
+ 	case BPF_TC_EGRESS:
+ 	case BPF_TC_INGRESS | BPF_TC_EGRESS:
+ 		if (OPTS_GET(hook, parent, 0))
+ 			return -EINVAL;
+ 		*config = &clsact_config;
+ 		return 0;
+ 	case BPF_TC_CUSTOM:
+ 		return -EOPNOTSUPP;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int tc_get_tcm_parent(enum bpf_tc_attach_point attach_point,
+ 			     __u32 *parent)
+ {
+ 	switch (attach_point) {
+ 	case BPF_TC_INGRESS:
+ 	case BPF_TC_EGRESS:
+ 		if (*parent)
+ 			return -EINVAL;
+ 		*parent = TC_H_MAKE(TC_H_CLSACT,
+ 				    attach_point == BPF_TC_INGRESS ?
+ 				    TC_H_MIN_INGRESS : TC_H_MIN_EGRESS);
+ 		break;
+ 	case BPF_TC_CUSTOM:
+ 		if (!*parent)
+ 			return -EINVAL;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
+ static int tc_qdisc_modify(struct bpf_tc_hook *hook, int cmd, int flags)
+ {
+ 	qdisc_config_t config;
+ 	int ret;
+ 	struct libbpf_nla_req req;
+ 
+ 	ret = attach_point_to_config(hook, &config);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
+ 	req.nh.nlmsg_type  = cmd;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = OPTS_GET(hook, ifindex, 0);
+ 
+ 	ret = config(&req);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return libbpf_netlink_send_recv(&req, NULL, NULL, NULL);
+ }
+ 
+ static int tc_qdisc_create_excl(struct bpf_tc_hook *hook)
+ {
+ 	return tc_qdisc_modify(hook, RTM_NEWQDISC, NLM_F_CREATE | NLM_F_EXCL);
+ }
+ 
+ static int tc_qdisc_delete(struct bpf_tc_hook *hook)
+ {
+ 	return tc_qdisc_modify(hook, RTM_DELQDISC, 0);
+ }
+ 
+ int bpf_tc_hook_create(struct bpf_tc_hook *hook)
+ {
+ 	int ret;
+ 
+ 	if (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    OPTS_GET(hook, ifindex, 0) <= 0)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ret = tc_qdisc_create_excl(hook);
+ 	return libbpf_err(ret);
+ }
+ 
+ static int __bpf_tc_detach(const struct bpf_tc_hook *hook,
+ 			   const struct bpf_tc_opts *opts,
+ 			   const bool flush);
+ 
+ int bpf_tc_hook_destroy(struct bpf_tc_hook *hook)
+ {
+ 	if (!hook || !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    OPTS_GET(hook, ifindex, 0) <= 0)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	switch (OPTS_GET(hook, attach_point, 0)) {
+ 	case BPF_TC_INGRESS:
+ 	case BPF_TC_EGRESS:
+ 		return libbpf_err(__bpf_tc_detach(hook, NULL, true));
+ 	case BPF_TC_INGRESS | BPF_TC_EGRESS:
+ 		return libbpf_err(tc_qdisc_delete(hook));
+ 	case BPF_TC_CUSTOM:
+ 		return libbpf_err(-EOPNOTSUPP);
+ 	default:
+ 		return libbpf_err(-EINVAL);
+ 	}
+ }
+ 
+ struct bpf_cb_ctx {
+ 	struct bpf_tc_opts *opts;
+ 	bool processed;
+ };
+ 
+ static int __get_tc_info(void *cookie, struct tcmsg *tc, struct nlattr **tb,
+ 			 bool unicast)
+ {
+ 	struct nlattr *tbb[TCA_BPF_MAX + 1];
+ 	struct bpf_cb_ctx *info = cookie;
+ 
+ 	if (!info || !info->opts)
+ 		return -EINVAL;
+ 	if (unicast && info->processed)
+ 		return -EINVAL;
+ 	if (!tb[TCA_OPTIONS])
+ 		return NL_CONT;
+ 
+ 	libbpf_nla_parse_nested(tbb, TCA_BPF_MAX, tb[TCA_OPTIONS], NULL);
+ 	if (!tbb[TCA_BPF_ID])
+ 		return -EINVAL;
+ 
+ 	OPTS_SET(info->opts, prog_id, libbpf_nla_getattr_u32(tbb[TCA_BPF_ID]));
+ 	OPTS_SET(info->opts, handle, tc->tcm_handle);
+ 	OPTS_SET(info->opts, priority, TC_H_MAJ(tc->tcm_info) >> 16);
+ 
+ 	info->processed = true;
+ 	return unicast ? NL_NEXT : NL_DONE;
+ }
+ 
+ static int get_tc_info(struct nlmsghdr *nh, libbpf_dump_nlmsg_t fn,
+ 		       void *cookie)
+ {
+ 	struct tcmsg *tc = NLMSG_DATA(nh);
+ 	struct nlattr *tb[TCA_MAX + 1];
+ 
+ 	libbpf_nla_parse(tb, TCA_MAX,
+ 			 (struct nlattr *)((char *)tc + NLMSG_ALIGN(sizeof(*tc))),
+ 			 NLMSG_PAYLOAD(nh, sizeof(*tc)), NULL);
+ 	if (!tb[TCA_KIND])
+ 		return NL_CONT;
+ 	return __get_tc_info(cookie, tc, tb, nh->nlmsg_flags & NLM_F_ECHO);
+ }
+ 
+ static int tc_add_fd_and_name(struct libbpf_nla_req *req, int fd)
+ {
+ 	struct bpf_prog_info info = {};
+ 	__u32 info_len = sizeof(info);
+ 	char name[256];
+ 	int len, ret;
+ 
+ 	ret = bpf_obj_get_info_by_fd(fd, &info, &info_len);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = nlattr_add(req, TCA_BPF_FD, &fd, sizeof(fd));
+ 	if (ret < 0)
+ 		return ret;
+ 	len = snprintf(name, sizeof(name), "%s:[%u]", info.name, info.id);
+ 	if (len < 0)
+ 		return -errno;
+ 	if (len >= sizeof(name))
+ 		return -ENAMETOOLONG;
+ 	return nlattr_add(req, TCA_BPF_NAME, name, len + 1);
+ }
+ 
+ int bpf_tc_attach(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)
+ {
+ 	__u32 protocol, bpf_flags, handle, priority, parent, prog_id, flags;
+ 	int ret, ifindex, attach_point, prog_fd;
+ 	struct bpf_cb_ctx info = {};
+ 	struct libbpf_nla_req req;
+ 	struct nlattr *nla;
+ 
+ 	if (!hook || !opts ||
+ 	    !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    !OPTS_VALID(opts, bpf_tc_opts))
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ifindex      = OPTS_GET(hook, ifindex, 0);
+ 	parent       = OPTS_GET(hook, parent, 0);
+ 	attach_point = OPTS_GET(hook, attach_point, 0);
+ 
+ 	handle       = OPTS_GET(opts, handle, 0);
+ 	priority     = OPTS_GET(opts, priority, 0);
+ 	prog_fd      = OPTS_GET(opts, prog_fd, 0);
+ 	prog_id      = OPTS_GET(opts, prog_id, 0);
+ 	flags        = OPTS_GET(opts, flags, 0);
+ 
+ 	if (ifindex <= 0 || !prog_fd || prog_id)
+ 		return libbpf_err(-EINVAL);
+ 	if (priority > UINT16_MAX)
+ 		return libbpf_err(-EINVAL);
+ 	if (flags & ~BPF_TC_F_REPLACE)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	flags = (flags & BPF_TC_F_REPLACE) ? NLM_F_REPLACE : NLM_F_EXCL;
+ 	protocol = ETH_P_ALL;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE |
+ 			     NLM_F_ECHO | flags;
+ 	req.nh.nlmsg_type  = RTM_NEWTFILTER;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = ifindex;
+ 	req.tc.tcm_handle  = handle;
+ 	req.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));
+ 
+ 	ret = tc_get_tcm_parent(attach_point, &parent);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	req.tc.tcm_parent = parent;
+ 
+ 	ret = nlattr_add(&req, TCA_KIND, "bpf", sizeof("bpf"));
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	nla = nlattr_begin_nested(&req, TCA_OPTIONS);
+ 	if (!nla)
+ 		return libbpf_err(-EMSGSIZE);
+ 	ret = tc_add_fd_and_name(&req, prog_fd);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	bpf_flags = TCA_BPF_FLAG_ACT_DIRECT;
+ 	ret = nlattr_add(&req, TCA_BPF_FLAGS, &bpf_flags, sizeof(bpf_flags));
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	nlattr_end_nested(&req, nla);
+ 
+ 	info.opts = opts;
+ 
+ 	ret = libbpf_netlink_send_recv(&req, get_tc_info, NULL, &info);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	if (!info.processed)
+ 		return libbpf_err(-ENOENT);
+ 	return ret;
+ }
+ 
+ static int __bpf_tc_detach(const struct bpf_tc_hook *hook,
+ 			   const struct bpf_tc_opts *opts,
+ 			   const bool flush)
+ {
+ 	__u32 protocol = 0, handle, priority, parent, prog_id, flags;
+ 	int ret, ifindex, attach_point, prog_fd;
+ 	struct libbpf_nla_req req;
+ 
+ 	if (!hook ||
+ 	    !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    !OPTS_VALID(opts, bpf_tc_opts))
+ 		return -EINVAL;
+ 
+ 	ifindex      = OPTS_GET(hook, ifindex, 0);
+ 	parent       = OPTS_GET(hook, parent, 0);
+ 	attach_point = OPTS_GET(hook, attach_point, 0);
+ 
+ 	handle       = OPTS_GET(opts, handle, 0);
+ 	priority     = OPTS_GET(opts, priority, 0);
+ 	prog_fd      = OPTS_GET(opts, prog_fd, 0);
+ 	prog_id      = OPTS_GET(opts, prog_id, 0);
+ 	flags        = OPTS_GET(opts, flags, 0);
+ 
+ 	if (ifindex <= 0 || flags || prog_fd || prog_id)
+ 		return -EINVAL;
+ 	if (priority > UINT16_MAX)
+ 		return -EINVAL;
+ 	if (!flush) {
+ 		if (!handle || !priority)
+ 			return -EINVAL;
+ 		protocol = ETH_P_ALL;
+ 	} else {
+ 		if (handle || priority)
+ 			return -EINVAL;
+ 	}
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+ 	req.nh.nlmsg_type  = RTM_DELTFILTER;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = ifindex;
+ 	if (!flush) {
+ 		req.tc.tcm_handle = handle;
+ 		req.tc.tcm_info   = TC_H_MAKE(priority << 16, htons(protocol));
+ 	}
+ 
+ 	ret = tc_get_tcm_parent(attach_point, &parent);
+ 	if (ret < 0)
+ 		return ret;
+ 	req.tc.tcm_parent = parent;
+ 
+ 	if (!flush) {
+ 		ret = nlattr_add(&req, TCA_KIND, "bpf", sizeof("bpf"));
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	return libbpf_netlink_send_recv(&req, NULL, NULL, NULL);
+ }
+ 
+ int bpf_tc_detach(const struct bpf_tc_hook *hook,
+ 		  const struct bpf_tc_opts *opts)
+ {
+ 	int ret;
+ 
+ 	if (!opts)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ret = __bpf_tc_detach(hook, opts, false);
+ 	return libbpf_err(ret);
+ }
+ 
+ int bpf_tc_query(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts)
+ {
+ 	__u32 protocol, handle, priority, parent, prog_id, flags;
+ 	int ret, ifindex, attach_point, prog_fd;
+ 	struct bpf_cb_ctx info = {};
+ 	struct libbpf_nla_req req;
+ 
+ 	if (!hook || !opts ||
+ 	    !OPTS_VALID(hook, bpf_tc_hook) ||
+ 	    !OPTS_VALID(opts, bpf_tc_opts))
+ 		return libbpf_err(-EINVAL);
+ 
+ 	ifindex      = OPTS_GET(hook, ifindex, 0);
+ 	parent       = OPTS_GET(hook, parent, 0);
+ 	attach_point = OPTS_GET(hook, attach_point, 0);
+ 
+ 	handle       = OPTS_GET(opts, handle, 0);
+ 	priority     = OPTS_GET(opts, priority, 0);
+ 	prog_fd      = OPTS_GET(opts, prog_fd, 0);
+ 	prog_id      = OPTS_GET(opts, prog_id, 0);
+ 	flags        = OPTS_GET(opts, flags, 0);
+ 
+ 	if (ifindex <= 0 || flags || prog_fd || prog_id ||
+ 	    !handle || !priority)
+ 		return libbpf_err(-EINVAL);
+ 	if (priority > UINT16_MAX)
+ 		return libbpf_err(-EINVAL);
+ 
+ 	protocol = ETH_P_ALL;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct tcmsg));
+ 	req.nh.nlmsg_flags = NLM_F_REQUEST;
+ 	req.nh.nlmsg_type  = RTM_GETTFILTER;
+ 	req.tc.tcm_family  = AF_UNSPEC;
+ 	req.tc.tcm_ifindex = ifindex;
+ 	req.tc.tcm_handle  = handle;
+ 	req.tc.tcm_info    = TC_H_MAKE(priority << 16, htons(protocol));
+ 
+ 	ret = tc_get_tcm_parent(attach_point, &parent);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	req.tc.tcm_parent = parent;
+ 
+ 	ret = nlattr_add(&req, TCA_KIND, "bpf", sizeof("bpf"));
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 
+ 	info.opts = opts;
+ 
+ 	ret = libbpf_netlink_send_recv(&req, get_tc_info, NULL, &info);
+ 	if (ret < 0)
+ 		return libbpf_err(ret);
+ 	if (!info.processed)
+ 		return libbpf_err(-ENOENT);
+ 	return ret;
+ }
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
diff --cc tools/lib/bpf/nlattr.h
index 6cc3ac91690f,76cbfeb21955..000000000000
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@@ -10,7 -10,11 +10,12 @@@
  #define __LIBBPF_NLATTR_H
  
  #include <stdint.h>
 -#include <string.h>
 -#include <errno.h>
  #include <linux/netlink.h>
++<<<<<<< HEAD
++=======
+ #include <linux/rtnetlink.h>
+ 
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
  /* avoid multiple definition of netlink features */
  #define __LINUX_NETLINK_H
  
@@@ -103,4 -116,49 +117,52 @@@ int libbpf_nla_parse_nested(struct nlat
  
  int libbpf_nla_dump_errormsg(struct nlmsghdr *nlh);
  
++<<<<<<< HEAD
++=======
+ static inline struct nlattr *nla_data(struct nlattr *nla)
+ {
+ 	return (struct nlattr *)((char *)nla + NLA_HDRLEN);
+ }
+ 
+ static inline struct nlattr *req_tail(struct libbpf_nla_req *req)
+ {
+ 	return (struct nlattr *)((char *)req + NLMSG_ALIGN(req->nh.nlmsg_len));
+ }
+ 
+ static inline int nlattr_add(struct libbpf_nla_req *req, int type,
+ 			     const void *data, int len)
+ {
+ 	struct nlattr *nla;
+ 
+ 	if (NLMSG_ALIGN(req->nh.nlmsg_len) + NLA_ALIGN(NLA_HDRLEN + len) > sizeof(*req))
+ 		return -EMSGSIZE;
+ 	if (!!data != !!len)
+ 		return -EINVAL;
+ 
+ 	nla = req_tail(req);
+ 	nla->nla_type = type;
+ 	nla->nla_len = NLA_HDRLEN + len;
+ 	if (data)
+ 		memcpy(nla_data(nla), data, len);
+ 	req->nh.nlmsg_len = NLMSG_ALIGN(req->nh.nlmsg_len) + NLA_ALIGN(nla->nla_len);
+ 	return 0;
+ }
+ 
+ static inline struct nlattr *nlattr_begin_nested(struct libbpf_nla_req *req, int type)
+ {
+ 	struct nlattr *tail;
+ 
+ 	tail = req_tail(req);
+ 	if (nlattr_add(req, type | NLA_F_NESTED, NULL, 0))
+ 		return NULL;
+ 	return tail;
+ }
+ 
+ static inline void nlattr_end_nested(struct libbpf_nla_req *req,
+ 				     struct nlattr *tail)
+ {
+ 	tail->nla_len = (char *)req_tail(req) - (char *)tail;
+ }
+ 
++>>>>>>> 0ae64fb6b645 (libbpf: Add request buffer type for netlink messages)
  #endif /* __LIBBPF_NLATTR_H */
* Unmerged path tools/lib/bpf/netlink.c
* Unmerged path tools/lib/bpf/nlattr.h
