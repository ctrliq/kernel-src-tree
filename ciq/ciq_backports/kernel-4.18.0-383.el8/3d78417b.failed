bpf: Add bpf_btf_find_by_name_kind() helper.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit 3d78417b60fba249cc555468cb72d96f5cde2964
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/3d78417b.failed

Add new helper:
long bpf_btf_find_by_name_kind(char *name, int name_sz, u32 kind, int flags)
Description
	Find BTF type with given name and kind in vmlinux BTF or in module's BTFs.
Return
	Returns btf_id and btf_obj_fd in lower and upper 32 bits.

It will be used by loader program to find btf_id to attach the program to
and to find btf_ids of ksyms.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/bpf/20210514003623.28033-10-alexei.starovoitov@gmail.com
(cherry picked from commit 3d78417b60fba249cc555468cb72d96f5cde2964)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index d613063f6429,3cc07351c1cf..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -4755,6 -4742,18 +4755,21 @@@ union bpf_attr 
   *		be zero-terminated except when **str_size** is 0.
   *
   *		Or **-EBUSY** if the per-CPU memory copy buffer is busy.
++<<<<<<< HEAD
++=======
+  *
+  * long bpf_sys_bpf(u32 cmd, void *attr, u32 attr_size)
+  * 	Description
+  * 		Execute bpf syscall with given arguments.
+  * 	Return
+  * 		A syscall result.
+  *
+  * long bpf_btf_find_by_name_kind(char *name, int name_sz, u32 kind, int flags)
+  * 	Description
+  * 		Find BTF type with given name and kind in vmlinux BTF or in module's BTFs.
+  * 	Return
+  * 		Returns btf_id and btf_obj_fd in lower and upper 32 bits.
++>>>>>>> 3d78417b60fb (bpf: Add bpf_btf_find_by_name_kind() helper.)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -4923,6 -4922,8 +4938,11 @@@
  	FN(check_mtu),			\
  	FN(for_each_map_elem),		\
  	FN(snprintf),			\
++<<<<<<< HEAD
++=======
+ 	FN(sys_bpf),			\
+ 	FN(btf_find_by_name_kind),	\
++>>>>>>> 3d78417b60fb (bpf: Add bpf_btf_find_by_name_kind() helper.)
  	/* */
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
diff --cc kernel/bpf/syscall.c
index 7aed15cc139e,f93ff2ebf96d..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -4541,3 -4527,75 +4541,78 @@@ SYSCALL_DEFINE3(bpf, int, cmd, union bp
  
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)
+ {
+ 	return __sys_bpf(cmd, USER_BPFPTR(uattr), size);
+ }
+ 
+ static bool syscall_prog_is_valid_access(int off, int size,
+ 					 enum bpf_access_type type,
+ 					 const struct bpf_prog *prog,
+ 					 struct bpf_insn_access_aux *info)
+ {
+ 	if (off < 0 || off >= U16_MAX)
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 	return true;
+ }
+ 
+ BPF_CALL_3(bpf_sys_bpf, int, cmd, void *, attr, u32, attr_size)
+ {
+ 	switch (cmd) {
+ 	case BPF_MAP_CREATE:
+ 	case BPF_MAP_UPDATE_ELEM:
+ 	case BPF_MAP_FREEZE:
+ 	case BPF_PROG_LOAD:
+ 	case BPF_BTF_LOAD:
+ 		break;
+ 	/* case BPF_PROG_TEST_RUN:
+ 	 * is not part of this list to prevent recursive test_run
+ 	 */
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 	return __sys_bpf(cmd, KERNEL_BPFPTR(attr), attr_size);
+ }
+ 
+ const struct bpf_func_proto bpf_sys_bpf_proto = {
+ 	.func		= bpf_sys_bpf,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_ANYTHING,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ const struct bpf_func_proto * __weak
+ tracing_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	return bpf_base_func_proto(func_id);
+ }
+ 
+ static const struct bpf_func_proto *
+ syscall_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_sys_bpf:
+ 		return &bpf_sys_bpf_proto;
+ 	case BPF_FUNC_btf_find_by_name_kind:
+ 		return &bpf_btf_find_by_name_kind_proto;
+ 	default:
+ 		return tracing_prog_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ const struct bpf_verifier_ops bpf_syscall_verifier_ops = {
+ 	.get_func_proto  = syscall_prog_func_proto,
+ 	.is_valid_access = syscall_prog_is_valid_access,
+ };
+ 
+ const struct bpf_prog_ops bpf_syscall_prog_ops = {
+ 	.test_run = bpf_prog_test_run_syscall,
+ };
++>>>>>>> 3d78417b60fb (bpf: Add bpf_btf_find_by_name_kind() helper.)
diff --cc tools/include/uapi/linux/bpf.h
index ed06cd84257e,3cc07351c1cf..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -4735,6 -4742,18 +4735,21 @@@ union bpf_attr 
   *		be zero-terminated except when **str_size** is 0.
   *
   *		Or **-EBUSY** if the per-CPU memory copy buffer is busy.
++<<<<<<< HEAD
++=======
+  *
+  * long bpf_sys_bpf(u32 cmd, void *attr, u32 attr_size)
+  * 	Description
+  * 		Execute bpf syscall with given arguments.
+  * 	Return
+  * 		A syscall result.
+  *
+  * long bpf_btf_find_by_name_kind(char *name, int name_sz, u32 kind, int flags)
+  * 	Description
+  * 		Find BTF type with given name and kind in vmlinux BTF or in module's BTFs.
+  * 	Return
+  * 		Returns btf_id and btf_obj_fd in lower and upper 32 bits.
++>>>>>>> 3d78417b60fb (bpf: Add bpf_btf_find_by_name_kind() helper.)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -4903,6 -4922,8 +4918,11 @@@
  	FN(check_mtu),			\
  	FN(for_each_map_elem),		\
  	FN(snprintf),			\
++<<<<<<< HEAD
++=======
+ 	FN(sys_bpf),			\
+ 	FN(btf_find_by_name_kind),	\
++>>>>>>> 3d78417b60fb (bpf: Add bpf_btf_find_by_name_kind() helper.)
  	/* */
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 03b6e29e91cf..99f30c6e216d 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -1985,6 +1985,7 @@ extern const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto;
 extern const struct bpf_func_proto bpf_sock_from_file_proto;
 extern const struct bpf_func_proto bpf_get_socket_ptr_cookie_proto;
 extern const struct bpf_func_proto bpf_for_each_map_elem_proto;
+extern const struct bpf_func_proto bpf_btf_find_by_name_kind_proto;
 
 const struct bpf_func_proto *bpf_tracing_func_proto(
 	enum bpf_func_id func_id, const struct bpf_prog *prog);
* Unmerged path include/uapi/linux/bpf.h
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index 05e47a04435b..49d8c6e3c1fa 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -6098,3 +6098,65 @@ struct module *btf_try_get_module(const struct btf *btf)
 
 	return res;
 }
+
+BPF_CALL_4(bpf_btf_find_by_name_kind, char *, name, int, name_sz, u32, kind, int, flags)
+{
+	struct btf *btf;
+	long ret;
+
+	if (flags)
+		return -EINVAL;
+
+	if (name_sz <= 1 || name[name_sz - 1])
+		return -EINVAL;
+
+	btf = bpf_get_btf_vmlinux();
+	if (IS_ERR(btf))
+		return PTR_ERR(btf);
+
+	ret = btf_find_by_name_kind(btf, name, kind);
+	/* ret is never zero, since btf_find_by_name_kind returns
+	 * positive btf_id or negative error.
+	 */
+	if (ret < 0) {
+		struct btf *mod_btf;
+		int id;
+
+		/* If name is not found in vmlinux's BTF then search in module's BTFs */
+		spin_lock_bh(&btf_idr_lock);
+		idr_for_each_entry(&btf_idr, mod_btf, id) {
+			if (!btf_is_module(mod_btf))
+				continue;
+			/* linear search could be slow hence unlock/lock
+			 * the IDR to avoiding holding it for too long
+			 */
+			btf_get(mod_btf);
+			spin_unlock_bh(&btf_idr_lock);
+			ret = btf_find_by_name_kind(mod_btf, name, kind);
+			if (ret > 0) {
+				int btf_obj_fd;
+
+				btf_obj_fd = __btf_new_fd(mod_btf);
+				if (btf_obj_fd < 0) {
+					btf_put(mod_btf);
+					return btf_obj_fd;
+				}
+				return ret | (((u64)btf_obj_fd) << 32);
+			}
+			spin_lock_bh(&btf_idr_lock);
+			btf_put(mod_btf);
+		}
+		spin_unlock_bh(&btf_idr_lock);
+	}
+	return ret;
+}
+
+const struct bpf_func_proto bpf_btf_find_by_name_kind_proto = {
+	.func		= bpf_btf_find_by_name_kind,
+	.gpl_only	= false,
+	.ret_type	= RET_INTEGER,
+	.arg1_type	= ARG_PTR_TO_MEM,
+	.arg2_type	= ARG_CONST_SIZE,
+	.arg3_type	= ARG_ANYTHING,
+	.arg4_type	= ARG_ANYTHING,
+};
* Unmerged path kernel/bpf/syscall.c
* Unmerged path tools/include/uapi/linux/bpf.h
