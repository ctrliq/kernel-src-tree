net/mlx5e: Decouple TTC logic from mlx5e

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Maor Gottlieb <maorg@nvidia.com>
commit bc29764ed9a2335a4f2453eba3f270ca84164a6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/bc29764e.failed

Remove dependency in the mlx5e driver from the TTC implementation
by changing the TTC related functions to receive mlx5 generic arguments.
It allows to decouple TTC logic from mlx5e and reused by other parts of
mlx5 driver.

	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit bc29764ed9a2335a4f2453eba3f270ca84164a6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 3a86dae16687,c289f7004e10..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -93,28 -94,30 +93,37 @@@ enum mlx5e_traffic_types 
  				 MLX5_HASH_FIELD_SEL_DST_IP   |\
  				 MLX5_HASH_FIELD_SEL_IPSEC_SPI)
  
 -enum mlx5_tunnel_types {
 -	MLX5_TT_IPV4_GRE,
 -	MLX5_TT_IPV6_GRE,
 -	MLX5_TT_IPV4_IPIP,
 -	MLX5_TT_IPV6_IPIP,
 -	MLX5_TT_IPV4_IPV6,
 -	MLX5_TT_IPV6_IPV6,
 -	MLX5_NUM_TUNNEL_TT,
 +enum mlx5e_tunnel_types {
 +	MLX5E_TT_IPV4_GRE,
 +	MLX5E_TT_IPV6_GRE,
 +	MLX5E_TT_IPV4_IPIP,
 +	MLX5E_TT_IPV6_IPIP,
 +	MLX5E_TT_IPV4_IPV6,
 +	MLX5E_TT_IPV6_IPV6,
 +	MLX5E_NUM_TUNNEL_TT,
  };
  
 -bool mlx5_tunnel_inner_ft_supported(struct mlx5_core_dev *mdev);
 +bool mlx5e_tunnel_inner_ft_supported(struct mlx5_core_dev *mdev);
  
- struct mlx5e_ttc_rule {
+ struct mlx5_ttc_rule {
  	struct mlx5_flow_handle *rule;
  	struct mlx5_flow_destination default_dest;
  };
  
  /* L3/L4 traffic type classifier */
++<<<<<<< HEAD
 +struct mlx5e_ttc_table {
 +	struct mlx5e_flow_table ft;
 +	struct mlx5e_ttc_rule rules[MLX5E_NUM_TT];
 +	struct mlx5_flow_handle *tunnel_rules[MLX5E_NUM_TUNNEL_TT];
++=======
+ struct mlx5_ttc_table {
+ 	int num_groups;
+ 	struct mlx5_flow_table *t;
+ 	struct mlx5_flow_group **g;
+ 	struct mlx5_ttc_rule rules[MLX5_NUM_TT];
+ 	struct mlx5_flow_handle *tunnel_rules[MLX5_NUM_TUNNEL_TT];
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  };
  
  /* NIC prio FTS */
@@@ -236,26 -239,28 +245,36 @@@ struct mlx5e_flow_steering 
  };
  
  struct ttc_params {
+ 	struct mlx5_flow_namespace *ns;
  	struct mlx5_flow_table_attr ft_attr;
- 	u32 any_tt_tirn;
- 	u32 indir_tirn[MLX5E_NUM_INDIR_TIRS];
- 	struct mlx5e_ttc_table *inner_ttc;
+ 	struct mlx5_flow_destination dests[MLX5_NUM_TT];
+ 	bool   inner_ttc;
+ 	struct mlx5_flow_destination tunnel_dests[MLX5_NUM_TUNNEL_TT];
  };
  
- void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv, struct ttc_params *ttc_params);
- void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params);
+ void mlx5e_set_ttc_params(struct mlx5e_priv *priv,
+ 			  struct ttc_params *ttc_params, bool tunnel);
  
- int mlx5e_create_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
- 			   struct mlx5e_ttc_table *ttc);
- void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv,
- 			     struct mlx5e_ttc_table *ttc);
+ int mlx5_create_ttc_table(struct mlx5_core_dev *dev, struct ttc_params *params,
+ 			  struct mlx5_ttc_table *ttc);
+ void mlx5_destroy_ttc_table(struct mlx5_ttc_table *ttc);
  
  void mlx5e_destroy_flow_table(struct mlx5e_flow_table *ft);
++<<<<<<< HEAD
 +int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
 +		       struct mlx5_flow_destination *new_dest);
 +struct mlx5_flow_destination
 +mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type);
 +int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type);
++=======
+ int mlx5_ttc_fwd_dest(struct mlx5_ttc_table *ttc, enum mlx5_traffic_types type,
+ 		      struct mlx5_flow_destination *new_dest);
+ struct mlx5_flow_destination
+ mlx5_ttc_get_default_dest(struct mlx5_ttc_table *ttc,
+ 			  enum mlx5_traffic_types type);
+ int mlx5_ttc_fwd_default_dest(struct mlx5_ttc_table *ttc,
+ 			      enum mlx5_traffic_types type);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  
  void mlx5e_enable_cvlan_filter(struct mlx5e_priv *priv);
  void mlx5e_disable_cvlan_filter(struct mlx5e_priv *priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index 909faa6c89d7,68cc3a8fd6b7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@@ -401,7 -402,7 +402,11 @@@ static int fs_any_add_default_rule(stru
  	fs_any = priv->fs.any;
  	fs_any_t = &fs_any->table;
  
++<<<<<<< HEAD
 +	dest = mlx5e_ttc_get_default_dest(priv, MLX5E_TT_ANY);
++=======
+ 	dest = mlx5_ttc_get_default_dest(&priv->fs.ttc, MLX5_TT_ANY);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	rule = mlx5_add_flow_rules(fs_any_t->t, NULL, &flow_act, &dest, 1);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
@@@ -514,7 -515,7 +519,11 @@@ static int fs_any_disable(struct mlx5e_
  	int err;
  
  	/* Modify ttc rules destination to point back to the indir TIRs */
++<<<<<<< HEAD
 +	err = mlx5e_ttc_fwd_default_dest(priv, MLX5E_TT_ANY);
++=======
+ 	err = mlx5_ttc_fwd_default_dest(&priv->fs.ttc, MLX5_TT_ANY);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev,
  			   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@@ -533,7 -534,7 +542,11 @@@ static int fs_any_enable(struct mlx5e_p
  	dest.ft = priv->fs.any->table.t;
  
  	/* Modify ttc rules destination to point on the accel_fs FTs */
++<<<<<<< HEAD
 +	err = mlx5e_ttc_fwd_dest(priv, MLX5E_TT_ANY, &dest);
++=======
+ 	err = mlx5_ttc_fwd_dest(&priv->fs.ttc, MLX5_TT_ANY, &dest);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev,
  			   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index d662cf3b0a99,a03842d132f6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -1056,42 -1057,34 +1054,62 @@@ static int mlx5_generate_ttc_table_rule
  	int tt;
  	int err;
  
- 	ft = ttc->ft.t;
+ 	ft = ttc->t;
  	rules = ttc->rules;
++<<<<<<< HEAD
 +
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 +	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
 +		struct mlx5e_ttc_rule *rule = &rules[tt];
 +
 +		if (tt == MLX5E_TT_ANY)
 +			dest.tir_num = params->any_tt_tirn;
 +		else
 +			dest.tir_num = params->indir_tirn[tt];
 +
 +		rule->rule = mlx5e_generate_ttc_rule(priv, ft, &dest,
 +						     ttc_rules[tt].etype,
 +						     ttc_rules[tt].proto);
++=======
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		struct mlx5_ttc_rule *rule = &rules[tt];
+ 
+ 		rule->rule = mlx5_generate_ttc_rule(dev, ft, &params->dests[tt],
+ 						    ttc_rules[tt].etype,
+ 						    ttc_rules[tt].proto);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		if (IS_ERR(rule->rule)) {
  			err = PTR_ERR(rule->rule);
  			rule->rule = NULL;
  			goto del_rules;
  		}
- 		rule->default_dest = dest;
+ 		rule->default_dest = params->dests[tt];
  	}
  
++<<<<<<< HEAD
 +	if (!params->inner_ttc || !mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		return 0;
 +
 +	trules    = ttc->tunnel_rules;
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
 +	dest.ft   = params->inner_ttc->ft.t;
 +	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
 +		if (!mlx5e_tunnel_proto_supported_rx(priv->mdev,
 +						     ttc_tunnel_rules[tt].proto))
++=======
+ 	if (!params->inner_ttc || !mlx5_tunnel_inner_ft_supported(dev))
+ 		return 0;
+ 
+ 	trules    = ttc->tunnel_rules;
+ 	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
+ 		if (!mlx5_tunnel_proto_supported_rx(dev,
+ 						    ttc_tunnel_rules[tt].proto))
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  			continue;
- 		trules[tt] = mlx5e_generate_ttc_rule(priv, ft, &dest,
- 						     ttc_tunnel_rules[tt].etype,
- 						     ttc_tunnel_rules[tt].proto);
+ 		trules[tt] = mlx5_generate_ttc_rule(dev, ft,
+ 						    &params->tunnel_dests[tt],
+ 						    ttc_tunnel_rules[tt].etype,
+ 						    ttc_tunnel_rules[tt].proto);
  		if (IS_ERR(trules[tt])) {
  			err = PTR_ERR(trules[tt]);
  			trules[tt] = NULL;
@@@ -1116,9 -1108,8 +1133,14 @@@ static int mlx5_create_ttc_table_groups
  	int err;
  	u8 *mc;
  
++<<<<<<< HEAD
 +	ft->g = kcalloc(MLX5E_TTC_NUM_GROUPS,
 +			sizeof(*ft->g), GFP_KERNEL);
 +	if (!ft->g)
++=======
+ 	ttc->g = kcalloc(MLX5_TTC_NUM_GROUPS, sizeof(*ttc->g), GFP_KERNEL);
+ 	if (!ttc->g)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		return -ENOMEM;
  	in = kvzalloc(inlen, GFP_KERNEL);
  	if (!in) {
@@@ -1136,32 -1127,32 +1158,32 @@@
  		MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);
  	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_TTC_GROUP1_SIZE;
 +	ix += MLX5E_TTC_GROUP1_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* L3 Group */
  	MLX5_SET(fte_match_param, mc, outer_headers.ip_protocol, 0);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_TTC_GROUP2_SIZE;
 +	ix += MLX5E_TTC_GROUP2_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* Any Group */
  	memset(in, 0, inlen);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_TTC_GROUP3_SIZE;
 +	ix += MLX5E_TTC_GROUP3_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	kvfree(in);
  	return 0;
@@@ -1223,21 -1213,16 +1244,30 @@@ static int mlx5_generate_inner_ttc_tabl
  	int err;
  	int tt;
  
- 	ft = ttc->ft.t;
+ 	ft = ttc->t;
  	rules = ttc->rules;
- 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
 +		struct mlx5e_ttc_rule *rule = &rules[tt];
 +
 +		if (tt == MLX5E_TT_ANY)
 +			dest.tir_num = params->any_tt_tirn;
 +		else
 +			dest.tir_num = params->indir_tirn[tt];
 +
 +		rule->rule = mlx5e_generate_inner_ttc_rule(priv, ft, &dest,
 +							   ttc_rules[tt].etype,
 +							   ttc_rules[tt].proto);
++=======
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		struct mlx5_ttc_rule *rule = &rules[tt];
+ 
+ 		rule->rule = mlx5_generate_inner_ttc_rule(dev, ft,
+ 							  &params->dests[tt],
+ 							  ttc_rules[tt].etype,
+ 							  ttc_rules[tt].proto);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		if (IS_ERR(rule->rule)) {
  			err = PTR_ERR(rule->rule);
  			rule->rule = NULL;
@@@ -1263,8 -1247,9 +1292,14 @@@ static int mlx5_create_inner_ttc_table_
  	int err;
  	u8 *mc;
  
++<<<<<<< HEAD
 +	ft->g = kcalloc(MLX5E_INNER_TTC_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);
 +	if (!ft->g)
++=======
+ 	ttc->g = kcalloc(MLX5_INNER_TTC_NUM_GROUPS, sizeof(*ttc->g),
+ 			 GFP_KERNEL);
+ 	if (!ttc->g)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		return -ENOMEM;
  	in = kvzalloc(inlen, GFP_KERNEL);
  	if (!in) {
@@@ -1279,32 -1264,32 +1314,32 @@@
  	MLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_version);
  	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_INNER_HEADERS);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_INNER_TTC_GROUP1_SIZE;
 +	ix += MLX5E_INNER_TTC_GROUP1_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* L3 Group */
  	MLX5_SET(fte_match_param, mc, inner_headers.ip_protocol, 0);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_INNER_TTC_GROUP2_SIZE;
 +	ix += MLX5E_INNER_TTC_GROUP2_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* Any Group */
  	memset(in, 0, inlen);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_INNER_TTC_GROUP3_SIZE;
 +	ix += MLX5E_INNER_TTC_GROUP3_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	kvfree(in);
  	return 0;
@@@ -1317,42 -1302,72 +1352,80 @@@ err
  	return err;
  }
  
- void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv,
- 				struct ttc_params *ttc_params)
- {
- 	ttc_params->any_tt_tirn = mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0);
- 	ttc_params->inner_ttc = &priv->fs.inner_ttc;
- }
- 
- static void mlx5e_set_inner_ttc_ft_params(struct ttc_params *ttc_params)
+ static void mlx5e_set_inner_ttc_params(struct mlx5e_priv *priv,
+ 				       struct ttc_params *ttc_params)
  {
  	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
+ 	int tt;
  
++<<<<<<< HEAD
 +	ft_attr->max_fte = MLX5E_INNER_TTC_TABLE_SIZE;
++=======
+ 	memset(ttc_params, 0, sizeof(*ttc_params));
+ 	ttc_params->ns = mlx5_get_flow_namespace(priv->mdev,
+ 						 MLX5_FLOW_NAMESPACE_KERNEL);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	ft_attr->level = MLX5E_INNER_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_NIC_PRIO;
+ 
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		ttc_params->dests[tt].tir_num =
+ 			tt == MLX5_TT_ANY ?
+ 				mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0) :
+ 				mlx5e_rx_res_get_tirn_rss_inner(priv->rx_res,
+ 								tt);
+ 	}
  }
  
- void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params)
+ void mlx5e_set_ttc_params(struct mlx5e_priv *priv,
+ 			  struct ttc_params *ttc_params, bool tunnel)
  
  {
  	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
+ 	int tt;
  
++<<<<<<< HEAD
 +	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
++=======
+ 	memset(ttc_params, 0, sizeof(*ttc_params));
+ 	ttc_params->ns = mlx5_get_flow_namespace(priv->mdev,
+ 						 MLX5_FLOW_NAMESPACE_KERNEL);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	ft_attr->level = MLX5E_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_NIC_PRIO;
+ 
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		ttc_params->dests[tt].tir_num =
+ 			tt == MLX5_TT_ANY ?
+ 				mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0) :
+ 				mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
+ 	}
+ 
+ 	ttc_params->inner_ttc = tunnel;
+ 	if (!tunnel || !mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		return;
+ 
+ 	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
+ 		ttc_params->tunnel_dests[tt].type =
+ 			MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		ttc_params->tunnel_dests[tt].ft = priv->fs.inner_ttc.t;
+ 	}
  }
  
- static int mlx5e_create_inner_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
- 					struct mlx5e_ttc_table *ttc)
+ static int mlx5_create_inner_ttc_table(struct mlx5_core_dev *dev,
+ 				       struct ttc_params *params,
+ 				       struct mlx5_ttc_table *ttc)
  {
- 	struct mlx5e_flow_table *ft = &ttc->ft;
  	int err;
  
- 	ft->t = mlx5_create_flow_table(priv->fs.ns, &params->ft_attr);
- 	if (IS_ERR(ft->t)) {
- 		err = PTR_ERR(ft->t);
- 		ft->t = NULL;
+ 	WARN_ON_ONCE(params->ft_attr.max_fte);
+ 	params->ft_attr.max_fte = MLX5_INNER_TTC_TABLE_SIZE;
+ 	ttc->t = mlx5_create_flow_table(params->ns, &params->ft_attr);
+ 	if (IS_ERR(ttc->t)) {
+ 		err = PTR_ERR(ttc->t);
+ 		ttc->t = NULL;
  		return err;
  	}
  
@@@ -1413,16 -1439,18 +1497,27 @@@ destroy_ttc
  	return err;
  }
  
++<<<<<<< HEAD
 +int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
 +		       struct mlx5_flow_destination *new_dest)
++=======
+ int mlx5_ttc_fwd_dest(struct mlx5_ttc_table *ttc, enum mlx5_traffic_types type,
+ 		      struct mlx5_flow_destination *new_dest)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
- 	return mlx5_modify_rule_destination(priv->fs.ttc.rules[type].rule, new_dest, NULL);
+ 	return mlx5_modify_rule_destination(ttc->rules[type].rule, new_dest,
+ 					    NULL);
  }
  
  struct mlx5_flow_destination
++<<<<<<< HEAD
 +mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
++=======
+ mlx5_ttc_get_default_dest(struct mlx5_ttc_table *ttc,
+ 			  enum mlx5_traffic_types type)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
- 	struct mlx5_flow_destination *dest = &priv->fs.ttc.rules[type].default_dest;
+ 	struct mlx5_flow_destination *dest = &ttc->rules[type].default_dest;
  
  	WARN_ONCE(dest->type != MLX5_FLOW_DESTINATION_TYPE_TIR,
  		  "TTC[%d] default dest is not setup yet", type);
@@@ -1430,11 -1458,12 +1525,16 @@@
  	return *dest;
  }
  
++<<<<<<< HEAD
 +int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
++=======
+ int mlx5_ttc_fwd_default_dest(struct mlx5_ttc_table *ttc,
+ 			      enum mlx5_traffic_types type)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
- 	struct mlx5_flow_destination dest = mlx5e_ttc_get_default_dest(priv, type);
+ 	struct mlx5_flow_destination dest = mlx5_ttc_get_default_dest(ttc, type);
  
- 	return mlx5e_ttc_fwd_dest(priv, type, &dest);
+ 	return mlx5_ttc_fwd_dest(ttc, type, &dest);
  }
  
  static void mlx5e_del_l2_flow_rule(struct mlx5e_priv *priv,
@@@ -1771,17 -1810,13 +1871,25 @@@ int mlx5e_create_flow_steering(struct m
  		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
  	}
  
++<<<<<<< HEAD
 +	mlx5e_set_ttc_basic_params(priv, &ttc_params);
 +
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev)) {
 +		mlx5e_set_inner_ttc_ft_params(&ttc_params);
 +		for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +			ttc_params.indir_tirn[tt] =
 +				mlx5e_rx_res_get_tirn_rss_inner(priv->rx_res, tt);
 +
 +		err = mlx5e_create_inner_ttc_table(priv, &ttc_params, &priv->fs.inner_ttc);
++=======
+ 	if (mlx5_tunnel_inner_ft_supported(priv->mdev)) {
+ 		mlx5e_set_inner_ttc_params(priv, &ttc_params);
+ 		err = mlx5_create_inner_ttc_table(priv->mdev, &ttc_params,
+ 						  &priv->fs.inner_ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		if (err) {
- 			netdev_err(priv->netdev, "Failed to create inner ttc table, err=%d\n",
+ 			netdev_err(priv->netdev,
+ 				   "Failed to create inner ttc table, err=%d\n",
  				   err);
  			goto err_destroy_arfs_tables;
  		}
@@@ -1825,10 -1857,10 +1930,15 @@@ err_destory_vlan_table
  err_destroy_l2_table:
  	mlx5e_destroy_l2_table(priv);
  err_destroy_ttc_table:
- 	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
+ 	mlx5_destroy_ttc_table(&priv->fs.ttc);
  err_destroy_inner_ttc_table:
++<<<<<<< HEAD
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		mlx5e_destroy_inner_ttc_table(priv, &priv->fs.inner_ttc);
++=======
+ 	if (mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		mlx5_destroy_inner_ttc_table(&priv->fs.inner_ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  err_destroy_arfs_tables:
  	mlx5e_arfs_destroy_tables(priv);
  
@@@ -1840,9 -1872,9 +1950,15 @@@ void mlx5e_destroy_flow_steering(struc
  	mlx5e_ptp_free_rx_fs(priv);
  	mlx5e_destroy_vlan_table(priv);
  	mlx5e_destroy_l2_table(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		mlx5e_destroy_inner_ttc_table(priv, &priv->fs.inner_ttc);
++=======
+ 	mlx5_destroy_ttc_table(&priv->fs.ttc);
+ 	if (mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		mlx5_destroy_inner_ttc_table(&priv->fs.inner_ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	mlx5e_arfs_destroy_tables(priv);
  	mlx5e_ethtool_cleanup_steering(priv);
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index a704abee8db0,afbd0caf31ae..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -597,12 -595,16 +597,23 @@@ static void mlx5e_hairpin_set_ttc_param
  
  	memset(ttc_params, 0, sizeof(*ttc_params));
  
- 	ttc_params->any_tt_tirn = mlx5e_tir_get_tirn(&hp->direct_tir);
+ 	ttc_params->ns = mlx5_get_flow_namespace(hp->func_mdev,
+ 						 MLX5_FLOW_NAMESPACE_KERNEL);
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		ttc_params->dests[tt].tir_num =
+ 			tt == MLX5_TT_ANY ?
+ 				mlx5e_tir_get_tirn(&hp->direct_tir) :
+ 				mlx5e_tir_get_tirn(&hp->indir_tir[tt]);
+ 	}
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params->indir_tirn[tt] = mlx5e_tir_get_tirn(&hp->indir_tir[tt]);
 +
 +	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
++=======
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	ft_attr->level = MLX5E_TC_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_TC_PRIO;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
index e51f60b55daa..2380cd90eca9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
@@ -161,7 +161,7 @@ static int accel_fs_tcp_add_default_rule(struct mlx5e_priv *priv,
 	fs_tcp = priv->fs.accel_tcp;
 	accel_fs_t = &fs_tcp->tables[type];
 
-	dest = mlx5e_ttc_get_default_dest(priv, fs_accel2tt(type));
+	dest = mlx5_ttc_get_default_dest(&priv->fs.ttc, fs_accel2tt(type));
 	rule = mlx5_add_flow_rules(accel_fs_t->t, NULL, &flow_act, &dest, 1);
 	if (IS_ERR(rule)) {
 		err = PTR_ERR(rule);
@@ -307,7 +307,7 @@ static int accel_fs_tcp_disable(struct mlx5e_priv *priv)
 
 	for (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++) {
 		/* Modify ttc rules destination to point back to the indir TIRs */
-		err = mlx5e_ttc_fwd_default_dest(priv, fs_accel2tt(i));
+		err = mlx5_ttc_fwd_default_dest(&priv->fs.ttc, fs_accel2tt(i));
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@ -329,7 +329,7 @@ static int accel_fs_tcp_enable(struct mlx5e_priv *priv)
 		dest.ft = priv->fs.accel_tcp->tables[i].t;
 
 		/* Modify ttc rules destination to point on the accel_fs FTs */
-		err = mlx5e_ttc_fwd_dest(priv, fs_accel2tt(i), &dest);
+		err = mlx5_ttc_fwd_dest(&priv->fs.ttc, fs_accel2tt(i), &dest);
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 34119ce92031..28181d9d9807 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@ -265,7 +265,7 @@ static int rx_create(struct mlx5e_priv *priv, enum accel_fs_esp_type type)
 	accel_esp = priv->ipsec->rx_fs;
 	fs_prot = &accel_esp->fs_prot[type];
 
-	fs_prot->default_dest = mlx5e_ttc_get_default_dest(priv, fs_esp2tt(type));
+	fs_prot->default_dest = mlx5_ttc_get_default_dest(&priv->fs.ttc, fs_esp2tt(type));
 
 	err = rx_err_create_ft(priv, fs_prot, &fs_prot->rx_err);
 	if (err)
@@ -301,7 +301,7 @@ static int rx_ft_get(struct mlx5e_priv *priv, enum accel_fs_esp_type type)
 	/* connect */
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
 	dest.ft = fs_prot->ft;
-	mlx5e_ttc_fwd_dest(priv, fs_esp2tt(type), &dest);
+	mlx5_ttc_fwd_dest(&priv->fs.ttc, fs_esp2tt(type), &dest);
 
 out:
 	mutex_unlock(&fs_prot->prot_mutex);
@@ -320,7 +320,7 @@ static void rx_ft_put(struct mlx5e_priv *priv, enum accel_fs_esp_type type)
 		goto out;
 
 	/* disconnect */
-	mlx5e_ttc_fwd_default_dest(priv, fs_esp2tt(type));
+	mlx5_ttc_fwd_default_dest(&priv->fs.ttc, fs_esp2tt(type));
 
 	/* remove FT */
 	rx_destroy(priv, type);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 5077367f3ea0..1c3f34c1f88d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -120,7 +120,7 @@ static int arfs_disable(struct mlx5e_priv *priv)
 
 	for (i = 0; i < ARFS_NUM_TYPES; i++) {
 		/* Modify ttc rules destination back to their default */
-		err = mlx5e_ttc_fwd_default_dest(priv, arfs_get_tt(i));
+		err = mlx5_ttc_fwd_default_dest(&priv->fs.ttc, arfs_get_tt(i));
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@ -149,7 +149,7 @@ int mlx5e_arfs_enable(struct mlx5e_priv *priv)
 	for (i = 0; i < ARFS_NUM_TYPES; i++) {
 		dest.ft = priv->fs.arfs->arfs_tables[i].ft.t;
 		/* Modify ttc rules destination to point on the aRFS FTs */
-		err = mlx5e_ttc_fwd_dest(priv, arfs_get_tt(i), &dest);
+		err = mlx5_ttc_fwd_dest(&priv->fs.ttc, arfs_get_tt(i), &dest);
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] dest to arfs, failed err(%d)\n",
@@ -205,7 +205,7 @@ static int arfs_add_default_rule(struct mlx5e_priv *priv,
 		return -EINVAL;
 	}
 
-	/* FIXME: Must use mlx5e_ttc_get_default_dest(),
+	/* FIXME: Must use mlx5_ttc_get_default_dest(),
 	 * but can't since TTC default is not setup yet !
 	 */
 	dest.tir_num = mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 9d72aca74f07..78c9968de951 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -649,25 +649,20 @@ static int mlx5e_create_rep_ttc_table(struct mlx5e_priv *priv)
 {
 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 	struct mlx5_eswitch_rep *rep = rpriv->rep;
-	struct mlx5e_rx_res *res = priv->rx_res;
 	struct ttc_params ttc_params = {};
-	int tt, err;
+	int err;
 
 	priv->fs.ns = mlx5_get_flow_namespace(priv->mdev,
 					      MLX5_FLOW_NAMESPACE_KERNEL);
 
 	/* The inner_ttc in the ttc params is intentionally not set */
-	ttc_params.any_tt_tirn = mlx5e_rx_res_get_tirn_direct(res, 0);
-	mlx5e_set_ttc_ft_params(&ttc_params);
+	mlx5e_set_ttc_params(priv, &ttc_params, false);
 
 	if (rep->vport != MLX5_VPORT_UPLINK)
 		/* To give uplik rep TTC a lower level for chaining from root ft */
 		ttc_params.ft_attr.level = MLX5E_TTC_FT_LEVEL + 1;
 
-	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
-		ttc_params.indir_tirn[tt] = mlx5e_rx_res_get_tirn_rss(res, tt);
-
-	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
+	err = mlx5_create_ttc_table(priv->mdev, &ttc_params, &priv->fs.ttc);
 	if (err) {
 		netdev_err(priv->netdev, "Failed to create rep ttc table, err=%d\n", err);
 		return err;
@@ -687,7 +682,7 @@ static int mlx5e_create_rep_root_ft(struct mlx5e_priv *priv)
 		/* non uplik reps will skip any bypass tables and go directly to
 		 * their own ttc
 		 */
-		rpriv->root_ft = priv->fs.ttc.ft.t;
+		rpriv->root_ft = priv->fs.ttc.t;
 		return 0;
 	}
 
@@ -802,7 +797,7 @@ static int mlx5e_init_rep_rx(struct mlx5e_priv *priv)
 err_destroy_root_ft:
 	mlx5e_destroy_rep_root_ft(priv);
 err_destroy_ttc_table:
-	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
+	mlx5_destroy_ttc_table(&priv->fs.ttc);
 err_destroy_rx_res:
 	mlx5e_rx_res_destroy(priv->rx_res);
 err_close_drop_rq:
@@ -817,7 +812,7 @@ static void mlx5e_cleanup_rep_rx(struct mlx5e_priv *priv)
 	mlx5e_ethtool_cleanup_steering(priv);
 	rep_vport_rx_rule_destroy(priv);
 	mlx5e_destroy_rep_root_ft(priv);
-	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
+	mlx5_destroy_ttc_table(&priv->fs.ttc);
 	mlx5e_rx_res_destroy(priv->rx_res);
 	mlx5e_close_drop_rq(&priv->drop_rq);
 	mlx5e_rx_res_free(priv->rx_res);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index 4760c3006f15..e900f78bd0fe 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@ -321,7 +321,7 @@ static void mlx5i_cleanup_tx(struct mlx5e_priv *priv)
 static int mlx5i_create_flow_steering(struct mlx5e_priv *priv)
 {
 	struct ttc_params ttc_params = {};
-	int tt, err;
+	int err;
 
 	priv->fs.ns = mlx5_get_flow_namespace(priv->mdev,
 					       MLX5_FLOW_NAMESPACE_KERNEL);
@@ -336,12 +336,8 @@ static int mlx5i_create_flow_steering(struct mlx5e_priv *priv)
 		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
 	}
 
-	mlx5e_set_ttc_basic_params(priv, &ttc_params);
-	mlx5e_set_ttc_ft_params(&ttc_params);
-	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
-		ttc_params.indir_tirn[tt] = mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
-
-	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
+	mlx5e_set_ttc_params(priv, &ttc_params, true);
+	err = mlx5_create_ttc_table(priv->mdev, &ttc_params, &priv->fs.ttc);
 	if (err) {
 		netdev_err(priv->netdev, "Failed to create ttc table, err=%d\n",
 			   err);
@@ -358,7 +354,7 @@ static int mlx5i_create_flow_steering(struct mlx5e_priv *priv)
 
 static void mlx5i_destroy_flow_steering(struct mlx5e_priv *priv)
 {
-	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
+	mlx5_destroy_ttc_table(&priv->fs.ttc);
 	mlx5e_arfs_destroy_tables(priv);
 }
 
