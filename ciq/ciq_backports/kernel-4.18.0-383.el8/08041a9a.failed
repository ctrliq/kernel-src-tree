net: phy: marvell10g: enable WoL for 88X3310 and 88E2110

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Voon Weifeng <weifeng.voon@intel.com>
commit 08041a9af98cf10a1e466206dfe8229b20afd575
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/08041a9a.failed

Implement Wake-on-LAN feature for 88X3310 and 88E2110.

This is done by enabling WoL interrupt and WoL detection and
configuring MAC address into WoL magic packet registers

	Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
	Signed-off-by: Ling Pei Lee <pei.lee.ling@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 08041a9af98cf10a1e466206dfe8229b20afd575)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/marvell10g.c
diff --cc drivers/net/phy/marvell10g.c
index 86c511e1ea61,0b7cae118ad7..000000000000
--- a/drivers/net/phy/marvell10g.c
+++ b/drivers/net/phy/marvell10g.c
@@@ -863,6 -972,139 +874,142 @@@ static const struct mv3310_chip mv2110_
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ static const struct mv3310_chip mv2111_type = {
+ 	.init_supported_interfaces = mv2111_init_supported_interfaces,
+ 	.get_mactype = mv2110_get_mactype,
+ 	.init_interface = mv2110_init_interface,
+ 
+ #ifdef CONFIG_HWMON
+ 	.hwmon_read_temp_reg = mv2110_hwmon_read_temp_reg,
+ #endif
+ };
+ 
+ static int mv3310_get_number_of_ports(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_PORT_INFO);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret &= MV_PCS_PORT_INFO_NPORTS_MASK;
+ 	ret >>= MV_PCS_PORT_INFO_NPORTS_SHIFT;
+ 
+ 	return ret + 1;
+ }
+ 
+ static int mv3310_match_phy_device(struct phy_device *phydev)
+ {
+ 	return mv3310_get_number_of_ports(phydev) == 1;
+ }
+ 
+ static int mv3340_match_phy_device(struct phy_device *phydev)
+ {
+ 	return mv3310_get_number_of_ports(phydev) == 4;
+ }
+ 
+ static int mv211x_match_phy_device(struct phy_device *phydev, bool has_5g)
+ {
+ 	int val;
+ 
+ 	if ((phydev->c45_ids.device_ids[MDIO_MMD_PMAPMD] &
+ 	     MARVELL_PHY_ID_MASK) != MARVELL_PHY_ID_88E2110)
+ 		return 0;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_SPEED);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	return !!(val & MDIO_PCS_SPEED_5G) == has_5g;
+ }
+ 
+ static int mv2110_match_phy_device(struct phy_device *phydev)
+ {
+ 	return mv211x_match_phy_device(phydev, true);
+ }
+ 
+ static int mv2111_match_phy_device(struct phy_device *phydev)
+ {
+ 	return mv211x_match_phy_device(phydev, false);
+ }
+ 
+ static void mv3110_get_wol(struct phy_device *phydev,
+ 			   struct ethtool_wolinfo *wol)
+ {
+ 	int ret;
+ 
+ 	wol->supported = WAKE_MAGIC;
+ 	wol->wolopts = 0;
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_V2_WOL_CTRL);
+ 	if (ret < 0)
+ 		return;
+ 
+ 	if (ret & MV_V2_WOL_CTRL_MAGIC_PKT_EN)
+ 		wol->wolopts |= WAKE_MAGIC;
+ }
+ 
+ static int mv3110_set_wol(struct phy_device *phydev,
+ 			  struct ethtool_wolinfo *wol)
+ {
+ 	int ret;
+ 
+ 	if (wol->wolopts & WAKE_MAGIC) {
+ 		/* Enable the WOL interrupt */
+ 		ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,
+ 				       MV_V2_PORT_INTR_MASK,
+ 				       MV_V2_PORT_INTR_STS_WOL_EN);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		/* Store the device address for the magic packet */
+ 		ret = phy_write_mmd(phydev, MDIO_MMD_VEND2,
+ 				    MV_V2_MAGIC_PKT_WORD2,
+ 				    ((phydev->attached_dev->dev_addr[5] << 8) |
+ 				    phydev->attached_dev->dev_addr[4]));
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		ret = phy_write_mmd(phydev, MDIO_MMD_VEND2,
+ 				    MV_V2_MAGIC_PKT_WORD1,
+ 				    ((phydev->attached_dev->dev_addr[3] << 8) |
+ 				    phydev->attached_dev->dev_addr[2]));
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		ret = phy_write_mmd(phydev, MDIO_MMD_VEND2,
+ 				    MV_V2_MAGIC_PKT_WORD0,
+ 				    ((phydev->attached_dev->dev_addr[1] << 8) |
+ 				    phydev->attached_dev->dev_addr[0]));
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		/* Clear WOL status and enable magic packet matching */
+ 		ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,
+ 				       MV_V2_WOL_CTRL,
+ 				       MV_V2_WOL_CTRL_MAGIC_PKT_EN |
+ 				       MV_V2_WOL_CTRL_CLEAR_STS);
+ 		if (ret < 0)
+ 			return ret;
+ 	} else {
+ 		/* Disable magic packet matching & reset WOL status bit */
+ 		ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2,
+ 				     MV_V2_WOL_CTRL,
+ 				     MV_V2_WOL_CTRL_MAGIC_PKT_EN,
+ 				     MV_V2_WOL_CTRL_CLEAR_STS);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	/* Reset the clear WOL status bit as it does not self-clear */
+ 	return phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2,
+ 				  MV_V2_WOL_CTRL,
+ 				  MV_V2_WOL_CTRL_CLEAR_STS);
+ }
+ 
++>>>>>>> 08041a9af98c (net: phy: marvell10g: enable WoL for 88X3310 and 88E2110)
  static struct phy_driver mv3310_drivers[] = {
  	{
  		.phy_id		= MARVELL_PHY_ID_88X3310,
@@@ -881,7 -1124,28 +1028,9 @@@
  		.set_tunable	= mv3310_set_tunable,
  		.remove		= mv3310_remove,
  		.set_loopback	= genphy_c45_loopback,
+ 		.get_wol	= mv3110_get_wol,
+ 		.set_wol	= mv3110_set_wol,
  	},
 -	{
 -		.phy_id		= MARVELL_PHY_ID_88X3310,
 -		.phy_id_mask	= MARVELL_PHY_ID_MASK,
 -		.match_phy_device = mv3340_match_phy_device,
 -		.name		= "mv88x3340",
 -		.driver_data	= &mv3340_type,
 -		.get_features	= mv3310_get_features,
 -		.config_init	= mv3310_config_init,
 -		.probe		= mv3310_probe,
 -		.suspend	= mv3310_suspend,
 -		.resume		= mv3310_resume,
 -		.config_aneg	= mv3310_config_aneg,
 -		.aneg_done	= mv3310_aneg_done,
 -		.read_status	= mv3310_read_status,
 -		.get_tunable	= mv3310_get_tunable,
 -		.set_tunable	= mv3310_set_tunable,
 -		.remove		= mv3310_remove,
 -		.set_loopback	= genphy_c45_loopback,
 -	},
  	{
  		.phy_id		= MARVELL_PHY_ID_88E2110,
  		.phy_id_mask	= MARVELL_PHY_ID_MASK,
@@@ -898,7 -1163,27 +1047,9 @@@
  		.set_tunable	= mv3310_set_tunable,
  		.remove		= mv3310_remove,
  		.set_loopback	= genphy_c45_loopback,
+ 		.get_wol	= mv3110_get_wol,
+ 		.set_wol	= mv3110_set_wol,
  	},
 -	{
 -		.phy_id		= MARVELL_PHY_ID_88E2110,
 -		.phy_id_mask	= MARVELL_PHY_ID_MASK,
 -		.match_phy_device = mv2111_match_phy_device,
 -		.name		= "mv88e2111",
 -		.driver_data	= &mv2111_type,
 -		.probe		= mv3310_probe,
 -		.suspend	= mv3310_suspend,
 -		.resume		= mv3310_resume,
 -		.config_init	= mv3310_config_init,
 -		.config_aneg	= mv3310_config_aneg,
 -		.aneg_done	= mv3310_aneg_done,
 -		.read_status	= mv3310_read_status,
 -		.get_tunable	= mv3310_get_tunable,
 -		.set_tunable	= mv3310_set_tunable,
 -		.remove		= mv3310_remove,
 -		.set_loopback	= genphy_c45_loopback,
 -	},
  };
  
  module_phy_driver(mv3310_drivers);
* Unmerged path drivers/net/phy/marvell10g.c
