drm/amdgpu/gfx9: switch to golden tsc registers for renoir+

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Alex Deucher <alexander.deucher@amd.com>
commit 7b37c7f8f505abc55da54a5a9d22135d77ff73bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/7b37c7f8.failed

Renoir and newer gfx9 APUs have new TSC register that is
not part of the gfxoff tile, so it can be read without
needing to disable gfx off.

	Acked-by: Luben Tuikov <luben.tuikov@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 7b37c7f8f505abc55da54a5a9d22135d77ff73bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
diff --cc drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
index 88ed0ef88f7e,34478bcc4d09..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
@@@ -4227,19 -4243,38 +4232,49 @@@ failed_kiq_read
  
  static uint64_t gfx_v9_0_get_gpu_clock_counter(struct amdgpu_device *adev)
  {
- 	uint64_t clock;
+ 	uint64_t clock, clock_lo, clock_hi, hi_check;
  
++<<<<<<< HEAD
 +	amdgpu_gfx_off_ctrl(adev, false);
 +	mutex_lock(&adev->gfx.gpu_clock_mutex);
 +	if (adev->asic_type == CHIP_VEGA10 && amdgpu_sriov_runtime(adev)) {
 +		clock = gfx_v9_0_kiq_read_clock(adev);
 +	} else {
 +		WREG32_SOC15(GC, 0, mmRLC_CAPTURE_GPU_CLOCK_COUNT, 1);
 +		clock = (uint64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_LSB) |
 +			((uint64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_MSB) << 32ULL);
++=======
+ 	switch (adev->ip_versions[GC_HWIP][0]) {
+ 	case IP_VERSION(9, 3, 0):
+ 		preempt_disable();
+ 		clock_hi = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_UPPER_Renoir);
+ 		clock_lo = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_LOWER_Renoir);
+ 		hi_check = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_UPPER_Renoir);
+ 		/* The SMUIO TSC clock frequency is 100MHz, which sets 32-bit carry over
+ 		 * roughly every 42 seconds.
+ 		 */
+ 		if (hi_check != clock_hi) {
+ 			clock_lo = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_LOWER_Renoir);
+ 			clock_hi = hi_check;
+ 		}
+ 		preempt_enable();
+ 		clock = clock_lo | (clock_hi << 32ULL);
+ 		break;
+ 	default:
+ 		amdgpu_gfx_off_ctrl(adev, false);
+ 		mutex_lock(&adev->gfx.gpu_clock_mutex);
+ 		if (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 0, 1) && amdgpu_sriov_runtime(adev)) {
+ 			clock = gfx_v9_0_kiq_read_clock(adev);
+ 		} else {
+ 			WREG32_SOC15(GC, 0, mmRLC_CAPTURE_GPU_CLOCK_COUNT, 1);
+ 			clock = (uint64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_LSB) |
+ 				((uint64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_MSB) << 32ULL);
+ 		}
+ 		mutex_unlock(&adev->gfx.gpu_clock_mutex);
+ 		amdgpu_gfx_off_ctrl(adev, true);
+ 		break;
++>>>>>>> 7b37c7f8f505 (drm/amdgpu/gfx9: switch to golden tsc registers for renoir+)
  	}
- 	mutex_unlock(&adev->gfx.gpu_clock_mutex);
- 	amdgpu_gfx_off_ctrl(adev, true);
  	return clock;
  }
  
* Unmerged path drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
