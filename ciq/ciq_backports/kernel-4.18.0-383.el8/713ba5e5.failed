net/mlx5e: Introduce abstraction of RSS context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit 713ba5e5f6896cbdde7ddb339cd8b06eb7c7334a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/713ba5e5.failed

Bring all fields that define and maintain RSS behavior together
into a new structure.
Align all usages with this new structure. Keep it hidden within
rx_res.c.
This helps supporting multiple RSS contexts in downstream patch.

Use dynamic allocations for the RSS context.

	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 713ba5e5f6896cbdde7ddb339cd8b06eb7c7334a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
index 80d9748a46f1,336930cfd632..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
@@@ -106,24 -104,67 +104,80 @@@ struct mlx5e_rx_res *mlx5e_rx_res_alloc
  
  static void mlx5e_rx_res_rss_params_init(struct mlx5e_rx_res *res, unsigned int init_nch)
  {
++<<<<<<< HEAD
 +	enum mlx5e_traffic_types tt;
- 
- 	res->rss_params.hash.hfunc = ETH_RSS_HASH_TOP;
- 	netdev_rss_key_fill(res->rss_params.hash.toeplitz_hash_key,
- 			    sizeof(res->rss_params.hash.toeplitz_hash_key));
- 	mlx5e_rss_params_indir_init_uniform(&res->rss_params.indir, init_nch);
++=======
+ 	struct mlx5e_rss *rss = res->rss;
+ 	enum mlx5_traffic_types tt;
++>>>>>>> 713ba5e5f689 (net/mlx5e: Introduce abstraction of RSS context)
+ 
+ 	rss->hash.hfunc = ETH_RSS_HASH_TOP;
+ 	netdev_rss_key_fill(rss->hash.toeplitz_hash_key,
+ 			    sizeof(rss->hash.toeplitz_hash_key));
+ 	mlx5e_rss_params_indir_init_uniform(&rss->indir, init_nch);
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
- 		res->rss_params.rx_hash_fields[tt] =
+ 		rss->rx_hash_fields[tt] =
  			mlx5e_rss_get_default_tt_config(tt).rx_hash_fields;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_rx_res_rss_init(struct mlx5e_rx_res *res,
 +				 const struct mlx5e_lro_param *init_lro_param)
 +{
 +	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
 +	enum mlx5e_traffic_types tt, max_tt;
++=======
+ static void mlx5e_rx_res_rss_destroy_tir(struct mlx5e_rx_res *res,
+ 					 enum mlx5_traffic_types tt,
+ 					 bool inner)
+ {
+ 	struct mlx5e_rss *rss = res->rss;
+ 	struct mlx5e_tir *tir;
+ 
+ 	tir = inner ? &rss->inner_tir[tt] : &rss->tir[tt];
+ 	mlx5e_tir_destroy(tir);
+ }
+ 
+ static int mlx5e_rx_res_rss_create_tir(struct mlx5e_rx_res *res,
+ 				       struct mlx5e_tir_builder *builder,
+ 				       enum mlx5_traffic_types tt,
+ 				       const struct mlx5e_lro_param *init_lro_param,
+ 				       bool inner)
+ {
+ 	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
+ 	struct mlx5e_rss_params_traffic_type rss_tt;
+ 	struct mlx5e_rss *rss = res->rss;
+ 	struct mlx5e_tir *tir;
+ 	u32 rqtn;
+ 	int err;
+ 
+ 	tir = inner ? &rss->inner_tir[tt] : &rss->tir[tt];
+ 
+ 	rqtn = mlx5e_rqt_get_rqtn(&rss->rqt);
+ 	mlx5e_tir_builder_build_rqt(builder, res->mdev->mlx5e_res.hw_objs.td.tdn,
+ 				    rqtn, inner_ft_support);
+ 	mlx5e_tir_builder_build_lro(builder, init_lro_param);
+ 	rss_tt = mlx5e_rx_res_rss_get_current_tt_config(res, tt);
+ 	mlx5e_tir_builder_build_rss(builder, &rss->hash, &rss_tt, inner);
+ 
+ 	err = mlx5e_tir_init(tir, builder, res->mdev, true);
+ 	if (err) {
+ 		mlx5_core_warn(res->mdev, "Failed to create %sindirect TIR: err = %d, tt = %d\n",
+ 			       inner ? "inner " : "", err, tt);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_rx_res_rss_create_tirs(struct mlx5e_rx_res *res,
+ 					const struct mlx5e_lro_param *init_lro_param,
+ 					bool inner)
+ {
+ 	enum mlx5_traffic_types tt, max_tt;
++>>>>>>> 713ba5e5f689 (net/mlx5e: Introduce abstraction of RSS context)
  	struct mlx5e_tir_builder *builder;
 +	u32 indir_rqtn;
  	int err;
  
  	builder = mlx5e_tir_builder_alloc(false);
@@@ -188,13 -186,59 +242,65 @@@ err_destroy_inner_tirs
  err_destroy_tirs:
  	max_tt = tt;
  	for (tt = 0; tt < max_tt; tt++)
 -		mlx5e_rx_res_rss_destroy_tir(res, tt, inner);
 -	goto out;
 -}
 +		mlx5e_tir_destroy(&res->rss[tt].indir_tir);
 +
++<<<<<<< HEAD
 +	mlx5e_rqt_destroy(&res->indir_rqt);
  
 +out:
 +	mlx5e_tir_builder_free(builder);
 +
++=======
+ static void mlx5e_rx_res_rss_destroy_tirs(struct mlx5e_rx_res *res, bool inner)
+ {
+ 	enum mlx5_traffic_types tt;
+ 
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
+ 		mlx5e_rx_res_rss_destroy_tir(res, tt, inner);
+ }
+ 
+ static int mlx5e_rx_res_rss_init(struct mlx5e_rx_res *res,
+ 				 const struct mlx5e_lro_param *init_lro_param,
+ 				 unsigned int init_nch)
+ {
+ 	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
+ 	struct mlx5e_rss *rss;
+ 	int err;
+ 
+ 	rss = kvzalloc(sizeof(*rss), GFP_KERNEL);
+ 	if (!rss)
+ 		return -ENOMEM;
+ 
+ 	res->rss = rss;
+ 
+ 	mlx5e_rx_res_rss_params_init(res, init_nch);
+ 
+ 	err = mlx5e_rqt_init_direct(&rss->rqt, res->mdev, true, res->drop_rqn);
+ 	if (err)
+ 		goto err_free_rss;
+ 
+ 	err = mlx5e_rx_res_rss_create_tirs(res, init_lro_param, false);
+ 	if (err)
+ 		goto err_destroy_rqt;
+ 
+ 	if (inner_ft_support) {
+ 		err = mlx5e_rx_res_rss_create_tirs(res, init_lro_param, true);
+ 		if (err)
+ 			goto err_destroy_tirs;
+ 	}
+ 
+ 	return 0;
+ 
+ err_destroy_tirs:
+ 	mlx5e_rx_res_rss_destroy_tirs(res, false);
+ 
+ err_destroy_rqt:
+ 	mlx5e_rqt_destroy(&rss->rqt);
+ 
+ err_free_rss:
+ 	kvfree(rss);
+ 	res->rss = NULL;
++>>>>>>> 713ba5e5f689 (net/mlx5e: Introduce abstraction of RSS context)
  	return err;
  }
  
@@@ -337,16 -381,16 +443,24 @@@ out
  
  static void mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res)
  {
++<<<<<<< HEAD
 +	enum mlx5e_traffic_types tt;
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		mlx5e_tir_destroy(&res->rss[tt].indir_tir);
++=======
+ 	struct mlx5e_rss *rss = res->rss;
+ 
+ 	mlx5e_rx_res_rss_destroy_tirs(res, false);
++>>>>>>> 713ba5e5f689 (net/mlx5e: Introduce abstraction of RSS context)
  
  	if (res->features & MLX5E_RX_RES_FEATURE_INNER_FT)
 -		mlx5e_rx_res_rss_destroy_tirs(res, true);
 +		for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +			mlx5e_tir_destroy(&res->rss[tt].inner_indir_tir);
  
- 	mlx5e_rqt_destroy(&res->indir_rqt);
+ 	mlx5e_rqt_destroy(&rss->rqt);
+ 	kvfree(rss);
+ 	res->rss = NULL;
  }
  
  static void mlx5e_rx_res_channels_destroy(struct mlx5e_rx_res *res)
@@@ -432,15 -474,19 +544,19 @@@ u32 mlx5e_rx_res_get_tirn_xsk(struct ml
  	return mlx5e_tir_get_tirn(&res->channels[ix].xsk_tir);
  }
  
 -u32 mlx5e_rx_res_get_tirn_rss(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
 +u32 mlx5e_rx_res_get_tirn_rss(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
  {
- 	return mlx5e_tir_get_tirn(&res->rss[tt].indir_tir);
+ 	struct mlx5e_rss *rss = res->rss;
+ 
+ 	return mlx5e_tir_get_tirn(&rss->tir[tt]);
  }
  
 -u32 mlx5e_rx_res_get_tirn_rss_inner(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
 +u32 mlx5e_rx_res_get_tirn_rss_inner(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
  {
+ 	struct mlx5e_rss *rss = res->rss;
+ 
  	WARN_ON(!(res->features & MLX5E_RX_RES_FEATURE_INNER_FT));
- 	return mlx5e_tir_get_tirn(&res->rss[tt].inner_indir_tir);
+ 	return mlx5e_tir_get_tirn(&rss->inner_tir[tt]);
  }
  
  u32 mlx5e_rx_res_get_tirn_ptp(struct mlx5e_rx_res *res)
@@@ -608,12 -656,13 +726,13 @@@ int mlx5e_rx_res_xsk_deactivate(struct 
  }
  
  struct mlx5e_rss_params_traffic_type
 -mlx5e_rx_res_rss_get_current_tt_config(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
 +mlx5e_rx_res_rss_get_current_tt_config(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
  {
  	struct mlx5e_rss_params_traffic_type rss_tt;
+ 	struct mlx5e_rss *rss = res->rss;
  
  	rss_tt = mlx5e_rss_get_default_tt_config(tt);
- 	rss_tt.rx_hash_fields = res->rss_params.rx_hash_fields[tt];
+ 	rss_tt.rx_hash_fields = rss->rx_hash_fields[tt];
  	return rss_tt;
  }
  
@@@ -630,17 -680,19 +750,19 @@@ int mlx5e_rx_res_rss_get_rxfh(struct ml
  
  	if (indir)
  		for (i = 0; i < MLX5E_INDIR_RQT_SIZE; i++)
- 			indir[i] = res->rss_params.indir.table[i];
+ 			indir[i] = rss->indir.table[i];
  
  	if (key)
- 		memcpy(key, res->rss_params.hash.toeplitz_hash_key,
- 		       sizeof(res->rss_params.hash.toeplitz_hash_key));
+ 		memcpy(key, rss->hash.toeplitz_hash_key,
+ 		       sizeof(rss->hash.toeplitz_hash_key));
  
  	if (hfunc)
- 		*hfunc = res->rss_params.hash.hfunc;
+ 		*hfunc = rss->hash.hfunc;
+ 
+ 	return 0;
  }
  
 -static int mlx5e_rx_res_rss_update_tir(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt,
 +static int mlx5e_rx_res_rss_update_tir(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt,
  				       bool inner)
  {
  	struct mlx5e_rss_params_traffic_type rss_tt;
@@@ -665,7 -718,8 +788,12 @@@
  int mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, const u32 *indir,
  			      const u8 *key, const u8 *hfunc)
  {
++<<<<<<< HEAD
 +	enum mlx5e_traffic_types tt;
++=======
+ 	struct mlx5e_rss *rss = res->rss;
+ 	enum mlx5_traffic_types tt;
++>>>>>>> 713ba5e5f689 (net/mlx5e: Introduce abstraction of RSS context)
  	bool changed_indir = false;
  	bool changed_hash = false;
  	int err;
@@@ -727,14 -780,17 +854,17 @@@
  	return 0;
  }
  
 -u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
 +u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
  {
- 	return res->rss_params.rx_hash_fields[tt];
+ 	struct mlx5e_rss *rss = res->rss;
+ 
+ 	return rss->rx_hash_fields[tt];
  }
  
 -int mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt,
 +int mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt,
  				     u8 rx_hash_fields)
  {
+ 	struct mlx5e_rss *rss = res->rss;
  	u8 old_rx_hash_fields;
  	int err;
  
@@@ -774,8 -831,9 +905,9 @@@
  
  int mlx5e_rx_res_lro_set_param(struct mlx5e_rx_res *res, struct mlx5e_lro_param *lro_param)
  {
+ 	struct mlx5e_rss *rss = res->rss;
  	struct mlx5e_tir_builder *builder;
 -	enum mlx5_traffic_types tt;
 +	enum mlx5e_traffic_types tt;
  	int err, final_err;
  	unsigned int ix;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
index 934e41a0761f..c3214a41f41b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
@@ -53,7 +53,7 @@ int mlx5e_rx_res_xsk_deactivate(struct mlx5e_rx_res *res, unsigned int ix);
 struct mlx5e_rss_params_traffic_type
 mlx5e_rx_res_rss_get_current_tt_config(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt);
 void mlx5e_rx_res_rss_set_indir_uniform(struct mlx5e_rx_res *res, unsigned int nch);
-void mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 *indir, u8 *key, u8 *hfunc);
+int mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 *indir, u8 *key, u8 *hfunc);
 int mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, const u32 *indir,
 			      const u8 *key, const u8 *hfunc);
 u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 3a54bd65c2b7..d30e946a9c4e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@ -1202,12 +1202,12 @@ int mlx5e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
 		   u8 *hfunc)
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
+	int err;
 
 	mutex_lock(&priv->state_lock);
-	mlx5e_rx_res_rss_get_rxfh(priv->rx_res, indir, key, hfunc);
+	err = mlx5e_rx_res_rss_get_rxfh(priv->rx_res, indir, key, hfunc);
 	mutex_unlock(&priv->state_lock);
-
-	return 0;
+	return err;
 }
 
 int mlx5e_set_rxfh(struct net_device *dev, const u32 *indir,
