net/mlx5e: Support multiple RSS contexts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-383.el8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit f01cc58c18d6457bd88b2c77c916a9e072f2b633
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-383.el8/f01cc58c.failed

Add support to multiple RSS contexts. Resources of the non-default
RSS contexts are allocated and created on demand. Each RSS context
can be controlled and configured separately, via the implemented
ethtool ops. Here we limit the num of total contexts to 16.

We do not enforce any kind of new limitation over the indirection table
content. More specifically, two separate contexts can be configured to
fully or partially point to the same set of receive rings.

The default RSS context (index 0) is created with its full set of TIRs.
All other contexts are created with an empty set, then TIRs are added
upon first usage when steering rules are added.
We use a reference counting mechanism to make sure an RSS context is
not removed before the rules pointing to it.

Block ethtool set_channels operations when multiple RSS contexts exist,
as currently the kernel doesn't protect against inconsistent channels
configs that break non-default RSS contexts.

	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit f01cc58c18d6457bd88b2c77c916a9e072f2b633)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
index 80d9748a46f1,432963594b8e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
@@@ -5,64 -5,7 +5,68 @@@
  #include "channels.h"
  #include "params.h"
  
++<<<<<<< HEAD
 +static const struct mlx5e_rss_params_traffic_type rss_default_config[MLX5E_NUM_INDIR_TIRS] = {
 +	[MLX5E_TT_IPV4_TCP] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +		.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
 +		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV6_TCP] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +		.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
 +		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV4_UDP] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +		.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
 +		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV6_UDP] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +		.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
 +		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_AH] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +		.l4_prot_type = 0,
 +		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_AH] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +		.l4_prot_type = 0,
 +		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_ESP] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +		.l4_prot_type = 0,
 +		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_ESP] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +		.l4_prot_type = 0,
 +		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV4] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +		.l4_prot_type = 0,
 +		.rx_hash_fields = MLX5_HASH_IP,
 +	},
 +	[MLX5E_TT_IPV6] = {
 +		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +		.l4_prot_type = 0,
 +		.rx_hash_fields = MLX5_HASH_IP,
 +	},
 +};
 +
 +struct mlx5e_rss_params_traffic_type
 +mlx5e_rss_get_default_tt_config(enum mlx5e_traffic_types tt)
 +{
 +	return rss_default_config[tt];
 +}
++=======
+ #define MLX5E_MAX_NUM_RSS 16
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  
  struct mlx5e_rx_res {
  	struct mlx5_core_dev *mdev;
@@@ -70,18 -13,7 +74,22 @@@
  	unsigned int max_nch;
  	u32 drop_rqn;
  
++<<<<<<< HEAD
 +	struct {
 +		struct mlx5e_rss_params_hash hash;
 +		struct mlx5e_rss_params_indir indir;
 +		u32 rx_hash_fields[MLX5E_NUM_INDIR_TIRS];
 +	} rss_params;
 +
 +	struct mlx5e_rqt indir_rqt;
 +	struct {
 +		struct mlx5e_tir indir_tir;
 +		struct mlx5e_tir inner_indir_tir;
 +	} rss[MLX5E_NUM_INDIR_TIRS];
 +
++=======
+ 	struct mlx5e_rss *rss[MLX5E_MAX_NUM_RSS];
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	bool rss_active;
  	u32 rss_rqns[MLX5E_INDIR_RQT_SIZE];
  	unsigned int rss_nch;
@@@ -99,6 -31,222 +107,225 @@@
  	} ptp;
  };
  
++<<<<<<< HEAD
++=======
+ /* API for rx_res_rss_* */
+ 
+ static int mlx5e_rx_res_rss_init_def(struct mlx5e_rx_res *res,
+ 				     const struct mlx5e_lro_param *init_lro_param,
+ 				     unsigned int init_nch)
+ {
+ 	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
+ 	struct mlx5e_rss *rss;
+ 	int err;
+ 
+ 	if (WARN_ON(res->rss[0]))
+ 		return -EINVAL;
+ 
+ 	rss = mlx5e_rss_alloc();
+ 	if (!rss)
+ 		return -ENOMEM;
+ 
+ 	err = mlx5e_rss_init(rss, res->mdev, inner_ft_support, res->drop_rqn,
+ 			     init_lro_param);
+ 	if (err)
+ 		goto err_rss_free;
+ 
+ 	mlx5e_rss_set_indir_uniform(rss, init_nch);
+ 
+ 	res->rss[0] = rss;
+ 
+ 	return 0;
+ 
+ err_rss_free:
+ 	mlx5e_rss_free(rss);
+ 	return err;
+ }
+ 
+ int mlx5e_rx_res_rss_init(struct mlx5e_rx_res *res, u32 *rss_idx, unsigned int init_nch)
+ {
+ 	bool inner_ft_support = res->features & MLX5E_RX_RES_FEATURE_INNER_FT;
+ 	struct mlx5e_rss *rss;
+ 	int err, i;
+ 
+ 	for (i = 1; i < MLX5E_MAX_NUM_RSS; i++)
+ 		if (!res->rss[i])
+ 			break;
+ 
+ 	if (i == MLX5E_MAX_NUM_RSS)
+ 		return -ENOSPC;
+ 
+ 	rss = mlx5e_rss_alloc();
+ 	if (!rss)
+ 		return -ENOMEM;
+ 
+ 	err = mlx5e_rss_init_no_tirs(rss, res->mdev, inner_ft_support, res->drop_rqn);
+ 	if (err)
+ 		goto err_rss_free;
+ 
+ 	mlx5e_rss_set_indir_uniform(rss, init_nch);
+ 	if (res->rss_active)
+ 		mlx5e_rss_enable(rss, res->rss_rqns, res->rss_nch);
+ 
+ 	res->rss[i] = rss;
+ 	*rss_idx = i;
+ 
+ 	return 0;
+ 
+ err_rss_free:
+ 	mlx5e_rss_free(rss);
+ 	return err;
+ }
+ 
+ static int __mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx)
+ {
+ 	struct mlx5e_rss *rss = res->rss[rss_idx];
+ 	int err;
+ 
+ 	err = mlx5e_rss_cleanup(rss);
+ 	if (err)
+ 		return err;
+ 
+ 	mlx5e_rss_free(rss);
+ 	res->rss[rss_idx] = NULL;
+ 
+ 	return 0;
+ }
+ 
+ int mlx5e_rx_res_rss_destroy(struct mlx5e_rx_res *res, u32 rss_idx)
+ {
+ 	struct mlx5e_rss *rss;
+ 
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return -EINVAL;
+ 
+ 	rss = res->rss[rss_idx];
+ 	if (!rss)
+ 		return -EINVAL;
+ 
+ 	return __mlx5e_rx_res_rss_destroy(res, rss_idx);
+ }
+ 
+ static void mlx5e_rx_res_rss_destroy_all(struct mlx5e_rx_res *res)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {
+ 		struct mlx5e_rss *rss = res->rss[i];
+ 		int err;
+ 
+ 		if (!rss)
+ 			continue;
+ 
+ 		err = __mlx5e_rx_res_rss_destroy(res, i);
+ 		if (err) {
+ 			unsigned int refcount;
+ 
+ 			refcount = mlx5e_rss_refcnt_read(rss);
+ 			mlx5_core_warn(res->mdev,
+ 				       "Failed to destroy RSS context %d, refcount = %u, err = %d\n",
+ 				       i, refcount, err);
+ 		}
+ 	}
+ }
+ 
+ static void mlx5e_rx_res_rss_enable(struct mlx5e_rx_res *res)
+ {
+ 	int i;
+ 
+ 	res->rss_active = true;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {
+ 		struct mlx5e_rss *rss = res->rss[i];
+ 
+ 		if (!rss)
+ 			continue;
+ 		mlx5e_rss_enable(rss, res->rss_rqns, res->rss_nch);
+ 	}
+ }
+ 
+ static void mlx5e_rx_res_rss_disable(struct mlx5e_rx_res *res)
+ {
+ 	int i;
+ 
+ 	res->rss_active = false;
+ 
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++) {
+ 		struct mlx5e_rss *rss = res->rss[i];
+ 
+ 		if (!rss)
+ 			continue;
+ 		mlx5e_rss_disable(rss);
+ 	}
+ }
+ 
+ /* Updates the indirection table SW shadow, does not update the HW resources yet */
+ void mlx5e_rx_res_rss_set_indir_uniform(struct mlx5e_rx_res *res, unsigned int nch)
+ {
+ 	WARN_ON_ONCE(res->rss_active);
+ 	mlx5e_rss_set_indir_uniform(res->rss[0], nch);
+ }
+ 
+ int mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,
+ 			      u32 *indir, u8 *key, u8 *hfunc)
+ {
+ 	struct mlx5e_rss *rss;
+ 
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return -EINVAL;
+ 
+ 	rss = res->rss[rss_idx];
+ 	if (!rss)
+ 		return -ENOENT;
+ 
+ 	return mlx5e_rss_get_rxfh(rss, indir, key, hfunc);
+ }
+ 
+ int mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,
+ 			      const u32 *indir, const u8 *key, const u8 *hfunc)
+ {
+ 	struct mlx5e_rss *rss;
+ 
+ 	if (rss_idx >= MLX5E_MAX_NUM_RSS)
+ 		return -EINVAL;
+ 
+ 	rss = res->rss[rss_idx];
+ 	if (!rss)
+ 		return -ENOENT;
+ 
+ 	return mlx5e_rss_set_rxfh(rss, indir, key, hfunc, res->rss_rqns, res->rss_nch);
+ }
+ 
+ u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
+ {
+ 	struct mlx5e_rss *rss = res->rss[0];
+ 
+ 	return mlx5e_rss_get_hash_fields(rss, tt);
+ }
+ 
+ int mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt,
+ 				     u8 rx_hash_fields)
+ {
+ 	struct mlx5e_rss *rss = res->rss[0];
+ 
+ 	return mlx5e_rss_set_hash_fields(rss, tt, rx_hash_fields);
+ }
+ 
+ int mlx5e_rx_res_rss_cnt(struct mlx5e_rx_res *res)
+ {
+ 	int i, cnt;
+ 
+ 	cnt = 0;
+ 	for (i = 0; i < MLX5E_MAX_NUM_RSS; i++)
+ 		if (res->rss[i])
+ 			cnt++;
+ 
+ 	return cnt;
+ }
+ 
+ /* End of API rx_res_rss_* */
+ 
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  struct mlx5e_rx_res *mlx5e_rx_res_alloc(void)
  {
  	return kvzalloc(sizeof(struct mlx5e_rx_res), GFP_KERNEL);
@@@ -385,11 -425,9 +612,15 @@@ int mlx5e_rx_res_init(struct mlx5e_rx_r
  	res->max_nch = max_nch;
  	res->drop_rqn = drop_rqn;
  
++<<<<<<< HEAD
 +	mlx5e_rx_res_rss_params_init(res, init_nch);
 +
 +	err = mlx5e_rx_res_rss_init(res, init_lro_param);
++=======
+ 	err = mlx5e_rx_res_rss_init_def(res, init_lro_param, init_nch);
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	if (err)
 -		goto err_out;
 +		return err;
  
  	err = mlx5e_rx_res_channels_init(res, init_lro_param);
  	if (err)
@@@ -404,7 -442,8 +635,12 @@@
  err_channels_destroy:
  	mlx5e_rx_res_channels_destroy(res);
  err_rss_destroy:
++<<<<<<< HEAD
 +	mlx5e_rx_res_rss_destroy(res);
++=======
+ 	__mlx5e_rx_res_rss_destroy(res, 0);
+ err_out:
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	return err;
  }
  
@@@ -432,15 -471,18 +668,27 @@@ u32 mlx5e_rx_res_get_tirn_xsk(struct ml
  	return mlx5e_tir_get_tirn(&res->channels[ix].xsk_tir);
  }
  
 -u32 mlx5e_rx_res_get_tirn_rss(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
 +u32 mlx5e_rx_res_get_tirn_rss(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
  {
++<<<<<<< HEAD
 +	return mlx5e_tir_get_tirn(&res->rss[tt].indir_tir);
++=======
+ 	struct mlx5e_rss *rss = res->rss[0];
+ 
+ 	return mlx5e_rss_get_tirn(rss, tt, false);
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  }
  
 -u32 mlx5e_rx_res_get_tirn_rss_inner(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt)
 +u32 mlx5e_rx_res_get_tirn_rss_inner(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
  {
++<<<<<<< HEAD
 +	WARN_ON(!(res->features & MLX5E_RX_RES_FEATURE_INNER_FT));
 +	return mlx5e_tir_get_tirn(&res->rss[tt].inner_indir_tir);
++=======
+ 	struct mlx5e_rss *rss = res->rss[0];
+ 
+ 	return mlx5e_rss_get_tirn(rss, tt, true);
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  }
  
  u32 mlx5e_rx_res_get_tirn_ptp(struct mlx5e_rx_res *res)
@@@ -787,25 -637,15 +1035,37 @@@ int mlx5e_rx_res_lro_set_param(struct m
  
  	final_err = 0;
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		err = mlx5e_tir_modify(&res->rss[tt].indir_tir, builder);
 +		if (err) {
 +			mlx5_core_warn(res->mdev, "Failed to update LRO state of indirect TIR %#x for traffic type %d: err = %d\n",
 +				       mlx5e_tir_get_tirn(&res->rss[tt].indir_tir), tt, err);
 +			if (!final_err)
 +				final_err = err;
 +		}
 +
 +		if (!(res->features & MLX5E_RX_RES_FEATURE_INNER_FT))
 +			continue;
 +
 +		err = mlx5e_tir_modify(&res->rss[tt].inner_indir_tir, builder);
 +		if (err) {
 +			mlx5_core_warn(res->mdev, "Failed to update LRO state of inner indirect TIR %#x for traffic type %d: err = %d\n",
 +				       mlx5e_tir_get_tirn(&res->rss[tt].inner_indir_tir), tt, err);
 +			if (!final_err)
 +				final_err = err;
 +		}
++=======
+ 	for (ix = 0; ix < MLX5E_MAX_NUM_RSS; ix++) {
+ 		struct mlx5e_rss *rss = res->rss[ix];
+ 
+ 		if (!rss)
+ 			continue;
+ 
+ 		err = mlx5e_rss_lro_set_param(rss, lro_param);
+ 		if (err)
+ 			final_err = final_err ? : err;
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	}
  
  	for (ix = 0; ix < res->max_nch; ix++) {
@@@ -824,5 -664,5 +1084,9 @@@
  
  struct mlx5e_rss_params_hash mlx5e_rx_res_get_current_hash(struct mlx5e_rx_res *res)
  {
++<<<<<<< HEAD
 +	return res->rss_params.hash;
++=======
+ 	return mlx5e_rss_get_hash(res->rss[0]);
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
index 934e41a0761f,8248caa36995..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
@@@ -50,14 -48,14 +50,24 @@@ int mlx5e_rx_res_xsk_activate(struct ml
  int mlx5e_rx_res_xsk_deactivate(struct mlx5e_rx_res *res, unsigned int ix);
  
  /* Configuration API */
 +struct mlx5e_rss_params_traffic_type
 +mlx5e_rx_res_rss_get_current_tt_config(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt);
  void mlx5e_rx_res_rss_set_indir_uniform(struct mlx5e_rx_res *res, unsigned int nch);
++<<<<<<< HEAD
 +void mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 *indir, u8 *key, u8 *hfunc);
 +int mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, const u32 *indir,
 +			      const u8 *key, const u8 *hfunc);
 +u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt);
 +int mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt,
++=======
+ int mlx5e_rx_res_rss_get_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,
+ 			      u32 *indir, u8 *key, u8 *hfunc);
+ int mlx5e_rx_res_rss_set_rxfh(struct mlx5e_rx_res *res, u32 rss_idx,
+ 			      const u32 *indir, const u8 *key, const u8 *hfunc);
+ 
+ u8 mlx5e_rx_res_rss_get_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt);
+ int mlx5e_rx_res_rss_set_hash_fields(struct mlx5e_rx_res *res, enum mlx5_traffic_types tt,
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  				     u8 rx_hash_fields);
  int mlx5e_rx_res_lro_set_param(struct mlx5e_rx_res *res, struct mlx5e_lro_param *lro_param);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 3a54bd65c2b7,839a753fda32..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -1198,18 -1206,53 +1210,61 @@@ static u32 mlx5e_get_rxfh_indir_size(st
  	return mlx5e_ethtool_get_rxfh_indir_size(priv);
  }
  
- int mlx5e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
- 		   u8 *hfunc)
+ static int mlx5e_get_rxfh_context(struct net_device *dev, u32 *indir,
+ 				  u8 *key, u8 *hfunc, u32 rss_context)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
 +
 +	mutex_lock(&priv->state_lock);
 +	mlx5e_rx_res_rss_get_rxfh(priv->rx_res, indir, key, hfunc);
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int err;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	err = mlx5e_rx_res_rss_get_rxfh(priv->rx_res, rss_context, indir, key, hfunc);
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	mutex_unlock(&priv->state_lock);
 -	return err;
 +
 +	return 0;
  }
  
+ static int mlx5e_set_rxfh_context(struct net_device *dev, const u32 *indir,
+ 				  const u8 *key, const u8 hfunc,
+ 				  u32 *rss_context, bool delete)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int err;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	if (delete) {
+ 		err = mlx5e_rx_res_rss_destroy(priv->rx_res, *rss_context);
+ 		goto unlock;
+ 	}
+ 
+ 	if (*rss_context == ETH_RXFH_CONTEXT_ALLOC) {
+ 		unsigned int count = priv->channels.params.num_channels;
+ 
+ 		err = mlx5e_rx_res_rss_init(priv->rx_res, rss_context, count);
+ 		if (err)
+ 			goto unlock;
+ 	}
+ 
+ 	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, *rss_context, indir, key,
+ 					hfunc == ETH_RSS_HASH_NO_CHANGE ? NULL : &hfunc);
+ 
+ unlock:
+ 	mutex_unlock(&priv->state_lock);
+ 	return err;
+ }
+ 
+ int mlx5e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+ 		   u8 *hfunc)
+ {
+ 	return mlx5e_get_rxfh_context(netdev, indir, key, hfunc, 0);
+ }
+ 
  int mlx5e_set_rxfh(struct net_device *dev, const u32 *indir,
  		   const u8 *key, const u8 hfunc)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
