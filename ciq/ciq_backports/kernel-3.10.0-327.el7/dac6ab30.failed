iser-target: Remove conn_ prefix from struct isert_conn members

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [iser-target] Remove conn_ prefix from struct isert_conn members (Andy Grover) [1136558 1185396]
Rebuild_FUZZ: 88.50%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit dac6ab305d73b5a67bbb2a0b3d8e2bd6a1383447
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dac6ab30.failed

These variables are always accessed via struct isert_conn so
no need to have a "conn_" prefix for them.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit dac6ab305d73b5a67bbb2a0b3d8e2bd6a1383447)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/isert/ib_isert.c
#	drivers/infiniband/ulp/isert/ib_isert.h
diff --cc drivers/infiniband/ulp/isert/ib_isert.c
index 6b6eb8b033b8,8f452f6a39f3..000000000000
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@@ -45,15 -76,15 +45,15 @@@ static struct kmem_cache *isert_cmd_cac
  static void
  isert_qp_event_callback(struct ib_event *e, void *context)
  {
 -	struct isert_conn *isert_conn = context;
 +	struct isert_conn *isert_conn = (struct isert_conn *)context;
  
 -	isert_err("conn %p event: %d\n", isert_conn, e->event);
 +	pr_err("isert_qp_event_callback event: %d\n", e->event);
  	switch (e->event) {
  	case IB_EVENT_COMM_EST:
- 		rdma_notify(isert_conn->conn_cm_id, IB_EVENT_COMM_EST);
+ 		rdma_notify(isert_conn->cm_id, IB_EVENT_COMM_EST);
  		break;
  	case IB_EVENT_QP_LAST_WQE_REACHED:
 -		isert_warn("Reached TX IB_EVENT_QP_LAST_WQE_REACHED\n");
 +		pr_warn("Reached TX IB_EVENT_QP_LAST_WQE_REACHED:\n");
  		break;
  	default:
  		break;
@@@ -76,27 -107,44 +76,64 @@@ isert_query_device(struct ib_device *ib
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +isert_conn_setup_qp(struct isert_conn *isert_conn, struct rdma_cm_id *cma_id)
++=======
+ static struct isert_comp *
+ isert_comp_get(struct isert_conn *isert_conn)
  {
- 	struct isert_device *device = isert_conn->conn_device;
+ 	struct isert_device *device = isert_conn->device;
+ 	struct isert_comp *comp;
+ 	int i, min = 0;
+ 
+ 	mutex_lock(&device_list_mutex);
+ 	for (i = 0; i < device->comps_used; i++)
+ 		if (device->comps[i].active_qps <
+ 		    device->comps[min].active_qps)
+ 			min = i;
+ 	comp = &device->comps[min];
+ 	comp->active_qps++;
+ 	mutex_unlock(&device_list_mutex);
+ 
+ 	isert_info("conn %p, using comp %p min_index: %d\n",
+ 		   isert_conn, comp, min);
+ 
+ 	return comp;
+ }
+ 
+ static void
+ isert_comp_put(struct isert_comp *comp)
+ {
+ 	mutex_lock(&device_list_mutex);
+ 	comp->active_qps--;
+ 	mutex_unlock(&device_list_mutex);
+ }
+ 
+ static struct ib_qp *
+ isert_create_qp(struct isert_conn *isert_conn,
+ 		struct isert_comp *comp,
+ 		struct rdma_cm_id *cma_id)
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
+ {
+ 	struct isert_device *device = isert_conn->device;
  	struct ib_qp_init_attr attr;
 -	int ret;
 +	struct ib_device_attr devattr;
 +	int ret, index, min_index = 0;
 +
 +	memset(&devattr, 0, sizeof(struct ib_device_attr));
 +	ret = isert_query_device(cma_id->device, &devattr);
 +	if (ret)
 +		return ret;
 +
 +	mutex_lock(&device_list_mutex);
 +	for (index = 0; index < device->cqs_used; index++)
 +		if (device->cq_active_qps[index] <
 +		    device->cq_active_qps[min_index])
 +			min_index = index;
 +	device->cq_active_qps[min_index]++;
 +	pr_debug("isert_conn_setup_qp: Using min_index: %d\n", min_index);
 +	mutex_unlock(&device_list_mutex);
  
  	memset(&attr, 0, sizeof(struct ib_qp_init_attr));
  	attr.event_handler = isert_qp_event_callback;
@@@ -118,21 -166,35 +155,42 @@@
  	attr.cap.max_recv_sge = 1;
  	attr.sq_sig_type = IB_SIGNAL_REQ_WR;
  	attr.qp_type = IB_QPT_RC;
 -	if (device->pi_capable)
 -		attr.create_flags |= IB_QP_CREATE_SIGNATURE_EN;
  
 -	ret = rdma_create_qp(cma_id, device->pd, &attr);
 +	pr_debug("isert_conn_setup_qp cma_id->device: %p\n",
 +		 cma_id->device);
 +	pr_debug("isert_conn_setup_qp conn_pd->device: %p\n",
 +		 isert_conn->conn_pd->device);
 +
 +	ret = rdma_create_qp(cma_id, isert_conn->conn_pd, &attr);
  	if (ret) {
++<<<<<<< HEAD
 +		pr_err("rdma_create_qp failed for cma_id %d\n", ret);
 +		return ret;
++=======
+ 		isert_err("rdma_create_qp failed for cma_id %d\n", ret);
+ 		return ERR_PTR(ret);
+ 	}
+ 
+ 	return cma_id->qp;
+ }
+ 
+ static int
+ isert_conn_setup_qp(struct isert_conn *isert_conn, struct rdma_cm_id *cma_id)
+ {
+ 	struct isert_comp *comp;
+ 	int ret;
+ 
+ 	comp = isert_comp_get(isert_conn);
+ 	isert_conn->qp = isert_create_qp(isert_conn, comp, cma_id);
+ 	if (IS_ERR(isert_conn->qp)) {
+ 		ret = PTR_ERR(isert_conn->qp);
+ 		goto err;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	}
 +	isert_conn->conn_qp = cma_id->qp;
 +	pr_debug("rdma_create_qp() returned success >>>>>>>>>>>>>>>>>>>>>>>>>.\n");
  
  	return 0;
 -err:
 -	isert_comp_put(comp);
 -	return ret;
  }
  
  static void
@@@ -144,7 -206,8 +202,12 @@@ isert_cq_event_callback(struct ib_even
  static int
  isert_alloc_rx_descriptors(struct isert_conn *isert_conn)
  {
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	struct iser_rx_desc *rx_desc;
  	struct ib_sge *rx_sg;
  	u64 dma_addr;
@@@ -168,10 -231,11 +231,15 @@@
  		rx_sg = &rx_desc->rx_sg;
  		rx_sg->addr = rx_desc->dma_addr;
  		rx_sg->length = ISER_RX_PAYLOAD_SIZE;
 -		rx_sg->lkey = device->mr->lkey;
 +		rx_sg->lkey = isert_conn->conn_mr->lkey;
  	}
  
++<<<<<<< HEAD
 +	isert_conn->conn_rx_desc_head = 0;
++=======
+ 	isert_conn->rx_desc_head = 0;
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	return 0;
  
  dma_map_fail:
@@@ -180,16 -244,18 +248,20 @@@
  		ib_dma_unmap_single(ib_dev, rx_desc->dma_addr,
  				    ISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);
  	}
- 	kfree(isert_conn->conn_rx_descs);
- 	isert_conn->conn_rx_descs = NULL;
+ 	kfree(isert_conn->rx_descs);
+ 	isert_conn->rx_descs = NULL;
  fail:
 -	isert_err("conn %p failed to allocate rx descriptors\n", isert_conn);
 -
  	return -ENOMEM;
  }
  
  static void
  isert_free_rx_descriptors(struct isert_conn *isert_conn)
  {
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 	struct ib_device *ib_dev = isert_conn->device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	struct iser_rx_desc *rx_desc;
  	int i;
  
@@@ -202,66 -268,67 +274,66 @@@
  				    ISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);
  	}
  
- 	kfree(isert_conn->conn_rx_descs);
- 	isert_conn->conn_rx_descs = NULL;
+ 	kfree(isert_conn->rx_descs);
+ 	isert_conn->rx_descs = NULL;
  }
  
 -static void isert_cq_work(struct work_struct *);
 -static void isert_cq_callback(struct ib_cq *, void *);
 -
 -static void
 -isert_free_comps(struct isert_device *device)
 -{
 -	int i;
 -
 -	for (i = 0; i < device->comps_used; i++) {
 -		struct isert_comp *comp = &device->comps[i];
 -
 -		if (comp->cq) {
 -			cancel_work_sync(&comp->work);
 -			ib_destroy_cq(comp->cq);
 -		}
 -	}
 -	kfree(device->comps);
 -}
 +static void isert_cq_tx_work(struct work_struct *);
 +static void isert_cq_tx_callback(struct ib_cq *, void *);
 +static void isert_cq_rx_work(struct work_struct *);
 +static void isert_cq_rx_callback(struct ib_cq *, void *);
  
  static int
 -isert_alloc_comps(struct isert_device *device,
 -		  struct ib_device_attr *attr)
 +isert_create_device_ib_res(struct isert_device *device)
  {
 -	int i, max_cqe, ret = 0;
 -
 -	device->comps_used = min(ISERT_MAX_CQ, min_t(int, num_online_cpus(),
 -				 device->ib_device->num_comp_vectors));
 +	struct ib_device *ib_dev = device->ib_device;
 +	struct isert_cq_desc *cq_desc;
 +	struct ib_device_attr dev_attr;
 +	int ret = 0, i, j;
 +	int max_rx_cqe, max_tx_cqe;
  
 -	isert_info("Using %d CQs, %s supports %d vectors support "
 -		   "Fast registration %d pi_capable %d\n",
 -		   device->comps_used, device->ib_device->name,
 -		   device->ib_device->num_comp_vectors, device->use_fastreg,
 -		   device->pi_capable);
 +	memset(&dev_attr, 0, sizeof(struct ib_device_attr));
 +	ret = isert_query_device(ib_dev, &dev_attr);
 +	if (ret)
 +		return ret;
  
 -	device->comps = kcalloc(device->comps_used, sizeof(struct isert_comp),
 -				GFP_KERNEL);
 -	if (!device->comps) {
 -		isert_err("Unable to allocate completion contexts\n");
 +	max_rx_cqe = min(ISER_MAX_RX_CQ_LEN, dev_attr.max_cqe);
 +	max_tx_cqe = min(ISER_MAX_TX_CQ_LEN, dev_attr.max_cqe);
 +
 +	device->cqs_used = min_t(int, num_online_cpus(),
 +				 device->ib_device->num_comp_vectors);
 +	device->cqs_used = min(ISERT_MAX_CQ, device->cqs_used);
 +	pr_debug("Using %d CQs, device %s supports %d vectors\n",
 +		 device->cqs_used, device->ib_device->name,
 +		 device->ib_device->num_comp_vectors);
 +	device->cq_desc = kzalloc(sizeof(struct isert_cq_desc) *
 +				device->cqs_used, GFP_KERNEL);
 +	if (!device->cq_desc) {
 +		pr_err("Unable to allocate device->cq_desc\n");
  		return -ENOMEM;
  	}
 +	cq_desc = device->cq_desc;
  
 -	max_cqe = min(ISER_MAX_CQ_LEN, attr->max_cqe);
 +	device->dev_pd = ib_alloc_pd(ib_dev);
 +	if (IS_ERR(device->dev_pd)) {
 +		ret = PTR_ERR(device->dev_pd);
 +		pr_err("ib_alloc_pd failed for dev_pd: %d\n", ret);
 +		goto out_cq_desc;
 +	}
  
 -	for (i = 0; i < device->comps_used; i++) {
 -		struct isert_comp *comp = &device->comps[i];
 +	for (i = 0; i < device->cqs_used; i++) {
 +		cq_desc[i].device = device;
 +		cq_desc[i].cq_index = i;
  
 -		comp->device = device;
 -		INIT_WORK(&comp->work, isert_cq_work);
 -		comp->cq = ib_create_cq(device->ib_device,
 -					isert_cq_callback,
 -					isert_cq_event_callback,
 -					(void *)comp,
 -					max_cqe, i);
 -		if (IS_ERR(comp->cq)) {
 -			isert_err("Unable to allocate cq\n");
 -			ret = PTR_ERR(comp->cq);
 -			comp->cq = NULL;
 +		INIT_WORK(&cq_desc[i].cq_rx_work, isert_cq_rx_work);
 +		device->dev_rx_cq[i] = ib_create_cq(device->ib_device,
 +						isert_cq_rx_callback,
 +						isert_cq_event_callback,
 +						(void *)&cq_desc[i],
 +						max_rx_cqe, i);
 +		if (IS_ERR(device->dev_rx_cq[i])) {
 +			ret = PTR_ERR(device->dev_rx_cq[i]);
 +			device->dev_rx_cq[i] = NULL;
  			goto out_cq;
  		}
  
@@@ -389,47 -465,209 +461,242 @@@ isert_device_find_by_ib_dev(struct rdma
  	return device;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ isert_conn_free_fastreg_pool(struct isert_conn *isert_conn)
+ {
+ 	struct fast_reg_descriptor *fr_desc, *tmp;
+ 	int i = 0;
+ 
+ 	if (list_empty(&isert_conn->fr_pool))
+ 		return;
+ 
+ 	isert_info("Freeing conn %p fastreg pool", isert_conn);
+ 
+ 	list_for_each_entry_safe(fr_desc, tmp,
+ 				 &isert_conn->fr_pool, list) {
+ 		list_del(&fr_desc->list);
+ 		ib_free_fast_reg_page_list(fr_desc->data_frpl);
+ 		ib_dereg_mr(fr_desc->data_mr);
+ 		if (fr_desc->pi_ctx) {
+ 			ib_free_fast_reg_page_list(fr_desc->pi_ctx->prot_frpl);
+ 			ib_dereg_mr(fr_desc->pi_ctx->prot_mr);
+ 			ib_destroy_mr(fr_desc->pi_ctx->sig_mr);
+ 			kfree(fr_desc->pi_ctx);
+ 		}
+ 		kfree(fr_desc);
+ 		++i;
+ 	}
+ 
+ 	if (i < isert_conn->fr_pool_size)
+ 		isert_warn("Pool still has %d regions registered\n",
+ 			isert_conn->fr_pool_size - i);
+ }
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  static int
 -isert_create_pi_ctx(struct fast_reg_descriptor *desc,
 -		    struct ib_device *device,
 -		    struct ib_pd *pd)
 +isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
  {
 -	struct ib_mr_init_attr mr_init_attr;
 -	struct pi_context *pi_ctx;
 -	int ret;
 +	struct iscsi_np *np = cma_id->context;
 +	struct isert_np *isert_np = np->np_context;
 +	struct isert_conn *isert_conn;
 +	struct isert_device *device;
 +	struct ib_device *ib_dev = cma_id->device;
 +	int ret = 0;
 +
 +	spin_lock_bh(&np->np_thread_lock);
 +	if (!np->enabled) {
 +		spin_unlock_bh(&np->np_thread_lock);
 +		pr_debug("iscsi_np is not enabled, reject connect request\n");
 +		return rdma_reject(cma_id, NULL, 0);
 +	}
 +	spin_unlock_bh(&np->np_thread_lock);
  
 -	pi_ctx = kzalloc(sizeof(*desc->pi_ctx), GFP_KERNEL);
 -	if (!pi_ctx) {
 -		isert_err("Failed to allocate pi context\n");
 +	pr_debug("Entering isert_connect_request cma_id: %p, context: %p\n",
 +		 cma_id, cma_id->context);
 +
 +	isert_conn = kzalloc(sizeof(struct isert_conn), GFP_KERNEL);
 +	if (!isert_conn) {
 +		pr_err("Unable to allocate isert_conn\n");
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
 +	isert_conn->state = ISER_CONN_INIT;
 +	INIT_LIST_HEAD(&isert_conn->conn_accept_node);
 +	init_completion(&isert_conn->conn_login_comp);
 +	init_completion(&isert_conn->conn_wait);
 +	init_completion(&isert_conn->conn_wait_comp_err);
 +	kref_init(&isert_conn->conn_kref);
 +	kref_get(&isert_conn->conn_kref);
 +	mutex_init(&isert_conn->conn_mutex);
 +
 +	cma_id->context = isert_conn;
 +	isert_conn->conn_cm_id = cma_id;
 +	isert_conn->responder_resources = event->param.conn.responder_resources;
 +	isert_conn->initiator_depth = event->param.conn.initiator_depth;
 +	pr_debug("Using responder_resources: %u initiator_depth: %u\n",
 +		 isert_conn->responder_resources, isert_conn->initiator_depth);
++=======
+ 
+ 	pi_ctx->prot_frpl = ib_alloc_fast_reg_page_list(device,
+ 					    ISCSI_ISER_SG_TABLESIZE);
+ 	if (IS_ERR(pi_ctx->prot_frpl)) {
+ 		isert_err("Failed to allocate prot frpl err=%ld\n",
+ 			  PTR_ERR(pi_ctx->prot_frpl));
+ 		ret = PTR_ERR(pi_ctx->prot_frpl);
+ 		goto err_pi_ctx;
+ 	}
+ 
+ 	pi_ctx->prot_mr = ib_alloc_fast_reg_mr(pd, ISCSI_ISER_SG_TABLESIZE);
+ 	if (IS_ERR(pi_ctx->prot_mr)) {
+ 		isert_err("Failed to allocate prot frmr err=%ld\n",
+ 			  PTR_ERR(pi_ctx->prot_mr));
+ 		ret = PTR_ERR(pi_ctx->prot_mr);
+ 		goto err_prot_frpl;
+ 	}
+ 	desc->ind |= ISERT_PROT_KEY_VALID;
+ 
+ 	memset(&mr_init_attr, 0, sizeof(mr_init_attr));
+ 	mr_init_attr.max_reg_descriptors = 2;
+ 	mr_init_attr.flags |= IB_MR_SIGNATURE_EN;
+ 	pi_ctx->sig_mr = ib_create_mr(pd, &mr_init_attr);
+ 	if (IS_ERR(pi_ctx->sig_mr)) {
+ 		isert_err("Failed to allocate signature enabled mr err=%ld\n",
+ 			  PTR_ERR(pi_ctx->sig_mr));
+ 		ret = PTR_ERR(pi_ctx->sig_mr);
+ 		goto err_prot_mr;
+ 	}
+ 
+ 	desc->pi_ctx = pi_ctx;
+ 	desc->ind |= ISERT_SIG_KEY_VALID;
+ 	desc->ind &= ~ISERT_PROTECTED;
+ 
+ 	return 0;
+ 
+ err_prot_mr:
+ 	ib_dereg_mr(desc->pi_ctx->prot_mr);
+ err_prot_frpl:
+ 	ib_free_fast_reg_page_list(desc->pi_ctx->prot_frpl);
+ err_pi_ctx:
+ 	kfree(desc->pi_ctx);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ isert_create_fr_desc(struct ib_device *ib_device, struct ib_pd *pd,
+ 		     struct fast_reg_descriptor *fr_desc)
+ {
+ 	int ret;
+ 
+ 	fr_desc->data_frpl = ib_alloc_fast_reg_page_list(ib_device,
+ 							 ISCSI_ISER_SG_TABLESIZE);
+ 	if (IS_ERR(fr_desc->data_frpl)) {
+ 		isert_err("Failed to allocate data frpl err=%ld\n",
+ 			  PTR_ERR(fr_desc->data_frpl));
+ 		return PTR_ERR(fr_desc->data_frpl);
+ 	}
+ 
+ 	fr_desc->data_mr = ib_alloc_fast_reg_mr(pd, ISCSI_ISER_SG_TABLESIZE);
+ 	if (IS_ERR(fr_desc->data_mr)) {
+ 		isert_err("Failed to allocate data frmr err=%ld\n",
+ 			  PTR_ERR(fr_desc->data_mr));
+ 		ret = PTR_ERR(fr_desc->data_mr);
+ 		goto err_data_frpl;
+ 	}
+ 	fr_desc->ind |= ISERT_DATA_KEY_VALID;
+ 
+ 	isert_dbg("Created fr_desc %p\n", fr_desc);
+ 
+ 	return 0;
+ 
+ err_data_frpl:
+ 	ib_free_fast_reg_page_list(fr_desc->data_frpl);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ isert_conn_create_fastreg_pool(struct isert_conn *isert_conn)
+ {
+ 	struct fast_reg_descriptor *fr_desc;
+ 	struct isert_device *device = isert_conn->device;
+ 	struct se_session *se_sess = isert_conn->conn->sess->se_sess;
+ 	struct se_node_acl *se_nacl = se_sess->se_node_acl;
+ 	int i, ret, tag_num;
+ 	/*
+ 	 * Setup the number of FRMRs based upon the number of tags
+ 	 * available to session in iscsi_target_locate_portal().
+ 	 */
+ 	tag_num = max_t(u32, ISCSIT_MIN_TAGS, se_nacl->queue_depth);
+ 	tag_num = (tag_num * 2) + ISCSIT_EXTRA_TAGS;
+ 
+ 	isert_conn->fr_pool_size = 0;
+ 	for (i = 0; i < tag_num; i++) {
+ 		fr_desc = kzalloc(sizeof(*fr_desc), GFP_KERNEL);
+ 		if (!fr_desc) {
+ 			isert_err("Failed to allocate fast_reg descriptor\n");
+ 			ret = -ENOMEM;
+ 			goto err;
+ 		}
+ 
+ 		ret = isert_create_fr_desc(device->ib_device,
+ 					   device->pd, fr_desc);
+ 		if (ret) {
+ 			isert_err("Failed to create fastreg descriptor err=%d\n",
+ 			       ret);
+ 			kfree(fr_desc);
+ 			goto err;
+ 		}
+ 
+ 		list_add_tail(&fr_desc->list, &isert_conn->fr_pool);
+ 		isert_conn->fr_pool_size++;
+ 	}
+ 
+ 	isert_dbg("Creating conn %p fastreg pool size=%d",
+ 		 isert_conn, isert_conn->fr_pool_size);
+ 
+ 	return 0;
+ 
+ err:
+ 	isert_conn_free_fastreg_pool(isert_conn);
+ 	return ret;
+ }
+ 
+ static void
+ isert_init_conn(struct isert_conn *isert_conn)
+ {
+ 	isert_conn->state = ISER_CONN_INIT;
+ 	INIT_LIST_HEAD(&isert_conn->accept_node);
+ 	init_completion(&isert_conn->login_comp);
+ 	init_completion(&isert_conn->login_req_comp);
+ 	init_completion(&isert_conn->wait);
+ 	kref_init(&isert_conn->kref);
+ 	mutex_init(&isert_conn->mutex);
+ 	spin_lock_init(&isert_conn->pool_lock);
+ 	INIT_LIST_HEAD(&isert_conn->fr_pool);
+ }
+ 
+ static void
+ isert_free_login_buf(struct isert_conn *isert_conn)
+ {
+ 	struct ib_device *ib_dev = isert_conn->device->ib_device;
+ 
+ 	ib_dma_unmap_single(ib_dev, isert_conn->login_rsp_dma,
+ 			    ISER_RX_LOGIN_SIZE, DMA_TO_DEVICE);
+ 	ib_dma_unmap_single(ib_dev, isert_conn->login_req_dma,
+ 			    ISCSI_DEF_MAX_RECV_SEG_LEN,
+ 			    DMA_FROM_DEVICE);
+ 	kfree(isert_conn->login_buf);
+ }
+ 
+ static int
+ isert_alloc_login_buf(struct isert_conn *isert_conn,
+ 		      struct ib_device *ib_dev)
+ {
+ 	int ret;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
  	isert_conn->login_buf = kzalloc(ISCSI_DEF_MAX_RECV_SEG_LEN +
  					ISER_RX_LOGIN_SIZE, GFP_KERNEL);
@@@ -470,25 -706,77 +737,74 @@@
  		goto out_req_dma_map;
  	}
  
++<<<<<<< HEAD
 +	device = isert_device_find_by_ib_dev(cma_id);
++=======
+ 	return 0;
+ 
+ out_req_dma_map:
+ 	ib_dma_unmap_single(ib_dev, isert_conn->login_req_dma,
+ 			    ISCSI_DEF_MAX_RECV_SEG_LEN, DMA_FROM_DEVICE);
+ out_login_buf:
+ 	kfree(isert_conn->login_buf);
+ 	return ret;
+ }
+ 
+ static int
+ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
+ {
+ 	struct isert_np *isert_np = cma_id->context;
+ 	struct iscsi_np *np = isert_np->np;
+ 	struct isert_conn *isert_conn;
+ 	struct isert_device *device;
+ 	int ret = 0;
+ 
+ 	spin_lock_bh(&np->np_thread_lock);
+ 	if (!np->enabled) {
+ 		spin_unlock_bh(&np->np_thread_lock);
+ 		isert_dbg("iscsi_np is not enabled, reject connect request\n");
+ 		return rdma_reject(cma_id, NULL, 0);
+ 	}
+ 	spin_unlock_bh(&np->np_thread_lock);
+ 
+ 	isert_dbg("cma_id: %p, portal: %p\n",
+ 		 cma_id, cma_id->context);
+ 
+ 	isert_conn = kzalloc(sizeof(struct isert_conn), GFP_KERNEL);
+ 	if (!isert_conn)
+ 		return -ENOMEM;
+ 
+ 	isert_init_conn(isert_conn);
+ 	isert_conn->cm_id = cma_id;
+ 
+ 	ret = isert_alloc_login_buf(isert_conn, cma_id->device);
+ 	if (ret)
+ 		goto out;
+ 
+ 	device = isert_device_get(cma_id);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	if (IS_ERR(device)) {
  		ret = PTR_ERR(device);
  		goto out_rsp_dma_map;
  	}
++<<<<<<< HEAD
++=======
+ 	isert_conn->device = device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	/* Set max inflight RDMA READ requests */
 -	isert_conn->initiator_depth = min_t(u8,
 -				event->param.conn.initiator_depth,
 -				device->dev_attr.max_qp_init_rd_atom);
 -	isert_dbg("Using initiator_depth: %u\n", isert_conn->initiator_depth);
 +	isert_conn->conn_device = device;
 +	isert_conn->conn_pd = device->dev_pd;
 +	isert_conn->conn_mr = device->dev_mr;
  
  	ret = isert_conn_setup_qp(isert_conn, cma_id);
  	if (ret)
  		goto out_conn_dev;
  
 -	ret = isert_rdma_post_recvl(isert_conn);
 -	if (ret)
 -		goto out_conn_dev;
 -
 -	ret = isert_rdma_accept(isert_conn);
 -	if (ret)
 -		goto out_conn_dev;
 -
  	mutex_lock(&isert_np->np_accept_mutex);
- 	list_add_tail(&isert_conn->conn_accept_node, &isert_np->np_accept_list);
+ 	list_add_tail(&isert_conn->accept_node, &isert_np->np_accept_list);
  	mutex_unlock(&isert_np->np_accept_mutex);
  
 -	isert_info("np %p: Allow accept_np to continue\n", np);
 +	pr_debug("isert_connect_request() up np_sem np: %p\n", np);
  	up(&isert_np->np_sem);
  	return 0;
  
@@@ -510,54 -793,60 +826,91 @@@ out
  static void
  isert_connect_release(struct isert_conn *isert_conn)
  {
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 +	struct isert_device *device = isert_conn->conn_device;
 +	int cq_index;
 +
 +	pr_debug("Entering isert_connect_release(): >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
 +
 +	if (isert_conn->conn_qp) {
 +		cq_index = ((struct isert_cq_desc *)
 +			isert_conn->conn_qp->recv_cq->cq_context)->cq_index;
 +		pr_debug("isert_connect_release: cq_index: %d\n", cq_index);
 +		isert_conn->conn_device->cq_active_qps[cq_index]--;
 +
 +		rdma_destroy_qp(isert_conn->conn_cm_id);
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 
+ 	isert_dbg("conn %p\n", isert_conn);
+ 
+ 	BUG_ON(!device);
+ 
+ 	if (device->use_fastreg)
+ 		isert_conn_free_fastreg_pool(isert_conn);
+ 
+ 	isert_free_rx_descriptors(isert_conn);
+ 	if (isert_conn->cm_id)
+ 		rdma_destroy_id(isert_conn->cm_id);
+ 
+ 	if (isert_conn->qp) {
+ 		struct isert_comp *comp = isert_conn->qp->recv_cq->cq_context;
+ 
+ 		isert_comp_put(comp);
+ 		ib_destroy_qp(isert_conn->qp);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	}
  
 -	if (isert_conn->login_buf)
 -		isert_free_login_buf(isert_conn);
 -
 -	isert_device_put(device);
 +	isert_free_rx_descriptors(isert_conn);
 +	rdma_destroy_id(isert_conn->conn_cm_id);
  
 +	if (isert_conn->login_buf) {
 +		ib_dma_unmap_single(ib_dev, isert_conn->login_rsp_dma,
 +				    ISER_RX_LOGIN_SIZE, DMA_TO_DEVICE);
 +		ib_dma_unmap_single(ib_dev, isert_conn->login_req_dma,
 +				    ISCSI_DEF_MAX_RECV_SEG_LEN,
 +				    DMA_FROM_DEVICE);
 +		kfree(isert_conn->login_buf);
 +	}
  	kfree(isert_conn);
 +
 +	if (device)
 +		isert_device_try_release(device);
 +
 +	pr_debug("Leaving isert_connect_release >>>>>>>>>>>>\n");
  }
  
  static void
  isert_connected_handler(struct rdma_cm_id *cma_id)
  {
++<<<<<<< HEAD
 +	return;
++=======
+ 	struct isert_conn *isert_conn = cma_id->qp->qp_context;
+ 
+ 	isert_info("conn %p\n", isert_conn);
+ 
+ 	if (!kref_get_unless_zero(&isert_conn->kref)) {
+ 		isert_warn("conn %p connect_release is running\n", isert_conn);
+ 		return;
+ 	}
+ 
+ 	mutex_lock(&isert_conn->mutex);
+ 	if (isert_conn->state != ISER_CONN_FULL_FEATURE)
+ 		isert_conn->state = ISER_CONN_UP;
+ 	mutex_unlock(&isert_conn->mutex);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  }
  
  static void
- isert_release_conn_kref(struct kref *kref)
+ isert_release_kref(struct kref *kref)
  {
  	struct isert_conn *isert_conn = container_of(kref,
- 				struct isert_conn, conn_kref);
+ 				struct isert_conn, kref);
  
 -	isert_info("conn %p final kref %s/%d\n", isert_conn, current->comm,
 -		   current->pid);
 +	pr_debug("Calling isert_connect_release for final kref %s/%d\n",
 +		 current->comm, current->pid);
  
  	isert_connect_release(isert_conn);
  }
@@@ -565,51 -854,102 +918,143 @@@
  static void
  isert_put_conn(struct isert_conn *isert_conn)
  {
- 	kref_put(&isert_conn->conn_kref, isert_release_conn_kref);
+ 	kref_put(&isert_conn->kref, isert_release_kref);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * isert_conn_terminate() - Initiate connection termination
+  * @isert_conn: isert connection struct
+  *
+  * Notes:
+  * In case the connection state is FULL_FEATURE, move state
+  * to TEMINATING and start teardown sequence (rdma_disconnect).
+  * In case the connection state is UP, complete flush as well.
+  *
+  * This routine must be called with mutex held. Thus it is
+  * safe to call multiple times.
+  */
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  static void
 -isert_conn_terminate(struct isert_conn *isert_conn)
 +isert_disconnect_work(struct work_struct *work)
  {
++<<<<<<< HEAD
 +	struct isert_conn *isert_conn = container_of(work,
 +				struct isert_conn, conn_logout_work);
 +
 +	pr_debug("isert_disconnect_work(): >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
 +	mutex_lock(&isert_conn->conn_mutex);
 +	if (isert_conn->state == ISER_CONN_UP)
 +		isert_conn->state = ISER_CONN_TERMINATING;
 +
 +	if (isert_conn->post_recv_buf_count == 0 &&
 +	    atomic_read(&isert_conn->post_send_buf_count) == 0) {
 +		mutex_unlock(&isert_conn->conn_mutex);
 +		goto wake_up;
 +	}
 +	if (!isert_conn->conn_cm_id) {
 +		mutex_unlock(&isert_conn->conn_mutex);
 +		isert_put_conn(isert_conn);
 +		return;
 +	}
 +
 +	if (isert_conn->disconnect) {
 +		/* Send DREQ/DREP towards our initiator */
 +		rdma_disconnect(isert_conn->conn_cm_id);
 +	}
 +
 +	mutex_unlock(&isert_conn->conn_mutex);
 +
 +wake_up:
 +	complete(&isert_conn->conn_wait);
 +	isert_put_conn(isert_conn);
++=======
+ 	int err;
+ 
+ 	switch (isert_conn->state) {
+ 	case ISER_CONN_TERMINATING:
+ 		break;
+ 	case ISER_CONN_UP:
+ 	case ISER_CONN_FULL_FEATURE: /* FALLTHRU */
+ 		isert_info("Terminating conn %p state %d\n",
+ 			   isert_conn, isert_conn->state);
+ 		isert_conn->state = ISER_CONN_TERMINATING;
+ 		err = rdma_disconnect(isert_conn->cm_id);
+ 		if (err)
+ 			isert_warn("Failed rdma_disconnect isert_conn %p\n",
+ 				   isert_conn);
+ 		break;
+ 	default:
+ 		isert_warn("conn %p teminating in state %d\n",
+ 			   isert_conn, isert_conn->state);
+ 	}
+ }
+ 
+ static int
+ isert_np_cma_handler(struct isert_np *isert_np,
+ 		     enum rdma_cm_event_type event)
+ {
+ 	isert_dbg("isert np %p, handling event %d\n", isert_np, event);
+ 
+ 	switch (event) {
+ 	case RDMA_CM_EVENT_DEVICE_REMOVAL:
+ 		isert_np->np_cm_id = NULL;
+ 		break;
+ 	case RDMA_CM_EVENT_ADDR_CHANGE:
+ 		isert_np->np_cm_id = isert_setup_id(isert_np);
+ 		if (IS_ERR(isert_np->np_cm_id)) {
+ 			isert_err("isert np %p setup id failed: %ld\n",
+ 				  isert_np, PTR_ERR(isert_np->np_cm_id));
+ 			isert_np->np_cm_id = NULL;
+ 		}
+ 		break;
+ 	default:
+ 		isert_err("isert np %p Unexpected event %d\n",
+ 			  isert_np, event);
+ 	}
+ 
+ 	return -1;
+ }
+ 
+ static int
+ isert_disconnected_handler(struct rdma_cm_id *cma_id,
+ 			   enum rdma_cm_event_type event)
+ {
+ 	struct isert_np *isert_np = cma_id->context;
+ 	struct isert_conn *isert_conn;
+ 
+ 	if (isert_np->np_cm_id == cma_id)
+ 		return isert_np_cma_handler(cma_id->context, event);
+ 
+ 	isert_conn = cma_id->qp->qp_context;
+ 
+ 	mutex_lock(&isert_conn->mutex);
+ 	isert_conn_terminate(isert_conn);
+ 	mutex_unlock(&isert_conn->mutex);
+ 
+ 	isert_info("conn %p completing wait\n", isert_conn);
+ 	complete(&isert_conn->wait);
+ 
+ 	return 0;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  }
  
 -static int
 -isert_connect_error(struct rdma_cm_id *cma_id)
 +static void
 +isert_disconnected_handler(struct rdma_cm_id *cma_id, bool disconnect)
  {
 -	struct isert_conn *isert_conn = cma_id->qp->qp_context;
 +	struct isert_conn *isert_conn = (struct isert_conn *)cma_id->context;
  
++<<<<<<< HEAD
 +	isert_conn->disconnect = disconnect;
 +	INIT_WORK(&isert_conn->conn_logout_work, isert_disconnect_work);
 +	schedule_work(&isert_conn->conn_logout_work);
++=======
+ 	isert_conn->cm_id = NULL;
+ 	isert_put_conn(isert_conn);
+ 
+ 	return -1;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  }
  
  static int
@@@ -655,12 -993,12 +1100,18 @@@ isert_post_recv(struct isert_conn *iser
  {
  	struct ib_recv_wr *rx_wr, *rx_wr_failed;
  	int i, ret;
- 	unsigned int rx_head = isert_conn->conn_rx_desc_head;
+ 	unsigned int rx_head = isert_conn->rx_desc_head;
  	struct iser_rx_desc *rx_desc;
  
++<<<<<<< HEAD
 +	for (rx_wr = isert_conn->conn_rx_wr, i = 0; i < count; i++, rx_wr++) {
 +		rx_desc		= &isert_conn->conn_rx_descs[rx_head];
 +		rx_wr->wr_id	= (unsigned long)rx_desc;
++=======
+ 	for (rx_wr = isert_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {
+ 		rx_desc		= &isert_conn->rx_descs[rx_head];
+ 		rx_wr->wr_id	= (uintptr_t)rx_desc;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  		rx_wr->sg_list	= &rx_desc->rx_sg;
  		rx_wr->num_sge	= 1;
  		rx_wr->next	= rx_wr + 1;
@@@ -671,14 -1009,14 +1122,19 @@@
  	rx_wr->next = NULL; /* mark end of work requests list */
  
  	isert_conn->post_recv_buf_count += count;
- 	ret = ib_post_recv(isert_conn->conn_qp, isert_conn->conn_rx_wr,
+ 	ret = ib_post_recv(isert_conn->qp, isert_conn->rx_wr,
  				&rx_wr_failed);
  	if (ret) {
 -		isert_err("ib_post_recv() failed with ret: %d\n", ret);
 +		pr_err("ib_post_recv() failed with ret: %d\n", ret);
  		isert_conn->post_recv_buf_count -= count;
  	} else {
++<<<<<<< HEAD
 +		pr_debug("isert_post_recv(): Posted %d RX buffers\n", count);
 +		isert_conn->conn_rx_desc_head = rx_head;
++=======
+ 		isert_dbg("Posted %d RX buffers\n", count);
+ 		isert_conn->rx_desc_head = rx_head;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	}
  	return ret;
  }
@@@ -700,13 -1038,9 +1156,19 @@@ isert_post_send(struct isert_conn *iser
  	send_wr.opcode	= IB_WR_SEND;
  	send_wr.send_flags = IB_SEND_SIGNALED;
  
++<<<<<<< HEAD
 +	atomic_inc(&isert_conn->post_send_buf_count);
 +
 +	ret = ib_post_send(isert_conn->conn_qp, &send_wr, &send_wr_failed);
 +	if (ret) {
 +		pr_err("ib_post_send() failed, ret: %d\n", ret);
 +		atomic_dec(&isert_conn->post_send_buf_count);
 +	}
++=======
+ 	ret = ib_post_send(isert_conn->qp, &send_wr, &send_wr_failed);
+ 	if (ret)
+ 		isert_err("ib_post_send() failed, ret: %d\n", ret);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
  	return ret;
  }
@@@ -716,7 -1050,8 +1178,12 @@@ isert_create_send_desc(struct isert_con
  		       struct isert_cmd *isert_cmd,
  		       struct iser_tx_desc *tx_desc)
  {
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
  	ib_dma_sync_single_for_cpu(ib_dev, tx_desc->dma_addr,
  				   ISER_HEADERS_LEN, DMA_TO_DEVICE);
@@@ -737,7 -1072,8 +1204,12 @@@ static in
  isert_init_tx_hdrs(struct isert_conn *isert_conn,
  		   struct iser_tx_desc *tx_desc)
  {
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	u64 dma_addr;
  
  	dma_addr = ib_dma_map_single(ib_dev, (void *)tx_desc,
@@@ -780,9 -1119,9 +1252,13 @@@ isert_rdma_post_recvl(struct isert_con
  	memset(&sge, 0, sizeof(struct ib_sge));
  	sge.addr = isert_conn->login_req_dma;
  	sge.length = ISER_RX_LOGIN_SIZE;
++<<<<<<< HEAD
 +	sge.lkey = isert_conn->conn_mr->lkey;
++=======
+ 	sge.lkey = isert_conn->device->mr->lkey;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	isert_dbg("Setup sge: addr: %llx length: %d 0x%08x\n",
 +	pr_debug("Setup sge: addr: %llx length: %d 0x%08x\n",
  		sge.addr, sge.length, sge.lkey);
  
  	memset(&rx_wr, 0, sizeof(struct ib_recv_wr));
@@@ -791,9 -1130,9 +1267,9 @@@
  	rx_wr.num_sge = 1;
  
  	isert_conn->post_recv_buf_count++;
- 	ret = ib_post_recv(isert_conn->conn_qp, &rx_wr, &rx_wr_fail);
+ 	ret = ib_post_recv(isert_conn->qp, &rx_wr, &rx_wr_fail);
  	if (ret) {
 -		isert_err("ib_post_recv() failed: %d\n", ret);
 +		pr_err("ib_post_recv() failed: %d\n", ret);
  		isert_conn->post_recv_buf_count--;
  	}
  
@@@ -806,8 -1144,9 +1282,14 @@@ isert_put_login_tx(struct iscsi_conn *c
  		   u32 length)
  {
  	struct isert_conn *isert_conn = conn->context;
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 +	struct iser_tx_desc *tx_desc = &isert_conn->conn_login_tx_desc;
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
+ 	struct iser_tx_desc *tx_desc = &isert_conn->login_tx_desc;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	int ret;
  
  	isert_create_send_desc(isert_conn, NULL, tx_desc);
@@@ -830,11 -1169,21 +1312,28 @@@
  
  		tx_dsg->addr	= isert_conn->login_rsp_dma;
  		tx_dsg->length	= length;
++<<<<<<< HEAD
 +		tx_dsg->lkey	= isert_conn->conn_mr->lkey;
++=======
+ 		tx_dsg->lkey	= isert_conn->device->mr->lkey;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  		tx_desc->num_sge = 2;
  	}
  	if (!login->login_failed) {
  		if (login->login_complete) {
++<<<<<<< HEAD
++=======
+ 			if (!conn->sess->sess_ops->SessionType &&
+ 			    isert_conn->device->use_fastreg) {
+ 				ret = isert_conn_create_fastreg_pool(isert_conn);
+ 				if (ret) {
+ 					isert_err("Conn: %p failed to create"
+ 					       " fastreg pool\n", isert_conn);
+ 					return ret;
+ 				}
+ 			}
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  			ret = isert_alloc_rx_descriptors(isert_conn);
  			if (ret)
  				return ret;
@@@ -843,7 -1192,10 +1342,14 @@@
  			if (ret)
  				return ret;
  
++<<<<<<< HEAD
 +			isert_conn->state = ISER_CONN_UP;
++=======
+ 			/* Now we are in FULL_FEATURE phase */
+ 			mutex_lock(&isert_conn->mutex);
+ 			isert_conn->state = ISER_CONN_FULL_FEATURE;
+ 			mutex_unlock(&isert_conn->mutex);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  			goto post_send;
  		}
  
@@@ -897,25 -1248,16 +1403,33 @@@ isert_rx_login_req(struct iser_rx_desc 
  	memcpy(&login->req[0], (void *)&rx_desc->iscsi_header, ISCSI_HDR_LEN);
  
  	size = min(rx_buflen, MAX_KEY_VALUE_PAIRS);
 -	isert_dbg("Using login payload size: %d, rx_buflen: %d "
 -		  "MAX_KEY_VALUE_PAIRS: %d\n", size, rx_buflen,
 -		  MAX_KEY_VALUE_PAIRS);
 +	pr_debug("Using login payload size: %d, rx_buflen: %d MAX_KEY_VALUE_PAIRS: %d\n",
 +		 size, rx_buflen, MAX_KEY_VALUE_PAIRS);
  	memcpy(login->req_buf, &rx_desc->data[0], size);
  
++<<<<<<< HEAD
 +	complete(&isert_conn->conn_login_comp);
 +}
 +
 +static void
 +isert_release_cmd(struct iscsi_cmd *cmd)
 +{
 +	struct isert_cmd *isert_cmd = container_of(cmd, struct isert_cmd,
 +						   iscsi_cmd);
 +
 +	pr_debug("Entering isert_release_cmd %p >>>>>>>>>>>>>>>.\n", isert_cmd);
 +
 +	kfree(cmd->buf_ptr);
 +	kfree(cmd->tmr_req);
 +
 +	kmem_cache_free(isert_cmd_cache, isert_cmd);
++=======
+ 	if (login->first_request) {
+ 		complete(&isert_conn->login_comp);
+ 		return;
+ 	}
+ 	schedule_delayed_work(&conn->login_work, 0);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  }
  
  static struct iscsi_cmd
@@@ -1216,10 -1565,11 +1730,10 @@@ isert_rx_do_work(struct iser_rx_desc *r
  }
  
  static void
 -isert_rcv_completion(struct iser_rx_desc *desc,
 -		     struct isert_conn *isert_conn,
 -		     u32 xfer_len)
 +isert_rx_completion(struct iser_rx_desc *desc, struct isert_conn *isert_conn,
 +		    unsigned long xfer_len)
  {
- 	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
+ 	struct ib_device *ib_dev = isert_conn->cm_id->device;
  	struct iscsi_hdr *hdr;
  	u64 rx_dma;
  	int rx_buflen, outstanding;
@@@ -1243,11 -1593,20 +1757,26 @@@
  		 hdr->opcode, hdr->itt, hdr->flags,
  		 (int)(xfer_len - ISER_HEADERS_LEN));
  
++<<<<<<< HEAD
 +	if ((char *)desc == isert_conn->login_req_buf)
 +		isert_rx_login_req(desc, xfer_len - ISER_HEADERS_LEN,
 +				   isert_conn);
 +	else
++=======
+ 	if ((char *)desc == isert_conn->login_req_buf) {
+ 		isert_conn->login_req_len = xfer_len - ISER_HEADERS_LEN;
+ 		if (isert_conn->conn) {
+ 			struct iscsi_login *login = isert_conn->conn->conn_login;
+ 
+ 			if (login && !login->first_request)
+ 				isert_rx_login_req(isert_conn);
+ 		}
+ 		mutex_lock(&isert_conn->mutex);
+ 		complete(&isert_conn->login_req_comp);
+ 		mutex_unlock(&isert_conn->mutex);
+ 	} else {
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  		isert_rx_do_work(desc, isert_conn);
 -	}
  
  	ib_dma_sync_single_for_device(ib_dev, rx_dma, rx_buflen,
  				      DMA_FROM_DEVICE);
@@@ -1271,34 -1630,113 +1800,127 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ isert_map_data_buf(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
+ 		   struct scatterlist *sg, u32 nents, u32 length, u32 offset,
+ 		   enum iser_ib_op_code op, struct isert_data_buf *data)
+ {
+ 	struct ib_device *ib_dev = isert_conn->cm_id->device;
+ 
+ 	data->dma_dir = op == ISER_IB_RDMA_WRITE ?
+ 			      DMA_TO_DEVICE : DMA_FROM_DEVICE;
+ 
+ 	data->len = length - offset;
+ 	data->offset = offset;
+ 	data->sg_off = data->offset / PAGE_SIZE;
+ 
+ 	data->sg = &sg[data->sg_off];
+ 	data->nents = min_t(unsigned int, nents - data->sg_off,
+ 					  ISCSI_ISER_SG_TABLESIZE);
+ 	data->len = min_t(unsigned int, data->len, ISCSI_ISER_SG_TABLESIZE *
+ 					PAGE_SIZE);
+ 
+ 	data->dma_nents = ib_dma_map_sg(ib_dev, data->sg, data->nents,
+ 					data->dma_dir);
+ 	if (unlikely(!data->dma_nents)) {
+ 		isert_err("Cmd: unable to dma map SGs %p\n", sg);
+ 		return -EINVAL;
+ 	}
+ 
+ 	isert_dbg("Mapped cmd: %p count: %u sg: %p sg_nents: %u rdma_len %d\n",
+ 		  isert_cmd, data->dma_nents, data->sg, data->nents, data->len);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ isert_unmap_data_buf(struct isert_conn *isert_conn, struct isert_data_buf *data)
+ {
+ 	struct ib_device *ib_dev = isert_conn->cm_id->device;
+ 
+ 	ib_dma_unmap_sg(ib_dev, data->sg, data->nents, data->dma_dir);
+ 	memset(data, 0, sizeof(*data));
+ }
+ 
+ 
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  static void
  isert_unmap_cmd(struct isert_cmd *isert_cmd, struct isert_conn *isert_conn)
  {
  	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
  
 -	isert_dbg("Cmd %p\n", isert_cmd);
 +	pr_debug("isert_unmap_cmd >>>>>>>>>>>>>>>>>>>>>>>\n");
  
 -	if (wr->data.sg) {
 -		isert_dbg("Cmd %p unmap_sg op\n", isert_cmd);
 -		isert_unmap_data_buf(isert_conn, &wr->data);
 +	if (wr->sge) {
 +		ib_dma_unmap_sg(ib_dev, wr->sge, wr->num_sge, DMA_TO_DEVICE);
 +		wr->sge = NULL;
  	}
  
++<<<<<<< HEAD
 +	kfree(wr->send_wr);
++=======
+ 	if (wr->send_wr) {
+ 		isert_dbg("Cmd %p free send_wr\n", isert_cmd);
+ 		kfree(wr->send_wr);
+ 		wr->send_wr = NULL;
+ 	}
+ 
+ 	if (wr->ib_sge) {
+ 		isert_dbg("Cmd %p free ib_sge\n", isert_cmd);
+ 		kfree(wr->ib_sge);
+ 		wr->ib_sge = NULL;
+ 	}
+ }
+ 
+ static void
+ isert_unreg_rdma(struct isert_cmd *isert_cmd, struct isert_conn *isert_conn)
+ {
+ 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
+ 
+ 	isert_dbg("Cmd %p\n", isert_cmd);
+ 
+ 	if (wr->fr_desc) {
+ 		isert_dbg("Cmd %p free fr_desc %p\n", isert_cmd, wr->fr_desc);
+ 		if (wr->fr_desc->ind & ISERT_PROTECTED) {
+ 			isert_unmap_data_buf(isert_conn, &wr->prot);
+ 			wr->fr_desc->ind &= ~ISERT_PROTECTED;
+ 		}
+ 		spin_lock_bh(&isert_conn->pool_lock);
+ 		list_add_tail(&wr->fr_desc->list, &isert_conn->fr_pool);
+ 		spin_unlock_bh(&isert_conn->pool_lock);
+ 		wr->fr_desc = NULL;
+ 	}
+ 
+ 	if (wr->data.sg) {
+ 		isert_dbg("Cmd %p unmap_sg op\n", isert_cmd);
+ 		isert_unmap_data_buf(isert_conn, &wr->data);
+ 	}
+ 
+ 	wr->ib_sge = NULL;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	wr->send_wr = NULL;
 +
 +	kfree(isert_cmd->ib_sge);
 +	isert_cmd->ib_sge = NULL;
  }
  
  static void
  isert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)
  {
 -	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
 +	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
  	struct isert_conn *isert_conn = isert_cmd->conn;
  	struct iscsi_conn *conn = isert_conn->conn;
++<<<<<<< HEAD
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct iscsi_text_rsp *hdr;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	isert_dbg("Cmd %p\n", isert_cmd);
 +	pr_debug("Entering isert_put_cmd: %p\n", isert_cmd);
  
  	switch (cmd->iscsi_opcode) {
  	case ISCSI_OP_SCSI_CMD:
@@@ -1389,34 -1831,100 +2011,119 @@@ isert_completion_put(struct iser_tx_des
  	isert_put_cmd(isert_cmd, comp_err);
  }
  
- static void
- isert_completion_rdma_read(struct iser_tx_desc *tx_desc,
- 			   struct isert_cmd *isert_cmd)
++<<<<<<< HEAD
++=======
+ static int
+ isert_check_pi_status(struct se_cmd *se_cmd, struct ib_mr *sig_mr)
  {
- 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
- 	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
- 	struct se_cmd *se_cmd = &cmd->se_cmd;
- 	struct ib_device *ib_dev = isert_cmd->conn->conn_cm_id->device;
- 
- 	iscsit_stop_dataout_timer(cmd);
+ 	struct ib_mr_status mr_status;
+ 	int ret;
  
- 	if (wr->sge) {
- 		pr_debug("isert_do_rdma_read_comp: Unmapping wr->sge from t_data_sg\n");
- 		ib_dma_unmap_sg(ib_dev, wr->sge, wr->num_sge, DMA_TO_DEVICE);
- 		wr->sge = NULL;
+ 	ret = ib_check_mr_status(sig_mr, IB_MR_CHECK_SIG_STATUS, &mr_status);
+ 	if (ret) {
+ 		isert_err("ib_check_mr_status failed, ret %d\n", ret);
+ 		goto fail_mr_status;
  	}
  
- 	if (isert_cmd->ib_sge) {
- 		pr_debug("isert_do_rdma_read_comp: Freeing isert_cmd->ib_sge\n");
- 		kfree(isert_cmd->ib_sge);
- 		isert_cmd->ib_sge = NULL;
- 	}
+ 	if (mr_status.fail_status & IB_MR_CHECK_SIG_STATUS) {
+ 		u64 sec_offset_err;
+ 		u32 block_size = se_cmd->se_dev->dev_attrib.block_size + 8;
  
- 	cmd->write_data_done = se_cmd->data_length;
- 	wr->send_wr_num = 0;
+ 		switch (mr_status.sig_err.err_type) {
+ 		case IB_SIG_BAD_GUARD:
+ 			se_cmd->pi_err = TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;
+ 			break;
+ 		case IB_SIG_BAD_REFTAG:
+ 			se_cmd->pi_err = TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
+ 			break;
+ 		case IB_SIG_BAD_APPTAG:
+ 			se_cmd->pi_err = TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;
+ 			break;
+ 		}
+ 		sec_offset_err = mr_status.sig_err.sig_err_offset;
+ 		do_div(sec_offset_err, block_size);
+ 		se_cmd->bad_sector = sec_offset_err + se_cmd->t_task_lba;
  
- 	pr_debug("isert_do_rdma_read_comp, calling target_execute_cmd\n");
- 	spin_lock_bh(&cmd->istate_lock);
+ 		isert_err("PI error found type %d at sector 0x%llx "
+ 			  "expected 0x%x vs actual 0x%x\n",
+ 			  mr_status.sig_err.err_type,
+ 			  (unsigned long long)se_cmd->bad_sector,
+ 			  mr_status.sig_err.expected,
+ 			  mr_status.sig_err.actual);
+ 		ret = 1;
+ 	}
+ 
+ fail_mr_status:
+ 	return ret;
+ }
+ 
+ static void
+ isert_completion_rdma_write(struct iser_tx_desc *tx_desc,
+ 			    struct isert_cmd *isert_cmd)
+ {
+ 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
+ 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	struct isert_conn *isert_conn = isert_cmd->conn;
+ 	struct isert_device *device = isert_conn->device;
+ 	int ret = 0;
+ 
+ 	if (wr->fr_desc && wr->fr_desc->ind & ISERT_PROTECTED) {
+ 		ret = isert_check_pi_status(se_cmd,
+ 					    wr->fr_desc->pi_ctx->sig_mr);
+ 		wr->fr_desc->ind &= ~ISERT_PROTECTED;
+ 	}
+ 
+ 	device->unreg_rdma_mem(isert_cmd, isert_conn);
+ 	wr->send_wr_num = 0;
+ 	if (ret)
+ 		transport_send_check_condition_and_sense(se_cmd,
+ 							 se_cmd->pi_err, 0);
+ 	else
+ 		isert_put_response(isert_conn->conn, cmd);
+ }
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
+ static void
+ isert_completion_rdma_read(struct iser_tx_desc *tx_desc,
+ 			   struct isert_cmd *isert_cmd)
+ {
+ 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
 -	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
++	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
++<<<<<<< HEAD
++	struct ib_device *ib_dev = isert_cmd->conn->conn_cm_id->device;
++=======
+ 	struct isert_conn *isert_conn = isert_cmd->conn;
+ 	struct isert_device *device = isert_conn->device;
+ 	int ret = 0;
+ 
+ 	if (wr->fr_desc && wr->fr_desc->ind & ISERT_PROTECTED) {
+ 		ret = isert_check_pi_status(se_cmd,
+ 					    wr->fr_desc->pi_ctx->sig_mr);
+ 		wr->fr_desc->ind &= ~ISERT_PROTECTED;
+ 	}
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
+ 
+ 	iscsit_stop_dataout_timer(cmd);
 -	device->unreg_rdma_mem(isert_cmd, isert_conn);
 -	cmd->write_data_done = wr->data.len;
++
++	if (wr->sge) {
++		pr_debug("isert_do_rdma_read_comp: Unmapping wr->sge from t_data_sg\n");
++		ib_dma_unmap_sg(ib_dev, wr->sge, wr->num_sge, DMA_TO_DEVICE);
++		wr->sge = NULL;
++	}
++
++	if (isert_cmd->ib_sge) {
++		pr_debug("isert_do_rdma_read_comp: Freeing isert_cmd->ib_sge\n");
++		kfree(isert_cmd->ib_sge);
++		isert_cmd->ib_sge = NULL;
++	}
++
++	cmd->write_data_done = se_cmd->data_length;
+ 	wr->send_wr_num = 0;
+ 
 -	isert_dbg("Cmd: %p RDMA_READ comp calling execute_cmd\n", isert_cmd);
++	pr_debug("isert_do_rdma_read_comp, calling target_execute_cmd\n");
+ 	spin_lock_bh(&cmd->istate_lock);
  	cmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;
  	cmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;
  	spin_unlock_bh(&cmd->istate_lock);
@@@ -1430,8 -1944,10 +2137,15 @@@ isert_do_control_comp(struct work_struc
  	struct isert_cmd *isert_cmd = container_of(work,
  			struct isert_cmd, comp_work);
  	struct isert_conn *isert_conn = isert_cmd->conn;
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 +	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
++=======
+ 	struct ib_device *ib_dev = isert_conn->cm_id->device;
+ 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+ 
+ 	isert_dbg("Cmd %p i_state %d\n", isert_cmd, cmd->i_state);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
  	switch (cmd->i_state) {
  	case ISTATE_SEND_TASKMGTRSP:
@@@ -1494,10 -1992,10 +2208,10 @@@ isert_response_completion(struct iser_t
  }
  
  static void
 -isert_snd_completion(struct iser_tx_desc *tx_desc,
 +isert_send_completion(struct iser_tx_desc *tx_desc,
  		      struct isert_conn *isert_conn)
  {
- 	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
+ 	struct ib_device *ib_dev = isert_conn->cm_id->device;
  	struct isert_cmd *isert_cmd = tx_desc->isert_cmd;
  	struct isert_rdma_wr *wr;
  
@@@ -1535,41 -2025,52 +2249,57 @@@
  	}
  }
  
 -/**
 - * is_isert_tx_desc() - Indicate if the completion wr_id
 - *     is a TX descriptor or not.
 - * @isert_conn: iser connection
 - * @wr_id: completion WR identifier
 - *
 - * Since we cannot rely on wc opcode in FLUSH errors
 - * we must work around it by checking if the wr_id address
 - * falls in the iser connection rx_descs buffer. If so
 - * it is an RX descriptor, otherwize it is a TX.
 - */
 -static inline bool
 -is_isert_tx_desc(struct isert_conn *isert_conn, void *wr_id)
 +static void
 +isert_cq_tx_comp_err(struct iser_tx_desc *tx_desc, struct isert_conn *isert_conn)
  {
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 +	struct isert_cmd *isert_cmd = tx_desc->isert_cmd;
++=======
+ 	void *start = isert_conn->rx_descs;
+ 	int len = ISERT_QP_MAX_RECV_DTOS * sizeof(*isert_conn->rx_descs);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	if (wr_id >= start && wr_id < start + len)
 -		return false;
 -
 -	return true;
 +	if (!isert_cmd)
 +		isert_unmap_tx_desc(tx_desc, ib_dev);
 +	else
 +		isert_completion_put(tx_desc, isert_cmd, ib_dev, true);
  }
  
  static void
 -isert_cq_comp_err(struct isert_conn *isert_conn, struct ib_wc *wc)
 +isert_cq_rx_comp_err(struct isert_conn *isert_conn)
  {
++<<<<<<< HEAD
 +	struct iscsi_conn *conn = isert_conn->conn;
++=======
+ 	if (wc->wr_id == ISER_BEACON_WRID) {
+ 		isert_info("conn %p completing wait_comp_err\n",
+ 			   isert_conn);
+ 		complete(&isert_conn->wait_comp_err);
+ 	} else if (is_isert_tx_desc(isert_conn, (void *)(uintptr_t)wc->wr_id)) {
+ 		struct ib_device *ib_dev = isert_conn->cm_id->device;
+ 		struct isert_cmd *isert_cmd;
+ 		struct iser_tx_desc *desc;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -		desc = (struct iser_tx_desc *)(uintptr_t)wc->wr_id;
 -		isert_cmd = desc->isert_cmd;
 -		if (!isert_cmd)
 -			isert_unmap_tx_desc(desc, ib_dev);
 -		else
 -			isert_completion_put(desc, isert_cmd, ib_dev, true);
 -	} else {
 -		isert_conn->post_recv_buf_count--;
 -		if (!isert_conn->post_recv_buf_count)
 -			iscsit_cause_connection_reinstatement(isert_conn->conn, 0);
 +	if (isert_conn->post_recv_buf_count)
 +		return;
 +
 +	if (conn->sess) {
 +		target_sess_cmd_list_set_waiting(conn->sess->se_sess);
 +		target_wait_for_sess_cmds(conn->sess->se_sess);
  	}
 +
 +	while (atomic_read(&isert_conn->post_send_buf_count))
 +		msleep(3000);
 +
 +	mutex_lock(&isert_conn->conn_mutex);
 +	isert_conn->state = ISER_CONN_DOWN;
 +	mutex_unlock(&isert_conn->conn_mutex);
 +
 +	iscsit_cause_connection_reinstatement(isert_conn->conn, 0);
 +
 +	complete(&isert_conn->conn_wait_comp_err);
  }
  
  static void
@@@ -1656,13 -2136,10 +2386,17 @@@ isert_post_response(struct isert_conn *
  	struct ib_send_wr *wr_failed;
  	int ret;
  
++<<<<<<< HEAD
 +	atomic_inc(&isert_conn->post_send_buf_count);
 +
 +	ret = ib_post_send(isert_conn->conn_qp, &isert_cmd->tx_desc.send_wr,
++=======
+ 	ret = ib_post_send(isert_conn->qp, &isert_cmd->tx_desc.send_wr,
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  			   &wr_failed);
  	if (ret) {
 -		isert_err("ib_post_send failed with %d\n", ret);
 +		pr_err("ib_post_send failed with %d\n", ret);
 +		atomic_dec(&isert_conn->post_send_buf_count);
  		return ret;
  	}
  	return ret;
@@@ -1687,7 -2163,8 +2421,12 @@@ isert_put_response(struct iscsi_conn *c
  	if (cmd->se_cmd.sense_buffer &&
  	    ((cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||
  	    (cmd->se_cmd.se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {
++<<<<<<< HEAD
 +		struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 		struct isert_device *device = isert_conn->device;
+ 		struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  		struct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];
  		u32 padding, pdu_len;
  
@@@ -1717,6 -2194,44 +2456,47 @@@
  	return isert_post_response(isert_conn, isert_cmd);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ isert_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
+ {
+ 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+ 	struct isert_conn *isert_conn = conn->context;
+ 	struct isert_device *device = isert_conn->device;
+ 
+ 	spin_lock_bh(&conn->cmd_lock);
+ 	if (!list_empty(&cmd->i_conn_node))
+ 		list_del_init(&cmd->i_conn_node);
+ 	spin_unlock_bh(&conn->cmd_lock);
+ 
+ 	if (cmd->data_direction == DMA_TO_DEVICE)
+ 		iscsit_stop_dataout_timer(cmd);
+ 
+ 	device->unreg_rdma_mem(isert_cmd, isert_conn);
+ }
+ 
+ static enum target_prot_op
+ isert_get_sup_prot_ops(struct iscsi_conn *conn)
+ {
+ 	struct isert_conn *isert_conn = conn->context;
+ 	struct isert_device *device = isert_conn->device;
+ 
+ 	if (conn->tpg->tpg_attrib.t10_pi) {
+ 		if (device->pi_capable) {
+ 			isert_info("conn %p PI offload enabled\n", isert_conn);
+ 			isert_conn->pi_support = true;
+ 			return TARGET_PROT_ALL;
+ 		}
+ 	}
+ 
+ 	isert_info("conn %p PI offload disabled\n", isert_conn);
+ 	isert_conn->pi_support = false;
+ 
+ 	return TARGET_PROT_NORMAL;
+ }
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  static int
  isert_put_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn,
  		bool nopout_response)
@@@ -1779,11 -2291,11 +2559,16 @@@ isert_put_tm_rsp(struct iscsi_cmd *cmd
  static int
  isert_put_reject(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
  {
 -	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
 -	struct isert_conn *isert_conn = conn->context;
 +	struct isert_cmd *isert_cmd = container_of(cmd,
 +				struct isert_cmd, iscsi_cmd);
 +	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
  	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	struct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];
  	struct iscsi_reject *hdr =
  		(struct iscsi_reject *)&isert_cmd->tx_desc.iscsi_header;
@@@ -1830,7 -2341,8 +2615,12 @@@ isert_put_text_rsp(struct iscsi_cmd *cm
  	isert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);
  
  	if (txt_rsp_len) {
++<<<<<<< HEAD
 +		struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 		struct isert_device *device = isert_conn->device;
+ 		struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  		struct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];
  		void *txt_rsp_buf = cmd->buf_ptr;
  
@@@ -1855,9 -2367,10 +2645,14 @@@ isert_build_rdma_wr(struct isert_conn *
  		    struct ib_sge *ib_sge, struct ib_send_wr *send_wr,
  		    u32 data_left, u32 offset)
  {
 -	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
 +	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
  	struct scatterlist *sg_start, *tmp_sg;
++<<<<<<< HEAD
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
++=======
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	u32 sg_off, page_off;
  	int i = 0, sg_nents;
  
@@@ -1897,215 -2411,567 +2692,740 @@@
  }
  
  static int
++<<<<<<< HEAD
++=======
+ isert_map_rdma(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+ 	       struct isert_rdma_wr *wr)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+ 	struct isert_conn *isert_conn = conn->context;
+ 	struct isert_data_buf *data = &wr->data;
+ 	struct ib_send_wr *send_wr;
+ 	struct ib_sge *ib_sge;
+ 	u32 offset, data_len, data_left, rdma_write_max, va_offset = 0;
+ 	int ret = 0, i, ib_sge_cnt;
+ 
+ 	isert_cmd->tx_desc.isert_cmd = isert_cmd;
+ 
+ 	offset = wr->iser_ib_op == ISER_IB_RDMA_READ ? cmd->write_data_done : 0;
+ 	ret = isert_map_data_buf(isert_conn, isert_cmd, se_cmd->t_data_sg,
+ 				 se_cmd->t_data_nents, se_cmd->data_length,
+ 				 offset, wr->iser_ib_op, &wr->data);
+ 	if (ret)
+ 		return ret;
+ 
+ 	data_left = data->len;
+ 	offset = data->offset;
+ 
+ 	ib_sge = kzalloc(sizeof(struct ib_sge) * data->nents, GFP_KERNEL);
+ 	if (!ib_sge) {
+ 		isert_warn("Unable to allocate ib_sge\n");
+ 		ret = -ENOMEM;
+ 		goto unmap_cmd;
+ 	}
+ 	wr->ib_sge = ib_sge;
+ 
+ 	wr->send_wr_num = DIV_ROUND_UP(data->nents, isert_conn->max_sge);
+ 	wr->send_wr = kzalloc(sizeof(struct ib_send_wr) * wr->send_wr_num,
+ 				GFP_KERNEL);
+ 	if (!wr->send_wr) {
+ 		isert_dbg("Unable to allocate wr->send_wr\n");
+ 		ret = -ENOMEM;
+ 		goto unmap_cmd;
+ 	}
+ 
+ 	wr->isert_cmd = isert_cmd;
+ 	rdma_write_max = isert_conn->max_sge * PAGE_SIZE;
+ 
+ 	for (i = 0; i < wr->send_wr_num; i++) {
+ 		send_wr = &isert_cmd->rdma_wr.send_wr[i];
+ 		data_len = min(data_left, rdma_write_max);
+ 
+ 		send_wr->send_flags = 0;
+ 		if (wr->iser_ib_op == ISER_IB_RDMA_WRITE) {
+ 			send_wr->opcode = IB_WR_RDMA_WRITE;
+ 			send_wr->wr.rdma.remote_addr = isert_cmd->read_va + offset;
+ 			send_wr->wr.rdma.rkey = isert_cmd->read_stag;
+ 			if (i + 1 == wr->send_wr_num)
+ 				send_wr->next = &isert_cmd->tx_desc.send_wr;
+ 			else
+ 				send_wr->next = &wr->send_wr[i + 1];
+ 		} else {
+ 			send_wr->opcode = IB_WR_RDMA_READ;
+ 			send_wr->wr.rdma.remote_addr = isert_cmd->write_va + va_offset;
+ 			send_wr->wr.rdma.rkey = isert_cmd->write_stag;
+ 			if (i + 1 == wr->send_wr_num)
+ 				send_wr->send_flags = IB_SEND_SIGNALED;
+ 			else
+ 				send_wr->next = &wr->send_wr[i + 1];
+ 		}
+ 
+ 		ib_sge_cnt = isert_build_rdma_wr(isert_conn, isert_cmd, ib_sge,
+ 					send_wr, data_len, offset);
+ 		ib_sge += ib_sge_cnt;
+ 
+ 		offset += data_len;
+ 		va_offset += data_len;
+ 		data_left -= data_len;
+ 	}
+ 
+ 	return 0;
+ unmap_cmd:
+ 	isert_unmap_data_buf(isert_conn, data);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ isert_map_fr_pagelist(struct ib_device *ib_dev,
+ 		      struct scatterlist *sg_start, int sg_nents, u64 *fr_pl)
+ {
+ 	u64 start_addr, end_addr, page, chunk_start = 0;
+ 	struct scatterlist *tmp_sg;
+ 	int i = 0, new_chunk, last_ent, n_pages;
+ 
+ 	n_pages = 0;
+ 	new_chunk = 1;
+ 	last_ent = sg_nents - 1;
+ 	for_each_sg(sg_start, tmp_sg, sg_nents, i) {
+ 		start_addr = ib_sg_dma_address(ib_dev, tmp_sg);
+ 		if (new_chunk)
+ 			chunk_start = start_addr;
+ 		end_addr = start_addr + ib_sg_dma_len(ib_dev, tmp_sg);
+ 
+ 		isert_dbg("SGL[%d] dma_addr: 0x%llx len: %u\n",
+ 			  i, (unsigned long long)tmp_sg->dma_address,
+ 			  tmp_sg->length);
+ 
+ 		if ((end_addr & ~PAGE_MASK) && i < last_ent) {
+ 			new_chunk = 0;
+ 			continue;
+ 		}
+ 		new_chunk = 1;
+ 
+ 		page = chunk_start & PAGE_MASK;
+ 		do {
+ 			fr_pl[n_pages++] = page;
+ 			isert_dbg("Mapped page_list[%d] page_addr: 0x%llx\n",
+ 				  n_pages - 1, page);
+ 			page += PAGE_SIZE;
+ 		} while (page < end_addr);
+ 	}
+ 
+ 	return n_pages;
+ }
+ 
+ static inline void
+ isert_inv_rkey(struct ib_send_wr *inv_wr, struct ib_mr *mr)
+ {
+ 	u32 rkey;
+ 
+ 	memset(inv_wr, 0, sizeof(*inv_wr));
+ 	inv_wr->wr_id = ISER_FASTREG_LI_WRID;
+ 	inv_wr->opcode = IB_WR_LOCAL_INV;
+ 	inv_wr->ex.invalidate_rkey = mr->rkey;
+ 
+ 	/* Bump the key */
+ 	rkey = ib_inc_rkey(mr->rkey);
+ 	ib_update_fast_reg_key(mr, rkey);
+ }
+ 
+ static int
+ isert_fast_reg_mr(struct isert_conn *isert_conn,
+ 		  struct fast_reg_descriptor *fr_desc,
+ 		  struct isert_data_buf *mem,
+ 		  enum isert_indicator ind,
+ 		  struct ib_sge *sge)
+ {
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_device *ib_dev = device->ib_device;
+ 	struct ib_mr *mr;
+ 	struct ib_fast_reg_page_list *frpl;
+ 	struct ib_send_wr fr_wr, inv_wr;
+ 	struct ib_send_wr *bad_wr, *wr = NULL;
+ 	int ret, pagelist_len;
+ 	u32 page_off;
+ 
+ 	if (mem->dma_nents == 1) {
+ 		sge->lkey = device->mr->lkey;
+ 		sge->addr = ib_sg_dma_address(ib_dev, &mem->sg[0]);
+ 		sge->length = ib_sg_dma_len(ib_dev, &mem->sg[0]);
+ 		isert_dbg("sge: addr: 0x%llx  length: %u lkey: %x\n",
+ 			 sge->addr, sge->length, sge->lkey);
+ 		return 0;
+ 	}
+ 
+ 	if (ind == ISERT_DATA_KEY_VALID) {
+ 		/* Registering data buffer */
+ 		mr = fr_desc->data_mr;
+ 		frpl = fr_desc->data_frpl;
+ 	} else {
+ 		/* Registering protection buffer */
+ 		mr = fr_desc->pi_ctx->prot_mr;
+ 		frpl = fr_desc->pi_ctx->prot_frpl;
+ 	}
+ 
+ 	page_off = mem->offset % PAGE_SIZE;
+ 
+ 	isert_dbg("Use fr_desc %p sg_nents %d offset %u\n",
+ 		  fr_desc, mem->nents, mem->offset);
+ 
+ 	pagelist_len = isert_map_fr_pagelist(ib_dev, mem->sg, mem->nents,
+ 					     &frpl->page_list[0]);
+ 
+ 	if (!(fr_desc->ind & ind)) {
+ 		isert_inv_rkey(&inv_wr, mr);
+ 		wr = &inv_wr;
+ 	}
+ 
+ 	/* Prepare FASTREG WR */
+ 	memset(&fr_wr, 0, sizeof(fr_wr));
+ 	fr_wr.wr_id = ISER_FASTREG_LI_WRID;
+ 	fr_wr.opcode = IB_WR_FAST_REG_MR;
+ 	fr_wr.wr.fast_reg.iova_start = frpl->page_list[0] + page_off;
+ 	fr_wr.wr.fast_reg.page_list = frpl;
+ 	fr_wr.wr.fast_reg.page_list_len = pagelist_len;
+ 	fr_wr.wr.fast_reg.page_shift = PAGE_SHIFT;
+ 	fr_wr.wr.fast_reg.length = mem->len;
+ 	fr_wr.wr.fast_reg.rkey = mr->rkey;
+ 	fr_wr.wr.fast_reg.access_flags = IB_ACCESS_LOCAL_WRITE;
+ 
+ 	if (!wr)
+ 		wr = &fr_wr;
+ 	else
+ 		wr->next = &fr_wr;
+ 
+ 	ret = ib_post_send(isert_conn->qp, wr, &bad_wr);
+ 	if (ret) {
+ 		isert_err("fast registration failed, ret:%d\n", ret);
+ 		return ret;
+ 	}
+ 	fr_desc->ind &= ~ind;
+ 
+ 	sge->lkey = mr->lkey;
+ 	sge->addr = frpl->page_list[0] + page_off;
+ 	sge->length = mem->len;
+ 
+ 	isert_dbg("sge: addr: 0x%llx  length: %u lkey: %x\n",
+ 		  sge->addr, sge->length, sge->lkey);
+ 
+ 	return ret;
+ }
+ 
+ static inline void
+ isert_set_dif_domain(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs,
+ 		     struct ib_sig_domain *domain)
+ {
+ 	domain->sig_type = IB_SIG_TYPE_T10_DIF;
+ 	domain->sig.dif.bg_type = IB_T10DIF_CRC;
+ 	domain->sig.dif.pi_interval = se_cmd->se_dev->dev_attrib.block_size;
+ 	domain->sig.dif.ref_tag = se_cmd->reftag_seed;
+ 	/*
+ 	 * At the moment we hard code those, but if in the future
+ 	 * the target core would like to use it, we will take it
+ 	 * from se_cmd.
+ 	 */
+ 	domain->sig.dif.apptag_check_mask = 0xffff;
+ 	domain->sig.dif.app_escape = true;
+ 	domain->sig.dif.ref_escape = true;
+ 	if (se_cmd->prot_type == TARGET_DIF_TYPE1_PROT ||
+ 	    se_cmd->prot_type == TARGET_DIF_TYPE2_PROT)
+ 		domain->sig.dif.ref_remap = true;
+ };
+ 
+ static int
+ isert_set_sig_attrs(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		sig_attrs->mem.sig_type = IB_SIG_TYPE_NONE;
+ 		isert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->wire);
+ 		break;
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 		sig_attrs->wire.sig_type = IB_SIG_TYPE_NONE;
+ 		isert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->mem);
+ 		break;
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		isert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->wire);
+ 		isert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->mem);
+ 		break;
+ 	default:
+ 		isert_err("Unsupported PI operation %d\n", se_cmd->prot_op);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static inline u8
+ isert_set_prot_checks(u8 prot_checks)
+ {
+ 	return (prot_checks & TARGET_DIF_CHECK_GUARD  ? 0xc0 : 0) |
+ 	       (prot_checks & TARGET_DIF_CHECK_REFTAG ? 0x30 : 0) |
+ 	       (prot_checks & TARGET_DIF_CHECK_REFTAG ? 0x0f : 0);
+ }
+ 
+ static int
+ isert_reg_sig_mr(struct isert_conn *isert_conn,
+ 		 struct se_cmd *se_cmd,
+ 		 struct isert_rdma_wr *rdma_wr,
+ 		 struct fast_reg_descriptor *fr_desc)
+ {
+ 	struct ib_send_wr sig_wr, inv_wr;
+ 	struct ib_send_wr *bad_wr, *wr = NULL;
+ 	struct pi_context *pi_ctx = fr_desc->pi_ctx;
+ 	struct ib_sig_attrs sig_attrs;
+ 	int ret;
+ 
+ 	memset(&sig_attrs, 0, sizeof(sig_attrs));
+ 	ret = isert_set_sig_attrs(se_cmd, &sig_attrs);
+ 	if (ret)
+ 		goto err;
+ 
+ 	sig_attrs.check_mask = isert_set_prot_checks(se_cmd->prot_checks);
+ 
+ 	if (!(fr_desc->ind & ISERT_SIG_KEY_VALID)) {
+ 		isert_inv_rkey(&inv_wr, pi_ctx->sig_mr);
+ 		wr = &inv_wr;
+ 	}
+ 
+ 	memset(&sig_wr, 0, sizeof(sig_wr));
+ 	sig_wr.opcode = IB_WR_REG_SIG_MR;
+ 	sig_wr.wr_id = ISER_FASTREG_LI_WRID;
+ 	sig_wr.sg_list = &rdma_wr->ib_sg[DATA];
+ 	sig_wr.num_sge = 1;
+ 	sig_wr.wr.sig_handover.access_flags = IB_ACCESS_LOCAL_WRITE;
+ 	sig_wr.wr.sig_handover.sig_attrs = &sig_attrs;
+ 	sig_wr.wr.sig_handover.sig_mr = pi_ctx->sig_mr;
+ 	if (se_cmd->t_prot_sg)
+ 		sig_wr.wr.sig_handover.prot = &rdma_wr->ib_sg[PROT];
+ 
+ 	if (!wr)
+ 		wr = &sig_wr;
+ 	else
+ 		wr->next = &sig_wr;
+ 
+ 	ret = ib_post_send(isert_conn->qp, wr, &bad_wr);
+ 	if (ret) {
+ 		isert_err("fast registration failed, ret:%d\n", ret);
+ 		goto err;
+ 	}
+ 	fr_desc->ind &= ~ISERT_SIG_KEY_VALID;
+ 
+ 	rdma_wr->ib_sg[SIG].lkey = pi_ctx->sig_mr->lkey;
+ 	rdma_wr->ib_sg[SIG].addr = 0;
+ 	rdma_wr->ib_sg[SIG].length = se_cmd->data_length;
+ 	if (se_cmd->prot_op != TARGET_PROT_DIN_STRIP &&
+ 	    se_cmd->prot_op != TARGET_PROT_DOUT_INSERT)
+ 		/*
+ 		 * We have protection guards on the wire
+ 		 * so we need to set a larget transfer
+ 		 */
+ 		rdma_wr->ib_sg[SIG].length += se_cmd->prot_length;
+ 
+ 	isert_dbg("sig_sge: addr: 0x%llx  length: %u lkey: %x\n",
+ 		  rdma_wr->ib_sg[SIG].addr, rdma_wr->ib_sg[SIG].length,
+ 		  rdma_wr->ib_sg[SIG].lkey);
+ err:
+ 	return ret;
+ }
+ 
+ static int
+ isert_handle_prot_cmd(struct isert_conn *isert_conn,
+ 		      struct isert_cmd *isert_cmd,
+ 		      struct isert_rdma_wr *wr)
+ {
+ 	struct isert_device *device = isert_conn->device;
+ 	struct se_cmd *se_cmd = &isert_cmd->iscsi_cmd->se_cmd;
+ 	int ret;
+ 
+ 	if (!wr->fr_desc->pi_ctx) {
+ 		ret = isert_create_pi_ctx(wr->fr_desc,
+ 					  device->ib_device,
+ 					  device->pd);
+ 		if (ret) {
+ 			isert_err("conn %p failed to allocate pi_ctx\n",
+ 				  isert_conn);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (se_cmd->t_prot_sg) {
+ 		ret = isert_map_data_buf(isert_conn, isert_cmd,
+ 					 se_cmd->t_prot_sg,
+ 					 se_cmd->t_prot_nents,
+ 					 se_cmd->prot_length,
+ 					 0, wr->iser_ib_op, &wr->prot);
+ 		if (ret) {
+ 			isert_err("conn %p failed to map protection buffer\n",
+ 				  isert_conn);
+ 			return ret;
+ 		}
+ 
+ 		memset(&wr->ib_sg[PROT], 0, sizeof(wr->ib_sg[PROT]));
+ 		ret = isert_fast_reg_mr(isert_conn, wr->fr_desc, &wr->prot,
+ 					ISERT_PROT_KEY_VALID, &wr->ib_sg[PROT]);
+ 		if (ret) {
+ 			isert_err("conn %p failed to fast reg mr\n",
+ 				  isert_conn);
+ 			goto unmap_prot_cmd;
+ 		}
+ 	}
+ 
+ 	ret = isert_reg_sig_mr(isert_conn, se_cmd, wr, wr->fr_desc);
+ 	if (ret) {
+ 		isert_err("conn %p failed to fast reg mr\n",
+ 			  isert_conn);
+ 		goto unmap_prot_cmd;
+ 	}
+ 	wr->fr_desc->ind |= ISERT_PROTECTED;
+ 
+ 	return 0;
+ 
+ unmap_prot_cmd:
+ 	if (se_cmd->t_prot_sg)
+ 		isert_unmap_data_buf(isert_conn, &wr->prot);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ isert_reg_rdma(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+ 	       struct isert_rdma_wr *wr)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+ 	struct isert_conn *isert_conn = conn->context;
+ 	struct fast_reg_descriptor *fr_desc = NULL;
+ 	struct ib_send_wr *send_wr;
+ 	struct ib_sge *ib_sg;
+ 	u32 offset;
+ 	int ret = 0;
+ 	unsigned long flags;
+ 
+ 	isert_cmd->tx_desc.isert_cmd = isert_cmd;
+ 
+ 	offset = wr->iser_ib_op == ISER_IB_RDMA_READ ? cmd->write_data_done : 0;
+ 	ret = isert_map_data_buf(isert_conn, isert_cmd, se_cmd->t_data_sg,
+ 				 se_cmd->t_data_nents, se_cmd->data_length,
+ 				 offset, wr->iser_ib_op, &wr->data);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (wr->data.dma_nents != 1 || isert_prot_cmd(isert_conn, se_cmd)) {
+ 		spin_lock_irqsave(&isert_conn->pool_lock, flags);
+ 		fr_desc = list_first_entry(&isert_conn->fr_pool,
+ 					   struct fast_reg_descriptor, list);
+ 		list_del(&fr_desc->list);
+ 		spin_unlock_irqrestore(&isert_conn->pool_lock, flags);
+ 		wr->fr_desc = fr_desc;
+ 	}
+ 
+ 	ret = isert_fast_reg_mr(isert_conn, fr_desc, &wr->data,
+ 				ISERT_DATA_KEY_VALID, &wr->ib_sg[DATA]);
+ 	if (ret)
+ 		goto unmap_cmd;
+ 
+ 	if (isert_prot_cmd(isert_conn, se_cmd)) {
+ 		ret = isert_handle_prot_cmd(isert_conn, isert_cmd, wr);
+ 		if (ret)
+ 			goto unmap_cmd;
+ 
+ 		ib_sg = &wr->ib_sg[SIG];
+ 	} else {
+ 		ib_sg = &wr->ib_sg[DATA];
+ 	}
+ 
+ 	memcpy(&wr->s_ib_sge, ib_sg, sizeof(*ib_sg));
+ 	wr->ib_sge = &wr->s_ib_sge;
+ 	wr->send_wr_num = 1;
+ 	memset(&wr->s_send_wr, 0, sizeof(*send_wr));
+ 	wr->send_wr = &wr->s_send_wr;
+ 	wr->isert_cmd = isert_cmd;
+ 
+ 	send_wr = &isert_cmd->rdma_wr.s_send_wr;
+ 	send_wr->sg_list = &wr->s_ib_sge;
+ 	send_wr->num_sge = 1;
+ 	send_wr->wr_id = (uintptr_t)&isert_cmd->tx_desc;
+ 	if (wr->iser_ib_op == ISER_IB_RDMA_WRITE) {
+ 		send_wr->opcode = IB_WR_RDMA_WRITE;
+ 		send_wr->wr.rdma.remote_addr = isert_cmd->read_va;
+ 		send_wr->wr.rdma.rkey = isert_cmd->read_stag;
+ 		send_wr->send_flags = !isert_prot_cmd(isert_conn, se_cmd) ?
+ 				      0 : IB_SEND_SIGNALED;
+ 	} else {
+ 		send_wr->opcode = IB_WR_RDMA_READ;
+ 		send_wr->wr.rdma.remote_addr = isert_cmd->write_va;
+ 		send_wr->wr.rdma.rkey = isert_cmd->write_stag;
+ 		send_wr->send_flags = IB_SEND_SIGNALED;
+ 	}
+ 
+ 	return 0;
+ 
+ unmap_cmd:
+ 	if (fr_desc) {
+ 		spin_lock_irqsave(&isert_conn->pool_lock, flags);
+ 		list_add_tail(&fr_desc->list, &isert_conn->fr_pool);
+ 		spin_unlock_irqrestore(&isert_conn->pool_lock, flags);
+ 	}
+ 	isert_unmap_data_buf(isert_conn, &wr->data);
+ 
+ 	return ret;
+ }
+ 
+ static int
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  isert_put_datain(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
  {
  	struct se_cmd *se_cmd = &cmd->se_cmd;
 -	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
 +	struct isert_cmd *isert_cmd = container_of(cmd,
 +					struct isert_cmd, iscsi_cmd);
  	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
++<<<<<<< HEAD
 +	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 +	struct ib_send_wr *wr_failed, *send_wr;
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 +	struct ib_sge *ib_sge;
 +	struct scatterlist *sg;
 +	u32 offset = 0, data_len, data_left, rdma_write_max;
 +	int rc, ret = 0, count, sg_nents, i, ib_sge_cnt;
++=======
+ 	struct isert_conn *isert_conn = conn->context;
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_send_wr *wr_failed;
+ 	int rc;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	isert_dbg("Cmd: %p RDMA_WRITE data_length: %u\n",
 -		 isert_cmd, se_cmd->data_length);
 +	pr_debug("RDMA_WRITE: data_length: %u\n", se_cmd->data_length);
  
 -	wr->iser_ib_op = ISER_IB_RDMA_WRITE;
 -	rc = device->reg_rdma_mem(conn, cmd, wr);
 -	if (rc) {
 -		isert_err("Cmd: %p failed to prepare RDMA res\n", isert_cmd);
 -		return rc;
 +	sg = &se_cmd->t_data_sg[0];
 +	sg_nents = se_cmd->t_data_nents;
 +
 +	count = ib_dma_map_sg(ib_dev, sg, sg_nents, DMA_TO_DEVICE);
 +	if (unlikely(!count)) {
 +		pr_err("Unable to map put_datain SGs\n");
 +		return -EINVAL;
  	}
 +	wr->sge = sg;
 +	wr->num_sge = sg_nents;
 +	pr_debug("Mapped IB count: %u sg: %p sg_nents: %u for RDMA_WRITE\n",
 +		 count, sg, sg_nents);
  
 -	if (!isert_prot_cmd(isert_conn, se_cmd)) {
 -		/*
 -		 * Build isert_conn->tx_desc for iSCSI response PDU and attach
 -		 */
 -		isert_create_send_desc(isert_conn, isert_cmd,
 -				       &isert_cmd->tx_desc);
 -		iscsit_build_rsp_pdu(cmd, conn, true, (struct iscsi_scsi_rsp *)
 -				     &isert_cmd->tx_desc.iscsi_header);
 -		isert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);
 -		isert_init_send_wr(isert_conn, isert_cmd,
 -				   &isert_cmd->tx_desc.send_wr);
 -		isert_cmd->rdma_wr.s_send_wr.next = &isert_cmd->tx_desc.send_wr;
 -		wr->send_wr_num += 1;
 +	ib_sge = kzalloc(sizeof(struct ib_sge) * sg_nents, GFP_KERNEL);
 +	if (!ib_sge) {
 +		pr_warn("Unable to allocate datain ib_sge\n");
 +		ret = -ENOMEM;
 +		goto unmap_sg;
  	}
 +	isert_cmd->ib_sge = ib_sge;
 +
 +	pr_debug("Allocated ib_sge: %p from t_data_ents: %d for RDMA_WRITE\n",
 +		 ib_sge, se_cmd->t_data_nents);
 +
 +	wr->send_wr_num = DIV_ROUND_UP(sg_nents, isert_conn->max_sge);
 +	wr->send_wr = kzalloc(sizeof(struct ib_send_wr) * wr->send_wr_num,
 +				GFP_KERNEL);
 +	if (!wr->send_wr) {
 +		pr_err("Unable to allocate wr->send_wr\n");
 +		ret = -ENOMEM;
 +		goto unmap_sg;
 +	}
 +	pr_debug("Allocated wr->send_wr: %p wr->send_wr_num: %u\n",
 +		 wr->send_wr, wr->send_wr_num);
 +
 +	iscsit_increment_maxcmdsn(cmd, conn->sess);
 +	cmd->stat_sn = conn->stat_sn++;
 +
 +	wr->isert_cmd = isert_cmd;
 +	rdma_write_max = isert_conn->max_sge * PAGE_SIZE;
 +	data_left = se_cmd->data_length;
 +
 +	for (i = 0; i < wr->send_wr_num; i++) {
 +		send_wr = &isert_cmd->rdma_wr.send_wr[i];
 +		data_len = min(data_left, rdma_write_max);
  
 +		send_wr->opcode = IB_WR_RDMA_WRITE;
 +		send_wr->send_flags = 0;
 +		send_wr->wr.rdma.remote_addr = isert_cmd->read_va + offset;
 +		send_wr->wr.rdma.rkey = isert_cmd->read_stag;
 +
 +		ib_sge_cnt = isert_build_rdma_wr(isert_conn, isert_cmd, ib_sge,
 +					send_wr, data_len, offset);
 +		ib_sge += ib_sge_cnt;
 +
 +		if (i + 1 == wr->send_wr_num)
 +			send_wr->next = &isert_cmd->tx_desc.send_wr;
 +		else
 +			send_wr->next = &wr->send_wr[i + 1];
 +
 +		offset += data_len;
 +		data_left -= data_len;
 +	}
 +	/*
 +	 * Build isert_conn->tx_desc for iSCSI response PDU and attach
 +	 */
 +	isert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);
 +	iscsit_build_rsp_pdu(cmd, conn, false, (struct iscsi_scsi_rsp *)
 +			     &isert_cmd->tx_desc.iscsi_header);
 +	isert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);
 +	isert_init_send_wr(isert_cmd, &isert_cmd->tx_desc.send_wr);
 +
 +	atomic_add(wr->send_wr_num + 1, &isert_conn->post_send_buf_count);
 +
++<<<<<<< HEAD
 +	rc = ib_post_send(isert_conn->conn_qp, wr->send_wr, &wr_failed);
 +	if (rc) {
 +		pr_warn("ib_post_send() failed for IB_WR_RDMA_WRITE\n");
 +		atomic_sub(wr->send_wr_num + 1, &isert_conn->post_send_buf_count);
 +	}
 +	pr_debug("Posted RDMA_WRITE + Response for iSER Data READ\n");
++=======
+ 	rc = ib_post_send(isert_conn->qp, wr->send_wr, &wr_failed);
+ 	if (rc)
+ 		isert_warn("ib_post_send() failed for IB_WR_RDMA_WRITE\n");
+ 
+ 	if (!isert_prot_cmd(isert_conn, se_cmd))
+ 		isert_dbg("Cmd: %p posted RDMA_WRITE + Response for iSER Data "
+ 			 "READ\n", isert_cmd);
+ 	else
+ 		isert_dbg("Cmd: %p posted RDMA_WRITE for iSER Data READ\n",
+ 			 isert_cmd);
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	return 1;
 +
 +unmap_sg:
 +	ib_dma_unmap_sg(ib_dev, sg, sg_nents, DMA_TO_DEVICE);
 +	return ret;
  }
  
  static int
  isert_get_dataout(struct iscsi_conn *conn, struct iscsi_cmd *cmd, bool recovery)
  {
  	struct se_cmd *se_cmd = &cmd->se_cmd;
 -	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
 +	struct isert_cmd *isert_cmd = container_of(cmd,
 +					struct isert_cmd, iscsi_cmd);
  	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
++<<<<<<< HEAD
 +	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 +	struct ib_send_wr *wr_failed, *send_wr;
 +	struct ib_sge *ib_sge;
 +	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 +	struct scatterlist *sg_start;
 +	u32 sg_off, sg_nents, page_off, va_offset = 0;
 +	u32 offset = 0, data_len, data_left, rdma_write_max;
 +	int rc, ret = 0, count, i, ib_sge_cnt;
 +
 +	pr_debug("RDMA_READ: data_length: %u write_data_done: %u\n",
 +		 se_cmd->data_length, cmd->write_data_done);
 +
 +	sg_off = cmd->write_data_done / PAGE_SIZE;
 +	sg_start = &cmd->se_cmd.t_data_sg[sg_off];
 +	page_off = cmd->write_data_done % PAGE_SIZE;
 +
 +	pr_debug("RDMA_READ: sg_off: %d, sg_start: %p page_off: %d\n",
 +		 sg_off, sg_start, page_off);
 +
 +	data_left = se_cmd->data_length - cmd->write_data_done;
 +	sg_nents = se_cmd->t_data_nents - sg_off;
 +
 +	pr_debug("RDMA_READ: data_left: %d, sg_nents: %d\n",
 +		 data_left, sg_nents);
 +
 +	count = ib_dma_map_sg(ib_dev, sg_start, sg_nents, DMA_FROM_DEVICE);
 +	if (unlikely(!count)) {
 +		pr_err("Unable to map get_dataout SGs\n");
 +		return -EINVAL;
 +	}
 +	wr->sge = sg_start;
 +	wr->num_sge = sg_nents;
 +	pr_debug("Mapped IB count: %u sg_start: %p sg_nents: %u for RDMA_READ\n",
 +		 count, sg_start, sg_nents);
 +
 +	ib_sge = kzalloc(sizeof(struct ib_sge) * sg_nents, GFP_KERNEL);
 +	if (!ib_sge) {
 +		pr_warn("Unable to allocate dataout ib_sge\n");
 +		ret = -ENOMEM;
 +		goto unmap_sg;
 +	}
 +	isert_cmd->ib_sge = ib_sge;
 +
 +	pr_debug("Using ib_sge: %p from sg_ents: %d for RDMA_READ\n",
 +		 ib_sge, sg_nents);
 +
 +	wr->send_wr_num = DIV_ROUND_UP(sg_nents, isert_conn->max_sge);
 +	wr->send_wr = kzalloc(sizeof(struct ib_send_wr) * wr->send_wr_num,
 +				GFP_KERNEL);
 +	if (!wr->send_wr) {
 +		pr_debug("Unable to allocate wr->send_wr\n");
 +		ret = -ENOMEM;
 +		goto unmap_sg;
 +	}
 +	pr_debug("Allocated wr->send_wr: %p wr->send_wr_num: %u\n",
 +		 wr->send_wr, wr->send_wr_num);
 +
 +	isert_cmd->tx_desc.isert_cmd = isert_cmd;
++=======
+ 	struct isert_conn *isert_conn = conn->context;
+ 	struct isert_device *device = isert_conn->device;
+ 	struct ib_send_wr *wr_failed;
+ 	int rc;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	isert_dbg("Cmd: %p RDMA_READ data_length: %u write_data_done: %u\n",
 -		 isert_cmd, se_cmd->data_length, cmd->write_data_done);
  	wr->iser_ib_op = ISER_IB_RDMA_READ;
 -	rc = device->reg_rdma_mem(conn, cmd, wr);
 -	if (rc) {
 -		isert_err("Cmd: %p failed to prepare RDMA res\n", isert_cmd);
 -		return rc;
 +	wr->isert_cmd = isert_cmd;
 +	rdma_write_max = isert_conn->max_sge * PAGE_SIZE;
 +	offset = cmd->write_data_done;
 +
 +	for (i = 0; i < wr->send_wr_num; i++) {
 +		send_wr = &isert_cmd->rdma_wr.send_wr[i];
 +		data_len = min(data_left, rdma_write_max);
 +
 +		send_wr->opcode = IB_WR_RDMA_READ;
 +		send_wr->wr.rdma.remote_addr = isert_cmd->write_va + va_offset;
 +		send_wr->wr.rdma.rkey = isert_cmd->write_stag;
 +
 +		ib_sge_cnt = isert_build_rdma_wr(isert_conn, isert_cmd, ib_sge,
 +					send_wr, data_len, offset);
 +		ib_sge += ib_sge_cnt;
 +
 +		if (i + 1 == wr->send_wr_num)
 +			send_wr->send_flags = IB_SEND_SIGNALED;
 +		else
 +			send_wr->next = &wr->send_wr[i + 1];
 +
 +		offset += data_len;
 +		va_offset += data_len;
 +		data_left -= data_len;
  	}
  
++<<<<<<< HEAD
 +	atomic_add(wr->send_wr_num, &isert_conn->post_send_buf_count);
 +
 +	rc = ib_post_send(isert_conn->conn_qp, wr->send_wr, &wr_failed);
 +	if (rc) {
 +		pr_warn("ib_post_send() failed for IB_WR_RDMA_READ\n");
 +		atomic_sub(wr->send_wr_num, &isert_conn->post_send_buf_count);
 +	}
 +	pr_debug("Posted RDMA_READ memory for ISER Data WRITE\n");
++=======
+ 	rc = ib_post_send(isert_conn->qp, wr->send_wr, &wr_failed);
+ 	if (rc)
+ 		isert_warn("ib_post_send() failed for IB_WR_RDMA_READ\n");
+ 
+ 	isert_dbg("Cmd: %p posted RDMA_READ memory for ISER Data WRITE\n",
+ 		 isert_cmd);
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	return 0;
 +
 +unmap_sg:
 +	ib_dma_unmap_sg(ib_dev, sg_start, sg_nents, DMA_FROM_DEVICE);
 +	return ret;
  }
  
  static int
@@@ -2258,12 -3138,31 +3578,28 @@@ isert_rdma_accept(struct isert_conn *is
  static int
  isert_get_login_rx(struct iscsi_conn *conn, struct iscsi_login *login)
  {
 -	struct isert_conn *isert_conn = conn->context;
 +	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
  	int ret;
  
 -	isert_info("before login_req comp conn: %p\n", isert_conn);
 -	ret = wait_for_completion_interruptible(&isert_conn->login_req_comp);
 -	if (ret) {
 -		isert_err("isert_conn %p interrupted before got login req\n",
 -			  isert_conn);
 -		return ret;
 -	}
 -	reinit_completion(&isert_conn->login_req_comp);
 +	pr_debug("isert_get_login_rx before conn_login_comp conn: %p\n", conn);
  
++<<<<<<< HEAD
 +	ret = wait_for_completion_interruptible(&isert_conn->conn_login_comp);
++=======
+ 	/*
+ 	 * For login requests after the first PDU, isert_rx_login_req() will
+ 	 * kick schedule_delayed_work(&conn->login_work) as the packet is
+ 	 * received, which turns this callback from iscsi_target_do_login_rx()
+ 	 * into a NOP.
+ 	 */
+ 	if (!login->first_request)
+ 		return 0;
+ 
+ 	isert_rx_login_req(isert_conn);
+ 
+ 	isert_info("before login_comp conn: %p\n", conn);
+ 	ret = wait_for_completion_interruptible(&isert_conn->login_comp);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	if (ret)
  		return ret;
  
@@@ -2362,40 -3253,121 +3698,138 @@@ accept_wait
  static void
  isert_free_np(struct iscsi_np *np)
  {
 -	struct isert_np *isert_np = np->np_context;
 -	struct isert_conn *isert_conn, *n;
 +	struct isert_np *isert_np = (struct isert_np *)np->np_context;
  
++<<<<<<< HEAD
 +	rdma_destroy_id(isert_np->np_cm_id);
++=======
+ 	if (isert_np->np_cm_id)
+ 		rdma_destroy_id(isert_np->np_cm_id);
+ 
+ 	/*
+ 	 * FIXME: At this point we don't have a good way to insure
+ 	 * that at this point we don't have hanging connections that
+ 	 * completed RDMA establishment but didn't start iscsi login
+ 	 * process. So work-around this by cleaning up what ever piled
+ 	 * up in np_accept_list.
+ 	 */
+ 	mutex_lock(&isert_np->np_accept_mutex);
+ 	if (!list_empty(&isert_np->np_accept_list)) {
+ 		isert_info("Still have isert connections, cleaning up...\n");
+ 		list_for_each_entry_safe(isert_conn, n,
+ 					 &isert_np->np_accept_list,
+ 					 accept_node) {
+ 			isert_info("cleaning isert_conn %p state (%d)\n",
+ 				   isert_conn, isert_conn->state);
+ 			isert_connect_release(isert_conn);
+ 		}
+ 	}
+ 	mutex_unlock(&isert_np->np_accept_mutex);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
  	np->np_context = NULL;
  	kfree(isert_np);
  }
  
++<<<<<<< HEAD
++=======
+ static void isert_release_work(struct work_struct *work)
+ {
+ 	struct isert_conn *isert_conn = container_of(work,
+ 						     struct isert_conn,
+ 						     release_work);
+ 
+ 	isert_info("Starting release conn %p\n", isert_conn);
+ 
+ 	wait_for_completion(&isert_conn->wait);
+ 
+ 	mutex_lock(&isert_conn->mutex);
+ 	isert_conn->state = ISER_CONN_DOWN;
+ 	mutex_unlock(&isert_conn->mutex);
+ 
+ 	isert_info("Destroying conn %p\n", isert_conn);
+ 	isert_put_conn(isert_conn);
+ }
+ 
+ static void
+ isert_wait4logout(struct isert_conn *isert_conn)
+ {
+ 	struct iscsi_conn *conn = isert_conn->conn;
+ 
+ 	isert_info("conn %p\n", isert_conn);
+ 
+ 	if (isert_conn->logout_posted) {
+ 		isert_info("conn %p wait for conn_logout_comp\n", isert_conn);
+ 		wait_for_completion_timeout(&conn->conn_logout_comp,
+ 					    SECONDS_FOR_LOGOUT_COMP * HZ);
+ 	}
+ }
+ 
+ static void
+ isert_wait4cmds(struct iscsi_conn *conn)
+ {
+ 	isert_info("iscsi_conn %p\n", conn);
+ 
+ 	if (conn->sess) {
+ 		target_sess_cmd_list_set_waiting(conn->sess->se_sess);
+ 		target_wait_for_sess_cmds(conn->sess->se_sess);
+ 	}
+ }
+ 
+ static void
+ isert_wait4flush(struct isert_conn *isert_conn)
+ {
+ 	struct ib_recv_wr *bad_wr;
+ 
+ 	isert_info("conn %p\n", isert_conn);
+ 
+ 	init_completion(&isert_conn->wait_comp_err);
+ 	isert_conn->beacon.wr_id = ISER_BEACON_WRID;
+ 	/* post an indication that all flush errors were consumed */
+ 	if (ib_post_recv(isert_conn->qp, &isert_conn->beacon, &bad_wr)) {
+ 		isert_err("conn %p failed to post beacon", isert_conn);
+ 		return;
+ 	}
+ 
+ 	wait_for_completion(&isert_conn->wait_comp_err);
+ }
+ 
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  static void isert_wait_conn(struct iscsi_conn *conn)
  {
  	struct isert_conn *isert_conn = conn->context;
  
 -	isert_info("Starting conn %p\n", isert_conn);
 +	pr_debug("isert_wait_conn: Starting \n");
  
++<<<<<<< HEAD
 +	mutex_lock(&isert_conn->conn_mutex);
 +	if (isert_conn->conn_cm_id) {
 +		pr_debug("Calling rdma_disconnect from isert_wait_conn\n");
 +		rdma_disconnect(isert_conn->conn_cm_id);
 +	}
++=======
+ 	mutex_lock(&isert_conn->mutex);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  	/*
- 	 * Only wait for conn_wait_comp_err if the isert_conn made it
+ 	 * Only wait for wait_comp_err if the isert_conn made it
  	 * into full feature phase..
  	 */
  	if (isert_conn->state == ISER_CONN_INIT) {
- 		mutex_unlock(&isert_conn->conn_mutex);
+ 		mutex_unlock(&isert_conn->mutex);
  		return;
  	}
++<<<<<<< HEAD
 +	if (isert_conn->state == ISER_CONN_UP)
 +		isert_conn->state = ISER_CONN_TERMINATING;
 +	mutex_unlock(&isert_conn->conn_mutex);
++=======
+ 	isert_conn_terminate(isert_conn);
+ 	mutex_unlock(&isert_conn->mutex);
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  
 -	isert_wait4cmds(conn);
 -	isert_wait4flush(isert_conn);
 -	isert_wait4logout(isert_conn);
 +	wait_for_completion(&isert_conn->conn_wait_comp_err);
  
 -	INIT_WORK(&isert_conn->release_work, isert_release_work);
 -	queue_work(isert_release_wq, &isert_conn->release_work);
 +	wait_for_completion(&isert_conn->conn_wait);
  }
  
  static void isert_free_conn(struct iscsi_conn *conn)
diff --cc drivers/infiniband/ulp/isert/ib_isert.h
index 1964470480ac,9ec23a786c02..000000000000
--- a/drivers/infiniband/ulp/isert/ib_isert.h
+++ b/drivers/infiniband/ulp/isert/ib_isert.h
@@@ -87,25 -157,30 +87,46 @@@ struct isert_conn 
  	char			*login_req_buf;
  	char			*login_rsp_buf;
  	u64			login_req_dma;
 -	int			login_req_len;
  	u64			login_rsp_dma;
- 	unsigned int		conn_rx_desc_head;
- 	struct iser_rx_desc	*conn_rx_descs;
- 	struct ib_recv_wr	conn_rx_wr[ISERT_MIN_POSTED_RX];
+ 	unsigned int		rx_desc_head;
+ 	struct iser_rx_desc	*rx_descs;
+ 	struct ib_recv_wr	rx_wr[ISERT_MIN_POSTED_RX];
  	struct iscsi_conn	*conn;
++<<<<<<< HEAD
 +	struct list_head	conn_accept_node;
 +	struct completion	conn_login_comp;
 +	struct iser_tx_desc	conn_login_tx_desc;
 +	struct rdma_cm_id	*conn_cm_id;
 +	struct ib_pd		*conn_pd;
 +	struct ib_mr		*conn_mr;
 +	struct ib_qp		*conn_qp;
 +	struct isert_device	*conn_device;
 +	struct work_struct	conn_logout_work;
 +	struct mutex		conn_mutex;
 +	struct completion	conn_wait;
 +	struct completion	conn_wait_comp_err;
 +	struct kref		conn_kref;
 +	bool			disconnect;
++=======
+ 	struct list_head	accept_node;
+ 	struct completion	login_comp;
+ 	struct completion	login_req_comp;
+ 	struct iser_tx_desc	login_tx_desc;
+ 	struct rdma_cm_id	*cm_id;
+ 	struct ib_qp		*qp;
+ 	struct isert_device	*device;
+ 	struct mutex		mutex;
+ 	struct completion	wait;
+ 	struct completion	wait_comp_err;
+ 	struct kref		kref;
+ 	struct list_head	fr_pool;
+ 	int			fr_pool_size;
+ 	/* lock to protect fastreg pool */
+ 	spinlock_t		pool_lock;
+ 	struct work_struct	release_work;
+ 	struct ib_recv_wr       beacon;
+ 	bool                    logout_posted;
++>>>>>>> dac6ab305d73 (iser-target: Remove conn_ prefix from struct isert_conn members)
  };
  
  #define ISERT_MAX_CQ 64
* Unmerged path drivers/infiniband/ulp/isert/ib_isert.c
* Unmerged path drivers/infiniband/ulp/isert/ib_isert.h
