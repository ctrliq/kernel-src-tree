swiotlb: remove alloc_size argument to swiotlb_tbl_map_single()

jira LE-1907
cve CVE-2024-35814
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Michael Kelley <mhklinux@outlook.com>
commit 327e2c97c46a4d971c5450a9d05b4a673f46c4da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/327e2c97.failed

Currently swiotlb_tbl_map_single() takes alloc_align_mask and
alloc_size arguments to specify an swiotlb allocation that is larger
than mapping_size.  This larger allocation is used solely by
iommu_dma_map_single() to handle untrusted devices that should not have
DMA visibility to memory pages that are partially used for unrelated
kernel data.

Having two arguments to specify the allocation is redundant. While
alloc_align_mask naturally specifies the alignment of the starting
address of the allocation, it can also implicitly specify the size
by rounding up the mapping_size to that alignment.

Additionally, the current approach has an edge case bug.
iommu_dma_map_page() already does the rounding up to compute the
alloc_size argument. But swiotlb_tbl_map_single() then calculates the
alignment offset based on the DMA min_align_mask, and adds that offset to
alloc_size. If the offset is non-zero, the addition may result in a value
that is larger than the max the swiotlb can allocate.  If the rounding up
is done _after_ the alignment offset is added to the mapping_size (and
the original mapping_size conforms to the value returned by
swiotlb_max_mapping_size), then the max that the swiotlb can allocate
will not be exceeded.

In view of these issues, simplify the swiotlb_tbl_map_single() interface
by removing the alloc_size argument. Most call sites pass the same value
for mapping_size and alloc_size, and they pass alloc_align_mask as zero.
Just remove the redundant argument from these callers, as they will see
no functional change. For iommu_dma_map_page() also remove the alloc_size
argument, and have swiotlb_tbl_map_single() compute the alloc_size by
rounding up mapping_size after adding the offset based on min_align_mask.
This has the side effect of fixing the edge case bug but with no other
functional change.

Also add a sanity test on the alloc_align_mask. While IOMMU code
currently ensures the granule is not larger than PAGE_SIZE, if that
guarantee were to be removed in the future, the downstream effect on the
swiotlb might go unnoticed until strange allocation failures occurred.

Tested on an ARM64 system with 16K page size and some kernel test-only
hackery to allow modifying the DMA min_align_mask and the granule size
that becomes the alloc_align_mask. Tested these combinations with a
variety of original memory addresses and sizes, including those that
reproduce the edge case bug:

 * 4K granule and 0 min_align_mask
 * 4K granule and 0xFFF min_align_mask (4K - 1)
 * 16K granule and 0xFFF min_align_mask
 * 64K granule and 0xFFF min_align_mask
 * 64K granule and 0x3FFF min_align_mask (16K - 1)

With the changes, all combinations pass.

	Signed-off-by: Michael Kelley <mhklinux@outlook.com>
	Reviewed-by: Petr Tesarik <petr@tesarici.cz>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 327e2c97c46a4d971c5450a9d05b4a673f46c4da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/swiotlb.c
diff --cc kernel/dma/swiotlb.c
index c0e227dcb45e,046da973a7e2..000000000000
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@@ -713,16 -1312,71 +713,72 @@@ static unsigned long mem_used(struct io
  	return used;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mem_used() - get number of used slots in an allocator
+  * @mem:	Software IO TLB allocator.
+  *
+  * The result is not accurate, because there is no locking of individual
+  * areas.
+  *
+  * Return: Approximate number of used slots.
+  */
+ static unsigned long mem_used(struct io_tlb_mem *mem)
+ {
+ #ifdef CONFIG_SWIOTLB_DYNAMIC
+ 	struct io_tlb_pool *pool;
+ 	unsigned long used = 0;
+ 
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(pool, &mem->pools, node)
+ 		used += mem_pool_used(pool);
+ 	rcu_read_unlock();
+ 
+ 	return used;
+ #else
+ 	return mem_pool_used(&mem->defpool);
+ #endif
+ }
+ 
+ #endif /* CONFIG_DEBUG_FS */
+ 
+ /**
+  * swiotlb_tbl_map_single() - bounce buffer map a single contiguous physical area
+  * @dev:		Device which maps the buffer.
+  * @orig_addr:		Original (non-bounced) physical IO buffer address
+  * @mapping_size:	Requested size of the actual bounce buffer, excluding
+  *			any pre- or post-padding for alignment
+  * @alloc_align_mask:	Required start and end alignment of the allocated buffer
+  * @dir:		DMA direction
+  * @attrs:		Optional DMA attributes for the map operation
+  *
+  * Find and allocate a suitable sequence of IO TLB slots for the request.
+  * The allocated space starts at an alignment specified by alloc_align_mask,
+  * and the size of the allocated space is rounded up so that the total amount
+  * of allocated space is a multiple of (alloc_align_mask + 1). If
+  * alloc_align_mask is zero, the allocated space may be at any alignment and
+  * the size is not rounded up.
+  *
+  * The returned address is within the allocated space and matches the bits
+  * of orig_addr that are specified in the DMA min_align_mask for the device. As
+  * such, this returned address may be offset from the beginning of the allocated
+  * space. The bounce buffer space starting at the returned address for
+  * mapping_size bytes is initialized to the contents of the original IO buffer
+  * area. Any pre-padding (due to an offset) and any post-padding (due to
+  * rounding-up the size) is not initialized.
+  */
++>>>>>>> 327e2c97c46a (swiotlb: remove alloc_size argument to swiotlb_tbl_map_single())
  phys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,
- 		size_t mapping_size, size_t alloc_size,
- 		unsigned int alloc_align_mask, enum dma_data_direction dir,
- 		unsigned long attrs)
+ 		size_t mapping_size, unsigned int alloc_align_mask,
+ 		enum dma_data_direction dir, unsigned long attrs)
  {
  	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
 -	unsigned int offset;
 -	struct io_tlb_pool *pool;
 +	unsigned int offset = swiotlb_align_offset(dev, orig_addr);
  	unsigned int i;
+ 	size_t size;
  	int index;
  	phys_addr_t tlb_addr;
 -	unsigned short pad_slots;
  
  	if (!mem || !mem->nslabs) {
  		dev_warn_ratelimited(dev,
@@@ -733,14 -1387,19 +789,24 @@@
  	if (cc_platform_has(CC_ATTR_MEM_ENCRYPT))
  		pr_warn_once("Memory encryption is active and system is using DMA bounce buffers\n");
  
- 	if (mapping_size > alloc_size) {
- 		dev_warn_once(dev, "Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)",
- 			      mapping_size, alloc_size);
- 		return (phys_addr_t)DMA_MAPPING_ERROR;
- 	}
+ 	/*
+ 	 * The default swiotlb memory pool is allocated with PAGE_SIZE
+ 	 * alignment. If a mapping is requested with larger alignment,
+ 	 * the mapping may be unable to use the initial slot(s) in all
+ 	 * sets of IO_TLB_SEGSIZE slots. In such case, a mapping request
+ 	 * of or near the maximum mapping size would always fail.
+ 	 */
+ 	dev_WARN_ONCE(dev, alloc_align_mask > ~PAGE_MASK,
+ 		"Alloc alignment may prevent fulfilling requests with max mapping_size\n");
  
++<<<<<<< HEAD
 +	index = swiotlb_find_slots(dev, orig_addr,
 +				   alloc_size + offset, alloc_align_mask);
++=======
+ 	offset = swiotlb_align_offset(dev, alloc_align_mask, orig_addr);
+ 	size = ALIGN(mapping_size + offset, alloc_align_mask + 1);
+ 	index = swiotlb_find_slots(dev, orig_addr, size, alloc_align_mask, &pool);
++>>>>>>> 327e2c97c46a (swiotlb: remove alloc_size argument to swiotlb_tbl_map_single())
  	if (index == -1) {
  		if (!(attrs & DMA_ATTR_NO_WARN))
  			dev_warn_ratelimited(dev,
@@@ -754,15 -1413,21 +820,25 @@@
  	 * This is needed when we sync the memory.  Then we sync the buffer if
  	 * needed.
  	 */
++<<<<<<< HEAD
 +	for (i = 0; i < nr_slots(alloc_size + offset); i++)
 +		mem->slots[index + i].orig_addr = slot_addr(orig_addr, i);
 +	tlb_addr = slot_addr(mem->start, index) + offset;
++=======
+ 	pad_slots = offset >> IO_TLB_SHIFT;
+ 	offset &= (IO_TLB_SIZE - 1);
+ 	index += pad_slots;
+ 	pool->slots[index].pad_slots = pad_slots;
+ 	for (i = 0; i < (nr_slots(size) - pad_slots); i++)
+ 		pool->slots[index + i].orig_addr = slot_addr(orig_addr, i);
+ 	tlb_addr = slot_addr(pool->start, index) + offset;
++>>>>>>> 327e2c97c46a (swiotlb: remove alloc_size argument to swiotlb_tbl_map_single())
  	/*
 -	 * When the device is writing memory, i.e. dir == DMA_FROM_DEVICE, copy
 -	 * the original buffer to the TLB buffer before initiating DMA in order
 -	 * to preserve the original's data if the device does a partial write,
 -	 * i.e. if the device doesn't overwrite the entire buffer.  Preserving
 -	 * the original data, even if it's garbage, is necessary to match
 -	 * hardware behavior.  Use of swiotlb is supposed to be transparent,
 -	 * i.e. swiotlb must not corrupt memory by clobbering unwritten bytes.
 +	 * When dir == DMA_FROM_DEVICE we could omit the copy from the orig
 +	 * to the tlb buffer, if we knew for sure the device will
 +	 * overwirte the entire current content. But we don't. Thus
 +	 * unconditional bounce may prevent leaking swiotlb content (i.e.
 +	 * kernel memory) to user-space.
  	 */
  	swiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);
  	return tlb_addr;
diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c
index e531d2c4ba52..c9497d9d08ae 100644
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -1025,7 +1025,7 @@ static dma_addr_t iommu_dma_map_page(struct device *dev, struct page *page,
 		}
 
 		aligned_size = iova_align(iovad, size);
-		phys = swiotlb_tbl_map_single(dev, phys, size, aligned_size,
+		phys = swiotlb_tbl_map_single(dev, phys, size,
 					      iova_mask(iovad), dir, attrs);
 
 		if (phys == DMA_MAPPING_ERROR)
diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c
index d027bb25e533..f3e78470c8c3 100644
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@ -387,7 +387,7 @@ static dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,
 	 */
 	trace_swiotlb_bounced(dev, dev_addr, size);
 
-	map = swiotlb_tbl_map_single(dev, phys, size, size, 0, dir, attrs);
+	map = swiotlb_tbl_map_single(dev, phys, size, 0, dir, attrs);
 	if (map == (phys_addr_t)DMA_MAPPING_ERROR)
 		return DMA_MAPPING_ERROR;
 
diff --git a/include/linux/swiotlb.h b/include/linux/swiotlb.h
index 2ef25e6fa1b4..5fc11fcaf6fd 100644
--- a/include/linux/swiotlb.h
+++ b/include/linux/swiotlb.h
@@ -42,7 +42,7 @@ int swiotlb_init_late(size_t size, gfp_t gfp_mask,
 extern void __init swiotlb_update_mem_attributes(void);
 
 phys_addr_t swiotlb_tbl_map_single(struct device *hwdev, phys_addr_t phys,
-		size_t mapping_size, size_t alloc_size,
+		size_t mapping_size,
 		unsigned int alloc_aligned_mask, enum dma_data_direction dir,
 		unsigned long attrs);
 
* Unmerged path kernel/dma/swiotlb.c
