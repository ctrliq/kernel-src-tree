smb3: remove trivial dfs compile warning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Steve French <stfrench@microsoft.com>
commit 0e62904836ecddf69b0358fe8f9442d3dd914c55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/0e629048.failed

Fix warning caused by recent changes to the dfs code:

symbol 'tree_connect_dfs_target' was not declared. Should it be static?

	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 0e62904836ecddf69b0358fe8f9442d3dd914c55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 13237453ae19,df3365958603..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -4200,6 -4064,206 +4200,209 @@@ cifs_prune_tlinks(struct work_struct *w
  }
  
  #ifdef CONFIG_CIFS_DFS_UPCALL
++<<<<<<< HEAD
++=======
+ static void mark_tcon_tcp_ses_for_reconnect(struct cifs_tcon *tcon)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < tcon->ses->chan_count; i++) {
+ 		spin_lock(&GlobalMid_Lock);
+ 		if (tcon->ses->chans[i].server->tcpStatus != CifsExiting)
+ 			tcon->ses->chans[i].server->tcpStatus = CifsNeedReconnect;
+ 		spin_unlock(&GlobalMid_Lock);
+ 	}
+ }
+ 
+ /* Update dfs referral path of superblock */
+ static int update_server_fullpath(struct TCP_Server_Info *server, struct cifs_sb_info *cifs_sb,
+ 				  const char *target)
+ {
+ 	int rc = 0;
+ 	size_t len = strlen(target);
+ 	char *refpath, *npath;
+ 
+ 	if (unlikely(len < 2 || *target != '\\'))
+ 		return -EINVAL;
+ 
+ 	if (target[1] == '\\') {
+ 		len += 1;
+ 		refpath = kmalloc(len, GFP_KERNEL);
+ 		if (!refpath)
+ 			return -ENOMEM;
+ 
+ 		scnprintf(refpath, len, "%s", target);
+ 	} else {
+ 		len += sizeof("\\");
+ 		refpath = kmalloc(len, GFP_KERNEL);
+ 		if (!refpath)
+ 			return -ENOMEM;
+ 
+ 		scnprintf(refpath, len, "\\%s", target);
+ 	}
+ 
+ 	npath = dfs_cache_canonical_path(refpath, cifs_sb->local_nls, cifs_remap(cifs_sb));
+ 	kfree(refpath);
+ 
+ 	if (IS_ERR(npath)) {
+ 		rc = PTR_ERR(npath);
+ 	} else {
+ 		mutex_lock(&server->refpath_lock);
+ 		kfree(server->leaf_fullpath);
+ 		server->leaf_fullpath = npath;
+ 		mutex_unlock(&server->refpath_lock);
+ 		server->current_fullpath = server->leaf_fullpath;
+ 	}
+ 	return rc;
+ }
+ 
+ static int target_share_matches_server(struct TCP_Server_Info *server, const char *tcp_host,
+ 				       size_t tcp_host_len, char *share, bool *target_match)
+ {
+ 	int rc = 0;
+ 	const char *dfs_host;
+ 	size_t dfs_host_len;
+ 
+ 	*target_match = true;
+ 	extract_unc_hostname(share, &dfs_host, &dfs_host_len);
+ 
+ 	/* Check if hostnames or addresses match */
+ 	if (dfs_host_len != tcp_host_len || strncasecmp(dfs_host, tcp_host, dfs_host_len) != 0) {
+ 		cifs_dbg(FYI, "%s: %.*s doesn't match %.*s\n", __func__, (int)dfs_host_len,
+ 			 dfs_host, (int)tcp_host_len, tcp_host);
+ 		rc = match_target_ip(server, dfs_host, dfs_host_len, target_match);
+ 		if (rc)
+ 			cifs_dbg(VFS, "%s: failed to match target ip: %d\n", __func__, rc);
+ 	}
+ 	return rc;
+ }
+ 
+ static int __tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,
+ 			      struct cifs_sb_info *cifs_sb, char *tree,
+ 			      struct dfs_cache_tgt_list *tl, struct dfs_info3_param *ref)
+ {
+ 	int rc;
+ 	struct TCP_Server_Info *server = tcon->ses->server;
+ 	const struct smb_version_operations *ops = server->ops;
+ 	struct cifs_tcon *ipc = tcon->ses->tcon_ipc;
+ 	bool islink;
+ 	char *share = NULL, *prefix = NULL;
+ 	const char *tcp_host;
+ 	size_t tcp_host_len;
+ 	struct dfs_cache_tgt_iterator *tit;
+ 	bool target_match;
+ 
+ 	extract_unc_hostname(server->hostname, &tcp_host, &tcp_host_len);
+ 
+ 	islink = ref->server_type == DFS_TYPE_LINK;
+ 	free_dfs_info_param(ref);
+ 
+ 	tit = dfs_cache_get_tgt_iterator(tl);
+ 	if (!tit) {
+ 		rc = -ENOENT;
+ 		goto out;
+ 	}
+ 
+ 	/* Try to tree connect to all dfs targets */
+ 	for (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {
+ 		const char *target = dfs_cache_get_tgt_name(tit);
+ 		struct dfs_cache_tgt_list ntl = DFS_CACHE_TGT_LIST_INIT(ntl);
+ 
+ 		kfree(share);
+ 		kfree(prefix);
+ 
+ 		/* Check if share matches with tcp ses */
+ 		rc = dfs_cache_get_tgt_share(server->current_fullpath + 1, tit, &share, &prefix);
+ 		if (rc) {
+ 			cifs_dbg(VFS, "%s: failed to parse target share: %d\n", __func__, rc);
+ 			break;
+ 		}
+ 
+ 		rc = target_share_matches_server(server, tcp_host, tcp_host_len, share,
+ 						 &target_match);
+ 		if (rc)
+ 			break;
+ 		if (!target_match) {
+ 			rc = -EHOSTUNREACH;
+ 			continue;
+ 		}
+ 
+ 		if (ipc->need_reconnect) {
+ 			scnprintf(tree, MAX_TREE_SIZE, "\\\\%s\\IPC$", server->hostname);
+ 			rc = ops->tree_connect(xid, ipc->ses, tree, ipc, cifs_sb->local_nls);
+ 			if (rc)
+ 				break;
+ 		}
+ 
+ 		scnprintf(tree, MAX_TREE_SIZE, "\\%s", share);
+ 		if (!islink) {
+ 			rc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);
+ 			break;
+ 		}
+ 		/*
+ 		 * If no dfs referrals were returned from link target, then just do a TREE_CONNECT
+ 		 * to it.  Otherwise, cache the dfs referral and then mark current tcp ses for
+ 		 * reconnect so either the demultiplex thread or the echo worker will reconnect to
+ 		 * newly resolved target.
+ 		 */
+ 		if (dfs_cache_find(xid, tcon->ses, cifs_sb->local_nls, cifs_remap(cifs_sb), target,
+ 				   ref, &ntl)) {
+ 			rc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);
+ 			if (rc)
+ 				continue;
+ 			rc = dfs_cache_noreq_update_tgthint(server->current_fullpath + 1, tit);
+ 			if (!rc)
+ 				rc = cifs_update_super_prepath(cifs_sb, prefix);
+ 			break;
+ 		}
+ 		/* Target is another dfs share */
+ 		rc = update_server_fullpath(server, cifs_sb, target);
+ 		dfs_cache_free_tgts(tl);
+ 
+ 		if (!rc) {
+ 			rc = -EREMOTE;
+ 			list_replace_init(&ntl.tl_list, &tl->tl_list);
+ 		} else {
+ 			dfs_cache_free_tgts(&ntl);
+ 			free_dfs_info_param(ref);
+ 		}
+ 		break;
+ 	}
+ 
+ out:
+ 	kfree(share);
+ 	kfree(prefix);
+ 
+ 	return rc;
+ }
+ 
+ static int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,
+ 			    struct cifs_sb_info *cifs_sb, char *tree,
+ 			    struct dfs_cache_tgt_list *tl, struct dfs_info3_param *ref)
+ {
+ 	int rc;
+ 	int num_links = 0;
+ 	struct TCP_Server_Info *server = tcon->ses->server;
+ 
+ 	do {
+ 		rc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, tl, ref);
+ 		if (!rc || rc != -EREMOTE)
+ 			break;
+ 	} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);
+ 	/*
+ 	 * If we couldn't tree connect to any targets from last referral path, then retry from
+ 	 * original referral path.
+ 	 */
+ 	if (rc && server->current_fullpath != server->origin_fullpath) {
+ 		server->current_fullpath = server->origin_fullpath;
+ 		mark_tcon_tcp_ses_for_reconnect(tcon);
+ 	}
+ 
+ 	dfs_cache_free_tgts(tl);
+ 	return rc;
+ }
+ 
++>>>>>>> 0e62904836ec (smb3: remove trivial dfs compile warning)
  int cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)
  {
  	int rc;
* Unmerged path fs/cifs/connect.c
