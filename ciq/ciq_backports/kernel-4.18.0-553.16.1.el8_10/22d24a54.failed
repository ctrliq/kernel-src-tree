block: fix overflow in blk_ioctl_discard()

jira LE-1907
cve CVE-2024-36917
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Li Nan <linan122@huawei.com>
commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/22d24a54.failed

There is no check for overflow of 'start + len' in blk_ioctl_discard().
Hung task occurs if submit an discard ioctl with the following param:
  start = 0x80000000000ff000, len = 0x8000000000fff000;
Add the overflow validation now.

	Signed-off-by: Li Nan <linan122@huawei.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
Link: https://lore.kernel.org/r/20240329012319.2034550-1-linan666@huaweicloud.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/ioctl.c
diff --cc block/ioctl.c
index eae81f7ec02b,a9028a2c2db5..000000000000
--- a/block/ioctl.c
+++ b/block/ioctl.c
@@@ -79,66 -92,18 +79,71 @@@ static int compat_blkpg_ioctl(struct bl
  }
  #endif
  
 -static int blk_ioctl_discard(struct block_device *bdev, blk_mode_t mode,
 -		unsigned long arg)
 +static int blkdev_reread_part(struct block_device *bdev, fmode_t mode)
 +{
 +	struct block_device *tmp;
 +	int ret = 0;
 +
 +	if (!disk_part_scan_enabled(bdev->bd_disk) || bdev_is_partition(bdev))
 +		return -EINVAL;
 +	if (!capable(CAP_SYS_ADMIN))
 +		return -EACCES;
 +	if (bdev->bd_part_count)
 +		return -EBUSY;
 +
 +	/*
 +	 * If the device is opened exclusively by current thread already, it's
 +	 * safe to scan partitons, otherwise, use bd_prepare_to_claim() to
 +	 * synchronize with other exclusive openers and other partition
 +	 * scanners.
 +	 */
 +	if (!(mode & FMODE_EXCL)) {
 +		ret = bd_prepare_to_claim(bdev, bdev->bd_contains, blkdev_reread_part);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	/*
 +	 * Reopen the device to revalidate the driver state and force a
 +	 * partition rescan.
 +	 */
 +	bdev->bd_invalidated = 1;
 +	set_bit(GD_NEED_PART_SCAN, &bdev->bd_disk->state);
 +	tmp = blkdev_get_by_dev(bdev->bd_dev, mode & ~FMODE_EXCL, NULL);
 +	if (IS_ERR(tmp))
 +		ret = PTR_ERR(tmp);
 +	else
 +		blkdev_put(tmp, mode & ~FMODE_EXCL);
 +
 +	/*
 +	 * If blkdev_get_by_dev() failed early, GD_NEED_PART_SCAN is still set,
 +	 * and this will cause that re-assemble partitioned raid device will
 +	 * creat partition for underlying disk.
 +	 */
 +	clear_bit(GD_NEED_PART_SCAN, &bdev->bd_disk->state);
 +	bdev->bd_invalidated = 0;
 +	if (!(mode & FMODE_EXCL))
 +		bd_abort_claiming(bdev, bdev->bd_contains, blkdev_reread_part);
 +	return ret;
 +}
 +
 +static int blk_ioctl_discard(struct block_device *bdev, fmode_t mode,
 +		unsigned long arg, unsigned long flags)
  {
  	uint64_t range[2];
++<<<<<<< HEAD
 +	uint64_t start, len;
 +	struct request_queue *q = bdev_get_queue(bdev);
++=======
+ 	uint64_t start, len, end;
+ 	struct inode *inode = bdev->bd_inode;
++>>>>>>> 22d24a544b0d (block: fix overflow in blk_ioctl_discard())
  	int err;
  
 -	if (!(mode & BLK_OPEN_WRITE))
 +	if (!(mode & FMODE_WRITE))
  		return -EBADF;
  
 -	if (!bdev_max_discard_sectors(bdev))
 +	if (!blk_queue_discard(q))
  		return -EOPNOTSUPP;
  
  	if (copy_from_user(range, (void __user *)arg, sizeof(range)))
@@@ -152,18 -117,52 +157,23 @@@
  	if (len & 511)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (start + len > i_size_read(bdev->bd_inode))
++=======
+ 	if (check_add_overflow(start, len, &end) ||
+ 	    end > bdev_nr_bytes(bdev))
++>>>>>>> 22d24a544b0d (block: fix overflow in blk_ioctl_discard())
  		return -EINVAL;
  
 -	filemap_invalidate_lock(inode->i_mapping);
  	err = truncate_bdev_range(bdev, mode, start, start + len - 1);
  	if (err)
 -		goto fail;
 -	err = blkdev_issue_discard(bdev, start >> 9, len >> 9, GFP_KERNEL);
 -fail:
 -	filemap_invalidate_unlock(inode->i_mapping);
 -	return err;
 -}
 -
 -static int blk_ioctl_secure_erase(struct block_device *bdev, blk_mode_t mode,
 -		void __user *argp)
 -{
 -	uint64_t start, len;
 -	uint64_t range[2];
 -	int err;
 -
 -	if (!(mode & BLK_OPEN_WRITE))
 -		return -EBADF;
 -	if (!bdev_max_secure_erase_sectors(bdev))
 -		return -EOPNOTSUPP;
 -	if (copy_from_user(range, argp, sizeof(range)))
 -		return -EFAULT;
 -
 -	start = range[0];
 -	len = range[1];
 -	if ((start & 511) || (len & 511))
 -		return -EINVAL;
 -	if (start + len > bdev_nr_bytes(bdev))
 -		return -EINVAL;
 +		return err;
  
 -	filemap_invalidate_lock(bdev->bd_inode->i_mapping);
 -	err = truncate_bdev_range(bdev, mode, start, start + len - 1);
 -	if (!err)
 -		err = blkdev_issue_secure_erase(bdev, start >> 9, len >> 9,
 -						GFP_KERNEL);
 -	filemap_invalidate_unlock(bdev->bd_inode->i_mapping);
 -	return err;
 +	return blkdev_issue_discard(bdev, start >> 9, len >> 9,
 +				    GFP_KERNEL, flags);
  }
  
 -
 -static int blk_ioctl_zeroout(struct block_device *bdev, blk_mode_t mode,
 +static int blk_ioctl_zeroout(struct block_device *bdev, fmode_t mode,
  		unsigned long arg)
  {
  	uint64_t range[2];
* Unmerged path block/ioctl.c
