xfs: allow extent free intents to be retried

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Dave Chinner <dchinner@redhat.com>
commit 0853b5de42b471a92f4ff128a8757b87427d2431
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/0853b5de.failed

Extent freeing neeeds to be able to avoid a busy extent deadlock
when the transaction itself holds the only busy extents in the
allocation group. This may occur if we have an EFI that contains
multiple extents to be freed, and the freeing the second intent
requires the space the first extent free released to expand the
AGFL. If we block on the busy extent at this point, we deadlock.

We hold a dirty transaction that contains a entire atomic extent
free operations within it, so if we can abort the extent free
operation and commit the progress that we've made, the busy extent
can be resolved by a log force. Hence we can restart the aborted
extent free with a new transaction and continue to make
progress without risking deadlocks.

To enable this, we need the EFI processing code to be able to handle
an -EAGAIN error to tell it to commit the current transaction and
retry again. This mechanism is already built into the defer ops
processing (used bythe refcount btree modification intents), so
there's relatively little handling we need to add to the EFI code to
enable this.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Chandan Babu R <chandan.babu@oracle.com>
(cherry picked from commit 0853b5de42b471a92f4ff128a8757b87427d2431)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_extfree_item.c
diff --cc fs/xfs/xfs_extfree_item.c
index f0baca0aa89e,cdd8ebb6e7cb..000000000000
--- a/fs/xfs/xfs_extfree_item.c
+++ b/fs/xfs/xfs_extfree_item.c
@@@ -380,9 -403,20 +408,20 @@@ xfs_trans_free_extent
  	 * 1.) releases the EFI and frees the EFD
  	 * 2.) shuts down the filesystem
  	 */
 -	tp->t_flags |= XFS_TRANS_DIRTY | XFS_TRANS_HAS_INTENT_DONE;
 +	tp->t_flags |= XFS_TRANS_DIRTY;
  	set_bit(XFS_LI_DIRTY, &efdp->efd_item.li_flags);
  
+ 	/*
+ 	 * If we need a new transaction to make progress, the caller will log a
+ 	 * new EFI with the current contents. It will also log an EFD to cancel
+ 	 * the existing EFI, and so we need to copy all the unprocessed extents
+ 	 * in this EFI to the EFD so this works correctly.
+ 	 */
+ 	if (error == -EAGAIN) {
+ 		xfs_efd_from_efi(efdp);
+ 		return error;
+ 	}
+ 
  	next_extent = efdp->efd_next_extent;
  	ASSERT(next_extent < efdp->efd_format.efd_nextents);
  	extp = &(efdp->efd_format.efd_extents[next_extent]);
@@@ -474,15 -527,22 +513,31 @@@ xfs_extent_free_finish_item
  	struct list_head		*item,
  	struct xfs_btree_cur		**state)
  {
 -	struct xfs_extent_free_item	*xefi;
 +	struct xfs_extent_free_item	*free;
  	int				error;
  
++<<<<<<< HEAD
 +	free = container_of(item, struct xfs_extent_free_item, xefi_list);
 +	error = xfs_trans_free_extent(tp, EFD_ITEM(done),
 +			free->xefi_startblock,
 +			free->xefi_blockcount,
 +			&free->xefi_oinfo, free->xefi_skip_discard);
 +	kmem_cache_free(xfs_bmap_free_item_zone, free);
++=======
+ 	xefi = container_of(item, struct xfs_extent_free_item, xefi_list);
+ 
+ 	error = xfs_trans_free_extent(tp, EFD_ITEM(done), xefi);
+ 
+ 	/*
+ 	 * Don't free the XEFI if we need a new transaction to complete
+ 	 * processing of it.
+ 	 */
+ 	if (error == -EAGAIN)
+ 		return error;
+ 
+ 	xfs_extent_free_put_group(xefi);
+ 	kmem_cache_free(xfs_extfree_item_cache, xefi);
++>>>>>>> 0853b5de42b4 (xfs: allow extent free intents to be retried)
  	return error;
  }
  
@@@ -596,14 -660,13 +651,15 @@@ xfs_efi_item_recover
  	struct xfs_log_item		*lip,
  	struct list_head		*capture_list)
  {
 +	struct xfs_trans_res		resv;
  	struct xfs_efi_log_item		*efip = EFI_ITEM(lip);
 -	struct xfs_mount		*mp = lip->li_log->l_mp;
 +	struct xfs_mount		*mp = lip->li_mountp;
  	struct xfs_efd_log_item		*efdp;
  	struct xfs_trans		*tp;
 +	struct xfs_extent		*extp;
  	int				i;
  	int				error = 0;
+ 	bool				requeue_only = false;
  
  	/*
  	 * First check the validity of the extents described by the
@@@ -627,10 -689,42 +683,42 @@@
  	efdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);
  
  	for (i = 0; i < efip->efi_format.efi_nextents; i++) {
 -		struct xfs_extent_free_item	fake = {
 -			.xefi_owner		= XFS_RMAP_OWN_UNKNOWN,
 -			.xefi_agresv		= XFS_AG_RESV_NONE,
 -		};
 -		struct xfs_extent		*extp;
 -
  		extp = &efip->efi_format.efi_extents[i];
++<<<<<<< HEAD
 +		error = xfs_trans_free_extent(tp, efdp, extp->ext_start,
 +					      extp->ext_len,
 +					      &XFS_RMAP_OINFO_ANY_OWNER, false);
++=======
+ 
+ 		fake.xefi_startblock = extp->ext_start;
+ 		fake.xefi_blockcount = extp->ext_len;
+ 
+ 		if (!requeue_only) {
+ 			xfs_extent_free_get_group(mp, &fake);
+ 			error = xfs_trans_free_extent(tp, efdp, &fake);
+ 			xfs_extent_free_put_group(&fake);
+ 		}
+ 
+ 		/*
+ 		 * If we can't free the extent without potentially deadlocking,
+ 		 * requeue the rest of the extents to a new so that they get
+ 		 * run again later with a new transaction context.
+ 		 */
+ 		if (error == -EAGAIN || requeue_only) {
+ 			error = xfs_free_extent_later(tp, fake.xefi_startblock,
+ 					fake.xefi_blockcount,
+ 					&XFS_RMAP_OINFO_ANY_OWNER,
+ 					fake.xefi_agresv);
+ 			if (!error) {
+ 				requeue_only = true;
+ 				continue;
+ 			}
+ 		};
+ 
+ 		if (error == -EFSCORRUPTED)
+ 			XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,
+ 					extp, sizeof(*extp));
++>>>>>>> 0853b5de42b4 (xfs: allow extent free intents to be retried)
  		if (error)
  			goto abort_error;
  
* Unmerged path fs/xfs/xfs_extfree_item.c
