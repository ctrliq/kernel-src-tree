cifs: switch build_path_from_dentry() to using dentry_path_raw()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 991e72eb0e99764219865b9a3a07328695148e14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/991e72eb.failed

The cost is that we might need to flip '/' to '\\' in more than
just the prefix.  Needs profiling, but I suspect that we won't
get slowdown on that.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 991e72eb0e99764219865b9a3a07328695148e14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/dir.c
diff --cc fs/cifs/dir.c
index 26bfed1a114a,03afad8b24af..000000000000
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@@ -90,19 -90,19 +90,27 @@@ build_path_from_dentry(struct dentry *d
  }
  
  char *
 -build_path_from_dentry_optional_prefix(struct dentry *direntry, void *page,
 -				       bool prefix)
 +build_path_from_dentry_optional_prefix(struct dentry *direntry, bool prefix)
  {
- 	struct dentry *temp;
- 	int namelen;
  	int dfsplen;
  	int pplen = 0;
++<<<<<<< HEAD
 +	char *full_path;
 +	char dirsep;
++=======
++>>>>>>> 991e72eb0e99 (cifs: switch build_path_from_dentry() to using dentry_path_raw())
  	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);
  	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
- 	unsigned seq;
+ 	char dirsep = CIFS_DIR_SEP(cifs_sb);
+ 	char *s;
  
++<<<<<<< HEAD
 +	dirsep = CIFS_DIR_SEP(cifs_sb);
++=======
+ 	if (unlikely(!page))
+ 		return ERR_PTR(-ENOMEM);
+ 
++>>>>>>> 991e72eb0e99 (cifs: switch build_path_from_dentry() to using dentry_path_raw())
  	if (prefix)
  		dfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);
  	else
@@@ -111,77 -111,30 +119,91 @@@
  	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)
  		pplen = cifs_sb->prepath ? strlen(cifs_sb->prepath) + 1 : 0;
  
++<<<<<<< HEAD
 +cifs_bp_rename_retry:
 +	namelen = dfsplen + pplen;
 +	seq = read_seqbegin(&rename_lock);
 +	rcu_read_lock();
 +	for (temp = direntry; !IS_ROOT(temp);) {
 +		namelen += (1 + temp->d_name.len);
 +		temp = temp->d_parent;
 +		if (temp == NULL) {
 +			cifs_dbg(VFS, "corrupt dentry\n");
 +			rcu_read_unlock();
 +			return NULL;
 +		}
 +	}
 +	rcu_read_unlock();
 +
 +	full_path = kmalloc(namelen+1, GFP_ATOMIC);
 +	if (full_path == NULL)
 +		return full_path;
 +	full_path[namelen] = 0;	/* trailing null */
 +	rcu_read_lock();
 +	for (temp = direntry; !IS_ROOT(temp);) {
 +		spin_lock(&temp->d_lock);
 +		namelen -= 1 + temp->d_name.len;
 +		if (namelen < 0) {
 +			spin_unlock(&temp->d_lock);
 +			break;
 +		} else {
 +			full_path[namelen] = dirsep;
 +			strncpy(full_path + namelen + 1, temp->d_name.name,
 +				temp->d_name.len);
 +			cifs_dbg(FYI, "name: %s\n", full_path + namelen);
 +		}
 +		spin_unlock(&temp->d_lock);
 +		temp = temp->d_parent;
 +		if (temp == NULL) {
 +			cifs_dbg(VFS, "corrupt dentry\n");
 +			rcu_read_unlock();
 +			kfree(full_path);
 +			return NULL;
 +		}
 +	}
 +	rcu_read_unlock();
 +	if (namelen != dfsplen + pplen || read_seqretry(&rename_lock, seq)) {
 +		cifs_dbg(FYI, "did not end path lookup where expected. namelen=%ddfsplen=%d\n",
 +			 namelen, dfsplen);
 +		/* presumably this is only possible if racing with a rename
 +		of one of the parent directories  (we can not lock the dentries
 +		above us to prevent this, but retrying should be harmless) */
 +		kfree(full_path);
 +		goto cifs_bp_rename_retry;
 +	}
 +	/* DIR_SEP already set for byte  0 / vs \ but not for
 +	   subsequent slashes in prepath which currently must
 +	   be entered the right way - not sure if there is an alternative
 +	   since the '\' is a valid posix character so we can not switch
 +	   those safely to '/' if any are found in the middle of the prepath */
 +	/* BB test paths to Windows with '/' in the midst of prepath */
 +
++=======
+ 	s = dentry_path_raw(direntry, page, PAGE_SIZE);
+ 	if (IS_ERR(s))
+ 		return s;
+ 	if (!s[1])	// for root we want "", not "/"
+ 		s++;
+ 	if (s < (char *)page + pplen + dfsplen)
+ 		return ERR_PTR(-ENAMETOOLONG);
++>>>>>>> 991e72eb0e99 (cifs: switch build_path_from_dentry() to using dentry_path_raw())
  	if (pplen) {
- 		int i;
- 
  		cifs_dbg(FYI, "using cifs_sb prepath <%s>\n", cifs_sb->prepath);
- 		memcpy(full_path+dfsplen+1, cifs_sb->prepath, pplen-1);
- 		full_path[dfsplen] = dirsep;
- 		for (i = 0; i < pplen-1; i++)
- 			if (full_path[dfsplen+1+i] == '/')
- 				full_path[dfsplen+1+i] = CIFS_DIR_SEP(cifs_sb);
+ 		s -= pplen;
+ 		memcpy(s + 1, cifs_sb->prepath, pplen - 1);
+ 		*s = '/';
  	}
+ 	if (dirsep != '/') {
+ 		/* BB test paths to Windows with '/' in the midst of prepath */
+ 		char *p;
  
+ 		for (p = s; *p; p++)
+ 			if (*p == '/')
+ 				*p = dirsep;
+ 	}
  	if (dfsplen) {
- 		strncpy(full_path, tcon->treeName, dfsplen);
+ 		s -= dfsplen;
+ 		memcpy(s, tcon->treeName, dfsplen);
  		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {
  			int i;
  			for (i = 0; i < dfsplen; i++) {
* Unmerged path fs/cifs/dir.c
