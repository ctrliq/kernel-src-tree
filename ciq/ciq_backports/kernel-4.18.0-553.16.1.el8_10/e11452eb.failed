dmaengine: idxd: add a new security check to deal with a hardware erratum

jira LE-1907
cve CVE-2024-21823
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Arjan van de Ven <arjan@linux.intel.com>
commit e11452eb071b2a8e6ba52892b2e270bbdaa6640d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/e11452eb.failed

On Sapphire Rapids and related platforms, the DSA and IAA devices have an
erratum that causes direct access (for example, by using the ENQCMD or
MOVDIR64 instructions) from untrusted applications to be a security problem.

To solve this, add a flag to the PCI device enumeration and device structures
to indicate the presence/absence of this security exposure. In the mmap()
method of the device, this flag is then used to enforce that the user
has the CAP_SYS_RAWIO capability.

In a future patch, a write() based method will be added that allows untrusted
applications submit work to the accelerator, where the kernel can do
sanity checking on the user input to ensure secure operation of the accelerator.

	Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
(cherry picked from commit e11452eb071b2a8e6ba52892b2e270bbdaa6640d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/idxd.h
#	drivers/dma/idxd/init.c
diff --cc drivers/dma/idxd/idxd.h
index 7ced8d283d98,868b724a3b75..000000000000
--- a/drivers/dma/idxd/idxd.h
+++ b/drivers/dma/idxd/idxd.h
@@@ -255,9 -280,38 +255,39 @@@ struct idxd_dma_dev 
  struct idxd_driver_data {
  	const char *name_prefix;
  	enum idxd_type type;
 -	const struct device_type *dev_type;
 +	struct device_type *dev_type;
  	int compl_size;
  	int align;
++<<<<<<< HEAD
++=======
+ 	int evl_cr_off;
+ 	int cr_status_off;
+ 	int cr_result_off;
+ 	bool user_submission_safe;
+ 	load_device_defaults_fn_t load_device_defaults;
+ };
+ 
+ struct idxd_evl {
+ 	/* Lock to protect event log access. */
+ 	struct mutex lock;
+ 	void *log;
+ 	dma_addr_t dma;
+ 	/* Total size of event log = number of entries * entry size. */
+ 	unsigned int log_size;
+ 	/* The number of entries in the event log. */
+ 	u16 size;
+ 	unsigned long *bmap;
+ 	bool batch_fail[IDXD_MAX_BATCH_IDENT];
+ };
+ 
+ struct idxd_evl_fault {
+ 	struct work_struct work;
+ 	struct idxd_wq *wq;
+ 	u8 status;
+ 
+ 	/* make this last member always */
+ 	struct __evl_entry entry[];
++>>>>>>> e11452eb071b (dmaengine: idxd: add a new security check to deal with a hardware erratum)
  };
  
  struct idxd_device {
@@@ -316,6 -370,32 +346,35 @@@
  	struct idxd_pmu *idxd_pmu;
  
  	unsigned long *opcap_bmap;
++<<<<<<< HEAD
++=======
+ 	struct idxd_evl *evl;
+ 	struct kmem_cache *evl_cache;
+ 
+ 	struct dentry *dbgfs_dir;
+ 	struct dentry *dbgfs_evl_file;
+ 
+ 	bool user_submission_safe;
+ };
+ 
+ static inline unsigned int evl_ent_size(struct idxd_device *idxd)
+ {
+ 	return idxd->hw.gen_cap.evl_support ?
+ 	       (32 * (1 << idxd->hw.gen_cap.evl_support)) : 0;
+ }
+ 
+ static inline unsigned int evl_size(struct idxd_device *idxd)
+ {
+ 	return idxd->evl->size * evl_ent_size(idxd);
+ }
+ 
+ struct crypto_ctx {
+ 	struct acomp_req *req;
+ 	struct crypto_tfm *tfm;
+ 	dma_addr_t src_addr;
+ 	dma_addr_t dst_addr;
+ 	bool compress;
++>>>>>>> e11452eb071b (dmaengine: idxd: add a new security check to deal with a hardware erratum)
  };
  
  /* IDXD software descriptor */
diff --cc drivers/dma/idxd/init.c
index ddcdb5ef133a,a7295943fa22..000000000000
--- a/drivers/dma/idxd/init.c
+++ b/drivers/dma/idxd/init.c
@@@ -46,6 -46,10 +46,13 @@@ static struct idxd_driver_data idxd_dri
  		.compl_size = sizeof(struct dsa_completion_record),
  		.align = 32,
  		.dev_type = &dsa_device_type,
++<<<<<<< HEAD
++=======
+ 		.evl_cr_off = offsetof(struct dsa_evl_entry, cr),
+ 		.user_submission_safe = false, /* See INTEL-SA-01084 security advisory */
+ 		.cr_status_off = offsetof(struct dsa_completion_record, status),
+ 		.cr_result_off = offsetof(struct dsa_completion_record, result),
++>>>>>>> e11452eb071b (dmaengine: idxd: add a new security check to deal with a hardware erratum)
  	},
  	[IDXD_TYPE_IAX] = {
  		.name_prefix = "iax",
@@@ -53,6 -57,11 +60,14 @@@
  		.compl_size = sizeof(struct iax_completion_record),
  		.align = 64,
  		.dev_type = &iax_device_type,
++<<<<<<< HEAD
++=======
+ 		.evl_cr_off = offsetof(struct iax_evl_entry, cr),
+ 		.user_submission_safe = false, /* See INTEL-SA-01084 security advisory */
+ 		.cr_status_off = offsetof(struct iax_completion_record, status),
+ 		.cr_result_off = offsetof(struct iax_completion_record, error_code),
+ 		.load_device_defaults = idxd_load_iaa_device_defaults,
++>>>>>>> e11452eb071b (dmaengine: idxd: add a new security check to deal with a hardware erratum)
  	},
  };
  
diff --git a/drivers/dma/idxd/cdev.c b/drivers/dma/idxd/cdev.c
index 517ef839f7e0..601dc9e1a3c2 100644
--- a/drivers/dma/idxd/cdev.c
+++ b/drivers/dma/idxd/cdev.c
@@ -196,6 +196,18 @@ static int idxd_cdev_mmap(struct file *filp, struct vm_area_struct *vma)
 	int rc;
 
 	dev_dbg(&pdev->dev, "%s called\n", __func__);
+
+	/*
+	 * Due to an erratum in some of the devices supported by the driver,
+	 * direct user submission to the device can be unsafe.
+	 * (See the INTEL-SA-01084 security advisory)
+	 *
+	 * For the devices that exhibit this behavior, require that the user
+	 * has CAP_SYS_RAWIO capabilities.
+	 */
+	if (!idxd->user_submission_safe && !capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
 	rc = check_vma(wq, vma, __func__);
 	if (rc < 0)
 		return rc;
* Unmerged path drivers/dma/idxd/idxd.h
* Unmerged path drivers/dma/idxd/init.c
