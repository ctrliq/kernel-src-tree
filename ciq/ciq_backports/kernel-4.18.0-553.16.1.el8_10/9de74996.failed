smb3: use netname when available on secondary channels

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 9de74996a739bf0b7b5d8c260bd207ad6007442b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/9de74996.failed

Some servers do not allow null netname contexts, which would cause
multichannel to revert to single channel when mounting to some
servers (e.g. Azure xSMB). The previous patch fixed that by avoiding
incorrectly sending the netname context when there would be a null
hostname sent in the netname context, while this patch fixes the null
hostname for the secondary channel by using the hostname of the
primary channel for the secondary channel.

Fixes: 4c14d7043fede ("cifs: populate empty hostnames for extra channels")
	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 9de74996a739bf0b7b5d8c260bd207ad6007442b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/smb2pdu.c
index 2c2185ee9128,12b4dddaedb0..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -509,7 -543,8 +509,12 @@@ assemble_neg_contexts(struct smb2_negot
  		      struct TCP_Server_Info *server, unsigned int *total_len)
  {
  	char *pneg_ctxt;
++<<<<<<< HEAD
 +	unsigned int ctxt_len;
++=======
+ 	char *hostname = NULL;
+ 	unsigned int ctxt_len, neg_context_count;
++>>>>>>> 9de74996a739 (smb3: use netname when available on secondary channels)
  
  	if (*total_len > 200) {
  		/* In case length corrupted don't want to overrun smb buffer */
@@@ -536,6 -571,25 +541,28 @@@
  	*total_len += ctxt_len;
  	pneg_ctxt += ctxt_len;
  
++<<<<<<< HEAD
++=======
+ 	build_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);
+ 	*total_len += sizeof(struct smb2_posix_neg_context);
+ 	pneg_ctxt += sizeof(struct smb2_posix_neg_context);
+ 
+ 	/*
+ 	 * secondary channels don't have the hostname field populated
+ 	 * use the hostname field in the primary channel instead
+ 	 */
+ 	hostname = CIFS_SERVER_IS_CHAN(server) ?
+ 		server->primary_server->hostname : server->hostname;
+ 	if (hostname && (hostname[0] != 0)) {
+ 		ctxt_len = build_netname_ctxt((struct smb2_netname_neg_context *)pneg_ctxt,
+ 					      hostname);
+ 		*total_len += ctxt_len;
+ 		pneg_ctxt += ctxt_len;
+ 		neg_context_count = 4;
+ 	} else /* second channels do not have a hostname */
+ 		neg_context_count = 3;
+ 
++>>>>>>> 9de74996a739 (smb3: use netname when available on secondary channels)
  	if (server->compress_algorithm) {
  		build_compression_ctxt((struct smb2_compression_capabilities_context *)
  				pneg_ctxt);
* Unmerged path fs/cifs/smb2pdu.c
