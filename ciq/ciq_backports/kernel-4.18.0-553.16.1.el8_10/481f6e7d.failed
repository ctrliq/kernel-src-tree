gfs2: Use qd_sbd more consequently

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Bob Peterson <rpeterso@redhat.com>
commit 481f6e7d734ad9a00b44cf0c000f0ed30843e4d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/481f6e7d.failed

Before this patch many of the functions in quota.c got their superblock
pointer, sdp, from the quota_data's glock pointer. That's silly because
the qd already has its own pointer to the superblock (qd_sbd).

This patch changes references to use that instead, eliminating a level
of indirection.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 481f6e7d734ad9a00b44cf0c000f0ed30843e4d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/quota.c
diff --cc fs/gfs2/quota.c
index 9ee7b7ef2a8f,48b9fbffe260..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -145,9 -118,29 +145,14 @@@ static void gfs2_qd_list_dispose(struc
  
  	while (!list_empty(list)) {
  		qd = list_first_entry(list, struct gfs2_quota_data, qd_lru);
++<<<<<<< HEAD
++=======
+ 		sdp = qd->qd_sbd;
+ 
++>>>>>>> 481f6e7d734a (gfs2: Use qd_sbd more consequently)
  		list_del(&qd->qd_lru);
  
 -		/* Free from the filesystem-specific list */
 -		spin_lock(&qd_lock);
 -		list_del(&qd->qd_list);
 -		spin_unlock(&qd_lock);
 -
 -		spin_lock_bucket(qd->qd_hash);
 -		hlist_bl_del_rcu(&qd->qd_hlist);
 -		spin_unlock_bucket(qd->qd_hash);
 -
 -		gfs2_assert_warn(sdp, !qd->qd_change);
 -		gfs2_assert_warn(sdp, !qd->qd_slot_count);
 -		gfs2_assert_warn(sdp, !qd->qd_bh_count);
 -
 -		gfs2_glock_put(qd->qd_gl);
 -		atomic_dec(&sdp->sd_quota_count);
 -
 -		/* Delete it from the common reclaim list */
 -		call_rcu(&qd->qd_rcu, gfs2_qd_dealloc);
 +		gfs2_qd_dispose(qd);
  	}
  }
  
@@@ -390,12 -367,13 +395,18 @@@ static void slot_put(struct gfs2_quota_
  
  static int bh_get(struct gfs2_quota_data *qd)
  {
++<<<<<<< HEAD
 +	struct gfs2_sbd *sdp = qd->qd_gl->gl_name.ln_sbd;
 +	struct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);
++=======
+ 	struct gfs2_sbd *sdp = qd->qd_sbd;
+ 	struct inode *inode = sdp->sd_qc_inode;
+ 	struct gfs2_inode *ip = GFS2_I(inode);
++>>>>>>> 481f6e7d734a (gfs2: Use qd_sbd more consequently)
  	unsigned int block, offset;
  	struct buffer_head *bh;
 -	struct iomap iomap = { };
  	int error;
 +	struct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };
  
  	mutex_lock(&sdp->sd_quota_mutex);
  
@@@ -1205,13 -1178,12 +1216,13 @@@ void gfs2_quota_unlock(struct gfs2_inod
  
  static int print_message(struct gfs2_quota_data *qd, char *type)
  {
- 	struct gfs2_sbd *sdp = qd->qd_gl->gl_name.ln_sbd;
+ 	struct gfs2_sbd *sdp = qd->qd_sbd;
  
 -	fs_info(sdp, "quota %s for %s %u\n",
 -		type,
 -		(qd->qd_id.type == USRQUOTA) ? "user" : "group",
 -		from_kqid(&init_user_ns, qd->qd_id));
 +	if (sdp->sd_args.ar_quota != GFS2_QUOTA_QUIET)
 +		fs_info(sdp, "quota %s for %s %u\n",
 +			type,
 +			(qd->qd_id.type == USRQUOTA) ? "user" : "group",
 +			from_kqid(&init_user_ns, qd->qd_id));
  
  	return 0;
  }
* Unmerged path fs/gfs2/quota.c
