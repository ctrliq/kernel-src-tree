fs/proc: do_task_stat: use sig->stats_lock to gather the threads/children stats

jira LE-1907
cve CVE-2024-26686
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Oleg Nesterov <oleg@redhat.com>
commit 7601df8031fd67310af891897ef6cc0df4209305
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/7601df80.failed

lock_task_sighand() can trigger a hard lockup.  If NR_CPUS threads call
do_task_stat() at the same time and the process has NR_THREADS, it will
spin with irqs disabled O(NR_CPUS * NR_THREADS) time.

Change do_task_stat() to use sig->stats_lock to gather the statistics
outside of ->siglock protected section, in the likely case this code will
run lockless.

Link: https://lkml.kernel.org/r/20240123153357.GA21857@redhat.com
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Dylan Hatch <dylanbhatch@google.com>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 7601df8031fd67310af891897ef6cc0df4209305)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/array.c
diff --cc fs/proc/array.c
index ed41b8b9bd7f,34a47fb0c57f..000000000000
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@@ -476,12 -511,8 +476,13 @@@ static int do_task_stat(struct seq_fil
  
  	sigemptyset(&sigign);
  	sigemptyset(&sigcatch);
++<<<<<<< HEAD
 +	cutime = cstime = utime = stime = 0;
 +	cgtime = gtime = 0;
++=======
++>>>>>>> 7601df8031fd (fs/proc: do_task_stat: use sig->stats_lock to gather the threads/children stats)
  
  	if (lock_task_sighand(task, &flags)) {
- 		struct signal_struct *sig = task->signal;
- 
  		if (sig->tty) {
  			struct pid *pgrp = tty_get_pgrp(sig->tty);
  			tty_pgrp = pid_nr_ns(pgrp, ns);
@@@ -492,28 -523,9 +493,25 @@@
  		num_threads = get_nr_threads(task);
  		collect_sigign_sigcatch(task, &sigign, &sigcatch);
  
- 		cmin_flt = sig->cmin_flt;
- 		cmaj_flt = sig->cmaj_flt;
- 		cutime = sig->cutime;
- 		cstime = sig->cstime;
- 		cgtime = sig->cgtime;
  		rsslim = READ_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);
  
- 		/* add up live thread stats at the group level */
  		if (whole) {
++<<<<<<< HEAD
 +			struct task_struct *t;
 +
 +			__for_each_thread(sig, t) {
 +				min_flt += t->min_flt;
 +				maj_flt += t->maj_flt;
 +				gtime += task_gtime(t);
 +			}
 +
 +			min_flt += sig->min_flt;
 +			maj_flt += sig->maj_flt;
 +			thread_group_cputime_adjusted(task, &utime, &stime);
 +			gtime += sig->gtime;
 +
++=======
++>>>>>>> 7601df8031fd (fs/proc: do_task_stat: use sig->stats_lock to gather the threads/children stats)
  			if (sig->flags & (SIGNAL_GROUP_EXIT | SIGNAL_STOP_STOPPED))
  				exit_code = sig->group_exit_code;
  		}
@@@ -526,11 -538,42 +524,48 @@@
  	}
  
  	if (permitted && (!whole || num_threads < 2))
++<<<<<<< HEAD
 +		wchan = get_wchan(task);
 +	if (!whole) {
++=======
+ 		wchan = !task_is_running(task);
+ 
+ 	do {
+ 		seq++; /* 2 on the 1st/lockless path, otherwise odd */
+ 		flags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);
+ 
+ 		cmin_flt = sig->cmin_flt;
+ 		cmaj_flt = sig->cmaj_flt;
+ 		cutime = sig->cutime;
+ 		cstime = sig->cstime;
+ 		cgtime = sig->cgtime;
+ 
+ 		if (whole) {
+ 			struct task_struct *t;
+ 
+ 			min_flt = sig->min_flt;
+ 			maj_flt = sig->maj_flt;
+ 			gtime = sig->gtime;
+ 
+ 			rcu_read_lock();
+ 			__for_each_thread(sig, t) {
+ 				min_flt += t->min_flt;
+ 				maj_flt += t->maj_flt;
+ 				gtime += task_gtime(t);
+ 			}
+ 			rcu_read_unlock();
+ 		}
+ 	} while (need_seqretry(&sig->stats_lock, seq));
+ 	done_seqretry_irqrestore(&sig->stats_lock, seq, flags);
+ 
+ 	if (whole) {
+ 		thread_group_cputime_adjusted(task, &utime, &stime);
+ 	} else {
+ 		task_cputime_adjusted(task, &utime, &stime);
++>>>>>>> 7601df8031fd (fs/proc: do_task_stat: use sig->stats_lock to gather the threads/children stats)
  		min_flt = task->min_flt;
  		maj_flt = task->maj_flt;
 +		task_cputime_adjusted(task, &utime, &stime);
  		gtime = task_gtime(task);
  	}
  
* Unmerged path fs/proc/array.c
