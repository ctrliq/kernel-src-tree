cifs: support nested dfs links over reconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit c88f7dcd6d6429197fc2fd87b54a894ffcd48e8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/c88f7dcd.failed

Mounting a dfs link that has nested links was already supported at
mount(2), so make it work over reconnect as well.

Make the following case work:

* mount //root/dfs/link /mnt -o ...
  - final share: /server/share

* in server settings
  - change target folder of /root/dfs/link3 to /server/share2
  - change target folder of /root/dfs/link2 to /root/dfs/link3
  - change target folder of /root/dfs/link to /root/dfs/link2

* mount -o remount,... /mnt
 - refresh all dfs referrals
 - mark current connection for failover
 - cifs_reconnect() reconnects to root server
 - tree_connect()
   * checks that /root/dfs/link2 is a link, then chase it
   * checks that root/dfs/link3 is a link, then chase it
   * finally tree connect to /server/share2

If the mounted share is no longer accessible and a reconnect had been
triggered, the client will retry it from both last referral
path (/root/dfs/link3) and original referral path (/root/dfs/link).

Any new referral paths found while chasing dfs links over reconnect,
it will be updated to TCP_Server_Info::leaf_fullpath, accordingly.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit c88f7dcd6d6429197fc2fd87b54a894ffcd48e8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifs_dfs_ref.c
#	fs/cifs/connect.c
#	fs/cifs/misc.c
diff --cc fs/cifs/cifs_dfs_ref.c
index 9cd2b1e94958,b0864da9ef43..000000000000
--- a/fs/cifs/cifs_dfs_ref.c
+++ b/fs/cifs/cifs_dfs_ref.c
@@@ -309,11 -307,8 +309,16 @@@ static struct vfsmount *cifs_dfs_do_mou
  static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)
  {
  	struct cifs_sb_info *cifs_sb;
++<<<<<<< HEAD
 +	struct cifs_ses *ses;
 +	struct cifs_tcon *tcon;
 +	char *full_path, *root_path;
 +	unsigned int xid;
 +	int rc;
++=======
+ 	void *page;
+ 	char *full_path;
++>>>>>>> c88f7dcd6d64 (cifs: support nested dfs links over reconnect)
  	struct vfsmount *mnt;
  
  	cifs_dbg(FYI, "in %s\n", __func__);
@@@ -333,68 -326,22 +336,19 @@@
  		goto cdda_exit;
  	}
  
 -	page = alloc_dentry_path();
  	/* always use tree name prefix */
 -	full_path = build_path_from_dentry_optional_prefix(mntpt, page, true);
 -	if (IS_ERR(full_path)) {
 -		mnt = ERR_CAST(full_path);
 -		goto free_full_path;
 -	}
 +	full_path = build_path_from_dentry_optional_prefix(mntpt, true);
 +	if (full_path == NULL)
 +		goto cdda_exit;
  
  	convert_delimiter(full_path, '\\');
- 
  	cifs_dbg(FYI, "%s: full_path: %s\n", __func__, full_path);
  
- 	if (!cifs_sb_master_tlink(cifs_sb)) {
- 		cifs_dbg(FYI, "%s: master tlink is NULL\n", __func__);
- 		goto free_full_path;
- 	}
- 
- 	tcon = cifs_sb_master_tcon(cifs_sb);
- 	if (!tcon) {
- 		cifs_dbg(FYI, "%s: master tcon is NULL\n", __func__);
- 		goto free_full_path;
- 	}
- 
- 	root_path = kstrdup(tcon->treeName, GFP_KERNEL);
- 	if (!root_path) {
- 		mnt = ERR_PTR(-ENOMEM);
- 		goto free_full_path;
- 	}
- 	cifs_dbg(FYI, "%s: root path: %s\n", __func__, root_path);
- 
- 	ses = tcon->ses;
- 	xid = get_xid();
- 
- 	/*
- 	 * If DFS root has been expired, then unconditionally fetch it again to
- 	 * refresh DFS referral cache.
- 	 */
- 	rc = dfs_cache_find(xid, ses, cifs_sb->local_nls, cifs_remap(cifs_sb),
- 			    root_path + 1, NULL, NULL);
- 	if (!rc) {
- 		rc = dfs_cache_find(xid, ses, cifs_sb->local_nls,
- 				    cifs_remap(cifs_sb), full_path + 1,
- 				    NULL, NULL);
- 	}
- 
- 	free_xid(xid);
- 
- 	if (rc) {
- 		mnt = ERR_PTR(rc);
- 		goto free_root_path;
- 	}
- 	/*
- 	 * OK - we were able to get and cache a referral for @full_path.
- 	 *
- 	 * Now, pass it down to cifs_mount() and it will retry every available
- 	 * node server in case of failures - no need to do it here.
- 	 */
  	mnt = cifs_dfs_do_mount(mntpt, cifs_sb, full_path);
- 	cifs_dbg(FYI, "%s: cifs_dfs_do_mount:%s , mnt:%p\n", __func__,
- 		 full_path + 1, mnt);
+ 	cifs_dbg(FYI, "%s: cifs_dfs_do_mount:%s , mnt:%p\n", __func__, full_path + 1, mnt);
  
- free_root_path:
- 	kfree(root_path);
  free_full_path:
 -	free_dentry_path(page);
 +	kfree(full_path);
  cdda_exit:
  	cifs_dbg(FYI, "leaving %s\n" , __func__);
  	return mnt;
diff --cc fs/cifs/connect.c
index 13237453ae19,1ace46e3f16f..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -398,25 -303,153 +412,160 @@@ cifs_reconnect(struct TCP_Server_Info *
  		}
  	} while (server->tcpStatus == CifsNeedReconnect);
  
 +#ifdef CONFIG_CIFS_DFS_UPCALL
++<<<<<<< HEAD
 +	if (tgt_it) {
 +		rc = dfs_cache_noreq_update_tgthint(cifs_sb->origin_fullpath + 1,
 +						    tgt_it);
 +		if (rc) {
 +			cifs_server_dbg(VFS, "%s: failed to update DFS target hint: rc = %d\n",
 +				 __func__, rc);
 +		}
 +		dfs_cache_free_tgts(&tgt_list);
 +	}
 +
 +	cifs_put_tcp_super(sb);
 +#endif
  	if (server->tcpStatus == CifsNeedNegotiate)
  		mod_delayed_work(cifsiod_wq, &server->echo, 0);
  
  	wake_up(&server->response_q);
  	return rc;
 -}
 -
 -#ifdef CONFIG_CIFS_DFS_UPCALL
++=======
+ static int __reconnect_target_unlocked(struct TCP_Server_Info *server, const char *target)
+ {
+ 	int rc;
+ 	char *hostname;
+ 
+ 	if (!cifs_swn_set_server_dstaddr(server)) {
+ 		if (server->hostname != target) {
+ 			hostname = extract_hostname(target);
+ 			if (!IS_ERR(hostname)) {
+ 				kfree(server->hostname);
+ 				server->hostname = hostname;
+ 			} else {
+ 				cifs_dbg(FYI, "%s: couldn't extract hostname or address from dfs target: %ld\n",
+ 					 __func__, PTR_ERR(hostname));
+ 				cifs_dbg(FYI, "%s: default to last target server: %s\n", __func__,
+ 					 server->hostname);
+ 			}
+ 		}
+ 		/* resolve the hostname again to make sure that IP address is up-to-date. */
+ 		rc = reconn_set_ipaddr_from_hostname(server);
+ 		cifs_dbg(FYI, "%s: reconn_set_ipaddr_from_hostname: rc=%d\n", __func__, rc);
+ 	}
+ 	/* Reconnect the socket */
+ 	if (cifs_rdma_enabled(server))
+ 		rc = smbd_reconnect(server);
+ 	else
+ 		rc = generic_ip_connect(server);
+ 
+ 	return rc;
+ }
+ 
+ static int reconnect_target_unlocked(struct TCP_Server_Info *server, struct dfs_cache_tgt_list *tl,
+ 				     struct dfs_cache_tgt_iterator **target_hint)
+ {
+ 	int rc;
+ 	struct dfs_cache_tgt_iterator *tit;
+ 
+ 	*target_hint = NULL;
+ 
+ 	/* If dfs target list is empty, then reconnect to last server */
+ 	tit = dfs_cache_get_tgt_iterator(tl);
+ 	if (!tit)
+ 		return __reconnect_target_unlocked(server, server->hostname);
+ 
+ 	/* Otherwise, try every dfs target in @tl */
+ 	for (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {
+ 		rc = __reconnect_target_unlocked(server, dfs_cache_get_tgt_name(tit));
+ 		if (!rc) {
+ 			*target_hint = tit;
+ 			break;
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
+ static int reconnect_dfs_server(struct TCP_Server_Info *server)
+ {
+ 	int rc = 0;
+ 	const char *refpath = server->current_fullpath + 1;
+ 	struct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);
+ 	struct dfs_cache_tgt_iterator *target_hint = NULL;
+ 	int num_targets = 0;
+ 
+ 	/*
+ 	 * Determine the number of dfs targets the referral path in @cifs_sb resolves to.
+ 	 *
+ 	 * smb2_reconnect() needs to know how long it should wait based upon the number of dfs
+ 	 * targets (server->nr_targets).  It's also possible that the cached referral was cleared
+ 	 * through /proc/fs/cifs/dfscache or the target list is empty due to server settings after
+ 	 * refreshing the referral, so, in this case, default it to 1.
+ 	 */
+ 	if (!dfs_cache_noreq_find(refpath, NULL, &tl))
+ 		num_targets = dfs_cache_get_nr_tgts(&tl);
+ 	if (!num_targets)
+ 		num_targets = 1;
+ 
+ 	if (!cifs_tcp_ses_needs_reconnect(server, num_targets))
+ 		return 0;
+ 
+ 	cifs_mark_tcp_ses_conns_for_reconnect(server);
+ 
+ 	do {
+ 		try_to_freeze();
+ 		mutex_lock(&server->srv_mutex);
+ 
+ 		rc = reconnect_target_unlocked(server, &tl, &target_hint);
+ 		if (rc) {
+ 			/* Failed to reconnect socket */
+ 			mutex_unlock(&server->srv_mutex);
+ 			cifs_dbg(FYI, "%s: reconnect error %d\n", __func__, rc);
+ 			msleep(3000);
+ 			continue;
+ 		}
+ 		/*
+ 		 * Socket was created.  Update tcp session status to CifsNeedNegotiate so that a
+ 		 * process waiting for reconnect will know it needs to re-establish session and tcon
+ 		 * through the reconnected target server.
+ 		 */
+ 		atomic_inc(&tcpSesReconnectCount);
+ 		set_credits(server, 1);
+ 		spin_lock(&GlobalMid_Lock);
+ 		if (server->tcpStatus != CifsExiting)
+ 			server->tcpStatus = CifsNeedNegotiate;
+ 		spin_unlock(&GlobalMid_Lock);
+ 		cifs_swn_reset_server_dstaddr(server);
+ 		mutex_unlock(&server->srv_mutex);
+ 	} while (server->tcpStatus == CifsNeedReconnect);
+ 
+ 	if (target_hint)
+ 		dfs_cache_noreq_update_tgthint(refpath, target_hint);
+ 
+ 	dfs_cache_free_tgts(&tl);
+ 
+ 	/* Need to set up echo worker again once connection has been established */
+ 	if (server->tcpStatus == CifsNeedNegotiate)
+ 		mod_delayed_work(cifsiod_wq, &server->echo, 0);
+ 
+ 	wake_up(&server->response_q);
+ 	return rc;
+ }
+ 
+ int cifs_reconnect(struct TCP_Server_Info *server)
+ {
+ 	/* If tcp session is not an dfs connection, then reconnect to last target server */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (!server->is_dfs_conn || !server->origin_fullpath || !server->leaf_fullpath) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return __cifs_reconnect(server);
+ 	}
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
+ 	return reconnect_dfs_server(server);
++>>>>>>> c88f7dcd6d64 (cifs: support nested dfs links over reconnect)
  }
 -#else
 -int cifs_reconnect(struct TCP_Server_Info *server)
 -{
 -	return __cifs_reconnect(server);
 -}
 -#endif
  
  static void
  cifs_echo_request(struct work_struct *work)
@@@ -3397,111 -3287,26 +3401,76 @@@ static int is_path_remote(struct mount_
  }
  
  #ifdef CONFIG_CIFS_DFS_UPCALL
- static void set_root_ses(struct cifs_sb_info *cifs_sb, const uuid_t *mount_id, struct cifs_ses *ses,
- 			 struct cifs_ses **root_ses)
+ static void set_root_ses(struct mount_ctx *mnt_ctx)
  {
- 	if (ses) {
+ 	if (mnt_ctx->ses) {
  		spin_lock(&cifs_tcp_ses_lock);
- 		ses->ses_count++;
+ 		mnt_ctx->ses->ses_count++;
  		spin_unlock(&cifs_tcp_ses_lock);
- 		dfs_cache_add_refsrv_session(mount_id, ses);
+ 		dfs_cache_add_refsrv_session(&mnt_ctx->mount_id, mnt_ctx->ses);
  	}
- 	*root_ses = ses;
+ 	mnt_ctx->root_ses = mnt_ctx->ses;
  }
  
++<<<<<<< HEAD
 +/* Set up next dfs prefix path in @dfs_path */
 +static int next_dfs_prepath(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx,
 +			    const unsigned int xid, struct TCP_Server_Info *server,
 +			    struct cifs_tcon *tcon, char **dfs_path)
 +{
 +	char *path, *npath;
 +	int added_treename = is_tcon_dfs(tcon);
 +	int rc;
 +
 +	path = cifs_build_path_to_root(ctx, cifs_sb, tcon, added_treename);
 +	if (!path)
 +		return -ENOMEM;
 +
 +	rc = is_path_remote(cifs_sb, ctx, xid, server, tcon);
 +	if (rc == -EREMOTE) {
 +		struct smb3_fs_context v = {NULL};
 +		/* if @path contains a tree name, skip it in the prefix path */
 +		if (added_treename && *path) {
 +			rc = smb3_parse_devname(path, &v);
 +			if (rc)
 +				goto out;
 +			npath = build_unc_path_to_root(&v, cifs_sb, true);
 +			smb3_cleanup_fs_context_contents(&v);
 +		} else {
 +			v.UNC = ctx->UNC;
 +			v.prepath = path + 1;
 +			npath = build_unc_path_to_root(&v, cifs_sb, false);
 +		}
 +
 +		if (IS_ERR(npath)) {
 +			rc = PTR_ERR(npath);
 +			goto out;
 +		}
 +
 +		kfree(*dfs_path);
 +		*dfs_path = npath;
 +		rc = -EREMOTE;
 +	}
 +
 +out:
 +	kfree(path);
 +	return rc;
 +}
 +
 +/* Check if resolved targets can handle any DFS referrals */
 +static int is_referral_server(const char *ref_path, struct cifs_sb_info *cifs_sb,
 +			      struct cifs_tcon *tcon, bool *ref_server)
++=======
+ static int is_dfs_mount(struct mount_ctx *mnt_ctx, bool *isdfs, struct dfs_cache_tgt_list *root_tl)
++>>>>>>> c88f7dcd6d64 (cifs: support nested dfs links over reconnect)
  {
  	int rc;
- 	struct dfs_info3_param ref = {0};
- 
- 	cifs_dbg(FYI, "%s: ref_path=%s\n", __func__, ref_path);
- 
- 	if (is_tcon_dfs(tcon)) {
- 		*ref_server = true;
- 	} else {
- 		char *npath;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
  
- 		npath = dfs_cache_canonical_path(ref_path, cifs_sb->local_nls, cifs_remap(cifs_sb));
- 		if (IS_ERR(npath))
- 			return PTR_ERR(npath);
- 
- 		rc = dfs_cache_noreq_find(npath, &ref, NULL);
- 		kfree(npath);
- 		if (rc) {
- 			cifs_dbg(VFS, "%s: dfs_cache_noreq_find: failed (rc=%d)\n", __func__, rc);
- 			return rc;
- 		}
- 		cifs_dbg(FYI, "%s: ref.flags=0x%x\n", __func__, ref.flags);
- 		/*
- 		 * Check if all targets are capable of handling DFS referrals as per
- 		 * MS-DFSC 2.2.4 RESP_GET_DFS_REFERRAL.
- 		 */
- 		*ref_server = !!(ref.flags & DFSREF_REFERRAL_SERVER);
- 		free_dfs_info_param(&ref);
- 	}
- 	return 0;
- }
- 
- int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)
- {
- 	int rc = 0;
- 	unsigned int xid;
- 	struct TCP_Server_Info *server = NULL;
- 	struct cifs_ses *ses = NULL, *root_ses = NULL;
- 	struct cifs_tcon *tcon = NULL;
- 	int count = 0;
- 	uuid_t mount_id = {0};
- 	char *ref_path = NULL, *full_path = NULL;
- 	char *oldmnt = NULL;
- 	bool ref_server = false;
+ 	*isdfs = true;
  
- 	rc = mount_get_conns(ctx, cifs_sb, &xid, &server, &ses, &tcon);
+ 	rc = mount_get_conns(mnt_ctx);
  	/*
  	 * If called with 'nodfs' mount option, then skip DFS resolving.  Otherwise unconditionally
  	 * try to get an DFS referral (even cached) to determine whether it is an DFS mount.
@@@ -3510,117 -3315,214 +3479,246 @@@
  	 * to respond with PATH_NOT_COVERED to requests that include the prefix.
  	 */
  	if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS) ||
- 	    dfs_cache_find(xid, ses, cifs_sb->local_nls, cifs_remap(cifs_sb), ctx->UNC + 1, NULL,
- 			   NULL)) {
+ 	    dfs_cache_find(mnt_ctx->xid, mnt_ctx->ses, cifs_sb->local_nls, cifs_remap(cifs_sb),
+ 			   ctx->UNC + 1, NULL, root_tl)) {
  		if (rc)
- 			goto error;
+ 			return rc;
  		/* Check if it is fully accessible and then mount it */
- 		rc = is_path_remote(cifs_sb, ctx, xid, server, tcon);
+ 		rc = is_path_remote(mnt_ctx);
  		if (!rc)
- 			goto out;
- 		if (rc != -EREMOTE)
- 			goto error;
+ 			*isdfs = false;
+ 		else if (rc != -EREMOTE)
+ 			return rc;
  	}
+ 	return 0;
+ }
  
- 	mount_put_conns(cifs_sb, xid, server, ses, tcon);
- 	/*
- 	 * Ignore error check here because we may failover to other targets from cached a
- 	 * referral.
+ static int connect_dfs_target(struct mount_ctx *mnt_ctx, const char *full_path,
+ 			      const char *ref_path, struct dfs_cache_tgt_iterator *tit)
+ {
+ 	int rc;
+ 	struct dfs_info3_param ref = {};
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	char *oldmnt = cifs_sb->ctx->mount_options;
+ 
+ 	rc = dfs_cache_get_tgt_referral(ref_path, tit, &ref);
+ 	if (rc)
+ 		goto out;
+ 
+ 	rc = expand_dfs_referral(mnt_ctx, full_path, &ref);
+ 	if (rc)
+ 		goto out;
+ 
+ 	/* Connect to new target only if we were redirected (e.g. mount options changed) */
+ 	if (oldmnt != cifs_sb->ctx->mount_options) {
+ 		mount_put_conns(mnt_ctx);
+ 		rc = mount_get_dfs_conns(mnt_ctx);
+ 	}
+ 	if (!rc) {
+ 		if (cifs_is_referral_server(mnt_ctx->tcon, &ref))
+ 			set_root_ses(mnt_ctx);
+ 		rc = dfs_cache_update_tgthint(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,
+ 					      cifs_remap(cifs_sb), ref_path, tit);
+ 	}
+ 
+ out:
+ 	free_dfs_info_param(&ref);
+ 	return rc;
+ }
+ 
+ static int connect_dfs_root(struct mount_ctx *mnt_ctx, struct dfs_cache_tgt_list *root_tl)
+ {
+ 	int rc;
+ 	char *full_path;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
+ 	struct dfs_cache_tgt_iterator *tit;
+ 
+ 	/* Put initial connections as they might be shared with other mounts.  We need unique dfs
+ 	 * connections per mount to properly failover, so mount_get_dfs_conns() must be used from
+ 	 * now on.
  	 */
- 	(void)mount_get_dfs_conns(ctx, cifs_sb, &xid, &server, &ses, &tcon);
+ 	mount_put_conns(mnt_ctx);
+ 	mount_get_dfs_conns(mnt_ctx);
  
- 	/* Get path of DFS root */
- 	ref_path = build_unc_path_to_root(ctx, cifs_sb, false);
- 	if (IS_ERR(ref_path)) {
- 		rc = PTR_ERR(ref_path);
- 		ref_path = NULL;
- 		goto error;
+ 	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
+ 	if (IS_ERR(full_path))
+ 		return PTR_ERR(full_path);
+ 
+ 	mnt_ctx->origin_fullpath = dfs_cache_canonical_path(ctx->UNC, cifs_sb->local_nls,
+ 							    cifs_remap(cifs_sb));
+ 	if (IS_ERR(mnt_ctx->origin_fullpath)) {
+ 		rc = PTR_ERR(mnt_ctx->origin_fullpath);
+ 		mnt_ctx->origin_fullpath = NULL;
+ 		goto out;
  	}
  
- 	uuid_gen(&mount_id);
- 	set_root_ses(cifs_sb, &mount_id, ses, &root_ses);
- 	do {
- 		/* Save full path of last DFS path we used to resolve final target server */
- 		kfree(full_path);
- 		full_path = build_unc_path_to_root(ctx, cifs_sb, !!count);
- 		if (IS_ERR(full_path)) {
- 			rc = PTR_ERR(full_path);
- 			full_path = NULL;
- 			break;
- 		}
- 		/* Chase referral */
- 		oldmnt = cifs_sb->ctx->mount_options;
- 		rc = expand_dfs_referral(xid, root_ses, ctx, cifs_sb, ref_path + 1);
- 		if (rc)
+ 	/* Try all dfs root targets */
+ 	for (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(root_tl);
+ 	     tit; tit = dfs_cache_get_next_tgt(root_tl, tit)) {
+ 		rc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->origin_fullpath + 1, tit);
+ 		if (!rc) {
+ 			mnt_ctx->leaf_fullpath = kstrdup(mnt_ctx->origin_fullpath, GFP_KERNEL);
+ 			if (!mnt_ctx->leaf_fullpath)
+ 				rc = -ENOMEM;
  			break;
- 		/* Connect to new DFS target only if we were redirected */
- 		if (oldmnt != cifs_sb->ctx->mount_options) {
- 			mount_put_conns(cifs_sb, xid, server, ses, tcon);
- 			rc = mount_get_dfs_conns(ctx, cifs_sb, &xid, &server, &ses, &tcon);
  		}
- 		if (rc && !server && !ses) {
- 			/* Failed to connect. Try to connect to other targets in the referral. */
- 			rc = do_dfs_failover(ref_path + 1, full_path, cifs_sb, ctx, root_ses, &xid,
- 					     &server, &ses, &tcon);
- 		}
- 		if (rc == -EACCES || rc == -EOPNOTSUPP || !server || !ses)
- 			break;
- 		if (!tcon)
- 			continue;
+ 	}
  
++<<<<<<< HEAD
 +		/* Make sure that requests go through new root servers */
 +		rc = is_referral_server(ref_path + 1, cifs_sb, tcon, &ref_server);
 +		if (rc)
 +			break;
 +		if (ref_server)
 +			set_root_ses(cifs_sb, &mount_id, ses, &root_ses);
 +
 +		/* Get next dfs path and then continue chasing them if -EREMOTE */
 +		rc = next_dfs_prepath(cifs_sb, ctx, xid, server, tcon, &ref_path);
 +		/* Prevent recursion on broken link referrals */
 +		if (rc == -EREMOTE && ++count > MAX_NESTED_LINKS)
 +			rc = -ELOOP;
 +	} while (rc == -EREMOTE);
 +
 +	if (rc || !tcon) {
 +		rc = rc ? rc : -ENOENT;
 +		goto error;
 +	}
 +
 +	kfree(ref_path);
 +	/*
 +	 * Store DFS full path in both superblock and tree connect structures.
 +	 *
 +	 * For DFS root mounts, the prefix path (cifs_sb->prepath) is preserved during reconnect so
 +	 * only the root path is set in cifs_sb->origin_fullpath and tcon->dfs_path. And for DFS
 +	 * links, the prefix path is included in both and may be changed during reconnect.  See
 +	 * cifs_tree_connect().
 +	 */
 +	ref_path = dfs_cache_canonical_path(full_path, cifs_sb->local_nls, cifs_remap(cifs_sb));
++=======
+ out:
++>>>>>>> c88f7dcd6d64 (cifs: support nested dfs links over reconnect)
  	kfree(full_path);
- 	full_path = NULL;
+ 	return rc;
+ }
  
- 	if (IS_ERR(ref_path)) {
- 		rc = PTR_ERR(ref_path);
- 		ref_path = NULL;
- 		goto error;
+ static int __follow_dfs_link(struct mount_ctx *mnt_ctx)
+ {
+ 	int rc;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
+ 	char *full_path;
+ 	struct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);
+ 	struct dfs_cache_tgt_iterator *tit;
+ 
+ 	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
+ 	if (IS_ERR(full_path))
+ 		return PTR_ERR(full_path);
+ 
+ 	kfree(mnt_ctx->leaf_fullpath);
+ 	mnt_ctx->leaf_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,
+ 							  cifs_remap(cifs_sb));
+ 	if (IS_ERR(mnt_ctx->leaf_fullpath)) {
+ 		rc = PTR_ERR(mnt_ctx->leaf_fullpath);
+ 		mnt_ctx->leaf_fullpath = NULL;
+ 		goto out;
  	}
- 	cifs_sb->origin_fullpath = ref_path;
  
- 	ref_path = kstrdup(cifs_sb->origin_fullpath, GFP_KERNEL);
- 	if (!ref_path) {
- 		rc = -ENOMEM;
- 		goto error;
+ 	/* Get referral from dfs link */
+ 	rc = dfs_cache_find(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,
+ 			    cifs_remap(cifs_sb), mnt_ctx->leaf_fullpath + 1, NULL, &tl);
+ 	if (rc)
+ 		goto out;
+ 
+ 	/* Try all dfs link targets */
+ 	for (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(&tl);
+ 	     tit; tit = dfs_cache_get_next_tgt(&tl, tit)) {
+ 		rc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->leaf_fullpath + 1, tit);
+ 		if (!rc) {
+ 			rc = is_path_remote(mnt_ctx);
+ 			break;
+ 		}
  	}
- 	spin_lock(&cifs_tcp_ses_lock);
- 	tcon->dfs_path = ref_path;
- 	ref_path = NULL;
- 	spin_unlock(&cifs_tcp_ses_lock);
  
+ out:
+ 	kfree(full_path);
+ 	dfs_cache_free_tgts(&tl);
+ 	return rc;
+ }
+ 
+ static int follow_dfs_link(struct mount_ctx *mnt_ctx)
+ {
+ 	int rc;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
+ 	char *full_path;
+ 	int num_links = 0;
+ 
+ 	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
+ 	if (IS_ERR(full_path))
+ 		return PTR_ERR(full_path);
+ 
+ 	kfree(mnt_ctx->origin_fullpath);
+ 	mnt_ctx->origin_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,
+ 							    cifs_remap(cifs_sb));
+ 	kfree(full_path);
+ 
+ 	if (IS_ERR(mnt_ctx->origin_fullpath)) {
+ 		rc = PTR_ERR(mnt_ctx->origin_fullpath);
+ 		mnt_ctx->origin_fullpath = NULL;
+ 		return rc;
+ 	}
+ 
+ 	do {
+ 		rc = __follow_dfs_link(mnt_ctx);
+ 		if (!rc || rc != -EREMOTE)
+ 			break;
+ 	} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);
+ 
+ 	return rc;
+ }
+ 
+ /* Set up DFS referral paths for failover */
+ static void setup_server_referral_paths(struct mount_ctx *mnt_ctx)
+ {
+ 	struct TCP_Server_Info *server = mnt_ctx->server;
+ 
+ 	server->origin_fullpath = mnt_ctx->origin_fullpath;
+ 	server->leaf_fullpath = mnt_ctx->leaf_fullpath;
+ 	server->current_fullpath = mnt_ctx->leaf_fullpath;
+ 	mnt_ctx->origin_fullpath = mnt_ctx->leaf_fullpath = NULL;
+ }
+ 
+ int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)
+ {
+ 	int rc;
+ 	struct mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };
+ 	struct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);
+ 	bool isdfs;
+ 
+ 	rc = is_dfs_mount(&mnt_ctx, &isdfs, &tl);
+ 	if (rc)
+ 		goto error;
+ 	if (!isdfs)
+ 		goto out;
+ 
+ 	uuid_gen(&mnt_ctx.mount_id);
+ 	rc = connect_dfs_root(&mnt_ctx, &tl);
+ 	dfs_cache_free_tgts(&tl);
+ 
+ 	if (rc)
+ 		goto error;
+ 
+ 	rc = is_path_remote(&mnt_ctx);
+ 	if (rc == -EREMOTE)
+ 		rc = follow_dfs_link(&mnt_ctx);
+ 	if (rc)
+ 		goto error;
+ 
+ 	setup_server_referral_paths(&mnt_ctx);
  	/*
- 	 * After reconnecting to a different server, unique ids won't
- 	 * match anymore, so we disable serverino. This prevents
- 	 * dentry revalidation to think the dentry are stale (ESTALE).
+ 	 * After reconnecting to a different server, unique ids won't match anymore, so we disable
+ 	 * serverino. This prevents dentry revalidation to think the dentry are stale (ESTALE).
  	 */
  	cifs_autodisable_serverino(cifs_sb);
  	/*
diff --cc fs/cifs/misc.c
index eca42bbeea81,a6089ea53ad7..000000000000
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@@ -1171,36 -1290,9 +1148,17 @@@ int cifs_update_super_prepath(struct ci
  	kfree(cifs_sb->prepath);
  
  	if (prefix && *prefix) {
++<<<<<<< HEAD
 +		cifs_sb->prepath = cifs_sanitize_prepath(prefix, GFP_ATOMIC);
 +		if (!cifs_sb->prepath) {
 +			rc = -ENOMEM;
 +			goto out;
 +		}
++=======
+ 		cifs_sb->prepath = kstrdup(prefix, GFP_ATOMIC);
+ 		if (!cifs_sb->prepath)
+ 			return -ENOMEM;
++>>>>>>> c88f7dcd6d64 (cifs: support nested dfs links over reconnect)
  
  		convert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));
  	} else
* Unmerged path fs/cifs/cifs_dfs_ref.c
diff --git a/fs/cifs/cifs_fs_sb.h b/fs/cifs/cifs_fs_sb.h
index 8d096bf8c931..386538c772b2 100644
--- a/fs/cifs/cifs_fs_sb.h
+++ b/fs/cifs/cifs_fs_sb.h
@@ -69,11 +69,6 @@ struct cifs_sb_info {
 	/* only used when CIFS_MOUNT_USE_PREFIX_PATH is set */
 	char *prepath;
 
-	/*
-	 * Canonical DFS path initially provided by the mount call. We might connect to something
-	 * different via DFS but we want to keep it to do failover properly.
-	 */
-	char *origin_fullpath; /* \\HOST\SHARE\[OPTIONAL PATH] */
 	/* randomly generated 128-bit number for indexing dfs mount groups in referral cache */
 	uuid_t dfs_mount_id;
 	/*
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 976b9d8b3609..0918399c0067 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -705,6 +705,19 @@ struct TCP_Server_Info {
 #endif
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	bool is_dfs_conn; /* if a dfs connection */
+	struct mutex refpath_lock; /* protects leaf_fullpath */
+	/*
+	 * Canonical DFS full paths that were used to chase referrals in mount and reconnect.
+	 *
+	 * origin_fullpath: first or original referral path
+	 * leaf_fullpath: last referral path (might be changed due to nested links in reconnect)
+	 *
+	 * current_fullpath: pointer to either origin_fullpath or leaf_fullpath
+	 * NOTE: cannot be accessed outside cifs_reconnect() and smb2_reconnect()
+	 *
+	 * format: \\HOST\SHARE\[OPTIONAL PATH]
+	 */
+	char *origin_fullpath, *leaf_fullpath, *current_fullpath;
 #endif
 };
 
@@ -1103,7 +1116,6 @@ struct cifs_tcon {
 	struct cached_fid crfid; /* Cached root fid */
 	/* BB add field for back pointer to sb struct(s)? */
 #ifdef CONFIG_CIFS_DFS_UPCALL
-	char *dfs_path; /* canonical DFS path */
 	struct list_head ulist; /* cache update list */
 #endif
 };
@@ -1958,4 +1970,14 @@ static inline bool is_tcon_dfs(struct cifs_tcon *tcon)
 		tcon->share_flags & (SHI1005_FLAGS_DFS | SHI1005_FLAGS_DFS_ROOT);
 }
 
+static inline bool cifs_is_referral_server(struct cifs_tcon *tcon,
+					   const struct dfs_info3_param *ref)
+{
+	/*
+	 * Check if all targets are capable of handling DFS referrals as per
+	 * MS-DFSC 2.2.4 RESP_GET_DFS_REFERRAL.
+	 */
+	return is_tcon_dfs(tcon) || (ref && (ref->flags & DFSREF_REFERRAL_SERVER));
+}
+
 #endif	/* _CIFS_GLOB_H */
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
index 8c76792c0d0f..2ac1db462d0b 100644
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -602,7 +602,7 @@ int smb2_parse_query_directory(struct cifs_tcon *tcon, struct kvec *rsp_iov,
 
 struct super_block *cifs_get_tcp_super(struct TCP_Server_Info *server);
 void cifs_put_tcp_super(struct super_block *sb);
-int update_super_prepath(struct cifs_tcon *tcon, char *prefix);
+int cifs_update_super_prepath(struct cifs_sb_info *cifs_sb, char *prefix);
 char *extract_hostname(const char *unc);
 char *extract_sharename(const char *unc);
 
@@ -629,4 +629,7 @@ static inline int cifs_create_options(struct cifs_sb_info *cifs_sb, int options)
 		return options;
 }
 
+struct super_block *cifs_get_tcon_super(struct cifs_tcon *tcon);
+void cifs_put_tcon_super(struct super_block *sb);
+
 #endif			/* _CIFSPROTO_H */
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/dfs_cache.c b/fs/cifs/dfs_cache.c
index 172fc0b3e8f8..91552c101535 100644
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@ -1363,9 +1363,9 @@ static void mark_for_reconnect_if_needed(struct cifs_tcon *tcon, struct dfs_cach
 }
 
 /* Refresh dfs referral of tcon and mark it for reconnect if needed */
-static int refresh_tcon(struct cifs_ses **sessions, struct cifs_tcon *tcon, bool force_refresh)
+static int __refresh_tcon(const char *path, struct cifs_ses **sessions, struct cifs_tcon *tcon,
+			  bool force_refresh)
 {
-	const char *path = tcon->dfs_path + 1;
 	struct cifs_ses *ses;
 	struct cache_entry *ce;
 	struct dfs_info3_param *refs = NULL;
@@ -1421,6 +1421,20 @@ static int refresh_tcon(struct cifs_ses **sessions, struct cifs_tcon *tcon, bool
 	return rc;
 }
 
+static int refresh_tcon(struct cifs_ses **sessions, struct cifs_tcon *tcon, bool force_refresh)
+{
+	struct TCP_Server_Info *server = tcon->ses->server;
+
+	mutex_lock(&server->refpath_lock);
+	if (strcasecmp(server->leaf_fullpath, server->origin_fullpath))
+		__refresh_tcon(server->leaf_fullpath + 1, sessions, tcon, force_refresh);
+	mutex_unlock(&server->refpath_lock);
+
+	__refresh_tcon(server->origin_fullpath + 1, sessions, tcon, force_refresh);
+
+	return 0;
+}
+
 /**
  * dfs_cache_remount_fs - remount a DFS share
  *
@@ -1434,6 +1448,7 @@ static int refresh_tcon(struct cifs_ses **sessions, struct cifs_tcon *tcon, bool
 int dfs_cache_remount_fs(struct cifs_sb_info *cifs_sb)
 {
 	struct cifs_tcon *tcon;
+	struct TCP_Server_Info *server;
 	struct mount_group *mg;
 	struct cifs_ses *sessions[CACHE_MAX_ENTRIES + 1] = {NULL};
 	int rc;
@@ -1442,13 +1457,15 @@ int dfs_cache_remount_fs(struct cifs_sb_info *cifs_sb)
 		return -EINVAL;
 
 	tcon = cifs_sb_master_tcon(cifs_sb);
-	if (!tcon->dfs_path) {
-		cifs_dbg(FYI, "%s: not a dfs tcon\n", __func__);
+	server = tcon->ses->server;
+
+	if (!server->origin_fullpath) {
+		cifs_dbg(FYI, "%s: not a dfs mount\n", __func__);
 		return 0;
 	}
 
 	if (uuid_is_null(&cifs_sb->dfs_mount_id)) {
-		cifs_dbg(FYI, "%s: tcon has no dfs mount group id\n", __func__);
+		cifs_dbg(FYI, "%s: no dfs mount group id\n", __func__);
 		return -EINVAL;
 	}
 
@@ -1456,7 +1473,7 @@ int dfs_cache_remount_fs(struct cifs_sb_info *cifs_sb)
 	mg = find_mount_group_locked(&cifs_sb->dfs_mount_id);
 	if (IS_ERR(mg)) {
 		mutex_unlock(&mount_group_list_lock);
-		cifs_dbg(FYI, "%s: tcon has ipc session to refresh referral\n", __func__);
+		cifs_dbg(FYI, "%s: no ipc session for refreshing referral\n", __func__);
 		return PTR_ERR(mg);
 	}
 	kref_get(&mg->refcount);
@@ -1497,9 +1514,12 @@ static void refresh_mounts(struct cifs_ses **sessions)
 
 	spin_lock(&cifs_tcp_ses_lock);
 	list_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {
+		if (!server->is_dfs_conn)
+			continue;
+
 		list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
 			list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
-				if (tcon->dfs_path) {
+				if (!tcon->ipc && !tcon->need_reconnect) {
 					tcon->tc_count++;
 					list_add_tail(&tcon->ulist, &tcons);
 				}
@@ -1509,8 +1529,16 @@ static void refresh_mounts(struct cifs_ses **sessions)
 	spin_unlock(&cifs_tcp_ses_lock);
 
 	list_for_each_entry_safe(tcon, ntcon, &tcons, ulist) {
+		struct TCP_Server_Info *server = tcon->ses->server;
+
 		list_del_init(&tcon->ulist);
-		refresh_tcon(sessions, tcon, false);
+
+		mutex_lock(&server->refpath_lock);
+		if (strcasecmp(server->leaf_fullpath, server->origin_fullpath))
+			__refresh_tcon(server->leaf_fullpath + 1, sessions, tcon, false);
+		mutex_unlock(&server->refpath_lock);
+
+		__refresh_tcon(server->origin_fullpath + 1, sessions, tcon, false);
 		cifs_put_tcon(tcon);
 	}
 }
* Unmerged path fs/cifs/misc.c
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index 2fb9ed3f434e..ada2cf74c775 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -2788,6 +2788,7 @@ smb2_get_dfs_refer(const unsigned int xid, struct cifs_ses *ses,
 	struct fsctl_get_dfs_referral_req *dfs_req = NULL;
 	struct get_dfs_referral_rsp *dfs_rsp = NULL;
 	u32 dfs_req_size = 0, dfs_rsp_size = 0;
+	int retry_count = 0;
 
 	cifs_dbg(FYI, "%s: path: %s\n", __func__, search_name);
 
@@ -2839,11 +2840,14 @@ smb2_get_dfs_refer(const unsigned int xid, struct cifs_ses *ses,
 				true /* is_fsctl */,
 				(char *)dfs_req, dfs_req_size, CIFSMaxBufSize,
 				(char **)&dfs_rsp, &dfs_rsp_size);
-	} while (rc == -EAGAIN);
+		if (!is_retryable_error(rc))
+			break;
+		usleep_range(512, 2048);
+	} while (++retry_count < 5);
 
 	if (rc) {
-		if ((rc != -ENOENT) && (rc != -EOPNOTSUPP))
-			cifs_tcon_dbg(VFS, "ioctl error in %s rc=%d\n", __func__, rc);
+		if (!is_retryable_error(rc) && rc != -ENOENT && rc != -EOPNOTSUPP)
+			cifs_tcon_dbg(VFS, "%s: ioctl error: rc=%d\n", __func__, rc);
 		goto out;
 	}
 
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index cbf14ad2ba8d..1b29859590ba 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -168,7 +168,11 @@ smb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon,
 	if (tcon == NULL)
 		return 0;
 
-	if (smb2_command == SMB2_TREE_CONNECT)
+	/*
+	 * Need to also skip SMB2_IOCTL because it is used for checking nested dfs links in
+	 * cifs_tree_connect().
+	 */
+	if (smb2_command == SMB2_TREE_CONNECT || smb2_command == SMB2_IOCTL)
 		return 0;
 
 	if (tcon->tidStatus == CifsExiting) {
