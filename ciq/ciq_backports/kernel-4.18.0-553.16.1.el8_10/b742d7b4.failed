xfs: use deferred frees for btree block freeing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Dave Chinner <dchinner@redhat.com>
commit b742d7b4f0e03df25c2a772adcded35044b625ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/b742d7b4.failed

Btrees that aren't freespace management trees use the normal extent
allocation and freeing routines for their blocks. Hence when a btree
block is freed, a direct call to xfs_free_extent() is made and the
extent is immediately freed. This puts the entire free space
management btrees under this path, so we are stacking btrees on
btrees in the call stack. The inobt, finobt and refcount btrees
all do this.

However, the bmap btree does not do this - it calls
xfs_free_extent_later() to defer the extent free operation via an
XEFI and hence it gets processed in deferred operation processing
during the commit of the primary transaction (i.e. via intent
chaining).

We need to change xfs_free_extent() to behave in a non-blocking
manner so that we can avoid deadlocks with busy extents near ENOSPC
in transactions that free multiple extents. Inserting or removing a
record from a btree can cause a multi-level tree merge operation and
that will free multiple blocks from the btree in a single
transaction. i.e. we can call xfs_free_extent() multiple times, and
hence the btree manipulation transaction is vulnerable to this busy
extent deadlock vector.

To fix this, convert all the remaining callers of xfs_free_extent()
to use xfs_free_extent_later() to queue XEFIs and hence defer
processing of the extent frees to a context that can be safely
restarted if a deadlock condition is detected.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Chandan Babu R <chandan.babu@oracle.com>
(cherry picked from commit b742d7b4f0e03df25c2a772adcded35044b625ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_ag.c
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_alloc.h
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap_btree.c
#	fs/xfs/libxfs/xfs_ialloc.c
#	fs/xfs/libxfs/xfs_ialloc_btree.c
#	fs/xfs/libxfs/xfs_refcount.c
#	fs/xfs/libxfs/xfs_refcount_btree.c
#	fs/xfs/xfs_extfree_item.c
#	fs/xfs/xfs_reflink.c
diff --cc fs/xfs/libxfs/xfs_ag.c
index 23949ec287d3,e9cc481b4ddf..000000000000
--- a/fs/xfs/libxfs/xfs_ag.c
+++ b/fs/xfs/libxfs/xfs_ag.c
@@@ -850,7 -984,10 +850,14 @@@ xfs_ag_shrink_space
  		if (err2 != -ENOSPC)
  			goto resv_err;
  
++<<<<<<< HEAD
 +		__xfs_bmap_add_free(*tpp, args.fsbno, delta, NULL, true);
++=======
+ 		err2 = __xfs_free_extent_later(*tpp, args.fsbno, delta, NULL,
+ 				XFS_AG_RESV_NONE, true);
+ 		if (err2)
+ 			goto resv_err;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  
  		/*
  		 * Roll the transaction before trying to re-init the per-ag
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 2debb6bf24be,713b4712704f..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -2487,21 -2439,89 +2487,100 @@@ xfs_defer_agfl_block
  	struct xfs_owner_info		*oinfo)
  {
  	struct xfs_mount		*mp = tp->t_mountp;
 -	struct xfs_extent_free_item	*xefi;
 +	struct xfs_extent_free_item	*new;		/* new element */
  
 -	ASSERT(xfs_extfree_item_cache != NULL);
 +	ASSERT(xfs_bmap_free_item_zone != NULL);
  	ASSERT(oinfo != NULL);
  
 -	xefi = kmem_cache_zalloc(xfs_extfree_item_cache,
 +	new = kmem_cache_alloc(xfs_bmap_free_item_zone,
  			       GFP_KERNEL | __GFP_NOFAIL);
++<<<<<<< HEAD
 +	new->xefi_startblock = XFS_AGB_TO_FSB(mp, agno, agbno);
 +	new->xefi_blockcount = 1;
 +	new->xefi_oinfo = *oinfo;
 +	new->xefi_skip_discard = false;
 +
 +	trace_xfs_agfl_free_defer(mp, agno, 0, agbno, 1);
 +
 +	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_AGFL_FREE, &new->xefi_list);
++=======
+ 	xefi->xefi_startblock = XFS_AGB_TO_FSB(mp, agno, agbno);
+ 	xefi->xefi_blockcount = 1;
+ 	xefi->xefi_owner = oinfo->oi_owner;
+ 	xefi->xefi_agresv = XFS_AG_RESV_AGFL;
+ 
+ 	if (XFS_IS_CORRUPT(mp, !xfs_verify_fsbno(mp, xefi->xefi_startblock)))
+ 		return -EFSCORRUPTED;
+ 
+ 	trace_xfs_agfl_free_defer(mp, agno, 0, agbno, 1);
+ 
+ 	xfs_extent_free_get_group(mp, xefi);
+ 	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_AGFL_FREE, &xefi->xefi_list);
+ 	return 0;
+ }
+ 
+ /*
+  * Add the extent to the list of extents to be free at transaction end.
+  * The list is maintained sorted (by block number).
+  */
+ int
+ __xfs_free_extent_later(
+ 	struct xfs_trans		*tp,
+ 	xfs_fsblock_t			bno,
+ 	xfs_filblks_t			len,
+ 	const struct xfs_owner_info	*oinfo,
+ 	enum xfs_ag_resv_type		type,
+ 	bool				skip_discard)
+ {
+ 	struct xfs_extent_free_item	*xefi;
+ 	struct xfs_mount		*mp = tp->t_mountp;
+ #ifdef DEBUG
+ 	xfs_agnumber_t			agno;
+ 	xfs_agblock_t			agbno;
+ 
+ 	ASSERT(bno != NULLFSBLOCK);
+ 	ASSERT(len > 0);
+ 	ASSERT(len <= XFS_MAX_BMBT_EXTLEN);
+ 	ASSERT(!isnullstartblock(bno));
+ 	agno = XFS_FSB_TO_AGNO(mp, bno);
+ 	agbno = XFS_FSB_TO_AGBNO(mp, bno);
+ 	ASSERT(agno < mp->m_sb.sb_agcount);
+ 	ASSERT(agbno < mp->m_sb.sb_agblocks);
+ 	ASSERT(len < mp->m_sb.sb_agblocks);
+ 	ASSERT(agbno + len <= mp->m_sb.sb_agblocks);
+ #endif
+ 	ASSERT(xfs_extfree_item_cache != NULL);
+ 	ASSERT(type != XFS_AG_RESV_AGFL);
+ 
+ 	if (XFS_IS_CORRUPT(mp, !xfs_verify_fsbext(mp, bno, len)))
+ 		return -EFSCORRUPTED;
+ 
+ 	xefi = kmem_cache_zalloc(xfs_extfree_item_cache,
+ 			       GFP_KERNEL | __GFP_NOFAIL);
+ 	xefi->xefi_startblock = bno;
+ 	xefi->xefi_blockcount = (xfs_extlen_t)len;
+ 	xefi->xefi_agresv = type;
+ 	if (skip_discard)
+ 		xefi->xefi_flags |= XFS_EFI_SKIP_DISCARD;
+ 	if (oinfo) {
+ 		ASSERT(oinfo->oi_offset == 0);
+ 
+ 		if (oinfo->oi_flags & XFS_OWNER_INFO_ATTR_FORK)
+ 			xefi->xefi_flags |= XFS_EFI_ATTR_FORK;
+ 		if (oinfo->oi_flags & XFS_OWNER_INFO_BMBT_BLOCK)
+ 			xefi->xefi_flags |= XFS_EFI_BMBT_BLOCK;
+ 		xefi->xefi_owner = oinfo->oi_owner;
+ 	} else {
+ 		xefi->xefi_owner = XFS_RMAP_OWN_NULL;
+ 	}
+ 	trace_xfs_bmap_free_defer(mp,
+ 			XFS_FSB_TO_AGNO(tp->t_mountp, bno), 0,
+ 			XFS_FSB_TO_AGBNO(tp->t_mountp, bno), len);
+ 
+ 	xfs_extent_free_get_group(mp, xefi);
+ 	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_FREE, &xefi->xefi_list);
+ 	return 0;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  }
  
  #ifdef DEBUG
diff --cc fs/xfs/libxfs/xfs_alloc.h
index 8f05e92ddf79,a3e519577e09..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.h
+++ b/fs/xfs/libxfs/xfs_alloc.h
@@@ -247,4 -230,46 +247,49 @@@ xfs_buf_to_agfl_bno
  	return bp->b_addr;
  }
  
++<<<<<<< HEAD
++=======
+ int __xfs_free_extent_later(struct xfs_trans *tp, xfs_fsblock_t bno,
+ 		xfs_filblks_t len, const struct xfs_owner_info *oinfo,
+ 		enum xfs_ag_resv_type type, bool skip_discard);
+ 
+ /*
+  * List of extents to be free "later".
+  * The list is kept sorted on xbf_startblock.
+  */
+ struct xfs_extent_free_item {
+ 	struct list_head	xefi_list;
+ 	uint64_t		xefi_owner;
+ 	xfs_fsblock_t		xefi_startblock;/* starting fs block number */
+ 	xfs_extlen_t		xefi_blockcount;/* number of blocks in extent */
+ 	struct xfs_perag	*xefi_pag;
+ 	unsigned int		xefi_flags;
+ 	enum xfs_ag_resv_type	xefi_agresv;
+ };
+ 
+ void xfs_extent_free_get_group(struct xfs_mount *mp,
+ 		struct xfs_extent_free_item *xefi);
+ 
+ #define XFS_EFI_SKIP_DISCARD	(1U << 0) /* don't issue discard */
+ #define XFS_EFI_ATTR_FORK	(1U << 1) /* freeing attr fork block */
+ #define XFS_EFI_BMBT_BLOCK	(1U << 2) /* freeing bmap btree block */
+ 
+ static inline int
+ xfs_free_extent_later(
+ 	struct xfs_trans		*tp,
+ 	xfs_fsblock_t			bno,
+ 	xfs_filblks_t			len,
+ 	const struct xfs_owner_info	*oinfo,
+ 	enum xfs_ag_resv_type		type)
+ {
+ 	return __xfs_free_extent_later(tp, bno, len, oinfo, type, false);
+ }
+ 
+ 
+ extern struct kmem_cache	*xfs_extfree_item_cache;
+ 
+ int __init xfs_extfree_intent_init_cache(void);
+ void xfs_extfree_intent_destroy_cache(void);
+ 
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  #endif	/* __XFS_ALLOC_H__ */
diff --cc fs/xfs/libxfs/xfs_bmap.c
index d4005787a5af,30c931b38853..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -624,8 -572,13 +624,16 @@@ xfs_bmap_btree_to_extents
  	cblock = XFS_BUF_TO_BLOCK(cbp);
  	if ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))
  		return error;
 -
  	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, whichfork);
++<<<<<<< HEAD
 +	xfs_bmap_add_free(cur->bc_tp, cbno, 1, &oinfo);
++=======
+ 	error = xfs_free_extent_later(cur->bc_tp, cbno, 1, &oinfo,
+ 			XFS_AG_RESV_NONE);
+ 	if (error)
+ 		return error;
+ 
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  	ip->i_nblocks--;
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
  	xfs_trans_binval(tp, cbp);
@@@ -5285,10 -5235,13 +5293,18 @@@ xfs_bmap_del_extent_real
  		if (xfs_is_reflink_inode(ip) && whichfork == XFS_DATA_FORK) {
  			xfs_refcount_decrease_extent(tp, del);
  		} else {
 -			error = __xfs_free_extent_later(tp, del->br_startblock,
 +			__xfs_bmap_add_free(tp, del->br_startblock,
  					del->br_blockcount, NULL,
++<<<<<<< HEAD
 +					(bflags & XFS_BMAPI_NODISCARD) ||
 +					del->br_state == XFS_EXT_UNWRITTEN);
++=======
+ 					XFS_AG_RESV_NONE,
+ 					((bflags & XFS_BMAPI_NODISCARD) ||
+ 					del->br_state == XFS_EXT_UNWRITTEN));
+ 			if (error)
+ 				goto done;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  		}
  	}
  
diff --cc fs/xfs/libxfs/xfs_bmap_btree.c
index 1ceba020940e,bf3f1b36fdd2..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@@ -282,13 -266,17 +282,21 @@@ xfs_bmbt_free_block
  	struct xfs_mount	*mp = cur->bc_mp;
  	struct xfs_inode	*ip = cur->bc_ino.ip;
  	struct xfs_trans	*tp = cur->bc_tp;
 -	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, xfs_buf_daddr(bp));
 +	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));
  	struct xfs_owner_info	oinfo;
 -	int			error;
  
  	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, cur->bc_ino.whichfork);
++<<<<<<< HEAD
 +	xfs_bmap_add_free(cur->bc_tp, fsbno, 1, &oinfo);
++=======
+ 	error = xfs_free_extent_later(cur->bc_tp, fsbno, 1, &oinfo,
+ 			XFS_AG_RESV_NONE);
+ 	if (error)
+ 		return error;
+ 
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  	ip->i_nblocks--;
 +
  	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
  	return 0;
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 19eb7ec0103f,1e5fafbc0cdb..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -1828,10 -1851,10 +1828,17 @@@ xfs_difree_inode_chunk
  
  	if (!xfs_inobt_issparse(rec->ir_holemask)) {
  		/* not sparse, calculate extent info directly */
++<<<<<<< HEAD
 +		xfs_bmap_add_free(tp, XFS_AGB_TO_FSB(mp, agno, sagbno),
 +				  M_IGEO(mp)->ialloc_blks,
 +				  &XFS_RMAP_OINFO_INODES);
 +		return;
++=======
+ 		return xfs_free_extent_later(tp,
+ 				XFS_AGB_TO_FSB(mp, agno, sagbno),
+ 				M_IGEO(mp)->ialloc_blks, &XFS_RMAP_OINFO_INODES,
+ 				XFS_AG_RESV_NONE);
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  	}
  
  	/* holemask is only 16-bits (fits in an unsigned long) */
@@@ -1873,8 -1898,11 +1880,16 @@@
  
  		ASSERT(agbno % mp->m_sb.sb_spino_align == 0);
  		ASSERT(contigblk % mp->m_sb.sb_spino_align == 0);
++<<<<<<< HEAD
 +		xfs_bmap_add_free(tp, XFS_AGB_TO_FSB(mp, agno, agbno),
 +				  contigblk, &XFS_RMAP_OINFO_INODES);
++=======
+ 		error = xfs_free_extent_later(tp,
+ 				XFS_AGB_TO_FSB(mp, agno, agbno), contigblk,
+ 				&XFS_RMAP_OINFO_INODES, XFS_AG_RESV_NONE);
+ 		if (error)
+ 			return error;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  
  		/* reset range to current bit and carry on... */
  		startidx = endidx = nextbit;
diff --cc fs/xfs/libxfs/xfs_ialloc_btree.c
index 823a038939f8,9258f01c0015..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc_btree.c
+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c
@@@ -154,9 -156,11 +154,14 @@@ __xfs_inobt_free_block
  	struct xfs_buf		*bp,
  	enum xfs_ag_resv_type	resv)
  {
 -	xfs_fsblock_t		fsbno;
 -
  	xfs_inobt_mod_blockcount(cur, -1);
++<<<<<<< HEAD
 +	return xfs_free_extent(cur->bc_tp,
 +			XFS_DADDR_TO_FSB(cur->bc_mp, XFS_BUF_ADDR(bp)), 1,
++=======
+ 	fsbno = XFS_DADDR_TO_FSB(cur->bc_mp, xfs_buf_daddr(bp));
+ 	return xfs_free_extent_later(cur->bc_tp, fsbno, 1,
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  			&XFS_RMAP_OINFO_INOBT, resv);
  }
  
diff --cc fs/xfs/libxfs/xfs_refcount.c
index d48712931122,70ab113c9cea..000000000000
--- a/fs/xfs/libxfs/xfs_refcount.c
+++ b/fs/xfs/libxfs/xfs_refcount.c
@@@ -1088,8 -1151,11 +1088,16 @@@ xfs_refcount_adjust_extents
  				fsbno = XFS_AGB_TO_FSB(cur->bc_mp,
  						cur->bc_ag.pag->pag_agno,
  						tmp.rc_startblock);
++<<<<<<< HEAD
 +				xfs_bmap_add_free(cur->bc_tp, fsbno,
 +						  tmp.rc_blockcount, oinfo);
++=======
+ 				error = xfs_free_extent_later(cur->bc_tp, fsbno,
+ 						  tmp.rc_blockcount, NULL,
+ 						  XFS_AG_RESV_NONE);
+ 				if (error)
+ 					goto out_error;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  			}
  
  			(*agbno) += tmp.rc_blockcount;
@@@ -1133,8 -1213,11 +1141,16 @@@
  			fsbno = XFS_AGB_TO_FSB(cur->bc_mp,
  					cur->bc_ag.pag->pag_agno,
  					ext.rc_startblock);
++<<<<<<< HEAD
 +			xfs_bmap_add_free(cur->bc_tp, fsbno, ext.rc_blockcount,
 +					  oinfo);
++=======
+ 			error = xfs_free_extent_later(cur->bc_tp, fsbno,
+ 					ext.rc_blockcount, NULL,
+ 					XFS_AG_RESV_NONE);
+ 			if (error)
+ 				goto out_error;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  		}
  
  skip:
@@@ -1858,7 -1982,11 +1874,15 @@@ xfs_refcount_recover_cow_leftovers
  				rr->rr_rrec.rc_blockcount);
  
  		/* Free the block. */
++<<<<<<< HEAD
 +		xfs_bmap_add_free(tp, fsb, rr->rr_rrec.rc_blockcount, NULL);
++=======
+ 		error = xfs_free_extent_later(tp, fsb,
+ 				rr->rr_rrec.rc_blockcount, NULL,
+ 				XFS_AG_RESV_NONE);
+ 		if (error)
+ 			goto out_trans;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  
  		error = xfs_trans_commit(tp);
  		if (error)
diff --cc fs/xfs/libxfs/xfs_refcount_btree.c
index 92d336c17e83,5c3987d8dc24..000000000000
--- a/fs/xfs/libxfs/xfs_refcount_btree.c
+++ b/fs/xfs/libxfs/xfs_refcount_btree.c
@@@ -102,19 -105,14 +102,28 @@@ xfs_refcountbt_free_block
  	struct xfs_mount	*mp = cur->bc_mp;
  	struct xfs_buf		*agbp = cur->bc_ag.agbp;
  	struct xfs_agf		*agf = agbp->b_addr;
++<<<<<<< HEAD
 +	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));
 +	int			error;
++=======
+ 	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, xfs_buf_daddr(bp));
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  
  	trace_xfs_refcountbt_free_block(cur->bc_mp, cur->bc_ag.pag->pag_agno,
  			XFS_FSB_TO_AGBNO(cur->bc_mp, fsbno), 1);
  	be32_add_cpu(&agf->agf_refcount_blocks, -1);
  	xfs_alloc_log_agf(cur->bc_tp, agbp, XFS_AGF_REFCOUNT_BLOCKS);
++<<<<<<< HEAD
 +	error = xfs_free_extent(cur->bc_tp, fsbno, 1, &XFS_RMAP_OINFO_REFC,
 +			XFS_AG_RESV_METADATA);
 +	if (error)
 +		return error;
 +
 +	return error;
++=======
+ 	return xfs_free_extent_later(cur->bc_tp, fsbno, 1,
+ 			&XFS_RMAP_OINFO_REFC, XFS_AG_RESV_METADATA);
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  }
  
  STATIC int
diff --cc fs/xfs/xfs_extfree_item.c
index f0baca0aa89e,873653b825e4..000000000000
--- a/fs/xfs/xfs_extfree_item.c
+++ b/fs/xfs/xfs_extfree_item.c
@@@ -364,15 -350,24 +364,30 @@@ xfs_trans_free_extent
  	struct xfs_mount		*mp = tp->t_mountp;
  	struct xfs_extent		*extp;
  	uint				next_extent;
 +	xfs_agnumber_t			agno = XFS_FSB_TO_AGNO(mp, start_block);
  	xfs_agblock_t			agbno = XFS_FSB_TO_AGBNO(mp,
 -							xefi->xefi_startblock);
 +								start_block);
  	int				error;
  
++<<<<<<< HEAD
 +	trace_xfs_bmap_free_deferred(tp->t_mountp, agno, 0, agbno, ext_len);
++=======
+ 	oinfo.oi_owner = xefi->xefi_owner;
+ 	if (xefi->xefi_flags & XFS_EFI_ATTR_FORK)
+ 		oinfo.oi_flags |= XFS_OWNER_INFO_ATTR_FORK;
+ 	if (xefi->xefi_flags & XFS_EFI_BMBT_BLOCK)
+ 		oinfo.oi_flags |= XFS_OWNER_INFO_BMBT_BLOCK;
+ 
+ 	trace_xfs_bmap_free_deferred(tp->t_mountp, xefi->xefi_pag->pag_agno, 0,
+ 			agbno, xefi->xefi_blockcount);
+ 
+ 	error = __xfs_free_extent(tp, xefi->xefi_pag, agbno,
+ 			xefi->xefi_blockcount, &oinfo, xefi->xefi_agresv,
+ 			xefi->xefi_flags & XFS_EFI_SKIP_DISCARD);
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  
 +	error = __xfs_free_extent(tp, start_block, ext_len,
 +				  oinfo, XFS_AG_RESV_NONE, skip_discard);
  	/*
  	 * Mark the transaction dirty, even on error. This ensures the
  	 * transaction is aborted, which:
@@@ -627,10 -642,23 +642,19 @@@ xfs_efi_item_recover
  	efdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);
  
  	for (i = 0; i < efip->efi_format.efi_nextents; i++) {
++<<<<<<< HEAD
++=======
+ 		struct xfs_extent_free_item	fake = {
+ 			.xefi_owner		= XFS_RMAP_OWN_UNKNOWN,
+ 			.xefi_agresv		= XFS_AG_RESV_NONE,
+ 		};
+ 		struct xfs_extent		*extp;
+ 
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  		extp = &efip->efi_format.efi_extents[i];
 -
 -		fake.xefi_startblock = extp->ext_start;
 -		fake.xefi_blockcount = extp->ext_len;
 -
 -		xfs_extent_free_get_group(mp, &fake);
 -		error = xfs_trans_free_extent(tp, efdp, &fake);
 -		xfs_extent_free_put_group(&fake);
 -		if (error == -EFSCORRUPTED)
 -			XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,
 -					extp, sizeof(*extp));
 +		error = xfs_trans_free_extent(tp, efdp, extp->ext_start,
 +					      extp->ext_len,
 +					      &XFS_RMAP_OINFO_ANY_OWNER, false);
  		if (error)
  			goto abort_error;
  
diff --cc fs/xfs/xfs_reflink.c
index 64f0a9bc5183,eb9102453aff..000000000000
--- a/fs/xfs/xfs_reflink.c
+++ b/fs/xfs/xfs_reflink.c
@@@ -615,8 -616,11 +615,16 @@@ xfs_reflink_cancel_cow_blocks
  			xfs_refcount_free_cow_extent(*tpp, del.br_startblock,
  					del.br_blockcount);
  
++<<<<<<< HEAD
 +			xfs_bmap_add_free(*tpp, del.br_startblock,
 +					  del.br_blockcount, NULL);
++=======
+ 			error = xfs_free_extent_later(*tpp, del.br_startblock,
+ 					del.br_blockcount, NULL,
+ 					XFS_AG_RESV_NONE);
+ 			if (error)
+ 				break;
++>>>>>>> b742d7b4f0e0 (xfs: use deferred frees for btree block freeing)
  
  			/* Roll the transaction */
  			error = xfs_defer_finish(tpp);
* Unmerged path fs/xfs/libxfs/xfs_ag.c
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/libxfs/xfs_alloc.h
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
* Unmerged path fs/xfs/libxfs/xfs_ialloc_btree.c
* Unmerged path fs/xfs/libxfs/xfs_refcount.c
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/xfs_extfree_item.c
* Unmerged path fs/xfs/xfs_reflink.c
