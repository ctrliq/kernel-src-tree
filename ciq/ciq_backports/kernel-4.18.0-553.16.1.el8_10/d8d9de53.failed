cifs: Move more definitions into the shared area

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit d8d9de532de9fa3f3ee0c1c96c42da9507fbade6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/d8d9de53.failed

Move SMB2_SessionSetup, SMB2_Close, SMB2_Read, SMB2_Write and
SMB2_ChangeNotify commands into smbfs_common/smb2pdu.h

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Reviewed-by: Namjae Jeon <linkinjeon@kernel.org>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit d8d9de532de9fa3f3ee0c1c96c42da9507fbade6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2pdu.c
#	fs/cifs/smb2pdu.h
#	fs/smbfs_common/smb2pdu.h
diff --cc fs/cifs/smb2pdu.c
index fcb73ef87431,4fe49b007651..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -3847,8 -3888,8 +3847,13 @@@ smb2_new_read_req(void **buf, unsigned 
  	unsigned int remaining_bytes, int request_type)
  {
  	int rc = -EACCES;
++<<<<<<< HEAD
 +	struct smb2_read_plain_req *req = NULL;
 +	struct smb2_sync_hdr *shdr;
++=======
+ 	struct smb2_read_req *req = NULL;
+ 	struct smb2_hdr *shdr;
++>>>>>>> d8d9de532de9 (cifs: Move more definitions into the shared area)
  	struct TCP_Server_Info *server = io_parms->server;
  
  	rc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, server,
@@@ -3859,11 -3900,11 +3864,11 @@@
  	if (server == NULL)
  		return -ECONNABORTED;
  
 -	shdr = &req->hdr;
 -	shdr->Id.SyncId.ProcessId = cpu_to_le32(io_parms->pid);
 +	shdr = &req->sync_hdr;
 +	shdr->ProcessId = cpu_to_le32(io_parms->pid);
  
- 	req->PersistentFileId = io_parms->persistent_fid;
- 	req->VolatileFileId = io_parms->volatile_fid;
+ 	req->PersistentFileId = cpu_to_le64(io_parms->persistent_fid);
+ 	req->VolatileFileId = cpu_to_le64(io_parms->volatile_fid);
  	req->ReadChannelInfoOffset = 0; /* reserved */
  	req->ReadChannelInfoLength = 0; /* reserved */
  	req->Channel = 0; /* reserved */
@@@ -3921,10 -3962,10 +3926,17 @@@
  			 * Related requests use info from previous read request
  			 * in chain.
  			 */
++<<<<<<< HEAD
 +			shdr->SessionId = 0xFFFFFFFFFFFFFFFF;
 +			shdr->TreeId = 0xFFFFFFFF;
 +			req->PersistentFileId = 0xFFFFFFFFFFFFFFFF;
 +			req->VolatileFileId = 0xFFFFFFFFFFFFFFFF;
++=======
+ 			shdr->SessionId = cpu_to_le64(0xFFFFFFFFFFFFFFFF);
+ 			shdr->Id.SyncId.TreeId = cpu_to_le32(0xFFFFFFFF);
+ 			req->PersistentFileId = cpu_to_le64(0xFFFFFFFFFFFFFFFF);
+ 			req->VolatileFileId = cpu_to_le64(0xFFFFFFFFFFFFFFFF);
++>>>>>>> d8d9de532de9 (cifs: Move more definitions into the shared area)
  		}
  	}
  	if (remaining_bytes > io_parms->length)
@@@ -4286,11 -4330,11 +4301,11 @@@ smb2_async_writev(struct cifs_writedat
  	if (smb3_encryption_required(tcon))
  		flags |= CIFS_TRANSFORM_REQ;
  
 -	shdr = (struct smb2_hdr *)req;
 -	shdr->Id.SyncId.ProcessId = cpu_to_le32(wdata->cfile->pid);
 +	shdr = (struct smb2_sync_hdr *)req;
 +	shdr->ProcessId = cpu_to_le32(wdata->cfile->pid);
  
- 	req->PersistentFileId = wdata->cfile->fid.persistent_fid;
- 	req->VolatileFileId = wdata->cfile->fid.volatile_fid;
+ 	req->PersistentFileId = cpu_to_le64(wdata->cfile->fid.persistent_fid);
+ 	req->VolatileFileId = cpu_to_le64(wdata->cfile->fid.volatile_fid);
  	req->WriteChannelInfoOffset = 0;
  	req->WriteChannelInfoLength = 0;
  	req->Channel = 0;
@@@ -4438,10 -4483,10 +4454,10 @@@ SMB2_write(const unsigned int xid, stru
  	if (smb3_encryption_required(io_parms->tcon))
  		flags |= CIFS_TRANSFORM_REQ;
  
 -	req->hdr.Id.SyncId.ProcessId = cpu_to_le32(io_parms->pid);
 +	req->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);
  
- 	req->PersistentFileId = io_parms->persistent_fid;
- 	req->VolatileFileId = io_parms->volatile_fid;
+ 	req->PersistentFileId = cpu_to_le64(io_parms->persistent_fid);
+ 	req->VolatileFileId = cpu_to_le64(io_parms->volatile_fid);
  	req->WriteChannelInfoOffset = 0;
  	req->WriteChannelInfoLength = 0;
  	req->Channel = 0;
diff --cc fs/cifs/smb2pdu.h
index 72185c3566c9,56f3cc568028..000000000000
--- a/fs/cifs/smb2pdu.h
+++ b/fs/cifs/smb2pdu.h
@@@ -271,390 -115,6 +271,393 @@@ struct share_redirect_error_context_rs
  	/* __u8 ResourceName[] */ /* Name of share as counted Unicode string */
  } __packed;
  
++<<<<<<< HEAD
 +#define SMB2_CLIENT_GUID_SIZE 16
 +
 +struct smb2_negotiate_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 36 */
 +	__le16 DialectCount;
 +	__le16 SecurityMode;
 +	__le16 Reserved;	/* MBZ */
 +	__le32 Capabilities;
 +	__u8   ClientGUID[SMB2_CLIENT_GUID_SIZE];
 +	/* In SMB3.02 and earlier next three were MBZ le64 ClientStartTime */
 +	__le32 NegotiateContextOffset; /* SMB3.1.1 only. MBZ earlier */
 +	__le16 NegotiateContextCount;  /* SMB3.1.1 only. MBZ earlier */
 +	__le16 Reserved2;
 +	__le16 Dialects[4]; /* BB expand this if autonegotiate > 4 dialects */
 +} __packed;
 +
 +/* Dialects */
 +#define SMB10_PROT_ID 0x0000 /* local only, not sent on wire w/CIFS negprot */
 +#define SMB20_PROT_ID 0x0202
 +#define SMB21_PROT_ID 0x0210
 +#define SMB30_PROT_ID 0x0300
 +#define SMB302_PROT_ID 0x0302
 +#define SMB311_PROT_ID 0x0311
 +#define BAD_PROT_ID   0xFFFF
 +
 +/* SecurityMode flags */
 +#define	SMB2_NEGOTIATE_SIGNING_ENABLED	0x0001
 +#define SMB2_NEGOTIATE_SIGNING_REQUIRED	0x0002
 +#define SMB2_SEC_MODE_FLAGS_ALL		0x0003
 +
 +/* Capabilities flags */
 +#define SMB2_GLOBAL_CAP_DFS		0x00000001
 +#define SMB2_GLOBAL_CAP_LEASING		0x00000002 /* Resp only New to SMB2.1 */
 +#define SMB2_GLOBAL_CAP_LARGE_MTU	0X00000004 /* Resp only New to SMB2.1 */
 +#define SMB2_GLOBAL_CAP_MULTI_CHANNEL	0x00000008 /* New to SMB3 */
 +#define SMB2_GLOBAL_CAP_PERSISTENT_HANDLES 0x00000010 /* New to SMB3 */
 +#define SMB2_GLOBAL_CAP_DIRECTORY_LEASING  0x00000020 /* New to SMB3 */
 +#define SMB2_GLOBAL_CAP_ENCRYPTION	0x00000040 /* New to SMB3 */
 +/* Internal types */
 +#define SMB2_NT_FIND			0x00100000
 +#define SMB2_LARGE_FILES		0x00200000
 +
 +
 +/* Negotiate Contexts - ContextTypes. See MS-SMB2 section 2.2.3.1 for details */
 +#define SMB2_PREAUTH_INTEGRITY_CAPABILITIES	cpu_to_le16(1)
 +#define SMB2_ENCRYPTION_CAPABILITIES		cpu_to_le16(2)
 +#define SMB2_COMPRESSION_CAPABILITIES		cpu_to_le16(3)
 +#define SMB2_NETNAME_NEGOTIATE_CONTEXT_ID	cpu_to_le16(5)
 +#define SMB2_TRANSPORT_CAPABILITIES		cpu_to_le16(6)
 +#define SMB2_RDMA_TRANSFORM_CAPABILITIES	cpu_to_le16(7)
 +#define SMB2_SIGNING_CAPABILITIES		cpu_to_le16(8)
 +#define SMB2_POSIX_EXTENSIONS_AVAILABLE		cpu_to_le16(0x100)
 +
 +struct smb2_neg_context {
 +	__le16	ContextType;
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	/* Followed by array of data */
 +} __packed;
 +
 +#define SMB311_LINUX_CLIENT_SALT_SIZE			32
 +/* Hash Algorithm Types */
 +#define SMB2_PREAUTH_INTEGRITY_SHA512	cpu_to_le16(0x0001)
 +#define SMB2_PREAUTH_HASH_SIZE 64
 +
 +/*
 + * SaltLength that the server send can be zero, so the only three required
 + * fields (all __le16) end up six bytes total, so the minimum context data len
 + * in the response is six bytes which accounts for
 + *
 + *      HashAlgorithmCount, SaltLength, and 1 HashAlgorithm.
 + */
 +#define MIN_PREAUTH_CTXT_DATA_LEN 6
 +
 +struct smb2_preauth_neg_context {
 +	__le16	ContextType; /* 1 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	__le16	HashAlgorithmCount; /* 1 */
 +	__le16	SaltLength;
 +	__le16	HashAlgorithms; /* HashAlgorithms[0] since only one defined */
 +	__u8	Salt[SMB311_LINUX_CLIENT_SALT_SIZE];
 +} __packed;
 +
 +/* Encryption Algorithms Ciphers */
 +#define SMB2_ENCRYPTION_AES128_CCM	cpu_to_le16(0x0001)
 +#define SMB2_ENCRYPTION_AES128_GCM	cpu_to_le16(0x0002)
 +/* we currently do not request AES256_CCM since presumably GCM faster */
 +#define SMB2_ENCRYPTION_AES256_CCM      cpu_to_le16(0x0003)
 +#define SMB2_ENCRYPTION_AES256_GCM      cpu_to_le16(0x0004)
 +
 +/* Min encrypt context data is one cipher so 2 bytes + 2 byte count field */
 +#define MIN_ENCRYPT_CTXT_DATA_LEN	4
 +struct smb2_encryption_neg_context {
 +	__le16	ContextType; /* 2 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	/* CipherCount usally 2, but can be 3 when AES256-GCM enabled */
 +	__le16	CipherCount; /* AES128-GCM and AES128-CCM by default */
 +	__le16	Ciphers[3];
 +} __packed;
 +
 +/* See MS-SMB2 2.2.3.1.3 */
 +#define SMB3_COMPRESS_NONE	cpu_to_le16(0x0000)
 +#define SMB3_COMPRESS_LZNT1	cpu_to_le16(0x0001)
 +#define SMB3_COMPRESS_LZ77	cpu_to_le16(0x0002)
 +#define SMB3_COMPRESS_LZ77_HUFF	cpu_to_le16(0x0003)
 +/* Pattern scanning algorithm See MS-SMB2 3.1.4.4.1 */
 +#define SMB3_COMPRESS_PATTERN	cpu_to_le16(0x0004) /* Pattern_V1 */
 +
 +/* Compression Flags */
 +#define SMB2_COMPRESSION_CAPABILITIES_FLAG_NONE		cpu_to_le32(0x00000000)
 +#define SMB2_COMPRESSION_CAPABILITIES_FLAG_CHAINED	cpu_to_le32(0x00000001)
 +
 +struct smb2_compression_capabilities_context {
 +	__le16	ContextType; /* 3 */
 +	__le16  DataLength;
 +	__u32	Reserved;
 +	__le16	CompressionAlgorithmCount;
 +	__u16	Padding;
 +	__u32	Flags;
 +	__le16	CompressionAlgorithms[3];
 +} __packed;
 +
 +/*
 + * For smb2_netname_negotiate_context_id See MS-SMB2 2.2.3.1.4.
 + * Its struct simply contains NetName, an array of Unicode characters
 + */
 +struct smb2_netname_neg_context {
 +	__le16	ContextType; /* 5 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	__le16	NetName[]; /* hostname of target converted to UCS-2 */
 +} __packed;
 +
 +/*
 + * For rdma transform capabilities context see MS-SMB2 2.2.3.1.6
 + * and 2.2.4.1.5
 + */
 +
 +/* RDMA Transform IDs */
 +#define SMB2_RDMA_TRANSFORM_NONE	0x0000
 +#define SMB2_RDMA_TRANSFORM_ENCRYPTION	0x0001
 +
 +struct smb2_rdma_transform_capabilities_context {
 +	__le16	ContextType; /* 7 */
 +	__le16  DataLength;
 +	__u32	Reserved;
 +	__le16	TransformCount;
 +	__u16	Reserved1;
 +	__u32	Reserved2;
 +	__le16	RDMATransformIds[1];
 +} __packed;
 +
 +/* Signing algorithms */
 +#define SIGNING_ALG_HMAC_SHA256	0
 +#define SIGNING_ALG_AES_CMAC	1
 +#define SIGNING_ALG_AES_GMAC	2
 +
 +struct smb2_signing_capabilities {
 +	__le16	ContextType; /* 8 */
 +	__le16	DataLength;
 +	__u32	Reserved;
 +	__le16	SigningAlgorithmCount;
 +	__le16	SigningAlgorithms[];
 +} __packed;
 +
 +#define POSIX_CTXT_DATA_LEN	16
 +struct smb2_posix_neg_context {
 +	__le16	ContextType; /* 0x100 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	__u8	Name[16]; /* POSIX ctxt GUID 93AD25509CB411E7B42383DE968BCD7C */
 +} __packed;
 +
 +struct smb2_negotiate_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 65 */
 +	__le16 SecurityMode;
 +	__le16 DialectRevision;
 +	__le16 NegotiateContextCount;	/* Prior to SMB3.1.1 was Reserved & MBZ */
 +	__u8   ServerGUID[16];
 +	__le32 Capabilities;
 +	__le32 MaxTransactSize;
 +	__le32 MaxReadSize;
 +	__le32 MaxWriteSize;
 +	__le64 SystemTime;	/* MBZ */
 +	__le64 ServerStartTime;
 +	__le16 SecurityBufferOffset;
 +	__le16 SecurityBufferLength;
 +	__le32 NegotiateContextOffset;	/* Pre:SMB3.1.1 was reserved/ignored */
 +	__u8   Buffer[];	/* variable length GSS security buffer */
 +} __packed;
 +
 +/* Flags */
 +#define SMB2_SESSION_REQ_FLAG_BINDING		0x01
 +#define SMB2_SESSION_REQ_FLAG_ENCRYPT_DATA	0x04
 +
 +struct smb2_sess_setup_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 25 */
 +	__u8   Flags;
 +	__u8   SecurityMode;
 +	__le32 Capabilities;
 +	__le32 Channel;
 +	__le16 SecurityBufferOffset;
 +	__le16 SecurityBufferLength;
 +	__u64 PreviousSessionId;
 +	__u8   Buffer[];	/* variable length GSS security buffer */
 +} __packed;
 +
 +/* Currently defined SessionFlags */
 +#define SMB2_SESSION_FLAG_IS_GUEST	0x0001
 +#define SMB2_SESSION_FLAG_IS_NULL	0x0002
 +#define SMB2_SESSION_FLAG_ENCRYPT_DATA	0x0004
 +struct smb2_sess_setup_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 9 */
 +	__le16 SessionFlags;
 +	__le16 SecurityBufferOffset;
 +	__le16 SecurityBufferLength;
 +	__u8   Buffer[];	/* variable length GSS security buffer */
 +} __packed;
 +
 +struct smb2_logoff_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +struct smb2_logoff_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +/* Flags/Reserved for SMB3.1.1 */
 +#define SMB2_TREE_CONNECT_FLAG_CLUSTER_RECONNECT cpu_to_le16(0x0001)
 +#define SMB2_TREE_CONNECT_FLAG_REDIRECT_TO_OWNER cpu_to_le16(0x0002)
 +#define SMB2_TREE_CONNECT_FLAG_EXTENSION_PRESENT cpu_to_le16(0x0004)
 +
 +struct smb2_tree_connect_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 9 */
 +	__le16 Flags; /* Reserved MBZ for dialects prior to SMB3.1.1 */
 +	__le16 PathOffset;
 +	__le16 PathLength;
 +	__u8   Buffer[];	/* variable length */
 +} __packed;
 +
 +/* See MS-SMB2 section 2.2.9.2 */
 +/* Context Types */
 +#define SMB2_RESERVED_TREE_CONNECT_CONTEXT_ID 0x0000
 +#define SMB2_REMOTED_IDENTITY_TREE_CONNECT_CONTEXT_ID cpu_to_le16(0x0001)
 +
 +struct tree_connect_contexts {
 +	__le16 ContextType;
 +	__le16 DataLength;
 +	__le32 Reserved;
 +	__u8   Data[];
 +} __packed;
 +
 +/* Remoted identity tree connect context structures - see MS-SMB2 2.2.9.2.1 */
 +struct smb3_blob_data {
 +	__le16 BlobSize;
 +	__u8   BlobData[];
 +} __packed;
 +
 +/* Valid values for Attr */
 +#define SE_GROUP_MANDATORY		0x00000001
 +#define SE_GROUP_ENABLED_BY_DEFAULT	0x00000002
 +#define SE_GROUP_ENABLED		0x00000004
 +#define SE_GROUP_OWNER			0x00000008
 +#define SE_GROUP_USE_FOR_DENY_ONLY	0x00000010
 +#define SE_GROUP_INTEGRITY		0x00000020
 +#define SE_GROUP_INTEGRITY_ENABLED	0x00000040
 +#define SE_GROUP_RESOURCE		0x20000000
 +#define SE_GROUP_LOGON_ID		0xC0000000
 +
 +/* struct sid_attr_data is SidData array in BlobData format then le32 Attr */
 +
 +struct sid_array_data {
 +	__le16 SidAttrCount;
 +	/* SidAttrList - array of sid_attr_data structs */
 +} __packed;
 +
 +struct luid_attr_data {
 +
 +} __packed;
 +
 +/*
 + * struct privilege_data is the same as BLOB_DATA - see MS-SMB2 2.2.9.2.1.5
 + * but with size of LUID_ATTR_DATA struct and BlobData set to LUID_ATTR DATA
 + */
 +
 +struct privilege_array_data {
 +	__le16 PrivilegeCount;
 +	/* array of privilege_data structs */
 +} __packed;
 +
 +struct remoted_identity_tcon_context {
 +	__le16 TicketType; /* must be 0x0001 */
 +	__le16 TicketSize; /* total size of this struct */
 +	__le16 User; /* offset to SID_ATTR_DATA struct with user info */
 +	__le16 UserName; /* offset to null terminated Unicode username string */
 +	__le16 Domain; /* offset to null terminated Unicode domain name */
 +	__le16 Groups; /* offset to SID_ARRAY_DATA struct with group info */
 +	__le16 RestrictedGroups; /* similar to above */
 +	__le16 Privileges; /* offset to PRIVILEGE_ARRAY_DATA struct */
 +	__le16 PrimaryGroup; /* offset to SID_ARRAY_DATA struct */
 +	__le16 Owner; /* offset to BLOB_DATA struct */
 +	__le16 DefaultDacl; /* offset to BLOB_DATA struct */
 +	__le16 DeviceGroups; /* offset to SID_ARRAY_DATA struct */
 +	__le16 UserClaims; /* offset to BLOB_DATA struct */
 +	__le16 DeviceClaims; /* offset to BLOB_DATA struct */
 +	__u8   TicketInfo[]; /* variable length buf - remoted identity data */
 +} __packed;
 +
 +struct smb2_tree_connect_req_extension {
 +	__le32 TreeConnectContextOffset;
 +	__le16 TreeConnectContextCount;
 +	__u8  Reserved[10];
 +	__u8  PathName[]; /* variable sized array */
 +	/* followed by array of TreeConnectContexts */
 +} __packed;
 +
 +struct smb2_tree_connect_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 16 */
 +	__u8   ShareType;  /* see below */
 +	__u8   Reserved;
 +	__le32 ShareFlags; /* see below */
 +	__le32 Capabilities; /* see below */
 +	__le32 MaximalAccess;
 +} __packed;
 +
 +/* Possible ShareType values */
 +#define SMB2_SHARE_TYPE_DISK	0x01
 +#define SMB2_SHARE_TYPE_PIPE	0x02
 +#define	SMB2_SHARE_TYPE_PRINT	0x03
 +
 +/*
 + * Possible ShareFlags - exactly one and only one of the first 4 caching flags
 + * must be set (any of the remaining, SHI1005, flags may be set individually
 + * or in combination.
 + */
 +#define SMB2_SHAREFLAG_MANUAL_CACHING			0x00000000
 +#define SMB2_SHAREFLAG_AUTO_CACHING			0x00000010
 +#define SMB2_SHAREFLAG_VDO_CACHING			0x00000020
 +#define SMB2_SHAREFLAG_NO_CACHING			0x00000030
 +#define SHI1005_FLAGS_DFS				0x00000001
 +#define SHI1005_FLAGS_DFS_ROOT				0x00000002
 +#define SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS		0x00000100
 +#define SHI1005_FLAGS_FORCE_SHARED_DELETE		0x00000200
 +#define SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING		0x00000400
 +#define SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM	0x00000800
 +#define SHI1005_FLAGS_FORCE_LEVELII_OPLOCK		0x00001000
 +#define SHI1005_FLAGS_ENABLE_HASH_V1			0x00002000
 +#define SHI1005_FLAGS_ENABLE_HASH_V2			0x00004000
 +#define SHI1005_FLAGS_ENCRYPT_DATA			0x00008000
 +#define SMB2_SHAREFLAG_IDENTITY_REMOTING		0x00040000 /* 3.1.1 */
 +#define SHI1005_FLAGS_ALL				0x0004FF33
 +
 +/* Possible share capabilities */
 +#define SMB2_SHARE_CAP_DFS	cpu_to_le32(0x00000008) /* all dialects */
 +#define SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY cpu_to_le32(0x00000010) /* 3.0 */
 +#define SMB2_SHARE_CAP_SCALEOUT	cpu_to_le32(0x00000020) /* 3.0 */
 +#define SMB2_SHARE_CAP_CLUSTER	cpu_to_le32(0x00000040) /* 3.0 */
 +#define SMB2_SHARE_CAP_ASYMMETRIC cpu_to_le32(0x00000080) /* 3.02 */
 +#define SMB2_SHARE_CAP_REDIRECT_TO_OWNER cpu_to_le32(0x00000100) /* 3.1.1 */
 +
 +struct smb2_tree_disconnect_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +struct smb2_tree_disconnect_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
++=======
++>>>>>>> d8d9de532de9 (cifs: Move more definitions into the shared area)
  /* File Attrubutes */
  #define FILE_ATTRIBUTE_READONLY			0x00000001
  #define FILE_ATTRIBUTE_HIDDEN			0x00000002
@@@ -1218,161 -678,6 +1221,164 @@@ struct smb2_ioctl_rsp 
  	/* char * buffer[] */
  } __packed;
  
++<<<<<<< HEAD
 +/* Currently defined values for close flags */
 +#define SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB	cpu_to_le16(0x0001)
 +struct smb2_close_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 24 */
 +	__le16 Flags;
 +	__le32 Reserved;
 +	__u64  PersistentFileId; /* opaque endianness */
 +	__u64  VolatileFileId; /* opaque endianness */
 +} __packed;
 +
 +/*
 + * Maximum size of a SMB2_CLOSE response is 64 (smb2 header) + 60 (data)
 + */
 +#define MAX_SMB2_CLOSE_RESPONSE_SIZE 124
 +
 +struct smb2_close_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* 60 */
 +	__le16 Flags;
 +	__le32 Reserved;
 +	__le64 CreationTime;
 +	__le64 LastAccessTime;
 +	__le64 LastWriteTime;
 +	__le64 ChangeTime;
 +	__le64 AllocationSize;	/* Beginning of FILE_STANDARD_INFO equivalent */
 +	__le64 EndOfFile;
 +	__le32 Attributes;
 +} __packed;
 +
 +struct smb2_flush_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 24 */
 +	__le16 Reserved1;
 +	__le32 Reserved2;
 +	__u64  PersistentFileId; /* opaque endianness */
 +	__u64  VolatileFileId; /* opaque endianness */
 +} __packed;
 +
 +struct smb2_flush_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;
 +	__le16 Reserved;
 +} __packed;
 +
 +/* For read request Flags field below, following flag is defined for SMB3.02 */
 +#define SMB2_READFLAG_READ_UNBUFFERED	0x01
 +#define SMB2_READFLAG_REQUEST_COMPRESSED 0x02 /* See MS-SMB2 2.2.19 */
 +
 +/* Channel field for read and write: exactly one of following flags can be set*/
 +#define SMB2_CHANNEL_NONE	cpu_to_le32(0x00000000)
 +#define SMB2_CHANNEL_RDMA_V1	cpu_to_le32(0x00000001) /* SMB3 or later */
 +#define SMB2_CHANNEL_RDMA_V1_INVALIDATE cpu_to_le32(0x00000002) /* >= SMB3.02 */
 +#define SMB2_CHANNEL_RDMA_TRANSFORM cpu_to_le32(0x00000003) /* >= SMB3.02, only used on write */
 +
 +/* SMB2 read request without RFC1001 length at the beginning */
 +struct smb2_read_plain_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 49 */
 +	__u8   Padding; /* offset from start of SMB2 header to place read */
 +	__u8   Flags; /* MBZ unless SMB3.02 or later */
 +	__le32 Length;
 +	__le64 Offset;
 +	__u64  PersistentFileId; /* opaque endianness */
 +	__u64  VolatileFileId; /* opaque endianness */
 +	__le32 MinimumCount;
 +	__le32 Channel; /* MBZ except for SMB3 or later */
 +	__le32 RemainingBytes;
 +	__le16 ReadChannelInfoOffset;
 +	__le16 ReadChannelInfoLength;
 +	__u8   Buffer[];
 +} __packed;
 +
 +/* Read flags */
 +#define SMB2_READFLAG_RESPONSE_NONE	0x00000000
 +#define SMB2_READFLAG_RESPONSE_RDMA_TRANSFORM	0x00000001
 +
 +struct smb2_read_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 17 */
 +	__u8   DataOffset;
 +	__u8   Reserved;
 +	__le32 DataLength;
 +	__le32 DataRemaining;
 +	__u32  Flags;
 +	__u8   Buffer[];
 +} __packed;
 +
 +/* For write request Flags field below the following flags are defined: */
 +#define SMB2_WRITEFLAG_WRITE_THROUGH	0x00000001	/* SMB2.1 or later */
 +#define SMB2_WRITEFLAG_WRITE_UNBUFFERED	0x00000002	/* SMB3.02 or later */
 +
 +struct smb2_write_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 49 */
 +	__le16 DataOffset; /* offset from start of SMB2 header to write data */
 +	__le32 Length;
 +	__le64 Offset;
 +	__u64  PersistentFileId; /* opaque endianness */
 +	__u64  VolatileFileId; /* opaque endianness */
 +	__le32 Channel; /* MBZ unless SMB3.02 or later */
 +	__le32 RemainingBytes;
 +	__le16 WriteChannelInfoOffset;
 +	__le16 WriteChannelInfoLength;
 +	__le32 Flags;
 +	__u8   Buffer[];
 +} __packed;
 +
 +struct smb2_write_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 17 */
 +	__u8   DataOffset;
 +	__u8   Reserved;
 +	__le32 DataLength;
 +	__le32 DataRemaining;
 +	__u32  Reserved2;
 +	__u8   Buffer[];
 +} __packed;
 +
 +/* notify flags */
 +#define SMB2_WATCH_TREE			0x0001
 +
 +/* notify completion filter flags. See MS-FSCC 2.6 and MS-SMB2 2.2.35 */
 +#define FILE_NOTIFY_CHANGE_FILE_NAME		0x00000001
 +#define FILE_NOTIFY_CHANGE_DIR_NAME		0x00000002
 +#define FILE_NOTIFY_CHANGE_ATTRIBUTES		0x00000004
 +#define FILE_NOTIFY_CHANGE_SIZE			0x00000008
 +#define FILE_NOTIFY_CHANGE_LAST_WRITE		0x00000010
 +#define FILE_NOTIFY_CHANGE_LAST_ACCESS		0x00000020
 +#define FILE_NOTIFY_CHANGE_CREATION		0x00000040
 +#define FILE_NOTIFY_CHANGE_EA			0x00000080
 +#define FILE_NOTIFY_CHANGE_SECURITY		0x00000100
 +#define FILE_NOTIFY_CHANGE_STREAM_NAME		0x00000200
 +#define FILE_NOTIFY_CHANGE_STREAM_SIZE		0x00000400
 +#define FILE_NOTIFY_CHANGE_STREAM_WRITE		0x00000800
 +
 +struct smb2_change_notify_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16	StructureSize;
 +	__le16	Flags;
 +	__le32	OutputBufferLength;
 +	__u64	PersistentFileId; /* opaque endianness */
 +	__u64	VolatileFileId; /* opaque endianness */
 +	__le32	CompletionFilter;
 +	__u32	Reserved;
 +} __packed;
 +
 +struct smb2_change_notify_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16	StructureSize;  /* Must be 9 */
 +	__le16	OutputBufferOffset;
 +	__le32	OutputBufferLength;
 +	__u8	Buffer[]; /* array of file notify structs */
 +} __packed;
 +
++=======
++>>>>>>> d8d9de532de9 (cifs: Move more definitions into the shared area)
  #define SMB2_LOCKFLAG_SHARED_LOCK	0x0001
  #define SMB2_LOCKFLAG_EXCLUSIVE_LOCK	0x0002
  #define SMB2_LOCKFLAG_UNLOCK		0x0004
* Unmerged path fs/smbfs_common/smb2pdu.h
* Unmerged path fs/cifs/smb2pdu.c
* Unmerged path fs/cifs/smb2pdu.h
* Unmerged path fs/smbfs_common/smb2pdu.h
