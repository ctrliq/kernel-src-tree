cifs: fix NULL ptr dereference in refresh_mounts()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit 41f10081a92a0ed280008218a8ec18ad8ba0fceb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/41f10081.failed

Either mount(2) or automount might not have server->origin_fullpath
set yet while refresh_cache_worker() is attempting to refresh DFS
referrals.  Add missing NULL check and locking around it.

This fixes bellow crash:

[ 1070.276835] general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN NOPTI
[ 1070.277676] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
[ 1070.278219] CPU: 1 PID: 8506 Comm: kworker/u8:1 Not tainted 5.18.0-rc3 #10
[ 1070.278701] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.15.0-0-g2dd4b9b-rebuilt.opensuse.org 04/01/2014
[ 1070.279495] Workqueue: cifs-dfscache refresh_cache_worker [cifs]
[ 1070.280044] RIP: 0010:strcasecmp+0x34/0x150
[ 1070.280359] Code: 00 00 00 fc ff df 41 54 55 48 89 fd 53 48 83 ec 10 eb 03 4c 89 fe 48 89 ef 48 83 c5 01 48 89 f8 48 89 fa 48 c1 e8 03 83 e2 07 <42> 0f b6 04 28 38 d0 7f 08 84 c0 0f 85 bc 00 00 00 0f b6 45 ff 44
[ 1070.281729] RSP: 0018:ffffc90008367958 EFLAGS: 00010246
[ 1070.282114] RAX: 0000000000000000 RBX: dffffc0000000000 RCX: 0000000000000000
[ 1070.282691] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
[ 1070.283273] RBP: 0000000000000001 R08: 0000000000000000 R09: ffffffff873eda27
[ 1070.283857] R10: ffffc900083679a0 R11: 0000000000000001 R12: ffff88812624c000
[ 1070.284436] R13: dffffc0000000000 R14: ffff88810e6e9a88 R15: ffff888119bb9000
[ 1070.284990] FS:  0000000000000000(0000) GS:ffff888151200000(0000) knlGS:0000000000000000
[ 1070.285625] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1070.286100] CR2: 0000561a4d922418 CR3: 000000010aecc000 CR4: 0000000000350ee0
[ 1070.286683] Call Trace:
[ 1070.286890]  <TASK>
[ 1070.287070]  refresh_cache_worker+0x895/0xd20 [cifs]
[ 1070.287475]  ? __refresh_tcon.isra.0+0xfb0/0xfb0 [cifs]
[ 1070.287905]  ? __lock_acquire+0xcd1/0x6960
[ 1070.288247]  ? is_dynamic_key+0x1a0/0x1a0
[ 1070.288591]  ? lockdep_hardirqs_on_prepare+0x410/0x410
[ 1070.289012]  ? lock_downgrade+0x6f0/0x6f0
[ 1070.289318]  process_one_work+0x7bd/0x12d0
[ 1070.289637]  ? worker_thread+0x160/0xec0
[ 1070.289970]  ? pwq_dec_nr_in_flight+0x230/0x230
[ 1070.290318]  ? _raw_spin_lock_irq+0x5e/0x90
[ 1070.290619]  worker_thread+0x5ac/0xec0
[ 1070.290891]  ? process_one_work+0x12d0/0x12d0
[ 1070.291199]  kthread+0x2a5/0x350
[ 1070.291430]  ? kthread_complete_and_exit+0x20/0x20
[ 1070.291770]  ret_from_fork+0x22/0x30
[ 1070.292050]  </TASK>
[ 1070.292223] Modules linked in: bpfilter cifs cifs_arc4 cifs_md4
[ 1070.292765] ---[ end trace 0000000000000000 ]---
[ 1070.293108] RIP: 0010:strcasecmp+0x34/0x150
[ 1070.293471] Code: 00 00 00 fc ff df 41 54 55 48 89 fd 53 48 83 ec 10 eb 03 4c 89 fe 48 89 ef 48 83 c5 01 48 89 f8 48 89 fa 48 c1 e8 03 83 e2 07 <42> 0f b6 04 28 38 d0 7f 08 84 c0 0f 85 bc 00 00 00 0f b6 45 ff 44
[ 1070.297718] RSP: 0018:ffffc90008367958 EFLAGS: 00010246
[ 1070.298622] RAX: 0000000000000000 RBX: dffffc0000000000 RCX: 0000000000000000
[ 1070.299428] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
[ 1070.300296] RBP: 0000000000000001 R08: 0000000000000000 R09: ffffffff873eda27
[ 1070.301204] R10: ffffc900083679a0 R11: 0000000000000001 R12: ffff88812624c000
[ 1070.301932] R13: dffffc0000000000 R14: ffff88810e6e9a88 R15: ffff888119bb9000
[ 1070.302645] FS:  0000000000000000(0000) GS:ffff888151200000(0000) knlGS:0000000000000000
[ 1070.303462] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1070.304131] CR2: 0000561a4d922418 CR3: 000000010aecc000 CR4: 0000000000350ee0
[ 1070.305004] Kernel panic - not syncing: Fatal exception
[ 1070.305711] Kernel Offset: disabled
[ 1070.305971] ---[ end Kernel panic - not syncing: Fatal exception ]---

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Cc: stable@vger.kernel.org
	Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 41f10081a92a0ed280008218a8ec18ad8ba0fceb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/dfs_cache.c
diff --cc fs/cifs/connect.c
index 6e27e4672066,2c24d433061a..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3559,117 -3494,225 +3559,291 @@@ int cifs_mount(struct cifs_sb_info *cif
  	 * to respond with PATH_NOT_COVERED to requests that include the prefix.
  	 */
  	if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS) ||
 -	    dfs_cache_find(mnt_ctx->xid, mnt_ctx->ses, cifs_sb->local_nls, cifs_remap(cifs_sb),
 -			   ctx->UNC + 1, NULL, root_tl)) {
 +	    dfs_cache_find(xid, ses, cifs_sb->local_nls, cifs_remap(cifs_sb), ctx->UNC + 1, NULL,
 +			   NULL)) {
  		if (rc)
 -			return rc;
 +			goto error;
  		/* Check if it is fully accessible and then mount it */
 -		rc = is_path_remote(mnt_ctx);
 +		rc = is_path_remote(cifs_sb, ctx, xid, server, tcon);
  		if (!rc)
 -			*isdfs = false;
 -		else if (rc != -EREMOTE)
 -			return rc;
 -	}
 -	return 0;
 -}
 -
 -static int connect_dfs_target(struct mount_ctx *mnt_ctx, const char *full_path,
 -			      const char *ref_path, struct dfs_cache_tgt_iterator *tit)
 -{
 -	int rc;
 -	struct dfs_info3_param ref = {};
 -	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
 -	char *oldmnt = cifs_sb->ctx->mount_options;
 -
 -	cifs_dbg(FYI, "%s: full_path=%s ref_path=%s target=%s\n", __func__, full_path, ref_path,
 -		 dfs_cache_get_tgt_name(tit));
 -
 -	rc = dfs_cache_get_tgt_referral(ref_path, tit, &ref);
 -	if (rc)
 -		goto out;
 -
 -	rc = expand_dfs_referral(mnt_ctx, full_path, &ref);
 -	if (rc)
 -		goto out;
 -
 -	/* Connect to new target only if we were redirected (e.g. mount options changed) */
 -	if (oldmnt != cifs_sb->ctx->mount_options) {
 -		mount_put_conns(mnt_ctx);
 -		rc = mount_get_dfs_conns(mnt_ctx);
 -	}
 -	if (!rc) {
 -		if (cifs_is_referral_server(mnt_ctx->tcon, &ref))
 -			set_root_ses(mnt_ctx);
 -		rc = dfs_cache_update_tgthint(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,
 -					      cifs_remap(cifs_sb), ref_path, tit);
 +			goto out;
 +		if (rc != -EREMOTE)
 +			goto error;
  	}
  
++<<<<<<< HEAD
 +	mount_put_conns(cifs_sb, xid, server, ses, tcon);
++=======
+ out:
+ 	free_dfs_info_param(&ref);
+ 	return rc;
+ }
+ 
+ static int connect_dfs_root(struct mount_ctx *mnt_ctx, struct dfs_cache_tgt_list *root_tl)
+ {
+ 	int rc;
+ 	char *full_path;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
+ 	struct dfs_cache_tgt_iterator *tit;
+ 
+ 	/* Put initial connections as they might be shared with other mounts.  We need unique dfs
+ 	 * connections per mount to properly failover, so mount_get_dfs_conns() must be used from
+ 	 * now on.
+ 	 */
+ 	mount_put_conns(mnt_ctx);
+ 	mount_get_dfs_conns(mnt_ctx);
+ 	set_root_ses(mnt_ctx);
+ 
+ 	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
+ 	if (IS_ERR(full_path))
+ 		return PTR_ERR(full_path);
+ 
+ 	mnt_ctx->origin_fullpath = dfs_cache_canonical_path(ctx->UNC, cifs_sb->local_nls,
+ 							    cifs_remap(cifs_sb));
+ 	if (IS_ERR(mnt_ctx->origin_fullpath)) {
+ 		rc = PTR_ERR(mnt_ctx->origin_fullpath);
+ 		mnt_ctx->origin_fullpath = NULL;
+ 		goto out;
+ 	}
+ 
+ 	/* Try all dfs root targets */
+ 	for (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(root_tl);
+ 	     tit; tit = dfs_cache_get_next_tgt(root_tl, tit)) {
+ 		rc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->origin_fullpath + 1, tit);
+ 		if (!rc) {
+ 			mnt_ctx->leaf_fullpath = kstrdup(mnt_ctx->origin_fullpath, GFP_KERNEL);
+ 			if (!mnt_ctx->leaf_fullpath)
+ 				rc = -ENOMEM;
+ 			break;
+ 		}
+ 	}
+ 
+ out:
+ 	kfree(full_path);
+ 	return rc;
+ }
+ 
+ static int __follow_dfs_link(struct mount_ctx *mnt_ctx)
+ {
+ 	int rc;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
+ 	char *full_path;
+ 	struct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);
+ 	struct dfs_cache_tgt_iterator *tit;
+ 
+ 	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
+ 	if (IS_ERR(full_path))
+ 		return PTR_ERR(full_path);
+ 
+ 	kfree(mnt_ctx->leaf_fullpath);
+ 	mnt_ctx->leaf_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,
+ 							  cifs_remap(cifs_sb));
+ 	if (IS_ERR(mnt_ctx->leaf_fullpath)) {
+ 		rc = PTR_ERR(mnt_ctx->leaf_fullpath);
+ 		mnt_ctx->leaf_fullpath = NULL;
+ 		goto out;
+ 	}
+ 
+ 	/* Get referral from dfs link */
+ 	rc = dfs_cache_find(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,
+ 			    cifs_remap(cifs_sb), mnt_ctx->leaf_fullpath + 1, NULL, &tl);
+ 	if (rc)
+ 		goto out;
+ 
+ 	/* Try all dfs link targets.  If an I/O fails from currently connected DFS target with an
+ 	 * error other than STATUS_PATH_NOT_COVERED (-EREMOTE), then retry it from other targets as
+ 	 * specified in MS-DFSC "3.1.5.2 I/O Operation to Target Fails with an Error Other Than
+ 	 * STATUS_PATH_NOT_COVERED."
+ 	 */
+ 	for (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(&tl);
+ 	     tit; tit = dfs_cache_get_next_tgt(&tl, tit)) {
+ 		rc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->leaf_fullpath + 1, tit);
+ 		if (!rc) {
+ 			rc = is_path_remote(mnt_ctx);
+ 			if (!rc || rc == -EREMOTE)
+ 				break;
+ 		}
+ 	}
+ 
+ out:
+ 	kfree(full_path);
+ 	dfs_cache_free_tgts(&tl);
+ 	return rc;
+ }
+ 
+ static int follow_dfs_link(struct mount_ctx *mnt_ctx)
+ {
+ 	int rc;
+ 	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
+ 	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
+ 	char *full_path;
+ 	int num_links = 0;
+ 
+ 	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
+ 	if (IS_ERR(full_path))
+ 		return PTR_ERR(full_path);
+ 
+ 	kfree(mnt_ctx->origin_fullpath);
+ 	mnt_ctx->origin_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,
+ 							    cifs_remap(cifs_sb));
+ 	kfree(full_path);
+ 
+ 	if (IS_ERR(mnt_ctx->origin_fullpath)) {
+ 		rc = PTR_ERR(mnt_ctx->origin_fullpath);
+ 		mnt_ctx->origin_fullpath = NULL;
+ 		return rc;
+ 	}
+ 
+ 	do {
+ 		rc = __follow_dfs_link(mnt_ctx);
+ 		if (!rc || rc != -EREMOTE)
+ 			break;
+ 	} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);
+ 
+ 	return rc;
+ }
+ 
+ /* Set up DFS referral paths for failover */
+ static void setup_server_referral_paths(struct mount_ctx *mnt_ctx)
+ {
+ 	struct TCP_Server_Info *server = mnt_ctx->server;
+ 
+ 	mutex_lock(&server->refpath_lock);
+ 	server->origin_fullpath = mnt_ctx->origin_fullpath;
+ 	server->leaf_fullpath = mnt_ctx->leaf_fullpath;
+ 	server->current_fullpath = mnt_ctx->leaf_fullpath;
+ 	mutex_unlock(&server->refpath_lock);
+ 	mnt_ctx->origin_fullpath = mnt_ctx->leaf_fullpath = NULL;
+ }
+ 
+ int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)
+ {
+ 	int rc;
+ 	struct mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };
+ 	struct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);
+ 	bool isdfs;
+ 
+ 	rc = is_dfs_mount(&mnt_ctx, &isdfs, &tl);
+ 	if (rc)
+ 		goto error;
+ 	if (!isdfs)
+ 		goto out;
+ 
+ 	uuid_gen(&mnt_ctx.mount_id);
+ 	rc = connect_dfs_root(&mnt_ctx, &tl);
+ 	dfs_cache_free_tgts(&tl);
+ 
+ 	if (rc)
+ 		goto error;
+ 
+ 	rc = is_path_remote(&mnt_ctx);
+ 	if (rc)
+ 		rc = follow_dfs_link(&mnt_ctx);
+ 	if (rc)
+ 		goto error;
+ 
+ 	setup_server_referral_paths(&mnt_ctx);
++>>>>>>> 41f10081a92a (cifs: fix NULL ptr dereference in refresh_mounts())
 +	/*
 +	 * Ignore error check here because we may failover to other targets from cached a
 +	 * referral.
 +	 */
 +	(void)mount_get_dfs_conns(ctx, cifs_sb, &xid, &server, &ses, &tcon);
 +
 +	/* Get path of DFS root */
 +	ref_path = build_unc_path_to_root(ctx, cifs_sb, false);
 +	if (IS_ERR(ref_path)) {
 +		rc = PTR_ERR(ref_path);
 +		ref_path = NULL;
 +		goto error;
 +	}
 +
 +	uuid_gen(&mount_id);
 +	set_root_ses(cifs_sb, &mount_id, ses, &root_ses);
 +	do {
 +		/* Save full path of last DFS path we used to resolve final target server */
 +		kfree(full_path);
 +		full_path = build_unc_path_to_root(ctx, cifs_sb, !!count);
 +		if (IS_ERR(full_path)) {
 +			rc = PTR_ERR(full_path);
 +			full_path = NULL;
 +			break;
 +		}
 +		/* Chase referral */
 +		oldmnt = cifs_sb->ctx->mount_options;
 +		rc = expand_dfs_referral(xid, root_ses, ctx, cifs_sb, ref_path + 1);
 +		if (rc)
 +			break;
 +		/* Connect to new DFS target only if we were redirected */
 +		if (oldmnt != cifs_sb->ctx->mount_options) {
 +			mount_put_conns(cifs_sb, xid, server, ses, tcon);
 +			rc = mount_get_dfs_conns(ctx, cifs_sb, &xid, &server, &ses, &tcon);
 +		}
 +		if (rc && !server && !ses) {
 +			/* Failed to connect. Try to connect to other targets in the referral. */
 +			rc = do_dfs_failover(ref_path + 1, full_path, cifs_sb, ctx, root_ses, &xid,
 +					     &server, &ses, &tcon);
 +		}
 +		if (rc == -EACCES || rc == -EOPNOTSUPP || !server || !ses)
 +			break;
 +		if (!tcon)
 +			continue;
 +
 +		/* Make sure that requests go through new root servers */
 +		rc = is_referral_server(ref_path + 1, cifs_sb, tcon, &ref_server);
 +		if (rc)
 +			break;
 +		if (ref_server)
 +			set_root_ses(cifs_sb, &mount_id, ses, &root_ses);
 +
 +		/* Get next dfs path and then continue chasing them if -EREMOTE */
 +		rc = next_dfs_prepath(cifs_sb, ctx, xid, server, tcon, &ref_path);
 +		/* Prevent recursion on broken link referrals */
 +		if (rc == -EREMOTE && ++count > MAX_NESTED_LINKS)
 +			rc = -ELOOP;
 +	} while (rc == -EREMOTE);
 +
 +	if (rc || !tcon) {
 +		rc = rc ? rc : -ENOENT;
 +		goto error;
 +	}
 +
 +	kfree(ref_path);
  	/*
 -	 * After reconnecting to a different server, unique ids won't match anymore, so we disable
 -	 * serverino. This prevents dentry revalidation to think the dentry are stale (ESTALE).
 +	 * Store DFS full path in both superblock and tree connect structures.
 +	 *
 +	 * For DFS root mounts, the prefix path (cifs_sb->prepath) is preserved during reconnect so
 +	 * only the root path is set in cifs_sb->origin_fullpath and tcon->dfs_path. And for DFS
 +	 * links, the prefix path is included in both and may be changed during reconnect.  See
 +	 * cifs_tree_connect().
 +	 */
 +	ref_path = dfs_cache_canonical_path(full_path, cifs_sb->local_nls, cifs_remap(cifs_sb));
 +	kfree(full_path);
 +	full_path = NULL;
 +
 +	if (IS_ERR(ref_path)) {
 +		rc = PTR_ERR(ref_path);
 +		ref_path = NULL;
 +		goto error;
 +	}
 +	cifs_sb->origin_fullpath = ref_path;
 +
 +	ref_path = kstrdup(cifs_sb->origin_fullpath, GFP_KERNEL);
 +	if (!ref_path) {
 +		rc = -ENOMEM;
 +		goto error;
 +	}
 +	spin_lock(&cifs_tcp_ses_lock);
 +	tcon->dfs_path = ref_path;
 +	ref_path = NULL;
 +	spin_unlock(&cifs_tcp_ses_lock);
 +
 +	/*
 +	 * After reconnecting to a different server, unique ids won't
 +	 * match anymore, so we disable serverino. This prevents
 +	 * dentry revalidation to think the dentry are stale (ESTALE).
  	 */
  	cifs_autodisable_serverino(cifs_sb);
  	/*
diff --cc fs/cifs/dfs_cache.c
index 172fc0b3e8f8,956f8e5cf3e7..000000000000
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@@ -1421,6 -1417,22 +1421,25 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int refresh_tcon(struct cifs_ses **sessions, struct cifs_tcon *tcon, bool force_refresh)
+ {
+ 	struct TCP_Server_Info *server = tcon->ses->server;
+ 
+ 	mutex_lock(&server->refpath_lock);
+ 	if (server->origin_fullpath) {
+ 		if (server->leaf_fullpath && strcasecmp(server->leaf_fullpath,
+ 							server->origin_fullpath))
+ 			__refresh_tcon(server->leaf_fullpath + 1, sessions, tcon, force_refresh);
+ 		__refresh_tcon(server->origin_fullpath + 1, sessions, tcon, force_refresh);
+ 	}
+ 	mutex_unlock(&server->refpath_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 41f10081a92a (cifs: fix NULL ptr dereference in refresh_mounts())
  /**
   * dfs_cache_remount_fs - remount a DFS share
   *
@@@ -1509,8 -1527,19 +1528,21 @@@ static void refresh_mounts(struct cifs_
  	spin_unlock(&cifs_tcp_ses_lock);
  
  	list_for_each_entry_safe(tcon, ntcon, &tcons, ulist) {
 -		struct TCP_Server_Info *server = tcon->ses->server;
 -
  		list_del_init(&tcon->ulist);
++<<<<<<< HEAD
 +		refresh_tcon(sessions, tcon, false);
++=======
+ 
+ 		mutex_lock(&server->refpath_lock);
+ 		if (server->origin_fullpath) {
+ 			if (server->leaf_fullpath && strcasecmp(server->leaf_fullpath,
+ 								server->origin_fullpath))
+ 				__refresh_tcon(server->leaf_fullpath + 1, sessions, tcon, false);
+ 			__refresh_tcon(server->origin_fullpath + 1, sessions, tcon, false);
+ 		}
+ 		mutex_unlock(&server->refpath_lock);
+ 
++>>>>>>> 41f10081a92a (cifs: fix NULL ptr dereference in refresh_mounts())
  		cifs_put_tcon(tcon);
  	}
  }
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/dfs_cache.c
