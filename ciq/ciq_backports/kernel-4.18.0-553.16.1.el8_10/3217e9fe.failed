perf record: Start threads in the beginning of trace streaming

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Alexey Bayduraev <alexey.v.bayduraev@linux.intel.com>
commit 3217e9fecf118d5dcabdd68d91e0c6afcb4c3e1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/3217e9fe.failed

Start thread in detached state because its management is implemented
via messaging to avoid any scaling issues. Block signals prior thread
start so only main tool thread would be notified on external async
signals during data collection. Thread affinity mask is used to assign
eligible CPUs for the thread to run. Wait and sync on thread start using
thread ack pipe.

	Reviewed-by: Riccardo Mancini <rickyman7@gmail.com>
	Signed-off-by: Alexey Bayduraev <alexey.v.bayduraev@linux.intel.com>
	Tested-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Riccardo Mancini <rickyman7@gmail.com>
	Acked-by: Namhyung Kim <namhyung@gmail.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexander Antonov <alexander.antonov@linux.intel.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexei Budankov <abudankov@huawei.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: https://lore.kernel.org/r/95784dd9f7c81ee408eab27b50b4c09ad4cf7be6.1642440724.git.alexey.v.bayduraev@linux.intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 3217e9fecf118d5dcabdd68d91e0c6afcb4c3e1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
#	tools/perf/util/record.h
diff --cc tools/perf/builtin-record.c
index a12318efae5a,517520ae1520..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -123,6 -163,18 +123,21 @@@ static const char *affinity_tags[PERF_A
  	"SYS", "NODE", "CPU"
  };
  
++<<<<<<< HEAD
++=======
+ #ifndef HAVE_GETTID
+ static inline pid_t gettid(void)
+ {
+ 	return (pid_t)syscall(__NR_gettid);
+ }
+ #endif
+ 
+ static int record__threads_enabled(struct record *rec)
+ {
+ 	return rec->opts.threads_spec;
+ }
+ 
++>>>>>>> 3217e9fecf11 (perf record: Start threads in the beginning of trace streaming)
  static bool switch_output_signal(struct record *rec)
  {
  	return rec->switch_output.signal &&
@@@ -1194,6 -1469,77 +1209,80 @@@ static int record__mmap_read_all(struc
  	return record__mmap_read_evlist(rec, rec->evlist, true, synch);
  }
  
++<<<<<<< HEAD
++=======
+ static void record__thread_munmap_filtered(struct fdarray *fda, int fd,
+ 					   void *arg __maybe_unused)
+ {
+ 	struct perf_mmap *map = fda->priv[fd].ptr;
+ 
+ 	if (map)
+ 		perf_mmap__put(map);
+ }
+ 
+ static void *record__thread(void *arg)
+ {
+ 	enum thread_msg msg = THREAD_MSG__READY;
+ 	bool terminate = false;
+ 	struct fdarray *pollfd;
+ 	int err, ctlfd_pos;
+ 
+ 	thread = arg;
+ 	thread->tid = gettid();
+ 
+ 	err = write(thread->pipes.ack[1], &msg, sizeof(msg));
+ 	if (err == -1)
+ 		pr_warning("threads[%d]: failed to notify on start: %s\n",
+ 			   thread->tid, strerror(errno));
+ 
+ 	pr_debug("threads[%d]: started on cpu%d\n", thread->tid, sched_getcpu());
+ 
+ 	pollfd = &thread->pollfd;
+ 	ctlfd_pos = thread->ctlfd_pos;
+ 
+ 	for (;;) {
+ 		unsigned long long hits = thread->samples;
+ 
+ 		if (record__mmap_read_all(thread->rec, false) < 0 || terminate)
+ 			break;
+ 
+ 		if (hits == thread->samples) {
+ 
+ 			err = fdarray__poll(pollfd, -1);
+ 			/*
+ 			 * Propagate error, only if there's any. Ignore positive
+ 			 * number of returned events and interrupt error.
+ 			 */
+ 			if (err > 0 || (err < 0 && errno == EINTR))
+ 				err = 0;
+ 			thread->waking++;
+ 
+ 			if (fdarray__filter(pollfd, POLLERR | POLLHUP,
+ 					    record__thread_munmap_filtered, NULL) == 0)
+ 				break;
+ 		}
+ 
+ 		if (pollfd->entries[ctlfd_pos].revents & POLLHUP) {
+ 			terminate = true;
+ 			close(thread->pipes.msg[0]);
+ 			thread->pipes.msg[0] = -1;
+ 			pollfd->entries[ctlfd_pos].fd = -1;
+ 			pollfd->entries[ctlfd_pos].events = 0;
+ 		}
+ 
+ 		pollfd->entries[ctlfd_pos].revents = 0;
+ 	}
+ 	record__mmap_read_all(thread->rec, true);
+ 
+ 	err = write(thread->pipes.ack[1], &msg, sizeof(msg));
+ 	if (err == -1)
+ 		pr_warning("threads[%d]: failed to notify on termination: %s\n",
+ 			   thread->tid, strerror(errno));
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 3217e9fecf11 (perf record: Start threads in the beginning of trace streaming)
  static void record__init_features(struct record *rec)
  {
  	struct perf_session *session = rec->session;
@@@ -1638,6 -1963,113 +1727,116 @@@ static void record__uniquify_name(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int record__terminate_thread(struct record_thread *thread_data)
+ {
+ 	int err;
+ 	enum thread_msg ack = THREAD_MSG__UNDEFINED;
+ 	pid_t tid = thread_data->tid;
+ 
+ 	close(thread_data->pipes.msg[1]);
+ 	thread_data->pipes.msg[1] = -1;
+ 	err = read(thread_data->pipes.ack[0], &ack, sizeof(ack));
+ 	if (err > 0)
+ 		pr_debug2("threads[%d]: sent %s\n", tid, thread_msg_tags[ack]);
+ 	else
+ 		pr_warning("threads[%d]: failed to receive termination notification from %d\n",
+ 			   thread->tid, tid);
+ 
+ 	return 0;
+ }
+ 
+ static int record__start_threads(struct record *rec)
+ {
+ 	int t, tt, err, ret = 0, nr_threads = rec->nr_threads;
+ 	struct record_thread *thread_data = rec->thread_data;
+ 	sigset_t full, mask;
+ 	pthread_t handle;
+ 	pthread_attr_t attrs;
+ 
+ 	thread = &thread_data[0];
+ 
+ 	if (!record__threads_enabled(rec))
+ 		return 0;
+ 
+ 	sigfillset(&full);
+ 	if (sigprocmask(SIG_SETMASK, &full, &mask)) {
+ 		pr_err("Failed to block signals on threads start: %s\n", strerror(errno));
+ 		return -1;
+ 	}
+ 
+ 	pthread_attr_init(&attrs);
+ 	pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED);
+ 
+ 	for (t = 1; t < nr_threads; t++) {
+ 		enum thread_msg msg = THREAD_MSG__UNDEFINED;
+ 
+ #ifdef HAVE_PTHREAD_ATTR_SETAFFINITY_NP
+ 		pthread_attr_setaffinity_np(&attrs,
+ 					    MMAP_CPU_MASK_BYTES(&(thread_data[t].mask->affinity)),
+ 					    (cpu_set_t *)(thread_data[t].mask->affinity.bits));
+ #endif
+ 		if (pthread_create(&handle, &attrs, record__thread, &thread_data[t])) {
+ 			for (tt = 1; tt < t; tt++)
+ 				record__terminate_thread(&thread_data[t]);
+ 			pr_err("Failed to start threads: %s\n", strerror(errno));
+ 			ret = -1;
+ 			goto out_err;
+ 		}
+ 
+ 		err = read(thread_data[t].pipes.ack[0], &msg, sizeof(msg));
+ 		if (err > 0)
+ 			pr_debug2("threads[%d]: sent %s\n", rec->thread_data[t].tid,
+ 				  thread_msg_tags[msg]);
+ 		else
+ 			pr_warning("threads[%d]: failed to receive start notification from %d\n",
+ 				   thread->tid, rec->thread_data[t].tid);
+ 	}
+ 
+ 	sched_setaffinity(0, MMAP_CPU_MASK_BYTES(&thread->mask->affinity),
+ 			(cpu_set_t *)thread->mask->affinity.bits);
+ 
+ 	pr_debug("threads[%d]: started on cpu%d\n", thread->tid, sched_getcpu());
+ 
+ out_err:
+ 	pthread_attr_destroy(&attrs);
+ 
+ 	if (sigprocmask(SIG_SETMASK, &mask, NULL)) {
+ 		pr_err("Failed to unblock signals on threads start: %s\n", strerror(errno));
+ 		ret = -1;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int record__stop_threads(struct record *rec)
+ {
+ 	int t;
+ 	struct record_thread *thread_data = rec->thread_data;
+ 
+ 	for (t = 1; t < rec->nr_threads; t++)
+ 		record__terminate_thread(&thread_data[t]);
+ 
+ 	for (t = 0; t < rec->nr_threads; t++)
+ 		rec->samples += thread_data[t].samples;
+ 
+ 	return 0;
+ }
+ 
+ static unsigned long record__waking(struct record *rec)
+ {
+ 	int t;
+ 	unsigned long waking = 0;
+ 	struct record_thread *thread_data = rec->thread_data;
+ 
+ 	for (t = 0; t < rec->nr_threads; t++)
+ 		waking += thread_data[t].waking;
+ 
+ 	return waking;
+ }
+ 
++>>>>>>> 3217e9fecf11 (perf record: Start threads in the beginning of trace streaming)
  static int __cmd_record(struct record *rec, int argc, const char **argv)
  {
  	int err;
diff --cc tools/perf/util/record.h
index 68f471d9a88b,ad08c092f3dd..000000000000
--- a/tools/perf/util/record.h
+++ b/tools/perf/util/record.h
@@@ -77,6 -77,8 +77,11 @@@ struct record_opts 
  	int	      ctl_fd;
  	int	      ctl_fd_ack;
  	bool	      ctl_fd_close;
++<<<<<<< HEAD
++=======
+ 	int	      synth;
+ 	int	      threads_spec;
++>>>>>>> 3217e9fecf11 (perf record: Start threads in the beginning of trace streaming)
  };
  
  extern const char * const *record_usage;
* Unmerged path tools/perf/builtin-record.c
* Unmerged path tools/perf/util/record.h
