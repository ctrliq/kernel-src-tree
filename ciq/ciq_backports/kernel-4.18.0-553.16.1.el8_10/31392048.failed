vxlan: Pull inner IP header in vxlan_xmit_one().

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Guillaume Nault <gnault@redhat.com>
commit 31392048f55f98cb01ca709d32d06d926ab9760a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/31392048.failed

Ensure the inner IP header is part of the skb's linear data before
setting old_iph. Otherwise, on a non-linear skb, old_iph could point
outside of the packet data.

Unlike classical VXLAN, which always encapsulates Ethernet packets,
VXLAN-GPE can transport IP packets directly. In that case, we need to
look at skb->protocol to figure out if an Ethernet header is present.

Fixes: d342894c5d2f ("vxlan: virtual extensible lan")
	Signed-off-by: Guillaume Nault <gnault@redhat.com>
Link: https://patch.msgid.link/2aa75f6fa62ac9dbe4f16ad5ba75dd04a51d4b99.1718804000.git.gnault@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 31392048f55f98cb01ca709d32d06d926ab9760a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 416037daf2cf,ba59e92ab941..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2409,27 -2336,40 +2409,42 @@@ static void vxlan_xmit_one(struct sk_bu
  {
  	struct dst_cache *dst_cache;
  	struct ip_tunnel_info *info;
 -	struct ip_tunnel_key *pkey;
 -	struct ip_tunnel_key key;
  	struct vxlan_dev *vxlan = netdev_priv(dev);
++<<<<<<< HEAD:drivers/net/vxlan.c
 +	const struct iphdr *old_iph = ip_hdr(skb);
 +	union vxlan_addr *dst;
 +	union vxlan_addr remote_ip, local_ip;
++=======
+ 	const struct iphdr *old_iph;
++>>>>>>> 31392048f55f (vxlan: Pull inner IP header in vxlan_xmit_one().):drivers/net/vxlan/vxlan_core.c
  	struct vxlan_metadata _md;
  	struct vxlan_metadata *md = &_md;
 -	unsigned int pkt_len = skb->len;
  	__be16 src_port = 0, dst_port;
  	struct dst_entry *ndst = NULL;
 -	int addr_family;
 +	__be32 vni, label;
  	__u8 tos, ttl;
  	int ifindex;
  	int err;
  	u32 flags = vxlan->cfg.flags;
 -	bool use_cache;
  	bool udp_sum = false;
  	bool xnet = !net_eq(vxlan->net, dev_net(vxlan->dev));
++<<<<<<< HEAD:drivers/net/vxlan.c
++=======
+ 	bool no_eth_encap;
+ 	__be32 vni = 0;
++>>>>>>> 31392048f55f (vxlan: Pull inner IP header in vxlan_xmit_one().):drivers/net/vxlan/vxlan_core.c
+ 
+ 	no_eth_encap = flags & VXLAN_F_GPE && skb->protocol != htons(ETH_P_TEB);
+ 	if (!skb_vlan_inet_prepare(skb, no_eth_encap))
+ 		goto drop;
+ 
+ 	old_iph = ip_hdr(skb);
  
  	info = skb_tunnel_info(skb);
 -	use_cache = ip_tunnel_dst_cache_usable(skb, info);
  
  	if (rdst) {
 -		memset(&key, 0, sizeof(key));
 -		pkey = &key;
 -
 -		if (vxlan_addr_any(&rdst->remote_ip)) {
 +		dst = &rdst->remote_ip;
 +		if (vxlan_addr_any(dst)) {
  			if (did_rsc) {
  				/* short-circuited back to local bridge */
  				vxlan_encap_bypass(skb, vxlan, vxlan,
* Unmerged path drivers/net/vxlan.c
