platform/x86: wmi: Fix opening of char device

jira LE-1907
cve CVE-2023-52864
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Armin Wolf <W_Armin@gmx.de>
commit eba9ac7abab91c8f6d351460239108bef5e7a0b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/eba9ac7a.failed

Since commit fa1f68db6ca7 ("drivers: misc: pass miscdevice pointer via
file private data"), the miscdevice stores a pointer to itself inside
filp->private_data, which means that private_data will not be NULL when
wmi_char_open() is called. This might cause memory corruption should
wmi_char_open() be unable to find its driver, something which can
happen when the associated WMI device is deleted in wmi_free_devices().

Fix the problem by using the miscdevice pointer to retrieve the WMI
device data associated with a char device using container_of(). This
also avoids wmi_char_open() picking a wrong WMI device bound to a
driver with the same name as the original driver.

Fixes: 44b6b7661132 ("platform/x86: wmi: create userspace interface for drivers")
	Signed-off-by: Armin Wolf <W_Armin@gmx.de>
Link: https://lore.kernel.org/r/20231020211005.38216-5-W_Armin@gmx.de
	Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
	Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
(cherry picked from commit eba9ac7abab91c8f6d351460239108bef5e7a0b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/wmi.c
diff --cc drivers/platform/x86/wmi.c
index ec4cfa9ba5d9,6b3b2fe464d2..000000000000
--- a/drivers/platform/x86/wmi.c
+++ b/drivers/platform/x86/wmi.c
@@@ -784,21 -958,13 +784,19 @@@ static int wmi_dev_match(struct device 
  }
  static int wmi_char_open(struct inode *inode, struct file *filp)
  {
++<<<<<<< HEAD
 +	const char *driver_name = filp->f_path.dentry->d_iname;
 +	struct wmi_block *wblock = NULL;
 +	struct wmi_block *next = NULL;
++=======
+ 	/*
+ 	 * The miscdevice already stores a pointer to itself
+ 	 * inside filp->private_data
+ 	 */
+ 	struct wmi_block *wblock = container_of(filp->private_data, struct wmi_block, char_dev);
++>>>>>>> eba9ac7abab9 (platform/x86: wmi: Fix opening of char device)
  
- 	list_for_each_entry_safe(wblock, next, &wmi_block_list, list) {
- 		if (!wblock->dev.dev.driver)
- 			continue;
- 		if (strcmp(driver_name, wblock->dev.dev.driver->name) == 0) {
- 			filp->private_data = wblock;
- 			break;
- 		}
- 	}
- 
- 	if (!filp->private_data)
- 		return -ENODEV;
+ 	filp->private_data = wblock;
  
  	return nonseekable_open(inode, filp);
  }
* Unmerged path drivers/platform/x86/wmi.c
