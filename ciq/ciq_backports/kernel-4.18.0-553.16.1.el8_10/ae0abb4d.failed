cifs: convert list_for_each to entry variant

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit ae0abb4dac8ff22d84ae0bc7d5b74c4691f3ad25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/ae0abb4d.failed

Convert list_for_each{,_safe} to list_for_each_entry{,_safe} in
cifs_mark_tcp_ses_conns_for_reconnect() function.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Reviewed-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit ae0abb4dac8ff22d84ae0bc7d5b74c4691f3ad25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 13237453ae19,9637465d23db..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -210,88 -199,33 +210,88 @@@ static inline int reconn_setup_dfs_targ
  }
  #endif
  
 -/**
 - * Mark all sessions and tcons for reconnect.
 +/*
 + * cifs tcp session reconnection
   *
 - * @server needs to be previously set to CifsNeedReconnect.
 + * mark tcp session as reconnecting so temporarily locked
 + * mark all smb sessions as reconnecting for tcp session
 + * reconnect tcp session
 + * wake up waiters on reconnection? - (not needed currently)
   */
 -static void cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server)
 +int
 +cifs_reconnect(struct TCP_Server_Info *server)
  {
++<<<<<<< HEAD
 +	int rc = 0;
 +	struct list_head *tmp, *tmp2;
++=======
++>>>>>>> ae0abb4dac8f (cifs: convert list_for_each to entry variant)
  	struct cifs_ses *ses;
  	struct cifs_tcon *tcon;
- 	struct mid_q_entry *mid_entry;
+ 	struct mid_q_entry *mid, *nmid;
  	struct list_head retry_list;
 +#ifdef CONFIG_CIFS_DFS_UPCALL
 +	struct super_block *sb = NULL;
 +	struct cifs_sb_info *cifs_sb = NULL;
 +	struct dfs_cache_tgt_list tgt_list = DFS_CACHE_TGT_LIST_INIT(tgt_list);
 +	struct dfs_cache_tgt_iterator *tgt_it = NULL;
 +#endif
  
 +	spin_lock(&GlobalMid_Lock);
 +	server->nr_targets = 1;
 +#ifdef CONFIG_CIFS_DFS_UPCALL
 +	spin_unlock(&GlobalMid_Lock);
 +	sb = cifs_get_tcp_super(server);
 +	if (IS_ERR(sb)) {
 +		rc = PTR_ERR(sb);
 +		cifs_dbg(FYI, "%s: will not do DFS failover: rc = %d\n",
 +			 __func__, rc);
 +		sb = NULL;
 +	} else {
 +		cifs_sb = CIFS_SB(sb);
 +		rc = reconn_setup_dfs_targets(cifs_sb, &tgt_list);
 +		if (rc) {
 +			cifs_sb = NULL;
 +			if (rc != -EOPNOTSUPP) {
 +				cifs_server_dbg(VFS, "%s: no target servers for DFS failover\n",
 +						__func__);
 +			}
 +		} else {
 +			server->nr_targets = dfs_cache_get_nr_tgts(&tgt_list);
 +		}
 +	}
 +	cifs_dbg(FYI, "%s: will retry %d target(s)\n", __func__,
 +		 server->nr_targets);
 +	spin_lock(&GlobalMid_Lock);
 +#endif
 +	if (server->tcpStatus == CifsExiting) {
 +		/* the demux thread will exit normally
 +		next time through the loop */
 +		spin_unlock(&GlobalMid_Lock);
 +#ifdef CONFIG_CIFS_DFS_UPCALL
 +		dfs_cache_free_tgts(&tgt_list);
 +		cifs_put_tcp_super(sb);
 +#endif
 +		wake_up(&server->response_q);
 +		return rc;
 +	} else
 +		server->tcpStatus = CifsNeedReconnect;
 +	spin_unlock(&GlobalMid_Lock);
  	server->maxBuf = 0;
  	server->max_read = 0;
  
  	cifs_dbg(FYI, "Mark tcp session as need reconnect\n");
 -	trace_smb3_reconnect(server->CurrentMid, server->conn_id, server->hostname);
 -	/*
 -	 * before reconnecting the tcp session, mark the smb session (uid) and the tid bad so they
 -	 * are not used until reconnected.
 -	 */
 -	cifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n", __func__);
 +	trace_smb3_reconnect(server->CurrentMid, server->hostname);
 +
 +	/* before reconnecting the tcp session, mark the smb session (uid)
 +		and the tid bad so they are not used until reconnected */
 +	cifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n",
 +		 __func__);
  	spin_lock(&cifs_tcp_ses_lock);
- 	list_for_each(tmp, &server->smb_ses_list) {
- 		ses = list_entry(tmp, struct cifs_ses, smb_ses_list);
+ 	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
  		ses->need_reconnect = true;
- 		list_for_each(tmp2, &ses->tcon_list) {
- 			tcon = list_entry(tmp2, struct cifs_tcon, tcon_list);
+ 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
- 		}
  		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
  	}
* Unmerged path fs/cifs/connect.c
