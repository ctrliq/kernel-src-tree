xfs: validate block number being freed before adding to xefi

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Dave Chinner <dchinner@redhat.com>
commit 7dfee17b13e5024c5c0ab1911859ded4182de3e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/7dfee17b.failed

Bad things happen in defered extent freeing operations if it is
passed a bad block number in the xefi. This can come from a bogus
agno/agbno pair from deferred agfl freeing, or just a bad fsbno
being passed to __xfs_free_extent_later(). Either way, it's very
difficult to diagnose where a null perag oops in EFI creation
is coming from when the operation that queued the xefi has already
been completed and there's no longer any trace of it around....

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit 7dfee17b13e5024c5c0ab1911859ded4182de3e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_ag.c
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_alloc.h
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap_btree.c
#	fs/xfs/libxfs/xfs_ialloc.c
#	fs/xfs/libxfs/xfs_refcount.c
#	fs/xfs/xfs_reflink.c
diff --cc fs/xfs/libxfs/xfs_ag.c
index 23949ec287d3,ee84835ebc66..000000000000
--- a/fs/xfs/libxfs/xfs_ag.c
+++ b/fs/xfs/libxfs/xfs_ag.c
@@@ -850,7 -984,10 +850,14 @@@ xfs_ag_shrink_space
  		if (err2 != -ENOSPC)
  			goto resv_err;
  
++<<<<<<< HEAD
 +		__xfs_bmap_add_free(*tpp, args.fsbno, delta, NULL, true);
++=======
+ 		err2 = __xfs_free_extent_later(*tpp, args.fsbno, delta, NULL,
+ 				true);
+ 		if (err2)
+ 			goto resv_err;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  
  		/*
  		 * Roll the transaction before trying to re-init the per-ag
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 2debb6bf24be,c20fe99405d8..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -2487,21 -2439,85 +2487,90 @@@ xfs_defer_agfl_block
  	struct xfs_owner_info		*oinfo)
  {
  	struct xfs_mount		*mp = tp->t_mountp;
 -	struct xfs_extent_free_item	*xefi;
 +	struct xfs_extent_free_item	*new;		/* new element */
  
 -	ASSERT(xfs_extfree_item_cache != NULL);
 +	ASSERT(xfs_bmap_free_item_zone != NULL);
  	ASSERT(oinfo != NULL);
  
 -	xefi = kmem_cache_zalloc(xfs_extfree_item_cache,
 +	new = kmem_cache_alloc(xfs_bmap_free_item_zone,
  			       GFP_KERNEL | __GFP_NOFAIL);
 -	xefi->xefi_startblock = XFS_AGB_TO_FSB(mp, agno, agbno);
 -	xefi->xefi_blockcount = 1;
 -	xefi->xefi_owner = oinfo->oi_owner;
 +	new->xefi_startblock = XFS_AGB_TO_FSB(mp, agno, agbno);
 +	new->xefi_blockcount = 1;
 +	new->xefi_oinfo = *oinfo;
 +	new->xefi_skip_discard = false;
  
+ 	if (XFS_IS_CORRUPT(mp, !xfs_verify_fsbno(mp, xefi->xefi_startblock)))
+ 		return -EFSCORRUPTED;
+ 
  	trace_xfs_agfl_free_defer(mp, agno, 0, agbno, 1);
  
++<<<<<<< HEAD
 +	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_AGFL_FREE, &new->xefi_list);
++=======
+ 	xfs_extent_free_get_group(mp, xefi);
+ 	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_AGFL_FREE, &xefi->xefi_list);
+ 	return 0;
+ }
+ 
+ /*
+  * Add the extent to the list of extents to be free at transaction end.
+  * The list is maintained sorted (by block number).
+  */
+ int
+ __xfs_free_extent_later(
+ 	struct xfs_trans		*tp,
+ 	xfs_fsblock_t			bno,
+ 	xfs_filblks_t			len,
+ 	const struct xfs_owner_info	*oinfo,
+ 	bool				skip_discard)
+ {
+ 	struct xfs_extent_free_item	*xefi;
+ 	struct xfs_mount		*mp = tp->t_mountp;
+ #ifdef DEBUG
+ 	xfs_agnumber_t			agno;
+ 	xfs_agblock_t			agbno;
+ 
+ 	ASSERT(bno != NULLFSBLOCK);
+ 	ASSERT(len > 0);
+ 	ASSERT(len <= XFS_MAX_BMBT_EXTLEN);
+ 	ASSERT(!isnullstartblock(bno));
+ 	agno = XFS_FSB_TO_AGNO(mp, bno);
+ 	agbno = XFS_FSB_TO_AGBNO(mp, bno);
+ 	ASSERT(agno < mp->m_sb.sb_agcount);
+ 	ASSERT(agbno < mp->m_sb.sb_agblocks);
+ 	ASSERT(len < mp->m_sb.sb_agblocks);
+ 	ASSERT(agbno + len <= mp->m_sb.sb_agblocks);
+ #endif
+ 	ASSERT(xfs_extfree_item_cache != NULL);
+ 
+ 	if (XFS_IS_CORRUPT(mp, !xfs_verify_fsbext(mp, bno, len)))
+ 		return -EFSCORRUPTED;
+ 
+ 	xefi = kmem_cache_zalloc(xfs_extfree_item_cache,
+ 			       GFP_KERNEL | __GFP_NOFAIL);
+ 	xefi->xefi_startblock = bno;
+ 	xefi->xefi_blockcount = (xfs_extlen_t)len;
+ 	if (skip_discard)
+ 		xefi->xefi_flags |= XFS_EFI_SKIP_DISCARD;
+ 	if (oinfo) {
+ 		ASSERT(oinfo->oi_offset == 0);
+ 
+ 		if (oinfo->oi_flags & XFS_OWNER_INFO_ATTR_FORK)
+ 			xefi->xefi_flags |= XFS_EFI_ATTR_FORK;
+ 		if (oinfo->oi_flags & XFS_OWNER_INFO_BMBT_BLOCK)
+ 			xefi->xefi_flags |= XFS_EFI_BMBT_BLOCK;
+ 		xefi->xefi_owner = oinfo->oi_owner;
+ 	} else {
+ 		xefi->xefi_owner = XFS_RMAP_OWN_NULL;
+ 	}
+ 	trace_xfs_bmap_free_defer(mp,
+ 			XFS_FSB_TO_AGNO(tp->t_mountp, bno), 0,
+ 			XFS_FSB_TO_AGBNO(tp->t_mountp, bno), len);
+ 
+ 	xfs_extent_free_get_group(mp, xefi);
+ 	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_FREE, &xefi->xefi_list);
+ 	return 0;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  }
  
  #ifdef DEBUG
diff --cc fs/xfs/libxfs/xfs_alloc.h
index 8f05e92ddf79,85ac470be0da..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.h
+++ b/fs/xfs/libxfs/xfs_alloc.h
@@@ -247,4 -230,44 +247,47 @@@ xfs_buf_to_agfl_bno
  	return bp->b_addr;
  }
  
++<<<<<<< HEAD
++=======
+ int __xfs_free_extent_later(struct xfs_trans *tp, xfs_fsblock_t bno,
+ 		xfs_filblks_t len, const struct xfs_owner_info *oinfo,
+ 		bool skip_discard);
+ 
+ /*
+  * List of extents to be free "later".
+  * The list is kept sorted on xbf_startblock.
+  */
+ struct xfs_extent_free_item {
+ 	struct list_head	xefi_list;
+ 	uint64_t		xefi_owner;
+ 	xfs_fsblock_t		xefi_startblock;/* starting fs block number */
+ 	xfs_extlen_t		xefi_blockcount;/* number of blocks in extent */
+ 	struct xfs_perag	*xefi_pag;
+ 	unsigned int		xefi_flags;
+ };
+ 
+ void xfs_extent_free_get_group(struct xfs_mount *mp,
+ 		struct xfs_extent_free_item *xefi);
+ 
+ #define XFS_EFI_SKIP_DISCARD	(1U << 0) /* don't issue discard */
+ #define XFS_EFI_ATTR_FORK	(1U << 1) /* freeing attr fork block */
+ #define XFS_EFI_BMBT_BLOCK	(1U << 2) /* freeing bmap btree block */
+ 
+ static inline int
+ xfs_free_extent_later(
+ 	struct xfs_trans		*tp,
+ 	xfs_fsblock_t			bno,
+ 	xfs_filblks_t			len,
+ 	const struct xfs_owner_info	*oinfo)
+ {
+ 	return __xfs_free_extent_later(tp, bno, len, oinfo, false);
+ }
+ 
+ 
+ extern struct kmem_cache	*xfs_extfree_item_cache;
+ 
+ int __init xfs_extfree_intent_init_cache(void);
+ void xfs_extfree_intent_destroy_cache(void);
+ 
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  #endif	/* __XFS_ALLOC_H__ */
diff --cc fs/xfs/libxfs/xfs_bmap.c
index d4005787a5af,fef35696adb7..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -624,8 -572,12 +624,16 @@@ xfs_bmap_btree_to_extents
  	cblock = XFS_BUF_TO_BLOCK(cbp);
  	if ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))
  		return error;
+ 
  	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, whichfork);
++<<<<<<< HEAD
 +	xfs_bmap_add_free(cur->bc_tp, cbno, 1, &oinfo);
++=======
+ 	error = xfs_free_extent_later(cur->bc_tp, cbno, 1, &oinfo);
+ 	if (error)
+ 		return error;
+ 
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  	ip->i_nblocks--;
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
  	xfs_trans_binval(tp, cbp);
@@@ -5285,7 -5234,7 +5293,11 @@@ xfs_bmap_del_extent_real
  		if (xfs_is_reflink_inode(ip) && whichfork == XFS_DATA_FORK) {
  			xfs_refcount_decrease_extent(tp, del);
  		} else {
++<<<<<<< HEAD
 +			__xfs_bmap_add_free(tp, del->br_startblock,
++=======
+ 			error = __xfs_free_extent_later(tp, del->br_startblock,
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  					del->br_blockcount, NULL,
  					(bflags & XFS_BMAPI_NODISCARD) ||
  					del->br_state == XFS_EXT_UNWRITTEN);
diff --cc fs/xfs/libxfs/xfs_bmap_btree.c
index 1ceba020940e,36564ae3084f..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@@ -282,13 -266,16 +282,21 @@@ xfs_bmbt_free_block
  	struct xfs_mount	*mp = cur->bc_mp;
  	struct xfs_inode	*ip = cur->bc_ino.ip;
  	struct xfs_trans	*tp = cur->bc_tp;
 -	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, xfs_buf_daddr(bp));
 +	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));
  	struct xfs_owner_info	oinfo;
+ 	int			error;
  
  	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, cur->bc_ino.whichfork);
++<<<<<<< HEAD
 +	xfs_bmap_add_free(cur->bc_tp, fsbno, 1, &oinfo);
 +	ip->i_nblocks--;
++=======
+ 	error = xfs_free_extent_later(cur->bc_tp, fsbno, 1, &oinfo);
+ 	if (error)
+ 		return error;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  
+ 	ip->i_nblocks--;
  	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
  	return 0;
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 19eb7ec0103f,34600f94c2f4..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -1828,10 -1851,10 +1828,17 @@@ xfs_difree_inode_chunk
  
  	if (!xfs_inobt_issparse(rec->ir_holemask)) {
  		/* not sparse, calculate extent info directly */
++<<<<<<< HEAD
 +		xfs_bmap_add_free(tp, XFS_AGB_TO_FSB(mp, agno, sagbno),
 +				  M_IGEO(mp)->ialloc_blks,
 +				  &XFS_RMAP_OINFO_INODES);
 +		return;
++=======
+ 		return xfs_free_extent_later(tp,
+ 				XFS_AGB_TO_FSB(mp, agno, sagbno),
+ 				M_IGEO(mp)->ialloc_blks,
+ 				&XFS_RMAP_OINFO_INODES);
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  	}
  
  	/* holemask is only 16-bits (fits in an unsigned long) */
@@@ -1873,8 -1898,11 +1882,16 @@@
  
  		ASSERT(agbno % mp->m_sb.sb_spino_align == 0);
  		ASSERT(contigblk % mp->m_sb.sb_spino_align == 0);
++<<<<<<< HEAD
 +		xfs_bmap_add_free(tp, XFS_AGB_TO_FSB(mp, agno, agbno),
 +				  contigblk, &XFS_RMAP_OINFO_INODES);
++=======
+ 		error = xfs_free_extent_later(tp,
+ 				XFS_AGB_TO_FSB(mp, agno, agbno),
+ 				contigblk, &XFS_RMAP_OINFO_INODES);
+ 		if (error)
+ 			return error;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  
  		/* reset range to current bit and carry on... */
  		startidx = endidx = nextbit;
diff --cc fs/xfs/libxfs/xfs_refcount.c
index d48712931122,b6e21433925c..000000000000
--- a/fs/xfs/libxfs/xfs_refcount.c
+++ b/fs/xfs/libxfs/xfs_refcount.c
@@@ -1088,8 -1151,10 +1088,15 @@@ xfs_refcount_adjust_extents
  				fsbno = XFS_AGB_TO_FSB(cur->bc_mp,
  						cur->bc_ag.pag->pag_agno,
  						tmp.rc_startblock);
++<<<<<<< HEAD
 +				xfs_bmap_add_free(cur->bc_tp, fsbno,
 +						  tmp.rc_blockcount, oinfo);
++=======
+ 				error = xfs_free_extent_later(cur->bc_tp, fsbno,
+ 						  tmp.rc_blockcount, NULL);
+ 				if (error)
+ 					goto out_error;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  			}
  
  			(*agbno) += tmp.rc_blockcount;
@@@ -1133,8 -1212,10 +1140,15 @@@
  			fsbno = XFS_AGB_TO_FSB(cur->bc_mp,
  					cur->bc_ag.pag->pag_agno,
  					ext.rc_startblock);
++<<<<<<< HEAD
 +			xfs_bmap_add_free(cur->bc_tp, fsbno, ext.rc_blockcount,
 +					  oinfo);
++=======
+ 			error = xfs_free_extent_later(cur->bc_tp, fsbno,
+ 					ext.rc_blockcount, NULL);
+ 			if (error)
+ 				goto out_error;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  		}
  
  skip:
@@@ -1858,7 -1980,10 +1872,14 @@@ xfs_refcount_recover_cow_leftovers
  				rr->rr_rrec.rc_blockcount);
  
  		/* Free the block. */
++<<<<<<< HEAD
 +		xfs_bmap_add_free(tp, fsb, rr->rr_rrec.rc_blockcount, NULL);
++=======
+ 		error = xfs_free_extent_later(tp, fsb,
+ 				rr->rr_rrec.rc_blockcount, NULL);
+ 		if (error)
+ 			goto out_trans;
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  
  		error = xfs_trans_commit(tp);
  		if (error)
diff --cc fs/xfs/xfs_reflink.c
index 64f0a9bc5183,abcc559f3c64..000000000000
--- a/fs/xfs/xfs_reflink.c
+++ b/fs/xfs/xfs_reflink.c
@@@ -615,8 -616,10 +615,14 @@@ xfs_reflink_cancel_cow_blocks
  			xfs_refcount_free_cow_extent(*tpp, del.br_startblock,
  					del.br_blockcount);
  
++<<<<<<< HEAD
 +			xfs_bmap_add_free(*tpp, del.br_startblock,
++=======
+ 			error = xfs_free_extent_later(*tpp, del.br_startblock,
++>>>>>>> 7dfee17b13e5 (xfs: validate block number being freed before adding to xefi)
  					  del.br_blockcount, NULL);
+ 			if (error)
+ 				break;
  
  			/* Roll the transaction */
  			error = xfs_defer_finish(tpp);
* Unmerged path fs/xfs/libxfs/xfs_ag.c
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/libxfs/xfs_alloc.h
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
* Unmerged path fs/xfs/libxfs/xfs_refcount.c
* Unmerged path fs/xfs/xfs_reflink.c
