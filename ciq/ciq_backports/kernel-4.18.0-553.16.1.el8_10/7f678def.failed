skb_expand_head() adjust skb->truesize incorrectly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Vasily Averin <vvs@virtuozzo.com>
commit 7f678def99d29c520418607509bb19c7fc96a6db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/7f678def.failed

Christoph Paasch reports [1] about incorrect skb->truesize
after skb_expand_head() call in ip6_xmit.
This may happen because of two reasons:
- skb_set_owner_w() for newly cloned skb is called too early,
before pskb_expand_head() where truesize is adjusted for (!skb-sk) case.
- pskb_expand_head() does not adjust truesize in (skb->sk) case.
In this case sk->sk_wmem_alloc should be adjusted too.

[1] https://lkml.org/lkml/2021/8/20/1082

Fixes: f1260ff15a71 ("skbuff: introduce skb_expand_head()")
Fixes: 2d85a1b31dde ("ipv6: ip6_finish_output2: set sk into newly allocated nskb")
	Reported-by: Christoph Paasch <christoph.paasch@gmail.com>
	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/644330dd-477e-0462-83bf-9f514c41edd1@virtuozzo.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 7f678def99d29c520418607509bb19c7fc96a6db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skbuff.c
diff --cc net/core/skbuff.c
index b685343d9dfe,fe9358437380..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -1937,6 -1791,57 +1938,60 @@@ struct sk_buff *skb_realloc_headroom(st
  EXPORT_SYMBOL(skb_realloc_headroom);
  
  /**
++<<<<<<< HEAD
++=======
+  *	skb_expand_head - reallocate header of &sk_buff
+  *	@skb: buffer to reallocate
+  *	@headroom: needed headroom
+  *
+  *	Unlike skb_realloc_headroom, this one does not allocate a new skb
+  *	if possible; copies skb->sk to new skb as needed
+  *	and frees original skb in case of failures.
+  *
+  *	It expect increased headroom and generates warning otherwise.
+  */
+ 
+ struct sk_buff *skb_expand_head(struct sk_buff *skb, unsigned int headroom)
+ {
+ 	int delta = headroom - skb_headroom(skb);
+ 	int osize = skb_end_offset(skb);
+ 	struct sock *sk = skb->sk;
+ 
+ 	if (WARN_ONCE(delta <= 0,
+ 		      "%s is expecting an increase in the headroom", __func__))
+ 		return skb;
+ 
+ 	delta = SKB_DATA_ALIGN(delta);
+ 	/* pskb_expand_head() might crash, if skb is shared. */
+ 	if (skb_shared(skb) || !is_skb_wmem(skb)) {
+ 		struct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);
+ 
+ 		if (unlikely(!nskb))
+ 			goto fail;
+ 
+ 		if (sk)
+ 			skb_set_owner_w(nskb, sk);
+ 		consume_skb(skb);
+ 		skb = nskb;
+ 	}
+ 	if (pskb_expand_head(skb, delta, 0, GFP_ATOMIC))
+ 		goto fail;
+ 
+ 	if (sk && is_skb_wmem(skb)) {
+ 		delta = skb_end_offset(skb) - osize;
+ 		refcount_add(delta, &sk->sk_wmem_alloc);
+ 		skb->truesize += delta;
+ 	}
+ 	return skb;
+ 
+ fail:
+ 	kfree_skb(skb);
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(skb_expand_head);
+ 
+ /**
++>>>>>>> 7f678def99d2 (skb_expand_head() adjust skb->truesize incorrectly)
   *	skb_copy_expand	-	copy and expand sk_buff
   *	@skb: buffer to copy
   *	@newheadroom: new free bytes at head
* Unmerged path net/core/skbuff.c
diff --git a/net/core/sock_destructor.h b/net/core/sock_destructor.h
new file mode 100644
index 000000000000..2f396e6bfba5
--- /dev/null
+++ b/net/core/sock_destructor.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef _NET_CORE_SOCK_DESTRUCTOR_H
+#define _NET_CORE_SOCK_DESTRUCTOR_H
+#include <net/tcp.h>
+
+static inline bool is_skb_wmem(const struct sk_buff *skb)
+{
+	return skb->destructor == sock_wfree ||
+	       skb->destructor == __sock_wfree ||
+	       (IS_ENABLED(CONFIG_INET) && skb->destructor == tcp_wfree);
+}
+#endif
