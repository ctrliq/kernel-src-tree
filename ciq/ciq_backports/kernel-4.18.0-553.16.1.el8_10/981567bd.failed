cifs: use the correct max-length for dentry_path_raw()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 981567bd965329df7e64b13e92a54da816c1e0a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/981567bd.failed

RHBZ: 1972502

PATH_MAX is 4096 but PAGE_SIZE can be >4096 on some architectures
such as ppc and would thus write beyond the end of the actual object.

	Cc: <stable@vger.kernel.org>
	Reported-by: Xiaoli Feng <xifeng@redhat.com>
	Suggested-by: Brian foster <bfoster@redhat.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 981567bd965329df7e64b13e92a54da816c1e0a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/dir.c
diff --cc fs/cifs/dir.c
index 26bfed1a114a,5f8a302ffcb2..000000000000
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@@ -111,77 -100,30 +111,92 @@@ build_path_from_dentry_optional_prefix(
  	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)
  		pplen = cifs_sb->prepath ? strlen(cifs_sb->prepath) + 1 : 0;
  
++<<<<<<< HEAD
 +cifs_bp_rename_retry:
 +	namelen = dfsplen + pplen;
 +	seq = read_seqbegin(&rename_lock);
 +	rcu_read_lock();
 +	for (temp = direntry; !IS_ROOT(temp);) {
 +		namelen += (1 + temp->d_name.len);
 +		temp = temp->d_parent;
 +		if (temp == NULL) {
 +			cifs_dbg(VFS, "corrupt dentry\n");
 +			rcu_read_unlock();
 +			return NULL;
 +		}
++=======
+ 	s = dentry_path_raw(direntry, page, PATH_MAX);
+ 	if (IS_ERR(s))
+ 		return s;
+ 	if (!s[1])	// for root we want "", not "/"
+ 		s++;
+ 	if (s < (char *)page + pplen + dfsplen)
+ 		return ERR_PTR(-ENAMETOOLONG);
+ 	if (pplen) {
+ 		cifs_dbg(FYI, "using cifs_sb prepath <%s>\n", cifs_sb->prepath);
+ 		s -= pplen;
+ 		memcpy(s + 1, cifs_sb->prepath, pplen - 1);
+ 		*s = '/';
++>>>>>>> 981567bd9653 (cifs: use the correct max-length for dentry_path_raw())
  	}
 -	if (dirsep != '/') {
 -		/* BB test paths to Windows with '/' in the midst of prepath */
 -		char *p;
 +	rcu_read_unlock();
 +
 +	full_path = kmalloc(namelen+1, GFP_ATOMIC);
 +	if (full_path == NULL)
 +		return full_path;
 +	full_path[namelen] = 0;	/* trailing null */
 +	rcu_read_lock();
 +	for (temp = direntry; !IS_ROOT(temp);) {
 +		spin_lock(&temp->d_lock);
 +		namelen -= 1 + temp->d_name.len;
 +		if (namelen < 0) {
 +			spin_unlock(&temp->d_lock);
 +			break;
 +		} else {
 +			full_path[namelen] = dirsep;
 +			strncpy(full_path + namelen + 1, temp->d_name.name,
 +				temp->d_name.len);
 +			cifs_dbg(FYI, "name: %s\n", full_path + namelen);
 +		}
 +		spin_unlock(&temp->d_lock);
 +		temp = temp->d_parent;
 +		if (temp == NULL) {
 +			cifs_dbg(VFS, "corrupt dentry\n");
 +			rcu_read_unlock();
 +			kfree(full_path);
 +			return NULL;
 +		}
 +	}
 +	rcu_read_unlock();
 +	if (namelen != dfsplen + pplen || read_seqretry(&rename_lock, seq)) {
 +		cifs_dbg(FYI, "did not end path lookup where expected. namelen=%ddfsplen=%d\n",
 +			 namelen, dfsplen);
 +		/* presumably this is only possible if racing with a rename
 +		of one of the parent directories  (we can not lock the dentries
 +		above us to prevent this, but retrying should be harmless) */
 +		kfree(full_path);
 +		goto cifs_bp_rename_retry;
 +	}
 +	/* DIR_SEP already set for byte  0 / vs \ but not for
 +	   subsequent slashes in prepath which currently must
 +	   be entered the right way - not sure if there is an alternative
 +	   since the '\' is a valid posix character so we can not switch
 +	   those safely to '/' if any are found in the middle of the prepath */
 +	/* BB test paths to Windows with '/' in the midst of prepath */
 +
 +	if (pplen) {
 +		int i;
  
 -		for (p = s; *p; p++)
 -			if (*p == '/')
 -				*p = dirsep;
 +		cifs_dbg(FYI, "using cifs_sb prepath <%s>\n", cifs_sb->prepath);
 +		memcpy(full_path+dfsplen+1, cifs_sb->prepath, pplen-1);
 +		full_path[dfsplen] = dirsep;
 +		for (i = 0; i < pplen-1; i++)
 +			if (full_path[dfsplen+1+i] == '/')
 +				full_path[dfsplen+1+i] = CIFS_DIR_SEP(cifs_sb);
  	}
 +
  	if (dfsplen) {
 -		s -= dfsplen;
 -		memcpy(s, tcon->treeName, dfsplen);
 +		strncpy(full_path, tcon->treeName, dfsplen);
  		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {
  			int i;
  			for (i = 0; i < dfsplen; i++) {
* Unmerged path fs/cifs/dir.c
