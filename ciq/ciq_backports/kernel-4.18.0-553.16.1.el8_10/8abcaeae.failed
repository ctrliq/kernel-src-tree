cifs: always iterate smb sessions using primary channel

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.16.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 8abcaeaed38109e5ccaf40218e0e9e387f07bfe6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.16.1.el8_10/8abcaeae.failed

smb sessions and tcons currently hang off primary channel only.
Secondary channels have the lists as empty. Whenever there's a
need to iterate sessions or tcons, we should use the list in the
corresponding primary channel.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 8abcaeaed38109e5ccaf40218e0e9e387f07bfe6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/misc.c
#	fs/cifs/smb2misc.c
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/misc.c
index 6786c1311d74,3e68d8208cf5..000000000000
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@@ -411,7 -400,7 +411,11 @@@ is_valid_oplock_break(char *buffer, str
  {
  	struct smb_hdr *buf = (struct smb_hdr *)buffer;
  	struct smb_com_lock_req *pSMB = (struct smb_com_lock_req *)buf;
++<<<<<<< HEAD
 +	struct list_head *tmp, *tmp1, *tmp2;
++=======
+ 	struct TCP_Server_Info *pserver;
++>>>>>>> 8abcaeaed381 (cifs: always iterate smb sessions using primary channel)
  	struct cifs_ses *ses;
  	struct cifs_tcon *tcon;
  	struct cifsInodeInfo *pCifsInode;
@@@ -476,12 -465,13 +480,20 @@@
  	if (!(pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE))
  		return false;
  
+ 	/* If server is a channel, select the primary channel */
+ 	pserver = CIFS_SERVER_IS_CHAN(srv) ? srv->primary_server : srv;
+ 
  	/* look up tcon based on tid & uid */
  	spin_lock(&cifs_tcp_ses_lock);
++<<<<<<< HEAD
 +	list_for_each(tmp, &srv->smb_ses_list) {
 +		ses = list_entry(tmp, struct cifs_ses, smb_ses_list);
 +		list_for_each(tmp1, &ses->tcon_list) {
 +			tcon = list_entry(tmp1, struct cifs_tcon, tcon_list);
++=======
+ 	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+ 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
++>>>>>>> 8abcaeaed381 (cifs: always iterate smb sessions using primary channel)
  			if (tcon->tid != buf->Tid)
  				continue;
  
diff --cc fs/cifs/smb2misc.c
index f3aaa2e43ec2,e73a3c649b87..000000000000
--- a/fs/cifs/smb2misc.c
+++ b/fs/cifs/smb2misc.c
@@@ -145,16 -133,20 +145,29 @@@ static __u32 get_neg_ctxt_len(struct sm
  }
  
  int
 -smb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)
 +smb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *srvr)
  {
++<<<<<<< HEAD
 +	struct smb2_sync_hdr *shdr = (struct smb2_sync_hdr *)buf;
 +	struct smb2_sync_pdu *pdu = (struct smb2_sync_pdu *)shdr;
++=======
+ 	struct TCP_Server_Info *pserver;
+ 	struct smb2_hdr *shdr = (struct smb2_hdr *)buf;
+ 	struct smb2_pdu *pdu = (struct smb2_pdu *)shdr;
+ 	int hdr_size = sizeof(struct smb2_hdr);
+ 	int pdu_size = sizeof(struct smb2_pdu);
+ 	int command;
+ 	__u32 calc_len; /* calculated length */
++>>>>>>> 8abcaeaed381 (cifs: always iterate smb sessions using primary channel)
  	__u64 mid;
 +	__u32 clc_len;  /* calculated length */
 +	int command;
 +	int pdu_size = sizeof(struct smb2_sync_pdu);
 +	int hdr_size = sizeof(struct smb2_sync_hdr);
  
+ 	/* If server is a channel, select the primary channel */
+ 	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+ 
  	/*
  	 * Add function to do table lookup of StructureSize by command
  	 * ie Validate the wct via smb2_struct_sizes table above
@@@ -166,13 -158,15 +179,19 @@@
  
  		/* decrypt frame now that it is completely read in */
  		spin_lock(&cifs_tcp_ses_lock);
++<<<<<<< HEAD
 +		list_for_each_entry(ses, &srvr->smb_ses_list, smb_ses_list) {
 +			if (ses->Suid == thdr->SessionId)
++=======
+ 		list_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {
+ 			if (iter->Suid == le64_to_cpu(thdr->SessionId)) {
+ 				ses = iter;
++>>>>>>> 8abcaeaed381 (cifs: always iterate smb sessions using primary channel)
  				break;
 -			}
  		}
  		spin_unlock(&cifs_tcp_ses_lock);
 -		if (!ses) {
 +		if (list_entry_is_head(ses, &srvr->smb_ses_list,
 +				       smb_ses_list)) {
  			cifs_dbg(VFS, "no decryption - session id not found\n");
  			return 1;
  		}
diff --cc fs/cifs/smb2ops.c
index 2fb9ed3f434e,cca12eadbb07..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -2462,24 -2301,27 +2462,39 @@@ smb2_is_status_io_timeout(char *buf
  static void
  smb2_is_network_name_deleted(char *buf, struct TCP_Server_Info *server)
  {
++<<<<<<< HEAD
 +	struct smb2_sync_hdr *shdr = (struct smb2_sync_hdr *)buf;
 +	struct list_head *tmp, *tmp1;
++=======
+ 	struct smb2_hdr *shdr = (struct smb2_hdr *)buf;
+ 	struct TCP_Server_Info *pserver;
++>>>>>>> 8abcaeaed381 (cifs: always iterate smb sessions using primary channel)
  	struct cifs_ses *ses;
  	struct cifs_tcon *tcon;
  
  	if (shdr->Status != STATUS_NETWORK_NAME_DELETED)
  		return;
  
+ 	/* If server is a channel, select the primary channel */
+ 	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+ 
  	spin_lock(&cifs_tcp_ses_lock);
++<<<<<<< HEAD
 +	list_for_each(tmp, &server->smb_ses_list) {
 +		ses = list_entry(tmp, struct cifs_ses, smb_ses_list);
 +		list_for_each(tmp1, &ses->tcon_list) {
 +			tcon = list_entry(tmp1, struct cifs_tcon, tcon_list);
 +			if (tcon->tid == shdr->TreeId) {
++=======
+ 	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+ 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
+ 			if (tcon->tid == le32_to_cpu(shdr->Id.SyncId.TreeId)) {
+ 				spin_lock(&tcon->tc_lock);
++>>>>>>> 8abcaeaed381 (cifs: always iterate smb sessions using primary channel)
  				tcon->need_reconnect = true;
 -				spin_unlock(&tcon->tc_lock);
  				spin_unlock(&cifs_tcp_ses_lock);
  				pr_warn_once("Server share %s deleted.\n",
 -					     tcon->tree_name);
 +					     tcon->treeName);
  				return;
  			}
  		}
* Unmerged path fs/cifs/misc.c
* Unmerged path fs/cifs/smb2misc.c
* Unmerged path fs/cifs/smb2ops.c
diff --git a/fs/cifs/smb2transport.c b/fs/cifs/smb2transport.c
index 707ad0a1191d..0ef4e410dfda 100644
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@ -148,9 +148,13 @@ int smb2_get_sign_key(__u64 ses_id, struct TCP_Server_Info *server, u8 *key)
 static struct cifs_ses *
 smb2_find_smb_ses_unlocked(struct TCP_Server_Info *server, __u64 ses_id)
 {
+	struct TCP_Server_Info *pserver;
 	struct cifs_ses *ses;
 
-	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
+	/* If server is a channel, select the primary channel */
+	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+
+	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
 		if (ses->Suid != ses_id)
 			continue;
 		++ses->ses_count;
