KVM: x86: Add a helper to retrieve userspace address from kvm_device_attr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.26.1.el8_6
commit-author Sean Christopherson <seanjc@google.com>
commit 56f289a8d23addfa4408a08f07f42fcfe2a7bd69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.26.1.el8_6/56f289a8.failed

Add a helper to handle converting the u64 userspace address embedded in
struct kvm_device_attr into a userspace pointer, it's all too easy to
forget the intermediate "unsigned long" cast as well as the truncation
check.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 56f289a8d23addfa4408a08f07f42fcfe2a7bd69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 3e40344015c8,76a5dcfcabdb..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -4866,6 -5014,115 +4874,118 @@@ static int kvm_set_guest_paused(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int kvm_arch_tsc_has_attr(struct kvm_vcpu *vcpu,
+ 				 struct kvm_device_attr *attr)
+ {
+ 	int r;
+ 
+ 	switch (attr->attr) {
+ 	case KVM_VCPU_TSC_OFFSET:
+ 		r = 0;
+ 		break;
+ 	default:
+ 		r = -ENXIO;
+ 	}
+ 
+ 	return r;
+ }
+ 
+ static int kvm_arch_tsc_get_attr(struct kvm_vcpu *vcpu,
+ 				 struct kvm_device_attr *attr)
+ {
+ 	u64 __user *uaddr = kvm_get_attr_addr(attr);
+ 	int r;
+ 
+ 	if (IS_ERR(uaddr))
+ 		return PTR_ERR(uaddr);
+ 
+ 	switch (attr->attr) {
+ 	case KVM_VCPU_TSC_OFFSET:
+ 		r = -EFAULT;
+ 		if (put_user(vcpu->arch.l1_tsc_offset, uaddr))
+ 			break;
+ 		r = 0;
+ 		break;
+ 	default:
+ 		r = -ENXIO;
+ 	}
+ 
+ 	return r;
+ }
+ 
+ static int kvm_arch_tsc_set_attr(struct kvm_vcpu *vcpu,
+ 				 struct kvm_device_attr *attr)
+ {
+ 	u64 __user *uaddr = kvm_get_attr_addr(attr);
+ 	struct kvm *kvm = vcpu->kvm;
+ 	int r;
+ 
+ 	if (IS_ERR(uaddr))
+ 		return PTR_ERR(uaddr);
+ 
+ 	switch (attr->attr) {
+ 	case KVM_VCPU_TSC_OFFSET: {
+ 		u64 offset, tsc, ns;
+ 		unsigned long flags;
+ 		bool matched;
+ 
+ 		r = -EFAULT;
+ 		if (get_user(offset, uaddr))
+ 			break;
+ 
+ 		raw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);
+ 
+ 		matched = (vcpu->arch.virtual_tsc_khz &&
+ 			   kvm->arch.last_tsc_khz == vcpu->arch.virtual_tsc_khz &&
+ 			   kvm->arch.last_tsc_offset == offset);
+ 
+ 		tsc = kvm_scale_tsc(vcpu, rdtsc(), vcpu->arch.l1_tsc_scaling_ratio) + offset;
+ 		ns = get_kvmclock_base_ns();
+ 
+ 		__kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);
+ 		raw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);
+ 
+ 		r = 0;
+ 		break;
+ 	}
+ 	default:
+ 		r = -ENXIO;
+ 	}
+ 
+ 	return r;
+ }
+ 
+ static int kvm_vcpu_ioctl_device_attr(struct kvm_vcpu *vcpu,
+ 				      unsigned int ioctl,
+ 				      void __user *argp)
+ {
+ 	struct kvm_device_attr attr;
+ 	int r;
+ 
+ 	if (copy_from_user(&attr, argp, sizeof(attr)))
+ 		return -EFAULT;
+ 
+ 	if (attr.group != KVM_VCPU_TSC_CTRL)
+ 		return -ENXIO;
+ 
+ 	switch (ioctl) {
+ 	case KVM_HAS_DEVICE_ATTR:
+ 		r = kvm_arch_tsc_has_attr(vcpu, &attr);
+ 		break;
+ 	case KVM_GET_DEVICE_ATTR:
+ 		r = kvm_arch_tsc_get_attr(vcpu, &attr);
+ 		break;
+ 	case KVM_SET_DEVICE_ATTR:
+ 		r = kvm_arch_tsc_set_attr(vcpu, &attr);
+ 		break;
+ 	}
+ 
+ 	return r;
+ }
+ 
++>>>>>>> 56f289a8d23a (KVM: x86: Add a helper to retrieve userspace address from kvm_device_attr)
  static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,
  				     struct kvm_enable_cap *cap)
  {
* Unmerged path arch/x86/kvm/x86.c
