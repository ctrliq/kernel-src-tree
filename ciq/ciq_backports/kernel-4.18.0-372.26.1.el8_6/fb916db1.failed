ice: introduce VF accessor functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.26.1.el8_6
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit fb916db1f04f8c5f005fafcbe6ae01f40abd6aff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.26.1.el8_6/fb916db1.failed

Before we switch the VF data structure storage mechanism to a hash,
introduce new accessor functions to define the new interface.

* ice_get_vf_by_id is a function used to obtain a reference to a VF from
  the table based on its VF ID
* ice_has_vfs is used to quickly check if any VFs are configured
* ice_get_num_vfs is used to get an exact count of how many VFs are
  configured

We can drop the old ice_validate_vf_id function, since every caller was
just going to immediately access the VF table to get a reference
anyways. This way we simply use the single ice_get_vf_by_id to both
validate the VF ID is within range and that there exists a VF with that
ID.

This change enables us to more easily convert the codebase to the hash
table since most callers now properly use the interface.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Konrad Jankowski <konrad0.jankowski@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit fb916db1f04f8c5f005fafcbe6ae01f40abd6aff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_eswitch.c
#	drivers/net/ethernet/intel/ice/ice_ethtool.c
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
diff --cc drivers/net/ethernet/intel/ice/ice_eswitch.c
index 34a4474731de,c27013afcadb..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c
+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c
@@@ -173,10 -176,20 +173,27 @@@ static void ice_eswitch_remap_rings_to_
  	int q_id;
  
  	ice_for_each_txq(vsi, q_id) {
++<<<<<<< HEAD
 +		struct ice_repr *repr = pf->vf[q_id].repr;
 +		struct ice_q_vector *q_vector = repr->q_vector;
 +		struct ice_tx_ring *tx_ring = vsi->tx_rings[q_id];
 +		struct ice_rx_ring *rx_ring = vsi->rx_rings[q_id];
++=======
+ 		struct ice_q_vector *q_vector;
+ 		struct ice_tx_ring *tx_ring;
+ 		struct ice_rx_ring *rx_ring;
+ 		struct ice_repr *repr;
+ 		struct ice_vf *vf;
+ 
+ 		vf = ice_get_vf_by_id(pf, q_id);
+ 		if (WARN_ON(!vf))
+ 			continue;
+ 
+ 		repr = vf->repr;
+ 		q_vector = repr->q_vector;
+ 		tx_ring = vsi->tx_rings[q_id];
+ 		rx_ring = vsi->rx_rings[q_id];
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  
  		q_vector->vsi = vsi;
  		q_vector->reg_idx = vsi->q_vectors[0]->reg_idx;
@@@ -519,7 -535,7 +536,11 @@@ ice_eswitch_mode_set(struct devlink *de
  	if (pf->eswitch_mode == mode)
  		return 0;
  
++<<<<<<< HEAD
 +	if (pf->num_alloc_vfs) {
++=======
+ 	if (ice_has_vfs(pf)) {
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  		dev_info(ice_pf_to_dev(pf), "Changing eswitch mode is allowed only if there is no VFs created");
  		NL_SET_ERR_MSG_MOD(extack, "Changing eswitch mode is allowed only if there is no VFs created");
  		return -EOPNOTSUPP;
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool.c
index 3e0089fcaa98,83680eaa3565..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@@ -1295,6 -1295,14 +1295,17 @@@ static int ice_set_priv_flags(struct ne
  		change_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags);
  		ret = -EAGAIN;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (test_bit(ICE_FLAG_VF_VLAN_PRUNING, change_flags) &&
+ 	    ice_has_vfs(pf)) {
+ 		dev_err(dev, "vf-vlan-pruning: VLAN pruning cannot be changed while VFs are active.\n");
+ 		/* toggle bit back to previous state */
+ 		change_bit(ICE_FLAG_VF_VLAN_PRUNING, pf->flags);
+ 		ret = -EOPNOTSUPP;
+ 	}
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  ethtool_exit:
  	clear_bit(ICE_FLAG_ETHTOOL_CTXT, pf->flags);
  	return ret;
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 80f50982752a,6ea1d9741808..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -216,8 -215,8 +216,13 @@@ static void ice_vsi_set_num_qs(struct i
  		/* The number of queues for ctrl VSI is equal to number of VFs.
  		 * Each ring is associated to the corresponding VF_PR netdev.
  		 */
++<<<<<<< HEAD
 +		vsi->alloc_txq = pf->num_alloc_vfs;
 +		vsi->alloc_rxq = pf->num_alloc_vfs;
++=======
+ 		vsi->alloc_txq = ice_get_num_vfs(pf);
+ 		vsi->alloc_rxq = vsi->alloc_txq;
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  		vsi->num_q_vectors = 1;
  		break;
  	case ICE_VSI_VF:
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index e45882c22848,535d5f1a763f..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -173,18 -175,58 +173,65 @@@ struct ice_vsi *ice_get_vf_vsi(struct i
  }
  
  /**
-  * ice_validate_vf_id - helper to check if VF ID is valid
-  * @pf: pointer to the PF structure
-  * @vf_id: the ID of the VF to check
+  * ice_get_vf_by_id - Get pointer to VF by ID
+  * @pf: the PF private structure
+  * @vf_id: the VF ID to locate
+  *
+  * Locate and return a pointer to the VF structure associated with a given ID.
+  * Returns NULL if the ID does not have a valid VF structure associated with
+  * it.
   */
- static int ice_validate_vf_id(struct ice_pf *pf, u16 vf_id)
+ struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
  {
++<<<<<<< HEAD
 +	/* vf_id range is only valid for 0-255, and should always be unsigned */
 +	if (vf_id >= pf->num_alloc_vfs) {
 +		dev_err(ice_pf_to_dev(pf), "Invalid VF ID: %u\n", vf_id);
 +		return -EINVAL;
++=======
+ 	if (!pf->vfs.table) {
+ 		dev_err(ice_pf_to_dev(pf), "VF table not allocated\n");
+ 		return NULL;
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	}
- 	return 0;
+ 
+ 	if (vf_id >= pf->vfs.num_alloc) {
+ 		dev_err(ice_pf_to_dev(pf), "Out of range VF ID: %u\n",
+ 			vf_id);
+ 		return NULL;
+ 	}
+ 
+ 	return &pf->vfs.table[vf_id];
+ }
+ 
+ /**
+  * ice_has_vfs - Return true if the PF has any associated VFs
+  * @pf: the PF private structure
+  *
+  * Return whether or not the PF has any allocated VFs.
+  *
+  * Note that this function only guarantees that there are no VFs at the point
+  * of calling it. It does not guarantee that no more VFs will be added.
+  */
+ bool ice_has_vfs(struct ice_pf *pf)
+ {
+ 	return pf->vfs.table && pf->vfs.num_alloc > 0;
+ }
+ 
+ /**
+  * ice_get_num_vfs - Get number of allocated VFs
+  * @pf: the PF private structure
+  *
+  * Return the total number of allocated VFs. NOTE: VF IDs are not guaranteed
+  * to be contiguous. Do not assume that a VF ID is guaranteed to be less than
+  * the output of this function.
+  */
+ u16 ice_get_num_vfs(struct ice_pf *pf)
+ {
+ 	if (!pf->vfs.table)
+ 		return 0;
+ 
+ 	return pf->vfs.num_alloc;
  }
  
  /**
@@@ -497,10 -538,12 +544,14 @@@ static void ice_dis_vf_qs(struct ice_v
  void ice_free_vfs(struct ice_pf *pf)
  {
  	struct device *dev = ice_pf_to_dev(pf);
 -	struct ice_vfs *vfs = &pf->vfs;
  	struct ice_hw *hw = &pf->hw;
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 +	unsigned int i;
  
++<<<<<<< HEAD
 +	if (!pf->vf)
++=======
+ 	if (!ice_has_vfs(pf))
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  		return;
  
  	ice_eswitch_release(pf);
@@@ -1396,10 -1501,10 +1447,14 @@@ bool ice_reset_all_vfs(struct ice_pf *p
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
  	struct ice_vf *vf;
 -	unsigned int bkt;
 +	int v, i;
  
  	/* If we don't have any VFs, then there is nothing to reset */
++<<<<<<< HEAD
 +	if (!pf->num_alloc_vfs)
++=======
+ 	if (!ice_has_vfs(pf))
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  		return false;
  
  	/* clear all malicious info if the VFs are getting reset */
@@@ -1642,7 -1749,7 +1697,11 @@@ void ice_vc_notify_reset(struct ice_pf 
  {
  	struct virtchnl_pf_event pfe;
  
++<<<<<<< HEAD
 +	if (!pf->num_alloc_vfs)
++=======
+ 	if (!ice_has_vfs(pf))
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  		return;
  
  	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
@@@ -2009,15 -2130,14 +2061,19 @@@ void ice_process_vflr_event(struct ice_
  	u32 reg;
  
  	if (!test_and_clear_bit(ICE_VFLR_EVENT_PENDING, pf->state) ||
++<<<<<<< HEAD
 +	    !pf->num_alloc_vfs)
++=======
+ 	    !ice_has_vfs(pf))
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  		return;
  
 -	ice_for_each_vf(pf, bkt, vf) {
 +	ice_for_each_vf(pf, vf_id) {
 +		struct ice_vf *vf = &pf->vf[vf_id];
  		u32 reg_idx, bit_idx;
  
 -		reg_idx = (hw->func_caps.vf_base_id + vf->vf_id) / 32;
 -		bit_idx = (hw->func_caps.vf_base_id + vf->vf_id) % 32;
 +		reg_idx = (hw->func_caps.vf_base_id + vf_id) / 32;
 +		bit_idx = (hw->func_caps.vf_base_id + vf_id) % 32;
  		/* read GLGEN_VFLRSTAT register to find out the flr VFs */
  		reg = rd32(hw, GLGEN_VFLRSTAT(reg_idx));
  		if (reg & BIT(bit_idx)) {
@@@ -2839,10 -3001,11 +2895,15 @@@ int ice_set_vf_spoofchk(struct net_devi
  	int ret;
  
  	dev = ice_pf_to_dev(pf);
- 	if (ice_validate_vf_id(pf, vf_id))
+ 
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	ret = ice_check_vf_ready_for_cfg(vf);
  	if (ret)
  		return ret;
@@@ -4067,7 -4206,10 +4126,14 @@@ ice_set_vf_port_vlan(struct net_device 
  		return -EPROTONOSUPPORT;
  	}
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
+ 		return -EINVAL;
+ 
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	ret = ice_check_vf_ready_for_cfg(vf);
  	if (ret)
  		return ret;
@@@ -4601,10 -5765,6 +4669,13 @@@ void ice_vc_process_vf_msg(struct ice_p
  		return;
  	}
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
 +
 +	mutex_lock(&vf->cfg_lock);
 +
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	/* Check if VF is disabled. */
  	if (test_bit(ICE_VF_STATE_DIS, vf->vf_states)) {
  		err = -EPERM;
@@@ -4744,14 -5933,15 +4815,22 @@@ ice_get_vf_cfg(struct net_device *netde
  {
  	struct ice_pf *pf = ice_netdev_to_pf(netdev);
  	struct ice_vf *vf;
+ 	int ret;
  
- 	if (ice_validate_vf_id(pf, vf_id))
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
 +
 +	if (ice_check_vf_init(pf, vf))
 +		return -EBUSY;
++=======
+ 	ret = ice_check_vf_ready_for_cfg(vf);
+ 	if (ret)
+ 		return ret;
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  
  	ivi->vf = vf_id;
  	ether_addr_copy(ivi->mac, vf->hw_lan_addr.addr);
@@@ -4828,7 -6017,10 +4904,14 @@@ int ice_set_vf_mac(struct net_device *n
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
+ 		return -EINVAL;
+ 
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	/* nothing left to do, unicast MAC already set */
  	if (ether_addr_equal(vf->dev_lan_addr.addr, mac) &&
  	    ether_addr_equal(vf->hw_lan_addr.addr, mac))
@@@ -4887,10 -6079,10 +4970,14 @@@ int ice_set_vf_trust(struct net_device 
  		return -EOPNOTSUPP;
  	}
  
- 	if (ice_validate_vf_id(pf, vf_id))
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	ret = ice_check_vf_ready_for_cfg(vf);
  	if (ret)
  		return ret;
@@@ -4925,10 -6117,10 +5012,14 @@@ int ice_set_vf_link_state(struct net_de
  	struct ice_vf *vf;
  	int ret;
  
- 	if (ice_validate_vf_id(pf, vf_id))
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	ret = ice_check_vf_ready_for_cfg(vf);
  	if (ret)
  		return ret;
@@@ -5018,10 -6212,11 +5109,15 @@@ ice_set_vf_bw(struct net_device *netdev
  	int ret;
  
  	dev = ice_pf_to_dev(pf);
- 	if (ice_validate_vf_id(pf, vf_id))
+ 
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	ret = ice_check_vf_ready_for_cfg(vf);
  	if (ret)
  		return ret;
@@@ -5085,10 -6280,10 +5181,14 @@@ int ice_get_vf_stats(struct net_device 
  	struct ice_vf *vf;
  	int ret;
  
- 	if (ice_validate_vf_id(pf, vf_id))
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	ret = ice_check_vf_ready_for_cfg(vf);
  	if (ret)
  		return ret;
@@@ -5227,10 -6421,10 +5327,14 @@@ ice_is_malicious_vf(struct ice_pf *pf, 
  	struct ice_vf *vf;
  	int status;
  
- 	if (ice_validate_vf_id(pf, vf_id))
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
  		return false;
  
++<<<<<<< HEAD
 +	vf = &pf->vf[vf_id];
++=======
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  	/* Check if VF is disabled. */
  	if (test_bit(ICE_VF_STATE_DIS, vf->vf_states))
  		return false;
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
index 8f27255cc0cc,bc86358fc8e2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
@@@ -37,8 -39,27 +37,32 @@@
  #define ICE_MAX_VF_RESET_TRIES		40
  #define ICE_MAX_VF_RESET_SLEEP_MS	20
  
++<<<<<<< HEAD
 +#define ice_for_each_vf(pf, i) \
 +	for ((i) = 0; (i) < (pf)->num_alloc_vfs; (i)++)
++=======
+ /* VF Hash Table access functions
+  *
+  * These functions provide abstraction for interacting with the VF hash table.
+  * In general, direct access to the hash table should be avoided outside of
+  * these functions where possible.
+  */
+ 
+ /**
+  * ice_for_each_vf - Iterate over each VF entry
+  * @pf: pointer to the PF private structure
+  * @bkt: bucket index used for iteration
+  * @entry: pointer to the VF entry currently being processed in the loop.
+  *
+  * The bkt variable is an unsigned integer iterator used to traverse the VF
+  * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
+  * Use vf->vf_id to get the id number if needed.
+  */
+ #define ice_for_each_vf(pf, bkt, entry)					\
+ 	for ((bkt) = 0, (entry) = &(pf)->vfs.table[0];			\
+ 	     (bkt) < (pf)->vfs.num_alloc;				\
+ 	     (bkt)++, (entry)++)
++>>>>>>> fb916db1f04f (ice: introduce VF accessor functions)
  
  /* Specific VF states */
  enum ice_vf_states {
@@@ -207,7 -252,23 +234,22 @@@ in
  ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
  		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen);
  bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id);
 -bool ice_vf_is_port_vlan_ena(struct ice_vf *vf);
  #else /* CONFIG_PCI_IOV */
+ static inline struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
+ {
+ 	return NULL;
+ }
+ 
+ static inline bool ice_has_vfs(struct ice_pf *pf)
+ {
+ 	return false;
+ }
+ 
+ static inline u16 ice_get_num_vfs(struct ice_pf *pf)
+ {
+ 	return 0;
+ }
+ 
  static inline void ice_process_vflr_event(struct ice_pf *pf) { }
  static inline void ice_free_vfs(struct ice_pf *pf) { }
  static inline
* Unmerged path drivers/net/ethernet/intel/ice/ice_eswitch.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
