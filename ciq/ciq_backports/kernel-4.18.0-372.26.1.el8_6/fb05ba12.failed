ice: Introduce ice_vlan struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.26.1.el8_6
commit-author Brett Creeley <brett.creeley@intel.com>
commit fb05ba1257d727b4532dc943851d5ee24ae7cafd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.26.1.el8_6/fb05ba12.failed

Add a new struct for VLAN related information. Currently this holds
VLAN ID and priority values, but will be expanded to hold TPID value.
This reduces the changes necessary if any other values are added in
future. Remove the action argument from these calls as it's always
ICE_FWD_VSI.

	Signed-off-by: Brett Creeley <brett.creeley@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit fb05ba1257d727b4532dc943851d5ee24ae7cafd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
#	drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.c
#	drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.h
#	drivers/net/ethernet/intel/ice/ice_vsi_vlan_ops.h
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 737ccd2dacf6,58e796191a0f..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -4144,7 -3921,10 +4144,14 @@@ int ice_set_link(struct ice_vsi *vsi, b
   */
  int ice_vsi_add_vlan_zero(struct ice_vsi *vsi)
  {
++<<<<<<< HEAD
 +	return ice_vsi_add_vlan(vsi, 0, ICE_FWD_TO_VSI);
++=======
+ 	struct ice_vlan vlan;
+ 
+ 	vlan = ICE_VLAN(0, 0);
+ 	return vsi->vlan_ops.add_vlan(vsi, &vlan);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index c72c372436a2,cc13943a1d88..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -3484,23 -3430,10 +3485,30 @@@ ice_vlan_rx_add_vid(struct net_device *
  	/* Add a switch rule for this VLAN ID so its corresponding VLAN tagged
  	 * packets aren't pruned by the device's internal switch on Rx
  	 */
++<<<<<<< HEAD
 +	ret = ice_vsi_add_vlan(vsi, vid, ICE_FWD_TO_VSI);
 +	if (ret)
 +		goto finish;
 +
 +	/* If all-multicast is currently enabled and this VLAN ID is only one
 +	 * besides VLAN-0 we have to update look-up type of multicast promisc
 +	 * rule for VLAN-0 from ICE_SW_LKUP_PROMISC to ICE_SW_LKUP_PROMISC_VLAN.
 +	 */
 +	if ((vsi->current_netdev_flags & IFF_ALLMULTI) && vsi->num_vlan == 2) {
 +		ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
 +					   ICE_MCAST_PROMISC_BITS, 0);
 +		ice_fltr_set_vsi_promisc(&vsi->back->hw, vsi->idx,
 +					 ICE_MCAST_VLAN_PROMISC_BITS, 0);
 +	}
 +
 +finish:
 +	clear_bit(ICE_CFG_BUSY, vsi->state);
++=======
+ 	vlan = ICE_VLAN(vid, 0);
+ 	ret = vsi->vlan_ops.add_vlan(vsi, &vlan);
+ 	if (!ret)
+ 		set_bit(ICE_VSI_VLAN_FLTR_CHANGED, vsi->state);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  
  	return ret;
  }
@@@ -3525,44 -3459,19 +3534,49 @@@ ice_vlan_rx_kill_vid(struct net_device 
  	if (!vid)
  		return 0;
  
 -	/* Make sure VLAN delete is successful before updating VLAN
 +	while (test_and_set_bit(ICE_CFG_BUSY, vsi->state))
 +		usleep_range(1000, 2000);
 +
 +	/* Make sure ice_vsi_kill_vlan is successful before updating VLAN
  	 * information
  	 */
++<<<<<<< HEAD
 +	ret = ice_vsi_kill_vlan(vsi, vid);
++=======
+ 	vlan = ICE_VLAN(vid, 0);
+ 	ret = vsi->vlan_ops.del_vlan(vsi, &vlan);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  	if (ret)
 -		return ret;
 +		goto finish;
  
 -	/* Disable pruning when VLAN 0 is the only VLAN rule */
 -	if (vsi->num_vlan == 1 && ice_vsi_is_vlan_pruning_ena(vsi))
 -		vsi->vlan_ops.dis_rx_filtering(vsi);
 +	/* Remove multicast promisc rule for the removed VLAN ID if
 +	 * all-multicast is enabled.
 +	 */
 +	if (vsi->current_netdev_flags & IFF_ALLMULTI)
 +		ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
 +					   ICE_MCAST_VLAN_PROMISC_BITS, vid);
 +
 +	if (vsi->num_vlan == 1) {
 +		/* Disable pruning when VLAN 0 is the only VLAN rule */
 +		if (ice_vsi_is_vlan_pruning_ena(vsi))
 +			ice_cfg_vlan_pruning(vsi, false);
 +
 +		/* Update look-up type of multicast promisc rule for VLAN 0
 +		 * from ICE_SW_LKUP_PROMISC_VLAN to ICE_SW_LKUP_PROMISC when
 +		 * all-multicast is enabled and VLAN 0 is the only VLAN rule.
 +		 */
 +		if (vsi->current_netdev_flags & IFF_ALLMULTI) {
 +			ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
 +						   ICE_MCAST_VLAN_PROMISC_BITS,
 +						   0);
 +			ice_fltr_set_vsi_promisc(&vsi->back->hw, vsi->idx,
 +						 ICE_MCAST_PROMISC_BITS, 0);
 +		}
 +	}
 +
 +finish:
 +	clear_bit(ICE_CFG_BUSY, vsi->state);
  
 -	set_bit(ICE_VSI_VLAN_FLTR_CHANGED, vsi->state);
  	return ret;
  }
  
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index e5875fdaaf40,fdc50b42f8ee..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -810,13 -760,16 +810,20 @@@ static int ice_vf_rebuild_host_tx_rate_
   */
  static int ice_vf_rebuild_host_vlan_cfg(struct ice_vf *vf)
  {
+ 	u8 vlan_prio = (vf->port_vlan_info & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
+ 	u16 vlan_id = vf->port_vlan_info & VLAN_VID_MASK;
  	struct device *dev = ice_pf_to_dev(vf->pf);
  	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
- 	u16 vlan_id = 0;
+ 	struct ice_vlan vlan;
  	int err;
  
+ 	vlan = ICE_VLAN(vlan_id, vlan_prio);
  	if (vf->port_vlan_info) {
++<<<<<<< HEAD
 +		err = ice_vsi_manage_pvid(vsi, vf->port_vlan_info, true);
++=======
+ 		err = vsi->vlan_ops.set_port_vlan(vsi, &vlan);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  		if (err) {
  			dev_err(dev, "failed to configure port VLAN via VSI parameters for VF %u, error %d\n",
  				vf->vf_id, err);
@@@ -825,9 -778,7 +832,11 @@@
  	}
  
  	/* vlan_id will either be 0 or the port VLAN number */
++<<<<<<< HEAD
 +	err = ice_vsi_add_vlan(vsi, vlan_id, ICE_FWD_TO_VSI);
++=======
+ 	err = vsi->vlan_ops.add_vlan(vsi, &vlan);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  	if (err) {
  		dev_err(dev, "failed to add %s VLAN %u filter for VF %u, error %d\n",
  			vf->port_vlan_info ? "port" : "", vlan_id, vf->vf_id,
@@@ -4257,7 -4253,8 +4267,12 @@@ static int ice_vc_process_vlan_msg(stru
  			if (!vid)
  				continue;
  
++<<<<<<< HEAD
 +			status = ice_vsi_add_vlan(vsi, vid, ICE_FWD_TO_VSI);
++=======
+ 			vlan = ICE_VLAN(vid, 0);
+ 			status = vsi->vlan_ops.add_vlan(vsi, &vlan);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  			if (status) {
  				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  				goto error_param;
@@@ -4308,10 -4306,8 +4324,15 @@@
  			if (!vid)
  				continue;
  
++<<<<<<< HEAD
 +			/* Make sure ice_vsi_kill_vlan is successful before
 +			 * updating VLAN information
 +			 */
 +			status = ice_vsi_kill_vlan(vsi, vid);
++=======
+ 			vlan = ICE_VLAN(vid, 0);
+ 			status = vsi->vlan_ops.del_vlan(vsi, &vlan);
++>>>>>>> fb05ba1257d7 (ice: Introduce ice_vlan struct)
  			if (status) {
  				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  				goto error_param;
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_ops.h
diff --git a/drivers/net/ethernet/intel/ice/ice_fltr.c b/drivers/net/ethernet/intel/ice/ice_fltr.c
index 6a04cc548457..5efe71c8757f 100644
--- a/drivers/net/ethernet/intel/ice/ice_fltr.c
+++ b/drivers/net/ethernet/intel/ice/ice_fltr.c
@@ -239,21 +239,20 @@ ice_fltr_add_mac_to_list(struct ice_vsi *vsi, struct list_head *list,
  * ice_fltr_add_vlan_to_list - add VLAN filter info to exsisting list
  * @vsi: pointer to VSI struct
  * @list: list to add filter info to
- * @vlan_id: VLAN ID to add
- * @action: filter action
+ * @vlan: VLAN filter details
  */
 static int
 ice_fltr_add_vlan_to_list(struct ice_vsi *vsi, struct list_head *list,
-			  u16 vlan_id, enum ice_sw_fwd_act_type action)
+			  struct ice_vlan *vlan)
 {
 	struct ice_fltr_info info = { 0 };
 
 	info.flag = ICE_FLTR_TX;
 	info.src_id = ICE_SRC_ID_VSI;
 	info.lkup_type = ICE_SW_LKUP_VLAN;
-	info.fltr_act = action;
+	info.fltr_act = ICE_FWD_TO_VSI;
 	info.vsi_handle = vsi->idx;
-	info.l_data.vlan.vlan_id = vlan_id;
+	info.l_data.vlan.vlan_id = vlan->vid;
 
 	return ice_fltr_add_entry_to_list(ice_pf_to_dev(vsi->back), &info,
 					  list);
@@ -346,19 +345,17 @@ ice_fltr_prepare_mac_and_broadcast(struct ice_vsi *vsi, const u8 *mac,
 /**
  * ice_fltr_prepare_vlan - add or remove VLAN filter
  * @vsi: pointer to VSI struct
- * @vlan_id: VLAN ID to add
- * @action: action to be performed on filter match
+ * @vlan: VLAN filter details
  * @vlan_action: pointer to add or remove VLAN function
  */
 static int
-ice_fltr_prepare_vlan(struct ice_vsi *vsi, u16 vlan_id,
-		      enum ice_sw_fwd_act_type action,
+ice_fltr_prepare_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan,
 		      int (*vlan_action)(struct ice_vsi *, struct list_head *))
 {
 	LIST_HEAD(tmp_list);
 	int result;
 
-	if (ice_fltr_add_vlan_to_list(vsi, &tmp_list, vlan_id, action))
+	if (ice_fltr_add_vlan_to_list(vsi, &tmp_list, vlan))
 		return -ENOMEM;
 
 	result = vlan_action(vsi, &tmp_list);
@@ -431,27 +428,21 @@ int ice_fltr_remove_mac(struct ice_vsi *vsi, const u8 *mac,
 /**
  * ice_fltr_add_vlan - add single VLAN filter
  * @vsi: pointer to VSI struct
- * @vlan_id: VLAN ID to add
- * @action: action to be performed on filter match
+ * @vlan: VLAN filter details
  */
-int ice_fltr_add_vlan(struct ice_vsi *vsi, u16 vlan_id,
-		      enum ice_sw_fwd_act_type action)
+int ice_fltr_add_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan)
 {
-	return ice_fltr_prepare_vlan(vsi, vlan_id, action,
-				     ice_fltr_add_vlan_list);
+	return ice_fltr_prepare_vlan(vsi, vlan, ice_fltr_add_vlan_list);
 }
 
 /**
  * ice_fltr_remove_vlan - remove VLAN filter
  * @vsi: pointer to VSI struct
- * @vlan_id: filter VLAN to remove
- * @action: action to remove
+ * @vlan: VLAN filter details
  */
-int ice_fltr_remove_vlan(struct ice_vsi *vsi, u16 vlan_id,
-			 enum ice_sw_fwd_act_type action)
+int ice_fltr_remove_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan)
 {
-	return ice_fltr_prepare_vlan(vsi, vlan_id, action,
-				     ice_fltr_remove_vlan_list);
+	return ice_fltr_prepare_vlan(vsi, vlan, ice_fltr_remove_vlan_list);
 }
 
 /**
diff --git a/drivers/net/ethernet/intel/ice/ice_fltr.h b/drivers/net/ethernet/intel/ice/ice_fltr.h
index 3eb42479175f..0f3dbc308eec 100644
--- a/drivers/net/ethernet/intel/ice/ice_fltr.h
+++ b/drivers/net/ethernet/intel/ice/ice_fltr.h
@@ -4,6 +4,8 @@
 #ifndef _ICE_FLTR_H_
 #define _ICE_FLTR_H_
 
+#include "ice_vlan.h"
+
 void ice_fltr_free_list(struct device *dev, struct list_head *h);
 int
 ice_fltr_set_vlan_vsi_promisc(struct ice_hw *hw, struct ice_vsi *vsi,
@@ -32,12 +34,8 @@ ice_fltr_remove_mac(struct ice_vsi *vsi, const u8 *mac,
 		    enum ice_sw_fwd_act_type action);
 int ice_fltr_remove_mac_list(struct ice_vsi *vsi, struct list_head *list);
 
-int
-ice_fltr_add_vlan(struct ice_vsi *vsi, u16 vid,
-		  enum ice_sw_fwd_act_type action);
-int
-ice_fltr_remove_vlan(struct ice_vsi *vsi, u16 vid,
-		     enum ice_sw_fwd_act_type action);
+int ice_fltr_add_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan);
+int ice_fltr_remove_vlan(struct ice_vsi *vsi, struct ice_vlan *vlan);
 
 int
 ice_fltr_add_eth(struct ice_vsi *vsi, u16 ethertype, u16 flag,
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.h b/drivers/net/ethernet/intel/ice/ice_lib.h
index 9a554bee4b03..f4f8f6fabec0 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_lib.h
@@ -5,6 +5,7 @@
 #define _ICE_LIB_H_
 
 #include "ice.h"
+#include "ice_vlan.h"
 
 const char *ice_vsi_type_str(enum ice_vsi_type vsi_type);
 
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/ice/ice_vlan.h b/drivers/net/ethernet/intel/ice/ice_vlan.h
new file mode 100644
index 000000000000..3fad0cba2da6
--- /dev/null
+++ b/drivers/net/ethernet/intel/ice/ice_vlan.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2019-2021, Intel Corporation. */
+
+#ifndef _ICE_VLAN_H_
+#define _ICE_VLAN_H_
+
+#include <linux/types.h>
+#include "ice_type.h"
+
+struct ice_vlan {
+	u16 vid;
+	u8 prio;
+};
+
+#define ICE_VLAN(vid, prio) ((struct ice_vlan){ vid, prio })
+
+#endif /* _ICE_VLAN_H_ */
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_ops.h
