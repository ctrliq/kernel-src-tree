ice: Fix clearing of promisc mode with bridge over bond

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.26.1.el8_6
commit-author Grzegorz Siwik <grzegorz.siwik@intel.com>
commit abddafd4585cc825d454da3cf308ad1226f6c554
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.26.1.el8_6/abddafd4.failed

When at least two interfaces are bonded and a bridge is enabled on the
bond, an error can occur when the bridge is removed and re-added. The
reason for the error is because promiscuous mode was not fully cleared from
the VLAN VSI in the hardware. With this change, promiscuous mode is
properly removed when the bridge disconnects from bonding.

[ 1033.676359] bond1: link status definitely down for interface enp95s0f0, disabling it
[ 1033.676366] bond1: making interface enp175s0f0 the new active one
[ 1033.676369] device enp95s0f0 left promiscuous mode
[ 1033.676522] device enp175s0f0 entered promiscuous mode
[ 1033.676901] ice 0000:af:00.0 enp175s0f0: Error setting Multicast promiscuous mode on VSI 6
[ 1041.795662] ice 0000:af:00.0 enp175s0f0: Error setting Multicast promiscuous mode on VSI 6
[ 1041.944826] bond1: link status definitely down for interface enp175s0f0, disabling it
[ 1041.944874] device enp175s0f0 left promiscuous mode
[ 1041.944918] bond1: now running without any active interface!

Fixes: c31af68a1b94 ("ice: Add outer_vlan_ops and VSI specific VLAN ops implementations")
Co-developed-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Signed-off-by: Grzegorz Siwik <grzegorz.siwik@intel.com>
Link: https://lore.kernel.org/all/CAK8fFZ7m-KR57M_rYX6xZN39K89O=LGooYkKsu6HKt0Bs+x6xQ@mail.gmail.com/
	Tested-by: Jaroslav Pulchart <jaroslav.pulchart@gooddata.com>
	Tested-by: Igor Raits <igor@gooddata.com>
	Tested-by: Gurucharan <gurucharanx.g@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit abddafd4585cc825d454da3cf308ad1226f6c554)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_main.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 5661098694e0,733c455f6574..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -4144,7 -4001,116 +4144,107 @@@ int ice_set_link(struct ice_vsi *vsi, b
   */
  int ice_vsi_add_vlan_zero(struct ice_vsi *vsi)
  {
++<<<<<<< HEAD
 +	return ice_vsi_add_vlan(vsi, 0, ICE_FWD_TO_VSI);
++=======
+ 	struct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	struct ice_vlan vlan;
+ 	int err;
+ 
+ 	vlan = ICE_VLAN(0, 0, 0);
+ 	err = vlan_ops->add_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	/* in SVM both VLAN 0 filters are identical */
+ 	if (!ice_is_dvm_ena(&vsi->back->hw))
+ 		return 0;
+ 
+ 	vlan = ICE_VLAN(ETH_P_8021Q, 0, 0);
+ 	err = vlan_ops->add_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vsi_del_vlan_zero - delete VLAN 0 filter(s) for this VSI
+  * @vsi: VSI used to add VLAN filters
+  *
+  * Delete the VLAN 0 filters in the same manner that they were added in
+  * ice_vsi_add_vlan_zero.
+  */
+ int ice_vsi_del_vlan_zero(struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	struct ice_vlan vlan;
+ 	int err;
+ 
+ 	vlan = ICE_VLAN(0, 0, 0);
+ 	err = vlan_ops->del_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	/* in SVM both VLAN 0 filters are identical */
+ 	if (!ice_is_dvm_ena(&vsi->back->hw))
+ 		return 0;
+ 
+ 	vlan = ICE_VLAN(ETH_P_8021Q, 0, 0);
+ 	err = vlan_ops->del_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	/* when deleting the last VLAN filter, make sure to disable the VLAN
+ 	 * promisc mode so the filter isn't left by accident
+ 	 */
+ 	return ice_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
+ 				    ICE_MCAST_VLAN_PROMISC_BITS, 0);
+ }
+ 
+ /**
+  * ice_vsi_num_zero_vlans - get number of VLAN 0 filters based on VLAN mode
+  * @vsi: VSI used to get the VLAN mode
+  *
+  * If DVM is enabled then 2 VLAN 0 filters are added, else if SVM is enabled
+  * then 1 VLAN 0 filter is added. See ice_vsi_add_vlan_zero for more details.
+  */
+ static u16 ice_vsi_num_zero_vlans(struct ice_vsi *vsi)
+ {
+ #define ICE_DVM_NUM_ZERO_VLAN_FLTRS	2
+ #define ICE_SVM_NUM_ZERO_VLAN_FLTRS	1
+ 	/* no VLAN 0 filter is created when a port VLAN is active */
+ 	if (vsi->type == ICE_VSI_VF) {
+ 		if (WARN_ON(!vsi->vf))
+ 			return 0;
+ 
+ 		if (ice_vf_is_port_vlan_ena(vsi->vf))
+ 			return 0;
+ 	}
+ 
+ 	if (ice_is_dvm_ena(&vsi->back->hw))
+ 		return ICE_DVM_NUM_ZERO_VLAN_FLTRS;
+ 	else
+ 		return ICE_SVM_NUM_ZERO_VLAN_FLTRS;
+ }
+ 
+ /**
+  * ice_vsi_has_non_zero_vlans - check if VSI has any non-zero VLANs
+  * @vsi: VSI used to determine if any non-zero VLANs have been added
+  */
+ bool ice_vsi_has_non_zero_vlans(struct ice_vsi *vsi)
+ {
+ 	return (vsi->num_vlan > ice_vsi_num_zero_vlans(vsi));
+ }
+ 
+ /**
+  * ice_vsi_num_non_zero_vlans - get the number of non-zero VLANs for this VSI
+  * @vsi: VSI used to get the number of non-zero VLANs added
+  */
+ u16 ice_vsi_num_non_zero_vlans(struct ice_vsi *vsi)
+ {
+ 	return (vsi->num_vlan - ice_vsi_num_zero_vlans(vsi));
++>>>>>>> abddafd4585c (ice: Fix clearing of promisc mode with bridge over bond)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index f89e43b129ba,4ecaf40cf946..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -3528,10 -3575,21 +3530,24 @@@ ice_vlan_rx_kill_vid(struct net_device 
  	while (test_and_set_bit(ICE_CFG_BUSY, vsi->state))
  		usleep_range(1000, 2000);
  
++<<<<<<< HEAD
 +	/* Make sure ice_vsi_kill_vlan is successful before updating VLAN
++=======
+ 	ret = ice_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
+ 				    ICE_MCAST_VLAN_PROMISC_BITS, vid);
+ 	if (ret) {
+ 		netdev_err(netdev, "Error clearing multicast promiscuous mode on VSI %i\n",
+ 			   vsi->vsi_num);
+ 		vsi->current_netdev_flags |= IFF_ALLMULTI;
+ 	}
+ 
+ 	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 
+ 	/* Make sure VLAN delete is successful before updating VLAN
++>>>>>>> abddafd4585c (ice: Fix clearing of promisc mode with bridge over bond)
  	 * information
  	 */
 -	vlan = ICE_VLAN(be16_to_cpu(proto), vid, 0);
 -	ret = vlan_ops->del_vlan(vsi, &vlan);
 +	ret = ice_vsi_kill_vlan(vsi, vid);
  	if (ret)
  		goto finish;
  
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
