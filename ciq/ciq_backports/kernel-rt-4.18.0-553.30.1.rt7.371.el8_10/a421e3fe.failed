smb: client: use actual path when queryfs

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.30.1.rt7.371.el8_10
commit-author wangrong <wangrong@uniontech.com>
commit a421e3fe0e6abe27395078f4f0cec5daf466caea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.30.1.rt7.371.el8_10/a421e3fe.failed

Due to server permission control, the client does not have access to
the shared root directory, but can access subdirectories normally, so
users usually mount the shared subdirectories directly. In this case,
queryfs should use the actual path instead of the root directory to
avoid the call returning an error (EACCES).

	Signed-off-by: wangrong <wangrong@uniontech.com>
	Reviewed-by: Paulo Alcantara (Red Hat) <pc@manguebit.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit a421e3fe0e6abe27395078f4f0cec5daf466caea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/smb2ops.c
index bfffaf91afb2,cd6ff224015a..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -2756,17 -2884,24 +2756,33 @@@ smb311_queryfs(const unsigned int xid, 
  	struct cifs_fid fid;
  
  	if (!tcon->posix_extensions)
- 		return smb2_queryfs(xid, tcon, cifs_sb, buf);
+ 		return smb2_queryfs(xid, tcon, path, cifs_sb, buf);
  
++<<<<<<< HEAD:fs/cifs/smb2ops.c
 +	oparms.tcon = tcon;
 +	oparms.desired_access = FILE_READ_ATTRIBUTES;
 +	oparms.disposition = FILE_OPEN;
 +	oparms.create_options = cifs_create_options(cifs_sb, 0);
 +	oparms.fid = &fid;
 +	oparms.reconnect = false;
++=======
+ 	oparms = (struct cifs_open_parms) {
+ 		.tcon = tcon,
+ 		.path = path,
+ 		.desired_access = FILE_READ_ATTRIBUTES,
+ 		.disposition = FILE_OPEN,
+ 		.create_options = cifs_create_options(cifs_sb, 0),
+ 		.fid = &fid,
+ 	};
++>>>>>>> a421e3fe0e6a (smb: client: use actual path when queryfs):fs/smb/client/smb2ops.c
  
- 	rc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL,
+ 	utf16_path = cifs_convert_path_to_utf16(path, cifs_sb);
+ 	if (utf16_path == NULL)
+ 		return -ENOMEM;
+ 
+ 	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL,
  		       NULL, NULL);
+ 	kfree(utf16_path);
  	if (rc)
  		return rc;
  
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4404659a0401..cf323b776d49 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -263,8 +263,17 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct TCP_Server_Info *server = tcon->ses->server;
 	unsigned int xid;
 	int rc = 0;
+	const char *full_path;
+	void *page;
 
 	xid = get_xid();
+	page = alloc_dentry_path();
+
+	full_path = build_path_from_dentry(dentry, page);
+	if (IS_ERR(full_path)) {
+		rc = PTR_ERR(full_path);
+		goto statfs_out;
+	}
 
 	if (le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength) > 0)
 		buf->f_namelen =
@@ -280,8 +289,10 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_ffree = 0;	/* unlimited */
 
 	if (server->ops->queryfs)
-		rc = server->ops->queryfs(xid, tcon, cifs_sb, buf);
+		rc = server->ops->queryfs(xid, tcon, full_path, cifs_sb, buf);
 
+statfs_out:
+	free_dentry_path(page);
 	free_xid(xid);
 	return 0;
 }
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 747d61144ce9..9a4aa4a3889a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -403,7 +403,7 @@ struct smb_version_operations {
 			       struct cifsInodeInfo *);
 	/* query remote filesystem */
 	int (*queryfs)(const unsigned int, struct cifs_tcon *,
-		       struct cifs_sb_info *, struct kstatfs *);
+		       const char *, struct cifs_sb_info *, struct kstatfs *);
 	/* send mandatory brlock to the server */
 	int (*mand_lock)(const unsigned int, struct cifsFileInfo *, __u64,
 			 __u64, __u32, int, int, bool);
diff --git a/fs/cifs/smb1ops.c b/fs/cifs/smb1ops.c
index 017d0207befe..a5d1db8ca6ff 100644
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@ -886,7 +886,7 @@ cifs_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,
 
 static int
 cifs_queryfs(const unsigned int xid, struct cifs_tcon *tcon,
-	     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)
+	     const char *path, struct cifs_sb_info *cifs_sb, struct kstatfs *buf)
 {
 	int rc = -EOPNOTSUPP;
 
* Unmerged path fs/cifs/smb2ops.c
