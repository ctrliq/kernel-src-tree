vxlan: Expose helper vxlan_build_gbp_hdr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-520.el8
commit-author Gavin Li <gavinl@nvidia.com>
commit c641e9279f3530aa2fe4bcb250477b555b75104a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-520.el8/c641e927.failed

The function vxlan_build_gbp_hdr will be used by other modules to build
gbp option in vxlan header according to gbp flags.

	Signed-off-by: Gavin Li <gavinl@nvidia.com>
	Reviewed-by: Gavi Teitz <gavi@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Acked-by: Saeed Mahameed <saeedm@nvidia.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit c641e9279f3530aa2fe4bcb250477b555b75104a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/vxlan.h
diff --cc include/net/vxlan.h
index d1e731fde341,20bd7d893e10..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -459,4 -517,78 +459,81 @@@ vxlan_fdb_clear_offload(const struct ne
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static inline void vxlan_flag_attr_error(int attrtype,
+ 					 struct netlink_ext_ack *extack)
+ {
+ #define VXLAN_FLAG(flg) \
+ 	case IFLA_VXLAN_##flg: \
+ 		NL_SET_ERR_MSG_MOD(extack, \
+ 				   "cannot change " #flg " flag"); \
+ 		break
+ 	switch (attrtype) {
+ 	VXLAN_FLAG(TTL_INHERIT);
+ 	VXLAN_FLAG(LEARNING);
+ 	VXLAN_FLAG(PROXY);
+ 	VXLAN_FLAG(RSC);
+ 	VXLAN_FLAG(L2MISS);
+ 	VXLAN_FLAG(L3MISS);
+ 	VXLAN_FLAG(COLLECT_METADATA);
+ 	VXLAN_FLAG(UDP_ZERO_CSUM6_TX);
+ 	VXLAN_FLAG(UDP_ZERO_CSUM6_RX);
+ 	VXLAN_FLAG(REMCSUM_TX);
+ 	VXLAN_FLAG(REMCSUM_RX);
+ 	VXLAN_FLAG(GBP);
+ 	VXLAN_FLAG(GPE);
+ 	VXLAN_FLAG(REMCSUM_NOPARTIAL);
+ 	default:
+ 		NL_SET_ERR_MSG_MOD(extack, \
+ 				   "cannot change flag");
+ 		break;
+ 	}
+ #undef VXLAN_FLAG
+ }
+ 
+ static inline bool vxlan_fdb_nh_path_select(struct nexthop *nh,
+ 					    int hash,
+ 					    struct vxlan_rdst *rdst)
+ {
+ 	struct fib_nh_common *nhc;
+ 
+ 	nhc = nexthop_path_fdb_result(nh, hash);
+ 	if (unlikely(!nhc))
+ 		return false;
+ 
+ 	switch (nhc->nhc_gw_family) {
+ 	case AF_INET:
+ 		rdst->remote_ip.sin.sin_addr.s_addr = nhc->nhc_gw.ipv4;
+ 		rdst->remote_ip.sa.sa_family = AF_INET;
+ 		break;
+ 	case AF_INET6:
+ 		rdst->remote_ip.sin6.sin6_addr = nhc->nhc_gw.ipv6;
+ 		rdst->remote_ip.sa.sa_family = AF_INET6;
+ 		break;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static inline void vxlan_build_gbp_hdr(struct vxlanhdr *vxh, const struct vxlan_metadata *md)
+ {
+ 	struct vxlanhdr_gbp *gbp;
+ 
+ 	if (!md->gbp)
+ 		return;
+ 
+ 	gbp = (struct vxlanhdr_gbp *)vxh;
+ 	vxh->vx_flags |= VXLAN_HF_GBP;
+ 
+ 	if (md->gbp & VXLAN_GBP_DONT_LEARN)
+ 		gbp->dont_learn = 1;
+ 
+ 	if (md->gbp & VXLAN_GBP_POLICY_APPLIED)
+ 		gbp->policy_applied = 1;
+ 
+ 	gbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);
+ }
+ 
++>>>>>>> c641e9279f35 (vxlan: Expose helper vxlan_build_gbp_hdr)
  #endif
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index b386ddb29ab4..2e230ed11337 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -2113,25 +2113,6 @@ static bool route_shortcircuit(struct net_device *dev, struct sk_buff *skb)
 	return false;
 }
 
-static void vxlan_build_gbp_hdr(struct vxlanhdr *vxh, struct vxlan_metadata *md)
-{
-	struct vxlanhdr_gbp *gbp;
-
-	if (!md->gbp)
-		return;
-
-	gbp = (struct vxlanhdr_gbp *)vxh;
-	vxh->vx_flags |= VXLAN_HF_GBP;
-
-	if (md->gbp & VXLAN_GBP_DONT_LEARN)
-		gbp->dont_learn = 1;
-
-	if (md->gbp & VXLAN_GBP_POLICY_APPLIED)
-		gbp->policy_applied = 1;
-
-	gbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);
-}
-
 static int vxlan_build_gpe_hdr(struct vxlanhdr *vxh, __be16 protocol)
 {
 	struct vxlanhdr_gpe *gpe = (struct vxlanhdr_gpe *)vxh;
* Unmerged path include/net/vxlan.h
