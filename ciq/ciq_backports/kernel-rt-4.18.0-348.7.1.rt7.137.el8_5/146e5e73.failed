net-sysfs: try not to restart the syscall if it will fail eventually

jira NONE_AUTOMATION
Rebuild_History Non-Buildable kernel-rt-4.18.0-348.7.1.rt7.137.el8_5
commit-author Antoine Tenart <atenart@kernel.org>
commit 146e5e733310379f51924111068f08a3af0db830
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-348.7.1.rt7.137.el8_5/146e5e73.failed

Due to deadlocks in the networking subsystem spotted 12 years ago[1],
a workaround was put in place[2] to avoid taking the rtnl lock when it
was not available and restarting the syscall (back to VFS, letting
userspace spin). The following construction is found a lot in the net
sysfs and sysctl code:

  if (!rtnl_trylock())
          return restart_syscall();

This can be problematic when multiple userspace threads use such
interfaces in a short period, making them to spin a lot. This happens
for example when adding and moving virtual interfaces: userspace
programs listening on events, such as systemd-udevd and NetworkManager,
do trigger actions reading files in sysfs. It gets worse when a lot of
virtual interfaces are created concurrently, say when creating
containers at boot time.

Returning early without hitting the above pattern when the syscall will
fail eventually does make things better. While it is not a fix for the
issue, it does ease things.

[1] https://lore.kernel.org/netdev/49A4D5D5.5090602@trash.net/
    https://lore.kernel.org/netdev/m14oyhis31.fsf@fess.ebiederm.org/
    and https://lore.kernel.org/netdev/20090226084924.16cb3e08@nehalam/
[2] Rightfully, those deadlocks are *hard* to solve.

	Signed-off-by: Antoine Tenart <atenart@kernel.org>
	Reviewed-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 146e5e733310379f51924111068f08a3af0db830)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/net-sysfs.c
diff --cc net/core/net-sysfs.c
index 564c5b2fbab2,d6e4e0b43beb..000000000000
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@@ -1164,6 -1272,15 +1213,18 @@@ static ssize_t tx_maxrate_store(struct 
  	int err, index = get_netdev_queue_index(queue);
  	u32 rate = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (!capable(CAP_NET_ADMIN))
+ 		return -EPERM;
+ 
+ 	/* The check is also done later; this helps returning early without
+ 	 * hitting the trylock/restart below.
+ 	 */
+ 	if (!dev->netdev_ops->ndo_set_tx_maxrate)
+ 		return -EOPNOTSUPP;
+ 
++>>>>>>> 146e5e733310 (net-sysfs: try not to restart the syscall if it will fail eventually)
  	err = kstrtou32(buf, 10, &rate);
  	if (err < 0)
  		return err;
* Unmerged path net/core/net-sysfs.c
