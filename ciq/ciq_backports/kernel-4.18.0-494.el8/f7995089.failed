dm: unexport dm_get_queue_limits()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Mike Snitzer <snitzer@kernel.org>
commit f7995089c508a5a11b0491c7b348d5c07217a4e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/f7995089.failed

There are no dm_get_queue_limits() callers outside of DM core and
there shouldn't be.

Also, remove its BUG_ON(!atomic_read(&md->holders)) to micro-optimize
__process_abnormal_io().

	Signed-off-by: Mike Snitzer <snitzer@kernel.org>
(cherry picked from commit f7995089c508a5a11b0491c7b348d5c07217a4e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
#	include/linux/device-mapper.h
diff --cc drivers/md/dm.c
index 6c26c325384a,3b694ba3a106..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -2190,23 -2321,6 +2199,26 @@@ struct target_type *dm_get_immutable_ta
  }
  
  /*
++<<<<<<< HEAD
 + * The queue_limits are only valid as long as you have a reference
 + * count on 'md'.
 + */
 +struct queue_limits *dm_get_queue_limits(struct mapped_device *md)
 +{
 +	BUG_ON(!atomic_read(&md->holders));
 +	return &md->queue->limits;
 +}
 +EXPORT_SYMBOL_GPL(dm_get_queue_limits);
 +
 +static void dm_init_congested_fn(struct mapped_device *md)
 +{
 +	md->queue->backing_dev_info->congested_data = md;
 +	md->queue->backing_dev_info->congested_fn = dm_any_congested;
 +}
 +
 +/*
++=======
++>>>>>>> f7995089c508 (dm: unexport dm_get_queue_limits())
   * Setup the DM device's queue based on md's type
   */
  int dm_setup_md_queue(struct mapped_device *md, struct dm_table *t)
diff --cc include/linux/device-mapper.h
index baa823f06474,a52d2b9a6846..000000000000
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@@ -490,10 -518,17 +490,20 @@@ struct dm_report_zones_args 
  	/* must be filled by ->report_zones before calling dm_report_zones_cb */
  	sector_t start;
  };
 -int dm_report_zones(struct block_device *bdev, sector_t start, sector_t sector,
 -		    struct dm_report_zones_args *args, unsigned int nr_zones);
 +int dm_report_zones_cb(struct blk_zone *zone, unsigned int idx, void *data);
  #endif /* CONFIG_BLK_DEV_ZONED */
  
++<<<<<<< HEAD
 +struct queue_limits *dm_get_queue_limits(struct mapped_device *md);
++=======
+ /*
+  * Device mapper functions to parse and create devices specified by the
+  * parameter "dm-mod.create="
+  */
+ int __init dm_early_create(struct dm_ioctl *dmi,
+ 			   struct dm_target_spec **spec_array,
+ 			   char **target_params_array);
++>>>>>>> f7995089c508 (dm: unexport dm_get_queue_limits())
  
  /*
   * Geometry functions.
* Unmerged path drivers/md/dm.c
* Unmerged path include/linux/device-mapper.h
