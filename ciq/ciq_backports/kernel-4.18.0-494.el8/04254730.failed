list: introduce list_is_head() helper and re-use it in list.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 0425473037db40d9e322631f2d4dc6ef51f97e88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/04254730.failed

Introduce list_is_head() in the similar (*) way as it's done for
list_entry_is_head().  Make use of it in the list.h.

*) it's done as inliner and not a macro to be aligned with other
   list_is_*() APIs; while at it, make all three to have the same
   style.

Link: https://lkml.kernel.org/r/20211201141824.81400-1-andriy.shevchenko@linux.intel.com
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0425473037db40d9e322631f2d4dc6ef51f97e88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/list.h
diff --cc include/linux/list.h
index 1211a9574532,dd6c2041d09c..000000000000
--- a/include/linux/list.h
+++ b/include/linux/list.h
@@@ -256,10 -258,9 +256,14 @@@ static inline void list_bulk_move_tail(
   * @list: the entry to test
   * @head: the head of the list
   */
++<<<<<<< HEAD
 +static inline int list_is_first(const struct list_head *list,
 +				const struct list_head *head)
++=======
+ static inline int list_is_first(const struct list_head *list, const struct list_head *head)
++>>>>>>> 0425473037db (list: introduce list_is_head() helper and re-use it in list.h)
  {
 -	return list->prev == head;
 +       return list->prev == head;
  }
  
  /**
@@@ -297,8 -325,8 +310,13 @@@ static inline int list_empty(const stru
   */
  static inline int list_empty_careful(const struct list_head *head)
  {
++<<<<<<< HEAD
 +	struct list_head *next = head->next;
 +	return (next == head) && (next == head->prev);
++=======
+ 	struct list_head *next = smp_load_acquire(&head->next);
+ 	return list_is_head(next, head) && (next == head->prev);
++>>>>>>> 0425473037db (list: introduce list_is_head() helper and re-use it in list.h)
  }
  
  /**
@@@ -588,24 -616,9 +606,24 @@@ static inline void list_splice_tail_ini
   */
  #define list_for_each_prev_safe(pos, n, head) \
  	for (pos = (head)->prev, n = pos->prev; \
- 	     pos != (head); \
+ 	     !list_is_head(pos, (head)); \
  	     pos = n, n = pos->prev)
  
 +/**
 + * list_count_nodes - count nodes in the list
 + * @head:	the head for your list.
 + */
 +static inline size_t list_count_nodes(struct list_head *head)
 +{
 +	struct list_head *pos;
 +	size_t count = 0;
 +
 +	list_for_each(pos, head)
 +		count++;
 +
 +	return count;
 +}
 +
  /**
   * list_entry_is_head - test if the entry points to the head of the list
   * @pos:	the type * to cursor
* Unmerged path include/linux/list.h
