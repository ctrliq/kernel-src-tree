vfio/ccw: refactor the idaw counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Eric Farman <farman@linux.ibm.com>
commit b21f9cb1124e9fee33dd3c07108aabde060b6ef8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/b21f9cb1.failed

The rules of an IDAW are fairly simple: Each one can move no
more than a defined amount of data, must not cross the
boundary defined by that length, and must be aligned to that
length as well. The first IDAW in a list is special, in that
it does not need to adhere to that alignment, but the other
rules still apply. Thus, by reading the first IDAW in a list,
the number of IDAWs that will comprise a data transfer of a
particular size can be calculated.

Let's factor out the reading of that first IDAW with the
logic that calculates the length of the list, to simplify
the rest of the routine that handles the individual IDAWs.

	Signed-off-by: Eric Farman <farman@linux.ibm.com>
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit b21f9cb1124e9fee33dd3c07108aabde060b6ef8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/vfio_ccw_cp.c
diff --cc drivers/s390/cio/vfio_ccw_cp.c
index 3054373c1ee5,9d74e0b74da7..000000000000
--- a/drivers/s390/cio/vfio_ccw_cp.c
+++ b/drivers/s390/cio/vfio_ccw_cp.c
@@@ -504,21 -496,22 +504,30 @@@ static int ccwchain_fetch_tic(struct cc
  	return -EFAULT;
  }
  
++<<<<<<< HEAD
 +static int ccwchain_fetch_direct(struct ccwchain *chain,
 +				 int idx,
 +				 struct channel_program *cp)
++=======
+ /*
+  * ccw_count_idaws() - Calculate the number of IDAWs needed to transfer
+  * a specified amount of data
+  *
+  * @ccw: The Channel Command Word being translated
+  * @cp: Channel Program being processed
+  */
+ static int ccw_count_idaws(struct ccw1 *ccw,
+ 			   struct channel_program *cp)
++>>>>>>> b21f9cb1124e (vfio/ccw: refactor the idaw counter)
  {
 -	struct vfio_device *vdev =
 -		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
 +	struct ccw1 *ccw;
 +	struct pfn_array *pa;
  	u64 iova;
- 	unsigned long *idaws;
  	int ret;
  	int bytes = 1;
- 	int idaw_nr, idal_len;
- 	int i;
  
 +	ccw = chain->ch_ccw + idx;
 +
  	if (ccw->count)
  		bytes = ccw->count;
  
@@@ -564,13 -574,11 +591,19 @@@ static int ccwchain_fetch_ccw(struct cc
  		 * occupy is not contiguous.
  		 */
  		for (i = 0; i < idaw_nr; i++)
 -			pa->pa_iova[i] = idaws[i];
 +			pa->pa_iova_pfn[i] = idaws[i] >> PAGE_SHIFT;
  	} else {
++<<<<<<< HEAD
 +		/*
 +		 * No action is required here; the iova addresses in pfn_array
 +		 * were initialized sequentially in pfn_array_alloc() beginning
 +		 * with the contents of ccw->cda.
 +		 */
++=======
+ 		pa->pa_iova[0] = ccw->cda;
+ 		for (i = 1; i < pa->pa_nr; i++)
+ 			pa->pa_iova[i] = pa->pa_iova[i - 1] + PAGE_SIZE;
++>>>>>>> b21f9cb1124e (vfio/ccw: refactor the idaw counter)
  	}
  
  	if (ccw_does_data_transfer(ccw)) {
* Unmerged path drivers/s390/cio/vfio_ccw_cp.c
