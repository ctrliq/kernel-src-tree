vfio/ccw: allocate/populate the guest idal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Eric Farman <farman@linux.ibm.com>
commit 61f3a16b9d5cd9361a317ee7870083c1bc171188
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/61f3a16b.failed

Today, we allocate memory for a list of IDAWs, and if the CCW
being processed contains an IDAL we read that data from the guest
into that space. We then copy each IDAW into the pa_iova array,
or fabricate that pa_iova array with a list of addresses based
on a direct-addressed CCW.

Combine the reading of the guest IDAL with the creation of a
pseudo-IDAL for direct-addressed CCWs, so that both CCW types
have a "guest" IDAL that can be populated straight into the
pa_iova array.

	Signed-off-by: Eric Farman <farman@linux.ibm.com>
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 61f3a16b9d5cd9361a317ee7870083c1bc171188)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/vfio_ccw_cp.c
diff --cc drivers/s390/cio/vfio_ccw_cp.c
index 3054373c1ee5,525277750041..000000000000
--- a/drivers/s390/cio/vfio_ccw_cp.c
+++ b/drivers/s390/cio/vfio_ccw_cp.c
@@@ -157,11 -192,12 +157,20 @@@ static inline void pfn_array_idal_creat
  	 * idaw.
  	 */
  
++<<<<<<< HEAD
 +	for (i = 0; i < pa->pa_nr; i++)
 +		idaws[i] = pa->pa_pfn[i] << PAGE_SHIFT;
 +
 +	/* Adjust the first IDAW, since it may not start on a page boundary */
 +	idaws[0] += pa->pa_iova & (PAGE_SIZE - 1);
++=======
+ 	for (i = 0; i < pa->pa_nr; i++) {
+ 		idaws[i] = page_to_phys(pa->pa_page[i]);
+ 
+ 		/* Incorporate any offset from each starting address */
+ 		idaws[i] += pa->pa_iova[i] & (PAGE_SIZE - 1);
+ 	}
++>>>>>>> 61f3a16b9d5c (vfio/ccw: allocate/populate the guest idal)
  }
  
  static void convert_ccw0_to_ccw1(struct ccw1 *source, unsigned long len)
@@@ -504,20 -497,67 +513,77 @@@ static int ccwchain_fetch_tic(struct cc
  	return -EFAULT;
  }
  
++<<<<<<< HEAD
 +static int ccwchain_fetch_direct(struct ccwchain *chain,
 +				 int idx,
 +				 struct channel_program *cp)
++=======
+ static unsigned long *get_guest_idal(struct ccw1 *ccw,
+ 				     struct channel_program *cp,
+ 				     int idaw_nr)
+ {
+ 	struct vfio_device *vdev =
+ 		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
+ 	unsigned long *idaws;
+ 	int idal_len = idaw_nr * sizeof(*idaws);
+ 	int idaw_size = PAGE_SIZE;
+ 	int idaw_mask = ~(idaw_size - 1);
+ 	int i, ret;
+ 
+ 	idaws = kcalloc(idaw_nr, sizeof(*idaws), GFP_DMA | GFP_KERNEL);
+ 	if (!idaws)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (ccw_is_idal(ccw)) {
+ 		/* Copy IDAL from guest */
+ 		ret = vfio_dma_rw(vdev, ccw->cda, idaws, idal_len, false);
+ 		if (ret) {
+ 			kfree(idaws);
+ 			return ERR_PTR(ret);
+ 		}
+ 	} else {
+ 		/* Fabricate an IDAL based off CCW data address */
+ 		if (cp->orb.cmd.c64) {
+ 			idaws[0] = ccw->cda;
+ 			for (i = 1; i < idaw_nr; i++)
+ 				idaws[i] = (idaws[i - 1] + idaw_size) & idaw_mask;
+ 		} else {
+ 			kfree(idaws);
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 		}
+ 	}
+ 
+ 	return idaws;
+ }
+ 
+ /*
+  * ccw_count_idaws() - Calculate the number of IDAWs needed to transfer
+  * a specified amount of data
+  *
+  * @ccw: The Channel Command Word being translated
+  * @cp: Channel Program being processed
+  *
+  * The ORB is examined, since it specifies what IDAWs could actually be
+  * used by any CCW in the channel program, regardless of whether or not
+  * the CCW actually does. An ORB that does not specify Format-2-IDAW
+  * Control could still contain a CCW with an IDAL, which would be
+  * Format-1 and thus only move 2K with each IDAW. Thus all CCWs within
+  * the channel program must follow the same size requirements.
+  */
+ static int ccw_count_idaws(struct ccw1 *ccw,
+ 			   struct channel_program *cp)
++>>>>>>> 61f3a16b9d5c (vfio/ccw: allocate/populate the guest idal)
  {
 -	struct vfio_device *vdev =
 -		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
 +	struct ccw1 *ccw;
 +	struct pfn_array *pa;
  	u64 iova;
 -	int size = cp->orb.cmd.c64 ? sizeof(u64) : sizeof(u32);
 +	unsigned long *idaws;
  	int ret;
  	int bytes = 1;
 +	int idaw_nr, idal_len;
 +	int i;
 +
 +	ccw = chain->ch_ccw + idx;
  
  	if (ccw->count)
  		bytes = ccw->count;
@@@ -532,13 -571,46 +598,44 @@@
  	} else {
  		iova = ccw->cda;
  	}
++<<<<<<< HEAD
 +	idaw_nr = idal_nr_words((void *)iova, bytes);
 +	idal_len = idaw_nr * sizeof(*idaws);
++=======
+ 
+ 	/* Format-1 IDAWs operate on 2K each */
+ 	if (!cp->orb.cmd.c64)
+ 		return idal_2k_nr_words((void *)iova, bytes);
+ 
+ 	/* Using the 2K variant of Format-2 IDAWs? */
+ 	if (cp->orb.cmd.i2k)
+ 		return idal_2k_nr_words((void *)iova, bytes);
+ 
+ 	/* The 'usual' case is 4K Format-2 IDAWs */
+ 	return idal_nr_words((void *)iova, bytes);
+ }
+ 
+ static int ccwchain_fetch_ccw(struct ccw1 *ccw,
+ 			      struct page_array *pa,
+ 			      struct channel_program *cp)
+ {
+ 	struct vfio_device *vdev =
+ 		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
+ 	unsigned long *idaws;
+ 	int ret;
+ 	int idaw_nr;
+ 	int i;
+ 
+ 	/* Calculate size of IDAL */
+ 	idaw_nr = ccw_count_idaws(ccw, cp);
+ 	if (idaw_nr < 0)
+ 		return idaw_nr;
++>>>>>>> 61f3a16b9d5c (vfio/ccw: allocate/populate the guest idal)
  
  	/* Allocate an IDAL from host storage */
- 	idaws = kcalloc(idaw_nr, sizeof(*idaws), GFP_DMA | GFP_KERNEL);
- 	if (!idaws) {
- 		ret = -ENOMEM;
+ 	idaws = get_guest_idal(ccw, cp, idaw_nr);
+ 	if (IS_ERR(idaws)) {
+ 		ret = PTR_ERR(idaws);
  		goto out_init;
  	}
  
@@@ -553,24 -624,13 +650,34 @@@
  	if (ret < 0)
  		goto out_free_idaws;
  
++<<<<<<< HEAD
 +	if (ccw_is_idal(ccw)) {
 +		/* Copy guest IDAL into host IDAL */
 +		ret = copy_from_iova(cp->mdev, idaws, ccw->cda, idal_len);
 +		if (ret)
 +			goto out_unpin;
 +
 +		/*
 +		 * Copy guest IDAWs into pfn_array, in case the memory they
 +		 * occupy is not contiguous.
 +		 */
 +		for (i = 0; i < idaw_nr; i++)
 +			pa->pa_iova_pfn[i] = idaws[i] >> PAGE_SHIFT;
 +	} else {
 +		/*
 +		 * No action is required here; the iova addresses in pfn_array
 +		 * were initialized sequentially in pfn_array_alloc() beginning
 +		 * with the contents of ccw->cda.
 +		 */
++=======
+ 	/*
+ 	 * Copy guest IDAWs into page_array, in case the memory they
+ 	 * occupy is not contiguous.
+ 	 */
+ 	for (i = 0; i < idaw_nr; i++) {
+ 		if (cp->orb.cmd.c64)
+ 			pa->pa_iova[i] = idaws[i];
++>>>>>>> 61f3a16b9d5c (vfio/ccw: allocate/populate the guest idal)
  	}
  
  	if (ccw_does_data_transfer(ccw)) {
* Unmerged path drivers/s390/cio/vfio_ccw_cp.c
