media: uvcvideo: Refactor __uvc_ctrl_add_mapping

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Ricardo Ribalda <ribalda@chromium.org>
commit 252d50da337ba97019574b1e830879d5dd5121d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/252d50da.failed

Simplify the exit code with a common error tag freeing all the memory.

	Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Ricardo Ribalda <ribalda@chromium.org>
	Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
(cherry picked from commit 252d50da337ba97019574b1e830879d5dd5121d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index c2cba0b5f59f,ffa0e2654264..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -2062,34 -2283,59 +2062,63 @@@ static int __uvc_ctrl_add_mapping(struc
  {
  	struct uvc_control_mapping *map;
  	unsigned int size;
 -	unsigned int i;
  
++<<<<<<< HEAD
 +	/* Most mappings come from static kernel data and need to be duplicated.
++=======
+ 	/*
+ 	 * Most mappings come from static kernel data, and need to be duplicated.
++>>>>>>> 252d50da337b (media: uvcvideo: Refactor __uvc_ctrl_add_mapping)
  	 * Mappings that come from userspace will be unnecessarily duplicated,
  	 * this could be optimized.
  	 */
  	map = kmemdup(mapping, sizeof(*mapping), GFP_KERNEL);
- 	if (map == NULL)
+ 	if (!map)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	map->name = NULL;
+ 	map->menu_info = NULL;
+ 
+ 	/* For UVCIOC_CTRL_MAP custom control */
+ 	if (mapping->name) {
+ 		map->name = kstrdup(mapping->name, GFP_KERNEL);
+ 		if (!map->name)
+ 			goto err_nomem;
+ 	}
+ 
++>>>>>>> 252d50da337b (media: uvcvideo: Refactor __uvc_ctrl_add_mapping)
  	INIT_LIST_HEAD(&map->ev_subs);
  
  	size = sizeof(*mapping->menu_info) * mapping->menu_count;
  	map->menu_info = kmemdup(mapping->menu_info, size, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (map->menu_info == NULL) {
 +		kfree(map);
 +		return -ENOMEM;
 +	}
++=======
+ 	if (!map->menu_info)
+ 		goto err_nomem;
++>>>>>>> 252d50da337b (media: uvcvideo: Refactor __uvc_ctrl_add_mapping)
  
  	if (map->get == NULL)
  		map->get = uvc_get_le_value;
  	if (map->set == NULL)
  		map->set = uvc_set_le_value;
  
 -	for (i = 0; i < ARRAY_SIZE(uvc_control_classes); i++) {
 -		if (V4L2_CTRL_ID2WHICH(uvc_control_classes[i]) ==
 -						V4L2_CTRL_ID2WHICH(map->id)) {
 -			chain->ctrl_class_bitmap |= BIT(i);
 -			break;
 -		}
 -	}
 -
  	list_add_tail(&map->list, &ctrl->info.mappings);
 -	uvc_dbg(chain->dev, CONTROL, "Adding mapping '%s' to control %pUl/%u\n",
 -		uvc_map_get_name(map), ctrl->info.entity,
 -		ctrl->info.selector);
 +	uvc_dbg(dev, CONTROL, "Adding mapping '%s' to control %pUl/%u\n",
 +		map->name, ctrl->info.entity, ctrl->info.selector);
  
  	return 0;
+ 
+ err_nomem:
+ 	kfree(map->menu_info);
+ 	kfree(map->name);
+ 	kfree(map);
+ 	return -ENOMEM;
  }
  
  int uvc_ctrl_add_mapping(struct uvc_video_chain *chain,
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
