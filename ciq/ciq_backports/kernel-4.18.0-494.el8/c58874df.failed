media: uvcvideo: Use indexed loops in uvc_ctrl_init_ctrl()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Laurent Pinchart <laurent.pinchart@ideasonboard.com>
commit c58874df1051c2baee8dabb8c476c3e476923923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/c58874df.failed

As shown by the bug introduced in commit 86f7ef773156 ("media: uvcvideo:
Add support for per-device control mapping overrides"), the loop style
used by uvc_ctrl_init_ctrl() is error-prone. Rewrite the loops to use
indices instead.

	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Reviewed-by: Ricardo Ribalda <ribalda@chromium.org>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
(cherry picked from commit c58874df1051c2baee8dabb8c476c3e476923923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index 6b12dcdabf26,5c33b0b7ef9a..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -2254,13 -2408,12 +2254,19 @@@ static void uvc_ctrl_prune_entity(struc
   * Add control information and hardcoded stock control mappings to the given
   * device.
   */
 -static void uvc_ctrl_init_ctrl(struct uvc_video_chain *chain,
 -			       struct uvc_control *ctrl)
 +static void uvc_ctrl_init_ctrl(struct uvc_device *dev, struct uvc_control *ctrl)
  {
++<<<<<<< HEAD
 +	const struct uvc_control_info *info = uvc_ctrls;
 +	const struct uvc_control_info *iend = info + ARRAY_SIZE(uvc_ctrls);
 +	const struct uvc_control_mapping *mapping = uvc_ctrl_mappings;
 +	const struct uvc_control_mapping *mend =
 +		mapping + ARRAY_SIZE(uvc_ctrl_mappings);
++=======
+ 	const struct uvc_control_mapping *mappings;
+ 	unsigned int num_mappings;
+ 	unsigned int i;
++>>>>>>> c58874df1051 (media: uvcvideo: Use indexed loops in uvc_ctrl_init_ctrl())
  
  	/*
  	 * XU controls initialization requires querying the device for control
@@@ -2271,10 -2424,12 +2277,12 @@@
  	if (UVC_ENTITY_TYPE(ctrl->entity) == UVC_VC_EXTENSION_UNIT)
  		return;
  
- 	for (; info < iend; ++info) {
+ 	for (i = 0; i < ARRAY_SIZE(uvc_ctrls); ++i) {
+ 		const struct uvc_control_info *info = &uvc_ctrls[i];
+ 
  		if (uvc_entity_match_guid(ctrl->entity, info->entity) &&
  		    ctrl->index == info->index) {
 -			uvc_ctrl_add_info(chain->dev, ctrl, info);
 +			uvc_ctrl_add_info(dev, ctrl, info);
  			/*
  			 * Retrieve control flags from the device. Ignore errors
  			 * and work with default flag values from the uvc_ctrl
@@@ -2289,10 -2444,55 +2297,62 @@@
  	if (!ctrl->initialized)
  		return;
  
++<<<<<<< HEAD
 +	for (; mapping < mend; ++mapping) {
 +		if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
 +		    ctrl->info.selector == mapping->selector)
 +			__uvc_ctrl_add_mapping(dev, ctrl, mapping);
++=======
+ 	/*
+ 	 * First check if the device provides a custom mapping for this control,
+ 	 * used to override standard mappings for non-conformant devices. Don't
+ 	 * process standard mappings if a custom mapping is found. This
+ 	 * mechanism doesn't support combining standard and custom mappings for
+ 	 * a single control.
+ 	 */
+ 	if (chain->dev->info->mappings) {
+ 		bool custom = false;
+ 
+ 		for (i = 0; chain->dev->info->mappings[i]; ++i) {
+ 			const struct uvc_control_mapping *mapping =
+ 				chain->dev->info->mappings[i];
+ 
+ 			if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
+ 			    ctrl->info.selector == mapping->selector) {
+ 				__uvc_ctrl_add_mapping(chain, ctrl, mapping);
+ 				custom = true;
+ 			}
+ 		}
+ 
+ 		if (custom)
+ 			return;
+ 	}
+ 
+ 	/* Process common mappings next. */
+ 	for (i = 0; i < ARRAY_SIZE(uvc_ctrl_mappings); ++i) {
+ 		const struct uvc_control_mapping *mapping = &uvc_ctrl_mappings[i];
+ 
+ 		if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
+ 		    ctrl->info.selector == mapping->selector)
+ 			__uvc_ctrl_add_mapping(chain, ctrl, mapping);
+ 	}
+ 
+ 	/* Finally process version-specific mappings. */
+ 	if (chain->dev->uvc_version < 0x0150) {
+ 		mappings = uvc_ctrl_mappings_uvc11;
+ 		num_mappings = ARRAY_SIZE(uvc_ctrl_mappings_uvc11);
+ 	} else {
+ 		mappings = uvc_ctrl_mappings_uvc15;
+ 		num_mappings = ARRAY_SIZE(uvc_ctrl_mappings_uvc15);
+ 	}
+ 
+ 	for (i = 0; i < num_mappings; ++i) {
+ 		const struct uvc_control_mapping *mapping = &mappings[i];
+ 
+ 		if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
+ 		    ctrl->info.selector == mapping->selector)
+ 			__uvc_ctrl_add_mapping(chain, ctrl, mapping);
++>>>>>>> c58874df1051 (media: uvcvideo: Use indexed loops in uvc_ctrl_init_ctrl())
  	}
  }
  
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
