usb: typec: tipd: Prevent uninitialized event{1,2} in IRQ handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Sven Peter <sven@svenpeter.dev>
commit 6d8fc203b28ff8f6115fbe5eaf584de8b824f4fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/6d8fc203.failed

If reading TPS_REG_INT_EVENT1/2 fails in the interrupt handler event1
and event2 may be uninitialized when they are used to determine
IRQ_HANDLED vs. IRQ_NONE in the error path.

Fixes: c7260e29dd20 ("usb: typec: tipd: Add short-circuit for no irqs")
Fixes: 45188f27b3d0 ("usb: typec: tipd: Add support for Apple CD321X")
	Cc: stable <stable@kernel.org>
	Signed-off-by: Sven Peter <sven@svenpeter.dev>
	Reviewed-by: Eric Curtin <ecurtin@redhat.com>
	Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Reviewed-by: Guido GÃ¼nther <agx@sigxcpu.org>
Link: https://lore.kernel.org/r/20221102161542.30669-1-sven@svenpeter.dev
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6d8fc203b28ff8f6115fbe5eaf584de8b824f4fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/tipd/core.c
diff --cc drivers/usb/typec/tipd/core.c
index ea4cc0a6e40c,2a77bab948f5..000000000000
--- a/drivers/usb/typec/tipd/core.c
+++ b/drivers/usb/typec/tipd/core.c
@@@ -401,13 -413,115 +401,125 @@@ static const struct typec_operations tp
  	.pr_set = tps6598x_pr_set,
  };
  
++<<<<<<< HEAD
 +static irqreturn_t tps6598x_interrupt(int irq, void *data)
 +{
 +	struct tps6598x *tps = data;
 +	u64 event1;
 +	u64 event2;
 +	u32 status, data_status;
 +	u16 pwr_status;
++=======
+ static bool tps6598x_read_status(struct tps6598x *tps, u32 *status)
+ {
+ 	int ret;
+ 
+ 	ret = tps6598x_read32(tps, TPS_REG_STATUS, status);
+ 	if (ret) {
+ 		dev_err(tps->dev, "%s: failed to read status\n", __func__);
+ 		return false;
+ 	}
+ 	trace_tps6598x_status(*status);
+ 
+ 	return true;
+ }
+ 
+ static bool tps6598x_read_data_status(struct tps6598x *tps)
+ {
+ 	u32 data_status;
+ 	int ret;
+ 
+ 	ret = tps6598x_read32(tps, TPS_REG_DATA_STATUS, &data_status);
+ 	if (ret < 0) {
+ 		dev_err(tps->dev, "failed to read data status: %d\n", ret);
+ 		return false;
+ 	}
+ 	trace_tps6598x_data_status(data_status);
+ 
+ 	return true;
+ }
+ 
+ static bool tps6598x_read_power_status(struct tps6598x *tps)
+ {
+ 	u16 pwr_status;
+ 	int ret;
+ 
+ 	ret = tps6598x_read16(tps, TPS_REG_POWER_STATUS, &pwr_status);
+ 	if (ret < 0) {
+ 		dev_err(tps->dev, "failed to read power status: %d\n", ret);
+ 		return false;
+ 	}
+ 	tps->pwr_status = pwr_status;
+ 	trace_tps6598x_power_status(pwr_status);
+ 
+ 	return true;
+ }
+ 
+ static void tps6598x_handle_plug_event(struct tps6598x *tps, u32 status)
+ {
+ 	int ret;
+ 
+ 	if (status & TPS_STATUS_PLUG_PRESENT) {
+ 		ret = tps6598x_connect(tps, status);
+ 		if (ret)
+ 			dev_err(tps->dev, "failed to register partner\n");
+ 	} else {
+ 		tps6598x_disconnect(tps, status);
+ 	}
+ }
+ 
+ static irqreturn_t cd321x_interrupt(int irq, void *data)
+ {
+ 	struct tps6598x *tps = data;
+ 	u64 event = 0;
+ 	u32 status;
+ 	int ret;
+ 
+ 	mutex_lock(&tps->lock);
+ 
+ 	ret = tps6598x_read64(tps, TPS_REG_INT_EVENT1, &event);
+ 	if (ret) {
+ 		dev_err(tps->dev, "%s: failed to read events\n", __func__);
+ 		goto err_unlock;
+ 	}
+ 	trace_cd321x_irq(event);
+ 
+ 	if (!event)
+ 		goto err_unlock;
+ 
+ 	if (!tps6598x_read_status(tps, &status))
+ 		goto err_clear_ints;
+ 
+ 	if (event & APPLE_CD_REG_INT_POWER_STATUS_UPDATE)
+ 		if (!tps6598x_read_power_status(tps))
+ 			goto err_clear_ints;
+ 
+ 	if (event & APPLE_CD_REG_INT_DATA_STATUS_UPDATE)
+ 		if (!tps6598x_read_data_status(tps))
+ 			goto err_clear_ints;
+ 
+ 	/* Handle plug insert or removal */
+ 	if (event & APPLE_CD_REG_INT_PLUG_EVENT)
+ 		tps6598x_handle_plug_event(tps, status);
+ 
+ err_clear_ints:
+ 	tps6598x_write64(tps, TPS_REG_INT_CLEAR1, event);
+ 
+ err_unlock:
+ 	mutex_unlock(&tps->lock);
+ 
+ 	if (event)
+ 		return IRQ_HANDLED;
+ 	return IRQ_NONE;
+ }
+ 
+ static irqreturn_t tps6598x_interrupt(int irq, void *data)
+ {
+ 	struct tps6598x *tps = data;
+ 	u64 event1 = 0;
+ 	u64 event2 = 0;
+ 	u32 status;
++>>>>>>> 6d8fc203b28f (usb: typec: tipd: Prevent uninitialized event{1,2} in IRQ handler)
  	int ret;
  
  	mutex_lock(&tps->lock);
* Unmerged path drivers/usb/typec/tipd/core.c
