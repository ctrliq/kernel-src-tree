perf/x86/amd/lbr: Add LbrExtV2 branch record support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Sandipan Das <sandipan.das@amd.com>
commit ca5b7c0d9621702e107c83216316a6d722878b64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/ca5b7c0d.failed

If AMD Last Branch Record Extension Version 2 (LbrExtV2) is detected,
enable it alongside LBR Freeze on PMI when an event requests branch stack
i.e. PERF_SAMPLE_BRANCH_STACK.

Each branch record is represented by a pair of registers, LBR From and LBR
To. The freeze feature prevents any updates to these registers once a PMC
overflows. The contents remain unchanged until the freeze bit is cleared by
the PMI handler.

The branch records are read and copied to sample data before unfreezing.
However, only valid entries are copied. There is no additional register to
denote which of the register pairs represent the top of the stack (TOS)
since internal register renaming always ensures that the first pair (i.e.
index 0) is the one representing the most recent branch and so on.

The LBR registers are per-thread resources and are cleared explicitly
whenever a new task is scheduled in. There are no special implications on
the contents of these registers when transitioning to deep C-states.

	Signed-off-by: Sandipan Das <sandipan.das@amd.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lore.kernel.org/r/d3b8500a3627a0d4d0259b005891ee248f248d91.1660211399.git.sandipan.das@amd.com
(cherry picked from commit ca5b7c0d9621702e107c83216316a6d722878b64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/amd/core.c
#	arch/x86/events/amd/lbr.c
#	arch/x86/events/perf_event.h
diff --cc arch/x86/events/amd/core.c
index f5d6291850fc,d799628016c8..000000000000
--- a/arch/x86/events/amd/core.c
+++ b/arch/x86/events/amd/core.c
@@@ -1372,10 -1392,18 +1390,25 @@@ static int __init amd_core_pmu_init(voi
  		x86_pmu.flags |= PMU_FL_PAIR;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * BRS requires special event constraints and flushing on ctxsw.
 +	 */
 +	if (boot_cpu_data.x86 >= 0x19 && !amd_brs_init()) {
++=======
+ 	/* LBR and BRS are mutually exclusive features */
+ 	if (!amd_pmu_lbr_init()) {
+ 		/* LBR requires flushing on context switch */
+ 		x86_pmu.sched_task = amd_pmu_lbr_sched_task;
+ 		static_call_update(amd_pmu_branch_hw_config, amd_pmu_lbr_hw_config);
+ 		static_call_update(amd_pmu_branch_reset, amd_pmu_lbr_reset);
+ 		static_call_update(amd_pmu_branch_add, amd_pmu_lbr_add);
+ 		static_call_update(amd_pmu_branch_del, amd_pmu_lbr_del);
+ 	} else if (!amd_brs_init()) {
+ 		/*
+ 		 * BRS requires special event constraints and flushing on ctxsw.
+ 		 */
++>>>>>>> ca5b7c0d9621 (perf/x86/amd/lbr: Add LbrExtV2 branch record support)
  		x86_pmu.get_event_constraints = amd_get_event_constraints_f19h;
  		x86_pmu.sched_task = amd_pmu_brs_sched_task;
  		x86_pmu.limit_period = amd_pmu_limit_period;
diff --cc arch/x86/events/perf_event.h
index 46be49bdb33c,e8930414cba5..000000000000
--- a/arch/x86/events/perf_event.h
+++ b/arch/x86/events/perf_event.h
@@@ -1236,6 -1232,16 +1236,19 @@@ static inline bool fixed_counter_disabl
  
  int amd_pmu_init(void);
  
++<<<<<<< HEAD
++=======
+ int amd_pmu_lbr_init(void);
+ void amd_pmu_lbr_reset(void);
+ void amd_pmu_lbr_read(void);
+ void amd_pmu_lbr_add(struct perf_event *event);
+ void amd_pmu_lbr_del(struct perf_event *event);
+ void amd_pmu_lbr_sched_task(struct perf_event_context *ctx, bool sched_in);
+ void amd_pmu_lbr_enable_all(void);
+ void amd_pmu_lbr_disable_all(void);
+ int amd_pmu_lbr_hw_config(struct perf_event *event);
+ 
++>>>>>>> ca5b7c0d9621 (perf/x86/amd/lbr: Add LbrExtV2 branch record support)
  #ifdef CONFIG_PERF_EVENTS_AMD_BRS
  
  #define AMD_FAM19H_BRS_EVENT 0xc4 /* RETIRED_TAKEN_BRANCH_INSTRUCTIONS */
* Unmerged path arch/x86/events/amd/lbr.c
* Unmerged path arch/x86/events/amd/core.c
* Unmerged path arch/x86/events/amd/lbr.c
* Unmerged path arch/x86/events/perf_event.h
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 3f7ce6edabba..3273ad38ea29 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -551,6 +551,9 @@
 #define MSR_AMD64_PERF_CNTR_GLOBAL_CTL		0xc0000301
 #define MSR_AMD64_PERF_CNTR_GLOBAL_STATUS_CLR	0xc0000302
 
+/* AMD Last Branch Record MSRs */
+#define MSR_AMD64_LBR_SELECT			0xc000010e
+
 /* Fam 17h MSRs */
 #define MSR_F17H_IRPERF			0xc00000e9
 
@@ -723,6 +726,8 @@
 #define MSR_AMD_DBG_EXTN_CFG		0xc000010f
 #define MSR_AMD_SAMP_BR_FROM		0xc0010300
 
+#define DBG_EXTN_CFG_LBRV2EN		BIT_ULL(6)
+
 #define MSR_IA32_MPERF			0x000000e7
 #define MSR_IA32_APERF			0x000000e8
 
