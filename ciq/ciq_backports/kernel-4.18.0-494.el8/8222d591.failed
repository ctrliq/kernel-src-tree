xfrm: Zero padding when dumping algos and encap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 8222d5910dae08213b6d9d4bc9a7f8502855e624
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/8222d591.failed

When copying data to user-space we should ensure that only valid
data is copied over.  Padding in structures may be filled with
random (possibly sensitve) data and should never be given directly
to user-space.

This patch fixes the copying of xfrm algorithms and the encap
template in xfrm_user so that padding is zeroed.

	Reported-by: syzbot+fa5414772d5c445dac3c@syzkaller.appspotmail.com
	Reported-by: Hyunwoo Kim <v4bel@theori.io>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 8222d5910dae08213b6d9d4bc9a7f8502855e624)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_user.c
diff --cc net/xfrm/xfrm_user.c
index db038d37fa23,103af2b3e986..000000000000
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@@ -860,12 -979,104 +860,103 @@@ static int copy_to_user_auth(struct xfr
  			  sizeof(*algo) + (auth->alg_key_len + 7) / 8);
  	if (!nla)
  		return -EMSGSIZE;
 +
  	algo = nla_data(nla);
  	strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));
 -
 -	if (redact_secret && auth->alg_key_len)
 -		memset(algo->alg_key, 0, (auth->alg_key_len + 7) / 8);
 -	else
 -		memcpy(algo->alg_key, auth->alg_key,
 -		       (auth->alg_key_len + 7) / 8);
 +	memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);
  	algo->alg_key_len = auth->alg_key_len;
  
++<<<<<<< HEAD
++=======
+ 	nla = nla_reserve(skb, XFRMA_ALG_AUTH_TRUNC, xfrm_alg_auth_len(auth));
+ 	if (!nla)
+ 		return -EMSGSIZE;
+ 	ap = nla_data(nla);
+ 	memcpy(ap, auth, sizeof(struct xfrm_algo_auth));
+ 	if (redact_secret && auth->alg_key_len)
+ 		memset(ap->alg_key, 0, (auth->alg_key_len + 7) / 8);
+ 	else
+ 		memcpy(ap->alg_key, auth->alg_key,
+ 		       (auth->alg_key_len + 7) / 8);
+ 	return 0;
+ }
+ 
+ static int copy_to_user_aead(struct xfrm_algo_aead *aead, struct sk_buff *skb)
+ {
+ 	struct nlattr *nla = nla_reserve(skb, XFRMA_ALG_AEAD, aead_len(aead));
+ 	struct xfrm_algo_aead *ap;
+ 	bool redact_secret = xfrm_redact();
+ 
+ 	if (!nla)
+ 		return -EMSGSIZE;
+ 
+ 	ap = nla_data(nla);
+ 	strscpy_pad(ap->alg_name, aead->alg_name, sizeof(ap->alg_name));
+ 	ap->alg_key_len = aead->alg_key_len;
+ 	ap->alg_icv_len = aead->alg_icv_len;
+ 
+ 	if (redact_secret && aead->alg_key_len)
+ 		memset(ap->alg_key, 0, (aead->alg_key_len + 7) / 8);
+ 	else
+ 		memcpy(ap->alg_key, aead->alg_key,
+ 		       (aead->alg_key_len + 7) / 8);
+ 	return 0;
+ }
+ 
+ static int copy_to_user_ealg(struct xfrm_algo *ealg, struct sk_buff *skb)
+ {
+ 	struct xfrm_algo *ap;
+ 	bool redact_secret = xfrm_redact();
+ 	struct nlattr *nla = nla_reserve(skb, XFRMA_ALG_CRYPT,
+ 					 xfrm_alg_len(ealg));
+ 	if (!nla)
+ 		return -EMSGSIZE;
+ 
+ 	ap = nla_data(nla);
+ 	strscpy_pad(ap->alg_name, ealg->alg_name, sizeof(ap->alg_name));
+ 	ap->alg_key_len = ealg->alg_key_len;
+ 
+ 	if (redact_secret && ealg->alg_key_len)
+ 		memset(ap->alg_key, 0, (ealg->alg_key_len + 7) / 8);
+ 	else
+ 		memcpy(ap->alg_key, ealg->alg_key,
+ 		       (ealg->alg_key_len + 7) / 8);
+ 
++>>>>>>> 8222d5910dae (xfrm: Zero padding when dumping algos and encap)
+ 	return 0;
+ }
+ 
+ static int copy_to_user_calg(struct xfrm_algo *calg, struct sk_buff *skb)
+ {
+ 	struct nlattr *nla = nla_reserve(skb, XFRMA_ALG_COMP, sizeof(*calg));
+ 	struct xfrm_algo *ap;
+ 
+ 	if (!nla)
+ 		return -EMSGSIZE;
+ 
+ 	ap = nla_data(nla);
+ 	strscpy_pad(ap->alg_name, calg->alg_name, sizeof(ap->alg_name));
+ 	ap->alg_key_len = 0;
+ 
+ 	return 0;
+ }
+ 
+ static int copy_to_user_encap(struct xfrm_encap_tmpl *ep, struct sk_buff *skb)
+ {
+ 	struct nlattr *nla = nla_reserve(skb, XFRMA_ENCAP, sizeof(*ep));
+ 	struct xfrm_encap_tmpl *uep;
+ 
+ 	if (!nla)
+ 		return -EMSGSIZE;
+ 
+ 	uep = nla_data(nla);
+ 	memset(uep, 0, sizeof(*uep));
+ 
+ 	uep->encap_type = ep->encap_type;
+ 	uep->encap_sport = ep->encap_sport;
+ 	uep->encap_dport = ep->encap_dport;
+ 	uep->encap_oa = ep->encap_oa;
+ 
  	return 0;
  }
  
* Unmerged path net/xfrm/xfrm_user.c
