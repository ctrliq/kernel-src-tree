vfio/ccw: read only one Format-1 IDAW

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Eric Farman <farman@linux.ibm.com>
commit 667e5dbabf2bb790640525cff7d563cf88eb3e61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/667e5dba.failed

The intention is to read the first IDAW to determine the starting
location of an I/O operation, knowing that the second and any/all
subsequent IDAWs will be aligned per architecture. But, this read
receives 64-bits of data, which is the size of a Format-2 IDAW.

In the event that Format-1 IDAWs are presented, adjust the size
of the read to 32-bits. The data will end up occupying the upper
word of the target iova variable, so shift it down to the lower
word for use as an address. (By definition, this IDAW format
uses a 31-bit address, so the "sign" bit will always be off and
there is no concern about sign extension.)

	Signed-off-by: Eric Farman <farman@linux.ibm.com>
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 667e5dbabf2bb790640525cff7d563cf88eb3e61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/vfio_ccw_cp.c
diff --cc drivers/s390/cio/vfio_ccw_cp.c
index 3054373c1ee5,fbb46bec3174..000000000000
--- a/drivers/s390/cio/vfio_ccw_cp.c
+++ b/drivers/s390/cio/vfio_ccw_cp.c
@@@ -504,31 -496,39 +504,48 @@@ static int ccwchain_fetch_tic(struct cc
  	return -EFAULT;
  }
  
 -/*
 - * ccw_count_idaws() - Calculate the number of IDAWs needed to transfer
 - * a specified amount of data
 - *
 - * @ccw: The Channel Command Word being translated
 - * @cp: Channel Program being processed
 - */
 -static int ccw_count_idaws(struct ccw1 *ccw,
 -			   struct channel_program *cp)
 +static int ccwchain_fetch_direct(struct ccwchain *chain,
 +				 int idx,
 +				 struct channel_program *cp)
  {
 -	struct vfio_device *vdev =
 -		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
 +	struct ccw1 *ccw;
 +	struct pfn_array *pa;
  	u64 iova;
++<<<<<<< HEAD
 +	unsigned long *idaws;
++=======
+ 	int size = cp->orb.cmd.c64 ? sizeof(u64) : sizeof(u32);
++>>>>>>> 667e5dbabf2b (vfio/ccw: read only one Format-1 IDAW)
  	int ret;
  	int bytes = 1;
 +	int idaw_nr, idal_len;
 +	int i;
 +
 +	ccw = chain->ch_ccw + idx;
  
  	if (ccw->count)
  		bytes = ccw->count;
  
 +	/* Calculate size of IDAL */
  	if (ccw_is_idal(ccw)) {
++<<<<<<< HEAD
 +		/* Read first IDAW to see if it's 4K-aligned or not. */
 +		/* All subsequent IDAws will be 4K-aligned. */
 +		ret = copy_from_iova(cp->mdev, &iova, ccw->cda, sizeof(iova));
++=======
+ 		/* Read first IDAW to check its starting address. */
+ 		/* All subsequent IDAWs will be 2K- or 4K-aligned. */
+ 		ret = vfio_dma_rw(vdev, ccw->cda, &iova, size, false);
++>>>>>>> 667e5dbabf2b (vfio/ccw: read only one Format-1 IDAW)
  		if (ret)
  			return ret;
+ 
+ 		/*
+ 		 * Format-1 IDAWs only occupy the first 32 bits,
+ 		 * and bit 0 is always off.
+ 		 */
+ 		if (!cp->orb.cmd.c64)
+ 			iova = iova >> 32;
  	} else {
  		iova = ccw->cda;
  	}
* Unmerged path drivers/s390/cio/vfio_ccw_cp.c
