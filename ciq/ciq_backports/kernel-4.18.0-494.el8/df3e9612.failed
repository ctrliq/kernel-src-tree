perf/x86: Make branch classifier fusion-aware

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Sandipan Das <sandipan.das@amd.com>
commit df3e9612f758fb5f9c251cbe262e3c68ffe67b2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/df3e9612.failed

With branch fusion and other optimizations, branch sampling hardware in
some processors can report a branch from address that points to an
instruction preceding the actual branch by several bytes.

In such cases, the classifier cannot determine the branch type which leads
to failures such as with the recently added test from commit b55878c90ab9
("perf test: Add test for branch stack sampling"). Branch information is
also easier to consume and annotate if branch from addresses always point
to branch instructions.

Add a new variant of the branch classifier that can account for instruction
fusion. If fusion is expected and the current branch from address does not
point to a branch instruction, it attempts to find the first branch within
the next (MAX_INSN_SIZE - 1) bytes and if found, additionally provides the
offset between the reported branch from address and the address of the
expected branch instruction.

	Signed-off-by: Sandipan Das <sandipan.das@amd.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lore.kernel.org/r/b6bb0abaa8a54c0b6d716344700ee11a1793d709.1660211399.git.sandipan.das@amd.com
(cherry picked from commit df3e9612f758fb5f9c251cbe262e3c68ffe67b2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/perf_event.h
#	arch/x86/events/utils.c
diff --cc arch/x86/events/perf_event.h
index 46be49bdb33c,93263b98cd6e..000000000000
--- a/arch/x86/events/perf_event.h
+++ b/arch/x86/events/perf_event.h
@@@ -1214,6 -1210,70 +1214,73 @@@ static inline void set_linear_ip(struc
  	regs->ip = ip;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * x86control flow change classification
+  * x86control flow changes include branches, interrupts, traps, faults
+  */
+ enum {
+ 	X86_BR_NONE		= 0,      /* unknown */
+ 
+ 	X86_BR_USER		= 1 << 0, /* branch target is user */
+ 	X86_BR_KERNEL		= 1 << 1, /* branch target is kernel */
+ 
+ 	X86_BR_CALL		= 1 << 2, /* call */
+ 	X86_BR_RET		= 1 << 3, /* return */
+ 	X86_BR_SYSCALL		= 1 << 4, /* syscall */
+ 	X86_BR_SYSRET		= 1 << 5, /* syscall return */
+ 	X86_BR_INT		= 1 << 6, /* sw interrupt */
+ 	X86_BR_IRET		= 1 << 7, /* return from interrupt */
+ 	X86_BR_JCC		= 1 << 8, /* conditional */
+ 	X86_BR_JMP		= 1 << 9, /* jump */
+ 	X86_BR_IRQ		= 1 << 10,/* hw interrupt or trap or fault */
+ 	X86_BR_IND_CALL		= 1 << 11,/* indirect calls */
+ 	X86_BR_ABORT		= 1 << 12,/* transaction abort */
+ 	X86_BR_IN_TX		= 1 << 13,/* in transaction */
+ 	X86_BR_NO_TX		= 1 << 14,/* not in transaction */
+ 	X86_BR_ZERO_CALL	= 1 << 15,/* zero length call */
+ 	X86_BR_CALL_STACK	= 1 << 16,/* call stack */
+ 	X86_BR_IND_JMP		= 1 << 17,/* indirect jump */
+ 
+ 	X86_BR_TYPE_SAVE	= 1 << 18,/* indicate to save branch type */
+ 
+ };
+ 
+ #define X86_BR_PLM (X86_BR_USER | X86_BR_KERNEL)
+ #define X86_BR_ANYTX (X86_BR_NO_TX | X86_BR_IN_TX)
+ 
+ #define X86_BR_ANY       \
+ 	(X86_BR_CALL    |\
+ 	 X86_BR_RET     |\
+ 	 X86_BR_SYSCALL |\
+ 	 X86_BR_SYSRET  |\
+ 	 X86_BR_INT     |\
+ 	 X86_BR_IRET    |\
+ 	 X86_BR_JCC     |\
+ 	 X86_BR_JMP	 |\
+ 	 X86_BR_IRQ	 |\
+ 	 X86_BR_ABORT	 |\
+ 	 X86_BR_IND_CALL |\
+ 	 X86_BR_IND_JMP  |\
+ 	 X86_BR_ZERO_CALL)
+ 
+ #define X86_BR_ALL (X86_BR_PLM | X86_BR_ANY)
+ 
+ #define X86_BR_ANY_CALL		 \
+ 	(X86_BR_CALL		|\
+ 	 X86_BR_IND_CALL	|\
+ 	 X86_BR_ZERO_CALL	|\
+ 	 X86_BR_SYSCALL		|\
+ 	 X86_BR_IRQ		|\
+ 	 X86_BR_INT)
+ 
+ int common_branch_type(int type);
+ int branch_type(unsigned long from, unsigned long to, int abort);
+ int branch_type_fused(unsigned long from, unsigned long to, int abort,
+ 		      int *offset);
+ 
++>>>>>>> df3e9612f758 (perf/x86: Make branch classifier fusion-aware)
  ssize_t x86_event_sysfs_show(char *page, u64 config, u64 event);
  ssize_t intel_event_sysfs_show(char *page, u64 config);
  
* Unmerged path arch/x86/events/utils.c
* Unmerged path arch/x86/events/perf_event.h
* Unmerged path arch/x86/events/utils.c
