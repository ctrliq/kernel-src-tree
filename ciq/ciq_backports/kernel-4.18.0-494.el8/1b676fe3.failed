vfio/ccw: handle a guest Format-1 IDAL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Eric Farman <farman@linux.ibm.com>
commit 1b676fe3d9d3f262bc26bb18dc1b1ac66c83c2a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/1b676fe3.failed

There are two scenarios that need to be addressed here.

First, an ORB that does NOT have the Format-2 IDAL bit set could
have both a direct-addressed CCW and an indirect-data-address CCW
chained together. This means that the IDA CCW will contain a
Format-1 IDAL, and can be easily converted to a 2K Format-2 IDAL.
But it also means that the direct-addressed CCW needs to be
converted to the same 2K Format-2 IDAL for consistency with the
ORB settings.

Secondly, a Format-1 IDAL is comprised of 31-bit addresses.
Thus, we need to cast this IDAL to a pointer of ints while
populating the list of addresses that are sent to vfio.

Since the result of both of these is the use of the 2K IDAL
variants, and the output of vfio-ccw is always a Format-2 IDAL
(in order to use 64-bit addresses), make sure that the correct
control bit gets set in the ORB when these scenarios occur.

	Signed-off-by: Eric Farman <farman@linux.ibm.com>
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 1b676fe3d9d3f262bc26bb18dc1b1ac66c83c2a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/vfio_ccw_cp.c
diff --cc drivers/s390/cio/vfio_ccw_cp.c
index 3054373c1ee5,a7415d440a81..000000000000
--- a/drivers/s390/cio/vfio_ccw_cp.c
+++ b/drivers/s390/cio/vfio_ccw_cp.c
@@@ -186,51 -222,8 +186,53 @@@ static void convert_ccw0_to_ccw1(struc
  	}
  }
  
+ #define idal_is_2k(_cp) (!(_cp)->orb.cmd.c64 || (_cp)->orb.cmd.i2k)
+ 
 +/*
 + * Within the domain (@mdev), copy @n bytes from a guest physical
 + * address (@iova) to a host physical address (@to).
 + */
 +static long copy_from_iova(struct device *mdev,
 +			   void *to, u64 iova,
 +			   unsigned long n)
 +{
 +	struct pfn_array pa = {0};
 +	u64 from;
 +	int i, ret;
 +	unsigned long l, m;
 +
 +	ret = pfn_array_alloc(&pa, iova, n);
 +	if (ret < 0)
 +		return ret;
 +
 +	ret = pfn_array_pin(&pa, mdev);
 +	if (ret < 0) {
 +		pfn_array_unpin_free(&pa, mdev);
 +		return ret;
 +	}
 +
 +	l = n;
 +	for (i = 0; i < pa.pa_nr; i++) {
 +		from = pa.pa_pfn[i] << PAGE_SHIFT;
 +		m = PAGE_SIZE;
 +		if (i == 0) {
 +			from += iova & (PAGE_SIZE - 1);
 +			m -= iova & (PAGE_SIZE - 1);
 +		}
 +
 +		m = min(l, m);
 +		memcpy(to + (n - l), (void *)from, m);
 +
 +		l -= m;
 +		if (l == 0)
 +			break;
 +	}
 +
 +	pfn_array_unpin_free(&pa, mdev);
 +
 +	return l;
 +}
 +
  /*
   * Helpers to operate ccwchain.
   */
@@@ -504,20 -499,70 +506,79 @@@ static int ccwchain_fetch_tic(struct cc
  	return -EFAULT;
  }
  
 -static unsigned long *get_guest_idal(struct ccw1 *ccw,
 -				     struct channel_program *cp,
 -				     int idaw_nr)
 +static int ccwchain_fetch_direct(struct ccwchain *chain,
 +				 int idx,
 +				 struct channel_program *cp)
  {
++<<<<<<< HEAD
 +	struct ccw1 *ccw;
 +	struct pfn_array *pa;
++=======
+ 	struct vfio_device *vdev =
+ 		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
+ 	unsigned long *idaws;
+ 	unsigned int *idaws_f1;
+ 	int idal_len = idaw_nr * sizeof(*idaws);
+ 	int idaw_size = idal_is_2k(cp) ? PAGE_SIZE / 2 : PAGE_SIZE;
+ 	int idaw_mask = ~(idaw_size - 1);
+ 	int i, ret;
+ 
+ 	idaws = kcalloc(idaw_nr, sizeof(*idaws), GFP_DMA | GFP_KERNEL);
+ 	if (!idaws)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (ccw_is_idal(ccw)) {
+ 		/* Copy IDAL from guest */
+ 		ret = vfio_dma_rw(vdev, ccw->cda, idaws, idal_len, false);
+ 		if (ret) {
+ 			kfree(idaws);
+ 			return ERR_PTR(ret);
+ 		}
+ 	} else {
+ 		/* Fabricate an IDAL based off CCW data address */
+ 		if (cp->orb.cmd.c64) {
+ 			idaws[0] = ccw->cda;
+ 			for (i = 1; i < idaw_nr; i++)
+ 				idaws[i] = (idaws[i - 1] + idaw_size) & idaw_mask;
+ 		} else {
+ 			idaws_f1 = (unsigned int *)idaws;
+ 			idaws_f1[0] = ccw->cda;
+ 			for (i = 1; i < idaw_nr; i++)
+ 				idaws_f1[i] = (idaws_f1[i - 1] + idaw_size) & idaw_mask;
+ 		}
+ 	}
+ 
+ 	return idaws;
+ }
+ 
+ /*
+  * ccw_count_idaws() - Calculate the number of IDAWs needed to transfer
+  * a specified amount of data
+  *
+  * @ccw: The Channel Command Word being translated
+  * @cp: Channel Program being processed
+  *
+  * The ORB is examined, since it specifies what IDAWs could actually be
+  * used by any CCW in the channel program, regardless of whether or not
+  * the CCW actually does. An ORB that does not specify Format-2-IDAW
+  * Control could still contain a CCW with an IDAL, which would be
+  * Format-1 and thus only move 2K with each IDAW. Thus all CCWs within
+  * the channel program must follow the same size requirements.
+  */
+ static int ccw_count_idaws(struct ccw1 *ccw,
+ 			   struct channel_program *cp)
+ {
+ 	struct vfio_device *vdev =
+ 		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
++>>>>>>> 1b676fe3d9d3 (vfio/ccw: handle a guest Format-1 IDAL)
  	u64 iova;
 -	int size = cp->orb.cmd.c64 ? sizeof(u64) : sizeof(u32);
 +	unsigned long *idaws;
  	int ret;
  	int bytes = 1;
 +	int idaw_nr, idal_len;
 +	int i;
 +
 +	ccw = chain->ch_ccw + idx;
  
  	if (ccw->count)
  		bytes = ccw->count;
@@@ -532,13 -576,47 +593,45 @@@
  	} else {
  		iova = ccw->cda;
  	}
++<<<<<<< HEAD
 +	idaw_nr = idal_nr_words((void *)iova, bytes);
 +	idal_len = idaw_nr * sizeof(*idaws);
++=======
+ 
+ 	/* Format-1 IDAWs operate on 2K each */
+ 	if (!cp->orb.cmd.c64)
+ 		return idal_2k_nr_words((void *)iova, bytes);
+ 
+ 	/* Using the 2K variant of Format-2 IDAWs? */
+ 	if (cp->orb.cmd.i2k)
+ 		return idal_2k_nr_words((void *)iova, bytes);
+ 
+ 	/* The 'usual' case is 4K Format-2 IDAWs */
+ 	return idal_nr_words((void *)iova, bytes);
+ }
+ 
+ static int ccwchain_fetch_ccw(struct ccw1 *ccw,
+ 			      struct page_array *pa,
+ 			      struct channel_program *cp)
+ {
+ 	struct vfio_device *vdev =
+ 		&container_of(cp, struct vfio_ccw_private, cp)->vdev;
+ 	unsigned long *idaws;
+ 	unsigned int *idaws_f1;
+ 	int ret;
+ 	int idaw_nr;
+ 	int i;
+ 
+ 	/* Calculate size of IDAL */
+ 	idaw_nr = ccw_count_idaws(ccw, cp);
+ 	if (idaw_nr < 0)
+ 		return idaw_nr;
++>>>>>>> 1b676fe3d9d3 (vfio/ccw: handle a guest Format-1 IDAL)
  
  	/* Allocate an IDAL from host storage */
 -	idaws = get_guest_idal(ccw, cp, idaw_nr);
 -	if (IS_ERR(idaws)) {
 -		ret = PTR_ERR(idaws);
 +	idaws = kcalloc(idaw_nr, sizeof(*idaws), GFP_DMA | GFP_KERNEL);
 +	if (!idaws) {
 +		ret = -ENOMEM;
  		goto out_init;
  	}
  
@@@ -553,24 -630,16 +646,37 @@@
  	if (ret < 0)
  		goto out_free_idaws;
  
++<<<<<<< HEAD
 +	if (ccw_is_idal(ccw)) {
 +		/* Copy guest IDAL into host IDAL */
 +		ret = copy_from_iova(cp->mdev, idaws, ccw->cda, idal_len);
 +		if (ret)
 +			goto out_unpin;
 +
 +		/*
 +		 * Copy guest IDAWs into pfn_array, in case the memory they
 +		 * occupy is not contiguous.
 +		 */
 +		for (i = 0; i < idaw_nr; i++)
 +			pa->pa_iova_pfn[i] = idaws[i] >> PAGE_SHIFT;
 +	} else {
 +		/*
 +		 * No action is required here; the iova addresses in pfn_array
 +		 * were initialized sequentially in pfn_array_alloc() beginning
 +		 * with the contents of ccw->cda.
 +		 */
++=======
+ 	/*
+ 	 * Copy guest IDAWs into page_array, in case the memory they
+ 	 * occupy is not contiguous.
+ 	 */
+ 	idaws_f1 = (unsigned int *)idaws;
+ 	for (i = 0; i < idaw_nr; i++) {
+ 		if (cp->orb.cmd.c64)
+ 			pa->pa_iova[i] = idaws[i];
+ 		else
+ 			pa->pa_iova[i] = idaws_f1[i];
++>>>>>>> 1b676fe3d9d3 (vfio/ccw: handle a guest Format-1 IDAL)
  	}
  
  	if (ccw_does_data_transfer(ccw)) {
* Unmerged path drivers/s390/cio/vfio_ccw_cp.c
