media: v4l: move helper functions for fractions from uvc to v4l2-common

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Michael Grzeschik <m.grzeschik@pengutronix.de>
commit 6ba8b8d45335180523df8f1b6cd1c995a3dbf560
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/6ba8b8d4.failed

The functions uvc_simplify_fraction and uvc_fraction_to_interval are
generic helpers which are also useful for other v4l2 drivers. This patch
moves them to v4l2-common.

	Tested-by: Daniel Scally <dan.scally@ideasonboard.com>
	Reviewed-by: Daniel Scally <dan.scally@ideasonboard.com>
	Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
Link: https://lore.kernel.org/r/20220909221335.15033-2-m.grzeschik@pengutronix.de
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6ba8b8d45335180523df8f1b6cd1c995a3dbf560)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/v4l2-core/v4l2-common.c
#	include/media/v4l2-common.h
diff --cc drivers/media/v4l2-core/v4l2-common.c
index a443cfa050b6,40f56e044640..000000000000
--- a/drivers/media/v4l2-core/v4l2-common.c
+++ b/drivers/media/v4l2-core/v4l2-common.c
@@@ -444,3 -230,343 +444,346 @@@ int v4l2_s_parm_cap(struct video_devic
  	return ret;
  }
  EXPORT_SYMBOL_GPL(v4l2_s_parm_cap);
++<<<<<<< HEAD
++=======
+ 
+ const struct v4l2_format_info *v4l2_format_info(u32 format)
+ {
+ 	static const struct v4l2_format_info formats[] = {
+ 		/* RGB formats */
+ 		{ .format = V4L2_PIX_FMT_BGR24,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_RGB24,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_HSV24,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_BGR32,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_XBGR32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_BGRX32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_RGB32,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_XRGB32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_RGBX32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_HSV32,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_ARGB32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_RGBA32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_ABGR32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_BGRA32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_RGB565,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_RGB555,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_BGR666,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 
+ 		/* YUV packed formats */
+ 		{ .format = V4L2_PIX_FMT_YUYV,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVYU,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_UYVY,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_VYUY,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		/* YUV planar formats */
+ 		{ .format = V4L2_PIX_FMT_NV12,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV21,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV16,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_NV61,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_NV24,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_NV42,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_P010,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 2, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		{ .format = V4L2_PIX_FMT_YUV410,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 4 },
+ 		{ .format = V4L2_PIX_FMT_YVU410,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 4 },
+ 		{ .format = V4L2_PIX_FMT_YUV411P, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YUV420,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YVU420,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YUV422P, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_GREY,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 
+ 		/* Tiled YUV formats */
+ 		{ .format = V4L2_PIX_FMT_NV12_4L4, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_P010_4L4, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 2, 4, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 
+ 		/* YUV planar formats, non contiguous variant */
+ 		{ .format = V4L2_PIX_FMT_YUV420M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YVU420M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YUV422M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVU422M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YUV444M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVU444M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 1, .vdiv = 1 },
+ 
+ 		{ .format = V4L2_PIX_FMT_NV12M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV21M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV16M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_NV61M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		/* Bayer RGB formats */
+ 		{ .format = V4L2_PIX_FMT_SBGGR8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10ALAW8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10ALAW8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10ALAW8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10ALAW8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10DPCM8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10DPCM8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10DPCM8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10DPCM8,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR12,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG12,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG12,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB12,	.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 	};
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(formats); ++i)
+ 		if (formats[i].format == format)
+ 			return &formats[i];
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(v4l2_format_info);
+ 
+ static inline unsigned int v4l2_format_block_width(const struct v4l2_format_info *info, int plane)
+ {
+ 	if (!info->block_w[plane])
+ 		return 1;
+ 	return info->block_w[plane];
+ }
+ 
+ static inline unsigned int v4l2_format_block_height(const struct v4l2_format_info *info, int plane)
+ {
+ 	if (!info->block_h[plane])
+ 		return 1;
+ 	return info->block_h[plane];
+ }
+ 
+ void v4l2_apply_frmsize_constraints(u32 *width, u32 *height,
+ 				    const struct v4l2_frmsize_stepwise *frmsize)
+ {
+ 	if (!frmsize)
+ 		return;
+ 
+ 	/*
+ 	 * Clamp width/height to meet min/max constraints and round it up to
+ 	 * macroblock alignment.
+ 	 */
+ 	*width = clamp_roundup(*width, frmsize->min_width, frmsize->max_width,
+ 			       frmsize->step_width);
+ 	*height = clamp_roundup(*height, frmsize->min_height, frmsize->max_height,
+ 				frmsize->step_height);
+ }
+ EXPORT_SYMBOL_GPL(v4l2_apply_frmsize_constraints);
+ 
+ int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,
+ 			u32 pixelformat, u32 width, u32 height)
+ {
+ 	const struct v4l2_format_info *info;
+ 	struct v4l2_plane_pix_format *plane;
+ 	int i;
+ 
+ 	info = v4l2_format_info(pixelformat);
+ 	if (!info)
+ 		return -EINVAL;
+ 
+ 	pixfmt->width = width;
+ 	pixfmt->height = height;
+ 	pixfmt->pixelformat = pixelformat;
+ 	pixfmt->num_planes = info->mem_planes;
+ 
+ 	if (info->mem_planes == 1) {
+ 		plane = &pixfmt->plane_fmt[0];
+ 		plane->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
+ 		plane->sizeimage = 0;
+ 
+ 		for (i = 0; i < info->comp_planes; i++) {
+ 			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+ 			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+ 			unsigned int aligned_width;
+ 			unsigned int aligned_height;
+ 
+ 			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
+ 			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
+ 
+ 			plane->sizeimage += info->bpp[i] *
+ 				DIV_ROUND_UP(aligned_width, hdiv) *
+ 				DIV_ROUND_UP(aligned_height, vdiv);
+ 		}
+ 	} else {
+ 		for (i = 0; i < info->comp_planes; i++) {
+ 			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+ 			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+ 			unsigned int aligned_width;
+ 			unsigned int aligned_height;
+ 
+ 			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
+ 			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
+ 
+ 			plane = &pixfmt->plane_fmt[i];
+ 			plane->bytesperline =
+ 				info->bpp[i] * DIV_ROUND_UP(aligned_width, hdiv);
+ 			plane->sizeimage =
+ 				plane->bytesperline * DIV_ROUND_UP(aligned_height, vdiv);
+ 		}
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt_mp);
+ 
+ int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,
+ 		     u32 width, u32 height)
+ {
+ 	const struct v4l2_format_info *info;
+ 	int i;
+ 
+ 	info = v4l2_format_info(pixelformat);
+ 	if (!info)
+ 		return -EINVAL;
+ 
+ 	/* Single planar API cannot be used for multi plane formats. */
+ 	if (info->mem_planes > 1)
+ 		return -EINVAL;
+ 
+ 	pixfmt->width = width;
+ 	pixfmt->height = height;
+ 	pixfmt->pixelformat = pixelformat;
+ 	pixfmt->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
+ 	pixfmt->sizeimage = 0;
+ 
+ 	for (i = 0; i < info->comp_planes; i++) {
+ 		unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+ 		unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+ 		unsigned int aligned_width;
+ 		unsigned int aligned_height;
+ 
+ 		aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
+ 		aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
+ 
+ 		pixfmt->sizeimage += info->bpp[i] *
+ 			DIV_ROUND_UP(aligned_width, hdiv) *
+ 			DIV_ROUND_UP(aligned_height, vdiv);
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt);
+ 
+ s64 v4l2_get_link_freq(struct v4l2_ctrl_handler *handler, unsigned int mul,
+ 		       unsigned int div)
+ {
+ 	struct v4l2_ctrl *ctrl;
+ 	s64 freq;
+ 
+ 	ctrl = v4l2_ctrl_find(handler, V4L2_CID_LINK_FREQ);
+ 	if (ctrl) {
+ 		struct v4l2_querymenu qm = { .id = V4L2_CID_LINK_FREQ };
+ 		int ret;
+ 
+ 		qm.index = v4l2_ctrl_g_ctrl(ctrl);
+ 
+ 		ret = v4l2_querymenu(handler, &qm);
+ 		if (ret)
+ 			return -ENOENT;
+ 
+ 		freq = qm.value;
+ 	} else {
+ 		if (!mul || !div)
+ 			return -ENOENT;
+ 
+ 		ctrl = v4l2_ctrl_find(handler, V4L2_CID_PIXEL_RATE);
+ 		if (!ctrl)
+ 			return -ENOENT;
+ 
+ 		freq = div_u64(v4l2_ctrl_g_ctrl_int64(ctrl) * mul, div);
+ 
+ 		pr_warn("%s: Link frequency estimated using pixel rate: result might be inaccurate\n",
+ 			__func__);
+ 		pr_warn("%s: Consider implementing support for V4L2_CID_LINK_FREQ in the transmitter driver\n",
+ 			__func__);
+ 	}
+ 
+ 	return freq > 0 ? freq : -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(v4l2_get_link_freq);
+ 
+ /*
+  * Simplify a fraction using a simple continued fraction decomposition. The
+  * idea here is to convert fractions such as 333333/10000000 to 1/30 using
+  * 32 bit arithmetic only. The algorithm is not perfect and relies upon two
+  * arbitrary parameters to remove non-significative terms from the simple
+  * continued fraction decomposition. Using 8 and 333 for n_terms and threshold
+  * respectively seems to give nice results.
+  */
+ void v4l2_simplify_fraction(u32 *numerator, u32 *denominator,
+ 		unsigned int n_terms, unsigned int threshold)
+ {
+ 	u32 *an;
+ 	u32 x, y, r;
+ 	unsigned int i, n;
+ 
+ 	an = kmalloc_array(n_terms, sizeof(*an), GFP_KERNEL);
+ 	if (an == NULL)
+ 		return;
+ 
+ 	/*
+ 	 * Convert the fraction to a simple continued fraction. See
+ 	 * https://en.wikipedia.org/wiki/Continued_fraction
+ 	 * Stop if the current term is bigger than or equal to the given
+ 	 * threshold.
+ 	 */
+ 	x = *numerator;
+ 	y = *denominator;
+ 
+ 	for (n = 0; n < n_terms && y != 0; ++n) {
+ 		an[n] = x / y;
+ 		if (an[n] >= threshold) {
+ 			if (n < 2)
+ 				n++;
+ 			break;
+ 		}
+ 
+ 		r = x - an[n] * y;
+ 		x = y;
+ 		y = r;
+ 	}
+ 
+ 	/* Expand the simple continued fraction back to an integer fraction. */
+ 	x = 0;
+ 	y = 1;
+ 
+ 	for (i = n; i > 0; --i) {
+ 		r = y;
+ 		y = an[i-1] * y + x;
+ 		x = r;
+ 	}
+ 
+ 	*numerator = y;
+ 	*denominator = x;
+ 	kfree(an);
+ }
+ EXPORT_SYMBOL_GPL(v4l2_simplify_fraction);
+ 
+ /*
+  * Convert a fraction to a frame interval in 100ns multiples. The idea here is
+  * to compute numerator / denominator * 10000000 using 32 bit fixed point
+  * arithmetic only.
+  */
+ u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator)
+ {
+ 	u32 multiplier;
+ 
+ 	/* Saturate the result if the operation would overflow. */
+ 	if (denominator == 0 ||
+ 	    numerator/denominator >= ((u32)-1)/10000000)
+ 		return (u32)-1;
+ 
+ 	/*
+ 	 * Divide both the denominator and the multiplier by two until
+ 	 * numerator * multiplier doesn't overflow. If anyone knows a better
+ 	 * algorithm please let me know.
+ 	 */
+ 	multiplier = 10000000;
+ 	while (numerator > ((u32)-1)/multiplier) {
+ 		multiplier /= 2;
+ 		denominator /= 2;
+ 	}
+ 
+ 	return denominator ? numerator * multiplier / denominator : 0;
+ }
+ EXPORT_SYMBOL_GPL(v4l2_fraction_to_interval);
++>>>>>>> 6ba8b8d45335 (media: v4l: move helper functions for fractions from uvc to v4l2-common)
diff --cc include/media/v4l2-common.h
index 160bca96d524,725ff91b26e0..000000000000
--- a/include/media/v4l2-common.h
+++ b/include/media/v4l2-common.h
@@@ -384,4 -448,149 +384,152 @@@ int v4l2_g_parm_cap(struct video_devic
  int v4l2_s_parm_cap(struct video_device *vdev,
  		    struct v4l2_subdev *sd, struct v4l2_streamparm *a);
  
++<<<<<<< HEAD
++=======
+ /* Compare two v4l2_fract structs */
+ #define V4L2_FRACT_COMPARE(a, OP, b)			\
+ 	((u64)(a).numerator * (b).denominator OP	\
+ 	(u64)(b).numerator * (a).denominator)
+ 
+ /* ------------------------------------------------------------------------- */
+ 
+ /* Pixel format and FourCC helpers */
+ 
+ /**
+  * enum v4l2_pixel_encoding - specifies the pixel encoding value
+  *
+  * @V4L2_PIXEL_ENC_UNKNOWN:	Pixel encoding is unknown/un-initialized
+  * @V4L2_PIXEL_ENC_YUV:		Pixel encoding is YUV
+  * @V4L2_PIXEL_ENC_RGB:		Pixel encoding is RGB
+  * @V4L2_PIXEL_ENC_BAYER:	Pixel encoding is Bayer
+  */
+ enum v4l2_pixel_encoding {
+ 	V4L2_PIXEL_ENC_UNKNOWN = 0,
+ 	V4L2_PIXEL_ENC_YUV = 1,
+ 	V4L2_PIXEL_ENC_RGB = 2,
+ 	V4L2_PIXEL_ENC_BAYER = 3,
+ };
+ 
+ /**
+  * struct v4l2_format_info - information about a V4L2 format
+  * @format: 4CC format identifier (V4L2_PIX_FMT_*)
+  * @pixel_enc: Pixel encoding (see enum v4l2_pixel_encoding above)
+  * @mem_planes: Number of memory planes, which includes the alpha plane (1 to 4).
+  * @comp_planes: Number of component planes, which includes the alpha plane (1 to 4).
+  * @bpp: Array of per-plane bytes per pixel
+  * @hdiv: Horizontal chroma subsampling factor
+  * @vdiv: Vertical chroma subsampling factor
+  * @block_w: Per-plane macroblock pixel width (optional)
+  * @block_h: Per-plane macroblock pixel height (optional)
+  */
+ struct v4l2_format_info {
+ 	u32 format;
+ 	u8 pixel_enc;
+ 	u8 mem_planes;
+ 	u8 comp_planes;
+ 	u8 bpp[4];
+ 	u8 hdiv;
+ 	u8 vdiv;
+ 	u8 block_w[4];
+ 	u8 block_h[4];
+ };
+ 
+ static inline bool v4l2_is_format_rgb(const struct v4l2_format_info *f)
+ {
+ 	return f && f->pixel_enc == V4L2_PIXEL_ENC_RGB;
+ }
+ 
+ static inline bool v4l2_is_format_yuv(const struct v4l2_format_info *f)
+ {
+ 	return f && f->pixel_enc == V4L2_PIXEL_ENC_YUV;
+ }
+ 
+ static inline bool v4l2_is_format_bayer(const struct v4l2_format_info *f)
+ {
+ 	return f && f->pixel_enc == V4L2_PIXEL_ENC_BAYER;
+ }
+ 
+ const struct v4l2_format_info *v4l2_format_info(u32 format);
+ void v4l2_apply_frmsize_constraints(u32 *width, u32 *height,
+ 				    const struct v4l2_frmsize_stepwise *frmsize);
+ int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,
+ 		     u32 width, u32 height);
+ int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt, u32 pixelformat,
+ 			u32 width, u32 height);
+ 
+ /**
+  * v4l2_get_link_freq - Get link rate from transmitter
+  *
+  * @handler: The transmitter's control handler
+  * @mul: The multiplier between pixel rate and link frequency. Bits per pixel on
+  *	 D-PHY, samples per clock on parallel. 0 otherwise.
+  * @div: The divisor between pixel rate and link frequency. Number of data lanes
+  *	 times two on D-PHY, 1 on parallel. 0 otherwise.
+  *
+  * This function is intended for obtaining the link frequency from the
+  * transmitter sub-devices. It returns the link rate, either from the
+  * V4L2_CID_LINK_FREQ control implemented by the transmitter, or value
+  * calculated based on the V4L2_CID_PIXEL_RATE implemented by the transmitter.
+  *
+  * Returns link frequency on success, otherwise a negative error code:
+  *	-ENOENT: Link frequency or pixel rate control not found
+  *	-EINVAL: Invalid link frequency value
+  */
+ s64 v4l2_get_link_freq(struct v4l2_ctrl_handler *handler, unsigned int mul,
+ 		       unsigned int div);
+ 
+ void v4l2_simplify_fraction(u32 *numerator, u32 *denominator,
+ 		unsigned int n_terms, unsigned int threshold);
+ u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator);
+ 
+ static inline u64 v4l2_buffer_get_timestamp(const struct v4l2_buffer *buf)
+ {
+ 	/*
+ 	 * When the timestamp comes from 32-bit user space, there may be
+ 	 * uninitialized data in tv_usec, so cast it to u32.
+ 	 * Otherwise allow invalid input for backwards compatibility.
+ 	 */
+ 	return buf->timestamp.tv_sec * NSEC_PER_SEC +
+ 		(u32)buf->timestamp.tv_usec * NSEC_PER_USEC;
+ }
+ 
+ static inline void v4l2_buffer_set_timestamp(struct v4l2_buffer *buf,
+ 					     u64 timestamp)
+ {
+ 	struct timespec64 ts = ns_to_timespec64(timestamp);
+ 
+ 	buf->timestamp.tv_sec  = ts.tv_sec;
+ 	buf->timestamp.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
+ }
+ 
+ static inline bool v4l2_is_colorspace_valid(__u32 colorspace)
+ {
+ 	return colorspace > V4L2_COLORSPACE_DEFAULT &&
+ 	       colorspace < V4L2_COLORSPACE_LAST;
+ }
+ 
+ static inline bool v4l2_is_xfer_func_valid(__u32 xfer_func)
+ {
+ 	return xfer_func > V4L2_XFER_FUNC_DEFAULT &&
+ 	       xfer_func < V4L2_XFER_FUNC_LAST;
+ }
+ 
+ static inline bool v4l2_is_ycbcr_enc_valid(__u8 ycbcr_enc)
+ {
+ 	return ycbcr_enc > V4L2_YCBCR_ENC_DEFAULT &&
+ 	       ycbcr_enc < V4L2_YCBCR_ENC_LAST;
+ }
+ 
+ static inline bool v4l2_is_hsv_enc_valid(__u8 hsv_enc)
+ {
+ 	return hsv_enc == V4L2_HSV_ENC_180 || hsv_enc == V4L2_HSV_ENC_256;
+ }
+ 
+ static inline bool v4l2_is_quant_valid(__u8 quantization)
+ {
+ 	return quantization == V4L2_QUANTIZATION_FULL_RANGE ||
+ 	       quantization == V4L2_QUANTIZATION_LIM_RANGE;
+ }
+ 
++>>>>>>> 6ba8b8d45335 (media: v4l: move helper functions for fractions from uvc to v4l2-common)
  #endif /* V4L2_COMMON_H_ */
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
index f1b63f0973e0..6b6f577ef0f1 100644
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -324,90 +324,6 @@ static enum v4l2_ycbcr_encoding uvc_ycbcr_enc(const u8 matrix_coefficients)
 	return V4L2_YCBCR_ENC_DEFAULT;  /* Reserved */
 }
 
-/*
- * Simplify a fraction using a simple continued fraction decomposition. The
- * idea here is to convert fractions such as 333333/10000000 to 1/30 using
- * 32 bit arithmetic only. The algorithm is not perfect and relies upon two
- * arbitrary parameters to remove non-significative terms from the simple
- * continued fraction decomposition. Using 8 and 333 for n_terms and threshold
- * respectively seems to give nice results.
- */
-void uvc_simplify_fraction(u32 *numerator, u32 *denominator,
-		unsigned int n_terms, unsigned int threshold)
-{
-	u32 *an;
-	u32 x, y, r;
-	unsigned int i, n;
-
-	an = kmalloc_array(n_terms, sizeof(*an), GFP_KERNEL);
-	if (an == NULL)
-		return;
-
-	/*
-	 * Convert the fraction to a simple continued fraction. See
-	 * https://en.wikipedia.org/wiki/Continued_fraction
-	 * Stop if the current term is bigger than or equal to the given
-	 * threshold.
-	 */
-	x = *numerator;
-	y = *denominator;
-
-	for (n = 0; n < n_terms && y != 0; ++n) {
-		an[n] = x / y;
-		if (an[n] >= threshold) {
-			if (n < 2)
-				n++;
-			break;
-		}
-
-		r = x - an[n] * y;
-		x = y;
-		y = r;
-	}
-
-	/* Expand the simple continued fraction back to an integer fraction. */
-	x = 0;
-	y = 1;
-
-	for (i = n; i > 0; --i) {
-		r = y;
-		y = an[i-1] * y + x;
-		x = r;
-	}
-
-	*numerator = y;
-	*denominator = x;
-	kfree(an);
-}
-
-/*
- * Convert a fraction to a frame interval in 100ns multiples. The idea here is
- * to compute numerator / denominator * 10000000 using 32 bit fixed point
- * arithmetic only.
- */
-u32 uvc_fraction_to_interval(u32 numerator, u32 denominator)
-{
-	u32 multiplier;
-
-	/* Saturate the result if the operation would overflow. */
-	if (denominator == 0 ||
-	    numerator/denominator >= ((u32)-1)/10000000)
-		return (u32)-1;
-
-	/*
-	 * Divide both the denominator and the multiplier by two until
-	 * numerator * multiplier doesn't overflow. If anyone knows a better
-	 * algorithm please let me know.
-	 */
-	multiplier = 10000000;
-	while (numerator > ((u32)-1)/multiplier) {
-		multiplier /= 2;
-		denominator /= 2;
-	}
-
-	return denominator ? numerator * multiplier / denominator : 0;
-}
-
 /* ------------------------------------------------------------------------
  * Terminal and unit management
  */
diff --git a/drivers/media/usb/uvc/uvc_v4l2.c b/drivers/media/usb/uvc/uvc_v4l2.c
index 7ac7c606a574..9432c6fdd54a 100644
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@ -378,7 +378,7 @@ static int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,
 	mutex_unlock(&stream->mutex);
 
 	denominator = 10000000;
-	uvc_simplify_fraction(&numerator, &denominator, 8, 333);
+	v4l2_simplify_fraction(&numerator, &denominator, 8, 333);
 
 	memset(parm, 0, sizeof(*parm));
 	parm->type = stream->type;
@@ -419,7 +419,7 @@ static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 	else
 		timeperframe = parm->parm.output.timeperframe;
 
-	interval = uvc_fraction_to_interval(timeperframe.numerator,
+	interval = v4l2_fraction_to_interval(timeperframe.numerator,
 		timeperframe.denominator);
 	uvc_dbg(stream->dev, FORMAT, "Setting frame interval to %u/%u (%u)\n",
 		timeperframe.numerator, timeperframe.denominator, interval);
@@ -473,7 +473,7 @@ static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 	/* Return the actual frame period. */
 	timeperframe.numerator = probe.dwFrameInterval;
 	timeperframe.denominator = 10000000;
-	uvc_simplify_fraction(&timeperframe.numerator,
+	v4l2_simplify_fraction(&timeperframe.numerator,
 		&timeperframe.denominator, 8, 333);
 
 	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -1293,7 +1293,7 @@ static int uvc_ioctl_enum_frameintervals(struct file *file, void *fh,
 		fival->discrete.numerator =
 			frame->dwFrameInterval[index];
 		fival->discrete.denominator = 10000000;
-		uvc_simplify_fraction(&fival->discrete.numerator,
+		v4l2_simplify_fraction(&fival->discrete.numerator,
 			&fival->discrete.denominator, 8, 333);
 	} else {
 		fival->type = V4L2_FRMIVAL_TYPE_STEPWISE;
@@ -1303,11 +1303,11 @@ static int uvc_ioctl_enum_frameintervals(struct file *file, void *fh,
 		fival->stepwise.max.denominator = 10000000;
 		fival->stepwise.step.numerator = frame->dwFrameInterval[2];
 		fival->stepwise.step.denominator = 10000000;
-		uvc_simplify_fraction(&fival->stepwise.min.numerator,
+		v4l2_simplify_fraction(&fival->stepwise.min.numerator,
 			&fival->stepwise.min.denominator, 8, 333);
-		uvc_simplify_fraction(&fival->stepwise.max.numerator,
+		v4l2_simplify_fraction(&fival->stepwise.max.numerator,
 			&fival->stepwise.max.denominator, 8, 333);
-		uvc_simplify_fraction(&fival->stepwise.step.numerator,
+		v4l2_simplify_fraction(&fival->stepwise.step.numerator,
 			&fival->stepwise.step.denominator, 8, 333);
 	}
 
diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
index 70b4e59bcfdb..b3a03c318f6a 100644
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@ -904,9 +904,6 @@ int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 		      struct uvc_xu_control_query *xqry);
 
 /* Utility functions */
-void uvc_simplify_fraction(u32 *numerator, u32 *denominator,
-			   unsigned int n_terms, unsigned int threshold);
-u32 uvc_fraction_to_interval(u32 numerator, u32 denominator);
 struct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,
 					    u8 epaddr);
 
* Unmerged path drivers/media/v4l2-core/v4l2-common.c
* Unmerged path include/media/v4l2-common.h
