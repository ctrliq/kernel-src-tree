media: uvcvideo: Add support for per-device control mapping overrides

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-494.el8
commit-author Ricardo Ribalda <ribalda@chromium.org>
commit 86f7ef77315687df144042762325c53d9a3a28c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-494.el8/86f7ef77.failed

Some devices do not implement all their controls in a way that complies
with the UVC specification. This is for instance the case for several
devices that do not support the disabled mode for the power line
frequency control. Add a mechanism to allow per-device control mapping
overrides to avoid errors when accessing non-compliant controls.

	Signed-off-by: Ricardo Ribalda <ribalda@chromium.org>
	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
(cherry picked from commit 86f7ef77315687df144042762325c53d9a3a28c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index 6b12dcdabf26,e4826a846861..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -2289,10 -2444,49 +2289,56 @@@ static void uvc_ctrl_init_ctrl(struct u
  	if (!ctrl->initialized)
  		return;
  
++<<<<<<< HEAD
 +	for (; mapping < mend; ++mapping) {
 +		if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
 +		    ctrl->info.selector == mapping->selector)
 +			__uvc_ctrl_add_mapping(dev, ctrl, mapping);
++=======
+ 	/*
+ 	 * First check if the device provides a custom mapping for this control,
+ 	 * used to override standard mappings for non-conformant devices. Don't
+ 	 * process standard mappings if a custom mapping is found. This
+ 	 * mechanism doesn't support combining standard and custom mappings for
+ 	 * a single control.
+ 	 */
+ 	if (chain->dev->info->mappings) {
+ 		bool custom = false;
+ 		unsigned int i;
+ 
+ 		for (i = 0; (mapping = chain->dev->info->mappings[i]); ++i) {
+ 			if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
+ 			    ctrl->info.selector == mapping->selector) {
+ 				__uvc_ctrl_add_mapping(chain, ctrl, mapping);
+ 				custom = true;
+ 			}
+ 		}
+ 
+ 		if (custom)
+ 			return;
+ 	}
+ 
+ 	/* Process common mappings next. */
+ 	for (; mapping < mend; ++mapping) {
+ 		if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
+ 		    ctrl->info.selector == mapping->selector)
+ 			__uvc_ctrl_add_mapping(chain, ctrl, mapping);
+ 	}
+ 
+ 	/* Finally process version-specific mappings. */
+ 	if (chain->dev->uvc_version < 0x0150) {
+ 		mapping = uvc_ctrl_mappings_uvc11;
+ 		mend = mapping + ARRAY_SIZE(uvc_ctrl_mappings_uvc11);
+ 	} else {
+ 		mapping = uvc_ctrl_mappings_uvc15;
+ 		mend = mapping + ARRAY_SIZE(uvc_ctrl_mappings_uvc15);
+ 	}
+ 
+ 	for (; mapping < mend; ++mapping) {
+ 		if (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&
+ 		    ctrl->info.selector == mapping->selector)
+ 			__uvc_ctrl_add_mapping(chain, ctrl, mapping);
++>>>>>>> 86f7ef773156 (media: uvcvideo: Add support for per-device control mapping overrides)
  	}
  }
  
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
index 70b4e59bcfdb..4f13d5051a6d 100644
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@ -663,6 +663,7 @@ struct uvc_device_info {
 	u32	quirks;
 	u32	meta_format;
 	u16	uvc_version;
+	const struct uvc_control_mapping **mappings;
 };
 
 struct uvc_device {
