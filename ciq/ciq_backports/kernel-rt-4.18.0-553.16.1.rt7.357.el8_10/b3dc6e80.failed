ipvlan: Dont Use skb->sk in ipvlan_process_v{4,6}_outbound

jira LE-1907
cve {CVE-2024-33621
cve [RHEL-44396]
cve Liu)
cve (Hangbin
cve 4,6_outbound
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.16.1.rt7.357.el8_10
commit-author Yue Haibing <yuehaibing@huawei.com>
commit b3dc6e8003b500861fa307e9a3400c52e78e4d3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.16.1.rt7.357.el8_10/b3dc6e80.failed

Raw packet from PF_PACKET socket ontop of an IPv6-backed ipvlan device will
hit WARN_ON_ONCE() in sk_mc_loop() through sch_direct_xmit() path.

WARNING: CPU: 2 PID: 0 at net/core/sock.c:775 sk_mc_loop+0x2d/0x70
Modules linked in: sch_netem ipvlan rfkill cirrus drm_shmem_helper sg drm_kms_helper
CPU: 2 PID: 0 Comm: swapper/2 Kdump: loaded Not tainted 6.9.0+ #279
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
RIP: 0010:sk_mc_loop+0x2d/0x70
Code: fa 0f 1f 44 00 00 65 0f b7 15 f7 96 a3 4f 31 c0 66 85 d2 75 26 48 85 ff 74 1c
RSP: 0018:ffffa9584015cd78 EFLAGS: 00010212
RAX: 0000000000000011 RBX: ffff91e585793e00 RCX: 0000000002c6a001
RDX: 0000000000000000 RSI: 0000000000000040 RDI: ffff91e589c0f000
RBP: ffff91e5855bd100 R08: 0000000000000000 R09: 3d00545216f43d00
R10: ffff91e584fdcc50 R11: 00000060dd8616f4 R12: ffff91e58132d000
R13: ffff91e584fdcc68 R14: ffff91e5869ce800 R15: ffff91e589c0f000
FS:  0000000000000000(0000) GS:ffff91e898100000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f788f7c44c0 CR3: 0000000008e1a000 CR4: 00000000000006f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<IRQ>
 ? __warn (kernel/panic.c:693)
 ? sk_mc_loop (net/core/sock.c:760)
 ? report_bug (lib/bug.c:201 lib/bug.c:219)
 ? handle_bug (arch/x86/kernel/traps.c:239)
 ? exc_invalid_op (arch/x86/kernel/traps.c:260 (discriminator 1))
 ? asm_exc_invalid_op (./arch/x86/include/asm/idtentry.h:621)
 ? sk_mc_loop (net/core/sock.c:760)
 ip6_finish_output2 (net/ipv6/ip6_output.c:83 (discriminator 1))
 ? nf_hook_slow (net/netfilter/core.c:626)
 ip6_finish_output (net/ipv6/ip6_output.c:222)
 ? __pfx_ip6_finish_output (net/ipv6/ip6_output.c:215)
 ipvlan_xmit_mode_l3 (drivers/net/ipvlan/ipvlan_core.c:602) ipvlan
 ipvlan_start_xmit (drivers/net/ipvlan/ipvlan_main.c:226) ipvlan
 dev_hard_start_xmit (net/core/dev.c:3594)
 sch_direct_xmit (net/sched/sch_generic.c:343)
 __qdisc_run (net/sched/sch_generic.c:416)
 net_tx_action (net/core/dev.c:5286)
 handle_softirqs (kernel/softirq.c:555)
 __irq_exit_rcu (kernel/softirq.c:589)
 sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1043)

The warning triggers as this:
packet_sendmsg
   packet_snd //skb->sk is packet sk
      __dev_queue_xmit
         __dev_xmit_skb //q->enqueue is not NULL
             __qdisc_run
               sch_direct_xmit
                 dev_hard_start_xmit
                   ipvlan_start_xmit
                      ipvlan_xmit_mode_l3 //l3 mode
                        ipvlan_process_outbound //vepa flag
                          ipvlan_process_v6_outbound
                            ip6_local_out
                                __ip6_finish_output
                                  ip6_finish_output2 //multicast packet
                                    sk_mc_loop //sk->sk_family is AF_PACKET

Call ip{6}_local_out() with NULL sk in ipvlan as other tunnels to fix this.

Fixes: 2ad7bf363841 ("ipvlan: Initial check-in of the IPVLAN driver.")
	Suggested-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Yue Haibing <yuehaibing@huawei.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/20240529095633.613103-1-yuehaibing@huawei.com
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit b3dc6e8003b500861fa307e9a3400c52e78e4d3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ipvlan/ipvlan_core.c
diff --cc drivers/net/ipvlan/ipvlan_core.c
index 4acee967f244,fef4eff7753a..000000000000
--- a/drivers/net/ipvlan/ipvlan_core.c
+++ b/drivers/net/ipvlan/ipvlan_core.c
@@@ -446,9 -439,9 +446,9 @@@ static int ipvlan_process_v4_outbound(s
  
  	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
  
- 	err = ip_local_out(net, skb->sk, skb);
+ 	err = ip_local_out(net, NULL, skb);
  	if (unlikely(net_xmit_eval(err)))
 -		DEV_STATS_INC(dev, tx_errors);
 +		dev->stats.tx_errors++;
  	else
  		ret = NET_XMIT_SUCCESS;
  	goto out;
@@@ -487,16 -480,25 +487,20 @@@ static int ipvlan_process_v6_outbound(s
  
  	memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
  
++<<<<<<< HEAD
 +	err = ip6_local_out(net, skb->sk, skb);
++=======
+ 	err = ip6_local_out(dev_net(dev), NULL, skb);
++>>>>>>> b3dc6e8003b5 (ipvlan: Dont Use skb->sk in ipvlan_process_v{4,6}_outbound)
  	if (unlikely(net_xmit_eval(err)))
 -		DEV_STATS_INC(dev, tx_errors);
 +		dev->stats.tx_errors++;
  	else
  		ret = NET_XMIT_SUCCESS;
 +	goto out;
 +err:
 +	dev->stats.tx_errors++;
 +	kfree_skb(skb);
 +out:
  	return ret;
  }
  #else
* Unmerged path drivers/net/ipvlan/ipvlan_core.c
