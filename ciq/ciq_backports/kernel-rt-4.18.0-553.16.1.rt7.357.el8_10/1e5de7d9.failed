perf record: Stop threads in the end of trace streaming

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.16.1.rt7.357.el8_10
commit-author Alexey Bayduraev <alexey.v.bayduraev@linux.intel.com>
commit 1e5de7d9c6ded0722736eb6e58c72b18937efc06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.16.1.rt7.357.el8_10/1e5de7d9.failed

Signal thread to terminate by closing write fd of msg pipe.
Receive THREAD_MSG__READY message as the confirmation of the
thread's termination. Stop threads created for parallel trace
streaming prior their stats processing.

	Reviewed-by: Riccardo Mancini <rickyman7@gmail.com>
	Signed-off-by: Alexey Bayduraev <alexey.v.bayduraev@linux.intel.com>
	Tested-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Riccardo Mancini <rickyman7@gmail.com>
	Acked-by: Andi Kleen <ak@linux.intel.com>
	Acked-by: Namhyung Kim <namhyung@gmail.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexander Antonov <alexander.antonov@linux.intel.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexei Budankov <abudankov@huawei.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: https://lore.kernel.org/r/55ef8cc5ec3a96360660d9dc1763573225325f8c.1642440724.git.alexey.v.bayduraev@linux.intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 1e5de7d9c6ded0722736eb6e58c72b18937efc06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
diff --cc tools/perf/builtin-record.c
index a12318efae5a,0e65b80927b7..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -87,6 -90,40 +87,43 @@@ struct switch_output 
  	int		 cur_file;
  };
  
++<<<<<<< HEAD
++=======
+ struct thread_mask {
+ 	struct mmap_cpu_mask	maps;
+ 	struct mmap_cpu_mask	affinity;
+ };
+ 
+ struct record_thread {
+ 	pid_t			tid;
+ 	struct thread_mask	*mask;
+ 	struct {
+ 		int		msg[2];
+ 		int		ack[2];
+ 	} pipes;
+ 	struct fdarray		pollfd;
+ 	int			ctlfd_pos;
+ 	int			nr_mmaps;
+ 	struct mmap		**maps;
+ 	struct mmap		**overwrite_maps;
+ 	struct record		*rec;
+ 	unsigned long long	samples;
+ 	unsigned long		waking;
+ };
+ 
+ static __thread struct record_thread *thread;
+ 
+ enum thread_msg {
+ 	THREAD_MSG__UNDEFINED = 0,
+ 	THREAD_MSG__READY,
+ 	THREAD_MSG__MAX,
+ };
+ 
+ static const char *thread_msg_tags[THREAD_MSG__MAX] = {
+ 	"UNDEFINED", "READY"
+ };
+ 
++>>>>>>> 1e5de7d9c6de (perf record: Stop threads in the end of trace streaming)
  struct record {
  	struct perf_tool	tool;
  	struct record_opts	opts;
@@@ -1638,6 -1896,61 +1675,64 @@@ static void record__uniquify_name(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int record__terminate_thread(struct record_thread *thread_data)
+ {
+ 	int err;
+ 	enum thread_msg ack = THREAD_MSG__UNDEFINED;
+ 	pid_t tid = thread_data->tid;
+ 
+ 	close(thread_data->pipes.msg[1]);
+ 	thread_data->pipes.msg[1] = -1;
+ 	err = read(thread_data->pipes.ack[0], &ack, sizeof(ack));
+ 	if (err > 0)
+ 		pr_debug2("threads[%d]: sent %s\n", tid, thread_msg_tags[ack]);
+ 	else
+ 		pr_warning("threads[%d]: failed to receive termination notification from %d\n",
+ 			   thread->tid, tid);
+ 
+ 	return 0;
+ }
+ 
+ static int record__start_threads(struct record *rec)
+ {
+ 	struct record_thread *thread_data = rec->thread_data;
+ 
+ 	thread = &thread_data[0];
+ 
+ 	pr_debug("threads[%d]: started on cpu%d\n", thread->tid, sched_getcpu());
+ 
+ 	return 0;
+ }
+ 
+ static int record__stop_threads(struct record *rec)
+ {
+ 	int t;
+ 	struct record_thread *thread_data = rec->thread_data;
+ 
+ 	for (t = 1; t < rec->nr_threads; t++)
+ 		record__terminate_thread(&thread_data[t]);
+ 
+ 	for (t = 0; t < rec->nr_threads; t++)
+ 		rec->samples += thread_data[t].samples;
+ 
+ 	return 0;
+ }
+ 
+ static unsigned long record__waking(struct record *rec)
+ {
+ 	int t;
+ 	unsigned long waking = 0;
+ 	struct record_thread *thread_data = rec->thread_data;
+ 
+ 	for (t = 0; t < rec->nr_threads; t++)
+ 		waking += thread_data[t].waking;
+ 
+ 	return waking;
+ }
+ 
++>>>>>>> 1e5de7d9c6de (perf record: Stop threads in the end of trace streaming)
  static int __cmd_record(struct record *rec, int argc, const char **argv)
  {
  	int err;
* Unmerged path tools/perf/builtin-record.c
