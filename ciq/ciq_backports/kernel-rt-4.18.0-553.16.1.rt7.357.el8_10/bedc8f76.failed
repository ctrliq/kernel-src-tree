cifs: always initialize struct msghdr smb_msg completely

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.16.1.rt7.357.el8_10
commit-author Stefan Metzmacher <metze@samba.org>
commit bedc8f76b3539ac4f952114b316bcc2251e808ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.16.1.rt7.357.el8_10/bedc8f76.failed

So far we were just lucky because the uninitialized members
of struct msghdr are not used by default on a SOCK_STREAM tcp
socket.

But as new things like msg_ubuf and sg_from_iter where added
recently, we should play on the safe side and avoid potention
problems in future.

	Signed-off-by: Stefan Metzmacher <metze@samba.org>
	Cc: stable@vger.kernel.org
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit bedc8f76b3539ac4f952114b316bcc2251e808ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/transport.c
diff --cc fs/cifs/transport.c
index d46e2f1740ea,9a2753e21170..000000000000
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@@ -326,8 -305,7 +322,12 @@@ __smb_send_rqst(struct TCP_Server_Info 
  	sigset_t mask, oldmask;
  	size_t total_len = 0, sent, size;
  	struct socket *ssocket = server->ssocket;
++<<<<<<< HEAD
 +	struct msghdr smb_msg;
 +	int val = 1;
++=======
+ 	struct msghdr smb_msg = {};
++>>>>>>> bedc8f76b353 (cifs: always initialize struct msghdr smb_msg completely)
  	__be32 rfc1002_marker;
  
  	if (cifs_rdma_enabled(server)) {
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 6e27e4672066..cdc2d8a266ad 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -530,9 +530,6 @@ cifs_readv_from_socket(struct TCP_Server_Info *server, struct msghdr *smb_msg)
 	int length = 0;
 	int total_read;
 
-	smb_msg->msg_control = NULL;
-	smb_msg->msg_controllen = 0;
-
 	for (total_read = 0; msg_data_left(smb_msg); total_read += length) {
 		try_to_freeze();
 
@@ -583,7 +580,7 @@ int
 cifs_read_from_socket(struct TCP_Server_Info *server, char *buf,
 		      unsigned int to_read)
 {
-	struct msghdr smb_msg;
+	struct msghdr smb_msg = {};
 	struct kvec iov = {.iov_base = buf, .iov_len = to_read};
 	iov_iter_kvec(&smb_msg.msg_iter, READ, &iov, 1, to_read);
 
@@ -593,15 +590,13 @@ cifs_read_from_socket(struct TCP_Server_Info *server, char *buf,
 ssize_t
 cifs_discard_from_socket(struct TCP_Server_Info *server, size_t to_read)
 {
-	struct msghdr smb_msg;
+	struct msghdr smb_msg = {};
 
 	/*
 	 *  iov_iter_discard already sets smb_msg.type and count and iov_offset
 	 *  and cifs_readv_from_socket sets msg_control and msg_controllen
 	 *  so little to initialize in struct msghdr
 	 */
-	smb_msg.msg_name = NULL;
-	smb_msg.msg_namelen = 0;
 	iov_iter_discard(&smb_msg.msg_iter, READ, to_read);
 
 	return cifs_readv_from_socket(server, &smb_msg);
@@ -611,7 +606,7 @@ int
 cifs_read_page_from_socket(struct TCP_Server_Info *server, struct page *page,
 	unsigned int page_offset, unsigned int to_read)
 {
-	struct msghdr smb_msg;
+	struct msghdr smb_msg = {};
 	struct bio_vec bv = {
 		.bv_page = page, .bv_len = to_read, .bv_offset = page_offset};
 	iov_iter_bvec(&smb_msg.msg_iter, READ, &bv, 1, to_read);
* Unmerged path fs/cifs/transport.c
