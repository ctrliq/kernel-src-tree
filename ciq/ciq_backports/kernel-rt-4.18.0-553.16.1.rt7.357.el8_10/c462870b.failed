cifs: Move SMB2_Create definitions to the shared area

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.16.1.rt7.357.el8_10
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit c462870bf8547d9cefa2e89abd0f78599c9786fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.16.1.rt7.357.el8_10/c462870b.failed

Move all SMB2_Create definitions (except contexts) into the shared area.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Reviewed-by: Namjae Jeon <linkinjeon@kernel.org>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit c462870bf8547d9cefa2e89abd0f78599c9786fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2misc.c
#	fs/cifs/smb2pdu.h
#	fs/smbfs_common/smb2pdu.h
diff --cc fs/cifs/smb2misc.c
index f3aaa2e43ec2,cdcdef32759e..000000000000
--- a/fs/cifs/smb2misc.c
+++ b/fs/cifs/smb2misc.c
@@@ -842,10 -830,10 +842,17 @@@ smb2_handle_cancelled_mid(struct mid_q_
  		return -ENOENT;
  
  	rc = __smb2_handle_cancelled_cmd(tcon,
++<<<<<<< HEAD
 +					 le16_to_cpu(sync_hdr->Command),
 +					 le64_to_cpu(sync_hdr->MessageId),
 +					 rsp->PersistentFileId,
 +					 rsp->VolatileFileId);
++=======
+ 					 le16_to_cpu(hdr->Command),
+ 					 le64_to_cpu(hdr->MessageId),
+ 					 le64_to_cpu(rsp->PersistentFileId),
+ 					 le64_to_cpu(rsp->VolatileFileId));
++>>>>>>> c462870bf854 (cifs: Move SMB2_Create definitions to the shared area)
  	if (rc)
  		cifs_put_tcon(tcon);
  
diff --cc fs/cifs/smb2pdu.h
index 72185c3566c9,33cfd0a1adf1..000000000000
--- a/fs/cifs/smb2pdu.h
+++ b/fs/cifs/smb2pdu.h
@@@ -271,504 -115,6 +271,507 @@@ struct share_redirect_error_context_rs
  	/* __u8 ResourceName[] */ /* Name of share as counted Unicode string */
  } __packed;
  
++<<<<<<< HEAD
 +#define SMB2_CLIENT_GUID_SIZE 16
 +
 +struct smb2_negotiate_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 36 */
 +	__le16 DialectCount;
 +	__le16 SecurityMode;
 +	__le16 Reserved;	/* MBZ */
 +	__le32 Capabilities;
 +	__u8   ClientGUID[SMB2_CLIENT_GUID_SIZE];
 +	/* In SMB3.02 and earlier next three were MBZ le64 ClientStartTime */
 +	__le32 NegotiateContextOffset; /* SMB3.1.1 only. MBZ earlier */
 +	__le16 NegotiateContextCount;  /* SMB3.1.1 only. MBZ earlier */
 +	__le16 Reserved2;
 +	__le16 Dialects[4]; /* BB expand this if autonegotiate > 4 dialects */
 +} __packed;
 +
 +/* Dialects */
 +#define SMB10_PROT_ID 0x0000 /* local only, not sent on wire w/CIFS negprot */
 +#define SMB20_PROT_ID 0x0202
 +#define SMB21_PROT_ID 0x0210
 +#define SMB30_PROT_ID 0x0300
 +#define SMB302_PROT_ID 0x0302
 +#define SMB311_PROT_ID 0x0311
 +#define BAD_PROT_ID   0xFFFF
 +
 +/* SecurityMode flags */
 +#define	SMB2_NEGOTIATE_SIGNING_ENABLED	0x0001
 +#define SMB2_NEGOTIATE_SIGNING_REQUIRED	0x0002
 +#define SMB2_SEC_MODE_FLAGS_ALL		0x0003
 +
 +/* Capabilities flags */
 +#define SMB2_GLOBAL_CAP_DFS		0x00000001
 +#define SMB2_GLOBAL_CAP_LEASING		0x00000002 /* Resp only New to SMB2.1 */
 +#define SMB2_GLOBAL_CAP_LARGE_MTU	0X00000004 /* Resp only New to SMB2.1 */
 +#define SMB2_GLOBAL_CAP_MULTI_CHANNEL	0x00000008 /* New to SMB3 */
 +#define SMB2_GLOBAL_CAP_PERSISTENT_HANDLES 0x00000010 /* New to SMB3 */
 +#define SMB2_GLOBAL_CAP_DIRECTORY_LEASING  0x00000020 /* New to SMB3 */
 +#define SMB2_GLOBAL_CAP_ENCRYPTION	0x00000040 /* New to SMB3 */
 +/* Internal types */
 +#define SMB2_NT_FIND			0x00100000
 +#define SMB2_LARGE_FILES		0x00200000
 +
 +
 +/* Negotiate Contexts - ContextTypes. See MS-SMB2 section 2.2.3.1 for details */
 +#define SMB2_PREAUTH_INTEGRITY_CAPABILITIES	cpu_to_le16(1)
 +#define SMB2_ENCRYPTION_CAPABILITIES		cpu_to_le16(2)
 +#define SMB2_COMPRESSION_CAPABILITIES		cpu_to_le16(3)
 +#define SMB2_NETNAME_NEGOTIATE_CONTEXT_ID	cpu_to_le16(5)
 +#define SMB2_TRANSPORT_CAPABILITIES		cpu_to_le16(6)
 +#define SMB2_RDMA_TRANSFORM_CAPABILITIES	cpu_to_le16(7)
 +#define SMB2_SIGNING_CAPABILITIES		cpu_to_le16(8)
 +#define SMB2_POSIX_EXTENSIONS_AVAILABLE		cpu_to_le16(0x100)
 +
 +struct smb2_neg_context {
 +	__le16	ContextType;
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	/* Followed by array of data */
 +} __packed;
 +
 +#define SMB311_LINUX_CLIENT_SALT_SIZE			32
 +/* Hash Algorithm Types */
 +#define SMB2_PREAUTH_INTEGRITY_SHA512	cpu_to_le16(0x0001)
 +#define SMB2_PREAUTH_HASH_SIZE 64
 +
 +/*
 + * SaltLength that the server send can be zero, so the only three required
 + * fields (all __le16) end up six bytes total, so the minimum context data len
 + * in the response is six bytes which accounts for
 + *
 + *      HashAlgorithmCount, SaltLength, and 1 HashAlgorithm.
 + */
 +#define MIN_PREAUTH_CTXT_DATA_LEN 6
 +
 +struct smb2_preauth_neg_context {
 +	__le16	ContextType; /* 1 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	__le16	HashAlgorithmCount; /* 1 */
 +	__le16	SaltLength;
 +	__le16	HashAlgorithms; /* HashAlgorithms[0] since only one defined */
 +	__u8	Salt[SMB311_LINUX_CLIENT_SALT_SIZE];
 +} __packed;
 +
 +/* Encryption Algorithms Ciphers */
 +#define SMB2_ENCRYPTION_AES128_CCM	cpu_to_le16(0x0001)
 +#define SMB2_ENCRYPTION_AES128_GCM	cpu_to_le16(0x0002)
 +/* we currently do not request AES256_CCM since presumably GCM faster */
 +#define SMB2_ENCRYPTION_AES256_CCM      cpu_to_le16(0x0003)
 +#define SMB2_ENCRYPTION_AES256_GCM      cpu_to_le16(0x0004)
 +
 +/* Min encrypt context data is one cipher so 2 bytes + 2 byte count field */
 +#define MIN_ENCRYPT_CTXT_DATA_LEN	4
 +struct smb2_encryption_neg_context {
 +	__le16	ContextType; /* 2 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	/* CipherCount usally 2, but can be 3 when AES256-GCM enabled */
 +	__le16	CipherCount; /* AES128-GCM and AES128-CCM by default */
 +	__le16	Ciphers[3];
 +} __packed;
 +
 +/* See MS-SMB2 2.2.3.1.3 */
 +#define SMB3_COMPRESS_NONE	cpu_to_le16(0x0000)
 +#define SMB3_COMPRESS_LZNT1	cpu_to_le16(0x0001)
 +#define SMB3_COMPRESS_LZ77	cpu_to_le16(0x0002)
 +#define SMB3_COMPRESS_LZ77_HUFF	cpu_to_le16(0x0003)
 +/* Pattern scanning algorithm See MS-SMB2 3.1.4.4.1 */
 +#define SMB3_COMPRESS_PATTERN	cpu_to_le16(0x0004) /* Pattern_V1 */
 +
 +/* Compression Flags */
 +#define SMB2_COMPRESSION_CAPABILITIES_FLAG_NONE		cpu_to_le32(0x00000000)
 +#define SMB2_COMPRESSION_CAPABILITIES_FLAG_CHAINED	cpu_to_le32(0x00000001)
 +
 +struct smb2_compression_capabilities_context {
 +	__le16	ContextType; /* 3 */
 +	__le16  DataLength;
 +	__u32	Reserved;
 +	__le16	CompressionAlgorithmCount;
 +	__u16	Padding;
 +	__u32	Flags;
 +	__le16	CompressionAlgorithms[3];
 +} __packed;
 +
 +/*
 + * For smb2_netname_negotiate_context_id See MS-SMB2 2.2.3.1.4.
 + * Its struct simply contains NetName, an array of Unicode characters
 + */
 +struct smb2_netname_neg_context {
 +	__le16	ContextType; /* 5 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	__le16	NetName[]; /* hostname of target converted to UCS-2 */
 +} __packed;
 +
 +/*
 + * For rdma transform capabilities context see MS-SMB2 2.2.3.1.6
 + * and 2.2.4.1.5
 + */
 +
 +/* RDMA Transform IDs */
 +#define SMB2_RDMA_TRANSFORM_NONE	0x0000
 +#define SMB2_RDMA_TRANSFORM_ENCRYPTION	0x0001
 +
 +struct smb2_rdma_transform_capabilities_context {
 +	__le16	ContextType; /* 7 */
 +	__le16  DataLength;
 +	__u32	Reserved;
 +	__le16	TransformCount;
 +	__u16	Reserved1;
 +	__u32	Reserved2;
 +	__le16	RDMATransformIds[1];
 +} __packed;
 +
 +/* Signing algorithms */
 +#define SIGNING_ALG_HMAC_SHA256	0
 +#define SIGNING_ALG_AES_CMAC	1
 +#define SIGNING_ALG_AES_GMAC	2
 +
 +struct smb2_signing_capabilities {
 +	__le16	ContextType; /* 8 */
 +	__le16	DataLength;
 +	__u32	Reserved;
 +	__le16	SigningAlgorithmCount;
 +	__le16	SigningAlgorithms[];
 +} __packed;
 +
 +#define POSIX_CTXT_DATA_LEN	16
 +struct smb2_posix_neg_context {
 +	__le16	ContextType; /* 0x100 */
 +	__le16	DataLength;
 +	__le32	Reserved;
 +	__u8	Name[16]; /* POSIX ctxt GUID 93AD25509CB411E7B42383DE968BCD7C */
 +} __packed;
 +
 +struct smb2_negotiate_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 65 */
 +	__le16 SecurityMode;
 +	__le16 DialectRevision;
 +	__le16 NegotiateContextCount;	/* Prior to SMB3.1.1 was Reserved & MBZ */
 +	__u8   ServerGUID[16];
 +	__le32 Capabilities;
 +	__le32 MaxTransactSize;
 +	__le32 MaxReadSize;
 +	__le32 MaxWriteSize;
 +	__le64 SystemTime;	/* MBZ */
 +	__le64 ServerStartTime;
 +	__le16 SecurityBufferOffset;
 +	__le16 SecurityBufferLength;
 +	__le32 NegotiateContextOffset;	/* Pre:SMB3.1.1 was reserved/ignored */
 +	__u8   Buffer[];	/* variable length GSS security buffer */
 +} __packed;
 +
 +/* Flags */
 +#define SMB2_SESSION_REQ_FLAG_BINDING		0x01
 +#define SMB2_SESSION_REQ_FLAG_ENCRYPT_DATA	0x04
 +
 +struct smb2_sess_setup_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 25 */
 +	__u8   Flags;
 +	__u8   SecurityMode;
 +	__le32 Capabilities;
 +	__le32 Channel;
 +	__le16 SecurityBufferOffset;
 +	__le16 SecurityBufferLength;
 +	__u64 PreviousSessionId;
 +	__u8   Buffer[];	/* variable length GSS security buffer */
 +} __packed;
 +
 +/* Currently defined SessionFlags */
 +#define SMB2_SESSION_FLAG_IS_GUEST	0x0001
 +#define SMB2_SESSION_FLAG_IS_NULL	0x0002
 +#define SMB2_SESSION_FLAG_ENCRYPT_DATA	0x0004
 +struct smb2_sess_setup_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize; /* Must be 9 */
 +	__le16 SessionFlags;
 +	__le16 SecurityBufferOffset;
 +	__le16 SecurityBufferLength;
 +	__u8   Buffer[];	/* variable length GSS security buffer */
 +} __packed;
 +
 +struct smb2_logoff_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +struct smb2_logoff_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +/* Flags/Reserved for SMB3.1.1 */
 +#define SMB2_TREE_CONNECT_FLAG_CLUSTER_RECONNECT cpu_to_le16(0x0001)
 +#define SMB2_TREE_CONNECT_FLAG_REDIRECT_TO_OWNER cpu_to_le16(0x0002)
 +#define SMB2_TREE_CONNECT_FLAG_EXTENSION_PRESENT cpu_to_le16(0x0004)
 +
 +struct smb2_tree_connect_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 9 */
 +	__le16 Flags; /* Reserved MBZ for dialects prior to SMB3.1.1 */
 +	__le16 PathOffset;
 +	__le16 PathLength;
 +	__u8   Buffer[];	/* variable length */
 +} __packed;
 +
 +/* See MS-SMB2 section 2.2.9.2 */
 +/* Context Types */
 +#define SMB2_RESERVED_TREE_CONNECT_CONTEXT_ID 0x0000
 +#define SMB2_REMOTED_IDENTITY_TREE_CONNECT_CONTEXT_ID cpu_to_le16(0x0001)
 +
 +struct tree_connect_contexts {
 +	__le16 ContextType;
 +	__le16 DataLength;
 +	__le32 Reserved;
 +	__u8   Data[];
 +} __packed;
 +
 +/* Remoted identity tree connect context structures - see MS-SMB2 2.2.9.2.1 */
 +struct smb3_blob_data {
 +	__le16 BlobSize;
 +	__u8   BlobData[];
 +} __packed;
 +
 +/* Valid values for Attr */
 +#define SE_GROUP_MANDATORY		0x00000001
 +#define SE_GROUP_ENABLED_BY_DEFAULT	0x00000002
 +#define SE_GROUP_ENABLED		0x00000004
 +#define SE_GROUP_OWNER			0x00000008
 +#define SE_GROUP_USE_FOR_DENY_ONLY	0x00000010
 +#define SE_GROUP_INTEGRITY		0x00000020
 +#define SE_GROUP_INTEGRITY_ENABLED	0x00000040
 +#define SE_GROUP_RESOURCE		0x20000000
 +#define SE_GROUP_LOGON_ID		0xC0000000
 +
 +/* struct sid_attr_data is SidData array in BlobData format then le32 Attr */
 +
 +struct sid_array_data {
 +	__le16 SidAttrCount;
 +	/* SidAttrList - array of sid_attr_data structs */
 +} __packed;
 +
 +struct luid_attr_data {
 +
 +} __packed;
 +
 +/*
 + * struct privilege_data is the same as BLOB_DATA - see MS-SMB2 2.2.9.2.1.5
 + * but with size of LUID_ATTR_DATA struct and BlobData set to LUID_ATTR DATA
 + */
 +
 +struct privilege_array_data {
 +	__le16 PrivilegeCount;
 +	/* array of privilege_data structs */
 +} __packed;
 +
 +struct remoted_identity_tcon_context {
 +	__le16 TicketType; /* must be 0x0001 */
 +	__le16 TicketSize; /* total size of this struct */
 +	__le16 User; /* offset to SID_ATTR_DATA struct with user info */
 +	__le16 UserName; /* offset to null terminated Unicode username string */
 +	__le16 Domain; /* offset to null terminated Unicode domain name */
 +	__le16 Groups; /* offset to SID_ARRAY_DATA struct with group info */
 +	__le16 RestrictedGroups; /* similar to above */
 +	__le16 Privileges; /* offset to PRIVILEGE_ARRAY_DATA struct */
 +	__le16 PrimaryGroup; /* offset to SID_ARRAY_DATA struct */
 +	__le16 Owner; /* offset to BLOB_DATA struct */
 +	__le16 DefaultDacl; /* offset to BLOB_DATA struct */
 +	__le16 DeviceGroups; /* offset to SID_ARRAY_DATA struct */
 +	__le16 UserClaims; /* offset to BLOB_DATA struct */
 +	__le16 DeviceClaims; /* offset to BLOB_DATA struct */
 +	__u8   TicketInfo[]; /* variable length buf - remoted identity data */
 +} __packed;
 +
 +struct smb2_tree_connect_req_extension {
 +	__le32 TreeConnectContextOffset;
 +	__le16 TreeConnectContextCount;
 +	__u8  Reserved[10];
 +	__u8  PathName[]; /* variable sized array */
 +	/* followed by array of TreeConnectContexts */
 +} __packed;
 +
 +struct smb2_tree_connect_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 16 */
 +	__u8   ShareType;  /* see below */
 +	__u8   Reserved;
 +	__le32 ShareFlags; /* see below */
 +	__le32 Capabilities; /* see below */
 +	__le32 MaximalAccess;
 +} __packed;
 +
 +/* Possible ShareType values */
 +#define SMB2_SHARE_TYPE_DISK	0x01
 +#define SMB2_SHARE_TYPE_PIPE	0x02
 +#define	SMB2_SHARE_TYPE_PRINT	0x03
 +
 +/*
 + * Possible ShareFlags - exactly one and only one of the first 4 caching flags
 + * must be set (any of the remaining, SHI1005, flags may be set individually
 + * or in combination.
 + */
 +#define SMB2_SHAREFLAG_MANUAL_CACHING			0x00000000
 +#define SMB2_SHAREFLAG_AUTO_CACHING			0x00000010
 +#define SMB2_SHAREFLAG_VDO_CACHING			0x00000020
 +#define SMB2_SHAREFLAG_NO_CACHING			0x00000030
 +#define SHI1005_FLAGS_DFS				0x00000001
 +#define SHI1005_FLAGS_DFS_ROOT				0x00000002
 +#define SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS		0x00000100
 +#define SHI1005_FLAGS_FORCE_SHARED_DELETE		0x00000200
 +#define SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING		0x00000400
 +#define SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM	0x00000800
 +#define SHI1005_FLAGS_FORCE_LEVELII_OPLOCK		0x00001000
 +#define SHI1005_FLAGS_ENABLE_HASH_V1			0x00002000
 +#define SHI1005_FLAGS_ENABLE_HASH_V2			0x00004000
 +#define SHI1005_FLAGS_ENCRYPT_DATA			0x00008000
 +#define SMB2_SHAREFLAG_IDENTITY_REMOTING		0x00040000 /* 3.1.1 */
 +#define SHI1005_FLAGS_ALL				0x0004FF33
 +
 +/* Possible share capabilities */
 +#define SMB2_SHARE_CAP_DFS	cpu_to_le32(0x00000008) /* all dialects */
 +#define SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY cpu_to_le32(0x00000010) /* 3.0 */
 +#define SMB2_SHARE_CAP_SCALEOUT	cpu_to_le32(0x00000020) /* 3.0 */
 +#define SMB2_SHARE_CAP_CLUSTER	cpu_to_le32(0x00000040) /* 3.0 */
 +#define SMB2_SHARE_CAP_ASYMMETRIC cpu_to_le32(0x00000080) /* 3.02 */
 +#define SMB2_SHARE_CAP_REDIRECT_TO_OWNER cpu_to_le32(0x00000100) /* 3.1.1 */
 +
 +struct smb2_tree_disconnect_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +struct smb2_tree_disconnect_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 4 */
 +	__le16 Reserved;
 +} __packed;
 +
 +/* File Attrubutes */
 +#define FILE_ATTRIBUTE_READONLY			0x00000001
 +#define FILE_ATTRIBUTE_HIDDEN			0x00000002
 +#define FILE_ATTRIBUTE_SYSTEM			0x00000004
 +#define FILE_ATTRIBUTE_DIRECTORY		0x00000010
 +#define FILE_ATTRIBUTE_ARCHIVE			0x00000020
 +#define FILE_ATTRIBUTE_NORMAL			0x00000080
 +#define FILE_ATTRIBUTE_TEMPORARY		0x00000100
 +#define FILE_ATTRIBUTE_SPARSE_FILE		0x00000200
 +#define FILE_ATTRIBUTE_REPARSE_POINT		0x00000400
 +#define FILE_ATTRIBUTE_COMPRESSED		0x00000800
 +#define FILE_ATTRIBUTE_OFFLINE			0x00001000
 +#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED	0x00002000
 +#define FILE_ATTRIBUTE_ENCRYPTED		0x00004000
 +#define FILE_ATTRIBUTE_INTEGRITY_STREAM		0x00008000
 +#define FILE_ATTRIBUTE_NO_SCRUB_DATA		0x00020000
 +
 +/* Oplock levels */
 +#define SMB2_OPLOCK_LEVEL_NONE		0x00
 +#define SMB2_OPLOCK_LEVEL_II		0x01
 +#define SMB2_OPLOCK_LEVEL_EXCLUSIVE	0x08
 +#define SMB2_OPLOCK_LEVEL_BATCH		0x09
 +#define SMB2_OPLOCK_LEVEL_LEASE		0xFF
 +/* Non-spec internal type */
 +#define SMB2_OPLOCK_LEVEL_NOCHANGE	0x99
 +
 +/* Desired Access Flags */
 +#define FILE_READ_DATA_LE		cpu_to_le32(0x00000001)
 +#define FILE_WRITE_DATA_LE		cpu_to_le32(0x00000002)
 +#define FILE_APPEND_DATA_LE		cpu_to_le32(0x00000004)
 +#define FILE_READ_EA_LE			cpu_to_le32(0x00000008)
 +#define FILE_WRITE_EA_LE		cpu_to_le32(0x00000010)
 +#define FILE_EXECUTE_LE			cpu_to_le32(0x00000020)
 +#define FILE_READ_ATTRIBUTES_LE		cpu_to_le32(0x00000080)
 +#define FILE_WRITE_ATTRIBUTES_LE	cpu_to_le32(0x00000100)
 +#define FILE_DELETE_LE			cpu_to_le32(0x00010000)
 +#define FILE_READ_CONTROL_LE		cpu_to_le32(0x00020000)
 +#define FILE_WRITE_DAC_LE		cpu_to_le32(0x00040000)
 +#define FILE_WRITE_OWNER_LE		cpu_to_le32(0x00080000)
 +#define FILE_SYNCHRONIZE_LE		cpu_to_le32(0x00100000)
 +#define FILE_ACCESS_SYSTEM_SECURITY_LE	cpu_to_le32(0x01000000)
 +#define FILE_MAXIMAL_ACCESS_LE		cpu_to_le32(0x02000000)
 +#define FILE_GENERIC_ALL_LE		cpu_to_le32(0x10000000)
 +#define FILE_GENERIC_EXECUTE_LE		cpu_to_le32(0x20000000)
 +#define FILE_GENERIC_WRITE_LE		cpu_to_le32(0x40000000)
 +#define FILE_GENERIC_READ_LE		cpu_to_le32(0x80000000)
 +
 +/* ShareAccess Flags */
 +#define FILE_SHARE_READ_LE		cpu_to_le32(0x00000001)
 +#define FILE_SHARE_WRITE_LE		cpu_to_le32(0x00000002)
 +#define FILE_SHARE_DELETE_LE		cpu_to_le32(0x00000004)
 +#define FILE_SHARE_ALL_LE		cpu_to_le32(0x00000007)
 +
 +/* CreateDisposition Flags */
 +#define FILE_SUPERSEDE_LE		cpu_to_le32(0x00000000)
 +#define FILE_OPEN_LE			cpu_to_le32(0x00000001)
 +#define FILE_CREATE_LE			cpu_to_le32(0x00000002)
 +#define	FILE_OPEN_IF_LE			cpu_to_le32(0x00000003)
 +#define FILE_OVERWRITE_LE		cpu_to_le32(0x00000004)
 +#define FILE_OVERWRITE_IF_LE		cpu_to_le32(0x00000005)
 +
 +/* CreateOptions Flags */
 +#define FILE_DIRECTORY_FILE_LE		cpu_to_le32(0x00000001)
 +/* same as #define CREATE_NOT_FILE_LE	cpu_to_le32(0x00000001) */
 +#define FILE_WRITE_THROUGH_LE		cpu_to_le32(0x00000002)
 +#define FILE_SEQUENTIAL_ONLY_LE		cpu_to_le32(0x00000004)
 +#define FILE_NO_INTERMEDIATE_BUFFERRING_LE cpu_to_le32(0x00000008)
 +#define FILE_SYNCHRONOUS_IO_ALERT_LE	cpu_to_le32(0x00000010)
 +#define FILE_SYNCHRONOUS_IO_NON_ALERT_LE	cpu_to_le32(0x00000020)
 +#define FILE_NON_DIRECTORY_FILE_LE	cpu_to_le32(0x00000040)
 +#define FILE_COMPLETE_IF_OPLOCKED_LE	cpu_to_le32(0x00000100)
 +#define FILE_NO_EA_KNOWLEDGE_LE		cpu_to_le32(0x00000200)
 +#define FILE_RANDOM_ACCESS_LE		cpu_to_le32(0x00000800)
 +#define FILE_DELETE_ON_CLOSE_LE		cpu_to_le32(0x00001000)
 +#define FILE_OPEN_BY_FILE_ID_LE		cpu_to_le32(0x00002000)
 +#define FILE_OPEN_FOR_BACKUP_INTENT_LE	cpu_to_le32(0x00004000)
 +#define FILE_NO_COMPRESSION_LE		cpu_to_le32(0x00008000)
 +#define FILE_RESERVE_OPFILTER_LE	cpu_to_le32(0x00100000)
 +#define FILE_OPEN_REPARSE_POINT_LE	cpu_to_le32(0x00200000)
 +#define FILE_OPEN_NO_RECALL_LE		cpu_to_le32(0x00400000)
 +#define FILE_OPEN_FOR_FREE_SPACE_QUERY_LE cpu_to_le32(0x00800000)
 +
 +#define FILE_READ_RIGHTS_LE (FILE_READ_DATA_LE | FILE_READ_EA_LE \
 +			| FILE_READ_ATTRIBUTES_LE)
 +#define FILE_WRITE_RIGHTS_LE (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE \
 +			| FILE_WRITE_EA_LE | FILE_WRITE_ATTRIBUTES_LE)
 +#define FILE_EXEC_RIGHTS_LE (FILE_EXECUTE_LE)
 +
 +/* Impersonation Levels. See MS-WPO section 9.7 and MSDN-IMPERS */
 +#define IL_ANONYMOUS		cpu_to_le32(0x00000000)
 +#define IL_IDENTIFICATION	cpu_to_le32(0x00000001)
 +#define IL_IMPERSONATION	cpu_to_le32(0x00000002)
 +#define IL_DELEGATE		cpu_to_le32(0x00000003)
 +
 +/* Create Context Values */
 +#define SMB2_CREATE_EA_BUFFER			"ExtA" /* extended attributes */
 +#define SMB2_CREATE_SD_BUFFER			"SecD" /* security descriptor */
 +#define SMB2_CREATE_DURABLE_HANDLE_REQUEST	"DHnQ"
 +#define SMB2_CREATE_DURABLE_HANDLE_RECONNECT	"DHnC"
 +#define SMB2_CREATE_ALLOCATION_SIZE		"AISi"
 +#define SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST "MxAc"
 +#define SMB2_CREATE_TIMEWARP_REQUEST		"TWrp"
 +#define SMB2_CREATE_QUERY_ON_DISK_ID		"QFid"
 +#define SMB2_CREATE_REQUEST_LEASE		"RqLs"
 +#define SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2	"DH2Q"
 +#define SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2	"DH2C"
 +#define SMB2_CREATE_APP_INSTANCE_ID	0x45BCA66AEFA7F74A9008FA462E144D74
 +#define SMB2_CREATE_APP_INSTANCE_VERSION 0xB982D0B73B56074FA07B524A8116A010
 +#define SVHDX_OPEN_DEVICE_CONTEX	0x9CCBCF9E04C1E643980E158DA1F6EC83
 +#define SMB2_CREATE_TAG_POSIX		0x93AD25509CB411E7B42383DE968BCD7C
 +
 +/* Flag (SMB3 open response) values */
 +#define SMB2_CREATE_FLAG_REPARSEPOINT 0x01
 +
++=======
++>>>>>>> c462870bf854 (cifs: Move SMB2_Create definitions to the shared area)
  /*
   * Maximum number of iovs we need for an open/create request.
   * [0] : struct smb2_create_req
@@@ -782,26 -128,6 +785,29 @@@
   */
  #define SMB2_CREATE_IOV_SIZE 8
  
++<<<<<<< HEAD
 +struct smb2_create_req {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 57 */
 +	__u8   SecurityFlags;
 +	__u8   RequestedOplockLevel;
 +	__le32 ImpersonationLevel;
 +	__le64 SmbCreateFlags;
 +	__le64 Reserved;
 +	__le32 DesiredAccess;
 +	__le32 FileAttributes;
 +	__le32 ShareAccess;
 +	__le32 CreateDisposition;
 +	__le32 CreateOptions;
 +	__le16 NameOffset;
 +	__le16 NameLength;
 +	__le32 CreateContextsOffset;
 +	__le32 CreateContextsLength;
 +	__u8   Buffer[];
 +} __packed;
 +
++=======
++>>>>>>> c462870bf854 (cifs: Move SMB2_Create definitions to the shared area)
  /*
   * Maximum size of a SMB2_CREATE response is 64 (smb2 header) +
   * 88 (fixed part of create response) + 520 (path) + 208 (contexts) +
@@@ -809,37 -135,6 +815,40 @@@
   */
  #define MAX_SMB2_CREATE_RESPONSE_SIZE 880
  
++<<<<<<< HEAD
 +struct smb2_create_rsp {
 +	struct smb2_sync_hdr sync_hdr;
 +	__le16 StructureSize;	/* Must be 89 */
 +	__u8   OplockLevel;
 +	__u8   Flag;  /* 0x01 if reparse point */
 +	__le32 CreateAction;
 +	__le64 CreationTime;
 +	__le64 LastAccessTime;
 +	__le64 LastWriteTime;
 +	__le64 ChangeTime;
 +	__le64 AllocationSize;
 +	__le64 EndofFile;
 +	__le32 FileAttributes;
 +	__le32 Reserved2;
 +	__u64  PersistentFileId; /* opaque endianness */
 +	__u64  VolatileFileId; /* opaque endianness */
 +	__le32 CreateContextsOffset;
 +	__le32 CreateContextsLength;
 +	__u8   Buffer[];
 +} __packed;
 +
 +struct create_context {
 +	__le32 Next;
 +	__le16 NameOffset;
 +	__le16 NameLength;
 +	__le16 Reserved;
 +	__le16 DataOffset;
 +	__le32 DataLength;
 +	__u8 Buffer[];
 +} __packed;
 +
++=======
++>>>>>>> c462870bf854 (cifs: Move SMB2_Create definitions to the shared area)
  #define SMB2_LEASE_READ_CACHING_HE	0x01
  #define SMB2_LEASE_HANDLE_CACHING_HE	0x02
  #define SMB2_LEASE_WRITE_CACHING_HE	0x04
* Unmerged path fs/smbfs_common/smb2pdu.h
* Unmerged path fs/cifs/smb2misc.c
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index 2fb9ed3f434e..70ad6fd464bc 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -848,8 +848,8 @@ int open_shroot(unsigned int xid, struct cifs_tcon *tcon,
 	atomic_inc(&tcon->num_remote_opens);
 
 	o_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;
-	oparms.fid->persistent_fid = o_rsp->PersistentFileId;
-	oparms.fid->volatile_fid = o_rsp->VolatileFileId;
+	oparms.fid->persistent_fid = le64_to_cpu(o_rsp->PersistentFileId);
+	oparms.fid->volatile_fid = le64_to_cpu(o_rsp->VolatileFileId);
 #ifdef CONFIG_CIFS_DEBUG2
 	oparms.fid->mid = le64_to_cpu(o_rsp->sync_hdr.MessageId);
 #endif /* CIFS_DEBUG2 */
@@ -2342,8 +2342,8 @@ smb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,
 		cifs_dbg(FYI, "query_dir_first: open failed rc=%d\n", rc);
 		goto qdf_free;
 	}
-	fid->persistent_fid = op_rsp->PersistentFileId;
-	fid->volatile_fid = op_rsp->VolatileFileId;
+	fid->persistent_fid = le64_to_cpu(op_rsp->PersistentFileId);
+	fid->volatile_fid = le64_to_cpu(op_rsp->VolatileFileId);
 
 	/* Anything else than ENODATA means a genuine error */
 	if (rc && rc != -ENODATA) {
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index fcb73ef87431..34aadbaa3060 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -2630,11 +2630,13 @@ int smb311_posix_mkdir(const unsigned int xid, struct inode *inode,
 	}
 
 	rsp = (struct smb2_create_rsp *)rsp_iov.iov_base;
-	trace_smb3_posix_mkdir_done(xid, rsp->PersistentFileId, tcon->tid,
+	trace_smb3_posix_mkdir_done(xid, le64_to_cpu(rsp->PersistentFileId),
+				    tcon->tid,
 				    ses->Suid, CREATE_NOT_FILE,
 				    FILE_WRITE_ATTRIBUTES);
 
-	SMB2_close(xid, tcon, rsp->PersistentFileId, rsp->VolatileFileId);
+	SMB2_close(xid, tcon, le64_to_cpu(rsp->PersistentFileId),
+		   le64_to_cpu(rsp->VolatileFileId));
 
 	/* Eventually save off posix specific response info and timestaps */
 
@@ -2901,13 +2903,14 @@ SMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,
 		}
 		goto creat_exit;
 	} else
-		trace_smb3_open_done(xid, rsp->PersistentFileId, tcon->tid,
+		trace_smb3_open_done(xid, le64_to_cpu(rsp->PersistentFileId),
+				     tcon->tid,
 				     ses->Suid, oparms->create_options,
 				     oparms->desired_access);
 
 	atomic_inc(&tcon->num_remote_opens);
-	oparms->fid->persistent_fid = rsp->PersistentFileId;
-	oparms->fid->volatile_fid = rsp->VolatileFileId;
+	oparms->fid->persistent_fid = le64_to_cpu(rsp->PersistentFileId);
+	oparms->fid->volatile_fid = le64_to_cpu(rsp->VolatileFileId);
 	oparms->fid->access = oparms->desired_access;
 #ifdef CONFIG_CIFS_DEBUG2
 	oparms->fid->mid = le64_to_cpu(rsp->sync_hdr.MessageId);
* Unmerged path fs/cifs/smb2pdu.h
* Unmerged path fs/smbfs_common/smb2pdu.h
