cifs: lock chan_lock outside match_session

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.16.1.rt7.357.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 2f4e429c846972c8405951a9ff7a82aceeca7461
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.16.1.rt7.357.el8_10/2f4e429c.failed

Coverity had rightly indicated a possible deadlock
due to chan_lock being done inside match_session.
All callers of match_* functions should pick up the
necessary locks and call them.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
	Cc: stable@vger.kernel.org
Fixes: 724244cdb382 ("cifs: protect session channel fields with chan_lock")
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 2f4e429c846972c8405951a9ff7a82aceeca7461)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 531a2d7f2407,f42cc7077312..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -1539,6 -1721,7 +1539,10 @@@ out_err
  	return ERR_PTR(rc);
  }
  
++<<<<<<< HEAD
++=======
+ /* this function must be called with ses_lock and chan_lock held */
++>>>>>>> 2f4e429c8469 (cifs: lock chan_lock outside match_session)
  static int match_session(struct cifs_ses *ses, struct smb3_fs_context *ctx)
  {
  	if (ctx->sectype != Unspecified &&
@@@ -1674,10 -1856,20 +1674,23 @@@ cifs_find_smb_ses(struct TCP_Server_Inf
  
  	spin_lock(&cifs_tcp_ses_lock);
  	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
 -		spin_lock(&ses->ses_lock);
 -		if (ses->ses_status == SES_EXITING) {
 -			spin_unlock(&ses->ses_lock);
 +		if (ses->status == CifsExiting)
  			continue;
++<<<<<<< HEAD
 +		if (!match_session(ses, ctx))
 +			continue;
++=======
+ 		}
+ 		spin_lock(&ses->chan_lock);
+ 		if (!match_session(ses, ctx)) {
+ 			spin_unlock(&ses->chan_lock);
+ 			spin_unlock(&ses->ses_lock);
+ 			continue;
+ 		}
+ 		spin_unlock(&ses->chan_lock);
+ 		spin_unlock(&ses->ses_lock);
+ 
++>>>>>>> 2f4e429c8469 (cifs: lock chan_lock outside match_session)
  		++ses->ses_count;
  		spin_unlock(&cifs_tcp_ses_lock);
  		return ses;
@@@ -2469,11 -2686,17 +2482,19 @@@ cifs_match_super(struct super_block *sb
  	ses = tcon->ses;
  	tcp_srv = ses->server;
  
 -	dfs_super_cmp = IS_ENABLED(CONFIG_CIFS_DFS_UPCALL) && tcp_srv->origin_fullpath;
 -
  	ctx = mnt_data->ctx;
  
++<<<<<<< HEAD
 +	if (!match_server(tcp_srv, ctx) ||
++=======
+ 	spin_lock(&tcp_srv->srv_lock);
+ 	spin_lock(&ses->ses_lock);
+ 	spin_lock(&ses->chan_lock);
+ 	spin_lock(&tcon->tc_lock);
+ 	if (!match_server(tcp_srv, ctx, dfs_super_cmp) ||
++>>>>>>> 2f4e429c8469 (cifs: lock chan_lock outside match_session)
  	    !match_session(ses, ctx) ||
 -	    !match_tcon(tcon, ctx, dfs_super_cmp) ||
 +	    !match_tcon(tcon, ctx) ||
  	    !match_prepath(sb, mnt_data)) {
  		rc = 0;
  		goto out;
@@@ -2481,6 -2704,11 +2502,14 @@@
  
  	rc = compare_mount_options(sb, mnt_data);
  out:
++<<<<<<< HEAD
++=======
+ 	spin_unlock(&tcon->tc_lock);
+ 	spin_unlock(&ses->chan_lock);
+ 	spin_unlock(&ses->ses_lock);
+ 	spin_unlock(&tcp_srv->srv_lock);
+ 
++>>>>>>> 2f4e429c8469 (cifs: lock chan_lock outside match_session)
  	spin_unlock(&cifs_tcp_ses_lock);
  	cifs_put_tlink(tlink);
  	return rc;
* Unmerged path fs/cifs/connect.c
