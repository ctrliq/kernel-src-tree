xfs: preserve inode versioning across remounts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Sandeen <sandeen@redhat.com>
commit 4750a171c3290f9bbebca16c6372db723a4cfa3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4750a171.failed

The MS_I_VERSION mount flag is exposed via the VFS, as documented
in the mount manpages etc; see the iversion and noiversion mount
options in mount(8).

As a result, mount -o remount looks for this option in /proc/mounts
and will only send the I_VERSION flag back in during remount it it
is present.  Since it's not there, a remount will /remove/ the
I_VERSION flag at the vfs level, and iversion functionality is lost.

xfs v5 superblocks intend to always have i_version enabled; it is
set as a default at mount time, but is lost during remount for the
reasons above.

The generic fix would be to expose this documented option in
/proc/mounts, but since that was rejected, fix it up again in the
xfs remount path instead, so that at least xfs won't suffer from
this misbehavior.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 4750a171c3290f9bbebca16c6372db723a4cfa3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index e6df26a81bbf,71ac6c1cdc36..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1759,75 -1589,251 +1759,123 @@@ xfs_fs_fill_super
  	goto out_free_sb;
  }
  
 -static int
 -xfs_fc_get_tree(
 -	struct fs_context	*fc)
 -{
 -	return get_tree_bdev(fc, xfs_fc_fill_super);
 -}
 -
 -static int
 -xfs_remount_rw(
 -	struct xfs_mount	*mp)
 +STATIC void
 +xfs_fs_put_super(
 +	struct super_block	*sb)
  {
 -	struct xfs_sb		*sbp = &mp->m_sb;
 -	int error;
 -
 -	if (mp->m_flags & XFS_MOUNT_NORECOVERY) {
 -		xfs_warn(mp,
 -			"ro->rw transition prohibited on norecovery mount");
 -		return -EINVAL;
 -	}
 -
 -	if (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&
 -	    xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {
 -		xfs_warn(mp,
 -	"ro->rw transition prohibited on unknown (0x%x) ro-compat filesystem",
 -			(sbp->sb_features_ro_compat &
 -				XFS_SB_FEAT_RO_COMPAT_UNKNOWN));
 -		return -EINVAL;
 -	}
 -
 -	mp->m_flags &= ~XFS_MOUNT_RDONLY;
 -
 -	/*
 -	 * If this is the first remount to writeable state we might have some
 -	 * superblock changes to update.
 -	 */
 -	if (mp->m_update_sb) {
 -		error = xfs_sync_sb(mp, false);
 -		if (error) {
 -			xfs_warn(mp, "failed to write sb changes");
 -			return error;
 -		}
 -		mp->m_update_sb = false;
 -	}
 +	struct xfs_mount	*mp = XFS_M(sb);
  
 -	/*
 -	 * Fill out the reserve pool if it is empty. Use the stashed value if
 -	 * it is non-zero, otherwise go with the default.
 -	 */
 -	xfs_restore_resvblks(mp);
 -	xfs_log_work_queue(mp);
 +	/* if ->fill_super failed, we have no mount to tear down */
 +	if (!sb->s_fs_info)
 +		return;
  
 -	/* Recover any CoW blocks that never got remapped. */
 -	error = xfs_reflink_recover_cow(mp);
 -	if (error) {
 -		xfs_err(mp,
 -			"Error %d recovering leftover CoW allocations.", error);
 -		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 -		return error;
 -	}
 -	xfs_start_block_reaping(mp);
 +	xfs_notice(mp, "Unmounting Filesystem");
 +	xfs_filestream_unmount(mp);
 +	xfs_unmountfs(mp);
  
 -	/* Create the per-AG metadata reservation pool .*/
 -	error = xfs_fs_reserve_ag_blocks(mp);
 -	if (error && error != -ENOSPC)
 -		return error;
 +	xfs_freesb(mp);
 +	free_percpu(mp->m_stats.xs_stats);
 +	xfs_destroy_percpu_counters(mp);
 +	xfs_destroy_mount_workqueues(mp);
 +	xfs_close_devices(mp);
  
 -	return 0;
 +	sb->s_fs_info = NULL;
 +	xfs_mount_free(mp);
  }
  
 -static int
 -xfs_remount_ro(
 -	struct xfs_mount	*mp)
 +STATIC struct dentry *
 +xfs_fs_mount(
 +	struct file_system_type	*fs_type,
 +	int			flags,
 +	const char		*dev_name,
 +	void			*data)
  {
 -	int error;
 -
 -	/*
 -	 * Cancel background eofb scanning so it cannot race with the final
 -	 * log force+buftarg wait and deadlock the remount.
 -	 */
 -	xfs_stop_block_reaping(mp);
 -
 -	/* Get rid of any leftover CoW reservations... */
 -	error = xfs_icache_free_cowblocks(mp, NULL);
 -	if (error) {
 -		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 -		return error;
 -	}
 -
 -	/* Free the per-AG metadata reservation pool. */
 -	error = xfs_fs_unreserve_ag_blocks(mp);
 -	if (error) {
 -		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 -		return error;
 -	}
 -
 -	/*
 -	 * Before we sync the metadata, we need to free up the reserve block
 -	 * pool so that the used block count in the superblock on disk is
 -	 * correct at the end of the remount. Stash the current* reserve pool
 -	 * size so that if we get remounted rw, we can return it to the same
 -	 * size.
 -	 */
 -	xfs_save_resvblks(mp);
 -
 -	xfs_quiesce_attr(mp);
 -	mp->m_flags |= XFS_MOUNT_RDONLY;
 +	return mount_bdev(fs_type, flags, dev_name, data, xfs_fs_fill_super);
 +}
  
 -	return 0;
 +static long
 +xfs_fs_nr_cached_objects(
 +	struct super_block	*sb,
 +	struct shrink_control	*sc)
 +{
 +	/* Paranoia: catch incorrect calls during mount setup or teardown */
 +	if (WARN_ON_ONCE(!sb->s_fs_info))
 +		return 0;
 +	return xfs_reclaim_inodes_count(XFS_M(sb));
  }
  
 -/*
 - * Logically we would return an error here to prevent users from believing
 - * they might have changed mount options using remount which can't be changed.
 - *
 - * But unfortunately mount(8) adds all options from mtab and fstab to the mount
 - * arguments in some cases so we can't blindly reject options, but have to
 - * check for each specified option if it actually differs from the currently
 - * set option and only reject it if that's the case.
 - *
 - * Until that is implemented we return success for every remount request, and
 - * silently ignore all options that we can't actually change.
 - */
 -static int
 -xfs_fc_reconfigure(
 -	struct fs_context *fc)
 +static long
 +xfs_fs_free_cached_objects(
 +	struct super_block	*sb,
 +	struct shrink_control	*sc)
  {
++<<<<<<< HEAD
 +	return xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);
++=======
+ 	struct xfs_mount	*mp = XFS_M(fc->root->d_sb);
+ 	struct xfs_mount        *new_mp = fc->s_fs_info;
+ 	xfs_sb_t		*sbp = &mp->m_sb;
+ 	int			flags = fc->sb_flags;
+ 	int			error;
+ 
+ 	/* version 5 superblocks always support version counters. */
+ 	if (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)
+ 		fc->sb_flags |= SB_I_VERSION;
+ 
+ 	error = xfs_fc_validate_params(new_mp);
+ 	if (error)
+ 		return error;
+ 
+ 	sync_filesystem(mp->m_super);
+ 
+ 	/* inode32 -> inode64 */
+ 	if ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) &&
+ 	    !(new_mp->m_flags & XFS_MOUNT_SMALL_INUMS)) {
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
+ 	}
+ 
+ 	/* inode64 -> inode32 */
+ 	if (!(mp->m_flags & XFS_MOUNT_SMALL_INUMS) &&
+ 	    (new_mp->m_flags & XFS_MOUNT_SMALL_INUMS)) {
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
+ 	}
+ 
+ 	/* ro -> rw */
+ 	if ((mp->m_flags & XFS_MOUNT_RDONLY) && !(flags & SB_RDONLY)) {
+ 		error = xfs_remount_rw(mp);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/* rw -> ro */
+ 	if (!(mp->m_flags & XFS_MOUNT_RDONLY) && (flags & SB_RDONLY)) {
+ 		error = xfs_remount_ro(mp);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 4750a171c329 (xfs: preserve inode versioning across remounts)
  }
  
 -static void xfs_fc_free(
 -	struct fs_context	*fc)
 -{
 -	struct xfs_mount	*mp = fc->s_fs_info;
 -
 -	/*
 -	 * mp is stored in the fs_context when it is initialized.
 -	 * mp is transferred to the superblock on a successful mount,
 -	 * but if an error occurs before the transfer we have to free
 -	 * it here.
 -	 */
 -	if (mp)
 -		xfs_mount_free(mp);
 -}
 -
 -static const struct fs_context_operations xfs_context_ops = {
 -	.parse_param = xfs_fc_parse_param,
 -	.get_tree    = xfs_fc_get_tree,
 -	.reconfigure = xfs_fc_reconfigure,
 -	.free        = xfs_fc_free,
 +static const struct super_operations xfs_super_operations = {
 +	.alloc_inode		= xfs_fs_alloc_inode,
 +	.destroy_inode		= xfs_fs_destroy_inode,
 +	.dirty_inode		= xfs_fs_dirty_inode,
 +	.drop_inode		= xfs_fs_drop_inode,
 +	.put_super		= xfs_fs_put_super,
 +	.sync_fs		= xfs_fs_sync_fs,
 +	.freeze_fs		= xfs_fs_freeze,
 +	.unfreeze_fs		= xfs_fs_unfreeze,
 +	.statfs			= xfs_fs_statfs,
 +	.remount_fs		= xfs_fs_remount,
 +	.show_options		= xfs_fs_show_options,
 +	.nr_cached_objects	= xfs_fs_nr_cached_objects,
 +	.free_cached_objects	= xfs_fs_free_cached_objects,
  };
  
 -static int xfs_init_fs_context(
 -	struct fs_context	*fc)
 -{
 -	struct xfs_mount	*mp;
 -
 -	mp = kmem_alloc(sizeof(struct xfs_mount), KM_ZERO);
 -	if (!mp)
 -		return -ENOMEM;
 -
 -	spin_lock_init(&mp->m_sb_lock);
 -	spin_lock_init(&mp->m_agirotor_lock);
 -	INIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);
 -	spin_lock_init(&mp->m_perag_lock);
 -	mutex_init(&mp->m_growlock);
 -	INIT_WORK(&mp->m_flush_inodes_work, xfs_flush_inodes_worker);
 -	INIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);
 -	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
 -	INIT_DELAYED_WORK(&mp->m_cowblocks_work, xfs_cowblocks_worker);
 -	mp->m_kobj.kobject.kset = xfs_kset;
 -	/*
 -	 * We don't create the finobt per-ag space reservation until after log
 -	 * recovery, so we must set this to true so that an ifree transaction
 -	 * started during log recovery will not depend on space reservations
 -	 * for finobt expansion.
 -	 */
 -	mp->m_finobt_nores = true;
 -
 -	/*
 -	 * These can be overridden by the mount option parsing.
 -	 */
 -	mp->m_logbufs = -1;
 -	mp->m_logbsize = -1;
 -	mp->m_allocsize_log = 16; /* 64k */
 -
 -	/*
 -	 * Copy binary VFS mount flags we are interested in.
 -	 */
 -	if (fc->sb_flags & SB_RDONLY)
 -		mp->m_flags |= XFS_MOUNT_RDONLY;
 -	if (fc->sb_flags & SB_DIRSYNC)
 -		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 -	if (fc->sb_flags & SB_SYNCHRONOUS)
 -		mp->m_flags |= XFS_MOUNT_WSYNC;
 -
 -	fc->s_fs_info = mp;
 -	fc->ops = &xfs_context_ops;
 -
 -	return 0;
 -}
 -
  static struct file_system_type xfs_fs_type = {
  	.owner			= THIS_MODULE,
  	.name			= "xfs",
* Unmerged path fs/xfs/xfs_super.c
