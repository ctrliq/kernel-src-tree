filelock: add a new locks_inode_context accessor function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-546.el8
commit-author Jeff Layton <jlayton@kernel.org>
commit 401a8b8fd5acd51582b15238d72a8d0edd580e9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-546.el8/401a8b8f.failed

There are a number of places in the kernel that are accessing the
inode->i_flctx field without smp_load_acquire. This is required to
ensure that the caller doesn't see a partially-initialized structure.

Add a new accessor function for it to make this clear and convert all of
the relevant accesses in locks.c to use it. Also, convert
locks_free_lock_context to use the helper as well instead of just doing
a "bare" assignment.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jeff Layton <jlayton@kernel.org>
(cherry picked from commit 401a8b8fd5acd51582b15238d72a8d0edd580e9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
#	include/linux/fs.h
diff --cc fs/locks.c
index f7a81c12e56e,8e48b3d5afe3..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -820,8 -888,10 +820,8 @@@ posix_test_lock(struct file *filp, stru
  	struct file_lock *cfl;
  	struct file_lock_context *ctx;
  	struct inode *inode = locks_inode(filp);
 -	void *owner;
 -	void (*func)(void);
  
- 	ctx = smp_load_acquire(&inode->i_flctx);
+ 	ctx = locks_inode_context(inode);
  	if (!ctx || list_empty_careful(&ctx->flc_posix)) {
  		fl->fl_type = F_UNLCK;
  		return;
@@@ -1472,10 -1483,10 +1472,10 @@@ int __break_lease(struct inode *inode, 
  	new_fl->fl_flags = type;
  
  	/* typically we will check that ctx is non-NULL before calling */
- 	ctx = smp_load_acquire(&inode->i_flctx);
+ 	ctx = locks_inode_context(inode);
  	if (!ctx) {
  		WARN_ON_ONCE(1);
 -		goto free_lock;
 +		return error;
  	}
  
  	percpu_down_read(&file_rwsem);
@@@ -2627,6 -2672,29 +2627,32 @@@ int vfs_cancel_lock(struct file *filp, 
  }
  EXPORT_SYMBOL_GPL(vfs_cancel_lock);
  
++<<<<<<< HEAD
++=======
+ /**
+  * vfs_inode_has_locks - are any file locks held on @inode?
+  * @inode: inode to check for locks
+  *
+  * Return true if there are any FL_POSIX or FL_FLOCK locks currently
+  * set on @inode.
+  */
+ bool vfs_inode_has_locks(struct inode *inode)
+ {
+ 	struct file_lock_context *ctx;
+ 	bool ret;
+ 
+ 	ctx = locks_inode_context(inode);
+ 	if (!ctx)
+ 		return false;
+ 
+ 	spin_lock(&ctx->flc_lock);
+ 	ret = !list_empty(&ctx->flc_posix) || !list_empty(&ctx->flc_flock);
+ 	spin_unlock(&ctx->flc_lock);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(vfs_inode_has_locks);
+ 
++>>>>>>> 401a8b8fd5ac (filelock: add a new locks_inode_context accessor function)
  #ifdef CONFIG_PROC_FS
  #include <linux/proc_fs.h>
  #include <linux/seq_file.h>
diff --cc include/linux/fs.h
index ed30a0d62377,fd0a79511fd8..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1173,6 -1180,20 +1173,18 @@@ extern int lease_modify(struct file_loc
  struct files_struct;
  extern void show_fd_locks(struct seq_file *f,
  			 struct file *filp, struct files_struct *files);
++<<<<<<< HEAD
++=======
+ extern bool locks_owner_has_blockers(struct file_lock_context *flctx,
+ 			fl_owner_t owner);
+ 
+ static inline struct file_lock_context *
+ locks_inode_context(const struct inode *inode)
+ {
+ 	return smp_load_acquire(&inode->i_flctx);
+ }
+ 
++>>>>>>> 401a8b8fd5ac (filelock: add a new locks_inode_context accessor function)
  #else /* !CONFIG_FILE_LOCKING */
  static inline int fcntl_getlk(struct file *file, unsigned int cmd,
  			      struct flock __user *user)
@@@ -1308,6 -1334,18 +1320,21 @@@ static inline int lease_modify(struct f
  struct files_struct;
  static inline void show_fd_locks(struct seq_file *f,
  			struct file *filp, struct files_struct *files) {}
++<<<<<<< HEAD
++=======
+ static inline bool locks_owner_has_blockers(struct file_lock_context *flctx,
+ 			fl_owner_t owner)
+ {
+ 	return false;
+ }
+ 
+ static inline struct file_lock_context *
+ locks_inode_context(const struct inode *inode)
+ {
+ 	return NULL;
+ }
+ 
++>>>>>>> 401a8b8fd5ac (filelock: add a new locks_inode_context accessor function)
  #endif /* !CONFIG_FILE_LOCKING */
  
  static inline struct inode *file_inode(const struct file *f)
* Unmerged path fs/locks.c
* Unmerged path include/linux/fs.h
