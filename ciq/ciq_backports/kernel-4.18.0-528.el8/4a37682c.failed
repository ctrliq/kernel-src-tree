Bluetooth: advmon offload MSFT handle controller reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Archie Pusaka <apusaka@chromium.org>
commit 4a37682c6b59c8888acf93117362d761c5923a69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/4a37682c.failed

When the controller is powered off, the registered advertising monitor
is removed from the controller. This patch handles the re-registration
of those monitors when the power is on.

	Signed-off-by: Archie Pusaka <apusaka@chromium.org>
	Reviewed-by: Miao-chen Chou <mcchou@chromium.org>
	Reviewed-by: Yun-Hao Chung <howardchung@google.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 4a37682c6b59c8888acf93117362d761c5923a69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/msft.c
diff --cc net/bluetooth/msft.c
index 910ec68f8aa5,d25c6936daa4..000000000000
--- a/net/bluetooth/msft.c
+++ b/net/bluetooth/msft.c
@@@ -25,8 -79,20 +25,25 @@@ struct msft_data 
  	__u64 features;
  	__u8  evt_prefix_len;
  	__u8  *evt_prefix;
++<<<<<<< HEAD
 +};
 +
++=======
+ 	struct list_head handle_map;
+ 	__u16 pending_add_handle;
+ 	__u16 pending_remove_handle;
+ 	__u8 reregistering;
+ };
+ 
+ static int __msft_add_monitor_pattern(struct hci_dev *hdev,
+ 				      struct adv_monitor *monitor);
+ 
+ bool msft_monitor_supported(struct hci_dev *hdev)
+ {
+ 	return !!(msft_get_features(hdev) & MSFT_FEATURE_MASK_LE_ADV_MONITOR);
+ }
+ 
++>>>>>>> 4a37682c6b59 (Bluetooth: advmon offload MSFT handle controller reset)
  static bool read_supported_features(struct hci_dev *hdev,
  				    struct msft_data *msft)
  {
@@@ -93,12 -185,20 +139,22 @@@ void msft_do_open(struct hci_dev *hdev
  		return;
  	}
  
 -	INIT_LIST_HEAD(&msft->handle_map);
  	hdev->msft_data = msft;
+ 
+ 	if (msft_monitor_supported(hdev)) {
+ 		msft->reregistering = true;
+ 		reregister_monitor_on_restart(hdev, 0);
+ 	}
  }
  
  void msft_do_close(struct hci_dev *hdev)
  {
  	struct msft_data *msft = hdev->msft_data;
++<<<<<<< HEAD
++=======
+ 	struct msft_monitor_advertisement_handle_data *handle_data, *tmp;
+ 	struct adv_monitor *monitor;
++>>>>>>> 4a37682c6b59 (Bluetooth: advmon offload MSFT handle controller reset)
  
  	if (!msft)
  		return;
@@@ -107,6 -207,17 +163,20 @@@
  
  	hdev->msft_data = NULL;
  
++<<<<<<< HEAD
++=======
+ 	list_for_each_entry_safe(handle_data, tmp, &msft->handle_map, list) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr,
+ 				   handle_data->mgmt_handle);
+ 
+ 		if (monitor && monitor->state == ADV_MONITOR_STATE_OFFLOADED)
+ 			monitor->state = ADV_MONITOR_STATE_REGISTERED;
+ 
+ 		list_del(&handle_data->list);
+ 		kfree(handle_data);
+ 	}
+ 
++>>>>>>> 4a37682c6b59 (Bluetooth: advmon offload MSFT handle controller reset)
  	kfree(msft->evt_prefix);
  	kfree(msft);
  }
@@@ -148,10 -259,275 +218,274 @@@ __u64 msft_get_features(struct hci_dev 
  {
  	struct msft_data *msft = hdev->msft_data;
  
 -	return msft ? msft->features : 0;
 +	return  msft ? msft->features : 0;
  }
  
 -/* is_mgmt = true matches the handle exposed to userspace via mgmt.
 - * is_mgmt = false matches the handle used by the msft controller.
 - * This function requires the caller holds hdev->lock
 - */
 -static struct msft_monitor_advertisement_handle_data *msft_find_handle_data
 -				(struct hci_dev *hdev, u16 handle, bool is_mgmt)
 +bool msft_curve_validity(struct hci_dev *hdev)
  {
++<<<<<<< HEAD
 +	return hdev->msft_curve_validity;
++=======
+ 	struct msft_monitor_advertisement_handle_data *entry;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	list_for_each_entry(entry, &msft->handle_map, list) {
+ 		if (is_mgmt && entry->mgmt_handle == handle)
+ 			return entry;
+ 		if (!is_mgmt && entry->msft_handle == handle)
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void msft_le_monitor_advertisement_cb(struct hci_dev *hdev,
+ 					     u8 status, u16 opcode,
+ 					     struct sk_buff *skb)
+ {
+ 	struct msft_rp_le_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	monitor = idr_find(&hdev->adv_monitors_idr, msft->pending_add_handle);
+ 	if (!monitor) {
+ 		bt_dev_err(hdev, "msft add advmon: monitor %d is not found!",
+ 			   msft->pending_add_handle);
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	if (status)
+ 		goto unlock;
+ 
+ 	rp = (struct msft_rp_le_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data = kmalloc(sizeof(*handle_data), GFP_KERNEL);
+ 	if (!handle_data) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data->mgmt_handle = monitor->handle;
+ 	handle_data->msft_handle = rp->handle;
+ 	INIT_LIST_HEAD(&handle_data->list);
+ 	list_add(&handle_data->list, &msft->handle_map);
+ 
+ 	monitor->state = ADV_MONITOR_STATE_OFFLOADED;
+ 
+ unlock:
+ 	if (status && monitor)
+ 		hci_free_adv_monitor(hdev, monitor);
+ 
+ 	/* If in restart/reregister sequence, keep registering. */
+ 	if (msft->reregistering)
+ 		reregister_monitor_on_restart(hdev,
+ 					      msft->pending_add_handle + 1);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	if (!msft->reregistering)
+ 		hci_add_adv_patterns_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_cancel_monitor_advertisement_cb(struct hci_dev *hdev,
+ 						    u8 status, u16 opcode,
+ 						    struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement *cp;
+ 	struct msft_rp_le_cancel_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 	bool pending;
+ 
+ 	if (status)
+ 		goto done;
+ 
+ 	rp = (struct msft_rp_le_cancel_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto done;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	handle_data = msft_find_handle_data(hdev, cp->handle, false);
+ 
+ 	if (handle_data) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr,
+ 				   handle_data->mgmt_handle);
+ 		if (monitor)
+ 			hci_free_adv_monitor(hdev, monitor);
+ 
+ 		list_del(&handle_data->list);
+ 		kfree(handle_data);
+ 	}
+ 
+ 	/* If remove all monitors is required, we need to continue the process
+ 	 * here because the earlier it was paused when waiting for the
+ 	 * response from controller.
+ 	 */
+ 	if (msft->pending_remove_handle == 0) {
+ 		pending = hci_remove_all_adv_monitor(hdev, &err);
+ 		if (pending) {
+ 			hci_dev_unlock(hdev);
+ 			return;
+ 		}
+ 
+ 		if (err)
+ 			status = HCI_ERROR_UNSPECIFIED;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ done:
+ 	hci_remove_adv_monitor_complete(hdev, status);
+ }
+ 
+ static bool msft_monitor_rssi_valid(struct adv_monitor *monitor)
+ {
+ 	struct adv_rssi_thresholds *r = &monitor->rssi;
+ 
+ 	if (r->high_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->high_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX ||
+ 	    r->low_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->low_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX)
+ 		return false;
+ 
+ 	/* High_threshold_timeout is not supported,
+ 	 * once high_threshold is reached, events are immediately reported.
+ 	 */
+ 	if (r->high_threshold_timeout != 0)
+ 		return false;
+ 
+ 	if (r->low_threshold_timeout > MSFT_RSSI_LOW_TIMEOUT_MAX)
+ 		return false;
+ 
+ 	/* Sampling period from 0x00 to 0xFF are all allowed */
+ 	return true;
+ }
+ 
+ static bool msft_monitor_pattern_valid(struct adv_monitor *monitor)
+ {
+ 	return msft_monitor_rssi_valid(monitor);
+ 	/* No additional check needed for pattern-based monitor */
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ static int __msft_add_monitor_pattern(struct hci_dev *hdev,
+ 				      struct adv_monitor *monitor)
+ {
+ 	struct msft_cp_le_monitor_advertisement *cp;
+ 	struct msft_le_monitor_advertisement_pattern_data *pattern_data;
+ 	struct msft_le_monitor_advertisement_pattern *pattern;
+ 	struct adv_pattern *entry;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	size_t total_size = sizeof(*cp) + sizeof(*pattern_data);
+ 	ptrdiff_t offset = 0;
+ 	u8 pattern_count = 0;
+ 	int err = 0;
+ 
+ 	if (!msft_monitor_pattern_valid(monitor))
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern_count++;
+ 		total_size += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	cp = kmalloc(total_size, GFP_KERNEL);
+ 	if (!cp)
+ 		return -ENOMEM;
+ 
+ 	cp->sub_opcode = MSFT_OP_LE_MONITOR_ADVERTISEMENT;
+ 	cp->rssi_high = monitor->rssi.high_threshold;
+ 	cp->rssi_low = monitor->rssi.low_threshold;
+ 	cp->rssi_low_interval = (u8)monitor->rssi.low_threshold_timeout;
+ 	cp->rssi_sampling_period = monitor->rssi.sampling_period;
+ 
+ 	cp->cond_type = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;
+ 
+ 	pattern_data = (void *)cp->data;
+ 	pattern_data->count = pattern_count;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern = (void *)(pattern_data->data + offset);
+ 		/* the length also includes data_type and offset */
+ 		pattern->length = entry->length + 2;
+ 		pattern->data_type = entry->ad_type;
+ 		pattern->start_byte = entry->offset;
+ 		memcpy(pattern->pattern, entry->value, entry->length);
+ 		offset += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, total_size, cp);
+ 	err = hci_req_run_skb(&req, msft_le_monitor_advertisement_cb);
+ 	kfree(cp);
+ 
+ 	if (!err)
+ 		msft->pending_add_handle = monitor->handle;
+ 
+ 	return err;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	return __msft_add_monitor_pattern(hdev, monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement cp;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err = 0;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	handle_data = msft_find_handle_data(hdev, monitor->handle, true);
+ 
+ 	/* If no matched handle, just remove without telling controller */
+ 	if (!handle_data)
+ 		return -ENOENT;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;
+ 	cp.handle = handle_data->msft_handle;
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, sizeof(cp), &cp);
+ 	err = hci_req_run_skb(&req, msft_le_cancel_monitor_advertisement_cb);
+ 
+ 	if (!err)
+ 		msft->pending_remove_handle = handle;
+ 
+ 	return err;
++>>>>>>> 4a37682c6b59 (Bluetooth: advmon offload MSFT handle controller reset)
  }
* Unmerged path net/bluetooth/msft.c
