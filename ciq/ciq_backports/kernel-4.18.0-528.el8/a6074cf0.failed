kunit: Fix missed memory release in kunit_free_suite_set()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Jinjie Ruan <ruanjinjie@huawei.com>
commit a6074cf0126b0bee51ab77a15930dc24a4d5db90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/a6074cf0.failed

modprobe cpumask_kunit and rmmod cpumask_kunit, kmemleak detect
a suspected memory leak as below.

If kunit_filter_suites() in kunit_module_init() succeeds, the
suite_set.start will not be NULL and the kunit_free_suite_set() in
kunit_module_exit() should free all the memory which has not
been freed. However the test_cases in suites is left out.

unreferenced object 0xffff54ac47e83200 (size 512):
  comm "modprobe", pid 592, jiffies 4294913238 (age 1367.612s)
  hex dump (first 32 bytes):
    84 13 1a f0 d3 b6 ff ff 30 68 1a f0 d3 b6 ff ff  ........0h......
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<000000008dec63a2>] slab_post_alloc_hook+0xb8/0x368
    [<00000000ec280d8e>] __kmem_cache_alloc_node+0x174/0x290
    [<00000000896c7740>] __kmalloc+0x60/0x2c0
    [<000000007a50fa06>] kunit_filter_suites+0x254/0x5b8
    [<0000000078cc98e2>] kunit_module_notify+0xf4/0x240
    [<0000000033cea952>] notifier_call_chain+0x98/0x17c
    [<00000000973d05cc>] notifier_call_chain_robust+0x4c/0xa4
    [<000000005f95895f>] blocking_notifier_call_chain_robust+0x4c/0x74
    [<0000000048e36fa7>] load_module+0x1a2c/0x1c40
    [<0000000004eb8a91>] init_module_from_file+0x94/0xcc
    [<0000000037dbba28>] idempotent_init_module+0x184/0x278
    [<00000000161b75cb>] __arm64_sys_finit_module+0x68/0xa8
    [<000000006dc1669b>] invoke_syscall+0x44/0x100
    [<00000000fa87e304>] el0_svc_common.constprop.1+0x68/0xe0
    [<000000009d8ad866>] do_el0_svc+0x1c/0x28
    [<000000005b83c607>] el0_svc+0x3c/0xc4

Fixes: a127b154a8f2 ("kunit: tool: allow filtering test cases via glob")
	Signed-off-by: Jinjie Ruan <ruanjinjie@huawei.com>
	Reviewed-by: Rae Moar <rmoar@google.com>
	Reviewed-by: David Gow <davidgow@google.com>
	Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
(cherry picked from commit a6074cf0126b0bee51ab77a15930dc24a4d5db90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/kunit/executor.c
diff --cc lib/kunit/executor.c
index 7ce5aabb617d,a037a46fae5e..000000000000
--- a/lib/kunit/executor.c
+++ b/lib/kunit/executor.c
@@@ -89,103 -133,160 +89,139 @@@ kunit_filter_tests(const struct kunit_s
  	return copy;
  }
  
 -void kunit_free_suite_set(struct kunit_suite_set suite_set)
 +static char *kunit_shutdown;
 +core_param(kunit_shutdown, kunit_shutdown, charp, 0644);
 +
 +static struct kunit_suite * const *
 +kunit_filter_subsuite(struct kunit_suite * const * const subsuite,
 +		      struct kunit_test_filter *filter)
  {
 -	struct kunit_suite * const *suites;
 +	int i, n = 0;
 +	struct kunit_suite **filtered, *filtered_suite;
  
++<<<<<<< HEAD
 +	n = 0;
 +	for (i = 0; subsuite[i]; ++i) {
 +		if (glob_match(filter->suite_glob, subsuite[i]->name))
 +			++n;
++=======
+ 	for (suites = suite_set.start; suites < suite_set.end; suites++) {
+ 		kfree((*suites)->test_cases);
+ 		kfree(*suites);
+ 	}
+ 	kfree(suite_set.start);
+ }
+ 
+ struct kunit_suite_set
+ kunit_filter_suites(const struct kunit_suite_set *suite_set,
+ 		    const char *filter_glob,
+ 		    char *filters,
+ 		    char *filter_action,
+ 		    int *err)
+ {
+ 	int i, j, k;
+ 	int filter_count = 0;
+ 	struct kunit_suite **copy, **copy_start, *filtered_suite, *new_filtered_suite;
+ 	struct kunit_suite_set filtered = {NULL, NULL};
+ 	struct kunit_glob_filter parsed_glob;
+ 	struct kunit_attr_filter *parsed_filters = NULL;
+ 
+ 	const size_t max = suite_set->end - suite_set->start;
+ 
+ 	copy = kmalloc_array(max, sizeof(*filtered.start), GFP_KERNEL);
+ 	if (!copy) { /* won't be able to run anything, return an empty set */
+ 		return filtered;
+ 	}
+ 	copy_start = copy;
+ 
+ 	if (filter_glob) {
+ 		*err = kunit_parse_glob_filter(&parsed_glob, filter_glob);
+ 		if (*err)
+ 			goto free_copy;
++>>>>>>> a6074cf0126b (kunit: Fix missed memory release in kunit_free_suite_set())
  	}
  
 -	/* Parse attribute filters */
 -	if (filters) {
 -		filter_count = kunit_get_filter_count(filters);
 -		parsed_filters = kcalloc(filter_count, sizeof(*parsed_filters), GFP_KERNEL);
 -		if (!parsed_filters) {
 -			*err = -ENOMEM;
 -			goto free_parsed_glob;
 -		}
 -		for (j = 0; j < filter_count; j++)
 -			parsed_filters[j] = kunit_next_attr_filter(&filters, err);
 -		if (*err)
 -			goto free_parsed_filters;
 -	}
 +	if (n == 0)
 +		return NULL;
  
 -	for (i = 0; &suite_set->start[i] != suite_set->end; i++) {
 -		filtered_suite = suite_set->start[i];
 -		if (filter_glob) {
 -			if (!glob_match(parsed_glob.suite_glob, filtered_suite->name))
 -				continue;
 -			filtered_suite = kunit_filter_glob_tests(filtered_suite,
 -					parsed_glob.test_glob);
 -			if (IS_ERR(filtered_suite)) {
 -				*err = PTR_ERR(filtered_suite);
 -				goto free_parsed_filters;
 -			}
 -		}
 -		if (filter_count > 0 && parsed_filters != NULL) {
 -			for (k = 0; k < filter_count; k++) {
 -				new_filtered_suite = kunit_filter_attr_tests(filtered_suite,
 -						parsed_filters[k], filter_action, err);
 -
 -				/* Free previous copy of suite */
 -				if (k > 0 || filter_glob) {
 -					kfree(filtered_suite->test_cases);
 -					kfree(filtered_suite);
 -				}
 -
 -				filtered_suite = new_filtered_suite;
 -
 -				if (*err)
 -					goto free_parsed_filters;
 -
 -				if (IS_ERR(filtered_suite)) {
 -					*err = PTR_ERR(filtered_suite);
 -					goto free_parsed_filters;
 -				}
 -				if (!filtered_suite)
 -					break;
 -			}
 -		}
 +	filtered = kmalloc_array(n + 1, sizeof(*filtered), GFP_KERNEL);
 +	if (!filtered)
 +		return ERR_PTR(-ENOMEM);
  
 -		if (!filtered_suite)
 +	n = 0;
 +	for (i = 0; subsuite[i] != NULL; ++i) {
 +		if (!glob_match(filter->suite_glob, subsuite[i]->name))
  			continue;
 -
 -		*copy++ = filtered_suite;
 +		filtered_suite = kunit_filter_tests(subsuite[i], filter->test_glob);
 +		if (IS_ERR(filtered_suite))
 +			return ERR_CAST(filtered_suite);
 +		else if (filtered_suite)
 +			filtered[n++] = filtered_suite;
  	}
 -	filtered.start = copy_start;
 -	filtered.end = copy;
 +	filtered[n] = NULL;
  
 -free_parsed_filters:
 -	if (filter_count)
 -		kfree(parsed_filters);
 +	return filtered;
 +}
  
 -free_parsed_glob:
 -	if (filter_glob) {
 -		kfree(parsed_glob.suite_glob);
 -		kfree(parsed_glob.test_glob);
 -	}
 +struct suite_set {
 +	struct kunit_suite * const * const *start;
 +	struct kunit_suite * const * const *end;
 +};
  
 -free_copy:
 -	if (*err)
 -		kfree(copy);
 +static void kunit_free_subsuite(struct kunit_suite * const *subsuite)
 +{
 +	unsigned int i;
  
 -	return filtered;
 +	for (i = 0; subsuite[i]; i++)
 +		kfree(subsuite[i]);
 +
 +	kfree(subsuite);
  }
  
 -void kunit_exec_run_tests(struct kunit_suite_set *suite_set, bool builtin)
 +static void kunit_free_suite_set(struct suite_set suite_set)
  {
 -	size_t num_suites = suite_set->end - suite_set->start;
 -
 -	if (builtin || num_suites) {
 -		pr_info("KTAP version 1\n");
 -		pr_info("1..%zu\n", num_suites);
 -	}
 +	struct kunit_suite * const * const *suites;
  
 -	__kunit_test_suites_init(suite_set->start, num_suites);
 +	for (suites = suite_set.start; suites < suite_set.end; suites++)
 +		kunit_free_subsuite(*suites);
 +	kfree(suite_set.start);
  }
  
 -void kunit_exec_list_tests(struct kunit_suite_set *suite_set, bool include_attr)
 +static struct suite_set kunit_filter_suites(const struct suite_set *suite_set,
 +					    const char *filter_glob,
 +					    int *err)
  {
 -	struct kunit_suite * const *suites;
 -	struct kunit_case *test_case;
 +	int i;
 +	struct kunit_suite * const **copy, * const *filtered_subsuite;
 +	struct suite_set filtered;
 +	struct kunit_test_filter filter;
  
 -	/* Hack: print a ktap header so kunit.py can find the start of KUnit output. */
 -	pr_info("KTAP version 1\n");
 +	const size_t max = suite_set->end - suite_set->start;
  
 -	for (suites = suite_set->start; suites < suite_set->end; suites++) {
 -		/* Print suite name and suite attributes */
 -		pr_info("%s\n", (*suites)->name);
 -		if (include_attr)
 -			kunit_print_attr((void *)(*suites), false, 0);
 +	copy = kmalloc_array(max, sizeof(*filtered.start), GFP_KERNEL);
 +	filtered.start = copy;
 +	if (!copy) { /* won't be able to run anything, return an empty set */
 +		filtered.end = copy;
 +		return filtered;
 +	}
 +
 +	kunit_parse_filter_glob(&filter, filter_glob);
  
 -		/* Print test case name and attributes in suite */
 -		kunit_suite_for_each_test_case((*suites), test_case) {
 -			pr_info("%s.%s\n", (*suites)->name, test_case->name);
 -			if (include_attr)
 -				kunit_print_attr((void *)test_case, true, 0);
 +	for (i = 0; i < max; ++i) {
 +		filtered_subsuite = kunit_filter_subsuite(suite_set->start[i], &filter);
 +		if (IS_ERR(filtered_subsuite)) {
 +			*err = PTR_ERR(filtered_subsuite);
 +			return filtered;
  		}
 +		if (filtered_subsuite)
 +			*copy++ = filtered_subsuite;
  	}
 -}
 -
 -#if IS_BUILTIN(CONFIG_KUNIT)
 +	filtered.end = copy;
  
 -static char *kunit_shutdown;
 -core_param(kunit_shutdown, kunit_shutdown, charp, 0644);
 +	kfree(filter.suite_glob);
 +	kfree(filter.test_glob);
 +	return filtered;
 +}
  
  static void kunit_handle_shutdown(void)
  {
* Unmerged path lib/kunit/executor.c
