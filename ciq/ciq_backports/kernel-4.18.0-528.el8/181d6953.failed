Bluetooth: Replace BT_DBG with bt_dev_dbg for management support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Marcel Holtmann <marcel@holtmann.org>
commit 181d695352305cc52a49c151a1c3370376e54887
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/181d6953.failed

The majority of management interaction are based on a controller index
and have a hci_dev associated with it. So use bt_dev_dbg to have a clean
way of indentifying the controller the debug message belongs to.

	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 181d695352305cc52a49c151a1c3370376e54887)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/mgmt.c
diff --cc net/bluetooth/mgmt.c
index 1bfb5e35836f,78cf72b64014..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -1823,12 -1787,8 +1823,12 @@@ static int set_hs(struct sock *sk, stru
  	u8 status;
  	int err;
  
- 	BT_DBG("request for %s", hdev->name);
+ 	bt_dev_dbg(hdev, "sock %p", sk);
  
 +	if (!IS_ENABLED(CONFIG_BT_HS))
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,
 +				       MGMT_STATUS_NOT_SUPPORTED);
 +
  	status = mgmt_bredr_support(hdev);
  	if (status)
  		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS, status);
@@@ -3392,6 -3337,27 +3391,30 @@@ static int set_appearance(struct sock *
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int get_phy_configuration(struct sock *sk, struct hci_dev *hdev,
+ 				 void *data, u16 len)
+ {
+ 	struct mgmt_rp_get_phy_confguration rp;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 
+ 	rp.supported_phys = cpu_to_le32(get_supported_phys(hdev));
+ 	rp.selected_phys = cpu_to_le32(get_selected_phys(hdev));
+ 	rp.configurable_phys = cpu_to_le32(get_configurable_phys(hdev));
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_PHY_CONFIGURATION, 0,
+ 				 &rp, sizeof(rp));
+ }
+ 
++>>>>>>> 181d69535230 (Bluetooth: Replace BT_DBG with bt_dev_dbg for management support)
  int mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip)
  {
  	struct mgmt_ev_phy_configuration_changed ev;
@@@ -3590,12 -3556,32 +3613,31 @@@ unlock
  	return err;
  }
  
 -static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
 -			    u16 len)
 +static int get_phy_configuration(struct sock *sk, struct hci_dev *hdev,
 +				 void *data, u16 len)
  {
 -	int err = MGMT_STATUS_SUCCESS;
 -	struct mgmt_cp_set_blocked_keys *keys = data;
 -	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
 -				   sizeof(struct mgmt_blocked_key_info));
 -	u16 key_count, expected_len;
 -	int i;
 +	struct mgmt_rp_get_phy_confguration rp;
  
++<<<<<<< HEAD
 +	BT_DBG("sock %p %s", sk, hdev->name);
++=======
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	key_count = __le16_to_cpu(keys->key_count);
+ 	if (key_count > max_key_count) {
+ 		bt_dev_err(hdev, "too big key_count value %u", key_count);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	expected_len = struct_size(keys, keys, key_count);
+ 	if (expected_len != len) {
+ 		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
+ 			   expected_len, len);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
++>>>>>>> 181d69535230 (Bluetooth: Replace BT_DBG with bt_dev_dbg for management support)
  
  	hci_dev_lock(hdev);
  
@@@ -3900,637 -3778,93 +3942,637 @@@ static int set_exp_feature(struct sock 
  
  	bt_dev_dbg(hdev, "sock %p", sk);
  
 -	hci_dev_lock(hdev);
 +	if (!memcmp(cp->uuid, ZERO_KEY, 16)) {
 +		memset(rp.uuid, 0, 16);
 +		rp.flags = cpu_to_le32(0);
  
 -	if (!hdev_is_powered(hdev)) {
 -		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 -				      MGMT_STATUS_NOT_POWERED);
 -		goto unlock;
 -	}
 +#ifdef CONFIG_BT_FEATURE_DEBUG
 +		if (!hdev) {
 +			bool changed = bt_dbg_get();
  
 -	if (!lmp_ssp_capable(hdev)) {
 -		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 -				      MGMT_STATUS_NOT_SUPPORTED);
 -		goto unlock;
 -	}
 +			bt_dbg_set(false);
  
 -	if (pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {
 -		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 -				      MGMT_STATUS_BUSY);
 -		goto unlock;
 -	}
 +			if (changed)
 +				exp_debug_feature_changed(false, sk);
 +		}
 +#endif
  
 -	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);
 -	if (!cmd) {
 -		err = -ENOMEM;
 -		goto unlock;
 +		if (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {
 +			bool changed = hci_dev_test_flag(hdev,
 +							 HCI_ENABLE_LL_PRIVACY);
 +
 +			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
 +
 +			if (changed)
 +				exp_ll_privacy_feature_changed(false, hdev, sk);
 +		}
 +
 +		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
 +
 +		return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
 +					 MGMT_OP_SET_EXP_FEATURE, 0,
 +					 &rp, sizeof(rp));
  	}
  
 -	hci_req_init(&req, hdev);
 +#ifdef CONFIG_BT_FEATURE_DEBUG
 +	if (!memcmp(cp->uuid, debug_uuid, 16)) {
 +		bool val, changed;
 +		int err;
  
 -	if (bredr_sc_enabled(hdev))
 -		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);
 -	else
 -		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
 +		/* Command requires to use the non-controller index */
 +		if (hdev)
 +			return mgmt_cmd_status(sk, hdev->id,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_INVALID_INDEX);
  
 -	err = hci_req_run_skb(&req, read_local_oob_data_complete);
 -	if (err < 0)
 -		mgmt_pending_remove(cmd);
 +		/* Parameters are limited to a single octet */
 +		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
 +			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_INVALID_PARAMS);
  
 -unlock:
 -	hci_dev_unlock(hdev);
 -	return err;
 -}
 +		/* Only boolean on/off is supported */
 +		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
 +			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_INVALID_PARAMS);
  
 -static int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,
 -			       void *data, u16 len)
 -{
 -	struct mgmt_addr_info *addr = data;
 -	int err;
 +		val = !!cp->param[0];
 +		changed = val ? !bt_dbg_get() : bt_dbg_get();
 +		bt_dbg_set(val);
  
 -	bt_dev_dbg(hdev, "sock %p", sk);
 +		memcpy(rp.uuid, debug_uuid, 16);
 +		rp.flags = cpu_to_le32(val ? BIT(0) : 0);
  
 -	if (!bdaddr_type_is_valid(addr->type))
 -		return mgmt_cmd_complete(sk, hdev->id,
 -					 MGMT_OP_ADD_REMOTE_OOB_DATA,
 -					 MGMT_STATUS_INVALID_PARAMS,
 -					 addr, sizeof(*addr));
 +		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
  
 -	hci_dev_lock(hdev);
 +		err = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,
 +					MGMT_OP_SET_EXP_FEATURE, 0,
 +					&rp, sizeof(rp));
  
 -	if (len == MGMT_ADD_REMOTE_OOB_DATA_SIZE) {
 -		struct mgmt_cp_add_remote_oob_data *cp = data;
 -		u8 status;
 +		if (changed)
 +			exp_debug_feature_changed(val, sk);
  
 -		if (cp->addr.type != BDADDR_BREDR) {
 -			err = mgmt_cmd_complete(sk, hdev->id,
 -						MGMT_OP_ADD_REMOTE_OOB_DATA,
 -						MGMT_STATUS_INVALID_PARAMS,
 -						&cp->addr, sizeof(cp->addr));
 -			goto unlock;
 -		}
 +		return err;
 +	}
 +#endif
  
 -		err = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,
 -					      cp->addr.type, cp->hash,
 -					      cp->rand, NULL, NULL);
 -		if (err < 0)
 -			status = MGMT_STATUS_FAILED;
 -		else
 -			status = MGMT_STATUS_SUCCESS;
 +	if (!memcmp(cp->uuid, rpa_resolution_uuid, 16)) {
 +		bool val, changed;
 +		int err;
 +		u32 flags;
  
 -		err = mgmt_cmd_complete(sk, hdev->id,
 -					MGMT_OP_ADD_REMOTE_OOB_DATA, status,
 -					&cp->addr, sizeof(cp->addr));
 -	} else if (len == MGMT_ADD_REMOTE_OOB_EXT_DATA_SIZE) {
 -		struct mgmt_cp_add_remote_oob_ext_data *cp = data;
 -		u8 *rand192, *hash192, *rand256, *hash256;
 -		u8 status;
 +		/* Command requires to use the controller index */
 +		if (!hdev)
 +			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_INVALID_INDEX);
  
 -		if (bdaddr_type_is_le(cp->addr.type)) {
 +		/* Changes can only be made when controller is powered down */
 +		if (hdev_is_powered(hdev))
 +			return mgmt_cmd_status(sk, hdev->id,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_REJECTED);
 +
 +		/* Parameters are limited to a single octet */
 +		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
 +			return mgmt_cmd_status(sk, hdev->id,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_INVALID_PARAMS);
 +
 +		/* Only boolean on/off is supported */
 +		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
 +			return mgmt_cmd_status(sk, hdev->id,
 +					       MGMT_OP_SET_EXP_FEATURE,
 +					       MGMT_STATUS_INVALID_PARAMS);
 +
 +		val = !!cp->param[0];
 +
 +		if (val) {
 +			changed = !hci_dev_test_flag(hdev,
 +						     HCI_ENABLE_LL_PRIVACY);
 +			hci_dev_set_flag(hdev, HCI_ENABLE_LL_PRIVACY);
 +			hci_dev_clear_flag(hdev, HCI_ADVERTISING);
 +
 +			/* Enable LL privacy + supported settings changed */
 +			flags = BIT(0) | BIT(1);
 +		} else {
 +			changed = hci_dev_test_flag(hdev,
 +						    HCI_ENABLE_LL_PRIVACY);
 +			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
 +
 +			/* Disable LL privacy + supported settings changed */
 +			flags = BIT(1);
 +		}
 +
 +		memcpy(rp.uuid, rpa_resolution_uuid, 16);
 +		rp.flags = cpu_to_le32(flags);
 +
 +		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
 +
 +		err = mgmt_cmd_complete(sk, hdev->id,
 +					MGMT_OP_SET_EXP_FEATURE, 0,
 +					&rp, sizeof(rp));
 +
 +		if (changed)
 +			exp_ll_privacy_feature_changed(val, hdev, sk);
 +
 +		return err;
 +	}
 +
 +	return mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
 +			       MGMT_OP_SET_EXP_FEATURE,
 +			       MGMT_STATUS_NOT_SUPPORTED);
 +}
 +
 +#define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)
 +
 +static int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
 +			    u16 data_len)
 +{
 +	struct mgmt_cp_get_device_flags *cp = data;
 +	struct mgmt_rp_get_device_flags rp;
 +	struct bdaddr_list_with_flags *br_params;
 +	struct hci_conn_params *params;
 +	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 +	u32 current_flags = 0;
 +	u8 status = MGMT_STATUS_INVALID_PARAMS;
 +
 +	bt_dev_dbg(hdev, "Get device flags %pMR (type 0x%x)\n",
 +		   &cp->addr.bdaddr, cp->addr.type);
 +
 +	hci_dev_lock(hdev);
 +
 +	memset(&rp, 0, sizeof(rp));
 +
 +	if (cp->addr.type == BDADDR_BREDR) {
 +		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,
 +							      &cp->addr.bdaddr,
 +							      cp->addr.type);
 +		if (!br_params)
 +			goto done;
 +
 +		current_flags = br_params->current_flags;
 +	} else {
 +		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
 +						le_addr_type(cp->addr.type));
 +
 +		if (!params)
 +			goto done;
 +
 +		current_flags = params->current_flags;
 +	}
 +
 +	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
 +	rp.addr.type = cp->addr.type;
 +	rp.supported_flags = cpu_to_le32(supported_flags);
 +	rp.current_flags = cpu_to_le32(current_flags);
 +
 +	status = MGMT_STATUS_SUCCESS;
 +
 +done:
 +	hci_dev_unlock(hdev);
 +
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,
 +				&rp, sizeof(rp));
 +}
 +
 +static void device_flags_changed(struct sock *sk, struct hci_dev *hdev,
 +				 bdaddr_t *bdaddr, u8 bdaddr_type,
 +				 u32 supported_flags, u32 current_flags)
 +{
 +	struct mgmt_ev_device_flags_changed ev;
 +
 +	bacpy(&ev.addr.bdaddr, bdaddr);
 +	ev.addr.type = bdaddr_type;
 +	ev.supported_flags = cpu_to_le32(supported_flags);
 +	ev.current_flags = cpu_to_le32(current_flags);
 +
 +	mgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);
 +}
 +
 +static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
 +			    u16 len)
 +{
 +	struct mgmt_cp_set_device_flags *cp = data;
 +	struct bdaddr_list_with_flags *br_params;
 +	struct hci_conn_params *params;
 +	u8 status = MGMT_STATUS_INVALID_PARAMS;
 +	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 +	u32 current_flags = __le32_to_cpu(cp->current_flags);
 +
 +	bt_dev_dbg(hdev, "Set device flags %pMR (type 0x%x) = 0x%x",
 +		   &cp->addr.bdaddr, cp->addr.type,
 +		   __le32_to_cpu(current_flags));
 +
 +	if ((supported_flags | current_flags) != supported_flags) {
 +		bt_dev_warn(hdev, "Bad flag given (0x%x) vs supported (0x%0x)",
 +			    current_flags, supported_flags);
 +		goto done;
 +	}
 +
 +	hci_dev_lock(hdev);
 +
 +	if (cp->addr.type == BDADDR_BREDR) {
 +		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,
 +							      &cp->addr.bdaddr,
 +							      cp->addr.type);
 +
 +		if (br_params) {
 +			br_params->current_flags = current_flags;
 +			status = MGMT_STATUS_SUCCESS;
 +		} else {
 +			bt_dev_warn(hdev, "No such BR/EDR device %pMR (0x%x)",
 +				    &cp->addr.bdaddr, cp->addr.type);
 +		}
 +	} else {
 +		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
 +						le_addr_type(cp->addr.type));
 +		if (params) {
 +			params->current_flags = current_flags;
 +			status = MGMT_STATUS_SUCCESS;
 +		} else {
 +			bt_dev_warn(hdev, "No such LE device %pMR (0x%x)",
 +				    &cp->addr.bdaddr,
 +				    le_addr_type(cp->addr.type));
 +		}
 +	}
 +
 +done:
 +	hci_dev_unlock(hdev);
 +
 +	if (status == MGMT_STATUS_SUCCESS)
 +		device_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
 +				     supported_flags, current_flags);
 +
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,
 +				 &cp->addr, sizeof(cp->addr));
 +}
 +
 +static void mgmt_adv_monitor_added(struct sock *sk, struct hci_dev *hdev,
 +				   u16 handle)
 +{
 +	struct mgmt_ev_adv_monitor_added ev;
 +
 +	ev.monitor_handle = cpu_to_le16(handle);
 +
 +	mgmt_event(MGMT_EV_ADV_MONITOR_ADDED, hdev, &ev, sizeof(ev), sk);
 +}
 +
 +static void mgmt_adv_monitor_removed(struct sock *sk, struct hci_dev *hdev,
 +				     u16 handle)
 +{
 +	struct mgmt_ev_adv_monitor_added ev;
 +
 +	ev.monitor_handle = cpu_to_le16(handle);
 +
 +	mgmt_event(MGMT_EV_ADV_MONITOR_REMOVED, hdev, &ev, sizeof(ev), sk);
 +}
 +
 +static int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,
 +				 void *data, u16 len)
 +{
 +	struct adv_monitor *monitor = NULL;
 +	struct mgmt_rp_read_adv_monitor_features *rp = NULL;
 +	int handle, err;
 +	size_t rp_size = 0;
 +	__u32 supported = 0;
 +	__u16 num_handles = 0;
 +	__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];
 +
 +	BT_DBG("request for %s", hdev->name);
 +
 +	hci_dev_lock(hdev);
 +
 +	if (msft_get_features(hdev) & MSFT_FEATURE_MASK_LE_ADV_MONITOR)
 +		supported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;
 +
 +	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle) {
 +		handles[num_handles++] = monitor->handle;
 +	}
 +
 +	hci_dev_unlock(hdev);
 +
 +	rp_size = sizeof(*rp) + (num_handles * sizeof(u16));
 +	rp = kmalloc(rp_size, GFP_KERNEL);
 +	if (!rp)
 +		return -ENOMEM;
 +
 +	/* Once controller-based monitoring is in place, the enabled_features
 +	 * should reflect the use.
 +	 */
 +	rp->supported_features = cpu_to_le32(supported);
 +	rp->enabled_features = 0;
 +	rp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);
 +	rp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;
 +	rp->num_handles = cpu_to_le16(num_handles);
 +	if (num_handles)
 +		memcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));
 +
 +	err = mgmt_cmd_complete(sk, hdev->id,
 +				MGMT_OP_READ_ADV_MONITOR_FEATURES,
 +				MGMT_STATUS_SUCCESS, rp, rp_size);
 +
 +	kfree(rp);
 +
 +	return err;
 +}
 +
 +static int add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,
 +				    void *data, u16 len)
 +{
 +	struct mgmt_cp_add_adv_patterns_monitor *cp = data;
 +	struct mgmt_rp_add_adv_patterns_monitor rp;
 +	struct adv_monitor *m = NULL;
 +	struct adv_pattern *p = NULL;
 +	unsigned int mp_cnt = 0, prev_adv_monitors_cnt;
 +	__u8 cp_ofst = 0, cp_len = 0;
 +	int err, i;
 +
 +	BT_DBG("request for %s", hdev->name);
 +
 +	if (len <= sizeof(*cp) || cp->pattern_count == 0) {
 +		err = mgmt_cmd_status(sk, hdev->id,
 +				      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 +				      MGMT_STATUS_INVALID_PARAMS);
 +		goto failed;
 +	}
 +
 +	m = kmalloc(sizeof(*m), GFP_KERNEL);
 +	if (!m) {
 +		err = -ENOMEM;
 +		goto failed;
 +	}
 +
 +	INIT_LIST_HEAD(&m->patterns);
 +	m->active = false;
 +
 +	for (i = 0; i < cp->pattern_count; i++) {
 +		if (++mp_cnt > HCI_MAX_ADV_MONITOR_NUM_PATTERNS) {
 +			err = mgmt_cmd_status(sk, hdev->id,
 +					      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 +					      MGMT_STATUS_INVALID_PARAMS);
 +			goto failed;
 +		}
 +
 +		cp_ofst = cp->patterns[i].offset;
 +		cp_len = cp->patterns[i].length;
 +		if (cp_ofst >= HCI_MAX_AD_LENGTH ||
 +		    cp_len > HCI_MAX_AD_LENGTH ||
 +		    (cp_ofst + cp_len) > HCI_MAX_AD_LENGTH) {
 +			err = mgmt_cmd_status(sk, hdev->id,
 +					      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 +					      MGMT_STATUS_INVALID_PARAMS);
 +			goto failed;
 +		}
 +
 +		p = kmalloc(sizeof(*p), GFP_KERNEL);
 +		if (!p) {
 +			err = -ENOMEM;
 +			goto failed;
 +		}
 +
 +		p->ad_type = cp->patterns[i].ad_type;
 +		p->offset = cp->patterns[i].offset;
 +		p->length = cp->patterns[i].length;
 +		memcpy(p->value, cp->patterns[i].value, p->length);
 +
 +		INIT_LIST_HEAD(&p->list);
 +		list_add(&p->list, &m->patterns);
 +	}
 +
 +	if (mp_cnt != cp->pattern_count) {
 +		err = mgmt_cmd_status(sk, hdev->id,
 +				      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 +				      MGMT_STATUS_INVALID_PARAMS);
 +		goto failed;
 +	}
 +
 +	hci_dev_lock(hdev);
 +
 +	prev_adv_monitors_cnt = hdev->adv_monitors_cnt;
 +
 +	err = hci_add_adv_monitor(hdev, m);
 +	if (err) {
 +		if (err == -ENOSPC) {
 +			mgmt_cmd_status(sk, hdev->id,
 +					MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 +					MGMT_STATUS_NO_RESOURCES);
 +		}
 +		goto unlock;
 +	}
 +
 +	if (hdev->adv_monitors_cnt > prev_adv_monitors_cnt)
 +		mgmt_adv_monitor_added(sk, hdev, m->handle);
 +
 +	hci_dev_unlock(hdev);
 +
 +	rp.monitor_handle = cpu_to_le16(m->handle);
 +
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 +				 MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
 +
 +unlock:
 +	hci_dev_unlock(hdev);
 +
 +failed:
 +	hci_free_adv_monitor(m);
 +	return err;
 +}
 +
 +static int remove_adv_monitor(struct sock *sk, struct hci_dev *hdev,
 +			      void *data, u16 len)
 +{
 +	struct mgmt_cp_remove_adv_monitor *cp = data;
 +	struct mgmt_rp_remove_adv_monitor rp;
 +	unsigned int prev_adv_monitors_cnt;
 +	u16 handle;
 +	int err;
 +
 +	BT_DBG("request for %s", hdev->name);
 +
 +	hci_dev_lock(hdev);
 +
 +	handle = __le16_to_cpu(cp->monitor_handle);
 +	prev_adv_monitors_cnt = hdev->adv_monitors_cnt;
 +
 +	err = hci_remove_adv_monitor(hdev, handle);
 +	if (err == -ENOENT) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,
 +				      MGMT_STATUS_INVALID_INDEX);
 +		goto unlock;
 +	}
 +
 +	if (hdev->adv_monitors_cnt < prev_adv_monitors_cnt)
 +		mgmt_adv_monitor_removed(sk, hdev, handle);
 +
 +	hci_dev_unlock(hdev);
 +
 +	rp.monitor_handle = cp->monitor_handle;
 +
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,
 +				 MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
 +
 +unlock:
 +	hci_dev_unlock(hdev);
 +	return err;
 +}
 +
 +static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
 +				         u16 opcode, struct sk_buff *skb)
 +{
 +	struct mgmt_rp_read_local_oob_data mgmt_rp;
 +	size_t rp_size = sizeof(mgmt_rp);
 +	struct mgmt_pending_cmd *cmd;
 +
- 	BT_DBG("%s status %u", hdev->name, status);
++	bt_dev_dbg(hdev, "status %u", status);
 +
 +	cmd = pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
 +	if (!cmd)
 +		return;
 +
 +	if (status || !skb) {
 +		mgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +				status ? mgmt_status(status) : MGMT_STATUS_FAILED);
 +		goto remove;
 +	}
 +
 +	memset(&mgmt_rp, 0, sizeof(mgmt_rp));
 +
 +	if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {
 +		struct hci_rp_read_local_oob_data *rp = (void *) skb->data;
 +
 +		if (skb->len < sizeof(*rp)) {
 +			mgmt_cmd_status(cmd->sk, hdev->id,
 +					MGMT_OP_READ_LOCAL_OOB_DATA,
 +					MGMT_STATUS_FAILED);
 +			goto remove;
 +		}
 +
 +		memcpy(mgmt_rp.hash192, rp->hash, sizeof(rp->hash));
 +		memcpy(mgmt_rp.rand192, rp->rand, sizeof(rp->rand));
 +
 +		rp_size -= sizeof(mgmt_rp.hash256) + sizeof(mgmt_rp.rand256);
 +	} else {
 +		struct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;
 +
 +		if (skb->len < sizeof(*rp)) {
 +			mgmt_cmd_status(cmd->sk, hdev->id,
 +					MGMT_OP_READ_LOCAL_OOB_DATA,
 +					MGMT_STATUS_FAILED);
 +			goto remove;
 +		}
 +
 +		memcpy(mgmt_rp.hash192, rp->hash192, sizeof(rp->hash192));
 +		memcpy(mgmt_rp.rand192, rp->rand192, sizeof(rp->rand192));
 +
 +		memcpy(mgmt_rp.hash256, rp->hash256, sizeof(rp->hash256));
 +		memcpy(mgmt_rp.rand256, rp->rand256, sizeof(rp->rand256));
 +	}
 +
 +	mgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +			  MGMT_STATUS_SUCCESS, &mgmt_rp, rp_size);
 +
 +remove:
 +	mgmt_pending_remove(cmd);
 +}
 +
 +static int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,
 +			       void *data, u16 data_len)
 +{
 +	struct mgmt_pending_cmd *cmd;
 +	struct hci_request req;
 +	int err;
 +
- 	BT_DBG("%s", hdev->name);
++	bt_dev_dbg(hdev, "sock %p", sk);
 +
 +	hci_dev_lock(hdev);
 +
 +	if (!hdev_is_powered(hdev)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +				      MGMT_STATUS_NOT_POWERED);
 +		goto unlock;
 +	}
 +
 +	if (!lmp_ssp_capable(hdev)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +				      MGMT_STATUS_NOT_SUPPORTED);
 +		goto unlock;
 +	}
 +
 +	if (pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +				      MGMT_STATUS_BUSY);
 +		goto unlock;
 +	}
 +
 +	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);
 +	if (!cmd) {
 +		err = -ENOMEM;
 +		goto unlock;
 +	}
 +
 +	hci_req_init(&req, hdev);
 +
 +	if (bredr_sc_enabled(hdev))
 +		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);
 +	else
 +		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
 +
 +	err = hci_req_run_skb(&req, read_local_oob_data_complete);
 +	if (err < 0)
 +		mgmt_pending_remove(cmd);
 +
 +unlock:
 +	hci_dev_unlock(hdev);
 +	return err;
 +}
 +
 +static int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,
 +			       void *data, u16 len)
 +{
 +	struct mgmt_addr_info *addr = data;
 +	int err;
 +
- 	BT_DBG("%s ", hdev->name);
++	bt_dev_dbg(hdev, "sock %p", sk);
 +
 +	if (!bdaddr_type_is_valid(addr->type))
 +		return mgmt_cmd_complete(sk, hdev->id,
 +					 MGMT_OP_ADD_REMOTE_OOB_DATA,
 +					 MGMT_STATUS_INVALID_PARAMS,
 +					 addr, sizeof(*addr));
 +
 +	hci_dev_lock(hdev);
 +
 +	if (len == MGMT_ADD_REMOTE_OOB_DATA_SIZE) {
 +		struct mgmt_cp_add_remote_oob_data *cp = data;
 +		u8 status;
 +
 +		if (cp->addr.type != BDADDR_BREDR) {
 +			err = mgmt_cmd_complete(sk, hdev->id,
 +						MGMT_OP_ADD_REMOTE_OOB_DATA,
 +						MGMT_STATUS_INVALID_PARAMS,
 +						&cp->addr, sizeof(cp->addr));
 +			goto unlock;
 +		}
 +
 +		err = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,
 +					      cp->addr.type, cp->hash,
 +					      cp->rand, NULL, NULL);
 +		if (err < 0)
 +			status = MGMT_STATUS_FAILED;
 +		else
 +			status = MGMT_STATUS_SUCCESS;
 +
 +		err = mgmt_cmd_complete(sk, hdev->id,
 +					MGMT_OP_ADD_REMOTE_OOB_DATA, status,
 +					&cp->addr, sizeof(cp->addr));
 +	} else if (len == MGMT_ADD_REMOTE_OOB_EXT_DATA_SIZE) {
 +		struct mgmt_cp_add_remote_oob_ext_data *cp = data;
 +		u8 *rand192, *hash192, *rand256, *hash256;
 +		u8 status;
 +
 +		if (bdaddr_type_is_le(cp->addr.type)) {
  			/* Enforce zero-valued 192-bit parameters as
  			 * long as legacy SMP OOB isn't implemented.
  			 */
@@@ -6508,11 -5827,9 +6550,11 @@@ static int add_device(struct sock *sk, 
  {
  	struct mgmt_cp_add_device *cp = data;
  	u8 auto_conn, addr_type;
 +	struct hci_conn_params *params;
  	int err;
 +	u32 current_flags = 0;
  
- 	BT_DBG("%s", hdev->name);
+ 	bt_dev_dbg(hdev, "sock %p", sk);
  
  	if (!bdaddr_type_is_valid(cp->addr.type) ||
  	    !bacmp(&cp->addr.bdaddr, BDADDR_ANY))
@@@ -8017,15 -6950,8 +8059,15 @@@ static int remove_advertising(struct so
  	struct hci_request req;
  	int err;
  
- 	BT_DBG("%s", hdev->name);
+ 	bt_dev_dbg(hdev, "sock %p", sk);
  
 +	/* Enabling the experimental LL Privay support disables support for
 +	 * advertising.
 +	 */
 +	if (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,
 +				       MGMT_STATUS_NOT_SUPPORTED);
 +
  	hci_dev_lock(hdev);
  
  	if (cp->instance && !hci_find_adv_instance(hdev, cp->instance)) {
* Unmerged path net/bluetooth/mgmt.c
