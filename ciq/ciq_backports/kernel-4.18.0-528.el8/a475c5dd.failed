gfs2: Free quota data objects synchronously

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit a475c5dd16e57c570113eccba51955b5df8bb052
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/a475c5dd.failed

In gfs2_quota_cleanup(), wait for the quota data objects to be freed
before returning.  Otherwise, there is no guarantee that the quota data
objects will be gone when their kmem cache is destroyed.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit a475c5dd16e57c570113eccba51955b5df8bb052)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/quota.c
diff --cc fs/gfs2/quota.c
index f53a03e1dc51,75be0d8e243f..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -112,38 -109,44 +112,46 @@@ static inline void spin_unlock_bucket(u
  static void gfs2_qd_dealloc(struct rcu_head *rcu)
  {
  	struct gfs2_quota_data *qd = container_of(rcu, struct gfs2_quota_data, qd_rcu);
+ 	struct gfs2_sbd *sdp = qd->qd_sbd;
+ 
  	kmem_cache_free(gfs2_quotad_cachep, qd);
+ 	if (atomic_dec_and_test(&sdp->sd_quota_count))
+ 		wake_up(&sdp->sd_kill_wait);
  }
  
 -static void gfs2_qd_dispose(struct gfs2_quota_data *qd)
 +static void gfs2_qd_dispose(struct list_head *list)
  {
 -	struct gfs2_sbd *sdp = qd->qd_sbd;
 +	struct gfs2_quota_data *qd;
 +	struct gfs2_sbd *sdp;
  
 -	spin_lock(&qd_lock);
 -	list_del(&qd->qd_list);
 -	spin_unlock(&qd_lock);
 +	while (!list_empty(list)) {
 +		qd = list_first_entry(list, struct gfs2_quota_data, qd_lru);
 +		sdp = qd->qd_gl->gl_name.ln_sbd;
  
 -	spin_lock_bucket(qd->qd_hash);
 -	hlist_bl_del_rcu(&qd->qd_hlist);
 -	spin_unlock_bucket(qd->qd_hash);
 +		list_del(&qd->qd_lru);
 +
++<<<<<<< HEAD
 +		/* Free from the filesystem-specific list */
 +		spin_lock(&qd_lock);
 +		list_del(&qd->qd_list);
 +		spin_unlock(&qd_lock);
 +
 +		spin_lock_bucket(qd->qd_hash);
 +		hlist_bl_del_rcu(&qd->qd_hlist);
 +		spin_unlock_bucket(qd->qd_hash);
  
 -	if (!gfs2_withdrawn(sdp)) {
  		gfs2_assert_warn(sdp, !qd->qd_change);
  		gfs2_assert_warn(sdp, !qd->qd_slot_count);
  		gfs2_assert_warn(sdp, !qd->qd_bh_count);
 -	}
  
 -	gfs2_glock_put(qd->qd_gl);
 -	call_rcu(&qd->qd_rcu, gfs2_qd_dealloc);
 -}
 -
 -static void gfs2_qd_list_dispose(struct list_head *list)
 -{
 -	struct gfs2_quota_data *qd;
 -
 -	while (!list_empty(list)) {
 -		qd = list_first_entry(list, struct gfs2_quota_data, qd_lru);
 -		list_del(&qd->qd_lru);
 +		gfs2_glock_put(qd->qd_gl);
 +		atomic_dec(&sdp->sd_quota_count);
  
 +		/* Delete it from the common reclaim list */
 +		call_rcu(&qd->qd_rcu, gfs2_qd_dealloc);
++=======
+ 		gfs2_qd_dispose(qd);
++>>>>>>> a475c5dd16e5 (gfs2: Free quota data objects synchronously)
  	}
  }
  
@@@ -1481,8 -1498,14 +1511,19 @@@ void gfs2_quota_cleanup(struct gfs2_sb
  	}
  	spin_unlock(&qd_lock);
  
++<<<<<<< HEAD
 +	gfs2_qd_dispose(&dispose);
 +	gfs2_assert_warn(sdp, !atomic_read(&sdp->sd_quota_count));
++=======
+ 	gfs2_qd_list_dispose(&dispose);
+ 
+ 	wait_event_timeout(sdp->sd_kill_wait,
+ 		(count = atomic_read(&sdp->sd_quota_count)) == 0,
+ 		HZ * 60);
+ 
+ 	if (count != 0)
+ 		fs_err(sdp, "%d left-over quota data objects\n", count);
++>>>>>>> a475c5dd16e5 (gfs2: Free quota data objects synchronously)
  
  	kvfree(sdp->sd_quota_bitmap);
  	sdp->sd_quota_bitmap = NULL;
* Unmerged path fs/gfs2/quota.c
