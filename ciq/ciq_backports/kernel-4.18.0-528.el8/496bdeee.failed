Bluetooth: msft: Use the correct print format

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Kai Ye <yekai13@huawei.com>
commit 496bdeeeda09e84f469f47e66f6d38d3735f802f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/496bdeee.failed

According to Documentation/core-api/printk-formats.rst,
Use the correct print format. Printing an unsigned int value should use %u
instead of %d. Otherwise printk() might end up displaying negative numbers.

	Signed-off-by: Kai Ye <yekai13@huawei.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 496bdeeeda09e84f469f47e66f6d38d3735f802f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/msft.c
diff --cc net/bluetooth/msft.c
index 910ec68f8aa5,b4bfae41e8a5..000000000000
--- a/net/bluetooth/msft.c
+++ b/net/bluetooth/msft.c
@@@ -148,7 -275,338 +148,342 @@@ __u64 msft_get_features(struct hci_dev 
  {
  	struct msft_data *msft = hdev->msft_data;
  
++<<<<<<< HEAD
 +	return  msft ? msft->features : 0;
++=======
+ 	return msft ? msft->features : 0;
+ }
+ 
+ /* is_mgmt = true matches the handle exposed to userspace via mgmt.
+  * is_mgmt = false matches the handle used by the msft controller.
+  * This function requires the caller holds hdev->lock
+  */
+ static struct msft_monitor_advertisement_handle_data *msft_find_handle_data
+ 				(struct hci_dev *hdev, u16 handle, bool is_mgmt)
+ {
+ 	struct msft_monitor_advertisement_handle_data *entry;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	list_for_each_entry(entry, &msft->handle_map, list) {
+ 		if (is_mgmt && entry->mgmt_handle == handle)
+ 			return entry;
+ 		if (!is_mgmt && entry->msft_handle == handle)
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void msft_le_monitor_advertisement_cb(struct hci_dev *hdev,
+ 					     u8 status, u16 opcode,
+ 					     struct sk_buff *skb)
+ {
+ 	struct msft_rp_le_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	monitor = idr_find(&hdev->adv_monitors_idr, msft->pending_add_handle);
+ 	if (!monitor) {
+ 		bt_dev_err(hdev, "msft add advmon: monitor %u is not found!",
+ 			   msft->pending_add_handle);
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	if (status)
+ 		goto unlock;
+ 
+ 	rp = (struct msft_rp_le_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data = kmalloc(sizeof(*handle_data), GFP_KERNEL);
+ 	if (!handle_data) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data->mgmt_handle = monitor->handle;
+ 	handle_data->msft_handle = rp->handle;
+ 	INIT_LIST_HEAD(&handle_data->list);
+ 	list_add(&handle_data->list, &msft->handle_map);
+ 
+ 	monitor->state = ADV_MONITOR_STATE_OFFLOADED;
+ 
+ unlock:
+ 	if (status && monitor)
+ 		hci_free_adv_monitor(hdev, monitor);
+ 
+ 	/* If in restart/reregister sequence, keep registering. */
+ 	if (msft->reregistering)
+ 		reregister_monitor_on_restart(hdev,
+ 					      msft->pending_add_handle + 1);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	if (!msft->reregistering)
+ 		hci_add_adv_patterns_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_cancel_monitor_advertisement_cb(struct hci_dev *hdev,
+ 						    u8 status, u16 opcode,
+ 						    struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement *cp;
+ 	struct msft_rp_le_cancel_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 	bool pending;
+ 
+ 	if (status)
+ 		goto done;
+ 
+ 	rp = (struct msft_rp_le_cancel_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto done;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	handle_data = msft_find_handle_data(hdev, cp->handle, false);
+ 
+ 	if (handle_data) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr,
+ 				   handle_data->mgmt_handle);
+ 		if (monitor)
+ 			hci_free_adv_monitor(hdev, monitor);
+ 
+ 		list_del(&handle_data->list);
+ 		kfree(handle_data);
+ 	}
+ 
+ 	/* If remove all monitors is required, we need to continue the process
+ 	 * here because the earlier it was paused when waiting for the
+ 	 * response from controller.
+ 	 */
+ 	if (msft->pending_remove_handle == 0) {
+ 		pending = hci_remove_all_adv_monitor(hdev, &err);
+ 		if (pending) {
+ 			hci_dev_unlock(hdev);
+ 			return;
+ 		}
+ 
+ 		if (err)
+ 			status = HCI_ERROR_UNSPECIFIED;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ done:
+ 	hci_remove_adv_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_set_advertisement_filter_enable_cb(struct hci_dev *hdev,
+ 						       u8 status, u16 opcode,
+ 						       struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_set_advertisement_filter_enable *cp;
+ 	struct msft_rp_le_set_advertisement_filter_enable *rp;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	rp = (struct msft_rp_le_set_advertisement_filter_enable *)skb->data;
+ 	if (skb->len < sizeof(*rp))
+ 		return;
+ 
+ 	/* Error 0x0C would be returned if the filter enabled status is
+ 	 * already set to whatever we were trying to set.
+ 	 * Although the default state should be disabled, some controller set
+ 	 * the initial value to enabled. Because there is no way to know the
+ 	 * actual initial value before sending this command, here we also treat
+ 	 * error 0x0C as success.
+ 	 */
+ 	if (status != 0x00 && status != 0x0C)
+ 		return;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	msft->filter_enabled = cp->enable;
+ 
+ 	if (status == 0x0C)
+ 		bt_dev_warn(hdev, "MSFT filter_enable is already %s",
+ 			    cp->enable ? "on" : "off");
+ 
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static bool msft_monitor_rssi_valid(struct adv_monitor *monitor)
+ {
+ 	struct adv_rssi_thresholds *r = &monitor->rssi;
+ 
+ 	if (r->high_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->high_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX ||
+ 	    r->low_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->low_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX)
+ 		return false;
+ 
+ 	/* High_threshold_timeout is not supported,
+ 	 * once high_threshold is reached, events are immediately reported.
+ 	 */
+ 	if (r->high_threshold_timeout != 0)
+ 		return false;
+ 
+ 	if (r->low_threshold_timeout > MSFT_RSSI_LOW_TIMEOUT_MAX)
+ 		return false;
+ 
+ 	/* Sampling period from 0x00 to 0xFF are all allowed */
+ 	return true;
+ }
+ 
+ static bool msft_monitor_pattern_valid(struct adv_monitor *monitor)
+ {
+ 	return msft_monitor_rssi_valid(monitor);
+ 	/* No additional check needed for pattern-based monitor */
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ static int __msft_add_monitor_pattern(struct hci_dev *hdev,
+ 				      struct adv_monitor *monitor)
+ {
+ 	struct msft_cp_le_monitor_advertisement *cp;
+ 	struct msft_le_monitor_advertisement_pattern_data *pattern_data;
+ 	struct msft_le_monitor_advertisement_pattern *pattern;
+ 	struct adv_pattern *entry;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	size_t total_size = sizeof(*cp) + sizeof(*pattern_data);
+ 	ptrdiff_t offset = 0;
+ 	u8 pattern_count = 0;
+ 	int err = 0;
+ 
+ 	if (!msft_monitor_pattern_valid(monitor))
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern_count++;
+ 		total_size += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	cp = kmalloc(total_size, GFP_KERNEL);
+ 	if (!cp)
+ 		return -ENOMEM;
+ 
+ 	cp->sub_opcode = MSFT_OP_LE_MONITOR_ADVERTISEMENT;
+ 	cp->rssi_high = monitor->rssi.high_threshold;
+ 	cp->rssi_low = monitor->rssi.low_threshold;
+ 	cp->rssi_low_interval = (u8)monitor->rssi.low_threshold_timeout;
+ 	cp->rssi_sampling_period = monitor->rssi.sampling_period;
+ 
+ 	cp->cond_type = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;
+ 
+ 	pattern_data = (void *)cp->data;
+ 	pattern_data->count = pattern_count;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern = (void *)(pattern_data->data + offset);
+ 		/* the length also includes data_type and offset */
+ 		pattern->length = entry->length + 2;
+ 		pattern->data_type = entry->ad_type;
+ 		pattern->start_byte = entry->offset;
+ 		memcpy(pattern->pattern, entry->value, entry->length);
+ 		offset += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, total_size, cp);
+ 	err = hci_req_run_skb(&req, msft_le_monitor_advertisement_cb);
+ 	kfree(cp);
+ 
+ 	if (!err)
+ 		msft->pending_add_handle = monitor->handle;
+ 
+ 	return err;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	return __msft_add_monitor_pattern(hdev, monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement cp;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err = 0;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	handle_data = msft_find_handle_data(hdev, monitor->handle, true);
+ 
+ 	/* If no matched handle, just remove without telling controller */
+ 	if (!handle_data)
+ 		return -ENOENT;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;
+ 	cp.handle = handle_data->msft_handle;
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, sizeof(cp), &cp);
+ 	err = hci_req_run_skb(&req, msft_le_cancel_monitor_advertisement_cb);
+ 
+ 	if (!err)
+ 		msft->pending_remove_handle = handle;
+ 
+ 	return err;
+ }
+ 
+ void msft_req_add_set_filter_enable(struct hci_request *req, bool enable)
+ {
+ 	struct hci_dev *hdev = req->hdev;
+ 	struct msft_cp_le_set_advertisement_filter_enable cp;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_SET_ADVERTISEMENT_FILTER_ENABLE;
+ 	cp.enable = enable;
+ 
+ 	hci_req_add(req, hdev->msft_opcode, sizeof(cp), &cp);
+ }
+ 
+ int msft_set_filter_enable(struct hci_dev *hdev, bool enable)
+ {
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	hci_req_init(&req, hdev);
+ 	msft_req_add_set_filter_enable(&req, enable);
+ 	err = hci_req_run_skb(&req, msft_le_set_advertisement_filter_enable_cb);
+ 
+ 	return err;
++>>>>>>> 496bdeeeda09 (Bluetooth: msft: Use the correct print format)
  }
  
  bool msft_curve_validity(struct hci_dev *hdev)
* Unmerged path net/bluetooth/msft.c
