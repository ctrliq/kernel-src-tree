Bluetooth: disable advertisement filters during suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Howard Chung <howardchung@google.com>
commit bf6a4e30ffbd9e9ef8934582feb937f6532f8b68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/bf6a4e30.failed

This adds logic to disable and reenable advertisement filters during
suspend and resume. After this patch, we would only receive packets from
devices in allow list during suspend.

	Signed-off-by: Howard Chung <howardchung@google.com>
	Reviewed-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit bf6a4e30ffbd9e9ef8934582feb937f6532f8b68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_request.c
#	net/bluetooth/msft.c
#	net/bluetooth/msft.h
diff --cc net/bluetooth/hci_request.c
index 4614f7a7d25e,e55976db4403..000000000000
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@@ -1337,6 -1325,12 +1361,15 @@@ void hci_req_prepare_suspend(struct hci
  			hci_req_add_le_scan_disable(&req, false);
  		}
  
++<<<<<<< HEAD
++=======
+ 		/* Disable advertisement filters */
+ 		hci_req_add_set_adv_filter_enable(&req, false);
+ 
+ 		/* Mark task needing completion */
+ 		set_bit(SUSPEND_SCAN_DISABLE, hdev->suspend_tasks);
+ 
++>>>>>>> bf6a4e30ffbd (Bluetooth: disable advertisement filters during suspend)
  		/* Prevent disconnects from causing scanning to be re-enabled */
  		hdev->scanning_paused = true;
  
@@@ -1370,12 -1364,11 +1403,14 @@@
  		hdev->suspended = false;
  		hdev->scanning_paused = false;
  
 +		/* Clear any event filters and restore scan state */
  		hci_req_clear_event_filter(&req);
 +		__hci_req_update_scan(&req);
 +
  		/* Reset passive/background scanning to normal */
  		__hci_update_background_scan(&req);
+ 		/* Enable all of the advertisement filters */
+ 		hci_req_add_set_adv_filter_enable(&req, true);
  
  		/* Unpause directed advertising */
  		hdev->advertising_paused = false;
diff --cc net/bluetooth/msft.c
index 910ec68f8aa5,47b104f318e9..000000000000
--- a/net/bluetooth/msft.c
+++ b/net/bluetooth/msft.c
@@@ -148,10 -272,336 +148,335 @@@ __u64 msft_get_features(struct hci_dev 
  {
  	struct msft_data *msft = hdev->msft_data;
  
 -	return msft ? msft->features : 0;
 +	return  msft ? msft->features : 0;
  }
  
 -/* is_mgmt = true matches the handle exposed to userspace via mgmt.
 - * is_mgmt = false matches the handle used by the msft controller.
 - * This function requires the caller holds hdev->lock
 - */
 -static struct msft_monitor_advertisement_handle_data *msft_find_handle_data
 -				(struct hci_dev *hdev, u16 handle, bool is_mgmt)
 +bool msft_curve_validity(struct hci_dev *hdev)
  {
++<<<<<<< HEAD
 +	return hdev->msft_curve_validity;
++=======
+ 	struct msft_monitor_advertisement_handle_data *entry;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	list_for_each_entry(entry, &msft->handle_map, list) {
+ 		if (is_mgmt && entry->mgmt_handle == handle)
+ 			return entry;
+ 		if (!is_mgmt && entry->msft_handle == handle)
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void msft_le_monitor_advertisement_cb(struct hci_dev *hdev,
+ 					     u8 status, u16 opcode,
+ 					     struct sk_buff *skb)
+ {
+ 	struct msft_rp_le_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	monitor = idr_find(&hdev->adv_monitors_idr, msft->pending_add_handle);
+ 	if (!monitor) {
+ 		bt_dev_err(hdev, "msft add advmon: monitor %d is not found!",
+ 			   msft->pending_add_handle);
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	if (status)
+ 		goto unlock;
+ 
+ 	rp = (struct msft_rp_le_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data = kmalloc(sizeof(*handle_data), GFP_KERNEL);
+ 	if (!handle_data) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data->mgmt_handle = monitor->handle;
+ 	handle_data->msft_handle = rp->handle;
+ 	INIT_LIST_HEAD(&handle_data->list);
+ 	list_add(&handle_data->list, &msft->handle_map);
+ 
+ 	monitor->state = ADV_MONITOR_STATE_OFFLOADED;
+ 
+ unlock:
+ 	if (status && monitor)
+ 		hci_free_adv_monitor(hdev, monitor);
+ 
+ 	/* If in restart/reregister sequence, keep registering. */
+ 	if (msft->reregistering)
+ 		reregister_monitor_on_restart(hdev,
+ 					      msft->pending_add_handle + 1);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	if (!msft->reregistering)
+ 		hci_add_adv_patterns_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_cancel_monitor_advertisement_cb(struct hci_dev *hdev,
+ 						    u8 status, u16 opcode,
+ 						    struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement *cp;
+ 	struct msft_rp_le_cancel_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 	bool pending;
+ 
+ 	if (status)
+ 		goto done;
+ 
+ 	rp = (struct msft_rp_le_cancel_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto done;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	handle_data = msft_find_handle_data(hdev, cp->handle, false);
+ 
+ 	if (handle_data) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr,
+ 				   handle_data->mgmt_handle);
+ 		if (monitor)
+ 			hci_free_adv_monitor(hdev, monitor);
+ 
+ 		list_del(&handle_data->list);
+ 		kfree(handle_data);
+ 	}
+ 
+ 	/* If remove all monitors is required, we need to continue the process
+ 	 * here because the earlier it was paused when waiting for the
+ 	 * response from controller.
+ 	 */
+ 	if (msft->pending_remove_handle == 0) {
+ 		pending = hci_remove_all_adv_monitor(hdev, &err);
+ 		if (pending) {
+ 			hci_dev_unlock(hdev);
+ 			return;
+ 		}
+ 
+ 		if (err)
+ 			status = HCI_ERROR_UNSPECIFIED;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ done:
+ 	hci_remove_adv_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_set_advertisement_filter_enable_cb(struct hci_dev *hdev,
+ 						       u8 status, u16 opcode,
+ 						       struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_set_advertisement_filter_enable *cp;
+ 	struct msft_rp_le_set_advertisement_filter_enable *rp;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	rp = (struct msft_rp_le_set_advertisement_filter_enable *)skb->data;
+ 	if (skb->len < sizeof(*rp))
+ 		return;
+ 
+ 	/* Error 0x0C would be returned if the filter enabled status is
+ 	 * already set to whatever we were trying to set.
+ 	 * Although the default state should be disabled, some controller set
+ 	 * the initial value to enabled. Because there is no way to know the
+ 	 * actual initial value before sending this command, here we also treat
+ 	 * error 0x0C as success.
+ 	 */
+ 	if (status != 0x00 && status != 0x0C)
+ 		return;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	msft->filter_enabled = cp->enable;
+ 
+ 	if (status == 0x0C)
+ 		bt_dev_warn(hdev, "MSFT filter_enable is already %s",
+ 			    cp->enable ? "on" : "off");
+ 
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static bool msft_monitor_rssi_valid(struct adv_monitor *monitor)
+ {
+ 	struct adv_rssi_thresholds *r = &monitor->rssi;
+ 
+ 	if (r->high_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->high_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX ||
+ 	    r->low_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->low_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX)
+ 		return false;
+ 
+ 	/* High_threshold_timeout is not supported,
+ 	 * once high_threshold is reached, events are immediately reported.
+ 	 */
+ 	if (r->high_threshold_timeout != 0)
+ 		return false;
+ 
+ 	if (r->low_threshold_timeout > MSFT_RSSI_LOW_TIMEOUT_MAX)
+ 		return false;
+ 
+ 	/* Sampling period from 0x00 to 0xFF are all allowed */
+ 	return true;
+ }
+ 
+ static bool msft_monitor_pattern_valid(struct adv_monitor *monitor)
+ {
+ 	return msft_monitor_rssi_valid(monitor);
+ 	/* No additional check needed for pattern-based monitor */
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ static int __msft_add_monitor_pattern(struct hci_dev *hdev,
+ 				      struct adv_monitor *monitor)
+ {
+ 	struct msft_cp_le_monitor_advertisement *cp;
+ 	struct msft_le_monitor_advertisement_pattern_data *pattern_data;
+ 	struct msft_le_monitor_advertisement_pattern *pattern;
+ 	struct adv_pattern *entry;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	size_t total_size = sizeof(*cp) + sizeof(*pattern_data);
+ 	ptrdiff_t offset = 0;
+ 	u8 pattern_count = 0;
+ 	int err = 0;
+ 
+ 	if (!msft_monitor_pattern_valid(monitor))
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern_count++;
+ 		total_size += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	cp = kmalloc(total_size, GFP_KERNEL);
+ 	if (!cp)
+ 		return -ENOMEM;
+ 
+ 	cp->sub_opcode = MSFT_OP_LE_MONITOR_ADVERTISEMENT;
+ 	cp->rssi_high = monitor->rssi.high_threshold;
+ 	cp->rssi_low = monitor->rssi.low_threshold;
+ 	cp->rssi_low_interval = (u8)monitor->rssi.low_threshold_timeout;
+ 	cp->rssi_sampling_period = monitor->rssi.sampling_period;
+ 
+ 	cp->cond_type = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;
+ 
+ 	pattern_data = (void *)cp->data;
+ 	pattern_data->count = pattern_count;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern = (void *)(pattern_data->data + offset);
+ 		/* the length also includes data_type and offset */
+ 		pattern->length = entry->length + 2;
+ 		pattern->data_type = entry->ad_type;
+ 		pattern->start_byte = entry->offset;
+ 		memcpy(pattern->pattern, entry->value, entry->length);
+ 		offset += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, total_size, cp);
+ 	err = hci_req_run_skb(&req, msft_le_monitor_advertisement_cb);
+ 	kfree(cp);
+ 
+ 	if (!err)
+ 		msft->pending_add_handle = monitor->handle;
+ 
+ 	return err;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	return __msft_add_monitor_pattern(hdev, monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement cp;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err = 0;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	handle_data = msft_find_handle_data(hdev, monitor->handle, true);
+ 
+ 	/* If no matched handle, just remove without telling controller */
+ 	if (!handle_data)
+ 		return -ENOENT;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;
+ 	cp.handle = handle_data->msft_handle;
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, sizeof(cp), &cp);
+ 	err = hci_req_run_skb(&req, msft_le_cancel_monitor_advertisement_cb);
+ 
+ 	if (!err)
+ 		msft->pending_remove_handle = handle;
+ 
+ 	return err;
+ }
+ 
+ void msft_req_add_set_filter_enable(struct hci_request *req, bool enable)
+ {
+ 	struct hci_dev *hdev = req->hdev;
+ 	struct msft_cp_le_set_advertisement_filter_enable cp;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_SET_ADVERTISEMENT_FILTER_ENABLE;
+ 	cp.enable = enable;
+ 
+ 	hci_req_add(req, hdev->msft_opcode, sizeof(cp), &cp);
+ }
+ 
+ int msft_set_filter_enable(struct hci_dev *hdev, bool enable)
+ {
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	hci_req_init(&req, hdev);
+ 	msft_req_add_set_filter_enable(&req, enable);
+ 	err = hci_req_run_skb(&req, msft_le_set_advertisement_filter_enable_cb);
+ 
+ 	return err;
++>>>>>>> bf6a4e30ffbd (Bluetooth: disable advertisement filters during suspend)
  }
diff --cc net/bluetooth/msft.h
index d114e67c6ccd,88ed613dfa08..000000000000
--- a/net/bluetooth/msft.h
+++ b/net/bluetooth/msft.h
@@@ -16,7 -17,11 +16,15 @@@ void msft_do_open(struct hci_dev *hdev)
  void msft_do_close(struct hci_dev *hdev);
  void msft_vendor_evt(struct hci_dev *hdev, struct sk_buff *skb);
  __u64 msft_get_features(struct hci_dev *hdev);
++<<<<<<< HEAD
 +bool msft_curve_validity(struct hci_dev *hdev);
++=======
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor);
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle);
+ void msft_req_add_set_filter_enable(struct hci_request *req, bool enable);
+ int msft_set_filter_enable(struct hci_dev *hdev, bool enable);
++>>>>>>> bf6a4e30ffbd (Bluetooth: disable advertisement filters during suspend)
  
  #else
  
@@@ -24,10 -34,24 +32,21 @@@ static inline void msft_do_open(struct 
  static inline void msft_do_close(struct hci_dev *hdev) {}
  static inline void msft_vendor_evt(struct hci_dev *hdev, struct sk_buff *skb) {}
  static inline __u64 msft_get_features(struct hci_dev *hdev) { return 0; }
 -static inline int msft_add_monitor_pattern(struct hci_dev *hdev,
 -					   struct adv_monitor *monitor)
 -{
 -	return -EOPNOTSUPP;
 -}
  
 -static inline int msft_remove_monitor(struct hci_dev *hdev,
 -				      struct adv_monitor *monitor,
 -				      u16 handle)
 +static inline bool msft_curve_validity(struct hci_dev *hdev)
  {
++<<<<<<< HEAD
 +	return false;
++=======
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline void msft_req_add_set_filter_enable(struct hci_request *req,
+ 						  bool enable) {}
+ static inline int msft_set_filter_enable(struct hci_dev *hdev, bool enable)
+ {
+ 	return -EOPNOTSUPP;
++>>>>>>> bf6a4e30ffbd (Bluetooth: disable advertisement filters during suspend)
  }
  
  #endif
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 13faec7ac058..0f97314649f7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -105,6 +105,8 @@ enum suspend_tasks {
 	SUSPEND_POWERING_DOWN,
 
 	SUSPEND_PREPARE_NOTIFIER,
+
+	SUSPEND_SET_ADV_FILTER,
 	__SUSPEND_NUM_TASKS
 };
 
* Unmerged path net/bluetooth/hci_request.c
* Unmerged path net/bluetooth/msft.c
* Unmerged path net/bluetooth/msft.h
