Bluetooth: btqca: Use NVM files based on SoC ID for WCN3991

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Venkata Lakshmi Narayana Gubba <gubbaven@codeaurora.org>
commit 059924fdf6c1c31a7c1aa1915884e23f4313dde2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/059924fd.failed

This change will allow to use different NVM file based
on WCN3991 BT SoC ID.Need to use different NVM file based on
fab location for WCN3991 BT SoC.

	Signed-off-by: Venkata Lakshmi Narayana Gubba <gubbaven@codeaurora.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 059924fdf6c1c31a7c1aa1915884e23f4313dde2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btqca.c
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/btqca.c
index de1f7b0bbc68,f85a55add9be..000000000000
--- a/drivers/bluetooth/btqca.c
+++ b/drivers/bluetooth/btqca.c
@@@ -82,10 -68,10 +81,17 @@@ int qca_read_soc_version(struct hci_de
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (soc_type == QCA_WCN3991)
 +		memmove(&edl->data, &edl->data[1], sizeof(*ver));
 +
 +	ver = (struct qca_btsoc_version *)(edl->data);
++=======
+ 	if (soc_type >= QCA_WCN3991)
+ 		memcpy(ver, edl->data + 1, sizeof(*ver));
+ 	else
+ 		memcpy(ver, &edl->data, sizeof(*ver));
++>>>>>>> 059924fdf6c1 (Bluetooth: btqca: Use NVM files based on SoC ID for WCN3991)
  
  	bt_dev_info(hdev, "QCA Product ID   :0x%08x",
  		    le32_to_cpu(ver->product_id));
@@@ -559,9 -489,18 +564,24 @@@ int qca_uart_setup(struct hci_dev *hdev
  	if (firmware_name)
  		snprintf(config.fwname, sizeof(config.fwname),
  			 "qca/%s", firmware_name);
++<<<<<<< HEAD
 +	else if (qca_is_wcn399x(soc_type))
 +		snprintf(config.fwname, sizeof(config.fwname),
 +			 "qca/crnv%02x.bin", rom_ver);
++=======
+ 	else if (qca_is_wcn399x(soc_type)) {
+ 		if (ver.soc_id == QCA_WCN3991_SOC_ID) {
+ 			snprintf(config.fwname, sizeof(config.fwname),
+ 				 "qca/crnv%02xu.bin", rom_ver);
+ 		} else {
+ 			snprintf(config.fwname, sizeof(config.fwname),
+ 				 "qca/crnv%02x.bin", rom_ver);
+ 		}
+ 	}
+ 	else if (soc_type == QCA_QCA6390)
+ 		snprintf(config.fwname, sizeof(config.fwname),
+ 			 "qca/htnv%02x.bin", rom_ver);
++>>>>>>> 059924fdf6c1 (Bluetooth: btqca: Use NVM files based on SoC ID for WCN3991)
  	else
  		snprintf(config.fwname, sizeof(config.fwname),
  			 "qca/nvm_%08x.bin", soc_ver);
diff --cc drivers/bluetooth/hci_qca.c
index a33d551040f0,4a963682c702..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -1710,11 -1684,7 +1710,15 @@@ retry
  	if (qca_is_wcn399x(soc_type)) {
  		set_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);
  
++<<<<<<< HEAD
 +		ret = qca_wcn3990_init(hu);
 +		if (ret)
 +			return ret;
 +
 +		ret = qca_read_soc_version(hdev, &soc_ver, soc_type);
++=======
+ 		ret = qca_read_soc_version(hdev, &ver, soc_type);
++>>>>>>> 059924fdf6c1 (Bluetooth: btqca: Use NVM files based on SoC ID for WCN3991)
  		if (ret)
  			goto out;
  	} else {
* Unmerged path drivers/bluetooth/btqca.c
diff --git a/drivers/bluetooth/btqca.h b/drivers/bluetooth/btqca.h
index 1cbbc00fca46..cf81a56eaf1c 100644
--- a/drivers/bluetooth/btqca.h
+++ b/drivers/bluetooth/btqca.h
@@ -48,6 +48,18 @@
 #define QCA_HCI_CC_OPCODE		0xFC00
 #define QCA_HCI_CC_SUCCESS		0x00
 
+#define QCA_WCN3991_SOC_ID		(0x40014320)
+
+/* QCA chipset version can be decided by patch and SoC
+ * version, combination with upper 2 bytes from SoC
+ * and lower 2 bytes from patch will be used.
+ */
+#define get_soc_ver(soc_id, rom_ver)	\
+	((le32_to_cpu(soc_id) << 16) | (le16_to_cpu(rom_ver)))
+
+#define QCA_FW_BUILD_VER_LEN		255
+
+
 enum qca_baudrate {
 	QCA_BAUDRATE_115200 	= 0,
 	QCA_BAUDRATE_57600,
@@ -149,9 +161,9 @@ enum qca_btsoc_type {
 
 int qca_set_bdaddr_rome(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 int qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,
-		   enum qca_btsoc_type soc_type, u32 soc_ver,
+		   enum qca_btsoc_type soc_type, struct qca_btsoc_version ver,
 		   const char *firmware_name);
-int qca_read_soc_version(struct hci_dev *hdev, u32 *soc_version,
+int qca_read_soc_version(struct hci_dev *hdev, struct qca_btsoc_version *ver,
 			 enum qca_btsoc_type);
 int qca_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 int qca_send_pre_shutdown_cmd(struct hci_dev *hdev);
@@ -168,13 +180,15 @@ static inline int qca_set_bdaddr_rome(struct hci_dev *hdev, const bdaddr_t *bdad
 }
 
 static inline int qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,
-				 enum qca_btsoc_type soc_type, u32 soc_ver,
+				 enum qca_btsoc_type soc_type,
+				 struct qca_btsoc_version ver,
 				 const char *firmware_name)
 {
 	return -EOPNOTSUPP;
 }
 
-static inline int qca_read_soc_version(struct hci_dev *hdev, u32 *soc_version,
+static inline int qca_read_soc_version(struct hci_dev *hdev,
+				       struct qca_btsoc_version *ver,
 				       enum qca_btsoc_type)
 {
 	return -EOPNOTSUPP;
* Unmerged path drivers/bluetooth/hci_qca.c
