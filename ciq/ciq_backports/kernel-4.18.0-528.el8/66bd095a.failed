Bluetooth: advmon offload MSFT remove monitor

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-528.el8
commit-author Archie Pusaka <apusaka@chromium.org>
commit 66bd095ab5d408af106808cce302406542f70f65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-528.el8/66bd095a.failed

Implements the monitor removal functionality for advertising monitor
offloading to MSFT controllers. Supply handle = 0 to remove all
monitors.

	Signed-off-by: Archie Pusaka <apusaka@chromium.org>
	Reviewed-by: Miao-chen Chou <mcchou@chromium.org>
	Reviewed-by: Yun-Hao Chung <howardchung@google.com>
	Reported-by: kernel test robot <lkp@intel.com>
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 66bd095ab5d408af106808cce302406542f70f65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
#	net/bluetooth/hci_core.c
#	net/bluetooth/mgmt.c
#	net/bluetooth/msft.c
#	net/bluetooth/msft.h
diff --cc include/net/bluetooth/hci_core.h
index 13faec7ac058,29cfc6a2d689..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -1354,10 -1332,15 +1354,20 @@@ int hci_remove_adv_instance(struct hci_
  void hci_adv_instances_set_rpa_expired(struct hci_dev *hdev, bool rpa_expired);
  
  void hci_adv_monitors_clear(struct hci_dev *hdev);
++<<<<<<< HEAD
 +void hci_free_adv_monitor(struct adv_monitor *monitor);
 +int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor);
 +int hci_remove_adv_monitor(struct hci_dev *hdev, u16 handle);
++=======
+ void hci_free_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor);
+ int hci_add_adv_patterns_monitor_complete(struct hci_dev *hdev, u8 status);
+ int hci_remove_adv_monitor_complete(struct hci_dev *hdev, u8 status);
+ bool hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			int *err);
+ bool hci_remove_single_adv_monitor(struct hci_dev *hdev, u16 handle, int *err);
+ bool hci_remove_all_adv_monitor(struct hci_dev *hdev, int *err);
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  bool hci_is_adv_monitoring(struct hci_dev *hdev);
 -int hci_get_adv_monitor_offload_ext(struct hci_dev *hdev);
  
  void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
  
@@@ -1831,7 -1815,10 +1841,13 @@@ void mgmt_advertising_added(struct soc
  			    u8 instance);
  void mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,
  			      u8 instance);
+ void mgmt_adv_monitor_removed(struct hci_dev *hdev, u16 handle);
  int mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip);
++<<<<<<< HEAD
++=======
+ int mgmt_add_adv_patterns_monitor_complete(struct hci_dev *hdev, u8 status);
+ int mgmt_remove_adv_monitor_complete(struct hci_dev *hdev, u8 status);
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  
  u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
  		      u16 to_multiplier);
diff --cc net/bluetooth/hci_core.c
index 1127409261f8,b0a63f643a07..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -3099,8 -3083,23 +3112,28 @@@ void hci_free_adv_monitor(struct hci_de
  	kfree(monitor);
  }
  
++<<<<<<< HEAD
 +/* This function requires the caller holds hdev->lock */
 +int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor)
++=======
+ int hci_add_adv_patterns_monitor_complete(struct hci_dev *hdev, u8 status)
+ {
+ 	return mgmt_add_adv_patterns_monitor_complete(hdev, status);
+ }
+ 
+ int hci_remove_adv_monitor_complete(struct hci_dev *hdev, u8 status)
+ {
+ 	return mgmt_remove_adv_monitor_complete(hdev, status);
+ }
+ 
+ /* Assigns handle to a monitor, and if offloading is supported and power is on,
+  * also attempts to forward the request to the controller.
+  * Returns true if request is forwarded (result is pending), false otherwise.
+  * This function requires the caller holds hdev->lock.
+  */
+ bool hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			 int *err)
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  {
  	int min, max, handle;
  
@@@ -3111,50 -3114,120 +3144,105 @@@
  	max = HCI_MIN_ADV_MONITOR_HANDLE + HCI_MAX_ADV_MONITOR_NUM_HANDLES;
  	handle = idr_alloc(&hdev->adv_monitors_idr, monitor, min, max,
  			   GFP_KERNEL);
 -	if (handle < 0) {
 -		*err = handle;
 -		return false;
 -	}
 +	if (handle < 0)
 +		return handle;
  
 +	hdev->adv_monitors_cnt++;
  	monitor->handle = handle;
  
 -	if (!hdev_is_powered(hdev))
 -		return false;
 -
 -	switch (hci_get_adv_monitor_offload_ext(hdev)) {
 -	case HCI_ADV_MONITOR_EXT_NONE:
 -		hci_update_background_scan(hdev);
 -		bt_dev_dbg(hdev, "%s add monitor status %d", hdev->name, *err);
 -		/* Message was not forwarded to controller - not an error */
 -		return false;
 -	case HCI_ADV_MONITOR_EXT_MSFT:
 -		*err = msft_add_monitor_pattern(hdev, monitor);
 -		bt_dev_dbg(hdev, "%s add monitor msft status %d", hdev->name,
 -			   *err);
 -		break;
 -	}
 +	hci_update_background_scan(hdev);
  
 -	return (*err == 0);
 +	return 0;
  }
  
- static int free_adv_monitor(int id, void *ptr, void *data)
+ /* Attempts to tell the controller and free the monitor. If somehow the
+  * controller doesn't have a corresponding handle, remove anyway.
+  * Returns true if request is forwarded (result is pending), false otherwise.
+  * This function requires the caller holds hdev->lock.
+  */
+ static bool hci_remove_adv_monitor(struct hci_dev *hdev,
+ 				   struct adv_monitor *monitor,
+ 				   u16 handle, int *err)
  {
- 	struct hci_dev *hdev = data;
- 	struct adv_monitor *monitor = ptr;
+ 	*err = 0;
  
- 	idr_remove(&hdev->adv_monitors_idr, monitor->handle);
- 	hci_free_adv_monitor(monitor);
- 	hdev->adv_monitors_cnt--;
+ 	switch (hci_get_adv_monitor_offload_ext(hdev)) {
+ 	case HCI_ADV_MONITOR_EXT_NONE: /* also goes here when powered off */
+ 		goto free_monitor;
+ 	case HCI_ADV_MONITOR_EXT_MSFT:
+ 		*err = msft_remove_monitor(hdev, monitor, handle);
+ 		break;
+ 	}
  
- 	return 0;
+ 	/* In case no matching handle registered, just free the monitor */
+ 	if (*err == -ENOENT)
+ 		goto free_monitor;
+ 
+ 	return (*err == 0);
+ 
+ free_monitor:
+ 	if (*err == -ENOENT)
+ 		bt_dev_warn(hdev, "Removing monitor with no matching handle %d",
+ 			    monitor->handle);
+ 	hci_free_adv_monitor(hdev, monitor);
+ 
+ 	*err = 0;
+ 	return false;
  }
  
- /* This function requires the caller holds hdev->lock */
- int hci_remove_adv_monitor(struct hci_dev *hdev, u16 handle)
+ /* Returns true if request is forwarded (result is pending), false otherwise.
+  * This function requires the caller holds hdev->lock.
+  */
+ bool hci_remove_single_adv_monitor(struct hci_dev *hdev, u16 handle, int *err)
+ {
+ 	struct adv_monitor *monitor = idr_find(&hdev->adv_monitors_idr, handle);
+ 	bool pending;
+ 
+ 	if (!monitor) {
+ 		*err = -EINVAL;
+ 		return false;
+ 	}
+ 
+ 	pending = hci_remove_adv_monitor(hdev, monitor, handle, err);
+ 	if (!*err && !pending)
+ 		hci_update_background_scan(hdev);
+ 
+ 	bt_dev_dbg(hdev, "%s remove monitor handle %d, status %d, %spending",
+ 		   hdev->name, handle, *err, pending ? "" : "not ");
+ 
+ 	return pending;
+ }
+ 
+ /* Returns true if request is forwarded (result is pending), false otherwise.
+  * This function requires the caller holds hdev->lock.
+  */
+ bool hci_remove_all_adv_monitor(struct hci_dev *hdev, int *err)
  {
  	struct adv_monitor *monitor;
+ 	int idr_next_id = 0;
+ 	bool pending = false;
+ 	bool update = false;
+ 
+ 	*err = 0;
  
- 	if (handle) {
- 		monitor = idr_find(&hdev->adv_monitors_idr, handle);
+ 	while (!*err && !pending) {
+ 		monitor = idr_get_next(&hdev->adv_monitors_idr, &idr_next_id);
  		if (!monitor)
- 			return -ENOENT;
+ 			break;
  
- 		idr_remove(&hdev->adv_monitors_idr, monitor->handle);
- 		hci_free_adv_monitor(monitor);
- 		hdev->adv_monitors_cnt--;
- 	} else {
- 		/* Remove all monitors if handle is 0. */
- 		idr_for_each(&hdev->adv_monitors_idr, &free_adv_monitor, hdev);
+ 		pending = hci_remove_adv_monitor(hdev, monitor, 0, err);
+ 
+ 		if (!*err && !pending)
+ 			update = true;
  	}
  
- 	hci_update_background_scan(hdev);
+ 	if (update)
+ 		hci_update_background_scan(hdev);
  
- 	return 0;
+ 	bt_dev_dbg(hdev, "%s remove all monitors status %d, %spending",
+ 		   hdev->name, *err, pending ? "" : "not ");
+ 
+ 	return pending;
  }
  
  /* This function requires the caller holds hdev->lock */
diff --cc net/bluetooth/mgmt.c
index 571df4b44339,8ff9c4bb43d1..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -4266,16 -4323,19 +4276,20 @@@ static int __add_adv_patterns_monitor(s
  
  	hci_dev_unlock(hdev);
  
 -	cmd->user_data = m;
 -	return 0;
 +	rp.monitor_handle = cpu_to_le16(m->handle);
 +
 +	return mgmt_cmd_complete(sk, hdev->id, op,
 +				 MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
  
  unlock:
+ 	hci_free_adv_monitor(hdev, m);
  	hci_dev_unlock(hdev);
++<<<<<<< HEAD
 +
 +failed:
 +	hci_free_adv_monitor(m);
++=======
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  	return mgmt_cmd_status(sk, hdev->id, op, status);
  }
  
diff --cc net/bluetooth/msft.c
index 910ec68f8aa5,f5aa0e3b1b9b..000000000000
--- a/net/bluetooth/msft.c
+++ b/net/bluetooth/msft.c
@@@ -21,12 -28,67 +21,68 @@@ struct msft_rp_read_supported_features 
  	__u8   evt_prefix[];
  } __packed;
  
++<<<<<<< HEAD
++=======
+ #define MSFT_OP_LE_MONITOR_ADVERTISEMENT	0x03
+ #define MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN	0x01
+ struct msft_le_monitor_advertisement_pattern {
+ 	__u8 length;
+ 	__u8 data_type;
+ 	__u8 start_byte;
+ 	__u8 pattern[0];
+ };
+ 
+ struct msft_le_monitor_advertisement_pattern_data {
+ 	__u8 count;
+ 	__u8 data[0];
+ };
+ 
+ struct msft_cp_le_monitor_advertisement {
+ 	__u8 sub_opcode;
+ 	__s8 rssi_high;
+ 	__s8 rssi_low;
+ 	__u8 rssi_low_interval;
+ 	__u8 rssi_sampling_period;
+ 	__u8 cond_type;
+ 	__u8 data[0];
+ } __packed;
+ 
+ struct msft_rp_le_monitor_advertisement {
+ 	__u8 status;
+ 	__u8 sub_opcode;
+ 	__u8 handle;
+ } __packed;
+ 
+ #define MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT	0x04
+ struct msft_cp_le_cancel_monitor_advertisement {
+ 	__u8 sub_opcode;
+ 	__u8 handle;
+ } __packed;
+ 
+ struct msft_rp_le_cancel_monitor_advertisement {
+ 	__u8 status;
+ 	__u8 sub_opcode;
+ } __packed;
+ 
+ struct msft_monitor_advertisement_handle_data {
+ 	__u8  msft_handle;
+ 	__u16 mgmt_handle;
+ 	struct list_head list;
+ };
+ 
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  struct msft_data {
  	__u64 features;
  	__u8  evt_prefix_len;
  	__u8  *evt_prefix;
++<<<<<<< HEAD
++=======
+ 	struct list_head handle_map;
+ 	__u16 pending_add_handle;
+ 	__u16 pending_remove_handle;
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  };
  
 -bool msft_monitor_supported(struct hci_dev *hdev)
 -{
 -	return !!(msft_get_features(hdev) & MSFT_FEATURE_MASK_LE_ADV_MONITOR);
 -}
 -
  static bool read_supported_features(struct hci_dev *hdev,
  				    struct msft_data *msft)
  {
@@@ -148,10 -214,254 +204,260 @@@ __u64 msft_get_features(struct hci_dev 
  {
  	struct msft_data *msft = hdev->msft_data;
  
 -	return msft ? msft->features : 0;
 +	return  msft ? msft->features : 0;
  }
  
++<<<<<<< HEAD
 +bool msft_curve_validity(struct hci_dev *hdev)
 +{
 +	return hdev->msft_curve_validity;
++=======
+ /* is_mgmt = true matches the handle exposed to userspace via mgmt.
+  * is_mgmt = false matches the handle used by the msft controller.
+  * This function requires the caller holds hdev->lock
+  */
+ static struct msft_monitor_advertisement_handle_data *msft_find_handle_data
+ 				(struct hci_dev *hdev, u16 handle, bool is_mgmt)
+ {
+ 	struct msft_monitor_advertisement_handle_data *entry;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	list_for_each_entry(entry, &msft->handle_map, list) {
+ 		if (is_mgmt && entry->mgmt_handle == handle)
+ 			return entry;
+ 		if (!is_mgmt && entry->msft_handle == handle)
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void msft_le_monitor_advertisement_cb(struct hci_dev *hdev,
+ 					     u8 status, u16 opcode,
+ 					     struct sk_buff *skb)
+ {
+ 	struct msft_rp_le_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	monitor = idr_find(&hdev->adv_monitors_idr, msft->pending_add_handle);
+ 	if (!monitor) {
+ 		bt_dev_err(hdev, "msft add advmon: monitor %d is not found!",
+ 			   msft->pending_add_handle);
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	if (status)
+ 		goto unlock;
+ 
+ 	rp = (struct msft_rp_le_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data = kmalloc(sizeof(*handle_data), GFP_KERNEL);
+ 	if (!handle_data) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data->mgmt_handle = monitor->handle;
+ 	handle_data->msft_handle = rp->handle;
+ 	INIT_LIST_HEAD(&handle_data->list);
+ 	list_add(&handle_data->list, &msft->handle_map);
+ 
+ 	monitor->state = ADV_MONITOR_STATE_OFFLOADED;
+ 
+ unlock:
+ 	if (status && monitor)
+ 		hci_free_adv_monitor(hdev, monitor);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	hci_add_adv_patterns_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_cancel_monitor_advertisement_cb(struct hci_dev *hdev,
+ 						    u8 status, u16 opcode,
+ 						    struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement *cp;
+ 	struct msft_rp_le_cancel_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 	bool pending;
+ 
+ 	if (status)
+ 		goto done;
+ 
+ 	rp = (struct msft_rp_le_cancel_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto done;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	handle_data = msft_find_handle_data(hdev, cp->handle, false);
+ 
+ 	if (handle_data) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr,
+ 				   handle_data->mgmt_handle);
+ 		if (monitor)
+ 			hci_free_adv_monitor(hdev, monitor);
+ 
+ 		list_del(&handle_data->list);
+ 		kfree(handle_data);
+ 	}
+ 
+ 	/* If remove all monitors is required, we need to continue the process
+ 	 * here because the earlier it was paused when waiting for the
+ 	 * response from controller.
+ 	 */
+ 	if (msft->pending_remove_handle == 0) {
+ 		pending = hci_remove_all_adv_monitor(hdev, &err);
+ 		if (pending) {
+ 			hci_dev_unlock(hdev);
+ 			return;
+ 		}
+ 
+ 		if (err)
+ 			status = HCI_ERROR_UNSPECIFIED;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ done:
+ 	hci_remove_adv_monitor_complete(hdev, status);
+ }
+ 
+ static bool msft_monitor_rssi_valid(struct adv_monitor *monitor)
+ {
+ 	struct adv_rssi_thresholds *r = &monitor->rssi;
+ 
+ 	if (r->high_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->high_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX ||
+ 	    r->low_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->low_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX)
+ 		return false;
+ 
+ 	/* High_threshold_timeout is not supported,
+ 	 * once high_threshold is reached, events are immediately reported.
+ 	 */
+ 	if (r->high_threshold_timeout != 0)
+ 		return false;
+ 
+ 	if (r->low_threshold_timeout > MSFT_RSSI_LOW_TIMEOUT_MAX)
+ 		return false;
+ 
+ 	/* Sampling period from 0x00 to 0xFF are all allowed */
+ 	return true;
+ }
+ 
+ static bool msft_monitor_pattern_valid(struct adv_monitor *monitor)
+ {
+ 	return msft_monitor_rssi_valid(monitor);
+ 	/* No additional check needed for pattern-based monitor */
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	struct msft_cp_le_monitor_advertisement *cp;
+ 	struct msft_le_monitor_advertisement_pattern_data *pattern_data;
+ 	struct msft_le_monitor_advertisement_pattern *pattern;
+ 	struct adv_pattern *entry;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	size_t total_size = sizeof(*cp) + sizeof(*pattern_data);
+ 	ptrdiff_t offset = 0;
+ 	u8 pattern_count = 0;
+ 	int err = 0;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!msft_monitor_pattern_valid(monitor))
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern_count++;
+ 		total_size += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	cp = kmalloc(total_size, GFP_KERNEL);
+ 	if (!cp)
+ 		return -ENOMEM;
+ 
+ 	cp->sub_opcode = MSFT_OP_LE_MONITOR_ADVERTISEMENT;
+ 	cp->rssi_high = monitor->rssi.high_threshold;
+ 	cp->rssi_low = monitor->rssi.low_threshold;
+ 	cp->rssi_low_interval = (u8)monitor->rssi.low_threshold_timeout;
+ 	cp->rssi_sampling_period = monitor->rssi.sampling_period;
+ 
+ 	cp->cond_type = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;
+ 
+ 	pattern_data = (void *)cp->data;
+ 	pattern_data->count = pattern_count;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern = (void *)(pattern_data->data + offset);
+ 		/* the length also includes data_type and offset */
+ 		pattern->length = entry->length + 2;
+ 		pattern->data_type = entry->ad_type;
+ 		pattern->start_byte = entry->offset;
+ 		memcpy(pattern->pattern, entry->value, entry->length);
+ 		offset += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, total_size, cp);
+ 	err = hci_req_run_skb(&req, msft_le_monitor_advertisement_cb);
+ 	kfree(cp);
+ 
+ 	if (!err)
+ 		msft->pending_add_handle = monitor->handle;
+ 
+ 	return err;
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement cp;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err = 0;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	handle_data = msft_find_handle_data(hdev, monitor->handle, true);
+ 
+ 	/* If no matched handle, just remove without telling controller */
+ 	if (!handle_data)
+ 		return -ENOENT;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;
+ 	cp.handle = handle_data->msft_handle;
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, sizeof(cp), &cp);
+ 	err = hci_req_run_skb(&req, msft_le_cancel_monitor_advertisement_cb);
+ 
+ 	if (!err)
+ 		msft->pending_remove_handle = handle;
+ 
+ 	return err;
  }
diff --cc net/bluetooth/msft.h
index d114e67c6ccd,6f126a1f1688..000000000000
--- a/net/bluetooth/msft.h
+++ b/net/bluetooth/msft.h
@@@ -16,7 -17,9 +16,13 @@@ void msft_do_open(struct hci_dev *hdev)
  void msft_do_close(struct hci_dev *hdev);
  void msft_vendor_evt(struct hci_dev *hdev, struct sk_buff *skb);
  __u64 msft_get_features(struct hci_dev *hdev);
++<<<<<<< HEAD
 +bool msft_curve_validity(struct hci_dev *hdev);
++=======
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor);
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle);
++>>>>>>> 66bd095ab5d4 (Bluetooth: advmon offload MSFT remove monitor)
  
  #else
  
@@@ -24,10 -32,17 +30,17 @@@ static inline void msft_do_open(struct 
  static inline void msft_do_close(struct hci_dev *hdev) {}
  static inline void msft_vendor_evt(struct hci_dev *hdev, struct sk_buff *skb) {}
  static inline __u64 msft_get_features(struct hci_dev *hdev) { return 0; }
 -static inline int msft_add_monitor_pattern(struct hci_dev *hdev,
 -					   struct adv_monitor *monitor)
 +
 +static inline bool msft_curve_validity(struct hci_dev *hdev)
  {
 -	return -EOPNOTSUPP;
 +	return false;
  }
  
+ static inline int msft_remove_monitor(struct hci_dev *hdev,
+ 				      struct adv_monitor *monitor,
+ 				      u16 handle)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
  #endif
* Unmerged path include/net/bluetooth/hci_core.h
* Unmerged path net/bluetooth/hci_core.c
* Unmerged path net/bluetooth/mgmt.c
* Unmerged path net/bluetooth/msft.c
* Unmerged path net/bluetooth/msft.h
