platform/x86: think-lmi: Add WMI interface support on Lenovo platforms

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Mark Pearson <markpearson@lenovo.com>
commit a40cd7ef22fbb11229cf982920f4ec96c1f49282
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/a40cd7ef.failed

For Lenovo platforms that support a WMI interface to the BIOS add
support, using the firmware-attributes class, to allow users to access
and modify various BIOS related settings.

	Signed-off-by: Mark Pearson <markpearson@lenovo.com>
Link: https://lore.kernel.org/r/20210530223111.25929-3-markpearson@lenovo.com
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit a40cd7ef22fbb11229cf982920f4ec96c1f49282)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/platform/x86/Kconfig
#	drivers/platform/x86/Makefile
diff --cc MAINTAINERS
index 477f5f6cbf3a,771ea74e7e2d..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -14568,8 -18160,21 +14568,23 @@@ L:	platform-driver-x86@vger.kernel.or
  W:	http://ibm-acpi.sourceforge.net
  W:	http://thinkwiki.org/wiki/Ibm-acpi
  T:	git git://repo.or.cz/linux-2.6/linux-acpi-2.6/ibm-acpi-2.6.git
++<<<<<<< HEAD
++=======
+ F:	drivers/platform/x86/thinkpad_acpi.c
+ 
+ THINKPAD LMI DRIVER
+ M:	Mark Pearson <markpearson@lenovo.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-class-firmware-attributes
+ F:	drivers/platform/x86/think-lmi.?
+ 
+ THUNDERBOLT DMA TRAFFIC TEST DRIVER
+ M:	Isaac Hazan <isaac.hazan@intel.com>
+ L:	linux-usb@vger.kernel.org
++>>>>>>> a40cd7ef22fb (platform/x86: think-lmi: Add WMI interface support on Lenovo platforms)
  S:	Maintained
 -F:	drivers/thunderbolt/dma_test.c
 +F:	drivers/platform/x86/thinkpad_acpi.c
  
  THUNDERBOLT DRIVER
  M:	Andreas Noever <andreas.noever@gmail.com>
diff --cc drivers/platform/x86/Kconfig
index 9a282595af99,1e538ce8feaf..000000000000
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@@ -778,6 -99,701 +778,704 @@@ config INTEL_WMI_THUNDERBOL
  	  To compile this driver as a module, choose M here: the module will
  	  be called intel-wmi-thunderbolt.
  
++<<<<<<< HEAD
++=======
+ config MXM_WMI
+        tristate "WMI support for MXM Laptop Graphics"
+        depends on ACPI_WMI
+ 	help
+           MXM is a standard for laptop graphics cards, the WMI interface
+ 	  is required for switchable nvidia graphics machines
+ 
+ config PEAQ_WMI
+ 	tristate "PEAQ 2-in-1 WMI hotkey driver"
+ 	depends on ACPI_WMI
+ 	depends on INPUT
+ 	help
+ 	 Say Y here if you want to support WMI-based hotkeys on PEAQ 2-in-1s.
+ 
+ config XIAOMI_WMI
+ 	tristate "Xiaomi WMI key driver"
+ 	depends on ACPI_WMI
+ 	depends on INPUT
+ 	help
+ 	  Say Y here if you want to support WMI-based keys on Xiaomi notebooks.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called xiaomi-wmi.
+ 
+ config GIGABYTE_WMI
+ 	tristate "Gigabyte WMI temperature driver"
+ 	depends on ACPI_WMI
+ 	depends on HWMON
+ 	help
+ 	  Say Y here if you want to support WMI-based temperature reporting on
+ 	  Gigabyte mainboards.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called gigabyte-wmi.
+ 
+ config ACERHDF
+ 	tristate "Acer Aspire One temperature and fan driver"
+ 	depends on ACPI && THERMAL
+ 	select THERMAL_GOV_BANG_BANG
+ 	help
+ 	  This is a driver for Acer Aspire One netbooks. It allows to access
+ 	  the temperature sensor and to control the fan.
+ 
+ 	  After loading this driver the BIOS is still in control of the fan.
+ 	  To let the kernel handle the fan, do:
+ 	  echo -n enabled > /sys/class/thermal/thermal_zoneN/mode
+ 	  where N=0,1,2... depending on the number of thermal nodes and the
+ 	  detection order of your particular system.  The "type" parameter
+ 	  in the same node directory will tell you if it is "acerhdf".
+ 
+ 	  For more information about this driver see
+ 	  <https://piie.net/files/acerhdf_README.txt>
+ 
+ 	  If you have an Acer Aspire One netbook, say Y or M
+ 	  here.
+ 
+ config ACER_WIRELESS
+         tristate "Acer Wireless Radio Control Driver"
+         depends on ACPI
+         depends on INPUT
+ 	help
+           The Acer Wireless Radio Control handles the airplane mode hotkey
+           present on new Acer laptops.
+ 
+           Say Y or M here if you have an Acer notebook with an airplane mode
+           hotkey.
+ 
+           If you choose to compile this driver as a module the module will be
+           called acer-wireless.
+ 
+ config ACER_WMI
+ 	tristate "Acer WMI Laptop Extras"
+ 	depends on ACPI
+ 	select LEDS_CLASS
+ 	select NEW_LEDS
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on SERIO_I8042
+ 	depends on INPUT
+ 	depends on RFKILL || RFKILL = n
+ 	depends on ACPI_WMI
+ 	select INPUT_SPARSEKMAP
+ 	# Acer WMI depends on ACPI_VIDEO when ACPI is enabled
+         select ACPI_VIDEO if ACPI
+ 	help
+ 	  This is a driver for newer Acer (and Wistron) laptops. It adds
+ 	  wireless radio and bluetooth control, and on some laptops,
+ 	  exposes the mail LED and LCD backlight.
+ 
+ 	  If you have an ACPI-WMI compatible Acer/ Wistron laptop, say Y or M
+ 	  here.
+ 
+ config AMD_PMC
+ 	tristate "AMD SoC PMC driver"
+ 	depends on ACPI && PCI
+ 	help
+ 	  The driver provides support for AMD Power Management Controller
+ 	  primarily responsible for S2Idle transactions that are driven from
+ 	  a platform firmware running on SMU. This driver also provides a debug
+ 	  mechanism to investigate the S2Idle transactions and failures.
+ 
+ 	  Say Y or M here if you have a notebook powered by AMD RYZEN CPU/APU.
+ 
+ 	  If you choose to compile this driver as a module the module will be
+ 	  called amd-pmc.
+ 
+ config ADV_SWBUTTON
+ 	tristate "Advantech ACPI Software Button Driver"
+ 	depends on ACPI && INPUT
+ 	help
+ 	  Say Y here to enable support for Advantech software defined
+ 	  button feature. More information can be found at
+ 	  <http://www.advantech.com.tw/products/>
+ 
+ 	  To compile this driver as a module, choose M here. The module will
+ 	  be called adv_swbutton.
+ 
+ config APPLE_GMUX
+ 	tristate "Apple Gmux Driver"
+ 	depends on ACPI && PCI
+ 	depends on PNP
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on BACKLIGHT_APPLE=n || BACKLIGHT_APPLE
+ 	depends on ACPI_VIDEO=n || ACPI_VIDEO
+ 	help
+ 	  This driver provides support for the gmux device found on many
+ 	  Apple laptops, which controls the display mux for the hybrid
+ 	  graphics as well as the backlight. Currently only backlight
+ 	  control is supported by the driver.
+ 
+ config ASUS_LAPTOP
+ 	tristate "Asus Laptop Extras"
+ 	depends on ACPI
+ 	select LEDS_CLASS
+ 	select NEW_LEDS
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on INPUT
+ 	depends on RFKILL || RFKILL = n
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	select INPUT_SPARSEKMAP
+ 	help
+ 	  This is a driver for Asus laptops, Lenovo SL and the Pegatron
+ 	  Lucid tablet. It may also support some MEDION, JVC or VICTOR
+ 	  laptops. It makes all the extra buttons generate standard
+ 	  ACPI events and input events, and on the Lucid the built-in
+ 	  accelerometer appears as an input device.  It also adds
+ 	  support for video output switching, LCD backlight control,
+ 	  Bluetooth and Wlan control, and most importantly, allows you
+ 	  to blink those fancy LEDs.
+ 
+ 	  For more information see <http://acpi4asus.sf.net>.
+ 
+ 	  If you have an ACPI-compatible ASUS laptop, say Y or M here.
+ 
+ config ASUS_WIRELESS
+ 	tristate "Asus Wireless Radio Control Driver"
+ 	depends on ACPI
+ 	depends on INPUT
+ 	select NEW_LEDS
+ 	select LEDS_CLASS
+ 	help
+ 	  The Asus Wireless Radio Control handles the airplane mode hotkey
+ 	  present on some Asus laptops.
+ 
+ 	  Say Y or M here if you have an ASUS notebook with an airplane mode
+ 	  hotkey.
+ 
+ 	  If you choose to compile this driver as a module the module will be
+ 	  called asus-wireless.
+ 
+ config ASUS_WMI
+ 	tristate "ASUS WMI Driver"
+ 	depends on ACPI_WMI
+ 	depends on ACPI_BATTERY
+ 	depends on INPUT
+ 	depends on HWMON
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on RFKILL || RFKILL = n
+ 	depends on HOTPLUG_PCI
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	select INPUT_SPARSEKMAP
+ 	select LEDS_CLASS
+ 	select NEW_LEDS
+ 	help
+ 	  Say Y here if you have a WMI aware Asus laptop (like Eee PCs or new
+ 	  Asus Notebooks).
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called asus-wmi.
+ 
+ config ASUS_NB_WMI
+ 	tristate "Asus Notebook WMI Driver"
+ 	depends on ASUS_WMI
+ 	depends on SERIO_I8042 || SERIO_I8042 = n
+ 	help
+ 	  This is a driver for newer Asus notebooks. It adds extra features
+ 	  like wireless radio and bluetooth control, leds, hotkeys, backlight...
+ 
+ 	  For more information, see
+ 	  <file:Documentation/ABI/testing/sysfs-platform-asus-wmi>
+ 
+ 	  If you have an ACPI-WMI compatible Asus Notebook, say Y or M
+ 	  here.
+ 
+ config EEEPC_LAPTOP
+ 	tristate "Eee PC Hotkey Driver"
+ 	depends on ACPI
+ 	depends on INPUT
+ 	depends on RFKILL || RFKILL = n
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	depends on HOTPLUG_PCI
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	select HWMON
+ 	select LEDS_CLASS
+ 	select NEW_LEDS
+ 	select INPUT_SPARSEKMAP
+ 	help
+ 	  This driver supports the Fn-Fx keys on Eee PC laptops.
+ 
+ 	  It  also gives access to some extra laptop functionalities like
+ 	  Bluetooth, backlight and allows powering on/off some other
+ 	  devices.
+ 
+ 	  If you have an Eee PC laptop, say Y or M here. If this driver
+ 	  doesn't work on your Eee PC, try eeepc-wmi instead.
+ 
+ config EEEPC_WMI
+ 	tristate "Eee PC WMI Driver"
+ 	depends on ASUS_WMI
+ 	help
+ 	  This is a driver for newer Eee PC laptops. It adds extra features
+ 	  like wireless radio and bluetooth control, leds, hotkeys, backlight...
+ 
+ 	  For more information, see
+ 	  <file:Documentation/ABI/testing/sysfs-platform-asus-wmi>
+ 
+ 	  If you have an ACPI-WMI compatible Eee PC laptop (>= 1000), say Y or M
+ 	  here.
+ 
+ source "drivers/platform/x86/dell/Kconfig"
+ 
+ config AMILO_RFKILL
+ 	tristate "Fujitsu-Siemens Amilo rfkill support"
+ 	depends on RFKILL
+ 	depends on SERIO_I8042
+ 	help
+ 	  This is a driver for enabling wifi on some Fujitsu-Siemens Amilo
+ 	  laptops.
+ 
+ config FUJITSU_LAPTOP
+ 	tristate "Fujitsu Laptop Extras"
+ 	depends on ACPI
+ 	depends on INPUT
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	select INPUT_SPARSEKMAP
+ 	select NEW_LEDS
+ 	select LEDS_CLASS
+ 	help
+ 	  This is a driver for laptops built by Fujitsu:
+ 
+ 	    * P2xxx/P5xxx/S6xxx/S7xxx series Lifebooks
+ 	    * Possibly other Fujitsu laptop models
+ 	    * Tested with S6410 and S7020
+ 
+ 	  It adds support for LCD brightness control and some hotkeys.
+ 
+ 	  If you have a Fujitsu laptop, say Y or M here.
+ 
+ config FUJITSU_TABLET
+        tristate "Fujitsu Tablet Extras"
+        depends on ACPI
+        depends on INPUT
+ 	help
+          This is a driver for tablets built by Fujitsu:
+ 
+            * Lifebook P1510/P1610/P1620/Txxxx
+            * Stylistic ST5xxx
+            * Possibly other Fujitsu tablet models
+ 
+          It adds support for the panel buttons, docking station detection,
+          tablet/notebook mode detection for convertible and
+          orientation detection for docked slates.
+ 
+          If you have a Fujitsu convertible or slate, say Y or M here.
+ 
+ config GPD_POCKET_FAN
+ 	tristate "GPD Pocket Fan Controller support"
+ 	depends on ACPI
+ 	depends on THERMAL
+ 	help
+ 	  Driver for the GPD Pocket vendor specific FAN02501 ACPI device
+ 	  which controls the fan speed on the GPD Pocket.
+ 
+ 	  Without this driver the fan on the Pocket will stay off independent
+ 	  of the CPU temperature. Say Y or M if the kernel may be used on a
+ 	  GPD pocket.
+ 
+ config HP_ACCEL
+ 	tristate "HP laptop accelerometer"
+ 	depends on INPUT && ACPI
+ 	depends on SERIO_I8042
+ 	select SENSORS_LIS3LV02D
+ 	select NEW_LEDS
+ 	select LEDS_CLASS
+ 	help
+ 	  This driver provides support for the "Mobile Data Protection System 3D"
+ 	  or "3D DriveGuard" feature of HP laptops. On such systems the driver
+ 	  should load automatically (via ACPI alias).
+ 
+ 	  Support for a led indicating disk protection will be provided as
+ 	  hp::hddprotect. For more information on the feature, refer to
+ 	  Documentation/misc-devices/lis3lv02d.rst.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called hp_accel.
+ 
+ config WIRELESS_HOTKEY
+ 	tristate "Wireless hotkey button"
+ 	depends on ACPI
+ 	depends on INPUT
+ 	help
+ 	 This driver provides supports for the wireless buttons found on some AMD,
+ 	 HP, & Xioami laptops.
+ 	 On such systems the driver should load automatically (via ACPI alias).
+ 
+ 	 To compile this driver as a module, choose M here: the module will
+ 	 be called wireless-hotkey.
+ 
+ config HP_WMI
+ 	tristate "HP WMI extras"
+ 	depends on ACPI_WMI
+ 	depends on INPUT
+ 	depends on RFKILL || RFKILL = n
+ 	select INPUT_SPARSEKMAP
+ 	select ACPI_PLATFORM_PROFILE
+ 	help
+ 	 Say Y here if you want to support WMI-based hotkeys on HP laptops and
+ 	 to read data from WMI such as docking or ambient light sensor state.
+ 
+ 	 To compile this driver as a module, choose M here: the module will
+ 	 be called hp-wmi.
+ 
+ config TC1100_WMI
+ 	tristate "HP Compaq TC1100 Tablet WMI Extras"
+ 	depends on !X86_64
+ 	depends on ACPI
+ 	depends on ACPI_WMI
+ 	help
+ 	  This is a driver for the WMI extensions (wireless and bluetooth power
+ 	  control) of the HP Compaq TC1100 tablet.
+ 
+ config IBM_RTL
+ 	tristate "Device driver to enable PRTL support"
+ 	depends on PCI
+ 	help
+ 	 Enable support for IBM Premium Real Time Mode (PRTM).
+ 	 This module will allow you the enter and exit PRTM in the BIOS via
+ 	 sysfs on platforms that support this feature.  System in PRTM will
+ 	 not receive CPU-generated SMIs for recoverable errors.  Use of this
+ 	 feature without proper support may void your hardware warranty.
+ 
+ 	 If the proper BIOS support is found the driver will load and create
+ 	 /sys/devices/system/ibm_rtl/.  The "state" variable will indicate
+ 	 whether or not the BIOS is in PRTM.
+ 	 state = 0 (BIOS SMIs on)
+ 	 state = 1 (BIOS SMIs off)
+ 
+ config IDEAPAD_LAPTOP
+ 	tristate "Lenovo IdeaPad Laptop Extras"
+ 	depends on ACPI
+ 	depends on RFKILL && INPUT
+ 	depends on SERIO_I8042
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	depends on ACPI_WMI || ACPI_WMI = n
+ 	select ACPI_PLATFORM_PROFILE
+ 	select INPUT_SPARSEKMAP
+ 	select NEW_LEDS
+ 	select LEDS_CLASS
+ 	help
+ 	  This is a driver for Lenovo IdeaPad netbooks contains drivers for
+ 	  rfkill switch, hotkey, fan control and backlight control.
+ 
+ config SENSORS_HDAPS
+ 	tristate "Thinkpad Hard Drive Active Protection System (hdaps)"
+ 	depends on INPUT
+ 	help
+ 	  This driver provides support for the IBM Hard Drive Active Protection
+ 	  System (hdaps), which provides an accelerometer and other misc. data.
+ 	  ThinkPads starting with the R50, T41, and X40 are supported.  The
+ 	  accelerometer data is readable via sysfs.
+ 
+ 	  This driver also provides an absolute input class device, allowing
+ 	  the laptop to act as a pinball machine-esque joystick.
+ 
+ 	  If your ThinkPad is not recognized by the driver, please update to latest
+ 	  BIOS. This is especially the case for some R52 ThinkPads.
+ 
+ 	  Say Y here if you have an applicable laptop and want to experience
+ 	  the awesome power of hdaps.
+ 
+ config THINKPAD_ACPI
+ 	tristate "ThinkPad ACPI Laptop Extras"
+ 	depends on ACPI
+ 	depends on ACPI_BATTERY
+ 	depends on INPUT
+ 	depends on RFKILL || RFKILL = n
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	select ACPI_PLATFORM_PROFILE
+ 	select HWMON
+ 	select NVRAM
+ 	select NEW_LEDS
+ 	select LEDS_CLASS
+ 	select LEDS_TRIGGERS
+ 	select LEDS_TRIGGER_AUDIO
+ 	help
+ 	  This is a driver for the IBM and Lenovo ThinkPad laptops. It adds
+ 	  support for Fn-Fx key combinations, Bluetooth control, video
+ 	  output switching, ThinkLight control, UltraBay eject and more.
+ 	  For more information about this driver see
+ 	  <file:Documentation/admin-guide/laptops/thinkpad-acpi.rst> and
+ 	  <http://ibm-acpi.sf.net/> .
+ 
+ 	  This driver was formerly known as ibm-acpi.
+ 
+ 	  Extra functionality will be available if the rfkill (CONFIG_RFKILL)
+ 	  and/or ALSA (CONFIG_SND) subsystems are available in the kernel.
+ 	  Note that if you want ThinkPad-ACPI to be built-in instead of
+ 	  modular, ALSA and rfkill will also have to be built-in.
+ 
+ 	  If you have an IBM or Lenovo ThinkPad laptop, say Y or M here.
+ 
+ config THINKPAD_ACPI_ALSA_SUPPORT
+ 	bool "Console audio control ALSA interface"
+ 	depends on THINKPAD_ACPI
+ 	depends on SND
+ 	depends on SND = y || THINKPAD_ACPI = SND
+ 	default y
+ 	help
+ 	  Enables monitoring of the built-in console audio output control
+ 	  (headphone and speakers), which is operated by the mute and (in
+ 	  some ThinkPad models) volume hotkeys.
+ 
+ 	  If this option is enabled, ThinkPad-ACPI will export an ALSA card
+ 	  with a single read-only mixer control, which should be used for
+ 	  on-screen-display feedback purposes by the Desktop Environment.
+ 
+ 	  Optionally, the driver will also allow software control (the
+ 	  ALSA mixer will be made read-write).  Please refer to the driver
+ 	  documentation for details.
+ 
+ 	  All IBM models have both volume and mute control.  Newer Lenovo
+ 	  models only have mute control (the volume hotkeys are just normal
+ 	  keys and volume control is done through the main HDA mixer).
+ 
+ config THINKPAD_ACPI_DEBUGFACILITIES
+ 	bool "Maintainer debug facilities"
+ 	depends on THINKPAD_ACPI
+ 	help
+ 	  Enables extra stuff in the thinkpad-acpi which is completely useless
+ 	  for normal use.  Read the driver source to find out what it does.
+ 
+ 	  Say N here, unless you were told by a kernel maintainer to do
+ 	  otherwise.
+ 
+ config THINKPAD_ACPI_DEBUG
+ 	bool "Verbose debug mode"
+ 	depends on THINKPAD_ACPI
+ 	help
+ 	  Enables extra debugging information, at the expense of a slightly
+ 	  increase in driver size.
+ 
+ 	  If you are not sure, say N here.
+ 
+ config THINKPAD_ACPI_UNSAFE_LEDS
+ 	bool "Allow control of important LEDs (unsafe)"
+ 	depends on THINKPAD_ACPI
+ 	help
+ 	  Overriding LED state on ThinkPads can mask important
+ 	  firmware alerts (like critical battery condition), or misled
+ 	  the user into damaging the hardware (undocking or ejecting
+ 	  the bay while buses are still active), etc.
+ 
+ 	  LED control on the ThinkPad is write-only (with very few
+ 	  exceptions on very ancient models), which makes it
+ 	  impossible to know beforehand if important information will
+ 	  be lost when one changes LED state.
+ 
+ 	  Users that know what they are doing can enable this option
+ 	  and the driver will allow control of every LED, including
+ 	  the ones on the dock stations.
+ 
+ 	  Never enable this option on a distribution kernel.
+ 
+ 	  Say N here, unless you are building a kernel for your own
+ 	  use, and need to control the important firmware LEDs.
+ 
+ config THINKPAD_ACPI_VIDEO
+ 	bool "Video output control support"
+ 	depends on THINKPAD_ACPI
+ 	default y
+ 	help
+ 	  Allows the thinkpad_acpi driver to provide an interface to control
+ 	  the various video output ports.
+ 
+ 	  This feature often won't work well, depending on ThinkPad model,
+ 	  display state, video output devices in use, whether there is a X
+ 	  server running, phase of the moon, and the current mood of
+ 	  Schroedinger's cat.  If you can use X.org's RandR to control
+ 	  your ThinkPad's video output ports instead of this feature,
+ 	  don't think twice: do it and say N here to save memory and avoid
+ 	  bad interactions with X.org.
+ 
+ 	  NOTE: access to this feature is limited to processes with the
+ 	  CAP_SYS_ADMIN capability, to avoid local DoS issues in platforms
+ 	  where it interacts badly with X.org.
+ 
+ 	  If you are not sure, say Y here but do try to check if you could
+ 	  be using X.org RandR instead.
+ 
+ config THINKPAD_ACPI_HOTKEY_POLL
+ 	bool "Support NVRAM polling for hot keys"
+ 	depends on THINKPAD_ACPI
+ 	default y
+ 	help
+ 	  Some thinkpad models benefit from NVRAM polling to detect a few of
+ 	  the hot key press events.  If you know your ThinkPad model does not
+ 	  need to do NVRAM polling to support any of the hot keys you use,
+ 	  unselecting this option will save about 1kB of memory.
+ 
+ 	  ThinkPads T40 and newer, R52 and newer, and X31 and newer are
+ 	  unlikely to need NVRAM polling in their latest BIOS versions.
+ 
+ 	  NVRAM polling can detect at most the following keys: ThinkPad/Access
+ 	  IBM, Zoom, Switch Display (fn+F7), ThinkLight, Volume up/down/mute,
+ 	  Brightness up/down, Display Expand (fn+F8), Hibernate (fn+F12).
+ 
+ 	  If you are not sure, say Y here.  The driver enables polling only if
+ 	  it is strictly necessary to do so.
+ 
+ config THINKPAD_LMI
+ 	tristate "Lenovo WMI-based systems management driver"
+ 	depends on ACPI_WMI
+ 	select FW_ATTR_CLASS
+ 	help
+ 	  This driver allows changing BIOS settings on Lenovo machines whose
+ 	  BIOS support the WMI interface.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called think-lmi.
+ 
+ config INTEL_ATOMISP2_LED
+ 	tristate "Intel AtomISP2 camera LED driver"
+ 	depends on GPIOLIB && LEDS_GPIO
+ 	help
+ 	  Many Bay Trail and Cherry Trail devices come with a camera attached
+ 	  to Intel's Image Signal Processor. Linux currently does not have a
+ 	  driver for these, so they do not work as a camera. Some of these
+ 	  camera's have a LED which is controlled through a GPIO.
+ 
+ 	  Some of these devices have a firmware issue where the LED gets turned
+ 	  on at boot. This driver will turn the LED off at boot and also allows
+ 	  controlling the LED (repurposing it) through the sysfs LED interface.
+ 
+ 	  Which GPIO is attached to the LED is usually not described in the
+ 	  ACPI tables, so this driver contains per-system info about the GPIO
+ 	  inside the driver, this means that this driver only works on systems
+ 	  the driver knows about.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called intel_atomisp2_led.
+ 
+ config INTEL_ATOMISP2_PM
+ 	tristate "Intel AtomISP2 dummy / power-management driver"
+ 	depends on PCI && IOSF_MBI && PM
+ 	depends on !INTEL_ATOMISP
+ 	help
+ 	  Power-management driver for Intel's Image Signal Processor found on
+ 	  Bay Trail and Cherry Trail devices. This dummy driver's sole purpose
+ 	  is to turn the ISP off (put it in D3) to save power and to allow
+ 	  entering of S0ix modes.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called intel_atomisp2_pm.
+ 
+ config INTEL_CHT_INT33FE
+ 	tristate "Intel Cherry Trail ACPI INT33FE Driver"
+ 	depends on X86 && ACPI && I2C && REGULATOR
+ 	depends on CHARGER_BQ24190=y || (CHARGER_BQ24190=m && m)
+ 	depends on USB_ROLES_INTEL_XHCI=y || (USB_ROLES_INTEL_XHCI=m && m)
+ 	depends on TYPEC_MUX_PI3USB30532=y || (TYPEC_MUX_PI3USB30532=m && m)
+ 	help
+ 	  This driver add support for the INT33FE ACPI device found on
+ 	  some Intel Cherry Trail devices.
+ 
+ 	  There are two kinds of INT33FE ACPI device possible: for hardware
+ 	  with USB Type-C and Micro-B connectors. This driver supports both.
+ 
+ 	  The INT33FE ACPI device has a CRS table with I2cSerialBusV2
+ 	  resources for Fuel Gauge Controller and (in the Type-C variant)
+ 	  FUSB302 USB Type-C Controller and PI3USB30532 USB switch.
+ 	  This driver instantiates i2c-clients for these, so that standard
+ 	  i2c drivers for these chips can bind to the them.
+ 
+ 	  If you enable this driver it is advised to also select
+ 	  CONFIG_BATTERY_BQ27XXX=m or CONFIG_BATTERY_BQ27XXX_I2C=m for Micro-B
+ 	  device and CONFIG_TYPEC_FUSB302=m and CONFIG_BATTERY_MAX17042=m
+ 	  for Type-C device.
+ 
+ config INTEL_HID_EVENT
+ 	tristate "INTEL HID Event"
+ 	depends on ACPI
+ 	depends on INPUT
+ 	select INPUT_SPARSEKMAP
+ 	help
+ 	  This driver provides support for the Intel HID Event hotkey interface.
+ 	  Some laptops require this driver for hotkey support.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called intel_hid.
+ 
+ config INTEL_INT0002_VGPIO
+ 	tristate "Intel ACPI INT0002 Virtual GPIO driver"
+ 	depends on GPIOLIB && ACPI && PM_SLEEP
+ 	select GPIOLIB_IRQCHIP
+ 	help
+ 	  Some peripherals on Bay Trail and Cherry Trail platforms signal a
+ 	  Power Management Event (PME) to the Power Management Controller (PMC)
+ 	  to wakeup the system. When this happens software needs to explicitly
+ 	  clear the PME bus 0 status bit in the GPE0a_STS register to avoid an
+ 	  IRQ storm on IRQ 9.
+ 
+ 	  This is modelled in ACPI through the INT0002 ACPI device, which is
+ 	  called a "Virtual GPIO controller" in ACPI because it defines the
+ 	  event handler to call when the PME triggers through _AEI and _L02
+ 	  methods as would be done for a real GPIO interrupt in ACPI.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called intel_int0002_vgpio.
+ 
+ config INTEL_MENLOW
+ 	tristate "Thermal Management driver for Intel menlow platform"
+ 	depends on ACPI_THERMAL
+ 	select THERMAL
+ 	help
+ 	  ACPI thermal management enhancement driver on
+ 	  Intel Menlow platform.
+ 
+ 	  If unsure, say N.
+ 
+ config INTEL_OAKTRAIL
+ 	tristate "Intel Oaktrail Platform Extras"
+ 	depends on ACPI
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	depends on RFKILL && BACKLIGHT_CLASS_DEVICE && ACPI
+ 	help
+ 	  Intel Oaktrail platform need this driver to provide interfaces to
+ 	  enable/disable the Camera, WiFi, BT etc. devices. If in doubt, say Y
+ 	  here; it will only load on supported platforms.
+ 
+ config INTEL_VBTN
+ 	tristate "INTEL VIRTUAL BUTTON"
+ 	depends on ACPI
+ 	depends on INPUT
+ 	select INPUT_SPARSEKMAP
+ 	help
+ 	  This driver provides support for the Intel Virtual Button interface.
+ 	  Some laptops require this driver for power button support.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called intel_vbtn.
+ 
+ config MSI_LAPTOP
+ 	tristate "MSI Laptop Extras"
+ 	depends on ACPI
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on ACPI_VIDEO || ACPI_VIDEO = n
+ 	depends on RFKILL
+ 	depends on INPUT && SERIO_I8042
+ 	select INPUT_SPARSEKMAP
+ 	help
+ 	  This is a driver for laptops built by MSI (MICRO-STAR
+ 	  INTERNATIONAL):
+ 
+ 	  MSI MegaBook S270 (MS-1013)
+ 	  Cytron/TCM/Medion/Tchibo MD96100/SAM2000
+ 
+ 	  It adds support for Bluetooth, WLAN and LCD brightness control.
+ 
+ 	  More information about this driver is available at
+ 	  <http://0pointer.de/lennart/tchibo.html>.
+ 
+ 	  If you have an MSI S270 laptop, say Y or M here.
+ 
++>>>>>>> a40cd7ef22fb (platform/x86: think-lmi: Add WMI interface support on Lenovo platforms)
  config MSI_WMI
  	tristate "MSI WMI extras"
  	depends on ACPI_WMI
diff --cc drivers/platform/x86/Makefile
index bc00c206ad61,ff620d653d39..000000000000
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@@ -3,58 -3,100 +3,95 @@@
  # Makefile for linux/drivers/platform/x86
  # x86 Platform-Specific Drivers
  #
 +obj-$(CONFIG_X86_PLATFORM_DRIVERS_INTEL)		+= intel/
  
 -# Windows Management Interface
 -obj-$(CONFIG_ACPI_WMI)		+= wmi.o
 -obj-$(CONFIG_WMI_BMOF)		+= wmi-bmof.o
 -
 -# WMI drivers
 -obj-$(CONFIG_HUAWEI_WMI)		+= huawei-wmi.o
 -obj-$(CONFIG_INTEL_WMI_SBL_FW_UPDATE)	+= intel-wmi-sbl-fw-update.o
 -obj-$(CONFIG_INTEL_WMI_THUNDERBOLT)	+= intel-wmi-thunderbolt.o
 -obj-$(CONFIG_MXM_WMI)			+= mxm-wmi.o
 -obj-$(CONFIG_PEAQ_WMI)			+= peaq-wmi.o
 -obj-$(CONFIG_XIAOMI_WMI)		+= xiaomi-wmi.o
 -obj-$(CONFIG_GIGABYTE_WMI)		+= gigabyte-wmi.o
 -
 -# Acer
 -obj-$(CONFIG_ACERHDF)		+= acerhdf.o
 -obj-$(CONFIG_ACER_WIRELESS)	+= acer-wireless.o
 -obj-$(CONFIG_ACER_WMI)		+= acer-wmi.o
 -
 -# AMD
 -obj-$(CONFIG_AMD_PMC)		+= amd-pmc.o
 -
 -# Advantech
 -obj-$(CONFIG_ADV_SWBUTTON)	+= adv_swbutton.o
 -
 -# Apple
 -obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
 -
 -# ASUS
  obj-$(CONFIG_ASUS_LAPTOP)	+= asus-laptop.o
 -obj-$(CONFIG_ASUS_WIRELESS)	+= asus-wireless.o
  obj-$(CONFIG_ASUS_WMI)		+= asus-wmi.o
  obj-$(CONFIG_ASUS_NB_WMI)	+= asus-nb-wmi.o
 +obj-$(CONFIG_ASUS_WIRELESS)	+= asus-wireless.o
  obj-$(CONFIG_EEEPC_LAPTOP)	+= eeepc-laptop.o
  obj-$(CONFIG_EEEPC_WMI)		+= eeepc-wmi.o
 +obj-$(CONFIG_MSI_LAPTOP)	+= msi-laptop.o
 +obj-$(CONFIG_ACPI_CMPC)		+= classmate-laptop.o
 +obj-$(CONFIG_COMPAL_LAPTOP)	+= compal-laptop.o
 +obj-$(CONFIG_DCDBAS)		+= dcdbas.o
 +obj-$(CONFIG_DELL_SMBIOS)	+= dell-smbios.o
 +dell-smbios-objs		:= dell-smbios-base.o
 +dell-smbios-$(CONFIG_DELL_SMBIOS_WMI)	+= dell-smbios-wmi.o
 +dell-smbios-$(CONFIG_DELL_SMBIOS_SMM)	+= dell-smbios-smm.o
 +obj-$(CONFIG_DELL_LAPTOP)	+= dell-laptop.o
 +obj-$(CONFIG_DELL_WMI)		+= dell-wmi.o
 +obj-$(CONFIG_DELL_WMI_DESCRIPTOR)	+= dell-wmi-descriptor.o
 +obj-$(CONFIG_DELL_WMI_AIO)	+= dell-wmi-aio.o
 +obj-$(CONFIG_DELL_WMI_LED)	+= dell-wmi-led.o
 +obj-$(CONFIG_DELL_WMI_SYSMAN)		+= dell-wmi-sysman/
 +obj-$(CONFIG_DELL_SMO8800)	+= dell-smo8800.o
 +obj-$(CONFIG_DELL_RBTN)		+= dell-rbtn.o
 +obj-$(CONFIG_ACER_WMI)		+= acer-wmi.o
 +obj-$(CONFIG_ACER_WIRELESS)	+= acer-wireless.o
 +# AMD
 +obj-$(CONFIG_AMD_PMC)		+= amd-pmc.o
  
 -# Dell
 -obj-$(CONFIG_X86_PLATFORM_DRIVERS_DELL)		+= dell/
 -
 -# Fujitsu
 +obj-$(CONFIG_ACERHDF)		+= acerhdf.o
 +obj-$(CONFIG_HP_ACCEL)		+= hp_accel.o
 +obj-$(CONFIG_HP_WIRELESS)	+= hp-wireless.o
 +obj-$(CONFIG_HP_WMI)		+= hp-wmi.o
  obj-$(CONFIG_AMILO_RFKILL)	+= amilo-rfkill.o
 +obj-$(CONFIG_GPD_POCKET_FAN)	+= gpd-pocket-fan.o
 +obj-$(CONFIG_TC1100_WMI)	+= tc1100-wmi.o
 +obj-$(CONFIG_SONY_LAPTOP)	+= sony-laptop.o
 +obj-$(CONFIG_UV_SYSFS)		+= uv_sysfs.o
 +obj-$(CONFIG_IDEAPAD_LAPTOP)	+= ideapad-laptop.o
 +obj-$(CONFIG_THINKPAD_ACPI)	+= thinkpad_acpi.o
 +obj-$(CONFIG_SENSORS_HDAPS)	+= hdaps.o
  obj-$(CONFIG_FUJITSU_LAPTOP)	+= fujitsu-laptop.o
  obj-$(CONFIG_FUJITSU_TABLET)	+= fujitsu-tablet.o
++<<<<<<< HEAD
 +obj-$(CONFIG_PANASONIC_LAPTOP)	+= panasonic-laptop.o
 +obj-$(CONFIG_INTEL_MENLOW)	+= intel_menlow.o
 +obj-$(CONFIG_ACPI_WMI)		+= wmi.o
++=======
+ 
+ # GPD
+ obj-$(CONFIG_GPD_POCKET_FAN)	+= gpd-pocket-fan.o
+ 
+ # Hewlett Packard
+ obj-$(CONFIG_HP_ACCEL)		+= hp_accel.o
+ obj-$(CONFIG_HP_WMI)		+= hp-wmi.o
+ obj-$(CONFIG_TC1100_WMI)	+= tc1100-wmi.o
+ 
+ # Hewlett Packard Enterprise
+ obj-$(CONFIG_UV_SYSFS)       += uv_sysfs.o
+ 
+ # IBM Thinkpad and Lenovo
+ obj-$(CONFIG_IBM_RTL)		+= ibm_rtl.o
+ obj-$(CONFIG_IDEAPAD_LAPTOP)	+= ideapad-laptop.o
+ obj-$(CONFIG_SENSORS_HDAPS)	+= hdaps.o
+ obj-$(CONFIG_THINKPAD_ACPI)	+= thinkpad_acpi.o
+ obj-$(CONFIG_THINKPAD_LMI)	+= think-lmi.o
+ 
+ # Intel
+ obj-$(CONFIG_INTEL_ATOMISP2_LED)	+= intel_atomisp2_led.o
+ obj-$(CONFIG_INTEL_ATOMISP2_PM)		+= intel_atomisp2_pm.o
+ obj-$(CONFIG_INTEL_CHT_INT33FE)		+= intel_cht_int33fe.o
+ intel_cht_int33fe-objs			:= intel_cht_int33fe_common.o \
+ 					   intel_cht_int33fe_typec.o \
+ 					   intel_cht_int33fe_microb.o
+ obj-$(CONFIG_INTEL_HID_EVENT)		+= intel-hid.o
+ obj-$(CONFIG_INTEL_INT0002_VGPIO)	+= intel_int0002_vgpio.o
+ obj-$(CONFIG_INTEL_MENLOW)		+= intel_menlow.o
+ obj-$(CONFIG_INTEL_OAKTRAIL)		+= intel_oaktrail.o
+ obj-$(CONFIG_INTEL_VBTN)		+= intel-vbtn.o
+ 
+ # MSI
+ obj-$(CONFIG_MSI_LAPTOP)	+= msi-laptop.o
++>>>>>>> a40cd7ef22fb (platform/x86: think-lmi: Add WMI interface support on Lenovo platforms)
  obj-$(CONFIG_MSI_WMI)		+= msi-wmi.o
 -
 -# OLPC
 -obj-$(CONFIG_XO15_EBOOK)	+= xo15-ebook.o
 -obj-$(CONFIG_XO1_RFKILL)	+= xo1-rfkill.o
 -
 -# PC Engines
 -obj-$(CONFIG_PCENGINES_APU2)	+= pcengines-apuv2.o
 -
 -# Samsung
 -obj-$(CONFIG_SAMSUNG_LAPTOP)	+= samsung-laptop.o
 -obj-$(CONFIG_SAMSUNG_Q10)	+= samsung-q10.o
 -
 -# Toshiba
 -obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
 -obj-$(CONFIG_TOSHIBA_HAPS)	+= toshiba_haps.o
 -obj-$(CONFIG_TOSHIBA_WMI)	+= toshiba-wmi.o
 +obj-$(CONFIG_PEAQ_WMI)		+= peaq-wmi.o
 +obj-$(CONFIG_SURFACE3_WMI)	+= surface3-wmi.o
 +obj-$(CONFIG_TOPSTAR_LAPTOP)	+= topstar-laptop.o
 +obj-$(CONFIG_WMI_BMOF)		+= wmi-bmof.o
 +obj-$(CONFIG_INTEL_WMI_THUNDERBOLT)	+= intel-wmi-thunderbolt.o
  
  # toshiba_acpi must link after wmi to ensure that wmi devices are found
  # before toshiba_acpi initializes
diff --git a/Documentation/ABI/testing/sysfs-class-firmware-attributes b/Documentation/ABI/testing/sysfs-class-firmware-attributes
index 8ea59fea4709..3348bf80a37c 100644
--- a/Documentation/ABI/testing/sysfs-class-firmware-attributes
+++ b/Documentation/ABI/testing/sysfs-class-firmware-attributes
@@ -197,8 +197,24 @@ Description:
 		Drivers may emit a CHANGE uevent when a password is set or unset
 		userspace may check it again.
 
-		On Dell systems, if Admin password is set, then all BIOS attributes
+		On Dell and Lenovo systems, if Admin password is set, then all BIOS attributes
 		require password validation.
+		On Lenovo systems if you change the Admin password the new password is not active until
+		the next boot.
+
+		Lenovo specific class extensions
+		------------------------------
+
+		On Lenovo systems the following additional settings are available:
+
+		lenovo_encoding:
+					The encoding method that is used. This can be either "ascii"
+					or "scancode". Default is set to "ascii"
+
+		lenovo_kbdlang:
+					The keyboard language method that is used. This is generally a
+					two char code (e.g. "us", "fr", "gr") and may vary per platform.
+					Default is set to "us"
 
 What:		/sys/class/firmware-attributes/*/attributes/pending_reboot
 Date:		February 2021
* Unmerged path MAINTAINERS
* Unmerged path drivers/platform/x86/Kconfig
* Unmerged path drivers/platform/x86/Makefile
diff --git a/drivers/platform/x86/think-lmi.c b/drivers/platform/x86/think-lmi.c
new file mode 100644
index 000000000000..854427fed1a9
--- /dev/null
+++ b/drivers/platform/x86/think-lmi.c
@@ -0,0 +1,891 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Think LMI BIOS configuration driver
+ *
+ * Copyright(C) 2019-2021 Lenovo
+ *
+ * Original code from Thinkpad-wmi project https://github.com/iksaif/thinkpad-wmi
+ * Copyright(C) 2017 Corentin Chary <corentin.chary@gmail.com>
+ * Distributed under the GPL-2.0 license
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/acpi.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wmi.h>
+#include "firmware_attributes_class.h"
+#include "think-lmi.h"
+
+/*
+ * Name:
+ *  Lenovo_BiosSetting
+ * Description:
+ *  Get item name and settings for current LMI instance.
+ * Type:
+ *  Query
+ * Returns:
+ *  "Item,Value"
+ * Example:
+ *  "WakeOnLAN,Enable"
+ */
+#define LENOVO_BIOS_SETTING_GUID "51F5230E-9677-46CD-A1CF-C0B23EE34DB7"
+
+/*
+ * Name:
+ *  Lenovo_SetBiosSetting
+ * Description:
+ *  Change the BIOS setting to the desired value using the Lenovo_SetBiosSetting
+ *  class. To save the settings, use the Lenovo_SaveBiosSetting class.
+ *  BIOS settings and values are case sensitive.
+ *  After making changes to the BIOS settings, you must reboot the computer
+ *  before the changes will take effect.
+ * Type:
+ *  Method
+ * Arguments:
+ *  "Item,Value,Password,Encoding,KbdLang;"
+ * Example:
+ *  "WakeOnLAN,Disable,pa55w0rd,ascii,us;"
+ */
+#define LENOVO_SET_BIOS_SETTINGS_GUID "98479A64-33F5-4E33-A707-8E251EBBC3A1"
+
+/*
+ * Name:
+ *  Lenovo_SaveBiosSettings
+ * Description:
+ *  Save any pending changes in settings.
+ * Type:
+ *  Method
+ * Arguments:
+ *  "Password,Encoding,KbdLang;"
+ * Example:
+ * "pa55w0rd,ascii,us;"
+ */
+#define LENOVO_SAVE_BIOS_SETTINGS_GUID "6A4B54EF-A5ED-4D33-9455-B0D9B48DF4B3"
+
+/*
+ * Name:
+ *  Lenovo_BiosPasswordSettings
+ * Description:
+ *  Return BIOS Password settings
+ * Type:
+ *  Query
+ * Returns:
+ *  PasswordMode, PasswordState, MinLength, MaxLength,
+ *  SupportedEncoding, SupportedKeyboard
+ */
+#define LENOVO_BIOS_PASSWORD_SETTINGS_GUID "8ADB159E-1E32-455C-BC93-308A7ED98246"
+
+/*
+ * Name:
+ *  Lenovo_SetBiosPassword
+ * Description:
+ *  Change a specific password.
+ *  - BIOS settings cannot be changed at the same boot as power-on
+ *    passwords (POP) and hard disk passwords (HDP). If you want to change
+ *    BIOS settings and POP or HDP, you must reboot the system after changing
+ *    one of them.
+ *  - A password cannot be set using this method when one does not already
+ *    exist. Passwords can only be updated or cleared.
+ * Type:
+ *  Method
+ * Arguments:
+ *  "PasswordType,CurrentPassword,NewPassword,Encoding,KbdLang;"
+ * Example:
+ *  "pop,pa55w0rd,newpa55w0rd,ascii,us;â€
+ */
+#define LENOVO_SET_BIOS_PASSWORD_GUID "2651D9FD-911C-4B69-B94E-D0DED5963BD7"
+
+/*
+ * Name:
+ *  Lenovo_GetBiosSelections
+ * Description:
+ *  Return a list of valid settings for a given item.
+ * Type:
+ *  Method
+ * Arguments:
+ *  "Item"
+ * Returns:
+ *  "Value1,Value2,Value3,..."
+ * Example:
+ *  -> "FlashOverLAN"
+ *  <- "Enabled,Disabled"
+ */
+#define LENOVO_GET_BIOS_SELECTIONS_GUID	"7364651A-132F-4FE7-ADAA-40C6C7EE2E3B"
+
+#define TLMI_POP_PWD (1 << 0)
+#define TLMI_PAP_PWD (1 << 1)
+#define to_tlmi_pwd_setting(kobj)  container_of(kobj, struct tlmi_pwd_setting, kobj)
+#define to_tlmi_attr_setting(kobj)  container_of(kobj, struct tlmi_attr_setting, kobj)
+
+static const struct tlmi_err_codes tlmi_errs[] = {
+	{"Success", 0},
+	{"Not Supported", -EOPNOTSUPP},
+	{"Invalid Parameter", -EINVAL},
+	{"Access Denied", -EACCES},
+	{"System Busy", -EBUSY},
+};
+
+static const char * const encoding_options[] = {
+	[TLMI_ENCODING_ASCII] = "ascii",
+	[TLMI_ENCODING_SCANCODE] = "scancode",
+};
+static struct think_lmi tlmi_priv;
+struct class *fw_attr_class;
+
+/* ------ Utility functions ------------*/
+/* Convert BIOS WMI error string to suitable error code */
+static int tlmi_errstr_to_err(const char *errstr)
+{
+	int i;
+
+	for (i = 0; i < sizeof(tlmi_errs)/sizeof(struct tlmi_err_codes); i++) {
+		if (!strcmp(tlmi_errs[i].err_str, errstr))
+			return tlmi_errs[i].err_code;
+	}
+	return -EPERM;
+}
+
+/* Extract error string from WMI return buffer */
+static int tlmi_extract_error(const struct acpi_buffer *output)
+{
+	const union acpi_object *obj;
+
+	obj = output->pointer;
+	if (!obj)
+		return -ENOMEM;
+	if (obj->type != ACPI_TYPE_STRING || !obj->string.pointer)
+		return -EIO;
+
+	return tlmi_errstr_to_err(obj->string.pointer);
+}
+
+/* Utility function to execute WMI call to BIOS */
+static int tlmi_simple_call(const char *guid, const char *arg)
+{
+	const struct acpi_buffer input = { strlen(arg), (char *)arg };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	acpi_status status;
+	int i, err;
+
+	/*
+	 * Duplicated call required to match BIOS workaround for behavior
+	 * seen when WMI accessed via scripting on other OS.
+	 */
+	for (i = 0; i < 2; i++) {
+		/* (re)initialize output buffer to default state */
+		output.length = ACPI_ALLOCATE_BUFFER;
+		output.pointer = NULL;
+
+		status = wmi_evaluate_method(guid, 0, 0, &input, &output);
+		if (ACPI_FAILURE(status)) {
+			kfree(output.pointer);
+			return -EIO;
+		}
+		err = tlmi_extract_error(&output);
+		kfree(output.pointer);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+/* Extract output string from WMI return buffer */
+static int tlmi_extract_output_string(const struct acpi_buffer *output,
+				      char **string)
+{
+	const union acpi_object *obj;
+	char *s;
+
+	obj = output->pointer;
+	if (!obj)
+		return -ENOMEM;
+	if (obj->type != ACPI_TYPE_STRING || !obj->string.pointer)
+		return -EIO;
+
+	s = kstrdup(obj->string.pointer, GFP_KERNEL);
+	if (!s)
+		return -ENOMEM;
+	*string = s;
+	return 0;
+}
+
+/* ------ Core interface functions ------------*/
+
+/* Get password settings from BIOS */
+static int tlmi_get_pwd_settings(struct tlmi_pwdcfg *pwdcfg)
+{
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	const union acpi_object *obj;
+	acpi_status status;
+
+	if (!tlmi_priv.can_get_password_settings)
+		return -EOPNOTSUPP;
+
+	status = wmi_query_block(LENOVO_BIOS_PASSWORD_SETTINGS_GUID, 0,
+				 &output);
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	obj = output.pointer;
+	if (!obj)
+		return -ENOMEM;
+	if (obj->type != ACPI_TYPE_BUFFER || !obj->buffer.pointer) {
+		kfree(obj);
+		return -EIO;
+	}
+	/*
+	 * The size of thinkpad_wmi_pcfg on ThinkStation is larger than ThinkPad.
+	 * To make the driver compatible on different brands, we permit it to get
+	 * the data in below case.
+	 */
+	if (obj->buffer.length < sizeof(struct tlmi_pwdcfg)) {
+		pr_warn("Unknown pwdcfg buffer length %d\n", obj->buffer.length);
+		kfree(obj);
+		return -EIO;
+	}
+	memcpy(pwdcfg, obj->buffer.pointer, sizeof(struct tlmi_pwdcfg));
+	kfree(obj);
+	return 0;
+}
+
+static int tlmi_save_bios_settings(const char *password)
+{
+	return tlmi_simple_call(LENOVO_SAVE_BIOS_SETTINGS_GUID,
+				password);
+}
+
+static int tlmi_setting(int item, char **value, const char *guid_string)
+{
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	acpi_status status;
+	int ret;
+
+	status = wmi_query_block(guid_string, item, &output);
+	if (ACPI_FAILURE(status)) {
+		kfree(output.pointer);
+		return -EIO;
+	}
+
+	ret = tlmi_extract_output_string(&output, value);
+	kfree(output.pointer);
+	return ret;
+}
+
+static int tlmi_get_bios_selections(const char *item, char **value)
+{
+	const struct acpi_buffer input = { strlen(item), (char *)item };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	acpi_status status;
+	int ret;
+
+	status = wmi_evaluate_method(LENOVO_GET_BIOS_SELECTIONS_GUID,
+				     0, 0, &input, &output);
+
+	if (ACPI_FAILURE(status)) {
+		kfree(output.pointer);
+		return -EIO;
+	}
+
+	ret = tlmi_extract_output_string(&output, value);
+	kfree(output.pointer);
+	return ret;
+}
+
+/* ---- Authentication sysfs --------------------------------------------------------- */
+static ssize_t is_enabled_show(struct kobject *kobj, struct kobj_attribute *attr,
+					  char *buf)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	return sysfs_emit(buf, "%d\n", setting->valid);
+}
+
+static struct kobj_attribute auth_is_pass_set = __ATTR_RO(is_enabled);
+
+static ssize_t current_password_store(struct kobject *kobj,
+				      struct kobj_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+	size_t pwdlen;
+	char *p;
+
+	pwdlen = strlen(buf);
+	/* pwdlen == 0 is allowed to clear the password */
+	if (pwdlen && ((pwdlen < setting->minlen) || (pwdlen > setting->maxlen)))
+		return -EINVAL;
+
+	strscpy(setting->password, buf, setting->maxlen);
+	/* Strip out CR if one is present, setting password won't work if it is present */
+	p = strchrnul(setting->password, '\n');
+	*p = '\0';
+	return count;
+}
+
+static struct kobj_attribute auth_current_password = __ATTR_WO(current_password);
+
+static ssize_t new_password_store(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+	char *auth_str, *new_pwd, *p;
+	size_t pwdlen;
+	int ret;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (!tlmi_priv.can_set_bios_password)
+		return -EOPNOTSUPP;
+
+	new_pwd = kstrdup(buf, GFP_KERNEL);
+	if (!new_pwd)
+		return -ENOMEM;
+
+	/* Strip out CR if one is present, setting password won't work if it is present */
+	p = strchrnul(new_pwd, '\n');
+	*p = '\0';
+
+	pwdlen = strlen(new_pwd);
+	/* pwdlen == 0 is allowed to clear the password */
+	if (pwdlen && ((pwdlen < setting->minlen) || (pwdlen > setting->maxlen))) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Format: 'PasswordType,CurrentPw,NewPw,Encoding,KbdLang;' */
+	auth_str = kasprintf(GFP_KERNEL, "%s,%s,%s,%s,%s;",
+		 setting->pwd_type, setting->password, new_pwd,
+		 encoding_options[setting->encoding], setting->kbdlang);
+	if (!auth_str) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = tlmi_simple_call(LENOVO_SET_BIOS_PASSWORD_GUID, auth_str);
+	kfree(auth_str);
+out:
+	kfree(new_pwd);
+	return ret ?: count;
+}
+
+static struct kobj_attribute auth_new_password = __ATTR_WO(new_password);
+
+static ssize_t min_password_length_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	return sysfs_emit(buf, "%d\n", setting->minlen);
+}
+
+static struct kobj_attribute auth_min_pass_length = __ATTR_RO(min_password_length);
+
+static ssize_t max_password_length_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	return sysfs_emit(buf, "%d\n", setting->maxlen);
+}
+static struct kobj_attribute auth_max_pass_length = __ATTR_RO(max_password_length);
+
+static ssize_t mechanism_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sysfs_emit(buf, "password\n");
+}
+static struct kobj_attribute auth_mechanism = __ATTR_RO(mechanism);
+
+static ssize_t encoding_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	return sysfs_emit(buf, "%s\n", encoding_options[setting->encoding]);
+}
+
+static ssize_t encoding_store(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+	int i;
+
+	/* Scan for a matching profile */
+	i = sysfs_match_string(encoding_options, buf);
+	if (i < 0)
+		return -EINVAL;
+
+	setting->encoding = i;
+	return count;
+}
+
+static struct kobj_attribute auth_encoding = __ATTR_RW(encoding);
+
+static ssize_t kbdlang_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	return sysfs_emit(buf, "%s\n", setting->kbdlang);
+}
+
+static ssize_t kbdlang_store(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+	int length;
+
+	length = strlen(buf);
+	if (buf[length-1] == '\n')
+		length--;
+
+	if (!length || (length >= TLMI_LANG_MAXLEN))
+		return -EINVAL;
+
+	memcpy(setting->kbdlang, buf, length);
+	setting->kbdlang[length] = '\0';
+	return count;
+}
+
+static struct kobj_attribute auth_kbdlang = __ATTR_RW(kbdlang);
+
+static ssize_t role_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	return sysfs_emit(buf, "%s\n", setting->role);
+}
+static struct kobj_attribute auth_role = __ATTR_RO(role);
+
+static struct attribute *auth_attrs[] = {
+	&auth_is_pass_set.attr,
+	&auth_min_pass_length.attr,
+	&auth_max_pass_length.attr,
+	&auth_current_password.attr,
+	&auth_new_password.attr,
+	&auth_role.attr,
+	&auth_mechanism.attr,
+	&auth_encoding.attr,
+	&auth_kbdlang.attr,
+	NULL
+};
+
+static const struct attribute_group auth_attr_group = {
+	.attrs = auth_attrs,
+};
+
+/* ---- Attributes sysfs --------------------------------------------------------- */
+static ssize_t display_name_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf)
+{
+	struct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);
+
+	return sysfs_emit(buf, "%s\n", setting->display_name);
+}
+
+static ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);
+	char *item;
+	int ret;
+
+	ret = tlmi_setting(setting->index, &item, LENOVO_BIOS_SETTING_GUID);
+	if (ret)
+		return ret;
+
+	ret = sysfs_emit(buf, "%s\n", item);
+	kfree(item);
+	return ret;
+}
+
+static ssize_t possible_values_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);
+
+	if (!tlmi_priv.can_get_bios_selections)
+		return -EOPNOTSUPP;
+
+	return sysfs_emit(buf, "%s\n", setting->possible_values);
+}
+
+static ssize_t current_value_store(struct kobject *kobj,
+		struct kobj_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);
+	char *set_str = NULL, *new_setting = NULL;
+	char *auth_str = NULL;
+	char *p;
+	int ret;
+
+	if (!tlmi_priv.can_set_bios_settings)
+		return -EOPNOTSUPP;
+
+	new_setting = kstrdup(buf, GFP_KERNEL);
+	if (!new_setting)
+		return -ENOMEM;
+
+	/* Strip out CR if one is present */
+	p = strchrnul(new_setting, '\n');
+	*p = '\0';
+
+	if (tlmi_priv.pwd_admin->valid && tlmi_priv.pwd_admin->password) {
+		auth_str = kasprintf(GFP_KERNEL, "%s,%s,%s;",
+				tlmi_priv.pwd_admin->password,
+				encoding_options[tlmi_priv.pwd_admin->encoding],
+				tlmi_priv.pwd_admin->kbdlang);
+		if (!auth_str) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	if (auth_str)
+		set_str = kasprintf(GFP_KERNEL, "%s,%s,%s", setting->display_name,
+				new_setting, auth_str);
+	else
+		set_str = kasprintf(GFP_KERNEL, "%s,%s;", setting->display_name,
+				new_setting);
+	if (!set_str) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = tlmi_simple_call(LENOVO_SET_BIOS_SETTINGS_GUID, set_str);
+	if (ret)
+		goto out;
+
+	if (tlmi_priv.pwd_admin->valid && tlmi_priv.pwd_admin->password)
+		ret = tlmi_save_bios_settings(auth_str);
+	else
+		ret = tlmi_save_bios_settings("");
+
+out:
+	kfree(auth_str);
+	kfree(set_str);
+	kfree(new_setting);
+	return ret ?: count;
+}
+
+static struct kobj_attribute attr_displ_name = __ATTR_RO(display_name);
+
+static struct kobj_attribute attr_possible_values = __ATTR_RO(possible_values);
+
+static struct kobj_attribute attr_current_val = __ATTR_RW_MODE(current_value, 0600);
+
+static struct attribute *tlmi_attrs[] = {
+	&attr_displ_name.attr,
+	&attr_current_val.attr,
+	&attr_possible_values.attr,
+	NULL
+};
+
+static const struct attribute_group tlmi_attr_group = {
+	.attrs = tlmi_attrs,
+};
+
+static ssize_t tlmi_attr_show(struct kobject *kobj, struct attribute *attr,
+				    char *buf)
+{
+	struct kobj_attribute *kattr;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->show)
+		return kattr->show(kobj, kattr, buf);
+	return -EIO;
+}
+
+static ssize_t tlmi_attr_store(struct kobject *kobj, struct attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct kobj_attribute *kattr;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->store)
+		return kattr->store(kobj, kattr, buf, count);
+	return -EIO;
+}
+
+static const struct sysfs_ops tlmi_kobj_sysfs_ops = {
+	.show	= tlmi_attr_show,
+	.store	= tlmi_attr_store,
+};
+
+static void tlmi_attr_setting_release(struct kobject *kobj)
+{
+	struct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);
+
+	kfree(setting);
+}
+
+static void tlmi_pwd_setting_release(struct kobject *kobj)
+{
+	struct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);
+
+	kfree(setting);
+}
+
+static struct kobj_type tlmi_attr_setting_ktype = {
+	.release        = &tlmi_attr_setting_release,
+	.sysfs_ops	= &tlmi_kobj_sysfs_ops,
+};
+
+static struct kobj_type tlmi_pwd_setting_ktype = {
+	.release        = &tlmi_pwd_setting_release,
+	.sysfs_ops	= &tlmi_kobj_sysfs_ops,
+};
+
+/* ---- Initialisation --------------------------------------------------------- */
+static void tlmi_release_attr(void)
+{
+	int i;
+
+	/* Attribute structures */
+	for (i = 0; i < TLMI_SETTINGS_COUNT; i++) {
+		if (tlmi_priv.setting[i]) {
+			kfree(tlmi_priv.setting[i]->possible_values);
+			sysfs_remove_group(&tlmi_priv.setting[i]->kobj, &tlmi_attr_group);
+			kobject_put(&tlmi_priv.setting[i]->kobj);
+		}
+	}
+	kset_unregister(tlmi_priv.attribute_kset);
+
+	/* Authentication structures */
+	sysfs_remove_group(&tlmi_priv.pwd_admin->kobj, &auth_attr_group);
+	kobject_put(&tlmi_priv.pwd_admin->kobj);
+	sysfs_remove_group(&tlmi_priv.pwd_power->kobj, &auth_attr_group);
+	kobject_put(&tlmi_priv.pwd_power->kobj);
+	kset_unregister(tlmi_priv.authentication_kset);
+}
+
+static int tlmi_sysfs_init(void)
+{
+	int i, ret;
+
+	ret = fw_attributes_class_get(&fw_attr_class);
+	if (ret)
+		return ret;
+
+	tlmi_priv.class_dev = device_create(fw_attr_class, NULL, MKDEV(0, 0),
+			NULL, "%s", "thinklmi");
+	if (IS_ERR(tlmi_priv.class_dev)) {
+		ret = PTR_ERR(tlmi_priv.class_dev);
+		goto fail_class_created;
+	}
+
+	tlmi_priv.attribute_kset = kset_create_and_add("attributes", NULL,
+			&tlmi_priv.class_dev->kobj);
+	if (!tlmi_priv.attribute_kset) {
+		ret = -ENOMEM;
+		goto fail_device_created;
+	}
+
+	for (i = 0; i < TLMI_SETTINGS_COUNT; i++) {
+		/* Check if index is a valid setting - skip if it isn't */
+		if (!tlmi_priv.setting[i])
+			continue;
+
+		/* Build attribute */
+		tlmi_priv.setting[i]->kobj.kset = tlmi_priv.attribute_kset;
+		ret = kobject_init_and_add(&tlmi_priv.setting[i]->kobj, &tlmi_attr_setting_ktype,
+				NULL, "%s", tlmi_priv.setting[i]->display_name);
+		if (ret)
+			goto fail_create_attr;
+
+		ret = sysfs_create_group(&tlmi_priv.setting[i]->kobj, &tlmi_attr_group);
+		if (ret)
+			goto fail_create_attr;
+	}
+
+	/* Create authentication entries */
+	tlmi_priv.authentication_kset = kset_create_and_add("authentication", NULL,
+								&tlmi_priv.class_dev->kobj);
+	if (!tlmi_priv.authentication_kset) {
+		ret = -ENOMEM;
+		goto fail_create_attr;
+	}
+	tlmi_priv.pwd_admin->kobj.kset = tlmi_priv.authentication_kset;
+	ret = kobject_init_and_add(&tlmi_priv.pwd_admin->kobj, &tlmi_pwd_setting_ktype,
+			NULL, "%s", "Admin");
+	if (ret)
+		goto fail_create_attr;
+
+	ret = sysfs_create_group(&tlmi_priv.pwd_admin->kobj, &auth_attr_group);
+	if (ret)
+		goto fail_create_attr;
+
+	tlmi_priv.pwd_power->kobj.kset = tlmi_priv.authentication_kset;
+	ret = kobject_init_and_add(&tlmi_priv.pwd_power->kobj, &tlmi_pwd_setting_ktype,
+			NULL, "%s", "System");
+	if (ret)
+		goto fail_create_attr;
+
+	ret = sysfs_create_group(&tlmi_priv.pwd_power->kobj, &auth_attr_group);
+	if (ret)
+		goto fail_create_attr;
+
+	return ret;
+
+fail_create_attr:
+	tlmi_release_attr();
+fail_device_created:
+	device_destroy(fw_attr_class, MKDEV(0, 0));
+fail_class_created:
+	fw_attributes_class_put();
+	return ret;
+}
+
+/* ---- Base Driver -------------------------------------------------------- */
+static int tlmi_analyze(void)
+{
+	struct tlmi_pwdcfg pwdcfg;
+	acpi_status status;
+	int i, ret;
+
+	if (wmi_has_guid(LENOVO_SET_BIOS_SETTINGS_GUID) &&
+	    wmi_has_guid(LENOVO_SAVE_BIOS_SETTINGS_GUID))
+		tlmi_priv.can_set_bios_settings = true;
+
+	if (wmi_has_guid(LENOVO_GET_BIOS_SELECTIONS_GUID))
+		tlmi_priv.can_get_bios_selections = true;
+
+	if (wmi_has_guid(LENOVO_SET_BIOS_PASSWORD_GUID))
+		tlmi_priv.can_set_bios_password = true;
+
+	if (wmi_has_guid(LENOVO_BIOS_PASSWORD_SETTINGS_GUID))
+		tlmi_priv.can_get_password_settings = true;
+
+	/*
+	 * Try to find the number of valid settings of this machine
+	 * and use it to create sysfs attributes.
+	 */
+	for (i = 0; i < TLMI_SETTINGS_COUNT; ++i) {
+		struct tlmi_attr_setting *setting;
+		char *item = NULL;
+		char *p;
+
+		tlmi_priv.setting[i] = NULL;
+		status = tlmi_setting(i, &item, LENOVO_BIOS_SETTING_GUID);
+		if (ACPI_FAILURE(status))
+			break;
+		if (!item)
+			break;
+		if (!*item)
+			continue;
+
+		/* It is not allowed to have '/' for file name. Convert it into '\'. */
+		strreplace(item, '/', '\\');
+
+		/* Remove the value part */
+		p = strchrnul(item, ',');
+		*p = '\0';
+
+		/* Create a setting entry */
+		setting = kzalloc(sizeof(*setting), GFP_KERNEL);
+		if (!setting) {
+			ret = -ENOMEM;
+			goto fail_clear_attr;
+		}
+		setting->index = i;
+		strscpy(setting->display_name, item, TLMI_SETTINGS_MAXLEN);
+		/* If BIOS selections supported, load those */
+		if (tlmi_priv.can_get_bios_selections) {
+			ret = tlmi_get_bios_selections(setting->display_name,
+					&setting->possible_values);
+			if (ret || !setting->possible_values)
+				pr_info("Error retrieving possible values for %d : %s\n",
+						i, setting->display_name);
+		}
+		tlmi_priv.setting[i] = setting;
+		tlmi_priv.settings_count++;
+		kfree(item);
+	}
+
+	/* Create password setting structure */
+	ret = tlmi_get_pwd_settings(&pwdcfg);
+	if (ret)
+		goto fail_clear_attr;
+
+	tlmi_priv.pwd_admin = kzalloc(sizeof(struct tlmi_pwd_setting), GFP_KERNEL);
+	if (!tlmi_priv.pwd_admin) {
+		ret = -ENOMEM;
+		goto fail_clear_attr;
+	}
+	strscpy(tlmi_priv.pwd_admin->display_name, "admin", TLMI_PWDTYPE_MAXLEN);
+	strscpy(tlmi_priv.pwd_admin->kbdlang, "us", TLMI_LANG_MAXLEN);
+	tlmi_priv.pwd_admin->encoding = TLMI_ENCODING_ASCII;
+	tlmi_priv.pwd_admin->pwd_type = "pap";
+	tlmi_priv.pwd_admin->role = "bios-admin";
+	tlmi_priv.pwd_admin->minlen = pwdcfg.min_length;
+	if (WARN_ON(pwdcfg.max_length >= TLMI_PWD_BUFSIZE))
+		pwdcfg.max_length = TLMI_PWD_BUFSIZE - 1;
+	tlmi_priv.pwd_admin->maxlen = pwdcfg.max_length;
+	if (pwdcfg.password_state & TLMI_PAP_PWD)
+		tlmi_priv.pwd_admin->valid = true;
+
+	tlmi_priv.pwd_power = kzalloc(sizeof(struct tlmi_pwd_setting), GFP_KERNEL);
+	if (!tlmi_priv.pwd_power) {
+		ret = -ENOMEM;
+		goto fail_clear_attr;
+	}
+	strscpy(tlmi_priv.pwd_power->display_name, "power-on", TLMI_PWDTYPE_MAXLEN);
+	strscpy(tlmi_priv.pwd_power->kbdlang, "us", TLMI_LANG_MAXLEN);
+	tlmi_priv.pwd_power->encoding = TLMI_ENCODING_ASCII;
+	tlmi_priv.pwd_power->pwd_type = "pop";
+	tlmi_priv.pwd_power->role = "power-on";
+	tlmi_priv.pwd_power->minlen = pwdcfg.min_length;
+	tlmi_priv.pwd_power->maxlen = pwdcfg.max_length;
+
+	if (pwdcfg.password_state & TLMI_POP_PWD)
+		tlmi_priv.pwd_power->valid = true;
+
+	return 0;
+
+fail_clear_attr:
+	for (i = 0; i < TLMI_SETTINGS_COUNT; ++i)
+		kfree(tlmi_priv.setting[i]);
+	return ret;
+}
+
+static void tlmi_remove(struct wmi_device *wdev)
+{
+	tlmi_release_attr();
+	device_destroy(fw_attr_class, MKDEV(0, 0));
+	fw_attributes_class_put();
+}
+
+static int tlmi_probe(struct wmi_device *wdev, const void *context)
+{
+	tlmi_analyze();
+	return tlmi_sysfs_init();
+}
+
+static const struct wmi_device_id tlmi_id_table[] = {
+	{ .guid_string = LENOVO_BIOS_SETTING_GUID },
+	{ }
+};
+
+static struct wmi_driver tlmi_driver = {
+	.driver = {
+		.name = "think-lmi",
+	},
+	.id_table = tlmi_id_table,
+	.probe = tlmi_probe,
+	.remove = tlmi_remove,
+};
+
+MODULE_AUTHOR("Sugumaran L <slacshiminar@lenovo.com>");
+MODULE_AUTHOR("Mark Pearson <markpearson@lenovo.com>");
+MODULE_AUTHOR("Corentin Chary <corentin.chary@gmail.com>");
+MODULE_DESCRIPTION("ThinkLMI Driver");
+MODULE_LICENSE("GPL");
+
+module_wmi_driver(tlmi_driver);
diff --git a/drivers/platform/x86/think-lmi.h b/drivers/platform/x86/think-lmi.h
new file mode 100644
index 000000000000..6cd5325cc50e
--- /dev/null
+++ b/drivers/platform/x86/think-lmi.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _THINK_LMI_H_
+#define _THINK_LMI_H_
+
+#include <linux/types.h>
+
+#define TLMI_SETTINGS_COUNT  256
+#define TLMI_SETTINGS_MAXLEN 512
+#define TLMI_PWD_BUFSIZE     129
+#define TLMI_PWDTYPE_MAXLEN   64
+#define TLMI_ENC_MAXLEN       64
+#define TLMI_LANG_MAXLEN       4
+#define TLMI_PWDTYPE_LEN       4
+/*
+ * Longest string should be in the set command: allow size of BIOS
+ * option and choice
+ */
+#define TLMI_GETSET_MAXLEN (TLMI_SETTINGS_MAXLEN + TLMI_SETTINGS_MAXLEN)
+
+/* Possible error values */
+struct tlmi_err_codes {
+	const char *err_str;
+	int err_code;
+};
+
+enum encoding_option {
+	TLMI_ENCODING_ASCII,
+	TLMI_ENCODING_SCANCODE,
+};
+
+/* password configuration details */
+struct tlmi_pwdcfg {
+	uint32_t password_mode;
+	uint32_t password_state;
+	uint32_t min_length;
+	uint32_t max_length;
+	uint32_t supported_encodings;
+	uint32_t supported_keyboard;
+};
+
+/* password setting details */
+struct tlmi_pwd_setting {
+	struct kobject kobj;
+	bool valid;
+	char display_name[TLMI_PWDTYPE_MAXLEN];
+	char password[TLMI_PWD_BUFSIZE];
+	const char *pwd_type;
+	const char *role;
+	int minlen;
+	int maxlen;
+	enum encoding_option encoding;
+	char kbdlang[TLMI_LANG_MAXLEN];
+};
+
+/* Attribute setting details */
+struct tlmi_attr_setting {
+	struct kobject kobj;
+	int index;
+	char display_name[TLMI_SETTINGS_MAXLEN];
+	char *possible_values;
+};
+
+struct think_lmi {
+	struct wmi_device *wmi_device;
+
+	int settings_count;
+	bool can_set_bios_settings;
+	bool can_get_bios_selections;
+	bool can_set_bios_password;
+	bool can_get_password_settings;
+
+	struct tlmi_attr_setting *setting[TLMI_SETTINGS_COUNT];
+	struct device *class_dev;
+	struct kset *attribute_kset;
+	struct kset *authentication_kset;
+	struct tlmi_pwd_setting *pwd_admin;
+	struct tlmi_pwd_setting *pwd_power;
+};
+
+#endif /* !_THINK_LMI_H_ */
