ASoC: intel: sof_sdw: Support multiple groups on the same link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit f82742dd479dfec7dc6a30a84f165a258c51ce09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/f82742dd.failed

The current code checks the first device on a link and assumes
that all the other devices on the link will have the same endpoint
aggregation status and endpoint group ID.

Say for example a system looked like:

SDW0 - Amp 1 (Aggregated, Group 1), Mic 1 (Aggregated, Group 2)
SDW1 - Amp 2 (Aggregated, Group 1), Mic 2 (Aggregated, Group 2)

The current code would create the DAI link for the aggregated amps,
although it is worth noting that the only reason Mic 2 is not added is
the additional check that aborts processing the link when the device
changes. Then when processing the DAI link for the microphones, Mic
2 would not be added, as the check will only be done on the first
device, which would be Amp 2 and thus the wrong group, causing the
whole link to be skipped.

Move the endpoint check to be for each device rather than the first
device on each link.

	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230808132013.889419-10-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit f82742dd479dfec7dc6a30a84f165a258c51ce09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/boards/sof_sdw.c
diff --cc sound/soc/intel/boards/sof_sdw.c
index 5f6ef7f8be22,357946365e76..000000000000
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@@ -1284,25 -1288,9 +1284,27 @@@ static int get_slave_info(const struct 
  	}
  
  	/* gather other link ID of slaves in the same group */
- 	for (adr_next = adr_link + 1; adr_next && adr_next->num_adr;
- 		adr_next++) {
- 		const struct snd_soc_acpi_endpoint *endpoint;
+ 	for (adr_next = adr_link + 1; adr_next && adr_next->num_adr; adr_next++) {
+ 		unsigned int link_codecs = 0;
  
++<<<<<<< HEAD
 +		endpoint = adr_next->adr_d->endpoints;
 +		if (!endpoint->aggregated ||
 +		    endpoint->group_id != *group_id)
 +			continue;
 +
 +		/* make sure the link mask has a single bit set */
 +		if (!is_power_of_2(adr_next->mask))
 +			return -EINVAL;
 +
 +		if (index >= SDW_MAX_CPU_DAIS) {
 +			dev_err(dev, "cpu_dai_id array overflows\n");
 +			return -EINVAL;
 +		}
 +
 +		cpu_dai_id[index++] = ffs(adr_next->mask) - 1;
++=======
++>>>>>>> f82742dd479d (ASoC: intel: sof_sdw: Support multiple groups on the same link)
  		for (i = 0; i < adr_next->num_adr; i++) {
  			if (adr_next->adr_d[i].endpoints->aggregated &&
  			    adr_next->adr_d[i].endpoints->group_id == *group_id)
@@@ -1372,24 -1365,56 +1385,76 @@@ static int create_sdw_dailink(struct sn
  		return -ENOMEM;
  
  	/* generate codec name on different links in the same group */
++<<<<<<< HEAD
 +	for (link_next = link; link_next && link_next->num_adr &&
 +	     i < cpu_dai_num; link_next++) {
 +		const struct snd_soc_acpi_endpoint *endpoints;
 +
 +		endpoints = link_next->adr_d->endpoints;
 +		if (group_id && (!endpoints->aggregated ||
 +				 endpoints->group_id != group_id))
 +			continue;
 +
++=======
+ 	j = adr_index;
+ 	for (adr_link_next = adr_link; adr_link_next && adr_link_next->num_adr &&
+ 	     i < cpu_dai_num; adr_link_next++) {
+ 		int _codec_index = -1;
+ 
++>>>>>>> f82742dd479d (ASoC: intel: sof_sdw: Support multiple groups on the same link)
  		/* skip the link excluded by this processed group */
 -		if (cpu_dai_id[i] != ffs(adr_link_next->mask) - 1)
 +		if (cpu_dai_id[i] != ffs(link_next->mask) - 1)
  			continue;
  
++<<<<<<< HEAD
 +		ret = create_codec_dai_name(dev, link_next, codecs, codec_idx,
 +					    codec_conf, codec_count, codec_conf_index,
 +					    adr_index, dai_index);
 +		if (ret < 0)
 +			return ret;
++=======
+ 		/* j reset after loop, adr_index only applies to first link */
+ 		for (; j < adr_link_next->num_adr; j++) {
+ 			const struct snd_soc_acpi_endpoint *endpoints;
+ 			int codec_index;
+ 			u64 adr = adr_link_next->adr_d[j].adr;
+ 
+ 			codec_index = find_codec_info_part(adr);
+ 			if (codec_index < 0)
+ 				return codec_index;
+ 			if (_codec_index != -1 && codec_index != _codec_index) {
+ 				dev_dbg(dev, "Different devices on the same sdw link\n");
+ 				break;
+ 			}
+ 			_codec_index = codec_index;
+ 
+ 			endpoints = adr_link_next->adr_d[j].endpoints;
+ 
+ 			if (group_id && (!endpoints->aggregated ||
+ 					 endpoints->group_id != group_id))
+ 				continue;
+ 
+ 			/* sanity check */
+ 			if (*codec_conf_index >= codec_count) {
+ 				dev_err(dev, "codec_conf array overflowed\n");
+ 				return -EINVAL;
+ 			}
+ 
+ 			ret = fill_sdw_codec_dlc(dev, adr_link_next,
+ 						 &codecs[codec_dlc_index],
+ 						 codec_index, j, dai_index);
+ 			if (ret)
+ 				return ret;
+ 
+ 			codec_conf[*codec_conf_index].dlc = codecs[codec_dlc_index];
+ 			codec_conf[*codec_conf_index].name_prefix =
+ 					adr_link_next->adr_d[j].name_prefix;
+ 
+ 			codec_dlc_index++;
+ 			(*codec_conf_index)++;
+ 		}
+ 		j = 0;
++>>>>>>> f82742dd479d (ASoC: intel: sof_sdw: Support multiple groups on the same link)
  
  		/* check next link to create codec dai in the processed group */
  		i++;
* Unmerged path sound/soc/intel/boards/sof_sdw.c
