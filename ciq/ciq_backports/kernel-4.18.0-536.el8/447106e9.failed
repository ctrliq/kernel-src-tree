ALSA: hda: cs35l41: Support mute notifications for CS35L41 HDA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit 447106e92a0c86c332d40710436f38f64c322cd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/447106e9.failed

Some laptops require a hardware based mute system, where when a hotkey
is pressed, it forces the amp to be muted.

For CS35L41, when the hotkey is pressed, an acpi notification is sent
to the CS35L41 Device Node. The driver needs to handle this notification
and call a _DSM function to retrieve the mute state.

Since the amp is only muted during playback, the driver will only mute
or unmute if playback is occurring, otherwise it will save the mute
state for when playback starts.

This uses the ACPI Notification mechanism, where a handler has been
registered in the component master, which notifies each amp through
the component binding.

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230921162849.1988124-4-sbinding@opensource.cirrus.com
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 447106e92a0c86c332d40710436f38f64c322cd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/cs35l41_hda.c
diff --cc sound/pci/hda/cs35l41_hda.c
index cd9a2717cef5,18ca00c0a8cd..000000000000
--- a/sound/pci/hda/cs35l41_hda.c
+++ b/sound/pci/hda/cs35l41_hda.c
@@@ -528,15 -555,9 +556,9 @@@ static void cs35l41_hda_play_done(struc
  
  	dev_dbg(dev, "Play (Complete)\n");
  
 -	cs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 1, NULL,
 +	cs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 1,
  			      cs35l41->firmware_running);
- 	if (cs35l41->firmware_running) {
- 		regmap_multi_reg_write(reg, cs35l41_hda_unmute_dsp,
- 				       ARRAY_SIZE(cs35l41_hda_unmute_dsp));
- 	} else {
- 		regmap_multi_reg_write(reg, cs35l41_hda_unmute,
- 				       ARRAY_SIZE(cs35l41_hda_unmute));
- 	}
+ 	cs35l41_mute(dev, false);
  }
  
  static void cs35l41_hda_pause_start(struct device *dev)
@@@ -546,8 -567,8 +568,13 @@@
  
  	dev_dbg(dev, "Pause (Start)\n");
  
++<<<<<<< HEAD
 +	regmap_multi_reg_write(reg, cs35l41_hda_mute, ARRAY_SIZE(cs35l41_hda_mute));
 +	cs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 0,
++=======
+ 	cs35l41_mute(dev, true);
+ 	cs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 0, NULL,
++>>>>>>> 447106e92a0c (ALSA: hda: cs35l41: Support mute notifications for CS35L41 HDA)
  			      cs35l41->firmware_running);
  }
  
* Unmerged path sound/pci/hda/cs35l41_hda.c
diff --git a/sound/pci/hda/cs35l41_hda.h b/sound/pci/hda/cs35l41_hda.h
index b93bf762976e..ce3f2bb6ffd0 100644
--- a/sound/pci/hda/cs35l41_hda.h
+++ b/sound/pci/hda/cs35l41_hda.h
@@ -10,6 +10,7 @@
 #ifndef __CS35L41_HDA_H__
 #define __CS35L41_HDA_H__
 
+#include <linux/acpi.h>
 #include <linux/efi.h>
 #include <linux/regulator/consumer.h>
 #include <linux/gpio/consumer.h>
@@ -70,6 +71,8 @@ struct cs35l41_hda {
 	bool halo_initialized;
 	bool playback_started;
 	struct cs_dsp cs_dsp;
+	struct acpi_device *dacpi;
+	bool mute_override;
 };
 
 enum halo_state {
