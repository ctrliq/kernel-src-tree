ASoC: intel: sof_sdw: Simplify get_slave_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit 7f5cf19703ccb05ac4965d1cfc1422e38bec93aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/7f5cf197.failed

Now the first device on a link is not treated specially there is no
need to have a separate loop to handle the current link over the
future links, as the logic is identical. Combine this all into a
single processing loop.

	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230808132013.889419-12-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 7f5cf19703ccb05ac4965d1cfc1422e38bec93aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/boards/sof_sdw.c
diff --cc sound/soc/intel/boards/sof_sdw.c
index 5f6ef7f8be22,f283c0d528df..000000000000
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@@ -1250,73 -1263,45 +1250,101 @@@ static int set_codec_init_func(struct s
  static int get_slave_info(const struct snd_soc_acpi_link_adr *adr_link,
  			  struct device *dev, int *cpu_dai_id, int *cpu_dai_num,
  			  int *codec_num, unsigned int *group_id,
 -			  int adr_index)
 +			  bool *group_generated, int adr_index)
  {
- 	const struct snd_soc_acpi_adr_device *adr_d;
- 	const struct snd_soc_acpi_link_adr *adr_next;
- 	bool no_aggregation;
- 	int index = 0;
+ 	bool no_aggregation = sof_sdw_quirk & SOF_SDW_NO_AGGREGATION;
  	int i;
  
++<<<<<<< HEAD
 +	no_aggregation = sof_sdw_quirk & SOF_SDW_NO_AGGREGATION;
 +	adr_d = &adr_link->adr_d[adr_index];
 +
 +	/* make sure the link mask has a single bit set */
 +	if (!is_power_of_2(adr_link->mask))
 +		return -EINVAL;
 +
 +	cpu_dai_id[index++] = ffs(adr_link->mask) - 1;
 +	if (!adr_d->endpoints->aggregated || no_aggregation) {
++=======
+ 	if (!adr_link->adr_d[adr_index].endpoints->aggregated || no_aggregation) {
+ 		cpu_dai_id[0] = ffs(adr_link->mask) - 1;
++>>>>>>> 7f5cf19703cc (ASoC: intel: sof_sdw: Simplify get_slave_info)
  		*cpu_dai_num = 1;
  		*codec_num = 1;
  		*group_id = 0;
  		return 0;
  	}
  
- 	*group_id = adr_d->endpoints->group_id;
+ 	*codec_num = 0;
+ 	*cpu_dai_num = 0;
+ 	*group_id = adr_link->adr_d[adr_index].endpoints->group_id;
  
  	/* Count endpoints with the same group_id in the adr_link */
++<<<<<<< HEAD
 +	*codec_num = 0;
 +	for (i = 0; i < adr_link->num_adr; i++) {
 +		if (adr_link->adr_d[i].endpoints->aggregated &&
 +		    adr_link->adr_d[i].endpoints->group_id == *group_id)
 +			(*codec_num)++;
 +	}
 +
 +	/* gather other link ID of slaves in the same group */
 +	for (adr_next = adr_link + 1; adr_next && adr_next->num_adr;
 +		adr_next++) {
 +		const struct snd_soc_acpi_endpoint *endpoint;
 +
 +		endpoint = adr_next->adr_d->endpoints;
 +		if (!endpoint->aggregated ||
 +		    endpoint->group_id != *group_id)
 +			continue;
 +
 +		/* make sure the link mask has a single bit set */
 +		if (!is_power_of_2(adr_next->mask))
 +			return -EINVAL;
 +
 +		if (index >= SDW_MAX_CPU_DAIS) {
 +			dev_err(dev, "cpu_dai_id array overflows\n");
 +			return -EINVAL;
 +		}
 +
 +		cpu_dai_id[index++] = ffs(adr_next->mask) - 1;
 +		for (i = 0; i < adr_next->num_adr; i++) {
 +			if (adr_next->adr_d[i].endpoints->aggregated &&
 +			    adr_next->adr_d[i].endpoints->group_id == *group_id)
 +				(*codec_num)++;
 +		}
 +	}
 +
 +	/*
 +	 * indicate CPU DAIs for this group have been generated
 +	 * to avoid generating CPU DAIs for this group again.
 +	 */
 +	group_generated[*group_id] = true;
 +	*cpu_dai_num = index;
 +
++=======
+ 	for (; adr_link && adr_link->num_adr; adr_link++) {
+ 		unsigned int link_codecs = 0;
+ 
+ 		for (i = 0; i < adr_link->num_adr; i++) {
+ 			if (adr_link->adr_d[i].endpoints->aggregated &&
+ 			    adr_link->adr_d[i].endpoints->group_id == *group_id)
+ 				link_codecs++;
+ 		}
+ 
+ 		if (link_codecs) {
+ 			*codec_num += link_codecs;
+ 
+ 			if (*cpu_dai_num >= SDW_MAX_CPU_DAIS) {
+ 				dev_err(dev, "cpu_dai_id array overflowed\n");
+ 				return -EINVAL;
+ 			}
+ 
+ 			cpu_dai_id[(*cpu_dai_num)++] = ffs(adr_link->mask) - 1;
+ 		}
+ 	}
+ 
++>>>>>>> 7f5cf19703cc (ASoC: intel: sof_sdw: Simplify get_slave_info)
  	return 0;
  }
  
* Unmerged path sound/soc/intel/boards/sof_sdw.c
