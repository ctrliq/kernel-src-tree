x86/hyperv: Add sev-snp enlightened guest static key

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Tianyu Lan <tiala@microsoft.com>
commit d6e2d652443751e290b2edb70173ec3c22f78fbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/d6e2d652.failed

Introduce static key isolation_type_en_snp for enlightened
sev-snp guest check.

	Reviewed-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Tianyu Lan <tiala@microsoft.com>
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
Link: https://lore.kernel.org/r/20230818102919.1318039-2-ltykernel@gmail.com
(cherry picked from commit d6e2d652443751e290b2edb70173ec3c22f78fbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mshyperv.c
diff --cc arch/x86/kernel/cpu/mshyperv.c
index 1189865ffc68,5398fb2f4d39..000000000000
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@@ -385,16 -402,11 +385,24 @@@ static void __init ms_hyperv_init_platf
  		pr_info("Hyper-V: Isolation Config: Group A 0x%x, Group B 0x%x\n",
  			ms_hyperv.isolation_config_a, ms_hyperv.isolation_config_b);
  
++<<<<<<< HEAD
 +		if (hv_get_isolation_type() == HV_ISOLATION_TYPE_SNP) {
 +			static_branch_enable(&isolation_type_snp);
 +#ifdef CONFIG_SWIOTLB
 +			swiotlb_unencrypted_base = ms_hyperv.shared_gpa_boundary;
 +#endif
 +		}
 +		/* Isolation VMs are unenlightened SEV-based VMs, thus this check: */
 +		if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
 +			if (hv_get_isolation_type() != HV_ISOLATION_TYPE_NONE)
 +				cc_set_vendor(CC_VENDOR_HYPERV);
++=======
+ 
+ 		if (cc_platform_has(CC_ATTR_GUEST_SEV_SNP)) {
+ 			static_branch_enable(&isolation_type_en_snp);
+ 		} else if (hv_get_isolation_type() == HV_ISOLATION_TYPE_SNP) {
+ 			static_branch_enable(&isolation_type_snp);
++>>>>>>> d6e2d6524437 (x86/hyperv: Add sev-snp enlightened guest static key)
  		}
  	}
  
@@@ -464,6 -476,10 +472,13 @@@
  	i8253_clear_counter_on_shutdown = false;
  
  #if IS_ENABLED(CONFIG_HYPERV)
++<<<<<<< HEAD
++=======
+ 	if ((hv_get_isolation_type() == HV_ISOLATION_TYPE_VBS) ||
+ 	    ((hv_get_isolation_type() == HV_ISOLATION_TYPE_SNP) &&
+ 	    ms_hyperv.paravisor_present))
+ 		hv_vtom_init();
++>>>>>>> d6e2d6524437 (x86/hyperv: Add sev-snp enlightened guest static key)
  	/*
  	 * Setup the hook to get control post apic initialization.
  	 */
diff --git a/arch/x86/hyperv/ivm.c b/arch/x86/hyperv/ivm.c
index 5648efb6c73e..39fdd43f6587 100644
--- a/arch/x86/hyperv/ivm.c
+++ b/arch/x86/hyperv/ivm.c
@@ -387,3 +387,14 @@ bool hv_isolation_type_snp(void)
 {
 	return static_branch_unlikely(&isolation_type_snp);
 }
+
+DEFINE_STATIC_KEY_FALSE(isolation_type_en_snp);
+/*
+ * hv_isolation_type_en_snp - Check system runs in the AMD SEV-SNP based
+ * isolation enlightened VM.
+ */
+bool hv_isolation_type_en_snp(void)
+{
+	return static_branch_unlikely(&isolation_type_en_snp);
+}
+
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 74fbe7b96116..5a3acbc83185 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -14,6 +14,7 @@
 union hv_ghcb;
 
 DECLARE_STATIC_KEY_FALSE(isolation_type_snp);
+DECLARE_STATIC_KEY_FALSE(isolation_type_en_snp);
 
 typedef int (*hyperv_fill_flush_list_func)(
 		struct hv_guest_mapping_flush_list *flush,
@@ -232,6 +233,7 @@ static inline void hv_ghcb_terminate(unsigned int set, unsigned int reason) {}
 #endif
 
 extern bool hv_isolation_type_snp(void);
+extern bool hv_isolation_type_en_snp(void);
 
 static inline bool hv_is_synic_reg(unsigned int reg)
 {
* Unmerged path arch/x86/kernel/cpu/mshyperv.c
diff --git a/drivers/hv/hv_common.c b/drivers/hv/hv_common.c
index c00e1e18c2ea..689eb051409e 100644
--- a/drivers/hv/hv_common.c
+++ b/drivers/hv/hv_common.c
@@ -270,6 +270,12 @@ bool __weak hv_isolation_type_snp(void)
 }
 EXPORT_SYMBOL_GPL(hv_isolation_type_snp);
 
+bool __weak hv_isolation_type_en_snp(void)
+{
+	return false;
+}
+EXPORT_SYMBOL_GPL(hv_isolation_type_en_snp);
+
 void __weak hv_setup_vmbus_handler(void (*handler)(void))
 {
 }
diff --git a/include/asm-generic/mshyperv.h b/include/asm-generic/mshyperv.h
index 8845a2eca339..14cb1c41dded 100644
--- a/include/asm-generic/mshyperv.h
+++ b/include/asm-generic/mshyperv.h
@@ -34,15 +34,21 @@ struct ms_hyperv_info {
 	u32 nested_features;
 	u32 max_vp_index;
 	u32 max_lp_index;
-	u32 isolation_config_a;
+	union {
+		u32 isolation_config_a;
+		struct {
+			u32 paravisor_present : 1;
+			u32 reserved_a1 : 31;
+		};
+	};
 	union {
 		u32 isolation_config_b;
 		struct {
 			u32 cvm_type : 4;
-			u32 reserved1 : 1;
+			u32 reserved_b1 : 1;
 			u32 shared_gpa_boundary_active : 1;
 			u32 shared_gpa_boundary_bits : 6;
-			u32 reserved2 : 20;
+			u32 reserved_b2 : 20;
 		};
 	};
 	u64 shared_gpa_boundary;
@@ -56,6 +62,7 @@ extern void * __percpu *hyperv_pcpu_output_arg;
 extern u64 hv_do_hypercall(u64 control, void *inputaddr, void *outputaddr);
 extern u64 hv_do_fast_hypercall8(u16 control, u64 input8);
 extern bool hv_isolation_type_snp(void);
+extern bool hv_isolation_type_en_snp(void);
 
 /* Helper functions that provide a consistent pattern for checking Hyper-V hypercall status. */
 static inline int hv_result(u64 status)
