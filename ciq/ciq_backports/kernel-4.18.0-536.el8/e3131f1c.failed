x86/hyperv: Remove hv_isolation_type_en_snp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Dexuan Cui <decui@microsoft.com>
commit e3131f1c81448a87e08dffd21867312a5ce563d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/e3131f1c.failed

In ms_hyperv_init_platform(), do not distinguish between a SNP VM with
the paravisor and a SNP VM without the paravisor.

Replace hv_isolation_type_en_snp() with
!ms_hyperv.paravisor_present && hv_isolation_type_snp().

The hv_isolation_type_en_snp() in drivers/hv/hv.c and
drivers/hv/hv_common.c can be changed to hv_isolation_type_snp() since
we know !ms_hyperv.paravisor_present is true there.

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Reviewed-by: Tianyu Lan <tiala@microsoft.com>
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
Link: https://lore.kernel.org/r/20230824080712.30327-10-decui@microsoft.com
(cherry picked from commit e3131f1c81448a87e08dffd21867312a5ce563d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
#	arch/x86/hyperv/ivm.c
#	arch/x86/include/asm/mshyperv.h
#	arch/x86/kernel/cpu/mshyperv.c
#	drivers/hv/hv.c
#	drivers/hv/hv_common.c
#	include/asm-generic/mshyperv.h
diff --cc arch/x86/hyperv/hv_init.c
index 1d0a26104d0f,2b0124394e24..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -116,8 -108,21 +116,26 @@@ static int hv_cpu_init(unsigned int cpu
  		 * in hv_cpu_die(), otherwise a CPU may not be stopped in the
  		 * case of CPU offlining and the VM will hang.
  		 */
++<<<<<<< HEAD
 +		if (!*hvp)
 +			*hvp = __vmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_ZERO, PAGE_KERNEL);
++=======
+ 		if (!*hvp) {
+ 			*hvp = __vmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_ZERO);
+ 
+ 			/*
+ 			 * Hyper-V should never specify a VM that is a Confidential
+ 			 * VM and also running in the root partition. Root partition
+ 			 * is blocked to run in Confidential VM. So only decrypt assist
+ 			 * page in non-root partition here.
+ 			 */
+ 			if (*hvp && !ms_hyperv.paravisor_present && hv_isolation_type_snp()) {
+ 				WARN_ON_ONCE(set_memory_decrypted((unsigned long)(*hvp), 1));
+ 				memset(*hvp, 0, PAGE_SIZE);
+ 			}
+ 		}
+ 
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  		if (*hvp)
  			msr.pfn = vmalloc_to_pfn(*hvp);
  
@@@ -412,14 -443,24 +430,14 @@@ void __init hyperv_init(void
  	if (hv_common_init())
  		return;
  
 -	/*
 -	 * The VP assist page is useless to a TDX guest: the only use we
 -	 * would have for it is lazy EOI, which can not be used with TDX.
 -	 */
 -	if (hv_isolation_type_tdx())
 -		hv_vp_assist_page = NULL;
 -	else
 -		hv_vp_assist_page = kcalloc(num_possible_cpus(),
 -					    sizeof(*hv_vp_assist_page),
 -					    GFP_KERNEL);
 +	hv_vp_assist_page = kcalloc(num_possible_cpus(),
 +				    sizeof(*hv_vp_assist_page), GFP_KERNEL);
  	if (!hv_vp_assist_page) {
  		ms_hyperv.hints &= ~HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;
 -
 -		if (!hv_isolation_type_tdx())
 -			goto common_free;
 +		goto common_free;
  	}
  
- 	if (hv_isolation_type_snp()) {
+ 	if (ms_hyperv.paravisor_present && hv_isolation_type_snp()) {
  		/* Negotiate GHCB Version. */
  		if (!hv_ghcb_negotiate_protocol())
  			hv_ghcb_terminate(SEV_TERM_SET_GEN,
@@@ -520,15 -582,9 +538,21 @@@
  	/* Query the VMs extended capability once, so that it can be cached. */
  	hv_query_ext_cap(0);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SWIOTLB
 +	/*
 +	 * Swiotlb bounce buffer needs to be mapped in extra address
 +	 * space. Map function doesn't work in the early place and so
 +	 * call swiotlb_update_mem_attributes() here.
 +	 */
 +	if (hv_is_isolation_supported())
 +		swiotlb_update_mem_attributes();
 +#endif
++=======
+ 	/* Find the VTL */
+ 	if (!ms_hyperv.paravisor_present && hv_isolation_type_snp())
+ 		ms_hyperv.vtl = get_vtl();
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  
  	return;
  
diff --cc arch/x86/hyperv/ivm.c
index 5648efb6c73e,3d48f823582c..000000000000
--- a/arch/x86/hyperv/ivm.c
+++ b/arch/x86/hyperv/ivm.c
@@@ -387,3 -644,30 +387,33 @@@ bool hv_isolation_type_snp(void
  {
  	return static_branch_unlikely(&isolation_type_snp);
  }
++<<<<<<< HEAD
++=======
+ 
+ DEFINE_STATIC_KEY_FALSE(isolation_type_tdx);
+ /*
+  * hv_isolation_type_tdx - Check if the system runs in an Intel TDX based
+  * isolated VM.
+  */
+ bool hv_isolation_type_tdx(void)
+ {
+ 	return static_branch_unlikely(&isolation_type_tdx);
+ }
+ 
+ #ifdef CONFIG_INTEL_TDX_GUEST
+ 
+ u64 hv_tdx_hypercall(u64 control, u64 param1, u64 param2)
+ {
+ 	struct tdx_hypercall_args args = { };
+ 
+ 	args.r10 = control;
+ 	args.rdx = param1;
+ 	args.r8  = param2;
+ 
+ 	(void)__tdx_hypercall_ret(&args);
+ 
+ 	return args.r11;
+ }
+ 
+ #endif
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
diff --cc arch/x86/include/asm/mshyperv.h
index a56488c7d1a0,66ca641a164a..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -14,6 -14,19 +14,10 @@@
  union hv_ghcb;
  
  DECLARE_STATIC_KEY_FALSE(isolation_type_snp);
++<<<<<<< HEAD
++=======
+ DECLARE_STATIC_KEY_FALSE(isolation_type_tdx);
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  
  typedef int (*hyperv_fill_flush_list_func)(
  		struct hv_guest_mapping_flush_list *flush,
@@@ -45,7 -49,16 +49,20 @@@ extern u64 hv_current_partition_id
  
  extern union hv_ghcb * __percpu *hv_ghcb_pg;
  
++<<<<<<< HEAD
 +extern bool hv_isolation_type_en_snp(void);
++=======
+ bool hv_isolation_type_snp(void);
+ bool hv_isolation_type_tdx(void);
+ u64 hv_tdx_hypercall(u64 control, u64 param1, u64 param2);
+ 
+ /*
+  * DEFAULT INIT GPAT and SEGMENT LIMIT value in struct VMSA
+  * to start AP in enlightened SEV guest.
+  */
+ #define HV_AP_INIT_GPAT_DEFAULT		0x0007040600070406ULL
+ #define HV_AP_SEGMENT_LIMIT		0xffffffff
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  
  int hv_call_deposit_pages(int node, u64 partition_id, u32 num_pages);
  int hv_call_add_logical_proc(int node, u32 lp_index, u32 acpi_id);
@@@ -58,7 -75,10 +75,14 @@@ static inline u64 hv_do_hypercall(u64 c
  	u64 hv_status;
  
  #ifdef CONFIG_X86_64
++<<<<<<< HEAD
 +	if (hv_isolation_type_en_snp()) {
++=======
+ 	if (hv_isolation_type_tdx() && !hyperv_paravisor_present)
+ 		return hv_tdx_hypercall(control, input_address, output_address);
+ 
+ 	if (hv_isolation_type_snp() && !hyperv_paravisor_present) {
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  		__asm__ __volatile__("mov %4, %%r8\n"
  				     "vmmcall"
  				     : "=a" (hv_status), ASM_CALL_CONSTRAINT,
@@@ -111,7 -131,10 +135,14 @@@ static inline u64 _hv_do_fast_hypercall
  	u64 hv_status;
  
  #ifdef CONFIG_X86_64
++<<<<<<< HEAD
 +	if (hv_isolation_type_en_snp()) {
++=======
+ 	if (hv_isolation_type_tdx() && !hyperv_paravisor_present)
+ 		return hv_tdx_hypercall(control, input1, 0);
+ 
+ 	if (hv_isolation_type_snp() && !hyperv_paravisor_present) {
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  		__asm__ __volatile__(
  				"vmmcall"
  				: "=a" (hv_status), ASM_CALL_CONSTRAINT,
@@@ -162,7 -185,10 +193,14 @@@ static inline u64 _hv_do_fast_hypercall
  	u64 hv_status;
  
  #ifdef CONFIG_X86_64
++<<<<<<< HEAD
 +	if (hv_isolation_type_en_snp()) {
++=======
+ 	if (hv_isolation_type_tdx() && !hyperv_paravisor_present)
+ 		return hv_tdx_hypercall(control, input1, input2);
+ 
+ 	if (hv_isolation_type_snp() && !hyperv_paravisor_present) {
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  		__asm__ __volatile__("mov %4, %%r8\n"
  				     "vmmcall"
  				     : "=a" (hv_status), ASM_CALL_CONSTRAINT,
@@@ -242,21 -268,30 +280,33 @@@ static inline void hv_apic_init(void) {
  #endif
  
  struct irq_domain *hv_create_pci_msi_domain(void);
 -
 -int hv_map_ioapic_interrupt(int ioapic_id, bool level, int vcpu, int vector,
 -		struct hv_interrupt_entry *entry);
 -int hv_unmap_ioapic_interrupt(int ioapic_id, struct hv_interrupt_entry *entry);
 +int hv_set_mem_host_visibility(unsigned long addr, int numpages, bool visible);
  
  #ifdef CONFIG_AMD_MEM_ENCRYPT
 +void hv_ghcb_msr_write(u64 msr, u64 value);
 +void hv_ghcb_msr_read(u64 msr, u64 *value);
  bool hv_ghcb_negotiate_protocol(void);
 -void __noreturn hv_ghcb_terminate(unsigned int set, unsigned int reason);
 -int hv_snp_boot_ap(int cpu, unsigned long start_ip);
 +void hv_ghcb_terminate(unsigned int set, unsigned int reason);
  #else
 +static inline void hv_ghcb_msr_write(u64 msr, u64 value) {}
 +static inline void hv_ghcb_msr_read(u64 msr, u64 *value) {}
  static inline bool hv_ghcb_negotiate_protocol(void) { return false; }
  static inline void hv_ghcb_terminate(unsigned int set, unsigned int reason) {}
 -static inline int hv_snp_boot_ap(int cpu, unsigned long start_ip) { return 0; }
  #endif
  
++<<<<<<< HEAD
 +extern bool hv_isolation_type_snp(void);
++=======
+ #if defined(CONFIG_AMD_MEM_ENCRYPT) || defined(CONFIG_INTEL_TDX_GUEST)
+ void hv_vtom_init(void);
+ void hv_ivm_msr_write(u64 msr, u64 value);
+ void hv_ivm_msr_read(u64 msr, u64 *value);
+ #else
+ static inline void hv_vtom_init(void) {}
+ static inline void hv_ivm_msr_write(u64 msr, u64 value) {}
+ static inline void hv_ivm_msr_read(u64 msr, u64 *value) {}
+ #endif
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  
  static inline bool hv_is_synic_reg(unsigned int reg)
  {
diff --cc arch/x86/kernel/cpu/mshyperv.c
index 1189865ffc68,b63590ffc777..000000000000
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@@ -300,8 -290,63 +300,60 @@@ static void __init hv_smp_prepare_boot_
  	hv_init_spinlocks();
  #endif
  }
 -
 -static void __init hv_smp_prepare_cpus(unsigned int max_cpus)
 -{
 -#ifdef CONFIG_X86_64
 -	int i;
 -	int ret;
  #endif
  
++<<<<<<< HEAD
++=======
+ 	native_smp_prepare_cpus(max_cpus);
+ 
+ 	/*
+ 	 *  Override wakeup_secondary_cpu_64 callback for SEV-SNP
+ 	 *  enlightened guest.
+ 	 */
+ 	if (!ms_hyperv.paravisor_present && hv_isolation_type_snp()) {
+ 		apic->wakeup_secondary_cpu_64 = hv_snp_boot_ap;
+ 		return;
+ 	}
+ 
+ #ifdef CONFIG_X86_64
+ 	for_each_present_cpu(i) {
+ 		if (i == 0)
+ 			continue;
+ 		ret = hv_call_add_logical_proc(numa_cpu_node(i), i, cpu_physical_id(i));
+ 		BUG_ON(ret);
+ 	}
+ 
+ 	for_each_present_cpu(i) {
+ 		if (i == 0)
+ 			continue;
+ 		ret = hv_call_create_vp(numa_cpu_node(i), hv_current_partition_id, i, i);
+ 		BUG_ON(ret);
+ 	}
+ #endif
+ }
+ #endif
+ 
+ /*
+  * When a fully enlightened TDX VM runs on Hyper-V, the firmware sets the
+  * HW_REDUCED flag: refer to acpi_tb_create_local_fadt(). Consequently ttyS0
+  * interrupts can't work because request_irq() -> ... -> irq_to_desc() returns
+  * NULL for ttyS0. This happens because mp_config_acpi_legacy_irqs() sees a
+  * nr_legacy_irqs() of 0, so it doesn't initialize the array 'mp_irqs[]', and
+  * later setup_IO_APIC_irqs() -> find_irq_entry() fails to find the legacy irqs
+  * from the array and hence doesn't create the necessary irq description info.
+  *
+  * Clone arch/x86/kernel/acpi/boot.c: acpi_generic_reduced_hw_init() here,
+  * except don't change 'legacy_pic', which keeps its default value
+  * 'default_legacy_pic'. This way, mp_config_acpi_legacy_irqs() sees a non-zero
+  * nr_legacy_irqs() and eventually serial console interrupts works properly.
+  */
+ static void __init reduced_hw_init(void)
+ {
+ 	x86_init.timers.timer_init	= x86_init_noop;
+ 	x86_init.irqs.pre_vector_init	= x86_init_noop;
+ }
+ 
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  static void __init ms_hyperv_init_platform(void)
  {
  	int hv_max_functions_eax;
@@@ -385,16 -438,27 +437,37 @@@
  		pr_info("Hyper-V: Isolation Config: Group A 0x%x, Group B 0x%x\n",
  			ms_hyperv.isolation_config_a, ms_hyperv.isolation_config_b);
  
 -
  		if (hv_get_isolation_type() == HV_ISOLATION_TYPE_SNP) {
  			static_branch_enable(&isolation_type_snp);
++<<<<<<< HEAD
 +#ifdef CONFIG_SWIOTLB
 +			swiotlb_unencrypted_base = ms_hyperv.shared_gpa_boundary;
 +#endif
 +		}
 +		/* Isolation VMs are unenlightened SEV-based VMs, thus this check: */
 +		if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
 +			if (hv_get_isolation_type() != HV_ISOLATION_TYPE_NONE)
 +				cc_set_vendor(CC_VENDOR_HYPERV);
++=======
+ 		} else if (hv_get_isolation_type() == HV_ISOLATION_TYPE_TDX) {
+ 			static_branch_enable(&isolation_type_tdx);
+ 
+ 			/* A TDX VM must use x2APIC and doesn't use lazy EOI. */
+ 			ms_hyperv.hints &= ~HV_X64_APIC_ACCESS_RECOMMENDED;
+ 
+ 			if (!ms_hyperv.paravisor_present) {
+ 				/* To be supported: more work is required.  */
+ 				ms_hyperv.features &= ~HV_MSR_REFERENCE_TSC_AVAILABLE;
+ 
+ 				/* HV_REGISTER_CRASH_CTL is unsupported. */
+ 				ms_hyperv.misc_features &= ~HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;
+ 
+ 				/* Don't trust Hyper-V's TLB-flushing hypercalls. */
+ 				ms_hyperv.hints &= ~HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;
+ 
+ 				x86_init.acpi.reduced_hw_early_init = reduced_hw_init;
+ 			}
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  		}
  	}
  
@@@ -484,6 -553,9 +557,12 @@@
  
  # ifdef CONFIG_SMP
  	smp_ops.smp_prepare_boot_cpu = hv_smp_prepare_boot_cpu;
++<<<<<<< HEAD
++=======
+ 	if (hv_root_partition ||
+ 	    (!ms_hyperv.paravisor_present && hv_isolation_type_snp()))
+ 		smp_ops.smp_prepare_cpus = hv_smp_prepare_cpus;
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  # endif
  
  	/*
diff --cc drivers/hv/hv.c
index 54db91ae3c0d,51e5018ac9b2..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -172,6 -159,38 +172,38 @@@ int hv_synic_alloc(void
  				goto err;
  			}
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (!ms_hyperv.paravisor_present &&
+ 		    (hv_isolation_type_snp() || hv_isolation_type_tdx())) {
+ 			ret = set_memory_decrypted((unsigned long)
+ 				hv_cpu->synic_message_page, 1);
+ 			if (ret) {
+ 				pr_err("Failed to decrypt SYNIC msg page: %d\n", ret);
+ 				hv_cpu->synic_message_page = NULL;
+ 
+ 				/*
+ 				 * Free the event page here so that hv_synic_free()
+ 				 * won't later try to re-encrypt it.
+ 				 */
+ 				free_page((unsigned long)hv_cpu->synic_event_page);
+ 				hv_cpu->synic_event_page = NULL;
+ 				goto err;
+ 			}
+ 
+ 			ret = set_memory_decrypted((unsigned long)
+ 				hv_cpu->synic_event_page, 1);
+ 			if (ret) {
+ 				pr_err("Failed to decrypt SYNIC event page: %d\n", ret);
+ 				hv_cpu->synic_event_page = NULL;
+ 				goto err;
+ 			}
+ 
+ 			memset(hv_cpu->synic_message_page, 0, PAGE_SIZE);
+ 			memset(hv_cpu->synic_event_page, 0, PAGE_SIZE);
+ 		}
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  	}
  
  	return 0;
@@@ -192,6 -212,40 +224,43 @@@ void hv_synic_free(void
  		struct hv_per_cpu_context *hv_cpu
  			= per_cpu_ptr(hv_context.cpu_context, cpu);
  
++<<<<<<< HEAD
++=======
+ 		/* It's better to leak the page if the encryption fails. */
+ 		if (ms_hyperv.paravisor_present && hv_isolation_type_tdx()) {
+ 			if (hv_cpu->post_msg_page) {
+ 				ret = set_memory_encrypted((unsigned long)
+ 					hv_cpu->post_msg_page, 1);
+ 				if (ret) {
+ 					pr_err("Failed to encrypt post msg page: %d\n", ret);
+ 					hv_cpu->post_msg_page = NULL;
+ 				}
+ 			}
+ 		}
+ 
+ 		if (!ms_hyperv.paravisor_present &&
+ 		    (hv_isolation_type_snp() || hv_isolation_type_tdx())) {
+ 			if (hv_cpu->synic_message_page) {
+ 				ret = set_memory_encrypted((unsigned long)
+ 					hv_cpu->synic_message_page, 1);
+ 				if (ret) {
+ 					pr_err("Failed to encrypt SYNIC msg page: %d\n", ret);
+ 					hv_cpu->synic_message_page = NULL;
+ 				}
+ 			}
+ 
+ 			if (hv_cpu->synic_event_page) {
+ 				ret = set_memory_encrypted((unsigned long)
+ 					hv_cpu->synic_event_page, 1);
+ 				if (ret) {
+ 					pr_err("Failed to encrypt SYNIC event page: %d\n", ret);
+ 					hv_cpu->synic_event_page = NULL;
+ 				}
+ 			}
+ 		}
+ 
+ 		free_page((unsigned long)hv_cpu->post_msg_page);
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  		free_page((unsigned long)hv_cpu->synic_event_page);
  		free_page((unsigned long)hv_cpu->synic_message_page);
  	}
diff --cc drivers/hv/hv_common.c
index c00e1e18c2ea,81aa8be3e0df..000000000000
--- a/drivers/hv/hv_common.c
+++ b/drivers/hv/hv_common.c
@@@ -132,13 -367,47 +132,56 @@@ int hv_common_cpu_init(unsigned int cpu
  	flags = irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL;
  
  	inputarg = (void **)this_cpu_ptr(hyperv_pcpu_input_arg);
 +	*inputarg = kmalloc(pgcount * HV_HYP_PAGE_SIZE, flags);
 +	if (!(*inputarg))
 +		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if (hv_root_partition) {
 +		outputarg = (void **)this_cpu_ptr(hyperv_pcpu_output_arg);
 +		*outputarg = (char *)(*inputarg) + HV_HYP_PAGE_SIZE;
++=======
+ 	/*
+ 	 * hyperv_pcpu_input_arg and hyperv_pcpu_output_arg memory is already
+ 	 * allocated if this CPU was previously online and then taken offline
+ 	 */
+ 	if (!*inputarg) {
+ 		mem = kmalloc(pgcount * HV_HYP_PAGE_SIZE, flags);
+ 		if (!mem)
+ 			return -ENOMEM;
+ 
+ 		if (hv_root_partition) {
+ 			outputarg = (void **)this_cpu_ptr(hyperv_pcpu_output_arg);
+ 			*outputarg = (char *)mem + HV_HYP_PAGE_SIZE;
+ 		}
+ 
+ 		if (!ms_hyperv.paravisor_present &&
+ 		    (hv_isolation_type_snp() || hv_isolation_type_tdx())) {
+ 			ret = set_memory_decrypted((unsigned long)mem, pgcount);
+ 			if (ret) {
+ 				/* It may be unsafe to free 'mem' */
+ 				return ret;
+ 			}
+ 
+ 			memset(mem, 0x00, pgcount * HV_HYP_PAGE_SIZE);
+ 		}
+ 
+ 		/*
+ 		 * In a fully enlightened TDX/SNP VM with more than 64 VPs, if
+ 		 * hyperv_pcpu_input_arg is not NULL, set_memory_decrypted() ->
+ 		 * ... -> cpa_flush()-> ... -> __send_ipi_mask_ex() tries to
+ 		 * use hyperv_pcpu_input_arg as the hypercall input page, which
+ 		 * must be a decrypted page in such a VM, but the page is still
+ 		 * encrypted before set_memory_decrypted() returns. Fix this by
+ 		 * setting *inputarg after the above set_memory_decrypted(): if
+ 		 * hyperv_pcpu_input_arg is NULL, __send_ipi_mask_ex() returns
+ 		 * HV_STATUS_INVALID_PARAMETER immediately, and the function
+ 		 * hv_send_ipi_mask() falls back to orig_apic.send_IPI_mask(),
+ 		 * which may be slightly slower than the hypercall, but still
+ 		 * works correctly in such a VM.
+ 		 */
+ 		*inputarg = mem;
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  	}
  
  	msr_vp_index = hv_get_register(HV_REGISTER_VP_INDEX);
@@@ -270,6 -532,12 +313,15 @@@ bool __weak hv_isolation_type_snp(void
  }
  EXPORT_SYMBOL_GPL(hv_isolation_type_snp);
  
++<<<<<<< HEAD
++=======
+ bool __weak hv_isolation_type_tdx(void)
+ {
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(hv_isolation_type_tdx);
+ 
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  void __weak hv_setup_vmbus_handler(void (*handler)(void))
  {
  }
diff --cc include/asm-generic/mshyperv.h
index 8845a2eca339,e7ecf03f675e..000000000000
--- a/include/asm-generic/mshyperv.h
+++ b/include/asm-generic/mshyperv.h
@@@ -55,7 -64,8 +55,12 @@@ extern void * __percpu *hyperv_pcpu_out
  
  extern u64 hv_do_hypercall(u64 control, void *inputaddr, void *outputaddr);
  extern u64 hv_do_fast_hypercall8(u16 control, u64 input8);
++<<<<<<< HEAD
 +extern bool hv_isolation_type_snp(void);
++=======
+ bool hv_isolation_type_snp(void);
+ bool hv_isolation_type_tdx(void);
++>>>>>>> e3131f1c8144 (x86/hyperv: Remove hv_isolation_type_en_snp)
  
  /* Helper functions that provide a consistent pattern for checking Hyper-V hypercall status. */
  static inline int hv_result(u64 status)
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/hyperv/ivm.c
* Unmerged path arch/x86/include/asm/mshyperv.h
* Unmerged path arch/x86/kernel/cpu/mshyperv.c
* Unmerged path drivers/hv/hv.c
* Unmerged path drivers/hv/hv_common.c
* Unmerged path include/asm-generic/mshyperv.h
