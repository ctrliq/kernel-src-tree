ASoC: intel: sof_sdw: Move range check of codec_conf into inner loop

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit 59736ca62e1eeb4466ace99e167cbe7a0f9bc0fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/59736ca6.failed

There are two problems with the current range check on the codec_conf
array.

Firstly, adr_link_next->num_adr refers to the number of devices
on the current SoundWire link, but adr_index refers to the first
SoundWire link involved in the DAI link. This means that subtracting
these two numbers is only meaningful on the first SoundWire link in the
DAI and broken on later links.

Secondly, the intention of the range check is to add the number
of remaining devices on the currently link to the current index
and ensure enough space remains. However, this assumes that all
remaining devices on the SoundWire link will be added to the current
DAI link. Ideally this would not be the case, and devices could be
grouped as the user desired.

Moving the range check into the inner loop both simplifies the code (no
need to add and subtract offsets) and allows future refactoring such
that devices on a single SoundWire link don't have to all be grouped onto
a single DAI link. The check will be processed slightly more often since
it is processed for each device rather each link but this is probe time
and the numbers involved are very small here (4 links, likely no more
than 2-4 devices per link).

	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230808132013.889419-8-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 59736ca62e1eeb4466ace99e167cbe7a0f9bc0fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/boards/sof_sdw.c
diff --cc sound/soc/intel/boards/sof_sdw.c
index 5f6ef7f8be22,0401516f35de..000000000000
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@@ -1382,14 -1377,41 +1382,49 @@@ static int create_sdw_dailink(struct sn
  			continue;
  
  		/* skip the link excluded by this processed group */
 -		if (cpu_dai_id[i] != ffs(adr_link_next->mask) - 1)
 +		if (cpu_dai_id[i] != ffs(link_next->mask) - 1)
  			continue;
  
++<<<<<<< HEAD
 +		ret = create_codec_dai_name(dev, link_next, codecs, codec_idx,
 +					    codec_conf, codec_count, codec_conf_index,
 +					    adr_index, dai_index);
 +		if (ret < 0)
 +			return ret;
++=======
+ 		for (j = adr_index; j < adr_link_next->num_adr; j++) {
+ 			int codec_index;
+ 			u64 adr = adr_link_next->adr_d[j].adr;
+ 
+ 			codec_index = find_codec_info_part(adr);
+ 			if (codec_index < 0)
+ 				return codec_index;
+ 			if (_codec_index != -1 && codec_index != _codec_index) {
+ 				dev_dbg(dev, "Different devices on the same sdw link\n");
+ 				break;
+ 			}
+ 			_codec_index = codec_index;
+ 
+ 			/* sanity check */
+ 			if (*codec_conf_index >= codec_count) {
+ 				dev_err(dev, "codec_conf array overflowed\n");
+ 				return -EINVAL;
+ 			}
+ 
+ 			ret = fill_sdw_codec_dlc(dev, adr_link_next,
+ 						 &codecs[codec_dlc_index],
+ 						 codec_index, j, dai_index);
+ 			if (ret)
+ 				return ret;
+ 
+ 			codec_conf[*codec_conf_index].dlc = codecs[codec_dlc_index];
+ 			codec_conf[*codec_conf_index].name_prefix =
+ 					adr_link_next->adr_d[j].name_prefix;
+ 
+ 			codec_dlc_index++;
+ 			(*codec_conf_index)++;
+ 		}
++>>>>>>> 59736ca62e1e (ASoC: intel: sof_sdw: Move range check of codec_conf into inner loop)
  
  		/* check next link to create codec dai in the processed group */
  		i++;
* Unmerged path sound/soc/intel/boards/sof_sdw.c
