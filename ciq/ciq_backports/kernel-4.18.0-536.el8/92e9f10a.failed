ASoC: intel: sof_sdw: Add helper to create a single codec DLC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit 92e9f10a093529f85b7557b0627531728d89afa2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/92e9f10a.failed

Add a helper function to create a single codec DAI link component
structure. This sets things up for more refactoring of the creating of
the DAI links.

	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230808132013.889419-5-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 92e9f10a093529f85b7557b0627531728d89afa2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/boards/sof_sdw.c
diff --cc sound/soc/intel/boards/sof_sdw.c
index 5f6ef7f8be22,ba4775e77807..000000000000
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@@ -1114,8 -1160,45 +1114,45 @@@ static bool is_unique_device(const stru
  	return true;
  }
  
+ static int fill_sdw_codec_dlc(struct device *dev,
+ 			      const struct snd_soc_acpi_link_adr *adr_link,
+ 			      struct snd_soc_dai_link_component *codec,
+ 			      int codec_index, int adr_index, int dai_index)
+ {
+ 	unsigned int sdw_version, unique_id, mfg_id, link_id, part_id, class_id;
+ 	u64 adr = adr_link->adr_d[adr_index].adr;
+ 
+ 	sdw_version = SDW_VERSION(adr);
+ 	link_id = SDW_DISCO_LINK_ID(adr);
+ 	unique_id = SDW_UNIQUE_ID(adr);
+ 	mfg_id = SDW_MFG_ID(adr);
+ 	part_id = SDW_PART_ID(adr);
+ 	class_id = SDW_CLASS_ID(adr);
+ 
+ 	if (codec_info_list[codec_index].codec_name)
+ 		codec->name = devm_kstrdup(dev,
+ 					   codec_info_list[codec_index].codec_name,
+ 					   GFP_KERNEL);
+ 	else if (is_unique_device(adr_link, sdw_version, mfg_id, part_id,
+ 				  class_id, adr_index))
+ 		codec->name = devm_kasprintf(dev, GFP_KERNEL,
+ 					     "sdw:%01x:%04x:%04x:%02x", link_id,
+ 					     mfg_id, part_id, class_id);
+ 	else
+ 		codec->name = devm_kasprintf(dev, GFP_KERNEL,
+ 					     "sdw:%01x:%04x:%04x:%02x:%01x", link_id,
+ 					     mfg_id, part_id, class_id, unique_id);
+ 
+ 	if (!codec->name)
+ 		return -ENOMEM;
+ 
+ 	codec->dai_name = codec_info_list[codec_index].dais[dai_index].dai_name;
+ 
+ 	return 0;
+ }
+ 
  static int create_codec_dai_name(struct device *dev,
 -				 const struct snd_soc_acpi_link_adr *adr_link,
 +				 const struct snd_soc_acpi_link_adr *link,
  				 struct snd_soc_dai_link_component *codec,
  				 int offset,
  				 struct snd_soc_codec_conf *codec_conf,
@@@ -1125,22 -1208,17 +1162,28 @@@
  				 int dai_index)
  {
  	int _codec_index = -1;
- 	int i;
+ 	int i, ret;
  
  	/* sanity check */
 -	if (*codec_conf_index + adr_link->num_adr - adr_index > codec_count) {
 +	if (*codec_conf_index + link->num_adr - adr_index > codec_count) {
  		dev_err(dev, "codec_conf: out-of-bounds access requested\n");
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	for (i = adr_index; i < link->num_adr; i++) {
 +		unsigned int sdw_version, unique_id, mfg_id;
 +		unsigned int link_id, part_id, class_id;
 +		int codec_index, comp_index;
 +		char *codec_str;
 +		u64 adr;
 +
 +		adr = link->adr_d[i].adr;
++=======
+ 	for (i = adr_index; i < adr_link->num_adr; i++) {
+ 		int codec_index, comp_index;
+ 		u64 adr = adr_link->adr_d[i].adr;
++>>>>>>> 92e9f10a0935 (ASoC: intel: sof_sdw: Add helper to create a single codec DLC)
  
  		codec_index = find_codec_info_part(adr);
  		if (codec_index < 0)
@@@ -1151,37 -1229,15 +1194,32 @@@
  		}
  		_codec_index = codec_index;
  
- 		sdw_version = SDW_VERSION(adr);
- 		link_id = SDW_DISCO_LINK_ID(adr);
- 		unique_id = SDW_UNIQUE_ID(adr);
- 		mfg_id = SDW_MFG_ID(adr);
- 		part_id = SDW_PART_ID(adr);
- 		class_id = SDW_CLASS_ID(adr);
- 
  		comp_index = i - adr_index + offset;
++<<<<<<< HEAD
 +		if (is_unique_device(link, sdw_version, mfg_id, part_id,
 +				     class_id, i)) {
 +			codec_str = "sdw:%01x:%04x:%04x:%02x";
 +			codec[comp_index].name =
 +				devm_kasprintf(dev, GFP_KERNEL, codec_str,
 +					       link_id, mfg_id, part_id,
 +					       class_id);
 +		} else {
 +			codec_str = "sdw:%01x:%04x:%04x:%02x:%01x";
 +			codec[comp_index].name =
 +				devm_kasprintf(dev, GFP_KERNEL, codec_str,
 +					       link_id, mfg_id, part_id,
 +					       class_id, unique_id);
 +		}
++=======
++>>>>>>> 92e9f10a0935 (ASoC: intel: sof_sdw: Add helper to create a single codec DLC)
  
- 		if (!codec[comp_index].name)
- 			return -ENOMEM;
- 
- 		codec[comp_index].dai_name =
- 			codec_info_list[codec_index].dais[dai_index].dai_name;
+ 		ret = fill_sdw_codec_dlc(dev, adr_link, &codec[comp_index],
+ 					 codec_index, i, dai_index);
+ 		if (ret)
+ 			return ret;
  
  		codec_conf[*codec_conf_index].dlc = codec[comp_index];
 -		codec_conf[*codec_conf_index].name_prefix = adr_link->adr_d[i].name_prefix;
 +		codec_conf[*codec_conf_index].name_prefix = link->adr_d[i].name_prefix;
  
  		++*codec_conf_index;
  	}
* Unmerged path sound/soc/intel/boards/sof_sdw.c
