ASoC: intel: sof_sdw: Pull device loop up into create_sdw_dailink

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit c3d7e29ad82ee689b1adf5ea7806b9d06eb098c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/c3d7e29a.failed

The loops which fill the codec DAI link component structures are split
across create_sdw_dailink and create_codec_dai_name. This causes the
code to be rather confusing, needing to return out the function to allow
the upper loop to iterate. Remove the create_codec_dai_name helper and
pull its code up into create_sdw_dailink, this makes it more obvious
what is happening in the code. This patch makes no functional change
just hoists the code up a level.

	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230808132013.889419-6-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit c3d7e29ad82ee689b1adf5ea7806b9d06eb098c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/boards/sof_sdw.c
diff --cc sound/soc/intel/boards/sof_sdw.c
index 5f6ef7f8be22,5c154628236c..000000000000
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@@ -1114,77 -1160,39 +1114,113 @@@ static bool is_unique_device(const stru
  	return true;
  }
  
++<<<<<<< HEAD
 +static int create_codec_dai_name(struct device *dev,
 +				 const struct snd_soc_acpi_link_adr *link,
 +				 struct snd_soc_dai_link_component *codec,
 +				 int offset,
 +				 struct snd_soc_codec_conf *codec_conf,
 +				 int codec_count,
 +				 int *codec_conf_index,
 +				 int adr_index,
 +				 int dai_index)
 +{
 +	int _codec_index = -1;
 +	int i;
 +
 +	/* sanity check */
 +	if (*codec_conf_index + link->num_adr - adr_index > codec_count) {
 +		dev_err(dev, "codec_conf: out-of-bounds access requested\n");
 +		return -EINVAL;
 +	}
 +
 +	for (i = adr_index; i < link->num_adr; i++) {
 +		unsigned int sdw_version, unique_id, mfg_id;
 +		unsigned int link_id, part_id, class_id;
 +		int codec_index, comp_index;
 +		char *codec_str;
 +		u64 adr;
 +
 +		adr = link->adr_d[i].adr;
 +
 +		codec_index = find_codec_info_part(adr);
 +		if (codec_index < 0)
 +			return codec_index;
 +		if (_codec_index != -1 && codec_index != _codec_index) {
 +			dev_dbg(dev, "Different devices on the same sdw link\n");
 +			break;
 +		}
 +		_codec_index = codec_index;
 +
 +		sdw_version = SDW_VERSION(adr);
 +		link_id = SDW_DISCO_LINK_ID(adr);
 +		unique_id = SDW_UNIQUE_ID(adr);
 +		mfg_id = SDW_MFG_ID(adr);
 +		part_id = SDW_PART_ID(adr);
 +		class_id = SDW_CLASS_ID(adr);
 +
 +		comp_index = i - adr_index + offset;
 +		if (is_unique_device(link, sdw_version, mfg_id, part_id,
 +				     class_id, i)) {
 +			codec_str = "sdw:%01x:%04x:%04x:%02x";
 +			codec[comp_index].name =
 +				devm_kasprintf(dev, GFP_KERNEL, codec_str,
 +					       link_id, mfg_id, part_id,
 +					       class_id);
 +		} else {
 +			codec_str = "sdw:%01x:%04x:%04x:%02x:%01x";
 +			codec[comp_index].name =
 +				devm_kasprintf(dev, GFP_KERNEL, codec_str,
 +					       link_id, mfg_id, part_id,
 +					       class_id, unique_id);
 +		}
 +
 +		if (!codec[comp_index].name)
 +			return -ENOMEM;
 +
 +		codec[comp_index].dai_name =
 +			codec_info_list[codec_index].dais[dai_index].dai_name;
 +
 +		codec_conf[*codec_conf_index].dlc = codec[comp_index];
 +		codec_conf[*codec_conf_index].name_prefix = link->adr_d[i].name_prefix;
 +
 +		++*codec_conf_index;
 +	}
++=======
+ static int fill_sdw_codec_dlc(struct device *dev,
+ 			      const struct snd_soc_acpi_link_adr *adr_link,
+ 			      struct snd_soc_dai_link_component *codec,
+ 			      int codec_index, int adr_index, int dai_index)
+ {
+ 	unsigned int sdw_version, unique_id, mfg_id, link_id, part_id, class_id;
+ 	u64 adr = adr_link->adr_d[adr_index].adr;
+ 
+ 	sdw_version = SDW_VERSION(adr);
+ 	link_id = SDW_DISCO_LINK_ID(adr);
+ 	unique_id = SDW_UNIQUE_ID(adr);
+ 	mfg_id = SDW_MFG_ID(adr);
+ 	part_id = SDW_PART_ID(adr);
+ 	class_id = SDW_CLASS_ID(adr);
+ 
+ 	if (codec_info_list[codec_index].codec_name)
+ 		codec->name = devm_kstrdup(dev,
+ 					   codec_info_list[codec_index].codec_name,
+ 					   GFP_KERNEL);
+ 	else if (is_unique_device(adr_link, sdw_version, mfg_id, part_id,
+ 				  class_id, adr_index))
+ 		codec->name = devm_kasprintf(dev, GFP_KERNEL,
+ 					     "sdw:%01x:%04x:%04x:%02x", link_id,
+ 					     mfg_id, part_id, class_id);
+ 	else
+ 		codec->name = devm_kasprintf(dev, GFP_KERNEL,
+ 					     "sdw:%01x:%04x:%04x:%02x:%01x", link_id,
+ 					     mfg_id, part_id, class_id, unique_id);
+ 
+ 	if (!codec->name)
+ 		return -ENOMEM;
+ 
+ 	codec->dai_name = codec_info_list[codec_index].dais[dai_index].dai_name;
++>>>>>>> c3d7e29ad82e (ASoC: intel: sof_sdw: Pull device loop up into create_sdw_dailink)
  
  	return 0;
  }
@@@ -1359,11 -1353,11 +1395,11 @@@ static int create_sdw_dailink(struct sn
  	int codec_num;
  	int stream;
  	int i = 0;
+ 	int j, k;
  	int ret;
- 	int k;
  
 -	ret = get_slave_info(adr_link, dev, cpu_dai_id, &cpu_dai_num, &codec_num,
 -			     &group_id, adr_index);
 +	ret = get_slave_info(link, dev, cpu_dai_id, &cpu_dai_num, &codec_num,
 +			     &group_id, group_generated, adr_index);
  	if (ret)
  		return ret;
  
@@@ -1372,24 -1366,53 +1408,61 @@@
  		return -ENOMEM;
  
  	/* generate codec name on different links in the same group */
 -	for (adr_link_next = adr_link; adr_link_next && adr_link_next->num_adr &&
 -	     i < cpu_dai_num; adr_link_next++) {
 +	for (link_next = link; link_next && link_next->num_adr &&
 +	     i < cpu_dai_num; link_next++) {
  		const struct snd_soc_acpi_endpoint *endpoints;
+ 		int _codec_index = -1;
  
 -		endpoints = adr_link_next->adr_d->endpoints;
 +		endpoints = link_next->adr_d->endpoints;
  		if (group_id && (!endpoints->aggregated ||
  				 endpoints->group_id != group_id))
  			continue;
  
  		/* skip the link excluded by this processed group */
 -		if (cpu_dai_id[i] != ffs(adr_link_next->mask) - 1)
 +		if (cpu_dai_id[i] != ffs(link_next->mask) - 1)
  			continue;
  
++<<<<<<< HEAD
 +		ret = create_codec_dai_name(dev, link_next, codecs, codec_idx,
 +					    codec_conf, codec_count, codec_conf_index,
 +					    adr_index, dai_index);
 +		if (ret < 0)
 +			return ret;
++=======
+ 		/* sanity check */
+ 		if (*codec_conf_index + adr_link_next->num_adr - adr_index > codec_count) {
+ 			dev_err(dev, "codec_conf: out-of-bounds access requested\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		for (j = adr_index; j < adr_link_next->num_adr; j++) {
+ 			int codec_index, comp_index;
+ 			u64 adr = adr_link_next->adr_d[j].adr;
+ 
+ 			codec_index = find_codec_info_part(adr);
+ 			if (codec_index < 0)
+ 				return codec_index;
+ 			if (_codec_index != -1 && codec_index != _codec_index) {
+ 				dev_dbg(dev, "Different devices on the same sdw link\n");
+ 				break;
+ 			}
+ 			_codec_index = codec_index;
+ 
+ 			comp_index = j - adr_index + codec_dlc_index;
+ 
+ 			ret = fill_sdw_codec_dlc(dev, adr_link_next,
+ 						 &codecs[comp_index],
+ 						 codec_index, j, dai_index);
+ 			if (ret)
+ 				return ret;
+ 
+ 			codec_conf[*codec_conf_index].dlc = codecs[comp_index];
+ 			codec_conf[*codec_conf_index].name_prefix =
+ 					adr_link_next->adr_d[j].name_prefix;
+ 
+ 			(*codec_conf_index)++;
+ 		}
++>>>>>>> c3d7e29ad82e (ASoC: intel: sof_sdw: Pull device loop up into create_sdw_dailink)
  
  		/* check next link to create codec dai in the processed group */
  		i++;
* Unmerged path sound/soc/intel/boards/sof_sdw.c
