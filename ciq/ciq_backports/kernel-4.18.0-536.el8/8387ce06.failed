x86/hyperv: Set Virtual Trust Level in VMBus init message

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Tianyu Lan <tiala@microsoft.com>
commit 8387ce06d70bbbb97a0c168a52b68268ae0da075
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/8387ce06.failed

SEV-SNP guests on Hyper-V can run at multiple Virtual Trust
Levels (VTL).  During boot, get the VTL at which we're running
using the GET_VP_REGISTERs hypercall, and save the value
for future use.  Then during VMBus initialization, set the VTL
with the saved value as required in the VMBus init message.

	Reviewed-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Tianyu Lan <tiala@microsoft.com>
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
Link: https://lore.kernel.org/r/20230818102919.1318039-3-ltykernel@gmail.com
(cherry picked from commit 8387ce06d70bbbb97a0c168a52b68268ae0da075)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
diff --cc arch/x86/hyperv/hv_init.c
index 1d0a26104d0f,318010eb9f9e..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -520,15 -536,9 +550,21 @@@ void __init hyperv_init(void
  	/* Query the VMs extended capability once, so that it can be cached. */
  	hv_query_ext_cap(0);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SWIOTLB
 +	/*
 +	 * Swiotlb bounce buffer needs to be mapped in extra address
 +	 * space. Map function doesn't work in the early place and so
 +	 * call swiotlb_update_mem_attributes() here.
 +	 */
 +	if (hv_is_isolation_supported())
 +		swiotlb_update_mem_attributes();
 +#endif
++=======
+ 	/* Find the VTL */
+ 	if (hv_isolation_type_en_snp())
+ 		ms_hyperv.vtl = get_vtl();
++>>>>>>> 8387ce06d70b (x86/hyperv: Set Virtual Trust Level in VMBus init message)
  
  	return;
  
* Unmerged path arch/x86/hyperv/hv_init.c
diff --git a/arch/x86/include/asm/hyperv-tlfs.h b/arch/x86/include/asm/hyperv-tlfs.h
index 5c67c9e46cc4..2820e8589ad9 100644
--- a/arch/x86/include/asm/hyperv-tlfs.h
+++ b/arch/x86/include/asm/hyperv-tlfs.h
@@ -301,6 +301,13 @@ enum hv_isolation_type {
 #define HV_X64_MSR_TIME_REF_COUNT	HV_REGISTER_TIME_REF_COUNT
 #define HV_X64_MSR_REFERENCE_TSC	HV_REGISTER_REFERENCE_TSC
 
+/*
+ * Registers are only accessible via HVCALL_GET_VP_REGISTERS hvcall and
+ * there is not associated MSR address.
+ */
+#define	HV_X64_REGISTER_VSM_VP_STATUS	0x000D0003
+#define	HV_X64_VTL_MASK			GENMASK(3, 0)
+
 /* Hyper-V memory host visibility */
 enum hv_mem_host_visibility {
 	VMBUS_PAGE_NOT_VISIBLE		= 0,
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 6535a1d15ba1..82a3c1bf73d8 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -111,6 +111,7 @@ int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 	 */
 	if (version >= VERSION_WIN10_V5) {
 		msg->msg_sint = VMBUS_MESSAGE_SINT;
+		msg->msg_vtl = ms_hyperv.vtl;
 		vmbus_connection.msg_conn_id = VMBUS_MESSAGE_CONNECTION_ID_4;
 	} else {
 		msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
diff --git a/include/asm-generic/mshyperv.h b/include/asm-generic/mshyperv.h
index 8845a2eca339..7ddc9896c120 100644
--- a/include/asm-generic/mshyperv.h
+++ b/include/asm-generic/mshyperv.h
@@ -46,6 +46,7 @@ struct ms_hyperv_info {
 		};
 	};
 	u64 shared_gpa_boundary;
+	u8 vtl;
 };
 extern struct ms_hyperv_info ms_hyperv;
 extern bool hv_nested;
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b405e9cb4082..ea8fe3872e4d 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -678,8 +678,8 @@ struct vmbus_channel_initiate_contact {
 		u64 interrupt_page;
 		struct {
 			u8	msg_sint;
-			u8	padding1[3];
-			u32	padding2;
+			u8	msg_vtl;
+			u8	reserved[6];
 		};
 	};
 	u64 monitor_page1;
