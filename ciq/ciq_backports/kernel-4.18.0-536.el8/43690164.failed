bpf: cpumap: Fix memory leak in cpu_map_update_elem

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Pu Lehui <pulehui@huawei.com>
commit 4369016497319a9635702da010d02af1ebb1849d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/43690164.failed

Syzkaller reported a memory leak as follows:

BUG: memory leak
unreferenced object 0xff110001198ef748 (size 192):
  comm "syz-executor.3", pid 17672, jiffies 4298118891 (age 9.906s)
  hex dump (first 32 bytes):
    00 00 00 00 4a 19 00 00 80 ad e3 e4 fe ff c0 00  ....J...........
    00 b2 d3 0c 01 00 11 ff 28 f5 8e 19 01 00 11 ff  ........(.......
  backtrace:
    [<ffffffffadd28087>] __cpu_map_entry_alloc+0xf7/0xb00
    [<ffffffffadd28d8e>] cpu_map_update_elem+0x2fe/0x3d0
    [<ffffffffadc6d0fd>] bpf_map_update_value.isra.0+0x2bd/0x520
    [<ffffffffadc7349b>] map_update_elem+0x4cb/0x720
    [<ffffffffadc7d983>] __se_sys_bpf+0x8c3/0xb90
    [<ffffffffb029cc80>] do_syscall_64+0x30/0x40
    [<ffffffffb0400099>] entry_SYSCALL_64_after_hwframe+0x61/0xc6

BUG: memory leak
unreferenced object 0xff110001198ef528 (size 192):
  comm "syz-executor.3", pid 17672, jiffies 4298118891 (age 9.906s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<ffffffffadd281f0>] __cpu_map_entry_alloc+0x260/0xb00
    [<ffffffffadd28d8e>] cpu_map_update_elem+0x2fe/0x3d0
    [<ffffffffadc6d0fd>] bpf_map_update_value.isra.0+0x2bd/0x520
    [<ffffffffadc7349b>] map_update_elem+0x4cb/0x720
    [<ffffffffadc7d983>] __se_sys_bpf+0x8c3/0xb90
    [<ffffffffb029cc80>] do_syscall_64+0x30/0x40
    [<ffffffffb0400099>] entry_SYSCALL_64_after_hwframe+0x61/0xc6

BUG: memory leak
unreferenced object 0xff1100010fd93d68 (size 8):
  comm "syz-executor.3", pid 17672, jiffies 4298118891 (age 9.906s)
  hex dump (first 8 bytes):
    00 00 00 00 00 00 00 00                          ........
  backtrace:
    [<ffffffffade5db3e>] kvmalloc_node+0x11e/0x170
    [<ffffffffadd28280>] __cpu_map_entry_alloc+0x2f0/0xb00
    [<ffffffffadd28d8e>] cpu_map_update_elem+0x2fe/0x3d0
    [<ffffffffadc6d0fd>] bpf_map_update_value.isra.0+0x2bd/0x520
    [<ffffffffadc7349b>] map_update_elem+0x4cb/0x720
    [<ffffffffadc7d983>] __se_sys_bpf+0x8c3/0xb90
    [<ffffffffb029cc80>] do_syscall_64+0x30/0x40
    [<ffffffffb0400099>] entry_SYSCALL_64_after_hwframe+0x61/0xc6

In the cpu_map_update_elem flow, when kthread_stop is called before
calling the threadfn of rcpu->kthread, since the KTHREAD_SHOULD_STOP bit
of kthread has been set by kthread_stop, the threadfn of rcpu->kthread
will never be executed, and rcpu->refcnt will never be 0, which will
lead to the allocated rcpu, rcpu->queue and rcpu->queue->queue cannot be
released.

Calling kthread_stop before executing kthread's threadfn will return
-EINTR. We can complete the release of memory resources in this state.

Fixes: 6710e1126934 ("bpf: introduce new bpf cpu map type BPF_MAP_TYPE_CPUMAP")
	Signed-off-by: Pu Lehui <pulehui@huawei.com>
	Acked-by: Jesper Dangaard Brouer <hawk@kernel.org>
	Acked-by: Hou Tao <houtao1@huawei.com>
Link: https://lore.kernel.org/r/20230711115848.2701559-1-pulehui@huaweicloud.com
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 4369016497319a9635702da010d02af1ebb1849d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/cpumap.c
diff --cc kernel/bpf/cpumap.c
index 1d67dd9be144,6ae02be7a48e..000000000000
--- a/kernel/bpf/cpumap.c
+++ b/kernel/bpf/cpumap.c
@@@ -168,6 -149,70 +152,73 @@@ static void put_cpu_map_entry(struct bp
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /* called from workqueue, to workaround syscall using preempt_disable */
+ static void cpu_map_kthread_stop(struct work_struct *work)
+ {
+ 	struct bpf_cpu_map_entry *rcpu;
+ 	int err;
+ 
+ 	rcpu = container_of(work, struct bpf_cpu_map_entry, kthread_stop_wq);
+ 
+ 	/* Wait for flush in __cpu_map_entry_free(), via full RCU barrier,
+ 	 * as it waits until all in-flight call_rcu() callbacks complete.
+ 	 */
+ 	rcu_barrier();
+ 
+ 	/* kthread_stop will wake_up_process and wait for it to complete */
+ 	err = kthread_stop(rcpu->kthread);
+ 	if (err) {
+ 		/* kthread_stop may be called before cpu_map_kthread_run
+ 		 * is executed, so we need to release the memory related
+ 		 * to rcpu.
+ 		 */
+ 		put_cpu_map_entry(rcpu);
+ 	}
+ }
+ 
+ static void cpu_map_bpf_prog_run_skb(struct bpf_cpu_map_entry *rcpu,
+ 				     struct list_head *listp,
+ 				     struct xdp_cpumap_stats *stats)
+ {
+ 	struct sk_buff *skb, *tmp;
+ 	struct xdp_buff xdp;
+ 	u32 act;
+ 	int err;
+ 
+ 	list_for_each_entry_safe(skb, tmp, listp, list) {
+ 		act = bpf_prog_run_generic_xdp(skb, &xdp, rcpu->prog);
+ 		switch (act) {
+ 		case XDP_PASS:
+ 			break;
+ 		case XDP_REDIRECT:
+ 			skb_list_del_init(skb);
+ 			err = xdp_do_generic_redirect(skb->dev, skb, &xdp,
+ 						      rcpu->prog);
+ 			if (unlikely(err)) {
+ 				kfree_skb(skb);
+ 				stats->drop++;
+ 			} else {
+ 				stats->redirect++;
+ 			}
+ 			return;
+ 		default:
+ 			bpf_warn_invalid_xdp_action(NULL, rcpu->prog, act);
+ 			fallthrough;
+ 		case XDP_ABORTED:
+ 			trace_xdp_exception(skb->dev, rcpu->prog, act);
+ 			fallthrough;
+ 		case XDP_DROP:
+ 			skb_list_del_init(skb);
+ 			kfree_skb(skb);
+ 			stats->drop++;
+ 			return;
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 436901649731 (bpf: cpumap: Fix memory leak in cpu_map_update_elem)
  static int cpu_map_bpf_prog_run_xdp(struct bpf_cpu_map_entry *rcpu,
  				    void **frames, int n,
  				    struct xdp_cpumap_stats *stats)
* Unmerged path kernel/bpf/cpumap.c
