ALSA: hda: cs35l41: Remove unnecessary boolean state variable firmware_running

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit 37f67abe08557a79c3aabf684a49c6b99dbc259a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/37f67abe.failed

This state duplicates the running state inside cs_dsp, so is not necessary.
Remove it, and use cs_dsp.running instead.
This brings the CS35L41 HDA driver more inline with its ASoC version,
allowing the same state to be used when calling library functions.

Fixes: fa3efcc36aac ("ALSA: cs35l41: Use mbox command to enable speaker output for external boost")
	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20231117163609.823627-2-sbinding@opensource.cirrus.com
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 37f67abe08557a79c3aabf684a49c6b99dbc259a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/cs35l41_hda.c
diff --cc sound/pci/hda/cs35l41_hda.c
index 8e0696101fe5,b7d2aa18c566..000000000000
--- a/sound/pci/hda/cs35l41_hda.c
+++ b/sound/pci/hda/cs35l41_hda.c
@@@ -564,6 -565,31 +563,34 @@@ static void cs35l41_hda_play_start(stru
  
  }
  
++<<<<<<< HEAD
++=======
+ static void cs35l41_mute(struct device *dev, bool mute)
+ {
+ 	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
+ 	struct regmap *reg = cs35l41->regmap;
+ 
+ 	dev_dbg(dev, "Mute(%d:%d) Playback Started: %d\n", mute, cs35l41->mute_override,
+ 		cs35l41->playback_started);
+ 
+ 	if (cs35l41->playback_started) {
+ 		if (mute || cs35l41->mute_override) {
+ 			dev_dbg(dev, "Muting\n");
+ 			regmap_multi_reg_write(reg, cs35l41_hda_mute, ARRAY_SIZE(cs35l41_hda_mute));
+ 		} else {
+ 			dev_dbg(dev, "Unmuting\n");
+ 			if (cs35l41->cs_dsp.running) {
+ 				regmap_multi_reg_write(reg, cs35l41_hda_unmute_dsp,
+ 						ARRAY_SIZE(cs35l41_hda_unmute_dsp));
+ 			} else {
+ 				regmap_multi_reg_write(reg, cs35l41_hda_unmute,
+ 						ARRAY_SIZE(cs35l41_hda_unmute));
+ 			}
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 37f67abe0855 (ALSA: hda: cs35l41: Remove unnecessary boolean state variable firmware_running)
  static void cs35l41_hda_play_done(struct device *dev)
  {
  	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
@@@ -572,14 -598,8 +599,19 @@@
  	dev_dbg(dev, "Play (Complete)\n");
  
  	cs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 1,
++<<<<<<< HEAD
 +			      cs35l41->firmware_running);
 +	if (cs35l41->firmware_running) {
 +		regmap_multi_reg_write(reg, cs35l41_hda_unmute_dsp,
 +				       ARRAY_SIZE(cs35l41_hda_unmute_dsp));
 +	} else {
 +		regmap_multi_reg_write(reg, cs35l41_hda_unmute,
 +				       ARRAY_SIZE(cs35l41_hda_unmute));
 +	}
++=======
+ 			      cs35l41->cs_dsp.running);
+ 	cs35l41_mute(dev, false);
++>>>>>>> 37f67abe0855 (ALSA: hda: cs35l41: Remove unnecessary boolean state variable firmware_running)
  }
  
  static void cs35l41_hda_pause_start(struct device *dev)
@@@ -589,9 -609,9 +621,9 @@@
  
  	dev_dbg(dev, "Pause (Start)\n");
  
 -	cs35l41_mute(dev, true);
 +	regmap_multi_reg_write(reg, cs35l41_hda_mute, ARRAY_SIZE(cs35l41_hda_mute));
  	cs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 0,
- 			      cs35l41->firmware_running);
+ 			      cs35l41->cs_dsp.running);
  }
  
  static void cs35l41_hda_pause_done(struct device *dev)
@@@ -653,6 -673,15 +685,18 @@@ static void cs35l41_hda_playback_hook(s
  		mutex_unlock(&cs35l41->fw_mutex);
  		break;
  	case HDA_GEN_PCM_ACT_CLOSE:
++<<<<<<< HEAD
++=======
+ 		mutex_lock(&cs35l41->fw_mutex);
+ 		if (!cs35l41->cs_dsp.running && cs35l41->request_fw_load &&
+ 		    !cs35l41->fw_request_ongoing) {
+ 			dev_info(dev, "Requesting Firmware Load after HDA_GEN_PCM_ACT_CLOSE\n");
+ 			cs35l41->fw_request_ongoing = true;
+ 			schedule_work(&cs35l41->fw_load_work);
+ 		}
+ 		mutex_unlock(&cs35l41->fw_mutex);
+ 
++>>>>>>> 37f67abe0855 (ALSA: hda: cs35l41: Remove unnecessary boolean state variable firmware_running)
  		/*
  		 * Playback must be finished for all amps before we start runtime suspend.
  		 * This ensures no amps are playing back when we start putting them to sleep.
@@@ -870,12 -923,7 +913,16 @@@ static int cs35l41_runtime_suspend(stru
  
  	mutex_lock(&cs35l41->fw_mutex);
  
++<<<<<<< HEAD
 +	if (cs35l41->playback_started) {
 +		cs35l41_hda_pause_start(dev);
 +		cs35l41_hda_pause_done(dev);
 +	}
 +
 +	if (cs35l41->firmware_running) {
++=======
+ 	if (cs35l41->cs_dsp.running) {
++>>>>>>> 37f67abe0855 (ALSA: hda: cs35l41: Remove unnecessary boolean state variable firmware_running)
  		ret = cs35l41_enter_hibernate(cs35l41->dev, cs35l41->regmap,
  					      cs35l41->hw_cfg.bst_type);
  		if (ret)
* Unmerged path sound/pci/hda/cs35l41_hda.c
