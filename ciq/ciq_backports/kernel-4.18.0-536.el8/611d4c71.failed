x86/hyperv: Mark hv_ghcb_terminate() as noreturn

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Guilherme G. Piccoli <gpiccoli@igalia.com>
commit 611d4c716db0141cfc436994dc5aff1d69c924ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/611d4c71.failed

Annotate the function prototype and definition as noreturn to prevent
objtool warnings like:

vmlinux.o: warning: objtool: hyperv_init+0x55c: unreachable instruction

Also, as per Josh's suggestion, add it to the global_noreturns list.
As a comparison, an objdump output without the annotation:

[...]
1b63:  mov    $0x1,%esi
1b68:  xor    %edi,%edi
1b6a:  callq  ffffffff8102f680 <hv_ghcb_terminate>
1b6f:  jmpq   ffffffff82f217ec <hyperv_init+0x9c> # unreachable
1b74:  cmpq   $0xffffffffffffffff,-0x702a24(%rip)
[...]

Now, after adding the __noreturn to the function prototype:

[...]
17df:  callq  ffffffff8102f6d0 <hv_ghcb_negotiate_protocol>
17e4:  test   %al,%al
17e6:  je     ffffffff82f21bb9 <hyperv_init+0x469>
[...]  <many insns>
1bb9:  mov    $0x1,%esi
1bbe:  xor    %edi,%edi
1bc0:  callq  ffffffff8102f680 <hv_ghcb_terminate>
1bc5:  nopw   %cs:0x0(%rax,%rax,1) # end of function

	Reported-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Guilherme G. Piccoli <gpiccoli@igalia.com>
	Signed-off-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/32453a703dfcf0d007b473c9acbf70718222b74b.1681342859.git.jpoimboe@kernel.org
(cherry picked from commit 611d4c716db0141cfc436994dc5aff1d69c924ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/objtool/check.c
diff --cc tools/objtool/check.c
index 2ff4b9e05984,5b600bbf2389..000000000000
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@@ -141,29 -194,54 +141,53 @@@ static bool __dead_end_function(struct 
  
  	/*
  	 * Unfortunately these have to be hard coded because the noreturn
 -	 * attribute isn't provided in ELF data. Keep 'em sorted.
 +	 * attribute isn't provided in ELF data.
  	 */
  	static const char * const global_noreturns[] = {
 -		"__invalid_creds",
 -		"__module_put_and_kthread_exit",
 -		"__reiserfs_panic",
  		"__stack_chk_fail",
++<<<<<<< HEAD
++=======
+ 		"__ubsan_handle_builtin_unreachable",
+ 		"arch_call_rest_init",
+ 		"arch_cpu_idle_dead",
+ 		"btrfs_assertfail",
+ 		"cpu_bringup_and_idle",
+ 		"cpu_startup_entry",
+ 		"do_exit",
+ 		"do_group_exit",
+ 		"do_task_dead",
+ 		"ex_handler_msr_mce",
+ 		"fortify_panic",
+ 		"hlt_play_dead",
+ 		"hv_ghcb_terminate",
+ 		"kthread_complete_and_exit",
+ 		"kthread_exit",
+ 		"kunit_try_catch_throw",
+ 		"lbug_with_loc",
+ 		"machine_real_restart",
+ 		"make_task_dead",
+ 		"mpt_halt_firmware",
+ 		"nmi_panic_self_stop",
++>>>>>>> 611d4c716db0 (x86/hyperv: Mark hv_ghcb_terminate() as noreturn)
  		"panic",
 -		"panic_smp_self_stop",
 -		"rest_init",
 -		"resume_play_dead",
 -		"rewind_stack_and_make_dead",
 -		"sev_es_terminate",
 -		"snp_abort",
 -		"start_kernel",
 -		"stop_this_cpu",
 +		"do_exit",
 +		"do_task_dead",
 +		"__module_put_and_exit",
 +		"complete_and_exit",
 +		"__reiserfs_panic",
 +		"lbug_with_loc",
 +		"fortify_panic",
  		"usercopy_abort",
 -		"x86_64_start_kernel",
 -		"x86_64_start_reservations",
 -		"xen_cpu_bringup_again",
 -		"xen_start_kernel",
 +		"machine_real_restart",
 +		"rewind_stack_do_exit",
 +		"kunit_try_catch_throw",
 +		"snp_abort",
  	};
  
 -	if (!func)
 +	if (func->bind == STB_WEAK)
  		return false;
  
 -	if (func->bind == STB_GLOBAL || func->bind == STB_WEAK)
 +	if (func->bind == STB_GLOBAL)
  		for (i = 0; i < ARRAY_SIZE(global_noreturns); i++)
  			if (!strcmp(func->name, global_noreturns[i]))
  				return true;
diff --git a/arch/x86/hyperv/ivm.c b/arch/x86/hyperv/ivm.c
index 5648efb6c73e..56dd59a47e2b 100644
--- a/arch/x86/hyperv/ivm.c
+++ b/arch/x86/hyperv/ivm.c
@@ -127,7 +127,7 @@ static enum es_result hv_ghcb_hv_call(struct ghcb *ghcb, u64 exit_code,
 		return ES_OK;
 }
 
-void hv_ghcb_terminate(unsigned int set, unsigned int reason)
+void __noreturn hv_ghcb_terminate(unsigned int set, unsigned int reason)
 {
 	u64 val = GHCB_MSR_TERM_REQ;
 
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index a56488c7d1a0..0ad5ff878857 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -248,7 +248,7 @@ int hv_set_mem_host_visibility(unsigned long addr, int numpages, bool visible);
 void hv_ghcb_msr_write(u64 msr, u64 value);
 void hv_ghcb_msr_read(u64 msr, u64 *value);
 bool hv_ghcb_negotiate_protocol(void);
-void hv_ghcb_terminate(unsigned int set, unsigned int reason);
+void __noreturn hv_ghcb_terminate(unsigned int set, unsigned int reason);
 #else
 static inline void hv_ghcb_msr_write(u64 msr, u64 value) {}
 static inline void hv_ghcb_msr_read(u64 msr, u64 *value) {}
* Unmerged path tools/objtool/check.c
