x86/hyperv: Add smp support for SEV-SNP guest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-536.el8
commit-author Tianyu Lan <tiala@microsoft.com>
commit 44676bb9d566ce2bfbd132f9745eb7eb2d784476
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-536.el8/44676bb9.failed

In the AMD SEV-SNP guest, AP needs to be started up via sev es
save area and Hyper-V requires to call HVCALL_START_VP hypercall
to pass the gpa of sev es save area with AP's vp index and VTL(Virtual
trust level) parameters. Override wakeup_secondary_cpu_64 callback
with hv_snp_boot_ap.

	Reviewed-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Tianyu Lan <tiala@microsoft.com>
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
Link: https://lore.kernel.org/r/20230818102919.1318039-8-ltykernel@gmail.com
(cherry picked from commit 44676bb9d566ce2bfbd132f9745eb7eb2d784476)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/ivm.c
#	arch/x86/include/asm/mshyperv.h
#	arch/x86/kernel/cpu/mshyperv.c
diff --cc arch/x86/hyperv/ivm.c
index 5648efb6c73e,cbbd3af4c3da..000000000000
--- a/arch/x86/hyperv/ivm.c
+++ b/arch/x86/hyperv/ivm.c
@@@ -13,8 -13,17 +13,18 @@@
  #include <asm/svm.h>
  #include <asm/sev.h>
  #include <asm/io.h>
 -#include <asm/coco.h>
 -#include <asm/mem_encrypt.h>
  #include <asm/mshyperv.h>
  #include <asm/hypervisor.h>
++<<<<<<< HEAD
++=======
+ #include <asm/mtrr.h>
+ #include <asm/coco.h>
+ #include <asm/io_apic.h>
+ #include <asm/sev.h>
+ #include <asm/realmode.h>
+ #include <asm/e820/api.h>
+ #include <asm/desc.h>
++>>>>>>> 44676bb9d566 (x86/hyperv: Add smp support for SEV-SNP guest)
  
  #ifdef CONFIG_AMD_MEM_ENCRYPT
  
@@@ -323,37 -336,188 +338,209 @@@ int hv_set_mem_host_visibility(unsigne
  
   err_free_pfn_array:
  	kfree(pfn_array);
 -	return result;
 +	return ret;
  }
  
 -static bool hv_vtom_tlb_flush_required(bool private)
 +/*
 + * hv_map_memory - map memory to extra space in the AMD SEV-SNP Isolation VM.
 + */
 +void *hv_map_memory(void *addr, unsigned long size)
  {
 -	return true;
 +	unsigned long *pfns = kcalloc(size / PAGE_SIZE,
 +				      sizeof(unsigned long), GFP_KERNEL);
 +	void *vaddr;
 +	int i;
 +
 +	if (!pfns)
 +		return NULL;
 +
 +	for (i = 0; i < size / PAGE_SIZE; i++)
 +		pfns[i] = vmalloc_to_pfn(addr + i * PAGE_SIZE) +
 +			(ms_hyperv.shared_gpa_boundary >> PAGE_SHIFT);
 +
 +	vaddr = vmap_pfn(pfns, size / PAGE_SIZE, pgprot_decrypted(PAGE_KERNEL));
 +	kfree(pfns);
 +
 +	return vaddr;
  }
  
 -static bool hv_vtom_cache_flush_required(void)
 +void hv_unmap_memory(void *addr)
  {
 -	return false;
 +	vunmap(addr);
  }
  
++<<<<<<< HEAD
++=======
+ static bool hv_is_private_mmio(u64 addr)
+ {
+ 	/*
+ 	 * Hyper-V always provides a single IO-APIC in a guest VM.
+ 	 * When a paravisor is used, it is emulated by the paravisor
+ 	 * in the guest context and must be mapped private.
+ 	 */
+ 	if (addr >= HV_IOAPIC_BASE_ADDRESS &&
+ 	    addr < (HV_IOAPIC_BASE_ADDRESS + PAGE_SIZE))
+ 		return true;
+ 
+ 	/* Same with a vTPM */
+ 	if (addr >= VTPM_BASE_ADDRESS &&
+ 	    addr < (VTPM_BASE_ADDRESS + PAGE_SIZE))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ #define hv_populate_vmcb_seg(seg, gdtr_base)			\
+ do {								\
+ 	if (seg.selector) {					\
+ 		seg.base = 0;					\
+ 		seg.limit = HV_AP_SEGMENT_LIMIT;		\
+ 		seg.attrib = *(u16 *)(gdtr_base + seg.selector + 5);	\
+ 		seg.attrib = (seg.attrib & 0xFF) | ((seg.attrib >> 4) & 0xF00); \
+ 	}							\
+ } while (0)							\
+ 
+ static int snp_set_vmsa(void *va, bool vmsa)
+ {
+ 	u64 attrs;
+ 
+ 	/*
+ 	 * Running at VMPL0 allows the kernel to change the VMSA bit for a page
+ 	 * using the RMPADJUST instruction. However, for the instruction to
+ 	 * succeed it must target the permissions of a lesser privileged
+ 	 * (higher numbered) VMPL level, so use VMPL1 (refer to the RMPADJUST
+ 	 * instruction in the AMD64 APM Volume 3).
+ 	 */
+ 	attrs = 1;
+ 	if (vmsa)
+ 		attrs |= RMPADJUST_VMSA_PAGE_BIT;
+ 
+ 	return rmpadjust((unsigned long)va, RMP_PG_SIZE_4K, attrs);
+ }
+ 
+ static void snp_cleanup_vmsa(struct sev_es_save_area *vmsa)
+ {
+ 	int err;
+ 
+ 	err = snp_set_vmsa(vmsa, false);
+ 	if (err)
+ 		pr_err("clear VMSA page failed (%u), leaking page\n", err);
+ 	else
+ 		free_page((unsigned long)vmsa);
+ }
+ 
+ int hv_snp_boot_ap(int cpu, unsigned long start_ip)
+ {
+ 	struct sev_es_save_area *vmsa = (struct sev_es_save_area *)
+ 		__get_free_page(GFP_KERNEL | __GFP_ZERO);
+ 	struct sev_es_save_area *cur_vmsa;
+ 	struct desc_ptr gdtr;
+ 	u64 ret, retry = 5;
+ 	struct hv_enable_vp_vtl *start_vp_input;
+ 	unsigned long flags;
+ 
+ 	if (!vmsa)
+ 		return -ENOMEM;
+ 
+ 	native_store_gdt(&gdtr);
+ 
+ 	vmsa->gdtr.base = gdtr.address;
+ 	vmsa->gdtr.limit = gdtr.size;
+ 
+ 	asm volatile("movl %%es, %%eax;" : "=a" (vmsa->es.selector));
+ 	hv_populate_vmcb_seg(vmsa->es, vmsa->gdtr.base);
+ 
+ 	asm volatile("movl %%cs, %%eax;" : "=a" (vmsa->cs.selector));
+ 	hv_populate_vmcb_seg(vmsa->cs, vmsa->gdtr.base);
+ 
+ 	asm volatile("movl %%ss, %%eax;" : "=a" (vmsa->ss.selector));
+ 	hv_populate_vmcb_seg(vmsa->ss, vmsa->gdtr.base);
+ 
+ 	asm volatile("movl %%ds, %%eax;" : "=a" (vmsa->ds.selector));
+ 	hv_populate_vmcb_seg(vmsa->ds, vmsa->gdtr.base);
+ 
+ 	vmsa->efer = native_read_msr(MSR_EFER);
+ 
+ 	asm volatile("movq %%cr4, %%rax;" : "=a" (vmsa->cr4));
+ 	asm volatile("movq %%cr3, %%rax;" : "=a" (vmsa->cr3));
+ 	asm volatile("movq %%cr0, %%rax;" : "=a" (vmsa->cr0));
+ 
+ 	vmsa->xcr0 = 1;
+ 	vmsa->g_pat = HV_AP_INIT_GPAT_DEFAULT;
+ 	vmsa->rip = (u64)secondary_startup_64_no_verify;
+ 	vmsa->rsp = (u64)&ap_start_stack[PAGE_SIZE];
+ 
+ 	/*
+ 	 * Set the SNP-specific fields for this VMSA:
+ 	 *   VMPL level
+ 	 *   SEV_FEATURES (matches the SEV STATUS MSR right shifted 2 bits)
+ 	 */
+ 	vmsa->vmpl = 0;
+ 	vmsa->sev_features = sev_status >> 2;
+ 
+ 	ret = snp_set_vmsa(vmsa, true);
+ 	if (!ret) {
+ 		pr_err("RMPADJUST(%llx) failed: %llx\n", (u64)vmsa, ret);
+ 		free_page((u64)vmsa);
+ 		return ret;
+ 	}
+ 
+ 	local_irq_save(flags);
+ 	start_vp_input = (struct hv_enable_vp_vtl *)ap_start_input_arg;
+ 	memset(start_vp_input, 0, sizeof(*start_vp_input));
+ 	start_vp_input->partition_id = -1;
+ 	start_vp_input->vp_index = cpu;
+ 	start_vp_input->target_vtl.target_vtl = ms_hyperv.vtl;
+ 	*(u64 *)&start_vp_input->vp_context = __pa(vmsa) | 1;
+ 
+ 	do {
+ 		ret = hv_do_hypercall(HVCALL_START_VP,
+ 				      start_vp_input, NULL);
+ 	} while (hv_result(ret) == HV_STATUS_TIME_OUT && retry--);
+ 
+ 	local_irq_restore(flags);
+ 
+ 	if (!hv_result_success(ret)) {
+ 		pr_err("HvCallStartVirtualProcessor failed: %llx\n", ret);
+ 		snp_cleanup_vmsa(vmsa);
+ 		vmsa = NULL;
+ 	}
+ 
+ 	cur_vmsa = per_cpu(hv_sev_vmsa, cpu);
+ 	/* Free up any previous VMSA page */
+ 	if (cur_vmsa)
+ 		snp_cleanup_vmsa(cur_vmsa);
+ 
+ 	/* Record the current VMSA page */
+ 	per_cpu(hv_sev_vmsa, cpu) = vmsa;
+ 
+ 	return ret;
+ }
+ 
+ void __init hv_vtom_init(void)
+ {
+ 	/*
+ 	 * By design, a VM using vTOM doesn't see the SEV setting,
+ 	 * so SEV initialization is bypassed and sev_status isn't set.
+ 	 * Set it here to indicate a vTOM VM.
+ 	 */
+ 	sev_status = MSR_AMD64_SNP_VTOM;
+ 	cc_vendor = CC_VENDOR_AMD;
+ 	cc_set_mask(ms_hyperv.shared_gpa_boundary);
+ 	physical_mask &= ms_hyperv.shared_gpa_boundary - 1;
+ 
+ 	x86_platform.hyper.is_private_mmio = hv_is_private_mmio;
+ 	x86_platform.guest.enc_cache_flush_required = hv_vtom_cache_flush_required;
+ 	x86_platform.guest.enc_tlb_flush_required = hv_vtom_tlb_flush_required;
+ 	x86_platform.guest.enc_status_change_finish = hv_vtom_set_host_visibility;
+ 
+ 	/* Set WB as the default cache mode. */
+ 	mtrr_overwrite_state(NULL, 0, MTRR_TYPE_WRBACK);
+ }
+ 
+ #endif /* CONFIG_AMD_MEM_ENCRYPT */
+ 
++>>>>>>> 44676bb9d566 (x86/hyperv: Add smp support for SEV-SNP guest)
  enum hv_isolation_type hv_get_isolation_type(void)
  {
  	if (!(ms_hyperv.priv_high & HV_ISOLATION))
diff --cc arch/x86/include/asm/mshyperv.h
index a56488c7d1a0,6bd9ae04d9c3..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -248,12 -260,16 +254,23 @@@ int hv_set_mem_host_visibility(unsigne
  void hv_ghcb_msr_write(u64 msr, u64 value);
  void hv_ghcb_msr_read(u64 msr, u64 *value);
  bool hv_ghcb_negotiate_protocol(void);
++<<<<<<< HEAD
 +void hv_ghcb_terminate(unsigned int set, unsigned int reason);
++=======
+ void __noreturn hv_ghcb_terminate(unsigned int set, unsigned int reason);
+ void hv_vtom_init(void);
+ int hv_snp_boot_ap(int cpu, unsigned long start_ip);
++>>>>>>> 44676bb9d566 (x86/hyperv: Add smp support for SEV-SNP guest)
  #else
  static inline void hv_ghcb_msr_write(u64 msr, u64 value) {}
  static inline void hv_ghcb_msr_read(u64 msr, u64 *value) {}
  static inline bool hv_ghcb_negotiate_protocol(void) { return false; }
  static inline void hv_ghcb_terminate(unsigned int set, unsigned int reason) {}
++<<<<<<< HEAD
++=======
+ static inline void hv_vtom_init(void) {}
+ static int hv_snp_boot_ap(int cpu, unsigned long start_ip) { return 0; }
++>>>>>>> 44676bb9d566 (x86/hyperv: Add smp support for SEV-SNP guest)
  #endif
  
  extern bool hv_isolation_type_snp(void);
diff --cc arch/x86/kernel/cpu/mshyperv.c
index 1189865ffc68,c56fc151b8db..000000000000
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@@ -300,6 -285,41 +300,44 @@@ static void __init hv_smp_prepare_boot_
  	hv_init_spinlocks();
  #endif
  }
++<<<<<<< HEAD
++=======
+ 
+ static void __init hv_smp_prepare_cpus(unsigned int max_cpus)
+ {
+ #ifdef CONFIG_X86_64
+ 	int i;
+ 	int ret;
+ #endif
+ 
+ 	native_smp_prepare_cpus(max_cpus);
+ 
+ 	/*
+ 	 *  Override wakeup_secondary_cpu_64 callback for SEV-SNP
+ 	 *  enlightened guest.
+ 	 */
+ 	if (hv_isolation_type_en_snp()) {
+ 		apic->wakeup_secondary_cpu_64 = hv_snp_boot_ap;
+ 		return;
+ 	}
+ 
+ #ifdef CONFIG_X86_64
+ 	for_each_present_cpu(i) {
+ 		if (i == 0)
+ 			continue;
+ 		ret = hv_call_add_logical_proc(numa_cpu_node(i), i, cpu_physical_id(i));
+ 		BUG_ON(ret);
+ 	}
+ 
+ 	for_each_present_cpu(i) {
+ 		if (i == 0)
+ 			continue;
+ 		ret = hv_call_create_vp(numa_cpu_node(i), hv_current_partition_id, i, i);
+ 		BUG_ON(ret);
+ 	}
+ #endif
+ }
++>>>>>>> 44676bb9d566 (x86/hyperv: Add smp support for SEV-SNP guest)
  #endif
  
  static void __init ms_hyperv_init_platform(void)
@@@ -484,6 -511,8 +522,11 @@@
  
  # ifdef CONFIG_SMP
  	smp_ops.smp_prepare_boot_cpu = hv_smp_prepare_boot_cpu;
++<<<<<<< HEAD
++=======
+ 	if (hv_root_partition || hv_isolation_type_en_snp())
+ 		smp_ops.smp_prepare_cpus = hv_smp_prepare_cpus;
++>>>>>>> 44676bb9d566 (x86/hyperv: Add smp support for SEV-SNP guest)
  # endif
  
  	/*
* Unmerged path arch/x86/hyperv/ivm.c
* Unmerged path arch/x86/include/asm/mshyperv.h
* Unmerged path arch/x86/kernel/cpu/mshyperv.c
diff --git a/include/asm-generic/hyperv-tlfs.h b/include/asm-generic/hyperv-tlfs.h
index f4e4cc4f965f..fdac4a1714ec 100644
--- a/include/asm-generic/hyperv-tlfs.h
+++ b/include/asm-generic/hyperv-tlfs.h
@@ -223,6 +223,7 @@ enum HV_GENERIC_SET_FORMAT {
 #define HV_STATUS_INVALID_PORT_ID		17
 #define HV_STATUS_INVALID_CONNECTION_ID		18
 #define HV_STATUS_INSUFFICIENT_BUFFERS		19
+#define HV_STATUS_TIME_OUT                      120
 #define HV_STATUS_VTL_ALREADY_ENABLED		134
 
 /*
