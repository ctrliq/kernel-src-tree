s390: add z16 elf platform

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-516.el8
commit-author Heiko Carstens <hca@linux.ibm.com>
commit 6203ac30297847ddc5e122ccdcbe9941fbc258e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-516.el8/6203ac30.failed

Add detection for machine types 0x3931 and 0x3932 and set ELF platform
name to z16.

	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 6203ac30297847ddc5e122ccdcbe9941fbc258e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/processor.c
diff --cc arch/s390/kernel/processor.c
index 3f62e2fcb90a,aa0e0e7fc773..000000000000
--- a/arch/s390/kernel/processor.c
+++ b/arch/s390/kernel/processor.c
@@@ -151,6 -169,152 +151,155 @@@ static void show_cpu_summary(struct seq
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int __init setup_hwcaps(void)
+ {
+ 	/* instructions named N3, "backported" to esa-mode */
+ 	elf_hwcap |= HWCAP_ESAN3;
+ 
+ 	/* z/Architecture mode active */
+ 	elf_hwcap |= HWCAP_ZARCH;
+ 
+ 	/* store-facility-list-extended */
+ 	if (test_facility(7))
+ 		elf_hwcap |= HWCAP_STFLE;
+ 
+ 	/* message-security assist */
+ 	if (test_facility(17))
+ 		elf_hwcap |= HWCAP_MSA;
+ 
+ 	/* long-displacement */
+ 	if (test_facility(19))
+ 		elf_hwcap |= HWCAP_LDISP;
+ 
+ 	/* extended-immediate */
+ 	elf_hwcap |= HWCAP_EIMM;
+ 
+ 	/* extended-translation facility 3 enhancement */
+ 	if (test_facility(22) && test_facility(30))
+ 		elf_hwcap |= HWCAP_ETF3EH;
+ 
+ 	/* decimal floating point & perform floating point operation */
+ 	if (test_facility(42) && test_facility(44))
+ 		elf_hwcap |= HWCAP_DFP;
+ 
+ 	/* huge page support */
+ 	if (MACHINE_HAS_EDAT1)
+ 		elf_hwcap |= HWCAP_HPAGE;
+ 
+ 	/* 64-bit register support for 31-bit processes */
+ 	elf_hwcap |= HWCAP_HIGH_GPRS;
+ 
+ 	/* transactional execution */
+ 	if (MACHINE_HAS_TE)
+ 		elf_hwcap |= HWCAP_TE;
+ 
+ 	/*
+ 	 * Vector extension can be disabled with the "novx" parameter.
+ 	 * Use MACHINE_HAS_VX instead of facility bit 129.
+ 	 */
+ 	if (MACHINE_HAS_VX) {
+ 		elf_hwcap |= HWCAP_VXRS;
+ 		if (test_facility(134))
+ 			elf_hwcap |= HWCAP_VXRS_BCD;
+ 		if (test_facility(135))
+ 			elf_hwcap |= HWCAP_VXRS_EXT;
+ 		if (test_facility(148))
+ 			elf_hwcap |= HWCAP_VXRS_EXT2;
+ 		if (test_facility(152))
+ 			elf_hwcap |= HWCAP_VXRS_PDE;
+ 		if (test_facility(192))
+ 			elf_hwcap |= HWCAP_VXRS_PDE2;
+ 	}
+ 
+ 	if (test_facility(150))
+ 		elf_hwcap |= HWCAP_SORT;
+ 
+ 	if (test_facility(151))
+ 		elf_hwcap |= HWCAP_DFLT;
+ 
+ 	if (test_facility(165))
+ 		elf_hwcap |= HWCAP_NNPA;
+ 
+ 	/* guarded storage */
+ 	if (MACHINE_HAS_GS)
+ 		elf_hwcap |= HWCAP_GS;
+ 
+ 	if (MACHINE_HAS_PCI_MIO)
+ 		elf_hwcap |= HWCAP_PCI_MIO;
+ 
+ 	/* virtualization support */
+ 	if (sclp.has_sief2)
+ 		elf_hwcap |= HWCAP_SIE;
+ 
+ 	return 0;
+ }
+ arch_initcall(setup_hwcaps);
+ 
+ static int __init setup_elf_platform(void)
+ {
+ 	struct cpuid cpu_id;
+ 
+ 	get_cpu_id(&cpu_id);
+ 	add_device_randomness(&cpu_id, sizeof(cpu_id));
+ 	switch (cpu_id.machine) {
+ 	default:	/* Use "z10" as default. */
+ 		strcpy(elf_platform, "z10");
+ 		break;
+ 	case 0x2817:
+ 	case 0x2818:
+ 		strcpy(elf_platform, "z196");
+ 		break;
+ 	case 0x2827:
+ 	case 0x2828:
+ 		strcpy(elf_platform, "zEC12");
+ 		break;
+ 	case 0x2964:
+ 	case 0x2965:
+ 		strcpy(elf_platform, "z13");
+ 		break;
+ 	case 0x3906:
+ 	case 0x3907:
+ 		strcpy(elf_platform, "z14");
+ 		break;
+ 	case 0x8561:
+ 	case 0x8562:
+ 		strcpy(elf_platform, "z15");
+ 		break;
+ 	case 0x3931:
+ 	case 0x3932:
+ 		strcpy(elf_platform, "z16");
+ 		break;
+ 	}
+ 	return 0;
+ }
+ arch_initcall(setup_elf_platform);
+ 
+ static void show_cpu_topology(struct seq_file *m, unsigned long n)
+ {
+ #ifdef CONFIG_SCHED_TOPOLOGY
+ 	seq_printf(m, "physical id     : %d\n", topology_physical_package_id(n));
+ 	seq_printf(m, "core id         : %d\n", topology_core_id(n));
+ 	seq_printf(m, "book id         : %d\n", topology_book_id(n));
+ 	seq_printf(m, "drawer id       : %d\n", topology_drawer_id(n));
+ 	seq_printf(m, "dedicated       : %d\n", topology_cpu_dedicated(n));
+ 	seq_printf(m, "address         : %d\n", smp_cpu_get_cpu_address(n));
+ 	seq_printf(m, "siblings        : %d\n", cpumask_weight(topology_core_cpumask(n)));
+ 	seq_printf(m, "cpu cores       : %d\n", topology_booted_cores(n));
+ #endif /* CONFIG_SCHED_TOPOLOGY */
+ }
+ 
+ static void show_cpu_ids(struct seq_file *m, unsigned long n)
+ {
+ 	struct cpuid *id = &per_cpu(cpu_info.cpu_id, n);
+ 
+ 	seq_printf(m, "version         : %02X\n", id->version);
+ 	seq_printf(m, "identification  : %06X\n", id->ident);
+ 	seq_printf(m, "machine         : %04X\n", id->machine);
+ }
+ 
++>>>>>>> 6203ac302978 (s390: add z16 elf platform)
  static void show_cpu_mhz(struct seq_file *m, unsigned long n)
  {
  	struct cpu_info *c = per_cpu_ptr(&cpu_info, n);
* Unmerged path arch/s390/kernel/processor.c
