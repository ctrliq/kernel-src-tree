arm64: kdump: Remove custom linux,elfcorehdr handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-516.el8
commit-author Geert Uytterhoeven <geert+renesas@glider.be>
commit 57beb9bd18fca085e6627526d64d68b6080f605c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-516.el8/57beb9bd.failed

Remove the architecture-specific code for handling the
"linux,elfcorehdr" property under the "/chosen" node in DT, as the
platform-agnostic handling in the FDT core code already takes care of
this.

	Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Signed-off-by: Rob Herring <robh@kernel.org>
Link: https://lore.kernel.org/r/3b8f801f9b92066855e87f3079fafc153ab20f69.1628670468.git.geert+renesas@glider.be
(cherry picked from commit 57beb9bd18fca085e6627526d64d68b6080f605c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/init.c
diff --cc arch/arm64/mm/init.c
index 0ecabcb09871,bac4f06bb7d9..000000000000
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@@ -209,65 -124,22 +209,68 @@@ static void __init reserve_crashkernel(
  }
  #endif /* CONFIG_KEXEC_CORE */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_CRASH_DUMP
 +static int __init early_init_dt_scan_elfcorehdr(unsigned long node,
 +		const char *uname, int depth, void *data)
 +{
 +	const __be32 *reg;
 +	int len;
 +
 +	if (depth != 1 || strcmp(uname, "chosen") != 0)
 +		return 0;
 +
 +	reg = of_get_flat_dt_prop(node, "linux,elfcorehdr", &len);
 +	if (!reg || (len < (dt_root_addr_cells + dt_root_size_cells)))
 +		return 1;
 +
 +	elfcorehdr_addr = dt_mem_next_cell(dt_root_addr_cells, &reg);
 +	elfcorehdr_size = dt_mem_next_cell(dt_root_size_cells, &reg);
 +
 +	return 1;
 +}
 +
  /*
 - * Return the maximum physical address for a zone accessible by the given bits
 - * limit. If DRAM starts above 32-bit, expand the zone to the maximum
 - * available memory, otherwise cap it at 32-bit.
 + * reserve_elfcorehdr() - reserves memory for elf core header
 + *
 + * This function reserves the memory occupied by an elf core header
 + * described in the device tree. This region contains all the
 + * information about primary kernel's core image and is used by a dump
 + * capture kernel to access the system memory on primary kernel.
   */
 -static phys_addr_t __init max_zone_phys(unsigned int zone_bits)
 +static void __init reserve_elfcorehdr(void)
  {
 -	phys_addr_t zone_mask = DMA_BIT_MASK(zone_bits);
 -	phys_addr_t phys_start = memblock_start_of_DRAM();
 +	of_scan_flat_dt(early_init_dt_scan_elfcorehdr, NULL);
 +
 +	if (!elfcorehdr_size)
 +		return;
 +
 +	if (memblock_is_region_reserved(elfcorehdr_addr, elfcorehdr_size)) {
 +		pr_warn("elfcorehdr is overlapped\n");
 +		return;
 +	}
  
 -	if (phys_start > U32_MAX)
 -		zone_mask = PHYS_ADDR_MAX;
 -	else if (phys_start > zone_mask)
 -		zone_mask = U32_MAX;
 +	memblock_reserve(elfcorehdr_addr, elfcorehdr_size);
  
 -	return min(zone_mask, memblock_end_of_DRAM() - 1) + 1;
 +	pr_info("Reserving %lldKB of memory at 0x%llx for elfcorehdr\n",
 +		elfcorehdr_size >> 10, elfcorehdr_addr);
 +}
 +#else
 +static void __init reserve_elfcorehdr(void)
 +{
 +}
 +#endif /* CONFIG_CRASH_DUMP */
++=======
++>>>>>>> 57beb9bd18fc (arm64: kdump: Remove custom linux,elfcorehdr handling)
 +/*
 + * Return the maximum physical address for ZONE_DMA32 (DMA_BIT_MASK(32)). It
 + * currently assumes that for memory starting above 4G, 32-bit devices will
 + * use a DMA offset.
 + */
 +static phys_addr_t __init max_zone_dma32_phys(void)
 +{
 +	phys_addr_t offset = memblock_start_of_DRAM() & GENMASK_ULL(63, 32);
 +	return min(offset + (1ULL << 32), memblock_end_of_DRAM());
  }
  
  static void __init zone_sizes_init(unsigned long min, unsigned long max)
@@@ -496,19 -344,7 +499,22 @@@ void __init arm64_memblock_init(void
  
  	early_init_fdt_scan_reserved_mem();
  
++<<<<<<< HEAD
 +	/* 4GB maximum for 32-bit only capable devices */
 +	if (IS_ENABLED(CONFIG_ZONE_DMA32))
 +		arm64_dma32_phys_limit = max_zone_dma32_phys();
 +	else
 +		arm64_dma32_phys_limit = PHYS_MASK + 1;
 +
 +	reserve_crashkernel();
 +
 +	reserve_elfcorehdr();
 +
++=======
++>>>>>>> 57beb9bd18fc (arm64: kdump: Remove custom linux,elfcorehdr handling)
  	high_memory = __va(memblock_end_of_DRAM() - 1) + 1;
 +
 +	dma_contiguous_reserve(arm64_dma32_phys_limit);
  }
  
  void __init bootmem_init(void)
* Unmerged path arch/arm64/mm/init.c
