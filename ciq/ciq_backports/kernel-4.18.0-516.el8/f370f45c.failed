s390/pkey: do not use struct pkey_protkey

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-516.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit f370f45c6475ad0058277ae111f28fb32f58aa46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-516.el8/f370f45c.failed

This is an internal rework of the pkey code to not use the
struct pkey_protkey internal any more. This struct has a hard
coded protected key buffer with MAXPROTKEYSIZE = 64 bytes.
However, with support for ECC protected key, this limit is
too short and thus this patch reworks all the internal code
to use the triple u8 *protkey, u32 protkeylen, u32 protkeytype
instead. So the ioctl which still has to deal with this struct
coming from userspace and/or provided to userspace invoke all
the internal functions now with the triple instead of passing
a pointer to struct pkey_protkey.

Also the struct pkey_clrkey has been internally replaced in
a similar way. This struct also has a hard coded clear key
buffer of MAXCLRKEYSIZE = 32 bytes and thus is not usable with
e.g. ECC clear key material.

This is a transparent rework for userspace applications using
the pkey API. The internal kernel API used by the PAES crypto
ciphers has been adapted to this change to make it possible
to provide ECC protected keys via this interface in the future.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Reviewed-by: Holger Dengler <dengler@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit f370f45c6475ad0058277ae111f28fb32f58aa46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/pkey_api.c
diff --cc drivers/s390/crypto/pkey_api.c
index 3930e75c24bd,9d2af01204ea..000000000000
--- a/drivers/s390/crypto/pkey_api.c
+++ b/drivers/s390/crypto/pkey_api.c
@@@ -144,11 -150,12 +150,12 @@@ static int pkey_clr2protkey(u32 keytype
  /*
   * Find card and transform secure key into protected key.
   */
- static int pkey_skey2pkey(const u8 *key, struct pkey_protkey *pkey)
+ static int pkey_skey2pkey(const u8 *key, u8 *protkey,
+ 			  u32 *protkeylen, u32 *protkeytype)
  {
 -	struct keytoken_header *hdr = (struct keytoken_header *)key;
 -	u16 cardnr, domain;
  	int rc, verify;
 +	u16 cardnr, domain;
 +	struct keytoken_header *hdr = (struct keytoken_header *)key;
  
  	zcrypt_wait_api_operational();
  
@@@ -227,12 -233,13 +233,13 @@@ out
  /*
   * Find card and transform EP11 secure key into protected key.
   */
- static int pkey_ep11key2pkey(const u8 *key, struct pkey_protkey *pkey)
+ static int pkey_ep11key2pkey(const u8 *key, u8 *protkey,
+ 			     u32 *protkeylen, u32 *protkeytype)
  {
 -	struct ep11keyblob *kb = (struct ep11keyblob *)key;
 -	u32 nr_apqns, *apqns = NULL;
 -	u16 card, dom;
  	int i, rc;
 +	u16 card, dom;
 +	u32 nr_apqns, *apqns = NULL;
 +	struct ep11keyblob *kb = (struct ep11keyblob *)key;
  
  	zcrypt_wait_api_operational();
  
@@@ -345,19 -353,21 +353,26 @@@ static int pkey_genprotkey(u32 keytype
  /*
   * Verify if a protected key is still valid
   */
- static int pkey_verifyprotkey(const struct pkey_protkey *protkey)
+ static int pkey_verifyprotkey(const u8 *protkey, u32 protkeylen,
+ 			      u32 protkeytype)
  {
 +	unsigned long fc;
  	struct {
  		u8 iv[AES_BLOCK_SIZE];
  		u8 key[MAXPROTKEYSIZE];
  	} param;
  	u8 null_msg[AES_BLOCK_SIZE];
  	u8 dest_buf[AES_BLOCK_SIZE];
++<<<<<<< HEAD
 +	unsigned int k;
++=======
+ 	unsigned int k, pkeylen;
+ 	unsigned long fc;
++>>>>>>> f370f45c6475 (s390/pkey: do not use struct pkey_protkey)
  
- 	switch (protkey->type) {
+ 	switch (protkeytype) {
  	case PKEY_KEYTYPE_AES_128:
+ 		pkeylen = 16 + AES_WK_VP_SIZE;
  		fc = CPACF_KMC_PAES_128;
  		break;
  	case PKEY_KEYTYPE_AES_192:
@@@ -391,11 -408,11 +413,11 @@@
   * Transform a non-CCA key token into a protected key
   */
  static int pkey_nonccatok2pkey(const u8 *key, u32 keylen,
- 			       struct pkey_protkey *protkey)
+ 			       u8 *protkey, u32 *protkeylen, u32 *protkeytype)
  {
 -	struct keytoken_header *hdr = (struct keytoken_header *)key;
 -	u8 *tmpbuf = NULL;
  	int rc = -EINVAL;
 +	u8 *tmpbuf = NULL;
 +	struct keytoken_header *hdr = (struct keytoken_header *)key;
  
  	switch (hdr->version) {
  	case TOKVER_PROTECTED_KEY: {
@@@ -516,10 -538,10 +543,10 @@@ static int pkey_ccainttok2pkey(const u
   * Transform a key blob (of any type) into a protected key
   */
  int pkey_keyblob2pkey(const u8 *key, u32 keylen,
- 		      struct pkey_protkey *protkey)
+ 		      u8 *protkey, u32 *protkeylen, u32 *protkeytype)
  {
 -	struct keytoken_header *hdr = (struct keytoken_header *)key;
  	int rc;
 +	struct keytoken_header *hdr = (struct keytoken_header *)key;
  
  	if (keylen < sizeof(struct keytoken_header)) {
  		DEBUG_ERR("%s invalid keylen %d\n", __func__, keylen);
@@@ -771,10 -795,10 +800,10 @@@ out
  
  static int pkey_keyblob2pkey2(const struct pkey_apqn *apqns, size_t nr_apqns,
  			      const u8 *key, size_t keylen,
- 			      struct pkey_protkey *pkey)
+ 			      u8 *protkey, u32 *protkeylen, u32 *protkeytype)
  {
 -	struct keytoken_header *hdr = (struct keytoken_header *)key;
  	int i, card, dom, rc;
 +	struct keytoken_header *hdr = (struct keytoken_header *)key;
  
  	/* check for at least one apqn given */
  	if (!apqns || !nr_apqns)
@@@ -1020,11 -1046,11 +1051,11 @@@ out
  }
  
  static int pkey_keyblob2pkey3(const struct pkey_apqn *apqns, size_t nr_apqns,
- 			      const u8 *key, size_t keylen, u32 *protkeytype,
- 			      u8 *protkey, u32 *protkeylen)
+ 			      const u8 *key, size_t keylen,
+ 			      u8 *protkey, u32 *protkeylen, u32 *protkeytype)
  {
 -	struct keytoken_header *hdr = (struct keytoken_header *)key;
  	int i, card, dom, rc;
 +	struct keytoken_header *hdr = (struct keytoken_header *)key;
  
  	/* check for at least one apqn given */
  	if (!apqns || !nr_apqns)
diff --git a/arch/s390/crypto/paes_s390.c b/arch/s390/crypto/paes_s390.c
index 6bbf576c7f9f..011e225d4a0e 100644
--- a/arch/s390/crypto/paes_s390.c
+++ b/arch/s390/crypto/paes_s390.c
@@ -5,7 +5,7 @@
  * s390 implementation of the AES Cipher Algorithm with protected keys.
  *
  * s390 Version:
- *   Copyright IBM Corp. 2017,2020
+ *   Copyright IBM Corp. 2017, 2023
  *   Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
  *		Harald Freudenberger <freude@de.ibm.com>
  */
@@ -131,7 +131,8 @@ static inline int __paes_keyblob2pkey(struct key_blob *kb,
 		if (i > 0 && ret == -EAGAIN && in_task())
 			if (msleep_interruptible(1000))
 				return -EINTR;
-		ret = pkey_keyblob2pkey(kb->key, kb->keylen, pk);
+		ret = pkey_keyblob2pkey(kb->key, kb->keylen,
+					pk->protkey, &pk->len, &pk->type);
 		if (ret == 0)
 			break;
 	}
@@ -144,6 +145,7 @@ static inline int __paes_convert_key(struct s390_paes_ctx *ctx)
 	int ret;
 	struct pkey_protkey pkey;
 
+	pkey.len = sizeof(pkey.protkey);
 	ret = __paes_keyblob2pkey(&ctx->kb, &pkey);
 	if (ret)
 		return ret;
@@ -452,6 +454,9 @@ static inline int __xts_paes_convert_key(struct s390_pxts_ctx *ctx)
 {
 	struct pkey_protkey pkey0, pkey1;
 
+	pkey0.len = sizeof(pkey0.protkey);
+	pkey1.len = sizeof(pkey1.protkey);
+
 	if (__paes_keyblob2pkey(&ctx->kb[0], &pkey0) ||
 	    __paes_keyblob2pkey(&ctx->kb[1], &pkey1))
 		return -EINVAL;
diff --git a/arch/s390/include/asm/pkey.h b/arch/s390/include/asm/pkey.h
index dd3d20c332ac..47d80a7451a6 100644
--- a/arch/s390/include/asm/pkey.h
+++ b/arch/s390/include/asm/pkey.h
@@ -2,7 +2,7 @@
 /*
  * Kernelspace interface to the pkey device driver
  *
- * Copyright IBM Corp. 2016,2019
+ * Copyright IBM Corp. 2016, 2023
  *
  * Author: Harald Freudenberger <freude@de.ibm.com>
  *
@@ -23,6 +23,6 @@
  * @return 0 on success, negative errno value on failure
  */
 int pkey_keyblob2pkey(const u8 *key, u32 keylen,
-		      struct pkey_protkey *protkey);
+		      u8 *protkey, u32 *protkeylen, u32 *protkeytype);
 
 #endif /* _KAPI_PKEY_H */
* Unmerged path drivers/s390/crypto/pkey_api.c
