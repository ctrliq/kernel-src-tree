md: factor out a helper to wake up md_thread directly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-516.el8
commit-author Yu Kuai <yukuai3@huawei.com>
commit e5e9b9cb71a09d86d5e8d147e6a6457e1f8887b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-516.el8/e5e9b9cb.failed

md_wakeup_thread() can't wakeup md_thread->tsk if md_thread->run is
still in progress, and in some cases md_thread->tsk need to be woke up
directly, like md_set_readonly() and do_md_stop().

Commit 9dfbdafda3b3 ("md: unlock mddev before reap sync_thread in
action_store") introduce a new scenario where unregister sync_thread is
not protected by 'reconfig_mutex', this can cause null-ptr-deference in
theroy:

t1: md_set_readonly		t2: action_store
				md_unregister_thread
				// 'reconfig_mutex' is not held
// 'reconfig_mutex' is held by caller
if (mddev->sync_thread)
				 thread = *threadp
				 *threadp = NULL
 wake_up_process(mddev->sync_thread->tsk)
 // null-ptr-deference

Fix this problem by factoring out a helper to wake up md_thread directly,
so that 'sync_thread' won't be accessed multiple times from the reader
side. This helper also prepare to protect md_thread with rcu.

Noted that later patches is going to fix that unregister sync_thread is
not protected by 'reconfig_mutex' from action_store().

	Signed-off-by: Yu Kuai <yukuai3@huawei.com>
	Signed-off-by: Song Liu <song@kernel.org>
Link: https://lore.kernel.org/r/20230523021017.3048783-2-yukuai1@huaweicloud.com
(cherry picked from commit e5e9b9cb71a09d86d5e8d147e6a6457e1f8887b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index fd28501ae1e0,9d54de3441ef..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -100,18 -91,8 +100,23 @@@ static struct workqueue_struct *md_rdev
  static int remove_and_add_spares(struct mddev *mddev,
  				 struct md_rdev *this);
  static void mddev_detach(struct mddev *mddev);
++<<<<<<< HEAD
 +
 +enum md_ro_state {
 +	MD_RDWR,
 +	MD_RDONLY,
 +	MD_AUTO_READ,
 +	MD_MAX_STATE
 +};
 +
 +static bool md_is_rdwr(struct mddev *mddev)
 +{
 +	return (mddev->ro == MD_RDWR);
 +}
++=======
+ static void export_rdev(struct md_rdev *rdev, struct mddev *mddev);
+ static void md_wakeup_thread_directly(struct md_thread *thread);
++>>>>>>> e5e9b9cb71a0 (md: factor out a helper to wake up md_thread directly)
  
  /*
   * Default number of read corrections we'll attempt on an rdev
* Unmerged path drivers/md/md.c
