md: export md_is_rdwr() and is_md_suspended()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-516.el8
commit-author Yu Kuai <yukuai3@huawei.com>
commit 431e61257d631157e1d374f1368febf37aa59f7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-516.el8/431e6125.failed

The two apis will be used later to fix a deadlock in raid456, there are
no functional changes.

	Signed-off-by: Yu Kuai <yukuai3@huawei.com>
	Signed-off-by: Song Liu <song@kernel.org>
Link: https://lore.kernel.org/r/20230512015610.821290-4-yukuai1@huaweicloud.com
(cherry picked from commit 431e61257d631157e1d374f1368febf37aa59f7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index b03358034212,fb060e381ae7..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -370,33 -348,6 +358,36 @@@ EXPORT_SYMBOL_GPL(md_new_event)
  static LIST_HEAD(all_mddevs);
  static DEFINE_SPINLOCK(all_mddevs_lock);
  
++<<<<<<< HEAD
 +static bool is_md_suspended(struct mddev *mddev)
 +{
 +	return percpu_ref_is_dying(&mddev->active_io);
 +}
 +
 +/*
 + * iterates through all used mddevs in the system.
 + * We take care to grab the all_mddevs_lock whenever navigating
 + * the list, and to always hold a refcount when unlocked.
 + * Any code which breaks out of this loop while own
 + * a reference to the current mddev and must mddev_put it.
 + */
 +#define for_each_mddev(_mddev,_tmp)					\
 +									\
 +	for (({ spin_lock(&all_mddevs_lock);				\
 +		_tmp = all_mddevs.next;					\
 +		_mddev = NULL;});					\
 +	     ({ if (_tmp != &all_mddevs)				\
 +			mddev_get(list_entry(_tmp, struct mddev, all_mddevs));\
 +		spin_unlock(&all_mddevs_lock);				\
 +		if (_mddev) mddev_put(_mddev);				\
 +		_mddev = list_entry(_tmp, struct mddev, all_mddevs);	\
 +		_tmp != &all_mddevs;});					\
 +	     ({ spin_lock(&all_mddevs_lock);				\
 +		_tmp = _tmp->next;})					\
 +		)
 +
++=======
++>>>>>>> 431e61257d63 (md: export md_is_rdwr() and is_md_suspended())
  /* Rather than calling directly into the personality make_request function,
   * IO requests come here first so that we can check if the device is
   * being suspended pending a reconfiguration.
* Unmerged path drivers/md/md.c
diff --git a/drivers/md/md.h b/drivers/md/md.h
index b13a74c1667d..45fbc78612b5 100644
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@ -560,6 +560,23 @@ enum recovery_flags {
 	MD_RESYNCING_REMOTE,	/* remote node is running resync thread */
 };
 
+enum md_ro_state {
+	MD_RDWR,
+	MD_RDONLY,
+	MD_AUTO_READ,
+	MD_MAX_STATE
+};
+
+static inline bool md_is_rdwr(struct mddev *mddev)
+{
+	return (mddev->ro == MD_RDWR);
+}
+
+static inline bool is_md_suspended(struct mddev *mddev)
+{
+	return percpu_ref_is_dying(&mddev->active_io);
+}
+
 static inline int __must_check mddev_lock(struct mddev *mddev)
 {
 	return mutex_lock_interruptible(&mddev->reconfig_mutex);
