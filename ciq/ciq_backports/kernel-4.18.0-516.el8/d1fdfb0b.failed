s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23]

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-516.el8
commit-author Holger Dengler <dengler@linux.ibm.com>
commit d1fdfb0b2f339cf882c0b5431084a1950b8b73b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-516.el8/d1fdfb0b.failed

Commit 'fa6999e326fe ("s390/pkey: support CCA and EP11 secure ECC
private keys")' introduced a new PKEY_TYPE_EP11_AES type for the
PKEY_KBLOB2PROTK2 and a new IOCTL, PKEY_KBLOB2PROTK3, which both
allows userspace to convert opaque securekey blobs of this type into
protectedkey blobs. Unfortunately, all PKEY_KBLOB2PROTK2 and
PKEY_KBLOB2PROTK3 IOCTL requests with this keyblobs of this type
return with an error (-EINVAL). Fix PKEY_TYPE_EP11_AES handling in
PKEY_KBLOB2PROTK2 and PKEY_KBLOB2PROTK3 IOCTLs, so that userspace can
convert PKEY_TYPE_EP11_AES keyblobs into protectedkey blobs.

Add a helper function to decode the start and size of the internal
header as well as start and size of the keyblob payload of an existing
keyblob. Also validate the length of header and keyblob, as well as
the keyblob magic.

Introduce another helper function, which handles a raw key wrapping
request and do the keyblob decoding in the calling function. Remove
all other header-related calculations.

Fixes: fa6999e326fe ("s390/pkey: support CCA and EP11 secure ECC private keys")
	Signed-off-by: Holger Dengler <dengler@linux.ibm.com>
	Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit d1fdfb0b2f339cf882c0b5431084a1950b8b73b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/pkey_api.c
#	drivers/s390/crypto/zcrypt_ep11misc.c
diff --cc drivers/s390/crypto/pkey_api.c
index e3e8504920c9,75d7f0d5f14e..000000000000
--- a/drivers/s390/crypto/pkey_api.c
+++ b/drivers/s390/crypto/pkey_api.c
@@@ -228,12 -288,12 +228,20 @@@ out
  /*
   * Find card and transform EP11 secure key into protected key.
   */
++<<<<<<< HEAD
 +static int pkey_ep11key2pkey(const u8 *key, struct pkey_protkey *pkey)
 +{
++=======
+ static int pkey_ep11key2pkey(const u8 *key, size_t keylen,
+ 			     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+ {
+ 	u32 nr_apqns, *apqns = NULL;
+ 	u16 card, dom;
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  	int i, rc;
 +	u16 card, dom;
 +	u32 nr_apqns, *apqns = NULL;
 +	struct ep11keyblob *kb = (struct ep11keyblob *)key;
  
  	zcrypt_wait_api_operational();
  
@@@ -247,9 -308,8 +256,14 @@@
  	for (rc = -ENODEV, i = 0; i < nr_apqns; i++) {
  		card = apqns[i] >> 16;
  		dom = apqns[i] & 0xFFFF;
++<<<<<<< HEAD
 +		pkey->len = sizeof(pkey->protkey);
 +		rc = ep11_kblob2protkey(card, dom, key, kb->head.len,
 +					pkey->protkey, &pkey->len, &pkey->type);
++=======
+ 		rc = ep11_kblob2protkey(card, dom, key, keylen,
+ 					protkey, protkeylen, protkeytype);
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  		if (rc == 0)
  			break;
  	}
@@@ -388,6 -450,111 +402,114 @@@ static int pkey_verifyprotkey(const str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Helper for pkey_nonccatok2pkey, handles aes clear key token */
+ static int nonccatokaes2pkey(const struct clearkeytoken *t,
+ 			     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+ {
+ 	size_t tmpbuflen = max_t(size_t, SECKEYBLOBSIZE, MAXEP11AESKEYBLOBSIZE);
+ 	u8 *tmpbuf = NULL;
+ 	u32 keysize;
+ 	int rc;
+ 
+ 	keysize = pkey_keytype_aes_to_size(t->keytype);
+ 	if (!keysize) {
+ 		DEBUG_ERR("%s unknown/unsupported keytype %u\n",
+ 			  __func__, t->keytype);
+ 		return -EINVAL;
+ 	}
+ 	if (t->len != keysize) {
+ 		DEBUG_ERR("%s non clear key aes token: invalid key len %u\n",
+ 			  __func__, t->len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* try direct way with the PCKMO instruction */
+ 	rc = pkey_clr2protkey(t->keytype, t->clearkey,
+ 			      protkey, protkeylen, protkeytype);
+ 	if (!rc)
+ 		goto out;
+ 
+ 	/* PCKMO failed, so try the CCA secure key way */
+ 	tmpbuf = kmalloc(tmpbuflen, GFP_ATOMIC);
+ 	if (!tmpbuf)
+ 		return -ENOMEM;
+ 	zcrypt_wait_api_operational();
+ 	rc = cca_clr2seckey(0xFFFF, 0xFFFF, t->keytype, t->clearkey, tmpbuf);
+ 	if (rc)
+ 		goto try_via_ep11;
+ 	rc = pkey_skey2pkey(tmpbuf,
+ 			    protkey, protkeylen, protkeytype);
+ 	if (!rc)
+ 		goto out;
+ 
+ try_via_ep11:
+ 	/* if the CCA way also failed, let's try via EP11 */
+ 	rc = pkey_clr2ep11key(t->clearkey, t->len,
+ 			      tmpbuf, &tmpbuflen);
+ 	if (rc)
+ 		goto failure;
+ 	rc = pkey_ep11key2pkey(tmpbuf, tmpbuflen,
+ 			       protkey, protkeylen, protkeytype);
+ 	if (!rc)
+ 		goto out;
+ 
+ failure:
+ 	DEBUG_ERR("%s unable to build protected key from clear", __func__);
+ 
+ out:
+ 	kfree(tmpbuf);
+ 	return rc;
+ }
+ 
+ /* Helper for pkey_nonccatok2pkey, handles ecc clear key token */
+ static int nonccatokecc2pkey(const struct clearkeytoken *t,
+ 			     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+ {
+ 	u32 keylen;
+ 	int rc;
+ 
+ 	switch (t->keytype) {
+ 	case PKEY_KEYTYPE_ECC_P256:
+ 		keylen = 32;
+ 		break;
+ 	case PKEY_KEYTYPE_ECC_P384:
+ 		keylen = 48;
+ 		break;
+ 	case PKEY_KEYTYPE_ECC_P521:
+ 		keylen = 80;
+ 		break;
+ 	case PKEY_KEYTYPE_ECC_ED25519:
+ 		keylen = 32;
+ 		break;
+ 	case PKEY_KEYTYPE_ECC_ED448:
+ 		keylen = 64;
+ 		break;
+ 	default:
+ 		DEBUG_ERR("%s unknown/unsupported keytype %u\n",
+ 			  __func__, t->keytype);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (t->len != keylen) {
+ 		DEBUG_ERR("%s non clear key ecc token: invalid key len %u\n",
+ 			  __func__, t->len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* only one path possible: via PCKMO instruction */
+ 	rc = pkey_clr2protkey(t->keytype, t->clearkey,
+ 			      protkey, protkeylen, protkeytype);
+ 	if (rc) {
+ 		DEBUG_ERR("%s unable to build protected key from clear",
+ 			  __func__);
+ 	}
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  /*
   * Transform a non-CCA key token into a protected key
   */
@@@ -465,7 -612,8 +587,12 @@@ static int pkey_nonccatok2pkey(const u
  		rc = ep11_check_aes_key(debug_info, 3, key, keylen, 1);
  		if (rc)
  			goto out;
++<<<<<<< HEAD
 +		rc = pkey_ep11key2pkey(key, protkey);
++=======
+ 		rc = pkey_ep11key2pkey(key, keylen,
+ 				       protkey, protkeylen, protkeytype);
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  		break;
  	}
  	case TOKVER_EP11_AES_WITH_HEADER:
@@@ -473,8 -621,8 +600,13 @@@
  		rc = ep11_check_aes_key_with_hdr(debug_info, 3, key, keylen, 1);
  		if (rc)
  			goto out;
++<<<<<<< HEAD
 +		rc = pkey_ep11key2pkey(key + sizeof(struct ep11kblob_header),
 +				       protkey);
++=======
+ 		rc = pkey_ep11key2pkey(key, keylen,
+ 				       protkey, protkeylen, protkeytype);
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  		break;
  	default:
  		DEBUG_ERR("%s unknown/unsupported non-CCA token version %d\n",
@@@ -809,12 -963,16 +941,14 @@@ static int pkey_keyblob2pkey2(const str
  		}
  	} else if (hdr->type == TOKTYPE_NON_CCA) {
  		if (hdr->version == TOKVER_EP11_AES) {
- 			if (keylen < sizeof(struct ep11keyblob))
- 				return -EINVAL;
  			if (ep11_check_aes_key(debug_info, 3, key, keylen, 1))
  				return -EINVAL;
+ 		} else if (hdr->version == TOKVER_EP11_AES_WITH_HEADER) {
+ 			if (ep11_check_aes_key_with_hdr(debug_info, 3,
+ 							key, keylen, 1))
+ 				return -EINVAL;
  		} else {
 -			return pkey_nonccatok2pkey(key, keylen,
 -						   protkey, protkeylen,
 -						   protkeytype);
 +			return pkey_nonccatok2pkey(key, keylen, pkey);
  		}
  	} else {
  		DEBUG_ERR("%s unknown/unsupported blob type %d\n",
@@@ -830,20 -988,17 +964,26 @@@
  		dom = apqns[i].domain;
  		if (hdr->type == TOKTYPE_CCA_INTERNAL &&
  		    hdr->version == TOKVER_CCA_AES) {
 -			rc = cca_sec2protkey(card, dom, key,
 -					     protkey, protkeylen, protkeytype);
 +			rc = cca_sec2protkey(card, dom, key, pkey->protkey,
 +					     &pkey->len, &pkey->type);
  		} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
  			   hdr->version == TOKVER_CCA_VLSC) {
 -			rc = cca_cipher2protkey(card, dom, key,
 -						protkey, protkeylen,
 -						protkeytype);
 +			rc = cca_cipher2protkey(card, dom, key, pkey->protkey,
 +						&pkey->len, &pkey->type);
  		} else {
++<<<<<<< HEAD
 +			/* EP11 AES secure key blob */
 +			struct ep11keyblob *kb = (struct ep11keyblob *)key;
 +
 +			pkey->len = sizeof(pkey->protkey);
 +			rc = ep11_kblob2protkey(card, dom, key, kb->head.len,
 +						pkey->protkey, &pkey->len,
 +						&pkey->type);
++=======
+ 			rc = ep11_kblob2protkey(card, dom, key, keylen,
+ 						protkey, protkeylen,
+ 						protkeytype);
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  		}
  		if (rc == 0)
  			break;
diff --cc drivers/s390/crypto/zcrypt_ep11misc.c
index 8deb0922aeec,669ad6f5d5b0..000000000000
--- a/drivers/s390/crypto/zcrypt_ep11misc.c
+++ b/drivers/s390/crypto/zcrypt_ep11misc.c
@@@ -113,6 -113,109 +113,112 @@@ static void __exit card_cache_free(void
  	spin_unlock_bh(&card_list_lock);
  }
  
++<<<<<<< HEAD
++=======
+ static int ep11_kb_split(const u8 *kb, size_t kblen, u32 kbver,
+ 			 struct ep11kblob_header **kbhdr, size_t *kbhdrsize,
+ 			 u8 **kbpl, size_t *kbplsize)
+ {
+ 	struct ep11kblob_header *hdr = NULL;
+ 	size_t hdrsize, plsize = 0;
+ 	int rc = -EINVAL;
+ 	u8 *pl = NULL;
+ 
+ 	if (kblen < sizeof(struct ep11kblob_header))
+ 		goto out;
+ 	hdr = (struct ep11kblob_header *)kb;
+ 
+ 	switch (kbver) {
+ 	case TOKVER_EP11_AES:
+ 		/* header overlays the payload */
+ 		hdrsize = 0;
+ 		break;
+ 	case TOKVER_EP11_ECC_WITH_HEADER:
+ 	case TOKVER_EP11_AES_WITH_HEADER:
+ 		/* payload starts after the header */
+ 		hdrsize = sizeof(struct ep11kblob_header);
+ 		break;
+ 	default:
+ 		goto out;
+ 	}
+ 
+ 	plsize = kblen - hdrsize;
+ 	pl = (u8 *)kb + hdrsize;
+ 
+ 	if (kbhdr)
+ 		*kbhdr = hdr;
+ 	if (kbhdrsize)
+ 		*kbhdrsize = hdrsize;
+ 	if (kbpl)
+ 		*kbpl = pl;
+ 	if (kbplsize)
+ 		*kbplsize = plsize;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static int ep11_kb_decode(const u8 *kb, size_t kblen,
+ 			  struct ep11kblob_header **kbhdr, size_t *kbhdrsize,
+ 			  struct ep11keyblob **kbpl, size_t *kbplsize)
+ {
+ 	struct ep11kblob_header *tmph, *hdr = NULL;
+ 	size_t hdrsize = 0, plsize = 0;
+ 	struct ep11keyblob *pl = NULL;
+ 	int rc = -EINVAL;
+ 	u8 *tmpp;
+ 
+ 	if (kblen < sizeof(struct ep11kblob_header))
+ 		goto out;
+ 	tmph = (struct ep11kblob_header *)kb;
+ 
+ 	if (tmph->type != TOKTYPE_NON_CCA &&
+ 	    tmph->len > kblen)
+ 		goto out;
+ 
+ 	if (ep11_kb_split(kb, kblen, tmph->version,
+ 			  &hdr, &hdrsize, &tmpp, &plsize))
+ 		goto out;
+ 
+ 	if (plsize < sizeof(struct ep11keyblob))
+ 		goto out;
+ 
+ 	if (!is_ep11_keyblob(tmpp))
+ 		goto out;
+ 
+ 	pl = (struct ep11keyblob *)tmpp;
+ 	plsize = hdr->len - hdrsize;
+ 
+ 	if (kbhdr)
+ 		*kbhdr = hdr;
+ 	if (kbhdrsize)
+ 		*kbhdrsize = hdrsize;
+ 	if (kbpl)
+ 		*kbpl = pl;
+ 	if (kbplsize)
+ 		*kbplsize = plsize;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ /*
+  * For valid ep11 keyblobs, returns a reference to the wrappingkey verification
+  * pattern. Otherwise NULL.
+  */
+ const u8 *ep11_kb_wkvp(const u8 *keyblob, size_t keybloblen)
+ {
+ 	struct ep11keyblob *kb;
+ 
+ 	if (ep11_kb_decode(keyblob, keybloblen, NULL, NULL, &kb, NULL))
+ 		return NULL;
+ 	return kb->wkvp;
+ }
+ EXPORT_SYMBOL(ep11_kb_wkvp);
+ 
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  /*
   * Simple check if the key blob is a valid EP11 AES key blob with header.
   */
@@@ -1128,20 -1262,10 +1234,21 @@@ static int _ep11_wrapkey(u16 card, u16 
  	struct ep11_cprb *req = NULL, *rep = NULL;
  	struct ep11_target_dev target;
  	struct ep11_urb *urb = NULL;
- 	struct ep11keyblob *kb;
  	size_t req_pl_size;
  	int api, rc = -ENOMEM;
- 	bool has_header = false;
  	u8 *p;
  
++<<<<<<< HEAD
 +	/* maybe the session field holds a header with key info */
 +	kb = (struct ep11keyblob *)key;
 +	if (kb->head.type == TOKTYPE_NON_CCA &&
 +	    kb->head.version == TOKVER_EP11_AES) {
 +		has_header = true;
 +		keysize = kb->head.len < keysize ? kb->head.len : keysize;
 +	}
 +
++=======
++>>>>>>> d1fdfb0b2f33 (s390/pkey: fix PKEY_TYPE_EP11_AES handling in PKEY_KBLOB2PROTK[23])
  	/* request cprb and payload */
  	req_pl_size = sizeof(struct wk_req_pl) + (iv ? 16 : 0)
  		+ ASN1TAGLEN(keysize) + 4;
@@@ -1307,33 -1424,19 +1410,19 @@@ int ep11_kblob2protkey(u16 card, u16 do
  		u32 pkeybitsize;
  		u64 pkeysize;
  		u8  res2[8];
 -		u8  pkey[];
 +		u8  pkey[0];
  	} __packed * wki;
- 	const u8 *key;
- 	struct ep11kblob_header *hdr;
+ 	u8 *wkbuf = NULL;
+ 	int rc = -EIO;
  
- 	/* key with or without header ? */
- 	hdr = (struct ep11kblob_header *)keyblob;
- 	if (hdr->type == TOKTYPE_NON_CCA &&
- 	    (hdr->version == TOKVER_EP11_AES_WITH_HEADER ||
- 	     hdr->version == TOKVER_EP11_ECC_WITH_HEADER) &&
- 	    is_ep11_keyblob(keyblob + sizeof(struct ep11kblob_header))) {
- 		/* EP11 AES or ECC key with header */
- 		key = keyblob + sizeof(struct ep11kblob_header);
- 		keylen = hdr->len - sizeof(struct ep11kblob_header);
- 	} else if (hdr->type == TOKTYPE_NON_CCA &&
- 		   hdr->version == TOKVER_EP11_AES &&
- 		   is_ep11_keyblob(keyblob)) {
- 		/* EP11 AES key (old style) */
- 		key = keyblob;
- 		keylen = hdr->len;
- 	} else if (is_ep11_keyblob(keyblob)) {
- 		/* raw EP11 key blob */
- 		key = keyblob;
- 		keylen = keybloblen;
- 	} else {
+ 	if (ep11_kb_decode((u8 *)keyblob, keybloblen, &hdr, NULL, &key, &keylen))
  		return -EINVAL;
+ 
+ 	if (hdr->version == TOKVER_EP11_AES) {
+ 		/* wipe overlayed header */
+ 		memset(hdr, 0, sizeof(*hdr));
  	}
+ 	/* !!! hdr is no longer a valid header !!! */
  
  	/* alloc temp working buffer */
  	wkbuflen = (keylen + AES_BLOCK_SIZE) & (~(AES_BLOCK_SIZE - 1));
* Unmerged path drivers/s390/crypto/pkey_api.c
* Unmerged path drivers/s390/crypto/zcrypt_ep11misc.c
diff --git a/drivers/s390/crypto/zcrypt_ep11misc.h b/drivers/s390/crypto/zcrypt_ep11misc.h
index df06f2ef79d2..58b1429cb8f3 100644
--- a/drivers/s390/crypto/zcrypt_ep11misc.h
+++ b/drivers/s390/crypto/zcrypt_ep11misc.h
@@ -48,6 +48,12 @@ static inline bool is_ep11_keyblob(const u8 *key)
 	return (kb->version == EP11_STRUCT_MAGIC);
 }
 
+/*
+ * For valid ep11 keyblobs, returns a reference to the wrappingkey verification
+ * pattern. Otherwise NULL.
+ */
+const u8 *ep11_kb_wkvp(const u8 *kblob, size_t kbloblen);
+
 /*
  * Simple check if the key blob is a valid EP11 AES key blob with header.
  * If checkcpacfexport is enabled, the key is also checked for the
