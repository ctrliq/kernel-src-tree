gfs2: do_xmote fixes

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 9947a06d29c0a30da88cdc6376ca5fd87083e130
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/9947a06d.failed

Function do_xmote() is called with the glock spinlock held.  Commit
86934198eefa added a 'goto skip_inval' statement at the beginning of the
function to further below where the glock spinlock is expected not to be
held anymore.  Then it added code there that requires the glock spinlock
to be held.  This doesn't make sense; fix this up by dropping and
retaking the spinlock where needed.

In addition, when ->lm_lock() returned an error, do_xmote() didn't fail
the locking operation, and simply left the glock hanging; fix that as
well.  (This is a much older error.)

Fixes: 86934198eefa ("gfs2: Clear flags when withdraw prevents xmote")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 9947a06d29c0a30da88cdc6376ca5fd87083e130)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 5dc035ea3dca,fa374617d2f1..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -787,8 -817,22 +793,27 @@@ skip_inval
  	    (target != LM_ST_UNLOCKED ||
  	     test_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags))) {
  		if (!is_system_glock(gl)) {
++<<<<<<< HEAD
 +			gfs2_glock_queue_work(gl, GL_GLOCK_DFT_HOLD);
 +			goto out;
++=======
+ 			handle_callback(gl, LM_ST_UNLOCKED, 0, false); /* sets demote */
+ 			/*
+ 			 * Ordinarily, we would call dlm and its callback would call
+ 			 * finish_xmote, which would call state_change() to the new state.
+ 			 * Since we withdrew, we won't call dlm, so call state_change
+ 			 * manually, but to the UNLOCKED state we desire.
+ 			 */
+ 			state_change(gl, LM_ST_UNLOCKED);
+ 			/*
+ 			 * We skip telling dlm to do the locking, so we won't get a
+ 			 * reply that would otherwise clear GLF_LOCK. So we clear it here.
+ 			 */
+ 			clear_bit(GLF_LOCK, &gl->gl_flags);
+ 			clear_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags);
+ 			__gfs2_glock_queue_work(gl, GL_GLOCK_DFT_HOLD);
+ 			return;
++>>>>>>> 9947a06d29c0 (gfs2: do_xmote fixes)
  		} else {
  			clear_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags);
  		}
@@@ -800,24 -846,22 +827,26 @@@
  		if (ret == -EINVAL && gl->gl_target == LM_ST_UNLOCKED &&
  		    target == LM_ST_UNLOCKED &&
  		    test_bit(DFL_UNMOUNT, &ls->ls_recover_flags)) {
- 			spin_lock(&gl->gl_lockref.lock);
- 			finish_xmote(gl, target);
- 			__gfs2_glock_queue_work(gl, 0);
- 			spin_unlock(&gl->gl_lockref.lock);
+ 			/*
+ 			 * The lockspace has been released and the lock has
+ 			 * been unlocked implicitly.
+ 			 */
  		} else if (ret) {
  			fs_err(sdp, "lm_lock ret %d\n", ret);
++<<<<<<< HEAD
 +			GLOCK_BUG_ON(gl, !gfs2_withdrawn(sdp));
++=======
+ 			target = gl->gl_state | LM_OUT_ERROR;
+ 		} else {
+ 			/* The operation will be completed asynchronously. */
+ 			return;
++>>>>>>> 9947a06d29c0 (gfs2: do_xmote fixes)
  		}
- 	} else { /* lock_nolock */
- 		spin_lock(&gl->gl_lockref.lock);
- 		finish_xmote(gl, target);
- 		__gfs2_glock_queue_work(gl, 0);
- 		spin_unlock(&gl->gl_lockref.lock);
  	}
- out:
- 	spin_lock(&gl->gl_lockref.lock);
+ 
+ 	/* Complete the operation now. */
+ 	finish_xmote(gl, target);
+ 	__gfs2_glock_queue_work(gl, 0);
  }
  
  /**
* Unmerged path fs/gfs2/glock.c
