gfs2: gfs2_evict_inode clarification

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 03ff3781bf6c149554d88e7b702a3abd5e400dc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/03ff3781.failed

When function evict_should_delete() returns SHOULD_DEFER_EVICTION, gh is
never initialized, but that isn't obvious; if it did initialize gh and
then return SHOULD_DEFER_EVICTION, gfs2_evict_inode() would fail to
release it.  To clarify the code, change gfs2_evict_inode() to always
check if gh needs to be released, no matter what evict_should_delete()
returns.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 03ff3781bf6c149554d88e7b702a3abd5e400dc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index ab6dba97d184,aadb83e38c17..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1531,18 -1498,15 +1532,17 @@@ static void gfs2_evict_inode(struct ino
  	if (!sdp->sd_jdesc)
  		goto out;
  
- 	gfs2_holder_mark_uninitialized(&gh);
  	behavior = evict_should_delete(inode, &gh);
 -	if (behavior == EVICT_SHOULD_DEFER_DELETE &&
 -	    !test_bit(SDF_KILL, &sdp->sd_flags)) {
 +	if (behavior == EVICT_SHOULD_DEFER_DELETE) {
  		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
  
 -		gfs2_glock_hold(io_gl);
 -		if (!gfs2_queue_verify_delete(io_gl, true))
 -			gfs2_glock_put(io_gl);
 -		goto out;
 +		if (io_gl) {
 +			gfs2_glock_hold(io_gl);
 +			if (!gfs2_queue_verify_delete(io_gl))
 +				gfs2_glock_put(io_gl);
 +			goto out;
 +		}
 +		behavior = EVICT_SHOULD_DELETE;
  	}
  	if (behavior == EVICT_SHOULD_DELETE)
  		ret = evict_unlinked_inode(inode);
@@@ -1555,9 -1519,8 +1555,12 @@@
  	if (ret && ret != GLR_TRYFAILED && ret != -EROFS)
  		fs_warn(sdp, "gfs2_evict_inode: %d\n", ret);
  out:
++<<<<<<< HEAD
 +	/* Case 3 starts here */
++=======
+ 	if (gfs2_holder_initialized(&gh))
+ 		gfs2_glock_dq_uninit(&gh);
++>>>>>>> 03ff3781bf6c (gfs2: gfs2_evict_inode clarification)
  	truncate_inode_pages_final(&inode->i_data);
  	if (ip->i_qadata)
  		gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);
* Unmerged path fs/gfs2/super.c
