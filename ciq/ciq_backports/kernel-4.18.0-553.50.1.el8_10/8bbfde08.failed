gfs2: Add GLF_PENDING_REPLY flag

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 8bbfde0875590b71f012bd8b0c9cb988c9a873b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/8bbfde08.failed

Introduce a new GLF_PENDING_REPLY flag to indicate that a reply from DLM
is expected.  Include that flag in glock dumps to show more clearly
what's going on.  (When the GLF_PENDING_REPLY flag is set, the GLF_LOCK
flag will also be set but the GLF_LOCK flag alone isn't sufficient to
tell that we are waiting for a DLM reply.)

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 8bbfde0875590b71f012bd8b0c9cb988c9a873b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 5dc035ea3dca,f6cf5cb8c022..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -794,30 -806,32 +794,42 @@@ skip_inval
  		}
  	}
  
++<<<<<<< HEAD
 +	if (sdp->sd_lockstruct.ls_ops->lm_lock)	{
 +		struct lm_lockstruct *ls = &sdp->sd_lockstruct;
++=======
+ 	if (ls->ls_ops->lm_lock) {
+ 		set_bit(GLF_PENDING_REPLY, &gl->gl_flags);
+ 		spin_unlock(&gl->gl_lockref.lock);
+ 		ret = ls->ls_ops->lm_lock(gl, target, lck_flags);
+ 		spin_lock(&gl->gl_lockref.lock);
++>>>>>>> 8bbfde087559 (gfs2: Add GLF_PENDING_REPLY flag)
  
 +		/* lock_dlm */
 +		ret = sdp->sd_lockstruct.ls_ops->lm_lock(gl, target, lck_flags);
  		if (ret == -EINVAL && gl->gl_target == LM_ST_UNLOCKED &&
  		    target == LM_ST_UNLOCKED &&
  		    test_bit(DFL_UNMOUNT, &ls->ls_recover_flags)) {
 -			/*
 -			 * The lockspace has been released and the lock has
 -			 * been unlocked implicitly.
 -			 */
 +			spin_lock(&gl->gl_lockref.lock);
 +			finish_xmote(gl, target);
 +			__gfs2_glock_queue_work(gl, 0);
 +			spin_unlock(&gl->gl_lockref.lock);
  		} else if (ret) {
  			fs_err(sdp, "lm_lock ret %d\n", ret);
 -			target = gl->gl_state | LM_OUT_ERROR;
 -		} else {
 -			/* The operation will be completed asynchronously. */
 -			return;
 +			GLOCK_BUG_ON(gl, !gfs2_withdrawn(sdp));
  		}
++<<<<<<< HEAD
 +	} else { /* lock_nolock */
 +		spin_lock(&gl->gl_lockref.lock);
 +		finish_xmote(gl, target);
 +		__gfs2_glock_queue_work(gl, 0);
 +		spin_unlock(&gl->gl_lockref.lock);
++=======
+ 		clear_bit(GLF_PENDING_REPLY, &gl->gl_flags);
++>>>>>>> 8bbfde087559 (gfs2: Add GLF_PENDING_REPLY flag)
  	}
 -
 -	/* Complete the operation now. */
 -	finish_xmote(gl, target);
 -	gfs2_glock_queue_work(gl, 0);
 +out:
 +	spin_lock(&gl->gl_lockref.lock);
  }
  
  /**
* Unmerged path fs/gfs2/glock.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d242e1596a57..c8654963a8f3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -334,6 +334,7 @@ enum {
 	GLF_UNLOCKED			= 16, /* Wait for glock to be unlocked */
 	GLF_TRY_TO_EVICT		= 17, /* iopen glocks only */
 	GLF_VERIFY_DELETE		= 18, /* iopen glocks only */
+	GLF_PENDING_REPLY		= 19,
 };
 
 struct gfs2_glock {
diff --git a/fs/gfs2/trace_gfs2.h b/fs/gfs2/trace_gfs2.h
index ac8ca485c46f..09121c2c198b 100644
--- a/fs/gfs2/trace_gfs2.h
+++ b/fs/gfs2/trace_gfs2.h
@@ -53,6 +53,7 @@
 	{(1UL << GLF_DIRTY),			"y" },		\
 	{(1UL << GLF_LFLUSH),			"f" },		\
 	{(1UL << GLF_INVALIDATE_IN_PROGRESS),	"i" },		\
+	{(1UL << GLF_PENDING_REPLY),		"R" },		\
 	{(1UL << GLF_HAVE_REPLY),		"r" },		\
 	{(1UL << GLF_INITIAL),			"a" },		\
 	{(1UL << GLF_HAVE_FROZEN_REPLY),	"F" },		\
