gfs2: Fix additional unlikely request cancelation race

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6cb3b1c2df87a8048ee1d54ec16d2e757af86c7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/6cb3b1c2.failed

In gfs2_glock_dq(), we must drop the glock spin lock before calling
->lm_cancel, but this means that in the meantime, the operation we are
trying to cancel could complete.  If the operation completes
unsuccessfully, another holder can end up at the head of the queue and
another ->lm_lock operation can get started.  In this case, we would end
up canceling that second operation by accident.

To prevent that, introduce a new GLF_CANCELING flag.  Set that flag in
gfs2_glock_dq() when trying to cancel an operation.  When seeing that
flag, finish_xmote() will then keep the GLF_LOCK flag set to prevent
other glock operations from taking place.  gfs2_glock_dq() then
completes the cancelation attempt by clearing GLF_LOCK and
GLF_CANCELING.

In addition, add a missing GLF_DEMOTE_IN_PROGRESS check in
gfs2_glock_dq() to make sure that we won't accidentally cancel a demote
request.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6cb3b1c2df87a8048ee1d54ec16d2e757af86c7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
#	fs/gfs2/incore.h
#	fs/gfs2/trace_gfs2.h
diff --cc fs/gfs2/glock.c
index e4c621a86fa8,ea98b8bc166a..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -1658,6 -1681,10 +1663,13 @@@ void gfs2_glock_dq(struct gfs2_holder *
  		gl->gl_name.ln_sbd->sd_lockstruct.ls_ops->lm_cancel(gl);
  		wait_on_bit(&gh->gh_iflags, HIF_WAIT, TASK_UNINTERRUPTIBLE);
  		spin_lock(&gl->gl_lockref.lock);
++<<<<<<< HEAD
++=======
+ 		clear_bit(GLF_CANCELING, &gl->gl_flags);
+ 		clear_bit(GLF_LOCK, &gl->gl_flags);
+ 		if (!gfs2_holder_queued(gh))
+ 			goto out;
++>>>>>>> 6cb3b1c2df87 (gfs2: Fix additional unlikely request cancelation race)
  	}
  
  	/*
@@@ -2333,6 -2357,10 +2345,13 @@@ static const char *gflags2str(char *buf
  		*p++ = 'e';
  	if (test_bit(GLF_VERIFY_DELETE, gflags))
  		*p++ = 'E';
++<<<<<<< HEAD
++=======
+ 	if (test_bit(GLF_DEFER_DELETE, gflags))
+ 		*p++ = 's';
+ 	if (test_bit(GLF_CANCELING, gflags))
+ 		*p++ = 'C';
++>>>>>>> 6cb3b1c2df87 (gfs2: Fix additional unlikely request cancelation race)
  	*p = 0;
  	return buf;
  }
diff --cc fs/gfs2/incore.h
index d242e1596a57,74abbd4970f8..000000000000
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@@ -334,6 -330,9 +334,12 @@@ enum 
  	GLF_UNLOCKED			= 16, /* Wait for glock to be unlocked */
  	GLF_TRY_TO_EVICT		= 17, /* iopen glocks only */
  	GLF_VERIFY_DELETE		= 18, /* iopen glocks only */
++<<<<<<< HEAD
++=======
+ 	GLF_PENDING_REPLY		= 19,
+ 	GLF_DEFER_DELETE		= 20, /* iopen glocks only */
+ 	GLF_CANCELING			= 21,
++>>>>>>> 6cb3b1c2df87 (gfs2: Fix additional unlikely request cancelation race)
  };
  
  struct gfs2_glock {
diff --cc fs/gfs2/trace_gfs2.h
index ac8ca485c46f,26036ffc3f33..000000000000
--- a/fs/gfs2/trace_gfs2.h
+++ b/fs/gfs2/trace_gfs2.h
@@@ -63,7 -64,9 +63,13 @@@
  	{(1UL << GLF_INSTANTIATE_NEEDED),	"n" },		\
  	{(1UL << GLF_INSTANTIATE_IN_PROG),	"N" },		\
  	{(1UL << GLF_TRY_TO_EVICT),		"e" },		\
++<<<<<<< HEAD
 +	{(1UL << GLF_VERIFY_DELETE),		"E" })
++=======
+ 	{(1UL << GLF_VERIFY_DELETE),		"E" },		\
+ 	{(1UL << GLF_DEFER_DELETE),		"s" },		\
+ 	{(1UL << GLF_CANCELING),		"C" })
++>>>>>>> 6cb3b1c2df87 (gfs2: Fix additional unlikely request cancelation race)
  
  #ifndef NUMPTY
  #define NUMPTY
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/incore.h
* Unmerged path fs/gfs2/trace_gfs2.h
