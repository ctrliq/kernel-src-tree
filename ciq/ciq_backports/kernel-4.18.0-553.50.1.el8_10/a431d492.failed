gfs2: Fix request cancelation bug

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit a431d49243a012738f132054b2303e0815663aac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/a431d492.failed

In finish_xmote(), when a locking request is canceled, the corresponding
holder is moved to the tail of the holders list instead of being
dequeued immediately.  When there is only a single holder, the canceled
locking request is then immediately repeated.  This makes no sense; it
looks like another remnant of LM_FLAG_PRIORITY support.

Instead, dequeue canceled holders and proceed with the next holder in
finish_xmote().  We can then easily detect in gfs2_glock_dq() when a
holder has been canceled.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit a431d49243a012738f132054b2303e0815663aac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index e4c621a86fa8,4d152e0e585c..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -616,15 -607,19 +616,24 @@@ static void finish_xmote(struct gfs2_gl
  		if (gh && (ret & LM_OUT_CANCELED))
  			gfs2_holder_wake(gh);
  		if (gh && !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags)) {
- 			/* move to back of queue and try next entry */
  			if (ret & LM_OUT_CANCELED) {
++<<<<<<< HEAD
 +				if ((gh->gh_flags & LM_FLAG_PRIORITY) == 0)
 +					list_move_tail(&gh->gh_list, &gl->gl_holders);
++=======
+ 				list_del_init(&gh->gh_list);
+ 				trace_gfs2_glock_queue(gh, 0);
+ 				gl->gl_target = gl->gl_state;
++>>>>>>> a431d49243a0 (gfs2: Fix request cancelation bug)
  				gh = find_first_waiter(gl);
- 				gl->gl_target = gh->gh_state;
- 				if (do_promote(gl))
- 					goto out;
- 				goto retry;
+ 				if (gh) {
+ 					gl->gl_target = gh->gh_state;
+ 					if (do_promote(gl))
+ 						goto out;
+ 					do_xmote(gl, gh, gl->gl_target);
+ 					return;
+ 				}
+ 				goto out;
  			}
  			/* Some error or failed "try lock" - report it */
  			if ((ret & LM_OUT_ERROR) ||
* Unmerged path fs/gfs2/glock.c
