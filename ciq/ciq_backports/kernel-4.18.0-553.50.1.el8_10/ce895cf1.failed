gfs2: Remove misleading comments in gfs2_evict_inode

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit ce895cf15ab60b93464ebbb515f2fc9e7a8cef9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/ce895cf1.failed

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit ce895cf15ab60b93464ebbb515f2fc9e7a8cef9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index ab6dba97d184,6d89d0ecec2a..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1517,51 -1572,131 +1517,100 @@@ static void gfs2_evict_inode(struct ino
  	struct gfs2_sbd *sdp = sb->s_fs_info;
  	struct gfs2_inode *ip = GFS2_I(inode);
  	struct gfs2_holder gh;
 -	struct address_space *metamapping;
 -	int error;
 -
 -	if (test_bit(GIF_FREE_VFS_INODE, &ip->i_flags)) {
 -		clear_inode(inode);
 -		return;
 -	}
 -
 -	if (inode->i_nlink || sb_rdonly(sb))
 -		goto out;
 -
 -	if (test_bit(GIF_ALLOC_FAILED, &ip->i_flags)) {
 -		BUG_ON(!gfs2_glock_is_locked_by_me(ip->i_gl));
 -		gfs2_holder_mark_uninitialized(&gh);
 -		goto alloc_failed;
 -	}
 -
 -	/* Deletes should never happen under memory pressure anymore.  */
 -	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
 -		goto out;
 +	enum evict_behavior behavior;
 +	int ret;
  
 -	/* Must not read inode block until block type has been verified */
 -	error = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, &gh);
 -	if (unlikely(error)) {
 -		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
 -		ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 -		gfs2_glock_dq_uninit(&ip->i_iopen_gh);
 +	if (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr)
  		goto out;
 -	}
 -
 -	error = gfs2_check_blk_type(sdp, ip->i_no_addr, GFS2_BLKST_UNLINKED);
 -	if (error)
 -		goto out_truncate;
 -
 -	if (test_bit(GIF_INVALID, &ip->i_flags)) {
 -		error = gfs2_inode_refresh(ip);
 -		if (error)
 -			goto out_truncate;
 -	}
  
  	/*
 -	 * The inode may have been recreated in the meantime.
 +	 * In case of an incomplete mount, gfs2_evict_inode() may be called for
 +	 * system files without having an active journal to write to.  In that
 +	 * case, skip the filesystem evict.
  	 */
 -	if (inode->i_nlink)
 -		goto out_truncate;
 +	if (!sdp->sd_jdesc)
 +		goto out;
  
 -alloc_failed:
 -	if (gfs2_holder_initialized(&ip->i_iopen_gh) &&
 -	    test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
 -		ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 -		gfs2_glock_dq_wait(&ip->i_iopen_gh);
 -		gfs2_holder_reinit(LM_ST_EXCLUSIVE, LM_FLAG_TRY_1CB | GL_NOCACHE,
 -				   &ip->i_iopen_gh);
 -		error = gfs2_glock_nq(&ip->i_iopen_gh);
 -		if (error)
 -			goto out_truncate;
 +	gfs2_holder_mark_uninitialized(&gh);
 +	behavior = evict_should_delete(inode, &gh);
 +	if (behavior == EVICT_SHOULD_DEFER_DELETE) {
 +		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
 +
 +		if (io_gl) {
 +			gfs2_glock_hold(io_gl);
 +			if (!gfs2_queue_verify_delete(io_gl))
 +				gfs2_glock_put(io_gl);
 +			goto out;
 +		}
 +		behavior = EVICT_SHOULD_DELETE;
  	}
 +	if (behavior == EVICT_SHOULD_DELETE)
 +		ret = evict_unlinked_inode(inode);
 +	else
 +		ret = evict_linked_inode(inode);
  
++<<<<<<< HEAD
++=======
+ 	if (S_ISDIR(inode->i_mode) &&
+ 	    (ip->i_diskflags & GFS2_DIF_EXHASH)) {
+ 		error = gfs2_dir_exhash_dealloc(ip);
+ 		if (error)
+ 			goto out_unlock;
+ 	}
+ 
+ 	if (ip->i_eattr) {
+ 		error = gfs2_ea_dealloc(ip);
+ 		if (error)
+ 			goto out_unlock;
+ 	}
+ 
+ 	if (!gfs2_is_stuffed(ip)) {
+ 		error = gfs2_file_dealloc(ip);
+ 		if (error)
+ 			goto out_unlock;
+ 	}
+ 
+ 	/* We're about to clear the bitmap for the dinode, but as soon as we
+ 	   do, gfs2_create_inode can create another inode at the same block
+ 	   location and try to set gl_object again. We clear gl_object here so
+ 	   that subsequent inode creates don't see an old gl_object. */
+ 	glock_clear_object(ip->i_gl, ip);
+ 	error = gfs2_dinode_dealloc(ip);
+ 	goto out_unlock;
+ 
+ out_truncate:
+ 	gfs2_log_flush(sdp, ip->i_gl, GFS2_LOG_HEAD_FLUSH_NORMAL |
+ 		       GFS2_LFC_EVICT_INODE);
+ 	metamapping = gfs2_glock2aspace(ip->i_gl);
+ 	if (test_bit(GLF_DIRTY, &ip->i_gl->gl_flags)) {
+ 		filemap_fdatawrite(metamapping);
+ 		filemap_fdatawait(metamapping);
+ 	}
+ 	write_inode_now(inode, 1);
+ 	gfs2_ail_flush(ip->i_gl, 0);
+ 
+ 	error = gfs2_trans_begin(sdp, 0, sdp->sd_jdesc->jd_blocks);
+ 	if (error)
+ 		goto out_unlock;
+ 	/* Needs to be done before glock release & also in a transaction */
+ 	truncate_inode_pages(&inode->i_data, 0);
+ 	truncate_inode_pages(metamapping, 0);
+ 	gfs2_trans_end(sdp);
+ 
+ out_unlock:
++>>>>>>> ce895cf15ab6 (gfs2: Remove misleading comments in gfs2_evict_inode)
  	if (gfs2_rs_active(&ip->i_res))
  		gfs2_rs_deltree(&ip->i_res);
  
 -	if (gfs2_holder_initialized(&ip->i_iopen_gh)) {
 -		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
 -		if (test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
 -			ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 -			gfs2_glock_dq(&ip->i_iopen_gh);
 -		}
 -		gfs2_holder_uninit(&ip->i_iopen_gh);
 -	}
 -	if (gfs2_holder_initialized(&gh)) {
 -		glock_clear_object(ip->i_gl, ip);
 +	if (gfs2_holder_initialized(&gh))
  		gfs2_glock_dq_uninit(&gh);
 -	}
 -	if (error && error != GLR_TRYFAILED && error != -EROFS)
 -		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
 +	if (ret && ret != GLR_TRYFAILED && ret != -EROFS)
 +		fs_warn(sdp, "gfs2_evict_inode: %d\n", ret);
  out:
- 	/* Case 3 starts here */
  	truncate_inode_pages_final(&inode->i_data);
 -	gfs2_rsqa_delete(ip, NULL);
 +	if (ip->i_qadata)
 +		gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);
 +	gfs2_rs_deltree(&ip->i_res);
  	gfs2_ordered_del_inode(ip);
  	clear_inode(inode);
  	gfs2_dir_hash_inval(ip);
* Unmerged path fs/gfs2/super.c
