gfs2: Prevent inode creation race (2)

jira LE-2815
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 9136cad723ec3e5ab5ca85a839f151abf1c9a106
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/9136cad7.failed

In gfs2_try_evict(), we try grabbing the inode to evict, we try to evict
it, and then we try grabbing it again to see if it still exists.  There
is no guarantee that we will end up with the same inode both times; the
inode validity check that commit ffd1cf0443a2 ("gfs2: Prevent inode
creation race") added to the first grab is actually needed both times.

(To avoid code duplication, add a grab_existing_inode() helper.)

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 9136cad723ec3e5ab5ca85a839f151abf1c9a106)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index e4c621a86fa8,3c26812b12a8..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -968,32 -1007,15 +987,25 @@@ static void gfs2_try_evict(struct gfs2_
  	 * happened below.  (Verification is triggered by the call to
  	 * gfs2_queue_verify_delete() in gfs2_evict_inode().)
  	 */
- 	spin_lock(&gl->gl_lockref.lock);
- 	ip = gl->gl_object;
- 	if (ip && !igrab(&ip->i_inode))
- 		ip = NULL;
- 	spin_unlock(&gl->gl_lockref.lock);
- 	if (ip) {
- 		wait_on_inode(&ip->i_inode);
- 		if (is_bad_inode(&ip->i_inode)) {
- 			iput(&ip->i_inode);
- 			ip = NULL;
- 		}
- 	}
+ 	ip = gfs2_grab_existing_inode(gl);
  	if (ip) {
 -		set_bit(GLF_DEFER_DELETE, &gl->gl_flags);
 +		set_bit(GIF_DEFER_DELETE, &ip->i_flags);
  		d_prune_aliases(&ip->i_inode);
  		iput(&ip->i_inode);
 -		clear_bit(GLF_DEFER_DELETE, &gl->gl_flags);
  
  		/* If the inode was evicted, gl->gl_object will now be NULL. */
++<<<<<<< HEAD
 +		spin_lock(&gl->gl_lockref.lock);
 +		ip = gl->gl_object;
 +		if (ip) {
 +			clear_bit(GIF_DEFER_DELETE, &ip->i_flags);
 +			if (!igrab(&ip->i_inode))
 +				ip = NULL;
 +		}
 +		spin_unlock(&gl->gl_lockref.lock);
++=======
+ 		ip = gfs2_grab_existing_inode(gl);
++>>>>>>> 9136cad723ec (gfs2: Prevent inode creation race (2))
  		if (ip) {
  			gfs2_glock_poke(ip->i_gl);
  			iput(&ip->i_inode);
* Unmerged path fs/gfs2/glock.c
