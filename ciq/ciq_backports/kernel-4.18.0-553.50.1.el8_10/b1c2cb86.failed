x86/xen: use new hypercall functions instead of hypercall page

jira LE-2815
cve CVE-2024-53241
Rebuild_History Non-Buildable kernel-4.18.0-553.50.1.el8_10
commit-author Juergen Gross <jgross@suse.com>
commit b1c2cb86f4a7861480ad54bb9a58df3cbebf8e92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.50.1.el8_10/b1c2cb86.failed

Call the Xen hypervisor via the new xen_hypercall_func static-call
instead of the hypercall page.

This is part of XSA-466 / CVE-2024-53241.

	Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
	Signed-off-by: Juergen Gross <jgross@suse.com>
Co-developed-by: Peter Zijlstra <peterz@infradead.org>
Co-developed-by: Josh Poimboeuf <jpoimboe@redhat.com>
(cherry picked from commit b1c2cb86f4a7861480ad54bb9a58df3cbebf8e92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/xen/hypercall.h
diff --cc arch/x86/include/asm/xen/hypercall.h
index dcf9353a662a,7d5f8ad66774..000000000000
--- a/arch/x86/include/asm/xen/hypercall.h
+++ b/arch/x86/include/asm/xen/hypercall.h
@@@ -38,11 -38,13 +38,17 @@@
  #include <linux/errno.h>
  #include <linux/string.h>
  #include <linux/types.h>
++<<<<<<< HEAD
++=======
+ #include <linux/pgtable.h>
+ #include <linux/instrumentation.h>
++>>>>>>> b1c2cb86f4a7 (x86/xen: use new hypercall functions instead of hypercall page)
  
  #include <trace/events/xen.h>
  
+ #include <asm/alternative.h>
  #include <asm/page.h>
 +#include <asm/pgtable.h>
  #include <asm/smap.h>
  #include <asm/nospec-branch.h>
  
@@@ -88,9 -90,20 +94,26 @@@ struct xen_dm_op_buf
  
  extern struct { char _entry[32]; } hypercall_page[];
  
++<<<<<<< HEAD
 +#define __HYPERCALL		"call hypercall_page+%c[offset]"
 +#define __HYPERCALL_ENTRY(x)						\
 +	[offset] "i" (__HYPERVISOR_##x * sizeof(hypercall_page[0]))
++=======
+ void xen_hypercall_func(void);
+ DECLARE_STATIC_CALL(xen_hypercall, xen_hypercall_func);
+ 
+ #ifdef MODULE
+ #define __ADDRESSABLE_xen_hypercall
+ #else
+ #define __ADDRESSABLE_xen_hypercall __ADDRESSABLE_ASM_STR(__SCK__xen_hypercall)
+ #endif
+ 
+ #define __HYPERCALL					\
+ 	__ADDRESSABLE_xen_hypercall			\
+ 	"call __SCT__xen_hypercall"
+ 
+ #define __HYPERCALL_ENTRY(x)	"a" (x)
++>>>>>>> b1c2cb86f4a7 (x86/xen: use new hypercall functions instead of hypercall page)
  
  #ifdef CONFIG_X86_32
  #define __HYPERCALL_RETREG	"eax"
@@@ -197,19 -210,41 +220,54 @@@
  	(type)__res;							\
  })
  
++<<<<<<< HEAD
 +#define _hypercall5(type, name, a1, a2, a3, a4, a5)			\
 +({									\
 +	__HYPERCALL_DECLS;						\
 +	__HYPERCALL_5ARG(a1, a2, a3, a4, a5);				\
 +	asm volatile (__HYPERCALL					\
 +		      : __HYPERCALL_5PARAM				\
 +		      : __HYPERCALL_ENTRY(name)				\
 +		      : __HYPERCALL_CLOBBER5);				\
 +	(type)__res;							\
 +})
++=======
+ static inline long
+ xen_single_call(unsigned int call,
+ 		unsigned long a1, unsigned long a2,
+ 		unsigned long a3, unsigned long a4,
+ 		unsigned long a5)
+ {
+ 	__HYPERCALL_DECLS;
+ 	__HYPERCALL_5ARG(a1, a2, a3, a4, a5);
+ 
+ 	asm volatile(__HYPERCALL
+ 		     : __HYPERCALL_5PARAM
+ 		     : __HYPERCALL_ENTRY(call)
+ 		     : __HYPERCALL_CLOBBER5);
+ 
+ 	return (long)__res;
+ }
+ 
+ static __always_inline void __xen_stac(void)
+ {
+ 	/*
+ 	 * Suppress objtool seeing the STAC/CLAC and getting confused about it
+ 	 * calling random code with AC=1.
+ 	 */
+ 	asm volatile(ANNOTATE_IGNORE_ALTERNATIVE
+ 		     ASM_STAC ::: "memory", "flags");
+ }
+ 
+ static __always_inline void __xen_clac(void)
+ {
+ 	asm volatile(ANNOTATE_IGNORE_ALTERNATIVE
+ 		     ASM_CLAC ::: "memory", "flags");
+ }
++>>>>>>> b1c2cb86f4a7 (x86/xen: use new hypercall functions instead of hypercall page)
  
  static inline long
 -privcmd_call(unsigned int call,
 +privcmd_call(unsigned call,
  	     unsigned long a1, unsigned long a2,
  	     unsigned long a3, unsigned long a4,
  	     unsigned long a5)
* Unmerged path arch/x86/include/asm/xen/hypercall.h
