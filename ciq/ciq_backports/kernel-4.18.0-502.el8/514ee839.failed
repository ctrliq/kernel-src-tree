x86/microcode/intel: Reuse microcode_sanity_check()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Jithu Joseph <jithu.joseph@intel.com>
commit 514ee839c6d0750c1c4456502e6fa08599e57931
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/514ee839.failed

IFS test image carries the same microcode header as regular Intel
microcode blobs.

Reuse microcode_sanity_check() in the IFS driver to perform sanity check
of the IFS test images too.

	Signed-off-by: Jithu Joseph <jithu.joseph@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Ashok Raj <ashok.raj@intel.com>
	Reviewed-by: Sohil Mehta <sohil.mehta@intel.com>
Link: https://lore.kernel.org/r/20221117035935.4136738-8-jithu.joseph@intel.com
(cherry picked from commit 514ee839c6d0750c1c4456502e6fa08599e57931)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpu.h
#	arch/x86/kernel/cpu/intel.c
diff --cc arch/x86/include/asm/cpu.h
index 21924730afae,9e3ac95acf2d..000000000000
--- a/arch/x86/include/asm/cpu.h
+++ b/arch/x86/include/asm/cpu.h
@@@ -73,4 -68,34 +73,37 @@@ static inline u8 get_this_hybrid_cpu_ty
  	return 0;
  }
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IA32_FEAT_CTL
+ void init_ia32_feat_ctl(struct cpuinfo_x86 *c);
+ #else
+ static inline void init_ia32_feat_ctl(struct cpuinfo_x86 *c) {}
+ #endif
+ 
+ extern __noendbr void cet_disable(void);
+ 
+ struct ucode_cpu_info;
+ 
+ int intel_cpu_collect_info(struct ucode_cpu_info *uci);
+ 
+ static inline bool intel_cpu_signatures_match(unsigned int s1, unsigned int p1,
+ 					      unsigned int s2, unsigned int p2)
+ {
+ 	if (s1 != s2)
+ 		return false;
+ 
+ 	/* Processor flags are either both 0 ... */
+ 	if (!p1 && !p2)
+ 		return true;
+ 
+ 	/* ... or they intersect. */
+ 	return p1 & p2;
+ }
+ 
+ extern u64 x86_read_arch_cap_msr(void);
+ int intel_find_matching_signature(void *mc, unsigned int csig, int cpf);
+ int intel_microcode_sanity_check(void *mc, bool print_err);
+ 
++>>>>>>> 514ee839c6d0 (x86/microcode/intel: Reuse microcode_sanity_check())
  #endif /* _ASM_X86_CPU_H */
diff --cc arch/x86/kernel/cpu/intel.c
index 9f6c1ec168fa,bef06a1fafe9..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -217,6 -184,165 +217,168 @@@ static bool bad_spectre_microcode(struc
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ int intel_cpu_collect_info(struct ucode_cpu_info *uci)
+ {
+ 	unsigned int val[2];
+ 	unsigned int family, model;
+ 	struct cpu_signature csig = { 0 };
+ 	unsigned int eax, ebx, ecx, edx;
+ 
+ 	memset(uci, 0, sizeof(*uci));
+ 
+ 	eax = 0x00000001;
+ 	ecx = 0;
+ 	native_cpuid(&eax, &ebx, &ecx, &edx);
+ 	csig.sig = eax;
+ 
+ 	family = x86_family(eax);
+ 	model  = x86_model(eax);
+ 
+ 	if (model >= 5 || family > 6) {
+ 		/* get processor flags from MSR 0x17 */
+ 		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);
+ 		csig.pf = 1 << ((val[1] >> 18) & 7);
+ 	}
+ 
+ 	csig.rev = intel_get_microcode_revision();
+ 
+ 	uci->cpu_sig = csig;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(intel_cpu_collect_info);
+ 
+ /*
+  * Returns 1 if update has been found, 0 otherwise.
+  */
+ int intel_find_matching_signature(void *mc, unsigned int csig, int cpf)
+ {
+ 	struct microcode_header_intel *mc_hdr = mc;
+ 	struct extended_sigtable *ext_hdr;
+ 	struct extended_signature *ext_sig;
+ 	int i;
+ 
+ 	if (intel_cpu_signatures_match(csig, cpf, mc_hdr->sig, mc_hdr->pf))
+ 		return 1;
+ 
+ 	/* Look for ext. headers: */
+ 	if (get_totalsize(mc_hdr) <= get_datasize(mc_hdr) + MC_HEADER_SIZE)
+ 		return 0;
+ 
+ 	ext_hdr = mc + get_datasize(mc_hdr) + MC_HEADER_SIZE;
+ 	ext_sig = (void *)ext_hdr + EXT_HEADER_SIZE;
+ 
+ 	for (i = 0; i < ext_hdr->count; i++) {
+ 		if (intel_cpu_signatures_match(csig, cpf, ext_sig->sig, ext_sig->pf))
+ 			return 1;
+ 		ext_sig++;
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(intel_find_matching_signature);
+ 
+ int intel_microcode_sanity_check(void *mc, bool print_err)
+ {
+ 	unsigned long total_size, data_size, ext_table_size;
+ 	struct microcode_header_intel *mc_header = mc;
+ 	struct extended_sigtable *ext_header = NULL;
+ 	u32 sum, orig_sum, ext_sigcount = 0, i;
+ 	struct extended_signature *ext_sig;
+ 
+ 	total_size = get_totalsize(mc_header);
+ 	data_size = get_datasize(mc_header);
+ 
+ 	if (data_size + MC_HEADER_SIZE > total_size) {
+ 		if (print_err)
+ 			pr_err("Error: bad microcode data file size.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mc_header->ldrver != 1 || mc_header->hdrver != 1) {
+ 		if (print_err)
+ 			pr_err("Error: invalid/unknown microcode update format.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ext_table_size = total_size - (MC_HEADER_SIZE + data_size);
+ 	if (ext_table_size) {
+ 		u32 ext_table_sum = 0;
+ 		u32 *ext_tablep;
+ 
+ 		if (ext_table_size < EXT_HEADER_SIZE ||
+ 		    ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {
+ 			if (print_err)
+ 				pr_err("Error: truncated extended signature table.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		ext_header = mc + MC_HEADER_SIZE + data_size;
+ 		if (ext_table_size != exttable_size(ext_header)) {
+ 			if (print_err)
+ 				pr_err("Error: extended signature table size mismatch.\n");
+ 			return -EFAULT;
+ 		}
+ 
+ 		ext_sigcount = ext_header->count;
+ 
+ 		/*
+ 		 * Check extended table checksum: the sum of all dwords that
+ 		 * comprise a valid table must be 0.
+ 		 */
+ 		ext_tablep = (u32 *)ext_header;
+ 
+ 		i = ext_table_size / sizeof(u32);
+ 		while (i--)
+ 			ext_table_sum += ext_tablep[i];
+ 
+ 		if (ext_table_sum) {
+ 			if (print_err)
+ 				pr_warn("Bad extended signature table checksum, aborting.\n");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Calculate the checksum of update data and header. The checksum of
+ 	 * valid update data and header including the extended signature table
+ 	 * must be 0.
+ 	 */
+ 	orig_sum = 0;
+ 	i = (MC_HEADER_SIZE + data_size) / sizeof(u32);
+ 	while (i--)
+ 		orig_sum += ((u32 *)mc)[i];
+ 
+ 	if (orig_sum) {
+ 		if (print_err)
+ 			pr_err("Bad microcode data checksum, aborting.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!ext_table_size)
+ 		return 0;
+ 
+ 	/*
+ 	 * Check extended signature checksum: 0 => valid.
+ 	 */
+ 	for (i = 0; i < ext_sigcount; i++) {
+ 		ext_sig = (void *)ext_header + EXT_HEADER_SIZE +
+ 			  EXT_SIGNATURE_SIZE * i;
+ 
+ 		sum = (mc_header->sig + mc_header->pf + mc_header->cksum) -
+ 		      (ext_sig->sig + ext_sig->pf + ext_sig->cksum);
+ 		if (sum) {
+ 			if (print_err)
+ 				pr_err("Bad extended signature checksum, aborting.\n");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(intel_microcode_sanity_check);
+ 
++>>>>>>> 514ee839c6d0 (x86/microcode/intel: Reuse microcode_sanity_check())
  static void early_init_intel(struct cpuinfo_x86 *c)
  {
  	u64 misc_enable;
* Unmerged path arch/x86/include/asm/cpu.h
* Unmerged path arch/x86/kernel/cpu/intel.c
diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c
index cdab3b93d858..0746a931367a 100644
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@ -177,104 +177,6 @@ static void save_microcode_patch(struct ucode_cpu_info *uci, void *data, unsigne
 		intel_ucode_patch = p->data;
 }
 
-static int microcode_sanity_check(void *mc, bool print_err)
-{
-	unsigned long total_size, data_size, ext_table_size;
-	struct microcode_header_intel *mc_header = mc;
-	struct extended_sigtable *ext_header = NULL;
-	u32 sum, orig_sum, ext_sigcount = 0, i;
-	struct extended_signature *ext_sig;
-
-	total_size = get_totalsize(mc_header);
-	data_size = get_datasize(mc_header);
-
-	if (data_size + MC_HEADER_SIZE > total_size) {
-		if (print_err)
-			pr_err("Error: bad microcode data file size.\n");
-		return -EINVAL;
-	}
-
-	if (mc_header->ldrver != 1 || mc_header->hdrver != 1) {
-		if (print_err)
-			pr_err("Error: invalid/unknown microcode update format.\n");
-		return -EINVAL;
-	}
-
-	ext_table_size = total_size - (MC_HEADER_SIZE + data_size);
-	if (ext_table_size) {
-		u32 ext_table_sum = 0;
-		u32 *ext_tablep;
-
-		if ((ext_table_size < EXT_HEADER_SIZE)
-		 || ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {
-			if (print_err)
-				pr_err("Error: truncated extended signature table.\n");
-			return -EINVAL;
-		}
-
-		ext_header = mc + MC_HEADER_SIZE + data_size;
-		if (ext_table_size != exttable_size(ext_header)) {
-			if (print_err)
-				pr_err("Error: extended signature table size mismatch.\n");
-			return -EFAULT;
-		}
-
-		ext_sigcount = ext_header->count;
-
-		/*
-		 * Check extended table checksum: the sum of all dwords that
-		 * comprise a valid table must be 0.
-		 */
-		ext_tablep = (u32 *)ext_header;
-
-		i = ext_table_size / sizeof(u32);
-		while (i--)
-			ext_table_sum += ext_tablep[i];
-
-		if (ext_table_sum) {
-			if (print_err)
-				pr_warn("Bad extended signature table checksum, aborting.\n");
-			return -EINVAL;
-		}
-	}
-
-	/*
-	 * Calculate the checksum of update data and header. The checksum of
-	 * valid update data and header including the extended signature table
-	 * must be 0.
-	 */
-	orig_sum = 0;
-	i = (MC_HEADER_SIZE + data_size) / sizeof(u32);
-	while (i--)
-		orig_sum += ((u32 *)mc)[i];
-
-	if (orig_sum) {
-		if (print_err)
-			pr_err("Bad microcode data checksum, aborting.\n");
-		return -EINVAL;
-	}
-
-	if (!ext_table_size)
-		return 0;
-
-	/*
-	 * Check extended signature checksum: 0 => valid.
-	 */
-	for (i = 0; i < ext_sigcount; i++) {
-		ext_sig = (void *)ext_header + EXT_HEADER_SIZE +
-			  EXT_SIGNATURE_SIZE * i;
-
-		sum = (mc_header->sig + mc_header->pf + mc_header->cksum) -
-		      (ext_sig->sig + ext_sig->pf + ext_sig->cksum);
-		if (sum) {
-			if (print_err)
-				pr_err("Bad extended signature checksum, aborting.\n");
-			return -EINVAL;
-		}
-	}
-	return 0;
-}
-
 /*
  * Get microcode matching with BSP's model. Only CPUs with the same model as
  * BSP can stay in the platform.
@@ -295,7 +197,7 @@ scan_microcode(void *data, size_t size, struct ucode_cpu_info *uci, bool save)
 		mc_size = get_totalsize(mc_header);
 		if (!mc_size ||
 		    mc_size > size ||
-		    microcode_sanity_check(data, false) < 0)
+		    intel_microcode_sanity_check(data, false) < 0)
 			break;
 
 		size -= mc_size;
@@ -858,7 +760,7 @@ static enum ucode_state generic_load_microcode(int cpu, struct iov_iter *iter)
 		memcpy(mc, &mc_header, sizeof(mc_header));
 		data = mc + sizeof(mc_header);
 		if (!copy_from_iter_full(data, data_size, iter) ||
-		    microcode_sanity_check(mc, true) < 0) {
+		    intel_microcode_sanity_check(mc, true) < 0) {
 			break;
 		}
 
