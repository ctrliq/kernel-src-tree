r8152: avoid to change cfg for all devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Hayes Wang <hayeswang@realtek.com>
commit 0d4cda805a183bbe523f2407edb5c14ade50b841
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/0d4cda80.failed

The rtl8152_cfgselector_probe() should set the USB configuration to the
vendor mode only for the devices which the driver (r8152) supports.
Otherwise, no driver would be used for such devices.

Fixes: ec51fbd1b8a2 ("r8152: add USB device driver for config selection")
	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0d4cda805a183bbe523f2407edb5c14ade50b841)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index 35e98590e253,4c5c1df5d7a4..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -6805,9 -9547,30 +6804,9 @@@ static u8 __rtl_get_hw_ver(struct usb_d
  	case 0x6010:
  		version = RTL_VER_09;
  		break;
 -	case 0x7010:
 -		version = RTL_TEST_01;
 -		break;
 -	case 0x7020:
 -		version = RTL_VER_10;
 -		break;
 -	case 0x7030:
 -		version = RTL_VER_11;
 -		break;
 -	case 0x7400:
 -		version = RTL_VER_12;
 -		break;
 -	case 0x7410:
 -		version = RTL_VER_13;
 -		break;
 -	case 0x6400:
 -		version = RTL_VER_14;
 -		break;
 -	case 0x7420:
 -		version = RTL_VER_15;
 -		break;
  	default:
  		version = RTL_VER_UNKNOWN;
- 		dev_info(&intf->dev, "Unknown version 0x%04x\n", ocp_data);
+ 		dev_info(&udev->dev, "Unknown version 0x%04x\n", ocp_data);
  		break;
  	}
  
@@@ -7060,7 -9873,67 +7068,71 @@@ static struct usb_driver rtl8152_drive
  	.disable_hub_initiated_lpm = 1,
  };
  
++<<<<<<< HEAD
 +module_usb_driver(rtl8152_driver);
++=======
+ static int rtl8152_cfgselector_probe(struct usb_device *udev)
+ {
+ 	struct usb_host_config *c;
+ 	int i, num_configs;
+ 
+ 	/* Switch the device to vendor mode, if and only if the vendor mode
+ 	 * driver supports it.
+ 	 */
+ 	if (__rtl_get_hw_ver(udev) == RTL_VER_UNKNOWN)
+ 		return 0;
+ 
+ 	/* The vendor mode is not always config #1, so to find it out. */
+ 	c = udev->config;
+ 	num_configs = udev->descriptor.bNumConfigurations;
+ 	for (i = 0; i < num_configs; (i++, c++)) {
+ 		struct usb_interface_descriptor	*desc = NULL;
+ 
+ 		if (!c->desc.bNumInterfaces)
+ 			continue;
+ 		desc = &c->intf_cache[0]->altsetting->desc;
+ 		if (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC)
+ 			break;
+ 	}
+ 
+ 	if (i == num_configs)
+ 		return -ENODEV;
+ 
+ 	if (usb_set_configuration(udev, c->desc.bConfigurationValue)) {
+ 		dev_err(&udev->dev, "Failed to set configuration %d\n",
+ 			c->desc.bConfigurationValue);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct usb_device_driver rtl8152_cfgselector_driver = {
+ 	.name =		MODULENAME "-cfgselector",
+ 	.probe =	rtl8152_cfgselector_probe,
+ 	.id_table =	rtl8152_table,
+ 	.generic_subclass = 1,
+ };
+ 
+ static int __init rtl8152_driver_init(void)
+ {
+ 	int ret;
+ 
+ 	ret = usb_register_device_driver(&rtl8152_cfgselector_driver, THIS_MODULE);
+ 	if (ret)
+ 		return ret;
+ 	return usb_register(&rtl8152_driver);
+ }
+ 
+ static void __exit rtl8152_driver_exit(void)
+ {
+ 	usb_deregister(&rtl8152_driver);
+ 	usb_deregister_device_driver(&rtl8152_cfgselector_driver);
+ }
+ 
+ module_init(rtl8152_driver_init);
+ module_exit(rtl8152_driver_exit);
++>>>>>>> 0d4cda805a18 (r8152: avoid to change cfg for all devices)
  
  MODULE_AUTHOR(DRIVER_AUTHOR);
  MODULE_DESCRIPTION(DRIVER_DESC);
* Unmerged path drivers/net/usb/r8152.c
