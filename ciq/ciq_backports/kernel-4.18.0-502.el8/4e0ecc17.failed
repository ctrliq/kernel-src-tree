net/mlx5e: Decouple fs_tt_redirect from en.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Lama Kayal <lkayal@nvidia.com>
commit 4e0ecc17a74ed41b8378d9515d4555cb7f3c0794
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/4e0ecc17.failed

Make flow steering files fs_tt_redirect.c/h independent of en.h
such that it goes through the flow steering API only.

Make error reports be via mlx5_core API instead of netdev_err API, this
to ensure a safe decoupling from en.h, and prevent redundant argument
passing.

	Signed-off-by: Lama Kayal <lkayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 4e0ecc17a74ed41b8378d9515d4555cb7f3c0794)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index e153d6119e02,db731019bb11..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@@ -78,6 -78,7 +78,10 @@@ mlx5e_fs_tt_redirect_udp_add_rule(struc
  				  enum mlx5_traffic_types ttc_type,
  				  u32 tir_num, u16 d_port)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	enum fs_udp_type type = tt2fs_udp(ttc_type);
  	struct mlx5_flow_destination dest = {};
  	struct mlx5_flow_table *ft = NULL;
@@@ -112,8 -111,10 +116,13 @@@
  	return rule;
  }
  
- static int fs_udp_add_default_rule(struct mlx5e_priv *priv, enum fs_udp_type type)
+ static int fs_udp_add_default_rule(struct mlx5e_flow_steering *fs, enum fs_udp_type type)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);
+ 	struct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5e_flow_table *fs_udp_t;
  	struct mlx5_flow_destination dest;
  	MLX5_DECLARE_FLOW_ACT(flow_act);
@@@ -206,12 -205,15 +215,19 @@@ out
  	return err;
  }
  
- static int fs_udp_create_table(struct mlx5e_priv *priv, enum fs_udp_type type)
+ static int fs_udp_create_table(struct mlx5e_flow_steering *fs, enum fs_udp_type type)
  {
++<<<<<<< HEAD
 +	struct mlx5e_flow_table *ft = &priv->fs->udp->tables[type];
++=======
+ 	struct mlx5_flow_namespace *ns = mlx5e_fs_get_ns(fs, false);
+ 	struct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5_flow_table_attr ft_attr = {};
+ 	struct mlx5e_flow_table *ft;
  	int err;
  
+ 	ft = &fs_udp->tables[type];
  	ft->num_groups = 0;
  
  	ft_attr.max_fte = MLX5E_FS_UDP_TABLE_SIZE;
@@@ -253,17 -255,18 +269,21 @@@ static void fs_udp_destroy_table(struc
  	fs_udp->tables[i].t = NULL;
  }
  
- static int fs_udp_disable(struct mlx5e_priv *priv)
+ static int fs_udp_disable(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	int err, i;
  
  	for (i = 0; i < FS_UDP_NUM_TYPES; i++) {
  		/* Modify ttc rules destination to point back to the indir TIRs */
 -		err = mlx5_ttc_fwd_default_dest(ttc, fs_udp2tt(i));
 +		err = mlx5_ttc_fwd_default_dest(priv->fs->ttc, fs_udp2tt(i));
  		if (err) {
- 			netdev_err(priv->netdev,
- 				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
- 				   __func__, fs_udp2tt(i), err);
+ 			mlx5_core_err(mlx5e_fs_get_mdev(fs),
+ 				      "%s: modify ttc[%d] default destination failed, err(%d)\n",
+ 				      __func__, fs_udp2tt(i), err);
  			return err;
  		}
  	}
@@@ -271,30 -274,32 +291,39 @@@
  	return 0;
  }
  
- static int fs_udp_enable(struct mlx5e_priv *priv)
+ static int fs_udp_enable(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);
+ 	struct mlx5e_fs_udp *udp = mlx5e_fs_get_udp(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5_flow_destination dest = {};
  	int err, i;
  
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
  	for (i = 0; i < FS_UDP_NUM_TYPES; i++) {
 -		dest.ft = udp->tables[i].t;
 +		dest.ft = priv->fs->udp->tables[i].t;
  
  		/* Modify ttc rules destination to point on the accel_fs FTs */
 -		err = mlx5_ttc_fwd_dest(ttc, fs_udp2tt(i), &dest);
 +		err = mlx5_ttc_fwd_dest(priv->fs->ttc, fs_udp2tt(i), &dest);
  		if (err) {
- 			netdev_err(priv->netdev,
- 				   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
- 				   __func__, fs_udp2tt(i), err);
+ 			mlx5_core_err(mlx5e_fs_get_mdev(fs),
+ 				      "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
+ 				      __func__, fs_udp2tt(i), err);
  			return err;
  		}
  	}
  	return 0;
  }
  
- void mlx5e_fs_tt_redirect_udp_destroy(struct mlx5e_priv *priv)
+ void mlx5e_fs_tt_redirect_udp_destroy(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	struct mlx5e_fs_udp *fs_udp = priv->fs->udp;
++=======
+ 	struct mlx5e_fs_udp *fs_udp = mlx5e_fs_get_udp(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	int i;
  
  	if (!fs_udp)
@@@ -309,24 -314,26 +338,36 @@@
  		fs_udp_destroy_table(fs_udp, i);
  
  	kfree(fs_udp);
++<<<<<<< HEAD
 +	priv->fs->udp = NULL;
++=======
+ 	mlx5e_fs_set_udp(fs, NULL);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  }
  
- int mlx5e_fs_tt_redirect_udp_create(struct mlx5e_priv *priv)
+ int mlx5e_fs_tt_redirect_udp_create(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_fs_udp *udp = mlx5e_fs_get_udp(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	int i, err;
  
 -	if (udp) {
 -		udp->ref_cnt++;
 +	if (priv->fs->udp) {
 +		priv->fs->udp->ref_cnt++;
  		return 0;
  	}
  
 -	udp = kzalloc(sizeof(*udp), GFP_KERNEL);
 -	if (!udp)
 +	priv->fs->udp = kzalloc(sizeof(*priv->fs->udp), GFP_KERNEL);
 +	if (!priv->fs->udp)
  		return -ENOMEM;
++<<<<<<< HEAD
++=======
+ 	mlx5e_fs_set_udp(fs, udp);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  
  	for (i = 0; i < FS_UDP_NUM_TYPES; i++) {
- 		err = fs_udp_create_table(priv, i);
+ 		err = fs_udp_create_table(fs, i);
  		if (err)
  			goto err_destroy_tables;
  	}
@@@ -341,10 -348,10 +382,15 @@@
  
  err_destroy_tables:
  	while (--i >= 0)
 -		fs_udp_destroy_table(udp, i);
 +		fs_udp_destroy_table(priv->fs->udp, i);
  
++<<<<<<< HEAD
 +	kfree(priv->fs->udp);
 +	priv->fs->udp = NULL;
++=======
+ 	kfree(udp);
+ 	mlx5e_fs_set_udp(fs, NULL);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	return err;
  }
  
@@@ -356,9 -363,10 +402,13 @@@ static void fs_any_set_ethertype_flow(s
  }
  
  struct mlx5_flow_handle *
- mlx5e_fs_tt_redirect_any_add_rule(struct mlx5e_priv *priv,
+ mlx5e_fs_tt_redirect_any_add_rule(struct mlx5e_flow_steering *fs,
  				  u32 tir_num, u16 ether_type)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5_flow_destination dest = {};
  	struct mlx5_flow_table *ft = NULL;
  	MLX5_DECLARE_FLOW_ACT(flow_act);
@@@ -389,8 -395,10 +439,13 @@@
  	return rule;
  }
  
- static int fs_any_add_default_rule(struct mlx5e_priv *priv)
+ static int fs_any_add_default_rule(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);
+ 	struct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5e_flow_table *fs_any_t;
  	struct mlx5_flow_destination dest;
  	MLX5_DECLARE_FLOW_ACT(flow_act);
@@@ -472,9 -477,11 +527,15 @@@ err
  	return err;
  }
  
- static int fs_any_create_table(struct mlx5e_priv *priv)
+ static int fs_any_create_table(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	struct mlx5e_flow_table *ft = &priv->fs->any->table;
++=======
+ 	struct mlx5_flow_namespace *ns = mlx5e_fs_get_ns(fs, false);
+ 	struct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);
+ 	struct mlx5e_flow_table *ft = &fs_any->table;
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5_flow_table_attr ft_attr = {};
  	int err;
  
@@@ -509,35 -516,38 +570,44 @@@ err
  	return err;
  }
  
- static int fs_any_disable(struct mlx5e_priv *priv)
+ static int fs_any_disable(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	int err;
  
  	/* Modify ttc rules destination to point back to the indir TIRs */
 -	err = mlx5_ttc_fwd_default_dest(ttc, MLX5_TT_ANY);
 +	err = mlx5_ttc_fwd_default_dest(priv->fs->ttc, MLX5_TT_ANY);
  	if (err) {
- 		netdev_err(priv->netdev,
- 			   "%s: modify ttc[%d] default destination failed, err(%d)\n",
- 			   __func__, MLX5_TT_ANY, err);
+ 		mlx5_core_err(mlx5e_fs_get_mdev(fs),
+ 			      "%s: modify ttc[%d] default destination failed, err(%d)\n",
+ 			      __func__, MLX5_TT_ANY, err);
  		return err;
  	}
  	return 0;
  }
  
- static int fs_any_enable(struct mlx5e_priv *priv)
+ static int fs_any_enable(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);
+ 	struct mlx5e_fs_any *any = mlx5e_fs_get_any(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5_flow_destination dest = {};
  	int err;
  
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
 -	dest.ft = any->table.t;
 +	dest.ft = priv->fs->any->table.t;
  
  	/* Modify ttc rules destination to point on the accel_fs FTs */
 -	err = mlx5_ttc_fwd_dest(ttc, MLX5_TT_ANY, &dest);
 +	err = mlx5_ttc_fwd_dest(priv->fs->ttc, MLX5_TT_ANY, &dest);
  	if (err) {
- 		netdev_err(priv->netdev,
- 			   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
- 			   __func__, MLX5_TT_ANY, err);
+ 		mlx5_core_err(mlx5e_fs_get_mdev(fs),
+ 			      "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
+ 			      __func__, MLX5_TT_ANY, err);
  		return err;
  	}
  	return 0;
@@@ -553,9 -563,9 +623,13 @@@ static void fs_any_destroy_table(struc
  	fs_any->table.t = NULL;
  }
  
- void mlx5e_fs_tt_redirect_any_destroy(struct mlx5e_priv *priv)
+ void mlx5e_fs_tt_redirect_any_destroy(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	struct mlx5e_fs_any *fs_any = priv->fs->any;
++=======
+ 	struct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  
  	if (!fs_any)
  		return;
@@@ -568,23 -578,25 +642,35 @@@
  	fs_any_destroy_table(fs_any);
  
  	kfree(fs_any);
++<<<<<<< HEAD
 +	priv->fs->any = NULL;
++=======
+ 	mlx5e_fs_set_any(fs, NULL);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  }
  
- int mlx5e_fs_tt_redirect_any_create(struct mlx5e_priv *priv)
+ int mlx5e_fs_tt_redirect_any_create(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_fs_any *fs_any = mlx5e_fs_get_any(fs);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	int err;
  
 -	if (fs_any) {
 -		fs_any->ref_cnt++;
 +	if (priv->fs->any) {
 +		priv->fs->any->ref_cnt++;
  		return 0;
  	}
  
 -	fs_any = kzalloc(sizeof(*fs_any), GFP_KERNEL);
 -	if (!fs_any)
 +	priv->fs->any = kzalloc(sizeof(*priv->fs->any), GFP_KERNEL);
 +	if (!priv->fs->any)
  		return -ENOMEM;
++<<<<<<< HEAD
++=======
+ 	mlx5e_fs_set_any(fs, fs_any);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  
- 	err = fs_any_create_table(priv);
+ 	err = fs_any_create_table(fs);
  	if (err)
  		return err;
  
@@@ -597,9 -609,9 +683,14 @@@
  	return 0;
  
  err_destroy_table:
 -	fs_any_destroy_table(fs_any);
 +	fs_any_destroy_table(priv->fs->any);
  
++<<<<<<< HEAD
 +	kfree(priv->fs->any);
 +	priv->fs->any = NULL;
++=======
+ 	kfree(fs_any);
+ 	mlx5e_fs_set_any(fs, NULL);
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	return err;
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
index 26d4c2a0b645,3fdaacc2abde..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
@@@ -624,8 -624,10 +624,14 @@@ static int mlx5e_ptp_set_state(struct m
  
  static void mlx5e_ptp_rx_unset_fs(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	struct mlx5e_ptp_fs *ptp_fs = priv->fs->ptp_fs;
++=======
+ 	struct mlx5e_flow_steering *fs = priv->fs;
+ 	struct mlx5e_ptp_fs *ptp_fs;
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  
+ 	ptp_fs = mlx5e_fs_get_ptp(fs);
  	if (!ptp_fs->valid)
  		return;
  
@@@ -641,10 -643,12 +647,16 @@@
  static int mlx5e_ptp_rx_set_fs(struct mlx5e_priv *priv)
  {
  	u32 tirn = mlx5e_rx_res_get_tirn_ptp(priv->rx_res);
++<<<<<<< HEAD
 +	struct mlx5e_ptp_fs *ptp_fs = priv->fs->ptp_fs;
++=======
+ 	struct mlx5e_flow_steering *fs = priv->fs;
++>>>>>>> 4e0ecc17a74e (net/mlx5e: Decouple fs_tt_redirect from en.h)
  	struct mlx5_flow_handle *rule;
+ 	struct mlx5e_ptp_fs *ptp_fs;
  	int err;
  
+ 	ptp_fs = mlx5e_fs_get_ptp(fs);
  	if (ptp_fs->valid)
  		return 0;
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 1098d4abbff9..21e1e38cc8b5 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -855,11 +855,6 @@ enum {
 	MLX5E_STATE_XDP_ACTIVE,
 };
 
-enum {
-	MLX5E_TC_PRIO = 0,
-	MLX5E_NIC_PRIO
-};
-
 struct mlx5e_modify_sq_param {
 	int curr_state;
 	int next_state;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 9b8cdf2e68ad..2caa566bc1bd 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@ -15,6 +15,11 @@ enum {
 	MLX5E_TC_MISS_LEVEL,
 };
 
+enum {
+	MLX5E_TC_PRIO = 0,
+	MLX5E_NIC_PRIO
+};
+
 struct mlx5e_flow_table {
 	int num_groups;
 	struct mlx5_flow_table *t;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h
index 7a70c4f38fda..5780fd7ad507 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h
@@ -4,23 +4,22 @@
 #ifndef __MLX5E_FS_TT_REDIRECT_H__
 #define __MLX5E_FS_TT_REDIRECT_H__
 
-#include "en.h"
 #include "en/fs.h"
 
 void mlx5e_fs_tt_redirect_del_rule(struct mlx5_flow_handle *rule);
 
 /* UDP traffic type redirect */
 struct mlx5_flow_handle *
-mlx5e_fs_tt_redirect_udp_add_rule(struct mlx5e_priv *priv,
+mlx5e_fs_tt_redirect_udp_add_rule(struct mlx5e_flow_steering *fs,
 				  enum mlx5_traffic_types ttc_type,
 				  u32 tir_num, u16 d_port);
-void mlx5e_fs_tt_redirect_udp_destroy(struct mlx5e_priv *priv);
-int mlx5e_fs_tt_redirect_udp_create(struct mlx5e_priv *priv);
+void mlx5e_fs_tt_redirect_udp_destroy(struct mlx5e_flow_steering *fs);
+int mlx5e_fs_tt_redirect_udp_create(struct mlx5e_flow_steering *fs);
 
 /* ANY traffic type redirect*/
 struct mlx5_flow_handle *
-mlx5e_fs_tt_redirect_any_add_rule(struct mlx5e_priv *priv,
+mlx5e_fs_tt_redirect_any_add_rule(struct mlx5e_flow_steering *fs,
 				  u32 tir_num, u16 ether_type);
-void mlx5e_fs_tt_redirect_any_destroy(struct mlx5e_priv *priv);
-int mlx5e_fs_tt_redirect_any_create(struct mlx5e_priv *priv);
+void mlx5e_fs_tt_redirect_any_destroy(struct mlx5e_flow_steering *fs);
+int mlx5e_fs_tt_redirect_any_create(struct mlx5e_flow_steering *fs);
 #endif
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
