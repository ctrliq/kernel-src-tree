net/smc: Register SMC-D as ISM client

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Stefan Raspl <raspl@linux.ibm.com>
commit 8747716f3942a610efdd12e3655df47269c268ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/8747716f.failed

Register the smc module with the new ism device driver API.
This is the second part of a bigger overhaul of the interfaces between SMC
and ISM.

	Signed-off-by: Stefan Raspl <raspl@linux.ibm.com>
	Signed-off-by: Jan Karcher <jaka@linux.ibm.com>
	Signed-off-by: Wenjia Zhang <wenjia@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8747716f3942a610efdd12e3655df47269c268ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/ism_drv.c
#	include/net/smc.h
#	net/smc/smc_ism.c
diff --cc drivers/s390/net/ism_drv.c
index f8a04d468283,f35c6077db04..000000000000
--- a/drivers/s390/net/ism_drv.c
+++ b/drivers/s390/net/ism_drv.c
@@@ -527,9 -620,27 +527,33 @@@ static int ism_dev_init(struct ism_dev 
  		/* hardware is V2 capable */
  		ism_create_system_eid();
  
++<<<<<<< HEAD
 +	ret = smcd_register_dev(ism->smcd);
 +	if (ret)
 +		goto unreg_ieq;
++=======
+ 	init_waitqueue_head(&ism->waitq);
+ 	atomic_set(&ism->free_clients_cnt, 0);
+ 	atomic_set(&ism->add_dev_cnt, 0);
+ 
+ 	wait_event(ism->waitq, !atomic_read(&ism->add_dev_cnt));
+ 	spin_lock_irqsave(&clients_lock, flags);
+ 	for (i = 0; i < max_client; ++i)
+ 		if (clients[i]) {
+ 			INIT_WORK(&clients[i]->add_work,
+ 				  ism_dev_add_work_func);
+ 			clients[i]->tgt_ism = ism;
+ 			atomic_inc(&ism->add_dev_cnt);
+ 			schedule_work(&clients[i]->add_work);
+ 		}
+ 	spin_unlock_irqrestore(&clients_lock, flags);
+ 
+ 	wait_event(ism->waitq, !atomic_read(&ism->add_dev_cnt));
+ 
+ 	mutex_lock(&ism_dev_list.mutex);
+ 	list_add(&ism->list, &ism_dev_list.list);
+ 	mutex_unlock(&ism_dev_list.mutex);
++>>>>>>> 8747716f3942 (net/smc: Register SMC-D as ISM client)
  
  	query_info(ism);
  	return 0;
@@@ -605,8 -716,34 +629,7 @@@ err
  static void ism_dev_exit(struct ism_dev *ism)
  {
  	struct pci_dev *pdev = ism->pdev;
 -	unsigned long flags;
 -	int i;
 -
 -	wait_event(ism->waitq, !atomic_read(&ism->free_clients_cnt));
 -	spin_lock_irqsave(&clients_lock, flags);
 -	for (i = 0; i < max_client; ++i)
 -		if (clients[i]) {
 -			INIT_WORK(&clients[i]->remove_work,
 -				  ism_dev_remove_work_func);
 -			clients[i]->tgt_ism = ism;
 -			atomic_inc(&ism->free_clients_cnt);
 -			schedule_work(&clients[i]->remove_work);
 -		}
 -	spin_unlock_irqrestore(&clients_lock, flags);
 -
 -	wait_event(ism->waitq, !atomic_read(&ism->free_clients_cnt));
  
- 	smcd_unregister_dev(ism->smcd);
  	if (SYSTEM_EID.serial_number[0] != '0' ||
  	    SYSTEM_EID.type[0] != '0')
  		ism_del_vlan_id(ism->smcd, ISM_RESERVED_VLANID);
diff --cc include/net/smc.h
index 421a7197b475,151aa54d9ad2..000000000000
--- a/include/net/smc.h
+++ b/include/net/smc.h
@@@ -90,9 -90,6 +90,11 @@@ struct smcd_dev 
  
  struct smcd_dev *smcd_alloc_dev(struct device *parent, const char *name,
  				const struct smcd_ops *ops, int max_dmbs);
- int smcd_register_dev(struct smcd_dev *smcd);
- void smcd_unregister_dev(struct smcd_dev *smcd);
  void smcd_free_dev(struct smcd_dev *smcd);
++<<<<<<< HEAD
 +void smcd_handle_event(struct smcd_dev *dev, struct smcd_event *event);
 +void smcd_handle_irq(struct smcd_dev *dev, unsigned int bit, u16 dmbemask);
++=======
+ 
++>>>>>>> 8747716f3942 (net/smc: Register SMC-D as ISM client)
  #endif	/* _SMC_H */
diff --cc net/smc/smc_ism.c
index 71e38768fea2,6d31e9bbc5f9..000000000000
--- a/net/smc/smc_ism.c
+++ b/net/smc/smc_ism.c
@@@ -489,8 -513,9 +512,13 @@@ static void smcd_unregister_dev(struct 
   * Context:
   * - Function called in IRQ context from ISM device driver event handler.
   */
++<<<<<<< HEAD
 +void smcd_handle_event(struct smcd_dev *smcd, struct smcd_event *event)
++=======
+ static void smcd_handle_event(struct ism_dev *ism, struct ism_event *event)
++>>>>>>> 8747716f3942 (net/smc: Register SMC-D as ISM client)
  {
+ 	struct smcd_dev *smcd = ism_get_priv(ism, &smc_ism_client);
  	struct smc_ism_event_work *wrk;
  
  	if (smcd->going_away)
* Unmerged path drivers/s390/net/ism_drv.c
* Unmerged path include/net/smc.h
diff --git a/net/smc/af_smc.c b/net/smc/af_smc.c
index 4d4f0b55a268..12243d5f2313 100644
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@ -3369,12 +3369,14 @@ static int __init smc_init(void)
 	if (rc)
 		goto out_pernet_subsys;
 
-	smc_ism_init();
+	rc = smc_ism_init();
+	if (rc)
+		goto out_pernet_subsys_stat;
 	smc_clc_init();
 
 	rc = smc_nl_init();
 	if (rc)
-		goto out_pernet_subsys_stat;
+		goto out_ism;
 
 	rc = smc_pnet_init();
 	if (rc)
@@ -3467,6 +3469,8 @@ static int __init smc_init(void)
 	smc_pnet_exit();
 out_nl:
 	smc_nl_exit();
+out_ism:
+	smc_ism_exit();
 out_pernet_subsys_stat:
 	unregister_pernet_subsys(&smc_net_stat_ops);
 out_pernet_subsys:
diff --git a/net/smc/smc_core.c b/net/smc/smc_core.c
index b8b18a172193..e93eda57ee31 100644
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@ -2594,6 +2594,7 @@ static int smc_core_reboot_event(struct notifier_block *this,
 {
 	smc_lgrs_shutdown();
 	smc_ib_unregister_client();
+	smc_ism_exit();
 	return 0;
 }
 
* Unmerged path net/smc/smc_ism.c
diff --git a/net/smc/smc_ism.h b/net/smc/smc_ism.h
index d6b2db604fe8..832b2f42d79f 100644
--- a/net/smc/smc_ism.h
+++ b/net/smc/smc_ism.h
@@ -42,7 +42,8 @@ int smc_ism_signal_shutdown(struct smc_link_group *lgr);
 void smc_ism_get_system_eid(u8 **eid);
 u16 smc_ism_get_chid(struct smcd_dev *dev);
 bool smc_ism_is_v2_capable(void);
-void smc_ism_init(void);
+int smc_ism_init(void);
+void smc_ism_exit(void);
 int smcd_nl_get_device(struct sk_buff *skb, struct netlink_callback *cb);
 
 static inline int smc_ism_write(struct smcd_dev *smcd, u64 dmb_tok,
