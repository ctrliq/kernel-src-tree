net/mlx5: E-Switch, Add default drop rule for unmatched packets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Jianbo Liu <jianbol@nvidia.com>
commit 8ea7bcf632181bee8fbe46a2507023c2defc05fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/8ea7bcf6.failed

The ft_offloads table serves to steer packets, which are from the
eswitch, to the representor associated with the packets' source vport.

Previously, if a packet's source vport or metadata was not associated
with any representor, it was forwarded to the uplink representor. The
representor got packets it shouldn't have as they weren't coming from
the uplink vport.

One such effect of this breakage can be observed if the uplink
representor is attached to a bridge, where such illegal packets will
be broadcast to the remaining ports, flooding the switch with illegal
packets. In the case where IB loopback (e.g, SNAP) is enabled, all
transmitted packets would be looped back, and received by the uplink
representor, and result in an infinite feedback loop.

Therefore, block this hole by adding a default drop rule to the
ft_offloads table, so that all unmatched packets with no associated
representor are dropped.

	Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
	Reviewed-by: Gavi Teitz <gavi@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 8ea7bcf632181bee8fbe46a2507023c2defc05fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 5cd63f395e7a,c2b1b2ff6846..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -2064,6 -2111,70 +2113,73 @@@ out
  	return flow_rule;
  }
  
++<<<<<<< HEAD
++=======
+ static int esw_create_vport_rx_drop_rule(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_flow_act flow_act = {};
+ 	struct mlx5_flow_handle *flow_rule;
+ 
+ 	flow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;
+ 	flow_rule = mlx5_add_flow_rules(esw->offloads.ft_offloads, NULL,
+ 					&flow_act, NULL, 0);
+ 	if (IS_ERR(flow_rule)) {
+ 		esw_warn(esw->dev,
+ 			 "fs offloads: Failed to add vport rx drop rule err %ld\n",
+ 			 PTR_ERR(flow_rule));
+ 		return PTR_ERR(flow_rule);
+ 	}
+ 
+ 	esw->offloads.vport_rx_drop_rule = flow_rule;
+ 
+ 	return 0;
+ }
+ 
+ static void esw_destroy_vport_rx_drop_rule(struct mlx5_eswitch *esw)
+ {
+ 	if (esw->offloads.vport_rx_drop_rule)
+ 		mlx5_del_flow_rules(esw->offloads.vport_rx_drop_rule);
+ }
+ 
+ static int mlx5_eswitch_inline_mode_get(struct mlx5_eswitch *esw, u8 *mode)
+ {
+ 	u8 prev_mlx5_mode, mlx5_mode = MLX5_INLINE_MODE_L2;
+ 	struct mlx5_core_dev *dev = esw->dev;
+ 	struct mlx5_vport *vport;
+ 	unsigned long i;
+ 
+ 	if (!MLX5_CAP_GEN(dev, vport_group_manager))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!mlx5_esw_is_fdb_created(esw))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (MLX5_CAP_ETH(dev, wqe_inline_mode)) {
+ 	case MLX5_CAP_INLINE_MODE_NOT_REQUIRED:
+ 		mlx5_mode = MLX5_INLINE_MODE_NONE;
+ 		goto out;
+ 	case MLX5_CAP_INLINE_MODE_L2:
+ 		mlx5_mode = MLX5_INLINE_MODE_L2;
+ 		goto out;
+ 	case MLX5_CAP_INLINE_MODE_VPORT_CONTEXT:
+ 		goto query_vports;
+ 	}
+ 
+ query_vports:
+ 	mlx5_query_nic_vport_min_inline(dev, esw->first_host_vport, &prev_mlx5_mode);
+ 	mlx5_esw_for_each_host_func_vport(esw, i, vport, esw->esw_funcs.num_vfs) {
+ 		mlx5_query_nic_vport_min_inline(dev, vport->vport, &mlx5_mode);
+ 		if (prev_mlx5_mode != mlx5_mode)
+ 			return -EINVAL;
+ 		prev_mlx5_mode = mlx5_mode;
+ 	}
+ 
+ out:
+ 	*mode = mlx5_mode;
+ 	return 0;
+ }
+ 
++>>>>>>> 8ea7bcf63218 (net/mlx5: E-Switch, Add default drop rule for unmatched packets)
  static void esw_destroy_restore_table(struct mlx5_eswitch *esw)
  {
  	struct mlx5_esw_offload *offloads = &esw->offloads;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index b53df6880313..afb3c510da9d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -244,6 +244,8 @@ struct mlx5_esw_offload {
 
 	struct mlx5_flow_table *ft_offloads;
 	struct mlx5_flow_group *vport_rx_group;
+	struct mlx5_flow_group *vport_rx_drop_group;
+	struct mlx5_flow_handle *vport_rx_drop_rule;
 	struct xarray vport_reps;
 	struct list_head peer_flows;
 	struct mutex peer_mutex;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
