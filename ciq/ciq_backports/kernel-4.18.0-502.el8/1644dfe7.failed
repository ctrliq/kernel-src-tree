x86/resctrl: Remove set_mba_sc()s control array re-initialisation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit 1644dfe727cb042ef7f2e773015747954fd0e746
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/1644dfe7.failed

set_mba_sc() enables the 'software controller' to regulate the bandwidth
based on the byte counters. This can be managed entirely in the parts
of resctrl that move to /fs/, without any extra support from the
architecture specific code. set_mba_sc() is called by rdt_enable_ctx()
during mount and unmount. It currently resets the arch code's ctrl_val[]
and mbps_val[] arrays.

The ctrl_val[] was already reset when the domain was created, and by
reset_all_ctrls() when the filesystem was last unmounted. Doing the work
in set_mba_sc() is not necessary as the values are already at their
defaults due to the creation of the domain, or were previously reset
during umount(), or are about to reset during umount().

Add a reset of the mbps_val[] in reset_all_ctrls(), allowing the code in
set_mba_sc() that reaches in to the architecture specific structures to
be removed.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <quic_jiles@quicinc.com>
	Reviewed-by: Shaopeng Tan <tan.shaopeng@fujitsu.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Xin Hao <xhao@linux.alibaba.com>
	Tested-by: Shaopeng Tan <tan.shaopeng@fujitsu.com>
	Tested-by: Cristian Marussi <cristian.marussi@arm.com>
Link: https://lore.kernel.org/r/20220902154829.30399-7-james.morse@arm.com
(cherry picked from commit 1644dfe727cb042ef7f2e773015747954fd0e746)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index a8731279ffbf,b32ceff8325a..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -1959,16 -1897,13 +1959,23 @@@ void rdt_domain_reconfigure_cdp(struct 
   */
  static int set_mba_sc(bool mba_sc)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r = &rdt_resources_all[RDT_RESOURCE_MBA];
 +	struct rdt_domain *d;
++=======
+ 	struct rdt_resource *r = &rdt_resources_all[RDT_RESOURCE_MBA].r_resctrl;
++>>>>>>> 1644dfe727cb (x86/resctrl: Remove set_mba_sc()s control array re-initialisation)
  
  	if (!is_mbm_enabled() || !is_mba_linear() ||
  	    mba_sc == is_mba_sc(r))
  		return -EINVAL;
  
  	r->membw.mba_sc = mba_sc;
++<<<<<<< HEAD
 +	list_for_each_entry(d, &r->domains, list)
 +		setup_default_ctrlval(r, d->ctrl_val, d->mbps_val);
++=======
++>>>>>>> 1644dfe727cb (x86/resctrl: Remove set_mba_sc()s control array re-initialisation)
  
  	return 0;
  }
@@@ -2302,10 -2318,13 +2309,17 @@@ static int reset_all_ctrls(struct rdt_r
  	 * from each domain to update the MSRs below.
  	 */
  	list_for_each_entry(d, &r->domains, list) {
 -		hw_dom = resctrl_to_arch_dom(d);
  		cpumask_set_cpu(cpumask_any(&d->cpu_mask), cpu_mask);
  
++<<<<<<< HEAD
 +		for (i = 0; i < r->num_closid; i++)
 +			d->ctrl_val[i] = r->default_ctrl;
++=======
+ 		for (i = 0; i < hw_res->num_closid; i++) {
+ 			hw_dom->ctrl_val[i] = r->default_ctrl;
+ 			hw_dom->mbps_val[i] = MBA_MAX_MBPS;
+ 		}
++>>>>>>> 1644dfe727cb (x86/resctrl: Remove set_mba_sc()s control array re-initialisation)
  	}
  	cpu = get_cpu();
  	/* Update CBM on this cpu if it's in cpu_mask. */
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
