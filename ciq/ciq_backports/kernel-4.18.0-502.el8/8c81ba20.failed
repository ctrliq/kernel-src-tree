net/smc: De-tangle ism and smc device initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Stefan Raspl <raspl@linux.ibm.com>
commit 8c81ba20349daf9f7e58bb05a0c12f4b71813a30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/8c81ba20.failed

The struct device for ISM devices was part of struct smcd_dev. Move to
struct ism_dev, provide a new API call in struct smcd_ops, and convert
existing SMCD code accordingly.
Furthermore, remove struct smcd_dev from struct ism_dev.
This is the final part of a bigger overhaul of the interfaces between SMC
and ISM.

	Signed-off-by: Stefan Raspl <raspl@linux.ibm.com>
	Signed-off-by: Jan Karcher <jaka@linux.ibm.com>
	Signed-off-by: Wenjia Zhang <wenjia@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8c81ba20349daf9f7e58bb05a0c12f4b71813a30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/ism_drv.c
#	include/linux/ism.h
#	include/net/smc.h
#	net/smc/smc_ism.c
diff --cc drivers/s390/net/ism_drv.c
index f8a04d468283,eb7e13486087..000000000000
--- a/drivers/s390/net/ism_drv.c
+++ b/drivers/s390/net/ism_drv.c
@@@ -620,9 -735,10 +619,8 @@@ static void ism_remove(struct pci_dev *
  {
  	struct ism_dev *ism = dev_get_drvdata(&pdev->dev);
  
 -	mutex_lock(&ism_dev_list.mutex);
  	ism_dev_exit(ism);
 -	mutex_unlock(&ism_dev_list.mutex);
  
- 	smcd_free_dev(ism->smcd);
  	pci_clear_master(pdev);
  	pci_release_mem_regions(pdev);
  	pci_disable_device(pdev);
@@@ -681,3 -788,96 +679,99 @@@ static void __exit ism_exit(void
  
  module_init(ism_init);
  module_exit(ism_exit);
++<<<<<<< HEAD
++=======
+ 
+ /*************************** SMC-D Implementation *****************************/
+ 
+ #if IS_ENABLED(CONFIG_SMC)
+ static int smcd_query_rgid(struct smcd_dev *smcd, u64 rgid, u32 vid_valid,
+ 			   u32 vid)
+ {
+ 	return ism_query_rgid(smcd->priv, rgid, vid_valid, vid);
+ }
+ 
+ static int smcd_register_dmb(struct smcd_dev *smcd, struct smcd_dmb *dmb,
+ 			     struct ism_client *client)
+ {
+ 	return ism_register_dmb(smcd->priv, (struct ism_dmb *)dmb, client);
+ }
+ 
+ static int smcd_unregister_dmb(struct smcd_dev *smcd, struct smcd_dmb *dmb)
+ {
+ 	return ism_unregister_dmb(smcd->priv, (struct ism_dmb *)dmb);
+ }
+ 
+ static int smcd_add_vlan_id(struct smcd_dev *smcd, u64 vlan_id)
+ {
+ 	return ism_add_vlan_id(smcd->priv, vlan_id);
+ }
+ 
+ static int smcd_del_vlan_id(struct smcd_dev *smcd, u64 vlan_id)
+ {
+ 	return ism_del_vlan_id(smcd->priv, vlan_id);
+ }
+ 
+ static int smcd_set_vlan_required(struct smcd_dev *smcd)
+ {
+ 	return ism_cmd_simple(smcd->priv, ISM_SET_VLAN);
+ }
+ 
+ static int smcd_reset_vlan_required(struct smcd_dev *smcd)
+ {
+ 	return ism_cmd_simple(smcd->priv, ISM_RESET_VLAN);
+ }
+ 
+ static int smcd_signal_ieq(struct smcd_dev *smcd, u64 rgid, u32 trigger_irq,
+ 			   u32 event_code, u64 info)
+ {
+ 	return ism_signal_ieq(smcd->priv, rgid, trigger_irq, event_code, info);
+ }
+ 
+ static int smcd_move(struct smcd_dev *smcd, u64 dmb_tok, unsigned int idx,
+ 		     bool sf, unsigned int offset, void *data,
+ 		     unsigned int size)
+ {
+ 	return ism_move(smcd->priv, dmb_tok, idx, sf, offset, data, size);
+ }
+ 
+ static u64 smcd_get_local_gid(struct smcd_dev *smcd)
+ {
+ 	return ism_get_local_gid(smcd->priv);
+ }
+ 
+ static u16 smcd_get_chid(struct smcd_dev *smcd)
+ {
+ 	return ism_get_chid(smcd->priv);
+ }
+ 
+ static inline struct device *smcd_get_dev(struct smcd_dev *dev)
+ {
+ 	struct ism_dev *ism = dev->priv;
+ 
+ 	return &ism->dev;
+ }
+ 
+ static const struct smcd_ops ism_ops = {
+ 	.query_remote_gid = smcd_query_rgid,
+ 	.register_dmb = smcd_register_dmb,
+ 	.unregister_dmb = smcd_unregister_dmb,
+ 	.add_vlan_id = smcd_add_vlan_id,
+ 	.del_vlan_id = smcd_del_vlan_id,
+ 	.set_vlan_required = smcd_set_vlan_required,
+ 	.reset_vlan_required = smcd_reset_vlan_required,
+ 	.signal_event = smcd_signal_ieq,
+ 	.move_data = smcd_move,
+ 	.get_system_eid = ism_get_seid,
+ 	.get_local_gid = smcd_get_local_gid,
+ 	.get_chid = smcd_get_chid,
+ 	.get_dev = smcd_get_dev,
+ };
+ 
+ const struct smcd_ops *ism_get_smcd_ops(void)
+ {
+ 	return &ism_ops;
+ }
+ EXPORT_SYMBOL_GPL(ism_get_smcd_ops);
+ #endif
++>>>>>>> 8c81ba20349d (net/smc: De-tangle ism and smc device initialization)
diff --cc include/linux/ism.h
index 69bfbf0faaa1,ea2bcdae7401..000000000000
--- a/include/linux/ism.h
+++ b/include/linux/ism.h
@@@ -20,4 -22,77 +20,80 @@@ struct ism_dmb 
  	dma_addr_t dma_addr;
  };
  
++<<<<<<< HEAD
++=======
+ /* Unless we gain unexpected popularity, this limit should hold for a while */
+ #define MAX_CLIENTS		8
+ #define ISM_NR_DMBS		1920
+ 
+ struct ism_dev {
+ 	spinlock_t lock; /* protects the ism device */
+ 	struct list_head list;
+ 	struct pci_dev *pdev;
+ 
+ 	struct ism_sba *sba;
+ 	dma_addr_t sba_dma_addr;
+ 	DECLARE_BITMAP(sba_bitmap, ISM_NR_DMBS);
+ 	u8 *sba_client_arr;	/* entries are indices into 'clients' array */
+ 	void *priv[MAX_CLIENTS];
+ 
+ 	struct ism_eq *ieq;
+ 	dma_addr_t ieq_dma_addr;
+ 
+ 	struct device dev;
+ 	u64 local_gid;
+ 	int ieq_idx;
+ 
+ 	atomic_t free_clients_cnt;
+ 	atomic_t add_dev_cnt;
+ 	wait_queue_head_t waitq;
+ };
+ 
+ struct ism_event {
+ 	u32 type;
+ 	u32 code;
+ 	u64 tok;
+ 	u64 time;
+ 	u64 info;
+ };
+ 
+ struct ism_client {
+ 	const char *name;
+ 	void (*add)(struct ism_dev *dev);
+ 	void (*remove)(struct ism_dev *dev);
+ 	void (*handle_event)(struct ism_dev *dev, struct ism_event *event);
+ 	/* Parameter dmbemask contains a bit vector with updated DMBEs, if sent
+ 	 * via ism_move_data(). Callback function must handle all active bits
+ 	 * indicated by dmbemask.
+ 	 */
+ 	void (*handle_irq)(struct ism_dev *dev, unsigned int bit, u16 dmbemask);
+ 	/* Private area - don't touch! */
+ 	struct work_struct remove_work;
+ 	struct work_struct add_work;
+ 	struct ism_dev *tgt_ism;
+ 	u8 id;
+ };
+ 
+ int ism_register_client(struct ism_client *client);
+ int  ism_unregister_client(struct ism_client *client);
+ static inline void *ism_get_priv(struct ism_dev *dev,
+ 				 struct ism_client *client) {
+ 	return dev->priv[client->id];
+ }
+ 
+ static inline void ism_set_priv(struct ism_dev *dev, struct ism_client *client,
+ 				void *priv) {
+ 	dev->priv[client->id] = priv;
+ }
+ 
+ int  ism_register_dmb(struct ism_dev *dev, struct ism_dmb *dmb,
+ 		      struct ism_client *client);
+ int  ism_unregister_dmb(struct ism_dev *dev, struct ism_dmb *dmb);
+ int  ism_move(struct ism_dev *dev, u64 dmb_tok, unsigned int idx, bool sf,
+ 	      unsigned int offset, void *data, unsigned int size);
+ u8  *ism_get_seid(void);
+ 
+ const struct smcd_ops *ism_get_smcd_ops(void);
+ 
++>>>>>>> 8c81ba20349d (net/smc: De-tangle ism and smc device initialization)
  #endif	/* _ISM_H */
diff --cc include/net/smc.h
index 421a7197b475,597cb9381182..000000000000
--- a/include/net/smc.h
+++ b/include/net/smc.h
@@@ -66,14 -68,14 +66,14 @@@ struct smcd_ops 
  			 bool sf, unsigned int offset, void *data,
  			 unsigned int size);
  	u8* (*get_system_eid)(void);
 -	u64 (*get_local_gid)(struct smcd_dev *dev);
  	u16 (*get_chid)(struct smcd_dev *dev);
+ 	struct device* (*get_dev)(struct smcd_dev *dev);
  };
  
  struct smcd_dev {
  	const struct smcd_ops *ops;
- 	struct device dev;
  	void *priv;
 +	u64 local_gid;
  	struct list_head list;
  	spinlock_t lock;
  	struct smc_connection **conn;
@@@ -88,11 -90,4 +88,14 @@@
  	u8 going_away : 1;
  };
  
++<<<<<<< HEAD
 +struct smcd_dev *smcd_alloc_dev(struct device *parent, const char *name,
 +				const struct smcd_ops *ops, int max_dmbs);
 +int smcd_register_dev(struct smcd_dev *smcd);
 +void smcd_unregister_dev(struct smcd_dev *smcd);
 +void smcd_free_dev(struct smcd_dev *smcd);
 +void smcd_handle_event(struct smcd_dev *dev, struct smcd_event *event);
 +void smcd_handle_irq(struct smcd_dev *dev, unsigned int bit, u16 dmbemask);
++=======
++>>>>>>> 8c81ba20349d (net/smc: De-tangle ism and smc device initialization)
  #endif	/* _SMC_H */
diff --cc net/smc/smc_ism.c
index 71e38768fea2,3b0b7710c6b0..000000000000
--- a/net/smc/smc_ism.c
+++ b/net/smc/smc_ism.c
@@@ -396,20 -394,10 +389,12 @@@ static struct smcd_dev *smcd_alloc_dev(
  
  	smcd->event_wq = alloc_ordered_workqueue("ism_evt_wq-%s)",
  						 WQ_MEM_RECLAIM, name);
- 	if (!smcd->event_wq) {
- 		kfree(smcd->conn);
- 		kfree(smcd);
+ 	if (!smcd->event_wq)
  		return NULL;
- 	}
  
- 	smcd->dev.parent = parent;
- 	smcd->dev.release = smcd_release;
- 	device_initialize(&smcd->dev);
- 	dev_set_name(&smcd->dev, name);
  	smcd->ops = ops;
 +	if (smc_pnetid_by_dev_port(parent, 0, smcd->pnetid))
 +		smc_pnetid_by_table_smcd(smcd);
  
  	spin_lock_init(&smcd->lock);
  	spin_lock_init(&smcd->lgr_lock);
@@@ -418,11 -406,23 +403,31 @@@
  	init_waitqueue_head(&smcd->lgrs_deleted);
  	return smcd;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(smcd_alloc_dev);
 +
 +int smcd_register_dev(struct smcd_dev *smcd)
 +{
 +	int rc;
++=======
+ 
+ static void smcd_register_dev(struct ism_dev *ism)
+ {
+ 	const struct smcd_ops *ops = ism_get_smcd_ops();
+ 	struct smcd_dev *smcd;
+ 
+ 	if (!ops)
+ 		return;
+ 
+ 	smcd = smcd_alloc_dev(&ism->pdev->dev, dev_name(&ism->pdev->dev), ops,
+ 			      ISM_NR_DMBS);
+ 	if (!smcd)
+ 		return;
+ 	smcd->priv = ism;
+ 	ism_set_priv(ism, &smc_ism_client, smcd);
+ 	if (smc_pnetid_by_dev_port(&ism->pdev->dev, 0, smcd->pnetid))
+ 		smc_pnetid_by_table_smcd(smcd);
++>>>>>>> 8c81ba20349d (net/smc: De-tangle ism and smc device initialization)
  
  	mutex_lock(&smcd_dev_list.mutex);
  	if (list_empty(&smcd_dev_list.list)) {
@@@ -443,43 -443,28 +448,45 @@@
  	mutex_unlock(&smcd_dev_list.mutex);
  
  	pr_warn_ratelimited("smc: adding smcd device %s with pnetid %.16s%s\n",
- 			    dev_name(&smcd->dev), smcd->pnetid,
+ 			    dev_name(&ism->dev), smcd->pnetid,
  			    smcd->pnetid_by_user ? " (user defined)" : "");
  
++<<<<<<< HEAD
 +	rc = device_add(&smcd->dev);
 +	if (rc) {
 +		mutex_lock(&smcd_dev_list.mutex);
 +		list_del(&smcd->list);
 +		mutex_unlock(&smcd_dev_list.mutex);
 +	}
 +
 +	return rc;
++=======
+ 	return;
++>>>>>>> 8c81ba20349d (net/smc: De-tangle ism and smc device initialization)
  }
 +EXPORT_SYMBOL_GPL(smcd_register_dev);
  
 -static void smcd_unregister_dev(struct ism_dev *ism)
 +void smcd_unregister_dev(struct smcd_dev *smcd)
  {
 -	struct smcd_dev *smcd = ism_get_priv(ism, &smc_ism_client);
 -
  	pr_warn_ratelimited("smc: removing smcd device %s\n",
- 			    dev_name(&smcd->dev));
+ 			    dev_name(&ism->dev));
  	smcd->going_away = 1;
  	smc_smcd_terminate_all(smcd);
  	mutex_lock(&smcd_dev_list.mutex);
  	list_del_init(&smcd->list);
  	mutex_unlock(&smcd_dev_list.mutex);
  	destroy_workqueue(smcd->event_wq);
- 
- 	device_del(&smcd->dev);
  }
 +EXPORT_SYMBOL_GPL(smcd_unregister_dev);
 +
 +void smcd_free_dev(struct smcd_dev *smcd)
 +{
 +	put_device(&smcd->dev);
 +}
 +EXPORT_SYMBOL_GPL(smcd_free_dev);
  
  /* SMCD Device event handler. Called from ISM device interrupt handler.
 - * Parameters are ism device pointer,
 + * Parameters are smcd device pointer,
   * - event->type (0 --> DMB, 1 --> GID),
   * - event->code (event code),
   * - event->tok (either DMB token when event type 0, or GID when event type 1)
* Unmerged path drivers/s390/net/ism_drv.c
* Unmerged path include/linux/ism.h
* Unmerged path include/net/smc.h
diff --git a/net/smc/af_smc.c b/net/smc/af_smc.c
index 4d4f0b55a268..d0a153234be4 100644
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@ -3482,6 +3482,7 @@ static void __exit smc_exit(void)
 	sock_unregister(PF_SMC);
 	smc_core_exit();
 	smc_ib_unregister_client();
+	smc_ism_exit();
 	destroy_workqueue(smc_close_wq);
 	destroy_workqueue(smc_tcp_ls_wq);
 	destroy_workqueue(smc_hs_wq);
diff --git a/net/smc/smc_core.c b/net/smc/smc_core.c
index b8b18a172193..b590af4f14bc 100644
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@ -819,6 +819,7 @@ static int smc_lgr_create(struct smc_sock *smc, struct smc_init_info *ini)
 {
 	struct smc_link_group *lgr;
 	struct list_head *lgr_list;
+	struct smcd_dev *smcd;
 	struct smc_link *lnk;
 	spinlock_t *lgr_lock;
 	u8 link_idx;
@@ -865,7 +866,8 @@ static int smc_lgr_create(struct smc_sock *smc, struct smc_init_info *ini)
 	lgr->conns_all = RB_ROOT;
 	if (ini->is_smcd) {
 		/* SMC-D specific settings */
-		get_device(&ini->ism_dev[ini->ism_selected]->dev);
+		smcd = ini->ism_dev[ini->ism_selected];
+		get_device(smcd->ops->get_dev(smcd));
 		lgr->peer_gid = ini->ism_peer_gid[ini->ism_selected];
 		lgr->smcd = ini->ism_dev[ini->ism_selected];
 		lgr_list = &ini->ism_dev[ini->ism_selected]->lgr_list;
@@ -1384,7 +1386,7 @@ static void smc_lgr_free(struct smc_link_group *lgr)
 	destroy_workqueue(lgr->tx_wq);
 	if (lgr->is_smcd) {
 		smc_ism_put_vlan(lgr->smcd, lgr->vlan_id);
-		put_device(&lgr->smcd->dev);
+		put_device(lgr->smcd->ops->get_dev(lgr->smcd));
 	}
 	smc_lgr_put(lgr); /* theoretically last lgr_put */
 }
* Unmerged path net/smc/smc_ism.c
diff --git a/net/smc/smc_pnet.c b/net/smc/smc_pnet.c
index 13ca16b74468..cb6e3be6e594 100644
--- a/net/smc/smc_pnet.c
+++ b/net/smc/smc_pnet.c
@@ -102,7 +102,7 @@ static int smc_pnet_remove_by_pnetid(struct net *net, char *pnet_name)
 	struct smc_pnetentry *pnetelem, *tmp_pe;
 	struct smc_pnettable *pnettable;
 	struct smc_ib_device *ibdev;
-	struct smcd_dev *smcd_dev;
+	struct smcd_dev *smcd;
 	struct smc_net *sn;
 	int rc = -ENOENT;
 	int ibport;
@@ -160,16 +160,17 @@ static int smc_pnet_remove_by_pnetid(struct net *net, char *pnet_name)
 	mutex_unlock(&smc_ib_devices.mutex);
 	/* remove smcd devices */
 	mutex_lock(&smcd_dev_list.mutex);
-	list_for_each_entry(smcd_dev, &smcd_dev_list.list, list) {
-		if (smcd_dev->pnetid_by_user &&
+	list_for_each_entry(smcd, &smcd_dev_list.list, list) {
+		if (smcd->pnetid_by_user &&
 		    (!pnet_name ||
-		     smc_pnet_match(pnet_name, smcd_dev->pnetid))) {
+		     smc_pnet_match(pnet_name, smcd->pnetid))) {
 			pr_warn_ratelimited("smc: smcd device %s "
 					    "erased user defined pnetid "
-					    "%.16s\n", dev_name(&smcd_dev->dev),
-					    smcd_dev->pnetid);
-			memset(smcd_dev->pnetid, 0, SMC_MAX_PNETID_LEN);
-			smcd_dev->pnetid_by_user = false;
+					    "%.16s\n",
+					    dev_name(smcd->ops->get_dev(smcd)),
+					    smcd->pnetid);
+			memset(smcd->pnetid, 0, SMC_MAX_PNETID_LEN);
+			smcd->pnetid_by_user = false;
 			rc = 0;
 		}
 	}
@@ -329,8 +330,8 @@ static struct smcd_dev *smc_pnet_find_smcd(char *smcd_name)
 
 	mutex_lock(&smcd_dev_list.mutex);
 	list_for_each_entry(smcd_dev, &smcd_dev_list.list, list) {
-		if (!strncmp(dev_name(&smcd_dev->dev), smcd_name,
-			     IB_DEVICE_NAME_MAX - 1))
+		if (!strncmp(dev_name(smcd_dev->ops->get_dev(smcd_dev)),
+			     smcd_name, IB_DEVICE_NAME_MAX - 1))
 			goto out;
 	}
 	smcd_dev = NULL;
@@ -406,7 +407,8 @@ static int smc_pnet_add_ib(struct smc_pnettable *pnettable, char *ib_name,
 	struct smc_ib_device *ib_dev;
 	bool smcddev_applied = true;
 	bool ibdev_applied = true;
-	struct smcd_dev *smcd_dev;
+	struct smcd_dev *smcd;
+	struct device *dev;
 	bool new_ibdev;
 
 	/* try to apply the pnetid to active devices */
@@ -420,14 +422,16 @@ static int smc_pnet_add_ib(struct smc_pnettable *pnettable, char *ib_name,
 					    ib_port,
 					    ib_dev->pnetid[ib_port - 1]);
 	}
-	smcd_dev = smc_pnet_find_smcd(ib_name);
-	if (smcd_dev) {
-		smcddev_applied = smc_pnet_apply_smcd(smcd_dev, pnet_name);
-		if (smcddev_applied)
+	smcd = smc_pnet_find_smcd(ib_name);
+	if (smcd) {
+		smcddev_applied = smc_pnet_apply_smcd(smcd, pnet_name);
+		if (smcddev_applied) {
+			dev = smcd->ops->get_dev(smcd);
 			pr_warn_ratelimited("smc: smcd device %s "
 					    "applied user defined pnetid "
-					    "%.16s\n", dev_name(&smcd_dev->dev),
-					    smcd_dev->pnetid);
+					    "%.16s\n", dev_name(dev),
+					    smcd->pnetid);
+		}
 	}
 	/* Apply fails when a device has a hardware-defined pnetid set, do not
 	 * add a pnet table entry in that case.
@@ -1175,7 +1179,7 @@ int smc_pnetid_by_table_ib(struct smc_ib_device *smcibdev, u8 ib_port)
  */
 int smc_pnetid_by_table_smcd(struct smcd_dev *smcddev)
 {
-	const char *ib_name = dev_name(&smcddev->dev);
+	const char *ib_name = dev_name(smcddev->ops->get_dev(smcddev));
 	struct smc_pnettable *pnettable;
 	struct smc_pnetentry *tmp_pe;
 	struct smc_net *sn;
