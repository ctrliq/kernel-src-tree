x86/resctrl: Remove rdt_cdp_peer_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit fbc06c69805976e1b5c7e6bd0b89c5b0f5282cdf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/fbc06c69.failed

When CDP is enabled, rdt_cdp_peer_get() finds the alternative
CODE/DATA resource and returns the alternative domain. This is used
to determine if bitmaps overlap when there are aliased entries
in the two struct rdt_hw_resources.

Now that the ctrl_val[] used by the CODE/DATA resources is the same,
the search for an alternate resource/domain is not needed.

Replace rdt_cdp_peer_get() with resctrl_peer_type(), which returns
the alternative type. This can be passed to resctrl_arch_get_config()
with the same resource and domain.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <jamie@nuviainc.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lkml.kernel.org/r/20210728170637.25610-23-james.morse@arm.com
(cherry picked from commit fbc06c69805976e1b5c7e6bd0b89c5b0f5282cdf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index a8731279ffbf,7cf4bf3583a9..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -1105,76 -1092,17 +1105,64 @@@ static int rdtgroup_mode_show(struct ke
  	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * rdt_cdp_peer_get - Retrieve CDP peer if it exists
 + * @r: RDT resource to which RDT domain @d belongs
 + * @d: Cache instance for which a CDP peer is requested
 + * @r_cdp: RDT resource that shares hardware with @r (RDT resource peer)
 + *         Used to return the result.
 + * @d_cdp: RDT domain that shares hardware with @d (RDT domain peer)
 + *         Used to return the result.
 + *
 + * RDT resources are managed independently and by extension the RDT domains
 + * (RDT resource instances) are managed independently also. The Code and
 + * Data Prioritization (CDP) RDT resources, while managed independently,
 + * could refer to the same underlying hardware. For example,
 + * RDT_RESOURCE_L2CODE and RDT_RESOURCE_L2DATA both refer to the L2 cache.
 + *
 + * When provided with an RDT resource @r and an instance of that RDT
 + * resource @d rdt_cdp_peer_get() will return if there is a peer RDT
 + * resource and the exact instance that shares the same hardware.
 + *
 + * Return: 0 if a CDP peer was found, <0 on error or if no CDP peer exists.
 + *         If a CDP peer was found, @r_cdp will point to the peer RDT resource
 + *         and @d_cdp will point to the peer RDT domain.
 + */
 +static int rdt_cdp_peer_get(struct rdt_resource *r, struct rdt_domain *d,
 +			    struct rdt_resource **r_cdp,
 +			    struct rdt_domain **d_cdp)
 +{
 +	struct rdt_resource *_r_cdp = NULL;
 +	struct rdt_domain *_d_cdp = NULL;
 +	int ret = 0;
 +
 +	switch (r->rid) {
 +	case RDT_RESOURCE_L3DATA:
 +		_r_cdp = &rdt_resources_all[RDT_RESOURCE_L3CODE];
 +		break;
 +	case RDT_RESOURCE_L3CODE:
 +		_r_cdp =  &rdt_resources_all[RDT_RESOURCE_L3DATA];
 +		break;
 +	case RDT_RESOURCE_L2DATA:
 +		_r_cdp =  &rdt_resources_all[RDT_RESOURCE_L2CODE];
 +		break;
 +	case RDT_RESOURCE_L2CODE:
 +		_r_cdp =  &rdt_resources_all[RDT_RESOURCE_L2DATA];
 +		break;
++=======
+ static enum resctrl_conf_type resctrl_peer_type(enum resctrl_conf_type my_type)
+ {
+ 	switch (my_type) {
+ 	case CDP_CODE:
+ 		return CDP_DATA;
+ 	case CDP_DATA:
+ 		return CDP_CODE;
++>>>>>>> fbc06c698059 (x86/resctrl: Remove rdt_cdp_peer_get())
  	default:
- 		ret = -ENOENT;
- 		goto out;
- 	}
- 
- 	/*
- 	 * When a new CPU comes online and CDP is enabled then the new
- 	 * RDT domains (if any) associated with both CDP RDT resources
- 	 * are added in the same CPU online routine while the
- 	 * rdtgroup_mutex is held. It should thus not happen for one
- 	 * RDT domain to exist and be associated with its RDT CDP
- 	 * resource but there is no RDT domain associated with the
- 	 * peer RDT CDP resource. Hence the WARN.
- 	 */
- 	_d_cdp = rdt_find_domain(_r_cdp, d->id, NULL);
- 	if (WARN_ON(IS_ERR_OR_NULL(_d_cdp))) {
- 		_r_cdp = NULL;
- 		_d_cdp = NULL;
- 		ret = -EINVAL;
+ 	case CDP_NONE:
+ 		return CDP_NONE;
  	}
- 
- out:
- 	*r_cdp = _r_cdp;
- 	*d_cdp = _d_cdp;
- 
- 	return ret;
  }
  
  /**
@@@ -1253,19 -1180,19 +1241,30 @@@ static bool __rdtgroup_cbm_overlaps(str
   *
   * Return: true if CBM overlap detected, false if there is no overlap
   */
 -bool rdtgroup_cbm_overlaps(struct resctrl_schema *s, struct rdt_domain *d,
 +bool rdtgroup_cbm_overlaps(struct rdt_resource *r, struct rdt_domain *d,
  			   unsigned long cbm, int closid, bool exclusive)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r_cdp;
 +	struct rdt_domain *d_cdp;
++=======
+ 	enum resctrl_conf_type peer_type = resctrl_peer_type(s->conf_type);
+ 	struct rdt_resource *r = s->res;
++>>>>>>> fbc06c698059 (x86/resctrl: Remove rdt_cdp_peer_get())
  
 -	if (__rdtgroup_cbm_overlaps(r, d, cbm, closid, s->conf_type,
 -				    exclusive))
 +	if (__rdtgroup_cbm_overlaps(r, d, cbm, closid, exclusive))
  		return true;
  
++<<<<<<< HEAD
 +	if (rdt_cdp_peer_get(r, d, &r_cdp, &d_cdp) < 0)
 +		return false;
 +
 +	return  __rdtgroup_cbm_overlaps(r_cdp, d_cdp, cbm, closid, exclusive);
++=======
+ 	if (!resctrl_arch_get_cdp_enabled(r->rid))
+ 		return false;
+ 	return  __rdtgroup_cbm_overlaps(r, d, cbm, closid, peer_type, exclusive);
++>>>>>>> fbc06c698059 (x86/resctrl: Remove rdt_cdp_peer_get())
  }
  
  /**
@@@ -2669,23 -2685,24 +2668,36 @@@ static u32 cbm_ensure_valid(u32 _val, s
   * Set the RDT domain up to start off with all usable allocations. That is,
   * all shareable and unused bits. All-zero CBM is invalid.
   */
 -static int __init_one_rdt_domain(struct rdt_domain *d, struct resctrl_schema *s,
 +static int __init_one_rdt_domain(struct rdt_domain *d, struct rdt_resource *r,
  				 u32 closid)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r_cdp = NULL;
 +	struct rdt_domain *d_cdp = NULL;
++=======
+ 	enum resctrl_conf_type peer_type = resctrl_peer_type(s->conf_type);
+ 	enum resctrl_conf_type t = s->conf_type;
+ 	struct resctrl_staged_config *cfg;
+ 	struct rdt_resource *r = s->res;
++>>>>>>> fbc06c698059 (x86/resctrl: Remove rdt_cdp_peer_get())
  	u32 used_b = 0, unused_b = 0;
  	unsigned long tmp_cbm;
  	enum rdtgrp_mode mode;
 -	u32 peer_ctl, ctrl_val;
 +	u32 peer_ctl, *ctrl;
  	int i;
  
++<<<<<<< HEAD
 +	rdt_cdp_peer_get(r, d, &r_cdp, &d_cdp);
 +	d->have_new_ctrl = false;
 +	d->new_ctrl = r->cache.shareable_bits;
++=======
+ 	cfg = &d->staged_config[t];
+ 	cfg->have_new_ctrl = false;
+ 	cfg->new_ctrl = r->cache.shareable_bits;
++>>>>>>> fbc06c698059 (x86/resctrl: Remove rdt_cdp_peer_get())
  	used_b = r->cache.shareable_bits;
 -	for (i = 0; i < closids_supported(); i++) {
 +	ctrl = d->ctrl_val;
 +	for (i = 0; i < closids_supported(); i++, ctrl++) {
  		if (closid_allocated(i) && i != closid) {
  			mode = rdtgroup_mode_by_closid(i);
  			if (mode == RDT_MODE_PSEUDO_LOCKSETUP)
@@@ -2700,13 -2717,14 +2712,18 @@@
  			 * usage to ensure there is no overlap
  			 * with an exclusive group.
  			 */
++<<<<<<< HEAD
 +			if (d_cdp)
 +				peer_ctl = d_cdp->ctrl_val[i];
++=======
+ 			if (resctrl_arch_get_cdp_enabled(r->rid))
+ 				resctrl_arch_get_config(r, d, i, peer_type, &peer_ctl);
++>>>>>>> fbc06c698059 (x86/resctrl: Remove rdt_cdp_peer_get())
  			else
  				peer_ctl = 0;
 -			resctrl_arch_get_config(r, d, i, s->conf_type, &ctrl_val);
 -			used_b |= ctrl_val | peer_ctl;
 +			used_b |= *ctrl | peer_ctl;
  			if (mode == RDT_MODE_SHAREABLE)
 -				cfg->new_ctrl |= ctrl_val | peer_ctl;
 +				d->new_ctrl |= *ctrl | peer_ctl;
  		}
  	}
  	if (d->plr && d->plr->cbm > 0)
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
