x86/microcode: Simplify init path even more

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Borislav Petkov <bp@suse.de>
commit 2071c0aeda228107bf1b9e870b6187c90fbeef1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/2071c0ae.failed

Get rid of all the IPI-sending functions and their wrappers and use
those which are supposed to be called on each CPU.

Thus:

- microcode_init_cpu() gets called on each CPU on init, applying any new
  microcode that the driver might've found on the filesystem.

- mc_cpu_starting() simply tries to apply cached microcode as this is
  the cpuhp starting callback which gets called on CPU resume too.

Even if the driver init function is a late initcall, there is no
filesystem by then (not even a hdd driver has been loaded yet) so a new
firmware load attempt cannot simply be done.

It is pointless anyway - for that there's late loading if one really
needs it.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Ashok Raj <ashok.raj@intel.com>
Link: https://lore.kernel.org/r/20221028142638.28498-3-bp@alien8.de
(cherry picked from commit 2071c0aeda228107bf1b9e870b6187c90fbeef1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/microcode/core.c
diff --cc arch/x86/kernel/cpu/microcode/core.c
index 98b42808eaaf,63f7678743be..000000000000
--- a/arch/x86/kernel/cpu/microcode/core.c
+++ b/arch/x86/kernel/cpu/microcode/core.c
@@@ -338,152 -319,6 +338,155 @@@ void reload_early_microcode(void
  	}
  }
  
++<<<<<<< HEAD
 +static void collect_cpu_info_local(void *arg)
 +{
 +	struct cpu_info_ctx *ctx = arg;
 +
 +	ctx->err = microcode_ops->collect_cpu_info(smp_processor_id(),
 +						   ctx->cpu_sig);
 +}
 +
 +static int collect_cpu_info_on_target(int cpu, struct cpu_signature *cpu_sig)
 +{
 +	struct cpu_info_ctx ctx = { .cpu_sig = cpu_sig, .err = 0 };
 +	int ret;
 +
 +	ret = smp_call_function_single(cpu, collect_cpu_info_local, &ctx, 1);
 +	if (!ret)
 +		ret = ctx.err;
 +
 +	return ret;
 +}
 +
 +static int collect_cpu_info(int cpu)
 +{
 +	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
 +	int ret;
 +
 +	memset(uci, 0, sizeof(*uci));
 +
 +	ret = collect_cpu_info_on_target(cpu, &uci->cpu_sig);
 +	if (!ret)
 +		uci->valid = 1;
 +
 +	return ret;
 +}
 +
 +static void apply_microcode_local(void *arg)
 +{
 +	enum ucode_state *err = arg;
 +
 +	*err = microcode_ops->apply_microcode(smp_processor_id());
 +}
 +
 +static int apply_microcode_on_target(int cpu)
 +{
 +	enum ucode_state err;
 +	int ret;
 +
 +	ret = smp_call_function_single(cpu, apply_microcode_local, &err, 1);
 +	if (!ret) {
 +		if (err == UCODE_ERROR)
 +			ret = 1;
 +	}
 +	return ret;
 +}
 +
 +#ifdef CONFIG_MICROCODE_OLD_INTERFACE
 +static int do_microcode_update(const void __user *buf, size_t size)
 +{
 +	int error = 0;
 +	int cpu;
 +
 +	for_each_online_cpu(cpu) {
 +		struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
 +		enum ucode_state ustate;
 +
 +		if (!uci->valid)
 +			continue;
 +
 +		ustate = microcode_ops->request_microcode_user(cpu, buf, size);
 +		if (ustate == UCODE_ERROR) {
 +			error = -1;
 +			break;
 +		} else if (ustate == UCODE_NEW) {
 +			apply_microcode_on_target(cpu);
 +		}
 +	}
 +
 +	return error;
 +}
 +
 +static int microcode_open(struct inode *inode, struct file *file)
 +{
 +	return capable(CAP_SYS_RAWIO) ? nonseekable_open(inode, file) : -EPERM;
 +}
 +
 +static ssize_t microcode_write(struct file *file, const char __user *buf,
 +			       size_t len, loff_t *ppos)
 +{
 +	ssize_t ret = -EINVAL;
 +	unsigned long nr_pages = totalram_pages();
 +
 +	if ((len >> PAGE_SHIFT) > nr_pages) {
 +		pr_err("too much data (max %ld pages)\n", nr_pages);
 +		return ret;
 +	}
 +
 +	cpus_read_lock();
 +	mutex_lock(&microcode_mutex);
 +
 +	if (do_microcode_update(buf, len) == 0)
 +		ret = (ssize_t)len;
 +
 +	if (ret > 0)
 +		perf_check_microcode();
 +
 +	mutex_unlock(&microcode_mutex);
 +	cpus_read_unlock();
 +
 +	return ret;
 +}
 +
 +static const struct file_operations microcode_fops = {
 +	.owner			= THIS_MODULE,
 +	.write			= microcode_write,
 +	.open			= microcode_open,
 +	.llseek		= no_llseek,
 +};
 +
 +static struct miscdevice microcode_dev = {
 +	.minor			= MICROCODE_MINOR,
 +	.name			= "microcode",
 +	.nodename		= "cpu/microcode",
 +	.fops			= &microcode_fops,
 +};
 +
 +static int __init microcode_dev_init(void)
 +{
 +	int error;
 +
 +	error = misc_register(&microcode_dev);
 +	if (error) {
 +		pr_err("can't misc_register on minor=%d\n", MICROCODE_MINOR);
 +		return error;
 +	}
 +
 +	return 0;
 +}
 +
 +static void __exit microcode_dev_exit(void)
 +{
 +	misc_deregister(&microcode_dev);
 +}
 +#else
 +#define microcode_dev_init()	0
 +#define microcode_dev_exit()	do { } while (0)
 +#endif
 +
++=======
++>>>>>>> 2071c0aeda22 (x86/microcode: Simplify init path even more)
  /* fake device for request_firmware */
  static struct platform_device	*microcode_pdev;
  
@@@ -697,95 -535,21 +700,97 @@@ static void microcode_fini_cpu(int cpu
  		microcode_ops->microcode_fini_cpu(cpu);
  }
  
++<<<<<<< HEAD
 +static enum ucode_state microcode_resume_cpu(int cpu)
 +{
 +	if (apply_microcode_on_target(cpu))
 +		return UCODE_ERROR;
 +
 +	pr_debug("CPU%d updated upon resume\n", cpu);
 +
 +	return UCODE_OK;
 +}
 +
 +static enum ucode_state microcode_init_cpu(int cpu, bool refresh_fw)
 +{
 +	enum ucode_state ustate;
 +	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
 +
 +	if (uci->valid)
 +		return UCODE_OK;
 +
 +	if (collect_cpu_info(cpu))
 +		return UCODE_ERROR;
 +
 +	/* --dimm. Trigger a delayed update? */
 +	if (system_state != SYSTEM_RUNNING)
 +		return UCODE_NFOUND;
 +
 +	ustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev, refresh_fw);
 +	if (ustate == UCODE_NEW) {
 +		pr_debug("CPU%d updated upon init\n", cpu);
 +		apply_microcode_on_target(cpu);
 +	}
 +
 +	return ustate;
 +}
 +
 +static enum ucode_state microcode_update_cpu(int cpu)
++=======
+ static enum ucode_state microcode_init_cpu(int cpu)
++>>>>>>> 2071c0aeda22 (x86/microcode: Simplify init path even more)
  {
  	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
  
- 	/* Refresh CPU microcode revision after resume. */
- 	collect_cpu_info(cpu);
+ 	memset(uci, 0, sizeof(*uci));
  
- 	if (uci->valid)
- 		return microcode_resume_cpu(cpu);
+ 	microcode_ops->collect_cpu_info(cpu, &uci->cpu_sig);
  
- 	return microcode_init_cpu(cpu, false);
+ 	return microcode_ops->apply_microcode(cpu);
  }
  
 +static int mc_device_add(struct device *dev, struct subsys_interface *sif)
 +{
 +	int err, cpu = dev->id;
 +
 +	if (!cpu_online(cpu))
 +		return 0;
 +
 +	pr_debug("CPU%d added\n", cpu);
 +
 +	err = sysfs_create_group(&dev->kobj, &mc_attr_group);
 +	if (err)
 +		return err;
 +
 +	if (microcode_init_cpu(cpu, true) == UCODE_ERROR)
 +		return -EINVAL;
 +
 +	return err;
 +}
 +
 +static void mc_device_remove(struct device *dev, struct subsys_interface *sif)
 +{
 +	int cpu = dev->id;
 +
 +	if (!cpu_online(cpu))
 +		return;
 +
 +	pr_debug("CPU%d removed\n", cpu);
 +	microcode_fini_cpu(cpu);
 +	sysfs_remove_group(&dev->kobj, &mc_attr_group);
 +}
 +
 +static struct subsys_interface mc_cpu_interface = {
 +	.name			= "microcode",
 +	.subsys			= &cpu_subsys,
 +	.add_dev		= mc_device_add,
 +	.remove_dev		= mc_device_remove,
 +};
 +
  /**
 - * microcode_bsp_resume - Update boot CPU microcode during resume.
 + * mc_bp_resume - Update boot CPU microcode during resume.
   */
 -void microcode_bsp_resume(void)
 +static void mc_bp_resume(void)
  {
  	int cpu = smp_processor_id();
  	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
@@@ -797,7 -561,7 +802,11 @@@
  }
  
  static struct syscore_ops mc_syscore_ops = {
++<<<<<<< HEAD
 +	.resume			= mc_bp_resume,
++=======
+ 	.resume	= microcode_bsp_resume,
++>>>>>>> 2071c0aeda22 (x86/microcode: Simplify init path even more)
  };
  
  static int mc_cpu_starting(unsigned int cpu)
@@@ -828,8 -595,24 +837,25 @@@ static int mc_cpu_down_prep(unsigned in
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void setup_online_cpu(struct work_struct *work)
+ {
+ 	int cpu = smp_processor_id();
+ 	enum ucode_state err;
+ 
+ 	err = microcode_init_cpu(cpu);
+ 	if (err == UCODE_ERROR) {
+ 		pr_err("Error applying microcode on CPU%d\n", cpu);
+ 		return;
+ 	}
+ 
+ 	mc_cpu_online(cpu);
+ }
+ 
++>>>>>>> 2071c0aeda22 (x86/microcode: Simplify init path even more)
  static struct attribute *cpu_root_microcode_attrs[] = {
 -#ifdef CONFIG_MICROCODE_LATE_LOADING
  	&dev_attr_reload.attr,
 -#endif
  	NULL
  };
  
* Unmerged path arch/x86/kernel/cpu/microcode/core.c
