x86/microcode/intel: Add hdr_type to intel_microcode_sanity_check()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Jithu Joseph <jithu.joseph@intel.com>
commit e0788c3281a72386e75b53a010de4bfbac7e80db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/e0788c32.failed

IFS test images and microcode blobs use the same header format.
Microcode blobs use header type of 1, whereas IFS test images
will use header type of 2.

In preparation for IFS reusing intel_microcode_sanity_check(),
add header type as a parameter for sanity check.

  [ bp: Touchups. ]

	Signed-off-by: Jithu Joseph <jithu.joseph@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Ashok Raj <ashok.raj@intel.com>
Link: https://lore.kernel.org/r/20221117035935.4136738-9-jithu.joseph@intel.com
(cherry picked from commit e0788c3281a72386e75b53a010de4bfbac7e80db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpu.h
#	arch/x86/kernel/cpu/intel.c
#	arch/x86/kernel/cpu/microcode/intel.c
diff --cc arch/x86/include/asm/cpu.h
index 21924730afae,78796b98a544..000000000000
--- a/arch/x86/include/asm/cpu.h
+++ b/arch/x86/include/asm/cpu.h
@@@ -73,4 -68,34 +73,37 @@@ static inline u8 get_this_hybrid_cpu_ty
  	return 0;
  }
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IA32_FEAT_CTL
+ void init_ia32_feat_ctl(struct cpuinfo_x86 *c);
+ #else
+ static inline void init_ia32_feat_ctl(struct cpuinfo_x86 *c) {}
+ #endif
+ 
+ extern __noendbr void cet_disable(void);
+ 
+ struct ucode_cpu_info;
+ 
+ int intel_cpu_collect_info(struct ucode_cpu_info *uci);
+ 
+ static inline bool intel_cpu_signatures_match(unsigned int s1, unsigned int p1,
+ 					      unsigned int s2, unsigned int p2)
+ {
+ 	if (s1 != s2)
+ 		return false;
+ 
+ 	/* Processor flags are either both 0 ... */
+ 	if (!p1 && !p2)
+ 		return true;
+ 
+ 	/* ... or they intersect. */
+ 	return p1 & p2;
+ }
+ 
+ extern u64 x86_read_arch_cap_msr(void);
+ int intel_find_matching_signature(void *mc, unsigned int csig, int cpf);
+ int intel_microcode_sanity_check(void *mc, bool print_err, int hdr_type);
+ 
++>>>>>>> e0788c3281a7 (x86/microcode/intel: Add hdr_type to intel_microcode_sanity_check())
  #endif /* _ASM_X86_CPU_H */
diff --cc arch/x86/kernel/cpu/intel.c
index 9f6c1ec168fa,b6997eb6e519..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -217,6 -184,180 +217,183 @@@ static bool bad_spectre_microcode(struc
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ int intel_cpu_collect_info(struct ucode_cpu_info *uci)
+ {
+ 	unsigned int val[2];
+ 	unsigned int family, model;
+ 	struct cpu_signature csig = { 0 };
+ 	unsigned int eax, ebx, ecx, edx;
+ 
+ 	memset(uci, 0, sizeof(*uci));
+ 
+ 	eax = 0x00000001;
+ 	ecx = 0;
+ 	native_cpuid(&eax, &ebx, &ecx, &edx);
+ 	csig.sig = eax;
+ 
+ 	family = x86_family(eax);
+ 	model  = x86_model(eax);
+ 
+ 	if (model >= 5 || family > 6) {
+ 		/* get processor flags from MSR 0x17 */
+ 		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);
+ 		csig.pf = 1 << ((val[1] >> 18) & 7);
+ 	}
+ 
+ 	csig.rev = intel_get_microcode_revision();
+ 
+ 	uci->cpu_sig = csig;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(intel_cpu_collect_info);
+ 
+ /*
+  * Returns 1 if update has been found, 0 otherwise.
+  */
+ int intel_find_matching_signature(void *mc, unsigned int csig, int cpf)
+ {
+ 	struct microcode_header_intel *mc_hdr = mc;
+ 	struct extended_sigtable *ext_hdr;
+ 	struct extended_signature *ext_sig;
+ 	int i;
+ 
+ 	if (intel_cpu_signatures_match(csig, cpf, mc_hdr->sig, mc_hdr->pf))
+ 		return 1;
+ 
+ 	/* Look for ext. headers: */
+ 	if (get_totalsize(mc_hdr) <= get_datasize(mc_hdr) + MC_HEADER_SIZE)
+ 		return 0;
+ 
+ 	ext_hdr = mc + get_datasize(mc_hdr) + MC_HEADER_SIZE;
+ 	ext_sig = (void *)ext_hdr + EXT_HEADER_SIZE;
+ 
+ 	for (i = 0; i < ext_hdr->count; i++) {
+ 		if (intel_cpu_signatures_match(csig, cpf, ext_sig->sig, ext_sig->pf))
+ 			return 1;
+ 		ext_sig++;
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(intel_find_matching_signature);
+ 
+ /**
+  * intel_microcode_sanity_check() - Sanity check microcode file.
+  * @mc: Pointer to the microcode file contents.
+  * @print_err: Display failure reason if true, silent if false.
+  * @hdr_type: Type of file, i.e. normal microcode file or In Field Scan file.
+  *            Validate if the microcode header type matches with the type
+  *            specified here.
+  *
+  * Validate certain header fields and verify if computed checksum matches
+  * with the one specified in the header.
+  *
+  * Return: 0 if the file passes all the checks, -EINVAL if any of the checks
+  * fail.
+  */
+ int intel_microcode_sanity_check(void *mc, bool print_err, int hdr_type)
+ {
+ 	unsigned long total_size, data_size, ext_table_size;
+ 	struct microcode_header_intel *mc_header = mc;
+ 	struct extended_sigtable *ext_header = NULL;
+ 	u32 sum, orig_sum, ext_sigcount = 0, i;
+ 	struct extended_signature *ext_sig;
+ 
+ 	total_size = get_totalsize(mc_header);
+ 	data_size = get_datasize(mc_header);
+ 
+ 	if (data_size + MC_HEADER_SIZE > total_size) {
+ 		if (print_err)
+ 			pr_err("Error: bad microcode data file size.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mc_header->ldrver != 1 || mc_header->hdrver != hdr_type) {
+ 		if (print_err)
+ 			pr_err("Error: invalid/unknown microcode update format. Header type %d\n",
+ 			       mc_header->hdrver);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ext_table_size = total_size - (MC_HEADER_SIZE + data_size);
+ 	if (ext_table_size) {
+ 		u32 ext_table_sum = 0;
+ 		u32 *ext_tablep;
+ 
+ 		if (ext_table_size < EXT_HEADER_SIZE ||
+ 		    ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {
+ 			if (print_err)
+ 				pr_err("Error: truncated extended signature table.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		ext_header = mc + MC_HEADER_SIZE + data_size;
+ 		if (ext_table_size != exttable_size(ext_header)) {
+ 			if (print_err)
+ 				pr_err("Error: extended signature table size mismatch.\n");
+ 			return -EFAULT;
+ 		}
+ 
+ 		ext_sigcount = ext_header->count;
+ 
+ 		/*
+ 		 * Check extended table checksum: the sum of all dwords that
+ 		 * comprise a valid table must be 0.
+ 		 */
+ 		ext_tablep = (u32 *)ext_header;
+ 
+ 		i = ext_table_size / sizeof(u32);
+ 		while (i--)
+ 			ext_table_sum += ext_tablep[i];
+ 
+ 		if (ext_table_sum) {
+ 			if (print_err)
+ 				pr_warn("Bad extended signature table checksum, aborting.\n");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Calculate the checksum of update data and header. The checksum of
+ 	 * valid update data and header including the extended signature table
+ 	 * must be 0.
+ 	 */
+ 	orig_sum = 0;
+ 	i = (MC_HEADER_SIZE + data_size) / sizeof(u32);
+ 	while (i--)
+ 		orig_sum += ((u32 *)mc)[i];
+ 
+ 	if (orig_sum) {
+ 		if (print_err)
+ 			pr_err("Bad microcode data checksum, aborting.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!ext_table_size)
+ 		return 0;
+ 
+ 	/*
+ 	 * Check extended signature checksum: 0 => valid.
+ 	 */
+ 	for (i = 0; i < ext_sigcount; i++) {
+ 		ext_sig = (void *)ext_header + EXT_HEADER_SIZE +
+ 			  EXT_SIGNATURE_SIZE * i;
+ 
+ 		sum = (mc_header->sig + mc_header->pf + mc_header->cksum) -
+ 		      (ext_sig->sig + ext_sig->pf + ext_sig->cksum);
+ 		if (sum) {
+ 			if (print_err)
+ 				pr_err("Bad extended signature checksum, aborting.\n");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(intel_microcode_sanity_check);
+ 
++>>>>>>> e0788c3281a7 (x86/microcode/intel: Add hdr_type to intel_microcode_sanity_check())
  static void early_init_intel(struct cpuinfo_x86 *c)
  {
  	u64 misc_enable;
diff --cc arch/x86/kernel/cpu/microcode/intel.c
index cdab3b93d858,c4a00fb97f61..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@@ -295,7 -155,7 +295,11 @@@ scan_microcode(void *data, size_t size
  		mc_size = get_totalsize(mc_header);
  		if (!mc_size ||
  		    mc_size > size ||
++<<<<<<< HEAD
 +		    microcode_sanity_check(data, false) < 0)
++=======
+ 		    intel_microcode_sanity_check(data, false, MC_HEADER_TYPE_MICROCODE) < 0)
++>>>>>>> e0788c3281a7 (x86/microcode/intel: Add hdr_type to intel_microcode_sanity_check())
  			break;
  
  		size -= mc_size;
@@@ -858,7 -694,7 +862,11 @@@ static enum ucode_state generic_load_mi
  		memcpy(mc, &mc_header, sizeof(mc_header));
  		data = mc + sizeof(mc_header);
  		if (!copy_from_iter_full(data, data_size, iter) ||
++<<<<<<< HEAD
 +		    microcode_sanity_check(mc, true) < 0) {
++=======
+ 		    intel_microcode_sanity_check(mc, true, MC_HEADER_TYPE_MICROCODE) < 0) {
++>>>>>>> e0788c3281a7 (x86/microcode/intel: Add hdr_type to intel_microcode_sanity_check())
  			break;
  		}
  
* Unmerged path arch/x86/include/asm/cpu.h
diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h
index d85a07d7154f..ff2bd31347e2 100644
--- a/arch/x86/include/asm/microcode_intel.h
+++ b/arch/x86/include/asm/microcode_intel.h
@@ -41,6 +41,7 @@ struct extended_sigtable {
 #define DEFAULT_UCODE_TOTALSIZE (DEFAULT_UCODE_DATASIZE + MC_HEADER_SIZE)
 #define EXT_HEADER_SIZE		(sizeof(struct extended_sigtable))
 #define EXT_SIGNATURE_SIZE	(sizeof(struct extended_signature))
+#define MC_HEADER_TYPE_MICROCODE	1
 
 #define get_totalsize(mc) \
 	(((struct microcode_intel *)mc)->hdr.datasize ? \
* Unmerged path arch/x86/kernel/cpu/intel.c
* Unmerged path arch/x86/kernel/cpu/microcode/intel.c
