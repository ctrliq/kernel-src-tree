x86/resctrl: Merge the CDP resources

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit 5c3b63cdba441c6a530b974ff73b14161d96a0c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/5c3b63cd.failed

resctrl uses struct rdt_resource to describe the available hardware
resources. The domains of the CDP aliases share a single ctrl_val[]
array. The only differences between the struct rdt_hw_resource aliases
is the name and conf_type.

The name from struct rdt_hw_resource is visible to user-space. To
support another architecture, as many user-visible details should be
handled in the filesystem parts of the code that is common to all
architectures. The name and conf_type go together.

Remove conf_type and the CDP aliases. When CDP is supported and enabled,
schemata_list_create() can create two schemata using the single
resource, generating the CODE/DATA suffix to the schema name itself.

This allows the alloc_ctrlval_array() and complications around free()ing
the ctrl_val arrays to be removed.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <jamie@nuviainc.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lkml.kernel.org/r/20210728170637.25610-25-james.morse@arm.com
(cherry picked from commit 5c3b63cdba441c6a530b974ff73b14161d96a0c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/core.c
#	arch/x86/kernel/cpu/resctrl/internal.h
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/core.c
index 916eb976301b,4b8813bafffd..000000000000
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@@ -65,120 -57,54 +65,166 @@@ static voi
  mba_wrmsr_amd(struct rdt_domain *d, struct msr_param *m,
  	      struct rdt_resource *r);
  
 -#define domain_init(id) LIST_HEAD_INIT(rdt_resources_all[id].r_resctrl.domains)
 +#define domain_init(id) LIST_HEAD_INIT(rdt_resources_all[id].domains)
  
 -struct rdt_hw_resource rdt_resources_all[] = {
 +struct rdt_resource rdt_resources_all[] = {
  	[RDT_RESOURCE_L3] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L3,
 +		.name			= "L3",
 +		.domains		= domain_init(RDT_RESOURCE_L3),
++=======
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L3,
+ 			.name			= "L3",
+ 			.cache_level		= 3,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L3),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
 +		.msr_base		= MSR_IA32_L3_CBM_BASE,
 +		.msr_update		= cat_wrmsr,
 +		.cache_level		= 3,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 1,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
 +	},
++<<<<<<< HEAD
 +	[RDT_RESOURCE_L3DATA] =
 +	{
 +		.rid			= RDT_RESOURCE_L3DATA,
 +		.name			= "L3DATA",
 +		.domains		= domain_init(RDT_RESOURCE_L3DATA),
  		.msr_base		= MSR_IA32_L3_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 3,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
 +	[RDT_RESOURCE_L3CODE] =
 +	{
 +		.rid			= RDT_RESOURCE_L3CODE,
 +		.name			= "L3CODE",
 +		.domains		= domain_init(RDT_RESOURCE_L3CODE),
 +		.msr_base		= MSR_IA32_L3_CBM_BASE,
 +		.msr_update		= cat_wrmsr,
 +		.cache_level		= 3,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 1,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
 +	},
 +	[RDT_RESOURCE_L2] =
 +	{
 +		.rid			= RDT_RESOURCE_L2,
 +		.name			= "L2",
 +		.domains		= domain_init(RDT_RESOURCE_L2),
++=======
+ 	[RDT_RESOURCE_L2] =
+ 	{
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L2,
+ 			.name			= "L2",
+ 			.cache_level		= 2,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L2),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
 +		.msr_base		= MSR_IA32_L2_CBM_BASE,
 +		.msr_update		= cat_wrmsr,
 +		.cache_level		= 2,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 1,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
 +	},
++<<<<<<< HEAD
 +	[RDT_RESOURCE_L2DATA] =
 +	{
 +		.rid			= RDT_RESOURCE_L2DATA,
 +		.name			= "L2DATA",
 +		.domains		= domain_init(RDT_RESOURCE_L2DATA),
 +		.msr_base		= MSR_IA32_L2_CBM_BASE,
 +		.msr_update		= cat_wrmsr,
 +		.cache_level		= 2,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
 +	},
 +	[RDT_RESOURCE_L2CODE] =
 +	{
 +		.rid			= RDT_RESOURCE_L2CODE,
 +		.name			= "L2CODE",
 +		.domains		= domain_init(RDT_RESOURCE_L2CODE),
  		.msr_base		= MSR_IA32_L2_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 2,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 1,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
 +	[RDT_RESOURCE_MBA] =
 +	{
 +		.rid			= RDT_RESOURCE_MBA,
 +		.name			= "MB",
 +		.domains		= domain_init(RDT_RESOURCE_MBA),
 +		.cache_level		= 3,
 +		.parse_ctrlval		= parse_bw,
 +		.format_str		= "%d=%*u",
 +		.fflags			= RFTYPE_RES_MB,
++=======
+ 	[RDT_RESOURCE_MBA] =
+ 	{
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_MBA,
+ 			.name			= "MB",
+ 			.cache_level		= 3,
+ 			.domains		= domain_init(RDT_RESOURCE_MBA),
+ 			.parse_ctrlval		= parse_bw,
+ 			.format_str		= "%d=%*u",
+ 			.fflags			= RFTYPE_RES_MB,
+ 		},
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  	},
  };
  
@@@ -339,22 -264,14 +385,30 @@@ static void rdt_get_cache_alloc_cfg(in
  	r->alloc_enabled = true;
  }
  
- static void rdt_get_cdp_config(int level, int type)
+ static void rdt_get_cdp_config(int level)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r_l = &rdt_resources_all[level];
 +	struct rdt_resource *r = &rdt_resources_all[type];
 +
 +	r->num_closid = r_l->num_closid / 2;
 +	r->cache.cbm_len = r_l->cache.cbm_len;
 +	r->default_ctrl = r_l->default_ctrl;
 +	r->cache.shareable_bits = r_l->cache.shareable_bits;
 +	r->data_width = (r->cache.cbm_len + 3) / 4;
 +	r->alloc_capable = true;
++=======
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  	/*
  	 * By default, CDP is disabled. CDP can be enabled by mount parameter
  	 * "cdp" during resctrl file system mount time.
  	 */
++<<<<<<< HEAD
 +	r->alloc_enabled = false;
++=======
+ 	rdt_resources_all[level].cdp_enabled = false;
+ 	rdt_resources_all[level].r_resctrl.cdp_capable = true;
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  }
  
  static void rdt_get_cdp_l3_config(void)
@@@ -495,11 -423,15 +547,21 @@@ static int domain_setup_ctrlval(struct 
  	struct msr_param m;
  	u32 *dc, *dm;
  
++<<<<<<< HEAD
 +	dc = kmalloc_array(r->num_closid, sizeof(*d->ctrl_val), GFP_KERNEL);
 +	if (!dc)
 +		return -ENOMEM;
 +
 +	dm = kmalloc_array(r->num_closid, sizeof(*d->mbps_val), GFP_KERNEL);
++=======
+ 	dc = kmalloc_array(hw_res->num_closid, sizeof(*hw_dom->ctrl_val),
+ 			   GFP_KERNEL);
+ 	if (!dc)
+ 		return -ENOMEM;
+ 
+ 	dm = kmalloc_array(hw_res->num_closid, sizeof(*hw_dom->mbps_val),
+ 			   GFP_KERNEL);
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  	if (!dm) {
  		kfree(dc);
  		return -ENOMEM;
@@@ -654,8 -590,8 +716,13 @@@ static void domain_remove_cpu(int cpu, 
  		if (d->plr)
  			d->plr->d = NULL;
  
++<<<<<<< HEAD
 +		kfree(d->ctrl_val);
 +		kfree(d->mbps_val);
++=======
+ 		kfree(hw_dom->ctrl_val);
+ 		kfree(hw_dom->mbps_val);
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  		bitmap_free(d->rmid_busy_llc);
  		kfree(d->mbm_total);
  		kfree(d->mbm_local);
@@@ -929,12 -867,11 +996,8 @@@ static __init void rdt_init_res_defs_in
  	struct rdt_resource *r;
  
  	for_each_rdt_resource(r) {
 -		hw_res = resctrl_to_arch_res(r);
 -
  		if (r->rid == RDT_RESOURCE_L3 ||
- 		    r->rid == RDT_RESOURCE_L3DATA ||
- 		    r->rid == RDT_RESOURCE_L3CODE ||
- 		    r->rid == RDT_RESOURCE_L2 ||
- 		    r->rid == RDT_RESOURCE_L2DATA ||
- 		    r->rid == RDT_RESOURCE_L2CODE) {
+ 		    r->rid == RDT_RESOURCE_L2) {
  			r->cache.arch_has_sparse_bitmaps = false;
  			r->cache.arch_has_empty_bitmaps = false;
  			r->cache.arch_has_per_cpu_cfg = false;
@@@ -950,12 -887,11 +1013,8 @@@ static __init void rdt_init_res_defs_am
  	struct rdt_resource *r;
  
  	for_each_rdt_resource(r) {
 -		hw_res = resctrl_to_arch_res(r);
 -
  		if (r->rid == RDT_RESOURCE_L3 ||
- 		    r->rid == RDT_RESOURCE_L3DATA ||
- 		    r->rid == RDT_RESOURCE_L3CODE ||
- 		    r->rid == RDT_RESOURCE_L2 ||
- 		    r->rid == RDT_RESOURCE_L2DATA ||
- 		    r->rid == RDT_RESOURCE_L2CODE) {
+ 		    r->rid == RDT_RESOURCE_L2) {
  			r->cache.arch_has_sparse_bitmaps = true;
  			r->cache.arch_has_empty_bitmaps = true;
  			r->cache.arch_has_per_cpu_cfg = true;
diff --cc arch/x86/kernel/cpu/resctrl/internal.h
index 9780c2d2c637,1d647188a43b..000000000000
--- a/arch/x86/kernel/cpu/resctrl/internal.h
+++ b/arch/x86/kernel/cpu/resctrl/internal.h
@@@ -446,40 -368,26 +446,56 @@@ struct rdt_parse_data 
  };
  
  /**
++<<<<<<< HEAD
 + * struct rdt_resource - attributes of an RDT resource
 + * @rid:		The index of the resource
 + * @alloc_enabled:	Is allocation enabled on this machine
 + * @mon_enabled:	Is monitoring enabled for this feature
 + * @alloc_capable:	Is allocation available on this machine
 + * @mon_capable:	Is monitor feature available on this machine
 + * @name:		Name to use in "schemata" file
 + * @num_closid:		Number of CLOSIDs available
 + * @cache_level:	Which cache level defines scope of this resource
 + * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
++=======
+  * struct rdt_hw_resource - arch private attributes of a resctrl resource
+  * @r_resctrl:		Attributes of the resource used directly by resctrl.
+  * @num_closid:		Maximum number of closid this hardware can support,
+  *			regardless of CDP. This is exposed via
+  *			resctrl_arch_get_num_closid() to avoid confusion
+  *			with struct resctrl_schema's property of the same name,
+  *			which has been corrected for features like CDP.
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
   * @msr_base:		Base MSR address for CBMs
   * @msr_update:		Function pointer to update QOS MSRs
 + * @data_width:		Character width of data when displaying
 + * @domains:		All domains for this resource
 + * @cache:		Cache allocation related data
 + * @membw:		If the component has bandwidth controls, their properties.
 + * @format_str:		Per resource format string to show domain value
 + * @parse_ctrlval:	Per resource function pointer to parse control values
 + * @evt_list:		List of monitoring events
 + * @num_rmid:		Number of RMIDs available
   * @mon_scale:		cqm counter * mon_scale = occupancy in bytes
   * @mbm_width:		Monitor width, to detect and correct for overflow.
 - * @cdp_enabled:	CDP state of this resource
 - *
 - * Members of this structure are either private to the architecture
 - * e.g. mbm_width, or accessed via helpers that provide abstraction. e.g.
 - * msr_update and msr_base.
 + * @fflags:		flags to choose base and info files
   */
++<<<<<<< HEAD
 +struct rdt_resource {
 +	int			rid;
 +	bool			alloc_enabled;
 +	bool			mon_enabled;
 +	bool			alloc_capable;
 +	bool			mon_capable;
 +	char			*name;
 +	int			num_closid;
 +	int			cache_level;
 +	u32			default_ctrl;
++=======
+ struct rdt_hw_resource {
+ 	struct rdt_resource	r_resctrl;
+ 	u32			num_closid;
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  	unsigned int		msr_base;
  	void (*msr_update)	(struct rdt_domain *d, struct msr_param *m,
  				 struct rdt_resource *r);
@@@ -511,13 -414,9 +527,9 @@@ DECLARE_STATIC_KEY_FALSE(rdt_alloc_enab
  
  extern struct dentry *debugfs_resctrl;
  
 -enum resctrl_res_level {
 +enum {
  	RDT_RESOURCE_L3,
- 	RDT_RESOURCE_L3DATA,
- 	RDT_RESOURCE_L3CODE,
  	RDT_RESOURCE_L2,
- 	RDT_RESOURCE_L2DATA,
- 	RDT_RESOURCE_L2CODE,
  	RDT_RESOURCE_MBA,
  
  	/* Must be the last */
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index a8731279ffbf,89123a4977cf..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -1941,14 -1875,16 +1941,22 @@@ static int set_cache_qos_cfg(int level
  /* Restore the qos cfg state when a domain comes online */
  void rdt_domain_reconfigure_cdp(struct rdt_resource *r)
  {
 -	struct rdt_hw_resource *hw_res = resctrl_to_arch_res(r);
 -
 -	if (!r->cdp_capable)
 +	if (!r->alloc_capable)
  		return;
  
++<<<<<<< HEAD
 +	if (r == &rdt_resources_all[RDT_RESOURCE_L2DATA])
 +		l2_qos_cfg_update(&r->alloc_enabled);
 +
 +	if (r == &rdt_resources_all[RDT_RESOURCE_L3DATA])
 +		l3_qos_cfg_update(&r->alloc_enabled);
++=======
+ 	if (r->rid == RDT_RESOURCE_L2)
+ 		l2_qos_cfg_update(&hw_res->cdp_enabled);
+ 
+ 	if (r->rid == RDT_RESOURCE_L3)
+ 		l3_qos_cfg_update(&hw_res->cdp_enabled);
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  }
  
  /*
@@@ -1973,59 -1912,44 +1981,92 @@@ static int set_mba_sc(bool mba_sc
  	return 0;
  }
  
- static int cdp_enable(int level, int data_type, int code_type)
+ static int cdp_enable(int level)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r_ldata = &rdt_resources_all[data_type];
 +	struct rdt_resource *r_lcode = &rdt_resources_all[code_type];
 +	struct rdt_resource *r_l = &rdt_resources_all[level];
++=======
+ 	struct rdt_resource *r_l = &rdt_resources_all[level].r_resctrl;
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  	int ret;
  
- 	if (!r_l->alloc_capable || !r_ldata->alloc_capable ||
- 	    !r_lcode->alloc_capable)
+ 	if (!r_l->alloc_capable)
  		return -EINVAL;
  
  	ret = set_cache_qos_cfg(level, true);
++<<<<<<< HEAD
 +	if (!ret) {
 +		r_l->alloc_enabled = false;
 +		r_ldata->alloc_enabled = true;
 +		r_lcode->alloc_enabled = true;
 +	}
 +	return ret;
 +}
 +
 +static int cdpl3_enable(void)
 +{
 +	return cdp_enable(RDT_RESOURCE_L3, RDT_RESOURCE_L3DATA,
 +			  RDT_RESOURCE_L3CODE);
 +}
 +
 +static int cdpl2_enable(void)
 +{
 +	return cdp_enable(RDT_RESOURCE_L2, RDT_RESOURCE_L2DATA,
 +			  RDT_RESOURCE_L2CODE);
 +}
 +
 +static void cdp_disable(int level, int data_type, int code_type)
 +{
 +	struct rdt_resource *r = &rdt_resources_all[level];
 +
 +	r->alloc_enabled = r->alloc_capable;
 +
 +	if (rdt_resources_all[data_type].alloc_enabled) {
 +		rdt_resources_all[data_type].alloc_enabled = false;
 +		rdt_resources_all[code_type].alloc_enabled = false;
 +		set_cache_qos_cfg(level, false);
++=======
+ 	if (!ret)
+ 		rdt_resources_all[level].cdp_enabled = true;
+ 
+ 	return ret;
+ }
+ 
+ static void cdp_disable(int level)
+ {
+ 	struct rdt_hw_resource *r_hw = &rdt_resources_all[level];
+ 
+ 	if (r_hw->cdp_enabled) {
+ 		set_cache_qos_cfg(level, false);
+ 		r_hw->cdp_enabled = false;
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  	}
  }
  
 -int resctrl_arch_set_cdp_enabled(enum resctrl_res_level l, bool enable)
 +static void cdpl3_disable(void)
  {
++<<<<<<< HEAD
 +	cdp_disable(RDT_RESOURCE_L3, RDT_RESOURCE_L3DATA, RDT_RESOURCE_L3CODE);
 +}
 +
 +static void cdpl2_disable(void)
 +{
 +	cdp_disable(RDT_RESOURCE_L2, RDT_RESOURCE_L2DATA, RDT_RESOURCE_L2CODE);
++=======
+ 	struct rdt_hw_resource *hw_res = &rdt_resources_all[l];
+ 
+ 	if (!hw_res->r_resctrl.cdp_capable)
+ 		return -EINVAL;
+ 
+ 	if (enable)
+ 		return cdp_enable(l);
+ 
+ 	cdp_disable(l);
+ 
+ 	return 0;
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  }
  
  static void cdp_disable_all(void)
@@@ -2122,6 -2046,92 +2163,95 @@@ static int rdt_enable_ctx(struct rdt_fs
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int schemata_list_add(struct rdt_resource *r, enum resctrl_conf_type type)
+ {
+ 	struct resctrl_schema *s;
+ 	const char *suffix = "";
+ 	int ret, cl;
+ 
+ 	s = kzalloc(sizeof(*s), GFP_KERNEL);
+ 	if (!s)
+ 		return -ENOMEM;
+ 
+ 	s->res = r;
+ 	s->num_closid = resctrl_arch_get_num_closid(r);
+ 	if (resctrl_arch_get_cdp_enabled(r->rid))
+ 		s->num_closid /= 2;
+ 
+ 	s->conf_type = type;
+ 	switch (type) {
+ 	case CDP_CODE:
+ 		suffix = "CODE";
+ 		break;
+ 	case CDP_DATA:
+ 		suffix = "DATA";
+ 		break;
+ 	case CDP_NONE:
+ 		suffix = "";
+ 		break;
+ 	}
+ 
+ 	ret = snprintf(s->name, sizeof(s->name), "%s%s", r->name, suffix);
+ 	if (ret >= sizeof(s->name)) {
+ 		kfree(s);
+ 		return -EINVAL;
+ 	}
+ 
+ 	cl = strlen(s->name);
+ 
+ 	/*
+ 	 * If CDP is supported by this resource, but not enabled,
+ 	 * include the suffix. This ensures the tabular format of the
+ 	 * schemata file does not change between mounts of the filesystem.
+ 	 */
+ 	if (r->cdp_capable && !resctrl_arch_get_cdp_enabled(r->rid))
+ 		cl += 4;
+ 
+ 	if (cl > max_name_width)
+ 		max_name_width = cl;
+ 
+ 	INIT_LIST_HEAD(&s->list);
+ 	list_add(&s->list, &resctrl_schema_all);
+ 
+ 	return 0;
+ }
+ 
+ static int schemata_list_create(void)
+ {
+ 	struct rdt_resource *r;
+ 	int ret = 0;
+ 
+ 	for_each_alloc_enabled_rdt_resource(r) {
+ 		if (resctrl_arch_get_cdp_enabled(r->rid)) {
+ 			ret = schemata_list_add(r, CDP_CODE);
+ 			if (ret)
+ 				break;
+ 
+ 			ret = schemata_list_add(r, CDP_DATA);
+ 		} else {
+ 			ret = schemata_list_add(r, CDP_NONE);
+ 		}
+ 
+ 		if (ret)
+ 			break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void schemata_list_destroy(void)
+ {
+ 	struct resctrl_schema *s, *tmp;
+ 
+ 	list_for_each_entry_safe(s, tmp, &resctrl_schema_all, list) {
+ 		list_del(&s->list);
+ 		kfree(s);
+ 	}
+ }
+ 
++>>>>>>> 5c3b63cdba44 (x86/resctrl: Merge the CDP resources)
  static int rdt_get_tree(struct fs_context *fc)
  {
  	struct rdt_fs_context *ctx = rdt_fc2context(fc);
* Unmerged path arch/x86/kernel/cpu/resctrl/core.c
* Unmerged path arch/x86/kernel/cpu/resctrl/internal.h
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
