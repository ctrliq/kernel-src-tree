x86/microcode: Rip out the OLD_INTERFACE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Borislav Petkov <bp@suse.de>
commit 181b6f40e9ea80c76756d4d0cdeed396016c487e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/181b6f40.failed

Everything should be using the early initrd loading by now.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20220525161232.14924-2-bp@alien8.de

(cherry picked from commit 181b6f40e9ea80c76756d4d0cdeed396016c487e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
#	arch/x86/kernel/cpu/microcode/core.c
diff --cc arch/x86/Kconfig
index f26d1d596e9a,f423a2d87b15..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -1360,13 -1350,9 +1360,16 @@@ config MICROCODE_AM
  	  If you select this option, microcode patch loading support for AMD
  	  processors will be enabled.
  
++<<<<<<< HEAD
 +config MICROCODE_OLD_INTERFACE
 +	def_bool y
 +	depends on MICROCODE
 +
++=======
++>>>>>>> 181b6f40e9ea (x86/microcode: Rip out the OLD_INTERFACE)
  config X86_MSR
  	tristate "/dev/cpu/*/msr - Model-specific register support"
 -	help
 +	---help---
  	  This device gives privileged processes access to the x86
  	  Model-Specific Registers (MSRs).  It is a character device with
  	  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
diff --cc arch/x86/kernel/cpu/microcode/core.c
index fb1f03e6cf05,b72c4134f289..000000000000
--- a/arch/x86/kernel/cpu/microcode/core.c
+++ b/arch/x86/kernel/cpu/microcode/core.c
@@@ -392,98 -373,6 +392,101 @@@ static int apply_microcode_on_target(in
  	return ret;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MICROCODE_OLD_INTERFACE
 +static int do_microcode_update(const void __user *buf, size_t size)
 +{
 +	int error = 0;
 +	int cpu;
 +
 +	for_each_online_cpu(cpu) {
 +		struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
 +		enum ucode_state ustate;
 +
 +		if (!uci->valid)
 +			continue;
 +
 +		ustate = microcode_ops->request_microcode_user(cpu, buf, size);
 +		if (ustate == UCODE_ERROR) {
 +			error = -1;
 +			break;
 +		} else if (ustate == UCODE_NEW) {
 +			apply_microcode_on_target(cpu);
 +		}
 +	}
 +
 +	return error;
 +}
 +
 +static int microcode_open(struct inode *inode, struct file *file)
 +{
 +	return capable(CAP_SYS_RAWIO) ? nonseekable_open(inode, file) : -EPERM;
 +}
 +
 +static ssize_t microcode_write(struct file *file, const char __user *buf,
 +			       size_t len, loff_t *ppos)
 +{
 +	ssize_t ret = -EINVAL;
 +	unsigned long nr_pages = totalram_pages();
 +
 +	if ((len >> PAGE_SHIFT) > nr_pages) {
 +		pr_err("too much data (max %ld pages)\n", nr_pages);
 +		return ret;
 +	}
 +
 +	cpus_read_lock();
 +	mutex_lock(&microcode_mutex);
 +
 +	if (do_microcode_update(buf, len) == 0)
 +		ret = (ssize_t)len;
 +
 +	if (ret > 0)
 +		perf_check_microcode();
 +
 +	mutex_unlock(&microcode_mutex);
 +	cpus_read_unlock();
 +
 +	return ret;
 +}
 +
 +static const struct file_operations microcode_fops = {
 +	.owner			= THIS_MODULE,
 +	.write			= microcode_write,
 +	.open			= microcode_open,
 +	.llseek		= no_llseek,
 +};
 +
 +static struct miscdevice microcode_dev = {
 +	.minor			= MICROCODE_MINOR,
 +	.name			= "microcode",
 +	.nodename		= "cpu/microcode",
 +	.fops			= &microcode_fops,
 +};
 +
 +static int __init microcode_dev_init(void)
 +{
 +	int error;
 +
 +	error = misc_register(&microcode_dev);
 +	if (error) {
 +		pr_err("can't misc_register on minor=%d\n", MICROCODE_MINOR);
 +		return error;
 +	}
 +
 +	return 0;
 +}
 +
 +static void __exit microcode_dev_exit(void)
 +{
 +	misc_deregister(&microcode_dev);
 +}
 +#else
 +#define microcode_dev_init()	0
 +#define microcode_dev_exit()	do { } while (0)
 +#endif
 +
++=======
++>>>>>>> 181b6f40e9ea (x86/microcode: Rip out the OLD_INTERFACE)
  /* fake device for request_firmware */
  static struct platform_device	*microcode_pdev;
  
* Unmerged path arch/x86/Kconfig
* Unmerged path arch/x86/kernel/cpu/microcode/core.c
