s390/ism: Consolidate SMC-D-related code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Stefan Raspl <raspl@linux.ibm.com>
commit 820f21009f1bc7a69e28752f6c6d9544401ca526
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/820f2100.failed

The ism module had SMC-D-specific code sprinkled across the entire module.
We are now consolidating the SMC-D-specific parts into the latter parts
of the module, so it becomes more clear what code is intended for use with
ISM, and which parts are glue code for usage in the context of SMC-D.
This is the fourth part of a bigger overhaul of the interfaces between SMC
and ISM.

	Signed-off-by: Stefan Raspl <raspl@linux.ibm.com>
	Signed-off-by: Jan Karcher <jaka@linux.ibm.com>
	Signed-off-by: Wenjia Zhang <wenjia@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 820f21009f1bc7a69e28752f6c6d9544401ca526)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/ism_drv.c
#	include/linux/ism.h
#	net/smc/smc_ism.c
diff --cc drivers/s390/net/ism_drv.c
index f8a04d468283,73c8f42a22a7..000000000000
--- a/drivers/s390/net/ism_drv.c
+++ b/drivers/s390/net/ism_drv.c
@@@ -281,15 -355,11 +281,19 @@@ static int ism_register_dmb(struct smcd
  out:
  	return ret;
  }
 -EXPORT_SYMBOL_GPL(ism_register_dmb);
  
++<<<<<<< HEAD
 +static int smcd_register_dmb(struct smcd_dev *smcd, struct smcd_dmb *dmb)
 +{
 +	return ism_register_dmb(smcd, (struct ism_dmb *)dmb);
 +}
 +
 +static int ism_unregister_dmb(struct smcd_dev *smcd, struct ism_dmb *dmb)
++=======
+ int ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  {
 +	struct ism_dev *ism = smcd->priv;
  	union ism_unreg_dmb cmd;
  	int ret;
  
@@@ -307,15 -379,10 +311,19 @@@
  out:
  	return ret;
  }
 -EXPORT_SYMBOL_GPL(ism_unregister_dmb);
  
++<<<<<<< HEAD
 +static int smcd_unregister_dmb(struct smcd_dev *smcd, struct smcd_dmb *dmb)
 +{
 +	return ism_unregister_dmb(smcd, (struct ism_dmb *)dmb);
 +}
 +
 +static int ism_add_vlan_id(struct smcd_dev *smcd, u64 vlan_id)
++=======
+ static int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  {
 +	struct ism_dev *ism = smcd->priv;
  	union ism_set_vlan_id cmd;
  
  	memset(&cmd, 0, sizeof(cmd));
@@@ -327,9 -394,8 +335,13 @@@
  	return ism_cmd(ism, &cmd);
  }
  
++<<<<<<< HEAD
 +static int ism_del_vlan_id(struct smcd_dev *smcd, u64 vlan_id)
++=======
+ static int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  {
 +	struct ism_dev *ism = smcd->priv;
  	union ism_set_vlan_id cmd;
  
  	memset(&cmd, 0, sizeof(cmd));
@@@ -341,20 -407,9 +353,26 @@@
  	return ism_cmd(ism, &cmd);
  }
  
++<<<<<<< HEAD
 +static int ism_set_vlan_required(struct smcd_dev *smcd)
 +{
 +	return ism_cmd_simple(smcd->priv, ISM_SET_VLAN);
 +}
 +
 +static int ism_reset_vlan_required(struct smcd_dev *smcd)
 +{
 +	return ism_cmd_simple(smcd->priv, ISM_RESET_VLAN);
 +}
 +
 +static int ism_signal_ieq(struct smcd_dev *smcd, u64 rgid, u32 trigger_irq,
 +			  u32 event_code, u64 info)
 +{
 +	struct ism_dev *ism = smcd->priv;
++=======
+ static int ism_signal_ieq(struct ism_dev *ism, u64 rgid, u32 trigger_irq,
+ 			  u32 event_code, u64 info)
+ {
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  	union ism_sig_ieq cmd;
  
  	memset(&cmd, 0, sizeof(cmd));
@@@ -375,10 -430,9 +393,14 @@@ static unsigned int max_bytes(unsigned 
  	return min(boundary - (start & (boundary - 1)), len);
  }
  
++<<<<<<< HEAD
 +static int ism_move(struct smcd_dev *smcd, u64 dmb_tok, unsigned int idx,
 +		    bool sf, unsigned int offset, void *data, unsigned int size)
++=======
+ int ism_move(struct ism_dev *ism, u64 dmb_tok, unsigned int idx, bool sf,
+ 	     unsigned int offset, void *data, unsigned int size)
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  {
- 	struct ism_dev *ism = smcd->priv;
  	unsigned int bytes;
  	u64 dmb_req;
  	int ret;
@@@ -424,11 -479,10 +447,16 @@@ static u8 *ism_get_system_eid(void
  {
  	return SYSTEM_EID.seid_string;
  }
 -EXPORT_SYMBOL_GPL(ism_get_seid);
  
++<<<<<<< HEAD
 +static u16 ism_get_chid(struct smcd_dev *smcd)
 +{
 +	struct ism_dev *ism = (struct ism_dev *)smcd->priv;
 +
++=======
+ static u16 ism_get_chid(struct ism_dev *ism)
+ {
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  	if (!ism || !ism->pdev)
  		return 0;
  
@@@ -483,19 -544,20 +511,36 @@@ static irqreturn_t ism_handle_irq(int i
  	return IRQ_HANDLED;
  }
  
++<<<<<<< HEAD
 +static const struct smcd_ops ism_ops = {
 +	.query_remote_gid = ism_query_rgid,
 +	.register_dmb = smcd_register_dmb,
 +	.unregister_dmb = smcd_unregister_dmb,
 +	.add_vlan_id = ism_add_vlan_id,
 +	.del_vlan_id = ism_del_vlan_id,
 +	.set_vlan_required = ism_set_vlan_required,
 +	.reset_vlan_required = ism_reset_vlan_required,
 +	.signal_event = ism_signal_ieq,
 +	.move_data = ism_move,
 +	.get_system_eid = ism_get_system_eid,
 +	.get_chid = ism_get_chid,
 +};
++=======
+ static u64 ism_get_local_gid(struct ism_dev *ism)
+ {
+ 	return ism->local_gid;
+ }
+ 
+ static void ism_dev_add_work_func(struct work_struct *work)
+ {
+ 	struct ism_client *client = container_of(work, struct ism_client,
+ 						 add_work);
+ 
+ 	client->add(client->tgt_ism);
+ 	atomic_dec(&client->tgt_ism->add_dev_cnt);
+ 	wake_up(&client->tgt_ism->waitq);
+ }
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  
  static int ism_dev_init(struct ism_dev *ism)
  {
diff --cc include/linux/ism.h
index 69bfbf0faaa1,104ce2fd503a..000000000000
--- a/include/linux/ism.h
+++ b/include/linux/ism.h
@@@ -20,4 -22,78 +20,81 @@@ struct ism_dmb 
  	dma_addr_t dma_addr;
  };
  
++<<<<<<< HEAD
++=======
+ /* Unless we gain unexpected popularity, this limit should hold for a while */
+ #define MAX_CLIENTS		8
+ #define ISM_NR_DMBS		1920
+ 
+ struct ism_dev {
+ 	spinlock_t lock; /* protects the ism device */
+ 	struct list_head list;
+ 	struct pci_dev *pdev;
+ 	struct smcd_dev *smcd;
+ 
+ 	struct ism_sba *sba;
+ 	dma_addr_t sba_dma_addr;
+ 	DECLARE_BITMAP(sba_bitmap, ISM_NR_DMBS);
+ 	u8 *sba_client_arr;	/* entries are indices into 'clients' array */
+ 	void *priv[MAX_CLIENTS];
+ 
+ 	struct ism_eq *ieq;
+ 	dma_addr_t ieq_dma_addr;
+ 
+ 	struct device dev;
+ 	u64 local_gid;
+ 	int ieq_idx;
+ 
+ 	atomic_t free_clients_cnt;
+ 	atomic_t add_dev_cnt;
+ 	wait_queue_head_t waitq;
+ };
+ 
+ struct ism_event {
+ 	u32 type;
+ 	u32 code;
+ 	u64 tok;
+ 	u64 time;
+ 	u64 info;
+ };
+ 
+ struct ism_client {
+ 	const char *name;
+ 	void (*add)(struct ism_dev *dev);
+ 	void (*remove)(struct ism_dev *dev);
+ 	void (*handle_event)(struct ism_dev *dev, struct ism_event *event);
+ 	/* Parameter dmbemask contains a bit vector with updated DMBEs, if sent
+ 	 * via ism_move_data(). Callback function must handle all active bits
+ 	 * indicated by dmbemask.
+ 	 */
+ 	void (*handle_irq)(struct ism_dev *dev, unsigned int bit, u16 dmbemask);
+ 	/* Private area - don't touch! */
+ 	struct work_struct remove_work;
+ 	struct work_struct add_work;
+ 	struct ism_dev *tgt_ism;
+ 	u8 id;
+ };
+ 
+ int ism_register_client(struct ism_client *client);
+ int  ism_unregister_client(struct ism_client *client);
+ static inline void *ism_get_priv(struct ism_dev *dev,
+ 				 struct ism_client *client) {
+ 	return dev->priv[client->id];
+ }
+ 
+ static inline void ism_set_priv(struct ism_dev *dev, struct ism_client *client,
+ 				void *priv) {
+ 	dev->priv[client->id] = priv;
+ }
+ 
+ int  ism_register_dmb(struct ism_dev *dev, struct ism_dmb *dmb,
+ 		      struct ism_client *client);
+ int  ism_unregister_dmb(struct ism_dev *dev, struct ism_dmb *dmb);
+ int  ism_move(struct ism_dev *dev, u64 dmb_tok, unsigned int idx, bool sf,
+ 	      unsigned int offset, void *data, unsigned int size);
+ u8  *ism_get_seid(void);
+ 
+ const struct smcd_ops *ism_get_smcd_ops(void);
+ 
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  #endif	/* _ISM_H */
diff --cc net/smc/smc_ism.c
index 71e38768fea2,6196b305df44..000000000000
--- a/net/smc/smc_ism.c
+++ b/net/smc/smc_ism.c
@@@ -25,6 -27,22 +25,25 @@@ struct smcd_dev_list smcd_dev_list = 
  static bool smc_ism_v2_capable;
  static u8 smc_ism_v2_system_eid[SMC_MAX_EID_LEN];
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_ISM)
+ static void smcd_register_dev(struct ism_dev *ism);
+ static void smcd_unregister_dev(struct ism_dev *ism);
+ static void smcd_handle_event(struct ism_dev *ism, struct ism_event *event);
+ static void smcd_handle_irq(struct ism_dev *ism, unsigned int dmbno,
+ 			    u16 dmbemask);
+ 
+ static struct ism_client smc_ism_client = {
+ 	.name = "SMC-D",
+ 	.add = smcd_register_dev,
+ 	.remove = smcd_unregister_dev,
+ 	.handle_event = smcd_handle_event,
+ 	.handle_irq = smcd_handle_irq,
+ };
+ #endif
+ 
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  /* Test if an ISM communication is possible - same CPC */
  int smc_ism_cantalk(u64 peer_gid, unsigned short vlan_id, struct smcd_dev *smcd)
  {
@@@ -420,9 -423,28 +426,32 @@@ struct smcd_dev *smcd_alloc_dev(struct 
  }
  EXPORT_SYMBOL_GPL(smcd_alloc_dev);
  
 -void smcd_free_dev(struct smcd_dev *smcd)
 +int smcd_register_dev(struct smcd_dev *smcd)
  {
++<<<<<<< HEAD
 +	int rc;
++=======
+ 	put_device(&smcd->dev);
+ }
+ EXPORT_SYMBOL_GPL(smcd_free_dev);
+ 
+ static void smcd_register_dev(struct ism_dev *ism)
+ {
+ 	const struct smcd_ops *ops = ism_get_smcd_ops();
+ 	struct smcd_dev *smcd;
+ 
+ 	if (!ops)
+ 		return;
+ 
+ 	smcd = smcd_alloc_dev(&ism->pdev->dev, dev_name(&ism->pdev->dev), ops,
+ 			      ISM_NR_DMBS);
+ 	if (!smcd)
+ 		return;
+ 	smcd->priv = ism;
+ 	ism_set_priv(ism, &smc_ism_client, smcd);
+ 	if (smc_pnetid_by_dev_port(&ism->pdev->dev, 0, smcd->pnetid))
+ 		smc_pnetid_by_table_smcd(smcd);
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  
  	mutex_lock(&smcd_dev_list.mutex);
  	if (list_empty(&smcd_dev_list.list)) {
@@@ -524,10 -542,44 +553,51 @@@ void smcd_handle_irq(struct smcd_dev *s
  		tasklet_schedule(&conn->rx_tsklet);
  	spin_unlock_irqrestore(&smcd->lock, flags);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(smcd_handle_irq);
++=======
+ #endif
+ 
+ int smc_ism_signal_shutdown(struct smc_link_group *lgr)
+ {
+ 	int rc = 0;
+ #if IS_ENABLED(CONFIG_ISM)
+ 	union smcd_sw_event_info ev_info;
+ 
+ 	if (lgr->peer_shutdown)
+ 		return 0;
+ 
+ 	memcpy(ev_info.uid, lgr->id, SMC_LGR_ID_SIZE);
+ 	ev_info.vlan_id = lgr->vlan_id;
+ 	ev_info.code = ISM_EVENT_REQUEST;
+ 	rc = lgr->smcd->ops->signal_event(lgr->smcd, lgr->peer_gid,
+ 					  ISM_EVENT_REQUEST_IR,
+ 					  ISM_EVENT_CODE_SHUTDOWN,
+ 					  ev_info.info);
+ #endif
+ 	return rc;
+ }
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  
 -int smc_ism_init(void)
 +void __init smc_ism_init(void)
  {
+ 	int rc = 0;
+ 
+ #if IS_ENABLED(CONFIG_ISM)
  	smc_ism_v2_capable = false;
  	memset(smc_ism_v2_system_eid, 0, SMC_MAX_EID_LEN);
++<<<<<<< HEAD
++=======
+ 
+ 	rc = ism_register_client(&smc_ism_client);
+ #endif
+ 	return rc;
+ }
+ 
+ void smc_ism_exit(void)
+ {
+ #if IS_ENABLED(CONFIG_ISM)
+ 	ism_unregister_client(&smc_ism_client);
+ #endif
++>>>>>>> 820f21009f1b (s390/ism: Consolidate SMC-D-related code)
  }
* Unmerged path drivers/s390/net/ism_drv.c
* Unmerged path include/linux/ism.h
diff --git a/include/net/smc.h b/include/net/smc.h
index 421a7197b475..e59cee2d439f 100644
--- a/include/net/smc.h
+++ b/include/net/smc.h
@@ -50,11 +50,13 @@ struct smcd_event {
 };
 
 struct smcd_dev;
+struct ism_client;
 
 struct smcd_ops {
 	int (*query_remote_gid)(struct smcd_dev *dev, u64 rgid, u32 vid_valid,
 				u32 vid);
-	int (*register_dmb)(struct smcd_dev *dev, struct smcd_dmb *dmb);
+	int (*register_dmb)(struct smcd_dev *dev, struct smcd_dmb *dmb,
+			    struct ism_client *client);
 	int (*unregister_dmb)(struct smcd_dev *dev, struct smcd_dmb *dmb);
 	int (*add_vlan_id)(struct smcd_dev *dev, u64 vlan_id);
 	int (*del_vlan_id)(struct smcd_dev *dev, u64 vlan_id);
* Unmerged path net/smc/smc_ism.c
