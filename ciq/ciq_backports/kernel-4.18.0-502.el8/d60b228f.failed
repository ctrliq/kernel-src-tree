arm64: entry: split SDEI entry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit d60b228fd19985a903b8e8c599be0538a875d505
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/d60b228f.failed

We'd like to keep all the entry sequencing in entry-common.c, as this
will allow us to ensure this is consistent, and free from any unsound
instrumentation.

Currently __sdei_handler() performs the NMI entry/exit sequences in
sdei.c. Let's split the low-level entry sequence from the event
handling, moving the former to entry-common.c and keeping the latter in
sdei.c. The event handling function is renamed to do_sdei_event(),
matching the do_${FOO}() pattern used for other exception handlers.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Acked-by: Marc Zyngier <maz@kernel.org>
	Reviewed-by: Joey Gouly <joey.gouly@arm.com>
	Cc: James Morse <james.morse@arm.com>
	Cc: Will Deacon <will@kernel.org>
Link: https://lore.kernel.org/r/20210607094624.34689-18-mark.rutland@arm.com
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit d60b228fd19985a903b8e8c599be0538a875d505)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/entry-common.c
#	arch/arm64/kernel/sdei.c
diff --cc arch/arm64/kernel/entry-common.c
index c764ba2d11d7,1b32ca3848f5..000000000000
--- a/arch/arm64/kernel/entry-common.c
+++ b/arch/arm64/kernel/entry-common.c
@@@ -15,7 -19,11 +15,13 @@@
  #include <asm/exception.h>
  #include <asm/kprobes.h>
  #include <asm/mmu.h>
++<<<<<<< HEAD
++=======
+ #include <asm/processor.h>
+ #include <asm/sdei.h>
+ #include <asm/stacktrace.h>
++>>>>>>> d60b228fd199 (arm64: entry: split SDEI entry)
  #include <asm/sysreg.h>
 -#include <asm/system_misc.h>
  
  /*
   * This is intended to match the logic in irqentry_enter(), handling the kernel
@@@ -413,4 -679,71 +419,54 @@@ asmlinkage void noinstr el0_sync_compat
  		el0_inv(regs, esr);
  	}
  }
 -
 -asmlinkage void noinstr el0t_32_irq_handler(struct pt_regs *regs)
 -{
 -	__el0_irq_handler_common(regs);
 -}
 -
 -asmlinkage void noinstr el0t_32_fiq_handler(struct pt_regs *regs)
 -{
 -	__el0_fiq_handler_common(regs);
 -}
 -
 -asmlinkage void noinstr el0t_32_error_handler(struct pt_regs *regs)
 -{
 -	__el0_error_handler_common(regs);
 -}
 -#else /* CONFIG_COMPAT */
 -UNHANDLED(el0t, 32, sync)
 -UNHANDLED(el0t, 32, irq)
 -UNHANDLED(el0t, 32, fiq)
 -UNHANDLED(el0t, 32, error)
  #endif /* CONFIG_COMPAT */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_VMAP_STACK
+ asmlinkage void noinstr handle_bad_stack(struct pt_regs *regs)
+ {
+ 	unsigned int esr = read_sysreg(esr_el1);
+ 	unsigned long far = read_sysreg(far_el1);
+ 
+ 	arm64_enter_nmi(regs);
+ 	panic_bad_stack(regs, esr, far);
+ }
+ #endif /* CONFIG_VMAP_STACK */
+ 
+ #ifdef CONFIG_ARM_SDE_INTERFACE
+ asmlinkage noinstr unsigned long
+ __sdei_handler(struct pt_regs *regs, struct sdei_registered_event *arg)
+ {
+ 	unsigned long ret;
+ 
+ 	/*
+ 	 * We didn't take an exception to get here, so the HW hasn't
+ 	 * set/cleared bits in PSTATE that we may rely on.
+ 	 *
+ 	 * The original SDEI spec (ARM DEN 0054A) can be read ambiguously as to
+ 	 * whether PSTATE bits are inherited unchanged or generated from
+ 	 * scratch, and the TF-A implementation always clears PAN and always
+ 	 * clears UAO. There are no other known implementations.
+ 	 *
+ 	 * Subsequent revisions (ARM DEN 0054B) follow the usual rules for how
+ 	 * PSTATE is modified upon architectural exceptions, and so PAN is
+ 	 * either inherited or set per SCTLR_ELx.SPAN, and UAO is always
+ 	 * cleared.
+ 	 *
+ 	 * We must explicitly reset PAN to the expected state, including
+ 	 * clearing it when the host isn't using it, in case a VM had it set.
+ 	 */
+ 	if (system_uses_hw_pan())
+ 		set_pstate_pan(1);
+ 	else if (cpu_has_pan())
+ 		set_pstate_pan(0);
+ 
+ 	arm64_enter_nmi(regs);
+ 	ret = do_sdei_event(regs, arg);
+ 	arm64_exit_nmi(regs);
+ 
+ 	return ret;
+ }
+ #endif /* CONFIG_ARM_SDE_INTERFACE */
++>>>>>>> d60b228fd199 (arm64: entry: split SDEI entry)
diff --cc arch/arm64/kernel/sdei.c
index e396e69e33a1,e72953992743..000000000000
--- a/arch/arm64/kernel/sdei.c
+++ b/arch/arm64/kernel/sdei.c
@@@ -245,18 -292,3 +245,21 @@@ unsigned long __kprobes do_sdei_event(s
  
  	return vbar + 0x480;
  }
++<<<<<<< HEAD
 +
 +
 +asmlinkage __kprobes notrace unsigned long
 +__sdei_handler(struct pt_regs *regs, struct sdei_registered_event *arg)
 +{
 +	unsigned long ret;
 +
 +	nmi_enter();
 +
 +	ret = _sdei_handler(regs, arg);
 +
 +	nmi_exit();
 +
 +	return ret;
 +}
++=======
++>>>>>>> d60b228fd199 (arm64: entry: split SDEI entry)
diff --git a/arch/arm64/include/asm/sdei.h b/arch/arm64/include/asm/sdei.h
index ffe47d766c25..2a89d083c0f0 100644
--- a/arch/arm64/include/asm/sdei.h
+++ b/arch/arm64/include/asm/sdei.h
@@ -37,6 +37,9 @@ struct sdei_registered_event;
 asmlinkage unsigned long __sdei_handler(struct pt_regs *regs,
 					struct sdei_registered_event *arg);
 
+unsigned long do_sdei_event(struct pt_regs *regs,
+			    struct sdei_registered_event *arg);
+
 unsigned long sdei_arch_get_entry_point(int conduit);
 #define sdei_arch_get_entry_point(x)	sdei_arch_get_entry_point(x)
 
* Unmerged path arch/arm64/kernel/entry-common.c
* Unmerged path arch/arm64/kernel/sdei.c
