net/mlx5: Add IFC bits and enums for crypto key

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Jianbo Liu <jianbol@nvidia.com>
commit 9a0ed4f2bfe220e9389cc86d7f9b284119037eb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/9a0ed4f2.failed

Add and extend structure layouts and defines for fast crypto key
update. This is a prerequisite to support bulk creation, key
modification and destruction, software wrapped DEK, and SYNC_CRYPTO
command.

	Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 9a0ed4f2bfe220e9389cc86d7f9b284119037eb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mlx5/mlx5_ifc.h
diff --cc include/linux/mlx5/mlx5_ifc.h
index a4795284fa6c,7143b65f9f4a..000000000000
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@@ -1728,9 -1789,12 +1753,10 @@@ struct mlx5_ifc_cmd_hca_cap_bits 
  	u8         steering_format_version[0x4];
  	u8         create_qp_start_hint[0x18];
  
 -	u8         reserved_at_460[0x1];
 -	u8         ats[0x1];
 -	u8         reserved_at_462[0x1];
 +	u8         reserved_at_460[0x3];
  	u8         log_max_uctx[0x5];
- 	u8         reserved_at_468[0x2];
+ 	u8         reserved_at_468[0x1];
+ 	u8         crypto[0x1];
  	u8         ipsec_offload[0x1];
  	u8         log_max_umem[0x5];
  	u8         max_num_eqs[0x10];
@@@ -3316,6 -3420,8 +3366,11 @@@ union mlx5_ifc_hca_cap_union_bits 
  	struct mlx5_ifc_device_mem_cap_bits device_mem_cap;
  	struct mlx5_ifc_virtio_emulation_cap_bits virtio_emulation_cap;
  	struct mlx5_ifc_shampo_cap_bits shampo_cap;
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ifc_macsec_cap_bits macsec_cap;
+ 	struct mlx5_ifc_crypto_cap_bits crypto_cap;
++>>>>>>> 9a0ed4f2bfe2 (net/mlx5: Add IFC bits and enums for crypto key)
  	u8         reserved_at_0[0x8000];
  };
  
@@@ -11636,6 -11765,8 +11699,11 @@@ enum 
  	MLX5_GENERAL_OBJECT_TYPES_IPSEC = 0x13,
  	MLX5_GENERAL_OBJECT_TYPES_SAMPLER = 0x20,
  	MLX5_GENERAL_OBJECT_TYPES_FLOW_METER_ASO = 0x24,
++<<<<<<< HEAD
++=======
+ 	MLX5_GENERAL_OBJECT_TYPES_MACSEC = 0x27,
+ 	MLX5_GENERAL_OBJECT_TYPES_INT_KEK = 0x47,
++>>>>>>> 9a0ed4f2bfe2 (net/mlx5: Add IFC bits and enums for crypto key)
  };
  
  enum {
@@@ -11686,6 -11856,128 +11754,131 @@@ struct mlx5_ifc_modify_ipsec_obj_in_bit
  	struct mlx5_ifc_ipsec_obj_bits ipsec_object;
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	MLX5_MACSEC_ASO_REPLAY_PROTECTION = 0x1,
+ };
+ 
+ enum {
+ 	MLX5_MACSEC_ASO_REPLAY_WIN_32BIT  = 0x0,
+ 	MLX5_MACSEC_ASO_REPLAY_WIN_64BIT  = 0x1,
+ 	MLX5_MACSEC_ASO_REPLAY_WIN_128BIT = 0x2,
+ 	MLX5_MACSEC_ASO_REPLAY_WIN_256BIT = 0x3,
+ };
+ 
+ #define MLX5_MACSEC_ASO_INC_SN  0x2
+ #define MLX5_MACSEC_ASO_REG_C_4_5 0x2
+ 
+ struct mlx5_ifc_macsec_aso_bits {
+ 	u8    valid[0x1];
+ 	u8    reserved_at_1[0x1];
+ 	u8    mode[0x2];
+ 	u8    window_size[0x2];
+ 	u8    soft_lifetime_arm[0x1];
+ 	u8    hard_lifetime_arm[0x1];
+ 	u8    remove_flow_enable[0x1];
+ 	u8    epn_event_arm[0x1];
+ 	u8    reserved_at_a[0x16];
+ 
+ 	u8    remove_flow_packet_count[0x20];
+ 
+ 	u8    remove_flow_soft_lifetime[0x20];
+ 
+ 	u8    reserved_at_60[0x80];
+ 
+ 	u8    mode_parameter[0x20];
+ 
+ 	u8    replay_protection_window[8][0x20];
+ };
+ 
+ struct mlx5_ifc_macsec_offload_obj_bits {
+ 	u8    modify_field_select[0x40];
+ 
+ 	u8    confidentiality_en[0x1];
+ 	u8    reserved_at_41[0x1];
+ 	u8    epn_en[0x1];
+ 	u8    epn_overlap[0x1];
+ 	u8    reserved_at_44[0x2];
+ 	u8    confidentiality_offset[0x2];
+ 	u8    reserved_at_48[0x4];
+ 	u8    aso_return_reg[0x4];
+ 	u8    reserved_at_50[0x10];
+ 
+ 	u8    epn_msb[0x20];
+ 
+ 	u8    reserved_at_80[0x8];
+ 	u8    dekn[0x18];
+ 
+ 	u8    reserved_at_a0[0x20];
+ 
+ 	u8    sci[0x40];
+ 
+ 	u8    reserved_at_100[0x8];
+ 	u8    macsec_aso_access_pd[0x18];
+ 
+ 	u8    reserved_at_120[0x60];
+ 
+ 	u8    salt[3][0x20];
+ 
+ 	u8    reserved_at_1e0[0x20];
+ 
+ 	struct mlx5_ifc_macsec_aso_bits macsec_aso;
+ };
+ 
+ struct mlx5_ifc_create_macsec_obj_in_bits {
+ 	struct mlx5_ifc_general_obj_in_cmd_hdr_bits general_obj_in_cmd_hdr;
+ 	struct mlx5_ifc_macsec_offload_obj_bits macsec_object;
+ };
+ 
+ struct mlx5_ifc_modify_macsec_obj_in_bits {
+ 	struct mlx5_ifc_general_obj_in_cmd_hdr_bits general_obj_in_cmd_hdr;
+ 	struct mlx5_ifc_macsec_offload_obj_bits macsec_object;
+ };
+ 
+ enum {
+ 	MLX5_MODIFY_MACSEC_BITMASK_EPN_OVERLAP = BIT(0),
+ 	MLX5_MODIFY_MACSEC_BITMASK_EPN_MSB = BIT(1),
+ };
+ 
+ struct mlx5_ifc_query_macsec_obj_out_bits {
+ 	struct mlx5_ifc_general_obj_out_cmd_hdr_bits general_obj_out_cmd_hdr;
+ 	struct mlx5_ifc_macsec_offload_obj_bits macsec_object;
+ };
+ 
+ struct mlx5_ifc_wrapped_dek_bits {
+ 	u8         gcm_iv[0x60];
+ 
+ 	u8         reserved_at_60[0x20];
+ 
+ 	u8         const0[0x1];
+ 	u8         key_size[0x1];
+ 	u8         reserved_at_82[0x2];
+ 	u8         key2_invalid[0x1];
+ 	u8         reserved_at_85[0x3];
+ 	u8         pd[0x18];
+ 
+ 	u8         key_purpose[0x5];
+ 	u8         reserved_at_a5[0x13];
+ 	u8         kek_id[0x8];
+ 
+ 	u8         reserved_at_c0[0x40];
+ 
+ 	u8         key1[0x8][0x20];
+ 
+ 	u8         key2[0x8][0x20];
+ 
+ 	u8         reserved_at_300[0x40];
+ 
+ 	u8         const1[0x1];
+ 	u8         reserved_at_341[0x1f];
+ 
+ 	u8         reserved_at_360[0x20];
+ 
+ 	u8         auth_tag[0x80];
+ };
+ 
++>>>>>>> 9a0ed4f2bfe2 (net/mlx5: Add IFC bits and enums for crypto key)
  struct mlx5_ifc_encryption_key_obj_bits {
  	u8         modify_field_select[0x40];
  
* Unmerged path include/linux/mlx5/mlx5_ifc.h
