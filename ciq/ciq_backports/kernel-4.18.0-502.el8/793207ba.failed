x86/resctrl: Fix a silly -Wunused-but-set-variable warning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Borislav Petkov (AMD) <bp@alien8.de>
commit 793207bad71c5339c614d12ac21d627da7bf771d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/793207ba.failed

clang correctly complains

  arch/x86/kernel/cpu/resctrl/rdtgroup.c:1456:6: warning: variable \
     'h' set but not used [-Wunused-but-set-variable]
          u32 h;
              ^

but it can't know whether this use is innocuous or really a problem.
There's a reason why those warning switches are behind a W=1 and not
enabled by default - yes, one needs to do:

  make W=1 CC=clang HOSTCC=clang arch/x86/kernel/cpu/resctrl/

with clang 14 in order to trigger it.

I would normally not take a silly fix like that but this one is simple
and doesn't make the code uglier so...

	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Acked-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lore.kernel.org/r/202301242015.kbzkVteJ-lkp@intel.com
(cherry picked from commit 793207bad71c5339c614d12ac21d627da7bf771d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index 2b966c66b88f,e2c1599d1b37..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -1486,6 -1420,248 +1486,251 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct mon_config_info {
+ 	u32 evtid;
+ 	u32 mon_config;
+ };
+ 
+ #define INVALID_CONFIG_INDEX   UINT_MAX
+ 
+ /**
+  * mon_event_config_index_get - get the hardware index for the
+  *                              configurable event
+  * @evtid: event id.
+  *
+  * Return: 0 for evtid == QOS_L3_MBM_TOTAL_EVENT_ID
+  *         1 for evtid == QOS_L3_MBM_LOCAL_EVENT_ID
+  *         INVALID_CONFIG_INDEX for invalid evtid
+  */
+ static inline unsigned int mon_event_config_index_get(u32 evtid)
+ {
+ 	switch (evtid) {
+ 	case QOS_L3_MBM_TOTAL_EVENT_ID:
+ 		return 0;
+ 	case QOS_L3_MBM_LOCAL_EVENT_ID:
+ 		return 1;
+ 	default:
+ 		/* Should never reach here */
+ 		return INVALID_CONFIG_INDEX;
+ 	}
+ }
+ 
+ static void mon_event_config_read(void *info)
+ {
+ 	struct mon_config_info *mon_info = info;
+ 	unsigned int index;
+ 	u64 msrval;
+ 
+ 	index = mon_event_config_index_get(mon_info->evtid);
+ 	if (index == INVALID_CONFIG_INDEX) {
+ 		pr_warn_once("Invalid event id %d\n", mon_info->evtid);
+ 		return;
+ 	}
+ 	rdmsrl(MSR_IA32_EVT_CFG_BASE + index, msrval);
+ 
+ 	/* Report only the valid event configuration bits */
+ 	mon_info->mon_config = msrval & MAX_EVT_CONFIG_BITS;
+ }
+ 
+ static void mondata_config_read(struct rdt_domain *d, struct mon_config_info *mon_info)
+ {
+ 	smp_call_function_any(&d->cpu_mask, mon_event_config_read, mon_info, 1);
+ }
+ 
+ static int mbm_config_show(struct seq_file *s, struct rdt_resource *r, u32 evtid)
+ {
+ 	struct mon_config_info mon_info = {0};
+ 	struct rdt_domain *dom;
+ 	bool sep = false;
+ 
+ 	mutex_lock(&rdtgroup_mutex);
+ 
+ 	list_for_each_entry(dom, &r->domains, list) {
+ 		if (sep)
+ 			seq_puts(s, ";");
+ 
+ 		memset(&mon_info, 0, sizeof(struct mon_config_info));
+ 		mon_info.evtid = evtid;
+ 		mondata_config_read(dom, &mon_info);
+ 
+ 		seq_printf(s, "%d=0x%02x", dom->id, mon_info.mon_config);
+ 		sep = true;
+ 	}
+ 	seq_puts(s, "\n");
+ 
+ 	mutex_unlock(&rdtgroup_mutex);
+ 
+ 	return 0;
+ }
+ 
+ static int mbm_total_bytes_config_show(struct kernfs_open_file *of,
+ 				       struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	mbm_config_show(seq, r, QOS_L3_MBM_TOTAL_EVENT_ID);
+ 
+ 	return 0;
+ }
+ 
+ static int mbm_local_bytes_config_show(struct kernfs_open_file *of,
+ 				       struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	mbm_config_show(seq, r, QOS_L3_MBM_LOCAL_EVENT_ID);
+ 
+ 	return 0;
+ }
+ 
+ static void mon_event_config_write(void *info)
+ {
+ 	struct mon_config_info *mon_info = info;
+ 	unsigned int index;
+ 
+ 	index = mon_event_config_index_get(mon_info->evtid);
+ 	if (index == INVALID_CONFIG_INDEX) {
+ 		pr_warn_once("Invalid event id %d\n", mon_info->evtid);
+ 		return;
+ 	}
+ 	wrmsr(MSR_IA32_EVT_CFG_BASE + index, mon_info->mon_config, 0);
+ }
+ 
+ static int mbm_config_write_domain(struct rdt_resource *r,
+ 				   struct rdt_domain *d, u32 evtid, u32 val)
+ {
+ 	struct mon_config_info mon_info = {0};
+ 	int ret = 0;
+ 
+ 	/* mon_config cannot be more than the supported set of events */
+ 	if (val > MAX_EVT_CONFIG_BITS) {
+ 		rdt_last_cmd_puts("Invalid event configuration\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * Read the current config value first. If both are the same then
+ 	 * no need to write it again.
+ 	 */
+ 	mon_info.evtid = evtid;
+ 	mondata_config_read(d, &mon_info);
+ 	if (mon_info.mon_config == val)
+ 		goto out;
+ 
+ 	mon_info.mon_config = val;
+ 
+ 	/*
+ 	 * Update MSR_IA32_EVT_CFG_BASE MSR on one of the CPUs in the
+ 	 * domain. The MSRs offset from MSR MSR_IA32_EVT_CFG_BASE
+ 	 * are scoped at the domain level. Writing any of these MSRs
+ 	 * on one CPU is observed by all the CPUs in the domain.
+ 	 */
+ 	smp_call_function_any(&d->cpu_mask, mon_event_config_write,
+ 			      &mon_info, 1);
+ 
+ 	/*
+ 	 * When an Event Configuration is changed, the bandwidth counters
+ 	 * for all RMIDs and Events will be cleared by the hardware. The
+ 	 * hardware also sets MSR_IA32_QM_CTR.Unavailable (bit 62) for
+ 	 * every RMID on the next read to any event for every RMID.
+ 	 * Subsequent reads will have MSR_IA32_QM_CTR.Unavailable (bit 62)
+ 	 * cleared while it is tracked by the hardware. Clear the
+ 	 * mbm_local and mbm_total counts for all the RMIDs.
+ 	 */
+ 	resctrl_arch_reset_rmid_all(r, d);
+ 
+ out:
+ 	return ret;
+ }
+ 
+ static int mon_config_write(struct rdt_resource *r, char *tok, u32 evtid)
+ {
+ 	char *dom_str = NULL, *id_str;
+ 	unsigned long dom_id, val;
+ 	struct rdt_domain *d;
+ 	int ret = 0;
+ 
+ next:
+ 	if (!tok || tok[0] == '\0')
+ 		return 0;
+ 
+ 	/* Start processing the strings for each domain */
+ 	dom_str = strim(strsep(&tok, ";"));
+ 	id_str = strsep(&dom_str, "=");
+ 
+ 	if (!id_str || kstrtoul(id_str, 10, &dom_id)) {
+ 		rdt_last_cmd_puts("Missing '=' or non-numeric domain id\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!dom_str || kstrtoul(dom_str, 16, &val)) {
+ 		rdt_last_cmd_puts("Non-numeric event configuration value\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	list_for_each_entry(d, &r->domains, list) {
+ 		if (d->id == dom_id) {
+ 			ret = mbm_config_write_domain(r, d, evtid, val);
+ 			if (ret)
+ 				return -EINVAL;
+ 			goto next;
+ 		}
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static ssize_t mbm_total_bytes_config_write(struct kernfs_open_file *of,
+ 					    char *buf, size_t nbytes,
+ 					    loff_t off)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	int ret;
+ 
+ 	/* Valid input requires a trailing newline */
+ 	if (nbytes == 0 || buf[nbytes - 1] != '\n')
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&rdtgroup_mutex);
+ 
+ 	rdt_last_cmd_clear();
+ 
+ 	buf[nbytes - 1] = '\0';
+ 
+ 	ret = mon_config_write(r, buf, QOS_L3_MBM_TOTAL_EVENT_ID);
+ 
+ 	mutex_unlock(&rdtgroup_mutex);
+ 
+ 	return ret ?: nbytes;
+ }
+ 
+ static ssize_t mbm_local_bytes_config_write(struct kernfs_open_file *of,
+ 					    char *buf, size_t nbytes,
+ 					    loff_t off)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	int ret;
+ 
+ 	/* Valid input requires a trailing newline */
+ 	if (nbytes == 0 || buf[nbytes - 1] != '\n')
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&rdtgroup_mutex);
+ 
+ 	rdt_last_cmd_clear();
+ 
+ 	buf[nbytes - 1] = '\0';
+ 
+ 	ret = mon_config_write(r, buf, QOS_L3_MBM_LOCAL_EVENT_ID);
+ 
+ 	mutex_unlock(&rdtgroup_mutex);
+ 
+ 	return ret ?: nbytes;
+ }
+ 
++>>>>>>> 793207bad71c (x86/resctrl: Fix a silly -Wunused-but-set-variable warning)
  /* rdtgroup information files for one cache resource. */
  static struct rftype res_common_files[] = {
  	{
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
