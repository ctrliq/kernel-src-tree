drm/amd/display: fix access hdcp_workqueue assert

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Hersen Wu <hersenxs.wu@amd.com>
commit cdff36a0217aadf5cbc167893ad1c0da869619cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/cdff36a0.failed

[Why] hdcp are enabled for asics from raven. for old asics
which hdcp are not enabled, hdcp_workqueue are null. some
access to hdcp work queue are not guarded with pointer check.

[How] add hdcp_workqueue pointer check before access workqueue.

	Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
	Acked-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
	Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
	Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit cdff36a0217aadf5cbc167893ad1c0da869619cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
#	drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
diff --cc drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 6a8904d9ec26,6e9d2e680d50..000000000000
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@@ -8201,16 -8554,72 +8201,73 @@@ static void amdgpu_dm_atomic_commit_tai
  				acrtc->otg_inst = status->primary_otg_inst;
  		}
  	}
++<<<<<<< HEAD
 +#ifdef CONFIG_DRM_AMD_DC_HDCP
++=======
  	for_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {
  		struct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);
  		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);
  		struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
  
+ 		if (!adev->dm.hdcp_workqueue)
+ 			continue;
+ 
+ 		pr_debug("[HDCP_DM] -------------- i : %x ----------\n", i);
+ 
+ 		if (!connector)
+ 			continue;
+ 
+ 		pr_debug("[HDCP_DM] connector->index: %x connect_status: %x dpms: %x\n",
+ 			connector->index, connector->status, connector->dpms);
+ 		pr_debug("[HDCP_DM] state protection old: %x new: %x\n",
+ 			old_con_state->content_protection, new_con_state->content_protection);
+ 
+ 		if (aconnector->dc_sink) {
+ 			if (aconnector->dc_sink->sink_signal != SIGNAL_TYPE_VIRTUAL &&
+ 				aconnector->dc_sink->sink_signal != SIGNAL_TYPE_NONE) {
+ 				pr_debug("[HDCP_DM] pipe_ctx dispname=%s\n",
+ 				aconnector->dc_sink->edid_caps.display_name);
+ 			}
+ 		}
+ 
+ 		new_crtc_state = NULL;
+ 		old_crtc_state = NULL;
+ 
+ 		if (acrtc) {
+ 			new_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);
+ 			old_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);
+ 		}
+ 
+ 		if (old_crtc_state)
+ 			pr_debug("old crtc en: %x a: %x m: %x a-chg: %x c-chg: %x\n",
+ 			old_crtc_state->enable,
+ 			old_crtc_state->active,
+ 			old_crtc_state->mode_changed,
+ 			old_crtc_state->active_changed,
+ 			old_crtc_state->connectors_changed);
+ 
+ 		if (new_crtc_state)
+ 			pr_debug("NEW crtc en: %x a: %x m: %x a-chg: %x c-chg: %x\n",
+ 			new_crtc_state->enable,
+ 			new_crtc_state->active,
+ 			new_crtc_state->mode_changed,
+ 			new_crtc_state->active_changed,
+ 			new_crtc_state->connectors_changed);
+ 	}
+ 
++>>>>>>> cdff36a0217a (drm/amd/display: fix access hdcp_workqueue assert)
+ 	for_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {
+ 		struct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);
+ 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);
+ 		struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+ 
+ 		if (!adev->dm.hdcp_workqueue)
+ 			continue;
+ 
  		new_crtc_state = NULL;
 -		old_crtc_state = NULL;
  
 -		if (acrtc) {
 +		if (acrtc)
  			new_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);
 -			old_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);
 -		}
  
  		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
  
diff --cc drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 2e74ccf7df5b,5dc79b753d5f..000000000000
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@@ -343,6 -368,30 +343,33 @@@ static int dm_dp_mst_get_modes(struct d
  		/* dc_link_add_remote_sink returns a new reference */
  		aconnector->dc_sink = dc_sink;
  
++<<<<<<< HEAD
++=======
+ 		/* when display is unplugged from mst hub, connctor will be
+ 		 * destroyed within dm_dp_mst_connector_destroy. connector
+ 		 * hdcp perperties, like type, undesired, desired, enabled,
+ 		 * will be lost. So, save hdcp properties into hdcp_work within
+ 		 * amdgpu_dm_atomic_commit_tail. if the same display is
+ 		 * plugged back with same display index, its hdcp properties
+ 		 * will be retrieved from hdcp_work within dm_dp_mst_get_modes
+ 		 */
+ 		if (aconnector->dc_sink && connector->state) {
+ 			struct drm_device *dev = connector->dev;
+ 			struct amdgpu_device *adev = drm_to_adev(dev);
+ 
+ 			if (adev->dm.hdcp_workqueue) {
+ 				struct hdcp_workqueue *hdcp_work = adev->dm.hdcp_workqueue;
+ 				struct hdcp_workqueue *hdcp_w =
+ 					&hdcp_work[aconnector->dc_link->link_index];
+ 
+ 				connector->state->hdcp_content_type =
+ 				hdcp_w->hdcp_content_type[connector->index];
+ 				connector->state->content_protection =
+ 				hdcp_w->content_protection[connector->index];
+ 			}
+ 		}
+ 
++>>>>>>> cdff36a0217a (drm/amd/display: fix access hdcp_workqueue assert)
  		if (aconnector->dc_sink) {
  			amdgpu_dm_update_freesync_caps(
  					connector, aconnector->edid);
* Unmerged path drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
* Unmerged path drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
