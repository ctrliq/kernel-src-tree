arm64: entry: fold el1_inv() into el1h_64_sync_handler()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit afd05e28c9115d01f01d934962634789d069d3fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/afd05e28.failed

An unexpected synchronous exception from EL1h could happen at any time,
and for robustness we should treat this as an NMI, making minimal
assumptions about the context the exception was taken from.

Currently el1_inv() assumes we can use enter_from_kernel_mode(), and
also assumes that we should inherit the original DAIF value. Neither of
these are desireable when we take an unexpected exception. Further,
after el1_inv() calls __panic_unhandled(), the remainder of the function
is unreachable, and therefore superfluous.

Let's address this and simplify things by having el1h_64_sync_handler()
call __panic_unhandled() directly, without any of the redundant logic.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Acked-by: Marc Zyngier <maz@kernel.org>
	Reported-by: Joey Gouly <joey.gouly@arm.com>
	Cc: James Morse <james.morse@arm.com>
	Cc: Will Deacon <will@kernel.org>
Link: https://lore.kernel.org/r/20210607094624.34689-16-mark.rutland@arm.com
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit afd05e28c9115d01f01d934962634789d069d3fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/entry-common.c
diff --cc arch/arm64/kernel/entry-common.c
index c764ba2d11d7,ce5c8af91d31..000000000000
--- a/arch/arm64/kernel/entry-common.c
+++ b/arch/arm64/kernel/entry-common.c
@@@ -111,13 -264,28 +111,38 @@@ static void noinstr el1_undef(struct pt
  	exit_to_kernel_mode(regs);
  }
  
++<<<<<<< HEAD
 +static void noinstr el1_inv(struct pt_regs *regs, unsigned long esr)
 +{
 +	enter_from_kernel_mode(regs);
 +	local_daif_inherit(regs);
 +	bad_mode(regs, 0, esr);
 +	local_daif_mask();
 +	exit_to_kernel_mode(regs);
++=======
+ static void noinstr arm64_enter_el1_dbg(struct pt_regs *regs)
+ {
+ 	regs->lockdep_hardirqs = lockdep_hardirqs_enabled();
+ 
+ 	lockdep_hardirqs_off(CALLER_ADDR0);
+ 	rcu_nmi_enter();
+ 
+ 	trace_hardirqs_off_finish();
+ }
+ 
+ static void noinstr arm64_exit_el1_dbg(struct pt_regs *regs)
+ {
+ 	bool restore = regs->lockdep_hardirqs;
+ 
+ 	if (restore) {
+ 		trace_hardirqs_on_prepare();
+ 		lockdep_hardirqs_on_prepare(CALLER_ADDR0);
+ 	}
+ 
+ 	rcu_nmi_exit();
+ 	if (restore)
+ 		lockdep_hardirqs_on(CALLER_ADDR0);
++>>>>>>> afd05e28c911 (arm64: entry: fold el1_inv() into el1h_64_sync_handler())
  }
  
  static void noinstr el1_dbg(struct pt_regs *regs, unsigned long esr)
* Unmerged path arch/arm64/kernel/entry-common.c
