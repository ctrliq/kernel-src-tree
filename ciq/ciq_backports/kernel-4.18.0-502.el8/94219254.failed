net/mlx5: Refactor the encryption key creation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Jianbo Liu <jianbol@nvidia.com>
commit 942192541675b80222e98b4eb410695c5ab619a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/94219254.failed

Move the common code to general functions which can be used by fast
update encryption key in later patches.

	Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 942192541675b80222e98b4eb410695c5ab619a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
index e995f8378df7,81fe5c3763a5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
@@@ -2,10 -2,60 +2,55 @@@
  // Copyright (c) 2019 Mellanox Technologies.
  
  #include "mlx5_core.h"
 -#include "lib/crypto.h"
 -
 -struct mlx5_crypto_dek_priv {
 -	struct mlx5_core_dev *mdev;
 -	int log_dek_obj_range;
 -};
 +#include "lib/mlx5.h"
  
+ static int mlx5_crypto_dek_get_key_sz(struct mlx5_core_dev *mdev,
+ 				      u32 sz_bytes, u8 *key_sz_p)
+ {
+ 	u32 sz_bits = sz_bytes * BITS_PER_BYTE;
+ 
+ 	switch (sz_bits) {
+ 	case 128:
+ 		*key_sz_p = MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_128;
+ 		break;
+ 	case 256:
+ 		*key_sz_p = MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_256;
+ 		break;
+ 	default:
+ 		mlx5_core_err(mdev, "Crypto offload error, invalid key size (%u bits)\n",
+ 			      sz_bits);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_crypto_dek_fill_key(struct mlx5_core_dev *mdev, u8 *key_obj,
+ 				    const void *key, u32 sz_bytes)
+ {
+ 	void *dst;
+ 	u8 key_sz;
+ 	int err;
+ 
+ 	err = mlx5_crypto_dek_get_key_sz(mdev, sz_bytes, &key_sz);
+ 	if (err)
+ 		return err;
+ 
+ 	MLX5_SET(encryption_key_obj, key_obj, key_size, key_sz);
+ 
+ 	if (sz_bytes == 16)
+ 		/* For key size of 128b the MSBs are reserved. */
+ 		dst = MLX5_ADDR_OF(encryption_key_obj, key_obj, key[1]);
+ 	else
+ 		dst = MLX5_ADDR_OF(encryption_key_obj, key_obj, key);
+ 
+ 	memcpy(dst, key, sz_bytes);
+ 
+ 	return 0;
+ }
+ 
  int mlx5_create_encryption_key(struct mlx5_core_dev *mdev,
 -			       const void *key, u32 sz_bytes,
 +			       void *key, u32 sz_bytes,
  			       u32 key_type, u32 *p_key_id)
  {
  	u32 in[MLX5_ST_SZ_DW(create_encryption_key_in)] = {};
@@@ -24,24 -69,6 +64,27 @@@
  	      MLX5_HCA_CAP_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	switch (sz_bits) {
 +	case 128:
 +		general_obj_key_size =
 +			MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_128;
 +		key_p += sz_bytes;
 +		break;
 +	case 256:
 +		general_obj_key_size =
 +			MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_256;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	memcpy(key_p, key, sz_bytes);
 +
 +	MLX5_SET(encryption_key_obj, obj, key_size, general_obj_key_size);
 +	MLX5_SET(encryption_key_obj, obj, key_type, key_type);
++=======
++>>>>>>> 942192541675 (net/mlx5: Refactor the encryption key creation)
  	MLX5_SET(general_obj_in_cmd_hdr, in, opcode,
  		 MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
  	MLX5_SET(general_obj_in_cmd_hdr, in, obj_type,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
