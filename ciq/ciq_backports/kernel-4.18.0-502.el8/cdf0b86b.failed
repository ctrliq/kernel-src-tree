r8152: fix a WOL issue

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Hayes Wang <hayeswang@realtek.com>
commit cdf0b86b250fd3c1c3e120c86583ea510c52e4ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/cdf0b86b.failed

This fixes that the platform is waked by an unexpected packet. The
size and range of FIFO is different when the device enters S3 state,
so it is necessary to correct some settings when suspending.

Regardless of jumbo frame, set RMS to 1522 and MTPS to MTPS_DEFAULT.
Besides, enable MCU_BORW_EN to update the method of calculating the
pointer of data. Then, the hardware could get the correct data.

Fixes: 195aae321c82 ("r8152: support new chips")
	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
Link: https://lore.kernel.org/r/20220718082120.10957-391-nic_swsd@realtek.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit cdf0b86b250fd3c1c3e120c86583ea510c52e4ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index bd7057c011cc,0f6efaabaa32..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -33,10 -29,10 +33,14 @@@
  #include <linux/usb/r8152.h>
  
  /* Information for net-next */
 -#define NETNEXT_VERSION		"12"
 +#define NETNEXT_VERSION		"11"
  
  /* Information for net */
++<<<<<<< HEAD
 +#define NET_VERSION		"11"
++=======
+ #define NET_VERSION		"13"
++>>>>>>> cdf0b86b250f (r8152: fix a WOL issue)
  
  #define DRIVER_VERSION		"v1." NETNEXT_VERSION "." NET_VERSION
  #define DRIVER_AUTHOR "Realtek linux nic maintainers <nic_swsd@realtek.com>"
@@@ -5090,6 -6333,260 +5099,263 @@@ static void rtl8153b_down(struct r8152 
  	r8153_aldps_en(tp, true);
  }
  
++<<<<<<< HEAD
++=======
+ static void rtl8153c_change_mtu(struct r8152 *tp)
+ {
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+ 
+ 	/* Adjust the tx fifo free credit full threshold, otherwise
+ 	 * the fifo would be too small to send a jumbo frame packet.
+ 	 */
+ 	if (tp->netdev->mtu < 8000)
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 2048 / 8);
+ 	else
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 900 / 8);
+ }
+ 
+ static void rtl8153c_up(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153b_u1u2en(tp, false);
+ 	r8153_u2p3en(tp, false);
+ 	r8153_aldps_en(tp, false);
+ 
+ 	rxdy_gated_en(tp, true);
+ 	r8153_teredo_off(tp);
+ 
+ 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 	ocp_data &= ~RCR_ACPT_ALL;
+ 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 
+ 	rtl8152_nic_reset(tp);
+ 	rtl_reset_bmu(tp);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data &= ~NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data &= ~MCU_BORW_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	wait_oob_link_list_ready(tp);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data |= RE_INIT_LL;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	wait_oob_link_list_ready(tp);
+ 
+ 	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+ 
+ 	rtl8153c_change_mtu(tp);
+ 
+ 	rtl8152_nic_reset(tp);
+ 
+ 	/* rx share fifo credit full threshold */
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, 0x02);
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 0x08);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+ 
+ 	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+ 
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
+ 	ocp_data |= BIT(8);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);
+ 
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data &= ~PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	r8153_aldps_en(tp, true);
+ 	r8153b_u1u2en(tp, true);
+ }
+ 
+ static inline u32 fc_pause_on_auto(struct r8152 *tp)
+ {
+ 	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 6 * 1024);
+ }
+ 
+ static inline u32 fc_pause_off_auto(struct r8152 *tp)
+ {
+ 	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 14 * 1024);
+ }
+ 
+ static void r8156_fc_parameter(struct r8152 *tp)
+ {
+ 	u32 pause_on = tp->fc_pause_on ? tp->fc_pause_on : fc_pause_on_auto(tp);
+ 	u32 pause_off = tp->fc_pause_off ? tp->fc_pause_off : fc_pause_off_auto(tp);
+ 
+ 	switch (tp->version) {
+ 	case RTL_VER_10:
+ 	case RTL_VER_11:
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 8);
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, pause_off / 8);
+ 		break;
+ 	case RTL_VER_12:
+ 	case RTL_VER_13:
+ 	case RTL_VER_15:
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 16);
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, pause_off / 16);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void rtl8156_change_mtu(struct r8152 *tp)
+ {
+ 	u32 rx_max_size = mtu_to_size(tp->netdev->mtu);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, rx_max_size);
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+ 	r8156_fc_parameter(tp);
+ 
+ 	/* TX share fifo free credit full threshold */
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+ 		       ALIGN(rx_max_size + sizeof(struct tx_desc), 1024) / 16);
+ }
+ 
+ static void rtl8156_up(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153b_u1u2en(tp, false);
+ 	r8153_u2p3en(tp, false);
+ 	r8153_aldps_en(tp, false);
+ 
+ 	rxdy_gated_en(tp, true);
+ 	r8153_teredo_off(tp);
+ 
+ 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 	ocp_data &= ~RCR_ACPT_ALL;
+ 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 
+ 	rtl8152_nic_reset(tp);
+ 	rtl_reset_bmu(tp);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data &= ~NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data &= ~MCU_BORW_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+ 
+ 	rtl8156_change_mtu(tp);
+ 
+ 	switch (tp->version) {
+ 	case RTL_TEST_01:
+ 	case RTL_VER_10:
+ 	case RTL_VER_11:
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG);
+ 		ocp_data |= ACT_ODMA;
+ 		ocp_write_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/* share FIFO settings */
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL);
+ 	ocp_data &= ~RXFIFO_FULL_MASK;
+ 	ocp_data |= 0x08;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data &= ~PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION);
+ 	ocp_data &= ~(RG_PWRDN_EN | ALL_SPEED_OFF);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, ocp_data);
+ 
+ 	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);
+ 
+ 	if (tp->saved_wolopts != __rtl_get_wol(tp)) {
+ 		netif_warn(tp, ifup, tp->netdev, "wol setting is changed\n");
+ 		__rtl_set_wol(tp, tp->saved_wolopts);
+ 	}
+ 
+ 	r8153_aldps_en(tp, true);
+ 	r8153_u2p3en(tp, true);
+ 
+ 	if (tp->udev->speed >= USB_SPEED_SUPER)
+ 		r8153b_u1u2en(tp, true);
+ }
+ 
+ static void rtl8156_down(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+ 		rtl_drop_queued_tx(tp);
+ 		return;
+ 	}
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data |= PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	r8153b_u1u2en(tp, false);
+ 	r8153_u2p3en(tp, false);
+ 	r8153b_power_cut_en(tp, false);
+ 	r8153_aldps_en(tp, false);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data &= ~NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	rtl_disable(tp);
+ 	rtl_reset_bmu(tp);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+ 
+ 	/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+ 	 * type. Set it to zero. bits[7:0] are the W1C bits about
+ 	 * the events. Set them to all 1 to clear them.
+ 	 */
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data |= NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data |= MCU_BORW_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	rtl_rx_vlan_en(tp, true);
+ 	rxdy_gated_en(tp, false);
+ 
+ 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
+ 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 
+ 	r8153_aldps_en(tp, true);
+ }
+ 
++>>>>>>> cdf0b86b250f (r8152: fix a WOL issue)
  static bool rtl8152_in_nway(struct r8152 *tp)
  {
  	u16 nway_state;
* Unmerged path drivers/net/usb/r8152.c
