x86/resctrl: Group struct rdt_hw_domain cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit 7add3af4178d9e25afc8d990a7d1000ccb22b6a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/7add3af4.failed

domain_add_cpu() and domain_remove_cpu() need to kfree() the child
arrays that were allocated by domain_setup_ctrlval().

As this memory is moved around, and new arrays are created, adjusting
the error handling cleanup code becomes noisier.

To simplify this, move all the kfree() calls into a domain_free() helper.
This depends on struct rdt_hw_domain being kzalloc()d, allowing it to
unconditionally kfree() all the child arrays.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <quic_jiles@quicinc.com>
	Reviewed-by: Shaopeng Tan <tan.shaopeng@fujitsu.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Xin Hao <xhao@linux.alibaba.com>
	Tested-by: Shaopeng Tan <tan.shaopeng@fujitsu.com>
	Tested-by: Cristian Marussi <cristian.marussi@arm.com>
Link: https://lore.kernel.org/r/20220902154829.30399-5-james.morse@arm.com
(cherry picked from commit 7add3af4178d9e25afc8d990a7d1000ccb22b6a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/core.c
diff --cc arch/x86/kernel/cpu/resctrl/core.c
index 296d8b9fc18a,e37889f7a1a5..000000000000
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@@ -490,8 -414,17 +490,15 @@@ void setup_default_ctrlval(struct rdt_r
  	}
  }
  
+ static void domain_free(struct rdt_hw_domain *hw_dom)
+ {
+ 	kfree(hw_dom->ctrl_val);
+ 	kfree(hw_dom->mbps_val);
+ 	kfree(hw_dom);
+ }
+ 
  static int domain_setup_ctrlval(struct rdt_resource *r, struct rdt_domain *d)
  {
 -	struct rdt_hw_resource *hw_res = resctrl_to_arch_res(r);
 -	struct rdt_hw_domain *hw_dom = resctrl_to_arch_dom(d);
  	struct msr_param m;
  	u32 *dc, *dm;
  
@@@ -597,21 -499,13 +604,30 @@@ static void domain_add_cpu(int cpu, str
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (r->mon_capable && domain_setup_mon_state(r, d)) {
 +		kfree(hw_dom->ctrl_val);
 +		kfree(hw_dom->mbps_val);
 +		kfree(hw_dom);
 +		return;
++=======
+ 	list_add_tail(&d->list, add_pos);
+ 
+ 	err = resctrl_online_domain(r, d);
+ 	if (err) {
+ 		list_del(&d->list);
+ 		domain_free(hw_dom);
++>>>>>>> 7add3af4178d (x86/resctrl: Group struct rdt_hw_domain cleanup)
  	}
 +
 +	list_add_tail(&d->list, add_pos);
 +
 +	/*
 +	 * If resctrl is mounted, add
 +	 * per domain monitor data directories.
 +	 */
 +	if (static_branch_unlikely(&rdt_mon_enable_key))
 +		mkdir_mondata_subdir_allrdtgrp(r, d);
  }
  
  static void domain_remove_cpu(int cpu, struct rdt_resource *r)
@@@ -656,12 -552,10 +672,19 @@@
  		if (d->plr)
  			d->plr->d = NULL;
  
++<<<<<<< HEAD
 +		kfree(d->ctrl_val);
 +		kfree(d->mbps_val);
 +		bitmap_free(d->rmid_busy_llc);
 +		kfree(d->mbm_total);
 +		kfree(d->mbm_local);
 +		kfree(d);
++=======
+ 		bitmap_free(d->rmid_busy_llc);
+ 		kfree(d->mbm_total);
+ 		kfree(d->mbm_local);
+ 		domain_free(hw_dom);
++>>>>>>> 7add3af4178d (x86/resctrl: Group struct rdt_hw_domain cleanup)
  		return;
  	}
  
* Unmerged path arch/x86/kernel/cpu/resctrl/core.c
