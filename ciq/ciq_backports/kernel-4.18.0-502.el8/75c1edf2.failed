net/smc: postpone sk_refcnt increment in connect()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author liuyacan <liuyacan@corp.netease.com>
commit 75c1edf23b95a9c66923d9269d8e86e4dbde151f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/75c1edf2.failed

Same trigger condition as commit 86434744. When setsockopt runs
in parallel to a connect(), and switch the socket into fallback
mode. Then the sk_refcnt is incremented in smc_connect(), but
its state stay in SMC_INIT (NOT SMC_ACTIVE). This cause the
corresponding sk_refcnt decrement in __smc_release() will not be
performed.

Fixes: 86434744fedf ("net/smc: add fallback check to connect()")
	Signed-off-by: liuyacan <liuyacan@corp.netease.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 75c1edf23b95a9c66923d9269d8e86e4dbde151f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/af_smc.c
diff --cc net/smc/af_smc.c
index ebb6d99da0c3,45a24d24210f..000000000000
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@@ -1582,11 -1564,9 +1582,17 @@@ static int smc_connect(struct socket *s
  	if (rc && rc != -EINPROGRESS)
  		goto out;
  
++<<<<<<< HEAD
 +	sock_hold(&smc->sk); /* sock put in passive closing */
 +	if (smc->use_fallback) {
 +		sock->state = rc ? SS_CONNECTING : SS_CONNECTED;
 +		goto out;
 +	}
++=======
+ 	if (smc->use_fallback)
+ 		goto out;
+ 	sock_hold(&smc->sk); /* sock put in passive closing */
++>>>>>>> 75c1edf23b95 (net/smc: postpone sk_refcnt increment in connect())
  	if (flags & O_NONBLOCK) {
  		if (queue_work(smc_hs_wq, &smc->connect_work))
  			smc->connect_nonblock = 1;
* Unmerged path net/smc/af_smc.c
