arm64: entry: make NMI entry/exit functions static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit 6ecbc78c3d06a3e7a4676f348a52f1c533d88464
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/6ecbc78c.failed

Now that we only call arm64_enter_nmi() and arm64_exit_nmi() from within
entry-common.c, let's make these static to ensure this remains the case.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Acked-by: Marc Zyngier <maz@kernel.org>
	Reviewed-by: Joey Gouly <joey.gouly@arm.com>
	Cc: James Morse <james.morse@arm.com>
	Cc: Will Deacon <will@kernel.org>
Link: https://lore.kernel.org/r/20210607094624.34689-19-mark.rutland@arm.com
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 6ecbc78c3d06a3e7a4676f348a52f1c533d88464)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/exception.h
#	arch/arm64/kernel/entry-common.c
diff --cc arch/arm64/include/asm/exception.h
index acd3d9be4846,4afbc45b8bb0..000000000000
--- a/arch/arm64/include/asm/exception.h
+++ b/arch/arm64/include/asm/exception.h
@@@ -51,10 -56,10 +51,15 @@@ asmlinkage void noinstr exit_el1_irq_or
  asmlinkage void call_on_irq_stack(struct pt_regs *regs,
  				  void (*func)(struct pt_regs *));
  asmlinkage void enter_from_user_mode(void);
++<<<<<<< HEAD
 +void do_mem_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs);
++=======
+ asmlinkage void exit_to_user_mode(void);
+ void do_mem_abort(unsigned long far, unsigned int esr, struct pt_regs *regs);
++>>>>>>> 6ecbc78c3d06 (arm64: entry: make NMI entry/exit functions static)
  void do_undefinstr(struct pt_regs *regs);
  void do_bti(struct pt_regs *regs);
 +asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr);
  void do_debug_exception(unsigned long addr_if_watchpoint, unsigned int esr,
  			struct pt_regs *regs);
  void do_fpsimd_acc(unsigned int esr, struct pt_regs *regs);
diff --cc arch/arm64/kernel/entry-common.c
index c764ba2d11d7,12ce14a98b7c..000000000000
--- a/arch/arm64/kernel/entry-common.c
+++ b/arch/arm64/kernel/entry-common.c
@@@ -63,10 -75,40 +63,44 @@@ static void noinstr exit_to_kernel_mode
  	}
  }
  
++<<<<<<< HEAD
 +asmlinkage void noinstr enter_el1_irq_or_nmi(struct pt_regs *regs)
++=======
+ static void noinstr arm64_enter_nmi(struct pt_regs *regs)
+ {
+ 	regs->lockdep_hardirqs = lockdep_hardirqs_enabled();
+ 
+ 	__nmi_enter();
+ 	lockdep_hardirqs_off(CALLER_ADDR0);
+ 	lockdep_hardirq_enter();
+ 	rcu_nmi_enter();
+ 
+ 	trace_hardirqs_off_finish();
+ 	ftrace_nmi_enter();
+ }
+ 
+ static void noinstr arm64_exit_nmi(struct pt_regs *regs)
+ {
+ 	bool restore = regs->lockdep_hardirqs;
+ 
+ 	ftrace_nmi_exit();
+ 	if (restore) {
+ 		trace_hardirqs_on_prepare();
+ 		lockdep_hardirqs_on_prepare(CALLER_ADDR0);
+ 	}
+ 
+ 	rcu_nmi_exit();
+ 	lockdep_hardirq_exit();
+ 	if (restore)
+ 		lockdep_hardirqs_on(CALLER_ADDR0);
+ 	__nmi_exit();
+ }
+ 
+ static void noinstr enter_el1_irq_or_nmi(struct pt_regs *regs)
++>>>>>>> 6ecbc78c3d06 (arm64: entry: make NMI entry/exit functions static)
  {
  	if (IS_ENABLED(CONFIG_ARM64_PSEUDO_NMI) && !interrupts_enabled(regs))
 -		arm64_enter_nmi(regs);
 +		nmi_enter();
  	else
  		enter_from_kernel_mode(regs);
  }
* Unmerged path arch/arm64/include/asm/exception.h
* Unmerged path arch/arm64/kernel/entry-common.c
