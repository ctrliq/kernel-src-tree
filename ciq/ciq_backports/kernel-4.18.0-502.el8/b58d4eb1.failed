x86/resctrl: Remove architecture copy of mbps_val

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit b58d4eb1f199f5a26d8c756d8e74a31c48b90428
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/b58d4eb1.failed

The resctrl arch code provides a second configuration array mbps_val[]
for the MBA software controller.

Since resctrl switched over to allocating and freeing its own array
when needed, nothing uses the arch code version.

Remove it.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <quic_jiles@quicinc.com>
	Reviewed-by: Shaopeng Tan <tan.shaopeng@fujitsu.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Xin Hao <xhao@linux.alibaba.com>
	Tested-by: Shaopeng Tan <tan.shaopeng@fujitsu.com>
	Tested-by: Cristian Marussi <cristian.marussi@arm.com>
Link: https://lore.kernel.org/r/20220902154829.30399-11-james.morse@arm.com
(cherry picked from commit b58d4eb1f199f5a26d8c756d8e74a31c48b90428)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/core.c
#	arch/x86/kernel/cpu/resctrl/internal.h
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/core.c
index 296d8b9fc18a,f0e2820af475..000000000000
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@@ -474,80 -397,44 +474,95 @@@ struct rdt_domain *rdt_find_domain(stru
  	return NULL;
  }
  
- void setup_default_ctrlval(struct rdt_resource *r, u32 *dc, u32 *dm)
+ static void setup_default_ctrlval(struct rdt_resource *r, u32 *dc)
  {
 -	struct rdt_hw_resource *hw_res = resctrl_to_arch_res(r);
  	int i;
  
  	/*
  	 * Initialize the Control MSRs to having no control.
  	 * For Cache Allocation: Set all bits in cbm
  	 * For Memory Allocation: Set b/w requested to 100%
- 	 * and the bandwidth in MBps to U32_MAX
  	 */
++<<<<<<< HEAD
 +	for (i = 0; i < r->num_closid; i++, dc++, dm++) {
++=======
+ 	for (i = 0; i < hw_res->num_closid; i++, dc++)
++>>>>>>> b58d4eb1f199 (x86/resctrl: Remove architecture copy of mbps_val)
  		*dc = r->default_ctrl;
- 		*dm = MBA_MAX_MBPS;
- 	}
  }
  
++<<<<<<< HEAD
++=======
+ static void domain_free(struct rdt_hw_domain *hw_dom)
+ {
+ 	kfree(hw_dom->ctrl_val);
+ 	kfree(hw_dom);
+ }
+ 
++>>>>>>> b58d4eb1f199 (x86/resctrl: Remove architecture copy of mbps_val)
  static int domain_setup_ctrlval(struct rdt_resource *r, struct rdt_domain *d)
  {
 -	struct rdt_hw_resource *hw_res = resctrl_to_arch_res(r);
 -	struct rdt_hw_domain *hw_dom = resctrl_to_arch_dom(d);
  	struct msr_param m;
- 	u32 *dc, *dm;
+ 	u32 *dc;
  
 -	dc = kmalloc_array(hw_res->num_closid, sizeof(*hw_dom->ctrl_val),
 -			   GFP_KERNEL);
 +	dc = kmalloc_array(r->num_closid, sizeof(*d->ctrl_val), GFP_KERNEL);
  	if (!dc)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	dm = kmalloc_array(r->num_closid, sizeof(*d->mbps_val), GFP_KERNEL);
 +	if (!dm) {
 +		kfree(dc);
 +		return -ENOMEM;
 +	}
 +
 +	d->ctrl_val = dc;
 +	d->mbps_val = dm;
 +	setup_default_ctrlval(r, dc, dm);
++=======
+ 	hw_dom->ctrl_val = dc;
+ 	setup_default_ctrlval(r, dc);
++>>>>>>> b58d4eb1f199 (x86/resctrl: Remove architecture copy of mbps_val)
  
  	m.low = 0;
 -	m.high = hw_res->num_closid;
 -	hw_res->msr_update(d, &m, r);
 +	m.high = r->num_closid;
 +	r->msr_update(d, &m, r);
 +	return 0;
 +}
 +
 +static int domain_setup_mon_state(struct rdt_resource *r, struct rdt_domain *d)
 +{
 +	size_t tsize;
 +
 +	if (is_llc_occupancy_enabled()) {
 +		d->rmid_busy_llc = bitmap_zalloc(r->num_rmid, GFP_KERNEL);
 +		if (!d->rmid_busy_llc)
 +			return -ENOMEM;
 +		INIT_DELAYED_WORK(&d->cqm_limbo, cqm_handle_limbo);
 +	}
 +	if (is_mbm_total_enabled()) {
 +		tsize = sizeof(*d->mbm_total);
 +		d->mbm_total = kcalloc(r->num_rmid, tsize, GFP_KERNEL);
 +		if (!d->mbm_total) {
 +			bitmap_free(d->rmid_busy_llc);
 +			return -ENOMEM;
 +		}
 +	}
 +	if (is_mbm_local_enabled()) {
 +		tsize = sizeof(*d->mbm_local);
 +		d->mbm_local = kcalloc(r->num_rmid, tsize, GFP_KERNEL);
 +		if (!d->mbm_local) {
 +			bitmap_free(d->rmid_busy_llc);
 +			kfree(d->mbm_total);
 +			return -ENOMEM;
 +		}
 +	}
 +
 +	if (is_mbm_enabled()) {
 +		INIT_DELAYED_WORK(&d->mbm_over, mbm_handle_overflow);
 +		mbm_setup_overflow_handler(d, MBM_OVERFLOW_INTERVAL);
 +	}
 +
  	return 0;
  }
  
diff --cc arch/x86/kernel/cpu/resctrl/internal.h
index 9780c2d2c637,373aaba53ecd..000000000000
--- a/arch/x86/kernel/cpu/resctrl/internal.h
+++ b/arch/x86/kernel/cpu/resctrl/internal.h
@@@ -303,44 -304,23 +303,52 @@@ struct mbm_state 
  };
  
  /**
 - * struct rdt_hw_domain - Arch private attributes of a set of CPUs that share
 - *			  a resource
 - * @d_resctrl:	Properties exposed to the resctrl file system
 + * struct rdt_domain - group of cpus sharing an RDT resource
 + * @list:	all instances of this resource
 + * @id:		unique id for this instance
 + * @cpu_mask:	which cpus share this resource
 + * @rmid_busy_llc:
 + *		bitmap of which limbo RMIDs are above threshold
 + * @mbm_total:	saved state for MBM total bandwidth
 + * @mbm_local:	saved state for MBM local bandwidth
 + * @mbm_over:	worker to periodically read MBM h/w counters
 + * @cqm_limbo:	worker to periodically read CQM h/w counters
 + * @mbm_work_cpu:
 + *		worker cpu for MBM h/w counters
 + * @cqm_work_cpu:
 + *		worker cpu for CQM h/w counters
   * @ctrl_val:	array of cache or mem ctrl values (indexed by CLOSID)
++<<<<<<< HEAD
 + * @mbps_val:	When mba_sc is enabled, this holds the bandwidth in MBps
 + * @new_ctrl:	new ctrl value to be loaded
 + * @have_new_ctrl: did user provide new_ctrl for this domain
 + * @plr:	pseudo-locked region (if any) associated with domain
++=======
+  *
+  * Members of this structure are accessed via helpers that provide abstraction.
++>>>>>>> b58d4eb1f199 (x86/resctrl: Remove architecture copy of mbps_val)
   */
 -struct rdt_hw_domain {
 -	struct rdt_domain		d_resctrl;
 +struct rdt_domain {
 +	struct list_head		list;
 +	int				id;
 +	struct cpumask			cpu_mask;
 +	unsigned long			*rmid_busy_llc;
 +	struct mbm_state		*mbm_total;
 +	struct mbm_state		*mbm_local;
 +	struct delayed_work		mbm_over;
 +	struct delayed_work		cqm_limbo;
 +	int				mbm_work_cpu;
 +	int				cqm_work_cpu;
  	u32				*ctrl_val;
++<<<<<<< HEAD
 +	u32				*mbps_val;
 +	u32				new_ctrl;
 +	bool				have_new_ctrl;
 +	struct pseudo_lock_region	*plr;
++=======
++>>>>>>> b58d4eb1f199 (x86/resctrl: Remove architecture copy of mbps_val)
  };
  
 -static inline struct rdt_hw_domain *resctrl_to_arch_dom(struct rdt_domain *r)
 -{
 -	return container_of(r, struct rdt_hw_domain, d_resctrl);
 -}
 -
  /**
   * struct msr_param - set a range of MSRs from a domain
   * @res:       The resource to use
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index e5f7b979a288,6c33dfe7ea53..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -2311,10 -2367,11 +2311,15 @@@ static int reset_all_ctrls(struct rdt_r
  	 * from each domain to update the MSRs below.
  	 */
  	list_for_each_entry(d, &r->domains, list) {
 -		hw_dom = resctrl_to_arch_dom(d);
  		cpumask_set_cpu(cpumask_any(&d->cpu_mask), cpu_mask);
  
++<<<<<<< HEAD
 +		for (i = 0; i < r->num_closid; i++)
 +			d->ctrl_val[i] = r->default_ctrl;
++=======
+ 		for (i = 0; i < hw_res->num_closid; i++)
+ 			hw_dom->ctrl_val[i] = r->default_ctrl;
++>>>>>>> b58d4eb1f199 (x86/resctrl: Remove architecture copy of mbps_val)
  	}
  	cpu = get_cpu();
  	/* Update CBM on this cpu if it's in cpu_mask. */
* Unmerged path arch/x86/kernel/cpu/resctrl/core.c
* Unmerged path arch/x86/kernel/cpu/resctrl/internal.h
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
