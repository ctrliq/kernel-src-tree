net/mlx5e: Update rx ring hw mtu upon each rx-fcs flag change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Adham Faris <afaris@nvidia.com>
commit 1e66220948df815d7b37e0ff8b4627ce10433738
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/1e662209.failed

rq->hw_mtu is used in function en_rx.c/mlx5e_skb_from_cqe_mpwrq_linear()
to catch oversized packets. If FCS is concatenated to the end of the
packet then the check should be updated accordingly.

Rx rings initialization (mlx5e_init_rxq_rq()) invoked for every new set
of channels, as part of mlx5e_safe_switch_params(), unknowingly if it
runs with default configuration or not. Current rq->hw_mtu
initialization assumes default configuration and ignores
params->scatter_fcs_en flag state.
Fix this, by accounting for params->scatter_fcs_en flag state during
rq->hw_mtu initialization.

In addition, updating rq->hw_mtu value during ingress traffic might
lead to packets drop and oversize_pkts_sw_drop counter increase with no
good reason. Hence we remove this optimization and switch the set of
channels with a new one, to make sure we don't get false positives on
the oversize_pkts_sw_drop counter.

Fixes: 102722fc6832 ("net/mlx5e: Add support for RXFCS feature flag")
	Signed-off-by: Adham Faris <afaris@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 1e66220948df815d7b37e0ff8b4627ce10433738)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index ae689404b54c,f8b5e5993f35..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -865,33 -989,30 +866,60 @@@ int mlx5e_modify_rq_state(struct mlx5e_
  	return err;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_modify_rq_scatter_fcs(struct mlx5e_rq *rq, bool enable)
 +{
 +	struct mlx5_core_dev *mdev = rq->mdev;
 +
 +	void *in;
 +	void *rqc;
 +	int inlen;
 +	int err;
 +
 +	inlen = MLX5_ST_SZ_BYTES(modify_rq_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);
 +
 +	MLX5_SET(modify_rq_in, in, rq_state, MLX5_RQC_STATE_RDY);
 +	MLX5_SET64(modify_rq_in, in, modify_bitmask,
 +		   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_SCATTER_FCS);
 +	MLX5_SET(rqc, rqc, scatter_fcs, enable);
 +	MLX5_SET(rqc, rqc, state, MLX5_RQC_STATE_RDY);
 +
 +	err = mlx5_core_modify_rq(mdev, rq->rqn, in);
 +
 +	kvfree(in);
 +
 +	return err;
++=======
+ static int mlx5e_rq_to_ready(struct mlx5e_rq *rq, int curr_state)
+ {
+ 	struct net_device *dev = rq->netdev;
+ 	int err;
+ 
+ 	err = mlx5e_modify_rq_state(rq, curr_state, MLX5_RQC_STATE_RST);
+ 	if (err) {
+ 		netdev_err(dev, "Failed to move rq 0x%x to reset\n", rq->rqn);
+ 		return err;
+ 	}
+ 	err = mlx5e_modify_rq_state(rq, MLX5_RQC_STATE_RST, MLX5_RQC_STATE_RDY);
+ 	if (err) {
+ 		netdev_err(dev, "Failed to move rq 0x%x to ready\n", rq->rqn);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int mlx5e_flush_rq(struct mlx5e_rq *rq, int curr_state)
+ {
+ 	mlx5e_free_rx_descs(rq);
+ 
+ 	return mlx5e_rq_to_ready(rq, curr_state);
++>>>>>>> 1e66220948df (net/mlx5e: Update rx ring hw mtu upon each rx-fcs flag change)
  }
  
  static int mlx5e_modify_rq_vsd(struct mlx5e_rq *rq, bool vsd)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
