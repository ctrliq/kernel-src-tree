x86/resctrl: Add a helper to read/set the CDP configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit c091e90721b836c2367fa3017636d92427f3f8f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/c091e907.failed

Whether CDP is enabled for a hardware resource like the L3 cache can be
found by inspecting the alloc_enabled flags of the L3CODE/L3DATA struct
rdt_hw_resources, even if they aren't in use.

Once these resources are merged, the flags can't be compared. Whether
CDP is enabled needs tracking explicitly. If another architecture is
emulating CDP the behaviour may not be per-resource. 'cdp_capable' needs
to be visible to resctrl, even if its not in use, as this affects the
padding of the schemata table visible to user-space.

Add cdp_enabled to struct rdt_hw_resource and cdp_capable to struct
rdt_resource. Add resctrl_arch_set_cdp_enabled() to let resctrl enable
or disable CDP on a resource. resctrl_arch_get_cdp_enabled() lets it
read the current state.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <jamie@nuviainc.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lkml.kernel.org/r/20210728170637.25610-12-james.morse@arm.com
(cherry picked from commit c091e90721b836c2367fa3017636d92427f3f8f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/internal.h
#	arch/x86/kernel/cpu/resctrl/pseudo_lock.c
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
#	include/linux/resctrl.h
diff --cc arch/x86/kernel/cpu/resctrl/internal.h
index 9780c2d2c637,4e15667b88a8..000000000000
--- a/arch/x86/kernel/cpu/resctrl/internal.h
+++ b/arch/x86/kernel/cpu/resctrl/internal.h
@@@ -446,61 -368,44 +446,73 @@@ struct rdt_parse_data 
  };
  
  /**
 - * struct rdt_hw_resource - arch private attributes of a resctrl resource
 - * @conf_type:		The type that should be used when configuring. temporary
 - * @r_resctrl:		Attributes of the resource used directly by resctrl.
 - * @num_closid:		Maximum number of closid this hardware can support,
 - *			regardless of CDP. This is exposed via
 - *			resctrl_arch_get_num_closid() to avoid confusion
 - *			with struct resctrl_schema's property of the same name,
 - *			which has been corrected for features like CDP.
 + * struct rdt_resource - attributes of an RDT resource
 + * @rid:		The index of the resource
 + * @alloc_enabled:	Is allocation enabled on this machine
 + * @mon_enabled:	Is monitoring enabled for this feature
 + * @alloc_capable:	Is allocation available on this machine
 + * @mon_capable:	Is monitor feature available on this machine
 + * @name:		Name to use in "schemata" file
 + * @num_closid:		Number of CLOSIDs available
 + * @cache_level:	Which cache level defines scope of this resource
 + * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
   * @msr_base:		Base MSR address for CBMs
   * @msr_update:		Function pointer to update QOS MSRs
 + * @data_width:		Character width of data when displaying
 + * @domains:		All domains for this resource
 + * @cache:		Cache allocation related data
 + * @membw:		If the component has bandwidth controls, their properties.
 + * @format_str:		Per resource format string to show domain value
 + * @parse_ctrlval:	Per resource function pointer to parse control values
 + * @evt_list:		List of monitoring events
 + * @num_rmid:		Number of RMIDs available
   * @mon_scale:		cqm counter * mon_scale = occupancy in bytes
   * @mbm_width:		Monitor width, to detect and correct for overflow.
++<<<<<<< HEAD
 + * @fflags:		flags to choose base and info files
++=======
+  * @cdp_enabled:	CDP state of this resource
+  *
+  * Members of this structure are either private to the architecture
+  * e.g. mbm_width, or accessed via helpers that provide abstraction. e.g.
+  * msr_update and msr_base.
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
   */
 -struct rdt_hw_resource {
 -	enum resctrl_conf_type	conf_type;
 -	struct rdt_resource	r_resctrl;
 -	u32			num_closid;
 +struct rdt_resource {
 +	int			rid;
 +	bool			alloc_enabled;
 +	bool			mon_enabled;
 +	bool			alloc_capable;
 +	bool			mon_capable;
 +	char			*name;
 +	int			num_closid;
 +	int			cache_level;
 +	u32			default_ctrl;
  	unsigned int		msr_base;
  	void (*msr_update)	(struct rdt_domain *d, struct msr_param *m,
  				 struct rdt_resource *r);
 +	int			data_width;
 +	struct list_head	domains;
 +	struct rdt_cache	cache;
 +	struct rdt_membw	membw;
 +	const char		*format_str;
 +	int (*parse_ctrlval)(struct rdt_parse_data *data,
 +			     struct rdt_resource *r,
 +			     struct rdt_domain *d);
 +	struct list_head	evt_list;
 +	int			num_rmid;
  	unsigned int		mon_scale;
  	unsigned int		mbm_width;
++<<<<<<< HEAD
 +	unsigned long		fflags;
++=======
+ 	bool			cdp_enabled;
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  };
  
 -static inline struct rdt_hw_resource *resctrl_to_arch_res(struct rdt_resource *r)
 -{
 -	return container_of(r, struct rdt_hw_resource, r_resctrl);
 -}
 -
 -int parse_cbm(struct rdt_parse_data *data, struct resctrl_schema *s,
 +int parse_cbm(struct rdt_parse_data *data, struct rdt_resource *r,
  	      struct rdt_domain *d);
 -int parse_bw(struct rdt_parse_data *data, struct resctrl_schema *s,
 +int parse_bw(struct rdt_parse_data *data, struct rdt_resource *r,
  	     struct rdt_domain *d);
  
  extern struct mutex rdtgroup_mutex;
@@@ -524,13 -429,32 +536,35 @@@ enum resctrl_res_level 
  	RDT_NUM_RESOURCES,
  };
  
++<<<<<<< HEAD
++=======
+ static inline struct rdt_resource *resctrl_inc(struct rdt_resource *res)
+ {
+ 	struct rdt_hw_resource *hw_res = resctrl_to_arch_res(res);
+ 
+ 	hw_res++;
+ 	return &hw_res->r_resctrl;
+ }
+ 
+ static inline bool resctrl_arch_get_cdp_enabled(enum resctrl_res_level l)
+ {
+ 	return rdt_resources_all[l].cdp_enabled;
+ }
+ 
+ int resctrl_arch_set_cdp_enabled(enum resctrl_res_level l, bool enable);
+ 
+ /*
+  * To return the common struct rdt_resource, which is contained in struct
+  * rdt_hw_resource, walk the resctrl member of struct rdt_hw_resource.
+  */
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  #define for_each_rdt_resource(r)					      \
 -	for (r = &rdt_resources_all[0].r_resctrl;			      \
 -	     r <= &rdt_resources_all[RDT_NUM_RESOURCES - 1].r_resctrl;	      \
 -	     r = resctrl_inc(r))
 +	for (r = rdt_resources_all; r < rdt_resources_all + RDT_NUM_RESOURCES;\
 +	     r++)
  
  #define for_each_capable_rdt_resource(r)				      \
 -	for_each_rdt_resource(r)					      \
 +	for (r = rdt_resources_all; r < rdt_resources_all + RDT_NUM_RESOURCES;\
 +	     r++)							      \
  		if (r->alloc_capable || r->mon_capable)
  
  #define for_each_alloc_capable_rdt_resource(r)				      \
diff --cc arch/x86/kernel/cpu/resctrl/pseudo_lock.c
index dd352f57e43b,db813f819ad6..000000000000
--- a/arch/x86/kernel/cpu/resctrl/pseudo_lock.c
+++ b/arch/x86/kernel/cpu/resctrl/pseudo_lock.c
@@@ -688,8 -688,8 +688,13 @@@ int rdtgroup_locksetup_enter(struct rdt
  	 *   resource, the portion of cache used by it should be made
  	 *   unavailable to all future allocations from both resources.
  	 */
++<<<<<<< HEAD
 +	if (rdt_resources_all[RDT_RESOURCE_L3DATA].alloc_enabled ||
 +	    rdt_resources_all[RDT_RESOURCE_L2DATA].alloc_enabled) {
++=======
+ 	if (resctrl_arch_get_cdp_enabled(RDT_RESOURCE_L3) ||
+ 	    resctrl_arch_get_cdp_enabled(RDT_RESOURCE_L2)) {
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  		rdt_last_cmd_puts("CDP enabled\n");
  		return -EINVAL;
  	}
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index a8731279ffbf,cc9dacd73438..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -1941,14 -1940,16 +1941,24 @@@ static int set_cache_qos_cfg(int level
  /* Restore the qos cfg state when a domain comes online */
  void rdt_domain_reconfigure_cdp(struct rdt_resource *r)
  {
- 	if (!r->alloc_capable)
+ 	struct rdt_hw_resource *hw_res = resctrl_to_arch_res(r);
+ 
+ 	if (!r->cdp_capable)
  		return;
  
++<<<<<<< HEAD
 +	if (r == &rdt_resources_all[RDT_RESOURCE_L2DATA])
 +		l2_qos_cfg_update(&r->alloc_enabled);
 +
 +	if (r == &rdt_resources_all[RDT_RESOURCE_L3DATA])
 +		l3_qos_cfg_update(&r->alloc_enabled);
++=======
+ 	if (r == &rdt_resources_all[RDT_RESOURCE_L2DATA].r_resctrl)
+ 		l2_qos_cfg_update(&hw_res->cdp_enabled);
+ 
+ 	if (r == &rdt_resources_all[RDT_RESOURCE_L3DATA].r_resctrl)
+ 		l3_qos_cfg_update(&hw_res->cdp_enabled);
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  }
  
  /*
@@@ -1993,28 -2000,20 +2006,30 @@@ static int cdp_enable(int level, int da
  	return ret;
  }
  
- static int cdpl3_enable(void)
- {
- 	return cdp_enable(RDT_RESOURCE_L3, RDT_RESOURCE_L3DATA,
- 			  RDT_RESOURCE_L3CODE);
- }
- 
- static int cdpl2_enable(void)
- {
- 	return cdp_enable(RDT_RESOURCE_L2, RDT_RESOURCE_L2DATA,
- 			  RDT_RESOURCE_L2CODE);
- }
- 
  static void cdp_disable(int level, int data_type, int code_type)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r = &rdt_resources_all[level];
 +
 +	r->alloc_enabled = r->alloc_capable;
 +
 +	if (rdt_resources_all[data_type].alloc_enabled) {
 +		rdt_resources_all[data_type].alloc_enabled = false;
 +		rdt_resources_all[code_type].alloc_enabled = false;
++=======
+ 	struct rdt_hw_resource *r_hw = &rdt_resources_all[level];
+ 	struct rdt_resource *r = &r_hw->r_resctrl;
+ 
+ 	r->alloc_enabled = r->alloc_capable;
+ 
+ 	if (r_hw->cdp_enabled) {
+ 		rdt_resources_all[data_type].r_resctrl.alloc_enabled = false;
+ 		rdt_resources_all[code_type].r_resctrl.alloc_enabled = false;
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  		set_cache_qos_cfg(level, false);
+ 		r_hw->cdp_enabled = false;
+ 		rdt_resources_all[data_type].cdp_enabled = false;
+ 		rdt_resources_all[code_type].cdp_enabled = false;
  	}
  }
  
@@@ -2030,10 -2045,10 +2061,17 @@@ int resctrl_arch_set_cdp_enabled(enum r
  
  static void cdp_disable_all(void)
  {
++<<<<<<< HEAD
 +	if (rdt_resources_all[RDT_RESOURCE_L3DATA].alloc_enabled)
 +		cdpl3_disable();
 +	if (rdt_resources_all[RDT_RESOURCE_L2DATA].alloc_enabled)
 +		cdpl2_disable();
++=======
+ 	if (resctrl_arch_get_cdp_enabled(RDT_RESOURCE_L3))
+ 		resctrl_arch_set_cdp_enabled(RDT_RESOURCE_L3, false);
+ 	if (resctrl_arch_get_cdp_enabled(RDT_RESOURCE_L2))
+ 		resctrl_arch_set_cdp_enabled(RDT_RESOURCE_L2, false);
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  }
  
  /*
@@@ -3151,13 -3212,13 +3189,20 @@@ out
  
  static int rdtgroup_show_options(struct seq_file *seq, struct kernfs_root *kf)
  {
++<<<<<<< HEAD
 +	if (rdt_resources_all[RDT_RESOURCE_L3DATA].alloc_enabled)
 +		seq_puts(seq, ",cdp");
 +
 +	if (rdt_resources_all[RDT_RESOURCE_L2DATA].alloc_enabled)
++=======
+ 	if (resctrl_arch_get_cdp_enabled(RDT_RESOURCE_L3))
+ 		seq_puts(seq, ",cdp");
+ 
+ 	if (resctrl_arch_get_cdp_enabled(RDT_RESOURCE_L2))
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  		seq_puts(seq, ",cdpl2");
  
 -	if (is_mba_sc(&rdt_resources_all[RDT_RESOURCE_MBA].r_resctrl))
 +	if (is_mba_sc(&rdt_resources_all[RDT_RESOURCE_MBA]))
  		seq_puts(seq, ",mba_MBps");
  
  	return 0;
diff --cc include/linux/resctrl.h
index 9b05af9b3e28,4b30571fbc8e..000000000000
--- a/include/linux/resctrl.h
+++ b/include/linux/resctrl.h
@@@ -13,4 -15,177 +13,180 @@@ int proc_resctrl_show(struct seq_file *
  
  #endif
  
++<<<<<<< HEAD
++=======
+ /**
+  * enum resctrl_conf_type - The type of configuration.
+  * @CDP_NONE:	No prioritisation, both code and data are controlled or monitored.
+  * @CDP_CODE:	Configuration applies to instruction fetches.
+  * @CDP_DATA:	Configuration applies to reads and writes.
+  */
+ enum resctrl_conf_type {
+ 	CDP_NONE,
+ 	CDP_CODE,
+ 	CDP_DATA,
+ };
+ 
+ /**
+  * struct rdt_domain - group of CPUs sharing a resctrl resource
+  * @list:		all instances of this resource
+  * @id:			unique id for this instance
+  * @cpu_mask:		which CPUs share this resource
+  * @new_ctrl:		new ctrl value to be loaded
+  * @have_new_ctrl:	did user provide new_ctrl for this domain
+  * @rmid_busy_llc:	bitmap of which limbo RMIDs are above threshold
+  * @mbm_total:		saved state for MBM total bandwidth
+  * @mbm_local:		saved state for MBM local bandwidth
+  * @mbm_over:		worker to periodically read MBM h/w counters
+  * @cqm_limbo:		worker to periodically read CQM h/w counters
+  * @mbm_work_cpu:	worker CPU for MBM h/w counters
+  * @cqm_work_cpu:	worker CPU for CQM h/w counters
+  * @plr:		pseudo-locked region (if any) associated with domain
+  */
+ struct rdt_domain {
+ 	struct list_head		list;
+ 	int				id;
+ 	struct cpumask			cpu_mask;
+ 	u32				new_ctrl;
+ 	bool				have_new_ctrl;
+ 	unsigned long			*rmid_busy_llc;
+ 	struct mbm_state		*mbm_total;
+ 	struct mbm_state		*mbm_local;
+ 	struct delayed_work		mbm_over;
+ 	struct delayed_work		cqm_limbo;
+ 	int				mbm_work_cpu;
+ 	int				cqm_work_cpu;
+ 	struct pseudo_lock_region	*plr;
+ };
+ 
+ /**
+  * struct resctrl_cache - Cache allocation related data
+  * @cbm_len:		Length of the cache bit mask
+  * @min_cbm_bits:	Minimum number of consecutive bits to be set
+  * @cbm_idx_mult:	Multiplier of CBM index
+  * @cbm_idx_offset:	Offset of CBM index. CBM index is computed by:
+  *			closid * cbm_idx_multi + cbm_idx_offset
+  *			in a cache bit mask
+  * @shareable_bits:	Bitmask of shareable resource with other
+  *			executing entities
+  * @arch_has_sparse_bitmaps:	True if a bitmap like f00f is valid.
+  * @arch_has_empty_bitmaps:	True if the '0' bitmap is valid.
+  * @arch_has_per_cpu_cfg:	True if QOS_CFG register for this cache
+  *				level has CPU scope.
+  */
+ struct resctrl_cache {
+ 	unsigned int	cbm_len;
+ 	unsigned int	min_cbm_bits;
+ 	unsigned int	cbm_idx_mult;	// TODO remove this
+ 	unsigned int	cbm_idx_offset; // TODO remove this
+ 	unsigned int	shareable_bits;
+ 	bool		arch_has_sparse_bitmaps;
+ 	bool		arch_has_empty_bitmaps;
+ 	bool		arch_has_per_cpu_cfg;
+ };
+ 
+ /**
+  * enum membw_throttle_mode - System's memory bandwidth throttling mode
+  * @THREAD_THROTTLE_UNDEFINED:	Not relevant to the system
+  * @THREAD_THROTTLE_MAX:	Memory bandwidth is throttled at the core
+  *				always using smallest bandwidth percentage
+  *				assigned to threads, aka "max throttling"
+  * @THREAD_THROTTLE_PER_THREAD:	Memory bandwidth is throttled at the thread
+  */
+ enum membw_throttle_mode {
+ 	THREAD_THROTTLE_UNDEFINED = 0,
+ 	THREAD_THROTTLE_MAX,
+ 	THREAD_THROTTLE_PER_THREAD,
+ };
+ 
+ /**
+  * struct resctrl_membw - Memory bandwidth allocation related data
+  * @min_bw:		Minimum memory bandwidth percentage user can request
+  * @bw_gran:		Granularity at which the memory bandwidth is allocated
+  * @delay_linear:	True if memory B/W delay is in linear scale
+  * @arch_needs_linear:	True if we can't configure non-linear resources
+  * @throttle_mode:	Bandwidth throttling mode when threads request
+  *			different memory bandwidths
+  * @mba_sc:		True if MBA software controller(mba_sc) is enabled
+  * @mb_map:		Mapping of memory B/W percentage to memory B/W delay
+  */
+ struct resctrl_membw {
+ 	u32				min_bw;
+ 	u32				bw_gran;
+ 	u32				delay_linear;
+ 	bool				arch_needs_linear;
+ 	enum membw_throttle_mode	throttle_mode;
+ 	bool				mba_sc;
+ 	u32				*mb_map;
+ };
+ 
+ struct rdt_parse_data;
+ struct resctrl_schema;
+ 
+ /**
+  * struct rdt_resource - attributes of a resctrl resource
+  * @rid:		The index of the resource
+  * @alloc_enabled:	Is allocation enabled on this machine
+  * @mon_enabled:	Is monitoring enabled for this feature
+  * @alloc_capable:	Is allocation available on this machine
+  * @mon_capable:	Is monitor feature available on this machine
+  * @num_rmid:		Number of RMIDs available
+  * @cache_level:	Which cache level defines scope of this resource
+  * @cache:		Cache allocation related data
+  * @membw:		If the component has bandwidth controls, their properties.
+  * @domains:		All domains for this resource
+  * @name:		Name to use in "schemata" file.
+  * @data_width:		Character width of data when displaying
+  * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
+  * @format_str:		Per resource format string to show domain value
+  * @parse_ctrlval:	Per resource function pointer to parse control values
+  * @evt_list:		List of monitoring events
+  * @fflags:		flags to choose base and info files
+  * @cdp_capable:	Is the CDP feature available on this resource
+  */
+ struct rdt_resource {
+ 	int			rid;
+ 	bool			alloc_enabled;
+ 	bool			mon_enabled;
+ 	bool			alloc_capable;
+ 	bool			mon_capable;
+ 	int			num_rmid;
+ 	int			cache_level;
+ 	struct resctrl_cache	cache;
+ 	struct resctrl_membw	membw;
+ 	struct list_head	domains;
+ 	char			*name;
+ 	int			data_width;
+ 	u32			default_ctrl;
+ 	const char		*format_str;
+ 	int			(*parse_ctrlval)(struct rdt_parse_data *data,
+ 						 struct resctrl_schema *s,
+ 						 struct rdt_domain *d);
+ 	struct list_head	evt_list;
+ 	unsigned long		fflags;
+ 	bool			cdp_capable;
+ };
+ 
+ /**
+  * struct resctrl_schema - configuration abilities of a resource presented to
+  *			   user-space
+  * @list:	Member of resctrl_schema_all.
+  * @conf_type:	Whether this schema is specific to code/data.
+  * @res:	The resource structure exported by the architecture to describe
+  *		the hardware that is configured by this schema.
+  * @num_closid:	The number of closid that can be used with this schema. When
+  *		features like CDP are enabled, this will be lower than the
+  *		hardware supports for the resource.
+  */
+ struct resctrl_schema {
+ 	struct list_head		list;
+ 	enum resctrl_conf_type		conf_type;
+ 	struct rdt_resource		*res;
+ 	u32				num_closid;
+ };
+ 
+ /* The number of closid supported by this resource regardless of CDP */
+ u32 resctrl_arch_get_num_closid(struct rdt_resource *r);
+ 
++>>>>>>> c091e90721b8 (x86/resctrl: Add a helper to read/set the CDP configuration)
  #endif /* _RESCTRL_H */
diff --git a/arch/x86/kernel/cpu/resctrl/core.c b/arch/x86/kernel/cpu/resctrl/core.c
index 916eb976301b..c02dea07bdaf 100644
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@ -355,6 +355,10 @@ static void rdt_get_cdp_config(int level, int type)
 	 * "cdp" during resctrl file system mount time.
 	 */
 	r->alloc_enabled = false;
+	rdt_resources_all[level].cdp_enabled = false;
+	rdt_resources_all[type].cdp_enabled = false;
+	r_l->cdp_capable = true;
+	r->cdp_capable = true;
 }
 
 static void rdt_get_cdp_l3_config(void)
* Unmerged path arch/x86/kernel/cpu/resctrl/internal.h
* Unmerged path arch/x86/kernel/cpu/resctrl/pseudo_lock.c
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
* Unmerged path include/linux/resctrl.h
