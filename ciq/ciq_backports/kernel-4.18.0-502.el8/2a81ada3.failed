driver core: make struct bus_type.uevent() take a const *

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
Rebuild_CHGLOG: - Revert "driver core: make struct bus_type.uevent() take a const *" (Jocelyn Falempe) [2160452]
Rebuild_FUZZ: 92.68%
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 2a81ada32f0e584fc0c943e0d3a8c9f4fae411d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/2a81ada3.failed

The uevent() callback in struct bus_type should not be modifying the
device that is passed into it, so mark it as a const * and propagate the
function signature changes out into all relevant subsystems that use
this callback.

	Acked-by: Rafael J. Wysocki <rafael@kernel.org>
	Acked-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/20230111113018.459199-16-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2a81ada32f0e584fc0c943e0d3a8c9f4fae411d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/platform.c
#	drivers/bcma/main.c
#	drivers/bus/sunxi-rsb.c
#	drivers/cxl/core/memdev.c
#	drivers/cxl/core/port.c
#	drivers/cxl/cxl.h
#	drivers/cxl/cxlmem.h
#	drivers/firmware/arm_ffa/bus.c
#	drivers/fpga/dfl.c
#	drivers/gpu/host1x/bus.c
#	drivers/macintosh/macio_asic.c
#	drivers/mmc/core/sdio_bus.c
#	drivers/nvdimm/nd-core.h
#	drivers/nvdimm/region_devs.c
#	drivers/slimbus/core.c
#	drivers/tee/tee_core.c
#	include/linux/device/bus.h
#	include/linux/spi/spi.h
diff --cc drivers/base/platform.c
index 935e9399cca8,262555b83bed..000000000000
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@@ -1298,9 -1353,9 +1298,13 @@@ static int platform_match(struct devic
  	return (strcmp(pdev->name, drv->name) == 0);
  }
  
- static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
+ static int platform_uevent(const struct device *dev, struct kobj_uevent_env *env)
  {
++<<<<<<< HEAD
 +	struct platform_device  *pdev = to_platform_device(dev);
++=======
+ 	const struct platform_device *pdev = to_platform_device(dev);
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  	int rc;
  
  	/* Some devices have extra OF data and an OF-style MODALIAS */
diff --cc drivers/bcma/main.c
index fc1f4acdd189,7b39f010bbb3..000000000000
--- a/drivers/bcma/main.c
+++ b/drivers/bcma/main.c
@@@ -27,8 -27,8 +27,13 @@@ static DEFINE_MUTEX(bcma_buses_mutex)
  
  static int bcma_bus_match(struct device *dev, struct device_driver *drv);
  static int bcma_device_probe(struct device *dev);
++<<<<<<< HEAD
 +static int bcma_device_remove(struct device *dev);
 +static int bcma_device_uevent(struct device *dev, struct kobj_uevent_env *env);
++=======
+ static void bcma_device_remove(struct device *dev);
+ static int bcma_device_uevent(const struct device *dev, struct kobj_uevent_env *env);
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  
  static ssize_t manuf_show(struct device *dev, struct device_attribute *attr, char *buf)
  {
@@@ -648,13 -625,11 +653,13 @@@ static int bcma_device_remove(struct de
  	if (adrv->remove)
  		adrv->remove(core);
  	put_device(dev);
 +
 +	return 0;
  }
  
- static int bcma_device_uevent(struct device *dev, struct kobj_uevent_env *env)
+ static int bcma_device_uevent(const struct device *dev, struct kobj_uevent_env *env)
  {
- 	struct bcma_device *core = container_of(dev, struct bcma_device, dev);
+ 	const struct bcma_device *core = container_of_const(dev, struct bcma_device, dev);
  
  	return add_uevent_var(env,
  			      "MODALIAS=bcma:m%04Xid%04Xrev%02Xcl%02X",
diff --cc drivers/bus/sunxi-rsb.c
index 1b76d9585902,9aa99c369e48..000000000000
--- a/drivers/bus/sunxi-rsb.c
+++ b/drivers/bus/sunxi-rsb.c
@@@ -170,7 -169,12 +170,16 @@@ static int sunxi_rsb_device_remove(stru
  {
  	const struct sunxi_rsb_driver *drv = to_sunxi_rsb_driver(dev->driver);
  
++<<<<<<< HEAD
 +	return drv->remove(to_sunxi_rsb_device(dev));
++=======
+ 	drv->remove(to_sunxi_rsb_device(dev));
+ }
+ 
+ static int sunxi_rsb_device_modalias(const struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	return of_device_uevent_modalias(dev, env);
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  }
  
  static struct bus_type sunxi_rsb_bus = {
diff --cc drivers/fpga/dfl.c
index 649958a36e62,4d32c98c82fc..000000000000
--- a/drivers/fpga/dfl.c
+++ b/drivers/fpga/dfl.c
@@@ -250,6 -245,247 +250,250 @@@ int dfl_fpga_check_port_id(struct platf
  }
  EXPORT_SYMBOL_GPL(dfl_fpga_check_port_id);
  
++<<<<<<< HEAD
++=======
+ static DEFINE_IDA(dfl_device_ida);
+ 
+ static const struct dfl_device_id *
+ dfl_match_one_device(const struct dfl_device_id *id, struct dfl_device *ddev)
+ {
+ 	if (id->type == ddev->type && id->feature_id == ddev->feature_id)
+ 		return id;
+ 
+ 	return NULL;
+ }
+ 
+ static int dfl_bus_match(struct device *dev, struct device_driver *drv)
+ {
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 	struct dfl_driver *ddrv = to_dfl_drv(drv);
+ 	const struct dfl_device_id *id_entry;
+ 
+ 	id_entry = ddrv->id_table;
+ 	if (id_entry) {
+ 		while (id_entry->feature_id) {
+ 			if (dfl_match_one_device(id_entry, ddev)) {
+ 				ddev->id_entry = id_entry;
+ 				return 1;
+ 			}
+ 			id_entry++;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dfl_bus_probe(struct device *dev)
+ {
+ 	struct dfl_driver *ddrv = to_dfl_drv(dev->driver);
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+ 	return ddrv->probe(ddev);
+ }
+ 
+ static void dfl_bus_remove(struct device *dev)
+ {
+ 	struct dfl_driver *ddrv = to_dfl_drv(dev->driver);
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+ 	if (ddrv->remove)
+ 		ddrv->remove(ddev);
+ }
+ 
+ static int dfl_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	const struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+ 	return add_uevent_var(env, "MODALIAS=dfl:t%04Xf%04X",
+ 			      ddev->type, ddev->feature_id);
+ }
+ 
+ static ssize_t
+ type_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+ 	return sprintf(buf, "0x%x\n", ddev->type);
+ }
+ static DEVICE_ATTR_RO(type);
+ 
+ static ssize_t
+ feature_id_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+ 	return sprintf(buf, "0x%x\n", ddev->feature_id);
+ }
+ static DEVICE_ATTR_RO(feature_id);
+ 
+ static struct attribute *dfl_dev_attrs[] = {
+ 	&dev_attr_type.attr,
+ 	&dev_attr_feature_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(dfl_dev);
+ 
+ static struct bus_type dfl_bus_type = {
+ 	.name		= "dfl",
+ 	.match		= dfl_bus_match,
+ 	.probe		= dfl_bus_probe,
+ 	.remove		= dfl_bus_remove,
+ 	.uevent		= dfl_bus_uevent,
+ 	.dev_groups	= dfl_dev_groups,
+ };
+ 
+ static void release_dfl_dev(struct device *dev)
+ {
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+ 	if (ddev->mmio_res.parent)
+ 		release_resource(&ddev->mmio_res);
+ 
+ 	ida_free(&dfl_device_ida, ddev->id);
+ 	kfree(ddev->irqs);
+ 	kfree(ddev);
+ }
+ 
+ static struct dfl_device *
+ dfl_dev_add(struct dfl_feature_platform_data *pdata,
+ 	    struct dfl_feature *feature)
+ {
+ 	struct platform_device *pdev = pdata->dev;
+ 	struct resource *parent_res;
+ 	struct dfl_device *ddev;
+ 	int id, i, ret;
+ 
+ 	ddev = kzalloc(sizeof(*ddev), GFP_KERNEL);
+ 	if (!ddev)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	id = ida_alloc(&dfl_device_ida, GFP_KERNEL);
+ 	if (id < 0) {
+ 		dev_err(&pdev->dev, "unable to get id\n");
+ 		kfree(ddev);
+ 		return ERR_PTR(id);
+ 	}
+ 
+ 	/* freeing resources by put_device() after device_initialize() */
+ 	device_initialize(&ddev->dev);
+ 	ddev->dev.parent = &pdev->dev;
+ 	ddev->dev.bus = &dfl_bus_type;
+ 	ddev->dev.release = release_dfl_dev;
+ 	ddev->id = id;
+ 	ret = dev_set_name(&ddev->dev, "dfl_dev.%d", id);
+ 	if (ret)
+ 		goto put_dev;
+ 
+ 	ddev->type = feature_dev_id_type(pdev);
+ 	ddev->feature_id = feature->id;
+ 	ddev->revision = feature->revision;
+ 	ddev->cdev = pdata->dfl_cdev;
+ 
+ 	/* add mmio resource */
+ 	parent_res = &pdev->resource[feature->resource_index];
+ 	ddev->mmio_res.flags = IORESOURCE_MEM;
+ 	ddev->mmio_res.start = parent_res->start;
+ 	ddev->mmio_res.end = parent_res->end;
+ 	ddev->mmio_res.name = dev_name(&ddev->dev);
+ 	ret = insert_resource(parent_res, &ddev->mmio_res);
+ 	if (ret) {
+ 		dev_err(&pdev->dev, "%s failed to claim resource: %pR\n",
+ 			dev_name(&ddev->dev), &ddev->mmio_res);
+ 		goto put_dev;
+ 	}
+ 
+ 	/* then add irq resource */
+ 	if (feature->nr_irqs) {
+ 		ddev->irqs = kcalloc(feature->nr_irqs,
+ 				     sizeof(*ddev->irqs), GFP_KERNEL);
+ 		if (!ddev->irqs) {
+ 			ret = -ENOMEM;
+ 			goto put_dev;
+ 		}
+ 
+ 		for (i = 0; i < feature->nr_irqs; i++)
+ 			ddev->irqs[i] = feature->irq_ctx[i].irq;
+ 
+ 		ddev->num_irqs = feature->nr_irqs;
+ 	}
+ 
+ 	ret = device_add(&ddev->dev);
+ 	if (ret)
+ 		goto put_dev;
+ 
+ 	dev_dbg(&pdev->dev, "add dfl_dev: %s\n", dev_name(&ddev->dev));
+ 	return ddev;
+ 
+ put_dev:
+ 	/* calls release_dfl_dev() which does the clean up  */
+ 	put_device(&ddev->dev);
+ 	return ERR_PTR(ret);
+ }
+ 
+ static void dfl_devs_remove(struct dfl_feature_platform_data *pdata)
+ {
+ 	struct dfl_feature *feature;
+ 
+ 	dfl_fpga_dev_for_each_feature(pdata, feature) {
+ 		if (feature->ddev) {
+ 			device_unregister(&feature->ddev->dev);
+ 			feature->ddev = NULL;
+ 		}
+ 	}
+ }
+ 
+ static int dfl_devs_add(struct dfl_feature_platform_data *pdata)
+ {
+ 	struct dfl_feature *feature;
+ 	struct dfl_device *ddev;
+ 	int ret;
+ 
+ 	dfl_fpga_dev_for_each_feature(pdata, feature) {
+ 		if (feature->ioaddr)
+ 			continue;
+ 
+ 		if (feature->ddev) {
+ 			ret = -EEXIST;
+ 			goto err;
+ 		}
+ 
+ 		ddev = dfl_dev_add(pdata, feature);
+ 		if (IS_ERR(ddev)) {
+ 			ret = PTR_ERR(ddev);
+ 			goto err;
+ 		}
+ 
+ 		feature->ddev = ddev;
+ 	}
+ 
+ 	return 0;
+ 
+ err:
+ 	dfl_devs_remove(pdata);
+ 	return ret;
+ }
+ 
+ int __dfl_driver_register(struct dfl_driver *dfl_drv, struct module *owner)
+ {
+ 	if (!dfl_drv || !dfl_drv->probe || !dfl_drv->id_table)
+ 		return -EINVAL;
+ 
+ 	dfl_drv->drv.owner = owner;
+ 	dfl_drv->drv.bus = &dfl_bus_type;
+ 
+ 	return driver_register(&dfl_drv->drv);
+ }
+ EXPORT_SYMBOL(__dfl_driver_register);
+ 
+ void dfl_driver_unregister(struct dfl_driver *dfl_drv)
+ {
+ 	driver_unregister(&dfl_drv->drv);
+ }
+ EXPORT_SYMBOL(dfl_driver_unregister);
+ 
+ #define is_header_feature(feature) ((feature)->id == FEATURE_ID_FIU_HEADER)
+ 
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  /**
   * dfl_fpga_dev_feature_uinit - uinit for sub features of dfl feature device
   * @pdev: feature device.
diff --cc drivers/gpu/host1x/bus.c
index 815bdb42e3f0,bc7271a00a94..000000000000
--- a/drivers/gpu/host1x/bus.c
+++ b/drivers/gpu/host1x/bus.c
@@@ -314,6 -338,36 +314,39 @@@ static int host1x_device_match(struct d
  	return strcmp(dev_name(dev), drv->name) == 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int host1x_device_uevent(const struct device *dev,
+ 				struct kobj_uevent_env *env)
+ {
+ 	struct device_node *np = dev->parent->of_node;
+ 	unsigned int count = 0;
+ 	struct property *p;
+ 	const char *compat;
+ 
+ 	/*
+ 	 * This duplicates most of of_device_uevent(), but the latter cannot
+ 	 * be called from modules and operates on dev->of_node, which is not
+ 	 * available in this case.
+ 	 *
+ 	 * Note that this is really only needed for backwards compatibility
+ 	 * with libdrm, which parses this information from sysfs and will
+ 	 * fail if it can't find the OF_FULLNAME, specifically.
+ 	 */
+ 	add_uevent_var(env, "OF_NAME=%pOFn", np);
+ 	add_uevent_var(env, "OF_FULLNAME=%pOF", np);
+ 
+ 	of_property_for_each_string(np, "compatible", p, compat) {
+ 		add_uevent_var(env, "OF_COMPATIBLE_%u=%s", count, compat);
+ 		count++;
+ 	}
+ 
+ 	add_uevent_var(env, "OF_COMPATIBLE_N=%u", count);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  static int host1x_dma_configure(struct device *dev)
  {
  	return of_dma_configure(dev, dev->of_node, true);
diff --cc drivers/macintosh/macio_asic.c
index 07074820a167,211ed9aa9edc..000000000000
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@@ -133,6 -128,11 +133,14 @@@ static int macio_device_resume(struct d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int macio_device_modalias(const struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	return of_device_uevent_modalias(dev, env);
+ }
+ 
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  extern const struct attribute_group *macio_dev_groups[];
  
  struct bus_type macio_bus_type = {
diff --cc drivers/mmc/core/sdio_bus.c
index b6d8203e46eb,5ec4e4ca52f0..000000000000
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@@ -107,9 -120,10 +107,14 @@@ static int sdio_bus_match(struct devic
  }
  
  static int
- sdio_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+ sdio_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
  {
++<<<<<<< HEAD
 +	struct sdio_func *func = dev_to_sdio_func(dev);
++=======
+ 	const struct sdio_func *func = dev_to_sdio_func(dev);
+ 	unsigned int i;
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  
  	if (add_uevent_var(env,
  			"SDIO_CLASS=%02X", func->class))
diff --cc drivers/nvdimm/nd-core.h
index 11a73d667c4f,ca2bbc57e755..000000000000
--- a/drivers/nvdimm/nd-core.h
+++ b/drivers/nvdimm/nd-core.h
@@@ -88,32 -82,14 +88,39 @@@ static inline void nvdimm_security_over
  }
  #endif
  
++<<<<<<< HEAD
 +/**
 + * struct blk_alloc_info - tracking info for BLK dpa scanning
 + * @nd_mapping: blk region mapping boundaries
 + * @available: decremented in alias_dpa_busy as aliased PMEM is scanned
 + * @busy: decremented in blk_dpa_busy to account for ranges already
 + * 	  handled by alias_dpa_busy
 + * @res: alias_dpa_busy interprets this a free space range that needs to
 + * 	 be truncated to the valid BLK allocation starting DPA, blk_dpa_busy
 + * 	 treats it as a busy range that needs the aliased PMEM ranges
 + * 	 truncated.
 + */
 +struct blk_alloc_info {
 +	struct nd_mapping *nd_mapping;
 +	resource_size_t available, busy;
 +	struct resource *res;
 +};
 +
 +bool is_nvdimm(struct device *dev);
 +bool is_nd_pmem(struct device *dev);
 +bool is_nd_volatile(struct device *dev);
 +bool is_nd_blk(struct device *dev);
 +static inline bool is_nd_region(struct device *dev)
++=======
+ bool is_nvdimm(const struct device *dev);
+ bool is_nd_pmem(const struct device *dev);
+ bool is_nd_volatile(const struct device *dev);
+ static inline bool is_nd_region(const struct device *dev)
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  {
 -	return is_nd_pmem(dev) || is_nd_volatile(dev);
 +	return is_nd_pmem(dev) || is_nd_blk(dev) || is_nd_volatile(dev);
  }
- static inline bool is_memory(struct device *dev)
+ static inline bool is_memory(const struct device *dev)
  {
  	return is_nd_pmem(dev) || is_nd_volatile(dev);
  }
diff --cc drivers/nvdimm/region_devs.c
index 1185959609cb,8f134d63af13..000000000000
--- a/drivers/nvdimm/region_devs.c
+++ b/drivers/nvdimm/region_devs.c
@@@ -862,12 -844,7 +862,16 @@@ bool is_nd_pmem(const struct device *de
  	return dev ? dev->type == &nd_pmem_device_type : false;
  }
  
++<<<<<<< HEAD
 +bool is_nd_blk(struct device *dev)
 +{
 +	return dev ? dev->type == &nd_blk_device_type : false;
 +}
 +
 +bool is_nd_volatile(struct device *dev)
++=======
+ bool is_nd_volatile(const struct device *dev)
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  {
  	return dev ? dev->type == &nd_volatile_device_type : false;
  }
diff --cc drivers/slimbus/core.c
index 7ddfc675b131,d43873bb5fe6..000000000000
--- a/drivers/slimbus/core.c
+++ b/drivers/slimbus/core.c
@@@ -53,8 -91,13 +53,16 @@@ static int slim_device_remove(struct de
  		if (sbdrv->remove)
  			sbdrv->remove(sbdev);
  	}
 -}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ static int slim_device_uevent(const struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	const struct slim_device *sbdev = to_slim_device(dev);
+ 
+ 	return add_uevent_var(env, "MODALIAS=slim:%s", dev_name(&sbdev->dev));
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  }
  
  struct bus_type slimbus_bus = {
diff --cc drivers/tee/tee_core.c
index 893ea2b65ecb,452cbb8ad484..000000000000
--- a/drivers/tee/tee_core.c
+++ b/drivers/tee/tee_core.c
@@@ -1045,6 -1180,48 +1045,51 @@@ int tee_client_invoke_func(struct tee_c
  }
  EXPORT_SYMBOL_GPL(tee_client_invoke_func);
  
++<<<<<<< HEAD
++=======
+ int tee_client_cancel_req(struct tee_context *ctx,
+ 			  struct tee_ioctl_cancel_arg *arg)
+ {
+ 	if (!ctx->teedev->desc->ops->cancel_req)
+ 		return -EINVAL;
+ 	return ctx->teedev->desc->ops->cancel_req(ctx, arg->cancel_id,
+ 						  arg->session);
+ }
+ 
+ static int tee_client_device_match(struct device *dev,
+ 				   struct device_driver *drv)
+ {
+ 	const struct tee_client_device_id *id_table;
+ 	struct tee_client_device *tee_device;
+ 
+ 	id_table = to_tee_client_driver(drv)->id_table;
+ 	tee_device = to_tee_client_device(dev);
+ 
+ 	while (!uuid_is_null(&id_table->uuid)) {
+ 		if (uuid_equal(&tee_device->id.uuid, &id_table->uuid))
+ 			return 1;
+ 		id_table++;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tee_client_device_uevent(const struct device *dev,
+ 				    struct kobj_uevent_env *env)
+ {
+ 	uuid_t *dev_id = &to_tee_client_device(dev)->id.uuid;
+ 
+ 	return add_uevent_var(env, "MODALIAS=tee:%pUb", dev_id);
+ }
+ 
+ struct bus_type tee_bus_type = {
+ 	.name		= "tee",
+ 	.match		= tee_client_device_match,
+ 	.uevent		= tee_client_device_uevent,
+ };
+ EXPORT_SYMBOL_GPL(tee_bus_type);
+ 
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  static int __init tee_init(void)
  {
  	int rc;
diff --cc include/linux/spi/spi.h
index 95522a5aa253,2edf7f09239e..000000000000
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@@ -188,7 -219,11 +188,15 @@@ struct spi_device 
  	 */
  };
  
++<<<<<<< HEAD
 +static inline struct spi_device *to_spi_device(struct device *dev)
++=======
+ /* Make sure that SPI_MODE_KERNEL_MASK & SPI_MODE_USER_MASK don't overlap */
+ static_assert((SPI_MODE_KERNEL_MASK & SPI_MODE_USER_MASK) == 0,
+ 	      "SPI_MODE_USER_MASK & SPI_MODE_KERNEL_MASK must not overlap");
+ 
+ static inline struct spi_device *to_spi_device(const struct device *dev)
++>>>>>>> 2a81ada32f0e (driver core: make struct bus_type.uevent() take a const *)
  {
  	return dev ? container_of(dev, struct spi_device, dev) : NULL;
  }
* Unmerged path drivers/cxl/core/memdev.c
* Unmerged path drivers/cxl/core/port.c
* Unmerged path drivers/cxl/cxl.h
* Unmerged path drivers/cxl/cxlmem.h
* Unmerged path drivers/firmware/arm_ffa/bus.c
* Unmerged path include/linux/device/bus.h
diff --git a/arch/mips/sgi-ip22/ip22-gio.c b/arch/mips/sgi-ip22/ip22-gio.c
index b225033aade6..ef14beb552c3 100644
--- a/arch/mips/sgi-ip22/ip22-gio.c
+++ b/arch/mips/sgi-ip22/ip22-gio.c
@@ -199,9 +199,9 @@ static struct attribute *gio_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(gio_dev);
 
-static int gio_device_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int gio_device_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct gio_device *gio_dev = to_gio_device(dev);
+	const struct gio_device *gio_dev = to_gio_device(dev);
 
 	add_uevent_var(env, "MODALIAS=gio:%x", gio_dev->id.id);
 	return 0;
diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 5eb979d04b90..28115d568893 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -532,7 +532,7 @@ static int parisc_generic_match(struct device *dev, struct device_driver *drv)
 	return match_device(to_parisc_driver(drv), to_parisc_device(dev));
 }
 
-static ssize_t make_modalias(struct device *dev, char *buf)
+static ssize_t make_modalias(const struct device *dev, char *buf)
 {
 	const struct parisc_device *padev = to_parisc_device(dev);
 	const struct parisc_device_id *id = &padev->id;
@@ -542,7 +542,7 @@ static ssize_t make_modalias(struct device *dev, char *buf)
 		(u32)id->sversion);
 }
 
-static int parisc_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int parisc_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct parisc_device *padev;
 	char modalias[40];
diff --git a/arch/powerpc/platforms/pseries/vio.c b/arch/powerpc/platforms/pseries/vio.c
index 4f70b4fc7e22..fb18d03ac195 100644
--- a/arch/powerpc/platforms/pseries/vio.c
+++ b/arch/powerpc/platforms/pseries/vio.c
@@ -1597,10 +1597,10 @@ static int vio_bus_match(struct device *dev, struct device_driver *drv)
 	return (ids != NULL) && (vio_match_device(ids, vio_dev) != NULL);
 }
 
-static int vio_hotplug(struct device *dev, struct kobj_uevent_env *env)
+static int vio_hotplug(const struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct vio_dev *vio_dev = to_vio_dev(dev);
-	struct device_node *dn;
+	const struct device_node *dn;
 	const char *cp;
 
 	dn = dev->of_node;
diff --git a/arch/sparc/kernel/vio.c b/arch/sparc/kernel/vio.c
index 32bae68e34c1..4c9cd8d40ceb 100644
--- a/arch/sparc/kernel/vio.c
+++ b/arch/sparc/kernel/vio.c
@@ -46,7 +46,7 @@ static const struct vio_device_id *vio_match_device(
 	return NULL;
 }
 
-static int vio_hotplug(struct device *dev, struct kobj_uevent_env *env)
+static int vio_hotplug(const struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct vio_dev *vio_dev = to_vio_dev(dev);
 
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 64c40f31e5c6..c01419f2cd6e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1029,7 +1029,7 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }
 
-static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int acpi_device_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	return __acpi_device_uevent_modalias(to_acpi_device(dev), env);
 }
diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 41b706403ef7..91af645737c6 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -53,9 +53,9 @@ static int amba_match(struct device *dev, struct device_driver *drv)
 	return amba_lookup(pcdrv->id_table, pcdev) != NULL;
 }
 
-static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int amba_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct amba_device *pcdev = to_amba_device(dev);
+	const struct amba_device *pcdev = to_amba_device(dev);
 	int retval = 0;
 
 	retval = add_uevent_var(env, "AMBA_ID=%08x", pcdev->periphid);
diff --git a/drivers/base/auxiliary.c b/drivers/base/auxiliary.c
index adc199dfba3c..89baf042f10e 100644
--- a/drivers/base/auxiliary.c
+++ b/drivers/base/auxiliary.c
@@ -44,7 +44,7 @@ static int auxiliary_match(struct device *dev, struct device_driver *drv)
 	return !!auxiliary_match_id(auxdrv->id_table, auxdev);
 }
 
-static int auxiliary_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int auxiliary_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	const char *name, *p;
 
diff --git a/drivers/base/cpu.c b/drivers/base/cpu.c
index 2adb3e646da2..0ddeeec64631 100644
--- a/drivers/base/cpu.c
+++ b/drivers/base/cpu.c
@@ -336,7 +336,7 @@ static ssize_t print_cpu_modalias(struct device *dev,
 	return len;
 }
 
-static int cpu_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int cpu_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	char *buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
 	if (buf) {
* Unmerged path drivers/base/platform.c
* Unmerged path drivers/bcma/main.c
diff --git a/drivers/bus/fsl-mc/fsl-mc-bus.c b/drivers/bus/fsl-mc/fsl-mc-bus.c
index 5d8266c6571f..107f7ddfa79e 100644
--- a/drivers/bus/fsl-mc/fsl-mc-bus.c
+++ b/drivers/bus/fsl-mc/fsl-mc-bus.c
@@ -115,9 +115,9 @@ static int fsl_mc_bus_match(struct device *dev, struct device_driver *drv)
 /**
  * fsl_mc_bus_uevent - callback invoked when a device is added
  */
-static int fsl_mc_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int fsl_mc_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);
+	const struct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);
 
 	if (add_uevent_var(env, "MODALIAS=fsl-mc:v%08Xd%s",
 			   mc_dev->obj_desc.vendor,
diff --git a/drivers/bus/mhi/ep/main.c b/drivers/bus/mhi/ep/main.c
index dffe03658ff9..a6a48e515478 100644
--- a/drivers/bus/mhi/ep/main.c
+++ b/drivers/bus/mhi/ep/main.c
@@ -1550,9 +1550,9 @@ void mhi_ep_driver_unregister(struct mhi_ep_driver *mhi_drv)
 }
 EXPORT_SYMBOL_GPL(mhi_ep_driver_unregister);
 
-static int mhi_ep_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mhi_ep_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mhi_ep_device *mhi_dev = to_mhi_ep_device(dev);
+	const struct mhi_ep_device *mhi_dev = to_mhi_ep_device(dev);
 
 	return add_uevent_var(env, "MODALIAS=" MHI_EP_DEVICE_MODALIAS_FMT,
 					mhi_dev->name);
diff --git a/drivers/bus/mhi/host/init.c b/drivers/bus/mhi/host/init.c
index 7307335c4fd1..3d779ee6396d 100644
--- a/drivers/bus/mhi/host/init.c
+++ b/drivers/bus/mhi/host/init.c
@@ -1395,9 +1395,9 @@ void mhi_driver_unregister(struct mhi_driver *mhi_drv)
 }
 EXPORT_SYMBOL_GPL(mhi_driver_unregister);
 
-static int mhi_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mhi_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mhi_device *mhi_dev = to_mhi_device(dev);
+	const struct mhi_device *mhi_dev = to_mhi_device(dev);
 
 	return add_uevent_var(env, "MODALIAS=" MHI_DEVICE_MODALIAS_FMT,
 					mhi_dev->name);
diff --git a/drivers/bus/mips_cdmm.c b/drivers/bus/mips_cdmm.c
index 1b14256376d2..5b8902649bc8 100644
--- a/drivers/bus/mips_cdmm.c
+++ b/drivers/bus/mips_cdmm.c
@@ -65,9 +65,9 @@ static int mips_cdmm_match(struct device *dev, struct device_driver *drv)
 	return mips_cdmm_lookup(cdrv->id_table, cdev) != NULL;
 }
 
-static int mips_cdmm_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mips_cdmm_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);
+	const struct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);
 	int retval = 0;
 
 	retval = add_uevent_var(env, "CDMM_CPU=%u", cdev->cpu);
* Unmerged path drivers/bus/sunxi-rsb.c
* Unmerged path drivers/cxl/core/memdev.c
* Unmerged path drivers/cxl/core/port.c
* Unmerged path drivers/cxl/cxl.h
* Unmerged path drivers/cxl/cxlmem.h
diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index 76f1c414be9e..2db2e1bf2171 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -19,7 +19,7 @@ struct dax_id {
 	char dev_name[DAX_NAME_LEN];
 };
 
-static int dax_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int dax_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	/*
 	 * We only ever expect to handle device-dax instances, i.e. the
diff --git a/drivers/eisa/eisa-bus.c b/drivers/eisa/eisa-bus.c
index 1e8062f6dbfc..488ff5c45cb3 100644
--- a/drivers/eisa/eisa-bus.c
+++ b/drivers/eisa/eisa-bus.c
@@ -128,9 +128,9 @@ static int eisa_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int eisa_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int eisa_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct eisa_device *edev = to_eisa_device(dev);
+	const struct eisa_device *edev = to_eisa_device(dev);
 
 	add_uevent_var(env, "MODALIAS=" EISA_DEVICE_MODALIAS_FMT, edev->id.sig);
 	return 0;
* Unmerged path drivers/firmware/arm_ffa/bus.c
* Unmerged path drivers/fpga/dfl.c
diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
index c317ee9fa445..71b02ee73785 100644
--- a/drivers/gpu/drm/drm_mipi_dsi.c
+++ b/drivers/gpu/drm/drm_mipi_dsi.c
@@ -62,9 +62,9 @@ static int mipi_dsi_device_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int mipi_dsi_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mipi_dsi_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);
+	const struct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);
 	int err;
 
 	err = of_device_uevent_modalias(dev, env);
* Unmerged path drivers/gpu/host1x/bus.c
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index 7db332139f7d..82a46cd4a3a3 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -2350,9 +2350,9 @@ static const struct attribute_group hid_dev_group = {
 };
 __ATTRIBUTE_GROUPS(hid_dev);
 
-static int hid_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int hid_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct hid_device *hdev = to_hid_device(dev);
+	const struct hid_device *hdev = to_hid_device(dev);
 
 	if (add_uevent_var(env, "HID_ID=%04X:%08X:%08X",
 			hdev->bus, hdev->vendor, hdev->product))
diff --git a/drivers/hid/intel-ish-hid/ishtp/bus.c b/drivers/hid/intel-ish-hid/ishtp/bus.c
index f55c8be2728d..8c121d1364c5 100644
--- a/drivers/hid/intel-ish-hid/ishtp/bus.c
+++ b/drivers/hid/intel-ish-hid/ishtp/bus.c
@@ -363,7 +363,7 @@ static struct attribute *ishtp_cl_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(ishtp_cl_dev);
 
-static int ishtp_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ishtp_cl_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	if (add_uevent_var(env, "MODALIAS=" ISHTP_MODULE_PREFIX "%s", dev_name(dev)))
 		return -ENOMEM;
diff --git a/drivers/hsi/hsi_core.c b/drivers/hsi/hsi_core.c
index 9065efd21851..f965f55d35cb 100644
--- a/drivers/hsi/hsi_core.c
+++ b/drivers/hsi/hsi_core.c
@@ -43,7 +43,7 @@ static struct attribute *hsi_bus_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(hsi_bus_dev);
 
-static int hsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int hsi_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	add_uevent_var(env, "MODALIAS=hsi:%s", dev_name(dev));
 
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 3813d713899a..e776fb2cf00d 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -743,9 +743,9 @@ __ATTRIBUTE_GROUPS(vmbus_bus);
  * representation of the device guid (each byte of the guid will be
  * represented with two hex characters.
  */
-static int vmbus_uevent(struct device *device, struct kobj_uevent_env *env)
+static int vmbus_uevent(const struct device *device, struct kobj_uevent_env *env)
 {
-	struct hv_device *dev = device_to_hv_device(device);
+	const struct hv_device *dev = device_to_hv_device(device);
 	const char *format = "MODALIAS=vmbus:%*phN";
 
 	return add_uevent_var(env, format, UUID_SIZE, &dev->dev_type);
diff --git a/drivers/input/serio/serio.c b/drivers/input/serio/serio.c
index 29f491082926..4b8a0fa4e18f 100644
--- a/drivers/input/serio/serio.c
+++ b/drivers/input/serio/serio.c
@@ -899,9 +899,9 @@ static int serio_bus_match(struct device *dev, struct device_driver *drv)
 			return err;					\
 	} while (0)
 
-static int serio_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int serio_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct serio *serio;
+	const struct serio *serio;
 
 	if (!dev)
 		return -ENODEV;
diff --git a/drivers/ipack/ipack.c b/drivers/ipack/ipack.c
index a1e07a77d4e6..8d0002215017 100644
--- a/drivers/ipack/ipack.c
+++ b/drivers/ipack/ipack.c
@@ -85,9 +85,9 @@ static int ipack_bus_remove(struct device *device)
 	return 0;
 }
 
-static int ipack_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ipack_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct ipack_device *idev;
+	const struct ipack_device *idev;
 
 	if (!dev)
 		return -ENODEV;
* Unmerged path drivers/macintosh/macio_asic.c
diff --git a/drivers/mcb/mcb-core.c b/drivers/mcb/mcb-core.c
index bb5c5692dedc..d45a335f56d4 100644
--- a/drivers/mcb/mcb-core.c
+++ b/drivers/mcb/mcb-core.c
@@ -44,9 +44,9 @@ static int mcb_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int mcb_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mcb_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mcb_device *mdev = to_mcb_device(dev);
+	const struct mcb_device *mdev = to_mcb_device(dev);
 	int ret;
 
 	ret = add_uevent_var(env, "MODALIAS=mcb:16z%03d", mdev->id);
diff --git a/drivers/memstick/core/memstick.c b/drivers/memstick/core/memstick.c
index ebd457f653e1..5a6e058c7d94 100644
--- a/drivers/memstick/core/memstick.c
+++ b/drivers/memstick/core/memstick.c
@@ -61,10 +61,10 @@ static int memstick_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int memstick_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int memstick_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct memstick_dev *card = container_of(dev, struct memstick_dev,
-						  dev);
+	const struct memstick_dev *card = container_of_const(dev, struct memstick_dev,
+							     dev);
 
 	if (add_uevent_var(env, "MEMSTICK_TYPE=%02X", card->id.type))
 		return -ENOMEM;
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index bffa63b232fb..c425c69d4984 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -1204,9 +1204,9 @@ ATTRIBUTE_GROUPS(mei_cldev);
  *
  * Return: 0 on success -ENOMEM on when add_uevent_var fails
  */
-static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mei_cl_device_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 	u8 version = mei_me_cl_ver(cldev->me_cl);
 
diff --git a/drivers/misc/tifm_core.c b/drivers/misc/tifm_core.c
index a511b2a713b3..bce8118ac00b 100644
--- a/drivers/misc/tifm_core.c
+++ b/drivers/misc/tifm_core.c
@@ -59,9 +59,9 @@ static int tifm_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int tifm_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int tifm_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);
+	const struct tifm_dev *sock = container_of_const(dev, struct tifm_dev, dev);
 
 	if (add_uevent_var(env, "TIFM_CARD_TYPE=%s", tifm_media_type_name(sock->type, 1)))
 		return -ENOMEM;
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index fc92c6c1c9a4..036c496df128 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -67,9 +67,9 @@ static int mmc_bus_match(struct device *dev, struct device_driver *drv)
 }
 
 static int
-mmc_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+mmc_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mmc_card *card = mmc_dev_to_card(dev);
+	const struct mmc_card *card = mmc_dev_to_card(dev);
 	const char *type;
 	int retval = 0;
 
* Unmerged path drivers/mmc/core/sdio_bus.c
diff --git a/drivers/net/phy/mdio_bus.c b/drivers/net/phy/mdio_bus.c
index ae56eac60f69..0400957e1224 100644
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -1028,7 +1028,7 @@ static int mdio_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int mdio_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mdio_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	int rc;
 
diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c
index cd51492ae6c2..37b9510e6f59 100644
--- a/drivers/net/xen-netback/xenbus.c
+++ b/drivers/net/xen-netback/xenbus.c
@@ -444,7 +444,7 @@ static int netback_probe(struct xenbus_device *dev,
  * and vif variables to the environment, for the benefit of the vif-* hotplug
  * scripts.
  */
-static int netback_uevent(struct xenbus_device *xdev,
+static int netback_uevent(const struct xenbus_device *xdev,
 			  struct kobj_uevent_env *env)
 {
 	struct backend_info *be = dev_get_drvdata(&xdev->dev);
diff --git a/drivers/nvdimm/bus.c b/drivers/nvdimm/bus.c
index 1a1a3ef09626..f3cf6d9b42d1 100644
--- a/drivers/nvdimm/bus.c
+++ b/drivers/nvdimm/bus.c
@@ -37,7 +37,7 @@ static int nvdimm_bus_major;
 static struct class *nd_class;
 static DEFINE_IDA(nd_ida);
 
-static int to_nd_device_type(struct device *dev)
+static int to_nd_device_type(const struct device *dev)
 {
 	if (is_nvdimm(dev))
 		return ND_DEVICE_DIMM;
@@ -53,7 +53,7 @@ static int to_nd_device_type(struct device *dev)
 	return 0;
 }
 
-static int nvdimm_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int nvdimm_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	return add_uevent_var(env, "MODALIAS=" ND_DEVICE_MODALIAS_FMT,
 			to_nd_device_type(dev));
diff --git a/drivers/nvdimm/dax_devs.c b/drivers/nvdimm/dax_devs.c
index 79860e2b8104..f7308667dd9b 100644
--- a/drivers/nvdimm/dax_devs.c
+++ b/drivers/nvdimm/dax_devs.c
@@ -46,7 +46,7 @@ static const struct device_type nd_dax_device_type = {
 	.groups = nd_pfn_attribute_groups,
 };
 
-bool is_nd_dax(struct device *dev)
+bool is_nd_dax(const struct device *dev)
 {
 	return dev ? dev->type == &nd_dax_device_type : false;
 }
diff --git a/drivers/nvdimm/dimm_devs.c b/drivers/nvdimm/dimm_devs.c
index 35aeb29152d3..53e0f8fab055 100644
--- a/drivers/nvdimm/dimm_devs.c
+++ b/drivers/nvdimm/dimm_devs.c
@@ -466,7 +466,7 @@ static const struct device_type nvdimm_device_type = {
 	.groups = nvdimm_attribute_groups,
 };
 
-bool is_nvdimm(struct device *dev)
+bool is_nvdimm(const struct device *dev)
 {
 	return dev->type == &nvdimm_device_type;
 }
* Unmerged path drivers/nvdimm/nd-core.h
diff --git a/drivers/nvdimm/nd.h b/drivers/nvdimm/nd.h
index 0563bb60a9a5..e32936380aed 100644
--- a/drivers/nvdimm/nd.h
+++ b/drivers/nvdimm/nd.h
@@ -345,7 +345,7 @@ static inline int nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)
 struct nd_dax *to_nd_dax(struct device *dev);
 #if IS_ENABLED(CONFIG_NVDIMM_DAX)
 int nd_dax_probe(struct device *dev, struct nd_namespace_common *ndns);
-bool is_nd_dax(struct device *dev);
+bool is_nd_dax(const struct device *dev);
 struct device *nd_dax_create(struct nd_region *nd_region);
 #else
 static inline int nd_dax_probe(struct device *dev,
@@ -354,7 +354,7 @@ static inline int nd_dax_probe(struct device *dev,
 	return -ENODEV;
 }
 
-static inline bool is_nd_dax(struct device *dev)
+static inline bool is_nd_dax(const struct device *dev)
 {
 	return false;
 }
* Unmerged path drivers/nvdimm/region_devs.c
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index deec7158460a..a7e6d763b30f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1602,9 +1602,9 @@ void pci_dev_put(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_dev_put);
 
-static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int pci_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct pci_dev *pdev;
+	const struct pci_dev *pdev;
 
 	if (!dev)
 		return -ENODEV;
diff --git a/drivers/pcmcia/ds.c b/drivers/pcmcia/ds.c
index a9258f641cee..9f0609a41397 100644
--- a/drivers/pcmcia/ds.c
+++ b/drivers/pcmcia/ds.c
@@ -935,9 +935,9 @@ static int pcmcia_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int pcmcia_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int pcmcia_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct pcmcia_device *p_dev;
+	const struct pcmcia_device *p_dev;
 	int i;
 	u32 hash[4] = { 0, 0, 0, 0};
 
diff --git a/drivers/platform/x86/wmi.c b/drivers/platform/x86/wmi.c
index ec4cfa9ba5d9..93914412e5bf 100644
--- a/drivers/platform/x86/wmi.c
+++ b/drivers/platform/x86/wmi.c
@@ -742,9 +742,9 @@ static struct attribute *wmi_method_attrs[] = {
 };
 ATTRIBUTE_GROUPS(wmi_method);
 
-static int wmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int wmi_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct wmi_block *wblock = dev_to_wblock(dev);
+	const struct wmi_block *wblock = dev_to_wblock(dev);
 
 	if (add_uevent_var(env, "MODALIAS=wmi:%pUL", wblock->gblock.guid))
 		return -ENOMEM;
diff --git a/drivers/rapidio/rio-driver.c b/drivers/rapidio/rio-driver.c
index 128350f4d17a..ece4738b1414 100644
--- a/drivers/rapidio/rio-driver.c
+++ b/drivers/rapidio/rio-driver.c
@@ -209,9 +209,9 @@ static int rio_match_bus(struct device *dev, struct device_driver *drv)
       out:return 0;
 }
 
-static int rio_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int rio_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct rio_dev *rdev;
+	const struct rio_dev *rdev;
 
 	if (!dev)
 		return -ENODEV;
diff --git a/drivers/rpmsg/rpmsg_core.c b/drivers/rpmsg/rpmsg_core.c
index b714a543a91d..b4569c006e22 100644
--- a/drivers/rpmsg/rpmsg_core.c
+++ b/drivers/rpmsg/rpmsg_core.c
@@ -420,9 +420,9 @@ static int rpmsg_dev_match(struct device *dev, struct device_driver *drv)
 	return of_driver_match_device(dev, drv);
 }
 
-static int rpmsg_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int rpmsg_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct rpmsg_device *rpdev = to_rpmsg_device(dev);
+	const struct rpmsg_device *rpdev = to_rpmsg_device(dev);
 	int ret;
 
 	ret = of_device_uevent_modalias(dev, env);
diff --git a/drivers/s390/cio/css.c b/drivers/s390/cio/css.c
index 8a1d2f3c61ee..ad079606f9ed 100644
--- a/drivers/s390/cio/css.c
+++ b/drivers/s390/cio/css.c
@@ -1438,9 +1438,9 @@ static void css_shutdown(struct device *dev)
 		sch->driver->shutdown(sch);
 }
 
-static int css_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int css_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct subchannel *sch = to_subchannel(dev);
+	const struct subchannel *sch = to_subchannel(dev);
 	int ret;
 
 	ret = add_uevent_var(env, "ST=%01X", sch->st);
diff --git a/drivers/s390/cio/device.c b/drivers/s390/cio/device.c
index 5312699c099b..9687ef0e4f84 100644
--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@ -80,7 +80,7 @@ ccw_bus_match (struct device * dev, struct device_driver * drv)
  * specified size. Return length of resulting string (excluding trailing '\0')
  * even if string doesn't fit buffer (snprintf semantics). */
 static int snprint_alias(char *buf, size_t size,
-			 struct ccw_device_id *id, const char *suffix)
+			 const struct ccw_device_id *id, const char *suffix)
 {
 	int len;
 
@@ -101,10 +101,10 @@ static int snprint_alias(char *buf, size_t size,
 
 /* Set up environment variables for ccw device uevent. Return 0 on success,
  * non-zero otherwise. */
-static int ccw_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ccw_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct ccw_device *cdev = to_ccwdev(dev);
-	struct ccw_device_id *id = &(cdev->id);
+	const struct ccw_device *cdev = to_ccwdev(dev);
+	const struct ccw_device_id *id = &(cdev->id);
 	int ret;
 	char modalias_buf[30];
 
diff --git a/drivers/s390/cio/scm.c b/drivers/s390/cio/scm.c
index 9f26d4310bb3..488a1ae8b5fe 100644
--- a/drivers/s390/cio/scm.c
+++ b/drivers/s390/cio/scm.c
@@ -36,7 +36,7 @@ static int scmdev_remove(struct device *dev)
 	return scmdrv->remove ? scmdrv->remove(scmdev) : -ENODEV;
 }
 
-static int scmdev_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int scmdev_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	return add_uevent_var(env, "MODALIAS=scm:scmdev");
 }
diff --git a/drivers/s390/crypto/ap_bus.c b/drivers/s390/crypto/ap_bus.c
index 733e1cac1d69..e3f6030452a6 100644
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@ -621,10 +621,10 @@ static int ap_bus_match(struct device *dev, struct device_driver *drv)
  * It sets up a single environment variable DEV_TYPE which contains the
  * hardware device type.
  */
-static int ap_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ap_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	int rc = 0;
-	struct ap_device *ap_dev = to_ap_dev(dev);
+	const struct ap_device *ap_dev = to_ap_dev(dev);
 
 	/* Uevents from ap bus core don't need extensions to the env */
 	if (dev == ap_root_device)
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 9f333d67a7f3..8c0ae5bb0721 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -541,9 +541,9 @@ static int scsi_bus_match(struct device *dev, struct device_driver *gendrv)
 	return (sdp->inq_periph_qual == SCSI_INQ_PQ_CON)? 1: 0;
 }
 
-static int scsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int scsi_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct scsi_device *sdev;
+	const struct scsi_device *sdev;
 
 	if (dev->type != &scsi_dev_type)
 		return 0;
* Unmerged path drivers/slimbus/core.c
diff --git a/drivers/soc/qcom/apr.c b/drivers/soc/qcom/apr.c
index 57af8a537332..bbe612e17867 100644
--- a/drivers/soc/qcom/apr.c
+++ b/drivers/soc/qcom/apr.c
@@ -181,9 +181,9 @@ static int apr_device_remove(struct device *dev)
 	return 0;
 }
 
-static int apr_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int apr_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct apr_device *adev = to_apr_device(dev);
+	const struct apr_device *adev = to_apr_device(dev);
 	int ret;
 
 	ret = of_device_uevent_modalias(dev, env);
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 17b569013205..9804ce022c6a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -362,7 +362,7 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 	return strcmp(spi->modalias, drv->name) == 0;
 }
 
-static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int spi_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct spi_device		*spi = to_spi_device(dev);
 	int rc;
diff --git a/drivers/spmi/spmi.c b/drivers/spmi/spmi.c
index aa3edabc2b0f..5a9bdabb1106 100644
--- a/drivers/spmi/spmi.c
+++ b/drivers/spmi/spmi.c
@@ -365,7 +365,7 @@ static int spmi_drv_remove(struct device *dev)
 	return 0;
 }
 
-static int spmi_drv_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int spmi_drv_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	int ret;
 
diff --git a/drivers/ssb/main.c b/drivers/ssb/main.c
index 116594413f66..2f4390025be2 100644
--- a/drivers/ssb/main.c
+++ b/drivers/ssb/main.c
@@ -337,9 +337,9 @@ static int ssb_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int ssb_device_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ssb_device_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	const struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
 
 	if (!dev)
 		return -ENODEV;
diff --git a/drivers/staging/greybus/core.c b/drivers/staging/greybus/core.c
index dafa430d176e..180ff3f8cc4c 100644
--- a/drivers/staging/greybus/core.c
+++ b/drivers/staging/greybus/core.c
@@ -78,14 +78,14 @@ static int greybus_match_device(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int greybus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int greybus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct gb_host_device *hd;
-	struct gb_module *module = NULL;
-	struct gb_interface *intf = NULL;
-	struct gb_control *control = NULL;
-	struct gb_bundle *bundle = NULL;
-	struct gb_svc *svc = NULL;
+	const struct gb_host_device *hd;
+	const struct gb_module *module = NULL;
+	const struct gb_interface *intf = NULL;
+	const struct gb_control *control = NULL;
+	const struct gb_bundle *bundle = NULL;
+	const struct gb_svc *svc = NULL;
 
 	if (is_gb_host_device(dev)) {
 		hd = to_gb_host_device(dev);
diff --git a/drivers/staging/greybus/gbphy.c b/drivers/staging/greybus/gbphy.c
index 6cb85c3d3572..f13ba0fcf943 100644
--- a/drivers/staging/greybus/gbphy.c
+++ b/drivers/staging/greybus/gbphy.c
@@ -71,14 +71,14 @@ static const struct device_type greybus_gbphy_dev_type = {
 	.pm	=	&gb_gbphy_pm_ops,
 };
 
-static int gbphy_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int gbphy_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct gbphy_device *gbphy_dev = to_gbphy_dev(dev);
-	struct greybus_descriptor_cport *cport_desc = gbphy_dev->cport_desc;
-	struct gb_bundle *bundle = gbphy_dev->bundle;
-	struct gb_interface *intf = bundle->intf;
-	struct gb_module *module = intf->module;
-	struct gb_host_device *hd = intf->hd;
+	const struct gbphy_device *gbphy_dev = to_gbphy_dev(dev);
+	const struct greybus_descriptor_cport *cport_desc = gbphy_dev->cport_desc;
+	const struct gb_bundle *bundle = gbphy_dev->bundle;
+	const struct gb_interface *intf = bundle->intf;
+	const struct gb_module *module = intf->module;
+	const struct gb_host_device *hd = intf->hd;
 
 	if (add_uevent_var(env, "BUS=%u", hd->bus_id))
 		return -ENOMEM;
* Unmerged path drivers/tee/tee_core.c
diff --git a/drivers/usb/common/ulpi.c b/drivers/usb/common/ulpi.c
index 29a29dca2919..e0a0bc0c9441 100644
--- a/drivers/usb/common/ulpi.c
+++ b/drivers/usb/common/ulpi.c
@@ -55,9 +55,9 @@ static int ulpi_match(struct device *dev, struct device_driver *driver)
 	return 0;
 }
 
-static int ulpi_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ulpi_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct ulpi *ulpi = to_ulpi_dev(dev);
+	const struct ulpi *ulpi = to_ulpi_dev(dev);
 	int ret;
 
 	ret = of_device_uevent_modalias(dev, env);
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index cb95ee30bcc9..e7fe6274fa1c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -898,14 +898,14 @@ static int usb_device_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int usb_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct usb_device *usb_dev;
+	const struct usb_device *usb_dev;
 
 	if (is_usb_device(dev)) {
 		usb_dev = to_usb_device(dev);
 	} else if (is_usb_interface(dev)) {
-		struct usb_interface *intf = to_usb_interface(dev);
+		const struct usb_interface *intf = to_usb_interface(dev);
 
 		usb_dev = interface_to_usbdev(intf);
 	} else {
diff --git a/drivers/usb/typec/bus.c b/drivers/usb/typec/bus.c
index 669aa815fbb8..b322b0da94c9 100644
--- a/drivers/usb/typec/bus.c
+++ b/drivers/usb/typec/bus.c
@@ -321,9 +321,9 @@ static int typec_match(struct device *dev, struct device_driver *driver)
 	return 0;
 }
 
-static int typec_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int typec_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct typec_altmode *altmode = to_typec_altmode(dev);
+	const struct typec_altmode *altmode = to_typec_altmode(dev);
 
 	if (add_uevent_var(env, "SVID=%04X", altmode->svid))
 		return -ENOMEM;
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index 5e3e5fa642d5..64e9f6d4731f 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -92,9 +92,9 @@ static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 	return 0;
 }
 
-static int virtio_uevent(struct device *_dv, struct kobj_uevent_env *env)
+static int virtio_uevent(const struct device *_dv, struct kobj_uevent_env *env)
 {
-	struct virtio_device *dev = dev_to_virtio(_dv);
+	const struct virtio_device *dev = dev_to_virtio(_dv);
 
 	return add_uevent_var(env, "MODALIAS=virtio:d%08Xv%08X",
 			      dev->id.device, dev->id.vendor);
diff --git a/drivers/w1/w1.c b/drivers/w1/w1.c
index caef0e0fd817..c5008371db60 100644
--- a/drivers/w1/w1.c
+++ b/drivers/w1/w1.c
@@ -176,7 +176,7 @@ static struct w1_family w1_default_family = {
 	.fops = &w1_default_fops,
 };
 
-static int w1_uevent(struct device *dev, struct kobj_uevent_env *env);
+static int w1_uevent(const struct device *dev, struct kobj_uevent_env *env);
 
 static struct bus_type w1_bus_type = {
 	.name = "w1",
@@ -583,11 +583,11 @@ void w1_destroy_master_attributes(struct w1_master *master)
 	sysfs_remove_group(&master->dev.kobj, &w1_master_defattr_group);
 }
 
-static int w1_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int w1_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct w1_master *md = NULL;
-	struct w1_slave *sl = NULL;
-	char *event_owner, *name;
+	const struct w1_master *md = NULL;
+	const struct w1_slave *sl = NULL;
+	const char *event_owner, *name;
 	int err = 0;
 
 	if (dev->driver == &w1_master_driver) {
diff --git a/drivers/xen/pvcalls-back.c b/drivers/xen/pvcalls-back.c
index 8c9ec619bad2..d09945e96373 100644
--- a/drivers/xen/pvcalls-back.c
+++ b/drivers/xen/pvcalls-back.c
@@ -1179,7 +1179,7 @@ static int pvcalls_back_remove(struct xenbus_device *dev)
 	return 0;
 }
 
-static int pvcalls_back_uevent(struct xenbus_device *xdev,
+static int pvcalls_back_uevent(const struct xenbus_device *xdev,
 			       struct kobj_uevent_env *env)
 {
 	return 0;
diff --git a/drivers/xen/xenbus/xenbus_probe_backend.c b/drivers/xen/xenbus/xenbus_probe_backend.c
index b0bed4faf44c..0b0b59ebfcb3 100644
--- a/drivers/xen/xenbus/xenbus_probe_backend.c
+++ b/drivers/xen/xenbus/xenbus_probe_backend.c
@@ -92,12 +92,12 @@ static int backend_bus_id(char bus_id[XEN_BUS_ID_SIZE], const char *nodename)
 	return 0;
 }
 
-static int xenbus_uevent_backend(struct device *dev,
+static int xenbus_uevent_backend(const struct device *dev,
 				 struct kobj_uevent_env *env)
 {
-	struct xenbus_device *xdev;
-	struct xenbus_driver *drv;
-	struct xen_bus_type *bus;
+	const struct xenbus_device *xdev;
+	const struct xenbus_driver *drv;
+	const struct xen_bus_type *bus;
 
 	DPRINTK("");
 
diff --git a/drivers/xen/xenbus/xenbus_probe_frontend.c b/drivers/xen/xenbus/xenbus_probe_frontend.c
index 07896f4b2736..fbef33c2b52c 100644
--- a/drivers/xen/xenbus/xenbus_probe_frontend.c
+++ b/drivers/xen/xenbus/xenbus_probe_frontend.c
@@ -73,10 +73,10 @@ static int xenbus_probe_frontend(struct xen_bus_type *bus, const char *type,
 	return err;
 }
 
-static int xenbus_uevent_frontend(struct device *_dev,
+static int xenbus_uevent_frontend(const struct device *_dev,
 				  struct kobj_uevent_env *env)
 {
-	struct xenbus_device *dev = to_xenbus_device(_dev);
+	const struct xenbus_device *dev = to_xenbus_device(_dev);
 
 	if (add_uevent_var(env, "MODALIAS=xen:%s", dev->devicetype))
 		return -ENOMEM;
diff --git a/drivers/zorro/zorro-driver.c b/drivers/zorro/zorro-driver.c
index fa23b7366b98..afc9c90c128d 100644
--- a/drivers/zorro/zorro-driver.c
+++ b/drivers/zorro/zorro-driver.c
@@ -142,9 +142,9 @@ static int zorro_bus_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
-static int zorro_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int zorro_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct zorro_dev *z;
+	const struct zorro_dev *z;
 
 	if (!dev)
 		return -ENODEV;
* Unmerged path include/linux/device/bus.h
* Unmerged path include/linux/spi/spi.h
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
index 3b43655cabe6..4cb04a3003f5 100644
--- a/include/linux/ssb/ssb.h
+++ b/include/linux/ssb/ssb.h
@@ -285,7 +285,7 @@ struct ssb_device {
 
 /* Go from struct device to struct ssb_device. */
 static inline
-struct ssb_device * dev_to_ssb_dev(struct device *dev)
+struct ssb_device * dev_to_ssb_dev(const struct device *dev)
 {
 	struct __ssb_dev_wrapper *wrap;
 	wrap = container_of(dev, struct __ssb_dev_wrapper, dev);
diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 536612c6ab0c..97f09acae302 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -123,7 +123,7 @@ void snd_hdac_device_exit(struct hdac_device *dev);
 int snd_hdac_device_register(struct hdac_device *codec);
 void snd_hdac_device_unregister(struct hdac_device *codec);
 int snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name);
-int snd_hdac_codec_modalias(struct hdac_device *hdac, char *buf, size_t size);
+int snd_hdac_codec_modalias(const struct hdac_device *hdac, char *buf, size_t size);
 
 int snd_hdac_refresh_widgets(struct hdac_device *codec);
 
diff --git a/include/xen/xenbus.h b/include/xen/xenbus.h
index 869c816d5f8c..e04bd0bdd84c 100644
--- a/include/xen/xenbus.h
+++ b/include/xen/xenbus.h
@@ -100,7 +100,7 @@ struct xenbus_driver {
 	int (*remove)(struct xenbus_device *dev);
 	int (*suspend)(struct xenbus_device *dev);
 	int (*resume)(struct xenbus_device *dev);
-	int (*uevent)(struct xenbus_device *, struct kobj_uevent_env *);
+	int (*uevent)(const struct xenbus_device *, struct kobj_uevent_env *);
 	struct device_driver driver;
 	int (*read_otherend_details)(struct xenbus_device *dev);
 	int (*is_ready)(struct xenbus_device *dev);
diff --git a/sound/aoa/soundbus/core.c b/sound/aoa/soundbus/core.c
index 002fb5bf220b..ba3e4569f106 100644
--- a/sound/aoa/soundbus/core.c
+++ b/sound/aoa/soundbus/core.c
@@ -55,10 +55,10 @@ static int soundbus_probe(struct device *dev)
 }
 
 
-static int soundbus_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int soundbus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct soundbus_dev * soundbus_dev;
-	struct platform_device * of;
+	const struct soundbus_dev * soundbus_dev;
+	const struct platform_device * of;
 	const char *compat;
 	int retval = 0;
 	int cplen, seen = 0;
diff --git a/sound/hda/hda_bus_type.c b/sound/hda/hda_bus_type.c
index eea6b63f8305..4cd94178df9f 100644
--- a/sound/hda/hda_bus_type.c
+++ b/sound/hda/hda_bus_type.c
@@ -65,7 +65,7 @@ static int hda_bus_match(struct device *dev, struct device_driver *drv)
 	return 1;
 }
 
-static int hda_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int hda_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	char modalias[32];
 
diff --git a/sound/hda/hdac_device.c b/sound/hda/hdac_device.c
index bfd858577676..6c043fbd606f 100644
--- a/sound/hda/hdac_device.c
+++ b/sound/hda/hdac_device.c
@@ -204,7 +204,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_device_set_chip_name);
  *
  * Returns the size of string, like snprintf(), or a negative error code.
  */
-int snd_hdac_codec_modalias(struct hdac_device *codec, char *buf, size_t size)
+int snd_hdac_codec_modalias(const struct hdac_device *codec, char *buf, size_t size)
 {
 	return scnprintf(buf, size, "hdaudio:v%08Xr%08Xa%02X\n",
 			codec->vendor_id, codec->revision_id, codec->type);
