r8152: support new chips

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Hayes Wang <hayeswang@realtek.com>
commit 195aae321c829dd1945900d75561e6aa79cce208
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/195aae32.failed

Support RTL8153C, RTL8153D, RTL8156A, and RTL8156B. The RTL8156A
and RTL8156B are the 2.5G ethernet.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 195aae321c829dd1945900d75561e6aa79cce208)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index e84ea7c904d3,72b8ef0ad5a1..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -3228,44 -3539,31 +3543,44 @@@ static void r8153b_ups_en(struct r8152 
  		ocp_data |= UPS_EN | USP_PREWAKE | PHASE2_EN;
  		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
  
- 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xcfff);
- 		ocp_data |= BIT(0);
- 		ocp_write_byte(tp, MCU_TYPE_USB, 0xcfff, ocp_data);
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
+ 		ocp_data |= UPS_FORCE_PWR_DOWN;
+ 		ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
  	} else {
 +		u16 data;
 +
  		ocp_data &= ~(UPS_EN | USP_PREWAKE);
  		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
  
- 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xcfff);
- 		ocp_data &= ~BIT(0);
- 		ocp_write_byte(tp, MCU_TYPE_USB, 0xcfff, ocp_data);
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
+ 		ocp_data &= ~UPS_FORCE_PWR_DOWN;
+ 		ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
  
 -		if (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {
 -			int i;
 +		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
 +		ocp_data &= ~PCUT_STATUS;
 +		ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
  
 -			for (i = 0; i < 500; i++) {
 -				if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
 -				    AUTOLOAD_DONE)
 -					break;
 -				msleep(20);
 -			}
 +		data = r8153_phy_status(tp, 0);
  
 -			tp->rtl_ops.hw_phy_cfg(tp);
 +		switch (data) {
 +		case PHY_STAT_PWRDN:
 +		case PHY_STAT_EXT_INIT:
 +			r8153b_green_en(tp,
 +					test_bit(GREEN_ETHERNET, &tp->flags));
  
 -			rtl8152_set_speed(tp, tp->autoneg, tp->speed,
 -					  tp->duplex, tp->advertising);
 +			data = r8152_mdio_read(tp, MII_BMCR);
 +			data &= ~BMCR_PDOWN;
 +			data |= BMCR_RESET;
 +			r8152_mdio_write(tp, MII_BMCR, data);
 +
 +			data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
 +			/* fall through */
 +
 +		default:
 +			if (data != PHY_STAT_LAN_ON)
 +				netif_warn(tp, link, tp->netdev,
 +					   "PHY not ready");
 +			break;
  		}
  	}
  }
@@@ -5384,15 -6267,1076 +6260,1079 @@@ static void r8152b_init(struct r8152 *t
  		   SPDWN_RXDV_MSK | SPDWN_LINKCHG_MSK;
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR, ocp_data);
  
- 	rtl_tally_reset(tp);
+ 	rtl_tally_reset(tp);
+ 
+ 	/* enable rx aggregation */
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+ }
+ 
+ static void r8153_init(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 	u16 data;
+ 	int i;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153_u1u2en(tp, false);
+ 
+ 	for (i = 0; i < 500; i++) {
+ 		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+ 		    AUTOLOAD_DONE)
+ 			break;
+ 
+ 		msleep(20);
+ 		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 			break;
+ 	}
+ 
+ 	data = r8153_phy_status(tp, 0);
+ 
+ 	if (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||
+ 	    tp->version == RTL_VER_05)
+ 		ocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN | EN_EMI_L);
+ 
+ 	data = r8152_mdio_read(tp, MII_BMCR);
+ 	if (data & BMCR_PDOWN) {
+ 		data &= ~BMCR_PDOWN;
+ 		r8152_mdio_write(tp, MII_BMCR, data);
+ 	}
+ 
+ 	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+ 
+ 	r8153_u2p3en(tp, false);
+ 
+ 	if (tp->version == RTL_VER_04) {
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2);
+ 		ocp_data &= ~pwd_dn_scale_mask;
+ 		ocp_data |= pwd_dn_scale(96);
+ 		ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, ocp_data);
+ 
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
+ 		ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
+ 		ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
+ 	} else if (tp->version == RTL_VER_05) {
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0);
+ 		ocp_data &= ~ECM_ALDPS;
+ 		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ocp_data);
+ 
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
+ 		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
+ 			ocp_data &= ~DYNAMIC_BURST;
+ 		else
+ 			ocp_data |= DYNAMIC_BURST;
+ 		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
+ 	} else if (tp->version == RTL_VER_06) {
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
+ 		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
+ 			ocp_data &= ~DYNAMIC_BURST;
+ 		else
+ 			ocp_data |= DYNAMIC_BURST;
+ 		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
+ 
+ 		r8153_queue_wake(tp, false);
+ 
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
+ 		if (rtl8152_get_speed(tp) & LINK_STATUS)
+ 			ocp_data |= CUR_LINK_OK;
+ 		else
+ 			ocp_data &= ~CUR_LINK_OK;
+ 		ocp_data |= POLL_LINK_CHG;
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
+ 	}
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2);
+ 	ocp_data |= EP4_FULL_FC;
+ 	ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL);
+ 	ocp_data &= ~TIMER11_EN;
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
+ 	ocp_data &= ~LED_MODE_MASK;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
+ 
+ 	ocp_data = FIFO_EMPTY_1FB | ROK_EXIT_LPM;
+ 	if (tp->version == RTL_VER_04 && tp->udev->speed < USB_SPEED_SUPER)
+ 		ocp_data |= LPM_TIMER_500MS;
+ 	else
+ 		ocp_data |= LPM_TIMER_500US;
+ 	ocp_write_byte(tp, MCU_TYPE_USB, USB_LPM_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2);
+ 	ocp_data &= ~SEN_VAL_MASK;
+ 	ocp_data |= SEN_VAL_NORMAL | SEL_RXIDLE;
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2, ocp_data);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);
+ 
+ 	r8153_power_cut_en(tp, false);
+ 	rtl_runtime_suspend_enable(tp, false);
+ 	r8153_mac_clk_speed_down(tp, false);
+ 	r8153_u1u2en(tp, true);
+ 	usb_enable_lpm(tp->udev);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);
+ 	ocp_data |= LANWAKE_CLR_EN;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG);
+ 	ocp_data &= ~LANWAKE_PIN;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG, ocp_data);
+ 
+ 	/* rx aggregation */
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	if (test_bit(DELL_TB_RX_AGG_BUG, &tp->flags))
+ 		ocp_data |= RX_AGG_DISABLE;
+ 
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+ 
+ 	rtl_tally_reset(tp);
+ 
+ 	switch (tp->udev->speed) {
+ 	case USB_SPEED_SUPER:
+ 	case USB_SPEED_SUPER_PLUS:
+ 		tp->coalesce = COALESCE_SUPER;
+ 		break;
+ 	case USB_SPEED_HIGH:
+ 		tp->coalesce = COALESCE_HIGH;
+ 		break;
+ 	default:
+ 		tp->coalesce = COALESCE_SLOW;
+ 		break;
+ 	}
+ }
+ 
+ static void r8153b_init(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 	u16 data;
+ 	int i;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153b_u1u2en(tp, false);
+ 
+ 	for (i = 0; i < 500; i++) {
+ 		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+ 		    AUTOLOAD_DONE)
+ 			break;
+ 
+ 		msleep(20);
+ 		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 			break;
+ 	}
+ 
+ 	data = r8153_phy_status(tp, 0);
+ 
+ 	data = r8152_mdio_read(tp, MII_BMCR);
+ 	if (data & BMCR_PDOWN) {
+ 		data &= ~BMCR_PDOWN;
+ 		r8152_mdio_write(tp, MII_BMCR, data);
+ 	}
+ 
+ 	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+ 
+ 	r8153_u2p3en(tp, false);
+ 
+ 	/* MSC timer = 0xfff * 8ms = 32760 ms */
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+ 
++	/* U1/U2/L1 idle timer. 500 us */
++	ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
++
+ 	r8153b_power_cut_en(tp, false);
+ 	r8153b_ups_en(tp, false);
+ 	r8153_queue_wake(tp, false);
+ 	rtl_runtime_suspend_enable(tp, false);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
+ 	if (rtl8152_get_speed(tp) & LINK_STATUS)
+ 		ocp_data |= CUR_LINK_OK;
+ 	else
+ 		ocp_data &= ~CUR_LINK_OK;
+ 	ocp_data |= POLL_LINK_CHG;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
+ 
+ 	if (tp->udev->speed >= USB_SPEED_SUPER)
+ 		r8153b_u1u2en(tp, true);
+ 
+ 	usb_enable_lpm(tp->udev);
+ 
+ 	/* MAC clock speed down */
+ 	r8153_mac_clk_speed_down(tp, true);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data &= ~PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	if (tp->version == RTL_VER_09) {
+ 		/* Disable Test IO for 32QFN */
+ 		if (ocp_read_byte(tp, MCU_TYPE_PLA, 0xdc00) & BIT(5)) {
+ 			ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+ 			ocp_data |= TEST_IO_OFF;
+ 			ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+ 		}
+ 	}
+ 
+ 	set_bit(GREEN_ETHERNET, &tp->flags);
+ 
+ 	/* rx aggregation */
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+ 
+ 	rtl_tally_reset(tp);
+ 
+ 	tp->coalesce = 15000;	/* 15 us */
+ }
+ 
+ static void r8153c_init(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 	u16 data;
+ 	int i;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153b_u1u2en(tp, false);
+ 
+ 	/* Disable spi_en */
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);
+ 	ocp_data &= ~BIT(3);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcbf0);
+ 	ocp_data |= BIT(1);
+ 	ocp_write_word(tp, MCU_TYPE_USB, 0xcbf0, ocp_data);
+ 
+ 	for (i = 0; i < 500; i++) {
+ 		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+ 		    AUTOLOAD_DONE)
+ 			break;
+ 
+ 		msleep(20);
+ 		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 			return;
+ 	}
+ 
+ 	data = r8153_phy_status(tp, 0);
+ 
+ 	data = r8152_mdio_read(tp, MII_BMCR);
+ 	if (data & BMCR_PDOWN) {
+ 		data &= ~BMCR_PDOWN;
+ 		r8152_mdio_write(tp, MII_BMCR, data);
+ 	}
+ 
+ 	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+ 
+ 	r8153_u2p3en(tp, false);
+ 
+ 	/* MSC timer = 0xfff * 8ms = 32760 ms */
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+ 
+ 	r8153b_power_cut_en(tp, false);
+ 	r8153c_ups_en(tp, false);
+ 	r8153_queue_wake(tp, false);
+ 	rtl_runtime_suspend_enable(tp, false);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
+ 	if (rtl8152_get_speed(tp) & LINK_STATUS)
+ 		ocp_data |= CUR_LINK_OK;
+ 	else
+ 		ocp_data &= ~CUR_LINK_OK;
+ 
+ 	ocp_data |= POLL_LINK_CHG;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
+ 
+ 	r8153b_u1u2en(tp, true);
+ 
+ 	usb_enable_lpm(tp->udev);
+ 
+ 	/* MAC clock speed down */
+ 	r8153_mac_clk_speed_down(tp, true);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
+ 	ocp_data &= ~BIT(7);
+ 	ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
+ 
+ 	set_bit(GREEN_ETHERNET, &tp->flags);
+ 
+ 	/* rx aggregation */
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+ 
+ 	rtl_tally_reset(tp);
+ 
+ 	tp->coalesce = 15000;	/* 15 us */
+ }
+ 
+ static void r8156_hw_phy_cfg(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 	u16 data;
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+ 	if (ocp_data & PCUT_STATUS) {
+ 		ocp_data &= ~PCUT_STATUS;
+ 		ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
+ 	}
+ 
+ 	data = r8153_phy_status(tp, 0);
+ 	switch (data) {
+ 	case PHY_STAT_EXT_INIT:
+ 		rtl8152_apply_firmware(tp, true);
+ 
+ 		data = ocp_reg_read(tp, 0xa468);
+ 		data &= ~(BIT(3) | BIT(1));
+ 		ocp_reg_write(tp, 0xa468, data);
+ 		break;
+ 	case PHY_STAT_LAN_ON:
+ 	case PHY_STAT_PWRDN:
+ 	default:
+ 		rtl8152_apply_firmware(tp, false);
+ 		break;
+ 	}
+ 
+ 	/* disable ALDPS before updating the PHY parameters */
+ 	r8153_aldps_en(tp, false);
+ 
+ 	/* disable EEE before updating the PHY parameters */
+ 	rtl_eee_enable(tp, false);
+ 
+ 	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+ 	WARN_ON_ONCE(data != PHY_STAT_LAN_ON);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+ 	ocp_data |= PFM_PWM_SWITCH;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+ 
+ 	switch (tp->version) {
+ 	case RTL_VER_10:
+ 		data = ocp_reg_read(tp, 0xad40);
+ 		data &= ~0x3ff;
+ 		data |= BIT(7) | BIT(2);
+ 		ocp_reg_write(tp, 0xad40, data);
+ 
+ 		data = ocp_reg_read(tp, 0xad4e);
+ 		data |= BIT(4);
+ 		ocp_reg_write(tp, 0xad4e, data);
+ 		data = ocp_reg_read(tp, 0xad16);
+ 		data &= ~0x3ff;
+ 		data |= 0x6;
+ 		ocp_reg_write(tp, 0xad16, data);
+ 		data = ocp_reg_read(tp, 0xad32);
+ 		data &= ~0x3f;
+ 		data |= 6;
+ 		ocp_reg_write(tp, 0xad32, data);
+ 		data = ocp_reg_read(tp, 0xac08);
+ 		data &= ~(BIT(12) | BIT(8));
+ 		ocp_reg_write(tp, 0xac08, data);
+ 		data = ocp_reg_read(tp, 0xac8a);
+ 		data |= BIT(12) | BIT(13) | BIT(14);
+ 		data &= ~BIT(15);
+ 		ocp_reg_write(tp, 0xac8a, data);
+ 		data = ocp_reg_read(tp, 0xad18);
+ 		data |= BIT(10);
+ 		ocp_reg_write(tp, 0xad18, data);
+ 		data = ocp_reg_read(tp, 0xad1a);
+ 		data |= 0x3ff;
+ 		ocp_reg_write(tp, 0xad1a, data);
+ 		data = ocp_reg_read(tp, 0xad1c);
+ 		data |= 0x3ff;
+ 		ocp_reg_write(tp, 0xad1c, data);
+ 
+ 		data = sram_read(tp, 0x80ea);
+ 		data &= ~0xff00;
+ 		data |= 0xc400;
+ 		sram_write(tp, 0x80ea, data);
+ 		data = sram_read(tp, 0x80eb);
+ 		data &= ~0x0700;
+ 		data |= 0x0300;
+ 		sram_write(tp, 0x80eb, data);
+ 		data = sram_read(tp, 0x80f8);
+ 		data &= ~0xff00;
+ 		data |= 0x1c00;
+ 		sram_write(tp, 0x80f8, data);
+ 		data = sram_read(tp, 0x80f1);
+ 		data &= ~0xff00;
+ 		data |= 0x3000;
+ 		sram_write(tp, 0x80f1, data);
+ 
+ 		data = sram_read(tp, 0x80fe);
+ 		data &= ~0xff00;
+ 		data |= 0xa500;
+ 		sram_write(tp, 0x80fe, data);
+ 		data = sram_read(tp, 0x8102);
+ 		data &= ~0xff00;
+ 		data |= 0x5000;
+ 		sram_write(tp, 0x8102, data);
+ 		data = sram_read(tp, 0x8015);
+ 		data &= ~0xff00;
+ 		data |= 0x3300;
+ 		sram_write(tp, 0x8015, data);
+ 		data = sram_read(tp, 0x8100);
+ 		data &= ~0xff00;
+ 		data |= 0x7000;
+ 		sram_write(tp, 0x8100, data);
+ 		data = sram_read(tp, 0x8014);
+ 		data &= ~0xff00;
+ 		data |= 0xf000;
+ 		sram_write(tp, 0x8014, data);
+ 		data = sram_read(tp, 0x8016);
+ 		data &= ~0xff00;
+ 		data |= 0x6500;
+ 		sram_write(tp, 0x8016, data);
+ 		data = sram_read(tp, 0x80dc);
+ 		data &= ~0xff00;
+ 		data |= 0xed00;
+ 		sram_write(tp, 0x80dc, data);
+ 		data = sram_read(tp, 0x80df);
+ 		data |= BIT(8);
+ 		sram_write(tp, 0x80df, data);
+ 		data = sram_read(tp, 0x80e1);
+ 		data &= ~BIT(8);
+ 		sram_write(tp, 0x80e1, data);
+ 
+ 		data = ocp_reg_read(tp, 0xbf06);
+ 		data &= ~0x003f;
+ 		data |= 0x0038;
+ 		ocp_reg_write(tp, 0xbf06, data);
+ 
+ 		sram_write(tp, 0x819f, 0xddb6);
+ 
+ 		ocp_reg_write(tp, 0xbc34, 0x5555);
+ 		data = ocp_reg_read(tp, 0xbf0a);
+ 		data &= ~0x0e00;
+ 		data |= 0x0a00;
+ 		ocp_reg_write(tp, 0xbf0a, data);
+ 
+ 		data = ocp_reg_read(tp, 0xbd2c);
+ 		data &= ~BIT(13);
+ 		ocp_reg_write(tp, 0xbd2c, data);
+ 		break;
+ 	case RTL_VER_11:
+ 		data = ocp_reg_read(tp, 0xad16);
+ 		data |= 0x3ff;
+ 		ocp_reg_write(tp, 0xad16, data);
+ 		data = ocp_reg_read(tp, 0xad32);
+ 		data &= ~0x3f;
+ 		data |= 6;
+ 		ocp_reg_write(tp, 0xad32, data);
+ 		data = ocp_reg_read(tp, 0xac08);
+ 		data &= ~(BIT(12) | BIT(8));
+ 		ocp_reg_write(tp, 0xac08, data);
+ 		data = ocp_reg_read(tp, 0xacc0);
+ 		data &= ~0x3;
+ 		data |= BIT(1);
+ 		ocp_reg_write(tp, 0xacc0, data);
+ 		data = ocp_reg_read(tp, 0xad40);
+ 		data &= ~0xe7;
+ 		data |= BIT(6) | BIT(2);
+ 		ocp_reg_write(tp, 0xad40, data);
+ 		data = ocp_reg_read(tp, 0xac14);
+ 		data &= ~BIT(7);
+ 		ocp_reg_write(tp, 0xac14, data);
+ 		data = ocp_reg_read(tp, 0xac80);
+ 		data &= ~(BIT(8) | BIT(9));
+ 		ocp_reg_write(tp, 0xac80, data);
+ 		data = ocp_reg_read(tp, 0xac5e);
+ 		data &= ~0x7;
+ 		data |= BIT(1);
+ 		ocp_reg_write(tp, 0xac5e, data);
+ 		ocp_reg_write(tp, 0xad4c, 0x00a8);
+ 		ocp_reg_write(tp, 0xac5c, 0x01ff);
+ 		data = ocp_reg_read(tp, 0xac8a);
+ 		data &= ~0xf0;
+ 		data |= BIT(4) | BIT(5);
+ 		ocp_reg_write(tp, 0xac8a, data);
+ 		ocp_reg_write(tp, 0xb87c, 0x8157);
+ 		data = ocp_reg_read(tp, 0xb87e);
+ 		data &= ~0xff00;
+ 		data |= 0x0500;
+ 		ocp_reg_write(tp, 0xb87e, data);
+ 		ocp_reg_write(tp, 0xb87c, 0x8159);
+ 		data = ocp_reg_read(tp, 0xb87e);
+ 		data &= ~0xff00;
+ 		data |= 0x0700;
+ 		ocp_reg_write(tp, 0xb87e, data);
+ 
+ 		/* AAGC */
+ 		ocp_reg_write(tp, 0xb87c, 0x80a2);
+ 		ocp_reg_write(tp, 0xb87e, 0x0153);
+ 		ocp_reg_write(tp, 0xb87c, 0x809c);
+ 		ocp_reg_write(tp, 0xb87e, 0x0153);
+ 
+ 		/* EEE parameter */
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS_2P5G, 0x0056);
+ 
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_USB_CFG);
+ 		ocp_data |= EN_XG_LIP | EN_G_LIP;
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_USB_CFG, ocp_data);
+ 
+ 		sram_write(tp, 0x8257, 0x020f); /*  XG PLL */
+ 		sram_write(tp, 0x80ea, 0x7843); /* GIGA Master */
+ 
+ 		if (rtl_phy_patch_request(tp, true, true))
+ 			return;
+ 
+ 		/* Advance EEE */
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);
+ 		ocp_data |= EEE_SPDWN_EN;
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);
+ 
+ 		data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+ 		data &= ~(EN_EEE_100 | EN_EEE_1000);
+ 		data |= EN_10M_CLKDIV;
+ 		ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+ 		tp->ups_info._10m_ckdiv = true;
+ 		tp->ups_info.eee_plloff_100 = false;
+ 		tp->ups_info.eee_plloff_giga = false;
+ 
+ 		data = ocp_reg_read(tp, OCP_POWER_CFG);
+ 		data &= ~EEE_CLKDIV_EN;
+ 		ocp_reg_write(tp, OCP_POWER_CFG, data);
+ 		tp->ups_info.eee_ckdiv = false;
+ 
+ 		ocp_reg_write(tp, OCP_SYSCLK_CFG, 0);
+ 		ocp_reg_write(tp, OCP_SYSCLK_CFG, sysclk_div_expo(5));
+ 		tp->ups_info._250m_ckdiv = false;
+ 
+ 		rtl_phy_patch_request(tp, false, true);
+ 
+ 		/* enable ADC Ibias Cal */
+ 		data = ocp_reg_read(tp, 0xd068);
+ 		data |= BIT(13);
+ 		ocp_reg_write(tp, 0xd068, data);
+ 
+ 		/* enable Thermal Sensor */
+ 		data = sram_read(tp, 0x81a2);
+ 		data &= ~BIT(8);
+ 		sram_write(tp, 0x81a2, data);
+ 		data = ocp_reg_read(tp, 0xb54c);
+ 		data &= ~0xff00;
+ 		data |= 0xdb00;
+ 		ocp_reg_write(tp, 0xb54c, data);
+ 
+ 		/* Nway 2.5G Lite */
+ 		data = ocp_reg_read(tp, 0xa454);
+ 		data &= ~BIT(0);
+ 		ocp_reg_write(tp, 0xa454, data);
+ 
+ 		/* CS DSP solution */
+ 		data = ocp_reg_read(tp, OCP_10GBT_CTRL);
+ 		data |= RTL_ADV2_5G_F_R;
+ 		ocp_reg_write(tp, OCP_10GBT_CTRL, data);
+ 		data = ocp_reg_read(tp, 0xad4e);
+ 		data &= ~BIT(4);
+ 		ocp_reg_write(tp, 0xad4e, data);
+ 		data = ocp_reg_read(tp, 0xa86a);
+ 		data &= ~BIT(0);
+ 		ocp_reg_write(tp, 0xa86a, data);
+ 
+ 		/* MDI SWAP */
+ 		if ((ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CFG) & MID_REVERSE) &&
+ 		    (ocp_reg_read(tp, 0xd068) & BIT(1))) {
+ 			u16 swap_a, swap_b;
+ 
+ 			data = ocp_reg_read(tp, 0xd068);
+ 			data &= ~0x1f;
+ 			data |= 0x1; /* p0 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			swap_a = ocp_reg_read(tp, 0xd06a);
+ 			data &= ~0x18;
+ 			data |= 0x18; /* p3 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			swap_b = ocp_reg_read(tp, 0xd06a);
+ 			data &= ~0x18; /* p0 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			ocp_reg_write(tp, 0xd06a,
+ 				      (swap_a & ~0x7ff) | (swap_b & 0x7ff));
+ 			data |= 0x18; /* p3 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			ocp_reg_write(tp, 0xd06a,
+ 				      (swap_b & ~0x7ff) | (swap_a & 0x7ff));
+ 			data &= ~0x18;
+ 			data |= 0x08; /* p1 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			swap_a = ocp_reg_read(tp, 0xd06a);
+ 			data &= ~0x18;
+ 			data |= 0x10; /* p2 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			swap_b = ocp_reg_read(tp, 0xd06a);
+ 			data &= ~0x18;
+ 			data |= 0x08; /* p1 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			ocp_reg_write(tp, 0xd06a,
+ 				      (swap_a & ~0x7ff) | (swap_b & 0x7ff));
+ 			data &= ~0x18;
+ 			data |= 0x10; /* p2 */
+ 			ocp_reg_write(tp, 0xd068, data);
+ 			ocp_reg_write(tp, 0xd06a,
+ 				      (swap_b & ~0x7ff) | (swap_a & 0x7ff));
+ 			swap_a = ocp_reg_read(tp, 0xbd5a);
+ 			swap_b = ocp_reg_read(tp, 0xbd5c);
+ 			ocp_reg_write(tp, 0xbd5a, (swap_a & ~0x1f1f) |
+ 				      ((swap_b & 0x1f) << 8) |
+ 				      ((swap_b >> 8) & 0x1f));
+ 			ocp_reg_write(tp, 0xbd5c, (swap_b & ~0x1f1f) |
+ 				      ((swap_a & 0x1f) << 8) |
+ 				      ((swap_a >> 8) & 0x1f));
+ 			swap_a = ocp_reg_read(tp, 0xbc18);
+ 			swap_b = ocp_reg_read(tp, 0xbc1a);
+ 			ocp_reg_write(tp, 0xbc18, (swap_a & ~0x1f1f) |
+ 				      ((swap_b & 0x1f) << 8) |
+ 				      ((swap_b >> 8) & 0x1f));
+ 			ocp_reg_write(tp, 0xbc1a, (swap_b & ~0x1f1f) |
+ 				      ((swap_a & 0x1f) << 8) |
+ 				      ((swap_a >> 8) & 0x1f));
+ 		}
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	rtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+ 
+ 	data = ocp_reg_read(tp, 0xa428);
+ 	data &= ~BIT(9);
+ 	ocp_reg_write(tp, 0xa428, data);
+ 	data = ocp_reg_read(tp, 0xa5ea);
+ 	data &= ~BIT(0);
+ 	ocp_reg_write(tp, 0xa5ea, data);
+ 	tp->ups_info.lite_mode = 0;
+ 
+ 	if (tp->eee_en)
+ 		rtl_eee_enable(tp, true);
+ 
+ 	r8153_aldps_en(tp, true);
+ 	r8152b_enable_fc(tp);
+ 	r8153_u2p3en(tp, true);
+ 
+ 	set_bit(PHY_RESET, &tp->flags);
+ }
+ 
+ static void r8156b_hw_phy_cfg(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 	u16 data;
+ 
+ 	switch (tp->version) {
+ 	case RTL_VER_12:
+ 		ocp_reg_write(tp, 0xbf86, 0x9000);
+ 		data = ocp_reg_read(tp, 0xc402);
+ 		data |= BIT(10);
+ 		ocp_reg_write(tp, 0xc402, data);
+ 		data &= ~BIT(10);
+ 		ocp_reg_write(tp, 0xc402, data);
+ 		ocp_reg_write(tp, 0xbd86, 0x1010);
+ 		ocp_reg_write(tp, 0xbd88, 0x1010);
+ 		data = ocp_reg_read(tp, 0xbd4e);
+ 		data &= ~(BIT(10) | BIT(11));
+ 		data |= BIT(11);
+ 		ocp_reg_write(tp, 0xbd4e, data);
+ 		data = ocp_reg_read(tp, 0xbf46);
+ 		data &= ~0xf00;
+ 		data |= 0x700;
+ 		ocp_reg_write(tp, 0xbf46, data);
+ 		break;
+ 	case RTL_VER_13:
+ 	case RTL_VER_15:
+ 		r8156b_wait_loading_flash(tp);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+ 	if (ocp_data & PCUT_STATUS) {
+ 		ocp_data &= ~PCUT_STATUS;
+ 		ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
+ 	}
+ 
+ 	data = r8153_phy_status(tp, 0);
+ 	switch (data) {
+ 	case PHY_STAT_EXT_INIT:
+ 		rtl8152_apply_firmware(tp, true);
+ 
+ 		data = ocp_reg_read(tp, 0xa466);
+ 		data &= ~BIT(0);
+ 		ocp_reg_write(tp, 0xa466, data);
+ 
+ 		data = ocp_reg_read(tp, 0xa468);
+ 		data &= ~(BIT(3) | BIT(1));
+ 		ocp_reg_write(tp, 0xa468, data);
+ 		break;
+ 	case PHY_STAT_LAN_ON:
+ 	case PHY_STAT_PWRDN:
+ 	default:
+ 		rtl8152_apply_firmware(tp, false);
+ 		break;
+ 	}
+ 
+ 	data = r8152_mdio_read(tp, MII_BMCR);
+ 	if (data & BMCR_PDOWN) {
+ 		data &= ~BMCR_PDOWN;
+ 		r8152_mdio_write(tp, MII_BMCR, data);
+ 	}
+ 
+ 	/* disable ALDPS before updating the PHY parameters */
+ 	r8153_aldps_en(tp, false);
+ 
+ 	/* disable EEE before updating the PHY parameters */
+ 	rtl_eee_enable(tp, false);
+ 
+ 	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+ 	WARN_ON_ONCE(data != PHY_STAT_LAN_ON);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+ 	ocp_data |= PFM_PWM_SWITCH;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+ 
+ 	switch (tp->version) {
+ 	case RTL_VER_12:
+ 		data = ocp_reg_read(tp, 0xbc08);
+ 		data |= BIT(3) | BIT(2);
+ 		ocp_reg_write(tp, 0xbc08, data);
+ 
+ 		data = sram_read(tp, 0x8fff);
+ 		data &= ~0xff00;
+ 		data |= 0x0400;
+ 		sram_write(tp, 0x8fff, data);
+ 
+ 		data = ocp_reg_read(tp, 0xacda);
+ 		data |= 0xff00;
+ 		ocp_reg_write(tp, 0xacda, data);
+ 		data = ocp_reg_read(tp, 0xacde);
+ 		data |= 0xf000;
+ 		ocp_reg_write(tp, 0xacde, data);
+ 		ocp_reg_write(tp, 0xac8c, 0x0ffc);
+ 		ocp_reg_write(tp, 0xac46, 0xb7b4);
+ 		ocp_reg_write(tp, 0xac50, 0x0fbc);
+ 		ocp_reg_write(tp, 0xac3c, 0x9240);
+ 		ocp_reg_write(tp, 0xac4e, 0x0db4);
+ 		ocp_reg_write(tp, 0xacc6, 0x0707);
+ 		ocp_reg_write(tp, 0xacc8, 0xa0d3);
+ 		ocp_reg_write(tp, 0xad08, 0x0007);
+ 
+ 		ocp_reg_write(tp, 0xb87c, 0x8560);
+ 		ocp_reg_write(tp, 0xb87e, 0x19cc);
+ 		ocp_reg_write(tp, 0xb87c, 0x8562);
+ 		ocp_reg_write(tp, 0xb87e, 0x19cc);
+ 		ocp_reg_write(tp, 0xb87c, 0x8564);
+ 		ocp_reg_write(tp, 0xb87e, 0x19cc);
+ 		ocp_reg_write(tp, 0xb87c, 0x8566);
+ 		ocp_reg_write(tp, 0xb87e, 0x147d);
+ 		ocp_reg_write(tp, 0xb87c, 0x8568);
+ 		ocp_reg_write(tp, 0xb87e, 0x147d);
+ 		ocp_reg_write(tp, 0xb87c, 0x856a);
+ 		ocp_reg_write(tp, 0xb87e, 0x147d);
+ 		ocp_reg_write(tp, 0xb87c, 0x8ffe);
+ 		ocp_reg_write(tp, 0xb87e, 0x0907);
+ 		ocp_reg_write(tp, 0xb87c, 0x80d6);
+ 		ocp_reg_write(tp, 0xb87e, 0x2801);
+ 		ocp_reg_write(tp, 0xb87c, 0x80f2);
+ 		ocp_reg_write(tp, 0xb87e, 0x2801);
+ 		ocp_reg_write(tp, 0xb87c, 0x80f4);
+ 		ocp_reg_write(tp, 0xb87e, 0x6077);
+ 		ocp_reg_write(tp, 0xb506, 0x01e7);
+ 
+ 		ocp_reg_write(tp, 0xb87c, 0x8013);
+ 		ocp_reg_write(tp, 0xb87e, 0x0700);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fb9);
+ 		ocp_reg_write(tp, 0xb87e, 0x2801);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fba);
+ 		ocp_reg_write(tp, 0xb87e, 0x0100);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fbc);
+ 		ocp_reg_write(tp, 0xb87e, 0x1900);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fbe);
+ 		ocp_reg_write(tp, 0xb87e, 0xe100);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fc0);
+ 		ocp_reg_write(tp, 0xb87e, 0x0800);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fc2);
+ 		ocp_reg_write(tp, 0xb87e, 0xe500);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fc4);
+ 		ocp_reg_write(tp, 0xb87e, 0x0f00);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fc6);
+ 		ocp_reg_write(tp, 0xb87e, 0xf100);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fc8);
+ 		ocp_reg_write(tp, 0xb87e, 0x0400);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fca);
+ 		ocp_reg_write(tp, 0xb87e, 0xf300);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fcc);
+ 		ocp_reg_write(tp, 0xb87e, 0xfd00);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fce);
+ 		ocp_reg_write(tp, 0xb87e, 0xff00);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fd0);
+ 		ocp_reg_write(tp, 0xb87e, 0xfb00);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fd2);
+ 		ocp_reg_write(tp, 0xb87e, 0x0100);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fd4);
+ 		ocp_reg_write(tp, 0xb87e, 0xf400);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fd6);
+ 		ocp_reg_write(tp, 0xb87e, 0xff00);
+ 		ocp_reg_write(tp, 0xb87c, 0x8fd8);
+ 		ocp_reg_write(tp, 0xb87e, 0xf600);
+ 
+ 		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_USB_CFG);
+ 		ocp_data |= EN_XG_LIP | EN_G_LIP;
+ 		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_USB_CFG, ocp_data);
+ 		ocp_reg_write(tp, 0xb87c, 0x813d);
+ 		ocp_reg_write(tp, 0xb87e, 0x390e);
+ 		ocp_reg_write(tp, 0xb87c, 0x814f);
+ 		ocp_reg_write(tp, 0xb87e, 0x790e);
+ 		ocp_reg_write(tp, 0xb87c, 0x80b0);
+ 		ocp_reg_write(tp, 0xb87e, 0x0f31);
+ 		data = ocp_reg_read(tp, 0xbf4c);
+ 		data |= BIT(1);
+ 		ocp_reg_write(tp, 0xbf4c, data);
+ 		data = ocp_reg_read(tp, 0xbcca);
+ 		data |= BIT(9) | BIT(8);
+ 		ocp_reg_write(tp, 0xbcca, data);
+ 		ocp_reg_write(tp, 0xb87c, 0x8141);
+ 		ocp_reg_write(tp, 0xb87e, 0x320e);
+ 		ocp_reg_write(tp, 0xb87c, 0x8153);
+ 		ocp_reg_write(tp, 0xb87e, 0x720e);
+ 		ocp_reg_write(tp, 0xb87c, 0x8529);
+ 		ocp_reg_write(tp, 0xb87e, 0x050e);
+ 		data = ocp_reg_read(tp, OCP_EEE_CFG);
+ 		data &= ~CTAP_SHORT_EN;
+ 		ocp_reg_write(tp, OCP_EEE_CFG, data);
+ 
+ 		sram_write(tp, 0x816c, 0xc4a0);
+ 		sram_write(tp, 0x8170, 0xc4a0);
+ 		sram_write(tp, 0x8174, 0x04a0);
+ 		sram_write(tp, 0x8178, 0x04a0);
+ 		sram_write(tp, 0x817c, 0x0719);
+ 		sram_write(tp, 0x8ff4, 0x0400);
+ 		sram_write(tp, 0x8ff1, 0x0404);
+ 
+ 		ocp_reg_write(tp, 0xbf4a, 0x001b);
+ 		ocp_reg_write(tp, 0xb87c, 0x8033);
+ 		ocp_reg_write(tp, 0xb87e, 0x7c13);
+ 		ocp_reg_write(tp, 0xb87c, 0x8037);
+ 		ocp_reg_write(tp, 0xb87e, 0x7c13);
+ 		ocp_reg_write(tp, 0xb87c, 0x803b);
+ 		ocp_reg_write(tp, 0xb87e, 0xfc32);
+ 		ocp_reg_write(tp, 0xb87c, 0x803f);
+ 		ocp_reg_write(tp, 0xb87e, 0x7c13);
+ 		ocp_reg_write(tp, 0xb87c, 0x8043);
+ 		ocp_reg_write(tp, 0xb87e, 0x7c13);
+ 		ocp_reg_write(tp, 0xb87c, 0x8047);
+ 		ocp_reg_write(tp, 0xb87e, 0x7c13);
+ 
+ 		ocp_reg_write(tp, 0xb87c, 0x8145);
+ 		ocp_reg_write(tp, 0xb87e, 0x370e);
+ 		ocp_reg_write(tp, 0xb87c, 0x8157);
+ 		ocp_reg_write(tp, 0xb87e, 0x770e);
+ 		ocp_reg_write(tp, 0xb87c, 0x8169);
+ 		ocp_reg_write(tp, 0xb87e, 0x0d0a);
+ 		ocp_reg_write(tp, 0xb87c, 0x817b);
+ 		ocp_reg_write(tp, 0xb87e, 0x1d0a);
+ 
+ 		data = sram_read(tp, 0x8217);
+ 		data &= ~0xff00;
+ 		data |= 0x5000;
+ 		sram_write(tp, 0x8217, data);
+ 		data = sram_read(tp, 0x821a);
+ 		data &= ~0xff00;
+ 		data |= 0x5000;
+ 		sram_write(tp, 0x821a, data);
+ 		sram_write(tp, 0x80da, 0x0403);
+ 		data = sram_read(tp, 0x80dc);
+ 		data &= ~0xff00;
+ 		data |= 0x1000;
+ 		sram_write(tp, 0x80dc, data);
+ 		sram_write(tp, 0x80b3, 0x0384);
+ 		sram_write(tp, 0x80b7, 0x2007);
+ 		data = sram_read(tp, 0x80ba);
+ 		data &= ~0xff00;
+ 		data |= 0x6c00;
+ 		sram_write(tp, 0x80ba, data);
+ 		sram_write(tp, 0x80b5, 0xf009);
+ 		data = sram_read(tp, 0x80bd);
+ 		data &= ~0xff00;
+ 		data |= 0x9f00;
+ 		sram_write(tp, 0x80bd, data);
+ 		sram_write(tp, 0x80c7, 0xf083);
+ 		sram_write(tp, 0x80dd, 0x03f0);
+ 		data = sram_read(tp, 0x80df);
+ 		data &= ~0xff00;
+ 		data |= 0x1000;
+ 		sram_write(tp, 0x80df, data);
+ 		sram_write(tp, 0x80cb, 0x2007);
+ 		data = sram_read(tp, 0x80ce);
+ 		data &= ~0xff00;
+ 		data |= 0x6c00;
+ 		sram_write(tp, 0x80ce, data);
+ 		sram_write(tp, 0x80c9, 0x8009);
+ 		data = sram_read(tp, 0x80d1);
+ 		data &= ~0xff00;
+ 		data |= 0x8000;
+ 		sram_write(tp, 0x80d1, data);
+ 		sram_write(tp, 0x80a3, 0x200a);
+ 		sram_write(tp, 0x80a5, 0xf0ad);
+ 		sram_write(tp, 0x809f, 0x6073);
+ 		sram_write(tp, 0x80a1, 0x000b);
+ 		data = sram_read(tp, 0x80a9);
+ 		data &= ~0xff00;
+ 		data |= 0xc000;
+ 		sram_write(tp, 0x80a9, data);
+ 
+ 		if (rtl_phy_patch_request(tp, true, true))
+ 			return;
+ 
+ 		data = ocp_reg_read(tp, 0xb896);
+ 		data &= ~BIT(0);
+ 		ocp_reg_write(tp, 0xb896, data);
+ 		data = ocp_reg_read(tp, 0xb892);
+ 		data &= ~0xff00;
+ 		ocp_reg_write(tp, 0xb892, data);
+ 		ocp_reg_write(tp, 0xb88e, 0xc23e);
+ 		ocp_reg_write(tp, 0xb890, 0x0000);
+ 		ocp_reg_write(tp, 0xb88e, 0xc240);
+ 		ocp_reg_write(tp, 0xb890, 0x0103);
+ 		ocp_reg_write(tp, 0xb88e, 0xc242);
+ 		ocp_reg_write(tp, 0xb890, 0x0507);
+ 		ocp_reg_write(tp, 0xb88e, 0xc244);
+ 		ocp_reg_write(tp, 0xb890, 0x090b);
+ 		ocp_reg_write(tp, 0xb88e, 0xc246);
+ 		ocp_reg_write(tp, 0xb890, 0x0c0e);
+ 		ocp_reg_write(tp, 0xb88e, 0xc248);
+ 		ocp_reg_write(tp, 0xb890, 0x1012);
+ 		ocp_reg_write(tp, 0xb88e, 0xc24a);
+ 		ocp_reg_write(tp, 0xb890, 0x1416);
+ 		data = ocp_reg_read(tp, 0xb896);
+ 		data |= BIT(0);
+ 		ocp_reg_write(tp, 0xb896, data);
+ 
+ 		rtl_phy_patch_request(tp, false, true);
+ 
+ 		data = ocp_reg_read(tp, 0xa86a);
+ 		data |= BIT(0);
+ 		ocp_reg_write(tp, 0xa86a, data);
+ 		data = ocp_reg_read(tp, 0xa6f0);
+ 		data |= BIT(0);
+ 		ocp_reg_write(tp, 0xa6f0, data);
+ 
+ 		ocp_reg_write(tp, 0xbfa0, 0xd70d);
+ 		ocp_reg_write(tp, 0xbfa2, 0x4100);
+ 		ocp_reg_write(tp, 0xbfa4, 0xe868);
+ 		ocp_reg_write(tp, 0xbfa6, 0xdc59);
+ 		ocp_reg_write(tp, 0xb54c, 0x3c18);
+ 		data = ocp_reg_read(tp, 0xbfa4);
+ 		data &= ~BIT(5);
+ 		ocp_reg_write(tp, 0xbfa4, data);
+ 		data = sram_read(tp, 0x817d);
+ 		data |= BIT(12);
+ 		sram_write(tp, 0x817d, data);
+ 		break;
+ 	case RTL_VER_13:
+ 		/* 2.5G INRX */
+ 		data = ocp_reg_read(tp, 0xac46);
+ 		data &= ~0x00f0;
+ 		data |= 0x0090;
+ 		ocp_reg_write(tp, 0xac46, data);
+ 		data = ocp_reg_read(tp, 0xad30);
+ 		data &= ~0x0003;
+ 		data |= 0x0001;
+ 		ocp_reg_write(tp, 0xad30, data);
+ 		fallthrough;
+ 	case RTL_VER_15:
+ 		/* EEE parameter */
+ 		ocp_reg_write(tp, 0xb87c, 0x80f5);
+ 		ocp_reg_write(tp, 0xb87e, 0x760e);
+ 		ocp_reg_write(tp, 0xb87c, 0x8107);
+ 		ocp_reg_write(tp, 0xb87e, 0x360e);
+ 		ocp_reg_write(tp, 0xb87c, 0x8551);
+ 		data = ocp_reg_read(tp, 0xb87e);
+ 		data &= ~0xff00;
+ 		data |= 0x0800;
+ 		ocp_reg_write(tp, 0xb87e, data);
+ 
+ 		/* ADC_PGA parameter */
+ 		data = ocp_reg_read(tp, 0xbf00);
+ 		data &= ~0xe000;
+ 		data |= 0xa000;
+ 		ocp_reg_write(tp, 0xbf00, data);
+ 		data = ocp_reg_read(tp, 0xbf46);
+ 		data &= ~0x0f00;
+ 		data |= 0x0300;
+ 		ocp_reg_write(tp, 0xbf46, data);
+ 
+ 		/* Green Table-PGA, 1G full viterbi */
+ 		sram_write(tp, 0x8044, 0x2417);
+ 		sram_write(tp, 0x804a, 0x2417);
+ 		sram_write(tp, 0x8050, 0x2417);
+ 		sram_write(tp, 0x8056, 0x2417);
+ 		sram_write(tp, 0x805c, 0x2417);
+ 		sram_write(tp, 0x8062, 0x2417);
+ 		sram_write(tp, 0x8068, 0x2417);
+ 		sram_write(tp, 0x806e, 0x2417);
+ 		sram_write(tp, 0x8074, 0x2417);
+ 		sram_write(tp, 0x807a, 0x2417);
+ 
+ 		/* XG PLL */
+ 		data = ocp_reg_read(tp, 0xbf84);
+ 		data &= ~0xe000;
+ 		data |= 0xa000;
+ 		ocp_reg_write(tp, 0xbf84, data);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	if (rtl_phy_patch_request(tp, true, true))
+ 		return;
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);
+ 	ocp_data |= EEE_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);
+ 
+ 	data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+ 	data &= ~(EN_EEE_100 | EN_EEE_1000);
+ 	data |= EN_10M_CLKDIV;
+ 	ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+ 	tp->ups_info._10m_ckdiv = true;
+ 	tp->ups_info.eee_plloff_100 = false;
+ 	tp->ups_info.eee_plloff_giga = false;
+ 
+ 	data = ocp_reg_read(tp, OCP_POWER_CFG);
+ 	data &= ~EEE_CLKDIV_EN;
+ 	ocp_reg_write(tp, OCP_POWER_CFG, data);
+ 	tp->ups_info.eee_ckdiv = false;
+ 
+ 	rtl_phy_patch_request(tp, false, true);
+ 
+ 	rtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+ 
+ 	data = ocp_reg_read(tp, 0xa428);
+ 	data &= ~BIT(9);
+ 	ocp_reg_write(tp, 0xa428, data);
+ 	data = ocp_reg_read(tp, 0xa5ea);
+ 	data &= ~BIT(0);
+ 	ocp_reg_write(tp, 0xa5ea, data);
+ 	tp->ups_info.lite_mode = 0;
+ 
+ 	if (tp->eee_en)
+ 		rtl_eee_enable(tp, true);
+ 
+ 	r8153_aldps_en(tp, true);
+ 	r8152b_enable_fc(tp);
+ 	r8153_u2p3en(tp, true);
  
- 	/* enable rx aggregation */
- 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
- 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
- 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+ 	set_bit(PHY_RESET, &tp->flags);
  }
  
- static void r8153_init(struct r8152 *tp)
+ static void r8156_init(struct r8152 *tp)
  {
  	u32 ocp_data;
  	u16 data;
@@@ -6882,7 -8942,11 +8946,15 @@@ static int rtl8152_probe(struct usb_int
  	set_ethernet_addr(tp);
  
  	usb_set_intfdata(intf, tp);
++<<<<<<< HEAD
 +	netif_napi_add_weight(netdev, &tp->napi, r8152_poll, RTL8152_NAPI_WEIGHT);
++=======
+ 
+ 	if (tp->support_2500full)
+ 		netif_napi_add(netdev, &tp->napi, r8152_poll, 256);
+ 	else
+ 		netif_napi_add(netdev, &tp->napi, r8152_poll, 64);
++>>>>>>> 195aae321c82 (r8152: support new chips)
  
  	ret = register_netdev(netdev);
  	if (ret != 0) {
* Unmerged path drivers/net/usb/r8152.c
