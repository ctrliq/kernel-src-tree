r8152: fix the units of some registers for RTL8156A

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Hayes Wang <hayeswang@realtek.com>
commit 6dc4df12d741c0fe8f885778a43039e0619b9cd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/6dc4df12.failed

The units of PLA_RX_FIFO_FULL and PLA_RX_FIFO_EMPTY are 16 bytes.

Fixes: 195aae321c82 ("r8152: support new chips")
	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6dc4df12d741c0fe8f885778a43039e0619b9cd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index bd7057c011cc,46c7954d2762..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -5090,6 -6333,247 +5090,250 @@@ static void rtl8153b_down(struct r8152 
  	r8153_aldps_en(tp, true);
  }
  
++<<<<<<< HEAD
++=======
+ static void rtl8153c_change_mtu(struct r8152 *tp)
+ {
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+ 
+ 	/* Adjust the tx fifo free credit full threshold, otherwise
+ 	 * the fifo would be too small to send a jumbo frame packet.
+ 	 */
+ 	if (tp->netdev->mtu < 8000)
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 2048 / 8);
+ 	else
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 900 / 8);
+ }
+ 
+ static void rtl8153c_up(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153b_u1u2en(tp, false);
+ 	r8153_u2p3en(tp, false);
+ 	r8153_aldps_en(tp, false);
+ 
+ 	rxdy_gated_en(tp, true);
+ 	r8153_teredo_off(tp);
+ 
+ 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 	ocp_data &= ~RCR_ACPT_ALL;
+ 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 
+ 	rtl8152_nic_reset(tp);
+ 	rtl_reset_bmu(tp);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data &= ~NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data &= ~MCU_BORW_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	wait_oob_link_list_ready(tp);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data |= RE_INIT_LL;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	wait_oob_link_list_ready(tp);
+ 
+ 	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+ 
+ 	rtl8153c_change_mtu(tp);
+ 
+ 	rtl8152_nic_reset(tp);
+ 
+ 	/* rx share fifo credit full threshold */
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, 0x02);
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 0x08);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+ 
+ 	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+ 
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
+ 	ocp_data |= BIT(8);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);
+ 
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data &= ~PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	r8153_aldps_en(tp, true);
+ 	r8153b_u1u2en(tp, true);
+ }
+ 
+ static inline u32 fc_pause_on_auto(struct r8152 *tp)
+ {
+ 	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 6 * 1024);
+ }
+ 
+ static inline u32 fc_pause_off_auto(struct r8152 *tp)
+ {
+ 	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 14 * 1024);
+ }
+ 
+ static void r8156_fc_parameter(struct r8152 *tp)
+ {
+ 	u32 pause_on = tp->fc_pause_on ? tp->fc_pause_on : fc_pause_on_auto(tp);
+ 	u32 pause_off = tp->fc_pause_off ? tp->fc_pause_off : fc_pause_off_auto(tp);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 16);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, pause_off / 16);
+ }
+ 
+ static void rtl8156_change_mtu(struct r8152 *tp)
+ {
+ 	u32 rx_max_size = mtu_to_size(tp->netdev->mtu);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, rx_max_size);
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+ 	r8156_fc_parameter(tp);
+ 
+ 	/* TX share fifo free credit full threshold */
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+ 		       ALIGN(rx_max_size + sizeof(struct tx_desc), 1024) / 16);
+ }
+ 
+ static void rtl8156_up(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+ 		return;
+ 
+ 	r8153b_u1u2en(tp, false);
+ 	r8153_u2p3en(tp, false);
+ 	r8153_aldps_en(tp, false);
+ 
+ 	rxdy_gated_en(tp, true);
+ 	r8153_teredo_off(tp);
+ 
+ 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 	ocp_data &= ~RCR_ACPT_ALL;
+ 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 
+ 	rtl8152_nic_reset(tp);
+ 	rtl_reset_bmu(tp);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data &= ~NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data &= ~MCU_BORW_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+ 
+ 	rtl8156_change_mtu(tp);
+ 
+ 	switch (tp->version) {
+ 	case RTL_TEST_01:
+ 	case RTL_VER_10:
+ 	case RTL_VER_11:
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG);
+ 		ocp_data |= ACT_ODMA;
+ 		ocp_write_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/* share FIFO settings */
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL);
+ 	ocp_data &= ~RXFIFO_FULL_MASK;
+ 	ocp_data |= 0x08;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data &= ~PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION);
+ 	ocp_data &= ~(RG_PWRDN_EN | ALL_SPEED_OFF);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, ocp_data);
+ 
+ 	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);
+ 
+ 	if (tp->saved_wolopts != __rtl_get_wol(tp)) {
+ 		netif_warn(tp, ifup, tp->netdev, "wol setting is changed\n");
+ 		__rtl_set_wol(tp, tp->saved_wolopts);
+ 	}
+ 
+ 	r8153_aldps_en(tp, true);
+ 	r8153_u2p3en(tp, true);
+ 
+ 	if (tp->udev->speed >= USB_SPEED_SUPER)
+ 		r8153b_u1u2en(tp, true);
+ }
+ 
+ static void rtl8156_down(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+ 
+ 	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+ 		rtl_drop_queued_tx(tp);
+ 		return;
+ 	}
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+ 	ocp_data |= PLA_MCU_SPDWN_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+ 
+ 	r8153b_u1u2en(tp, false);
+ 	r8153_u2p3en(tp, false);
+ 	r8153b_power_cut_en(tp, false);
+ 	r8153_aldps_en(tp, false);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data &= ~NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	rtl_disable(tp);
+ 	rtl_reset_bmu(tp);
+ 
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+ 
+ 	/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+ 	 * type. Set it to zero. bits[7:0] are the W1C bits about
+ 	 * the events. Set them to all 1 to clear them.
+ 	 */
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+ 
+ 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+ 	ocp_data |= NOW_IS_OOB;
+ 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+ 	ocp_data |= MCU_BORW_EN;
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+ 
+ 	rtl_rx_vlan_en(tp, true);
+ 	rxdy_gated_en(tp, false);
+ 
+ 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
+ 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 
+ 	r8153_aldps_en(tp, true);
+ }
+ 
++>>>>>>> 6dc4df12d741 (r8152: fix the units of some registers for RTL8156A)
  static bool rtl8152_in_nway(struct r8152 *tp)
  {
  	u16 nway_state;
* Unmerged path drivers/net/usb/r8152.c
