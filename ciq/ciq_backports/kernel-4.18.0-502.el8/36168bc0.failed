x86/cpu: Add Xeon Emerald Rapids to list of CPUs that support PPIN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Tony Luck <tony.luck@intel.com>
commit 36168bc061b4368ad19e82b06a6463c95d3bb9a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/36168bc0.failed

This should be the last addition to this table. Future CPUs will
enumerate PPIN support using CPUID.

	Signed-off-by: Tony Luck <tony.luck@intel.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Link: https://lore.kernel.org/r/20230404212124.428118-1-tony.luck@intel.com
(cherry picked from commit 36168bc061b4368ad19e82b06a6463c95d3bb9a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/kernel/cpu/common.c
index e2a0a17f458d,80710a68ef7d..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -87,6 -91,84 +87,87 @@@ EXPORT_SYMBOL_GPL(get_llc_id)
  /* L2 cache ID of each logical CPU */
  DEFINE_PER_CPU_READ_MOSTLY(u16, cpu_l2c_id) = BAD_APICID;
  
++<<<<<<< HEAD
++=======
+ static struct ppin_info {
+ 	int	feature;
+ 	int	msr_ppin_ctl;
+ 	int	msr_ppin;
+ } ppin_info[] = {
+ 	[X86_VENDOR_INTEL] = {
+ 		.feature = X86_FEATURE_INTEL_PPIN,
+ 		.msr_ppin_ctl = MSR_PPIN_CTL,
+ 		.msr_ppin = MSR_PPIN
+ 	},
+ 	[X86_VENDOR_AMD] = {
+ 		.feature = X86_FEATURE_AMD_PPIN,
+ 		.msr_ppin_ctl = MSR_AMD_PPIN_CTL,
+ 		.msr_ppin = MSR_AMD_PPIN
+ 	},
+ };
+ 
+ static const struct x86_cpu_id ppin_cpuids[] = {
+ 	X86_MATCH_FEATURE(X86_FEATURE_AMD_PPIN, &ppin_info[X86_VENDOR_AMD]),
+ 	X86_MATCH_FEATURE(X86_FEATURE_INTEL_PPIN, &ppin_info[X86_VENDOR_INTEL]),
+ 
+ 	/* Legacy models without CPUID enumeration */
+ 	X86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(HASWELL_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(EMERALDRAPIDS_X, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNL, &ppin_info[X86_VENDOR_INTEL]),
+ 	X86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNM, &ppin_info[X86_VENDOR_INTEL]),
+ 
+ 	{}
+ };
+ 
+ static void ppin_init(struct cpuinfo_x86 *c)
+ {
+ 	const struct x86_cpu_id *id;
+ 	unsigned long long val;
+ 	struct ppin_info *info;
+ 
+ 	id = x86_match_cpu(ppin_cpuids);
+ 	if (!id)
+ 		return;
+ 
+ 	/*
+ 	 * Testing the presence of the MSR is not enough. Need to check
+ 	 * that the PPIN_CTL allows reading of the PPIN.
+ 	 */
+ 	info = (struct ppin_info *)id->driver_data;
+ 
+ 	if (rdmsrl_safe(info->msr_ppin_ctl, &val))
+ 		goto clear_ppin;
+ 
+ 	if ((val & 3UL) == 1UL) {
+ 		/* PPIN locked in disabled mode */
+ 		goto clear_ppin;
+ 	}
+ 
+ 	/* If PPIN is disabled, try to enable */
+ 	if (!(val & 2UL)) {
+ 		wrmsrl_safe(info->msr_ppin_ctl,  val | 2UL);
+ 		rdmsrl_safe(info->msr_ppin_ctl, &val);
+ 	}
+ 
+ 	/* Is the enable bit set? */
+ 	if (val & 2UL) {
+ 		c->ppin = __rdmsr(info->msr_ppin);
+ 		set_cpu_cap(c, info->feature);
+ 		return;
+ 	}
+ 
+ clear_ppin:
+ 	clear_cpu_cap(c, info->feature);
+ }
+ 
++>>>>>>> 36168bc061b4 (x86/cpu: Add Xeon Emerald Rapids to list of CPUs that support PPIN)
  /* correctly size the local cpu masks */
  void __init setup_cpu_local_masks(void)
  {
* Unmerged path arch/x86/kernel/cpu/common.c
