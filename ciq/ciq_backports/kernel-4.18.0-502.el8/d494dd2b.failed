net/mlx5e: Completely eliminate priv from fs.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Lama Kayal <lkayal@nvidia.com>
commit d494dd2bb70c2a0c4a4234698c60c52165603f70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/d494dd2b.failed

Complete the decoupling process of flow steering from en.h.

	Signed-off-by: Lama Kayal <lkayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit d494dd2bb70c2a0c4a4234698c60c52165603f70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 9b8cdf2e68ad,bf2741eb7f9b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -83,39 -89,8 +83,44 @@@ enum 
  #endif
  };
  
++<<<<<<< HEAD
 +struct mlx5e_priv;
++=======
+ struct mlx5e_flow_steering;
+ struct mlx5e_rx_res;
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
 +
 +#ifdef CONFIG_MLX5_EN_RXNFC
 +
 +struct mlx5e_ethtool_table {
 +	struct mlx5_flow_table *ft;
 +	int                    num_rules;
 +};
 +
 +#define ETHTOOL_NUM_L3_L4_FTS 7
 +#define ETHTOOL_NUM_L2_FTS 4
 +
 +struct mlx5e_ethtool_steering {
 +	struct mlx5e_ethtool_table      l3_l4_ft[ETHTOOL_NUM_L3_L4_FTS];
 +	struct mlx5e_ethtool_table      l2_ft[ETHTOOL_NUM_L2_FTS];
 +	struct list_head                rules;
 +	int                             tot_num_rules;
 +};
 +
 +void mlx5e_ethtool_init_steering(struct mlx5e_priv *priv);
 +void mlx5e_ethtool_cleanup_steering(struct mlx5e_priv *priv);
 +int mlx5e_ethtool_set_rxnfc(struct mlx5e_priv *priv, struct ethtool_rxnfc *cmd);
 +int mlx5e_ethtool_get_rxnfc(struct mlx5e_priv *priv,
 +			    struct ethtool_rxnfc *info, u32 *rule_locs);
 +#else
 +static inline void mlx5e_ethtool_init_steering(struct mlx5e_priv *priv)    { }
 +static inline void mlx5e_ethtool_cleanup_steering(struct mlx5e_priv *priv) { }
 +static inline int mlx5e_ethtool_set_rxnfc(struct mlx5e_priv *priv, struct ethtool_rxnfc *cmd)
 +{ return -EOPNOTSUPP; }
 +static inline int mlx5e_ethtool_get_rxnfc(struct mlx5e_priv *priv,
 +					  struct ethtool_rxnfc *info, u32 *rule_locs)
 +{ return -EOPNOTSUPP; }
 +#endif /* CONFIG_MLX5_EN_RXNFC */
  
  #ifdef CONFIG_MLX5_EN_ARFS
  struct mlx5e_arfs_tables;
@@@ -185,11 -146,39 +194,19 @@@ struct mlx5e_flow_steering *mlx5e_fs_in
  					  struct mlx5_core_dev *mdev,
  					  bool state_destroy);
  void mlx5e_fs_cleanup(struct mlx5e_flow_steering *fs);
 -struct mlx5e_vlan_table *mlx5e_fs_get_vlan(struct mlx5e_flow_steering *fs);
 -void mlx5e_fs_set_tc(struct mlx5e_flow_steering *fs, struct mlx5e_tc_table *tc);
 -struct mlx5e_tc_table *mlx5e_fs_get_tc(struct mlx5e_flow_steering *fs);
 -struct mlx5e_l2_table *mlx5e_fs_get_l2(struct mlx5e_flow_steering *fs);
 -struct mlx5_flow_namespace *mlx5e_fs_get_ns(struct mlx5e_flow_steering *fs, bool egress);
 -void mlx5e_fs_set_ns(struct mlx5e_flow_steering *fs, struct mlx5_flow_namespace *ns, bool egress);
 -#ifdef CONFIG_MLX5_EN_RXNFC
 -struct mlx5e_ethtool_steering *mlx5e_fs_get_ethtool(struct mlx5e_flow_steering *fs);
 -#endif
 -struct mlx5_ttc_table *mlx5e_fs_get_ttc(struct mlx5e_flow_steering *fs, bool inner);
 -void mlx5e_fs_set_ttc(struct mlx5e_flow_steering *fs, struct mlx5_ttc_table *ttc, bool inner);
 -#ifdef CONFIG_MLX5_EN_ARFS
 -struct mlx5e_arfs_tables *mlx5e_fs_get_arfs(struct mlx5e_flow_steering *fs);
 -void mlx5e_fs_set_arfs(struct mlx5e_flow_steering *fs, struct mlx5e_arfs_tables *arfs);
 -#endif
 -struct mlx5e_ptp_fs *mlx5e_fs_get_ptp(struct mlx5e_flow_steering *fs);
 -void mlx5e_fs_set_ptp(struct mlx5e_flow_steering *fs, struct mlx5e_ptp_fs *ptp_fs);
 -struct mlx5e_fs_any *mlx5e_fs_get_any(struct mlx5e_flow_steering *fs);
 -void mlx5e_fs_set_any(struct mlx5e_flow_steering *fs, struct mlx5e_fs_any *any);
 -struct mlx5e_fs_udp *mlx5e_fs_get_udp(struct mlx5e_flow_steering *fs);
 -void mlx5e_fs_set_udp(struct mlx5e_flow_steering *fs, struct mlx5e_fs_udp *udp);
 -#ifdef CONFIG_MLX5_EN_TLS
 -struct mlx5e_accel_fs_tcp *mlx5e_fs_get_accel_tcp(struct mlx5e_flow_steering *fs);
 -void mlx5e_fs_set_accel_tcp(struct mlx5e_flow_steering *fs, struct mlx5e_accel_fs_tcp *accel_tcp);
 -#endif
 -void mlx5e_fs_set_state_destroy(struct mlx5e_flow_steering *fs, bool state_destroy);
 -void mlx5e_fs_set_vlan_strip_disable(struct mlx5e_flow_steering *fs, bool vlan_strip_disable);
  
++<<<<<<< HEAD
 +int mlx5e_add_vlan_trap(struct mlx5e_priv *priv, int  trap_id, int tir_num);
 +void mlx5e_remove_vlan_trap(struct mlx5e_priv *priv);
 +int mlx5e_add_mac_trap(struct mlx5e_priv *priv, int  trap_id, int tir_num);
 +void mlx5e_remove_mac_trap(struct mlx5e_priv *priv);
++=======
+ struct mlx5_core_dev *mlx5e_fs_get_mdev(struct mlx5e_flow_steering *fs);
+ int mlx5e_add_vlan_trap(struct mlx5e_flow_steering *fs, int  trap_id, int tir_num);
+ void mlx5e_remove_vlan_trap(struct mlx5e_flow_steering *fs);
+ int mlx5e_add_mac_trap(struct mlx5e_flow_steering *fs, int  trap_id, int tir_num);
+ void mlx5e_remove_mac_trap(struct mlx5e_flow_steering *fs);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  void mlx5e_fs_set_rx_mode_work(struct mlx5e_flow_steering *fs, struct net_device *netdev);
  int mlx5e_fs_vlan_rx_add_vid(struct mlx5e_flow_steering *fs,
  			     struct net_device *netdev,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 6768f21c4eb1,ef1dfbb78464..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -360,12 -387,12 +359,18 @@@ int mlx5e_add_vlan_trap(struct mlx5e_fl
  	rule = mlx5e_add_trap_rule(ft, trap_id, tir_num);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
++<<<<<<< HEAD
 +		priv->fs->vlan->trap_rule = NULL;
 +		mlx5_core_err(priv->fs->mdev, "%s: add VLAN trap rule failed, err %d\n",
 +			      __func__, err);
++=======
+ 		fs->vlan->trap_rule = NULL;
+ 		fs_err(fs, "%s: add VLAN trap rule failed, err %d\n",
+ 		       __func__, err);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  		return err;
  	}
- 	priv->fs->vlan->trap_rule = rule;
+ 	fs->vlan->trap_rule = rule;
  	return 0;
  }
  
@@@ -386,12 -413,12 +391,18 @@@ int mlx5e_add_mac_trap(struct mlx5e_flo
  	rule = mlx5e_add_trap_rule(ft, trap_id, tir_num);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
++<<<<<<< HEAD
 +		priv->fs->l2.trap_rule = NULL;
 +		mlx5_core_err(priv->fs->mdev, "%s: add MAC trap rule failed, err %d\n",
 +			      __func__, err);
++=======
+ 		fs->l2.trap_rule = NULL;
+ 		fs_err(fs, "%s: add MAC trap rule failed, err %d\n",
+ 		       __func__, err);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  		return err;
  	}
- 	priv->fs->l2.trap_rule = rule;
+ 	fs->l2.trap_rule = rule;
  	return 0;
  }
  
@@@ -1221,25 -1248,26 +1232,25 @@@ err_destroy_vlan_table
  	return err;
  }
  
- static void mlx5e_destroy_vlan_table(struct mlx5e_priv *priv)
+ static void mlx5e_destroy_vlan_table(struct mlx5e_flow_steering *fs)
  {
- 	mlx5e_del_vlan_rules(priv);
- 	mlx5e_destroy_flow_table(&priv->fs->vlan->ft);
+ 	mlx5e_del_vlan_rules(fs);
+ 	mlx5e_destroy_flow_table(&fs->vlan->ft);
  }
  
- static void mlx5e_destroy_inner_ttc_table(struct mlx5e_priv *priv)
+ static void mlx5e_destroy_inner_ttc_table(struct mlx5e_flow_steering *fs)
  {
- 	if (!mlx5_tunnel_inner_ft_supported(priv->fs->mdev))
+ 	if (!mlx5_tunnel_inner_ft_supported(fs->mdev))
  		return;
- 	mlx5_destroy_ttc_table(priv->fs->inner_ttc);
+ 	mlx5_destroy_ttc_table(fs->inner_ttc);
  }
  
 -void mlx5e_destroy_ttc_table(struct mlx5e_flow_steering *fs)
 +void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv)
  {
 -	mlx5_destroy_ttc_table(fs->ttc);
 +	mlx5_destroy_ttc_table(priv->fs->ttc);
  }
  
 -static int mlx5e_create_inner_ttc_table(struct mlx5e_flow_steering *fs,
 -					struct mlx5e_rx_res *rx_res)
 +static int mlx5e_create_inner_ttc_table(struct mlx5e_priv *priv)
  {
  	struct ttc_params ttc_params = {};
  
@@@ -1265,27 -1294,29 +1276,44 @@@ int mlx5e_create_ttc_table(struct mlx5e
  	return 0;
  }
  
- int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
+ int mlx5e_create_flow_steering(struct mlx5e_flow_steering *fs,
+ 			       struct mlx5e_rx_res *rx_res,
+ 			       const struct mlx5e_profile *profile,
+ 			       struct net_device *netdev)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_flow_namespace *ns = mlx5_get_flow_namespace(fs->mdev,
+ 								 MLX5_FLOW_NAMESPACE_KERNEL);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  	int err;
  
 -	if (!ns)
 +	priv->fs->ns = mlx5_get_flow_namespace(priv->fs->mdev,
 +					       MLX5_FLOW_NAMESPACE_KERNEL);
 +
 +	if (!priv->fs->ns)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	err = mlx5e_arfs_create_tables(priv);
 +	if (err) {
 +		mlx5_core_err(priv->fs->mdev, "Failed to create arfs tables, err=%d\n",
 +			      err);
 +		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
++=======
+ 	mlx5e_fs_set_ns(fs, ns, false);
+ 	err = mlx5e_arfs_create_tables(fs, rx_res,
+ 				       !!(netdev->hw_features & NETIF_F_NTUPLE));
+ 	if (err) {
+ 		fs_err(fs, "Failed to create arfs tables, err=%d\n", err);
+ 		netdev->hw_features &= ~NETIF_F_NTUPLE;
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  	}
  
 -	err = mlx5e_create_inner_ttc_table(fs, rx_res);
 +	err = mlx5e_create_inner_ttc_table(priv);
  	if (err) {
 -		fs_err(fs, "Failed to create inner ttc table, err=%d\n", err);
 +		mlx5_core_err(priv->fs->mdev,
 +			      "Failed to create inner ttc table, err=%d\n", err);
  		goto err_destroy_arfs_tables;
  	}
  
@@@ -1296,51 -1326,50 +1324,78 @@@
  		goto err_destroy_inner_ttc_table;
  	}
  
- 	err = mlx5e_create_l2_table(priv);
+ 	err = mlx5e_create_l2_table(fs);
  	if (err) {
 -		fs_err(fs, "Failed to create l2 table, err=%d\n", err);
 +		mlx5_core_err(priv->fs->mdev, "Failed to create l2 table, err=%d\n",
 +			      err);
  		goto err_destroy_ttc_table;
  	}
  
- 	err = mlx5e_fs_create_vlan_table(priv->fs);
+ 	err = mlx5e_fs_create_vlan_table(fs);
  	if (err) {
 -		fs_err(fs, "Failed to create vlan table, err=%d\n", err);
 +		mlx5_core_err(priv->fs->mdev, "Failed to create vlan table, err=%d\n",
 +			      err);
  		goto err_destroy_l2_table;
  	}
  
++<<<<<<< HEAD
 +	err = mlx5e_ptp_alloc_rx_fs(priv);
 +	if (err)
 +		goto err_destory_vlan_table;
 +
 +	mlx5e_ethtool_init_steering(priv);
++=======
+ 	err = mlx5e_ptp_alloc_rx_fs(fs, profile);
+ 	if (err)
+ 		goto err_destory_vlan_table;
+ 
+ 	mlx5e_ethtool_init_steering(fs);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  
  	return 0;
  
  err_destory_vlan_table:
- 	mlx5e_destroy_vlan_table(priv);
+ 	mlx5e_destroy_vlan_table(fs);
  err_destroy_l2_table:
- 	mlx5e_destroy_l2_table(priv);
+ 	mlx5e_destroy_l2_table(fs);
  err_destroy_ttc_table:
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv);
++=======
+ 	mlx5e_destroy_ttc_table(fs);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  err_destroy_inner_ttc_table:
- 	mlx5e_destroy_inner_ttc_table(priv);
+ 	mlx5e_destroy_inner_ttc_table(fs);
  err_destroy_arfs_tables:
++<<<<<<< HEAD
 +	mlx5e_arfs_destroy_tables(priv);
++=======
+ 	mlx5e_arfs_destroy_tables(fs, !!(netdev->hw_features & NETIF_F_NTUPLE));
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  
  	return err;
  }
  
- void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv)
+ void mlx5e_destroy_flow_steering(struct mlx5e_flow_steering *fs, bool ntuple,
+ 				 const struct mlx5e_profile *profile)
  {
++<<<<<<< HEAD
 +	mlx5e_ptp_free_rx_fs(priv);
 +	mlx5e_destroy_vlan_table(priv);
 +	mlx5e_destroy_l2_table(priv);
 +	mlx5e_destroy_ttc_table(priv);
 +	mlx5e_destroy_inner_ttc_table(priv);
 +	mlx5e_arfs_destroy_tables(priv);
 +	mlx5e_ethtool_cleanup_steering(priv);
++=======
+ 	mlx5e_ptp_free_rx_fs(fs, profile);
+ 	mlx5e_destroy_vlan_table(fs);
+ 	mlx5e_destroy_l2_table(fs);
+ 	mlx5e_destroy_ttc_table(fs);
+ 	mlx5e_destroy_inner_ttc_table(fs);
+ 	mlx5e_arfs_destroy_tables(fs, ntuple);
+ 	mlx5e_ethtool_cleanup_steering(fs);
++>>>>>>> d494dd2bb70c (net/mlx5e: Completely eliminate priv from fs.h)
  }
  
  static int mlx5e_fs_vlan_alloc(struct mlx5e_flow_steering *fs)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c b/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
index 5b63f3189704..201ac7dd338f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
@@ -230,12 +230,12 @@ static int mlx5e_handle_action_trap(struct mlx5e_priv *priv, int trap_id)
 
 	switch (trap_id) {
 	case DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER:
-		err = mlx5e_add_vlan_trap(priv, trap_id, mlx5e_trap_get_tirn(priv->en_trap));
+		err = mlx5e_add_vlan_trap(priv->fs, trap_id, mlx5e_trap_get_tirn(priv->en_trap));
 		if (err)
 			goto err_out;
 		break;
 	case DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER:
-		err = mlx5e_add_mac_trap(priv, trap_id, mlx5e_trap_get_tirn(priv->en_trap));
+		err = mlx5e_add_mac_trap(priv->fs, trap_id, mlx5e_trap_get_tirn(priv->en_trap));
 		if (err)
 			goto err_out;
 		break;
@@ -256,10 +256,10 @@ static int mlx5e_handle_action_drop(struct mlx5e_priv *priv, int trap_id)
 {
 	switch (trap_id) {
 	case DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER:
-		mlx5e_remove_vlan_trap(priv);
+		mlx5e_remove_vlan_trap(priv->fs);
 		break;
 	case DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER:
-		mlx5e_remove_mac_trap(priv);
+		mlx5e_remove_mac_trap(priv->fs);
 		break;
 	default:
 		netdev_warn(priv->netdev, "%s: Unknown trap id %d\n", __func__, trap_id);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 387a2d1312ee..129e1615064a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -3664,9 +3664,11 @@ static int set_feature_cvlan_filter(struct net_device *netdev, bool enable)
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 
 	if (enable)
-		mlx5e_enable_cvlan_filter(priv);
+		mlx5e_enable_cvlan_filter(priv->fs,
+					  !!(priv->netdev->flags & IFF_PROMISC));
 	else
-		mlx5e_disable_cvlan_filter(priv);
+		mlx5e_disable_cvlan_filter(priv->fs,
+					   !!(priv->netdev->flags & IFF_PROMISC));
 
 	return 0;
 }
@@ -5091,7 +5093,8 @@ static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
 	if (err)
 		goto err_close_drop_rq;
 
-	err = mlx5e_create_flow_steering(priv);
+	err = mlx5e_create_flow_steering(priv->fs, priv->rx_res, priv->profile,
+					 priv->netdev);
 	if (err) {
 		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
 		goto err_destroy_rx_res;
@@ -5114,7 +5117,8 @@ static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
 err_tc_nic_cleanup:
 	mlx5e_tc_nic_cleanup(priv);
 err_destroy_flow_steering:
-	mlx5e_destroy_flow_steering(priv);
+	mlx5e_destroy_flow_steering(priv->fs, !!(priv->netdev->hw_features & NETIF_F_NTUPLE),
+				    priv->profile);
 err_destroy_rx_res:
 	mlx5e_rx_res_destroy(priv->rx_res);
 err_close_drop_rq:
@@ -5130,7 +5134,8 @@ static void mlx5e_cleanup_nic_rx(struct mlx5e_priv *priv)
 {
 	mlx5e_accel_cleanup_rx(priv);
 	mlx5e_tc_nic_cleanup(priv);
-	mlx5e_destroy_flow_steering(priv);
+	mlx5e_destroy_flow_steering(priv->fs, !!(priv->netdev->hw_features & NETIF_F_NTUPLE),
+				    priv->profile);
 	mlx5e_rx_res_destroy(priv->rx_res);
 	mlx5e_close_drop_rq(&priv->drop_rq);
 	mlx5e_destroy_q_counters(priv);
