ipv6: tcp: send consistent autoflowlabel in SYN_RECV state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Eric Dumazet <edumazet@google.com>
commit aa51b80e1af47b3781abb1fb1666445a7616f0cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/aa51b80e.failed

This is a followup of commit c67b85558ff2 ("ipv6: tcp: send consistent
autoflowlabel in TIME_WAIT state"), but for SYN_RECV state.

In some cases, TCP sends a challenge ACK on behalf of a SYN_RECV request.
WHen this happens, we want to use the flow label that was used when
the prior SYNACK packet was sent, instead of another one.

After his patch, following packetdrill passes:

    0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
   +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
   +0 bind(3, ..., ...) = 0
   +0 listen(3, 1) = 0

  +.2 < S 0:0(0) win 32792 <mss 1000,sackOK,nop,nop,nop,wscale 7>
   +0 > (flowlabel 0x11) S. 0:0(0) ack 1 <...>
// Test if a challenge ack is properly sent (same flowlabel than prior SYNACK)
   +.01 < . 4000000000:4000000000(0) ack 1 win 320
   +0  > (flowlabel 0x11) . 1:1(0) ack 1

	Signed-off-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/20220831203729.458000-1-eric.dumazet@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit aa51b80e1af47b3781abb1fb1666445a7616f0cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv6/tcp_ipv6.c
index 1832037baa19,35013497e407..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -782,7 -858,7 +782,11 @@@ const struct tcp_request_sock_ops tcp_r
  static void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,
  				 u32 ack, u32 win, u32 tsval, u32 tsecr,
  				 int oif, struct tcp_md5sig_key *key, int rst,
++<<<<<<< HEAD
 +				 u8 tclass, __be32 label)
++=======
+ 				 u8 tclass, __be32 label, u32 priority, u32 txhash)
++>>>>>>> aa51b80e1af4 (ipv6: tcp: send consistent autoflowlabel in SYN_RECV state)
  {
  	const struct tcphdr *th = tcp_hdr(skb);
  	struct tcphdr *t1;
@@@ -875,14 -949,15 +879,19 @@@
  	}
  
  	if (sk) {
- 		if (sk->sk_state == TCP_TIME_WAIT) {
+ 		if (sk->sk_state == TCP_TIME_WAIT)
  			mark = inet_twsk(sk)->tw_mark;
- 			/* autoflowlabel relies on buff->hash */
- 			skb_set_hash(buff, inet_twsk(sk)->tw_txhash,
- 				     PKT_HASH_TYPE_L4);
- 		} else {
+ 		else
  			mark = sk->sk_mark;
++<<<<<<< HEAD
 +		}
++=======
+ 		skb_set_delivery_time(buff, tcp_transmit_time(sk), true);
++>>>>>>> aa51b80e1af4 (ipv6: tcp: send consistent autoflowlabel in SYN_RECV state)
+ 	}
+ 	if (txhash) {
+ 		/* autoflowlabel/skb_get_hash_flowi6 rely on buff->hash */
+ 		skb_set_hash(buff, txhash, PKT_HASH_TYPE_L4);
  	}
  	fl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark) ?: mark;
  	fl6.fl6_dport = t1->dest;
@@@ -972,11 -1067,25 +981,16 @@@ static void tcp_v6_send_reset(const str
  
  	if (sk) {
  		oif = sk->sk_bound_dev_if;
 -		if (sk_fullsock(sk)) {
 -			const struct ipv6_pinfo *np = tcp_inet6_sk(sk);
 -
 +		if (sk_fullsock(sk))
  			trace_tcp_send_reset(sk, skb);
 -			if (np->repflow)
 -				label = ip6_flowlabel(ipv6h);
 -			priority = sk->sk_priority;
 -		}
 -		if (sk->sk_state == TCP_TIME_WAIT) {
 -			label = cpu_to_be32(inet_twsk(sk)->tw_flowlabel);
 -			priority = inet_twsk(sk)->tw_priority;
 -		}
 -	} else {
 -		if (net->ipv6.sysctl.flowlabel_reflect & FLOWLABEL_REFLECT_TCP_RESET)
 -			label = ip6_flowlabel(ipv6h);
  	}
  
++<<<<<<< HEAD
 +	tcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);
++=======
+ 	tcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1,
+ 			     ipv6_get_dsfield(ipv6h), label, priority, 0);
++>>>>>>> aa51b80e1af4 (ipv6: tcp: send consistent autoflowlabel in SYN_RECV state)
  
  #ifdef CONFIG_TCP_MD5SIG
  out:
@@@ -987,10 -1096,10 +1001,17 @@@
  static void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,
  			    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,
  			    struct tcp_md5sig_key *key, u8 tclass,
++<<<<<<< HEAD
 +			    __be32 label)
 +{
 +	tcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,
 +			     tclass, label);
++=======
+ 			    __be32 label, u32 priority, u32 txhash)
+ {
+ 	tcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,
+ 			     tclass, label, priority, txhash);
++>>>>>>> aa51b80e1af4 (ipv6: tcp: send consistent autoflowlabel in SYN_RECV state)
  }
  
  static void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)
@@@ -1002,7 -1111,8 +1023,12 @@@
  			tcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,
  			tcp_time_stamp_raw() + tcptw->tw_ts_offset,
  			tcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),
++<<<<<<< HEAD
 +			tw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));
++=======
+ 			tw->tw_tclass, cpu_to_be32(tw->tw_flowlabel), tw->tw_priority,
+ 			tw->tw_txhash);
++>>>>>>> aa51b80e1af4 (ipv6: tcp: send consistent autoflowlabel in SYN_RECV state)
  
  	inet_twsk_put(tw);
  }
@@@ -1024,8 -1138,9 +1050,14 @@@ static void tcp_v6_reqsk_send_ack(cons
  			req->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,
  			tcp_time_stamp_raw() + tcp_rsk(req)->ts_off,
  			req->ts_recent, sk->sk_bound_dev_if,
++<<<<<<< HEAD
 +			tcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->saddr),
 +			0, 0);
++=======
+ 			tcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->saddr, l3index),
+ 			ipv6_get_dsfield(ipv6_hdr(skb)), 0, sk->sk_priority,
+ 			tcp_rsk(req)->txhash);
++>>>>>>> aa51b80e1af4 (ipv6: tcp: send consistent autoflowlabel in SYN_RECV state)
  }
  
  
* Unmerged path net/ipv6/tcp_ipv6.c
