x86/resctrl: Add interface to write mbm_local_bytes_config

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Babu Moger <babu.moger@amd.com>
commit 4fe61bff5a4100e92f81427dab06b7f3a025f6a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/4fe61bff.failed

The event configuration for mbm_local_bytes can be changed by the
user by writing to the configuration file
/sys/fs/resctrl/info/L3_MON/mbm_local_bytes_config.

The event configuration settings are domain specific and will affect all
the CPUs in the domain.

Following are the types of events supported:

  ====  ===========================================================
  Bits   Description
  ====  ===========================================================
  6      Dirty Victims from the QOS domain to all types of memory
  5      Reads to slow memory in the non-local NUMA domain
  4      Reads to slow memory in the local NUMA domain
  3      Non-temporal writes to non-local NUMA domain
  2      Non-temporal writes to local NUMA domain
  1      Reads to memory in the non-local NUMA domain
  0      Reads to memory in the local NUMA domain
  ====  ===========================================================

For example, to change the mbm_local_bytes_config to count all the non-temporal
writes on domain 0, the bits 2 and 3 needs to be set which is 1100b (in hex
0xc).
Run the command:

  $echo  0=0xc > /sys/fs/resctrl/info/L3_MON/mbm_local_bytes_config

To change the mbm_local_bytes to count only reads to local NUMA domain 1,
the bit 0 needs to be set which 1b (in hex 0x1). Run the command:

  $echo  1=0x1 > /sys/fs/resctrl/info/L3_MON/mbm_local_bytes_config

	Signed-off-by: Babu Moger <babu.moger@amd.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
Link: https://lore.kernel.org/r/20230113152039.770054-13-babu.moger@amd.com
(cherry picked from commit 4fe61bff5a4100e92f81427dab06b7f3a025f6a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index 2b966c66b88f,5990589f8a21..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -1486,6 -1420,248 +1486,251 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct mon_config_info {
+ 	u32 evtid;
+ 	u32 mon_config;
+ };
+ 
+ #define INVALID_CONFIG_INDEX   UINT_MAX
+ 
+ /**
+  * mon_event_config_index_get - get the hardware index for the
+  *                              configurable event
+  * @evtid: event id.
+  *
+  * Return: 0 for evtid == QOS_L3_MBM_TOTAL_EVENT_ID
+  *         1 for evtid == QOS_L3_MBM_LOCAL_EVENT_ID
+  *         INVALID_CONFIG_INDEX for invalid evtid
+  */
+ static inline unsigned int mon_event_config_index_get(u32 evtid)
+ {
+ 	switch (evtid) {
+ 	case QOS_L3_MBM_TOTAL_EVENT_ID:
+ 		return 0;
+ 	case QOS_L3_MBM_LOCAL_EVENT_ID:
+ 		return 1;
+ 	default:
+ 		/* Should never reach here */
+ 		return INVALID_CONFIG_INDEX;
+ 	}
+ }
+ 
+ static void mon_event_config_read(void *info)
+ {
+ 	struct mon_config_info *mon_info = info;
+ 	unsigned int index;
+ 	u32 h;
+ 
+ 	index = mon_event_config_index_get(mon_info->evtid);
+ 	if (index == INVALID_CONFIG_INDEX) {
+ 		pr_warn_once("Invalid event id %d\n", mon_info->evtid);
+ 		return;
+ 	}
+ 	rdmsr(MSR_IA32_EVT_CFG_BASE + index, mon_info->mon_config, h);
+ 
+ 	/* Report only the valid event configuration bits */
+ 	mon_info->mon_config &= MAX_EVT_CONFIG_BITS;
+ }
+ 
+ static void mondata_config_read(struct rdt_domain *d, struct mon_config_info *mon_info)
+ {
+ 	smp_call_function_any(&d->cpu_mask, mon_event_config_read, mon_info, 1);
+ }
+ 
+ static int mbm_config_show(struct seq_file *s, struct rdt_resource *r, u32 evtid)
+ {
+ 	struct mon_config_info mon_info = {0};
+ 	struct rdt_domain *dom;
+ 	bool sep = false;
+ 
+ 	mutex_lock(&rdtgroup_mutex);
+ 
+ 	list_for_each_entry(dom, &r->domains, list) {
+ 		if (sep)
+ 			seq_puts(s, ";");
+ 
+ 		memset(&mon_info, 0, sizeof(struct mon_config_info));
+ 		mon_info.evtid = evtid;
+ 		mondata_config_read(dom, &mon_info);
+ 
+ 		seq_printf(s, "%d=0x%02x", dom->id, mon_info.mon_config);
+ 		sep = true;
+ 	}
+ 	seq_puts(s, "\n");
+ 
+ 	mutex_unlock(&rdtgroup_mutex);
+ 
+ 	return 0;
+ }
+ 
+ static int mbm_total_bytes_config_show(struct kernfs_open_file *of,
+ 				       struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	mbm_config_show(seq, r, QOS_L3_MBM_TOTAL_EVENT_ID);
+ 
+ 	return 0;
+ }
+ 
+ static int mbm_local_bytes_config_show(struct kernfs_open_file *of,
+ 				       struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	mbm_config_show(seq, r, QOS_L3_MBM_LOCAL_EVENT_ID);
+ 
+ 	return 0;
+ }
+ 
+ static void mon_event_config_write(void *info)
+ {
+ 	struct mon_config_info *mon_info = info;
+ 	unsigned int index;
+ 
+ 	index = mon_event_config_index_get(mon_info->evtid);
+ 	if (index == INVALID_CONFIG_INDEX) {
+ 		pr_warn_once("Invalid event id %d\n", mon_info->evtid);
+ 		return;
+ 	}
+ 	wrmsr(MSR_IA32_EVT_CFG_BASE + index, mon_info->mon_config, 0);
+ }
+ 
+ static int mbm_config_write_domain(struct rdt_resource *r,
+ 				   struct rdt_domain *d, u32 evtid, u32 val)
+ {
+ 	struct mon_config_info mon_info = {0};
+ 	int ret = 0;
+ 
+ 	/* mon_config cannot be more than the supported set of events */
+ 	if (val > MAX_EVT_CONFIG_BITS) {
+ 		rdt_last_cmd_puts("Invalid event configuration\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * Read the current config value first. If both are the same then
+ 	 * no need to write it again.
+ 	 */
+ 	mon_info.evtid = evtid;
+ 	mondata_config_read(d, &mon_info);
+ 	if (mon_info.mon_config == val)
+ 		goto out;
+ 
+ 	mon_info.mon_config = val;
+ 
+ 	/*
+ 	 * Update MSR_IA32_EVT_CFG_BASE MSR on one of the CPUs in the
+ 	 * domain. The MSRs offset from MSR MSR_IA32_EVT_CFG_BASE
+ 	 * are scoped at the domain level. Writing any of these MSRs
+ 	 * on one CPU is observed by all the CPUs in the domain.
+ 	 */
+ 	smp_call_function_any(&d->cpu_mask, mon_event_config_write,
+ 			      &mon_info, 1);
+ 
+ 	/*
+ 	 * When an Event Configuration is changed, the bandwidth counters
+ 	 * for all RMIDs and Events will be cleared by the hardware. The
+ 	 * hardware also sets MSR_IA32_QM_CTR.Unavailable (bit 62) for
+ 	 * every RMID on the next read to any event for every RMID.
+ 	 * Subsequent reads will have MSR_IA32_QM_CTR.Unavailable (bit 62)
+ 	 * cleared while it is tracked by the hardware. Clear the
+ 	 * mbm_local and mbm_total counts for all the RMIDs.
+ 	 */
+ 	resctrl_arch_reset_rmid_all(r, d);
+ 
+ out:
+ 	return ret;
+ }
+ 
+ static int mon_config_write(struct rdt_resource *r, char *tok, u32 evtid)
+ {
+ 	char *dom_str = NULL, *id_str;
+ 	unsigned long dom_id, val;
+ 	struct rdt_domain *d;
+ 	int ret = 0;
+ 
+ next:
+ 	if (!tok || tok[0] == '\0')
+ 		return 0;
+ 
+ 	/* Start processing the strings for each domain */
+ 	dom_str = strim(strsep(&tok, ";"));
+ 	id_str = strsep(&dom_str, "=");
+ 
+ 	if (!id_str || kstrtoul(id_str, 10, &dom_id)) {
+ 		rdt_last_cmd_puts("Missing '=' or non-numeric domain id\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!dom_str || kstrtoul(dom_str, 16, &val)) {
+ 		rdt_last_cmd_puts("Non-numeric event configuration value\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	list_for_each_entry(d, &r->domains, list) {
+ 		if (d->id == dom_id) {
+ 			ret = mbm_config_write_domain(r, d, evtid, val);
+ 			if (ret)
+ 				return -EINVAL;
+ 			goto next;
+ 		}
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static ssize_t mbm_total_bytes_config_write(struct kernfs_open_file *of,
+ 					    char *buf, size_t nbytes,
+ 					    loff_t off)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	int ret;
+ 
+ 	/* Valid input requires a trailing newline */
+ 	if (nbytes == 0 || buf[nbytes - 1] != '\n')
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&rdtgroup_mutex);
+ 
+ 	rdt_last_cmd_clear();
+ 
+ 	buf[nbytes - 1] = '\0';
+ 
+ 	ret = mon_config_write(r, buf, QOS_L3_MBM_TOTAL_EVENT_ID);
+ 
+ 	mutex_unlock(&rdtgroup_mutex);
+ 
+ 	return ret ?: nbytes;
+ }
+ 
+ static ssize_t mbm_local_bytes_config_write(struct kernfs_open_file *of,
+ 					    char *buf, size_t nbytes,
+ 					    loff_t off)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	int ret;
+ 
+ 	/* Valid input requires a trailing newline */
+ 	if (nbytes == 0 || buf[nbytes - 1] != '\n')
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&rdtgroup_mutex);
+ 
+ 	rdt_last_cmd_clear();
+ 
+ 	buf[nbytes - 1] = '\0';
+ 
+ 	ret = mon_config_write(r, buf, QOS_L3_MBM_LOCAL_EVENT_ID);
+ 
+ 	mutex_unlock(&rdtgroup_mutex);
+ 
+ 	return ret ?: nbytes;
+ }
+ 
++>>>>>>> 4fe61bff5a41 (x86/resctrl: Add interface to write mbm_local_bytes_config)
  /* rdtgroup information files for one cache resource. */
  static struct rftype res_common_files[] = {
  	{
@@@ -1585,6 -1761,20 +1830,23 @@@
  		.fflags		= RF_MON_INFO | RFTYPE_RES_CACHE,
  	},
  	{
++<<<<<<< HEAD
++=======
+ 		.name		= "mbm_total_bytes_config",
+ 		.mode		= 0644,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= mbm_total_bytes_config_show,
+ 		.write		= mbm_total_bytes_config_write,
+ 	},
+ 	{
+ 		.name		= "mbm_local_bytes_config",
+ 		.mode		= 0644,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= mbm_local_bytes_config_show,
+ 		.write		= mbm_local_bytes_config_write,
+ 	},
+ 	{
++>>>>>>> 4fe61bff5a41 (x86/resctrl: Add interface to write mbm_local_bytes_config)
  		.name		= "cpus",
  		.mode		= 0644,
  		.kf_ops		= &rdtgroup_kf_single_ops,
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
