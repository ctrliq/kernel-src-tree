r8152: sync ocp base

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Hayes Wang <hayeswang@realtek.com>
commit b24edca309535c2d9af86aab95d64065f6ef1d26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/b24edca3.failed

There are some chances that the actual base of hardware is different
from the value recorded by driver, so we have to reset the variable
of ocp_base to sync it.

Set ocp_base to -1. Then, it would be updated and the new base would be
set to the hardware next time.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit b24edca309535c2d9af86aab95d64065f6ef1d26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index 3fc35ae93ecc,3085e8118d7f..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -33,10 -29,10 +33,10 @@@
  #include <linux/usb/r8152.h>
  
  /* Information for net-next */
 -#define NETNEXT_VERSION		"12"
 +#define NETNEXT_VERSION		"11"
  
  /* Information for net */
- #define NET_VERSION		"11"
+ #define NET_VERSION		"12"
  
  #define DRIVER_VERSION		"v1." NETNEXT_VERSION "." NET_VERSION
  #define DRIVER_AUTHOR "Realtek linux nic maintainers <nic_swsd@realtek.com>"
@@@ -3950,6 -4798,152 +3953,155 @@@ fail
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void rtl_ram_code_speed_up(struct r8152 *tp, struct fw_phy_speed_up *phy, bool wait)
+ {
+ 	u32 len;
+ 	u8 *data;
+ 
+ 	rtl_reset_ocp_base(tp);
+ 
+ 	if (sram_read(tp, SRAM_GPHY_FW_VER) >= __le16_to_cpu(phy->version)) {
+ 		dev_dbg(&tp->intf->dev, "PHY firmware has been the newest\n");
+ 		return;
+ 	}
+ 
+ 	len = __le32_to_cpu(phy->blk_hdr.length);
+ 	len -= __le16_to_cpu(phy->fw_offset);
+ 	data = (u8 *)phy + __le16_to_cpu(phy->fw_offset);
+ 
+ 	if (rtl_phy_patch_request(tp, true, wait))
+ 		return;
+ 
+ 	while (len) {
+ 		u32 ocp_data, size;
+ 		int i;
+ 
+ 		if (len < 2048)
+ 			size = len;
+ 		else
+ 			size = 2048;
+ 
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL);
+ 		ocp_data |= GPHY_PATCH_DONE | BACKUP_RESTRORE;
+ 		ocp_write_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL, ocp_data);
+ 
+ 		generic_ocp_write(tp, __le16_to_cpu(phy->fw_reg), 0xff, size, data, MCU_TYPE_USB);
+ 
+ 		data += size;
+ 		len -= size;
+ 
+ 		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL);
+ 		ocp_data |= POL_GPHY_PATCH;
+ 		ocp_write_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL, ocp_data);
+ 
+ 		for (i = 0; i < 1000; i++) {
+ 			if (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL) & POL_GPHY_PATCH))
+ 				break;
+ 		}
+ 
+ 		if (i == 1000) {
+ 			dev_err(&tp->intf->dev, "ram code speedup mode timeout\n");
+ 			break;
+ 		}
+ 	}
+ 
+ 	rtl_reset_ocp_base(tp);
+ 
+ 	rtl_phy_patch_request(tp, false, wait);
+ 
+ 	if (sram_read(tp, SRAM_GPHY_FW_VER) == __le16_to_cpu(phy->version))
+ 		dev_dbg(&tp->intf->dev, "successfully applied %s\n", phy->info);
+ 	else
+ 		dev_err(&tp->intf->dev, "ram code speedup mode fail\n");
+ }
+ 
+ static int rtl8152_fw_phy_ver(struct r8152 *tp, struct fw_phy_ver *phy_ver)
+ {
+ 	u16 ver_addr, ver;
+ 
+ 	ver_addr = __le16_to_cpu(phy_ver->ver.addr);
+ 	ver = __le16_to_cpu(phy_ver->ver.data);
+ 
+ 	rtl_reset_ocp_base(tp);
+ 
+ 	if (sram_read(tp, ver_addr) >= ver) {
+ 		dev_dbg(&tp->intf->dev, "PHY firmware has been the newest\n");
+ 		return 0;
+ 	}
+ 
+ 	sram_write(tp, ver_addr, ver);
+ 
+ 	dev_dbg(&tp->intf->dev, "PHY firmware version %x\n", ver);
+ 
+ 	return ver;
+ }
+ 
+ static void rtl8152_fw_phy_fixup(struct r8152 *tp, struct fw_phy_fixup *fix)
+ {
+ 	u16 addr, data;
+ 
+ 	rtl_reset_ocp_base(tp);
+ 
+ 	addr = __le16_to_cpu(fix->setting.addr);
+ 	data = ocp_reg_read(tp, addr);
+ 
+ 	switch (__le16_to_cpu(fix->bit_cmd)) {
+ 	case FW_FIXUP_AND:
+ 		data &= __le16_to_cpu(fix->setting.data);
+ 		break;
+ 	case FW_FIXUP_OR:
+ 		data |= __le16_to_cpu(fix->setting.data);
+ 		break;
+ 	case FW_FIXUP_NOT:
+ 		data &= ~__le16_to_cpu(fix->setting.data);
+ 		break;
+ 	case FW_FIXUP_XOR:
+ 		data ^= __le16_to_cpu(fix->setting.data);
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	ocp_reg_write(tp, addr, data);
+ 
+ 	dev_dbg(&tp->intf->dev, "applied ocp %x %x\n", addr, data);
+ }
+ 
+ static void rtl8152_fw_phy_union_apply(struct r8152 *tp, struct fw_phy_union *phy)
+ {
+ 	__le16 *data;
+ 	u32 length;
+ 	int i, num;
+ 
+ 	rtl_reset_ocp_base(tp);
+ 
+ 	num = phy->pre_num;
+ 	for (i = 0; i < num; i++)
+ 		sram_write(tp, __le16_to_cpu(phy->pre_set[i].addr),
+ 			   __le16_to_cpu(phy->pre_set[i].data));
+ 
+ 	length = __le32_to_cpu(phy->blk_hdr.length);
+ 	length -= __le16_to_cpu(phy->fw_offset);
+ 	num = length / 2;
+ 	data = (__le16 *)((u8 *)phy + __le16_to_cpu(phy->fw_offset));
+ 
+ 	ocp_reg_write(tp, OCP_SRAM_ADDR, __le16_to_cpu(phy->fw_reg));
+ 	for (i = 0; i < num; i++)
+ 		ocp_reg_write(tp, OCP_SRAM_DATA, __le16_to_cpu(data[i]));
+ 
+ 	num = phy->bp_num;
+ 	for (i = 0; i < num; i++)
+ 		sram_write(tp, __le16_to_cpu(phy->bp[i].addr), __le16_to_cpu(phy->bp[i].data));
+ 
+ 	if (phy->bp_num && phy->bp_en.addr)
+ 		sram_write(tp, __le16_to_cpu(phy->bp_en.addr), __le16_to_cpu(phy->bp_en.data));
+ 
+ 	dev_dbg(&tp->intf->dev, "successfully applied %s\n", phy->info);
+ }
+ 
++>>>>>>> b24edca30953 (r8152: sync ocp base)
  static void rtl8152_fw_phy_nc_apply(struct r8152 *tp, struct fw_phy_nc *phy)
  {
  	u16 mode_reg, bp_index;
@@@ -5889,9 -8516,10 +6046,10 @@@ static int rtl8152_reset_resume(struct 
  	struct r8152 *tp = usb_get_intfdata(intf);
  
  	clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+ 	rtl_reset_ocp_base(tp);
  	tp->rtl_ops.init(tp);
  	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
 -	set_ethernet_addr(tp, true);
 +	set_ethernet_addr(tp);
  	return rtl8152_resume(intf);
  }
  
* Unmerged path drivers/net/usb/r8152.c
