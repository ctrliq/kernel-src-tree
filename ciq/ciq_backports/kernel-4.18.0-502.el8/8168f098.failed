arm64: entry: split bad stack entry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit 8168f098867f6584295ea408c683f61e945c6ff1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/8168f098.failed

We'd like to keep all the entry sequencing in entry-common.c, as this
will allow us to ensure this is consistent, and free from any unsound
instrumentation.

Currently handle_bad_stack() performs the NMI entry sequence in traps.c.
Let's split the low-level entry sequence from the reporting, moving the
former to entry-common.c and keeping the latter in traps.c. To make it
clear that reporting function never returns, it is renamed to
panic_bad_stack().

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Acked-by: Marc Zyngier <maz@kernel.org>
	Reviewed-by: Joey Gouly <joey.gouly@arm.com>
	Cc: James Morse <james.morse@arm.com>
	Cc: Will Deacon <will@kernel.org>
Link: https://lore.kernel.org/r/20210607094624.34689-17-mark.rutland@arm.com
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 8168f098867f6584295ea408c683f61e945c6ff1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/exception.h
#	arch/arm64/kernel/traps.c
diff --cc arch/arm64/include/asm/exception.h
index acd3d9be4846,0113b9242b67..000000000000
--- a/arch/arm64/include/asm/exception.h
+++ b/arch/arm64/include/asm/exception.h
@@@ -42,12 -31,28 +42,36 @@@ static inline u32 disr_to_esr(u64 disr
  	return esr;
  }
  
++<<<<<<< HEAD
 +asmlinkage void el1_sync_handler(struct pt_regs *regs);
 +asmlinkage void el0_sync_handler(struct pt_regs *regs);
 +asmlinkage void el0_sync_compat_handler(struct pt_regs *regs);
++=======
+ asmlinkage void handle_bad_stack(struct pt_regs *regs);
+ 
+ asmlinkage void el1t_64_sync_handler(struct pt_regs *regs);
+ asmlinkage void el1t_64_irq_handler(struct pt_regs *regs);
+ asmlinkage void el1t_64_fiq_handler(struct pt_regs *regs);
+ asmlinkage void el1t_64_error_handler(struct pt_regs *regs);
+ 
+ asmlinkage void el1h_64_sync_handler(struct pt_regs *regs);
+ asmlinkage void el1h_64_irq_handler(struct pt_regs *regs);
+ asmlinkage void el1h_64_fiq_handler(struct pt_regs *regs);
+ asmlinkage void el1h_64_error_handler(struct pt_regs *regs);
+ 
+ asmlinkage void el0t_64_sync_handler(struct pt_regs *regs);
+ asmlinkage void el0t_64_irq_handler(struct pt_regs *regs);
+ asmlinkage void el0t_64_fiq_handler(struct pt_regs *regs);
+ asmlinkage void el0t_64_error_handler(struct pt_regs *regs);
+ 
+ asmlinkage void el0t_32_sync_handler(struct pt_regs *regs);
+ asmlinkage void el0t_32_irq_handler(struct pt_regs *regs);
+ asmlinkage void el0t_32_fiq_handler(struct pt_regs *regs);
+ asmlinkage void el0t_32_error_handler(struct pt_regs *regs);
++>>>>>>> 8168f098867f (arm64: entry: split bad stack entry)
  
 +asmlinkage void noinstr enter_el1_irq_or_nmi(struct pt_regs *regs);
 +asmlinkage void noinstr exit_el1_irq_or_nmi(struct pt_regs *regs);
  asmlinkage void call_on_irq_stack(struct pt_regs *regs,
  				  void (*func)(struct pt_regs *));
  asmlinkage void enter_from_user_mode(void);
@@@ -67,4 -74,7 +91,10 @@@ void do_cp15instr(unsigned int esr, str
  void do_el0_svc(struct pt_regs *regs);
  void do_el0_svc_compat(struct pt_regs *regs);
  void do_ptrauth_fault(struct pt_regs *regs, unsigned int esr);
++<<<<<<< HEAD
++=======
+ void do_serror(struct pt_regs *regs, unsigned int esr);
+ 
+ void panic_bad_stack(struct pt_regs *regs, unsigned int esr, unsigned long far);
++>>>>>>> 8168f098867f (arm64: entry: split bad stack entry)
  #endif	/* __ASM_EXCEPTION_H */
diff --cc arch/arm64/kernel/traps.c
index af27331eeca1,af941996eb5f..000000000000
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@@ -857,13 -763,11 +857,20 @@@ void bad_el0_sync(struct pt_regs *regs
  DEFINE_PER_CPU(unsigned long [OVERFLOW_STACK_SIZE/sizeof(long)], overflow_stack)
  	__aligned(16);
  
++<<<<<<< HEAD
 +asmlinkage void handle_bad_stack(struct pt_regs *regs)
++=======
+ void panic_bad_stack(struct pt_regs *regs, unsigned int esr, unsigned long far)
++>>>>>>> 8168f098867f (arm64: entry: split bad stack entry)
  {
  	unsigned long tsk_stk = (unsigned long)current->stack;
  	unsigned long irq_stk = (unsigned long)this_cpu_read(irq_stack_ptr);
  	unsigned long ovf_stk = (unsigned long)this_cpu_ptr(overflow_stack);
++<<<<<<< HEAD
 +	unsigned int esr = read_sysreg(esr_el1);
 +	unsigned long far = read_sysreg(far_el1);
++=======
++>>>>>>> 8168f098867f (arm64: entry: split bad stack entry)
  
  	console_verbose();
  	pr_emerg("Insufficient stack space to handle exception!");
* Unmerged path arch/arm64/include/asm/exception.h
diff --git a/arch/arm64/kernel/entry-common.c b/arch/arm64/kernel/entry-common.c
index c764ba2d11d7..ef2b39b4074a 100644
--- a/arch/arm64/kernel/entry-common.c
+++ b/arch/arm64/kernel/entry-common.c
@@ -414,3 +414,14 @@ asmlinkage void noinstr el0_sync_compat_handler(struct pt_regs *regs)
 	}
 }
 #endif /* CONFIG_COMPAT */
+
+#ifdef CONFIG_VMAP_STACK
+asmlinkage void noinstr handle_bad_stack(struct pt_regs *regs)
+{
+	unsigned int esr = read_sysreg(esr_el1);
+	unsigned long far = read_sysreg(far_el1);
+
+	arm64_enter_nmi(regs);
+	panic_bad_stack(regs, esr, far);
+}
+#endif /* CONFIG_VMAP_STACK */
* Unmerged path arch/arm64/kernel/traps.c
