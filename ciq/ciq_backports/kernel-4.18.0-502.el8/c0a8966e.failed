net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Antoine Tenart <atenart@kernel.org>
commit c0a8966e2bc7d31f77a7246947ebc09c1ff06066
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/c0a8966e.failed

When using IPv4/TCP, skb->hash comes from sk->sk_txhash except in
TIME_WAIT and SYN_RECV where it's not set in the reply skb from
ip_send_unicast_reply. Those packets will have a mismatched hash with
others from the same flow as their hashes will be 0. IPv6 does not have
the same issue as the hash is set from the socket txhash in those cases.

This commits sets the hash in the reply skb from ip_send_unicast_reply,
which makes the IPv4 code behaving like IPv6.

	Signed-off-by: Antoine Tenart <atenart@kernel.org>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit c0a8966e2bc7d31f77a7246947ebc09c1ff06066)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
#	net/ipv4/ip_output.c
#	net/ipv4/tcp_ipv4.c
diff --cc include/net/ip.h
index ae4ffc8dceb1,2982dd13cf16..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -236,7 -286,7 +236,11 @@@ void ip_send_unicast_reply(struct sock 
  			   const struct ip_options *sopt,
  			   __be32 daddr, __be32 saddr,
  			   const struct ip_reply_arg *arg,
++<<<<<<< HEAD
 +			   unsigned int len);
++=======
+ 			   unsigned int len, u64 transmit_time, u32 txhash);
++>>>>>>> c0a8966e2bc7 (net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV)
  
  #define IP_INC_STATS(net, field)	SNMP_INC_STATS64((net)->mib.ip_statistics, field)
  #define __IP_INC_STATS(net, field)	__SNMP_INC_STATS64((net)->mib.ip_statistics, field)
diff --cc net/ipv4/ip_output.c
index c5e21015cfc0,244fb9365d87..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -1571,7 -1570,7 +1571,11 @@@ void ip_send_unicast_reply(struct sock 
  			   const struct ip_options *sopt,
  			   __be32 daddr, __be32 saddr,
  			   const struct ip_reply_arg *arg,
++<<<<<<< HEAD
 +			   unsigned int len)
++=======
+ 			   unsigned int len, u64 transmit_time, u32 txhash)
++>>>>>>> c0a8966e2bc7 (net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV)
  {
  	struct ip_options_data replyopts;
  	struct ipcm_cookie ipc;
@@@ -1633,6 -1632,9 +1637,12 @@@
  			  arg->csumoffset) = csum_fold(csum_add(nskb->csum,
  								arg->csum));
  		nskb->ip_summed = CHECKSUM_NONE;
++<<<<<<< HEAD
++=======
+ 		nskb->mono_delivery_time = !!transmit_time;
+ 		if (txhash)
+ 			skb_set_hash(nskb, txhash, PKT_HASH_TYPE_L4);
++>>>>>>> c0a8966e2bc7 (net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV)
  		ip_push_pending_frames(sk, &fl4);
  	}
  out:
diff --cc net/ipv4/tcp_ipv4.c
index 4498f4203490,a50bd782f91f..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -675,8 -689,10 +675,12 @@@ static void tcp_v4_send_reset(const str
  	int genhash;
  	struct sock *sk1 = NULL;
  #endif
 -	u64 transmit_time = 0;
 -	struct sock *ctl_sk;
  	struct net *net;
++<<<<<<< HEAD
 +	struct sock *ctl_sk;
++=======
+ 	u32 txhash = 0;
++>>>>>>> c0a8966e2bc7 (net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV)
  
  	/* Never send a reset in response to a reset. */
  	if (th->rst)
@@@ -795,16 -821,29 +799,34 @@@
  	arg.tos = ip_hdr(skb)->tos;
  	arg.uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);
  	local_bh_disable();
 -	ctl_sk = this_cpu_read(ipv4_tcp_sk);
 -	sock_net_set(ctl_sk, net);
 -	if (sk) {
 +	ctl_sk = *this_cpu_ptr(net->ipv4.tcp_sk);
 +	if (sk)
  		ctl_sk->sk_mark = (sk->sk_state == TCP_TIME_WAIT) ?
  				   inet_twsk(sk)->tw_mark : sk->sk_mark;
++<<<<<<< HEAD
 +	ip_send_unicast_reply(ctl_sk,
 +			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
 +			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
 +			      &arg, arg.iov[0].iov_len);
++=======
+ 		ctl_sk->sk_priority = (sk->sk_state == TCP_TIME_WAIT) ?
+ 				   inet_twsk(sk)->tw_priority : sk->sk_priority;
+ 		transmit_time = tcp_transmit_time(sk);
+ 		xfrm_sk_clone_policy(ctl_sk, sk);
+ 		txhash = (sk->sk_state == TCP_TIME_WAIT) ?
+ 			 inet_twsk(sk)->tw_txhash : sk->sk_txhash;
+ 	} else {
+ 		ctl_sk->sk_mark = 0;
+ 		ctl_sk->sk_priority = 0;
+ 	}
+ 	ip_send_unicast_reply(ctl_sk,
+ 			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
+ 			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
+ 			      &arg, arg.iov[0].iov_len,
+ 			      transmit_time, txhash);
++>>>>>>> c0a8966e2bc7 (net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV)
  
 -	xfrm_sk_free_policy(ctl_sk);
 -	sock_net_set(ctl_sk, &init_net);
 +	ctl_sk->sk_mark = 0;
  	__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);
  	__TCP_INC_STATS(net, TCP_MIB_OUTRSTS);
  	local_bh_enable();
@@@ -894,9 -937,10 +916,14 @@@ static void tcp_v4_send_ack(const struc
  	ip_send_unicast_reply(ctl_sk,
  			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
  			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
++<<<<<<< HEAD
 +			      &arg, arg.iov[0].iov_len);
++=======
+ 			      &arg, arg.iov[0].iov_len,
+ 			      transmit_time, txhash);
++>>>>>>> c0a8966e2bc7 (net: ipv4: use consistent txhash in TIME_WAIT and SYN_RECV)
  
 -	sock_net_set(ctl_sk, &init_net);
 +	ctl_sk->sk_mark = 0;
  	__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);
  	local_bh_enable();
  }
@@@ -943,9 -990,9 +971,9 @@@ static void tcp_v4_reqsk_send_ack(cons
  			tcp_time_stamp_raw() + tcp_rsk(req)->ts_off,
  			req->ts_recent,
  			0,
 -			tcp_md5_do_lookup(sk, l3index, addr, AF_INET),
 +			tcp_md5_do_lookup(sk, addr, AF_INET),
  			inet_rsk(req)->no_srccheck ? IP_REPLY_ARG_NOSRCCHECK : 0,
- 			ip_hdr(skb)->tos);
+ 			ip_hdr(skb)->tos, tcp_rsk(req)->txhash);
  }
  
  /*
* Unmerged path include/net/ip.h
* Unmerged path net/ipv4/ip_output.c
* Unmerged path net/ipv4/tcp_ipv4.c
