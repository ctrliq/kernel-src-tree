net/mlx5: Add new APIs for fast update encryption key

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Jianbo Liu <jianbol@nvidia.com>
commit 204369e718e9f276bdc8677e8dbb648d3298735f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/204369e7.failed

New APIs are added to support fast update DEKs. As a pool is created
for each key purpose (type), one pair of pool APIs to get/put pool.
Anotehr pair of DEKs APIs is to get DEK object from pool and update it
with user key, or free it back to the pool. As The bulk allocation
and destruction will be supported in later patches, old implementation
is used here.

To support these APIs, pool and dek structs are defined first. Only
small number of fields are stored in them. For example, key_purpose
and refcnt in pool struct, DEK object id in dek struct. More fields
will be added to these structs in later patches, for example, the
different bulk lists for pool struct, the bulk pointer dek struct
belongs to, and a list_entry for the list in a pool, which is used to
save keys waiting for being freed while other thread is doing sync.

Besides the creation and destruction interfaces, new one is also added
to get obj id.

Currently these APIs are planned to used by TLS only.

	Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 204369e718e9f276bdc8677e8dbb648d3298735f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
#	drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
index e995f8378df7,d1b4cc990756..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
@@@ -2,11 -2,78 +2,86 @@@
  // Copyright (c) 2019 Mellanox Technologies.
  
  #include "mlx5_core.h"
++<<<<<<< HEAD
 +#include "lib/mlx5.h"
 +
 +int mlx5_create_encryption_key(struct mlx5_core_dev *mdev,
 +			       void *key, u32 sz_bytes,
 +			       u32 key_type, u32 *p_key_id)
++=======
+ #include "lib/crypto.h"
+ 
+ #define MLX5_CRYPTO_DEK_POOLS_NUM (MLX5_ACCEL_OBJ_TYPE_KEY_NUM - 1)
+ #define type2idx(type) ((type) - 1)
+ 
+ struct mlx5_crypto_dek_pool {
+ 	struct mlx5_core_dev *mdev;
+ 	u32 key_purpose;
+ };
+ 
+ struct mlx5_crypto_dek_priv {
+ 	struct mlx5_core_dev *mdev;
+ 	int log_dek_obj_range;
+ };
+ 
+ struct mlx5_crypto_dek {
+ 	u32 obj_id;
+ };
+ 
+ u32 mlx5_crypto_dek_get_id(struct mlx5_crypto_dek *dek)
+ {
+ 	return dek->obj_id;
+ }
+ 
+ static int mlx5_crypto_dek_get_key_sz(struct mlx5_core_dev *mdev,
+ 				      u32 sz_bytes, u8 *key_sz_p)
+ {
+ 	u32 sz_bits = sz_bytes * BITS_PER_BYTE;
+ 
+ 	switch (sz_bits) {
+ 	case 128:
+ 		*key_sz_p = MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_128;
+ 		break;
+ 	case 256:
+ 		*key_sz_p = MLX5_GENERAL_OBJECT_TYPE_ENCRYPTION_KEY_KEY_SIZE_256;
+ 		break;
+ 	default:
+ 		mlx5_core_err(mdev, "Crypto offload error, invalid key size (%u bits)\n",
+ 			      sz_bits);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_crypto_dek_fill_key(struct mlx5_core_dev *mdev, u8 *key_obj,
+ 				    const void *key, u32 sz_bytes)
+ {
+ 	void *dst;
+ 	u8 key_sz;
+ 	int err;
+ 
+ 	err = mlx5_crypto_dek_get_key_sz(mdev, sz_bytes, &key_sz);
+ 	if (err)
+ 		return err;
+ 
+ 	MLX5_SET(encryption_key_obj, key_obj, key_size, key_sz);
+ 
+ 	if (sz_bytes == 16)
+ 		/* For key size of 128b the MSBs are reserved. */
+ 		dst = MLX5_ADDR_OF(encryption_key_obj, key_obj, key[1]);
+ 	else
+ 		dst = MLX5_ADDR_OF(encryption_key_obj, key_obj, key);
+ 
+ 	memcpy(dst, key, sz_bytes);
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_crypto_create_dek_key(struct mlx5_core_dev *mdev,
+ 				      const void *key, u32 sz_bytes,
+ 				      u32 key_purpose, u32 *p_key_id)
++>>>>>>> 204369e718e9 (net/mlx5: Add new APIs for fast update encryption key)
  {
  	u32 in[MLX5_ST_SZ_DW(create_encryption_key_in)] = {};
  	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
@@@ -46,8 -90,15 +121,14 @@@
  		 MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
  	MLX5_SET(general_obj_in_cmd_hdr, in, obj_type,
  		 MLX5_GENERAL_OBJECT_TYPES_ENCRYPTION_KEY);
++<<<<<<< HEAD
++=======
+ 
+ 	obj = MLX5_ADDR_OF(create_encryption_key_in, in, encryption_key_object);
+ 	MLX5_SET(encryption_key_obj, obj, key_purpose, key_purpose);
++>>>>>>> 204369e718e9 (net/mlx5: Add new APIs for fast update encryption key)
  	MLX5_SET(encryption_key_obj, obj, pd, mdev->mlx5e_res.hw_objs.pdn);
  
 -	err = mlx5_crypto_dek_fill_key(mdev, obj, key, sz_bytes);
 -	if (err)
 -		return err;
 -
  	err = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));
  	if (!err)
  		*p_key_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);
@@@ -71,3 -122,97 +152,100 @@@ static void mlx5_crypto_destroy_dek_key
  
  	mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));
  }
++<<<<<<< HEAD
++=======
+ 
+ int mlx5_create_encryption_key(struct mlx5_core_dev *mdev,
+ 			       const void *key, u32 sz_bytes,
+ 			       u32 key_type, u32 *p_key_id)
+ {
+ 	return mlx5_crypto_create_dek_key(mdev, key, sz_bytes, key_type, p_key_id);
+ }
+ 
+ void mlx5_destroy_encryption_key(struct mlx5_core_dev *mdev, u32 key_id)
+ {
+ 	mlx5_crypto_destroy_dek_key(mdev, key_id);
+ }
+ 
+ struct mlx5_crypto_dek *mlx5_crypto_dek_create(struct mlx5_crypto_dek_pool *dek_pool,
+ 					       const void *key, u32 sz_bytes)
+ {
+ 	struct mlx5_core_dev *mdev = dek_pool->mdev;
+ 	u32 key_purpose = dek_pool->key_purpose;
+ 	struct mlx5_crypto_dek *dek;
+ 	int err;
+ 
+ 	dek = kzalloc(sizeof(*dek), GFP_KERNEL);
+ 	if (!dek)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	err = mlx5_crypto_create_dek_key(mdev, key, sz_bytes,
+ 					 key_purpose, &dek->obj_id);
+ 	if (err) {
+ 		kfree(dek);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return dek;
+ }
+ 
+ void mlx5_crypto_dek_destroy(struct mlx5_crypto_dek_pool *dek_pool,
+ 			     struct mlx5_crypto_dek *dek)
+ {
+ 	struct mlx5_core_dev *mdev = dek_pool->mdev;
+ 
+ 	mlx5_crypto_destroy_dek_key(mdev, dek->obj_id);
+ 	kfree(dek);
+ }
+ 
+ struct mlx5_crypto_dek_pool *
+ mlx5_crypto_dek_pool_create(struct mlx5_core_dev *mdev, int key_purpose)
+ {
+ 	struct mlx5_crypto_dek_pool *pool;
+ 
+ 	pool = kzalloc(sizeof(*pool), GFP_KERNEL);
+ 	if (!pool)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pool->mdev = mdev;
+ 	pool->key_purpose = key_purpose;
+ 
+ 	return pool;
+ }
+ 
+ void mlx5_crypto_dek_pool_destroy(struct mlx5_crypto_dek_pool *pool)
+ {
+ 	kfree(pool);
+ }
+ 
+ void mlx5_crypto_dek_cleanup(struct mlx5_crypto_dek_priv *dek_priv)
+ {
+ 	if (!dek_priv)
+ 		return;
+ 
+ 	kfree(dek_priv);
+ }
+ 
+ struct mlx5_crypto_dek_priv *mlx5_crypto_dek_init(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_crypto_dek_priv *dek_priv;
+ 
+ 	if (!MLX5_CAP_CRYPTO(mdev, log_dek_max_alloc))
+ 		return NULL;
+ 
+ 	dek_priv = kzalloc(sizeof(*dek_priv), GFP_KERNEL);
+ 	if (!dek_priv)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	dek_priv->mdev = mdev;
+ 	dek_priv->log_dek_obj_range = min_t(int, 12,
+ 					    MLX5_CAP_CRYPTO(mdev, log_dek_max_alloc));
+ 
+ 	mlx5_core_dbg(mdev, "Crypto DEK enabled, %d deks per alloc (max %d), total %d\n",
+ 		      1 << dek_priv->log_dek_obj_range,
+ 		      1 << MLX5_CAP_CRYPTO(mdev, log_dek_max_alloc),
+ 		      1 << MLX5_CAP_CRYPTO(mdev, log_max_num_deks));
+ 
+ 	return dek_priv;
+ }
++>>>>>>> 204369e718e9 (net/mlx5: Add new APIs for fast update encryption key)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/crypto.h
