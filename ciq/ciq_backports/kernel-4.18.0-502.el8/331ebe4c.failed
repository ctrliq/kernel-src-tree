x86/resctrl: Walk the resctrl schema list instead of an arch list

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit 331ebe4c43496cdc7f8d9a32d4ef59300b748435
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/331ebe4c.failed

When parsing a schema configuration value from user-space, resctrl walks
the architectures rdt_resources_all[] array to find a matching struct
rdt_resource.

Once the CDP resources are merged there will be one resource in use
by two schemata. Anything walking rdt_resources_all[] on behalf of a
user-space request should walk the list of struct resctrl_schema
instead.

Change the users of for_each_alloc_enabled_rdt_resource() to walk the
schema instead. Schemata were only created for alloc_enabled resources
so these two lists are currently equivalent.

schemata_list_create() and rdt_kill_sb() are ignored. The first
creates the schema list, and will eventually loop over the resource
indexes using an arch helper to retrieve the resource. rdt_kill_sb()
will eventually make use of an arch 'reset everything' helper.

After the filesystem code is moved, rdtgroup_pseudo_locked_in_hierarchy()
remains part of the x86 specific hooks to support pseudo lock. This
code walks each domain, and still does this after the separate resources
are merged.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <jamie@nuviainc.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lkml.kernel.org/r/20210728170637.25610-7-james.morse@arm.com
(cherry picked from commit 331ebe4c43496cdc7f8d9a32d4ef59300b748435)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/ctrlmondata.c
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
diff --cc arch/x86/kernel/cpu/resctrl/ctrlmondata.c
index 84ba438cc344,405b99d31ef9..000000000000
--- a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
+++ b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
@@@ -292,10 -286,14 +292,21 @@@ done
  static int rdtgroup_parse_resource(char *resname, char *tok,
  				   struct rdtgroup *rdtgrp)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r;
 +
 +	for_each_alloc_enabled_rdt_resource(r) {
 +		if (!strcmp(resname, r->name) && rdtgrp->closid < r->num_closid)
++=======
+ 	struct rdt_hw_resource *hw_res;
+ 	struct resctrl_schema *s;
+ 	struct rdt_resource *r;
+ 
+ 	list_for_each_entry(s, &resctrl_schema_all, list) {
+ 		r = s->res;
+ 		hw_res = resctrl_to_arch_res(s->res);
+ 		if (!strcmp(resname, r->name) && rdtgrp->closid < hw_res->num_closid)
++>>>>>>> 331ebe4c4349 (x86/resctrl: Walk the resctrl schema list instead of an arch list)
  			return parse_line(tok, r, rdtgrp);
  	}
  	rdt_last_cmd_printf("Unknown or unsupported resource name '%s'\n", resname);
@@@ -402,6 -404,8 +415,11 @@@ static void show_doms(struct seq_file *
  int rdtgroup_schemata_show(struct kernfs_open_file *of,
  			   struct seq_file *s, void *v)
  {
++<<<<<<< HEAD
++=======
+ 	struct rdt_hw_resource *hw_res;
+ 	struct resctrl_schema *schema;
++>>>>>>> 331ebe4c4349 (x86/resctrl: Walk the resctrl schema list instead of an arch list)
  	struct rdtgroup *rdtgrp;
  	struct rdt_resource *r;
  	int ret = 0;
@@@ -425,8 -431,9 +445,14 @@@
  			}
  		} else {
  			closid = rdtgrp->closid;
++<<<<<<< HEAD
 +			for_each_alloc_enabled_rdt_resource(r) {
 +				if (closid < r->num_closid)
++=======
+ 			list_for_each_entry(schema, &resctrl_schema_all, list) {
+ 				hw_res = resctrl_to_arch_res(schema->res);
+ 				if (closid < hw_res->num_closid)
++>>>>>>> 331ebe4c4349 (x86/resctrl: Walk the resctrl schema list instead of an arch list)
  					show_doms(s, r, closid);
  			}
  		}
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index fc8061800ae6,7502b7de3916..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -108,12 -103,15 +108,24 @@@ int closids_supported(void
  
  static void closid_init(void)
  {
++<<<<<<< HEAD
 +	struct rdt_resource *r;
 +	int rdt_min_closid = 32;
 +
 +	/* Compute rdt_min_closid across all resources */
 +	for_each_alloc_enabled_rdt_resource(r)
 +		rdt_min_closid = min(rdt_min_closid, r->num_closid);
++=======
+ 	struct rdt_hw_resource *hw_res;
+ 	struct resctrl_schema *s;
+ 	int rdt_min_closid = 32;
+ 
+ 	/* Compute rdt_min_closid across all resources */
+ 	list_for_each_entry(s, &resctrl_schema_all, list) {
+ 		hw_res = resctrl_to_arch_res(s->res);
+ 		rdt_min_closid = min(rdt_min_closid, hw_res->num_closid);
+ 	}
++>>>>>>> 331ebe4c4349 (x86/resctrl: Walk the resctrl schema list instead of an arch list)
  
  	closid_free_map = BIT_MASK(rdt_min_closid) - 1;
  
@@@ -1282,7 -1274,9 +1294,8 @@@ bool rdtgroup_cbm_overlaps(struct rdt_r
   */
  static bool rdtgroup_mode_test_exclusive(struct rdtgroup *rdtgrp)
  {
 -	struct rdt_hw_domain *hw_dom;
  	int closid = rdtgrp->closid;
+ 	struct resctrl_schema *s;
  	struct rdt_resource *r;
  	bool has_cache = false;
  	struct rdt_domain *d;
@@@ -1424,6 -1420,8 +1438,11 @@@ unsigned int rdtgroup_cbm_to_size(struc
  static int rdtgroup_size_show(struct kernfs_open_file *of,
  			      struct seq_file *s, void *v)
  {
++<<<<<<< HEAD
++=======
+ 	struct resctrl_schema *schema;
+ 	struct rdt_hw_domain *hw_dom;
++>>>>>>> 331ebe4c4349 (x86/resctrl: Walk the resctrl schema list instead of an arch list)
  	struct rdtgroup *rdtgrp;
  	struct rdt_resource *r;
  	struct rdt_domain *d;
* Unmerged path arch/x86/kernel/cpu/resctrl/ctrlmondata.c
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
