x86/resctrl: Calculate the index from the configuration type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit 2b8dd4ab65dad1251822fbf74fb0d5623e4eaee0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/2b8dd4ab.failed

resctrl uses cbm_idx() to map a closid to an index in the configuration
array. This is based on a multiplier and offset that are held in the
resource.

To merge the resources, the resctrl arch code needs to calculate the
index from something else, as there will only be one resource.

Decide based on the staged configuration type. This makes the static
mult and offset parameters redundant.

 [ bp: Remove superfluous brackets in get_config_index() ]

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jamie Iles <jamie@nuviainc.com>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lkml.kernel.org/r/20210728170637.25610-21-james.morse@arm.com
(cherry picked from commit 2b8dd4ab65dad1251822fbf74fb0d5623e4eaee0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/core.c
#	arch/x86/kernel/cpu/resctrl/ctrlmondata.c
#	include/linux/resctrl.h
diff --cc arch/x86/kernel/cpu/resctrl/core.c
index 916eb976301b,c6b953fe7fdf..000000000000
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@@ -65,110 -57,116 +65,206 @@@ static voi
  mba_wrmsr_amd(struct rdt_domain *d, struct msr_param *m,
  	      struct rdt_resource *r);
  
 -#define domain_init(id) LIST_HEAD_INIT(rdt_resources_all[id].r_resctrl.domains)
 +#define domain_init(id) LIST_HEAD_INIT(rdt_resources_all[id].domains)
  
 -struct rdt_hw_resource rdt_resources_all[] = {
 +struct rdt_resource rdt_resources_all[] = {
  	[RDT_RESOURCE_L3] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L3,
 +		.name			= "L3",
 +		.domains		= domain_init(RDT_RESOURCE_L3),
++=======
+ 		.conf_type			= CDP_NONE,
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L3,
+ 			.name			= "L3",
+ 			.cache_level		= 3,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L3),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		.msr_base		= MSR_IA32_L3_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 3,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 1,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
  	[RDT_RESOURCE_L3DATA] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L3DATA,
 +		.name			= "L3DATA",
 +		.domains		= domain_init(RDT_RESOURCE_L3DATA),
++=======
+ 		.conf_type			= CDP_DATA,
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L3DATA,
+ 			.name			= "L3DATA",
+ 			.cache_level		= 3,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L3DATA),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		.msr_base		= MSR_IA32_L3_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 3,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
  	[RDT_RESOURCE_L3CODE] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L3CODE,
 +		.name			= "L3CODE",
 +		.domains		= domain_init(RDT_RESOURCE_L3CODE),
++=======
+ 		.conf_type			= CDP_CODE,
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L3CODE,
+ 			.name			= "L3CODE",
+ 			.cache_level		= 3,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L3CODE),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		.msr_base		= MSR_IA32_L3_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 3,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 1,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
  	[RDT_RESOURCE_L2] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L2,
 +		.name			= "L2",
 +		.domains		= domain_init(RDT_RESOURCE_L2),
++=======
+ 		.conf_type			= CDP_NONE,
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L2,
+ 			.name			= "L2",
+ 			.cache_level		= 2,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L2),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		.msr_base		= MSR_IA32_L2_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 2,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 1,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
  	[RDT_RESOURCE_L2DATA] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L2DATA,
 +		.name			= "L2DATA",
 +		.domains		= domain_init(RDT_RESOURCE_L2DATA),
++=======
+ 		.conf_type			= CDP_DATA,
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L2DATA,
+ 			.name			= "L2DATA",
+ 			.cache_level		= 2,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L2DATA),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		.msr_base		= MSR_IA32_L2_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 2,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 0,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
  	[RDT_RESOURCE_L2CODE] =
  	{
++<<<<<<< HEAD
 +		.rid			= RDT_RESOURCE_L2CODE,
 +		.name			= "L2CODE",
 +		.domains		= domain_init(RDT_RESOURCE_L2CODE),
++=======
+ 		.conf_type			= CDP_CODE,
+ 		.r_resctrl = {
+ 			.rid			= RDT_RESOURCE_L2CODE,
+ 			.name			= "L2CODE",
+ 			.cache_level		= 2,
+ 			.cache = {
+ 				.min_cbm_bits	= 1,
+ 			},
+ 			.domains		= domain_init(RDT_RESOURCE_L2CODE),
+ 			.parse_ctrlval		= parse_cbm,
+ 			.format_str		= "%d=%0*x",
+ 			.fflags			= RFTYPE_RES_CACHE,
+ 		},
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		.msr_base		= MSR_IA32_L2_CBM_BASE,
  		.msr_update		= cat_wrmsr,
 +		.cache_level		= 2,
 +		.cache = {
 +			.min_cbm_bits	= 1,
 +			.cbm_idx_mult	= 2,
 +			.cbm_idx_offset	= 1,
 +		},
 +		.parse_ctrlval		= parse_cbm,
 +		.format_str		= "%d=%0*x",
 +		.fflags			= RFTYPE_RES_CACHE,
  	},
  	[RDT_RESOURCE_MBA] =
  	{
diff --cc arch/x86/kernel/cpu/resctrl/ctrlmondata.c
index 9a768d89de37,92d79c88b965..000000000000
--- a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
+++ b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
@@@ -244,9 -246,42 +244,46 @@@ next
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +int update_domains(struct rdt_resource *r, int closid)
 +{
++=======
+ static u32 get_config_index(u32 closid, enum resctrl_conf_type type)
+ {
+ 	switch (type) {
+ 	default:
+ 	case CDP_NONE:
+ 		return closid;
+ 	case CDP_CODE:
+ 		return closid * 2 + 1;
+ 	case CDP_DATA:
+ 		return closid * 2;
+ 	}
+ }
+ 
+ static bool apply_config(struct rdt_hw_domain *hw_dom,
+ 			 struct resctrl_staged_config *cfg, u32 idx,
+ 			 cpumask_var_t cpu_mask, bool mba_sc)
+ {
+ 	struct rdt_domain *dom = &hw_dom->d_resctrl;
+ 	u32 *dc = !mba_sc ? hw_dom->ctrl_val : hw_dom->mbps_val;
+ 
+ 	if (cfg->new_ctrl != dc[idx]) {
+ 		cpumask_set_cpu(cpumask_any(&dom->cpu_mask), cpu_mask);
+ 		dc[idx] = cfg->new_ctrl;
+ 
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ int resctrl_arch_update_domains(struct rdt_resource *r, u32 closid)
+ {
+ 	struct resctrl_staged_config *cfg;
+ 	struct rdt_hw_domain *hw_dom;
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  	struct msr_param msr_param;
 -	enum resctrl_conf_type t;
  	cpumask_var_t cpu_mask;
  	struct rdt_domain *d;
  	bool mba_sc;
@@@ -256,16 -291,21 +293,34 @@@
  	if (!zalloc_cpumask_var(&cpu_mask, GFP_KERNEL))
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	msr_param.low = closid;
 +	msr_param.high = msr_param.low + 1;
 +	msr_param.res = r;
 +
 +	mba_sc = is_mba_sc(r);
 +	list_for_each_entry(d, &r->domains, list) {
 +		dc = !mba_sc ? d->ctrl_val : d->mbps_val;
 +		if (d->have_new_ctrl && d->new_ctrl != dc[closid]) {
 +			cpumask_set_cpu(cpumask_any(&d->cpu_mask), cpu_mask);
 +			dc[closid] = d->new_ctrl;
++=======
+ 	mba_sc = is_mba_sc(r);
+ 	list_for_each_entry(d, &r->domains, list) {
+ 		hw_dom = resctrl_to_arch_dom(d);
+ 		for (t = 0; t < CDP_NUM_TYPES; t++) {
+ 			cfg = &hw_dom->d_resctrl.staged_config[t];
+ 			if (!cfg->have_new_ctrl)
+ 				continue;
+ 
+ 			idx = get_config_index(closid, t);
+ 			if (!apply_config(hw_dom, cfg, idx, cpu_mask, mba_sc))
+ 				continue;
+ 
+ 			msr_param.low = idx;
+ 			msr_param.high = msr_param.low + 1;
+ 			msr_param.res = r;
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  		}
  	}
  
@@@ -379,8 -421,21 +434,23 @@@ out
  	return ret ?: nbytes;
  }
  
 -void resctrl_arch_get_config(struct rdt_resource *r, struct rdt_domain *d,
 -			     u32 closid, enum resctrl_conf_type type, u32 *value)
 +static void show_doms(struct seq_file *s, struct rdt_resource *r, int closid)
  {
++<<<<<<< HEAD
++=======
+ 	struct rdt_hw_domain *hw_dom = resctrl_to_arch_dom(d);
+ 	u32 idx = get_config_index(closid, type);
+ 
+ 	if (!is_mba_sc(r))
+ 		*value = hw_dom->ctrl_val[idx];
+ 	else
+ 		*value = hw_dom->mbps_val[idx];
+ }
+ 
+ static void show_doms(struct seq_file *s, struct resctrl_schema *schema, int closid)
+ {
+ 	struct rdt_resource *r = schema->res;
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  	struct rdt_domain *dom;
  	bool sep = false;
  	u32 ctrl_val;
diff --cc include/linux/resctrl.h
index 9b05af9b3e28,18dd764af0dd..000000000000
--- a/include/linux/resctrl.h
+++ b/include/linux/resctrl.h
@@@ -13,4 -15,187 +13,190 @@@ int proc_resctrl_show(struct seq_file *
  
  #endif
  
++<<<<<<< HEAD
++=======
+ /**
+  * enum resctrl_conf_type - The type of configuration.
+  * @CDP_NONE:	No prioritisation, both code and data are controlled or monitored.
+  * @CDP_CODE:	Configuration applies to instruction fetches.
+  * @CDP_DATA:	Configuration applies to reads and writes.
+  */
+ enum resctrl_conf_type {
+ 	CDP_NONE,
+ 	CDP_CODE,
+ 	CDP_DATA,
+ };
+ 
+ #define CDP_NUM_TYPES	(CDP_DATA + 1)
+ 
+ /**
+  * struct resctrl_staged_config - parsed configuration to be applied
+  * @new_ctrl:		new ctrl value to be loaded
+  * @have_new_ctrl:	whether the user provided new_ctrl is valid
+  */
+ struct resctrl_staged_config {
+ 	u32			new_ctrl;
+ 	bool			have_new_ctrl;
+ };
+ 
+ /**
+  * struct rdt_domain - group of CPUs sharing a resctrl resource
+  * @list:		all instances of this resource
+  * @id:			unique id for this instance
+  * @cpu_mask:		which CPUs share this resource
+  * @rmid_busy_llc:	bitmap of which limbo RMIDs are above threshold
+  * @mbm_total:		saved state for MBM total bandwidth
+  * @mbm_local:		saved state for MBM local bandwidth
+  * @mbm_over:		worker to periodically read MBM h/w counters
+  * @cqm_limbo:		worker to periodically read CQM h/w counters
+  * @mbm_work_cpu:	worker CPU for MBM h/w counters
+  * @cqm_work_cpu:	worker CPU for CQM h/w counters
+  * @plr:		pseudo-locked region (if any) associated with domain
+  * @staged_config:	parsed configuration to be applied
+  */
+ struct rdt_domain {
+ 	struct list_head		list;
+ 	int				id;
+ 	struct cpumask			cpu_mask;
+ 	unsigned long			*rmid_busy_llc;
+ 	struct mbm_state		*mbm_total;
+ 	struct mbm_state		*mbm_local;
+ 	struct delayed_work		mbm_over;
+ 	struct delayed_work		cqm_limbo;
+ 	int				mbm_work_cpu;
+ 	int				cqm_work_cpu;
+ 	struct pseudo_lock_region	*plr;
+ 	struct resctrl_staged_config	staged_config[CDP_NUM_TYPES];
+ };
+ 
+ /**
+  * struct resctrl_cache - Cache allocation related data
+  * @cbm_len:		Length of the cache bit mask
+  * @min_cbm_bits:	Minimum number of consecutive bits to be set
+  * @shareable_bits:	Bitmask of shareable resource with other
+  *			executing entities
+  * @arch_has_sparse_bitmaps:	True if a bitmap like f00f is valid.
+  * @arch_has_empty_bitmaps:	True if the '0' bitmap is valid.
+  * @arch_has_per_cpu_cfg:	True if QOS_CFG register for this cache
+  *				level has CPU scope.
+  */
+ struct resctrl_cache {
+ 	unsigned int	cbm_len;
+ 	unsigned int	min_cbm_bits;
+ 	unsigned int	shareable_bits;
+ 	bool		arch_has_sparse_bitmaps;
+ 	bool		arch_has_empty_bitmaps;
+ 	bool		arch_has_per_cpu_cfg;
+ };
+ 
+ /**
+  * enum membw_throttle_mode - System's memory bandwidth throttling mode
+  * @THREAD_THROTTLE_UNDEFINED:	Not relevant to the system
+  * @THREAD_THROTTLE_MAX:	Memory bandwidth is throttled at the core
+  *				always using smallest bandwidth percentage
+  *				assigned to threads, aka "max throttling"
+  * @THREAD_THROTTLE_PER_THREAD:	Memory bandwidth is throttled at the thread
+  */
+ enum membw_throttle_mode {
+ 	THREAD_THROTTLE_UNDEFINED = 0,
+ 	THREAD_THROTTLE_MAX,
+ 	THREAD_THROTTLE_PER_THREAD,
+ };
+ 
+ /**
+  * struct resctrl_membw - Memory bandwidth allocation related data
+  * @min_bw:		Minimum memory bandwidth percentage user can request
+  * @bw_gran:		Granularity at which the memory bandwidth is allocated
+  * @delay_linear:	True if memory B/W delay is in linear scale
+  * @arch_needs_linear:	True if we can't configure non-linear resources
+  * @throttle_mode:	Bandwidth throttling mode when threads request
+  *			different memory bandwidths
+  * @mba_sc:		True if MBA software controller(mba_sc) is enabled
+  * @mb_map:		Mapping of memory B/W percentage to memory B/W delay
+  */
+ struct resctrl_membw {
+ 	u32				min_bw;
+ 	u32				bw_gran;
+ 	u32				delay_linear;
+ 	bool				arch_needs_linear;
+ 	enum membw_throttle_mode	throttle_mode;
+ 	bool				mba_sc;
+ 	u32				*mb_map;
+ };
+ 
+ struct rdt_parse_data;
+ struct resctrl_schema;
+ 
+ /**
+  * struct rdt_resource - attributes of a resctrl resource
+  * @rid:		The index of the resource
+  * @alloc_enabled:	Is allocation enabled on this machine
+  * @mon_enabled:	Is monitoring enabled for this feature
+  * @alloc_capable:	Is allocation available on this machine
+  * @mon_capable:	Is monitor feature available on this machine
+  * @num_rmid:		Number of RMIDs available
+  * @cache_level:	Which cache level defines scope of this resource
+  * @cache:		Cache allocation related data
+  * @membw:		If the component has bandwidth controls, their properties.
+  * @domains:		All domains for this resource
+  * @name:		Name to use in "schemata" file.
+  * @data_width:		Character width of data when displaying
+  * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
+  * @format_str:		Per resource format string to show domain value
+  * @parse_ctrlval:	Per resource function pointer to parse control values
+  * @evt_list:		List of monitoring events
+  * @fflags:		flags to choose base and info files
+  * @cdp_capable:	Is the CDP feature available on this resource
+  */
+ struct rdt_resource {
+ 	int			rid;
+ 	bool			alloc_enabled;
+ 	bool			mon_enabled;
+ 	bool			alloc_capable;
+ 	bool			mon_capable;
+ 	int			num_rmid;
+ 	int			cache_level;
+ 	struct resctrl_cache	cache;
+ 	struct resctrl_membw	membw;
+ 	struct list_head	domains;
+ 	char			*name;
+ 	int			data_width;
+ 	u32			default_ctrl;
+ 	const char		*format_str;
+ 	int			(*parse_ctrlval)(struct rdt_parse_data *data,
+ 						 struct resctrl_schema *s,
+ 						 struct rdt_domain *d);
+ 	struct list_head	evt_list;
+ 	unsigned long		fflags;
+ 	bool			cdp_capable;
+ };
+ 
+ /**
+  * struct resctrl_schema - configuration abilities of a resource presented to
+  *			   user-space
+  * @list:	Member of resctrl_schema_all.
+  * @name:	The name to use in the "schemata" file.
+  * @conf_type:	Whether this schema is specific to code/data.
+  * @res:	The resource structure exported by the architecture to describe
+  *		the hardware that is configured by this schema.
+  * @num_closid:	The number of closid that can be used with this schema. When
+  *		features like CDP are enabled, this will be lower than the
+  *		hardware supports for the resource.
+  */
+ struct resctrl_schema {
+ 	struct list_head		list;
+ 	char				name[8];
+ 	enum resctrl_conf_type		conf_type;
+ 	struct rdt_resource		*res;
+ 	u32				num_closid;
+ };
+ 
+ /* The number of closid supported by this resource regardless of CDP */
+ u32 resctrl_arch_get_num_closid(struct rdt_resource *r);
+ int resctrl_arch_update_domains(struct rdt_resource *r, u32 closid);
+ void resctrl_arch_get_config(struct rdt_resource *r, struct rdt_domain *d,
+ 			     u32 closid, enum resctrl_conf_type type,
+ 			     u32 *value);
+ 
++>>>>>>> 2b8dd4ab65da (x86/resctrl: Calculate the index from the configuration type)
  #endif /* _RESCTRL_H */
* Unmerged path arch/x86/kernel/cpu/resctrl/core.c
* Unmerged path arch/x86/kernel/cpu/resctrl/ctrlmondata.c
* Unmerged path include/linux/resctrl.h
