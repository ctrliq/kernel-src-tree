x86/resctrl: Expand resctrl_arch_update_domains()'s msr_param range

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author James Morse <james.morse@arm.com>
commit 327364d5b6b6f8c89d2d6253a986d80323512890
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/327364d5.failed

resctrl_arch_update_domains() specifies the one closid that has been
modified and needs copying to the hardware.

resctrl_arch_update_domains() takes a struct rdt_resource and a closid
as arguments, but copies all the staged configurations for that closid
into the ctrl_val[] array.

resctrl_arch_update_domains() is called once per schema, but once the
resources and domains are merged, the second call of a L2CODE/L2DATA
pair will find no staged configurations, as they were previously
applied. The msr_param of the first call only has one index, so would
only have update the hardware for the last staged configuration.

To avoid a second round of IPIs when changing L2CODE and L2DATA in one
go, expand the range of the msr_param if multiple staged configurations
are found.

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
	Tested-by: Babu Moger <babu.moger@amd.com>
Link: https://lkml.kernel.org/r/20210728170637.25610-24-james.morse@arm.com
(cherry picked from commit 327364d5b6b6f8c89d2d6253a986d80323512890)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/ctrlmondata.c
diff --cc arch/x86/kernel/cpu/resctrl/ctrlmondata.c
index 9a768d89de37,a487cf7ff04e..000000000000
--- a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
+++ b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
@@@ -256,16 -291,27 +256,38 @@@ int update_domains(struct rdt_resource 
  	if (!zalloc_cpumask_var(&cpu_mask, GFP_KERNEL))
  		return -ENOMEM;
  
 +	msr_param.low = closid;
 +	msr_param.high = msr_param.low + 1;
 +	msr_param.res = r;
 +
  	mba_sc = is_mba_sc(r);
+ 	msr_param.res = NULL;
  	list_for_each_entry(d, &r->domains, list) {
++<<<<<<< HEAD
 +		dc = !mba_sc ? d->ctrl_val : d->mbps_val;
 +		if (d->have_new_ctrl && d->new_ctrl != dc[closid]) {
 +			cpumask_set_cpu(cpumask_any(&d->cpu_mask), cpu_mask);
 +			dc[closid] = d->new_ctrl;
++=======
+ 		hw_dom = resctrl_to_arch_dom(d);
+ 		for (t = 0; t < CDP_NUM_TYPES; t++) {
+ 			cfg = &hw_dom->d_resctrl.staged_config[t];
+ 			if (!cfg->have_new_ctrl)
+ 				continue;
+ 
+ 			idx = get_config_index(closid, t);
+ 			if (!apply_config(hw_dom, cfg, idx, cpu_mask, mba_sc))
+ 				continue;
+ 
+ 			if (!msr_param.res) {
+ 				msr_param.low = idx;
+ 				msr_param.high = msr_param.low + 1;
+ 				msr_param.res = r;
+ 			} else {
+ 				msr_param.low = min(msr_param.low, idx);
+ 				msr_param.high = max(msr_param.high, idx + 1);
+ 			}
++>>>>>>> 327364d5b6b6 (x86/resctrl: Expand resctrl_arch_update_domains()'s msr_param range)
  		}
  	}
  
* Unmerged path arch/x86/kernel/cpu/resctrl/ctrlmondata.c
