net/mlx5e: Convert ethtool_steering member of flow_steering struct to pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-502.el8
commit-author Lama Kayal <lkayal@nvidia.com>
commit c7eafc5ed0688812f7b59094107d664893911c0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-502.el8/c7eafc5e.failed

Convert mlx5e_ethtool_steering member of mlx5e_flow_steering to a
pointer, and allocate dynamically for each profile at flow_steering
init.

	Signed-off-by: Lama Kayal <lkayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit c7eafc5ed0688812f7b59094107d664893911c0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 6768f21c4eb1,eef674cf0f1d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -41,6 -41,34 +41,37 @@@
  #include "lib/mpfs.h"
  #include "en/ptp.h"
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_flow_steering {
+ 	struct work_struct		set_rx_mode_work;
+ 	bool				state_destroy;
+ 	bool				vlan_strip_disable;
+ 	struct mlx5_core_dev		*mdev;
+ 	struct net_device		*netdev;
+ 	struct mlx5_flow_namespace      *ns;
+ 	struct mlx5_flow_namespace      *egress_ns;
+ #ifdef CONFIG_MLX5_EN_RXNFC
+ 	struct mlx5e_ethtool_steering   *ethtool;
+ #endif
+ 	struct mlx5e_tc_table           *tc;
+ 	struct mlx5e_promisc_table      promisc;
+ 	struct mlx5e_vlan_table         *vlan;
+ 	struct mlx5e_l2_table           l2;
+ 	struct mlx5_ttc_table           *ttc;
+ 	struct mlx5_ttc_table           *inner_ttc;
+ #ifdef CONFIG_MLX5_EN_ARFS
+ 	struct mlx5e_arfs_tables       *arfs;
+ #endif
+ #ifdef CONFIG_MLX5_EN_TLS
+ 	struct mlx5e_accel_fs_tcp      *accel_tcp;
+ #endif
+ 	struct mlx5e_fs_udp            *udp;
+ 	struct mlx5e_fs_any            *any;
+ 	struct mlx5e_ptp_fs            *ptp_fs;
+ };
+ 
++>>>>>>> c7eafc5ed068 (net/mlx5e: Convert ethtool_steering member of flow_steering struct to pointer)
  static int mlx5e_add_l2_flow_rule(struct mlx5e_flow_steering *fs,
  				  struct mlx5e_l2_rule *ai, int type);
  static void mlx5e_del_l2_flow_rule(struct mlx5e_flow_steering *fs,
@@@ -1369,6 -1402,36 +1400,39 @@@ static void mlx5e_fs_tc_free(struct mlx
  	mlx5e_tc_table_free(fs->tc);
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_tc_table *mlx5e_fs_get_tc(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->tc;
+ }
+ 
+ #ifdef CONFIG_MLX5_EN_RXNFC
+ static int mlx5e_fs_ethtool_alloc(struct mlx5e_flow_steering *fs)
+ {
+ 	fs->ethtool = kvzalloc(sizeof(*fs->ethtool), GFP_KERNEL);
+ 
+ 	if (!fs->ethtool)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ static void mlx5e_fs_ethtool_free(struct mlx5e_flow_steering *fs)
+ {
+ 	kvfree(fs->ethtool);
+ }
+ 
+ struct mlx5e_ethtool_steering *mlx5e_fs_get_ethtool(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->ethtool;
+ }
+ #else
+ static int mlx5e_fs_ethtool_alloc(struct mlx5e_flow_steering *fs)
+ { return 0; }
+ static void mlx5e_fs_ethtool_free(struct mlx5e_flow_steering *fs) { }
+ #endif
+ 
++>>>>>>> c7eafc5ed068 (net/mlx5e: Convert ethtool_steering member of flow_steering struct to pointer)
  struct mlx5e_flow_steering *mlx5e_fs_init(const struct mlx5e_profile *profile,
  					  struct mlx5_core_dev *mdev,
  					  bool state_destroy)
@@@ -1394,12 -1457,17 +1458,23 @@@
  			goto err_free_vlan;
  	}
  
+ 	err = mlx5e_fs_ethtool_alloc(fs);
+ 	if (err)
+ 		goto err_free_tc;
+ 
  	return fs;
++<<<<<<< HEAD
 +
++=======
+ err_free_tc:
+ 	mlx5e_fs_tc_free(fs);
+ err_free_fs:
+ 	kvfree(fs);
++>>>>>>> c7eafc5ed068 (net/mlx5e: Convert ethtool_steering member of flow_steering struct to pointer)
  err_free_vlan:
  	mlx5e_fs_vlan_free(fs);
 +err_free_fs:
 +	kvfree(fs);
  err:
  	return NULL;
  }
@@@ -1410,3 -1479,104 +1486,107 @@@ void mlx5e_fs_cleanup(struct mlx5e_flow
  	mlx5e_fs_vlan_free(fs);
  	kvfree(fs);
  }
++<<<<<<< HEAD
++=======
+ 
+ struct mlx5e_l2_table *mlx5e_fs_get_l2(struct mlx5e_flow_steering *fs)
+ {
+ 	return &fs->l2;
+ }
+ 
+ struct mlx5_flow_namespace *mlx5e_fs_get_ns(struct mlx5e_flow_steering *fs, bool egress)
+ {
+ 	return  egress ? fs->egress_ns : fs->ns;
+ }
+ 
+ void mlx5e_fs_set_ns(struct mlx5e_flow_steering *fs, struct mlx5_flow_namespace *ns, bool egress)
+ {
+ 	if (!egress)
+ 		fs->ns = ns;
+ 	else
+ 		fs->egress_ns = ns;
+ }
+ 
+ struct mlx5_ttc_table *mlx5e_fs_get_ttc(struct mlx5e_flow_steering *fs, bool inner)
+ {
+ 	return inner ? fs->inner_ttc : fs->ttc;
+ }
+ 
+ void mlx5e_fs_set_ttc(struct mlx5e_flow_steering *fs, struct mlx5_ttc_table *ttc, bool inner)
+ {
+ 	if (!inner)
+ 		fs->ttc = ttc;
+ 	else
+ 		fs->inner_ttc = ttc;
+ }
+ 
+ #ifdef CONFIG_MLX5_EN_ARFS
+ struct mlx5e_arfs_tables *mlx5e_fs_get_arfs(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->arfs;
+ }
+ 
+ void mlx5e_fs_set_arfs(struct mlx5e_flow_steering *fs, struct mlx5e_arfs_tables *arfs)
+ {
+ 	fs->arfs = arfs;
+ }
+ #endif
+ 
+ struct mlx5e_ptp_fs *mlx5e_fs_get_ptp(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->ptp_fs;
+ }
+ 
+ void mlx5e_fs_set_ptp(struct mlx5e_flow_steering *fs, struct mlx5e_ptp_fs *ptp_fs)
+ {
+ 	fs->ptp_fs = ptp_fs;
+ }
+ 
+ struct mlx5e_fs_any *mlx5e_fs_get_any(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->any;
+ }
+ 
+ void mlx5e_fs_set_any(struct mlx5e_flow_steering *fs, struct mlx5e_fs_any *any)
+ {
+ 	fs->any = any;
+ }
+ 
+ #ifdef CONFIG_MLX5_EN_TLS
+ struct mlx5e_accel_fs_tcp *mlx5e_fs_get_accel_tcp(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->accel_tcp;
+ }
+ 
+ void mlx5e_fs_set_accel_tcp(struct mlx5e_flow_steering *fs, struct mlx5e_accel_fs_tcp *accel_tcp)
+ {
+ 	fs->accel_tcp = accel_tcp;
+ }
+ #endif
+ 
+ void mlx5e_fs_set_state_destroy(struct mlx5e_flow_steering *fs, bool state_destroy)
+ {
+ 	fs->state_destroy = state_destroy;
+ }
+ 
+ void mlx5e_fs_set_vlan_strip_disable(struct mlx5e_flow_steering *fs,
+ 				     bool vlan_strip_disable)
+ {
+ 	fs->vlan_strip_disable = vlan_strip_disable;
+ }
+ 
+ struct mlx5e_fs_udp *mlx5e_fs_get_udp(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->udp;
+ }
+ 
+ void mlx5e_fs_set_udp(struct mlx5e_flow_steering *fs, struct mlx5e_fs_udp *udp)
+ {
+ 	fs->udp = udp;
+ }
+ 
+ struct mlx5_core_dev *mlx5e_fs_get_mdev(struct mlx5e_flow_steering *fs)
+ {
+ 	return fs->mdev;
+ }
++>>>>>>> c7eafc5ed068 (net/mlx5e: Convert ethtool_steering member of flow_steering struct to pointer)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
