idpf: add support for SW triggered interrupts

jira LE-3064
Rebuild_History Non-Buildable kernel-4.18.0-553.52.1.el8_10
commit-author Joshua Hay <joshua.a.hay@intel.com>
commit 93433c1d919775f8ac0f7893692f42e6731a5373
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.52.1.el8_10/93433c1d.failed

SW triggered interrupts are guaranteed to fire after their timer
expires, unlike Tx and Rx interrupts which will only fire after the
timer expires _and_ a descriptor write back is available to be processed
by the driver.

Add the necessary fields, defines, and initializations to enable a SW
triggered interrupt in the vector's dyn_ctl register.

	Reviewed-by: Madhu Chittim <madhu.chittim@intel.com>
	Signed-off-by: Joshua Hay <joshua.a.hay@intel.com>
	Tested-by: Krishneil Singh <krishneil.k.singh@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 93433c1d919775f8ac0f7893692f42e6731a5373)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/idpf/idpf_dev.c
#	drivers/net/ethernet/intel/idpf/idpf_txrx.h
#	drivers/net/ethernet/intel/idpf/idpf_vf_dev.c
diff --cc drivers/net/ethernet/intel/idpf/idpf_dev.c
index 3df9935685e9,41e4bd49402a..000000000000
--- a/drivers/net/ethernet/intel/idpf/idpf_dev.c
+++ b/drivers/net/ethernet/intel/idpf/idpf_dev.c
@@@ -97,8 -97,13 +97,15 @@@ static int idpf_intr_reg_init(struct id
  		intr->dyn_ctl = idpf_get_reg_addr(adapter,
  						  reg_vals[vec_id].dyn_ctl_reg);
  		intr->dyn_ctl_intena_m = PF_GLINT_DYN_CTL_INTENA_M;
 -		intr->dyn_ctl_intena_msk_m = PF_GLINT_DYN_CTL_INTENA_MSK_M;
  		intr->dyn_ctl_itridx_s = PF_GLINT_DYN_CTL_ITR_INDX_S;
  		intr->dyn_ctl_intrvl_s = PF_GLINT_DYN_CTL_INTERVAL_S;
++<<<<<<< HEAD
++=======
+ 		intr->dyn_ctl_wb_on_itr_m = PF_GLINT_DYN_CTL_WB_ON_ITR_M;
+ 		intr->dyn_ctl_swint_trig_m = PF_GLINT_DYN_CTL_SWINT_TRIG_M;
+ 		intr->dyn_ctl_sw_itridx_ena_m =
+ 			PF_GLINT_DYN_CTL_SW_ITR_INDX_ENA_M;
++>>>>>>> 93433c1d9197 (idpf: add support for SW triggered interrupts)
  
  		spacing = IDPF_ITR_IDX_SPACING(reg_vals[vec_id].itrn_index_spacing,
  					       IDPF_PF_ITR_IDX_SPACING);
diff --cc drivers/net/ethernet/intel/idpf/idpf_txrx.h
index 387f1af9c33f,0f71a6f5557b..000000000000
--- a/drivers/net/ethernet/intel/idpf/idpf_txrx.h
+++ b/drivers/net/ethernet/intel/idpf/idpf_txrx.h
@@@ -488,6 -352,10 +488,12 @@@ struct idpf_vec_regs 
   * @dyn_ctl_itridx_s: Register bit offset for ITR index
   * @dyn_ctl_itridx_m: Mask for ITR index
   * @dyn_ctl_intrvl_s: Register bit offset for ITR interval
++<<<<<<< HEAD
++=======
+  * @dyn_ctl_wb_on_itr_m: Mask for WB on ITR feature
+  * @dyn_ctl_sw_itridx_ena_m: Mask for SW ITR index
+  * @dyn_ctl_swint_trig_m: Mask for dyn_ctl SW triggered interrupt enable
++>>>>>>> 93433c1d9197 (idpf: add support for SW triggered interrupts)
   * @rx_itr: RX ITR register
   * @tx_itr: TX ITR register
   * @icr_ena: Interrupt cause register offset
@@@ -499,6 -367,10 +505,12 @@@ struct idpf_intr_reg 
  	u32 dyn_ctl_itridx_s;
  	u32 dyn_ctl_itridx_m;
  	u32 dyn_ctl_intrvl_s;
++<<<<<<< HEAD
++=======
+ 	u32 dyn_ctl_wb_on_itr_m;
+ 	u32 dyn_ctl_sw_itridx_ena_m;
+ 	u32 dyn_ctl_swint_trig_m;
++>>>>>>> 93433c1d9197 (idpf: add support for SW triggered interrupts)
  	void __iomem *rx_itr;
  	void __iomem *tx_itr;
  	void __iomem *icr_ena;
@@@ -549,13 -433,18 +561,20 @@@ struct idpf_q_vector 
  	u16 rx_itr_value;
  	bool rx_intr_mode;
  	u32 rx_itr_idx;
 -	__cacheline_group_end_aligned(read_write);
  
 -	__cacheline_group_begin_aligned(cold);
 -	u16 v_idx;
 +	u16 num_bufq;
 +	struct idpf_queue **bufq;
  
 -	cpumask_var_t affinity_mask;
 -	__cacheline_group_end_aligned(cold);
 +	u16 total_events;
 +	char *name;
  };
++<<<<<<< HEAD
++=======
+ libeth_cacheline_set_assert(struct idpf_q_vector, 120,
+ 			    24 + sizeof(struct napi_struct) +
+ 			    2 * sizeof(struct dim),
+ 			    8 + sizeof(cpumask_var_t));
++>>>>>>> 93433c1d9197 (idpf: add support for SW triggered interrupts)
  
  struct idpf_rx_queue_stats {
  	u64_stats_t packets;
diff --cc drivers/net/ethernet/intel/idpf/idpf_vf_dev.c
index 629cb5cb7c9f,aba828abcb17..000000000000
--- a/drivers/net/ethernet/intel/idpf/idpf_vf_dev.c
+++ b/drivers/net/ethernet/intel/idpf/idpf_vf_dev.c
@@@ -97,7 -97,13 +97,15 @@@ static int idpf_vf_intr_reg_init(struc
  		intr->dyn_ctl = idpf_get_reg_addr(adapter,
  						  reg_vals[vec_id].dyn_ctl_reg);
  		intr->dyn_ctl_intena_m = VF_INT_DYN_CTLN_INTENA_M;
 -		intr->dyn_ctl_intena_msk_m = VF_INT_DYN_CTLN_INTENA_MSK_M;
  		intr->dyn_ctl_itridx_s = VF_INT_DYN_CTLN_ITR_INDX_S;
++<<<<<<< HEAD
++=======
+ 		intr->dyn_ctl_intrvl_s = VF_INT_DYN_CTLN_INTERVAL_S;
+ 		intr->dyn_ctl_wb_on_itr_m = VF_INT_DYN_CTLN_WB_ON_ITR_M;
+ 		intr->dyn_ctl_swint_trig_m = VF_INT_DYN_CTLN_SWINT_TRIG_M;
+ 		intr->dyn_ctl_sw_itridx_ena_m =
+ 			VF_INT_DYN_CTLN_SW_ITR_INDX_ENA_M;
++>>>>>>> 93433c1d9197 (idpf: add support for SW triggered interrupts)
  
  		spacing = IDPF_ITR_IDX_SPACING(reg_vals[vec_id].itrn_index_spacing,
  					       IDPF_VF_ITR_IDX_SPACING);
* Unmerged path drivers/net/ethernet/intel/idpf/idpf_dev.c
* Unmerged path drivers/net/ethernet/intel/idpf/idpf_txrx.h
* Unmerged path drivers/net/ethernet/intel/idpf/idpf_vf_dev.c
