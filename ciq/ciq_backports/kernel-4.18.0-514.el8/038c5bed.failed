s390/ap: add ap status asynch error support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-514.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 038c5bedbc313b55f66b26fda5a7808727c2f177
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-514.el8/038c5bed.failed

Review and extend the low level AP code to be able to
deal with asynchronous reported errors on APQNs.

The hypervisor and the SE guest may be confronted with
an asynchronously reported error at return of an AP
instruction. So all places where AP instructions are
called need review and may eventually need extensions.
However, not all places need rework. As together with
the AP status and the enabled asynch bit there is always
a response code set. The asynch error reporting comes
with new response codes which may be simple handled in
the default case of a switch statement.

The idea behind this patch is to report asynch errors
as -EPERM (read this as "Operation not permitted") which
reflects the fact that only a rapq (with F bit enabled)
is a valid AP instruction when an asynch error is flagged.

The AP queue state machine functions return
AP_SM_WAIT_NONE when a asynch error is detected to reflect
the fact, that the state machine can't do anything with
such an error as long as the queue is reset.

Unfortunately the ap bus scan function needed some
update as the ap_queue_info() now needs to return
3 states: 1 if an APQN exists and info is available,
-1 if it is assumed an APQN does not exist and the new
return value 0 without any info values filled. This 0
returncode is handled as "there is an APQN but we currently
don't know any more hw info about this, so please use
your previous info and try again later".

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Reviewed-by: Holger Dengler <dengler@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 038c5bedbc313b55f66b26fda5a7808727c2f177)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/ap_queue.c
diff --cc drivers/s390/crypto/ap_bus.c
index bf45474cbab8,70855af8c281..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -340,35 -342,32 +340,47 @@@ EXPORT_SYMBOL(ap_test_config_ctrl_domai
  
  /*
   * ap_queue_info(): Check and get AP queue info.
-  * Returns true if TAPQ succeeded and the info is filled or
-  * false otherwise.
+  * Returns: 1 if APQN exists and info is filled,
+  *	    0 if APQN seems to exit but there is no info
+  *	      available (eg. caused by an asynch pending error)
+  *	   -1 invalid APQN, TAPQ error or AP queue status which
+  *	      indicates there is no APQN.
   */
- static bool ap_queue_info(ap_qid_t qid, int *q_type, unsigned int *q_fac,
- 			  int *q_depth, int *q_ml, bool *q_decfg, bool *q_cstop)
+ static int ap_queue_info(ap_qid_t qid, int *q_type, unsigned int *q_fac,
+ 			 int *q_depth, int *q_ml, bool *q_decfg, bool *q_cstop)
  {
  	struct ap_queue_status status;
 -	struct ap_tapq_gr2 tapq_info;
 +	union {
 +		unsigned long value;
 +		struct {
 +			unsigned int fac   : 32; /* facility bits */
 +			unsigned int at	   :  8; /* ap type */
 +			unsigned int _res1 :  8;
 +			unsigned int _res2 :  4;
 +			unsigned int ml	   :  4; /* apxl ml */
 +			unsigned int _res3 :  4;
 +			unsigned int qd	   :  4; /* queue depth */
 +		} tapq_gr2;
 +	} tapq_info;
  
  	tapq_info.value = 0;
  
  	/* make sure we don't run into a specifiation exception */
  	if (AP_QID_CARD(qid) > ap_max_adapter_id ||
  	    AP_QID_QUEUE(qid) > ap_max_domain_id)
- 		return false;
+ 		return -1;
  
  	/* call TAPQ on this APQN */
++<<<<<<< HEAD
 +	status = ap_test_queue(qid, ap_apft_available(), &tapq_info.value);
++=======
+ 	status = ap_test_queue(qid, ap_apft_available(), &tapq_info);
+ 
+ 	/* handle pending async error with return 'no info available' */
+ 	if (status.async)
+ 		return 0;
+ 
++>>>>>>> 038c5bedbc31 (s390/ap: add ap status asynch error support)
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  	case AP_RESPONSE_RESET_IN_PROGRESS:
@@@ -381,11 -380,11 +393,19 @@@
  		 * there is at least one of the mode bits set.
  		 */
  		if (WARN_ON_ONCE(!tapq_info.value))
++<<<<<<< HEAD
 +			return false;
 +		*q_type = tapq_info.tapq_gr2.at;
 +		*q_fac = tapq_info.tapq_gr2.fac;
 +		*q_depth = tapq_info.tapq_gr2.qd;
 +		*q_ml = tapq_info.tapq_gr2.ml;
++=======
+ 			return 0;
+ 		*q_type = tapq_info.at;
+ 		*q_fac = tapq_info.fac;
+ 		*q_depth = tapq_info.qd;
+ 		*q_ml = tapq_info.ml;
++>>>>>>> 038c5bedbc31 (s390/ap: add ap status asynch error support)
  		*q_decfg = status.response_code == AP_RESPONSE_DECONFIGURED;
  		*q_cstop = status.response_code == AP_RESPONSE_CHECKSTOPPED;
  		switch (*q_type) {
diff --cc drivers/s390/crypto/ap_queue.c
index 5cff09d72b96,ed8f813653fe..000000000000
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@@ -34,7 -49,9 +34,13 @@@ static int ap_queue_enable_irq(struct a
  
  	qirqctrl.ir = 1;
  	qirqctrl.isc = AP_ISC;
++<<<<<<< HEAD
 +	status = ap_aqic(aq->qid, qirqctrl, ind);
++=======
+ 	status = ap_aqic(aq->qid, qirqctrl, virt_to_phys(ind));
+ 	if (status.async)
+ 		return -EPERM;
++>>>>>>> 038c5bedbc31 (s390/ap: add ap status asynch error support)
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  	case AP_RESPONSE_OTHERWISE_CHANGED:
@@@ -80,7 -97,9 +86,13 @@@ int ap_send(ap_qid_t qid, unsigned lon
  {
  	struct ap_queue_status status;
  
++<<<<<<< HEAD
 +	status = __ap_send(qid, psmid, msg, length, 0);
++=======
+ 	status = __ap_send(qid, psmid, msg, msglen, 0);
+ 	if (status.async)
+ 		return -EPERM;
++>>>>>>> 038c5bedbc31 (s390/ap: add ap status asynch error support)
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		return 0;
@@@ -101,7 -120,9 +113,13 @@@ int ap_recv(ap_qid_t qid, unsigned lon
  
  	if (!msg)
  		return -EINVAL;
++<<<<<<< HEAD
 +	status = ap_dqap(qid, psmid, msg, length, NULL, NULL);
++=======
+ 	status = ap_dqap(qid, psmid, msg, msglen, NULL, NULL, NULL);
+ 	if (status.async)
+ 		return -EPERM;
++>>>>>>> 038c5bedbc31 (s390/ap: add ap status asynch error support)
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		return 0;
@@@ -347,7 -347,9 +369,13 @@@ static enum ap_sm_wait ap_sm_reset(stru
  {
  	struct ap_queue_status status;
  
++<<<<<<< HEAD
 +	status = ap_rapq(aq->qid, 0);
++=======
+ 	status = ap_rapq(aq->qid, aq->rapq_fbit);
+ 	if (status.async)
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 038c5bedbc31 (s390/ap: add ap status asynch error support)
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  	case AP_RESPONSE_RESET_IN_PROGRESS:
* Unmerged path drivers/s390/crypto/ap_bus.c
* Unmerged path drivers/s390/crypto/ap_queue.c
