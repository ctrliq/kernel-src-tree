s390/ap: implement SE AP bind, unbind and associate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-514.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 2d72eaf036d2f2b7ec16cda2d0e7ce292537dad9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-514.el8/2d72eaf0.failed

Implementation of the new functions for SE AP support:
bind, unbind and associate. There are two new sysfs
attributes for this:

/sys/devices/ap/cardxx/xx.yyyy/se_bind
/sys/devices/ap/cardxx/xx.yyyy/se_associate

Writing a 1 into the se_bind attribute triggers the
SE AP bind for this AP queue, writing a 0 into does
an unbind - that's a reset (RAPQ) with the F bit enabled.

The se_associate attribute needs an integer value in
range 0...2^16-1 written in. This is the index into a
secrets table feed into the ultravisor. For more details
please see the Architecture documents.

These both new ap queue attributes are only visible
inside a SE guest with SB (Secure Binding) available.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Reviewed-by: Holger Dengler <dengler@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 2d72eaf036d2f2b7ec16cda2d0e7ce292537dad9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/ap.h
#	drivers/s390/crypto/ap_bus.h
#	drivers/s390/crypto/ap_queue.c
diff --cc arch/s390/include/asm/ap.h
index fe5c518cac2d,d5d967166bac..000000000000
--- a/arch/s390/include/asm/ap.h
+++ b/arch/s390/include/asm/ap.h
@@@ -42,12 -43,26 +42,13 @@@ struct ap_queue_status 
  	unsigned int queue_empty	: 1;
  	unsigned int replies_waiting	: 1;
  	unsigned int queue_full		: 1;
- 	unsigned int _pad1		: 4;
+ 	unsigned int			: 3;
+ 	unsigned int async		: 1;
  	unsigned int irq_enabled	: 1;
  	unsigned int response_code	: 8;
- 	unsigned int _pad2		: 16;
+ 	unsigned int			: 16;
  };
  
 -/*
 - * AP queue status reg union to access the reg1
 - * register with the lower 32 bits comprising the
 - * ap queue status.
 - */
 -union ap_queue_status_reg {
 -	unsigned long value;
 -	struct {
 -		u32 _pad;
 -		struct ap_queue_status status;
 -	};
 -};
 -
  /**
   * ap_intructions_available() - Test if AP instructions are available.
   *
@@@ -72,6 -87,42 +73,45 @@@ static inline bool ap_instructions_avai
  	return reg1 != 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* TAPQ register GR2 response struct */
+ struct ap_tapq_gr2 {
+ 	union {
+ 		unsigned long value;
+ 		struct {
+ 			unsigned int fac    : 32; /* facility bits */
+ 			unsigned int apinfo : 32; /* ap type, ... */
+ 		};
+ 		struct {
+ 			unsigned int s	   :  1; /* APSC */
+ 			unsigned int m	   :  1; /* AP4KM */
+ 			unsigned int c	   :  1; /* AP4KC */
+ 			unsigned int mode  :  3;
+ 			unsigned int n	   :  1; /* APXA */
+ 			unsigned int	   :  1;
+ 			unsigned int class :  8;
+ 			unsigned int bs	   :  2; /* SE bind/assoc */
+ 			unsigned int	   : 14;
+ 			unsigned int at	   :  8; /* ap type */
+ 			unsigned int nd	   :  8; /* nr of domains */
+ 			unsigned int	   :  4;
+ 			unsigned int ml	   :  4; /* apxl ml */
+ 			unsigned int	   :  4;
+ 			unsigned int qd	   :  4; /* queue depth */
+ 		};
+ 	};
+ };
+ 
+ /*
+  * Convenience defines to be used with the bs field from struct ap_tapq_gr2
+  */
+ #define AP_BS_Q_USABLE		      0
+ #define AP_BS_Q_USABLE_NO_SECURE_KEY  1
+ #define AP_BS_Q_AVAIL_FOR_BINDING     2
+ #define AP_BS_Q_UNUSABLE	      3
+ 
++>>>>>>> 2d72eaf036d2 (s390/ap: implement SE AP bind, unbind and associate)
  /**
   * ap_tapq(): Test adjunct processor queue.
   * @qid: The AP queue number
diff --cc drivers/s390/crypto/ap_bus.h
index 05e7475f8f8f,101fb324476f..000000000000
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@@ -39,21 -39,32 +39,50 @@@ static inline int ap_test_bit(unsigned 
  	return (*ptr & (0x80000000u >> nr)) != 0;
  }
  
++<<<<<<< HEAD
 +#define AP_RESPONSE_NORMAL		0x00
 +#define AP_RESPONSE_Q_NOT_AVAIL		0x01
 +#define AP_RESPONSE_RESET_IN_PROGRESS	0x02
 +#define AP_RESPONSE_DECONFIGURED	0x03
 +#define AP_RESPONSE_CHECKSTOPPED	0x04
 +#define AP_RESPONSE_BUSY		0x05
 +#define AP_RESPONSE_INVALID_ADDRESS	0x06
 +#define AP_RESPONSE_OTHERWISE_CHANGED	0x07
 +#define AP_RESPONSE_Q_FULL		0x10
 +#define AP_RESPONSE_NO_PENDING_REPLY	0x10
 +#define AP_RESPONSE_INDEX_TOO_BIG	0x11
 +#define AP_RESPONSE_NO_FIRST_PART	0x13
 +#define AP_RESPONSE_MESSAGE_TOO_BIG	0x15
 +#define AP_RESPONSE_REQ_FAC_NOT_INST	0x16
 +#define AP_RESPONSE_INVALID_DOMAIN	0x42
++=======
+ #define AP_RESPONSE_NORMAL		     0x00
+ #define AP_RESPONSE_Q_NOT_AVAIL		     0x01
+ #define AP_RESPONSE_RESET_IN_PROGRESS	     0x02
+ #define AP_RESPONSE_DECONFIGURED	     0x03
+ #define AP_RESPONSE_CHECKSTOPPED	     0x04
+ #define AP_RESPONSE_BUSY		     0x05
+ #define AP_RESPONSE_INVALID_ADDRESS	     0x06
+ #define AP_RESPONSE_OTHERWISE_CHANGED	     0x07
+ #define AP_RESPONSE_INVALID_GISA	     0x08
+ #define AP_RESPONSE_Q_BOUND_TO_ANOTHER	     0x09
+ #define AP_RESPONSE_STATE_CHANGE_IN_PROGRESS 0x0A
+ #define AP_RESPONSE_Q_NOT_BOUND		     0x0B
+ #define AP_RESPONSE_Q_FULL		     0x10
+ #define AP_RESPONSE_NO_PENDING_REPLY	     0x10
+ #define AP_RESPONSE_INDEX_TOO_BIG	     0x11
+ #define AP_RESPONSE_NO_FIRST_PART	     0x13
+ #define AP_RESPONSE_MESSAGE_TOO_BIG	     0x15
+ #define AP_RESPONSE_REQ_FAC_NOT_INST	     0x16
+ #define AP_RESPONSE_Q_BIND_ERROR	     0x30
+ #define AP_RESPONSE_Q_NOT_AVAIL_FOR_ASSOC    0x31
+ #define AP_RESPONSE_Q_NOT_EMPTY		     0x32
+ #define AP_RESPONSE_BIND_LIMIT_EXCEEDED	     0x33
+ #define AP_RESPONSE_INVALID_ASSOC_SECRET     0x34
+ #define AP_RESPONSE_ASSOC_SECRET_NOT_UNIQUE  0x35
+ #define AP_RESPONSE_ASSOC_FAILED	     0x36
+ #define AP_RESPONSE_INVALID_DOMAIN	     0x42
++>>>>>>> 2d72eaf036d2 (s390/ap: implement SE AP bind, unbind and associate)
  
  /*
   * Known device types
@@@ -91,7 -102,7 +120,11 @@@ enum ap_sm_state 
  	AP_SM_STATE_IDLE,
  	AP_SM_STATE_WORKING,
  	AP_SM_STATE_QUEUE_FULL,
++<<<<<<< HEAD
 +	AP_SM_STATE_SUSPEND_WAIT,
++=======
+ 	AP_SM_STATE_ASSOC_WAIT,
++>>>>>>> 2d72eaf036d2 (s390/ap: implement SE AP bind, unbind and associate)
  	NR_AP_SM_STATES
  };
  
diff --cc drivers/s390/crypto/ap_queue.c
index 5cff09d72b96,2be63f2554bd..000000000000
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@@ -353,7 -343,8 +368,12 @@@ static enum ap_sm_wait ap_sm_reset(stru
  	case AP_RESPONSE_RESET_IN_PROGRESS:
  		aq->sm_state = AP_SM_STATE_RESET_WAIT;
  		aq->interrupt = false;
++<<<<<<< HEAD
 +		return AP_SM_WAIT_TIMEOUT;
++=======
+ 		aq->rapq_fbit = 0;
+ 		return AP_SM_WAIT_LOW_TIMEOUT;
++>>>>>>> 2d72eaf036d2 (s390/ap: implement SE AP bind, unbind and associate)
  	default:
  		aq->dev_state = AP_DEV_STATE_ERROR;
  		aq->last_err_rc = status.response_code;
@@@ -476,9 -520,9 +549,15 @@@ static ap_func_t *ap_jumptable[NR_AP_SM
  		[AP_SM_EVENT_POLL] = ap_sm_read,
  		[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,
  	},
++<<<<<<< HEAD
 +	[AP_SM_STATE_SUSPEND_WAIT] = {
 +		[AP_SM_EVENT_POLL] = ap_sm_suspend_read,
 +		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
++=======
+ 	[AP_SM_STATE_ASSOC_WAIT] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_assoc_wait,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,
++>>>>>>> 2d72eaf036d2 (s390/ap: implement SE AP bind, unbind and associate)
  	},
  };
  
@@@ -730,32 -752,28 +809,35 @@@ static ssize_t states_show(struct devic
  	if (aq->dev_state) {
  		switch (aq->sm_state) {
  		case AP_SM_STATE_RESET_START:
 -			rc += sysfs_emit_at(buf, rc, " [RESET_START]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [RESET_START]\n");
  			break;
  		case AP_SM_STATE_RESET_WAIT:
 -			rc += sysfs_emit_at(buf, rc, " [RESET_WAIT]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [RESET_WAIT]\n");
  			break;
  		case AP_SM_STATE_SETIRQ_WAIT:
 -			rc += sysfs_emit_at(buf, rc, " [SETIRQ_WAIT]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [SETIRQ_WAIT]\n");
  			break;
  		case AP_SM_STATE_IDLE:
 -			rc += sysfs_emit_at(buf, rc, " [IDLE]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [IDLE]\n");
  			break;
  		case AP_SM_STATE_WORKING:
 -			rc += sysfs_emit_at(buf, rc, " [WORKING]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [WORKING]\n");
  			break;
  		case AP_SM_STATE_QUEUE_FULL:
 -			rc += sysfs_emit_at(buf, rc, " [FULL]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [FULL]\n");
  			break;
+ 		case AP_SM_STATE_ASSOC_WAIT:
+ 			rc += sysfs_emit_at(buf, rc, " [ASSOC_WAIT]\n");
+ 			break;
  		default:
 -			rc += sysfs_emit_at(buf, rc, " [UNKNOWN]\n");
 +			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
 +					" [UNKNOWN]\n");
  		}
  	}
  	spin_unlock_bh(&aq->lock);
* Unmerged path arch/s390/include/asm/ap.h
* Unmerged path drivers/s390/crypto/ap_bus.h
* Unmerged path drivers/s390/crypto/ap_queue.c
