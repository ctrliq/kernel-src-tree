perf/x86: Support Retire Latency

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Kan Liang <kan.liang@linux.intel.com>
commit c87a31093c707eb0b8c48aab89922c1d0bf4bd90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/c87a3109.failed

Retire Latency reports the number of elapsed core clocks between the
retirement of the instruction indicated by the Instruction Pointer field
of the PEBS record and the retirement of the prior instruction. It's
enumerated by the IA32_PERF_CAPABILITIES.PEBS_TIMING_INFO[17].

Add flag PMU_FL_RETIRE_LATENCY to indicate the availability of the
feature.

The Retire Latency is not supported by the fixed counter 0 on p-core of
MTL.

	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Reviewed-by: Andi Kleen <ak@linux.intel.com>
	Acked-by: Peter Zijlstra <peterz@infradead.org>
Link: https://lore.kernel.org/r/20230104201349.1451191-3-kan.liang@linux.intel.com
(cherry picked from commit c87a31093c707eb0b8c48aab89922c1d0bf4bd90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/core.c
diff --cc arch/x86/events/intel/core.c
index a9e98932e43b,a5678ab6d3e3..000000000000
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@@ -6533,6 -6745,11 +6560,14 @@@ __init int intel_pmu_init(void
  	if (is_hybrid())
  		intel_pmu_check_hybrid_pmus((u64)fixed_mask);
  
++<<<<<<< HEAD
++=======
+ 	if (x86_pmu.intel_cap.pebs_timing_info)
+ 		x86_pmu.flags |= PMU_FL_RETIRE_LATENCY;
+ 
+ 	intel_aux_output_init();
+ 
++>>>>>>> c87a31093c70 (perf/x86: Support Retire Latency)
  	return 0;
  }
  
* Unmerged path arch/x86/events/intel/core.c
diff --git a/arch/x86/events/intel/ds.c b/arch/x86/events/intel/ds.c
index 7fd64498e61e..5a342a9b69b9 100644
--- a/arch/x86/events/intel/ds.c
+++ b/arch/x86/events/intel/ds.c
@@ -1708,6 +1708,7 @@ static void adaptive_pebs_save_regs(struct pt_regs *regs,
 
 #define PEBS_LATENCY_MASK			0xffff
 #define PEBS_CACHE_LATENCY_OFFSET		32
+#define PEBS_RETIRE_LATENCY_OFFSET		32
 
 /*
  * With adaptive PEBS the layout depends on what fields are configured.
@@ -1755,6 +1756,9 @@ static void setup_pebs_adaptive_sample_data(struct perf_event *event,
 	set_linear_ip(regs, basic->ip);
 	regs->flags = PERF_EFLAGS_EXACT;
 
+	if ((sample_type & PERF_SAMPLE_WEIGHT_STRUCT) && (x86_pmu.flags & PMU_FL_RETIRE_LATENCY))
+		data->weight.var3_w = format_size >> PEBS_RETIRE_LATENCY_OFFSET & PEBS_LATENCY_MASK;
+
 	/*
 	 * The record for MEMINFO is in front of GP
 	 * But PERF_SAMPLE_TRANSACTION needs gprs->ax.
diff --git a/arch/x86/events/perf_event.h b/arch/x86/events/perf_event.h
index 74b72c5189f5..2f6d4b409cb4 100644
--- a/arch/x86/events/perf_event.h
+++ b/arch/x86/events/perf_event.h
@@ -605,6 +605,7 @@ union perf_capabilities {
 		u64     pebs_baseline:1;
 		u64	perf_metrics:1;
 		u64	pebs_output_pt_available:1;
+		u64	pebs_timing_info:1;
 		u64	anythread_deprecated:1;
 	};
 	u64	capabilities;
@@ -1001,6 +1002,7 @@ do {									\
 #define PMU_FL_PAIR		0x40 /* merge counters for large incr. events */
 #define PMU_FL_INSTR_LATENCY	0x80 /* Support Instruction Latency in PEBS Memory Info Record */
 #define PMU_FL_MEM_LOADS_AUX	0x100 /* Require an auxiliary event for the complete memory info */
+#define PMU_FL_RETIRE_LATENCY	0x200 /* Support Retire Latency in PEBS */
 
 #define EVENT_VAR(_id)  event_attr_##_id
 #define EVENT_PTR(_id) &event_attr_##_id.attr.attr
