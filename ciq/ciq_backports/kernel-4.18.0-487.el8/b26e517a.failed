mm/mempolicy: cleanup nodemask intersection check for oom

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Feng Tang <feng.tang@intel.com>
commit b26e517a058bd40c790a1d9868c896842f2e4155
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/b26e517a.failed

Patch series "mm/mempolicy: some fix and semantics cleanup", v4.

Current memory policy code has some confusing and ambiguous part about
MPOL_LOCAL policy, as it is handled as a faked MPOL_PREFERRED one, and
there are many places having to distinguish them.  Also the nodemask
intersection check needs cleanup to be more explicit for OOM use, and
handle MPOL_INTERLEAVE correctly.  This patchset cleans up these and
unifies the parameter sanity check for mbind() and set_mempolicy().

This patch (of 3):

mempolicy_nodemask_intersects seem to be a general purpose mempolicy
function.  In fact it is partially tailored for the OOM purpose
instead.  The oom proper is the only existing user so rename the
function to make that purpose explicit.

While at it drop the MPOL_INTERLEAVE as those allocations never has a
nodemask defined (see alloc_page_interleave) so this is a dead code and
a confusing one because MPOL_INTERLEAVE is a hint rather than a hard
requirement so it shouldn't be considered during the OOM.

The final code can be reduced to a check for MPOL_BIND which is the
only memory policy that is a hard requirement and thus relevant to a
constrained OOM logic.

[mhocko@suse.com: changelog edits]

Link: https://lkml.kernel.org/r/1622560492-1294-1-git-send-email-feng.tang@intel.com
Link: https://lkml.kernel.org/r/1622560492-1294-2-git-send-email-feng.tang@intel.com
Link: https://lkml.kernel.org/r/1622469956-82897-1-git-send-email-feng.tang@intel.com
Link: https://lkml.kernel.org/r/1622469956-82897-2-git-send-email-feng.tang@intel.com
	Signed-off-by: Feng Tang <feng.tang@intel.com>
	Suggested-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Ben Widawsky <ben.widawsky@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Huang Ying <ying.huang@intel.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b26e517a058bd40c790a1d9868c896842f2e4155)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mempolicy.c
diff --cc mm/mempolicy.c
index bdeec44db9fd,bd213b900e71..000000000000
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@@ -2037,12 -2094,12 +2037,19 @@@ bool init_nodemask_of_mempolicy(nodemas
  #endif
  
  /*
-  * mempolicy_nodemask_intersects
+  * mempolicy_in_oom_domain
   *
++<<<<<<< HEAD
 + * If tsk's mempolicy is "default" [NULL], return 'true' to indicate default
 + * policy.  Otherwise, check for intersection between mask and the policy
 + * nodemask for 'bind' or 'interleave' policy.  For 'perferred' or 'local'
 + * policy, always return true since it may allocate elsewhere on fallback.
++=======
+  * If tsk's mempolicy is "bind", check for intersection between mask and
+  * the policy nodemask. Otherwise, return true for all other policies
+  * including "interleave", as a tsk with "interleave" policy may have
+  * memory allocated from all nodes in system.
++>>>>>>> b26e517a058b (mm/mempolicy: cleanup nodemask intersection check for oom)
   *
   * Takes task_lock(tsk) to prevent freeing of its mempolicy.
   */
diff --git a/include/linux/mempolicy.h b/include/linux/mempolicy.h
index e553c56f6be7..d373c2c6ec72 100644
--- a/include/linux/mempolicy.h
+++ b/include/linux/mempolicy.h
@@ -150,7 +150,7 @@ extern int huge_node(struct vm_area_struct *vma,
 				unsigned long addr, gfp_t gfp_flags,
 				struct mempolicy **mpol, nodemask_t **nodemask);
 extern bool init_nodemask_of_mempolicy(nodemask_t *mask);
-extern bool mempolicy_nodemask_intersects(struct task_struct *tsk,
+extern bool mempolicy_in_oom_domain(struct task_struct *tsk,
 				const nodemask_t *mask);
 extern nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy);
 
* Unmerged path mm/mempolicy.c
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 944713fca3e2..1a4db04fb4bd 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -95,7 +95,7 @@ static bool oom_cpuset_eligible(struct task_struct *start,
 			 * mempolicy intersects current, otherwise it may be
 			 * needlessly killed.
 			 */
-			ret = mempolicy_nodemask_intersects(tsk, mask);
+			ret = mempolicy_in_oom_domain(tsk, mask);
 		} else {
 			/*
 			 * This is not a mempolicy constrained oom, so only
