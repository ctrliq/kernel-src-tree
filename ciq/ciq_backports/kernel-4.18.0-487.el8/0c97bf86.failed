tracing: Silence GCC 9 array bounds warning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
commit 0c97bf863efce63d6ab7971dad811601e6171d2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/0c97bf86.failed

Starting with GCC 9, -Warray-bounds detects cases when memset is called
starting on a member of a struct but the size to be cleared ends up
writing over further members.

Such a call happens in the trace code to clear, at once, all members
after and including `seq` on struct trace_iterator:

    In function 'memset',
        inlined from 'ftrace_dump' at kernel/trace/trace.c:8914:3:
    ./include/linux/string.h:344:9: warning: '__builtin_memset' offset
    [8505, 8560] from the object at 'iter' is out of the bounds of
    referenced subobject 'seq' with type 'struct trace_seq' at offset
    4368 [-Warray-bounds]
      344 |  return __builtin_memset(p, c, size);
          |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to avoid GCC complaining about it, we compute the address
ourselves by adding the offsetof distance instead of referring
directly to the member.

Since there are two places doing this clear (trace.c and trace_kdb.c),
take the chance to move the workaround into a single place in
the internal header.

Link: http://lkml.kernel.org/r/20190523124535.GA12931@gmail.com

	Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
[ Removed unnecessary parenthesis around "iter" ]
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 0c97bf863efce63d6ab7971dad811601e6171d2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace.h
diff --cc kernel/trace/trace.h
index 151fb49d2aa7,005f08629b8b..000000000000
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@@ -1921,21 -1967,21 +1921,40 @@@ static inline void tracer_hardirqs_off(
  extern struct trace_iterator *tracepoint_print_iter;
  
  /*
++<<<<<<< HEAD
 + * This is a generic way to read and write a u64 value from a file in tracefs.
 + *
 + * The value is stored on the variable pointed by *val. The value needs
 + * to be at least *min and at most *max. The write is protected by an
 + * existing *lock.
 + */
 +struct trace_min_max_param {
 +	struct mutex	*lock;
 +	u64		*val;
 +	u64		*min;
 +	u64		*max;
 +};
 +
 +#define U64_STR_SIZE		24	/* 20 digits max */
 +
 +extern const struct file_operations trace_min_max_fops;
++=======
+  * Reset the state of the trace_iterator so that it can read consumed data.
+  * Normally, the trace_iterator is used for reading the data when it is not
+  * consumed, and must retain state.
+  */
+ static __always_inline void trace_iterator_reset(struct trace_iterator *iter)
+ {
+ 	const size_t offset = offsetof(struct trace_iterator, seq);
+ 
+ 	/*
+ 	 * Keep gcc from complaining about overwriting more than just one
+ 	 * member in the structure.
+ 	 */
+ 	memset((char *)iter + offset, 0, sizeof(struct trace_iterator) - offset);
+ 
+ 	iter->pos = -1;
+ }
++>>>>>>> 0c97bf863efc (tracing: Silence GCC 9 array bounds warning)
  
  #endif /* _LINUX_KERNEL_TRACE_H */
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 9618d6151170..dd9b5d09e1b9 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -8485,12 +8485,8 @@ void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)
 
 		cnt++;
 
-		/* reset all but tr, trace, and overruns */
-		memset(&iter.seq, 0,
-		       sizeof(struct trace_iterator) -
-		       offsetof(struct trace_iterator, seq));
+		trace_iterator_reset(&iter);
 		iter.iter_flags |= TRACE_FILE_LAT_FMT;
-		iter.pos = -1;
 
 		if (trace_find_next_entry_inc(&iter) != NULL) {
 			int ret;
* Unmerged path kernel/trace/trace.h
diff --git a/kernel/trace/trace_kdb.c b/kernel/trace/trace_kdb.c
index 5654e0f1c278..4c3405079289 100644
--- a/kernel/trace/trace_kdb.c
+++ b/kernel/trace/trace_kdb.c
@@ -37,12 +37,8 @@ static void ftrace_dump_buf(int skip_entries, long cpu_file)
 	if (skip_entries)
 		kdb_printf("(skipping %d entries)\n", skip_entries);
 
-	/* reset all but tr, trace, and overruns */
-	memset(&iter.seq, 0,
-		   sizeof(struct trace_iterator) -
-		   offsetof(struct trace_iterator, seq));
+	trace_iterator_reset(&iter);
 	iter.iter_flags |= TRACE_FILE_LAT_FMT;
-	iter.pos = -1;
 
 	if (cpu_file == RING_BUFFER_ALL_CPUS) {
 		for_each_tracing_cpu(cpu) {
