mm/mempolicy: unify the create() func for bind/interleave/prefer-many policies

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Feng Tang <feng.tang@intel.com>
commit be897d48a971e36daadbd9289967e7e4f3749528
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/be897d48.failed

As they all do the same thing: sanity check and save nodemask info, create
one mpol_new_nodemask() to reduce redundancy.

Link: https://lkml.kernel.org/r/1627970362-61305-6-git-send-email-feng.tang@intel.com
	Signed-off-by: Feng Tang <feng.tang@intel.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Ben Widawsky <ben.widawsky@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Huang Ying <ying.huang@intel.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit be897d48a971e36daadbd9289967e7e4f3749528)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mempolicy.c
diff --cc mm/mempolicy.c
index 9717dff79e1e,bd4f249aada3..000000000000
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@@ -204,20 -202,11 +204,28 @@@ static int mpol_new_nodemask(struct mem
  
  static int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)
  {
++<<<<<<< HEAD
 +	if (!nodes)
 +		pol->flags |= MPOL_F_LOCAL;	/* local allocation */
 +	else if (nodes_empty(*nodes))
 +		return -EINVAL;			/*  no allowed nodes */
 +	else
 +		pol->v.preferred_node = first_node(*nodes);
 +	return 0;
 +}
 +
 +static int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)
 +{
 +	if (nodes_empty(*nodes))
 +		return -EINVAL;
 +	pol->v.nodes = *nodes;
++=======
+ 	if (nodes_empty(*nodes))
+ 		return -EINVAL;
+ 
+ 	nodes_clear(pol->nodes);
+ 	node_set(first_node(*nodes), pol->nodes);
++>>>>>>> be897d48a971 (mm/mempolicy: unify the create() func for bind/interleave/prefer-many policies)
  	return 0;
  }
  
@@@ -428,9 -397,16 +436,19 @@@ static const struct mempolicy_operation
  		.rebind = mpol_rebind_preferred,
  	},
  	[MPOL_BIND] = {
- 		.create = mpol_new_bind,
+ 		.create = mpol_new_nodemask,
  		.rebind = mpol_rebind_nodemask,
  	},
++<<<<<<< HEAD
++=======
+ 	[MPOL_LOCAL] = {
+ 		.rebind = mpol_rebind_default,
+ 	},
+ 	[MPOL_PREFERRED_MANY] = {
+ 		.create = mpol_new_nodemask,
+ 		.rebind = mpol_rebind_preferred,
+ 	},
++>>>>>>> be897d48a971 (mm/mempolicy: unify the create() func for bind/interleave/prefer-many policies)
  };
  
  static int migrate_page_add(struct page *page, struct list_head *pagelist,
* Unmerged path mm/mempolicy.c
