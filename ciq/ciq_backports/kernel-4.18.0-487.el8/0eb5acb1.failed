netfilter: flowtable: fixup UDP timeout depending on ct state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit 0eb5acb16418898c3d813e2c2d59a7ea7763a824
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/0eb5acb1.failed

Currently flow_offload_fixup_ct() function assumes that only replied UDP
connections can be offloaded and hardcodes UDP_CT_REPLIED timeout value. To
enable UDP NEW connection offload in following patches extract the actual
connections state from ct->status and set the timeout according to it.

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0eb5acb16418898c3d813e2c2d59a7ea7763a824)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_core.c
diff --cc net/netfilter/nf_flow_table_core.c
index e6f30bcdb054,04bd0ed4d2ae..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -146,12 -190,15 +146,20 @@@ static void flow_offload_fixup_ct(struc
  		flow_offload_fixup_tcp(&ct->proto.tcp);
  
  		timeout = tn->timeouts[ct->proto.tcp.state];
 -		timeout -= tn->offload_timeout;
 +		timeout -= net->nf_tcp_net_offload_timeout;
  	} else if (l4num == IPPROTO_UDP) {
  		struct nf_udp_net *tn = nf_udp_pernet(net);
+ 		enum udp_conntrack state =
+ 			test_bit(IPS_SEEN_REPLY_BIT, &ct->status) ?
+ 			UDP_CT_REPLIED : UDP_CT_UNREPLIED;
  
++<<<<<<< HEAD
 +		timeout = tn->timeouts[UDP_CT_REPLIED];
 +		timeout -= net->nf_udp_net_offload_timeout;
++=======
+ 		timeout = tn->timeouts[state];
+ 		timeout -= tn->offload_timeout;
++>>>>>>> 0eb5acb16418 (netfilter: flowtable: fixup UDP timeout depending on ct state)
  	} else {
  		return;
  	}
* Unmerged path net/netfilter/nf_flow_table_core.c
