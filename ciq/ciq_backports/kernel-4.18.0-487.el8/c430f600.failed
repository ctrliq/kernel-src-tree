fortify: Move remaining fortify helpers into fortify-string.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Kees Cook <keescook@chromium.org>
commit c430f60036af44079170ff71a461b9d7cf5ee431
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/c430f600.failed

When commit a28a6e860c6c ("string.h: move fortified functions definitions
in a dedicated header.") moved the fortify-specific code, some helpers
were left behind. Move the remaining fortify-specific helpers into
fortify-string.h so they're together where they're used. This requires
that any FORTIFY helper function prototypes be conditionally built to
avoid "no prototype" warnings. Additionally removes unused helpers.

	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Daniel Axtens <dja@axtens.net>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Andrey Konovalov <andreyknvl@google.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Acked-by: Francis Laniel <laniel_francis@privacyrequired.com>
	Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit c430f60036af44079170ff71a461b9d7cf5ee431)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/string_helpers.c
diff --cc lib/string_helpers.c
index 9ca19918ca26,faa9d8e4e2c5..000000000000
--- a/lib/string_helpers.c
+++ b/lib/string_helpers.c
@@@ -645,3 -673,221 +645,224 @@@ char *kstrdup_quotable_file(struct fil
  	return pathname;
  }
  EXPORT_SYMBOL_GPL(kstrdup_quotable_file);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * kfree_strarray - free a number of dynamically allocated strings contained
+  *                  in an array and the array itself
+  *
+  * @array: Dynamically allocated array of strings to free.
+  * @n: Number of strings (starting from the beginning of the array) to free.
+  *
+  * Passing a non-NULL @array and @n == 0 as well as NULL @array are valid
+  * use-cases. If @array is NULL, the function does nothing.
+  */
+ void kfree_strarray(char **array, size_t n)
+ {
+ 	unsigned int i;
+ 
+ 	if (!array)
+ 		return;
+ 
+ 	for (i = 0; i < n; i++)
+ 		kfree(array[i]);
+ 	kfree(array);
+ }
+ EXPORT_SYMBOL_GPL(kfree_strarray);
+ 
+ /**
+  * strscpy_pad() - Copy a C-string into a sized buffer
+  * @dest: Where to copy the string to
+  * @src: Where to copy the string from
+  * @count: Size of destination buffer
+  *
+  * Copy the string, or as much of it as fits, into the dest buffer.  The
+  * behavior is undefined if the string buffers overlap.  The destination
+  * buffer is always %NUL terminated, unless it's zero-sized.
+  *
+  * If the source string is shorter than the destination buffer, zeros
+  * the tail of the destination buffer.
+  *
+  * For full explanation of why you may want to consider using the
+  * 'strscpy' functions please see the function docstring for strscpy().
+  *
+  * Returns:
+  * * The number of characters copied (not including the trailing %NUL)
+  * * -E2BIG if count is 0 or @src was truncated.
+  */
+ ssize_t strscpy_pad(char *dest, const char *src, size_t count)
+ {
+ 	ssize_t written;
+ 
+ 	written = strscpy(dest, src, count);
+ 	if (written < 0 || written == count - 1)
+ 		return written;
+ 
+ 	memset(dest + written + 1, 0, count - written - 1);
+ 
+ 	return written;
+ }
+ EXPORT_SYMBOL(strscpy_pad);
+ 
+ /**
+  * skip_spaces - Removes leading whitespace from @str.
+  * @str: The string to be stripped.
+  *
+  * Returns a pointer to the first non-whitespace character in @str.
+  */
+ char *skip_spaces(const char *str)
+ {
+ 	while (isspace(*str))
+ 		++str;
+ 	return (char *)str;
+ }
+ EXPORT_SYMBOL(skip_spaces);
+ 
+ /**
+  * strim - Removes leading and trailing whitespace from @s.
+  * @s: The string to be stripped.
+  *
+  * Note that the first trailing whitespace is replaced with a %NUL-terminator
+  * in the given string @s. Returns a pointer to the first non-whitespace
+  * character in @s.
+  */
+ char *strim(char *s)
+ {
+ 	size_t size;
+ 	char *end;
+ 
+ 	size = strlen(s);
+ 	if (!size)
+ 		return s;
+ 
+ 	end = s + size - 1;
+ 	while (end >= s && isspace(*end))
+ 		end--;
+ 	*(end + 1) = '\0';
+ 
+ 	return skip_spaces(s);
+ }
+ EXPORT_SYMBOL(strim);
+ 
+ /**
+  * sysfs_streq - return true if strings are equal, modulo trailing newline
+  * @s1: one string
+  * @s2: another string
+  *
+  * This routine returns true iff two strings are equal, treating both
+  * NUL and newline-then-NUL as equivalent string terminations.  It's
+  * geared for use with sysfs input strings, which generally terminate
+  * with newlines but are compared against values without newlines.
+  */
+ bool sysfs_streq(const char *s1, const char *s2)
+ {
+ 	while (*s1 && *s1 == *s2) {
+ 		s1++;
+ 		s2++;
+ 	}
+ 
+ 	if (*s1 == *s2)
+ 		return true;
+ 	if (!*s1 && *s2 == '\n' && !s2[1])
+ 		return true;
+ 	if (*s1 == '\n' && !s1[1] && !*s2)
+ 		return true;
+ 	return false;
+ }
+ EXPORT_SYMBOL(sysfs_streq);
+ 
+ /**
+  * match_string - matches given string in an array
+  * @array:	array of strings
+  * @n:		number of strings in the array or -1 for NULL terminated arrays
+  * @string:	string to match with
+  *
+  * This routine will look for a string in an array of strings up to the
+  * n-th element in the array or until the first NULL element.
+  *
+  * Historically the value of -1 for @n, was used to search in arrays that
+  * are NULL terminated. However, the function does not make a distinction
+  * when finishing the search: either @n elements have been compared OR
+  * the first NULL element was found.
+  *
+  * Return:
+  * index of a @string in the @array if matches, or %-EINVAL otherwise.
+  */
+ int match_string(const char * const *array, size_t n, const char *string)
+ {
+ 	int index;
+ 	const char *item;
+ 
+ 	for (index = 0; index < n; index++) {
+ 		item = array[index];
+ 		if (!item)
+ 			break;
+ 		if (!strcmp(item, string))
+ 			return index;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL(match_string);
+ 
+ /**
+  * __sysfs_match_string - matches given string in an array
+  * @array: array of strings
+  * @n: number of strings in the array or -1 for NULL terminated arrays
+  * @str: string to match with
+  *
+  * Returns index of @str in the @array or -EINVAL, just like match_string().
+  * Uses sysfs_streq instead of strcmp for matching.
+  *
+  * This routine will look for a string in an array of strings up to the
+  * n-th element in the array or until the first NULL element.
+  *
+  * Historically the value of -1 for @n, was used to search in arrays that
+  * are NULL terminated. However, the function does not make a distinction
+  * when finishing the search: either @n elements have been compared OR
+  * the first NULL element was found.
+  */
+ int __sysfs_match_string(const char * const *array, size_t n, const char *str)
+ {
+ 	const char *item;
+ 	int index;
+ 
+ 	for (index = 0; index < n; index++) {
+ 		item = array[index];
+ 		if (!item)
+ 			break;
+ 		if (sysfs_streq(item, str))
+ 			return index;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL(__sysfs_match_string);
+ 
+ /**
+  * strreplace - Replace all occurrences of character in string.
+  * @s: The string to operate on.
+  * @old: The character being replaced.
+  * @new: The character @old is replaced with.
+  *
+  * Returns pointer to the nul byte at the end of @s.
+  */
+ char *strreplace(char *s, char old, char new)
+ {
+ 	for (; *s; ++s)
+ 		if (*s == old)
+ 			*s = new;
+ 	return s;
+ }
+ EXPORT_SYMBOL(strreplace);
+ 
+ #ifdef CONFIG_FORTIFY_SOURCE
+ void fortify_panic(const char *name)
+ {
+ 	pr_emerg("detected buffer overflow in %s\n", name);
+ 	BUG();
+ }
+ EXPORT_SYMBOL(fortify_panic);
+ #endif /* CONFIG_FORTIFY_SOURCE */
++>>>>>>> c430f60036af (fortify: Move remaining fortify helpers into fortify-string.h)
diff --git a/include/linux/fortify-string.h b/include/linux/fortify-string.h
index c1be37437e77..7e67d02764db 100644
--- a/include/linux/fortify-string.h
+++ b/include/linux/fortify-string.h
@@ -2,6 +2,13 @@
 #ifndef _LINUX_FORTIFY_STRING_H_
 #define _LINUX_FORTIFY_STRING_H_
 
+#define __FORTIFY_INLINE extern __always_inline __attribute__((gnu_inline))
+#define __RENAME(x) __asm__(#x)
+
+void fortify_panic(const char *name) __noreturn __cold;
+void __read_overflow(void) __compiletime_error("detected read beyond size of object (1st parameter)");
+void __read_overflow2(void) __compiletime_error("detected read beyond size of object (2nd parameter)");
+void __write_overflow(void) __compiletime_error("detected write beyond size of object (1st parameter)");
 
 #if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
 extern void *__underlying_memchr(const void *p, int c, __kernel_size_t size) __RENAME(memchr);
diff --git a/include/linux/string.h b/include/linux/string.h
index 9d0d89afb113..ef87d26ddb0e 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -257,15 +257,6 @@ static inline const char *kbasename(const char *path)
 	return tail ? tail + 1 : path;
 }
 
-#define __FORTIFY_INLINE extern __always_inline __attribute__((gnu_inline))
-#define __RENAME(x) __asm__(#x)
-
-void fortify_panic(const char *name) __noreturn __cold;
-void __read_overflow(void) __compiletime_error("detected read beyond size of object passed as 1st parameter");
-void __read_overflow2(void) __compiletime_error("detected read beyond size of object passed as 2nd parameter");
-void __read_overflow3(void) __compiletime_error("detected read beyond size of object passed as 3rd parameter");
-void __write_overflow(void) __compiletime_error("detected write beyond size of object passed as 1st parameter");
-
 #if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
 #include <linux/fortify-string.h>
 #endif
* Unmerged path lib/string_helpers.c
