kernfs: dont take i_lock on revalidate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
Rebuild_CHGLOG: - kernfs: dont take d_lock on revalidate (Ian Kent) [2126350]
Rebuild_FUZZ: 97.37%
commit-author Ian Kent <raven@themaw.net>
commit 92b57842f43014e6ca81ddf6d5d59e9ddf762e12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/92b57842.failed

In kernfs_dop_revalidate() when the passed in dentry is negative the
dentry directory is checked to see if it has changed and if so the
negative dentry is discarded so it can refreshed. During this check
the dentry inode i_lock is taken to mitigate against a possible
concurrent rename.

But if it's racing with a rename, becuase the dentry is negative, it
can't be the source it must be the target and it must be going to do
a d_move() otherwise the rename will return an error.

In this case the parent dentry of the target will not change, it will
be the same over the d_move(), only the source dentry parent may change
so the inode i_lock isn't needed.

	Cc: Tejun Heo <tj@kernel.org>
	Signed-off-by: Ian Kent <raven@themaw.net>
Link: https://lore.kernel.org/r/166606036967.13363.9336408133975631967.stgit@donald.themaw.net
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 92b57842f43014e6ca81ddf6d5d59e9ddf762e12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/dir.c
diff --cc fs/kernfs/dir.c
index baa2c1382a0d,6acd9c3d4cff..000000000000
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@@ -1048,9 -1073,22 +1048,27 @@@ static int kernfs_dop_revalidate(struc
  
  		/* If the kernfs parent node has changed discard and
  		 * proceed to ->lookup.
+ 		 *
+ 		 * There's nothing special needed here when getting the
+ 		 * dentry parent, even if a concurrent rename is in
+ 		 * progress. That's because the dentry is negative so
+ 		 * it can only be the target of the rename and it will
+ 		 * be doing a d_move() not a replace. Consequently the
+ 		 * dentry d_parent won't change over the d_move().
+ 		 *
+ 		 * Also kernfs negative dentries transitioning from
+ 		 * negative to positive during revalidate won't happen
+ 		 * because they are invalidated on containing directory
+ 		 * changes and the lookup re-done so that a new positive
+ 		 * dentry can be properly created.
  		 */
++<<<<<<< HEAD
 +		down_read(&kernfs_rwsem);
 +		spin_lock(&dentry->d_lock);
++=======
+ 		root = kernfs_root_from_sb(dentry->d_sb);
+ 		down_read(&root->kernfs_rwsem);
++>>>>>>> 92b57842f430 (kernfs: dont take i_lock on revalidate)
  		parent = kernfs_dentry_node(dentry->d_parent);
  		if (parent) {
  			if (kernfs_dir_changed(parent, dentry)) {
@@@ -1059,8 -1096,7 +1077,12 @@@
  				return 0;
  			}
  		}
++<<<<<<< HEAD
 +		spin_unlock(&dentry->d_lock);
 +		up_read(&kernfs_rwsem);
++=======
+ 		up_read(&root->kernfs_rwsem);
++>>>>>>> 92b57842f430 (kernfs: dont take i_lock on revalidate)
  
  		/* The kernfs parent node hasn't changed, leave the
  		 * dentry negative and return success.
* Unmerged path fs/kernfs/dir.c
