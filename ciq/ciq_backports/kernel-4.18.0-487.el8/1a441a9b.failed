netfilter: flowtable: cache info of last offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit 1a441a9b8be8849957a01413a144f84932c324cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/1a441a9b.failed

Modify flow table offload to cache the last ct info status that was passed
to the driver offload callbacks by extending enum nf_flow_flags with new
"NF_FLOW_HW_ESTABLISHED" flag. Set the flag if ctinfo was 'established'
during last act_ct meta actions fill call. This infrastructure change is
necessary to optimize promoting of UDP connections from 'new' to
'established' in following patches in this series.

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1a441a9b8be8849957a01413a144f84932c324cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_offload.c
diff --cc net/netfilter/nf_flow_table_offload.c
index ecbcf8493f18,1c26f03fc661..000000000000
--- a/net/netfilter/nf_flow_table_offload.c
+++ b/net/netfilter/nf_flow_table_offload.c
@@@ -528,6 -639,53 +528,56 @@@ int nf_flow_rule_route_ipv4(struct net 
  	    flow_offload_eth_dst(net, flow, dir, flow_rule) < 0)
  		return -1;
  
++<<<<<<< HEAD
++=======
+ 	tuple = &flow->tuplehash[dir].tuple;
+ 
+ 	for (i = 0; i < tuple->encap_num; i++) {
+ 		struct flow_action_entry *entry;
+ 
+ 		if (tuple->in_vlan_ingress & BIT(i))
+ 			continue;
+ 
+ 		if (tuple->encap[i].proto == htons(ETH_P_8021Q)) {
+ 			entry = flow_action_entry_next(flow_rule);
+ 			entry->id = FLOW_ACTION_VLAN_POP;
+ 		}
+ 	}
+ 
+ 	other_tuple = &flow->tuplehash[!dir].tuple;
+ 
+ 	for (i = 0; i < other_tuple->encap_num; i++) {
+ 		struct flow_action_entry *entry;
+ 
+ 		if (other_tuple->in_vlan_ingress & BIT(i))
+ 			continue;
+ 
+ 		entry = flow_action_entry_next(flow_rule);
+ 
+ 		switch (other_tuple->encap[i].proto) {
+ 		case htons(ETH_P_PPP_SES):
+ 			entry->id = FLOW_ACTION_PPPOE_PUSH;
+ 			entry->pppoe.sid = other_tuple->encap[i].id;
+ 			break;
+ 		case htons(ETH_P_8021Q):
+ 			entry->id = FLOW_ACTION_VLAN_PUSH;
+ 			entry->vlan.vid = other_tuple->encap[i].id;
+ 			entry->vlan.proto = other_tuple->encap[i].proto;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int nf_flow_rule_route_ipv4(struct net *net, struct flow_offload *flow,
+ 			    enum flow_offload_tuple_dir dir,
+ 			    struct nf_flow_rule *flow_rule)
+ {
+ 	if (nf_flow_rule_route_common(net, flow, dir, flow_rule) < 0)
+ 		return -1;
+ 
++>>>>>>> 1a441a9b8be8 (netfilter: flowtable: cache info of last offload)
  	if (test_bit(NF_FLOW_SNAT, &flow->flags)) {
  		flow_offload_ipv4_snat(net, flow, dir, flow_rule);
  		flow_offload_port_snat(net, flow, dir, flow_rule);
@@@ -580,10 -734,10 +630,16 @@@ nf_flow_offload_rule_alloc(struct net *
  			   enum flow_offload_tuple_dir dir)
  {
  	const struct nf_flowtable *flowtable = offload->flowtable;
++<<<<<<< HEAD
 +	const struct flow_offload *flow = offload->flow;
 +	const struct flow_offload_tuple *tuple;
++=======
+ 	const struct flow_offload_tuple *tuple, *other_tuple;
+ 	struct flow_offload *flow = offload->flow;
+ 	struct dst_entry *other_dst = NULL;
++>>>>>>> 1a441a9b8be8 (netfilter: flowtable: cache info of last offload)
  	struct nf_flow_rule *flow_rule;
 +	struct dst_entry *other_dst;
  	int err = -ENOMEM;
  
  	flow_rule = kzalloc(sizeof(*flow_rule), GFP_KERNEL);
diff --git a/include/net/netfilter/nf_flow_table.h b/include/net/netfilter/nf_flow_table.h
index 466b050edf20..5cb275c17a88 100644
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@ -52,7 +52,7 @@ struct nf_flowtable_type {
 						 struct net_device *dev,
 						 enum flow_block_command cmd);
 	int				(*action)(struct net *net,
-						  const struct flow_offload *flow,
+						  struct flow_offload *flow,
 						  enum flow_offload_tuple_dir dir,
 						  struct nf_flow_rule *flow_rule);
 	void				(*free)(struct nf_flowtable *ft);
@@ -127,6 +127,7 @@ enum nf_flow_flags {
 	NF_FLOW_HW_DEAD,
 	NF_FLOW_HW_PENDING,
 	NF_FLOW_HW_BIDIRECTIONAL,
+	NF_FLOW_HW_ESTABLISHED,
 };
 
 enum flow_offload_type {
@@ -259,10 +260,10 @@ void nf_flow_table_offload_flush_cleanup(struct nf_flowtable *flowtable);
 int nf_flow_table_offload_setup(struct nf_flowtable *flowtable,
 				struct net_device *dev,
 				enum flow_block_command cmd);
-int nf_flow_rule_route_ipv4(struct net *net, const struct flow_offload *flow,
+int nf_flow_rule_route_ipv4(struct net *net, struct flow_offload *flow,
 			    enum flow_offload_tuple_dir dir,
 			    struct nf_flow_rule *flow_rule);
-int nf_flow_rule_route_ipv6(struct net *net, const struct flow_offload *flow,
+int nf_flow_rule_route_ipv6(struct net *net, struct flow_offload *flow,
 			    enum flow_offload_tuple_dir dir,
 			    struct nf_flow_rule *flow_rule);
 
diff --git a/net/netfilter/nf_flow_table_inet.c b/net/netfilter/nf_flow_table_inet.c
index 2a7e4f70740f..a05eb345b98e 100644
--- a/net/netfilter/nf_flow_table_inet.c
+++ b/net/netfilter/nf_flow_table_inet.c
@@ -21,7 +21,7 @@ nf_flow_offload_inet_hook(void *priv, struct sk_buff *skb,
 }
 
 static int nf_flow_rule_route_inet(struct net *net,
-				   const struct flow_offload *flow,
+				   struct flow_offload *flow,
 				   enum flow_offload_tuple_dir dir,
 				   struct nf_flow_rule *flow_rule)
 {
* Unmerged path net/netfilter/nf_flow_table_offload.c
diff --git a/net/sched/act_ct.c b/net/sched/act_ct.c
index 76785fdbe97a..0fd273042760 100644
--- a/net/sched/act_ct.c
+++ b/net/sched/act_ct.c
@@ -168,11 +168,11 @@ tcf_ct_flow_table_add_action_nat_udp(const struct nf_conntrack_tuple *tuple,
 
 static void tcf_ct_flow_table_add_action_meta(struct nf_conn *ct,
 					      enum ip_conntrack_dir dir,
+					      enum ip_conntrack_info ctinfo,
 					      struct flow_action *action)
 {
 	struct nf_conn_labels *ct_labels;
 	struct flow_action_entry *entry;
-	enum ip_conntrack_info ctinfo;
 	u32 *act_ct_labels;
 
 	entry = tcf_ct_flow_table_flow_action_get_next(action);
@@ -180,8 +180,6 @@ static void tcf_ct_flow_table_add_action_meta(struct nf_conn *ct,
 #if IS_ENABLED(CONFIG_NF_CONNTRACK_MARK)
 	entry->ct_metadata.mark = ct->mark;
 #endif
-	ctinfo = dir == IP_CT_DIR_ORIGINAL ? IP_CT_ESTABLISHED :
-					     IP_CT_ESTABLISHED_REPLY;
 	/* aligns with the CT reference on the SKB nf_ct_set */
 	entry->ct_metadata.cookie = (unsigned long)ct | ctinfo;
 	entry->ct_metadata.orig_dir = dir == IP_CT_DIR_ORIGINAL;
@@ -235,22 +233,26 @@ static int tcf_ct_flow_table_add_action_nat(struct net *net,
 }
 
 static int tcf_ct_flow_table_fill_actions(struct net *net,
-					  const struct flow_offload *flow,
+					  struct flow_offload *flow,
 					  enum flow_offload_tuple_dir tdir,
 					  struct nf_flow_rule *flow_rule)
 {
 	struct flow_action *action = &flow_rule->rule->action;
 	int num_entries = action->num_entries;
 	struct nf_conn *ct = flow->ct;
+	enum ip_conntrack_info ctinfo;
 	enum ip_conntrack_dir dir;
 	int i, err;
 
 	switch (tdir) {
 	case FLOW_OFFLOAD_DIR_ORIGINAL:
 		dir = IP_CT_DIR_ORIGINAL;
+		ctinfo = IP_CT_ESTABLISHED;
+		set_bit(NF_FLOW_HW_ESTABLISHED, &flow->flags);
 		break;
 	case FLOW_OFFLOAD_DIR_REPLY:
 		dir = IP_CT_DIR_REPLY;
+		ctinfo = IP_CT_ESTABLISHED_REPLY;
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -260,7 +262,7 @@ static int tcf_ct_flow_table_fill_actions(struct net *net,
 	if (err)
 		goto err_nat;
 
-	tcf_ct_flow_table_add_action_meta(ct, dir, action);
+	tcf_ct_flow_table_add_action_meta(ct, dir, ctinfo, action);
 	return 0;
 
 err_nat:
