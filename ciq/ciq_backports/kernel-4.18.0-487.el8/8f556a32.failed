locking/rtmutex: Fix incorrect condition in rtmutex_spin_on_owner()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Zqiang <qiang1.zhang@intel.com>
commit 8f556a326c93213927e683fc32bbf5be1b62540a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/8f556a32.failed

Optimistic spinning needs to be terminated when the spinning waiter is not
longer the top waiter on the lock, but the condition is negated. It
terminates if the waiter is the top waiter, which is defeating the whole
purpose.

Fixes: c3123c431447 ("locking/rtmutex: Dont dereference waiter lockless")
	Signed-off-by: Zqiang <qiang1.zhang@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20211217074207.77425-1-qiang1.zhang@intel.com
(cherry picked from commit 8f556a326c93213927e683fc32bbf5be1b62540a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/rtmutex.c
diff --cc kernel/locking/rtmutex.c
index 0bca38d1110b,1f25a4d7de27..000000000000
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@@ -1371,8 -1379,9 +1371,14 @@@ static bool rtmutex_spin_on_owner(struc
  		 *    for CONFIG_PREEMPT_RCU=y)
  		 *  - the VCPU on which owner runs is preempted
  		 */
++<<<<<<< HEAD
 +		if (!owner_on_cpu(owner) || need_resched() ||
 +		    rt_mutex_waiter_is_top_waiter(lock, waiter)) {
++=======
+ 		if (!owner->on_cpu || need_resched() ||
+ 		    !rt_mutex_waiter_is_top_waiter(lock, waiter) ||
+ 		    vcpu_is_preempted(task_cpu(owner))) {
++>>>>>>> 8f556a326c93 (locking/rtmutex: Fix incorrect condition in rtmutex_spin_on_owner())
  			res = false;
  			break;
  		}
* Unmerged path kernel/locking/rtmutex.c
