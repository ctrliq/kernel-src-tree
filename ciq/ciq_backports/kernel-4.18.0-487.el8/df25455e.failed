netfilter: nf_conntrack: allow early drop of offloaded UDP conns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-487.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit df25455e5a489764508942b77b77de8f550e92cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-487.el8/df25455e.failed

Both synchronous early drop algorithm and asynchronous gc worker completely
ignore connections with IPS_OFFLOAD_BIT status bit set. With new
functionality that enabled UDP NEW connection offload in action CT
malicious user can flood the conntrack table with offloaded UDP connections
by just sending a single packet per 5tuple because such connections can no
longer be deleted by early drop algorithm.

To mitigate the issue allow both early drop and gc to consider offloaded
UDP connections for deletion.

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df25455e5a489764508942b77b77de8f550e92cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 8316da3b38a4,9a830573480e..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1327,7 -1447,7 +1327,11 @@@ static bool gc_worker_can_early_drop(co
  	if (!test_bit(IPS_ASSURED_BIT, &ct->status))
  		return true;
  
++<<<<<<< HEAD
 +	l4proto = __nf_ct_l4proto_find(nf_ct_protonum(ct));
++=======
+ 	l4proto = nf_ct_l4proto_find(protonum);
++>>>>>>> df25455e5a48 (netfilter: nf_conntrack: allow early drop of offloaded UDP conns)
  	if (l4proto->can_early_drop && l4proto->can_early_drop(ct))
  		return true;
  
@@@ -1369,12 -1501,27 +1373,13 @@@ static void gc_worker(struct work_struc
  
  			tmp = nf_ct_tuplehash_to_ctrack(h);
  
 +			scanned++;
  			if (test_bit(IPS_OFFLOAD_BIT, &tmp->status)) {
  				nf_ct_offload_timeout(tmp);
- 				continue;
+ 				if (!nf_conntrack_max95)
+ 					continue;
  			}
  
 -			if (expired_count > GC_SCAN_EXPIRED_MAX) {
 -				rcu_read_unlock();
 -
 -				gc_work->next_bucket = i;
 -				gc_work->avg_timeout = next_run;
 -				gc_work->count = count;
 -
 -				delta_time = nfct_time_stamp - gc_work->start_time;
 -
 -				/* re-sched immediately if total cycle time is exceeded */
 -				next_run = delta_time < (s32)GC_SCAN_INTERVAL_MAX;
 -				goto early_exit;
 -			}
 -
  			if (nf_ct_is_expired(tmp)) {
  				nf_ct_gc_expired(tmp);
  				expired_count++;
* Unmerged path net/netfilter/nf_conntrack_core.c
