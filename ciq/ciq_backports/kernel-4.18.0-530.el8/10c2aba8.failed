ibmveth: Ethtool set queue support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-530.el8
commit-author Nick Child <nnac123@linux.ibm.com>
commit 10c2aba89cc0535b23ebc795f44b8b8b16785ec9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-530.el8/10c2aba8.failed

Implement channel management functions to allow dynamic addition and
removal of transmit queues. The `ethtool --show-channels` and
`ethtool --set-channels` commands can be used to get and set the
number of queues, respectively. Allow the ability to add as many
transmit queues as available processors but never allow more than the
hard maximum of 16. The number of receive queues is one and cannot be
modified.

Depending on whether the requested number of queues is larger or
smaller than the current value, either allocate or free long term
buffers. Since long term buffer construction and destruction can
occur in two different areas, from either channel set requests or
device open/close, define functions for performing this work. If
allocation of a new buffer fails, then attempt to revert back to the
previous number of queues.

	Signed-off-by: Nick Child <nnac123@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 10c2aba89cc0535b23ebc795f44b8b8b16785ec9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmveth.c
diff --cc drivers/net/ethernet/ibm/ibmveth.c
index 4964de1079a5,3b14dc93f59d..000000000000
--- a/drivers/net/ethernet/ibm/ibmveth.c
+++ b/drivers/net/ethernet/ibm/ibmveth.c
@@@ -991,13 -992,79 +1009,88 @@@ static void ibmveth_get_ethtool_stats(s
  		data[i] = IBMVETH_GET_STAT(adapter, ibmveth_stats[i].offset);
  }
  
+ static void ibmveth_get_channels(struct net_device *netdev,
+ 				 struct ethtool_channels *channels)
+ {
+ 	channels->max_tx = ibmveth_real_max_tx_queues();
+ 	channels->tx_count = netdev->real_num_tx_queues;
+ 
+ 	channels->max_rx = netdev->real_num_rx_queues;
+ 	channels->rx_count = netdev->real_num_rx_queues;
+ }
+ 
+ static int ibmveth_set_channels(struct net_device *netdev,
+ 				struct ethtool_channels *channels)
+ {
+ 	struct ibmveth_adapter *adapter = netdev_priv(netdev);
+ 	unsigned int old = netdev->real_num_tx_queues,
+ 		     goal = channels->tx_count;
+ 	int rc, i;
+ 
+ 	/* If ndo_open has not been called yet then don't allocate, just set
+ 	 * desired netdev_queue's and return
+ 	 */
+ 	if (!(netdev->flags & IFF_UP))
+ 		return netif_set_real_num_tx_queues(netdev, goal);
+ 
+ 	/* We have IBMVETH_MAX_QUEUES netdev_queue's allocated
+ 	 * but we may need to alloc/free the ltb's.
+ 	 */
+ 	netif_tx_stop_all_queues(netdev);
+ 
+ 	/* Allocate any queue that we need */
+ 	for (i = old; i < goal; i++) {
+ 		if (adapter->tx_ltb_ptr[i])
+ 			continue;
+ 
+ 		rc = ibmveth_allocate_tx_ltb(adapter, i);
+ 		if (!rc)
+ 			continue;
+ 
+ 		/* if something goes wrong, free everything we just allocated */
+ 		netdev_err(netdev, "Failed to allocate more tx queues, returning to %d queues\n",
+ 			   old);
+ 		goal = old;
+ 		old = i;
+ 		break;
+ 	}
+ 	rc = netif_set_real_num_tx_queues(netdev, goal);
+ 	if (rc) {
+ 		netdev_err(netdev, "Failed to set real tx queues, returning to %d queues\n",
+ 			   old);
+ 		goal = old;
+ 		old = i;
+ 	}
+ 	/* Free any that are no longer needed */
+ 	for (i = old; i > goal; i--) {
+ 		if (adapter->tx_ltb_ptr[i - 1])
+ 			ibmveth_free_tx_ltb(adapter, i - 1);
+ 	}
+ 
+ 	netif_tx_wake_all_queues(netdev);
+ 
+ 	return rc;
+ }
+ 
  static const struct ethtool_ops netdev_ethtool_ops = {
++<<<<<<< HEAD
 +	.get_drvinfo		= netdev_get_drvinfo,
 +	.get_link		= ethtool_op_get_link,
 +	.get_strings		= ibmveth_get_strings,
 +	.get_sset_count		= ibmveth_get_sset_count,
 +	.get_ethtool_stats	= ibmveth_get_ethtool_stats,
 +	.get_link_ksettings	= netdev_get_link_ksettings,
++=======
+ 	.get_drvinfo		         = netdev_get_drvinfo,
+ 	.get_link		         = ethtool_op_get_link,
+ 	.get_strings		         = ibmveth_get_strings,
+ 	.get_sset_count		         = ibmveth_get_sset_count,
+ 	.get_ethtool_stats	         = ibmveth_get_ethtool_stats,
+ 	.get_link_ksettings	         = ibmveth_get_link_ksettings,
+ 	.set_link_ksettings              = ibmveth_set_link_ksettings,
+ 	.get_channels			 = ibmveth_get_channels,
+ 	.set_channels			 = ibmveth_set_channels
++>>>>>>> 10c2aba89cc0 (ibmveth: Ethtool set queue support)
  };
  
  static int ibmveth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
* Unmerged path drivers/net/ethernet/ibm/ibmveth.c
