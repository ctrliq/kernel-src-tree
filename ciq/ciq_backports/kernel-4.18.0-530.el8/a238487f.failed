crypto: qat - fix ring to service map for QAT GEN4

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-530.el8
commit-author Giovanni Cabiddu <giovanni.cabiddu@intel.com>
commit a238487f7965d102794ed9f8aff0b667cd2ae886
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-530.el8/a238487f.failed

The 4xxx drivers hardcode the ring to service mapping. However, when
additional configurations where added to the driver, the mappings were
not updated. This implies that an incorrect mapping might be reported
through pfvf for certain configurations.

Add an algorithm that computes the correct ring to service mapping based
on the firmware loaded on the device.

Fixes: 0cec19c761e5 ("crypto: qat - add support for compression for 4xxx")
	Signed-off-by: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
	Reviewed-by: Damian Muszynski <damian.muszynski@intel.com>
	Reviewed-by: Tero Kristo <tero.kristo@linux.intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit a238487f7965d102794ed9f8aff0b667cd2ae886)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
diff --cc drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
index 3eda91aa7c11,37bb2b3618cd..000000000000
--- a/drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
+++ b/drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
@@@ -383,6 -399,84 +383,87 @@@ static u32 uof_get_num_objs(void
  	return ARRAY_SIZE(adf_fw_cy_config);
  }
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
++=======
+ static const struct adf_fw_config *get_fw_config(struct adf_accel_dev *accel_dev)
+ {
+ 	switch (get_service_enabled(accel_dev)) {
+ 	case SVC_CY:
+ 	case SVC_CY2:
+ 		return adf_fw_cy_config;
+ 	case SVC_DC:
+ 		return adf_fw_dc_config;
+ 	case SVC_DCC:
+ 		return adf_fw_dcc_config;
+ 	case SVC_SYM:
+ 		return adf_fw_sym_config;
+ 	case SVC_ASYM:
+ 		return adf_fw_asym_config;
+ 	case SVC_ASYM_DC:
+ 	case SVC_DC_ASYM:
+ 		return adf_fw_asym_dc_config;
+ 	case SVC_SYM_DC:
+ 	case SVC_DC_SYM:
+ 		return adf_fw_sym_dc_config;
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ enum adf_rp_groups {
+ 	RP_GROUP_0 = 0,
+ 	RP_GROUP_1,
+ 	RP_GROUP_COUNT
+ };
+ 
+ static u16 get_ring_to_svc_map(struct adf_accel_dev *accel_dev)
+ {
+ 	enum adf_cfg_service_type rps[RP_GROUP_COUNT];
+ 	const struct adf_fw_config *fw_config;
+ 	u16 ring_to_svc_map;
+ 	int i, j;
+ 
+ 	fw_config = get_fw_config(accel_dev);
+ 	if (!fw_config)
+ 		return 0;
+ 
+ 	for (i = 0; i < RP_GROUP_COUNT; i++) {
+ 		switch (fw_config[i].ae_mask) {
+ 		case ADF_AE_GROUP_0:
+ 			j = RP_GROUP_0;
+ 			break;
+ 		case ADF_AE_GROUP_1:
+ 			j = RP_GROUP_1;
+ 			break;
+ 		default:
+ 			return 0;
+ 		}
+ 
+ 		switch (fw_config[i].obj) {
+ 		case ADF_FW_SYM_OBJ:
+ 			rps[j] = SYM;
+ 			break;
+ 		case ADF_FW_ASYM_OBJ:
+ 			rps[j] = ASYM;
+ 			break;
+ 		case ADF_FW_DC_OBJ:
+ 			rps[j] = COMP;
+ 			break;
+ 		default:
+ 			rps[j] = 0;
+ 			break;
+ 		}
+ 	}
+ 
+ 	ring_to_svc_map = rps[RP_GROUP_0] << ADF_CFG_SERV_RING_PAIR_0_SHIFT |
+ 			  rps[RP_GROUP_1] << ADF_CFG_SERV_RING_PAIR_1_SHIFT |
+ 			  rps[RP_GROUP_0] << ADF_CFG_SERV_RING_PAIR_2_SHIFT |
+ 			  rps[RP_GROUP_1] << ADF_CFG_SERV_RING_PAIR_3_SHIFT;
+ 
+ 	return ring_to_svc_map;
+ }
+ 
++>>>>>>> a238487f7965 (crypto: qat - fix ring to service map for QAT GEN4):drivers/crypto/intel/qat/qat_4xxx/adf_4xxx_hw_data.c
  static const char *uof_get_name(struct adf_accel_dev *accel_dev, u32 obj_num,
  				const char * const fw_objs[], int num_objs)
  {
* Unmerged path drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
diff --git a/drivers/crypto/qat/qat_common/adf_accel_devices.h b/drivers/crypto/qat/qat_common/adf_accel_devices.h
index c43e39c34d9b..5970eb1a4218 100644
--- a/drivers/crypto/qat/qat_common/adf_accel_devices.h
+++ b/drivers/crypto/qat/qat_common/adf_accel_devices.h
@@ -182,6 +182,7 @@ struct adf_hw_device_data {
 	void (*get_arb_info)(struct arb_info *arb_csrs_info);
 	void (*get_admin_info)(struct admin_info *admin_csrs_info);
 	enum dev_sku_info (*get_sku)(struct adf_hw_device_data *self);
+	u16 (*get_ring_to_svc_map)(struct adf_accel_dev *accel_dev);
 	int (*alloc_irq)(struct adf_accel_dev *accel_dev);
 	void (*free_irq)(struct adf_accel_dev *accel_dev);
 	void (*enable_error_correction)(struct adf_accel_dev *accel_dev);
diff --git a/drivers/crypto/qat/qat_common/adf_init.c b/drivers/crypto/qat/qat_common/adf_init.c
index 55c4bf1a3b16..2e8c08820221 100644
--- a/drivers/crypto/qat/qat_common/adf_init.c
+++ b/drivers/crypto/qat/qat_common/adf_init.c
@@ -95,6 +95,9 @@ static int adf_dev_init(struct adf_accel_dev *accel_dev)
 		return -EFAULT;
 	}
 
+	if (hw_data->get_ring_to_svc_map)
+		hw_data->ring_to_svc_map = hw_data->get_ring_to_svc_map(accel_dev);
+
 	if (adf_ae_init(accel_dev)) {
 		dev_err(&GET_DEV(accel_dev),
 			"Failed to initialise Acceleration Engine\n");
