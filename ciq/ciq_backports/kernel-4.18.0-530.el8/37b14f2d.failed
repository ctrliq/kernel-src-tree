crypto: qat - enable dc chaining service

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-530.el8
commit-author Adam Guerin <adam.guerin@intel.com>
commit 37b14f2dfa791fd485dbc536f8d1ffe8c6990290
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-530.el8/37b14f2d.failed

QAT GEN4 devices support chained compression operations. These
allow, with a single request to firmware, to hash then compress
data.

Extend the configuration to enable such mode. The cfg_services
operations in sysfs are extended to allow the string "dcc". When
selected, the driver downloads to the device both the symmetric
crypto and the compression firmware images and sends an admin message
to firmware which enables `chained` operations.
In addition, it sets the device's capabilities as the combination
of compression and symmetric crypto capabilities, while excluding
the ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC bit to indicate
that in this mode, symmetric crypto instances are not supported.

When "dcc" is enabled, the device will handle compression requests
as if the "dc" configuration is loaded ("dcc" is a variation of "dc")
and the driver will register the acomp algorithms.

As for the other extended configurations, "dcc" is only available for
qat_4xxx devices and the chaining service will be only accessible from
user space.

	Signed-off-by: Adam Guerin <adam.guerin@intel.com>
	Reviewed-by: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 37b14f2dfa791fd485dbc536f8d1ffe8c6990290)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/intel/qat/qat_common/adf_cfg_services.h
#	drivers/crypto/qat/qat_4xxx/adf_drv.c
#	drivers/crypto/qat/qat_common/adf_admin.c
#	drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
diff --cc drivers/crypto/qat/qat_4xxx/adf_drv.c
index 3f92d9e7e814,90f5c1ca7b8d..000000000000
--- a/drivers/crypto/qat/qat_4xxx/adf_drv.c
+++ b/drivers/crypto/qat/qat_4xxx/adf_drv.c
@@@ -293,11 -274,12 +293,16 @@@ int adf_gen4_dev_config(struct adf_acce
  		goto err;
  
  	switch (ret) {
 -	case SVC_CY:
 -	case SVC_CY2:
 +	case DEV_CFG_CY:
 +	case DEV_CFG_ASYM_SYM:
  		ret = adf_crypto_dev_config(accel_dev);
  		break;
++<<<<<<< HEAD:drivers/crypto/qat/qat_4xxx/adf_drv.c
 +	case DEV_CFG_DC:
++=======
+ 	case SVC_DC:
+ 	case SVC_DCC:
++>>>>>>> 37b14f2dfa79 (crypto: qat - enable dc chaining service):drivers/crypto/intel/qat/qat_4xxx/adf_drv.c
  		ret = adf_comp_dev_config(accel_dev);
  		break;
  	default:
diff --cc drivers/crypto/qat/qat_common/adf_admin.c
index 118775ee02f2,194d64d4b99a..000000000000
--- a/drivers/crypto/qat/qat_common/adf_admin.c
+++ b/drivers/crypto/qat/qat_common/adf_admin.c
@@@ -8,6 -8,8 +8,11 @@@
  #include <linux/dma-mapping.h>
  #include "adf_accel_devices.h"
  #include "adf_common_drv.h"
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/adf_admin.c
++=======
+ #include "adf_cfg.h"
+ #include "adf_heartbeat.h"
++>>>>>>> 37b14f2dfa79 (crypto: qat - enable dc chaining service):drivers/crypto/intel/qat/qat_common/adf_admin.c
  #include "icp_qat_fw_init_admin.h"
  
  #define ADF_ADMIN_MAILBOX_STRIDE 0x1000
@@@ -194,6 -197,33 +199,36 @@@ static int adf_set_fw_constants(struct 
  	return adf_send_admin(accel_dev, &req, &resp, ae_mask);
  }
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/adf_admin.c
++=======
+ int adf_get_fw_timestamp(struct adf_accel_dev *accel_dev, u64 *timestamp)
+ {
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	struct icp_qat_fw_init_admin_resp resp;
+ 	unsigned int ae_mask = ADF_ONE_AE;
+ 	int ret;
+ 
+ 	req.cmd_id = ICP_QAT_FW_TIMER_GET;
+ 	ret = adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ 	if (ret)
+ 		return ret;
+ 
+ 	*timestamp = resp.timestamp;
+ 	return 0;
+ }
+ 
+ static int adf_set_chaining(struct adf_accel_dev *accel_dev)
+ {
+ 	u32 ae_mask = GET_HW_DATA(accel_dev)->ae_mask;
+ 	struct icp_qat_fw_init_admin_resp resp = { };
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 
+ 	req.cmd_id = ICP_QAT_FW_DC_CHAIN_INIT;
+ 
+ 	return adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ }
+ 
++>>>>>>> 37b14f2dfa79 (crypto: qat - enable dc chaining service):drivers/crypto/intel/qat/qat_common/adf_admin.c
  static int adf_get_dc_capabilities(struct adf_accel_dev *accel_dev,
  				   u32 *capabilities)
  {
@@@ -223,6 -253,62 +258,65 @@@
  	return 0;
  }
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/adf_admin.c
++=======
+ int adf_get_ae_fw_counters(struct adf_accel_dev *accel_dev, u16 ae, u64 *reqs, u64 *resps)
+ {
+ 	struct icp_qat_fw_init_admin_resp resp = { };
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	int ret;
+ 
+ 	req.cmd_id = ICP_QAT_FW_COUNTERS_GET;
+ 
+ 	ret = adf_put_admin_msg_sync(accel_dev, ae, &req, &resp);
+ 	if (ret || resp.status)
+ 		return -EFAULT;
+ 
+ 	*reqs = resp.req_rec_count;
+ 	*resps = resp.resp_sent_count;
+ 
+ 	return 0;
+ }
+ 
+ int adf_send_admin_tim_sync(struct adf_accel_dev *accel_dev, u32 cnt)
+ {
+ 	u32 ae_mask = accel_dev->hw_device->ae_mask;
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	struct icp_qat_fw_init_admin_resp resp = { };
+ 
+ 	req.cmd_id = ICP_QAT_FW_SYNC;
+ 	req.int_timer_ticks = cnt;
+ 
+ 	return adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ }
+ 
+ int adf_send_admin_hb_timer(struct adf_accel_dev *accel_dev, uint32_t ticks)
+ {
+ 	u32 ae_mask = accel_dev->hw_device->ae_mask;
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	struct icp_qat_fw_init_admin_resp resp;
+ 
+ 	req.cmd_id = ICP_QAT_FW_HEARTBEAT_TIMER_SET;
+ 	req.init_cfg_ptr = accel_dev->heartbeat->dma.phy_addr;
+ 	req.heartbeat_ticks = ticks;
+ 
+ 	return adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ }
+ 
+ static bool is_dcc_enabled(struct adf_accel_dev *accel_dev)
+ {
+ 	char services[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};
+ 	int ret;
+ 
+ 	ret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,
+ 				      ADF_SERVICES_ENABLED, services);
+ 	if (ret)
+ 		return false;
+ 
+ 	return !strcmp(services, "dcc");
+ }
+ 
++>>>>>>> 37b14f2dfa79 (crypto: qat - enable dc chaining service):drivers/crypto/intel/qat/qat_common/adf_admin.c
  /**
   * adf_send_admin_init() - Function sends init message to FW
   * @accel_dev: Pointer to acceleration device.
diff --cc drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
index 56cb827f93ea,019a6443834e..000000000000
--- a/drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
+++ b/drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
@@@ -16,6 -16,9 +16,12 @@@ enum icp_qat_fw_init_admin_cmd_id 
  	ICP_QAT_FW_HEARTBEAT_SYNC = 7,
  	ICP_QAT_FW_HEARTBEAT_GET = 8,
  	ICP_QAT_FW_COMP_CAPABILITY_GET = 9,
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
++=======
+ 	ICP_QAT_FW_DC_CHAIN_INIT = 11,
+ 	ICP_QAT_FW_HEARTBEAT_TIMER_SET = 13,
+ 	ICP_QAT_FW_TIMER_GET = 19,
++>>>>>>> 37b14f2dfa79 (crypto: qat - enable dc chaining service):drivers/crypto/intel/qat/qat_common/icp_qat_fw_init_admin.h
  	ICP_QAT_FW_PM_STATE_CONFIG = 128,
  };
  
* Unmerged path drivers/crypto/intel/qat/qat_common/adf_cfg_services.h
diff --git a/Documentation/ABI/testing/sysfs-driver-qat b/Documentation/ABI/testing/sysfs-driver-qat
index ef6d6c57105e..96834d103a09 100644
--- a/Documentation/ABI/testing/sysfs-driver-qat
+++ b/Documentation/ABI/testing/sysfs-driver-qat
@@ -29,6 +29,8 @@ Description:	(RW) Reports the current configuration of the QAT device.
 		  services
 		* asym;sym: identical to sym;asym
 		* dc: the device is configured for running compression services
+		* dcc: identical to dc but enables the dc chaining feature,
+		  hash then compression. If this is not required chose dc
 		* sym: the device is configured for running symmetric crypto
 		  services
 		* asym: the device is configured for running asymmetric crypto
* Unmerged path drivers/crypto/intel/qat/qat_common/adf_cfg_services.h
diff --git a/drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c b/drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
index 3eda91aa7c11..63f80634c6ab 100644
--- a/drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
+++ b/drivers/crypto/qat/qat_4xxx/adf_4xxx_hw_data.c
@@ -73,11 +73,18 @@ static const struct adf_fw_config adf_fw_sym_dc_config[] = {
 	{0x100, ADF_FW_ADMIN_OBJ},
 };
 
+static const struct adf_fw_config adf_fw_dcc_config[] = {
+	{0xF0, ADF_FW_DC_OBJ},
+	{0xF, ADF_FW_SYM_OBJ},
+	{0x100, ADF_FW_ADMIN_OBJ},
+};
+
 static_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_dc_config));
 static_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_sym_config));
 static_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_asym_config));
 static_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_asym_dc_config));
 static_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_sym_dc_config));
+static_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_dcc_config));
 
 /* Worker thread to service arbiter mappings */
 static const u32 default_thrd_to_arb_map[ADF_4XXX_MAX_ACCELENGINES] = {
@@ -92,6 +99,12 @@ static const u32 thrd_to_arb_map_dc[ADF_4XXX_MAX_ACCELENGINES] = {
 	0x0
 };
 
+static const u32 thrd_to_arb_map_dcc[ADF_4XXX_MAX_ACCELENGINES] = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0000FFFF, 0x0000FFFF, 0x0000FFFF, 0x0000FFFF,
+	0x0
+};
+
 static struct adf_hw_device_class adf_4xxx_class = {
 	.name = ADF_4XXX_DEVICE_NAME,
 	.type = DEV_4XXX,
@@ -210,6 +223,7 @@ static u32 get_accel_cap(struct adf_accel_dev *accel_dev)
 {
 	struct pci_dev *pdev = accel_dev->accel_pci_dev.pci_dev;
 	u32 capabilities_sym, capabilities_asym, capabilities_dc;
+	u32 capabilities_dcc;
 	u32 fusectl1;
 
 	/* Read accelerator capabilities mask */
@@ -282,6 +296,14 @@ static u32 get_accel_cap(struct adf_accel_dev *accel_dev)
 		return capabilities_sym | capabilities_asym;
 	case SVC_DC:
 		return capabilities_dc;
+	case SVC_DCC:
+		/*
+		 * Sym capabilities are available for chaining operations,
+		 * but sym crypto instances cannot be supported
+		 */
+		capabilities_dcc = capabilities_dc | capabilities_sym;
+		capabilities_dcc &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC;
+		return capabilities_dcc;
 	case SVC_SYM:
 		return capabilities_sym;
 	case SVC_ASYM:
@@ -307,6 +329,8 @@ static const u32 *adf_get_arbiter_mapping(struct adf_accel_dev *accel_dev)
 	switch (get_service_enabled(accel_dev)) {
 	case SVC_DC:
 		return thrd_to_arb_map_dc;
+	case SVC_DCC:
+		return thrd_to_arb_map_dcc;
 	default:
 		return default_thrd_to_arb_map;
 	}
@@ -396,6 +420,9 @@ static const char *uof_get_name(struct adf_accel_dev *accel_dev, u32 obj_num,
 	case SVC_DC:
 		id = adf_fw_dc_config[obj_num].obj;
 		break;
+	case SVC_DCC:
+		id = adf_fw_dcc_config[obj_num].obj;
+		break;
 	case SVC_SYM:
 		id = adf_fw_sym_config[obj_num].obj;
 		break;
@@ -442,6 +469,8 @@ static u32 uof_get_ae_mask(struct adf_accel_dev *accel_dev, u32 obj_num)
 		return adf_fw_cy_config[obj_num].ae_mask;
 	case SVC_DC:
 		return adf_fw_dc_config[obj_num].ae_mask;
+	case SVC_DCC:
+		return adf_fw_dcc_config[obj_num].ae_mask;
 	case SVC_CY2:
 		return adf_fw_cy_config[obj_num].ae_mask;
 	case SVC_SYM:
* Unmerged path drivers/crypto/qat/qat_4xxx/adf_drv.c
* Unmerged path drivers/crypto/qat/qat_common/adf_admin.c
diff --git a/drivers/crypto/qat/qat_common/adf_cfg_strings.h b/drivers/crypto/qat/qat_common/adf_cfg_strings.h
index 3ae1e5caee0e..378521d5750d 100644
--- a/drivers/crypto/qat/qat_common/adf_cfg_strings.h
+++ b/drivers/crypto/qat/qat_common/adf_cfg_strings.h
@@ -32,6 +32,7 @@
 #define ADF_CFG_DC_ASYM "dc;asym"
 #define ADF_CFG_SYM_DC "sym;dc"
 #define ADF_CFG_DC_SYM "dc;sym"
+#define ADF_CFG_DCC "dcc"
 #define ADF_SERVICES_ENABLED "ServicesEnabled"
 #define ADF_PM_IDLE_SUPPORT "PmIdleSupport"
 #define ADF_ETRMGR_COALESCING_ENABLED "InterruptCoalescingEnabled"
* Unmerged path drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
