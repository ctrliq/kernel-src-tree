crypto: qat - add retrieval of fw capabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-530.el8
commit-author Damian Muszynski <damian.muszynski@intel.com>
commit c7fd53796dbd09c3ef55032925bc7f8f238f9405
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-530.el8/c7fd5379.failed

The QAT firmware provides a mechanism to retrieve its capabilities
through the init admin interface.

Add logic to retrieve the firmware capability mask from the firmware
through the init/admin channel. This mask reports if the
power management, telemetry and rate limiting features are supported.

The fw capabilities are stored in the accel_dev structure and are used
to detect if a certain feature is supported by the firmware loaded
in the device.

This is supported only by devices which have an admin AE.

	Signed-off-by: Damian Muszynski <damian.muszynski@intel.com>
	Reviewed-by: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
	Reviewed-by: Tero Kristo <tero.kristo@linux.intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit c7fd53796dbd09c3ef55032925bc7f8f238f9405)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/qat/qat_common/adf_admin.c
#	drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
diff --cc drivers/crypto/qat/qat_common/adf_admin.c
index 118775ee02f2,50e054ba2c33..000000000000
--- a/drivers/crypto/qat/qat_common/adf_admin.c
+++ b/drivers/crypto/qat/qat_common/adf_admin.c
@@@ -223,6 -254,82 +223,85 @@@ static int adf_get_dc_capabilities(stru
  	return 0;
  }
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/adf_admin.c
++=======
+ int adf_get_ae_fw_counters(struct adf_accel_dev *accel_dev, u16 ae, u64 *reqs, u64 *resps)
+ {
+ 	struct icp_qat_fw_init_admin_resp resp = { };
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	int ret;
+ 
+ 	req.cmd_id = ICP_QAT_FW_COUNTERS_GET;
+ 
+ 	ret = adf_put_admin_msg_sync(accel_dev, ae, &req, &resp);
+ 	if (ret || resp.status)
+ 		return -EFAULT;
+ 
+ 	*reqs = resp.req_rec_count;
+ 	*resps = resp.resp_sent_count;
+ 
+ 	return 0;
+ }
+ 
+ int adf_send_admin_tim_sync(struct adf_accel_dev *accel_dev, u32 cnt)
+ {
+ 	u32 ae_mask = accel_dev->hw_device->ae_mask;
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	struct icp_qat_fw_init_admin_resp resp = { };
+ 
+ 	req.cmd_id = ICP_QAT_FW_SYNC;
+ 	req.int_timer_ticks = cnt;
+ 
+ 	return adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ }
+ 
+ int adf_send_admin_hb_timer(struct adf_accel_dev *accel_dev, uint32_t ticks)
+ {
+ 	u32 ae_mask = accel_dev->hw_device->ae_mask;
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	struct icp_qat_fw_init_admin_resp resp;
+ 
+ 	req.cmd_id = ICP_QAT_FW_HEARTBEAT_TIMER_SET;
+ 	req.init_cfg_ptr = accel_dev->heartbeat->dma.phy_addr;
+ 	req.heartbeat_ticks = ticks;
+ 
+ 	return adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ }
+ 
+ static bool is_dcc_enabled(struct adf_accel_dev *accel_dev)
+ {
+ 	char services[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};
+ 	int ret;
+ 
+ 	ret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,
+ 				      ADF_SERVICES_ENABLED, services);
+ 	if (ret)
+ 		return false;
+ 
+ 	return !strcmp(services, "dcc");
+ }
+ 
+ static int adf_get_fw_capabilities(struct adf_accel_dev *accel_dev, u16 *caps)
+ {
+ 	u32 ae_mask = accel_dev->hw_device->admin_ae_mask;
+ 	struct icp_qat_fw_init_admin_resp resp = { };
+ 	struct icp_qat_fw_init_admin_req req = { };
+ 	int ret;
+ 
+ 	if (!ae_mask)
+ 		return 0;
+ 
+ 	req.cmd_id = ICP_QAT_FW_CAPABILITIES_GET;
+ 	ret = adf_send_admin(accel_dev, &req, &resp, ae_mask);
+ 	if (ret)
+ 		return ret;
+ 
+ 	*caps = resp.fw_capabilities;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c7fd53796dbd (crypto: qat - add retrieval of fw capabilities):drivers/crypto/intel/qat/qat_common/adf_admin.c
  /**
   * adf_send_admin_init() - Function sends init message to FW
   * @accel_dev: Pointer to acceleration device.
@@@ -243,9 -361,7 +323,13 @@@ int adf_send_admin_init(struct adf_acce
  	}
  	accel_dev->hw_device->extended_dc_capabilities = dc_capabilities;
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/adf_admin.c
 +	ret = adf_set_fw_constants(accel_dev);
 +	if (ret)
 +		return ret;
++=======
+ 	adf_get_fw_capabilities(accel_dev, &hw_data->fw_capabilities);
++>>>>>>> c7fd53796dbd (crypto: qat - add retrieval of fw capabilities):drivers/crypto/intel/qat/qat_common/adf_admin.c
  
  	return adf_init_ae(accel_dev);
  }
diff --cc drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
index 56cb827f93ea,e4de9a30e0bd..000000000000
--- a/drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
+++ b/drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
@@@ -16,7 -16,13 +16,15 @@@ enum icp_qat_fw_init_admin_cmd_id 
  	ICP_QAT_FW_HEARTBEAT_SYNC = 7,
  	ICP_QAT_FW_HEARTBEAT_GET = 8,
  	ICP_QAT_FW_COMP_CAPABILITY_GET = 9,
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
++=======
+ 	ICP_QAT_FW_CRYPTO_CAPABILITY_GET = 10,
+ 	ICP_QAT_FW_DC_CHAIN_INIT = 11,
+ 	ICP_QAT_FW_HEARTBEAT_TIMER_SET = 13,
+ 	ICP_QAT_FW_TIMER_GET = 19,
+ 	ICP_QAT_FW_CNV_STATS_GET = 20,
++>>>>>>> c7fd53796dbd (crypto: qat - add retrieval of fw capabilities):drivers/crypto/intel/qat/qat_common/icp_qat_fw_init_admin.h
  	ICP_QAT_FW_PM_STATE_CONFIG = 128,
 -	ICP_QAT_FW_PM_INFO = 129,
  };
  
  enum icp_qat_fw_init_admin_resp_status {
@@@ -97,19 -114,41 +106,24 @@@ struct icp_qat_fw_init_admin_resp 
  	};
  } __packed;
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
 +#define ICP_QAT_FW_COMN_HEARTBEAT_OK 0
 +#define ICP_QAT_FW_COMN_HEARTBEAT_BLOCKED 1
 +#define ICP_QAT_FW_COMN_HEARTBEAT_FLAG_BITPOS 0
 +#define ICP_QAT_FW_COMN_HEARTBEAT_FLAG_MASK 0x1
 +#define ICP_QAT_FW_COMN_STATUS_RESRVD_FLD_MASK 0xFE
 +#define ICP_QAT_FW_COMN_HEARTBEAT_HDR_FLAG_GET(hdr_t) \
 +	ICP_QAT_FW_COMN_HEARTBEAT_FLAG_GET(hdr_t.flags)
++=======
+ #define ICP_QAT_FW_SYNC ICP_QAT_FW_HEARTBEAT_SYNC
+ #define ICP_QAT_FW_CAPABILITIES_GET ICP_QAT_FW_CRYPTO_CAPABILITY_GET
++>>>>>>> c7fd53796dbd (crypto: qat - add retrieval of fw capabilities):drivers/crypto/intel/qat/qat_common/icp_qat_fw_init_admin.h
  
 -#define ICP_QAT_NUMBER_OF_PM_EVENTS 8
 -
 -struct icp_qat_fw_init_admin_pm_info {
 -	__u16 max_pwrreq;
 -	__u16 min_pwrreq;
 -	__u16 resvrd1;
 -	__u8 pwr_state;
 -	__u8 resvrd2;
 -	__u32 fusectl0;
 -	struct_group(event_counters,
 -		__u32 sys_pm;
 -		__u32 host_msg;
 -		__u32 unknown;
 -		__u32 local_ssm;
 -		__u32 timer;
 -	);
 -	__u32 event_log[ICP_QAT_NUMBER_OF_PM_EVENTS];
 -	struct_group(pm,
 -		__u32 fw_init;
 -		__u32 pwrreq;
 -		__u32 status;
 -		__u32 main;
 -		__u32 thread;
 -	);
 -	struct_group(ssm,
 -		__u32 pm_enable;
 -		__u32 pm_active_status;
 -		__u32 pm_managed_status;
 -		__u32 pm_domain_status;
 -		__u32 active_constraint;
 -	);
 -	__u32 resvrd3[6];
 -};
 +#define ICP_QAT_FW_COMN_HEARTBEAT_HDR_FLAG_SET(hdr_t, val) \
 +	ICP_QAT_FW_COMN_HEARTBEAT_FLAG_SET(hdr_t, val)
  
 +#define ICP_QAT_FW_COMN_HEARTBEAT_FLAG_GET(flags) \
 +	QAT_FIELD_GET(flags, \
 +		 ICP_QAT_FW_COMN_HEARTBEAT_FLAG_BITPOS, \
 +		 ICP_QAT_FW_COMN_HEARTBEAT_FLAG_MASK)
  #endif
diff --git a/drivers/crypto/qat/qat_common/adf_accel_devices.h b/drivers/crypto/qat/qat_common/adf_accel_devices.h
index c43e39c34d9b..e589cfcbf0a5 100644
--- a/drivers/crypto/qat/qat_common/adf_accel_devices.h
+++ b/drivers/crypto/qat/qat_common/adf_accel_devices.h
@@ -215,6 +215,7 @@ struct adf_hw_device_data {
 	u32 straps;
 	u32 accel_capabilities_mask;
 	u32 extended_dc_capabilities;
+	u16 fw_capabilities;
 	u32 clock_frequency;
 	u32 instance_id;
 	u16 accel_mask;
* Unmerged path drivers/crypto/qat/qat_common/adf_admin.c
* Unmerged path drivers/crypto/qat/qat_common/icp_qat_fw_init_admin.h
