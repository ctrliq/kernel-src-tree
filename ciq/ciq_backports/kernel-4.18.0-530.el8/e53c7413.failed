crypto: qat - prevent underflow in rp2srv_store()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-530.el8
commit-author Dan Carpenter <dan.carpenter@linaro.org>
commit e53c741303a59ee1682e11f61b7772863e02526d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-530.el8/e53c7413.failed

The "ring" variable has an upper bounds check but nothing checks for
negatives.  This code uses kstrtouint() already and it was obviously
intended to be declared as unsigned int.  Make it so.

Fixes: dbc8876dd873 ("crypto: qat - add rp2svc sysfs attribute")
	Signed-off-by: Dan Carpenter <dan.carpenter@linaro.org>
	Acked-by: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit e53c741303a59ee1682e11f61b7772863e02526d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/qat/qat_common/adf_sysfs.c
diff --cc drivers/crypto/qat/qat_common/adf_sysfs.c
index 8672cfa2800f,6f0b3629da13..000000000000
--- a/drivers/crypto/qat/qat_common/adf_sysfs.c
+++ b/drivers/crypto/qat/qat_common/adf_sysfs.c
@@@ -216,6 -207,81 +216,84 @@@ static DEVICE_ATTR_RW(pm_idle_enabled)
  static DEVICE_ATTR_RW(state);
  static DEVICE_ATTR_RW(cfg_services);
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_common/adf_sysfs.c
++=======
+ static ssize_t rp2srv_show(struct device *dev, struct device_attribute *attr,
+ 			   char *buf)
+ {
+ 	struct adf_hw_device_data *hw_data;
+ 	struct adf_accel_dev *accel_dev;
+ 	enum adf_cfg_service_type svc;
+ 
+ 	accel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));
+ 	hw_data = GET_HW_DATA(accel_dev);
+ 
+ 	if (accel_dev->sysfs.ring_num == UNSET_RING_NUM)
+ 		return -EINVAL;
+ 
+ 	down_read(&accel_dev->sysfs.lock);
+ 	svc = GET_SRV_TYPE(accel_dev, accel_dev->sysfs.ring_num %
+ 					      hw_data->num_banks_per_vf);
+ 	up_read(&accel_dev->sysfs.lock);
+ 
+ 	switch (svc) {
+ 	case COMP:
+ 		return sysfs_emit(buf, "%s\n", ADF_CFG_DC);
+ 	case SYM:
+ 		return sysfs_emit(buf, "%s\n", ADF_CFG_SYM);
+ 	case ASYM:
+ 		return sysfs_emit(buf, "%s\n", ADF_CFG_ASYM);
+ 	default:
+ 		break;
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static ssize_t rp2srv_store(struct device *dev, struct device_attribute *attr,
+ 			    const char *buf, size_t count)
+ {
+ 	struct adf_accel_dev *accel_dev;
+ 	int num_rings, ret;
+ 	unsigned int ring;
+ 
+ 	accel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));
+ 	if (!accel_dev)
+ 		return -EINVAL;
+ 
+ 	ret = kstrtouint(buf, 10, &ring);
+ 	if (ret)
+ 		return ret;
+ 
+ 	num_rings = GET_MAX_BANKS(accel_dev);
+ 	if (ring >= num_rings) {
+ 		dev_err(&GET_DEV(accel_dev),
+ 			"Device does not support more than %u ring pairs\n",
+ 			num_rings);
+ 		return -EINVAL;
+ 	}
+ 
+ 	down_write(&accel_dev->sysfs.lock);
+ 	accel_dev->sysfs.ring_num = ring;
+ 	up_write(&accel_dev->sysfs.lock);
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(rp2srv);
+ 
+ static ssize_t num_rps_show(struct device *dev, struct device_attribute *attr,
+ 			    char *buf)
+ {
+ 	struct adf_accel_dev *accel_dev;
+ 
+ 	accel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));
+ 	if (!accel_dev)
+ 		return -EINVAL;
+ 
+ 	return sysfs_emit(buf, "%u\n", GET_MAX_BANKS(accel_dev));
+ }
+ static DEVICE_ATTR_RO(num_rps);
+ 
++>>>>>>> e53c741303a5 (crypto: qat - prevent underflow in rp2srv_store()):drivers/crypto/intel/qat/qat_common/adf_sysfs.c
  static struct attribute *qat_attrs[] = {
  	&dev_attr_state.attr,
  	&dev_attr_cfg_services.attr,
* Unmerged path drivers/crypto/qat/qat_common/adf_sysfs.c
