ext4: refresh the ext4_ext_path struct after dropping i_data_sem.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author yangerkun <yangerkun@huawei.com>
commit 1811bc401aa58c7bdb0df3205aa6613b49d32127
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/1811bc40.failed

After we drop i_data sem, we need to reload the ext4_ext_path
structure since the extent tree can change once i_data_sem is
released.

This addresses the BUG:

[52117.465187] ------------[ cut here ]------------
[52117.465686] kernel BUG at fs/ext4/extents.c:1756!
...
[52117.478306] Call Trace:
[52117.478565]  ext4_ext_shift_extents+0x3ee/0x710
[52117.479020]  ext4_fallocate+0x139c/0x1b40
[52117.479405]  ? __do_sys_newfstat+0x6b/0x80
[52117.479805]  vfs_fallocate+0x151/0x4b0
[52117.480177]  ksys_fallocate+0x4a/0xa0
[52117.480533]  __x64_sys_fallocate+0x22/0x30
[52117.480930]  do_syscall_64+0x35/0x80
[52117.481277]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[52117.481769] RIP: 0033:0x7fa062f855ca

	Cc: stable@kernel.org
Link: https://lore.kernel.org/r/20210903062748.4118886-4-yangerkun@huawei.com
	Signed-off-by: yangerkun <yangerkun@huawei.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 1811bc401aa58c7bdb0df3205aa6613b49d32127)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents.c
diff --cc fs/ext4/extents.c
index 674bf6b7b83e,15c68bc80d21..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -5247,13 -5003,26 +5247,23 @@@ ext4_ext_shift_path_extents(struct ext4
  				return -EFSCORRUPTED;
  
  			ex_last = EXT_LAST_EXTENT(path[depth].p_hdr);
 -			/* leaf + sb + inode */
 -			credits = 3;
 -			if (ex_start == EXT_FIRST_EXTENT(path[depth].p_hdr)) {
 -				update = true;
 -				/* extent tree + sb + inode */
 -				credits = depth + 2;
 -			}
  
++<<<<<<< HEAD
 +			err = ext4_access_path(handle, inode, path + depth);
 +			if (err)
++=======
+ 			restart_credits = ext4_writepage_trans_blocks(inode);
+ 			err = ext4_datasem_ensure_credits(handle, inode, credits,
+ 					restart_credits, 0);
+ 			if (err) {
+ 				if (err > 0)
+ 					err = -EAGAIN;
++>>>>>>> 1811bc401aa5 (ext4: refresh the ext4_ext_path struct after dropping i_data_sem.)
  				goto out;
+ 			}
  
 -			err = ext4_ext_get_access(handle, inode, path + depth);
 -			if (err)
 -				goto out;
 +			if (ex_start == EXT_FIRST_EXTENT(path[depth].p_hdr))
 +				update = 1;
  
  			while (ex_start <= ex_last) {
  				if (SHIFT == SHIFT_LEFT) {
* Unmerged path fs/ext4/extents.c
