ALSA: usb-audio: Switch back to non-latency mode at a later point

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit eee5d6f1356a016105a974fb176b491288439efa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/eee5d6f1.failed

The recent regression report revealed that the judgment of the
low-latency playback mode based on the runtime->stop_threshold cannot
work reliably at the prepare stage, as sw_params call may happen at
any time, and PCM dmix actually sets it up after the prepare call.
This ended up with the stall of the stream as PCM ack won't be issued
at all.

For addressing this, check the free-wheeling mode again at the PCM
trigger right before starting the stream again, and allow switching to
the non-LL mode at a late stage.

Fixes: d5f871f89e21 ("ALSA: usb-audio: Improved lowlatency playback support")
Reported-and-tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Link: https://lore.kernel.org/r/20211117161855.m45mxcqszkfcetai@box.shutemov.name
Link: https://lore.kernel.org/r/20211119102459.7055-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit eee5d6f1356a016105a974fb176b491288439efa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/pcm.c
diff --cc sound/usb/pcm.c
index bb6ca8e81598,57b046e73bfe..000000000000
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@@ -572,6 -581,31 +572,34 @@@ static int snd_usb_hw_free(struct snd_p
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* free-wheeling mode? (e.g. dmix) */
+ static int in_free_wheeling_mode(struct snd_pcm_runtime *runtime)
+ {
+ 	return runtime->stop_threshold > runtime->buffer_size;
+ }
+ 
+ /* check whether early start is needed for playback stream */
+ static int lowlatency_playback_available(struct snd_pcm_runtime *runtime,
+ 					 struct snd_usb_substream *subs)
+ {
+ 	struct snd_usb_audio *chip = subs->stream->chip;
+ 
+ 	if (subs->direction == SNDRV_PCM_STREAM_CAPTURE)
+ 		return false;
+ 	/* disabled via module option? */
+ 	if (!chip->lowlatency)
+ 		return false;
+ 	if (in_free_wheeling_mode(runtime))
+ 		return false;
+ 	/* implicit feedback mode has own operation mode */
+ 	if (snd_usb_endpoint_implicit_feedback_sink(subs->data_endpoint))
+ 		return false;
+ 	return true;
+ }
+ 
++>>>>>>> eee5d6f1356a (ALSA: usb-audio: Switch back to non-latency mode at a later point)
  /*
   * prepare callback
   *
@@@ -1447,7 -1555,10 +1475,14 @@@ static int snd_usb_substream_playback_t
  					      prepare_playback_urb,
  					      retire_playback_urb,
  					      subs);
++<<<<<<< HEAD
 +		if (cmd == SNDRV_PCM_TRIGGER_START) {
++=======
+ 		if (subs->lowlatency_playback &&
+ 		    cmd == SNDRV_PCM_TRIGGER_START) {
+ 			if (in_free_wheeling_mode(substream->runtime))
+ 				subs->lowlatency_playback = false;
++>>>>>>> eee5d6f1356a (ALSA: usb-audio: Switch back to non-latency mode at a later point)
  			err = start_endpoints(subs);
  			if (err < 0) {
  				snd_usb_endpoint_set_callback(subs->data_endpoint,
* Unmerged path sound/usb/pcm.c
