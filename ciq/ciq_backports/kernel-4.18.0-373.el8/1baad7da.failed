ASoC: topology: handle endianness warning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 1baad7dad115ea3976fb5e5d0e3f3bec83dfd7ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/1baad7da.failed

Sparse reports the following warning:

sound/soc/soc-topology.c:1488:26: error: restricted __le32 degrades to
integer

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20211025185933.144327-2-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 1baad7dad115ea3976fb5e5d0e3f3bec83dfd7ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/soc-topology.c
diff --cc sound/soc/soc-topology.c
index 813191db0a58,7a4559ddf903..000000000000
--- a/sound/soc/soc-topology.c
+++ b/sound/soc/soc-topology.c
@@@ -1504,61 -1475,68 +1504,113 @@@ static int soc_tplg_dapm_widget_create(
  		goto widget;
  	}
  
 -	template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 -	kc = devm_kcalloc(tplg->dev, le32_to_cpu(w->num_kcontrols), sizeof(*kc), GFP_KERNEL);
 -	if (!kc)
 -		goto err;
 -
 +	control_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;
 +	dev_dbg(tplg->dev, "ASoC: template %s has %d controls of type %x\n",
 +		w->name, w->num_kcontrols, control_hdr->type);
 +
++<<<<<<< HEAD
 +	switch (le32_to_cpu(control_hdr->ops.info)) {
 +	case SND_SOC_TPLG_CTL_VOLSW:
 +	case SND_SOC_TPLG_CTL_STROBE:
 +	case SND_SOC_TPLG_CTL_VOLSW_SX:
 +	case SND_SOC_TPLG_CTL_VOLSW_XR_SX:
 +	case SND_SOC_TPLG_CTL_RANGE:
 +	case SND_SOC_TPLG_DAPM_CTL_VOLSW:
 +		kcontrol_type = SND_SOC_TPLG_TYPE_MIXER;  /* volume mixer */
 +		template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 +		template.kcontrol_news =
 +			soc_tplg_dapm_widget_dmixer_create(tplg,
 +			template.num_kcontrols);
 +		if (!template.kcontrol_news) {
 +			ret = -ENOMEM;
++=======
+ 	kcontrol_type = devm_kcalloc(tplg->dev, le32_to_cpu(w->num_kcontrols), sizeof(unsigned int),
+ 				     GFP_KERNEL);
+ 	if (!kcontrol_type)
+ 		goto err;
+ 
+ 	for (i = 0; i < le32_to_cpu(w->num_kcontrols); i++) {
+ 		control_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;
+ 		switch (le32_to_cpu(control_hdr->ops.info)) {
+ 		case SND_SOC_TPLG_CTL_VOLSW:
+ 		case SND_SOC_TPLG_CTL_STROBE:
+ 		case SND_SOC_TPLG_CTL_VOLSW_SX:
+ 		case SND_SOC_TPLG_CTL_VOLSW_XR_SX:
+ 		case SND_SOC_TPLG_CTL_RANGE:
+ 		case SND_SOC_TPLG_DAPM_CTL_VOLSW:
+ 			/* volume mixer */
+ 			kc[i].index = mixer_count;
+ 			kcontrol_type[i] = SND_SOC_TPLG_TYPE_MIXER;
+ 			mixer_count++;
+ 			ret = soc_tplg_dapm_widget_dmixer_create(tplg, &kc[i]);
+ 			if (ret < 0)
+ 				goto hdr_err;
+ 			break;
+ 		case SND_SOC_TPLG_CTL_ENUM:
+ 		case SND_SOC_TPLG_CTL_ENUM_VALUE:
+ 		case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
+ 		case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
+ 		case SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:
+ 			/* enumerated mixer */
+ 			kc[i].index = enum_count;
+ 			kcontrol_type[i] = SND_SOC_TPLG_TYPE_ENUM;
+ 			enum_count++;
+ 			ret = soc_tplg_dapm_widget_denum_create(tplg, &kc[i]);
+ 			if (ret < 0)
+ 				goto hdr_err;
+ 			break;
+ 		case SND_SOC_TPLG_CTL_BYTES:
+ 			/* bytes control */
+ 			kc[i].index = bytes_count;
+ 			kcontrol_type[i] = SND_SOC_TPLG_TYPE_BYTES;
+ 			bytes_count++;
+ 			ret = soc_tplg_dapm_widget_dbytes_create(tplg, &kc[i]);
+ 			if (ret < 0)
+ 				goto hdr_err;
+ 			break;
+ 		default:
+ 			dev_err(tplg->dev, "ASoC: invalid widget control type %d:%d:%d\n",
+ 				control_hdr->ops.get, control_hdr->ops.put,
+ 				le32_to_cpu(control_hdr->ops.info));
+ 			ret = -EINVAL;
++>>>>>>> 1baad7dad115 (ASoC: topology: handle endianness warning)
 +			goto hdr_err;
 +		}
 +		break;
 +	case SND_SOC_TPLG_CTL_ENUM:
 +	case SND_SOC_TPLG_CTL_ENUM_VALUE:
 +	case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
 +	case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
 +	case SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:
 +		kcontrol_type = SND_SOC_TPLG_TYPE_ENUM;	/* enumerated mixer */
 +		template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 +		template.kcontrol_news =
 +			soc_tplg_dapm_widget_denum_create(tplg,
 +			template.num_kcontrols);
 +		if (!template.kcontrol_news) {
 +			ret = -ENOMEM;
  			goto hdr_err;
  		}
 +		break;
 +	case SND_SOC_TPLG_CTL_BYTES:
 +		kcontrol_type = SND_SOC_TPLG_TYPE_BYTES; /* bytes control */
 +		template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 +		template.kcontrol_news =
 +			soc_tplg_dapm_widget_dbytes_create(tplg,
 +				template.num_kcontrols);
 +		if (!template.kcontrol_news) {
 +			ret = -ENOMEM;
 +			goto hdr_err;
 +		}
 +		break;
 +	default:
 +		dev_err(tplg->dev, "ASoC: invalid widget control type %d:%d:%d\n",
 +			control_hdr->ops.get, control_hdr->ops.put,
 +			le32_to_cpu(control_hdr->ops.info));
 +		ret = -EINVAL;
 +		goto hdr_err;
  	}
  
 -	template.kcontrol_news = kc;
 -	dev_dbg(tplg->dev, "ASoC: template %s with %d/%d/%d (mixer/enum/bytes) control\n",
 -		w->name, mixer_count, enum_count, bytes_count);
 -
  widget:
  	ret = soc_tplg_widget_load(tplg, &template, w);
  	if (ret < 0)
* Unmerged path sound/soc/soc-topology.c
