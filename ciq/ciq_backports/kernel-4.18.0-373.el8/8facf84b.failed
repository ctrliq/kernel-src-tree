ASoC: soc-topology: Move template info print soc_tplg_dapm_widget_create()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit 8facf84bcf575e3217a15cefcc867db15dca4781
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/8facf84b.failed

A DAPM widget now can have different types of controls, it is no longer
correct to print the type as it is just the type of the first control.

Move it after the loop where we create the controls and print the number
of the control types.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
Link: https://lore.kernel.org/r/20210902112301.22657-1-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 8facf84bcf575e3217a15cefcc867db15dca4781)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/soc-topology.c
diff --cc sound/soc/soc-topology.c
index 5752d5720afd,73e1b7b48ce9..000000000000
--- a/sound/soc/soc-topology.c
+++ b/sound/soc/soc-topology.c
@@@ -1502,61 -1473,68 +1502,125 @@@ static int soc_tplg_dapm_widget_create(
  		goto widget;
  	}
  
++<<<<<<< HEAD
 +	control_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;
 +	dev_dbg(tplg->dev, "ASoC: template %s has %d controls of type %x\n",
 +		w->name, w->num_kcontrols, control_hdr->type);
 +
 +	switch (le32_to_cpu(control_hdr->ops.info)) {
 +	case SND_SOC_TPLG_CTL_VOLSW:
 +	case SND_SOC_TPLG_CTL_STROBE:
 +	case SND_SOC_TPLG_CTL_VOLSW_SX:
 +	case SND_SOC_TPLG_CTL_VOLSW_XR_SX:
 +	case SND_SOC_TPLG_CTL_RANGE:
 +	case SND_SOC_TPLG_DAPM_CTL_VOLSW:
 +		kcontrol_type = SND_SOC_TPLG_TYPE_MIXER;  /* volume mixer */
 +		template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 +		template.kcontrol_news =
 +			soc_tplg_dapm_widget_dmixer_create(tplg,
 +			template.num_kcontrols);
 +		if (!template.kcontrol_news) {
 +			ret = -ENOMEM;
++=======
+ 	template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
+ 	kc = devm_kcalloc(tplg->dev, le32_to_cpu(w->num_kcontrols), sizeof(*kc), GFP_KERNEL);
+ 	if (!kc)
+ 		goto err;
+ 
+ 	kcontrol_type = devm_kcalloc(tplg->dev, le32_to_cpu(w->num_kcontrols), sizeof(unsigned int),
+ 				     GFP_KERNEL);
+ 	if (!kcontrol_type)
+ 		goto err;
+ 
+ 	for (i = 0; i < w->num_kcontrols; i++) {
+ 		control_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;
+ 		switch (le32_to_cpu(control_hdr->ops.info)) {
+ 		case SND_SOC_TPLG_CTL_VOLSW:
+ 		case SND_SOC_TPLG_CTL_STROBE:
+ 		case SND_SOC_TPLG_CTL_VOLSW_SX:
+ 		case SND_SOC_TPLG_CTL_VOLSW_XR_SX:
+ 		case SND_SOC_TPLG_CTL_RANGE:
+ 		case SND_SOC_TPLG_DAPM_CTL_VOLSW:
+ 			/* volume mixer */
+ 			kc[i].index = mixer_count;
+ 			kcontrol_type[i] = SND_SOC_TPLG_TYPE_MIXER;
+ 			mixer_count++;
+ 			ret = soc_tplg_dapm_widget_dmixer_create(tplg, &kc[i]);
+ 			if (ret < 0)
+ 				goto hdr_err;
+ 			break;
+ 		case SND_SOC_TPLG_CTL_ENUM:
+ 		case SND_SOC_TPLG_CTL_ENUM_VALUE:
+ 		case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
+ 		case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
+ 		case SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:
+ 			/* enumerated mixer */
+ 			kc[i].index = enum_count;
+ 			kcontrol_type[i] = SND_SOC_TPLG_TYPE_ENUM;
+ 			enum_count++;
+ 			ret = soc_tplg_dapm_widget_denum_create(tplg, &kc[i]);
+ 			if (ret < 0)
+ 				goto hdr_err;
+ 			break;
+ 		case SND_SOC_TPLG_CTL_BYTES:
+ 			/* bytes control */
+ 			kc[i].index = bytes_count;
+ 			kcontrol_type[i] = SND_SOC_TPLG_TYPE_BYTES;
+ 			bytes_count++;
+ 			ret = soc_tplg_dapm_widget_dbytes_create(tplg, &kc[i]);
+ 			if (ret < 0)
+ 				goto hdr_err;
+ 			break;
+ 		default:
+ 			dev_err(tplg->dev, "ASoC: invalid widget control type %d:%d:%d\n",
+ 				control_hdr->ops.get, control_hdr->ops.put,
+ 				le32_to_cpu(control_hdr->ops.info));
+ 			ret = -EINVAL;
++>>>>>>> 8facf84bcf57 (ASoC: soc-topology: Move template info print soc_tplg_dapm_widget_create())
  			goto hdr_err;
  		}
 +		break;
 +	case SND_SOC_TPLG_CTL_ENUM:
 +	case SND_SOC_TPLG_CTL_ENUM_VALUE:
 +	case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
 +	case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
 +	case SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:
 +		kcontrol_type = SND_SOC_TPLG_TYPE_ENUM;	/* enumerated mixer */
 +		template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 +		template.kcontrol_news =
 +			soc_tplg_dapm_widget_denum_create(tplg,
 +			template.num_kcontrols);
 +		if (!template.kcontrol_news) {
 +			ret = -ENOMEM;
 +			goto hdr_err;
 +		}
 +		break;
 +	case SND_SOC_TPLG_CTL_BYTES:
 +		kcontrol_type = SND_SOC_TPLG_TYPE_BYTES; /* bytes control */
 +		template.num_kcontrols = le32_to_cpu(w->num_kcontrols);
 +		template.kcontrol_news =
 +			soc_tplg_dapm_widget_dbytes_create(tplg,
 +				template.num_kcontrols);
 +		if (!template.kcontrol_news) {
 +			ret = -ENOMEM;
 +			goto hdr_err;
 +		}
 +		break;
 +	default:
 +		dev_err(tplg->dev, "ASoC: invalid widget control type %d:%d:%d\n",
 +			control_hdr->ops.get, control_hdr->ops.put,
 +			le32_to_cpu(control_hdr->ops.info));
 +		ret = -EINVAL;
 +		goto hdr_err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	template.kcontrol_news = kc;
+ 	dev_dbg(tplg->dev, "ASoC: template %s with %d/%d/%d (mixer/enum/bytes) control\n",
+ 		w->name, mixer_count, enum_count, bytes_count);
+ 
++>>>>>>> 8facf84bcf57 (ASoC: soc-topology: Move template info print soc_tplg_dapm_widget_create())
  widget:
  	ret = soc_tplg_widget_load(tplg, &template, w);
  	if (ret < 0)
* Unmerged path sound/soc/soc-topology.c
