net: phy: make PHY PM ops a no-op if MAC driver manages PHY PM

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit fba863b816049b03f3fbb07b10ebdcfe5c4141f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/fba863b8.failed

Resume callback of the PHY driver is called after the one for the MAC
driver. The PHY driver resume callback calls phy_init_hw(), and this is
potentially problematic if the MAC driver calls phy_start() in its resume
callback. One issue was reported with the fec driver and a KSZ8081 PHY
which seems to become unstable if a soft reset is triggered during aneg.

The new flag allows MAC drivers to indicate that they take care of
suspending/resuming the PHY. Then the MAC PM callbacks can handle
any dependency between MAC and PHY PM.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit fba863b816049b03f3fbb07b10ebdcfe5c4141f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/phy.h
diff --cc include/linux/phy.h
index eb97971acf04,98fb441dd72e..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -445,37 -468,77 +445,68 @@@ enum phy_state 
   */
  struct phy_c45_device_ids {
  	u32 devices_in_package;
 -	u32 mmds_present;
 -	u32 device_ids[MDIO_MMD_NUM];
 +	RH_KABI_BROKEN_INSERT(u32 mmds_present)
 +	RH_KABI_BROKEN_REPLACE(u32 device_ids[8], u32 device_ids[MDIO_MMD_NUM])
  };
  
 -struct macsec_context;
 -struct macsec_ops;
 -
 -/**
 - * struct phy_device - An instance of a PHY
 +/* phy_device: An instance of a PHY
   *
++<<<<<<< HEAD
 + * drv: Pointer to the driver for this PHY instance
 + * phy_id: UID for this device found during discovery
 + * c45_ids: 802.3-c45 Device Identifers if is_c45.
 + * is_c45:  Set to true if this phy uses clause 45 addressing.
 + * is_internal: Set to true if this phy is internal to a MAC.
 + * is_pseudo_fixed_link: Set to true if this phy is an Ethernet switch, etc.
 + * is_gigabit_capable: Set to true if PHY supports 1000Mbps
 + * has_fixups: Set to true if this phy has fixups/quirks.
 + * suspended: Set to true if this phy has been suspended successfully.
 + * suspended_by_mdio_bus: Set to true if this phy was suspended by MDIO bus.
 + * sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
 + * loopback_enabled: Set true if this phy has been loopbacked successfully.
 + * downshifted_rate: Set true if link speed has been downshifted.
 + * state: state of the PHY for management purposes
 + * dev_flags: Device-specific flags used by the PHY driver.
 + * irq: IRQ number of the PHY's interrupt (-1 if none)
 + * phy_timer: The timer for handling the state machine
 + * sfp_bus_attached: flag indicating whether the SFP bus has been attached
 + * sfp_bus: SFP bus attached to this PHY's fiber port
 + * attached_dev: The attached enet driver's device instance ptr
 + * adjust_link: Callback for the enet controller to respond to
 + * changes in the link state.
++=======
+  * @mdio: MDIO bus this PHY is on
+  * @drv: Pointer to the driver for this PHY instance
+  * @phy_id: UID for this device found during discovery
+  * @c45_ids: 802.3-c45 Device Identifiers if is_c45.
+  * @is_c45:  Set to true if this PHY uses clause 45 addressing.
+  * @is_internal: Set to true if this PHY is internal to a MAC.
+  * @is_pseudo_fixed_link: Set to true if this PHY is an Ethernet switch, etc.
+  * @is_gigabit_capable: Set to true if PHY supports 1000Mbps
+  * @has_fixups: Set to true if this PHY has fixups/quirks.
+  * @suspended: Set to true if this PHY has been suspended successfully.
+  * @suspended_by_mdio_bus: Set to true if this PHY was suspended by MDIO bus.
+  * @sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
+  * @loopback_enabled: Set true if this PHY has been loopbacked successfully.
+  * @downshifted_rate: Set true if link speed has been downshifted.
+  * @is_on_sfp_module: Set true if PHY is located on an SFP module.
+  * @mac_managed_pm: Set true if MAC driver takes of suspending/resuming PHY
+  * @state: State of the PHY for management purposes
+  * @dev_flags: Device-specific flags used by the PHY driver.
+  * @irq: IRQ number of the PHY's interrupt (-1 if none)
+  * @phy_timer: The timer for handling the state machine
+  * @phylink: Pointer to phylink instance for this PHY
+  * @sfp_bus_attached: Flag indicating whether the SFP bus has been attached
+  * @sfp_bus: SFP bus attached to this PHY's fiber port
+  * @attached_dev: The attached enet driver's device instance ptr
+  * @adjust_link: Callback for the enet controller to respond to changes: in the
+  *               link state.
+  * @phy_link_change: Callback for phylink for notification of link change
+  * @macsec_ops: MACsec offloading ops.
++>>>>>>> fba863b81604 (net: phy: make PHY PM ops a no-op if MAC driver manages PHY PM)
   *
 - * @speed: Current link speed
 - * @duplex: Current duplex
 - * @port: Current port
 - * @pause: Current pause
 - * @asym_pause: Current asymmetric pause
 - * @supported: Combined MAC/PHY supported linkmodes
 - * @advertising: Currently advertised linkmodes
 - * @adv_old: Saved advertised while power saving for WoL
 - * @lp_advertising: Current link partner advertised linkmodes
 - * @eee_broken_modes: Energy efficient ethernet modes which should be prohibited
 - * @autoneg: Flag autoneg being used
 - * @link: Current link state
 - * @autoneg_complete: Flag auto negotiation of the link has completed
 - * @mdix: Current crossover
 - * @mdix_ctrl: User setting of crossover
 - * @interrupts: Flag interrupts have been enabled
 - * @interface: enum phy_interface_t value
 - * @skb: Netlink message for cable diagnostics
 - * @nest: Netlink nest used for cable diagnostics
 - * @ehdr: nNtlink header for cable diagnostics
 - * @phy_led_triggers: Array of LED triggers
 - * @phy_num_led_triggers: Number of triggers in @phy_led_triggers
 - * @led_link_trigger: LED trigger for link up/down
 - * @last_triggered: last LED trigger for link speed
 - * @master_slave_set: User requested master/slave configuration
 - * @master_slave_get: Current master/slave advertisement
 - * @master_slave_state: Current master/slave configuration
 - * @mii_ts: Pointer to time stamper callbacks
 - * @lock:  Mutex for serialization access to PHY
 - * @state_queue: Work queue for state machine
 - * @shared: Pointer to private data shared by phys in one package
 - * @priv: Pointer to driver private data
 + * speed, duplex, pause, supported, advertising, lp_advertising,
 + * and autoneg are used like in mii_if_info
   *
   * interrupts currently only supports enabled or disabled,
   * but could be changed in the future to support enabling
@@@ -497,10 -560,15 +528,16 @@@ struct phy_device 
  	unsigned is_c45:1;
  	unsigned is_internal:1;
  	unsigned is_pseudo_fixed_link:1;
 -	unsigned is_gigabit_capable:1;
  	unsigned has_fixups:1;
  	unsigned suspended:1;
 -	unsigned suspended_by_mdio_bus:1;
  	unsigned sysfs_links:1;
  	unsigned loopback_enabled:1;
++<<<<<<< HEAD
++=======
+ 	unsigned downshifted_rate:1;
+ 	unsigned is_on_sfp_module:1;
+ 	unsigned mac_managed_pm:1;
++>>>>>>> fba863b81604 (net: phy: make PHY PM ops a no-op if MAC driver manages PHY PM)
  
  	unsigned autoneg:1;
  	/* The most recently read link state */
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index acd15ff31219..069cdb985448 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -275,6 +275,9 @@ static int mdio_bus_phy_suspend(struct device *dev)
 {
 	struct phy_device *phydev = to_phy_device(dev);
 
+	if (phydev->mac_managed_pm)
+		return 0;
+
 	/* We must stop the state machine manually, otherwise it stops out of
 	 * control, possibly with the phydev->lock held. Upon resume, netdev
 	 * may call phy routines that try to grab the same lock, and that may
@@ -296,6 +299,9 @@ static int mdio_bus_phy_resume(struct device *dev)
 	struct phy_device *phydev = to_phy_device(dev);
 	int ret;
 
+	if (phydev->mac_managed_pm)
+		return 0;
+
 	if (!phydev->suspended_by_mdio_bus)
 		goto no_resume;
 
* Unmerged path include/linux/phy.h
