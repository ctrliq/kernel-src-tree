net/mlx5e: Generalize close RQ

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Aya Levin <ayal@nvidia.com>
commit e078e8df4224d1c422081192e9a6d3db85fa1634
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/e078e8df.failed

Allow different flavours of RQ to use the same close flow. Add validity
checks to support different RQ types which not necessarily initialize
all the RQ's functionality.

	Signed-off-by: Aya Levin <ayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit e078e8df4224d1c422081192e9a6d3db85fa1634)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
index 90bd7328df42,86ab4e864fe6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
@@@ -30,128 -30,29 +30,133 @@@ static int mlx5e_trap_napi_poll(struct 
  	return work_done;
  }
  
 -static void mlx5e_init_trap_rq(struct mlx5e_trap *t, struct mlx5e_params *params,
++<<<<<<< HEAD
 +static int mlx5e_alloc_trap_rq(struct mlx5e_priv *priv, struct mlx5e_rq_param *rqp,
 +			       struct mlx5e_rq_stats *stats, struct mlx5e_params *params,
 +			       struct mlx5e_ch_stats *ch_stats,
  			       struct mlx5e_rq *rq)
  {
 -	struct mlx5_core_dev *mdev = t->mdev;
 -	struct mlx5e_priv *priv = t->priv;
 -
 -	rq->wq_type      = params->rq_wq_type;
 -	rq->pdev         = mdev->device;
 -	rq->netdev       = priv->netdev;
 -	rq->priv         = priv;
 -	rq->clock        = &mdev->clock;
 -	rq->tstamp       = &priv->tstamp;
 -	rq->mdev         = mdev;
 -	rq->hw_mtu       = MLX5E_SW2HW_MTU(params, params->sw_mtu);
 -	rq->stats        = &priv->trap_stats.rq;
 -	rq->ptp_cyc2time = mlx5_rq_ts_translator(mdev);
 +	void *rqc_wq = MLX5_ADDR_OF(rqc, rqp->rqc, wq);
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	struct page_pool_params pp_params = {};
 +	int node = dev_to_node(mdev->device);
 +	u32 pool_size;
 +	int wq_sz;
 +	int err;
 +	int i;
 +
 +	rqp->wq.db_numa_node = node;
 +
 +	rq->wq_type  = params->rq_wq_type;
 +	rq->pdev     = mdev->device;
 +	rq->netdev   = priv->netdev;
 +	rq->mdev     = mdev;
 +	rq->priv     = priv;
 +	rq->stats    = stats;
 +	rq->clock    = &mdev->clock;
 +	rq->tstamp   = &priv->tstamp;
 +	rq->hw_mtu   = MLX5E_SW2HW_MTU(params, params->sw_mtu);
 +
  	xdp_rxq_info_unused(&rq->xdp_rxq);
 +
 +	rq->buff.map_dir = DMA_FROM_DEVICE;
 +	rq->buff.headroom = mlx5e_get_rq_headroom(mdev, params, NULL);
 +	pool_size = 1 << params->log_rq_mtu_frames;
 +
 +	err = mlx5_wq_cyc_create(mdev, &rqp->wq, rqc_wq, &rq->wqe.wq, &rq->wq_ctrl);
 +	if (err)
 +		return err;
 +
 +	rq->wqe.wq.db = &rq->wqe.wq.db[MLX5_RCV_DBR];
 +
 +	wq_sz = mlx5_wq_cyc_get_size(&rq->wqe.wq);
 +
 +	rq->wqe.info = rqp->frags_info;
 +	rq->buff.frame0_sz = rq->wqe.info.arr[0].frag_stride;
 +	rq->wqe.frags =	kvzalloc_node(array_size(sizeof(*rq->wqe.frags),
 +						 (wq_sz << rq->wqe.info.log_num_frags)),
 +				      GFP_KERNEL, node);
 +	if (!rq->wqe.frags) {
 +		err = -ENOMEM;
 +		goto err_wq_cyc_destroy;
 +	}
 +
 +	err = mlx5e_init_di_list(rq, wq_sz, node);
 +	if (err)
 +		goto err_free_frags;
 +
 +	rq->mkey_be = cpu_to_be32(mdev->mlx5e_res.hw_objs.mkey.key);
 +
  	mlx5e_rq_set_trap_handlers(rq, params);
 +
 +	/* Create a page_pool and register it with rxq */
 +	pp_params.order     = 0;
 +	pp_params.flags     = 0; /* No-internal DMA mapping in page_pool */
 +	pp_params.pool_size = pool_size;
 +	pp_params.nid       = node;
 +	pp_params.dev       = mdev->device;
 +	pp_params.dma_dir   = rq->buff.map_dir;
 +
 +	/* page_pool can be used even when there is no rq->xdp_prog,
 +	 * given page_pool does not handle DMA mapping there is no
 +	 * required state to clear. And page_pool gracefully handle
 +	 * elevated refcnt.
 +	 */
 +	rq->page_pool = page_pool_create(&pp_params);
 +	if (IS_ERR(rq->page_pool)) {
 +		err = PTR_ERR(rq->page_pool);
 +		rq->page_pool = NULL;
 +		goto err_free_di_list;
 +	}
 +	for (i = 0; i < wq_sz; i++) {
 +		struct mlx5e_rx_wqe_cyc *wqe =
 +			mlx5_wq_cyc_get_wqe(&rq->wqe.wq, i);
 +		int f;
 +
 +		for (f = 0; f < rq->wqe.info.num_frags; f++) {
 +			u32 frag_size = rq->wqe.info.arr[f].frag_size |
 +				MLX5_HW_START_PADDING;
 +
 +			wqe->data[f].byte_count = cpu_to_be32(frag_size);
 +			wqe->data[f].lkey = rq->mkey_be;
 +		}
 +		/* check if num_frags is not a pow of two */
 +		if (rq->wqe.info.num_frags < (1 << rq->wqe.info.log_num_frags)) {
 +			wqe->data[f].byte_count = 0;
 +			wqe->data[f].lkey = cpu_to_be32(MLX5_INVALID_LKEY);
 +			wqe->data[f].addr = 0;
 +		}
 +	}
 +	return 0;
 +
 +err_free_di_list:
 +	mlx5e_free_di_list(rq);
 +err_free_frags:
 +	kvfree(rq->wqe.frags);
 +err_wq_cyc_destroy:
 +	mlx5_wq_destroy(&rq->wq_ctrl);
 +
 +	return err;
 +}
 +
 +static void mlx5e_free_trap_rq(struct mlx5e_rq *rq)
 +{
 +	page_pool_destroy(rq->page_pool);
 +	mlx5e_free_di_list(rq);
 +	kvfree(rq->wqe.frags);
 +	mlx5_wq_destroy(&rq->wq_ctrl);
  }
  
 -static int mlx5e_open_trap_rq(struct mlx5e_priv *priv, struct mlx5e_trap *t)
 +static int mlx5e_open_trap_rq(struct mlx5e_priv *priv, struct napi_struct *napi,
 +			      struct mlx5e_rq_stats *stats, struct mlx5e_params *params,
 +			      struct mlx5e_rq_param *rq_param,
 +			      struct mlx5e_ch_stats *ch_stats,
 +			      struct mlx5e_rq *rq)
++=======
++static void mlx5e_init_trap_rq(struct mlx5e_trap *t, struct mlx5e_params *params,
++			       struct mlx5e_rq *rq)
++>>>>>>> e078e8df4224 (net/mlx5e: Generalize close RQ)
  {
 -	struct mlx5e_rq_param *rq_param = &t->rq_param;
  	struct mlx5_core_dev *mdev = priv->mdev;
  	struct mlx5e_create_cq_param ccp = {};
  	struct dim_cq_moder trap_moder = {};
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index c889808996c3..72012f21c201 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -601,10 +601,12 @@ static void mlx5e_free_rq(struct mlx5e_rq *rq)
 	struct bpf_prog *old_prog;
 	int i;
 
-	old_prog = rcu_dereference_protected(rq->xdp_prog,
-					     lockdep_is_held(&rq->priv->state_lock));
-	if (old_prog)
-		bpf_prog_put(old_prog);
+	if (xdp_rxq_info_is_reg(&rq->xdp_rxq)) {
+		old_prog = rcu_dereference_protected(rq->xdp_prog,
+						     lockdep_is_held(&rq->priv->state_lock));
+		if (old_prog)
+			bpf_prog_put(old_prog);
+	}
 
 	switch (rq->wq_type) {
 	case MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:
@@ -909,7 +911,8 @@ void mlx5e_deactivate_rq(struct mlx5e_rq *rq)
 void mlx5e_close_rq(struct mlx5e_rq *rq)
 {
 	cancel_work_sync(&rq->dim.work);
-	cancel_work_sync(&rq->icosq->recover_work);
+	if (rq->icosq)
+		cancel_work_sync(&rq->icosq->recover_work);
 	cancel_work_sync(&rq->recover_work);
 	mlx5e_destroy_rq(rq);
 	mlx5e_free_rx_descs(rq);
