net/mlx5: Bridge, implement infrastructure for vlans

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit d75b9e804858c8eee5549b821fd48e780d3bb871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/d75b9e80.failed

Establish all the necessary infrastructure for implementing vlan matching
and vlan push/pop in following patches:

- Add new per-vport struct mlx5_esw_bridge_port that is used to store
metadata for all port vlans. Initialize and cleanup the instance of the
structure when port representor is linked/unliked to bridge. Use xarray to
allow quick vport metadata lookup by vport number.

- Add new per-port-vlan struct mlx5_esw_bridge_vlan that is used to store
vlan-specific data (vid, flags). Handle SWITCHDEV_PORT_OBJ_{ADD|DEL}
switchdev blocking event for SWITCHDEV_OBJ_ID_PORT_VLAN object by
creating/deleting the vlan structure and saving it in per-vport xarray for
quick lookup.

- Implement support for SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING object
attribute that is used to toggle vlan filtering. Remove all FDB entries
from hardware when vlan filtering state is changed.

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Reviewed-by: Jianbo Liu <jianbol@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit d75b9e804858c8eee5549b821fd48e780d3bb871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
index de7a68488a9d,7f5efc1b4392..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
@@@ -65,6 -75,275 +65,278 @@@ static int mlx5_esw_bridge_switchdev_po
  	return notifier_from_errno(err);
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5_esw_bridge_port_obj_add(struct net_device *dev,
+ 					const struct switchdev_obj *obj,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	const struct switchdev_obj_port_vlan *vlan;
+ 	struct mlx5e_rep_priv *rpriv;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	struct mlx5e_priv *priv;
+ 	u16 vport_num;
+ 	int err = 0;
+ 
+ 	priv = netdev_priv(dev);
+ 	rpriv = priv->ppriv;
+ 	vport_num = rpriv->rep->vport;
+ 	esw = priv->mdev->priv.eswitch;
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		return PTR_ERR(vport);
+ 
+ 	switch (obj->id) {
+ 	case SWITCHDEV_OBJ_ID_PORT_VLAN:
+ 		vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);
+ 		err = mlx5_esw_bridge_port_vlan_add(vlan->vid, vlan->flags, esw, vport, extack);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return err;
+ }
+ 
+ static int mlx5_esw_bridge_port_obj_del(struct net_device *dev,
+ 					const struct switchdev_obj *obj)
+ {
+ 	const struct switchdev_obj_port_vlan *vlan;
+ 	struct mlx5e_rep_priv *rpriv;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	struct mlx5e_priv *priv;
+ 	u16 vport_num;
+ 
+ 	priv = netdev_priv(dev);
+ 	rpriv = priv->ppriv;
+ 	vport_num = rpriv->rep->vport;
+ 	esw = priv->mdev->priv.eswitch;
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		return PTR_ERR(vport);
+ 
+ 	switch (obj->id) {
+ 	case SWITCHDEV_OBJ_ID_PORT_VLAN:
+ 		vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);
+ 		mlx5_esw_bridge_port_vlan_del(vlan->vid, esw, vport);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ static int mlx5_esw_bridge_port_obj_attr_set(struct net_device *dev,
+ 					     const struct switchdev_attr *attr,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5e_rep_priv *rpriv;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	struct mlx5e_priv *priv;
+ 	u16 vport_num;
+ 	int err = 0;
+ 
+ 	priv = netdev_priv(dev);
+ 	rpriv = priv->ppriv;
+ 	vport_num = rpriv->rep->vport;
+ 	esw = priv->mdev->priv.eswitch;
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		return PTR_ERR(vport);
+ 
+ 	switch (attr->id) {
+ 	case SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:
+ 		if (attr->u.brport_flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD)) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Flag is not supported");
+ 			err = -EINVAL;
+ 		}
+ 		break;
+ 	case SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:
+ 		break;
+ 	case SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:
+ 		err = mlx5_esw_bridge_ageing_time_set(attr->u.ageing_time, esw, vport);
+ 		break;
+ 	case SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:
+ 		err = mlx5_esw_bridge_vlan_filtering_set(attr->u.vlan_filtering, esw, vport);
+ 		break;
+ 	default:
+ 		err = -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int mlx5_esw_bridge_event_blocking(struct notifier_block *unused,
+ 					  unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
+ 	int err;
+ 
+ 	switch (event) {
+ 	case SWITCHDEV_PORT_OBJ_ADD:
+ 		err = switchdev_handle_port_obj_add(dev, ptr,
+ 						    mlx5e_eswitch_rep,
+ 						    mlx5_esw_bridge_port_obj_add);
+ 		break;
+ 	case SWITCHDEV_PORT_OBJ_DEL:
+ 		err = switchdev_handle_port_obj_del(dev, ptr,
+ 						    mlx5e_eswitch_rep,
+ 						    mlx5_esw_bridge_port_obj_del);
+ 		break;
+ 	case SWITCHDEV_PORT_ATTR_SET:
+ 		err = switchdev_handle_port_attr_set(dev, ptr,
+ 						     mlx5e_eswitch_rep,
+ 						     mlx5_esw_bridge_port_obj_attr_set);
+ 		break;
+ 	default:
+ 		err = 0;
+ 	}
+ 
+ 	return notifier_from_errno(err);
+ }
+ 
+ static void
+ mlx5_esw_bridge_cleanup_switchdev_fdb_work(struct mlx5_bridge_switchdev_fdb_work *fdb_work)
+ {
+ 	dev_put(fdb_work->dev);
+ 	kfree(fdb_work->fdb_info.addr);
+ 	kfree(fdb_work);
+ }
+ 
+ static void mlx5_esw_bridge_switchdev_fdb_event_work(struct work_struct *work)
+ {
+ 	struct mlx5_bridge_switchdev_fdb_work *fdb_work =
+ 		container_of(work, struct mlx5_bridge_switchdev_fdb_work, work);
+ 	struct switchdev_notifier_fdb_info *fdb_info =
+ 		&fdb_work->fdb_info;
+ 	struct net_device *dev = fdb_work->dev;
+ 	struct mlx5e_rep_priv *rpriv;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	struct mlx5e_priv *priv;
+ 	u16 vport_num;
+ 
+ 	rtnl_lock();
+ 
+ 	priv = netdev_priv(dev);
+ 	rpriv = priv->ppriv;
+ 	vport_num = rpriv->rep->vport;
+ 	esw = priv->mdev->priv.eswitch;
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		goto out;
+ 
+ 	if (fdb_work->add)
+ 		mlx5_esw_bridge_fdb_create(dev, esw, vport, fdb_info);
+ 	else
+ 		mlx5_esw_bridge_fdb_remove(dev, esw, vport, fdb_info);
+ 
+ out:
+ 	rtnl_unlock();
+ 	mlx5_esw_bridge_cleanup_switchdev_fdb_work(fdb_work);
+ }
+ 
+ static struct mlx5_bridge_switchdev_fdb_work *
+ mlx5_esw_bridge_init_switchdev_fdb_work(struct net_device *dev, bool add,
+ 					struct switchdev_notifier_fdb_info *fdb_info)
+ {
+ 	struct mlx5_bridge_switchdev_fdb_work *work;
+ 	u8 *addr;
+ 
+ 	work = kzalloc(sizeof(*work), GFP_ATOMIC);
+ 	if (!work)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	INIT_WORK(&work->work, mlx5_esw_bridge_switchdev_fdb_event_work);
+ 	memcpy(&work->fdb_info, fdb_info, sizeof(work->fdb_info));
+ 
+ 	addr = kzalloc(ETH_ALEN, GFP_ATOMIC);
+ 	if (!addr) {
+ 		kfree(work);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 	ether_addr_copy(addr, fdb_info->addr);
+ 	work->fdb_info.addr = addr;
+ 
+ 	dev_hold(dev);
+ 	work->dev = dev;
+ 	work->add = add;
+ 	return work;
+ }
+ 
+ static int mlx5_esw_bridge_switchdev_event(struct notifier_block *nb,
+ 					   unsigned long event, void *ptr)
+ {
+ 	struct mlx5_esw_bridge_offloads *br_offloads = container_of(nb,
+ 								    struct mlx5_esw_bridge_offloads,
+ 								    nb);
+ 	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
+ 	struct switchdev_notifier_fdb_info *fdb_info;
+ 	struct mlx5_bridge_switchdev_fdb_work *work;
+ 	struct switchdev_notifier_info *info = ptr;
+ 	struct net_device *upper;
+ 	struct mlx5e_priv *priv;
+ 
+ 	if (!mlx5e_eswitch_rep(dev))
+ 		return NOTIFY_DONE;
+ 	priv = netdev_priv(dev);
+ 	if (priv->mdev->priv.eswitch != br_offloads->esw)
+ 		return NOTIFY_DONE;
+ 
+ 	if (event == SWITCHDEV_PORT_ATTR_SET) {
+ 		int err = switchdev_handle_port_attr_set(dev, ptr,
+ 							 mlx5e_eswitch_rep,
+ 							 mlx5_esw_bridge_port_obj_attr_set);
+ 		return notifier_from_errno(err);
+ 	}
+ 
+ 	upper = netdev_master_upper_dev_get_rcu(dev);
+ 	if (!upper)
+ 		return NOTIFY_DONE;
+ 	if (!netif_is_bridge_master(upper))
+ 		return NOTIFY_DONE;
+ 
+ 	switch (event) {
+ 	case SWITCHDEV_FDB_ADD_TO_DEVICE:
+ 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
+ 		fdb_info = container_of(info,
+ 					struct switchdev_notifier_fdb_info,
+ 					info);
+ 
+ 		work = mlx5_esw_bridge_init_switchdev_fdb_work(dev,
+ 							       event == SWITCHDEV_FDB_ADD_TO_DEVICE,
+ 							       fdb_info);
+ 		if (IS_ERR(work)) {
+ 			WARN_ONCE(1, "Failed to init switchdev work, err=%ld",
+ 				  PTR_ERR(work));
+ 			return notifier_from_errno(PTR_ERR(work));
+ 		}
+ 
+ 		queue_work(br_offloads->wq, &work->work);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 	return NOTIFY_DONE;
+ }
+ 
+ static void mlx5_esw_bridge_update_work(struct work_struct *work)
+ {
+ 	struct mlx5_esw_bridge_offloads *br_offloads = container_of(work,
+ 								    struct mlx5_esw_bridge_offloads,
+ 								    update_work.work);
+ 
+ 	rtnl_lock();
+ 	mlx5_esw_bridge_update(br_offloads);
+ 	rtnl_unlock();
+ 
+ 	queue_delayed_work(br_offloads->wq, &br_offloads->update_work,
+ 			   msecs_to_jiffies(MLX5_ESW_BRIDGE_UPDATE_INTERVAL));
+ }
+ 
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  void mlx5e_rep_bridge_init(struct mlx5e_priv *priv)
  {
  	struct mlx5_esw_bridge_offloads *br_offloads;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
index b503562f97d0,eec5897c6b79..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
@@@ -3,6 -3,9 +3,12 @@@
  
  #include <linux/netdevice.h>
  #include <linux/list.h>
++<<<<<<< HEAD
++=======
+ #include <linux/rhashtable.h>
+ #include <linux/xarray.h>
+ #include <linux/if_bridge.h>
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  #include <net/switchdev.h>
  #include "bridge.h"
  #include "eswitch.h"
@@@ -21,15 -24,78 +27,75 @@@ enum 
  	MLX5_ESW_BRIDGE_LEVEL_EGRESS_TABLE,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_esw_bridge_fdb_key {
+ 	unsigned char addr[ETH_ALEN];
+ 	u16 vid;
+ };
+ 
+ enum {
+ 	MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER = BIT(0),
+ };
+ 
+ struct mlx5_esw_bridge_fdb_entry {
+ 	struct mlx5_esw_bridge_fdb_key key;
+ 	struct rhash_head ht_node;
+ 	struct net_device *dev;
+ 	struct list_head list;
+ 	u16 vport_num;
+ 	u16 flags;
+ 
+ 	struct mlx5_flow_handle *ingress_handle;
+ 	struct mlx5_fc *ingress_counter;
+ 	unsigned long lastuse;
+ 	struct mlx5_flow_handle *egress_handle;
+ };
+ 
+ static const struct rhashtable_params fdb_ht_params = {
+ 	.key_offset = offsetof(struct mlx5_esw_bridge_fdb_entry, key),
+ 	.key_len = sizeof(struct mlx5_esw_bridge_fdb_key),
+ 	.head_offset = offsetof(struct mlx5_esw_bridge_fdb_entry, ht_node),
+ 	.automatic_shrinking = true,
+ };
+ 
+ struct mlx5_esw_bridge_vlan {
+ 	u16 vid;
+ 	u16 flags;
+ };
+ 
+ struct mlx5_esw_bridge_port {
+ 	u16 vport_num;
+ 	struct xarray vlans;
+ };
+ 
+ enum {
+ 	MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG = BIT(0),
+ };
+ 
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  struct mlx5_esw_bridge {
  	int ifindex;
  	int refcnt;
  	struct list_head list;
++<<<<<<< HEAD
++
++	struct mlx5_flow_table *egress_ft;
++	struct mlx5_flow_group *egress_mac_fg;
++=======
+ 	struct mlx5_esw_bridge_offloads *br_offloads;
+ 
+ 	struct list_head fdb_list;
+ 	struct rhashtable fdb_ht;
+ 	struct xarray vports;
  
  	struct mlx5_flow_table *egress_ft;
  	struct mlx5_flow_group *egress_mac_fg;
+ 	unsigned long ageing_time;
+ 	u32 flags;
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  };
  
 -static void
 -mlx5_esw_bridge_fdb_offload_notify(struct net_device *dev, const unsigned char *addr, u16 vid,
 -				   unsigned long val)
 -{
 -	struct switchdev_notifier_fdb_info send_info;
 -
 -	send_info.addr = addr;
 -	send_info.vid = vid;
 -	send_info.offloaded = true;
 -	call_switchdev_notifiers(val, dev, &send_info.info, NULL);
 -}
 -
  static struct mlx5_flow_table *
  mlx5_esw_bridge_table_create(int max_fte, u32 level, struct mlx5_eswitch *esw)
  {
@@@ -208,8 -357,15 +274,17 @@@ static struct mlx5_esw_bridge *mlx5_esw
  	if (err)
  		goto err_egress_tbl;
  
++<<<<<<< HEAD
++=======
+ 	err = rhashtable_init(&bridge->fdb_ht, &fdb_ht_params);
+ 	if (err)
+ 		goto err_fdb_ht;
+ 
+ 	INIT_LIST_HEAD(&bridge->fdb_list);
+ 	xa_init(&bridge->vports);
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  	bridge->ifindex = ifindex;
  	bridge->refcnt = 1;
 -	bridge->ageing_time = BR_DEFAULT_AGEING_TIME;
  	list_add(&bridge->list, &br_offloads->bridges);
  
  	return bridge;
@@@ -231,7 -389,9 +306,8 @@@ static void mlx5_esw_bridge_put(struct 
  		return;
  
  	mlx5_esw_bridge_egress_table_cleanup(bridge);
+ 	WARN_ON(!xa_empty(&bridge->vports));
  	list_del(&bridge->list);
 -	rhashtable_destroy(&bridge->fdb_ht);
  	kvfree(bridge);
  
  	if (list_empty(&br_offloads->bridges))
@@@ -265,17 -425,255 +341,263 @@@ mlx5_esw_bridge_lookup(int ifindex, str
  	return bridge;
  }
  
++<<<<<<< HEAD
 +static int mlx5_esw_bridge_vport_init(struct mlx5_esw_bridge *bridge,
++=======
+ static int mlx5_esw_bridge_port_insert(struct mlx5_esw_bridge_port *port,
+ 				       struct mlx5_esw_bridge *bridge)
+ {
+ 	return xa_insert(&bridge->vports, port->vport_num, port, GFP_KERNEL);
+ }
+ 
+ static struct mlx5_esw_bridge_port *
+ mlx5_esw_bridge_port_lookup(u16 vport_num, struct mlx5_esw_bridge *bridge)
+ {
+ 	return xa_load(&bridge->vports, vport_num);
+ }
+ 
+ static void mlx5_esw_bridge_port_erase(struct mlx5_esw_bridge_port *port,
+ 				       struct mlx5_esw_bridge *bridge)
+ {
+ 	xa_erase(&bridge->vports, port->vport_num);
+ }
+ 
+ static void
+ mlx5_esw_bridge_fdb_entry_cleanup(struct mlx5_esw_bridge_fdb_entry *entry,
+ 				  struct mlx5_esw_bridge *bridge)
+ {
+ 	rhashtable_remove_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);
+ 	mlx5_del_flow_rules(entry->egress_handle);
+ 	mlx5_del_flow_rules(entry->ingress_handle);
+ 	mlx5_fc_destroy(bridge->br_offloads->esw->dev, entry->ingress_counter);
+ 	list_del(&entry->list);
+ 	kvfree(entry);
+ }
+ 
+ static void mlx5_esw_bridge_fdb_flush(struct mlx5_esw_bridge *bridge)
+ {
+ 	struct mlx5_esw_bridge_fdb_entry *entry, *tmp;
+ 
+ 	list_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list) {
+ 		if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER))
+ 			mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
+ 							   entry->key.vid,
+ 							   SWITCHDEV_FDB_DEL_TO_BRIDGE);
+ 		mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
+ 	}
+ }
+ 
+ static struct mlx5_esw_bridge_vlan *
+ mlx5_esw_bridge_vlan_lookup(u16 vid, struct mlx5_esw_bridge_port *port)
+ {
+ 	return xa_load(&port->vlans, vid);
+ }
+ 
+ static struct mlx5_esw_bridge_vlan *
+ mlx5_esw_bridge_vlan_create(u16 vid, u16 flags, struct mlx5_esw_bridge_port *port)
+ {
+ 	struct mlx5_esw_bridge_vlan *vlan;
+ 	int err;
+ 
+ 	vlan = kvzalloc(sizeof(*vlan), GFP_KERNEL);
+ 	if (!vlan)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	vlan->vid = vid;
+ 	vlan->flags = flags;
+ 	err = xa_insert(&port->vlans, vid, vlan, GFP_KERNEL);
+ 	if (err) {
+ 		kvfree(vlan);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return vlan;
+ }
+ 
+ static void mlx5_esw_bridge_vlan_erase(struct mlx5_esw_bridge_port *port,
+ 				       struct mlx5_esw_bridge_vlan *vlan)
+ {
+ 	xa_erase(&port->vlans, vlan->vid);
+ }
+ 
+ static void mlx5_esw_bridge_vlan_cleanup(struct mlx5_esw_bridge_port *port,
+ 					 struct mlx5_esw_bridge_vlan *vlan)
+ {
+ 	mlx5_esw_bridge_vlan_erase(port, vlan);
+ 	kvfree(vlan);
+ }
+ 
+ static void mlx5_esw_bridge_port_vlans_flush(struct mlx5_esw_bridge_port *port)
+ {
+ 	struct mlx5_esw_bridge_vlan *vlan;
+ 	unsigned long index;
+ 
+ 	xa_for_each(&port->vlans, index, vlan)
+ 		mlx5_esw_bridge_vlan_cleanup(port, vlan);
+ }
+ 
+ static struct mlx5_esw_bridge_fdb_entry *
+ mlx5_esw_bridge_fdb_entry_init(struct net_device *dev, u16 vport_num, const unsigned char *addr,
+ 			       u16 vid, bool added_by_user, struct mlx5_eswitch *esw,
+ 			       struct mlx5_esw_bridge *bridge)
+ {
+ 	struct mlx5_esw_bridge_fdb_entry *entry;
+ 	struct mlx5_flow_handle *handle;
+ 	struct mlx5_fc *counter;
+ 	struct mlx5e_priv *priv;
+ 	int err;
+ 
+ 	priv = netdev_priv(dev);
+ 	entry = kvzalloc(sizeof(*entry), GFP_KERNEL);
+ 	if (!entry)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	ether_addr_copy(entry->key.addr, addr);
+ 	entry->key.vid = vid;
+ 	entry->dev = dev;
+ 	entry->vport_num = vport_num;
+ 	entry->lastuse = jiffies;
+ 	if (added_by_user)
+ 		entry->flags |= MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER;
+ 
+ 	counter = mlx5_fc_create(priv->mdev, true);
+ 	if (IS_ERR(counter)) {
+ 		err = PTR_ERR(counter);
+ 		goto err_ingress_fc_create;
+ 	}
+ 	entry->ingress_counter = counter;
+ 
+ 	handle = mlx5_esw_bridge_ingress_flow_create(vport_num, addr, vid, mlx5_fc_id(counter),
+ 						     bridge);
+ 	if (IS_ERR(handle)) {
+ 		err = PTR_ERR(handle);
+ 		esw_warn(esw->dev, "Failed to create ingress flow(vport=%u,err=%d)\n",
+ 			 vport_num, err);
+ 		goto err_ingress_flow_create;
+ 	}
+ 	entry->ingress_handle = handle;
+ 
+ 	handle = mlx5_esw_bridge_egress_flow_create(vport_num, addr, vid, bridge);
+ 	if (IS_ERR(handle)) {
+ 		err = PTR_ERR(handle);
+ 		esw_warn(esw->dev, "Failed to create egress flow(vport=%u,err=%d)\n",
+ 			 vport_num, err);
+ 		goto err_egress_flow_create;
+ 	}
+ 	entry->egress_handle = handle;
+ 
+ 	err = rhashtable_insert_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);
+ 	if (err) {
+ 		esw_warn(esw->dev, "Failed to insert FDB flow(vport=%u,err=%d)\n", vport_num, err);
+ 		goto err_ht_init;
+ 	}
+ 
+ 	list_add(&entry->list, &bridge->fdb_list);
+ 	return entry;
+ 
+ err_ht_init:
+ 	mlx5_del_flow_rules(entry->egress_handle);
+ err_egress_flow_create:
+ 	mlx5_del_flow_rules(entry->ingress_handle);
+ err_ingress_flow_create:
+ 	mlx5_fc_destroy(priv->mdev, entry->ingress_counter);
+ err_ingress_fc_create:
+ 	kvfree(entry);
+ 	return ERR_PTR(err);
+ }
+ 
+ int mlx5_esw_bridge_ageing_time_set(unsigned long ageing_time, struct mlx5_eswitch *esw,
+ 				    struct mlx5_vport *vport)
+ {
+ 	if (!vport->bridge)
+ 		return -EINVAL;
+ 
+ 	vport->bridge->ageing_time = ageing_time;
+ 	return 0;
+ }
+ 
+ int mlx5_esw_bridge_vlan_filtering_set(bool enable, struct mlx5_eswitch *esw,
+ 				       struct mlx5_vport *vport)
+ {
+ 	struct mlx5_esw_bridge *bridge;
+ 	bool filtering;
+ 
+ 	if (!vport->bridge)
+ 		return -EINVAL;
+ 
+ 	bridge = vport->bridge;
+ 	filtering = bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;
+ 	if (filtering == enable)
+ 		return 0;
+ 
+ 	mlx5_esw_bridge_fdb_flush(bridge);
+ 	if (enable)
+ 		bridge->flags |= MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;
+ 	else
+ 		bridge->flags &= ~MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_esw_bridge_vport_init(struct mlx5_esw_bridge_offloads *br_offloads,
+ 				      struct mlx5_esw_bridge *bridge,
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  				      struct mlx5_vport *vport)
  {
+ 	struct mlx5_eswitch *esw = br_offloads->esw;
+ 	struct mlx5_esw_bridge_port *port;
+ 	int err;
+ 
+ 	port = kvzalloc(sizeof(*port), GFP_KERNEL);
+ 	if (!port) {
+ 		err = -ENOMEM;
+ 		goto err_port_alloc;
+ 	}
+ 
+ 	port->vport_num = vport->vport;
+ 	xa_init(&port->vlans);
+ 	err = mlx5_esw_bridge_port_insert(port, bridge);
+ 	if (err) {
+ 		esw_warn(esw->dev, "Failed to insert port metadata (vport=%u,err=%d)\n",
+ 			 vport->vport, err);
+ 		goto err_port_insert;
+ 	}
+ 
  	vport->bridge = bridge;
  	return 0;
+ 
+ err_port_insert:
+ 	kvfree(port);
+ err_port_alloc:
+ 	mlx5_esw_bridge_put(br_offloads, bridge);
+ 	return err;
  }
  
  static int mlx5_esw_bridge_vport_cleanup(struct mlx5_esw_bridge_offloads *br_offloads,
  					 struct mlx5_vport *vport)
  {
++<<<<<<< HEAD
 +	mlx5_esw_bridge_put(br_offloads, vport->bridge);
++=======
+ 	struct mlx5_esw_bridge *bridge = vport->bridge;
+ 	struct mlx5_esw_bridge_fdb_entry *entry, *tmp;
+ 	struct mlx5_esw_bridge_port *port;
+ 
+ 	list_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list)
+ 		if (entry->vport_num == vport->vport)
+ 			mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
+ 
+ 	port = mlx5_esw_bridge_port_lookup(vport->vport, bridge);
+ 	if (!port) {
+ 		WARN(1, "Vport %u metadata not found on bridge", vport->vport);
+ 		return -EINVAL;
+ 	}
+ 
+ 	mlx5_esw_bridge_port_vlans_flush(port);
+ 	mlx5_esw_bridge_port_erase(port, bridge);
+ 	kvfree(port);
+ 	mlx5_esw_bridge_put(br_offloads, bridge);
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  	vport->bridge = NULL;
  	return 0;
  }
@@@ -299,7 -701,10 +625,14 @@@ int mlx5_esw_bridge_vport_link(int ifin
  int mlx5_esw_bridge_vport_unlink(int ifindex, struct mlx5_esw_bridge_offloads *br_offloads,
  				 struct mlx5_vport *vport, struct netlink_ext_ack *extack)
  {
++<<<<<<< HEAD
 +	if (!vport->bridge) {
++=======
+ 	struct mlx5_esw_bridge *bridge = vport->bridge;
+ 	int err;
+ 
+ 	if (!bridge) {
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  		NL_SET_ERR_MSG_MOD(extack, "Port is not attached to any bridge");
  		return -EINVAL;
  	}
@@@ -308,9 -713,137 +641,51 @@@
  		return -EINVAL;
  	}
  
- 	return mlx5_esw_bridge_vport_cleanup(br_offloads, vport);
+ 	err = mlx5_esw_bridge_vport_cleanup(br_offloads, vport);
+ 	if (err)
+ 		NL_SET_ERR_MSG_MOD(extack, "Port cleanup failed");
+ 	return err;
+ }
+ 
+ int mlx5_esw_bridge_port_vlan_add(u16 vid, u16 flags, struct mlx5_eswitch *esw,
+ 				  struct mlx5_vport *vport, struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_esw_bridge_port *port;
+ 	struct mlx5_esw_bridge_vlan *vlan;
+ 
+ 	port = mlx5_esw_bridge_port_lookup(vport->vport, vport->bridge);
+ 	if (!port)
+ 		return -EINVAL;
+ 
+ 	vlan = mlx5_esw_bridge_vlan_lookup(vid, port);
+ 	if (vlan) {
+ 		vlan->flags = flags;
+ 		return 0;
+ 	}
+ 
+ 	vlan = mlx5_esw_bridge_vlan_create(vid, flags, port);
+ 	if (IS_ERR(vlan)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Failed to create VLAN entry");
+ 		return PTR_ERR(vlan);
+ 	}
+ 	return 0;
+ }
+ 
+ void mlx5_esw_bridge_port_vlan_del(u16 vid, struct mlx5_eswitch *esw, struct mlx5_vport *vport)
+ {
+ 	struct mlx5_esw_bridge_port *port;
+ 	struct mlx5_esw_bridge_vlan *vlan;
+ 
+ 	port = mlx5_esw_bridge_port_lookup(vport->vport, vport->bridge);
+ 	if (!port)
+ 		return;
+ 
+ 	vlan = mlx5_esw_bridge_vlan_lookup(vid, port);
+ 	if (!vlan)
+ 		return;
+ 	mlx5_esw_bridge_vlan_cleanup(port, vlan);
  }
  
 -void mlx5_esw_bridge_fdb_create(struct net_device *dev, struct mlx5_eswitch *esw,
 -				struct mlx5_vport *vport,
 -				struct switchdev_notifier_fdb_info *fdb_info)
 -{
 -	struct mlx5_esw_bridge *bridge = vport->bridge;
 -	struct mlx5_esw_bridge_fdb_entry *entry;
 -	u16 vport_num = vport->vport;
 -
 -	if (!bridge) {
 -		esw_info(esw->dev, "Vport is not assigned to bridge (vport=%u)\n", vport_num);
 -		return;
 -	}
 -
 -	entry = mlx5_esw_bridge_fdb_entry_init(dev, vport_num, fdb_info->addr, fdb_info->vid,
 -					       fdb_info->added_by_user, esw, bridge);
 -	if (IS_ERR(entry))
 -		return;
 -
 -	if (entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER)
 -		mlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,
 -						   SWITCHDEV_FDB_OFFLOADED);
 -	else
 -		/* Take over dynamic entries to prevent kernel bridge from aging them out. */
 -		mlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,
 -						   SWITCHDEV_FDB_ADD_TO_BRIDGE);
 -}
 -
 -void mlx5_esw_bridge_fdb_remove(struct net_device *dev, struct mlx5_eswitch *esw,
 -				struct mlx5_vport *vport,
 -				struct switchdev_notifier_fdb_info *fdb_info)
 -{
 -	struct mlx5_esw_bridge *bridge = vport->bridge;
 -	struct mlx5_esw_bridge_fdb_entry *entry;
 -	struct mlx5_esw_bridge_fdb_key key;
 -	u16 vport_num = vport->vport;
 -
 -	if (!bridge) {
 -		esw_warn(esw->dev, "Vport is not assigned to bridge (vport=%u)\n", vport_num);
 -		return;
 -	}
 -
 -	ether_addr_copy(key.addr, fdb_info->addr);
 -	key.vid = fdb_info->vid;
 -	entry = rhashtable_lookup_fast(&bridge->fdb_ht, &key, fdb_ht_params);
 -	if (!entry) {
 -		esw_warn(esw->dev,
 -			 "FDB entry with specified key not found (MAC=%pM,vid=%u,vport=%u)\n",
 -			 key.addr, key.vid, vport_num);
 -		return;
 -	}
 -
 -	if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER))
 -		mlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,
 -						   SWITCHDEV_FDB_DEL_TO_BRIDGE);
 -	mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
 -}
 -
 -void mlx5_esw_bridge_update(struct mlx5_esw_bridge_offloads *br_offloads)
 -{
 -	struct mlx5_esw_bridge_fdb_entry *entry, *tmp;
 -	struct mlx5_esw_bridge *bridge;
 -
 -	list_for_each_entry(bridge, &br_offloads->bridges, list) {
 -		list_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list) {
 -			unsigned long lastuse =
 -				(unsigned long)mlx5_fc_query_lastuse(entry->ingress_counter);
 -
 -			if (entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER)
 -				continue;
 -
 -			if (time_after(lastuse, entry->lastuse)) {
 -				entry->lastuse = lastuse;
 -				/* refresh existing bridge entry */
 -				mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
 -								   entry->key.vid,
 -								   SWITCHDEV_FDB_ADD_TO_BRIDGE);
 -			} else if (time_is_before_jiffies(entry->lastuse + bridge->ageing_time)) {
 -				mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
 -								   entry->key.vid,
 -								   SWITCHDEV_FDB_DEL_TO_BRIDGE);
 -				mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
 -			}
 -		}
 -	}
 -}
 -
  static void mlx5_esw_bridge_flush(struct mlx5_esw_bridge_offloads *br_offloads)
  {
  	struct mlx5_eswitch *esw = br_offloads->esw;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
index 319b6f1db0ba,276ed0392607..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
@@@ -26,5 -31,19 +26,22 @@@ int mlx5_esw_bridge_vport_link(int ifin
  			       struct mlx5_vport *vport, struct netlink_ext_ack *extack);
  int mlx5_esw_bridge_vport_unlink(int ifindex, struct mlx5_esw_bridge_offloads *br_offloads,
  				 struct mlx5_vport *vport, struct netlink_ext_ack *extack);
++<<<<<<< HEAD
++=======
+ void mlx5_esw_bridge_fdb_create(struct net_device *dev, struct mlx5_eswitch *esw,
+ 				struct mlx5_vport *vport,
+ 				struct switchdev_notifier_fdb_info *fdb_info);
+ void mlx5_esw_bridge_fdb_remove(struct net_device *dev, struct mlx5_eswitch *esw,
+ 				struct mlx5_vport *vport,
+ 				struct switchdev_notifier_fdb_info *fdb_info);
+ void mlx5_esw_bridge_update(struct mlx5_esw_bridge_offloads *br_offloads);
+ int mlx5_esw_bridge_ageing_time_set(unsigned long ageing_time, struct mlx5_eswitch *esw,
+ 				    struct mlx5_vport *vport);
+ int mlx5_esw_bridge_vlan_filtering_set(bool enable, struct mlx5_eswitch *esw,
+ 				       struct mlx5_vport *vport);
+ int mlx5_esw_bridge_port_vlan_add(u16 vid, u16 flags, struct mlx5_eswitch *esw,
+ 				  struct mlx5_vport *vport, struct netlink_ext_ack *extack);
+ void mlx5_esw_bridge_port_vlan_del(u16 vid, struct mlx5_eswitch *esw, struct mlx5_vport *vport);
++>>>>>>> d75b9e804858 (net/mlx5: Bridge, implement infrastructure for vlans)
  
  #endif /* __MLX5_ESW_BRIDGE_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
