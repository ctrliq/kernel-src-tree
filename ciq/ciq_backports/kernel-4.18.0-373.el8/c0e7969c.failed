ASoC: SOF: topology: Add kernel parameter for topology verification

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit c0e7969cf9c4fd347b33a8056960e8448f6b51c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/c0e7969c.failed

Add a kernel debug flag to enable a one-shot topology
verification for all pipelines including the dynamic
ones. If the debug flag is set, all the topology
component loading will be verified during the complete
callback.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
Link: https://lore.kernel.org/r/20210927120517.20505-13-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit c0e7969cf9c4fd347b33a8056960e8448f6b51c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/sof-audio.c
diff --cc sound/soc/sof/sof-audio.c
index bf5e7c7019a5,c4cabe26b157..000000000000
--- a/sound/soc/sof/sof-audio.c
+++ b/sound/soc/sof/sof-audio.c
@@@ -314,8 -598,28 +314,33 @@@ int sof_set_up_pipelines(struct device 
  
  	/* restore pipeline components */
  	list_for_each_entry_reverse(swidget, &sdev->widget_list, list) {
++<<<<<<< HEAD
 +		/* reset widget use_count after resuming */
 +		swidget->use_count = 0;
++=======
+ 		/* only set up the widgets belonging to static pipelines */
+ 		if (!verify && swidget->dynamic_pipeline_widget)
+ 			continue;
+ 
+ 		/* update DAI config. The IPC will be sent in sof_widget_setup() */
+ 		if (WIDGET_IS_DAI(swidget->id)) {
+ 			struct snd_sof_dai *dai = swidget->private;
+ 			struct sof_ipc_dai_config *config;
+ 
+ 			if (!dai || !dai->dai_config)
+ 				continue;
+ 
+ 			config = dai->dai_config;
+ 			/*
+ 			 * The link DMA channel would be invalidated for running
+ 			 * streams but not for streams that were in the PAUSED
+ 			 * state during suspend. So invalidate it here before setting
+ 			 * the dai config in the DSP.
+ 			 */
+ 			if (config->type == SOF_DAI_INTEL_HDA)
+ 				config->hda.link_dma_ch = DMA_CHAN_INVALID;
+ 		}
++>>>>>>> c0e7969cf9c4 (ASoC: SOF: topology: Add kernel parameter for topology verification)
  
  		ret = sof_widget_setup(sdev, swidget);
  		if (ret < 0)
@@@ -323,56 -627,28 +348,69 @@@
  	}
  
  	/* restore pipeline connections */
 -	list_for_each_entry(sroute, &sdev->route_list, list) {
 -
 +	list_for_each_entry_reverse(sroute, &sdev->route_list, list) {
 +		struct sof_ipc_pipe_comp_connect *connect;
 +		struct sof_ipc_reply reply;
 +
++<<<<<<< HEAD
 +		/* skip if there's no private data */
 +		if (!sroute->private)
++=======
+ 		/* only set up routes belonging to static pipelines */
+ 		if (!verify && (sroute->src_widget->dynamic_pipeline_widget ||
+ 				sroute->sink_widget->dynamic_pipeline_widget))
++>>>>>>> c0e7969cf9c4 (ASoC: SOF: topology: Add kernel parameter for topology verification)
  			continue;
  
 -		ret = sof_route_setup_ipc(sdev, sroute);
 +		connect = sroute->private;
 +
 +		/* send ipc */
 +		ret = sof_ipc_tx_message(sdev->ipc,
 +					 connect->hdr.cmd,
 +					 connect, sizeof(*connect),
 +					 &reply, sizeof(reply));
  		if (ret < 0) {
 -			dev_err(sdev->dev, "%s: restore pipeline connections failed\n", __func__);
 +			dev_err(dev,
 +				"error: failed to load route sink %s control %s source %s\n",
 +				sroute->route->sink,
 +				sroute->route->control ? sroute->route->control
 +					: "none",
 +				sroute->route->source);
 +
  			return ret;
  		}
 +		sroute->setup = true;
 +	}
 +
 +	/* restore dai links */
 +	list_for_each_entry_reverse(dai, &sdev->dai_list, list) {
 +		struct sof_ipc_dai_config *config = &dai->dai_config[dai->current_config];
 +
 +		/*
 +		 * The link DMA channel would be invalidated for running
 +		 * streams but not for streams that were in the PAUSED
 +		 * state during suspend. So invalidate it here before setting
 +		 * the dai config in the DSP.
 +		 */
 +		if (config->type == SOF_DAI_INTEL_HDA)
 +			config->hda.link_dma_ch = DMA_CHAN_INVALID;
 +
 +		ret = sof_dai_config_setup(sdev, dai);
 +		if (ret < 0)
 +			return ret;
  	}
  
  	/* complete pipeline */
  	list_for_each_entry(swidget, &sdev->widget_list, list) {
  		switch (swidget->id) {
  		case snd_soc_dapm_scheduler:
++<<<<<<< HEAD
++=======
+ 			/* only complete static pipelines */
+ 			if (!verify && swidget->dynamic_pipeline_widget)
+ 				continue;
+ 
++>>>>>>> c0e7969cf9c4 (ASoC: SOF: topology: Add kernel parameter for topology verification)
  			swidget->complete =
  				snd_sof_complete_pipeline(dev, swidget);
  			break;
diff --git a/sound/soc/sof/pm.c b/sound/soc/sof/pm.c
index 891e8b924fb7..77a3496d3dbd 100644
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@ -157,7 +157,7 @@ static int sof_resume(struct device *dev, bool runtime_resume)
 	}
 
 	/* restore pipelines */
-	ret = sof_set_up_pipelines(sdev->dev);
+	ret = sof_set_up_pipelines(sdev->dev, false);
 	if (ret < 0) {
 		dev_err(sdev->dev,
 			"error: failed to restore pipeline after resume %d\n",
@@ -208,7 +208,7 @@ static int sof_suspend(struct device *dev, bool runtime_suspend)
 	if (target_state == SOF_DSP_PM_D0)
 		goto suspend;
 
-	sof_tear_down_pipelines(dev);
+	sof_tear_down_pipelines(dev, false);
 
 	/* release trace */
 	snd_sof_release_trace(sdev);
* Unmerged path sound/soc/sof/sof-audio.c
diff --git a/sound/soc/sof/sof-audio.h b/sound/soc/sof/sof-audio.h
index d358d455da1e..9d771759b6cb 100644
--- a/sound/soc/sof/sof-audio.h
+++ b/sound/soc/sof/sof-audio.h
@@ -243,8 +243,8 @@ int snd_sof_ipc_set_get_comp_data(struct snd_sof_control *scontrol,
 int sof_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_hw_params *params);
 
 /* PM */
-int sof_set_up_pipelines(struct device *dev);
-void sof_tear_down_pipelines(struct device *dev);
+int sof_set_up_pipelines(struct device *dev, bool verify);
+int sof_tear_down_pipelines(struct device *dev, bool verify);
 int sof_set_hw_params_upon_resume(struct device *dev);
 bool snd_sof_stream_suspend_ignored(struct snd_sof_dev *sdev);
 bool snd_sof_dsp_only_d0i3_compatible_stream_active(struct snd_sof_dev *sdev);
diff --git a/sound/soc/sof/sof-priv.h b/sound/soc/sof/sof-priv.h
index 94632a45d6b0..bb4ded5fb1df 100644
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@ -23,6 +23,7 @@
 /* debug flags */
 #define SOF_DBG_ENABLE_TRACE	BIT(0)
 #define SOF_DBG_RETAIN_CTX	BIT(1)	/* prevent DSP D3 on FW exception */
+#define SOF_DBG_VERIFY_TPLG	BIT(2) /* verify topology during load */
 
 #define SOF_DBG_DUMP_REGS		BIT(0)
 #define SOF_DBG_DUMP_MBOX		BIT(1)
diff --git a/sound/soc/sof/topology.c b/sound/soc/sof/topology.c
index cfef4151c798..43e7c60b44ab 100644
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@ -3449,8 +3449,23 @@ static int sof_complete(struct snd_soc_component *scomp)
 		}
 	}
 
+	/* verify topology components loading including dynamic pipelines */
+	if (sof_core_debug & SOF_DBG_VERIFY_TPLG) {
+		ret = sof_set_up_pipelines(scomp->dev, true);
+		if (ret < 0) {
+			dev_err(sdev->dev, "error: topology verification failed %d\n", ret);
+			return ret;
+		}
+
+		ret = sof_tear_down_pipelines(scomp->dev, true);
+		if (ret < 0) {
+			dev_err(sdev->dev, "error: topology tear down pipelines failed %d\n", ret);
+			return ret;
+		}
+	}
+
 	/* set up static pipelines */
-	return sof_set_up_pipelines(scomp->dev);
+	return sof_set_up_pipelines(scomp->dev, false);
 }
 
 /* manifest - optional to inform component of manifest */
