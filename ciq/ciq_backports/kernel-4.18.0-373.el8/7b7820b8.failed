xfs: don't expose internal symlink metadata buffers to the vfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-373.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 7b7820b83f230036fc48c3e7fb280c48c58adebf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-373.el8/7b7820b8.failed

Ian Kent reported that for inline symlinks, it's possible for
vfs_readlink to hang on to the target buffer returned by
_vn_get_link_inline long after it's been freed by xfs inode reclaim.
This is a layering violation -- we should never expose XFS internals to
the VFS.

When the symlink has a remote target, we allocate a separate buffer,
copy the internal information, and let the VFS manage the new buffer's
lifetime.  Let's adapt the inline code paths to do this too.  It's
less efficient, but fixes the layering violation and avoids the need to
adapt the if_data lifetime to rcu rules.  Clearly I don't care about
readlink benchmarks.

As a side note, this fixes the minor locking violation where we can
access the inode data fork without taking any locks; proper locking (and
eliminating the possibility of having to switch inode_operations on a
live inode) is essential to online repair coordinating repairs
correctly.

	Reported-by: Ian Kent <raven@themaw.net>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 7b7820b83f230036fc48c3e7fb280c48c58adebf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iops.c
#	fs/xfs/xfs_symlink.c
diff --cc fs/xfs/xfs_iops.c
index 310b59c17f4a,72bdd7c79e93..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -469,27 -511,6 +469,30 @@@ xfs_vn_get_link
  	return ERR_PTR(error);
  }
  
++<<<<<<< HEAD
 +STATIC const char *
 +xfs_vn_get_link_inline(
 +	struct dentry		*dentry,
 +	struct inode		*inode,
 +	struct delayed_call	*done)
 +{
 +	struct xfs_inode	*ip = XFS_I(inode);
 +	char			*link;
 +
 +	ASSERT(ip->i_df.if_flags & XFS_IFINLINE);
 +
 +	/*
 +	 * The VFS crashes on a NULL pointer, so return -EFSCORRUPTED if
 +	 * if_data is junk.
 +	 */
 +	link = ip->i_df.if_u1.if_data;
 +	if (XFS_IS_CORRUPT(ip->i_mount, !link))
 +		return ERR_PTR(-EFSCORRUPTED);
 +	return link;
 +}
 +
++=======
++>>>>>>> 7b7820b83f23 (xfs: don't expose internal symlink metadata buffers to the vfs)
  static uint32_t
  xfs_stat_blksize(
  	struct xfs_inode	*ip)
@@@ -1377,10 -1379,7 +1372,14 @@@ xfs_setup_iops
  		inode->i_fop = &xfs_dir_file_operations;
  		break;
  	case S_IFLNK:
++<<<<<<< HEAD
 +		if (ip->i_df.if_flags & XFS_IFINLINE)
 +			inode->i_op = &xfs_inline_symlink_inode_operations;
 +		else
 +			inode->i_op = &xfs_symlink_inode_operations;
++=======
+ 		inode->i_op = &xfs_symlink_inode_operations;
++>>>>>>> 7b7820b83f23 (xfs: don't expose internal symlink metadata buffers to the vfs)
  		break;
  	default:
  		inode->i_op = &xfs_inode_operations;
diff --cc fs/xfs/xfs_symlink.c
index 1f43fd7f3209,b1f70651acb5..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -21,6 -21,8 +21,11 @@@
  #include "xfs_trans_space.h"
  #include "xfs_trace.h"
  #include "xfs_trans.h"
++<<<<<<< HEAD
++=======
+ #include "xfs_ialloc.h"
+ #include "xfs_error.h"
++>>>>>>> 7b7820b83f23 (xfs: don't expose internal symlink metadata buffers to the vfs)
  
  /* ----- Kernel only functions below ----- */
  int
@@@ -104,9 -106,7 +109,13 @@@ xfs_readlink
  
  	trace_xfs_readlink(ip);
  
++<<<<<<< HEAD
 +	ASSERT(!(ip->i_df.if_flags & XFS_IFINLINE));
 +
 +	if (XFS_FORCED_SHUTDOWN(mp))
++=======
+ 	if (xfs_is_shutdown(mp))
++>>>>>>> 7b7820b83f23 (xfs: don't expose internal symlink metadata buffers to the vfs)
  		return -EIO;
  
  	xfs_ilock(ip, XFS_ILOCK_SHARED);
* Unmerged path fs/xfs/xfs_iops.c
* Unmerged path fs/xfs/xfs_symlink.c
