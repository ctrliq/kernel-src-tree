clocksource/drivers/arm_arch_timer: Drop CNT*_TVAL read accessors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-543.el8
commit-author Marc Zyngier <maz@kernel.org>
commit d72689988d67d56aebf7afb7f609373ea6b548db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-543.el8/d7268998.failed

The arch timer driver never reads the various TVAL registers, only
writes to them. It is thus pointless to provide accessors
for them and to implement errata workarounds.

Drop these read-side accessors, and add a couple of BUG() statements
for the time being. These statements will be removed further down
the line.

	Reviewed-by: Oliver Upton <oupton@google.com>
	Reviewed-by: Mark Rutland <mark.rutland@arm.com>
	Tested-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20211017124225.3018098-3-maz@kernel.org
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
(cherry picked from commit d72689988d67d56aebf7afb7f609373ea6b548db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/clocksource/arm_arch_timer.c
diff --cc drivers/clocksource/arm_arch_timer.c
index 64d1227648a9,67bdc7288f59..000000000000
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@@ -351,6 -331,38 +325,41 @@@ static u64 notrace arm64_858921_read_cn
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SUN50I_ERRATUM_UNKNOWN1
+ /*
+  * The low bits of the counter registers are indeterminate while bit 10 or
+  * greater is rolling over. Since the counter value can jump both backward
+  * (7ff -> 000 -> 800) and forward (7ff -> fff -> 800), ignore register values
+  * with all ones or all zeros in the low bits. Bound the loop by the maximum
+  * number of CPU cycles in 3 consecutive 24 MHz counter periods.
+  */
+ #define __sun50i_a64_read_reg(reg) ({					\
+ 	u64 _val;							\
+ 	int _retries = 150;						\
+ 									\
+ 	do {								\
+ 		_val = read_sysreg(reg);				\
+ 		_retries--;						\
+ 	} while (((_val + 1) & GENMASK(8, 0)) <= 1 && _retries);	\
+ 									\
+ 	WARN_ON_ONCE(!_retries);					\
+ 	_val;								\
+ })
+ 
+ static u64 notrace sun50i_a64_read_cntpct_el0(void)
+ {
+ 	return __sun50i_a64_read_reg(cntpct_el0);
+ }
+ 
+ static u64 notrace sun50i_a64_read_cntvct_el0(void)
+ {
+ 	return __sun50i_a64_read_reg(cntvct_el0);
+ }
+ #endif
+ 
++>>>>>>> d72689988d67 (clocksource/drivers/arm_arch_timer: Drop CNT*_TVAL read accessors)
  #ifdef CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND
  DEFINE_PER_CPU(const struct arch_timer_erratum_workaround *, timer_unstable_counter_workaround);
  EXPORT_SYMBOL_GPL(timer_unstable_counter_workaround);
@@@ -439,6 -445,25 +442,28 @@@ static const struct arch_timer_erratum_
  		.read_cntvct_el0 = arm64_858921_read_cntvct_el0,
  	},
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SUN50I_ERRATUM_UNKNOWN1
+ 	{
+ 		.match_type = ate_match_dt,
+ 		.id = "allwinner,erratum-unknown1",
+ 		.desc = "Allwinner erratum UNKNOWN1",
+ 		.read_cntpct_el0 = sun50i_a64_read_cntpct_el0,
+ 		.read_cntvct_el0 = sun50i_a64_read_cntvct_el0,
+ 		.set_next_event_phys = erratum_set_next_event_tval_phys,
+ 		.set_next_event_virt = erratum_set_next_event_tval_virt,
+ 	},
+ #endif
+ #ifdef CONFIG_ARM64_ERRATUM_1418040
+ 	{
+ 		.match_type = ate_match_local_cap_id,
+ 		.id = (void *)ARM64_WORKAROUND_1418040,
+ 		.desc = "ARM erratum 1418040",
+ 		.disable_compat_vdso = true,
+ 	},
+ #endif
++>>>>>>> d72689988d67 (clocksource/drivers/arm_arch_timer: Drop CNT*_TVAL read accessors)
  };
  
  typedef bool (*ate_match_fn_t)(const struct arch_timer_erratum_workaround *,
diff --git a/arch/arm/include/asm/arch_timer.h b/arch/arm/include/asm/arch_timer.h
index 20604903380c..88e58dbbb05e 100644
--- a/arch/arm/include/asm/arch_timer.h
+++ b/arch/arm/include/asm/arch_timer.h
@@ -64,9 +64,6 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 		case ARCH_TIMER_REG_CTRL:
 			asm volatile("mrc p15, 0, %0, c14, c2, 1" : "=r" (val));
 			break;
-		case ARCH_TIMER_REG_TVAL:
-			asm volatile("mrc p15, 0, %0, c14, c2, 0" : "=r" (val));
-			break;
 		default:
 			BUILD_BUG();
 		}
@@ -75,9 +72,6 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 		case ARCH_TIMER_REG_CTRL:
 			asm volatile("mrc p15, 0, %0, c14, c3, 1" : "=r" (val));
 			break;
-		case ARCH_TIMER_REG_TVAL:
-			asm volatile("mrc p15, 0, %0, c14, c3, 0" : "=r" (val));
-			break;
 		default:
 			BUILD_BUG();
 		}
diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index f75d9ac8afd6..63543b8951cf 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -62,8 +62,6 @@ struct arch_timer_erratum_workaround {
 	enum arch_timer_erratum_match_type match_type;
 	const void *id;
 	const char *desc;
-	u32 (*read_cntp_tval_el0)(void);
-	u32 (*read_cntv_tval_el0)(void);
 	u64 (*read_cntpct_el0)(void);
 	u64 (*read_cntvct_el0)(void);
 	int (*set_next_event_phys)(unsigned long, struct clock_event_device *);
@@ -73,17 +71,6 @@ struct arch_timer_erratum_workaround {
 DECLARE_PER_CPU(const struct arch_timer_erratum_workaround *,
 		timer_unstable_counter_workaround);
 
-/* inline sysreg accessors that make erratum_handler() work */
-static inline notrace u32 arch_timer_read_cntp_tval_el0(void)
-{
-	return read_sysreg(cntp_tval_el0);
-}
-
-static inline notrace u32 arch_timer_read_cntv_tval_el0(void)
-{
-	return read_sysreg(cntv_tval_el0);
-}
-
 static inline notrace u64 arch_timer_read_cntpct_el0(void)
 {
 	return read_sysreg(cntpct_el0);
@@ -149,8 +136,6 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 		switch (reg) {
 		case ARCH_TIMER_REG_CTRL:
 			return read_sysreg(cntp_ctl_el0);
-		case ARCH_TIMER_REG_TVAL:
-			return arch_timer_reg_read_stable(cntp_tval_el0);
 		default:
 			BUILD_BUG();
 		}
@@ -158,8 +143,6 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 		switch (reg) {
 		case ARCH_TIMER_REG_CTRL:
 			return read_sysreg(cntv_ctl_el0);
-		case ARCH_TIMER_REG_TVAL:
-			return arch_timer_reg_read_stable(cntv_tval_el0);
 		default:
 			BUILD_BUG();
 		}
* Unmerged path drivers/clocksource/arm_arch_timer.c
