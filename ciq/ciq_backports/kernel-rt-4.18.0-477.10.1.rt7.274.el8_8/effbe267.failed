net/mlx5: Simplify IPsec capabilities logic

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit effbe2675165515e47e45aa26d70c3caedc9f6bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/effbe267.failed

Reduce number of hard-coded IPsec capabilities by making sure
that mlx5_ipsec_device_caps() sets only supported bits.

As part of this change, remove _ACCEL_ notations from the capabilities
names as they represent IPsec-capable device, so it is aligned with
MLX5_CAP_IPSEC() macro. And prepare the code to IPsec full offload mode.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit effbe2675165515e47e45aa26d70c3caedc9f6bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
index 027d80b77b28,be7650d2cfd3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
@@@ -226,8 -215,7 +226,12 @@@ static inline int mlx5e_xfrm_validate_s
  		return -EINVAL;
  	}
  	if (x->props.flags & XFRM_STATE_ESN &&
++<<<<<<< HEAD
 +	    !(mlx5_accel_ipsec_device_caps(priv->mdev) &
 +	    MLX5_ACCEL_IPSEC_CAP_ESN)) {
++=======
+ 	    !(mlx5_ipsec_device_caps(priv->mdev) & MLX5_IPSEC_CAP_ESN)) {
++>>>>>>> effbe2675165 (net/mlx5: Simplify IPsec capabilities logic)
  		netdev_info(netdev, "Cannot offload ESN xfrm states\n");
  		return -EINVAL;
  	}
@@@ -274,12 -262,6 +278,15 @@@
  		netdev_info(netdev, "Cannot offload xfrm states with geniv other than seqiv\n");
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +	if (x->props.family == AF_INET6 &&
 +	    !(mlx5_accel_ipsec_device_caps(priv->mdev) &
 +	     MLX5_ACCEL_IPSEC_CAP_IPV6)) {
 +		netdev_info(netdev, "IPv6 xfrm state offload is not supported by this device\n");
 +		return -EINVAL;
 +	}
++=======
++>>>>>>> effbe2675165 (net/mlx5: Simplify IPsec capabilities logic)
  	return 0;
  }
  
@@@ -508,11 -449,8 +515,16 @@@ void mlx5e_ipsec_build_netdev(struct ml
  	struct mlx5_core_dev *mdev = priv->mdev;
  	struct net_device *netdev = priv->netdev;
  
++<<<<<<< HEAD
 +	if (!(mlx5_accel_ipsec_device_caps(mdev) & MLX5_ACCEL_IPSEC_CAP_ESP) ||
 +	    !MLX5_CAP_ETH(mdev, swp)) {
 +		mlx5_core_dbg(mdev, "mlx5e: ESP and SWP offload not supported\n");
 +		return;
 +	}
++=======
+ 	if (!mlx5_ipsec_device_caps(mdev))
+ 		return;
++>>>>>>> effbe2675165 (net/mlx5: Simplify IPsec capabilities logic)
  
  	mlx5_core_info(mdev, "mlx5e: IPSec ESP acceleration enabled\n");
  	netdev->xfrmdev_ops = &mlx5e_ipsec_xfrmdev_ops;
@@@ -527,8 -465,7 +539,12 @@@
  	netdev->features |= NETIF_F_HW_ESP_TX_CSUM;
  	netdev->hw_enc_features |= NETIF_F_HW_ESP_TX_CSUM;
  
++<<<<<<< HEAD
 +	if (!(mlx5_accel_ipsec_device_caps(mdev) & MLX5_ACCEL_IPSEC_CAP_LSO) ||
 +	    !MLX5_CAP_ETH(mdev, swp_lso)) {
++=======
+ 	if (!MLX5_CAP_ETH(mdev, swp_lso)) {
++>>>>>>> effbe2675165 (net/mlx5: Simplify IPsec capabilities logic)
  		mlx5_core_dbg(mdev, "mlx5e: ESP LSO not supported\n");
  		return;
  	}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
index 45f71910d196,97c55620089d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
@@@ -45,6 -43,70 +45,73 @@@
  #define MLX5E_IPSEC_SADB_RX_BITS 10
  #define MLX5E_IPSEC_ESN_SCOPE_MID 0x80000000L
  
++<<<<<<< HEAD
++=======
+ enum mlx5_accel_esp_flags {
+ 	MLX5_ACCEL_ESP_FLAGS_TUNNEL            = 0,    /* Default */
+ 	MLX5_ACCEL_ESP_FLAGS_TRANSPORT         = 1UL << 0,
+ 	MLX5_ACCEL_ESP_FLAGS_ESN_TRIGGERED     = 1UL << 1,
+ 	MLX5_ACCEL_ESP_FLAGS_ESN_STATE_OVERLAP = 1UL << 2,
+ };
+ 
+ enum mlx5_accel_esp_action {
+ 	MLX5_ACCEL_ESP_ACTION_DECRYPT,
+ 	MLX5_ACCEL_ESP_ACTION_ENCRYPT,
+ };
+ 
+ enum mlx5_accel_esp_keymats {
+ 	MLX5_ACCEL_ESP_KEYMAT_AES_NONE,
+ 	MLX5_ACCEL_ESP_KEYMAT_AES_GCM,
+ };
+ 
+ struct aes_gcm_keymat {
+ 	u64   seq_iv;
+ 
+ 	u32   salt;
+ 	u32   icv_len;
+ 
+ 	u32   key_len;
+ 	u32   aes_key[256 / 32];
+ };
+ 
+ struct mlx5_accel_esp_xfrm_attrs {
+ 	enum mlx5_accel_esp_action action;
+ 	u32   esn;
+ 	__be32 spi;
+ 	u32   seq;
+ 	u32   tfc_pad;
+ 	u32   flags;
+ 	u32   sa_handle;
+ 	union {
+ 		struct {
+ 			u32 size;
+ 
+ 		} bmp;
+ 	} replay;
+ 	enum mlx5_accel_esp_keymats keymat_type;
+ 	union {
+ 		struct aes_gcm_keymat aes_gcm;
+ 	} keymat;
+ 
+ 	union {
+ 		__be32 a4;
+ 		__be32 a6[4];
+ 	} saddr;
+ 
+ 	union {
+ 		__be32 a4;
+ 		__be32 a6[4];
+ 	} daddr;
+ 
+ 	u8 is_ipv6;
+ };
+ 
+ enum mlx5_ipsec_cap {
+ 	MLX5_IPSEC_CAP_CRYPTO		= 1 << 0,
+ 	MLX5_IPSEC_CAP_ESN		= 1 << 1,
+ };
+ 
++>>>>>>> effbe2675165 (net/mlx5: Simplify IPsec capabilities logic)
  struct mlx5e_priv;
  
  struct mlx5e_ipsec_sw_stats {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
