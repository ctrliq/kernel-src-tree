gfs2: Make go_instantiate take a glock

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 5f38a4d3c44b01495dcb4952b53d90170a30c51a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/5f38a4d3.failed

Make go_instantiate take a glock instead of a glock holder as its argument:
this handler is supposed to instantiate the object associated with the glock.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 5f38a4d3c44b01495dcb4952b53d90170a30c51a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glops.c
diff --cc fs/gfs2/glops.c
index 3b666370e53d,49210a2e7ce7..000000000000
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@@ -480,10 -485,8 +480,13 @@@ int gfs2_inode_refresh(struct gfs2_inod
   * Returns: errno
   */
  
- static int inode_go_instantiate(struct gfs2_holder *gh)
+ static int inode_go_instantiate(struct gfs2_glock *gl)
  {
++<<<<<<< HEAD
 +	struct gfs2_glock *gl = gh->gh_gl;
 +	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
++=======
++>>>>>>> 5f38a4d3c44b (gfs2: Make go_instantiate take a glock)
  	struct gfs2_inode *ip = gl->gl_object;
  
  	if (!ip) /* no inode to populate - read it in later */
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index e89e3f985401..94a62e6854a8 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -509,7 +509,7 @@ int gfs2_instantiate(struct gfs2_holder *gh)
 		goto again;
 	}
 
-	ret = glops->go_instantiate(gh);
+	ret = glops->go_instantiate(gl);
 	if (!ret)
 		clear_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags);
 	clear_and_wake_up_bit(GLF_INSTANTIATE_IN_PROG, &gl->gl_flags);
* Unmerged path fs/gfs2/glops.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9b819ad2be13..e2c91e6c67e3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -222,7 +222,7 @@ struct gfs2_glock_operations {
 	int (*go_xmote_bh)(struct gfs2_glock *gl);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (const struct gfs2_glock *gl);
-	int (*go_instantiate) (struct gfs2_holder *gh);
+	int (*go_instantiate) (struct gfs2_glock *gl);
 	int (*go_held)(struct gfs2_holder *gh);
 	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl,
 			const char *fs_id_buf);
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 57bf943fbb39..3439fa71af26 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -1199,9 +1199,8 @@ static void rgrp_set_bitmap_flags(struct gfs2_rgrpd *rgd)
  * Returns: errno
  */
 
-int gfs2_rgrp_go_instantiate(struct gfs2_holder *gh)
+int gfs2_rgrp_go_instantiate(struct gfs2_glock *gl)
 {
-	struct gfs2_glock *gl = gh->gh_gl;
 	struct gfs2_rgrpd *rgd = gl->gl_object;
 	struct gfs2_sbd *sdp = rgd->rd_sbd;
 	unsigned int length = rgd->rd_length;
diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5142df945656..bee9102cff0c 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -34,7 +34,7 @@ extern struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 extern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
 extern int gfs2_rindex_update(struct gfs2_sbd *sdp);
 extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
-extern int gfs2_rgrp_go_instantiate(struct gfs2_holder *gh);
+extern int gfs2_rgrp_go_instantiate(struct gfs2_glock *gl);
 extern void gfs2_rgrp_brelse(struct gfs2_rgrpd *rgd);
 
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
