x86/idt: Rework IDT setup for boot CPU

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1dcc917a0eed934c522d93bb05a9a7bb3c54f96c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/1dcc917a.failed

A basic IDT setup for the boot CPU has to be done before invoking
cpu_init() because that might trigger #GP when accessing certain MSRs. This
setup cannot install the IST variants on 64-bit because the TSS setup which
is required for ISTs to work happens in cpu_init(). That leaves a
theoretical window where a NMI would invoke the ASM entry point which
relies on IST being enabled on the kernel stack which is undefined
behaviour.

This setup logic has never worked correctly, but on the other hand a NMI
hitting the boot CPU before it has fully set up the IDT would be fatal
anyway. So the small window between the wrong NMI gate and the IST based
NMI gate is not really adding a substantial amount of risk.

But the setup logic is nevertheless more convoluted than necessary. The
recent separation of the TSS setup into a separate function to ensure that
setup so it can setup TSS first, then initialize IDT with the IST variants
before invoking cpu_init() and get rid of the post cpu_init() IST setup.

Move the invocation of cpu_init_exception_handling() ahead of
idt_setup_traps() and merge the IST setup into the default setup table.

	Reported-by: Lai Jiangshan <laijs@linux.alibaba.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Lai Jiangshan <laijs@linux.alibaba.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lore.kernel.org/r/20210507114000.569244755@linutronix.de

(cherry picked from commit 1dcc917a0eed934c522d93bb05a9a7bb3c54f96c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/desc.h
#	arch/x86/kernel/idt.c
#	arch/x86/kernel/traps.c
diff --cc arch/x86/include/asm/desc.h
index c288003f863f,96021e9bd202..000000000000
--- a/arch/x86/include/asm/desc.h
+++ b/arch/x86/include/asm/desc.h
@@@ -465,12 -420,9 +465,17 @@@ extern void idt_setup_apic_and_irq_gate
  
  #ifdef CONFIG_X86_64
  extern void idt_setup_early_pf(void);
++<<<<<<< HEAD
 +extern void idt_setup_ist_traps(void);
 +extern void idt_setup_debugidt_traps(void);
 +#else
 +static inline void idt_setup_early_pf(void) { }
 +static inline void idt_setup_ist_traps(void) { }
 +static inline void idt_setup_debugidt_traps(void) { }
++=======
+ #else
+ static inline void idt_setup_early_pf(void) { }
++>>>>>>> 1dcc917a0eed (x86/idt: Rework IDT setup for boot CPU)
  #endif
  
  extern void idt_invalidate(void *addr);
diff --cc arch/x86/kernel/idt.c
index e0713a63e3bd,6cce6047fa12..000000000000
--- a/arch/x86/kernel/idt.c
+++ b/arch/x86/kernel/idt.c
@@@ -68,33 -77,37 +72,63 @@@ static const __initconst struct idt_dat
   * set up TSS.
   */
  static const __initconst struct idt_data def_idts[] = {
++<<<<<<< HEAD
 +	INTG(X86_TRAP_DE,		divide_error),
 +	INTG(X86_TRAP_NMI,		nmi),
 +	INTG(X86_TRAP_BR,		bounds),
 +	INTG(X86_TRAP_UD,		invalid_op),
 +	INTG(X86_TRAP_NM,		device_not_available),
 +	INTG(X86_TRAP_OLD_MF,		coprocessor_segment_overrun),
 +	INTG(X86_TRAP_TS,		invalid_TSS),
 +	INTG(X86_TRAP_NP,		segment_not_present),
 +	INTG(X86_TRAP_SS,		stack_segment),
 +	INTG(X86_TRAP_GP,		general_protection),
 +	INTG(X86_TRAP_SPURIOUS,		spurious_interrupt_bug),
 +	INTG(X86_TRAP_MF,		coprocessor_error),
 +	INTG(X86_TRAP_AC,		alignment_check),
 +	INTG(X86_TRAP_XF,		simd_coprocessor_error),
++=======
+ 	INTG(X86_TRAP_DE,		asm_exc_divide_error),
+ 	ISTG(X86_TRAP_NMI,		asm_exc_nmi, IST_INDEX_NMI),
+ 	INTG(X86_TRAP_BR,		asm_exc_bounds),
+ 	INTG(X86_TRAP_UD,		asm_exc_invalid_op),
+ 	INTG(X86_TRAP_NM,		asm_exc_device_not_available),
+ 	INTG(X86_TRAP_OLD_MF,		asm_exc_coproc_segment_overrun),
+ 	INTG(X86_TRAP_TS,		asm_exc_invalid_tss),
+ 	INTG(X86_TRAP_NP,		asm_exc_segment_not_present),
+ 	INTG(X86_TRAP_SS,		asm_exc_stack_segment),
+ 	INTG(X86_TRAP_GP,		asm_exc_general_protection),
+ 	INTG(X86_TRAP_SPURIOUS,		asm_exc_spurious_interrupt_bug),
+ 	INTG(X86_TRAP_MF,		asm_exc_coprocessor_error),
+ 	INTG(X86_TRAP_AC,		asm_exc_alignment_check),
+ 	INTG(X86_TRAP_XF,		asm_exc_simd_coprocessor_error),
++>>>>>>> 1dcc917a0eed (x86/idt: Rework IDT setup for boot CPU)
  
  #ifdef CONFIG_X86_32
  	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
  #else
++<<<<<<< HEAD
 +	INTG(X86_TRAP_DF,		double_fault),
 +#endif
 +	INTG(X86_TRAP_DB,		debug),
 +
 +#ifdef CONFIG_X86_MCE
 +	INTG(X86_TRAP_MC,		&machine_check),
++=======
+ 	ISTG(X86_TRAP_DF,		asm_exc_double_fault, IST_INDEX_DF),
+ #endif
+ 	ISTG(X86_TRAP_DB,		asm_exc_debug, IST_INDEX_DB),
+ 
+ #ifdef CONFIG_X86_MCE
+ 	ISTG(X86_TRAP_MC,		asm_exc_machine_check, IST_INDEX_MCE),
+ #endif
+ 
+ #ifdef CONFIG_AMD_MEM_ENCRYPT
+ 	ISTG(X86_TRAP_VC,		asm_exc_vmm_communication, IST_INDEX_VC),
++>>>>>>> 1dcc917a0eed (x86/idt: Rework IDT setup for boot CPU)
  #endif
  
 -	SYSG(X86_TRAP_OF,		asm_exc_overflow),
 +	SYSG(X86_TRAP_OF,		overflow),
  #if defined(CONFIG_IA32_EMULATION)
  	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
  #elif defined(CONFIG_X86_32)
@@@ -243,6 -221,14 +277,17 @@@ void __init idt_setup_traps(void
  }
  
  #ifdef CONFIG_X86_64
++<<<<<<< HEAD
++=======
+ /*
+  * Early traps running on the DEFAULT_STACK because the other interrupt
+  * stacks work only after cpu_init().
+  */
+ static const __initconst struct idt_data early_pf_idts[] = {
+ 	INTG(X86_TRAP_PF,		asm_exc_page_fault),
+ };
+ 
++>>>>>>> 1dcc917a0eed (x86/idt: Rework IDT setup for boot CPU)
  /**
   * idt_setup_early_pf - Initialize the idt table with early pagefault handler
   *
@@@ -258,24 -246,6 +303,27 @@@ void __init idt_setup_early_pf(void
  	idt_setup_from_table(idt_table, early_pf_idts,
  			     ARRAY_SIZE(early_pf_idts), true);
  }
++<<<<<<< HEAD
 +
 +/**
 + * idt_setup_ist_traps - Initialize the idt table with traps using IST
 + */
 +void __init idt_setup_ist_traps(void)
 +{
 +	idt_setup_from_table(idt_table, ist_idts, ARRAY_SIZE(ist_idts), true);
 +}
 +
 +/**
 + * idt_setup_debugidt_traps - Initialize the debug idt table with debug traps
 + */
 +void __init idt_setup_debugidt_traps(void)
 +{
 +	memcpy(&debug_idt_table, &idt_table, IDT_ENTRIES * 16);
 +
 +	idt_setup_from_table(debug_idt_table, dbg_idts, ARRAY_SIZE(dbg_idts), false);
 +}
++=======
++>>>>>>> 1dcc917a0eed (x86/idt: Rework IDT setup for boot CPU)
  #endif
  
  static void __init idt_map_in_cea(void)
diff --cc arch/x86/kernel/traps.c
index bfb6deda083d,ed540e09a399..000000000000
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@@ -1053,14 -1160,9 +1053,22 @@@ void __init trap_init(void
  	/* Init GHCB memory pages when running as an SEV-ES guest */
  	sev_es_init_vc_handling();
  
++<<<<<<< HEAD
 +	idt_setup_traps();
 +
 +	/*
 +	 * Should be a barrier for any external CPU state:
 +	 */
 +	cpu_init();
 +
 +	idt_setup_ist_traps();
 +
 +	idt_setup_debugidt_traps();
++=======
+ 	/* Initialize TSS before setting up traps so ISTs work */
+ 	cpu_init_exception_handling();
+ 	/* Setup traps as cpu_init() might #GP */
+ 	idt_setup_traps();
+ 	cpu_init();
++>>>>>>> 1dcc917a0eed (x86/idt: Rework IDT setup for boot CPU)
  }
* Unmerged path arch/x86/include/asm/desc.h
* Unmerged path arch/x86/kernel/idt.c
* Unmerged path arch/x86/kernel/traps.c
