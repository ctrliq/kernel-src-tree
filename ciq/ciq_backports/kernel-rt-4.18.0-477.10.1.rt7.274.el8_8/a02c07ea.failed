net/mlx5e: Split en_fs ndo's and move to en_main

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Lama Kayal <lkayal@nvidia.com>
commit a02c07ea5d0b38815282a787a9621007f86965d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/a02c07ea.failed

Add inner callee for ndo mlx5e_vlan_rx_add_vid and
mlx5e_vlan_rx_kill_vid, to separate the priv usage from other
flow steering flows.

Move wrapper ndo's into en_main, and split the rest of the functionality
into a separate part inside en_fs.

	Signed-off-by: Lama Kayal <lkayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a02c07ea5d0b38815282a787a9621007f86965d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 234e5292cdc3,83f67e536ca0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -185,6 -190,12 +185,16 @@@ int mlx5e_add_vlan_trap(struct mlx5e_pr
  void mlx5e_remove_vlan_trap(struct mlx5e_priv *priv);
  int mlx5e_add_mac_trap(struct mlx5e_priv *priv, int  trap_id, int tir_num);
  void mlx5e_remove_mac_trap(struct mlx5e_priv *priv);
- 
++<<<<<<< HEAD
++
++=======
+ void mlx5e_fs_set_rx_mode_work(struct mlx5e_flow_steering *fs, struct net_device *netdev);
+ int mlx5e_fs_vlan_rx_add_vid(struct mlx5e_flow_steering *fs,
+ 			     struct net_device *netdev,
+ 			     __be16 proto, u16 vid);
+ int mlx5e_fs_vlan_rx_kill_vid(struct mlx5e_flow_steering *fs,
+ 			      struct net_device *netdev,
+ 			      __be16 proto, u16 vid);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  #endif /* __MLX5E_FLOW_STEER_H__ */
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 3f8245301b0a,121407f57564..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -133,9 -132,8 +132,9 @@@ struct mlx5_flow_table *mlx5e_vlan_get_
  	return vlan->ft.t;
  }
  
- static int mlx5e_vport_context_update_vlans(struct mlx5e_priv *priv)
+ static int mlx5e_vport_context_update_vlans(struct mlx5e_flow_steering *fs)
  {
 +	struct net_device *ndev = priv->netdev;
  	int max_list_size;
  	int list_size;
  	u16 *vlans;
@@@ -144,15 -142,15 +143,27 @@@
  	int i;
  
  	list_size = 0;
++<<<<<<< HEAD
 +	for_each_set_bit(vlan, priv->fs.vlan->active_cvlans, VLAN_N_VID)
 +		list_size++;
 +
 +	max_list_size = 1 << MLX5_CAP_GEN(priv->mdev, log_max_vlan_list);
 +
 +	if (list_size > max_list_size) {
 +		netdev_warn(ndev,
 +			    "netdev vlans list size (%d) > (%d) max vport list size, some vlans will be dropped\n",
 +			    list_size, max_list_size);
++=======
+ 	for_each_set_bit(vlan, fs->vlan->active_cvlans, VLAN_N_VID)
+ 		list_size++;
+ 
+ 	max_list_size = 1 << MLX5_CAP_GEN(fs->mdev, log_max_vlan_list);
+ 
+ 	if (list_size > max_list_size) {
+ 		mlx5_core_warn(fs->mdev,
+ 			       "netdev vlans list size (%d) > (%d) max vport list size, some vlans will be dropped\n",
+ 			       list_size, max_list_size);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		list_size = max_list_size;
  	}
  
@@@ -161,16 -159,16 +172,27 @@@
  		return -ENOMEM;
  
  	i = 0;
++<<<<<<< HEAD
 +	for_each_set_bit(vlan, priv->fs.vlan->active_cvlans, VLAN_N_VID) {
++=======
+ 	for_each_set_bit(vlan, fs->vlan->active_cvlans, VLAN_N_VID) {
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		if (i >= list_size)
  			break;
  		vlans[i++] = vlan;
  	}
  
++<<<<<<< HEAD
 +	err = mlx5_modify_nic_vport_vlans(priv->mdev, vlans, list_size);
 +	if (err)
 +		netdev_err(ndev, "Failed to modify vport vlans list err(%d)\n",
 +			   err);
++=======
+ 	err = mlx5_modify_nic_vport_vlans(fs->mdev, vlans, list_size);
+ 	if (err)
+ 		mlx5_core_err(fs->mdev, "Failed to modify vport vlans list err(%d)\n",
+ 			      err);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  
  	kvfree(vlans);
  	return err;
@@@ -188,14 -186,14 +210,22 @@@ static int __mlx5e_add_vlan_rule(struc
  				 enum mlx5e_vlan_rule_type rule_type,
  				 u16 vid, struct mlx5_flow_spec *spec)
  {
++<<<<<<< HEAD
 +	struct mlx5_flow_table *ft = priv->fs.vlan->ft.t;
++=======
+ 	struct mlx5_flow_table *ft = fs->vlan->ft.t;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  	struct mlx5_flow_destination dest = {};
  	struct mlx5_flow_handle **rule_p;
  	MLX5_DECLARE_FLOW_ACT(flow_act);
  	int err = 0;
  
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
++<<<<<<< HEAD
 +	dest.ft = priv->fs.l2.ft.t;
++=======
+ 	dest.ft = fs->l2.ft.t;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  
  	spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
  
@@@ -205,24 -203,24 +235,40 @@@
  		 * disabled in match value means both S & C tags
  		 * don't exist (untagged of both)
  		 */
++<<<<<<< HEAD
 +		rule_p = &priv->fs.vlan->untagged_rule;
++=======
+ 		rule_p = &fs->vlan->untagged_rule;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,
  				 outer_headers.cvlan_tag);
  		break;
  	case MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID:
++<<<<<<< HEAD
 +		rule_p = &priv->fs.vlan->any_cvlan_rule;
++=======
+ 		rule_p = &fs->vlan->any_cvlan_rule;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,
  				 outer_headers.cvlan_tag);
  		MLX5_SET(fte_match_param, spec->match_value, outer_headers.cvlan_tag, 1);
  		break;
  	case MLX5E_VLAN_RULE_TYPE_ANY_STAG_VID:
++<<<<<<< HEAD
 +		rule_p = &priv->fs.vlan->any_svlan_rule;
++=======
+ 		rule_p = &fs->vlan->any_svlan_rule;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,
  				 outer_headers.svlan_tag);
  		MLX5_SET(fte_match_param, spec->match_value, outer_headers.svlan_tag, 1);
  		break;
  	case MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID:
++<<<<<<< HEAD
 +		rule_p = &priv->fs.vlan->active_svlans_rule[vid];
++=======
+ 		rule_p = &fs->vlan->active_svlans_rule[vid];
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,
  				 outer_headers.svlan_tag);
  		MLX5_SET(fte_match_param, spec->match_value, outer_headers.svlan_tag, 1);
@@@ -232,7 -230,7 +278,11 @@@
  			 vid);
  		break;
  	default: /* MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID */
++<<<<<<< HEAD
 +		rule_p = &priv->fs.vlan->active_cvlans_rule[vid];
++=======
+ 		rule_p = &fs->vlan->active_cvlans_rule[vid];
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,
  				 outer_headers.cvlan_tag);
  		MLX5_SET(fte_match_param, spec->match_value, outer_headers.cvlan_tag, 1);
@@@ -251,7 -249,7 +301,11 @@@
  	if (IS_ERR(*rule_p)) {
  		err = PTR_ERR(*rule_p);
  		*rule_p = NULL;
++<<<<<<< HEAD
 +		netdev_err(priv->netdev, "%s: add rule failed\n", __func__);
++=======
+ 		mlx5_core_err(fs->mdev, "%s: add rule failed\n", __func__);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  	}
  
  	return err;
@@@ -282,35 -280,35 +336,65 @@@ static void mlx5e_fs_del_vlan_rule(stru
  {
  	switch (rule_type) {
  	case MLX5E_VLAN_RULE_TYPE_UNTAGGED:
++<<<<<<< HEAD
 +		if (priv->fs.vlan->untagged_rule) {
 +			mlx5_del_flow_rules(priv->fs.vlan->untagged_rule);
 +			priv->fs.vlan->untagged_rule = NULL;
 +		}
 +		break;
 +	case MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID:
 +		if (priv->fs.vlan->any_cvlan_rule) {
 +			mlx5_del_flow_rules(priv->fs.vlan->any_cvlan_rule);
 +			priv->fs.vlan->any_cvlan_rule = NULL;
 +		}
 +		break;
 +	case MLX5E_VLAN_RULE_TYPE_ANY_STAG_VID:
 +		if (priv->fs.vlan->any_svlan_rule) {
 +			mlx5_del_flow_rules(priv->fs.vlan->any_svlan_rule);
 +			priv->fs.vlan->any_svlan_rule = NULL;
 +		}
 +		break;
 +	case MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID:
 +		if (priv->fs.vlan->active_svlans_rule[vid]) {
 +			mlx5_del_flow_rules(priv->fs.vlan->active_svlans_rule[vid]);
 +			priv->fs.vlan->active_svlans_rule[vid] = NULL;
 +		}
 +		break;
 +	case MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID:
 +		if (priv->fs.vlan->active_cvlans_rule[vid]) {
 +			mlx5_del_flow_rules(priv->fs.vlan->active_cvlans_rule[vid]);
 +			priv->fs.vlan->active_cvlans_rule[vid] = NULL;
++=======
+ 		if (fs->vlan->untagged_rule) {
+ 			mlx5_del_flow_rules(fs->vlan->untagged_rule);
+ 			fs->vlan->untagged_rule = NULL;
+ 		}
+ 		break;
+ 	case MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID:
+ 		if (fs->vlan->any_cvlan_rule) {
+ 			mlx5_del_flow_rules(fs->vlan->any_cvlan_rule);
+ 			fs->vlan->any_cvlan_rule = NULL;
+ 		}
+ 		break;
+ 	case MLX5E_VLAN_RULE_TYPE_ANY_STAG_VID:
+ 		if (fs->vlan->any_svlan_rule) {
+ 			mlx5_del_flow_rules(fs->vlan->any_svlan_rule);
+ 			fs->vlan->any_svlan_rule = NULL;
+ 		}
+ 		break;
+ 	case MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID:
+ 		if (fs->vlan->active_svlans_rule[vid]) {
+ 			mlx5_del_flow_rules(fs->vlan->active_svlans_rule[vid]);
+ 			fs->vlan->active_svlans_rule[vid] = NULL;
  		}
- 		mlx5e_vport_context_update_vlans(priv);
+ 		break;
+ 	case MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID:
+ 		if (fs->vlan->active_cvlans_rule[vid]) {
+ 			mlx5_del_flow_rules(fs->vlan->active_cvlans_rule[vid]);
+ 			fs->vlan->active_cvlans_rule[vid] = NULL;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
+ 		}
+ 		mlx5e_vport_context_update_vlans(fs);
  		break;
  	}
  }
@@@ -407,49 -405,49 +491,65 @@@ void mlx5e_remove_mac_trap(struct mlx5e
  
  void mlx5e_enable_cvlan_filter(struct mlx5e_priv *priv)
  {
 -	if (!priv->fs->vlan->cvlan_filter_disabled)
 +	if (!priv->fs.vlan->cvlan_filter_disabled)
  		return;
  
 -	priv->fs->vlan->cvlan_filter_disabled = false;
 +	priv->fs.vlan->cvlan_filter_disabled = false;
  	if (priv->netdev->flags & IFF_PROMISC)
  		return;
- 	mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID, 0);
+ 	mlx5e_fs_del_vlan_rule(priv->fs, MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID, 0);
  }
  
  void mlx5e_disable_cvlan_filter(struct mlx5e_priv *priv)
  {
 -	if (priv->fs->vlan->cvlan_filter_disabled)
 +	if (priv->fs.vlan->cvlan_filter_disabled)
  		return;
  
 -	priv->fs->vlan->cvlan_filter_disabled = true;
 +	priv->fs.vlan->cvlan_filter_disabled = true;
  	if (priv->netdev->flags & IFF_PROMISC)
  		return;
- 	mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID, 0);
+ 	mlx5e_add_vlan_rule(priv->fs, MLX5E_VLAN_RULE_TYPE_ANY_CTAG_VID, 0);
  }
  
- static int mlx5e_vlan_rx_add_cvid(struct mlx5e_priv *priv, u16 vid)
+ static int mlx5e_vlan_rx_add_cvid(struct mlx5e_flow_steering *fs, u16 vid)
  {
  	int err;
  
++<<<<<<< HEAD
 +	set_bit(vid, priv->fs.vlan->active_cvlans);
++=======
+ 	set_bit(vid, fs->vlan->active_cvlans);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  
- 	err = mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, vid);
+ 	err = mlx5e_add_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, vid);
  	if (err)
++<<<<<<< HEAD
 +		clear_bit(vid, priv->fs.vlan->active_cvlans);
++=======
+ 		clear_bit(vid, fs->vlan->active_cvlans);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  
  	return err;
  }
  
- static int mlx5e_vlan_rx_add_svid(struct mlx5e_priv *priv, u16 vid)
+ static int mlx5e_vlan_rx_add_svid(struct mlx5e_flow_steering *fs,
+ 				  struct net_device *netdev, u16 vid)
  {
- 	struct net_device *netdev = priv->netdev;
  	int err;
  
++<<<<<<< HEAD
 +	set_bit(vid, priv->fs.vlan->active_svlans);
++=======
+ 	set_bit(vid, fs->vlan->active_svlans);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  
- 	err = mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, vid);
+ 	err = mlx5e_add_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, vid);
  	if (err) {
++<<<<<<< HEAD
 +		clear_bit(vid, priv->fs.vlan->active_svlans);
++=======
+ 		clear_bit(vid, fs->vlan->active_svlans);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  		return err;
  	}
  
@@@ -473,20 -474,22 +576,31 @@@ int mlx5e_fs_vlan_rx_add_vid(struct mlx
  	return -EOPNOTSUPP;
  }
  
- int mlx5e_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)
+ int mlx5e_fs_vlan_rx_kill_vid(struct mlx5e_flow_steering *fs,
+ 			      struct net_device *netdev,
+ 			      __be16 proto, u16 vid)
  {
- 	struct mlx5e_priv *priv = netdev_priv(dev);
- 
- 	if (mlx5e_is_uplink_rep(priv))
- 		return 0; /* no vlan table for uplink rep */
+ 	if (!fs->vlan) {
+ 		mlx5_core_err(fs->mdev, "Vlan doesn't exist\n");
+ 		return -EINVAL;
+ 	}
  
  	if (be16_to_cpu(proto) == ETH_P_8021Q) {
++<<<<<<< HEAD
 +		clear_bit(vid, priv->fs.vlan->active_cvlans);
 +		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, vid);
 +	} else if (be16_to_cpu(proto) == ETH_P_8021AD) {
 +		clear_bit(vid, priv->fs.vlan->active_svlans);
 +		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, vid);
 +		netdev_update_features(dev);
++=======
+ 		clear_bit(vid, fs->vlan->active_cvlans);
+ 		mlx5e_fs_del_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, vid);
+ 	} else if (be16_to_cpu(proto) == ETH_P_8021AD) {
+ 		clear_bit(vid, fs->vlan->active_svlans);
+ 		mlx5e_fs_del_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, vid);
+ 		netdev_update_features(netdev);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  	}
  
  	return 0;
@@@ -496,41 -499,41 +610,67 @@@ static void mlx5e_fs_add_vlan_rules(str
  {
  	int i;
  
- 	mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
+ 	mlx5e_add_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
  
++<<<<<<< HEAD
 +	for_each_set_bit(i, priv->fs.vlan->active_cvlans, VLAN_N_VID) {
 +		mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, i);
 +	}
 +
 +	for_each_set_bit(i, priv->fs.vlan->active_svlans, VLAN_N_VID)
 +		mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, i);
 +
 +	if (priv->fs.vlan->cvlan_filter_disabled)
 +		mlx5e_add_any_vid_rules(priv);
++=======
+ 	for_each_set_bit(i, fs->vlan->active_cvlans, VLAN_N_VID) {
+ 		mlx5e_add_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, i);
+ 	}
+ 
+ 	for_each_set_bit(i, fs->vlan->active_svlans, VLAN_N_VID)
+ 		mlx5e_add_vlan_rule(fs, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, i);
+ 
+ 	if (fs->vlan->cvlan_filter_disabled)
+ 		mlx5e_fs_add_any_vid_rules(fs);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  }
  
  static void mlx5e_del_vlan_rules(struct mlx5e_priv *priv)
  {
  	int i;
  
- 	mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
+ 	mlx5e_fs_del_vlan_rule(priv->fs, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
  
++<<<<<<< HEAD
 +	for_each_set_bit(i, priv->fs.vlan->active_cvlans, VLAN_N_VID) {
 +		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, i);
 +	}
 +
 +	for_each_set_bit(i, priv->fs.vlan->active_svlans, VLAN_N_VID)
 +		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, i);
++=======
+ 	for_each_set_bit(i, priv->fs->vlan->active_cvlans, VLAN_N_VID) {
+ 		mlx5e_fs_del_vlan_rule(priv->fs, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, i);
+ 	}
+ 
+ 	for_each_set_bit(i, priv->fs->vlan->active_svlans, VLAN_N_VID)
+ 		mlx5e_fs_del_vlan_rule(priv->fs, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, i);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  
 -	WARN_ON_ONCE(priv->fs->state_destroy);
 +	WARN_ON_ONCE(!(test_bit(MLX5E_STATE_DESTROYING, &priv->state)));
  
  	mlx5e_remove_vlan_trap(priv);
  
  	/* must be called after DESTROY bit is set and
  	 * set_rx_mode is called and flushed
  	 */
++<<<<<<< HEAD
 +	if (priv->fs.vlan->cvlan_filter_disabled)
 +		mlx5e_del_any_vid_rules(priv);
++=======
+ 	if (priv->fs->vlan->cvlan_filter_disabled)
+ 		mlx5e_fs_del_any_vid_rules(priv->fs);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  }
  
  #define mlx5e_for_each_hash_node(hn, tmp, hash, i) \
@@@ -1187,14 -1188,14 +1327,22 @@@ static int mlx5e_fs_create_vlan_table(s
  	struct mlx5e_flow_table *ft;
  	int err;
  
++<<<<<<< HEAD
 +	ft = &priv->fs.vlan->ft;
++=======
+ 	ft = &fs->vlan->ft;
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  	ft->num_groups = 0;
  
  	ft_attr.max_fte = MLX5E_VLAN_TABLE_SIZE;
  	ft_attr.level = MLX5E_VLAN_FT_LEVEL;
  	ft_attr.prio = MLX5E_NIC_PRIO;
  
++<<<<<<< HEAD
 +	ft->t = mlx5_create_flow_table(priv->fs.ns, &ft_attr);
++=======
+ 	ft->t = mlx5_create_flow_table(fs->ns, &ft_attr);
++>>>>>>> a02c07ea5d0b (net/mlx5e: Split en_fs ndo's and move to en_main)
  	if (IS_ERR(ft->t))
  		return PTR_ERR(ft->t);
  
@@@ -1303,10 -1303,10 +1451,10 @@@ int mlx5e_create_flow_steering(struct m
  		goto err_destroy_ttc_table;
  	}
  
- 	err = mlx5e_create_vlan_table(priv);
+ 	err = mlx5e_fs_create_vlan_table(priv->fs);
  	if (err) {
 -		mlx5_core_err(priv->fs->mdev, "Failed to create vlan table, err=%d\n",
 -			      err);
 +		netdev_err(priv->netdev, "Failed to create vlan table, err=%d\n",
 +			   err);
  		goto err_destroy_l2_table;
  	}
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 945751d7ac68..a0c81c2df15b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -3738,6 +3738,28 @@ static int set_feature_rx_vlan(struct net_device *netdev, bool enable)
 	return err;
 }
 
+int mlx5e_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)
+{
+	struct mlx5e_priv *priv = netdev_priv(dev);
+	struct mlx5e_flow_steering *fs = priv->fs;
+
+	if (mlx5e_is_uplink_rep(priv))
+		return 0; /* no vlan table for uplink rep */
+
+	return mlx5e_fs_vlan_rx_add_vid(fs, dev, proto, vid);
+}
+
+int mlx5e_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)
+{
+	struct mlx5e_priv *priv = netdev_priv(dev);
+	struct mlx5e_flow_steering *fs = priv->fs;
+
+	if (mlx5e_is_uplink_rep(priv))
+		return 0; /* no vlan table for uplink rep */
+
+	return mlx5e_fs_vlan_rx_kill_vid(fs, dev, proto, vid);
+}
+
 #ifdef CONFIG_MLX5_EN_ARFS
 static int set_feature_arfs(struct net_device *netdev, bool enable)
 {
