net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Lama Kayal <lkayal@nvidia.com>
commit 5b031add2f94b3c34b0ab2057cdc061132bd3eb9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/5b031add.failed

Separate mlx5e_set_rx_mode into two, and move caller to en_main while
keeping implementation in en_fs in the newly declared function
mlx5e_fs_set_rx_mode. This; to minimize the coupling of flow_steering
to priv.

Add a parallel boolean member vlan_strip_disable to
mlx5e_flow_steering that's updated similarly as its identical in priv,
thus making it possible to adjust the rx_mode work handler to current
changes.

Also, add state_destroy boolean to mlx5e_flow_steering struct which
replaces the old check : !test_bit(MLX5E_STATE_DESTROYING, &priv->state).
This state member is updated accordingly prior to
INIT_WORK(mlx5e_set_rx_mode_work), This is done for similar purposes as
mentioned earlier and to minimize argument passings.

	Signed-off-by: Lama Kayal <lkayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 5b031add2f94b3c34b0ab2057cdc061132bd3eb9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 234e5292cdc3,681a17df5da3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -142,8 -143,10 +142,14 @@@ struct mlx5e_fs_any
  struct mlx5e_ptp_fs;
  
  struct mlx5e_flow_steering {
++<<<<<<< HEAD
++=======
+ 	bool				state_destroy;
+ 	bool				vlan_strip_disable;
+ 	struct mlx5_core_dev		*mdev;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	struct mlx5_flow_namespace      *ns;
 +	struct mlx5_flow_namespace      *egress_ns;
  #ifdef CONFIG_MLX5_EN_RXNFC
  	struct mlx5e_ethtool_steering   ethtool;
  #endif
@@@ -178,8 -181,10 +184,15 @@@ void mlx5e_disable_cvlan_filter(struct 
  int mlx5e_create_flow_steering(struct mlx5e_priv *priv);
  void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +int mlx5e_fs_init(struct mlx5e_priv *priv);
 +void mlx5e_fs_cleanup(struct mlx5e_priv *priv);
++=======
+ struct mlx5e_flow_steering *mlx5e_fs_init(const struct mlx5e_profile *profile,
+ 					  struct mlx5_core_dev *mdev,
+ 					  bool state_destroy);
+ void mlx5e_fs_cleanup(struct mlx5e_flow_steering *fs);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  
  int mlx5e_add_vlan_trap(struct mlx5e_priv *priv, int  trap_id, int tir_num);
  void mlx5e_remove_vlan_trap(struct mlx5e_priv *priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 3f8245301b0a,0f3730a099bb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -519,10 -518,10 +519,10 @@@ static void mlx5e_del_vlan_rules(struc
  		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_CTAG_VID, i);
  	}
  
 -	for_each_set_bit(i, priv->fs->vlan->active_svlans, VLAN_N_VID)
 +	for_each_set_bit(i, priv->fs.vlan->active_svlans, VLAN_N_VID)
  		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_STAG_VID, i);
  
- 	WARN_ON_ONCE(!(test_bit(MLX5E_STATE_DESTROYING, &priv->state)));
+ 	WARN_ON_ONCE(priv->fs->state_destroy);
  
  	mlx5e_remove_vlan_trap(priv);
  
@@@ -548,9 -547,9 +548,13 @@@ static void mlx5e_execute_l2_action(str
  
  	switch (action) {
  	case MLX5E_ACTION_ADD:
- 		mlx5e_add_l2_flow_rule(priv, &hn->ai, MLX5E_FULLMATCH);
+ 		mlx5e_add_l2_flow_rule(fs, &hn->ai, MLX5E_FULLMATCH);
  		if (!is_multicast_ether_addr(mac_addr)) {
++<<<<<<< HEAD
 +			l2_err = mlx5_mpfs_add_mac(priv->mdev, mac_addr);
++=======
+ 			l2_err = mlx5_mpfs_add_mac(fs->mdev, mac_addr);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  			hn->mpfs = !l2_err;
  		}
  		hn->action = MLX5E_ACTION_NONE;
@@@ -558,32 -557,30 +562,51 @@@
  
  	case MLX5E_ACTION_DEL:
  		if (!is_multicast_ether_addr(mac_addr) && hn->mpfs)
++<<<<<<< HEAD
 +			l2_err = mlx5_mpfs_del_mac(priv->mdev, mac_addr);
 +		mlx5e_del_l2_flow_rule(priv, &hn->ai);
++=======
+ 			l2_err = mlx5_mpfs_del_mac(fs->mdev, mac_addr);
+ 		mlx5e_del_l2_flow_rule(fs, &hn->ai);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		mlx5e_del_l2_from_hash(hn);
  		break;
  	}
  
  	if (l2_err)
++<<<<<<< HEAD
 +		netdev_warn(priv->netdev, "MPFS, failed to %s mac %pM, err(%d)\n",
 +			    action == MLX5E_ACTION_ADD ? "add" : "del", mac_addr, l2_err);
++=======
+ 		mlx5_core_warn(fs->mdev, "MPFS, failed to %s mac %pM, err(%d)\n",
+ 			       action == MLX5E_ACTION_ADD ? "add" : "del", mac_addr, l2_err);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  }
  
- static void mlx5e_sync_netdev_addr(struct mlx5e_priv *priv)
+ static void mlx5e_sync_netdev_addr(struct mlx5e_flow_steering *fs,
+ 				   struct net_device *netdev)
  {
- 	struct net_device *netdev = priv->netdev;
  	struct netdev_hw_addr *ha;
  
  	netif_addr_lock_bh(netdev);
  
++<<<<<<< HEAD
 +	mlx5e_add_l2_to_hash(priv->fs.l2.netdev_uc,
 +			     priv->netdev->dev_addr);
 +
 +	netdev_for_each_uc_addr(ha, netdev)
 +		mlx5e_add_l2_to_hash(priv->fs.l2.netdev_uc, ha->addr);
 +
 +	netdev_for_each_mc_addr(ha, netdev)
 +		mlx5e_add_l2_to_hash(priv->fs.l2.netdev_mc, ha->addr);
++=======
+ 	mlx5e_add_l2_to_hash(fs->l2.netdev_uc, netdev->dev_addr);
+ 	netdev_for_each_uc_addr(ha, netdev)
+ 		mlx5e_add_l2_to_hash(fs->l2.netdev_uc, ha->addr);
+ 
+ 	netdev_for_each_mc_addr(ha, netdev)
+ 		mlx5e_add_l2_to_hash(fs->l2.netdev_mc, ha->addr);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  
  	netif_addr_unlock_bh(netdev);
  }
@@@ -599,11 -596,11 +622,19 @@@ static void mlx5e_fill_addr_array(struc
  	int i = 0;
  	int hi;
  
++<<<<<<< HEAD
 +	addr_list = is_uc ? priv->fs.l2.netdev_uc : priv->fs.l2.netdev_mc;
 +
 +	if (is_uc) /* Make sure our own address is pushed first */
 +		ether_addr_copy(addr_array[i++], ndev->dev_addr);
 +	else if (priv->fs.l2.broadcast_enabled)
++=======
+ 	addr_list = is_uc ? fs->l2.netdev_uc : fs->l2.netdev_mc;
+ 
+ 	if (is_uc) /* Make sure our own address is pushed first */
+ 		ether_addr_copy(addr_array[i++], ndev->dev_addr);
+ 	else if (fs->l2.broadcast_enabled)
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		ether_addr_copy(addr_array[i++], ndev->broadcast);
  
  	mlx5e_for_each_hash_node(hn, tmp, addr_list, hi) {
@@@ -628,19 -626,19 +660,34 @@@ static void mlx5e_vport_context_update_
  	int err;
  	int hi;
  
++<<<<<<< HEAD
 +	size = is_uc ? 0 : (priv->fs.l2.broadcast_enabled ? 1 : 0);
 +	max_size = is_uc ?
 +		1 << MLX5_CAP_GEN(priv->mdev, log_max_current_uc_list) :
 +		1 << MLX5_CAP_GEN(priv->mdev, log_max_current_mc_list);
 +
 +	addr_list = is_uc ? priv->fs.l2.netdev_uc : priv->fs.l2.netdev_mc;
++=======
+ 	size = is_uc ? 0 : (fs->l2.broadcast_enabled ? 1 : 0);
+ 	max_size = is_uc ?
+ 		1 << MLX5_CAP_GEN(fs->mdev, log_max_current_uc_list) :
+ 		1 << MLX5_CAP_GEN(fs->mdev, log_max_current_mc_list);
+ 
+ 	addr_list = is_uc ? fs->l2.netdev_uc : fs->l2.netdev_mc;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	mlx5e_for_each_hash_node(hn, tmp, addr_list, hi)
  		size++;
  
  	if (size > max_size) {
++<<<<<<< HEAD
 +		netdev_warn(priv->netdev,
 +			    "netdev %s list size (%d) > (%d) max vport list size, some addresses will be dropped\n",
 +			    is_uc ? "UC" : "MC", size, max_size);
++=======
+ 		mlx5_core_warn(fs->mdev,
+ 			       "mdev %s list size (%d) > (%d) max vport list size, some addresses will be dropped\n",
+ 			      is_uc ? "UC" : "MC", size, max_size);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		size = max_size;
  	}
  
@@@ -650,25 -648,26 +697,43 @@@
  			err = -ENOMEM;
  			goto out;
  		}
- 		mlx5e_fill_addr_array(priv, list_type, addr_array, size);
+ 		mlx5e_fill_addr_array(fs, list_type, netdev, addr_array, size);
  	}
  
++<<<<<<< HEAD
 +	err = mlx5_modify_nic_vport_mac_list(priv->mdev, list_type, addr_array, size);
 +out:
 +	if (err)
 +		netdev_err(priv->netdev,
 +			   "Failed to modify vport %s list err(%d)\n",
 +			   is_uc ? "UC" : "MC", err);
++=======
+ 	err = mlx5_modify_nic_vport_mac_list(fs->mdev, list_type, addr_array, size);
+ out:
+ 	if (err)
+ 		mlx5_core_err(fs->mdev,
+ 			      "Failed to modify vport %s list err(%d)\n",
+ 			      is_uc ? "UC" : "MC", err);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	kfree(addr_array);
  }
  
- static void mlx5e_vport_context_update(struct mlx5e_priv *priv)
+ static void mlx5e_vport_context_update(struct mlx5e_flow_steering *fs,
+ 				       struct net_device *netdev)
  {
++<<<<<<< HEAD
 +	struct mlx5e_l2_table *ea = &priv->fs.l2;
 +
 +	mlx5e_vport_context_update_addr_list(priv, MLX5_NVPRT_LIST_TYPE_UC);
 +	mlx5e_vport_context_update_addr_list(priv, MLX5_NVPRT_LIST_TYPE_MC);
 +	mlx5_modify_nic_vport_promisc(priv->mdev, 0,
++=======
+ 	struct mlx5e_l2_table *ea = &fs->l2;
+ 
+ 	mlx5e_vport_context_update_addr_list(fs, netdev, MLX5_NVPRT_LIST_TYPE_UC);
+ 	mlx5e_vport_context_update_addr_list(fs, netdev, MLX5_NVPRT_LIST_TYPE_MC);
+ 	mlx5_modify_nic_vport_promisc(fs->mdev, 0,
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  				      ea->allmulti_enabled,
  				      ea->promisc_enabled);
  }
@@@ -679,36 -678,37 +744,55 @@@ static void mlx5e_apply_netdev_addr(str
  	struct hlist_node *tmp;
  	int i;
  
++<<<<<<< HEAD
 +	mlx5e_for_each_hash_node(hn, tmp, priv->fs.l2.netdev_uc, i)
 +		mlx5e_execute_l2_action(priv, hn);
 +
 +	mlx5e_for_each_hash_node(hn, tmp, priv->fs.l2.netdev_mc, i)
 +		mlx5e_execute_l2_action(priv, hn);
++=======
+ 	mlx5e_for_each_hash_node(hn, tmp, fs->l2.netdev_uc, i)
+ 		mlx5e_execute_l2_action(fs, hn);
+ 
+ 	mlx5e_for_each_hash_node(hn, tmp, fs->l2.netdev_mc, i)
+ 		mlx5e_execute_l2_action(fs, hn);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  }
  
- static void mlx5e_handle_netdev_addr(struct mlx5e_priv *priv)
+ static void mlx5e_handle_netdev_addr(struct mlx5e_flow_steering *fs,
+ 				     struct net_device *netdev)
  {
  	struct mlx5e_l2_hash_node *hn;
  	struct hlist_node *tmp;
  	int i;
  
++<<<<<<< HEAD
 +	mlx5e_for_each_hash_node(hn, tmp, priv->fs.l2.netdev_uc, i)
 +		hn->action = MLX5E_ACTION_DEL;
 +	mlx5e_for_each_hash_node(hn, tmp, priv->fs.l2.netdev_mc, i)
++=======
+ 	mlx5e_for_each_hash_node(hn, tmp, fs->l2.netdev_uc, i)
+ 		hn->action = MLX5E_ACTION_DEL;
+ 	mlx5e_for_each_hash_node(hn, tmp, fs->l2.netdev_mc, i)
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		hn->action = MLX5E_ACTION_DEL;
  
- 	if (!test_bit(MLX5E_STATE_DESTROYING, &priv->state))
- 		mlx5e_sync_netdev_addr(priv);
+ 	if (fs->state_destroy)
+ 		mlx5e_sync_netdev_addr(fs, netdev);
  
- 	mlx5e_apply_netdev_addr(priv);
+ 	mlx5e_apply_netdev_addr(fs);
  }
  
  #define MLX5E_PROMISC_GROUP0_SIZE BIT(0)
  #define MLX5E_PROMISC_TABLE_SIZE MLX5E_PROMISC_GROUP0_SIZE
  
- static int mlx5e_add_promisc_rule(struct mlx5e_priv *priv)
+ static int mlx5e_add_promisc_rule(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	struct mlx5_flow_table *ft = priv->fs.promisc.ft.t;
++=======
+ 	struct mlx5_flow_table *ft = fs->promisc.ft.t;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	struct mlx5_flow_destination dest = {};
  	struct mlx5_flow_handle **rule_p;
  	MLX5_DECLARE_FLOW_ACT(flow_act);
@@@ -719,22 -719,22 +803,36 @@@
  	if (!spec)
  		return -ENOMEM;
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
++<<<<<<< HEAD
 +	dest.ft = mlx5_get_ttc_flow_table(priv->fs.ttc);
 +
 +	rule_p = &priv->fs.promisc.rule;
++=======
+ 	dest.ft = mlx5_get_ttc_flow_table(fs->ttc);
+ 
+ 	rule_p = &fs->promisc.rule;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	*rule_p = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);
  	if (IS_ERR(*rule_p)) {
  		err = PTR_ERR(*rule_p);
  		*rule_p = NULL;
++<<<<<<< HEAD
 +		netdev_err(priv->netdev, "%s: add promiscuous rule failed\n", __func__);
++=======
+ 		mlx5_core_err(fs->mdev, "%s: add promiscuous rule failed\n", __func__);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	}
  	kvfree(spec);
  	return err;
  }
  
- static int mlx5e_create_promisc_table(struct mlx5e_priv *priv)
+ static int mlx5e_create_promisc_table(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	struct mlx5e_flow_table *ft = &priv->fs.promisc.ft;
++=======
+ 	struct mlx5e_flow_table *ft = &fs->promisc.ft;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	struct mlx5_flow_table_attr ft_attr = {};
  	int err;
  
@@@ -743,10 -743,10 +841,17 @@@
  	ft_attr.level = MLX5E_PROMISC_FT_LEVEL;
  	ft_attr.prio = MLX5E_NIC_PRIO;
  
++<<<<<<< HEAD
 +	ft->t = mlx5_create_auto_grouped_flow_table(priv->fs.ns, &ft_attr);
 +	if (IS_ERR(ft->t)) {
 +		err = PTR_ERR(ft->t);
 +		netdev_err(priv->netdev, "fail to create promisc table err=%d\n", err);
++=======
+ 	ft->t = mlx5_create_auto_grouped_flow_table(fs->ns, &ft_attr);
+ 	if (IS_ERR(ft->t)) {
+ 		err = PTR_ERR(ft->t);
+ 		mlx5_core_err(fs->mdev, "fail to create promisc table err=%d\n", err);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		return err;
  	}
  
@@@ -763,34 -763,31 +868,55 @@@ err_destroy_promisc_table
  	return err;
  }
  
- static void mlx5e_del_promisc_rule(struct mlx5e_priv *priv)
+ static void mlx5e_del_promisc_rule(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	if (WARN(!priv->fs.promisc.rule, "Trying to remove non-existing promiscuous rule"))
 +		return;
 +	mlx5_del_flow_rules(priv->fs.promisc.rule);
 +	priv->fs.promisc.rule = NULL;
++=======
+ 	if (WARN(!fs->promisc.rule, "Trying to remove non-existing promiscuous rule"))
+ 		return;
+ 	mlx5_del_flow_rules(fs->promisc.rule);
+ 	fs->promisc.rule = NULL;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  }
  
- static void mlx5e_destroy_promisc_table(struct mlx5e_priv *priv)
+ static void mlx5e_destroy_promisc_table(struct mlx5e_flow_steering *fs)
  {
++<<<<<<< HEAD
 +	if (WARN(!priv->fs.promisc.ft.t, "Trying to remove non-existing promiscuous table"))
 +		return;
 +	mlx5e_del_promisc_rule(priv);
 +	mlx5_destroy_flow_table(priv->fs.promisc.ft.t);
 +	priv->fs.promisc.ft.t = NULL;
++=======
+ 	if (WARN(!fs->promisc.ft.t, "Trying to remove non-existing promiscuous table"))
+ 		return;
+ 	mlx5e_del_promisc_rule(fs);
+ 	mlx5_destroy_flow_table(fs->promisc.ft.t);
+ 	fs->promisc.ft.t = NULL;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  }
  
- void mlx5e_set_rx_mode_work(struct work_struct *work)
+ void mlx5e_fs_set_rx_mode_work(struct mlx5e_flow_steering *fs,
+ 			       struct net_device *netdev)
  {
- 	struct mlx5e_priv *priv = container_of(work, struct mlx5e_priv,
- 					       set_rx_mode_work);
+ 	struct mlx5e_l2_table *ea = &fs->l2;
  
++<<<<<<< HEAD
 +	struct mlx5e_l2_table *ea = &priv->fs.l2;
 +	struct net_device *ndev = priv->netdev;
 +
 +	bool rx_mode_enable   = !test_bit(MLX5E_STATE_DESTROYING, &priv->state);
 +	bool promisc_enabled   = rx_mode_enable && (ndev->flags & IFF_PROMISC);
 +	bool allmulti_enabled  = rx_mode_enable && (ndev->flags & IFF_ALLMULTI);
++=======
+ 	bool rx_mode_enable  = fs->state_destroy;
+ 	bool promisc_enabled   = rx_mode_enable && (netdev->flags & IFF_PROMISC);
+ 	bool allmulti_enabled  = rx_mode_enable && (netdev->flags & IFF_ALLMULTI);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	bool broadcast_enabled = rx_mode_enable;
  
  	bool enable_promisc    = !ea->promisc_enabled   &&  promisc_enabled;
@@@ -802,26 -799,26 +928,32 @@@
  	int err;
  
  	if (enable_promisc) {
- 		err = mlx5e_create_promisc_table(priv);
+ 		err = mlx5e_create_promisc_table(fs);
  		if (err)
  			enable_promisc = false;
++<<<<<<< HEAD
 +		if (!priv->channels.params.vlan_strip_disable && !err)
 +			netdev_warn_once(ndev,
 +					 "S-tagged traffic will be dropped while C-tag vlan stripping is enabled\n");
++=======
+ 		if (!fs->vlan_strip_disable && !err)
+ 			mlx5_core_warn_once(fs->mdev,
+ 					    "S-tagged traffic will be dropped while C-tag vlan stripping is enabled\n");
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	}
  	if (enable_allmulti)
- 		mlx5e_add_l2_flow_rule(priv, &ea->allmulti, MLX5E_ALLMULTI);
+ 		mlx5e_add_l2_flow_rule(fs, &ea->allmulti, MLX5E_ALLMULTI);
  	if (enable_broadcast)
- 		mlx5e_add_l2_flow_rule(priv, &ea->broadcast, MLX5E_FULLMATCH);
+ 		mlx5e_add_l2_flow_rule(fs, &ea->broadcast, MLX5E_FULLMATCH);
  
- 	mlx5e_handle_netdev_addr(priv);
+ 	mlx5e_handle_netdev_addr(fs, netdev);
  
  	if (disable_broadcast)
- 		mlx5e_del_l2_flow_rule(priv, &ea->broadcast);
+ 		mlx5e_del_l2_flow_rule(fs, &ea->broadcast);
  	if (disable_allmulti)
- 		mlx5e_del_l2_flow_rule(priv, &ea->allmulti);
+ 		mlx5e_del_l2_flow_rule(fs, &ea->allmulti);
  	if (disable_promisc)
- 		mlx5e_destroy_promisc_table(priv);
+ 		mlx5e_destroy_promisc_table(fs);
  
  	ea->promisc_enabled   = promisc_enabled;
  	ea->allmulti_enabled  = allmulti_enabled;
@@@ -919,10 -916,10 +1051,14 @@@ static void mlx5e_del_l2_flow_rule(stru
  	}
  }
  
- static int mlx5e_add_l2_flow_rule(struct mlx5e_priv *priv,
+ static int mlx5e_add_l2_flow_rule(struct mlx5e_flow_steering *fs,
  				  struct mlx5e_l2_rule *ai, int type)
  {
++<<<<<<< HEAD
 +	struct mlx5_flow_table *ft = priv->fs.l2.ft.t;
++=======
+ 	struct mlx5_flow_table *ft = fs->l2.ft.t;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	struct mlx5_flow_destination dest = {};
  	MLX5_DECLARE_FLOW_ACT(flow_act);
  	struct mlx5_flow_spec *spec;
@@@ -940,7 -937,7 +1076,11 @@@
  			       outer_headers.dmac_47_16);
  
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
++<<<<<<< HEAD
 +	dest.ft = mlx5_get_ttc_flow_table(priv->fs.ttc);
++=======
+ 	dest.ft = mlx5_get_ttc_flow_table(fs->ttc);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  
  	switch (type) {
  	case MLX5E_FULLMATCH:
@@@ -958,8 -955,8 +1098,13 @@@
  
  	ai->rule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);
  	if (IS_ERR(ai->rule)) {
++<<<<<<< HEAD
 +		netdev_err(priv->netdev, "%s: add l2 rule(mac:%pM) failed\n",
 +			   __func__, mv_dmac);
++=======
+ 		mlx5_core_err(fs->mdev, "%s: add l2 rule(mac:%pM) failed\n",
+ 			      __func__, mv_dmac);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		err = PTR_ERR(ai->rule);
  		ai->rule = NULL;
  	}
@@@ -1369,18 -1365,27 +1514,35 @@@ static void mlx5e_fs_tc_free(struct mlx
  	mlx5e_tc_table_free(fs->tc);
  }
  
++<<<<<<< HEAD
 +int mlx5e_fs_init(struct mlx5e_priv *priv)
++=======
+ struct mlx5e_flow_steering *mlx5e_fs_init(const struct mlx5e_profile *profile,
+ 					  struct mlx5_core_dev *mdev,
+ 					  bool state_destroy)
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  {
 -	struct mlx5e_flow_steering *fs;
  	int err;
  
++<<<<<<< HEAD
 +	if (mlx5e_profile_feature_cap(priv->profile, FS_VLAN)) {
 +		err = mlx5e_fs_vlan_alloc(&priv->fs);
++=======
+ 	fs = kvzalloc(sizeof(*fs), GFP_KERNEL);
+ 	if (!fs)
+ 		goto err;
+ 
+ 	fs->mdev = mdev;
+ 	fs->state_destroy = state_destroy;
+ 	if (mlx5e_profile_feature_cap(profile, FS_VLAN)) {
+ 		err = mlx5e_fs_vlan_alloc(fs);
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		if (err)
 -			goto err_free_fs;
 +			goto err;
  	}
  
 -	if (mlx5e_profile_feature_cap(profile, FS_TC)) {
 -		err = mlx5e_fs_tc_alloc(fs);
 +	if (mlx5e_profile_feature_cap(priv->profile, FS_TC)) {
 +		err = mlx5e_fs_tc_alloc(&priv->fs);
  		if (err)
  			goto err_free_vlan;
  	}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 945751d7ac68,ca7f8d6f8ab7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -4958,8 -5023,10 +4961,15 @@@ static int mlx5e_nic_init(struct mlx5_c
  
  	mlx5e_timestamp_init(priv);
  
++<<<<<<< HEAD
 +	err = mlx5e_fs_init(priv);
 +	if (err) {
++=======
+ 	fs = mlx5e_fs_init(priv->profile, mdev,
+ 			   !test_bit(MLX5E_STATE_DESTROYING, &priv->state));
+ 	if (!fs) {
+ 		err = -ENOMEM;
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  		mlx5_core_err(mdev, "FS initialization failed, %d\n", err);
  		return err;
  	}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 0f4abe589eaa,3ad9752c35ee..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -836,9 -836,18 +836,19 @@@ static int mlx5e_init_rep_rx(struct mlx
  	struct mlx5_core_dev *mdev = priv->mdev;
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	priv->fs = mlx5e_fs_init(priv->profile, mdev,
+ 				 !test_bit(MLX5E_STATE_DESTROYING, &priv->state));
+ 	if (!priv->fs) {
+ 		netdev_err(priv->netdev, "FS allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	priv->rx_res = mlx5e_rx_res_alloc();
 -	if (!priv->rx_res) {
 -		err = -ENOMEM;
 -		goto err_free_fs;
 -	}
 +	if (!priv->rx_res)
 +		return -ENOMEM;
  
  	mlx5e_init_l2_addr(priv);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index f037b0822cb1,c02b7b08fb4c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -364,9 -364,18 +364,19 @@@ static int mlx5i_init_rx(struct mlx5e_p
  	struct mlx5_core_dev *mdev = priv->mdev;
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	priv->fs = mlx5e_fs_init(priv->profile, mdev,
+ 				 !test_bit(MLX5E_STATE_DESTROYING, &priv->state));
+ 	if (!priv->fs) {
+ 		netdev_err(priv->netdev, "FS allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
++>>>>>>> 5b031add2f94 (net/mlx5e: Separate mlx5e_set_rx_mode_work and move caller to en_main)
  	priv->rx_res = mlx5e_rx_res_alloc();
 -	if (!priv->rx_res) {
 -		err = -ENOMEM;
 -		goto err_free_fs;
 -	}
 +	if (!priv->rx_res)
 +		return -ENOMEM;
  
  	mlx5e_create_q_counters(priv);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
