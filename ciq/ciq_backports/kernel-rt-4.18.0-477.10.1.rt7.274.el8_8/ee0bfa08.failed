x86/compressed/64: Add support for SEV-SNP CPUID table in #VC handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Michael Roth <michael.roth@amd.com>
commit ee0bfa08a345370df28c07288e886abcbaac481f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/ee0bfa08.failed

CPUID instructions generate a #VC exception for SEV-ES/SEV-SNP guests,
for which early handlers are currently set up to handle. In the case
of SEV-SNP, guests can use a configurable location in guest memory
that has been pre-populated with a firmware-validated CPUID table to
look up the relevant CPUID values rather than requesting them from
hypervisor via a VMGEXIT. Add the various hooks in the #VC handlers to
allow CPUID instructions to be handled via the table. The code to
actually configure/enable the table will be added in a subsequent
commit.

	Signed-off-by: Michael Roth <michael.roth@amd.com>
	Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/r/20220307213356.2797205-33-brijesh.singh@amd.com
(cherry picked from commit ee0bfa08a345370df28c07288e886abcbaac481f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/sev-common.h
#	arch/x86/kernel/sev-shared.c
diff --cc arch/x86/include/asm/sev-common.h
index 94f0ea574049,0759af9b1acf..000000000000
--- a/arch/x86/include/asm/sev-common.h
+++ b/arch/x86/include/asm/sev-common.h
@@@ -83,6 -151,9 +83,12 @@@
  #define GHCB_TERM_REGISTER		0	/* GHCB GPA registration failure */
  #define GHCB_TERM_PSC			1	/* Page State Change failure */
  #define GHCB_TERM_PVALIDATE		2	/* Pvalidate failure */
++<<<<<<< HEAD
++=======
+ #define GHCB_TERM_NOT_VMPL0		3	/* SNP guest is not running at VMPL-0 */
+ #define GHCB_TERM_CPUID			4	/* CPUID-validation failure */
+ #define GHCB_TERM_CPUID_HV		5	/* CPUID failure during hypervisor fallback */
++>>>>>>> ee0bfa08a345 (x86/compressed/64: Add support for SEV-SNP CPUID table in #VC handlers)
  
  #define GHCB_RESP_CODE(v)		((v) & GHCB_MSR_INFO_MASK)
  
diff --cc arch/x86/kernel/sev-shared.c
index 91ece8db542a,0f1375164ff0..000000000000
--- a/arch/x86/kernel/sev-shared.c
+++ b/arch/x86/kernel/sev-shared.c
@@@ -14,6 -14,46 +14,36 @@@
  #define has_cpuflag(f)	boot_cpu_has(f)
  #endif
  
 -/* I/O parameters for CPUID-related helpers */
 -struct cpuid_leaf {
 -	u32 fn;
 -	u32 subfn;
 -	u32 eax;
 -	u32 ebx;
 -	u32 ecx;
 -	u32 edx;
 -};
 -
+ /*
+  * Individual entries of the SNP CPUID table, as defined by the SNP
+  * Firmware ABI, Revision 0.9, Section 7.1, Table 14.
+  */
+ struct snp_cpuid_fn {
+ 	u32 eax_in;
+ 	u32 ecx_in;
+ 	u64 xcr0_in;
+ 	u64 xss_in;
+ 	u32 eax;
+ 	u32 ebx;
+ 	u32 ecx;
+ 	u32 edx;
+ 	u64 __reserved;
+ } __packed;
+ 
+ /*
+  * SNP CPUID table, as defined by the SNP Firmware ABI, Revision 0.9,
+  * Section 8.14.2.6. Also noted there is the SNP firmware-enforced limit
+  * of 64 entries per CPUID table.
+  */
+ #define SNP_CPUID_COUNT_MAX 64
+ 
+ struct snp_cpuid_table {
+ 	u32 count;
+ 	u32 __reserved1;
+ 	u64 __reserved2;
+ 	struct snp_cpuid_fn fn[SNP_CPUID_COUNT_MAX];
+ } __packed;
+ 
  /*
   * Since feature negotiation related variables are set early in the boot
   * process they must reside in the .data section so as not to be zeroed
@@@ -158,6 -247,290 +201,252 @@@ enum es_result sev_es_ghcb_hv_call(stru
  	return verify_exception_info(ghcb, ctxt);
  }
  
 -static int __sev_cpuid_hv(u32 fn, int reg_idx, u32 *reg)
 -{
 -	u64 val;
 -
 -	sev_es_wr_ghcb_msr(GHCB_CPUID_REQ(fn, reg_idx));
 -	VMGEXIT();
 -	val = sev_es_rd_ghcb_msr();
 -	if (GHCB_RESP_CODE(val) != GHCB_MSR_CPUID_RESP)
 -		return -EIO;
 -
 -	*reg = (val >> 32);
 -
 -	return 0;
 -}
 -
 -static int sev_cpuid_hv(struct cpuid_leaf *leaf)
 -{
 -	int ret;
 -
 -	/*
 -	 * MSR protocol does not support fetching non-zero subfunctions, but is
 -	 * sufficient to handle current early-boot cases. Should that change,
 -	 * make sure to report an error rather than ignoring the index and
 -	 * grabbing random values. If this issue arises in the future, handling
 -	 * can be added here to use GHCB-page protocol for cases that occur late
 -	 * enough in boot that GHCB page is available.
 -	 */
 -	if (cpuid_function_is_indexed(leaf->fn) && leaf->subfn)
 -		return -EINVAL;
 -
 -	ret =         __sev_cpuid_hv(leaf->fn, GHCB_CPUID_REQ_EAX, &leaf->eax);
 -	ret = ret ? : __sev_cpuid_hv(leaf->fn, GHCB_CPUID_REQ_EBX, &leaf->ebx);
 -	ret = ret ? : __sev_cpuid_hv(leaf->fn, GHCB_CPUID_REQ_ECX, &leaf->ecx);
 -	ret = ret ? : __sev_cpuid_hv(leaf->fn, GHCB_CPUID_REQ_EDX, &leaf->edx);
 -
 -	return ret;
 -}
 -
+ /*
+  * This may be called early while still running on the initial identity
+  * mapping. Use RIP-relative addressing to obtain the correct address
+  * while running with the initial identity mapping as well as the
+  * switch-over to kernel virtual addresses later.
+  */
+ static const struct snp_cpuid_table *snp_cpuid_get_table(void)
+ {
+ 	void *ptr;
+ 
+ 	asm ("lea cpuid_table_copy(%%rip), %0"
+ 	     : "=r" (ptr)
+ 	     : "p" (&cpuid_table_copy));
+ 
+ 	return ptr;
+ }
+ 
+ /*
+  * The SNP Firmware ABI, Revision 0.9, Section 7.1, details the use of
+  * XCR0_IN and XSS_IN to encode multiple versions of 0xD subfunctions 0
+  * and 1 based on the corresponding features enabled by a particular
+  * combination of XCR0 and XSS registers so that a guest can look up the
+  * version corresponding to the features currently enabled in its XCR0/XSS
+  * registers. The only values that differ between these versions/table
+  * entries is the enabled XSAVE area size advertised via EBX.
+  *
+  * While hypervisors may choose to make use of this support, it is more
+  * robust/secure for a guest to simply find the entry corresponding to the
+  * base/legacy XSAVE area size (XCR0=1 or XCR0=3), and then calculate the
+  * XSAVE area size using subfunctions 2 through 64, as documented in APM
+  * Volume 3, Rev 3.31, Appendix E.3.8, which is what is done here.
+  *
+  * Since base/legacy XSAVE area size is documented as 0x240, use that value
+  * directly rather than relying on the base size in the CPUID table.
+  *
+  * Return: XSAVE area size on success, 0 otherwise.
+  */
+ static u32 snp_cpuid_calc_xsave_size(u64 xfeatures_en, bool compacted)
+ {
+ 	const struct snp_cpuid_table *cpuid_table = snp_cpuid_get_table();
+ 	u64 xfeatures_found = 0;
+ 	u32 xsave_size = 0x240;
+ 	int i;
+ 
+ 	for (i = 0; i < cpuid_table->count; i++) {
+ 		const struct snp_cpuid_fn *e = &cpuid_table->fn[i];
+ 
+ 		if (!(e->eax_in == 0xD && e->ecx_in > 1 && e->ecx_in < 64))
+ 			continue;
+ 		if (!(xfeatures_en & (BIT_ULL(e->ecx_in))))
+ 			continue;
+ 		if (xfeatures_found & (BIT_ULL(e->ecx_in)))
+ 			continue;
+ 
+ 		xfeatures_found |= (BIT_ULL(e->ecx_in));
+ 
+ 		if (compacted)
+ 			xsave_size += e->eax;
+ 		else
+ 			xsave_size = max(xsave_size, e->eax + e->ebx);
+ 	}
+ 
+ 	/*
+ 	 * Either the guest set unsupported XCR0/XSS bits, or the corresponding
+ 	 * entries in the CPUID table were not present. This is not a valid
+ 	 * state to be in.
+ 	 */
+ 	if (xfeatures_found != (xfeatures_en & GENMASK_ULL(63, 2)))
+ 		return 0;
+ 
+ 	return xsave_size;
+ }
+ 
+ static bool
+ snp_cpuid_get_validated_func(struct cpuid_leaf *leaf)
+ {
+ 	const struct snp_cpuid_table *cpuid_table = snp_cpuid_get_table();
+ 	int i;
+ 
+ 	for (i = 0; i < cpuid_table->count; i++) {
+ 		const struct snp_cpuid_fn *e = &cpuid_table->fn[i];
+ 
+ 		if (e->eax_in != leaf->fn)
+ 			continue;
+ 
+ 		if (cpuid_function_is_indexed(leaf->fn) && e->ecx_in != leaf->subfn)
+ 			continue;
+ 
+ 		/*
+ 		 * For 0xD subfunctions 0 and 1, only use the entry corresponding
+ 		 * to the base/legacy XSAVE area size (XCR0=1 or XCR0=3, XSS=0).
+ 		 * See the comments above snp_cpuid_calc_xsave_size() for more
+ 		 * details.
+ 		 */
+ 		if (e->eax_in == 0xD && (e->ecx_in == 0 || e->ecx_in == 1))
+ 			if (!(e->xcr0_in == 1 || e->xcr0_in == 3) || e->xss_in)
+ 				continue;
+ 
+ 		leaf->eax = e->eax;
+ 		leaf->ebx = e->ebx;
+ 		leaf->ecx = e->ecx;
+ 		leaf->edx = e->edx;
+ 
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static void snp_cpuid_hv(struct cpuid_leaf *leaf)
+ {
+ 	if (sev_cpuid_hv(leaf))
+ 		sev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_CPUID_HV);
+ }
+ 
+ static int snp_cpuid_postprocess(struct cpuid_leaf *leaf)
+ {
+ 	struct cpuid_leaf leaf_hv = *leaf;
+ 
+ 	switch (leaf->fn) {
+ 	case 0x1:
+ 		snp_cpuid_hv(&leaf_hv);
+ 
+ 		/* initial APIC ID */
+ 		leaf->ebx = (leaf_hv.ebx & GENMASK(31, 24)) | (leaf->ebx & GENMASK(23, 0));
+ 		/* APIC enabled bit */
+ 		leaf->edx = (leaf_hv.edx & BIT(9)) | (leaf->edx & ~BIT(9));
+ 
+ 		/* OSXSAVE enabled bit */
+ 		if (native_read_cr4() & X86_CR4_OSXSAVE)
+ 			leaf->ecx |= BIT(27);
+ 		break;
+ 	case 0x7:
+ 		/* OSPKE enabled bit */
+ 		leaf->ecx &= ~BIT(4);
+ 		if (native_read_cr4() & X86_CR4_PKE)
+ 			leaf->ecx |= BIT(4);
+ 		break;
+ 	case 0xB:
+ 		leaf_hv.subfn = 0;
+ 		snp_cpuid_hv(&leaf_hv);
+ 
+ 		/* extended APIC ID */
+ 		leaf->edx = leaf_hv.edx;
+ 		break;
+ 	case 0xD: {
+ 		bool compacted = false;
+ 		u64 xcr0 = 1, xss = 0;
+ 		u32 xsave_size;
+ 
+ 		if (leaf->subfn != 0 && leaf->subfn != 1)
+ 			return 0;
+ 
+ 		if (native_read_cr4() & X86_CR4_OSXSAVE)
+ 			xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);
+ 		if (leaf->subfn == 1) {
+ 			/* Get XSS value if XSAVES is enabled. */
+ 			if (leaf->eax & BIT(3)) {
+ 				unsigned long lo, hi;
+ 
+ 				asm volatile("rdmsr" : "=a" (lo), "=d" (hi)
+ 						     : "c" (MSR_IA32_XSS));
+ 				xss = (hi << 32) | lo;
+ 			}
+ 
+ 			/*
+ 			 * The PPR and APM aren't clear on what size should be
+ 			 * encoded in 0xD:0x1:EBX when compaction is not enabled
+ 			 * by either XSAVEC (feature bit 1) or XSAVES (feature
+ 			 * bit 3) since SNP-capable hardware has these feature
+ 			 * bits fixed as 1. KVM sets it to 0 in this case, but
+ 			 * to avoid this becoming an issue it's safer to simply
+ 			 * treat this as unsupported for SNP guests.
+ 			 */
+ 			if (!(leaf->eax & (BIT(1) | BIT(3))))
+ 				return -EINVAL;
+ 
+ 			compacted = true;
+ 		}
+ 
+ 		xsave_size = snp_cpuid_calc_xsave_size(xcr0 | xss, compacted);
+ 		if (!xsave_size)
+ 			return -EINVAL;
+ 
+ 		leaf->ebx = xsave_size;
+ 		}
+ 		break;
+ 	case 0x8000001E:
+ 		snp_cpuid_hv(&leaf_hv);
+ 
+ 		/* extended APIC ID */
+ 		leaf->eax = leaf_hv.eax;
+ 		/* compute ID */
+ 		leaf->ebx = (leaf->ebx & GENMASK(31, 8)) | (leaf_hv.ebx & GENMASK(7, 0));
+ 		/* node ID */
+ 		leaf->ecx = (leaf->ecx & GENMASK(31, 8)) | (leaf_hv.ecx & GENMASK(7, 0));
+ 		break;
+ 	default:
+ 		/* No fix-ups needed, use values as-is. */
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Returns -EOPNOTSUPP if feature not enabled. Any other non-zero return value
+  * should be treated as fatal by caller.
+  */
+ static int snp_cpuid(struct cpuid_leaf *leaf)
+ {
+ 	const struct snp_cpuid_table *cpuid_table = snp_cpuid_get_table();
+ 
+ 	if (!cpuid_table->count)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!snp_cpuid_get_validated_func(leaf)) {
+ 		/*
+ 		 * Some hypervisors will avoid keeping track of CPUID entries
+ 		 * where all values are zero, since they can be handled the
+ 		 * same as out-of-range values (all-zero). This is useful here
+ 		 * as well as it allows virtually all guest configurations to
+ 		 * work using a single SNP CPUID table.
+ 		 *
+ 		 * To allow for this, there is a need to distinguish between
+ 		 * out-of-range entries and in-range zero entries, since the
+ 		 * CPUID table entries are only a template that may need to be
+ 		 * augmented with additional values for things like
+ 		 * CPU-specific information during post-processing. So if it's
+ 		 * not in the table, set the values to zero. Then, if they are
+ 		 * within a valid CPUID range, proceed with post-processing
+ 		 * using zeros as the initial values. Otherwise, skip
+ 		 * post-processing and just return zeros immediately.
+ 		 */
+ 		leaf->eax = leaf->ebx = leaf->ecx = leaf->edx = 0;
+ 
+ 		/* Skip post-processing for out-of-range zero leafs. */
+ 		if (!(leaf->fn <= cpuid_std_range_max ||
+ 		      (leaf->fn >= 0x40000000 && leaf->fn <= cpuid_hyp_range_max) ||
+ 		      (leaf->fn >= 0x80000000 && leaf->fn <= cpuid_ext_range_max)))
+ 			return 0;
+ 	}
+ 
+ 	return snp_cpuid_postprocess(leaf);
+ }
+ 
  /*
   * Boot VC Handler - This is the first VC handler during boot, there is no GHCB
   * page yet, so it only supports the MSR based communication with the
@@@ -165,40 -538,33 +454,67 @@@
   */
  void __init do_vc_no_ghcb(struct pt_regs *regs, unsigned long exit_code)
  {
 -	unsigned int subfn = lower_bits(regs->cx, 32);
  	unsigned int fn = lower_bits(regs->ax, 32);
++<<<<<<< HEAD
 +	unsigned long val;
++=======
+ 	struct cpuid_leaf leaf;
+ 	int ret;
++>>>>>>> ee0bfa08a345 (x86/compressed/64: Add support for SEV-SNP CPUID table in #VC handlers)
  
  	/* Only CPUID is supported via MSR protocol */
  	if (exit_code != SVM_EXIT_CPUID)
  		goto fail;
  
++<<<<<<< HEAD
 +	sev_es_wr_ghcb_msr(GHCB_CPUID_REQ(fn, GHCB_CPUID_REQ_EAX));
 +	VMGEXIT();
 +	val = sev_es_rd_ghcb_msr();
 +	if (GHCB_RESP_CODE(val) != GHCB_MSR_CPUID_RESP)
++=======
+ 	leaf.fn = fn;
+ 	leaf.subfn = subfn;
+ 
+ 	ret = snp_cpuid(&leaf);
+ 	if (!ret)
+ 		goto cpuid_done;
+ 
+ 	if (ret != -EOPNOTSUPP)
+ 		goto fail;
+ 
+ 	if (sev_cpuid_hv(&leaf))
++>>>>>>> ee0bfa08a345 (x86/compressed/64: Add support for SEV-SNP CPUID table in #VC handlers)
 +		goto fail;
 +	regs->ax = val >> 32;
 +
++<<<<<<< HEAD
 +	sev_es_wr_ghcb_msr(GHCB_CPUID_REQ(fn, GHCB_CPUID_REQ_EBX));
 +	VMGEXIT();
 +	val = sev_es_rd_ghcb_msr();
 +	if (GHCB_RESP_CODE(val) != GHCB_MSR_CPUID_RESP)
 +		goto fail;
 +	regs->bx = val >> 32;
 +
 +	sev_es_wr_ghcb_msr(GHCB_CPUID_REQ(fn, GHCB_CPUID_REQ_ECX));
 +	VMGEXIT();
 +	val = sev_es_rd_ghcb_msr();
 +	if (GHCB_RESP_CODE(val) != GHCB_MSR_CPUID_RESP)
  		goto fail;
 +	regs->cx = val >> 32;
  
 +	sev_es_wr_ghcb_msr(GHCB_CPUID_REQ(fn, GHCB_CPUID_REQ_EDX));
 +	VMGEXIT();
 +	val = sev_es_rd_ghcb_msr();
 +	if (GHCB_RESP_CODE(val) != GHCB_MSR_CPUID_RESP)
 +		goto fail;
 +	regs->dx = val >> 32;
++=======
+ cpuid_done:
+ 	regs->ax = leaf.eax;
+ 	regs->bx = leaf.ebx;
+ 	regs->cx = leaf.ecx;
+ 	regs->dx = leaf.edx;
++>>>>>>> ee0bfa08a345 (x86/compressed/64: Add support for SEV-SNP CPUID table in #VC handlers)
  
  	/*
  	 * This is a VC handler and the #VC is only raised when SEV-ES is
* Unmerged path arch/x86/include/asm/sev-common.h
* Unmerged path arch/x86/kernel/sev-shared.c
