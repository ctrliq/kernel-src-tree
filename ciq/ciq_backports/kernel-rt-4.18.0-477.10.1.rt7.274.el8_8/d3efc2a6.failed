net: devlink: remove devlink_mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Jiri Pirko <jiri@nvidia.com>
commit d3efc2a6a6d851bcd53805309f4632e018007436
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/d3efc2a6.failed

All accesses to devlink structure from userspace and drivers are locked
with devlink->lock instance mutex. Also, devlinks xa_array iteration is
taken care of by iteration helpers taking devlink reference.

Therefore, remove devlink_mutex as it is no longer needed.

	Signed-off-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d3efc2a6a6d851bcd53805309f4632e018007436)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index d6ce0602d04f,06cd7c1a1f0a..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -202,14 -225,6 +202,17 @@@ static DEFINE_XARRAY_FLAGS(devlinks, XA
  #define ASSERT_DEVLINK_NOT_REGISTERED(d)                                       \
  	WARN_ON_ONCE(xa_get_mark(&devlinks, (d)->index, DEVLINK_REGISTERED))
  
++<<<<<<< HEAD
 +/* devlink_mutex
 + *
 + * An overall lock guarding every operation coming from userspace.
 + * It also guards devlink devices list and it is taken when
 + * driver registers/unregisters it.
 + */
 +static DEFINE_MUTEX(devlink_mutex);
 +
++=======
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  struct net *devlink_net(const struct devlink *devlink)
  {
  	return read_pnet(&devlink->_net);
@@@ -639,14 -770,10 +642,16 @@@ static int devlink_nl_pre_doit(const st
  	struct devlink *devlink;
  	int err;
  
- 	mutex_lock(&devlink_mutex);
  	devlink = devlink_get_from_attrs(genl_info_net(info), info->attrs);
- 	if (IS_ERR(devlink)) {
- 		mutex_unlock(&devlink_mutex);
+ 	if (IS_ERR(devlink))
  		return PTR_ERR(devlink);
++<<<<<<< HEAD
 +	}
 +	if (~ops->internal_flags & DEVLINK_NL_FLAG_NO_LOCK)
 +		devl_lock(devlink);
++=======
+ 	devl_lock(devlink);
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  	info->user_ptr[0] = devlink;
  	if (ops->internal_flags & DEVLINK_NL_FLAG_NEED_PORT) {
  		devlink_port = devlink_port_get_from_info(devlink, info);
@@@ -681,10 -815,8 +686,9 @@@
  	return 0;
  
  unlock:
 -	devl_unlock(devlink);
 +	if (~ops->internal_flags & DEVLINK_NL_FLAG_NO_LOCK)
 +		devl_unlock(devlink);
  	devlink_put(devlink);
- 	mutex_unlock(&devlink_mutex);
  	return err;
  }
  
@@@ -694,10 -826,13 +698,9 @@@ static void devlink_nl_post_doit(const 
  	struct devlink *devlink;
  
  	devlink = info->user_ptr[0];
 -	if (ops->internal_flags & DEVLINK_NL_FLAG_NEED_LINECARD) {
 -		linecard = info->user_ptr[1];
 -		devlink_linecard_put(linecard);
 -	}
 -	devl_unlock(devlink);
 +	if (~ops->internal_flags & DEVLINK_NL_FLAG_NO_LOCK)
 +		devl_unlock(devlink);
  	devlink_put(devlink);
- 	mutex_unlock(&devlink_mutex);
  }
  
  static struct genl_family devlink_nl_family;
@@@ -1240,14 -1397,7 +1243,18 @@@ static int devlink_nl_cmd_rate_get_dump
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(devlink_rate, &devlink->rate_list, list) {
  			enum devlink_command cmd = DEVLINK_CMD_RATE_NEW;
@@@ -1343,16 -1491,7 +1349,20 @@@ static int devlink_nl_cmd_get_dumpit(st
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk))) {
 +			devlink_put(devlink);
 +			continue;
 +		}
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		if (idx < start) {
  			idx++;
  			devlink_put(devlink);
@@@ -1406,14 -1543,7 +1414,18 @@@ static int devlink_nl_cmd_port_get_dump
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(devlink_port, &devlink->port_list, list) {
  			if (idx < start) {
@@@ -1972,6 -2096,316 +1982,319 @@@ static int devlink_nl_cmd_rate_del_doit
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct devlink_linecard_type {
+ 	const char *type;
+ 	const void *priv;
+ };
+ 
+ static int devlink_nl_linecard_fill(struct sk_buff *msg,
+ 				    struct devlink *devlink,
+ 				    struct devlink_linecard *linecard,
+ 				    enum devlink_command cmd, u32 portid,
+ 				    u32 seq, int flags,
+ 				    struct netlink_ext_ack *extack)
+ {
+ 	struct devlink_linecard_type *linecard_type;
+ 	struct nlattr *attr;
+ 	void *hdr;
+ 	int i;
+ 
+ 	hdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);
+ 	if (!hdr)
+ 		return -EMSGSIZE;
+ 
+ 	if (devlink_nl_put_handle(msg, devlink))
+ 		goto nla_put_failure;
+ 	if (nla_put_u32(msg, DEVLINK_ATTR_LINECARD_INDEX, linecard->index))
+ 		goto nla_put_failure;
+ 	if (nla_put_u8(msg, DEVLINK_ATTR_LINECARD_STATE, linecard->state))
+ 		goto nla_put_failure;
+ 	if (linecard->type &&
+ 	    nla_put_string(msg, DEVLINK_ATTR_LINECARD_TYPE, linecard->type))
+ 		goto nla_put_failure;
+ 
+ 	if (linecard->types_count) {
+ 		attr = nla_nest_start(msg,
+ 				      DEVLINK_ATTR_LINECARD_SUPPORTED_TYPES);
+ 		if (!attr)
+ 			goto nla_put_failure;
+ 		for (i = 0; i < linecard->types_count; i++) {
+ 			linecard_type = &linecard->types[i];
+ 			if (nla_put_string(msg, DEVLINK_ATTR_LINECARD_TYPE,
+ 					   linecard_type->type)) {
+ 				nla_nest_cancel(msg, attr);
+ 				goto nla_put_failure;
+ 			}
+ 		}
+ 		nla_nest_end(msg, attr);
+ 	}
+ 
+ 	if (linecard->nested_devlink &&
+ 	    devlink_nl_put_nested_handle(msg, linecard->nested_devlink))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ 	return -EMSGSIZE;
+ }
+ 
+ static void devlink_linecard_notify(struct devlink_linecard *linecard,
+ 				    enum devlink_command cmd)
+ {
+ 	struct devlink *devlink = linecard->devlink;
+ 	struct sk_buff *msg;
+ 	int err;
+ 
+ 	WARN_ON(cmd != DEVLINK_CMD_LINECARD_NEW &&
+ 		cmd != DEVLINK_CMD_LINECARD_DEL);
+ 
+ 	if (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))
+ 		return;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return;
+ 
+ 	err = devlink_nl_linecard_fill(msg, devlink, linecard, cmd, 0, 0, 0,
+ 				       NULL);
+ 	if (err) {
+ 		nlmsg_free(msg);
+ 		return;
+ 	}
+ 
+ 	genlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),
+ 				msg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);
+ }
+ 
+ static int devlink_nl_cmd_linecard_get_doit(struct sk_buff *skb,
+ 					    struct genl_info *info)
+ {
+ 	struct devlink_linecard *linecard = info->user_ptr[1];
+ 	struct devlink *devlink = linecard->devlink;
+ 	struct sk_buff *msg;
+ 	int err;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&linecard->state_lock);
+ 	err = devlink_nl_linecard_fill(msg, devlink, linecard,
+ 				       DEVLINK_CMD_LINECARD_NEW,
+ 				       info->snd_portid, info->snd_seq, 0,
+ 				       info->extack);
+ 	mutex_unlock(&linecard->state_lock);
+ 	if (err) {
+ 		nlmsg_free(msg);
+ 		return err;
+ 	}
+ 
+ 	return genlmsg_reply(msg, info);
+ }
+ 
+ static int devlink_nl_cmd_linecard_get_dumpit(struct sk_buff *msg,
+ 					      struct netlink_callback *cb)
+ {
+ 	struct devlink_linecard *linecard;
+ 	struct devlink *devlink;
+ 	int start = cb->args[0];
+ 	unsigned long index;
+ 	int idx = 0;
+ 	int err;
+ 
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
+ 		mutex_lock(&devlink->linecards_lock);
+ 		list_for_each_entry(linecard, &devlink->linecard_list, list) {
+ 			if (idx < start) {
+ 				idx++;
+ 				continue;
+ 			}
+ 			mutex_lock(&linecard->state_lock);
+ 			err = devlink_nl_linecard_fill(msg, devlink, linecard,
+ 						       DEVLINK_CMD_LINECARD_NEW,
+ 						       NETLINK_CB(cb->skb).portid,
+ 						       cb->nlh->nlmsg_seq,
+ 						       NLM_F_MULTI,
+ 						       cb->extack);
+ 			mutex_unlock(&linecard->state_lock);
+ 			if (err) {
+ 				mutex_unlock(&devlink->linecards_lock);
+ 				devlink_put(devlink);
+ 				goto out;
+ 			}
+ 			idx++;
+ 		}
+ 		mutex_unlock(&devlink->linecards_lock);
+ 		devlink_put(devlink);
+ 	}
+ out:
+ 	cb->args[0] = idx;
+ 	return msg->len;
+ }
+ 
+ static struct devlink_linecard_type *
+ devlink_linecard_type_lookup(struct devlink_linecard *linecard,
+ 			     const char *type)
+ {
+ 	struct devlink_linecard_type *linecard_type;
+ 	int i;
+ 
+ 	for (i = 0; i < linecard->types_count; i++) {
+ 		linecard_type = &linecard->types[i];
+ 		if (!strcmp(type, linecard_type->type))
+ 			return linecard_type;
+ 	}
+ 	return NULL;
+ }
+ 
+ static int devlink_linecard_type_set(struct devlink_linecard *linecard,
+ 				     const char *type,
+ 				     struct netlink_ext_ack *extack)
+ {
+ 	const struct devlink_linecard_ops *ops = linecard->ops;
+ 	struct devlink_linecard_type *linecard_type;
+ 	int err;
+ 
+ 	mutex_lock(&linecard->state_lock);
+ 	if (linecard->state == DEVLINK_LINECARD_STATE_PROVISIONING) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Line card is currently being provisioned");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+ 	if (linecard->state == DEVLINK_LINECARD_STATE_UNPROVISIONING) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Line card is currently being unprovisioned");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	linecard_type = devlink_linecard_type_lookup(linecard, type);
+ 	if (!linecard_type) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Unsupported line card type provided");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (linecard->state != DEVLINK_LINECARD_STATE_UNPROVISIONED &&
+ 	    linecard->state != DEVLINK_LINECARD_STATE_PROVISIONING_FAILED) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Line card already provisioned");
+ 		err = -EBUSY;
+ 		/* Check if the line card is provisioned in the same
+ 		 * way the user asks. In case it is, make the operation
+ 		 * to return success.
+ 		 */
+ 		if (ops->same_provision &&
+ 		    ops->same_provision(linecard, linecard->priv,
+ 					linecard_type->type,
+ 					linecard_type->priv))
+ 			err = 0;
+ 		goto out;
+ 	}
+ 
+ 	linecard->state = DEVLINK_LINECARD_STATE_PROVISIONING;
+ 	linecard->type = linecard_type->type;
+ 	devlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);
+ 	mutex_unlock(&linecard->state_lock);
+ 	err = ops->provision(linecard, linecard->priv, linecard_type->type,
+ 			     linecard_type->priv, extack);
+ 	if (err) {
+ 		/* Provisioning failed. Assume the linecard is unprovisioned
+ 		 * for future operations.
+ 		 */
+ 		mutex_lock(&linecard->state_lock);
+ 		linecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;
+ 		linecard->type = NULL;
+ 		devlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);
+ 		mutex_unlock(&linecard->state_lock);
+ 	}
+ 	return err;
+ 
+ out:
+ 	mutex_unlock(&linecard->state_lock);
+ 	return err;
+ }
+ 
+ static int devlink_linecard_type_unset(struct devlink_linecard *linecard,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	int err;
+ 
+ 	mutex_lock(&linecard->state_lock);
+ 	if (linecard->state == DEVLINK_LINECARD_STATE_PROVISIONING) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Line card is currently being provisioned");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+ 	if (linecard->state == DEVLINK_LINECARD_STATE_UNPROVISIONING) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Line card is currently being unprovisioned");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+ 	if (linecard->state == DEVLINK_LINECARD_STATE_PROVISIONING_FAILED) {
+ 		linecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;
+ 		linecard->type = NULL;
+ 		devlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);
+ 		err = 0;
+ 		goto out;
+ 	}
+ 
+ 	if (linecard->state == DEVLINK_LINECARD_STATE_UNPROVISIONED) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Line card is not provisioned");
+ 		err = 0;
+ 		goto out;
+ 	}
+ 	linecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONING;
+ 	devlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);
+ 	mutex_unlock(&linecard->state_lock);
+ 	err = linecard->ops->unprovision(linecard, linecard->priv,
+ 					 extack);
+ 	if (err) {
+ 		/* Unprovisioning failed. Assume the linecard is unprovisioned
+ 		 * for future operations.
+ 		 */
+ 		mutex_lock(&linecard->state_lock);
+ 		linecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;
+ 		linecard->type = NULL;
+ 		devlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);
+ 		mutex_unlock(&linecard->state_lock);
+ 	}
+ 	return err;
+ 
+ out:
+ 	mutex_unlock(&linecard->state_lock);
+ 	return err;
+ }
+ 
+ static int devlink_nl_cmd_linecard_set_doit(struct sk_buff *skb,
+ 					    struct genl_info *info)
+ {
+ 	struct devlink_linecard *linecard = info->user_ptr[1];
+ 	struct netlink_ext_ack *extack = info->extack;
+ 	int err;
+ 
+ 	if (info->attrs[DEVLINK_ATTR_LINECARD_TYPE]) {
+ 		const char *type;
+ 
+ 		type = nla_data(info->attrs[DEVLINK_ATTR_LINECARD_TYPE]);
+ 		if (strcmp(type, "")) {
+ 			err = devlink_linecard_type_set(linecard, type, extack);
+ 			if (err)
+ 				return err;
+ 		} else {
+ 			err = devlink_linecard_type_unset(linecard, extack);
+ 			if (err)
+ 				return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  static int devlink_nl_sb_fill(struct sk_buff *msg, struct devlink *devlink,
  			      struct devlink_sb *devlink_sb,
  			      enum devlink_command cmd, u32 portid,
@@@ -2047,14 -2481,7 +2370,18 @@@ static int devlink_nl_cmd_sb_get_dumpit
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(devlink_sb, &devlink->sb_list, list) {
  			if (idx < start) {
@@@ -2199,13 -2623,8 +2524,18 @@@ static int devlink_nl_cmd_sb_pool_get_d
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)) ||
 +		    !devlink->ops->sb_pool_get)
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
+ 		if (!devlink->ops->sb_pool_get)
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  			goto retry;
  
  		devl_lock(devlink);
@@@ -2420,13 -2837,8 +2748,18 @@@ static int devlink_nl_cmd_sb_port_pool_
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)) ||
 +		    !devlink->ops->sb_port_pool_get)
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
+ 		if (!devlink->ops->sb_port_pool_get)
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  			goto retry;
  
  		devl_lock(devlink);
@@@ -2669,13 -3079,8 +3000,18 @@@ devlink_nl_cmd_sb_tc_pool_bind_get_dump
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)) ||
 +		    !devlink->ops->sb_tc_pool_bind_get)
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
+ 		if (!devlink->ops->sb_tc_pool_bind_get)
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  			goto retry;
  
  		devl_lock(devlink);
@@@ -4397,6 -4800,204 +4731,207 @@@ static int devlink_nl_cmd_flash_update(
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ devlink_nl_selftests_fill(struct sk_buff *msg, struct devlink *devlink,
+ 			  u32 portid, u32 seq, int flags,
+ 			  struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *selftests;
+ 	void *hdr;
+ 	int err;
+ 	int i;
+ 
+ 	hdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags,
+ 			  DEVLINK_CMD_SELFTESTS_GET);
+ 	if (!hdr)
+ 		return -EMSGSIZE;
+ 
+ 	err = -EMSGSIZE;
+ 	if (devlink_nl_put_handle(msg, devlink))
+ 		goto err_cancel_msg;
+ 
+ 	selftests = nla_nest_start(msg, DEVLINK_ATTR_SELFTESTS);
+ 	if (!selftests)
+ 		goto err_cancel_msg;
+ 
+ 	for (i = DEVLINK_ATTR_SELFTEST_ID_UNSPEC + 1;
+ 	     i <= DEVLINK_ATTR_SELFTEST_ID_MAX; i++) {
+ 		if (devlink->ops->selftest_check(devlink, i, extack)) {
+ 			err = nla_put_flag(msg, i);
+ 			if (err)
+ 				goto err_cancel_msg;
+ 		}
+ 	}
+ 
+ 	nla_nest_end(msg, selftests);
+ 	genlmsg_end(msg, hdr);
+ 	return 0;
+ 
+ err_cancel_msg:
+ 	genlmsg_cancel(msg, hdr);
+ 	return err;
+ }
+ 
+ static int devlink_nl_cmd_selftests_get_doit(struct sk_buff *skb,
+ 					     struct genl_info *info)
+ {
+ 	struct devlink *devlink = info->user_ptr[0];
+ 	struct sk_buff *msg;
+ 	int err;
+ 
+ 	if (!devlink->ops->selftest_check)
+ 		return -EOPNOTSUPP;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	err = devlink_nl_selftests_fill(msg, devlink, info->snd_portid,
+ 					info->snd_seq, 0, info->extack);
+ 	if (err) {
+ 		nlmsg_free(msg);
+ 		return err;
+ 	}
+ 
+ 	return genlmsg_reply(msg, info);
+ }
+ 
+ static int devlink_nl_cmd_selftests_get_dumpit(struct sk_buff *msg,
+ 					       struct netlink_callback *cb)
+ {
+ 	struct devlink *devlink;
+ 	int start = cb->args[0];
+ 	unsigned long index;
+ 	int idx = 0;
+ 	int err = 0;
+ 
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
+ 		if (idx < start || !devlink->ops->selftest_check)
+ 			goto inc;
+ 
+ 		devl_lock(devlink);
+ 		err = devlink_nl_selftests_fill(msg, devlink,
+ 						NETLINK_CB(cb->skb).portid,
+ 						cb->nlh->nlmsg_seq, NLM_F_MULTI,
+ 						cb->extack);
+ 		devl_unlock(devlink);
+ 		if (err) {
+ 			devlink_put(devlink);
+ 			break;
+ 		}
+ inc:
+ 		idx++;
+ 		devlink_put(devlink);
+ 	}
+ 
+ 	if (err != -EMSGSIZE)
+ 		return err;
+ 
+ 	cb->args[0] = idx;
+ 	return msg->len;
+ }
+ 
+ static int devlink_selftest_result_put(struct sk_buff *skb, unsigned int id,
+ 				       enum devlink_selftest_status test_status)
+ {
+ 	struct nlattr *result_attr;
+ 
+ 	result_attr = nla_nest_start(skb, DEVLINK_ATTR_SELFTEST_RESULT);
+ 	if (!result_attr)
+ 		return -EMSGSIZE;
+ 
+ 	if (nla_put_u32(skb, DEVLINK_ATTR_SELFTEST_RESULT_ID, id) ||
+ 	    nla_put_u8(skb, DEVLINK_ATTR_SELFTEST_RESULT_STATUS,
+ 		       test_status))
+ 		goto nla_put_failure;
+ 
+ 	nla_nest_end(skb, result_attr);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(skb, result_attr);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int devlink_nl_cmd_selftests_run(struct sk_buff *skb,
+ 					struct genl_info *info)
+ {
+ 	struct nlattr *tb[DEVLINK_ATTR_SELFTEST_ID_MAX + 1];
+ 	struct devlink *devlink = info->user_ptr[0];
+ 	struct nlattr *attrs, *selftests;
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 	int err;
+ 	int i;
+ 
+ 	if (!devlink->ops->selftest_run || !devlink->ops->selftest_check)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!info->attrs[DEVLINK_ATTR_SELFTESTS]) {
+ 		NL_SET_ERR_MSG_MOD(info->extack, "selftest required");
+ 		return -EINVAL;
+ 	}
+ 
+ 	attrs = info->attrs[DEVLINK_ATTR_SELFTESTS];
+ 
+ 	err = nla_parse_nested(tb, DEVLINK_ATTR_SELFTEST_ID_MAX, attrs,
+ 			       devlink_selftest_nl_policy, info->extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	err = -EMSGSIZE;
+ 	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq,
+ 			  &devlink_nl_family, 0, DEVLINK_CMD_SELFTESTS_RUN);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (devlink_nl_put_handle(msg, devlink))
+ 		goto genlmsg_cancel;
+ 
+ 	selftests = nla_nest_start(msg, DEVLINK_ATTR_SELFTESTS);
+ 	if (!selftests)
+ 		goto genlmsg_cancel;
+ 
+ 	for (i = DEVLINK_ATTR_SELFTEST_ID_UNSPEC + 1;
+ 	     i <= DEVLINK_ATTR_SELFTEST_ID_MAX; i++) {
+ 		enum devlink_selftest_status test_status;
+ 
+ 		if (nla_get_flag(tb[i])) {
+ 			if (!devlink->ops->selftest_check(devlink, i,
+ 							  info->extack)) {
+ 				if (devlink_selftest_result_put(msg, i,
+ 								DEVLINK_SELFTEST_STATUS_SKIP))
+ 					goto selftests_nest_cancel;
+ 				continue;
+ 			}
+ 
+ 			test_status = devlink->ops->selftest_run(devlink, i,
+ 								 info->extack);
+ 			if (devlink_selftest_result_put(msg, i, test_status))
+ 				goto selftests_nest_cancel;
+ 		}
+ 	}
+ 
+ 	nla_nest_end(msg, selftests);
+ 	genlmsg_end(msg, hdr);
+ 	return genlmsg_reply(msg, info);
+ 
+ selftests_nest_cancel:
+ 	nla_nest_cancel(msg, selftests);
+ genlmsg_cancel:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return err;
+ }
+ 
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  static const struct devlink_param devlink_param_generic[] = {
  	{
  		.id = DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET,
@@@ -4756,14 -5357,7 +5291,18 @@@ static int devlink_nl_cmd_param_get_dum
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(param_item, &devlink->param_list, list) {
  			if (idx < start) {
@@@ -4991,14 -5582,7 +5528,18 @@@ static int devlink_nl_cmd_port_param_ge
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(devlink_port, &devlink->port_list, list) {
  			list_for_each_entry(param_item,
@@@ -5585,17 -6166,9 +6124,21 @@@ static int devlink_nl_cmd_region_get_du
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		err = devlink_nl_cmd_region_get_devlink_dumpit(msg, cb, devlink,
  							       &idx, start);
 +retry:
  		devlink_put(devlink);
  		if (err)
  			goto out;
@@@ -6133,14 -6696,7 +6668,18 @@@ static int devlink_nl_cmd_info_get_dump
  	int idx = 0;
  	int err = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		if (idx < start || !devlink->ops->info_get)
  			goto inc;
  
@@@ -6158,10 -6714,8 +6697,9 @@@
  		}
  inc:
  		idx++;
 +retry:
  		devlink_put(devlink);
  	}
- 	mutex_unlock(&devlink_mutex);
  
  	if (err != -EMSGSIZE)
  		return err;
@@@ -7317,14 -7866,7 +7850,18 @@@ devlink_nl_cmd_health_reporter_get_dump
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry_rep;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		mutex_lock(&devlink->reporters_lock);
  		list_for_each_entry(reporter, &devlink->reporter_list,
  				    list) {
@@@ -7913,14 -8449,7 +8448,18 @@@ static int devlink_nl_cmd_trap_get_dump
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(trap_item, &devlink->trap_list, list) {
  			if (idx < start) {
@@@ -8140,14 -8666,7 +8677,18 @@@ static int devlink_nl_cmd_trap_group_ge
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(group_item, &devlink->trap_group_list,
  				    list) {
@@@ -8454,14 -8970,7 +8993,18 @@@ static int devlink_nl_cmd_trap_policer_
  	int idx = 0;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), sock_net(msg->sk)))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(sock_net(msg->sk), index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		devl_lock(devlink);
  		list_for_each_entry(policer_item, &devlink->trap_policer_list,
  				    list) {
@@@ -11849,25 -12424,18 +12390,28 @@@ static void __net_exit devlink_pernet_p
  	/* In case network namespace is getting destroyed, reload
  	 * all devlink instances from this namespace into init_net.
  	 */
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), net))
 +			goto retry;
 +
++=======
+ 	devlinks_xa_for_each_registered_get(net, index, devlink) {
++>>>>>>> d3efc2a6a6d8 (net: devlink: remove devlink_mutex)
  		WARN_ON(!(devlink->features & DEVLINK_F_RELOAD));
 -		mutex_lock(&devlink->lock);
  		err = devlink_reload(devlink, &init_net,
  				     DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
  				     DEVLINK_RELOAD_LIMIT_UNSPEC,
  				     &actions_performed, NULL);
 -		mutex_unlock(&devlink->lock);
  		if (err && err != -EOPNOTSUPP)
  			pr_warn("Failed to reload devlink instance into init_net\n");
 +retry:
  		devlink_put(devlink);
  	}
- 	mutex_unlock(&devlink_mutex);
  }
  
  static struct pernet_operations devlink_pernet_ops __net_initdata = {
* Unmerged path net/core/devlink.c
