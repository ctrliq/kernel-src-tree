net: devlink: convert reload command to take implicit devlink->lock

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Jiri Pirko <jiri@nvidia.com>
commit 644a66c60f02f302d82c3008ae2ffe67cf495383
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/644a66c6.failed

Convert reload command to behave the same way as the rest of the
commands and let if be called with devlink->lock held. Remove the
temporary devl_lock taking from drivers. As the DEVLINK_NL_FLAG_NO_LOCK
flag is no longer used, remove it alongside.

	Signed-off-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 644a66c60f02f302d82c3008ae2ffe67cf495383)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlxsw/core.c
#	drivers/net/netdevsim/dev.c
#	net/core/devlink.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index 41bb50d94caa,66c6a7017695..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -174,8 -177,10 +174,13 @@@ static int mlx5_devlink_reload_down(str
  	default:
  		/* Unsupported action should not get to this function */
  		WARN_ON(1);
 -		ret = -EOPNOTSUPP;
 +		return -EOPNOTSUPP;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return ret;
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  }
  
  static int mlx5_devlink_reload_up(struct devlink *devlink, enum devlink_reload_action action,
@@@ -197,10 -205,10 +202,14 @@@
  	default:
  		/* Unsupported action should not get to this function */
  		WARN_ON(1);
 -		ret = -EOPNOTSUPP;
 +		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	return ret;
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  }
  
  static struct mlx5_devlink_trap *mlx5_find_trap_by_id(struct mlx5_core_dev *dev, int trap_id)
diff --cc drivers/net/ethernet/mellanox/mlxsw/core.c
index 49fab4a59db8,75553eb2c7f2..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/core.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.c
@@@ -1476,10 -1512,12 +1476,18 @@@ mlxsw_devlink_core_bus_device_reload_up
  
  	*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |
  			     BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE);
++<<<<<<< HEAD
 +	return mlxsw_core_bus_device_register(mlxsw_core->bus_info,
 +					      mlxsw_core->bus,
 +					      mlxsw_core->bus_priv, true,
 +					      devlink, extack);
++=======
+ 	err = mlxsw_core_bus_device_register(mlxsw_core->bus_info,
+ 					     mlxsw_core->bus,
+ 					     mlxsw_core->bus_priv, true,
+ 					     devlink, extack);
+ 	return err;
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  }
  
  static int mlxsw_devlink_flash_update(struct devlink *devlink,
diff --cc drivers/net/netdevsim/dev.c
index 37f2b650e9d9,e88f783c297e..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -948,13 -953,10 +948,19 @@@ static int nsim_dev_reload_down(struct 
  		 * value to true. So forbid it.
  		 */
  		NL_SET_ERR_MSG_MOD(extack, "User forbid the reload for testing purposes");
++<<<<<<< HEAD
 +		mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
++=======
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  		return -EOPNOTSUPP;
  	}
 +	nsim_bus_dev->in_reload = true;
  
  	nsim_dev_reload_destroy(nsim_dev);
++<<<<<<< HEAD
 +	mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
++=======
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  	return 0;
  }
  
@@@ -963,25 -965,18 +969,34 @@@ static int nsim_dev_reload_up(struct de
  			      struct netlink_ext_ack *extack)
  {
  	struct nsim_dev *nsim_dev = devlink_priv(devlink);
 +	struct nsim_bus_dev *nsim_bus_dev;
  	int ret;
  
++<<<<<<< HEAD
 +	nsim_bus_dev = nsim_dev->nsim_bus_dev;
 +	mutex_lock(&nsim_bus_dev->nsim_bus_reload_lock);
 +	nsim_bus_dev->in_reload = false;
 +
++=======
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  	if (nsim_dev->fail_reload) {
  		/* For testing purposes, user set debugfs fail_reload
  		 * value to true. Fail right away.
  		 */
  		NL_SET_ERR_MSG_MOD(extack, "User setup the reload to fail for testing purposes");
++<<<<<<< HEAD
 +		mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
++=======
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  		return -EINVAL;
  	}
  
  	*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
  	ret = nsim_dev_reload_create(nsim_dev, extack);
++<<<<<<< HEAD
 +	mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
++=======
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  	return ret;
  }
  
diff --cc net/core/devlink.c
index f668c5a7a91d,57865b231364..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -625,13 -766,8 +625,16 @@@ devlink_region_snapshot_get_by_id(struc
  #define DEVLINK_NL_FLAG_NEED_DEVLINK_OR_PORT	BIT(1)
  #define DEVLINK_NL_FLAG_NEED_RATE		BIT(2)
  #define DEVLINK_NL_FLAG_NEED_RATE_NODE		BIT(3)
 -#define DEVLINK_NL_FLAG_NEED_LINECARD		BIT(4)
  
++<<<<<<< HEAD
 +/* The per devlink instance lock is taken by default in the pre-doit
 + * operation, yet several commands do not require this. The global
 + * devlink lock is taken and protects from disruption by user-calls.
 + */
 +#define DEVLINK_NL_FLAG_NO_LOCK			BIT(4)
 +
++=======
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  static int devlink_nl_pre_doit(const struct genl_ops *ops,
  			       struct sk_buff *skb, struct genl_info *info)
  {
@@@ -694,8 -836,12 +695,16 @@@ static void devlink_nl_post_doit(const 
  	struct devlink *devlink;
  
  	devlink = info->user_ptr[0];
++<<<<<<< HEAD
 +	if (~ops->internal_flags & DEVLINK_NL_FLAG_NO_LOCK)
 +		devl_unlock(devlink);
++=======
+ 	if (ops->internal_flags & DEVLINK_NL_FLAG_NEED_LINECARD) {
+ 		linecard = info->user_ptr[1];
+ 		devlink_linecard_put(linecard);
+ 	}
+ 	devl_unlock(devlink);
++>>>>>>> 644a66c60f02 (net: devlink: convert reload command to take implicit devlink->lock)
  	devlink_put(devlink);
  	mutex_unlock(&devlink_mutex);
  }
@@@ -11852,21 -12495,16 +11860,23 @@@ static void __net_exit devlink_pernet_p
  	 * all devlink instances from this namespace into init_net.
  	 */
  	mutex_lock(&devlink_mutex);
 -	devlinks_xa_for_each_registered_get(net, index, devlink) {
 +	xa_for_each_marked(&devlinks, index, devlink, DEVLINK_REGISTERED) {
 +		if (!devlink_try_get(devlink))
 +			continue;
 +
 +		if (!net_eq(devlink_net(devlink), net))
 +			goto retry;
 +
  		WARN_ON(!(devlink->features & DEVLINK_F_RELOAD));
+ 		mutex_lock(&devlink->lock);
  		err = devlink_reload(devlink, &init_net,
  				     DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
  				     DEVLINK_RELOAD_LIMIT_UNSPEC,
  				     &actions_performed, NULL);
+ 		mutex_unlock(&devlink->lock);
  		if (err && err != -EOPNOTSUPP)
  			pr_warn("Failed to reload devlink instance into init_net\n");
 +retry:
  		devlink_put(devlink);
  	}
  	mutex_unlock(&devlink_mutex);
diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c
index 2c764d1d897d..78c5f40382c9 100644
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@ -3958,11 +3958,9 @@ static int mlx4_devlink_reload_down(struct devlink *devlink, bool netns_change,
 		NL_SET_ERR_MSG_MOD(extack, "Namespace change is not supported");
 		return -EOPNOTSUPP;
 	}
-	devl_lock(devlink);
 	if (persist->num_vfs)
 		mlx4_warn(persist->dev, "Reload performed on PF, will cause reset on operating Virtual Functions\n");
 	mlx4_restart_one_down(persist->pdev);
-	devl_unlock(devlink);
 	return 0;
 }
 
@@ -3975,10 +3973,8 @@ static int mlx4_devlink_reload_up(struct devlink *devlink, enum devlink_reload_a
 	struct mlx4_dev_persistent *persist = dev->persist;
 	int err;
 
-	devl_lock(devlink);
 	*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
 	err = mlx4_restart_one_up(persist->pdev, true, devlink);
-	devl_unlock(devlink);
 	if (err)
 		mlx4_err(persist->dev, "mlx4_restart_one_up failed, ret=%d\n",
 			 err);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/core.c
* Unmerged path drivers/net/netdevsim/dev.c
* Unmerged path net/core/devlink.c
