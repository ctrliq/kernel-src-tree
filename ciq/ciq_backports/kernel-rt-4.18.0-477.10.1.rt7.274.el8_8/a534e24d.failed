net/mlx5: Remove indirections from esp functions

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit a534e24d720f02395367e65af1285dc1ee3cf406
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/a534e24d.failed

This change cleanups the mlx5 esp interface.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a534e24d720f02395367e65af1285dc1ee3cf406)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
index 3ae0fdee10d2,a7bd31d10bd4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
@@@ -50,11 -59,11 +50,17 @@@ static u32 mlx5_ipsec_offload_device_ca
  	WARN_ON_ONCE(MLX5_CAP_IPSEC(mdev, log_max_ipsec_offload) > 24);
  	return caps;
  }
 -EXPORT_SYMBOL_GPL(mlx5_ipsec_device_caps);
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +static struct mlx5_accel_esp_xfrm *
 +mlx5_ipsec_offload_esp_create_xfrm(struct mlx5_core_dev *mdev,
 +				   const struct mlx5_accel_esp_xfrm_attrs *attrs,
 +				   u32 flags)
++=======
+ struct mlx5_accel_esp_xfrm *
+ mlx5_accel_esp_create_xfrm(struct mlx5_core_dev *mdev,
+ 			   const struct mlx5_accel_esp_xfrm_attrs *attrs)
++>>>>>>> a534e24d720f (net/mlx5: Remove indirections from esp functions):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  {
  	struct mlx5_ipsec_esp_xfrm *mxfrm;
  
@@@ -281,20 -276,13 +288,29 @@@ static int mlx5_modify_ipsec_obj(struc
  	return mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));
  }
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +static int mlx5_ipsec_offload_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
 +					      const struct mlx5_accel_esp_xfrm_attrs *attrs)
++=======
+ void mlx5_accel_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
+ 				const struct mlx5_accel_esp_xfrm_attrs *attrs)
++>>>>>>> a534e24d720f (net/mlx5: Remove indirections from esp functions):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  {
  	struct mlx5_ipsec_obj_attrs ipsec_attrs = {};
  	struct mlx5_core_dev *mdev = xfrm->mdev;
  	struct mlx5_ipsec_esp_xfrm *mxfrm;
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> a534e24d720f (net/mlx5: Remove indirections from esp functions):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
 +
 +	if (!memcmp(&xfrm->attrs, attrs, sizeof(xfrm->attrs)))
 +		return 0;
 +
 +	if (mlx5_ipsec_offload_esp_validate_xfrm_attrs(mdev, attrs))
 +		return -EOPNOTSUPP;
  
  	mxfrm = container_of(xfrm, struct mlx5_ipsec_esp_xfrm, accel_xfrm);
  
@@@ -312,28 -294,32 +328,54 @@@
  				    &ipsec_attrs,
  				    mxfrm->sa_ctx->ipsec_obj_id);
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +change_sw_xfrm_attrs:
 +	if (!err)
 +		memcpy(&xfrm->attrs, attrs, sizeof(xfrm->attrs));
 +
 +	mutex_unlock(&mxfrm->lock);
 +	return err;
++=======
+ 	if (err)
+ 		return;
+ 
+ 	memcpy(&xfrm->attrs, attrs, sizeof(xfrm->attrs));
++>>>>>>> a534e24d720f (net/mlx5: Remove indirections from esp functions):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  }
  
 -void *mlx5_accel_esp_create_hw_context(struct mlx5_core_dev *mdev,
 -				       struct mlx5_accel_esp_xfrm *xfrm,
 -				       u32 *sa_handle)
 +static const struct mlx5_accel_ipsec_ops ipsec_offload_ops = {
 +	.device_caps = mlx5_ipsec_offload_device_caps,
 +	.create_hw_context = mlx5_ipsec_offload_create_sa_ctx,
 +	.free_hw_context = mlx5_ipsec_offload_delete_sa_ctx,
 +	.init = mlx5_ipsec_offload_init,
 +	.esp_create_xfrm = mlx5_ipsec_offload_esp_create_xfrm,
 +	.esp_destroy_xfrm = mlx5_ipsec_offload_esp_destroy_xfrm,
 +	.esp_modify_xfrm = mlx5_ipsec_offload_esp_modify_xfrm,
 +};
 +
 +const struct mlx5_accel_ipsec_ops *mlx5_ipsec_offload_ops(struct mlx5_core_dev *mdev)
  {
 -	__be32 saddr[4] = {}, daddr[4] = {};
 +	if (!mlx5_ipsec_offload_device_caps(mdev))
 +		return NULL;
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +	return &ipsec_offload_ops;
++=======
+ 	if (!xfrm->attrs.is_ipv6) {
+ 		saddr[3] = xfrm->attrs.saddr.a4;
+ 		daddr[3] = xfrm->attrs.daddr.a4;
+ 	} else {
+ 		memcpy(saddr, xfrm->attrs.saddr.a6, sizeof(saddr));
+ 		memcpy(daddr, xfrm->attrs.daddr.a6, sizeof(daddr));
+ 	}
+ 
+ 	return mlx5_ipsec_offload_create_sa_ctx(mdev, xfrm, saddr, daddr,
+ 						xfrm->attrs.spi,
+ 						xfrm->attrs.is_ipv6, sa_handle);
+ }
+ 
+ void mlx5_accel_esp_free_hw_context(struct mlx5_core_dev *mdev, void *context)
+ {
+ 	mlx5_ipsec_offload_delete_sa_ctx(context);
++>>>>>>> a534e24d720f (net/mlx5: Remove indirections from esp functions):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
