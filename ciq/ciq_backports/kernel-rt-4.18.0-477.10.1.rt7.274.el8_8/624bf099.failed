net/mlx5e: kTLS, Dynamically re-size TX recycling pool

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit 624bf09921338f977ca81e70817ff2fd3aa9216d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/624bf099.failed

Let the TLS TX recycle pool be more flexible in size, by continuously
and dynamically allocating and releasing HW resources in response to
changes in the connections rate and load.

Allocate and release pool entries in bulks (16). Use a workqueue to
release/allocate in the background. Allocate a new bulk when the pool
size goes lower than the low threshold (1K). Symmetric operation is done
when the pool size gets greater than the upper threshold (4K).

Every idle pool entry holds: 1 TIS, 1 DEK (HW resources), in addition to
~100 bytes in host memory.

Start with an empty pool to minimize memory and HW resources waste for
non-TLS users that have the device-offload TLS enabled.

Upon a new request, in case the pool is empty, do not wait for a whole bulk
allocation to complete.  Instead, trigger an instant allocation of a single
resource to reduce latency.

Performance tests:
Before: 11,684 CPS
After:  16,556 CPS

	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 624bf09921338f977ca81e70817ff2fd3aa9216d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_tx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_tx.c
index 5fd65d395a52,6b6c7044b64a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_tx.c
@@@ -55,14 -56,49 +55,48 @@@ static int mlx5e_ktls_create_tis(struc
  	return mlx5_core_create_tis(mdev, in, tisn);
  }
  
+ static int mlx5e_ktls_create_tis_cb(struct mlx5_core_dev *mdev,
+ 				    struct mlx5_async_ctx *async_ctx,
+ 				    u32 *out, int outlen,
+ 				    mlx5_async_cbk_t callback,
+ 				    struct mlx5_async_work *context)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(create_tis_in)] = {};
+ 
+ 	mlx5e_ktls_set_tisc(mdev, MLX5_ADDR_OF(create_tis_in, in, ctx));
+ 	MLX5_SET(create_tis_in, in, opcode, MLX5_CMD_OP_CREATE_TIS);
+ 
+ 	return mlx5_cmd_exec_cb(async_ctx, in, sizeof(in),
+ 				out, outlen, callback, context);
+ }
+ 
+ static int mlx5e_ktls_destroy_tis_cb(struct mlx5_core_dev *mdev, u32 tisn,
+ 				     struct mlx5_async_ctx *async_ctx,
+ 				     u32 *out, int outlen,
+ 				     mlx5_async_cbk_t callback,
+ 				     struct mlx5_async_work *context)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(destroy_tis_in)] = {};
+ 
+ 	MLX5_SET(destroy_tis_in, in, opcode, MLX5_CMD_OP_DESTROY_TIS);
+ 	MLX5_SET(destroy_tis_in, in, tisn, tisn);
+ 
+ 	return mlx5_cmd_exec_cb(async_ctx, in, sizeof(in),
+ 				out, outlen, callback, context);
+ }
+ 
  struct mlx5e_ktls_offload_context_tx {
 -	/* fast path */
 -	u32 expected_seq;
 -	u32 tisn;
 -	bool ctx_post_pending;
 -	/* control / resync */
 -	struct list_head list_node; /* member of the pool */
 -	struct tls12_crypto_info_aes_gcm_128 crypto_info;
  	struct tls_offload_context_tx *tx_ctx;
 -	struct mlx5_core_dev *mdev;
 +	struct tls12_crypto_info_aes_gcm_128 crypto_info;
  	struct mlx5e_tls_sw_stats *sw_stats;
 +	u32 expected_seq;
 +	u32 tisn;
  	u32 key_id;
++<<<<<<< HEAD
 +	bool ctx_post_pending;
++=======
+ 	u8 create_err : 1;
++>>>>>>> 624bf0992133 (net/mlx5e: kTLS, Dynamically re-size TX recycling pool)
  };
  
  static void
@@@ -86,6 -122,347 +120,350 @@@ mlx5e_get_ktls_tx_priv_ctx(struct tls_c
  	return *ctx;
  }
  
++<<<<<<< HEAD
++=======
+ /* struct for callback API management */
+ struct mlx5e_async_ctx {
+ 	struct mlx5_async_work context;
+ 	struct mlx5_async_ctx async_ctx;
+ 	struct work_struct work;
+ 	struct mlx5e_ktls_offload_context_tx *priv_tx;
+ 	struct completion complete;
+ 	int err;
+ 	union {
+ 		u32 out_create[MLX5_ST_SZ_DW(create_tis_out)];
+ 		u32 out_destroy[MLX5_ST_SZ_DW(destroy_tis_out)];
+ 	};
+ };
+ 
+ static struct mlx5e_async_ctx *mlx5e_bulk_async_init(struct mlx5_core_dev *mdev, int n)
+ {
+ 	struct mlx5e_async_ctx *bulk_async;
+ 	int i;
+ 
+ 	bulk_async = kvcalloc(n, sizeof(struct mlx5e_async_ctx), GFP_KERNEL);
+ 	if (!bulk_async)
+ 		return NULL;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct mlx5e_async_ctx *async = &bulk_async[i];
+ 
+ 		mlx5_cmd_init_async_ctx(mdev, &async->async_ctx);
+ 		init_completion(&async->complete);
+ 	}
+ 
+ 	return bulk_async;
+ }
+ 
+ static void mlx5e_bulk_async_cleanup(struct mlx5e_async_ctx *bulk_async, int n)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct mlx5e_async_ctx *async = &bulk_async[i];
+ 
+ 		mlx5_cmd_cleanup_async_ctx(&async->async_ctx);
+ 	}
+ 	kvfree(bulk_async);
+ }
+ 
+ static void create_tis_callback(int status, struct mlx5_async_work *context)
+ {
+ 	struct mlx5e_async_ctx *async =
+ 		container_of(context, struct mlx5e_async_ctx, context);
+ 	struct mlx5e_ktls_offload_context_tx *priv_tx = async->priv_tx;
+ 
+ 	if (status) {
+ 		async->err = status;
+ 		priv_tx->create_err = 1;
+ 		goto out;
+ 	}
+ 
+ 	priv_tx->tisn = MLX5_GET(create_tis_out, async->out_create, tisn);
+ out:
+ 	complete(&async->complete);
+ }
+ 
+ static void destroy_tis_callback(int status, struct mlx5_async_work *context)
+ {
+ 	struct mlx5e_async_ctx *async =
+ 		container_of(context, struct mlx5e_async_ctx, context);
+ 	struct mlx5e_ktls_offload_context_tx *priv_tx = async->priv_tx;
+ 
+ 	complete(&async->complete);
+ 	kfree(priv_tx);
+ }
+ 
+ static struct mlx5e_ktls_offload_context_tx *
+ mlx5e_tls_priv_tx_init(struct mlx5_core_dev *mdev, struct mlx5e_tls_sw_stats *sw_stats,
+ 		       struct mlx5e_async_ctx *async)
+ {
+ 	struct mlx5e_ktls_offload_context_tx *priv_tx;
+ 	int err;
+ 
+ 	priv_tx = kzalloc(sizeof(*priv_tx), GFP_KERNEL);
+ 	if (!priv_tx)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	priv_tx->mdev = mdev;
+ 	priv_tx->sw_stats = sw_stats;
+ 
+ 	if (!async) {
+ 		err = mlx5e_ktls_create_tis(mdev, &priv_tx->tisn);
+ 		if (err)
+ 			goto err_out;
+ 	} else {
+ 		async->priv_tx = priv_tx;
+ 		err = mlx5e_ktls_create_tis_cb(mdev, &async->async_ctx,
+ 					       async->out_create, sizeof(async->out_create),
+ 					       create_tis_callback, &async->context);
+ 		if (err)
+ 			goto err_out;
+ 	}
+ 
+ 	return priv_tx;
+ 
+ err_out:
+ 	kfree(priv_tx);
+ 	return ERR_PTR(err);
+ }
+ 
+ static void mlx5e_tls_priv_tx_cleanup(struct mlx5e_ktls_offload_context_tx *priv_tx,
+ 				      struct mlx5e_async_ctx *async)
+ {
+ 	if (priv_tx->create_err) {
+ 		complete(&async->complete);
+ 		kfree(priv_tx);
+ 		return;
+ 	}
+ 	async->priv_tx = priv_tx;
+ 	mlx5e_ktls_destroy_tis_cb(priv_tx->mdev, priv_tx->tisn,
+ 				  &async->async_ctx,
+ 				  async->out_destroy, sizeof(async->out_destroy),
+ 				  destroy_tis_callback, &async->context);
+ }
+ 
+ static void mlx5e_tls_priv_tx_list_cleanup(struct mlx5_core_dev *mdev,
+ 					   struct list_head *list, int size)
+ {
+ 	struct mlx5e_ktls_offload_context_tx *obj;
+ 	struct mlx5e_async_ctx *bulk_async;
+ 	int i;
+ 
+ 	bulk_async = mlx5e_bulk_async_init(mdev, size);
+ 	if (!bulk_async)
+ 		return;
+ 
+ 	i = 0;
+ 	list_for_each_entry(obj, list, list_node) {
+ 		mlx5e_tls_priv_tx_cleanup(obj, &bulk_async[i]);
+ 		i++;
+ 	}
+ 
+ 	for (i = 0; i < size; i++) {
+ 		struct mlx5e_async_ctx *async = &bulk_async[i];
+ 
+ 		wait_for_completion(&async->complete);
+ 	}
+ 	mlx5e_bulk_async_cleanup(bulk_async, size);
+ }
+ 
+ /* Recycling pool API */
+ 
+ #define MLX5E_TLS_TX_POOL_BULK (16)
+ #define MLX5E_TLS_TX_POOL_HIGH (4 * 1024)
+ #define MLX5E_TLS_TX_POOL_LOW (MLX5E_TLS_TX_POOL_HIGH / 4)
+ 
+ struct mlx5e_tls_tx_pool {
+ 	struct mlx5_core_dev *mdev;
+ 	struct mlx5e_tls_sw_stats *sw_stats;
+ 	struct mutex lock; /* Protects access to the pool */
+ 	struct list_head list;
+ 	size_t size;
+ 
+ 	struct workqueue_struct *wq;
+ 	struct work_struct create_work;
+ 	struct work_struct destroy_work;
+ };
+ 
+ static void create_work(struct work_struct *work)
+ {
+ 	struct mlx5e_tls_tx_pool *pool =
+ 		container_of(work, struct mlx5e_tls_tx_pool, create_work);
+ 	struct mlx5e_ktls_offload_context_tx *obj;
+ 	struct mlx5e_async_ctx *bulk_async;
+ 	LIST_HEAD(local_list);
+ 	int i, j, err = 0;
+ 
+ 	bulk_async = mlx5e_bulk_async_init(pool->mdev, MLX5E_TLS_TX_POOL_BULK);
+ 	if (!bulk_async)
+ 		return;
+ 
+ 	for (i = 0; i < MLX5E_TLS_TX_POOL_BULK; i++) {
+ 		obj = mlx5e_tls_priv_tx_init(pool->mdev, pool->sw_stats, &bulk_async[i]);
+ 		if (IS_ERR(obj)) {
+ 			err = PTR_ERR(obj);
+ 			break;
+ 		}
+ 		list_add(&obj->list_node, &local_list);
+ 	}
+ 
+ 	for (j = 0; j < i; j++) {
+ 		struct mlx5e_async_ctx *async = &bulk_async[j];
+ 
+ 		wait_for_completion(&async->complete);
+ 		if (!err && async->err)
+ 			err = async->err;
+ 	}
+ 	atomic64_add(i, &pool->sw_stats->tx_tls_pool_alloc);
+ 	mlx5e_bulk_async_cleanup(bulk_async, MLX5E_TLS_TX_POOL_BULK);
+ 	if (err)
+ 		goto err_out;
+ 
+ 	mutex_lock(&pool->lock);
+ 	if (pool->size + MLX5E_TLS_TX_POOL_BULK >= MLX5E_TLS_TX_POOL_HIGH) {
+ 		mutex_unlock(&pool->lock);
+ 		goto err_out;
+ 	}
+ 	list_splice(&local_list, &pool->list);
+ 	pool->size += MLX5E_TLS_TX_POOL_BULK;
+ 	if (pool->size <= MLX5E_TLS_TX_POOL_LOW)
+ 		queue_work(pool->wq, work);
+ 	mutex_unlock(&pool->lock);
+ 	return;
+ 
+ err_out:
+ 	mlx5e_tls_priv_tx_list_cleanup(pool->mdev, &local_list, i);
+ 	atomic64_add(i, &pool->sw_stats->tx_tls_pool_free);
+ }
+ 
+ static void destroy_work(struct work_struct *work)
+ {
+ 	struct mlx5e_tls_tx_pool *pool =
+ 		container_of(work, struct mlx5e_tls_tx_pool, destroy_work);
+ 	struct mlx5e_ktls_offload_context_tx *obj;
+ 	LIST_HEAD(local_list);
+ 	int i = 0;
+ 
+ 	mutex_lock(&pool->lock);
+ 	if (pool->size < MLX5E_TLS_TX_POOL_HIGH) {
+ 		mutex_unlock(&pool->lock);
+ 		return;
+ 	}
+ 
+ 	list_for_each_entry(obj, &pool->list, list_node)
+ 		if (++i == MLX5E_TLS_TX_POOL_BULK)
+ 			break;
+ 
+ 	list_cut_position(&local_list, &pool->list, &obj->list_node);
+ 	pool->size -= MLX5E_TLS_TX_POOL_BULK;
+ 	if (pool->size >= MLX5E_TLS_TX_POOL_HIGH)
+ 		queue_work(pool->wq, work);
+ 	mutex_unlock(&pool->lock);
+ 
+ 	mlx5e_tls_priv_tx_list_cleanup(pool->mdev, &local_list, MLX5E_TLS_TX_POOL_BULK);
+ 	atomic64_add(MLX5E_TLS_TX_POOL_BULK, &pool->sw_stats->tx_tls_pool_free);
+ }
+ 
+ static struct mlx5e_tls_tx_pool *mlx5e_tls_tx_pool_init(struct mlx5_core_dev *mdev,
+ 							struct mlx5e_tls_sw_stats *sw_stats)
+ {
+ 	struct mlx5e_tls_tx_pool *pool;
+ 
+ 	BUILD_BUG_ON(MLX5E_TLS_TX_POOL_LOW + MLX5E_TLS_TX_POOL_BULK >= MLX5E_TLS_TX_POOL_HIGH);
+ 
+ 	pool = kvzalloc(sizeof(*pool), GFP_KERNEL);
+ 	if (!pool)
+ 		return NULL;
+ 
+ 	pool->wq = create_singlethread_workqueue("mlx5e_tls_tx_pool");
+ 	if (!pool->wq)
+ 		goto err_free;
+ 
+ 	INIT_LIST_HEAD(&pool->list);
+ 	mutex_init(&pool->lock);
+ 
+ 	INIT_WORK(&pool->create_work, create_work);
+ 	INIT_WORK(&pool->destroy_work, destroy_work);
+ 
+ 	pool->mdev = mdev;
+ 	pool->sw_stats = sw_stats;
+ 
+ 	return pool;
+ 
+ err_free:
+ 	kvfree(pool);
+ 	return NULL;
+ }
+ 
+ static void mlx5e_tls_tx_pool_list_cleanup(struct mlx5e_tls_tx_pool *pool)
+ {
+ 	while (pool->size > MLX5E_TLS_TX_POOL_BULK) {
+ 		struct mlx5e_ktls_offload_context_tx *obj;
+ 		LIST_HEAD(local_list);
+ 		int i = 0;
+ 
+ 		list_for_each_entry(obj, &pool->list, list_node)
+ 			if (++i == MLX5E_TLS_TX_POOL_BULK)
+ 				break;
+ 
+ 		list_cut_position(&local_list, &pool->list, &obj->list_node);
+ 		mlx5e_tls_priv_tx_list_cleanup(pool->mdev, &local_list, MLX5E_TLS_TX_POOL_BULK);
+ 		atomic64_add(MLX5E_TLS_TX_POOL_BULK, &pool->sw_stats->tx_tls_pool_free);
+ 		pool->size -= MLX5E_TLS_TX_POOL_BULK;
+ 	}
+ 	if (pool->size) {
+ 		mlx5e_tls_priv_tx_list_cleanup(pool->mdev, &pool->list, pool->size);
+ 		atomic64_add(pool->size, &pool->sw_stats->tx_tls_pool_free);
+ 	}
+ }
+ 
+ static void mlx5e_tls_tx_pool_cleanup(struct mlx5e_tls_tx_pool *pool)
+ {
+ 	mlx5e_tls_tx_pool_list_cleanup(pool);
+ 	destroy_workqueue(pool->wq);
+ 	kvfree(pool);
+ }
+ 
+ static void pool_push(struct mlx5e_tls_tx_pool *pool, struct mlx5e_ktls_offload_context_tx *obj)
+ {
+ 	mutex_lock(&pool->lock);
+ 	list_add(&obj->list_node, &pool->list);
+ 	if (++pool->size == MLX5E_TLS_TX_POOL_HIGH)
+ 		queue_work(pool->wq, &pool->destroy_work);
+ 	mutex_unlock(&pool->lock);
+ }
+ 
+ static struct mlx5e_ktls_offload_context_tx *pool_pop(struct mlx5e_tls_tx_pool *pool)
+ {
+ 	struct mlx5e_ktls_offload_context_tx *obj;
+ 
+ 	mutex_lock(&pool->lock);
+ 	if (unlikely(pool->size == 0)) {
+ 		/* pool is empty:
+ 		 * - trigger the populating work, and
+ 		 * - serve the current context via the regular blocking api.
+ 		 */
+ 		queue_work(pool->wq, &pool->create_work);
+ 		mutex_unlock(&pool->lock);
+ 		obj = mlx5e_tls_priv_tx_init(pool->mdev, pool->sw_stats, NULL);
+ 		if (!IS_ERR(obj))
+ 			atomic64_inc(&pool->sw_stats->tx_tls_pool_alloc);
+ 		return obj;
+ 	}
+ 
+ 	obj = list_first_entry(&pool->list, struct mlx5e_ktls_offload_context_tx,
+ 			       list_node);
+ 	list_del(&obj->list_node);
+ 	if (--pool->size == MLX5E_TLS_TX_POOL_LOW)
+ 		queue_work(pool->wq, &pool->create_work);
+ 	mutex_unlock(&pool->lock);
+ 	return obj;
+ }
+ 
+ /* End of pool API */
+ 
++>>>>>>> 624bf0992133 (net/mlx5e: kTLS, Dynamically re-size TX recycling pool)
  int mlx5e_ktls_add_tx(struct net_device *netdev, struct sock *sk,
  		      struct tls_crypto_info *crypto_info, u32 start_offload_tcp_sn)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_tx.c
