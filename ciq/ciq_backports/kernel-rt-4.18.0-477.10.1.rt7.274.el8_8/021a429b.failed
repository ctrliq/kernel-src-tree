net/mlx5: Don't hide fallback to software IPsec in FS code

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 021a429bdbde93be504adcea79a81a3f19349483
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/021a429b.failed

The XFRM code performs fallback to software IPsec if .xdo_dev_state_add()
returns -EOPNOTSUPP. This is what mlx5 did very deep in its stack trace,
despite have all the knowledge that IPsec is not going to work in very
early stage.

This is achieved by making sure that priv->ipsec pointer is valid for
fully working and supported hardware crypto IPsec engine.

In case, the hardware IPsec is not supported, the XFRM code will set NULL
to xso->dev and it will prevent from calls to various .xdo_dev_state_*()
callbacks.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 021a429bdbde93be504adcea79a81a3f19349483)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
index 1391a0c84f16,b04d5de91d87..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
@@@ -404,9 -388,10 +390,10 @@@ static void mlx5e_xfrm_free_state(struc
  
  int mlx5e_ipsec_init(struct mlx5e_priv *priv)
  {
- 	struct mlx5e_ipsec *ipsec = NULL;
+ 	struct mlx5e_ipsec *ipsec;
+ 	int ret;
  
 -	if (!mlx5_ipsec_device_caps(priv->mdev)) {
 +	if (!MLX5_IPSEC_DEV(priv->mdev)) {
  		netdev_dbg(priv->netdev, "Not an IPSec offload device\n");
  		return 0;
  	}
@@@ -421,14 -407,23 +408,27 @@@
  	ipsec->wq = alloc_ordered_workqueue("mlx5e_ipsec: %s", 0,
  					    priv->netdev->name);
  	if (!ipsec->wq) {
- 		kfree(ipsec);
- 		return -ENOMEM;
+ 		ret = -ENOMEM;
+ 		goto err_wq;
  	}
  
+ 	ret = mlx5e_accel_ipsec_fs_init(ipsec);
+ 	if (ret)
+ 		goto err_fs_init;
+ 
  	priv->ipsec = ipsec;
++<<<<<<< HEAD
 +	mlx5e_accel_ipsec_fs_init(priv);
++=======
++>>>>>>> 021a429bdbde (net/mlx5: Don't hide fallback to software IPsec in FS code)
  	netdev_dbg(priv->netdev, "IPSec attached to netdevice\n");
  	return 0;
+ 
+ err_fs_init:
+ 	destroy_workqueue(ipsec->wq);
+ err_wq:
+ 	kfree(ipsec);
+ 	return (ret != -EOPNOTSUPP) ? ret : 0;
  }
  
  void mlx5e_ipsec_cleanup(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 32093497292f..6564aeccf4c6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@ -610,9 +610,6 @@ int mlx5e_accel_ipsec_fs_add_rule(struct mlx5e_priv *priv,
 				  u32 ipsec_obj_id,
 				  struct mlx5e_ipsec_rule *ipsec_rule)
 {
-	if (!priv->ipsec->rx_fs)
-		return -EOPNOTSUPP;
-
 	if (attrs->action == MLX5_ACCEL_ESP_ACTION_DECRYPT)
 		return rx_add_rule(priv, attrs, ipsec_obj_id, ipsec_rule);
 	else
@@ -623,9 +620,6 @@ void mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_priv *priv,
 				   struct mlx5_accel_esp_xfrm_attrs *attrs,
 				   struct mlx5e_ipsec_rule *ipsec_rule)
 {
-	if (!priv->ipsec->rx_fs)
-		return;
-
 	if (attrs->action == MLX5_ACCEL_ESP_ACTION_DECRYPT)
 		rx_del_rule(priv, attrs, ipsec_rule);
 	else
