net/mlx5: Simplify HW context interfaces by using SA entry

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.10.1.rt7.274.el8_8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit b73e67287b80519bef0217637028d1a49456baac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.10.1.rt7.274.el8_8/b73e6728.failed

SA context logic used multiple structures to store same data
over and over. By simplifying the SA context interfaces, we
can remove extra structs.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit b73e67287b80519bef0217637028d1a49456baac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
index 3ae0fdee10d2,817747d5229e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
@@@ -1,35 -1,26 +1,39 @@@
  // SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
 -/* Copyright (c) 2017, Mellanox Technologies inc. All rights reserved. */
 +/* Copyright (c) 2020, Mellanox Technologies inc. All rights reserved. */
  
  #include "mlx5_core.h"
 -#include "ipsec.h"
 +#include "ipsec_offload.h"
  #include "lib/mlx5.h"
 -
 +#include "en_accel/ipsec_fs.h"
 +
 +#define MLX5_IPSEC_DEV_BASIC_CAPS (MLX5_ACCEL_IPSEC_CAP_DEVICE | MLX5_ACCEL_IPSEC_CAP_IPV6 | \
 +				   MLX5_ACCEL_IPSEC_CAP_LSO)
 +
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +struct mlx5_ipsec_sa_ctx {
 +	struct rhash_head hash;
 +	u32 enc_key_id;
 +	u32 ipsec_obj_id;
 +	/* hw ctx */
 +	struct mlx5_core_dev *dev;
 +	struct mlx5_ipsec_esp_xfrm *mxfrm;
 +};
 +
 +struct mlx5_ipsec_esp_xfrm {
 +	/* reference counter of SA ctx */
 +	struct mlx5_ipsec_sa_ctx *sa_ctx;
 +	struct mutex lock; /* protects mlx5_ipsec_esp_xfrm */
 +	struct mlx5_accel_esp_xfrm accel_xfrm;
 +};
 +
 +static u32 mlx5_ipsec_offload_device_caps(struct mlx5_core_dev *mdev)
++=======
+ u32 mlx5_ipsec_device_caps(struct mlx5_core_dev *mdev)
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  {
 -	u32 caps;
 -
 -	if (!MLX5_CAP_GEN(mdev, ipsec_offload))
 -		return 0;
 -
 -	if (!MLX5_CAP_GEN(mdev, log_max_dek))
 -		return 0;
 -
 -	if (!(MLX5_CAP_GEN_64(mdev, general_obj_types) &
 -	    MLX5_HCA_CAP_GENERAL_OBJECT_TYPES_IPSEC))
 -		return 0;
 +	u32 caps = MLX5_IPSEC_DEV_BASIC_CAPS;
  
 -	if (!MLX5_CAP_IPSEC(mdev, ipsec_crypto_offload) ||
 -	    !MLX5_CAP_ETH(mdev, insert_trailer))
 +	if (!mlx5_is_ipsec_device(mdev))
  		return 0;
  
  	if (!MLX5_CAP_FLOWTABLE_NIC_TX(mdev, ipsec_encrypt) ||
@@@ -50,47 -44,13 +54,55 @@@
  	WARN_ON_ONCE(MLX5_CAP_IPSEC(mdev, log_max_ipsec_offload) > 24);
  	return caps;
  }
 -EXPORT_SYMBOL_GPL(mlx5_ipsec_device_caps);
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +static struct mlx5_accel_esp_xfrm *
 +mlx5_ipsec_offload_esp_create_xfrm(struct mlx5_core_dev *mdev,
 +				   const struct mlx5_accel_esp_xfrm_attrs *attrs,
 +				   u32 flags)
 +{
 +	struct mlx5_ipsec_esp_xfrm *mxfrm;
 +
 +	mxfrm = kzalloc(sizeof(*mxfrm), GFP_KERNEL);
 +	if (!mxfrm)
 +		return ERR_PTR(-ENOMEM);
 +
 +	mutex_init(&mxfrm->lock);
 +	memcpy(&mxfrm->accel_xfrm.attrs, attrs,
 +	       sizeof(mxfrm->accel_xfrm.attrs));
 +
 +	return &mxfrm->accel_xfrm;
 +}
 +
 +static void mlx5_ipsec_offload_esp_destroy_xfrm(struct mlx5_accel_esp_xfrm *xfrm)
 +{
 +	struct mlx5_ipsec_esp_xfrm *mxfrm = container_of(xfrm, struct mlx5_ipsec_esp_xfrm,
 +							 accel_xfrm);
 +
 +	/* assuming no sa_ctx are connected to this xfrm_ctx */
 +	WARN_ON(mxfrm->sa_ctx);
 +	kfree(mxfrm);
 +}
 +
 +struct mlx5_ipsec_obj_attrs {
 +	const struct aes_gcm_keymat *aes_gcm;
 +	u32 accel_flags;
 +	u32 esn_msb;
 +	u32 enc_key_id;
 +};
 +
 +static int mlx5_create_ipsec_obj(struct mlx5_core_dev *mdev,
 +				 struct mlx5_ipsec_obj_attrs *attrs,
 +				 u32 *ipsec_id)
 +{
 +	const struct aes_gcm_keymat *aes_gcm = attrs->aes_gcm;
++=======
+ static int mlx5_create_ipsec_obj(struct mlx5e_ipsec_sa_entry *sa_entry)
+ {
+ 	struct mlx5_accel_esp_xfrm_attrs *attrs = &sa_entry->attrs;
+ 	struct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);
+ 	struct aes_gcm_keymat *aes_gcm = &attrs->keymat.aes_gcm;
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
  	u32 in[MLX5_ST_SZ_DW(create_ipsec_obj_in)] = {};
  	void *obj, *salt_p, *salt_iv_p;
@@@ -157,29 -119,12 +171,26 @@@ static void mlx5_destroy_ipsec_obj(stru
  	mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));
  }
  
- static void *mlx5_ipsec_offload_create_sa_ctx(struct mlx5_core_dev *mdev,
- 					      struct mlx5_accel_esp_xfrm *accel_xfrm,
- 					      const __be32 saddr[4], const __be32 daddr[4],
- 					      const __be32 spi, bool is_ipv6, u32 *hw_handle)
+ int mlx5_ipsec_create_sa_ctx(struct mlx5e_ipsec_sa_entry *sa_entry)
  {
- 	struct mlx5_accel_esp_xfrm_attrs *xfrm_attrs = &accel_xfrm->attrs;
- 	struct aes_gcm_keymat *aes_gcm = &xfrm_attrs->keymat.aes_gcm;
- 	struct mlx5_ipsec_obj_attrs ipsec_attrs = {};
- 	struct mlx5_ipsec_esp_xfrm *mxfrm;
- 	struct mlx5_ipsec_sa_ctx *sa_ctx;
+ 	struct aes_gcm_keymat *aes_gcm = &sa_entry->attrs.keymat.aes_gcm;
+ 	struct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);
  	int err;
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +	/* alloc SA context */
 +	sa_ctx = kzalloc(sizeof(*sa_ctx), GFP_KERNEL);
 +	if (!sa_ctx)
 +		return ERR_PTR(-ENOMEM);
 +
 +	sa_ctx->dev = mdev;
 +
 +	mxfrm = container_of(accel_xfrm, struct mlx5_ipsec_esp_xfrm, accel_xfrm);
 +	mutex_lock(&mxfrm->lock);
 +	sa_ctx->mxfrm = mxfrm;
 +
++=======
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  	/* key */
  	err = mlx5_create_encryption_key(mdev, aes_gcm->aes_key,
  					 aes_gcm->key_len / BITS_PER_BYTE,
@@@ -201,42 -141,25 +207,57 @@@
  		goto err_enc_key;
  	}
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +	*hw_handle = sa_ctx->ipsec_obj_id;
 +	mxfrm->sa_ctx = sa_ctx;
 +	mutex_unlock(&mxfrm->lock);
 +
 +	return sa_ctx;
 +
 +err_enc_key:
 +	mlx5_destroy_encryption_key(mdev, sa_ctx->enc_key_id);
 +err_sa_ctx:
 +	mutex_unlock(&mxfrm->lock);
 +	kfree(sa_ctx);
 +	return ERR_PTR(err);
++=======
+ 	return 0;
+ 
+ err_enc_key:
+ 	mlx5_destroy_encryption_key(mdev, sa_entry->enc_key_id);
+ 	return err;
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  }
  
- static void mlx5_ipsec_offload_delete_sa_ctx(void *context)
+ void mlx5_ipsec_free_sa_ctx(struct mlx5e_ipsec_sa_entry *sa_entry)
  {
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +	struct mlx5_ipsec_sa_ctx *sa_ctx = (struct mlx5_ipsec_sa_ctx *)context;
 +	struct mlx5_ipsec_esp_xfrm *mxfrm = sa_ctx->mxfrm;
 +
 +	mutex_lock(&mxfrm->lock);
 +	mlx5_destroy_ipsec_obj(sa_ctx->dev, sa_ctx->ipsec_obj_id);
 +	mlx5_destroy_encryption_key(sa_ctx->dev, sa_ctx->enc_key_id);
 +	kfree(sa_ctx);
 +	mxfrm->sa_ctx = NULL;
 +	mutex_unlock(&mxfrm->lock);
 +}
 +
 +static int mlx5_ipsec_offload_init(struct mlx5_core_dev *mdev)
 +{
 +	return 0;
++=======
+ 	struct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);
+ 
+ 	mlx5_destroy_ipsec_obj(sa_entry);
+ 	mlx5_destroy_encryption_key(mdev, sa_entry->enc_key_id);
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  }
  
- static int mlx5_modify_ipsec_obj(struct mlx5_core_dev *mdev,
- 				 struct mlx5_ipsec_obj_attrs *attrs,
- 				 u32 ipsec_id)
+ static int mlx5_modify_ipsec_obj(struct mlx5e_ipsec_sa_entry *sa_entry,
+ 				 const struct mlx5_accel_esp_xfrm_attrs *attrs)
  {
+ 	struct mlx5_core_dev *mdev = mlx5e_ipsec_sa2dev(sa_entry);
  	u32 in[MLX5_ST_SZ_DW(modify_ipsec_obj_in)] = {};
  	u32 out[MLX5_ST_SZ_DW(query_ipsec_obj_out)];
  	u64 modify_field_select = 0;
@@@ -281,59 -204,14 +302,72 @@@
  	return mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));
  }
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
 +static int mlx5_ipsec_offload_esp_modify_xfrm(struct mlx5_accel_esp_xfrm *xfrm,
 +					      const struct mlx5_accel_esp_xfrm_attrs *attrs)
 +{
 +	struct mlx5_ipsec_obj_attrs ipsec_attrs = {};
 +	struct mlx5_core_dev *mdev = xfrm->mdev;
 +	struct mlx5_ipsec_esp_xfrm *mxfrm;
 +
 +	int err = 0;
 +
 +	if (!memcmp(&xfrm->attrs, attrs, sizeof(xfrm->attrs)))
 +		return 0;
 +
 +	if (mlx5_ipsec_offload_esp_validate_xfrm_attrs(mdev, attrs))
 +		return -EOPNOTSUPP;
 +
 +	mxfrm = container_of(xfrm, struct mlx5_ipsec_esp_xfrm, accel_xfrm);
 +
 +	mutex_lock(&mxfrm->lock);
 +
 +	if (!mxfrm->sa_ctx)
 +		/* Not bound xfrm, change only sw attrs */
 +		goto change_sw_xfrm_attrs;
 +
 +	/* need to add find and replace in ipsec_rhash_sa the sa_ctx */
 +	/* modify device with new hw_sa */
 +	ipsec_attrs.accel_flags = attrs->flags;
 +	ipsec_attrs.esn_msb = attrs->esn;
 +	err = mlx5_modify_ipsec_obj(mdev,
 +				    &ipsec_attrs,
 +				    mxfrm->sa_ctx->ipsec_obj_id);
 +
 +change_sw_xfrm_attrs:
 +	if (!err)
 +		memcpy(&xfrm->attrs, attrs, sizeof(xfrm->attrs));
 +
 +	mutex_unlock(&mxfrm->lock);
 +	return err;
 +}
 +
 +static const struct mlx5_accel_ipsec_ops ipsec_offload_ops = {
 +	.device_caps = mlx5_ipsec_offload_device_caps,
 +	.create_hw_context = mlx5_ipsec_offload_create_sa_ctx,
 +	.free_hw_context = mlx5_ipsec_offload_delete_sa_ctx,
 +	.init = mlx5_ipsec_offload_init,
 +	.esp_create_xfrm = mlx5_ipsec_offload_esp_create_xfrm,
 +	.esp_destroy_xfrm = mlx5_ipsec_offload_esp_destroy_xfrm,
 +	.esp_modify_xfrm = mlx5_ipsec_offload_esp_modify_xfrm,
 +};
 +
 +const struct mlx5_accel_ipsec_ops *mlx5_ipsec_offload_ops(struct mlx5_core_dev *mdev)
 +{
 +	if (!mlx5_ipsec_offload_device_caps(mdev))
 +		return NULL;
 +
 +	return &ipsec_offload_ops;
++=======
+ void mlx5_accel_esp_modify_xfrm(struct mlx5e_ipsec_sa_entry *sa_entry,
+ 				const struct mlx5_accel_esp_xfrm_attrs *attrs)
+ {
+ 	int err;
+ 
+ 	err = mlx5_modify_ipsec_obj(sa_entry, attrs);
+ 	if (err)
+ 		return;
+ 
+ 	memcpy(&sa_entry->attrs, attrs, sizeof(sa_entry->attrs));
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry):drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_offload.c
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
index 027d80b77b28,537311a74bfb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
@@@ -283,6 -270,16 +283,19 @@@ static inline int mlx5e_xfrm_validate_s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void _update_xfrm_state(struct work_struct *work)
+ {
+ 	struct mlx5e_ipsec_modify_state_work *modify_work =
+ 		container_of(work, struct mlx5e_ipsec_modify_state_work, work);
+ 	struct mlx5e_ipsec_sa_entry *sa_entry = container_of(
+ 		modify_work, struct mlx5e_ipsec_sa_entry, modify_work);
+ 
+ 	mlx5_accel_esp_modify_xfrm(sa_entry, &modify_work->attrs);
+ }
+ 
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry)
  static int mlx5e_xfrm_add_state(struct xfrm_state *x)
  {
  	struct mlx5e_ipsec_sa_entry *sa_entry = NULL;
@@@ -377,17 -356,10 +372,24 @@@ static void mlx5e_xfrm_free_state(struc
  	struct mlx5e_ipsec_sa_entry *sa_entry = to_ipsec_sa_entry(x);
  	struct mlx5e_priv *priv = netdev_priv(x->xso.dev);
  
++<<<<<<< HEAD
 +	if (!sa_entry)
 +		return;
 +
 +	if (sa_entry->hw_context) {
 +		flush_workqueue(sa_entry->ipsec->wq);
 +		mlx5e_accel_ipsec_fs_del_rule(priv, &sa_entry->xfrm->attrs,
 +					      &sa_entry->ipsec_rule);
 +		mlx5_accel_esp_free_hw_context(sa_entry->xfrm->mdev, sa_entry->hw_context);
 +		mlx5_accel_esp_destroy_xfrm(sa_entry->xfrm);
 +	}
 +
++=======
+ 	cancel_work_sync(&sa_entry->modify_work.work);
+ 	mlx5e_accel_ipsec_fs_del_rule(priv, &sa_entry->attrs,
+ 				      &sa_entry->ipsec_rule);
+ 	mlx5_ipsec_free_sa_ctx(sa_entry);
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry)
  	kfree(sa_entry);
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
index 45f71910d196,cdcb95f90623..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
@@@ -45,6 -43,73 +45,76 @@@
  #define MLX5E_IPSEC_SADB_RX_BITS 10
  #define MLX5E_IPSEC_ESN_SCOPE_MID 0x80000000L
  
++<<<<<<< HEAD
++=======
+ enum mlx5_accel_esp_flags {
+ 	MLX5_ACCEL_ESP_FLAGS_TUNNEL            = 0,    /* Default */
+ 	MLX5_ACCEL_ESP_FLAGS_TRANSPORT         = 1UL << 0,
+ 	MLX5_ACCEL_ESP_FLAGS_ESN_TRIGGERED     = 1UL << 1,
+ 	MLX5_ACCEL_ESP_FLAGS_ESN_STATE_OVERLAP = 1UL << 2,
+ };
+ 
+ enum mlx5_accel_esp_action {
+ 	MLX5_ACCEL_ESP_ACTION_DECRYPT,
+ 	MLX5_ACCEL_ESP_ACTION_ENCRYPT,
+ };
+ 
+ enum mlx5_accel_esp_keymats {
+ 	MLX5_ACCEL_ESP_KEYMAT_AES_NONE,
+ 	MLX5_ACCEL_ESP_KEYMAT_AES_GCM,
+ };
+ 
+ struct aes_gcm_keymat {
+ 	u64   seq_iv;
+ 
+ 	u32   salt;
+ 	u32   icv_len;
+ 
+ 	u32   key_len;
+ 	u32   aes_key[256 / 32];
+ };
+ 
+ struct mlx5_accel_esp_xfrm_attrs {
+ 	enum mlx5_accel_esp_action action;
+ 	u32   esn;
+ 	__be32 spi;
+ 	u32   seq;
+ 	u32   tfc_pad;
+ 	u32   flags;
+ 	u32   sa_handle;
+ 	union {
+ 		struct {
+ 			u32 size;
+ 
+ 		} bmp;
+ 	} replay;
+ 	enum mlx5_accel_esp_keymats keymat_type;
+ 	union {
+ 		struct aes_gcm_keymat aes_gcm;
+ 	} keymat;
+ 
+ 	union {
+ 		__be32 a4;
+ 		__be32 a6[4];
+ 	} saddr;
+ 
+ 	union {
+ 		__be32 a4;
+ 		__be32 a6[4];
+ 	} daddr;
+ 
+ 	u8 is_ipv6;
+ };
+ 
+ enum mlx5_accel_ipsec_cap {
+ 	MLX5_ACCEL_IPSEC_CAP_DEVICE		= 1 << 0,
+ 	MLX5_ACCEL_IPSEC_CAP_ESP		= 1 << 1,
+ 	MLX5_ACCEL_IPSEC_CAP_IPV6		= 1 << 2,
+ 	MLX5_ACCEL_IPSEC_CAP_LSO		= 1 << 3,
+ 	MLX5_ACCEL_IPSEC_CAP_ESN		= 1 << 4,
+ };
+ 
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry)
  struct mlx5e_priv;
  
  struct mlx5e_ipsec_sw_stats {
@@@ -111,10 -161,11 +180,11 @@@ struct mlx5e_ipsec_sa_entry 
  	void (*set_iv_op)(struct sk_buff *skb, struct xfrm_state *x,
  			  struct xfrm_offload *xo);
  	u32 ipsec_obj_id;
+ 	u32 enc_key_id;
  	struct mlx5e_ipsec_rule ipsec_rule;
 -	struct mlx5e_ipsec_modify_state_work modify_work;
  };
  
 +void mlx5e_ipsec_build_inverse_table(void);
  int mlx5e_ipsec_init(struct mlx5e_priv *priv);
  void mlx5e_ipsec_cleanup(struct mlx5e_priv *priv);
  void mlx5e_ipsec_build_netdev(struct mlx5e_priv *priv);
@@@ -122,12 -173,30 +192,38 @@@
  struct xfrm_state *mlx5e_ipsec_sadb_rx_lookup(struct mlx5e_ipsec *dev,
  					      unsigned int handle);
  
++<<<<<<< HEAD
++=======
+ void mlx5e_accel_ipsec_fs_cleanup(struct mlx5e_ipsec *ipsec);
+ int mlx5e_accel_ipsec_fs_init(struct mlx5e_ipsec *ipsec);
+ int mlx5e_accel_ipsec_fs_add_rule(struct mlx5e_priv *priv,
+ 				  struct mlx5_accel_esp_xfrm_attrs *attrs,
+ 				  u32 ipsec_obj_id,
+ 				  struct mlx5e_ipsec_rule *ipsec_rule);
+ void mlx5e_accel_ipsec_fs_del_rule(struct mlx5e_priv *priv,
+ 				   struct mlx5_accel_esp_xfrm_attrs *attrs,
+ 				   struct mlx5e_ipsec_rule *ipsec_rule);
+ 
+ int mlx5_ipsec_create_sa_ctx(struct mlx5e_ipsec_sa_entry *sa_entry);
+ void mlx5_ipsec_free_sa_ctx(struct mlx5e_ipsec_sa_entry *sa_entry);
+ 
+ u32 mlx5_ipsec_device_caps(struct mlx5_core_dev *mdev);
+ 
+ void mlx5_accel_esp_modify_xfrm(struct mlx5e_ipsec_sa_entry *sa_entry,
+ 				const struct mlx5_accel_esp_xfrm_attrs *attrs);
+ 
+ static inline struct mlx5_core_dev *
+ mlx5e_ipsec_sa2dev(struct mlx5e_ipsec_sa_entry *sa_entry)
+ {
+ 	return sa_entry->ipsec->mdev;
+ }
++>>>>>>> b73e67287b80 (net/mlx5: Simplify HW context interfaces by using SA entry)
  #else
 +
 +static inline void mlx5e_ipsec_build_inverse_table(void)
 +{
 +}
 +
  static inline int mlx5e_ipsec_init(struct mlx5e_priv *priv)
  {
  	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/accel/ipsec_offload.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
