KVM: arm64: Add a macro for creating filtered sys_reg_descs entries

jira LE-4649
Rebuild_History Non-Buildable kernel-5.14.0-570.60.1.el9_6
commit-author James Morse <james.morse@arm.com>
commit 7da540e29dea6016ed55d16450d3133c70761d21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.60.1.el9_6/7da540e2.failed

The sys_reg_descs array holds function pointers and reset value for
managing the user-space and guest view of system registers. These
are mostly created by a set of macro's as only some combinations
of behaviour are needed.

If a register needs special treatment, its sys_reg_descs entry is
open-coded. This is true of some id registers where the value provided
by user-space is validated by some helpers.

Before adding another one of these, add a helper that covers the
existing special cases. 'ID_FILTERED' expects helpers to set the
user-space value, and retrieve the modified reset value.

Like ID_WRITABLE() this uses id_visibility(), which should have no
functional change for the registers converted to use ID_FILTERED().

read_sanitised_id_aa64dfr0_el1() and read_sanitised_id_aa64pfr0_el1()
have been refactored to be called from kvm_read_sanitised_id_reg(), to
try be consistent with ID_WRITABLE().

	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Joey Gouly <joey.gouly@arm.com>
	Reviewed-by: Gavin Shan <gshan@redhat.com>
	Tested-by: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
	Reviewed-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20241030160317.2528209-6-joey.gouly@arm.com
	Signed-off-by: Oliver Upton <oliver.upton@linux.dev>
(cherry picked from commit 7da540e29dea6016ed55d16450d3133c70761d21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/sys_regs.c
diff --cc arch/arm64/kvm/sys_regs.c
index d97ad622075f,86ce783a54a6..000000000000
--- a/arch/arm64/kvm/sys_regs.c
+++ b/arch/arm64/kvm/sys_regs.c
@@@ -1684,11 -1683,26 +1693,31 @@@ static unsigned int sve_visibility(cons
  	return REG_HIDDEN;
  }
  
++<<<<<<< HEAD
 +static u64 read_sanitised_id_aa64pfr0_el1(struct kvm_vcpu *vcpu,
 +					  const struct sys_reg_desc *rd)
++=======
+ static unsigned int sme_visibility(const struct kvm_vcpu *vcpu,
+ 				   const struct sys_reg_desc *rd)
+ {
+ 	if (kvm_has_feat(vcpu->kvm, ID_AA64PFR1_EL1, SME, IMP))
+ 		return 0;
+ 
+ 	return REG_HIDDEN;
+ }
+ 
+ static unsigned int fp8_visibility(const struct kvm_vcpu *vcpu,
+ 				   const struct sys_reg_desc *rd)
  {
- 	u64 val = read_sanitised_ftr_reg(SYS_ID_AA64PFR0_EL1);
+ 	if (kvm_has_fpmr(vcpu->kvm))
+ 		return 0;
+ 
+ 	return REG_HIDDEN;
+ }
  
+ static u64 sanitise_id_aa64pfr0_el1(const struct kvm_vcpu *vcpu, u64 val)
++>>>>>>> 7da540e29dea (KVM: arm64: Add a macro for creating filtered sys_reg_descs entries)
+ {
  	if (!vcpu_has_sve(vcpu))
  		val &= ~ID_AA64PFR0_EL1_SVE_MASK;
  
@@@ -2365,18 -2392,13 +2406,28 @@@ static const struct sys_reg_desc sys_re
  
  	/* AArch64 ID registers */
  	/* CRm=4 */
++<<<<<<< HEAD
 +	{ SYS_DESC(SYS_ID_AA64PFR0_EL1),
 +	  .access = access_id_reg,
 +	  .get_user = get_id_reg,
 +	  .set_user = set_id_reg,
 +	  .reset = read_sanitised_id_aa64pfr0_el1,
 +	  .val = ~(ID_AA64PFR0_EL1_AMU |
 +		   ID_AA64PFR0_EL1_MPAM |
 +		   ID_AA64PFR0_EL1_SVE |
 +		   ID_AA64PFR0_EL1_RAS |
 +		   ID_AA64PFR0_EL1_GIC |
 +		   ID_AA64PFR0_EL1_AdvSIMD |
 +		   ID_AA64PFR0_EL1_FP), },
++=======
+ 	ID_FILTERED(ID_AA64PFR0_EL1, id_aa64pfr0_el1,
+ 		    ~(ID_AA64PFR0_EL1_AMU |
+ 		      ID_AA64PFR0_EL1_MPAM |
+ 		      ID_AA64PFR0_EL1_SVE |
+ 		      ID_AA64PFR0_EL1_RAS |
+ 		      ID_AA64PFR0_EL1_AdvSIMD |
+ 		      ID_AA64PFR0_EL1_FP)),
++>>>>>>> 7da540e29dea (KVM: arm64: Add a macro for creating filtered sys_reg_descs entries)
  	ID_WRITABLE(ID_AA64PFR1_EL1, ~(ID_AA64PFR1_EL1_PFAR |
  				       ID_AA64PFR1_EL1_DF2 |
  				       ID_AA64PFR1_EL1_MTEX |
@@@ -2395,14 -2417,9 +2446,9 @@@
  	ID_WRITABLE(ID_AA64ZFR0_EL1, ~ID_AA64ZFR0_EL1_RES0),
  	ID_HIDDEN(ID_AA64SMFR0_EL1),
  	ID_UNALLOCATED(4,6),
 -	ID_WRITABLE(ID_AA64FPFR0_EL1, ~ID_AA64FPFR0_EL1_RES0),
 +	ID_UNALLOCATED(4,7),
  
  	/* CRm=5 */
- 	{ SYS_DESC(SYS_ID_AA64DFR0_EL1),
- 	  .access = access_id_reg,
- 	  .get_user = get_id_reg,
- 	  .set_user = set_id_aa64dfr0_el1,
- 	  .reset = read_sanitised_id_aa64dfr0_el1,
  	/*
  	 * Prior to FEAT_Debugv8.9, the architecture defines context-aware
  	 * breakpoints (CTX_CMPs) as the highest numbered breakpoints (BRPs).
* Unmerged path arch/arm64/kvm/sys_regs.c
