SUNRPC: Cleanup/fix initial rq_pages allocation

jira LE-4649
Rebuild_History Non-Buildable kernel-5.14.0-570.60.1.el9_6
commit-author Benjamin Coddington <bcodding@redhat.com>
commit 8b3ac9fabaa825b7bae850ee7b4580c5cba32699
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.60.1.el9_6/8b3ac9fa.failed

While investigating some reports of memory-constrained NUMA machines
failing to mount v3 and v4.0 nfs mounts, we found that svc_init_buffer()
was not attempting to retry allocations from the bulk page allocator.
Typically, this results in a single page allocation being returned and
the mount attempt fails with -ENOMEM.  A retry would have allowed the mount
to succeed.

Additionally, it seems that the bulk allocation in svc_init_buffer() is
redundant because svc_alloc_arg() will perform the required allocation and
does the correct thing to retry the allocations.

The call to allocate memory in svc_alloc_arg() drops the preferred node
argument, but I expect we'll still allocate on the preferred node because
the allocation call happens within the svc thread context, which chooses
the node with memory closest to the current thread's execution.

This patch cleans out the bulk allocation in svc_init_buffer() to allow
svc_alloc_arg() to handle the allocation/retry logic for rq_pages.

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
Fixes: ed603bcf4fea ("sunrpc: Replace the rq_pages array with dynamically-allocated memory")
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 8b3ac9fabaa825b7bae850ee7b4580c5cba32699)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/svc.c
diff --cc net/sunrpc/svc.c
index aef501b0904b,ef8a05aac87f..000000000000
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@@ -631,24 -636,18 +631,32 @@@ svc_destroy(struct svc_serv **servp
  EXPORT_SYMBOL_GPL(svc_destroy);
  
  static bool
 -svc_init_buffer(struct svc_rqst *rqstp, const struct svc_serv *serv, int node)
 +svc_init_buffer(struct svc_rqst *rqstp, unsigned int size, int node)
  {
 -	rqstp->rq_maxpages = svc_serv_maxpages(serv);
 -
 -	/* rq_pages' last entry is NULL for historical reasons. */
 -	rqstp->rq_pages = kcalloc_node(rqstp->rq_maxpages + 1,
 -				       sizeof(struct page *),
 -				       GFP_KERNEL, node);
 -	if (!rqstp->rq_pages)
 -		return false;
++<<<<<<< HEAD
 +	unsigned long pages, ret;
  
 +	/* bc_xprt uses fore channel allocated buffers */
 +	if (svc_is_backchannel(rqstp))
 +		return true;
++=======
++	rqstp->rq_maxpages = svc_serv_maxpages(serv);
++>>>>>>> 8b3ac9fabaa8 (SUNRPC: Cleanup/fix initial rq_pages allocation)
 +
 +	pages = size / PAGE_SIZE + 1; /* extra page as we hold both request and reply.
 +				       * We assume one is at most one page
 +				       */
 +	WARN_ON_ONCE(pages > RPCSVC_MAXPAGES);
 +	if (pages > RPCSVC_MAXPAGES)
 +		pages = RPCSVC_MAXPAGES;
 +
++<<<<<<< HEAD
 +	ret = alloc_pages_bulk_array_node(GFP_KERNEL, node, pages,
 +					  rqstp->rq_pages);
 +	return ret == pages;
++=======
+ 	return true;
++>>>>>>> 8b3ac9fabaa8 (SUNRPC: Cleanup/fix initial rq_pages allocation)
  }
  
  /*
* Unmerged path net/sunrpc/svc.c
