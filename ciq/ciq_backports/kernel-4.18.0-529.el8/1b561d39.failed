arm64: acpi: Fix possible memory leak of ffh_ctxt

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Sudeep Holla <sudeep.holla@arm.com>
commit 1b561d3949f8478c5403c9752b5533211a757226
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/1b561d39.failed

Allocated 'ffh_ctxt' memory leak is possible if the SMCCC version
and conduit checks fail and -EOPNOTSUPP is returned without freeing the
allocated memory.

Fix the same by moving the allocation after the SMCCC version and
conduit checks.

Fixes: 1d280ce099db ("arm64: Add architecture specific ACPI FFH Opregion callbacks")
	Cc: <stable@vger.kernel.org> # 6.2.x
	Cc: Will Deacon <will@kernel.org>
	Reported-by: kernel test robot <lkp@intel.com>
	Reported-by: Dan Carpenter <error27@gmail.com>
	Suggested-by: Dan Carpenter <error27@gmail.com>
Link: https://lore.kernel.org/r/202302191417.dAl9NuE8-lkp@intel.com/
	Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
Link: https://lore.kernel.org/r/20230223135742.2952091-1-sudeep.holla@arm.com
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 1b561d3949f8478c5403c9752b5533211a757226)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/acpi.c
diff --cc arch/arm64/kernel/acpi.c
index 68379f2cb53e,dba8fcec7f33..000000000000
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@@ -316,3 -407,113 +316,116 @@@ int apei_claim_sea(struct pt_regs *regs
  
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ void arch_reserve_mem_area(acpi_physical_address addr, size_t size)
+ {
+ 	memblock_mark_nomap(addr, size);
+ }
+ 
+ #ifdef CONFIG_ACPI_FFH
+ /*
+  * Implements ARM64 specific callbacks to support ACPI FFH Operation Region as
+  * specified in https://developer.arm.com/docs/den0048/latest
+  */
+ struct acpi_ffh_data {
+ 	struct acpi_ffh_info info;
+ 	void (*invoke_ffh_fn)(unsigned long a0, unsigned long a1,
+ 			      unsigned long a2, unsigned long a3,
+ 			      unsigned long a4, unsigned long a5,
+ 			      unsigned long a6, unsigned long a7,
+ 			      struct arm_smccc_res *args,
+ 			      struct arm_smccc_quirk *res);
+ 	void (*invoke_ffh64_fn)(const struct arm_smccc_1_2_regs *args,
+ 				struct arm_smccc_1_2_regs *res);
+ };
+ 
+ int acpi_ffh_address_space_arch_setup(void *handler_ctxt, void **region_ctxt)
+ {
+ 	enum arm_smccc_conduit conduit;
+ 	struct acpi_ffh_data *ffh_ctxt;
+ 
+ 	if (arm_smccc_get_version() < ARM_SMCCC_VERSION_1_2)
+ 		return -EOPNOTSUPP;
+ 
+ 	conduit = arm_smccc_1_1_get_conduit();
+ 	if (conduit == SMCCC_CONDUIT_NONE) {
+ 		pr_err("%s: invalid SMCCC conduit\n", __func__);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	ffh_ctxt = kzalloc(sizeof(*ffh_ctxt), GFP_KERNEL);
+ 	if (!ffh_ctxt)
+ 		return -ENOMEM;
+ 
+ 	if (conduit == SMCCC_CONDUIT_SMC) {
+ 		ffh_ctxt->invoke_ffh_fn = __arm_smccc_smc;
+ 		ffh_ctxt->invoke_ffh64_fn = arm_smccc_1_2_smc;
+ 	} else {
+ 		ffh_ctxt->invoke_ffh_fn = __arm_smccc_hvc;
+ 		ffh_ctxt->invoke_ffh64_fn = arm_smccc_1_2_hvc;
+ 	}
+ 
+ 	memcpy(ffh_ctxt, handler_ctxt, sizeof(ffh_ctxt->info));
+ 
+ 	*region_ctxt = ffh_ctxt;
+ 	return AE_OK;
+ }
+ 
+ static bool acpi_ffh_smccc_owner_allowed(u32 fid)
+ {
+ 	int owner = ARM_SMCCC_OWNER_NUM(fid);
+ 
+ 	if (owner == ARM_SMCCC_OWNER_STANDARD ||
+ 	    owner == ARM_SMCCC_OWNER_SIP || owner == ARM_SMCCC_OWNER_OEM)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ int acpi_ffh_address_space_arch_handler(acpi_integer *value, void *region_context)
+ {
+ 	int ret = 0;
+ 	struct acpi_ffh_data *ffh_ctxt = region_context;
+ 
+ 	if (ffh_ctxt->info.offset == 0) {
+ 		/* SMC/HVC 32bit call */
+ 		struct arm_smccc_res res;
+ 		u32 a[8] = { 0 }, *ptr = (u32 *)value;
+ 
+ 		if (!ARM_SMCCC_IS_FAST_CALL(*ptr) || ARM_SMCCC_IS_64(*ptr) ||
+ 		    !acpi_ffh_smccc_owner_allowed(*ptr) ||
+ 		    ffh_ctxt->info.length > 32) {
+ 			ret = AE_ERROR;
+ 		} else {
+ 			int idx, len = ffh_ctxt->info.length >> 2;
+ 
+ 			for (idx = 0; idx < len; idx++)
+ 				a[idx] = *(ptr + idx);
+ 
+ 			ffh_ctxt->invoke_ffh_fn(a[0], a[1], a[2], a[3], a[4],
+ 						a[5], a[6], a[7], &res, NULL);
+ 			memcpy(value, &res, sizeof(res));
+ 		}
+ 
+ 	} else if (ffh_ctxt->info.offset == 1) {
+ 		/* SMC/HVC 64bit call */
+ 		struct arm_smccc_1_2_regs *r = (struct arm_smccc_1_2_regs *)value;
+ 
+ 		if (!ARM_SMCCC_IS_FAST_CALL(r->a0) || !ARM_SMCCC_IS_64(r->a0) ||
+ 		    !acpi_ffh_smccc_owner_allowed(r->a0) ||
+ 		    ffh_ctxt->info.length > sizeof(*r)) {
+ 			ret = AE_ERROR;
+ 		} else {
+ 			ffh_ctxt->invoke_ffh64_fn(r, r);
+ 			memcpy(value, r, ffh_ctxt->info.length);
+ 		}
+ 	} else {
+ 		ret = AE_ERROR;
+ 	}
+ 
+ 	return ret;
+ }
+ #endif /* CONFIG_ACPI_FFH */
++>>>>>>> 1b561d3949f8 (arm64: acpi: Fix possible memory leak of ffh_ctxt)
* Unmerged path arch/arm64/kernel/acpi.c
