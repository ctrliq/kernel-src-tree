mptcp: refactor passive socket initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 3a236aef280ed5122b2d47087eb514d0921ae033
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/3a236aef.failed

After commit 30e51b923e43 ("mptcp: fix unreleased socket in accept queue")
unaccepted msk sockets go throu complete shutdown, we don't need anymore
to delay inserting the first subflow into the subflow lists.

The reference counting deserve some extra care, as __mptcp_close() is
unaware of the request socket linkage to the first subflow.

Please note that this is more a refactoring than a fix but because this
modification is needed to include other corrections, see the following
commits. Then a Fixes tag has been added here to help the stable team.

Fixes: 30e51b923e43 ("mptcp: fix unreleased socket in accept queue")
	Cc: stable@vger.kernel.org
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Tested-by: Christoph Paasch <cpaasch@apple.com>
	Signed-off-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 3a236aef280ed5122b2d47087eb514d0921ae033)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
#	net/mptcp/subflow.c
diff --cc net/mptcp/protocol.c
index 235f6c6f03b1,447641d34c2c..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -3379,25 -3703,10 +3378,28 @@@ static int mptcp_stream_accept(struct s
  		struct mptcp_subflow_context *subflow;
  		struct sock *newsk = newsock->sk;
  
 -		set_bit(SOCK_CUSTOM_SOCKOPT, &newsock->flags);
 -
  		lock_sock(newsk);
  
++<<<<<<< HEAD
 +		/* PM/worker can now acquire the first subflow socket
 +		 * lock without racing with listener queue cleanup,
 +		 * we can notify it, if needed.
 +		 *
 +		 * Even if remote has reset the initial subflow by now
 +		 * the refcnt is still at least one.
 +		 */
 +		subflow = mptcp_subflow_ctx(msk->first);
 +		list_add(&subflow->node, &msk->conn_list);
 +		sock_hold(msk->first);
 +		if (mptcp_is_fully_established(newsk))
 +			mptcp_pm_fully_established(msk, msk->first, GFP_KERNEL);
 +
 +		mptcp_copy_inaddrs(newsk, msk->first);
 +		mptcp_rcv_space_init(msk, msk->first);
 +		mptcp_propagate_sndbuf(newsk, msk->first);
 +
++=======
++>>>>>>> 3a236aef280e (mptcp: refactor passive socket initialization)
  		/* set ssk->sk_socket of accept()ed flows to mptcp socket.
  		 * This is needed so NOSPACE flag can be set from tcp stack.
  		 */
diff --cc net/mptcp/subflow.c
index f7dbf4057ccc,a631a5e6fc7b..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -698,14 -852,25 +707,32 @@@ create_child
  			ctx->conn = new_msk;
  			new_msk = NULL;
  
++<<<<<<< HEAD
 +			/* with OoO packets we can reach here without ingress
 +			 * mpc option
 +			 */
 +			if (mp_opt.mp_capable)
++=======
+ 			/* set msk addresses early to ensure mptcp_pm_get_local_id()
+ 			 * uses the correct data
+ 			 */
+ 			mptcp_copy_inaddrs(ctx->conn, child);
+ 			mptcp_propagate_sndbuf(ctx->conn, child);
+ 
+ 			mptcp_rcv_space_init(owner, child);
+ 			list_add(&ctx->node, &owner->conn_list);
+ 			sock_hold(child);
+ 
+ 			/* with OoO packets we can reach here without ingress
+ 			 * mpc option
+ 			 */
+ 			if (mp_opt.suboptions & OPTION_MPTCP_MPC_ACK) {
++>>>>>>> 3a236aef280e (mptcp: refactor passive socket initialization)
  				mptcp_subflow_fully_established(ctx, &mp_opt);
+ 				mptcp_pm_fully_established(owner, child, GFP_ATOMIC);
+ 				ctx->pm_notified = 1;
+ 			}
  		} else if (ctx->mp_join) {
- 			struct mptcp_sock *owner;
- 
  			owner = subflow_req->msk;
  			if (!owner) {
  				subflow_add_reset_reason(skb, MPTCP_RST_EPROHIBIT);
* Unmerged path net/mptcp/protocol.c
* Unmerged path net/mptcp/subflow.c
