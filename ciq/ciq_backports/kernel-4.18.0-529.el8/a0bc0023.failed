ACPI: x86: s2idle: Add module parameter to prefer Microsoft GUID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Mario Limonciello <mario.limonciello@amd.com>
commit a0bc002393d42ab7d895b0e82e730ce7622bdbff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/a0bc0023.failed

OEMs have made some mistakes in the past for the AMD GUID support
and not populated the method properly.  To add an escape hatch for
this problem introduce a module parameter that can force using
the Microsoft GUID.

This is intentionally introduced to both Intel and AMD codepaths
to allow using the parameter as a debugging tactic on either.

	Reviewed-by: Philipp Zabel <philipp.zabel@gmail.com>
	Tested-by: Philipp Zabel <philipp.zabel@gmail.com> # GA402RJ
	Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a0bc002393d42ab7d895b0e82e730ce7622bdbff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/x86/s2idle.c
diff --cc drivers/acpi/x86/s2idle.c
index 474aa46f82f6,725d2a6c87ed..000000000000
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@@ -369,34 -406,29 +373,46 @@@ static int lps0_device_attach(struct ac
  	if (lps0_device_handle)
  		return 0;
  
+ 	lps0_dsm_func_mask_microsoft = validate_dsm(adev->handle,
+ 						    ACPI_LPS0_DSM_UUID_MICROSOFT, 0,
+ 						    &lps0_dsm_guid_microsoft);
  	if (acpi_s2idle_vendor_amd()) {
 -		static const struct acpi_device_id *dev_id;
 -		const struct amd_lps0_hid_device_data *data;
 -
 -		for (dev_id = &amd_hid_ids[0]; dev_id->id[0]; dev_id++)
 -			if (acpi_dev_hid_uid_match(adev, dev_id->id, NULL))
 -				break;
 -		if (dev_id)
 -			data = (const struct amd_lps0_hid_device_data *) dev_id->driver_data;
 -		else
 -			data = &amd_rembrandt;
 -		rev_id = data->rev_id;
 +		/* AMD0004, AMD0005, AMDI0005:
 +		 * - Should use rev_id 0x0
 +		 * - function mask > 0x3: Should use AMD method, but has off by one bug
 +		 * - function mask = 0x3: Should use Microsoft method
 +		 * AMDI0006:
 +		 * - should use rev_id 0x0
 +		 * - function mask = 0x3: Should use Microsoft method
 +		 * AMDI0007:
 +		 * - Should use rev_id 0x2
 +		 * - Should only use AMD method
 +		 */
 +		const char *hid = acpi_device_hid(adev);
 +		rev_id = strcmp(hid, "AMDI0007") ? 0 : 2;
  		lps0_dsm_func_mask = validate_dsm(adev->handle,
  					ACPI_LPS0_DSM_UUID_AMD, rev_id, &lps0_dsm_guid);
++<<<<<<< HEAD
 +		lps0_dsm_func_mask_microsoft = validate_dsm(adev->handle,
 +					ACPI_LPS0_DSM_UUID_MICROSOFT, 0,
 +					&lps0_dsm_guid_microsoft);
 +		if (lps0_dsm_func_mask > 0x3 && (!strcmp(hid, "AMD0004") ||
 +						 !strcmp(hid, "AMD0005") ||
 +						 !strcmp(hid, "AMDI0005"))) {
 +			lps0_dsm_func_mask = (lps0_dsm_func_mask << 1) | 0x1;
 +			acpi_handle_debug(adev->handle, "_DSM UUID %s: Adjusted function mask: 0x%x\n",
 +					  ACPI_LPS0_DSM_UUID_AMD, lps0_dsm_func_mask);
 +		} else if (lps0_dsm_func_mask_microsoft > 0 &&
 +				(!strcmp(hid, "AMDI0007") ||
 +				 !strcmp(hid, "AMDI0008"))) {
++=======
+ 		if (lps0_dsm_func_mask > 0x3 && data->check_off_by_one) {
+ 			lps0_dsm_func_mask = (lps0_dsm_func_mask << 1) | 0x1;
+ 			acpi_handle_debug(adev->handle, "_DSM UUID %s: Adjusted function mask: 0x%x\n",
+ 					  ACPI_LPS0_DSM_UUID_AMD, lps0_dsm_func_mask);
+ 		} else if (lps0_dsm_func_mask_microsoft > 0 && data->prefer_amd_guid &&
+ 				!prefer_microsoft_dsm_guid) {
++>>>>>>> a0bc002393d4 (ACPI: x86: s2idle: Add module parameter to prefer Microsoft GUID)
  			lps0_dsm_func_mask_microsoft = -EINVAL;
  			acpi_handle_debug(adev->handle, "_DSM Using AMD method\n");
  		}
* Unmerged path drivers/acpi/x86/s2idle.c
