drm/vmwgfx: Fix possible invalid drm gem put calls

jira LE-1907
cve CVE-2023-5633
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Zack Rusin <zackr@vmware.com>
commit f9e96bf1905479f18e83a3a4c314a8dfa56ede2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/f9e96bf1.failed

vmw_bo_unreference sets the input buffer to null on exit, resulting in
null ptr deref's on the subsequent drm gem put calls.

This went unnoticed because only very old userspace would be exercising
those paths but it wouldn't be hard to hit on old distros with brand
new kernels.

Introduce a new function that abstracts unrefing of user bo's to make
the code cleaner and more explicit.

	Signed-off-by: Zack Rusin <zackr@vmware.com>
	Reported-by: Ian Forbes <iforbes@vmware.com>
Fixes: 9ef8d83e8e25 ("drm/vmwgfx: Do not drop the reference to the handle too soon")
	Cc: <stable@vger.kernel.org> # v6.4+
	Reviewed-by: Maaz Mombasawala<mombasawalam@vmware.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20230818041301.407636-1-zack@kde.org
(cherry picked from commit f9e96bf1905479f18e83a3a4c314a8dfa56ede2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_bo.h
#	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
index 5c5d3efb662a,c43853597776..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
@@@ -580,10 -497,9 +580,16 @@@ static int vmw_user_bo_synccpu_release(
  		if (!(flags & drm_vmw_synccpu_allow_cs)) {
  			atomic_dec(&vmw_bo->cpu_writers);
  		}
++<<<<<<< HEAD
 +		ttm_bo_put(&vmw_bo->base);
 +	}
 +
 +	drm_gem_object_put(&vmw_bo->base.base);
++=======
+ 		vmw_user_bo_unref(vmw_bo);
+ 	}
+ 
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  	return ret;
  }
  
@@@ -623,8 -539,7 +629,12 @@@ int vmw_user_bo_synccpu_ioctl(struct dr
  			return ret;
  
  		ret = vmw_user_bo_synccpu_grab(vbo, arg->flags);
++<<<<<<< HEAD
 +		vmw_bo_unreference(&vbo);
 +		drm_gem_object_put(&vbo->base.base);
++=======
+ 		vmw_user_bo_unref(vbo);
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  		if (unlikely(ret != 0)) {
  			if (ret == -ERESTARTSYS || ret == -EBUSY)
  				return -EBUSY;
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
index 4cf54bea4fb6,98e0723ca6f5..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
@@@ -1158,9 -1162,9 +1158,15 @@@ static int vmw_translate_mob_ptr(struc
  		drm_dbg(&dev_priv->drm, "Could not find or use MOB buffer.\n");
  		return PTR_ERR(vmw_bo);
  	}
++<<<<<<< HEAD
 +	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo, true, false);
 +	ttm_bo_put(&vmw_bo->base);
 +	drm_gem_object_put(&vmw_bo->base.base);
++=======
+ 	vmw_bo_placement_set(vmw_bo, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB);
+ 	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo);
+ 	vmw_user_bo_unref(vmw_bo);
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  	if (unlikely(ret != 0))
  		return ret;
  
@@@ -1213,9 -1217,10 +1219,16 @@@ static int vmw_translate_guest_ptr(stru
  		drm_dbg(&dev_priv->drm, "Could not find or use GMR region.\n");
  		return PTR_ERR(vmw_bo);
  	}
++<<<<<<< HEAD
 +	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo, false, false);
 +	ttm_bo_put(&vmw_bo->base);
 +	drm_gem_object_put(&vmw_bo->base.base);
++=======
+ 	vmw_bo_placement_set(vmw_bo, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,
+ 			     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);
+ 	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo);
+ 	vmw_user_bo_unref(vmw_bo);
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  	if (unlikely(ret != 0))
  		return ret;
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index 04b5a37fdcd5,1489ad73c103..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@@ -1755,10 -1665,8 +1755,15 @@@ static struct drm_framebuffer *vmw_kms_
  
  err_out:
  	/* vmw_user_lookup_handle takes one ref so does new_fb */
++<<<<<<< HEAD
 +	if (bo) {
 +		vmw_bo_unreference(&bo);
 +		drm_gem_object_put(&bo->base.base);
 +	}
++=======
+ 	if (bo)
+ 		vmw_user_bo_unref(bo);
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  	if (surface)
  		vmw_surface_unreference(&surface);
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
index bb0e480c8e92,fb85f244c3d0..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
@@@ -451,8 -451,7 +451,12 @@@ int vmw_overlay_ioctl(struct drm_devic
  
  	ret = vmw_overlay_update_stream(dev_priv, buf, arg, true);
  
++<<<<<<< HEAD
 +	vmw_bo_unreference(&buf);
 +	drm_gem_object_put(&buf->base.base);
++=======
+ 	vmw_user_bo_unref(buf);
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  
  out_unlock:
  	mutex_unlock(&overlay->mutex);
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
index 51e83dfa1cac,1e81ff2422cf..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
@@@ -806,8 -809,7 +806,12 @@@ static int vmw_shader_define(struct drm
  				    shader_type, num_input_sig,
  				    num_output_sig, tfile, shader_handle);
  out_bad_arg:
++<<<<<<< HEAD
 +	vmw_bo_unreference(&buffer);
 +	drm_gem_object_put(&buffer->base.base);
++=======
+ 	vmw_user_bo_unref(buffer);
++>>>>>>> f9e96bf19054 (drm/vmwgfx: Fix possible invalid drm gem put calls)
  	return ret;
  }
  
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_bo.h
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_bo.h
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
