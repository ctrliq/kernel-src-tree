ACPI: bus: Rework system-level device notification handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit c56610a869bce03490faf4f157076370c71b8ae3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/c56610a8.failed

For ACPI drivers that provide a ->notify() callback and set
ACPI_DRIVER_ALL_NOTIFY_EVENTS in their flags, that callback can be
invoked while either the ->add() or the ->remove() callback is running
without any synchronization at the bus type level which is counter to
the common-sense expectation that notification handling should only be
enabled when the driver is actually bound to the device.  As a result,
if the driver is not careful enough, it's ->notify() callback may crash
when it is invoked too early or too late [1].

This issue has been amplified by commit d6fb6ee1820c ("ACPI: bus: Drop
driver member of struct acpi_device") that made acpi_bus_notify() check
for the presence of the driver and its ->notify() callback directly
instead of using an extra driver pointer that was only set and cleared
by the bus type code, but it was present before that commit although
it was harder to reproduce then.

It can be addressed by using the observation that
acpi_device_install_notify_handler() can be modified to install the
handler for all types of events when ACPI_DRIVER_ALL_NOTIFY_EVENTS is
set in the driver flags, in which case acpi_bus_notify() will not need
to invoke the driver's ->notify() callback any more and that callback
will only be invoked after acpi_device_install_notify_handler() has run
and before acpi_device_remove_notify_handler() runs, which implies the
correct ordering with respect to the other ACPI driver callbacks.

Modify the code accordingly and while at it, drop two redundant local
variables from acpi_bus_notify() and turn its description comment into
a proper kerneldoc one.

Fixes: d6fb6ee1820c ("ACPI: bus: Drop driver member of struct acpi_device")
Link: https://lore.kernel.org/linux-acpi/9f6cba7a8a57e5a687c934e8e406e28c.squirrel@mail.panix.com # [1]
	Reported-by: Pierre Asselin <pa@panix.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Pierre Asselin <pa@panix.com>
(cherry picked from commit c56610a869bce03490faf4f157076370c71b8ae3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/bus.c
diff --cc drivers/acpi/bus.c
index 840d536285fd,a96da65057b1..000000000000
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@@ -523,33 -509,17 +521,37 @@@ static void acpi_bus_notify(acpi_handl
  
  	default:
  		acpi_handle_debug(handle, "Unknown event type 0x%x\n", type);
++<<<<<<< HEAD
 +		break;
 +	}
 +
 +	adev = acpi_bus_get_acpi_device(handle);
 +	if (!adev)
 +		goto err;
 +
 +	if (adev->dev.driver) {
 +		struct acpi_driver *driver = to_acpi_driver(adev->dev.driver);
 +
 +		if (driver && driver->ops.notify &&
 +		    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
 +			driver->ops.notify(adev, type);
 +	}
 +
 +	if (!hotplug_event) {
 +		acpi_bus_put_acpi_device(adev);
++=======
++>>>>>>> c56610a869bc (ACPI: bus: Rework system-level device notification handling)
  		return;
  	}
  
- 	if (ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
+ 	adev = acpi_get_acpi_dev(handle);
+ 
+ 	if (adev && ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
  		return;
  
 -	acpi_put_acpi_dev(adev);
 +	acpi_bus_put_acpi_device(adev);
  
-  err:
- 	acpi_evaluate_ost(handle, type, ost_code, NULL);
+ 	acpi_evaluate_ost(handle, type, ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
  }
  
  static void acpi_notify_device(acpi_handle handle, u32 event, void *data)
* Unmerged path drivers/acpi/bus.c
