ACPI: scan: Rearrange initialization of ACPI device objects

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 5c5e1237032aaa39107e2d0bb8e6cb84b3c41161
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/5c5e1237.failed

The initialization of ACPI device objects is split between
acpi_init_device_object() and __acpi_device_add() that initializes
the dev field in struct acpi_device.  The "release" function pointer
is passed to __acpi_device_add() for this reason.

However, that split is artificial and all of the initialization can
be carried out by acpi_init_device_object(), so rearrange the code
to that end.  In particular, make acpi_init_device_object() take the
"release" pointer as an argument, along with the "type" which is
related to it, instead of __acpi_device_add().

No intentional functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Punit Agrawal <punit.agrawal@bytedance.com>
(cherry picked from commit 5c5e1237032aaa39107e2d0bb8e6cb84b3c41161)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index c33e86308828,75a32f2d0f33..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1710,7 -1778,12 +1706,16 @@@ void acpi_init_device_object(struct acp
  	INIT_LIST_HEAD(&device->pnp.ids);
  	device->device_type = type;
  	device->handle = handle;
++<<<<<<< HEAD
 +	device->parent = acpi_bus_get_parent(handle);
++=======
+ 	if (parent) {
+ 		device->parent = parent;
+ 		device->dev.parent = &parent->dev;
+ 	}
+ 	device->dev.release = release;
+ 	device->dev.bus = &acpi_bus_type;
++>>>>>>> 5c5e1237032a (ACPI: scan: Rearrange initialization of ACPI device objects)
  	fwnode_init(&device->fwnode, &acpi_device_fwnode_ops);
  	acpi_set_device_status(device, ACPI_STA_DEFAULT);
  	acpi_device_get_busid(device);
diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index 4520818e1184..c0fd705b7b85 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -111,10 +111,9 @@ struct acpi_device_bus_id {
 	struct list_head node;
 };
 
-int acpi_device_add(struct acpi_device *device,
-		    void (*release)(struct device *));
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
-			     int type);
+			     int type, void (*release)(struct device *));
+int acpi_device_add(struct acpi_device *device);
 int acpi_device_setup_files(struct acpi_device *dev);
 void acpi_device_remove_files(struct acpi_device *dev);
 void acpi_device_add_finalize(struct acpi_device *device);
diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index e911d4afa875..350f1a0efd02 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -962,7 +962,8 @@ struct acpi_device *acpi_add_power_resource(acpi_handle handle)
 		return NULL;
 
 	device = &resource->device;
-	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER);
+	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
+				acpi_release_power_resource);
 	mutex_init(&resource->resource_lock);
 	INIT_LIST_HEAD(&resource->list_node);
 	INIT_LIST_HEAD(&resource->dependents);
@@ -987,7 +988,7 @@ struct acpi_device *acpi_add_power_resource(acpi_handle handle)
 	       acpi_device_bid(device));
 
 	device->flags.match_driver = true;
-	result = acpi_device_add(device, acpi_release_power_resource);
+	result = acpi_device_add(device);
 	if (result)
 		goto err;
 
* Unmerged path drivers/acpi/scan.c
