mptcp: stops worker on unaccepted sockets at listener close

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 2a6a870e44dd88f1a6a2893c65ef756a9edfb4c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/2a6a870e.failed

This is a partial revert of the blamed commit, with a relevant
change: mptcp_subflow_queue_clean() now just change the msk
socket status and stop the worker, so that the UaF issue addressed
by the blamed commit is not re-introduced.

The above prevents the mptcp worker from running concurrently with
inet_csk_listen_stop(), as such race would trigger a warning, as
reported by Christoph:

RSP: 002b:00007f784fe09cd8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
WARNING: CPU: 0 PID: 25807 at net/ipv4/inet_connection_sock.c:1387 inet_csk_listen_stop+0x664/0x870 net/ipv4/inet_connection_sock.c:1387
RAX: ffffffffffffffda RBX: 00000000006bc050 RCX: 00007f7850afd6a9
RDX: 0000000000000000 RSI: 0000000020000340 RDI: 0000000000000004
Modules linked in:
RBP: 0000000000000002 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00000000006bc05c
R13: fffffffffffffea8 R14: 00000000006bc050 R15: 000000000001fe40

 </TASK>
CPU: 0 PID: 25807 Comm: syz-executor.7 Not tainted 6.2.0-g778e54711659 #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014
RIP: 0010:inet_csk_listen_stop+0x664/0x870 net/ipv4/inet_connection_sock.c:1387
RAX: 0000000000000000 RBX: ffff888100dfbd40 RCX: 0000000000000000
RDX: ffff8881363aab80 RSI: ffffffff81c494f4 RDI: 0000000000000005
RBP: ffff888126dad080 R08: 0000000000000005 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000000 R12: ffff888100dfe040
R13: 0000000000000001 R14: 0000000000000000 R15: ffff888100dfbdd8
FS:  00007f7850a2c800(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000001b32d26000 CR3: 000000012fdd8006 CR4: 0000000000770ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 <TASK>
 __tcp_close+0x5b2/0x620 net/ipv4/tcp.c:2875
 __mptcp_close_ssk+0x145/0x3d0 net/mptcp/protocol.c:2427
 mptcp_destroy_common+0x8a/0x1c0 net/mptcp/protocol.c:3277
 mptcp_destroy+0x41/0x60 net/mptcp/protocol.c:3304
 __mptcp_destroy_sock+0x56/0x140 net/mptcp/protocol.c:2965
 __mptcp_close+0x38f/0x4a0 net/mptcp/protocol.c:3057
 mptcp_close+0x24/0xe0 net/mptcp/protocol.c:3072
 inet_release+0x53/0xa0 net/ipv4/af_inet.c:429
 __sock_release+0x4e/0xf0 net/socket.c:651
 sock_close+0x15/0x20 net/socket.c:1393
 __fput+0xff/0x420 fs/file_table.c:321
 task_work_run+0x8b/0xe0 kernel/task_work.c:179
 resume_user_mode_work include/linux/resume_user_mode.h:49 [inline]
 exit_to_user_mode_loop kernel/entry/common.c:171 [inline]
 exit_to_user_mode_prepare+0x113/0x120 kernel/entry/common.c:203
 __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]
 syscall_exit_to_user_mode+0x1d/0x40 kernel/entry/common.c:296
 do_syscall_64+0x46/0x90 arch/x86/entry/common.c:86
 entry_SYSCALL_64_after_hwframe+0x72/0xdc
RIP: 0033:0x7f7850af70dc
RAX: 0000000000000000 RBX: 0000000000000004 RCX: 00007f7850af70dc
RDX: 00007f7850a2c800 RSI: 0000000000000002 RDI: 0000000000000003
RBP: 00000000006bd980 R08: 0000000000000000 R09: 00000000000018a0
R10: 00000000316338a4 R11: 0000000000000293 R12: 0000000000211e31
R13: 00000000006bc05c R14: 00007f785062c000 R15: 0000000000211af0

Fixes: 0a3f4f1f9c27 ("mptcp: fix UaF in listener shutdown")
	Cc: stable@vger.kernel.org
	Reported-by: Christoph Paasch <cpaasch@apple.com>
Link: https://github.com/multipath-tcp/mptcp_net-next/issues/371
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2a6a870e44dd88f1a6a2893c65ef756a9edfb4c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
#	net/mptcp/subflow.c
diff --cc net/mptcp/protocol.c
index 06fc28bcb1ca,5181fb91595b..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -2263,7 -2369,9 +2263,13 @@@ static void __mptcp_close_ssk(struct so
  			tcp_set_state(ssk, TCP_CLOSE);
  			mptcp_subflow_queue_clean(sk, ssk);
  			inet_csk_listen_stop(ssk);
++<<<<<<< HEAD
 +		}
++=======
+ 			mptcp_event_pm_listener(ssk, MPTCP_EVENT_LISTENER_CLOSED);
+ 		}
+ 
++>>>>>>> 2a6a870e44dd (mptcp: stops worker on unaccepted sockets at listener close)
  		__tcp_close(ssk, 0);
  
  		/* close acquired an extra ref */
diff --cc net/mptcp/subflow.c
index 7d8558c6c894,bf5e5c72b5ee..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -1515,7 -1830,6 +1515,10 @@@ void mptcp_subflow_queue_clean(struct s
  	for (req = queue->rskq_accept_head; req; req = req->dl_next) {
  		struct mptcp_subflow_context *subflow;
  		struct sock *ssk = req->sk;
++<<<<<<< HEAD
 +		struct mptcp_sock *msk;
++=======
++>>>>>>> 2a6a870e44dd (mptcp: stops worker on unaccepted sockets at listener close)
  
  		if (!sk_is_mptcp(ssk))
  			continue;
@@@ -1529,6 -1843,7 +1532,10 @@@
  		if (msk->dl_next || msk == head)
  			continue;
  
++<<<<<<< HEAD
++=======
+ 		sock_hold(subflow->conn);
++>>>>>>> 2a6a870e44dd (mptcp: stops worker on unaccepted sockets at listener close)
  		msk->dl_next = head;
  		head = msk;
  	}
@@@ -1543,33 -1858,32 +1550,62 @@@
  
  	for (msk = head; msk; msk = next) {
  		struct sock *sk = (struct sock *)msk;
++<<<<<<< HEAD
 +		bool do_cancel_work;
 +
 +		sock_hold(sk);
 +		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 +		next = msk->dl_next;
 +		msk->first = NULL;
 +		msk->dl_next = NULL;
 +
 +		do_cancel_work = __mptcp_close(sk, 0);
 +		release_sock(sk);
 +		if (do_cancel_work) {
 +			/* lockdep will report a false positive ABBA deadlock
 +			 * between cancel_work_sync and the listener socket.
 +			 * The involved locks belong to different sockets WRT
 +			 * the existing AB chain.
 +			 * Using a per socket key is problematic as key
 +			 * deregistration requires process context and must be
 +			 * performed at socket disposal time, in atomic
 +			 * context.
 +			 * Just tell lockdep to consider the listener socket
 +			 * released here.
 +			 */
 +			mutex_release(&listener_sk->sk_lock.dep_map, _RET_IP_);
 +			mptcp_cancel_work(sk);
 +			mutex_acquire(&listener_sk->sk_lock.dep_map,
 +				      SINGLE_DEPTH_NESTING, 0, _RET_IP_);
 +		}
++=======
+ 
+ 		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
+ 		next = msk->dl_next;
+ 		msk->dl_next = NULL;
+ 
+ 		/* prevent the stack from later re-schedule the worker for
+ 		 * this socket
+ 		 */
+ 		inet_sk_state_store(sk, TCP_CLOSE);
+ 		release_sock(sk);
+ 
+ 		/* lockdep will report a false positive ABBA deadlock
+ 		 * between cancel_work_sync and the listener socket.
+ 		 * The involved locks belong to different sockets WRT
+ 		 * the existing AB chain.
+ 		 * Using a per socket key is problematic as key
+ 		 * deregistration requires process context and must be
+ 		 * performed at socket disposal time, in atomic
+ 		 * context.
+ 		 * Just tell lockdep to consider the listener socket
+ 		 * released here.
+ 		 */
+ 		mutex_release(&listener_sk->sk_lock.dep_map, _RET_IP_);
+ 		mptcp_cancel_work(sk);
+ 		mutex_acquire(&listener_sk->sk_lock.dep_map, 0, 0, _RET_IP_);
+ 
++>>>>>>> 2a6a870e44dd (mptcp: stops worker on unaccepted sockets at listener close)
  		sock_put(sk);
  	}
  
* Unmerged path net/mptcp/protocol.c
* Unmerged path net/mptcp/subflow.c
