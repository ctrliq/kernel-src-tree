ACPI: Implement a generic FFH Opregion handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Sudeep Holla <sudeep.holla@arm.com>
commit e81c782c16844dc758a784899c2fe5260386211b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/e81c782c.failed

This registers the FFH OpRegion handler before ACPI tables are
loaded. The platform support for the same is checked via Platform-Wide
OSPM Capabilities(OSC) before registering the OpRegion handler.

It relies on the special context data passed to offset and the length.
However the interpretation of the values is platform/architecture
specific. This generic handler just passed all the information to
the platform/architecture specific callback. It also implements the
default callbacks which return as not supported.

	Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e81c782c16844dc758a784899c2fe5260386211b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/Kconfig
#	drivers/acpi/Makefile
diff --cc drivers/acpi/Kconfig
index e59ff4845a36,06508674a30b..000000000000
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@@ -565,8 -547,38 +565,38 @@@ config ACPI_PPT
  	bool
  endif
  
++<<<<<<< HEAD
++=======
+ config ACPI_PCC
+ 	bool "ACPI PCC Address Space"
+ 	depends on PCC
+ 	default y
+ 	help
+ 	  The PCC Address Space also referred as PCC Operation Region pertains
+ 	  to the region of PCC subspace that succeeds the PCC signature.
+ 
+ 	  The PCC Operation Region works in conjunction with the PCC Table
+ 	  (Platform Communications Channel Table). PCC subspaces that are
+ 	  marked for use as PCC Operation Regions must not be used as PCC
+ 	  subspaces for the standard ACPI features such as CPPC, RASF, PDTT and
+ 	  MPST. These standard features must always use the PCC Table instead.
+ 
+ 	  Enable this feature if you want to set up and install the PCC Address
+ 	  Space handler to handle PCC OpRegion in the firmware.
+ 
+ config ACPI_FFH
+ 	bool "ACPI FFH Address Space"
+ 	default n
+ 	help
+ 	  The FFH(Fixed Function Hardware) Address Space also referred as FFH
+ 	  Operation Region allows to define platform specific opregion.
+ 
+ 	  Enable this feature if you want to set up and install the FFH Address
+ 	  Space handler to handle FFH OpRegion in the firmware.
+ 
++>>>>>>> e81c782c1684 (ACPI: Implement a generic FFH Opregion handler)
  source "drivers/acpi/pmic/Kconfig"
  
 -config ACPI_VIOT
 -	bool
 -
  config ACPI_PRMT
  	bool "Platform Runtime Mechanism Support"
  	depends on EFI && (X86_64 || ARM64)
diff --cc drivers/acpi/Makefile
index 7d8130237f92,feb36c0b9446..000000000000
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@@ -68,6 -67,8 +68,11 @@@ acpi-$(CONFIG_ACPI_LPIT)	+= acpi_lpit.
  acpi-$(CONFIG_ACPI_GENERIC_GSI) += irq.o
  acpi-$(CONFIG_ACPI_WATCHDOG)	+= acpi_watchdog.o
  acpi-$(CONFIG_ACPI_PRMT)	+= prmt.o
++<<<<<<< HEAD
++=======
+ acpi-$(CONFIG_ACPI_PCC)		+= acpi_pcc.o
+ acpi-$(CONFIG_ACPI_FFH)		+= acpi_ffh.o
++>>>>>>> e81c782c1684 (ACPI: Implement a generic FFH Opregion handler)
  
  # Address translation
  acpi-$(CONFIG_ACPI_ADXL)	+= acpi_adxl.o
* Unmerged path drivers/acpi/Kconfig
* Unmerged path drivers/acpi/Makefile
diff --git a/drivers/acpi/acpi_ffh.c b/drivers/acpi/acpi_ffh.c
new file mode 100644
index 000000000000..19aff808bbb8
--- /dev/null
+++ b/drivers/acpi/acpi_ffh.c
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Author: Sudeep Holla <sudeep.holla@arm.com>
+ * Copyright 2022 Arm Limited
+ */
+#include <linux/kernel.h>
+#include <linux/acpi.h>
+#include <linux/completion.h>
+#include <linux/idr.h>
+#include <linux/io.h>
+
+#include <linux/arm-smccc.h>
+
+static struct acpi_ffh_info ffh_ctx;
+
+int __weak acpi_ffh_address_space_arch_setup(void *handler_ctxt,
+					     void **region_ctxt)
+{
+	return -EOPNOTSUPP;
+}
+
+int __weak acpi_ffh_address_space_arch_handler(acpi_integer *value,
+					       void *region_context)
+{
+	return -EOPNOTSUPP;
+}
+
+static acpi_status
+acpi_ffh_address_space_setup(acpi_handle region_handle, u32 function,
+			     void *handler_context,  void **region_context)
+{
+	return acpi_ffh_address_space_arch_setup(handler_context,
+						 region_context);
+}
+
+static acpi_status
+acpi_ffh_address_space_handler(u32 function, acpi_physical_address addr,
+			       u32 bits, acpi_integer *value,
+			       void *handler_context, void *region_context)
+{
+	return acpi_ffh_address_space_arch_handler(value, region_context);
+}
+
+void __init acpi_init_ffh(void)
+{
+	acpi_status status;
+
+	status = acpi_install_address_space_handler(ACPI_ROOT_OBJECT,
+						    ACPI_ADR_SPACE_FIXED_HARDWARE,
+						    &acpi_ffh_address_space_handler,
+						    &acpi_ffh_address_space_setup,
+						    &ffh_ctx);
+	if (ACPI_FAILURE(status))
+		pr_alert("OperationRegion handler could not be installed\n");
+}
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 840d536285fd..387140907527 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -315,6 +315,8 @@ EXPORT_SYMBOL_GPL(osc_sb_native_usb4_support_confirmed);
 
 bool osc_sb_cppc2_support_acked;
 
+bool osc_sb_ffh_opregion_support_confirmed;
+
 static u8 sb_uuid_str[] = "0811B06E-4A27-44F9-8D60-3CBBC22E7B48";
 static void acpi_bus_osc_negotiate_platform_control(void)
 {
@@ -398,6 +400,8 @@ static void acpi_bus_osc_negotiate_platform_control(void)
 			capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_NATIVE_USB4_SUPPORT;
 		osc_cpc_flexible_adr_space_confirmed =
 			capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_CPC_FLEXIBLE_ADR_SPACE;
+		osc_sb_ffh_opregion_support_confirmed =
+			capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_FFH_OPR_SUPPORT;
 	}
 
 	kfree(context.ret.pointer);
@@ -1419,6 +1423,8 @@ static int __init acpi_init(void)
 		disable_acpi();
 		return result;
 	}
+	if (osc_sb_ffh_opregion_support_confirmed)
+		acpi_init_ffh();
 
 	pci_mmcfg_late_init();
 	acpi_iort_init();
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index e15d22cbc926..531109b0b5d1 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -591,6 +591,7 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context);
 #define OSC_SB_CPC_FLEXIBLE_ADR_SPACE		0x00004000
 #define OSC_SB_NATIVE_USB4_SUPPORT		0x00040000
 #define OSC_SB_PRM_SUPPORT			0x00200000
+#define OSC_SB_FFH_OPR_SUPPORT			0x00400000
 
 extern bool osc_sb_apei_support_acked;
 extern bool osc_pc_lpi_support_confirmed;
@@ -1457,6 +1458,12 @@ static inline int find_acpi_cpu_cache_topology(unsigned int cpu, int level)
 }
 #endif
 
+#ifdef CONFIG_ACPI_FFH
+void acpi_init_ffh(void);
+#else
+static inline void acpi_init_ffh(void) { }
+#endif
+
 #ifdef CONFIG_ACPI
 extern void acpi_device_notify(struct device *dev);
 extern void acpi_device_notify_remove(struct device *dev);
