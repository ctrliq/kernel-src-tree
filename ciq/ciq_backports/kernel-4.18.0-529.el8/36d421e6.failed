drm/vmwgfx: Stop accessing buffer objects which failed init

jira LE-1907
cve CVE-2023-5633
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
Rebuild_CHGLOG: - Revert "drm/vmwgfx: Stop accessing buffer objects which failed init" (Jocelyn Falempe) [RHEL-14510] {CVE-2023-5633}
Rebuild_FUZZ: 92.91%
commit-author Zack Rusin <zackr@vmware.com>
commit 36d421e632e9a0e8375eaed0143551a34d81a7e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/36d421e6.failed

ttm_bo_init_reserved on failure puts the buffer object back which
causes it to be deleted, but kfree was still being called on the same
buffer in vmw_bo_create leading to a double free.

After the double free the vmw_gem_object_create_with_handle was
setting the gem function objects before checking the return status
of vmw_bo_create leading to null pointer access.

Fix the entire path by relaying on ttm_bo_init_reserved to delete the
buffer objects on failure and making sure the return status is checked
before setting the gem function objects on the buffer object.

	Signed-off-by: Zack Rusin <zackr@vmware.com>
Fixes: 8afa13a0583f ("drm/vmwgfx: Implement DRIVER_GEM")
	Reviewed-by: Maaz Mombasawala <mombasawalam@vmware.com>
	Reviewed-by: Martin Krastev <krastevm@vmware.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20230208180050.2093426-1-zack@kde.org
(cherry picked from commit 36d421e632e9a0e8375eaed0143551a34d81a7e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
index 5c5d3efb662a,7a00314882a3..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
@@@ -450,9 -419,7 +450,13 @@@ int vmw_bo_create(struct vmw_private *v
  	/*
  	 * vmw_bo_init will delete the *p_bo object if it fails
  	 */
++<<<<<<< HEAD
 +	ret = vmw_bo_init(vmw, *p_bo, size,
 +			  placement, interruptible, pin,
 +			  bo_free);
++=======
+ 	ret = vmw_bo_init(vmw, *p_bo, params, vmw_bo_free);
++>>>>>>> 36d421e632e9 (drm/vmwgfx: Stop accessing buffer objects which failed init)
  	if (unlikely(ret != 0))
  		goto out_error;
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
index a2933ff4240b,51bd1f8c5cc4..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
@@@ -145,21 -115,26 +145,33 @@@ int vmw_gem_object_create_with_handle(s
  				      struct drm_file *filp,
  				      uint32_t size,
  				      uint32_t *handle,
 -				      struct vmw_bo **p_vbo)
 +				      struct vmw_buffer_object **p_vbo)
  {
  	int ret;
 -	struct vmw_bo_params params = {
 -		.domain = (dev_priv->has_mob) ? VMW_BO_DOMAIN_SYS : VMW_BO_DOMAIN_VRAM,
 -		.busy_domain = VMW_BO_DOMAIN_SYS,
 -		.bo_type = ttm_bo_type_device,
 -		.size = size,
 -		.pin = false
 -	};
  
++<<<<<<< HEAD
 +	ret = vmw_bo_create(dev_priv, size,
 +			    (dev_priv->has_mob) ?
 +				    &vmw_sys_placement :
 +				    &vmw_vram_sys_placement,
 +			    true, false, &vmw_gem_destroy, p_vbo);
 +	if (ret != 0)
 +		goto out_no_bo;
 +
 +	(*p_vbo)->base.base.funcs = &vmw_gem_object_funcs;
 +
 +	ret = drm_gem_handle_create(filp, &(*p_vbo)->base.base, handle);
++=======
+ 	ret = vmw_bo_create(dev_priv, &params, p_vbo);
+ 	if (ret != 0)
+ 		goto out_no_bo;
+ 
+ 	(*p_vbo)->tbo.base.funcs = &vmw_gem_object_funcs;
+ 
+ 	ret = drm_gem_handle_create(filp, &(*p_vbo)->tbo.base, handle);
+ 	/* drop reference from allocate - handle holds it now */
+ 	drm_gem_object_put(&(*p_vbo)->tbo.base);
++>>>>>>> 36d421e632e9 (drm/vmwgfx: Stop accessing buffer objects which failed init)
  out_no_bo:
  	return ret;
  }
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
