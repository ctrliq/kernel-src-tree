ACPI: Drop parent field from struct acpi_device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 62fcb99bdf10fed34b4fe6e225489fe4be2d0536
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/62fcb99b.failed

The parent field in struct acpi_device is, in fact, redundant,
because the dev.parent field in it effectively points to the same
object and it is used by the driver core.

Accordingly, the parent field can be dropped from struct acpi_device
and for this purpose define acpi_dev_parent() to retrieve a parent
struct acpi_device pointer from the dev.parent field in struct
acpi_device.  Next, update all of the users of the parent field
in struct acpi_device to use acpi_dev_parent() instead of it and
drop it.

While at it, drop the ACPI_IS_ROOT_DEVICE() macro that is only used
in one place in a confusing way.

No intentional functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Mark Brown <broonie@kernel.org>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Acked-by: Wei Liu <wei.liu@kernel.org>
	Reviewed-by: Punit Agrawal <punit.agrawal@bytedance.com>
(cherry picked from commit 62fcb99bdf10fed34b4fe6e225489fe4be2d0536)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
#	drivers/thunderbolt/acpi.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/scan.c
index c33e86308828,f6b9ea937de1..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1710,7 -1763,11 +1708,13 @@@ void acpi_init_device_object(struct acp
  	INIT_LIST_HEAD(&device->pnp.ids);
  	device->device_type = type;
  	device->handle = handle;
++<<<<<<< HEAD
 +	device->parent = acpi_bus_get_parent(handle);
++=======
+ 	device->dev.parent = parent ? &parent->dev : NULL;
+ 	device->dev.release = release;
+ 	device->dev.bus = &acpi_bus_type;
++>>>>>>> 62fcb99bdf10 (ACPI: Drop parent field from struct acpi_device)
  	fwnode_init(&device->fwnode, &acpi_device_fwnode_ops);
  	acpi_set_device_status(device, ACPI_STA_DEFAULT);
  	acpi_device_get_busid(device);
@@@ -1800,11 -1860,11 +1804,19 @@@ static int acpi_add_single_object(struc
  
  	acpi_power_add_remove_device(device, true);
  	acpi_device_add_finalize(device);
++<<<<<<< HEAD
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Added %s [%s] parent %s\n",
 +		dev_name(&device->dev), (char *) buffer.pointer,
 +		device->parent ? dev_name(&device->parent->dev) : "(null)"));
 +	kfree(buffer.pointer);
++=======
+ 
+ 	acpi_handle_debug(handle, "Added as %s, parent %s\n",
+ 			  dev_name(&device->dev), device->dev.parent ?
+ 				dev_name(device->dev.parent) : "(null)");
+ 
++>>>>>>> 62fcb99bdf10 (ACPI: Drop parent field from struct acpi_device)
  	*child = device;
  	return 0;
  }
diff --cc drivers/thunderbolt/acpi.c
index 4d7439e40659,7a8adf5ad5a0..000000000000
--- a/drivers/thunderbolt/acpi.c
+++ b/drivers/thunderbolt/acpi.c
@@@ -36,13 -40,16 +36,21 @@@ static acpi_status tb_acpi_add_link(acp
  	 * We need to do this because the xHCI driver might not yet be
  	 * bound so the USB3 SuperSpeed ports are not yet created.
  	 */
++<<<<<<< HEAD
 +	do {
++=======
+ 	dev = acpi_get_first_physical_node(adev);
+ 	while (!dev) {
+ 		adev = acpi_dev_parent(adev);
+ 		if (!adev)
+ 			break;
++>>>>>>> 62fcb99bdf10 (ACPI: Drop parent field from struct acpi_device)
  		dev = acpi_get_first_physical_node(adev);
 -	}
 +		if (dev)
 +			break;
  
 -	if (!dev)
 -		goto out_put;
 +		adev = adev->parent;
 +	} while (adev);
  
  	/*
  	 * Check that the device is PCIe. This is because USB3
diff --cc include/acpi/acpi_bus.h
index 78ec67a99a97,6289020fdab8..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -374,9 -364,7 +374,12 @@@ struct acpi_device 
  	int device_type;
  	acpi_handle handle;		/* no handle for fixed hardware */
  	struct fwnode_handle fwnode;
++<<<<<<< HEAD
 +	struct acpi_device *parent;
 +	struct list_head children;
 +	struct list_head node;
++=======
++>>>>>>> 62fcb99bdf10 (ACPI: Drop parent field from struct acpi_device)
  	struct list_head wakeup_list;
  	struct list_head del_list;
  	struct acpi_device_status status;
@@@ -490,6 -484,9 +501,12 @@@ void acpi_initialize_hp_context(struct 
  
  /* acpi_device.dev.bus == &acpi_bus_type */
  extern struct bus_type acpi_bus_type;
++<<<<<<< HEAD
++=======
+ 
+ struct acpi_device *acpi_dev_parent(struct acpi_device *adev);
+ int acpi_bus_for_each_dev(int (*fn)(struct device *, void *), void *data);
++>>>>>>> 62fcb99bdf10 (ACPI: Drop parent field from struct acpi_device)
  int acpi_dev_for_each_child(struct acpi_device *adev,
  			    int (*fn)(struct acpi_device *, void *), void *data);
  int acpi_dev_for_each_child_reverse(struct acpi_device *adev,
diff --git a/drivers/acpi/acpi_amba.c b/drivers/acpi/acpi_amba.c
index c10f30247561..3f062b44489d 100644
--- a/drivers/acpi/acpi_amba.c
+++ b/drivers/acpi/acpi_amba.c
@@ -51,6 +51,7 @@ static void amba_register_dummy_clk(void)
 static int amba_handler_attach(struct acpi_device *adev,
 				const struct acpi_device_id *id)
 {
+	struct acpi_device *parent = acpi_dev_parent(adev);
 	struct amba_device *dev;
 	struct resource_entry *rentry;
 	struct list_head resource_list;
@@ -100,8 +101,8 @@ static int amba_handler_attach(struct acpi_device *adev,
 	 * attached to it, that physical device should be the parent of
 	 * the amba device we are about to create.
 	 */
-	if (adev->parent)
-		dev->dev.parent = acpi_get_first_physical_node(adev->parent);
+	if (parent)
+		dev->dev.parent = acpi_get_first_physical_node(parent);
 
 	ACPI_COMPANION_SET(&dev->dev, adev);
 
diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 7b59abf00f5c..c344ccacf722 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -81,7 +81,7 @@ static void acpi_platform_fill_resource(struct acpi_device *adev,
 	 * If the device has parent we need to take its resources into
 	 * account as well because this device might consume part of those.
 	 */
-	parent = acpi_get_first_physical_node(adev->parent);
+	parent = acpi_get_first_physical_node(acpi_dev_parent(adev));
 	if (parent && dev_is_pci(parent))
 		dest->parent = pci_find_resource(to_pci_dev(parent), dest);
 }
@@ -100,6 +100,7 @@ static void acpi_platform_fill_resource(struct acpi_device *adev,
 struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 					struct property_entry *properties)
 {
+	struct acpi_device *parent = acpi_dev_parent(adev);
 	struct platform_device *pdev = NULL;
 	struct platform_device_info pdevinfo;
 	struct resource_entry *rentry;
@@ -140,8 +141,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 	 * attached to it, that physical device should be the parent of the
 	 * platform device we are about to create.
 	 */
-	pdevinfo.parent = adev->parent ?
-		acpi_get_first_physical_node(adev->parent) : NULL;
+	pdevinfo.parent = parent ? acpi_get_first_physical_node(parent) : NULL;
 	pdevinfo.name = dev_name(&adev->dev);
 	pdevinfo.id = -1;
 	pdevinfo.res = resources;
diff --git a/drivers/acpi/acpi_video.c b/drivers/acpi/acpi_video.c
index 54116339673f..a7fcc5eb7cc5 100644
--- a/drivers/acpi/acpi_video.c
+++ b/drivers/acpi/acpi_video.c
@@ -2051,7 +2051,7 @@ static int acpi_video_bus_add(struct acpi_device *device)
 	acpi_status status;
 
 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE,
-				device->parent->handle, 1,
+				acpi_dev_parent(device)->handle, 1,
 				acpi_video_bus_match, NULL,
 				device, NULL);
 	if (status == AE_ALREADY_EXISTS) {
diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 71f17f5d6ab5..51fb3e67dbb1 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -83,6 +83,7 @@ static int acpi_dev_pm_explicit_get(struct acpi_device *device, int *state)
  */
 int acpi_device_get_power(struct acpi_device *device, int *state)
 {
+	struct acpi_device *parent = acpi_dev_parent(device);
 	int result = ACPI_STATE_UNKNOWN;
 	int error;
 
@@ -91,8 +92,7 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 
 	if (!device->flags.power_manageable) {
 		/* TBD: Non-recursive algorithm for walking up hierarchy. */
-		*state = device->parent ?
-			device->parent->power.state : ACPI_STATE_D0;
+		*state = parent ? parent->power.state : ACPI_STATE_D0;
 		goto out;
 	}
 
@@ -131,10 +131,10 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 	 * point, the fact that the device is in D0 implies that the parent has
 	 * to be in D0 too, except if ignore_parent is set.
 	 */
-	if (!device->power.flags.ignore_parent && device->parent
-	    && device->parent->power.state == ACPI_STATE_UNKNOWN
-	    && result == ACPI_STATE_D0)
-		device->parent->power.state = ACPI_STATE_D0;
+	if (!device->power.flags.ignore_parent && parent &&
+	    parent->power.state == ACPI_STATE_UNKNOWN &&
+	    result == ACPI_STATE_D0)
+		parent->power.state = ACPI_STATE_D0;
 
 	*state = result;
 
@@ -168,6 +168,7 @@ static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
  */
 int acpi_device_set_power(struct acpi_device *device, int state)
 {
+	struct acpi_device *parent = acpi_dev_parent(device);
 	int target_state = state;
 	int result = 0;
 
@@ -200,12 +201,12 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		return -ENODEV;
 	}
 
-	if (!device->power.flags.ignore_parent && device->parent &&
-	    state < device->parent->power.state) {
+	if (!device->power.flags.ignore_parent && parent &&
+	    state < parent->power.state) {
 		acpi_handle_debug(device->handle,
 				  "Cannot transition to %s for parent in %s\n",
 				  acpi_power_state_string(state),
-				  acpi_power_state_string(device->parent->power.state));
+				  acpi_power_state_string(parent->power.state));
 		return -ENODEV;
 	}
 
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index 1572a12fe1e5..5b21a8d92580 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -307,8 +307,10 @@ static void acpi_init_of_compatible(struct acpi_device *adev)
 		ret = acpi_dev_get_property(adev, "compatible",
 					    ACPI_TYPE_STRING, &of_compatible);
 		if (ret) {
-			if (adev->parent
-			    && adev->parent->flags.of_compatible_ok)
+			struct acpi_device *parent;
+
+			parent = acpi_dev_parent(adev);
+			if (parent && parent->flags.of_compatible_ok)
 				goto out;
 
 			return;
diff --git a/drivers/acpi/sbs.c b/drivers/acpi/sbs.c
index 1f09ac31f766..7a1ca3e70079 100644
--- a/drivers/acpi/sbs.c
+++ b/drivers/acpi/sbs.c
@@ -645,7 +645,7 @@ static int acpi_sbs_add(struct acpi_device *device)
 
 	mutex_init(&sbs->lock);
 
-	sbs->hc = acpi_driver_data(device->parent);
+	sbs->hc = acpi_driver_data(acpi_dev_parent(device));
 	sbs->device = device;
 	strcpy(acpi_device_name(device), ACPI_SBS_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_SBS_CLASS);
diff --git a/drivers/acpi/sbshc.c b/drivers/acpi/sbshc.c
index f057cb087467..c6f1438e417a 100644
--- a/drivers/acpi/sbshc.c
+++ b/drivers/acpi/sbshc.c
@@ -269,7 +269,7 @@ static int acpi_smbus_hc_add(struct acpi_device *device)
 	mutex_init(&hc->lock);
 	init_waitqueue_head(&hc->wait);
 
-	hc->ec = acpi_driver_data(device->parent);
+	hc->ec = acpi_driver_data(acpi_dev_parent(device));
 	hc->offset = (val >> 8) & 0xff;
 	hc->query_bit = val & 0xff;
 	device->driver_data = hc;
* Unmerged path drivers/acpi/scan.c
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 3813d713899a..37646c0eddb6 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -2510,7 +2510,8 @@ static int vmbus_acpi_add(struct acpi_device *device)
 	 * Some ancestor of the vmbus acpi device (Gen1 or Gen2
 	 * firmware) is the VMOD that has the mmio ranges. Get that.
 	 */
-	for (ancestor = device->parent; ancestor; ancestor = ancestor->parent) {
+	for (ancestor = acpi_dev_parent(device); ancestor;
+	     ancestor = acpi_dev_parent(ancestor)) {
 		result = acpi_walk_resources(ancestor->handle, METHOD_NAME__CRS,
 					     vmbus_walk_resources, NULL);
 
diff --git a/drivers/perf/arm_dsu_pmu.c b/drivers/perf/arm_dsu_pmu.c
index ccda4458a7aa..f5ae7594d0e7 100644
--- a/drivers/perf/arm_dsu_pmu.c
+++ b/drivers/perf/arm_dsu_pmu.c
@@ -642,6 +642,7 @@ static int dsu_pmu_dt_get_cpus(struct device *dev, cpumask_t *mask)
 static int dsu_pmu_acpi_get_cpus(struct device *dev, cpumask_t *mask)
 {
 #ifdef CONFIG_ACPI
+	struct acpi_device *parent_adev = acpi_dev_parent(ACPI_COMPANION(dev));
 	int cpu;
 
 	/*
@@ -656,8 +657,7 @@ static int dsu_pmu_acpi_get_cpus(struct device *dev, cpumask_t *mask)
 			continue;
 
 		acpi_dev = ACPI_COMPANION(cpu_dev);
-		if (acpi_dev &&
-			acpi_dev->parent == ACPI_COMPANION(dev)->parent)
+		if (acpi_dev && acpi_dev_parent(acpi_dev) == parent_adev)
 			cpumask_set_cpu(cpu, mask);
 	}
 #endif
diff --git a/drivers/perf/qcom_l3_pmu.c b/drivers/perf/qcom_l3_pmu.c
index ca4703da2721..04e3f32ee230 100644
--- a/drivers/perf/qcom_l3_pmu.c
+++ b/drivers/perf/qcom_l3_pmu.c
@@ -750,7 +750,8 @@ static int qcom_l3_cache_pmu_probe(struct platform_device *pdev)
 
 	l3pmu = devm_kzalloc(&pdev->dev, sizeof(*l3pmu), GFP_KERNEL);
 	name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "l3cache_%s_%s",
-		      acpi_dev->parent->pnp.unique_id, acpi_dev->pnp.unique_id);
+		      acpi_dev_parent(acpi_dev)->pnp.unique_id,
+		      acpi_dev->pnp.unique_id);
 	if (!l3pmu || !name)
 		return -ENOMEM;
 
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 17b569013205..5b9976157f7b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3808,7 +3808,7 @@ static int acpi_spi_notify(struct notifier_block *nb, unsigned long value,
 
 	switch (value) {
 	case ACPI_RECONFIG_DEVICE_ADD:
-		ctlr = acpi_spi_find_controller_by_adev(adev->parent);
+		ctlr = acpi_spi_find_controller_by_adev(acpi_dev_parent(adev));
 		if (!ctlr)
 			break;
 
* Unmerged path drivers/thunderbolt/acpi.c
* Unmerged path include/acpi/acpi_bus.h
