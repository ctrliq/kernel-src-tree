drm/vmwgfx: Do not drop the reference to the handle too soon

jira LE-1907
cve CVE-2023-5633
Rebuild_History Non-Buildable kernel-4.18.0-529.el8
Rebuild_CHGLOG: - Revert "drm/vmwgfx: Do not drop the reference to the handle too soon" (Jocelyn Falempe) [RHEL-14510] {CVE-2023-5633}
Rebuild_FUZZ: 93.02%
commit-author Zack Rusin <zackr@vmware.com>
commit 9ef8d83e8e25d5f1811b3a38eb1484f85f64296c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-529.el8/9ef8d83e.failed

v3: Fix vmw_user_bo_lookup which was also dropping the gem reference
before the kernel was done with buffer depending on userspace doing
the right thing. Same bug, different spot.

It is possible for userspace to predict the next buffer handle and
to destroy the buffer while it's still used by the kernel. Delay
dropping the internal reference on the buffers until kernel is done
with them.

Instead of immediately dropping the gem reference in vmw_user_bo_lookup
and vmw_gem_object_create_with_handle let the callers decide when they're
ready give the control back to userspace.

Also fixes the second usage of vmw_gem_object_create_with_handle in
vmwgfx_surface.c which wasn't grabbing an explicit reference
to the gem object which could have been destroyed by the userspace
on the owning surface at any point.

	Signed-off-by: Zack Rusin <zackr@vmware.com>
Fixes: 8afa13a0583f ("drm/vmwgfx: Implement DRIVER_GEM")
	Reviewed-by: Martin Krastev <krastevm@vmware.com>
	Reviewed-by: Maaz Mombasawala <mombasawalam@vmware.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20230211050514.2431155-1-zack@kde.org
(cherry picked from commit 9ef8d83e8e25d5f1811b3a38eb1484f85f64296c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
#	drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
index 5c5d3efb662a,82094c137855..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
@@@ -580,10 -497,10 +580,14 @@@ static int vmw_user_bo_synccpu_release(
  		if (!(flags & drm_vmw_synccpu_allow_cs)) {
  			atomic_dec(&vmw_bo->cpu_writers);
  		}
 -		ttm_bo_put(&vmw_bo->tbo);
 +		ttm_bo_put(&vmw_bo->base);
  	}
  
++<<<<<<< HEAD
 +	drm_gem_object_put(&vmw_bo->base.base);
++=======
+ 	drm_gem_object_put(&vmw_bo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  	return ret;
  }
  
@@@ -624,7 -541,7 +628,11 @@@ int vmw_user_bo_synccpu_ioctl(struct dr
  
  		ret = vmw_user_bo_synccpu_grab(vbo, arg->flags);
  		vmw_bo_unreference(&vbo);
++<<<<<<< HEAD
 +		drm_gem_object_put(&vbo->base.base);
++=======
+ 		drm_gem_object_put(&vbo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  		if (unlikely(ret != 0)) {
  			if (ret == -ERESTARTSYS || ret == -EBUSY)
  				return -EBUSY;
@@@ -697,8 -613,8 +705,13 @@@ int vmw_user_bo_lookup(struct drm_file 
  		return -ESRCH;
  	}
  
++<<<<<<< HEAD
 +	*out = gem_to_vmw_bo(gobj);
 +	ttm_bo_get(&(*out)->base);
++=======
+ 	*out = to_vmw_bo(gobj);
+ 	ttm_bo_get(&(*out)->tbo);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  
  	return 0;
  }
@@@ -780,7 -695,7 +793,11 @@@ int vmw_dumb_create(struct drm_file *fi
  						args->size, &args->handle,
  						&vbo);
  	/* drop reference from allocate - handle holds it now */
++<<<<<<< HEAD
 +	drm_gem_object_put(&vbo->base.base);
++=======
+ 	drm_gem_object_put(&vbo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  	return ret;
  }
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
index 0590bb22c73a,6b9aa2b4ef54..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
@@@ -1158,9 -1162,10 +1158,16 @@@ static int vmw_translate_mob_ptr(struc
  		drm_dbg(&dev_priv->drm, "Could not find or use MOB buffer.\n");
  		return PTR_ERR(vmw_bo);
  	}
++<<<<<<< HEAD
 +	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo, true, false);
 +	ttm_bo_put(&vmw_bo->base);
 +	drm_gem_object_put(&vmw_bo->base.base);
++=======
+ 	vmw_bo_placement_set(vmw_bo, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB);
+ 	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo);
+ 	ttm_bo_put(&vmw_bo->tbo);
+ 	drm_gem_object_put(&vmw_bo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  	if (unlikely(ret != 0))
  		return ret;
  
@@@ -1213,9 -1218,11 +1220,17 @@@ static int vmw_translate_guest_ptr(stru
  		drm_dbg(&dev_priv->drm, "Could not find or use GMR region.\n");
  		return PTR_ERR(vmw_bo);
  	}
++<<<<<<< HEAD
 +	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo, false, false);
 +	ttm_bo_put(&vmw_bo->base);
 +	drm_gem_object_put(&vmw_bo->base.base);
++=======
+ 	vmw_bo_placement_set(vmw_bo, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,
+ 			     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);
+ 	ret = vmw_validation_add_bo(sw_context->ctx, vmw_bo);
+ 	ttm_bo_put(&vmw_bo->tbo);
+ 	drm_gem_object_put(&vmw_bo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  	if (unlikely(ret != 0))
  		return ret;
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
index a2933ff4240b,d6baf73a6458..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
@@@ -157,9 -130,9 +157,13 @@@ int vmw_gem_object_create_with_handle(s
  	if (ret != 0)
  		goto out_no_bo;
  
 -	(*p_vbo)->tbo.base.funcs = &vmw_gem_object_funcs;
 +	(*p_vbo)->base.base.funcs = &vmw_gem_object_funcs;
  
++<<<<<<< HEAD
 +	ret = drm_gem_handle_create(filp, &(*p_vbo)->base.base, handle);
++=======
+ 	ret = drm_gem_handle_create(filp, &(*p_vbo)->tbo.base, handle);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  out_no_bo:
  	return ret;
  }
@@@ -187,7 -160,7 +191,11 @@@ int vmw_gem_object_create_ioctl(struct 
  	rep->cur_gmr_id = handle;
  	rep->cur_gmr_offset = 0;
  	/* drop reference from allocate - handle holds it now */
++<<<<<<< HEAD
 +	drm_gem_object_put(&vbo->base.base);
++=======
+ 	drm_gem_object_put(&vbo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  out_no_bo:
  	return ret;
  }
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index 04b5a37fdcd5,84d6380b9895..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@@ -1757,7 -1727,7 +1757,11 @@@ err_out
  	/* vmw_user_lookup_handle takes one ref so does new_fb */
  	if (bo) {
  		vmw_bo_unreference(&bo);
++<<<<<<< HEAD
 +		drm_gem_object_put(&bo->base.base);
++=======
+ 		drm_gem_object_put(&bo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  	}
  	if (surface)
  		vmw_surface_unreference(&surface);
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
index b5b311f2a91a,8d171d71cb8a..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
@@@ -458,7 -458,7 +458,11 @@@ int vmw_overlay_ioctl(struct drm_devic
  	ret = vmw_overlay_update_stream(dev_priv, buf, arg, true);
  
  	vmw_bo_unreference(&buf);
++<<<<<<< HEAD
 +	drm_gem_object_put(&buf->base.base);
++=======
+ 	drm_gem_object_put(&buf->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  
  out_unlock:
  	mutex_unlock(&overlay->mutex);
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
index 51e83dfa1cac,e7226db8b242..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
@@@ -807,7 -810,7 +807,11 @@@ static int vmw_shader_define(struct drm
  				    num_output_sig, tfile, shader_handle);
  out_bad_arg:
  	vmw_bo_unreference(&buffer);
++<<<<<<< HEAD
 +	drm_gem_object_put(&buffer->base.base);
++=======
+ 	drm_gem_object_put(&buffer->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  	return ret;
  }
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
index dcfb003841b3,5db403ee8261..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
@@@ -683,8 -686,8 +683,13 @@@ static void vmw_user_surface_base_relea
  	    container_of(base, struct vmw_user_surface, prime.base);
  	struct vmw_resource *res = &user_srf->srf.res;
  
++<<<<<<< HEAD
 +	if (res && res->backup)
 +		drm_gem_object_put(&res->backup->base.base);
++=======
+ 	if (res->guest_memory_bo)
+ 		drm_gem_object_put(&res->guest_memory_bo->tbo.base);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  
  	*p_base = NULL;
  	vmw_resource_unreference(&res);
@@@ -863,7 -866,7 +868,11 @@@ int vmw_surface_define_ioctl(struct drm
  			vmw_resource_unreference(&res);
  			goto out_unlock;
  		}
++<<<<<<< HEAD
 +		vmw_bo_reference(res->backup);
++=======
+ 		vmw_bo_reference(res->guest_memory_bo);
++>>>>>>> 9ef8d83e8e25 (drm/vmwgfx: Do not drop the reference to the handle too soon)
  		/*
  		 * We don't expose the handle to the userspace and surface
  		 * already holds a gem reference
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_gem.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_shader.c
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
