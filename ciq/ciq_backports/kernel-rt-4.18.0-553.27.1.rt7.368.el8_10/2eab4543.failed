ipv6: prevent possible NULL deref in fib6_nh_init()

jira LE-3201
cve CVE-2024-40961
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.27.1.rt7.368.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 2eab4543a2204092c3a7af81d7d6c506e59a03a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.27.1.rt7.368.el8_10/2eab4543.failed

syzbot reminds us that in6_dev_get() can return NULL.

fib6_nh_init()
    ip6_validate_gw(  &idev  )
        ip6_route_check_nh(  idev  )
            *idev = in6_dev_get(dev); // can be NULL

Oops: general protection fault, probably for non-canonical address 0xdffffc00000000bc: 0000 [#1] PREEMPT SMP KASAN PTI
KASAN: null-ptr-deref in range [0x00000000000005e0-0x00000000000005e7]
CPU: 0 PID: 11237 Comm: syz-executor.3 Not tainted 6.10.0-rc2-syzkaller-00249-gbe27b8965297 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/07/2024
 RIP: 0010:fib6_nh_init+0x640/0x2160 net/ipv6/route.c:3606
Code: 00 00 fc ff df 4c 8b 64 24 58 48 8b 44 24 28 4c 8b 74 24 30 48 89 c1 48 89 44 24 28 48 8d 98 e0 05 00 00 48 89 d8 48 c1 e8 03 <42> 0f b6 04 38 84 c0 0f 85 b3 17 00 00 8b 1b 31 ff 89 de e8 b8 8b
RSP: 0018:ffffc900032775a0 EFLAGS: 00010202
RAX: 00000000000000bc RBX: 00000000000005e0 RCX: 0000000000000000
RDX: 0000000000000010 RSI: ffffc90003277a54 RDI: ffff88802b3a08d8
RBP: ffffc900032778b0 R08: 00000000000002fc R09: 0000000000000000
R10: 00000000000002fc R11: 0000000000000000 R12: ffff88802b3a08b8
R13: 1ffff9200064eec8 R14: ffffc90003277a00 R15: dffffc0000000000
FS:  00007f940feb06c0(0000) GS:ffff8880b9400000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000000 CR3: 00000000245e8000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
  ip6_route_info_create+0x99e/0x12b0 net/ipv6/route.c:3809
  ip6_route_add+0x28/0x160 net/ipv6/route.c:3853
  ipv6_route_ioctl+0x588/0x870 net/ipv6/route.c:4483
  inet6_ioctl+0x21a/0x280 net/ipv6/af_inet6.c:579
  sock_do_ioctl+0x158/0x460 net/socket.c:1222
  sock_ioctl+0x629/0x8e0 net/socket.c:1341
  vfs_ioctl fs/ioctl.c:51 [inline]
  __do_sys_ioctl fs/ioctl.c:907 [inline]
  __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893
  do_syscall_x64 arch/x86/entry/common.c:52 [inline]
  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7f940f07cea9

Fixes: 428604fb118f ("ipv6: do not set routes if disable_ipv6 has been enabled")
	Reported-by: syzbot <syzkaller@googlegroups.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://lore.kernel.org/r/20240614082002.26407-1-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2eab4543a2204092c3a7af81d7d6c506e59a03a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index 1f00f8737f54,28788ffde585..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -3102,6 -3507,186 +3102,189 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static bool fib6_is_reject(u32 flags, struct net_device *dev, int addr_type)
+ {
+ 	if ((flags & RTF_REJECT) ||
+ 	    (dev && (dev->flags & IFF_LOOPBACK) &&
+ 	     !(addr_type & IPV6_ADDR_LOOPBACK) &&
+ 	     !(flags & (RTF_ANYCAST | RTF_LOCAL))))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ int fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,
+ 		 struct fib6_config *cfg, gfp_t gfp_flags,
+ 		 struct netlink_ext_ack *extack)
+ {
+ 	netdevice_tracker *dev_tracker = &fib6_nh->fib_nh_dev_tracker;
+ 	struct net_device *dev = NULL;
+ 	struct inet6_dev *idev = NULL;
+ 	int addr_type;
+ 	int err;
+ 
+ 	fib6_nh->fib_nh_family = AF_INET6;
+ #ifdef CONFIG_IPV6_ROUTER_PREF
+ 	fib6_nh->last_probe = jiffies;
+ #endif
+ 	if (cfg->fc_is_fdb) {
+ 		fib6_nh->fib_nh_gw6 = cfg->fc_gateway;
+ 		fib6_nh->fib_nh_gw_family = AF_INET6;
+ 		return 0;
+ 	}
+ 
+ 	err = -ENODEV;
+ 	if (cfg->fc_ifindex) {
+ 		dev = netdev_get_by_index(net, cfg->fc_ifindex,
+ 					  dev_tracker, gfp_flags);
+ 		if (!dev)
+ 			goto out;
+ 		idev = in6_dev_get(dev);
+ 		if (!idev)
+ 			goto out;
+ 	}
+ 
+ 	if (cfg->fc_flags & RTNH_F_ONLINK) {
+ 		if (!dev) {
+ 			NL_SET_ERR_MSG(extack,
+ 				       "Nexthop device required for onlink");
+ 			goto out;
+ 		}
+ 
+ 		if (!(dev->flags & IFF_UP)) {
+ 			NL_SET_ERR_MSG(extack, "Nexthop device is not up");
+ 			err = -ENETDOWN;
+ 			goto out;
+ 		}
+ 
+ 		fib6_nh->fib_nh_flags |= RTNH_F_ONLINK;
+ 	}
+ 
+ 	fib6_nh->fib_nh_weight = 1;
+ 
+ 	/* We cannot add true routes via loopback here,
+ 	 * they would result in kernel looping; promote them to reject routes
+ 	 */
+ 	addr_type = ipv6_addr_type(&cfg->fc_dst);
+ 	if (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {
+ 		/* hold loopback dev/idev if we haven't done so. */
+ 		if (dev != net->loopback_dev) {
+ 			if (dev) {
+ 				netdev_put(dev, dev_tracker);
+ 				in6_dev_put(idev);
+ 			}
+ 			dev = net->loopback_dev;
+ 			netdev_hold(dev, dev_tracker, gfp_flags);
+ 			idev = in6_dev_get(dev);
+ 			if (!idev) {
+ 				err = -ENODEV;
+ 				goto out;
+ 			}
+ 		}
+ 		goto pcpu_alloc;
+ 	}
+ 
+ 	if (cfg->fc_flags & RTF_GATEWAY) {
+ 		err = ip6_validate_gw(net, cfg, &dev, dev_tracker,
+ 				      &idev, extack);
+ 		if (err)
+ 			goto out;
+ 
+ 		fib6_nh->fib_nh_gw6 = cfg->fc_gateway;
+ 		fib6_nh->fib_nh_gw_family = AF_INET6;
+ 	}
+ 
+ 	err = -ENODEV;
+ 	if (!dev)
+ 		goto out;
+ 
+ 	if (!idev || idev->cnf.disable_ipv6) {
+ 		NL_SET_ERR_MSG(extack, "IPv6 is disabled on nexthop device");
+ 		err = -EACCES;
+ 		goto out;
+ 	}
+ 
+ 	if (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {
+ 		NL_SET_ERR_MSG(extack, "Nexthop device is not up");
+ 		err = -ENETDOWN;
+ 		goto out;
+ 	}
+ 
+ 	if (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&
+ 	    !netif_carrier_ok(dev))
+ 		fib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;
+ 
+ 	err = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,
+ 				 cfg->fc_encap_type, cfg, gfp_flags, extack);
+ 	if (err)
+ 		goto out;
+ 
+ pcpu_alloc:
+ 	fib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);
+ 	if (!fib6_nh->rt6i_pcpu) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	fib6_nh->fib_nh_dev = dev;
+ 	fib6_nh->fib_nh_oif = dev->ifindex;
+ 	err = 0;
+ out:
+ 	if (idev)
+ 		in6_dev_put(idev);
+ 
+ 	if (err) {
+ 		lwtstate_put(fib6_nh->fib_nh_lws);
+ 		fib6_nh->fib_nh_lws = NULL;
+ 		netdev_put(dev, dev_tracker);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ void fib6_nh_release(struct fib6_nh *fib6_nh)
+ {
+ 	struct rt6_exception_bucket *bucket;
+ 
+ 	rcu_read_lock();
+ 
+ 	fib6_nh_flush_exceptions(fib6_nh, NULL);
+ 	bucket = fib6_nh_get_excptn_bucket(fib6_nh, NULL);
+ 	if (bucket) {
+ 		rcu_assign_pointer(fib6_nh->rt6i_exception_bucket, NULL);
+ 		kfree(bucket);
+ 	}
+ 
+ 	rcu_read_unlock();
+ 
+ 	fib6_nh_release_dsts(fib6_nh);
+ 	free_percpu(fib6_nh->rt6i_pcpu);
+ 
+ 	fib_nh_common_release(&fib6_nh->nh_common);
+ }
+ 
+ void fib6_nh_release_dsts(struct fib6_nh *fib6_nh)
+ {
+ 	int cpu;
+ 
+ 	if (!fib6_nh->rt6i_pcpu)
+ 		return;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct rt6_info *pcpu_rt, **ppcpu_rt;
+ 
+ 		ppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);
+ 		pcpu_rt = xchg(ppcpu_rt, NULL);
+ 		if (pcpu_rt) {
+ 			dst_dev_put(&pcpu_rt->dst);
+ 			dst_release(&pcpu_rt->dst);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 2eab4543a220 (ipv6: prevent possible NULL deref in fib6_nh_init())
  static struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,
  					      gfp_t gfp_flags,
  					      struct netlink_ext_ack *extack)
* Unmerged path net/ipv6/route.c
