gfs2: Clean up delete work processing

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.27.1.rt7.368.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 0baa10b60cddb587a1a252a8db76b0cea439d1be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.27.1.rt7.368.el8_10/0baa10b6.failed

Function delete_work_func() was previously assuming that the
GLF_TRY_TO_EVICT and GLF_VERIFY_DELETE flags won't both be set at the
same time, but there probably are races in which that can happen, so
handle that case correctly.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 0baa10b60cddb587a1a252a8db76b0cea439d1be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 7369f9303901,95f082f13a8c..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -992,8 -1028,7 +992,12 @@@ static void delete_work_func(struct wor
  	struct delayed_work *dwork = to_delayed_work(work);
  	struct gfs2_glock *gl = container_of(dwork, struct gfs2_glock, gl_delete);
  	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
++<<<<<<< HEAD
 +	struct inode *inode;
 +	u64 no_addr = gl->gl_name.ln_number;
++=======
+ 	bool verify_delete = test_and_clear_bit(GLF_VERIFY_DELETE, &gl->gl_flags);
++>>>>>>> 0baa10b60cdd (gfs2: Clean up delete work processing)
  
  	if (test_and_clear_bit(GLF_TRY_TO_EVICT, &gl->gl_flags)) {
  		/*
@@@ -1014,15 -1049,18 +1018,29 @@@
  		 * step entirely.
  		 */
  		if (gfs2_try_evict(gl)) {
++<<<<<<< HEAD
 +			if (test_bit(SDF_KILL, &sdp->sd_flags))
 +				goto out;
 +			if (gfs2_queue_verify_delete(gl))
 +				return;
++=======
+ 			if (!test_bit(SDF_KILL, &sdp->sd_flags)) {
+ 				gfs2_glock_hold(gl);
+ 				if (!gfs2_queue_verify_delete(gl, true))
+ 					gfs2_glock_put(gl);
+ 			}
++>>>>>>> 0baa10b60cdd (gfs2: Clean up delete work processing)
  		}
- 		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (test_and_clear_bit(GLF_VERIFY_DELETE, &gl->gl_flags)) {
++=======
+ 	if (verify_delete) {
+ 		u64 no_addr = gl->gl_name.ln_number;
+ 		struct inode *inode;
+ 
++>>>>>>> 0baa10b60cdd (gfs2: Clean up delete work processing)
  		inode = gfs2_lookup_by_inum(sdp, no_addr, gl->gl_no_formal_ino,
  					    GFS2_BLKST_UNLINKED);
  		if (IS_ERR(inode)) {
* Unmerged path fs/gfs2/glock.c
