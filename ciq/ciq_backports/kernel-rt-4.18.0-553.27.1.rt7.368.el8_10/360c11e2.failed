tty: tty_io: update timestamps on all device nodes

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.27.1.rt7.368.el8_10
commit-author Michal Sekletar <msekleta@redhat.com>
commit 360c11e2258ce4269441a5ab6d43d0b202f4261b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.27.1.rt7.368.el8_10/360c11e2.failed

User space applications watch for timestamp changes on character device
files in order to determine idle time of a given terminal session. For
example, "w" program uses this information to populate the IDLE column
of its output [1]. Similarly, systemd-logind has optional feature where
it uses atime of the tty character device to determine if there was
activity on the terminal associated with the logind's session object. If
there was no activity for a configured period of time then logind will
terminate such session [2].

Now, usually (e.g. bash running on the terminal) the use of the terminal
will update timestamps (atime and mtime) on the corresponding terminal
character device. However, if access to the terminal, e.g. /dev/pts/0,
is performed through magic character device /dev/tty then such access
obviously changes the state of the terminal, however timestamps on the
device that correspond to the terminal (/dev/pts/0) are not updated.

This patch makes sure that we update timestamps on *all* character
devices that correspond to the given tty, because outside observers (w,
systemd-logind) are maybe checking these timestamps. Obviously, they can
not check timestamps on /dev/tty as that has per-process meaning.

[1] https://gitlab.com/procps-ng/procps/-/blob/v4.0.0/w.c#L286
[2] https://github.com/systemd/systemd/blob/v252/NEWS#L477

	Signed-off-by: Michal Sekletar <msekleta@redhat.com>
Message-ID: <20230613172107.78138-1-msekleta@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 360c11e2258ce4269441a5ab6d43d0b202f4261b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/tty_io.c
diff --cc drivers/tty/tty_io.c
index 7cb9fc7e0eb4,a505d2c49110..000000000000
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@@ -97,8 -98,10 +97,13 @@@
  #include <linux/seq_file.h>
  #include <linux/serial.h>
  #include <linux/ratelimit.h>
 -#include <linux/compat.h>
 +
  #include <linux/uaccess.h>
++<<<<<<< HEAD
++=======
+ #include <linux/termios_internal.h>
+ #include <linux/fs.h>
++>>>>>>> 360c11e2258c (tty: tty_io: update timestamps on all device nodes)
  
  #include <linux/kbd_kern.h>
  #include <linux/vt_kern.h>
@@@ -816,39 -812,110 +821,47 @@@ void start_tty(struct tty_struct *tty
  }
  EXPORT_SYMBOL(start_tty);
  
- static void tty_update_time(struct timespec64 *time)
+ static void tty_update_time(struct tty_struct *tty, bool mtime)
  {
  	time64_t sec = ktime_get_real_seconds();
+ 	struct tty_file_private *priv;
  
- 	/*
- 	 * We only care if the two values differ in anything other than the
- 	 * lower three bits (i.e every 8 seconds).  If so, then we can update
- 	 * the time of the tty device, otherwise it could be construded as a
- 	 * security leak to let userspace know the exact timing of the tty.
- 	 */
- 	if ((sec ^ time->tv_sec) & ~7)
- 		time->tv_sec = sec;
+ 	spin_lock(&tty->files_lock);
+ 	list_for_each_entry(priv, &tty->tty_files, list) {
+ 		struct inode *inode = file_inode(priv->file);
+ 		struct timespec64 *time = mtime ? &inode->i_mtime : &inode->i_atime;
+ 
+ 		/*
+ 		 * We only care if the two values differ in anything other than the
+ 		 * lower three bits (i.e every 8 seconds).  If so, then we can update
+ 		 * the time of the tty device, otherwise it could be construded as a
+ 		 * security leak to let userspace know the exact timing of the tty.
+ 		 */
+ 		if ((sec ^ time->tv_sec) & ~7)
+ 			time->tv_sec = sec;
+ 	}
+ 	spin_unlock(&tty->files_lock);
  }
  
 -/*
 - * Iterate on the ldisc ->read() function until we've gotten all
 - * the data the ldisc has for us.
 - *
 - * The "cookie" is something that the ldisc read function can fill
 - * in to let us know that there is more data to be had.
 - *
 - * We promise to continue to call the ldisc until it stops returning
 - * data or clears the cookie. The cookie may be something that the
 - * ldisc maintains state for and needs to free.
 - */
 -static int iterate_tty_read(struct tty_ldisc *ld, struct tty_struct *tty,
 -		struct file *file, struct iov_iter *to)
 -{
 -	int retval = 0;
 -	void *cookie = NULL;
 -	unsigned long offset = 0;
 -	char kernel_buf[64];
 -	size_t count = iov_iter_count(to);
 -
 -	do {
 -		int size, copied;
 -
 -		size = count > sizeof(kernel_buf) ? sizeof(kernel_buf) : count;
 -		size = ld->ops->read(tty, file, kernel_buf, size, &cookie, offset);
 -		if (!size)
 -			break;
 -
 -		if (size < 0) {
 -			/* Did we have an earlier error (ie -EFAULT)? */
 -			if (retval)
 -				break;
 -			retval = size;
 -
 -			/*
 -			 * -EOVERFLOW means we didn't have enough space
 -			 * for a whole packet, and we shouldn't return
 -			 * a partial result.
 -			 */
 -			if (retval == -EOVERFLOW)
 -				offset = 0;
 -			break;
 -		}
 -
 -		copied = copy_to_iter(kernel_buf, size, to);
 -		offset += copied;
 -		count -= copied;
 -
 -		/*
 -		 * If the user copy failed, we still need to do another ->read()
 -		 * call if we had a cookie to let the ldisc clear up.
 -		 *
 -		 * But make sure size is zeroed.
 -		 */
 -		if (unlikely(copied != size)) {
 -			count = 0;
 -			retval = -EFAULT;
 -		}
 -	} while (cookie);
 -
 -	/* We always clear tty buffer in case they contained passwords */
 -	memzero_explicit(kernel_buf, sizeof(kernel_buf));
 -	return offset ? offset : retval;
 -}
 -
 -
  /**
 - * tty_read	-	read method for tty device files
 - * @iocb: kernel I/O control block
 - * @to: destination for the data read
 + *	tty_read	-	read method for tty device files
 + *	@file: pointer to tty file
 + *	@buf: user buffer
 + *	@count: size of user buffer
 + *	@ppos: unused
   *
 - * Perform the read system call function on this terminal device. Checks
 - * for hung up devices before calling the line discipline method.
 + *	Perform the read system call function on this terminal device. Checks
 + *	for hung up devices before calling the line discipline method.
   *
 - * Locking:
 - *	Locks the line discipline internally while needed. Multiple read calls
 - *	may be outstanding in parallel.
 + *	Locking:
 + *		Locks the line discipline internally while needed. Multiple
 + *	read calls may be outstanding in parallel.
   */
 -static ssize_t tty_read(struct kiocb *iocb, struct iov_iter *to)
 +
 +static ssize_t tty_read(struct file *file, char __user *buf, size_t count,
 +			loff_t *ppos)
  {
  	int i;
 -	struct file *file = iocb->ki_filp;
  	struct inode *inode = file_inode(file);
  	struct tty_struct *tty = file_tty(file);
  	struct tty_ldisc *ld;
* Unmerged path drivers/tty/tty_io.c
