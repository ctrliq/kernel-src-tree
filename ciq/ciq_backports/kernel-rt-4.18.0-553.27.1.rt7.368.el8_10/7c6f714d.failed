gfs2: Fix unlinked inode cleanup

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.27.1.rt7.368.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 7c6f714d88475ceae5342264858a641eafa19632
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.27.1.rt7.368.el8_10/7c6f714d.failed

Before commit f0e56edc2ec7 ("gfs2: Split the two kinds of glock "delete"
work"), function delete_work_func() was used to trigger the eviction of
in-memory inodes from remote as well as deleting unlinked inodes at a
later point.  These two kinds of work were then split into two kinds of
work, and the two places in the code were deferred deletion of inodes is
required accidentally ended up queuing the wrong kind of work.  This
caused unlinked inodes to be left behind, which could in the worst case
fill up filesystems and require a filesystem check to recover.

Fix that by queuing the right kind of work in try_rgrp_unlink() and
gfs2_drop_inode().

Fixes: f0e56edc2ec7 ("gfs2: Split the two kinds of glock "delete" work")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 7c6f714d88475ceae5342264858a641eafa19632)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
#	fs/gfs2/glock.h
#	fs/gfs2/super.c
diff --cc fs/gfs2/glock.c
index 0881a898d05f,9273ec5345ed..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -977,9 -1012,10 +977,13 @@@ bool gfs2_queue_try_to_evict(struct gfs
  				  &gl->gl_delete, 0);
  }
  
++<<<<<<< HEAD
 +static bool gfs2_queue_verify_delete(struct gfs2_glock *gl)
++=======
+ bool gfs2_queue_verify_delete(struct gfs2_glock *gl, bool later)
++>>>>>>> 7c6f714d8847 (gfs2: Fix unlinked inode cleanup)
  {
  	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 -	unsigned long delay;
  
  	if (test_and_set_bit(GLF_VERIFY_DELETE, &gl->gl_flags))
  		return false;
diff --cc fs/gfs2/glock.h
index c0ed1817ac0b,63e101d448e9..000000000000
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@@ -252,28 -242,28 +252,42 @@@ static inline int gfs2_glock_nq_init(st
  	return error;
  }
  
++<<<<<<< HEAD
 +extern void gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state);
 +extern void gfs2_glock_complete(struct gfs2_glock *gl, int ret);
 +extern bool gfs2_queue_try_to_evict(struct gfs2_glock *gl);
 +extern void gfs2_cancel_delete_work(struct gfs2_glock *gl);
 +extern void gfs2_flush_delete_work(struct gfs2_sbd *sdp);
 +extern void gfs2_gl_hash_clear(struct gfs2_sbd *sdp);
 +extern void gfs2_gl_dq_holders(struct gfs2_sbd *sdp);
 +extern void gfs2_glock_thaw(struct gfs2_sbd *sdp);
 +extern void gfs2_glock_add_to_lru(struct gfs2_glock *gl);
 +extern void gfs2_glock_free(struct gfs2_glock *gl);
 +extern void gfs2_glock_free_later(struct gfs2_glock *gl);
++=======
+ void gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state);
+ void gfs2_glock_complete(struct gfs2_glock *gl, int ret);
+ bool gfs2_queue_try_to_evict(struct gfs2_glock *gl);
+ bool gfs2_queue_verify_delete(struct gfs2_glock *gl, bool later);
+ void gfs2_cancel_delete_work(struct gfs2_glock *gl);
+ void gfs2_flush_delete_work(struct gfs2_sbd *sdp);
+ void gfs2_gl_hash_clear(struct gfs2_sbd *sdp);
+ void gfs2_gl_dq_holders(struct gfs2_sbd *sdp);
+ void gfs2_glock_thaw(struct gfs2_sbd *sdp);
+ void gfs2_glock_free(struct gfs2_glock *gl);
+ void gfs2_glock_free_later(struct gfs2_glock *gl);
++>>>>>>> 7c6f714d8847 (gfs2: Fix unlinked inode cleanup)
  
 -int __init gfs2_glock_init(void);
 -void gfs2_glock_exit(void);
 +extern int __init gfs2_glock_init(void);
 +extern void gfs2_glock_exit(void);
  
 -void gfs2_create_debugfs_file(struct gfs2_sbd *sdp);
 -void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp);
 -void gfs2_register_debugfs(void);
 -void gfs2_unregister_debugfs(void);
 +extern void gfs2_create_debugfs_file(struct gfs2_sbd *sdp);
 +extern void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp);
 +extern void gfs2_register_debugfs(void);
 +extern void gfs2_unregister_debugfs(void);
  
 -void glock_set_object(struct gfs2_glock *gl, void *object);
 -void glock_clear_object(struct gfs2_glock *gl, void *object);
 +extern void glock_set_object(struct gfs2_glock *gl, void *object);
 +extern void glock_clear_object(struct gfs2_glock *gl, void *object);
  
  extern const struct lm_lockops gfs2_dlm_ops;
  
diff --cc fs/gfs2/super.c
index 544721b9078a,e22c1edc32b3..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1066,8 -1045,8 +1066,13 @@@ static int gfs2_drop_inode(struct inod
  		struct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;
  
  		gfs2_glock_hold(gl);
++<<<<<<< HEAD
 +		if (!gfs2_queue_try_to_evict(gl))
 +			gfs2_glock_queue_put(gl);
++=======
+ 		if (!gfs2_queue_verify_delete(gl, true))
+ 			gfs2_glock_put_async(gl);
++>>>>>>> 7c6f714d8847 (gfs2: Fix unlinked inode cleanup)
  		return 0;
  	}
  
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/glock.h
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 89d829045308..4f0923da8abc 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -1882,7 +1882,7 @@ static void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip
 		 */
 		ip = gl->gl_object;
 
-		if (ip || !gfs2_queue_try_to_evict(gl))
+		if (ip || !gfs2_queue_verify_delete(gl, false))
 			gfs2_glock_put(gl);
 		else
 			found++;
* Unmerged path fs/gfs2/super.c
