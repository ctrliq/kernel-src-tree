x86/speculation/mmio: Enable CPU Fill buffer clearing on idle

jira LE-1907
cve CVE-2022-21166
cve CVE-2022-21125
cve CVE-2022-21123
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.26.1.rt7.183.el8_6
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit 99a83db5a605137424e1efe29dc0573d6a5b6316
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.26.1.rt7.183.el8_6/99a83db5.failed

When the CPU is affected by Processor MMIO Stale Data vulnerabilities,
Fill Buffer Stale Data Propagator (FBSDP) can propagate stale data out
of Fill buffer to uncore buffer when CPU goes idle. Stale data can then
be exploited with other variants using MMIO operations.

Mitigate it by clearing the Fill buffer before entering idle state.

	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Co-developed-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 99a83db5a605137424e1efe29dc0573d6a5b6316)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index f6dceabb4029,56d5dea5e128..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -387,6 -390,98 +387,101 @@@ static int __init tsx_async_abort_parse
  early_param("tsx_async_abort", tsx_async_abort_parse_cmdline);
  
  #undef pr_fmt
++<<<<<<< HEAD
++=======
+ #define pr_fmt(fmt)	"MMIO Stale Data: " fmt
+ 
+ enum mmio_mitigations {
+ 	MMIO_MITIGATION_OFF,
+ 	MMIO_MITIGATION_UCODE_NEEDED,
+ 	MMIO_MITIGATION_VERW,
+ };
+ 
+ /* Default mitigation for Processor MMIO Stale Data vulnerabilities */
+ static enum mmio_mitigations mmio_mitigation __ro_after_init = MMIO_MITIGATION_VERW;
+ static bool mmio_nosmt __ro_after_init = false;
+ 
+ static const char * const mmio_strings[] = {
+ 	[MMIO_MITIGATION_OFF]		= "Vulnerable",
+ 	[MMIO_MITIGATION_UCODE_NEEDED]	= "Vulnerable: Clear CPU buffers attempted, no microcode",
+ 	[MMIO_MITIGATION_VERW]		= "Mitigation: Clear CPU buffers",
+ };
+ 
+ static void __init mmio_select_mitigation(void)
+ {
+ 	u64 ia32_cap;
+ 
+ 	if (!boot_cpu_has_bug(X86_BUG_MMIO_STALE_DATA) ||
+ 	    cpu_mitigations_off()) {
+ 		mmio_mitigation = MMIO_MITIGATION_OFF;
+ 		return;
+ 	}
+ 
+ 	if (mmio_mitigation == MMIO_MITIGATION_OFF)
+ 		return;
+ 
+ 	ia32_cap = x86_read_arch_cap_msr();
+ 
+ 	/*
+ 	 * Enable CPU buffer clear mitigation for host and VMM, if also affected
+ 	 * by MDS or TAA. Otherwise, enable mitigation for VMM only.
+ 	 */
+ 	if (boot_cpu_has_bug(X86_BUG_MDS) || (boot_cpu_has_bug(X86_BUG_TAA) &&
+ 					      boot_cpu_has(X86_FEATURE_RTM)))
+ 		static_branch_enable(&mds_user_clear);
+ 	else
+ 		static_branch_enable(&mmio_stale_data_clear);
+ 
+ 	/*
+ 	 * If Processor-MMIO-Stale-Data bug is present and Fill Buffer data can
+ 	 * be propagated to uncore buffers, clearing the Fill buffers on idle
+ 	 * is required irrespective of SMT state.
+ 	 */
+ 	if (!(ia32_cap & ARCH_CAP_FBSDP_NO))
+ 		static_branch_enable(&mds_idle_clear);
+ 
+ 	/*
+ 	 * Check if the system has the right microcode.
+ 	 *
+ 	 * CPU Fill buffer clear mitigation is enumerated by either an explicit
+ 	 * FB_CLEAR or by the presence of both MD_CLEAR and L1D_FLUSH on MDS
+ 	 * affected systems.
+ 	 */
+ 	if ((ia32_cap & ARCH_CAP_FB_CLEAR) ||
+ 	    (boot_cpu_has(X86_FEATURE_MD_CLEAR) &&
+ 	     boot_cpu_has(X86_FEATURE_FLUSH_L1D) &&
+ 	     !(ia32_cap & ARCH_CAP_MDS_NO)))
+ 		mmio_mitigation = MMIO_MITIGATION_VERW;
+ 	else
+ 		mmio_mitigation = MMIO_MITIGATION_UCODE_NEEDED;
+ 
+ 	if (mmio_nosmt || cpu_mitigations_auto_nosmt())
+ 		cpu_smt_disable(false);
+ }
+ 
+ static int __init mmio_stale_data_parse_cmdline(char *str)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_MMIO_STALE_DATA))
+ 		return 0;
+ 
+ 	if (!str)
+ 		return -EINVAL;
+ 
+ 	if (!strcmp(str, "off")) {
+ 		mmio_mitigation = MMIO_MITIGATION_OFF;
+ 	} else if (!strcmp(str, "full")) {
+ 		mmio_mitigation = MMIO_MITIGATION_VERW;
+ 	} else if (!strcmp(str, "full,nosmt")) {
+ 		mmio_mitigation = MMIO_MITIGATION_VERW;
+ 		mmio_nosmt = true;
+ 	}
+ 
+ 	return 0;
+ }
+ early_param("mmio_stale_data", mmio_stale_data_parse_cmdline);
+ 
+ #undef pr_fmt
++>>>>>>> 99a83db5a605 (x86/speculation/mmio: Enable CPU Fill buffer clearing on idle)
  #define pr_fmt(fmt)     "" fmt
  
  static void __init md_clear_update_mitigation(void)
* Unmerged path arch/x86/kernel/cpu/bugs.c
