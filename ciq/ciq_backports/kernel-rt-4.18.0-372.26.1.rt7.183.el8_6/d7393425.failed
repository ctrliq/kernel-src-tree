ice: Introduce enabling promiscuous mode on multiple VF's

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.26.1.rt7.183.el8_6
commit-author Michal Wilczynski <michal.wilczynski@intel.com>
commit d7393425e7c8819ac4a6dbc03f061954665f62ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.26.1.rt7.183.el8_6/d7393425.failed

In current implementation default VSI switch filter is only able to
forward traffic to a single VSI. This limits promiscuous mode with
private flag 'vf-true-promisc-support' to a single VF. Enabling it on
the second VF won't work. Also allmulticast support doesn't seem to be
properly implemented when vf-true-promisc-support is true.

Use standard ice_add_rule_internal() function that already implements
forwarding to multiple VSI's instead of constructing AQ call manually.

Add switch filter for allmulticast mode when vf-true-promisc-support is
enabled. The same filter is added regardless of the flag - it doesn't
matter for this case.

Remove unnecessary fields in switch structure. From now on book keeping
will be done by ice_add_rule_internal().

Refactor unnecessarily passed function arguments.

To test:
1) Create 2 VM's, and two VF's. Attach VF's to VM's.
2) Enable promiscuous mode on both of them and check if
   traffic is seen on both of them.

	Signed-off-by: Michal Wilczynski <michal.wilczynski@intel.com>
	Tested-by: Marek Szlosek <marek.szlosek@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit d7393425e7c8819ac4a6dbc03f061954665f62ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_switch.c
#	drivers/net/ethernet/intel/ice/ice_vf_lib.c
#	drivers/net/ethernet/intel/ice/ice_vf_lib.h
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 79ca35d1f0b4,fce204693dbb..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -3244,26 -3881,21 +3244,35 @@@ ice_rem_adv_rule_info(struct ice_hw *hw
   * add filter rule to set/unset given VSI as default VSI for the switch
   * (represented by swid)
   */
- int ice_cfg_dflt_vsi(struct ice_hw *hw, u16 vsi_handle, bool set, u8 direction)
+ int
+ ice_cfg_dflt_vsi(struct ice_port_info *pi, u16 vsi_handle, bool set,
+ 		 u8 direction)
  {
++<<<<<<< HEAD
 +	struct ice_aqc_sw_rules_elem *s_rule;
++=======
+ 	struct ice_fltr_list_entry f_list_entry;
++>>>>>>> d7393425e7c8 (ice: Introduce enabling promiscuous mode on multiple VF's)
  	struct ice_fltr_info f_info;
- 	enum ice_adminq_opc opcode;
- 	u16 s_rule_size;
+ 	struct ice_hw *hw = pi->hw;
  	u16 hw_vsi_id;
  	int status;
  
  	if (!ice_is_vsi_valid(hw, vsi_handle))
  		return -EINVAL;
+ 
  	hw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);
  
++<<<<<<< HEAD
 +	s_rule_size = set ? ICE_SW_RULE_RX_TX_ETH_HDR_SIZE :
 +		ICE_SW_RULE_RX_TX_NO_HDR_SIZE;
 +
 +	s_rule = devm_kzalloc(ice_hw_to_dev(hw), s_rule_size, GFP_KERNEL);
 +	if (!s_rule)
 +		return -ENOMEM;
 +
++=======
++>>>>>>> d7393425e7c8 (ice: Introduce enabling promiscuous mode on multiple VF's)
  	memset(&f_info, 0, sizeof(f_info));
  
  	f_info.lkup_type = ICE_SW_LKUP_DFLT;
@@@ -3277,41 -3910,66 +3287,74 @@@
  	} else if (f_info.flag & ICE_FLTR_TX) {
  		f_info.src_id = ICE_SRC_ID_VSI;
  		f_info.src = hw_vsi_id;
- 		if (!set)
- 			f_info.fltr_rule_id =
- 				hw->port_info->dflt_tx_vsi_rule_id;
  	}
+ 	f_list_entry.fltr_info = f_info;
  
  	if (set)
- 		opcode = ice_aqc_opc_add_sw_rules;
+ 		status = ice_add_rule_internal(hw, ICE_SW_LKUP_DFLT,
+ 					       &f_list_entry);
  	else
- 		opcode = ice_aqc_opc_remove_sw_rules;
+ 		status = ice_remove_rule_internal(hw, ICE_SW_LKUP_DFLT,
+ 						  &f_list_entry);
  
- 	ice_fill_sw_rule(hw, &f_info, s_rule, opcode);
+ 	return status;
+ }
  
++<<<<<<< HEAD
 +	status = ice_aq_sw_rules(hw, s_rule, s_rule_size, 1, opcode, NULL);
 +	if (status || !(f_info.flag & ICE_FLTR_TX_RX))
 +		goto out;
 +	if (set) {
 +		u16 index = le16_to_cpu(s_rule->pdata.lkup_tx_rx.index);
++=======
+ /**
+  * ice_vsi_uses_fltr - Determine if given VSI uses specified filter
+  * @fm_entry: filter entry to inspect
+  * @vsi_handle: VSI handle to compare with filter info
+  */
+ static bool
+ ice_vsi_uses_fltr(struct ice_fltr_mgmt_list_entry *fm_entry, u16 vsi_handle)
+ {
+ 	return ((fm_entry->fltr_info.fltr_act == ICE_FWD_TO_VSI &&
+ 		 fm_entry->fltr_info.vsi_handle == vsi_handle) ||
+ 		(fm_entry->fltr_info.fltr_act == ICE_FWD_TO_VSI_LIST &&
+ 		 fm_entry->vsi_list_info &&
+ 		 (test_bit(vsi_handle, fm_entry->vsi_list_info->vsi_map))));
+ }
++>>>>>>> d7393425e7c8 (ice: Introduce enabling promiscuous mode on multiple VF's)
  
- 		if (f_info.flag & ICE_FLTR_TX) {
- 			hw->port_info->dflt_tx_vsi_num = hw_vsi_id;
- 			hw->port_info->dflt_tx_vsi_rule_id = index;
- 		} else if (f_info.flag & ICE_FLTR_RX) {
- 			hw->port_info->dflt_rx_vsi_num = hw_vsi_id;
- 			hw->port_info->dflt_rx_vsi_rule_id = index;
- 		}
- 	} else {
- 		if (f_info.flag & ICE_FLTR_TX) {
- 			hw->port_info->dflt_tx_vsi_num = ICE_DFLT_VSI_INVAL;
- 			hw->port_info->dflt_tx_vsi_rule_id = ICE_INVAL_ACT;
- 		} else if (f_info.flag & ICE_FLTR_RX) {
- 			hw->port_info->dflt_rx_vsi_num = ICE_DFLT_VSI_INVAL;
- 			hw->port_info->dflt_rx_vsi_rule_id = ICE_INVAL_ACT;
+ /**
+  * ice_check_if_dflt_vsi - check if VSI is default VSI
+  * @pi: pointer to the port_info structure
+  * @vsi_handle: vsi handle to check for in filter list
+  * @rule_exists: indicates if there are any VSI's in the rule list
+  *
+  * checks if the VSI is in a default VSI list, and also indicates
+  * if the default VSI list is empty
+  */
+ bool
+ ice_check_if_dflt_vsi(struct ice_port_info *pi, u16 vsi_handle,
+ 		      bool *rule_exists)
+ {
+ 	struct ice_fltr_mgmt_list_entry *fm_entry;
+ 	struct ice_sw_recipe *recp_list;
+ 	struct list_head *rule_head;
+ 	struct mutex *rule_lock; /* Lock to protect filter rule list */
+ 	bool ret = false;
+ 
+ 	recp_list = &pi->hw->switch_info->recp_list[ICE_SW_LKUP_DFLT];
+ 	rule_lock = &recp_list->filt_rule_lock;
+ 	rule_head = &recp_list->filt_rules;
+ 
+ 	mutex_lock(rule_lock);
+ 
+ 	if (rule_exists && !list_empty(rule_head))
+ 		*rule_exists = true;
+ 
+ 	list_for_each_entry(fm_entry, rule_head, list_entry) {
+ 		if (ice_vsi_uses_fltr(fm_entry, vsi_handle)) {
+ 			ret = true;
+ 			break;
  		}
  	}
  
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index f47989ad400e,47ce713274cf..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -2381,1765 -2189,37 +2381,1787 @@@ static bool ice_vc_isvalid_ring_len(u1
  }
  
  /**
 - * ice_vc_process_vlan_msg
 + * ice_vc_validate_pattern
   * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - * @add_v: Add VLAN if true, otherwise delete VLAN
 + * @proto: virtchnl protocol headers
   *
 - * Process virtchnl op to add or remove programmed guest VLAN ID
 + * validate the pattern is supported or not.
 + *
 + * Return: true on success, false on error.
   */
 -static int ice_vc_process_vlan_msg(struct ice_vf *vf, u8 *msg, bool add_v)
 +bool
 +ice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto)
  {
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_filter_list *vfl =
 -	    (struct virtchnl_vlan_filter_list *)msg;
 -	struct ice_pf *pf = vf->pf;
 -	bool vlan_promisc = false;
 -	struct ice_vsi *vsi;
 -	struct device *dev;
 -	int status = 0;
 -	int i;
 -
 -	dev = ice_pf_to_dev(pf);
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vf_vlan_offload_ena(vf->driver_caps)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 +	bool is_ipv4 = false;
 +	bool is_ipv6 = false;
 +	bool is_udp = false;
 +	u16 ptype = -1;
 +	int i = 0;
  
 -	if (!ice_vc_isvalid_vsi_id(vf, vfl->vsi_id)) {
 +	while (i < proto->count &&
 +	       proto->proto_hdr[i].type != VIRTCHNL_PROTO_HDR_NONE) {
 +		switch (proto->proto_hdr[i].type) {
 +		case VIRTCHNL_PROTO_HDR_ETH:
 +			ptype = ICE_PTYPE_MAC_PAY;
 +			break;
 +		case VIRTCHNL_PROTO_HDR_IPV4:
 +			ptype = ICE_PTYPE_IPV4_PAY;
 +			is_ipv4 = true;
 +			break;
 +		case VIRTCHNL_PROTO_HDR_IPV6:
 +			ptype = ICE_PTYPE_IPV6_PAY;
 +			is_ipv6 = true;
 +			break;
 +		case VIRTCHNL_PROTO_HDR_UDP:
 +			if (is_ipv4)
 +				ptype = ICE_PTYPE_IPV4_UDP_PAY;
 +			else if (is_ipv6)
 +				ptype = ICE_PTYPE_IPV6_UDP_PAY;
 +			is_udp = true;
 +			break;
 +		case VIRTCHNL_PROTO_HDR_TCP:
 +			if (is_ipv4)
 +				ptype = ICE_PTYPE_IPV4_TCP_PAY;
 +			else if (is_ipv6)
 +				ptype = ICE_PTYPE_IPV6_TCP_PAY;
 +			break;
 +		case VIRTCHNL_PROTO_HDR_SCTP:
 +			if (is_ipv4)
 +				ptype = ICE_PTYPE_IPV4_SCTP_PAY;
 +			else if (is_ipv6)
 +				ptype = ICE_PTYPE_IPV6_SCTP_PAY;
 +			break;
 +		case VIRTCHNL_PROTO_HDR_GTPU_IP:
 +		case VIRTCHNL_PROTO_HDR_GTPU_EH:
 +			if (is_ipv4)
 +				ptype = ICE_MAC_IPV4_GTPU;
 +			else if (is_ipv6)
 +				ptype = ICE_MAC_IPV6_GTPU;
 +			goto out;
 +		case VIRTCHNL_PROTO_HDR_L2TPV3:
 +			if (is_ipv4)
 +				ptype = ICE_MAC_IPV4_L2TPV3;
 +			else if (is_ipv6)
 +				ptype = ICE_MAC_IPV6_L2TPV3;
 +			goto out;
 +		case VIRTCHNL_PROTO_HDR_ESP:
 +			if (is_ipv4)
 +				ptype = is_udp ? ICE_MAC_IPV4_NAT_T_ESP :
 +						ICE_MAC_IPV4_ESP;
 +			else if (is_ipv6)
 +				ptype = is_udp ? ICE_MAC_IPV6_NAT_T_ESP :
 +						ICE_MAC_IPV6_ESP;
 +			goto out;
 +		case VIRTCHNL_PROTO_HDR_AH:
 +			if (is_ipv4)
 +				ptype = ICE_MAC_IPV4_AH;
 +			else if (is_ipv6)
 +				ptype = ICE_MAC_IPV6_AH;
 +			goto out;
 +		case VIRTCHNL_PROTO_HDR_PFCP:
 +			if (is_ipv4)
 +				ptype = ICE_MAC_IPV4_PFCP_SESSION;
 +			else if (is_ipv6)
 +				ptype = ICE_MAC_IPV6_PFCP_SESSION;
 +			goto out;
 +		default:
 +			break;
 +		}
 +		i++;
 +	}
 +
 +out:
 +	return ice_hw_ptype_ena(&vf->pf->hw, ptype);
 +}
 +
 +/**
 + * ice_vc_parse_rss_cfg - parses hash fields and headers from
 + * a specific virtchnl RSS cfg
 + * @hw: pointer to the hardware
 + * @rss_cfg: pointer to the virtchnl RSS cfg
 + * @addl_hdrs: pointer to the protocol header fields (ICE_FLOW_SEG_HDR_*)
 + * to configure
 + * @hash_flds: pointer to the hash bit fields (ICE_FLOW_HASH_*) to configure
 + *
 + * Return true if all the protocol header and hash fields in the RSS cfg could
 + * be parsed, else return false
 + *
 + * This function parses the virtchnl RSS cfg to be the intended
 + * hash fields and the intended header for RSS configuration
 + */
 +static bool
 +ice_vc_parse_rss_cfg(struct ice_hw *hw, struct virtchnl_rss_cfg *rss_cfg,
 +		     u32 *addl_hdrs, u64 *hash_flds)
 +{
 +	const struct ice_vc_hash_field_match_type *hf_list;
 +	const struct ice_vc_hdr_match_type *hdr_list;
 +	int i, hf_list_len, hdr_list_len;
 +
 +	hf_list = ice_vc_hash_field_list;
 +	hf_list_len = ARRAY_SIZE(ice_vc_hash_field_list);
 +	hdr_list = ice_vc_hdr_list;
 +	hdr_list_len = ARRAY_SIZE(ice_vc_hdr_list);
 +
 +	for (i = 0; i < rss_cfg->proto_hdrs.count; i++) {
 +		struct virtchnl_proto_hdr *proto_hdr =
 +					&rss_cfg->proto_hdrs.proto_hdr[i];
 +		bool hdr_found = false;
 +		int j;
 +
 +		/* Find matched ice headers according to virtchnl headers. */
 +		for (j = 0; j < hdr_list_len; j++) {
 +			struct ice_vc_hdr_match_type hdr_map = hdr_list[j];
 +
 +			if (proto_hdr->type == hdr_map.vc_hdr) {
 +				*addl_hdrs |= hdr_map.ice_hdr;
 +				hdr_found = true;
 +			}
 +		}
 +
 +		if (!hdr_found)
 +			return false;
 +
 +		/* Find matched ice hash fields according to
 +		 * virtchnl hash fields.
 +		 */
 +		for (j = 0; j < hf_list_len; j++) {
 +			struct ice_vc_hash_field_match_type hf_map = hf_list[j];
 +
 +			if (proto_hdr->type == hf_map.vc_hdr &&
 +			    proto_hdr->field_selector == hf_map.vc_hash_field) {
 +				*hash_flds |= hf_map.ice_hash_field;
 +				break;
 +			}
 +		}
 +	}
 +
 +	return true;
 +}
 +
 +/**
 + * ice_vf_adv_rss_offload_ena - determine if capabilities support advanced
 + * RSS offloads
 + * @caps: VF driver negotiated capabilities
 + *
 + * Return true if VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF capability is set,
 + * else return false
 + */
 +static bool ice_vf_adv_rss_offload_ena(u32 caps)
 +{
 +	return !!(caps & VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF);
 +}
 +
 +/**
 + * ice_vc_handle_rss_cfg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the message buffer
 + * @add: add a RSS config if true, otherwise delete a RSS config
 + *
 + * This function adds/deletes a RSS config
 + */
 +static int ice_vc_handle_rss_cfg(struct ice_vf *vf, u8 *msg, bool add)
 +{
 +	u32 v_opcode = add ? VIRTCHNL_OP_ADD_RSS_CFG : VIRTCHNL_OP_DEL_RSS_CFG;
 +	struct virtchnl_rss_cfg *rss_cfg = (struct virtchnl_rss_cfg *)msg;
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct device *dev = ice_pf_to_dev(vf->pf);
 +	struct ice_hw *hw = &vf->pf->hw;
 +	struct ice_vsi *vsi;
 +
 +	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
 +		dev_dbg(dev, "VF %d attempting to configure RSS, but RSS is not supported by the PF\n",
 +			vf->vf_id);
 +		v_ret = VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vf_adv_rss_offload_ena(vf->driver_caps)) {
 +		dev_dbg(dev, "VF %d attempting to configure RSS, but Advanced RSS offload is not supported\n",
 +			vf->vf_id);
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (rss_cfg->proto_hdrs.count > VIRTCHNL_MAX_NUM_PROTO_HDRS ||
 +	    rss_cfg->rss_algorithm < VIRTCHNL_RSS_ALG_TOEPLITZ_ASYMMETRIC ||
 +	    rss_cfg->rss_algorithm > VIRTCHNL_RSS_ALG_XOR_SYMMETRIC) {
 +		dev_dbg(dev, "VF %d attempting to configure RSS, but RSS configuration is not valid\n",
 +			vf->vf_id);
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_validate_pattern(vf, &rss_cfg->proto_hdrs)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (rss_cfg->rss_algorithm == VIRTCHNL_RSS_ALG_R_ASYMMETRIC) {
 +		struct ice_vsi_ctx *ctx;
 +		u8 lut_type, hash_type;
 +		int status;
 +
 +		lut_type = ICE_AQ_VSI_Q_OPT_RSS_LUT_VSI;
 +		hash_type = add ? ICE_AQ_VSI_Q_OPT_RSS_XOR :
 +				ICE_AQ_VSI_Q_OPT_RSS_TPLZ;
 +
 +		ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 +		if (!ctx) {
 +			v_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;
 +			goto error_param;
 +		}
 +
 +		ctx->info.q_opt_rss = ((lut_type <<
 +					ICE_AQ_VSI_Q_OPT_RSS_LUT_S) &
 +				       ICE_AQ_VSI_Q_OPT_RSS_LUT_M) |
 +				       (hash_type &
 +					ICE_AQ_VSI_Q_OPT_RSS_HASH_M);
 +
 +		/* Preserve existing queueing option setting */
 +		ctx->info.q_opt_rss |= (vsi->info.q_opt_rss &
 +					  ICE_AQ_VSI_Q_OPT_RSS_GBL_LUT_M);
 +		ctx->info.q_opt_tc = vsi->info.q_opt_tc;
 +		ctx->info.q_opt_flags = vsi->info.q_opt_rss;
 +
 +		ctx->info.valid_sections =
 +				cpu_to_le16(ICE_AQ_VSI_PROP_Q_OPT_VALID);
 +
 +		status = ice_update_vsi(hw, vsi->idx, ctx, NULL);
 +		if (status) {
 +			dev_err(dev, "update VSI for RSS failed, err %d aq_err %s\n",
 +				status, ice_aq_str(hw->adminq.sq_last_status));
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		} else {
 +			vsi->info.q_opt_rss = ctx->info.q_opt_rss;
 +		}
 +
 +		kfree(ctx);
 +	} else {
 +		u32 addl_hdrs = ICE_FLOW_SEG_HDR_NONE;
 +		u64 hash_flds = ICE_HASH_INVALID;
 +
 +		if (!ice_vc_parse_rss_cfg(hw, rss_cfg, &addl_hdrs,
 +					  &hash_flds)) {
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		if (add) {
 +			if (ice_add_rss_cfg(hw, vsi->idx, hash_flds,
 +					    addl_hdrs)) {
 +				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +				dev_err(dev, "ice_add_rss_cfg failed for vsi = %d, v_ret = %d\n",
 +					vsi->vsi_num, v_ret);
 +			}
 +		} else {
 +			int status;
 +
 +			status = ice_rem_rss_cfg(hw, vsi->idx, hash_flds,
 +						 addl_hdrs);
 +			/* We just ignore -ENOENT, because if two configurations
 +			 * share the same profile remove one of them actually
 +			 * removes both, since the profile is deleted.
 +			 */
 +			if (status && status != -ENOENT) {
 +				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +				dev_err(dev, "ice_rem_rss_cfg failed for VF ID:%d, error:%d\n",
 +					vf->vf_id, status);
 +			}
 +		}
 +	}
 +
 +error_param:
 +	return ice_vc_send_msg_to_vf(vf, v_opcode, v_ret, NULL, 0);
 +}
 +
 +/**
 + * ice_vc_config_rss_key
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * Configure the VF's RSS key
 + */
 +static int ice_vc_config_rss_key(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_rss_key *vrk =
 +		(struct virtchnl_rss_key *)msg;
 +	struct ice_vsi *vsi;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, vrk->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (vrk->key_len != ICE_VSIQF_HKEY_ARRAY_SIZE) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (ice_set_rss_key(vsi, vrk->key))
 +		v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 +error_param:
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_KEY, v_ret,
 +				     NULL, 0);
 +}
 +
 +/**
 + * ice_vc_config_rss_lut
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * Configure the VF's RSS LUT
 + */
 +static int ice_vc_config_rss_lut(struct ice_vf *vf, u8 *msg)
 +{
 +	struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct ice_vsi *vsi;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, vrl->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (vrl->lut_entries != ICE_VSIQF_HLUT_ARRAY_SIZE) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (ice_set_rss_lut(vsi, vrl->lut, ICE_VSIQF_HLUT_ARRAY_SIZE))
 +		v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 +error_param:
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_LUT, v_ret,
 +				     NULL, 0);
 +}
 +
 +/**
 + * ice_wait_on_vf_reset - poll to make sure a given VF is ready after reset
 + * @vf: The VF being resseting
 + *
 + * The max poll time is about ~800ms, which is about the maximum time it takes
 + * for a VF to be reset and/or a VF driver to be removed.
 + */
 +static void ice_wait_on_vf_reset(struct ice_vf *vf)
 +{
 +	int i;
 +
 +	for (i = 0; i < ICE_MAX_VF_RESET_TRIES; i++) {
 +		if (test_bit(ICE_VF_STATE_INIT, vf->vf_states))
 +			break;
 +		msleep(ICE_MAX_VF_RESET_SLEEP_MS);
 +	}
 +}
 +
 +/**
 + * ice_check_vf_ready_for_cfg - check if VF is ready to be configured/queried
 + * @vf: VF to check if it's ready to be configured/queried
 + *
 + * The purpose of this function is to make sure the VF is not in reset, not
 + * disabled, and initialized so it can be configured and/or queried by a host
 + * administrator.
 + */
 +int ice_check_vf_ready_for_cfg(struct ice_vf *vf)
 +{
 +	struct ice_pf *pf;
 +
 +	ice_wait_on_vf_reset(vf);
 +
 +	if (ice_is_vf_disabled(vf))
 +		return -EINVAL;
 +
 +	pf = vf->pf;
 +	if (ice_check_vf_init(pf, vf))
 +		return -EBUSY;
 +
 +	return 0;
 +}
 +
 +/**
 + * ice_set_vf_spoofchk
 + * @netdev: network interface device structure
 + * @vf_id: VF identifier
 + * @ena: flag to enable or disable feature
 + *
 + * Enable or disable VF spoof checking
 + */
 +int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena)
 +{
 +	struct ice_netdev_priv *np = netdev_priv(netdev);
 +	struct ice_pf *pf = np->vsi->back;
 +	struct ice_vsi_ctx *ctx;
 +	struct ice_vsi *vf_vsi;
 +	struct device *dev;
 +	struct ice_vf *vf;
 +	int ret;
 +
 +	dev = ice_pf_to_dev(pf);
 +	if (ice_validate_vf_id(pf, vf_id))
 +		return -EINVAL;
 +
 +	vf = &pf->vf[vf_id];
 +	ret = ice_check_vf_ready_for_cfg(vf);
 +	if (ret)
 +		return ret;
 +
 +	vf_vsi = ice_get_vf_vsi(vf);
 +	if (!vf_vsi) {
 +		netdev_err(netdev, "VSI %d for VF %d is null\n",
 +			   vf->lan_vsi_idx, vf->vf_id);
 +		return -EINVAL;
 +	}
 +
 +	if (vf_vsi->type != ICE_VSI_VF) {
 +		netdev_err(netdev, "Type %d of VSI %d for VF %d is no ICE_VSI_VF\n",
 +			   vf_vsi->type, vf_vsi->vsi_num, vf->vf_id);
 +		return -ENODEV;
 +	}
 +
 +	if (ena == vf->spoofchk) {
 +		dev_dbg(dev, "VF spoofchk already %s\n", ena ? "ON" : "OFF");
 +		return 0;
 +	}
 +
 +	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 +	if (!ctx)
 +		return -ENOMEM;
 +
 +	ctx->info.sec_flags = vf_vsi->info.sec_flags;
 +	ctx->info.valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_SECURITY_VALID);
 +	if (ena) {
 +		ctx->info.sec_flags |=
 +			ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;
 +	} else {
 +		ctx->info.sec_flags &=
 +			~(ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF);
 +	}
 +
 +	ret = ice_update_vsi(&pf->hw, vf_vsi->idx, ctx, NULL);
 +	if (ret) {
 +		dev_err(dev, "Failed to %sable spoofchk on VF %d VSI %d\n error %d\n",
 +			ena ? "en" : "dis", vf->vf_id, vf_vsi->vsi_num, ret);
 +		goto out;
 +	}
 +
 +	/* only update spoofchk state and VSI context on success */
 +	vf_vsi->info.sec_flags = ctx->info.sec_flags;
 +	vf->spoofchk = ena;
 +
 +out:
 +	kfree(ctx);
 +	return ret;
 +}
 +
 +/**
 + * ice_is_any_vf_in_promisc - check if any VF(s) are in promiscuous mode
 + * @pf: PF structure for accessing VF(s)
 + *
 + * Return false if no VF(s) are in unicast and/or multicast promiscuous mode,
 + * else return true
 + */
 +bool ice_is_any_vf_in_promisc(struct ice_pf *pf)
 +{
 +	int vf_idx;
 +
 +	ice_for_each_vf(pf, vf_idx) {
 +		struct ice_vf *vf = &pf->vf[vf_idx];
 +
 +		/* found a VF that has promiscuous mode configured */
 +		if (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||
 +		    test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 +			return true;
 +	}
 +
 +	return false;
 +}
 +
 +/**
 + * ice_vc_cfg_promiscuous_mode_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * called from the VF to configure VF VSIs promiscuous mode
 + */
 +static int ice_vc_cfg_promiscuous_mode_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	bool rm_promisc, alluni = false, allmulti = false;
 +	struct virtchnl_promisc_info *info =
 +	    (struct virtchnl_promisc_info *)msg;
 +	int mcast_err = 0, ucast_err = 0;
 +	struct ice_pf *pf = vf->pf;
 +	struct ice_vsi *vsi;
++	u8 mcast_m, ucast_m;
 +	struct device *dev;
 +	int ret = 0;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, info->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	dev = ice_pf_to_dev(pf);
 +	if (!test_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {
 +		dev_err(dev, "Unprivileged VF %d is attempting to configure promiscuous mode\n",
 +			vf->vf_id);
 +		/* Leave v_ret alone, lie to the VF on purpose. */
 +		goto error_param;
 +	}
 +
 +	if (info->flags & FLAG_VF_UNICAST_PROMISC)
 +		alluni = true;
 +
 +	if (info->flags & FLAG_VF_MULTICAST_PROMISC)
 +		allmulti = true;
 +
 +	rm_promisc = !allmulti && !alluni;
 +
 +	if (vsi->num_vlan || vf->port_vlan_info) {
 +
 +		if (rm_promisc)
 +			ret = ice_cfg_vlan_pruning(vsi, true);
 +		else
 +			ret = ice_cfg_vlan_pruning(vsi, false);
 +		if (ret) {
 +			dev_err(dev, "Failed to configure VLAN pruning in promiscuous mode\n");
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +	}
 +
++	if (ice_vf_is_port_vlan_ena(vf) ||
++	    ice_vsi_has_non_zero_vlans(vsi)) {
++		mcast_m = ICE_MCAST_VLAN_PROMISC_BITS;
++		ucast_m = ICE_UCAST_VLAN_PROMISC_BITS;
++	} else {
++		mcast_m = ICE_MCAST_PROMISC_BITS;
++		ucast_m = ICE_UCAST_PROMISC_BITS;
++	}
++
 +	if (!test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags)) {
- 		bool set_dflt_vsi = alluni || allmulti;
++		if (alluni) {
++			/* in this case we're turning on promiscuous mode */
++			ret = ice_set_dflt_vsi(vsi);
++		} else {
++			/* in this case we're turning off promiscuous mode */
++			if (ice_is_dflt_vsi_in_use(vsi->port_info))
++				ret = ice_clear_dflt_vsi(vsi);
++		}
 +
- 		if (set_dflt_vsi && !ice_is_dflt_vsi_in_use(pf->first_sw))
- 			/* only attempt to set the default forwarding VSI if
- 			 * it's not currently set
- 			 */
- 			ret = ice_set_dflt_vsi(pf->first_sw, vsi);
- 		else if (!set_dflt_vsi &&
- 			 ice_is_vsi_dflt_vsi(pf->first_sw, vsi))
- 			/* only attempt to free the default forwarding VSI if we
- 			 * are the owner
- 			 */
- 			ret = ice_clear_dflt_vsi(pf->first_sw);
++		/* in this case we're turning on/off only
++		 * allmulticast
++		 */
++		if (allmulti)
++			mcast_err = ice_vf_set_vsi_promisc(vf, vsi, mcast_m);
++		else
++			mcast_err = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);
 +
 +		if (ret) {
- 			dev_err(dev, "%sable VF %d as the default VSI failed, error %d\n",
- 				set_dflt_vsi ? "en" : "dis", vf->vf_id, ret);
++			dev_err(dev, "Turning on/off promiscuous mode for VF %d failed, error: %d\n",
++				vf->vf_id, ret);
 +			v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 +			goto error_param;
 +		}
 +	} else {
++<<<<<<< HEAD:drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
 +		u8 mcast_m, ucast_m;
 +
 +		if (vf->port_vlan_info || vsi->num_vlan > 1) {
 +			mcast_m = ICE_MCAST_VLAN_PROMISC_BITS;
 +			ucast_m = ICE_UCAST_VLAN_PROMISC_BITS;
 +		} else {
 +			mcast_m = ICE_MCAST_PROMISC_BITS;
 +			ucast_m = ICE_UCAST_PROMISC_BITS;
 +		}
 +
++=======
++>>>>>>> d7393425e7c8 (ice: Introduce enabling promiscuous mode on multiple VF's):drivers/net/ethernet/intel/ice/ice_virtchnl.c
 +		if (alluni)
 +			ucast_err = ice_vf_set_vsi_promisc(vf, vsi, ucast_m);
 +		else
 +			ucast_err = ice_vf_clear_vsi_promisc(vf, vsi, ucast_m);
 +
 +		if (allmulti)
 +			mcast_err = ice_vf_set_vsi_promisc(vf, vsi, mcast_m);
 +		else
 +			mcast_err = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);
 +
 +		if (ucast_err || mcast_err)
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +	}
 +
 +	if (!mcast_err) {
 +		if (allmulti &&
 +		    !test_and_set_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 +			dev_info(dev, "VF %u successfully set multicast promiscuous mode\n",
 +				 vf->vf_id);
 +		else if (!allmulti && test_and_clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 +			dev_info(dev, "VF %u successfully unset multicast promiscuous mode\n",
 +				 vf->vf_id);
++	} else {
++		dev_err(dev, "Error while modifying multicast promiscuous mode for VF %u, error: %d\n",
++			vf->vf_id, mcast_err);
 +	}
 +
 +	if (!ucast_err) {
 +		if (alluni && !test_and_set_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))
 +			dev_info(dev, "VF %u successfully set unicast promiscuous mode\n",
 +				 vf->vf_id);
 +		else if (!alluni && test_and_clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))
 +			dev_info(dev, "VF %u successfully unset unicast promiscuous mode\n",
 +				 vf->vf_id);
++	} else {
++		dev_err(dev, "Error while modifying unicast promiscuous mode for VF %u, error: %d\n",
++			vf->vf_id, ucast_err);
 +	}
 +
 +error_param:
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,
 +				     v_ret, NULL, 0);
 +}
 +
 +/**
 + * ice_vc_get_stats_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * called from the VF to get VSI stats
 + */
 +static int ice_vc_get_stats_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_queue_select *vqs =
 +		(struct virtchnl_queue_select *)msg;
 +	struct ice_eth_stats stats = { 0 };
 +	struct ice_vsi *vsi;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	ice_update_eth_stats(vsi);
 +
 +	stats = vsi->eth_stats;
 +
 +error_param:
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_STATS, v_ret,
 +				     (u8 *)&stats, sizeof(stats));
 +}
 +
 +/**
 + * ice_vc_validate_vqs_bitmaps - validate Rx/Tx queue bitmaps from VIRTCHNL
 + * @vqs: virtchnl_queue_select structure containing bitmaps to validate
 + *
 + * Return true on successful validation, else false
 + */
 +static bool ice_vc_validate_vqs_bitmaps(struct virtchnl_queue_select *vqs)
 +{
 +	if ((!vqs->rx_queues && !vqs->tx_queues) ||
 +	    vqs->rx_queues >= BIT(ICE_MAX_RSS_QS_PER_VF) ||
 +	    vqs->tx_queues >= BIT(ICE_MAX_RSS_QS_PER_VF))
 +		return false;
 +
 +	return true;
 +}
 +
 +/**
 + * ice_vf_ena_txq_interrupt - enable Tx queue interrupt via QINT_TQCTL
 + * @vsi: VSI of the VF to configure
 + * @q_idx: VF queue index used to determine the queue in the PF's space
 + */
 +static void ice_vf_ena_txq_interrupt(struct ice_vsi *vsi, u32 q_idx)
 +{
 +	struct ice_hw *hw = &vsi->back->hw;
 +	u32 pfq = vsi->txq_map[q_idx];
 +	u32 reg;
 +
 +	reg = rd32(hw, QINT_TQCTL(pfq));
 +
 +	/* MSI-X index 0 in the VF's space is always for the OICR, which means
 +	 * this is most likely a poll mode VF driver, so don't enable an
 +	 * interrupt that was never configured via VIRTCHNL_OP_CONFIG_IRQ_MAP
 +	 */
 +	if (!(reg & QINT_TQCTL_MSIX_INDX_M))
 +		return;
 +
 +	wr32(hw, QINT_TQCTL(pfq), reg | QINT_TQCTL_CAUSE_ENA_M);
 +}
 +
 +/**
 + * ice_vf_ena_rxq_interrupt - enable Tx queue interrupt via QINT_RQCTL
 + * @vsi: VSI of the VF to configure
 + * @q_idx: VF queue index used to determine the queue in the PF's space
 + */
 +static void ice_vf_ena_rxq_interrupt(struct ice_vsi *vsi, u32 q_idx)
 +{
 +	struct ice_hw *hw = &vsi->back->hw;
 +	u32 pfq = vsi->rxq_map[q_idx];
 +	u32 reg;
 +
 +	reg = rd32(hw, QINT_RQCTL(pfq));
 +
 +	/* MSI-X index 0 in the VF's space is always for the OICR, which means
 +	 * this is most likely a poll mode VF driver, so don't enable an
 +	 * interrupt that was never configured via VIRTCHNL_OP_CONFIG_IRQ_MAP
 +	 */
 +	if (!(reg & QINT_RQCTL_MSIX_INDX_M))
 +		return;
 +
 +	wr32(hw, QINT_RQCTL(pfq), reg | QINT_RQCTL_CAUSE_ENA_M);
 +}
 +
 +/**
 + * ice_vc_ena_qs_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * called from the VF to enable all or specific queue(s)
 + */
 +static int ice_vc_ena_qs_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_queue_select *vqs =
 +	    (struct virtchnl_queue_select *)msg;
 +	struct ice_vsi *vsi;
 +	unsigned long q_map;
 +	u16 vf_q_id;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_validate_vqs_bitmaps(vqs)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	/* Enable only Rx rings, Tx rings were enabled by the FW when the
 +	 * Tx queue group list was configured and the context bits were
 +	 * programmed using ice_vsi_cfg_txqs
 +	 */
 +	q_map = vqs->rx_queues;
 +	for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 +		if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		/* Skip queue if enabled */
 +		if (test_bit(vf_q_id, vf->rxq_ena))
 +			continue;
 +
 +		if (ice_vsi_ctrl_one_rx_ring(vsi, true, vf_q_id, true)) {
 +			dev_err(ice_pf_to_dev(vsi->back), "Failed to enable Rx ring %d on VSI %d\n",
 +				vf_q_id, vsi->vsi_num);
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		ice_vf_ena_rxq_interrupt(vsi, vf_q_id);
 +		set_bit(vf_q_id, vf->rxq_ena);
 +	}
 +
 +	q_map = vqs->tx_queues;
 +	for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 +		if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		/* Skip queue if enabled */
 +		if (test_bit(vf_q_id, vf->txq_ena))
 +			continue;
 +
 +		ice_vf_ena_txq_interrupt(vsi, vf_q_id);
 +		set_bit(vf_q_id, vf->txq_ena);
 +	}
 +
 +	/* Set flag to indicate that queues are enabled */
 +	if (v_ret == VIRTCHNL_STATUS_SUCCESS)
 +		set_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);
 +
 +error_param:
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_QUEUES, v_ret,
 +				     NULL, 0);
 +}
 +
 +/**
 + * ice_vf_vsi_dis_single_txq - disable a single Tx queue
 + * @vf: VF to disable queue for
 + * @vsi: VSI for the VF
 + * @q_id: VF relative (0-based) queue ID
 + *
 + * Attempt to disable the Tx queue passed in. If the Tx queue was successfully
 + * disabled then clear q_id bit in the enabled queues bitmap and return
 + * success. Otherwise return error.
 + */
 +static int
 +ice_vf_vsi_dis_single_txq(struct ice_vf *vf, struct ice_vsi *vsi, u16 q_id)
 +{
 +	struct ice_txq_meta txq_meta = { 0 };
 +	struct ice_tx_ring *ring;
 +	int err;
 +
 +	if (!test_bit(q_id, vf->txq_ena))
 +		dev_dbg(ice_pf_to_dev(vsi->back), "Queue %u on VSI %u is not enabled, but stopping it anyway\n",
 +			q_id, vsi->vsi_num);
 +
 +	ring = vsi->tx_rings[q_id];
 +	if (!ring)
 +		return -EINVAL;
 +
 +	ice_fill_txq_meta(vsi, ring, &txq_meta);
 +
 +	err = ice_vsi_stop_tx_ring(vsi, ICE_NO_RESET, vf->vf_id, ring, &txq_meta);
 +	if (err) {
 +		dev_err(ice_pf_to_dev(vsi->back), "Failed to stop Tx ring %d on VSI %d\n",
 +			q_id, vsi->vsi_num);
 +		return err;
 +	}
 +
 +	/* Clear enabled queues flag */
 +	clear_bit(q_id, vf->txq_ena);
 +
 +	return 0;
 +}
 +
 +/**
 + * ice_vc_dis_qs_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * called from the VF to disable all or specific queue(s)
 + */
 +static int ice_vc_dis_qs_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_queue_select *vqs =
 +	    (struct virtchnl_queue_select *)msg;
 +	struct ice_vsi *vsi;
 +	unsigned long q_map;
 +	u16 vf_q_id;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) &&
 +	    !test_bit(ICE_VF_STATE_QS_ENA, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_validate_vqs_bitmaps(vqs)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (vqs->tx_queues) {
 +		q_map = vqs->tx_queues;
 +
 +		for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 +			if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 +				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +				goto error_param;
 +			}
 +
 +			if (ice_vf_vsi_dis_single_txq(vf, vsi, vf_q_id)) {
 +				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +				goto error_param;
 +			}
 +		}
 +	}
 +
 +	q_map = vqs->rx_queues;
 +	/* speed up Rx queue disable by batching them if possible */
 +	if (q_map &&
 +	    bitmap_equal(&q_map, vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF)) {
 +		if (ice_vsi_stop_all_rx_rings(vsi)) {
 +			dev_err(ice_pf_to_dev(vsi->back), "Failed to stop all Rx rings on VSI %d\n",
 +				vsi->vsi_num);
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		bitmap_zero(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF);
 +	} else if (q_map) {
 +		for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 +			if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 +				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +				goto error_param;
 +			}
 +
 +			/* Skip queue if not enabled */
 +			if (!test_bit(vf_q_id, vf->rxq_ena))
 +				continue;
 +
 +			if (ice_vsi_ctrl_one_rx_ring(vsi, false, vf_q_id,
 +						     true)) {
 +				dev_err(ice_pf_to_dev(vsi->back), "Failed to stop Rx ring %d on VSI %d\n",
 +					vf_q_id, vsi->vsi_num);
 +				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +				goto error_param;
 +			}
 +
 +			/* Clear enabled queues flag */
 +			clear_bit(vf_q_id, vf->rxq_ena);
 +		}
 +	}
 +
 +	/* Clear enabled queues flag */
 +	if (v_ret == VIRTCHNL_STATUS_SUCCESS && ice_vf_has_no_qs_ena(vf))
 +		clear_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);
 +
 +error_param:
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_QUEUES, v_ret,
 +				     NULL, 0);
 +}
 +
 +/**
 + * ice_cfg_interrupt
 + * @vf: pointer to the VF info
 + * @vsi: the VSI being configured
 + * @vector_id: vector ID
 + * @map: vector map for mapping vectors to queues
 + * @q_vector: structure for interrupt vector
 + * configure the IRQ to queue map
 + */
 +static int
 +ice_cfg_interrupt(struct ice_vf *vf, struct ice_vsi *vsi, u16 vector_id,
 +		  struct virtchnl_vector_map *map,
 +		  struct ice_q_vector *q_vector)
 +{
 +	u16 vsi_q_id, vsi_q_id_idx;
 +	unsigned long qmap;
 +
 +	q_vector->num_ring_rx = 0;
 +	q_vector->num_ring_tx = 0;
 +
 +	qmap = map->rxq_map;
 +	for_each_set_bit(vsi_q_id_idx, &qmap, ICE_MAX_RSS_QS_PER_VF) {
 +		vsi_q_id = vsi_q_id_idx;
 +
 +		if (!ice_vc_isvalid_q_id(vf, vsi->vsi_num, vsi_q_id))
 +			return VIRTCHNL_STATUS_ERR_PARAM;
 +
 +		q_vector->num_ring_rx++;
 +		q_vector->rx.itr_idx = map->rxitr_idx;
 +		vsi->rx_rings[vsi_q_id]->q_vector = q_vector;
 +		ice_cfg_rxq_interrupt(vsi, vsi_q_id, vector_id,
 +				      q_vector->rx.itr_idx);
 +	}
 +
 +	qmap = map->txq_map;
 +	for_each_set_bit(vsi_q_id_idx, &qmap, ICE_MAX_RSS_QS_PER_VF) {
 +		vsi_q_id = vsi_q_id_idx;
 +
 +		if (!ice_vc_isvalid_q_id(vf, vsi->vsi_num, vsi_q_id))
 +			return VIRTCHNL_STATUS_ERR_PARAM;
 +
 +		q_vector->num_ring_tx++;
 +		q_vector->tx.itr_idx = map->txitr_idx;
 +		vsi->tx_rings[vsi_q_id]->q_vector = q_vector;
 +		ice_cfg_txq_interrupt(vsi, vsi_q_id, vector_id,
 +				      q_vector->tx.itr_idx);
 +	}
 +
 +	return VIRTCHNL_STATUS_SUCCESS;
 +}
 +
 +/**
 + * ice_vc_cfg_irq_map_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * called from the VF to configure the IRQ to queue map
 + */
 +static int ice_vc_cfg_irq_map_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	u16 num_q_vectors_mapped, vsi_id, vector_id;
 +	struct virtchnl_irq_map_info *irqmap_info;
 +	struct virtchnl_vector_map *map;
 +	struct ice_pf *pf = vf->pf;
 +	struct ice_vsi *vsi;
 +	int i;
 +
 +	irqmap_info = (struct virtchnl_irq_map_info *)msg;
 +	num_q_vectors_mapped = irqmap_info->num_vectors;
 +
 +	/* Check to make sure number of VF vectors mapped is not greater than
 +	 * number of VF vectors originally allocated, and check that
 +	 * there is actually at least a single VF queue vector mapped
 +	 */
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||
 +	    pf->num_msix_per_vf < num_q_vectors_mapped ||
 +	    !num_q_vectors_mapped) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	for (i = 0; i < num_q_vectors_mapped; i++) {
 +		struct ice_q_vector *q_vector;
 +
 +		map = &irqmap_info->vecmap[i];
 +
 +		vector_id = map->vector_id;
 +		vsi_id = map->vsi_id;
 +		/* vector_id is always 0-based for each VF, and can never be
 +		 * larger than or equal to the max allowed interrupts per VF
 +		 */
 +		if (!(vector_id < pf->num_msix_per_vf) ||
 +		    !ice_vc_isvalid_vsi_id(vf, vsi_id) ||
 +		    (!vector_id && (map->rxq_map || map->txq_map))) {
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		/* No need to map VF miscellaneous or rogue vector */
 +		if (!vector_id)
 +			continue;
 +
 +		/* Subtract non queue vector from vector_id passed by VF
 +		 * to get actual number of VSI queue vector array index
 +		 */
 +		q_vector = vsi->q_vectors[vector_id - ICE_NONQ_VECS_VF];
 +		if (!q_vector) {
 +			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +			goto error_param;
 +		}
 +
 +		/* lookout for the invalid queue index */
 +		v_ret = (enum virtchnl_status_code)
 +			ice_cfg_interrupt(vf, vsi, vector_id, map, q_vector);
 +		if (v_ret)
 +			goto error_param;
 +	}
 +
 +error_param:
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_IRQ_MAP, v_ret,
 +				     NULL, 0);
 +}
 +
 +/**
 + * ice_vc_cfg_qs_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * called from the VF to configure the Rx/Tx queues
 + */
 +static int ice_vc_cfg_qs_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	struct virtchnl_vsi_queue_config_info *qci =
 +	    (struct virtchnl_vsi_queue_config_info *)msg;
 +	struct virtchnl_queue_pair_info *qpi;
 +	struct ice_pf *pf = vf->pf;
 +	struct ice_vsi *vsi;
 +	int i = -1, q_idx;
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states))
 +		goto error_param;
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, qci->vsi_id))
 +		goto error_param;
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi)
 +		goto error_param;
 +
 +	if (qci->num_queue_pairs > ICE_MAX_RSS_QS_PER_VF ||
 +	    qci->num_queue_pairs > min_t(u16, vsi->alloc_txq, vsi->alloc_rxq)) {
 +		dev_err(ice_pf_to_dev(pf), "VF-%d requesting more than supported number of queues: %d\n",
 +			vf->vf_id, min_t(u16, vsi->alloc_txq, vsi->alloc_rxq));
 +		goto error_param;
 +	}
 +
 +	for (i = 0; i < qci->num_queue_pairs; i++) {
 +		qpi = &qci->qpair[i];
 +		if (qpi->txq.vsi_id != qci->vsi_id ||
 +		    qpi->rxq.vsi_id != qci->vsi_id ||
 +		    qpi->rxq.queue_id != qpi->txq.queue_id ||
 +		    qpi->txq.headwb_enabled ||
 +		    !ice_vc_isvalid_ring_len(qpi->txq.ring_len) ||
 +		    !ice_vc_isvalid_ring_len(qpi->rxq.ring_len) ||
 +		    !ice_vc_isvalid_q_id(vf, qci->vsi_id, qpi->txq.queue_id)) {
 +			goto error_param;
 +		}
 +
 +		q_idx = qpi->rxq.queue_id;
 +
 +		/* make sure selected "q_idx" is in valid range of queues
 +		 * for selected "vsi"
 +		 */
 +		if (q_idx >= vsi->alloc_txq || q_idx >= vsi->alloc_rxq) {
 +			goto error_param;
 +		}
 +
 +		/* copy Tx queue info from VF into VSI */
 +		if (qpi->txq.ring_len > 0) {
 +			vsi->tx_rings[i]->dma = qpi->txq.dma_ring_addr;
 +			vsi->tx_rings[i]->count = qpi->txq.ring_len;
 +
 +			/* Disable any existing queue first */
 +			if (ice_vf_vsi_dis_single_txq(vf, vsi, q_idx))
 +				goto error_param;
 +
 +			/* Configure a queue with the requested settings */
 +			if (ice_vsi_cfg_single_txq(vsi, vsi->tx_rings, q_idx)) {
 +				dev_warn(ice_pf_to_dev(pf), "VF-%d failed to configure TX queue %d\n",
 +					 vf->vf_id, i);
 +				goto error_param;
 +			}
 +		}
 +
 +		/* copy Rx queue info from VF into VSI */
 +		if (qpi->rxq.ring_len > 0) {
 +			u16 max_frame_size = ice_vc_get_max_frame_size(vf);
 +
 +			vsi->rx_rings[i]->dma = qpi->rxq.dma_ring_addr;
 +			vsi->rx_rings[i]->count = qpi->rxq.ring_len;
 +
 +			if (qpi->rxq.databuffer_size != 0 &&
 +			    (qpi->rxq.databuffer_size > ((16 * 1024) - 128) ||
 +			     qpi->rxq.databuffer_size < 1024))
 +				goto error_param;
 +			vsi->rx_buf_len = qpi->rxq.databuffer_size;
 +			vsi->rx_rings[i]->rx_buf_len = vsi->rx_buf_len;
 +			if (qpi->rxq.max_pkt_size > max_frame_size ||
 +			    qpi->rxq.max_pkt_size < 64)
 +				goto error_param;
 +
 +			vsi->max_frame = qpi->rxq.max_pkt_size;
 +			/* add space for the port VLAN since the VF driver is not
 +			 * expected to account for it in the MTU calculation
 +			 */
 +			if (vf->port_vlan_info)
 +				vsi->max_frame += VLAN_HLEN;
 +
 +			if (ice_vsi_cfg_single_rxq(vsi, q_idx)) {
 +				dev_warn(ice_pf_to_dev(pf), "VF-%d failed to configure RX queue %d\n",
 +					 vf->vf_id, i);
 +				goto error_param;
 +			}
 +		}
 +	}
 +
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,
 +				     VIRTCHNL_STATUS_SUCCESS, NULL, 0);
 +error_param:
 +	/* disable whatever we can */
 +	for (; i >= 0; i--) {
 +		if (ice_vsi_ctrl_one_rx_ring(vsi, false, i, true))
 +			dev_err(ice_pf_to_dev(pf), "VF-%d could not disable RX queue %d\n",
 +				vf->vf_id, i);
 +		if (ice_vf_vsi_dis_single_txq(vf, vsi, i))
 +			dev_err(ice_pf_to_dev(pf), "VF-%d could not disable TX queue %d\n",
 +				vf->vf_id, i);
 +	}
 +
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,
 +				     VIRTCHNL_STATUS_ERR_PARAM, NULL, 0);
 +}
 +
 +/**
 + * ice_is_vf_trusted
 + * @vf: pointer to the VF info
 + */
 +static bool ice_is_vf_trusted(struct ice_vf *vf)
 +{
 +	return test_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
 +}
 +
 +/**
 + * ice_can_vf_change_mac
 + * @vf: pointer to the VF info
 + *
 + * Return true if the VF is allowed to change its MAC filters, false otherwise
 + */
 +static bool ice_can_vf_change_mac(struct ice_vf *vf)
 +{
 +	/* If the VF MAC address has been set administratively (via the
 +	 * ndo_set_vf_mac command), then deny permission to the VF to
 +	 * add/delete unicast MAC addresses, unless the VF is trusted
 +	 */
 +	if (vf->pf_set_mac && !ice_is_vf_trusted(vf))
 +		return false;
 +
 +	return true;
 +}
 +
 +/**
 + * ice_vc_ether_addr_type - get type of virtchnl_ether_addr
 + * @vc_ether_addr: used to extract the type
 + */
 +static u8
 +ice_vc_ether_addr_type(struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	return (vc_ether_addr->type & VIRTCHNL_ETHER_ADDR_TYPE_MASK);
 +}
 +
 +/**
 + * ice_is_vc_addr_legacy - check if the MAC address is from an older VF
 + * @vc_ether_addr: VIRTCHNL structure that contains MAC and type
 + */
 +static bool
 +ice_is_vc_addr_legacy(struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	u8 type = ice_vc_ether_addr_type(vc_ether_addr);
 +
 +	return (type == VIRTCHNL_ETHER_ADDR_LEGACY);
 +}
 +
 +/**
 + * ice_is_vc_addr_primary - check if the MAC address is the VF's primary MAC
 + * @vc_ether_addr: VIRTCHNL structure that contains MAC and type
 + *
 + * This function should only be called when the MAC address in
 + * virtchnl_ether_addr is a valid unicast MAC
 + */
 +static bool
 +ice_is_vc_addr_primary(struct virtchnl_ether_addr __maybe_unused *vc_ether_addr)
 +{
 +	u8 type = ice_vc_ether_addr_type(vc_ether_addr);
 +
 +	return (type == VIRTCHNL_ETHER_ADDR_PRIMARY);
 +}
 +
 +/**
 + * ice_vfhw_mac_add - update the VF's cached hardware MAC if allowed
 + * @vf: VF to update
 + * @vc_ether_addr: structure from VIRTCHNL with MAC to add
 + */
 +static void
 +ice_vfhw_mac_add(struct ice_vf *vf, struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	u8 *mac_addr = vc_ether_addr->addr;
 +
 +	if (!is_valid_ether_addr(mac_addr))
 +		return;
 +
 +	/* only allow legacy VF drivers to set the device and hardware MAC if it
 +	 * is zero and allow new VF drivers to set the hardware MAC if the type
 +	 * was correctly specified over VIRTCHNL
 +	 */
 +	if ((ice_is_vc_addr_legacy(vc_ether_addr) &&
 +	     is_zero_ether_addr(vf->hw_lan_addr.addr)) ||
 +	    ice_is_vc_addr_primary(vc_ether_addr)) {
 +		ether_addr_copy(vf->dev_lan_addr.addr, mac_addr);
 +		ether_addr_copy(vf->hw_lan_addr.addr, mac_addr);
 +	}
 +
 +	/* hardware and device MACs are already set, but its possible that the
 +	 * VF driver sent the VIRTCHNL_OP_ADD_ETH_ADDR message before the
 +	 * VIRTCHNL_OP_DEL_ETH_ADDR when trying to update its MAC, so save it
 +	 * away for the legacy VF driver case as it will be updated in the
 +	 * delete flow for this case
 +	 */
 +	if (ice_is_vc_addr_legacy(vc_ether_addr)) {
 +		ether_addr_copy(vf->legacy_last_added_umac.addr,
 +				mac_addr);
 +		vf->legacy_last_added_umac.time_modified = jiffies;
 +	}
 +}
 +
 +/**
 + * ice_vc_add_mac_addr - attempt to add the MAC address passed in
 + * @vf: pointer to the VF info
 + * @vsi: pointer to the VF's VSI
 + * @vc_ether_addr: VIRTCHNL MAC address structure used to add MAC
 + */
 +static int
 +ice_vc_add_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi,
 +		    struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	struct device *dev = ice_pf_to_dev(vf->pf);
 +	u8 *mac_addr = vc_ether_addr->addr;
 +	int ret;
 +
 +	/* device MAC already added */
 +	if (ether_addr_equal(mac_addr, vf->dev_lan_addr.addr))
 +		return 0;
 +
 +	if (is_unicast_ether_addr(mac_addr) && !ice_can_vf_change_mac(vf)) {
 +		dev_err(dev, "VF attempting to override administratively set MAC address, bring down and up the VF interface to resume normal operation\n");
 +		return -EPERM;
 +	}
 +
 +	ret = ice_fltr_add_mac(vsi, mac_addr, ICE_FWD_TO_VSI);
 +	if (ret == -EEXIST) {
 +		dev_dbg(dev, "MAC %pM already exists for VF %d\n", mac_addr,
 +			vf->vf_id);
 +		/* don't return since we might need to update
 +		 * the primary MAC in ice_vfhw_mac_add() below
 +		 */
 +	} else if (ret) {
 +		dev_err(dev, "Failed to add MAC %pM for VF %d\n, error %d\n",
 +			mac_addr, vf->vf_id, ret);
 +		return ret;
 +	} else {
 +		vf->num_mac++;
 +	}
 +
 +	ice_vfhw_mac_add(vf, vc_ether_addr);
 +
 +	return ret;
 +}
 +
 +/**
 + * ice_is_legacy_umac_expired - check if last added legacy unicast MAC expired
 + * @last_added_umac: structure used to check expiration
 + */
 +static bool ice_is_legacy_umac_expired(struct ice_time_mac *last_added_umac)
 +{
 +#define ICE_LEGACY_VF_MAC_CHANGE_EXPIRE_TIME	msecs_to_jiffies(3000)
 +	return time_is_before_jiffies(last_added_umac->time_modified +
 +				      ICE_LEGACY_VF_MAC_CHANGE_EXPIRE_TIME);
 +}
 +
 +/**
 + * ice_update_legacy_cached_mac - update cached hardware MAC for legacy VF
 + * @vf: VF to update
 + * @vc_ether_addr: structure from VIRTCHNL with MAC to check
 + *
 + * only update cached hardware MAC for legacy VF drivers on delete
 + * because we cannot guarantee order/type of MAC from the VF driver
 + */
 +static void
 +ice_update_legacy_cached_mac(struct ice_vf *vf,
 +			     struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	if (!ice_is_vc_addr_legacy(vc_ether_addr) ||
 +	    ice_is_legacy_umac_expired(&vf->legacy_last_added_umac))
 +		return;
 +
 +	ether_addr_copy(vf->dev_lan_addr.addr, vf->legacy_last_added_umac.addr);
 +	ether_addr_copy(vf->hw_lan_addr.addr, vf->legacy_last_added_umac.addr);
 +}
 +
 +/**
 + * ice_vfhw_mac_del - update the VF's cached hardware MAC if allowed
 + * @vf: VF to update
 + * @vc_ether_addr: structure from VIRTCHNL with MAC to delete
 + */
 +static void
 +ice_vfhw_mac_del(struct ice_vf *vf, struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	u8 *mac_addr = vc_ether_addr->addr;
 +
 +	if (!is_valid_ether_addr(mac_addr) ||
 +	    !ether_addr_equal(vf->dev_lan_addr.addr, mac_addr))
 +		return;
 +
 +	/* allow the device MAC to be repopulated in the add flow and don't
 +	 * clear the hardware MAC (i.e. hw_lan_addr.addr) here as that is meant
 +	 * to be persistent on VM reboot and across driver unload/load, which
 +	 * won't work if we clear the hardware MAC here
 +	 */
 +	eth_zero_addr(vf->dev_lan_addr.addr);
 +
 +	ice_update_legacy_cached_mac(vf, vc_ether_addr);
 +}
 +
 +/**
 + * ice_vc_del_mac_addr - attempt to delete the MAC address passed in
 + * @vf: pointer to the VF info
 + * @vsi: pointer to the VF's VSI
 + * @vc_ether_addr: VIRTCHNL MAC address structure used to delete MAC
 + */
 +static int
 +ice_vc_del_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi,
 +		    struct virtchnl_ether_addr *vc_ether_addr)
 +{
 +	struct device *dev = ice_pf_to_dev(vf->pf);
 +	u8 *mac_addr = vc_ether_addr->addr;
 +	int status;
 +
 +	if (!ice_can_vf_change_mac(vf) &&
 +	    ether_addr_equal(vf->dev_lan_addr.addr, mac_addr))
 +		return 0;
 +
 +	status = ice_fltr_remove_mac(vsi, mac_addr, ICE_FWD_TO_VSI);
 +	if (status == -ENOENT) {
 +		dev_err(dev, "MAC %pM does not exist for VF %d\n", mac_addr,
 +			vf->vf_id);
 +		return -ENOENT;
 +	} else if (status) {
 +		dev_err(dev, "Failed to delete MAC %pM for VF %d, error %d\n",
 +			mac_addr, vf->vf_id, status);
 +		return -EIO;
 +	}
 +
 +	ice_vfhw_mac_del(vf, vc_ether_addr);
 +
 +	vf->num_mac--;
 +
 +	return 0;
 +}
 +
 +/**
 + * ice_vc_handle_mac_addr_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + * @set: true if MAC filters are being set, false otherwise
 + *
 + * add guest MAC address filter
 + */
 +static int
 +ice_vc_handle_mac_addr_msg(struct ice_vf *vf, u8 *msg, bool set)
 +{
 +	int (*ice_vc_cfg_mac)
 +		(struct ice_vf *vf, struct ice_vsi *vsi,
 +		 struct virtchnl_ether_addr *virtchnl_ether_addr);
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_ether_addr_list *al =
 +	    (struct virtchnl_ether_addr_list *)msg;
 +	struct ice_pf *pf = vf->pf;
 +	enum virtchnl_ops vc_op;
 +	struct ice_vsi *vsi;
 +	int i;
 +
 +	if (set) {
 +		vc_op = VIRTCHNL_OP_ADD_ETH_ADDR;
 +		ice_vc_cfg_mac = ice_vc_add_mac_addr;
 +	} else {
 +		vc_op = VIRTCHNL_OP_DEL_ETH_ADDR;
 +		ice_vc_cfg_mac = ice_vc_del_mac_addr;
 +	}
 +
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||
 +	    !ice_vc_isvalid_vsi_id(vf, al->vsi_id)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto handle_mac_exit;
 +	}
 +
 +	/* If this VF is not privileged, then we can't add more than a
 +	 * limited number of addresses. Check to make sure that the
 +	 * additions do not push us over the limit.
 +	 */
 +	if (set && !ice_is_vf_trusted(vf) &&
 +	    (vf->num_mac + al->num_elements) > ICE_MAX_MACADDR_PER_VF) {
 +		dev_err(ice_pf_to_dev(pf), "Can't add more MAC addresses, because VF-%d is not trusted, switch the VF to trusted mode in order to add more functionalities\n",
 +			vf->vf_id);
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto handle_mac_exit;
 +	}
 +
 +	vsi = ice_get_vf_vsi(vf);
 +	if (!vsi) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto handle_mac_exit;
 +	}
 +
 +	for (i = 0; i < al->num_elements; i++) {
 +		u8 *mac_addr = al->list[i].addr;
 +		int result;
 +
 +		if (is_broadcast_ether_addr(mac_addr) ||
 +		    is_zero_ether_addr(mac_addr))
 +			continue;
 +
 +		result = ice_vc_cfg_mac(vf, vsi, &al->list[i]);
 +		if (result == -EEXIST || result == -ENOENT) {
 +			continue;
 +		} else if (result) {
 +			v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 +			goto handle_mac_exit;
 +		}
 +	}
 +
 +handle_mac_exit:
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, vc_op, v_ret, NULL, 0);
 +}
 +
 +/**
 + * ice_vc_add_mac_addr_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * add guest MAC address filter
 + */
 +static int ice_vc_add_mac_addr_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	return ice_vc_handle_mac_addr_msg(vf, msg, true);
 +}
 +
 +/**
 + * ice_vc_del_mac_addr_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * remove guest MAC address filter
 + */
 +static int ice_vc_del_mac_addr_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	return ice_vc_handle_mac_addr_msg(vf, msg, false);
 +}
 +
 +/**
 + * ice_vc_request_qs_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + *
 + * VFs get a default number of queues but can use this message to request a
 + * different number. If the request is successful, PF will reset the VF and
 + * return 0. If unsuccessful, PF will send message informing VF of number of
 + * available queue pairs via virtchnl message response to VF.
 + */
 +static int ice_vc_request_qs_msg(struct ice_vf *vf, u8 *msg)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_vf_res_request *vfres =
 +		(struct virtchnl_vf_res_request *)msg;
 +	u16 req_queues = vfres->num_queue_pairs;
 +	struct ice_pf *pf = vf->pf;
 +	u16 max_allowed_vf_queues;
 +	u16 tx_rx_queue_left;
 +	struct device *dev;
 +	u16 cur_queues;
 +
 +	dev = ice_pf_to_dev(pf);
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	cur_queues = vf->num_vf_qs;
 +	tx_rx_queue_left = min_t(u16, ice_get_avail_txq_count(pf),
 +				 ice_get_avail_rxq_count(pf));
 +	max_allowed_vf_queues = tx_rx_queue_left + cur_queues;
 +	if (!req_queues) {
 +		dev_err(dev, "VF %d tried to request 0 queues. Ignoring.\n",
 +			vf->vf_id);
 +	} else if (req_queues > ICE_MAX_RSS_QS_PER_VF) {
 +		dev_err(dev, "VF %d tried to request more than %d queues.\n",
 +			vf->vf_id, ICE_MAX_RSS_QS_PER_VF);
 +		vfres->num_queue_pairs = ICE_MAX_RSS_QS_PER_VF;
 +	} else if (req_queues > cur_queues &&
 +		   req_queues - cur_queues > tx_rx_queue_left) {
 +		dev_warn(dev, "VF %d requested %u more queues, but only %u left.\n",
 +			 vf->vf_id, req_queues - cur_queues, tx_rx_queue_left);
 +		vfres->num_queue_pairs = min_t(u16, max_allowed_vf_queues,
 +					       ICE_MAX_RSS_QS_PER_VF);
 +	} else {
 +		/* request is successful, then reset VF */
 +		vf->num_req_qs = req_queues;
 +		ice_vc_reset_vf(vf);
 +		dev_info(dev, "VF %d granted request of %u queues.\n",
 +			 vf->vf_id, req_queues);
 +		return 0;
 +	}
 +
 +error_param:
 +	/* send the response to the VF */
 +	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_REQUEST_QUEUES,
 +				     v_ret, (u8 *)vfres, sizeof(*vfres));
 +}
 +
 +/**
 + * ice_set_vf_port_vlan
 + * @netdev: network interface device structure
 + * @vf_id: VF identifier
 + * @vlan_id: VLAN ID being set
 + * @qos: priority setting
 + * @vlan_proto: VLAN protocol
 + *
 + * program VF Port VLAN ID and/or QoS
 + */
 +int
 +ice_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos,
 +		     __be16 vlan_proto)
 +{
 +	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 +	struct device *dev;
 +	struct ice_vf *vf;
 +	u16 vlanprio;
 +	int ret;
 +
 +	dev = ice_pf_to_dev(pf);
 +	if (ice_validate_vf_id(pf, vf_id))
 +		return -EINVAL;
 +
 +	if (vlan_id >= VLAN_N_VID || qos > 7) {
 +		dev_err(dev, "Invalid Port VLAN parameters for VF %d, ID %d, QoS %d\n",
 +			vf_id, vlan_id, qos);
 +		return -EINVAL;
 +	}
 +
 +	if (vlan_proto != htons(ETH_P_8021Q)) {
 +		dev_err(dev, "VF VLAN protocol is not supported\n");
 +		return -EPROTONOSUPPORT;
 +	}
 +
 +	vf = &pf->vf[vf_id];
 +	ret = ice_check_vf_ready_for_cfg(vf);
 +	if (ret)
 +		return ret;
 +
 +	vlanprio = vlan_id | (qos << VLAN_PRIO_SHIFT);
 +
 +	if (vf->port_vlan_info == vlanprio) {
 +		/* duplicate request, so just return success */
 +		dev_dbg(dev, "Duplicate pvid %d request\n", vlanprio);
 +		return 0;
 +	}
 +
 +	mutex_lock(&vf->cfg_lock);
 +
 +	vf->port_vlan_info = vlanprio;
 +
 +	if (vf->port_vlan_info)
 +		dev_info(dev, "Setting VLAN %d, QoS 0x%x on VF %d\n",
 +			 vlan_id, qos, vf_id);
 +	else
 +		dev_info(dev, "Clearing port VLAN on VF %d\n", vf_id);
 +
 +	ice_vc_reset_vf(vf);
 +	mutex_unlock(&vf->cfg_lock);
 +
 +	return 0;
 +}
 +
 +/**
 + * ice_vf_vlan_offload_ena - determine if capabilities support VLAN offloads
 + * @caps: VF driver negotiated capabilities
 + *
 + * Return true if VIRTCHNL_VF_OFFLOAD_VLAN capability is set, else return false
 + */
 +static bool ice_vf_vlan_offload_ena(u32 caps)
 +{
 +	return !!(caps & VIRTCHNL_VF_OFFLOAD_VLAN);
 +}
 +
 +/**
 + * ice_vc_process_vlan_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + * @add_v: Add VLAN if true, otherwise delete VLAN
 + *
 + * Process virtchnl op to add or remove programmed guest VLAN ID
 + */
 +static int ice_vc_process_vlan_msg(struct ice_vf *vf, u8 *msg, bool add_v)
 +{
 +	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 +	struct virtchnl_vlan_filter_list *vfl =
 +	    (struct virtchnl_vlan_filter_list *)msg;
 +	struct ice_pf *pf = vf->pf;
 +	bool vlan_promisc = false;
 +	struct ice_vsi *vsi;
 +	struct device *dev;
 +	struct ice_hw *hw;
 +	int status = 0;
 +	u8 promisc_m;
 +	int i;
 +
 +	dev = ice_pf_to_dev(pf);
 +	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vf_vlan_offload_ena(vf->driver_caps)) {
 +		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 +		goto error_param;
 +	}
 +
 +	if (!ice_vc_isvalid_vsi_id(vf, vfl->vsi_id)) {
  		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  		goto error_param;
  	}
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_lib.h
diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index dc1d16430838..dfd5288e750b 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -246,8 +246,6 @@ struct ice_sw {
 	struct ice_pf *pf;
 	u16 sw_id;		/* switch ID for this switch */
 	u16 bridge_mode;	/* VEB/VEPA/Port Virtualizer */
-	struct ice_vsi *dflt_vsi;	/* default VSI for this switch */
-	u8 dflt_vsi_ena:1;	/* true if above dflt_vsi is enabled */
 };
 
 enum ice_pf_state {
diff --git a/drivers/net/ethernet/intel/ice/ice_eswitch.c b/drivers/net/ethernet/intel/ice/ice_eswitch.c
index 34a4474731de..d902efcb3d6a 100644
--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c
+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c
@@ -130,8 +130,8 @@ static int ice_eswitch_setup_env(struct ice_pf *pf)
 	if (ice_vsi_add_vlan_zero(uplink_vsi))
 		goto err_def_rx;
 
-	if (!ice_is_dflt_vsi_in_use(uplink_vsi->vsw)) {
-		if (ice_set_dflt_vsi(uplink_vsi->vsw, uplink_vsi))
+	if (!ice_is_dflt_vsi_in_use(uplink_vsi->port_info)) {
+		if (ice_set_dflt_vsi(uplink_vsi))
 			goto err_def_rx;
 		rule_added = true;
 	}
@@ -148,7 +148,7 @@ static int ice_eswitch_setup_env(struct ice_pf *pf)
 	ice_vsi_update_security(uplink_vsi, ice_vsi_ctx_clear_allow_override);
 err_override_uplink:
 	if (rule_added)
-		ice_clear_dflt_vsi(uplink_vsi->vsw);
+		ice_clear_dflt_vsi(uplink_vsi);
 err_def_rx:
 	ice_fltr_add_mac_and_broadcast(uplink_vsi,
 				       uplink_vsi->port_info->mac.perm_addr,
@@ -391,7 +391,7 @@ static void ice_eswitch_release_env(struct ice_pf *pf)
 
 	ice_vsi_update_security(ctrl_vsi, ice_vsi_ctx_clear_allow_override);
 	ice_vsi_update_security(uplink_vsi, ice_vsi_ctx_clear_allow_override);
-	ice_clear_dflt_vsi(uplink_vsi->vsw);
+	ice_clear_dflt_vsi(uplink_vsi);
 	ice_fltr_add_mac_and_broadcast(uplink_vsi,
 				       uplink_vsi->port_info->mac.perm_addr,
 				       ICE_FWD_TO_VSI);
diff --git a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c
index 66783bb3abb7..22d53888bb64 100644
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@ -1290,7 +1290,7 @@ static int ice_set_priv_flags(struct net_device *netdev, u32 flags)
 	 * promiscuous mode because it's not supported
 	 */
 	if (test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, change_flags) &&
-	    ice_is_any_vf_in_promisc(pf)) {
+	    ice_is_any_vf_in_unicast_promisc(pf)) {
 		dev_err(dev, "Changing vf-true-promisc-support flag while VF(s) are in promiscuous mode not supported\n");
 		/* toggle bit back to previous state */
 		change_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags);
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 5661098694e0..34f041550b09 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -3147,8 +3147,8 @@ int ice_vsi_release(struct ice_vsi *vsi)
 		}
 	}
 
-	if (ice_is_vsi_dflt_vsi(pf->first_sw, vsi))
-		ice_clear_dflt_vsi(pf->first_sw);
+	if (ice_is_vsi_dflt_vsi(vsi))
+		ice_clear_dflt_vsi(vsi);
 	ice_fltr_remove_all(vsi);
 	ice_rm_vsi_lan_cfg(vsi->port_info, vsi->idx);
 	err = ice_rm_vsi_rdma_cfg(vsi->port_info, vsi->idx);
@@ -3814,116 +3814,97 @@ void ice_update_rx_ring_stats(struct ice_rx_ring *rx_ring, u64 pkts, u64 bytes)
 
 /**
  * ice_is_dflt_vsi_in_use - check if the default forwarding VSI is being used
- * @sw: switch to check if its default forwarding VSI is free
+ * @pi: port info of the switch with default VSI
  *
- * Return true if the default forwarding VSI is already being used, else returns
- * false signalling that it's available to use.
+ * Return true if the there is a single VSI in default forwarding VSI list
  */
-bool ice_is_dflt_vsi_in_use(struct ice_sw *sw)
+bool ice_is_dflt_vsi_in_use(struct ice_port_info *pi)
 {
-	return (sw->dflt_vsi && sw->dflt_vsi_ena);
+	bool exists = false;
+
+	ice_check_if_dflt_vsi(pi, 0, &exists);
+	return exists;
 }
 
 /**
  * ice_is_vsi_dflt_vsi - check if the VSI passed in is the default VSI
- * @sw: switch for the default forwarding VSI to compare against
  * @vsi: VSI to compare against default forwarding VSI
  *
  * If this VSI passed in is the default forwarding VSI then return true, else
  * return false
  */
-bool ice_is_vsi_dflt_vsi(struct ice_sw *sw, struct ice_vsi *vsi)
+bool ice_is_vsi_dflt_vsi(struct ice_vsi *vsi)
 {
-	return (sw->dflt_vsi == vsi && sw->dflt_vsi_ena);
+	return ice_check_if_dflt_vsi(vsi->port_info, vsi->idx, NULL);
 }
 
 /**
  * ice_set_dflt_vsi - set the default forwarding VSI
- * @sw: switch used to assign the default forwarding VSI
  * @vsi: VSI getting set as the default forwarding VSI on the switch
  *
  * If the VSI passed in is already the default VSI and it's enabled just return
  * success.
  *
- * If there is already a default VSI on the switch and it's enabled then return
- * -EEXIST since there can only be one default VSI per switch.
- *
- *  Otherwise try to set the VSI passed in as the switch's default VSI and
- *  return the result.
+ * Otherwise try to set the VSI passed in as the switch's default VSI and
+ * return the result.
  */
-int ice_set_dflt_vsi(struct ice_sw *sw, struct ice_vsi *vsi)
+int ice_set_dflt_vsi(struct ice_vsi *vsi)
 {
 	struct device *dev;
 	int status;
 
-	if (!sw || !vsi)
+	if (!vsi)
 		return -EINVAL;
 
 	dev = ice_pf_to_dev(vsi->back);
 
 	/* the VSI passed in is already the default VSI */
-	if (ice_is_vsi_dflt_vsi(sw, vsi)) {
+	if (ice_is_vsi_dflt_vsi(vsi)) {
 		dev_dbg(dev, "VSI %d passed in is already the default forwarding VSI, nothing to do\n",
 			vsi->vsi_num);
 		return 0;
 	}
 
-	/* another VSI is already the default VSI for this switch */
-	if (ice_is_dflt_vsi_in_use(sw)) {
-		dev_err(dev, "Default forwarding VSI %d already in use, disable it and try again\n",
-			sw->dflt_vsi->vsi_num);
-		return -EEXIST;
-	}
-
-	status = ice_cfg_dflt_vsi(&vsi->back->hw, vsi->idx, true, ICE_FLTR_RX);
+	status = ice_cfg_dflt_vsi(vsi->port_info, vsi->idx, true, ICE_FLTR_RX);
 	if (status) {
 		dev_err(dev, "Failed to set VSI %d as the default forwarding VSI, error %d\n",
 			vsi->vsi_num, status);
 		return status;
 	}
 
-	sw->dflt_vsi = vsi;
-	sw->dflt_vsi_ena = true;
-
 	return 0;
 }
 
 /**
  * ice_clear_dflt_vsi - clear the default forwarding VSI
- * @sw: switch used to clear the default VSI
+ * @vsi: VSI to remove from filter list
  *
  * If the switch has no default VSI or it's not enabled then return error.
  *
  * Otherwise try to clear the default VSI and return the result.
  */
-int ice_clear_dflt_vsi(struct ice_sw *sw)
+int ice_clear_dflt_vsi(struct ice_vsi *vsi)
 {
-	struct ice_vsi *dflt_vsi;
 	struct device *dev;
 	int status;
 
-	if (!sw)
+	if (!vsi)
 		return -EINVAL;
 
-	dev = ice_pf_to_dev(sw->pf);
-
-	dflt_vsi = sw->dflt_vsi;
+	dev = ice_pf_to_dev(vsi->back);
 
 	/* there is no default VSI configured */
-	if (!ice_is_dflt_vsi_in_use(sw))
+	if (!ice_is_dflt_vsi_in_use(vsi->port_info))
 		return -ENODEV;
 
-	status = ice_cfg_dflt_vsi(&dflt_vsi->back->hw, dflt_vsi->idx, false,
+	status = ice_cfg_dflt_vsi(vsi->port_info, vsi->idx, false,
 				  ICE_FLTR_RX);
 	if (status) {
 		dev_err(dev, "Failed to clear the default forwarding VSI %d, error %d\n",
-			dflt_vsi->vsi_num, status);
+			vsi->vsi_num, status);
 		return -EIO;
 	}
 
-	sw->dflt_vsi = NULL;
-	sw->dflt_vsi_ena = false;
-
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.h b/drivers/net/ethernet/intel/ice/ice_lib.h
index 59ac60e11487..6f4456257f70 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_lib.h
@@ -111,13 +111,10 @@ int ice_vsi_cfg_mac_fltr(struct ice_vsi *vsi, const u8 *macaddr, bool set);
 
 bool ice_is_safe_mode(struct ice_pf *pf);
 bool ice_is_rdma_ena(struct ice_pf *pf);
-bool ice_is_dflt_vsi_in_use(struct ice_sw *sw);
-
-bool ice_is_vsi_dflt_vsi(struct ice_sw *sw, struct ice_vsi *vsi);
-
-int ice_set_dflt_vsi(struct ice_sw *sw, struct ice_vsi *vsi);
-
-int ice_clear_dflt_vsi(struct ice_sw *sw);
+bool ice_is_dflt_vsi_in_use(struct ice_port_info *pi);
+bool ice_is_vsi_dflt_vsi(struct ice_vsi *vsi);
+int ice_set_dflt_vsi(struct ice_vsi *vsi);
+int ice_clear_dflt_vsi(struct ice_vsi *vsi);
 int ice_set_min_bw_limit(struct ice_vsi *vsi, u64 min_tx_rate);
 int ice_set_max_bw_limit(struct ice_vsi *vsi, u64 max_tx_rate);
 int ice_get_link_speed_kbps(struct ice_vsi *vsi);
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index f89e43b129ba..dbcfe4b82481 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -387,8 +387,8 @@ static int ice_vsi_sync_fltr(struct ice_vsi *vsi)
 		clear_bit(ICE_VSI_PROMISC_CHANGED, vsi->state);
 		if (vsi->current_netdev_flags & IFF_PROMISC) {
 			/* Apply Rx filter rule to get traffic from wire */
-			if (!ice_is_dflt_vsi_in_use(pf->first_sw)) {
-				err = ice_set_dflt_vsi(pf->first_sw, vsi);
+			if (!ice_is_dflt_vsi_in_use(vsi->port_info)) {
+				err = ice_set_dflt_vsi(vsi);
 				if (err && err != -EEXIST) {
 					netdev_err(netdev, "Error %d setting default VSI %i Rx rule\n",
 						   err, vsi->vsi_num);
@@ -401,8 +401,8 @@ static int ice_vsi_sync_fltr(struct ice_vsi *vsi)
 			}
 		} else {
 			/* Clear Rx filter to remove traffic from wire */
-			if (ice_is_vsi_dflt_vsi(pf->first_sw, vsi)) {
-				err = ice_clear_dflt_vsi(pf->first_sw);
+			if (ice_is_vsi_dflt_vsi(vsi)) {
+				err = ice_clear_dflt_vsi(vsi);
 				if (err) {
 					netdev_err(netdev, "Error %d clearing default VSI %i Rx rule\n",
 						   err, vsi->vsi_num);
@@ -6754,12 +6754,6 @@ static void ice_rebuild(struct ice_pf *pf, enum ice_reset_req reset_type)
 		goto err_init_ctrlq;
 	}
 
-	if (pf->first_sw->dflt_vsi_ena)
-		dev_info(dev, "Clearing default VSI, re-enable after reset completes\n");
-	/* clear the default VSI configuration if it exists */
-	pf->first_sw->dflt_vsi = NULL;
-	pf->first_sw->dflt_vsi_ena = false;
-
 	ice_clear_pxe_mode(hw);
 
 	err = ice_init_nvm(hw);
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
diff --git a/drivers/net/ethernet/intel/ice/ice_switch.h b/drivers/net/ethernet/intel/ice/ice_switch.h
index d8334beaaa8a..9fba4e1fade6 100644
--- a/drivers/net/ethernet/intel/ice/ice_switch.h
+++ b/drivers/net/ethernet/intel/ice/ice_switch.h
@@ -342,7 +342,13 @@ int ice_cfg_rdma_fltr(struct ice_hw *hw, u16 vsi_handle, bool enable);
 void ice_remove_vsi_fltr(struct ice_hw *hw, u16 vsi_handle);
 
 /* Promisc/defport setup for VSIs */
-int ice_cfg_dflt_vsi(struct ice_hw *hw, u16 vsi_handle, bool set, u8 direction);
+int
+ice_cfg_dflt_vsi(struct ice_port_info *pi, u16 vsi_handle, bool set,
+		 u8 direction);
+bool
+ice_check_if_dflt_vsi(struct ice_port_info *pi, u16 vsi_handle,
+		      bool *rule_exists);
+
 int
 ice_set_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,
 		    u16 vid);
diff --git a/drivers/net/ethernet/intel/ice/ice_type.h b/drivers/net/ethernet/intel/ice/ice_type.h
index 546145dd1f02..0232539fe33e 100644
--- a/drivers/net/ethernet/intel/ice/ice_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_type.h
@@ -686,10 +686,6 @@ struct ice_port_info {
 #define ICE_SCHED_PORT_STATE_READY	0x1
 	u8 lport;
 #define ICE_LPORT_MASK			0xff
-	u16 dflt_tx_vsi_rule_id;
-	u16 dflt_tx_vsi_num;
-	u16 dflt_rx_vsi_rule_id;
-	u16 dflt_rx_vsi_num;
 	struct ice_fc_info fc;
 	struct ice_mac_info mac;
 	struct ice_phy_info phy;
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
