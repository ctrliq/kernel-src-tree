ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.26.1.rt7.183.el8_6
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 109aba47ca9b9d6206a187a4b2ab4d2616c683d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.26.1.rt7.183.el8_6/109aba47.failed

Introduce the ice_vf_lib.c file along with the ice_vf_lib.h and
ice_vf_lib_private.h header files.

These files will house the generic VF structures and access functions.
Move struct ice_vf and its dependent definitions into this new header
file.

The ice_vf_lib.c is compiled conditionally on CONFIG_PCI_IOV. Some of
its functionality is required by all driver files. However, some of its
functionality will only be required by other files also conditionally
compiled based on CONFIG_PCI_IOV.

Declaring these functions used only in CONFIG_PCI_IOV files in
ice_vf_lib.h is verbose. This is because we must provide a fallback
implementation for each function in this header since it is included in
files which may not be compiled with CONFIG_PCI_IOV.

Instead, introduce a new ice_vf_lib_private.h header which verifies that
CONFIG_PCI_IOV is enabled. This header is intended to be directly
included in .c files which are CONFIG_PCI_IOV only. Add a #error
indication that will complain if the file ever gets included by another
C file on a kernel with CONFIG_PCI_IOV disabled. Add a comment
indicating the nature of the file and why it is useful.

This makes it so that we can easily define functions exposed from
ice_vf_lib.c into other virtualization files without needing to add
fallback implementations for every single function.

This begins the path to separate out generic code which will be reused
by other virtualization implementations from ice_sriov.h and ice_sriov.c

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Konrad Jankowski <konrad0.jankowski@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 109aba47ca9b9d6206a187a4b2ab4d2616c683d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/Makefile
#	drivers/net/ethernet/intel/ice/ice_sriov.c
#	drivers/net/ethernet/intel/ice/ice_sriov.h
diff --cc drivers/net/ethernet/intel/ice/Makefile
index c36faa7d1471,c21a0aa897a5..000000000000
--- a/drivers/net/ethernet/intel/ice/Makefile
+++ b/drivers/net/ethernet/intel/ice/Makefile
@@@ -29,9 -33,15 +29,19 @@@ ice-y := ice_main.o	
  	 ice_ethtool.o  \
  	 ice_repr.o	\
  	 ice_tc_lib.o
++<<<<<<< HEAD
 +ice-$(CONFIG_PCI_IOV) += ice_virtchnl_allowlist.o
 +ice-$(CONFIG_PCI_IOV) += ice_virtchnl_pf.o ice_sriov.o ice_virtchnl_fdir.o
++=======
+ ice-$(CONFIG_PCI_IOV) +=	\
+ 	ice_sriov.o		\
+ 	ice_virtchnl_allowlist.o \
+ 	ice_virtchnl_fdir.o	\
+ 	ice_vf_mbx.o		\
+ 	ice_vf_vsi_vlan_ops.o	\
+ 	ice_vf_lib.o
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
  ice-$(CONFIG_PTP_1588_CLOCK) += ice_ptp.o ice_ptp_hw.o
 -ice-$(CONFIG_TTY) += ice_gnss.o
  ice-$(CONFIG_DCB) += ice_dcb.o ice_dcb_nl.o ice_dcb_lib.o
  ice-$(CONFIG_RFS_ACCEL) += ice_arfs.o
  ice-$(CONFIG_XDP_SOCKETS) += ice_xsk.o
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.c
index 52c6bac41bf7,2f74fcf51c2c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.c
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.c
@@@ -1,394 -1,2814 +1,2704 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2018, Intel Corporation. */
  
++<<<<<<< HEAD
 +#include "ice_common.h"
 +#include "ice_sriov.h"
 +
 +/**
 + * ice_aq_send_msg_to_vf
 + * @hw: pointer to the hardware structure
 + * @vfid: VF ID to send msg
 + * @v_opcode: opcodes for VF-PF communication
 + * @v_retval: return error code
 + * @msg: pointer to the msg buffer
 + * @msglen: msg length
 + * @cd: pointer to command details
 + *
 + * Send message to VF driver (0x0802) using mailbox
 + * queue and asynchronously sending message via
 + * ice_sq_send_cmd() function
++=======
+ #include "ice.h"
+ #include "ice_vf_lib_private.h"
+ #include "ice_base.h"
+ #include "ice_lib.h"
+ #include "ice_fltr.h"
+ #include "ice_dcb_lib.h"
+ #include "ice_flow.h"
+ #include "ice_eswitch.h"
+ #include "ice_virtchnl_allowlist.h"
+ #include "ice_flex_pipe.h"
+ #include "ice_vf_vsi_vlan_ops.h"
+ #include "ice_vlan.h"
+ 
+ #define FIELD_SELECTOR(proto_hdr_field) \
+ 		BIT((proto_hdr_field) & PROTO_HDR_FIELD_MASK)
+ 
+ struct ice_vc_hdr_match_type {
+ 	u32 vc_hdr;	/* virtchnl headers (VIRTCHNL_PROTO_HDR_XXX) */
+ 	u32 ice_hdr;	/* ice headers (ICE_FLOW_SEG_HDR_XXX) */
+ };
+ 
+ static const struct ice_vc_hdr_match_type ice_vc_hdr_list[] = {
+ 	{VIRTCHNL_PROTO_HDR_NONE,	ICE_FLOW_SEG_HDR_NONE},
+ 	{VIRTCHNL_PROTO_HDR_ETH,	ICE_FLOW_SEG_HDR_ETH},
+ 	{VIRTCHNL_PROTO_HDR_S_VLAN,	ICE_FLOW_SEG_HDR_VLAN},
+ 	{VIRTCHNL_PROTO_HDR_C_VLAN,	ICE_FLOW_SEG_HDR_VLAN},
+ 	{VIRTCHNL_PROTO_HDR_IPV4,	ICE_FLOW_SEG_HDR_IPV4 |
+ 					ICE_FLOW_SEG_HDR_IPV_OTHER},
+ 	{VIRTCHNL_PROTO_HDR_IPV6,	ICE_FLOW_SEG_HDR_IPV6 |
+ 					ICE_FLOW_SEG_HDR_IPV_OTHER},
+ 	{VIRTCHNL_PROTO_HDR_TCP,	ICE_FLOW_SEG_HDR_TCP},
+ 	{VIRTCHNL_PROTO_HDR_UDP,	ICE_FLOW_SEG_HDR_UDP},
+ 	{VIRTCHNL_PROTO_HDR_SCTP,	ICE_FLOW_SEG_HDR_SCTP},
+ 	{VIRTCHNL_PROTO_HDR_PPPOE,	ICE_FLOW_SEG_HDR_PPPOE},
+ 	{VIRTCHNL_PROTO_HDR_GTPU_IP,	ICE_FLOW_SEG_HDR_GTPU_IP},
+ 	{VIRTCHNL_PROTO_HDR_GTPU_EH,	ICE_FLOW_SEG_HDR_GTPU_EH},
+ 	{VIRTCHNL_PROTO_HDR_GTPU_EH_PDU_DWN,
+ 					ICE_FLOW_SEG_HDR_GTPU_DWN},
+ 	{VIRTCHNL_PROTO_HDR_GTPU_EH_PDU_UP,
+ 					ICE_FLOW_SEG_HDR_GTPU_UP},
+ 	{VIRTCHNL_PROTO_HDR_L2TPV3,	ICE_FLOW_SEG_HDR_L2TPV3},
+ 	{VIRTCHNL_PROTO_HDR_ESP,	ICE_FLOW_SEG_HDR_ESP},
+ 	{VIRTCHNL_PROTO_HDR_AH,		ICE_FLOW_SEG_HDR_AH},
+ 	{VIRTCHNL_PROTO_HDR_PFCP,	ICE_FLOW_SEG_HDR_PFCP_SESSION},
+ };
+ 
+ struct ice_vc_hash_field_match_type {
+ 	u32 vc_hdr;		/* virtchnl headers
+ 				 * (VIRTCHNL_PROTO_HDR_XXX)
+ 				 */
+ 	u32 vc_hash_field;	/* virtchnl hash fields selector
+ 				 * FIELD_SELECTOR((VIRTCHNL_PROTO_HDR_ETH_XXX))
+ 				 */
+ 	u64 ice_hash_field;	/* ice hash fields
+ 				 * (BIT_ULL(ICE_FLOW_FIELD_IDX_XXX))
+ 				 */
+ };
+ 
+ static const struct
+ ice_vc_hash_field_match_type ice_vc_hash_field_list[] = {
+ 	{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_SRC),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_ETH_SA)},
+ 	{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_DST),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_ETH_DA)},
+ 	{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_DST),
+ 		ICE_FLOW_HASH_ETH},
+ 	{VIRTCHNL_PROTO_HDR_ETH,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_ETHERTYPE),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_ETH_TYPE)},
+ 	{VIRTCHNL_PROTO_HDR_S_VLAN,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_S_VLAN_ID),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_S_VLAN)},
+ 	{VIRTCHNL_PROTO_HDR_C_VLAN,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_C_VLAN_ID),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_C_VLAN)},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA)},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA)},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST),
+ 		ICE_FLOW_HASH_IPV4},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA) |
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA) |
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
+ 		ICE_FLOW_HASH_IPV4 | BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA)},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA)},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST),
+ 		ICE_FLOW_HASH_IPV6},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA) |
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA) |
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
+ 		ICE_FLOW_HASH_IPV6 | BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
+ 	{VIRTCHNL_PROTO_HDR_TCP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_SRC_PORT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_TCP_SRC_PORT)},
+ 	{VIRTCHNL_PROTO_HDR_TCP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_DST_PORT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_TCP_DST_PORT)},
+ 	{VIRTCHNL_PROTO_HDR_TCP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_SRC_PORT) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_DST_PORT),
+ 		ICE_FLOW_HASH_TCP_PORT},
+ 	{VIRTCHNL_PROTO_HDR_UDP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_SRC_PORT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_UDP_SRC_PORT)},
+ 	{VIRTCHNL_PROTO_HDR_UDP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_DST_PORT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_UDP_DST_PORT)},
+ 	{VIRTCHNL_PROTO_HDR_UDP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_SRC_PORT) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_DST_PORT),
+ 		ICE_FLOW_HASH_UDP_PORT},
+ 	{VIRTCHNL_PROTO_HDR_SCTP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_SRC_PORT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT)},
+ 	{VIRTCHNL_PROTO_HDR_SCTP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_DST_PORT),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_DST_PORT)},
+ 	{VIRTCHNL_PROTO_HDR_SCTP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_SRC_PORT) |
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_DST_PORT),
+ 		ICE_FLOW_HASH_SCTP_PORT},
+ 	{VIRTCHNL_PROTO_HDR_PPPOE,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_PPPOE_SESS_ID),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_PPPOE_SESS_ID)},
+ 	{VIRTCHNL_PROTO_HDR_GTPU_IP,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_GTPU_IP_TEID),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_GTPU_IP_TEID)},
+ 	{VIRTCHNL_PROTO_HDR_L2TPV3,
+ 		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_L2TPV3_SESS_ID),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_L2TPV3_SESS_ID)},
+ 	{VIRTCHNL_PROTO_HDR_ESP, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ESP_SPI),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_ESP_SPI)},
+ 	{VIRTCHNL_PROTO_HDR_AH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_AH_SPI),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_AH_SPI)},
+ 	{VIRTCHNL_PROTO_HDR_PFCP, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_PFCP_SEID),
+ 		BIT_ULL(ICE_FLOW_FIELD_IDX_PFCP_SEID)},
+ };
+ 
+ /**
+  * ice_free_vf_entries - Free all VF entries from the hash table
+  * @pf: pointer to the PF structure
+  *
+  * Iterate over the VF hash table, removing and releasing all VF entries.
+  * Called during VF teardown or as cleanup during failed VF initialization.
+  */
+ static void ice_free_vf_entries(struct ice_pf *pf)
+ {
+ 	struct ice_vfs *vfs = &pf->vfs;
+ 	struct hlist_node *tmp;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	/* Remove all VFs from the hash table and release their main
+ 	 * reference. Once all references to the VF are dropped, ice_put_vf()
+ 	 * will call ice_release_vf which will remove the VF memory.
+ 	 */
+ 	lockdep_assert_held(&vfs->table_lock);
+ 
+ 	hash_for_each_safe(vfs->table, bkt, tmp, vf, entry) {
+ 		hash_del_rcu(&vf->entry);
+ 		ice_put_vf(vf);
+ 	}
+ }
+ 
+ /**
+  * ice_vc_vf_broadcast - Broadcast a message to all VFs on PF
+  * @pf: pointer to the PF structure
+  * @v_opcode: operation code
+  * @v_retval: return value
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  */
+ static void
+ ice_vc_vf_broadcast(struct ice_pf *pf, enum virtchnl_ops v_opcode,
+ 		    enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		/* Not all vfs are enabled so skip the ones that are not */
+ 		if (!test_bit(ICE_VF_STATE_INIT, vf->vf_states) &&
+ 		    !test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states))
+ 			continue;
+ 
+ 		/* Ignore return value on purpose - a given VF may fail, but
+ 		 * we need to keep going and send to all of them
+ 		 */
+ 		ice_aq_send_msg_to_vf(hw, vf->vf_id, v_opcode, v_retval, msg,
+ 				      msglen, NULL);
+ 	}
+ 	mutex_unlock(&pf->vfs.table_lock);
+ }
+ 
+ /**
+  * ice_set_pfe_link - Set the link speed/status of the virtchnl_pf_event
+  * @vf: pointer to the VF structure
+  * @pfe: pointer to the virtchnl_pf_event to set link speed/status for
+  * @ice_link_speed: link speed specified by ICE_AQ_LINK_SPEED_*
+  * @link_up: whether or not to set the link up/down
+  */
+ static void
+ ice_set_pfe_link(struct ice_vf *vf, struct virtchnl_pf_event *pfe,
+ 		 int ice_link_speed, bool link_up)
+ {
+ 	if (vf->driver_caps & VIRTCHNL_VF_CAP_ADV_LINK_SPEED) {
+ 		pfe->event_data.link_event_adv.link_status = link_up;
+ 		/* Speed in Mbps */
+ 		pfe->event_data.link_event_adv.link_speed =
+ 			ice_conv_link_speed_to_virtchnl(true, ice_link_speed);
+ 	} else {
+ 		pfe->event_data.link_event.link_status = link_up;
+ 		/* Legacy method for virtchnl link speeds */
+ 		pfe->event_data.link_event.link_speed =
+ 			(enum virtchnl_link_speed)
+ 			ice_conv_link_speed_to_virtchnl(false, ice_link_speed);
+ 	}
+ }
+ 
+ /**
+  * ice_vc_notify_vf_link_state - Inform a VF of link status
+  * @vf: pointer to the VF structure
+  *
+  * send a link status message to a single VF
+  */
+ void ice_vc_notify_vf_link_state(struct ice_vf *vf)
+ {
+ 	struct virtchnl_pf_event pfe = { 0 };
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 
+ 	pfe.event = VIRTCHNL_EVENT_LINK_CHANGE;
+ 	pfe.severity = PF_EVENT_SEVERITY_INFO;
+ 
+ 	if (ice_is_vf_link_up(vf))
+ 		ice_set_pfe_link(vf, &pfe,
+ 				 hw->port_info->phy.link_info.link_speed, true);
+ 	else
+ 		ice_set_pfe_link(vf, &pfe, ICE_AQ_LINK_SPEED_UNKNOWN, false);
+ 
+ 	ice_aq_send_msg_to_vf(hw, vf->vf_id, VIRTCHNL_OP_EVENT,
+ 			      VIRTCHNL_STATUS_SUCCESS, (u8 *)&pfe,
+ 			      sizeof(pfe), NULL);
+ }
+ 
+ /**
+  * ice_vf_vsi_release - invalidate the VF's VSI after freeing it
+  * @vf: invalidate this VF's VSI after freeing it
+  */
+ static void ice_vf_vsi_release(struct ice_vf *vf)
+ {
+ 	ice_vsi_release(ice_get_vf_vsi(vf));
+ 	ice_vf_invalidate_vsi(vf);
+ }
+ 
+ /**
+  * ice_free_vf_res - Free a VF's resources
+  * @vf: pointer to the VF info
+  */
+ static void ice_free_vf_res(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	int i, last_vector_idx;
+ 
+ 	/* First, disable VF's configuration API to prevent OS from
+ 	 * accessing the VF's VSI after it's freed or invalidated.
+ 	 */
+ 	clear_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 	ice_vf_fdir_exit(vf);
+ 	/* free VF control VSI */
+ 	if (vf->ctrl_vsi_idx != ICE_NO_VSI)
+ 		ice_vf_ctrl_vsi_release(vf);
+ 
+ 	/* free VSI and disconnect it from the parent uplink */
+ 	if (vf->lan_vsi_idx != ICE_NO_VSI) {
+ 		ice_vf_vsi_release(vf);
+ 		vf->num_mac = 0;
+ 	}
+ 
+ 	last_vector_idx = vf->first_vector_idx + pf->vfs.num_msix_per - 1;
+ 
+ 	/* clear VF MDD event information */
+ 	memset(&vf->mdd_tx_events, 0, sizeof(vf->mdd_tx_events));
+ 	memset(&vf->mdd_rx_events, 0, sizeof(vf->mdd_rx_events));
+ 
+ 	/* Disable interrupts so that VF starts in a known state */
+ 	for (i = vf->first_vector_idx; i <= last_vector_idx; i++) {
+ 		wr32(&pf->hw, GLINT_DYN_CTL(i), GLINT_DYN_CTL_CLEARPBA_M);
+ 		ice_flush(&pf->hw);
+ 	}
+ 	/* reset some of the state variables keeping track of the resources */
+ 	clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);
+ 	clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);
+ }
+ 
+ /**
+  * ice_dis_vf_mappings
+  * @vf: pointer to the VF structure
+  */
+ static void ice_dis_vf_mappings(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 	struct device *dev;
+ 	int first, last, v;
+ 	struct ice_hw *hw;
+ 
+ 	hw = &pf->hw;
+ 	vsi = ice_get_vf_vsi(vf);
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	wr32(hw, VPINT_ALLOC(vf->vf_id), 0);
+ 	wr32(hw, VPINT_ALLOC_PCI(vf->vf_id), 0);
+ 
+ 	first = vf->first_vector_idx;
+ 	last = first + pf->vfs.num_msix_per - 1;
+ 	for (v = first; v <= last; v++) {
+ 		u32 reg;
+ 
+ 		reg = (((1 << GLINT_VECT2FUNC_IS_PF_S) &
+ 			GLINT_VECT2FUNC_IS_PF_M) |
+ 		       ((hw->pf_id << GLINT_VECT2FUNC_PF_NUM_S) &
+ 			GLINT_VECT2FUNC_PF_NUM_M));
+ 		wr32(hw, GLINT_VECT2FUNC(v), reg);
+ 	}
+ 
+ 	if (vsi->tx_mapping_mode == ICE_VSI_MAP_CONTIG)
+ 		wr32(hw, VPLAN_TX_QBASE(vf->vf_id), 0);
+ 	else
+ 		dev_err(dev, "Scattered mode for VF Tx queues is not yet implemented\n");
+ 
+ 	if (vsi->rx_mapping_mode == ICE_VSI_MAP_CONTIG)
+ 		wr32(hw, VPLAN_RX_QBASE(vf->vf_id), 0);
+ 	else
+ 		dev_err(dev, "Scattered mode for VF Rx queues is not yet implemented\n");
+ }
+ 
+ /**
+  * ice_sriov_free_msix_res - Reset/free any used MSIX resources
+  * @pf: pointer to the PF structure
+  *
+  * Since no MSIX entries are taken from the pf->irq_tracker then just clear
+  * the pf->sriov_base_vector.
+  *
+  * Returns 0 on success, and -EINVAL on error.
+  */
+ static int ice_sriov_free_msix_res(struct ice_pf *pf)
+ {
+ 	struct ice_res_tracker *res;
+ 
+ 	if (!pf)
+ 		return -EINVAL;
+ 
+ 	res = pf->irq_tracker;
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	/* give back irq_tracker resources used */
+ 	WARN_ON(pf->sriov_base_vector < res->num_entries);
+ 
+ 	pf->sriov_base_vector = 0;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_free_vfs - Free all VFs
+  * @pf: pointer to the PF structure
+  */
+ void ice_free_vfs(struct ice_pf *pf)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_vfs *vfs = &pf->vfs;
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	if (!ice_has_vfs(pf))
+ 		return;
+ 
+ 	while (test_and_set_bit(ICE_VF_DIS, pf->state))
+ 		usleep_range(1000, 2000);
+ 
+ 	/* Disable IOV before freeing resources. This lets any VF drivers
+ 	 * running in the host get themselves cleaned up before we yank
+ 	 * the carpet out from underneath their feet.
+ 	 */
+ 	if (!pci_vfs_assigned(pf->pdev))
+ 		pci_disable_sriov(pf->pdev);
+ 	else
+ 		dev_warn(dev, "VFs are assigned - not disabling SR-IOV\n");
+ 
+ 	mutex_lock(&vfs->table_lock);
+ 
+ 	ice_eswitch_release(pf);
+ 
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		mutex_lock(&vf->cfg_lock);
+ 
+ 		ice_dis_vf_qs(vf);
+ 
+ 		if (test_bit(ICE_VF_STATE_INIT, vf->vf_states)) {
+ 			/* disable VF qp mappings and set VF disable state */
+ 			ice_dis_vf_mappings(vf);
+ 			set_bit(ICE_VF_STATE_DIS, vf->vf_states);
+ 			ice_free_vf_res(vf);
+ 		}
+ 
+ 		if (!pci_vfs_assigned(pf->pdev)) {
+ 			u32 reg_idx, bit_idx;
+ 
+ 			reg_idx = (hw->func_caps.vf_base_id + vf->vf_id) / 32;
+ 			bit_idx = (hw->func_caps.vf_base_id + vf->vf_id) % 32;
+ 			wr32(hw, GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));
+ 		}
+ 
+ 		/* clear malicious info since the VF is getting released */
+ 		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->vfs.malvfs,
+ 					ICE_MAX_SRIOV_VFS, vf->vf_id))
+ 			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n",
+ 				vf->vf_id);
+ 
+ 		mutex_unlock(&vf->cfg_lock);
+ 	}
+ 
+ 	if (ice_sriov_free_msix_res(pf))
+ 		dev_err(dev, "Failed to free MSIX resources used by SR-IOV\n");
+ 
+ 	vfs->num_qps_per = 0;
+ 	ice_free_vf_entries(pf);
+ 
+ 	mutex_unlock(&vfs->table_lock);
+ 
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 	clear_bit(ICE_FLAG_SRIOV_ENA, pf->flags);
+ }
+ 
+ /**
+  * ice_trigger_vf_reset - Reset a VF on HW
+  * @vf: pointer to the VF structure
+  * @is_vflr: true if VFLR was issued, false if not
+  * @is_pfr: true if the reset was triggered due to a previous PFR
+  *
+  * Trigger hardware to start a reset for a particular VF. Expects the caller
+  * to wait the proper amount of time to allow hardware to reset the VF before
+  * it cleans up and restores VF functionality.
+  */
+ static void ice_trigger_vf_reset(struct ice_vf *vf, bool is_vflr, bool is_pfr)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	u32 reg, reg_idx, bit_idx;
+ 	unsigned int vf_abs_id, i;
+ 	struct device *dev;
+ 	struct ice_hw *hw;
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	hw = &pf->hw;
+ 	vf_abs_id = vf->vf_id + hw->func_caps.vf_base_id;
+ 
+ 	/* Inform VF that it is no longer active, as a warning */
+ 	clear_bit(ICE_VF_STATE_ACTIVE, vf->vf_states);
+ 
+ 	/* Disable VF's configuration API during reset. The flag is re-enabled
+ 	 * when it's safe again to access VF's VSI.
+ 	 */
+ 	clear_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 
+ 	/* VF_MBX_ARQLEN and VF_MBX_ATQLEN are cleared by PFR, so the driver
+ 	 * needs to clear them in the case of VFR/VFLR. If this is done for
+ 	 * PFR, it can mess up VF resets because the VF driver may already
+ 	 * have started cleanup by the time we get here.
+ 	 */
+ 	if (!is_pfr) {
+ 		wr32(hw, VF_MBX_ARQLEN(vf->vf_id), 0);
+ 		wr32(hw, VF_MBX_ATQLEN(vf->vf_id), 0);
+ 	}
+ 
+ 	/* In the case of a VFLR, the HW has already reset the VF and we
+ 	 * just need to clean up, so don't hit the VFRTRIG register.
+ 	 */
+ 	if (!is_vflr) {
+ 		/* reset VF using VPGEN_VFRTRIG reg */
+ 		reg = rd32(hw, VPGEN_VFRTRIG(vf->vf_id));
+ 		reg |= VPGEN_VFRTRIG_VFSWR_M;
+ 		wr32(hw, VPGEN_VFRTRIG(vf->vf_id), reg);
+ 	}
+ 	/* clear the VFLR bit in GLGEN_VFLRSTAT */
+ 	reg_idx = (vf_abs_id) / 32;
+ 	bit_idx = (vf_abs_id) % 32;
+ 	wr32(hw, GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));
+ 	ice_flush(hw);
+ 
+ 	wr32(hw, PF_PCI_CIAA,
+ 	     VF_DEVICE_STATUS | (vf_abs_id << PF_PCI_CIAA_VF_NUM_S));
+ 	for (i = 0; i < ICE_PCI_CIAD_WAIT_COUNT; i++) {
+ 		reg = rd32(hw, PF_PCI_CIAD);
+ 		/* no transactions pending so stop polling */
+ 		if ((reg & VF_TRANS_PENDING_M) == 0)
+ 			break;
+ 
+ 		dev_err(dev, "VF %u PCI transactions stuck\n", vf->vf_id);
+ 		udelay(ICE_PCI_CIAD_WAIT_DELAY_US);
+ 	}
+ }
+ 
+ /**
+  * ice_vf_vsi_setup - Set up a VF VSI
+  * @vf: VF to setup VSI for
+  *
+  * Returns pointer to the successfully allocated VSI struct on success,
+  * otherwise returns NULL on failure.
+  */
+ static struct ice_vsi *ice_vf_vsi_setup(struct ice_vf *vf)
+ {
+ 	struct ice_port_info *pi = ice_vf_get_port_info(vf);
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 
+ 	vsi = ice_vsi_setup(pf, pi, ICE_VSI_VF, vf, NULL);
+ 
+ 	if (!vsi) {
+ 		dev_err(ice_pf_to_dev(pf), "Failed to create VF VSI\n");
+ 		ice_vf_invalidate_vsi(vf);
+ 		return NULL;
+ 	}
+ 
+ 	vf->lan_vsi_idx = vsi->idx;
+ 	vf->lan_vsi_num = vsi->vsi_num;
+ 
+ 	return vsi;
+ }
+ 
+ /**
+  * ice_calc_vf_first_vector_idx - Calculate MSIX vector index in the PF space
+  * @pf: pointer to PF structure
+  * @vf: pointer to VF that the first MSIX vector index is being calculated for
+  *
+  * This returns the first MSIX vector index in PF space that is used by this VF.
+  * This index is used when accessing PF relative registers such as
+  * GLINT_VECT2FUNC and GLINT_DYN_CTL.
+  * This will always be the OICR index in the AVF driver so any functionality
+  * using vf->first_vector_idx for queue configuration will have to increment by
+  * 1 to avoid meddling with the OICR index.
+  */
+ static int ice_calc_vf_first_vector_idx(struct ice_pf *pf, struct ice_vf *vf)
+ {
+ 	return pf->sriov_base_vector + vf->vf_id * pf->vfs.num_msix_per;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_tx_rate_cfg - re-apply the Tx rate limiting configuration
+  * @vf: VF to re-apply the configuration for
+  *
+  * Called after a VF VSI has been re-added/rebuild during reset. The PF driver
+  * needs to re-apply the host configured Tx rate limiting configuration.
+  */
+ static int ice_vf_rebuild_host_tx_rate_cfg(struct ice_vf *vf)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	int err;
+ 
+ 	if (vf->min_tx_rate) {
+ 		err = ice_set_min_bw_limit(vsi, (u64)vf->min_tx_rate * 1000);
+ 		if (err) {
+ 			dev_err(dev, "failed to set min Tx rate to %d Mbps for VF %u, error %d\n",
+ 				vf->min_tx_rate, vf->vf_id, err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	if (vf->max_tx_rate) {
+ 		err = ice_set_max_bw_limit(vsi, (u64)vf->max_tx_rate * 1000);
+ 		if (err) {
+ 			dev_err(dev, "failed to set max Tx rate to %d Mbps for VF %u, error %d\n",
+ 				vf->max_tx_rate, vf->vf_id, err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_vlan_cfg - add VLAN 0 filter or rebuild the Port VLAN
+  * @vf: VF to add MAC filters for
+  * @vsi: Pointer to VSI
+  *
+  * Called after a VF VSI has been re-added/rebuilt during reset. The PF driver
+  * always re-adds either a VLAN 0 or port VLAN based filter after reset.
+  */
+ static int ice_vf_rebuild_host_vlan_cfg(struct ice_vf *vf, struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	int err;
+ 
+ 	if (ice_vf_is_port_vlan_ena(vf)) {
+ 		err = vlan_ops->set_port_vlan(vsi, &vf->port_vlan_info);
+ 		if (err) {
+ 			dev_err(dev, "failed to configure port VLAN via VSI parameters for VF %u, error %d\n",
+ 				vf->vf_id, err);
+ 			return err;
+ 		}
+ 
+ 		err = vlan_ops->add_vlan(vsi, &vf->port_vlan_info);
+ 	} else {
+ 		err = ice_vsi_add_vlan_zero(vsi);
+ 	}
+ 
+ 	if (err) {
+ 		dev_err(dev, "failed to add VLAN %u filter for VF %u during VF rebuild, error %d\n",
+ 			ice_vf_is_port_vlan_ena(vf) ?
+ 			ice_vf_get_port_vlan_id(vf) : 0, vf->vf_id, err);
+ 		return err;
+ 	}
+ 
+ 	err = vlan_ops->ena_rx_filtering(vsi);
+ 	if (err)
+ 		dev_warn(dev, "failed to enable Rx VLAN filtering for VF %d VSI %d during VF rebuild, error %d\n",
+ 			 vf->vf_id, vsi->idx, err);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_mac_cfg - add broadcast and the VF's perm_addr/LAA
+  * @vf: VF to add MAC filters for
+  *
+  * Called after a VF VSI has been re-added/rebuilt during reset. The PF driver
+  * always re-adds a broadcast filter and the VF's perm_addr/LAA after reset.
+  */
+ static int ice_vf_rebuild_host_mac_cfg(struct ice_vf *vf)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	u8 broadcast[ETH_ALEN];
+ 	int status;
+ 
+ 	if (ice_is_eswitch_mode_switchdev(vf->pf))
+ 		return 0;
+ 
+ 	eth_broadcast_addr(broadcast);
+ 	status = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);
+ 	if (status) {
+ 		dev_err(dev, "failed to add broadcast MAC filter for VF %u, error %d\n",
+ 			vf->vf_id, status);
+ 		return status;
+ 	}
+ 
+ 	vf->num_mac++;
+ 
+ 	if (is_valid_ether_addr(vf->hw_lan_addr.addr)) {
+ 		status = ice_fltr_add_mac(vsi, vf->hw_lan_addr.addr,
+ 					  ICE_FWD_TO_VSI);
+ 		if (status) {
+ 			dev_err(dev, "failed to add default unicast MAC filter %pM for VF %u, error %d\n",
+ 				&vf->hw_lan_addr.addr[0], vf->vf_id,
+ 				status);
+ 			return status;
+ 		}
+ 		vf->num_mac++;
+ 
+ 		ether_addr_copy(vf->dev_lan_addr.addr, vf->hw_lan_addr.addr);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_set_host_trust_cfg - set trust setting based on pre-reset value
+  * @vf: VF to configure trust setting for
+  */
+ static void ice_vf_set_host_trust_cfg(struct ice_vf *vf)
+ {
+ 	if (vf->trusted)
+ 		set_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
+ 	else
+ 		clear_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
+ }
+ 
+ /**
+  * ice_ena_vf_msix_mappings - enable VF MSIX mappings in hardware
+  * @vf: VF to enable MSIX mappings for
+  *
+  * Some of the registers need to be indexed/configured using hardware global
+  * device values and other registers need 0-based values, which represent PF
+  * based values.
+  */
+ static void ice_ena_vf_msix_mappings(struct ice_vf *vf)
+ {
+ 	int device_based_first_msix, device_based_last_msix;
+ 	int pf_based_first_msix, pf_based_last_msix, v;
+ 	struct ice_pf *pf = vf->pf;
+ 	int device_based_vf_id;
+ 	struct ice_hw *hw;
+ 	u32 reg;
+ 
+ 	hw = &pf->hw;
+ 	pf_based_first_msix = vf->first_vector_idx;
+ 	pf_based_last_msix = (pf_based_first_msix + pf->vfs.num_msix_per) - 1;
+ 
+ 	device_based_first_msix = pf_based_first_msix +
+ 		pf->hw.func_caps.common_cap.msix_vector_first_id;
+ 	device_based_last_msix =
+ 		(device_based_first_msix + pf->vfs.num_msix_per) - 1;
+ 	device_based_vf_id = vf->vf_id + hw->func_caps.vf_base_id;
+ 
+ 	reg = (((device_based_first_msix << VPINT_ALLOC_FIRST_S) &
+ 		VPINT_ALLOC_FIRST_M) |
+ 	       ((device_based_last_msix << VPINT_ALLOC_LAST_S) &
+ 		VPINT_ALLOC_LAST_M) | VPINT_ALLOC_VALID_M);
+ 	wr32(hw, VPINT_ALLOC(vf->vf_id), reg);
+ 
+ 	reg = (((device_based_first_msix << VPINT_ALLOC_PCI_FIRST_S)
+ 		 & VPINT_ALLOC_PCI_FIRST_M) |
+ 	       ((device_based_last_msix << VPINT_ALLOC_PCI_LAST_S) &
+ 		VPINT_ALLOC_PCI_LAST_M) | VPINT_ALLOC_PCI_VALID_M);
+ 	wr32(hw, VPINT_ALLOC_PCI(vf->vf_id), reg);
+ 
+ 	/* map the interrupts to its functions */
+ 	for (v = pf_based_first_msix; v <= pf_based_last_msix; v++) {
+ 		reg = (((device_based_vf_id << GLINT_VECT2FUNC_VF_NUM_S) &
+ 			GLINT_VECT2FUNC_VF_NUM_M) |
+ 		       ((hw->pf_id << GLINT_VECT2FUNC_PF_NUM_S) &
+ 			GLINT_VECT2FUNC_PF_NUM_M));
+ 		wr32(hw, GLINT_VECT2FUNC(v), reg);
+ 	}
+ 
+ 	/* Map mailbox interrupt to VF MSI-X vector 0 */
+ 	wr32(hw, VPINT_MBX_CTL(device_based_vf_id), VPINT_MBX_CTL_CAUSE_ENA_M);
+ }
+ 
+ /**
+  * ice_ena_vf_q_mappings - enable Rx/Tx queue mappings for a VF
+  * @vf: VF to enable the mappings for
+  * @max_txq: max Tx queues allowed on the VF's VSI
+  * @max_rxq: max Rx queues allowed on the VF's VSI
+  */
+ static void ice_ena_vf_q_mappings(struct ice_vf *vf, u16 max_txq, u16 max_rxq)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 	u32 reg;
+ 
+ 	/* set regardless of mapping mode */
+ 	wr32(hw, VPLAN_TXQ_MAPENA(vf->vf_id), VPLAN_TXQ_MAPENA_TX_ENA_M);
+ 
+ 	/* VF Tx queues allocation */
+ 	if (vsi->tx_mapping_mode == ICE_VSI_MAP_CONTIG) {
+ 		/* set the VF PF Tx queue range
+ 		 * VFNUMQ value should be set to (number of queues - 1). A value
+ 		 * of 0 means 1 queue and a value of 255 means 256 queues
+ 		 */
+ 		reg = (((vsi->txq_map[0] << VPLAN_TX_QBASE_VFFIRSTQ_S) &
+ 			VPLAN_TX_QBASE_VFFIRSTQ_M) |
+ 		       (((max_txq - 1) << VPLAN_TX_QBASE_VFNUMQ_S) &
+ 			VPLAN_TX_QBASE_VFNUMQ_M));
+ 		wr32(hw, VPLAN_TX_QBASE(vf->vf_id), reg);
+ 	} else {
+ 		dev_err(dev, "Scattered mode for VF Tx queues is not yet implemented\n");
+ 	}
+ 
+ 	/* set regardless of mapping mode */
+ 	wr32(hw, VPLAN_RXQ_MAPENA(vf->vf_id), VPLAN_RXQ_MAPENA_RX_ENA_M);
+ 
+ 	/* VF Rx queues allocation */
+ 	if (vsi->rx_mapping_mode == ICE_VSI_MAP_CONTIG) {
+ 		/* set the VF PF Rx queue range
+ 		 * VFNUMQ value should be set to (number of queues - 1). A value
+ 		 * of 0 means 1 queue and a value of 255 means 256 queues
+ 		 */
+ 		reg = (((vsi->rxq_map[0] << VPLAN_RX_QBASE_VFFIRSTQ_S) &
+ 			VPLAN_RX_QBASE_VFFIRSTQ_M) |
+ 		       (((max_rxq - 1) << VPLAN_RX_QBASE_VFNUMQ_S) &
+ 			VPLAN_RX_QBASE_VFNUMQ_M));
+ 		wr32(hw, VPLAN_RX_QBASE(vf->vf_id), reg);
+ 	} else {
+ 		dev_err(dev, "Scattered mode for VF Rx queues is not yet implemented\n");
+ 	}
+ }
+ 
+ /**
+  * ice_ena_vf_mappings - enable VF MSIX and queue mapping
+  * @vf: pointer to the VF structure
+  */
+ static void ice_ena_vf_mappings(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_ena_vf_msix_mappings(vf);
+ 	ice_ena_vf_q_mappings(vf, vsi->alloc_txq, vsi->alloc_rxq);
+ }
+ 
+ /**
+  * ice_calc_vf_reg_idx - Calculate the VF's register index in the PF space
+  * @vf: VF to calculate the register index for
+  * @q_vector: a q_vector associated to the VF
+  */
+ int ice_calc_vf_reg_idx(struct ice_vf *vf, struct ice_q_vector *q_vector)
+ {
+ 	struct ice_pf *pf;
+ 
+ 	if (!vf || !q_vector)
+ 		return -EINVAL;
+ 
+ 	pf = vf->pf;
+ 
+ 	/* always add one to account for the OICR being the first MSIX */
+ 	return pf->sriov_base_vector + pf->vfs.num_msix_per * vf->vf_id +
+ 		q_vector->v_idx + 1;
+ }
+ 
+ /**
+  * ice_get_max_valid_res_idx - Get the max valid resource index
+  * @res: pointer to the resource to find the max valid index for
+  *
+  * Start from the end of the ice_res_tracker and return right when we find the
+  * first res->list entry with the ICE_RES_VALID_BIT set. This function is only
+  * valid for SR-IOV because it is the only consumer that manipulates the
+  * res->end and this is always called when res->end is set to res->num_entries.
+  */
+ static int ice_get_max_valid_res_idx(struct ice_res_tracker *res)
+ {
+ 	int i;
+ 
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	for (i = res->num_entries - 1; i >= 0; i--)
+ 		if (res->list[i] & ICE_RES_VALID_BIT)
+ 			return i;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_sriov_set_msix_res - Set any used MSIX resources
+  * @pf: pointer to PF structure
+  * @num_msix_needed: number of MSIX vectors needed for all SR-IOV VFs
+  *
+  * This function allows SR-IOV resources to be taken from the end of the PF's
+  * allowed HW MSIX vectors so that the irq_tracker will not be affected. We
+  * just set the pf->sriov_base_vector and return success.
+  *
+  * If there are not enough resources available, return an error. This should
+  * always be caught by ice_set_per_vf_res().
+  *
+  * Return 0 on success, and -EINVAL when there are not enough MSIX vectors
+  * in the PF's space available for SR-IOV.
+  */
+ static int ice_sriov_set_msix_res(struct ice_pf *pf, u16 num_msix_needed)
+ {
+ 	u16 total_vectors = pf->hw.func_caps.common_cap.num_msix_vectors;
+ 	int vectors_used = pf->irq_tracker->num_entries;
+ 	int sriov_base_vector;
+ 
+ 	sriov_base_vector = total_vectors - num_msix_needed;
+ 
+ 	/* make sure we only grab irq_tracker entries from the list end and
+ 	 * that we have enough available MSIX vectors
+ 	 */
+ 	if (sriov_base_vector < vectors_used)
+ 		return -EINVAL;
+ 
+ 	pf->sriov_base_vector = sriov_base_vector;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_set_per_vf_res - check if vectors and queues are available
+  * @pf: pointer to the PF structure
+  * @num_vfs: the number of SR-IOV VFs being configured
+  *
+  * First, determine HW interrupts from common pool. If we allocate fewer VFs, we
+  * get more vectors and can enable more queues per VF. Note that this does not
+  * grab any vectors from the SW pool already allocated. Also note, that all
+  * vector counts include one for each VF's miscellaneous interrupt vector
+  * (i.e. OICR).
+  *
+  * Minimum VFs - 2 vectors, 1 queue pair
+  * Small VFs - 5 vectors, 4 queue pairs
+  * Medium VFs - 17 vectors, 16 queue pairs
+  *
+  * Second, determine number of queue pairs per VF by starting with a pre-defined
+  * maximum each VF supports. If this is not possible, then we adjust based on
+  * queue pairs available on the device.
+  *
+  * Lastly, set queue and MSI-X VF variables tracked by the PF so it can be used
+  * by each VF during VF initialization and reset.
+  */
+ static int ice_set_per_vf_res(struct ice_pf *pf, u16 num_vfs)
+ {
+ 	int max_valid_res_idx = ice_get_max_valid_res_idx(pf->irq_tracker);
+ 	u16 num_msix_per_vf, num_txq, num_rxq, avail_qs;
+ 	int msix_avail_per_vf, msix_avail_for_sriov;
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	int err;
+ 
+ 	lockdep_assert_held(&pf->vfs.table_lock);
+ 
+ 	if (!num_vfs)
+ 		return -EINVAL;
+ 
+ 	if (max_valid_res_idx < 0)
+ 		return -ENOSPC;
+ 
+ 	/* determine MSI-X resources per VF */
+ 	msix_avail_for_sriov = pf->hw.func_caps.common_cap.num_msix_vectors -
+ 		pf->irq_tracker->num_entries;
+ 	msix_avail_per_vf = msix_avail_for_sriov / num_vfs;
+ 	if (msix_avail_per_vf >= ICE_NUM_VF_MSIX_MED) {
+ 		num_msix_per_vf = ICE_NUM_VF_MSIX_MED;
+ 	} else if (msix_avail_per_vf >= ICE_NUM_VF_MSIX_SMALL) {
+ 		num_msix_per_vf = ICE_NUM_VF_MSIX_SMALL;
+ 	} else if (msix_avail_per_vf >= ICE_NUM_VF_MSIX_MULTIQ_MIN) {
+ 		num_msix_per_vf = ICE_NUM_VF_MSIX_MULTIQ_MIN;
+ 	} else if (msix_avail_per_vf >= ICE_MIN_INTR_PER_VF) {
+ 		num_msix_per_vf = ICE_MIN_INTR_PER_VF;
+ 	} else {
+ 		dev_err(dev, "Only %d MSI-X interrupts available for SR-IOV. Not enough to support minimum of %d MSI-X interrupts per VF for %d VFs\n",
+ 			msix_avail_for_sriov, ICE_MIN_INTR_PER_VF,
+ 			num_vfs);
+ 		return -ENOSPC;
+ 	}
+ 
+ 	num_txq = min_t(u16, num_msix_per_vf - ICE_NONQ_VECS_VF,
+ 			ICE_MAX_RSS_QS_PER_VF);
+ 	avail_qs = ice_get_avail_txq_count(pf) / num_vfs;
+ 	if (!avail_qs)
+ 		num_txq = 0;
+ 	else if (num_txq > avail_qs)
+ 		num_txq = rounddown_pow_of_two(avail_qs);
+ 
+ 	num_rxq = min_t(u16, num_msix_per_vf - ICE_NONQ_VECS_VF,
+ 			ICE_MAX_RSS_QS_PER_VF);
+ 	avail_qs = ice_get_avail_rxq_count(pf) / num_vfs;
+ 	if (!avail_qs)
+ 		num_rxq = 0;
+ 	else if (num_rxq > avail_qs)
+ 		num_rxq = rounddown_pow_of_two(avail_qs);
+ 
+ 	if (num_txq < ICE_MIN_QS_PER_VF || num_rxq < ICE_MIN_QS_PER_VF) {
+ 		dev_err(dev, "Not enough queues to support minimum of %d queue pairs per VF for %d VFs\n",
+ 			ICE_MIN_QS_PER_VF, num_vfs);
+ 		return -ENOSPC;
+ 	}
+ 
+ 	err = ice_sriov_set_msix_res(pf, num_msix_per_vf * num_vfs);
+ 	if (err) {
+ 		dev_err(dev, "Unable to set MSI-X resources for %d VFs, err %d\n",
+ 			num_vfs, err);
+ 		return err;
+ 	}
+ 
+ 	/* only allow equal Tx/Rx queue count (i.e. queue pairs) */
+ 	pf->vfs.num_qps_per = min_t(int, num_txq, num_rxq);
+ 	pf->vfs.num_msix_per = num_msix_per_vf;
+ 	dev_info(dev, "Enabling %d VFs with %d vectors and %d queues per VF\n",
+ 		 num_vfs, pf->vfs.num_msix_per, pf->vfs.num_qps_per);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_clear_vf_reset_trigger - enable VF to access hardware
+  * @vf: VF to enabled hardware access for
+  */
+ static void ice_clear_vf_reset_trigger(struct ice_vf *vf)
+ {
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 	u32 reg;
+ 
+ 	reg = rd32(hw, VPGEN_VFRTRIG(vf->vf_id));
+ 	reg &= ~VPGEN_VFRTRIG_VFSWR_M;
+ 	wr32(hw, VPGEN_VFRTRIG(vf->vf_id), reg);
+ 	ice_flush(hw);
+ }
+ 
+ static void ice_vf_clear_counters(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	vf->num_mac = 0;
+ 	vsi->num_vlan = 0;
+ 	memset(&vf->mdd_tx_events, 0, sizeof(vf->mdd_tx_events));
+ 	memset(&vf->mdd_rx_events, 0, sizeof(vf->mdd_rx_events));
+ }
+ 
+ /**
+  * ice_vf_pre_vsi_rebuild - tasks to be done prior to VSI rebuild
+  * @vf: VF to perform pre VSI rebuild tasks
+  *
+  * These tasks are items that don't need to be amortized since they are most
+  * likely called in a for loop with all VF(s) in the reset_all_vfs() case.
+  */
+ static void ice_vf_pre_vsi_rebuild(struct ice_vf *vf)
+ {
+ 	ice_vf_clear_counters(vf);
+ 	ice_clear_vf_reset_trigger(vf);
+ }
+ 
+ /**
+  * ice_vf_rebuild_aggregator_node_cfg - rebuild aggregator node config
+  * @vsi: Pointer to VSI
+  *
+  * This function moves VSI into corresponding scheduler aggregator node
+  * based on cached value of "aggregator node info" per VSI
+  */
+ static void ice_vf_rebuild_aggregator_node_cfg(struct ice_vsi *vsi)
+ {
+ 	struct ice_pf *pf = vsi->back;
+ 	struct device *dev;
+ 	int status;
+ 
+ 	if (!vsi->agg_node)
+ 		return;
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	if (vsi->agg_node->num_vsis == ICE_MAX_VSIS_IN_AGG_NODE) {
+ 		dev_dbg(dev,
+ 			"agg_id %u already has reached max_num_vsis %u\n",
+ 			vsi->agg_node->agg_id, vsi->agg_node->num_vsis);
+ 		return;
+ 	}
+ 
+ 	status = ice_move_vsi_to_agg(pf->hw.port_info, vsi->agg_node->agg_id,
+ 				     vsi->idx, vsi->tc_cfg.ena_tc);
+ 	if (status)
+ 		dev_dbg(dev, "unable to move VSI idx %u into aggregator %u node",
+ 			vsi->idx, vsi->agg_node->agg_id);
+ 	else
+ 		vsi->agg_node->num_vsis++;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_cfg - host admin configuration is persistent across reset
+  * @vf: VF to rebuild host configuration on
+  */
+ static void ice_vf_rebuild_host_cfg(struct ice_vf *vf)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_vf_set_host_trust_cfg(vf);
+ 
+ 	if (ice_vf_rebuild_host_mac_cfg(vf))
+ 		dev_err(dev, "failed to rebuild default MAC configuration for VF %d\n",
+ 			vf->vf_id);
+ 
+ 	if (ice_vf_rebuild_host_vlan_cfg(vf, vsi))
+ 		dev_err(dev, "failed to rebuild VLAN configuration for VF %u\n",
+ 			vf->vf_id);
+ 
+ 	if (ice_vf_rebuild_host_tx_rate_cfg(vf))
+ 		dev_err(dev, "failed to rebuild Tx rate limiting configuration for VF %u\n",
+ 			vf->vf_id);
+ 
+ 	if (ice_vsi_apply_spoofchk(vsi, vf->spoofchk))
+ 		dev_err(dev, "failed to rebuild spoofchk configuration for VF %d\n",
+ 			vf->vf_id);
+ 
+ 	/* rebuild aggregator node config for main VF VSI */
+ 	ice_vf_rebuild_aggregator_node_cfg(vsi);
+ }
+ 
+ /**
+  * ice_vf_rebuild_vsi_with_release - release and setup the VF's VSI
+  * @vf: VF to release and setup the VSI for
+  *
+  * This is only called when a single VF is being reset (i.e. VFR, VFLR, host VF
+  * configuration change, etc.).
+  */
+ static int ice_vf_rebuild_vsi_with_release(struct ice_vf *vf)
+ {
+ 	ice_vf_vsi_release(vf);
+ 	if (!ice_vf_vsi_setup(vf))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_rebuild_vsi - rebuild the VF's VSI
+  * @vf: VF to rebuild the VSI for
+  *
+  * This is only called when all VF(s) are being reset (i.e. PCIe Reset on the
+  * host, PFR, CORER, etc.).
+  */
+ static int ice_vf_rebuild_vsi(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	struct ice_pf *pf = vf->pf;
+ 
+ 	if (ice_vsi_rebuild(vsi, true)) {
+ 		dev_err(ice_pf_to_dev(pf), "failed to rebuild VF %d VSI\n",
+ 			vf->vf_id);
+ 		return -EIO;
+ 	}
+ 	/* vsi->idx will remain the same in this case so don't update
+ 	 * vf->lan_vsi_idx
+ 	 */
+ 	vsi->vsi_num = ice_get_hw_vsi_num(&pf->hw, vsi->idx);
+ 	vf->lan_vsi_num = vsi->vsi_num;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_post_vsi_rebuild - tasks to do after the VF's VSI have been rebuilt
+  * @vf: VF to perform tasks on
+  */
+ static void ice_vf_post_vsi_rebuild(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_hw *hw;
+ 
+ 	hw = &pf->hw;
+ 
+ 	ice_vf_rebuild_host_cfg(vf);
+ 
+ 	ice_vf_set_initialized(vf);
+ 	ice_ena_vf_mappings(vf);
+ 	wr32(hw, VFGEN_RSTAT(vf->vf_id), VIRTCHNL_VFR_VFACTIVE);
+ }
+ 
+ /**
+  * ice_reset_all_vfs - reset all allocated VFs in one go
+  * @pf: pointer to the PF structure
+  * @is_vflr: true if VFLR was issued, false if not
+  *
+  * First, tell the hardware to reset each VF, then do all the waiting in one
+  * chunk, and finally finish restoring each VF after the wait. This is useful
+  * during PF routines which need to reset all VFs, as otherwise it must perform
+  * these resets in a serialized fashion.
+  *
+  * Returns true if any VFs were reset, and false otherwise.
+  */
+ bool ice_reset_all_vfs(struct ice_pf *pf, bool is_vflr)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	/* If we don't have any VFs, then there is nothing to reset */
+ 	if (!ice_has_vfs(pf))
+ 		return false;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 
+ 	/* clear all malicious info if the VFs are getting reset */
+ 	ice_for_each_vf(pf, bkt, vf)
+ 		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->vfs.malvfs,
+ 					ICE_MAX_SRIOV_VFS, vf->vf_id))
+ 			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n",
+ 				vf->vf_id);
+ 
+ 	/* If VFs have been disabled, there is no need to reset */
+ 	if (test_and_set_bit(ICE_VF_DIS, pf->state)) {
+ 		mutex_unlock(&pf->vfs.table_lock);
+ 		return false;
+ 	}
+ 
+ 	/* Begin reset on all VFs at once */
+ 	ice_for_each_vf(pf, bkt, vf)
+ 		ice_trigger_vf_reset(vf, is_vflr, true);
+ 
+ 	/* HW requires some time to make sure it can flush the FIFO for a VF
+ 	 * when it resets it. Poll the VPGEN_VFRSTAT register for each VF in
+ 	 * sequence to make sure that it has completed. We'll keep track of
+ 	 * the VFs using a simple iterator that increments once that VF has
+ 	 * finished resetting.
+ 	 */
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		bool done = false;
+ 		unsigned int i;
+ 		u32 reg;
+ 
+ 		for (i = 0; i < 10; i++) {
+ 			reg = rd32(&pf->hw, VPGEN_VFRSTAT(vf->vf_id));
+ 			if (reg & VPGEN_VFRSTAT_VFRD_M) {
+ 				done = true;
+ 				break;
+ 			}
+ 
+ 			/* only delay if check failed */
+ 			usleep_range(10, 20);
+ 		}
+ 
+ 		if (!done) {
+ 			/* Display a warning if at least one VF didn't manage
+ 			 * to reset in time, but continue on with the
+ 			 * operation.
+ 			 */
+ 			dev_warn(dev, "VF %u reset check timeout\n", vf->vf_id);
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* free VF resources to begin resetting the VSI state */
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		mutex_lock(&vf->cfg_lock);
+ 
+ 		vf->driver_caps = 0;
+ 		ice_vc_set_default_allowlist(vf);
+ 
+ 		ice_vf_fdir_exit(vf);
+ 		ice_vf_fdir_init(vf);
+ 		/* clean VF control VSI when resetting VFs since it should be
+ 		 * setup only when VF creates its first FDIR rule.
+ 		 */
+ 		if (vf->ctrl_vsi_idx != ICE_NO_VSI)
+ 			ice_vf_ctrl_invalidate_vsi(vf);
+ 
+ 		ice_vf_pre_vsi_rebuild(vf);
+ 		ice_vf_rebuild_vsi(vf);
+ 		ice_vf_post_vsi_rebuild(vf);
+ 
+ 		mutex_unlock(&vf->cfg_lock);
+ 	}
+ 
+ 	if (ice_is_eswitch_mode_switchdev(pf))
+ 		if (ice_eswitch_rebuild(pf))
+ 			dev_warn(dev, "eswitch rebuild failed\n");
+ 
+ 	ice_flush(hw);
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 
+ 	mutex_unlock(&pf->vfs.table_lock);
+ 
+ 	return true;
+ }
+ 
+ /**
+  * ice_reset_vf - Reset a particular VF
+  * @vf: pointer to the VF structure
+  * @is_vflr: true if VFLR was issued, false if not
+  *
+  * Returns true if the VF is currently in reset, resets successfully, or resets
+  * are disabled and false otherwise.
+  */
+ bool ice_reset_vf(struct ice_vf *vf, bool is_vflr)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 	struct device *dev;
+ 	struct ice_hw *hw;
+ 	bool rsd = false;
+ 	u8 promisc_m;
+ 	u32 reg;
+ 	int i;
+ 
+ 	lockdep_assert_held(&vf->cfg_lock);
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 
+ 	if (test_bit(ICE_VF_RESETS_DISABLED, pf->state)) {
+ 		dev_dbg(dev, "Trying to reset VF %d, but all VF resets are disabled\n",
+ 			vf->vf_id);
+ 		return true;
+ 	}
+ 
+ 	if (ice_is_vf_disabled(vf)) {
+ 		dev_dbg(dev, "VF is already disabled, there is no need for resetting it, telling VM, all is fine %d\n",
+ 			vf->vf_id);
+ 		return true;
+ 	}
+ 
+ 	/* Set VF disable bit state here, before triggering reset */
+ 	set_bit(ICE_VF_STATE_DIS, vf->vf_states);
+ 	ice_trigger_vf_reset(vf, is_vflr, false);
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_dis_vf_qs(vf);
+ 
+ 	/* Call Disable LAN Tx queue AQ whether or not queues are
+ 	 * enabled. This is needed for successful completion of VFR.
+ 	 */
+ 	ice_dis_vsi_txq(vsi->port_info, vsi->idx, 0, 0, NULL, NULL,
+ 			NULL, ICE_VF_RESET, vf->vf_id, NULL);
+ 
+ 	hw = &pf->hw;
+ 	/* poll VPGEN_VFRSTAT reg to make sure
+ 	 * that reset is complete
+ 	 */
+ 	for (i = 0; i < 10; i++) {
+ 		/* VF reset requires driver to first reset the VF and then
+ 		 * poll the status register to make sure that the reset
+ 		 * completed successfully.
+ 		 */
+ 		reg = rd32(hw, VPGEN_VFRSTAT(vf->vf_id));
+ 		if (reg & VPGEN_VFRSTAT_VFRD_M) {
+ 			rsd = true;
+ 			break;
+ 		}
+ 
+ 		/* only sleep if the reset is not done */
+ 		usleep_range(10, 20);
+ 	}
+ 
+ 	vf->driver_caps = 0;
+ 	ice_vc_set_default_allowlist(vf);
+ 
+ 	/* Display a warning if VF didn't manage to reset in time, but need to
+ 	 * continue on with the operation.
+ 	 */
+ 	if (!rsd)
+ 		dev_warn(dev, "VF reset check timeout on VF %d\n", vf->vf_id);
+ 
+ 	/* disable promiscuous modes in case they were enabled
+ 	 * ignore any error if disabling process failed
+ 	 */
+ 	if (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||
+ 	    test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) {
+ 		if (ice_vf_is_port_vlan_ena(vf) || vsi->num_vlan)
+ 			promisc_m = ICE_UCAST_VLAN_PROMISC_BITS;
+ 		else
+ 			promisc_m = ICE_UCAST_PROMISC_BITS;
+ 
+ 		if (ice_vf_clear_vsi_promisc(vf, vsi, promisc_m))
+ 			dev_err(dev, "disabling promiscuous mode failed\n");
+ 	}
+ 
+ 	ice_eswitch_del_vf_mac_rule(vf);
+ 
+ 	ice_vf_fdir_exit(vf);
+ 	ice_vf_fdir_init(vf);
+ 	/* clean VF control VSI when resetting VF since it should be setup
+ 	 * only when VF creates its first FDIR rule.
+ 	 */
+ 	if (vf->ctrl_vsi_idx != ICE_NO_VSI)
+ 		ice_vf_ctrl_vsi_release(vf);
+ 
+ 	ice_vf_pre_vsi_rebuild(vf);
+ 
+ 	if (ice_vf_rebuild_vsi_with_release(vf)) {
+ 		dev_err(dev, "Failed to release and setup the VF%u's VSI\n", vf->vf_id);
+ 		return false;
+ 	}
+ 
+ 	ice_vf_post_vsi_rebuild(vf);
+ 	vsi = ice_get_vf_vsi(vf);
+ 	ice_eswitch_update_repr(vsi);
+ 	ice_eswitch_replay_vf_mac_rule(vf);
+ 
+ 	/* if the VF has been reset allow it to come up again */
+ 	if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->vfs.malvfs,
+ 				ICE_MAX_SRIOV_VFS, vf->vf_id))
+ 		dev_dbg(dev, "failed to clear malicious VF state for VF %u\n", i);
+ 
+ 	return true;
+ }
+ 
+ /**
+  * ice_vc_notify_link_state - Inform all VFs on a PF of link status
+  * @pf: pointer to the PF structure
+  */
+ void ice_vc_notify_link_state(struct ice_pf *pf)
+ {
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 	ice_for_each_vf(pf, bkt, vf)
+ 		ice_vc_notify_vf_link_state(vf);
+ 	mutex_unlock(&pf->vfs.table_lock);
+ }
+ 
+ /**
+  * ice_vc_notify_reset - Send pending reset message to all VFs
+  * @pf: pointer to the PF structure
+  *
+  * indicate a pending reset to all VFs on a given PF
+  */
+ void ice_vc_notify_reset(struct ice_pf *pf)
+ {
+ 	struct virtchnl_pf_event pfe;
+ 
+ 	if (!ice_has_vfs(pf))
+ 		return;
+ 
+ 	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
+ 	pfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;
+ 	ice_vc_vf_broadcast(pf, VIRTCHNL_OP_EVENT, VIRTCHNL_STATUS_SUCCESS,
+ 			    (u8 *)&pfe, sizeof(struct virtchnl_pf_event));
+ }
+ 
+ /**
+  * ice_vc_notify_vf_reset - Notify VF of a reset event
+  * @vf: pointer to the VF structure
+  */
+ static void ice_vc_notify_vf_reset(struct ice_vf *vf)
+ {
+ 	struct virtchnl_pf_event pfe;
+ 	struct ice_pf *pf = vf->pf;
+ 
+ 	/* Bail out if VF is in disabled state, neither initialized, nor active
+ 	 * state - otherwise proceed with notifications
+ 	 */
+ 	if ((!test_bit(ICE_VF_STATE_INIT, vf->vf_states) &&
+ 	     !test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) ||
+ 	    test_bit(ICE_VF_STATE_DIS, vf->vf_states))
+ 		return;
+ 
+ 	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
+ 	pfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;
+ 	ice_aq_send_msg_to_vf(&pf->hw, vf->vf_id, VIRTCHNL_OP_EVENT,
+ 			      VIRTCHNL_STATUS_SUCCESS, (u8 *)&pfe, sizeof(pfe),
+ 			      NULL);
+ }
+ 
+ /**
+  * ice_init_vf_vsi_res - initialize/setup VF VSI resources
+  * @vf: VF to initialize/setup the VSI for
+  *
+  * This function creates a VSI for the VF, adds a VLAN 0 filter, and sets up the
+  * VF VSI's broadcast filter and is only used during initial VF creation.
+  */
+ static int ice_init_vf_vsi_res(struct ice_vf *vf)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops;
+ 	struct ice_pf *pf = vf->pf;
+ 	u8 broadcast[ETH_ALEN];
+ 	struct ice_vsi *vsi;
+ 	struct device *dev;
+ 	int err;
+ 
+ 	vf->first_vector_idx = ice_calc_vf_first_vector_idx(pf, vf);
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	vsi = ice_vf_vsi_setup(vf);
+ 	if (!vsi)
+ 		return -ENOMEM;
+ 
+ 	err = ice_vsi_add_vlan_zero(vsi);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to add VLAN 0 filter for VF %d\n",
+ 			 vf->vf_id);
+ 		goto release_vsi;
+ 	}
+ 
+ 	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	err = vlan_ops->ena_rx_filtering(vsi);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to enable Rx VLAN filtering for VF %d\n",
+ 			 vf->vf_id);
+ 		goto release_vsi;
+ 	}
+ 
+ 	eth_broadcast_addr(broadcast);
+ 	err = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);
+ 	if (err) {
+ 		dev_err(dev, "Failed to add broadcast MAC filter for VF %d, error %d\n",
+ 			vf->vf_id, err);
+ 		goto release_vsi;
+ 	}
+ 
+ 	err = ice_vsi_apply_spoofchk(vsi, vf->spoofchk);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to initialize spoofchk setting for VF %d\n",
+ 			 vf->vf_id);
+ 		goto release_vsi;
+ 	}
+ 
+ 	vf->num_mac = 1;
+ 
+ 	return 0;
+ 
+ release_vsi:
+ 	ice_vf_vsi_release(vf);
+ 	return err;
+ }
+ 
+ /**
+  * ice_start_vfs - start VFs so they are ready to be used by SR-IOV
+  * @pf: PF the VFs are associated with
+  */
+ static int ice_start_vfs(struct ice_pf *pf)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 	unsigned int bkt, it_cnt;
+ 	struct ice_vf *vf;
+ 	int retval;
+ 
+ 	lockdep_assert_held(&pf->vfs.table_lock);
+ 
+ 	it_cnt = 0;
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		ice_clear_vf_reset_trigger(vf);
+ 
+ 		retval = ice_init_vf_vsi_res(vf);
+ 		if (retval) {
+ 			dev_err(ice_pf_to_dev(pf), "Failed to initialize VSI resources for VF %d, error %d\n",
+ 				vf->vf_id, retval);
+ 			goto teardown;
+ 		}
+ 
+ 		set_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 		ice_ena_vf_mappings(vf);
+ 		wr32(hw, VFGEN_RSTAT(vf->vf_id), VIRTCHNL_VFR_VFACTIVE);
+ 		it_cnt++;
+ 	}
+ 
+ 	ice_flush(hw);
+ 	return 0;
+ 
+ teardown:
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		if (it_cnt == 0)
+ 			break;
+ 
+ 		ice_dis_vf_mappings(vf);
+ 		ice_vf_vsi_release(vf);
+ 		it_cnt--;
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ /**
+  * ice_create_vf_entries - Allocate and insert VF entries
+  * @pf: pointer to the PF structure
+  * @num_vfs: the number of VFs to allocate
+  *
+  * Allocate new VF entries and insert them into the hash table. Set some
+  * basic default fields for initializing the new VFs.
+  *
+  * After this function exits, the hash table will have num_vfs entries
+  * inserted.
+  *
+  * Returns 0 on success or an integer error code on failure.
+  */
+ static int ice_create_vf_entries(struct ice_pf *pf, u16 num_vfs)
+ {
+ 	struct ice_vfs *vfs = &pf->vfs;
+ 	struct ice_vf *vf;
+ 	u16 vf_id;
+ 	int err;
+ 
+ 	lockdep_assert_held(&vfs->table_lock);
+ 
+ 	for (vf_id = 0; vf_id < num_vfs; vf_id++) {
+ 		vf = kzalloc(sizeof(*vf), GFP_KERNEL);
+ 		if (!vf) {
+ 			err = -ENOMEM;
+ 			goto err_free_entries;
+ 		}
+ 		kref_init(&vf->refcnt);
+ 
+ 		vf->pf = pf;
+ 		vf->vf_id = vf_id;
+ 
+ 		vf->vf_sw_id = pf->first_sw;
+ 		/* assign default capabilities */
+ 		vf->spoofchk = true;
+ 		vf->num_vf_qs = pf->vfs.num_qps_per;
+ 		ice_vc_set_default_allowlist(vf);
+ 
+ 		/* ctrl_vsi_idx will be set to a valid value only when VF
+ 		 * creates its first fdir rule.
+ 		 */
+ 		ice_vf_ctrl_invalidate_vsi(vf);
+ 		ice_vf_fdir_init(vf);
+ 
+ 		ice_virtchnl_set_dflt_ops(vf);
+ 
+ 		mutex_init(&vf->cfg_lock);
+ 
+ 		hash_add_rcu(vfs->table, &vf->entry, vf_id);
+ 	}
+ 
+ 	return 0;
+ 
+ err_free_entries:
+ 	ice_free_vf_entries(pf);
+ 	return err;
+ }
+ 
+ /**
+  * ice_ena_vfs - enable VFs so they are ready to be used
+  * @pf: pointer to the PF structure
+  * @num_vfs: number of VFs to enable
+  */
+ static int ice_ena_vfs(struct ice_pf *pf, u16 num_vfs)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	int ret;
+ 
+ 	/* Disable global interrupt 0 so we don't try to handle the VFLR. */
+ 	wr32(hw, GLINT_DYN_CTL(pf->oicr_idx),
+ 	     ICE_ITR_NONE << GLINT_DYN_CTL_ITR_INDX_S);
+ 	set_bit(ICE_OICR_INTR_DIS, pf->state);
+ 	ice_flush(hw);
+ 
+ 	ret = pci_enable_sriov(pf->pdev, num_vfs);
+ 	if (ret)
+ 		goto err_unroll_intr;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 
+ 	ret = ice_set_per_vf_res(pf, num_vfs);
+ 	if (ret) {
+ 		dev_err(dev, "Not enough resources for %d VFs, err %d. Try with fewer number of VFs\n",
+ 			num_vfs, ret);
+ 		goto err_unroll_sriov;
+ 	}
+ 
+ 	ret = ice_create_vf_entries(pf, num_vfs);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to allocate VF entries for %d VFs\n",
+ 			num_vfs);
+ 		goto err_unroll_sriov;
+ 	}
+ 
+ 	ret = ice_start_vfs(pf);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to start %d VFs, err %d\n", num_vfs, ret);
+ 		ret = -EAGAIN;
+ 		goto err_unroll_vf_entries;
+ 	}
+ 
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 
+ 	ret = ice_eswitch_configure(pf);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to configure eswitch, err %d\n", ret);
+ 		goto err_unroll_sriov;
+ 	}
+ 
+ 	/* rearm global interrupts */
+ 	if (test_and_clear_bit(ICE_OICR_INTR_DIS, pf->state))
+ 		ice_irq_dynamic_ena(hw, NULL, NULL);
+ 
+ 	mutex_unlock(&pf->vfs.table_lock);
+ 
+ 	return 0;
+ 
+ err_unroll_vf_entries:
+ 	ice_free_vf_entries(pf);
+ err_unroll_sriov:
+ 	mutex_unlock(&pf->vfs.table_lock);
+ 	pci_disable_sriov(pf->pdev);
+ err_unroll_intr:
+ 	/* rearm interrupts here */
+ 	ice_irq_dynamic_ena(hw, NULL, NULL);
+ 	clear_bit(ICE_OICR_INTR_DIS, pf->state);
+ 	return ret;
+ }
+ 
+ /**
+  * ice_pci_sriov_ena - Enable or change number of VFs
+  * @pf: pointer to the PF structure
+  * @num_vfs: number of VFs to allocate
+  *
+  * Returns 0 on success and negative on failure
+  */
+ static int ice_pci_sriov_ena(struct ice_pf *pf, int num_vfs)
+ {
+ 	int pre_existing_vfs = pci_num_vf(pf->pdev);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	int err;
+ 
+ 	if (pre_existing_vfs && pre_existing_vfs != num_vfs)
+ 		ice_free_vfs(pf);
+ 	else if (pre_existing_vfs && pre_existing_vfs == num_vfs)
+ 		return 0;
+ 
+ 	if (num_vfs > pf->vfs.num_supported) {
+ 		dev_err(dev, "Can't enable %d VFs, max VFs supported is %d\n",
+ 			num_vfs, pf->vfs.num_supported);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	dev_info(dev, "Enabling %d VFs\n", num_vfs);
+ 	err = ice_ena_vfs(pf, num_vfs);
+ 	if (err) {
+ 		dev_err(dev, "Failed to enable SR-IOV: %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	set_bit(ICE_FLAG_SRIOV_ENA, pf->flags);
+ 	return 0;
+ }
+ 
+ /**
+  * ice_check_sriov_allowed - check if SR-IOV is allowed based on various checks
+  * @pf: PF to enabled SR-IOV on
+  */
+ static int ice_check_sriov_allowed(struct ice_pf *pf)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 
+ 	if (!test_bit(ICE_FLAG_SRIOV_CAPABLE, pf->flags)) {
+ 		dev_err(dev, "This device is not capable of SR-IOV\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (ice_is_safe_mode(pf)) {
+ 		dev_err(dev, "SR-IOV cannot be configured - Device is in Safe Mode\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!ice_pf_state_is_nominal(pf)) {
+ 		dev_err(dev, "Cannot enable SR-IOV, device not ready\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_sriov_configure - Enable or change number of VFs via sysfs
+  * @pdev: pointer to a pci_dev structure
+  * @num_vfs: number of VFs to allocate or 0 to free VFs
+  *
+  * This function is called when the user updates the number of VFs in sysfs. On
+  * success return whatever num_vfs was set to by the caller. Return negative on
+  * failure.
+  */
+ int ice_sriov_configure(struct pci_dev *pdev, int num_vfs)
+ {
+ 	struct ice_pf *pf = pci_get_drvdata(pdev);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	int err;
+ 
+ 	err = ice_check_sriov_allowed(pf);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!num_vfs) {
+ 		if (!pci_vfs_assigned(pdev)) {
+ 			ice_mbx_deinit_snapshot(&pf->hw);
+ 			ice_free_vfs(pf);
+ 			if (pf->lag)
+ 				ice_enable_lag(pf->lag);
+ 			return 0;
+ 		}
+ 
+ 		dev_err(dev, "can't free VFs because some are assigned to VMs.\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = ice_mbx_init_snapshot(&pf->hw, num_vfs);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_pci_sriov_ena(pf, num_vfs);
+ 	if (err) {
+ 		ice_mbx_deinit_snapshot(&pf->hw);
+ 		return err;
+ 	}
+ 
+ 	if (pf->lag)
+ 		ice_disable_lag(pf->lag);
+ 	return num_vfs;
+ }
+ 
+ /**
+  * ice_process_vflr_event - Free VF resources via IRQ calls
+  * @pf: pointer to the PF structure
+  *
+  * called from the VFLR IRQ handler to
+  * free up VF resources and state variables
+  */
+ void ice_process_vflr_event(struct ice_pf *pf)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 	u32 reg;
+ 
+ 	if (!test_and_clear_bit(ICE_VFLR_EVENT_PENDING, pf->state) ||
+ 	    !ice_has_vfs(pf))
+ 		return;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		u32 reg_idx, bit_idx;
+ 
+ 		reg_idx = (hw->func_caps.vf_base_id + vf->vf_id) / 32;
+ 		bit_idx = (hw->func_caps.vf_base_id + vf->vf_id) % 32;
+ 		/* read GLGEN_VFLRSTAT register to find out the flr VFs */
+ 		reg = rd32(hw, GLGEN_VFLRSTAT(reg_idx));
+ 		if (reg & BIT(bit_idx)) {
+ 			/* GLGEN_VFLRSTAT bit will be cleared in ice_reset_vf */
+ 			mutex_lock(&vf->cfg_lock);
+ 			ice_reset_vf(vf, true);
+ 			mutex_unlock(&vf->cfg_lock);
+ 		}
+ 	}
+ 	mutex_unlock(&pf->vfs.table_lock);
+ }
+ 
+ /**
+  * ice_vc_reset_vf - Perform software reset on the VF after informing the AVF
+  * @vf: pointer to the VF info
+  */
+ static void ice_vc_reset_vf(struct ice_vf *vf)
+ {
+ 	ice_vc_notify_vf_reset(vf);
+ 	ice_reset_vf(vf, false);
+ }
+ 
+ /**
+  * ice_get_vf_from_pfq - get the VF who owns the PF space queue passed in
+  * @pf: PF used to index all VFs
+  * @pfq: queue index relative to the PF's function space
+  *
+  * If no VF is found who owns the pfq then return NULL, otherwise return a
+  * pointer to the VF who owns the pfq
+  *
+  * If this function returns non-NULL, it acquires a reference count of the VF
+  * structure. The caller is responsible for calling ice_put_vf() to drop this
+  * reference.
+  */
+ static struct ice_vf *ice_get_vf_from_pfq(struct ice_pf *pf, u16 pfq)
+ {
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	rcu_read_lock();
+ 	ice_for_each_vf_rcu(pf, bkt, vf) {
+ 		struct ice_vsi *vsi;
+ 		u16 rxq_idx;
+ 
+ 		vsi = ice_get_vf_vsi(vf);
+ 
+ 		ice_for_each_rxq(vsi, rxq_idx)
+ 			if (vsi->rxq_map[rxq_idx] == pfq) {
+ 				struct ice_vf *found;
+ 
+ 				if (kref_get_unless_zero(&vf->refcnt))
+ 					found = vf;
+ 				else
+ 					found = NULL;
+ 				rcu_read_unlock();
+ 				return found;
+ 			}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * ice_globalq_to_pfq - convert from global queue index to PF space queue index
+  * @pf: PF used for conversion
+  * @globalq: global queue index used to convert to PF space queue index
+  */
+ static u32 ice_globalq_to_pfq(struct ice_pf *pf, u32 globalq)
+ {
+ 	return globalq - pf->hw.func_caps.common_cap.rxq_first_id;
+ }
+ 
+ /**
+  * ice_vf_lan_overflow_event - handle LAN overflow event for a VF
+  * @pf: PF that the LAN overflow event happened on
+  * @event: structure holding the event information for the LAN overflow event
+  *
+  * Determine if the LAN overflow event was caused by a VF queue. If it was not
+  * caused by a VF, do nothing. If a VF caused this LAN overflow event trigger a
+  * reset on the offending VF.
+  */
+ void
+ ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event)
+ {
+ 	u32 gldcb_rtctq, queue;
+ 	struct ice_vf *vf;
+ 
+ 	gldcb_rtctq = le32_to_cpu(event->desc.params.lan_overflow.prtdcb_ruptq);
+ 	dev_dbg(ice_pf_to_dev(pf), "GLDCB_RTCTQ: 0x%08x\n", gldcb_rtctq);
+ 
+ 	/* event returns device global Rx queue number */
+ 	queue = (gldcb_rtctq & GLDCB_RTCTQ_RXQNUM_M) >>
+ 		GLDCB_RTCTQ_RXQNUM_S;
+ 
+ 	vf = ice_get_vf_from_pfq(pf, ice_globalq_to_pfq(pf, queue));
+ 	if (!vf)
+ 		return;
+ 
+ 	mutex_lock(&vf->cfg_lock);
+ 	ice_vc_reset_vf(vf);
+ 	mutex_unlock(&vf->cfg_lock);
+ 
+ 	ice_put_vf(vf);
+ }
+ 
+ /**
+  * ice_vc_send_msg_to_vf - Send message to VF
+  * @vf: pointer to the VF info
+  * @v_opcode: virtual channel opcode
+  * @v_retval: virtual channel return value
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * send msg to VF
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
   */
  int
 -ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
 -		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)
 +ice_aq_send_msg_to_vf(struct ice_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval,
 +		      u8 *msg, u16 msglen, struct ice_sq_cd *cd)
  {
 -	struct device *dev;
 -	struct ice_pf *pf;
 -	int aq_ret;
 -
 -	pf = vf->pf;
 -	dev = ice_pf_to_dev(pf);
 -
 -	aq_ret = ice_aq_send_msg_to_vf(&pf->hw, vf->vf_id, v_opcode, v_retval,
 -				       msg, msglen, NULL);
 -	if (aq_ret && pf->hw.mailboxq.sq_last_status != ICE_AQ_RC_ENOSYS) {
 -		dev_info(dev, "Unable to send the message to VF %d ret %d aq_err %s\n",
 -			 vf->vf_id, aq_ret,
 -			 ice_aq_str(pf->hw.mailboxq.sq_last_status));
 -		return -EIO;
 -	}
 -
 -	return 0;
 -}
 +	struct ice_aqc_pf_vf_msg *cmd;
 +	struct ice_aq_desc desc;
  
 -/**
 - * ice_vc_get_ver_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to request the API version used by the PF
 - */
 -static int ice_vc_get_ver_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	struct virtchnl_version_info info = {
 -		VIRTCHNL_VERSION_MAJOR, VIRTCHNL_VERSION_MINOR
 -	};
 -
 -	vf->vf_ver = *(struct virtchnl_version_info *)msg;
 -	/* VFs running the 1.0 API expect to get 1.0 back or they will cry. */
 -	if (VF_IS_V10(&vf->vf_ver))
 -		info.minor = VIRTCHNL_VERSION_MINOR_NO_VF_CAPS;
 -
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_VERSION,
 -				     VIRTCHNL_STATUS_SUCCESS, (u8 *)&info,
 -				     sizeof(struct virtchnl_version_info));
 -}
 +	ice_fill_dflt_direct_cmd_desc(&desc, ice_mbx_opc_send_msg_to_vf);
  
 -/**
 - * ice_vc_get_max_frame_size - get max frame size allowed for VF
 - * @vf: VF used to determine max frame size
 - *
 - * Max frame size is determined based on the current port's max frame size and
 - * whether a port VLAN is configured on this VF. The VF is not aware whether
 - * it's in a port VLAN so the PF needs to account for this in max frame size
 - * checks and sending the max frame size to the VF.
 - */
 -static u16 ice_vc_get_max_frame_size(struct ice_vf *vf)
 -{
 -	struct ice_port_info *pi = ice_vf_get_port_info(vf);
 -	u16 max_frame_size;
 +	cmd = &desc.params.virt;
 +	cmd->id = cpu_to_le32(vfid);
  
 -	max_frame_size = pi->phy.link_info.max_frame_size;
 +	desc.cookie_high = cpu_to_le32(v_opcode);
 +	desc.cookie_low = cpu_to_le32(v_retval);
  
 -	if (ice_vf_is_port_vlan_ena(vf))
 -		max_frame_size -= VLAN_HLEN;
 +	if (msglen)
 +		desc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);
  
 -	return max_frame_size;
 +	return ice_sq_send_cmd(hw, &hw->mailboxq, &desc, msg, msglen, cd);
  }
  
  /**
 - * ice_vc_get_vf_res_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 + * ice_conv_link_speed_to_virtchnl
 + * @adv_link_support: determines the format of the returned link speed
 + * @link_speed: variable containing the link_speed to be converted
   *
 - * called from the VF to request its resources
 + * Convert link speed supported by HW to link speed supported by virtchnl.
 + * If adv_link_support is true, then return link speed in Mbps. Else return
 + * link speed as a VIRTCHNL_LINK_SPEED_* casted to a u32. Note that the caller
 + * needs to cast back to an enum virtchnl_link_speed in the case where
 + * adv_link_support is false, but when adv_link_support is true the caller can
 + * expect the speed in Mbps.
   */
 -static int ice_vc_get_vf_res_msg(struct ice_vf *vf, u8 *msg)
 +u32 ice_conv_link_speed_to_virtchnl(bool adv_link_support, u16 link_speed)
  {
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vf_resource *vfres = NULL;
 -	struct ice_pf *pf = vf->pf;
 -	struct ice_vsi *vsi;
 -	int len = 0;
 -	int ret;
 -
 -	if (ice_check_vf_init(pf, vf)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto err;
 -	}
 -
 -	len = sizeof(struct virtchnl_vf_resource);
 +	u32 speed;
  
 -	vfres = kzalloc(len, GFP_KERNEL);
 -	if (!vfres) {
 -		v_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;
 -		len = 0;
 -		goto err;
 -	}
 -	if (VF_IS_V11(&vf->vf_ver))
 -		vf->driver_caps = *(u32 *)msg;
 +	if (adv_link_support)
 +		switch (link_speed) {
 +		case ICE_AQ_LINK_SPEED_10MB:
 +			speed = ICE_LINK_SPEED_10MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_100MB:
 +			speed = ICE_LINK_SPEED_100MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_1000MB:
 +			speed = ICE_LINK_SPEED_1000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_2500MB:
 +			speed = ICE_LINK_SPEED_2500MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_5GB:
 +			speed = ICE_LINK_SPEED_5000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_10GB:
 +			speed = ICE_LINK_SPEED_10000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_20GB:
 +			speed = ICE_LINK_SPEED_20000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_25GB:
 +			speed = ICE_LINK_SPEED_25000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_40GB:
 +			speed = ICE_LINK_SPEED_40000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_50GB:
 +			speed = ICE_LINK_SPEED_50000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_100GB:
 +			speed = ICE_LINK_SPEED_100000MBPS;
 +			break;
 +		default:
 +			speed = ICE_LINK_SPEED_UNKNOWN;
 +			break;
 +		}
++<<<<<<< HEAD
  	else
 -		vf->driver_caps = VIRTCHNL_VF_OFFLOAD_L2 |
 -				  VIRTCHNL_VF_OFFLOAD_RSS_REG |
 -				  VIRTCHNL_VF_OFFLOAD_VLAN;
 -
 -	vfres->vf_cap_flags = VIRTCHNL_VF_OFFLOAD_L2;
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto err;
 -	}
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_VLAN_V2) {
 -		/* VLAN offloads based on current device configuration */
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_VLAN_V2;
 -	} else if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_VLAN) {
 -		/* allow VF to negotiate VIRTCHNL_VF_OFFLOAD explicitly for
 -		 * these two conditions, which amounts to guest VLAN filtering
 -		 * and offloads being based on the inner VLAN or the
 -		 * inner/single VLAN respectively and don't allow VF to
 -		 * negotiate VIRTCHNL_VF_OFFLOAD in any other cases
 +		/* Virtchnl speeds are not defined for every speed supported in
 +		 * the hardware. To maintain compatibility with older AVF
 +		 * drivers, while reporting the speed the new speed values are
 +		 * resolved to the closest known virtchnl speeds
  		 */
 -		if (ice_is_dvm_ena(&pf->hw) && ice_vf_is_port_vlan_ena(vf)) {
 -			vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_VLAN;
 -		} else if (!ice_is_dvm_ena(&pf->hw) &&
 -			   !ice_vf_is_port_vlan_ena(vf)) {
 -			vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_VLAN;
 -			/* configure backward compatible support for VFs that
 -			 * only support VIRTCHNL_VF_OFFLOAD_VLAN, the PF is
 -			 * configured in SVM, and no port VLAN is configured
 -			 */
 -			ice_vf_vsi_cfg_svm_legacy_vlan_mode(vsi);
 -		} else if (ice_is_dvm_ena(&pf->hw)) {
 -			/* configure software offloaded VLAN support when DVM
 -			 * is enabled, but no port VLAN is enabled
 -			 */
 -			ice_vf_vsi_cfg_dvm_legacy_vlan_mode(vsi);
 -		}
 -	}
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PF) {
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PF;
 -	} else {
 -		if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_AQ)
 -			vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_AQ;
 -		else
 -			vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_REG;
 -	}
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_FDIR_PF)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_FDIR_PF;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_POLLING)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RX_POLLING;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_REQ_QUEUES)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_REQ_QUEUES;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_CAP_ADV_LINK_SPEED)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_CAP_ADV_LINK_SPEED;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF;
 -
 -	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_USO)
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_USO;
 -
 -	vfres->num_vsis = 1;
 -	/* Tx and Rx queue are equal for VF */
 -	vfres->num_queue_pairs = vsi->num_txq;
 -	vfres->max_vectors = pf->vfs.num_msix_per;
 -	vfres->rss_key_size = ICE_VSIQF_HKEY_ARRAY_SIZE;
 -	vfres->rss_lut_size = ICE_VSIQF_HLUT_ARRAY_SIZE;
 -	vfres->max_mtu = ice_vc_get_max_frame_size(vf);
 -
 -	vfres->vsi_res[0].vsi_id = vf->lan_vsi_num;
 -	vfres->vsi_res[0].vsi_type = VIRTCHNL_VSI_SRIOV;
 -	vfres->vsi_res[0].num_queue_pairs = vsi->num_txq;
 -	ether_addr_copy(vfres->vsi_res[0].default_mac_addr,
 -			vf->hw_lan_addr.addr);
 -
 -	/* match guest capabilities */
 -	vf->driver_caps = vfres->vf_cap_flags;
 -
 -	ice_vc_set_caps_allowlist(vf);
 -	ice_vc_set_working_allowlist(vf);
 -
 -	set_bit(ICE_VF_STATE_ACTIVE, vf->vf_states);
 -
 -err:
 -	/* send the response back to the VF */
 -	ret = ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_VF_RESOURCES, v_ret,
 -				    (u8 *)vfres, len);
 -
 -	kfree(vfres);
 -	return ret;
 -}
 -
 -/**
 - * ice_vc_reset_vf_msg
 - * @vf: pointer to the VF info
 - *
 - * called from the VF to reset itself,
 - * unlike other virtchnl messages, PF driver
 - * doesn't send the response back to the VF
 - */
 -static void ice_vc_reset_vf_msg(struct ice_vf *vf)
 -{
 -	if (test_bit(ICE_VF_STATE_INIT, vf->vf_states))
 -		ice_reset_vf(vf, false);
 -}
 -
 -/**
 - * ice_find_vsi_from_id
 - * @pf: the PF structure to search for the VSI
 - * @id: ID of the VSI it is searching for
 - *
 - * searches for the VSI with the given ID
 - */
 -static struct ice_vsi *ice_find_vsi_from_id(struct ice_pf *pf, u16 id)
 -{
 -	int i;
 -
 -	ice_for_each_vsi(pf, i)
 -		if (pf->vsi[i] && pf->vsi[i]->vsi_num == id)
 -			return pf->vsi[i];
 -
 -	return NULL;
 -}
 -
 -/**
 - * ice_vc_isvalid_vsi_id
 - * @vf: pointer to the VF info
 - * @vsi_id: VF relative VSI ID
 - *
 - * check for the valid VSI ID
 - */
 -bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id)
 -{
 -	struct ice_pf *pf = vf->pf;
 -	struct ice_vsi *vsi;
 -
 -	vsi = ice_find_vsi_from_id(pf, vsi_id);
 -
 -	return (vsi && (vsi->vf == vf));
 -}
 -
 -/**
 - * ice_vc_isvalid_q_id
 - * @vf: pointer to the VF info
 - * @vsi_id: VSI ID
 - * @qid: VSI relative queue ID
 - *
 - * check for the valid queue ID
 - */
 -static bool ice_vc_isvalid_q_id(struct ice_vf *vf, u16 vsi_id, u8 qid)
 -{
 -	struct ice_vsi *vsi = ice_find_vsi_from_id(vf->pf, vsi_id);
 -	/* allocated Tx and Rx queues should be always equal for VF VSI */
 -	return (vsi && (qid < vsi->alloc_txq));
 -}
 -
 -/**
 - * ice_vc_isvalid_ring_len
 - * @ring_len: length of ring
 - *
 - * check for the valid ring count, should be multiple of ICE_REQ_DESC_MULTIPLE
 - * or zero
 - */
 -static bool ice_vc_isvalid_ring_len(u16 ring_len)
 -{
 -	return ring_len == 0 ||
 -	       (ring_len >= ICE_MIN_NUM_DESC &&
 -		ring_len <= ICE_MAX_NUM_DESC &&
 -		!(ring_len % ICE_REQ_DESC_MULTIPLE));
 -}
 -
 -/**
 - * ice_vc_validate_pattern
 - * @vf: pointer to the VF info
 - * @proto: virtchnl protocol headers
 - *
 - * validate the pattern is supported or not.
 - *
 - * Return: true on success, false on error.
 - */
 -bool
 -ice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto)
 -{
 -	bool is_ipv4 = false;
 -	bool is_ipv6 = false;
 -	bool is_udp = false;
 -	u16 ptype = -1;
 -	int i = 0;
 -
 -	while (i < proto->count &&
 -	       proto->proto_hdr[i].type != VIRTCHNL_PROTO_HDR_NONE) {
 -		switch (proto->proto_hdr[i].type) {
 -		case VIRTCHNL_PROTO_HDR_ETH:
 -			ptype = ICE_PTYPE_MAC_PAY;
 +		switch (link_speed) {
 +		case ICE_AQ_LINK_SPEED_10MB:
 +		case ICE_AQ_LINK_SPEED_100MB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_100MB;
  			break;
 -		case VIRTCHNL_PROTO_HDR_IPV4:
 -			ptype = ICE_PTYPE_IPV4_PAY;
 -			is_ipv4 = true;
 +		case ICE_AQ_LINK_SPEED_1000MB:
 +		case ICE_AQ_LINK_SPEED_2500MB:
 +		case ICE_AQ_LINK_SPEED_5GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_1GB;
  			break;
 -		case VIRTCHNL_PROTO_HDR_IPV6:
 -			ptype = ICE_PTYPE_IPV6_PAY;
 -			is_ipv6 = true;
 +		case ICE_AQ_LINK_SPEED_10GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_10GB;
  			break;
 -		case VIRTCHNL_PROTO_HDR_UDP:
 -			if (is_ipv4)
 -				ptype = ICE_PTYPE_IPV4_UDP_PAY;
 -			else if (is_ipv6)
 -				ptype = ICE_PTYPE_IPV6_UDP_PAY;
 -			is_udp = true;
 +		case ICE_AQ_LINK_SPEED_20GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_20GB;
  			break;
 -		case VIRTCHNL_PROTO_HDR_TCP:
 -			if (is_ipv4)
 -				ptype = ICE_PTYPE_IPV4_TCP_PAY;
 -			else if (is_ipv6)
 -				ptype = ICE_PTYPE_IPV6_TCP_PAY;
 +		case ICE_AQ_LINK_SPEED_25GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_25GB;
  			break;
 -		case VIRTCHNL_PROTO_HDR_SCTP:
 -			if (is_ipv4)
 -				ptype = ICE_PTYPE_IPV4_SCTP_PAY;
 -			else if (is_ipv6)
 -				ptype = ICE_PTYPE_IPV6_SCTP_PAY;
 +		case ICE_AQ_LINK_SPEED_40GB:
 +		case ICE_AQ_LINK_SPEED_50GB:
 +		case ICE_AQ_LINK_SPEED_100GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_40GB;
  			break;
 -		case VIRTCHNL_PROTO_HDR_GTPU_IP:
 -		case VIRTCHNL_PROTO_HDR_GTPU_EH:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_GTPU;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_GTPU;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_L2TPV3:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_L2TPV3;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_L2TPV3;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_ESP:
 -			if (is_ipv4)
 -				ptype = is_udp ? ICE_MAC_IPV4_NAT_T_ESP :
 -						ICE_MAC_IPV4_ESP;
 -			else if (is_ipv6)
 -				ptype = is_udp ? ICE_MAC_IPV6_NAT_T_ESP :
 -						ICE_MAC_IPV6_ESP;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_AH:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_AH;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_AH;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_PFCP:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_PFCP_SESSION;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_PFCP_SESSION;
 -			goto out;
  		default:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_UNKNOWN;
  			break;
  		}
 +
 +	return speed;
 +}
 +
 +/* The mailbox overflow detection algorithm helps to check if there
 + * is a possibility of a malicious VF transmitting too many MBX messages to the
 + * PF.
 + * 1. The mailbox snapshot structure, ice_mbx_snapshot, is initialized during
 + * driver initialization in ice_init_hw() using ice_mbx_init_snapshot().
 + * The struct ice_mbx_snapshot helps to track and traverse a static window of
 + * messages within the mailbox queue while looking for a malicious VF.
++=======
+ 		i++;
+ 	}
+ 
+ out:
+ 	return ice_hw_ptype_ena(&vf->pf->hw, ptype);
+ }
+ 
+ /**
+  * ice_vc_parse_rss_cfg - parses hash fields and headers from
+  * a specific virtchnl RSS cfg
+  * @hw: pointer to the hardware
+  * @rss_cfg: pointer to the virtchnl RSS cfg
+  * @addl_hdrs: pointer to the protocol header fields (ICE_FLOW_SEG_HDR_*)
+  * to configure
+  * @hash_flds: pointer to the hash bit fields (ICE_FLOW_HASH_*) to configure
+  *
+  * Return true if all the protocol header and hash fields in the RSS cfg could
+  * be parsed, else return false
+  *
+  * This function parses the virtchnl RSS cfg to be the intended
+  * hash fields and the intended header for RSS configuration
+  */
+ static bool
+ ice_vc_parse_rss_cfg(struct ice_hw *hw, struct virtchnl_rss_cfg *rss_cfg,
+ 		     u32 *addl_hdrs, u64 *hash_flds)
+ {
+ 	const struct ice_vc_hash_field_match_type *hf_list;
+ 	const struct ice_vc_hdr_match_type *hdr_list;
+ 	int i, hf_list_len, hdr_list_len;
+ 
+ 	hf_list = ice_vc_hash_field_list;
+ 	hf_list_len = ARRAY_SIZE(ice_vc_hash_field_list);
+ 	hdr_list = ice_vc_hdr_list;
+ 	hdr_list_len = ARRAY_SIZE(ice_vc_hdr_list);
+ 
+ 	for (i = 0; i < rss_cfg->proto_hdrs.count; i++) {
+ 		struct virtchnl_proto_hdr *proto_hdr =
+ 					&rss_cfg->proto_hdrs.proto_hdr[i];
+ 		bool hdr_found = false;
+ 		int j;
+ 
+ 		/* Find matched ice headers according to virtchnl headers. */
+ 		for (j = 0; j < hdr_list_len; j++) {
+ 			struct ice_vc_hdr_match_type hdr_map = hdr_list[j];
+ 
+ 			if (proto_hdr->type == hdr_map.vc_hdr) {
+ 				*addl_hdrs |= hdr_map.ice_hdr;
+ 				hdr_found = true;
+ 			}
+ 		}
+ 
+ 		if (!hdr_found)
+ 			return false;
+ 
+ 		/* Find matched ice hash fields according to
+ 		 * virtchnl hash fields.
+ 		 */
+ 		for (j = 0; j < hf_list_len; j++) {
+ 			struct ice_vc_hash_field_match_type hf_map = hf_list[j];
+ 
+ 			if (proto_hdr->type == hf_map.vc_hdr &&
+ 			    proto_hdr->field_selector == hf_map.vc_hash_field) {
+ 				*hash_flds |= hf_map.ice_hash_field;
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /**
+  * ice_vf_adv_rss_offload_ena - determine if capabilities support advanced
+  * RSS offloads
+  * @caps: VF driver negotiated capabilities
+  *
+  * Return true if VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF capability is set,
+  * else return false
+  */
+ static bool ice_vf_adv_rss_offload_ena(u32 caps)
+ {
+ 	return !!(caps & VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF);
+ }
+ 
+ /**
+  * ice_vc_handle_rss_cfg
+  * @vf: pointer to the VF info
+  * @msg: pointer to the message buffer
+  * @add: add a RSS config if true, otherwise delete a RSS config
+  *
+  * This function adds/deletes a RSS config
+  */
+ static int ice_vc_handle_rss_cfg(struct ice_vf *vf, u8 *msg, bool add)
+ {
+ 	u32 v_opcode = add ? VIRTCHNL_OP_ADD_RSS_CFG : VIRTCHNL_OP_DEL_RSS_CFG;
+ 	struct virtchnl_rss_cfg *rss_cfg = (struct virtchnl_rss_cfg *)msg;
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 	struct ice_vsi *vsi;
+ 
+ 	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
+ 		dev_dbg(dev, "VF %d attempting to configure RSS, but RSS is not supported by the PF\n",
+ 			vf->vf_id);
+ 		v_ret = VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!ice_vf_adv_rss_offload_ena(vf->driver_caps)) {
+ 		dev_dbg(dev, "VF %d attempting to configure RSS, but Advanced RSS offload is not supported\n",
+ 			vf->vf_id);
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (rss_cfg->proto_hdrs.count > VIRTCHNL_MAX_NUM_PROTO_HDRS ||
+ 	    rss_cfg->rss_algorithm < VIRTCHNL_RSS_ALG_TOEPLITZ_ASYMMETRIC ||
+ 	    rss_cfg->rss_algorithm > VIRTCHNL_RSS_ALG_XOR_SYMMETRIC) {
+ 		dev_dbg(dev, "VF %d attempting to configure RSS, but RSS configuration is not valid\n",
+ 			vf->vf_id);
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!ice_vc_validate_pattern(vf, &rss_cfg->proto_hdrs)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (rss_cfg->rss_algorithm == VIRTCHNL_RSS_ALG_R_ASYMMETRIC) {
+ 		struct ice_vsi_ctx *ctx;
+ 		u8 lut_type, hash_type;
+ 		int status;
+ 
+ 		lut_type = ICE_AQ_VSI_Q_OPT_RSS_LUT_VSI;
+ 		hash_type = add ? ICE_AQ_VSI_Q_OPT_RSS_XOR :
+ 				ICE_AQ_VSI_Q_OPT_RSS_TPLZ;
+ 
+ 		ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+ 		if (!ctx) {
+ 			v_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;
+ 			goto error_param;
+ 		}
+ 
+ 		ctx->info.q_opt_rss = ((lut_type <<
+ 					ICE_AQ_VSI_Q_OPT_RSS_LUT_S) &
+ 				       ICE_AQ_VSI_Q_OPT_RSS_LUT_M) |
+ 				       (hash_type &
+ 					ICE_AQ_VSI_Q_OPT_RSS_HASH_M);
+ 
+ 		/* Preserve existing queueing option setting */
+ 		ctx->info.q_opt_rss |= (vsi->info.q_opt_rss &
+ 					  ICE_AQ_VSI_Q_OPT_RSS_GBL_LUT_M);
+ 		ctx->info.q_opt_tc = vsi->info.q_opt_tc;
+ 		ctx->info.q_opt_flags = vsi->info.q_opt_rss;
+ 
+ 		ctx->info.valid_sections =
+ 				cpu_to_le16(ICE_AQ_VSI_PROP_Q_OPT_VALID);
+ 
+ 		status = ice_update_vsi(hw, vsi->idx, ctx, NULL);
+ 		if (status) {
+ 			dev_err(dev, "update VSI for RSS failed, err %d aq_err %s\n",
+ 				status, ice_aq_str(hw->adminq.sq_last_status));
+ 			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		} else {
+ 			vsi->info.q_opt_rss = ctx->info.q_opt_rss;
+ 		}
+ 
+ 		kfree(ctx);
+ 	} else {
+ 		u32 addl_hdrs = ICE_FLOW_SEG_HDR_NONE;
+ 		u64 hash_flds = ICE_HASH_INVALID;
+ 
+ 		if (!ice_vc_parse_rss_cfg(hw, rss_cfg, &addl_hdrs,
+ 					  &hash_flds)) {
+ 			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 			goto error_param;
+ 		}
+ 
+ 		if (add) {
+ 			if (ice_add_rss_cfg(hw, vsi->idx, hash_flds,
+ 					    addl_hdrs)) {
+ 				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 				dev_err(dev, "ice_add_rss_cfg failed for vsi = %d, v_ret = %d\n",
+ 					vsi->vsi_num, v_ret);
+ 			}
+ 		} else {
+ 			int status;
+ 
+ 			status = ice_rem_rss_cfg(hw, vsi->idx, hash_flds,
+ 						 addl_hdrs);
+ 			/* We just ignore -ENOENT, because if two configurations
+ 			 * share the same profile remove one of them actually
+ 			 * removes both, since the profile is deleted.
+ 			 */
+ 			if (status && status != -ENOENT) {
+ 				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 				dev_err(dev, "ice_rem_rss_cfg failed for VF ID:%d, error:%d\n",
+ 					vf->vf_id, status);
+ 			}
+ 		}
+ 	}
+ 
+ error_param:
+ 	return ice_vc_send_msg_to_vf(vf, v_opcode, v_ret, NULL, 0);
+ }
+ 
+ /**
+  * ice_vc_config_rss_key
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  *
+  * Configure the VF's RSS key
+  */
+ static int ice_vc_config_rss_key(struct ice_vf *vf, u8 *msg)
+ {
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
+ 	struct virtchnl_rss_key *vrk =
+ 		(struct virtchnl_rss_key *)msg;
+ 	struct ice_vsi *vsi;
+ 
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!ice_vc_isvalid_vsi_id(vf, vrk->vsi_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (vrk->key_len != ICE_VSIQF_HKEY_ARRAY_SIZE) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (ice_set_rss_key(vsi, vrk->key))
+ 		v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
+ error_param:
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_KEY, v_ret,
+ 				     NULL, 0);
+ }
+ 
+ /**
+  * ice_vc_config_rss_lut
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  *
+  * Configure the VF's RSS LUT
+  */
+ static int ice_vc_config_rss_lut(struct ice_vf *vf, u8 *msg)
+ {
+ 	struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
+ 	struct ice_vsi *vsi;
+ 
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!ice_vc_isvalid_vsi_id(vf, vrl->vsi_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (vrl->lut_entries != ICE_VSIQF_HLUT_ARRAY_SIZE) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (ice_set_rss_lut(vsi, vrl->lut, ICE_VSIQF_HLUT_ARRAY_SIZE))
+ 		v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
+ error_param:
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_LUT, v_ret,
+ 				     NULL, 0);
+ }
+ 
+ /**
+  * ice_set_vf_spoofchk
+  * @netdev: network interface device structure
+  * @vf_id: VF identifier
+  * @ena: flag to enable or disable feature
+  *
+  * Enable or disable VF spoof checking
+  */
+ int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena)
+ {
+ 	struct ice_netdev_priv *np = netdev_priv(netdev);
+ 	struct ice_pf *pf = np->vsi->back;
+ 	struct ice_vsi *vf_vsi;
+ 	struct device *dev;
+ 	struct ice_vf *vf;
+ 	int ret;
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
+ 		return -EINVAL;
+ 
+ 	ret = ice_check_vf_ready_for_cfg(vf);
+ 	if (ret)
+ 		goto out_put_vf;
+ 
+ 	vf_vsi = ice_get_vf_vsi(vf);
+ 	if (!vf_vsi) {
+ 		netdev_err(netdev, "VSI %d for VF %d is null\n",
+ 			   vf->lan_vsi_idx, vf->vf_id);
+ 		ret = -EINVAL;
+ 		goto out_put_vf;
+ 	}
+ 
+ 	if (vf_vsi->type != ICE_VSI_VF) {
+ 		netdev_err(netdev, "Type %d of VSI %d for VF %d is no ICE_VSI_VF\n",
+ 			   vf_vsi->type, vf_vsi->vsi_num, vf->vf_id);
+ 		ret = -ENODEV;
+ 		goto out_put_vf;
+ 	}
+ 
+ 	if (ena == vf->spoofchk) {
+ 		dev_dbg(dev, "VF spoofchk already %s\n", ena ? "ON" : "OFF");
+ 		ret = 0;
+ 		goto out_put_vf;
+ 	}
+ 
+ 	ret = ice_vsi_apply_spoofchk(vf_vsi, ena);
+ 	if (ret)
+ 		dev_err(dev, "Failed to set spoofchk %s for VF %d VSI %d\n error %d\n",
+ 			ena ? "ON" : "OFF", vf->vf_id, vf_vsi->vsi_num, ret);
+ 	else
+ 		vf->spoofchk = ena;
+ 
+ out_put_vf:
+ 	ice_put_vf(vf);
+ 	return ret;
+ }
+ 
+ /**
+  * ice_vc_cfg_promiscuous_mode_msg
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
 + *
 + * 2. When the caller starts processing its mailbox queue in response to an
 + * interrupt, the structure ice_mbx_snapshot is expected to be cleared before
 + * the algorithm can be run for the first time for that interrupt. This can be
 + * done via ice_mbx_reset_snapshot().
 + *
 + * 3. For every message read by the caller from the MBX Queue, the caller must
 + * call the detection algorithm's entry function ice_mbx_vf_state_handler().
 + * Before every call to ice_mbx_vf_state_handler() the struct ice_mbx_data is
 + * filled as it is required to be passed to the algorithm.
 + *
 + * 4. Every time a message is read from the MBX queue, a VFId is received which
 + * is passed to the state handler. The boolean output is_malvf of the state
 + * handler ice_mbx_vf_state_handler() serves as an indicator to the caller
 + * whether this VF is malicious or not.
 + *
 + * 5. When a VF is identified to be malicious, the caller can send a message
 + * to the system administrator. The caller can invoke ice_mbx_report_malvf()
 + * to help determine if a malicious VF is to be reported or not. This function
 + * requires the caller to maintain a global bitmap to track all malicious VFs
 + * and pass that to ice_mbx_report_malvf() along with the VFID which was identified
 + * to be malicious by ice_mbx_vf_state_handler().
 + *
 + * 6. The global bitmap maintained by PF can be cleared completely if PF is in
 + * reset or the bit corresponding to a VF can be cleared if that VF is in reset.
 + * When a VF is shut down and brought back up, we assume that the new VF
 + * brought up is not malicious and hence report it if found malicious.
 + *
 + * 7. The function ice_mbx_reset_snapshot() is called to reset the information
 + * in ice_mbx_snapshot for every new mailbox interrupt handled.
 + *
 + * 8. The memory allocated for variables in ice_mbx_snapshot is de-allocated
 + * when driver is unloaded.
 + */
 +#define ICE_RQ_DATA_MASK(rq_data) ((rq_data) & PF_MBX_ARQH_ARQH_M)
 +/* Using the highest value for an unsigned 16-bit value 0xFFFF to indicate that
 + * the max messages check must be ignored in the algorithm
 + */
 +#define ICE_IGNORE_MAX_MSG_CNT	0xFFFF
 +
 +/**
 + * ice_mbx_traverse - Pass through mailbox snapshot
 + * @hw: pointer to the HW struct
 + * @new_state: new algorithm state
   *
 - * called from the VF to configure VF VSIs promiscuous mode
 + * Traversing the mailbox static snapshot without checking
 + * for malicious VFs.
   */
 -static int ice_vc_cfg_promiscuous_mode_msg(struct ice_vf *vf, u8 *msg)
 +static void
 +ice_mbx_traverse(struct ice_hw *hw,
 +		 enum ice_mbx_snapshot_state *new_state)
  {
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	bool rm_promisc, alluni = false, allmulti = false;
 -	struct virtchnl_promisc_info *info =
 -	    (struct virtchnl_promisc_info *)msg;
 -	struct ice_vsi_vlan_ops *vlan_ops;
 -	int mcast_err = 0, ucast_err = 0;
 -	struct ice_pf *pf = vf->pf;
 -	struct ice_vsi *vsi;
 -	struct device *dev;
 -	int ret = 0;
 +	struct ice_mbx_snap_buffer_data *snap_buf;
 +	u32 num_iterations;
  
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 +	snap_buf = &hw->mbx_snapshot.mbx_buf;
  
 -	if (!ice_vc_isvalid_vsi_id(vf, info->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 +	/* As mailbox buffer is circular, applying a mask
 +	 * on the incremented iteration count.
 +	 */
 +	num_iterations = ICE_RQ_DATA_MASK(++snap_buf->num_iterations);
 +
 +	/* Checking either of the below conditions to exit snapshot traversal:
 +	 * Condition-1: If the number of iterations in the mailbox is equal to
 +	 * the mailbox head which would indicate that we have reached the end
 +	 * of the static snapshot.
 +	 * Condition-2: If the maximum messages serviced in the mailbox for a
 +	 * given interrupt is the highest possible value then there is no need
 +	 * to check if the number of messages processed is equal to it. If not
 +	 * check if the number of messages processed is greater than or equal
 +	 * to the maximum number of mailbox entries serviced in current work item.
 +	 */
 +	if (num_iterations == snap_buf->head ||
 +	    (snap_buf->max_num_msgs_mbx < ICE_IGNORE_MAX_MSG_CNT &&
 +	     ++snap_buf->num_msg_proc >= snap_buf->max_num_msgs_mbx))
 +		*new_state = ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT;
 +}
  
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 +/**
 + * ice_mbx_detect_malvf - Detect malicious VF in snapshot
 + * @hw: pointer to the HW struct
 + * @vf_id: relative virtual function ID
 + * @new_state: new algorithm state
 + * @is_malvf: boolean output to indicate if VF is malicious
 + *
 + * This function tracks the number of asynchronous messages
 + * sent per VF and marks the VF as malicious if it exceeds
 + * the permissible number of messages to send.
 + */
 +static int
 +ice_mbx_detect_malvf(struct ice_hw *hw, u16 vf_id,
 +		     enum ice_mbx_snapshot_state *new_state,
 +		     bool *is_malvf)
 +{
 +	struct ice_mbx_snapshot *snap = &hw->mbx_snapshot;
  
 -	dev = ice_pf_to_dev(pf);
 -	if (!ice_is_vf_trusted(vf)) {
 -		dev_err(dev, "Unprivileged VF %d is attempting to configure promiscuous mode\n",
 -			vf->vf_id);
 -		/* Leave v_ret alone, lie to the VF on purpose. */
 -		goto error_param;
 -	}
 +	if (vf_id >= snap->mbx_vf.vfcntr_len)
 +		return -EIO;
  
 -	if (info->flags & FLAG_VF_UNICAST_PROMISC)
 -		alluni = true;
 +	/* increment the message count in the VF array */
 +	snap->mbx_vf.vf_cntr[vf_id]++;
  
 -	if (info->flags & FLAG_VF_MULTICAST_PROMISC)
 -		allmulti = true;
 +	if (snap->mbx_vf.vf_cntr[vf_id] >= ICE_ASYNC_VF_MSG_THRESHOLD)
 +		*is_malvf = true;
  
 -	rm_promisc = !allmulti && !alluni;
 +	/* continue to iterate through the mailbox snapshot */
 +	ice_mbx_traverse(hw, new_state);
  
 -	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
 -	if (rm_promisc)
 -		ret = vlan_ops->ena_rx_filtering(vsi);
 -	else
 -		ret = vlan_ops->dis_rx_filtering(vsi);
 -	if (ret) {
 -		dev_err(dev, "Failed to configure VLAN pruning in promiscuous mode\n");
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 +	return 0;
 +}
  
 -	if (!test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags)) {
 -		bool set_dflt_vsi = alluni || allmulti;
 +/**
 + * ice_mbx_reset_snapshot - Reset mailbox snapshot structure
 + * @snap: pointer to mailbox snapshot structure in the ice_hw struct
 + *
 + * Reset the mailbox snapshot structure and clear VF counter array.
 + */
 +static void ice_mbx_reset_snapshot(struct ice_mbx_snapshot *snap)
 +{
 +	u32 vfcntr_len;
  
 -		if (set_dflt_vsi && !ice_is_dflt_vsi_in_use(pf->first_sw))
 -			/* only attempt to set the default forwarding VSI if
 -			 * it's not currently set
 -			 */
 -			ret = ice_set_dflt_vsi(pf->first_sw, vsi);
 -		else if (!set_dflt_vsi &&
 -			 ice_is_vsi_dflt_vsi(pf->first_sw, vsi))
 -			/* only attempt to free the default forwarding VSI if we
 -			 * are the owner
 -			 */
 -			ret = ice_clear_dflt_vsi(pf->first_sw);
 +	if (!snap || !snap->mbx_vf.vf_cntr)
 +		return;
  
 -		if (ret) {
 -			dev_err(dev, "%sable VF %d as the default VSI failed, error %d\n",
 -				set_dflt_vsi ? "en" : "dis", vf->vf_id, ret);
 -			v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 -			goto error_param;
 -		}
 -	} else {
 -		u8 mcast_m, ucast_m;
 +	/* Clear VF counters. */
 +	vfcntr_len = snap->mbx_vf.vfcntr_len;
 +	if (vfcntr_len)
 +		memset(snap->mbx_vf.vf_cntr, 0,
 +		       (vfcntr_len * sizeof(*snap->mbx_vf.vf_cntr)));
 +
 +	/* Reset mailbox snapshot for a new capture. */
 +	memset(&snap->mbx_buf, 0, sizeof(snap->mbx_buf));
 +	snap->mbx_buf.state = ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT;
 +}
 +
 +/**
 + * ice_mbx_vf_state_handler - Handle states of the overflow algorithm
 + * @hw: pointer to the HW struct
 + * @mbx_data: pointer to structure containing mailbox data
 + * @vf_id: relative virtual function (VF) ID
 + * @is_malvf: boolean output to indicate if VF is malicious
 + *
 + * The function serves as an entry point for the malicious VF
 + * detection algorithm by handling the different states and state
 + * transitions of the algorithm:
 + * New snapshot: This state is entered when creating a new static
 + * snapshot. The data from any previous mailbox snapshot is
 + * cleared and a new capture of the mailbox head and tail is
 + * logged. This will be the new static snapshot to detect
 + * asynchronous messages sent by VFs. On capturing the snapshot
 + * and depending on whether the number of pending messages in that
 + * snapshot exceed the watermark value, the state machine enters
 + * traverse or detect states.
 + * Traverse: If pending message count is below watermark then iterate
 + * through the snapshot without any action on VF.
 + * Detect: If pending message count exceeds watermark traverse
 + * the static snapshot and look for a malicious VF.
 + */
 +int
 +ice_mbx_vf_state_handler(struct ice_hw *hw,
 +			 struct ice_mbx_data *mbx_data, u16 vf_id,
 +			 bool *is_malvf)
 +{
 +	struct ice_mbx_snapshot *snap = &hw->mbx_snapshot;
 +	struct ice_mbx_snap_buffer_data *snap_buf;
 +	struct ice_ctl_q_info *cq = &hw->mailboxq;
 +	enum ice_mbx_snapshot_state new_state;
 +	int status = 0;
 +
 +	if (!is_malvf || !mbx_data)
 +		return -EINVAL;
 +
 +	/* When entering the mailbox state machine assume that the VF
 +	 * is not malicious until detected.
 +	 */
 +	*is_malvf = false;
 +
 +	 /* Checking if max messages allowed to be processed while servicing current
 +	  * interrupt is not less than the defined AVF message threshold.
 +	  */
 +	if (mbx_data->max_num_msgs_mbx <= ICE_ASYNC_VF_MSG_THRESHOLD)
 +		return -EINVAL;
 +
 +	/* The watermark value should not be lesser than the threshold limit
 +	 * set for the number of asynchronous messages a VF can send to mailbox
 +	 * nor should it be greater than the maximum number of messages in the
 +	 * mailbox serviced in current interrupt.
 +	 */
 +	if (mbx_data->async_watermark_val < ICE_ASYNC_VF_MSG_THRESHOLD ||
 +	    mbx_data->async_watermark_val > mbx_data->max_num_msgs_mbx)
 +		return -EINVAL;
 +
 +	new_state = ICE_MAL_VF_DETECT_STATE_INVALID;
 +	snap_buf = &snap->mbx_buf;
 +
 +	switch (snap_buf->state) {
 +	case ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT:
 +		/* Clear any previously held data in mailbox snapshot structure. */
 +		ice_mbx_reset_snapshot(snap);
 +
 +		/* Collect the pending ARQ count, number of messages processed and
 +		 * the maximum number of messages allowed to be processed from the
 +		 * Mailbox for current interrupt.
 +		 */
 +		snap_buf->num_pending_arq = mbx_data->num_pending_arq;
 +		snap_buf->num_msg_proc = mbx_data->num_msg_proc;
 +		snap_buf->max_num_msgs_mbx = mbx_data->max_num_msgs_mbx;
  
 -		if (ice_vf_is_port_vlan_ena(vf) ||
 -		    ice_vsi_has_non_zero_vlans(vsi)) {
 -			mcast_m = ICE_MCAST_VLAN_PROMISC_BITS;
 -			ucast_m = ICE_UCAST_VLAN_PROMISC_BITS;
 +		/* Capture a new static snapshot of the mailbox by logging the
 +		 * head and tail of snapshot and set num_iterations to the tail
 +		 * value to mark the start of the iteration through the snapshot.
 +		 */
 +		snap_buf->head = ICE_RQ_DATA_MASK(cq->rq.next_to_clean +
 +						  mbx_data->num_pending_arq);
 +		snap_buf->tail = ICE_RQ_DATA_MASK(cq->rq.next_to_clean - 1);
 +		snap_buf->num_iterations = snap_buf->tail;
 +
 +		/* Pending ARQ messages returned by ice_clean_rq_elem
 +		 * is the difference between the head and tail of the
 +		 * mailbox queue. Comparing this value against the watermark
 +		 * helps to check if we potentially have malicious VFs.
 +		 */
 +		if (snap_buf->num_pending_arq >=
 +		    mbx_data->async_watermark_val) {
 +			new_state = ICE_MAL_VF_DETECT_STATE_DETECT;
 +			status = ice_mbx_detect_malvf(hw, vf_id, &new_state, is_malvf);
  		} else {
 -			mcast_m = ICE_MCAST_PROMISC_BITS;
 -			ucast_m = ICE_UCAST_PROMISC_BITS;
 +			new_state = ICE_MAL_VF_DETECT_STATE_TRAVERSE;
 +			ice_mbx_traverse(hw, &new_state);
  		}
 +		break;
  
 -		if (alluni)
 -			ucast_err = ice_vf_set_vsi_promisc(vf, vsi, ucast_m);
 -		else
 -			ucast_err = ice_vf_clear_vsi_promisc(vf, vsi, ucast_m);
 -
 -		if (allmulti)
 -			mcast_err = ice_vf_set_vsi_promisc(vf, vsi, mcast_m);
 -		else
 -			mcast_err = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);
 +	case ICE_MAL_VF_DETECT_STATE_TRAVERSE:
 +		new_state = ICE_MAL_VF_DETECT_STATE_TRAVERSE;
 +		ice_mbx_traverse(hw, &new_state);
 +		break;
  
 -		if (ucast_err || mcast_err)
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -	}
 +	case ICE_MAL_VF_DETECT_STATE_DETECT:
 +		new_state = ICE_MAL_VF_DETECT_STATE_DETECT;
 +		status = ice_mbx_detect_malvf(hw, vf_id, &new_state, is_malvf);
 +		break;
  
 -	if (!mcast_err) {
 -		if (allmulti &&
 -		    !test_and_set_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully set multicast promiscuous mode\n",
 -				 vf->vf_id);
 -		else if (!allmulti && test_and_clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully unset multicast promiscuous mode\n",
 -				 vf->vf_id);
 +	default:
 +		new_state = ICE_MAL_VF_DETECT_STATE_INVALID;
 +		status = -EIO;
  	}
  
 -	if (!ucast_err) {
 -		if (alluni && !test_and_set_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully set unicast promiscuous mode\n",
 -				 vf->vf_id);
 -		else if (!alluni && test_and_clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully unset unicast promiscuous mode\n",
 -				 vf->vf_id);
 -	}
 +	snap_buf->state = new_state;
  
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,
 -				     v_ret, NULL, 0);
 +	return status;
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.h
index 68686a3fd7e8,d3456eeccf58..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.h
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.h
@@@ -3,50 -3,227 +3,252 @@@
  
  #ifndef _ICE_SRIOV_H_
  #define _ICE_SRIOV_H_
++<<<<<<< HEAD
++=======
+ #include "ice_virtchnl_fdir.h"
+ #include "ice_vf_lib.h"
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
  
 -/* Restrict number of MAC Addr and VLAN that non-trusted VF can programmed */
 -#define ICE_MAX_VLAN_PER_VF		8
 -/* MAC filters: 1 is reserved for the VF's default/perm_addr/LAA MAC, 1 for
 - * broadcast, and 16 for additional unicast/multicast filters
 +#include "ice_type.h"
 +#include "ice_controlq.h"
 +
 +/* Defining the mailbox message threshold as 63 asynchronous
 + * pending messages. Normal VF functionality does not require
 + * sending more than 63 asynchronous pending message.
   */
++<<<<<<< HEAD
 +#define ICE_ASYNC_VF_MSG_THRESHOLD	63
 +
 +#ifdef CONFIG_PCI_IOV
++=======
+ #define ICE_MAX_MACADDR_PER_VF		18
+ 
+ /* Static VF transaction/status register def */
+ #define VF_DEVICE_STATUS		0xAA
+ #define VF_TRANS_PENDING_M		0x20
+ 
+ /* wait defines for polling PF_PCI_CIAD register status */
+ #define ICE_PCI_CIAD_WAIT_COUNT		100
+ #define ICE_PCI_CIAD_WAIT_DELAY_US	1
+ 
+ /* VF resource constraints */
+ #define ICE_MIN_QS_PER_VF		1
+ #define ICE_NONQ_VECS_VF		1
+ #define ICE_NUM_VF_MSIX_MED		17
+ #define ICE_NUM_VF_MSIX_SMALL		5
+ #define ICE_NUM_VF_MSIX_MULTIQ_MIN	3
+ #define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
+ #define ICE_MAX_VF_RESET_TRIES		40
+ #define ICE_MAX_VF_RESET_SLEEP_MS	20
+ 
+ struct ice_vf;
+ 
+ struct ice_virtchnl_ops {
+ 	int (*get_ver_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*get_vf_res_msg)(struct ice_vf *vf, u8 *msg);
+ 	void (*reset_vf)(struct ice_vf *vf);
+ 	int (*add_mac_addr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*del_mac_addr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*cfg_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*dis_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*request_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*cfg_irq_map_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*config_rss_key)(struct ice_vf *vf, u8 *msg);
+ 	int (*config_rss_lut)(struct ice_vf *vf, u8 *msg);
+ 	int (*get_stats_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*cfg_promiscuous_mode_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*add_vlan_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*remove_vlan_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_vlan_stripping)(struct ice_vf *vf);
+ 	int (*dis_vlan_stripping)(struct ice_vf *vf);
+ 	int (*handle_rss_cfg_msg)(struct ice_vf *vf, u8 *msg, bool add);
+ 	int (*add_fdir_fltr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*del_fdir_fltr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*get_offload_vlan_v2_caps)(struct ice_vf *vf);
+ 	int (*add_vlan_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*remove_vlan_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_vlan_stripping_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*dis_vlan_stripping_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_vlan_insertion_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*dis_vlan_insertion_v2_msg)(struct ice_vf *vf, u8 *msg);
+ };
+ 
+ #ifdef CONFIG_PCI_IOV
+ void ice_process_vflr_event(struct ice_pf *pf);
+ int ice_sriov_configure(struct pci_dev *pdev, int num_vfs);
+ int ice_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac);
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
  int
 -ice_get_vf_cfg(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi);
 -
 -void ice_free_vfs(struct ice_pf *pf);
 -void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event);
 -void ice_vc_notify_link_state(struct ice_pf *pf);
 -void ice_vc_notify_reset(struct ice_pf *pf);
 -void ice_vc_notify_vf_link_state(struct ice_vf *vf);
 -void ice_virtchnl_set_repr_ops(struct ice_vf *vf);
 -void ice_virtchnl_set_dflt_ops(struct ice_vf *vf);
 -bool ice_reset_all_vfs(struct ice_pf *pf, bool is_vflr);
 -bool ice_reset_vf(struct ice_vf *vf, bool is_vflr);
 -void ice_restore_all_vfs_msi_state(struct pci_dev *pdev);
 -bool
 -ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
 -		    u16 num_msg_proc, u16 num_msg_pending);
 +ice_aq_send_msg_to_vf(struct ice_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval,
 +		      u8 *msg, u16 msglen, struct ice_sq_cd *cd);
  
 +u32 ice_conv_link_speed_to_virtchnl(bool adv_link_support, u16 link_speed);
  int
 -ice_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos,
 -		     __be16 vlan_proto);
 -
 +ice_mbx_vf_state_handler(struct ice_hw *hw, struct ice_mbx_data *mbx_data,
 +			 u16 vf_id, bool *is_mal_vf);
 +int
++<<<<<<< HEAD
 +ice_mbx_clear_malvf(struct ice_mbx_snapshot *snap, unsigned long *all_malvfs,
 +		    u16 bitmap_len, u16 vf_id);
 +int ice_mbx_init_snapshot(struct ice_hw *hw, u16 vf_count);
 +void ice_mbx_deinit_snapshot(struct ice_hw *hw);
  int
 +ice_mbx_report_malvf(struct ice_hw *hw, unsigned long *all_malvfs,
 +		     u16 bitmap_len, u16 vf_id, bool *report_malvf);
 +#else /* CONFIG_PCI_IOV */
 +static inline int
 +ice_aq_send_msg_to_vf(struct ice_hw __always_unused *hw,
 +		      u16 __always_unused vfid, u32 __always_unused v_opcode,
 +		      u32 __always_unused v_retval, u8 __always_unused *msg,
 +		      u16 __always_unused msglen,
 +		      struct ice_sq_cd __always_unused *cd)
 +{
 +	return 0;
 +}
 +
 +static inline u32
 +ice_conv_link_speed_to_virtchnl(bool __always_unused adv_link_support,
 +				u16 __always_unused link_speed)
++=======
+ ice_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate,
+ 	      int max_tx_rate);
+ 
+ int ice_set_vf_trust(struct net_device *netdev, int vf_id, bool trusted);
+ 
+ int ice_set_vf_link_state(struct net_device *netdev, int vf_id, int link_state);
+ 
+ int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena);
+ 
+ int ice_calc_vf_reg_idx(struct ice_vf *vf, struct ice_q_vector *q_vector);
+ 
+ int
+ ice_get_vf_stats(struct net_device *netdev, int vf_id,
+ 		 struct ifla_vf_stats *vf_stats);
+ void
+ ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event);
+ void ice_print_vfs_mdd_events(struct ice_pf *pf);
+ void ice_print_vf_rx_mdd_event(struct ice_vf *vf);
+ bool
+ ice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto);
+ int
+ ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
+ 		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen);
+ bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id);
+ #else /* CONFIG_PCI_IOV */
+ static inline void ice_process_vflr_event(struct ice_pf *pf) { }
+ static inline void ice_free_vfs(struct ice_pf *pf) { }
+ static inline
+ void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event) { }
+ static inline void ice_vc_notify_link_state(struct ice_pf *pf) { }
+ static inline void ice_vc_notify_reset(struct ice_pf *pf) { }
+ static inline void ice_vc_notify_vf_link_state(struct ice_vf *vf) { }
+ static inline void ice_virtchnl_set_repr_ops(struct ice_vf *vf) { }
+ static inline void ice_virtchnl_set_dflt_ops(struct ice_vf *vf) { }
+ static inline
+ void ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event) { }
+ static inline void ice_print_vfs_mdd_events(struct ice_pf *pf) { }
+ static inline void ice_print_vf_rx_mdd_event(struct ice_vf *vf) { }
+ static inline void ice_restore_all_vfs_msi_state(struct pci_dev *pdev) { }
+ 
+ static inline bool
+ ice_is_malicious_vf(struct ice_pf __always_unused *pf,
+ 		    struct ice_rq_event_info __always_unused *event,
+ 		    u16 __always_unused num_msg_proc,
+ 		    u16 __always_unused num_msg_pending)
+ {
+ 	return false;
+ }
+ 
+ static inline bool
+ ice_reset_all_vfs(struct ice_pf __always_unused *pf,
+ 		  bool __always_unused is_vflr)
+ {
+ 	return true;
+ }
+ 
+ static inline bool
+ ice_reset_vf(struct ice_vf __always_unused *vf, bool __always_unused is_vflr)
+ {
+ 	return true;
+ }
+ 
+ static inline int
+ ice_sriov_configure(struct pci_dev __always_unused *pdev,
+ 		    int __always_unused num_vfs)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_mac(struct net_device __always_unused *netdev,
+ 	       int __always_unused vf_id, u8 __always_unused *mac)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_get_vf_cfg(struct net_device __always_unused *netdev,
+ 	       int __always_unused vf_id,
+ 	       struct ifla_vf_info __always_unused *ivi)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_trust(struct net_device __always_unused *netdev,
+ 		 int __always_unused vf_id, bool __always_unused trusted)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_port_vlan(struct net_device __always_unused *netdev,
+ 		     int __always_unused vf_id, u16 __always_unused vid,
+ 		     u8 __always_unused qos, __be16 __always_unused v_proto)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_spoofchk(struct net_device __always_unused *netdev,
+ 		    int __always_unused vf_id, bool __always_unused ena)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_link_state(struct net_device __always_unused *netdev,
+ 		      int __always_unused vf_id, int __always_unused link_state)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_bw(struct net_device __always_unused *netdev,
+ 	      int __always_unused vf_id, int __always_unused min_tx_rate,
+ 	      int __always_unused max_tx_rate)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_calc_vf_reg_idx(struct ice_vf __always_unused *vf,
+ 		    struct ice_q_vector __always_unused *q_vector)
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
  {
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ ice_get_vf_stats(struct net_device __always_unused *netdev,
+ 		 int __always_unused vf_id,
+ 		 struct ifla_vf_stats __always_unused *vf_stats)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> 109aba47ca9b (ice: introduce ice_vf_lib.c, ice_vf_lib.h, and ice_vf_lib_private.h)
  #endif /* CONFIG_PCI_IOV */
  #endif /* _ICE_SRIOV_H_ */
* Unmerged path drivers/net/ethernet/intel/ice/Makefile
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.h
diff --git a/drivers/net/ethernet/intel/ice/ice_vf_lib.c b/drivers/net/ethernet/intel/ice/ice_vf_lib.c
new file mode 100644
index 000000000000..7ac06aa8b25a
--- /dev/null
+++ b/drivers/net/ethernet/intel/ice/ice_vf_lib.c
@@ -0,0 +1,519 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2022, Intel Corporation. */
+
+#include "ice_vf_lib_private.h"
+#include "ice.h"
+#include "ice_lib.h"
+#include "ice_fltr.h"
+#include "ice_virtchnl_allowlist.h"
+
+/* Public functions which may be accessed by all driver files */
+
+/**
+ * ice_get_vf_by_id - Get pointer to VF by ID
+ * @pf: the PF private structure
+ * @vf_id: the VF ID to locate
+ *
+ * Locate and return a pointer to the VF structure associated with a given ID.
+ * Returns NULL if the ID does not have a valid VF structure associated with
+ * it.
+ *
+ * This function takes a reference to the VF, which must be released by
+ * calling ice_put_vf() once the caller is finished accessing the VF structure
+ * returned.
+ */
+struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
+{
+	struct ice_vf *vf;
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu(pf->vfs.table, vf, entry, vf_id) {
+		if (vf->vf_id == vf_id) {
+			struct ice_vf *found;
+
+			if (kref_get_unless_zero(&vf->refcnt))
+				found = vf;
+			else
+				found = NULL;
+
+			rcu_read_unlock();
+			return found;
+		}
+	}
+	rcu_read_unlock();
+
+	return NULL;
+}
+
+/**
+ * ice_release_vf - Release VF associated with a refcount
+ * @ref: the kref decremented to zero
+ *
+ * Callback function for kref_put to release a VF once its reference count has
+ * hit zero.
+ */
+static void ice_release_vf(struct kref *ref)
+{
+	struct ice_vf *vf = container_of(ref, struct ice_vf, refcnt);
+
+	mutex_destroy(&vf->cfg_lock);
+
+	kfree_rcu(vf, rcu);
+}
+
+/**
+ * ice_put_vf - Release a reference to a VF
+ * @vf: the VF structure to decrease reference count on
+ *
+ * Decrease the reference count for a VF, and free the entry if it is no
+ * longer in use.
+ *
+ * This must be called after ice_get_vf_by_id() once the reference to the VF
+ * structure is no longer used. Otherwise, the VF structure will never be
+ * freed.
+ */
+void ice_put_vf(struct ice_vf *vf)
+{
+	kref_put(&vf->refcnt, ice_release_vf);
+}
+
+/**
+ * ice_has_vfs - Return true if the PF has any associated VFs
+ * @pf: the PF private structure
+ *
+ * Return whether or not the PF has any allocated VFs.
+ *
+ * Note that this function only guarantees that there are no VFs at the point
+ * of calling it. It does not guarantee that no more VFs will be added.
+ */
+bool ice_has_vfs(struct ice_pf *pf)
+{
+	/* A simple check that the hash table is not empty does not require
+	 * the mutex or rcu_read_lock.
+	 */
+	return !hash_empty(pf->vfs.table);
+}
+
+/**
+ * ice_get_num_vfs - Get number of allocated VFs
+ * @pf: the PF private structure
+ *
+ * Return the total number of allocated VFs. NOTE: VF IDs are not guaranteed
+ * to be contiguous. Do not assume that a VF ID is guaranteed to be less than
+ * the output of this function.
+ */
+u16 ice_get_num_vfs(struct ice_pf *pf)
+{
+	struct ice_vf *vf;
+	unsigned int bkt;
+	u16 num_vfs = 0;
+
+	rcu_read_lock();
+	ice_for_each_vf_rcu(pf, bkt, vf)
+		num_vfs++;
+	rcu_read_unlock();
+
+	return num_vfs;
+}
+
+/**
+ * ice_get_vf_vsi - get VF's VSI based on the stored index
+ * @vf: VF used to get VSI
+ */
+struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)
+{
+	if (vf->lan_vsi_idx == ICE_NO_VSI)
+		return NULL;
+
+	return vf->pf->vsi[vf->lan_vsi_idx];
+}
+
+/**
+ * ice_is_vf_disabled
+ * @vf: pointer to the VF info
+ *
+ * If the PF has been disabled, there is no need resetting VF until PF is
+ * active again. Similarly, if the VF has been disabled, this means something
+ * else is resetting the VF, so we shouldn't continue.
+ *
+ * Returns true if the caller should consider the VF as disabled whether
+ * because that single VF is explicitly disabled or because the PF is
+ * currently disabled.
+ */
+bool ice_is_vf_disabled(struct ice_vf *vf)
+{
+	struct ice_pf *pf = vf->pf;
+
+	return (test_bit(ICE_VF_DIS, pf->state) ||
+		test_bit(ICE_VF_STATE_DIS, vf->vf_states));
+}
+
+/**
+ * ice_wait_on_vf_reset - poll to make sure a given VF is ready after reset
+ * @vf: The VF being resseting
+ *
+ * The max poll time is about ~800ms, which is about the maximum time it takes
+ * for a VF to be reset and/or a VF driver to be removed.
+ */
+static void ice_wait_on_vf_reset(struct ice_vf *vf)
+{
+	int i;
+
+	for (i = 0; i < ICE_MAX_VF_RESET_TRIES; i++) {
+		if (test_bit(ICE_VF_STATE_INIT, vf->vf_states))
+			break;
+		msleep(ICE_MAX_VF_RESET_SLEEP_MS);
+	}
+}
+
+/**
+ * ice_check_vf_ready_for_cfg - check if VF is ready to be configured/queried
+ * @vf: VF to check if it's ready to be configured/queried
+ *
+ * The purpose of this function is to make sure the VF is not in reset, not
+ * disabled, and initialized so it can be configured and/or queried by a host
+ * administrator.
+ */
+int ice_check_vf_ready_for_cfg(struct ice_vf *vf)
+{
+	struct ice_pf *pf;
+
+	ice_wait_on_vf_reset(vf);
+
+	if (ice_is_vf_disabled(vf))
+		return -EINVAL;
+
+	pf = vf->pf;
+	if (ice_check_vf_init(pf, vf))
+		return -EBUSY;
+
+	return 0;
+}
+
+/**
+ * ice_is_any_vf_in_promisc - check if any VF(s) are in promiscuous mode
+ * @pf: PF structure for accessing VF(s)
+ *
+ * Return false if no VF(s) are in unicast and/or multicast promiscuous mode,
+ * else return true
+ */
+bool ice_is_any_vf_in_promisc(struct ice_pf *pf)
+{
+	bool is_vf_promisc = false;
+	struct ice_vf *vf;
+	unsigned int bkt;
+
+	rcu_read_lock();
+	ice_for_each_vf_rcu(pf, bkt, vf) {
+		/* found a VF that has promiscuous mode configured */
+		if (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||
+		    test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) {
+			is_vf_promisc = true;
+			break;
+		}
+	}
+	rcu_read_unlock();
+
+	return is_vf_promisc;
+}
+
+/**
+ * ice_vf_set_vsi_promisc - Enable promiscuous mode for a VF VSI
+ * @vf: the VF to configure
+ * @vsi: the VF's VSI
+ * @promisc_m: the promiscuous mode to enable
+ */
+int
+ice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)
+{
+	struct ice_hw *hw = &vsi->back->hw;
+	int status;
+
+	if (ice_vf_is_port_vlan_ena(vf))
+		status = ice_fltr_set_vsi_promisc(hw, vsi->idx, promisc_m,
+						  ice_vf_get_port_vlan_id(vf));
+	else if (ice_vsi_has_non_zero_vlans(vsi))
+		status = ice_fltr_set_vlan_vsi_promisc(hw, vsi, promisc_m);
+	else
+		status = ice_fltr_set_vsi_promisc(hw, vsi->idx, promisc_m, 0);
+
+	if (status && status != -EEXIST) {
+		dev_err(ice_pf_to_dev(vsi->back), "enable Tx/Rx filter promiscuous mode on VF-%u failed, error: %d\n",
+			vf->vf_id, status);
+		return status;
+	}
+
+	return 0;
+}
+
+/**
+ * ice_vf_clear_vsi_promisc - Disable promiscuous mode for a VF VSI
+ * @vf: the VF to configure
+ * @vsi: the VF's VSI
+ * @promisc_m: the promiscuous mode to disable
+ */
+int
+ice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)
+{
+	struct ice_hw *hw = &vsi->back->hw;
+	int status;
+
+	if (ice_vf_is_port_vlan_ena(vf))
+		status = ice_fltr_clear_vsi_promisc(hw, vsi->idx, promisc_m,
+						    ice_vf_get_port_vlan_id(vf));
+	else if (ice_vsi_has_non_zero_vlans(vsi))
+		status = ice_fltr_clear_vlan_vsi_promisc(hw, vsi, promisc_m);
+	else
+		status = ice_fltr_clear_vsi_promisc(hw, vsi->idx, promisc_m, 0);
+
+	if (status && status != -ENOENT) {
+		dev_err(ice_pf_to_dev(vsi->back), "disable Tx/Rx filter promiscuous mode on VF-%u failed, error: %d\n",
+			vf->vf_id, status);
+		return status;
+	}
+
+	return 0;
+}
+
+/**
+ * ice_set_vf_state_qs_dis - Set VF queues state to disabled
+ * @vf: pointer to the VF structure
+ */
+void ice_set_vf_state_qs_dis(struct ice_vf *vf)
+{
+	/* Clear Rx/Tx enabled queues flag */
+	bitmap_zero(vf->txq_ena, ICE_MAX_RSS_QS_PER_VF);
+	bitmap_zero(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF);
+	clear_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);
+}
+
+/* Private functions only accessed from other virtualization files */
+
+/**
+ * ice_dis_vf_qs - Disable the VF queues
+ * @vf: pointer to the VF structure
+ */
+void ice_dis_vf_qs(struct ice_vf *vf)
+{
+	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+
+	ice_vsi_stop_lan_tx_rings(vsi, ICE_NO_RESET, vf->vf_id);
+	ice_vsi_stop_all_rx_rings(vsi);
+	ice_set_vf_state_qs_dis(vf);
+}
+
+/**
+ * ice_check_vf_init - helper to check if VF init complete
+ * @pf: pointer to the PF structure
+ * @vf: the pointer to the VF to check
+ */
+int ice_check_vf_init(struct ice_pf *pf, struct ice_vf *vf)
+{
+	if (!test_bit(ICE_VF_STATE_INIT, vf->vf_states)) {
+		dev_err(ice_pf_to_dev(pf), "VF ID: %u in reset. Try again.\n",
+			vf->vf_id);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+/**
+ * ice_vf_get_port_info - Get the VF's port info structure
+ * @vf: VF used to get the port info structure for
+ */
+struct ice_port_info *ice_vf_get_port_info(struct ice_vf *vf)
+{
+	return vf->pf->hw.port_info;
+}
+
+static int ice_cfg_mac_antispoof(struct ice_vsi *vsi, bool enable)
+{
+	struct ice_vsi_ctx *ctx;
+	int err;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->info.sec_flags = vsi->info.sec_flags;
+	ctx->info.valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_SECURITY_VALID);
+
+	if (enable)
+		ctx->info.sec_flags |= ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;
+	else
+		ctx->info.sec_flags &= ~ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;
+
+	err = ice_update_vsi(&vsi->back->hw, vsi->idx, ctx, NULL);
+	if (err)
+		dev_err(ice_pf_to_dev(vsi->back), "Failed to configure Tx MAC anti-spoof %s for VSI %d, error %d\n",
+			enable ? "ON" : "OFF", vsi->vsi_num, err);
+	else
+		vsi->info.sec_flags = ctx->info.sec_flags;
+
+	kfree(ctx);
+
+	return err;
+}
+
+/**
+ * ice_vsi_ena_spoofchk - enable Tx spoof checking for this VSI
+ * @vsi: VSI to enable Tx spoof checking for
+ */
+static int ice_vsi_ena_spoofchk(struct ice_vsi *vsi)
+{
+	struct ice_vsi_vlan_ops *vlan_ops;
+	int err;
+
+	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+
+	err = vlan_ops->ena_tx_filtering(vsi);
+	if (err)
+		return err;
+
+	return ice_cfg_mac_antispoof(vsi, true);
+}
+
+/**
+ * ice_vsi_dis_spoofchk - disable Tx spoof checking for this VSI
+ * @vsi: VSI to disable Tx spoof checking for
+ */
+static int ice_vsi_dis_spoofchk(struct ice_vsi *vsi)
+{
+	struct ice_vsi_vlan_ops *vlan_ops;
+	int err;
+
+	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+
+	err = vlan_ops->dis_tx_filtering(vsi);
+	if (err)
+		return err;
+
+	return ice_cfg_mac_antispoof(vsi, false);
+}
+
+/**
+ * ice_vsi_apply_spoofchk - Apply Tx spoof checking setting to a VSI
+ * @vsi: VSI associated to the VF
+ * @enable: whether to enable or disable the spoof checking
+ */
+int ice_vsi_apply_spoofchk(struct ice_vsi *vsi, bool enable)
+{
+	int err;
+
+	if (enable)
+		err = ice_vsi_ena_spoofchk(vsi);
+	else
+		err = ice_vsi_dis_spoofchk(vsi);
+
+	return err;
+}
+
+/**
+ * ice_is_vf_trusted
+ * @vf: pointer to the VF info
+ */
+bool ice_is_vf_trusted(struct ice_vf *vf)
+{
+	return test_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
+}
+
+/**
+ * ice_vf_has_no_qs_ena - check if the VF has any Rx or Tx queues enabled
+ * @vf: the VF to check
+ *
+ * Returns true if the VF has no Rx and no Tx queues enabled and returns false
+ * otherwise
+ */
+bool ice_vf_has_no_qs_ena(struct ice_vf *vf)
+{
+	return (!bitmap_weight(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF) &&
+		!bitmap_weight(vf->txq_ena, ICE_MAX_RSS_QS_PER_VF));
+}
+
+/**
+ * ice_is_vf_link_up - check if the VF's link is up
+ * @vf: VF to check if link is up
+ */
+bool ice_is_vf_link_up(struct ice_vf *vf)
+{
+	struct ice_pf *pf = vf->pf;
+
+	if (ice_check_vf_init(pf, vf))
+		return false;
+
+	if (ice_vf_has_no_qs_ena(vf))
+		return false;
+	else if (vf->link_forced)
+		return vf->link_up;
+	else
+		return pf->hw.port_info->phy.link_info.link_info &
+			ICE_AQ_LINK_UP;
+}
+
+/**
+ * ice_vf_ctrl_invalidate_vsi - invalidate ctrl_vsi_idx to remove VSI access
+ * @vf: VF that control VSI is being invalidated on
+ */
+void ice_vf_ctrl_invalidate_vsi(struct ice_vf *vf)
+{
+	vf->ctrl_vsi_idx = ICE_NO_VSI;
+}
+
+/**
+ * ice_vf_ctrl_vsi_release - invalidate the VF's control VSI after freeing it
+ * @vf: VF that control VSI is being released on
+ */
+void ice_vf_ctrl_vsi_release(struct ice_vf *vf)
+{
+	ice_vsi_release(vf->pf->vsi[vf->ctrl_vsi_idx]);
+	ice_vf_ctrl_invalidate_vsi(vf);
+}
+
+/**
+ * ice_vf_ctrl_vsi_setup - Set up a VF control VSI
+ * @vf: VF to setup control VSI for
+ *
+ * Returns pointer to the successfully allocated VSI struct on success,
+ * otherwise returns NULL on failure.
+ */
+struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf)
+{
+	struct ice_port_info *pi = ice_vf_get_port_info(vf);
+	struct ice_pf *pf = vf->pf;
+	struct ice_vsi *vsi;
+
+	vsi = ice_vsi_setup(pf, pi, ICE_VSI_CTRL, vf, NULL);
+	if (!vsi) {
+		dev_err(ice_pf_to_dev(pf), "Failed to create VF control VSI\n");
+		ice_vf_ctrl_invalidate_vsi(vf);
+	}
+
+	return vsi;
+}
+
+/**
+ * ice_vf_invalidate_vsi - invalidate vsi_idx/vsi_num to remove VSI access
+ * @vf: VF to remove access to VSI for
+ */
+void ice_vf_invalidate_vsi(struct ice_vf *vf)
+{
+	vf->lan_vsi_idx = ICE_NO_VSI;
+	vf->lan_vsi_num = ICE_NO_VSI;
+}
+
+/**
+ * ice_vf_set_initialized - VF is ready for VIRTCHNL communication
+ * @vf: VF to set in initialized state
+ *
+ * After this function the VF will be ready to receive/handle the
+ * VIRTCHNL_OP_GET_VF_RESOURCES message
+ */
+void ice_vf_set_initialized(struct ice_vf *vf)
+{
+	ice_set_vf_state_qs_dis(vf);
+	clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);
+	clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);
+	clear_bit(ICE_VF_STATE_DIS, vf->vf_states);
+	set_bit(ICE_VF_STATE_INIT, vf->vf_states);
+	memset(&vf->vlan_v2_caps, 0, sizeof(vf->vlan_v2_caps));
+}
diff --git a/drivers/net/ethernet/intel/ice/ice_vf_lib.h b/drivers/net/ethernet/intel/ice/ice_vf_lib.h
new file mode 100644
index 000000000000..8c5a5a2258e6
--- /dev/null
+++ b/drivers/net/ethernet/intel/ice/ice_vf_lib.h
@@ -0,0 +1,259 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018-2021, Intel Corporation. */
+
+#ifndef _ICE_VF_LIB_H_
+#define _ICE_VF_LIB_H_
+
+#include <linux/types.h>
+#include <linux/hashtable.h>
+#include <linux/bitmap.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <net/devlink.h>
+#include <linux/avf/virtchnl.h>
+#include "ice_type.h"
+#include "ice_virtchnl_fdir.h"
+#include "ice_vsi_vlan_ops.h"
+
+#define ICE_MAX_SRIOV_VFS		256
+
+/* VF resource constraints */
+#define ICE_MAX_RSS_QS_PER_VF	16
+
+struct ice_pf;
+struct ice_vf;
+struct ice_virtchnl_ops;
+
+/* VF capabilities */
+enum ice_virtchnl_cap {
+	ICE_VIRTCHNL_VF_CAP_PRIVILEGE = 0,
+};
+
+/* Specific VF states */
+enum ice_vf_states {
+	ICE_VF_STATE_INIT = 0,		/* PF is initializing VF */
+	ICE_VF_STATE_ACTIVE,		/* VF resources are allocated for use */
+	ICE_VF_STATE_QS_ENA,		/* VF queue(s) enabled */
+	ICE_VF_STATE_DIS,
+	ICE_VF_STATE_MC_PROMISC,
+	ICE_VF_STATE_UC_PROMISC,
+	ICE_VF_STATES_NBITS
+};
+
+struct ice_time_mac {
+	unsigned long time_modified;
+	u8 addr[ETH_ALEN];
+};
+
+/* VF MDD events print structure */
+struct ice_mdd_vf_events {
+	u16 count;			/* total count of Rx|Tx events */
+	/* count number of the last printed event */
+	u16 last_printed;
+};
+
+/* Virtchnl/SR-IOV config info */
+struct ice_vfs {
+	DECLARE_HASHTABLE(table, 8);	/* table of VF entries */
+	struct mutex table_lock;	/* Lock for protecting the hash table */
+	u16 num_supported;		/* max supported VFs on this PF */
+	u16 num_qps_per;		/* number of queue pairs per VF */
+	u16 num_msix_per;		/* number of MSI-X vectors per VF */
+	unsigned long last_printed_mdd_jiffies;	/* MDD message rate limit */
+	DECLARE_BITMAP(malvfs, ICE_MAX_SRIOV_VFS); /* malicious VF indicator */
+};
+
+/* VF information structure */
+struct ice_vf {
+	struct hlist_node entry;
+	struct rcu_head rcu;
+	struct kref refcnt;
+	struct ice_pf *pf;
+
+	/* Used during virtchnl message handling and NDO ops against the VF
+	 * that will trigger a VFR
+	 */
+	struct mutex cfg_lock;
+
+	u16 vf_id;			/* VF ID in the PF space */
+	u16 lan_vsi_idx;		/* index into PF struct */
+	u16 ctrl_vsi_idx;
+	struct ice_vf_fdir fdir;
+	/* first vector index of this VF in the PF space */
+	int first_vector_idx;
+	struct ice_sw *vf_sw_id;	/* switch ID the VF VSIs connect to */
+	struct virtchnl_version_info vf_ver;
+	u32 driver_caps;		/* reported by VF driver */
+	struct virtchnl_ether_addr dev_lan_addr;
+	struct virtchnl_ether_addr hw_lan_addr;
+	struct ice_time_mac legacy_last_added_umac;
+	DECLARE_BITMAP(txq_ena, ICE_MAX_RSS_QS_PER_VF);
+	DECLARE_BITMAP(rxq_ena, ICE_MAX_RSS_QS_PER_VF);
+	struct ice_vlan port_vlan_info;	/* Port VLAN ID, QoS, and TPID */
+	struct virtchnl_vlan_caps vlan_v2_caps;
+	u8 pf_set_mac:1;		/* VF MAC address set by VMM admin */
+	u8 trusted:1;
+	u8 spoofchk:1;
+	u8 link_forced:1;
+	u8 link_up:1;			/* only valid if VF link is forced */
+	/* VSI indices - actual VSI pointers are maintained in the PF structure
+	 * When assigned, these will be non-zero, because VSI 0 is always
+	 * the main LAN VSI for the PF.
+	 */
+	u16 lan_vsi_num;		/* ID as used by firmware */
+	unsigned int min_tx_rate;	/* Minimum Tx bandwidth limit in Mbps */
+	unsigned int max_tx_rate;	/* Maximum Tx bandwidth limit in Mbps */
+	DECLARE_BITMAP(vf_states, ICE_VF_STATES_NBITS);	/* VF runtime states */
+
+	unsigned long vf_caps;		/* VF's adv. capabilities */
+	u8 num_req_qs;			/* num of queue pairs requested by VF */
+	u16 num_mac;
+	u16 num_vf_qs;			/* num of queue configured per VF */
+	struct ice_mdd_vf_events mdd_rx_events;
+	struct ice_mdd_vf_events mdd_tx_events;
+	DECLARE_BITMAP(opcodes_allowlist, VIRTCHNL_OP_MAX);
+
+	struct ice_repr *repr;
+	const struct ice_virtchnl_ops *virtchnl_ops;
+
+	/* devlink port data */
+	struct devlink_port devlink_port;
+};
+
+static inline u16 ice_vf_get_port_vlan_id(struct ice_vf *vf)
+{
+	return vf->port_vlan_info.vid;
+}
+
+static inline u8 ice_vf_get_port_vlan_prio(struct ice_vf *vf)
+{
+	return vf->port_vlan_info.prio;
+}
+
+static inline bool ice_vf_is_port_vlan_ena(struct ice_vf *vf)
+{
+	return (ice_vf_get_port_vlan_id(vf) || ice_vf_get_port_vlan_prio(vf));
+}
+
+static inline u16 ice_vf_get_port_vlan_tpid(struct ice_vf *vf)
+{
+	return vf->port_vlan_info.tpid;
+}
+
+/* VF Hash Table access functions
+ *
+ * These functions provide abstraction for interacting with the VF hash table.
+ * In general, direct access to the hash table should be avoided outside of
+ * these functions where possible.
+ *
+ * The VF entries in the hash table are protected by reference counting to
+ * track lifetime of accesses from the table. The ice_get_vf_by_id() function
+ * obtains a reference to the VF structure which must be dropped by using
+ * ice_put_vf().
+ */
+
+/**
+ * ice_for_each_vf - Iterate over each VF entry
+ * @pf: pointer to the PF private structure
+ * @bkt: bucket index used for iteration
+ * @vf: pointer to the VF entry currently being processed in the loop.
+ *
+ * The bkt variable is an unsigned integer iterator used to traverse the VF
+ * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
+ * Use vf->vf_id to get the id number if needed.
+ *
+ * The caller is expected to be under the table_lock mutex for the entire
+ * loop. Use this iterator if your loop is long or if it might sleep.
+ */
+#define ice_for_each_vf(pf, bkt, vf) \
+	hash_for_each((pf)->vfs.table, (bkt), (vf), entry)
+
+/**
+ * ice_for_each_vf_rcu - Iterate over each VF entry protected by RCU
+ * @pf: pointer to the PF private structure
+ * @bkt: bucket index used for iteration
+ * @vf: pointer to the VF entry currently being processed in the loop.
+ *
+ * The bkt variable is an unsigned integer iterator used to traverse the VF
+ * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
+ * Use vf->vf_id to get the id number if needed.
+ *
+ * The caller is expected to be under rcu_read_lock() for the entire loop.
+ * Only use this iterator if your loop is short and you can guarantee it does
+ * not sleep.
+ */
+#define ice_for_each_vf_rcu(pf, bkt, vf) \
+	hash_for_each_rcu((pf)->vfs.table, (bkt), (vf), entry)
+
+#ifdef CONFIG_PCI_IOV
+struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id);
+void ice_put_vf(struct ice_vf *vf);
+bool ice_has_vfs(struct ice_pf *pf);
+u16 ice_get_num_vfs(struct ice_pf *pf);
+struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf);
+bool ice_is_vf_disabled(struct ice_vf *vf);
+int ice_check_vf_ready_for_cfg(struct ice_vf *vf);
+void ice_set_vf_state_qs_dis(struct ice_vf *vf);
+bool ice_is_any_vf_in_promisc(struct ice_pf *pf);
+int
+ice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m);
+int
+ice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m);
+#else /* CONFIG_PCI_IOV */
+static inline struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
+{
+	return NULL;
+}
+
+static inline void ice_put_vf(struct ice_vf *vf)
+{
+}
+
+static inline bool ice_has_vfs(struct ice_pf *pf)
+{
+	return false;
+}
+
+static inline u16 ice_get_num_vfs(struct ice_pf *pf)
+{
+	return 0;
+}
+
+static inline struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)
+{
+	return NULL;
+}
+
+static inline bool ice_is_vf_disabled(struct ice_vf *vf)
+{
+	return true;
+}
+
+static inline int ice_check_vf_ready_for_cfg(struct ice_vf *vf)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void ice_set_vf_state_qs_dis(struct ice_vf *vf)
+{
+}
+
+static inline bool ice_is_any_vf_in_promisc(struct ice_pf *pf)
+{
+	return false;
+}
+
+static inline int
+ice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int
+ice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)
+{
+	return -EOPNOTSUPP;
+}
+#endif /* !CONFIG_PCI_IOV */
+
+#endif /* _ICE_VF_LIB_H_ */
diff --git a/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h b/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h
new file mode 100644
index 000000000000..93daf74c928c
--- /dev/null
+++ b/drivers/net/ethernet/intel/ice/ice_vf_lib_private.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018-2021, Intel Corporation. */
+
+#ifndef _ICE_VF_LIB_PRIVATE_H_
+#define _ICE_VF_LIB_PRIVATE_H_
+
+#include "ice_vf_lib.h"
+
+/* This header file is for exposing functions in ice_vf_lib.c to other files
+ * which are also conditionally compiled depending on CONFIG_PCI_IOV.
+ * Functions which may be used by other files should be exposed as part of
+ * ice_vf_lib.h
+ *
+ * Functions in this file are exposed only when CONFIG_PCI_IOV is enabled, and
+ * thus this header must not be included by .c files which may be compiled
+ * with CONFIG_PCI_IOV disabled.
+ *
+ * To avoid this, only include this header file directly within .c files that
+ * are conditionally enabled in the "ice-$(CONFIG_PCI_IOV)" block.
+ */
+
+#ifndef CONFIG_PCI_IOV
+#warning "Only include ice_vf_lib_private.h in CONFIG_PCI_IOV virtualization files"
+#endif
+
+void ice_dis_vf_qs(struct ice_vf *vf);
+int ice_check_vf_init(struct ice_pf *pf, struct ice_vf *vf);
+struct ice_port_info *ice_vf_get_port_info(struct ice_vf *vf);
+int ice_vsi_apply_spoofchk(struct ice_vsi *vsi, bool enable);
+bool ice_is_vf_trusted(struct ice_vf *vf);
+bool ice_vf_has_no_qs_ena(struct ice_vf *vf);
+bool ice_is_vf_link_up(struct ice_vf *vf);
+void ice_vf_ctrl_invalidate_vsi(struct ice_vf *vf);
+void ice_vf_ctrl_vsi_release(struct ice_vf *vf);
+struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf);
+void ice_vf_invalidate_vsi(struct ice_vf *vf);
+void ice_vf_set_initialized(struct ice_vf *vf);
+
+#endif /* _ICE_VF_LIB_PRIVATE_H_ */
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
index d64df81d4893..506f1dbd2795 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
@@ -5,6 +5,7 @@
 #include "ice_base.h"
 #include "ice_lib.h"
 #include "ice_flow.h"
+#include "ice_vf_lib_private.h"
 
 #define to_fltr_conf_from_desc(p) \
 	container_of(p, struct virtchnl_fdir_fltr_conf, input)
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.h b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.h
index f4e629f4c09b..c5bcc8d7481c 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.h
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.h
@@ -6,6 +6,7 @@
 
 struct ice_vf;
 struct ice_pf;
+struct ice_vsi;
 
 enum ice_fdir_ctx_stat {
 	ICE_FDIR_CTX_READY,
