selftests: kvm: move vm_xsave_req_perm call to amx_test

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.26.1.rt7.183.el8_6
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit dd4516aee365fc9c944c9d6036b6b87363398680
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.26.1.rt7.183.el8_6/dd4516ae.failed

There is no need for tests other than amx_test to enable dynamic xsave
states.  Remove the call to vm_xsave_req_perm from generic code,
and move it inside the test.  While at it, allow customizing the bit
that is requested, so that future tests can use it differently.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dd4516aee365fc9c944c9d6036b6b87363398680)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/include/kvm_util_base.h
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
#	tools/testing/selftests/kvm/x86_64/amx_test.c
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index 28cb881f440d,c1d1c195a838..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -650,6 -650,45 +650,48 @@@ static void vcpu_setup(struct kvm_vm *v
  	vcpu_sregs_set(vm, vcpuid, &sregs);
  }
  
++<<<<<<< HEAD
++=======
+ #define CPUID_XFD_BIT (1 << 4)
+ static bool is_xfd_supported(void)
+ {
+ 	int eax, ebx, ecx, edx;
+ 	const int leaf = 0xd, subleaf = 0x1;
+ 
+ 	__asm__ __volatile__(
+ 		"cpuid"
+ 		: /* output */ "=a"(eax), "=b"(ebx),
+ 		  "=c"(ecx), "=d"(edx)
+ 		: /* input */ "0"(leaf), "2"(subleaf));
+ 
+ 	return !!(eax & CPUID_XFD_BIT);
+ }
+ 
+ void vm_xsave_req_perm(int bit)
+ {
+ 	u64 bitmask;
+ 	long rc;
+ 
+ 	if (!is_xfd_supported())
+ 		exit(KSFT_SKIP);
+ 
+ 	rc = syscall(SYS_arch_prctl, ARCH_REQ_XCOMP_GUEST_PERM, bit);
+ 
+ 	/*
+ 	 * The older kernel version(<5.15) can't support
+ 	 * ARCH_REQ_XCOMP_GUEST_PERM and directly return.
+ 	 */
+ 	if (rc)
+ 		return;
+ 
+ 	rc = syscall(SYS_arch_prctl, ARCH_GET_XCOMP_GUEST_PERM, &bitmask);
+ 	TEST_ASSERT(rc == 0, "prctl(ARCH_GET_XCOMP_GUEST_PERM) error: %ld", rc);
+ 	TEST_ASSERT(bitmask & (1ULL << bit),
+ 		    "prctl(ARCH_REQ_XCOMP_GUEST_PERM) failure bitmask=0x%lx",
+ 		    bitmask);
+ }
+ 
++>>>>>>> dd4516aee365 (selftests: kvm: move vm_xsave_req_perm call to amx_test)
  void vm_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid, void *guest_code)
  {
  	struct kvm_mp_state mp_state;
* Unmerged path tools/testing/selftests/kvm/include/kvm_util_base.h
* Unmerged path tools/testing/selftests/kvm/x86_64/amx_test.c
* Unmerged path tools/testing/selftests/kvm/include/kvm_util_base.h
diff --git a/tools/testing/selftests/kvm/include/x86_64/processor.h b/tools/testing/selftests/kvm/include/x86_64/processor.h
index 05e65ca1c30c..2994e3f46df2 100644
--- a/tools/testing/selftests/kvm/include/x86_64/processor.h
+++ b/tools/testing/selftests/kvm/include/x86_64/processor.h
@@ -416,6 +416,7 @@ uint64_t kvm_hypercall(uint64_t nr, uint64_t a0, uint64_t a1, uint64_t a2,
 struct kvm_cpuid2 *kvm_get_supported_hv_cpuid(void);
 void vcpu_set_hv_cpuid(struct kvm_vm *vm, uint32_t vcpuid);
 struct kvm_cpuid2 *vcpu_get_supported_hv_cpuid(struct kvm_vm *vm, uint32_t vcpuid);
+void vm_xsave_req_perm(int bit);
 
 enum x86_page_size {
 	X86_PAGE_SIZE_4K = 0,
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
* Unmerged path tools/testing/selftests/kvm/x86_64/amx_test.c
