pidfd: add polling support

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.26.1.rt7.183.el8_6
commit-author Joel Fernandes (Google) <joel@joelfernandes.org>
commit b53b0b9d9a613c418057f6cb921c2f40a6f78c24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.26.1.rt7.183.el8_6/b53b0b9d.failed

This patch adds polling support to pidfd.

Android low memory killer (LMK) needs to know when a process dies once
it is sent the kill signal. It does so by checking for the existence of
/proc/pid which is both racy and slow. For example, if a PID is reused
between when LMK sends a kill signal and checks for existence of the
PID, since the wrong PID is now possibly checked for existence.
Using the polling support, LMK will be able to get notified when a process
exists in race-free and fast way, and allows the LMK to do other things
(such as by polling on other fds) while awaiting the process being killed
to die.

For notification to polling processes, we follow the same existing
mechanism in the kernel used when the parent of the task group is to be
notified of a child's death (do_notify_parent). This is precisely when the
tasks waiting on a poll of pidfd are also awakened in this patch.

We have decided to include the waitqueue in struct pid for the following
reasons:
1. The wait queue has to survive for the lifetime of the poll. Including
   it in task_struct would not be option in this case because the task can
   be reaped and destroyed before the poll returns.

2. By including the struct pid for the waitqueue means that during
   de_thread(), the new thread group leader automatically gets the new
   waitqueue/pid even though its task_struct is different.

Appropriate test cases are added in the second patch to provide coverage of
all the cases the patch is handling.

	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Daniel Colascione <dancol@google.com>
	Cc: Jann Horn <jannh@google.com>
	Cc: Tim Murray <timmurray@google.com>
	Cc: Jonathan Kowalski <bl0pbl33p@gmail.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: David Howells <dhowells@redhat.com>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: kernel-team@android.com
	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
Co-developed-by: Daniel Colascione <dancol@google.com>
	Signed-off-by: Daniel Colascione <dancol@google.com>
	Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
	Signed-off-by: Christian Brauner <christian@brauner.io>
(cherry picked from commit b53b0b9d9a613c418057f6cb921c2f40a6f78c24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/pid.h
diff --cc include/linux/pid.h
index 6d66c404c789,1484db6ca8d1..000000000000
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@@ -3,7 -3,7 +3,11 @@@
  #define _LINUX_PID_H
  
  #include <linux/rculist.h>
++<<<<<<< HEAD
 +#include <linux/atomic.h>
++=======
+ #include <linux/wait.h>
++>>>>>>> b53b0b9d9a61 (pidfd: add polling support)
  
  enum pid_type
  {
* Unmerged path include/linux/pid.h
diff --git a/kernel/fork.c b/kernel/fork.c
index 2f2eeb19562e..116994af001b 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1769,8 +1769,34 @@ static void pidfd_show_fdinfo(struct seq_file *m, struct file *f)
 }
 #endif
 
+/*
+ * Poll support for process exit notification.
+ */
+static unsigned int pidfd_poll(struct file *file, struct poll_table_struct *pts)
+{
+	struct task_struct *task;
+	struct pid *pid = file->private_data;
+	int poll_flags = 0;
+
+	poll_wait(file, &pid->wait_pidfd, pts);
+
+	rcu_read_lock();
+	task = pid_task(pid, PIDTYPE_PID);
+	/*
+	 * Inform pollers only when the whole thread group exits.
+	 * If the thread group leader exits before all other threads in the
+	 * group, then poll(2) should block, similar to the wait(2) family.
+	 */
+	if (!task || (task->exit_state && thread_group_empty(task)))
+		poll_flags = POLLIN | POLLRDNORM;
+	rcu_read_unlock();
+
+	return poll_flags;
+}
+
 const struct file_operations pidfd_fops = {
 	.release = pidfd_release,
+	.poll = pidfd_poll,
 #ifdef CONFIG_PROC_FS
 	.show_fdinfo = pidfd_show_fdinfo,
 #endif
diff --git a/kernel/pid.c b/kernel/pid.c
index 6d5bcb390758..3d6a420ab482 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -215,6 +215,8 @@ struct pid *alloc_pid(struct pid_namespace *ns)
 	for (type = 0; type < PIDTYPE_MAX; ++type)
 		INIT_HLIST_HEAD(&pid->tasks[type]);
 
+	init_waitqueue_head(&pid->wait_pidfd);
+
 	upid = pid->numbers + ns->level;
 	spin_lock_irq(&pidmap_lock);
 	if (!(ns->pid_allocated & PIDNS_ADDING))
diff --git a/kernel/signal.c b/kernel/signal.c
index fa3fce46796b..3d0c06fb26f8 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1934,6 +1934,14 @@ int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)
 	return ret;
 }
 
+static void do_notify_pidfd(struct task_struct *task)
+{
+	struct pid *pid;
+
+	pid = task_pid(task);
+	wake_up_all(&pid->wait_pidfd);
+}
+
 /*
  * Let a parent know about the death of a child.
  * For a stopped/continued status change, use do_notify_parent_cldstop instead.
@@ -1957,6 +1965,9 @@ bool do_notify_parent(struct task_struct *tsk, int sig)
 	BUG_ON(!tsk->ptrace &&
 	       (tsk->group_leader != tsk || !thread_group_empty(tsk)));
 
+	/* Wake up all pidfd waiters */
+	do_notify_pidfd(tsk);
+
 	if (sig != SIGCHLD) {
 		/*
 		 * This is only possible if parent == real_parent.
