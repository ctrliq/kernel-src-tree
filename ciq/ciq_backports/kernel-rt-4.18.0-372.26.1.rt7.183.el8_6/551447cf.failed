selftest: kvm: Reorder vcpu_load_state steps for AMX

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.26.1.rt7.183.el8_6
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 551447cfa5dc208b7fba7aa98391d5cc8149fa5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.26.1.rt7.183.el8_6/551447cf.failed

For AMX support it is recommended to load XCR0 after XFD, so
that KVM does not see XFD=0, XCR=1 for a save state that will
eventually be disabled (which would lead to premature allocation
of the space required for that save state).

It is also required to load XSAVE data after XCR0 and XFD, so
that KVM can trigger allocation of the extra space required to
store AMX state.

Adjust vcpu_load_state to obey these new requirements.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Yang Zhong <yang.zhong@intel.com>
Message-Id: <20211223145322.2914028-2-yang.zhong@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 551447cfa5dc208b7fba7aa98391d5cc8149fa5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index 28cb881f440d,93264424aee5..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -1159,10 -1212,15 +1159,20 @@@ void vcpu_load_state(struct kvm_vm *vm
  	struct vcpu *vcpu = vcpu_find(vm, vcpuid);
  	int r;
  
++<<<<<<< HEAD
 +	r = ioctl(vcpu->fd, KVM_SET_XSAVE, &state->xsave);
 +        TEST_ASSERT(r == 0, "Unexpected result from KVM_SET_XSAVE, r: %i",
++=======
+ 	r = ioctl(vcpu->fd, KVM_SET_SREGS, &state->sregs);
+ 	TEST_ASSERT(r == 0, "Unexpected result from KVM_SET_SREGS, r: %i",
++>>>>>>> 551447cfa5dc (selftest: kvm: Reorder vcpu_load_state steps for AMX)
                  r);
  
+ 	r = ioctl(vcpu->fd, KVM_SET_MSRS, &state->msrs);
+ 	TEST_ASSERT(r == state->msrs.nmsrs,
+ 		"Unexpected result from KVM_SET_MSRS, r: %i (failed at %x)",
+ 		r, r == state->msrs.nmsrs ? -1 : state->msrs.entries[r].index);
+ 
  	if (kvm_check_cap(KVM_CAP_XCRS)) {
  		r = ioctl(vcpu->fd, KVM_SET_XCRS, &state->xcrs);
  		TEST_ASSERT(r == 0, "Unexpected result from KVM_SET_XCRS, r: %i",
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
