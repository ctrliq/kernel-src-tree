RDMA/mana_ib: Handle net event for pointing to the current netdev

jira LE-4365
Rebuild_History Non-Buildable kernel-6.12.0-55.38.1.el10_0
commit-author Long Li <longli@microsoft.com>
commit bee35b7161aaaed9831e2f14876c374b9c566952
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-55.38.1.el10_0/bee35b71.failed

When running under Hyper-V, the master device to the RDMA device is always
bonded to this RDMA device. This is not user-configurable.

The master device can be unbind/bind from the kernel. During those events,
the RDMA device should set to the current netdev to reflect the change of
master device from those events.

	Signed-off-by: Long Li <longli@microsoft.com>
Link: https://patch.msgid.link/1741821332-9392-2-git-send-email-longli@linuxonhyperv.com
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit bee35b7161aaaed9831e2f14876c374b9c566952)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mana/device.c
#	drivers/infiniband/hw/mana/mana_ib.h
diff --cc drivers/infiniband/hw/mana/device.c
index 7ac01918ef7c,b31089320aa5..000000000000
--- a/drivers/infiniband/hw/mana/device.c
+++ b/drivers/infiniband/hw/mana/device.c
@@@ -51,6 -60,43 +51,46 @@@ static const struct ib_device_ops mana_
  			   ib_ind_table),
  };
  
++<<<<<<< HEAD
++=======
+ static const struct ib_device_ops mana_ib_stats_ops = {
+ 	.alloc_hw_port_stats = mana_ib_alloc_hw_port_stats,
+ 	.get_hw_stats = mana_ib_get_hw_stats,
+ };
+ 
+ static int mana_ib_netdev_event(struct notifier_block *this,
+ 				unsigned long event, void *ptr)
+ {
+ 	struct mana_ib_dev *dev = container_of(this, struct mana_ib_dev, nb);
+ 	struct net_device *event_dev = netdev_notifier_info_to_dev(ptr);
+ 	struct gdma_context *gc = dev->gdma_dev->gdma_context;
+ 	struct mana_context *mc = gc->mana.driver_data;
+ 	struct net_device *ndev;
+ 
+ 	/* Only process events from our parent device */
+ 	if (event_dev != mc->ports[0])
+ 		return NOTIFY_DONE;
+ 
+ 	switch (event) {
+ 	case NETDEV_CHANGEUPPER:
+ 		ndev = mana_get_primary_netdev(mc, 0, &dev->dev_tracker);
+ 		/*
+ 		 * RDMA core will setup GID based on updated netdev.
+ 		 * It's not possible to race with the core as rtnl lock is being
+ 		 * held.
+ 		 */
+ 		ib_device_set_netdev(&dev->ib_dev, ndev, 1);
+ 
+ 		/* mana_get_primary_netdev() returns ndev with refcount held */
+ 		netdev_put(ndev, &dev->dev_tracker);
+ 
+ 		return NOTIFY_OK;
+ 	default:
+ 		return NOTIFY_DONE;
+ 	}
+ }
+ 
++>>>>>>> bee35b7161aa (RDMA/mana_ib: Handle net event for pointing to the current netdev)
  static int mana_ib_probe(struct auxiliary_device *adev,
  			 const struct auxiliary_device_id *id)
  {
@@@ -113,9 -166,11 +161,9 @@@
  	if (ret) {
  		ibdev_err(&dev->ib_dev, "Failed to query device caps, ret %d",
  			  ret);
- 		goto deregister_device;
+ 		goto deregister_net_notifier;
  	}
  
 -	ib_set_device_ops(&dev->ib_dev, &mana_ib_stats_ops);
 -
  	ret = mana_ib_create_eqs(dev);
  	if (ret) {
  		ibdev_err(&dev->ib_dev, "Failed to create EQs, ret %d", ret);
diff --cc drivers/infiniband/hw/mana/mana_ib.h
index c3c9dc1c8d8b,6903946677e5..000000000000
--- a/drivers/infiniband/hw/mana/mana_ib.h
+++ b/drivers/infiniband/hw/mana/mana_ib.h
@@@ -65,6 -77,9 +65,12 @@@ struct mana_ib_dev 
  	struct gdma_queue **eqs;
  	struct xarray qp_table_wq;
  	struct mana_ib_adapter_caps adapter_caps;
++<<<<<<< HEAD
++=======
+ 	struct dma_pool *av_pool;
+ 	netdevice_tracker dev_tracker;
+ 	struct notifier_block nb;
++>>>>>>> bee35b7161aa (RDMA/mana_ib: Handle net event for pointing to the current netdev)
  };
  
  struct mana_ib_wq {
* Unmerged path drivers/infiniband/hw/mana/device.c
* Unmerged path drivers/infiniband/hw/mana/mana_ib.h
