xfs: rearrange code in xfs_inode_item_precommit

jira KERNEL-572
Rebuild_History Non-Buildable kernel-6.12.0-124.31.1.el10_1
commit-author Dave Chinner <dchinner@redhat.com>
commit bc7d684fea18cc48c3630d2b7f1789000ff2df5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-124.31.1.el10_1/bc7d684f.failed

There are similar extsize checks and updates done inside and outside
the inode item lock, which could all be done under a single top
level logic branch outside the ili_lock. The COW extsize fixup can
potentially miss updating the XFS_ILOG_CORE in ili_fsync_fields, so
moving this code up above the ili_fsync_fields update could also be
considered a fix.

Further, to make the next change a bit cleaner, move where we
calculate the on-disk flag mask to after we attach the cluster
buffer to the the inode log item.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Carlos Maiolino <cem@kernel.org>
(cherry picked from commit bc7d684fea18cc48c3630d2b7f1789000ff2df5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode_item.c
diff --cc fs/xfs/xfs_inode_item.c
index b509cbd191f4,678ca95793e0..000000000000
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@@ -131,32 -131,28 +131,35 @@@ xfs_inode_item_precommit
  	}
  
  	/*
- 	 * Inode verifiers do not check that the extent size hint is an integer
- 	 * multiple of the rt extent size on a directory with both rtinherit
- 	 * and extszinherit flags set.  If we're logging a directory that is
- 	 * misconfigured in this way, clear the hint.
+ 	 * Inode verifiers do not check that the extent size hints are an
+ 	 * integer multiple of the rt extent size on a directory with
+ 	 * rtinherit flags set.  If we're logging a directory that is
+ 	 * misconfigured in this way, clear the bad hints.
  	 */
- 	if ((ip->i_diflags & XFS_DIFLAG_RTINHERIT) &&
- 	    (ip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) &&
- 	    xfs_extlen_to_rtxmod(ip->i_mount, ip->i_extsize) > 0) {
- 		ip->i_diflags &= ~(XFS_DIFLAG_EXTSIZE |
- 				   XFS_DIFLAG_EXTSZINHERIT);
- 		ip->i_extsize = 0;
- 		flags |= XFS_ILOG_CORE;
+ 	if (ip->i_diflags & XFS_DIFLAG_RTINHERIT) {
+ 		if ((ip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) &&
+ 		    xfs_extlen_to_rtxmod(ip->i_mount, ip->i_extsize) > 0) {
+ 			ip->i_diflags &= ~(XFS_DIFLAG_EXTSIZE |
+ 					   XFS_DIFLAG_EXTSZINHERIT);
+ 			ip->i_extsize = 0;
+ 			flags |= XFS_ILOG_CORE;
+ 		}
+ 		if ((ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE) &&
+ 		    xfs_extlen_to_rtxmod(ip->i_mount, ip->i_cowextsize) > 0) {
+ 			ip->i_diflags2 &= ~XFS_DIFLAG2_COWEXTSIZE;
+ 			ip->i_cowextsize = 0;
+ 			flags |= XFS_ILOG_CORE;
+ 		}
  	}
  
- 	/*
- 	 * Record the specific change for fdatasync optimisation. This allows
- 	 * fdatasync to skip log forces for inodes that are only timestamp
- 	 * dirty. Once we've processed the XFS_ILOG_IVERSION flag, convert it
- 	 * to XFS_ILOG_CORE so that the actual on-disk dirty tracking
- 	 * (ili_fields) correctly tracks that the version has changed.
- 	 */
  	spin_lock(&iip->ili_lock);
++<<<<<<< HEAD
 +	iip->ili_fsync_fields |= (flags & ~XFS_ILOG_IVERSION);
 +	if (flags & XFS_ILOG_IVERSION)
 +		flags = ((flags & ~XFS_ILOG_IVERSION) | XFS_ILOG_CORE);
 +
++=======
++>>>>>>> bc7d684fea18 (xfs: rearrange code in xfs_inode_item_precommit)
  	if (!iip->ili_item.li_buf) {
  		struct xfs_buf	*bp;
  		int		error;
* Unmerged path fs/xfs/xfs_inode_item.c
