net: dst: introduce dst->dev_rcu

jira KERNEL-572
Rebuild_History Non-Buildable kernel-6.12.0-124.31.1.el10_1
commit-author Eric Dumazet <edumazet@google.com>
commit caedcc5b6df1b2e2b5f39079e3369c1d4d5c5f50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-124.31.1.el10_1/caedcc5b.failed

Followup of commit 88fe14253e18 ("net: dst: add four helpers
to annotate data-races around dst->dev").

We want to gradually add explicit RCU protection to dst->dev,
including lockdep support.

Add an union to alias dst->dev_rcu and dst->dev.

Add dst_dev_net_rcu() helper.

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://patch.msgid.link/20250828195823.3958522-2-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit caedcc5b6df1b2e2b5f39079e3369c1d4d5c5f50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/dst.h
#	net/core/dst.c
#	net/ipv4/route.c
diff --cc include/net/dst.h
index 08647c99d79c,f8aa1239b4db..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -561,6 -566,41 +564,44 @@@ static inline void skb_dst_update_pmtu_
  		dst->ops->update_pmtu(dst, NULL, skb, mtu, false);
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct net_device *dst_dev(const struct dst_entry *dst)
+ {
+ 	return READ_ONCE(dst->dev);
+ }
+ 
+ static inline struct net_device *dst_dev_rcu(const struct dst_entry *dst)
+ {
+ 	return rcu_dereference(dst->dev_rcu);
+ }
+ 
+ static inline struct net *dst_dev_net_rcu(const struct dst_entry *dst)
+ {
+ 	return dev_net_rcu(dst_dev_rcu(dst));
+ }
+ 
+ static inline struct net_device *skb_dst_dev(const struct sk_buff *skb)
+ {
+ 	return dst_dev(skb_dst(skb));
+ }
+ 
+ static inline struct net_device *skb_dst_dev_rcu(const struct sk_buff *skb)
+ {
+ 	return dst_dev_rcu(skb_dst(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net(const struct sk_buff *skb)
+ {
+ 	return dev_net(skb_dst_dev(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net_rcu(const struct sk_buff *skb)
+ {
+ 	return dev_net_rcu(skb_dst_dev_rcu(skb));
+ }
+ 
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  struct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie);
  void dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,
  			       struct sk_buff *skb, u32 mtu, bool confirm_neigh);
diff --cc net/core/dst.c
index 795ca07e28a4,e9d35f49c9e7..000000000000
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@@ -145,12 -145,12 +145,18 @@@ void dst_dev_put(struct dst_entry *dst
  {
  	struct net_device *dev = dst->dev;
  
 -	WRITE_ONCE(dst->obsolete, DST_OBSOLETE_DEAD);
 +	dst->obsolete = DST_OBSOLETE_DEAD;
  	if (dst->ops->ifdown)
  		dst->ops->ifdown(dst, dev);
++<<<<<<< HEAD
 +	dst->input = dst_discard;
 +	dst->output = dst_discard_out;
 +	dst->dev = blackhole_netdev;
++=======
+ 	WRITE_ONCE(dst->input, dst_discard);
+ 	WRITE_ONCE(dst->output, dst_discard_out);
+ 	rcu_assign_pointer(dst->dev_rcu, blackhole_netdev);
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  	netdev_ref_replace(dev, blackhole_netdev, &dst->dev_tracker,
  			   GFP_ATOMIC);
  }
diff --cc net/ipv4/route.c
index c4ffbf26c17b,44382d175589..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1021,7 -1027,7 +1021,11 @@@ static void __ip_rt_update_pmtu(struct 
  		return;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	net = dev_net_rcu(dst->dev);
++=======
+ 	net = dst_dev_net_rcu(dst);
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  	if (mtu < net->ipv4.ip_rt_min_pmtu) {
  		lock = true;
  		mtu = min(old_mtu, net->ipv4.ip_rt_min_pmtu);
@@@ -1307,7 -1327,7 +1311,11 @@@ static unsigned int ipv4_default_advmss
  	struct net *net;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	net = dev_net_rcu(dst->dev);
++=======
+ 	net = dst_dev_net_rcu(dst);
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  	advmss = max_t(unsigned int, ipv4_mtu(dst) - header_size,
  				   net->ipv4.ip_rt_min_advmss);
  	rcu_read_unlock();
* Unmerged path include/net/dst.h
* Unmerged path net/core/dst.c
* Unmerged path net/ipv4/route.c
