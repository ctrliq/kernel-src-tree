mm/page_alloc: don't wake kswapd from rmqueue() unless __GFP_KSWAPD_RECLAIM is specified

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-525.el8
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 3b11edf1f2398cac206a224308de6628ebeea924
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-525.el8/3b11edf1.failed

Commit 73444bc4d8f9 ("mm, page_alloc: do not wake kswapd with zone lock
held") moved wakeup_kswapd() from steal_suitable_fallback() to rmqueue()
using ZONE_BOOSTED_WATERMARK flag.

Only allocation contexts that include ALLOC_KSWAPD (which corresponds to
__GFP_KSWAPD_RECLAIM) should wake kswapd, for callers are supposed to
remove __GFP_KSWAPD_RECLAIM if trying to hold pgdat->kswapd_wait has a
risk of deadlock.  But since zone->flags is a shared variable, a thread
doing !__GFP_KSWAPD_RECLAIM allocation request might observe this flag
being set immediately after another thread doing __GFP_KSWAPD_RECLAIM
allocation request set this flag, causing possibility of deadlock.

Link: https://lkml.kernel.org/r/c3c3dacf-dd3b-77c9-f96a-d0982b4b2a4f@I-love.SAKURA.ne.jp
Fixes: 73444bc4d8f9 ("mm, page_alloc: do not wake kswapd with zone lock held")
	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Acked-by: Mel Gorman <mgorman@techsingularity.net>
	Cc: "Huang, Ying" <ying.huang@intel.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 3b11edf1f2398cac206a224308de6628ebeea924)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 8adb173695f2,091a6cb44265..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -3508,7 -2827,8 +3508,12 @@@ struct page *rmqueue(struct zone *prefe
  
  out:
  	/* Separate test+clear to avoid unnecessary atomics */
++<<<<<<< HEAD
 +	if (test_bit(ZONE_BOOSTED_WATERMARK, &zone->flags)) {
++=======
+ 	if ((alloc_flags & ALLOC_KSWAPD) &&
+ 	    unlikely(test_bit(ZONE_BOOSTED_WATERMARK, &zone->flags))) {
++>>>>>>> 3b11edf1f239 (mm/page_alloc: don't wake kswapd from rmqueue() unless __GFP_KSWAPD_RECLAIM is specified)
  		clear_bit(ZONE_BOOSTED_WATERMARK, &zone->flags);
  		wakeup_kswapd(zone, 0, 0, zone_idx(zone));
  	}
* Unmerged path mm/page_alloc.c
