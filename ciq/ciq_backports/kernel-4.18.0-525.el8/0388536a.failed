mm:vmscan: fix inaccurate reclaim during proactive reclaim

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-525.el8
commit-author Efly Young <yangyifei03@kuaishou.com>
commit 0388536ac29104a478c79b3869541524caec28eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-525.el8/0388536a.failed

Before commit f53af4285d77 ("mm: vmscan: fix extreme overreclaim and swap
floods"), proactive reclaim will extreme overreclaim sometimes.  But
proactive reclaim still inaccurate and some extent overreclaim.

Problematic case is easy to construct.  Allocate lots of anonymous memory
(e.g., 20G) in a memcg, then swapping by writing memory.recalim and there
is a certain probability of overreclaim.  For example, request 1G by
writing memory.reclaim will eventually reclaim 1.7G or other values more
than 1G.

The reason is that reclaimer may have already reclaimed part of requested
memory in one loop, but before adjust sc->nr_to_reclaim in outer loop,
call shrink_lruvec() again will still follow the current sc->nr_to_reclaim
to work.  It will eventually lead to overreclaim.  In theory, the amount
of reclaimed would be in [request, 2 * request).

Reclaimer usually tends to reclaim more than request.  But either direct
or kswapd reclaim have much smaller nr_to_reclaim targets, so it is less
noticeable and not have much impact.

Proactive reclaim can usually come in with a larger value, so the error is
difficult to ignore.  Considering proactive reclaim is usually low
frequency, handle the batching into smaller chunks is a better approach.

Link: https://lkml.kernel.org/r/20230721014116.3388-1-yangyifei03@kuaishou.com
	Signed-off-by: Efly Young <yangyifei03@kuaishou.com>
	Suggested-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 0388536ac29104a478c79b3869541524caec28eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index e050c7481956,56abc4f426f4..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -6759,8 -6686,8 +6759,13 @@@ static ssize_t memory_reclaim(struct ke
  			lru_add_drain_all();
  
  		reclaimed = try_to_free_mem_cgroup_pages(memcg,
++<<<<<<< HEAD
 +						nr_to_reclaim - nr_reclaimed,
 +						GFP_KERNEL, true);
++=======
+ 					min(nr_to_reclaim - nr_reclaimed, SWAP_CLUSTER_MAX),
+ 					GFP_KERNEL, reclaim_options);
++>>>>>>> 0388536ac291 (mm:vmscan: fix inaccurate reclaim during proactive reclaim)
  
  		if (!reclaimed && !nr_retries--)
  			return -EAGAIN;
* Unmerged path mm/memcontrol.c
