kernfs: Fix UAF in polling when open file is released

jira KERNEL-216
cve CVE-2025-39881
Rebuild_History Non-Buildable kernel-5.14.0-611.9.1.el9_7
commit-author Chen Ridong <chenridong@huawei.com>
commit 3c9ba2777d6c86025e1ba4186dc5cd930e40ec5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.9.1.el9_7/3c9ba277.failed

A use-after-free (UAF) vulnerability was identified in the PSI (Pressure
Stall Information) monitoring mechanism:

BUG: KASAN: slab-use-after-free in psi_trigger_poll+0x3c/0x140
Read of size 8 at addr ffff3de3d50bd308 by task systemd/1

psi_trigger_poll+0x3c/0x140
cgroup_pressure_poll+0x70/0xa0
cgroup_file_poll+0x8c/0x100
kernfs_fop_poll+0x11c/0x1c0
ep_item_poll.isra.0+0x188/0x2c0

Allocated by task 1:
cgroup_file_open+0x88/0x388
kernfs_fop_open+0x73c/0xaf0
do_dentry_open+0x5fc/0x1200
vfs_open+0xa0/0x3f0
do_open+0x7e8/0xd08
path_openat+0x2fc/0x6b0
do_filp_open+0x174/0x368

Freed by task 8462:
cgroup_file_release+0x130/0x1f8
kernfs_drain_open_files+0x17c/0x440
kernfs_drain+0x2dc/0x360
kernfs_show+0x1b8/0x288
cgroup_file_show+0x150/0x268
cgroup_pressure_write+0x1dc/0x340
cgroup_file_write+0x274/0x548

Reproduction Steps:
1. Open test/cpu.pressure and establish epoll monitoring
2. Disable monitoring: echo 0 > test/cgroup.pressure
3. Re-enable monitoring: echo 1 > test/cgroup.pressure

The race condition occurs because:
1. When cgroup.pressure is disabled (echo 0 > cgroup.pressure), it:
   - Releases PSI triggers via cgroup_file_release()
   - Frees of->priv through kernfs_drain_open_files()
2. While epoll still holds reference to the file and continues polling
3. Re-enabling (echo 1 > cgroup.pressure) accesses freed of->priv

epolling			disable/enable cgroup.pressure
fd=open(cpu.pressure)
while(1)
...
epoll_wait
kernfs_fop_poll
kernfs_get_active = true	echo 0 > cgroup.pressure
...				cgroup_file_show
				kernfs_show
				// inactive kn
				kernfs_drain_open_files
				cft->release(of);
				kfree(ctx);
				...
kernfs_get_active = false
				echo 1 > cgroup.pressure
				kernfs_show
				kernfs_activate_one(kn);
kernfs_fop_poll
kernfs_get_active = true
cgroup_file_poll
psi_trigger_poll
// UAF
...
end: close(fd)

To address this issue, introduce kernfs_get_active_of() for kernfs open
files to obtain active references. This function will fail if the open file
has been released. Replace kernfs_get_active() with kernfs_get_active_of()
to prevent further operations on released file descriptors.

Fixes: 34f26a15611a ("sched/psi: Per-cgroup PSI accounting disable/re-enable interface")
	Cc: stable <stable@kernel.org>
	Reported-by: Zhang Zhaotian <zhangzhaotian@huawei.com>
	Signed-off-by: Chen Ridong <chenridong@huawei.com>
	Acked-by: Tejun Heo <tj@kernel.org>
Link: https://lore.kernel.org/r/20250822070715.1565236-2-chenridong@huaweicloud.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3c9ba2777d6c86025e1ba4186dc5cd930e40ec5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/file.c
diff --cc fs/kernfs/file.c
index ffe8e26d18a3,9adf36e6364b..000000000000
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@@ -488,12 -501,14 +506,12 @@@ static int kernfs_fop_mmap(struct file 
  		goto out_put;
  
  	rc = 0;
 -	if (!of->mmapped) {
 -		of->mmapped = true;
 -		of_on(of)->nr_mmapped++;
 -		of->vm_ops = vma->vm_ops;
 -	}
 +	of->mmapped = true;
 +	of_on(of)->nr_mmapped++;
 +	of->vm_ops = vma->vm_ops;
  	vma->vm_ops = &kernfs_vm_ops;
  out_put:
- 	kernfs_put_active(of->kn);
+ 	kernfs_put_active_of(of);
  out_unlock:
  	mutex_unlock(&of->mutex);
  
@@@ -855,10 -878,37 +873,40 @@@ static __poll_t kernfs_fop_poll(struct 
  	else
  		ret = kernfs_generic_poll(of, wait);
  
- 	kernfs_put_active(kn);
+ 	kernfs_put_active_of(of);
+ 	return ret;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static loff_t kernfs_fop_llseek(struct file *file, loff_t offset, int whence)
+ {
+ 	struct kernfs_open_file *of = kernfs_of(file);
+ 	const struct kernfs_ops *ops;
+ 	loff_t ret;
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is primarily to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!kernfs_get_active_of(of)) {
+ 		mutex_unlock(&of->mutex);
+ 		return -ENODEV;
+ 	}
+ 
+ 	ops = kernfs_ops(of->kn);
+ 	if (ops->llseek)
+ 		ret = ops->llseek(of, offset, whence);
+ 	else
+ 		ret = generic_file_llseek(file, offset, whence);
+ 
+ 	kernfs_put_active_of(of);
+ 	mutex_unlock(&of->mutex);
  	return ret;
  }
  
++>>>>>>> 3c9ba2777d6c (kernfs: Fix UAF in polling when open file is released)
  static void kernfs_notify_workfn(struct work_struct *work)
  {
  	struct kernfs_node *kn;
* Unmerged path fs/kernfs/file.c
