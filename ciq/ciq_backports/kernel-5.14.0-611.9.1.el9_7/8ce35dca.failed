NFSD: Fix callback decoder status codes

jira KERNEL-216
Rebuild_History Non-Buildable kernel-5.14.0-611.9.1.el9_7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 8ce35dcaf3aed7113cd692759dc0a26cec8cd0c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.9.1.el9_7/8ce35dca.failed

fs/nfsd/nfs4callback.c implements a callback client. Thus its XDR
decoders are decoding replies, not calls.

NFS4ERR_BAD_XDR is an on-the-wire status code that reports that the
client sent a corrupted RPC /call/. It's not used as the internal
error code when a /reply/ can't be decoded, since that kind of
failure is never reported to the sender of that RPC message.

Instead, a reply decoder should return -EIO, as the reply decoders
in the NFS client do.

Fixes: 6487a13b5c6b ("NFSD: add support for CB_GETATTR callback")
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 8ce35dcaf3aed7113cd692759dc0a26cec8cd0c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4callback.c
diff --cc fs/nfsd/nfs4callback.c
index d29b36b02048,ae4b7b6df47f..000000000000
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@@ -93,12 -94,35 +93,34 @@@ static int decode_cb_fattr4(struct xdr_
  {
  	fattr->ncf_cb_change = 0;
  	fattr->ncf_cb_fsize = 0;
 -	fattr->ncf_cb_atime.tv_sec = 0;
 -	fattr->ncf_cb_atime.tv_nsec = 0;
 -	fattr->ncf_cb_mtime.tv_sec = 0;
 -	fattr->ncf_cb_mtime.tv_nsec = 0;
 -
  	if (bitmap[0] & FATTR4_WORD0_CHANGE)
  		if (xdr_stream_decode_u64(xdr, &fattr->ncf_cb_change) < 0)
- 			return -NFSERR_BAD_XDR;
+ 			return -EIO;
  	if (bitmap[0] & FATTR4_WORD0_SIZE)
  		if (xdr_stream_decode_u64(xdr, &fattr->ncf_cb_fsize) < 0)
++<<<<<<< HEAD
 +			return -NFSERR_BAD_XDR;
++=======
+ 			return -EIO;
+ 	if (bitmap[2] & FATTR4_WORD2_TIME_DELEG_ACCESS) {
+ 		fattr4_time_deleg_access access;
+ 
+ 		if (!xdrgen_decode_fattr4_time_deleg_access(xdr, &access))
+ 			return -EIO;
+ 		fattr->ncf_cb_atime.tv_sec = access.seconds;
+ 		fattr->ncf_cb_atime.tv_nsec = access.nseconds;
+ 
+ 	}
+ 	if (bitmap[2] & FATTR4_WORD2_TIME_DELEG_MODIFY) {
+ 		fattr4_time_deleg_modify modify;
+ 
+ 		if (!xdrgen_decode_fattr4_time_deleg_modify(xdr, &modify))
+ 			return -EIO;
+ 		fattr->ncf_cb_mtime.tv_sec = modify.seconds;
+ 		fattr->ncf_cb_mtime.tv_nsec = modify.nseconds;
+ 
+ 	}
++>>>>>>> 8ce35dcaf3ae (NFSD: Fix callback decoder status codes)
  	return 0;
  }
  
@@@ -608,11 -682,15 +630,21 @@@ static int nfs4_xdr_dec_cb_getattr(stru
  	if (unlikely(status || cb->cb_status))
  		return status;
  	if (xdr_stream_decode_uint32_array(xdr, bitmap, 3) < 0)
- 		return -NFSERR_BAD_XDR;
+ 		return -EIO;
  	if (xdr_stream_decode_u32(xdr, &attrlen) < 0)
++<<<<<<< HEAD
 +		return -NFSERR_BAD_XDR;
 +	if (attrlen > (sizeof(ncf->ncf_cb_change) + sizeof(ncf->ncf_cb_fsize)))
 +		return -NFSERR_BAD_XDR;
++=======
+ 		return -EIO;
+ 	maxlen = sizeof(ncf->ncf_cb_change) + sizeof(ncf->ncf_cb_fsize);
+ 	if (bitmap[2] != 0)
+ 		maxlen += (sizeof(ncf->ncf_cb_mtime.tv_sec) +
+ 			   sizeof(ncf->ncf_cb_mtime.tv_nsec)) * 2;
+ 	if (attrlen > maxlen)
+ 		return -EIO;
++>>>>>>> 8ce35dcaf3ae (NFSD: Fix callback decoder status codes)
  	status = decode_cb_fattr4(xdr, bitmap, ncf);
  	return status;
  }
* Unmerged path fs/nfsd/nfs4callback.c
