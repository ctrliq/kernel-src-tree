gfs2: Switch lock order of inode and iopen glock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 29464ee36bcaaee2691249f49b9592b8d5c97ece
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/29464ee3.failed

This patch tries to fix the continual ABBA deadlocks we keep having
between the iopen and inode glocks. This switches the lock order in
gfs2_inode_lookup and gfs2_create_inode so the iopen glock is always
locked first.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 29464ee36bcaaee2691249f49b9592b8d5c97ece)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
diff --cc fs/gfs2/inode.c
index 4b47d68bd57f,c8ec876f33ea..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -147,17 -129,25 +147,31 @@@ struct inode *gfs2_inode_lookup(struct 
  
  	if (inode->i_state & I_NEW) {
  		struct gfs2_sbd *sdp = GFS2_SB(inode);
 -		struct gfs2_glock *io_gl;
  
- 		error = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);
+ 		error = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE,
+ 				       &ip->i_gl);
+ 		if (unlikely(error))
+ 			goto fail;
+ 
+ 		error = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE,
+ 				       &io_gl);
+ 		if (unlikely(error))
+ 			goto fail;
+ 
+ 		if (blktype != GFS2_BLKST_UNLINKED)
+ 			gfs2_cancel_delete_work(io_gl);
+ 		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT,
+ 					   &ip->i_iopen_gh);
+ 		gfs2_glock_put(io_gl);
  		if (unlikely(error))
  			goto fail;
 +		flush_delayed_work(&ip->i_gl->gl_work);
 +
 +		error = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);
 +		if (unlikely(error))
 +			goto fail;
 +		if (blktype != GFS2_BLKST_UNLINKED)
 +			gfs2_cancel_delete_work(io_gl);
  
  		if (type == DT_UNKNOWN || blktype != GFS2_BLKST_FREE) {
  			/*
@@@ -183,14 -173,7 +197,18 @@@
  			}
  		}
  
++<<<<<<< HEAD
 +		glock_set_object(ip->i_gl, ip);
 +		set_bit(GIF_INVALID, &ip->i_flags);
 +		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);
 +		if (unlikely(error))
 +			goto fail;
 +		glock_set_object(ip->i_iopen_gh.gh_gl, ip);
 +		gfs2_glock_put(io_gl);
 +		io_gl = NULL;
++=======
+ 		set_bit(GLF_INSTANTIATE_NEEDED, &ip->i_gl->gl_flags);
++>>>>>>> 29464ee36bca (gfs2: Switch lock order of inode and iopen glock)
  
  		/* Lowest possible timestamp; will be overwritten in gfs2_dinode_in. */
  		inode->i_atime.tv_sec = 1LL << (8 * sizeof(inode->i_atime.tv_sec) - 1);
* Unmerged path fs/gfs2/inode.c
