gfs2: Make sure not to return short direct writes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 3bde4c48586074202044456285a97ccdf9048988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/3bde4c48.failed

When direct writes fail with -ENOTBLK because we're writing into a
hole (gfs2_iomap_begin()) or because of a page invalidation failure
(iomap_dio_rw()), we're falling back to buffered writes.  In that case,
when we lose the inode glock in gfs2_file_buffered_write(), we want to
re-acquire it instead of returning a short write.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 3bde4c48586074202044456285a97ccdf9048988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 37f4489b53a0,22b41acfbbc3..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -987,12 -1067,11 +987,20 @@@ retry_under_glock
  		gfs2_holder_disallow_demote(gh);
  		if (leftover != window_size) {
  			from->count = min(from->count, window_size - leftover);
++<<<<<<< HEAD
 +			if (!gfs2_holder_queued(gh)) {
 +				if (read)
 +					goto out_uninit;
 +				goto retry;
 +			}
 +			goto retry_under_glock;
++=======
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			if (read && !(iocb->ki_flags & IOCB_DIRECT))
+ 				goto out_uninit;
+ 			goto retry;
++>>>>>>> 3bde4c485860 (gfs2: Make sure not to return short direct writes)
  		}
  	}
  out_unlock:
* Unmerged path fs/gfs2/file.c
