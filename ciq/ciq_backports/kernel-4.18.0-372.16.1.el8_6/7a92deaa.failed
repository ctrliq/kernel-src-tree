gfs2: Fix atomic bug in gfs2_instantiate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 7a92deaae613c3b95f0fd02814bb09be7f7a5820
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/7a92deaa.failed

Replace test_bit() + set_bit() with test_and_set_bit() where we need an atomic
operation.  Use clear_and_wake_up_bit() instead of open coding it.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 7a92deaae613c3b95f0fd02814bb09be7f7a5820)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 8bbfd5bab589,258d8aae7c53..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -476,6 -475,47 +476,50 @@@ find_first_strong_holder(struct gfs2_gl
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * gfs2_instantiate - Call the glops instantiate function
+  * @gl: The glock
+  *
+  * Returns: 0 if instantiate was successful, 2 if type specific operation is
+  * underway, or error.
+  */
+ int gfs2_instantiate(struct gfs2_holder *gh)
+ {
+ 	struct gfs2_glock *gl = gh->gh_gl;
+ 	const struct gfs2_glock_operations *glops = gl->gl_ops;
+ 	int ret;
+ 
+ again:
+ 	if (!test_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags))
+ 		return 0;
+ 
+ 	/*
+ 	 * Since we unlock the lockref lock, we set a flag to indicate
+ 	 * instantiate is in progress.
+ 	 */
+ 	if (test_and_set_bit(GLF_INSTANTIATE_IN_PROG, &gl->gl_flags)) {
+ 		wait_on_bit(&gl->gl_flags, GLF_INSTANTIATE_IN_PROG,
+ 			    TASK_UNINTERRUPTIBLE);
+ 		/*
+ 		 * Here we just waited for a different instantiate to finish.
+ 		 * But that may not have been successful, as when a process
+ 		 * locks an inode glock _before_ it has an actual inode to
+ 		 * instantiate into. So we check again. This process might
+ 		 * have an inode to instantiate, so might be successful.
+ 		 */
+ 		goto again;
+ 	}
+ 
+ 	ret = glops->go_instantiate(gh);
+ 	if (!ret)
+ 		clear_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags);
+ 	clear_and_wake_up_bit(GLF_INSTANTIATE_IN_PROG, &gl->gl_flags);
+ 	return ret;
+ }
+ 
++>>>>>>> 7a92deaae613 (gfs2: Fix atomic bug in gfs2_instantiate)
  /**
   * do_promote - promote as many requests as possible on the current queue
   * @gl: The glock
* Unmerged path fs/gfs2/glock.c
