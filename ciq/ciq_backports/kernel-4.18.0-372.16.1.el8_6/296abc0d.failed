gfs2: No short reads or writes upon glock contention

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 296abc0d91d8b65d42224dd33452ace14491ad08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/296abc0d.failed

Commit 00bfe02f4796 ("gfs2: Fix mmap + page fault deadlocks for buffered
I/O") changed gfs2_file_read_iter() and gfs2_file_buffered_write() to
allow dropping the inode glock while faulting in user buffers.  When the
lock was dropped, a short result was returned to indicate that the
operation was interrupted.

As pointed out by Linus (see the link below), this behavior is broken
and the operations should always re-acquire the inode glock and resume
the operation instead.

Link: https://lore.kernel.org/lkml/CAHk-=whaz-g_nOOoo8RRiWNjnv2R+h6_xk2F1J4TuSRxk1MtLw@mail.gmail.com/
Fixes: 00bfe02f4796 ("gfs2: Fix mmap + page fault deadlocks for buffered I/O")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 296abc0d91d8b65d42224dd33452ace14491ad08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 37f4489b53a0,48f01323c37c..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -908,12 -989,9 +908,18 @@@ retry_under_glock
  		leftover = fault_in_iov_iter_writeable(to, window_size);
  		gfs2_holder_disallow_demote(&gh);
  		if (leftover != window_size) {
++<<<<<<< HEAD
 +			if (!gfs2_holder_queued(&gh)) {
 +				if (written)
 +					goto out_uninit;
 +				goto retry;
 +			}
 +			goto retry_under_glock;
++=======
+ 			if (gfs2_holder_queued(&gh))
+ 				goto retry_under_glock;
+ 			goto retry;
++>>>>>>> 296abc0d91d8 (gfs2: No short reads or writes upon glock contention)
  		}
  	}
  	if (gfs2_holder_queued(&gh))
@@@ -987,12 -1065,9 +993,18 @@@ retry_under_glock
  		gfs2_holder_disallow_demote(gh);
  		if (leftover != window_size) {
  			from->count = min(from->count, window_size - leftover);
++<<<<<<< HEAD
 +			if (!gfs2_holder_queued(gh)) {
 +				if (read)
 +					goto out_uninit;
 +				goto retry;
 +			}
 +			goto retry_under_glock;
++=======
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			goto retry;
++>>>>>>> 296abc0d91d8 (gfs2: No short reads or writes upon glock contention)
  		}
  	}
  out_unlock:
* Unmerged path fs/gfs2/file.c
