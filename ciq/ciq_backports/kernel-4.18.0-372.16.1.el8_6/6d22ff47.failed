gfs2: Clean up use of fault_in_iov_iter_{read,write}able

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6d22ff471070e21e24667be70764ee5abdfe5608
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/6d22ff47.failed

No need to store the return value of the fault_in functions in separate
variables.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6d22ff471070e21e24667be70764ee5abdfe5608)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 37f4489b53a0,acc0c1d41564..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -810,12 -834,34 +810,27 @@@ static ssize_t gfs2_file_direct_read(st
  	ret = gfs2_glock_nq(gh);
  	if (ret)
  		goto out_uninit;
 -retry_under_glock:
 -	pagefault_disable();
 -	to->nofault = true;
 -	ret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL,
 -			   IOMAP_DIO_PARTIAL, read);
 -	to->nofault = false;
 -	pagefault_enable();
 -	if (ret > 0)
 -		read = ret;
  
++<<<<<<< HEAD
 +	ret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL, 0);
 +	gfs2_glock_dq(gh);
++=======
+ 	if (should_fault_in_pages(ret, to, &prev_count, &window_size)) {
+ 		gfs2_holder_allow_demote(gh);
+ 		window_size -= fault_in_iov_iter_writeable(to, window_size);
+ 		gfs2_holder_disallow_demote(gh);
+ 		if (window_size) {
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			goto retry;
+ 		}
+ 	}
+ 	if (gfs2_holder_queued(gh))
+ 		gfs2_glock_dq(gh);
++>>>>>>> 6d22ff471070 (gfs2: Clean up use of fault_in_iov_iter_{read,write}able)
  out_uninit:
  	gfs2_holder_uninit(gh);
 -	if (ret < 0)
 -		return ret;
 -	return read;
 +	return ret;
  }
  
  static ssize_t gfs2_file_direct_write(struct kiocb *iocb, struct iov_iter *from,
@@@ -840,19 -896,40 +855,35 @@@
  	ret = gfs2_glock_nq(gh);
  	if (ret)
  		goto out_uninit;
 +
  	/* Silently fall back to buffered I/O when writing beyond EOF */
 -	if (iocb->ki_pos + iov_iter_count(from) > i_size_read(&ip->i_inode))
 +	if (offset + len > i_size_read(&ip->i_inode))
  		goto out;
 -retry_under_glock:
 -
 -	from->nofault = true;
 -	ret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL,
 -			   IOMAP_DIO_PARTIAL, written);
 -	from->nofault = false;
  
 +	ret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL, 0);
  	if (ret == -ENOTBLK)
  		ret = 0;
++<<<<<<< HEAD
++=======
+ 	if (ret > 0)
+ 		written = ret;
+ 
+ 	if (should_fault_in_pages(ret, from, &prev_count, &window_size)) {
+ 		gfs2_holder_allow_demote(gh);
+ 		window_size -= fault_in_iov_iter_readable(from, window_size);
+ 		gfs2_holder_disallow_demote(gh);
+ 		if (window_size) {
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			goto retry;
+ 		}
+ 	}
++>>>>>>> 6d22ff471070 (gfs2: Clean up use of fault_in_iov_iter_{read,write}able)
  out:
 -	if (gfs2_holder_queued(gh))
 -		gfs2_glock_dq(gh);
 +	gfs2_glock_dq(gh);
  out_uninit:
  	gfs2_holder_uninit(gh);
 -	if (ret < 0)
 -		return ret;
 -	return written;
 +	return ret;
  }
  
  static ssize_t gfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
@@@ -899,21 -976,16 +930,26 @@@ retry_under_glock
  	ret = generic_file_read_iter(iocb, to);
  	pagefault_enable();
  	if (ret > 0)
 -		read += ret;
 +		written += ret;
  
  	if (should_fault_in_pages(ret, to, &prev_count, &window_size)) {
- 		size_t leftover;
- 
  		gfs2_holder_allow_demote(&gh);
- 		leftover = fault_in_iov_iter_writeable(to, window_size);
+ 		window_size -= fault_in_iov_iter_writeable(to, window_size);
  		gfs2_holder_disallow_demote(&gh);
++<<<<<<< HEAD
 +		if (leftover != window_size) {
 +			if (!gfs2_holder_queued(&gh)) {
 +				if (written)
 +					goto out_uninit;
 +				goto retry;
 +			}
 +			goto retry_under_glock;
++=======
+ 		if (window_size) {
+ 			if (gfs2_holder_queued(&gh))
+ 				goto retry_under_glock;
+ 			goto retry;
++>>>>>>> 6d22ff471070 (gfs2: Clean up use of fault_in_iov_iter_{read,write}able)
  		}
  	}
  	if (gfs2_holder_queued(&gh))
@@@ -978,21 -1050,16 +1014,27 @@@ retry_under_glock
  	if (inode == sdp->sd_rindex)
  		gfs2_glock_dq_uninit(statfs_gh);
  
 -	from->count = orig_count - written;
 +	from->count = orig_count - read;
  	if (should_fault_in_pages(ret, from, &prev_count, &window_size)) {
- 		size_t leftover;
- 
  		gfs2_holder_allow_demote(gh);
- 		leftover = fault_in_iov_iter_readable(from, window_size);
+ 		window_size -= fault_in_iov_iter_readable(from, window_size);
  		gfs2_holder_disallow_demote(gh);
++<<<<<<< HEAD
 +		if (leftover != window_size) {
 +			from->count = min(from->count, window_size - leftover);
 +			if (!gfs2_holder_queued(gh)) {
 +				if (read)
 +					goto out_uninit;
 +				goto retry;
 +			}
 +			goto retry_under_glock;
++=======
+ 		if (window_size) {
+ 			from->count = min(from->count, window_size);
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			goto retry;
++>>>>>>> 6d22ff471070 (gfs2: Clean up use of fault_in_iov_iter_{read,write}able)
  		}
  	}
  out_unlock:
* Unmerged path fs/gfs2/file.c
