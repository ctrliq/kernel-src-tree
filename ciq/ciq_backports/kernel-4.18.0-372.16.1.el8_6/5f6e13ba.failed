gfs2: gfs2_inode_lookup rework

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 5f6e13baebf31d71779617b45fbe88ed62f121dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/5f6e13ba.failed

Rework gfs2_inode_lookup() to only set up the new inode's glocks after
verifying that the new inode is valid.

There is no need for flushing the inode glock work queue anymore now,
so remove that as well.

While at it, get rid of the useless wrapper around iget5_locked() and
its unnecessary is_bad_inode() check.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 5f6e13baebf31d71779617b45fbe88ed62f121dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
diff --cc fs/gfs2/inode.c
index 508017f345e1,d73b2933fdb8..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -183,24 -159,31 +161,42 @@@ struct inode *gfs2_inode_lookup(struct 
  			}
  		}
  
++<<<<<<< HEAD
 +		glock_set_object(ip->i_gl, ip);
 +		set_bit(GIF_INVALID, &ip->i_flags);
 +		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);
++=======
+ 		set_bit(GLF_INSTANTIATE_NEEDED, &ip->i_gl->gl_flags);
+ 
+ 		error = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);
++>>>>>>> 5f6e13baebf3 (gfs2: gfs2_inode_lookup rework)
  		if (unlikely(error))
  			goto fail;
- 		glock_set_object(ip->i_iopen_gh.gh_gl, ip);
+ 		if (blktype != GFS2_BLKST_UNLINKED)
+ 			gfs2_cancel_delete_work(io_gl);
+ 		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);
  		gfs2_glock_put(io_gl);
- 		io_gl = NULL;
+ 		if (unlikely(error))
+ 			goto fail;
  
  		/* Lowest possible timestamp; will be overwritten in gfs2_dinode_in. */
  		inode->i_atime.tv_sec = 1LL << (8 * sizeof(inode->i_atime.tv_sec) - 1);
  		inode->i_atime.tv_nsec = 0;
  
+ 		glock_set_object(ip->i_gl, ip);
+ 
  		if (type == DT_UNKNOWN) {
  			/* Inode glock must be locked already */
++<<<<<<< HEAD
 +			error = gfs2_inode_refresh(GFS2_I(inode));
 +			if (error)
++=======
+ 			error = gfs2_instantiate(&i_gh);
+ 			if (error) {
+ 				glock_clear_object(ip->i_gl, ip);
++>>>>>>> 5f6e13baebf3 (gfs2: gfs2_inode_lookup rework)
  				goto fail;
+ 			}
  		} else {
  			ip->i_no_formal_ino = no_formal_ino;
  			inode->i_mode = DT2IF(type);
* Unmerged path fs/gfs2/inode.c
