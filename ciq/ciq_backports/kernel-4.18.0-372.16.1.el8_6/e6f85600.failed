gfs2: split glock instantiation off from do_promote

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.16.1.el8_6
commit-author Bob Peterson <rpeterso@redhat.com>
commit e6f856008d2364a16610d6269b6b38503d5e41a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.16.1.el8_6/e6f85600.failed

Before this patch, function do_promote had a section of code that did
the actual instantiation.  This patch splits that off into its own
function, gfs2_instantiate, which prepares us for the next patch that
will use that function.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit e6f856008d2364a16610d6269b6b38503d5e41a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index ea487d5365d7,75d54ed7e54e..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -488,41 -499,45 +503,71 @@@ static int do_promote(struct gfs2_gloc
  __releases(&gl->gl_lockref.lock)
  __acquires(&gl->gl_lockref.lock)
  {
- 	const struct gfs2_glock_operations *glops = gl->gl_ops;
  	struct gfs2_holder *gh, *tmp, *first_gh;
  	bool incompat_holders_demoted = false;
 -	bool lock_released;
  	int ret;
  
  restart:
  	first_gh = find_first_strong_holder(gl);
  	list_for_each_entry_safe(gh, tmp, &gl->gl_holders, gh_list) {
 -		lock_released = false;
 -		if (test_bit(HIF_HOLDER, &gh->gh_iflags))
 +		if (!test_bit(HIF_WAIT, &gh->gh_iflags))
  			continue;
++<<<<<<< HEAD
 +		if (may_grant(gl, first_gh, gh)) {
 +			if (!incompat_holders_demoted) {
 +				demote_incompat_holders(gl, first_gh);
 +				incompat_holders_demoted = true;
 +				first_gh = gh;
 +			}
 +			if (gh->gh_list.prev == &gl->gl_holders &&
 +			    glops->go_lock) {
 +				if (!(gh->gh_flags & GL_SKIP)) {
 +					spin_unlock(&gl->gl_lockref.lock);
 +					/* FIXME: eliminate this eventually */
 +					ret = glops->go_lock(gh);
 +					spin_lock(&gl->gl_lockref.lock);
 +					if (ret) {
 +						if (ret == 1)
 +							return 2;
 +						gh->gh_error = ret;
 +						list_del_init(&gh->gh_list);
 +						trace_gfs2_glock_queue(gh, 0);
 +						gfs2_holder_wake(gh);
 +						goto restart;
 +					}
 +				}
 +				set_bit(HIF_HOLDER, &gh->gh_iflags);
 +				trace_gfs2_promote(gh);
++=======
+ 		if (!may_grant(gl, first_gh, gh)) {
+ 			/*
+ 			 * If we get here, it means we may not grant this holder for
+ 			 * some reason. If this holder is the head of the list, it
+ 			 * means we have a blocked holder at the head, so return 1.
+ 			 */
+ 			if (gh->gh_list.prev == &gl->gl_holders)
+ 				return 1;
+ 			do_error(gl, 0);
+ 			break;
+ 		}
+ 		if (!incompat_holders_demoted) {
+ 			demote_incompat_holders(gl, first_gh);
+ 			incompat_holders_demoted = true;
+ 			first_gh = gh;
+ 		}
+ 		if (gh->gh_list.prev == &gl->gl_holders &&
+ 		    !(gh->gh_flags & GL_SKIP) && gl->gl_ops->go_instantiate) {
+ 			lock_released = true;
+ 			spin_unlock(&gl->gl_lockref.lock);
+ 			ret = gfs2_instantiate(gh);
+ 			spin_lock(&gl->gl_lockref.lock);
+ 			if (ret) {
+ 				if (ret == 1)
+ 					return 2;
+ 				gh->gh_error = ret;
+ 				list_del_init(&gh->gh_list);
+ 				trace_gfs2_glock_queue(gh, 0);
++>>>>>>> e6f856008d23 (gfs2: split glock instantiation off from do_promote)
  				gfs2_holder_wake(gh);
  				goto restart;
  			}
* Unmerged path fs/gfs2/glock.c
