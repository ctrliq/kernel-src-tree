x86/bugs: Fix BHI handling of RRSBA

jira LE-2015
cve CVE-2024-2201
Rebuild_History Non-Buildable kernel-5.14.0-427.42.1.el9_4
commit-author Josh Poimboeuf <jpoimboe@kernel.org>
commit 1cea8a280dfd1016148a3820676f2f03e3f5b898
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.42.1.el9_4/1cea8a28.failed

The ARCH_CAP_RRSBA check isn't correct: RRSBA may have already been
disabled by the Spectre v2 mitigation (or can otherwise be disabled by
the BHI mitigation itself if needed).  In that case retpolines are fine.

Fixes: ec9404e40e8f ("x86/bhi: Add BHI mitigation knob")
	Signed-off-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Sean Christopherson <seanjc@google.com>
Link: https://lore.kernel.org/r/6f56f13da34a0834b69163467449be7f58f253dc.1712813475.git.jpoimboe@kernel.org
(cherry picked from commit 1cea8a280dfd1016148a3820676f2f03e3f5b898)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index d1c0c8f6898b,08dfb94fcb3a..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -1552,17 -1543,20 +1554,33 @@@ static bool __ro_after_init rrsba_disab
  /* Disable in-kernel use of non-RSB RET predictors */
  static void __init spec_ctrl_disable_kernel_rrsba(void)
  {
++<<<<<<< HEAD
 +	u64 ia32_cap;
++=======
+ 	if (rrsba_disabled)
+ 		return;
+ 
+ 	if (!(x86_arch_cap_msr & ARCH_CAP_RRSBA)) {
+ 		rrsba_disabled = true;
+ 		return;
+ 	}
++>>>>>>> 1cea8a280dfd (x86/bugs: Fix BHI handling of RRSBA)
  
  	if (!boot_cpu_has(X86_FEATURE_RRSBA_CTRL))
  		return;
  
++<<<<<<< HEAD
 +	ia32_cap = x86_read_arch_cap_msr();
 +
 +	if (ia32_cap & ARCH_CAP_RRSBA) {
 +		x86_spec_ctrl_base |= SPEC_CTRL_RRSBA_DIS_S;
 +		update_spec_ctrl(x86_spec_ctrl_base);
 +	}
++=======
+ 	x86_spec_ctrl_base |= SPEC_CTRL_RRSBA_DIS_S;
+ 	update_spec_ctrl(x86_spec_ctrl_base);
+ 	rrsba_disabled = true;
++>>>>>>> 1cea8a280dfd (x86/bugs: Fix BHI handling of RRSBA)
  }
  
  static void __init spectre_v2_determine_rsb_fill_type_at_vmexit(enum spectre_v2_mitigation mode)
@@@ -1612,6 -1606,81 +1630,84 @@@
  	dump_stack();
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Set BHI_DIS_S to prevent indirect branches in kernel to be influenced by
+  * branch history in userspace. Not needed if BHI_NO is set.
+  */
+ static bool __init spec_ctrl_bhi_dis(void)
+ {
+ 	if (!boot_cpu_has(X86_FEATURE_BHI_CTRL))
+ 		return false;
+ 
+ 	x86_spec_ctrl_base |= SPEC_CTRL_BHI_DIS_S;
+ 	update_spec_ctrl(x86_spec_ctrl_base);
+ 	setup_force_cpu_cap(X86_FEATURE_CLEAR_BHB_HW);
+ 
+ 	return true;
+ }
+ 
+ enum bhi_mitigations {
+ 	BHI_MITIGATION_OFF,
+ 	BHI_MITIGATION_ON,
+ 	BHI_MITIGATION_AUTO,
+ };
+ 
+ static enum bhi_mitigations bhi_mitigation __ro_after_init =
+ 	IS_ENABLED(CONFIG_SPECTRE_BHI_ON)  ? BHI_MITIGATION_ON  :
+ 	IS_ENABLED(CONFIG_SPECTRE_BHI_OFF) ? BHI_MITIGATION_OFF :
+ 					     BHI_MITIGATION_AUTO;
+ 
+ static int __init spectre_bhi_parse_cmdline(char *str)
+ {
+ 	if (!str)
+ 		return -EINVAL;
+ 
+ 	if (!strcmp(str, "off"))
+ 		bhi_mitigation = BHI_MITIGATION_OFF;
+ 	else if (!strcmp(str, "on"))
+ 		bhi_mitigation = BHI_MITIGATION_ON;
+ 	else if (!strcmp(str, "auto"))
+ 		bhi_mitigation = BHI_MITIGATION_AUTO;
+ 	else
+ 		pr_err("Ignoring unknown spectre_bhi option (%s)", str);
+ 
+ 	return 0;
+ }
+ early_param("spectre_bhi", spectre_bhi_parse_cmdline);
+ 
+ static void __init bhi_select_mitigation(void)
+ {
+ 	if (bhi_mitigation == BHI_MITIGATION_OFF)
+ 		return;
+ 
+ 	/* Retpoline mitigates against BHI unless the CPU has RRSBA behavior */
+ 	if (cpu_feature_enabled(X86_FEATURE_RETPOLINE)) {
+ 		spec_ctrl_disable_kernel_rrsba();
+ 		if (rrsba_disabled)
+ 			return;
+ 	}
+ 
+ 	if (spec_ctrl_bhi_dis())
+ 		return;
+ 
+ 	if (!IS_ENABLED(CONFIG_X86_64))
+ 		return;
+ 
+ 	/* Mitigate KVM by default */
+ 	setup_force_cpu_cap(X86_FEATURE_CLEAR_BHB_LOOP_ON_VMEXIT);
+ 	pr_info("Spectre BHI mitigation: SW BHB clearing on vm exit\n");
+ 
+ 	if (bhi_mitigation == BHI_MITIGATION_AUTO)
+ 		return;
+ 
+ 	/* Mitigate syscalls when the mitigation is forced =on */
+ 	setup_force_cpu_cap(X86_FEATURE_CLEAR_BHB_LOOP);
+ 	pr_info("Spectre BHI mitigation: SW BHB clearing on syscall\n");
+ }
+ 
++>>>>>>> 1cea8a280dfd (x86/bugs: Fix BHI handling of RRSBA)
  static void __init spectre_v2_select_mitigation(void)
  {
  	enum spectre_v2_mitigation_cmd cmd = spectre_v2_parse_cmdline();
@@@ -2814,6 -2808,22 +2910,25 @@@ static char *pbrsb_eibrs_state(void
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static const char *spectre_bhi_state(void)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_BHI))
+ 		return "; BHI: Not affected";
+ 	else if  (boot_cpu_has(X86_FEATURE_CLEAR_BHB_HW))
+ 		return "; BHI: BHI_DIS_S";
+ 	else if  (boot_cpu_has(X86_FEATURE_CLEAR_BHB_LOOP))
+ 		return "; BHI: SW loop, KVM: SW loop";
+ 	else if (boot_cpu_has(X86_FEATURE_RETPOLINE) && rrsba_disabled)
+ 		return "; BHI: Retpoline";
+ 	else if  (boot_cpu_has(X86_FEATURE_CLEAR_BHB_LOOP_ON_VMEXIT))
+ 		return "; BHI: Syscall hardening, KVM: SW loop";
+ 
+ 	return "; BHI: Vulnerable (Syscall hardening enabled)";
+ }
+ 
++>>>>>>> 1cea8a280dfd (x86/bugs: Fix BHI handling of RRSBA)
  static ssize_t spectre_v2_show_state(char *buf)
  {
  	if (spectre_v2_enabled == SPECTRE_V2_LFENCE)
* Unmerged path arch/x86/kernel/cpu/bugs.c
