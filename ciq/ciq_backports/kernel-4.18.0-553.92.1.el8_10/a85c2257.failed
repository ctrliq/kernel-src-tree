sched/isolation: add cpu_is_isolated() API

jira KERNEL-428
Rebuild_History Non-Buildable kernel-4.18.0-553.92.1.el8_10
commit-author Frederic Weisbecker <frederic@kernel.org>
commit a85c2257a8ac353af16dbcbf32c50d3380860bc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.92.1.el8_10/a85c2257.failed

Patch series "memcg, cpuisol: do not interfere pcp cache charges draining
with cpuisol workloads".

Leonardo has reported [1] that pcp memcg charge draining can interfere
with cpu isolated workloads.  The said draining is done from a WQ context
with a pcp worker scheduled on each CPU which holds any cached charges for
a specific memcg hierarchy.  Operation is not really a common operation
[2].  It can be triggered from the userspace though so some care is
definitely due.

Leonardo has tried to address the issue by allowing remote charge draining
[3].  This approach requires an additional locking to synchronize pcp
caches sync from a remote cpu from local pcp consumers.  Even though the
proposed lock was per-cpu there is still potential for contention and less
predictable behavior.

This patchset addresses the issue from a different angle.  Rather than
dealing with a potential synchronization, cpus which are isolated are
simply never scheduled to be drained.  This means that a small amount of
charges could be laying around and waiting for a later use or they are
flushed when a different memcg is charged from the same cpu.  More details
are in patch 2.  The first patch from Frederic is implementing an
abstraction to tell whether a specific cpu has been isolated and therefore
require a special treatment.


This patch (of 2):

Provide this new API to check if a CPU has been isolated either through
isolcpus= or nohz_full= kernel parameter.

It aims at avoiding kernel load deemed to be safely spared on CPUs running
sensitive workload that can't bear any disturbance, such as pcp cache
draining.

Link: https://lkml.kernel.org/r/20230317134448.11082-1-mhocko@kernel.org
Link: https://lkml.kernel.org/r/20230317134448.11082-2-mhocko@kernel.org
	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Suggested-by: Michal Hocko <mhocko@suse.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: Muchun Song <muchun.song@linux.dev>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Leonardo Bras <leobras@redhat.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit a85c2257a8ac353af16dbcbf32c50d3380860bc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sched/isolation.h
diff --cc include/linux/sched/isolation.h
index cc9f393e2a70,fe1a46f30d24..000000000000
--- a/include/linux/sched/isolation.h
+++ b/include/linux/sched/isolation.h
@@@ -44,7 -45,13 +44,17 @@@ static inline bool housekeeping_enabled
  }
  
  static inline void housekeeping_affine(struct task_struct *t,
++<<<<<<< HEAD
 +				       enum hk_flags flags) { }
++=======
+ 				       enum hk_type type) { }
+ 
+ static inline bool housekeeping_test_cpu(int cpu, enum hk_type type)
+ {
+ 	return true;
+ }
+ 
++>>>>>>> a85c2257a8ac (sched/isolation: add cpu_is_isolated() API)
  static inline void housekeeping_init(void) { }
  #endif /* CONFIG_CPU_ISOLATION */
  
* Unmerged path include/linux/sched/isolation.h
