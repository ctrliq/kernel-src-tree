NFSv4: xattr handlers should check for absent nfs filehandles

jira KERNEL-428
Rebuild_History Non-Buildable kernel-4.18.0-553.92.1.el8_10
commit-author Scott Mayhew <smayhew@redhat.com>
commit 6e9a2f8dbe93c8004c2af2c0158888628b7ca034
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.92.1.el8_10/6e9a2f8d.failed

The nfs inodes for referral anchors that have not yet been followed have
their filehandles zeroed out.

Attempting to call getxattr() on one of these will cause the nfs client
to send a GETATTR to the nfs server with the preceding PUTFH sans
filehandle.  The server will reply NFS4ERR_NOFILEHANDLE, leading to -EIO
being returned to the application.

For example:

$ strace -e trace=getxattr getfattr -n system.nfs4_acl /mnt/t/ref
getxattr("/mnt/t/ref", "system.nfs4_acl", NULL, 0) = -1 EIO (Input/output error)
/mnt/t/ref: system.nfs4_acl: Input/output error
+++ exited with 1 +++

Have the xattr handlers return -ENODATA instead.

	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Signed-off-by: Anna Schumaker <anna.schumaker@oracle.com>
(cherry picked from commit 6e9a2f8dbe93c8004c2af2c0158888628b7ca034)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 0663a8ca3e6f,f837ed7ad90c..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -5977,7 -6211,9 +5977,13 @@@ static ssize_t nfs4_proc_get_acl(struc
  	struct nfs_server *server = NFS_SERVER(inode);
  	int ret;
  
++<<<<<<< HEAD
 +	if (!nfs4_server_supports_acls(server))
++=======
+ 	if (unlikely(NFS_FH(inode)->size == 0))
+ 		return -ENODATA;
+ 	if (!nfs4_server_supports_acls(server, type))
++>>>>>>> 6e9a2f8dbe93 (NFSv4: xattr handlers should check for absent nfs filehandles)
  		return -EOPNOTSUPP;
  	ret = nfs_revalidate_inode(inode, NFS_INO_INVALID_CHANGE);
  	if (ret < 0)
@@@ -6048,8 -6287,11 +6054,11 @@@ static int nfs4_proc_set_acl(struct ino
  {
  	struct nfs4_exception exception = { };
  	int err;
+ 
+ 	if (unlikely(NFS_FH(inode)->size == 0))
+ 		return -ENODATA;
  	do {
 -		err = __nfs4_proc_set_acl(inode, buf, buflen, type);
 +		err = __nfs4_proc_set_acl(inode, buf, buflen);
  		trace_nfs4_set_acl(inode, err);
  		if (err == -NFS4ERR_BADOWNER || err == -NFS4ERR_BADNAME) {
  			/*
* Unmerged path fs/nfs/nfs4proc.c
