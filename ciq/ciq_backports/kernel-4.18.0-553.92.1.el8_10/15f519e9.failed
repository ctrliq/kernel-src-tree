ceph: fix race condition validating r_parent before applying state

jira KERNEL-428
Rebuild_History Non-Buildable kernel-4.18.0-553.92.1.el8_10
Rebuild_CHGLOG: - ceph: fix client race condition validating r_parent before applying state (Alex Markuze) [RHEL-120226]
Rebuild_FUZZ: 94.96%
commit-author Alex Markuze <amarkuze@redhat.com>
commit 15f519e9f883b316d86e2bb6b767a023aafd9d83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.92.1.el8_10/15f519e9.failed

Add validation to ensure the cached parent directory inode matches the
directory info in MDS replies. This prevents client-side race conditions
where concurrent operations (e.g. rename) cause r_parent to become stale
between request initiation and reply processing, which could lead to
applying state changes to incorrect directory inodes.

[ idryomov: folded a kerneldoc fixup and a follow-up fix from Alex to
  move CEPH_CAP_PIN reference when r_parent is updated:

  When the parent directory lock is not held, req->r_parent can become
  stale and is updated to point to the correct inode.  However, the
  associated CEPH_CAP_PIN reference was not being adjusted.  The
  CEPH_CAP_PIN is a reference on an inode that is tracked for
  accounting purposes.  Moving this pin is important to keep the
  accounting balanced. When the pin was not moved from the old parent
  to the new one, it created two problems: The reference on the old,
  stale parent was never released, causing a reference leak.
  A reference for the new parent was never acquired, creating the risk
  of a reference underflow later in ceph_mdsc_release_request().  This
  patch corrects the logic by releasing the pin from the old parent and
  acquiring it for the new parent when r_parent is switched.  This
  ensures reference accounting stays balanced. ]

	Cc: stable@vger.kernel.org
	Signed-off-by: Alex Markuze <amarkuze@redhat.com>
	Reviewed-by: Viacheslav Dubeyko <Slava.Dubeyko@ibm.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 15f519e9f883b316d86e2bb6b767a023aafd9d83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/debugfs.c
#	fs/ceph/dir.c
#	fs/ceph/file.c
#	fs/ceph/inode.c
#	fs/ceph/mds_client.c
#	fs/ceph/mds_client.h
diff --cc fs/ceph/debugfs.c
index fbe0681b835e,f3fe786b4143..000000000000
--- a/fs/ceph/debugfs.c
+++ b/fs/ceph/debugfs.c
@@@ -81,8 -79,8 +79,13 @@@ static int mdsc_show(struct seq_file *s
  		if (req->r_inode) {
  			seq_printf(s, " #%llx", ceph_ino(req->r_inode));
  		} else if (req->r_dentry) {
++<<<<<<< HEAD
 +			path = ceph_mdsc_build_path(req->r_dentry, &pathlen,
 +						    &pathbase, 0);
++=======
+ 			struct ceph_path_info path_info;
+ 			path = ceph_mdsc_build_path(mdsc, req->r_dentry, &path_info, 0);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  			if (IS_ERR(path))
  				path = NULL;
  			spin_lock(&req->r_dentry->d_lock);
@@@ -100,8 -98,8 +103,13 @@@
  		}
  
  		if (req->r_old_dentry) {
++<<<<<<< HEAD
 +			path = ceph_mdsc_build_path(req->r_old_dentry, &pathlen,
 +						    &pathbase, 0);
++=======
+ 			struct ceph_path_info path_info;
+ 			path = ceph_mdsc_build_path(mdsc, req->r_old_dentry, &path_info, 0);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  			if (IS_ERR(path))
  				path = NULL;
  			spin_lock(&req->r_old_dentry->d_lock);
diff --cc fs/ceph/dir.c
index 448a51eb60e5,32973c62c1a2..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -1116,10 -1271,8 +1116,15 @@@ static void ceph_async_unlink_cb(struc
  
  	/* If op failed, mark everyone involved for errors */
  	if (result) {
++<<<<<<< HEAD
 +		int pathlen = 0;
 +		u64 base = 0;
 +		char *path = ceph_mdsc_build_path(dentry, &pathlen,
 +						  &base, 0);
++=======
+ 		struct ceph_path_info path_info = {0};
+ 		char *path = ceph_mdsc_build_path(mdsc, dentry, &path_info, 0);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  
  		/* mark error on parent + clear complete */
  		mapping_set_error(req->r_parent->i_mapping, result);
@@@ -1132,9 -1285,9 +1137,15 @@@
  		/* mark inode itself for an error (since metadata is bogus) */
  		mapping_set_error(req->r_old_inode->i_mapping, result);
  
++<<<<<<< HEAD
 +		pr_warn("async unlink failure path=(%llx)%s result=%d!\n",
 +			base, IS_ERR(path) ? "<<bad>>" : path, result);
 +		ceph_mdsc_free_path(path, pathlen);
++=======
+ 		pr_warn_client(cl, "failure path=(%llx)%s result=%d!\n",
+ 			       path_info.vino.ino, IS_ERR(path) ? "<<bad>>" : path, result);
+ 		ceph_mdsc_free_path_info(&path_info);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	}
  out:
  	iput(req->r_old_inode);
@@@ -1187,8 -1341,10 +1198,12 @@@ static int ceph_unlink(struct inode *di
  	struct inode *inode = d_inode(dentry);
  	struct ceph_mds_request *req;
  	bool try_async = ceph_test_mount_opt(fsc, ASYNC_DIROPS);
 -	struct dentry *dn;
  	int err = -EROFS;
  	int op;
++<<<<<<< HEAD
++=======
+ 	char *path;
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  
  	if (ceph_snap(dir) == CEPH_SNAPDIR) {
  		/* rmdir .snap/foo is RMSNAP */
@@@ -1201,6 -1358,31 +1216,34 @@@
  			CEPH_MDS_OP_RMDIR : CEPH_MDS_OP_UNLINK;
  	} else
  		goto out;
++<<<<<<< HEAD
++=======
+ 
+ 	dn = d_find_alias(dir);
+ 	if (!dn) {
+ 		try_async = false;
+ 	} else {
+ 		struct ceph_path_info path_info;
+ 		path = ceph_mdsc_build_path(mdsc, dn, &path_info, 0);
+ 		if (IS_ERR(path)) {
+ 			try_async = false;
+ 			err = 0;
+ 		} else {
+ 			err = ceph_mds_check_access(mdsc, path, MAY_WRITE);
+ 		}
+ 		ceph_mdsc_free_path_info(&path_info);
+ 		dput(dn);
+ 
+ 		/* For none EACCES cases will let the MDS do the mds auth check */
+ 		if (err == -EACCES) {
+ 			return err;
+ 		} else if (err < 0) {
+ 			try_async = false;
+ 			err = 0;
+ 		}
+ 	}
+ 
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  retry:
  	req = ceph_mdsc_create_request(mdsc, op, USE_AUTH_MDS);
  	if (IS_ERR(req)) {
diff --cc fs/ceph/file.c
index bb6630d2ce0e,978acd3d4b32..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -344,9 -366,13 +344,16 @@@ int ceph_open(struct inode *inode, stru
  	struct ceph_file_info *fi = file->private_data;
  	int err;
  	int flags, fmode, wanted;
++<<<<<<< HEAD
++=======
+ 	struct dentry *dentry;
+ 	char *path;
+ 	bool do_sync = false;
+ 	int mask = MAY_READ;
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  
  	if (fi) {
 -		doutc(cl, "file %p is already opened\n", file);
 +		dout("open file %p is already opened\n", file);
  		return 0;
  	}
  
@@@ -360,6 -391,32 +367,35 @@@
  	fmode = ceph_flags_to_mode(flags);
  	wanted = ceph_caps_for_mode(fmode);
  
++<<<<<<< HEAD
++=======
+ 	if (fmode & CEPH_FILE_MODE_WR)
+ 		mask |= MAY_WRITE;
+ 	dentry = d_find_alias(inode);
+ 	if (!dentry) {
+ 		do_sync = true;
+ 	} else {
+ 		struct ceph_path_info path_info;
+ 		path = ceph_mdsc_build_path(mdsc, dentry, &path_info, 0);
+ 		if (IS_ERR(path)) {
+ 			do_sync = true;
+ 			err = 0;
+ 		} else {
+ 			err = ceph_mds_check_access(mdsc, path, mask);
+ 		}
+ 		ceph_mdsc_free_path_info(&path_info);
+ 		dput(dentry);
+ 
+ 		/* For none EACCES cases will let the MDS do the mds auth check */
+ 		if (err == -EACCES) {
+ 			return err;
+ 		} else if (err < 0) {
+ 			do_sync = true;
+ 			err = 0;
+ 		}
+ 	}
+ 
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	/* snapped files are read-only */
  	if (ceph_snap(inode) != CEPH_NOSNAP && (file->f_mode & FMODE_WRITE))
  		return -EROFS;
@@@ -524,13 -613,14 +560,24 @@@ static void ceph_async_create_cb(struc
  	mapping_set_error(req->r_parent->i_mapping, result);
  
  	if (result) {
++<<<<<<< HEAD
 +		struct dentry *dentry = req->r_dentry;
 +		struct inode *inode = d_inode(dentry);
 +		int pathlen = 0;
 +		u64 base = 0;
 +		char *path = ceph_mdsc_build_path(req->r_dentry, &pathlen,
 +						  &base, 0);
 +
++=======
+ 		struct ceph_path_info path_info = {0};
+ 		char *path = ceph_mdsc_build_path(mdsc, req->r_dentry, &path_info, 0);
+ 
+ 		pr_warn_client(cl,
+ 			"async create failure path=(%llx)%s result=%d!\n",
+ 			path_info.vino.ino, IS_ERR(path) ? "<<bad>>" : path, result);
+ 		ceph_mdsc_free_path_info(&path_info);
+ 
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  		ceph_dir_clear_complete(req->r_parent);
  		if (!d_unhashed(dentry))
  			d_drop(dentry);
@@@ -696,10 -787,11 +743,14 @@@ int ceph_atomic_open(struct inode *dir
  	bool try_async = ceph_test_mount_opt(fsc, ASYNC_DIROPS);
  	int mask;
  	int err;
++<<<<<<< HEAD
++=======
+ 	char *path;
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  
 -	doutc(cl, "%p %llx.%llx dentry %p '%pd' %s flags %d mode 0%o\n",
 -	      dir, ceph_vinop(dir), dentry, dentry,
 -	      d_unhashed(dentry) ? "unhashed" : "hashed", flags, mode);
 +	dout("atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\n",
 +	     dir, dentry, dentry,
 +	     d_unhashed(dentry) ? "unhashed" : "hashed", flags, mode);
  
  	if (dentry->d_name.len > NAME_MAX)
  		return -ENAMETOOLONG;
@@@ -713,6 -805,36 +764,39 @@@
  	 */
  	flags &= ~O_TRUNC;
  
++<<<<<<< HEAD
++=======
+ 	dn = d_find_alias(dir);
+ 	if (!dn) {
+ 		try_async = false;
+ 	} else {
+ 		struct ceph_path_info path_info;
+ 		path = ceph_mdsc_build_path(mdsc, dn, &path_info, 0);
+ 		if (IS_ERR(path)) {
+ 			try_async = false;
+ 			err = 0;
+ 		} else {
+ 			int fmode = ceph_flags_to_mode(flags);
+ 
+ 			mask = MAY_READ;
+ 			if (fmode & CEPH_FILE_MODE_WR)
+ 				mask |= MAY_WRITE;
+ 			err = ceph_mds_check_access(mdsc, path, mask);
+ 		}
+ 		ceph_mdsc_free_path_info(&path_info);
+ 		dput(dn);
+ 
+ 		/* For none EACCES cases will let the MDS do the mds auth check */
+ 		if (err == -EACCES) {
+ 			return err;
+ 		} else if (err < 0) {
+ 			try_async = false;
+ 			err = 0;
+ 		}
+ 	}
+ 
+ retry:
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	if (flags & O_CREAT) {
  		if (ceph_quota_is_max_files_exceeded(dir))
  			return -EDQUOT;
diff --cc fs/ceph/inode.c
index 696abab74f09,8ac89ce6435c..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -2005,7 -2483,37 +2005,41 @@@ int __ceph_setattr(struct inode *inode
  	int err = 0;
  	int inode_dirty_flags = 0;
  	bool lock_snap_rwsem = false;
++<<<<<<< HEAD
++
++=======
+ 	bool fill_fscrypt;
+ 	int truncate_retry = 20; /* The RMW will take around 50ms */
+ 	struct dentry *dentry;
+ 	char *path;
+ 	bool do_sync = false;
+ 
+ 	dentry = d_find_alias(inode);
+ 	if (!dentry) {
+ 		do_sync = true;
+ 	} else {
+ 		struct ceph_path_info path_info;
+ 		path = ceph_mdsc_build_path(mdsc, dentry, &path_info, 0);
+ 		if (IS_ERR(path)) {
+ 			do_sync = true;
+ 			err = 0;
+ 		} else {
+ 			err = ceph_mds_check_access(mdsc, path, MAY_WRITE);
+ 		}
+ 		ceph_mdsc_free_path_info(&path_info);
+ 		dput(dentry);
+ 
+ 		/* For none EACCES cases will let the MDS do the mds auth check */
+ 		if (err == -EACCES) {
+ 			return err;
+ 		} else if (err < 0) {
+ 			do_sync = true;
+ 			err = 0;
+ 		}
+ 	}
  
+ retry:
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	prealloc_cf = ceph_alloc_cap_flush();
  	if (!prealloc_cf)
  		return -ENOMEM;
diff --cc fs/ceph/mds_client.c
index d1ac6368a47f,3bc72b47fe4d..000000000000
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@@ -2386,20 -2616,94 +2386,95 @@@ static inline  u64 __get_oldest_tid(str
  	return mdsc->oldest_tid;
  }
  
++<<<<<<< HEAD
 +/*
 + * Build a dentry's path.  Allocate on heap; caller must kfree.  Based
 + * on build_path_from_dentry in fs/cifs/dir.c.
++=======
+ #if IS_ENABLED(CONFIG_FS_ENCRYPTION)
+ static u8 *get_fscrypt_altname(const struct ceph_mds_request *req, u32 *plen)
+ {
+ 	struct inode *dir = req->r_parent;
+ 	struct dentry *dentry = req->r_dentry;
+ 	const struct qstr *name = req->r_dname;
+ 	u8 *cryptbuf = NULL;
+ 	u32 len = 0;
+ 	int ret = 0;
+ 
+ 	/* only encode if we have parent and dentry */
+ 	if (!dir || !dentry)
+ 		goto success;
+ 
+ 	/* No-op unless this is encrypted */
+ 	if (!IS_ENCRYPTED(dir))
+ 		goto success;
+ 
+ 	ret = ceph_fscrypt_prepare_readdir(dir);
+ 	if (ret < 0)
+ 		return ERR_PTR(ret);
+ 
+ 	/* No key? Just ignore it. */
+ 	if (!fscrypt_has_encryption_key(dir))
+ 		goto success;
+ 
+ 	if (!name)
+ 		name = &dentry->d_name;
+ 
+ 	if (!fscrypt_fname_encrypted_size(dir, name->len, NAME_MAX, &len)) {
+ 		WARN_ON_ONCE(1);
+ 		return ERR_PTR(-ENAMETOOLONG);
+ 	}
+ 
+ 	/* No need to append altname if name is short enough */
+ 	if (len <= CEPH_NOHASH_NAME_MAX) {
+ 		len = 0;
+ 		goto success;
+ 	}
+ 
+ 	cryptbuf = kmalloc(len, GFP_KERNEL);
+ 	if (!cryptbuf)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	ret = fscrypt_fname_encrypt(dir, name, cryptbuf, len);
+ 	if (ret) {
+ 		kfree(cryptbuf);
+ 		return ERR_PTR(ret);
+ 	}
+ success:
+ 	*plen = len;
+ 	return cryptbuf;
+ }
+ #else
+ static u8 *get_fscrypt_altname(const struct ceph_mds_request *req, u32 *plen)
+ {
+ 	*plen = 0;
+ 	return NULL;
+ }
+ #endif
+ 
+ /**
+  * ceph_mdsc_build_path - build a path string to a given dentry
+  * @mdsc: mds client
+  * @dentry: dentry to which path should be built
+  * @path_info: output path, length, base ino+snap, and freepath ownership flag
+  * @for_wire: is this path going to be sent to the MDS?
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
   *
 - * Build a string that represents the path to the dentry. This is mostly called
 - * for two different purposes:
 - *
 - * 1) we need to build a path string to send to the MDS (for_wire == true)
 - * 2) we need a path string for local presentation (e.g. debugfs)
 - *    (for_wire == false)
 - *
 - * The path is built in reverse, starting with the dentry. Walk back up toward
 - * the root, building the path until the first non-snapped inode is reached
 - * (for_wire) or the root inode is reached (!for_wire).
 + * If @stop_on_nosnap, generate path relative to the first non-snapped
 + * inode.
   *
   * Encode hidden .snap dirs as a double /, i.e.
   *   foo/.snap/bar -> foo//bar
   */
++<<<<<<< HEAD
 +char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *pbase,
 +			   int stop_on_nosnap)
++=======
+ char *ceph_mdsc_build_path(struct ceph_mds_client *mdsc, struct dentry *dentry,
+ 			   struct ceph_path_info *path_info, int for_wire)
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  {
 -	struct ceph_client *cl = mdsc->fsc->client;
 -	struct dentry *cur;
 -	struct inode *inode;
 +	struct dentry *temp;
  	char *path;
  	int pos;
  	unsigned seq;
@@@ -2460,50 -2802,64 +2535,86 @@@ retry
  
  	if (pos < 0) {
  		/*
 -		 * The path is longer than PATH_MAX and this function
 -		 * cannot ever succeed.  Creating paths that long is
 -		 * possible with Ceph, but Linux cannot use them.
 +		 * A rename didn't occur, but somehow we didn't end up where
 +		 * we thought we would. Throw a warning and try again.
  		 */
 -		return ERR_PTR(-ENAMETOOLONG);
 +		pr_warn("build_path did not end path lookup where "
 +			"expected, pos is %d\n", pos);
 +		goto retry;
  	}
  
++<<<<<<< HEAD
 +	*pbase = base;
 +	*plen = PATH_MAX - 1 - pos;
 +	dout("build_path on %p %d built %llx '%.*s'\n",
 +	     dentry, d_count(dentry), base, *plen, path + pos);
 +	return path + pos;
 +}
 +
 +static int build_dentry_path(struct dentry *dentry, struct inode *dir,
 +			     const char **ppath, int *ppathlen, u64 *pino,
 +			     bool *pfreepath, bool parent_locked)
++=======
+ 	/* Initialize the output structure */
+ 	memset(path_info, 0, sizeof(*path_info));
+ 
+ 	path_info->vino.ino = base;
+ 	path_info->pathlen = PATH_MAX - 1 - pos;
+ 	path_info->path = path + pos;
+ 	path_info->freepath = true;
+ 
+ 	/* Set snap from dentry if available */
+ 	if (d_inode(dentry))
+ 		path_info->vino.snap = ceph_snap(d_inode(dentry));
+ 	else
+ 		path_info->vino.snap = CEPH_NOSNAP;
+ 
+ 	doutc(cl, "on %p %d built %llx '%.*s'\n", dentry, d_count(dentry),
+ 	      base, PATH_MAX - 1 - pos, path + pos);
+ 	return path + pos;
+ }
+ 
+ static int build_dentry_path(struct ceph_mds_client *mdsc, struct dentry *dentry,
+ 			     struct inode *dir, struct ceph_path_info *path_info,
+ 			     bool parent_locked)
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  {
  	char *path;
  
  	rcu_read_lock();
  	if (!dir)
  		dir = d_inode_rcu(dentry->d_parent);
++<<<<<<< HEAD
 +	if (dir && parent_locked && ceph_snap(dir) == CEPH_NOSNAP) {
 +		*pino = ceph_ino(dir);
++=======
+ 	if (dir && parent_locked && ceph_snap(dir) == CEPH_NOSNAP &&
+ 	    !IS_ENCRYPTED(dir)) {
+ 		path_info->vino.ino = ceph_ino(dir);
+ 		path_info->vino.snap = ceph_snap(dir);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  		rcu_read_unlock();
- 		*ppath = dentry->d_name.name;
- 		*ppathlen = dentry->d_name.len;
+ 		path_info->path = dentry->d_name.name;
+ 		path_info->pathlen = dentry->d_name.len;
+ 		path_info->freepath = false;
  		return 0;
  	}
  	rcu_read_unlock();
++<<<<<<< HEAD
 +	path = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);
++=======
+ 	path = ceph_mdsc_build_path(mdsc, dentry, path_info, 1);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	if (IS_ERR(path))
  		return PTR_ERR(path);
- 	*ppath = path;
- 	*pfreepath = true;
+ 	/*
+ 	 * ceph_mdsc_build_path already fills path_info, including snap handling.
+ 	 */
  	return 0;
  }
  
- static int build_inode_path(struct inode *inode,
- 			    const char **ppath, int *ppathlen, u64 *pino,
- 			    bool *pfreepath)
+ static int build_inode_path(struct inode *inode, struct ceph_path_info *path_info)
  {
 -	struct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);
  	struct dentry *dentry;
  	char *path;
  
@@@ -2513,7 -2871,7 +2626,11 @@@
  		return 0;
  	}
  	dentry = d_find_alias(inode);
++<<<<<<< HEAD
 +	path = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);
++=======
+ 	path = ceph_mdsc_build_path(mdsc, dentry, path_info, 1);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	dput(dentry);
  	if (IS_ERR(path))
  		return PTR_ERR(path);
@@@ -2526,27 -2887,34 +2646,56 @@@
   * request arguments may be specified via an inode *, a dentry *, or
   * an explicit ino+path.
   */
++<<<<<<< HEAD
 +static int set_request_path_attr(struct inode *rinode, struct dentry *rdentry,
 +				  struct inode *rdiri, const char *rpath,
 +				  u64 rino, const char **ppath, int *pathlen,
 +				  u64 *ino, bool *freepath, bool parent_locked)
++=======
+ static int set_request_path_attr(struct ceph_mds_client *mdsc, struct inode *rinode,
+ 				 struct dentry *rdentry, struct inode *rdiri,
+ 				 const char *rpath, u64 rino,
+ 				 struct ceph_path_info *path_info,
+ 				 bool parent_locked)
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  {
 -	struct ceph_client *cl = mdsc->fsc->client;
  	int r = 0;
  
+ 	/* Initialize the output structure */
+ 	memset(path_info, 0, sizeof(*path_info));
+ 
  	if (rinode) {
++<<<<<<< HEAD
 +		r = build_inode_path(rinode, ppath, pathlen, ino, freepath);
 +		dout(" inode %p %llx.%llx\n", rinode, ceph_ino(rinode),
 +		     ceph_snap(rinode));
 +	} else if (rdentry) {
 +		r = build_dentry_path(rdentry, rdiri, ppath, pathlen, ino,
 +					freepath, parent_locked);
 +		dout(" dentry %p %llx/%.*s\n", rdentry, *ino, *pathlen,
 +		     *ppath);
 +	} else if (rpath || rino) {
 +		*ino = rino;
 +		*ppath = rpath;
 +		*pathlen = rpath ? strlen(rpath) : 0;
 +		dout(" path %.*s\n", *pathlen, rpath);
++=======
+ 		r = build_inode_path(rinode, path_info);
+ 		doutc(cl, " inode %p %llx.%llx\n", rinode, ceph_ino(rinode),
+ 		      ceph_snap(rinode));
+ 	} else if (rdentry) {
+ 		r = build_dentry_path(mdsc, rdentry, rdiri, path_info, parent_locked);
+ 		doutc(cl, " dentry %p %llx/%.*s\n", rdentry, path_info->vino.ino,
+ 		      path_info->pathlen, path_info->path);
+ 	} else if (rpath || rino) {
+ 		path_info->vino.ino = rino;
+ 		path_info->vino.snap = CEPH_NOSNAP;
+ 		path_info->path = rpath;
+ 		path_info->pathlen = rpath ? strlen(rpath) : 0;
+ 		path_info->freepath = false;
+ 
+ 		doutc(cl, " path %.*s\n", path_info->pathlen, rpath);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	}
  
  	return r;
@@@ -2577,25 -2988,25 +2726,42 @@@ static struct ceph_msg *create_request_
  {
  	int mds = session->s_mds;
  	struct ceph_mds_client *mdsc = session->s_mdsc;
 -	struct ceph_client *cl = mdsc->fsc->client;
  	struct ceph_msg *msg;
++<<<<<<< HEAD
 +	struct ceph_mds_request_head_old *head;
 +	const char *path1 = NULL;
 +	const char *path2 = NULL;
 +	u64 ino1 = 0, ino2 = 0;
 +	int pathlen1 = 0, pathlen2 = 0;
 +	bool freepath1 = false, freepath2 = false;
++=======
+ 	struct ceph_mds_request_head_legacy *lhead;
+ 	struct ceph_path_info path_info1 = {0};
+ 	struct ceph_path_info path_info2 = {0};
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	struct dentry *old_dentry = NULL;
  	int len;
  	u16 releases;
  	void *p, *end;
  	int ret;
  	bool legacy = !(session->s_con.peer_features & CEPH_FEATURE_FS_BTIME);
++<<<<<<< HEAD
 +
 +	ret = set_request_path_attr(req->r_inode, req->r_dentry,
 +			      req->r_parent, req->r_path1, req->r_ino1.ino,
 +			      &path1, &pathlen1, &ino1, &freepath1,
 +			      test_bit(CEPH_MDS_R_PARENT_LOCKED,
 +					&req->r_req_flags));
++=======
+ 	u16 request_head_version = mds_supported_head_version(session);
+ 	kuid_t caller_fsuid = req->r_cred->fsuid;
+ 	kgid_t caller_fsgid = req->r_cred->fsgid;
+ 	bool parent_locked = test_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);
+ 
+ 	ret = set_request_path_attr(mdsc, req->r_inode, req->r_dentry,
+ 				    req->r_parent, req->r_path1, req->r_ino1.ino,
+ 				    &path_info1, parent_locked);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	if (ret < 0) {
  		msg = ERR_PTR(ret);
  		goto out;
@@@ -2605,30 -3041,73 +2796,61 @@@
  	if (req->r_old_dentry &&
  	    !(req->r_old_dentry->d_flags & DCACHE_DISCONNECTED))
  		old_dentry = req->r_old_dentry;
++<<<<<<< HEAD
 +	ret = set_request_path_attr(NULL, old_dentry,
 +			      req->r_old_dentry_dir,
 +			      req->r_path2, req->r_ino2.ino,
 +			      &path2, &pathlen2, &ino2, &freepath2, true);
++=======
+ 	ret = set_request_path_attr(mdsc, NULL, old_dentry,
+ 				    req->r_old_dentry_dir,
+ 				    req->r_path2, req->r_ino2.ino,
+ 				    &path_info2, true);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	if (ret < 0) {
  		msg = ERR_PTR(ret);
  		goto out_free1;
  	}
  
 -	req->r_altname = get_fscrypt_altname(req, &req->r_altname_len);
 -	if (IS_ERR(req->r_altname)) {
 -		msg = ERR_CAST(req->r_altname);
 -		req->r_altname = NULL;
 -		goto out_free2;
 -	}
 +	len = legacy ? sizeof(*head) : sizeof(struct ceph_mds_request_head);
 +	len += pathlen1 + pathlen2 + 2*(1 + sizeof(u32) + sizeof(u64)) +
 +		sizeof(struct ceph_timespec);
 +	len += sizeof(u32) + (sizeof(u64) * req->r_cred->group_info->ngroups);
  
++<<<<<<< HEAD
 +	/* calculate (max) length for cap releases */
++=======
+ 	/*
+ 	 * For old cephs without supporting the 32bit retry/fwd feature
+ 	 * it will copy the raw memories directly when decoding the
+ 	 * requests. While new cephs will decode the head depending the
+ 	 * version member, so we need to make sure it will be compatible
+ 	 * with them both.
+ 	 */
+ 	if (legacy)
+ 		len = sizeof(struct ceph_mds_request_head_legacy);
+ 	else if (request_head_version == 1)
+ 		len = offsetofend(struct ceph_mds_request_head, args);
+ 	else if (request_head_version == 2)
+ 		len = offsetofend(struct ceph_mds_request_head, ext_num_fwd);
+ 	else
+ 		len = sizeof(struct ceph_mds_request_head);
+ 
+ 	/* filepaths */
+ 	len += 2 * (1 + sizeof(u32) + sizeof(u64));
+ 	len += path_info1.pathlen + path_info2.pathlen;
+ 
+ 	/* cap releases */
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  	len += sizeof(struct ceph_mds_request_release) *
  		(!!req->r_inode_drop + !!req->r_dentry_drop +
  		 !!req->r_old_inode_drop + !!req->r_old_dentry_drop);
  
  	if (req->r_dentry_drop)
- 		len += pathlen1;
+ 		len += path_info1.pathlen;
  	if (req->r_old_dentry_drop)
- 		len += pathlen2;
+ 		len += path_info2.pathlen;
  
 -	/* MClientRequest tail */
 -
 -	/* req->r_stamp */
 -	len += sizeof(struct ceph_timespec);
 -
 -	/* gid list */
 -	len += sizeof(u32) + (sizeof(u64) * req->r_cred->group_info->ngroups);
 -
 -	/* alternate name */
 -	len += sizeof(u32) + req->r_altname_len;
 -
 -	/* fscrypt_auth */
 -	len += sizeof(u32); // fscrypt_auth
 -	if (req->r_fscrypt_auth)
 -		len += ceph_fscrypt_auth_len(req->r_fscrypt_auth);
 -
 -	/* fscrypt_file */
 -	len += sizeof(u32);
 -	if (test_bit(CEPH_MDS_R_FSCRYPT_FILE, &req->r_req_flags))
 -		len += sizeof(__le64);
 -
  	msg = ceph_msg_new2(CEPH_MSG_CLIENT_REQUEST, len, 1, GFP_NOFS, false);
  	if (!msg) {
  		msg = ERR_PTR(-ENOMEM);
@@@ -2656,17 -3189,17 +2878,17 @@@
  
  	end = msg->front.iov_base + msg->front.iov_len;
  
 -	lhead->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);
 -	lhead->op = cpu_to_le32(req->r_op);
 -	lhead->caller_uid = cpu_to_le32(from_kuid(&init_user_ns,
 -						  caller_fsuid));
 -	lhead->caller_gid = cpu_to_le32(from_kgid(&init_user_ns,
 -						  caller_fsgid));
 -	lhead->ino = cpu_to_le64(req->r_deleg_ino);
 -	lhead->args = req->r_args;
 +	head->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);
 +	head->op = cpu_to_le32(req->r_op);
 +	head->caller_uid = cpu_to_le32(from_kuid(&init_user_ns,
 +						 req->r_cred->fsuid));
 +	head->caller_gid = cpu_to_le32(from_kgid(&init_user_ns,
 +						 req->r_cred->fsgid));
 +	head->ino = cpu_to_le64(req->r_deleg_ino);
 +	head->args = req->r_args;
  
- 	ceph_encode_filepath(&p, end, ino1, path1);
- 	ceph_encode_filepath(&p, end, ino2, path2);
+ 	ceph_encode_filepath(&p, end, path_info1.vino.ino, path_info1.path);
+ 	ceph_encode_filepath(&p, end, path_info2.vino.ino, path_info2.path);
  
  	/* make note of release offset, in case we need to replay */
  	req->r_request_release_offset = p - msg->front.iov_base;
@@@ -2721,13 -3262,15 +2943,11 @@@
  	msg->hdr.data_off = cpu_to_le16(0);
  
  out_free2:
- 	if (freepath2)
- 		ceph_mdsc_free_path((char *)path2, pathlen2);
+ 	ceph_mdsc_free_path_info(&path_info2);
  out_free1:
- 	if (freepath1)
- 		ceph_mdsc_free_path((char *)path1, pathlen1);
+ 	ceph_mdsc_free_path_info(&path_info1);
  out:
  	return msg;
 -out_err:
 -	ceph_msg_put(msg);
 -	msg = ERR_PTR(ret);
 -	goto out_free2;
  }
  
  /*
@@@ -3930,7 -4628,7 +4149,11 @@@ static int reconnect_caps_cb(struct ino
  	dentry = d_find_primary(inode);
  	if (dentry) {
  		/* set pathbase to parent dir when msg_version >= 2 */
++<<<<<<< HEAD
 +		path = ceph_mdsc_build_path(dentry, &pathlen, &pathbase,
++=======
+ 		char *path = ceph_mdsc_build_path(mdsc, dentry, &path_info,
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  					    recon_state->msg_version >= 2);
  		dput(dentry);
  		if (IS_ERR(path)) {
@@@ -3980,10 -4677,12 +4200,10 @@@
  		rec.v1.wanted = cpu_to_le32(__ceph_caps_wanted(ci));
  		rec.v1.issued = cpu_to_le32(cap->issued);
  		rec.v1.size = cpu_to_le64(i_size_read(inode));
 -		ts = inode_get_mtime(inode);
 -		ceph_encode_timespec64(&rec.v1.mtime, &ts);
 -		ts = inode_get_atime(inode);
 -		ceph_encode_timespec64(&rec.v1.atime, &ts);
 +		ceph_encode_timespec64(&rec.v1.mtime, &inode->i_mtime);
 +		ceph_encode_timespec64(&rec.v1.atime, &inode->i_atime);
  		rec.v1.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);
- 		rec.v1.pathbase = cpu_to_le64(pathbase);
+ 		rec.v1.pathbase = cpu_to_le64(path_info.vino.ino);
  	}
  
  	if (list_empty(&ci->i_cap_snaps)) {
diff --cc fs/ceph/mds_client.h
index b79bc8576f4f,0428a5eaf28c..000000000000
--- a/fs/ceph/mds_client.h
+++ b/fs/ceph/mds_client.h
@@@ -537,16 -612,30 +537,32 @@@ extern void ceph_queue_cap_unlink_work(
  extern int ceph_iterate_session_caps(struct ceph_mds_session *session,
  				     int (*cb)(struct inode *, int mds, void *),
  				     void *arg);
 -extern int ceph_mds_check_access(struct ceph_mds_client *mdsc, char *tpath,
 -				 int mask);
 -
  extern void ceph_mdsc_pre_umount(struct ceph_mds_client *mdsc);
  
- static inline void ceph_mdsc_free_path(char *path, int len)
+ /*
+  * Structure to group path-related output parameters for build_*_path functions
+  */
+ struct ceph_path_info {
+ 	const char *path;
+ 	int pathlen;
+ 	struct ceph_vino vino;
+ 	bool freepath;
+ };
+ 
+ static inline void ceph_mdsc_free_path_info(const struct ceph_path_info *path_info)
  {
- 	if (!IS_ERR_OR_NULL(path))
- 		__putname(path - (PATH_MAX - 1 - len));
+ 	if (path_info && path_info->freepath && !IS_ERR_OR_NULL(path_info->path))
+ 		__putname((char *)path_info->path - (PATH_MAX - 1 - path_info->pathlen));
  }
  
++<<<<<<< HEAD
 +extern char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,
 +				  int stop_on_nosnap);
++=======
+ extern char *ceph_mdsc_build_path(struct ceph_mds_client *mdsc,
+ 				  struct dentry *dentry, struct ceph_path_info *path_info,
+ 				  int for_wire);
++>>>>>>> 15f519e9f883 (ceph: fix race condition validating r_parent before applying state)
  
  extern void __ceph_mdsc_drop_dentry_lease(struct dentry *dentry);
  extern void ceph_mdsc_lease_send_msg(struct ceph_mds_session *session,
* Unmerged path fs/ceph/debugfs.c
* Unmerged path fs/ceph/dir.c
* Unmerged path fs/ceph/file.c
* Unmerged path fs/ceph/inode.c
* Unmerged path fs/ceph/mds_client.c
* Unmerged path fs/ceph/mds_client.h
