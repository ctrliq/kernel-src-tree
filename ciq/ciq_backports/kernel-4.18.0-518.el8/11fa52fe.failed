cpufreq: amd-pstate: Make varaiable mode_state_machine static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Tom Rix <trix@redhat.com>
commit 11fa52fe619acfa945712d94a0bc27c0f5bc49de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/11fa52fe.failed

smatch reports
drivers/cpufreq/amd-pstate.c:907:25: warning: symbol
  'mode_state_machine' was not declared. Should it be static?

This variable is only used in one file so it should be static.

	Signed-off-by: Tom Rix <trix@redhat.com>
	Reviewed-by: Wyes Karny <wyes.karny@amd.com>
	Tested-by: Wyes Karny <wyes.karny@amd.com>
	Reviewed-by: Dhruva Gole <d-gole@ti.com>
[ rjw: Subject edits ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 11fa52fe619acfa945712d94a0bc27c0f5bc49de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/amd-pstate.c
diff --cc drivers/cpufreq/amd-pstate.c
index 2c71ef90154d,fcb54a6f6598..000000000000
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@@ -650,6 -791,198 +650,201 @@@ static ssize_t show_amd_pstate_highest_
  	return sysfs_emit(buf, "%u\n", perf);
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t show_energy_performance_available_preferences(
+ 				struct cpufreq_policy *policy, char *buf)
+ {
+ 	int i = 0;
+ 	int offset = 0;
+ 
+ 	while (energy_perf_strings[i] != NULL)
+ 		offset += sysfs_emit_at(buf, offset, "%s ", energy_perf_strings[i++]);
+ 
+ 	sysfs_emit_at(buf, offset, "\n");
+ 
+ 	return offset;
+ }
+ 
+ static ssize_t store_energy_performance_preference(
+ 		struct cpufreq_policy *policy, const char *buf, size_t count)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	char str_preference[21];
+ 	ssize_t ret;
+ 
+ 	ret = sscanf(buf, "%20s", str_preference);
+ 	if (ret != 1)
+ 		return -EINVAL;
+ 
+ 	ret = match_string(energy_perf_strings, -1, str_preference);
+ 	if (ret < 0)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&amd_pstate_limits_lock);
+ 	ret = amd_pstate_set_energy_pref_index(cpudata, ret);
+ 	mutex_unlock(&amd_pstate_limits_lock);
+ 
+ 	return ret ?: count;
+ }
+ 
+ static ssize_t show_energy_performance_preference(
+ 				struct cpufreq_policy *policy, char *buf)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	int preference;
+ 
+ 	preference = amd_pstate_get_energy_pref_index(cpudata);
+ 	if (preference < 0)
+ 		return preference;
+ 
+ 	return sysfs_emit(buf, "%s\n", energy_perf_strings[preference]);
+ }
+ 
+ static void amd_pstate_driver_cleanup(void)
+ {
+ 	amd_pstate_enable(false);
+ 	cppc_state = AMD_PSTATE_DISABLE;
+ 	current_pstate_driver = NULL;
+ }
+ 
+ static int amd_pstate_register_driver(int mode)
+ {
+ 	int ret;
+ 
+ 	if (mode == AMD_PSTATE_PASSIVE || mode == AMD_PSTATE_GUIDED)
+ 		current_pstate_driver = &amd_pstate_driver;
+ 	else if (mode == AMD_PSTATE_ACTIVE)
+ 		current_pstate_driver = &amd_pstate_epp_driver;
+ 	else
+ 		return -EINVAL;
+ 
+ 	cppc_state = mode;
+ 	ret = cpufreq_register_driver(current_pstate_driver);
+ 	if (ret) {
+ 		amd_pstate_driver_cleanup();
+ 		return ret;
+ 	}
+ 	return 0;
+ }
+ 
+ static int amd_pstate_unregister_driver(int dummy)
+ {
+ 	cpufreq_unregister_driver(current_pstate_driver);
+ 	amd_pstate_driver_cleanup();
+ 	return 0;
+ }
+ 
+ static int amd_pstate_change_mode_without_dvr_change(int mode)
+ {
+ 	int cpu = 0;
+ 
+ 	cppc_state = mode;
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC) || cppc_state == AMD_PSTATE_ACTIVE)
+ 		return 0;
+ 
+ 	for_each_present_cpu(cpu) {
+ 		cppc_set_auto_sel(cpu, (cppc_state == AMD_PSTATE_PASSIVE) ? 0 : 1);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_change_driver_mode(int mode)
+ {
+ 	int ret;
+ 
+ 	ret = amd_pstate_unregister_driver(0);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = amd_pstate_register_driver(mode);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ 
+ static cppc_mode_transition_fn mode_state_machine[AMD_PSTATE_MAX][AMD_PSTATE_MAX] = {
+ 	[AMD_PSTATE_DISABLE]         = {
+ 		[AMD_PSTATE_DISABLE]     = NULL,
+ 		[AMD_PSTATE_PASSIVE]     = amd_pstate_register_driver,
+ 		[AMD_PSTATE_ACTIVE]      = amd_pstate_register_driver,
+ 		[AMD_PSTATE_GUIDED]      = amd_pstate_register_driver,
+ 	},
+ 	[AMD_PSTATE_PASSIVE]         = {
+ 		[AMD_PSTATE_DISABLE]     = amd_pstate_unregister_driver,
+ 		[AMD_PSTATE_PASSIVE]     = NULL,
+ 		[AMD_PSTATE_ACTIVE]      = amd_pstate_change_driver_mode,
+ 		[AMD_PSTATE_GUIDED]      = amd_pstate_change_mode_without_dvr_change,
+ 	},
+ 	[AMD_PSTATE_ACTIVE]          = {
+ 		[AMD_PSTATE_DISABLE]     = amd_pstate_unregister_driver,
+ 		[AMD_PSTATE_PASSIVE]     = amd_pstate_change_driver_mode,
+ 		[AMD_PSTATE_ACTIVE]      = NULL,
+ 		[AMD_PSTATE_GUIDED]      = amd_pstate_change_driver_mode,
+ 	},
+ 	[AMD_PSTATE_GUIDED]          = {
+ 		[AMD_PSTATE_DISABLE]     = amd_pstate_unregister_driver,
+ 		[AMD_PSTATE_PASSIVE]     = amd_pstate_change_mode_without_dvr_change,
+ 		[AMD_PSTATE_ACTIVE]      = amd_pstate_change_driver_mode,
+ 		[AMD_PSTATE_GUIDED]      = NULL,
+ 	},
+ };
+ 
+ static ssize_t amd_pstate_show_status(char *buf)
+ {
+ 	if (!current_pstate_driver)
+ 		return sysfs_emit(buf, "disable\n");
+ 
+ 	return sysfs_emit(buf, "%s\n", amd_pstate_mode_string[cppc_state]);
+ }
+ 
+ static int amd_pstate_update_status(const char *buf, size_t size)
+ {
+ 	int mode_idx;
+ 
+ 	if (size > strlen("passive") || size < strlen("active"))
+ 		return -EINVAL;
+ 
+ 	mode_idx = get_mode_idx_from_str(buf, size);
+ 
+ 	if (mode_idx < 0 || mode_idx >= AMD_PSTATE_MAX)
+ 		return -EINVAL;
+ 
+ 	if (mode_state_machine[cppc_state][mode_idx])
+ 		return mode_state_machine[cppc_state][mode_idx](mode_idx);
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t show_status(struct kobject *kobj,
+ 			   struct kobj_attribute *attr, char *buf)
+ {
+ 	ssize_t ret;
+ 
+ 	mutex_lock(&amd_pstate_driver_lock);
+ 	ret = amd_pstate_show_status(buf);
+ 	mutex_unlock(&amd_pstate_driver_lock);
+ 
+ 	return ret;
+ }
+ 
+ static ssize_t store_status(struct kobject *a, struct kobj_attribute *b,
+ 			    const char *buf, size_t count)
+ {
+ 	char *p = memchr(buf, '\n', count);
+ 	int ret;
+ 
+ 	mutex_lock(&amd_pstate_driver_lock);
+ 	ret = amd_pstate_update_status(buf, p ? p - buf : count);
+ 	mutex_unlock(&amd_pstate_driver_lock);
+ 
+ 	return ret < 0 ? ret : count;
+ }
+ 
++>>>>>>> 11fa52fe619a (cpufreq: amd-pstate: Make varaiable mode_state_machine static)
  cpufreq_freq_attr_ro(amd_pstate_max_freq);
  cpufreq_freq_attr_ro(amd_pstate_lowest_nonlinear_freq);
  
* Unmerged path drivers/cpufreq/amd-pstate.c
