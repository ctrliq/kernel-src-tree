cpufreq: amd-pstate: Add guided autonomous mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Wyes Karny <wyes.karny@amd.com>
commit 2dd6d0ebf74049256160a3d03dabbd92fe0b8599
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/2dd6d0eb.failed

From ACPI spec below 3 modes for CPPC can be defined:

 1. Non autonomous: OS scaling governor specifies operating frequency/
    performance level through `Desired Performance` register and platform
    follows that.

 2. Guided autonomous: OS scaling governor specifies min and max
    frequencies/ performance levels through `Minimum Performance` and
    `Maximum Performance` register, and platform can autonomously select an
    operating frequency in this range.

 3. Fully autonomous: OS only hints (via EPP) to platform for the required
    energy performance preference for the workload and platform autonomously
    scales the frequency.

Currently (1) is supported by amd_pstate as passive mode, and (3) is
implemented by EPP support. This change is to support (2).

In guided autonomous mode the min_perf is based on the input from the
scaling governor. For example, in case of schedutil this value depends
on the current utilization. And max_perf is set to max capacity.

To activate guided auto mode ``amd_pstate=guided`` command line
parameter has to be passed in the kernel.

	Acked-by: Huang Rui <ray.huang@amd.com>
	Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
	Tested-by: Oleksandr Natalenko <oleksandr@natalenko.name>
	Signed-off-by: Wyes Karny <wyes.karny@amd.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2dd6d0ebf74049256160a3d03dabbd92fe0b8599)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/kernel-parameters.txt
#	drivers/cpufreq/amd-pstate.c
#	include/linux/amd-pstate.h
diff --cc Documentation/admin-guide/kernel-parameters.txt
index 5602654ef75c,1e5fe4891dd7..000000000000
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@@ -324,6 -339,29 +324,32 @@@
  			             This mode requires kvm-amd.avic=1.
  			             (Default when IOMMU HW support is present.)
  
++<<<<<<< HEAD
++=======
+ 	amd_pstate=	[X86]
+ 			disable
+ 			  Do not enable amd_pstate as the default
+ 			  scaling driver for the supported processors
+ 			passive
+ 			  Use amd_pstate with passive mode as a scaling driver.
+ 			  In this mode autonomous selection is disabled.
+ 			  Driver requests a desired performance level and platform
+ 			  tries to match the same performance level if it is
+ 			  satisfied by guaranteed performance level.
+ 			active
+ 			  Use amd_pstate_epp driver instance as the scaling driver,
+ 			  driver provides a hint to the hardware if software wants
+ 			  to bias toward performance (0x0) or energy efficiency (0xff)
+ 			  to the CPPC firmware. then CPPC power algorithm will
+ 			  calculate the runtime workload and adjust the realtime cores
+ 			  frequency.
+ 			guided
+ 			  Activate guided autonomous mode. Driver requests minimum and
+ 			  maximum performance level and the platform autonomously
+ 			  selects a performance level in this range and appropriate
+ 			  to the current workload.
+ 
++>>>>>>> 2dd6d0ebf740 (cpufreq: amd-pstate: Add guided autonomous mode)
  	amijoy.map=	[HW,JOY] Amiga joystick support
  			Map of devices attached to JOY0DAT and JOY1DAT
  			Format: <a>,<b>
diff --cc drivers/cpufreq/amd-pstate.c
index 2c71ef90154d,61dcd7b89b26..000000000000
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@@ -703,7 -1301,8 +725,12 @@@ static int __init amd_pstate_init(void
  	/* capability check */
  	if (boot_cpu_has(X86_FEATURE_CPPC)) {
  		pr_debug("AMD CPPC MSR based functionality is supported\n");
++<<<<<<< HEAD
 +		amd_pstate_driver.adjust_perf = amd_pstate_adjust_perf;
++=======
+ 		if (cppc_state != AMD_PSTATE_ACTIVE)
+ 			current_pstate_driver->adjust_perf = amd_pstate_adjust_perf;
++>>>>>>> 2dd6d0ebf740 (cpufreq: amd-pstate: Add guided autonomous mode)
  	} else {
  		pr_debug("AMD CPPC shared memory based functionality is supported\n");
  		static_call_update(amd_pstate_enable, cppc_enable);
@@@ -732,13 -1349,27 +759,31 @@@ static int __init amd_pstate_param(cha
  	if (!str)
  		return -EINVAL;
  
 -	size = strlen(str);
 -	mode_idx = get_mode_idx_from_str(str, size);
 +	if (!strcmp(str, "disable")) {
 +		cppc_load = 0;
 +		pr_info("driver is explicitly disabled\n");
 +	} else if (!strcmp(str, "passive"))
 +		cppc_load = 1;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	if (mode_idx >= AMD_PSTATE_DISABLE && mode_idx < AMD_PSTATE_MAX) {
+ 		cppc_state = mode_idx;
+ 		if (cppc_state == AMD_PSTATE_DISABLE)
+ 			pr_info("driver is explicitly disabled\n");
+ 
+ 		if (cppc_state == AMD_PSTATE_ACTIVE)
+ 			current_pstate_driver = &amd_pstate_epp_driver;
+ 
+ 		if (cppc_state == AMD_PSTATE_PASSIVE || cppc_state == AMD_PSTATE_GUIDED)
+ 			current_pstate_driver = &amd_pstate_driver;
+ 
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
++>>>>>>> 2dd6d0ebf740 (cpufreq: amd-pstate: Add guided autonomous mode)
  }
  early_param("amd_pstate", amd_pstate_param);
  
* Unmerged path include/linux/amd-pstate.h
* Unmerged path Documentation/admin-guide/kernel-parameters.txt
* Unmerged path drivers/cpufreq/amd-pstate.c
* Unmerged path include/linux/amd-pstate.h
