cpufreq: amd-pstate: convert sprintf with sysfs_emit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Perry Yuan <perry.yuan@amd.com>
commit 3ec32b6d17c5b229c6f5d05849932af1f0c6f523
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/3ec32b6d.failed

replace the sprintf with a more generic sysfs_emit function

No intended potential function impact

	Acked-by: Huang Rui <ray.huang@amd.com>
	Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
	Reviewed-by: Wyes Karny <wyes.karny@amd.com>
	Tested-by: Wyes Karny <wyes.karny@amd.com>
	Signed-off-by: Perry Yuan <perry.yuan@amd.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 3ec32b6d17c5b229c6f5d05849932af1f0c6f523)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/amd-pstate.c
diff --cc drivers/cpufreq/amd-pstate.c
index f0b221585cc8,168a28bed6ee..000000000000
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@@ -648,6 -765,141 +648,144 @@@ static ssize_t show_amd_pstate_highest_
  	perf = READ_ONCE(cpudata->highest_perf);
  
  	return sysfs_emit(buf, "%u\n", perf);
++<<<<<<< HEAD
++=======
+ }
+ 
+ static ssize_t show_energy_performance_available_preferences(
+ 				struct cpufreq_policy *policy, char *buf)
+ {
+ 	int i = 0;
+ 	int offset = 0;
+ 
+ 	while (energy_perf_strings[i] != NULL)
+ 		offset += sysfs_emit_at(buf, offset, "%s ", energy_perf_strings[i++]);
+ 
+ 	sysfs_emit_at(buf, offset, "\n");
+ 
+ 	return offset;
+ }
+ 
+ static ssize_t store_energy_performance_preference(
+ 		struct cpufreq_policy *policy, const char *buf, size_t count)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	char str_preference[21];
+ 	ssize_t ret;
+ 
+ 	ret = sscanf(buf, "%20s", str_preference);
+ 	if (ret != 1)
+ 		return -EINVAL;
+ 
+ 	ret = match_string(energy_perf_strings, -1, str_preference);
+ 	if (ret < 0)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&amd_pstate_limits_lock);
+ 	ret = amd_pstate_set_energy_pref_index(cpudata, ret);
+ 	mutex_unlock(&amd_pstate_limits_lock);
+ 
+ 	return ret ?: count;
+ }
+ 
+ static ssize_t show_energy_performance_preference(
+ 				struct cpufreq_policy *policy, char *buf)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	int preference;
+ 
+ 	preference = amd_pstate_get_energy_pref_index(cpudata);
+ 	if (preference < 0)
+ 		return preference;
+ 
+ 	return sysfs_emit(buf, "%s\n", energy_perf_strings[preference]);
+ }
+ 
+ static ssize_t amd_pstate_show_status(char *buf)
+ {
+ 	if (!current_pstate_driver)
+ 		return sysfs_emit(buf, "disable\n");
+ 
+ 	return sysfs_emit(buf, "%s\n", amd_pstate_mode_string[cppc_state]);
+ }
+ 
+ static void amd_pstate_driver_cleanup(void)
+ {
+ 	current_pstate_driver = NULL;
+ }
+ 
+ static int amd_pstate_update_status(const char *buf, size_t size)
+ {
+ 	int ret;
+ 	int mode_idx;
+ 
+ 	if (size > 7 || size < 6)
+ 		return -EINVAL;
+ 	mode_idx = get_mode_idx_from_str(buf, size);
+ 
+ 	switch(mode_idx) {
+ 	case AMD_PSTATE_DISABLE:
+ 		if (!current_pstate_driver)
+ 			return -EINVAL;
+ 		if (cppc_state == AMD_PSTATE_ACTIVE)
+ 			return -EBUSY;
+ 		ret = cpufreq_unregister_driver(current_pstate_driver);
+ 		amd_pstate_driver_cleanup();
+ 		break;
+ 	case AMD_PSTATE_PASSIVE:
+ 		if (current_pstate_driver) {
+ 			if (current_pstate_driver == &amd_pstate_driver)
+ 				return 0;
+ 			cpufreq_unregister_driver(current_pstate_driver);
+ 			cppc_state = AMD_PSTATE_PASSIVE;
+ 			current_pstate_driver = &amd_pstate_driver;
+ 		}
+ 
+ 		ret = cpufreq_register_driver(current_pstate_driver);
+ 		break;
+ 	case AMD_PSTATE_ACTIVE:
+ 		if (current_pstate_driver) {
+ 			if (current_pstate_driver == &amd_pstate_epp_driver)
+ 				return 0;
+ 			cpufreq_unregister_driver(current_pstate_driver);
+ 			current_pstate_driver = &amd_pstate_epp_driver;
+ 			cppc_state = AMD_PSTATE_ACTIVE;
+ 		}
+ 
+ 		ret = cpufreq_register_driver(current_pstate_driver);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static ssize_t show_status(struct kobject *kobj,
+ 			   struct kobj_attribute *attr, char *buf)
+ {
+ 	ssize_t ret;
+ 
+ 	mutex_lock(&amd_pstate_driver_lock);
+ 	ret = amd_pstate_show_status(buf);
+ 	mutex_unlock(&amd_pstate_driver_lock);
+ 
+ 	return ret;
+ }
+ 
+ static ssize_t store_status(struct kobject *a, struct kobj_attribute *b,
+ 			    const char *buf, size_t count)
+ {
+ 	char *p = memchr(buf, '\n', count);
+ 	int ret;
+ 
+ 	mutex_lock(&amd_pstate_driver_lock);
+ 	ret = amd_pstate_update_status(buf, p ? p - buf : count);
+ 	mutex_unlock(&amd_pstate_driver_lock);
+ 
+ 	return ret < 0 ? ret : count;
++>>>>>>> 3ec32b6d17c5 (cpufreq: amd-pstate: convert sprintf with sysfs_emit())
  }
  
  cpufreq_freq_attr_ro(amd_pstate_max_freq);
* Unmerged path drivers/cpufreq/amd-pstate.c
