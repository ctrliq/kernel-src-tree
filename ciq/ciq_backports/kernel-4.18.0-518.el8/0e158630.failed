RDMA/core: Update CMA destination address on rdma_resolve_addr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Shiraz Saleem <shiraz.saleem@intel.com>
commit 0e15863015d97c1ee2cc29d599abcc7fa2dc3e95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/0e158630.failed

8d037973d48c ("RDMA/core: Refactor rdma_bind_addr") intoduces as regression
on irdma devices on certain tests which uses rdma CM, such as cmtime.

No connections can be established with the MAD QP experiences a fatal
error on the active side.

The cma destination address is not updated with the dst_addr when ULP
on active side calls rdma_bind_addr followed by rdma_resolve_addr.
The id_priv state is 'bound' in resolve_prepare_src and update is skipped.

This leaves the dgid passed into irdma driver to create an Address Handle
(AH) for the MAD QP at 0. The create AH descriptor as well as the ARP cache
entry is invalid and HW throws an asynchronous events as result.

[ 1207.656888] resolve_prepare_src caller: ucma_resolve_addr+0xff/0x170 [rdma_ucm] daddr=200.0.4.28 id_priv->state=7
[....]
[ 1207.680362] ice 0000:07:00.1 rocep7s0f1: caller: irdma_create_ah+0x3e/0x70 [irdma] ah_id=0 arp_idx=0 dest_ip=0.0.0.0
destMAC=00:00:64:ca:b7:52 ipvalid=1 raw=0000:0000:0000:0000:0000:ffff:0000:0000
[ 1207.682077] ice 0000:07:00.1 rocep7s0f1: abnormal ae_id = 0x401 bool qp=1 qp_id = 1, ae_src=5
[ 1207.691657] infiniband rocep7s0f1: Fatal error (1) on MAD QP (1)

Fix this by updating the CMA destination address when the ULP calls
a resolve address with the CM state already bound.

Fixes: 8d037973d48c ("RDMA/core: Refactor rdma_bind_addr")
	Signed-off-by: Shiraz Saleem <shiraz.saleem@intel.com>
Link: https://lore.kernel.org/r/20230712234133.1343-1-shiraz.saleem@intel.com
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit 0e15863015d97c1ee2cc29d599abcc7fa2dc3e95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cma.c
diff --cc drivers/infiniband/core/cma.c
index aeb14358784a,9891c7dc2af5..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -4123,6 -4009,129 +4123,132 @@@ err1
  	cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_IDLE);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int cma_bind_addr(struct rdma_cm_id *id, struct sockaddr *src_addr,
+ 			 const struct sockaddr *dst_addr)
+ {
+ 	struct rdma_id_private *id_priv =
+ 		container_of(id, struct rdma_id_private, id);
+ 	struct sockaddr_storage zero_sock = {};
+ 
+ 	if (src_addr && src_addr->sa_family)
+ 		return rdma_bind_addr_dst(id_priv, src_addr, dst_addr);
+ 
+ 	/*
+ 	 * When the src_addr is not specified, automatically supply an any addr
+ 	 */
+ 	zero_sock.ss_family = dst_addr->sa_family;
+ 	if (IS_ENABLED(CONFIG_IPV6) && dst_addr->sa_family == AF_INET6) {
+ 		struct sockaddr_in6 *src_addr6 =
+ 			(struct sockaddr_in6 *)&zero_sock;
+ 		struct sockaddr_in6 *dst_addr6 =
+ 			(struct sockaddr_in6 *)dst_addr;
+ 
+ 		src_addr6->sin6_scope_id = dst_addr6->sin6_scope_id;
+ 		if (ipv6_addr_type(&dst_addr6->sin6_addr) & IPV6_ADDR_LINKLOCAL)
+ 			id->route.addr.dev_addr.bound_dev_if =
+ 				dst_addr6->sin6_scope_id;
+ 	} else if (dst_addr->sa_family == AF_IB) {
+ 		((struct sockaddr_ib *)&zero_sock)->sib_pkey =
+ 			((struct sockaddr_ib *)dst_addr)->sib_pkey;
+ 	}
+ 	return rdma_bind_addr_dst(id_priv, (struct sockaddr *)&zero_sock, dst_addr);
+ }
+ 
+ /*
+  * If required, resolve the source address for bind and leave the id_priv in
+  * state RDMA_CM_ADDR_BOUND. This oddly uses the state to determine the prior
+  * calls made by ULP, a previously bound ID will not be re-bound and src_addr is
+  * ignored.
+  */
+ static int resolve_prepare_src(struct rdma_id_private *id_priv,
+ 			       struct sockaddr *src_addr,
+ 			       const struct sockaddr *dst_addr)
+ {
+ 	int ret;
+ 
+ 	if (!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_ADDR_QUERY)) {
+ 		/* For a well behaved ULP state will be RDMA_CM_IDLE */
+ 		ret = cma_bind_addr(&id_priv->id, src_addr, dst_addr);
+ 		if (ret)
+ 			return ret;
+ 		if (WARN_ON(!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND,
+ 					   RDMA_CM_ADDR_QUERY)))
+ 			return -EINVAL;
+ 
+ 	} else {
+ 		memcpy(cma_dst_addr(id_priv), dst_addr, rdma_addr_size(dst_addr));
+ 	}
+ 
+ 	if (cma_family(id_priv) != dst_addr->sa_family) {
+ 		ret = -EINVAL;
+ 		goto err_state;
+ 	}
+ 	return 0;
+ 
+ err_state:
+ 	cma_comp_exch(id_priv, RDMA_CM_ADDR_QUERY, RDMA_CM_ADDR_BOUND);
+ 	return ret;
+ }
+ 
+ int rdma_resolve_addr(struct rdma_cm_id *id, struct sockaddr *src_addr,
+ 		      const struct sockaddr *dst_addr, unsigned long timeout_ms)
+ {
+ 	struct rdma_id_private *id_priv =
+ 		container_of(id, struct rdma_id_private, id);
+ 	int ret;
+ 
+ 	ret = resolve_prepare_src(id_priv, src_addr, dst_addr);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (cma_any_addr(dst_addr)) {
+ 		ret = cma_resolve_loopback(id_priv);
+ 	} else {
+ 		if (dst_addr->sa_family == AF_IB) {
+ 			ret = cma_resolve_ib_addr(id_priv);
+ 		} else {
+ 			/*
+ 			 * The FSM can return back to RDMA_CM_ADDR_BOUND after
+ 			 * rdma_resolve_ip() is called, eg through the error
+ 			 * path in addr_handler(). If this happens the existing
+ 			 * request must be canceled before issuing a new one.
+ 			 * Since canceling a request is a bit slow and this
+ 			 * oddball path is rare, keep track once a request has
+ 			 * been issued. The track turns out to be a permanent
+ 			 * state since this is the only cancel as it is
+ 			 * immediately before rdma_resolve_ip().
+ 			 */
+ 			if (id_priv->used_resolve_ip)
+ 				rdma_addr_cancel(&id->route.addr.dev_addr);
+ 			else
+ 				id_priv->used_resolve_ip = 1;
+ 			ret = rdma_resolve_ip(cma_src_addr(id_priv), dst_addr,
+ 					      &id->route.addr.dev_addr,
+ 					      timeout_ms, addr_handler,
+ 					      false, id_priv);
+ 		}
+ 	}
+ 	if (ret)
+ 		goto err;
+ 
+ 	return 0;
+ err:
+ 	cma_comp_exch(id_priv, RDMA_CM_ADDR_QUERY, RDMA_CM_ADDR_BOUND);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(rdma_resolve_addr);
+ 
+ int rdma_bind_addr(struct rdma_cm_id *id, struct sockaddr *addr)
+ {
+ 	struct rdma_id_private *id_priv =
+ 		container_of(id, struct rdma_id_private, id);
+ 
+ 	return rdma_bind_addr_dst(id_priv, addr, cma_dst_addr(id_priv));
+ }
++>>>>>>> 0e15863015d9 (RDMA/core: Update CMA destination address on rdma_resolve_addr)
  EXPORT_SYMBOL(rdma_bind_addr);
  
  static int cma_format_hdr(void *hdr, struct rdma_id_private *id_priv)
* Unmerged path drivers/infiniband/core/cma.c
