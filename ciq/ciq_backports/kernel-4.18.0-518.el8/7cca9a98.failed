cpufreq: amd-pstate: avoid uninitialized variable use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Arnd Bergmann <arnd@arndb.de>
commit 7cca9a9851a5fb44808949539af6c0428e48a267
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/7cca9a98.failed

The new epp support causes warnings about three separate
but related bugs:

1) failing before allocation should just return an error:

drivers/cpufreq/amd-pstate.c:951:6: error: variable 'ret' is used uninitialized whenever 'if' condition is true [-Werror,-Wsometimes-uninitialized]
        if (!dev)
            ^~~~
drivers/cpufreq/amd-pstate.c:1018:9: note: uninitialized use occurs here
        return ret;
               ^~~

2) wrong variable to store return code:

drivers/cpufreq/amd-pstate.c:963:6: error: variable 'ret' is used uninitialized whenever 'if' condition is true [-Werror,-Wsometimes-uninitialized]
        if (rc)
            ^~
drivers/cpufreq/amd-pstate.c:1019:9: note: uninitialized use occurs here
        return ret;
               ^~~
drivers/cpufreq/amd-pstate.c:963:2: note: remove the 'if' if its condition is always false
        if (rc)
        ^~~~~~~

3) calling amd_pstate_set_epp() in cleanup path after determining
that it should not be called:

drivers/cpufreq/amd-pstate.c:1055:6: error: variable 'epp' is used uninitialized whenever 'if' condition is true [-Werror,-Wsometimes-uninitialized]
        if (cpudata->epp_policy == cpudata->policy)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
drivers/cpufreq/amd-pstate.c:1080:30: note: uninitialized use occurs here
        amd_pstate_set_epp(cpudata, epp);
                                    ^~~

All three are trivial to fix, but most likely there are additional bugs
in this function when the error handling was not really tested.

Fixes: ffa5096a7c33 ("cpufreq: amd-pstate: implement Pstate EPP support for the AMD processors")
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Tested-by: Wyes Karny <wyes.karny@amd.com>
	Reviewed-by: Yuan Perry <Perry.Yuan@amd.com>
	Acked-by: Huang Rui <ray.huang@amd.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 7cca9a9851a5fb44808949539af6c0428e48a267)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/amd-pstate.c
diff --cc drivers/cpufreq/amd-pstate.c
index f0b221585cc8,b8862afef4e4..000000000000
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@@ -662,6 -917,312 +662,315 @@@ static struct freq_attr *amd_pstate_att
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static struct freq_attr *amd_pstate_epp_attr[] = {
+ 	&amd_pstate_max_freq,
+ 	&amd_pstate_lowest_nonlinear_freq,
+ 	&amd_pstate_highest_perf,
+ 	&energy_performance_preference,
+ 	&energy_performance_available_preferences,
+ 	NULL,
+ };
+ 
+ static struct attribute *pstate_global_attributes[] = {
+ 	&status.attr,
+ 	NULL
+ };
+ 
+ static const struct attribute_group amd_pstate_global_attr_group = {
+ 	.attrs = pstate_global_attributes,
+ };
+ 
+ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
+ {
+ 	int min_freq, max_freq, nominal_freq, lowest_nonlinear_freq, ret;
+ 	struct amd_cpudata *cpudata;
+ 	struct device *dev;
+ 	u64 value;
+ 
+ 	/*
+ 	 * Resetting PERF_CTL_MSR will put the CPU in P0 frequency,
+ 	 * which is ideal for initialization process.
+ 	 */
+ 	amd_perf_ctl_reset(policy->cpu);
+ 	dev = get_cpu_device(policy->cpu);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	cpudata = kzalloc(sizeof(*cpudata), GFP_KERNEL);
+ 	if (!cpudata)
+ 		return -ENOMEM;
+ 
+ 	cpudata->cpu = policy->cpu;
+ 	cpudata->epp_policy = 0;
+ 
+ 	ret = amd_pstate_init_perf(cpudata);
+ 	if (ret)
+ 		goto free_cpudata1;
+ 
+ 	min_freq = amd_get_min_freq(cpudata);
+ 	max_freq = amd_get_max_freq(cpudata);
+ 	nominal_freq = amd_get_nominal_freq(cpudata);
+ 	lowest_nonlinear_freq = amd_get_lowest_nonlinear_freq(cpudata);
+ 	if (min_freq < 0 || max_freq < 0 || min_freq > max_freq) {
+ 		dev_err(dev, "min_freq(%d) or max_freq(%d) value is incorrect\n",
+ 				min_freq, max_freq);
+ 		ret = -EINVAL;
+ 		goto free_cpudata1;
+ 	}
+ 
+ 	policy->cpuinfo.min_freq = min_freq;
+ 	policy->cpuinfo.max_freq = max_freq;
+ 	/* It will be updated by governor */
+ 	policy->cur = policy->cpuinfo.min_freq;
+ 
+ 	/* Initial processor data capability frequencies */
+ 	cpudata->max_freq = max_freq;
+ 	cpudata->min_freq = min_freq;
+ 	cpudata->nominal_freq = nominal_freq;
+ 	cpudata->lowest_nonlinear_freq = lowest_nonlinear_freq;
+ 
+ 	policy->driver_data = cpudata;
+ 
+ 	cpudata->epp_cached = amd_pstate_get_epp(cpudata, 0);
+ 
+ 	policy->min = policy->cpuinfo.min_freq;
+ 	policy->max = policy->cpuinfo.max_freq;
+ 
+ 	/*
+ 	 * Set the policy to powersave to provide a valid fallback value in case
+ 	 * the default cpufreq governor is neither powersave nor performance.
+ 	 */
+ 	policy->policy = CPUFREQ_POLICY_POWERSAVE;
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		policy->fast_switch_possible = true;
+ 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, &value);
+ 		if (ret)
+ 			return ret;
+ 		WRITE_ONCE(cpudata->cppc_req_cached, value);
+ 
+ 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_CAP1, &value);
+ 		if (ret)
+ 			return ret;
+ 		WRITE_ONCE(cpudata->cppc_cap1_cached, value);
+ 	}
+ 	amd_pstate_boost_init(cpudata);
+ 
+ 	return 0;
+ 
+ free_cpudata1:
+ 	kfree(cpudata);
+ 	return ret;
+ }
+ 
+ static int amd_pstate_epp_cpu_exit(struct cpufreq_policy *policy)
+ {
+ 	pr_debug("CPU %d exiting\n", policy->cpu);
+ 	policy->fast_switch_possible = false;
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_init(unsigned int cpu)
+ {
+ 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	u32 max_perf, min_perf;
+ 	u64 value;
+ 	s16 epp;
+ 
+ 	max_perf = READ_ONCE(cpudata->highest_perf);
+ 	min_perf = READ_ONCE(cpudata->lowest_perf);
+ 
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 
+ 	if (cpudata->policy == CPUFREQ_POLICY_PERFORMANCE)
+ 		min_perf = max_perf;
+ 
+ 	/* Initial min/max values for CPPC Performance Controls Register */
+ 	value &= ~AMD_CPPC_MIN_PERF(~0L);
+ 	value |= AMD_CPPC_MIN_PERF(min_perf);
+ 
+ 	value &= ~AMD_CPPC_MAX_PERF(~0L);
+ 	value |= AMD_CPPC_MAX_PERF(max_perf);
+ 
+ 	/* CPPC EPP feature require to set zero to the desire perf bit */
+ 	value &= ~AMD_CPPC_DES_PERF(~0L);
+ 	value |= AMD_CPPC_DES_PERF(0);
+ 
+ 	if (cpudata->epp_policy == cpudata->policy)
+ 		goto skip_epp;
+ 
+ 	cpudata->epp_policy = cpudata->policy;
+ 
+ 	if (cpudata->policy == CPUFREQ_POLICY_PERFORMANCE) {
+ 		epp = amd_pstate_get_epp(cpudata, value);
+ 		if (epp < 0)
+ 			goto skip_epp;
+ 		/* force the epp value to be zero for performance policy */
+ 		epp = 0;
+ 	} else {
+ 		/* Get BIOS pre-defined epp value */
+ 		epp = amd_pstate_get_epp(cpudata, value);
+ 		if (epp)
+ 			goto skip_epp;
+ 	}
+ 	/* Set initial EPP value */
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		value &= ~GENMASK_ULL(31, 24);
+ 		value |= (u64)epp << 24;
+ 	}
+ 
+ 	amd_pstate_set_epp(cpudata, epp);
+ skip_epp:
+ 	WRITE_ONCE(cpudata->cppc_req_cached, value);
+ 	cpufreq_cpu_put(policy);
+ }
+ 
+ static int amd_pstate_epp_set_policy(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	if (!policy->cpuinfo.max_freq)
+ 		return -ENODEV;
+ 
+ 	pr_debug("set_policy: cpuinfo.max %u policy->max %u\n",
+ 				policy->cpuinfo.max_freq, policy->max);
+ 
+ 	cpudata->policy = policy->policy;
+ 
+ 	amd_pstate_epp_init(policy->cpu);
+ 
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_reenable(struct amd_cpudata *cpudata)
+ {
+ 	struct cppc_perf_ctrls perf_ctrls;
+ 	u64 value, max_perf;
+ 	int ret;
+ 
+ 	ret = amd_pstate_enable(true);
+ 	if (ret)
+ 		pr_err("failed to enable amd pstate during resume, return %d\n", ret);
+ 
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 	max_perf = READ_ONCE(cpudata->highest_perf);
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+ 	} else {
+ 		perf_ctrls.max_perf = max_perf;
+ 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(cpudata->epp_cached);
+ 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+ 	}
+ }
+ 
+ static int amd_pstate_epp_cpu_online(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	pr_debug("AMD CPU Core %d going online\n", cpudata->cpu);
+ 
+ 	if (cppc_state == AMD_PSTATE_ACTIVE) {
+ 		amd_pstate_epp_reenable(cpudata);
+ 		cpudata->suspended = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_offline(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	struct cppc_perf_ctrls perf_ctrls;
+ 	int min_perf;
+ 	u64 value;
+ 
+ 	min_perf = READ_ONCE(cpudata->lowest_perf);
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 
+ 	mutex_lock(&amd_pstate_limits_lock);
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		cpudata->epp_policy = CPUFREQ_POLICY_UNKNOWN;
+ 
+ 		/* Set max perf same as min perf */
+ 		value &= ~AMD_CPPC_MAX_PERF(~0L);
+ 		value |= AMD_CPPC_MAX_PERF(min_perf);
+ 		value &= ~AMD_CPPC_MIN_PERF(~0L);
+ 		value |= AMD_CPPC_MIN_PERF(min_perf);
+ 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+ 	} else {
+ 		perf_ctrls.desired_perf = 0;
+ 		perf_ctrls.max_perf = min_perf;
+ 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(HWP_EPP_BALANCE_POWERSAVE);
+ 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+ 	}
+ 	mutex_unlock(&amd_pstate_limits_lock);
+ }
+ 
+ static int amd_pstate_epp_cpu_offline(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	pr_debug("AMD CPU Core %d going offline\n", cpudata->cpu);
+ 
+ 	if (cpudata->suspended)
+ 		return 0;
+ 
+ 	if (cppc_state == AMD_PSTATE_ACTIVE)
+ 		amd_pstate_epp_offline(policy);
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_verify_policy(struct cpufreq_policy_data *policy)
+ {
+ 	cpufreq_verify_within_cpu_limits(policy);
+ 	pr_debug("policy_max =%d, policy_min=%d\n", policy->max, policy->min);
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_suspend(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	int ret;
+ 
+ 	/* avoid suspending when EPP is not enabled */
+ 	if (cppc_state != AMD_PSTATE_ACTIVE)
+ 		return 0;
+ 
+ 	/* set this flag to avoid setting core offline*/
+ 	cpudata->suspended = true;
+ 
+ 	/* disable CPPC in lowlevel firmware */
+ 	ret = amd_pstate_enable(false);
+ 	if (ret)
+ 		pr_err("failed to suspend, return %d\n", ret);
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_resume(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	if (cpudata->suspended) {
+ 		mutex_lock(&amd_pstate_limits_lock);
+ 
+ 		/* enable amd pstate from suspend state*/
+ 		amd_pstate_epp_reenable(cpudata);
+ 
+ 		mutex_unlock(&amd_pstate_limits_lock);
+ 
+ 		cpudata->suspended = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 7cca9a9851a5 (cpufreq: amd-pstate: avoid uninitialized variable use)
  static struct cpufreq_driver amd_pstate_driver = {
  	.flags		= CPUFREQ_CONST_LOOPS | CPUFREQ_NEED_UPDATE_LIMITS,
  	.verify		= amd_pstate_verify,
* Unmerged path drivers/cpufreq/amd-pstate.c
