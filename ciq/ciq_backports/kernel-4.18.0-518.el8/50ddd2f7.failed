cpufreq: amd-pstate: implement suspend and resume callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Perry Yuan <Perry.Yuan@amd.com>
commit 50ddd2f7826927e6dc111a43b3a183f53c260fa4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/50ddd2f7.failed

add suspend and resume support for the AMD processors by amd_pstate_epp
driver instance.

When the CPPC is suspended, EPP driver will set EPP profile to 'power'
profile and set max/min perf to lowest perf value.
When resume happens, it will restore the MSR registers with
previous cached value.

	Acked-by: Huang Rui <ray.huang@amd.com>
	Reviewed-by: Mario Limonciello <Mario.Limonciello@amd.com>
	Reviewed-by: Wyes Karny <wyes.karny@amd.com>
	Tested-by: Wyes Karny <wyes.karny@amd.com>
	Signed-off-by: Perry Yuan <Perry.Yuan@amd.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 50ddd2f7826927e6dc111a43b3a183f53c260fa4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/amd-pstate.c
diff --cc drivers/cpufreq/amd-pstate.c
index f0b221585cc8,4e3770e0d4d3..000000000000
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@@ -662,6 -827,304 +662,307 @@@ static struct freq_attr *amd_pstate_att
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static struct freq_attr *amd_pstate_epp_attr[] = {
+ 	&amd_pstate_max_freq,
+ 	&amd_pstate_lowest_nonlinear_freq,
+ 	&amd_pstate_highest_perf,
+ 	&energy_performance_preference,
+ 	&energy_performance_available_preferences,
+ 	NULL,
+ };
+ 
+ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
+ {
+ 	int min_freq, max_freq, nominal_freq, lowest_nonlinear_freq, ret;
+ 	struct amd_cpudata *cpudata;
+ 	struct device *dev;
+ 	int rc;
+ 	u64 value;
+ 
+ 	/*
+ 	 * Resetting PERF_CTL_MSR will put the CPU in P0 frequency,
+ 	 * which is ideal for initialization process.
+ 	 */
+ 	amd_perf_ctl_reset(policy->cpu);
+ 	dev = get_cpu_device(policy->cpu);
+ 	if (!dev)
+ 		goto free_cpudata1;
+ 
+ 	cpudata = kzalloc(sizeof(*cpudata), GFP_KERNEL);
+ 	if (!cpudata)
+ 		return -ENOMEM;
+ 
+ 	cpudata->cpu = policy->cpu;
+ 	cpudata->epp_policy = 0;
+ 
+ 	rc = amd_pstate_init_perf(cpudata);
+ 	if (rc)
+ 		goto free_cpudata1;
+ 
+ 	min_freq = amd_get_min_freq(cpudata);
+ 	max_freq = amd_get_max_freq(cpudata);
+ 	nominal_freq = amd_get_nominal_freq(cpudata);
+ 	lowest_nonlinear_freq = amd_get_lowest_nonlinear_freq(cpudata);
+ 	if (min_freq < 0 || max_freq < 0 || min_freq > max_freq) {
+ 		dev_err(dev, "min_freq(%d) or max_freq(%d) value is incorrect\n",
+ 				min_freq, max_freq);
+ 		ret = -EINVAL;
+ 		goto free_cpudata1;
+ 	}
+ 
+ 	policy->cpuinfo.min_freq = min_freq;
+ 	policy->cpuinfo.max_freq = max_freq;
+ 	/* It will be updated by governor */
+ 	policy->cur = policy->cpuinfo.min_freq;
+ 
+ 	/* Initial processor data capability frequencies */
+ 	cpudata->max_freq = max_freq;
+ 	cpudata->min_freq = min_freq;
+ 	cpudata->nominal_freq = nominal_freq;
+ 	cpudata->lowest_nonlinear_freq = lowest_nonlinear_freq;
+ 
+ 	policy->driver_data = cpudata;
+ 
+ 	cpudata->epp_cached = amd_pstate_get_epp(cpudata, 0);
+ 
+ 	policy->min = policy->cpuinfo.min_freq;
+ 	policy->max = policy->cpuinfo.max_freq;
+ 
+ 	/*
+ 	 * Set the policy to powersave to provide a valid fallback value in case
+ 	 * the default cpufreq governor is neither powersave nor performance.
+ 	 */
+ 	policy->policy = CPUFREQ_POLICY_POWERSAVE;
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		policy->fast_switch_possible = true;
+ 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, &value);
+ 		if (ret)
+ 			return ret;
+ 		WRITE_ONCE(cpudata->cppc_req_cached, value);
+ 
+ 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_CAP1, &value);
+ 		if (ret)
+ 			return ret;
+ 		WRITE_ONCE(cpudata->cppc_cap1_cached, value);
+ 	}
+ 	amd_pstate_boost_init(cpudata);
+ 
+ 	return 0;
+ 
+ free_cpudata1:
+ 	kfree(cpudata);
+ 	return ret;
+ }
+ 
+ static int amd_pstate_epp_cpu_exit(struct cpufreq_policy *policy)
+ {
+ 	pr_debug("CPU %d exiting\n", policy->cpu);
+ 	policy->fast_switch_possible = false;
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_init(unsigned int cpu)
+ {
+ 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	u32 max_perf, min_perf;
+ 	u64 value;
+ 	s16 epp;
+ 
+ 	max_perf = READ_ONCE(cpudata->highest_perf);
+ 	min_perf = READ_ONCE(cpudata->lowest_perf);
+ 
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 
+ 	if (cpudata->policy == CPUFREQ_POLICY_PERFORMANCE)
+ 		min_perf = max_perf;
+ 
+ 	/* Initial min/max values for CPPC Performance Controls Register */
+ 	value &= ~AMD_CPPC_MIN_PERF(~0L);
+ 	value |= AMD_CPPC_MIN_PERF(min_perf);
+ 
+ 	value &= ~AMD_CPPC_MAX_PERF(~0L);
+ 	value |= AMD_CPPC_MAX_PERF(max_perf);
+ 
+ 	/* CPPC EPP feature require to set zero to the desire perf bit */
+ 	value &= ~AMD_CPPC_DES_PERF(~0L);
+ 	value |= AMD_CPPC_DES_PERF(0);
+ 
+ 	if (cpudata->epp_policy == cpudata->policy)
+ 		goto skip_epp;
+ 
+ 	cpudata->epp_policy = cpudata->policy;
+ 
+ 	if (cpudata->policy == CPUFREQ_POLICY_PERFORMANCE) {
+ 		epp = amd_pstate_get_epp(cpudata, value);
+ 		if (epp < 0)
+ 			goto skip_epp;
+ 		/* force the epp value to be zero for performance policy */
+ 		epp = 0;
+ 	} else {
+ 		/* Get BIOS pre-defined epp value */
+ 		epp = amd_pstate_get_epp(cpudata, value);
+ 		if (epp)
+ 			goto skip_epp;
+ 	}
+ 	/* Set initial EPP value */
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		value &= ~GENMASK_ULL(31, 24);
+ 		value |= (u64)epp << 24;
+ 	}
+ 
+ skip_epp:
+ 	WRITE_ONCE(cpudata->cppc_req_cached, value);
+ 	amd_pstate_set_epp(cpudata, epp);
+ 	cpufreq_cpu_put(policy);
+ }
+ 
+ static int amd_pstate_epp_set_policy(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	if (!policy->cpuinfo.max_freq)
+ 		return -ENODEV;
+ 
+ 	pr_debug("set_policy: cpuinfo.max %u policy->max %u\n",
+ 				policy->cpuinfo.max_freq, policy->max);
+ 
+ 	cpudata->policy = policy->policy;
+ 
+ 	amd_pstate_epp_init(policy->cpu);
+ 
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_reenable(struct amd_cpudata *cpudata)
+ {
+ 	struct cppc_perf_ctrls perf_ctrls;
+ 	u64 value, max_perf;
+ 	int ret;
+ 
+ 	ret = amd_pstate_enable(true);
+ 	if (ret)
+ 		pr_err("failed to enable amd pstate during resume, return %d\n", ret);
+ 
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 	max_perf = READ_ONCE(cpudata->highest_perf);
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+ 	} else {
+ 		perf_ctrls.max_perf = max_perf;
+ 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(cpudata->epp_cached);
+ 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+ 	}
+ }
+ 
+ static int amd_pstate_epp_cpu_online(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	pr_debug("AMD CPU Core %d going online\n", cpudata->cpu);
+ 
+ 	if (cppc_state == AMD_PSTATE_ACTIVE) {
+ 		amd_pstate_epp_reenable(cpudata);
+ 		cpudata->suspended = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_offline(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	struct cppc_perf_ctrls perf_ctrls;
+ 	int min_perf;
+ 	u64 value;
+ 
+ 	min_perf = READ_ONCE(cpudata->lowest_perf);
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 
+ 	mutex_lock(&amd_pstate_limits_lock);
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		cpudata->epp_policy = CPUFREQ_POLICY_UNKNOWN;
+ 
+ 		/* Set max perf same as min perf */
+ 		value &= ~AMD_CPPC_MAX_PERF(~0L);
+ 		value |= AMD_CPPC_MAX_PERF(min_perf);
+ 		value &= ~AMD_CPPC_MIN_PERF(~0L);
+ 		value |= AMD_CPPC_MIN_PERF(min_perf);
+ 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+ 	} else {
+ 		perf_ctrls.desired_perf = 0;
+ 		perf_ctrls.max_perf = min_perf;
+ 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(HWP_EPP_BALANCE_POWERSAVE);
+ 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+ 	}
+ 	mutex_unlock(&amd_pstate_limits_lock);
+ }
+ 
+ static int amd_pstate_epp_cpu_offline(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	pr_debug("AMD CPU Core %d going offline\n", cpudata->cpu);
+ 
+ 	if (cpudata->suspended)
+ 		return 0;
+ 
+ 	if (cppc_state == AMD_PSTATE_ACTIVE)
+ 		amd_pstate_epp_offline(policy);
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_verify_policy(struct cpufreq_policy_data *policy)
+ {
+ 	cpufreq_verify_within_cpu_limits(policy);
+ 	pr_debug("policy_max =%d, policy_min=%d\n", policy->max, policy->min);
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_suspend(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	int ret;
+ 
+ 	/* avoid suspending when EPP is not enabled */
+ 	if (cppc_state != AMD_PSTATE_ACTIVE)
+ 		return 0;
+ 
+ 	/* set this flag to avoid setting core offline*/
+ 	cpudata->suspended = true;
+ 
+ 	/* disable CPPC in lowlevel firmware */
+ 	ret = amd_pstate_enable(false);
+ 	if (ret)
+ 		pr_err("failed to suspend, return %d\n", ret);
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_resume(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	if (cpudata->suspended) {
+ 		mutex_lock(&amd_pstate_limits_lock);
+ 
+ 		/* enable amd pstate from suspend state*/
+ 		amd_pstate_epp_reenable(cpudata);
+ 
+ 		mutex_unlock(&amd_pstate_limits_lock);
+ 
+ 		cpudata->suspended = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 50ddd2f78269 (cpufreq: amd-pstate: implement suspend and resume callbacks)
  static struct cpufreq_driver amd_pstate_driver = {
  	.flags		= CPUFREQ_CONST_LOOPS | CPUFREQ_NEED_UPDATE_LIMITS,
  	.verify		= amd_pstate_verify,
@@@ -675,6 -1138,20 +976,23 @@@
  	.attr		= amd_pstate_attr,
  };
  
++<<<<<<< HEAD
++=======
+ static struct cpufreq_driver amd_pstate_epp_driver = {
+ 	.flags		= CPUFREQ_CONST_LOOPS,
+ 	.verify		= amd_pstate_epp_verify_policy,
+ 	.setpolicy	= amd_pstate_epp_set_policy,
+ 	.init		= amd_pstate_epp_cpu_init,
+ 	.exit		= amd_pstate_epp_cpu_exit,
+ 	.offline	= amd_pstate_epp_cpu_offline,
+ 	.online		= amd_pstate_epp_cpu_online,
+ 	.suspend	= amd_pstate_epp_suspend,
+ 	.resume		= amd_pstate_epp_resume,
+ 	.name		= "amd_pstate_epp",
+ 	.attr		= amd_pstate_epp_attr,
+ };
+ 
++>>>>>>> 50ddd2f78269 (cpufreq: amd-pstate: implement suspend and resume callbacks)
  static int __init amd_pstate_init(void)
  {
  	int ret;
* Unmerged path drivers/cpufreq/amd-pstate.c
