cpufreq: amd-pstate: fix global sysfs attribute type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-518.el8
commit-author Thomas Weißschuh <linux@weissschuh.net>
commit 5e720f8c8c9d959283c3908bbf32a91a01a86547
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-518.el8/5e720f8c.failed

In commit 3666062b87ec ("cpufreq: amd-pstate: move to use bus_get_dev_root()")
the "amd_pstate" attributes where moved from a dedicated kobject to the
cpu root kobject.

While the dedicated kobject expects to contain kobj_attributes the root
kobject needs device_attributes.

As the changed arguments are not used by the callbacks it works most of
the time.
However CFI will detect this issue:

[ 4947.849350] CFI failure at dev_attr_show+0x24/0x60 (target: show_status+0x0/0x70; expected type: 0x8651b1de)
...
[ 4947.849409] Call Trace:
[ 4947.849410]  <TASK>
[ 4947.849411]  ? __warn+0xcf/0x1c0
[ 4947.849414]  ? dev_attr_show+0x24/0x60
[ 4947.849415]  ? report_cfi_failure+0x4e/0x60
[ 4947.849417]  ? handle_cfi_failure+0x14c/0x1d0
[ 4947.849419]  ? __cfi_show_status+0x10/0x10
[ 4947.849420]  ? handle_bug+0x4f/0x90
[ 4947.849421]  ? exc_invalid_op+0x1a/0x60
[ 4947.849422]  ? asm_exc_invalid_op+0x1a/0x20
[ 4947.849424]  ? __cfi_show_status+0x10/0x10
[ 4947.849425]  ? dev_attr_show+0x24/0x60
[ 4947.849426]  sysfs_kf_seq_show+0xa6/0x110
[ 4947.849433]  seq_read_iter+0x16c/0x4b0
[ 4947.849436]  vfs_read+0x272/0x2d0
[ 4947.849438]  ksys_read+0x72/0xe0
[ 4947.849439]  do_syscall_64+0x76/0xb0
[ 4947.849440]  ? do_user_addr_fault+0x252/0x650
[ 4947.849442]  ? exc_page_fault+0x7a/0x1b0
[ 4947.849443]  entry_SYSCALL_64_after_hwframe+0x72/0xdc

Fixes: 3666062b87ec ("cpufreq: amd-pstate: move to use bus_get_dev_root()")
	Reported-by: Jannik Glückert <jannik.glueckert@gmail.com>
Closes: https://bugzilla.kernel.org/show_bug.cgi?id=217765
Link: https://lore.kernel.org/lkml/c7f1bf9b-b183-bf6e-1cbb-d43f72494083@gmail.com/
	Cc: All applicable <stable@vger.kernel.org>
	Signed-off-by: Thomas Weißschuh <linux@weissschuh.net>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Nathan Chancellor <nathan@kernel.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5e720f8c8c9d959283c3908bbf32a91a01a86547)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/amd-pstate.c
diff --cc drivers/cpufreq/amd-pstate.c
index 2c71ef90154d,9a1e194d5cf8..000000000000
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@@ -650,10 -845,205 +650,211 @@@ static ssize_t show_amd_pstate_highest_
  	return sysfs_emit(buf, "%u\n", perf);
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t show_energy_performance_available_preferences(
+ 				struct cpufreq_policy *policy, char *buf)
+ {
+ 	int i = 0;
+ 	int offset = 0;
+ 
+ 	while (energy_perf_strings[i] != NULL)
+ 		offset += sysfs_emit_at(buf, offset, "%s ", energy_perf_strings[i++]);
+ 
+ 	sysfs_emit_at(buf, offset, "\n");
+ 
+ 	return offset;
+ }
+ 
+ static ssize_t store_energy_performance_preference(
+ 		struct cpufreq_policy *policy, const char *buf, size_t count)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	char str_preference[21];
+ 	ssize_t ret;
+ 
+ 	ret = sscanf(buf, "%20s", str_preference);
+ 	if (ret != 1)
+ 		return -EINVAL;
+ 
+ 	ret = match_string(energy_perf_strings, -1, str_preference);
+ 	if (ret < 0)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&amd_pstate_limits_lock);
+ 	ret = amd_pstate_set_energy_pref_index(cpudata, ret);
+ 	mutex_unlock(&amd_pstate_limits_lock);
+ 
+ 	return ret ?: count;
+ }
+ 
+ static ssize_t show_energy_performance_preference(
+ 				struct cpufreq_policy *policy, char *buf)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	int preference;
+ 
+ 	preference = amd_pstate_get_energy_pref_index(cpudata);
+ 	if (preference < 0)
+ 		return preference;
+ 
+ 	return sysfs_emit(buf, "%s\n", energy_perf_strings[preference]);
+ }
+ 
+ static void amd_pstate_driver_cleanup(void)
+ {
+ 	amd_pstate_enable(false);
+ 	cppc_state = AMD_PSTATE_DISABLE;
+ 	current_pstate_driver = NULL;
+ }
+ 
+ static int amd_pstate_register_driver(int mode)
+ {
+ 	int ret;
+ 
+ 	if (mode == AMD_PSTATE_PASSIVE || mode == AMD_PSTATE_GUIDED)
+ 		current_pstate_driver = &amd_pstate_driver;
+ 	else if (mode == AMD_PSTATE_ACTIVE)
+ 		current_pstate_driver = &amd_pstate_epp_driver;
+ 	else
+ 		return -EINVAL;
+ 
+ 	cppc_state = mode;
+ 	ret = cpufreq_register_driver(current_pstate_driver);
+ 	if (ret) {
+ 		amd_pstate_driver_cleanup();
+ 		return ret;
+ 	}
+ 	return 0;
+ }
+ 
+ static int amd_pstate_unregister_driver(int dummy)
+ {
+ 	cpufreq_unregister_driver(current_pstate_driver);
+ 	amd_pstate_driver_cleanup();
+ 	return 0;
+ }
+ 
+ static int amd_pstate_change_mode_without_dvr_change(int mode)
+ {
+ 	int cpu = 0;
+ 
+ 	cppc_state = mode;
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC) || cppc_state == AMD_PSTATE_ACTIVE)
+ 		return 0;
+ 
+ 	for_each_present_cpu(cpu) {
+ 		cppc_set_auto_sel(cpu, (cppc_state == AMD_PSTATE_PASSIVE) ? 0 : 1);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_change_driver_mode(int mode)
+ {
+ 	int ret;
+ 
+ 	ret = amd_pstate_unregister_driver(0);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = amd_pstate_register_driver(mode);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ 
+ static cppc_mode_transition_fn mode_state_machine[AMD_PSTATE_MAX][AMD_PSTATE_MAX] = {
+ 	[AMD_PSTATE_DISABLE]         = {
+ 		[AMD_PSTATE_DISABLE]     = NULL,
+ 		[AMD_PSTATE_PASSIVE]     = amd_pstate_register_driver,
+ 		[AMD_PSTATE_ACTIVE]      = amd_pstate_register_driver,
+ 		[AMD_PSTATE_GUIDED]      = amd_pstate_register_driver,
+ 	},
+ 	[AMD_PSTATE_PASSIVE]         = {
+ 		[AMD_PSTATE_DISABLE]     = amd_pstate_unregister_driver,
+ 		[AMD_PSTATE_PASSIVE]     = NULL,
+ 		[AMD_PSTATE_ACTIVE]      = amd_pstate_change_driver_mode,
+ 		[AMD_PSTATE_GUIDED]      = amd_pstate_change_mode_without_dvr_change,
+ 	},
+ 	[AMD_PSTATE_ACTIVE]          = {
+ 		[AMD_PSTATE_DISABLE]     = amd_pstate_unregister_driver,
+ 		[AMD_PSTATE_PASSIVE]     = amd_pstate_change_driver_mode,
+ 		[AMD_PSTATE_ACTIVE]      = NULL,
+ 		[AMD_PSTATE_GUIDED]      = amd_pstate_change_driver_mode,
+ 	},
+ 	[AMD_PSTATE_GUIDED]          = {
+ 		[AMD_PSTATE_DISABLE]     = amd_pstate_unregister_driver,
+ 		[AMD_PSTATE_PASSIVE]     = amd_pstate_change_mode_without_dvr_change,
+ 		[AMD_PSTATE_ACTIVE]      = amd_pstate_change_driver_mode,
+ 		[AMD_PSTATE_GUIDED]      = NULL,
+ 	},
+ };
+ 
+ static ssize_t amd_pstate_show_status(char *buf)
+ {
+ 	if (!current_pstate_driver)
+ 		return sysfs_emit(buf, "disable\n");
+ 
+ 	return sysfs_emit(buf, "%s\n", amd_pstate_mode_string[cppc_state]);
+ }
+ 
+ static int amd_pstate_update_status(const char *buf, size_t size)
+ {
+ 	int mode_idx;
+ 
+ 	if (size > strlen("passive") || size < strlen("active"))
+ 		return -EINVAL;
+ 
+ 	mode_idx = get_mode_idx_from_str(buf, size);
+ 
+ 	if (mode_idx < 0 || mode_idx >= AMD_PSTATE_MAX)
+ 		return -EINVAL;
+ 
+ 	if (mode_state_machine[cppc_state][mode_idx])
+ 		return mode_state_machine[cppc_state][mode_idx](mode_idx);
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t status_show(struct device *dev,
+ 			   struct device_attribute *attr, char *buf)
+ {
+ 	ssize_t ret;
+ 
+ 	mutex_lock(&amd_pstate_driver_lock);
+ 	ret = amd_pstate_show_status(buf);
+ 	mutex_unlock(&amd_pstate_driver_lock);
+ 
+ 	return ret;
+ }
+ 
+ static ssize_t status_store(struct device *a, struct device_attribute *b,
+ 			    const char *buf, size_t count)
+ {
+ 	char *p = memchr(buf, '\n', count);
+ 	int ret;
+ 
+ 	mutex_lock(&amd_pstate_driver_lock);
+ 	ret = amd_pstate_update_status(buf, p ? p - buf : count);
+ 	mutex_unlock(&amd_pstate_driver_lock);
+ 
+ 	return ret < 0 ? ret : count;
+ }
+ 
++>>>>>>> 5e720f8c8c9d (cpufreq: amd-pstate: fix global sysfs attribute type)
  cpufreq_freq_attr_ro(amd_pstate_max_freq);
  cpufreq_freq_attr_ro(amd_pstate_lowest_nonlinear_freq);
  
  cpufreq_freq_attr_ro(amd_pstate_highest_perf);
++<<<<<<< HEAD
++=======
+ cpufreq_freq_attr_rw(energy_performance_preference);
+ cpufreq_freq_attr_ro(energy_performance_available_preferences);
+ static DEVICE_ATTR_RW(status);
++>>>>>>> 5e720f8c8c9d (cpufreq: amd-pstate: fix global sysfs attribute type)
  
  static struct freq_attr *amd_pstate_attr[] = {
  	&amd_pstate_max_freq,
@@@ -662,6 -1052,336 +863,339 @@@
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static struct freq_attr *amd_pstate_epp_attr[] = {
+ 	&amd_pstate_max_freq,
+ 	&amd_pstate_lowest_nonlinear_freq,
+ 	&amd_pstate_highest_perf,
+ 	&energy_performance_preference,
+ 	&energy_performance_available_preferences,
+ 	NULL,
+ };
+ 
+ static struct attribute *pstate_global_attributes[] = {
+ 	&dev_attr_status.attr,
+ 	NULL
+ };
+ 
+ static const struct attribute_group amd_pstate_global_attr_group = {
+ 	.name = "amd_pstate",
+ 	.attrs = pstate_global_attributes,
+ };
+ 
+ static bool amd_pstate_acpi_pm_profile_server(void)
+ {
+ 	switch (acpi_gbl_FADT.preferred_profile) {
+ 	case PM_ENTERPRISE_SERVER:
+ 	case PM_SOHO_SERVER:
+ 	case PM_PERFORMANCE_SERVER:
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ static bool amd_pstate_acpi_pm_profile_undefined(void)
+ {
+ 	if (acpi_gbl_FADT.preferred_profile == PM_UNSPECIFIED)
+ 		return true;
+ 	if (acpi_gbl_FADT.preferred_profile >= NR_PM_PROFILES)
+ 		return true;
+ 	return false;
+ }
+ 
+ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
+ {
+ 	int min_freq, max_freq, nominal_freq, lowest_nonlinear_freq, ret;
+ 	struct amd_cpudata *cpudata;
+ 	struct device *dev;
+ 	u64 value;
+ 
+ 	/*
+ 	 * Resetting PERF_CTL_MSR will put the CPU in P0 frequency,
+ 	 * which is ideal for initialization process.
+ 	 */
+ 	amd_perf_ctl_reset(policy->cpu);
+ 	dev = get_cpu_device(policy->cpu);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	cpudata = kzalloc(sizeof(*cpudata), GFP_KERNEL);
+ 	if (!cpudata)
+ 		return -ENOMEM;
+ 
+ 	cpudata->cpu = policy->cpu;
+ 	cpudata->epp_policy = 0;
+ 
+ 	ret = amd_pstate_init_perf(cpudata);
+ 	if (ret)
+ 		goto free_cpudata1;
+ 
+ 	min_freq = amd_get_min_freq(cpudata);
+ 	max_freq = amd_get_max_freq(cpudata);
+ 	nominal_freq = amd_get_nominal_freq(cpudata);
+ 	lowest_nonlinear_freq = amd_get_lowest_nonlinear_freq(cpudata);
+ 	if (min_freq < 0 || max_freq < 0 || min_freq > max_freq) {
+ 		dev_err(dev, "min_freq(%d) or max_freq(%d) value is incorrect\n",
+ 				min_freq, max_freq);
+ 		ret = -EINVAL;
+ 		goto free_cpudata1;
+ 	}
+ 
+ 	policy->cpuinfo.min_freq = min_freq;
+ 	policy->cpuinfo.max_freq = max_freq;
+ 	/* It will be updated by governor */
+ 	policy->cur = policy->cpuinfo.min_freq;
+ 
+ 	/* Initial processor data capability frequencies */
+ 	cpudata->max_freq = max_freq;
+ 	cpudata->min_freq = min_freq;
+ 	cpudata->nominal_freq = nominal_freq;
+ 	cpudata->lowest_nonlinear_freq = lowest_nonlinear_freq;
+ 
+ 	policy->driver_data = cpudata;
+ 
+ 	cpudata->epp_cached = amd_pstate_get_epp(cpudata, 0);
+ 
+ 	policy->min = policy->cpuinfo.min_freq;
+ 	policy->max = policy->cpuinfo.max_freq;
+ 
+ 	/*
+ 	 * Set the policy to provide a valid fallback value in case
+ 	 * the default cpufreq governor is neither powersave nor performance.
+ 	 */
+ 	if (amd_pstate_acpi_pm_profile_server() ||
+ 	    amd_pstate_acpi_pm_profile_undefined())
+ 		policy->policy = CPUFREQ_POLICY_PERFORMANCE;
+ 	else
+ 		policy->policy = CPUFREQ_POLICY_POWERSAVE;
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, &value);
+ 		if (ret)
+ 			return ret;
+ 		WRITE_ONCE(cpudata->cppc_req_cached, value);
+ 
+ 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_CAP1, &value);
+ 		if (ret)
+ 			return ret;
+ 		WRITE_ONCE(cpudata->cppc_cap1_cached, value);
+ 	}
+ 	amd_pstate_boost_init(cpudata);
+ 
+ 	return 0;
+ 
+ free_cpudata1:
+ 	kfree(cpudata);
+ 	return ret;
+ }
+ 
+ static int amd_pstate_epp_cpu_exit(struct cpufreq_policy *policy)
+ {
+ 	pr_debug("CPU %d exiting\n", policy->cpu);
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_init(unsigned int cpu)
+ {
+ 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	u32 max_perf, min_perf;
+ 	u64 value;
+ 	s16 epp;
+ 
+ 	max_perf = READ_ONCE(cpudata->highest_perf);
+ 	min_perf = READ_ONCE(cpudata->lowest_perf);
+ 
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 
+ 	if (cpudata->policy == CPUFREQ_POLICY_PERFORMANCE)
+ 		min_perf = max_perf;
+ 
+ 	/* Initial min/max values for CPPC Performance Controls Register */
+ 	value &= ~AMD_CPPC_MIN_PERF(~0L);
+ 	value |= AMD_CPPC_MIN_PERF(min_perf);
+ 
+ 	value &= ~AMD_CPPC_MAX_PERF(~0L);
+ 	value |= AMD_CPPC_MAX_PERF(max_perf);
+ 
+ 	/* CPPC EPP feature require to set zero to the desire perf bit */
+ 	value &= ~AMD_CPPC_DES_PERF(~0L);
+ 	value |= AMD_CPPC_DES_PERF(0);
+ 
+ 	if (cpudata->epp_policy == cpudata->policy)
+ 		goto skip_epp;
+ 
+ 	cpudata->epp_policy = cpudata->policy;
+ 
+ 	/* Get BIOS pre-defined epp value */
+ 	epp = amd_pstate_get_epp(cpudata, value);
+ 	if (epp < 0) {
+ 		/**
+ 		 * This return value can only be negative for shared_memory
+ 		 * systems where EPP register read/write not supported.
+ 		 */
+ 		goto skip_epp;
+ 	}
+ 
+ 	if (cpudata->policy == CPUFREQ_POLICY_PERFORMANCE)
+ 		epp = 0;
+ 
+ 	/* Set initial EPP value */
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		value &= ~GENMASK_ULL(31, 24);
+ 		value |= (u64)epp << 24;
+ 	}
+ 
+ 	WRITE_ONCE(cpudata->cppc_req_cached, value);
+ 	amd_pstate_set_epp(cpudata, epp);
+ skip_epp:
+ 	cpufreq_cpu_put(policy);
+ }
+ 
+ static int amd_pstate_epp_set_policy(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	if (!policy->cpuinfo.max_freq)
+ 		return -ENODEV;
+ 
+ 	pr_debug("set_policy: cpuinfo.max %u policy->max %u\n",
+ 				policy->cpuinfo.max_freq, policy->max);
+ 
+ 	cpudata->policy = policy->policy;
+ 
+ 	amd_pstate_epp_init(policy->cpu);
+ 
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_reenable(struct amd_cpudata *cpudata)
+ {
+ 	struct cppc_perf_ctrls perf_ctrls;
+ 	u64 value, max_perf;
+ 	int ret;
+ 
+ 	ret = amd_pstate_enable(true);
+ 	if (ret)
+ 		pr_err("failed to enable amd pstate during resume, return %d\n", ret);
+ 
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 	max_perf = READ_ONCE(cpudata->highest_perf);
+ 
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+ 	} else {
+ 		perf_ctrls.max_perf = max_perf;
+ 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(cpudata->epp_cached);
+ 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+ 	}
+ }
+ 
+ static int amd_pstate_epp_cpu_online(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	pr_debug("AMD CPU Core %d going online\n", cpudata->cpu);
+ 
+ 	if (cppc_state == AMD_PSTATE_ACTIVE) {
+ 		amd_pstate_epp_reenable(cpudata);
+ 		cpudata->suspended = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void amd_pstate_epp_offline(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	struct cppc_perf_ctrls perf_ctrls;
+ 	int min_perf;
+ 	u64 value;
+ 
+ 	min_perf = READ_ONCE(cpudata->lowest_perf);
+ 	value = READ_ONCE(cpudata->cppc_req_cached);
+ 
+ 	mutex_lock(&amd_pstate_limits_lock);
+ 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
+ 		cpudata->epp_policy = CPUFREQ_POLICY_UNKNOWN;
+ 
+ 		/* Set max perf same as min perf */
+ 		value &= ~AMD_CPPC_MAX_PERF(~0L);
+ 		value |= AMD_CPPC_MAX_PERF(min_perf);
+ 		value &= ~AMD_CPPC_MIN_PERF(~0L);
+ 		value |= AMD_CPPC_MIN_PERF(min_perf);
+ 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
+ 	} else {
+ 		perf_ctrls.desired_perf = 0;
+ 		perf_ctrls.max_perf = min_perf;
+ 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(HWP_EPP_BALANCE_POWERSAVE);
+ 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+ 	}
+ 	mutex_unlock(&amd_pstate_limits_lock);
+ }
+ 
+ static int amd_pstate_epp_cpu_offline(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	pr_debug("AMD CPU Core %d going offline\n", cpudata->cpu);
+ 
+ 	if (cpudata->suspended)
+ 		return 0;
+ 
+ 	if (cppc_state == AMD_PSTATE_ACTIVE)
+ 		amd_pstate_epp_offline(policy);
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_verify_policy(struct cpufreq_policy_data *policy)
+ {
+ 	cpufreq_verify_within_cpu_limits(policy);
+ 	pr_debug("policy_max =%d, policy_min=%d\n", policy->max, policy->min);
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_suspend(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 	int ret;
+ 
+ 	/* avoid suspending when EPP is not enabled */
+ 	if (cppc_state != AMD_PSTATE_ACTIVE)
+ 		return 0;
+ 
+ 	/* set this flag to avoid setting core offline*/
+ 	cpudata->suspended = true;
+ 
+ 	/* disable CPPC in lowlevel firmware */
+ 	ret = amd_pstate_enable(false);
+ 	if (ret)
+ 		pr_err("failed to suspend, return %d\n", ret);
+ 
+ 	return 0;
+ }
+ 
+ static int amd_pstate_epp_resume(struct cpufreq_policy *policy)
+ {
+ 	struct amd_cpudata *cpudata = policy->driver_data;
+ 
+ 	if (cpudata->suspended) {
+ 		mutex_lock(&amd_pstate_limits_lock);
+ 
+ 		/* enable amd pstate from suspend state*/
+ 		amd_pstate_epp_reenable(cpudata);
+ 
+ 		mutex_unlock(&amd_pstate_limits_lock);
+ 
+ 		cpudata->suspended = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 5e720f8c8c9d (cpufreq: amd-pstate: fix global sysfs attribute type)
  static struct cpufreq_driver amd_pstate_driver = {
  	.flags		= CPUFREQ_CONST_LOOPS | CPUFREQ_NEED_UPDATE_LIMITS,
  	.verify		= amd_pstate_verify,
* Unmerged path drivers/cpufreq/amd-pstate.c
