net: prevent address rewrite in kernel_bind()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.8.1.el8_10
commit-author Jordan Rife <jrife@google.com>
commit c889a99a21bf124c3db08d09df919f0eccc5ea4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.8.1.el8_10/c889a99a.failed

Similar to the change in commit 0bdf399342c5("net: Avoid address
overwrite in kernel_connect"), BPF hooks run on bind may rewrite the
address passed to kernel_bind(). This change

1) Makes a copy of the bind address in kernel_bind() to insulate
   callers.
2) Replaces direct calls to sock->ops->bind() in net with kernel_bind()

Link: https://lore.kernel.org/netdev/20230912013332.2048422-1-jrife@google.com/
Fixes: 4fbac77d2d09 ("bpf: Hooks for sys_bind")
	Cc: stable@vger.kernel.org
	Reviewed-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: Jordan Rife <jrife@google.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c889a99a21bf124c3db08d09df919f0eccc5ea4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/tcp_connect.c
#	net/rds/tcp_listen.c
#	net/socket.c
diff --cc net/rds/tcp_connect.c
index 168ee9aa85ac,a0046e99d6df..000000000000
--- a/net/rds/tcp_connect.c
+++ b/net/rds/tcp_connect.c
@@@ -110,15 -124,30 +110,19 @@@ int rds_tcp_conn_path_connect(struct rd
  	if (ret < 0)
  		goto out;
  
 -	if (!rds_tcp_tune(sock)) {
 -		ret = -EINVAL;
 -		goto out;
 -	}
 +	rds_tcp_tune(sock);
  
 -	if (isv6) {
 -		sin6.sin6_family = AF_INET6;
 -		sin6.sin6_addr = conn->c_laddr;
 -		sin6.sin6_port = 0;
 -		sin6.sin6_flowinfo = 0;
 -		sin6.sin6_scope_id = conn->c_dev_if;
 -		addr = (struct sockaddr *)&sin6;
 -		addrlen = sizeof(sin6);
 -	} else {
 -		sin.sin_family = AF_INET;
 -		sin.sin_addr.s_addr = conn->c_laddr.s6_addr32[3];
 -		sin.sin_port = 0;
 -		addr = (struct sockaddr *)&sin;
 -		addrlen = sizeof(sin);
 -	}
 +	src.sin_family = AF_INET;
 +	src.sin_addr.s_addr = (__force u32)conn->c_laddr;
 +	src.sin_port = (__force u16)htons(0);
  
++<<<<<<< HEAD
 +	ret = sock->ops->bind(sock, (struct sockaddr *)&src, sizeof(src));
++=======
+ 	ret = kernel_bind(sock, addr, addrlen);
++>>>>>>> c889a99a21bf (net: prevent address rewrite in kernel_bind())
  	if (ret) {
 -		rdsdebug("bind failed with %d at address %pI6c\n",
 +		rdsdebug("bind failed with %d at address %pI4\n",
  			 ret, &conn->c_laddr);
  		goto out;
  	}
diff --cc net/rds/tcp_listen.c
index bdee49b57da5,53b3535a1e4a..000000000000
--- a/net/rds/tcp_listen.c
+++ b/net/rds/tcp_listen.c
@@@ -254,13 -290,28 +254,20 @@@ struct socket *rds_tcp_listen_init(stru
  	sock->sk->sk_data_ready = rds_tcp_listen_data_ready;
  	write_unlock_bh(&sock->sk->sk_callback_lock);
  
 -	if (isv6) {
 -		sin6 = (struct sockaddr_in6 *)&ss;
 -		sin6->sin6_family = PF_INET6;
 -		sin6->sin6_addr = in6addr_any;
 -		sin6->sin6_port = (__force u16)htons(RDS_TCP_PORT);
 -		sin6->sin6_scope_id = 0;
 -		sin6->sin6_flowinfo = 0;
 -		addr_len = sizeof(*sin6);
 -	} else {
 -		sin = (struct sockaddr_in *)&ss;
 -		sin->sin_family = PF_INET;
 -		sin->sin_addr.s_addr = INADDR_ANY;
 -		sin->sin_port = (__force u16)htons(RDS_TCP_PORT);
 -		addr_len = sizeof(*sin);
 -	}
 +	sin.sin_family = PF_INET;
 +	sin.sin_addr.s_addr = (__force u32)htonl(INADDR_ANY);
 +	sin.sin_port = (__force u16)htons(RDS_TCP_PORT);
  
++<<<<<<< HEAD
 +	ret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));
 +	if (ret < 0)
++=======
+ 	ret = kernel_bind(sock, (struct sockaddr *)&ss, addr_len);
+ 	if (ret < 0) {
+ 		rdsdebug("could not bind %s listener socket: %d\n",
+ 			 isv6 ? "IPv6" : "IPv4", ret);
++>>>>>>> c889a99a21bf (net: prevent address rewrite in kernel_bind())
  		goto out;
 -	}
  
  	ret = sock->ops->listen(sock, 64);
  	if (ret < 0)
diff --cc net/socket.c
index e69fd02a179d,c4a6f5532955..000000000000
--- a/net/socket.c
+++ b/net/socket.c
@@@ -3583,7 -3516,12 +3583,16 @@@ static long compat_sock_ioctl(struct fi
  
  int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)
  {
++<<<<<<< HEAD
 +	return sock->ops->bind(sock, addr, addrlen);
++=======
+ 	struct sockaddr_storage address;
+ 
+ 	memcpy(&address, addr, addrlen);
+ 
+ 	return READ_ONCE(sock->ops)->bind(sock, (struct sockaddr *)&address,
+ 					  addrlen);
++>>>>>>> c889a99a21bf (net: prevent address rewrite in kernel_bind())
  }
  EXPORT_SYMBOL(kernel_bind);
  
diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c
index 2232b0639a07..eee0e0b1db4c 100644
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@ -1450,7 +1450,7 @@ static int bind_mcastif_addr(struct socket *sock, struct net_device *dev)
 	sin.sin_addr.s_addr  = addr;
 	sin.sin_port         = 0;
 
-	return sock->ops->bind(sock, (struct sockaddr*)&sin, sizeof(sin));
+	return kernel_bind(sock, (struct sockaddr *)&sin, sizeof(sin));
 }
 
 static void get_mcast_sockaddr(union ipvs_sockaddr *sa, int *salen,
@@ -1557,7 +1557,7 @@ static int make_receive_sock(struct netns_ipvs *ipvs, int id,
 
 	get_mcast_sockaddr(&mcast_addr, &salen, &ipvs->bcfg, id);
 	sock->sk->sk_bound_dev_if = dev->ifindex;
-	result = sock->ops->bind(sock, (struct sockaddr *)&mcast_addr, salen);
+	result = kernel_bind(sock, (struct sockaddr *)&mcast_addr, salen);
 	if (result < 0) {
 		pr_err("Error binding to the multicast addr\n");
 		goto error;
* Unmerged path net/rds/tcp_connect.c
* Unmerged path net/rds/tcp_listen.c
* Unmerged path net/socket.c
