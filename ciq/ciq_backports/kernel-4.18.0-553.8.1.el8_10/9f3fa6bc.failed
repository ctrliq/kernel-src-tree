KEYS: use kfree_sensitive with key

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.8.1.el8_10
commit-author Mahmoud Adam <mngyadam@amazon.com>
commit 9f3fa6bc4ff8515da1349c44a77e7327bd2f4788
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.8.1.el8_10/9f3fa6bc.failed

key might contain private part of the key, so better use
kfree_sensitive to free it

	Signed-off-by: Mahmoud Adam <mngyadam@amazon.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 9f3fa6bc4ff8515da1349c44a77e7327bd2f4788)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/public_key.c
diff --cc crypto/asymmetric_keys/public_key.c
index e929fe1e4106,abeecb8329b3..000000000000
--- a/crypto/asymmetric_keys/public_key.c
+++ b/crypto/asymmetric_keys/public_key.c
@@@ -44,7 -42,8 +44,12 @@@ static void public_key_describe(const s
  void public_key_free(struct public_key *key)
  {
  	if (key) {
++<<<<<<< HEAD
 +		kfree(key->key);
++=======
+ 		kfree_sensitive(key->key);
+ 		kfree(key->params);
++>>>>>>> 9f3fa6bc4ff8 (KEYS: use kfree_sensitive with key)
  		kfree(key);
  	}
  }
@@@ -60,6 -59,322 +65,325 @@@ static void public_key_destroy(void *pa
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Given a public_key, and an encoding and hash_algo to be used for signing
+  * and/or verification with that key, determine the name of the corresponding
+  * akcipher algorithm.  Also check that encoding and hash_algo are allowed.
+  */
+ static int
+ software_key_determine_akcipher(const struct public_key *pkey,
+ 				const char *encoding, const char *hash_algo,
+ 				char alg_name[CRYPTO_MAX_ALG_NAME], bool *sig,
+ 				enum kernel_pkey_operation op)
+ {
+ 	int n;
+ 
+ 	*sig = true;
+ 
+ 	if (!encoding)
+ 		return -EINVAL;
+ 
+ 	if (strcmp(pkey->pkey_algo, "rsa") == 0) {
+ 		/*
+ 		 * RSA signatures usually use EMSA-PKCS1-1_5 [RFC3447 sec 8.2].
+ 		 */
+ 		if (strcmp(encoding, "pkcs1") == 0) {
+ 			if (!hash_algo) {
+ 				*sig = false;
+ 				n = snprintf(alg_name, CRYPTO_MAX_ALG_NAME,
+ 					     "pkcs1pad(%s)",
+ 					     pkey->pkey_algo);
+ 			} else {
+ 				*sig = op == kernel_pkey_sign ||
+ 				       op == kernel_pkey_verify;
+ 				n = snprintf(alg_name, CRYPTO_MAX_ALG_NAME,
+ 					     "pkcs1pad(%s,%s)",
+ 					     pkey->pkey_algo, hash_algo);
+ 			}
+ 			return n >= CRYPTO_MAX_ALG_NAME ? -EINVAL : 0;
+ 		}
+ 		if (strcmp(encoding, "raw") != 0)
+ 			return -EINVAL;
+ 		/*
+ 		 * Raw RSA cannot differentiate between different hash
+ 		 * algorithms.
+ 		 */
+ 		if (hash_algo)
+ 			return -EINVAL;
+ 		*sig = false;
+ 	} else if (strncmp(pkey->pkey_algo, "ecdsa", 5) == 0) {
+ 		if (strcmp(encoding, "x962") != 0)
+ 			return -EINVAL;
+ 		/*
+ 		 * ECDSA signatures are taken over a raw hash, so they don't
+ 		 * differentiate between different hash algorithms.  That means
+ 		 * that the verifier should hard-code a specific hash algorithm.
+ 		 * Unfortunately, in practice ECDSA is used with multiple SHAs,
+ 		 * so we have to allow all of them and not just one.
+ 		 */
+ 		if (!hash_algo)
+ 			return -EINVAL;
+ 		if (strcmp(hash_algo, "sha1") != 0 &&
+ 		    strcmp(hash_algo, "sha224") != 0 &&
+ 		    strcmp(hash_algo, "sha256") != 0 &&
+ 		    strcmp(hash_algo, "sha384") != 0 &&
+ 		    strcmp(hash_algo, "sha512") != 0)
+ 			return -EINVAL;
+ 	} else if (strcmp(pkey->pkey_algo, "sm2") == 0) {
+ 		if (strcmp(encoding, "raw") != 0)
+ 			return -EINVAL;
+ 		if (!hash_algo)
+ 			return -EINVAL;
+ 		if (strcmp(hash_algo, "sm3") != 0)
+ 			return -EINVAL;
+ 	} else if (strcmp(pkey->pkey_algo, "ecrdsa") == 0) {
+ 		if (strcmp(encoding, "raw") != 0)
+ 			return -EINVAL;
+ 		if (!hash_algo)
+ 			return -EINVAL;
+ 		if (strcmp(hash_algo, "streebog256") != 0 &&
+ 		    strcmp(hash_algo, "streebog512") != 0)
+ 			return -EINVAL;
+ 	} else {
+ 		/* Unknown public key algorithm */
+ 		return -ENOPKG;
+ 	}
+ 	if (strscpy(alg_name, pkey->pkey_algo, CRYPTO_MAX_ALG_NAME) < 0)
+ 		return -EINVAL;
+ 	return 0;
+ }
+ 
+ static u8 *pkey_pack_u32(u8 *dst, u32 val)
+ {
+ 	memcpy(dst, &val, sizeof(val));
+ 	return dst + sizeof(val);
+ }
+ 
+ /*
+  * Query information about a key.
+  */
+ static int software_key_query(const struct kernel_pkey_params *params,
+ 			      struct kernel_pkey_query *info)
+ {
+ 	struct crypto_akcipher *tfm;
+ 	struct public_key *pkey = params->key->payload.data[asym_crypto];
+ 	char alg_name[CRYPTO_MAX_ALG_NAME];
+ 	struct crypto_sig *sig;
+ 	u8 *key, *ptr;
+ 	int ret, len;
+ 	bool issig;
+ 
+ 	ret = software_key_determine_akcipher(pkey, params->encoding,
+ 					      params->hash_algo, alg_name,
+ 					      &issig, kernel_pkey_sign);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	key = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,
+ 		      GFP_KERNEL);
+ 	if (!key)
+ 		return -ENOMEM;
+ 
+ 	memcpy(key, pkey->key, pkey->keylen);
+ 	ptr = key + pkey->keylen;
+ 	ptr = pkey_pack_u32(ptr, pkey->algo);
+ 	ptr = pkey_pack_u32(ptr, pkey->paramlen);
+ 	memcpy(ptr, pkey->params, pkey->paramlen);
+ 
+ 	if (issig) {
+ 		sig = crypto_alloc_sig(alg_name, 0, 0);
+ 		if (IS_ERR(sig)) {
+ 			ret = PTR_ERR(sig);
+ 			goto error_free_key;
+ 		}
+ 
+ 		if (pkey->key_is_private)
+ 			ret = crypto_sig_set_privkey(sig, key, pkey->keylen);
+ 		else
+ 			ret = crypto_sig_set_pubkey(sig, key, pkey->keylen);
+ 		if (ret < 0)
+ 			goto error_free_tfm;
+ 
+ 		len = crypto_sig_maxsize(sig);
+ 
+ 		info->supported_ops = KEYCTL_SUPPORTS_VERIFY;
+ 		if (pkey->key_is_private)
+ 			info->supported_ops |= KEYCTL_SUPPORTS_SIGN;
+ 
+ 		if (strcmp(params->encoding, "pkcs1") == 0) {
+ 			info->supported_ops |= KEYCTL_SUPPORTS_ENCRYPT;
+ 			if (pkey->key_is_private)
+ 				info->supported_ops |= KEYCTL_SUPPORTS_DECRYPT;
+ 		}
+ 	} else {
+ 		tfm = crypto_alloc_akcipher(alg_name, 0, 0);
+ 		if (IS_ERR(tfm)) {
+ 			ret = PTR_ERR(tfm);
+ 			goto error_free_key;
+ 		}
+ 
+ 		if (pkey->key_is_private)
+ 			ret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);
+ 		else
+ 			ret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);
+ 		if (ret < 0)
+ 			goto error_free_tfm;
+ 
+ 		len = crypto_akcipher_maxsize(tfm);
+ 
+ 		info->supported_ops = KEYCTL_SUPPORTS_ENCRYPT;
+ 		if (pkey->key_is_private)
+ 			info->supported_ops |= KEYCTL_SUPPORTS_DECRYPT;
+ 	}
+ 
+ 	info->key_size = len * 8;
+ 
+ 	if (strncmp(pkey->pkey_algo, "ecdsa", 5) == 0) {
+ 		/*
+ 		 * ECDSA key sizes are much smaller than RSA, and thus could
+ 		 * operate on (hashed) inputs that are larger than key size.
+ 		 * For example SHA384-hashed input used with secp256r1
+ 		 * based keys.  Set max_data_size to be at least as large as
+ 		 * the largest supported hash size (SHA512)
+ 		 */
+ 		info->max_data_size = 64;
+ 
+ 		/*
+ 		 * Verify takes ECDSA-Sig (described in RFC 5480) as input,
+ 		 * which is actually 2 'key_size'-bit integers encoded in
+ 		 * ASN.1.  Account for the ASN.1 encoding overhead here.
+ 		 */
+ 		info->max_sig_size = 2 * (len + 3) + 2;
+ 	} else {
+ 		info->max_data_size = len;
+ 		info->max_sig_size = len;
+ 	}
+ 
+ 	info->max_enc_size = len;
+ 	info->max_dec_size = len;
+ 
+ 	ret = 0;
+ 
+ error_free_tfm:
+ 	if (issig)
+ 		crypto_free_sig(sig);
+ 	else
+ 		crypto_free_akcipher(tfm);
+ error_free_key:
+ 	kfree_sensitive(key);
+ 	pr_devel("<==%s() = %d\n", __func__, ret);
+ 	return ret;
+ }
+ 
+ /*
+  * Do encryption, decryption and signing ops.
+  */
+ static int software_key_eds_op(struct kernel_pkey_params *params,
+ 			       const void *in, void *out)
+ {
+ 	const struct public_key *pkey = params->key->payload.data[asym_crypto];
+ 	char alg_name[CRYPTO_MAX_ALG_NAME];
+ 	struct crypto_akcipher *tfm;
+ 	struct crypto_sig *sig;
+ 	char *key, *ptr;
+ 	bool issig;
+ 	int ksz;
+ 	int ret;
+ 
+ 	pr_devel("==>%s()\n", __func__);
+ 
+ 	ret = software_key_determine_akcipher(pkey, params->encoding,
+ 					      params->hash_algo, alg_name,
+ 					      &issig, params->op);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	key = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,
+ 		      GFP_KERNEL);
+ 	if (!key)
+ 		return -ENOMEM;
+ 
+ 	memcpy(key, pkey->key, pkey->keylen);
+ 	ptr = key + pkey->keylen;
+ 	ptr = pkey_pack_u32(ptr, pkey->algo);
+ 	ptr = pkey_pack_u32(ptr, pkey->paramlen);
+ 	memcpy(ptr, pkey->params, pkey->paramlen);
+ 
+ 	if (issig) {
+ 		sig = crypto_alloc_sig(alg_name, 0, 0);
+ 		if (IS_ERR(sig)) {
+ 			ret = PTR_ERR(sig);
+ 			goto error_free_key;
+ 		}
+ 
+ 		if (pkey->key_is_private)
+ 			ret = crypto_sig_set_privkey(sig, key, pkey->keylen);
+ 		else
+ 			ret = crypto_sig_set_pubkey(sig, key, pkey->keylen);
+ 		if (ret)
+ 			goto error_free_tfm;
+ 
+ 		ksz = crypto_sig_maxsize(sig);
+ 	} else {
+ 		tfm = crypto_alloc_akcipher(alg_name, 0, 0);
+ 		if (IS_ERR(tfm)) {
+ 			ret = PTR_ERR(tfm);
+ 			goto error_free_key;
+ 		}
+ 
+ 		if (pkey->key_is_private)
+ 			ret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);
+ 		else
+ 			ret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);
+ 		if (ret)
+ 			goto error_free_tfm;
+ 
+ 		ksz = crypto_akcipher_maxsize(tfm);
+ 	}
+ 
+ 	ret = -EINVAL;
+ 
+ 	/* Perform the encryption calculation. */
+ 	switch (params->op) {
+ 	case kernel_pkey_encrypt:
+ 		if (issig)
+ 			break;
+ 		ret = crypto_akcipher_sync_encrypt(tfm, in, params->in_len,
+ 						   out, params->out_len);
+ 		break;
+ 	case kernel_pkey_decrypt:
+ 		if (issig)
+ 			break;
+ 		ret = crypto_akcipher_sync_decrypt(tfm, in, params->in_len,
+ 						   out, params->out_len);
+ 		break;
+ 	case kernel_pkey_sign:
+ 		if (!issig)
+ 			break;
+ 		ret = crypto_sig_sign(sig, in, params->in_len,
+ 				      out, params->out_len);
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	if (ret == 0)
+ 		ret = ksz;
+ 
+ error_free_tfm:
+ 	if (issig)
+ 		crypto_free_sig(sig);
+ 	else
+ 		crypto_free_akcipher(tfm);
+ error_free_key:
+ 	kfree_sensitive(key);
+ 	pr_devel("<==%s() = %d\n", __func__, ret);
+ 	return ret;
+ }
+ 
+ /*
++>>>>>>> 9f3fa6bc4ff8 (KEYS: use kfree_sensitive with key)
   * Verify a signature using a public key.
   */
  int public_key_verify_signature(const struct public_key *pkey,
@@@ -101,49 -417,33 +425,54 @@@
  	if (IS_ERR(tfm))
  		return PTR_ERR(tfm);
  
 -	key = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,
 -		      GFP_KERNEL);
 -	if (!key) {
 -		ret = -ENOMEM;
 +	ret = -ENOMEM;
 +	req = akcipher_request_alloc(tfm, GFP_KERNEL);
 +	if (!req)
  		goto error_free_tfm;
 -	}
 -
 -	memcpy(key, pkey->key, pkey->keylen);
 -	ptr = key + pkey->keylen;
 -	ptr = pkey_pack_u32(ptr, pkey->algo);
 -	ptr = pkey_pack_u32(ptr, pkey->paramlen);
 -	memcpy(ptr, pkey->params, pkey->paramlen);
  
 -	if (pkey->key_is_private)
 -		ret = crypto_sig_set_privkey(tfm, key, pkey->keylen);
 -	else
 -		ret = crypto_sig_set_pubkey(tfm, key, pkey->keylen);
 +	ret = crypto_akcipher_set_pub_key(tfm, pkey->key, pkey->keylen);
  	if (ret)
 -		goto error_free_key;
 -
 -	ret = crypto_sig_verify(tfm, sig->s, sig->s_size,
 -				sig->digest, sig->digest_size);
 -
 +		goto error_free_req;
 +
 +	ret = -ENOMEM;
 +	outlen = crypto_akcipher_maxsize(tfm);
 +	output = kmalloc(outlen, GFP_KERNEL);
 +	if (!output)
 +		goto error_free_req;
 +
++<<<<<<< HEAD
 +	sg_init_one(&sig_sg, sig->s, sig->s_size);
 +	sg_init_one(&digest_sg, output, outlen);
 +	akcipher_request_set_crypt(req, &sig_sg, &digest_sg, sig->s_size,
 +				   outlen);
 +	crypto_init_wait(&cwait);
 +	akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |
 +				      CRYPTO_TFM_REQ_MAY_SLEEP,
 +				      crypto_req_done, &cwait);
 +
 +	/* Perform the verification calculation.  This doesn't actually do the
 +	 * verification, but rather calculates the hash expected by the
 +	 * signature and returns that to us.
 +	 */
 +	ret = crypto_wait_req(crypto_akcipher_verify(req), &cwait);
 +	if (ret)
 +		goto out_free_output;
 +
 +	/* Do the actual verification step. */
 +	if (req->dst_len != sig->digest_size ||
 +	    memcmp(sig->digest, output, sig->digest_size) != 0)
 +		ret = -EKEYREJECTED;
 +
 +out_free_output:
 +	kfree(output);
 +error_free_req:
 +	akcipher_request_free(req);
++=======
+ error_free_key:
+ 	kfree_sensitive(key);
++>>>>>>> 9f3fa6bc4ff8 (KEYS: use kfree_sensitive with key)
  error_free_tfm:
 -	crypto_free_sig(tfm);
 +	crypto_free_akcipher(tfm);
  	pr_devel("<==%s() = %d\n", __func__, ret);
  	if (WARN_ON_ONCE(ret > 0))
  		ret = -EINVAL;
* Unmerged path crypto/asymmetric_keys/public_key.c
