gro: fix ownership transfer

jira LE-1907
cve CVE-2024-35890
Rebuild_History Non-Buildable kernel-4.18.0-553.8.1.el8_10
commit-author Antoine Tenart <atenart@kernel.org>
commit ed4cccef64c1d0d5b91e69f7a8a6697c3a865486
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.8.1.el8_10/ed4cccef.failed

If packets are GROed with fraglist they might be segmented later on and
continue their journey in the stack. In skb_segment_list those skbs can
be reused as-is. This is an issue as their destructor was removed in
skb_gro_receive_list but not the reference to their socket, and then
they can't be orphaned. Fix this by also removing the reference to the
socket.

For example this could be observed,

  kernel BUG at include/linux/skbuff.h:3131!  (skb_orphan)
  RIP: 0010:ip6_rcv_core+0x11bc/0x19a0
  Call Trace:
   ipv6_list_rcv+0x250/0x3f0
   __netif_receive_skb_list_core+0x49d/0x8f0
   netif_receive_skb_list_internal+0x634/0xd40
   napi_complete_done+0x1d2/0x7d0
   gro_cell_poll+0x118/0x1f0

A similar construction is found in skb_gro_receive, apply the same
change there.

Fixes: 5e10da5385d2 ("skbuff: allow 'slow_gro' for skb carring sock reference")
	Signed-off-by: Antoine Tenart <atenart@kernel.org>
	Reviewed-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed4cccef64c1d0d5b91e69f7a8a6697c3a865486)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/gro.c
#	net/ipv4/udp_offload.c
diff --cc net/ipv4/udp_offload.c
index 0ec0dafc3928,3bb69464930b..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -428,6 -433,34 +428,37 @@@ out
  	return segs;
  }
  
++<<<<<<< HEAD
++=======
+ static int skb_gro_receive_list(struct sk_buff *p, struct sk_buff *skb)
+ {
+ 	if (unlikely(p->len + skb->len >= 65536))
+ 		return -E2BIG;
+ 
+ 	if (NAPI_GRO_CB(p)->last == p)
+ 		skb_shinfo(p)->frag_list = skb;
+ 	else
+ 		NAPI_GRO_CB(p)->last->next = skb;
+ 
+ 	skb_pull(skb, skb_gro_offset(skb));
+ 
+ 	NAPI_GRO_CB(p)->last = skb;
+ 	NAPI_GRO_CB(p)->count++;
+ 	p->data_len += skb->len;
+ 
+ 	/* sk ownership - if any - completely transferred to the aggregated packet */
+ 	skb->destructor = NULL;
+ 	skb->sk = NULL;
+ 	p->truesize += skb->truesize;
+ 	p->len += skb->len;
+ 
+ 	NAPI_GRO_CB(skb)->same_flow = 1;
+ 
+ 	return 0;
+ }
+ 
+ 
++>>>>>>> ed4cccef64c1 (gro: fix ownership transfer)
  #define UDP_GRO_CNT_MAX 64
  static struct sk_buff *udp_gro_receive_segment(struct list_head *head,
  					       struct sk_buff *skb)
* Unmerged path net/core/gro.c
* Unmerged path net/core/gro.c
* Unmerged path net/ipv4/udp_offload.c
