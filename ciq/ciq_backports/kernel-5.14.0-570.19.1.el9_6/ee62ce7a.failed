page_pool: Track DMA-mapped pages and unmap them when destroying the pool

jira LE-3187
Rebuild_History Non-Buildable kernel-5.14.0-570.19.1.el9_6
commit-author Toke Høiland-Jørgensen <toke@redhat.com>
commit ee62ce7a1d909ccba0399680a03c2dee83bcae95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.19.1.el9_6/ee62ce7a.failed

When enabling DMA mapping in page_pool, pages are kept DMA mapped until
they are released from the pool, to avoid the overhead of re-mapping the
pages every time they are used. This causes resource leaks and/or
crashes when there are pages still outstanding while the device is torn
down, because page_pool will attempt an unmap through a non-existent DMA
device on the subsequent page return.

To fix this, implement a simple tracking of outstanding DMA-mapped pages
in page pool using an xarray. This was first suggested by Mina[0], and
turns out to be fairly straight forward: We simply store pointers to
pages directly in the xarray with xa_alloc() when they are first DMA
mapped, and remove them from the array on unmap. Then, when a page pool
is torn down, it can simply walk the xarray and unmap all pages still
present there before returning, which also allows us to get rid of the
get/put_device() calls in page_pool. Using xa_cmpxchg(), no additional
synchronisation is needed, as a page will only ever be unmapped once.

To avoid having to walk the entire xarray on unmap to find the page
reference, we stash the ID assigned by xa_alloc() into the page
structure itself, using the upper bits of the pp_magic field. This
requires a couple of defines to avoid conflicting with the
POINTER_POISON_DELTA define, but this is all evaluated at compile-time,
so does not affect run-time performance. The bitmap calculations in this
patch gives the following number of bits for different architectures:

- 23 bits on 32-bit architectures
- 21 bits on PPC64 (because of the definition of ILLEGAL_POINTER_VALUE)
- 32 bits on other 64-bit architectures

Stashing a value into the unused bits of pp_magic does have the effect
that it can make the value stored there lie outside the unmappable
range (as governed by the mmap_min_addr sysctl), for architectures that
don't define ILLEGAL_POINTER_VALUE. This means that if one of the
pointers that is aliased to the pp_magic field (such as page->lru.next)
is dereferenced while the page is owned by page_pool, that could lead to
a dereference into userspace, which is a security concern. The risk of
this is mitigated by the fact that (a) we always clear pp_magic before
releasing a page from page_pool, and (b) this would need a
use-after-free bug for struct page, which can have many other risks
since page->lru.next is used as a generic list pointer in multiple
places in the kernel. As such, with this patch we take the position that
this risk is negligible in practice. For more discussion, see[1].

Since all the tracking added in this patch is performed on DMA
map/unmap, no additional code is needed in the fast path, meaning the
performance overhead of this tracking is negligible there. A
micro-benchmark shows that the total overhead of the tracking itself is
about 400 ns (39 cycles(tsc) 395.218 ns; sum for both map and unmap[2]).
Since this cost is only paid on DMA map and unmap, it seems like an
acceptable cost to fix the late unmap issue. Further optimisation can
narrow the cases where this cost is paid (for instance by eliding the
tracking when DMA map/unmap is a no-op).

The extra memory needed to track the pages is neatly encapsulated inside
xarray, which uses the 'struct xa_node' structure to track items. This
structure is 576 bytes long, with slots for 64 items, meaning that a
full node occurs only 9 bytes of overhead per slot it tracks (in
practice, it probably won't be this efficient, but in any case it should
be an acceptable overhead).

[0] https://lore.kernel.org/all/CAHS8izPg7B5DwKfSuzz-iOop_YRbk3Sd6Y4rX7KBG9DcVJcyWg@mail.gmail.com/
[1] https://lore.kernel.org/r/20250320023202.GA25514@openwall.com
[2] https://lore.kernel.org/r/ae07144c-9295-4c9d-a400-153bb689fe9e@huawei.com

	Reported-by: Yonglong Liu <liuyonglong@huawei.com>
Closes: https://lore.kernel.org/r/8743264a-9700-4227-a556-5f931c720211@huawei.com
Fixes: ff7d6b27f894 ("page_pool: refurbish version of page_pool code")
	Suggested-by: Mina Almasry <almasrymina@google.com>
	Reviewed-by: Mina Almasry <almasrymina@google.com>
	Reviewed-by: Jesper Dangaard Brouer <hawk@kernel.org>
	Tested-by: Jesper Dangaard Brouer <hawk@kernel.org>
	Tested-by: Qiuling Ren <qren@redhat.com>
	Tested-by: Yuying Ma <yuma@redhat.com>
	Tested-by: Yonglong Liu <liuyonglong@huawei.com>
	Acked-by: Jesper Dangaard Brouer <hawk@kernel.org>
	Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
Link: https://patch.msgid.link/20250409-page-pool-track-dma-v9-2-6a9ef2e0cba8@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit ee62ce7a1d909ccba0399680a03c2dee83bcae95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
#	include/net/page_pool/types.h
#	net/core/netmem_priv.h
#	net/core/page_pool.c
diff --cc include/linux/mm.h
index 5d9b789ea0a7,130d3c9d2ee4..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -4138,9 -4198,112 +4138,117 @@@ static inline void accept_memory(phys_a
  
  static inline bool pfn_is_unaccepted_memory(unsigned long pfn)
  {
 -	return range_contains_unaccepted_memory(pfn << PAGE_SHIFT, PAGE_SIZE);
 +	phys_addr_t paddr = pfn << PAGE_SHIFT;
 +
 +	return range_contains_unaccepted_memory(paddr, paddr + PAGE_SIZE);
  }
  
++<<<<<<< HEAD
++=======
+ void vma_pgtable_walk_begin(struct vm_area_struct *vma);
+ void vma_pgtable_walk_end(struct vm_area_struct *vma);
+ 
+ int reserve_mem_find_by_name(const char *name, phys_addr_t *start, phys_addr_t *size);
+ int reserve_mem_release_by_name(const char *name);
+ 
+ #ifdef CONFIG_64BIT
+ int do_mseal(unsigned long start, size_t len_in, unsigned long flags);
+ #else
+ static inline int do_mseal(unsigned long start, size_t len_in, unsigned long flags)
+ {
+ 	/* noop on 32 bit */
+ 	return 0;
+ }
+ #endif
+ 
+ /*
+  * user_alloc_needs_zeroing checks if a user folio from page allocator needs to
+  * be zeroed or not.
+  */
+ static inline bool user_alloc_needs_zeroing(void)
+ {
+ 	/*
+ 	 * for user folios, arch with cache aliasing requires cache flush and
+ 	 * arc changes folio->flags to make icache coherent with dcache, so
+ 	 * always return false to make caller use
+ 	 * clear_user_page()/clear_user_highpage().
+ 	 */
+ 	return cpu_dcache_is_aliasing() || cpu_icache_is_aliasing() ||
+ 	       !static_branch_maybe(CONFIG_INIT_ON_ALLOC_DEFAULT_ON,
+ 				   &init_on_alloc);
+ }
+ 
+ int arch_get_shadow_stack_status(struct task_struct *t, unsigned long __user *status);
+ int arch_set_shadow_stack_status(struct task_struct *t, unsigned long status);
+ int arch_lock_shadow_stack_status(struct task_struct *t, unsigned long status);
+ 
+ 
+ /*
+  * mseal of userspace process's system mappings.
+  */
+ #ifdef CONFIG_MSEAL_SYSTEM_MAPPINGS
+ #define VM_SEALED_SYSMAP	VM_SEALED
+ #else
+ #define VM_SEALED_SYSMAP	VM_NONE
+ #endif
+ 
+ /*
+  * DMA mapping IDs for page_pool
+  *
+  * When DMA-mapping a page, page_pool allocates an ID (from an xarray) and
+  * stashes it in the upper bits of page->pp_magic. We always want to be able to
+  * unambiguously identify page pool pages (using page_pool_page_is_pp()). Non-PP
+  * pages can have arbitrary kernel pointers stored in the same field as pp_magic
+  * (since it overlaps with page->lru.next), so we must ensure that we cannot
+  * mistake a valid kernel pointer with any of the values we write into this
+  * field.
+  *
+  * On architectures that set POISON_POINTER_DELTA, this is already ensured,
+  * since this value becomes part of PP_SIGNATURE; meaning we can just use the
+  * space between the PP_SIGNATURE value (without POISON_POINTER_DELTA), and the
+  * lowest bits of POISON_POINTER_DELTA. On arches where POISON_POINTER_DELTA is
+  * 0, we make sure that we leave the two topmost bits empty, as that guarantees
+  * we won't mistake a valid kernel pointer for a value we set, regardless of the
+  * VMSPLIT setting.
+  *
+  * Altogether, this means that the number of bits available is constrained by
+  * the size of an unsigned long (at the upper end, subtracting two bits per the
+  * above), and the definition of PP_SIGNATURE (with or without
+  * POISON_POINTER_DELTA).
+  */
+ #define PP_DMA_INDEX_SHIFT (1 + __fls(PP_SIGNATURE - POISON_POINTER_DELTA))
+ #if POISON_POINTER_DELTA > 0
+ /* PP_SIGNATURE includes POISON_POINTER_DELTA, so limit the size of the DMA
+  * index to not overlap with that if set
+  */
+ #define PP_DMA_INDEX_BITS MIN(32, __ffs(POISON_POINTER_DELTA) - PP_DMA_INDEX_SHIFT)
+ #else
+ /* Always leave out the topmost two; see above. */
+ #define PP_DMA_INDEX_BITS MIN(32, BITS_PER_LONG - PP_DMA_INDEX_SHIFT - 2)
+ #endif
+ 
+ #define PP_DMA_INDEX_MASK GENMASK(PP_DMA_INDEX_BITS + PP_DMA_INDEX_SHIFT - 1, \
+ 				  PP_DMA_INDEX_SHIFT)
+ 
+ /* Mask used for checking in page_pool_page_is_pp() below. page->pp_magic is
+  * OR'ed with PP_SIGNATURE after the allocation in order to preserve bit 0 for
+  * the head page of compound page and bit 1 for pfmemalloc page, as well as the
+  * bits used for the DMA index. page_is_pfmemalloc() is checked in
+  * __page_pool_put_page() to avoid recycling the pfmemalloc page.
+  */
+ #define PP_MAGIC_MASK ~(PP_DMA_INDEX_MASK | 0x3UL)
+ 
+ #ifdef CONFIG_PAGE_POOL
+ static inline bool page_pool_page_is_pp(struct page *page)
+ {
+ 	return (page->pp_magic & PP_MAGIC_MASK) == PP_SIGNATURE;
+ }
+ #else
+ static inline bool page_pool_page_is_pp(struct page *page)
+ {
+ 	return false;
+ }
+ #endif
+ 
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  #endif /* _LINUX_MM_H */
diff --cc include/net/page_pool/types.h
index 4f4bd6c16884,431b593de709..000000000000
--- a/include/net/page_pool/types.h
+++ b/include/net/page_pool/types.h
@@@ -6,8 -6,8 +6,13 @@@
  #include <linux/dma-direction.h>
  #include <linux/ptr_ring.h>
  #include <linux/types.h>
++<<<<<<< HEAD
 +
 +#include <linux/rh_kabi.h>
++=======
+ #include <linux/xarray.h>
+ #include <net/netmem.h>
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  
  #define PP_FLAG_DMA_MAP		BIT(0) /* Should page_pool do the DMA
  					* map/unmap
@@@ -21,9 -21,22 +26,12 @@@
  					* device driver responsibility
  					*/
  #define PP_FLAG_SYSTEM_POOL	BIT(2) /* Global system page_pool */
 -
 -/* Allow unreadable (net_iov backed) netmem in this page_pool. Drivers setting
 - * this must be able to support unreadable netmem, where netmem_address() would
 - * return NULL. This flag should not be set for header page_pools.
 - *
 - * If the driver sets PP_FLAG_ALLOW_UNREADABLE_NETMEM, it should also set
 - * page_pool_params.slow.queue_idx.
 - */
 -#define PP_FLAG_ALLOW_UNREADABLE_NETMEM BIT(3)
 -
  #define PP_FLAG_ALL		(PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV | \
 -				 PP_FLAG_SYSTEM_POOL | PP_FLAG_ALLOW_UNREADABLE_NETMEM)
 +				 PP_FLAG_SYSTEM_POOL)
  
+ /* Index limit to stay within PP_DMA_INDEX_BITS for DMA indices */
+ #define PP_DMA_INDEX_LIMIT XA_LIMIT(1, BIT(PP_DMA_INDEX_BITS) - 1)
+ 
  /*
   * Fast allocation side cache array/stack
   *
@@@ -206,6 -222,11 +214,14 @@@ struct page_pool 
  	 */
  	struct ptr_ring ring;
  
++<<<<<<< HEAD
++=======
+ 	void *mp_priv;
+ 	const struct memory_provider_ops *mp_ops;
+ 
+ 	struct xarray dma_mapped;
+ 
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  #ifdef CONFIG_PAGE_POOL_STATS
  	/* recycle stats are per-cpu to avoid locking */
  	struct page_pool_recycle_stats __percpu *recycle_stats;
diff --cc net/core/page_pool.c
index cf5c367bffa3,2b7684865941..000000000000
--- a/net/core/page_pool.c
+++ b/net/core/page_pool.c
@@@ -263,10 -276,44 +263,9 @@@ static int page_pool_init(struct page_p
  	/* Driver calling page_pool_create() also call page_pool_destroy() */
  	refcount_set(&pool->user_cnt, 1);
  
- 	if (pool->dma_map)
- 		get_device(pool->p.dev);
+ 	xa_init_flags(&pool->dma_mapped, XA_FLAGS_ALLOC1);
  
 -	if (pool->slow.flags & PP_FLAG_ALLOW_UNREADABLE_NETMEM) {
 -		netdev_assert_locked(pool->slow.netdev);
 -		rxq = __netif_get_rx_queue(pool->slow.netdev,
 -					   pool->slow.queue_idx);
 -		pool->mp_priv = rxq->mp_params.mp_priv;
 -		pool->mp_ops = rxq->mp_params.mp_ops;
 -	}
 -
 -	if (pool->mp_ops) {
 -		if (!pool->dma_map || !pool->dma_sync)
 -			return -EOPNOTSUPP;
 -
 -		if (WARN_ON(!is_kernel_rodata((unsigned long)pool->mp_ops))) {
 -			err = -EFAULT;
 -			goto free_ptr_ring;
 -		}
 -
 -		err = pool->mp_ops->init(pool);
 -		if (err) {
 -			pr_warn("%s() mem-provider init failed %d\n", __func__,
 -				err);
 -			goto free_ptr_ring;
 -		}
 -
 -		static_branch_inc(&page_pool_mem_providers);
 -	}
 -
  	return 0;
 -
 -free_ptr_ring:
 -	ptr_ring_cleanup(&pool->ring, NULL);
 -#ifdef CONFIG_PAGE_POOL_STATS
 -	if (!pool->system)
 -		free_percpu(pool->recycle_stats);
 -#endif
 -	return err;
  }
  
  static void page_pool_uninit(struct page_pool *pool)
@@@ -413,16 -457,24 +410,32 @@@ static void __page_pool_dma_sync_for_de
  
  static __always_inline void
  page_pool_dma_sync_for_device(const struct page_pool *pool,
 -			      netmem_ref netmem,
 +			      const struct page *page,
  			      u32 dma_sync_size)
  {
++<<<<<<< HEAD
 +	if (pool->dma_sync && dma_dev_need_sync(pool->p.dev))
 +		__page_pool_dma_sync_for_device(pool, page, dma_sync_size);
 +}
 +
 +static bool page_pool_dma_map(struct page_pool *pool, struct page *page)
++=======
+ 	if (pool->dma_sync && dma_dev_need_sync(pool->p.dev)) {
+ 		rcu_read_lock();
+ 		/* re-check under rcu_read_lock() to sync with page_pool_scrub() */
+ 		if (pool->dma_sync)
+ 			__page_pool_dma_sync_for_device(pool, netmem,
+ 							dma_sync_size);
+ 		rcu_read_unlock();
+ 	}
+ }
+ 
+ static bool page_pool_dma_map(struct page_pool *pool, netmem_ref netmem, gfp_t gfp)
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  {
  	dma_addr_t dma;
+ 	int err;
+ 	u32 id;
  
  	/* Setup DMA mapping: use 'struct page' area for storing DMA-addr
  	 * since dma_addr_t can be either 32 or 64 bits and does not always fit
@@@ -436,10 -488,24 +449,32 @@@
  	if (dma_mapping_error(pool->p.dev, dma))
  		return false;
  
++<<<<<<< HEAD
 +	if (page_pool_set_dma_addr(page, dma))
++=======
+ 	if (page_pool_set_dma_addr_netmem(netmem, dma)) {
+ 		WARN_ONCE(1, "unexpected DMA address, please report to netdev@");
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  		goto unmap_failed;
+ 	}
  
++<<<<<<< HEAD
 +	page_pool_dma_sync_for_device(pool, page, pool->p.max_len);
++=======
+ 	if (in_softirq())
+ 		err = xa_alloc(&pool->dma_mapped, &id, netmem_to_page(netmem),
+ 			       PP_DMA_INDEX_LIMIT, gfp);
+ 	else
+ 		err = xa_alloc_bh(&pool->dma_mapped, &id, netmem_to_page(netmem),
+ 				  PP_DMA_INDEX_LIMIT, gfp);
+ 	if (err) {
+ 		WARN_ONCE(err != -ENOMEM, "couldn't track DMA mapping, please report to netdev@");
+ 		goto unset_failed;
+ 	}
+ 
+ 	netmem_set_dma_index(netmem, id);
+ 	page_pool_dma_sync_for_device(pool, netmem, pool->p.max_len);
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  
  	return true;
  
@@@ -484,7 -528,7 +520,11 @@@ static struct page *__page_pool_alloc_p
  	if (unlikely(!page))
  		return NULL;
  
++<<<<<<< HEAD
 +	if (pool->dma_map && unlikely(!page_pool_dma_map(pool, page))) {
++=======
+ 	if (pool->dma_map && unlikely(!page_pool_dma_map(pool, page_to_netmem(page), gfp))) {
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  		put_page(page);
  		return NULL;
  	}
@@@ -529,9 -573,9 +569,15 @@@ static struct page *__page_pool_alloc_p
  	 * page element have not been (possibly) DMA mapped.
  	 */
  	for (i = 0; i < nr_pages; i++) {
++<<<<<<< HEAD
 +		page = pool->alloc.cache[i];
 +		if (dma_map && unlikely(!page_pool_dma_map(pool, page))) {
 +			put_page(page);
++=======
+ 		netmem = pool->alloc.cache[i];
+ 		if (dma_map && unlikely(!page_pool_dma_map(pool, netmem, gfp))) {
+ 			put_page(netmem_to_page(netmem));
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  			continue;
  		}
  
@@@ -597,9 -651,33 +643,11 @@@ s32 page_pool_inflight(const struct pag
  	return inflight;
  }
  
 -void page_pool_set_pp_info(struct page_pool *pool, netmem_ref netmem)
 -{
 -	netmem_set_pp(netmem, pool);
 -	netmem_or_pp_magic(netmem, PP_SIGNATURE);
 -
 -	/* Ensuring all pages have been split into one fragment initially:
 -	 * page_pool_set_pp_info() is only called once for every page when it
 -	 * is allocated from the page allocator and page_pool_fragment_page()
 -	 * is dirtying the same cache line as the page->pp_magic above, so
 -	 * the overhead is negligible.
 -	 */
 -	page_pool_fragment_netmem(netmem, 1);
 -	if (pool->has_init_callback)
 -		pool->slow.init_callback(netmem, pool->slow.init_arg);
 -}
 -
 -void page_pool_clear_pp_info(netmem_ref netmem)
 -{
 -	netmem_clear_pp_magic(netmem);
 -	netmem_set_pp(netmem, NULL);
 -}
 -
 -static __always_inline void __page_pool_release_page_dma(struct page_pool *pool,
 -							 netmem_ref netmem)
 +static __always_inline
 +void __page_pool_release_page_dma(struct page_pool *pool, struct page *page)
  {
+ 	struct page *old, *page = netmem_to_page(netmem);
+ 	unsigned long id;
  	dma_addr_t dma;
  
  	if (!pool->dma_map)
@@@ -608,13 -686,25 +656,33 @@@
  		 */
  		return;
  
++<<<<<<< HEAD
 +	dma = page_pool_get_dma_addr(page);
++=======
+ 	id = netmem_get_dma_index(netmem);
+ 	if (!id)
+ 		return;
+ 
+ 	if (in_softirq())
+ 		old = xa_cmpxchg(&pool->dma_mapped, id, page, NULL, 0);
+ 	else
+ 		old = xa_cmpxchg_bh(&pool->dma_mapped, id, page, NULL, 0);
+ 	if (old != page)
+ 		return;
+ 
+ 	dma = page_pool_get_dma_addr_netmem(netmem);
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  
  	/* When page is unmapped, it cannot be returned to our pool */
  	dma_unmap_page_attrs(pool->p.dev, dma,
  			     PAGE_SIZE << pool->p.order, pool->p.dma_dir,
  			     DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING);
++<<<<<<< HEAD
 +	page_pool_set_dma_addr(page, 0);
++=======
+ 	page_pool_set_dma_addr_netmem(netmem, 0);
+ 	netmem_set_dma_index(netmem, 0);
++>>>>>>> ee62ce7a1d90 (page_pool: Track DMA-mapped pages and unmap them when destroying the pool)
  }
  
  /* Disconnects a page (from a page_pool).  API users can have a need
* Unmerged path net/core/netmem_priv.h
* Unmerged path include/linux/mm.h
diff --git a/include/linux/poison.h b/include/linux/poison.h
index 11b53bcc7acd..17e69ca9a684 100644
--- a/include/linux/poison.h
+++ b/include/linux/poison.h
@@ -79,6 +79,10 @@
 #define KEY_DESTROY		0xbd
 
 /********** net/core/page_pool.c **********/
+/*
+ * page_pool uses additional free bits within this value to store data, see the
+ * definition of PP_DMA_INDEX_MASK in mm.h
+ */
 #define PP_SIGNATURE		(0x40 + POISON_POINTER_DELTA)
 
 /********** net/core/skbuff.c **********/
* Unmerged path include/net/page_pool/types.h
* Unmerged path net/core/netmem_priv.h
* Unmerged path net/core/page_pool.c
