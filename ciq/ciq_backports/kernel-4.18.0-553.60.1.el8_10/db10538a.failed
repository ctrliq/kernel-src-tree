tcp: add tcp_sock_set_cork

jira LE-3571
Rebuild_History Non-Buildable kernel-4.18.0-553.60.1.el8_10
commit-author Christoph Hellwig <hch@lst.de>
commit db10538a4b997a77a1fd561adaaa58afc7dcfa2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.60.1.el8_10/db10538a.failed

Add a helper to directly set the TCP_CORK sockopt from kernel space
without going through a fake uaccess.  Cleanup the callers to avoid
pointless wrappers now that this is a simple function call.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit db10538a4b997a77a1fd561adaaa58afc7dcfa2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/drbd/drbd_int.h
#	fs/cifs/transport.c
#	include/linux/tcp.h
#	net/ipv4/tcp.c
diff --cc drivers/block/drbd/drbd_int.h
index dd0e1606fd7e,3550adc93c68..000000000000
--- a/drivers/block/drbd/drbd_int.h
+++ b/drivers/block/drbd/drbd_int.h
@@@ -1574,17 -1570,10 +1574,24 @@@ extern void drbd_set_recv_tcq(struct dr
  extern void _drbd_clear_done_ee(struct drbd_device *device, struct list_head *to_be_freed);
  extern int drbd_connected(struct drbd_peer_device *);
  
++<<<<<<< HEAD
 +static inline void drbd_tcp_cork(struct socket *sock)
 +{
 +	int val = 1;
 +	(void) kernel_setsockopt(sock, SOL_TCP, TCP_CORK,
 +			(char*)&val, sizeof(val));
 +}
 +
 +static inline void drbd_tcp_uncork(struct socket *sock)
 +{
 +	int val = 0;
 +	(void) kernel_setsockopt(sock, SOL_TCP, TCP_CORK,
++=======
+ static inline void drbd_tcp_nodelay(struct socket *sock)
+ {
+ 	int val = 1;
+ 	(void) kernel_setsockopt(sock, SOL_TCP, TCP_NODELAY,
++>>>>>>> db10538a4b99 (tcp: add tcp_sock_set_cork)
  			(char*)&val, sizeof(val));
  }
  
diff --cc fs/cifs/transport.c
index 81c73767363e,99760063e000..000000000000
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@@ -298,8 -324,7 +298,12 @@@ __smb_send_rqst(struct TCP_Server_Info 
  	sigset_t mask, oldmask;
  	size_t total_len = 0, sent, size;
  	struct socket *ssocket = server->ssocket;
++<<<<<<< HEAD
 +	struct msghdr smb_msg = {};
 +	int val = 1;
++=======
+ 	struct msghdr smb_msg;
++>>>>>>> db10538a4b99 (tcp: add tcp_sock_set_cork)
  	__be32 rfc1002_marker;
  
  	if (cifs_rdma_enabled(server)) {
diff --cc include/linux/tcp.h
index 2f7a01dcf5ea,889eeb2256c2..000000000000
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@@ -543,9 -497,6 +543,13 @@@ static inline u16 tcp_mss_clamp(const s
  int tcp_skb_shift(struct sk_buff *to, struct sk_buff *from, int pcount,
  		  int shiftlen);
  
++<<<<<<< HEAD
 +int tcp_sock_set_keepidle_locked(struct sock *sk, int val);
 +int tcp_sock_set_keepidle(struct sock *sk, int val);
 +void tcp_sock_set_nodelay(struct sock *sk);
 +int tcp_sock_set_syncnt(struct sock *sk, int val);
++=======
+ void tcp_sock_set_cork(struct sock *sk, bool on);
++>>>>>>> db10538a4b99 (tcp: add tcp_sock_set_cork)
  
  #endif	/* _LINUX_TCP_H */
diff --cc net/ipv4/tcp.c
index 19a03d7b55d2,e6cf702e16d6..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2818,90 -2786,52 +2818,124 @@@ static int tcp_repair_options_est(struc
  	return 0;
  }
  
 -DEFINE_STATIC_KEY_FALSE(tcp_tx_delay_enabled);
 -EXPORT_SYMBOL(tcp_tx_delay_enabled);
 +/* TCP_NODELAY is weaker than TCP_CORK, so that this option on corked socket is
 + * remembered, but it is not activated until cork is cleared.
 + *
 + * However, when TCP_NODELAY is set we make an explicit push, which overrides
 + * even TCP_CORK for currently queued segments.
 + */
 +static void __tcp_sock_set_nodelay(struct sock *sk, bool on)
 +{
 +	if (on) {
 +		tcp_sk(sk)->nonagle |= TCP_NAGLE_OFF|TCP_NAGLE_PUSH;
 +		tcp_push_pending_frames(sk);
 +	} else {
 +		tcp_sk(sk)->nonagle &= ~TCP_NAGLE_OFF;
 +	}
 +}
 +
++<<<<<<< HEAD
 +void tcp_sock_set_nodelay(struct sock *sk)
 +{
 +	lock_sock(sk);
 +	__tcp_sock_set_nodelay(sk, true);
 +	release_sock(sk);
 +}
 +EXPORT_SYMBOL(tcp_sock_set_nodelay);
  
 -static void tcp_enable_tx_delay(void)
 +int tcp_sock_set_syncnt(struct sock *sk, int val)
  {
 -	if (!static_branch_unlikely(&tcp_tx_delay_enabled)) {
 -		static int __tcp_tx_delay_enabled = 0;
 +	if (val < 1 || val > MAX_TCP_SYNCNT)
 +		return -EINVAL;
  
 -		if (cmpxchg(&__tcp_tx_delay_enabled, 0, 1) == 0) {
 -			static_branch_enable(&tcp_tx_delay_enabled);
 -			pr_info("TCP_TX_DELAY enabled\n");
 -		}
 +	lock_sock(sk);
 +	inet_csk(sk)->icsk_syn_retries = val;
 +	release_sock(sk);
 +	return 0;
 +}
 +EXPORT_SYMBOL(tcp_sock_set_syncnt);
 +
 +int tcp_sock_set_keepidle_locked(struct sock *sk, int val)
 +{
 +	struct tcp_sock *tp = tcp_sk(sk);
 +
 +	if (val < 1 || val > MAX_TCP_KEEPIDLE)
 +		return -EINVAL;
 +
 +	tp->keepalive_time = val * HZ;
 +	if (sock_flag(sk, SOCK_KEEPOPEN) &&
 +	    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {
 +		u32 elapsed = keepalive_time_elapsed(tp);
 +
 +		if (tp->keepalive_time > elapsed)
 +			elapsed = tp->keepalive_time - elapsed;
 +		else
 +			elapsed = 0;
 +		inet_csk_reset_keepalive_timer(sk, elapsed);
  	}
 +
 +	return 0;
  }
  
 +int tcp_sock_set_keepidle(struct sock *sk, int val)
 +{
 +	int err;
 +
 +	lock_sock(sk);
 +	err = tcp_sock_set_keepidle_locked(sk, val);
 +	release_sock(sk);
 +	return err;
 +}
 +EXPORT_SYMBOL(tcp_sock_set_keepidle);
 +
 +int tcp_set_window_clamp(struct sock *sk, int val)
 +{
 +	struct tcp_sock *tp = tcp_sk(sk);
 +
 +	if (!val) {
 +		if (sk->sk_state != TCP_CLOSE)
 +			return -EINVAL;
 +		tp->window_clamp = 0;
 +	} else {
 +		tp->window_clamp = val < SOCK_MIN_RCVBUF / 2 ?
 +			SOCK_MIN_RCVBUF / 2 : val;
 +	}
 +	return 0;
 +}
 +
++=======
+ /* When set indicates to always queue non-full frames.  Later the user clears
+  * this option and we transmit any pending partial frames in the queue.  This is
+  * meant to be used alongside sendfile() to get properly filled frames when the
+  * user (for example) must write out headers with a write() call first and then
+  * use sendfile to send out the data parts.
+  *
+  * TCP_CORK can be set together with TCP_NODELAY and it is stronger than
+  * TCP_NODELAY.
+  */
+ static void __tcp_sock_set_cork(struct sock *sk, bool on)
+ {
+ 	struct tcp_sock *tp = tcp_sk(sk);
+ 
+ 	if (on) {
+ 		tp->nonagle |= TCP_NAGLE_CORK;
+ 	} else {
+ 		tp->nonagle &= ~TCP_NAGLE_CORK;
+ 		if (tp->nonagle & TCP_NAGLE_OFF)
+ 			tp->nonagle |= TCP_NAGLE_PUSH;
+ 		tcp_push_pending_frames(sk);
+ 	}
+ }
+ 
+ void tcp_sock_set_cork(struct sock *sk, bool on)
+ {
+ 	lock_sock(sk);
+ 	__tcp_sock_set_cork(sk, on);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(tcp_sock_set_cork);
+ 
++>>>>>>> db10538a4b99 (tcp: add tcp_sock_set_cork)
  /*
   *	Socket option code for TCP.
   */
* Unmerged path drivers/block/drbd/drbd_int.h
diff --git a/drivers/block/drbd/drbd_receiver.c b/drivers/block/drbd/drbd_receiver.c
index 1c486b55de07..5725289429c6 100644
--- a/drivers/block/drbd/drbd_receiver.c
+++ b/drivers/block/drbd/drbd_receiver.c
@@ -5974,7 +5974,7 @@ void drbd_send_acks_wf(struct work_struct *ws)
 	rcu_read_unlock();
 
 	if (tcp_cork)
-		drbd_tcp_cork(connection->meta.socket);
+		tcp_sock_set_cork(connection->meta.socket->sk, true);
 
 	err = drbd_finish_peer_reqs(device);
 	kref_put(&device->kref, drbd_destroy_device);
@@ -5987,7 +5987,7 @@ void drbd_send_acks_wf(struct work_struct *ws)
 	}
 
 	if (tcp_cork)
-		drbd_tcp_uncork(connection->meta.socket);
+		tcp_sock_set_cork(connection->meta.socket->sk, false);
 
 	return;
 }
diff --git a/drivers/block/drbd/drbd_worker.c b/drivers/block/drbd/drbd_worker.c
index 1615be162131..a29ee3da8334 100644
--- a/drivers/block/drbd/drbd_worker.c
+++ b/drivers/block/drbd/drbd_worker.c
@@ -2110,7 +2110,7 @@ static void wait_for_work(struct drbd_connection *connection, struct list_head *
 	if (uncork) {
 		mutex_lock(&connection->data.mutex);
 		if (connection->data.socket)
-			drbd_tcp_uncork(connection->data.socket);
+			tcp_sock_set_cork(connection->data.socket->sk, false);
 		mutex_unlock(&connection->data.mutex);
 	}
 
@@ -2165,9 +2165,9 @@ static void wait_for_work(struct drbd_connection *connection, struct list_head *
 	mutex_lock(&connection->data.mutex);
 	if (connection->data.socket) {
 		if (cork)
-			drbd_tcp_cork(connection->data.socket);
+			tcp_sock_set_cork(connection->data.socket->sk, true);
 		else if (!uncork)
-			drbd_tcp_uncork(connection->data.socket);
+			tcp_sock_set_cork(connection->data.socket->sk, false);
 	}
 	mutex_unlock(&connection->data.mutex);
 }
* Unmerged path fs/cifs/transport.c
* Unmerged path include/linux/tcp.h
* Unmerged path net/ipv4/tcp.c
diff --git a/net/rds/tcp_send.c b/net/rds/tcp_send.c
index 7df869d37afd..2398e72a1263 100644
--- a/net/rds/tcp_send.c
+++ b/net/rds/tcp_send.c
@@ -38,23 +38,18 @@
 #include "rds.h"
 #include "tcp.h"
 
-static void rds_tcp_cork(struct socket *sock, int val)
-{
-	kernel_setsockopt(sock, SOL_TCP, TCP_CORK, (void *)&val, sizeof(val));
-}
-
 void rds_tcp_xmit_path_prepare(struct rds_conn_path *cp)
 {
 	struct rds_tcp_connection *tc = cp->cp_transport_data;
 
-	rds_tcp_cork(tc->t_sock, 1);
+	tcp_sock_set_cork(tc->t_sock->sk, true);
 }
 
 void rds_tcp_xmit_path_complete(struct rds_conn_path *cp)
 {
 	struct rds_tcp_connection *tc = cp->cp_transport_data;
 
-	rds_tcp_cork(tc->t_sock, 0);
+	tcp_sock_set_cork(tc->t_sock->sk, false);
 }
 
 /* the core send_sem serializes this with other xmit and shutdown */
