block: sync mixed merged request's failfast with 1st bio's

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-486.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 3ce6a115980c019928fcd06e01f64003886af79c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-486.el8/3ce6a115.failed

We support mixed merge for requests/bios with different fastfail
settings. When request fails, each time we only handle the portion
with same failfast setting, then bios with failfast can be failed
immediately, and bios without failfast can be retried.

The idea is pretty good, but the current implementation has several
defects:

1) initially RA bio doesn't set failfast, however bio merge code
doesn't consider this point, and just check its failfast setting for
deciding if mixed merge is required. Fix this issue by adding helper
of bio_failfast().

2) when merging bio to request front, if this request is mixed
merged, we have to sync request's faifast setting with 1st bio's
failfast. Fix it by calling blk_update_mixed_merge().

3) when merging bio to request back, if this request is mixed
merged, we have to mark the bio as failfast, because blk_update_request
simply updates request failfast with 1st bio's failfast. Fix
it by calling blk_update_mixed_merge().

Fixes one normal EXT4 READ IO failure issue, because it is observed
that the normal READ IO is merged with RA IO, and the mixed merged
request has different failfast setting with 1st bio's, so finally
the normal READ IO doesn't get retried.

	Cc: Tejun Heo <tj@kernel.org>
Fixes: 80a761fd33cf ("block: implement mixed merge of different failfast requests")
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
Link: https://lore.kernel.org/r/20230209125527.667004-1-ming.lei@redhat.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 3ce6a115980c019928fcd06e01f64003886af79c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-merge.c
diff --cc block/blk-merge.c
index 59c031679f80,30e4a99c2276..000000000000
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@@ -890,15 -972,21 +917,19 @@@ static void blk_account_io_merge_bio(st
  	part_stat_unlock();
  }
  
 -enum bio_merge_status {
 -	BIO_MERGE_OK,
 -	BIO_MERGE_NONE,
 -	BIO_MERGE_FAILED,
 -};
 -
 -static enum bio_merge_status bio_attempt_back_merge(struct request *req,
 -		struct bio *bio, unsigned int nr_segs)
 +bool bio_attempt_back_merge(struct request_queue *q, struct request *req,
 +			    struct bio *bio)
  {
++<<<<<<< HEAD
 +	const int ff = bio->bi_opf & REQ_FAILFAST_MASK;
++=======
+ 	const blk_opf_t ff = bio_failfast(bio);
++>>>>>>> 3ce6a115980c (block: sync mixed merged request's failfast with 1st bio's)
  
 -	if (!ll_back_merge_fn(req, bio, nr_segs))
 -		return BIO_MERGE_FAILED;
 +	if (!ll_back_merge_fn(q, req, bio))
 +		return false;
  
 -	trace_block_bio_backmerge(bio);
 +	trace_block_bio_backmerge(q, req, bio);
  	rq_qos_merge(req->q, req, bio);
  
  	if ((req->cmd_flags & REQ_FAILFAST_MASK) != ff)
@@@ -908,19 -998,21 +941,23 @@@
  	req->biotail = bio;
  	req->__data_len += bio->bi_iter.bi_size;
  
 -	bio_crypt_free_ctx(bio);
 -
  	blk_account_io_merge_bio(req);
 -	return BIO_MERGE_OK;
 +	return true;
  }
  
 -static enum bio_merge_status bio_attempt_front_merge(struct request *req,
 -		struct bio *bio, unsigned int nr_segs)
 +bool bio_attempt_front_merge(struct request_queue *q, struct request *req,
 +			     struct bio *bio)
  {
++<<<<<<< HEAD
 +	const int ff = bio->bi_opf & REQ_FAILFAST_MASK;
++=======
+ 	const blk_opf_t ff = bio_failfast(bio);
++>>>>>>> 3ce6a115980c (block: sync mixed merged request's failfast with 1st bio's)
  
 -	if (!ll_front_merge_fn(req, bio, nr_segs))
 -		return BIO_MERGE_FAILED;
 +	if (!ll_front_merge_fn(q, req, bio))
 +		return false;
  
 -	trace_block_bio_frontmerge(bio);
 +	trace_block_bio_frontmerge(q, req, bio);
  	rq_qos_merge(req->q, req, bio);
  
  	if ((req->cmd_flags & REQ_FAILFAST_MASK) != ff)
* Unmerged path block/blk-merge.c
