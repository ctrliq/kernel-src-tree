mm/hmm: fault non-owner device private entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-486.el8
commit-author Ralph Campbell <rcampbell@nvidia.com>
commit 8a295dbbaf7292c582a40ce469c326f472d51f66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-486.el8/8a295dbb.failed

If hmm_range_fault() is called with the HMM_PFN_REQ_FAULT flag and a
device private PTE is found, the hmm_range::dev_private_owner page is used
to determine if the device private page should not be faulted in. 
However, if the device private page is not owned by the caller,
hmm_range_fault() returns an error instead of calling migrate_to_ram() to
fault in the page.

For example, if a page is migrated to GPU private memory and a RDMA fault
capable NIC tries to read the migrated page, without this patch it will
get an error.  With this patch, the page will be migrated back to system
memory and the NIC will be able to read the data.

Link: https://lkml.kernel.org/r/20220727000837.4128709-2-rcampbell@nvidia.com
Link: https://lkml.kernel.org/r/20220725183615.4118795-2-rcampbell@nvidia.com
Fixes: 08ddddda667b ("mm/hmm: check the device private page owner in hmm_range_fault()")
	Signed-off-by: Ralph Campbell <rcampbell@nvidia.com>
	Reported-by: Felix Kuehling <felix.kuehling@amd.com>
	Reviewed-by: Alistair Popple <apopple@nvidia.com>
	Cc: Philip Yang <Philip.Yang@amd.com>
	Cc: Jason Gunthorpe <jgg@nvidia.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 8a295dbbaf7292c582a40ce469c326f472d51f66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hmm.c
diff --cc mm/hmm.c
index da653495bc5c,f2aa63b94d9b..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -259,12 -244,14 +251,14 @@@ static int hmm_vma_handle_pte(struct mm
  		swp_entry_t entry = pte_to_swp_entry(pte);
  
  		/*
- 		 * Never fault in device private pages, but just report
- 		 * the PFN even if not present.
+ 		 * Don't fault in device private pages owned by the caller,
+ 		 * just report the PFN.
  		 */
- 		if (hmm_is_device_private_entry(range, entry)) {
+ 		if (is_device_private_entry(entry) &&
+ 		    pfn_swap_entry_to_page(entry)->pgmap->owner ==
+ 		    range->dev_private_owner) {
  			cpu_flags = HMM_PFN_VALID;
 -			if (is_writable_device_private_entry(entry))
 +			if (is_write_device_private_entry(entry))
  				cpu_flags |= HMM_PFN_WRITE;
  			*hmm_pfn = swp_offset(entry) | cpu_flags;
  			return 0;
@@@ -280,6 -267,12 +274,15 @@@
  		if (!non_swap_entry(entry))
  			goto fault;
  
++<<<<<<< HEAD
++=======
+ 		if (is_device_private_entry(entry))
+ 			goto fault;
+ 
+ 		if (is_device_exclusive_entry(entry))
+ 			goto fault;
+ 
++>>>>>>> 8a295dbbaf72 (mm/hmm: fault non-owner device private entries)
  		if (is_migration_entry(entry)) {
  			pte_unmap(ptep);
  			hmm_vma_walk->last = addr;
* Unmerged path mm/hmm.c
