KVM: x86: Propagate the AMD Automatic IBRS feature to the guest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-486.el8
commit-author Kim Phillips <kim.phillips@amd.com>
commit 8c19b6f257fa71ed3a7a9df6ce466c6be31ca04c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-486.el8/8c19b6f2.failed

Add the AMD Automatic IBRS feature bit to those being propagated to the guest,
and enable the guest EFER bit.

	Signed-off-by: Kim Phillips <kim.phillips@amd.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Acked-by: Sean Christopherson <seanjc@google.com>
Link: https://lore.kernel.org/r/20230124163319.2277355-9-kim.phillips@amd.com
(cherry picked from commit 8c19b6f257fa71ed3a7a9df6ce466c6be31ca04c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
diff --cc arch/x86/kvm/cpuid.c
index 2ca5ac683c44,f1f4fe87e720..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -683,15 -742,25 +683,20 @@@ void kvm_set_cpu_caps(void
  		F(SME_COHERENT));
  
  	kvm_cpu_cap_mask(CPUID_8000_0021_EAX,
++<<<<<<< HEAD
 +		BIT(0) /* NO_NESTED_DATA_BP */ |
 +		BIT(2) /* LFENCE Always serializing */ | 0 /* SmmPgCfgLock */ |
 +		BIT(6) /* NULL_SEL_CLR_BASE */ | 0 /* PrefetchCtlMsr */
++=======
+ 		F(NO_NESTED_DATA_BP) | F(LFENCE_RDTSC) | 0 /* SmmPgCfgLock */ |
+ 		F(NULL_SEL_CLR_BASE) | F(AUTOIBRS) | 0 /* PrefetchCtlMsr */
++>>>>>>> 8c19b6f257fa (KVM: x86: Propagate the AMD Automatic IBRS feature to the guest)
  	);
 -
 -	/*
 -	 * Synthesize "LFENCE is serializing" into the AMD-defined entry in
 -	 * KVM's supported CPUID if the feature is reported as supported by the
 -	 * kernel.  LFENCE_RDTSC was a Linux-defined synthetic feature long
 -	 * before AMD joined the bandwagon, e.g. LFENCE is serializing on most
 -	 * CPUs that support SSE2.  On CPUs that don't support AMD's leaf,
 -	 * kvm_cpu_cap_mask() will unfortunately drop the flag due to ANDing
 -	 * the mask with the raw host CPUID, and reporting support in AMD's
 -	 * leaf can make it easier for userspace to detect the feature.
 -	 */
  	if (cpu_feature_enabled(X86_FEATURE_LFENCE_RDTSC))
 -		kvm_cpu_cap_set(X86_FEATURE_LFENCE_RDTSC);
 +		kvm_cpu_caps[CPUID_8000_0021_EAX] |= BIT(2) /* LFENCE Always serializing */;
  	if (!static_cpu_has_bug(X86_BUG_NULL_SEG))
 -		kvm_cpu_cap_set(X86_FEATURE_NULL_SEL_CLR_BASE);
 -	kvm_cpu_cap_set(X86_FEATURE_NO_SMM_CTL_MSR);
 +		kvm_cpu_caps[CPUID_8000_0021_EAX] |= BIT(6) /* NULL_SEL_CLR_BASE */;
 +	kvm_cpu_caps[CPUID_8000_0021_EAX] |= BIT(9) /* NO_SMM_CTL_MSR */;
  
  	kvm_cpu_cap_mask(CPUID_C000_0001_EDX,
  		F(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |
* Unmerged path arch/x86/kvm/cpuid.c
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index f34bc99d2f64..3e97d8df0f5b 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -4854,6 +4854,9 @@ static __init int svm_hardware_setup(void)
 
 	tsc_aux_uret_slot = kvm_add_user_return_msr(MSR_TSC_AUX);
 
+	if (boot_cpu_has(X86_FEATURE_AUTOIBRS))
+		kvm_enable_efer_bits(EFER_AUTOIBRS);
+
 	/* Check for pause filtering support */
 	if (!boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {
 		pause_filter_count = 0;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 59a751f834d4..e429dd77e6fb 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -1631,6 +1631,9 @@ static int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
 
 static bool __kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
 {
+	if (efer & EFER_AUTOIBRS && !guest_cpuid_has(vcpu, X86_FEATURE_AUTOIBRS))
+		return false;
+
 	if (efer & EFER_FFXSR && !guest_cpuid_has(vcpu, X86_FEATURE_FXSR_OPT))
 		return false;
 
