mm/mmap.c: extract __vma_unlink_list() as counterpart for __vma_link_list()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-486.el8
commit-author Wei Yang <richardw.yang@linux.intel.com>
commit 1b9fc5b24fa2e7c0e67778cda77ac231fb4bcac7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-486.el8/1b9fc5b2.failed

Just make the code a little easier to read.

Link: http://lkml.kernel.org/r/20191006012636.31521-3-richardw.yang@linux.intel.com
	Signed-off-by: Wei Yang <richardw.yang@linux.intel.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Matthew Wilcox (Oracle) <willy@infradead.org>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1b9fc5b24fa2e7c0e67778cda77ac231fb4bcac7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/internal.h
diff --cc mm/internal.h
index d5fedae7b81f,523d2a3ee923..000000000000
--- a/mm/internal.h
+++ b/mm/internal.h
@@@ -356,7 -290,8 +356,12 @@@ static inline bool is_data_mapping(vm_f
  
  /* mm/util.c */
  void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,
++<<<<<<< HEAD
 +		struct vm_area_struct *prev);
++=======
+ 		struct vm_area_struct *prev, struct rb_node *rb_parent);
+ void __vma_unlink_list(struct mm_struct *mm, struct vm_area_struct *vma);
++>>>>>>> 1b9fc5b24fa2 (mm/mmap.c: extract __vma_unlink_list() as counterpart for __vma_link_list())
  
  #ifdef CONFIG_MMU
  extern long populate_vma_page_range(struct vm_area_struct *vma,
* Unmerged path mm/internal.h
diff --git a/mm/mmap.c b/mm/mmap.c
index 51b278b5d6a3..c78023fa126b 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -677,18 +677,8 @@ static __always_inline void __vma_unlink_common(struct mm_struct *mm,
 						struct vm_area_struct *vma,
 						struct vm_area_struct *ignore)
 {
-	struct vm_area_struct *prev, *next;
-
 	vma_rb_erase_ignore(vma, &mm->mm_rb, ignore);
-	next = vma->vm_next;
-	prev = vma->vm_prev;
-	if (prev)
-		prev->vm_next = next;
-	else
-		mm->mmap = next;
-	if (next)
-		next->vm_prev = prev;
-
+	__vma_unlink_list(mm, vma);
 	/* Kill the cache */
 	vmacache_invalidate(mm);
 }
diff --git a/mm/nommu.c b/mm/nommu.c
index 1863f5093264..fad662e89156 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -674,13 +674,7 @@ static void delete_vma_from_mm(struct vm_area_struct *vma)
 	/* remove from the MM's tree and list */
 	rb_erase(&vma->vm_rb, &mm->mm_rb);
 
-	if (vma->vm_prev)
-		vma->vm_prev->vm_next = vma->vm_next;
-	else
-		mm->mmap = vma->vm_next;
-
-	if (vma->vm_next)
-		vma->vm_next->vm_prev = vma->vm_prev;
+	__vma_unlink_list(mm, vma);
 }
 
 /*
diff --git a/mm/util.c b/mm/util.c
index cd5b550f4c43..72390e34fd4c 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -280,6 +280,20 @@ void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,
 		next->vm_prev = vma;
 }
 
+void __vma_unlink_list(struct mm_struct *mm, struct vm_area_struct *vma)
+{
+	struct vm_area_struct *prev, *next;
+
+	next = vma->vm_next;
+	prev = vma->vm_prev;
+	if (prev)
+		prev->vm_next = next;
+	else
+		mm->mmap = next;
+	if (next)
+		next->vm_prev = prev;
+}
+
 /* Check if the vma is being used as a stack by this task */
 int vma_is_stack_for_current(struct vm_area_struct *vma)
 {
