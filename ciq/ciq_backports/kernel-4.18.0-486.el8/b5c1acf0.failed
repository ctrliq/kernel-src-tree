md: fold unbind_rdev_from_array into md_kick_rdev_from_array

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-486.el8
commit-author Christoph Hellwig <hch@lst.de>
commit b5c1acf012a7a73e3d0c5c3605ececcca6797267
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-486.el8/b5c1acf0.failed

unbind_rdev_from_array is only called from md_kick_rdev_from_array, so
merge it into its only caller.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Song Liu <song@kernel.org>
(cherry picked from commit b5c1acf012a7a73e3d0c5c3605ececcca6797267)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 0661781ff414,775f1dde190a..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2527,13 -2468,26 +2527,28 @@@ static void rdev_delayed_delete(struct 
  	kobject_put(&rdev->kobj);
  }
  
- static void unbind_rdev_from_array(struct md_rdev *rdev)
+ void md_autodetect_dev(dev_t dev);
+ 
+ static void export_rdev(struct md_rdev *rdev)
+ {
+ 	pr_debug("md: export_rdev(%pg)\n", rdev->bdev);
+ 	md_rdev_clear(rdev);
+ #ifndef MODULE
+ 	if (test_bit(AutoDetected, &rdev->flags))
+ 		md_autodetect_dev(rdev->bdev->bd_dev);
+ #endif
+ 	blkdev_put(rdev->bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);
+ 	rdev->bdev = NULL;
+ 	kobject_put(&rdev->kobj);
+ }
+ 
+ static void md_kick_rdev_from_array(struct md_rdev *rdev)
  {
 +	char b[BDEVNAME_SIZE];
 +
  	bd_unlink_disk_holder(rdev->bdev, rdev->mddev->gendisk);
  	list_del_rcu(&rdev->same_set);
 -	pr_debug("md: unbind<%pg>\n", rdev->bdev);
 +	pr_debug("md: unbind<%s>\n", bdevname(rdev->bdev,b));
  	mddev_destroy_serial_pool(rdev->mddev, rdev, false);
  	rdev->mddev = NULL;
  	sysfs_remove_link(&rdev->kobj, "block");
@@@ -2552,55 -2506,6 +2567,58 @@@
  	INIT_WORK(&rdev->del_work, rdev_delayed_delete);
  	kobject_get(&rdev->kobj);
  	queue_work(md_rdev_misc_wq, &rdev->del_work);
++<<<<<<< HEAD
 +}
 +
 +/*
 + * prevent the device from being mounted, repartitioned or
 + * otherwise reused by a RAID array (or any other kernel
 + * subsystem), by bd_claiming the device.
 + */
 +static int lock_rdev(struct md_rdev *rdev, dev_t dev, int shared)
 +{
 +	int err = 0;
 +	struct block_device *bdev;
 +
 +	bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL,
 +				 shared ? (struct md_rdev *)lock_rdev : rdev);
 +	if (IS_ERR(bdev)) {
 +		pr_warn("md: could not open device unknown-block(%u,%u).\n",
 +			MAJOR(dev), MINOR(dev));
 +		return PTR_ERR(bdev);
 +	}
 +	rdev->bdev = bdev;
 +	return err;
 +}
 +
 +static void unlock_rdev(struct md_rdev *rdev)
 +{
 +	struct block_device *bdev = rdev->bdev;
 +	rdev->bdev = NULL;
 +	blkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);
 +}
 +
 +void md_autodetect_dev(dev_t dev);
 +
 +static void export_rdev(struct md_rdev *rdev)
 +{
 +	char b[BDEVNAME_SIZE];
 +
 +	pr_debug("md: export_rdev(%s)\n", bdevname(rdev->bdev,b));
 +	md_rdev_clear(rdev);
 +#ifndef MODULE
 +	if (test_bit(AutoDetected, &rdev->flags))
 +		md_autodetect_dev(rdev->bdev->bd_dev);
 +#endif
 +	unlock_rdev(rdev);
 +	kobject_put(&rdev->kobj);
 +}
 +
 +static void md_kick_rdev_from_array(struct md_rdev *rdev)
 +{
 +	unbind_rdev_from_array(rdev);
++=======
++>>>>>>> b5c1acf012a7 (md: fold unbind_rdev_from_array into md_kick_rdev_from_array)
  	export_rdev(rdev);
  }
  
* Unmerged path drivers/md/md.c
