bnxt_en: Expand bnxt_tpa_info struct to support 57500 chips.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Expand bnxt_tpa_info struct to support 57500 chips (Jonathan Toppins) [1824438]
Rebuild_FUZZ: 99.16%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 79632e9ba38671215fb193346ef6fb8db582744d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/79632e9b.failed

Add an aggregation array to bnxt_tpa_info struct to keep track of the
aggregation completions.  The aggregation completions are not
completed at the TPA_END completion on 57500 chips so we need to
keep track of them.  The array is only allocated on the new chips
when required.  An agg_count field is also added to keep track of the
number of these completions.

The maximum concurrent TPA is now discovered from firmware instead of
the hardcoded 64.  Add a new bp->max_tpa to keep track of maximum
configured TPA.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 79632e9ba38671215fb193346ef6fb8db582744d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index d0557d84bac5,47f59e0ae147..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -2467,6 -2488,55 +2467,58 @@@ static int bnxt_alloc_ring(struct bnxt 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void bnxt_free_tpa_info(struct bnxt *bp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < bp->rx_nr_rings; i++) {
+ 		struct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];
+ 
+ 		if (rxr->rx_tpa) {
+ 			kfree(rxr->rx_tpa[0].agg_arr);
+ 			rxr->rx_tpa[0].agg_arr = NULL;
+ 		}
+ 		kfree(rxr->rx_tpa);
+ 		rxr->rx_tpa = NULL;
+ 	}
+ }
+ 
+ static int bnxt_alloc_tpa_info(struct bnxt *bp)
+ {
+ 	int i, j, total_aggs = 0;
+ 
+ 	bp->max_tpa = MAX_TPA;
+ 	if (bp->flags & BNXT_FLAG_CHIP_P5) {
+ 		if (!bp->max_tpa_v2)
+ 			return 0;
+ 		bp->max_tpa = max_t(u16, bp->max_tpa_v2, MAX_TPA_P5);
+ 		total_aggs = bp->max_tpa * MAX_SKB_FRAGS;
+ 	}
+ 
+ 	for (i = 0; i < bp->rx_nr_rings; i++) {
+ 		struct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];
+ 		struct rx_agg_cmp *agg;
+ 
+ 		rxr->rx_tpa = kcalloc(bp->max_tpa, sizeof(struct bnxt_tpa_info),
+ 				      GFP_KERNEL);
+ 		if (!rxr->rx_tpa)
+ 			return -ENOMEM;
+ 
+ 		if (!(bp->flags & BNXT_FLAG_CHIP_P5))
+ 			continue;
+ 		agg = kcalloc(total_aggs, sizeof(*agg), GFP_KERNEL);
+ 		rxr->rx_tpa[0].agg_arr = agg;
+ 		if (!agg)
+ 			return -ENOMEM;
+ 		for (j = 1; j < bp->max_tpa; j++)
+ 			rxr->rx_tpa[j].agg_arr = agg + j * MAX_SKB_FRAGS;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 79632e9ba386 (bnxt_en: Expand bnxt_tpa_info struct to support 57500 chips.)
  static void bnxt_free_rx_rings(struct bnxt *bp)
  {
  	int i;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.h b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
index ec4fe7263cc2..12319e6c184d 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -555,6 +555,8 @@ struct nqe_cn {
 #define BNXT_DEFAULT_TX_RING_SIZE	511
 
 #define MAX_TPA		64
+#define MAX_TPA_P5	256
+#define MAX_TPA_SEGS_P5	0x3f
 
 #if (BNXT_PAGE_SHIFT == 16)
 #define MAX_RX_PAGES	1
@@ -830,6 +832,8 @@ struct bnxt_tpa_info {
 	((hdr_info) & 0x1ff)
 
 	u16			cfa_code; /* cfa_code in TPA start compl */
+	u8			agg_count;
+	struct rx_agg_cmp	*agg_arr;
 };
 
 struct bnxt_rx_ring_info {
@@ -1484,6 +1488,8 @@ struct bnxt {
 					       u16, void *, u8 *, dma_addr_t,
 					       unsigned int);
 
+	u16			max_tpa_v2;
+	u16			max_tpa;
 	u32			rx_buf_size;
 	u32			rx_buf_use_size;	/* useable size */
 	u16			rx_offset;
