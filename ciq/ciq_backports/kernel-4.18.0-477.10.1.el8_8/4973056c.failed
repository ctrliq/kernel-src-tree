net: convert users of bitmap_foo() to linkmode_foo()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Sean Anderson <sean.anderson@seco.com>
commit 4973056cceacc70966396039fae99867dfafd796
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/4973056c.failed

This converts instances of
	bitmap_foo(args..., __ETHTOOL_LINK_MODE_MASK_NBITS)
to
	linkmode_foo(args...)

I manually fixed up some lines to prevent them from being excessively
long. Otherwise, this change was generated with the following semantic
patch:

// Generated with
// echo linux/linkmode.h > includes
// git grep -Flf includes include/ | cut -f 2- -d / | cat includes - \
// | sort | uniq | tee new_includes | wc -l && mv new_includes includes
// and repeating until the number stopped going up
@i@
@@

(
 #include <linux/acpi_mdio.h>
|
 #include <linux/brcmphy.h>
|
 #include <linux/dsa/loop.h>
|
 #include <linux/dsa/sja1105.h>
|
 #include <linux/ethtool.h>
|
 #include <linux/ethtool_netlink.h>
|
 #include <linux/fec.h>
|
 #include <linux/fs_enet_pd.h>
|
 #include <linux/fsl/enetc_mdio.h>
|
 #include <linux/fwnode_mdio.h>
|
 #include <linux/linkmode.h>
|
 #include <linux/lsm_audit.h>
|
 #include <linux/mdio-bitbang.h>
|
 #include <linux/mdio.h>
|
 #include <linux/mdio-mux.h>
|
 #include <linux/mii.h>
|
 #include <linux/mii_timestamper.h>
|
 #include <linux/mlx5/accel.h>
|
 #include <linux/mlx5/cq.h>
|
 #include <linux/mlx5/device.h>
|
 #include <linux/mlx5/driver.h>
|
 #include <linux/mlx5/eswitch.h>
|
 #include <linux/mlx5/fs.h>
|
 #include <linux/mlx5/port.h>
|
 #include <linux/mlx5/qp.h>
|
 #include <linux/mlx5/rsc_dump.h>
|
 #include <linux/mlx5/transobj.h>
|
 #include <linux/mlx5/vport.h>
|
 #include <linux/of_mdio.h>
|
 #include <linux/of_net.h>
|
 #include <linux/pcs-lynx.h>
|
 #include <linux/pcs/pcs-xpcs.h>
|
 #include <linux/phy.h>
|
 #include <linux/phy_led_triggers.h>
|
 #include <linux/phylink.h>
|
 #include <linux/platform_data/bcmgenet.h>
|
 #include <linux/platform_data/xilinx-ll-temac.h>
|
 #include <linux/pxa168_eth.h>
|
 #include <linux/qed/qed_eth_if.h>
|
 #include <linux/qed/qed_fcoe_if.h>
|
 #include <linux/qed/qed_if.h>
|
 #include <linux/qed/qed_iov_if.h>
|
 #include <linux/qed/qed_iscsi_if.h>
|
 #include <linux/qed/qed_ll2_if.h>
|
 #include <linux/qed/qed_nvmetcp_if.h>
|
 #include <linux/qed/qed_rdma_if.h>
|
 #include <linux/sfp.h>
|
 #include <linux/sh_eth.h>
|
 #include <linux/smsc911x.h>
|
 #include <linux/soc/nxp/lpc32xx-misc.h>
|
 #include <linux/stmmac.h>
|
 #include <linux/sunrpc/svc_rdma.h>
|
 #include <linux/sxgbe_platform.h>
|
 #include <net/cfg80211.h>
|
 #include <net/dsa.h>
|
 #include <net/mac80211.h>
|
 #include <net/selftests.h>
|
 #include <rdma/ib_addr.h>
|
 #include <rdma/ib_cache.h>
|
 #include <rdma/ib_cm.h>
|
 #include <rdma/ib_hdrs.h>
|
 #include <rdma/ib_mad.h>
|
 #include <rdma/ib_marshall.h>
|
 #include <rdma/ib_pack.h>
|
 #include <rdma/ib_pma.h>
|
 #include <rdma/ib_sa.h>
|
 #include <rdma/ib_smi.h>
|
 #include <rdma/ib_umem.h>
|
 #include <rdma/ib_umem_odp.h>
|
 #include <rdma/ib_verbs.h>
|
 #include <rdma/iw_cm.h>
|
 #include <rdma/mr_pool.h>
|
 #include <rdma/opa_addr.h>
|
 #include <rdma/opa_port_info.h>
|
 #include <rdma/opa_smi.h>
|
 #include <rdma/opa_vnic.h>
|
 #include <rdma/rdma_cm.h>
|
 #include <rdma/rdma_cm_ib.h>
|
 #include <rdma/rdmavt_cq.h>
|
 #include <rdma/rdma_vt.h>
|
 #include <rdma/rdmavt_qp.h>
|
 #include <rdma/rw.h>
|
 #include <rdma/tid_rdma_defs.h>
|
 #include <rdma/uverbs_ioctl.h>
|
 #include <rdma/uverbs_named_ioctl.h>
|
 #include <rdma/uverbs_std_types.h>
|
 #include <rdma/uverbs_types.h>
|
 #include <soc/mscc/ocelot.h>
|
 #include <soc/mscc/ocelot_ptp.h>
|
 #include <soc/mscc/ocelot_vcap.h>
|
 #include <trace/events/ib_mad.h>
|
 #include <trace/events/rdma_core.h>
|
 #include <trace/events/rdma.h>
|
 #include <trace/events/rpcrdma.h>
|
 #include <uapi/linux/ethtool.h>
|
 #include <uapi/linux/ethtool_netlink.h>
|
 #include <uapi/linux/mdio.h>
|
 #include <uapi/linux/mii.h>
)

@depends on i@
expression list args;
@@

(
- bitmap_zero(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_zero(args)
|
- bitmap_copy(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_copy(args)
|
- bitmap_and(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_and(args)
|
- bitmap_or(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_or(args)
|
- bitmap_empty(args, ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_empty(args)
|
- bitmap_andnot(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_andnot(args)
|
- bitmap_equal(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_equal(args)
|
- bitmap_intersects(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_intersects(args)
|
- bitmap_subset(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
+ linkmode_subset(args)
)

Add missing linux/mii.h include to mellanox. -DaveM

	Signed-off-by: Sean Anderson <sean.anderson@seco.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4973056cceacc70966396039fae99867dfafd796)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/dsa/b53/b53_common.c
#	drivers/net/dsa/bcm_sf2.c
#	drivers/net/dsa/hirschmann/hellcreek.c
#	drivers/net/dsa/lantiq_gswip.c
#	drivers/net/dsa/microchip/ksz8795.c
#	drivers/net/dsa/mv88e6xxx/chip.c
#	drivers/net/dsa/ocelot/felix_vsc9959.c
#	drivers/net/dsa/ocelot/seville_vsc9953.c
#	drivers/net/dsa/qca/ar9331.c
#	drivers/net/dsa/sja1105/sja1105_main.c
#	drivers/net/dsa/xrs700x/xrs700x.c
#	drivers/net/ethernet/atheros/ag71xx.c
#	drivers/net/ethernet/cadence/macb_main.c
#	drivers/net/ethernet/freescale/enetc/enetc_pf.c
#	drivers/net/ethernet/huawei/hinic/hinic_ethtool.c
#	drivers/net/ethernet/marvell/mvneta.c
#	drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
#	drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
#	drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c
#	drivers/net/ethernet/mscc/ocelot_net.c
#	drivers/net/ethernet/xilinx/xilinx_axienet_main.c
diff --cc drivers/net/dsa/b53/b53_common.c
index d93c790bfbe8,b0262e69a170..000000000000
--- a/drivers/net/dsa/b53/b53_common.c
+++ b/drivers/net/dsa/b53/b53_common.c
@@@ -1069,8 -1297,151 +1069,154 @@@ static void b53_adjust_link(struct dsa_
  	p->eee_enabled = b53_eee_init(ds, port, phydev);
  }
  
 -void b53_port_event(struct dsa_switch *ds, int port)
 +int b53_vlan_filtering(struct dsa_switch *ds, int port, bool vlan_filtering)
  {
++<<<<<<< HEAD
++=======
+ 	struct b53_device *dev = ds->priv;
+ 	bool link;
+ 	u16 sts;
+ 
+ 	b53_read16(dev, B53_STAT_PAGE, B53_LINK_STAT, &sts);
+ 	link = !!(sts & BIT(port));
+ 	dsa_port_phylink_mac_change(ds, port, link);
+ }
+ EXPORT_SYMBOL(b53_port_event);
+ 
+ void b53_phylink_validate(struct dsa_switch *ds, int port,
+ 			  unsigned long *supported,
+ 			  struct phylink_link_state *state)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	if (dev->ops->serdes_phylink_validate)
+ 		dev->ops->serdes_phylink_validate(dev, port, mask, state);
+ 
+ 	/* Allow all the expected bits */
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+ 	phylink_set(mask, Pause);
+ 	phylink_set(mask, Asym_Pause);
+ 
+ 	/* With the exclusion of 5325/5365, MII, Reverse MII and 802.3z, we
+ 	 * support Gigabit, including Half duplex.
+ 	 */
+ 	if (state->interface != PHY_INTERFACE_MODE_MII &&
+ 	    state->interface != PHY_INTERFACE_MODE_REVMII &&
+ 	    !phy_interface_mode_is_8023z(state->interface) &&
+ 	    !(is5325(dev) || is5365(dev))) {
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseT_Half);
+ 	}
+ 
+ 	if (!phy_interface_mode_is_8023z(state->interface)) {
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+ 		phylink_set(mask, 100baseT_Half);
+ 		phylink_set(mask, 100baseT_Full);
+ 	}
+ 
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	phylink_helper_basex_speed(state);
+ }
+ EXPORT_SYMBOL(b53_phylink_validate);
+ 
+ int b53_phylink_mac_link_state(struct dsa_switch *ds, int port,
+ 			       struct phylink_link_state *state)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	if ((phy_interface_mode_is_8023z(state->interface) ||
+ 	     state->interface == PHY_INTERFACE_MODE_SGMII) &&
+ 	     dev->ops->serdes_link_state)
+ 		ret = dev->ops->serdes_link_state(dev, port, state);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(b53_phylink_mac_link_state);
+ 
+ void b53_phylink_mac_config(struct dsa_switch *ds, int port,
+ 			    unsigned int mode,
+ 			    const struct phylink_link_state *state)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 
+ 	if (mode == MLO_AN_PHY || mode == MLO_AN_FIXED)
+ 		return;
+ 
+ 	if ((phy_interface_mode_is_8023z(state->interface) ||
+ 	     state->interface == PHY_INTERFACE_MODE_SGMII) &&
+ 	     dev->ops->serdes_config)
+ 		dev->ops->serdes_config(dev, port, mode, state);
+ }
+ EXPORT_SYMBOL(b53_phylink_mac_config);
+ 
+ void b53_phylink_mac_an_restart(struct dsa_switch *ds, int port)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 
+ 	if (dev->ops->serdes_an_restart)
+ 		dev->ops->serdes_an_restart(dev, port);
+ }
+ EXPORT_SYMBOL(b53_phylink_mac_an_restart);
+ 
+ void b53_phylink_mac_link_down(struct dsa_switch *ds, int port,
+ 			       unsigned int mode,
+ 			       phy_interface_t interface)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 
+ 	if (mode == MLO_AN_PHY)
+ 		return;
+ 
+ 	if (mode == MLO_AN_FIXED) {
+ 		b53_force_link(dev, port, false);
+ 		return;
+ 	}
+ 
+ 	if (phy_interface_mode_is_8023z(interface) &&
+ 	    dev->ops->serdes_link_set)
+ 		dev->ops->serdes_link_set(dev, port, mode, interface, false);
+ }
+ EXPORT_SYMBOL(b53_phylink_mac_link_down);
+ 
+ void b53_phylink_mac_link_up(struct dsa_switch *ds, int port,
+ 			     unsigned int mode,
+ 			     phy_interface_t interface,
+ 			     struct phy_device *phydev,
+ 			     int speed, int duplex,
+ 			     bool tx_pause, bool rx_pause)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 
+ 	if (mode == MLO_AN_PHY)
+ 		return;
+ 
+ 	if (mode == MLO_AN_FIXED) {
+ 		b53_force_port_config(dev, port, speed, duplex,
+ 				      tx_pause, rx_pause);
+ 		b53_force_link(dev, port, true);
+ 		return;
+ 	}
+ 
+ 	if (phy_interface_mode_is_8023z(interface) &&
+ 	    dev->ops->serdes_link_set)
+ 		dev->ops->serdes_link_set(dev, port, mode, interface, true);
+ }
+ EXPORT_SYMBOL(b53_phylink_mac_link_up);
+ 
+ int b53_vlan_filtering(struct dsa_switch *ds, int port, bool vlan_filtering,
+ 		       struct netlink_ext_ack *extack)
+ {
+ 	struct b53_device *dev = ds->priv;
+ 
+ 	b53_enable_vlan(dev, port, dev->vlan_enabled, vlan_filtering);
+ 
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  	return 0;
  }
  EXPORT_SYMBOL(b53_vlan_filtering);
diff --cc drivers/net/dsa/bcm_sf2.c
index 9c7cbf9b574e,13aa43b5cffd..000000000000
--- a/drivers/net/dsa/bcm_sf2.c
+++ b/drivers/net/dsa/bcm_sf2.c
@@@ -488,9 -685,11 +488,17 @@@ static void bcm_sf2_sw_validate(struct 
  	    state->interface != PHY_INTERFACE_MODE_GMII &&
  	    state->interface != PHY_INTERFACE_MODE_INTERNAL &&
  	    state->interface != PHY_INTERFACE_MODE_MOCA) {
++<<<<<<< HEAD
 +		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
 +		dev_err(ds->dev,
 +			"Unsupported interface: %d\n", state->interface);
++=======
+ 		linkmode_zero(supported);
+ 		if (port != core_readl(priv, CORE_IMP0_PRT_ID))
+ 			dev_err(ds->dev,
+ 				"Unsupported interface: %d for port %d\n",
+ 				state->interface, port);
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  		return;
  	}
  
diff --cc drivers/net/dsa/mv88e6xxx/chip.c
index be849e7b1088,14c678a9e41b..000000000000
--- a/drivers/net/dsa/mv88e6xxx/chip.c
+++ b/drivers/net/dsa/mv88e6xxx/chip.c
@@@ -569,111 -459,364 +569,124 @@@ restore_link
  	return err;
  }
  
 -static int mv88e6xxx_phy_is_internal(struct dsa_switch *ds, int port)
 +/* We expect the switch to perform auto negotiation if there is a real
 + * phy. However, in the case of a fixed link phy, we force the port
 + * settings from the fixed link settings.
 + */
 +static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
 +				  struct phy_device *phydev)
  {
  	struct mv88e6xxx_chip *chip = ds->priv;
 +	int err;
  
 -	return port < chip->info->num_internal_phys;
 -}
 +	if (!phy_is_pseudo_fixed_link(phydev))
 +		return;
  
 -static int mv88e6xxx_port_ppu_updates(struct mv88e6xxx_chip *chip, int port)
 -{
 -	u16 reg;
 -	int err;
 +	mutex_lock(&chip->reg_lock);
 +	err = mv88e6xxx_port_setup_mac(chip, port, phydev->link, phydev->speed,
 +				       phydev->duplex, phydev->interface);
 +	mutex_unlock(&chip->reg_lock);
  
 -	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
 -	if (err) {
 -		dev_err(chip->dev,
 -			"p%d: %s: failed to read port status\n",
 -			port, __func__);
 -		return err;
 -	}
 +	if (err && err != -EOPNOTSUPP)
 +		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
 +}
  
 -	return !!(reg & MV88E6XXX_PORT_STS_PHY_DETECT);
 +static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
 +			       unsigned long *supported,
 +			       struct phylink_link_state *state)
 +{
  }
  
 -static int mv88e6xxx_serdes_pcs_get_state(struct dsa_switch *ds, int port,
 -					  struct phylink_link_state *state)
 +static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
 +				struct phylink_link_state *state)
  {
  	struct mv88e6xxx_chip *chip = ds->priv;
 -	int lane;
  	int err;
  
 -	mv88e6xxx_reg_lock(chip);
 -	lane = mv88e6xxx_serdes_get_lane(chip, port);
 -	if (lane >= 0 && chip->info->ops->serdes_pcs_get_state)
 -		err = chip->info->ops->serdes_pcs_get_state(chip, port, lane,
 -							    state);
 -	else
 -		err = -EOPNOTSUPP;
 -	mv88e6xxx_reg_unlock(chip);
 +	mutex_lock(&chip->reg_lock);
 +	err = mv88e6xxx_port_link_state(chip, port, state);
 +	mutex_unlock(&chip->reg_lock);
  
++<<<<<<< HEAD
  	return err;
 -}
 -
 -static int mv88e6xxx_serdes_pcs_config(struct mv88e6xxx_chip *chip, int port,
 -				       unsigned int mode,
 -				       phy_interface_t interface,
 -				       const unsigned long *advertise)
 -{
 -	const struct mv88e6xxx_ops *ops = chip->info->ops;
 -	int lane;
++=======
++	if (chip->info->ops->phylink_validate)
++		chip->info->ops->phylink_validate(chip, port, mask, state);
+ 
 -	if (ops->serdes_pcs_config) {
 -		lane = mv88e6xxx_serdes_get_lane(chip, port);
 -		if (lane >= 0)
 -			return ops->serdes_pcs_config(chip, port, lane, mode,
 -						      interface, advertise);
 -	}
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
 -	return 0;
++	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
++	 * to advertise both, only report advertising at 2500BaseX.
++	 */
++	phylink_helper_basex_speed(state);
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  }
  
 -static void mv88e6xxx_serdes_pcs_an_restart(struct dsa_switch *ds, int port)
 +static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
 +				 unsigned int mode,
 +				 const struct phylink_link_state *state)
  {
  	struct mv88e6xxx_chip *chip = ds->priv;
 -	const struct mv88e6xxx_ops *ops;
 -	int err = 0;
 -	int lane;
 -
 -	ops = chip->info->ops;
 -
 -	if (ops->serdes_pcs_an_restart) {
 -		mv88e6xxx_reg_lock(chip);
 -		lane = mv88e6xxx_serdes_get_lane(chip, port);
 -		if (lane >= 0)
 -			err = ops->serdes_pcs_an_restart(chip, port, lane);
 -		mv88e6xxx_reg_unlock(chip);
 -
 -		if (err)
 -			dev_err(ds->dev, "p%d: failed to restart AN\n", port);
 -	}
 -}
 -
 -static int mv88e6xxx_serdes_pcs_link_up(struct mv88e6xxx_chip *chip, int port,
 -					unsigned int mode,
 -					int speed, int duplex)
 -{
 -	const struct mv88e6xxx_ops *ops = chip->info->ops;
 -	int lane;
 -
 -	if (!phylink_autoneg_inband(mode) && ops->serdes_pcs_link_up) {
 -		lane = mv88e6xxx_serdes_get_lane(chip, port);
 -		if (lane >= 0)
 -			return ops->serdes_pcs_link_up(chip, port, lane,
 -						       speed, duplex);
 -	}
 +	int speed, duplex, link, err;
  
 -	return 0;
 -}
 +	if (mode == MLO_AN_PHY)
 +		return;
  
 -static void mv88e6065_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -				       unsigned long *mask,
 -				       struct phylink_link_state *state)
 -{
 -	if (!phy_interface_mode_is_8023z(state->interface)) {
 -		/* 10M and 100M are only supported in non-802.3z mode */
 -		phylink_set(mask, 10baseT_Half);
 -		phylink_set(mask, 10baseT_Full);
 -		phylink_set(mask, 100baseT_Half);
 -		phylink_set(mask, 100baseT_Full);
 +	if (mode == MLO_AN_FIXED) {
 +		link = LINK_FORCED_UP;
 +		speed = state->speed;
 +		duplex = state->duplex;
 +	} else {
 +		speed = SPEED_UNFORCED;
 +		duplex = DUPLEX_UNFORCED;
 +		link = LINK_UNFORCED;
  	}
 -}
  
 -static void mv88e6185_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -				       unsigned long *mask,
 -				       struct phylink_link_state *state)
 -{
 -	/* FIXME: if the port is in 1000Base-X mode, then it only supports
 -	 * 1000M FD speeds.  In this case, CMODE will indicate 5.
 -	 */
 -	phylink_set(mask, 1000baseT_Full);
 -	phylink_set(mask, 1000baseX_Full);
 +	mutex_lock(&chip->reg_lock);
 +	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex,
 +				       state->interface);
 +	mutex_unlock(&chip->reg_lock);
  
 -	mv88e6065_phylink_validate(chip, port, mask, state);
 +	if (err && err != -EOPNOTSUPP)
 +		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
  }
  
 -static void mv88e6341_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -				       unsigned long *mask,
 -				       struct phylink_link_state *state)
 +static void mv88e6xxx_mac_link_force(struct dsa_switch *ds, int port, int link)
  {
 -	if (port >= 5)
 -		phylink_set(mask, 2500baseX_Full);
 -
 -	/* No ethtool bits for 200Mbps */
 -	phylink_set(mask, 1000baseT_Full);
 -	phylink_set(mask, 1000baseX_Full);
 -
 -	mv88e6065_phylink_validate(chip, port, mask, state);
 -}
 +	struct mv88e6xxx_chip *chip = ds->priv;
 +	int err;
  
 -static void mv88e6352_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -				       unsigned long *mask,
 -				       struct phylink_link_state *state)
 -{
 -	/* No ethtool bits for 200Mbps */
 -	phylink_set(mask, 1000baseT_Full);
 -	phylink_set(mask, 1000baseX_Full);
 +	mutex_lock(&chip->reg_lock);
 +	err = chip->info->ops->port_set_link(chip, port, link);
 +	mutex_unlock(&chip->reg_lock);
  
 -	mv88e6065_phylink_validate(chip, port, mask, state);
 +	if (err)
 +		dev_err(chip->dev, "p%d: failed to force MAC link\n", port);
  }
  
 -static void mv88e6390_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -				       unsigned long *mask,
 -				       struct phylink_link_state *state)
 +static void mv88e6xxx_mac_link_down(struct dsa_switch *ds, int port,
 +				    unsigned int mode,
 +				    phy_interface_t interface)
  {
 -	if (port >= 9) {
 -		phylink_set(mask, 2500baseX_Full);
 -		phylink_set(mask, 2500baseT_Full);
 -	}
 -
 -	/* No ethtool bits for 200Mbps */
 -	phylink_set(mask, 1000baseT_Full);
 -	phylink_set(mask, 1000baseX_Full);
 -
 -	mv88e6065_phylink_validate(chip, port, mask, state);
 +	if (mode == MLO_AN_FIXED)
 +		mv88e6xxx_mac_link_force(ds, port, LINK_FORCED_DOWN);
  }
  
 -static void mv88e6390x_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -					unsigned long *mask,
 -					struct phylink_link_state *state)
 +static void mv88e6xxx_mac_link_up(struct dsa_switch *ds, int port,
 +				  unsigned int mode, phy_interface_t interface,
 +				  struct phy_device *phydev)
  {
 -	if (port >= 9) {
 -		phylink_set(mask, 10000baseT_Full);
 -		phylink_set(mask, 10000baseKR_Full);
 -	}
 -
 -	mv88e6390_phylink_validate(chip, port, mask, state);
 +	if (mode == MLO_AN_FIXED)
 +		mv88e6xxx_mac_link_force(ds, port, LINK_FORCED_UP);
  }
  
 -static void mv88e6393x_phylink_validate(struct mv88e6xxx_chip *chip, int port,
 -					unsigned long *mask,
 -					struct phylink_link_state *state)
 +static int mv88e6xxx_stats_snapshot(struct mv88e6xxx_chip *chip, int port)
  {
 -	if (port == 0 || port == 9 || port == 10) {
 -		phylink_set(mask, 10000baseT_Full);
 -		phylink_set(mask, 10000baseKR_Full);
 -		phylink_set(mask, 10000baseCR_Full);
 -		phylink_set(mask, 10000baseSR_Full);
 -		phylink_set(mask, 10000baseLR_Full);
 -		phylink_set(mask, 10000baseLRM_Full);
 -		phylink_set(mask, 10000baseER_Full);
 -		phylink_set(mask, 5000baseT_Full);
 -		phylink_set(mask, 2500baseX_Full);
 -		phylink_set(mask, 2500baseT_Full);
 -	}
 -
 -	phylink_set(mask, 1000baseT_Full);
 -	phylink_set(mask, 1000baseX_Full);
 +	if (!chip->info->ops->stats_snapshot)
 +		return -EOPNOTSUPP;
  
 -	mv88e6065_phylink_validate(chip, port, mask, state);
 -}
 -
 -static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
 -			       unsigned long *supported,
 -			       struct phylink_link_state *state)
 -{
 -	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
 -	struct mv88e6xxx_chip *chip = ds->priv;
 -
 -	/* Allow all the expected bits */
 -	phylink_set(mask, Autoneg);
 -	phylink_set(mask, Pause);
 -	phylink_set_port_modes(mask);
 -
 -	if (chip->info->ops->phylink_validate)
 -		chip->info->ops->phylink_validate(chip, port, mask, state);
 -
 -	linkmode_and(supported, supported, mask);
 -	linkmode_and(state->advertising, state->advertising, mask);
 -
 -	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
 -	 * to advertise both, only report advertising at 2500BaseX.
 -	 */
 -	phylink_helper_basex_speed(state);
 -}
 -
 -static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
 -				 unsigned int mode,
 -				 const struct phylink_link_state *state)
 -{
 -	struct mv88e6xxx_chip *chip = ds->priv;
 -	struct mv88e6xxx_port *p;
 -	int err;
 -
 -	p = &chip->ports[port];
 -
 -	/* FIXME: is this the correct test? If we're in fixed mode on an
 -	 * internal port, why should we process this any different from
 -	 * PHY mode? On the other hand, the port may be automedia between
 -	 * an internal PHY and the serdes...
 -	 */
 -	if ((mode == MLO_AN_PHY) && mv88e6xxx_phy_is_internal(ds, port))
 -		return;
 -
 -	mv88e6xxx_reg_lock(chip);
 -	/* In inband mode, the link may come up at any time while the link
 -	 * is not forced down. Force the link down while we reconfigure the
 -	 * interface mode.
 -	 */
 -	if (mode == MLO_AN_INBAND && p->interface != state->interface &&
 -	    chip->info->ops->port_set_link)
 -		chip->info->ops->port_set_link(chip, port, LINK_FORCED_DOWN);
 -
 -	err = mv88e6xxx_port_config_interface(chip, port, state->interface);
 -	if (err && err != -EOPNOTSUPP)
 -		goto err_unlock;
 -
 -	err = mv88e6xxx_serdes_pcs_config(chip, port, mode, state->interface,
 -					  state->advertising);
 -	/* FIXME: we should restart negotiation if something changed - which
 -	 * is something we get if we convert to using phylinks PCS operations.
 -	 */
 -	if (err > 0)
 -		err = 0;
 -
 -	/* Undo the forced down state above after completing configuration
 -	 * irrespective of its state on entry, which allows the link to come up.
 -	 */
 -	if (mode == MLO_AN_INBAND && p->interface != state->interface &&
 -	    chip->info->ops->port_set_link)
 -		chip->info->ops->port_set_link(chip, port, LINK_UNFORCED);
 -
 -	p->interface = state->interface;
 -
 -err_unlock:
 -	mv88e6xxx_reg_unlock(chip);
 -
 -	if (err && err != -EOPNOTSUPP)
 -		dev_err(ds->dev, "p%d: failed to configure MAC/PCS\n", port);
 -}
 -
 -static void mv88e6xxx_mac_link_down(struct dsa_switch *ds, int port,
 -				    unsigned int mode,
 -				    phy_interface_t interface)
 -{
 -	struct mv88e6xxx_chip *chip = ds->priv;
 -	const struct mv88e6xxx_ops *ops;
 -	int err = 0;
 -
 -	ops = chip->info->ops;
 -
 -	mv88e6xxx_reg_lock(chip);
 -	/* Internal PHYs propagate their configuration directly to the MAC.
 -	 * External PHYs depend on whether the PPU is enabled for this port.
 -	 */
 -	if (((!mv88e6xxx_phy_is_internal(ds, port) &&
 -	      !mv88e6xxx_port_ppu_updates(chip, port)) ||
 -	     mode == MLO_AN_FIXED) && ops->port_sync_link)
 -		err = ops->port_sync_link(chip, port, mode, false);
 -	mv88e6xxx_reg_unlock(chip);
 -
 -	if (err)
 -		dev_err(chip->dev,
 -			"p%d: failed to force MAC link down\n", port);
 -}
 -
 -static void mv88e6xxx_mac_link_up(struct dsa_switch *ds, int port,
 -				  unsigned int mode, phy_interface_t interface,
 -				  struct phy_device *phydev,
 -				  int speed, int duplex,
 -				  bool tx_pause, bool rx_pause)
 -{
 -	struct mv88e6xxx_chip *chip = ds->priv;
 -	const struct mv88e6xxx_ops *ops;
 -	int err = 0;
 -
 -	ops = chip->info->ops;
 -
 -	mv88e6xxx_reg_lock(chip);
 -	/* Internal PHYs propagate their configuration directly to the MAC.
 -	 * External PHYs depend on whether the PPU is enabled for this port.
 -	 */
 -	if ((!mv88e6xxx_phy_is_internal(ds, port) &&
 -	     !mv88e6xxx_port_ppu_updates(chip, port)) ||
 -	    mode == MLO_AN_FIXED) {
 -		/* FIXME: for an automedia port, should we force the link
 -		 * down here - what if the link comes up due to "other" media
 -		 * while we're bringing the port up, how is the exclusivity
 -		 * handled in the Marvell hardware? E.g. port 2 on 88E6390
 -		 * shared between internal PHY and Serdes.
 -		 */
 -		err = mv88e6xxx_serdes_pcs_link_up(chip, port, mode, speed,
 -						   duplex);
 -		if (err)
 -			goto error;
 -
 -		if (ops->port_set_speed_duplex) {
 -			err = ops->port_set_speed_duplex(chip, port,
 -							 speed, duplex);
 -			if (err && err != -EOPNOTSUPP)
 -				goto error;
 -		}
 -
 -		if (ops->port_sync_link)
 -			err = ops->port_sync_link(chip, port, mode, true);
 -	}
 -error:
 -	mv88e6xxx_reg_unlock(chip);
 -
 -	if (err && err != -EOPNOTSUPP)
 -		dev_err(ds->dev,
 -			"p%d: failed to configure MAC link up\n", port);
 -}
 -
 -static int mv88e6xxx_stats_snapshot(struct mv88e6xxx_chip *chip, int port)
 -{
 -	if (!chip->info->ops->stats_snapshot)
 -		return -EOPNOTSUPP;
 -
 -	return chip->info->ops->stats_snapshot(chip, port);
 +	return chip->info->ops->stats_snapshot(chip, port);
  }
  
  static struct mv88e6xxx_hw_stat mv88e6xxx_hw_stats[] = {
diff --cc drivers/net/ethernet/cadence/macb_main.c
index 04c996c5df2b,309371abfe23..000000000000
--- a/drivers/net/ethernet/cadence/macb_main.c
+++ b/drivers/net/ethernet/cadence/macb_main.c
@@@ -393,19 -498,168 +393,169 @@@ static void macb_set_tx_clk(struct clk 
  	ferr = abs(rate_rounded - rate);
  	ferr = DIV_ROUND_UP(ferr, rate / 100000);
  	if (ferr > 5)
 -		netdev_warn(bp->dev,
 -			    "unable to generate target frequency: %ld Hz\n",
 +		netdev_warn(dev, "unable to generate target frequency: %ld Hz\n",
  			    rate);
  
 -	if (clk_set_rate(bp->tx_clk, rate_rounded))
 -		netdev_err(bp->dev, "adjusting tx_clk failed.\n");
 +	if (clk_set_rate(clk, rate_rounded))
 +		netdev_err(dev, "adjusting tx_clk failed.\n");
  }
  
 -static void macb_validate(struct phylink_config *config,
 -			  unsigned long *supported,
 -			  struct phylink_link_state *state)
 +static void macb_handle_link_change(struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct macb *bp = netdev_priv(dev);
 +	struct phy_device *phydev = dev->phydev;
++=======
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 	struct macb *bp = netdev_priv(ndev);
+ 
+ 	/* We only support MII, RMII, GMII, RGMII & SGMII. */
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != PHY_INTERFACE_MODE_MII &&
+ 	    state->interface != PHY_INTERFACE_MODE_RMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_GMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_10GBASER &&
+ 	    !phy_interface_mode_is_rgmii(state->interface)) {
+ 		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	if (!macb_is_gem(bp) &&
+ 	    (state->interface == PHY_INTERFACE_MODE_GMII ||
+ 	     phy_interface_mode_is_rgmii(state->interface))) {
+ 		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_10GBASER &&
+ 	    !(bp->caps & MACB_CAPS_HIGH_SPEED &&
+ 	      bp->caps & MACB_CAPS_PCS)) {
+ 		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	phylink_set_port_modes(mask);
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set(mask, Asym_Pause);
+ 
+ 	if (bp->caps & MACB_CAPS_GIGABIT_MODE_AVAILABLE &&
+ 	    (state->interface == PHY_INTERFACE_MODE_NA ||
+ 	     state->interface == PHY_INTERFACE_MODE_10GBASER)) {
+ 		phylink_set_10g_modes(mask);
+ 		phylink_set(mask, 10000baseKR_Full);
+ 		if (state->interface != PHY_INTERFACE_MODE_NA)
+ 			goto out;
+ 	}
+ 
+ 	phylink_set(mask, 10baseT_Half);
+ 	phylink_set(mask, 10baseT_Full);
+ 	phylink_set(mask, 100baseT_Half);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+ 	if (bp->caps & MACB_CAPS_GIGABIT_MODE_AVAILABLE &&
+ 	    (state->interface == PHY_INTERFACE_MODE_NA ||
+ 	     state->interface == PHY_INTERFACE_MODE_GMII ||
+ 	     state->interface == PHY_INTERFACE_MODE_SGMII ||
+ 	     phy_interface_mode_is_rgmii(state->interface))) {
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 
+ 		if (!(bp->caps & MACB_CAPS_NO_GIGABIT_HALF))
+ 			phylink_set(mask, 1000baseT_Half);
+ 	}
+ out:
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void macb_usx_pcs_link_up(struct phylink_pcs *pcs, unsigned int mode,
+ 				 phy_interface_t interface, int speed,
+ 				 int duplex)
+ {
+ 	struct macb *bp = container_of(pcs, struct macb, phylink_pcs);
+ 	u32 config;
+ 
+ 	config = gem_readl(bp, USX_CONTROL);
+ 	config = GEM_BFINS(SERDES_RATE, MACB_SERDES_RATE_10G, config);
+ 	config = GEM_BFINS(USX_CTRL_SPEED, HS_SPEED_10000M, config);
+ 	config &= ~(GEM_BIT(TX_SCR_BYPASS) | GEM_BIT(RX_SCR_BYPASS));
+ 	config |= GEM_BIT(TX_EN);
+ 	gem_writel(bp, USX_CONTROL, config);
+ }
+ 
+ static void macb_usx_pcs_get_state(struct phylink_pcs *pcs,
+ 				   struct phylink_link_state *state)
+ {
+ 	struct macb *bp = container_of(pcs, struct macb, phylink_pcs);
+ 	u32 val;
+ 
+ 	state->speed = SPEED_10000;
+ 	state->duplex = 1;
+ 	state->an_complete = 1;
+ 
+ 	val = gem_readl(bp, USX_STATUS);
+ 	state->link = !!(val & GEM_BIT(USX_BLOCK_LOCK));
+ 	val = gem_readl(bp, NCFGR);
+ 	if (val & GEM_BIT(PAE))
+ 		state->pause = MLO_PAUSE_RX;
+ }
+ 
+ static int macb_usx_pcs_config(struct phylink_pcs *pcs,
+ 			       unsigned int mode,
+ 			       phy_interface_t interface,
+ 			       const unsigned long *advertising,
+ 			       bool permit_pause_to_mac)
+ {
+ 	struct macb *bp = container_of(pcs, struct macb, phylink_pcs);
+ 
+ 	gem_writel(bp, USX_CONTROL, gem_readl(bp, USX_CONTROL) |
+ 		   GEM_BIT(SIGNAL_OK));
+ 
+ 	return 0;
+ }
+ 
+ static void macb_pcs_get_state(struct phylink_pcs *pcs,
+ 			       struct phylink_link_state *state)
+ {
+ 	state->link = 0;
+ }
+ 
+ static void macb_pcs_an_restart(struct phylink_pcs *pcs)
+ {
+ 	/* Not supported */
+ }
+ 
+ static int macb_pcs_config(struct phylink_pcs *pcs,
+ 			   unsigned int mode,
+ 			   phy_interface_t interface,
+ 			   const unsigned long *advertising,
+ 			   bool permit_pause_to_mac)
+ {
+ 	return 0;
+ }
+ 
+ static const struct phylink_pcs_ops macb_phylink_usx_pcs_ops = {
+ 	.pcs_get_state = macb_usx_pcs_get_state,
+ 	.pcs_config = macb_usx_pcs_config,
+ 	.pcs_link_up = macb_usx_pcs_link_up,
+ };
+ 
+ static const struct phylink_pcs_ops macb_phylink_pcs_ops = {
+ 	.pcs_get_state = macb_pcs_get_state,
+ 	.pcs_an_restart = macb_pcs_an_restart,
+ 	.pcs_config = macb_pcs_config,
+ };
+ 
+ static void macb_mac_config(struct phylink_config *config, unsigned int mode,
+ 			    const struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct macb *bp = netdev_priv(ndev);
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  	unsigned long flags;
 -	u32 old_ctrl, ctrl;
 -	u32 old_ncr, ncr;
 +	int status_change = 0;
  
  	spin_lock_irqsave(&bp->lock, flags);
  
diff --cc drivers/net/ethernet/marvell/mvneta.c
index 0adf25ced32f,b6c636592dfa..000000000000
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@@ -3257,15 -3824,24 +3257,33 @@@ static void mvneta_validate(struct phyl
  			    struct phylink_link_state *state)
  {
  	struct net_device *ndev = to_net_dev(config->dev);
 -	struct mvneta_port *pp = netdev_priv(ndev);
  	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
  
++<<<<<<< HEAD
 +	/* We only support QSGMII, SGMII, 802.3z and RGMII modes */
 +	if (state->interface != PHY_INTERFACE_MODE_NA &&
 +	    state->interface != PHY_INTERFACE_MODE_QSGMII &&
 +	    state->interface != PHY_INTERFACE_MODE_SGMII &&
 +	    !phy_interface_mode_is_8023z(state->interface) &&
 +	    !phy_interface_mode_is_rgmii(state->interface)) {
 +		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++=======
+ 	/* We only support QSGMII, SGMII, 802.3z and RGMII modes.
+ 	 * When in 802.3z mode, we must have AN enabled:
+ 	 * "Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...
+ 	 * When <PortType> = 1 (1000BASE-X) this field must be set to 1."
+ 	 */
+ 	if (phy_interface_mode_is_8023z(state->interface)) {
+ 		if (!phylink_test(state->advertising, Autoneg)) {
+ 			linkmode_zero(supported);
+ 			return;
+ 		}
+ 	} else if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 		   state->interface != PHY_INTERFACE_MODE_QSGMII &&
+ 		   state->interface != PHY_INTERFACE_MODE_SGMII &&
+ 		   !phy_interface_mode_is_rgmii(state->interface)) {
+ 		linkmode_zero(supported);
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  		return;
  	}
  
@@@ -3287,10 -3870,13 +3305,20 @@@
  		phylink_set(mask, 100baseT_Full);
  	}
  
++<<<<<<< HEAD
 +	bitmap_and(supported, supported, mask,
 +		   __ETHTOOL_LINK_MODE_MASK_NBITS);
 +	bitmap_and(state->advertising, state->advertising, mask,
 +		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++=======
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
+ 	 * to advertise both, only report advertising at 2500BaseX.
+ 	 */
+ 	phylink_helper_basex_speed(state);
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  }
  
  static void mvneta_mac_pcs_get_state(struct phylink_config *config,
diff --cc drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index 48deaf2ffa01,8ddf58f379ac..000000000000
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@@ -4260,40 -6180,172 +4260,141 @@@ static void mvpp2_gmac_pcs_get_state(st
  		state->pause |= MLO_PAUSE_TX;
  }
  
 -static int mvpp2_gmac_pcs_config(struct phylink_pcs *pcs, unsigned int mode,
 -				 phy_interface_t interface,
 -				 const unsigned long *advertising,
 -				 bool permit_pause_to_mac)
 +static void mvpp2_phylink_mac_pcs_get_state(struct phylink_config *config,
 +					    struct phylink_link_state *state)
  {
 -	struct mvpp2_port *port = mvpp2_pcs_to_port(pcs);
 -	u32 mask, val, an, old_an, changed;
 -
 -	mask = MVPP2_GMAC_IN_BAND_AUTONEG_BYPASS |
 -	       MVPP2_GMAC_IN_BAND_AUTONEG |
 -	       MVPP2_GMAC_AN_SPEED_EN |
 -	       MVPP2_GMAC_FLOW_CTRL_AUTONEG |
 -	       MVPP2_GMAC_AN_DUPLEX_EN;
 -
 -	if (phylink_autoneg_inband(mode)) {
 -		mask |= MVPP2_GMAC_CONFIG_MII_SPEED |
 -			MVPP2_GMAC_CONFIG_GMII_SPEED |
 -			MVPP2_GMAC_CONFIG_FULL_DUPLEX;
 -		val = MVPP2_GMAC_IN_BAND_AUTONEG;
 +	struct mvpp2_port *port = container_of(config, struct mvpp2_port,
 +					       phylink_config);
  
 -		if (interface == PHY_INTERFACE_MODE_SGMII) {
 -			/* SGMII mode receives the speed and duplex from PHY */
 -			val |= MVPP2_GMAC_AN_SPEED_EN |
 -			       MVPP2_GMAC_AN_DUPLEX_EN;
 -		} else {
 -			/* 802.3z mode has fixed speed and duplex */
 -			val |= MVPP2_GMAC_CONFIG_GMII_SPEED |
 -			       MVPP2_GMAC_CONFIG_FULL_DUPLEX;
 +	if (port->priv->hw_version == MVPP22 && port->gop_id == 0) {
 +		u32 mode = readl(port->base + MVPP22_XLG_CTRL3_REG);
 +		mode &= MVPP22_XLG_CTRL3_MACMODESELECT_MASK;
  
 -			/* The FLOW_CTRL_AUTONEG bit selects either the hardware
 -			 * automatically or the bits in MVPP22_GMAC_CTRL_4_REG
 -			 * manually controls the GMAC pause modes.
 -			 */
 -			if (permit_pause_to_mac)
 -				val |= MVPP2_GMAC_FLOW_CTRL_AUTONEG;
 -
 -			/* Configure advertisement bits */
 -			mask |= MVPP2_GMAC_FC_ADV_EN | MVPP2_GMAC_FC_ADV_ASM_EN;
 -			if (phylink_test(advertising, Pause))
 -				val |= MVPP2_GMAC_FC_ADV_EN;
 -			if (phylink_test(advertising, Asym_Pause))
 -				val |= MVPP2_GMAC_FC_ADV_ASM_EN;
 +		if (mode == MVPP22_XLG_CTRL3_MACMODESELECT_10G) {
 +			mvpp22_xlg_pcs_get_state(port, state);
 +			return;
  		}
 -	} else {
 -		val = 0;
  	}
  
 -	old_an = an = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -	an = (an & ~mask) | val;
 -	changed = an ^ old_an;
 -	if (changed)
 -		writel(an, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -
 -	/* We are only interested in the advertisement bits changing */
 -	return changed & (MVPP2_GMAC_FC_ADV_EN | MVPP2_GMAC_FC_ADV_ASM_EN);
 +	mvpp2_gmac_pcs_get_state(port, state);
  }
  
 -static void mvpp2_gmac_pcs_an_restart(struct phylink_pcs *pcs)
 +static void mvpp2_mac_an_restart(struct phylink_config *config)
  {
 -	struct mvpp2_port *port = mvpp2_pcs_to_port(pcs);
 +	struct mvpp2_port *port = container_of(config, struct mvpp2_port,
 +					       phylink_config);
  	u32 val = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);
  
 -	writel(val | MVPP2_GMAC_IN_BAND_RESTART_AN,
 -	       port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -	writel(val & ~MVPP2_GMAC_IN_BAND_RESTART_AN,
 -	       port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -}
 +	if (port->phy_interface != PHY_INTERFACE_MODE_SGMII)
 +		return;
  
++<<<<<<< HEAD
 +	val = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 +	/* The RESTART_AN bit is cleared by the h/w after restarting the AN
 +	 * process.
 +	 */
 +	val |= MVPP2_GMAC_IN_BAND_RESTART_AN | MVPP2_GMAC_IN_BAND_AUTONEG;
 +	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
++=======
+ static const struct phylink_pcs_ops mvpp2_phylink_gmac_pcs_ops = {
+ 	.pcs_get_state = mvpp2_gmac_pcs_get_state,
+ 	.pcs_config = mvpp2_gmac_pcs_config,
+ 	.pcs_an_restart = mvpp2_gmac_pcs_an_restart,
+ };
+ 
+ static void mvpp2_phylink_validate(struct phylink_config *config,
+ 				   unsigned long *supported,
+ 				   struct phylink_link_state *state)
+ {
+ 	struct mvpp2_port *port = mvpp2_phylink_to_port(config);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	/* Invalid combinations */
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_10GBASER:
+ 	case PHY_INTERFACE_MODE_XAUI:
+ 		if (!mvpp2_port_supports_xlg(port))
+ 			goto empty_set;
+ 		break;
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 		if (!mvpp2_port_supports_rgmii(port))
+ 			goto empty_set;
+ 		break;
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_2500BASEX:
+ 		/* When in 802.3z mode, we must have AN enabled:
+ 		 * Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...
+ 		 * When <PortType> = 1 (1000BASE-X) this field must be set to 1.
+ 		 */
+ 		if (!phylink_test(state->advertising, Autoneg))
+ 			goto empty_set;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+ 
+ 	if (port->priv->global_tx_fc) {
+ 		phylink_set(mask, Pause);
+ 		phylink_set(mask, Asym_Pause);
+ 	}
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_10GBASER:
+ 	case PHY_INTERFACE_MODE_XAUI:
+ 	case PHY_INTERFACE_MODE_NA:
+ 		if (mvpp2_port_supports_xlg(port)) {
+ 			phylink_set_10g_modes(mask);
+ 			phylink_set(mask, 10000baseKR_Full);
+ 		}
+ 		if (state->interface != PHY_INTERFACE_MODE_NA)
+ 			break;
+ 		fallthrough;
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+ 		phylink_set(mask, 100baseT_Half);
+ 		phylink_set(mask, 100baseT_Full);
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 		if (state->interface != PHY_INTERFACE_MODE_NA)
+ 			break;
+ 		fallthrough;
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_2500BASEX:
+ 		if (port->comphy ||
+ 		    state->interface != PHY_INTERFACE_MODE_2500BASEX) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseX_Full);
+ 		}
+ 		if (port->comphy ||
+ 		    state->interface == PHY_INTERFACE_MODE_2500BASEX) {
+ 			phylink_set(mask, 2500baseT_Full);
+ 			phylink_set(mask, 2500baseX_Full);
+ 		}
+ 		break;
+ 	default:
+ 		goto empty_set;
+ 	}
+ 
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	phylink_helper_basex_speed(state);
+ 	return;
+ 
+ empty_set:
+ 	linkmode_zero(supported);
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  }
  
  static void mvpp2_xlg_config(struct mvpp2_port *port, unsigned int mode,
diff --cc drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 01416fbdb4f0,9b068b81ae09..000000000000
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@@ -1306,8 -1498,202 +1306,207 @@@ static const struct ethtool_ops axienet
  	.set_pauseparam = axienet_ethtools_set_pauseparam,
  	.get_coalesce   = axienet_ethtools_get_coalesce,
  	.set_coalesce   = axienet_ethtools_set_coalesce,
++<<<<<<< HEAD
 +	.get_link_ksettings = phy_ethtool_get_link_ksettings,
 +	.set_link_ksettings = phy_ethtool_set_link_ksettings,
++=======
+ 	.get_link_ksettings = axienet_ethtools_get_link_ksettings,
+ 	.set_link_ksettings = axienet_ethtools_set_link_ksettings,
+ 	.nway_reset	= axienet_ethtools_nway_reset,
+ };
+ 
+ static void axienet_validate(struct phylink_config *config,
+ 			     unsigned long *supported,
+ 			     struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	/* Only support the mode we are configured for */
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_NA:
+ 		break;
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 		if (lp->switch_x_sgmii)
+ 			break;
+ 		fallthrough;
+ 	default:
+ 		if (state->interface != lp->phy_mode) {
+ 			netdev_warn(ndev, "Cannot use PHY mode %s, supported: %s\n",
+ 				    phy_modes(state->interface),
+ 				    phy_modes(lp->phy_mode));
+ 			linkmode_zero(supported);
+ 			return;
+ 		}
+ 	}
+ 
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+ 
+ 	phylink_set(mask, Asym_Pause);
+ 	phylink_set(mask, Pause);
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_NA:
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 	case PHY_INTERFACE_MODE_GMII:
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 		phylink_set(mask, 1000baseX_Full);
+ 		phylink_set(mask, 1000baseT_Full);
+ 		if (state->interface == PHY_INTERFACE_MODE_1000BASEX)
+ 			break;
+ 		fallthrough;
+ 	case PHY_INTERFACE_MODE_MII:
+ 		phylink_set(mask, 100baseT_Full);
+ 		phylink_set(mask, 10baseT_Full);
+ 		fallthrough;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void axienet_mac_pcs_get_state(struct phylink_config *config,
+ 				      struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 		phylink_mii_c22_pcs_get_state(lp->pcs_phy, state);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void axienet_mac_an_restart(struct phylink_config *config)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 
+ 	phylink_mii_c22_pcs_an_restart(lp->pcs_phy);
+ }
+ 
+ static int axienet_mac_prepare(struct phylink_config *config, unsigned int mode,
+ 			       phy_interface_t iface)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	int ret;
+ 
+ 	switch (iface) {
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 		if (!lp->switch_x_sgmii)
+ 			return 0;
+ 
+ 		ret = mdiobus_write(lp->pcs_phy->bus,
+ 				    lp->pcs_phy->addr,
+ 				    XLNX_MII_STD_SELECT_REG,
+ 				    iface == PHY_INTERFACE_MODE_SGMII ?
+ 					XLNX_MII_STD_SELECT_SGMII : 0);
+ 		if (ret < 0)
+ 			netdev_warn(ndev, "Failed to switch PHY interface: %d\n",
+ 				    ret);
+ 		return ret;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static void axienet_mac_config(struct phylink_config *config, unsigned int mode,
+ 			       const struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	int ret;
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 		ret = phylink_mii_c22_pcs_config(lp->pcs_phy, mode,
+ 						 state->interface,
+ 						 state->advertising);
+ 		if (ret < 0)
+ 			netdev_warn(ndev, "Failed to configure PCS: %d\n",
+ 				    ret);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void axienet_mac_link_down(struct phylink_config *config,
+ 				  unsigned int mode,
+ 				  phy_interface_t interface)
+ {
+ 	/* nothing meaningful to do */
+ }
+ 
+ static void axienet_mac_link_up(struct phylink_config *config,
+ 				struct phy_device *phy,
+ 				unsigned int mode, phy_interface_t interface,
+ 				int speed, int duplex,
+ 				bool tx_pause, bool rx_pause)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	u32 emmc_reg, fcc_reg;
+ 
+ 	emmc_reg = axienet_ior(lp, XAE_EMMC_OFFSET);
+ 	emmc_reg &= ~XAE_EMMC_LINKSPEED_MASK;
+ 
+ 	switch (speed) {
+ 	case SPEED_1000:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_1000;
+ 		break;
+ 	case SPEED_100:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_100;
+ 		break;
+ 	case SPEED_10:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_10;
+ 		break;
+ 	default:
+ 		dev_err(&ndev->dev,
+ 			"Speed other than 10, 100 or 1Gbps is not supported\n");
+ 		break;
+ 	}
+ 
+ 	axienet_iow(lp, XAE_EMMC_OFFSET, emmc_reg);
+ 
+ 	fcc_reg = axienet_ior(lp, XAE_FCC_OFFSET);
+ 	if (tx_pause)
+ 		fcc_reg |= XAE_FCC_FCTX_MASK;
+ 	else
+ 		fcc_reg &= ~XAE_FCC_FCTX_MASK;
+ 	if (rx_pause)
+ 		fcc_reg |= XAE_FCC_FCRX_MASK;
+ 	else
+ 		fcc_reg &= ~XAE_FCC_FCRX_MASK;
+ 	axienet_iow(lp, XAE_FCC_OFFSET, fcc_reg);
+ }
+ 
+ static const struct phylink_mac_ops axienet_phylink_ops = {
+ 	.validate = axienet_validate,
+ 	.mac_pcs_get_state = axienet_mac_pcs_get_state,
+ 	.mac_an_restart = axienet_mac_an_restart,
+ 	.mac_prepare = axienet_mac_prepare,
+ 	.mac_config = axienet_mac_config,
+ 	.mac_link_down = axienet_mac_link_down,
+ 	.mac_link_up = axienet_mac_link_up,
++>>>>>>> 4973056cceac (net: convert users of bitmap_foo() to linkmode_foo())
  };
  
  /**
* Unmerged path drivers/net/dsa/hirschmann/hellcreek.c
* Unmerged path drivers/net/dsa/lantiq_gswip.c
* Unmerged path drivers/net/dsa/microchip/ksz8795.c
* Unmerged path drivers/net/dsa/ocelot/felix_vsc9959.c
* Unmerged path drivers/net/dsa/ocelot/seville_vsc9953.c
* Unmerged path drivers/net/dsa/qca/ar9331.c
* Unmerged path drivers/net/dsa/sja1105/sja1105_main.c
* Unmerged path drivers/net/dsa/xrs700x/xrs700x.c
* Unmerged path drivers/net/ethernet/atheros/ag71xx.c
* Unmerged path drivers/net/ethernet/freescale/enetc/enetc_pf.c
* Unmerged path drivers/net/ethernet/huawei/hinic/hinic_ethtool.c
* Unmerged path drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
* Unmerged path drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_net.c
* Unmerged path drivers/net/dsa/b53/b53_common.c
* Unmerged path drivers/net/dsa/bcm_sf2.c
* Unmerged path drivers/net/dsa/hirschmann/hellcreek.c
* Unmerged path drivers/net/dsa/lantiq_gswip.c
* Unmerged path drivers/net/dsa/microchip/ksz8795.c
* Unmerged path drivers/net/dsa/mv88e6xxx/chip.c
* Unmerged path drivers/net/dsa/ocelot/felix_vsc9959.c
* Unmerged path drivers/net/dsa/ocelot/seville_vsc9953.c
* Unmerged path drivers/net/dsa/qca/ar9331.c
* Unmerged path drivers/net/dsa/sja1105/sja1105_main.c
* Unmerged path drivers/net/dsa/xrs700x/xrs700x.c
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
index 847d991c46db..a7beeddab1e2 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
@@ -369,9 +369,8 @@ static int xgbe_set_link_ksettings(struct net_device *netdev,
 		  __ETHTOOL_LINK_MODE_MASK_NBITS, cmd->link_modes.advertising,
 		  __ETHTOOL_LINK_MODE_MASK_NBITS, lks->link_modes.supported);
 
-	bitmap_and(advertising,
-		   cmd->link_modes.advertising, lks->link_modes.supported,
-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_and(advertising, cmd->link_modes.advertising,
+		     lks->link_modes.supported);
 
 	if ((cmd->base.autoneg == AUTONEG_ENABLE) &&
 	    bitmap_empty(advertising, __ETHTOOL_LINK_MODE_MASK_NBITS)) {
@@ -384,8 +383,7 @@ static int xgbe_set_link_ksettings(struct net_device *netdev,
 	pdata->phy.autoneg = cmd->base.autoneg;
 	pdata->phy.speed = speed;
 	pdata->phy.duplex = cmd->base.duplex;
-	bitmap_copy(lks->link_modes.advertising, advertising,
-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_copy(lks->link_modes.advertising, advertising);
 
 	if (cmd->base.autoneg == AUTONEG_ENABLE)
 		XGBE_SET_ADV(lks, Autoneg);
* Unmerged path drivers/net/ethernet/atheros/ag71xx.c
* Unmerged path drivers/net/ethernet/cadence/macb_main.c
* Unmerged path drivers/net/ethernet/freescale/enetc/enetc_pf.c
* Unmerged path drivers/net/ethernet/huawei/hinic/hinic_ethtool.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index b083255520a4..71196fd92f81 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -469,9 +469,8 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
 		 * this function does not support duplex forcing, but can
 		 * limit the advertising of the adapter to the specified speed
 		 */
-		if (!bitmap_subset(cmd->link_modes.advertising,
-				   cmd->link_modes.supported,
-				   __ETHTOOL_LINK_MODE_MASK_NBITS))
+		if (!linkmode_subset(cmd->link_modes.advertising,
+				     cmd->link_modes.supported))
 			return -EINVAL;
 
 		/* only allow one speed at a time if no autoneg */
* Unmerged path drivers/net/ethernet/marvell/mvneta.c
* Unmerged path drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
* Unmerged path drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index a61f0b6c374b..592e47d61a83 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -988,8 +988,7 @@ static int pxa168_init_phy(struct net_device *dev)
 	cmd.base.phy_address = pep->phy_addr;
 	cmd.base.speed = pep->phy_speed;
 	cmd.base.duplex = pep->phy_duplex;
-	bitmap_copy(cmd.link_modes.advertising, PHY_BASIC_FEATURES,
-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_copy(cmd.link_modes.advertising, PHY_BASIC_FEATURES);
 	cmd.base.autoneg = AUTONEG_ENABLE;
 
 	if (cmd.base.speed != 0)
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 2d4fb23b4008..ed5038d98ef6 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -39,6 +39,7 @@
 #include <linux/in.h>
 #include <net/ip.h>
 #include <linux/bitmap.h>
+#include <linux/mii.h>
 
 #include "mlx4_en.h"
 #include "en_port.h"
@@ -651,10 +652,8 @@ static unsigned long *ptys2ethtool_link_mode(struct ptys2ethtool_config *cfg,
 		unsigned int i;						\
 		cfg = &ptys2ethtool_map[reg_];				\
 		cfg->speed = speed_;					\
-		bitmap_zero(cfg->supported,				\
-			    __ETHTOOL_LINK_MODE_MASK_NBITS);		\
-		bitmap_zero(cfg->advertised,				\
-			    __ETHTOOL_LINK_MODE_MASK_NBITS);		\
+		linkmode_zero(cfg->supported);				\
+		linkmode_zero(cfg->advertised);				\
 		for (i = 0 ; i < ARRAY_SIZE(modes) ; ++i) {		\
 			__set_bit(modes[i], cfg->supported);		\
 			__set_bit(modes[i], cfg->advertised);		\
@@ -710,10 +709,8 @@ static void ptys2ethtool_update_link_modes(unsigned long *link_modes,
 	int i;
 	for (i = 0; i < MLX4_LINK_MODES_SZ; i++) {
 		if (eth_proto & MLX4_PROT_MASK(i))
-			bitmap_or(link_modes, link_modes,
-				  ptys2ethtool_link_mode(&ptys2ethtool_map[i],
-							 report),
-				  __ETHTOOL_LINK_MODE_MASK_NBITS);
+			linkmode_or(link_modes, link_modes,
+				    ptys2ethtool_link_mode(&ptys2ethtool_map[i], report));
 	}
 }
 
@@ -724,11 +721,9 @@ static u32 ethtool2ptys_link_modes(const unsigned long *link_modes,
 	u32 ptys_modes = 0;
 
 	for (i = 0; i < MLX4_LINK_MODES_SZ; i++) {
-		if (bitmap_intersects(
-			    ptys2ethtool_link_mode(&ptys2ethtool_map[i],
-						   report),
-			    link_modes,
-			    __ETHTOOL_LINK_MODE_MASK_NBITS))
+		ulong *map_mode = ptys2ethtool_link_mode(&ptys2ethtool_map[i],
+							 report);
+		if (linkmode_intersects(map_mode, link_modes))
 			ptys_modes |= 1 << i;
 	}
 	return ptys_modes;
* Unmerged path drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_net.c
diff --git a/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c b/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c
index ab4af8374add..386a5cf1e224 100644
--- a/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c
@@ -214,8 +214,7 @@ static int ionic_get_link_ksettings(struct net_device *netdev,
 		break;
 	}
 
-	bitmap_copy(ks->link_modes.advertising, ks->link_modes.supported,
-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_copy(ks->link_modes.advertising, ks->link_modes.supported);
 
 	ethtool_link_ksettings_add_link_mode(ks, supported, FEC_BASER);
 	ethtool_link_ksettings_add_link_mode(ks, supported, FEC_RS);
* Unmerged path drivers/net/ethernet/xilinx/xilinx_axienet_main.c
diff --git a/drivers/net/pcs/pcs-xpcs.c b/drivers/net/pcs/pcs-xpcs.c
index 89a5f43612cf..22100151ff6e 100644
--- a/drivers/net/pcs/pcs-xpcs.c
+++ b/drivers/net/pcs/pcs-xpcs.c
@@ -703,7 +703,7 @@ void xpcs_validate(struct mdio_xpcs_args *xpcs, unsigned long *supported,
 	if (state->interface == PHY_INTERFACE_MODE_NA)
 		return;
 
-	bitmap_zero(xpcs_supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_zero(xpcs_supported);
 
 	compat = xpcs_find_compat(xpcs->id, state->interface);
 
diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
index 10199d5d3f08..5575a26c19a1 100644
--- a/drivers/net/phy/sfp-bus.c
+++ b/drivers/net/phy/sfp-bus.c
@@ -347,7 +347,7 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
 	if (bus->sfp_quirk)
 		bus->sfp_quirk->modes(id, modes);
 
-	bitmap_or(support, support, modes, __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_or(support, support, modes);
 
 	phylink_set(support, Autoneg);
 	phylink_set(support, Pause);
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index b5ec3f738a58..6a31e55ed452 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -359,7 +359,7 @@ EXPORT_SYMBOL(ethtool_intersect_link_masks);
 void ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,
 					     u32 legacy_u32)
 {
-	bitmap_zero(dst, __ETHTOOL_LINK_MODE_MASK_NBITS);
+	linkmode_zero(dst);
 	dst[0] = legacy_u32;
 }
 EXPORT_SYMBOL(ethtool_convert_legacy_u32_to_link_mode);
@@ -374,11 +374,10 @@ bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
 	if (__ETHTOOL_LINK_MODE_MASK_NBITS > 32) {
 		__ETHTOOL_DECLARE_LINK_MODE_MASK(ext);
 
-		bitmap_zero(ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+		linkmode_zero(ext);
 		bitmap_fill(ext, 32);
 		bitmap_complement(ext, ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
-		if (bitmap_intersects(ext, src,
-				      __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+		if (linkmode_intersects(ext, src)) {
 			/* src mask goes beyond bit 31 */
 			retval = false;
 		}
