RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Aharon Landau <aharonl@nvidia.com>
commit 636bdbfc9996567af1a3ed89ecf92ea5028a8a89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/636bdbfc.failed

Move mlx5_ib_update_mr_pas logic to umr.c, and use
mlx5_umr_post_send_wait() instead of mlx5_ib_post_send_wait().

Since it is the last use of mlx5_ib_post_send_wait(), remove it.

Link: https://lore.kernel.org/r/55a4972f156aba3592a2fc9bcb33e2059acf295f.1649747695.git.leonro@nvidia.com
	Signed-off-by: Aharon Landau <aharonl@nvidia.com>
	Reviewed-by: Michael Guralnik <michaelgur@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 636bdbfc9996567af1a3ed89ecf92ea5028a8a89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/mr.c
#	drivers/infiniband/hw/mlx5/odp.c
#	drivers/infiniband/hw/mlx5/umr.c
#	drivers/infiniband/hw/mlx5/umr.h
diff --cc drivers/infiniband/hw/mlx5/mr.c
index 1faf0a4d0186,9bfbd8d199ee..000000000000
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@@ -862,74 -834,6 +857,77 @@@ static int mr_cache_max_order(struct ml
  	return MLX5_MAX_UMR_SHIFT;
  }
  
++<<<<<<< HEAD
 +static struct ib_umem *mr_umem_get(struct mlx5_ib_dev *dev, struct ib_udata *udata,
 +				   u64 start, u64 length, int access_flags)
 +{
 +	struct ib_umem *u;
 +
 +	if (access_flags & IB_ACCESS_ON_DEMAND) {
 +		struct ib_umem_odp *odp;
 +
 +		odp = ib_umem_odp_get(udata, start, length, access_flags);
 +		if (IS_ERR(odp)) {
 +			mlx5_ib_dbg(dev, "umem get failed (%ld)\n",
 +				    PTR_ERR(odp));
 +			return ERR_CAST(odp);
 +		}
 +		return &odp->umem;
 +	}
 +
 +	 u = ib_umem_get(udata, start, length, access_flags);
 +	if (IS_ERR(u)) {
 +		mlx5_ib_dbg(dev, "umem get failed (%ld)\n", PTR_ERR(u));
 +		return u;
 +	}
 +	return u;
 +}
 +
 +static void mlx5_ib_umr_done(struct ib_cq *cq, struct ib_wc *wc)
 +{
 +	struct mlx5_ib_umr_context *context =
 +		container_of(wc->wr_cqe, struct mlx5_ib_umr_context, cqe);
 +
 +	context->status = wc->status;
 +	complete(&context->done);
 +}
 +
 +static inline void mlx5_ib_init_umr_context(struct mlx5_ib_umr_context *context)
 +{
 +	context->cqe.done = mlx5_ib_umr_done;
 +	context->status = -1;
 +	init_completion(&context->done);
 +}
 +
 +static int mlx5_ib_post_send_wait(struct mlx5_ib_dev *dev,
 +				  struct mlx5_umr_wr *umrwr)
 +{
 +	struct umr_common *umrc = &dev->umrc;
 +	const struct ib_send_wr *bad;
 +	int err;
 +	struct mlx5_ib_umr_context umr_context;
 +
 +	mlx5_ib_init_umr_context(&umr_context);
 +	umrwr->wr.wr_cqe = &umr_context.cqe;
 +
 +	down(&umrc->sem);
 +	err = ib_post_send(umrc->qp, &umrwr->wr, &bad);
 +	if (err) {
 +		mlx5_ib_warn(dev, "UMR post send failed, err %d\n", err);
 +	} else {
 +		wait_for_completion(&umr_context.done);
 +		if (umr_context.status != IB_WC_SUCCESS) {
 +			mlx5_ib_warn(dev, "reg umr failed (%u)\n",
 +				     umr_context.status);
 +			err = -EFAULT;
 +		}
 +	}
 +	up(&umrc->sem);
 +	return err;
 +}
 +
++=======
++>>>>>>> 636bdbfc9996 (RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt)
  static struct mlx5_cache_ent *mr_cache_ent_from_order(struct mlx5_ib_dev *dev,
  						      unsigned int order)
  {
@@@ -976,284 -911,7 +974,287 @@@ static struct mlx5_ib_mr *alloc_mr_from
  	return mr;
  }
  
 +#define MLX5_MAX_UMR_CHUNK ((1 << (MLX5_MAX_UMR_SHIFT + 4)) - \
 +			    MLX5_UMR_MTT_ALIGNMENT)
 +#define MLX5_SPARE_UMR_CHUNK 0x10000
 +
  /*
 + * Allocate a temporary buffer to hold the per-page information to transfer to
 + * HW. For efficiency this should be as large as it can be, but buffer
 + * allocation failure is not allowed, so try smaller sizes.
 + */
 +static void *mlx5_ib_alloc_xlt(size_t *nents, size_t ent_size, gfp_t gfp_mask)
 +{
 +	const size_t xlt_chunk_align =
 +		MLX5_UMR_MTT_ALIGNMENT / ent_size;
 +	size_t size;
 +	void *res = NULL;
 +
 +	static_assert(PAGE_SIZE % MLX5_UMR_MTT_ALIGNMENT == 0);
 +
 +	/*
 +	 * MLX5_IB_UPD_XLT_ATOMIC doesn't signal an atomic context just that the
 +	 * allocation can't trigger any kind of reclaim.
 +	 */
 +	might_sleep();
 +
 +	gfp_mask |= __GFP_ZERO | __GFP_NORETRY;
 +
 +	/*
 +	 * If the system already has a suitable high order page then just use
 +	 * that, but don't try hard to create one. This max is about 1M, so a
 +	 * free x86 huge page will satisfy it.
 +	 */
 +	size = min_t(size_t, ent_size * ALIGN(*nents, xlt_chunk_align),
 +		     MLX5_MAX_UMR_CHUNK);
 +	*nents = size / ent_size;
 +	res = (void *)__get_free_pages(gfp_mask | __GFP_NOWARN,
 +				       get_order(size));
 +	if (res)
 +		return res;
 +
 +	if (size > MLX5_SPARE_UMR_CHUNK) {
 +		size = MLX5_SPARE_UMR_CHUNK;
 +		*nents = size / ent_size;
 +		res = (void *)__get_free_pages(gfp_mask | __GFP_NOWARN,
 +					       get_order(size));
 +		if (res)
 +			return res;
 +	}
 +
 +	*nents = PAGE_SIZE / ent_size;
 +	res = (void *)__get_free_page(gfp_mask);
 +	if (res)
 +		return res;
 +
 +	mutex_lock(&xlt_emergency_page_mutex);
 +	memset(xlt_emergency_page, 0, PAGE_SIZE);
 +	return xlt_emergency_page;
 +}
 +
 +static void mlx5_ib_free_xlt(void *xlt, size_t length)
 +{
 +	if (xlt == xlt_emergency_page) {
 +		mutex_unlock(&xlt_emergency_page_mutex);
 +		return;
 +	}
 +
 +	free_pages((unsigned long)xlt, get_order(length));
 +}
 +
 +/*
++<<<<<<< HEAD
 + * Create a MLX5_IB_SEND_UMR_UPDATE_XLT work request and XLT buffer ready for
 + * submission.
 + */
 +static void *mlx5_ib_create_xlt_wr(struct mlx5_ib_mr *mr,
 +				   struct mlx5_umr_wr *wr, struct ib_sge *sg,
 +				   size_t nents, size_t ent_size,
 +				   unsigned int flags)
 +{
 +	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
 +	struct device *ddev = &dev->mdev->pdev->dev;
 +	dma_addr_t dma;
 +	void *xlt;
 +
 +	xlt = mlx5_ib_alloc_xlt(&nents, ent_size,
 +				flags & MLX5_IB_UPD_XLT_ATOMIC ? GFP_ATOMIC :
 +								 GFP_KERNEL);
 +	sg->length = nents * ent_size;
 +	dma = dma_map_single(ddev, xlt, sg->length, DMA_TO_DEVICE);
 +	if (dma_mapping_error(ddev, dma)) {
 +		mlx5_ib_err(dev, "unable to map DMA during XLT update.\n");
 +		mlx5_ib_free_xlt(xlt, sg->length);
 +		return NULL;
 +	}
 +	sg->addr = dma;
 +	sg->lkey = dev->umrc.pd->local_dma_lkey;
 +
 +	memset(wr, 0, sizeof(*wr));
 +	wr->wr.send_flags = MLX5_IB_SEND_UMR_UPDATE_XLT;
 +	if (!(flags & MLX5_IB_UPD_XLT_ENABLE))
 +		wr->wr.send_flags |= MLX5_IB_SEND_UMR_FAIL_IF_FREE;
 +	wr->wr.sg_list = sg;
 +	wr->wr.num_sge = 1;
 +	wr->wr.opcode = MLX5_IB_WR_UMR;
 +	wr->pd = mr->ibmr.pd;
 +	wr->mkey = mr->mmkey.key;
 +	wr->length = mr->ibmr.length;
 +	wr->virt_addr = mr->ibmr.iova;
 +	wr->access_flags = mr->access_flags;
 +	wr->page_shift = mr->page_shift;
 +	wr->xlt_size = sg->length;
 +	return xlt;
 +}
 +
 +static void mlx5_ib_unmap_free_xlt(struct mlx5_ib_dev *dev, void *xlt,
 +				   struct ib_sge *sg)
 +{
 +	struct device *ddev = &dev->mdev->pdev->dev;
 +
 +	dma_unmap_single(ddev, sg->addr, sg->length, DMA_TO_DEVICE);
 +	mlx5_ib_free_xlt(xlt, sg->length);
 +}
 +
 +static unsigned int xlt_wr_final_send_flags(unsigned int flags)
 +{
 +	unsigned int res = 0;
 +
 +	if (flags & MLX5_IB_UPD_XLT_ENABLE)
 +		res |= MLX5_IB_SEND_UMR_ENABLE_MR |
 +		       MLX5_IB_SEND_UMR_UPDATE_PD_ACCESS |
 +		       MLX5_IB_SEND_UMR_UPDATE_TRANSLATION;
 +	if (flags & MLX5_IB_UPD_XLT_PD || flags & MLX5_IB_UPD_XLT_ACCESS)
 +		res |= MLX5_IB_SEND_UMR_UPDATE_PD_ACCESS;
 +	if (flags & MLX5_IB_UPD_XLT_ADDR)
 +		res |= MLX5_IB_SEND_UMR_UPDATE_TRANSLATION;
 +	return res;
 +}
 +
 +int mlx5_ib_update_xlt(struct mlx5_ib_mr *mr, u64 idx, int npages,
 +		       int page_shift, int flags)
 +{
 +	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
 +	struct device *ddev = &dev->mdev->pdev->dev;
 +	void *xlt;
 +	struct mlx5_umr_wr wr;
 +	struct ib_sge sg;
 +	int err = 0;
 +	int desc_size = (flags & MLX5_IB_UPD_XLT_INDIRECT)
 +			       ? sizeof(struct mlx5_klm)
 +			       : sizeof(struct mlx5_mtt);
 +	const int page_align = MLX5_UMR_MTT_ALIGNMENT / desc_size;
 +	const int page_mask = page_align - 1;
 +	size_t pages_mapped = 0;
 +	size_t pages_to_map = 0;
 +	size_t pages_iter;
 +	size_t size_to_map = 0;
 +	size_t orig_sg_length;
 +
 +	if ((flags & MLX5_IB_UPD_XLT_INDIRECT) &&
 +	    !umr_can_use_indirect_mkey(dev))
 +		return -EPERM;
 +
 +	if (WARN_ON(!mr->umem->is_odp))
 +		return -EINVAL;
 +
 +	/* UMR copies MTTs in units of MLX5_UMR_MTT_ALIGNMENT bytes,
 +	 * so we need to align the offset and length accordingly
 +	 */
 +	if (idx & page_mask) {
 +		npages += idx & page_mask;
 +		idx &= ~page_mask;
 +	}
 +	pages_to_map = ALIGN(npages, page_align);
 +
 +	xlt = mlx5_ib_create_xlt_wr(mr, &wr, &sg, npages, desc_size, flags);
 +	if (!xlt)
 +		return -ENOMEM;
 +	pages_iter = sg.length / desc_size;
 +	orig_sg_length = sg.length;
 +
 +	if (!(flags & MLX5_IB_UPD_XLT_INDIRECT)) {
 +		struct ib_umem_odp *odp = to_ib_umem_odp(mr->umem);
 +		size_t max_pages = ib_umem_odp_num_pages(odp) - idx;
 +
 +		pages_to_map = min_t(size_t, pages_to_map, max_pages);
 +	}
 +
 +	wr.page_shift = page_shift;
 +
 +	for (pages_mapped = 0;
 +	     pages_mapped < pages_to_map && !err;
 +	     pages_mapped += pages_iter, idx += pages_iter) {
 +		npages = min_t(int, pages_iter, pages_to_map - pages_mapped);
 +		size_to_map = npages * desc_size;
 +		dma_sync_single_for_cpu(ddev, sg.addr, sg.length,
 +					DMA_TO_DEVICE);
 +		mlx5_odp_populate_xlt(xlt, idx, npages, mr, flags);
 +		dma_sync_single_for_device(ddev, sg.addr, sg.length,
 +					   DMA_TO_DEVICE);
 +
 +		sg.length = ALIGN(size_to_map, MLX5_UMR_MTT_ALIGNMENT);
 +
 +		if (pages_mapped + pages_iter >= pages_to_map)
 +			wr.wr.send_flags |= xlt_wr_final_send_flags(flags);
 +
 +		wr.offset = idx * desc_size;
 +		wr.xlt_size = sg.length;
 +
 +		err = mlx5_ib_post_send_wait(dev, &wr);
 +	}
 +	sg.length = orig_sg_length;
 +	mlx5_ib_unmap_free_xlt(dev, xlt, &sg);
 +	return err;
 +}
 +
 +/*
 + * Send the DMA list to the HW for a normal MR using UMR.
 + */
 +static int mlx5_ib_update_mr_pas(struct mlx5_ib_mr *mr, unsigned int flags)
 +{
 +	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
 +	struct device *ddev = &dev->mdev->pdev->dev;
 +	struct ib_block_iter biter;
 +	struct mlx5_mtt *cur_mtt;
 +	struct mlx5_umr_wr wr;
 +	size_t orig_sg_length;
 +	struct mlx5_mtt *mtt;
 +	size_t final_size;
 +	struct ib_sge sg;
 +	int err = 0;
 +
 +	if (WARN_ON(mr->umem->is_odp))
 +		return -EINVAL;
 +
 +	mtt = mlx5_ib_create_xlt_wr(mr, &wr, &sg,
 +				    ib_umem_num_dma_blocks(mr->umem,
 +							   1 << mr->page_shift),
 +				    sizeof(*mtt), flags);
 +	if (!mtt)
 +		return -ENOMEM;
 +	orig_sg_length = sg.length;
 +
 +	cur_mtt = mtt;
 +	rdma_for_each_block (mr->umem->sgt_append.sgt.sgl, &biter,
 +			     mr->umem->sgt_append.sgt.nents,
 +			     BIT(mr->page_shift)) {
 +		if (cur_mtt == (void *)mtt + sg.length) {
 +			dma_sync_single_for_device(ddev, sg.addr, sg.length,
 +						   DMA_TO_DEVICE);
 +			err = mlx5_ib_post_send_wait(dev, &wr);
 +			if (err)
 +				goto err;
 +			dma_sync_single_for_cpu(ddev, sg.addr, sg.length,
 +						DMA_TO_DEVICE);
 +			wr.offset += sg.length;
 +			cur_mtt = mtt;
 +		}
 +
 +		cur_mtt->ptag =
 +			cpu_to_be64(rdma_block_iter_dma_address(&biter) |
 +				    MLX5_IB_MTT_PRESENT);
 +		cur_mtt++;
 +	}
 +
 +	final_size = (void *)cur_mtt - (void *)mtt;
 +	sg.length = ALIGN(final_size, MLX5_UMR_MTT_ALIGNMENT);
 +	memset(cur_mtt, 0, sg.length - final_size);
 +	wr.wr.send_flags |= xlt_wr_final_send_flags(flags);
 +	wr.xlt_size = sg.length;
 +
 +	dma_sync_single_for_device(ddev, sg.addr, sg.length, DMA_TO_DEVICE);
 +	err = mlx5_ib_post_send_wait(dev, &wr);
 +
 +err:
 +	sg.length = orig_sg_length;
 +	mlx5_ib_unmap_free_xlt(dev, mtt, &sg);
 +	return err;
 +}
 +
 +/*
++=======
++>>>>>>> 636bdbfc9996 (RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt)
   * If ibmr is NULL it will be allocated by reg_create.
   * Else, the given ibmr will be used.
   */
diff --cc drivers/infiniband/hw/mlx5/odp.c
index 446d722140da,66ac7bdc59f6..000000000000
--- a/drivers/infiniband/hw/mlx5/odp.c
+++ b/drivers/infiniband/hw/mlx5/odp.c
@@@ -493,16 -510,15 +493,25 @@@ struct mlx5_ib_mr *mlx5_ib_alloc_implic
  	imr->ibmr.rkey = imr->mmkey.key;
  	imr->ibmr.device = &dev->ib_dev;
  	imr->umem = &umem_odp->umem;
 -	imr->is_odp_implicit = true;
  	xa_init(&imr->implicit_children);
  
++<<<<<<< HEAD
 +	imr->is_odp_implicit = true;
 +
 +	err = mlx5_ib_update_xlt(imr, 0,
 +				 mlx5_imr_ksm_entries,
 +				 MLX5_KSM_PAGE_SHIFT,
 +				 MLX5_IB_UPD_XLT_INDIRECT |
 +				 MLX5_IB_UPD_XLT_ZAP |
 +				 MLX5_IB_UPD_XLT_ENABLE);
++=======
+ 	err = mlx5r_umr_update_xlt(imr, 0,
+ 				   mlx5_imr_ksm_entries,
+ 				   MLX5_KSM_PAGE_SHIFT,
+ 				   MLX5_IB_UPD_XLT_INDIRECT |
+ 				   MLX5_IB_UPD_XLT_ZAP |
+ 				   MLX5_IB_UPD_XLT_ENABLE);
++>>>>>>> 636bdbfc9996 (RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt)
  	if (err)
  		goto out_mr;
  
@@@ -562,18 -577,11 +571,26 @@@ static int pagefault_real_mr(struct mlx
  	if (np < 0)
  		return np;
  
++<<<<<<< HEAD
 +	mutex_lock(&odp->umem_mutex);
 +	if (!ib_umem_mmu_notifier_retry(odp, current_seq)) {
 +		/*
 +		 * No need to check whether the MTTs really belong to
 +		 * this MR, since ib_umem_odp_map_dma_pages already
 +		 * checks this.
 +		 */
 +		ret = mlx5_ib_update_xlt(mr, start_idx, np,
 +					 page_shift, MLX5_IB_UPD_XLT_ATOMIC);
 +	} else {
 +		ret = -EAGAIN;
 +	}
++=======
+ 	/*
+ 	 * No need to check whether the MTTs really belong to this MR, since
+ 	 * ib_umem_odp_map_dma_and_lock already checks this.
+ 	 */
+ 	ret = mlx5r_umr_update_xlt(mr, start_idx, np, page_shift, xlt_flags);
++>>>>>>> 636bdbfc9996 (RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt)
  	mutex_unlock(&odp->umem_mutex);
  
  	if (ret < 0) {
diff --cc drivers/infiniband/hw/mlx5/umr.c
index 46eaf919eb49,ad9e31107901..000000000000
--- a/drivers/infiniband/hw/mlx5/umr.c
+++ b/drivers/infiniband/hw/mlx5/umr.c
@@@ -1,8 -1,141 +1,9 @@@
  // SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
  /* Copyright (c) 2022, NVIDIA CORPORATION & AFFILIATES. */
  
+ #include <rdma/ib_umem_odp.h>
  #include "mlx5_ib.h"
  #include "umr.h"
 -#include "wr.h"
 -
 -/*
 - * We can't use an array for xlt_emergency_page because dma_map_single doesn't
 - * work on kernel modules memory
 - */
 -void *xlt_emergency_page;
 -static DEFINE_MUTEX(xlt_emergency_page_mutex);
 -
 -static __be64 get_umr_enable_mr_mask(void)
 -{
 -	u64 result;
 -
 -	result = MLX5_MKEY_MASK_KEY |
 -		 MLX5_MKEY_MASK_FREE;
 -
 -	return cpu_to_be64(result);
 -}
 -
 -static __be64 get_umr_disable_mr_mask(void)
 -{
 -	u64 result;
 -
 -	result = MLX5_MKEY_MASK_FREE;
 -
 -	return cpu_to_be64(result);
 -}
 -
 -static __be64 get_umr_update_translation_mask(void)
 -{
 -	u64 result;
 -
 -	result = MLX5_MKEY_MASK_LEN |
 -		 MLX5_MKEY_MASK_PAGE_SIZE |
 -		 MLX5_MKEY_MASK_START_ADDR;
 -
 -	return cpu_to_be64(result);
 -}
 -
 -static __be64 get_umr_update_access_mask(struct mlx5_ib_dev *dev)
 -{
 -	u64 result;
 -
 -	result = MLX5_MKEY_MASK_LR |
 -		 MLX5_MKEY_MASK_LW |
 -		 MLX5_MKEY_MASK_RR |
 -		 MLX5_MKEY_MASK_RW;
 -
 -	if (MLX5_CAP_GEN(dev->mdev, atomic))
 -		result |= MLX5_MKEY_MASK_A;
 -
 -	if (MLX5_CAP_GEN(dev->mdev, relaxed_ordering_write_umr))
 -		result |= MLX5_MKEY_MASK_RELAXED_ORDERING_WRITE;
 -
 -	if (MLX5_CAP_GEN(dev->mdev, relaxed_ordering_read_umr))
 -		result |= MLX5_MKEY_MASK_RELAXED_ORDERING_READ;
 -
 -	return cpu_to_be64(result);
 -}
 -
 -static __be64 get_umr_update_pd_mask(void)
 -{
 -	u64 result;
 -
 -	result = MLX5_MKEY_MASK_PD;
 -
 -	return cpu_to_be64(result);
 -}
 -
 -static int umr_check_mkey_mask(struct mlx5_ib_dev *dev, u64 mask)
 -{
 -	if (mask & MLX5_MKEY_MASK_PAGE_SIZE &&
 -	    MLX5_CAP_GEN(dev->mdev, umr_modify_entity_size_disabled))
 -		return -EPERM;
 -
 -	if (mask & MLX5_MKEY_MASK_A &&
 -	    MLX5_CAP_GEN(dev->mdev, umr_modify_atomic_disabled))
 -		return -EPERM;
 -
 -	if (mask & MLX5_MKEY_MASK_RELAXED_ORDERING_WRITE &&
 -	    !MLX5_CAP_GEN(dev->mdev, relaxed_ordering_write_umr))
 -		return -EPERM;
 -
 -	if (mask & MLX5_MKEY_MASK_RELAXED_ORDERING_READ &&
 -	    !MLX5_CAP_GEN(dev->mdev, relaxed_ordering_read_umr))
 -		return -EPERM;
 -
 -	return 0;
 -}
 -
 -int mlx5r_umr_set_umr_ctrl_seg(struct mlx5_ib_dev *dev,
 -			       struct mlx5_wqe_umr_ctrl_seg *umr,
 -			       const struct ib_send_wr *wr)
 -{
 -	const struct mlx5_umr_wr *umrwr = umr_wr(wr);
 -
 -	memset(umr, 0, sizeof(*umr));
 -
 -	if (!umrwr->ignore_free_state) {
 -		if (wr->send_flags & MLX5_IB_SEND_UMR_FAIL_IF_FREE)
 -			 /* fail if free */
 -			umr->flags = MLX5_UMR_CHECK_FREE;
 -		else
 -			/* fail if not free */
 -			umr->flags = MLX5_UMR_CHECK_NOT_FREE;
 -	}
 -
 -	umr->xlt_octowords =
 -		cpu_to_be16(mlx5r_umr_get_xlt_octo(umrwr->xlt_size));
 -	if (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_XLT) {
 -		u64 offset = mlx5r_umr_get_xlt_octo(umrwr->offset);
 -
 -		umr->xlt_offset = cpu_to_be16(offset & 0xffff);
 -		umr->xlt_offset_47_16 = cpu_to_be32(offset >> 16);
 -		umr->flags |= MLX5_UMR_TRANSLATION_OFFSET_EN;
 -	}
 -	if (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_TRANSLATION)
 -		umr->mkey_mask |= get_umr_update_translation_mask();
 -	if (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_PD_ACCESS) {
 -		umr->mkey_mask |= get_umr_update_access_mask(dev);
 -		umr->mkey_mask |= get_umr_update_pd_mask();
 -	}
 -	if (wr->send_flags & MLX5_IB_SEND_UMR_ENABLE_MR)
 -		umr->mkey_mask |= get_umr_enable_mr_mask();
 -	if (wr->send_flags & MLX5_IB_SEND_UMR_DISABLE_MR)
 -		umr->mkey_mask |= get_umr_disable_mr_mask();
 -
 -	if (!wr->num_sge)
 -		umr->flags |= MLX5_UMR_INLINE;
 -
 -	return umr_check_mkey_mask(dev, be64_to_cpu(umr->mkey_mask));
 -}
  
  enum {
  	MAX_UMR_WR = 128,
@@@ -104,3 -237,507 +105,510 @@@ void mlx5r_umr_resource_cleanup(struct 
  	ib_free_cq(dev->umrc.cq);
  	ib_dealloc_pd(dev->umrc.pd);
  }
++<<<<<<< HEAD
++=======
+ 
+ static int mlx5r_umr_post_send(struct ib_qp *ibqp, u32 mkey, struct ib_cqe *cqe,
+ 			       struct mlx5r_umr_wqe *wqe, bool with_data)
+ {
+ 	unsigned int wqe_size =
+ 		with_data ? sizeof(struct mlx5r_umr_wqe) :
+ 			    sizeof(struct mlx5r_umr_wqe) -
+ 				    sizeof(struct mlx5_wqe_data_seg);
+ 	struct mlx5_ib_dev *dev = to_mdev(ibqp->device);
+ 	struct mlx5_core_dev *mdev = dev->mdev;
+ 	struct mlx5_ib_qp *qp = to_mqp(ibqp);
+ 	struct mlx5_wqe_ctrl_seg *ctrl;
+ 	union {
+ 		struct ib_cqe *ib_cqe;
+ 		u64 wr_id;
+ 	} id;
+ 	void *cur_edge, *seg;
+ 	unsigned long flags;
+ 	unsigned int idx;
+ 	int size, err;
+ 
+ 	if (unlikely(mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR))
+ 		return -EIO;
+ 
+ 	spin_lock_irqsave(&qp->sq.lock, flags);
+ 
+ 	err = mlx5r_begin_wqe(qp, &seg, &ctrl, &idx, &size, &cur_edge, 0,
+ 			      cpu_to_be32(mkey), false, false);
+ 	if (WARN_ON(err))
+ 		goto out;
+ 
+ 	qp->sq.wr_data[idx] = MLX5_IB_WR_UMR;
+ 
+ 	mlx5r_memcpy_send_wqe(&qp->sq, &cur_edge, &seg, &size, wqe, wqe_size);
+ 
+ 	id.ib_cqe = cqe;
+ 	mlx5r_finish_wqe(qp, ctrl, seg, size, cur_edge, idx, id.wr_id, 0,
+ 			 MLX5_FENCE_MODE_NONE, MLX5_OPCODE_UMR);
+ 
+ 	mlx5r_ring_db(qp, 1, ctrl);
+ 
+ out:
+ 	spin_unlock_irqrestore(&qp->sq.lock, flags);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5r_umr_done(struct ib_cq *cq, struct ib_wc *wc)
+ {
+ 	struct mlx5_ib_umr_context *context =
+ 		container_of(wc->wr_cqe, struct mlx5_ib_umr_context, cqe);
+ 
+ 	context->status = wc->status;
+ 	complete(&context->done);
+ }
+ 
+ static inline void mlx5r_umr_init_context(struct mlx5r_umr_context *context)
+ {
+ 	context->cqe.done = mlx5r_umr_done;
+ 	init_completion(&context->done);
+ }
+ 
+ static int mlx5r_umr_post_send_wait(struct mlx5_ib_dev *dev, u32 mkey,
+ 				   struct mlx5r_umr_wqe *wqe, bool with_data)
+ {
+ 	struct umr_common *umrc = &dev->umrc;
+ 	struct mlx5r_umr_context umr_context;
+ 	int err;
+ 
+ 	err = umr_check_mkey_mask(dev, be64_to_cpu(wqe->ctrl_seg.mkey_mask));
+ 	if (WARN_ON(err))
+ 		return err;
+ 
+ 	mlx5r_umr_init_context(&umr_context);
+ 
+ 	down(&umrc->sem);
+ 	err = mlx5r_umr_post_send(umrc->qp, mkey, &umr_context.cqe, wqe,
+ 				  with_data);
+ 	if (err)
+ 		mlx5_ib_warn(dev, "UMR post send failed, err %d\n", err);
+ 	else {
+ 		wait_for_completion(&umr_context.done);
+ 		if (umr_context.status != IB_WC_SUCCESS) {
+ 			mlx5_ib_warn(dev, "reg umr failed (%u)\n",
+ 				     umr_context.status);
+ 			err = -EFAULT;
+ 		}
+ 	}
+ 	up(&umrc->sem);
+ 	return err;
+ }
+ 
+ /**
+  * mlx5r_umr_revoke_mr - Fence all DMA on the MR
+  * @mr: The MR to fence
+  *
+  * Upon return the NIC will not be doing any DMA to the pages under the MR,
+  * and any DMA in progress will be completed. Failure of this function
+  * indicates the HW has failed catastrophically.
+  */
+ int mlx5r_umr_revoke_mr(struct mlx5_ib_mr *mr)
+ {
+ 	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
+ 	struct mlx5r_umr_wqe wqe = {};
+ 
+ 	if (dev->mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)
+ 		return 0;
+ 
+ 	wqe.ctrl_seg.mkey_mask |= get_umr_update_pd_mask();
+ 	wqe.ctrl_seg.mkey_mask |= get_umr_disable_mr_mask();
+ 	wqe.ctrl_seg.flags |= MLX5_UMR_INLINE;
+ 
+ 	MLX5_SET(mkc, &wqe.mkey_seg, free, 1);
+ 	MLX5_SET(mkc, &wqe.mkey_seg, pd, to_mpd(dev->umrc.pd)->pdn);
+ 	MLX5_SET(mkc, &wqe.mkey_seg, qpn, 0xffffff);
+ 	MLX5_SET(mkc, &wqe.mkey_seg, mkey_7_0,
+ 		 mlx5_mkey_variant(mr->mmkey.key));
+ 
+ 	return mlx5r_umr_post_send_wait(dev, mr->mmkey.key, &wqe, false);
+ }
+ 
+ static void mlx5r_umr_set_access_flags(struct mlx5_ib_dev *dev,
+ 				       struct mlx5_mkey_seg *seg,
+ 				       unsigned int access_flags)
+ {
+ 	MLX5_SET(mkc, seg, a, !!(access_flags & IB_ACCESS_REMOTE_ATOMIC));
+ 	MLX5_SET(mkc, seg, rw, !!(access_flags & IB_ACCESS_REMOTE_WRITE));
+ 	MLX5_SET(mkc, seg, rr, !!(access_flags & IB_ACCESS_REMOTE_READ));
+ 	MLX5_SET(mkc, seg, lw, !!(access_flags & IB_ACCESS_LOCAL_WRITE));
+ 	MLX5_SET(mkc, seg, lr, 1);
+ 	MLX5_SET(mkc, seg, relaxed_ordering_write,
+ 		 !!(access_flags & IB_ACCESS_RELAXED_ORDERING));
+ 	MLX5_SET(mkc, seg, relaxed_ordering_read,
+ 		 !!(access_flags & IB_ACCESS_RELAXED_ORDERING));
+ }
+ 
+ int mlx5r_umr_rereg_pd_access(struct mlx5_ib_mr *mr, struct ib_pd *pd,
+ 			      int access_flags)
+ {
+ 	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
+ 	struct mlx5r_umr_wqe wqe = {};
+ 	int err;
+ 
+ 	wqe.ctrl_seg.mkey_mask = get_umr_update_access_mask(dev);
+ 	wqe.ctrl_seg.mkey_mask |= get_umr_update_pd_mask();
+ 	wqe.ctrl_seg.flags = MLX5_UMR_CHECK_FREE;
+ 	wqe.ctrl_seg.flags |= MLX5_UMR_INLINE;
+ 
+ 	mlx5r_umr_set_access_flags(dev, &wqe.mkey_seg, access_flags);
+ 	MLX5_SET(mkc, &wqe.mkey_seg, pd, to_mpd(pd)->pdn);
+ 	MLX5_SET(mkc, &wqe.mkey_seg, qpn, 0xffffff);
+ 	MLX5_SET(mkc, &wqe.mkey_seg, mkey_7_0,
+ 		 mlx5_mkey_variant(mr->mmkey.key));
+ 
+ 	err = mlx5r_umr_post_send_wait(dev, mr->mmkey.key, &wqe, false);
+ 	if (err)
+ 		return err;
+ 
+ 	mr->access_flags = access_flags;
+ 	return 0;
+ }
+ 
+ #define MLX5_MAX_UMR_CHUNK                                                     \
+ 	((1 << (MLX5_MAX_UMR_SHIFT + 4)) - MLX5_UMR_MTT_ALIGNMENT)
+ #define MLX5_SPARE_UMR_CHUNK 0x10000
+ 
+ /*
+  * Allocate a temporary buffer to hold the per-page information to transfer to
+  * HW. For efficiency this should be as large as it can be, but buffer
+  * allocation failure is not allowed, so try smaller sizes.
+  */
+ static void *mlx5r_umr_alloc_xlt(size_t *nents, size_t ent_size, gfp_t gfp_mask)
+ {
+ 	const size_t xlt_chunk_align = MLX5_UMR_MTT_ALIGNMENT / ent_size;
+ 	size_t size;
+ 	void *res = NULL;
+ 
+ 	static_assert(PAGE_SIZE % MLX5_UMR_MTT_ALIGNMENT == 0);
+ 
+ 	/*
+ 	 * MLX5_IB_UPD_XLT_ATOMIC doesn't signal an atomic context just that the
+ 	 * allocation can't trigger any kind of reclaim.
+ 	 */
+ 	might_sleep();
+ 
+ 	gfp_mask |= __GFP_ZERO | __GFP_NORETRY;
+ 
+ 	/*
+ 	 * If the system already has a suitable high order page then just use
+ 	 * that, but don't try hard to create one. This max is about 1M, so a
+ 	 * free x86 huge page will satisfy it.
+ 	 */
+ 	size = min_t(size_t, ent_size * ALIGN(*nents, xlt_chunk_align),
+ 		     MLX5_MAX_UMR_CHUNK);
+ 	*nents = size / ent_size;
+ 	res = (void *)__get_free_pages(gfp_mask | __GFP_NOWARN,
+ 				       get_order(size));
+ 	if (res)
+ 		return res;
+ 
+ 	if (size > MLX5_SPARE_UMR_CHUNK) {
+ 		size = MLX5_SPARE_UMR_CHUNK;
+ 		*nents = size / ent_size;
+ 		res = (void *)__get_free_pages(gfp_mask | __GFP_NOWARN,
+ 					       get_order(size));
+ 		if (res)
+ 			return res;
+ 	}
+ 
+ 	*nents = PAGE_SIZE / ent_size;
+ 	res = (void *)__get_free_page(gfp_mask);
+ 	if (res)
+ 		return res;
+ 
+ 	mutex_lock(&xlt_emergency_page_mutex);
+ 	memset(xlt_emergency_page, 0, PAGE_SIZE);
+ 	return xlt_emergency_page;
+ }
+ 
+ static void mlx5r_umr_free_xlt(void *xlt, size_t length)
+ {
+ 	if (xlt == xlt_emergency_page) {
+ 		mutex_unlock(&xlt_emergency_page_mutex);
+ 		return;
+ 	}
+ 
+ 	free_pages((unsigned long)xlt, get_order(length));
+ }
+ 
+ static void mlx5r_umr_unmap_free_xlt(struct mlx5_ib_dev *dev, void *xlt,
+ 				     struct ib_sge *sg)
+ {
+ 	struct device *ddev = &dev->mdev->pdev->dev;
+ 
+ 	dma_unmap_single(ddev, sg->addr, sg->length, DMA_TO_DEVICE);
+ 	mlx5r_umr_free_xlt(xlt, sg->length);
+ }
+ 
+ /*
+  * Create an XLT buffer ready for submission.
+  */
+ static void *mlx5r_umr_create_xlt(struct mlx5_ib_dev *dev, struct ib_sge *sg,
+ 				  size_t nents, size_t ent_size,
+ 				  unsigned int flags)
+ {
+ 	struct device *ddev = &dev->mdev->pdev->dev;
+ 	dma_addr_t dma;
+ 	void *xlt;
+ 
+ 	xlt = mlx5r_umr_alloc_xlt(&nents, ent_size,
+ 				 flags & MLX5_IB_UPD_XLT_ATOMIC ? GFP_ATOMIC :
+ 								  GFP_KERNEL);
+ 	sg->length = nents * ent_size;
+ 	dma = dma_map_single(ddev, xlt, sg->length, DMA_TO_DEVICE);
+ 	if (dma_mapping_error(ddev, dma)) {
+ 		mlx5_ib_err(dev, "unable to map DMA during XLT update.\n");
+ 		mlx5r_umr_free_xlt(xlt, sg->length);
+ 		return NULL;
+ 	}
+ 	sg->addr = dma;
+ 	sg->lkey = dev->umrc.pd->local_dma_lkey;
+ 
+ 	return xlt;
+ }
+ 
+ static void
+ mlx5r_umr_set_update_xlt_ctrl_seg(struct mlx5_wqe_umr_ctrl_seg *ctrl_seg,
+ 				  unsigned int flags, struct ib_sge *sg)
+ {
+ 	if (!(flags & MLX5_IB_UPD_XLT_ENABLE))
+ 		/* fail if free */
+ 		ctrl_seg->flags = MLX5_UMR_CHECK_FREE;
+ 	else
+ 		/* fail if not free */
+ 		ctrl_seg->flags = MLX5_UMR_CHECK_NOT_FREE;
+ 	ctrl_seg->xlt_octowords =
+ 		cpu_to_be16(mlx5r_umr_get_xlt_octo(sg->length));
+ }
+ 
+ static void mlx5r_umr_set_update_xlt_mkey_seg(struct mlx5_ib_dev *dev,
+ 					      struct mlx5_mkey_seg *mkey_seg,
+ 					      struct mlx5_ib_mr *mr,
+ 					      unsigned int page_shift)
+ {
+ 	mlx5r_umr_set_access_flags(dev, mkey_seg, mr->access_flags);
+ 	MLX5_SET(mkc, mkey_seg, pd, to_mpd(mr->ibmr.pd)->pdn);
+ 	MLX5_SET64(mkc, mkey_seg, start_addr, mr->ibmr.iova);
+ 	MLX5_SET64(mkc, mkey_seg, len, mr->ibmr.length);
+ 	MLX5_SET(mkc, mkey_seg, log_page_size, page_shift);
+ 	MLX5_SET(mkc, mkey_seg, qpn, 0xffffff);
+ 	MLX5_SET(mkc, mkey_seg, mkey_7_0, mlx5_mkey_variant(mr->mmkey.key));
+ }
+ 
+ static void
+ mlx5r_umr_set_update_xlt_data_seg(struct mlx5_wqe_data_seg *data_seg,
+ 				  struct ib_sge *sg)
+ {
+ 	data_seg->byte_count = cpu_to_be32(sg->length);
+ 	data_seg->lkey = cpu_to_be32(sg->lkey);
+ 	data_seg->addr = cpu_to_be64(sg->addr);
+ }
+ 
+ static void mlx5r_umr_update_offset(struct mlx5_wqe_umr_ctrl_seg *ctrl_seg,
+ 				    u64 offset)
+ {
+ 	u64 octo_offset = mlx5r_umr_get_xlt_octo(offset);
+ 
+ 	ctrl_seg->xlt_offset = cpu_to_be16(octo_offset & 0xffff);
+ 	ctrl_seg->xlt_offset_47_16 = cpu_to_be32(octo_offset >> 16);
+ 	ctrl_seg->flags |= MLX5_UMR_TRANSLATION_OFFSET_EN;
+ }
+ 
+ static void mlx5r_umr_final_update_xlt(struct mlx5_ib_dev *dev,
+ 				       struct mlx5r_umr_wqe *wqe,
+ 				       struct mlx5_ib_mr *mr, struct ib_sge *sg,
+ 				       unsigned int flags)
+ {
+ 	bool update_pd_access, update_translation;
+ 
+ 	if (flags & MLX5_IB_UPD_XLT_ENABLE)
+ 		wqe->ctrl_seg.mkey_mask |= get_umr_enable_mr_mask();
+ 
+ 	update_pd_access = flags & MLX5_IB_UPD_XLT_ENABLE ||
+ 			   flags & MLX5_IB_UPD_XLT_PD ||
+ 			   flags & MLX5_IB_UPD_XLT_ACCESS;
+ 
+ 	if (update_pd_access) {
+ 		wqe->ctrl_seg.mkey_mask |= get_umr_update_access_mask(dev);
+ 		wqe->ctrl_seg.mkey_mask |= get_umr_update_pd_mask();
+ 	}
+ 
+ 	update_translation =
+ 		flags & MLX5_IB_UPD_XLT_ENABLE || flags & MLX5_IB_UPD_XLT_ADDR;
+ 
+ 	if (update_translation) {
+ 		wqe->ctrl_seg.mkey_mask |= get_umr_update_translation_mask();
+ 		if (!mr->ibmr.length)
+ 			MLX5_SET(mkc, &wqe->mkey_seg, length64, 1);
+ 	}
+ 
+ 	wqe->ctrl_seg.xlt_octowords =
+ 		cpu_to_be16(mlx5r_umr_get_xlt_octo(sg->length));
+ 	wqe->data_seg.byte_count = cpu_to_be32(sg->length);
+ }
+ 
+ /*
+  * Send the DMA list to the HW for a normal MR using UMR.
+  * Dmabuf MR is handled in a similar way, except that the MLX5_IB_UPD_XLT_ZAP
+  * flag may be used.
+  */
+ int mlx5r_umr_update_mr_pas(struct mlx5_ib_mr *mr, unsigned int flags)
+ {
+ 	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
+ 	struct device *ddev = &dev->mdev->pdev->dev;
+ 	struct mlx5r_umr_wqe wqe = {};
+ 	struct ib_block_iter biter;
+ 	struct mlx5_mtt *cur_mtt;
+ 	size_t orig_sg_length;
+ 	struct mlx5_mtt *mtt;
+ 	size_t final_size;
+ 	struct ib_sge sg;
+ 	u64 offset = 0;
+ 	int err = 0;
+ 
+ 	if (WARN_ON(mr->umem->is_odp))
+ 		return -EINVAL;
+ 
+ 	mtt = mlx5r_umr_create_xlt(
+ 		dev, &sg, ib_umem_num_dma_blocks(mr->umem, 1 << mr->page_shift),
+ 		sizeof(*mtt), flags);
+ 	if (!mtt)
+ 		return -ENOMEM;
+ 
+ 	orig_sg_length = sg.length;
+ 
+ 	mlx5r_umr_set_update_xlt_ctrl_seg(&wqe.ctrl_seg, flags, &sg);
+ 	mlx5r_umr_set_update_xlt_mkey_seg(dev, &wqe.mkey_seg, mr,
+ 					  mr->page_shift);
+ 	mlx5r_umr_set_update_xlt_data_seg(&wqe.data_seg, &sg);
+ 
+ 	cur_mtt = mtt;
+ 	rdma_for_each_block(mr->umem->sgt_append.sgt.sgl, &biter,
+ 			    mr->umem->sgt_append.sgt.nents,
+ 			    BIT(mr->page_shift)) {
+ 		if (cur_mtt == (void *)mtt + sg.length) {
+ 			dma_sync_single_for_device(ddev, sg.addr, sg.length,
+ 						   DMA_TO_DEVICE);
+ 
+ 			err = mlx5r_umr_post_send_wait(dev, mr->mmkey.key, &wqe,
+ 						       true);
+ 			if (err)
+ 				goto err;
+ 			dma_sync_single_for_cpu(ddev, sg.addr, sg.length,
+ 						DMA_TO_DEVICE);
+ 			offset += sg.length;
+ 			mlx5r_umr_update_offset(&wqe.ctrl_seg, offset);
+ 
+ 			cur_mtt = mtt;
+ 		}
+ 
+ 		cur_mtt->ptag =
+ 			cpu_to_be64(rdma_block_iter_dma_address(&biter) |
+ 				    MLX5_IB_MTT_PRESENT);
+ 
+ 		if (mr->umem->is_dmabuf && (flags & MLX5_IB_UPD_XLT_ZAP))
+ 			cur_mtt->ptag = 0;
+ 
+ 		cur_mtt++;
+ 	}
+ 
+ 	final_size = (void *)cur_mtt - (void *)mtt;
+ 	sg.length = ALIGN(final_size, MLX5_UMR_MTT_ALIGNMENT);
+ 	memset(cur_mtt, 0, sg.length - final_size);
+ 	mlx5r_umr_final_update_xlt(dev, &wqe, mr, &sg, flags);
+ 
+ 	dma_sync_single_for_device(ddev, sg.addr, sg.length, DMA_TO_DEVICE);
+ 	err = mlx5r_umr_post_send_wait(dev, mr->mmkey.key, &wqe, true);
+ 
+ err:
+ 	sg.length = orig_sg_length;
+ 	mlx5r_umr_unmap_free_xlt(dev, mtt, &sg);
+ 	return err;
+ }
+ 
+ static bool umr_can_use_indirect_mkey(struct mlx5_ib_dev *dev)
+ {
+ 	return !MLX5_CAP_GEN(dev->mdev, umr_indirect_mkey_disabled);
+ }
+ 
+ int mlx5r_umr_update_xlt(struct mlx5_ib_mr *mr, u64 idx, int npages,
+ 			 int page_shift, int flags)
+ {
+ 	int desc_size = (flags & MLX5_IB_UPD_XLT_INDIRECT)
+ 			       ? sizeof(struct mlx5_klm)
+ 			       : sizeof(struct mlx5_mtt);
+ 	const int page_align = MLX5_UMR_MTT_ALIGNMENT / desc_size;
+ 	struct mlx5_ib_dev *dev = mr_to_mdev(mr);
+ 	struct device *ddev = &dev->mdev->pdev->dev;
+ 	const int page_mask = page_align - 1;
+ 	struct mlx5r_umr_wqe wqe = {};
+ 	size_t pages_mapped = 0;
+ 	size_t pages_to_map = 0;
+ 	size_t size_to_map = 0;
+ 	size_t orig_sg_length;
+ 	size_t pages_iter;
+ 	struct ib_sge sg;
+ 	int err = 0;
+ 	void *xlt;
+ 
+ 	if ((flags & MLX5_IB_UPD_XLT_INDIRECT) &&
+ 	    !umr_can_use_indirect_mkey(dev))
+ 		return -EPERM;
+ 
+ 	if (WARN_ON(!mr->umem->is_odp))
+ 		return -EINVAL;
+ 
+ 	/* UMR copies MTTs in units of MLX5_UMR_MTT_ALIGNMENT bytes,
+ 	 * so we need to align the offset and length accordingly
+ 	 */
+ 	if (idx & page_mask) {
+ 		npages += idx & page_mask;
+ 		idx &= ~page_mask;
+ 	}
+ 	pages_to_map = ALIGN(npages, page_align);
+ 
+ 	xlt = mlx5r_umr_create_xlt(dev, &sg, npages, desc_size, flags);
+ 	if (!xlt)
+ 		return -ENOMEM;
+ 
+ 	pages_iter = sg.length / desc_size;
+ 	orig_sg_length = sg.length;
+ 
+ 	if (!(flags & MLX5_IB_UPD_XLT_INDIRECT)) {
+ 		struct ib_umem_odp *odp = to_ib_umem_odp(mr->umem);
+ 		size_t max_pages = ib_umem_odp_num_pages(odp) - idx;
+ 
+ 		pages_to_map = min_t(size_t, pages_to_map, max_pages);
+ 	}
+ 
+ 	mlx5r_umr_set_update_xlt_ctrl_seg(&wqe.ctrl_seg, flags, &sg);
+ 	mlx5r_umr_set_update_xlt_mkey_seg(dev, &wqe.mkey_seg, mr, page_shift);
+ 	mlx5r_umr_set_update_xlt_data_seg(&wqe.data_seg, &sg);
+ 
+ 	for (pages_mapped = 0;
+ 	     pages_mapped < pages_to_map && !err;
+ 	     pages_mapped += pages_iter, idx += pages_iter) {
+ 		npages = min_t(int, pages_iter, pages_to_map - pages_mapped);
+ 		size_to_map = npages * desc_size;
+ 		dma_sync_single_for_cpu(ddev, sg.addr, sg.length,
+ 					DMA_TO_DEVICE);
+ 		mlx5_odp_populate_xlt(xlt, idx, npages, mr, flags);
+ 		dma_sync_single_for_device(ddev, sg.addr, sg.length,
+ 					   DMA_TO_DEVICE);
+ 		sg.length = ALIGN(size_to_map, MLX5_UMR_MTT_ALIGNMENT);
+ 
+ 		if (pages_mapped + pages_iter >= pages_to_map)
+ 			mlx5r_umr_final_update_xlt(dev, &wqe, mr, &sg, flags);
+ 		mlx5r_umr_update_offset(&wqe.ctrl_seg, idx * desc_size);
+ 		err = mlx5r_umr_post_send_wait(dev, mr->mmkey.key, &wqe, true);
+ 	}
+ 	sg.length = orig_sg_length;
+ 	mlx5r_umr_unmap_free_xlt(dev, xlt, &sg);
+ 	return err;
+ }
++>>>>>>> 636bdbfc9996 (RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt)
diff --cc drivers/infiniband/hw/mlx5/umr.h
index cb1a2c95aac2,b42e8c93b385..000000000000
--- a/drivers/infiniband/hw/mlx5/umr.h
+++ b/drivers/infiniband/hw/mlx5/umr.h
@@@ -9,4 -9,93 +9,89 @@@
  int mlx5r_umr_resource_init(struct mlx5_ib_dev *dev);
  void mlx5r_umr_resource_cleanup(struct mlx5_ib_dev *dev);
  
++<<<<<<< HEAD
++=======
+ static inline bool mlx5r_umr_can_load_pas(struct mlx5_ib_dev *dev,
+ 					  size_t length)
+ {
+ 	/*
+ 	 * umr_check_mkey_mask() rejects MLX5_MKEY_MASK_PAGE_SIZE which is
+ 	 * always set if MLX5_IB_SEND_UMR_UPDATE_TRANSLATION (aka
+ 	 * MLX5_IB_UPD_XLT_ADDR and MLX5_IB_UPD_XLT_ENABLE) is set. Thus, a mkey
+ 	 * can never be enabled without this capability. Simplify this weird
+ 	 * quirky hardware by just saying it can't use PAS lists with UMR at
+ 	 * all.
+ 	 */
+ 	if (MLX5_CAP_GEN(dev->mdev, umr_modify_entity_size_disabled))
+ 		return false;
+ 
+ 	/*
+ 	 * length is the size of the MR in bytes when mlx5_ib_update_xlt() is
+ 	 * used.
+ 	 */
+ 	if (!MLX5_CAP_GEN(dev->mdev, umr_extended_translation_offset) &&
+ 	    length >= MLX5_MAX_UMR_PAGES * PAGE_SIZE)
+ 		return false;
+ 	return true;
+ }
+ 
+ /*
+  * true if an existing MR can be reconfigured to new access_flags using UMR.
+  * Older HW cannot use UMR to update certain elements of the MKC. See
+  * get_umr_update_access_mask() and umr_check_mkey_mask()
+  */
+ static inline bool mlx5r_umr_can_reconfig(struct mlx5_ib_dev *dev,
+ 					  unsigned int current_access_flags,
+ 					  unsigned int target_access_flags)
+ {
+ 	unsigned int diffs = current_access_flags ^ target_access_flags;
+ 
+ 	if ((diffs & IB_ACCESS_REMOTE_ATOMIC) &&
+ 	    MLX5_CAP_GEN(dev->mdev, atomic) &&
+ 	    MLX5_CAP_GEN(dev->mdev, umr_modify_atomic_disabled))
+ 		return false;
+ 
+ 	if ((diffs & IB_ACCESS_RELAXED_ORDERING) &&
+ 	    MLX5_CAP_GEN(dev->mdev, relaxed_ordering_write) &&
+ 	    !MLX5_CAP_GEN(dev->mdev, relaxed_ordering_write_umr))
+ 		return false;
+ 
+ 	if ((diffs & IB_ACCESS_RELAXED_ORDERING) &&
+ 	    MLX5_CAP_GEN(dev->mdev, relaxed_ordering_read) &&
+ 	    !MLX5_CAP_GEN(dev->mdev, relaxed_ordering_read_umr))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static inline u64 mlx5r_umr_get_xlt_octo(u64 bytes)
+ {
+ 	return ALIGN(bytes, MLX5_IB_UMR_XLT_ALIGNMENT) /
+ 	       MLX5_IB_UMR_OCTOWORD;
+ }
+ 
+ int mlx5r_umr_set_umr_ctrl_seg(struct mlx5_ib_dev *dev,
+ 			       struct mlx5_wqe_umr_ctrl_seg *umr,
+ 			       const struct ib_send_wr *wr);
+ 
+ struct mlx5r_umr_context {
+ 	struct ib_cqe cqe;
+ 	enum ib_wc_status status;
+ 	struct completion done;
+ };
+ 
+ struct mlx5r_umr_wqe {
+ 	struct mlx5_wqe_umr_ctrl_seg ctrl_seg;
+ 	struct mlx5_mkey_seg mkey_seg;
+ 	struct mlx5_wqe_data_seg data_seg;
+ };
+ 
+ int mlx5r_umr_revoke_mr(struct mlx5_ib_mr *mr);
+ int mlx5r_umr_rereg_pd_access(struct mlx5_ib_mr *mr, struct ib_pd *pd,
+ 			      int access_flags);
+ int mlx5r_umr_update_mr_pas(struct mlx5_ib_mr *mr, unsigned int flags);
+ int mlx5r_umr_update_xlt(struct mlx5_ib_mr *mr, u64 idx, int npages,
+ 			 int page_shift, int flags);
+ 
++>>>>>>> 636bdbfc9996 (RDMA/mlx5: Use mlx5_umr_post_send_wait() to update xlt)
  #endif /* _MLX5_IB_UMR_H */
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 568671fe4f18..cf7b4c2ce552 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -1280,8 +1280,6 @@ int mlx5_ib_advise_mr(struct ib_pd *pd,
 		      struct uverbs_attr_bundle *attrs);
 int mlx5_ib_alloc_mw(struct ib_mw *mw, struct ib_udata *udata);
 int mlx5_ib_dealloc_mw(struct ib_mw *mw);
-int mlx5_ib_update_xlt(struct mlx5_ib_mr *mr, u64 idx, int npages,
-		       int page_shift, int flags);
 struct mlx5_ib_mr *mlx5_ib_alloc_implicit_mr(struct mlx5_ib_pd *pd,
 					     struct ib_udata *udata,
 					     int access_flags);
* Unmerged path drivers/infiniband/hw/mlx5/mr.c
* Unmerged path drivers/infiniband/hw/mlx5/odp.c
* Unmerged path drivers/infiniband/hw/mlx5/umr.c
* Unmerged path drivers/infiniband/hw/mlx5/umr.h
