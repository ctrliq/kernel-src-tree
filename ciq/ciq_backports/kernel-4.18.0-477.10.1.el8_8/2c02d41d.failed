net/ulp: prevent ULP without clone op from entering the LISTEN status

jira LE-1907
cve CVE-2023-0461
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 2c02d41d71f90a5168391b6a5f2954112ba2307c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/2c02d41d.failed

When an ULP-enabled socket enters the LISTEN status, the listener ULP data
pointer is copied inside the child/accepted sockets by sk_clone_lock().

The relevant ULP can take care of de-duplicating the context pointer via
the clone() operation, but only MPTCP and SMC implement such op.

Other ULPs may end-up with a double-free at socket disposal time.

We can't simply clear the ULP data at clone time, as TLS replaces the
socket ops with custom ones assuming a valid TLS ULP context is
available.

Instead completely prevent clone-less ULP sockets from entering the
LISTEN status.

Fixes: 734942cc4ea6 ("tcp: ULP infrastructure")
	Reported-by: slipper <slipper.alive@gmail.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Link: https://lore.kernel.org/r/4b80c3d1dbe3d0ab072f80450c202d9bc88b4b03.1672740602.git.pabeni@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2c02d41d71f90a5168391b6a5f2954112ba2307c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/inet_connection_sock.c
#	net/ipv4/tcp_ulp.c
diff --cc net/ipv4/inet_connection_sock.c
index 6baebe861f9c,d1f837579398..000000000000
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@@ -920,12 -1200,26 +920,30 @@@ void inet_csk_prepare_forced_close(stru
  }
  EXPORT_SYMBOL(inet_csk_prepare_forced_close);
  
++<<<<<<< HEAD
 +int inet_csk_listen_start(struct sock *sk, int backlog)
++=======
+ static int inet_ulp_can_listen(const struct sock *sk)
+ {
+ 	const struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 	if (icsk->icsk_ulp_ops && !icsk->icsk_ulp_ops->clone)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ int inet_csk_listen_start(struct sock *sk)
++>>>>>>> 2c02d41d71f9 (net/ulp: prevent ULP without clone op from entering the LISTEN status)
  {
  	struct inet_connection_sock *icsk = inet_csk(sk);
  	struct inet_sock *inet = inet_sk(sk);
 -	int err;
 +	int err = -EADDRINUSE;
  
+ 	err = inet_ulp_can_listen(sk);
+ 	if (unlikely(err))
+ 		return err;
+ 
  	reqsk_queue_alloc(&icsk->icsk_accept_queue);
  
  	sk->sk_ack_backlog = 0;
diff --cc net/ipv4/tcp_ulp.c
index 6cae9e21420b,05b6077b9f2c..000000000000
--- a/net/ipv4/tcp_ulp.c
+++ b/net/ipv4/tcp_ulp.c
@@@ -131,6 -136,13 +131,16 @@@ static int __tcp_set_ulp(struct sock *s
  	if (icsk->icsk_ulp_ops)
  		goto out_err;
  
++<<<<<<< HEAD
++=======
+ 	if (sk->sk_socket)
+ 		clear_bit(SOCK_SUPPORT_ZC, &sk->sk_socket->flags);
+ 
+ 	err = -EINVAL;
+ 	if (!ulp_ops->clone && sk->sk_state == TCP_LISTEN)
+ 		goto out_err;
+ 
++>>>>>>> 2c02d41d71f9 (net/ulp: prevent ULP without clone op from entering the LISTEN status)
  	err = ulp_ops->init(sk);
  	if (err)
  		goto out_err;
* Unmerged path net/ipv4/inet_connection_sock.c
* Unmerged path net/ipv4/tcp_ulp.c
