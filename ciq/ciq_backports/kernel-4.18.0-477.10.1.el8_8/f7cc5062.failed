regmap-irq: Refactor checks for status bulk read support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Aidan MacDonald <aidanmacdonald.0x0@gmail.com>
commit f7cc5062d6e5ca439708e8403b1a622cca75adf7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/f7cc5062.failed

There are several conditions that must be satisfied to support
bulk read of status registers. Move the check into a function
to avoid duplicating it in two places.

	Signed-off-by: Aidan MacDonald <aidanmacdonald.0x0@gmail.com>
Link: https://lore.kernel.org/r/20220623211420.918875-8-aidanmacdonald.0x0@gmail.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit f7cc5062d6e5ca439708e8403b1a622cca75adf7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regmap-irq.c
diff --cc drivers/base/regmap/regmap-irq.c
index edf2854ce062,5f9a5856c45e..000000000000
--- a/drivers/base/regmap/regmap-irq.c
+++ b/drivers/base/regmap/regmap-irq.c
@@@ -298,11 -421,62 +306,66 @@@ static irqreturn_t regmap_irq_thread(in
  	}
  
  	/*
 -	 * Read only registers with active IRQs if the chip has 'main status
 -	 * register'. Else read in the statuses, using a single bulk read if
 -	 * possible in order to reduce the I/O overheads.
 +	 * Read in the statuses, using a single bulk read if possible
 +	 * in order to reduce the I/O overheads.
  	 */
++<<<<<<< HEAD
 +	if (!map->use_single_read && map->reg_stride == 1 &&
 +	    data->irq_reg_stride == 1) {
++=======
+ 
+ 	if (chip->num_main_regs) {
+ 		unsigned int max_main_bits;
+ 		unsigned long size;
+ 
+ 		size = chip->num_regs * sizeof(unsigned int);
+ 
+ 		max_main_bits = (chip->num_main_status_bits) ?
+ 				 chip->num_main_status_bits : chip->num_regs;
+ 		/* Clear the status buf as we don't read all status regs */
+ 		memset(data->status_buf, 0, size);
+ 
+ 		/* We could support bulk read for main status registers
+ 		 * but I don't expect to see devices with really many main
+ 		 * status registers so let's only support single reads for the
+ 		 * sake of simplicity. and add bulk reads only if needed
+ 		 */
+ 		for (i = 0; i < chip->num_main_regs; i++) {
+ 			ret = regmap_read(map, chip->main_status +
+ 				  (i * map->reg_stride
+ 				   * data->irq_reg_stride),
+ 				  &data->main_status_buf[i]);
+ 			if (ret) {
+ 				dev_err(map->dev,
+ 					"Failed to read IRQ status %d\n",
+ 					ret);
+ 				goto exit;
+ 			}
+ 		}
+ 
+ 		/* Read sub registers with active IRQs */
+ 		for (i = 0; i < chip->num_main_regs; i++) {
+ 			unsigned int b;
+ 			const unsigned long mreg = data->main_status_buf[i];
+ 
+ 			for_each_set_bit(b, &mreg, map->format.val_bytes * 8) {
+ 				if (i * map->format.val_bytes * 8 + b >
+ 				    max_main_bits)
+ 					break;
+ 				ret = read_sub_irq_data(data, b);
+ 
+ 				if (ret != 0) {
+ 					dev_err(map->dev,
+ 						"Failed to read IRQ status %d\n",
+ 						ret);
+ 					goto exit;
+ 				}
+ 			}
+ 
+ 		}
+ 	} else if (regmap_irq_can_bulk_read_status(data)) {
+ 
++>>>>>>> f7cc5062d6e5 (regmap-irq: Refactor checks for status bulk read support)
  		u8 *buf8 = data->status_reg_buf;
  		u16 *buf16 = data->status_reg_buf;
  		u32 *buf32 = data->status_reg_buf;
@@@ -528,13 -736,7 +591,17 @@@ int regmap_add_irq_chip_fwnode(struct f
  	else
  		d->irq_reg_stride = 1;
  
++<<<<<<< HEAD
 +	if (chip->type_reg_stride)
 +		d->type_reg_stride = chip->type_reg_stride;
 +	else
 +		d->type_reg_stride = 1;
 +
 +	if (!map->use_single_read && map->reg_stride == 1 &&
 +	    d->irq_reg_stride == 1) {
++=======
+ 	if (regmap_irq_can_bulk_read_status(d)) {
++>>>>>>> f7cc5062d6e5 (regmap-irq: Refactor checks for status bulk read support)
  		d->status_reg_buf = kmalloc_array(chip->num_regs,
  						  map->format.val_bytes,
  						  GFP_KERNEL);
* Unmerged path drivers/base/regmap/regmap-irq.c
