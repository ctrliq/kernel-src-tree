x86/fpu: Add a helper to prepare AMX state for low-power CPU idle

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Chang S. Bae <chang.seok.bae@intel.com>
commit f17b168734c0fe47343a7502d012266a051f9942
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/f17b1687.failed

When a CPU enters an idle state, a non-initialized AMX register state may
be the cause of preventing a deeper low-power state. Other extended
register states whether initialized or not do not impact the CPU idle
state.

The new helper can ensure the AMX state is initialized before the CPU is
idle, and it will be used by the intel idle driver.

Check the AMX_TILE feature bit before using XGETBV1 as a chain of
dependencies was established via cpuid_deps[]: AMX->XFD->XGETBV1.

	Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20220608164748.11864-2-chang.seok.bae@intel.com
(cherry picked from commit f17b168734c0fe47343a7502d012266a051f9942)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/special_insns.h
diff --cc arch/x86/include/asm/special_insns.h
index 645b9d8cf19d,35f709f619fb..000000000000
--- a/arch/x86/include/asm/special_insns.h
+++ b/arch/x86/include/asm/special_insns.h
@@@ -284,26 -295,13 +284,36 @@@ static inline int enqcmds(void __iomem 
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* The dst parameter must be 64-bytes aligned */
 +static inline void movdir64b(void __iomem *dst, const void *src)
 +{
 +	const struct { char _[64]; } *__src = src;
 +	struct { char _[64]; } __iomem *__dst = dst;
 +
 +	/*
 +	 * MOVDIR64B %(rdx), rax.
 +	 *
 +	 * Both __src and __dst must be memory constraints in order to tell the
 +	 * compiler that no other memory accesses should be reordered around
 +	 * this one.
 +	 *
 +	 * Also, both must be supplied as lvalues because this tells
 +	 * the compiler what the object is (its size) the instruction accesses.
 +	 * I.e., not the pointers but what they point to, thus the deref'ing '*'.
 +	 */
 +	asm volatile(".byte 0x66, 0x0f, 0x38, 0xf8, 0x02"
 +		     : "+m" (*__dst)
 +		     :  "m" (*__src), "a" (__dst), "d" (__src));
++=======
+ static inline void tile_release(void)
+ {
+ 	/*
+ 	 * Instruction opcode for TILERELEASE; supported in binutils
+ 	 * version >= 2.36.
+ 	 */
+ 	asm volatile(".byte 0xc4, 0xe2, 0x78, 0x49, 0xc0");
++>>>>>>> f17b168734c0 (x86/fpu: Add a helper to prepare AMX state for low-power CPU idle)
  }
  
  #endif /* __KERNEL__ */
diff --git a/arch/x86/include/asm/fpu/api.h b/arch/x86/include/asm/fpu/api.h
index 8ead69ebad71..49bb99ea5e6f 100644
--- a/arch/x86/include/asm/fpu/api.h
+++ b/arch/x86/include/asm/fpu/api.h
@@ -158,4 +158,6 @@ static inline bool fpstate_is_confidential(struct fpu_guest *gfpu)
 struct task_struct;
 extern long fpu_xstate_prctl(struct task_struct *tsk, int option, unsigned long arg2);
 
+extern void fpu_idle_fpregs(void);
+
 #endif /* _ASM_X86_FPU_API_H */
* Unmerged path arch/x86/include/asm/special_insns.h
diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 7a4d7ad49db7..81062c0880f9 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -840,3 +840,17 @@ int fpu__exception_code(struct fpu *fpu, int trap_nr)
 	 */
 	return 0;
 }
+
+/*
+ * Initialize register state that may prevent from entering low-power idle.
+ * This function will be invoked from the cpuidle driver only when needed.
+ */
+void fpu_idle_fpregs(void)
+{
+	/* Note: AMX_TILE being enabled implies XGETBV1 support */
+	if (cpu_feature_enabled(X86_FEATURE_AMX_TILE) &&
+	    (xfeatures_in_use() & XFEATURE_MASK_XTILE)) {
+		tile_release();
+		fpregs_deactivate(&current->thread.fpu);
+	}
+}
