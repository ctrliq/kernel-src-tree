fs: add mode_strip_sgid() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Yang Xu <xuyang2018.jy@fujitsu.com>
commit 2b3416ceff5e6bd4922f6d1c61fb68113dd82302
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/2b3416ce.failed

Add a dedicated helper to handle the setgid bit when creating a new file
in a setgid directory. This is a preparatory patch for moving setgid
stripping into the vfs. The patch contains no functional changes.

Currently the setgid stripping logic is open-coded directly in
inode_init_owner() and the individual filesystems are responsible for
handling setgid inheritance. Since this has proven to be brittle as
evidenced by old issues we uncovered over the last months (see [1] to
[3] below) we will try to move this logic into the vfs.

Link: e014f37db1a2 ("xfs: use setattr_copy to set vfs inode attributes") [1]
Link: 01ea173e103e ("xfs: fix up non-directory creation in SGID directories") [2]
Link: fd84bfdddd16 ("ceph: fix up non-directory creation in SGID directories") [3]
Link: https://lore.kernel.org/r/1657779088-2242-1-git-send-email-xuyang2018.jy@fujitsu.com
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Christian Brauner (Microsoft) <brauner@kernel.org>
Reviewed-and-Tested-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Yang Xu <xuyang2018.jy@fujitsu.com>
	Signed-off-by: Christian Brauner (Microsoft) <brauner@kernel.org>
(cherry picked from commit 2b3416ceff5e6bd4922f6d1c61fb68113dd82302)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/inode.c
#	include/linux/fs.h
diff --cc fs/inode.c
index 6cd6e8e5f6af,71b36afc3893..000000000000
--- a/fs/inode.c
+++ b/fs/inode.c
@@@ -2045,12 -2246,10 +2045,17 @@@ void inode_init_owner(struct inode *ino
  		/* Directories are special, and always inherit S_ISGID */
  		if (S_ISDIR(mode))
  			mode |= S_ISGID;
++<<<<<<< HEAD
 +		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
 +			 !in_group_p(inode->i_gid) &&
 +			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
 +			mode &= ~S_ISGID;
++=======
+ 		else
+ 			mode = mode_strip_sgid(mnt_userns, dir, mode);
++>>>>>>> 2b3416ceff5e (fs: add mode_strip_sgid() helper)
  	} else
 -		inode_fsgid_set(inode, mnt_userns);
 +		inode->i_gid = current_fsgid();
  	inode->i_mode = mode;
  }
  EXPORT_SYMBOL(inode_init_owner);
@@@ -2223,88 -2404,32 +2228,120 @@@ struct timespec64 current_time(struct i
  }
  EXPORT_SYMBOL(current_time);
  
++<<<<<<< HEAD
 +/*
 + * Generic function to check FS_IOC_SETFLAGS values and reject any invalid
 + * configurations.
 + *
 + * Note: the caller should be holding i_mutex, or else be sure that they have
 + * exclusive access to the inode structure.
 + */
 +int vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,
 +			     unsigned int flags)
 +{
 +	/*
 +	 * The IMMUTABLE and APPEND_ONLY flags can only be changed by
 +	 * the relevant capability.
 +	 *
 +	 * This test looks nicer. Thanks to Pauline Middelink
 +	 */
 +	if ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL) &&
 +	    !capable(CAP_LINUX_IMMUTABLE))
 +		return -EPERM;
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL(vfs_ioc_setflags_prepare);
 +
 +/*
 + * Generic function to check FS_IOC_FSSETXATTR values and reject any invalid
 + * configurations.
 + *
 + * Note: the caller should be holding i_mutex, or else be sure that they have
 + * exclusive access to the inode structure.
 + */
 +int vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,
 +			     struct fsxattr *fa)
 +{
 +	/*
 +	 * Can't modify an immutable/append-only file unless we have
 +	 * appropriate permission.
 +	 */
 +	if ((old_fa->fsx_xflags ^ fa->fsx_xflags) &
 +			(FS_XFLAG_IMMUTABLE | FS_XFLAG_APPEND) &&
 +	    !capable(CAP_LINUX_IMMUTABLE))
 +		return -EPERM;
 +
 +	/*
 +	 * Project Quota ID state is only allowed to change from within the init
 +	 * namespace. Enforce that restriction only if we are trying to change
 +	 * the quota ID state. Everything else is allowed in user namespaces.
 +	 */
 +	if (current_user_ns() != &init_user_ns) {
 +		if (old_fa->fsx_projid != fa->fsx_projid)
 +			return -EINVAL;
 +		if ((old_fa->fsx_xflags ^ fa->fsx_xflags) &
 +				FS_XFLAG_PROJINHERIT)
 +			return -EINVAL;
 +	}
 +
 +	/* Check extent size hints. */
 +	if ((fa->fsx_xflags & FS_XFLAG_EXTSIZE) && !S_ISREG(inode->i_mode))
 +		return -EINVAL;
 +
 +	if ((fa->fsx_xflags & FS_XFLAG_EXTSZINHERIT) &&
 +			!S_ISDIR(inode->i_mode))
 +		return -EINVAL;
 +
 +	if ((fa->fsx_xflags & FS_XFLAG_COWEXTSIZE) &&
 +	    !S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))
 +		return -EINVAL;
 +
 +	/*
 +	 * It is only valid to set the DAX flag on regular files and
 +	 * directories on filesystems.
 +	 */
 +	if ((fa->fsx_xflags & FS_XFLAG_DAX) &&
 +	    !(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
 +		return -EINVAL;
 +
 +	/* Extent size hints of zero turn off the flags. */
 +	if (fa->fsx_extsize == 0)
 +		fa->fsx_xflags &= ~(FS_XFLAG_EXTSIZE | FS_XFLAG_EXTSZINHERIT);
 +	if (fa->fsx_cowextsize == 0)
 +		fa->fsx_xflags &= ~FS_XFLAG_COWEXTSIZE;
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL(vfs_ioc_fssetxattr_check);
++=======
+ /**
+  * mode_strip_sgid - handle the sgid bit for non-directories
+  * @mnt_userns: User namespace of the mount the inode was created from
+  * @dir: parent directory inode
+  * @mode: mode of the file to be created in @dir
+  *
+  * If the @mode of the new file has both the S_ISGID and S_IXGRP bit
+  * raised and @dir has the S_ISGID bit raised ensure that the caller is
+  * either in the group of the parent directory or they have CAP_FSETID
+  * in their user namespace and are privileged over the parent directory.
+  * In all other cases, strip the S_ISGID bit from @mode.
+  *
+  * Return: the new mode to use for the file
+  */
+ umode_t mode_strip_sgid(struct user_namespace *mnt_userns,
+ 			const struct inode *dir, umode_t mode)
+ {
+ 	if ((mode & (S_ISGID | S_IXGRP)) != (S_ISGID | S_IXGRP))
+ 		return mode;
+ 	if (S_ISDIR(mode) || !dir || !(dir->i_mode & S_ISGID))
+ 		return mode;
+ 	if (in_group_p(i_gid_into_mnt(mnt_userns, dir)))
+ 		return mode;
+ 	if (capable_wrt_inode_uidgid(mnt_userns, dir, CAP_FSETID))
+ 		return mode;
+ 
+ 	return mode & ~S_ISGID;
+ }
+ EXPORT_SYMBOL(mode_strip_sgid);
++>>>>>>> 2b3416ceff5e (fs: add mode_strip_sgid() helper)
diff --cc include/linux/fs.h
index a7d1230fe088,50642668c60f..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1738,38 -1900,11 +1738,43 @@@ extern long compat_ptr_ioctl(struct fil
  /*
   * VFS file helper functions.
   */
 -void inode_init_owner(struct user_namespace *mnt_userns, struct inode *inode,
 -		      const struct inode *dir, umode_t mode);
 +extern void inode_init_owner(struct inode *inode, const struct inode *dir,
 +			umode_t mode);
  extern bool may_open_dev(const struct path *path);
++<<<<<<< HEAD
 +/*
 + * VFS FS_IOC_FIEMAP helper definitions.
 + */
 +struct fiemap_extent_info {
 +	unsigned int fi_flags;		/* Flags as passed from user */
 +	unsigned int fi_extents_mapped;	/* Number of mapped extents */
 +	unsigned int fi_extents_max;	/* Size of fiemap_extent array */
 +	struct fiemap_extent __user *fi_extents_start; /* Start of
 +							fiemap_extent array */
 +};
 +int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
 +			    u64 phys, u64 len, u32 flags);
 +int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
 +
 +/*
 + * File types
 + *
 + * NOTE! These match bits 12..15 of stat.st_mode
 + * (ie "(i_mode >> 12) & 15").
 + */
 +#define DT_UNKNOWN	0
 +#define DT_FIFO		1
 +#define DT_CHR		2
 +#define DT_DIR		4
 +#define DT_BLK		6
 +#define DT_REG		8
 +#define DT_LNK		10
 +#define DT_SOCK		12
 +#define DT_WHT		14
++=======
+ umode_t mode_strip_sgid(struct user_namespace *mnt_userns,
+ 			const struct inode *dir, umode_t mode);
++>>>>>>> 2b3416ceff5e (fs: add mode_strip_sgid() helper)
  
  /*
   * This is the "filldir" function type, used by readdir() to let
* Unmerged path fs/inode.c
* Unmerged path include/linux/fs.h
