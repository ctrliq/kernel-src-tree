net: stmmac: use .mac_select_pcs() interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
commit 72e94511e9acfca384cb3f100dde8a2f5cc3acc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/72e94511.failed

Convert stmmac to use the mac_select_pcs() interface rather than using
phylink_set_pcs(). The intention here is to unify the approach for PCS
and eventually to remove phylink_set_pcs().

	Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 72e94511e9acfca384cb3f100dde8a2f5cc3acc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 28392c7b9479,e4381e13dae5..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -902,109 -936,15 +902,121 @@@ static void stmmac_mac_flow_ctrl(struc
  			priv->pause, tx_cnt);
  }
  
++<<<<<<< HEAD
 +static void stmmac_validate(struct phylink_config *config,
 +			    unsigned long *supported,
 +			    struct phylink_link_state *state)
 +{
 +	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 +	__ETHTOOL_DECLARE_LINK_MODE_MASK(mac_supported) = { 0, };
 +	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
 +	int tx_cnt = priv->plat->tx_queues_to_use;
 +	int max_speed = priv->plat->max_speed;
 +
 +	phylink_set(mac_supported, 10baseT_Half);
 +	phylink_set(mac_supported, 10baseT_Full);
 +	phylink_set(mac_supported, 100baseT_Half);
 +	phylink_set(mac_supported, 100baseT_Full);
 +	phylink_set(mac_supported, 1000baseT_Half);
 +	phylink_set(mac_supported, 1000baseT_Full);
 +	phylink_set(mac_supported, 1000baseKX_Full);
 +
 +	phylink_set(mac_supported, Autoneg);
 +	phylink_set(mac_supported, Pause);
 +	phylink_set(mac_supported, Asym_Pause);
 +	phylink_set_port_modes(mac_supported);
 +
 +	/* Cut down 1G if asked to */
 +	if ((max_speed > 0) && (max_speed < 1000)) {
 +		phylink_set(mask, 1000baseT_Full);
 +		phylink_set(mask, 1000baseX_Full);
 +	} else if (priv->plat->has_xgmac) {
 +		if (!max_speed || (max_speed >= 2500)) {
 +			phylink_set(mac_supported, 2500baseT_Full);
 +			phylink_set(mac_supported, 2500baseX_Full);
 +		}
 +		if (!max_speed || (max_speed >= 5000)) {
 +			phylink_set(mac_supported, 5000baseT_Full);
 +		}
 +		if (!max_speed || (max_speed >= 10000)) {
 +			phylink_set(mac_supported, 10000baseSR_Full);
 +			phylink_set(mac_supported, 10000baseLR_Full);
 +			phylink_set(mac_supported, 10000baseER_Full);
 +			phylink_set(mac_supported, 10000baseLRM_Full);
 +			phylink_set(mac_supported, 10000baseT_Full);
 +			phylink_set(mac_supported, 10000baseKX4_Full);
 +			phylink_set(mac_supported, 10000baseKR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 25000)) {
 +			phylink_set(mac_supported, 25000baseCR_Full);
 +			phylink_set(mac_supported, 25000baseKR_Full);
 +			phylink_set(mac_supported, 25000baseSR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 40000)) {
 +			phylink_set(mac_supported, 40000baseKR4_Full);
 +			phylink_set(mac_supported, 40000baseCR4_Full);
 +			phylink_set(mac_supported, 40000baseSR4_Full);
 +			phylink_set(mac_supported, 40000baseLR4_Full);
 +		}
 +		if (!max_speed || (max_speed >= 50000)) {
 +			phylink_set(mac_supported, 50000baseCR2_Full);
 +			phylink_set(mac_supported, 50000baseKR2_Full);
 +			phylink_set(mac_supported, 50000baseSR2_Full);
 +			phylink_set(mac_supported, 50000baseKR_Full);
 +			phylink_set(mac_supported, 50000baseSR_Full);
 +			phylink_set(mac_supported, 50000baseCR_Full);
 +			phylink_set(mac_supported, 50000baseLR_ER_FR_Full);
 +			phylink_set(mac_supported, 50000baseDR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 100000)) {
 +			phylink_set(mac_supported, 100000baseKR4_Full);
 +			phylink_set(mac_supported, 100000baseSR4_Full);
 +			phylink_set(mac_supported, 100000baseCR4_Full);
 +			phylink_set(mac_supported, 100000baseLR4_ER4_Full);
 +			phylink_set(mac_supported, 100000baseKR2_Full);
 +			phylink_set(mac_supported, 100000baseSR2_Full);
 +			phylink_set(mac_supported, 100000baseCR2_Full);
 +			phylink_set(mac_supported, 100000baseLR2_ER2_FR2_Full);
 +			phylink_set(mac_supported, 100000baseDR2_Full);
 +		}
 +	}
 +
 +	/* Half-Duplex can only work with single queue */
 +	if (tx_cnt > 1) {
 +		phylink_set(mask, 10baseT_Half);
 +		phylink_set(mask, 100baseT_Half);
 +		phylink_set(mask, 1000baseT_Half);
 +	}
 +
 +	linkmode_and(supported, supported, mac_supported);
 +	linkmode_andnot(supported, supported, mask);
 +
 +	linkmode_and(state->advertising, state->advertising, mac_supported);
 +	linkmode_andnot(state->advertising, state->advertising, mask);
 +
 +	/* If PCS is supported, check which modes it supports. */
 +	if (priv->hw->xpcs)
 +		xpcs_validate(priv->hw->xpcs_args, supported, state);
 +}
 +
 +static void stmmac_mac_pcs_get_state(struct phylink_config *config,
 +				     struct phylink_link_state *state)
 +{
 +	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 +
 +	state->link = 0;
 +	stmmac_xpcs_get_state(priv, priv->hw->xpcs_args, state);
++=======
+ static struct phylink_pcs *stmmac_mac_select_pcs(struct phylink_config *config,
+ 						 phy_interface_t interface)
+ {
+ 	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
+ 
+ 	if (!priv->hw->xpcs)
+ 		return NULL;
+ 
+ 	return &priv->hw->xpcs->pcs;
++>>>>>>> 72e94511e9ac (net: stmmac: use .mac_select_pcs() interface)
  }
  
  static void stmmac_mac_config(struct phylink_config *config, unsigned int mode,
@@@ -1152,10 -1083,9 +1164,15 @@@ static void stmmac_mac_link_up(struct p
  }
  
  static const struct phylink_mac_ops stmmac_phylink_mac_ops = {
++<<<<<<< HEAD
 +	.validate = stmmac_validate,
 +	.mac_pcs_get_state = stmmac_mac_pcs_get_state,
++=======
+ 	.validate = phylink_generic_validate,
+ 	.mac_select_pcs = stmmac_mac_select_pcs,
++>>>>>>> 72e94511e9ac (net: stmmac: use .mac_select_pcs() interface)
  	.mac_config = stmmac_mac_config,
 +	.mac_an_restart = stmmac_mac_an_restart,
  	.mac_link_down = stmmac_mac_link_down,
  	.mac_link_up = stmmac_mac_link_up,
  };
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
