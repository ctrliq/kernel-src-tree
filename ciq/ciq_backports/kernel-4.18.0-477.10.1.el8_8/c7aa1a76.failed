netfilter: ipset: regression in ip_set_hash_ip.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Vishwanath Pai <vpai@akamai.com>
commit c7aa1a76d4a0a3c401025b60c401412bbb60f8c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/c7aa1a76.failed

This patch introduced a regression: commit 48596a8ddc46 ("netfilter:
ipset: Fix adding an IPv4 range containing more than 2^31 addresses")

The variable e.ip is passed to adtfn() function which finally adds the
ip address to the set. The patch above refactored the for loop and moved
e.ip = htonl(ip) to the end of the for loop.

What this means is that if the value of "ip" changes between the first
assignement of e.ip and the forloop, then e.ip is pointing to a
different ip address than "ip".

Test case:
$ ipset create jdtest_tmp hash:ip family inet hashsize 2048 maxelem 100000
$ ipset add jdtest_tmp 10.0.1.1/31
ipset v6.21.1: Element cannot be added to the set: it's already added

The value of ip gets updated inside the  "else if (tb[IPSET_ATTR_CIDR])"
block but e.ip is still pointing to the old value.

Fixes: 48596a8ddc46 ("netfilter: ipset: Fix adding an IPv4 range containing more than 2^31 addresses")
	Reviewed-by: Joshua Hunt <johunt@akamai.com>
	Signed-off-by: Vishwanath Pai <vpai@akamai.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c7aa1a76d4a0a3c401025b60c401412bbb60f8c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_ip.c
diff --cc net/netfilter/ipset/ip_set_hash_ip.c
index 613eb212cb48,75d556d71652..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ip.c
+++ b/net/netfilter/ipset/ip_set_hash_ip.c
@@@ -147,11 -147,14 +147,18 @@@ hash_ip4_uadt(struct ip_set *set, struc
  
  	hosts = h->netmask == 32 ? 1 : 2 << (32 - h->netmask - 1);
  
++<<<<<<< HEAD
 +	if (retried) {
++=======
+ 	/* 64bit division is not allowed on 32bit */
+ 	if (((u64)ip_to - ip + 1) >> (32 - h->netmask) > IPSET_MAX_RANGE)
+ 		return -ERANGE;
+ 
+ 	if (retried)
++>>>>>>> c7aa1a76d4a0 (netfilter: ipset: regression in ip_set_hash_ip.c)
  		ip = ntohl(h->next.ip);
- 		e.ip = htonl(ip);
- 	}
  	for (; ip <= ip_to;) {
+ 		e.ip = htonl(ip);
  		ret = adtfn(set, &e, &ext, &ext, flags);
  		if (ret && !ip_set_eexist(ret, flags))
  			return ret;
* Unmerged path net/netfilter/ipset/ip_set_hash_ip.c
