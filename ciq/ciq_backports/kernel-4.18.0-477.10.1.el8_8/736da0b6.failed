firmware_loader: Check fw_state_is_done in loading_store

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Russ Weight <russell.h.weight@intel.com>
commit 736da0b657f615db7e29606eb8818871534a8943
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/736da0b6.failed

Rename fw_sysfs_done() and fw_sysfs_loading() to fw_state_is_done() and
fw_state_is_loading() respectively, and place them along side companion
functions in drivers/base/firmware_loader/firmware.h.

Use the fw_state_is_done() function to exit early from
firmware_loading_store() if the state is already "done". This is being done
in preparation for supporting persistent sysfs nodes to allow userspace to
upload firmware to a device, potentially reusing the sysfs loading and data
files multiple times.

	Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
	Reviewed-by: Tianfei zhang <tianfei.zhang@intel.com>
	Tested-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
	Signed-off-by: Russ Weight <russell.h.weight@intel.com>
Link: https://lore.kernel.org/r/20220421212204.36052-3-russell.h.weight@intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 736da0b657f615db7e29606eb8818871534a8943)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/firmware_loader/fallback.c
#	drivers/base/firmware_loader/firmware.h
diff --cc drivers/base/firmware_loader/fallback.c
index b59f7ade4eaf,8063eb595719..000000000000
--- a/drivers/base/firmware_loader/fallback.c
+++ b/drivers/base/firmware_loader/fallback.c
@@@ -268,18 -246,11 +258,23 @@@ static ssize_t firmware_loading_store(s
  	switch (loading) {
  	case 1:
  		/* discarding any previous partial load */
++<<<<<<< HEAD
 +		if (!fw_sysfs_done(fw_priv)) {
 +			for (i = 0; i < fw_priv->nr_pages; i++)
 +				__free_page(fw_priv->pages[i]);
 +			vfree(fw_priv->pages);
 +			fw_priv->pages = NULL;
 +			fw_priv->page_array_size = 0;
 +			fw_priv->nr_pages = 0;
 +			fw_state_start(fw_priv);
 +		}
++=======
+ 		fw_free_paged_buf(fw_priv);
+ 		fw_state_start(fw_priv);
++>>>>>>> 736da0b657f6 (firmware_loader: Check fw_state_is_done in loading_store)
  		break;
  	case 0:
- 		if (fw_sysfs_loading(fw_priv)) {
+ 		if (fw_state_is_loading(fw_priv)) {
  			int rc;
  
  			/*
diff --cc drivers/base/firmware_loader/firmware.h
index e2000b4ad09b,d5ff32a1ba2d..000000000000
--- a/drivers/base/firmware_loader/firmware.h
+++ b/drivers/base/firmware_loader/firmware.h
@@@ -138,7 -149,45 +138,50 @@@ static inline void fw_state_done(struc
  	__fw_state_set(fw_priv, FW_STATUS_DONE);
  }
  
++<<<<<<< HEAD
 +int assign_fw(struct firmware *fw, struct device *device,
 +	      enum fw_opt opt_flags);
++=======
+ static inline bool fw_state_is_done(struct fw_priv *fw_priv)
+ {
+ 	return __fw_state_check(fw_priv, FW_STATUS_DONE);
+ }
+ 
+ static inline bool fw_state_is_loading(struct fw_priv *fw_priv)
+ {
+ 	return __fw_state_check(fw_priv, FW_STATUS_LOADING);
+ }
+ 
+ int assign_fw(struct firmware *fw, struct device *device);
+ 
+ #ifdef CONFIG_FW_LOADER
+ bool firmware_is_builtin(const struct firmware *fw);
+ bool firmware_request_builtin_buf(struct firmware *fw, const char *name,
+ 				  void *buf, size_t size);
+ #else /* module case */
+ static inline bool firmware_is_builtin(const struct firmware *fw)
+ {
+ 	return false;
+ }
+ static inline bool firmware_request_builtin_buf(struct firmware *fw,
+ 						const char *name,
+ 						void *buf, size_t size)
+ {
+ 	return false;
+ }
+ #endif
+ 
+ #ifdef CONFIG_FW_LOADER_PAGED_BUF
+ void fw_free_paged_buf(struct fw_priv *fw_priv);
+ int fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed);
+ int fw_map_paged_buf(struct fw_priv *fw_priv);
+ bool fw_is_paged_buf(struct fw_priv *fw_priv);
+ #else
+ static inline void fw_free_paged_buf(struct fw_priv *fw_priv) {}
+ static inline int fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed) { return -ENXIO; }
+ static inline int fw_map_paged_buf(struct fw_priv *fw_priv) { return -ENXIO; }
+ static inline bool fw_is_paged_buf(struct fw_priv *fw_priv) { return false; }
+ #endif
++>>>>>>> 736da0b657f6 (firmware_loader: Check fw_state_is_done in loading_store)
  
  #endif /* __FIRMWARE_LOADER_H */
* Unmerged path drivers/base/firmware_loader/fallback.c
* Unmerged path drivers/base/firmware_loader/firmware.h
