regmap-irq: Remove inappropriate uses of regmap_irq_update_bits()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Aidan MacDonald <aidanmacdonald.0x0@gmail.com>
commit 6b0c31747722936101d56e71e809bfd7a6a440b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/6b0c3174.failed

regmap_irq_update_bits() is misnamed and should only be used for
updating mask registers, since it checks the mask_writeonly flag.
However, it was also used for updating wake and type registers.

It's safe to replace these uses with regmap_update_bits() because
there are no users of the mask_writeonly flag.

	Signed-off-by: Aidan MacDonald <aidanmacdonald.0x0@gmail.com>
Link: https://lore.kernel.org/r/20220623211420.918875-6-aidanmacdonald.0x0@gmail.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 6b0c31747722936101d56e71e809bfd7a6a440b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regmap-irq.c
diff --cc drivers/base/regmap/regmap-irq.c
index edf2854ce062,cb20ce6f91e7..000000000000
--- a/drivers/base/regmap/regmap-irq.c
+++ b/drivers/base/regmap/regmap-irq.c
@@@ -119,11 -155,10 +119,11 @@@ static void regmap_irq_sync_unlock(stru
  			dev_err(d->map->dev, "Failed to sync masks in %x\n",
  				reg);
  
 -		reg = sub_irq_reg(d, d->chip->wake_base, i);
 +		reg = d->chip->wake_base +
 +			(i * map->reg_stride * d->irq_reg_stride);
  		if (d->wake_buf) {
  			if (d->chip->wake_invert)
- 				ret = regmap_irq_update_bits(d, reg,
+ 				ret = regmap_update_bits(d->map, reg,
  							 d->mask_buf_def[i],
  							 ~d->wake_buf[i]);
  			else
@@@ -163,20 -198,36 +163,53 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < d->chip->num_type_reg; i++) {
 +		if (!d->type_buf_def[i])
 +			continue;
 +		reg = d->chip->type_base +
 +			(i * map->reg_stride * d->type_reg_stride);
 +		if (d->chip->type_invert)
 +			ret = regmap_irq_update_bits(d, reg,
 +				d->type_buf_def[i], ~d->type_buf[i]);
 +		else
 +			ret = regmap_irq_update_bits(d, reg,
 +				d->type_buf_def[i], d->type_buf[i]);
 +		if (ret != 0)
 +			dev_err(d->map->dev, "Failed to sync type in %x\n",
 +				reg);
++=======
+ 	/* Don't update the type bits if we're using mask bits for irq type. */
+ 	if (!d->chip->type_in_mask) {
+ 		for (i = 0; i < d->chip->num_type_reg; i++) {
+ 			if (!d->type_buf_def[i])
+ 				continue;
+ 			reg = sub_irq_reg(d, d->chip->type_base, i);
+ 			if (d->chip->type_invert)
+ 				ret = regmap_update_bits(d->map, reg,
+ 					d->type_buf_def[i], ~d->type_buf[i]);
+ 			else
+ 				ret = regmap_update_bits(d->map, reg,
+ 					d->type_buf_def[i], d->type_buf[i]);
+ 			if (ret != 0)
+ 				dev_err(d->map->dev, "Failed to sync type in %x\n",
+ 					reg);
+ 		}
+ 	}
+ 
+ 	if (d->chip->num_virt_regs) {
+ 		for (i = 0; i < d->chip->num_virt_regs; i++) {
+ 			for (j = 0; j < d->chip->num_regs; j++) {
+ 				reg = sub_irq_reg(d, d->chip->virt_reg_base[i],
+ 						  j);
+ 				ret = regmap_write(map, reg, d->virt_buf[i][j]);
+ 				if (ret != 0)
+ 					dev_err(d->map->dev,
+ 						"Failed to write virt 0x%x: %d\n",
+ 						reg, ret);
+ 			}
+ 		}
++>>>>>>> 6b0c31747722 (regmap-irq: Remove inappropriate uses of regmap_irq_update_bits())
  	}
  
  	if (d->chip->runtime_pm)
@@@ -615,11 -822,10 +648,11 @@@ int regmap_add_irq_chip_fwnode(struct f
  	if (d->wake_buf) {
  		for (i = 0; i < chip->num_regs; i++) {
  			d->wake_buf[i] = d->mask_buf_def[i];
 -			reg = sub_irq_reg(d, d->chip->wake_base, i);
 +			reg = chip->wake_base +
 +				(i * map->reg_stride * d->irq_reg_stride);
  
  			if (chip->wake_invert)
- 				ret = regmap_irq_update_bits(d, reg,
+ 				ret = regmap_update_bits(d->map, reg,
  							 d->mask_buf_def[i],
  							 0);
  			else
* Unmerged path drivers/base/regmap/regmap-irq.c
