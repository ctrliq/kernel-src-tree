gfs2: Revert 'Fix "truncate in progress" hang'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit de3f906f0af0c3f5d862b07df4d020c9322cd9c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/de3f906f.failed

Now that interrupted truncates are completed in the context of the
process taking the glock, there is no need for the glock state engine to
delegate that task to gfs2_quotad or for quotad to perform those
truncates anymore.  Get rid of the obsolete associated infrastructure.

Reverts commit 813e0c46c9e2 ("GFS2: Fix "truncate in progress" hang").

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit de3f906f0af0c3f5d862b07df4d020c9322cd9c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
#	fs/gfs2/main.c
diff --cc fs/gfs2/glock.c
index c9e74d9e7d29,347c7bc1fae3..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -2211,29 -2205,6 +2203,32 @@@ void gfs2_gl_hash_clear(struct gfs2_sb
  	glock_hash_walk(dump_glock_func, sdp);
  }
  
++<<<<<<< HEAD
 +void gfs2_glock_finish_truncate(struct gfs2_inode *ip)
 +{
 +	struct gfs2_glock *gl = ip->i_gl;
 +	int ret;
 +
 +	ret = gfs2_truncatei_resume(ip);
 +	gfs2_assert_withdraw(gl->gl_name.ln_sbd, ret == 0);
 +
 +	spin_lock(&gl->gl_lockref.lock);
 +	clear_bit(GLF_LOCK, &gl->gl_flags);
 +	run_queue(gl, 1);
 +	wake_up_glock(gl);
 +	spin_unlock(&gl->gl_lockref.lock);
 +}
 +
 +void gfs2_wait_truncate(struct gfs2_inode *ip)
 +{
 +	struct gfs2_glock *gl = ip->i_gl;
 +	wait_queue_head_t *wq = glock_waitqueue(&gl->gl_name);
 +
 +	wait_event(*wq, !(ip->i_diskflags & GFS2_DIF_TRUNC_IN_PROG));
 +}
 +
++=======
++>>>>>>> de3f906f0af0 (gfs2: Revert 'Fix "truncate in progress" hang')
  static const char *state2str(unsigned state)
  {
  	switch(state) {
diff --cc fs/gfs2/main.c
index 5498f4668fa6,d94791527dcb..000000000000
--- a/fs/gfs2/main.c
+++ b/fs/gfs2/main.c
@@@ -41,7 -38,7 +41,11 @@@ static void gfs2_init_inode_once(void *
  	inode_init_once(&ip->i_inode);
  	atomic_set(&ip->i_sizehint, 0);
  	init_rwsem(&ip->i_rw_mutex);
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&ip->i_trunc_list);
++=======
+ 	INIT_LIST_HEAD(&ip->i_ordered);
++>>>>>>> de3f906f0af0 (gfs2: Revert 'Fix "truncate in progress" hang')
  	ip->i_qadata = NULL;
  	gfs2_holder_mark_uninitialized(&ip->i_rgd_gh);
  	memset(&ip->i_res, 0, sizeof(ip->i_res));
* Unmerged path fs/gfs2/glock.c
diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.h
index 885d044e536c..70f0dc5d79c3 100644
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@ -254,8 +254,6 @@ extern void gfs2_cancel_delete_work(struct gfs2_glock *gl);
 extern bool gfs2_delete_work_queued(const struct gfs2_glock *gl);
 extern void gfs2_flush_delete_work(struct gfs2_sbd *sdp);
 extern void gfs2_gl_hash_clear(struct gfs2_sbd *sdp);
-extern void gfs2_glock_finish_truncate(struct gfs2_inode *ip);
-extern void gfs2_wait_truncate(struct gfs2_inode *ip);
 extern void gfs2_glock_thaw(struct gfs2_sbd *sdp);
 extern void gfs2_glock_add_to_lru(struct gfs2_glock *gl);
 extern void gfs2_glock_free(struct gfs2_glock *gl);
diff --git a/fs/gfs2/glops.c b/fs/gfs2/glops.c
index dd0905c1f005..bb57837aeb48 100644
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@ -483,7 +483,6 @@ int gfs2_inode_refresh(struct gfs2_inode *ip)
 static int inode_go_instantiate(struct gfs2_holder *gh)
 {
 	struct gfs2_glock *gl = gh->gh_gl;
-	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct gfs2_inode *ip = gl->gl_object;
 	int error = 0;
 
@@ -499,14 +498,8 @@ static int inode_go_instantiate(struct gfs2_holder *gh)
 
 	if ((ip->i_diskflags & GFS2_DIF_TRUNC_IN_PROG) &&
 	    (gl->gl_state == LM_ST_EXCLUSIVE) &&
-	    (gh->gh_state == LM_ST_EXCLUSIVE)) {
-		spin_lock(&sdp->sd_trunc_lock);
-		if (list_empty(&ip->i_trunc_list))
-			list_add(&ip->i_trunc_list, &sdp->sd_trunc_list);
-		spin_unlock(&sdp->sd_trunc_lock);
-		wake_up(&sdp->sd_quota_wait);
-		gfs2_wait_truncate(ip);
-	}
+	    (gh->gh_state == LM_ST_EXCLUSIVE))
+		error = gfs2_truncatei_resume(ip);
 
 out:
 	return error;
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d96800eb3df9..64b0dc7bcb8a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -402,7 +402,6 @@ struct gfs2_inode {
 	atomic_t i_sizehint;  /* hint of the write size */
 	struct rw_semaphore i_rw_mutex;
 	struct list_head i_ordered;
-	struct list_head i_trunc_list;
 	__be64 *i_hash_cache;
 	u32 i_entries;
 	u32 i_diskflags;
@@ -788,8 +787,6 @@ struct gfs2_sbd {
 	struct mutex sd_quota_mutex;
 	struct mutex sd_quota_sync_mutex;
 	wait_queue_head_t sd_quota_wait;
-	struct list_head sd_trunc_list;
-	spinlock_t sd_trunc_lock;
 
 	unsigned int sd_quota_slots;
 	unsigned long *sd_quota_bitmap;
* Unmerged path fs/gfs2/main.c
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index a7e8715ce000..2a11b9740102 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -108,8 +108,6 @@ static struct gfs2_sbd *init_sbd(struct super_block *sb)
 	mutex_init(&sdp->sd_quota_mutex);
 	mutex_init(&sdp->sd_quota_sync_mutex);
 	init_waitqueue_head(&sdp->sd_quota_wait);
-	INIT_LIST_HEAD(&sdp->sd_trunc_list);
-	spin_lock_init(&sdp->sd_trunc_lock);
 	spin_lock_init(&sdp->sd_bitmap_lock);
 
 	INIT_LIST_HEAD(&sdp->sd_sc_inodes_list);
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index ae30a2884ee8..07d58a4abc42 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -1508,25 +1508,6 @@ static void quotad_check_timeo(struct gfs2_sbd *sdp, const char *msg,
 	}
 }
 
-static void quotad_check_trunc_list(struct gfs2_sbd *sdp)
-{
-	struct gfs2_inode *ip;
-
-	while(1) {
-		ip = NULL;
-		spin_lock(&sdp->sd_trunc_lock);
-		if (!list_empty(&sdp->sd_trunc_list)) {
-			ip = list_first_entry(&sdp->sd_trunc_list,
-					struct gfs2_inode, i_trunc_list);
-			list_del_init(&ip->i_trunc_list);
-		}
-		spin_unlock(&sdp->sd_trunc_lock);
-		if (ip == NULL)
-			return;
-		gfs2_glock_finish_truncate(ip);
-	}
-}
-
 void gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {
 	if (!sdp->sd_statfs_force_sync) {
 		sdp->sd_statfs_force_sync = 1;
@@ -1549,7 +1530,6 @@ int gfs2_quotad(void *data)
 	unsigned long quotad_timeo = 0;
 	unsigned long t = 0;
 	DEFINE_WAIT(wait);
-	int empty;
 
 	while (!kthread_should_stop()) {
 
@@ -1570,19 +1550,13 @@ int gfs2_quotad(void *data)
 		quotad_check_timeo(sdp, "sync", gfs2_quota_sync, t,
 				   &quotad_timeo, &tune->gt_quota_quantum);
 
-		/* Check for & recover partially truncated inodes */
-		quotad_check_trunc_list(sdp);
-
 		try_to_freeze();
 
 bypass:
 		t = min(quotad_timeo, statfs_timeo);
 
 		prepare_to_wait(&sdp->sd_quota_wait, &wait, TASK_INTERRUPTIBLE);
-		spin_lock(&sdp->sd_trunc_lock);
-		empty = list_empty(&sdp->sd_trunc_list);
-		spin_unlock(&sdp->sd_trunc_lock);
-		if (empty && !sdp->sd_statfs_force_sync)
+		if (!sdp->sd_statfs_force_sync)
 			t -= schedule_timeout(t);
 		else
 			t = 0;
