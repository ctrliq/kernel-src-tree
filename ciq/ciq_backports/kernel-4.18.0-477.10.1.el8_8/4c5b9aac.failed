x86/boot: Port I/O: Add decompression-time support for TDX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit 4c5b9aac6cade51aef64cc6ed67f2ad5acda9aed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/4c5b9aac.failed

Port I/O instructions trigger #VE in the TDX environment. In response to
the exception, kernel emulates these instructions using hypercalls.

But during early boot, on the decompression stage, it is cumbersome to
deal with #VE. It is cleaner to go to hypercalls directly, bypassing #VE
handling.

Hook up TDX-specific port I/O helpers if booting in TDX environment.

	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
Link: https://lkml.kernel.org/r/20220405232939.73860-17-kirill.shutemov@linux.intel.com
(cherry picked from commit 4c5b9aac6cade51aef64cc6ed67f2ad5acda9aed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/Makefile
#	arch/x86/boot/compressed/tdx.c
#	arch/x86/include/asm/shared/tdx.h
#	arch/x86/include/asm/tdx.h
diff --cc arch/x86/boot/compressed/Makefile
index 3ffaacf049db,8fd0e6ae2e1f..000000000000
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@@ -95,37 -101,13 +95,41 @@@ ifdef CONFIG_X86_6
  endif
  
  vmlinux-objs-$(CONFIG_ACPI) += $(obj)/acpi.o
++<<<<<<< HEAD
++=======
+ vmlinux-objs-$(CONFIG_INTEL_TDX_GUEST) += $(obj)/tdx.o $(obj)/tdcall.o
++>>>>>>> 4c5b9aac6cad (x86/boot: Port I/O: Add decompression-time support for TDX)
 +
 +$(obj)/eboot.o: KBUILD_CFLAGS += -fshort-wchar -mno-red-zone
  
 +vmlinux-objs-$(CONFIG_EFI_STUB) += $(obj)/eboot.o $(obj)/efi_stub_$(BITS).o \
 +	$(objtree)/drivers/firmware/efi/libstub/lib.a
  vmlinux-objs-$(CONFIG_EFI_MIXED) += $(obj)/efi_thunk_$(BITS).o
 -efi-obj-$(CONFIG_EFI_STUB) = $(objtree)/drivers/firmware/efi/libstub/lib.a
  
 -$(obj)/vmlinux: $(vmlinux-objs-y) $(efi-obj-y) FORCE
 -	$(call if_changed,ld)
 +# The compressed kernel is built with -fPIC/-fPIE so that a boot loader
 +# can place it anywhere in memory and it will still run. However, since
 +# it is executed as-is without any ELF relocation processing performed
 +# (and has already had all relocation sections stripped from the binary),
 +# none of the code can use data relocations (e.g. static assignments of
 +# pointer values), since they will be meaningless at runtime. This check
 +# will refuse to link the vmlinux if any of these relocations are found.
 +quiet_cmd_check_data_rel = DATAREL $@
 +define cmd_check_data_rel
 +	for obj in $(filter %.o,$^); do \
 +		${CROSS_COMPILE}readelf -S $$obj | grep -qF .rel.local && { \
 +			echo "error: $$obj has data relocations!" >&2; \
 +			exit 1; \
 +		} || true; \
 +	done
 +endef
 +
 +# We need to run two commands under "if_changed", so merge them into a
 +# single invocation.
 +quiet_cmd_check-and-link-vmlinux = LD      $@
 +      cmd_check-and-link-vmlinux = $(cmd_check_data_rel); $(cmd_ld)
 +
 +$(obj)/vmlinux: $(vmlinux-objs-y) FORCE
 +	$(call if_changed,check-and-link-vmlinux)
  
  OBJCOPYFLAGS_vmlinux.bin :=  -R .comment -S
  $(obj)/vmlinux.bin: vmlinux FORCE
* Unmerged path arch/x86/boot/compressed/tdx.c
* Unmerged path arch/x86/include/asm/shared/tdx.h
* Unmerged path arch/x86/include/asm/tdx.h
* Unmerged path arch/x86/boot/compressed/Makefile
diff --git a/arch/x86/boot/compressed/tdcall.S b/arch/x86/boot/compressed/tdcall.S
new file mode 100644
index 000000000000..46d0495e0d3a
--- /dev/null
+++ b/arch/x86/boot/compressed/tdcall.S
@@ -0,0 +1,3 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include "../../coco/tdx/tdcall.S"
* Unmerged path arch/x86/boot/compressed/tdx.c
* Unmerged path arch/x86/include/asm/shared/tdx.h
* Unmerged path arch/x86/include/asm/tdx.h
