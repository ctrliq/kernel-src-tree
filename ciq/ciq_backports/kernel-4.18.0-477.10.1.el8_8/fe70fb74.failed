net: stmmac/xpcs: convert to pcs_validate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
commit fe70fb74b56407c1a5be347258082f8abbe7956d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/fe70fb74.failed

stmmac explicitly calls the xpcs driver to validate the ethtool
linkmodes. This is no longer necessary as phylink now supports
validation through a PCS method. Convert both drivers to use this
new mechanism.

	Tested-by: Wong Vee Khee <vee.khee.wong@linux.intel.com> # Intel EHL
	Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fe70fb74b56407c1a5be347258082f8abbe7956d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
#	drivers/net/pcs/pcs-xpcs.c
#	include/linux/pcs/pcs-xpcs.h
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 49d38e3b6733,029f21b9d452..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -906,105 -940,23 +906,107 @@@ static void stmmac_validate(struct phyl
  			    unsigned long *supported,
  			    struct phylink_link_state *state)
  {
- 	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
  	__ETHTOOL_DECLARE_LINK_MODE_MASK(mac_supported) = { 0, };
 +	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
 +	int tx_cnt = priv->plat->tx_queues_to_use;
 +	int max_speed = priv->plat->max_speed;
 +
 +	phylink_set(mac_supported, 10baseT_Half);
 +	phylink_set(mac_supported, 10baseT_Full);
 +	phylink_set(mac_supported, 100baseT_Half);
 +	phylink_set(mac_supported, 100baseT_Full);
 +	phylink_set(mac_supported, 1000baseT_Half);
 +	phylink_set(mac_supported, 1000baseT_Full);
 +	phylink_set(mac_supported, 1000baseKX_Full);
  
 -	/* This is very similar to phylink_generic_validate() except that
 -	 * we always use PHY_INTERFACE_MODE_INTERNAL to get all capabilities.
 -	 * This is because we don't always have config->supported_interfaces
 -	 * populated (only when we have the XPCS.)
 -	 *
 -	 * When we do have an XPCS, we could pass state->interface, as XPCS
 -	 * limits to a subset of the ethtool link modes allowed here.
 -	 */
  	phylink_set(mac_supported, Autoneg);
 +	phylink_set(mac_supported, Pause);
 +	phylink_set(mac_supported, Asym_Pause);
  	phylink_set_port_modes(mac_supported);
 -	phylink_get_linkmodes(mac_supported, PHY_INTERFACE_MODE_INTERNAL,
 -			      config->mac_capabilities);
 +
 +	/* Cut down 1G if asked to */
 +	if ((max_speed > 0) && (max_speed < 1000)) {
 +		phylink_set(mask, 1000baseT_Full);
 +		phylink_set(mask, 1000baseX_Full);
 +	} else if (priv->plat->has_xgmac) {
 +		if (!max_speed || (max_speed >= 2500)) {
 +			phylink_set(mac_supported, 2500baseT_Full);
 +			phylink_set(mac_supported, 2500baseX_Full);
 +		}
 +		if (!max_speed || (max_speed >= 5000)) {
 +			phylink_set(mac_supported, 5000baseT_Full);
 +		}
 +		if (!max_speed || (max_speed >= 10000)) {
 +			phylink_set(mac_supported, 10000baseSR_Full);
 +			phylink_set(mac_supported, 10000baseLR_Full);
 +			phylink_set(mac_supported, 10000baseER_Full);
 +			phylink_set(mac_supported, 10000baseLRM_Full);
 +			phylink_set(mac_supported, 10000baseT_Full);
 +			phylink_set(mac_supported, 10000baseKX4_Full);
 +			phylink_set(mac_supported, 10000baseKR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 25000)) {
 +			phylink_set(mac_supported, 25000baseCR_Full);
 +			phylink_set(mac_supported, 25000baseKR_Full);
 +			phylink_set(mac_supported, 25000baseSR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 40000)) {
 +			phylink_set(mac_supported, 40000baseKR4_Full);
 +			phylink_set(mac_supported, 40000baseCR4_Full);
 +			phylink_set(mac_supported, 40000baseSR4_Full);
 +			phylink_set(mac_supported, 40000baseLR4_Full);
 +		}
 +		if (!max_speed || (max_speed >= 50000)) {
 +			phylink_set(mac_supported, 50000baseCR2_Full);
 +			phylink_set(mac_supported, 50000baseKR2_Full);
 +			phylink_set(mac_supported, 50000baseSR2_Full);
 +			phylink_set(mac_supported, 50000baseKR_Full);
 +			phylink_set(mac_supported, 50000baseSR_Full);
 +			phylink_set(mac_supported, 50000baseCR_Full);
 +			phylink_set(mac_supported, 50000baseLR_ER_FR_Full);
 +			phylink_set(mac_supported, 50000baseDR_Full);
 +		}
 +		if (!max_speed || (max_speed >= 100000)) {
 +			phylink_set(mac_supported, 100000baseKR4_Full);
 +			phylink_set(mac_supported, 100000baseSR4_Full);
 +			phylink_set(mac_supported, 100000baseCR4_Full);
 +			phylink_set(mac_supported, 100000baseLR4_ER4_Full);
 +			phylink_set(mac_supported, 100000baseKR2_Full);
 +			phylink_set(mac_supported, 100000baseSR2_Full);
 +			phylink_set(mac_supported, 100000baseCR2_Full);
 +			phylink_set(mac_supported, 100000baseLR2_ER2_FR2_Full);
 +			phylink_set(mac_supported, 100000baseDR2_Full);
 +		}
 +	}
 +
 +	/* Half-Duplex can only work with single queue */
 +	if (tx_cnt > 1) {
 +		phylink_set(mask, 10baseT_Half);
 +		phylink_set(mask, 100baseT_Half);
 +		phylink_set(mask, 1000baseT_Half);
 +	}
  
  	linkmode_and(supported, supported, mac_supported);
 +	linkmode_andnot(supported, supported, mask);
 +
  	linkmode_and(state->advertising, state->advertising, mac_supported);
++<<<<<<< HEAD
 +	linkmode_andnot(state->advertising, state->advertising, mask);
 +
 +	/* If PCS is supported, check which modes it supports. */
 +	if (priv->hw->xpcs)
 +		xpcs_validate(priv->hw->xpcs_args, supported, state);
 +}
 +
 +static void stmmac_mac_pcs_get_state(struct phylink_config *config,
 +				     struct phylink_link_state *state)
 +{
 +	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 +
 +	state->link = 0;
 +	stmmac_xpcs_get_state(priv, priv->hw->xpcs_args, state);
++=======
++>>>>>>> fe70fb74b564 (net: stmmac/xpcs: convert to pcs_validate())
  }
  
  static void stmmac_mac_config(struct phylink_config *config, unsigned int mode,
diff --cc drivers/net/pcs/pcs-xpcs.c
index 89a5f43612cf,61418d4dc0cd..000000000000
--- a/drivers/net/pcs/pcs-xpcs.c
+++ b/drivers/net/pcs/pcs-xpcs.c
@@@ -689,38 -632,45 +689,49 @@@ static void xpcs_resolve_pma(struct mdi
  	}
  }
  
++<<<<<<< HEAD
 +void xpcs_validate(struct mdio_xpcs_args *xpcs, unsigned long *supported,
 +		   struct phylink_link_state *state)
++=======
+ static int xpcs_validate(struct phylink_pcs *pcs, unsigned long *supported,
+ 			 const struct phylink_link_state *state)
++>>>>>>> fe70fb74b564 (net: stmmac/xpcs: convert to pcs_validate())
  {
- 	__ETHTOOL_DECLARE_LINK_MODE_MASK(xpcs_supported);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(xpcs_supported) = { 0, };
  	const struct xpcs_compat *compat;
+ 	struct dw_xpcs *xpcs;
  	int i;
  
++<<<<<<< HEAD
 +	/* phylink expects us to report all supported modes with
 +	 * PHY_INTERFACE_MODE_NA, just don't limit the supported and
 +	 * advertising masks and exit.
 +	 */
 +	if (state->interface == PHY_INTERFACE_MODE_NA)
 +		return;
 +
 +	bitmap_zero(xpcs_supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
 +
++=======
+ 	xpcs = phylink_pcs_to_xpcs(pcs);
++>>>>>>> fe70fb74b564 (net: stmmac/xpcs: convert to pcs_validate())
  	compat = xpcs_find_compat(xpcs->id, state->interface);
  
- 	/* Populate the supported link modes for this
- 	 * PHY interface type
+ 	/* Populate the supported link modes for this PHY interface type.
+ 	 * FIXME: what about the port modes and autoneg bit? This masks
+ 	 * all those away.
  	 */
  	if (compat)
  		for (i = 0; compat->supported[i] != __ETHTOOL_LINK_MODE_MASK_NBITS; i++)
  			set_bit(compat->supported[i], xpcs_supported);
  
  	linkmode_and(supported, supported, xpcs_supported);
- 	linkmode_and(state->advertising, state->advertising, xpcs_supported);
+ 
+ 	return 0;
  }
- EXPORT_SYMBOL_GPL(xpcs_validate);
  
 -void xpcs_get_interfaces(struct dw_xpcs *xpcs, unsigned long *interfaces)
 -{
 -	int i, j;
 -
 -	for (i = 0; i < DW_XPCS_INTERFACE_MAX; i++) {
 -		const struct xpcs_compat *compat = &xpcs->id->compat[i];
 -
 -		for (j = 0; j < compat->num_interfaces; j++)
 -			if (compat->interface[j] < PHY_INTERFACE_MODE_MAX)
 -				__set_bit(compat->interface[j], interfaces);
 -	}
 -}
 -EXPORT_SYMBOL_GPL(xpcs_get_interfaces);
 -
 -int xpcs_config_eee(struct dw_xpcs *xpcs, int mult_fact_100ns, int enable)
 +int xpcs_config_eee(struct mdio_xpcs_args *xpcs, int mult_fact_100ns,
 +		    int enable)
  {
  	int ret;
  
@@@ -1038,10 -1105,25 +1049,22 @@@ static const struct xpcs_id xpcs_id_lis
  	},
  };
  
++<<<<<<< HEAD
 +struct mdio_xpcs_args *xpcs_create(struct mdio_device *mdiodev,
 +				   phy_interface_t interface)
++=======
+ static const struct phylink_pcs_ops xpcs_phylink_ops = {
+ 	.pcs_validate = xpcs_validate,
+ 	.pcs_config = xpcs_config,
+ 	.pcs_get_state = xpcs_get_state,
+ 	.pcs_link_up = xpcs_link_up,
+ };
+ 
+ struct dw_xpcs *xpcs_create(struct mdio_device *mdiodev,
+ 			    phy_interface_t interface)
++>>>>>>> fe70fb74b564 (net: stmmac/xpcs: convert to pcs_validate())
  {
 -	struct dw_xpcs *xpcs;
 +	struct mdio_xpcs_args *xpcs;
  	u32 xpcs_id;
  	int i, ret;
  
diff --cc include/linux/pcs/pcs-xpcs.h
index 57a199393d63,266eb26fb029..000000000000
--- a/include/linux/pcs/pcs-xpcs.h
+++ b/include/linux/pcs/pcs-xpcs.h
@@@ -16,28 -19,23 +16,38 @@@
  
  struct xpcs_id;
  
 -struct dw_xpcs {
 +struct mdio_xpcs_args {
  	struct mdio_device *mdiodev;
  	const struct xpcs_id *id;
 -	struct phylink_pcs pcs;
  };
  
++<<<<<<< HEAD
 +struct mdio_xpcs_ops {
 +	int (*config)(struct mdio_xpcs_args *xpcs,
 +		      const struct phylink_link_state *state);
 +	int (*get_state)(struct mdio_xpcs_args *xpcs,
 +			 struct phylink_link_state *state);
 +	int (*link_up)(struct mdio_xpcs_args *xpcs, int speed,
 +		       phy_interface_t interface);
 +};
 +
 +int xpcs_get_an_mode(struct mdio_xpcs_args *xpcs, phy_interface_t interface);
 +struct mdio_xpcs_ops *mdio_xpcs_get_ops(void);
 +void xpcs_validate(struct mdio_xpcs_args *xpcs, unsigned long *supported,
 +		   struct phylink_link_state *state);
 +int xpcs_config_eee(struct mdio_xpcs_args *xpcs, int mult_fact_100ns,
++=======
+ int xpcs_get_an_mode(struct dw_xpcs *xpcs, phy_interface_t interface);
+ void xpcs_link_up(struct phylink_pcs *pcs, unsigned int mode,
+ 		  phy_interface_t interface, int speed, int duplex);
+ int xpcs_do_config(struct dw_xpcs *xpcs, phy_interface_t interface,
+ 		   unsigned int mode);
+ void xpcs_get_interfaces(struct dw_xpcs *xpcs, unsigned long *interfaces);
+ int xpcs_config_eee(struct dw_xpcs *xpcs, int mult_fact_100ns,
++>>>>>>> fe70fb74b564 (net: stmmac/xpcs: convert to pcs_validate())
  		    int enable);
 -struct dw_xpcs *xpcs_create(struct mdio_device *mdiodev,
 -			    phy_interface_t interface);
 -void xpcs_destroy(struct dw_xpcs *xpcs);
 +struct mdio_xpcs_args *xpcs_create(struct mdio_device *mdiodev,
 +				   phy_interface_t interface);
 +void xpcs_destroy(struct mdio_xpcs_args *xpcs);
  
  #endif /* __LINUX_PCS_XPCS_H */
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
* Unmerged path drivers/net/pcs/pcs-xpcs.c
* Unmerged path include/linux/pcs/pcs-xpcs.h
