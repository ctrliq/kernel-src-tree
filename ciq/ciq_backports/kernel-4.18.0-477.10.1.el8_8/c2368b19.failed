net: devlink: introduce "unregistering" mark and use it during devlinks iteration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Jiri Pirko <jiri@nvidia.com>
commit c2368b19807affd7621f7c4638cd2e17fec13021
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/c2368b19.failed

Add new mark called "unregistering" to be set at the beginning of
devlink_unregister() function. Check this mark during devlinks
iteration in order to prevent getting a reference of devlink which is
being currently unregistered.

	Signed-off-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c2368b19807affd7621f7c4638cd2e17fec13021)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index d6ce0602d04f,6b20196ada1a..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -183,8 -201,13 +183,9 @@@ static const struct nla_policy devlink_
  				 DEVLINK_PORT_FN_STATE_ACTIVE),
  };
  
 -static const struct nla_policy devlink_selftest_nl_policy[DEVLINK_ATTR_SELFTEST_ID_MAX + 1] = {
 -	[DEVLINK_ATTR_SELFTEST_ID_FLASH] = { .type = NLA_FLAG },
 -};
 -
  static DEFINE_XARRAY_FLAGS(devlinks, XA_FLAGS_ALLOC);
  #define DEVLINK_REGISTERED XA_MARK_1
+ #define DEVLINK_UNREGISTERING XA_MARK_2
  
  /* devlink instances are open to the access from the user space after
   * devlink_register() call. Such logical barrier allows us to have certain
@@@ -256,6 -294,65 +257,68 @@@ void devl_unlock(struct devlink *devlin
  }
  EXPORT_SYMBOL_GPL(devl_unlock);
  
++<<<<<<< HEAD
++=======
+ static struct devlink *
+ devlinks_xa_find_get(struct net *net, unsigned long *indexp, xa_mark_t filter,
+ 		     void * (*xa_find_fn)(struct xarray *, unsigned long *,
+ 					  unsigned long, xa_mark_t))
+ {
+ 	struct devlink *devlink;
+ 
+ 	rcu_read_lock();
+ retry:
+ 	devlink = xa_find_fn(&devlinks, indexp, ULONG_MAX, DEVLINK_REGISTERED);
+ 	if (!devlink)
+ 		goto unlock;
+ 
+ 	/* In case devlink_unregister() was already called and "unregistering"
+ 	 * mark was set, do not allow to get a devlink reference here.
+ 	 * This prevents live-lock of devlink_unregister() wait for completion.
+ 	 */
+ 	if (xa_get_mark(&devlinks, *indexp, DEVLINK_UNREGISTERING))
+ 		goto retry;
+ 
+ 	/* For a possible retry, the xa_find_after() should be always used */
+ 	xa_find_fn = xa_find_after;
+ 	if (!devlink_try_get(devlink))
+ 		goto retry;
+ 	if (!net_eq(devlink_net(devlink), net)) {
+ 		devlink_put(devlink);
+ 		goto retry;
+ 	}
+ unlock:
+ 	rcu_read_unlock();
+ 	return devlink;
+ }
+ 
+ static struct devlink *devlinks_xa_find_get_first(struct net *net,
+ 						  unsigned long *indexp,
+ 						  xa_mark_t filter)
+ {
+ 	return devlinks_xa_find_get(net, indexp, filter, xa_find);
+ }
+ 
+ static struct devlink *devlinks_xa_find_get_next(struct net *net,
+ 						 unsigned long *indexp,
+ 						 xa_mark_t filter)
+ {
+ 	return devlinks_xa_find_get(net, indexp, filter, xa_find_after);
+ }
+ 
+ /* Iterate over devlink pointers which were possible to get reference to.
+  * devlink_put() needs to be called for each iterated devlink pointer
+  * in loop body in order to release the reference.
+  */
+ #define devlinks_xa_for_each_get(net, index, devlink, filter)			\
+ 	for (index = 0,								\
+ 	     devlink = devlinks_xa_find_get_first(net, &index, filter);		\
+ 	     devlink; devlink = devlinks_xa_find_get_next(net, &index, filter))
+ 
+ #define devlinks_xa_for_each_registered_get(net, index, devlink)		\
+ 	devlinks_xa_for_each_get(net, index, devlink, DEVLINK_REGISTERED)
+ 
++>>>>>>> c2368b19807a (net: devlink: introduce "unregistering" mark and use it during devlinks iteration)
  static struct devlink *devlink_get_from_attrs(struct net *net,
  					      struct nlattr **attrs)
  {
@@@ -9212,10 -9822,9 +9276,14 @@@ void devlink_unregister(struct devlink 
  	devlink_put(devlink);
  	wait_for_completion(&devlink->comp);
  
 +	mutex_lock(&devlink_mutex);
  	devlink_notify_unregister(devlink);
  	xa_clear_mark(&devlinks, devlink->index, DEVLINK_REGISTERED);
++<<<<<<< HEAD
 +	mutex_unlock(&devlink_mutex);
++=======
+ 	xa_clear_mark(&devlinks, devlink->index, DEVLINK_UNREGISTERING);
++>>>>>>> c2368b19807a (net: devlink: introduce "unregistering" mark and use it during devlinks iteration)
  }
  EXPORT_SYMBOL_GPL(devlink_unregister);
  
* Unmerged path net/core/devlink.c
