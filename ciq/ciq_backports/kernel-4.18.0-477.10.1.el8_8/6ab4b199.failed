cpuidle: Add cpu_idle_miss trace event

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Kajetan Puchalski <kajetan.puchalski@arm.com>
commit 6ab4b1990097b76508bd6dffd85ffcacbedb26b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/6ab4b199.failed

Add a trace event for cpuidle to track missed (too deep or too shallow)
wakeups.

After each wakeup, CPUIdle already computes whether the entered state was
optimal, above or below the desired one and updates the relevant
counters. This patch makes it possible to trace those events in addition
to just reading the counters.

The patterns of types and percentages of misses across different
workloads appear to be very consistent. This makes the trace event very
useful for comparing the relative correctness of different CPUIdle
governors for different types of workloads, or for finding the
optimal governor for a given device.

	Signed-off-by: Kajetan Puchalski <kajetan.puchalski@arm.com>
	Reviewed-by: Steven Rostedt (Google) <rostedt@goodmis.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6ab4b1990097b76508bd6dffd85ffcacbedb26b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/cpuidle.c
diff --cc drivers/cpuidle/cpuidle.c
index ae01baa6efec,bf57cab32456..000000000000
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@@ -276,7 -278,8 +277,12 @@@ int cpuidle_enter_state(struct cpuidle_
  					continue;
  
  				/* Shallower states are enabled, so update. */
++<<<<<<< HEAD
 +				dev->rh_cpuidle_dev.rh_states_usage[entered_state].above++;
++=======
+ 				dev->states_usage[entered_state].above++;
+ 				trace_cpu_idle_miss(dev->cpu, entered_state, false);
++>>>>>>> 6ab4b1990097 (cpuidle: Add cpu_idle_miss trace event)
  				break;
  			}
  		} else if (diff > delay) {
@@@ -288,8 -291,10 +294,15 @@@
  				 * Update if a deeper state would have been a
  				 * better match for the observed idle duration.
  				 */
++<<<<<<< HEAD
 +				if (diff - delay >= drv->states[i].target_residency_ns)
 +					dev->rh_cpuidle_dev.rh_states_usage[entered_state].below++;
++=======
+ 				if (diff - delay >= drv->states[i].target_residency_ns) {
+ 					dev->states_usage[entered_state].below++;
+ 					trace_cpu_idle_miss(dev->cpu, entered_state, true);
+ 				}
++>>>>>>> 6ab4b1990097 (cpuidle: Add cpu_idle_miss trace event)
  
  				break;
  			}
* Unmerged path drivers/cpuidle/cpuidle.c
diff --git a/include/trace/events/power.h b/include/trace/events/power.h
index af5018aa9517..2217b407bd38 100644
--- a/include/trace/events/power.h
+++ b/include/trace/events/power.h
@@ -40,6 +40,28 @@ DEFINE_EVENT(cpu, cpu_idle,
 	TP_ARGS(state, cpu_id)
 );
 
+TRACE_EVENT(cpu_idle_miss,
+
+	TP_PROTO(unsigned int cpu_id, unsigned int state, bool below),
+
+	TP_ARGS(cpu_id, state, below),
+
+	TP_STRUCT__entry(
+		__field(u32,		cpu_id)
+		__field(u32,		state)
+		__field(bool,		below)
+	),
+
+	TP_fast_assign(
+		__entry->cpu_id = cpu_id;
+		__entry->state = state;
+		__entry->below = below;
+	),
+
+	TP_printk("cpu_id=%lu state=%lu type=%s", (unsigned long)__entry->cpu_id,
+		(unsigned long)__entry->state, (__entry->below)?"below":"above")
+);
+
 TRACE_EVENT(powernv_throttle,
 
 	TP_PROTO(int chip_id, const char *reason, int pmax),
