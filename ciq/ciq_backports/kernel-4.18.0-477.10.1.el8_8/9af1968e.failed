net/mlx5: Check IPsec TX flow steering namespace in advance

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 9af1968ee13b33b0bff7def9c4861f1730389a7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/9af1968e.failed

Ensure that flow steering is usable as early as possible, to understand
if crypto IPsec is supported or not.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Reviewed-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 9af1968ee13b33b0bff7def9c4861f1730389a7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 32093497292f,55fb6d4cf4ae..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@@ -671,14 -653,27 +666,35 @@@ static int fs_init_rx(struct mlx5e_pri
  {
  	struct mlx5e_accel_fs_esp_prot *fs_prot;
  	struct mlx5e_accel_fs_esp *accel_esp;
+ 	struct mlx5_flow_namespace *ns;
  	enum accel_fs_esp_type i;
 -	int err = -ENOMEM;
  
++<<<<<<< HEAD
 +	priv->ipsec->rx_fs =
 +		kzalloc(sizeof(struct mlx5e_accel_fs_esp), GFP_KERNEL);
 +	if (!priv->ipsec->rx_fs)
 +		return -ENOMEM;
 +
 +	accel_esp = priv->ipsec->rx_fs;
++=======
+ 	ns = mlx5_get_flow_namespace(ipsec->mdev,
+ 				     MLX5_FLOW_NAMESPACE_EGRESS_KERNEL);
+ 	if (!ns)
+ 		return -EOPNOTSUPP;
+ 
+ 	ipsec->tx_fs = kzalloc(sizeof(*ipsec->tx_fs), GFP_KERNEL);
+ 	if (!ipsec->tx_fs)
+ 		return -ENOMEM;
+ 
+ 	ipsec->rx_fs = kzalloc(sizeof(*ipsec->rx_fs), GFP_KERNEL);
+ 	if (!ipsec->rx_fs)
+ 		goto err_rx;
+ 
+ 	mutex_init(&ipsec->tx_fs->mutex);
+ 	ipsec->tx_fs->ns = ns;
+ 
+ 	accel_esp = ipsec->rx_fs;
++>>>>>>> 9af1968ee13b (net/mlx5: Check IPsec TX flow steering namespace in advance)
  	for (i = 0; i < ACCEL_FS_ESP_NUM_TYPES; i++) {
  		fs_prot = &accel_esp->fs_prot[i];
  		mutex_init(&fs_prot->prot_mutex);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index e3e8c1c3ff24..6e3a90a959e9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@ -166,7 +166,6 @@ struct mlx5e_ptp_fs;
 
 struct mlx5e_flow_steering {
 	struct mlx5_flow_namespace      *ns;
-	struct mlx5_flow_namespace      *egress_ns;
 #ifdef CONFIG_MLX5_EN_RXNFC
 	struct mlx5e_ethtool_steering   ethtool;
 #endif
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
index 1391a0c84f16..f3db7e5291d7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.c
@@ -417,6 +417,7 @@ int mlx5e_ipsec_init(struct mlx5e_priv *priv)
 
 	hash_init(ipsec->sadb_rx);
 	spin_lock_init(&ipsec->sadb_rx_lock);
+	ipsec->mdev = priv->mdev;
 	ipsec->en_priv = priv;
 	ipsec->wq = alloc_ordered_workqueue("mlx5e_ipsec: %s", 0,
 					    priv->netdev->name);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
index 45f71910d196..26888881bc57 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec.h
@@ -79,6 +79,7 @@ struct mlx5e_accel_fs_esp;
 struct mlx5e_ipsec_tx;
 
 struct mlx5e_ipsec {
+	struct mlx5_core_dev *mdev;
 	struct mlx5e_priv *en_priv;
 	DECLARE_HASHTABLE(sadb_rx, MLX5E_IPSEC_SADB_RX_BITS);
 	spinlock_t sadb_rx_lock; /* Protects sadb_rx */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
