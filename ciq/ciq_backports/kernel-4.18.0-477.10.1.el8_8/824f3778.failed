x86/compressed/acpi: Move EFI kexec handling into common code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Michael Roth <michael.roth@amd.com>
commit 824f37783189a48db914488fb41eba36ec57ebb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/824f3778.failed

Future patches for SEV-SNP-validated CPUID will also require early
parsing of the EFI configuration. Incrementally move the related code
into a set of helpers that can be re-used for that purpose.

In this instance, the current acpi.c kexec handling is mainly used to
get the alternative EFI config table address provided by kexec via a
setup_data entry of type SETUP_EFI. If not present, the code then falls
back to normal EFI config table address provided by EFI system table.
This would need to be done by all call-sites attempting to access the
EFI config table, so just have efi_get_conf_table() handle that
automatically.

	Signed-off-by: Michael Roth <michael.roth@amd.com>
	Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/r/20220307213356.2797205-29-brijesh.singh@amd.com
(cherry picked from commit 824f37783189a48db914488fb41eba36ec57ebb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/acpi.c
#	arch/x86/boot/compressed/efi.c
diff --cc arch/x86/boot/compressed/acpi.c
index 15255f388a85,64b172dabd5c..000000000000
--- a/arch/x86/boot/compressed/acpi.c
+++ b/arch/x86/boot/compressed/acpi.c
@@@ -20,126 -20,33 +20,129 @@@
   */
  struct mem_vector immovable_mem[MAX_NUMNODES*2];
  
 +/*
 + * Max length of 64-bit hex address string is 19, prefix "0x" + 16 hex
 + * digits, and '\0' for termination.
 + */
 +#define MAX_ADDR_LEN 19
 +
 +static acpi_physical_address get_acpi_rsdp(void)
 +{
 +	acpi_physical_address addr = 0;
 +
 +#ifdef CONFIG_KEXEC
 +	char val[MAX_ADDR_LEN] = { };
 +	int ret;
 +
 +	ret = cmdline_find_option("acpi_rsdp", val, MAX_ADDR_LEN);
 +	if (ret < 0)
 +		return 0;
 +
 +	if (kstrtoull(val, 16, &addr))
 +		return 0;
 +#endif
 +	return addr;
 +}
 +
 +/*
 + * Search EFI system tables for RSDP.  If both ACPI_20_TABLE_GUID and
 + * ACPI_TABLE_GUID are found, take the former, which has more features.
 + */
  static acpi_physical_address
 -__efi_get_rsdp_addr(unsigned long cfg_tbl_pa, unsigned int cfg_tbl_len)
 +__efi_get_rsdp_addr(unsigned long config_tables, unsigned int nr_tables,
 +		    bool efi_64)
  {
 +	acpi_physical_address rsdp_addr = 0;
 +
  #ifdef CONFIG_EFI
 -	unsigned long rsdp_addr;
 -	int ret;
 +	int i;
  
 -	/*
 -	 * Search EFI system tables for RSDP. Preferred is ACPI_20_TABLE_GUID to
 -	 * ACPI_TABLE_GUID because it has more features.
 -	 */
 -	rsdp_addr = efi_find_vendor_table(boot_params, cfg_tbl_pa, cfg_tbl_len,
 -					  ACPI_20_TABLE_GUID);
 -	if (rsdp_addr)
 -		return (acpi_physical_address)rsdp_addr;
 -
 -	/* No ACPI_20_TABLE_GUID found, fallback to ACPI_TABLE_GUID. */
 -	rsdp_addr = efi_find_vendor_table(boot_params, cfg_tbl_pa, cfg_tbl_len,
 -					  ACPI_TABLE_GUID);
 -	if (rsdp_addr)
 -		return (acpi_physical_address)rsdp_addr;
 -
 -	debug_putstr("Error getting RSDP address.\n");
 +	/* Get EFI tables from systab. */
 +	for (i = 0; i < nr_tables; i++) {
 +		acpi_physical_address table;
 +		efi_guid_t guid;
 +
 +		if (efi_64) {
 +			efi_config_table_64_t *tbl = (efi_config_table_64_t *)config_tables + i;
 +
 +			guid  = tbl->guid;
 +			table = tbl->table;
 +
 +			if (!IS_ENABLED(CONFIG_X86_64) && table >> 32) {
 +				debug_putstr("Error getting RSDP address: EFI config table located above 4GB.\n");
 +				return 0;
 +			}
 +		} else {
 +			efi_config_table_32_t *tbl = (efi_config_table_32_t *)config_tables + i;
 +
 +			guid  = tbl->guid;
 +			table = tbl->table;
 +		}
 +
 +		if (!(efi_guidcmp(guid, ACPI_TABLE_GUID)))
 +			rsdp_addr = table;
 +		else if (!(efi_guidcmp(guid, ACPI_20_TABLE_GUID)))
 +			return table;
 +	}
  #endif
 -	return 0;
 +	return rsdp_addr;
  }
  
++<<<<<<< HEAD
 +/* EFI/kexec support is 64-bit only. */
 +#ifdef CONFIG_X86_64
 +static struct efi_setup_data *get_kexec_setup_data_addr(void)
 +{
 +	struct setup_data *data;
 +	u64 pa_data;
 +
 +	pa_data = boot_params->hdr.setup_data;
 +	while (pa_data) {
 +		data = (struct setup_data *)pa_data;
 +		if (data->type == SETUP_EFI)
 +			return (struct efi_setup_data *)(pa_data + sizeof(struct setup_data));
 +
 +		pa_data = data->next;
 +	}
 +	return NULL;
 +}
 +
 +static acpi_physical_address kexec_get_rsdp_addr(void)
 +{
 +	efi_system_table_64_t *systab;
 +	struct efi_setup_data *esd;
 +	struct efi_info *ei;
 +	char *sig;
 +
 +	esd = (struct efi_setup_data *)get_kexec_setup_data_addr();
 +	if (!esd)
 +		return 0;
 +
 +	if (!esd->tables) {
 +		debug_putstr("Wrong kexec SETUP_EFI data.\n");
 +		return 0;
 +	}
 +
 +	ei = &boot_params->efi_info;
 +	sig = (char *)&ei->efi_loader_signature;
 +	if (strncmp(sig, EFI64_LOADER_SIGNATURE, 4)) {
 +		debug_putstr("Wrong kexec EFI loader signature.\n");
 +		return 0;
 +	}
 +
 +	/* Get systab from boot params. */
 +	systab = (efi_system_table_64_t *) (ei->efi_systab | ((__u64)ei->efi_systab_hi << 32));
 +	if (!systab)
 +		error("EFI system table not found in kexec boot_params.");
 +
 +	return __efi_get_rsdp_addr((unsigned long)esd->tables, systab->nr_tables, true);
 +}
 +#else
 +static acpi_physical_address kexec_get_rsdp_addr(void) { return 0; }
 +#endif /* CONFIG_X86_64 */
 +
++=======
++>>>>>>> 824f37783189 (x86/compressed/acpi: Move EFI kexec handling into common code)
  static acpi_physical_address efi_get_rsdp_addr(void)
  {
  #ifdef CONFIG_EFI
@@@ -278,19 -157,8 +281,11 @@@ acpi_physical_address get_rsdp_addr(voi
  {
  	acpi_physical_address pa;
  
 -	pa = boot_params->acpi_rsdp_addr;
 +	pa = get_acpi_rsdp();
 +
 +	if (!pa)
 +		pa = boot_params->acpi_rsdp_addr;
  
- 	/*
- 	 * Try to get EFI data from setup_data. This can happen when we're a
- 	 * kexec'ed kernel and kexec(1) has passed all the required EFI info to
- 	 * us.
- 	 */
- 	if (!pa)
- 		pa = kexec_get_rsdp_addr();
- 
  	if (!pa)
  		pa = efi_get_rsdp_addr();
  
* Unmerged path arch/x86/boot/compressed/efi.c
* Unmerged path arch/x86/boot/compressed/acpi.c
* Unmerged path arch/x86/boot/compressed/efi.c
