net: stmmac: split xPCS setup from mdio register

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Voon Weifeng <weifeng.voon@intel.com>
commit 597a68ce32167e7d07bf40648e1501f786f60f99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/597a68ce.failed

This patch is a preparation patch for the enabling of Intel mGbE 2.5Gbps
link speed. The Intel mGbR link speed configuration (1G/2.5G) is depends on
a mdio ADHOC register which can be configured in the bios menu.
As PHY interface might be different for 1G and 2.5G, the mdio bus need be
ready to check the link speed and select the PHY interface before probing
the xPCS.

	Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
	Signed-off-by: Michael Sit Wei Hong <michael.wei.hong.sit@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 597a68ce32167e7d07bf40648e1501f786f60f99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
index 9fdcebcacd72,bc900e240da2..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
@@@ -519,34 -536,6 +554,37 @@@ int stmmac_mdio_register(struct net_dev
  		goto no_phy_found;
  	}
  
++<<<<<<< HEAD
 +	/* Try to probe the XPCS by scanning all addresses. */
 +	if (mdio_bus_data->has_xpcs) {
 +		int mode = priv->plat->phy_interface;
 +		struct mdio_device *mdiodev;
 +		struct mdio_xpcs_args *xpcs;
 +
 +		for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
 +			mdiodev = mdio_device_create(new_bus, addr);
 +			if (IS_ERR(mdiodev))
 +				continue;
 +
 +			xpcs = xpcs_create(mdiodev, mode);
 +			if (IS_ERR_OR_NULL(xpcs)) {
 +				mdio_device_free(mdiodev);
 +				continue;
 +			}
 +
 +			priv->hw->xpcs_args = xpcs;
 +			break;
 +		}
 +
 +		if (!priv->hw->xpcs_args) {
 +			dev_warn(dev, "No XPCS found\n");
 +			err = -ENODEV;
 +			goto no_xpcs_found;
 +		}
 +	}
 +
++=======
++>>>>>>> 597a68ce3216 (net: stmmac: split xPCS setup from mdio register)
  bus_register_done:
  	priv->mii = new_bus;
  
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 532f17835b06..014719786e71 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -294,6 +294,7 @@ enum stmmac_state {
 int stmmac_mdio_unregister(struct net_device *ndev);
 int stmmac_mdio_register(struct net_device *ndev);
 int stmmac_mdio_reset(struct mii_bus *mii);
+int stmmac_xpcs_setup(struct mii_bus *mii);
 void stmmac_set_ethtool_ops(struct net_device *netdev);
 
 void stmmac_ptp_register(struct stmmac_priv *priv);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 3ebd396e13f0..341c6258987f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -5769,6 +5769,14 @@ int stmmac_dvr_probe(struct device *device,
 		}
 	}
 
+	if (priv->plat->mdio_bus_data) {
+		if (priv->plat->mdio_bus_data->has_xpcs) {
+			ret = stmmac_xpcs_setup(priv->mii);
+			if (ret)
+				goto error_xpcs_setup;
+		}
+	}
+
 	ret = stmmac_phy_setup(priv);
 	if (ret) {
 		netdev_err(ndev, "failed to setup phy (%d)\n", ret);
@@ -5805,6 +5813,7 @@ int stmmac_dvr_probe(struct device *device,
 	unregister_netdev(ndev);
 error_netdev_register:
 	phylink_destroy(priv->phylink);
+error_xpcs_setup:
 error_phy_setup:
 	if (priv->hw->pcs != STMMAC_PCS_TBI &&
 	    priv->hw->pcs != STMMAC_PCS_RTBI)
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
