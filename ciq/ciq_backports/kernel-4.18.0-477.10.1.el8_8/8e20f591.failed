net: phy: add phy_interface_t bitmap support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.10.1.el8_8
commit-author Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
commit 8e20f591f204f8db7f1182918f8e2285d3f589e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.10.1.el8_8/8e20f591.failed

Add support for a bitmap for phy interface modes, which includes:
- a macro to declare the interface bitmap
- an inline helper to zero the interface bitmap
- an inline helper to detect an empty interface bitmap
- inline helpers to do a bitwise AND and OR operations on two interface
  bitmaps

	Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8e20f591f204f8db7f1182918f8e2285d3f589e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/phy.h
diff --cc include/linux/phy.h
index 812a0b236a34,96e43fbb2dd8..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -131,16 -155,42 +131,55 @@@ typedef enum 
  	PHY_INTERFACE_MODE_MAX,
  } phy_interface_t;
  
++<<<<<<< HEAD
 +/**
 + * phy_supported_speeds - return all speeds currently supported by a phy device
 + * @phy: The phy device to return supported speeds of.
 + * @speeds: buffer to store supported speeds in.
 + * @size: size of speeds buffer.
 + *
 + * Description: Returns the number of supported speeds, and fills
 + * the speeds buffer with the supported speeds. If speeds buffer is
 + * too small to contain all currently supported speeds, will return as
 + * many speeds as can fit.
++=======
+ /* PHY interface mode bitmap handling */
+ #define DECLARE_PHY_INTERFACE_MASK(name) \
+ 	DECLARE_BITMAP(name, PHY_INTERFACE_MODE_MAX)
+ 
+ static inline void phy_interface_zero(unsigned long *intf)
+ {
+ 	bitmap_zero(intf, PHY_INTERFACE_MODE_MAX);
+ }
+ 
+ static inline bool phy_interface_empty(const unsigned long *intf)
+ {
+ 	return bitmap_empty(intf, PHY_INTERFACE_MODE_MAX);
+ }
+ 
+ static inline void phy_interface_and(unsigned long *dst, const unsigned long *a,
+ 				     const unsigned long *b)
+ {
+ 	bitmap_and(dst, a, b, PHY_INTERFACE_MODE_MAX);
+ }
+ 
+ static inline void phy_interface_or(unsigned long *dst, const unsigned long *a,
+ 				    const unsigned long *b)
+ {
+ 	bitmap_or(dst, a, b, PHY_INTERFACE_MODE_MAX);
+ }
+ 
+ static inline void phy_interface_set_rgmii(unsigned long *intf)
+ {
+ 	__set_bit(PHY_INTERFACE_MODE_RGMII, intf);
+ 	__set_bit(PHY_INTERFACE_MODE_RGMII_ID, intf);
+ 	__set_bit(PHY_INTERFACE_MODE_RGMII_RXID, intf);
+ 	__set_bit(PHY_INTERFACE_MODE_RGMII_TXID, intf);
+ }
+ 
+ /*
+  * phy_supported_speeds - return all speeds currently supported by a PHY device
++>>>>>>> 8e20f591f204 (net: phy: add phy_interface_t bitmap support)
   */
  unsigned int phy_supported_speeds(struct phy_device *phy,
  				      unsigned int *speeds,
* Unmerged path include/linux/phy.h
