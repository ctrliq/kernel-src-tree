net: asix: fix modprobe "sysfs: cannot create duplicate filename"

jira LE-1907
cve CVE-2021-47101
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Grant Grundler <grundler@chromium.org>
commit 8eac0095de355ee31e1b014f79f83d2cd62a2d04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/8eac0095.failed

"modprobe asix ; rmmod asix ; modprobe asix" fails with:
   sysfs: cannot create duplicate filename \
   	'/devices/virtual/mdio_bus/usb-003:004'

Issue was originally reported by Anton Lundin on 2022-06-22 (link below).

Chrome OS team hit the same issue in Feb, 2023 when trying to find
work arounds for other issues with AX88172 devices.

The use of devm_mdiobus_register() with usbnet devices results in the
MDIO data being associated with the USB device. When the asix driver
is unloaded, the USB device continues to exist and the corresponding
"mdiobus_unregister()" is NOT called until the USB device is unplugged
or unauthorized. So the next "modprobe asix" will fail because the MDIO
phy sysfs attributes still exist.

The 'easy' (from a design PoV) fix is to use the non-devm variants of
mdiobus_* functions and explicitly manage this use in the asix_bind
and asix_unbind function calls. I've not explored trying to fix usbnet
initialization so devm_* stuff will work.

Fixes: e532a096be0e5 ("net: usb: asix: ax88772: add phylib support")
	Reported-by: Anton Lundin <glance@acc.umu.se>
Link: https://lore.kernel.org/netdev/20220623063649.GD23685@pengutronix.de/T/
	Tested-by: Eizan Miyamoto <eizan@chromium.org>
	Signed-off-by: Grant Grundler <grundler@chromium.org>
Link: https://lore.kernel.org/r/20230321170539.732147-1-grundler@chromium.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 8eac0095de355ee31e1b014f79f83d2cd62a2d04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/asix_devices.c
diff --cc drivers/net/usb/asix_devices.c
index 557e8671b5aa,f7cff58fe044..000000000000
--- a/drivers/net/usb/asix_devices.c
+++ b/drivers/net/usb/asix_devices.c
@@@ -689,12 -663,176 +689,174 @@@ static int asix_resume(struct usb_inter
  	return usbnet_resume(intf);
  }
  
++<<<<<<< HEAD
++=======
+ static int ax88772_init_mdio(struct usbnet *dev)
+ {
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 	int ret;
+ 
+ 	priv->mdio = mdiobus_alloc();
+ 	if (!priv->mdio)
+ 		return -ENOMEM;
+ 
+ 	priv->mdio->priv = dev;
+ 	priv->mdio->read = &asix_mdio_bus_read;
+ 	priv->mdio->write = &asix_mdio_bus_write;
+ 	priv->mdio->name = "Asix MDIO Bus";
+ 	/* mii bus name is usb-<usb bus number>-<usb device number> */
+ 	snprintf(priv->mdio->id, MII_BUS_ID_SIZE, "usb-%03d:%03d",
+ 		 dev->udev->bus->busnum, dev->udev->devnum);
+ 
+ 	ret = mdiobus_register(priv->mdio);
+ 	if (ret) {
+ 		netdev_err(dev->net, "Could not register MDIO bus (err %d)\n", ret);
+ 		mdiobus_free(priv->mdio);
+ 		priv->mdio = NULL;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void ax88772_mdio_unregister(struct asix_common_private *priv)
+ {
+ 	mdiobus_unregister(priv->mdio);
+ 	mdiobus_free(priv->mdio);
+ }
+ 
+ static int ax88772_init_phy(struct usbnet *dev)
+ {
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 	int ret;
+ 
+ 	priv->phydev = mdiobus_get_phy(priv->mdio, priv->phy_addr);
+ 	if (!priv->phydev) {
+ 		netdev_err(dev->net, "Could not find PHY\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	ret = phylink_connect_phy(priv->phylink, priv->phydev);
+ 	if (ret) {
+ 		netdev_err(dev->net, "Could not connect PHY\n");
+ 		return ret;
+ 	}
+ 
+ 	phy_suspend(priv->phydev);
+ 	priv->phydev->mac_managed_pm = true;
+ 
+ 	phy_attached_info(priv->phydev);
+ 
+ 	if (priv->embd_phy)
+ 		return 0;
+ 
+ 	/* In case main PHY is not the embedded PHY and MAC is RMII clock
+ 	 * provider, we need to suspend embedded PHY by keeping PLL enabled
+ 	 * (AX_SWRESET_IPPD == 0).
+ 	 */
+ 	priv->phydev_int = mdiobus_get_phy(priv->mdio, AX_EMBD_PHY_ADDR);
+ 	if (!priv->phydev_int) {
+ 		rtnl_lock();
+ 		phylink_disconnect_phy(priv->phylink);
+ 		rtnl_unlock();
+ 		netdev_err(dev->net, "Could not find internal PHY\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	priv->phydev_int->mac_managed_pm = true;
+ 	phy_suspend(priv->phydev_int);
+ 
+ 	return 0;
+ }
+ 
+ static void ax88772_mac_config(struct phylink_config *config, unsigned int mode,
+ 			      const struct phylink_link_state *state)
+ {
+ 	/* Nothing to do */
+ }
+ 
+ static void ax88772_mac_link_down(struct phylink_config *config,
+ 				 unsigned int mode, phy_interface_t interface)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(config->dev));
+ 
+ 	asix_write_medium_mode(dev, 0, 0);
+ 	usbnet_link_change(dev, false, false);
+ }
+ 
+ static void ax88772_mac_link_up(struct phylink_config *config,
+ 			       struct phy_device *phy,
+ 			       unsigned int mode, phy_interface_t interface,
+ 			       int speed, int duplex,
+ 			       bool tx_pause, bool rx_pause)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(config->dev));
+ 	u16 m = AX_MEDIUM_AC | AX_MEDIUM_RE;
+ 
+ 	m |= duplex ? AX_MEDIUM_FD : 0;
+ 
+ 	switch (speed) {
+ 	case SPEED_100:
+ 		m |= AX_MEDIUM_PS;
+ 		break;
+ 	case SPEED_10:
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	if (tx_pause)
+ 		m |= AX_MEDIUM_TFC;
+ 
+ 	if (rx_pause)
+ 		m |= AX_MEDIUM_RFC;
+ 
+ 	asix_write_medium_mode(dev, m, 0);
+ 	usbnet_link_change(dev, true, false);
+ }
+ 
+ static const struct phylink_mac_ops ax88772_phylink_mac_ops = {
+ 	.mac_config = ax88772_mac_config,
+ 	.mac_link_down = ax88772_mac_link_down,
+ 	.mac_link_up = ax88772_mac_link_up,
+ };
+ 
+ static int ax88772_phylink_setup(struct usbnet *dev)
+ {
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 	phy_interface_t phy_if_mode;
+ 	struct phylink *phylink;
+ 
+ 	priv->phylink_config.dev = &dev->net->dev;
+ 	priv->phylink_config.type = PHYLINK_NETDEV;
+ 	priv->phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE |
+ 		MAC_10 | MAC_100;
+ 
+ 	__set_bit(PHY_INTERFACE_MODE_INTERNAL,
+ 		  priv->phylink_config.supported_interfaces);
+ 	__set_bit(PHY_INTERFACE_MODE_RMII,
+ 		  priv->phylink_config.supported_interfaces);
+ 
+ 	if (priv->embd_phy)
+ 		phy_if_mode = PHY_INTERFACE_MODE_INTERNAL;
+ 	else
+ 		phy_if_mode = PHY_INTERFACE_MODE_RMII;
+ 
+ 	phylink = phylink_create(&priv->phylink_config, dev->net->dev.fwnode,
+ 				 phy_if_mode, &ax88772_phylink_mac_ops);
+ 	if (IS_ERR(phylink))
+ 		return PTR_ERR(phylink);
+ 
+ 	priv->phylink = phylink;
+ 	return 0;
+ }
+ 
++>>>>>>> 8eac0095de35 (net: asix: fix modprobe "sysfs: cannot create duplicate filename")
  static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
  {
 -	struct asix_common_private *priv;
 -	u8 buf[ETH_ALEN] = {0};
  	int ret, i;
 -
 -	priv = devm_kzalloc(&dev->udev->dev, sizeof(*priv), GFP_KERNEL);
 -	if (!priv)
 -		return -ENOMEM;
 -
 -	dev->driver_priv = priv;
 +	u8 buf[ETH_ALEN] = {0}, chipcode = 0;
 +	u32 phyid;
 +	struct asix_common_private *priv;
  
  	usbnet_get_endpoints(dev, intf);
  
@@@ -764,29 -905,50 +926,70 @@@
  		dev->rx_urb_size = 2048;
  	}
  
 +	dev->driver_priv = kzalloc(sizeof(struct asix_common_private), GFP_KERNEL);
 +	if (!dev->driver_priv)
 +		return -ENOMEM;
 +
 +	priv = dev->driver_priv;
 +
  	priv->presvd_phy_bmcr = 0;
  	priv->presvd_phy_advertise = 0;
++<<<<<<< HEAD
 +	if (chipcode == AX_AX88772_CHIPCODE) {
 +		priv->resume = ax88772_resume;
 +		priv->suspend = ax88772_suspend;
 +	} else {
 +		priv->resume = ax88772a_resume;
 +		priv->suspend = ax88772_suspend;
 +	}
++=======
+ 
+ 	ret = ax88772_init_mdio(dev);
+ 	if (ret)
+ 		goto mdio_err;
+ 
+ 	ret = ax88772_phylink_setup(dev);
+ 	if (ret)
+ 		goto phylink_err;
+ 
+ 	ret = ax88772_init_phy(dev);
+ 	if (ret)
+ 		goto initphy_err;
+ 
+ 	return 0;
+ 
+ initphy_err:
+ 	phylink_destroy(priv->phylink);
+ phylink_err:
+ 	ax88772_mdio_unregister(priv);
+ mdio_err:
+ 	return ret;
+ }
+ 
+ static int ax88772_stop(struct usbnet *dev)
+ {
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 
+ 	phylink_stop(priv->phylink);
++>>>>>>> 8eac0095de35 (net: asix: fix modprobe "sysfs: cannot create duplicate filename")
  
  	return 0;
  }
  
  static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
  {
++<<<<<<< HEAD
++=======
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 
+ 	rtnl_lock();
+ 	phylink_disconnect_phy(priv->phylink);
+ 	rtnl_unlock();
+ 	phylink_destroy(priv->phylink);
+ 	ax88772_mdio_unregister(priv);
++>>>>>>> 8eac0095de35 (net: asix: fix modprobe "sysfs: cannot create duplicate filename")
  	asix_rx_fixup_common_free(dev->driver_priv);
 +	kfree(dev->driver_priv);
  }
  
  static void ax88178_unbind(struct usbnet *dev, struct usb_interface *intf)
* Unmerged path drivers/net/usb/asix_devices.c
