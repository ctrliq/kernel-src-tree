gfs2: Fix potential glock use-after-free on unmount

jira LE-1907
cve CVE-2024-38570
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit d98779e687726d8f8860f1c54b5687eec5f63a73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/d98779e6.failed

When a DLM lockspace is released and there ares still locks in that
lockspace, DLM will unlock those locks automatically.  Commit
fb6791d100d1b started exploiting this behavior to speed up filesystem
unmount: gfs2 would simply free glocks it didn't want to unlock and then
release the lockspace.  This didn't take the bast callbacks for
asynchronous lock contention notifications into account, which remain
active until until a lock is unlocked or its lockspace is released.

To prevent those callbacks from accessing deallocated objects, put the
glocks that should not be unlocked on the sd_dead_glocks list, release
the lockspace, and only then free those glocks.

As an additional measure, ignore unexpected ast and bast callbacks if
the receiving glock is dead.

Fixes: fb6791d100d1b ("GFS2: skip dlm_unlock calls in unmount")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Cc: David Teigland <teigland@redhat.com>
(cherry picked from commit d98779e687726d8f8860f1c54b5687eec5f63a73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
#	fs/gfs2/glock.h
diff --cc fs/gfs2/glock.c
index 36a5c4894db1,4cf8971ce8ee..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -164,11 -166,8 +164,14 @@@ static bool glock_blocked_by_withdraw(s
  	return true;
  }
  
- void gfs2_glock_free(struct gfs2_glock *gl)
+ static void __gfs2_glock_free(struct gfs2_glock *gl)
  {
++<<<<<<< HEAD
 +	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 +
 +	BUG_ON(atomic_read(&gl->gl_revokes));
++=======
++>>>>>>> d98779e68772 (gfs2: Fix potential glock use-after-free on unmount)
  	rhashtable_remove_fast(&gl_hash_table, &gl->gl_node, ht_parms);
  	smp_mb();
  	wake_up_glock(gl);
diff --cc fs/gfs2/glock.h
index 841fba9c09db,19aef6d53267..000000000000
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@@ -252,27 -242,28 +252,41 @@@ static inline int gfs2_glock_nq_init(st
  	return error;
  }
  
++<<<<<<< HEAD
 +extern void gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state);
 +extern void gfs2_glock_complete(struct gfs2_glock *gl, int ret);
 +extern bool gfs2_queue_try_to_evict(struct gfs2_glock *gl);
 +extern void gfs2_cancel_delete_work(struct gfs2_glock *gl);
 +extern void gfs2_flush_delete_work(struct gfs2_sbd *sdp);
 +extern void gfs2_gl_hash_clear(struct gfs2_sbd *sdp);
 +extern void gfs2_gl_dq_holders(struct gfs2_sbd *sdp);
 +extern void gfs2_glock_thaw(struct gfs2_sbd *sdp);
 +extern void gfs2_glock_add_to_lru(struct gfs2_glock *gl);
 +extern void gfs2_glock_free(struct gfs2_glock *gl);
++=======
+ void gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state);
+ void gfs2_glock_complete(struct gfs2_glock *gl, int ret);
+ bool gfs2_queue_try_to_evict(struct gfs2_glock *gl);
+ void gfs2_cancel_delete_work(struct gfs2_glock *gl);
+ void gfs2_flush_delete_work(struct gfs2_sbd *sdp);
+ void gfs2_gl_hash_clear(struct gfs2_sbd *sdp);
+ void gfs2_gl_dq_holders(struct gfs2_sbd *sdp);
+ void gfs2_glock_thaw(struct gfs2_sbd *sdp);
+ void gfs2_glock_add_to_lru(struct gfs2_glock *gl);
+ void gfs2_glock_free(struct gfs2_glock *gl);
+ void gfs2_glock_free_later(struct gfs2_glock *gl);
++>>>>>>> d98779e68772 (gfs2: Fix potential glock use-after-free on unmount)
  
 -int __init gfs2_glock_init(void);
 -void gfs2_glock_exit(void);
 +extern int __init gfs2_glock_init(void);
 +extern void gfs2_glock_exit(void);
  
 -void gfs2_create_debugfs_file(struct gfs2_sbd *sdp);
 -void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp);
 -void gfs2_register_debugfs(void);
 -void gfs2_unregister_debugfs(void);
 +extern void gfs2_create_debugfs_file(struct gfs2_sbd *sdp);
 +extern void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp);
 +extern void gfs2_register_debugfs(void);
 +extern void gfs2_unregister_debugfs(void);
  
 -void glock_set_object(struct gfs2_glock *gl, void *object);
 -void glock_clear_object(struct gfs2_glock *gl, void *object);
 +extern void glock_set_object(struct gfs2_glock *gl, void *object);
 +extern void glock_clear_object(struct gfs2_glock *gl, void *object);
  
  extern const struct lm_lockops gfs2_dlm_ops;
  
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/glock.h
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5425cd90b005..68cd3fe4a8ba 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -841,6 +841,7 @@ struct gfs2_sbd {
 	/* For quiescing the filesystem */
 	struct gfs2_holder sd_freeze_gh;
 	struct mutex sd_freeze_mutex;
+	struct list_head sd_dead_glocks;
 
 	char sd_fsname[GFS2_FSNAME_LEN + 3 * sizeof(int) + 2];
 	char sd_table_name[GFS2_FSNAME_LEN];
diff --git a/fs/gfs2/lock_dlm.c b/fs/gfs2/lock_dlm.c
index cbdd7ec76b7c..7785e534ad18 100644
--- a/fs/gfs2/lock_dlm.c
+++ b/fs/gfs2/lock_dlm.c
@@ -121,6 +121,11 @@ static void gdlm_ast(void *arg)
 	struct gfs2_glock *gl = arg;
 	unsigned ret = gl->gl_state;
 
+	/* If the glock is dead, we only react to a dlm_unlock() reply. */
+	if (__lockref_is_dead(&gl->gl_lockref) &&
+	    gl->gl_lksb.sb_status != -DLM_EUNLOCK)
+		return;
+
 	gfs2_update_reply_times(gl);
 	BUG_ON(gl->gl_lksb.sb_flags & DLM_SBF_DEMOTED);
 
@@ -171,6 +176,9 @@ static void gdlm_bast(void *arg, int mode)
 {
 	struct gfs2_glock *gl = arg;
 
+	if (__lockref_is_dead(&gl->gl_lockref))
+		return;
+
 	switch (mode) {
 	case DLM_LOCK_EX:
 		gfs2_glock_cb(gl, LM_ST_UNLOCKED);
@@ -296,8 +304,12 @@ static void gdlm_put_lock(struct gfs2_glock *gl)
 	struct lm_lockstruct *ls = &sdp->sd_lockstruct;
 	int error;
 
-	if (gl->gl_lksb.sb_lkid == 0)
-		goto out_free;
+	BUG_ON(!__lockref_is_dead(&gl->gl_lockref));
+
+	if (gl->gl_lksb.sb_lkid == 0) {
+		gfs2_glock_free(gl);
+		return;
+	}
 
 	clear_bit(GLF_BLOCKING, &gl->gl_flags);
 	gfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);
@@ -305,13 +317,17 @@ static void gdlm_put_lock(struct gfs2_glock *gl)
 	gfs2_update_request_times(gl);
 
 	/* don't want to call dlm if we've unmounted the lock protocol */
-	if (test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))
-		goto out_free;
+	if (test_bit(DFL_UNMOUNT, &ls->ls_recover_flags)) {
+		gfs2_glock_free(gl);
+		return;
+	}
 	/* don't want to skip dlm_unlock writing the lvb when lock has one */
 
 	if (test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags) &&
-	    !gl->gl_lksb.sb_lvbptr)
-		goto out_free;
+	    !gl->gl_lksb.sb_lvbptr) {
+		gfs2_glock_free_later(gl);
+		return;
+	}
 
 again:
 	error = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,
@@ -326,10 +342,6 @@ static void gdlm_put_lock(struct gfs2_glock *gl)
 		       gl->gl_name.ln_type,
 		       (unsigned long long)gl->gl_name.ln_number, error);
 	}
-	return;
-
-out_free:
-	gfs2_glock_free(gl);
 }
 
 static void gdlm_cancel(struct gfs2_glock *gl)
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index 4e43ec3b894a..2eac09a289a6 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -137,6 +137,7 @@ static struct gfs2_sbd *init_sbd(struct super_block *sb)
 	atomic_set(&sdp->sd_log_in_flight, 0);
 	init_waitqueue_head(&sdp->sd_log_flush_wait);
 	mutex_init(&sdp->sd_freeze_mutex);
+	INIT_LIST_HEAD(&sdp->sd_dead_glocks);
 
 	return sdp;
 
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 46e65aff748e..512ea3c70e8a 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -668,10 +668,7 @@ static void gfs2_put_super(struct super_block *sb)
 	gfs2_gl_hash_clear(sdp);
 	truncate_inode_pages_final(&sdp->sd_aspace);
 	gfs2_delete_debugfs_file(sdp);
-	/*  Unmount the locking protocol  */
-	gfs2_lm_unmount(sdp);
 
-	/*  At this point, we're through participating in the lockspace  */
 	gfs2_sys_fs_del(sdp);
 	free_sbd(sdp);
 }
