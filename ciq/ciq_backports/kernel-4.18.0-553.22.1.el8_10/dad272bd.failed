media: cec: add xfer_timeout_ms field

jira LE-1907
cve CVE-2024-23848
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Hans Verkuil <hverkuil-cisco@xs4all.nl>
commit dad272bd03d541dc7c0ff8331756eccf659f6f02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/dad272bd.failed

Allow drivers to change the transmit timeout value, i.e. after how
long should a transmit be considered 'lost', i.e. the corresponding
cec_transmit_done_ts was never called.

Some CEC devices have their own timeout, and so this timeout value must be
longer than that hardware timeout value. If it is shorter then the
framework would consider the transmit lost, even though it is effectively
still in progress at the hardware level.

	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
(cherry picked from commit dad272bd03d541dc7c0ff8331756eccf659f6f02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/cec/core/cec-adap.c
#	include/media/cec.h
diff --cc drivers/media/cec/core/cec-adap.c
index e0e9d4808c3d,2425cb4c6a9a..000000000000
--- a/drivers/media/cec/core/cec-adap.c
+++ b/drivers/media/cec/core/cec-adap.c
@@@ -27,27 -27,6 +27,30 @@@ static void cec_fill_msg_report_feature
  					 struct cec_msg *msg,
  					 unsigned int la_idx);
  
++<<<<<<< HEAD
 +/*
 + * 400 ms is the time it takes for one 16 byte message to be
 + * transferred and 5 is the maximum number of retries. Add
 + * another 100 ms as a margin. So if the transmit doesn't
 + * finish before that time something is really wrong and we
 + * have to time out.
 + *
 + * This is a sign that something it really wrong and a warning
 + * will be issued.
 + */
 +#define CEC_XFER_TIMEOUT_MS (5 * 400 + 100)
 +
 +#define call_op(adap, op, arg...) \
 +	(adap->ops->op ? adap->ops->op(adap, ## arg) : 0)
 +
 +#define call_void_op(adap, op, arg...)			\
 +	do {						\
 +		if (adap->ops->op)			\
 +			adap->ops->op(adap, ## arg);	\
 +	} while (0)
 +
++=======
++>>>>>>> dad272bd03d5 (media: cec: add xfer_timeout_ms field)
  static int cec_log_addr2idx(const struct cec_adapter *adap, u8 log_addr)
  {
  	int i;
diff --cc include/media/cec.h
index 03e01c17f6ec,80340c9eb0f2..000000000000
--- a/include/media/cec.h
+++ b/include/media/cec.h
@@@ -156,6 -163,13 +156,16 @@@ struct cec_adap_ops 
   * @wait_queue:		queue of transmits waiting for a reply
   * @transmitting:	CEC messages currently being transmitted
   * @transmit_in_progress: true if a transmit is in progress
++<<<<<<< HEAD
++=======
+  * @transmit_in_progress_aborted: true if a transmit is in progress is to be
+  *			aborted. This happens if the logical address is
+  *			invalidated while the transmit is ongoing. In that
+  *			case the transmit will finish, but will not retransmit
+  *			and be marked as ABORTED.
+  * @xfer_timeout_ms:	the transfer timeout in ms.
+  *			If 0, then timeout after 2.1 ms.
++>>>>>>> dad272bd03d5 (media: cec: add xfer_timeout_ms field)
   * @kthread_config:	kthread used to configure a CEC adapter
   * @config_completion:	used to signal completion of the config kthread
   * @kthread:		main CEC processing thread
@@@ -205,6 -225,8 +215,11 @@@ struct cec_adapter 
  	struct list_head wait_queue;
  	struct cec_data *transmitting;
  	bool transmit_in_progress;
++<<<<<<< HEAD
++=======
+ 	bool transmit_in_progress_aborted;
+ 	unsigned int xfer_timeout_ms;
++>>>>>>> dad272bd03d5 (media: cec: add xfer_timeout_ms field)
  
  	struct task_struct *kthread_config;
  	struct completion config_completion;
* Unmerged path drivers/media/cec/core/cec-adap.c
diff --git a/drivers/media/cec/core/cec-core.c b/drivers/media/cec/core/cec-core.c
index e24aacf6b54d..a852fb33af5f 100644
--- a/drivers/media/cec/core/cec-core.c
+++ b/drivers/media/cec/core/cec-core.c
@@ -20,6 +20,18 @@
 #define CEC_NUM_DEVICES	256
 #define CEC_NAME	"cec"
 
+/*
+ * 400 ms is the time it takes for one 16 byte message to be
+ * transferred and 5 is the maximum number of retries. Add
+ * another 100 ms as a margin. So if the transmit doesn't
+ * finish before that time something is really wrong and we
+ * have to time out.
+ *
+ * This is a sign that something it really wrong and a warning
+ * will be issued.
+ */
+#define CEC_XFER_TIMEOUT_MS (5 * 400 + 100)
+
 int cec_debug;
 module_param_named(debug, cec_debug, int, 0644);
 MODULE_PARM_DESC(debug, "debug level (0-2)");
@@ -346,6 +358,8 @@ int cec_register_adapter(struct cec_adapter *adap,
 
 	adap->owner = parent->driver->owner;
 	adap->devnode.dev.parent = parent;
+	if (!adap->xfer_timeout_ms)
+		adap->xfer_timeout_ms = CEC_XFER_TIMEOUT_MS;
 
 #ifdef CONFIG_MEDIA_CEC_RC
 	if (adap->capabilities & CEC_CAP_RC) {
* Unmerged path include/media/cec.h
