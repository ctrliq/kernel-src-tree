KVM: selftests: Run clocksource dependent tests with hyperv_clocksource_tsc_page too

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 09951bf2cbb3a7893f76d1364b0ae6e3007ff1de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/09951bf2.failed

KVM's 'gtod_is_based_on_tsc()' recognizes two clocksources: 'tsc' and
'hyperv_clocksource_tsc_page' and enables kvmclock in 'masterclock'
mode when either is in use. Transform 'sys_clocksource_is_tsc()' into
'sys_clocksource_is_based_on_tsc()' to support the later. This affects
two tests: kvm_clock_test and vmx_nested_tsc_scaling_test, both seem
to work well when system clocksource is 'hyperv_clocksource_tsc_page'.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Link: https://lore.kernel.org/r/20240109141121.1619463-4-vkuznets@redhat.com
	Signed-off-by: Sean Christopherson <seanjc@google.com>
(cherry picked from commit 09951bf2cbb3a7893f76d1364b0ae6e3007ff1de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/include/x86_64/processor.h
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
#	tools/testing/selftests/kvm/x86_64/kvm_clock_test.c
#	tools/testing/selftests/kvm/x86_64/vmx_nested_tsc_scaling_test.c
diff --cc tools/testing/selftests/kvm/include/x86_64/processor.h
index d0d51adec76e,5bca8c947c82..000000000000
--- a/tools/testing/selftests/kvm/include/x86_64/processor.h
+++ b/tools/testing/selftests/kvm/include/x86_64/processor.h
@@@ -505,14 -1249,28 +505,29 @@@ void __virt_pg_map(struct kvm_vm *vm, u
  #define X86_CR0_CD          (1UL<<30) /* Cache Disable */
  #define X86_CR0_PG          (1UL<<31) /* Paging */
  
 -#define PFERR_PRESENT_BIT 0
 -#define PFERR_WRITE_BIT 1
 -#define PFERR_USER_BIT 2
 -#define PFERR_RSVD_BIT 3
 -#define PFERR_FETCH_BIT 4
 -#define PFERR_PK_BIT 5
 -#define PFERR_SGX_BIT 15
 -#define PFERR_GUEST_FINAL_BIT 32
 -#define PFERR_GUEST_PAGE_BIT 33
 -#define PFERR_IMPLICIT_ACCESS_BIT 48
 +/* VMX_EPT_VPID_CAP bits */
 +#define VMX_EPT_VPID_CAP_AD_BITS       (1ULL << 21)
  
++<<<<<<< HEAD
 +#define XSTATE_XTILE_CFG_BIT		17
 +#define XSTATE_XTILE_DATA_BIT		18
++=======
+ #define PFERR_PRESENT_MASK	BIT(PFERR_PRESENT_BIT)
+ #define PFERR_WRITE_MASK	BIT(PFERR_WRITE_BIT)
+ #define PFERR_USER_MASK		BIT(PFERR_USER_BIT)
+ #define PFERR_RSVD_MASK		BIT(PFERR_RSVD_BIT)
+ #define PFERR_FETCH_MASK	BIT(PFERR_FETCH_BIT)
+ #define PFERR_PK_MASK		BIT(PFERR_PK_BIT)
+ #define PFERR_SGX_MASK		BIT(PFERR_SGX_BIT)
+ #define PFERR_GUEST_FINAL_MASK	BIT_ULL(PFERR_GUEST_FINAL_BIT)
+ #define PFERR_GUEST_PAGE_MASK	BIT_ULL(PFERR_GUEST_PAGE_BIT)
+ #define PFERR_IMPLICIT_ACCESS	BIT_ULL(PFERR_IMPLICIT_ACCESS_BIT)
+ 
+ bool sys_clocksource_is_based_on_tsc(void);
++>>>>>>> 09951bf2cbb3 (KVM: selftests: Run clocksource dependent tests with hyperv_clocksource_tsc_page too)
  
 +#define XSTATE_XTILE_CFG_MASK		(1ULL << XSTATE_XTILE_CFG_BIT)
 +#define XSTATE_XTILE_DATA_MASK		(1ULL << XSTATE_XTILE_DATA_BIT)
 +#define XFEATURE_XTILE_MASK		(XSTATE_XTILE_CFG_MASK | \
 +					XSTATE_XTILE_DATA_MASK)
  #endif /* SELFTEST_KVM_PROCESSOR_H */
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index eb5e20676bc0,f639b3e062e3..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -1543,3 -1283,30 +1543,33 @@@ unsigned long vm_compute_max_gfn(struc
  done:
  	return min(max_gfn, ht_gfn - 1);
  }
++<<<<<<< HEAD
++=======
+ 
+ /* Returns true if kvm_intel was loaded with unrestricted_guest=1. */
+ bool vm_is_unrestricted_guest(struct kvm_vm *vm)
+ {
+ 	/* Ensure that a KVM vendor-specific module is loaded. */
+ 	if (vm == NULL)
+ 		close(open_kvm_dev_path_or_exit());
+ 
+ 	return get_kvm_intel_param_bool("unrestricted_guest");
+ }
+ 
+ void kvm_selftest_arch_init(void)
+ {
+ 	host_cpu_is_intel = this_cpu_is_intel();
+ 	host_cpu_is_amd = this_cpu_is_amd();
+ }
+ 
+ bool sys_clocksource_is_based_on_tsc(void)
+ {
+ 	char *clk_name = sys_get_cur_clocksource();
+ 	bool ret = !strcmp(clk_name, "tsc\n") ||
+ 		   !strcmp(clk_name, "hyperv_clocksource_tsc_page\n");
+ 
+ 	free(clk_name);
+ 
+ 	return ret;
+ }
++>>>>>>> 09951bf2cbb3 (KVM: selftests: Run clocksource dependent tests with hyperv_clocksource_tsc_page too)
diff --cc tools/testing/selftests/kvm/x86_64/kvm_clock_test.c
index 97731454f3f3,5bc12222d87a..000000000000
--- a/tools/testing/selftests/kvm/x86_64/kvm_clock_test.c
+++ b/tools/testing/selftests/kvm/x86_64/kvm_clock_test.c
@@@ -184,15 -141,11 +184,19 @@@ int main(void
  	int flags;
  
  	flags = kvm_check_cap(KVM_CAP_ADJUST_CLOCK);
 -	TEST_REQUIRE(flags & KVM_CLOCK_REALTIME);
 +	if (!(flags & KVM_CLOCK_REALTIME)) {
 +		print_skip("KVM_CLOCK_REALTIME not supported; flags: %x",
 +			   flags);
 +		exit(KSFT_SKIP);
 +	}
  
++<<<<<<< HEAD
 +	check_clocksource();
++=======
+ 	TEST_REQUIRE(sys_clocksource_is_based_on_tsc());
++>>>>>>> 09951bf2cbb3 (KVM: selftests: Run clocksource dependent tests with hyperv_clocksource_tsc_page too)
  
 -	vm = vm_create_with_one_vcpu(&vcpu, guest_main);
 +	vm = vm_create_default(VCPU_ID, 0, guest_main);
  
  	pvti_gva = vm_vaddr_alloc(vm, getpagesize(), 0x10000);
  	pvti_gpa = addr_gva2gpa(vm, pvti_gva);
diff --cc tools/testing/selftests/kvm/x86_64/vmx_nested_tsc_scaling_test.c
index 280c01fd2412,1759fa5cb3f2..000000000000
--- a/tools/testing/selftests/kvm/x86_64/vmx_nested_tsc_scaling_test.c
+++ b/tools/testing/selftests/kvm/x86_64/vmx_nested_tsc_scaling_test.c
@@@ -160,9 -129,9 +160,15 @@@ int main(int argc, char *argv[]
  	uint64_t l1_tsc_freq = 0;
  	uint64_t l2_tsc_freq = 0;
  
++<<<<<<< HEAD
 +	nested_vmx_check_supported();
 +	tsc_scaling_check_supported();
 +	stable_tsc_check_supported();
++=======
+ 	TEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));
+ 	TEST_REQUIRE(kvm_has_cap(KVM_CAP_TSC_CONTROL));
+ 	TEST_REQUIRE(sys_clocksource_is_based_on_tsc());
++>>>>>>> 09951bf2cbb3 (KVM: selftests: Run clocksource dependent tests with hyperv_clocksource_tsc_page too)
  
  	/*
  	 * We set L1's scale factor to be a random number from 2 to 10.
* Unmerged path tools/testing/selftests/kvm/include/x86_64/processor.h
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
* Unmerged path tools/testing/selftests/kvm/x86_64/kvm_clock_test.c
* Unmerged path tools/testing/selftests/kvm/x86_64/vmx_nested_tsc_scaling_test.c
