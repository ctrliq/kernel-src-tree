x86/bhi: Avoid warning in #DB handler due to BHI mitigation

jira LE-1907
cve CVE-2024-42240
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Alexandre Chartre <alexandre.chartre@oracle.com>
commit ac8b270b61d48fcc61f052097777e3b5e11591e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/ac8b270b.failed

When BHI mitigation is enabled, if SYSENTER is invoked with the TF flag set
then entry_SYSENTER_compat() uses CLEAR_BRANCH_HISTORY and calls the
clear_bhb_loop() before the TF flag is cleared. This causes the #DB handler
(exc_debug_kernel()) to issue a warning because single-step is used outside the
entry_SYSENTER_compat() function.

To address this issue, entry_SYSENTER_compat() should use CLEAR_BRANCH_HISTORY
after making sure the TF flag is cleared.

The problem can be reproduced with the following sequence:

  $ cat sysenter_step.c
  int main()
  { asm("pushf; pop %ax; bts $8,%ax; push %ax; popf; sysenter"); }

  $ gcc -o sysenter_step sysenter_step.c

  $ ./sysenter_step
  Segmentation fault (core dumped)

The program is expected to crash, and the #DB handler will issue a warning.

Kernel log:

  WARNING: CPU: 27 PID: 7000 at arch/x86/kernel/traps.c:1009 exc_debug_kernel+0xd2/0x160
  ...
  RIP: 0010:exc_debug_kernel+0xd2/0x160
  ...
  Call Trace:
  <#DB>
   ? show_regs+0x68/0x80
   ? __warn+0x8c/0x140
   ? exc_debug_kernel+0xd2/0x160
   ? report_bug+0x175/0x1a0
   ? handle_bug+0x44/0x90
   ? exc_invalid_op+0x1c/0x70
   ? asm_exc_invalid_op+0x1f/0x30
   ? exc_debug_kernel+0xd2/0x160
   exc_debug+0x43/0x50
   asm_exc_debug+0x1e/0x40
  RIP: 0010:clear_bhb_loop+0x0/0xb0
  ...
  </#DB>
  <TASK>
   ? entry_SYSENTER_compat_after_hwframe+0x6e/0x8d
  </TASK>

  [ bp: Massage commit message. ]

Fixes: 7390db8aea0d ("x86/bhi: Add support for clearing branch history at syscall entry")
	Reported-by: Suman Maity <suman.m.maity@oracle.com>
	Signed-off-by: Alexandre Chartre <alexandre.chartre@oracle.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
	Reviewed-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
Link: https://lore.kernel.org/r/20240524070459.3674025-1-alexandre.chartre@oracle.com
(cherry picked from commit ac8b270b61d48fcc61f052097777e3b5e11591e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64_compat.S
diff --cc arch/x86/entry/entry_64_compat.S
index 0b73bc26a2bb,ed0a5f2dc129..000000000000
--- a/arch/x86/entry/entry_64_compat.S
+++ b/arch/x86/entry/entry_64_compat.S
@@@ -66,52 -83,12 +66,48 @@@ SYM_FUNC_START(entry_SYSENTER_compat
  	 */
  	movl	%eax, %eax
  
 -	pushq	%rax			/* pt_regs->orig_ax */
 -	PUSH_AND_CLEAR_REGS rax=$-ENOSYS
 -	UNWIND_HINT_REGS
 +	/* Construct struct pt_regs on stack */
 +	pushq	$__USER32_DS		/* pt_regs->ss */
 +	pushq	%rbp			/* pt_regs->sp (stashed in bp) */
  
 +	/*
 +	 * Push flags.  This is nasty.  First, interrupts are currently
 +	 * off, but we need pt_regs->flags to have IF set.  Second, even
 +	 * if TF was set when SYSENTER started, it's clear by now.  We fix
 +	 * that later using TIF_SINGLESTEP.
 +	 */
 +	pushfq				/* pt_regs->flags (except IF = 0) */
 +	orl	$X86_EFLAGS_IF, (%rsp)	/* Fix saved flags */
 +	pushq	$__USER32_CS		/* pt_regs->cs */
 +	pushq	$0			/* pt_regs->ip = 0 (placeholder) */
 +	pushq	%rax			/* pt_regs->orig_ax */
 +	pushq	%rdi			/* pt_regs->di */
 +	pushq	%rsi			/* pt_regs->si */
 +	pushq	%rdx			/* pt_regs->dx */
 +	pushq	%rcx			/* pt_regs->cx */
 +	pushq	$-ENOSYS		/* pt_regs->ax */
 +	pushq   $0			/* pt_regs->r8  = 0 */
 +	xorl	%r8d, %r8d		/* nospec   r8 */
 +	pushq   $0			/* pt_regs->r9  = 0 */
 +	xorl	%r9d, %r9d		/* nospec   r9 */
 +	pushq   $0			/* pt_regs->r10 = 0 */
 +	xorl	%r10d, %r10d		/* nospec   r10 */
 +	pushq   $0			/* pt_regs->r11 = 0 */
 +	xorl	%r11d, %r11d		/* nospec   r11 */
 +	pushq   %rbx                    /* pt_regs->rbx */
 +	xorl	%ebx, %ebx		/* nospec   rbx */
 +	pushq   %rbp                    /* pt_regs->rbp (will be overwritten) */
 +	xorl	%ebp, %ebp		/* nospec   rbp */
 +	pushq   $0			/* pt_regs->r12 = 0 */
 +	xorl	%r12d, %r12d		/* nospec   r12 */
 +	pushq   $0			/* pt_regs->r13 = 0 */
 +	xorl	%r13d, %r13d		/* nospec   r13 */
 +	pushq   $0			/* pt_regs->r14 = 0 */
 +	xorl	%r14d, %r14d		/* nospec   r14 */
 +	pushq   $0			/* pt_regs->r15 = 0 */
 +	xorl	%r15d, %r15d		/* nospec   r15 */
  	cld
  
- 	IBRS_ENTER
- 	UNTRAIN_RET
- 	CLEAR_BRANCH_HISTORY
- 
  	/*
  	 * SYSENTER doesn't filter flags, so we need to clear NT and AC
  	 * ourselves.  To save a few cycles, we can check whether
@@@ -136,16 -113,17 +132,27 @@@
  .Lsysenter_flags_fixed:
  
  	/*
++<<<<<<< HEAD
 +	 * User mode is traced as though IRQs are on, and SYSENTER
 +	 * turned them off.
 +	 */
 +	TRACE_IRQS_OFF
++=======
+ 	 * CPU bugs mitigations mechanisms can call other functions. They
+ 	 * should be invoked after making sure TF is cleared because
+ 	 * single-step is ignored only for instructions inside the
+ 	 * entry_SYSENTER_compat function.
+ 	 */
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
+ 	CLEAR_BRANCH_HISTORY
++>>>>>>> ac8b270b61d4 (x86/bhi: Avoid warning in #DB handler due to BHI mitigation)
  
  	movq	%rsp, %rdi
 -	call	do_SYSENTER_32
 +	call	do_fast_syscall_32
 +	/* XEN PV guests always use IRET path */
 +	ALTERNATIVE "testl %eax, %eax; jz .Lsyscall_32_done", \
 +		    "jmp .Lsyscall_32_done", X86_FEATURE_XENPV
  	jmp	sysret32_from_system_call
  
  .Lsysenter_fix_flags:
* Unmerged path arch/x86/entry/entry_64_compat.S
