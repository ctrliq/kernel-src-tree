media: Use fallthrough pseudo-keyword

jira LE-1907
cve CVE-2024-23848
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Gustavo A. R. Silva <gustavoars@kernel.org>
commit 1771e9fb67e2d6df29acb0ee8349c3833a212754
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/1771e9fb.failed

Replace the existing /* fall through */ comments and its variants with
the new pseudo-keyword macro fallthrough[1]. Also, remove unnecessary
fall-through markings when it is the case.

[1] https://www.kernel.org/doc/html/v5.7/process/deprecated.html?highlight=fallthrough#implicit-switch-case-fall-through

	Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
	Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
(cherry picked from commit 1771e9fb67e2d6df29acb0ee8349c3833a212754)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/dvb-frontends/m88ds3103.c
#	drivers/media/i2c/adv7180.c
#	drivers/media/i2c/ov5640.c
#	drivers/media/i2c/smiapp/smiapp-core.c
#	drivers/media/platform/coda/coda-common.c
#	drivers/media/platform/qcom/venus/vdec.c
#	drivers/media/test-drivers/vicodec/vicodec-core.c
#	drivers/media/usb/dvb-usb-v2/gl861.c
#	drivers/media/usb/pulse8-cec/pulse8-cec.c
#	drivers/media/usb/uvc/uvc_video.c
diff --cc drivers/media/dvb-frontends/m88ds3103.c
index c411df2461dc,ad6d9d564a87..000000000000
--- a/drivers/media/dvb-frontends/m88ds3103.c
+++ b/drivers/media/dvb-frontends/m88ds3103.c
@@@ -526,6 -900,13 +526,16 @@@ static int m88ds3103_set_frontend(struc
  		u8tmp1 = 0x3f;
  		u8tmp2 = 0x3f;
  		break;
++<<<<<<< HEAD
++=======
+ 	case M88DS3103_TS_PARALLEL:
+ 		if (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {
+ 			ret = m88ds3103_update_bits(dev, 0x29, 0x01, u8tmp1);
+ 			if (ret)
+ 				goto err;
+ 		}
+ 		fallthrough;
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  	default:
  		u16tmp = DIV_ROUND_UP(target_mclk, dev->cfg->ts_clk);
  		u8tmp1 = u16tmp / 2 - 1;
diff --cc drivers/media/i2c/adv7180.c
index 25d24a3f10a7,4498d14d3429..000000000000
--- a/drivers/media/i2c/adv7180.c
+++ b/drivers/media/i2c/adv7180.c
@@@ -711,11 -724,11 +711,17 @@@ static int adv7180_set_pad_format(struc
  
  	switch (format->format.field) {
  	case V4L2_FIELD_NONE:
++<<<<<<< HEAD
 +		if (!(state->chip_info->flags & ADV7180_FLAG_I2P))
 +			format->format.field = V4L2_FIELD_INTERLACED;
 +		break;
++=======
+ 		if (state->chip_info->flags & ADV7180_FLAG_I2P)
+ 			break;
+ 		fallthrough;
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  	default:
 -		format->format.field = V4L2_FIELD_ALTERNATE;
 +		format->format.field = V4L2_FIELD_INTERLACED;
  		break;
  	}
  
diff --cc drivers/media/i2c/ov5640.c
index f6e40cc9745c,ccdabc7948a7..000000000000
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@@ -2583,6 -3003,22 +2583,25 @@@ static int ov5640_probe(struct i2c_clie
  
  	sensor->ae_target = 52;
  
++<<<<<<< HEAD
++=======
+ 	/* optional indication of physical rotation of sensor */
+ 	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+ 				       &rotation);
+ 	if (!ret) {
+ 		switch (rotation) {
+ 		case 180:
+ 			sensor->upside_down = true;
+ 			fallthrough;
+ 		case 0:
+ 			break;
+ 		default:
+ 			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+ 				 rotation);
+ 		}
+ 	}
+ 
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
  						  NULL);
  	if (!endpoint) {
diff --cc drivers/media/i2c/smiapp/smiapp-core.c
index e1f8208581aa,6fc0680a93d0..000000000000
--- a/drivers/media/i2c/smiapp/smiapp-core.c
+++ b/drivers/media/i2c/smiapp/smiapp-core.c
@@@ -2122,10 -2117,10 +2122,10 @@@ static int __smiapp_sel_supported(struc
  		if (ssd == sensor->binner)
  			return 0;
  		if (ssd == sensor->scaler
 -		    && SMIA_LIM(sensor, SCALING_CAPABILITY)
 +		    && sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]
  		    != SMIAPP_SCALING_CAPABILITY_NONE)
  			return 0;
- 		/* Fall through */
+ 		fallthrough;
  	default:
  		return -EINVAL;
  	}
@@@ -2800,8 -2789,20 +2800,25 @@@ static struct smiapp_hwconfig *smiapp_g
  
  	dev_dbg(dev, "lanes %u\n", hwcfg->lanes);
  
++<<<<<<< HEAD
 +	/* NVM size is not mandatory */
 +	fwnode_property_read_u32(fwnode, "nokia,nvm-size", &hwcfg->nvm_size);
++=======
+ 	rval = fwnode_property_read_u32(fwnode, "rotation", &rotation);
+ 	if (!rval) {
+ 		switch (rotation) {
+ 		case 180:
+ 			hwcfg->module_board_orient =
+ 				SMIAPP_MODULE_BOARD_ORIENT_180;
+ 			fallthrough;
+ 		case 0:
+ 			break;
+ 		default:
+ 			dev_err(dev, "invalid rotation %u\n", rotation);
+ 			goto out_err;
+ 		}
+ 	}
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  
  	rval = fwnode_property_read_u32(dev_fwnode(dev), "clock-frequency",
  					&hwcfg->ext_clk);
diff --cc drivers/media/platform/coda/coda-common.c
index d45220f4989a,823a4d7578d6..000000000000
--- a/drivers/media/platform/coda/coda-common.c
+++ b/drivers/media/platform/coda/coda-common.c
@@@ -733,9 -808,10 +733,9 @@@ static int coda_s_fmt(struct coda_ctx *
  			ctx->tiled_map_type = GDI_TILED_FRAME_MB_RASTER_MAP;
  			break;
  		}
- 		/* else fall through */
+ 		fallthrough;
  	case V4L2_PIX_FMT_YUV420:
  	case V4L2_PIX_FMT_YVU420:
 -	case V4L2_PIX_FMT_YUV422P:
  		ctx->tiled_map_type = GDI_LINEAR_FRAME_MAP;
  		break;
  	default:
@@@ -912,18 -1015,20 +912,18 @@@ static int coda_g_selection(struct fil
  	case V4L2_SEL_TGT_CROP_DEFAULT:
  	case V4L2_SEL_TGT_CROP_BOUNDS:
  		rsel = &r;
- 		/* fallthrough */
+ 		fallthrough;
  	case V4L2_SEL_TGT_CROP:
 -		if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||
 -		    ctx->inst_type == CODA_INST_DECODER)
 +		if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
  			return -EINVAL;
  		break;
  	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
  	case V4L2_SEL_TGT_COMPOSE_PADDED:
  		rsel = &r;
- 		/* fallthrough */
+ 		fallthrough;
  	case V4L2_SEL_TGT_COMPOSE:
  	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
 -		if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
 -		    ctx->inst_type == CODA_INST_ENCODER)
 +		if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
  			return -EINVAL;
  		break;
  	default:
@@@ -935,6 -1040,50 +935,53 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int coda_s_selection(struct file *file, void *fh,
+ 			    struct v4l2_selection *s)
+ {
+ 	struct coda_ctx *ctx = fh_to_ctx(fh);
+ 	struct coda_q_data *q_data;
+ 
+ 	switch (s->target) {
+ 	case V4L2_SEL_TGT_CROP:
+ 		if (ctx->inst_type == CODA_INST_ENCODER &&
+ 		    s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+ 			q_data = get_q_data(ctx, s->type);
+ 			if (!q_data)
+ 				return -EINVAL;
+ 
+ 			s->r.left = 0;
+ 			s->r.top = 0;
+ 			s->r.width = clamp(s->r.width, 2U, q_data->width);
+ 			s->r.height = clamp(s->r.height, 2U, q_data->height);
+ 
+ 			if (s->flags & V4L2_SEL_FLAG_LE) {
+ 				s->r.width = round_up(s->r.width, 2);
+ 				s->r.height = round_up(s->r.height, 2);
+ 			} else {
+ 				s->r.width = round_down(s->r.width, 2);
+ 				s->r.height = round_down(s->r.height, 2);
+ 			}
+ 
+ 			q_data->rect = s->r;
+ 
+ 			coda_dbg(1, ctx, "Setting crop rectangle: %dx%d\n",
+ 				 s->r.width, s->r.height);
+ 
+ 			return 0;
+ 		}
+ 		fallthrough;
+ 	case V4L2_SEL_TGT_NATIVE_SIZE:
+ 	case V4L2_SEL_TGT_COMPOSE:
+ 		return coda_g_selection(file, fh, s);
+ 	default:
+ 		/* v4l2-compliance expects this to fail for read-only targets */
+ 		return -EINVAL;
+ 	}
+ }
+ 
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  static int coda_try_encoder_cmd(struct file *file, void *fh,
  				struct v4l2_encoder_cmd *ec)
  {
diff --cc drivers/media/platform/qcom/venus/vdec.c
index 500901b52976,a88367af1472..000000000000
--- a/drivers/media/platform/qcom/venus/vdec.c
+++ b/drivers/media/platform/qcom/venus/vdec.c
@@@ -769,16 -1005,133 +769,102 @@@ static int vdec_start_streaming(struct 
  
  	ret = venus_helper_vb2_start_streaming(inst);
  	if (ret)
 -		return ret;
 -
 -	ret = venus_helper_process_initial_out_bufs(inst);
 -	if (ret)
 -		return ret;
 -
 -	inst->codec_state = VENUS_DEC_STATE_INIT;
 -
 -done:
 -	inst->streamon_out = 1;
 -	return ret;
 -}
 -
 -static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 -{
 -	struct venus_inst *inst = vb2_get_drv_priv(q);
 -	int ret;
 -
 -	mutex_lock(&inst->lock);
 -
 -	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
 -		ret = vdec_start_capture(inst);
 -	} else {
 -		ret = vdec_pm_get(inst);
 -		if (ret)
 -			goto error;
 -
 -		ret = venus_pm_acquire_core(inst);
 -		if (ret)
 -			goto put_power;
 -
 -		ret = vdec_pm_put(inst, true);
 -		if (ret)
 -			goto error;
 -
 -		ret = vdec_start_output(inst);
 -	}
 -
 -	if (ret)
 -		goto error;
 +		goto deinit_sess;
  
  	mutex_unlock(&inst->lock);
 +
  	return 0;
  
++<<<<<<< HEAD
 +deinit_sess:
 +	hfi_session_deinit(inst);
 +bufs_done:
 +	venus_helper_buffers_done(inst, VB2_BUF_STATE_QUEUED);
++=======
+ put_power:
+ 	vdec_pm_put(inst, false);
+ error:
+ 	venus_helper_buffers_done(inst, q->type, VB2_BUF_STATE_QUEUED);
+ 	mutex_unlock(&inst->lock);
+ 	return ret;
+ }
+ 
+ static void vdec_cancel_dst_buffers(struct venus_inst *inst)
+ {
+ 	struct vb2_v4l2_buffer *buf;
+ 
+ 	while ((buf = v4l2_m2m_dst_buf_remove(inst->m2m_ctx)))
+ 		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+ }
+ 
+ static int vdec_stop_capture(struct venus_inst *inst)
+ {
+ 	int ret = 0;
+ 
+ 	switch (inst->codec_state) {
+ 	case VENUS_DEC_STATE_DECODING:
+ 		ret = hfi_session_flush(inst, HFI_FLUSH_ALL, true);
+ 		fallthrough;
+ 	case VENUS_DEC_STATE_DRAIN:
+ 		vdec_cancel_dst_buffers(inst);
+ 		inst->codec_state = VENUS_DEC_STATE_STOPPED;
+ 		break;
+ 	case VENUS_DEC_STATE_DRC:
+ 		WARN_ON(1);
+ 		fallthrough;
+ 	case VENUS_DEC_STATE_DRC_FLUSH_DONE:
+ 		inst->codec_state = VENUS_DEC_STATE_CAPTURE_SETUP;
+ 		venus_helper_free_dpb_bufs(inst);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	INIT_LIST_HEAD(&inst->registeredbufs);
+ 
+ 	return ret;
+ }
+ 
+ static int vdec_stop_output(struct venus_inst *inst)
+ {
+ 	int ret = 0;
+ 
+ 	switch (inst->codec_state) {
+ 	case VENUS_DEC_STATE_DECODING:
+ 	case VENUS_DEC_STATE_DRAIN:
+ 	case VENUS_DEC_STATE_STOPPED:
+ 		ret = hfi_session_flush(inst, HFI_FLUSH_ALL, true);
+ 		inst->codec_state = VENUS_DEC_STATE_SEEK;
+ 		break;
+ 	case VENUS_DEC_STATE_INIT:
+ 	case VENUS_DEC_STATE_CAPTURE_SETUP:
+ 		ret = hfi_session_flush(inst, HFI_FLUSH_INPUT, true);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void vdec_stop_streaming(struct vb2_queue *q)
+ {
+ 	struct venus_inst *inst = vb2_get_drv_priv(q);
+ 	int ret = -EINVAL;
+ 
+ 	mutex_lock(&inst->lock);
+ 
+ 	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+ 		ret = vdec_stop_capture(inst);
+ 	else
+ 		ret = vdec_stop_output(inst);
+ 
+ 	venus_helper_buffers_done(inst, q->type, VB2_BUF_STATE_ERROR);
+ 
+ 	if (ret)
+ 		goto unlock;
+ 
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  	if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
  		inst->streamon_out = 0;
  	else
diff --cc drivers/media/usb/dvb-usb-v2/gl861.c
index 80fed4494736,0c434259c36f..000000000000
--- a/drivers/media/usb/dvb-usb-v2/gl861.c
+++ b/drivers/media/usb/dvb-usb-v2/gl861.c
@@@ -17,52 -14,67 +17,62 @@@
  
  DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
  
 -struct gl861 {
 -	/* USB control message buffer */
 -	u8 buf[16];
 -
 -	struct i2c_adapter *demod_sub_i2c;
 -	struct i2c_client  *i2c_client_demod;
 -	struct i2c_client  *i2c_client_tuner;
 -};
 -
 -#define CMD_WRITE_SHORT     0x01
 -#define CMD_READ            0x02
 -#define CMD_WRITE           0x03
 -
 -static int gl861_ctrl_msg(struct dvb_usb_device *d, u8 request, u16 value,
 -			  u16 index, void *data, u16 size)
 +static int gl861_i2c_msg(struct dvb_usb_device *d, u8 addr,
 +			 u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)
  {
 -	struct gl861 *ctx = d_to_priv(d);
 -	struct usb_interface *intf = d->intf;
 +	u16 index;
 +	u16 value = addr << (8 + 1);
 +	int wo = (rbuf == NULL || rlen == 0); /* write-only */
 +	u8 req, type;
 +	u8 *buf;
  	int ret;
 -	unsigned int pipe;
 -	u8 requesttype;
  
 -	mutex_lock(&d->usb_mutex);
 +	if (wo) {
 +		req = GL861_REQ_I2C_WRITE;
 +		type = GL861_WRITE;
 +		buf = kmemdup(wbuf, wlen, GFP_KERNEL);
 +	} else { /* rw */
 +		req = GL861_REQ_I2C_READ;
 +		type = GL861_READ;
 +		buf = kmalloc(rlen, GFP_KERNEL);
 +	}
 +	if (!buf)
 +		return -ENOMEM;
  
++<<<<<<< HEAD
 +	switch (wlen) {
 +	case 1:
 +		index = wbuf[0];
++=======
+ 	switch (request) {
+ 	case CMD_WRITE:
+ 		memcpy(ctx->buf, data, size);
+ 		fallthrough;
+ 	case CMD_WRITE_SHORT:
+ 		pipe = usb_sndctrlpipe(d->udev, 0);
+ 		requesttype = USB_TYPE_VENDOR | USB_DIR_OUT;
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  		break;
 -	case CMD_READ:
 -		pipe = usb_rcvctrlpipe(d->udev, 0);
 -		requesttype = USB_TYPE_VENDOR | USB_DIR_IN;
 +	case 2:
 +		index = wbuf[0];
 +		value = value + wbuf[1];
  		break;
  	default:
 -		ret = -EINVAL;
 -		goto err_mutex_unlock;
 +		dev_err(&d->udev->dev, "%s: wlen=%d, aborting\n",
 +				KBUILD_MODNAME, wlen);
 +		kfree(buf);
 +		return -EINVAL;
  	}
  
 -	ret = usb_control_msg(d->udev, pipe, request, requesttype, value,
 -			      index, ctx->buf, size, 200);
 -	dev_dbg(&intf->dev, "%d | %02x %02x %*ph %*ph %*ph %s %*ph\n",
 -		ret, requesttype, request, 2, &value, 2, &index, 2, &size,
 -		(requesttype & USB_DIR_IN) ? "<<<" : ">>>", size, ctx->buf);
 -	if (ret < 0)
 -		goto err_mutex_unlock;
 +	usleep_range(1000, 2000); /* avoid I2C errors */
  
 -	if (request == CMD_READ)
 -		memcpy(data, ctx->buf, size);
 +	ret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0), req, type,
 +			      value, index, buf, rlen, 2000);
  
 -	usleep_range(1000, 2000); /* Avoid I2C errors */
 +	if (!wo && ret > 0)
 +		memcpy(rbuf, buf, rlen);
  
 -	mutex_unlock(&d->usb_mutex);
 -
 -	return 0;
 -
 -err_mutex_unlock:
 -	mutex_unlock(&d->usb_mutex);
 -	dev_dbg(&intf->dev, "failed %d\n", ret);
 +	kfree(buf);
  	return ret;
  }
  
diff --cc drivers/media/usb/pulse8-cec/pulse8-cec.c
index 4299cf924f21,e4d8446b87da..000000000000
--- a/drivers/media/usb/pulse8-cec/pulse8-cec.c
+++ b/drivers/media/usb/pulse8-cec/pulse8-cec.c
@@@ -131,116 -203,6 +131,129 @@@ struct pulse8 
  	bool autonomous;
  };
  
 +static void pulse8_ping_eeprom_work_handler(struct work_struct *work);
 +
 +static void pulse8_irq_work_handler(struct work_struct *work)
 +{
 +	struct pulse8 *pulse8 =
 +		container_of(work, struct pulse8, work);
 +
 +	switch (pulse8->data[0] & 0x3f) {
 +	case MSGCODE_FRAME_DATA:
 +		cec_received_msg(pulse8->adap, &pulse8->rx_msg);
 +		break;
 +	case MSGCODE_TRANSMIT_SUCCEEDED:
 +		cec_transmit_attempt_done(pulse8->adap, CEC_TX_STATUS_OK);
 +		break;
 +	case MSGCODE_TRANSMIT_FAILED_ACK:
 +		cec_transmit_attempt_done(pulse8->adap, CEC_TX_STATUS_NACK);
 +		break;
 +	case MSGCODE_TRANSMIT_FAILED_LINE:
 +	case MSGCODE_TRANSMIT_FAILED_TIMEOUT_DATA:
 +	case MSGCODE_TRANSMIT_FAILED_TIMEOUT_LINE:
 +		cec_transmit_attempt_done(pulse8->adap, CEC_TX_STATUS_ERROR);
 +		break;
 +	}
 +}
 +
 +static irqreturn_t pulse8_interrupt(struct serio *serio, unsigned char data,
 +				    unsigned int flags)
 +{
 +	struct pulse8 *pulse8 = serio_get_drvdata(serio);
 +
 +	if (!pulse8->started && data != MSGSTART)
 +		return IRQ_HANDLED;
 +	if (data == MSGESC) {
 +		pulse8->escape = true;
 +		return IRQ_HANDLED;
 +	}
 +	if (pulse8->escape) {
 +		data += MSGOFFSET;
 +		pulse8->escape = false;
 +	} else if (data == MSGEND) {
 +		struct cec_msg *msg = &pulse8->rx_msg;
 +
 +		if (debug)
 +			dev_info(pulse8->dev, "received: %*ph\n",
 +				 pulse8->idx, pulse8->buf);
 +		pulse8->data[0] = pulse8->buf[0];
 +		switch (pulse8->buf[0] & 0x3f) {
 +		case MSGCODE_FRAME_START:
++<<<<<<< HEAD:drivers/media/usb/pulse8-cec/pulse8-cec.c
 +			msg->len = 1;
 +			msg->msg[0] = pulse8->buf[1];
 +			break;
++=======
++			/*
++			 * Test if we are receiving a new msg when a previous
++			 * message is still pending.
++			 */
++			if (!(msgcode & MSGCODE_FRAME_EOM)) {
++				pulse8->new_rx_msg_len = 1;
++				pulse8->new_rx_msg[0] = pulse8->buf[1];
++				break;
++			}
++			fallthrough;
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword):drivers/media/cec/usb/pulse8/pulse8-cec.c
 +		case MSGCODE_FRAME_DATA:
 +			if (msg->len == CEC_MAX_MSG_SIZE)
 +				break;
 +			msg->msg[msg->len++] = pulse8->buf[1];
 +			if (pulse8->buf[0] & MSGCODE_FRAME_EOM)
 +				schedule_work(&pulse8->work);
 +			break;
 +		case MSGCODE_TRANSMIT_SUCCEEDED:
 +		case MSGCODE_TRANSMIT_FAILED_LINE:
 +		case MSGCODE_TRANSMIT_FAILED_ACK:
 +		case MSGCODE_TRANSMIT_FAILED_TIMEOUT_DATA:
 +		case MSGCODE_TRANSMIT_FAILED_TIMEOUT_LINE:
 +			schedule_work(&pulse8->work);
 +			break;
 +		case MSGCODE_HIGH_ERROR:
 +		case MSGCODE_LOW_ERROR:
 +		case MSGCODE_RECEIVE_FAILED:
 +		case MSGCODE_TIMEOUT_ERROR:
 +			break;
 +		case MSGCODE_COMMAND_ACCEPTED:
 +		case MSGCODE_COMMAND_REJECTED:
 +		default:
 +			if (pulse8->idx == 0)
 +				break;
 +			memcpy(pulse8->data, pulse8->buf, pulse8->idx);
 +			pulse8->len = pulse8->idx;
 +			complete(&pulse8->cmd_done);
 +			break;
 +		}
 +		pulse8->idx = 0;
 +		pulse8->started = false;
 +		return IRQ_HANDLED;
 +	} else if (data == MSGSTART) {
 +		pulse8->idx = 0;
 +		pulse8->started = true;
 +		return IRQ_HANDLED;
 +	}
 +
 +	if (pulse8->idx >= DATA_SIZE) {
 +		dev_dbg(pulse8->dev,
 +			"throwing away %d bytes of garbage\n", pulse8->idx);
 +		pulse8->idx = 0;
 +	}
 +	pulse8->buf[pulse8->idx++] = data;
 +	return IRQ_HANDLED;
 +}
 +
 +static void pulse8_disconnect(struct serio *serio)
 +{
 +	struct pulse8 *pulse8 = serio_get_drvdata(serio);
 +
 +	cec_unregister_adapter(pulse8->adap);
 +	cancel_delayed_work_sync(&pulse8->ping_eeprom_work);
 +	dev_info(&serio->dev, "disconnected\n");
 +	serio_close(serio);
 +	serio_set_drvdata(serio, NULL);
 +	kfree(pulse8);
 +}
 +
  static int pulse8_send(struct serio *serio, const u8 *command, u8 cmd_len)
  {
  	int err = 0;
diff --cc drivers/media/usb/uvc/uvc_video.c
index c0ca66a6a393,6249e26e8788..000000000000
--- a/drivers/media/usb/uvc/uvc_video.c
+++ b/drivers/media/usb/uvc/uvc_video.c
@@@ -1593,10 -1507,9 +1593,16 @@@ static void uvc_video_complete(struct u
  		break;
  
  	default:
++<<<<<<< HEAD
 +		dev_warn(&stream->intf->dev,
 +			"Non-zero status (%d) in video completion handler.\n",
 +			urb->status);
 +		/* fall through */
++=======
+ 		uvc_printk(KERN_WARNING, "Non-zero status (%d) in video "
+ 			"completion handler.\n", urb->status);
+ 		fallthrough;
++>>>>>>> 1771e9fb67e2 (media: Use fallthrough pseudo-keyword)
  	case -ENOENT:		/* usb_poison_urb() called. */
  		if (stream->frozen)
  			return;
* Unmerged path drivers/media/test-drivers/vicodec/vicodec-core.c
diff --git a/drivers/media/cec/core/cec-adap.c b/drivers/media/cec/core/cec-adap.c
index 4efe8014445e..80fd5165f658 100644
--- a/drivers/media/cec/core/cec-adap.c
+++ b/drivers/media/cec/core/cec-adap.c
@@ -1928,7 +1928,7 @@ static int cec_receive_notify(struct cec_adapter *adap, struct cec_msg *msg,
 		 */
 		if (!adap->passthrough && from_unregistered)
 			return 0;
-		/* Fall through */
+		fallthrough;
 	case CEC_MSG_GIVE_DEVICE_VENDOR_ID:
 	case CEC_MSG_GIVE_FEATURES:
 	case CEC_MSG_GIVE_PHYSICAL_ADDR:
diff --git a/drivers/media/cec/core/cec-pin.c b/drivers/media/cec/core/cec-pin.c
index 660fe111f540..f006bd8eec63 100644
--- a/drivers/media/cec/core/cec-pin.c
+++ b/drivers/media/cec/core/cec-pin.c
@@ -417,7 +417,7 @@ static void cec_pin_tx_states(struct cec_pin *pin, ktime_t ts)
 			wake_up_interruptible(&pin->kthread_waitq);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case CEC_ST_TX_DATA_BIT_0_HIGH:
 	case CEC_ST_TX_DATA_BIT_0_HIGH_SHORT:
 	case CEC_ST_TX_DATA_BIT_0_HIGH_LONG:
@@ -445,7 +445,7 @@ static void cec_pin_tx_states(struct cec_pin *pin, ktime_t ts)
 			wake_up_interruptible(&pin->kthread_waitq);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case CEC_ST_TX_DATA_BIT_HIGH_CUSTOM:
 		if (tx_last_bit(pin)) {
 			/* Error Injection: just stop sending after this bit */
@@ -459,7 +459,7 @@ static void cec_pin_tx_states(struct cec_pin *pin, ktime_t ts)
 			break;
 		}
 		pin->tx_bit++;
-		/* fall through */
+		fallthrough;
 	case CEC_ST_TX_START_BIT_HIGH:
 	case CEC_ST_TX_START_BIT_HIGH_SHORT:
 	case CEC_ST_TX_START_BIT_HIGH_LONG:
diff --git a/drivers/media/common/videobuf2/videobuf2-v4l2.c b/drivers/media/common/videobuf2/videobuf2-v4l2.c
index 322fd2e3fb5f..3ccd0997bb45 100644
--- a/drivers/media/common/videobuf2/videobuf2-v4l2.c
+++ b/drivers/media/common/videobuf2/videobuf2-v4l2.c
@@ -262,7 +262,7 @@ static void __fill_v4l2_buffer(struct vb2_buffer *vb, void *pb)
 		break;
 	case VB2_BUF_STATE_ERROR:
 		b->flags |= V4L2_BUF_FLAG_ERROR;
-		/* fall through */
+		fallthrough;
 	case VB2_BUF_STATE_DONE:
 		b->flags |= V4L2_BUF_FLAG_DONE;
 		break;
diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index 99361c113bca..d7ea4a7b2dc6 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -607,7 +607,7 @@ static int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)
 			state->strength_en = 2;
 			break;
 		}
-		/* Fall through */
+		fallthrough;
 	case 1:
 		if (time_is_after_jiffies(state->strength_jiffies + msecs_to_jiffies(2000)))
 			break;
diff --git a/drivers/media/dvb-frontends/lg2160.c b/drivers/media/dvb-frontends/lg2160.c
index 9854096839ae..e6a6b565d3cd 100644
--- a/drivers/media/dvb-frontends/lg2160.c
+++ b/drivers/media/dvb-frontends/lg2160.c
@@ -1418,7 +1418,7 @@ struct dvb_frontend *lg2160_attach(const struct lg2160_config *config,
 	switch (config->lg_chip) {
 	default:
 		lg_warn("invalid chip requested, defaulting to LG2160");
-		/* fall-thru */
+		fallthrough;
 	case LG2160:
 		memcpy(&state->frontend.ops, &lg2160_ops,
 		       sizeof(struct dvb_frontend_ops));
* Unmerged path drivers/media/dvb-frontends/m88ds3103.c
* Unmerged path drivers/media/i2c/adv7180.c
diff --git a/drivers/media/i2c/adv7511.c b/drivers/media/i2c/adv7511.c
index b6b33304b05e..0ceebebc8bc1 100644
--- a/drivers/media/i2c/adv7511.c
+++ b/drivers/media/i2c/adv7511.c
@@ -465,7 +465,7 @@ static int adv7511_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *
 			reg->val = adv7511_cec_read(sd, reg->reg & 0xff);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		v4l2_info(sd, "Register %03llx not supported\n", reg->reg);
 		adv7511_inv_register(sd);
@@ -487,7 +487,7 @@ static int adv7511_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_regi
 			adv7511_cec_write(sd, reg->reg & 0xff, reg->val & 0xff);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		v4l2_info(sd, "Register %03llx not supported\n", reg->reg);
 		adv7511_inv_register(sd);
diff --git a/drivers/media/i2c/msp3400-kthreads.c b/drivers/media/i2c/msp3400-kthreads.c
index dc6cb8d475b3..896c71a1bce1 100644
--- a/drivers/media/i2c/msp3400-kthreads.c
+++ b/drivers/media/i2c/msp3400-kthreads.c
@@ -655,7 +655,7 @@ int msp3400c_thread(void *data)
 			break;
 		case 0: /* 4.5 */
 			state->detected_std = V4L2_STD_MN;
-			/* fall-through */
+			fallthrough;
 		default:
 no_second:
 			state->second = msp3400c_carrier_detect_main[max1].cdo;
* Unmerged path drivers/media/i2c/ov5640.c
diff --git a/drivers/media/i2c/ov6650.c b/drivers/media/i2c/ov6650.c
index 17a34b4a819d..f45643724033 100644
--- a/drivers/media/i2c/ov6650.c
+++ b/drivers/media/i2c/ov6650.c
@@ -689,7 +689,7 @@ static int ov6650_set_fmt(struct v4l2_subdev *sd,
 	switch (mf->code) {
 	case MEDIA_BUS_FMT_Y10_1X10:
 		mf->code = MEDIA_BUS_FMT_Y8_1X8;
-		/* fall through */
+		fallthrough;
 	case MEDIA_BUS_FMT_Y8_1X8:
 	case MEDIA_BUS_FMT_YVYU8_2X8:
 	case MEDIA_BUS_FMT_YUYV8_2X8:
@@ -699,7 +699,7 @@ static int ov6650_set_fmt(struct v4l2_subdev *sd,
 		break;
 	default:
 		mf->code = MEDIA_BUS_FMT_SBGGR8_1X8;
-		/* fall through */
+		fallthrough;
 	case MEDIA_BUS_FMT_SBGGR8_1X8:
 		mf->colorspace = V4L2_COLORSPACE_SRGB;
 		break;
diff --git a/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c b/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c
index 2e7185030741..231a9ae0ab29 100644
--- a/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c
+++ b/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c
@@ -54,7 +54,7 @@ static int s5c73m3_get_af_status(struct s5c73m3 *state, struct v4l2_ctrl *ctrl)
 		break;
 	default:
 		v4l2_info(&state->sensor_sd, "Unknown AF status %#x\n", reg);
-		/* Fall through */
+		fallthrough;
 	case REG_CAF_STATUS_UNFOCUSED:
 	case REG_AF_STATUS_UNFOCUSED:
 	case REG_AF_STATUS_INVALID:
* Unmerged path drivers/media/i2c/smiapp/smiapp-core.c
diff --git a/drivers/media/i2c/soc_camera/ov9640.c b/drivers/media/i2c/soc_camera/ov9640.c
index c63948989688..082023094753 100644
--- a/drivers/media/i2c/soc_camera/ov9640.c
+++ b/drivers/media/i2c/soc_camera/ov9640.c
@@ -519,7 +519,7 @@ static int ov9640_set_fmt(struct v4l2_subdev *sd,
 		break;
 	default:
 		mf->code = MEDIA_BUS_FMT_UYVY8_2X8;
-		/* fall through */
+		fallthrough;
 	case MEDIA_BUS_FMT_UYVY8_2X8:
 		mf->colorspace = V4L2_COLORSPACE_JPEG;
 		break;
diff --git a/drivers/media/i2c/tda1997x.c b/drivers/media/i2c/tda1997x.c
index 26741cc730c4..c04d1528c8bf 100644
--- a/drivers/media/i2c/tda1997x.c
+++ b/drivers/media/i2c/tda1997x.c
@@ -2584,7 +2584,7 @@ static int tda1997x_probe(struct i2c_client *client,
 			case 36:
 				mbus_codes[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
 				mbus_codes[i++] = MEDIA_BUS_FMT_YUV12_1X36;
-				/* fall-through */
+				fallthrough;
 			case 24:
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
 				break;
@@ -2613,10 +2613,10 @@ static int tda1997x_probe(struct i2c_client *client,
 				mbus_codes[i++] = MEDIA_BUS_FMT_RGB888_1X24;
 				mbus_codes[i++] = MEDIA_BUS_FMT_YUV8_1X24;
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
-				/* fall through */
+				fallthrough;
 			case 20:
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
-				/* fall through */
+				fallthrough;
 			case 16:
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
 				break;
@@ -2629,10 +2629,10 @@ static int tda1997x_probe(struct i2c_client *client,
 			case 16:
 			case 12:
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_2X12;
-				/* fall through */
+				fallthrough;
 			case 10:
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY10_2X10;
-				/* fall through */
+				fallthrough;
 			case 8:
 				mbus_codes[i++] = MEDIA_BUS_FMT_UYVY8_2X8;
 				break;
diff --git a/drivers/media/i2c/tvp5150.c b/drivers/media/i2c/tvp5150.c
index b162c2fe62c3..17bb98e99585 100644
--- a/drivers/media/i2c/tvp5150.c
+++ b/drivers/media/i2c/tvp5150.c
@@ -275,7 +275,7 @@ static void tvp5150_selmux(struct v4l2_subdev *sd)
 	switch (decoder->input) {
 	case TVP5150_COMPOSITE1:
 		input |= 2;
-		/* fall through */
+		fallthrough;
 	case TVP5150_COMPOSITE0:
 		break;
 	case TVP5150_SVIDEO:
diff --git a/drivers/media/pci/bt8xx/bttv-driver.c b/drivers/media/pci/bt8xx/bttv-driver.c
index cf977e6ae7ec..444644657437 100644
--- a/drivers/media/pci/bt8xx/bttv-driver.c
+++ b/drivers/media/pci/bt8xx/bttv-driver.c
@@ -2363,7 +2363,7 @@ static int bttv_try_fmt_vid_cap(struct file *file, void *priv,
 			field = V4L2_FIELD_SEQ_TB;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default: /* FIELD_ANY case */
 		height2 = btv->crop[!!fh->do_crop].rect.height >> 1;
 		field = (f->fmt.pix.height > height2)
diff --git a/drivers/media/pci/cx88/cx88-cards.c b/drivers/media/pci/cx88/cx88-cards.c
index 4c92d2388c26..660ab93f3a95 100644
--- a/drivers/media/pci/cx88/cx88-cards.c
+++ b/drivers/media/pci/cx88/cx88-cards.c
@@ -3465,7 +3465,7 @@ static void cx88_card_setup(struct cx88_core *core)
 		cx_clear(MO_GP0_IO, 0x00000040);
 		msleep(1000);
 		cx_set(MO_GP0_IO, 0x00004040);
-		/* FALLTHROUGH */
+		fallthrough;
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID:
diff --git a/drivers/media/pci/cx88/cx88-video.c b/drivers/media/pci/cx88/cx88-video.c
index 394ef0f13a0c..fa8cca84bbe1 100644
--- a/drivers/media/pci/cx88/cx88-video.c
+++ b/drivers/media/pci/cx88/cx88-video.c
@@ -1422,7 +1422,7 @@ static int cx8800_initdev(struct pci_dev *pci_dev,
 		request_module("rtc-isl1208");
 		core->i2c_rtc = i2c_new_device(&core->i2c_adap, &rtc_info);
 	}
-		/* fall-through */
+		fallthrough;
 	case CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:
 		request_module("ir-kbd-i2c");
 	}
diff --git a/drivers/media/pci/saa7134/saa7134-cards.c b/drivers/media/pci/saa7134/saa7134-cards.c
index 9d6688a82b50..e02e061783e9 100644
--- a/drivers/media/pci/saa7134/saa7134-cards.c
+++ b/drivers/media/pci/saa7134/saa7134-cards.c
@@ -7806,7 +7806,7 @@ int saa7134_board_init2(struct saa7134_dev *dev)
 				dev->name, saa7134_boards[dev->board].name);
 			break;
 		}
-		/* fall-through */
+		fallthrough;
 	case SAA7134_BOARD_VIDEOMATE_DVBT_300:
 	case SAA7134_BOARD_ASUS_EUROPA2_HYBRID:
 	case SAA7134_BOARD_ASUS_EUROPA_HYBRID:
@@ -7864,7 +7864,7 @@ int saa7134_board_init2(struct saa7134_dev *dev)
 		break;
 	case SAA7134_BOARD_HAUPPAUGE_HVR1110:
 		hauppauge_eeprom(dev, dev->eedata+0x80);
-		/* fall-through */
+		fallthrough;
 	case SAA7134_BOARD_PINNACLE_PCTV_310i:
 	case SAA7134_BOARD_KWORLD_DVBT_210:
 	case SAA7134_BOARD_TEVION_DVBT_220RF:
diff --git a/drivers/media/pci/solo6x10/solo6x10-core.c b/drivers/media/pci/solo6x10/solo6x10-core.c
index 19ffd2ed3cc7..24d51ad32a1a 100644
--- a/drivers/media/pci/solo6x10/solo6x10-core.c
+++ b/drivers/media/pci/solo6x10/solo6x10-core.c
@@ -512,7 +512,7 @@ static int solo_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	default:
 		dev_warn(&pdev->dev, "Invalid chip_id 0x%02x, assuming 4 ch\n",
 			 chip_id);
-		/* fall through */
+		fallthrough;
 	case 5:
 		solo_dev->nr_chans = 4;
 		solo_dev->nr_ext = 1;
diff --git a/drivers/media/pci/solo6x10/solo6x10-i2c.c b/drivers/media/pci/solo6x10/solo6x10-i2c.c
index 89f2f2a493c2..d4badba17a21 100644
--- a/drivers/media/pci/solo6x10/solo6x10-i2c.c
+++ b/drivers/media/pci/solo6x10/solo6x10-i2c.c
@@ -192,7 +192,7 @@ int solo_i2c_isr(struct solo_dev *solo_dev)
 		}
 
 		solo_dev->i2c_state = IIC_STATE_WRITE;
-		/* fall through */
+		fallthrough;
 	case IIC_STATE_WRITE:
 		ret = solo_i2c_handle_write(solo_dev);
 		break;
diff --git a/drivers/media/platform/coda/coda-bit.c b/drivers/media/platform/coda/coda-bit.c
index 68ed2a564ad1..2a26602310d8 100644
--- a/drivers/media/platform/coda/coda-bit.c
+++ b/drivers/media/platform/coda/coda-bit.c
@@ -902,7 +902,7 @@ static int coda_start_encoding(struct coda_ctx *ctx)
 		break;
 	case CODA_960:
 		coda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);
-		/* fallthrough */
+		fallthrough;
 	case CODA_HX4:
 	case CODA_7541:
 		coda_write(dev, CODA7_STREAM_BUF_DYNALLOC_EN |
@@ -942,7 +942,7 @@ static int coda_start_encoding(struct coda_ctx *ctx)
 				 CODA7_PICHEIGHT_MASK) << CODA_PICHEIGHT_OFFSET;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case CODA_960:
 		value = (q_data_src->width & CODA7_PICWIDTH_MASK)
 			<< CODA7_PICWIDTH_OFFSET;
* Unmerged path drivers/media/platform/coda/coda-common.c
diff --git a/drivers/media/platform/exynos4-is/fimc-capture.c b/drivers/media/platform/exynos4-is/fimc-capture.c
index 3e9fcf4f8a13..d6a4a3b1a9e0 100644
--- a/drivers/media/platform/exynos4-is/fimc-capture.c
+++ b/drivers/media/platform/exynos4-is/fimc-capture.c
@@ -1283,7 +1283,7 @@ static int fimc_cap_g_selection(struct file *file, void *fh,
 	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
 	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
 		f = &ctx->d_frame;
-		/* fall through */
+		fallthrough;
 	case V4L2_SEL_TGT_CROP_BOUNDS:
 	case V4L2_SEL_TGT_CROP_DEFAULT:
 		s->r.left = 0;
@@ -1294,7 +1294,7 @@ static int fimc_cap_g_selection(struct file *file, void *fh,
 
 	case V4L2_SEL_TGT_COMPOSE:
 		f = &ctx->d_frame;
-		/* fall through */
+		fallthrough;
 	case V4L2_SEL_TGT_CROP:
 		s->r.left = f->offs_h;
 		s->r.top = f->offs_v;
@@ -1618,7 +1618,7 @@ static int fimc_subdev_get_selection(struct v4l2_subdev *sd,
 	switch (sel->target) {
 	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
 		f = &ctx->d_frame;
-		/* fall through */
+		fallthrough;
 	case V4L2_SEL_TGT_CROP_BOUNDS:
 		r->width = f->o_width;
 		r->height = f->o_height;
diff --git a/drivers/media/platform/exynos4-is/fimc-reg.c b/drivers/media/platform/exynos4-is/fimc-reg.c
index 0806724553a2..78c390560a1c 100644
--- a/drivers/media/platform/exynos4-is/fimc-reg.c
+++ b/drivers/media/platform/exynos4-is/fimc-reg.c
@@ -713,7 +713,7 @@ int fimc_hw_set_camera_type(struct fimc_dev *fimc,
 		break;
 	case FIMC_BUS_TYPE_LCD_WRITEBACK_A:
 		cfg |= FIMC_REG_CIGCTRL_CAMIF_SELWB;
-		/* fall through */
+		fallthrough;
 	case FIMC_BUS_TYPE_ISP_WRITEBACK:
 		if (fimc->variant->has_isp_wb)
 			cfg |= FIMC_REG_CIGCTRL_CAMIF_SELWB;
diff --git a/drivers/media/platform/exynos4-is/media-dev.c b/drivers/media/platform/exynos4-is/media-dev.c
index 0be6e93dc9f5..f8878a9a9647 100644
--- a/drivers/media/platform/exynos4-is/media-dev.c
+++ b/drivers/media/platform/exynos4-is/media-dev.c
@@ -96,7 +96,7 @@ static void fimc_pipeline_prepare(struct fimc_pipeline *p,
 		switch (sd->grp_id) {
 		case GRP_ID_SENSOR:
 			sensor = sd;
-			/* fall through */
+			fallthrough;
 		case GRP_ID_FIMC_IS_SENSOR:
 			p->subdevs[IDX_SENSOR] = sd;
 			break;
diff --git a/drivers/media/platform/marvell-ccic/mcam-core.c b/drivers/media/platform/marvell-ccic/mcam-core.c
index c47011194710..52d6df348e19 100644
--- a/drivers/media/platform/marvell-ccic/mcam-core.c
+++ b/drivers/media/platform/marvell-ccic/mcam-core.c
@@ -394,7 +394,7 @@ static int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)
 		dma_free_coherent(cam->dev, cam->dma_buf_size,
 				cam->dma_bufs[0], cam->dma_handles[0]);
 		cam->nbufs = 0;
-		/* fall-through */
+		fallthrough;
 	case 0:
 		cam_err(cam, "Insufficient DMA buffers, cannot operate\n");
 		return -ENOMEM;
diff --git a/drivers/media/platform/omap3isp/ispvideo.c b/drivers/media/platform/omap3isp/ispvideo.c
index 5658f6a326f7..3b40f0b07cb8 100644
--- a/drivers/media/platform/omap3isp/ispvideo.c
+++ b/drivers/media/platform/omap3isp/ispvideo.c
@@ -711,7 +711,7 @@ isp_video_set_format(struct file *file, void *fh, struct v4l2_format *format)
 		 * requested.
 		 */
 		format->fmt.pix.field = V4L2_FIELD_INTERLACED_TB;
-		/* Fall-through */
+		fallthrough;
 	case V4L2_FIELD_INTERLACED_TB:
 	case V4L2_FIELD_INTERLACED_BT:
 		/* Interlaced orders are only supported at the CCDC output. */
* Unmerged path drivers/media/platform/qcom/venus/vdec.c
diff --git a/drivers/media/platform/renesas-ceu.c b/drivers/media/platform/renesas-ceu.c
index fb84bf74f720..1c70f5684082 100644
--- a/drivers/media/platform/renesas-ceu.c
+++ b/drivers/media/platform/renesas-ceu.c
@@ -390,7 +390,7 @@ static int ceu_hw_config(struct ceu_device *ceudev)
 	/* Non-swapped planar image capture mode. */
 	case V4L2_PIX_FMT_NV16:
 		cdocr	|= CEU_CDOCR_NO_DOWSAMPLE;
-		/* fall-through */
+		fallthrough;
 	case V4L2_PIX_FMT_NV12:
 		if (mbus_fmt->swapped)
 			camcr = mbus_fmt->fmt_order_swap;
@@ -404,7 +404,7 @@ static int ceu_hw_config(struct ceu_device *ceudev)
 	/* Swapped planar image capture mode. */
 	case V4L2_PIX_FMT_NV61:
 		cdocr	|= CEU_CDOCR_NO_DOWSAMPLE;
-		/* fall-through */
+		fallthrough;
 	case V4L2_PIX_FMT_NV21:
 		if (mbus_fmt->swapped)
 			camcr = mbus_fmt->fmt_order;
diff --git a/drivers/media/platform/vivid/vivid-vbi-gen.c b/drivers/media/platform/vivid/vivid-vbi-gen.c
index acc98445a1fa..a141369a7a63 100644
--- a/drivers/media/platform/vivid/vivid-vbi-gen.c
+++ b/drivers/media/platform/vivid/vivid-vbi-gen.c
@@ -298,7 +298,7 @@ void vivid_vbi_gen_sliced(struct vivid_vbi_gen_data *vbi,
 	switch (frame) {
 	case 0:
 		vivid_vbi_gen_set_time_of_day(vbi->time_of_day_packet);
-		/* fall through */
+		fallthrough;
 	case 1 ... 7:
 		data1->data[0] = vbi->time_of_day_packet[frame * 2];
 		data1->data[1] = vbi->time_of_day_packet[frame * 2 + 1];
diff --git a/drivers/media/radio/si4713/si4713.c b/drivers/media/radio/si4713/si4713.c
index f4a53f1e856e..a723d179451c 100644
--- a/drivers/media/radio/si4713/si4713.c
+++ b/drivers/media/radio/si4713/si4713.c
@@ -1166,7 +1166,7 @@ static int si4713_s_ctrl(struct v4l2_ctrl *ctrl)
 			 * V4L2_CID_TUNE_POWER_LEVEL. */
 			if (force)
 				break;
-			/* fall through */
+			fallthrough;
 		case V4L2_CID_TUNE_POWER_LEVEL:
 			ret = si4713_tx_tune_power(sdev,
 				sdev->tune_pwr_level->val, sdev->tune_ant_cap->val);
diff --git a/drivers/media/rc/iguanair.c b/drivers/media/rc/iguanair.c
index 7daac8bab83b..6ccf9123ffc7 100644
--- a/drivers/media/rc/iguanair.c
+++ b/drivers/media/rc/iguanair.c
@@ -113,7 +113,7 @@ static void process_ir_data(struct iguanair *ir, unsigned len)
 			break;
 		case CMD_TX_OVERFLOW:
 			ir->tx_overflow = true;
-			/* fall through */
+			fallthrough;
 		case CMD_RECEIVER_OFF:
 		case CMD_RECEIVER_ON:
 		case CMD_SEND:
* Unmerged path drivers/media/test-drivers/vicodec/vicodec-core.c
diff --git a/drivers/media/tuners/fc0011.c b/drivers/media/tuners/fc0011.c
index 145407dee3db..db7697df4bd7 100644
--- a/drivers/media/tuners/fc0011.c
+++ b/drivers/media/tuners/fc0011.c
@@ -259,7 +259,7 @@ static int fc0011_set_params(struct dvb_frontend *fe)
 		dev_warn(&priv->i2c->dev, "Unsupported bandwidth %u kHz. Using 6000 kHz.\n",
 			 bandwidth);
 		bandwidth = 6000;
-		/* fallthrough */
+		fallthrough;
 	case 6000:
 		regs[FC11_REG_VCOSEL] |= FC11_VCOSEL_BW6M;
 		break;
diff --git a/drivers/media/tuners/tda18271-fe.c b/drivers/media/tuners/tda18271-fe.c
index 147155553648..bfaeed7d09dd 100644
--- a/drivers/media/tuners/tda18271-fe.c
+++ b/drivers/media/tuners/tda18271-fe.c
@@ -960,7 +960,7 @@ static int tda18271_set_params(struct dvb_frontend *fe)
 		break;
 	case SYS_DVBC_ANNEX_B:
 		bw = 6000000;
-		/* fall through */
+		fallthrough;
 	case SYS_DVBC_ANNEX_A:
 	case SYS_DVBC_ANNEX_C:
 		if (bw <= 6000000) {
diff --git a/drivers/media/usb/dvb-usb-v2/af9015.c b/drivers/media/usb/dvb-usb-v2/af9015.c
index c8de087a8569..2b04a33e7969 100644
--- a/drivers/media/usb/dvb-usb-v2/af9015.c
+++ b/drivers/media/usb/dvb-usb-v2/af9015.c
@@ -43,7 +43,7 @@ static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
 	case READ_I2C:
 		write = 0;
 		state->buf[2] |= 0x01; /* set I2C direction */
-		/* fall through */
+		fallthrough;
 	case WRITE_I2C:
 		state->buf[0] = READ_WRITE_I2C;
 		break;
* Unmerged path drivers/media/usb/dvb-usb-v2/gl861.c
diff --git a/drivers/media/usb/dvb-usb-v2/lmedm04.c b/drivers/media/usb/dvb-usb-v2/lmedm04.c
index 0f321ee446a0..7aada6012912 100644
--- a/drivers/media/usb/dvb-usb-v2/lmedm04.c
+++ b/drivers/media/usb/dvb-usb-v2/lmedm04.c
@@ -690,7 +690,7 @@ static const char *lme_firmware_switch(struct dvb_usb_device *d, int cold)
 				cold = 0;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case TUNER_LG:
 			fw_lme = fw_lg;
 			ret = request_firmware(&fw, fw_lme, &udev->dev);
@@ -713,7 +713,7 @@ static const char *lme_firmware_switch(struct dvb_usb_device *d, int cold)
 				cold = 0;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case TUNER_LG:
 			fw_lme = fw_c_lg;
 			ret = request_firmware(&fw, fw_lme, &udev->dev);
@@ -721,7 +721,7 @@ static const char *lme_firmware_switch(struct dvb_usb_device *d, int cold)
 				st->dvb_usb_lme2510_firmware = TUNER_LG;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case TUNER_S0194:
 			fw_lme = fw_c_s0194;
 			ret = request_firmware(&fw, fw_lme, &udev->dev);
@@ -1021,7 +1021,7 @@ static int dm04_lme2510_frontend_attach(struct dvb_usb_adapter *adap)
 			}
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case 0x22f0:
 		st->i2c_gate = 5;
 		adap->fe[0] = dvb_attach(m88rs2000_attach,
diff --git a/drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c b/drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c
index 0b7dda99e410..ef489c566b75 100644
--- a/drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c
+++ b/drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c
@@ -632,7 +632,7 @@ int mxl111sf_set_gpio(struct mxl111sf_state *state, int gpio, int val)
 	default:
 		mxl_printk(KERN_ERR,
 			   "gpio_port_expander undefined, assuming PCA9534");
-		/* fall-thru */
+		fallthrough;
 	case mxl111sf_PCA9534:
 		return pca9534_set_gpio(state, gpio, val);
 	case mxl111sf_gpio_hw:
@@ -693,7 +693,7 @@ int mxl111sf_init_port_expander(struct mxl111sf_state *state)
 	default:
 		mxl_printk(KERN_ERR,
 			   "gpio_port_expander undefined, assuming PCA9534");
-		/* fall-thru */
+		fallthrough;
 	case mxl111sf_PCA9534:
 		return pca9534_init_port_expander(state);
 	case mxl111sf_gpio_hw:
diff --git a/drivers/media/usb/em28xx/em28xx-audio.c b/drivers/media/usb/em28xx/em28xx-audio.c
index 925a75b5a2ec..5357e9e28bbd 100644
--- a/drivers/media/usb/em28xx/em28xx-audio.c
+++ b/drivers/media/usb/em28xx/em28xx-audio.c
@@ -352,13 +352,13 @@ static int snd_em28xx_capture_trigger(struct snd_pcm_substream *substream,
 		return -ENODEV;
 
 	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE: /* fall through */
-	case SNDRV_PCM_TRIGGER_RESUME: /* fall through */
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_START:
 		atomic_set(&dev->adev.stream_started, 1);
 		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH: /* fall through */
-	case SNDRV_PCM_TRIGGER_SUSPEND: /* fall through */
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 		atomic_set(&dev->adev.stream_started, 0);
 		break;
diff --git a/drivers/media/usb/go7007/go7007-driver.c b/drivers/media/usb/go7007/go7007-driver.c
index 153a0c3e3da6..f1767be9d868 100644
--- a/drivers/media/usb/go7007/go7007-driver.c
+++ b/drivers/media/usb/go7007/go7007-driver.c
@@ -643,7 +643,7 @@ void go7007_parse_video_stream(struct go7007 *go, u8 *buf, int length)
 			case 0xD8:
 				if (go->format == V4L2_PIX_FMT_MJPEG)
 					vb = frame_boundary(go, vb);
-				/* fall through */
+				fallthrough;
 			default:
 				store_byte(vb, 0xFF);
 				store_byte(vb, buf[i]);
diff --git a/drivers/media/usb/gspca/mr97310a.c b/drivers/media/usb/gspca/mr97310a.c
index 502fc2eaffe0..8176534bcfff 100644
--- a/drivers/media/usb/gspca/mr97310a.c
+++ b/drivers/media/usb/gspca/mr97310a.c
@@ -511,7 +511,7 @@ static int start_cif_cam(struct gspca_dev *gspca_dev)
 	switch (gspca_dev->pixfmt.width) {
 	case 160:
 		data[9] |= 0x04;  /* reg 8, 2:1 scale down from 320 */
-		/* fall through */
+		fallthrough;
 	case 320:
 	default:
 		data[3] = 0x28;			   /* reg 2, H size/8 */
@@ -521,7 +521,7 @@ static int start_cif_cam(struct gspca_dev *gspca_dev)
 		break;
 	case 176:
 		data[9] |= 0x04;  /* reg 8, 2:1 scale down from 352 */
-		/* fall through */
+		fallthrough;
 	case 352:
 		data[3] = 0x2c;			   /* reg 2, H size/8 */
 		data[4] = 0x48;			   /* reg 3, V size/4 */
@@ -608,10 +608,10 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 	switch (gspca_dev->pixfmt.width) {
 	case 160:
 		data[9] |= 0x0c;  /* reg 8, 4:1 scale down */
-		/* fall through */
+		fallthrough;
 	case 320:
 		data[9] |= 0x04;  /* reg 8, 2:1 scale down */
-		/* fall through */
+		fallthrough;
 	case 640:
 	default:
 		data[3] = 0x50;  /* reg 2, H size/8 */
@@ -628,7 +628,7 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 
 	case 176:
 		data[9] |= 0x04;  /* reg 8, 2:1 scale down */
-		/* fall through */
+		fallthrough;
 	case 352:
 		data[3] = 0x2c;  /* reg 2, H size */
 		data[4] = 0x48;  /* reg 3, V size */
diff --git a/drivers/media/usb/gspca/nw80x.c b/drivers/media/usb/gspca/nw80x.c
index 59649704beba..a91e92db30ed 100644
--- a/drivers/media/usb/gspca/nw80x.c
+++ b/drivers/media/usb/gspca/nw80x.c
@@ -2014,7 +2014,7 @@ static int sd_init_controls(struct gspca_dev *gspca_dev)
 			V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
 		gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
 			V4L2_CID_GAIN, 0, 253, 1, 128);
-		/* fall through */
+		fallthrough;
 	case Cvideopro:
 	case DvcV6:
 	case Kritter:
diff --git a/drivers/media/usb/gspca/ov519.c b/drivers/media/usb/gspca/ov519.c
index e0a60403aa7f..f4a572feec8e 100644
--- a/drivers/media/usb/gspca/ov519.c
+++ b/drivers/media/usb/gspca/ov519.c
@@ -2004,7 +2004,7 @@ static void reg_w(struct sd *sd, u16 index, u16 value)
 		break;
 	case BRIDGE_OVFX2:
 		req = 0x0a;
-		/* fall through */
+		fallthrough;
 	case BRIDGE_W9968CF:
 		gspca_dbg(gspca_dev, D_USBO, "SET %02x %04x %04x\n",
 			  req, value, index);
@@ -3513,7 +3513,7 @@ static void ov511_mode_init_regs(struct sd *sd)
 	case SEN_OV76BE:
 		if (sd->gspca_dev.pixfmt.width == 320)
 			interlaced = 1;
-		/* Fall through */
+		fallthrough;
 	case SEN_OV6630:
 	case SEN_OV7610:
 	case SEN_OV7670:
@@ -3526,7 +3526,7 @@ static void ov511_mode_init_regs(struct sd *sd)
 				break;
 			}
 			/* For 640x480 case */
-			/* fall through */
+			fallthrough;
 		default:
 /*		case 20: */
 /*		case 15: */
diff --git a/drivers/media/usb/gspca/sn9c20x.c b/drivers/media/usb/gspca/sn9c20x.c
index b43f89fee6c1..7b60df3bd1d7 100644
--- a/drivers/media/usb/gspca/sn9c20x.c
+++ b/drivers/media/usb/gspca/sn9c20x.c
@@ -1625,7 +1625,7 @@ static int sd_config(struct gspca_dev *gspca_dev,
 		break;
 	case SENSOR_HV7131R:
 		sd->i2c_intf = 0x81;			/* i2c 400 Kb/s */
-		/* fall through */
+		fallthrough;
 	default:
 		cam->cam_mode = vga_mode;
 		cam->nmodes = ARRAY_SIZE(vga_mode);
diff --git a/drivers/media/usb/gspca/sunplus.c b/drivers/media/usb/gspca/sunplus.c
index 3c4fca491fd5..7dc99c0c658f 100644
--- a/drivers/media/usb/gspca/sunplus.c
+++ b/drivers/media/usb/gspca/sunplus.c
@@ -550,7 +550,7 @@ static void init_ctl_reg(struct gspca_dev *gspca_dev)
 	case BRIDGE_SPCA504:
 	case BRIDGE_SPCA504C:
 		pollreg = 0;
-		/* fall through */
+		fallthrough;
 	default:
 /*	case BRIDGE_SPCA533: */
 /*	case BRIDGE_SPCA504B: */
@@ -633,7 +633,7 @@ static int sd_init(struct gspca_dev *gspca_dev)
 		reg_w_riv(gspca_dev, 0x00, 0x2000, 0x00);
 		reg_w_riv(gspca_dev, 0x00, 0x2301, 0x13);
 		reg_w_riv(gspca_dev, 0x00, 0x2306, 0x00);
-		/* fall through */
+		fallthrough;
 	case BRIDGE_SPCA533:
 		spca504B_PollingDataReady(gspca_dev);
 		spca50x_GetFirmware(gspca_dev);
diff --git a/drivers/media/usb/gspca/xirlink_cit.c b/drivers/media/usb/gspca/xirlink_cit.c
index 16a0ef1447a1..acfb9a195106 100644
--- a/drivers/media/usb/gspca/xirlink_cit.c
+++ b/drivers/media/usb/gspca/xirlink_cit.c
@@ -1409,7 +1409,7 @@ static int cit_restart_stream(struct gspca_dev *gspca_dev)
 	case CIT_MODEL0:
 	case CIT_MODEL1:
 		cit_write_reg(gspca_dev, 0x0001, 0x0114);
-		/* Fall through */
+		fallthrough;
 	case CIT_MODEL2:
 	case CIT_MODEL4:
 		cit_write_reg(gspca_dev, 0x00c0, 0x010c); /* Go! */
@@ -2725,7 +2725,7 @@ static void sd_stop0(struct gspca_dev *gspca_dev)
 		break;
 	case CIT_MODEL2:
 		v4l2_ctrl_grab(sd->lighting, false);
-		/* Fall through! */
+		fallthrough;
 	case CIT_MODEL4:
 		cit_model2_Packet1(gspca_dev, 0x0030, 0x0004);
 
diff --git a/drivers/media/usb/gspca/zc3xx.c b/drivers/media/usb/gspca/zc3xx.c
index 15a2449d536f..aa285d5d6c0d 100644
--- a/drivers/media/usb/gspca/zc3xx.c
+++ b/drivers/media/usb/gspca/zc3xx.c
@@ -6766,7 +6766,7 @@ static int sd_start(struct gspca_dev *gspca_dev)
 	case SENSOR_HV7131R:
 	case SENSOR_TAS5130C:
 		reg_r(gspca_dev, 0x0008);
-		/* fall through */
+		fallthrough;
 	case SENSOR_PO2030:
 		reg_w(gspca_dev, 0x03, 0x0008);
 		break;
@@ -6815,7 +6815,7 @@ static int sd_start(struct gspca_dev *gspca_dev)
 	case SENSOR_TAS5130C:
 		reg_w(gspca_dev, 0x09, 0x01ad);	/* (from win traces) */
 		reg_w(gspca_dev, 0x15, 0x01ae);
-		/* fall through */
+		fallthrough;
 	case SENSOR_PAS202B:
 	case SENSOR_PO2030:
 /*		reg_w(gspca_dev, 0x40, ZC3XX_R117_GGAIN); in win traces */
* Unmerged path drivers/media/usb/pulse8-cec/pulse8-cec.c
diff --git a/drivers/media/usb/pwc/pwc-v4l.c b/drivers/media/usb/pwc/pwc-v4l.c
index 76c498cccc49..6116c265a457 100644
--- a/drivers/media/usb/pwc/pwc-v4l.c
+++ b/drivers/media/usb/pwc/pwc-v4l.c
@@ -554,7 +554,7 @@ static int pwc_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		if (!DEVICE_USE_CODEC3(pdev->type))
 			break;
 		/* For CODEC3 where autogain also controls expo */
-		/* fall through */
+		fallthrough;
 	case V4L2_CID_EXPOSURE_AUTO:
 		if (pdev->exposure_valid && time_before(jiffies,
 				pdev->last_exposure_update + HZ / 4)) {
diff --git a/drivers/media/usb/siano/smsusb.c b/drivers/media/usb/siano/smsusb.c
index 0358cd104387..5c223b5498b4 100644
--- a/drivers/media/usb/siano/smsusb.c
+++ b/drivers/media/usb/siano/smsusb.c
@@ -432,7 +432,7 @@ static int smsusb_init_device(struct usb_interface *intf, int board_id)
 		break;
 	case SMS_UNKNOWN_TYPE:
 		pr_err("Unspecified sms device type!\n");
-		/* fall-thru */
+		fallthrough;
 	default:
 		dev->buffer_size = USB2_BUFFER_SIZE;
 		dev->response_alignment = align;
diff --git a/drivers/media/usb/tm6000/tm6000-alsa.c b/drivers/media/usb/tm6000/tm6000-alsa.c
index c26a0ff60a64..3a2df36ef1db 100644
--- a/drivers/media/usb/tm6000/tm6000-alsa.c
+++ b/drivers/media/usb/tm6000/tm6000-alsa.c
@@ -272,13 +272,13 @@ static int snd_tm6000_card_trigger(struct snd_pcm_substream *substream, int cmd)
 	int err = 0;
 
 	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE: /* fall through */
-	case SNDRV_PCM_TRIGGER_RESUME: /* fall through */
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_START:
 		atomic_set(&core->stream_started, 1);
 		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH: /* fall through */
-	case SNDRV_PCM_TRIGGER_SUSPEND: /* fall through */
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 		atomic_set(&core->stream_started, 0);
 		break;
* Unmerged path drivers/media/usb/uvc/uvc_video.c
