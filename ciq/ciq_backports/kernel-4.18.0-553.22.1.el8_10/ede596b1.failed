scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Justin Tee <justin.tee@broadcom.com>
commit ede596b1434b57c0b3fd5c02b326efe5c54f6e48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/ede596b1.failed

The MBX_TIMEOUT return code is not handled in lpfc_get_sfp_info and the
routine unconditionally frees submitted mailbox commands regardless of
return status.  The issue is that for MBX_TIMEOUT cases, when firmware
returns SFP information at a later time, that same mailbox memory region
references previously freed memory in its cmpl routine.

Fix by adding checks for the MBX_TIMEOUT return code.  During mailbox
resource cleanup, check the mbox flag to make sure that the wait did not
timeout.  If the MBOX_WAKE flag is not set, then do not free the resources
because it will be freed when firmware completes the mailbox at a later
time in its cmpl routine.

Also, increase the timeout from 30 to 60 seconds to accommodate boot
scripts requiring longer timeouts.

	Signed-off-by: Justin Tee <justin.tee@broadcom.com>
Link: https://lore.kernel.org/r/20240628172011.25921-6-justintee8345@gmail.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ede596b1434b57c0b3fd5c02b326efe5c54f6e48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_els.c
diff --cc drivers/scsi/lpfc/lpfc_els.c
index ab088732b0f0,929cbfc95163..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -7111,16 -7302,15 +7111,21 @@@ int lpfc_get_sfp_info_wait(struct lpfc_
  		mbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);
  	}
  	mbox->vport = phba->pport;
++<<<<<<< HEAD
 +	mbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;
 +
 +	rc = lpfc_sli_issue_mbox_wait(phba, mbox, 30);
++=======
+ 	rc = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_SLI4_CONFIG_TMO);
++>>>>>>> ede596b1434b (scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info)
  	if (rc == MBX_NOT_FINISHED) {
  		rc = 1;
  		goto error;
  	}
- 
+ 	if (rc == MBX_TIMEOUT)
+ 		goto error;
  	if (phba->sli_rev == LPFC_SLI_REV4)
 -		mp = mbox->ctx_buf;
 +		mp = (struct lpfc_dmabuf *)(mbox->ctx_buf);
  	else
  		mp = mpsave;
  
@@@ -7171,8 -7361,10 +7176,15 @@@
  		mbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);
  	}
  
++<<<<<<< HEAD
 +	mbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;
 +	rc = lpfc_sli_issue_mbox_wait(phba, mbox, 30);
++=======
+ 	rc = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_SLI4_CONFIG_TMO);
+ 
+ 	if (rc == MBX_TIMEOUT)
+ 		goto error;
++>>>>>>> ede596b1434b (scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info)
  	if (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {
  		rc = 1;
  		goto error;
@@@ -7183,15 -7375,10 +7195,22 @@@
  			     DMP_SFF_PAGE_A2_SIZE);
  
  error:
++<<<<<<< HEAD
 +	mp = mpsave;
 +       	mbox->ctx_buf = NULL;
 +
 +	if (mp) {
 +		lpfc_mbuf_free(phba, mp->virt, mp->phys);
 +		kfree(mp);
 +	}
 +
 +	mempool_free(mbox, phba->mbox_mem_pool);
++=======
+ 	if (mbox->mbox_flag & LPFC_MBX_WAKE) {
+ 		mbox->ctx_buf = mpsave;
+ 		lpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);
+ 	}
++>>>>>>> ede596b1434b (scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info)
  
  	return rc;
  
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
