usb: core: Don't hold the device lock while sleeping in do_proc_control()

jira LE-1907
cve CVE-2021-47582
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Tasos Sahanidis <tasos@tasossah.com>
commit 0543e4e8852ef5ff1809ae62f1ea963e2ab23b66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/0543e4e8.failed

Since commit ae8709b296d8 ("USB: core: Make do_proc_control() and
do_proc_bulk() killable") if a device has the USB_QUIRK_DELAY_CTRL_MSG
quirk set, it will temporarily block all other URBs (e.g. interrupts)
while sleeping due to a control.

This results in noticeable delays when, for example, a userspace usbfs
application is sending URB interrupts at a high rate to a keyboard and
simultaneously updates the lock indicators using controls. Interrupts
with direction set to IN are also affected by this, meaning that
delivery of HID reports (containing scancodes) to the usbfs application
is delayed as well.

This patch fixes the regression by calling msleep() while the device
mutex is unlocked, as was the case originally with usb_control_msg().

Fixes: ae8709b296d8 ("USB: core: Make do_proc_control() and do_proc_bulk() killable")
	Cc: stable <stable@kernel.org>
	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Signed-off-by: Tasos Sahanidis <tasos@tasossah.com>
Link: https://lore.kernel.org/r/3e299e2a-13b9-ddff-7fee-6845e868bc06@tasossah.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 0543e4e8852ef5ff1809ae62f1ea963e2ab23b66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/devio.c
diff --cc drivers/usb/core/devio.c
index 986ad8499855,b5b85bf80329..000000000000
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@@ -1141,19 -1200,23 +1141,27 @@@ static int do_proc_control(struct usb_d
  		"wIndex=%04x wLength=%04x\n",
  		ctrl->bRequestType, ctrl->bRequest, ctrl->wValue,
  		ctrl->wIndex, ctrl->wLength);
 -
 -	if ((ctrl->bRequestType & USB_DIR_IN) && wLength) {
 +	if ((ctrl->bRequestType & USB_DIR_IN) && ctrl->wLength) {
  		pipe = usb_rcvctrlpipe(dev, 0);
 -		usb_fill_control_urb(urb, dev, pipe, (unsigned char *) dr, tbuf,
 -				wLength, NULL, NULL);
 -		snoop_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, NULL, 0);
 +		snoop_urb(dev, NULL, pipe, ctrl->wLength, tmo, SUBMIT, NULL, 0);
  
  		usb_unlock_device(dev);
++<<<<<<< HEAD
 +		i = usb_control_msg(dev, pipe, ctrl->bRequest,
 +				    ctrl->bRequestType, ctrl->wValue, ctrl->wIndex,
 +				    tbuf, ctrl->wLength, tmo);
++=======
+ 		i = usbfs_start_wait_urb(urb, tmo, &actlen);
+ 
+ 		/* Linger a bit, prior to the next control message. */
+ 		if (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)
+ 			msleep(200);
++>>>>>>> 0543e4e8852e (usb: core: Don't hold the device lock while sleeping in do_proc_control())
  		usb_lock_device(dev);
 -		snoop_urb(dev, NULL, pipe, actlen, i, COMPLETE, tbuf, actlen);
 -		if (!i && actlen) {
 -			if (copy_to_user(ctrl->data, tbuf, actlen)) {
 +		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE,
 +			  tbuf, max(i, 0));
 +		if ((i > 0) && ctrl->wLength) {
 +			if (copy_to_user(ctrl->data, tbuf, i)) {
  				ret = -EFAULT;
  				goto done;
  			}
@@@ -1166,15 -1229,18 +1174,23 @@@
  			}
  		}
  		pipe = usb_sndctrlpipe(dev, 0);
 -		usb_fill_control_urb(urb, dev, pipe, (unsigned char *) dr, tbuf,
 -				wLength, NULL, NULL);
 -		snoop_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, tbuf, wLength);
 +		snoop_urb(dev, NULL, pipe, ctrl->wLength, tmo, SUBMIT,
 +			tbuf, ctrl->wLength);
  
  		usb_unlock_device(dev);
++<<<<<<< HEAD
 +		i = usb_control_msg(dev, pipe, ctrl->bRequest,
 +				    ctrl->bRequestType, ctrl->wValue, ctrl->wIndex,
 +				    tbuf, ctrl->wLength, tmo);
++=======
+ 		i = usbfs_start_wait_urb(urb, tmo, &actlen);
+ 
+ 		/* Linger a bit, prior to the next control message. */
+ 		if (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)
+ 			msleep(200);
++>>>>>>> 0543e4e8852e (usb: core: Don't hold the device lock while sleeping in do_proc_control())
  		usb_lock_device(dev);
 -		snoop_urb(dev, NULL, pipe, actlen, i, COMPLETE, NULL, 0);
 +		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE, NULL, 0);
  	}
  	if (i < 0 && i != -EPIPE) {
  		dev_printk(KERN_DEBUG, &dev->dev, "usbfs: USBDEVFS_CONTROL "
@@@ -1182,8 -1248,11 +1198,13 @@@
  			   current->comm, ctrl->bRequestType, ctrl->bRequest,
  			   ctrl->wLength, i);
  	}
++<<<<<<< HEAD
 +	ret = i;
++=======
+ 	ret = (i < 0 ? i : actlen);
+ 
++>>>>>>> 0543e4e8852e (usb: core: Don't hold the device lock while sleeping in do_proc_control())
   done:
 -	kfree(dr);
 -	usb_free_urb(urb);
  	free_page((unsigned long) tbuf);
  	usbfs_decrease_memory_usage(PAGE_SIZE + sizeof(struct urb) +
  			sizeof(struct usb_ctrlrequest));
* Unmerged path drivers/usb/core/devio.c
