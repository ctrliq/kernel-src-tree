net: usb: asix: ax88772: manage PHY PM from MAC

jira LE-1907
cve CVE-2021-47101
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Oleksij Rempel <o.rempel@pengutronix.de>
commit 4a2c7217cd5a87e85ceb761e307b030fe6db4805
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/4a2c7217.failed

Take over PHY power management, otherwise PHY framework will try to
access ASIX MDIO bus before MAC resume was completed.

Fixes: e532a096be0e ("net: usb: asix: ax88772: add phylib support")
	Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
	Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Reported-by: Jon Hunter <jonathanh@nvidia.com>
	Suggested-by: Heiner Kallweit <hkallweit1@gmail.com>
	Tested-by: Jon Hunter <jonathanh@nvidia.com>
	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4a2c7217cd5a87e85ceb761e307b030fe6db4805)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/asix_devices.c
diff --cc drivers/net/usb/asix_devices.c
index 47f9233efb5d,aec97b021a73..000000000000
--- a/drivers/net/usb/asix_devices.c
+++ b/drivers/net/usb/asix_devices.c
@@@ -689,12 -659,61 +668,64 @@@ static int asix_resume(struct usb_inter
  	return usbnet_resume(intf);
  }
  
++<<<<<<< HEAD
++=======
+ static int ax88772_init_mdio(struct usbnet *dev)
+ {
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 
+ 	priv->mdio = devm_mdiobus_alloc(&dev->udev->dev);
+ 	if (!priv->mdio)
+ 		return -ENOMEM;
+ 
+ 	priv->mdio->priv = dev;
+ 	priv->mdio->read = &asix_mdio_bus_read;
+ 	priv->mdio->write = &asix_mdio_bus_write;
+ 	priv->mdio->name = "Asix MDIO Bus";
+ 	/* mii bus name is usb-<usb bus number>-<usb device number> */
+ 	snprintf(priv->mdio->id, MII_BUS_ID_SIZE, "usb-%03d:%03d",
+ 		 dev->udev->bus->busnum, dev->udev->devnum);
+ 
+ 	return devm_mdiobus_register(&dev->udev->dev, priv->mdio);
+ }
+ 
+ static int ax88772_init_phy(struct usbnet *dev)
+ {
+ 	struct asix_common_private *priv = dev->driver_priv;
+ 	int ret;
+ 
+ 	ret = asix_read_phy_addr(dev, true);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	priv->phy_addr = ret;
+ 
+ 	snprintf(priv->phy_name, sizeof(priv->phy_name), PHY_ID_FMT,
+ 		 priv->mdio->id, priv->phy_addr);
+ 
+ 	priv->phydev = phy_connect(dev->net, priv->phy_name, &asix_adjust_link,
+ 				   PHY_INTERFACE_MODE_INTERNAL);
+ 	if (IS_ERR(priv->phydev)) {
+ 		netdev_err(dev->net, "Could not connect to PHY device %s\n",
+ 			   priv->phy_name);
+ 		ret = PTR_ERR(priv->phydev);
+ 		return ret;
+ 	}
+ 
+ 	priv->phydev->mac_managed_pm = 1;
+ 
+ 	phy_attached_info(priv->phydev);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4a2c7217cd5a (net: usb: asix: ax88772: manage PHY PM from MAC)
  static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
  {
 -	u8 buf[ETH_ALEN] = {0}, chipcode = 0;
 -	struct asix_common_private *priv;
  	int ret, i;
 +	u8 buf[ETH_ALEN] = {0}, chipcode = 0;
  	u32 phyid;
 +	struct asix_common_private *priv;
  
  	usbnet_get_endpoints(dev, intf);
  
* Unmerged path drivers/net/usb/asix_devices.c
