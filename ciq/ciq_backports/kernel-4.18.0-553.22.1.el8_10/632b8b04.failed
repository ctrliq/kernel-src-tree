media: cec: core: count low-drive, error and arb-lost conditions

jira LE-1907
cve CVE-2024-23848
Rebuild_History Non-Buildable kernel-4.18.0-553.22.1.el8_10
commit-author Hans Verkuil <hverkuil-cisco@xs4all.nl>
commit 632b8b044a940e415c6d9bd5235778b0db28add1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.22.1.el8_10/632b8b04.failed

Count how many Low Drive, Error and Arbitration Lost transmit
status errors occurred, and expose that in debugfs.

Also log the first 8 transmits that result in Low Drive or Error
conditions. That really should not happen with well-behaved CEC devices
and good HDMI cables.

This is useful to detect and debug HDMI cable issues.

	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
(cherry picked from commit 632b8b044a940e415c6d9bd5235778b0db28add1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/cec/core/cec-adap.c
diff --cc drivers/media/cec/core/cec-adap.c
index 1371346aef33,5741adf09a2e..000000000000
--- a/drivers/media/cec/core/cec-adap.c
+++ b/drivers/media/cec/core/cec-adap.c
@@@ -1581,6 -1608,65 +1608,68 @@@ static void cec_claim_log_addrs(struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Helper function to enable/disable the CEC adapter.
+  *
+  * This function is called with adap->lock held.
+  */
+ int cec_adap_enable(struct cec_adapter *adap)
+ {
+ 	bool enable;
+ 	int ret = 0;
+ 
+ 	enable = adap->monitor_all_cnt || adap->monitor_pin_cnt ||
+ 		 adap->log_addrs.num_log_addrs;
+ 	if (adap->needs_hpd)
+ 		enable = enable && adap->phys_addr != CEC_PHYS_ADDR_INVALID;
+ 
+ 	if (adap->devnode.unregistered)
+ 		enable = false;
+ 
+ 	if (enable == adap->is_enabled)
+ 		return 0;
+ 
+ 	/* serialize adap_enable */
+ 	mutex_lock(&adap->devnode.lock);
+ 	if (enable) {
+ 		adap->last_initiator = 0xff;
+ 		adap->transmit_in_progress = false;
+ 		adap->tx_low_drive_log_cnt = 0;
+ 		adap->tx_error_log_cnt = 0;
+ 		ret = adap->ops->adap_enable(adap, true);
+ 		if (!ret) {
+ 			/*
+ 			 * Enable monitor-all/pin modes if needed. We warn, but
+ 			 * continue if this fails as this is not a critical error.
+ 			 */
+ 			if (adap->monitor_all_cnt)
+ 				WARN_ON(call_op(adap, adap_monitor_all_enable, true));
+ 			if (adap->monitor_pin_cnt)
+ 				WARN_ON(call_op(adap, adap_monitor_pin_enable, true));
+ 		}
+ 	} else {
+ 		/* Disable monitor-all/pin modes if needed (needs_hpd == 1) */
+ 		if (adap->monitor_all_cnt)
+ 			WARN_ON(call_op(adap, adap_monitor_all_enable, false));
+ 		if (adap->monitor_pin_cnt)
+ 			WARN_ON(call_op(adap, adap_monitor_pin_enable, false));
+ 		WARN_ON(adap->ops->adap_enable(adap, false));
+ 		adap->last_initiator = 0xff;
+ 		adap->transmit_in_progress = false;
+ 		adap->transmit_in_progress_aborted = false;
+ 		if (adap->transmitting)
+ 			cec_data_cancel(adap->transmitting, CEC_TX_STATUS_ABORTED, 0);
+ 	}
+ 	if (!ret)
+ 		adap->is_enabled = enable;
+ 	wake_up_interruptible(&adap->kthread_waitq);
+ 	mutex_unlock(&adap->devnode.lock);
+ 	return ret;
+ }
+ 
++>>>>>>> 632b8b044a94 (media: cec: core: count low-drive, error and arb-lost conditions)
  /* Set a new physical address and send an event notifying userspace of this.
   *
   * This function is called with adap->lock held.
@@@ -2211,10 -2291,28 +2300,35 @@@ int cec_adap_status(struct seq_file *fi
  	if (adap->monitor_all_cnt)
  		seq_printf(file, "file handles in Monitor All mode: %u\n",
  			   adap->monitor_all_cnt);
++<<<<<<< HEAD
 +	if (adap->tx_timeouts) {
 +		seq_printf(file, "transmit timeouts: %u\n",
 +			   adap->tx_timeouts);
 +		adap->tx_timeouts = 0;
++=======
+ 	if (adap->monitor_pin_cnt)
+ 		seq_printf(file, "file handles in Monitor Pin mode: %u\n",
+ 			   adap->monitor_pin_cnt);
+ 	if (adap->tx_timeout_cnt) {
+ 		seq_printf(file, "transmit timeout count: %u\n",
+ 			   adap->tx_timeout_cnt);
+ 		adap->tx_timeout_cnt = 0;
+ 	}
+ 	if (adap->tx_low_drive_cnt) {
+ 		seq_printf(file, "transmit low drive count: %u\n",
+ 			   adap->tx_low_drive_cnt);
+ 		adap->tx_low_drive_cnt = 0;
+ 	}
+ 	if (adap->tx_arb_lost_cnt) {
+ 		seq_printf(file, "transmit arbitration lost count: %u\n",
+ 			   adap->tx_arb_lost_cnt);
+ 		adap->tx_arb_lost_cnt = 0;
+ 	}
+ 	if (adap->tx_error_cnt) {
+ 		seq_printf(file, "transmit error count: %u\n",
+ 			   adap->tx_error_cnt);
+ 		adap->tx_error_cnt = 0;
++>>>>>>> 632b8b044a94 (media: cec: core: count low-drive, error and arb-lost conditions)
  	}
  	data = adap->transmitting;
  	if (data)
* Unmerged path drivers/media/cec/core/cec-adap.c
diff --git a/include/media/cec.h b/include/media/cec.h
index c494f37771a8..516f2e29b900 100644
--- a/include/media/cec.h
+++ b/include/media/cec.h
@@ -183,7 +183,20 @@ struct cec_adap_ops {
  *	passthrough mode.
  * @log_addrs:		current logical addresses
  * @conn_info:		current connector info
- * @tx_timeouts:	number of transmit timeouts
+ * @tx_timeout_cnt:	count the number of Timed Out transmits.
+ *			Reset to 0 when this is reported in cec_adap_status().
+ * @tx_low_drive_cnt:	count the number of Low Drive transmits.
+ *			Reset to 0 when this is reported in cec_adap_status().
+ * @tx_error_cnt:	count the number of Error transmits.
+ *			Reset to 0 when this is reported in cec_adap_status().
+ * @tx_arb_lost_cnt:	count the number of Arb Lost transmits.
+ *			Reset to 0 when this is reported in cec_adap_status().
+ * @tx_low_drive_log_cnt: number of logged Low Drive transmits since the
+ *			adapter was enabled. Used to avoid flooding the kernel
+ *			log if this happens a lot.
+ * @tx_error_log_cnt:	number of logged Error transmits since the adapter was
+ *                      enabled. Used to avoid flooding the kernel log if this
+ *                      happens a lot.
  * @notifier:		CEC notifier
  * @pin:		CEC pin status struct
  * @cec_dir:		debugfs cec directory
@@ -234,7 +247,12 @@ struct cec_adapter {
 	struct cec_log_addrs log_addrs;
 	struct cec_connector_info conn_info;
 
-	u32 tx_timeouts;
+	u32 tx_timeout_cnt;
+	u32 tx_low_drive_cnt;
+	u32 tx_error_cnt;
+	u32 tx_arb_lost_cnt;
+	u32 tx_low_drive_log_cnt;
+	u32 tx_error_log_cnt;
 
 #ifdef CONFIG_CEC_NOTIFIER
 	struct cec_notifier *notifier;
