tcp: Fix sign comparison bug in getsockopt(TCP_ZEROCOPY_RECEIVE)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Arjun Roy <arjunroy@google.com>
commit 2107d45f17bedd7dbf4178462da0ac223835a2a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/2107d45f.failed

getsockopt(TCP_ZEROCOPY_RECEIVE) has a bug where we read a
user-provided "len" field of type signed int, and then compare the
value to the result of an "offsetofend" operation, which is unsigned.

Negative values provided by the user will be promoted to large
positive numbers; thus checking that len < offsetofend() will return
false when the intention was that it return true.

Note that while len is originally checked for negative values earlier
on in do_tcp_getsockopt(), subsequent calls to get_user() re-read the
value from userspace which may have changed in the meantime.

Therefore, re-add the check for negative values after the call to
get_user in the handler code for TCP_ZEROCOPY_RECEIVE.

Fixes: c8856c051454 ("tcp-zerocopy: Return inq along with tcp receive zerocopy.")
	Reported-by: kernel test robot <lkp@intel.com>
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Arjun Roy <arjunroy@google.com>
Link: https://lore.kernel.org/r/20210225232628.4033281-1-arjunroy.kdev@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2107d45f17bedd7dbf4178462da0ac223835a2a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index fed129a064e8,dfb6f286c1de..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -3699,12 -4143,26 +3699,17 @@@ static int do_tcp_getsockopt(struct soc
  
  		if (get_user(len, optlen))
  			return -EFAULT;
++<<<<<<< HEAD
 +		if (len != sizeof(zc))
++=======
+ 		if (len < 0 ||
+ 		    len < offsetofend(struct tcp_zerocopy_receive, length))
++>>>>>>> 2107d45f17be (tcp: Fix sign comparison bug in getsockopt(TCP_ZEROCOPY_RECEIVE))
  			return -EINVAL;
 -		if (unlikely(len > sizeof(zc))) {
 -			err = check_zeroed_user(optval + sizeof(zc),
 -						len - sizeof(zc));
 -			if (err < 1)
 -				return err == 0 ? -EINVAL : err;
 -			len = sizeof(zc);
 -			if (put_user(len, optlen))
 -				return -EFAULT;
 -		}
  		if (copy_from_user(&zc, optval, len))
  			return -EFAULT;
 -		if (zc.reserved)
 -			return -EINVAL;
 -		if (zc.msg_flags &  ~(TCP_VALID_ZC_MSG_FLAGS))
 -			return -EINVAL;
  		lock_sock(sk);
 -		err = tcp_zerocopy_receive(sk, &zc, &tss);
 +		err = tcp_zerocopy_receive(sk, &zc);
  		err = BPF_CGROUP_RUN_PROG_GETSOCKOPT_KERN(sk, level, optname,
  							  &zc, &len, err);
  		release_sock(sk);
* Unmerged path net/ipv4/tcp.c
