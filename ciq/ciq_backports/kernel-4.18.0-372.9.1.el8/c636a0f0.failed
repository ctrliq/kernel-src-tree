net/mlx5: Bridge, dynamic entry ageing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit c636a0f0f3f0c6ef715d86118273aa6d62ccc69a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/c636a0f0.failed

Dynamic FDB entries require capability to age out unused entries. Such
entries are either aged out by kernel software bridge implementation or by
hardware switch that offloaded them (and notified the kernel to mark them
as SWITCHDEV_FDB_ADD_TO_BRIDGE). Leaving ageing to kernel bridge would
result it deleting offloaded dynamic FDB entries every ageing_time period
due to packets being processed by hardware and, consecutively, 'used'
timestamp for FDB entry not being updated. However, since hardware doesn't
support ageing, software solution inside the driver is required.

In order to emulate hardware ageing in driver, extend bridge FDB ingress
flows with counter and create delayed br_offloads->update_work task on
bridge offloads workqueue. Run the task every second, update 'used'
timestamp in software bridge dynamic entry by sending
SWITCHDEV_FDB_ADD_TO_BRIDGE for the entry, if it flow hardware counter
lastuse field was changed since last update. If lastuse wasn't changed for
ageing_time period, then delete the FDB entry and notify kernel bridge by
sending SWITCHDEV_FDB_DEL_TO_BRIDGE notification.

Register blocking switchdev notifier callback and handle attribute set
SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME event to allow user to dynamically
configure bridge FDB entry ageing timeout. Save the value per-bridge in
struct mlx5_esw_bridge. Silently ignore
SWITCHDEV_ATTR_ID_PORT_{PRE_}BRIDGE_FLAGS switchdev event since mlx5 bridge
implementation relies on software bridge for implementing necessary
behavior for all of these flags.

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Reviewed-by: Jianbo Liu <jianbol@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit c636a0f0f3f0c6ef715d86118273aa6d62ccc69a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
index de7a68488a9d,14645f24671f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
@@@ -8,6 -9,15 +9,18 @@@
  #include "esw/bridge.h"
  #include "en_rep.h"
  
++<<<<<<< HEAD
++=======
+ #define MLX5_ESW_BRIDGE_UPDATE_INTERVAL 1000
+ 
+ struct mlx5_bridge_switchdev_fdb_work {
+ 	struct work_struct work;
+ 	struct switchdev_notifier_fdb_info fdb_info;
+ 	struct net_device *dev;
+ 	bool add;
+ };
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  static int mlx5_esw_bridge_port_changeupper(struct notifier_block *nb, void *ptr)
  {
  	struct mlx5_esw_bridge_offloads *br_offloads = container_of(nb,
@@@ -65,6 -75,202 +78,205 @@@ static int mlx5_esw_bridge_switchdev_po
  	return notifier_from_errno(err);
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5_esw_bridge_port_obj_attr_set(struct net_device *dev,
+ 					     const struct switchdev_attr *attr,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5e_rep_priv *rpriv;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	struct mlx5e_priv *priv;
+ 	u16 vport_num;
+ 	int err = 0;
+ 
+ 	priv = netdev_priv(dev);
+ 	rpriv = priv->ppriv;
+ 	vport_num = rpriv->rep->vport;
+ 	esw = priv->mdev->priv.eswitch;
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		return PTR_ERR(vport);
+ 
+ 	switch (attr->id) {
+ 	case SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:
+ 		if (attr->u.brport_flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD)) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Flag is not supported");
+ 			err = -EINVAL;
+ 		}
+ 		break;
+ 	case SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:
+ 		break;
+ 	case SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:
+ 		err = mlx5_esw_bridge_ageing_time_set(attr->u.ageing_time, esw, vport);
+ 		break;
+ 	default:
+ 		err = -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int mlx5_esw_bridge_event_blocking(struct notifier_block *unused,
+ 					  unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
+ 	int err;
+ 
+ 	switch (event) {
+ 	case SWITCHDEV_PORT_ATTR_SET:
+ 		err = switchdev_handle_port_attr_set(dev, ptr,
+ 						     mlx5e_eswitch_rep,
+ 						     mlx5_esw_bridge_port_obj_attr_set);
+ 		break;
+ 	default:
+ 		err = 0;
+ 	}
+ 
+ 	return notifier_from_errno(err);
+ }
+ 
+ static void
+ mlx5_esw_bridge_cleanup_switchdev_fdb_work(struct mlx5_bridge_switchdev_fdb_work *fdb_work)
+ {
+ 	dev_put(fdb_work->dev);
+ 	kfree(fdb_work->fdb_info.addr);
+ 	kfree(fdb_work);
+ }
+ 
+ static void mlx5_esw_bridge_switchdev_fdb_event_work(struct work_struct *work)
+ {
+ 	struct mlx5_bridge_switchdev_fdb_work *fdb_work =
+ 		container_of(work, struct mlx5_bridge_switchdev_fdb_work, work);
+ 	struct switchdev_notifier_fdb_info *fdb_info =
+ 		&fdb_work->fdb_info;
+ 	struct net_device *dev = fdb_work->dev;
+ 	struct mlx5e_rep_priv *rpriv;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	struct mlx5e_priv *priv;
+ 	u16 vport_num;
+ 
+ 	rtnl_lock();
+ 
+ 	priv = netdev_priv(dev);
+ 	rpriv = priv->ppriv;
+ 	vport_num = rpriv->rep->vport;
+ 	esw = priv->mdev->priv.eswitch;
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		goto out;
+ 
+ 	if (fdb_work->add)
+ 		mlx5_esw_bridge_fdb_create(dev, esw, vport, fdb_info);
+ 	else
+ 		mlx5_esw_bridge_fdb_remove(dev, esw, vport, fdb_info);
+ 
+ out:
+ 	rtnl_unlock();
+ 	mlx5_esw_bridge_cleanup_switchdev_fdb_work(fdb_work);
+ }
+ 
+ static struct mlx5_bridge_switchdev_fdb_work *
+ mlx5_esw_bridge_init_switchdev_fdb_work(struct net_device *dev, bool add,
+ 					struct switchdev_notifier_fdb_info *fdb_info)
+ {
+ 	struct mlx5_bridge_switchdev_fdb_work *work;
+ 	u8 *addr;
+ 
+ 	work = kzalloc(sizeof(*work), GFP_ATOMIC);
+ 	if (!work)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	INIT_WORK(&work->work, mlx5_esw_bridge_switchdev_fdb_event_work);
+ 	memcpy(&work->fdb_info, fdb_info, sizeof(work->fdb_info));
+ 
+ 	addr = kzalloc(ETH_ALEN, GFP_ATOMIC);
+ 	if (!addr) {
+ 		kfree(work);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 	ether_addr_copy(addr, fdb_info->addr);
+ 	work->fdb_info.addr = addr;
+ 
+ 	dev_hold(dev);
+ 	work->dev = dev;
+ 	work->add = add;
+ 	return work;
+ }
+ 
+ static int mlx5_esw_bridge_switchdev_event(struct notifier_block *nb,
+ 					   unsigned long event, void *ptr)
+ {
+ 	struct mlx5_esw_bridge_offloads *br_offloads = container_of(nb,
+ 								    struct mlx5_esw_bridge_offloads,
+ 								    nb);
+ 	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
+ 	struct switchdev_notifier_fdb_info *fdb_info;
+ 	struct mlx5_bridge_switchdev_fdb_work *work;
+ 	struct switchdev_notifier_info *info = ptr;
+ 	struct net_device *upper;
+ 	struct mlx5e_priv *priv;
+ 
+ 	if (!mlx5e_eswitch_rep(dev))
+ 		return NOTIFY_DONE;
+ 	priv = netdev_priv(dev);
+ 	if (priv->mdev->priv.eswitch != br_offloads->esw)
+ 		return NOTIFY_DONE;
+ 
+ 	if (event == SWITCHDEV_PORT_ATTR_SET) {
+ 		int err = switchdev_handle_port_attr_set(dev, ptr,
+ 							 mlx5e_eswitch_rep,
+ 							 mlx5_esw_bridge_port_obj_attr_set);
+ 		return notifier_from_errno(err);
+ 	}
+ 
+ 	upper = netdev_master_upper_dev_get_rcu(dev);
+ 	if (!upper)
+ 		return NOTIFY_DONE;
+ 	if (!netif_is_bridge_master(upper))
+ 		return NOTIFY_DONE;
+ 
+ 	switch (event) {
+ 	case SWITCHDEV_FDB_ADD_TO_DEVICE:
+ 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
+ 		fdb_info = container_of(info,
+ 					struct switchdev_notifier_fdb_info,
+ 					info);
+ 
+ 		work = mlx5_esw_bridge_init_switchdev_fdb_work(dev,
+ 							       event == SWITCHDEV_FDB_ADD_TO_DEVICE,
+ 							       fdb_info);
+ 		if (IS_ERR(work)) {
+ 			WARN_ONCE(1, "Failed to init switchdev work, err=%ld",
+ 				  PTR_ERR(work));
+ 			return notifier_from_errno(PTR_ERR(work));
+ 		}
+ 
+ 		queue_work(br_offloads->wq, &work->work);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 	return NOTIFY_DONE;
+ }
+ 
+ static void mlx5_esw_bridge_update_work(struct work_struct *work)
+ {
+ 	struct mlx5_esw_bridge_offloads *br_offloads = container_of(work,
+ 								    struct mlx5_esw_bridge_offloads,
+ 								    update_work.work);
+ 
+ 	rtnl_lock();
+ 	mlx5_esw_bridge_update(br_offloads);
+ 	rtnl_unlock();
+ 
+ 	queue_delayed_work(br_offloads->wq, &br_offloads->update_work,
+ 			   msecs_to_jiffies(MLX5_ESW_BRIDGE_UPDATE_INTERVAL));
+ }
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  void mlx5e_rep_bridge_init(struct mlx5e_priv *priv)
  {
  	struct mlx5_esw_bridge_offloads *br_offloads;
@@@ -81,13 -287,46 +293,52 @@@
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	br_offloads->wq = alloc_ordered_workqueue("mlx5_bridge_wq", 0);
+ 	if (!br_offloads->wq) {
+ 		esw_warn(mdev, "Failed to allocate bridge offloads workqueue\n");
+ 		goto err_alloc_wq;
+ 	}
+ 	INIT_DELAYED_WORK(&br_offloads->update_work, mlx5_esw_bridge_update_work);
+ 	queue_delayed_work(br_offloads->wq, &br_offloads->update_work,
+ 			   msecs_to_jiffies(MLX5_ESW_BRIDGE_UPDATE_INTERVAL));
+ 
+ 	br_offloads->nb.notifier_call = mlx5_esw_bridge_switchdev_event;
+ 	err = register_switchdev_notifier(&br_offloads->nb);
+ 	if (err) {
+ 		esw_warn(mdev, "Failed to register switchdev notifier (err=%d)\n", err);
+ 		goto err_register_swdev;
+ 	}
+ 
+ 	br_offloads->nb_blk.notifier_call = mlx5_esw_bridge_event_blocking;
+ 	err = register_switchdev_blocking_notifier(&br_offloads->nb_blk);
+ 	if (err) {
+ 		esw_warn(mdev, "Failed to register blocking switchdev notifier (err=%d)\n", err);
+ 		goto err_register_swdev_blk;
+ 	}
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  	br_offloads->netdev_nb.notifier_call = mlx5_esw_bridge_switchdev_port_event;
  	err = register_netdevice_notifier(&br_offloads->netdev_nb);
  	if (err) {
  		esw_warn(mdev, "Failed to register bridge offloads netdevice notifier (err=%d)\n",
  			 err);
 -		goto err_register_netdev;
 +		mlx5_esw_bridge_cleanup(esw);
  	}
++<<<<<<< HEAD
++=======
+ 	return;
+ 
+ err_register_netdev:
+ 	unregister_switchdev_blocking_notifier(&br_offloads->nb_blk);
+ err_register_swdev_blk:
+ 	unregister_switchdev_notifier(&br_offloads->nb);
+ err_register_swdev:
+ 	destroy_workqueue(br_offloads->wq);
+ err_alloc_wq:
+ 	mlx5_esw_bridge_cleanup(esw);
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  }
  
  void mlx5e_rep_bridge_cleanup(struct mlx5e_priv *priv)
@@@ -102,6 -341,10 +353,13 @@@
  		return;
  
  	unregister_netdevice_notifier(&br_offloads->netdev_nb);
++<<<<<<< HEAD
++=======
+ 	unregister_switchdev_blocking_notifier(&br_offloads->nb_blk);
+ 	unregister_switchdev_notifier(&br_offloads->nb);
+ 	cancel_delayed_work(&br_offloads->update_work);
+ 	destroy_workqueue(br_offloads->wq);
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  	rtnl_lock();
  	mlx5_esw_bridge_cleanup(esw);
  	rtnl_unlock();
diff --cc drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
index b503562f97d0,557dac5e9745..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
@@@ -3,6 -3,8 +3,11 @@@
  
  #include <linux/netdevice.h>
  #include <linux/list.h>
++<<<<<<< HEAD
++=======
+ #include <linux/rhashtable.h>
+ #include <linux/if_bridge.h>
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  #include <net/switchdev.h>
  #include "bridge.h"
  #include "eswitch.h"
@@@ -21,6 -23,36 +26,39 @@@ enum 
  	MLX5_ESW_BRIDGE_LEVEL_EGRESS_TABLE,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_esw_bridge_fdb_key {
+ 	unsigned char addr[ETH_ALEN];
+ 	u16 vid;
+ };
+ 
+ enum {
+ 	MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER = BIT(0),
+ };
+ 
+ struct mlx5_esw_bridge_fdb_entry {
+ 	struct mlx5_esw_bridge_fdb_key key;
+ 	struct rhash_head ht_node;
+ 	struct net_device *dev;
+ 	struct list_head list;
+ 	u16 vport_num;
+ 	u16 flags;
+ 
+ 	struct mlx5_flow_handle *ingress_handle;
+ 	struct mlx5_fc *ingress_counter;
+ 	unsigned long lastuse;
+ 	struct mlx5_flow_handle *egress_handle;
+ };
+ 
+ static const struct rhashtable_params fdb_ht_params = {
+ 	.key_offset = offsetof(struct mlx5_esw_bridge_fdb_entry, key),
+ 	.key_len = sizeof(struct mlx5_esw_bridge_fdb_key),
+ 	.head_offset = offsetof(struct mlx5_esw_bridge_fdb_entry, ht_node),
+ 	.automatic_shrinking = true,
+ };
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  struct mlx5_esw_bridge {
  	int ifindex;
  	int refcnt;
@@@ -28,8 -60,25 +66,9 @@@
  
  	struct mlx5_flow_table *egress_ft;
  	struct mlx5_flow_group *egress_mac_fg;
+ 	unsigned long ageing_time;
  };
  
 -static void
 -mlx5_esw_bridge_fdb_offload_notify(struct net_device *dev, const unsigned char *addr, u16 vid,
 -				   unsigned long val)
 -{
 -	struct switchdev_notifier_fdb_info send_info;
 -
 -	send_info.addr = addr;
 -	send_info.vid = vid;
 -	send_info.offloaded = true;
 -	call_switchdev_notifiers(val, dev, &send_info.info, NULL);
 -}
 -
  static struct mlx5_flow_table *
  mlx5_esw_bridge_table_create(int max_fte, u32 level, struct mlx5_eswitch *esw)
  {
@@@ -194,6 -246,85 +233,88 @@@ mlx5_esw_bridge_egress_table_cleanup(st
  	mlx5_destroy_flow_table(bridge->egress_ft);
  }
  
++<<<<<<< HEAD
++=======
+ static struct mlx5_flow_handle *
+ mlx5_esw_bridge_ingress_flow_create(u16 vport_num, const unsigned char *addr, u16 vid,
+ 				    u32 counter_id, struct mlx5_esw_bridge *bridge)
+ {
+ 	struct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;
+ 	struct mlx5_flow_act flow_act = {
+ 		.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_COUNT,
+ 		.flags = FLOW_ACT_NO_APPEND,
+ 	};
+ 	struct mlx5_flow_destination dests[2] = {};
+ 	struct mlx5_flow_spec *rule_spec;
+ 	struct mlx5_flow_handle *handle;
+ 	u8 *smac_v, *smac_c;
+ 
+ 	rule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);
+ 	if (!rule_spec)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	rule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_2;
+ 
+ 	smac_v = MLX5_ADDR_OF(fte_match_param, rule_spec->match_value,
+ 			      outer_headers.smac_47_16);
+ 	ether_addr_copy(smac_v, addr);
+ 	smac_c = MLX5_ADDR_OF(fte_match_param, rule_spec->match_criteria,
+ 			      outer_headers.smac_47_16);
+ 	eth_broadcast_addr(smac_c);
+ 
+ 	MLX5_SET(fte_match_param, rule_spec->match_criteria,
+ 		 misc_parameters_2.metadata_reg_c_0, mlx5_eswitch_get_vport_metadata_mask());
+ 	MLX5_SET(fte_match_param, rule_spec->match_value, misc_parameters_2.metadata_reg_c_0,
+ 		 mlx5_eswitch_get_vport_metadata_for_match(br_offloads->esw, vport_num));
+ 
+ 	dests[0].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 	dests[0].ft = bridge->egress_ft;
+ 	dests[1].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
+ 	dests[1].counter_id = counter_id;
+ 
+ 	handle = mlx5_add_flow_rules(br_offloads->ingress_ft, rule_spec, &flow_act, dests,
+ 				     ARRAY_SIZE(dests));
+ 
+ 	kvfree(rule_spec);
+ 	return handle;
+ }
+ 
+ static struct mlx5_flow_handle *
+ mlx5_esw_bridge_egress_flow_create(u16 vport_num, const unsigned char *addr, u16 vid,
+ 				   struct mlx5_esw_bridge *bridge)
+ {
+ 	struct mlx5_flow_destination dest = {
+ 		.type = MLX5_FLOW_DESTINATION_TYPE_VPORT,
+ 		.vport.num = vport_num,
+ 	};
+ 	struct mlx5_flow_act flow_act = {
+ 		.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,
+ 		.flags = FLOW_ACT_NO_APPEND,
+ 	};
+ 	struct mlx5_flow_spec *rule_spec;
+ 	struct mlx5_flow_handle *handle;
+ 	u8 *dmac_v, *dmac_c;
+ 
+ 	rule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);
+ 	if (!rule_spec)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	rule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
+ 
+ 	dmac_v = MLX5_ADDR_OF(fte_match_param, rule_spec->match_value,
+ 			      outer_headers.dmac_47_16);
+ 	ether_addr_copy(dmac_v, addr);
+ 	dmac_c = MLX5_ADDR_OF(fte_match_param, rule_spec->match_criteria,
+ 			      outer_headers.dmac_47_16);
+ 	eth_broadcast_addr(dmac_c);
+ 
+ 	handle = mlx5_add_flow_rules(bridge->egress_ft, rule_spec, &flow_act, &dest, 1);
+ 
+ 	kvfree(rule_spec);
+ 	return handle;
+ }
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  static struct mlx5_esw_bridge *mlx5_esw_bridge_create(int ifindex,
  						      struct mlx5_esw_bridge_offloads *br_offloads)
  {
@@@ -208,8 -340,14 +329,9 @@@
  	if (err)
  		goto err_egress_tbl;
  
 -	err = rhashtable_init(&bridge->fdb_ht, &fdb_ht_params);
 -	if (err)
 -		goto err_fdb_ht;
 -
 -	INIT_LIST_HEAD(&bridge->fdb_list);
  	bridge->ifindex = ifindex;
  	bridge->refcnt = 1;
+ 	bridge->ageing_time = BR_DEFAULT_AGEING_TIME;
  	list_add(&bridge->list, &br_offloads->bridges);
  
  	return bridge;
@@@ -265,6 -406,98 +387,101 @@@ mlx5_esw_bridge_lookup(int ifindex, str
  	return bridge;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mlx5_esw_bridge_fdb_entry_cleanup(struct mlx5_esw_bridge_fdb_entry *entry,
+ 				  struct mlx5_esw_bridge *bridge)
+ {
+ 	rhashtable_remove_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);
+ 	mlx5_del_flow_rules(entry->egress_handle);
+ 	mlx5_del_flow_rules(entry->ingress_handle);
+ 	mlx5_fc_destroy(bridge->br_offloads->esw->dev, entry->ingress_counter);
+ 	list_del(&entry->list);
+ 	kvfree(entry);
+ }
+ 
+ static struct mlx5_esw_bridge_fdb_entry *
+ mlx5_esw_bridge_fdb_entry_init(struct net_device *dev, u16 vport_num, const unsigned char *addr,
+ 			       u16 vid, bool added_by_user, struct mlx5_eswitch *esw,
+ 			       struct mlx5_esw_bridge *bridge)
+ {
+ 	struct mlx5_esw_bridge_fdb_entry *entry;
+ 	struct mlx5_flow_handle *handle;
+ 	struct mlx5_fc *counter;
+ 	struct mlx5e_priv *priv;
+ 	int err;
+ 
+ 	priv = netdev_priv(dev);
+ 	entry = kvzalloc(sizeof(*entry), GFP_KERNEL);
+ 	if (!entry)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	ether_addr_copy(entry->key.addr, addr);
+ 	entry->key.vid = vid;
+ 	entry->dev = dev;
+ 	entry->vport_num = vport_num;
+ 	entry->lastuse = jiffies;
+ 	if (added_by_user)
+ 		entry->flags |= MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER;
+ 
+ 	counter = mlx5_fc_create(priv->mdev, true);
+ 	if (IS_ERR(counter)) {
+ 		err = PTR_ERR(counter);
+ 		goto err_ingress_fc_create;
+ 	}
+ 	entry->ingress_counter = counter;
+ 
+ 	handle = mlx5_esw_bridge_ingress_flow_create(vport_num, addr, vid, mlx5_fc_id(counter),
+ 						     bridge);
+ 	if (IS_ERR(handle)) {
+ 		err = PTR_ERR(handle);
+ 		esw_warn(esw->dev, "Failed to create ingress flow(vport=%u,err=%d)\n",
+ 			 vport_num, err);
+ 		goto err_ingress_flow_create;
+ 	}
+ 	entry->ingress_handle = handle;
+ 
+ 	handle = mlx5_esw_bridge_egress_flow_create(vport_num, addr, vid, bridge);
+ 	if (IS_ERR(handle)) {
+ 		err = PTR_ERR(handle);
+ 		esw_warn(esw->dev, "Failed to create egress flow(vport=%u,err=%d)\n",
+ 			 vport_num, err);
+ 		goto err_egress_flow_create;
+ 	}
+ 	entry->egress_handle = handle;
+ 
+ 	err = rhashtable_insert_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);
+ 	if (err) {
+ 		esw_warn(esw->dev, "Failed to insert FDB flow(vport=%u,err=%d)\n", vport_num, err);
+ 		goto err_ht_init;
+ 	}
+ 
+ 	list_add(&entry->list, &bridge->fdb_list);
+ 	return entry;
+ 
+ err_ht_init:
+ 	mlx5_del_flow_rules(entry->egress_handle);
+ err_egress_flow_create:
+ 	mlx5_del_flow_rules(entry->ingress_handle);
+ err_ingress_flow_create:
+ 	mlx5_fc_destroy(priv->mdev, entry->ingress_counter);
+ err_ingress_fc_create:
+ 	kvfree(entry);
+ 	return ERR_PTR(err);
+ }
+ 
+ int mlx5_esw_bridge_ageing_time_set(unsigned long ageing_time, struct mlx5_eswitch *esw,
+ 				    struct mlx5_vport *vport)
+ {
+ 	if (!vport->bridge)
+ 		return -EINVAL;
+ 
+ 	vport->bridge->ageing_time = ageing_time;
+ 	return 0;
+ }
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  static int mlx5_esw_bridge_vport_init(struct mlx5_esw_bridge *bridge,
  				      struct mlx5_vport *vport)
  {
@@@ -311,6 -553,92 +528,95 @@@ int mlx5_esw_bridge_vport_unlink(int if
  	return mlx5_esw_bridge_vport_cleanup(br_offloads, vport);
  }
  
++<<<<<<< HEAD
++=======
+ void mlx5_esw_bridge_fdb_create(struct net_device *dev, struct mlx5_eswitch *esw,
+ 				struct mlx5_vport *vport,
+ 				struct switchdev_notifier_fdb_info *fdb_info)
+ {
+ 	struct mlx5_esw_bridge *bridge = vport->bridge;
+ 	struct mlx5_esw_bridge_fdb_entry *entry;
+ 	u16 vport_num = vport->vport;
+ 
+ 	if (!bridge) {
+ 		esw_info(esw->dev, "Vport is not assigned to bridge (vport=%u)\n", vport_num);
+ 		return;
+ 	}
+ 
+ 	entry = mlx5_esw_bridge_fdb_entry_init(dev, vport_num, fdb_info->addr, fdb_info->vid,
+ 					       fdb_info->added_by_user, esw, bridge);
+ 	if (IS_ERR(entry))
+ 		return;
+ 
+ 	if (entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER)
+ 		mlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,
+ 						   SWITCHDEV_FDB_OFFLOADED);
+ 	else
+ 		/* Take over dynamic entries to prevent kernel bridge from aging them out. */
+ 		mlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,
+ 						   SWITCHDEV_FDB_ADD_TO_BRIDGE);
+ }
+ 
+ void mlx5_esw_bridge_fdb_remove(struct net_device *dev, struct mlx5_eswitch *esw,
+ 				struct mlx5_vport *vport,
+ 				struct switchdev_notifier_fdb_info *fdb_info)
+ {
+ 	struct mlx5_esw_bridge *bridge = vport->bridge;
+ 	struct mlx5_esw_bridge_fdb_entry *entry;
+ 	struct mlx5_esw_bridge_fdb_key key;
+ 	u16 vport_num = vport->vport;
+ 
+ 	if (!bridge) {
+ 		esw_warn(esw->dev, "Vport is not assigned to bridge (vport=%u)\n", vport_num);
+ 		return;
+ 	}
+ 
+ 	ether_addr_copy(key.addr, fdb_info->addr);
+ 	key.vid = fdb_info->vid;
+ 	entry = rhashtable_lookup_fast(&bridge->fdb_ht, &key, fdb_ht_params);
+ 	if (!entry) {
+ 		esw_warn(esw->dev,
+ 			 "FDB entry with specified key not found (MAC=%pM,vid=%u,vport=%u)\n",
+ 			 key.addr, key.vid, vport_num);
+ 		return;
+ 	}
+ 
+ 	if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER))
+ 		mlx5_esw_bridge_fdb_offload_notify(dev, entry->key.addr, entry->key.vid,
+ 						   SWITCHDEV_FDB_DEL_TO_BRIDGE);
+ 	mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
+ }
+ 
+ void mlx5_esw_bridge_update(struct mlx5_esw_bridge_offloads *br_offloads)
+ {
+ 	struct mlx5_esw_bridge_fdb_entry *entry, *tmp;
+ 	struct mlx5_esw_bridge *bridge;
+ 
+ 	list_for_each_entry(bridge, &br_offloads->bridges, list) {
+ 		list_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list) {
+ 			unsigned long lastuse =
+ 				(unsigned long)mlx5_fc_query_lastuse(entry->ingress_counter);
+ 
+ 			if (entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER)
+ 				continue;
+ 
+ 			if (time_after(lastuse, entry->lastuse)) {
+ 				entry->lastuse = lastuse;
+ 				/* refresh existing bridge entry */
+ 				mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
+ 								   entry->key.vid,
+ 								   SWITCHDEV_FDB_ADD_TO_BRIDGE);
+ 			} else if (time_is_before_jiffies(entry->lastuse + bridge->ageing_time)) {
+ 				mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
+ 								   entry->key.vid,
+ 								   SWITCHDEV_FDB_DEL_TO_BRIDGE);
+ 				mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
+ 			}
+ 		}
+ 	}
+ }
+ 
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  static void mlx5_esw_bridge_flush(struct mlx5_esw_bridge_offloads *br_offloads)
  {
  	struct mlx5_eswitch *esw = br_offloads->esw;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
index 319b6f1db0ba,07726ae55b2b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
@@@ -15,6 -16,10 +16,13 @@@ struct mlx5_esw_bridge_offloads 
  	struct mlx5_eswitch *esw;
  	struct list_head bridges;
  	struct notifier_block netdev_nb;
++<<<<<<< HEAD
++=======
+ 	struct notifier_block nb_blk;
+ 	struct notifier_block nb;
+ 	struct workqueue_struct *wq;
+ 	struct delayed_work update_work;
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  
  	struct mlx5_flow_table *ingress_ft;
  	struct mlx5_flow_group *ingress_mac_fg;
@@@ -26,5 -31,14 +34,17 @@@ int mlx5_esw_bridge_vport_link(int ifin
  			       struct mlx5_vport *vport, struct netlink_ext_ack *extack);
  int mlx5_esw_bridge_vport_unlink(int ifindex, struct mlx5_esw_bridge_offloads *br_offloads,
  				 struct mlx5_vport *vport, struct netlink_ext_ack *extack);
++<<<<<<< HEAD
++=======
+ void mlx5_esw_bridge_fdb_create(struct net_device *dev, struct mlx5_eswitch *esw,
+ 				struct mlx5_vport *vport,
+ 				struct switchdev_notifier_fdb_info *fdb_info);
+ void mlx5_esw_bridge_fdb_remove(struct net_device *dev, struct mlx5_eswitch *esw,
+ 				struct mlx5_vport *vport,
+ 				struct switchdev_notifier_fdb_info *fdb_info);
+ void mlx5_esw_bridge_update(struct mlx5_esw_bridge_offloads *br_offloads);
+ int mlx5_esw_bridge_ageing_time_set(unsigned long ageing_time, struct mlx5_eswitch *esw,
+ 				    struct mlx5_vport *vport);
++>>>>>>> c636a0f0f3f0 (net/mlx5: Bridge, dynamic entry ageing)
  
  #endif /* __MLX5_ESW_BRIDGE_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/bridge.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.h
