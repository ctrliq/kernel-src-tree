ice: Cleanup after ice_status removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Tony Nguyen <anthony.l.nguyen@intel.com>
commit 5518ac2a64423f226e922b6719cf0eb62c31e141
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/5518ac2a.failed

Clean up code after changing ice_status to int. Rearrange to fix reverse
Christmas tree and pull lines up where applicable.

	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
(cherry picked from commit 5518ac2a64423f226e922b6719cf0eb62c31e141)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_common.c
#	drivers/net/ethernet/intel/ice/ice_controlq.c
#	drivers/net/ethernet/intel/ice/ice_dcb.c
#	drivers/net/ethernet/intel/ice/ice_dcb.h
#	drivers/net/ethernet/intel/ice/ice_devlink.c
#	drivers/net/ethernet/intel/ice/ice_ethtool.c
#	drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
#	drivers/net/ethernet/intel/ice/ice_fdir.c
#	drivers/net/ethernet/intel/ice/ice_fdir.h
#	drivers/net/ethernet/intel/ice/ice_flex_pipe.c
#	drivers/net/ethernet/intel/ice/ice_flex_pipe.h
#	drivers/net/ethernet/intel/ice/ice_flow.c
#	drivers/net/ethernet/intel/ice/ice_flow.h
#	drivers/net/ethernet/intel/ice/ice_fltr.c
#	drivers/net/ethernet/intel/ice/ice_fltr.h
#	drivers/net/ethernet/intel/ice/ice_fw_update.c
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_lib.h
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_nvm.c
#	drivers/net/ethernet/intel/ice/ice_nvm.h
#	drivers/net/ethernet/intel/ice/ice_sched.c
#	drivers/net/ethernet/intel/ice/ice_sched.h
#	drivers/net/ethernet/intel/ice/ice_switch.c
#	drivers/net/ethernet/intel/ice/ice_switch.h
#	drivers/net/ethernet/intel/ice/ice_tc_lib.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice_common.c
index 1c7ece0676d5,2728cea1a490..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_common.c
+++ b/drivers/net/ethernet/intel/ice/ice_common.c
@@@ -164,8 -183,8 +164,12 @@@ ice_aq_get_phy_caps(struct ice_port_inf
  	struct ice_aqc_get_phy_caps *cmd;
  	u16 pcaps_size = sizeof(*pcaps);
  	struct ice_aq_desc desc;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status;
  
  	cmd = &desc.params.get_phy;
  
@@@ -409,12 -428,12 +413,16 @@@ ice_aq_get_link_info(struct ice_port_in
  	struct ice_fc_info *hw_fc_info;
  	bool tx_pause, rx_pause;
  	struct ice_aq_desc desc;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
  	u16 cmd_flags;
+ 	int status;
  
  	if (!pi)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  	hw = pi->hw;
  	li_old = &pi->phy.link_info_old;
  	hw_media_type = &pi->phy.media_type;
@@@ -646,11 -665,11 +654,15 @@@ static void ice_cleanup_fltr_mgmt_struc
   * ice_get_fw_log_cfg - get FW logging configuration
   * @hw: pointer to the HW struct
   */
 -static int ice_get_fw_log_cfg(struct ice_hw *hw)
 +static enum ice_status ice_get_fw_log_cfg(struct ice_hw *hw)
  {
  	struct ice_aq_desc desc;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	__le16 *config;
+ 	int status;
  	u16 size;
  
  	size = sizeof(*config) * ICE_AQC_FW_LOG_ID_MAX;
@@@ -718,10 -737,9 +730,13 @@@
   * messages from FW to SW. Interrupts are typically disabled during the device's
   * initialization phase.
   */
 -static int ice_cfg_fw_log(struct ice_hw *hw, bool enable)
 +static enum ice_status ice_cfg_fw_log(struct ice_hw *hw, bool enable)
  {
  	struct ice_aqc_fw_logging *cmd;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 i, chgs = 0, len = 0;
  	struct ice_aq_desc desc;
  	__le16 *data = NULL;
@@@ -884,12 -903,12 +900,16 @@@ static void ice_get_itr_intrl_gran(stru
   * ice_init_hw - main hardware initialization routine
   * @hw: pointer to the hardware structure
   */
 -int ice_init_hw(struct ice_hw *hw)
 +enum ice_status ice_init_hw(struct ice_hw *hw)
  {
  	struct ice_aqc_get_phy_caps_data *pcaps;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 mac_buf_len;
  	void *mac_buf;
+ 	int status;
  
  	/* Set MAC type based on DeviceID */
  	status = ice_set_mac_type(hw);
@@@ -1439,7 -1457,6 +1459,10 @@@ ice_sq_send_cmd_retry(struct ice_hw *hw
  		      struct ice_sq_cd *cd)
  {
  	struct ice_aq_desc desc_cpy;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool is_cmd_for_retry;
  	u8 *buf_cpy = NULL;
  	u8 idx = 0;
@@@ -1802,16 -1820,15 +1826,24 @@@ ice_acquire_res_exit
   */
  void ice_release_res(struct ice_hw *hw, enum ice_aq_res_ids res)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 total_delay = 0;
+ 	int status;
  
  	status = ice_aq_release_res(hw, res, 0, NULL);
  
  	/* there are some rare cases when trying to release the resource
  	 * results in an admin queue timeout, so handle them correctly
  	 */
++<<<<<<< HEAD
 +	while ((status == ICE_ERR_AQ_TIMEOUT) &&
 +	       (total_delay < hw->adminq.sq_cmd_timeout)) {
++=======
+ 	while ((status == -EIO) && (total_delay < hw->adminq.sq_cmd_timeout)) {
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  		mdelay(1);
  		status = ice_aq_release_res(hw, res, 0, NULL);
  		total_delay++;
@@@ -1866,8 -1883,8 +1898,12 @@@ enum ice_statu
  ice_alloc_hw_res(struct ice_hw *hw, u16 type, u16 num, bool btm, u16 *res)
  {
  	struct ice_aqc_alloc_free_res_elem *buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_len;
+ 	int status;
  
  	buf_len = struct_size(buf, elem, num);
  	buf = kzalloc(buf_len, GFP_KERNEL);
@@@ -1900,11 -1917,11 +1936,15 @@@ ice_alloc_res_exit
   * @num: number of resources
   * @res: pointer to array that contains the resources to free
   */
 -int ice_free_hw_res(struct ice_hw *hw, u16 type, u16 num, u16 *res)
 +enum ice_status ice_free_hw_res(struct ice_hw *hw, u16 type, u16 num, u16 *res)
  {
  	struct ice_aqc_alloc_free_res_elem *buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_len;
+ 	int status;
  
  	buf_len = struct_size(buf, elem, num);
  	buf = kzalloc(buf_len, GFP_KERNEL);
@@@ -2497,12 -2514,12 +2537,16 @@@ ice_aq_list_caps(struct ice_hw *hw, voi
   * Read the device capabilities and extract them into the dev_caps structure
   * for later use.
   */
 -int
 +enum ice_status
  ice_discover_dev_caps(struct ice_hw *hw, struct ice_hw_dev_caps *dev_caps)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 cap_count = 0;
  	void *cbuf;
+ 	int status;
  
  	cbuf = kzalloc(ICE_AQ_MAX_BUF_LEN, GFP_KERNEL);
  	if (!cbuf)
@@@ -2531,12 -2548,12 +2575,16 @@@
   * Read the function capabilities and extract them into the func_caps structure
   * for later use.
   */
 -static int
 +static enum ice_status
  ice_discover_func_caps(struct ice_hw *hw, struct ice_hw_func_caps *func_caps)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 cap_count = 0;
  	void *cbuf;
+ 	int status;
  
  	cbuf = kzalloc(ICE_AQ_MAX_BUF_LEN, GFP_KERNEL);
  	if (!cbuf)
@@@ -3102,11 -3119,11 +3150,15 @@@ ice_set_fc(struct ice_port_info *pi, u
  {
  	struct ice_aqc_set_phy_cfg_data cfg = { 0 };
  	struct ice_aqc_get_phy_caps_data *pcaps;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status;
  
  	if (!pi || !aq_failures)
 -		return -EINVAL;
 +		return ICE_ERR_BAD_PTR;
  
  	*aq_failures = 0;
  	hw = pi->hw;
@@@ -3243,11 -3260,11 +3295,15 @@@ ice_cfg_phy_fec(struct ice_port_info *p
  		enum ice_fec_mode fec)
  {
  	struct ice_aqc_get_phy_caps_data *pcaps;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status;
  
  	if (!pi || !cfg)
 -		return -EINVAL;
 +		return ICE_ERR_BAD_PTR;
  
  	hw = pi->hw;
  
@@@ -3634,10 -3651,9 +3690,16 @@@ ice_aq_set_rss_lut(struct ice_hw *hw, s
   *
   * get (0x0B04) or set (0x0B02) the RSS key per VSI
   */
++<<<<<<< HEAD
 +static enum
 +ice_status __ice_aq_get_set_rss_key(struct ice_hw *hw, u16 vsi_id,
 +				    struct ice_aqc_get_set_rss_keys *key,
 +				    bool set)
++=======
+ static int
+ __ice_aq_get_set_rss_key(struct ice_hw *hw, u16 vsi_id,
+ 			 struct ice_aqc_get_set_rss_keys *key, bool set)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_aqc_get_set_rss_key *cmd_resp;
  	u16 key_size = sizeof(*key);
@@@ -3776,8 -3792,8 +3838,12 @@@ ice_aq_dis_lan_txq(struct ice_hw *hw, u
  	struct ice_aqc_dis_txq_item *item;
  	struct ice_aqc_dis_txqs *cmd;
  	struct ice_aq_desc desc;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 i, sz = 0;
+ 	int status;
  
  	cmd = &desc.params.dis_txqs;
  	ice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_dis_txqs);
@@@ -4173,14 -4188,14 +4239,18 @@@ ice_ena_vsi_txq(struct ice_port_info *p
  	struct ice_aqc_txsched_elem_data node = { 0 };
  	struct ice_sched_node *parent;
  	struct ice_q_ctx *q_ctx;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status;
  
  	if (!pi || pi->port_state != ICE_SCHED_PORT_STATE_READY)
 -		return -EIO;
 +		return ICE_ERR_CFG;
  
  	if (num_qgrps > 1 || buf->num_txqs > 1)
 -		return -ENOSPC;
 +		return ICE_ERR_MAX_LIMIT;
  
  	hw = pi->hw;
  
@@@ -4276,9 -4291,9 +4346,13 @@@ ice_dis_vsi_txq(struct ice_port_info *p
  		enum ice_disq_rst_src rst_src, u16 vmvf_num,
  		struct ice_sq_cd *cd)
  {
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_DOES_NOT_EXIST;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_aqc_dis_txq_item *qg_list;
  	struct ice_q_ctx *q_ctx;
+ 	int status = -ENOENT;
  	struct ice_hw *hw;
  	u16 i, buf_size;
  
@@@ -4431,9 -4445,9 +4505,13 @@@ ice_ena_vsi_rdma_qset(struct ice_port_i
  	struct ice_aqc_txsched_elem_data node = { 0 };
  	struct ice_aqc_add_rdma_qset_data *buf;
  	struct ice_sched_node *parent;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
  	u16 i, buf_size;
+ 	int status;
  	int ret;
  
  	if (!pi || pi->port_state != ICE_SCHED_PORT_STATE_READY)
@@@ -4508,8 -4522,8 +4586,12 @@@ ice_dis_vsi_rdma_qset(struct ice_port_i
  		      u16 *q_id)
  {
  	struct ice_aqc_dis_txq_item *qg_list;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status = 0;
  	u16 qg_size;
  	int i;
  
diff --cc drivers/net/ethernet/intel/ice/ice_controlq.c
index 03bdb125be36,6bcfee295991..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_controlq.c
+++ b/drivers/net/ethernet/intel/ice/ice_controlq.c
@@@ -295,8 -295,7 +295,12 @@@ ice_cfg_cq_regs(struct ice_hw *hw, stru
   *
   * Configure base address and length registers for the transmit queue
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_cfg_sq_regs(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++=======
+ static int ice_cfg_sq_regs(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_cfg_cq_regs(hw, &cq->sq, cq->num_sq_entries);
  }
@@@ -308,10 -307,9 +312,14 @@@
   *
   * Configure base address and length registers for the receive (event queue)
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_cfg_rq_regs(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++=======
+ static int ice_cfg_rq_regs(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
 -	int status;
 +	enum ice_status status;
  
  	status = ice_cfg_cq_regs(hw, &cq->rq, cq->num_rq_entries);
  	if (status)
@@@ -474,10 -472,9 +482,14 @@@ init_ctrlq_exit
   *
   * The main shutdown routine for the Control Transmit Queue
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_shutdown_sq(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++=======
+ static int ice_shutdown_sq(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
 -	int ret_code = 0;
 +	enum ice_status ret_code = 0;
  
  	mutex_lock(&cq->sq_lock);
  
@@@ -541,10 -538,9 +553,14 @@@ static bool ice_aq_ver_check(struct ice
   *
   * The main shutdown routine for the Control Receive Queue
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_shutdown_rq(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++=======
+ static int ice_shutdown_rq(struct ice_hw *hw, struct ice_ctl_q_info *cq)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
 -	int ret_code = 0;
 +	enum ice_status ret_code = 0;
  
  	mutex_lock(&cq->rq_lock);
  
@@@ -751,10 -747,10 +767,14 @@@ void ice_shutdown_all_ctrlq(struct ice_
   *
   * NOTE: this function does not initialize the controlq locks.
   */
 -int ice_init_all_ctrlq(struct ice_hw *hw)
 +enum ice_status ice_init_all_ctrlq(struct ice_hw *hw)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 retry = 0;
+ 	int status;
  
  	/* Init FW admin queue */
  	do {
@@@ -970,9 -966,9 +990,13 @@@ ice_sq_send_cmd(struct ice_hw *hw, stru
  	struct ice_dma_mem *dma_buf = NULL;
  	struct ice_aq_desc *desc_on_ring;
  	bool cmd_completed = false;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_sq_cd *details;
  	u32 total_delay = 0;
+ 	int status = 0;
  	u16 retval = 0;
  	u32 val = 0;
  
@@@ -1160,9 -1156,9 +1184,13 @@@ ice_clean_rq_elem(struct ice_hw *hw, st
  {
  	u16 ntc = cq->rq.next_to_clean;
  	enum ice_aq_err rq_last_status;
++<<<<<<< HEAD
 +	enum ice_status ret_code = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_aq_desc *desc;
  	struct ice_dma_mem *bi;
+ 	int ret_code = 0;
  	u16 desc_idx;
  	u16 datalen;
  	u16 flags;
diff --cc drivers/net/ethernet/intel/ice/ice_dcb.c
index 241427cd9bc0,0b146a0d4205..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_dcb.c
+++ b/drivers/net/ethernet/intel/ice/ice_dcb.c
@@@ -117,8 -116,7 +117,12 @@@ ice_aq_stop_lldp(struct ice_hw *hw, boo
   *
   * Start the embedded LLDP Agent on all ports. (0x0A06)
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_aq_start_lldp(struct ice_hw *hw, bool persist, struct ice_sq_cd *cd)
++=======
+ int ice_aq_start_lldp(struct ice_hw *hw, bool persist, struct ice_sq_cd *cd)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_aqc_lldp_start *cmd;
  	struct ice_aq_desc desc;
@@@ -598,12 -596,11 +602,19 @@@ ice_parse_org_tlv(struct ice_lldp_org_t
   *
   * Parse DCB configuration from the LLDPDU
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_lldp_to_dcb_cfg(u8 *lldpmib, struct ice_dcbx_cfg *dcbcfg)
 +{
 +	struct ice_lldp_org_tlv *tlv;
 +	enum ice_status ret = 0;
++=======
+ static int ice_lldp_to_dcb_cfg(u8 *lldpmib, struct ice_dcbx_cfg *dcbcfg)
+ {
+ 	struct ice_lldp_org_tlv *tlv;
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 offset = 0;
+ 	int ret = 0;
  	u16 typelen;
  	u16 type;
  	u16 len;
@@@ -653,8 -650,8 +664,12 @@@ enum ice_statu
  ice_aq_get_dcb_cfg(struct ice_hw *hw, u8 mib_type, u8 bridgetype,
  		   struct ice_dcbx_cfg *dcbcfg)
  {
++<<<<<<< HEAD
 +	enum ice_status ret;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 *lldpmib;
+ 	int ret;
  
  	/* Allocate the LLDPDU */
  	lldpmib = devm_kzalloc(ice_hw_to_dev(hw), ICE_LLDPDU_SIZE, GFP_KERNEL);
@@@ -692,9 -689,9 +707,13 @@@ ice_aq_start_stop_dcbx(struct ice_hw *h
  		       bool *dcbx_agent_status, struct ice_sq_cd *cd)
  {
  	struct ice_aqc_lldp_stop_start_specific_agent *cmd;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_aq_desc desc;
  	u16 opcode;
+ 	int status;
  
  	cmd = &desc.params.lldp_agent_ctrl;
  
@@@ -903,14 -900,13 +922,18 @@@ ice_cee_to_dcb_cfg(struct ice_aqc_get_c
   *
   * Get IEEE or CEE mode DCB configuration from the Firmware
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_get_ieee_or_cee_dcb_cfg(struct ice_port_info *pi, u8 dcbx_mode)
++=======
+ static int ice_get_ieee_or_cee_dcb_cfg(struct ice_port_info *pi, u8 dcbx_mode)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_dcbx_cfg *dcbx_cfg = NULL;
 -	int ret;
 +	enum ice_status ret;
  
  	if (!pi)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	if (dcbx_mode == ICE_DCBX_MODE_IEEE)
  		dcbx_cfg = &pi->qos_cfg.local_dcbx_cfg;
@@@ -1473,12 -1469,12 +1496,16 @@@ enum ice_status ice_set_dcb_cfg(struct 
  {
  	u8 mib_type, *lldpmib = NULL;
  	struct ice_dcbx_cfg *dcbcfg;
++<<<<<<< HEAD
 +	enum ice_status ret;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
  	u16 miblen;
+ 	int ret;
  
  	if (!pi)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	hw = pi->hw;
  
@@@ -1543,8 -1539,8 +1570,12 @@@ ice_update_port_tc_tree_cfg(struct ice_
  {
  	struct ice_sched_node *node, *tc_node;
  	struct ice_aqc_txsched_elem_data elem;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 teid1, teid2;
+ 	int status = 0;
  	u8 i, j;
  
  	if (!pi)
diff --cc drivers/net/ethernet/intel/ice/ice_dcb.h
index 9b6f87a889a6,d73348f279f7..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_dcb.h
+++ b/drivers/net/ethernet/intel/ice/ice_dcb.h
@@@ -149,17 -149,16 +149,22 @@@ ice_query_port_ets(struct ice_port_inf
  		   struct ice_aqc_port_ets_elem *buf, u16 buf_size,
  		   struct ice_sq_cd *cmd_details);
  #ifdef CONFIG_DCB
 -int
 +enum ice_status
  ice_aq_stop_lldp(struct ice_hw *hw, bool shutdown_lldp_agent, bool persist,
  		 struct ice_sq_cd *cd);
++<<<<<<< HEAD
 +enum ice_status
 +ice_aq_start_lldp(struct ice_hw *hw, bool persist, struct ice_sq_cd *cd);
 +enum ice_status
++=======
+ int ice_aq_start_lldp(struct ice_hw *hw, bool persist, struct ice_sq_cd *cd);
+ int
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  ice_aq_start_stop_dcbx(struct ice_hw *hw, bool start_dcbx_agent,
  		       bool *dcbx_agent_status, struct ice_sq_cd *cd);
 -int ice_cfg_lldp_mib_change(struct ice_hw *hw, bool ena_mib);
 +enum ice_status ice_cfg_lldp_mib_change(struct ice_hw *hw, bool ena_mib);
  #else /* CONFIG_DCB */
 -static inline int
 +static inline enum ice_status
  ice_aq_stop_lldp(struct ice_hw __always_unused *hw,
  		 bool __always_unused shutdown_lldp_agent,
  		 bool __always_unused persist,
diff --cc drivers/net/ethernet/intel/ice/ice_devlink.c
index 212d0917749d,dde112e74d41..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_devlink.c
+++ b/drivers/net/ethernet/intel/ice/ice_devlink.c
@@@ -762,9 -762,9 +762,13 @@@ static int ice_devlink_nvm_snapshot(str
  	struct ice_pf *pf = devlink_priv(devlink);
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	void *nvm_data;
  	u32 nvm_size;
+ 	int status;
  
  	nvm_size = hw->flash.flash_size;
  	nvm_data = vzalloc(nvm_size);
@@@ -819,8 -819,8 +823,12 @@@ ice_devlink_devcaps_snapshot(struct dev
  	struct ice_pf *pf = devlink_priv(devlink);
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	void *devcaps;
+ 	int status;
  
  	devcaps = vzalloc(ICE_AQ_MAX_BUF_LEN);
  	if (!devcaps)
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool.c
index be50950576d4,900572181f69..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@@ -261,9 -270,9 +261,13 @@@ ice_get_eeprom(struct net_device *netde
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	int ret = 0;
+ 	int status;
  	u8 *buf;
  
  	dev = ice_pf_to_dev(pf);
@@@ -333,8 -340,8 +335,12 @@@ static bool ice_active_vfs(struct ice_p
  static u64 ice_link_test(struct net_device *netdev)
  {
  	struct ice_netdev_priv *np = netdev_priv(netdev);
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool link_up = false;
+ 	int status;
  
  	netdev_info(netdev, "link test\n");
  	status = ice_get_link_status(np->vsi->port_info, &link_up);
@@@ -1054,8 -1050,8 +1060,12 @@@ ice_get_fecparam(struct net_device *net
  	struct ice_link_status *link_info;
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_port_info *pi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int err = 0;
+ 	int status;
  
  	pi = vsi->port_info;
  
@@@ -1234,8 -1230,8 +1244,12 @@@ static int ice_set_priv_flags(struct ne
  			pf->dcbx_cap &= ~DCB_CAP_DCBX_LLD_MANAGED;
  			pf->dcbx_cap |= DCB_CAP_DCBX_HOST;
  		} else {
++<<<<<<< HEAD
 +			enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  			bool dcbx_agent_status;
+ 			int status;
  
  			if (ice_get_pfc_mode(pf) == ICE_QOS_MODE_DSCP) {
  				clear_bit(ICE_FLAG_FW_LLDP_AGENT, pf->flags);
@@@ -1929,8 -1936,8 +1943,12 @@@ ice_get_link_ksettings(struct net_devic
  	struct ice_aqc_get_phy_caps_data *caps;
  	struct ice_link_status *hw_link_info;
  	struct ice_vsi *vsi = np->vsi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int err = 0;
+ 	int status;
  
  	ethtool_link_ksettings_zero_link_mode(ks, supported);
  	ethtool_link_ksettings_zero_link_mode(ks, advertising);
@@@ -2201,7 -2208,6 +2219,10 @@@ ice_set_link_ksettings(struct net_devic
  	struct ice_pf *pf = np->vsi->back;
  	struct ice_port_info *pi;
  	u8 autoneg_changed = 0;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u64 phy_type_high = 0;
  	u64 phy_type_low = 0;
  	int err = 0;
@@@ -2513,9 -2520,9 +2535,13 @@@ static in
  ice_set_rss_hash_opt(struct ice_vsi *vsi, struct ethtool_rxnfc *nfc)
  {
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	u64 hashed_flds;
+ 	int status;
  	u32 hdrs;
  
  	dev = ice_pf_to_dev(pf);
@@@ -2990,7 -3001,6 +3016,10 @@@ ice_set_pauseparam(struct net_device *n
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_hw *hw = &pf->hw;
  	struct ice_port_info *pi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 aq_failures;
  	bool link_up;
  	int err = 0;
@@@ -3857,7 -3923,6 +3884,10 @@@ ice_get_module_info(struct net_device *
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 sff8472_comp = 0;
  	u8 sff8472_swap = 0;
  	u8 sff8636_rev = 0;
@@@ -3934,7 -4000,6 +3965,10 @@@ ice_get_module_eeprom(struct net_devic
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool is_sfp = false;
  	unsigned int i, j;
  	u16 offset = 0;
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
index 38960bcc384c,deb4e3ad38f6..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
@@@ -530,7 -530,6 +530,10 @@@ ice_fdir_set_hw_fltr_rule(struct ice_p
  	struct ice_flow_prof *prof = NULL;
  	struct ice_fd_hw_prof *hw_prof;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u64 entry1_h = 0;
  	u64 entry2_h = 0;
  	u64 prof_id;
@@@ -1190,9 -1190,9 +1194,13 @@@ ice_fdir_write_fltr(struct ice_pf *pf, 
  	struct ice_hw *hw = &pf->hw;
  	struct ice_fltr_desc desc;
  	struct ice_vsi *ctrl_vsi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 *pkt, *frag_pkt;
  	bool has_frag;
+ 	int status;
  	int err;
  
  	ctrl_vsi = ice_get_ctrl_vsi(pf);
diff --cc drivers/net/ethernet/intel/ice/ice_fdir.c
index cbd8424631e3,ae089d32ee9d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_fdir.c
@@@ -735,8 -735,7 +735,12 @@@ enum ice_status ice_free_fd_res_cntr(st
   * @cntr_id: returns counter index
   * @num_fltr: number of filter entries to be allocated
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_alloc_fd_guar_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr)
++=======
+ int ice_alloc_fd_guar_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_alloc_res_cntr(hw, ICE_AQC_RES_TYPE_FDIR_GUARANTEED_ENTRIES,
  				  ICE_AQC_RES_TYPE_FLAG_DEDICATED, num_fltr,
@@@ -749,8 -748,7 +753,12 @@@
   * @cntr_id: returns counter index
   * @num_fltr: number of filter entries to be allocated
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_alloc_fd_shrd_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr)
++=======
+ int ice_alloc_fd_shrd_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_alloc_res_cntr(hw, ICE_AQC_RES_TYPE_FDIR_SHARED_ENTRIES,
  				  ICE_AQC_RES_TYPE_FLAG_DEDICATED, num_fltr,
diff --cc drivers/net/ethernet/intel/ice/ice_fdir.h
index da4163856f4c,b6c7c6903f35..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fdir.h
+++ b/drivers/net/ethernet/intel/ice/ice_fdir.h
@@@ -201,12 -201,10 +201,19 @@@ struct ice_fdir_base_pkt 
  	const u8 *tun_pkt;
  };
  
++<<<<<<< HEAD
 +enum ice_status ice_alloc_fd_res_cntr(struct ice_hw *hw, u16 *cntr_id);
 +enum ice_status ice_free_fd_res_cntr(struct ice_hw *hw, u16 cntr_id);
 +enum ice_status
 +ice_alloc_fd_guar_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr);
 +enum ice_status
 +ice_alloc_fd_shrd_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr);
++=======
+ int ice_alloc_fd_res_cntr(struct ice_hw *hw, u16 *cntr_id);
+ int ice_free_fd_res_cntr(struct ice_hw *hw, u16 cntr_id);
+ int ice_alloc_fd_guar_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr);
+ int ice_alloc_fd_shrd_item(struct ice_hw *hw, u16 *cntr_id, u16 num_fltr);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  void
  ice_fdir_get_prgm_desc(struct ice_hw *hw, struct ice_fdir_fltr *input,
  		       struct ice_fltr_desc *fdesc, bool add);
diff --cc drivers/net/ethernet/intel/ice/ice_flex_pipe.c
index b79e0a77d927,d29197ab3d02..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
@@@ -892,11 -964,10 +892,17 @@@ ice_find_seg_in_pkg(struct ice_hw *hw, 
   *
   * Obtains change lock and updates package.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_update_pkg(struct ice_hw *hw, struct ice_buf *bufs, u32 count)
 +{
 +	enum ice_status status;
++=======
+ static int ice_update_pkg(struct ice_hw *hw, struct ice_buf *bufs, u32 count)
+ {
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 offset, info, i;
+ 	int status;
  
  	status = ice_acquire_change_lock(hw, ICE_RES_WRITE);
  	if (status)
@@@ -951,7 -1022,6 +957,10 @@@ static enum ice_ddp_stat
  ice_dwnld_cfg_bufs(struct ice_hw *hw, struct ice_buf *bufs, u32 count)
  {
  	enum ice_ddp_state state = ICE_DDP_PKG_SUCCESS;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_buf_hdr *bh;
  	enum ice_aq_err err;
  	u32 offset, info, i;
@@@ -1997,8 -2100,8 +2007,12 @@@ ice_create_tunnel(struct ice_hw *hw, u1
  		  enum ice_tunnel_type type, u16 port)
  {
  	struct ice_boost_tcam_section *sect_rx, *sect_tx;
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_MAX_LIMIT;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_buf_build *bld;
+ 	int status = -ENOSPC;
  
  	mutex_lock(&hw->tnl_lock);
  
@@@ -2068,8 -2171,8 +2082,12 @@@ ice_destroy_tunnel(struct ice_hw *hw, u
  		   u16 port)
  {
  	struct ice_boost_tcam_section *sect_rx, *sect_tx;
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_MAX_LIMIT;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_buf_build *bld;
+ 	int status = -ENOSPC;
  
  	mutex_lock(&hw->tnl_lock);
  
@@@ -2292,17 -2395,17 +2310,21 @@@ ice_ptg_remove_ptype(struct ice_hw *hw
   * a destination PTG ID of ICE_DEFAULT_PTG (0) will move the ptype to the
   * default PTG.
   */
 -static int
 +static enum ice_status
  ice_ptg_add_mv_ptype(struct ice_hw *hw, enum ice_block blk, u16 ptype, u8 ptg)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 original_ptg;
+ 	int status;
  
  	if (ptype > ICE_XLT1_CNT - 1)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	if (!hw->blk[blk].xlt1.ptg_tbl[ptg].in_use && ptg != ICE_DEFAULT_PTG)
 -		return -ENOENT;
 +		return ICE_ERR_DOES_NOT_EXIST;
  
  	status = ice_ptg_find_ptype(hw, blk, ptype, &original_ptg);
  	if (status)
@@@ -2532,8 -2635,7 +2554,12 @@@ ice_find_dup_props_vsig(struct ice_hw *
   * The function will remove all VSIs associated with the input VSIG and move
   * them to the DEFAULT_VSIG and mark the VSIG available.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_vsig_free(struct ice_hw *hw, enum ice_block blk, u16 vsig)
++=======
+ static int ice_vsig_free(struct ice_hw *hw, enum ice_block blk, u16 vsig)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_vsig_prof *dtmp, *del;
  	struct ice_vsig_vsi *vsi_cur;
@@@ -2655,8 -2757,8 +2681,12 @@@ static enum ice_statu
  ice_vsig_add_mv_vsi(struct ice_hw *hw, enum ice_block blk, u16 vsi, u16 vsig)
  {
  	struct ice_vsig_vsi *tmp;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 orig_vsig, idx;
+ 	int status;
  
  	idx = vsig & ICE_VSIG_IDX_M;
  
@@@ -2894,15 -2996,14 +2924,21 @@@ ice_free_tcam_ent(struct ice_hw *hw, en
   * This function allocates a new profile ID, which also corresponds to a Field
   * Vector (Extraction Sequence) entry.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_alloc_prof_id(struct ice_hw *hw, enum ice_block blk, u8 *prof_id)
 +{
 +	enum ice_status status;
++=======
+ static int ice_alloc_prof_id(struct ice_hw *hw, enum ice_block blk, u8 *prof_id)
+ {
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 res_type;
  	u16 get_prof;
+ 	int status;
  
  	if (!ice_prof_id_rsrc_type(blk, &res_type))
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	status = ice_alloc_hw_res(hw, res_type, 1, false, &get_prof);
  	if (!status)
@@@ -2919,8 -3020,7 +2955,12 @@@
   *
   * This function frees a profile ID, which also corresponds to a Field Vector.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_free_prof_id(struct ice_hw *hw, enum ice_block blk, u8 prof_id)
++=======
+ static int ice_free_prof_id(struct ice_hw *hw, enum ice_block blk, u8 prof_id)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	u16 tmp_prof_id = (u16)prof_id;
  	u16 res_type;
@@@ -2937,11 -3037,10 +2977,15 @@@
   * @blk: the block from which to free the profile ID
   * @prof_id: the profile ID for which to increment the reference count
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_prof_inc_ref(struct ice_hw *hw, enum ice_block blk, u8 prof_id)
++=======
+ static int ice_prof_inc_ref(struct ice_hw *hw, enum ice_block blk, u8 prof_id)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	if (prof_id > hw->blk[blk].es.count)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	hw->blk[blk].es.ref_count[prof_id]++;
  
@@@ -3063,8 -3162,8 +3107,12 @@@ ice_alloc_prof_mask(struct ice_hw *hw, 
  		    u16 *mask_idx)
  {
  	bool found_unused = false, found_copy = false;
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_MAX_LIMIT;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 unused_idx = 0, copy_idx = 0;
+ 	int status = -ENOSPC;
  	u16 i;
  
  	if (blk != ICE_BLK_RSS && blk != ICE_BLK_FD)
@@@ -4163,7 -4262,6 +4211,10 @@@ ice_upd_prof_hw(struct ice_hw *hw, enu
  {
  	struct ice_buf_build *b;
  	struct ice_chs_chg *tmp;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 pkg_sects;
  	u16 xlt1 = 0;
  	u16 xlt2 = 0;
@@@ -4534,9 -4633,9 +4586,13 @@@ ice_add_prof(struct ice_hw *hw, enum ic
  	u32 bytes = DIV_ROUND_UP(ICE_FLOW_PTYPE_MAX, BITS_PER_BYTE);
  	DECLARE_BITMAP(ptgs_used, ICE_XLT1_CNT);
  	struct ice_prof_map *prof;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 byte = 0;
  	u8 prof_id;
+ 	int status;
  
  	bitmap_zero(ptgs_used, ICE_XLT1_CNT);
  
@@@ -4694,8 -4793,7 +4750,12 @@@ ice_vsig_prof_id_count(struct ice_hw *h
   * @blk: hardware block
   * @idx: the index to release
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_rel_tcam_idx(struct ice_hw *hw, enum ice_block blk, u16 idx)
++=======
+ static int ice_rel_tcam_idx(struct ice_hw *hw, enum ice_block blk, u16 idx)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	/* Masks to invoke a never match entry */
  	u8 vl_msk[ICE_TCAM_KEY_VAL_SZ] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
@@@ -4837,12 -4935,11 +4897,19 @@@ ice_rem_prof_id_vsig(struct ice_hw *hw
   * @blk: hardware block
   * @id: profile tracking ID
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_rem_flow_all(struct ice_hw *hw, enum ice_block blk, u64 id)
 +{
 +	struct ice_chs_chg *del, *tmp;
 +	enum ice_status status;
++=======
+ static int ice_rem_flow_all(struct ice_hw *hw, enum ice_block blk, u64 id)
+ {
+ 	struct ice_chs_chg *del, *tmp;
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct list_head chg;
+ 	int status;
  	u16 i;
  
  	INIT_LIST_HEAD(&chg);
@@@ -4918,9 -5015,9 +4985,13 @@@ static enum ice_statu
  ice_get_prof(struct ice_hw *hw, enum ice_block blk, u64 hdl,
  	     struct list_head *chg)
  {
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_prof_map *map;
  	struct ice_chs_chg *p;
+ 	int status = 0;
  	u16 i;
  
  	mutex_lock(&hw->blk[blk].es.prof_map_lock);
@@@ -5011,9 -5108,9 +5082,13 @@@ static enum ice_statu
  ice_add_prof_to_lst(struct ice_hw *hw, enum ice_block blk,
  		    struct list_head *lst, u64 hdl)
  {
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_prof_map *map;
  	struct ice_vsig_prof *p;
+ 	int status = 0;
  	u16 i;
  
  	mutex_lock(&hw->blk[blk].es.prof_map_lock);
@@@ -5058,9 -5155,9 +5133,13 @@@ static enum ice_statu
  ice_move_vsi(struct ice_hw *hw, enum ice_block blk, u16 vsi, u16 vsig,
  	     struct list_head *chg)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_chs_chg *p;
  	u16 orig_vsig;
+ 	int status;
  
  	p = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*p), GFP_KERNEL);
  	if (!p)
@@@ -5119,8 -5216,8 +5198,12 @@@ ice_prof_tcam_ena_dis(struct ice_hw *hw
  		      u16 vsig, struct ice_tcam_inf *tcam,
  		      struct list_head *chg)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_chs_chg *p;
+ 	int status;
  
  	u8 vl_msk[ICE_TCAM_KEY_VAL_SZ] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
  	u8 dc_msk[ICE_TCAM_KEY_VAL_SZ] = { 0xFF, 0xFF, 0x00, 0x00, 0x00 };
@@@ -5266,7 -5363,6 +5349,10 @@@ ice_add_prof_id_vsig(struct ice_hw *hw
  	u8 vl_msk[ICE_TCAM_KEY_VAL_SZ] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
  	u8 dc_msk[ICE_TCAM_KEY_VAL_SZ] = { 0xFF, 0xFF, 0x00, 0x00, 0x00 };
  	u8 nm_msk[ICE_TCAM_KEY_VAL_SZ] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_prof_map *map;
  	struct ice_vsig_prof *t;
  	struct ice_chs_chg *p;
@@@ -5374,9 -5471,9 +5461,13 @@@ static enum ice_statu
  ice_create_prof_id_vsig(struct ice_hw *hw, enum ice_block blk, u16 vsi, u64 hdl,
  			struct list_head *chg)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_chs_chg *p;
  	u16 new_vsig;
+ 	int status;
  
  	p = devm_kzalloc(ice_hw_to_dev(hw), sizeof(*p), GFP_KERNEL);
  	if (!p)
@@@ -5461,8 -5558,8 +5552,12 @@@ static boo
  ice_find_prof_vsig(struct ice_hw *hw, enum ice_block blk, u64 hdl, u16 *vsig)
  {
  	struct ice_vsig_prof *t;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct list_head lst;
+ 	int status;
  
  	INIT_LIST_HEAD(&lst);
  
@@@ -5498,8 -5595,8 +5593,12 @@@ ice_add_prof_id_flow(struct ice_hw *hw
  	struct ice_vsig_prof *tmp1, *del1;
  	struct ice_chs_chg *tmp, *del;
  	struct list_head union_lst;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct list_head chg;
+ 	int status;
  	u16 vsig;
  
  	INIT_LIST_HEAD(&union_lst);
diff --cc drivers/net/ethernet/intel/ice/ice_flex_pipe.h
index c2afb6bd1250,6cbc29bcb02f..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.h
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.h
@@@ -113,6 -118,5 +113,10 @@@ void ice_free_seg(struct ice_hw *hw)
  void ice_fill_blk_tbls(struct ice_hw *hw);
  void ice_clear_hw_tbls(struct ice_hw *hw);
  void ice_free_hw_tbls(struct ice_hw *hw);
++<<<<<<< HEAD
 +enum ice_status
 +ice_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 id);
++=======
+ int ice_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 id);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  #endif /* _ICE_FLEX_PIPE_H_ */
diff --cc drivers/net/ethernet/intel/ice/ice_flow.c
index f160672448a0,b17b984196a2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flow.c
+++ b/drivers/net/ethernet/intel/ice/ice_flow.c
@@@ -625,8 -625,7 +625,12 @@@ struct ice_flow_prof_params 
   * @segs: array of one or more packet segments that describe the flow
   * @segs_cnt: number of packet segments provided
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_flow_val_hdrs(struct ice_flow_seg_info *segs, u8 segs_cnt)
++=======
+ static int ice_flow_val_hdrs(struct ice_flow_seg_info *segs, u8 segs_cnt)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	u8 i;
  
@@@ -700,8 -699,7 +704,12 @@@ static u16 ice_flow_calc_seg_sz(struct 
   * This function identifies the packet types associated with the protocol
   * headers being present in packet segments of the specified flow profile.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_flow_proc_seg_hdrs(struct ice_flow_prof_params *params)
++=======
+ static int ice_flow_proc_seg_hdrs(struct ice_flow_prof_params *params)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_flow_prof *prof;
  	u8 i;
@@@ -1574,11 -1572,10 +1582,15 @@@ ice_flow_add_prof(struct ice_hw *hw, en
   * @blk: the block for which the flow profile is to be removed
   * @prof_id: unique ID of the flow profile to be removed
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_flow_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 prof_id)
++=======
+ int ice_flow_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 prof_id)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_flow_prof *prof;
 -	int status;
 +	enum ice_status status;
  
  	mutex_lock(&hw->fl_profs_locks[blk]);
  
@@@ -1680,8 -1677,7 +1692,12 @@@ out
   * @blk: classification stage
   * @entry_h: handle to the flow entry to be removed
   */
++<<<<<<< HEAD
 +enum ice_status ice_flow_rem_entry(struct ice_hw *hw, enum ice_block blk,
 +				   u64 entry_h)
++=======
+ int ice_flow_rem_entry(struct ice_hw *hw, enum ice_block blk, u64 entry_h)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_flow_entry *entry;
  	struct ice_flow_prof *prof;
@@@ -2279,10 -2275,9 +2295,14 @@@ ice_rem_rss_cfg(struct ice_hw *hw, u16 
   * message, convert it to ICE-compatible values, and configure RSS flow
   * profiles.
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_add_avf_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 avf_hash)
++=======
+ int ice_add_avf_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 avf_hash)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
 -	int status = 0;
 +	enum ice_status status = 0;
  	u64 hash_flds;
  
  	if (avf_hash == ICE_AVF_FLOW_FIELD_INVALID ||
@@@ -2368,13 -2363,13 +2388,17 @@@
   * @hw: pointer to the hardware structure
   * @vsi_handle: software VSI handle
   */
 -int ice_replay_rss_cfg(struct ice_hw *hw, u16 vsi_handle)
 +enum ice_status ice_replay_rss_cfg(struct ice_hw *hw, u16 vsi_handle)
  {
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_rss_cfg *r;
+ 	int status = 0;
  
  	if (!ice_is_vsi_valid(hw, vsi_handle))
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	mutex_lock(&hw->rss_locks);
  	list_for_each_entry(r, &hw->rss_list_head, l_entry) {
diff --cc drivers/net/ethernet/intel/ice/ice_flow.h
index 2a2d8c1536cb,d8782b28323e..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flow.h
+++ b/drivers/net/ethernet/intel/ice/ice_flow.h
@@@ -387,14 -387,12 +387,23 @@@ enum ice_statu
  ice_flow_add_prof(struct ice_hw *hw, enum ice_block blk, enum ice_flow_dir dir,
  		  u64 prof_id, struct ice_flow_seg_info *segs, u8 segs_cnt,
  		  struct ice_flow_prof **prof);
++<<<<<<< HEAD
 +enum ice_status
 +ice_flow_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 prof_id);
 +enum ice_status
 +ice_flow_add_entry(struct ice_hw *hw, enum ice_block blk, u64 prof_id,
 +		   u64 entry_id, u16 vsi, enum ice_flow_priority prio,
 +		   void *data, u64 *entry_h);
 +enum ice_status
 +ice_flow_rem_entry(struct ice_hw *hw, enum ice_block blk, u64 entry_h);
++=======
+ int ice_flow_rem_prof(struct ice_hw *hw, enum ice_block blk, u64 prof_id);
+ int
+ ice_flow_add_entry(struct ice_hw *hw, enum ice_block blk, u64 prof_id,
+ 		   u64 entry_id, u16 vsi, enum ice_flow_priority prio,
+ 		   void *data, u64 *entry_h);
+ int ice_flow_rem_entry(struct ice_hw *hw, enum ice_block blk, u64 entry_h);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  void
  ice_flow_set_fld(struct ice_flow_seg_info *seg, enum ice_flow_field fld,
  		 u16 val_loc, u16 mask_loc, u16 last_loc, bool range);
@@@ -402,14 -400,13 +411,21 @@@ voi
  ice_flow_add_fld_raw(struct ice_flow_seg_info *seg, u16 off, u8 len,
  		     u16 val_loc, u16 mask_loc);
  void ice_rem_vsi_rss_list(struct ice_hw *hw, u16 vsi_handle);
++<<<<<<< HEAD
 +enum ice_status ice_replay_rss_cfg(struct ice_hw *hw, u16 vsi_handle);
 +enum ice_status
 +ice_add_avf_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds);
 +enum ice_status ice_rem_vsi_rss_cfg(struct ice_hw *hw, u16 vsi_handle);
 +enum ice_status
++=======
+ int ice_replay_rss_cfg(struct ice_hw *hw, u16 vsi_handle);
+ int ice_add_avf_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds);
+ int ice_rem_vsi_rss_cfg(struct ice_hw *hw, u16 vsi_handle);
+ int
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  ice_add_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds,
  		u32 addl_hdrs);
 -int
 +enum ice_status
  ice_rem_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u64 hashed_flds,
  		u32 addl_hdrs);
  u64 ice_get_rss_cfg(struct ice_hw *hw, u16 vsi_handle, u32 hdrs);
diff --cc drivers/net/ethernet/intel/ice/ice_fltr.c
index 2b1ff56a5378,94903b450345..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fltr.c
+++ b/drivers/net/ethernet/intel/ice/ice_fltr.c
@@@ -109,8 -109,7 +109,12 @@@ ice_fltr_set_vsi_promisc(struct ice_hw 
   * @vsi: pointer to VSI struct
   * @list: list of filters
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_fltr_add_mac_list(struct ice_vsi *vsi, struct list_head *list)
++=======
+ int ice_fltr_add_mac_list(struct ice_vsi *vsi, struct list_head *list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_add_mac(&vsi->back->hw, list);
  }
@@@ -120,8 -119,7 +124,12 @@@
   * @vsi: pointer to VSI struct
   * @list: list of filters
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_fltr_remove_mac_list(struct ice_vsi *vsi, struct list_head *list)
++=======
+ int ice_fltr_remove_mac_list(struct ice_vsi *vsi, struct list_head *list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_remove_mac(&vsi->back->hw, list);
  }
@@@ -131,8 -129,7 +139,12 @@@
   * @vsi: pointer to VSI struct
   * @list: list of filters
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_fltr_add_vlan_list(struct ice_vsi *vsi, struct list_head *list)
++=======
+ static int ice_fltr_add_vlan_list(struct ice_vsi *vsi, struct list_head *list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_add_vlan(&vsi->back->hw, list);
  }
@@@ -153,8 -150,7 +165,12 @@@ ice_fltr_remove_vlan_list(struct ice_vs
   * @vsi: pointer to VSI struct
   * @list: list of filters
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_fltr_add_eth_list(struct ice_vsi *vsi, struct list_head *list)
++=======
+ static int ice_fltr_add_eth_list(struct ice_vsi *vsi, struct list_head *list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_add_eth_mac(&vsi->back->hw, list);
  }
@@@ -164,8 -160,7 +180,12 @@@
   * @vsi: pointer to VSI struct
   * @list: list of filters
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_fltr_remove_eth_list(struct ice_vsi *vsi, struct list_head *list)
++=======
+ static int ice_fltr_remove_eth_list(struct ice_vsi *vsi, struct list_head *list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	return ice_remove_eth_mac(&vsi->back->hw, list);
  }
@@@ -265,14 -260,13 +285,18 @@@ ice_fltr_add_eth_to_list(struct ice_vs
   * @action: action to be performed on filter match
   * @mac_action: pointer to add or remove MAC function
   */
 -static int
 +static enum ice_status
  ice_fltr_prepare_mac(struct ice_vsi *vsi, const u8 *mac,
  		     enum ice_sw_fwd_act_type action,
 -		     int (*mac_action)(struct ice_vsi *, struct list_head *))
 +		     enum ice_status (*mac_action)(struct ice_vsi *,
 +						   struct list_head *))
  {
++<<<<<<< HEAD
 +	enum ice_status result;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	LIST_HEAD(tmp_list);
+ 	int result;
  
  	if (ice_fltr_add_mac_to_list(vsi, &tmp_list, mac, action)) {
  		ice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);
@@@ -298,8 -292,8 +322,12 @@@ ice_fltr_prepare_mac_and_broadcast(stru
  				   (struct ice_vsi *, struct list_head *))
  {
  	u8 broadcast[ETH_ALEN];
++<<<<<<< HEAD
 +	enum ice_status result;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	LIST_HEAD(tmp_list);
+ 	int result;
  
  	eth_broadcast_addr(broadcast);
  	if (ice_fltr_add_mac_to_list(vsi, &tmp_list, mac, action) ||
@@@ -320,17 -314,16 +348,21 @@@
   * @action: action to be performed on filter match
   * @vlan_action: pointer to add or remove VLAN function
   */
 -static int
 +static enum ice_status
  ice_fltr_prepare_vlan(struct ice_vsi *vsi, u16 vlan_id,
  		      enum ice_sw_fwd_act_type action,
 -		      int (*vlan_action)(struct ice_vsi *, struct list_head *))
 +		      enum ice_status (*vlan_action)(struct ice_vsi *,
 +						     struct list_head *))
  {
++<<<<<<< HEAD
 +	enum ice_status result;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	LIST_HEAD(tmp_list);
+ 	int result;
  
  	if (ice_fltr_add_vlan_to_list(vsi, &tmp_list, vlan_id, action))
 -		return -ENOMEM;
 +		return ICE_ERR_NO_MEMORY;
  
  	result = vlan_action(vsi, &tmp_list);
  	ice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);
@@@ -345,17 -338,16 +377,21 @@@
   * @action: action to be performed on filter match
   * @eth_action: pointer to add or remove ethertype function
   */
 -static int
 +static enum ice_status
  ice_fltr_prepare_eth(struct ice_vsi *vsi, u16 ethertype, u16 flag,
  		     enum ice_sw_fwd_act_type action,
 -		     int (*eth_action)(struct ice_vsi *, struct list_head *))
 +		     enum ice_status (*eth_action)(struct ice_vsi *,
 +						   struct list_head *))
  {
++<<<<<<< HEAD
 +	enum ice_status result;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	LIST_HEAD(tmp_list);
+ 	int result;
  
  	if (ice_fltr_add_eth_to_list(vsi, &tmp_list, ethertype, flag, action))
 -		return -ENOMEM;
 +		return ICE_ERR_NO_MEMORY;
  
  	result = eth_action(vsi, &tmp_list);
  	ice_fltr_free_list(ice_pf_to_dev(vsi->back), &tmp_list);
@@@ -469,8 -461,8 +505,12 @@@ ice_fltr_update_rule_flags(struct ice_h
  			   u32 act, u16 type, u16 src, u32 new_flags)
  {
  	struct ice_aqc_sw_rules_elem *s_rule;
++<<<<<<< HEAD
 +	enum ice_status err;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 flags_mask;
+ 	int err;
  
  	s_rule = kzalloc(ICE_SW_RULE_RX_TX_NO_HDR_SIZE, GFP_KERNEL);
  	if (!s_rule)
diff --cc drivers/net/ethernet/intel/ice/ice_fltr.h
index ba3a4979ab25,0e65fd021ad2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fltr.h
+++ b/drivers/net/ethernet/intel/ice/ice_fltr.h
@@@ -5,39 -5,37 +5,47 @@@
  #define _ICE_FLTR_H_
  
  void ice_fltr_free_list(struct device *dev, struct list_head *h);
 -int
 +enum ice_status
  ice_fltr_set_vlan_vsi_promisc(struct ice_hw *hw, struct ice_vsi *vsi,
  			      u8 promisc_mask);
 -int
 +enum ice_status
  ice_fltr_clear_vlan_vsi_promisc(struct ice_hw *hw, struct ice_vsi *vsi,
  				u8 promisc_mask);
 -int
 +enum ice_status
  ice_fltr_clear_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,
  			   u16 vid);
 -int
 +enum ice_status
  ice_fltr_set_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,
  			 u16 vid);
 -int
 +enum ice_status
  ice_fltr_add_mac_to_list(struct ice_vsi *vsi, struct list_head *list,
  			 const u8 *mac, enum ice_sw_fwd_act_type action);
 -int
 +enum ice_status
  ice_fltr_add_mac(struct ice_vsi *vsi, const u8 *mac,
  		 enum ice_sw_fwd_act_type action);
 -int
 +enum ice_status
  ice_fltr_add_mac_and_broadcast(struct ice_vsi *vsi, const u8 *mac,
  			       enum ice_sw_fwd_act_type action);
++<<<<<<< HEAD
 +enum ice_status
 +ice_fltr_add_mac_list(struct ice_vsi *vsi, struct list_head *list);
 +enum ice_status
 +ice_fltr_remove_mac(struct ice_vsi *vsi, const u8 *mac,
 +		    enum ice_sw_fwd_act_type action);
 +enum ice_status
 +ice_fltr_remove_mac_list(struct ice_vsi *vsi, struct list_head *list);
++=======
+ int ice_fltr_add_mac_list(struct ice_vsi *vsi, struct list_head *list);
+ int
+ ice_fltr_remove_mac(struct ice_vsi *vsi, const u8 *mac,
+ 		    enum ice_sw_fwd_act_type action);
+ int ice_fltr_remove_mac_list(struct ice_vsi *vsi, struct list_head *list);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  
 -int
 +enum ice_status
  ice_fltr_add_vlan(struct ice_vsi *vsi, u16 vid,
  		  enum ice_sw_fwd_act_type action);
 -int
 +enum ice_status
  ice_fltr_remove_vlan(struct ice_vsi *vsi, u16 vid,
  		     enum ice_sw_fwd_act_type action);
  
diff --cc drivers/net/ethernet/intel/ice/ice_fw_update.c
index ff801f4064a0,d12f292a576a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fw_update.c
+++ b/drivers/net/ethernet/intel/ice/ice_fw_update.c
@@@ -40,8 -40,8 +40,12 @@@ ice_send_package_data(struct pldmfw *co
  	struct device *dev = context->dev;
  	struct ice_pf *pf = priv->pf;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 *package_data;
+ 	int status;
  
  	dev_dbg(dev, "Sending PLDM record package data to firmware\n");
  
@@@ -203,8 -202,8 +206,12 @@@ ice_send_component_table(struct pldmfw 
  	struct device *dev = context->dev;
  	struct ice_pf *pf = priv->pf;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	size_t length;
+ 	int status;
  
  	switch (component->identifier) {
  	case NVM_COMP_ID_OROM:
@@@ -277,8 -275,8 +283,12 @@@ ice_write_one_nvm_block(struct ice_pf *
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_rq_event_info event;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 completion_offset;
+ 	int status;
  	int err;
  
  	memset(&event, 0, sizeof(event));
@@@ -524,8 -522,8 +534,12 @@@ static int ice_switch_flash_banks(struc
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_rq_event_info event;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 completion_retval;
+ 	int status;
  	int err;
  
  	memset(&event, 0, sizeof(event));
@@@ -736,8 -732,8 +748,12 @@@ int ice_check_for_pending_update(struc
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw_dev_caps *dev_caps;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 pending = 0;
+ 	int status;
  	int err;
  
  	dev_caps = kzalloc(sizeof(*dev_caps), GFP_KERNEL);
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 68fc7a57568e,1902aa250eac..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -1423,8 -1545,8 +1423,12 @@@ ice_vsi_cfg_rss_exit
  static void ice_vsi_set_vf_rss_flow_fld(struct ice_vsi *vsi)
  {
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  
  	dev = ice_pf_to_dev(pf);
  	if (ice_is_safe_mode(pf)) {
@@@ -1455,8 -1577,8 +1459,12 @@@ static void ice_vsi_set_rss_flow_fld(st
  	u16 vsi_handle = vsi->idx, vsi_num = vsi->vsi_num;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  
  	dev = ice_pf_to_dev(pf);
  	if (ice_is_safe_mode(pf)) {
@@@ -1627,9 -1749,9 +1635,13 @@@ ice_vsi_add_vlan(struct ice_vsi *vsi, u
  int ice_vsi_kill_vlan(struct ice_vsi *vsi, u16 vid)
  {
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	int err = 0;
+ 	int status;
  
  	dev = ice_pf_to_dev(pf);
  
@@@ -1983,8 -2105,8 +1995,12 @@@ int ice_vsi_manage_vlan_insertion(struc
  {
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int ret = 0;
+ 	int status;
  
  	ctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);
  	if (!ctxt)
@@@ -2279,11 -2404,11 +2294,15 @@@ clear_reg_idx
   */
  void ice_cfg_sw_lldp(struct ice_vsi *vsi, bool tx, bool create)
  {
 -	int (*eth_fltr)(struct ice_vsi *v, u16 type, u16 flag,
 -			enum ice_sw_fwd_act_type act);
 +	enum ice_status (*eth_fltr)(struct ice_vsi *v, u16 type, u16 flag,
 +				    enum ice_sw_fwd_act_type act);
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  
  	dev = ice_pf_to_dev(pf);
  	eth_fltr = create ? ice_fltr_add_eth : ice_fltr_remove_eth;
@@@ -2447,14 -2575,16 +2466,18 @@@ ice_vsi_setup(struct ice_pf *pf, struc
  {
  	u16 max_txqs[ICE_MAX_TRAFFIC_CLASS] = { 0 };
  	struct device *dev = ice_pf_to_dev(pf);
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_vsi *vsi;
  	int ret, i;
+ 	int status;
  
 -	if (vsi_type == ICE_VSI_CHNL)
 -		vsi = ice_vsi_alloc(pf, vsi_type, ch, ICE_INVAL_VFID);
 -	else if (vsi_type == ICE_VSI_VF || vsi_type == ICE_VSI_CTRL)
 -		vsi = ice_vsi_alloc(pf, vsi_type, NULL, vf_id);
 +	if (vsi_type == ICE_VSI_VF || vsi_type == ICE_VSI_CTRL)
 +		vsi = ice_vsi_alloc(pf, vsi_type, vf_id);
  	else
 -		vsi = ice_vsi_alloc(pf, vsi_type, NULL, ICE_INVAL_VFID);
 +		vsi = ice_vsi_alloc(pf, vsi_type, ICE_INVAL_VFID);
  
  	if (!vsi) {
  		dev_err(dev, "could not allocate VSI\n");
@@@ -2883,8 -3035,8 +2906,12 @@@ void ice_napi_del(struct ice_vsi *vsi
   */
  int ice_vsi_release(struct ice_vsi *vsi)
  {
++<<<<<<< HEAD
 +	enum ice_status err;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_pf *pf;
+ 	int err;
  
  	if (!vsi->back)
  		return -ENODEV;
@@@ -3120,9 -3272,9 +3147,13 @@@ int ice_vsi_rebuild(struct ice_vsi *vsi
  	int prev_num_q_vectors = 0;
  	struct ice_vf *vf = NULL;
  	enum ice_vsi_type vtype;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_pf *pf;
  	int ret, i;
+ 	int status;
  
  	if (!vsi)
  		return -EINVAL;
@@@ -3346,12 -3662,15 +3377,16 @@@ int ice_vsi_cfg_tc(struct ice_vsi *vsi
  	u16 max_txqs[ICE_MAX_TRAFFIC_CLASS] = { 0 };
  	struct ice_pf *pf = vsi->back;
  	struct ice_vsi_ctx *ctx;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	int i, ret = 0;
  	u8 num_tc = 0;
+ 	int status;
  
  	dev = ice_pf_to_dev(pf);
 -	if (vsi->tc_cfg.ena_tc == ena_tc &&
 -	    vsi->mqprio_qopt.mode != TC_MQPRIO_MODE_CHANNEL)
 -		return ret;
  
  	ice_for_each_traffic_class(i) {
  		/* build bitmap of enabled TCs */
@@@ -3515,8 -3815,8 +3550,12 @@@ bool ice_is_vsi_dflt_vsi(struct ice_sw 
   */
  int ice_set_dflt_vsi(struct ice_sw *sw, struct ice_vsi *vsi)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  
  	if (!sw || !vsi)
  		return -EINVAL;
@@@ -3561,8 -3861,8 +3600,12 @@@
  int ice_clear_dflt_vsi(struct ice_sw *sw)
  {
  	struct ice_vsi *dflt_vsi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  
  	if (!sw)
  		return -EINVAL;
@@@ -3653,8 -3953,8 +3696,12 @@@ static int ice_get_link_speed_kbps(stru
  int ice_set_min_bw_limit(struct ice_vsi *vsi, u64 min_tx_rate)
  {
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  	int speed;
  
  	dev = ice_pf_to_dev(pf);
@@@ -3714,8 -4014,8 +3761,12 @@@
  int ice_set_max_bw_limit(struct ice_vsi *vsi, u64 max_tx_rate)
  {
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  	int speed;
  
  	dev = ice_pf_to_dev(pf);
diff --cc drivers/net/ethernet/intel/ice/ice_lib.h
index b62ff4032665,b2ed189527d6..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_lib.h
@@@ -105,8 -107,7 +105,12 @@@ void ice_write_intrl(struct ice_q_vecto
  void ice_write_itr(struct ice_ring_container *rc, u16 itr);
  void ice_set_q_vector_intrl(struct ice_q_vector *q_vector);
  
++<<<<<<< HEAD
 +enum ice_status
 +ice_vsi_cfg_mac_fltr(struct ice_vsi *vsi, const u8 *macaddr, bool set);
++=======
+ int ice_vsi_cfg_mac_fltr(struct ice_vsi *vsi, const u8 *macaddr, bool set);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  
  bool ice_is_safe_mode(struct ice_pf *pf);
  bool ice_is_aux_ena(struct ice_pf *pf);
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index a13eae346070,c4676f289ad8..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -145,9 -155,9 +145,13 @@@ static void ice_check_for_hang_subtask(
   */
  static int ice_init_mac_fltr(struct ice_pf *pf)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_vsi *vsi;
  	u8 *perm_addr;
+ 	int status;
  
  	vsi = ice_get_main_vsi(pf);
  	if (!vsi)
@@@ -285,8 -295,8 +289,12 @@@ static int ice_vsi_sync_fltr(struct ice
  	bool promisc_forced_on = false;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 changed_flags = 0;
+ 	int status = 0;
  	u8 promisc_m;
  	int err = 0;
  
@@@ -663,7 -708,6 +671,10 @@@ void ice_print_link_msg(struct ice_vsi 
  {
  	struct ice_aqc_get_phy_caps_data *caps;
  	const char *an_advertised;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	const char *fec_req;
  	const char *speed;
  	const char *fec;
@@@ -988,7 -1033,6 +1000,10 @@@ ice_link_event(struct ice_pf *pf, struc
  {
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_phy_info *phy_info;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_vsi *vsi;
  	u16 old_link_speed;
  	bool old_link;
@@@ -1375,11 -1420,11 +1391,15 @@@ static int __ice_clean_ctrlq(struct ice
  		return 0;
  
  	do {
++<<<<<<< HEAD
 +		enum ice_status ret;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  		u16 opcode;
+ 		int ret;
  
  		ret = ice_clean_rq_elem(hw, cq, &event, &pending);
 -		if (ret == -EALREADY)
 +		if (ret == ICE_ERR_AQ_NO_WORK)
  			break;
  		if (ret) {
  			dev_err(dev, "%s Receive Queue event error %d\n", qtype,
@@@ -1834,8 -1879,8 +1854,12 @@@ static int ice_init_nvm_phy_type(struc
  {
  	struct ice_aqc_get_phy_caps_data *pcaps;
  	struct ice_pf *pf = pi->hw->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int err = 0;
+ 	int status;
  
  	pcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);
  	if (!pcaps)
@@@ -1945,8 -1990,8 +1969,12 @@@ static int ice_init_phy_user_cfg(struc
  	struct ice_aqc_get_phy_caps_data *pcaps;
  	struct ice_phy_info *phy = &pi->phy;
  	struct ice_pf *pf = pi->hw->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int err = 0;
+ 	int status;
  
  	if (!(phy->link_info.link_info & ICE_AQ_MEDIA_AVAILABLE))
  		return -EIO;
@@@ -2017,8 -2062,8 +2045,12 @@@ static int ice_configure_phy(struct ice
  	struct ice_aqc_set_phy_cfg_data *cfg;
  	struct ice_phy_info *phy = &pi->phy;
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int err = 0;
+ 	int status;
  
  	/* Ensure we have media as we cannot configure a medialess port */
  	if (!(phy->link_info.link_info & ICE_AQ_MEDIA_AVAILABLE))
@@@ -2502,9 -2562,9 +2534,13 @@@ int ice_prepare_xdp_rings(struct ice_vs
  		.vsi_map_offset = vsi->alloc_txq,
  		.mapping_mode = ICE_VSI_MAP_CONTIG
  	};
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	int i, v_idx;
+ 	int status;
  
  	dev = ice_pf_to_dev(pf);
  	vsi->xdp_rings = devm_kcalloc(dev, vsi->num_xdp_txq,
@@@ -3856,8 -4036,8 +3892,12 @@@ static void ice_set_safe_mode_vlan_cfg(
  {
  	struct ice_vsi *vsi = ice_get_main_vsi(pf);
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status;
  
  	if (!vsi)
  		return;
@@@ -4612,9 -4791,9 +4651,13 @@@ static void ice_setup_mc_magic_wake(str
  {
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 mac_addr[ETH_ALEN];
  	struct ice_vsi *vsi;
+ 	int status;
  	u8 flags;
  
  	if (!pf->wol_ena)
@@@ -5175,7 -5355,6 +5217,10 @@@ static int ice_set_mac_address(struct n
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
  	struct sockaddr *addr = pi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 old_mac[ETH_ALEN];
  	u8 flags = 0;
  	int err = 0;
@@@ -5284,8 -5470,8 +5330,12 @@@ ice_set_tx_maxrate(struct net_device *n
  {
  	struct ice_netdev_priv *np = netdev_priv(netdev);
  	struct ice_vsi *vsi = np->vsi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 q_handle;
+ 	int status;
  	u8 tc;
  
  	/* Validate maxrate requested is within permitted range */
@@@ -6879,8 -7086,8 +6922,12 @@@ static int ice_vsi_update_bridge_mode(s
  	struct ice_aqc_vsi_props *vsi_props;
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int ret = 0;
+ 	int status;
  
  	vsi_props = &vsi->info;
  
@@@ -6935,9 -7141,9 +6981,13 @@@ ice_bridge_setlink(struct net_device *d
  	struct ice_pf *pf = np->vsi->back;
  	struct nlattr *attr, *br_spec;
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_sw *pf_sw;
  	int rem, v, err = 0;
+ 	int status;
  
  	pf_sw = pf->first_sw;
  	/* find the attribute in the netlink message */
diff --cc drivers/net/ethernet/intel/ice/ice_nvm.c
index fee37a5844cf,2d95fe533d1e..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_nvm.c
+++ b/drivers/net/ethernet/intel/ice/ice_nvm.c
@@@ -64,7 -64,6 +64,10 @@@ enum ice_statu
  ice_read_flat_nvm(struct ice_hw *hw, u32 offset, u32 *length, u8 *data,
  		  bool read_shadow_ram)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 inlen = *length;
  	u32 bytes_read = 0;
  	bool last_cmd;
@@@ -158,8 -158,7 +162,12 @@@ ice_aq_update_nvm(struct ice_hw *hw, u1
   *
   * Erase the NVM sector using the admin queue commands (0x0702)
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_aq_erase_nvm(struct ice_hw *hw, u16 module_typeid, struct ice_sq_cd *cd)
++=======
+ int ice_aq_erase_nvm(struct ice_hw *hw, u16 module_typeid, struct ice_sq_cd *cd)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_aq_desc desc;
  	struct ice_aqc_nvm *cmd;
@@@ -184,12 -183,11 +192,19 @@@
   *
   * Reads one 16 bit word from the Shadow RAM using ice_read_flat_nvm.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_read_sr_word_aq(struct ice_hw *hw, u16 offset, u16 *data)
 +{
 +	u32 bytes = sizeof(u16);
 +	enum ice_status status;
++=======
+ static int ice_read_sr_word_aq(struct ice_hw *hw, u16 offset, u16 *data)
+ {
+ 	u32 bytes = sizeof(u16);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	__le16 data_local;
+ 	int status;
  
  	/* Note that ice_read_flat_nvm takes into account the 4Kb AdminQ and
  	 * Shadow RAM sector restrictions necessary when reading from the NVM.
@@@ -210,8 -208,7 +225,12 @@@
   *
   * This function will request NVM ownership.
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_acquire_nvm(struct ice_hw *hw, enum ice_aq_res_access_type access)
++=======
+ int ice_acquire_nvm(struct ice_hw *hw, enum ice_aq_res_access_type access)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	if (hw->flash.blank_nvm_mode)
  		return 0;
@@@ -353,11 -350,11 +372,15 @@@ ice_read_flash_module(struct ice_hw *hw
   * Read the specified word from the active NVM module. This includes the CSS
   * header at the start of the NVM module.
   */
 -static int
 +static enum ice_status
  ice_read_nvm_module(struct ice_hw *hw, enum ice_bank_select bank, u32 offset, u16 *data)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	__le16 data_local;
+ 	int status;
  
  	status = ice_read_flash_module(hw, bank, ICE_SR_1ST_NVM_BANK_PTR, offset * sizeof(u16),
  				       (__force u8 *)&data_local, sizeof(u16));
@@@ -392,11 -389,11 +415,15 @@@ ice_read_nvm_sr_copy(struct ice_hw *hw
   *
   * Read a word from the specified netlist bank.
   */
 -static int
 +static enum ice_status
  ice_read_netlist_module(struct ice_hw *hw, enum ice_bank_select bank, u32 offset, u16 *data)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	__le16 data_local;
+ 	int status;
  
  	status = ice_read_flash_module(hw, bank, ICE_SR_NETLIST_BANK_PTR, offset * sizeof(u16),
  				       (__force u8 *)&data_local, sizeof(u16));
@@@ -442,9 -439,9 +469,13 @@@ enum ice_statu
  ice_get_pfa_module_tlv(struct ice_hw *hw, u16 *module_tlv, u16 *module_tlv_len,
  		       u16 module_type)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 pfa_len, pfa_ptr;
  	u16 next_tlv;
+ 	int status;
  
  	status = ice_read_sr_word(hw, ICE_SR_PFA_PTR, &pfa_ptr);
  	if (status) {
@@@ -501,12 -498,11 +532,19 @@@
   *
   * Reads the part number string from the NVM.
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_read_pba_string(struct ice_hw *hw, u8 *pba_num, u32 pba_num_size)
 +{
 +	u16 pba_tlv, pba_tlv_len;
 +	enum ice_status status;
++=======
+ int ice_read_pba_string(struct ice_hw *hw, u8 *pba_num, u32 pba_num_size)
+ {
+ 	u16 pba_tlv, pba_tlv_len;
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 pba_word, pba_size;
+ 	int status;
  	u16 i;
  
  	status = ice_get_pfa_module_tlv(hw, &pba_tlv, &pba_tlv_len,
@@@ -673,8 -669,8 +711,12 @@@ static enum ice_statu
  ice_get_orom_ver_info(struct ice_hw *hw, enum ice_bank_select bank, struct ice_orom_info *orom)
  {
  	struct ice_orom_civd_info civd;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 combo_ver;
+ 	int status;
  
  	status = ice_get_orom_civd_data(hw, bank, &civd);
  	if (status) {
@@@ -720,8 -716,8 +762,12 @@@ ice_get_netlist_info(struct ice_hw *hw
  		     struct ice_netlist_info *netlist)
  {
  	u16 module_id, length, node_count, i;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 *id_blk;
+ 	int status;
  
  	status = ice_read_netlist_module(hw, bank, ICE_NETLIST_TYPE_OFFSET, &module_id);
  	if (status)
@@@ -859,10 -855,9 +905,14 @@@ err_read_flat_nvm
   * sector size by using the highest bit. The reported pointer value will be in
   * bytes, intended for flat NVM reads.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_read_sr_pointer(struct ice_hw *hw, u16 offset, u32 *pointer)
++=======
+ static int ice_read_sr_pointer(struct ice_hw *hw, u16 offset, u32 *pointer)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
 -	int status;
 +	enum ice_status status;
  	u16 value;
  
  	status = ice_read_sr_word(hw, offset, &value);
@@@ -891,10 -886,9 +941,14 @@@
   * Each area size word is specified in 4KB sector units. This function reports
   * the size in bytes, intended for flat NVM reads.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_read_sr_area_size(struct ice_hw *hw, u16 offset, u32 *size)
++=======
+ static int ice_read_sr_area_size(struct ice_hw *hw, u16 offset, u32 *size)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
 -	int status;
 +	enum ice_status status;
  	u16 value;
  
  	status = ice_read_sr_word(hw, offset, &value);
@@@ -917,12 -911,11 +971,19 @@@
   * structure for later use in order to calculate the correct offset to read
   * from the active module.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_determine_active_flash_banks(struct ice_hw *hw)
 +{
 +	struct ice_bank_info *banks = &hw->flash.banks;
 +	enum ice_status status;
++=======
+ static int ice_determine_active_flash_banks(struct ice_hw *hw)
+ {
+ 	struct ice_bank_info *banks = &hw->flash.banks;
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 ctrl_word;
+ 	int status;
  
  	status = ice_read_sr_word(hw, ICE_SR_NVM_CTRL_WORD, &ctrl_word);
  	if (status) {
@@@ -997,12 -990,12 +1058,16 @@@
   * This function reads and populates NVM settings such as Shadow RAM size,
   * max_timeout, and blank_nvm_mode
   */
 -int ice_init_nvm(struct ice_hw *hw)
 +enum ice_status ice_init_nvm(struct ice_hw *hw)
  {
  	struct ice_flash_info *flash = &hw->flash;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 fla, gens_stat;
  	u8 sr_size;
+ 	int status;
  
  	/* The SR size is stored regardless of the NVM programming mode
  	 * as the blank mode may be used in the factory line.
diff --cc drivers/net/ethernet/intel/ice/ice_nvm.h
index c6f05f43d593,f1d754ffac16..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_nvm.h
+++ b/drivers/net/ethernet/intel/ice/ice_nvm.h
@@@ -12,26 -12,22 +12,41 @@@ struct ice_orom_civd_info 
  	__le16 combo_name[32];	/* Unicode string representing the Combo Image version */
  } __packed;
  
++<<<<<<< HEAD
 +enum ice_status
 +ice_acquire_nvm(struct ice_hw *hw, enum ice_aq_res_access_type access);
++=======
+ int ice_acquire_nvm(struct ice_hw *hw, enum ice_aq_res_access_type access);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  void ice_release_nvm(struct ice_hw *hw);
 -int
 +enum ice_status
  ice_read_flat_nvm(struct ice_hw *hw, u32 offset, u32 *length, u8 *data,
  		  bool read_shadow_ram);
 -int
 +enum ice_status
  ice_get_pfa_module_tlv(struct ice_hw *hw, u16 *module_tlv, u16 *module_tlv_len,
  		       u16 module_type);
++<<<<<<< HEAD
 +enum ice_status
 +ice_get_inactive_orom_ver(struct ice_hw *hw, struct ice_orom_info *orom);
 +enum ice_status
 +ice_get_inactive_nvm_ver(struct ice_hw *hw, struct ice_nvm_info *nvm);
 +enum ice_status
 +ice_get_inactive_netlist_ver(struct ice_hw *hw, struct ice_netlist_info *netlist);
 +enum ice_status
 +ice_read_pba_string(struct ice_hw *hw, u8 *pba_num, u32 pba_num_size);
 +enum ice_status ice_init_nvm(struct ice_hw *hw);
 +enum ice_status ice_read_sr_word(struct ice_hw *hw, u16 offset, u16 *data);
 +enum ice_status
++=======
+ int ice_get_inactive_orom_ver(struct ice_hw *hw, struct ice_orom_info *orom);
+ int ice_get_inactive_nvm_ver(struct ice_hw *hw, struct ice_nvm_info *nvm);
+ int
+ ice_get_inactive_netlist_ver(struct ice_hw *hw, struct ice_netlist_info *netlist);
+ int ice_read_pba_string(struct ice_hw *hw, u8 *pba_num, u32 pba_num_size);
+ int ice_init_nvm(struct ice_hw *hw);
+ int ice_read_sr_word(struct ice_hw *hw, u16 offset, u16 *data);
+ int
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  ice_aq_update_nvm(struct ice_hw *hw, u16 module_typeid, u32 offset,
  		  u16 length, void *data, bool last_command, u8 command_flags,
  		  struct ice_sq_cd *cd);
diff --cc drivers/net/ethernet/intel/ice/ice_sched.c
index a3b957621a03,b4bf18f9d4e3..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sched.c
+++ b/drivers/net/ethernet/intel/ice/ice_sched.c
@@@ -152,11 -152,11 +152,15 @@@ ice_sched_add_node(struct ice_port_inf
  	struct ice_aqc_txsched_elem_data elem;
  	struct ice_sched_node *parent;
  	struct ice_sched_node *node;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
+ 	int status;
  
  	if (!pi)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	hw = pi->hw;
  
@@@ -234,8 -234,8 +238,12 @@@ ice_sched_remove_elems(struct ice_hw *h
  {
  	struct ice_aqc_delete_elem *buf;
  	u16 i, num_groups_removed = 0;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_size;
+ 	int status;
  
  	buf_size = struct_size(buf, teid, num_nodes);
  	buf = devm_kzalloc(ice_hw_to_dev(hw), buf_size, GFP_KERNEL);
@@@ -525,8 -525,8 +533,12 @@@ ice_sched_suspend_resume_elems(struct i
  			       bool suspend)
  {
  	u16 i, buf_size, num_elem_ret = 0;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	__le32 *buf;
+ 	int status;
  
  	buf_size = sizeof(*buf) * num_nodes;
  	buf = devm_kzalloc(ice_hw_to_dev(hw), buf_size, GFP_KERNEL);
@@@ -727,11 -727,11 +739,15 @@@ ice_sched_del_rl_profile(struct ice_hw 
  {
  	struct ice_aqc_rl_profile_elem *buf;
  	u16 num_profiles_removed;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 num_profiles = 1;
+ 	int status;
  
  	if (rl_info->prof_id_ref != 0)
 -		return -EBUSY;
 +		return ICE_ERR_IN_USE;
  
  	/* Safe to remove profile ID */
  	buf = &rl_info->profile;
@@@ -883,9 -883,9 +899,13 @@@ ice_sched_add_elems(struct ice_port_inf
  	struct ice_sched_node *prev, *new_node;
  	struct ice_aqc_add_elem *buf;
  	u16 i, num_groups_added = 0;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
  	size_t buf_size;
+ 	int status = 0;
  	u32 teid;
  
  	buf_size = struct_size(buf, generic, num_nodes);
@@@ -1198,10 -1198,9 +1218,13 @@@ static void ice_sched_rm_dflt_nodes(str
   * resources, default topology created by firmware and storing the information
   * in SW DB.
   */
 -int ice_sched_init_port(struct ice_port_info *pi)
 +enum ice_status ice_sched_init_port(struct ice_port_info *pi)
  {
  	struct ice_aqc_get_topo_elem *buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
  	u8 num_branches;
  	u16 num_elems;
@@@ -1300,11 -1300,11 +1324,15 @@@ err_init_port
   *
   * query FW for allocated scheduler resources and store in HW struct
   */
 -int ice_sched_query_res_alloc(struct ice_hw *hw)
 +enum ice_status ice_sched_query_res_alloc(struct ice_hw *hw)
  {
  	struct ice_aqc_query_txsched_res_resp *buf;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	__le16 max_sibl;
+ 	int status = 0;
  	u16 i;
  
  	if (hw->layer_info)
@@@ -1621,7 -1621,6 +1649,10 @@@ ice_sched_add_vsi_child_nodes(struct ic
  {
  	struct ice_sched_node *parent, *node;
  	struct ice_hw *hw = pi->hw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 first_node_teid;
  	u16 num_added = 0;
  	u8 i, qgl, vsil;
@@@ -1722,13 -1722,13 +1754,17 @@@ ice_sched_add_vsi_support_nodes(struct 
  				struct ice_sched_node *tc_node, u16 *num_nodes)
  {
  	struct ice_sched_node *parent = tc_node;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u32 first_node_teid;
  	u16 num_added = 0;
  	u8 i, vsil;
+ 	int status;
  
  	if (!pi)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	vsil = ice_sched_get_vsi_layer(pi->hw);
  	for (i = pi->hw->sw_entry_point_layer; i <= vsil; i++) {
@@@ -1802,9 -1802,9 +1838,13 @@@ ice_sched_update_vsi_child_nodes(struc
  	struct ice_sched_node *vsi_node;
  	struct ice_sched_node *tc_node;
  	struct ice_vsi_ctx *vsi_ctx;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
  	u16 prev_numqs;
+ 	int status = 0;
  
  	tc_node = ice_sched_get_tc_node(pi, tc);
  	if (!tc_node)
@@@ -1875,8 -1875,8 +1915,12 @@@ ice_sched_cfg_vsi(struct ice_port_info 
  {
  	struct ice_sched_node *vsi_node, *tc_node;
  	struct ice_vsi_ctx *vsi_ctx;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
+ 	int status = 0;
  
  	ice_debug(pi->hw, ICE_DBG_SCHED, "add/config VSI %d\n", vsi_handle);
  	tc_node = ice_sched_get_tc_node(pi, tc);
@@@ -1993,11 -1993,11 +2037,15 @@@ static bool ice_sched_is_leaf_node_pres
   * This function removes the VSI and its LAN or RDMA children nodes from the
   * scheduler tree.
   */
 -static int
 +static enum ice_status
  ice_sched_rm_vsi_cfg(struct ice_port_info *pi, u16 vsi_handle, u8 owner)
  {
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_PARAM;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_vsi_ctx *vsi_ctx;
+ 	int status = -EINVAL;
  	u8 i;
  
  	ice_debug(pi->hw, ICE_DBG_SCHED, "removing VSI %d\n", vsi_handle);
@@@ -2194,9 -2194,9 +2242,13 @@@ ice_sched_move_nodes(struct ice_port_in
  {
  	struct ice_aqc_move_elem *buf;
  	struct ice_sched_node *node;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 i, grps_movd = 0;
  	struct ice_hw *hw;
+ 	int status = 0;
  	u16 buf_len;
  
  	hw = pi->hw;
@@@ -2258,9 -2258,9 +2310,13 @@@ ice_sched_move_vsi_to_agg(struct ice_po
  	struct ice_sched_node *vsi_node, *agg_node, *tc_node, *parent;
  	u16 num_nodes[ICE_AQC_TOPO_MAX_LEVEL_NUM] = { 0 };
  	u32 first_node_teid, vsi_teid;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 num_nodes_added;
  	u8 aggl, vsil, i;
+ 	int status;
  
  	tc_node = ice_sched_get_tc_node(pi, tc);
  	if (!tc_node)
@@@ -2506,7 -2506,6 +2562,10 @@@ ice_sched_add_agg_cfg(struct ice_port_i
  {
  	struct ice_sched_node *parent, *agg_node, *tc_node;
  	u16 num_nodes[ICE_AQC_TOPO_MAX_LEVEL_NUM] = { 0 };
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
  	u32 first_node_teid;
  	u16 num_nodes_added;
@@@ -2596,8 -2596,8 +2656,12 @@@ ice_sched_cfg_agg(struct ice_port_info 
  		  enum ice_agg_type agg_type, unsigned long *tc_bitmap)
  {
  	struct ice_sched_agg_info *agg_info;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
+ 	int status = 0;
  	u8 tc;
  
  	agg_info = ice_get_agg_info(hw, agg_id);
@@@ -2760,8 -2760,8 +2824,12 @@@ ice_sched_assoc_vsi_to_agg(struct ice_p
  {
  	struct ice_sched_agg_vsi_info *agg_vsi_info, *old_agg_vsi_info = NULL;
  	struct ice_sched_agg_info *agg_info, *old_agg_info;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
+ 	int status = 0;
  	u8 tc;
  
  	if (!ice_is_vsi_valid(pi->hw, vsi_handle))
@@@ -2856,9 -2856,9 +2924,13 @@@ ice_sched_update_elem(struct ice_hw *hw
  		      struct ice_aqc_txsched_elem_data *info)
  {
  	struct ice_aqc_txsched_elem_data buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 elem_cfgd = 0;
  	u16 num_elems = 1;
+ 	int status;
  
  	buf = *info;
  	/* Parent TEID is reserved field in this aq call */
@@@ -3065,8 -3102,8 +3137,12 @@@ static enum ice_statu
  ice_sched_bw_to_rl_profile(struct ice_hw *hw, u32 bw,
  			   struct ice_aqc_rl_profile_elem *profile)
  {
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_PARAM;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	s64 bytes_per_sec, ts_rate, mv_tmp;
+ 	int status = -EINVAL;
  	bool found = false;
  	s32 encode = 0;
  	s64 mv = 0;
@@@ -3139,9 -3176,9 +3215,13 @@@ ice_sched_add_rl_profile(struct ice_por
  	struct ice_aqc_rl_profile_info *rl_prof_elem;
  	u16 profiles_added = 0, num_profiles = 1;
  	struct ice_aqc_rl_profile_elem *buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
  	u8 profile_type;
+ 	int status;
  
  	if (layer_num >= ICE_AQC_TOPO_MAX_LEVEL_NUM)
  		return NULL;
@@@ -3429,7 -3466,6 +3509,10 @@@ ice_sched_set_node_bw_dflt(struct ice_p
  			   struct ice_sched_node *node,
  			   enum ice_rl_type rl_type, u8 layer_num)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw;
  	u8 profile_type;
  	u16 rl_prof_id;
@@@ -3530,9 -3567,9 +3614,13 @@@ ice_sched_set_node_bw(struct ice_port_i
  		      enum ice_rl_type rl_type, u32 bw, u8 layer_num)
  {
  	struct ice_aqc_rl_profile_info *rl_prof_info;
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_PARAM;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_hw *hw = pi->hw;
  	u16 old_id, rl_prof_id;
+ 	int status = -EINVAL;
  
  	rl_prof_info = ice_sched_add_rl_profile(pi, rl_type, bw, layer_num);
  	if (!rl_prof_info)
@@@ -3698,12 -3735,12 +3786,16 @@@ static enum ice_statu
  ice_sched_set_q_bw_lmt(struct ice_port_info *pi, u16 vsi_handle, u8 tc,
  		       u16 q_handle, enum ice_rl_type rl_type, u32 bw)
  {
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_PARAM;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_sched_node *node;
  	struct ice_q_ctx *q_ctx;
+ 	int status = -EINVAL;
  
  	if (!ice_is_vsi_valid(pi->hw, vsi_handle))
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  	mutex_lock(&pi->sched_lock);
  	q_ctx = ice_get_lan_q_ctx(pi->hw, vsi_handle, tc, q_handle);
  	if (!q_ctx)
@@@ -3848,8 -3885,8 +3940,12 @@@ ice_sched_set_node_bw_lmt_per_tc(struc
  				 enum ice_agg_type agg_type, u8 tc,
  				 enum ice_rl_type rl_type, u32 bw)
  {
++<<<<<<< HEAD
 +	enum ice_status status = ICE_ERR_PARAM;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_sched_node *node;
+ 	int status = -EINVAL;
  
  	if (!pi)
  		return status;
@@@ -4137,8 -4191,7 +4233,12 @@@ void ice_sched_replay_agg_vsi_preinit(s
   * their node bandwidth information. This function needs to be called with
   * scheduler lock held.
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_sched_replay_vsi_agg(struct ice_hw *hw, u16 vsi_handle)
++=======
+ static int ice_sched_replay_vsi_agg(struct ice_hw *hw, u16 vsi_handle)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	DECLARE_BITMAP(replay_bitmap, ICE_MAX_TRAFFIC_CLASS);
  	struct ice_sched_agg_vsi_info *agg_vsi_info;
@@@ -4198,8 -4251,7 +4298,12 @@@ enum ice_status ice_replay_vsi_agg(stru
   * This function replays queue type node bandwidth. This function needs to be
   * called with scheduler lock held.
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_sched_replay_q_bw(struct ice_port_info *pi, struct ice_q_ctx *q_ctx)
++=======
+ int ice_sched_replay_q_bw(struct ice_port_info *pi, struct ice_q_ctx *q_ctx)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_sched_node *q_node;
  
diff --cc drivers/net/ethernet/intel/ice/ice_sched.h
index 11ad8336899f,4f91577fed56..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sched.h
+++ b/drivers/net/ethernet/intel/ice/ice_sched.h
@@@ -85,35 -87,38 +85,40 @@@ struct ice_sched_node *ice_sched_get_tc
  struct ice_sched_node *
  ice_sched_get_free_qparent(struct ice_port_info *pi, u16 vsi_handle, u8 tc,
  			   u8 owner);
 -int
 +enum ice_status
  ice_sched_cfg_vsi(struct ice_port_info *pi, u16 vsi_handle, u8 tc, u16 maxqs,
  		  u8 owner, bool enable);
 -int ice_rm_vsi_lan_cfg(struct ice_port_info *pi, u16 vsi_handle);
 -int ice_rm_vsi_rdma_cfg(struct ice_port_info *pi, u16 vsi_handle);
 +enum ice_status ice_rm_vsi_lan_cfg(struct ice_port_info *pi, u16 vsi_handle);
 +enum ice_status ice_rm_vsi_rdma_cfg(struct ice_port_info *pi, u16 vsi_handle);
  
  /* Tx scheduler rate limiter functions */
 -int
 +enum ice_status
  ice_cfg_agg(struct ice_port_info *pi, u32 agg_id,
  	    enum ice_agg_type agg_type, u8 tc_bitmap);
 -int
 +enum ice_status
  ice_move_vsi_to_agg(struct ice_port_info *pi, u32 agg_id, u16 vsi_handle,
  		    u8 tc_bitmap);
 -int
 +enum ice_status
  ice_cfg_q_bw_lmt(struct ice_port_info *pi, u16 vsi_handle, u8 tc,
  		 u16 q_handle, enum ice_rl_type rl_type, u32 bw);
 -int
 +enum ice_status
  ice_cfg_q_bw_dflt_lmt(struct ice_port_info *pi, u16 vsi_handle, u8 tc,
  		      u16 q_handle, enum ice_rl_type rl_type);
 -int
 +enum ice_status
  ice_cfg_vsi_bw_lmt_per_tc(struct ice_port_info *pi, u16 vsi_handle, u8 tc,
  			  enum ice_rl_type rl_type, u32 bw);
 -int
 +enum ice_status
  ice_cfg_vsi_bw_dflt_lmt_per_tc(struct ice_port_info *pi, u16 vsi_handle, u8 tc,
  			       enum ice_rl_type rl_type);
 -int
 -ice_sched_set_node_bw_lmt_per_tc(struct ice_port_info *pi, u32 id,
 -				 enum ice_agg_type agg_type, u8 tc,
 -				 enum ice_rl_type rl_type, u32 bw);
 -int ice_cfg_rl_burst_size(struct ice_hw *hw, u32 bytes);
 +enum ice_status ice_cfg_rl_burst_size(struct ice_hw *hw, u32 bytes);
  void ice_sched_replay_agg_vsi_preinit(struct ice_hw *hw);
  void ice_sched_replay_agg(struct ice_hw *hw);
++<<<<<<< HEAD
 +enum ice_status ice_replay_vsi_agg(struct ice_hw *hw, u16 vsi_handle);
 +enum ice_status
 +ice_sched_replay_q_bw(struct ice_port_info *pi, struct ice_q_ctx *q_ctx);
++=======
+ int ice_replay_vsi_agg(struct ice_hw *hw, u16 vsi_handle);
+ int ice_sched_replay_q_bw(struct ice_port_info *pi, struct ice_q_ctx *q_ctx);
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  #endif /* _ICE_SCHED_H_ */
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 436584f83302,e477c2b1d5bb..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -760,8 -946,8 +760,12 @@@ ice_aq_alloc_free_vsi_list(struct ice_h
  {
  	struct ice_aqc_alloc_free_res_elem *sw_buf;
  	struct ice_aqc_res_elem *vsi_ele;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_len;
+ 	int status;
  
  	buf_len = struct_size(sw_buf, elem, 1);
  	sw_buf = devm_kzalloc(ice_hw_to_dev(hw), buf_len, GFP_KERNEL);
@@@ -890,11 -1076,11 +894,15 @@@ ice_aq_get_recipe(struct ice_hw *hw
  {
  	struct ice_aqc_add_get_recipe *cmd;
  	struct ice_aq_desc desc;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_size;
+ 	int status;
  
  	if (*num_recipes != ICE_MAX_NUM_RECIPES)
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  
  	cmd = &desc.params.add_get_recipe;
  	ice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_get_recipe);
@@@ -968,11 -1154,11 +976,15 @@@ ice_aq_get_recipe_to_profile(struct ice
   * @hw: pointer to the hardware structure
   * @rid: recipe ID returned as response to AQ call
   */
 -static int ice_alloc_recipe(struct ice_hw *hw, u16 *rid)
 +static enum ice_status ice_alloc_recipe(struct ice_hw *hw, u16 *rid)
  {
  	struct ice_aqc_alloc_free_res_elem *sw_buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_len;
+ 	int status;
  
  	buf_len = struct_size(sw_buf, elem, 1);
  	sw_buf = kzalloc(buf_len, GFP_KERNEL);
@@@ -1052,9 -1238,9 +1064,13 @@@ ice_get_recp_frm_fw(struct ice_hw *hw, 
  	struct ice_aqc_recipe_data_elem *tmp;
  	u16 num_recps = ICE_MAX_NUM_RECIPES;
  	struct ice_prot_lkup_ext *lkup_exts;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 fv_word_idx = 0;
  	u16 sub_recps;
+ 	int status;
  
  	bitmap_zero(result_bm, ICE_MAX_FV_WORDS);
  
@@@ -1221,12 -1407,12 +1237,16 @@@ ice_init_port_info(struct ice_port_inf
  /* ice_get_initial_sw_cfg - Get initial port and default VSI data
   * @hw: pointer to the hardware structure
   */
 -int ice_get_initial_sw_cfg(struct ice_hw *hw)
 +enum ice_status ice_get_initial_sw_cfg(struct ice_hw *hw)
  {
  	struct ice_aqc_get_sw_cfg_resp_elem *rbuf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 req_desc = 0;
  	u16 num_elems;
+ 	int status;
  	u16 i;
  
  	rbuf = devm_kzalloc(ice_hw_to_dev(hw), ICE_SW_CFG_MAX_BUF_LEN,
@@@ -1495,9 -1681,9 +1515,13 @@@ ice_add_marker_act(struct ice_hw *hw, s
  	 * 3. GENERIC VALUE action to hold the software marker ID
  	 */
  	const u16 num_lg_acts = 3;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 lg_act_size;
  	u16 rules_size;
+ 	int status;
  	u32 act;
  	u16 id;
  
@@@ -1628,9 -1814,9 +1652,13 @@@ ice_update_vsi_list_rule(struct ice_hw 
  			 enum ice_sw_lkup_type lkup_type)
  {
  	struct ice_aqc_sw_rules_elem *s_rule;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 s_rule_size;
  	u16 rule_type;
+ 	int status;
  	int i;
  
  	if (!num_vsi)
@@@ -1806,9 -1992,9 +1834,13 @@@ enum ice_status ice_update_sw_rule_brid
  {
  	struct ice_switch_info *sw = hw->switch_info;
  	struct ice_fltr_mgmt_list_entry *fm_entry;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct list_head *rule_head;
  	struct mutex *rule_lock; /* Lock to protect filter rule list */
+ 	int status = 0;
  
  	rule_lock = &sw->recp_list[ICE_SW_LKUP_MAC].filt_rule_lock;
  	rule_head = &sw->recp_list[ICE_SW_LKUP_MAC].filt_rules;
@@@ -1864,8 -2050,8 +1896,12 @@@ ice_add_update_vsi_list(struct ice_hw *
  			struct ice_fltr_info *cur_fltr,
  			struct ice_fltr_info *new_fltr)
  {
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 vsi_list_id = 0;
+ 	int status = 0;
  
  	if ((cur_fltr->fltr_act == ICE_FWD_TO_Q ||
  	     cur_fltr->fltr_act == ICE_FWD_TO_QGRP))
@@@ -2074,8 -2260,8 +2110,12 @@@ ice_remove_vsi_list_rule(struct ice_hw 
  			 enum ice_sw_lkup_type lkup_type)
  {
  	struct ice_aqc_sw_rules_elem *s_rule;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 s_rule_size;
+ 	int status;
  
  	s_rule_size = (u16)ICE_SW_RULE_VSI_LIST_SIZE(0);
  	s_rule = devm_kzalloc(ice_hw_to_dev(hw), s_rule_size, GFP_KERNEL);
@@@ -2107,8 -2293,8 +2147,12 @@@ ice_rem_update_vsi_list(struct ice_hw *
  			struct ice_fltr_mgmt_list_entry *fm_list)
  {
  	enum ice_sw_lkup_type lkup_type;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 vsi_list_id;
+ 	int status = 0;
  
  	if (fm_list->fltr_info.fltr_act != ICE_FWD_TO_VSI_LIST ||
  	    fm_list->vsi_count == 0)
@@@ -2196,12 -2382,12 +2240,16 @@@ ice_remove_rule_internal(struct ice_hw 
  	struct ice_switch_info *sw = hw->switch_info;
  	struct ice_fltr_mgmt_list_entry *list_elem;
  	struct mutex *rule_lock; /* Lock to protect filter rule list */
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool remove_rule = false;
  	u16 vsi_handle;
+ 	int status = 0;
  
  	if (!ice_is_vsi_valid(hw, f_entry->fltr_info.vsi_handle))
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  	f_entry->fltr_info.fwd_id.hw_vsi_id =
  		ice_get_hw_vsi_num(hw, f_entry->fltr_info.vsi_handle);
  
@@@ -2293,8 -2598,8 +2341,12 @@@ enum ice_status ice_add_mac(struct ice_
  	u16 total_elem_left, s_rule_size;
  	struct ice_switch_info *sw;
  	struct mutex *rule_lock; /* Lock to protect filter rule list */
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 num_unicast = 0;
+ 	int status = 0;
  	u8 elem_sent;
  
  	if (!m_list || !hw)
@@@ -2612,8 -2917,7 +2664,12 @@@ enum ice_status ice_add_vlan(struct ice
   * the filter list with the necessary fields (including flags to
   * indicate Tx or Rx rules).
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_add_eth_mac(struct ice_hw *hw, struct list_head *em_list)
++=======
+ int ice_add_eth_mac(struct ice_hw *hw, struct list_head *em_list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_fltr_list_entry *em_list_itr;
  
@@@ -2641,8 -2945,7 +2697,12 @@@
   * @hw: pointer to the hardware structure
   * @em_list: list of ethertype or ethertype MAC entries
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_remove_eth_mac(struct ice_hw *hw, struct list_head *em_list)
++=======
+ int ice_remove_eth_mac(struct ice_hw *hw, struct list_head *em_list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_fltr_list_entry *em_list_itr, *tmp;
  
@@@ -2715,18 -3018,17 +2775,26 @@@ ice_rem_adv_rule_info(struct ice_hw *hw
   * add filter rule to set/unset given VSI as default VSI for the switch
   * (represented by swid)
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_cfg_dflt_vsi(struct ice_hw *hw, u16 vsi_handle, bool set, u8 direction)
++=======
+ int ice_cfg_dflt_vsi(struct ice_hw *hw, u16 vsi_handle, bool set, u8 direction)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_aqc_sw_rules_elem *s_rule;
  	struct ice_fltr_info f_info;
  	enum ice_adminq_opc opcode;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 s_rule_size;
  	u16 hw_vsi_id;
+ 	int status;
  
  	if (!ice_is_vsi_valid(hw, vsi_handle))
 -		return -EINVAL;
 +		return ICE_ERR_PARAM;
  	hw_vsi_id = ice_get_hw_vsi_num(hw, vsi_handle);
  
  	s_rule_size = set ? ICE_SW_RULE_RX_TX_ETH_HDR_SIZE :
@@@ -2832,12 -3134,12 +2900,19 @@@ ice_find_ucast_rule_entry(struct ice_h
   * This function removes either a MAC filter rule or a specific VSI from a
   * VSI list for a multicast MAC address.
   *
++<<<<<<< HEAD
 + * Returns ICE_ERR_DOES_NOT_EXIST if a given entry was not added by
 + * ice_add_mac. Caller should be aware that this call will only work if all
 + * the entries passed into m_list were added previously. It will not attempt to
 + * do a partial remove of entries that were found.
++=======
+  * Returns -ENOENT if a given entry was not added by ice_add_mac. Caller should
+  * be aware that this call will only work if all the entries passed into m_list
+  * were added previously. It will not attempt to do a partial remove of entries
+  * that were found.
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
   */
 -int ice_remove_mac(struct ice_hw *hw, struct list_head *m_list)
 +enum ice_status ice_remove_mac(struct ice_hw *hw, struct list_head *m_list)
  {
  	struct ice_fltr_list_entry *list_itr, *tmp;
  	struct mutex *rule_lock; /* Lock to protect filter rule list */
@@@ -2887,8 -3189,7 +2962,12 @@@
   * @hw: pointer to the hardware structure
   * @v_list: list of VLAN entries and forwarding information
   */
++<<<<<<< HEAD
 +enum ice_status
 +ice_remove_vlan(struct ice_hw *hw, struct list_head *v_list)
++=======
+ int ice_remove_vlan(struct ice_hw *hw, struct list_head *v_list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_fltr_list_entry *v_list_itr, *tmp;
  
@@@ -3044,9 -3345,8 +3123,14 @@@ static u8 ice_determine_promisc_mask(st
   * @recp_id: recipe ID for which the rule needs to removed
   * @v_list: list of promisc entries
   */
++<<<<<<< HEAD
 +static enum ice_status
 +ice_remove_promisc(struct ice_hw *hw, u8 recp_id,
 +		   struct list_head *v_list)
++=======
+ static int
+ ice_remove_promisc(struct ice_hw *hw, u8 recp_id, struct list_head *v_list)
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  {
  	struct ice_fltr_list_entry *v_list_itr, *tmp;
  
@@@ -3145,8 -3445,8 +3229,12 @@@ ice_set_vsi_promisc(struct ice_hw *hw, 
  	enum { UCAST_FLTR = 1, MCAST_FLTR, BCAST_FLTR };
  	struct ice_fltr_list_entry f_list_entry;
  	struct ice_fltr_info new_fltr;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool is_tx_fltr;
+ 	int status = 0;
  	u16 hw_vsi_id;
  	int pkt_type;
  	u8 recipe_id;
@@@ -3262,8 -3562,8 +3350,12 @@@ ice_set_vlan_vsi_promisc(struct ice_hw 
  	struct list_head vsi_list_head;
  	struct list_head *vlan_head;
  	struct mutex *vlan_lock; /* Lock to protect filter rule list */
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 vlan_id;
+ 	int status;
  
  	INIT_LIST_HEAD(&vsi_list_head);
  	vlan_lock = &sw->recp_list[ICE_SW_LKUP_VLAN].filt_rule_lock;
@@@ -3381,8 -3681,8 +3473,12 @@@ ice_alloc_res_cntr(struct ice_hw *hw, u
  		   u16 *counter_id)
  {
  	struct ice_aqc_alloc_free_res_elem *buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_len;
+ 	int status;
  
  	/* Allocate resource */
  	buf_len = struct_size(buf, elem, 1);
@@@ -3419,8 -3719,8 +3515,12 @@@ ice_free_res_cntr(struct ice_hw *hw, u
  		  u16 counter_id)
  {
  	struct ice_aqc_alloc_free_res_elem *buf;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 buf_len;
+ 	int status;
  
  	/* Free resource */
  	buf_len = struct_size(buf, elem, 1);
@@@ -3809,7 -4118,6 +3909,10 @@@ ice_add_sw_recipe(struct ice_hw *hw, st
  	struct ice_aqc_recipe_data_elem *tmp;
  	struct ice_aqc_recipe_data_elem *buf;
  	struct ice_recp_grp_entry *entry;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 free_res_idx;
  	u16 recipe_count;
  	u8 chain_idx;
@@@ -4105,8 -4406,8 +4209,12 @@@ static enum ice_statu
  ice_create_recipe_group(struct ice_hw *hw, struct ice_sw_recipe *rm,
  			struct ice_prot_lkup_ext *lkup_exts)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 recp_count = 0;
+ 	int status;
  
  	rm->n_grp_count = 0;
  
@@@ -4140,8 -4441,8 +4248,12 @@@ static enum ice_statu
  ice_get_fv(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,
  	   unsigned long *bm, struct list_head *fv_list)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 *prot_ids;
+ 	int status;
  	u16 i;
  
  	prot_ids = kcalloc(lkups_cnt, sizeof(*prot_ids), GFP_KERNEL);
@@@ -4196,9 -4567,8 +4308,14 @@@ ice_add_adv_recipe(struct ice_hw *hw, s
  	struct ice_sw_fv_list_entry *fvit;
  	struct ice_recp_grp_entry *r_tmp;
  	struct ice_sw_fv_list_entry *tmp;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
 +	struct ice_sw_recipe *rm;
 +	u16 match_tun_mask = 0;
++=======
+ 	struct ice_sw_recipe *rm;
+ 	int status = 0;
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 i;
  
  	if (!lkups_cnt)
@@@ -4594,8 -5055,8 +4711,12 @@@ ice_adv_add_update_vsi_list(struct ice_
  			    struct ice_adv_rule_info *cur_fltr,
  			    struct ice_adv_rule_info *new_fltr)
  {
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 vsi_list_id = 0;
+ 	int status;
  
  	if (cur_fltr->sw_act.fltr_act == ICE_FWD_TO_Q ||
  	    cur_fltr->sw_act.fltr_act == ICE_FWD_TO_QGRP ||
@@@ -4705,7 -5166,6 +4826,10 @@@ ice_add_adv_rule(struct ice_hw *hw, str
  	struct ice_aqc_sw_rules_elem *s_rule = NULL;
  	struct list_head *rule_head;
  	struct ice_switch_info *sw;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	const u8 *pkt = NULL;
  	u16 word_cnt;
  	u32 act = 0;
@@@ -4958,8 -5434,8 +5083,12 @@@ ice_adv_rem_update_vsi_list(struct ice_
  {
  	struct ice_vsi_list_map_info *vsi_list_info;
  	enum ice_sw_lkup_type lkup_type;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u16 vsi_list_id;
+ 	int status;
  
  	if (fm_list->rule_info.sw_act.fltr_act != ICE_FWD_TO_VSI_LIST ||
  	    fm_list->vsi_count == 0)
@@@ -5057,7 -5533,6 +5186,10 @@@ ice_rem_adv_rule(struct ice_hw *hw, str
  {
  	struct ice_adv_fltr_mgmt_list_entry *list_elem;
  	struct ice_prot_lkup_ext lkup_exts;
++<<<<<<< HEAD
 +	enum ice_status status = 0;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool remove_rule = false;
  	struct mutex *rule_lock; /* Lock to protect filter rule list */
  	u16 i, rid, vsi_handle;
diff --cc drivers/net/ethernet/intel/ice/ice_switch.h
index 34b7f74b1ab8,d8334beaaa8a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.h
+++ b/drivers/net/ethernet/intel/ice/ice_switch.h
@@@ -315,36 -329,32 +315,59 @@@ enum ice_statu
  ice_add_adv_rule(struct ice_hw *hw, struct ice_adv_lkup_elem *lkups,
  		 u16 lkups_cnt, struct ice_adv_rule_info *rinfo,
  		 struct ice_rule_query_data *added_entry);
++<<<<<<< HEAD
 +enum ice_status ice_update_sw_rule_bridge_mode(struct ice_hw *hw);
 +enum ice_status ice_add_mac(struct ice_hw *hw, struct list_head *m_lst);
 +enum ice_status ice_remove_mac(struct ice_hw *hw, struct list_head *m_lst);
 +enum ice_status
 +ice_add_eth_mac(struct ice_hw *hw, struct list_head *em_list);
 +enum ice_status
 +ice_remove_eth_mac(struct ice_hw *hw, struct list_head *em_list);
 +int
 +ice_cfg_rdma_fltr(struct ice_hw *hw, u16 vsi_handle, bool enable);
 +void ice_remove_vsi_fltr(struct ice_hw *hw, u16 vsi_handle);
 +enum ice_status
 +ice_add_vlan(struct ice_hw *hw, struct list_head *m_list);
 +enum ice_status ice_remove_vlan(struct ice_hw *hw, struct list_head *v_list);
 +
 +/* Promisc/defport setup for VSIs */
 +enum ice_status
 +ice_cfg_dflt_vsi(struct ice_hw *hw, u16 vsi_handle, bool set, u8 direction);
 +enum ice_status
++=======
+ int ice_update_sw_rule_bridge_mode(struct ice_hw *hw);
+ int ice_add_vlan(struct ice_hw *hw, struct list_head *m_list);
+ int ice_remove_vlan(struct ice_hw *hw, struct list_head *v_list);
+ int ice_add_mac(struct ice_hw *hw, struct list_head *m_lst);
+ int ice_remove_mac(struct ice_hw *hw, struct list_head *m_lst);
+ bool ice_mac_fltr_exist(struct ice_hw *hw, u8 *mac, u16 vsi_handle);
+ bool ice_vlan_fltr_exist(struct ice_hw *hw, u16 vlan_id, u16 vsi_handle);
+ int ice_add_eth_mac(struct ice_hw *hw, struct list_head *em_list);
+ int ice_remove_eth_mac(struct ice_hw *hw, struct list_head *em_list);
+ int ice_cfg_rdma_fltr(struct ice_hw *hw, u16 vsi_handle, bool enable);
+ void ice_remove_vsi_fltr(struct ice_hw *hw, u16 vsi_handle);
+ 
+ /* Promisc/defport setup for VSIs */
+ int ice_cfg_dflt_vsi(struct ice_hw *hw, u16 vsi_handle, bool set, u8 direction);
+ int
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  ice_set_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,
  		    u16 vid);
 -int
 +enum ice_status
  ice_clear_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,
  		      u16 vid);
 -int
 +enum ice_status
  ice_set_vlan_vsi_promisc(struct ice_hw *hw, u16 vsi_handle, u8 promisc_mask,
  			 bool rm_vlan_promisc);
  
++<<<<<<< HEAD
 +enum ice_status
 +ice_rem_adv_rule_for_vsi(struct ice_hw *hw, u16 vsi_handle);
 +enum ice_status
++=======
+ int ice_rem_adv_rule_for_vsi(struct ice_hw *hw, u16 vsi_handle);
+ int
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  ice_rem_adv_rule_by_id(struct ice_hw *hw,
  		       struct ice_rule_query_data *remove_entry);
  
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
index 6abf9ed1dd2e,4ce30ff96a79..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
@@@ -560,7 -560,6 +560,10 @@@ ice_vc_fdir_write_flow_prof(struct ice_
  	struct ice_flow_seg_info *old_seg;
  	struct ice_flow_prof *prof = NULL;
  	struct ice_fd_hw_prof *vf_prof;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	struct ice_pf *pf;
  	struct ice_hw *hw;
@@@ -1199,7 -1199,6 +1203,10 @@@ static int ice_vc_fdir_write_fltr(struc
  	struct ice_fdir_fltr *input = &conf->input;
  	struct ice_vsi *vsi, *ctrl_vsi;
  	struct ice_fltr_desc desc;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	struct ice_pf *pf;
  	struct ice_hw *hw;
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 3b25caebf610,92ddc3042d0d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -653,8 -653,8 +653,12 @@@ static int ice_vsi_manage_pvid(struct i
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_aqc_vsi_props *info;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int ret = 0;
+ 	int status;
  
  	ctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);
  	if (!ctxt)
@@@ -851,8 -850,8 +854,12 @@@ static int ice_vf_rebuild_host_mac_cfg(
  {
  	struct device *dev = ice_pf_to_dev(vf->pf);
  	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	u8 broadcast[ETH_ALEN];
+ 	int status;
  
  	if (ice_is_eswitch_mode_switchdev(vf->pf))
  		return 0;
@@@ -1303,8 -1302,8 +1310,12 @@@ static void ice_vf_pre_vsi_rebuild(stru
  static void ice_vf_rebuild_aggregator_node_cfg(struct ice_vsi *vsi)
  {
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
+ 	int status;
  
  	if (!vsi->agg_node)
  		return;
@@@ -1730,9 -1733,9 +1741,13 @@@ static int ice_init_vf_vsi_res(struct i
  {
  	struct ice_pf *pf = vf->pf;
  	u8 broadcast[ETH_ALEN];
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct ice_vsi *vsi;
  	struct device *dev;
+ 	int status;
  	int err;
  
  	vf->first_vector_idx = ice_calc_vf_first_vector_idx(pf, vf);
@@@ -2154,9 -2159,9 +2169,13 @@@ in
  ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
  		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)
  {
++<<<<<<< HEAD
 +	enum ice_status aq_ret;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	struct ice_pf *pf;
+ 	int aq_ret;
  
  	if (!vf)
  		return -EINVAL;
@@@ -2666,8 -2671,8 +2685,12 @@@ static int ice_vc_handle_rss_cfg(struc
  
  	if (rss_cfg->rss_algorithm == VIRTCHNL_RSS_ALG_R_ASYMMETRIC) {
  		struct ice_vsi_ctx *ctx;
++<<<<<<< HEAD
 +		enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  		u8 lut_type, hash_type;
+ 		int status;
  
  		lut_type = ICE_AQ_VSI_Q_OPT_RSS_LUT_VSI;
  		hash_type = add ? ICE_AQ_VSI_Q_OPT_RSS_XOR :
@@@ -2727,12 -2731,11 +2749,18 @@@
  
  			status = ice_rem_rss_cfg(hw, vsi->idx, hash_flds,
  						 addl_hdrs);
++<<<<<<< HEAD
 +			/* We just ignore ICE_ERR_DOES_NOT_EXIST, because
 +			 * if two configurations share the same profile remove
 +			 * one of them actually removes both, since the
 +			 * profile is deleted.
++=======
+ 			/* We just ignore -ENOENT, because if two configurations
+ 			 * share the same profile remove one of them actually
+ 			 * removes both, since the profile is deleted.
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  			 */
 -			if (status && status != -ENOENT) {
 +			if (status && status != ICE_ERR_DOES_NOT_EXIST) {
  				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  				dev_err(dev, "ice_rem_rss_cfg failed for VF ID:%d, error:%d\n",
  					vf->vf_id, status);
@@@ -2893,9 -2896,9 +2921,13 @@@ int ice_set_vf_spoofchk(struct net_devi
  	struct ice_pf *pf = np->vsi->back;
  	struct ice_vsi_ctx *ctx;
  	struct ice_vsi *vf_vsi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	struct device *dev;
  	struct ice_vf *vf;
+ 	int status;
  	int ret;
  
  	dev = ice_pf_to_dev(pf);
@@@ -3784,8 -3786,8 +3816,12 @@@ ice_vc_add_mac_addr(struct ice_vf *vf, 
  {
  	struct device *dev = ice_pf_to_dev(vf->pf);
  	u8 *mac_addr = vc_ether_addr->addr;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	int ret = 0;
+ 	int status;
  
  	/* device MAC already added */
  	if (ether_addr_equal(mac_addr, vf->dev_lan_addr.addr))
@@@ -5084,9 -5262,9 +5120,13 @@@ ice_is_malicious_vf(struct ice_pf *pf, 
  	s16 vf_id = le16_to_cpu(event->desc.retval);
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_mbx_data mbxdata;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 5518ac2a6442 (ice: Cleanup after ice_status removal)
  	bool malvf = false;
  	struct ice_vf *vf;
+ 	int status;
  
  	if (ice_validate_vf_id(pf, vf_id))
  		return false;
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_common.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_controlq.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_dcb.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_dcb.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_devlink.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fdir.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_flex_pipe.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_flex_pipe.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_flow.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_flow.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_fltr.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fltr.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_fw_update.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_nvm.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_nvm.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_sched.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_sched.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
