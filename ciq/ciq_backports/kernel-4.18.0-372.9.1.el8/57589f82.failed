ASoC: rt5682: move clk related code to rt5682_i2c_probe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Jack Yu <jack.yu@realtek.com>
commit 57589f82762e40bdaa975d840fa2bc5157b5be95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/57589f82.failed

The DAI clock is only used in I2S mode, to make it clear
and to fix clock resource release issue, we move CCF clock
related code to rt5682_i2c_probe to fix clock
register/unregister issue.

	Signed-off-by: Jack Yu <jack.yu@realtek.com>
Link: https://lore.kernel.org/r/20210929054344.12112-1-jack.yu@realtek.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 57589f82762e40bdaa975d840fa2bc5157b5be95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/rt5682.c
diff --cc sound/soc/codecs/rt5682.c
index 453facb1879d,914fe7debc05..000000000000
--- a/sound/soc/codecs/rt5682.c
+++ b/sound/soc/codecs/rt5682.c
@@@ -2587,8 -2591,7 +2591,12 @@@ static unsigned long rt5682_wclk_recalc
  	struct rt5682_priv *rt5682 =
  		container_of(hw, struct rt5682_priv,
  			     dai_clks_hw[RT5682_DAI_WCLK_IDX]);
++<<<<<<< HEAD
 +	struct snd_soc_component *component = rt5682->component;
 +	const char * const clk_name = __clk_get_name(hw->clk);
++=======
+ 	const char * const clk_name = clk_hw_get_name(hw);
++>>>>>>> 57589f82762e (ASoC: rt5682: move clk related code to rt5682_i2c_probe)
  
  	if (!rt5682_clk_check(rt5682))
  		return 0;
@@@ -2611,8 -2614,7 +2619,12 @@@ static long rt5682_wclk_round_rate(stru
  	struct rt5682_priv *rt5682 =
  		container_of(hw, struct rt5682_priv,
  			     dai_clks_hw[RT5682_DAI_WCLK_IDX]);
++<<<<<<< HEAD
 +	struct snd_soc_component *component = rt5682->component;
 +	const char * const clk_name = __clk_get_name(hw->clk);
++=======
+ 	const char * const clk_name = clk_hw_get_name(hw);
++>>>>>>> 57589f82762e (ASoC: rt5682: move clk related code to rt5682_i2c_probe)
  
  	if (!rt5682_clk_check(rt5682))
  		return -EINVAL;
@@@ -2635,9 -2637,9 +2647,9 @@@ static int rt5682_wclk_set_rate(struct 
  	struct rt5682_priv *rt5682 =
  		container_of(hw, struct rt5682_priv,
  			     dai_clks_hw[RT5682_DAI_WCLK_IDX]);
- 	struct snd_soc_component *component = rt5682->component;
+ 	struct snd_soc_component *component;
  	struct clk_hw *parent_hw;
 -	const char * const clk_name = clk_hw_get_name(hw);
 +	const char * const clk_name = __clk_get_name(hw->clk);
  	int pre_div;
  	unsigned int clk_pll2_out;
  
@@@ -2790,16 -2795,11 +2805,15 @@@ static const struct clk_ops rt5682_dai_
  	},
  };
  
- static int rt5682_register_dai_clks(struct snd_soc_component *component)
+ int rt5682_register_dai_clks(struct rt5682_priv *rt5682)
  {
- 	struct device *dev = component->dev;
- 	struct rt5682_priv *rt5682 = snd_soc_component_get_drvdata(component);
+ 	struct device *dev = rt5682->i2c_dev;
  	struct rt5682_platform_data *pdata = &rt5682->pdata;
 +	struct clk_init_data init;
 +	struct clk *dai_clk;
 +	struct clk_lookup *dai_clk_lookup;
  	struct clk_hw *dai_clk_hw;
 +	const char *parent_name;
  	int i, ret;
  
  	for (i = 0; i < RT5682_DAI_NUM_CLKS; ++i) {
@@@ -2860,15 -2854,8 +2874,16 @@@
  	}
  
  	return 0;
 +
 +err:
 +	do {
 +		if (rt5682->dai_clks_lookup[i])
 +			clkdev_drop(rt5682->dai_clks_lookup[i]);
 +	} while (i-- > 0);
 +
 +	return ret;
  }
+ EXPORT_SYMBOL_GPL(rt5682_register_dai_clks);
  #endif /* CONFIG_COMMON_CLK */
  
  static int rt5682_probe(struct snd_soc_component *component)
diff --git a/sound/soc/codecs/rt5682-i2c.c b/sound/soc/codecs/rt5682-i2c.c
index b9d5d7a0975b..a30e42932cf7 100644
--- a/sound/soc/codecs/rt5682-i2c.c
+++ b/sound/soc/codecs/rt5682-i2c.c
@@ -139,6 +139,8 @@ static int rt5682_i2c_probe(struct i2c_client *i2c,
 
 	i2c_set_clientdata(i2c, rt5682);
 
+	rt5682->i2c_dev = &i2c->dev;
+
 	rt5682->pdata = i2s_default_platform_data;
 
 	if (pdata)
@@ -276,6 +278,26 @@ static int rt5682_i2c_probe(struct i2c_client *i2c,
 			dev_err(&i2c->dev, "Failed to reguest IRQ: %d\n", ret);
 	}
 
+#ifdef CONFIG_COMMON_CLK
+	/* Check if MCLK provided */
+	rt5682->mclk = devm_clk_get(&i2c->dev, "mclk");
+	if (IS_ERR(rt5682->mclk)) {
+		if (PTR_ERR(rt5682->mclk) != -ENOENT) {
+			ret = PTR_ERR(rt5682->mclk);
+			return ret;
+		}
+		rt5682->mclk = NULL;
+	}
+
+	/* Register CCF DAI clock control */
+	ret = rt5682_register_dai_clks(rt5682);
+	if (ret)
+		return ret;
+
+	/* Initial setup for CCF */
+	rt5682->lrck[RT5682_AIF1] = 48000;
+#endif
+
 	return devm_snd_soc_register_component(&i2c->dev,
 					       &rt5682_soc_component_dev,
 					       rt5682_dai, ARRAY_SIZE(rt5682_dai));
* Unmerged path sound/soc/codecs/rt5682.c
diff --git a/sound/soc/codecs/rt5682.h b/sound/soc/codecs/rt5682.h
index c4aea9fcf7ce..4038ddba4e9c 100644
--- a/sound/soc/codecs/rt5682.h
+++ b/sound/soc/codecs/rt5682.h
@@ -1408,6 +1408,7 @@ enum {
 
 struct rt5682_priv {
 	struct snd_soc_component *component;
+	struct device *i2c_dev;
 	struct rt5682_platform_data pdata;
 	struct regmap *regmap;
 	struct regmap *sdw_regmap;
@@ -1464,6 +1465,8 @@ void rt5682_calibrate(struct rt5682_priv *rt5682);
 void rt5682_reset(struct rt5682_priv *rt5682);
 int rt5682_parse_dt(struct rt5682_priv *rt5682, struct device *dev);
 
+int rt5682_register_dai_clks(struct rt5682_priv *rt5682);
+
 #define RT5682_REG_NUM 318
 extern const struct reg_default rt5682_reg[RT5682_REG_NUM];
 
