ice: support for GRE in eswitch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
commit f0a35040adbe72f6b2e9ddc9fefdbcdbe0b92c55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/f0a35040.failed

Mostly reuse code from Geneve and VXLAN in TC parsing code. Add new GRE
header to match on correct fields. Create new dummy packets with GRE
fields.

Instead of checking if any encap values are presented in TC flower,
check if device is tunnel type or redirect is to tunnel device. This
will allow adding all combination of rules. For example filters only
with inner fields.

Return error in case device isn't tunnel but encap values are presented.

gre example:
- create tunnel device
ip l add $NVGRE_DEV type gretap remote $NVGRE_REM_IP local $VF1_IP \
dev $PF
- add tc filter (in switchdev mode)
tc filter add dev $NVGRE_DEV protocol ip parent ffff: flower dst_ip \
$NVGRE1_IP action mirred egress redirect dev $VF1_PR

	Signed-off-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Tested-by: Sandeep Penigalapati <sandeep.penigalapati@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit f0a35040adbe72f6b2e9ddc9fefdbcdbe0b92c55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_flex_pipe.c
#	drivers/net/ethernet/intel/ice/ice_flex_type.h
#	drivers/net/ethernet/intel/ice/ice_protocol_type.h
#	drivers/net/ethernet/intel/ice/ice_switch.c
#	drivers/net/ethernet/intel/ice/ice_tc_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_flex_pipe.c
index 5e8f3256f8ea,23cfcceb1536..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
@@@ -1566,6 -1566,30 +1566,33 @@@ static struct ice_buf_build *ice_pkg_bu
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_get_sw_prof_type - determine switch profile type
+  * @hw: pointer to the HW structure
+  * @fv: pointer to the switch field vector
+  */
+ static enum ice_prof_type
+ ice_get_sw_prof_type(struct ice_hw *hw, struct ice_fv *fv)
+ {
+ 	u16 i;
+ 
+ 	for (i = 0; i < hw->blk[ICE_BLK_SW].es.fvw; i++) {
+ 		/* UDP tunnel will have UDP_OF protocol ID and VNI offset */
+ 		if (fv->ew[i].prot_id == (u8)ICE_PROT_UDP_OF &&
+ 		    fv->ew[i].off == ICE_VNI_OFFSET)
+ 			return ICE_PROF_TUN_UDP;
+ 
+ 		/* GRE tunnel will have GRE protocol */
+ 		if (fv->ew[i].prot_id == (u8)ICE_PROT_GRE_OF)
+ 			return ICE_PROF_TUN_GRE;
+ 	}
+ 
+ 	return ICE_PROF_NON_TUN;
+ }
+ 
+ /**
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
   * ice_get_sw_fv_bitmap - Get switch field vector bitmap based on profile type
   * @hw: pointer to hardware structure
   * @req_profs: type of profiles requested
diff --cc drivers/net/ethernet/intel/ice/ice_flex_type.h
index 120bcebaa080,0f572a36d021..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flex_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_flex_type.h
@@@ -614,6 -615,9 +615,12 @@@ struct ice_chs_chg 
  
  enum ice_prof_type {
  	ICE_PROF_NON_TUN = 0x1,
++<<<<<<< HEAD
++=======
+ 	ICE_PROF_TUN_UDP = 0x2,
+ 	ICE_PROF_TUN_GRE = 0x4,
+ 	ICE_PROF_TUN_ALL = 0x6,
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  	ICE_PROF_ALL = 0xFF,
  };
  #endif /* _ICE_FLEX_TYPE_H_ */
diff --cc drivers/net/ethernet/intel/ice/ice_protocol_type.h
index 0b220dfa7457,dc1b0e9e6df5..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_protocol_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_protocol_type.h
@@@ -37,10 -37,22 +37,28 @@@ enum ice_protocol_type 
  	ICE_TCP_IL,
  	ICE_UDP_OF,
  	ICE_UDP_ILOS,
++<<<<<<< HEAD
++=======
+ 	ICE_VXLAN,
+ 	ICE_GENEVE,
+ 	ICE_NVGRE,
+ 	ICE_VXLAN_GPE,
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  	ICE_SCTP_IL,
  	ICE_PROTOCOL_LAST
  };
  
++<<<<<<< HEAD
++=======
+ enum ice_sw_tunnel_type {
+ 	ICE_NON_TUN = 0,
+ 	ICE_SW_TUN_VXLAN,
+ 	ICE_SW_TUN_GENEVE,
+ 	ICE_SW_TUN_NVGRE,
+ 	ICE_ALL_TUNNELS /* All tunnel types including NVGRE */
+ };
+ 
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  /* Decoders for ice_prot_id:
   * - F: First
   * - I: Inner
@@@ -85,8 -99,15 +103,9 @@@ enum ice_prot_id 
  #define ICE_IPV6_IL_HW		41
  #define ICE_TCP_IL_HW		49
  #define ICE_UDP_ILOS_HW		53
+ #define ICE_GRE_OF_HW		64
  
  #define ICE_UDP_OF_HW	52 /* UDP Tunnels */
 -#define ICE_META_DATA_ID_HW 255 /* this is used for tunnel type */
 -
 -#define ICE_MDID_SIZE 2
 -#define ICE_TUN_FLAG_MDID 21
 -#define ICE_TUN_FLAG_MDID_OFF (ICE_MDID_SIZE * ICE_TUN_FLAG_MDID)
 -#define ICE_TUN_FLAG_MASK 0xFF
  
  #define ICE_TUN_FLAG_FV_IND 2
  
@@@ -152,6 -173,18 +171,21 @@@ struct ice_l4_hdr 
  	__be16 check;
  };
  
++<<<<<<< HEAD
++=======
+ struct ice_udp_tnl_hdr {
+ 	__be16 field;
+ 	__be16 proto_type;
+ 	__be32 vni;     /* only use lower 24-bits */
+ };
+ 
+ struct ice_nvgre_hdr {
+ 	__be16 flags;
+ 	__be16 protocol;
+ 	__be32 tni_flow;
+ };
+ 
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  union ice_prot_hdr {
  	struct ice_ether_hdr eth_hdr;
  	struct ice_ethtype_hdr ethertype;
@@@ -160,6 -193,8 +194,11 @@@
  	struct ice_ipv6_hdr ipv6_hdr;
  	struct ice_l4_hdr l4_hdr;
  	struct ice_sctp_hdr sctp_hdr;
++<<<<<<< HEAD
++=======
+ 	struct ice_udp_tnl_hdr tnl_hdr;
+ 	struct ice_nvgre_hdr nvgre_hdr;
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  };
  
  /* This is mapping table entry that maps every word within a given protocol
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 0d07547b40f1,2af03b9845eb..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -35,6 -35,192 +35,195 @@@ struct ice_dummy_pkt_offsets 
  	u16 offset; /* ICE_PROTOCOL_LAST indicates end of list */
  };
  
++<<<<<<< HEAD
++=======
+ static const struct ice_dummy_pkt_offsets dummy_gre_tcp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_NVGRE,		34 },
+ 	{ ICE_MAC_IL,		42 },
+ 	{ ICE_IPV4_IL,		56 },
+ 	{ ICE_TCP_IL,		76 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_gre_tcp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00,	/* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x00,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x45, 0x00, 0x00, 0x3E,	/* ICE_IPV4_OFOS 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x2F, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x80, 0x00, 0x65, 0x58,	/* ICE_NVGRE 34 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00,	/* ICE_MAC_IL 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x14,	/* ICE_IPV4_IL 56 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00,	/* ICE_TCP_IL 76 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x02, 0x20, 0x00,
+ 	0x00, 0x00, 0x00, 0x00
+ };
+ 
+ static const struct ice_dummy_pkt_offsets dummy_gre_udp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_NVGRE,		34 },
+ 	{ ICE_MAC_IL,		42 },
+ 	{ ICE_IPV4_IL,		56 },
+ 	{ ICE_UDP_ILOS,		76 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_gre_udp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00,	/* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x00,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x45, 0x00, 0x00, 0x3E,	/* ICE_IPV4_OFOS 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x2F, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x80, 0x00, 0x65, 0x58,	/* ICE_NVGRE 34 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00,	/* ICE_MAC_IL 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x14,	/* ICE_IPV4_IL 56 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00,	/* ICE_UDP_ILOS 76 */
+ 	0x00, 0x08, 0x00, 0x00,
+ };
+ 
+ static const struct ice_dummy_pkt_offsets dummy_udp_tun_tcp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_VXLAN,		42 },
+ 	{ ICE_GENEVE,		42 },
+ 	{ ICE_VXLAN_GPE,	42 },
+ 	{ ICE_MAC_IL,		50 },
+ 	{ ICE_IPV4_IL,		64 },
+ 	{ ICE_TCP_IL,		84 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_udp_tun_tcp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00,  /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x00,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x45, 0x00, 0x00, 0x5a, /* ICE_IPV4_OFOS 14 */
+ 	0x00, 0x01, 0x00, 0x00,
+ 	0x40, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x12, 0xb5, /* ICE_UDP_OF 34 */
+ 	0x00, 0x46, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x65, 0x58, /* ICE_VXLAN 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_IL 50 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x28, /* ICE_IPV4_IL 64 */
+ 	0x00, 0x01, 0x00, 0x00,
+ 	0x40, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_TCP_IL 84 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x02, 0x20, 0x00,
+ 	0x00, 0x00, 0x00, 0x00
+ };
+ 
+ static const struct ice_dummy_pkt_offsets dummy_udp_tun_udp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_VXLAN,		42 },
+ 	{ ICE_GENEVE,		42 },
+ 	{ ICE_VXLAN_GPE,	42 },
+ 	{ ICE_MAC_IL,		50 },
+ 	{ ICE_IPV4_IL,		64 },
+ 	{ ICE_UDP_ILOS,		84 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_udp_tun_udp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00,  /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x00,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x45, 0x00, 0x00, 0x4e, /* ICE_IPV4_OFOS 14 */
+ 	0x00, 0x01, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x12, 0xb5, /* ICE_UDP_OF 34 */
+ 	0x00, 0x3a, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x65, 0x58, /* ICE_VXLAN 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_IL 50 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x1c, /* ICE_IPV4_IL 64 */
+ 	0x00, 0x01, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_UDP_ILOS 84 */
+ 	0x00, 0x08, 0x00, 0x00,
+ };
+ 
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  /* offset info for MAC + IPv4 + UDP dummy packet */
  static const struct ice_dummy_pkt_offsets dummy_udp_packet_offsets[] = {
  	{ ICE_MAC_OFOS,		0 },
@@@ -3463,6 -3768,9 +3652,12 @@@ static const struct ice_prot_ext_tbl_en
  	{ ICE_TCP_IL,		{ 0, 2 } },
  	{ ICE_UDP_OF,		{ 0, 2 } },
  	{ ICE_UDP_ILOS,		{ 0, 2 } },
++<<<<<<< HEAD
++=======
+ 	{ ICE_VXLAN,		{ 8, 10, 12, 14 } },
+ 	{ ICE_GENEVE,		{ 8, 10, 12, 14 } },
+ 	{ ICE_NVGRE,            { 0, 2, 4, 6 } },
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  };
  
  static struct ice_protocol_entry ice_prot_id_tbl[ICE_PROTOCOL_LAST] = {
@@@ -3477,6 -3785,9 +3672,12 @@@
  	{ ICE_TCP_IL,		ICE_TCP_IL_HW },
  	{ ICE_UDP_OF,		ICE_UDP_OF_HW },
  	{ ICE_UDP_ILOS,		ICE_UDP_ILOS_HW },
++<<<<<<< HEAD
++=======
+ 	{ ICE_VXLAN,		ICE_UDP_OF_HW },
+ 	{ ICE_GENEVE,		ICE_UDP_OF_HW },
+ 	{ ICE_NVGRE,            ICE_GRE_OF_HW },
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  };
  
  /**
@@@ -4160,6 -4462,55 +4361,58 @@@ free_mem
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ice_tun_type_match_word - determine if tun type needs a match mask
+  * @tun_type: tunnel type
+  * @mask: mask to be used for the tunnel
+  */
+ static bool ice_tun_type_match_word(enum ice_sw_tunnel_type tun_type, u16 *mask)
+ {
+ 	switch (tun_type) {
+ 	case ICE_SW_TUN_GENEVE:
+ 	case ICE_SW_TUN_VXLAN:
+ 	case ICE_SW_TUN_NVGRE:
+ 		*mask = ICE_TUN_FLAG_MASK;
+ 		return true;
+ 
+ 	default:
+ 		*mask = 0;
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * ice_add_special_words - Add words that are not protocols, such as metadata
+  * @rinfo: other information regarding the rule e.g. priority and action info
+  * @lkup_exts: lookup word structure
+  */
+ static enum ice_status
+ ice_add_special_words(struct ice_adv_rule_info *rinfo,
+ 		      struct ice_prot_lkup_ext *lkup_exts)
+ {
+ 	u16 mask;
+ 
+ 	/* If this is a tunneled packet, then add recipe index to match the
+ 	 * tunnel bit in the packet metadata flags.
+ 	 */
+ 	if (ice_tun_type_match_word(rinfo->tun_type, &mask)) {
+ 		if (lkup_exts->n_val_words < ICE_MAX_CHAIN_WORDS) {
+ 			u8 word = lkup_exts->n_val_words++;
+ 
+ 			lkup_exts->fv_words[word].prot_id = ICE_META_DATA_ID_HW;
+ 			lkup_exts->fv_words[word].off = ICE_TUN_FLAG_MDID_OFF;
+ 			lkup_exts->field_mask[word] = mask;
+ 		} else {
+ 			return ICE_ERR_MAX_LIMIT;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  /* ice_get_compat_fv_bitmap - Get compatible field vector bitmap for rule
   * @hw: pointer to hardware structure
   * @rinfo: other information regarding the rule e.g. priority and action info
@@@ -4169,9 -4520,30 +4422,32 @@@ static voi
  ice_get_compat_fv_bitmap(struct ice_hw *hw, struct ice_adv_rule_info *rinfo,
  			 unsigned long *bm)
  {
 -	enum ice_prof_type prof_type;
 -
  	bitmap_zero(bm, ICE_MAX_NUM_PROFILES);
  
++<<<<<<< HEAD
 +	ice_get_sw_fv_bitmap(hw, ICE_PROF_NON_TUN, bm);
++=======
+ 	switch (rinfo->tun_type) {
+ 	case ICE_NON_TUN:
+ 		prof_type = ICE_PROF_NON_TUN;
+ 		break;
+ 	case ICE_ALL_TUNNELS:
+ 		prof_type = ICE_PROF_TUN_ALL;
+ 		break;
+ 	case ICE_SW_TUN_GENEVE:
+ 	case ICE_SW_TUN_VXLAN:
+ 		prof_type = ICE_PROF_TUN_UDP;
+ 		break;
+ 	case ICE_SW_TUN_NVGRE:
+ 		prof_type = ICE_PROF_TUN_GRE;
+ 		break;
+ 	default:
+ 		prof_type = ICE_PROF_ALL;
+ 		break;
+ 	}
+ 
+ 	ice_get_sw_fv_bitmap(hw, prof_type, bm);
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  }
  
  /**
@@@ -4376,6 -4756,35 +4652,38 @@@ ice_find_dummy_packet(struct ice_adv_lk
  			ipv6 = true;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (tun_type == ICE_SW_TUN_NVGRE) {
+ 		if (tcp) {
+ 			*pkt = dummy_gre_tcp_packet;
+ 			*pkt_len = sizeof(dummy_gre_tcp_packet);
+ 			*offsets = dummy_gre_tcp_packet_offsets;
+ 			return;
+ 		}
+ 
+ 		*pkt = dummy_gre_udp_packet;
+ 		*pkt_len = sizeof(dummy_gre_udp_packet);
+ 		*offsets = dummy_gre_udp_packet_offsets;
+ 		return;
+ 	}
+ 
+ 	if (tun_type == ICE_SW_TUN_VXLAN ||
+ 	    tun_type == ICE_SW_TUN_GENEVE) {
+ 		if (tcp) {
+ 			*pkt = dummy_udp_tun_tcp_packet;
+ 			*pkt_len = sizeof(dummy_udp_tun_tcp_packet);
+ 			*offsets = dummy_udp_tun_tcp_packet_offsets;
+ 			return;
+ 		}
+ 
+ 		*pkt = dummy_udp_tun_udp_packet;
+ 		*pkt_len = sizeof(dummy_udp_tun_udp_packet);
+ 		*offsets = dummy_udp_tun_udp_packet_offsets;
+ 		return;
+ 	}
+ 
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  	if (udp && !ipv6) {
  		if (vlan) {
  			*pkt = dummy_vlan_udp_packet;
@@@ -4496,6 -4905,13 +4804,16 @@@ ice_fill_adv_dummy_packet(struct ice_ad
  		case ICE_SCTP_IL:
  			len = sizeof(struct ice_sctp_hdr);
  			break;
++<<<<<<< HEAD
++=======
+ 		case ICE_NVGRE:
+ 			len = sizeof(struct ice_nvgre_hdr);
+ 			break;
+ 		case ICE_VXLAN:
+ 		case ICE_GENEVE:
+ 			len = sizeof(struct ice_udp_tnl_hdr);
+ 			break;
++>>>>>>> f0a35040adbe (ice: support for GRE in eswitch)
  		default:
  			return ICE_ERR_PARAM;
  		}
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_flex_pipe.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_flex_type.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_protocol_type.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
