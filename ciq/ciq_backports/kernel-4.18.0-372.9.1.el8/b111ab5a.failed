ice: ensure the hardware Clock Generation Unit is configured

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit b111ab5a11eb8f7261940c95ada9fbf5ca784731
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/b111ab5a.failed

The E822 device has a Clock Generation Unit (CGU) responsible for
determining the clock frequency that drives the timers.

Ensure this function is initialized when bringing up the PTP support, so
that the clock has a known frequency.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit b111ab5a11eb8f7261940c95ada9fbf5ca784731)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ptp_consts.h
#	drivers/net/ethernet/intel/ice/ice_ptp_hw.c
#	drivers/net/ethernet/intel/ice/ice_ptp_hw.h
diff --cc drivers/net/ethernet/intel/ice/ice_ptp_hw.c
index 5dbd4d91dba1,20204bb5485d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
@@@ -3,6 -3,8 +3,11 @@@
  
  #include "ice_common.h"
  #include "ice_ptp_hw.h"
++<<<<<<< HEAD
++=======
+ #include "ice_ptp_consts.h"
+ #include "ice_cgu_regs.h"
++>>>>>>> b111ab5a11eb (ice: ensure the hardware Clock Generation Unit is configured)
  
  /* Low level functions for interacting with and managing the device clock used
   * for the Precision Time Protocol.
@@@ -51,6 -80,2036 +56,2039 @@@ u8 ice_get_ptp_src_clock_index(struct i
  	return hw->func_caps.ts_func_info.tmr_index_assoc;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ice_ptp_read_src_incval - Read source timer increment value
+  * @hw: pointer to HW struct
+  *
+  * Read the increment value of the source timer and return it.
+  */
+ static u64 ice_ptp_read_src_incval(struct ice_hw *hw)
+ {
+ 	u32 lo, hi;
+ 	u8 tmr_idx;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 
+ 	lo = rd32(hw, GLTSYN_INCVAL_L(tmr_idx));
+ 	hi = rd32(hw, GLTSYN_INCVAL_H(tmr_idx));
+ 
+ 	return ((u64)(hi & INCVAL_HIGH_M) << 32) | lo;
+ }
+ 
+ /**
+  * ice_ptp_src_cmd - Prepare source timer for a timer command
+  * @hw: pointer to HW structure
+  * @cmd: Timer command
+  *
+  * Prepare the source timer for an upcoming timer sync command.
+  */
+ static void ice_ptp_src_cmd(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)
+ {
+ 	u32 cmd_val;
+ 	u8 tmr_idx;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 	cmd_val = tmr_idx << SEL_CPK_SRC;
+ 
+ 	switch (cmd) {
+ 	case INIT_TIME:
+ 		cmd_val |= GLTSYN_CMD_INIT_TIME;
+ 		break;
+ 	case INIT_INCVAL:
+ 		cmd_val |= GLTSYN_CMD_INIT_INCVAL;
+ 		break;
+ 	case ADJ_TIME:
+ 		cmd_val |= GLTSYN_CMD_ADJ_TIME;
+ 		break;
+ 	case ADJ_TIME_AT_TIME:
+ 		cmd_val |= GLTSYN_CMD_ADJ_INIT_TIME;
+ 		break;
+ 	case READ_TIME:
+ 		cmd_val |= GLTSYN_CMD_READ_TIME;
+ 		break;
+ 	}
+ 
+ 	wr32(hw, GLTSYN_CMD, cmd_val);
+ }
+ 
+ /**
+  * ice_ptp_exec_tmr_cmd - Execute all prepared timer commands
+  * @hw: pointer to HW struct
+  *
+  * Write the SYNC_EXEC_CMD bit to the GLTSYN_CMD_SYNC register, and flush the
+  * write immediately. This triggers the hardware to begin executing all of the
+  * source and PHY timer commands synchronously.
+  */
+ static void ice_ptp_exec_tmr_cmd(struct ice_hw *hw)
+ {
+ 	wr32(hw, GLTSYN_CMD_SYNC, SYNC_EXEC_CMD);
+ 	ice_flush(hw);
+ }
+ 
+ /* E822 family functions
+  *
+  * The following functions operate on the E822 family of devices.
+  */
+ 
+ /**
+  * ice_fill_phy_msg_e822 - Fill message data for a PHY register access
+  * @msg: the PHY message buffer to fill in
+  * @port: the port to access
+  * @offset: the register offset
+  */
+ static void
+ ice_fill_phy_msg_e822(struct ice_sbq_msg_input *msg, u8 port, u16 offset)
+ {
+ 	int phy_port, phy, quadtype;
+ 
+ 	phy_port = port % ICE_PORTS_PER_PHY;
+ 	phy = port / ICE_PORTS_PER_PHY;
+ 	quadtype = (port / ICE_PORTS_PER_QUAD) % ICE_NUM_QUAD_TYPE;
+ 
+ 	if (quadtype == 0) {
+ 		msg->msg_addr_low = P_Q0_L(P_0_BASE + offset, phy_port);
+ 		msg->msg_addr_high = P_Q0_H(P_0_BASE + offset, phy_port);
+ 	} else {
+ 		msg->msg_addr_low = P_Q1_L(P_4_BASE + offset, phy_port);
+ 		msg->msg_addr_high = P_Q1_H(P_4_BASE + offset, phy_port);
+ 	}
+ 
+ 	if (phy == 0)
+ 		msg->dest_dev = rmn_0;
+ 	else if (phy == 1)
+ 		msg->dest_dev = rmn_1;
+ 	else
+ 		msg->dest_dev = rmn_2;
+ }
+ 
+ /**
+  * ice_is_64b_phy_reg_e822 - Check if this is a 64bit PHY register
+  * @low_addr: the low address to check
+  * @high_addr: on return, contains the high address of the 64bit register
+  *
+  * Checks if the provided low address is one of the known 64bit PHY values
+  * represented as two 32bit registers. If it is, return the appropriate high
+  * register offset to use.
+  */
+ static bool ice_is_64b_phy_reg_e822(u16 low_addr, u16 *high_addr)
+ {
+ 	switch (low_addr) {
+ 	case P_REG_PAR_PCS_TX_OFFSET_L:
+ 		*high_addr = P_REG_PAR_PCS_TX_OFFSET_U;
+ 		return true;
+ 	case P_REG_PAR_PCS_RX_OFFSET_L:
+ 		*high_addr = P_REG_PAR_PCS_RX_OFFSET_U;
+ 		return true;
+ 	case P_REG_PAR_TX_TIME_L:
+ 		*high_addr = P_REG_PAR_TX_TIME_U;
+ 		return true;
+ 	case P_REG_PAR_RX_TIME_L:
+ 		*high_addr = P_REG_PAR_RX_TIME_U;
+ 		return true;
+ 	case P_REG_TOTAL_TX_OFFSET_L:
+ 		*high_addr = P_REG_TOTAL_TX_OFFSET_U;
+ 		return true;
+ 	case P_REG_TOTAL_RX_OFFSET_L:
+ 		*high_addr = P_REG_TOTAL_RX_OFFSET_U;
+ 		return true;
+ 	case P_REG_UIX66_10G_40G_L:
+ 		*high_addr = P_REG_UIX66_10G_40G_U;
+ 		return true;
+ 	case P_REG_UIX66_25G_100G_L:
+ 		*high_addr = P_REG_UIX66_25G_100G_U;
+ 		return true;
+ 	case P_REG_TX_CAPTURE_L:
+ 		*high_addr = P_REG_TX_CAPTURE_U;
+ 		return true;
+ 	case P_REG_RX_CAPTURE_L:
+ 		*high_addr = P_REG_RX_CAPTURE_U;
+ 		return true;
+ 	case P_REG_TX_TIMER_INC_PRE_L:
+ 		*high_addr = P_REG_TX_TIMER_INC_PRE_U;
+ 		return true;
+ 	case P_REG_RX_TIMER_INC_PRE_L:
+ 		*high_addr = P_REG_RX_TIMER_INC_PRE_U;
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * ice_is_40b_phy_reg_e822 - Check if this is a 40bit PHY register
+  * @low_addr: the low address to check
+  * @high_addr: on return, contains the high address of the 40bit value
+  *
+  * Checks if the provided low address is one of the known 40bit PHY values
+  * split into two registers with the lower 8 bits in the low register and the
+  * upper 32 bits in the high register. If it is, return the appropriate high
+  * register offset to use.
+  */
+ static bool ice_is_40b_phy_reg_e822(u16 low_addr, u16 *high_addr)
+ {
+ 	switch (low_addr) {
+ 	case P_REG_TIMETUS_L:
+ 		*high_addr = P_REG_TIMETUS_U;
+ 		return true;
+ 	case P_REG_PAR_RX_TUS_L:
+ 		*high_addr = P_REG_PAR_RX_TUS_U;
+ 		return true;
+ 	case P_REG_PAR_TX_TUS_L:
+ 		*high_addr = P_REG_PAR_TX_TUS_U;
+ 		return true;
+ 	case P_REG_PCS_RX_TUS_L:
+ 		*high_addr = P_REG_PCS_RX_TUS_U;
+ 		return true;
+ 	case P_REG_PCS_TX_TUS_L:
+ 		*high_addr = P_REG_PCS_TX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PAR_RX_TUS_L:
+ 		*high_addr = P_REG_DESK_PAR_RX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PAR_TX_TUS_L:
+ 		*high_addr = P_REG_DESK_PAR_TX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PCS_RX_TUS_L:
+ 		*high_addr = P_REG_DESK_PCS_RX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PCS_TX_TUS_L:
+ 		*high_addr = P_REG_DESK_PCS_TX_TUS_U;
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * ice_read_phy_reg_e822 - Read a PHY register
+  * @hw: pointer to the HW struct
+  * @port: PHY port to read from
+  * @offset: PHY register offset to read
+  * @val: on return, the contents read from the PHY
+  *
+  * Read a PHY register for the given port over the device sideband queue.
+  */
+ int
+ ice_read_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 *val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	ice_fill_phy_msg_e822(&msg, port, offset);
+ 	msg.opcode = ice_sbq_msg_rd;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	*val = msg.data;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_64b_phy_reg_e822 - Read a 64bit value from PHY registers
+  * @hw: pointer to the HW struct
+  * @port: PHY port to read from
+  * @low_addr: offset of the lower register to read from
+  * @val: on return, the contents of the 64bit value from the PHY registers
+  *
+  * Reads the two registers associated with a 64bit value and returns it in the
+  * val pointer. The offset always specifies the lower register offset to use.
+  * The high offset is looked up. This function only operates on registers
+  * known to be two parts of a 64bit value.
+  */
+ static int
+ ice_read_64b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 *val)
+ {
+ 	u32 low, high;
+ 	u16 high_addr;
+ 	int err;
+ 
+ 	/* Only operate on registers known to be split into two 32bit
+ 	 * registers.
+ 	 */
+ 	if (!ice_is_64b_phy_reg_e822(low_addr, &high_addr)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Invalid 64b register addr 0x%08x\n",
+ 			  low_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, low_addr, &low);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read from low register 0x%08x\n, err %d",
+ 			  low_addr, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, high_addr, &high);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read from high register 0x%08x\n, err %d",
+ 			  high_addr, err);
+ 		return err;
+ 	}
+ 
+ 	*val = (u64)high << 32 | low;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_phy_reg_e822 - Write a PHY register
+  * @hw: pointer to the HW struct
+  * @port: PHY port to write to
+  * @offset: PHY register offset to write
+  * @val: The value to write to the register
+  *
+  * Write a PHY register for the given port over the device sideband queue.
+  */
+ int
+ ice_write_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	ice_fill_phy_msg_e822(&msg, port, offset);
+ 	msg.opcode = ice_sbq_msg_wr;
+ 	msg.data = val;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_40b_phy_reg_e822 - Write a 40b value to the PHY
+  * @hw: pointer to the HW struct
+  * @port: port to write to
+  * @low_addr: offset of the low register
+  * @val: 40b value to write
+  *
+  * Write the provided 40b value to the two associated registers by splitting
+  * it up into two chunks, the lower 8 bits and the upper 32 bits.
+  */
+ static int
+ ice_write_40b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 val)
+ {
+ 	u32 low, high;
+ 	u16 high_addr;
+ 	int err;
+ 
+ 	/* Only operate on registers known to be split into a lower 8 bit
+ 	 * register and an upper 32 bit register.
+ 	 */
+ 	if (!ice_is_40b_phy_reg_e822(low_addr, &high_addr)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Invalid 40b register addr 0x%08x\n",
+ 			  low_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	low = (u32)(val & P_REG_40B_LOW_M);
+ 	high = (u32)(val >> P_REG_40B_HIGH_S);
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, low_addr, low);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to low register 0x%08x\n, err %d",
+ 			  low_addr, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, high_addr, high);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to high register 0x%08x\n, err %d",
+ 			  high_addr, err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_64b_phy_reg_e822 - Write a 64bit value to PHY registers
+  * @hw: pointer to the HW struct
+  * @port: PHY port to read from
+  * @low_addr: offset of the lower register to read from
+  * @val: the contents of the 64bit value to write to PHY
+  *
+  * Write the 64bit value to the two associated 32bit PHY registers. The offset
+  * is always specified as the lower register, and the high address is looked
+  * up. This function only operates on registers known to be two parts of
+  * a 64bit value.
+  */
+ static int
+ ice_write_64b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 val)
+ {
+ 	u32 low, high;
+ 	u16 high_addr;
+ 	int err;
+ 
+ 	/* Only operate on registers known to be split into two 32bit
+ 	 * registers.
+ 	 */
+ 	if (!ice_is_64b_phy_reg_e822(low_addr, &high_addr)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Invalid 64b register addr 0x%08x\n",
+ 			  low_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	low = lower_32_bits(val);
+ 	high = upper_32_bits(val);
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, low_addr, low);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to low register 0x%08x\n, err %d",
+ 			  low_addr, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, high_addr, high);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to high register 0x%08x\n, err %d",
+ 			  high_addr, err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_fill_quad_msg_e822 - Fill message data for quad register access
+  * @msg: the PHY message buffer to fill in
+  * @quad: the quad to access
+  * @offset: the register offset
+  *
+  * Fill a message buffer for accessing a register in a quad shared between
+  * multiple PHYs.
+  */
+ static void
+ ice_fill_quad_msg_e822(struct ice_sbq_msg_input *msg, u8 quad, u16 offset)
+ {
+ 	u32 addr;
+ 
+ 	msg->dest_dev = rmn_0;
+ 
+ 	if ((quad % ICE_NUM_QUAD_TYPE) == 0)
+ 		addr = Q_0_BASE + offset;
+ 	else
+ 		addr = Q_1_BASE + offset;
+ 
+ 	msg->msg_addr_low = lower_16_bits(addr);
+ 	msg->msg_addr_high = upper_16_bits(addr);
+ }
+ 
+ /**
+  * ice_read_quad_reg_e822 - Read a PHY quad register
+  * @hw: pointer to the HW struct
+  * @quad: quad to read from
+  * @offset: quad register offset to read
+  * @val: on return, the contents read from the quad
+  *
+  * Read a quad register over the device sideband queue. Quad registers are
+  * shared between multiple PHYs.
+  */
+ int
+ ice_read_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 *val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	if (quad >= ICE_MAX_QUAD)
+ 		return -EINVAL;
+ 
+ 	ice_fill_quad_msg_e822(&msg, quad, offset);
+ 	msg.opcode = ice_sbq_msg_rd;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	*val = msg.data;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_quad_reg_e822 - Write a PHY quad register
+  * @hw: pointer to the HW struct
+  * @quad: quad to write to
+  * @offset: quad register offset to write
+  * @val: The value to write to the register
+  *
+  * Write a quad register over the device sideband queue. Quad registers are
+  * shared between multiple PHYs.
+  */
+ int
+ ice_write_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	if (quad >= ICE_MAX_QUAD)
+ 		return -EINVAL;
+ 
+ 	ice_fill_quad_msg_e822(&msg, quad, offset);
+ 	msg.opcode = ice_sbq_msg_wr;
+ 	msg.data = val;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_phy_tstamp_e822 - Read a PHY timestamp out of the quad block
+  * @hw: pointer to the HW struct
+  * @quad: the quad to read from
+  * @idx: the timestamp index to read
+  * @tstamp: on return, the 40bit timestamp value
+  *
+  * Read a 40bit timestamp value out of the two associated registers in the
+  * quad memory block that is shared between the internal PHYs of the E822
+  * family of devices.
+  */
+ static int
+ ice_read_phy_tstamp_e822(struct ice_hw *hw, u8 quad, u8 idx, u64 *tstamp)
+ {
+ 	u16 lo_addr, hi_addr;
+ 	u32 lo, hi;
+ 	int err;
+ 
+ 	lo_addr = (u16)TS_L(Q_REG_TX_MEMORY_BANK_START, idx);
+ 	hi_addr = (u16)TS_H(Q_REG_TX_MEMORY_BANK_START, idx);
+ 
+ 	err = ice_read_quad_reg_e822(hw, quad, lo_addr, &lo);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read low PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_read_quad_reg_e822(hw, quad, hi_addr, &hi);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read high PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* For E822 based internal PHYs, the timestamp is reported with the
+ 	 * lower 8 bits in the low register, and the upper 32 bits in the high
+ 	 * register.
+ 	 */
+ 	*tstamp = ((u64)hi) << TS_PHY_HIGH_S | ((u64)lo & TS_PHY_LOW_M);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_clear_phy_tstamp_e822 - Clear a timestamp from the quad block
+  * @hw: pointer to the HW struct
+  * @quad: the quad to read from
+  * @idx: the timestamp index to reset
+  *
+  * Clear a timestamp, resetting its valid bit, from the PHY quad block that is
+  * shared between the internal PHYs on the E822 devices.
+  */
+ static int
+ ice_clear_phy_tstamp_e822(struct ice_hw *hw, u8 quad, u8 idx)
+ {
+ 	u16 lo_addr, hi_addr;
+ 	int err;
+ 
+ 	lo_addr = (u16)TS_L(Q_REG_TX_MEMORY_BANK_START, idx);
+ 	hi_addr = (u16)TS_H(Q_REG_TX_MEMORY_BANK_START, idx);
+ 
+ 	err = ice_write_quad_reg_e822(hw, quad, lo_addr, 0);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to clear low PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_write_quad_reg_e822(hw, quad, hi_addr, 0);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to clear high PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_cgu_reg_e822 - Read a CGU register
+  * @hw: pointer to the HW struct
+  * @addr: Register address to read
+  * @val: storage for register value read
+  *
+  * Read the contents of a register of the Clock Generation Unit. Only
+  * applicable to E822 devices.
+  */
+ static int
+ ice_read_cgu_reg_e822(struct ice_hw *hw, u32 addr, u32 *val)
+ {
+ 	struct ice_sbq_msg_input cgu_msg;
+ 	int err;
+ 
+ 	cgu_msg.opcode = ice_sbq_msg_rd;
+ 	cgu_msg.dest_dev = cgu;
+ 	cgu_msg.msg_addr_low = addr;
+ 	cgu_msg.msg_addr_high = 0x0;
+ 
+ 	err = ice_sbq_rw_reg(hw, &cgu_msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read CGU register 0x%04x, err %d\n",
+ 			  addr, err);
+ 		return err;
+ 	}
+ 
+ 	*val = cgu_msg.data;
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_write_cgu_reg_e822 - Write a CGU register
+  * @hw: pointer to the HW struct
+  * @addr: Register address to write
+  * @val: value to write into the register
+  *
+  * Write the specified value to a register of the Clock Generation Unit. Only
+  * applicable to E822 devices.
+  */
+ static int
+ ice_write_cgu_reg_e822(struct ice_hw *hw, u32 addr, u32 val)
+ {
+ 	struct ice_sbq_msg_input cgu_msg;
+ 	int err;
+ 
+ 	cgu_msg.opcode = ice_sbq_msg_wr;
+ 	cgu_msg.dest_dev = cgu;
+ 	cgu_msg.msg_addr_low = addr;
+ 	cgu_msg.msg_addr_high = 0x0;
+ 	cgu_msg.data = val;
+ 
+ 	err = ice_sbq_rw_reg(hw, &cgu_msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write CGU register 0x%04x, err %d\n",
+ 			  addr, err);
+ 		return err;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_clk_freq_str - Convert time_ref_freq to string
+  * @clk_freq: Clock frequency
+  *
+  * Convert the specified TIME_REF clock frequency to a string.
+  */
+ static const char *ice_clk_freq_str(u8 clk_freq)
+ {
+ 	switch ((enum ice_time_ref_freq)clk_freq) {
+ 	case ICE_TIME_REF_FREQ_25_000:
+ 		return "25 MHz";
+ 	case ICE_TIME_REF_FREQ_122_880:
+ 		return "122.88 MHz";
+ 	case ICE_TIME_REF_FREQ_125_000:
+ 		return "125 MHz";
+ 	case ICE_TIME_REF_FREQ_153_600:
+ 		return "153.6 MHz";
+ 	case ICE_TIME_REF_FREQ_156_250:
+ 		return "156.25 MHz";
+ 	case ICE_TIME_REF_FREQ_245_760:
+ 		return "245.76 MHz";
+ 	default:
+ 		return "Unknown";
+ 	}
+ }
+ 
+ /**
+  * ice_clk_src_str - Convert time_ref_src to string
+  * @clk_src: Clock source
+  *
+  * Convert the specified clock source to its string name.
+  */
+ static const char *ice_clk_src_str(u8 clk_src)
+ {
+ 	switch ((enum ice_clk_src)clk_src) {
+ 	case ICE_CLK_SRC_TCX0:
+ 		return "TCX0";
+ 	case ICE_CLK_SRC_TIME_REF:
+ 		return "TIME_REF";
+ 	default:
+ 		return "Unknown";
+ 	}
+ }
+ 
+ /**
+  * ice_cfg_cgu_pll_e822 - Configure the Clock Generation Unit
+  * @hw: pointer to the HW struct
+  * @clk_freq: Clock frequency to program
+  * @clk_src: Clock source to select (TIME_REF, or TCX0)
+  *
+  * Configure the Clock Generation Unit with the desired clock frequency and
+  * time reference, enabling the PLL which drives the PTP hardware clock.
+  */
+ static int
+ ice_cfg_cgu_pll_e822(struct ice_hw *hw, enum ice_time_ref_freq clk_freq,
+ 		     enum ice_clk_src clk_src)
+ {
+ 	union tspll_ro_bwm_lf bwm_lf;
+ 	union nac_cgu_dword19 dw19;
+ 	union nac_cgu_dword22 dw22;
+ 	union nac_cgu_dword24 dw24;
+ 	union nac_cgu_dword9 dw9;
+ 	int err;
+ 
+ 	if (clk_freq >= NUM_ICE_TIME_REF_FREQ) {
+ 		dev_warn(ice_hw_to_dev(hw), "Invalid TIME_REF frequency %u\n",
+ 			 clk_freq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (clk_src >= NUM_ICE_CLK_SRC) {
+ 		dev_warn(ice_hw_to_dev(hw), "Invalid clock source %u\n",
+ 			 clk_src);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (clk_src == ICE_CLK_SRC_TCX0 &&
+ 	    clk_freq != ICE_TIME_REF_FREQ_25_000) {
+ 		dev_warn(ice_hw_to_dev(hw),
+ 			 "TCX0 only supports 25 MHz frequency\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD9, &dw9.val);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD24, &dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_cgu_reg_e822(hw, TSPLL_RO_BWM_LF, &bwm_lf.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Log the current clock configuration */
+ 	ice_debug(hw, ICE_DBG_PTP, "Current CGU configuration -- %s, clk_src %s, clk_freq %s, PLL %s\n",
+ 		  dw24.field.ts_pll_enable ? "enabled" : "disabled",
+ 		  ice_clk_src_str(dw24.field.time_ref_sel),
+ 		  ice_clk_freq_str(dw9.field.time_ref_freq_sel),
+ 		  bwm_lf.field.plllock_true_lock_cri ? "locked" : "unlocked");
+ 
+ 	/* Disable the PLL before changing the clock source or frequency */
+ 	if (dw24.field.ts_pll_enable) {
+ 		dw24.field.ts_pll_enable = 0;
+ 
+ 		err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	/* Set the frequency */
+ 	dw9.field.time_ref_freq_sel = clk_freq;
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD9, dw9.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the TS PLL feedback divisor */
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD19, &dw19.val);
+ 	if (err)
+ 		return err;
+ 
+ 	dw19.field.tspll_fbdiv_intgr = e822_cgu_params[clk_freq].feedback_div;
+ 	dw19.field.tspll_ndivratio = 1;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD19, dw19.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the TS PLL post divisor */
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD22, &dw22.val);
+ 	if (err)
+ 		return err;
+ 
+ 	dw22.field.time1588clk_div = e822_cgu_params[clk_freq].post_pll_div;
+ 	dw22.field.time1588clk_sel_div2 = 0;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD22, dw22.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the TS PLL pre divisor and clock source */
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD24, &dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	dw24.field.ref1588_ck_div = e822_cgu_params[clk_freq].refclk_pre_div;
+ 	dw24.field.tspll_fbdiv_frac = e822_cgu_params[clk_freq].frac_n_div;
+ 	dw24.field.time_ref_sel = clk_src;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Finally, enable the PLL */
+ 	dw24.field.ts_pll_enable = 1;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Wait to verify if the PLL locks */
+ 	usleep_range(1000, 5000);
+ 
+ 	err = ice_read_cgu_reg_e822(hw, TSPLL_RO_BWM_LF, &bwm_lf.val);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!bwm_lf.field.plllock_true_lock_cri) {
+ 		dev_warn(ice_hw_to_dev(hw), "CGU PLL failed to lock\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* Log the current clock configuration */
+ 	ice_debug(hw, ICE_DBG_PTP, "New CGU configuration -- %s, clk_src %s, clk_freq %s, PLL %s\n",
+ 		  dw24.field.ts_pll_enable ? "enabled" : "disabled",
+ 		  ice_clk_src_str(dw24.field.time_ref_sel),
+ 		  ice_clk_freq_str(dw9.field.time_ref_freq_sel),
+ 		  bwm_lf.field.plllock_true_lock_cri ? "locked" : "unlocked");
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_init_cgu_e822 - Initialize CGU with settings from firmware
+  * @hw: pointer to the HW structure
+  *
+  * Initialize the Clock Generation Unit of the E822 device.
+  */
+ static int ice_init_cgu_e822(struct ice_hw *hw)
+ {
+ 	struct ice_ts_func_info *ts_info = &hw->func_caps.ts_func_info;
+ 	union tspll_cntr_bist_settings cntr_bist;
+ 	int err;
+ 
+ 	err = ice_read_cgu_reg_e822(hw, TSPLL_CNTR_BIST_SETTINGS,
+ 				    &cntr_bist.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Disable sticky lock detection so lock err reported is accurate */
+ 	cntr_bist.field.i_plllock_sel_0 = 0;
+ 	cntr_bist.field.i_plllock_sel_1 = 0;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, TSPLL_CNTR_BIST_SETTINGS,
+ 				     cntr_bist.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the CGU PLL using the parameters from the function
+ 	 * capabilities.
+ 	 */
+ 	err = ice_cfg_cgu_pll_e822(hw, ts_info->time_ref,
+ 				   (enum ice_clk_src)ts_info->clk_src);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_set_vernier_wl - Set the window length for vernier calibration
+  * @hw: pointer to the HW struct
+  *
+  * Set the window length used for the vernier port calibration process.
+  */
+ static int ice_ptp_set_vernier_wl(struct ice_hw *hw)
+ {
+ 	u8 port;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		int err;
+ 
+ 		err = ice_write_phy_reg_e822(hw, port, P_REG_WL,
+ 					     PTP_VERNIER_WL);
+ 		if (err) {
+ 			ice_debug(hw, ICE_DBG_PTP, "Failed to set vernier window length for port %u, err %d\n",
+ 				  port, err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_init_phc_e822 - Perform E822 specific PHC initialization
+  * @hw: pointer to HW struct
+  *
+  * Perform PHC initialization steps specific to E822 devices.
+  */
+ static int ice_ptp_init_phc_e822(struct ice_hw *hw)
+ {
+ 	int err;
+ 	u32 regval;
+ 
+ 	/* Enable reading switch and PHY registers over the sideband queue */
+ #define PF_SB_REM_DEV_CTL_SWITCH_READ BIT(1)
+ #define PF_SB_REM_DEV_CTL_PHY0 BIT(2)
+ 	regval = rd32(hw, PF_SB_REM_DEV_CTL);
+ 	regval |= (PF_SB_REM_DEV_CTL_SWITCH_READ |
+ 		   PF_SB_REM_DEV_CTL_PHY0);
+ 	wr32(hw, PF_SB_REM_DEV_CTL, regval);
+ 
+ 	/* Initialize the Clock Generation Unit */
+ 	err = ice_init_cgu_e822(hw);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Set window length for all the ports */
+ 	return ice_ptp_set_vernier_wl(hw);
+ }
+ 
+ /**
+  * ice_ptp_prep_phy_time_e822 - Prepare PHY port with initial time
+  * @hw: pointer to the HW struct
+  * @time: Time to initialize the PHY port clocks to
+  *
+  * Program the PHY port registers with a new initial time value. The port
+  * clock will be initialized once the driver issues an INIT_TIME sync
+  * command. The time value is the upper 32 bits of the PHY timer, usually in
+  * units of nominal nanoseconds.
+  */
+ static int
+ ice_ptp_prep_phy_time_e822(struct ice_hw *hw, u32 time)
+ {
+ 	u64 phy_time;
+ 	u8 port;
+ 	int err;
+ 
+ 	/* The time represents the upper 32 bits of the PHY timer, so we need
+ 	 * to shift to account for this when programming.
+ 	 */
+ 	phy_time = (u64)time << 32;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		/* Tx case */
+ 		err = ice_write_64b_phy_reg_e822(hw, port,
+ 						 P_REG_TX_TIMER_INC_PRE_L,
+ 						 phy_time);
+ 		if (err)
+ 			goto exit_err;
+ 
+ 		/* Rx case */
+ 		err = ice_write_64b_phy_reg_e822(hw, port,
+ 						 P_REG_RX_TIMER_INC_PRE_L,
+ 						 phy_time);
+ 		if (err)
+ 			goto exit_err;
+ 	}
+ 
+ 	return 0;
+ 
+ exit_err:
+ 	ice_debug(hw, ICE_DBG_PTP, "Failed to write init time for port %u, err %d\n",
+ 		  port, err);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_prep_port_adj_e822 - Prepare a single port for time adjust
+  * @hw: pointer to HW struct
+  * @port: Port number to be programmed
+  * @time: time in cycles to adjust the port Tx and Rx clocks
+  *
+  * Program the port for an atomic adjustment by writing the Tx and Rx timer
+  * registers. The atomic adjustment won't be completed until the driver issues
+  * an ADJ_TIME command.
+  *
+  * Note that time is not in units of nanoseconds. It is in clock time
+  * including the lower sub-nanosecond portion of the port timer.
+  *
+  * Negative adjustments are supported using 2s complement arithmetic.
+  */
+ int
+ ice_ptp_prep_port_adj_e822(struct ice_hw *hw, u8 port, s64 time)
+ {
+ 	u32 l_time, u_time;
+ 	int err;
+ 
+ 	l_time = lower_32_bits(time);
+ 	u_time = upper_32_bits(time);
+ 
+ 	/* Tx case */
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_TIMER_INC_PRE_L,
+ 				     l_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_TIMER_INC_PRE_U,
+ 				     u_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	/* Rx case */
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_TIMER_INC_PRE_L,
+ 				     l_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_TIMER_INC_PRE_U,
+ 				     u_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	return 0;
+ 
+ exit_err:
+ 	ice_debug(hw, ICE_DBG_PTP, "Failed to write time adjust for port %u, err %d\n",
+ 		  port, err);
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_prep_phy_adj_e822 - Prep PHY ports for a time adjustment
+  * @hw: pointer to HW struct
+  * @adj: adjustment in nanoseconds
+  *
+  * Prepare the PHY ports for an atomic time adjustment by programming the PHY
+  * Tx and Rx port registers. The actual adjustment is completed by issuing an
+  * ADJ_TIME or ADJ_TIME_AT_TIME sync command.
+  */
+ static int
+ ice_ptp_prep_phy_adj_e822(struct ice_hw *hw, s32 adj)
+ {
+ 	s64 cycles;
+ 	u8 port;
+ 
+ 	/* The port clock supports adjustment of the sub-nanosecond portion of
+ 	 * the clock. We shift the provided adjustment in nanoseconds to
+ 	 * calculate the appropriate adjustment to program into the PHY ports.
+ 	 */
+ 	if (adj > 0)
+ 		cycles = (s64)adj << 32;
+ 	else
+ 		cycles = -(((s64)-adj) << 32);
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		int err;
+ 
+ 		err = ice_ptp_prep_port_adj_e822(hw, port, cycles);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_prep_phy_incval_e822 - Prepare PHY ports for time adjustment
+  * @hw: pointer to HW struct
+  * @incval: new increment value to prepare
+  *
+  * Prepare each of the PHY ports for a new increment value by programming the
+  * port's TIMETUS registers. The new increment value will be updated after
+  * issuing an INIT_INCVAL command.
+  */
+ static int
+ ice_ptp_prep_phy_incval_e822(struct ice_hw *hw, u64 incval)
+ {
+ 	int err;
+ 	u8 port;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		err = ice_write_40b_phy_reg_e822(hw, port, P_REG_TIMETUS_L,
+ 						 incval);
+ 		if (err)
+ 			goto exit_err;
+ 	}
+ 
+ 	return 0;
+ 
+ exit_err:
+ 	ice_debug(hw, ICE_DBG_PTP, "Failed to write incval for port %u, err %d\n",
+ 		  port, err);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_read_port_capture - Read a port's local time capture
+  * @hw: pointer to HW struct
+  * @port: Port number to read
+  * @tx_ts: on return, the Tx port time capture
+  * @rx_ts: on return, the Rx port time capture
+  *
+  * Read the port's Tx and Rx local time capture values.
+  *
+  * Note this has no equivalent for the E810 devices.
+  */
+ static int
+ ice_ptp_read_port_capture(struct ice_hw *hw, u8 port, u64 *tx_ts, u64 *rx_ts)
+ {
+ 	int err;
+ 
+ 	/* Tx case */
+ 	err = ice_read_64b_phy_reg_e822(hw, port, P_REG_TX_CAPTURE_L, tx_ts);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read REG_TX_CAPTURE, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "tx_init = 0x%016llx\n",
+ 		  (unsigned long long)*tx_ts);
+ 
+ 	/* Rx case */
+ 	err = ice_read_64b_phy_reg_e822(hw, port, P_REG_RX_CAPTURE_L, rx_ts);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read RX_CAPTURE, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "rx_init = 0x%016llx\n",
+ 		  (unsigned long long)*rx_ts);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_one_port_cmd - Prepare a single PHY port for a timer command
+  * @hw: pointer to HW struct
+  * @port: Port to which cmd has to be sent
+  * @cmd: Command to be sent to the port
+  *
+  * Prepare the requested port for an upcoming timer sync command.
+  *
+  * Note there is no equivalent of this operation on E810, as that device
+  * always handles all external PHYs internally.
+  */
+ static int
+ ice_ptp_one_port_cmd(struct ice_hw *hw, u8 port, enum ice_ptp_tmr_cmd cmd)
+ {
+ 	u32 cmd_val, val;
+ 	u8 tmr_idx;
+ 	int err;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 	cmd_val = tmr_idx << SEL_PHY_SRC;
+ 	switch (cmd) {
+ 	case INIT_TIME:
+ 		cmd_val |= PHY_CMD_INIT_TIME;
+ 		break;
+ 	case INIT_INCVAL:
+ 		cmd_val |= PHY_CMD_INIT_INCVAL;
+ 		break;
+ 	case ADJ_TIME:
+ 		cmd_val |= PHY_CMD_ADJ_TIME;
+ 		break;
+ 	case READ_TIME:
+ 		cmd_val |= PHY_CMD_READ_TIME;
+ 		break;
+ 	case ADJ_TIME_AT_TIME:
+ 		cmd_val |= PHY_CMD_ADJ_TIME_AT_TIME;
+ 		break;
+ 	}
+ 
+ 	/* Tx case */
+ 	/* Read, modify, write */
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_TX_TMR_CMD, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read TX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Modify necessary bits only and perform write */
+ 	val &= ~TS_CMD_MASK;
+ 	val |= cmd_val;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_TMR_CMD, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write back TX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Rx case */
+ 	/* Read, modify, write */
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_RX_TMR_CMD, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read RX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Modify necessary bits only and perform write */
+ 	val &= ~TS_CMD_MASK;
+ 	val |= cmd_val;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_TMR_CMD, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write back RX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_port_cmd_e822 - Prepare all ports for a timer command
+  * @hw: pointer to the HW struct
+  * @cmd: timer command to prepare
+  *
+  * Prepare all ports connected to this device for an upcoming timer sync
+  * command.
+  */
+ static int
+ ice_ptp_port_cmd_e822(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)
+ {
+ 	u8 port;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		int err;
+ 
+ 		err = ice_ptp_one_port_cmd(hw, port, cmd);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* E822 Vernier calibration functions
+  *
+  * The following functions are used as part of the vernier calibration of
+  * a port. This calibration increases the precision of the timestamps on the
+  * port.
+  */
+ 
+ /**
+  * ice_phy_get_speed_and_fec_e822 - Get link speed and FEC based on serdes mode
+  * @hw: pointer to HW struct
+  * @port: the port to read from
+  * @link_out: if non-NULL, holds link speed on success
+  * @fec_out: if non-NULL, holds FEC algorithm on success
+  *
+  * Read the serdes data for the PHY port and extract the link speed and FEC
+  * algorithm.
+  */
+ static int
+ ice_phy_get_speed_and_fec_e822(struct ice_hw *hw, u8 port,
+ 			       enum ice_ptp_link_spd *link_out,
+ 			       enum ice_ptp_fec_mode *fec_out)
+ {
+ 	enum ice_ptp_link_spd link;
+ 	enum ice_ptp_fec_mode fec;
+ 	u32 serdes;
+ 	int err;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_LINK_SPEED, &serdes);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read serdes info\n");
+ 		return err;
+ 	}
+ 
+ 	/* Determine the FEC algorithm */
+ 	fec = (enum ice_ptp_fec_mode)P_REG_LINK_SPEED_FEC_MODE(serdes);
+ 
+ 	serdes &= P_REG_LINK_SPEED_SERDES_M;
+ 
+ 	/* Determine the link speed */
+ 	if (fec == ICE_PTP_FEC_MODE_RS_FEC) {
+ 		switch (serdes) {
+ 		case ICE_PTP_SERDES_25G:
+ 			link = ICE_PTP_LNK_SPD_25G_RS;
+ 			break;
+ 		case ICE_PTP_SERDES_50G:
+ 			link = ICE_PTP_LNK_SPD_50G_RS;
+ 			break;
+ 		case ICE_PTP_SERDES_100G:
+ 			link = ICE_PTP_LNK_SPD_100G_RS;
+ 			break;
+ 		default:
+ 			return -EIO;
+ 		}
+ 	} else {
+ 		switch (serdes) {
+ 		case ICE_PTP_SERDES_1G:
+ 			link = ICE_PTP_LNK_SPD_1G;
+ 			break;
+ 		case ICE_PTP_SERDES_10G:
+ 			link = ICE_PTP_LNK_SPD_10G;
+ 			break;
+ 		case ICE_PTP_SERDES_25G:
+ 			link = ICE_PTP_LNK_SPD_25G;
+ 			break;
+ 		case ICE_PTP_SERDES_40G:
+ 			link = ICE_PTP_LNK_SPD_40G;
+ 			break;
+ 		case ICE_PTP_SERDES_50G:
+ 			link = ICE_PTP_LNK_SPD_50G;
+ 			break;
+ 		default:
+ 			return -EIO;
+ 		}
+ 	}
+ 
+ 	if (link_out)
+ 		*link_out = link;
+ 	if (fec_out)
+ 		*fec_out = fec;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_cfg_lane_e822 - Configure PHY quad for single/multi-lane timestamp
+  * @hw: pointer to HW struct
+  * @port: to configure the quad for
+  */
+ static void ice_phy_cfg_lane_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	int err;
+ 	u32 val;
+ 	u8 quad;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, NULL);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to get PHY link speed, err %d\n",
+ 			  err);
+ 		return;
+ 	}
+ 
+ 	quad = port / ICE_PORTS_PER_QUAD;
+ 
+ 	err = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read TX_MEM_GLB_CFG, err %d\n",
+ 			  err);
+ 		return;
+ 	}
+ 
+ 	if (link_spd >= ICE_PTP_LNK_SPD_40G)
+ 		val &= ~Q_REG_TX_MEM_GBL_CFG_LANE_TYPE_M;
+ 	else
+ 		val |= Q_REG_TX_MEM_GBL_CFG_LANE_TYPE_M;
+ 
+ 	err = ice_write_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write back TX_MEM_GBL_CFG, err %d\n",
+ 			  err);
+ 		return;
+ 	}
+ }
+ 
+ /**
+  * ice_phy_cfg_uix_e822 - Configure Serdes UI to TU conversion for E822
+  * @hw: pointer to the HW structure
+  * @port: the port to configure
+  *
+  * Program the conversion ration of Serdes clock "unit intervals" (UIs) to PHC
+  * hardware clock time units (TUs). That is, determine the number of TUs per
+  * serdes unit interval, and program the UIX registers with this conversion.
+  *
+  * This conversion is used as part of the calibration process when determining
+  * the additional error of a timestamp vs the real time of transmission or
+  * receipt of the packet.
+  *
+  * Hardware uses the number of TUs per 66 UIs, written to the UIX registers
+  * for the two main serdes clock rates, 10G/40G and 25G/100G serdes clocks.
+  *
+  * To calculate the conversion ratio, we use the following facts:
+  *
+  * a) the clock frequency in Hz (cycles per second)
+  * b) the number of TUs per cycle (the increment value of the clock)
+  * c) 1 second per 1 billion nanoseconds
+  * d) the duration of 66 UIs in nanoseconds
+  *
+  * Given these facts, we can use the following table to work out what ratios
+  * to multiply in order to get the number of TUs per 66 UIs:
+  *
+  * cycles |   1 second   | incval (TUs) | nanoseconds
+  * -------+--------------+--------------+-------------
+  * second | 1 billion ns |    cycle     |   66 UIs
+  *
+  * To perform the multiplication using integers without too much loss of
+  * precision, we can take use the following equation:
+  *
+  * (freq * incval * 6600 LINE_UI ) / ( 100 * 1 billion)
+  *
+  * We scale up to using 6600 UI instead of 66 in order to avoid fractional
+  * nanosecond UIs (66 UI at 10G/40G is 6.4 ns)
+  *
+  * The increment value has a maximum expected range of about 34 bits, while
+  * the frequency value is about 29 bits. Multiplying these values shouldn't
+  * overflow the 64 bits. However, we must then further multiply them again by
+  * the Serdes unit interval duration. To avoid overflow here, we split the
+  * overall divide by 1e11 into a divide by 256 (shift down by 8 bits) and
+  * a divide by 390,625,000. This does lose some precision, but avoids
+  * miscalculation due to arithmetic overflow.
+  */
+ static int ice_phy_cfg_uix_e822(struct ice_hw *hw, u8 port)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, uix;
+ 	int err;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second divided by 256 */
+ 	tu_per_sec = (cur_freq * clk_incval) >> 8;
+ 
+ #define LINE_UI_10G_40G 640 /* 6600 UIs is 640 nanoseconds at 10Gb/40Gb */
+ #define LINE_UI_25G_100G 256 /* 6600 UIs is 256 nanoseconds at 25Gb/100Gb */
+ 
+ 	/* Program the 10Gb/40Gb conversion ratio */
+ 	uix = div_u64(tu_per_sec * LINE_UI_10G_40G, 390625000);
+ 
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_UIX66_10G_40G_L,
+ 					 uix);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write UIX66_10G_40G, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Program the 25Gb/100Gb conversion ratio */
+ 	uix = div_u64(tu_per_sec * LINE_UI_25G_100G, 390625000);
+ 
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_UIX66_25G_100G_L,
+ 					 uix);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write UIX66_25G_100G, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_cfg_parpcs_e822 - Configure TUs per PAR/PCS clock cycle
+  * @hw: pointer to the HW struct
+  * @port: port to configure
+  *
+  * Configure the number of TUs for the PAR and PCS clocks used as part of the
+  * timestamp calibration process. This depends on the link speed, as the PHY
+  * uses different markers depending on the speed.
+  *
+  * 1Gb/10Gb/25Gb:
+  * - Tx/Rx PAR/PCS markers
+  *
+  * 25Gb RS:
+  * - Tx/Rx Reed Solomon gearbox PAR/PCS markers
+  *
+  * 40Gb/50Gb:
+  * - Tx/Rx PAR/PCS markers
+  * - Rx Deskew PAR/PCS markers
+  *
+  * 50G RS and 100GB RS:
+  * - Tx/Rx Reed Solomon gearbox PAR/PCS markers
+  * - Rx Deskew PAR/PCS markers
+  * - Tx PAR/PCS markers
+  *
+  * To calculate the conversion, we use the PHC clock frequency (cycles per
+  * second), the increment value (TUs per cycle), and the related PHY clock
+  * frequency to calculate the TUs per unit of the PHY link clock. The
+  * following table shows how the units convert:
+  *
+  * cycles |  TUs  | second
+  * -------+-------+--------
+  * second | cycle | cycles
+  *
+  * For each conversion register, look up the appropriate frequency from the
+  * e822 PAR/PCS table and calculate the TUs per unit of that clock. Program
+  * this to the appropriate register, preparing hardware to perform timestamp
+  * calibration to calculate the total Tx or Rx offset to adjust the timestamp
+  * in order to calibrate for the internal PHY delays.
+  *
+  * Note that the increment value ranges up to ~34 bits, and the clock
+  * frequency is ~29 bits, so multiplying them together should fit within the
+  * 64 bit arithmetic.
+  */
+ static int ice_phy_cfg_parpcs_e822(struct ice_hw *hw, u8 port)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, phy_tus;
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per cycle of the PHC clock */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* For each PHY conversion register, look up the appropriate link
+ 	 * speed frequency and determine the TUs per that clock's cycle time.
+ 	 * Split this into a high and low value and then program the
+ 	 * appropriate register. If that link speed does not use the
+ 	 * associated register, write zeros to clear it instead.
+ 	 */
+ 
+ 	/* P_REG_PAR_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_par_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_par_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PAR_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_PAR_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_par_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_par_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PAR_RX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_PCS_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_pcs_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_pcs_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PCS_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_PCS_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_pcs_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_pcs_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PCS_RX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PAR_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_desk_rsgb_par)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_desk_rsgb_par);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PAR_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PAR_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_desk_rsgb_par)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_desk_rsgb_par);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PAR_RX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PCS_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_desk_rsgb_pcs)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_desk_rsgb_pcs);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PCS_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PCS_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_desk_rsgb_pcs)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_desk_rsgb_pcs);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	return ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PCS_RX_TUS_L,
+ 					  phy_tus);
+ }
+ 
+ /**
+  * ice_calc_fixed_tx_offset_e822 - Calculated Fixed Tx offset for a port
+  * @hw: pointer to the HW struct
+  * @link_spd: the Link speed to calculate for
+  *
+  * Calculate the fixed offset due to known static latency data.
+  */
+ static u64
+ ice_calc_fixed_tx_offset_e822(struct ice_hw *hw, enum ice_ptp_link_spd link_spd)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, fixed_offset;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* Calculate number of TUs to add for the fixed Tx latency. Since the
+ 	 * latency measurement is in 1/100th of a nanosecond, we need to
+ 	 * multiply by tu_per_sec and then divide by 1e11. This calculation
+ 	 * overflows 64 bit integer arithmetic, so break it up into two
+ 	 * divisions by 1e4 first then by 1e7.
+ 	 */
+ 	fixed_offset = div_u64(tu_per_sec, 10000);
+ 	fixed_offset *= e822_vernier[link_spd].tx_fixed_delay;
+ 	fixed_offset = div_u64(fixed_offset, 10000000);
+ 
+ 	return fixed_offset;
+ }
+ 
+ /**
+  * ice_phy_cfg_fixed_tx_offset_e822 - Configure Tx offset for bypass mode
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * Calculate and program the fixed Tx offset, and indicate that the offset is
+  * ready. This can be used when operating in bypass mode.
+  */
+ static int
+ ice_phy_cfg_fixed_tx_offset_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	u64 total_offset;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset = ice_calc_fixed_tx_offset_e822(hw, link_spd);
+ 
+ 	/* Program the fixed Tx offset into the P_REG_TOTAL_TX_OFFSET_L
+ 	 * register, then indicate that the Tx offset is ready. After this,
+ 	 * timestamps will be enabled.
+ 	 *
+ 	 * Note that this skips including the more precise offsets generated
+ 	 * by the Vernier calibration.
+ 	 */
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_TX_OFFSET_L,
+ 					 total_offset);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_calc_fixed_rx_offset_e822 - Calculated the fixed Rx offset for a port
+  * @hw: pointer to HW struct
+  * @link_spd: The Link speed to calculate for
+  *
+  * Determine the fixed Rx latency for a given link speed.
+  */
+ static u64
+ ice_calc_fixed_rx_offset_e822(struct ice_hw *hw, enum ice_ptp_link_spd link_spd)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, fixed_offset;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* Calculate number of TUs to add for the fixed Rx latency. Since the
+ 	 * latency measurement is in 1/100th of a nanosecond, we need to
+ 	 * multiply by tu_per_sec and then divide by 1e11. This calculation
+ 	 * overflows 64 bit integer arithmetic, so break it up into two
+ 	 * divisions by 1e4 first then by 1e7.
+ 	 */
+ 	fixed_offset = div_u64(tu_per_sec, 10000);
+ 	fixed_offset *= e822_vernier[link_spd].rx_fixed_delay;
+ 	fixed_offset = div_u64(fixed_offset, 10000000);
+ 
+ 	return fixed_offset;
+ }
+ 
+ /**
+  * ice_phy_cfg_fixed_rx_offset_e822 - Configure fixed Rx offset for bypass mode
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * Calculate and program the fixed Rx offset, and indicate that the offset is
+  * ready. This can be used when operating in bypass mode.
+  */
+ static int
+ ice_phy_cfg_fixed_rx_offset_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	u64 total_offset;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset = ice_calc_fixed_rx_offset_e822(hw, link_spd);
+ 
+ 	/* Program the fixed Rx offset into the P_REG_TOTAL_RX_OFFSET_L
+ 	 * register, then indicate that the Rx offset is ready. After this,
+ 	 * timestamps will be enabled.
+ 	 *
+ 	 * Note that this skips including the more precise offsets generated
+ 	 * by Vernier calibration.
+ 	 */
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_RX_OFFSET_L,
+ 					 total_offset);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_phy_and_phc_time_e822 - Simultaneously capture PHC and PHY time
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to read
+  * @phy_time: on return, the 64bit PHY timer value
+  * @phc_time: on return, the lower 64bits of PHC time
+  *
+  * Issue a READ_TIME timer command to simultaneously capture the PHY and PHC
+  * timer values.
+  */
+ static int
+ ice_read_phy_and_phc_time_e822(struct ice_hw *hw, u8 port, u64 *phy_time,
+ 			       u64 *phc_time)
+ {
+ 	u64 tx_time, rx_time;
+ 	u32 zo, lo;
+ 	u8 tmr_idx;
+ 	int err;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 
+ 	/* Prepare the PHC timer for a READ_TIME capture command */
+ 	ice_ptp_src_cmd(hw, READ_TIME);
+ 
+ 	/* Prepare the PHY timer for a READ_TIME capture command */
+ 	err = ice_ptp_one_port_cmd(hw, port, READ_TIME);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Issue the sync to start the READ_TIME capture */
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	/* Read the captured PHC time from the shadow time registers */
+ 	zo = rd32(hw, GLTSYN_SHTIME_0(tmr_idx));
+ 	lo = rd32(hw, GLTSYN_SHTIME_L(tmr_idx));
+ 	*phc_time = (u64)lo << 32 | zo;
+ 
+ 	/* Read the captured PHY time from the PHY shadow registers */
+ 	err = ice_ptp_read_port_capture(hw, port, &tx_time, &rx_time);
+ 	if (err)
+ 		return err;
+ 
+ 	/* If the PHY Tx and Rx timers don't match, log a warning message.
+ 	 * Note that this should not happen in normal circumstances since the
+ 	 * driver always programs them together.
+ 	 */
+ 	if (tx_time != rx_time)
+ 		dev_warn(ice_hw_to_dev(hw),
+ 			 "PHY port %u Tx and Rx timers do not match, tx_time 0x%016llX, rx_time 0x%016llX\n",
+ 			 port, (unsigned long long)tx_time,
+ 			 (unsigned long long)rx_time);
+ 
+ 	*phy_time = tx_time;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_sync_phy_timer_e822 - Synchronize the PHY timer with PHC timer
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to synchronize
+  *
+  * Perform an adjustment to ensure that the PHY and PHC timers are in sync.
+  * This is done by issuing a READ_TIME command which triggers a simultaneous
+  * read of the PHY timer and PHC timer. Then we use the difference to
+  * calculate an appropriate 2s complement addition to add to the PHY timer in
+  * order to ensure it reads the same value as the primary PHC timer.
+  */
+ static int ice_sync_phy_timer_e822(struct ice_hw *hw, u8 port)
+ {
+ 	u64 phc_time, phy_time, difference;
+ 	int err;
+ 
+ 	if (!ice_ptp_lock(hw)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to acquire PTP semaphore\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = ice_read_phy_and_phc_time_e822(hw, port, &phy_time, &phc_time);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	/* Calculate the amount required to add to the port time in order for
+ 	 * it to match the PHC time.
+ 	 *
+ 	 * Note that the port adjustment is done using 2s complement
+ 	 * arithmetic. This is convenient since it means that we can simply
+ 	 * calculate the difference between the PHC time and the port time,
+ 	 * and it will be interpreted correctly.
+ 	 */
+ 	difference = phc_time - phy_time;
+ 
+ 	err = ice_ptp_prep_port_adj_e822(hw, port, (s64)difference);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	err = ice_ptp_one_port_cmd(hw, port, ADJ_TIME);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	/* Issue the sync to activate the time adjustment */
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	/* Re-capture the timer values to flush the command registers and
+ 	 * verify that the time was properly adjusted.
+ 	 */
+ 	err = ice_read_phy_and_phc_time_e822(hw, port, &phy_time, &phc_time);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	dev_info(ice_hw_to_dev(hw),
+ 		 "Port %u PHY time synced to PHC: 0x%016llX, 0x%016llX\n",
+ 		 port, (unsigned long long)phy_time,
+ 		 (unsigned long long)phc_time);
+ 
+ 	ice_ptp_unlock(hw);
+ 
+ 	return 0;
+ 
+ err_unlock:
+ 	ice_ptp_unlock(hw);
+ 	return err;
+ }
+ 
+ /**
+  * ice_stop_phy_timer_e822 - Stop the PHY clock timer
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to stop
+  * @soft_reset: if true, hold the SOFT_RESET bit of P_REG_PS
+  *
+  * Stop the clock of a PHY port. This must be done as part of the flow to
+  * re-calibrate Tx and Rx timestamping offsets whenever the clock time is
+  * initialized or when link speed changes.
+  */
+ int
+ ice_stop_phy_timer_e822(struct ice_hw *hw, u8 port, bool soft_reset)
+ {
+ 	int err;
+ 	u32 val;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	val &= ~P_REG_PS_START_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val &= ~P_REG_PS_ENA_CLK_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	if (soft_reset) {
+ 		val |= P_REG_PS_SFT_RESET_M;
+ 		err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "Disabled clock on PHY port %u\n", port);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_start_phy_timer_e822 - Start the PHY clock timer
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to start
+  * @bypass: if true, start the PHY in bypass mode
+  *
+  * Start the clock of a PHY port. This must be done as part of the flow to
+  * re-calibrate Tx and Rx timestamping offsets whenever the clock time is
+  * initialized or when link speed changes.
+  *
+  * Bypass mode enables timestamps immediately without waiting for Vernier
+  * calibration to complete. Hardware will still continue taking Vernier
+  * measurements on Tx or Rx of packets, but they will not be applied to
+  * timestamps. Use ice_phy_exit_bypass_e822 to exit bypass mode once hardware
+  * has completed offset calculation.
+  */
+ int
+ ice_start_phy_timer_e822(struct ice_hw *hw, u8 port, bool bypass)
+ {
+ 	u32 lo, hi, val;
+ 	u64 incval;
+ 	u8 tmr_idx;
+ 	int err;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 
+ 	err = ice_stop_phy_timer_e822(hw, port, false);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_phy_cfg_lane_e822(hw, port);
+ 
+ 	err = ice_phy_cfg_uix_e822(hw, port);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_phy_cfg_parpcs_e822(hw, port);
+ 	if (err)
+ 		return err;
+ 
+ 	lo = rd32(hw, GLTSYN_INCVAL_L(tmr_idx));
+ 	hi = rd32(hw, GLTSYN_INCVAL_H(tmr_idx));
+ 	incval = (u64)hi << 32 | lo;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_TIMETUS_L, incval);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_ptp_one_port_cmd(hw, port, INIT_INCVAL);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	val |= P_REG_PS_SFT_RESET_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val |= P_REG_PS_START_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val &= ~P_REG_PS_SFT_RESET_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_ptp_one_port_cmd(hw, port, INIT_INCVAL);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	val |= P_REG_PS_ENA_CLK_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val |= P_REG_PS_LOAD_OFFSET_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	err = ice_sync_phy_timer_e822(hw, port);
+ 	if (err)
+ 		return err;
+ 
+ 	if (bypass) {
+ 		val |= P_REG_PS_BYPASS_MODE_M;
+ 		/* Enter BYPASS mode, enabling timestamps immediately. */
+ 		err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 		if (err)
+ 			return err;
+ 
+ 		/* Program the fixed Tx offset */
+ 		err = ice_phy_cfg_fixed_tx_offset_e822(hw, port);
+ 		if (err)
+ 			return err;
+ 
+ 		/* Program the fixed Rx offset */
+ 		err = ice_phy_cfg_fixed_rx_offset_e822(hw, port);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "Enabled clock on PHY port %u\n", port);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> b111ab5a11eb (ice: ensure the hardware Clock Generation Unit is configured)
  /* E810 functions
   *
   * The following functions operate on the E810 series devices which use
diff --cc drivers/net/ethernet/intel/ice/ice_ptp_hw.h
index 55a414e87018,70b1aff14225..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp_hw.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp_hw.h
@@@ -12,6 -12,112 +12,115 @@@ enum ice_ptp_tmr_cmd 
  	READ_TIME
  };
  
++<<<<<<< HEAD
++=======
+ enum ice_ptp_serdes {
+ 	ICE_PTP_SERDES_1G,
+ 	ICE_PTP_SERDES_10G,
+ 	ICE_PTP_SERDES_25G,
+ 	ICE_PTP_SERDES_40G,
+ 	ICE_PTP_SERDES_50G,
+ 	ICE_PTP_SERDES_100G
+ };
+ 
+ enum ice_ptp_link_spd {
+ 	ICE_PTP_LNK_SPD_1G,
+ 	ICE_PTP_LNK_SPD_10G,
+ 	ICE_PTP_LNK_SPD_25G,
+ 	ICE_PTP_LNK_SPD_25G_RS,
+ 	ICE_PTP_LNK_SPD_40G,
+ 	ICE_PTP_LNK_SPD_50G,
+ 	ICE_PTP_LNK_SPD_50G_RS,
+ 	ICE_PTP_LNK_SPD_100G_RS,
+ 	NUM_ICE_PTP_LNK_SPD /* Must be last */
+ };
+ 
+ enum ice_ptp_fec_mode {
+ 	ICE_PTP_FEC_MODE_NONE,
+ 	ICE_PTP_FEC_MODE_CLAUSE74,
+ 	ICE_PTP_FEC_MODE_RS_FEC
+ };
+ 
+ /**
+  * struct ice_time_ref_info_e822
+  * @pll_freq: Frequency of PLL that drives timer ticks in Hz
+  * @nominal_incval: increment to generate nanoseconds in GLTSYN_TIME_L
+  * @pps_delay: propagation delay of the PPS output signal
+  *
+  * Characteristic information for the various TIME_REF sources possible in the
+  * E822 devices
+  */
+ struct ice_time_ref_info_e822 {
+ 	u64 pll_freq;
+ 	u64 nominal_incval;
+ 	u8 pps_delay;
+ };
+ 
+ /**
+  * struct ice_vernier_info_e822
+  * @tx_par_clk: Frequency used to calculate P_REG_PAR_TX_TUS
+  * @rx_par_clk: Frequency used to calculate P_REG_PAR_RX_TUS
+  * @tx_pcs_clk: Frequency used to calculate P_REG_PCS_TX_TUS
+  * @rx_pcs_clk: Frequency used to calculate P_REG_PCS_RX_TUS
+  * @tx_desk_rsgb_par: Frequency used to calculate P_REG_DESK_PAR_TX_TUS
+  * @rx_desk_rsgb_par: Frequency used to calculate P_REG_DESK_PAR_RX_TUS
+  * @tx_desk_rsgb_pcs: Frequency used to calculate P_REG_DESK_PCS_TX_TUS
+  * @rx_desk_rsgb_pcs: Frequency used to calculate P_REG_DESK_PCS_RX_TUS
+  * @tx_fixed_delay: Fixed Tx latency measured in 1/100th nanoseconds
+  * @pmd_adj_divisor: Divisor used to calculate PDM alignment adjustment
+  * @rx_fixed_delay: Fixed Rx latency measured in 1/100th nanoseconds
+  *
+  * Table of constants used during as part of the Vernier calibration of the Tx
+  * and Rx timestamps. This includes frequency values used to compute TUs per
+  * PAR/PCS clock cycle, and static delay values measured during hardware
+  * design.
+  *
+  * Note that some values are not used for all link speeds, and the
+  * P_REG_DESK_PAR* registers may represent different clock markers at
+  * different link speeds, either the deskew marker for multi-lane link speeds
+  * or the Reed Solomon gearbox marker for RS-FEC.
+  */
+ struct ice_vernier_info_e822 {
+ 	u32 tx_par_clk;
+ 	u32 rx_par_clk;
+ 	u32 tx_pcs_clk;
+ 	u32 rx_pcs_clk;
+ 	u32 tx_desk_rsgb_par;
+ 	u32 rx_desk_rsgb_par;
+ 	u32 tx_desk_rsgb_pcs;
+ 	u32 rx_desk_rsgb_pcs;
+ 	u32 tx_fixed_delay;
+ 	u32 pmd_adj_divisor;
+ 	u32 rx_fixed_delay;
+ };
+ 
+ /**
+  * struct ice_cgu_pll_params_e822
+  * @refclk_pre_div: Reference clock pre-divisor
+  * @feedback_div: Feedback divisor
+  * @frac_n_div: Fractional divisor
+  * @post_pll_div: Post PLL divisor
+  *
+  * Clock Generation Unit parameters used to program the PLL based on the
+  * selected TIME_REF frequency.
+  */
+ struct ice_cgu_pll_params_e822 {
+ 	u32 refclk_pre_div;
+ 	u32 feedback_div;
+ 	u32 frac_n_div;
+ 	u32 post_pll_div;
+ };
+ 
+ extern const struct
+ ice_cgu_pll_params_e822 e822_cgu_params[NUM_ICE_TIME_REF_FREQ];
+ 
+ /* Table of constants related to possible TIME_REF sources */
+ extern const struct ice_time_ref_info_e822 e822_time_ref[NUM_ICE_TIME_REF_FREQ];
+ 
+ /* Table of constants for Vernier calibration on E822 */
+ extern const struct ice_vernier_info_e822 e822_vernier[NUM_ICE_PTP_LNK_SPD];
+ 
++>>>>>>> b111ab5a11eb (ice: ensure the hardware Clock Generation Unit is configured)
  /* Increment value to generate nanoseconds in the GLTSYN_TIME_L register for
   * the E810 devices. Based off of a PLL with an 812.5 MHz frequency.
   */
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_consts.h
diff --git a/drivers/net/ethernet/intel/ice/ice_cgu_regs.h b/drivers/net/ethernet/intel/ice/ice_cgu_regs.h
new file mode 100644
index 000000000000..57abd52386d0
--- /dev/null
+++ b/drivers/net/ethernet/intel/ice/ice_cgu_regs.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018-2021, Intel Corporation. */
+
+#ifndef _ICE_CGU_REGS_H_
+#define _ICE_CGU_REGS_H_
+
+#define NAC_CGU_DWORD9 0x24
+union nac_cgu_dword9 {
+	struct {
+		u32 time_ref_freq_sel : 3;
+		u32 clk_eref1_en : 1;
+		u32 clk_eref0_en : 1;
+		u32 time_ref_en : 1;
+		u32 time_sync_en : 1;
+		u32 one_pps_out_en : 1;
+		u32 clk_ref_synce_en : 1;
+		u32 clk_synce1_en : 1;
+		u32 clk_synce0_en : 1;
+		u32 net_clk_ref1_en : 1;
+		u32 net_clk_ref0_en : 1;
+		u32 clk_synce1_amp : 2;
+		u32 misc6 : 1;
+		u32 clk_synce0_amp : 2;
+		u32 one_pps_out_amp : 2;
+		u32 misc24 : 12;
+	} field;
+	u32 val;
+};
+
+#define NAC_CGU_DWORD19 0x4c
+union nac_cgu_dword19 {
+	struct {
+		u32 tspll_fbdiv_intgr : 8;
+		u32 fdpll_ulck_thr : 5;
+		u32 misc15 : 3;
+		u32 tspll_ndivratio : 4;
+		u32 tspll_iref_ndivratio : 3;
+		u32 misc19 : 1;
+		u32 japll_ndivratio : 4;
+		u32 japll_iref_ndivratio : 3;
+		u32 misc27 : 1;
+	} field;
+	u32 val;
+};
+
+#define NAC_CGU_DWORD22 0x58
+union nac_cgu_dword22 {
+	struct {
+		u32 fdpll_frac_div_out_nc : 2;
+		u32 fdpll_lock_int_for : 1;
+		u32 synce_hdov_int_for : 1;
+		u32 synce_lock_int_for : 1;
+		u32 fdpll_phlead_slip_nc : 1;
+		u32 fdpll_acc1_ovfl_nc : 1;
+		u32 fdpll_acc2_ovfl_nc : 1;
+		u32 synce_status_nc : 6;
+		u32 fdpll_acc1f_ovfl : 1;
+		u32 misc18 : 1;
+		u32 fdpllclk_div : 4;
+		u32 time1588clk_div : 4;
+		u32 synceclk_div : 4;
+		u32 synceclk_sel_div2 : 1;
+		u32 fdpllclk_sel_div2 : 1;
+		u32 time1588clk_sel_div2 : 1;
+		u32 misc3 : 1;
+	} field;
+	u32 val;
+};
+
+#define NAC_CGU_DWORD24 0x60
+union nac_cgu_dword24 {
+	struct {
+		u32 tspll_fbdiv_frac : 22;
+		u32 misc20 : 2;
+		u32 ts_pll_enable : 1;
+		u32 time_sync_tspll_align_sel : 1;
+		u32 ext_synce_sel : 1;
+		u32 ref1588_ck_div : 4;
+		u32 time_ref_sel : 1;
+	} field;
+	u32 val;
+};
+
+#define TSPLL_CNTR_BIST_SETTINGS 0x344
+union tspll_cntr_bist_settings {
+	struct {
+		u32 i_irefgen_settling_time_cntr_7_0 : 8;
+		u32 i_irefgen_settling_time_ro_standby_1_0 : 2;
+		u32 reserved195 : 5;
+		u32 i_plllock_sel_0 : 1;
+		u32 i_plllock_sel_1 : 1;
+		u32 i_plllock_cnt_6_0 : 7;
+		u32 i_plllock_cnt_10_7 : 4;
+		u32 reserved200 : 4;
+	} field;
+	u32 val;
+};
+
+#define TSPLL_RO_BWM_LF 0x370
+union tspll_ro_bwm_lf {
+	struct {
+		u32 bw_freqov_high_cri_7_0 : 8;
+		u32 bw_freqov_high_cri_9_8 : 2;
+		u32 biascaldone_cri : 1;
+		u32 plllock_gain_tran_cri : 1;
+		u32 plllock_true_lock_cri : 1;
+		u32 pllunlock_flag_cri : 1;
+		u32 afcerr_cri : 1;
+		u32 afcdone_cri : 1;
+		u32 feedfwrdgain_cal_cri_7_0 : 8;
+		u32 m2fbdivmod_cri_7_0 : 8;
+	} field;
+	u32 val;
+};
+
+#endif /* _ICE_CGU_REGS_H_ */
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_consts.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_hw.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_hw.h
