ALSA: sc6000: Assign vport directly on card's private_data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 9b7843d1e125dca0d6ed0af9e8dd709d41eb25ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/9b7843d1.failed

sc6000 driver tries to allocate an extra pointer for keeping the vport
address and point it over card->private_data.  But, this indirect
access is utterly superfluous, and we can keep the vport address
directly in card->private_data instead.  This will simply the code and
avoid confusion.

Link: https://lore.kernel.org/r/20210720162837.6026-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 9b7843d1e125dca0d6ed0af9e8dd709d41eb25ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/isa/sc6000.c
diff --cc sound/isa/sc6000.c
index 3d0bea44f454,d92e56cb0490..000000000000
--- a/sound/isa/sc6000.c
+++ b/sound/isa/sc6000.c
@@@ -532,6 -529,14 +532,17 @@@ static int snd_sc6000_match(struct devi
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ static void snd_sc6000_free(struct snd_card *card)
+ {
+ 	char __iomem *vport = card->private_data;
+ 
+ 	if (vport)
+ 		sc6000_setup_board(vport, 0);
+ }
+ 
++>>>>>>> 9b7843d1e125 (ALSA: sc6000: Assign vport directly on card's private_data)
  static int snd_sc6000_probe(struct device *devptr, unsigned int dev)
  {
  	static const int possible_irqs[] = { 5, 7, 9, 10, 11, -1 };
@@@ -542,12 -547,11 +553,17 @@@
  	struct snd_card *card;
  	struct snd_wss *chip;
  	struct snd_opl3 *opl3;
- 	char __iomem **vport;
+ 	char __iomem *vport;
  	char __iomem *vmss_port;
  
++<<<<<<< HEAD
 +
 +	err = snd_card_new(devptr, index[dev], id[dev], THIS_MODULE,
 +			   sizeof(vport), &card);
++=======
+ 	err = snd_devm_card_new(devptr, index[dev], id[dev], THIS_MODULE,
+ 				0, &card);
++>>>>>>> 9b7843d1e125 (ALSA: sc6000: Assign vport directly on card's private_data)
  	if (err < 0)
  		return err;
  
@@@ -570,26 -571,24 +585,27 @@@
  		}
  	}
  
 -	if (!devm_request_region(devptr, port[dev], 0x10, DRV_NAME)) {
 +	if (!request_region(port[dev], 0x10, DRV_NAME)) {
  		snd_printk(KERN_ERR PFX
  			   "I/O port region is already in use.\n");
 -		return -EBUSY;
 +		err = -EBUSY;
 +		goto err_exit;
  	}
- 	*vport = devm_ioport_map(devptr, port[dev], 0x10);
- 	if (*vport == NULL) {
+ 	vport = devm_ioport_map(devptr, port[dev], 0x10);
+ 	if (!vport) {
  		snd_printk(KERN_ERR PFX
  			   "I/O port cannot be iomapped.\n");
 -		return -EBUSY;
 +		err = -EBUSY;
 +		goto err_unmap1;
  	}
+ 	card->private_data = vport;
  
  	/* to make it marked as used */
 -	if (!devm_request_region(devptr, mss_port[dev], 4, DRV_NAME)) {
 +	if (!request_region(mss_port[dev], 4, DRV_NAME)) {
  		snd_printk(KERN_ERR PFX
  			   "SC-6000 port I/O port region is already in use.\n");
 -		return -EBUSY;
 +		err = -EBUSY;
 +		goto err_unmap1;
  	}
  	vmss_port = devm_ioport_map(devptr, mss_port[dev], 4);
  	if (!vmss_port) {
@@@ -603,9 -601,10 +619,9 @@@
  		   port[dev], xirq, xdma,
  		   mpu_irq[dev] == SNDRV_AUTO_IRQ ? 0 : mpu_irq[dev]);
  
- 	err = sc6000_init_board(*vport, vmss_port, dev);
+ 	err = sc6000_init_board(vport, vmss_port, dev);
  	if (err < 0)
 -		return err;
 -	card->private_free = snd_sc6000_free;
 +		goto err_unmap2;
  
  	err = snd_wss_create(card, mss_port[dev] + 4,  -1, xirq, xdma, -1,
  			     WSS_HW_DETECT, 0, &chip);
* Unmerged path sound/isa/sc6000.c
