EDAC/i10nm: Retrieve and print retry_rd_err_log registers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Youquan Song <youquan.song@intel.com>
commit cf4e6d52f58399c777276172ec250502e19d5e63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/cf4e6d52.failed

Retrieve and print retry_rd_err_log registers like the earlier change:
commit e80634a75aba ("EDAC, skx: Retrieve and print retry_rd_err_log registers")

This is a little trickier than on Skylake because of potential
interference with BIOS use of the same registers. The default
behavior is to ignore these registers.

A module parameter retry_rd_err_log(default=0) controls the mode of operation:
- 0=off  : Default.
- 1=bios : Linux doesn't reset any control bits, but just reports values.
           This is "no harm" mode, but it may miss reporting some data.
- 2=linux: Linux tries to take control and resets mode bits,
           clears valid/UC bits after reading. This should be
           more reliable (especially if BIOS interference is reduced
           by disabling eMCA reporting mode in BIOS setup).

Co-developed-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
	Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
	Signed-off-by: Youquan Song <youquan.song@intel.com>
	Signed-off-by: Tony Luck <tony.luck@intel.com>
Link: https://lore.kernel.org/r/20210818175701.1611513-3-tony.luck@intel.com
(cherry picked from commit cf4e6d52f58399c777276172ec250502e19d5e63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/i10nm_base.c
diff --cc drivers/edac/i10nm_base.c
index aeae7d0a73c2,83345bfac246..000000000000
--- a/drivers/edac/i10nm_base.c
+++ b/drivers/edac/i10nm_base.c
@@@ -26,14 -26,28 +26,25 @@@
  	pci_read_config_dword((d)->uracu, 0xd8 + (i) * 4, &(reg))
  #define I10NM_GET_SAD(d, offset, i, reg)\
  	pci_read_config_dword((d)->sad_all, (offset) + (i) * 8, &(reg))
 -#define I10NM_GET_HBM_IMC_BAR(d, reg)	\
 -	pci_read_config_dword((d)->uracu, 0xd4, &(reg))
 -#define I10NM_GET_CAPID3_CFG(d, reg)	\
 -	pci_read_config_dword((d)->pcu_cr3, 0x90, &(reg))
  #define I10NM_GET_DIMMMTR(m, i, j)	\
 -	readl((m)->mbase + ((m)->hbm_mc ? 0x80c : 0x2080c) + \
 -	(i) * (m)->chan_mmio_sz + (j) * 4)
 -#define I10NM_GET_MCDDRTCFG(m, i)	\
 -	readl((m)->mbase + ((m)->hbm_mc ? 0x970 : 0x20970) + \
 -	(i) * (m)->chan_mmio_sz)
 +	readl((m)->mbase + 0x2080c + (i) * (m)->chan_mmio_sz + (j) * 4)
 +#define I10NM_GET_MCDDRTCFG(m, i, j)	\
 +	readl((m)->mbase + 0x20970 + (i) * (m)->chan_mmio_sz + (j) * 4)
  #define I10NM_GET_MCMTR(m, i)		\
 -	readl((m)->mbase + ((m)->hbm_mc ? 0xef8 : 0x20ef8) + \
 -	(i) * (m)->chan_mmio_sz)
 +	readl((m)->mbase + 0x20ef8 + (i) * (m)->chan_mmio_sz)
  #define I10NM_GET_AMAP(m, i)		\
++<<<<<<< HEAD
 +	readl((m)->mbase + 0x20814 + (i) * (m)->chan_mmio_sz)
++=======
+ 	readl((m)->mbase + ((m)->hbm_mc ? 0x814 : 0x20814) + \
+ 	(i) * (m)->chan_mmio_sz)
+ #define I10NM_GET_REG32(m, i, offset)	\
+ 	readl((m)->mbase + (i) * (m)->chan_mmio_sz + (offset))
+ #define I10NM_GET_REG64(m, i, offset)	\
+ 	readq((m)->mbase + (i) * (m)->chan_mmio_sz + (offset))
+ #define I10NM_SET_REG32(m, i, offset, v)	\
+ 	writel(v, (m)->mbase + (i) * (m)->chan_mmio_sz + (offset))
++>>>>>>> cf4e6d52f583 (EDAC/i10nm: Retrieve and print retry_rd_err_log registers)
  
  #define I10NM_GET_SCK_MMIO_BASE(reg)	(GET_BITFIELD(reg, 0, 28) << 23)
  #define I10NM_GET_IMC_MMIO_OFFSET(reg)	(GET_BITFIELD(reg, 0, 10) << 12)
@@@ -184,18 -409,12 +316,20 @@@ static struct res_config spr_cfg = 
  	.support_ddr5		= true,
  	.sad_all_devfn		= PCI_DEVFN(10, 0),
  	.sad_all_offset		= 0x300,
+ 	.offsets_scrub		= offsets_scrub_spr,
+ 	.offsets_demand		= offsets_demand_spr,
  };
  
 +/* RHEL only: because of 38eb638a57a88d, we need to keep both structs */
  static const struct x86_cpu_id i10nm_cpuids[] = {
 +	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_D,	&i10nm_cfg0),
 +	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,		&i10nm_cfg0),
 +	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,		&i10nm_cfg1),
 +	X86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X,	&spr_cfg),
 +	{}
 +};
 +
 +static const struct x86_cpu_id_v2 i10nm_cpuids_v2[] = {
  	X86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ATOM_TREMONT_D,	X86_STEPPINGS(0x0, 0x3), &i10nm_cfg0),
  	X86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ATOM_TREMONT_D,	X86_STEPPINGS(0x4, 0xf), &i10nm_cfg1),
  	X86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ICELAKE_X,		X86_STEPPINGS(0x0, 0x3), &i10nm_cfg0),
* Unmerged path drivers/edac/i10nm_base.c
diff --git a/drivers/edac/skx_base.c b/drivers/edac/skx_base.c
index 069a42d8401f..297960eb21e3 100644
--- a/drivers/edac/skx_base.c
+++ b/drivers/edac/skx_base.c
@@ -237,7 +237,8 @@ static int skx_get_dimm_config(struct mem_ctl_info *mci, struct res_config *cfg)
 #define SKX_ILV_TARGET(tgt)	((tgt) & 7)
 
 static void skx_show_retry_rd_err_log(struct decoded_addr *res,
-				      char *msg, int len)
+				      char *msg, int len,
+				      bool scrub_err)
 {
 	u32 log0, log1, log2, log3, log4;
 	u32 corr0, corr1, corr2, corr3;
diff --git a/drivers/edac/skx_common.c b/drivers/edac/skx_common.c
index 7817265cdc58..189ff8a3cf4b 100644
--- a/drivers/edac/skx_common.c
+++ b/drivers/edac/skx_common.c
@@ -524,6 +524,7 @@ static void skx_mce_output_error(struct mem_ctl_info *mci,
 	bool ripv = GET_BITFIELD(m->mcgstatus, 0, 0);
 	bool overflow = GET_BITFIELD(m->status, 62, 62);
 	bool uncorrected_error = GET_BITFIELD(m->status, 61, 61);
+	bool scrub_err = false;
 	bool recoverable;
 	int len;
 	u32 core_err_cnt = GET_BITFIELD(m->status, 38, 52);
@@ -578,6 +579,7 @@ static void skx_mce_output_error(struct mem_ctl_info *mci,
 			break;
 		case 4:
 			optype = "memory scrubbing error";
+			scrub_err = true;
 			break;
 		default:
 			optype = "reserved";
@@ -600,7 +602,7 @@ static void skx_mce_output_error(struct mem_ctl_info *mci,
 	}
 
 	if (skx_show_retry_rd_err_log)
-		skx_show_retry_rd_err_log(res, skx_msg + len, MSG_SIZE - len);
+		skx_show_retry_rd_err_log(res, skx_msg + len, MSG_SIZE - len, scrub_err);
 
 	edac_dbg(0, "%s\n", skx_msg);
 
diff --git a/drivers/edac/skx_common.h b/drivers/edac/skx_common.h
index 34e89f7ddf93..1fb7540a7092 100644
--- a/drivers/edac/skx_common.h
+++ b/drivers/edac/skx_common.h
@@ -68,6 +68,8 @@ struct skx_dev {
 		struct skx_channel {
 			struct pci_dev	*cdev;
 			struct pci_dev	*edev;
+			u32 retry_rd_err_log_s;
+			u32 retry_rd_err_log_d;
 			struct skx_dimm {
 				u8 close_pg;
 				u8 bank_xor_enable;
@@ -136,12 +138,15 @@ struct res_config {
 	/* SAD device number and function number */
 	unsigned int sad_all_devfn;
 	int sad_all_offset;
+	/* Offsets of retry_rd_err_log registers */
+	u32 *offsets_scrub;
+	u32 *offsets_demand;
 };
 
 typedef int (*get_dimm_config_f)(struct mem_ctl_info *mci,
 				 struct res_config *cfg);
 typedef bool (*skx_decode_f)(struct decoded_addr *res);
-typedef void (*skx_show_retry_log_f)(struct decoded_addr *res, char *msg, int len);
+typedef void (*skx_show_retry_log_f)(struct decoded_addr *res, char *msg, int len, bool scrub_err);
 
 int __init skx_adxl_get(void);
 void __exit skx_adxl_put(void);
