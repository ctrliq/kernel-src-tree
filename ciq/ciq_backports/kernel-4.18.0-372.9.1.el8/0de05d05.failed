x86/speculation: Warn about eIBRS + LFENCE + Unprivileged eBPF + SMT

jira LE-1907
cve CVE-2021-26401
cve CVE-2022-0002
cve CVE-2022-0001
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 0de05d056afdb00eca8c7bbb0c79a3438daf700c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/0de05d05.failed

The commit

   44a3918c8245 ("x86/speculation: Include unprivileged eBPF status in Spectre v2 mitigation reporting")

added a warning for the "eIBRS + unprivileged eBPF" combination, which
has been shown to be vulnerable against Spectre v2 BHB-based attacks.

However, there's no warning about the "eIBRS + LFENCE retpoline +
unprivileged eBPF" combo. The LFENCE adds more protection by shortening
the speculation window after a mispredicted branch. That makes an attack
significantly more difficult, even with unprivileged eBPF. So at least
for now the logic doesn't warn about that combination.

But if you then add SMT into the mix, the SMT attack angle weakens the
effectiveness of the LFENCE considerably.

So extend the "eIBRS + unprivileged eBPF" warning to also include the
"eIBRS + LFENCE + unprivileged eBPF + SMT" case.

  [ bp: Massage commit message. ]

	Suggested-by: Alyssa Milburn <alyssa.milburn@linux.intel.com>
	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 0de05d056afdb00eca8c7bbb0c79a3438daf700c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 7357f251348a,6296e1ebed1d..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -618,6 -651,32 +618,35 @@@ static inline const char *spectre_v2_mo
  static inline const char *spectre_v2_module_string(void) { return ""; }
  #endif
  
++<<<<<<< HEAD
++=======
+ #define SPECTRE_V2_LFENCE_MSG "WARNING: LFENCE mitigation is not recommended for this CPU, data leaks possible!\n"
+ #define SPECTRE_V2_EIBRS_EBPF_MSG "WARNING: Unprivileged eBPF is enabled with eIBRS on, data leaks possible via Spectre v2 BHB attacks!\n"
+ #define SPECTRE_V2_EIBRS_LFENCE_EBPF_SMT_MSG "WARNING: Unprivileged eBPF is enabled with eIBRS+LFENCE mitigation and SMT, data leaks possible via Spectre v2 BHB attacks!\n"
+ 
+ #ifdef CONFIG_BPF_SYSCALL
+ void unpriv_ebpf_notify(int new_state)
+ {
+ 	if (new_state)
+ 		return;
+ 
+ 	/* Unprivileged eBPF is enabled */
+ 
+ 	switch (spectre_v2_enabled) {
+ 	case SPECTRE_V2_EIBRS:
+ 		pr_err(SPECTRE_V2_EIBRS_EBPF_MSG);
+ 		break;
+ 	case SPECTRE_V2_EIBRS_LFENCE:
+ 		if (sched_smt_active())
+ 			pr_err(SPECTRE_V2_EIBRS_LFENCE_EBPF_SMT_MSG);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ #endif
+ 
++>>>>>>> 0de05d056afd (x86/speculation: Warn about eIBRS + LFENCE + Unprivileged eBPF + SMT)
  static inline bool match_option(const char *arg, int arglen, const char *opt)
  {
  	int len = strlen(opt);
@@@ -1704,6 -1806,27 +1737,30 @@@ static char *ibpb_state(void
  	return "";
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t spectre_v2_show_state(char *buf)
+ {
+ 	if (spectre_v2_enabled == SPECTRE_V2_LFENCE)
+ 		return sprintf(buf, "Vulnerable: LFENCE\n");
+ 
+ 	if (spectre_v2_enabled == SPECTRE_V2_EIBRS && unprivileged_ebpf_enabled())
+ 		return sprintf(buf, "Vulnerable: eIBRS with unprivileged eBPF\n");
+ 
+ 	if (sched_smt_active() && unprivileged_ebpf_enabled() &&
+ 	    spectre_v2_enabled == SPECTRE_V2_EIBRS_LFENCE)
+ 		return sprintf(buf, "Vulnerable: eIBRS+LFENCE with unprivileged eBPF and SMT\n");
+ 
+ 	return sprintf(buf, "%s%s%s%s%s%s\n",
+ 		       spectre_v2_strings[spectre_v2_enabled],
+ 		       ibpb_state(),
+ 		       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? ", IBRS_FW" : "",
+ 		       stibp_state(),
+ 		       boot_cpu_has(X86_FEATURE_RSB_CTXSW) ? ", RSB filling" : "",
+ 		       spectre_v2_module_string());
+ }
+ 
++>>>>>>> 0de05d056afd (x86/speculation: Warn about eIBRS + LFENCE + Unprivileged eBPF + SMT)
  static ssize_t srbds_show_state(char *buf)
  {
  	return sprintf(buf, "%s\n", srbds_strings[srbds_mitigation]);
* Unmerged path arch/x86/kernel/cpu/bugs.c
