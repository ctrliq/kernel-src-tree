net/mlx5e: Mutually exclude setting of TX-port-TS and MQPRIO in channel mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Aya Levin <ayal@nvidia.com>
commit 3bf1742f3c69501dec300b55917b9352428cb4dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/3bf1742f.failed

TX-port-TS hijacks the PTP traffic to a specific HW TX-queue. This
conflicts with MQPRIO in channel mode, which specifies explicitly which
TC accepts the packet. This patch mutually excludes the above
configuration.

Fixes: ec60c4581bd9 ("net/mlx5e: Support MQPRIO channel mode")
	Signed-off-by: Aya Levin <ayal@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 3bf1742f3c69501dec300b55917b9352428cb4dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,9d451b8ee467..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -2066,8 -2035,19 +2066,24 @@@ static int set_pflag_tx_port_ts(struct 
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	new_channels.params = priv->channels.params;
 +	MLX5E_SET_PFLAG(&new_channels.params, MLX5E_PFLAG_TX_PORT_TS, enable);
++=======
+ 	new_params = priv->channels.params;
+ 	/* Don't allow enabling TX-port-TS if MQPRIO mode channel  offload is
+ 	 * active, since it defines explicitly which TC accepts the packet.
+ 	 * This conflicts with TX-port-TS hijacking the PTP traffic to a specific
+ 	 * HW TX-queue.
+ 	 */
+ 	if (enable && new_params.mqprio.mode == TC_MQPRIO_MODE_CHANNEL) {
+ 		netdev_err(priv->netdev,
+ 			   "%s: MQPRIO mode channel offload is active, cannot set the TX-port-TS\n",
+ 			   __func__);
+ 		return -EINVAL;
+ 	}
+ 	MLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_TX_PORT_TS, enable);
++>>>>>>> 3bf1742f3c69 (net/mlx5e: Mutually exclude setting of TX-port-TS and MQPRIO in channel mode)
  	/* No need to verify SQ stop room as
  	 * ptpsq.txqsq.stop_room <= generic_sq->stop_room, and both
  	 * has the same log_sq_size.
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index c234e374c4b8,0c5197f9cea3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3385,8 -2930,90 +3385,92 @@@ static int mlx5e_setup_tc_mqprio(struc
  	if (tc && tc != MLX5E_MAX_NUM_TC)
  		return -EINVAL;
  
 -	new_params = priv->channels.params;
 -	mlx5e_params_mqprio_dcb_set(&new_params, tc ? tc : 1);
 +	mutex_lock(&priv->state_lock);
  
++<<<<<<< HEAD
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_num_channels_changed_ctx, NULL, true);
+ 
+ 	priv->max_opened_tc = max_t(u8, priv->max_opened_tc,
+ 				    mlx5e_get_dcb_num_tc(&priv->channels.params));
+ 	return err;
+ }
+ 
+ static int mlx5e_mqprio_channel_validate(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5e_ptp *ptp_channel;
+ 	int agg_count = 0;
+ 	int i;
+ 
+ 	ptp_channel = priv->channels.ptp;
+ 	if (ptp_channel && test_bit(MLX5E_PTP_STATE_TX, ptp_channel->state)) {
+ 		netdev_err(netdev,
+ 			   "Cannot activate MQPRIO mode channel since it conflicts with TX port TS\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mqprio->qopt.offset[0] != 0 || mqprio->qopt.num_tc < 1 ||
+ 	    mqprio->qopt.num_tc > MLX5E_MAX_NUM_MQPRIO_CH_TC)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < mqprio->qopt.num_tc; i++) {
+ 		if (!mqprio->qopt.count[i]) {
+ 			netdev_err(netdev, "Zero size for queue-group (%d) is not supported\n", i);
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->min_rate[i]) {
+ 			netdev_err(netdev, "Min tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->max_rate[i]) {
+ 			netdev_err(netdev, "Max tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (mqprio->qopt.offset[i] != agg_count) {
+ 			netdev_err(netdev, "Discontinuous queues config is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		agg_count += mqprio->qopt.count[i];
+ 	}
+ 
+ 	if (priv->channels.params.num_channels < agg_count) {
+ 		netdev_err(netdev, "Num of queues (%d) exceeds available (%d)\n",
+ 			   agg_count, priv->channels.params.num_channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_setup_tc_mqprio_channel(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	mlx5e_fp_preactivate preactivate;
+ 	struct mlx5e_params new_params;
+ 	bool nch_changed;
+ 	int err;
+ 
+ 	err = mlx5e_mqprio_channel_validate(priv, mqprio);
+ 	if (err)
+ 		return err;
+ 
+ 	new_params = priv->channels.params;
+ 	mlx5e_params_mqprio_channel_set(&new_params, &mqprio->qopt);
+ 
+ 	nch_changed = mlx5e_get_dcb_num_tc(&priv->channels.params) > 1;
+ 	preactivate = nch_changed ? mlx5e_num_channels_changed_ctx :
+ 		mlx5e_update_netdev_queues_ctx;
+ 	return mlx5e_safe_switch_params(priv, &new_params, preactivate, NULL, true);
+ }
+ 
+ static int mlx5e_setup_tc_mqprio(struct mlx5e_priv *priv,
+ 				 struct tc_mqprio_qopt_offload *mqprio)
+ {
++>>>>>>> 3bf1742f3c69 (net/mlx5e: Mutually exclude setting of TX-port-TS and MQPRIO in channel mode)
  	/* MQPRIO is another toplevel qdisc that can't be attached
  	 * simultaneously with the offloaded HTB.
  	 */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
