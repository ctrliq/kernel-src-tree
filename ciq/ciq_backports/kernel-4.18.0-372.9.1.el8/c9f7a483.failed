ice: move ice_devlink_flash_update and merge with ice_flash_pldm_image

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit c9f7a483e47004e94fcb9187dda10fb2406e983d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/c9f7a483.failed

The ice_devlink_flash_update function performs a few upfront checks and
then calls ice_flash_pldm_image.

Most if these checks make more sense in the context of code within
ice_flash_pldm_image. Merge ice_devlink_flash_update and
ice_flash_pldm_image into one function, placing it in ice_fw_update.c

Since this is still the entry point for devlink, call the function
ice_devlink_flash_update instead of ice_flash_pldm_image. This leaves a
single function which handles the devlink parameters and then initiates
a PLDM update.

With this change, the ice_devlink_flash_update function in
ice_fw_update.c becomes the main entry point for flash update. It
elimintes some unnecessary boiler plate code between the two previous
functions. The ultimate motivation for this is that it eases supporting
a dry run with the PLDM library in a future change.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit c9f7a483e47004e94fcb9187dda10fb2406e983d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_devlink.c
#	drivers/net/ethernet/intel/ice/ice_fw_update.c
#	drivers/net/ethernet/intel/ice/ice_fw_update.h
diff --cc drivers/net/ethernet/intel/ice/ice_devlink.c
index 021c315fa8d4,7e463b53ea98..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_devlink.c
+++ b/drivers/net/ethernet/intel/ice/ice_devlink.c
@@@ -372,56 -370,6 +372,59 @@@ out_free_ctx
  	return err;
  }
  
++<<<<<<< HEAD
 +/**
 + * ice_devlink_flash_update - Update firmware stored in flash on the device
 + * @devlink: pointer to devlink associated with device to update
 + * @params: flash update parameters
 + * @extack: netlink extended ACK structure
 + *
 + * Perform a device flash update. The bulk of the update logic is contained
 + * within the ice_flash_pldm_image function.
 + *
 + * Returns: zero on success, or an error code on failure.
 + */
 +static int
 +ice_devlink_flash_update(struct devlink *devlink,
 +			 struct devlink_flash_update_params *params,
 +			 struct netlink_ext_ack *extack)
 +{
 +	struct ice_pf *pf = devlink_priv(devlink);
 +	struct ice_hw *hw = &pf->hw;
 +	u8 preservation;
 +	int err;
 +
 +	if (!params->overwrite_mask) {
 +		/* preserve all settings and identifiers */
 +		preservation = ICE_AQC_NVM_PRESERVE_ALL;
 +	} else if (params->overwrite_mask == DEVLINK_FLASH_OVERWRITE_SETTINGS) {
 +		/* overwrite settings, but preserve the vital device identifiers */
 +		preservation = ICE_AQC_NVM_PRESERVE_SELECTED;
 +	} else if (params->overwrite_mask == (DEVLINK_FLASH_OVERWRITE_SETTINGS |
 +					      DEVLINK_FLASH_OVERWRITE_IDENTIFIERS)) {
 +		/* overwrite both settings and identifiers, preserve nothing */
 +		preservation = ICE_AQC_NVM_NO_PRESERVATION;
 +	} else {
 +		NL_SET_ERR_MSG_MOD(extack, "Requested overwrite mask is not supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (!hw->dev_caps.common_cap.nvm_unified_update) {
 +		NL_SET_ERR_MSG_MOD(extack, "Current firmware does not support unified update");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	err = ice_check_for_pending_update(pf, NULL, extack);
 +	if (err)
 +		return err;
 +
 +	devlink_flash_update_status_notify(devlink, "Preparing to flash", NULL, 0, 0);
 +
 +	return ice_flash_pldm_image(pf, params->fw, preservation, extack);
 +}
 +
++=======
++>>>>>>> c9f7a483e470 (ice: move ice_devlink_flash_update and merge with ice_flash_pldm_image)
  static const struct devlink_ops ice_devlink_ops = {
  	.supported_flash_update_params = DEVLINK_SUPPORT_FLASH_UPDATE_OVERWRITE_MASK,
  	.eswitch_mode_get = ice_eswitch_mode_get,
diff --cc drivers/net/ethernet/intel/ice/ice_fw_update.c
index ff801f4064a0,1f8e0e5d5660..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fw_update.c
+++ b/drivers/net/ethernet/intel/ice/ice_fw_update.c
@@@ -729,8 -652,9 +729,14 @@@ int ice_flash_pldm_image(struct ice_pf 
   *
   * Returns: zero on success, or a negative error code on failure.
   */
++<<<<<<< HEAD
 +int ice_check_for_pending_update(struct ice_pf *pf, const char *component,
 +				 struct netlink_ext_ack *extack)
++=======
+ static int
+ ice_cancel_pending_update(struct ice_pf *pf, const char *component,
+ 			  struct netlink_ext_ack *extack)
++>>>>>>> c9f7a483e470 (ice: move ice_devlink_flash_update and merge with ice_flash_pldm_image)
  {
  	struct devlink *devlink = priv_to_devlink(pf);
  	struct device *dev = ice_pf_to_dev(pf);
@@@ -814,3 -736,89 +820,92 @@@
  
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * ice_devlink_flash_update - Write a firmware image to the device
+  * @devlink: pointer to devlink associated with the device to update
+  * @params: devlink flash update parameters
+  * @extack: netlink extended ACK structure
+  *
+  * Parse the data for a given firmware file, verifying that it is a valid PLDM
+  * formatted image that matches this device.
+  *
+  * Extract the device record Package Data and Component Tables and send them
+  * to the firmware. Extract and write the flash data for each of the three
+  * main flash components, "fw.mgmt", "fw.undi", and "fw.netlist". Notify
+  * firmware once the data is written to the inactive banks.
+  *
+  * Returns: zero on success or a negative error code on failure.
+  */
+ int ice_devlink_flash_update(struct devlink *devlink,
+ 			     struct devlink_flash_update_params *params,
+ 			     struct netlink_ext_ack *extack)
+ {
+ 	struct ice_pf *pf = devlink_priv(devlink);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_fwu_priv priv;
+ 	u8 preservation;
+ 	int err;
+ 
+ 	if (!params->overwrite_mask) {
+ 		/* preserve all settings and identifiers */
+ 		preservation = ICE_AQC_NVM_PRESERVE_ALL;
+ 	} else if (params->overwrite_mask == DEVLINK_FLASH_OVERWRITE_SETTINGS) {
+ 		/* overwrite settings, but preserve the vital device identifiers */
+ 		preservation = ICE_AQC_NVM_PRESERVE_SELECTED;
+ 	} else if (params->overwrite_mask == (DEVLINK_FLASH_OVERWRITE_SETTINGS |
+ 					      DEVLINK_FLASH_OVERWRITE_IDENTIFIERS)) {
+ 		/* overwrite both settings and identifiers, preserve nothing */
+ 		preservation = ICE_AQC_NVM_NO_PRESERVATION;
+ 	} else {
+ 		NL_SET_ERR_MSG_MOD(extack, "Requested overwrite mask is not supported");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!hw->dev_caps.common_cap.nvm_unified_update) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Current firmware does not support unified update");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	memset(&priv, 0, sizeof(priv));
+ 
+ 	priv.context.ops = &ice_fwu_ops;
+ 	priv.context.dev = dev;
+ 	priv.extack = extack;
+ 	priv.pf = pf;
+ 	priv.activate_flags = preservation;
+ 
+ 	devlink_flash_update_status_notify(devlink, "Preparing to flash", NULL, 0, 0);
+ 
+ 	err = ice_cancel_pending_update(pf, NULL, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_acquire_nvm(hw, ICE_RES_WRITE);
+ 	if (err) {
+ 		dev_err(dev, "Failed to acquire device flash lock, err %d aq_err %s\n",
+ 			err, ice_aq_str(hw->adminq.sq_last_status));
+ 		NL_SET_ERR_MSG_MOD(extack, "Failed to acquire device flash lock");
+ 		return err;
+ 	}
+ 
+ 	err = pldmfw_flash_image(&priv.context, params->fw);
+ 	if (err == -ENOENT) {
+ 		dev_err(dev, "Firmware image has no record matching this device\n");
+ 		NL_SET_ERR_MSG_MOD(extack, "Firmware image has no record matching this device");
+ 	} else if (err) {
+ 		/* Do not set a generic extended ACK message here. A more
+ 		 * specific message may already have been set by one of our
+ 		 * ops.
+ 		 */
+ 		dev_err(dev, "Failed to flash PLDM image, err %d", err);
+ 	}
+ 
+ 	ice_release_nvm(hw);
+ 
+ 	return err;
+ }
++>>>>>>> c9f7a483e470 (ice: move ice_devlink_flash_update and merge with ice_flash_pldm_image)
diff --cc drivers/net/ethernet/intel/ice/ice_fw_update.h
index c6390f6851ff,be6d222124f2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fw_update.h
+++ b/drivers/net/ethernet/intel/ice/ice_fw_update.h
@@@ -4,9 -4,8 +4,15 @@@
  #ifndef _ICE_FW_UPDATE_H_
  #define _ICE_FW_UPDATE_H_
  
++<<<<<<< HEAD
 +int ice_flash_pldm_image(struct ice_pf *pf, const struct firmware *fw,
 +			 u8 preservation, struct netlink_ext_ack *extack);
 +int ice_check_for_pending_update(struct ice_pf *pf, const char *component,
 +				 struct netlink_ext_ack *extack);
++=======
+ int ice_devlink_flash_update(struct devlink *devlink,
+ 			     struct devlink_flash_update_params *params,
+ 			     struct netlink_ext_ack *extack);
++>>>>>>> c9f7a483e470 (ice: move ice_devlink_flash_update and merge with ice_flash_pldm_image)
  
  #endif
* Unmerged path drivers/net/ethernet/intel/ice/ice_devlink.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fw_update.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fw_update.h
