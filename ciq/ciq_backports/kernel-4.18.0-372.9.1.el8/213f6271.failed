iomap: add a IOMAP_DIO_OVERWRITE_ONLY flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 213f627104daf8589aad8ee73fcaeb603ab0af15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/213f6271.failed

Add a flag to signal that only pure overwrites are allowed.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 213f627104daf8589aad8ee73fcaeb603ab0af15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/iomap.h
diff --cc include/linux/iomap.h
index 93c9172844a5,1a86f520de56..000000000000
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@@ -259,14 -253,29 +260,30 @@@ int iomap_writepages(struct address_spa
  struct iomap_dio_ops {
  	int (*end_io)(struct kiocb *iocb, ssize_t size, int error,
  		      unsigned flags);
 -	blk_qc_t (*submit_io)(struct inode *inode, struct iomap *iomap,
 -			struct bio *bio, loff_t file_offset);
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * Wait for the I/O to complete in iomap_dio_rw even if the kiocb is not
+  * synchronous.
+  */
+ #define IOMAP_DIO_FORCE_WAIT	(1 << 0)
+ 
+ /*
+  * Do not allocate blocks or zero partial blocks, but instead fall back to
+  * the caller by returning -EAGAIN.  Used to optimize direct I/O writes that
+  * are not aligned to the file system block size.
+   */
+ #define IOMAP_DIO_OVERWRITE_ONLY	(1 << 1)
+ 
++>>>>>>> 213f627104da (iomap: add a IOMAP_DIO_OVERWRITE_ONLY flag)
  ssize_t iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
  		const struct iomap_ops *ops, const struct iomap_dio_ops *dops,
 -		unsigned int dio_flags);
 +		bool wait_for_completion);
  struct iomap_dio *__iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
  		const struct iomap_ops *ops, const struct iomap_dio_ops *dops,
 -		unsigned int dio_flags);
 +		bool wait_for_completion);
  ssize_t iomap_dio_complete(struct iomap_dio *dio);
  int iomap_dio_iopoll(struct kiocb *kiocb, bool spin);
  
diff --git a/fs/iomap/direct-io.c b/fs/iomap/direct-io.c
index 01b8b1de0719..996835bb8c9f 100644
--- a/fs/iomap/direct-io.c
+++ b/fs/iomap/direct-io.c
@@ -487,6 +487,13 @@ __iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
 		iomap_flags |= IOMAP_NOWAIT;
 	}
 
+	if (dio_flags & IOMAP_DIO_OVERWRITE_ONLY) {
+		ret = -EAGAIN;
+		if (pos >= dio->i_size || pos + count > dio->i_size)
+			goto out_free_dio;
+		iomap_flags |= IOMAP_OVERWRITE_ONLY;
+	}
+
 	ret = filemap_write_and_wait_range(mapping, pos, end);
 	if (ret)
 		goto out_free_dio;
* Unmerged path include/linux/iomap.h
