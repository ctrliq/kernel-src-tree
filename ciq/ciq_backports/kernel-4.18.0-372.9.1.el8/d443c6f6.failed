net/mlx5e: Rename traffic type enums

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Maor Gottlieb <maorg@nvidia.com>
commit d443c6f684d35d88d5be05c7c8d6ecd379fb3e0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/d443c6f6.failed

Rename traffic type enums as part of the preparation for moving
the traffic type logic to a separate file.

	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit d443c6f684d35d88d5be05c7c8d6ecd379fb3e0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 6d1dade3f38c,77fe98c42ec4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -75,27 -67,22 +75,30 @@@ struct mlx5e_l2_table 
  	bool                       promisc_enabled;
  };
  
- enum mlx5e_traffic_types {
- 	MLX5E_TT_IPV4_TCP,
- 	MLX5E_TT_IPV6_TCP,
- 	MLX5E_TT_IPV4_UDP,
- 	MLX5E_TT_IPV6_UDP,
- 	MLX5E_TT_IPV4_IPSEC_AH,
- 	MLX5E_TT_IPV6_IPSEC_AH,
- 	MLX5E_TT_IPV4_IPSEC_ESP,
- 	MLX5E_TT_IPV6_IPSEC_ESP,
- 	MLX5E_TT_IPV4,
- 	MLX5E_TT_IPV6,
- 	MLX5E_TT_ANY,
- 	MLX5E_NUM_TT,
- 	MLX5E_NUM_INDIR_TIRS = MLX5E_TT_ANY,
+ enum mlx5_traffic_types {
+ 	MLX5_TT_IPV4_TCP,
+ 	MLX5_TT_IPV6_TCP,
+ 	MLX5_TT_IPV4_UDP,
+ 	MLX5_TT_IPV6_UDP,
+ 	MLX5_TT_IPV4_IPSEC_AH,
+ 	MLX5_TT_IPV6_IPSEC_AH,
+ 	MLX5_TT_IPV4_IPSEC_ESP,
+ 	MLX5_TT_IPV6_IPSEC_ESP,
+ 	MLX5_TT_IPV4,
+ 	MLX5_TT_IPV6,
+ 	MLX5_TT_ANY,
+ 	MLX5_NUM_TT,
  };
  
++<<<<<<< HEAD
 +struct mlx5e_tirc_config {
 +	u8 l3_prot_type;
 +	u8 l4_prot_type;
 +	u32 rx_hash_fields;
 +};
++=======
+ #define MLX5E_NUM_INDIR_TIRS (MLX5_NUM_TT - 1)
++>>>>>>> d443c6f684d3 (net/mlx5e: Rename traffic type enums)
  
  #define MLX5_HASH_IP		(MLX5_HASH_FIELD_SEL_SRC_IP   |\
  				 MLX5_HASH_FIELD_SEL_DST_IP)
@@@ -152,22 -139,24 +155,22 @@@ enum 
  #endif
  };
  
- #define MLX5E_TTC_NUM_GROUPS	3
- #define MLX5E_TTC_GROUP1_SIZE	(BIT(3) + MLX5E_NUM_TUNNEL_TT)
- #define MLX5E_TTC_GROUP2_SIZE	 BIT(1)
- #define MLX5E_TTC_GROUP3_SIZE	 BIT(0)
- #define MLX5E_TTC_TABLE_SIZE	(MLX5E_TTC_GROUP1_SIZE +\
- 				 MLX5E_TTC_GROUP2_SIZE +\
- 				 MLX5E_TTC_GROUP3_SIZE)
- 
- #define MLX5E_INNER_TTC_NUM_GROUPS	3
- #define MLX5E_INNER_TTC_GROUP1_SIZE	BIT(3)
- #define MLX5E_INNER_TTC_GROUP2_SIZE	BIT(1)
- #define MLX5E_INNER_TTC_GROUP3_SIZE	BIT(0)
- #define MLX5E_INNER_TTC_TABLE_SIZE	(MLX5E_INNER_TTC_GROUP1_SIZE +\
- 					 MLX5E_INNER_TTC_GROUP2_SIZE +\
- 					 MLX5E_INNER_TTC_GROUP3_SIZE)
+ #define MLX5_TTC_NUM_GROUPS	3
+ #define MLX5_TTC_GROUP1_SIZE	(BIT(3) + MLX5_NUM_TUNNEL_TT)
+ #define MLX5_TTC_GROUP2_SIZE	 BIT(1)
+ #define MLX5_TTC_GROUP3_SIZE	 BIT(0)
+ #define MLX5_TTC_TABLE_SIZE	(MLX5_TTC_GROUP1_SIZE +\
+ 				 MLX5_TTC_GROUP2_SIZE +\
+ 				 MLX5_TTC_GROUP3_SIZE)
+ 
+ #define MLX5_INNER_TTC_NUM_GROUPS	3
+ #define MLX5_INNER_TTC_GROUP1_SIZE	BIT(3)
+ #define MLX5_INNER_TTC_GROUP2_SIZE	BIT(1)
+ #define MLX5_INNER_TTC_GROUP3_SIZE	BIT(0)
+ #define MLX5_INNER_TTC_TABLE_SIZE	(MLX5_INNER_TTC_GROUP1_SIZE +\
+ 					 MLX5_INNER_TTC_GROUP2_SIZE +\
+ 					 MLX5_INNER_TTC_GROUP3_SIZE)
  
 -struct mlx5e_priv;
 -
  #ifdef CONFIG_MLX5_EN_RXNFC
  
  struct mlx5e_ethtool_table {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
index f9afbdefded5,f479ef31ca40..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
@@@ -441,14 -564,103 +441,102 @@@ close_cqs
  	return err;
  }
  
 -static void mlx5e_ptp_close_queues(struct mlx5e_ptp *c)
 +static void mlx5e_ptp_close_queues(struct mlx5e_port_ptp *c)
  {
 -	if (test_bit(MLX5E_PTP_STATE_RX, c->state)) {
 -		mlx5e_close_rq(&c->rq);
 -		mlx5e_close_cq(&c->rq.cq);
 -	}
 -	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
 -		mlx5e_ptp_close_txqsqs(c);
 -		mlx5e_ptp_close_tx_cqs(c);
 -	}
 +	mlx5e_ptp_close_txqsqs(c);
 +	mlx5e_ptp_close_cqs(c);
  }
  
++<<<<<<< HEAD
 +int mlx5e_port_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
 +			u8 lag_port, struct mlx5e_port_ptp **cp)
++=======
+ static int mlx5e_ptp_set_state(struct mlx5e_ptp *c, struct mlx5e_params *params)
+ {
+ 	if (MLX5E_GET_PFLAG(params, MLX5E_PFLAG_TX_PORT_TS))
+ 		__set_bit(MLX5E_PTP_STATE_TX, c->state);
+ 
+ 	if (params->ptp_rx)
+ 		__set_bit(MLX5E_PTP_STATE_RX, c->state);
+ 
+ 	return bitmap_empty(c->state, MLX5E_PTP_STATE_NUM_STATES) ? -EINVAL : 0;
+ }
+ 
+ static void mlx5e_ptp_rx_unset_fs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_ptp_fs *ptp_fs = priv->fs.ptp_fs;
+ 
+ 	if (!ptp_fs->valid)
+ 		return;
+ 
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->l2_rule);
+ 	mlx5e_fs_tt_redirect_any_destroy(priv);
+ 
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v6_rule);
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v4_rule);
+ 	mlx5e_fs_tt_redirect_udp_destroy(priv);
+ 	ptp_fs->valid = false;
+ }
+ 
+ static int mlx5e_ptp_rx_set_fs(struct mlx5e_priv *priv)
+ {
+ 	u32 tirn = mlx5e_rx_res_get_tirn_ptp(priv->rx_res);
+ 	struct mlx5e_ptp_fs *ptp_fs = priv->fs.ptp_fs;
+ 	struct mlx5_flow_handle *rule;
+ 	int err;
+ 
+ 	if (ptp_fs->valid)
+ 		return 0;
+ 
+ 	err = mlx5e_fs_tt_redirect_udp_create(priv);
+ 	if (err)
+ 		goto out_free;
+ 
+ 	rule = mlx5e_fs_tt_redirect_udp_add_rule(priv, MLX5_TT_IPV4_UDP,
+ 						 tirn, PTP_EV_PORT);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_fs_udp;
+ 	}
+ 	ptp_fs->udp_v4_rule = rule;
+ 
+ 	rule = mlx5e_fs_tt_redirect_udp_add_rule(priv, MLX5_TT_IPV6_UDP,
+ 						 tirn, PTP_EV_PORT);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_udp_v4_rule;
+ 	}
+ 	ptp_fs->udp_v6_rule = rule;
+ 
+ 	err = mlx5e_fs_tt_redirect_any_create(priv);
+ 	if (err)
+ 		goto out_destroy_udp_v6_rule;
+ 
+ 	rule = mlx5e_fs_tt_redirect_any_add_rule(priv, tirn, ETH_P_1588);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_fs_any;
+ 	}
+ 	ptp_fs->l2_rule = rule;
+ 	ptp_fs->valid = true;
+ 
+ 	return 0;
+ 
+ out_destroy_fs_any:
+ 	mlx5e_fs_tt_redirect_any_destroy(priv);
+ out_destroy_udp_v6_rule:
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v6_rule);
+ out_destroy_udp_v4_rule:
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v4_rule);
+ out_destroy_fs_udp:
+ 	mlx5e_fs_tt_redirect_udp_destroy(priv);
+ out_free:
+ 	return err;
+ }
+ 
+ int mlx5e_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
+ 		   u8 lag_port, struct mlx5e_ptp **cp)
++>>>>>>> d443c6f684d3 (net/mlx5e: Rename traffic type enums)
  {
  	struct net_device *netdev = priv->netdev;
  	struct mlx5_core_dev *mdev = priv->mdev;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
index b416a8ee2eed,3d8918f9399e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
@@@ -816,14 -817,13 +816,20 @@@ static int flow_type_to_traffic_type(u3
  static int mlx5e_set_rss_hash_opt(struct mlx5e_priv *priv,
  				  struct ethtool_rxnfc *nfc)
  {
++<<<<<<< HEAD
 +	int inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
 +	enum mlx5e_traffic_types tt;
 +	u8 rx_hash_field = 0;
 +	void *in;
++=======
+ 	u8 rx_hash_field = 0;
+ 	int err;
+ 	int tt;
++>>>>>>> d443c6f684d3 (net/mlx5e: Rename traffic type enums)
  
  	tt = flow_type_to_traffic_type(nfc->flow_type);
- 	if (tt == MLX5E_NUM_INDIR_TIRS)
- 		return -EINVAL;
+ 	if (tt < 0)
+ 		return tt;
  
  	/*  RSS does not support anything other than hashing to queues
  	 *  on src IP, dest IP, TCP/UDP src port and TCP/UDP dest
@@@ -869,14 -858,14 +875,14 @@@ out
  static int mlx5e_get_rss_hash_opt(struct mlx5e_priv *priv,
  				  struct ethtool_rxnfc *nfc)
  {
- 	enum mlx5e_traffic_types tt;
  	u32 hash_field = 0;
+ 	int tt;
  
  	tt = flow_type_to_traffic_type(nfc->flow_type);
- 	if (tt == MLX5E_NUM_INDIR_TIRS)
- 		return -EINVAL;
+ 	if (tt < 0)
+ 		return tt;
  
 -	hash_field = mlx5e_rx_res_rss_get_hash_fields(priv->rx_res, tt);
 +	hash_field = priv->rss_params.rx_hash_fields[tt];
  	nfc->data = 0;
  
  	if (hash_field & MLX5_HASH_FIELD_SEL_SRC_IP)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,300a37c83c17..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -576,23 -537,28 +576,36 @@@ out
  static int mlx5e_hairpin_create_indirect_tirs(struct mlx5e_hairpin *hp)
  {
  	struct mlx5e_priv *priv = hp->func_priv;
++<<<<<<< HEAD
 +	u32 in[MLX5_ST_SZ_DW(create_tir_in)];
 +	int tt, i, err;
 +	void *tirc;
++=======
+ 	struct mlx5e_rss_params_hash rss_hash;
+ 	enum mlx5_traffic_types tt, max_tt;
+ 	struct mlx5e_tir_builder *builder;
+ 	int err = 0;
+ 
+ 	builder = mlx5e_tir_builder_alloc(false);
+ 	if (!builder)
+ 		return -ENOMEM;
+ 
+ 	rss_hash = mlx5e_rx_res_get_current_hash(priv->rx_res);
++>>>>>>> d443c6f684d3 (net/mlx5e: Rename traffic type enums)
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 -		struct mlx5e_rss_params_traffic_type rss_tt;
 +		struct mlx5e_tirc_config ttconfig = mlx5e_tirc_get_default_config(tt);
  
 -		rss_tt = mlx5e_rss_get_default_tt_config(tt);
 +		memset(in, 0, MLX5_ST_SZ_BYTES(create_tir_in));
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
  
 -		mlx5e_tir_builder_build_rqt(builder, hp->tdn,
 -					    mlx5e_rqt_get_rqtn(&hp->indir_rqt),
 -					    false);
 -		mlx5e_tir_builder_build_rss(builder, &rss_hash, &rss_tt, false);
 +		MLX5_SET(tirc, tirc, transport_domain, hp->tdn);
 +		MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +		MLX5_SET(tirc, tirc, indirect_table, hp->indir_rqt.rqtn);
 +		mlx5e_build_indir_tir_ctx_hash(&priv->rss_params, &ttconfig, tirc, false);
  
 -		err = mlx5e_tir_init(&hp->indir_tir[tt], builder, hp->func_mdev, false);
 +		err = mlx5_core_create_tir(hp->func_mdev, in,
 +					   &hp->indir_tirn[tt]);
  		if (err) {
  			mlx5_core_warn(hp->func_mdev, "create indirect tirs failed, %d\n", err);
  			goto err_destroy_tirs;
@@@ -622,12 -595,12 +635,12 @@@ static void mlx5e_hairpin_set_ttc_param
  
  	memset(ttc_params, 0, sizeof(*ttc_params));
  
 -	ttc_params->any_tt_tirn = mlx5e_tir_get_tirn(&hp->direct_tir);
 +	ttc_params->any_tt_tirn = hp->tirn;
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 -		ttc_params->indir_tirn[tt] = mlx5e_tir_get_tirn(&hp->indir_tir[tt]);
 +		ttc_params->indir_tirn[tt] = hp->indir_tirn[tt];
  
- 	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
+ 	ft_attr->max_fte = MLX5_TTC_TABLE_SIZE;
  	ft_attr->level = MLX5E_TC_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_TC_PRIO;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index 909faa6c89d7..5645e8032218 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@ -33,22 +33,22 @@ static char *fs_udp_type2str(enum fs_udp_type i)
 	}
 }
 
-static enum mlx5e_traffic_types fs_udp2tt(enum fs_udp_type i)
+static enum mlx5_traffic_types fs_udp2tt(enum fs_udp_type i)
 {
 	switch (i) {
 	case FS_IPV4_UDP:
-		return MLX5E_TT_IPV4_UDP;
+		return MLX5_TT_IPV4_UDP;
 	default: /* FS_IPV6_UDP */
-		return MLX5E_TT_IPV6_UDP;
+		return MLX5_TT_IPV6_UDP;
 	}
 }
 
-static enum fs_udp_type tt2fs_udp(enum mlx5e_traffic_types i)
+static enum fs_udp_type tt2fs_udp(enum mlx5_traffic_types i)
 {
 	switch (i) {
-	case MLX5E_TT_IPV4_UDP:
+	case MLX5_TT_IPV4_UDP:
 		return FS_IPV4_UDP;
-	case MLX5E_TT_IPV6_UDP:
+	case MLX5_TT_IPV6_UDP:
 		return FS_IPV6_UDP;
 	default:
 		return FS_UDP_NUM_TYPES;
@@ -75,7 +75,7 @@ static void fs_udp_set_dport_flow(struct mlx5_flow_spec *spec, enum fs_udp_type
 
 struct mlx5_flow_handle *
 mlx5e_fs_tt_redirect_udp_add_rule(struct mlx5e_priv *priv,
-				  enum mlx5e_traffic_types ttc_type,
+				  enum mlx5_traffic_types ttc_type,
 				  u32 tir_num, u16 d_port)
 {
 	enum fs_udp_type type = tt2fs_udp(ttc_type);
@@ -401,7 +401,7 @@ static int fs_any_add_default_rule(struct mlx5e_priv *priv)
 	fs_any = priv->fs.any;
 	fs_any_t = &fs_any->table;
 
-	dest = mlx5e_ttc_get_default_dest(priv, MLX5E_TT_ANY);
+	dest = mlx5e_ttc_get_default_dest(priv, MLX5_TT_ANY);
 	rule = mlx5_add_flow_rules(fs_any_t->t, NULL, &flow_act, &dest, 1);
 	if (IS_ERR(rule)) {
 		err = PTR_ERR(rule);
@@ -514,11 +514,11 @@ static int fs_any_disable(struct mlx5e_priv *priv)
 	int err;
 
 	/* Modify ttc rules destination to point back to the indir TIRs */
-	err = mlx5e_ttc_fwd_default_dest(priv, MLX5E_TT_ANY);
+	err = mlx5e_ttc_fwd_default_dest(priv, MLX5_TT_ANY);
 	if (err) {
 		netdev_err(priv->netdev,
 			   "%s: modify ttc[%d] default destination failed, err(%d)\n",
-			   __func__, MLX5E_TT_ANY, err);
+			   __func__, MLX5_TT_ANY, err);
 		return err;
 	}
 	return 0;
@@ -533,11 +533,11 @@ static int fs_any_enable(struct mlx5e_priv *priv)
 	dest.ft = priv->fs.any->table.t;
 
 	/* Modify ttc rules destination to point on the accel_fs FTs */
-	err = mlx5e_ttc_fwd_dest(priv, MLX5E_TT_ANY, &dest);
+	err = mlx5e_ttc_fwd_dest(priv, MLX5_TT_ANY, &dest);
 	if (err) {
 		netdev_err(priv->netdev,
 			   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
-			   __func__, MLX5E_TT_ANY, err);
+			   __func__, MLX5_TT_ANY, err);
 		return err;
 	}
 	return 0;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h
index 8385df24eb99..7a70c4f38fda 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.h
@@ -12,7 +12,7 @@ void mlx5e_fs_tt_redirect_del_rule(struct mlx5_flow_handle *rule);
 /* UDP traffic type redirect */
 struct mlx5_flow_handle *
 mlx5e_fs_tt_redirect_udp_add_rule(struct mlx5e_priv *priv,
-				  enum mlx5e_traffic_types ttc_type,
+				  enum mlx5_traffic_types ttc_type,
 				  u32 tir_num, u16 d_port);
 void mlx5e_fs_tt_redirect_udp_destroy(struct mlx5e_priv *priv);
 int mlx5e_fs_tt_redirect_udp_create(struct mlx5e_priv *priv);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
index e51f60b55daa..90095507a2ca 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
@@ -16,13 +16,13 @@ struct mlx5e_accel_fs_tcp {
 	struct mlx5_flow_handle *default_rules[ACCEL_FS_TCP_NUM_TYPES];
 };
 
-static enum mlx5e_traffic_types fs_accel2tt(enum accel_fs_tcp_type i)
+static enum mlx5_traffic_types fs_accel2tt(enum accel_fs_tcp_type i)
 {
 	switch (i) {
 	case ACCEL_FS_IPV4_TCP:
-		return MLX5E_TT_IPV4_TCP;
+		return MLX5_TT_IPV4_TCP;
 	default: /* ACCEL_FS_IPV6_TCP */
-		return MLX5E_TT_IPV6_TCP;
+		return MLX5_TT_IPV6_TCP;
 	}
 }
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 34119ce92031..9d9e40a64d0c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@ -41,11 +41,11 @@ struct mlx5e_ipsec_tx {
 };
 
 /* IPsec RX flow steering */
-static enum mlx5e_traffic_types fs_esp2tt(enum accel_fs_esp_type i)
+static enum mlx5_traffic_types fs_esp2tt(enum accel_fs_esp_type i)
 {
 	if (i == ACCEL_FS_ESP4)
-		return MLX5E_TT_IPV4_IPSEC_ESP;
-	return MLX5E_TT_IPV6_IPSEC_ESP;
+		return MLX5_TT_IPV4_IPSEC_ESP;
+	return MLX5_TT_IPV6_IPSEC_ESP;
 }
 
 static int rx_err_add_rule(struct mlx5e_priv *priv,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 25403af32859..8f37b401e475 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -98,17 +98,17 @@ struct arfs_rule {
 	for (j = 0; j < ARFS_HASH_SIZE; j++) \
 		hlist_for_each_entry_safe(hn, tmp, &hash[j], hlist)
 
-static enum mlx5e_traffic_types arfs_get_tt(enum arfs_type type)
+static enum mlx5_traffic_types arfs_get_tt(enum arfs_type type)
 {
 	switch (type) {
 	case ARFS_IPV4_TCP:
-		return MLX5E_TT_IPV4_TCP;
+		return MLX5_TT_IPV4_TCP;
 	case ARFS_IPV4_UDP:
-		return MLX5E_TT_IPV4_UDP;
+		return MLX5_TT_IPV4_UDP;
 	case ARFS_IPV6_TCP:
-		return MLX5E_TT_IPV6_TCP;
+		return MLX5_TT_IPV6_TCP;
 	case ARFS_IPV6_UDP:
-		return MLX5E_TT_IPV6_UDP;
+		return MLX5_TT_IPV6_UDP;
 	default:
 		return -EINVAL;
 	}
@@ -195,7 +195,7 @@ static int arfs_add_default_rule(struct mlx5e_priv *priv,
 	struct mlx5e_tir *tir = priv->indir_tir;
 	struct mlx5_flow_destination dest = {};
 	MLX5_DECLARE_FLOW_ACT(flow_act);
-	enum mlx5e_traffic_types tt;
+	enum mlx5_traffic_types tt;
 	int err = 0;
 
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 059efb0721cd..249a18a808bf 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@ -834,14 +834,14 @@ static void mlx5e_cleanup_ttc_rules(struct mlx5e_ttc_table *ttc)
 {
 	int i;
 
-	for (i = 0; i < MLX5E_NUM_TT; i++) {
+	for (i = 0; i < MLX5_NUM_TT; i++) {
 		if (!IS_ERR_OR_NULL(ttc->rules[i].rule)) {
 			mlx5_del_flow_rules(ttc->rules[i].rule);
 			ttc->rules[i].rule = NULL;
 		}
 	}
 
-	for (i = 0; i < MLX5E_NUM_TUNNEL_TT; i++) {
+	for (i = 0; i < MLX5_NUM_TUNNEL_TT; i++) {
 		if (!IS_ERR_OR_NULL(ttc->tunnel_rules[i])) {
 			mlx5_del_flow_rules(ttc->tunnel_rules[i]);
 			ttc->tunnel_rules[i] = NULL;
@@ -855,81 +855,81 @@ struct mlx5e_etype_proto {
 };
 
 static struct mlx5e_etype_proto ttc_rules[] = {
-	[MLX5E_TT_IPV4_TCP] = {
+	[MLX5_TT_IPV4_TCP] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_TCP,
 	},
-	[MLX5E_TT_IPV6_TCP] = {
+	[MLX5_TT_IPV6_TCP] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_TCP,
 	},
-	[MLX5E_TT_IPV4_UDP] = {
+	[MLX5_TT_IPV4_UDP] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_UDP,
 	},
-	[MLX5E_TT_IPV6_UDP] = {
+	[MLX5_TT_IPV6_UDP] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_UDP,
 	},
-	[MLX5E_TT_IPV4_IPSEC_AH] = {
+	[MLX5_TT_IPV4_IPSEC_AH] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_AH,
 	},
-	[MLX5E_TT_IPV6_IPSEC_AH] = {
+	[MLX5_TT_IPV6_IPSEC_AH] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_AH,
 	},
-	[MLX5E_TT_IPV4_IPSEC_ESP] = {
+	[MLX5_TT_IPV4_IPSEC_ESP] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_ESP,
 	},
-	[MLX5E_TT_IPV6_IPSEC_ESP] = {
+	[MLX5_TT_IPV6_IPSEC_ESP] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_ESP,
 	},
-	[MLX5E_TT_IPV4] = {
+	[MLX5_TT_IPV4] = {
 		.etype = ETH_P_IP,
 		.proto = 0,
 	},
-	[MLX5E_TT_IPV6] = {
+	[MLX5_TT_IPV6] = {
 		.etype = ETH_P_IPV6,
 		.proto = 0,
 	},
-	[MLX5E_TT_ANY] = {
+	[MLX5_TT_ANY] = {
 		.etype = 0,
 		.proto = 0,
 	},
 };
 
 static struct mlx5e_etype_proto ttc_tunnel_rules[] = {
-	[MLX5E_TT_IPV4_GRE] = {
+	[MLX5_TT_IPV4_GRE] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_GRE,
 	},
-	[MLX5E_TT_IPV6_GRE] = {
+	[MLX5_TT_IPV6_GRE] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_GRE,
 	},
-	[MLX5E_TT_IPV4_IPIP] = {
+	[MLX5_TT_IPV4_IPIP] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_IPIP,
 	},
-	[MLX5E_TT_IPV6_IPIP] = {
+	[MLX5_TT_IPV6_IPIP] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_IPIP,
 	},
-	[MLX5E_TT_IPV4_IPV6] = {
+	[MLX5_TT_IPV4_IPV6] = {
 		.etype = ETH_P_IP,
 		.proto = IPPROTO_IPV6,
 	},
-	[MLX5E_TT_IPV6_IPV6] = {
+	[MLX5_TT_IPV6_IPV6] = {
 		.etype = ETH_P_IPV6,
 		.proto = IPPROTO_IPV6,
 	},
 
 };
 
-u8 mlx5e_get_proto_by_tunnel_type(enum mlx5e_tunnel_types tt)
+u8 mlx5e_get_proto_by_tunnel_type(enum mlx5_tunnel_types tt)
 {
 	return ttc_tunnel_rules[tt].proto;
 }
@@ -952,7 +952,7 @@ static bool mlx5e_tunnel_any_rx_proto_supported(struct mlx5_core_dev *mdev)
 {
 	int tt;
 
-	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
+	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
 		if (mlx5e_tunnel_proto_supported_rx(mdev, ttc_tunnel_rules[tt].proto))
 			return true;
 	}
@@ -1036,10 +1036,10 @@ static int mlx5e_generate_ttc_table_rules(struct mlx5e_priv *priv,
 	rules = ttc->rules;
 
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
-	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
+	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
 		struct mlx5e_ttc_rule *rule = &rules[tt];
 
-		if (tt == MLX5E_TT_ANY)
+		if (tt == MLX5_TT_ANY)
 			dest.tir_num = params->any_tt_tirn;
 		else
 			dest.tir_num = params->indir_tirn[tt];
@@ -1060,8 +1060,8 @@ static int mlx5e_generate_ttc_table_rules(struct mlx5e_priv *priv,
 
 	trules    = ttc->tunnel_rules;
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
-	dest.ft   = params->inner_ttc->ft.t;
-	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
+	dest.ft = params->inner_ttc->ft.t;
+	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
 		if (!mlx5e_tunnel_proto_supported_rx(priv->mdev,
 						     ttc_tunnel_rules[tt].proto))
 			continue;
@@ -1092,7 +1092,7 @@ static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc,
 	int err;
 	u8 *mc;
 
-	ft->g = kcalloc(MLX5E_TTC_NUM_GROUPS,
+	ft->g = kcalloc(MLX5_TTC_NUM_GROUPS,
 			sizeof(*ft->g), GFP_KERNEL);
 	if (!ft->g)
 		return -ENOMEM;
@@ -1112,7 +1112,7 @@ static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc,
 		MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);
 	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
 	MLX5_SET_CFG(in, start_flow_index, ix);
-	ix += MLX5E_TTC_GROUP1_SIZE;
+	ix += MLX5_TTC_GROUP1_SIZE;
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 	if (IS_ERR(ft->g[ft->num_groups]))
@@ -1122,7 +1122,7 @@ static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc,
 	/* L3 Group */
 	MLX5_SET(fte_match_param, mc, outer_headers.ip_protocol, 0);
 	MLX5_SET_CFG(in, start_flow_index, ix);
-	ix += MLX5E_TTC_GROUP2_SIZE;
+	ix += MLX5_TTC_GROUP2_SIZE;
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 	if (IS_ERR(ft->g[ft->num_groups]))
@@ -1132,7 +1132,7 @@ static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc,
 	/* Any Group */
 	memset(in, 0, inlen);
 	MLX5_SET_CFG(in, start_flow_index, ix);
-	ix += MLX5E_TTC_GROUP3_SIZE;
+	ix += MLX5_TTC_GROUP3_SIZE;
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 	if (IS_ERR(ft->g[ft->num_groups]))
@@ -1203,10 +1203,10 @@ static int mlx5e_generate_inner_ttc_table_rules(struct mlx5e_priv *priv,
 	rules = ttc->rules;
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 
-	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
+	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
 		struct mlx5e_ttc_rule *rule = &rules[tt];
 
-		if (tt == MLX5E_TT_ANY)
+		if (tt == MLX5_TT_ANY)
 			dest.tir_num = params->any_tt_tirn;
 		else
 			dest.tir_num = params->indir_tirn[tt];
@@ -1239,7 +1239,7 @@ static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 	int err;
 	u8 *mc;
 
-	ft->g = kcalloc(MLX5E_INNER_TTC_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);
+	ft->g = kcalloc(MLX5_INNER_TTC_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);
 	if (!ft->g)
 		return -ENOMEM;
 	in = kvzalloc(inlen, GFP_KERNEL);
@@ -1255,7 +1255,7 @@ static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 	MLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_version);
 	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_INNER_HEADERS);
 	MLX5_SET_CFG(in, start_flow_index, ix);
-	ix += MLX5E_INNER_TTC_GROUP1_SIZE;
+	ix += MLX5_INNER_TTC_GROUP1_SIZE;
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 	if (IS_ERR(ft->g[ft->num_groups]))
@@ -1265,7 +1265,7 @@ static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 	/* L3 Group */
 	MLX5_SET(fte_match_param, mc, inner_headers.ip_protocol, 0);
 	MLX5_SET_CFG(in, start_flow_index, ix);
-	ix += MLX5E_INNER_TTC_GROUP2_SIZE;
+	ix += MLX5_INNER_TTC_GROUP2_SIZE;
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 	if (IS_ERR(ft->g[ft->num_groups]))
@@ -1275,7 +1275,7 @@ static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 	/* Any Group */
 	memset(in, 0, inlen);
 	MLX5_SET_CFG(in, start_flow_index, ix);
-	ix += MLX5E_INNER_TTC_GROUP3_SIZE;
+	ix += MLX5_INNER_TTC_GROUP3_SIZE;
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 	if (IS_ERR(ft->g[ft->num_groups]))
@@ -1304,7 +1304,7 @@ static void mlx5e_set_inner_ttc_ft_params(struct ttc_params *ttc_params)
 {
 	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
 
-	ft_attr->max_fte = MLX5E_INNER_TTC_TABLE_SIZE;
+	ft_attr->max_fte = MLX5_INNER_TTC_TABLE_SIZE;
 	ft_attr->level = MLX5E_INNER_TTC_FT_LEVEL;
 	ft_attr->prio = MLX5E_NIC_PRIO;
 }
@@ -1314,7 +1314,7 @@ void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params)
 {
 	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
 
-	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
+	ft_attr->max_fte = MLX5_TTC_TABLE_SIZE;
 	ft_attr->level = MLX5E_TTC_FT_LEVEL;
 	ft_attr->prio = MLX5E_NIC_PRIO;
 }
@@ -1389,14 +1389,14 @@ int mlx5e_create_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
 	return err;
 }
 
-int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
+int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5_traffic_types type,
 		       struct mlx5_flow_destination *new_dest)
 {
 	return mlx5_modify_rule_destination(priv->fs.ttc.rules[type].rule, new_dest, NULL);
 }
 
 struct mlx5_flow_destination
-mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
+mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5_traffic_types type)
 {
 	struct mlx5_flow_destination *dest = &priv->fs.ttc.rules[type].default_dest;
 
@@ -1406,7 +1406,7 @@ mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types typ
 	return *dest;
 }
 
-int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
+int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5_traffic_types type)
 {
 	struct mlx5_flow_destination dest = mlx5e_ttc_get_default_dest(priv, type);
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 15e30d82e985..94ac0d9c5427 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -4790,7 +4790,7 @@ static bool mlx5e_tunnel_any_tx_proto_supported(struct mlx5_core_dev *mdev)
 {
 	int tt;
 
-	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
+	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
 		if (mlx5e_tunnel_proto_supported_tx(mdev, mlx5e_get_proto_by_tunnel_type(tt)))
 			return true;
 	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
