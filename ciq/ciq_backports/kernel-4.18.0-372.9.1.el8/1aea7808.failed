LSM: Infrastructure management of the superblock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Casey Schaufler <casey@schaufler-ca.com>
commit 1aea7808372eee4ad01f98e064c88c57f1e94855
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/1aea7808.failed

Move management of the superblock->sb_security blob out of the
individual security modules and into the security infrastructure.
Instead of allocating the blobs from within the modules, the modules
tell the infrastructure how much space is required, and the space is
allocated there.

	Cc: John Johansen <john.johansen@canonical.com>
	Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
	Signed-off-by: Mickaël Salaün <mic@linux.microsoft.com>
	Reviewed-by: Stephen Smalley <stephen.smalley.work@gmail.com>
	Acked-by: Serge Hallyn <serge@hallyn.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
Link: https://lore.kernel.org/r/20210422154123.13086-6-mic@digikod.net
	Signed-off-by: James Morris <jamorris@linux.microsoft.com>
(cherry picked from commit 1aea7808372eee4ad01f98e064c88c57f1e94855)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/smack/smack_lsm.c
diff --cc security/smack/smack_lsm.c
index 8980142e168e,ee3e29603c9c..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -553,62 -548,66 +547,70 @@@ static int smack_sb_alloc_security(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * smack_sb_free_security - free a superblock blob
 + * @sb: the superblock getting the blob
 + *
 + */
 +static void smack_sb_free_security(struct super_block *sb)
 +{
 +	kfree(sb->s_security);
 +	sb->s_security = NULL;
 +}
 +
 +/**
 + * smack_sb_copy_data - copy mount options data for processing
 + * @orig: where to start
 + * @smackopts: mount options string
 + *
 + * Returns 0 on success or -ENOMEM on error.
 + *
 + * Copy the Smack specific mount options out of the mount
 + * options list.
 + */
 +static int smack_sb_copy_data(char *orig, char *smackopts)
++=======
+ struct smack_mnt_opts {
+ 	const char *fsdefault, *fsfloor, *fshat, *fsroot, *fstransmute;
+ };
+ 
+ static void smack_free_mnt_opts(void *mnt_opts)
++>>>>>>> 1aea7808372e (LSM: Infrastructure management of the superblock)
  {
 -	struct smack_mnt_opts *opts = mnt_opts;
 -	kfree(opts->fsdefault);
 -	kfree(opts->fsfloor);
 -	kfree(opts->fshat);
 -	kfree(opts->fsroot);
 -	kfree(opts->fstransmute);
 -	kfree(opts);
 -}
 -
 -static int smack_add_opt(int token, const char *s, void **mnt_opts)
 -{
 -	struct smack_mnt_opts *opts = *mnt_opts;
 +	char *cp, *commap, *otheropts, *dp;
  
 -	if (!opts) {
 -		opts = kzalloc(sizeof(struct smack_mnt_opts), GFP_KERNEL);
 -		if (!opts)
 -			return -ENOMEM;
 -		*mnt_opts = opts;
 -	}
 -	if (!s)
 +	otheropts = (char *)get_zeroed_page(GFP_KERNEL);
 +	if (otheropts == NULL)
  		return -ENOMEM;
  
 -	switch (token) {
 -	case Opt_fsdefault:
 -		if (opts->fsdefault)
 -			goto out_opt_err;
 -		opts->fsdefault = s;
 -		break;
 -	case Opt_fsfloor:
 -		if (opts->fsfloor)
 -			goto out_opt_err;
 -		opts->fsfloor = s;
 -		break;
 -	case Opt_fshat:
 -		if (opts->fshat)
 -			goto out_opt_err;
 -		opts->fshat = s;
 -		break;
 -	case Opt_fsroot:
 -		if (opts->fsroot)
 -			goto out_opt_err;
 -		opts->fsroot = s;
 -		break;
 -	case Opt_fstransmute:
 -		if (opts->fstransmute)
 -			goto out_opt_err;
 -		opts->fstransmute = s;
 -		break;
 +	for (cp = orig, commap = orig; commap != NULL; cp = commap + 1) {
 +		if (strstr(cp, SMK_FSDEFAULT) == cp)
 +			dp = smackopts;
 +		else if (strstr(cp, SMK_FSFLOOR) == cp)
 +			dp = smackopts;
 +		else if (strstr(cp, SMK_FSHAT) == cp)
 +			dp = smackopts;
 +		else if (strstr(cp, SMK_FSROOT) == cp)
 +			dp = smackopts;
 +		else if (strstr(cp, SMK_FSTRANS) == cp)
 +			dp = smackopts;
 +		else
 +			dp = otheropts;
 +
 +		commap = strchr(cp, ',');
 +		if (commap != NULL)
 +			*commap = '\0';
 +
 +		if (*dp != '\0')
 +			strcat(dp, ",");
 +		strcat(dp, cp);
  	}
 -	return 0;
  
 -out_opt_err:
 -	pr_warn("Smack: duplicate mount options\n");
 -	return -EINVAL;
 +	strcpy(orig, otheropts);
 +	free_page((unsigned long)otheropts);
 +
 +	return 0;
  }
  
  /**
@@@ -754,12 -755,11 +756,12 @@@ static int smack_set_mnt_opts(struct su
  {
  	struct dentry *root = sb->s_root;
  	struct inode *inode = d_backing_inode(root);
- 	struct superblock_smack *sp = sb->s_security;
+ 	struct superblock_smack *sp = smack_superblock(sb);
  	struct inode_smack *isp;
  	struct smack_known *skp;
 -	struct smack_mnt_opts *opts = mnt_opts;
 -	bool transmute = false;
 +	int i;
 +	int num_opts = opts->num_mnt_opts;
 +	int transmute = 0;
  
  	if (sp->smk_flags & SMK_SB_INITIALIZED)
  		return 0;
@@@ -1731,10 -1650,10 +1733,10 @@@ static int smack_mmap_file(struct file 
  	if (unlikely(IS_PRIVATE(file_inode(file))))
  		return 0;
  
 -	isp = smack_inode(file_inode(file));
 +	isp = file_inode(file)->i_security;
  	if (isp->smk_mmap == NULL)
  		return 0;
- 	sbsp = file_inode(file)->i_sb->s_security;
+ 	sbsp = smack_superblock(file_inode(file)->i_sb);
  	if (sbsp->smk_flags & SMK_SB_UNTRUSTED &&
  	    isp->smk_mmap != sbsp->smk_root)
  		return -EACCES;
@@@ -3368,10 -3265,10 +3370,10 @@@ static void smack_d_instantiate(struct 
  	 * take the quick way out
  	 */
  	if (isp->smk_flags & SMK_INODE_INSTANT)
 -		return;
 +		goto unlockandout;
  
  	sbp = inode->i_sb;
- 	sbsp = sbp->s_security;
+ 	sbsp = smack_superblock(sbp);
  	/*
  	 * We're going to use the superblock default label
  	 * if there's no label on the file.
@@@ -4638,18 -4677,28 +4640,35 @@@ static int smack_dentry_create_files_as
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct lsm_blob_sizes smack_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct task_smack),
+ 	.lbs_file = sizeof(struct smack_known *),
+ 	.lbs_inode = sizeof(struct inode_smack),
+ 	.lbs_ipc = sizeof(struct smack_known *),
+ 	.lbs_msg_msg = sizeof(struct smack_known *),
+ 	.lbs_superblock = sizeof(struct superblock_smack),
+ };
+ 
++>>>>>>> 1aea7808372e (LSM: Infrastructure management of the superblock)
  static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),
  	LSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),
  	LSM_HOOK_INIT(syslog, smack_syslog),
  
 -	LSM_HOOK_INIT(fs_context_dup, smack_fs_context_dup),
 -	LSM_HOOK_INIT(fs_context_parse_param, smack_fs_context_parse_param),
 -
  	LSM_HOOK_INIT(sb_alloc_security, smack_sb_alloc_security),
++<<<<<<< HEAD
 +	LSM_HOOK_INIT(sb_free_security, smack_sb_free_security),
 +	LSM_HOOK_INIT(sb_copy_data, smack_sb_copy_data),
 +	LSM_HOOK_INIT(sb_kern_mount, smack_sb_kern_mount),
++=======
+ 	LSM_HOOK_INIT(sb_free_mnt_opts, smack_free_mnt_opts),
+ 	LSM_HOOK_INIT(sb_eat_lsm_opts, smack_sb_eat_lsm_opts),
++>>>>>>> 1aea7808372e (LSM: Infrastructure management of the superblock)
  	LSM_HOOK_INIT(sb_statfs, smack_sb_statfs),
  	LSM_HOOK_INIT(sb_set_mnt_opts, smack_set_mnt_opts),
 +	LSM_HOOK_INIT(sb_parse_opts_str, smack_parse_opts_str),
  
  	LSM_HOOK_INIT(bprm_creds_for_exec, smack_bprm_creds_for_exec),
  
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index ec21b3299148..04d14906b833 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1497,6 +1497,7 @@ struct lsm_blob_sizes {
 	int	lbs_cred;
 	int	lbs_file;
 	int	lbs_inode;
+	int	lbs_superblock;
 	int	lbs_ipc;
 	int	lbs_msg_msg;
 	int	lbs_task;
diff --git a/security/security.c b/security/security.c
index fe356d5fcfc0..13feb69ad4e0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -175,6 +175,7 @@ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
 	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
 	lsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);
 	lsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);
+	lsm_set_blob_size(&needed->lbs_superblock, &blob_sizes.lbs_superblock);
 	lsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);
 }
 
@@ -303,12 +304,13 @@ static void __init ordered_lsm_init(void)
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		prepare_lsm(*lsm);
 
-	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
-	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
-	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
-	init_debug("ipc blob size      = %d\n", blob_sizes.lbs_ipc);
-	init_debug("msg_msg blob size  = %d\n", blob_sizes.lbs_msg_msg);
-	init_debug("task blob size     = %d\n", blob_sizes.lbs_task);
+	init_debug("cred blob size       = %d\n", blob_sizes.lbs_cred);
+	init_debug("file blob size       = %d\n", blob_sizes.lbs_file);
+	init_debug("inode blob size      = %d\n", blob_sizes.lbs_inode);
+	init_debug("ipc blob size        = %d\n", blob_sizes.lbs_ipc);
+	init_debug("msg_msg blob size    = %d\n", blob_sizes.lbs_msg_msg);
+	init_debug("superblock blob size = %d\n", blob_sizes.lbs_superblock);
+	init_debug("task blob size       = %d\n", blob_sizes.lbs_task);
 
 	/*
 	 * Create any kmem_caches needed for blobs
@@ -609,6 +611,27 @@ static void __init lsm_early_task(struct task_struct *task)
 		panic("%s: Early task alloc failed.\n", __func__);
 }
 
+/**
+ * lsm_superblock_alloc - allocate a composite superblock blob
+ * @sb: the superblock that needs a blob
+ *
+ * Allocate the superblock blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+static int lsm_superblock_alloc(struct super_block *sb)
+{
+	if (blob_sizes.lbs_superblock == 0) {
+		sb->s_security = NULL;
+		return 0;
+	}
+
+	sb->s_security = kzalloc(blob_sizes.lbs_superblock, GFP_KERNEL);
+	if (sb->s_security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
 /*
  * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
  * can be accessed with:
@@ -806,12 +829,21 @@ int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *
 
 int security_sb_alloc(struct super_block *sb)
 {
-	return call_int_hook(sb_alloc_security, 0, sb);
+	int rc = lsm_superblock_alloc(sb);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(sb_alloc_security, 0, sb);
+	if (unlikely(rc))
+		security_sb_free(sb);
+	return rc;
 }
 
 void security_sb_free(struct super_block *sb)
 {
 	call_void_hook(sb_free_security, sb);
+	kfree(sb->s_security);
+	sb->s_security = NULL;
 }
 
 void security_free_mnt_opts(void **mnt_opts)
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index a7b5d65c2d88..1e2883bbb2a1 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -321,7 +321,7 @@ static void inode_free_security(struct inode *inode)
 
 	if (!isec)
 		return;
-	sbsec = inode->i_sb->s_security;
+	sbsec = selinux_superblock(inode->i_sb);
 	/*
 	 * As not all inode security structures are in a list, we check for
 	 * empty list outside of the lock to make sure that we won't waste
@@ -339,13 +339,6 @@ static void inode_free_security(struct inode *inode)
 	}
 }
 
-static void superblock_free_security(struct super_block *sb)
-{
-	struct superblock_security_struct *sbsec = sb->s_security;
-	sb->s_security = NULL;
-	kfree(sbsec);
-}
-
 struct selinux_mnt_opts {
 	const char *fscontext, *context, *rootcontext, *defcontext;
 };
@@ -460,7 +453,7 @@ static int selinux_is_genfs_special_handling(struct super_block *sb)
 
 static int selinux_is_sblabel_mnt(struct super_block *sb)
 {
-	struct superblock_security_struct *sbsec = sb->s_security;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 
 	/*
 	 * IMPORTANT: Double-check logic in this function when adding a new
@@ -537,7 +530,7 @@ static int sb_check_xattr_support(struct super_block *sb)
 
 static int sb_finish_set_opts(struct super_block *sb)
 {
-	struct superblock_security_struct *sbsec = sb->s_security;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 	struct dentry *root = sb->s_root;
 	struct inode *root_inode = d_backing_inode(root);
 	int rc = 0;
@@ -628,7 +621,7 @@ static int selinux_set_mnt_opts(struct super_block *sb,
 				unsigned long *set_kern_flags)
 {
 	const struct cred *cred = current_cred();
-	struct superblock_security_struct *sbsec = sb->s_security;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 	struct dentry *root = sb->s_root;
 	struct selinux_mnt_opts *opts = mnt_opts;
 	struct inode_security_struct *root_isec;
@@ -869,8 +862,8 @@ static int selinux_set_mnt_opts(struct super_block *sb,
 static int selinux_cmp_sb_context(const struct super_block *oldsb,
 				    const struct super_block *newsb)
 {
-	struct superblock_security_struct *old = oldsb->s_security;
-	struct superblock_security_struct *new = newsb->s_security;
+	struct superblock_security_struct *old = selinux_superblock(oldsb);
+	struct superblock_security_struct *new = selinux_superblock(newsb);
 	char oldflags = old->flags & SE_MNTMASK;
 	char newflags = new->flags & SE_MNTMASK;
 
@@ -902,8 +895,9 @@ static int selinux_sb_clone_mnt_opts(const struct super_block *oldsb,
 					unsigned long *set_kern_flags)
 {
 	int rc = 0;
-	const struct superblock_security_struct *oldsbsec = oldsb->s_security;
-	struct superblock_security_struct *newsbsec = newsb->s_security;
+	const struct superblock_security_struct *oldsbsec =
+						selinux_superblock(oldsb);
+	struct superblock_security_struct *newsbsec = selinux_superblock(newsb);
 
 	int set_fscontext =	(oldsbsec->flags & FSCONTEXT_MNT);
 	int set_context =	(oldsbsec->flags & CONTEXT_MNT);
@@ -1082,7 +1076,7 @@ static int show_sid(struct seq_file *m, u32 sid)
 
 static int selinux_sb_show_options(struct seq_file *m, struct super_block *sb)
 {
-	struct superblock_security_struct *sbsec = sb->s_security;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 	int rc;
 
 	if (!(sbsec->flags & SE_SBINITIALIZED))
@@ -1433,7 +1427,7 @@ static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dent
 	if (isec->sclass == SECCLASS_FILE)
 		isec->sclass = inode_mode_to_security_class(inode->i_mode);
 
-	sbsec = inode->i_sb->s_security;
+	sbsec = selinux_superblock(inode->i_sb);
 	if (!(sbsec->flags & SE_SBINITIALIZED)) {
 		/* Defer initialization until selinux_complete_init,
 		   after the initial policy is loaded and the security
@@ -1794,7 +1788,8 @@ selinux_determine_inode_label(const struct task_security_struct *tsec,
 				 const struct qstr *name, u16 tclass,
 				 u32 *_new_isid)
 {
-	const struct superblock_security_struct *sbsec = dir->i_sb->s_security;
+	const struct superblock_security_struct *sbsec =
+						selinux_superblock(dir->i_sb);
 
 	if ((sbsec->flags & SE_SBINITIALIZED) &&
 	    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {
@@ -1825,7 +1820,7 @@ static int may_create(struct inode *dir,
 	int rc;
 
 	dsec = inode_security(dir);
-	sbsec = dir->i_sb->s_security;
+	sbsec = selinux_superblock(dir->i_sb);
 
 	sid = tsec->sid;
 
@@ -1974,7 +1969,7 @@ static int superblock_has_perm(const struct cred *cred,
 	struct superblock_security_struct *sbsec;
 	u32 sid = cred_sid(cred);
 
-	sbsec = sb->s_security;
+	sbsec = selinux_superblock(sb);
 	return avc_has_perm(&selinux_state,
 			    sid, sbsec->sid, SECCLASS_FILESYSTEM, perms, ad);
 }
@@ -2607,11 +2602,7 @@ static void selinux_bprm_committed_creds(struct linux_binprm *bprm)
 
 static int selinux_sb_alloc_security(struct super_block *sb)
 {
-	struct superblock_security_struct *sbsec;
-
-	sbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);
-	if (!sbsec)
-		return -ENOMEM;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 
 	mutex_init(&sbsec->lock);
 	INIT_LIST_HEAD(&sbsec->isec_head);
@@ -2619,16 +2610,10 @@ static int selinux_sb_alloc_security(struct super_block *sb)
 	sbsec->sid = SECINITSID_UNLABELED;
 	sbsec->def_sid = SECINITSID_FILE;
 	sbsec->mntpoint_sid = SECINITSID_UNLABELED;
-	sb->s_security = sbsec;
 
 	return 0;
 }
 
-static void selinux_sb_free_security(struct super_block *sb)
-{
-	superblock_free_security(sb);
-}
-
 static inline int opt_len(const char *s)
 {
 	bool open_quote = false;
@@ -2762,7 +2747,7 @@ static int selinux_sb_mnt_opts_compat(struct super_block *sb, void *mnt_opts)
 static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)
 {
 	struct selinux_mnt_opts *opts = mnt_opts;
-	struct superblock_security_struct *sbsec = sb->s_security;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 	u32 sid;
 	int rc;
 
@@ -3000,7 +2985,7 @@ static int selinux_inode_init_security(struct inode *inode, struct inode *dir,
 	int rc;
 	char *context;
 
-	sbsec = dir->i_sb->s_security;
+	sbsec = selinux_superblock(dir->i_sb);
 
 	newsid = tsec->create_sid;
 
@@ -3245,7 +3230,7 @@ static int selinux_inode_setxattr(struct dentry *dentry, const char *name,
 	if (!selinux_initialized(&selinux_state))
 		return (inode_owner_or_capable(inode) ? 0 : -EPERM);
 
-	sbsec = inode->i_sb->s_security;
+	sbsec = selinux_superblock(inode->i_sb);
 	if (!(sbsec->flags & SBLABEL_MNT))
 		return -EOPNOTSUPP;
 
@@ -3443,13 +3428,14 @@ static int selinux_inode_setsecurity(struct inode *inode, const char *name,
 				     const void *value, size_t size, int flags)
 {
 	struct inode_security_struct *isec = inode_security_novalidate(inode);
-	struct superblock_security_struct *sbsec = inode->i_sb->s_security;
+	struct superblock_security_struct *sbsec;
 	u32 newsid;
 	int rc;
 
 	if (strcmp(name, XATTR_SELINUX_SUFFIX))
 		return -EOPNOTSUPP;
 
+	sbsec = selinux_superblock(inode->i_sb);
 	if (!(sbsec->flags & SBLABEL_MNT))
 		return -EOPNOTSUPP;
 
@@ -6893,6 +6879,7 @@ struct lsm_blob_sizes selinux_blob_sizes __lsm_ro_after_init = {
 	.lbs_inode = sizeof(struct inode_security_struct),
 	.lbs_ipc = sizeof(struct ipc_security_struct),
 	.lbs_msg_msg = sizeof(struct msg_security_struct),
+	.lbs_superblock = sizeof(struct superblock_security_struct),
 };
 
 /*
@@ -6994,7 +6981,6 @@ static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),
 	LSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),
 
-	LSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),
 	LSM_HOOK_INIT(sb_free_mnt_opts, selinux_free_mnt_opts),
 	LSM_HOOK_INIT(sb_mnt_opts_compat, selinux_sb_mnt_opts_compat),
 	LSM_HOOK_INIT(sb_remount, selinux_sb_remount),
diff --git a/security/selinux/include/objsec.h b/security/selinux/include/objsec.h
index 31b55b3bd3c6..43b9152309d2 100644
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@ -191,4 +191,10 @@ static inline u32 current_sid(void)
 	return tsec->sid;
 }
 
+static inline struct superblock_security_struct *selinux_superblock(
+					const struct super_block *superblock)
+{
+	return superblock->s_security + selinux_blob_sizes.lbs_superblock;
+}
+
 #endif /* _SELINUX_OBJSEC_H_ */
diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c
index 3491c02e1c4b..960aef2d1366 100644
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@ -49,6 +49,7 @@
 #include <linux/sched.h>
 #include <linux/audit.h>
 #include <linux/vmalloc.h>
+#include <linux/lsm_hooks.h>
 #include <net/netlabel.h>
 
 #include "flask.h"
@@ -2795,7 +2796,7 @@ int security_fs_use(struct selinux_state *state, struct super_block *sb)
 	struct sidtab *sidtab;
 	int rc = 0;
 	struct ocontext *c;
-	struct superblock_security_struct *sbsec = sb->s_security;
+	struct superblock_security_struct *sbsec = selinux_superblock(sb);
 	const char *fstype = sb->s_type->name;
 
 	read_lock(&state->ss->policy_rwlock);
diff --git a/security/smack/smack.h b/security/smack/smack.h
index f7db791fb566..723f9c7e2bda 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -356,6 +356,12 @@ extern struct list_head smack_onlycap_list;
 #define SMACK_HASH_SLOTS 16
 extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
 
+static inline struct superblock_smack *smack_superblock(
+					const struct super_block *superblock)
+{
+	return superblock->s_security + smack_blob_sizes.lbs_superblock;
+}
+
 /*
  * Is the directory transmuting?
  */
* Unmerged path security/smack/smack_lsm.c
