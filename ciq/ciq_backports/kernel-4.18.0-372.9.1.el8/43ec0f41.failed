net/mlx5e: Hide all implementation details of mlx5e_rx_res

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Maxim Mikityanskiy <maximmi@nvidia.com>
commit 43ec0f41fa73cc4d4f8a67e56fb398eff6881841
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/43ec0f41.failed

This commit moves all implementation details of struct mlx5e_rx_res
under en/rx_res.c. All access to RX resources is now done using methods.
Encapsulating RX resources into an object allows for better
manageability, because all the implementation details are now in a
single place, and external code can use only a limited set of API
methods to init/teardown the whole thing, reconfigure RSS and LRO
parameters, connect TIRs to flow steering and activate/deactivate TIRs.

mlx5e_rx_res is self-contained and doesn't depend on struct mlx5e_priv
or include en.h.

	Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 43ec0f41fa73cc4d4f8a67e56fb398eff6881841)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 73a162266789,968e6a473cec..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -944,25 -921,6 +944,28 @@@ int mlx5e_vlan_rx_kill_vid(struct net_d
  			   u16 vid);
  void mlx5e_timestamp_init(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +struct mlx5e_redirect_rqt_param {
 +	bool is_rss;
 +	union {
 +		u32 rqn; /* Direct RQN (Non-RSS) */
 +		struct {
 +			u8 hfunc;
 +			struct mlx5e_channels *channels;
 +		} rss; /* RSS data */
 +	};
 +};
 +
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp);
 +void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_rss_params *rss_params,
 +				    const struct mlx5e_tirc_config *ttconfig,
 +				    void *tirc, bool inner);
 +void mlx5e_modify_tirs_hash(struct mlx5e_priv *priv, void *in);
 +struct mlx5e_tirc_config mlx5e_tirc_get_default_config(enum mlx5e_traffic_types tt);
 +
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  struct mlx5e_xsk_param;
  
  struct mlx5e_rq_param;
@@@ -1079,17 -1031,6 +1082,20 @@@ void mlx5e_close_drop_rq(struct mlx5e_r
  int mlx5e_init_di_list(struct mlx5e_rq *rq, int wq_sz, int node);
  void mlx5e_free_di_list(struct mlx5e_rq *rq);
  
++<<<<<<< HEAD
 +int mlx5e_create_indirect_rqt(struct mlx5e_priv *priv);
 +
 +int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv, bool inner_ttc);
 +void mlx5e_destroy_indirect_tirs(struct mlx5e_priv *priv);
 +
 +int mlx5e_create_direct_rqts(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n);
 +void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n);
 +int mlx5e_create_direct_tirs(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n);
 +void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n);
 +void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
 +
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  int mlx5e_create_tis(struct mlx5_core_dev *mdev, void *in, u32 *tisn);
  void mlx5e_destroy_tis(struct mlx5_core_dev *mdev, u32 tisn);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
index f9afbdefded5,f9c96e5a7f54..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
@@@ -441,14 -564,103 +441,102 @@@ close_cqs
  	return err;
  }
  
 -static void mlx5e_ptp_close_queues(struct mlx5e_ptp *c)
 +static void mlx5e_ptp_close_queues(struct mlx5e_port_ptp *c)
  {
 -	if (test_bit(MLX5E_PTP_STATE_RX, c->state)) {
 -		mlx5e_close_rq(&c->rq);
 -		mlx5e_close_cq(&c->rq.cq);
 -	}
 -	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
 -		mlx5e_ptp_close_txqsqs(c);
 -		mlx5e_ptp_close_tx_cqs(c);
 -	}
 +	mlx5e_ptp_close_txqsqs(c);
 +	mlx5e_ptp_close_cqs(c);
  }
  
++<<<<<<< HEAD
 +int mlx5e_port_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
 +			u8 lag_port, struct mlx5e_port_ptp **cp)
++=======
+ static int mlx5e_ptp_set_state(struct mlx5e_ptp *c, struct mlx5e_params *params)
+ {
+ 	if (MLX5E_GET_PFLAG(params, MLX5E_PFLAG_TX_PORT_TS))
+ 		__set_bit(MLX5E_PTP_STATE_TX, c->state);
+ 
+ 	if (params->ptp_rx)
+ 		__set_bit(MLX5E_PTP_STATE_RX, c->state);
+ 
+ 	return bitmap_empty(c->state, MLX5E_PTP_STATE_NUM_STATES) ? -EINVAL : 0;
+ }
+ 
+ static void mlx5e_ptp_rx_unset_fs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_ptp_fs *ptp_fs = priv->fs.ptp_fs;
+ 
+ 	if (!ptp_fs->valid)
+ 		return;
+ 
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->l2_rule);
+ 	mlx5e_fs_tt_redirect_any_destroy(priv);
+ 
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v6_rule);
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v4_rule);
+ 	mlx5e_fs_tt_redirect_udp_destroy(priv);
+ 	ptp_fs->valid = false;
+ }
+ 
+ static int mlx5e_ptp_rx_set_fs(struct mlx5e_priv *priv)
+ {
+ 	u32 tirn = mlx5e_rx_res_get_tirn_ptp(priv->rx_res);
+ 	struct mlx5e_ptp_fs *ptp_fs = priv->fs.ptp_fs;
+ 	struct mlx5_flow_handle *rule;
+ 	int err;
+ 
+ 	if (ptp_fs->valid)
+ 		return 0;
+ 
+ 	err = mlx5e_fs_tt_redirect_udp_create(priv);
+ 	if (err)
+ 		goto out_free;
+ 
+ 	rule = mlx5e_fs_tt_redirect_udp_add_rule(priv, MLX5E_TT_IPV4_UDP,
+ 						 tirn, PTP_EV_PORT);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_fs_udp;
+ 	}
+ 	ptp_fs->udp_v4_rule = rule;
+ 
+ 	rule = mlx5e_fs_tt_redirect_udp_add_rule(priv, MLX5E_TT_IPV6_UDP,
+ 						 tirn, PTP_EV_PORT);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_udp_v4_rule;
+ 	}
+ 	ptp_fs->udp_v6_rule = rule;
+ 
+ 	err = mlx5e_fs_tt_redirect_any_create(priv);
+ 	if (err)
+ 		goto out_destroy_udp_v6_rule;
+ 
+ 	rule = mlx5e_fs_tt_redirect_any_add_rule(priv, tirn, ETH_P_1588);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_fs_any;
+ 	}
+ 	ptp_fs->l2_rule = rule;
+ 	ptp_fs->valid = true;
+ 
+ 	return 0;
+ 
+ out_destroy_fs_any:
+ 	mlx5e_fs_tt_redirect_any_destroy(priv);
+ out_destroy_udp_v6_rule:
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v6_rule);
+ out_destroy_udp_v4_rule:
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v4_rule);
+ out_destroy_fs_udp:
+ 	mlx5e_fs_tt_redirect_udp_destroy(priv);
+ out_free:
+ 	return err;
+ }
+ 
+ int mlx5e_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
+ 		   u8 lag_port, struct mlx5e_ptp **cp)
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  {
  	struct net_device *netdev = priv->netdev;
  	struct mlx5_core_dev *mdev = priv->mdev;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
index 313a708e351b,c06267477b27..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
@@@ -138,73 -183,3 +138,76 @@@ void mlx5e_deactivate_xsk(struct mlx5e_
  	mlx5e_deactivate_rq(&c->xskrq);
  	/* TX queue is disabled on close. */
  }
++<<<<<<< HEAD
 +
 +static int mlx5e_redirect_xsk_rqt(struct mlx5e_priv *priv, u16 ix, u32 rqn)
 +{
 +	struct mlx5e_redirect_rqt_param direct_rrp = {
 +		.is_rss = false,
 +		{
 +			.rqn = rqn,
 +		},
 +	};
 +
 +	u32 rqtn = priv->xsk_tir[ix].rqt.rqtn;
 +
 +	return mlx5e_redirect_rqt(priv, rqtn, 1, direct_rrp);
 +}
 +
 +int mlx5e_xsk_redirect_rqt_to_channel(struct mlx5e_priv *priv, struct mlx5e_channel *c)
 +{
 +	return mlx5e_redirect_xsk_rqt(priv, c->ix, c->xskrq.rqn);
 +}
 +
 +int mlx5e_xsk_redirect_rqt_to_drop(struct mlx5e_priv *priv, u16 ix)
 +{
 +	return mlx5e_redirect_xsk_rqt(priv, ix, priv->drop_rq.rqn);
 +}
 +
 +int mlx5e_xsk_redirect_rqts_to_channels(struct mlx5e_priv *priv, struct mlx5e_channels *chs)
 +{
 +	int err, i;
 +
 +	if (!priv->xsk.refcnt)
 +		return 0;
 +
 +	for (i = 0; i < chs->num; i++) {
 +		struct mlx5e_channel *c = chs->c[i];
 +
 +		if (!test_bit(MLX5E_CHANNEL_STATE_XSK, c->state))
 +			continue;
 +
 +		err = mlx5e_xsk_redirect_rqt_to_channel(priv, c);
 +		if (unlikely(err))
 +			goto err_stop;
 +	}
 +
 +	return 0;
 +
 +err_stop:
 +	for (i--; i >= 0; i--) {
 +		if (!test_bit(MLX5E_CHANNEL_STATE_XSK, chs->c[i]->state))
 +			continue;
 +
 +		mlx5e_xsk_redirect_rqt_to_drop(priv, i);
 +	}
 +
 +	return err;
 +}
 +
 +void mlx5e_xsk_redirect_rqts_to_drop(struct mlx5e_priv *priv, struct mlx5e_channels *chs)
 +{
 +	int i;
 +
 +	if (!priv->xsk.refcnt)
 +		return;
 +
 +	for (i = 0; i < chs->num; i++) {
 +		if (!test_bit(MLX5E_CHANNEL_STATE_XSK, chs->c[i]->state))
 +			continue;
 +
 +		mlx5e_xsk_redirect_rqt_to_drop(priv, i);
 +	}
 +}
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
index 1d166cb4f6f5,62abce008c7b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
@@@ -642,9 -628,9 +642,13 @@@ int mlx5e_ktls_add_rx(struct net_devic
  	priv_rx->sw_stats = &priv->tls->sw_stats;
  	mlx5e_set_ktls_rx_priv_ctx(tls_ctx, priv_rx);
  
++<<<<<<< HEAD
 +	rqtn = priv->direct_tir[rxq].rqt.rqtn;
++=======
+ 	rqtn = mlx5e_rx_res_get_rqtn_direct(priv->rx_res, rxq);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
 -	err = mlx5e_ktls_create_tir(mdev, &priv_rx->tir, rqtn);
 +	err = mlx5e_ktls_create_tir(mdev, &priv_rx->tirn, rqtn);
  	if (err)
  		goto err_create_tir;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 25403af32859,5077367f3ea0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@@ -209,7 -208,7 +209,11 @@@ static int arfs_add_default_rule(struc
  	/* FIXME: Must use mlx5e_ttc_get_default_dest(),
  	 * but can't since TTC default is not setup yet !
  	 */
++<<<<<<< HEAD
 +	dest.tir_num = tir[tt].tirn;
++=======
+ 	dest.tir_num = mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	arfs_t->default_rule = mlx5_add_flow_rules(arfs_t->ft.t, NULL,
  						   &flow_act,
  						   &dest, 1);
@@@ -553,7 -552,7 +557,11 @@@ static struct mlx5_flow_handle *arfs_ad
  		       16);
  	}
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
++<<<<<<< HEAD
 +	dest.tir_num = priv->direct_tir[arfs_rule->rxq].tirn;
++=======
+ 	dest.tir_num = mlx5e_rx_res_get_tirn_direct(priv->rx_res, arfs_rule->rxq);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	rule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
@@@ -576,7 -575,7 +584,11 @@@ static void arfs_modify_rule_rq(struct 
  	int err = 0;
  
  	dst.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
++<<<<<<< HEAD
 +	dst.tir_num = priv->direct_tir[rxq].tirn;
++=======
+ 	dst.tir_num = mlx5e_rx_res_get_tirn_direct(priv->rx_res, rxq);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	err =  mlx5_modify_rule_destination(rule, &dst, NULL);
  	if (err)
  		netdev_warn(priv->netdev,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,2cf59bb5f898..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -1192,7 -1172,7 +1192,11 @@@ static int mlx5e_set_link_ksettings(str
  
  u32 mlx5e_ethtool_get_rxfh_key_size(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	return sizeof(priv->rss_params.toeplitz_hash_key);
++=======
+ 	return sizeof_field(struct mlx5e_rss_params_hash, toeplitz_hash_key);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  static u32 mlx5e_get_rxfh_key_size(struct net_device *netdev)
@@@ -1218,18 -1198,10 +1222,25 @@@ int mlx5e_get_rxfh(struct net_device *n
  		   u8 *hfunc)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
++<<<<<<< HEAD
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +
 +	if (indir)
 +		memcpy(indir, rss->indirection_rqt,
 +		       sizeof(rss->indirection_rqt));
 +
 +	if (key)
 +		memcpy(key, rss->toeplitz_hash_key,
 +		       sizeof(rss->toeplitz_hash_key));
 +
 +	if (hfunc)
 +		*hfunc = rss->hfunc;
++=======
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	mlx5e_rx_res_rss_get_rxfh(priv->rx_res, indir, key, hfunc);
+ 	mutex_unlock(&priv->state_lock);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	return 0;
  }
@@@ -1238,64 -1210,13 +1249,75 @@@ int mlx5e_set_rxfh(struct net_device *d
  		   const u8 *key, const u8 hfunc)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +	int inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
 +	bool refresh_tirs = false;
 +	bool refresh_rqt = false;
 +	void *in;
 +
 +	if ((hfunc != ETH_RSS_HASH_NO_CHANGE) &&
 +	    (hfunc != ETH_RSS_HASH_XOR) &&
 +	    (hfunc != ETH_RSS_HASH_TOP))
 +		return -EINVAL;
++=======
+ 	int err;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
 +
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
  
  	mutex_lock(&priv->state_lock);
++<<<<<<< HEAD
 +
 +	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hfunc) {
 +		rss->hfunc = hfunc;
 +		refresh_rqt = true;
 +		refresh_tirs = true;
 +	}
 +
 +	if (indir) {
 +		memcpy(rss->indirection_rqt, indir,
 +		       sizeof(rss->indirection_rqt));
 +		refresh_rqt = true;
 +	}
 +
 +	if (key) {
 +		memcpy(rss->toeplitz_hash_key, key,
 +		       sizeof(rss->toeplitz_hash_key));
 +		refresh_tirs = refresh_tirs || rss->hfunc == ETH_RSS_HASH_TOP;
 +	}
 +
 +	if (refresh_rqt && test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_redirect_rqt_param rrp = {
 +			.is_rss = true,
 +			{
 +				.rss = {
 +					.hfunc = rss->hfunc,
 +					.channels  = &priv->channels,
 +				},
 +			},
 +		};
 +		u32 rqtn = priv->indir_rqt.rqtn;
 +
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
 +	}
 +
 +	if (refresh_tirs)
 +		mlx5e_modify_tirs_hash(priv, in);
 +
 +	mutex_unlock(&priv->state_lock);
 +
 +	kvfree(in);
 +
 +	return 0;
++=======
+ 	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, indir, key,
+ 					hfunc == ETH_RSS_HASH_NO_CHANGE ? NULL : &hfunc);
+ 	mutex_unlock(&priv->state_lock);
+ 	return err;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  #define MLX5E_PFC_PREVEN_AUTO_TOUT_MSEC		100
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 059efb0721cd,776f73cb592b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -1296,7 -1320,7 +1296,11 @@@ err
  void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv,
  				struct ttc_params *ttc_params)
  {
++<<<<<<< HEAD
 +	ttc_params->any_tt_tirn = priv->direct_tir[0].tirn;
++=======
+ 	ttc_params->any_tt_tirn = mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	ttc_params->inner_ttc = &priv->fs.inner_ttc;
  }
  
@@@ -1755,7 -1786,8 +1759,12 @@@ int mlx5e_create_flow_steering(struct m
  	if (mlx5e_tunnel_inner_ft_supported(priv->mdev)) {
  		mlx5e_set_inner_ttc_ft_params(&ttc_params);
  		for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
++<<<<<<< HEAD
 +			ttc_params.indir_tirn[tt] = priv->inner_indir_tir[tt].tirn;
++=======
+ 			ttc_params.indir_tirn[tt] =
+ 				mlx5e_rx_res_get_tirn_rss_inner(priv->rx_res, tt);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  		err = mlx5e_create_inner_ttc_table(priv, &ttc_params, &priv->fs.inner_ttc);
  		if (err) {
@@@ -1767,7 -1799,7 +1776,11 @@@
  
  	mlx5e_set_ttc_ft_params(&ttc_params);
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
++<<<<<<< HEAD
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
++=======
+ 		ttc_params.indir_tirn[tt] = mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
  	if (err) {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
index b416a8ee2eed,c057f830a15d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
@@@ -434,7 -432,10 +434,14 @@@ add_ethtool_flow_rule(struct mlx5e_pri
  		}
  
  		dst->type = MLX5_FLOW_DESTINATION_TYPE_TIR;
++<<<<<<< HEAD
 +		dst->tir_num = tir[ix].tirn;
++=======
+ 		if (group == MLX5E_RQ_GROUP_XSK)
+ 			dst->tir_num = mlx5e_rx_res_get_tirn_xsk(priv->rx_res, ix);
+ 		else
+ 			dst->tir_num = mlx5e_rx_res_get_tirn_direct(priv->rx_res, ix);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  		flow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
  	}
  
@@@ -816,10 -817,9 +823,14 @@@ static enum mlx5e_traffic_types flow_ty
  static int mlx5e_set_rss_hash_opt(struct mlx5e_priv *priv,
  				  struct ethtool_rxnfc *nfc)
  {
 +	int inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
  	enum mlx5e_traffic_types tt;
  	u8 rx_hash_field = 0;
++<<<<<<< HEAD
 +	void *in;
++=======
+ 	int err;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	tt = flow_type_to_traffic_type(nfc->flow_type);
  	if (tt == MLX5E_NUM_INDIR_TIRS)
@@@ -848,22 -848,11 +859,29 @@@
  	if (nfc->data & RXH_L4_B_2_3)
  		rx_hash_field |= MLX5_HASH_FIELD_SEL_L4_DPORT;
  
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
  	mutex_lock(&priv->state_lock);
++<<<<<<< HEAD
 +
 +	if (rx_hash_field == priv->rss_params.rx_hash_fields[tt])
 +		goto out;
 +
 +	priv->rss_params.rx_hash_fields[tt] = rx_hash_field;
 +	mlx5e_modify_tirs_hash(priv, in);
 +
 +out:
 +	mutex_unlock(&priv->state_lock);
 +	kvfree(in);
 +	return 0;
++=======
+ 	err = mlx5e_rx_res_rss_set_hash_fields(priv->rx_res, tt, rx_hash_field);
+ 	mutex_unlock(&priv->state_lock);
+ 
+ 	return err;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  static int mlx5e_get_rss_hash_opt(struct mlx5e_priv *priv,
@@@ -876,7 -865,7 +894,11 @@@
  	if (tt == MLX5E_NUM_INDIR_TIRS)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	hash_field = priv->rss_params.rx_hash_fields[tt];
++=======
+ 	hash_field = mlx5e_rx_res_rss_get_hash_fields(priv->rx_res, tt);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	nfc->data = 0;
  
  	if (hash_field & MLX5_HASH_FIELD_SEL_SRC_IP)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 15e30d82e985,6797328e0afd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2180,391 -2194,14 +2180,402 @@@ void mlx5e_close_channels(struct mlx5e_
  	chs->num = 0;
  }
  
++<<<<<<< HEAD
 +static int
 +mlx5e_create_rqt(struct mlx5e_priv *priv, int sz, struct mlx5e_rqt *rqt)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	int inlen;
 +	int err;
 +	u32 *in;
 +	int i;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(rqtc, rqtc, rqt_max_size, sz);
 +
 +	for (i = 0; i < sz; i++)
 +		MLX5_SET(rqtc, rqtc, rq_num[i], priv->drop_rq.rqn);
 +
 +	err = mlx5_core_create_rqt(mdev, in, inlen, &rqt->rqtn);
 +	if (!err)
 +		rqt->enabled = true;
 +
 +	kvfree(in);
 +	return err;
 +}
 +
 +void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt)
 +{
 +	rqt->enabled = false;
 +	mlx5_core_destroy_rqt(priv->mdev, rqt->rqtn);
 +}
 +
 +int mlx5e_create_indirect_rqt(struct mlx5e_priv *priv)
 +{
 +	struct mlx5e_rqt *rqt = &priv->indir_rqt;
 +	int err;
 +
 +	err = mlx5e_create_rqt(priv, MLX5E_INDIR_RQT_SIZE, rqt);
 +	if (err)
 +		mlx5_core_warn(priv->mdev, "create indirect rqts failed, %d\n", err);
 +	return err;
 +}
 +
 +int mlx5e_create_direct_rqts(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
 +{
 +	int err;
 +	int ix;
 +
 +	for (ix = 0; ix < n; ix++) {
 +		err = mlx5e_create_rqt(priv, 1 /*size */, &tirs[ix].rqt);
 +		if (unlikely(err))
 +			goto err_destroy_rqts;
 +	}
 +
 +	return 0;
 +
 +err_destroy_rqts:
 +	mlx5_core_warn(priv->mdev, "create rqts failed, %d\n", err);
 +	for (ix--; ix >= 0; ix--)
 +		mlx5e_destroy_rqt(priv, &tirs[ix].rqt);
 +
 +	return err;
 +}
 +
 +void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
 +{
 +	int i;
 +
 +	for (i = 0; i < n; i++)
 +		mlx5e_destroy_rqt(priv, &tirs[i].rqt);
 +}
 +
 +static int mlx5e_rx_hash_fn(int hfunc)
 +{
 +	return (hfunc == ETH_RSS_HASH_TOP) ?
 +	       MLX5_RX_HASH_FN_TOEPLITZ :
 +	       MLX5_RX_HASH_FN_INVERTED_XOR8;
 +}
 +
 +int mlx5e_bits_invert(unsigned long a, int size)
 +{
 +	int inv = 0;
 +	int i;
 +
 +	for (i = 0; i < size; i++)
 +		inv |= (test_bit(size - i - 1, &a) ? 1 : 0) << i;
 +
 +	return inv;
 +}
 +
 +static void mlx5e_fill_rqt_rqns(struct mlx5e_priv *priv, int sz,
 +				struct mlx5e_redirect_rqt_param rrp, void *rqtc)
 +{
 +	int i;
 +
 +	for (i = 0; i < sz; i++) {
 +		u32 rqn;
 +
 +		if (rrp.is_rss) {
 +			int ix = i;
 +
 +			if (rrp.rss.hfunc == ETH_RSS_HASH_XOR)
 +				ix = mlx5e_bits_invert(i, ilog2(sz));
 +
 +			ix = priv->rss_params.indirection_rqt[ix];
 +			rqn = rrp.rss.channels->c[ix]->rq.rqn;
 +		} else {
 +			rqn = rrp.rqn;
 +		}
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
 +}
 +
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	int inlen;
 +	u32 *in;
 +	int err;
 +
 +	inlen = MLX5_ST_SZ_BYTES(modify_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(modify_rqt_in, in, ctx);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(modify_rqt_in, in, bitmask.rqn_list, 1);
 +	mlx5e_fill_rqt_rqns(priv, sz, rrp, rqtc);
 +	err = mlx5_core_modify_rqt(mdev, rqtn, in, inlen);
 +
 +	kvfree(in);
 +	return err;
 +}
 +
 +static u32 mlx5e_get_direct_rqn(struct mlx5e_priv *priv, int ix,
 +				struct mlx5e_redirect_rqt_param rrp)
 +{
 +	if (!rrp.is_rss)
 +		return rrp.rqn;
 +
 +	if (ix >= rrp.rss.channels->num)
 +		return priv->drop_rq.rqn;
 +
 +	return rrp.rss.channels->c[ix]->rq.rqn;
 +}
 +
 +static void mlx5e_redirect_rqts(struct mlx5e_priv *priv,
 +				struct mlx5e_redirect_rqt_param rrp)
 +{
 +	u32 rqtn;
 +	int ix;
 +
 +	if (priv->indir_rqt.enabled) {
 +		/* RSS RQ table */
 +		rqtn = priv->indir_rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
 +	}
 +
 +	for (ix = 0; ix < priv->max_nch; ix++) {
 +		struct mlx5e_redirect_rqt_param direct_rrp = {
 +			.is_rss = false,
 +			{
 +				.rqn    = mlx5e_get_direct_rqn(priv, ix, rrp)
 +			},
 +		};
 +
 +		/* Direct RQ Tables */
 +		if (!priv->direct_tir[ix].rqt.enabled)
 +			continue;
 +
 +		rqtn = priv->direct_tir[ix].rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, 1, direct_rrp);
 +	}
 +}
 +
 +static void mlx5e_redirect_rqts_to_channels(struct mlx5e_priv *priv,
 +					    struct mlx5e_channels *chs)
 +{
 +	struct mlx5e_redirect_rqt_param rrp = {
 +		.is_rss        = true,
 +		{
 +			.rss = {
 +				.channels  = chs,
 +				.hfunc     = priv->rss_params.hfunc,
 +			}
 +		},
 +	};
 +
 +	mlx5e_redirect_rqts(priv, rrp);
 +}
 +
 +static void mlx5e_redirect_rqts_to_drop(struct mlx5e_priv *priv)
 +{
 +	struct mlx5e_redirect_rqt_param drop_rrp = {
 +		.is_rss = false,
 +		{
 +			.rqn = priv->drop_rq.rqn,
 +		},
 +	};
 +
 +	mlx5e_redirect_rqts(priv, drop_rrp);
 +}
 +
 +static const struct mlx5e_tirc_config tirc_default_config[MLX5E_NUM_INDIR_TIRS] = {
 +	[MLX5E_TT_IPV4_TCP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV6_TCP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV4_UDP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV6_UDP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_AH] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				     .l4_prot_type = 0,
 +				     .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_AH] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				     .l4_prot_type = 0,
 +				     .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_ESP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				      .l4_prot_type = 0,
 +				      .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_ESP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				      .l4_prot_type = 0,
 +				      .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV4] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +			    .l4_prot_type = 0,
 +			    .rx_hash_fields = MLX5_HASH_IP,
 +	},
 +	[MLX5E_TT_IPV6] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +			    .l4_prot_type = 0,
 +			    .rx_hash_fields = MLX5_HASH_IP,
 +	},
 +};
 +
 +struct mlx5e_tirc_config mlx5e_tirc_get_default_config(enum mlx5e_traffic_types tt)
 +{
 +	return tirc_default_config[tt];
 +}
 +
 +static void mlx5e_build_tir_ctx_lro(struct mlx5e_params *params, void *tirc)
 +{
 +	if (!params->lro_en)
 +		return;
 +
 +#define ROUGH_MAX_L2_L3_HDR_SZ 256
 +
 +	MLX5_SET(tirc, tirc, lro_enable_mask,
 +		 MLX5_TIRC_LRO_ENABLE_MASK_IPV4_LRO |
 +		 MLX5_TIRC_LRO_ENABLE_MASK_IPV6_LRO);
 +	MLX5_SET(tirc, tirc, lro_max_ip_payload_size,
 +		 (MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ - ROUGH_MAX_L2_L3_HDR_SZ) >> 8);
 +	MLX5_SET(tirc, tirc, lro_timeout_period_usecs, params->lro_timeout);
 +}
 +
 +void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_rss_params *rss_params,
 +				    const struct mlx5e_tirc_config *ttconfig,
 +				    void *tirc, bool inner)
 +{
 +	void *hfso = inner ? MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner) :
 +			     MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);
 +
 +	MLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_rx_hash_fn(rss_params->hfunc));
 +	if (rss_params->hfunc == ETH_RSS_HASH_TOP) {
 +		void *rss_key = MLX5_ADDR_OF(tirc, tirc,
 +					     rx_hash_toeplitz_key);
 +		size_t len = MLX5_FLD_SZ_BYTES(tirc,
 +					       rx_hash_toeplitz_key);
 +
 +		MLX5_SET(tirc, tirc, rx_hash_symmetric, 1);
 +		memcpy(rss_key, rss_params->toeplitz_hash_key, len);
 +	}
 +	MLX5_SET(rx_hash_field_select, hfso, l3_prot_type,
 +		 ttconfig->l3_prot_type);
 +	MLX5_SET(rx_hash_field_select, hfso, l4_prot_type,
 +		 ttconfig->l4_prot_type);
 +	MLX5_SET(rx_hash_field_select, hfso, selected_fields,
 +		 ttconfig->rx_hash_fields);
 +}
 +
 +static void mlx5e_update_rx_hash_fields(struct mlx5e_tirc_config *ttconfig,
 +					enum mlx5e_traffic_types tt,
 +					u32 rx_hash_fields)
 +{
 +	*ttconfig                = tirc_default_config[tt];
 +	ttconfig->rx_hash_fields = rx_hash_fields;
 +}
 +
 +void mlx5e_modify_tirs_hash(struct mlx5e_priv *priv, void *in)
 +{
 +	void *tirc = MLX5_ADDR_OF(modify_tir_in, in, ctx);
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	int ctxlen = MLX5_ST_SZ_BYTES(tirc);
 +	struct mlx5e_tirc_config ttconfig;
 +	int tt;
 +
 +	MLX5_SET(modify_tir_in, in, bitmask.hash, 1);
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		memset(tirc, 0, ctxlen);
 +		mlx5e_update_rx_hash_fields(&ttconfig, tt,
 +					    rss->rx_hash_fields[tt]);
 +		mlx5e_build_indir_tir_ctx_hash(rss, &ttconfig, tirc, false);
 +		mlx5_core_modify_tir(mdev, priv->indir_tir[tt].tirn, in);
 +	}
 +
 +	/* Verify inner tirs resources allocated */
 +	if (!priv->inner_indir_tir[0].tirn)
 +		return;
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		memset(tirc, 0, ctxlen);
 +		mlx5e_update_rx_hash_fields(&ttconfig, tt,
 +					    rss->rx_hash_fields[tt]);
 +		mlx5e_build_indir_tir_ctx_hash(rss, &ttconfig, tirc, true);
 +		mlx5_core_modify_tir(mdev, priv->inner_indir_tir[tt].tirn, in);
 +	}
 +}
 +
 +static int mlx5e_modify_tirs_lro(struct mlx5e_priv *priv)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
 +	void *in;
 +	void *tirc;
 +	int inlen;
 +	int err;
 +	int tt;
 +	int ix;
 +
 +	inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	MLX5_SET(modify_tir_in, in, bitmask.lro, 1);
 +	tirc = MLX5_ADDR_OF(modify_tir_in, in, ctx);
 +
 +	mlx5e_build_tir_ctx_lro(&priv->channels.params, tirc);
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		err = mlx5_core_modify_tir(mdev, priv->indir_tir[tt].tirn, in);
 +		if (err)
 +			goto free_in;
 +
 +		/* Verify inner tirs resources allocated */
 +		if (!priv->inner_indir_tir[0].tirn)
 +			continue;
 +
 +		err = mlx5_core_modify_tir(mdev, priv->inner_indir_tir[tt].tirn, in);
 +		if (err)
 +			goto free_in;
 +	}
 +
 +	for (ix = 0; ix < priv->max_nch; ix++) {
 +		err = mlx5_core_modify_tir(mdev, priv->direct_tir[ix].tirn, in);
 +		if (err)
 +			goto free_in;
 +	}
 +
 +free_in:
 +	kvfree(in);
 +
 +	return err;
++=======
+ static int mlx5e_modify_tirs_lro(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	struct mlx5e_lro_param lro_param;
+ 
+ 	lro_param = mlx5e_get_lro_param(&priv->channels.params);
+ 
+ 	return mlx5e_rx_res_lro_set_param(res, &lro_param);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  static MLX5E_DEFINE_PREACTIVATE_WRAPPER_CTX(mlx5e_modify_tirs_lro);
@@@ -2745,9 -2382,9 +2756,15 @@@ int mlx5e_num_channels_changed(struct m
  
  	mlx5e_set_default_xps_cpumasks(priv, &priv->channels.params);
  
++<<<<<<< HEAD
 +	if (!netif_is_rxfh_configured(priv->netdev))
 +		mlx5e_build_default_indir_rqt(priv->rss_params.indirection_rqt,
 +					      MLX5E_INDIR_RQT_SIZE, count);
++=======
+ 	/* This function may be called on attach, before priv->rx_res is created. */
+ 	if (!netif_is_rxfh_configured(priv->netdev) && priv->rx_res)
+ 		mlx5e_rx_res_rss_set_indir_uniform(priv->rx_res, count);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	return 0;
  }
@@@ -2803,16 -2443,15 +2820,26 @@@ void mlx5e_activate_priv_channels(struc
  		mlx5e_add_sqs_fwd_rules(priv);
  
  	mlx5e_wait_channels_min_rx_wqes(&priv->channels);
 +	mlx5e_redirect_rqts_to_channels(priv, &priv->channels);
  
++<<<<<<< HEAD
 +	mlx5e_xsk_redirect_rqts_to_channels(priv, &priv->channels);
++=======
+ 	if (priv->rx_res)
+ 		mlx5e_rx_res_channels_activate(priv->rx_res, &priv->channels);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  void mlx5e_deactivate_priv_channels(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	mlx5e_xsk_redirect_rqts_to_drop(priv, &priv->channels);
 +
 +	mlx5e_redirect_rqts_to_drop(priv);
++=======
+ 	if (priv->rx_res)
+ 		mlx5e_rx_res_channels_deactivate(priv->rx_res);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	if (mlx5e_is_vport_rep(priv))
  		mlx5e_remove_sqs_fwd_rules(priv);
@@@ -3182,161 -2826,6 +3209,164 @@@ static void mlx5e_cleanup_nic_tx(struc
  	mlx5e_destroy_tises(priv);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_build_indir_tir_ctx_common(struct mlx5e_priv *priv,
 +					     u32 rqtn, u32 *tirc)
 +{
 +	MLX5_SET(tirc, tirc, transport_domain, priv->mdev->mlx5e_res.hw_objs.td.tdn);
 +	MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +	MLX5_SET(tirc, tirc, indirect_table, rqtn);
 +	MLX5_SET(tirc, tirc, tunneled_offload_en,
 +		 priv->channels.params.tunneled_offload_en);
 +
 +	mlx5e_build_tir_ctx_lro(&priv->channels.params, tirc);
 +}
 +
 +static void mlx5e_build_indir_tir_ctx(struct mlx5e_priv *priv,
 +				      enum mlx5e_traffic_types tt,
 +				      u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, priv->indir_rqt.rqtn, tirc);
 +	mlx5e_build_indir_tir_ctx_hash(&priv->rss_params,
 +				       &tirc_default_config[tt], tirc, false);
 +}
 +
 +static void mlx5e_build_direct_tir_ctx(struct mlx5e_priv *priv, u32 rqtn, u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, rqtn, tirc);
 +	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_INVERTED_XOR8);
 +}
 +
 +static void mlx5e_build_inner_indir_tir_ctx(struct mlx5e_priv *priv,
 +					    enum mlx5e_traffic_types tt,
 +					    u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, priv->indir_rqt.rqtn, tirc);
 +	mlx5e_build_indir_tir_ctx_hash(&priv->rss_params,
 +				       &tirc_default_config[tt], tirc, true);
 +}
 +
 +int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv, bool inner_ttc)
 +{
 +	struct mlx5e_tir *tir;
 +	void *tirc;
 +	int inlen;
 +	int i = 0;
 +	int err;
 +	u32 *in;
 +	int tt;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		memset(in, 0, inlen);
 +		tir = &priv->indir_tir[tt];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_indir_tir_ctx(priv, tt, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
 +		if (err) {
 +			mlx5_core_warn(priv->mdev, "create indirect tirs failed, %d\n", err);
 +			goto err_destroy_inner_tirs;
 +		}
 +	}
 +
 +	if (!inner_ttc || !mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		goto out;
 +
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++) {
 +		memset(in, 0, inlen);
 +		tir = &priv->inner_indir_tir[i];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_inner_indir_tir_ctx(priv, i, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
 +		if (err) {
 +			mlx5_core_warn(priv->mdev, "create inner indirect tirs failed, %d\n", err);
 +			goto err_destroy_inner_tirs;
 +		}
 +	}
 +
 +out:
 +	kvfree(in);
 +
 +	return 0;
 +
 +err_destroy_inner_tirs:
 +	for (i--; i >= 0; i--)
 +		mlx5e_destroy_tir(priv->mdev, &priv->inner_indir_tir[i]);
 +
 +	for (tt--; tt >= 0; tt--)
 +		mlx5e_destroy_tir(priv->mdev, &priv->indir_tir[tt]);
 +
 +	kvfree(in);
 +
 +	return err;
 +}
 +
 +int mlx5e_create_direct_tirs(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
 +{
 +	struct mlx5e_tir *tir;
 +	void *tirc;
 +	int inlen;
 +	int err = 0;
 +	u32 *in;
 +	int ix;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	for (ix = 0; ix < n; ix++) {
 +		memset(in, 0, inlen);
 +		tir = &tirs[ix];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_direct_tir_ctx(priv, tir->rqt.rqtn, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
 +		if (unlikely(err))
 +			goto err_destroy_ch_tirs;
 +	}
 +
 +	goto out;
 +
 +err_destroy_ch_tirs:
 +	mlx5_core_warn(priv->mdev, "create tirs failed, %d\n", err);
 +	for (ix--; ix >= 0; ix--)
 +		mlx5e_destroy_tir(priv->mdev, &tirs[ix]);
 +
 +out:
 +	kvfree(in);
 +
 +	return err;
 +}
 +
 +void mlx5e_destroy_indirect_tirs(struct mlx5e_priv *priv)
 +{
 +	int i;
 +
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++)
 +		mlx5e_destroy_tir(priv->mdev, &priv->indir_tir[i]);
 +
 +	/* Verify inner tirs resources allocated */
 +	if (!priv->inner_indir_tir[0].tirn)
 +		return;
 +
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++)
 +		mlx5e_destroy_tir(priv->mdev, &priv->inner_indir_tir[i]);
 +}
 +
 +void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
 +{
 +	int i;
 +
 +	for (i = 0; i < n; i++)
 +		mlx5e_destroy_tir(priv->mdev, &tirs[i]);
 +}
 +
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  static int mlx5e_modify_channels_scatter_fcs(struct mlx5e_channels *chs, bool enable)
  {
  	int err = 0;
@@@ -4654,21 -4090,6 +4684,24 @@@ static u32 mlx5e_choose_lro_timeout(str
  	return MLX5_CAP_ETH(mdev, lro_timer_supported_periods[i]);
  }
  
++<<<<<<< HEAD
 +void mlx5e_build_rss_params(struct mlx5e_rss_params *rss_params,
 +			    u16 num_channels)
 +{
 +	enum mlx5e_traffic_types tt;
 +
 +	rss_params->hfunc = ETH_RSS_HASH_TOP;
 +	netdev_rss_key_fill(rss_params->toeplitz_hash_key,
 +			    sizeof(rss_params->toeplitz_hash_key));
 +	mlx5e_build_default_indir_rqt(rss_params->indirection_rqt,
 +				      MLX5E_INDIR_RQT_SIZE, num_channels);
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		rss_params->rx_hash_fields[tt] =
 +			tirc_default_config[tt].rx_hash_fields;
 +}
 +
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  void mlx5e_build_nic_params(struct mlx5e_priv *priv, struct mlx5e_xsk *xsk, u16 mtu)
  {
  	struct mlx5e_params *params = &priv->channels.params;
@@@ -4999,10 -4414,13 +5032,20 @@@ static void mlx5e_nic_cleanup(struct ml
  static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
++<<<<<<< HEAD
 +	u16 max_nch = priv->max_nch;
 +	int err;
 +
 +	mlx5e_build_rss_params(&priv->rss_params, priv->channels.params.num_channels);
++=======
+ 	enum mlx5e_rx_res_features features;
+ 	struct mlx5e_lro_param lro_param;
+ 	int err;
+ 
+ 	priv->rx_res = mlx5e_rx_res_alloc();
+ 	if (!priv->rx_res)
+ 		return -ENOMEM;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	mlx5e_create_q_counters(priv);
  
@@@ -5016,30 -4440,10 +5065,37 @@@
  	if (err)
  		goto err_close_drop_rq;
  
++<<<<<<< HEAD
 +	err = mlx5e_create_direct_rqts(priv, priv->direct_tir, max_nch);
 +	if (err)
 +		goto err_destroy_indirect_rqts;
 +
 +	err = mlx5e_create_indirect_tirs(priv, true);
 +	if (err)
 +		goto err_destroy_direct_rqts;
 +
 +	err = mlx5e_create_direct_tirs(priv, priv->direct_tir, max_nch);
 +	if (err)
 +		goto err_destroy_indirect_tirs;
 +
 +	err = mlx5e_create_direct_rqts(priv, priv->xsk_tir, max_nch);
 +	if (unlikely(err))
 +		goto err_destroy_direct_tirs;
 +
 +	err = mlx5e_create_direct_tirs(priv, priv->xsk_tir, max_nch);
 +	if (unlikely(err))
 +		goto err_destroy_xsk_rqts;
 +
 +	err = mlx5e_create_flow_steering(priv);
 +	if (err) {
 +		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
 +		goto err_destroy_xsk_tirs;
++=======
+ 	err = mlx5e_create_flow_steering(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
+ 		goto err_destroy_rx_res;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	}
  
  	err = mlx5e_tc_nic_init(priv);
@@@ -5060,22 -4464,14 +5116,32 @@@ err_tc_nic_cleanup
  	mlx5e_tc_nic_cleanup(priv);
  err_destroy_flow_steering:
  	mlx5e_destroy_flow_steering(priv);
++<<<<<<< HEAD
 +err_destroy_xsk_tirs:
 +	mlx5e_destroy_direct_tirs(priv, priv->xsk_tir, max_nch);
 +err_destroy_xsk_rqts:
 +	mlx5e_destroy_direct_rqts(priv, priv->xsk_tir, max_nch);
 +err_destroy_direct_tirs:
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_tirs:
 +	mlx5e_destroy_indirect_tirs(priv);
 +err_destroy_direct_rqts:
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_rqts:
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ err_destroy_rx_res:
+ 	mlx5e_rx_res_destroy(priv->rx_res);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
  err_destroy_q_counters:
  	mlx5e_destroy_q_counters(priv);
++<<<<<<< HEAD
++=======
+ 	mlx5e_rx_res_free(priv->rx_res);
+ 	priv->rx_res = NULL;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	return err;
  }
  
@@@ -5086,14 -4480,11 +5152,22 @@@ static void mlx5e_cleanup_nic_rx(struc
  	mlx5e_accel_cleanup_rx(priv);
  	mlx5e_tc_nic_cleanup(priv);
  	mlx5e_destroy_flow_steering(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_tirs(priv, priv->xsk_tir, max_nch);
 +	mlx5e_destroy_direct_rqts(priv, priv->xsk_tir, max_nch);
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_indirect_tirs(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
 +	mlx5e_close_drop_rq(&priv->drop_rq);
 +	mlx5e_destroy_q_counters(priv);
++=======
+ 	mlx5e_rx_res_destroy(priv->rx_res);
+ 	mlx5e_close_drop_rq(&priv->drop_rq);
+ 	mlx5e_destroy_q_counters(priv);
+ 	mlx5e_rx_res_free(priv->rx_res);
+ 	priv->rx_res = NULL;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 98da6dcc9ee9,f6e96b7d4698..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -657,7 -655,7 +657,11 @@@ static int mlx5e_create_rep_ttc_table(s
  					      MLX5_FLOW_NAMESPACE_KERNEL);
  
  	/* The inner_ttc in the ttc params is intentionally not set */
++<<<<<<< HEAD
 +	ttc_params.any_tt_tirn = priv->direct_tir[0].tirn;
++=======
+ 	ttc_params.any_tt_tirn = mlx5e_rx_res_get_tirn_direct(res, 0);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	mlx5e_set_ttc_ft_params(&ttc_params);
  
  	if (rep->vport != MLX5_VPORT_UPLINK)
@@@ -665,7 -663,7 +669,11 @@@
  		ttc_params.ft_attr.level = MLX5E_TTC_FT_LEVEL + 1;
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
++<<<<<<< HEAD
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
++=======
+ 		ttc_params.indir_tirn[tt] = mlx5e_rx_res_get_tirn_rss(res, tt);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
  	if (err) {
@@@ -761,10 -758,12 +769,19 @@@ int mlx5e_rep_bond_update(struct mlx5e_
  static int mlx5e_init_rep_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
++<<<<<<< HEAD
 +	u16 max_nch = priv->max_nch;
 +	int err;
 +
 +	mlx5e_build_rss_params(&priv->rss_params, priv->channels.params.num_channels);
++=======
+ 	struct mlx5e_lro_param lro_param;
+ 	int err;
+ 
+ 	priv->rx_res = mlx5e_rx_res_alloc();
+ 	if (!priv->rx_res)
+ 		return -ENOMEM;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	mlx5e_init_l2_addr(priv);
  
@@@ -778,21 -780,9 +798,24 @@@
  	if (err)
  		goto err_close_drop_rq;
  
++<<<<<<< HEAD
 +	err = mlx5e_create_direct_rqts(priv, priv->direct_tir, max_nch);
 +	if (err)
 +		goto err_destroy_indirect_rqts;
 +
 +	err = mlx5e_create_indirect_tirs(priv, false);
 +	if (err)
 +		goto err_destroy_direct_rqts;
 +
 +	err = mlx5e_create_direct_tirs(priv, priv->direct_tir, max_nch);
 +	if (err)
 +		goto err_destroy_indirect_tirs;
 +
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	err = mlx5e_create_rep_ttc_table(priv);
  	if (err)
- 		goto err_destroy_direct_tirs;
+ 		goto err_destroy_rx_res;
  
  	err = mlx5e_create_rep_root_ft(priv);
  	if (err)
@@@ -810,16 -800,12 +833,25 @@@ err_destroy_root_ft
  	mlx5e_destroy_rep_root_ft(priv);
  err_destroy_ttc_table:
  	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
++<<<<<<< HEAD
 +err_destroy_direct_tirs:
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_tirs:
 +	mlx5e_destroy_indirect_tirs(priv);
 +err_destroy_direct_rqts:
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_rqts:
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
 +err_close_drop_rq:
 +	mlx5e_close_drop_rq(&priv->drop_rq);
++=======
+ err_destroy_rx_res:
+ 	mlx5e_rx_res_destroy(priv->rx_res);
+ err_close_drop_rq:
+ 	mlx5e_close_drop_rq(&priv->drop_rq);
+ 	mlx5e_rx_res_free(priv->rx_res);
+ 	priv->rx_res = NULL;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	return err;
  }
  
@@@ -831,11 -815,10 +863,18 @@@ static void mlx5e_cleanup_rep_rx(struc
  	rep_vport_rx_rule_destroy(priv);
  	mlx5e_destroy_rep_root_ft(priv);
  	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_indirect_tirs(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
 +	mlx5e_close_drop_rq(&priv->drop_rq);
++=======
+ 	mlx5e_rx_res_destroy(priv->rx_res);
+ 	mlx5e_close_drop_rq(&priv->drop_rq);
+ 	mlx5e_rx_res_free(priv->rx_res);
+ 	priv->rx_res = NULL;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  static int mlx5e_init_ul_rep_rx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,04687ffaeffa..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -516,83 -514,51 +516,110 @@@ static void mlx5e_hairpin_destroy_trans
  	mlx5_core_dealloc_transport_domain(hp->func_mdev, hp->tdn);
  }
  
 +static int mlx5e_hairpin_fill_rqt_rqns(struct mlx5e_hairpin *hp, void *rqtc)
 +{
 +	struct mlx5e_priv *priv = hp->func_priv;
 +	int i, ix, sz = MLX5E_INDIR_RQT_SIZE;
 +	u32 *indirection_rqt, rqn;
 +
 +	indirection_rqt = kcalloc(sz, sizeof(*indirection_rqt), GFP_KERNEL);
 +	if (!indirection_rqt)
 +		return -ENOMEM;
 +
 +	mlx5e_build_default_indir_rqt(indirection_rqt, sz,
 +				      hp->num_channels);
 +
 +	for (i = 0; i < sz; i++) {
 +		ix = i;
 +		if (priv->rss_params.hfunc == ETH_RSS_HASH_XOR)
 +			ix = mlx5e_bits_invert(i, ilog2(sz));
 +		ix = indirection_rqt[ix];
 +		rqn = hp->pair->rqn[ix];
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
 +
 +	kfree(indirection_rqt);
 +	return 0;
 +}
 +
  static int mlx5e_hairpin_create_indirect_rqt(struct mlx5e_hairpin *hp)
  {
 +	int inlen, err, sz = MLX5E_INDIR_RQT_SIZE;
  	struct mlx5e_priv *priv = hp->func_priv;
  	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_rss_params_indir *indir;
 -	int err;
 +	void *rqtc;
 +	u32 *in;
  
 -	indir = kvmalloc(sizeof(*indir), GFP_KERNEL);
 -	if (!indir)
 +	inlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	rqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);
++=======
+ 	mlx5e_rss_params_indir_init_uniform(indir, hp->num_channels);
+ 	err = mlx5e_rqt_init_indir(&hp->indir_rqt, mdev, hp->pair->rqn, hp->num_channels,
+ 				   mlx5e_rx_res_get_current_hash(priv->rx_res).hfunc,
+ 				   indir);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
 -	kvfree(indir);
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(rqtc, rqtc, rqt_max_size, sz);
 +
 +	err = mlx5e_hairpin_fill_rqt_rqns(hp, rqtc);
 +	if (err)
 +		goto out;
 +
 +	err = mlx5_core_create_rqt(mdev, in, inlen, &hp->indir_rqt.rqtn);
 +	if (!err)
 +		hp->indir_rqt.enabled = true;
 +
 +out:
 +	kvfree(in);
  	return err;
  }
  
  static int mlx5e_hairpin_create_indirect_tirs(struct mlx5e_hairpin *hp)
  {
  	struct mlx5e_priv *priv = hp->func_priv;
++<<<<<<< HEAD
 +	u32 in[MLX5_ST_SZ_DW(create_tir_in)];
 +	int tt, i, err;
 +	void *tirc;
++=======
+ 	struct mlx5e_rss_params_hash rss_hash;
+ 	enum mlx5e_traffic_types tt, max_tt;
+ 	struct mlx5e_tir_builder *builder;
+ 	int err = 0;
+ 
+ 	builder = mlx5e_tir_builder_alloc(false);
+ 	if (!builder)
+ 		return -ENOMEM;
+ 
+ 	rss_hash = mlx5e_rx_res_get_current_hash(priv->rx_res);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 -		struct mlx5e_rss_params_traffic_type rss_tt;
 +		struct mlx5e_tirc_config ttconfig = mlx5e_tirc_get_default_config(tt);
  
 -		rss_tt = mlx5e_rss_get_default_tt_config(tt);
 +		memset(in, 0, MLX5_ST_SZ_BYTES(create_tir_in));
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
  
++<<<<<<< HEAD
 +		MLX5_SET(tirc, tirc, transport_domain, hp->tdn);
 +		MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +		MLX5_SET(tirc, tirc, indirect_table, hp->indir_rqt.rqtn);
 +		mlx5e_build_indir_tir_ctx_hash(&priv->rss_params, &ttconfig, tirc, false);
++=======
+ 		mlx5e_tir_builder_build_rqt(builder, hp->tdn,
+ 					    mlx5e_rqt_get_rqtn(&hp->indir_rqt),
+ 					    false);
+ 		mlx5e_tir_builder_build_rss(builder, &rss_hash, &rss_tt, false);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
 -		err = mlx5e_tir_init(&hp->indir_tir[tt], builder, hp->func_mdev, false);
 +		err = mlx5_core_create_tir(hp->func_mdev, in,
 +					   &hp->indir_tirn[tt]);
  		if (err) {
  			mlx5_core_warn(hp->func_mdev, "create indirect tirs failed, %d\n", err);
  			goto err_destroy_tirs;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index f3988eec3041,1f118678ea9d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -339,7 -333,7 +339,11 @@@ static int mlx5i_create_flow_steering(s
  	mlx5e_set_ttc_basic_params(priv, &ttc_params);
  	mlx5e_set_ttc_ft_params(&ttc_params);
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
++<<<<<<< HEAD
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
++=======
+ 		ttc_params.indir_tirn[tt] = mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
  	if (err) {
@@@ -365,10 -359,12 +369,19 @@@ static void mlx5i_destroy_flow_steering
  static int mlx5i_init_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
++<<<<<<< HEAD
 +	u16 max_nch = priv->max_nch;
 +	int err;
 +
 +	mlx5e_build_rss_params(&priv->rss_params, priv->channels.params.num_channels);
++=======
+ 	struct mlx5e_lro_param lro_param;
+ 	int err;
+ 
+ 	priv->rx_res = mlx5e_rx_res_alloc();
+ 	if (!priv->rx_res)
+ 		return -ENOMEM;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  
  	mlx5e_create_q_counters(priv);
  
@@@ -382,50 -381,31 +398,71 @@@
  	if (err)
  		goto err_close_drop_rq;
  
++<<<<<<< HEAD
 +	err = mlx5e_create_direct_rqts(priv, priv->direct_tir, max_nch);
 +	if (err)
 +		goto err_destroy_indirect_rqts;
 +
 +	err = mlx5e_create_indirect_tirs(priv, false);
 +	if (err)
 +		goto err_destroy_direct_rqts;
 +
 +	err = mlx5e_create_direct_tirs(priv, priv->direct_tir, max_nch);
 +	if (err)
 +		goto err_destroy_indirect_tirs;
 +
++=======
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	err = mlx5i_create_flow_steering(priv);
  	if (err)
- 		goto err_destroy_direct_tirs;
+ 		goto err_destroy_rx_res;
  
  	return 0;
  
++<<<<<<< HEAD
 +err_destroy_direct_tirs:
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_tirs:
 +	mlx5e_destroy_indirect_tirs(priv);
 +err_destroy_direct_rqts:
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_rqts:
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ err_destroy_rx_res:
+ 	mlx5e_rx_res_destroy(priv->rx_res);
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
  err_destroy_q_counters:
  	mlx5e_destroy_q_counters(priv);
++<<<<<<< HEAD
++=======
+ 	mlx5e_rx_res_free(priv->rx_res);
+ 	priv->rx_res = NULL;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  	return err;
  }
  
  static void mlx5i_cleanup_rx(struct mlx5e_priv *priv)
  {
 +	u16 max_nch = priv->max_nch;
 +
  	mlx5i_destroy_flow_steering(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_indirect_tirs(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
 +	mlx5e_close_drop_rq(&priv->drop_rq);
 +	mlx5e_destroy_q_counters(priv);
++=======
+ 	mlx5e_rx_res_destroy(priv->rx_res);
+ 	mlx5e_close_drop_rq(&priv->drop_rq);
+ 	mlx5e_destroy_q_counters(priv);
+ 	mlx5e_rx_res_free(priv->rx_res);
+ 	priv->rx_res = NULL;
++>>>>>>> 43ec0f41fa73 (net/mlx5e: Hide all implementation details of mlx5e_rx_res)
  }
  
  /* The stats groups order is opposite to the update_stats() order calls */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/pool.c b/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/pool.c
index 3503e7711178..ad6cd265134c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/pool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/pool.c
@@ -122,7 +122,7 @@ static int mlx5e_xsk_enable_locked(struct mlx5e_priv *priv,
 	 * any Fill Ring entries at the setup stage.
 	 */
 
-	err = mlx5e_xsk_redirect_rqt_to_channel(priv, priv->channels.c[ix]);
+	err = mlx5e_rx_res_xsk_activate(priv->rx_res, &priv->channels, ix);
 	if (unlikely(err))
 		goto err_deactivate;
 
@@ -169,7 +169,7 @@ static int mlx5e_xsk_disable_locked(struct mlx5e_priv *priv, u16 ix)
 		goto remove_pool;
 
 	c = priv->channels.c[ix];
-	mlx5e_xsk_redirect_rqt_to_drop(priv, ix);
+	mlx5e_rx_res_xsk_deactivate(priv->rx_res, ix);
 	mlx5e_deactivate_xsk(c);
 	mlx5e_close_xsk(c);
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.h b/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.h
index ca20f1ff5e39..50e111b85efd 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.h
@@ -17,9 +17,5 @@ int mlx5e_open_xsk(struct mlx5e_priv *priv, struct mlx5e_params *params,
 void mlx5e_close_xsk(struct mlx5e_channel *c);
 void mlx5e_activate_xsk(struct mlx5e_channel *c);
 void mlx5e_deactivate_xsk(struct mlx5e_channel *c);
-int mlx5e_xsk_redirect_rqt_to_channel(struct mlx5e_priv *priv, struct mlx5e_channel *c);
-int mlx5e_xsk_redirect_rqt_to_drop(struct mlx5e_priv *priv, u16 ix);
-int mlx5e_xsk_redirect_rqts_to_channels(struct mlx5e_priv *priv, struct mlx5e_channels *chs);
-void mlx5e_xsk_redirect_rqts_to_drop(struct mlx5e_priv *priv, struct mlx5e_channels *chs);
 
 #endif /* __MLX5_EN_XSK_SETUP_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
