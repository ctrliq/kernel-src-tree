net/mlx5e: Move management of indir traffic types to rx_res

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Maxim Mikityanskiy <maximmi@nvidia.com>
commit 65d6b6e5a5dad9a49a5a268741c82e72e810ced7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/65d6b6e5.failed

This commit moves the responsibility of keeping the RSS configuration
for different traffic types to en/rx_res.{c,h}, hiding the
implementation details behind the new getters, and abandons all usage of
struct mlx5e_tirc_config, which is no longer useful and superseded by
struct mlx5e_rss_params_traffic_type.

	Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 65d6b6e5a5dad9a49a5a268741c82e72e810ced7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index b5072a3a2585,6378dc815df7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -27,7 -27,8 +27,12 @@@ mlx5_core-$(CONFIG_MLX5_CORE_EN) += en_
  		en_selftest.o en/port.o en/monitor_stats.o en/health.o \
  		en/reporter_tx.o en/reporter_rx.o en/params.o en/xsk/pool.o \
  		en/xsk/setup.o en/xsk/rx.o en/xsk/tx.o en/devlink.o en/ptp.o \
++<<<<<<< HEAD
 +		en/qos.o en/trap.o en/fs_tt_redirect.o
++=======
+ 		en/qos.o en/trap.o en/fs_tt_redirect.o en/rqt.o en/tir.o \
+ 		en/rx_res.o
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  
  #
  # Netdev extra
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 73a162266789,35668986878a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -944,24 -921,7 +944,28 @@@ int mlx5e_vlan_rx_kill_vid(struct net_d
  			   u16 vid);
  void mlx5e_timestamp_init(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +struct mlx5e_redirect_rqt_param {
 +	bool is_rss;
 +	union {
 +		u32 rqn; /* Direct RQN (Non-RSS) */
 +		struct {
 +			u8 hfunc;
 +			struct mlx5e_channels *channels;
 +		} rss; /* RSS data */
 +	};
 +};
 +
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp);
 +void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_rss_params *rss_params,
 +				    const struct mlx5e_tirc_config *ttconfig,
 +				    void *tirc, bool inner);
 +void mlx5e_modify_tirs_hash(struct mlx5e_priv *priv, void *in);
 +struct mlx5e_tirc_config mlx5e_tirc_get_default_config(enum mlx5e_traffic_types tt);
++=======
+ int mlx5e_modify_tirs_hash(struct mlx5e_priv *priv);
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  
  struct mlx5e_xsk_param;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 15e30d82e985,b9a0459b58f1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2382,142 -2304,51 +2382,166 @@@ static void mlx5e_redirect_rqts_to_chan
  
  static void mlx5e_redirect_rqts_to_drop(struct mlx5e_priv *priv)
  {
 -	struct mlx5e_rx_res *res = priv->rx_res;
 -	unsigned int ix;
 +	struct mlx5e_redirect_rqt_param drop_rrp = {
 +		.is_rss = false,
 +		{
 +			.rqn = priv->drop_rq.rqn,
 +		},
 +	};
 +
 +	mlx5e_redirect_rqts(priv, drop_rrp);
 +}
 +
++<<<<<<< HEAD
 +static const struct mlx5e_tirc_config tirc_default_config[MLX5E_NUM_INDIR_TIRS] = {
 +	[MLX5E_TT_IPV4_TCP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV6_TCP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV4_UDP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV6_UDP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
 +				.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_AH] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				     .l4_prot_type = 0,
 +				     .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_AH] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				     .l4_prot_type = 0,
 +				     .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_ESP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +				      .l4_prot_type = 0,
 +				      .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_ESP] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +				      .l4_prot_type = 0,
 +				      .rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
 +	},
 +	[MLX5E_TT_IPV4] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
 +			    .l4_prot_type = 0,
 +			    .rx_hash_fields = MLX5_HASH_IP,
 +	},
 +	[MLX5E_TT_IPV6] = { .l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
 +			    .l4_prot_type = 0,
 +			    .rx_hash_fields = MLX5_HASH_IP,
 +	},
 +};
  
 -	mlx5e_rqt_redirect_direct(&res->indir_rqt, priv->drop_rq.rqn);
 +struct mlx5e_tirc_config mlx5e_tirc_get_default_config(enum mlx5e_traffic_types tt)
 +{
 +	return tirc_default_config[tt];
 +}
 +
 +static void mlx5e_build_tir_ctx_lro(struct mlx5e_params *params, void *tirc)
 +{
 +	if (!params->lro_en)
 +		return;
 +
 +#define ROUGH_MAX_L2_L3_HDR_SZ 256
 +
 +	MLX5_SET(tirc, tirc, lro_enable_mask,
 +		 MLX5_TIRC_LRO_ENABLE_MASK_IPV4_LRO |
 +		 MLX5_TIRC_LRO_ENABLE_MASK_IPV6_LRO);
 +	MLX5_SET(tirc, tirc, lro_max_ip_payload_size,
 +		 (MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ - ROUGH_MAX_L2_L3_HDR_SZ) >> 8);
 +	MLX5_SET(tirc, tirc, lro_timeout_period_usecs, params->lro_timeout);
 +}
 +
 +void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_rss_params *rss_params,
 +				    const struct mlx5e_tirc_config *ttconfig,
 +				    void *tirc, bool inner)
 +{
 +	void *hfso = inner ? MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner) :
 +			     MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);
  
 -	for (ix = 0; ix < priv->max_nch; ix++)
 -		mlx5e_rqt_redirect_direct(&res->channels[ix].direct_rqt, priv->drop_rq.rqn);
 +	MLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_rx_hash_fn(rss_params->hfunc));
 +	if (rss_params->hfunc == ETH_RSS_HASH_TOP) {
 +		void *rss_key = MLX5_ADDR_OF(tirc, tirc,
 +					     rx_hash_toeplitz_key);
 +		size_t len = MLX5_FLD_SZ_BYTES(tirc,
 +					       rx_hash_toeplitz_key);
  
 -	if (priv->profile->rx_ptp_support)
 -		mlx5e_rqt_redirect_direct(&res->ptp.rqt, priv->drop_rq.rqn);
 +		MLX5_SET(tirc, tirc, rx_hash_symmetric, 1);
 +		memcpy(rss_key, rss_params->toeplitz_hash_key, len);
 +	}
 +	MLX5_SET(rx_hash_field_select, hfso, l3_prot_type,
 +		 ttconfig->l3_prot_type);
 +	MLX5_SET(rx_hash_field_select, hfso, l4_prot_type,
 +		 ttconfig->l4_prot_type);
 +	MLX5_SET(rx_hash_field_select, hfso, selected_fields,
 +		 ttconfig->rx_hash_fields);
 +}
 +
 +static void mlx5e_update_rx_hash_fields(struct mlx5e_tirc_config *ttconfig,
 +					enum mlx5e_traffic_types tt,
 +					u32 rx_hash_fields)
 +{
 +	*ttconfig                = tirc_default_config[tt];
 +	ttconfig->rx_hash_fields = rx_hash_fields;
  }
  
 +void mlx5e_modify_tirs_hash(struct mlx5e_priv *priv, void *in)
 +{
 +	void *tirc = MLX5_ADDR_OF(modify_tir_in, in, ctx);
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	int ctxlen = MLX5_ST_SZ_BYTES(tirc);
 +	struct mlx5e_tirc_config ttconfig;
 +	int tt;
++=======
+ int mlx5e_modify_tirs_hash(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rss_params_hash *rss_hash = &priv->rx_res->rss_params.hash;
+ 	struct mlx5e_rss_params_traffic_type rss_tt;
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	struct mlx5e_tir_builder *builder;
+ 	enum mlx5e_traffic_types tt;
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  
 -	builder = mlx5e_tir_builder_alloc(true);
 -	if (!builder)
 -		return -ENOMEM;
 +	MLX5_SET(modify_tir_in, in, bitmask.hash, 1);
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
++<<<<<<< HEAD
 +		memset(tirc, 0, ctxlen);
 +		mlx5e_update_rx_hash_fields(&ttconfig, tt,
 +					    rss->rx_hash_fields[tt]);
 +		mlx5e_build_indir_tir_ctx_hash(rss, &ttconfig, tirc, false);
 +		mlx5_core_modify_tir(mdev, priv->indir_tir[tt].tirn, in);
++=======
+ 		rss_tt = mlx5e_rx_res_rss_get_current_tt_config(res, tt);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, false);
+ 		mlx5e_tir_modify(&res->rss[tt].indir_tir, builder);
+ 		mlx5e_tir_builder_clear(builder);
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  	}
  
  	/* Verify inner tirs resources allocated */
 -	if (!res->rss[0].inner_indir_tir.tirn)
 -		goto out;
 +	if (!priv->inner_indir_tir[0].tirn)
 +		return;
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
++<<<<<<< HEAD
 +		memset(tirc, 0, ctxlen);
 +		mlx5e_update_rx_hash_fields(&ttconfig, tt,
 +					    rss->rx_hash_fields[tt]);
 +		mlx5e_build_indir_tir_ctx_hash(rss, &ttconfig, tirc, true);
 +		mlx5_core_modify_tir(mdev, priv->inner_indir_tir[tt].tirn, in);
++=======
+ 		rss_tt = mlx5e_rx_res_rss_get_current_tt_config(res, tt);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, true);
+ 		mlx5e_tir_modify(&res->rss[tt].indir_tir, builder);
+ 		mlx5e_tir_builder_clear(builder);
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  	}
 -
 -out:
 -	mlx5e_tir_builder_free(builder);
 -	return 0;
  }
  
  static int mlx5e_modify_tirs_lro(struct mlx5e_priv *priv)
@@@ -3182,78 -3019,52 +3206,111 @@@ static void mlx5e_cleanup_nic_tx(struc
  	mlx5e_destroy_tises(priv);
  }
  
 +static void mlx5e_build_indir_tir_ctx_common(struct mlx5e_priv *priv,
 +					     u32 rqtn, u32 *tirc)
 +{
 +	MLX5_SET(tirc, tirc, transport_domain, priv->mdev->mlx5e_res.hw_objs.td.tdn);
 +	MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +	MLX5_SET(tirc, tirc, indirect_table, rqtn);
 +	MLX5_SET(tirc, tirc, tunneled_offload_en,
 +		 priv->channels.params.tunneled_offload_en);
 +
 +	mlx5e_build_tir_ctx_lro(&priv->channels.params, tirc);
 +}
 +
 +static void mlx5e_build_indir_tir_ctx(struct mlx5e_priv *priv,
 +				      enum mlx5e_traffic_types tt,
 +				      u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, priv->indir_rqt.rqtn, tirc);
 +	mlx5e_build_indir_tir_ctx_hash(&priv->rss_params,
 +				       &tirc_default_config[tt], tirc, false);
 +}
 +
 +static void mlx5e_build_direct_tir_ctx(struct mlx5e_priv *priv, u32 rqtn, u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, rqtn, tirc);
 +	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_INVERTED_XOR8);
 +}
 +
 +static void mlx5e_build_inner_indir_tir_ctx(struct mlx5e_priv *priv,
 +					    enum mlx5e_traffic_types tt,
 +					    u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, priv->indir_rqt.rqtn, tirc);
 +	mlx5e_build_indir_tir_ctx_hash(&priv->rss_params,
 +				       &tirc_default_config[tt], tirc, true);
 +}
 +
  int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv, bool inner_ttc)
  {
++<<<<<<< HEAD
 +	struct mlx5e_tir *tir;
 +	void *tirc;
 +	int inlen;
 +	int i = 0;
 +	int err;
 +	u32 *in;
 +	int tt;
++=======
+ 	struct mlx5e_rss_params_hash *rss_hash = &priv->rx_res->rss_params.hash;
+ 	bool inner_ft_support = priv->channels.params.tunneled_offload_en;
+ 	struct mlx5e_rss_params_traffic_type rss_tt;
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	enum mlx5e_traffic_types tt, max_tt;
+ 	struct mlx5e_tir_builder *builder;
+ 	struct mlx5e_lro_param lro_param;
+ 	u32 indir_rqtn;
+ 	int err = 0;
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  
 -	builder = mlx5e_tir_builder_alloc(false);
 -	if (!builder)
 +	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
  		return -ENOMEM;
  
 -	lro_param = mlx5e_get_lro_param(&priv->channels.params);
 -	indir_rqtn = mlx5e_rqt_get_rqtn(&res->indir_rqt);
 -
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
++<<<<<<< HEAD
 +		memset(in, 0, inlen);
 +		tir = &priv->indir_tir[tt];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_indir_tir_ctx(priv, tt, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
++=======
+ 		mlx5e_tir_builder_build_rqt(builder, priv->mdev->mlx5e_res.hw_objs.td.tdn,
+ 					    indir_rqtn, inner_ft_support);
+ 		mlx5e_tir_builder_build_lro(builder, &lro_param);
+ 		rss_tt = mlx5e_rx_res_rss_get_current_tt_config(res, tt);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, false);
+ 
+ 		err = mlx5e_tir_init(&res->rss[tt].indir_tir, builder, priv->mdev, true);
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  		if (err) {
  			mlx5_core_warn(priv->mdev, "create indirect tirs failed, %d\n", err);
 -			goto err_destroy_tirs;
 +			goto err_destroy_inner_tirs;
  		}
 -
 -		mlx5e_tir_builder_clear(builder);
  	}
  
  	if (!inner_ttc || !mlx5e_tunnel_inner_ft_supported(priv->mdev))
  		goto out;
  
++<<<<<<< HEAD
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++) {
 +		memset(in, 0, inlen);
 +		tir = &priv->inner_indir_tir[i];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_inner_indir_tir_ctx(priv, i, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
++=======
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
+ 		mlx5e_tir_builder_build_rqt(builder, priv->mdev->mlx5e_res.hw_objs.td.tdn,
+ 					    indir_rqtn, inner_ft_support);
+ 		mlx5e_tir_builder_build_lro(builder, &lro_param);
+ 		rss_tt = mlx5e_rx_res_rss_get_current_tt_config(res, tt);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, true);
+ 
+ 		err = mlx5e_tir_init(&res->rss[tt].inner_indir_tir, builder, priv->mdev, true);
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  		if (err) {
  			mlx5_core_warn(priv->mdev, "create inner indirect tirs failed, %d\n", err);
  			goto err_destroy_inner_tirs;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,0cee2fa76d65..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -576,23 -516,28 +576,27 @@@ out
  static int mlx5e_hairpin_create_indirect_tirs(struct mlx5e_hairpin *hp)
  {
  	struct mlx5e_priv *priv = hp->func_priv;
 -	struct mlx5e_rss_params_hash *rss_hash;
 -	enum mlx5e_traffic_types tt, max_tt;
 -	struct mlx5e_tir_builder *builder;
 -	int err = 0;
 -
 -	builder = mlx5e_tir_builder_alloc(false);
 -	if (!builder)
 -		return -ENOMEM;
 -
 -	rss_hash = &priv->rx_res->rss_params.hash;
 +	u32 in[MLX5_ST_SZ_DW(create_tir_in)];
 +	int tt, i, err;
 +	void *tirc;
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
- 		struct mlx5e_tirc_config ttconfig = mlx5e_tirc_get_default_config(tt);
+ 		struct mlx5e_rss_params_traffic_type rss_tt;
  
++<<<<<<< HEAD
 +		memset(in, 0, MLX5_ST_SZ_BYTES(create_tir_in));
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
++=======
+ 		rss_tt = mlx5e_rss_get_default_tt_config(tt);
++>>>>>>> 65d6b6e5a5da (net/mlx5e: Move management of indir traffic types to rx_res)
  
 -		mlx5e_tir_builder_build_rqt(builder, hp->tdn,
 -					    mlx5e_rqt_get_rqtn(&hp->indir_rqt),
 -					    false);
 -		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, false);
 +		MLX5_SET(tirc, tirc, transport_domain, hp->tdn);
 +		MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +		MLX5_SET(tirc, tirc, indirect_table, hp->indir_rqt.rqtn);
 +		mlx5e_build_indir_tir_ctx_hash(&priv->rss_params, &ttconfig, tirc, false);
  
 -		err = mlx5e_tir_init(&hp->indir_tir[tt], builder, hp->func_mdev, false);
 +		err = mlx5_core_create_tir(hp->func_mdev, in,
 +					   &hp->indir_tirn[tt]);
  		if (err) {
  			mlx5_core_warn(hp->func_mdev, "create indirect tirs failed, %d\n", err);
  			goto err_destroy_tirs;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 6d1dade3f38c..cd70de8c2128 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@ -91,12 +91,6 @@ enum mlx5e_traffic_types {
 	MLX5E_NUM_INDIR_TIRS = MLX5E_TT_ANY,
 };
 
-struct mlx5e_tirc_config {
-	u8 l3_prot_type;
-	u8 l4_prot_type;
-	u32 rx_hash_fields;
-};
-
 #define MLX5_HASH_IP		(MLX5_HASH_FIELD_SEL_SRC_IP   |\
 				 MLX5_HASH_FIELD_SEL_DST_IP)
 #define MLX5_HASH_IP_L4PORTS	(MLX5_HASH_FIELD_SEL_SRC_IP   |\
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
new file mode 100644
index 000000000000..8fc1dfc4e830
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/* Copyright (c) 2021, Mellanox Technologies inc. All rights reserved. */
+
+#include "rx_res.h"
+
+static const struct mlx5e_rss_params_traffic_type rss_default_config[MLX5E_NUM_INDIR_TIRS] = {
+	[MLX5E_TT_IPV4_TCP] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
+		.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
+		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
+	},
+	[MLX5E_TT_IPV6_TCP] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
+		.l4_prot_type = MLX5_L4_PROT_TYPE_TCP,
+		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
+	},
+	[MLX5E_TT_IPV4_UDP] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
+		.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
+		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
+	},
+	[MLX5E_TT_IPV6_UDP] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
+		.l4_prot_type = MLX5_L4_PROT_TYPE_UDP,
+		.rx_hash_fields = MLX5_HASH_IP_L4PORTS,
+	},
+	[MLX5E_TT_IPV4_IPSEC_AH] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
+		.l4_prot_type = 0,
+		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
+	},
+	[MLX5E_TT_IPV6_IPSEC_AH] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
+		.l4_prot_type = 0,
+		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
+	},
+	[MLX5E_TT_IPV4_IPSEC_ESP] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
+		.l4_prot_type = 0,
+		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
+	},
+	[MLX5E_TT_IPV6_IPSEC_ESP] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
+		.l4_prot_type = 0,
+		.rx_hash_fields = MLX5_HASH_IP_IPSEC_SPI,
+	},
+	[MLX5E_TT_IPV4] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV4,
+		.l4_prot_type = 0,
+		.rx_hash_fields = MLX5_HASH_IP,
+	},
+	[MLX5E_TT_IPV6] = {
+		.l3_prot_type = MLX5_L3_PROT_TYPE_IPV6,
+		.l4_prot_type = 0,
+		.rx_hash_fields = MLX5_HASH_IP,
+	},
+};
+
+struct mlx5e_rss_params_traffic_type
+mlx5e_rss_get_default_tt_config(enum mlx5e_traffic_types tt)
+{
+	return rss_default_config[tt];
+}
+
+struct mlx5e_rss_params_traffic_type
+mlx5e_rx_res_rss_get_current_tt_config(struct mlx5e_rx_res *res, enum mlx5e_traffic_types tt)
+{
+	struct mlx5e_rss_params_traffic_type rss_tt;
+
+	rss_tt = mlx5e_rss_get_default_tt_config(tt);
+	rss_tt.rx_hash_fields = res->rss_params.rx_hash_fields[tt];
+	return rss_tt;
+}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
