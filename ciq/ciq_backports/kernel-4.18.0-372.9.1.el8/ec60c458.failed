net/mlx5e: Support MQPRIO channel mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit ec60c4581bd952296c1f81115eabd0a570042458
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/ec60c458.failed

Add support for MQPRIO channel mode, in which a partition to TCs
is defined over the channels. We allow partitions with contiguous
queue indices, with no holes within. We do not allow modification
to the num of channels while this MQPRIO mode is active.

	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit ec60c4581bd952296c1f81115eabd0a570042458)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,5696d3f1baaf..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -473,7 -467,22 +473,26 @@@ int mlx5e_ethtool_set_channels(struct m
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	arfs_enabled = priv->netdev->features & NETIF_F_NTUPLE;
++=======
+ 	/* Don't allow changing the number of channels if MQPRIO mode channel offload is active,
+ 	 * because it defines a partition over the channels queues.
+ 	 */
+ 	if (cur_params->mqprio.mode == TC_MQPRIO_MODE_CHANNEL) {
+ 		err = -EINVAL;
+ 		netdev_err(priv->netdev, "%s: MQPRIO mode channel offload is active, cannot change the number of channels\n",
+ 			   __func__);
+ 		goto out;
+ 	}
+ 
+ 	new_params = *cur_params;
+ 	new_params.num_channels = count;
+ 
+ 	opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
+ 
+ 	arfs_enabled = opened && (priv->netdev->features & NETIF_F_NTUPLE);
++>>>>>>> ec60c4581bd9 (net/mlx5e: Support MQPRIO channel mode)
  	if (arfs_enabled)
  		mlx5e_arfs_disable(priv);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index c234e374c4b8,26d2f78c7706..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2690,10 -2324,10 +2696,10 @@@ static int mlx5e_update_netdev_queues(s
  	old_ntc = netdev->num_tc ? : 1;
  
  	nch = priv->channels.params.num_channels;
 -	ntc = mlx5e_get_dcb_num_tc(&priv->channels.params);
 +	ntc = priv->channels.params.num_tc;
  	num_rxqs = nch * priv->profile->rq_groups;
  
- 	err = mlx5e_netdev_set_tcs(netdev, nch, ntc);
+ 	err = mlx5e_netdev_set_tcs(netdev, nch, ntc, NULL);
  	if (err)
  		goto err_out;
  	err = mlx5e_update_tx_netdev_queues(priv);
@@@ -3385,39 -2873,110 +3391,141 @@@ static int mlx5e_setup_tc_mqprio(struc
  	if (tc && tc != MLX5E_MAX_NUM_TC)
  		return -EINVAL;
  
 -	new_params = priv->channels.params;
 -	new_params.mqprio.mode = TC_MQPRIO_MODE_DCB;
 -	new_params.mqprio.num_tc = tc ? tc : 1;
 +	mutex_lock(&priv->state_lock);
  
++<<<<<<< HEAD
 +	/* MQPRIO is another toplevel qdisc that can't be attached
 +	 * simultaneously with the offloaded HTB.
 +	 */
 +	if (WARN_ON(priv->htb.maj_id)) {
 +		err = -EINVAL;
 +		goto out;
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_num_channels_changed_ctx, NULL, true);
+ 
+ 	priv->max_opened_tc = max_t(u8, priv->max_opened_tc,
+ 				    mlx5e_get_dcb_num_tc(&priv->channels.params));
+ 	return err;
+ }
+ 
+ static int mlx5e_mqprio_channel_validate(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	int agg_count = 0;
+ 	int i;
+ 
+ 	if (mqprio->qopt.offset[0] != 0 || mqprio->qopt.num_tc < 1 ||
+ 	    mqprio->qopt.num_tc > MLX5E_MAX_NUM_MQPRIO_CH_TC)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < mqprio->qopt.num_tc; i++) {
+ 		if (!mqprio->qopt.count[i]) {
+ 			netdev_err(netdev, "Zero size for queue-group (%d) is not supported\n", i);
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->min_rate[i]) {
+ 			netdev_err(netdev, "Min tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->max_rate[i]) {
+ 			netdev_err(netdev, "Max tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (mqprio->qopt.offset[i] != agg_count) {
+ 			netdev_err(netdev, "Discontinuous queues config is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		agg_count += mqprio->qopt.count[i];
+ 	}
+ 
+ 	if (priv->channels.params.num_channels < agg_count) {
+ 		netdev_err(netdev, "Num of queues (%d) exceeds available (%d)\n",
+ 			   agg_count, priv->channels.params.num_channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_mqprio_channel_set_tcs_ctx(struct mlx5e_priv *priv, void *ctx)
+ {
+ 	struct tc_mqprio_qopt_offload *mqprio = (struct tc_mqprio_qopt_offload *)ctx;
+ 	struct net_device *netdev = priv->netdev;
+ 	u8 num_tc;
+ 
+ 	if (priv->channels.params.mqprio.mode != TC_MQPRIO_MODE_CHANNEL)
+ 		return -EINVAL;
+ 
+ 	num_tc = priv->channels.params.mqprio.num_tc;
+ 	mlx5e_netdev_set_tcs(netdev, 0, num_tc, mqprio);
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_setup_tc_mqprio_channel(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	struct mlx5e_params new_params;
+ 	int err;
+ 
+ 	err = mlx5e_mqprio_channel_validate(priv, mqprio);
+ 	if (err)
+ 		return err;
+ 
+ 	new_params = priv->channels.params;
+ 	new_params.mqprio.mode = TC_MQPRIO_MODE_CHANNEL;
+ 	new_params.mqprio.num_tc = mqprio->qopt.num_tc;
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_mqprio_channel_set_tcs_ctx, mqprio, true);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_setup_tc_mqprio(struct mlx5e_priv *priv,
+ 				 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	/* MQPRIO is another toplevel qdisc that can't be attached
+ 	 * simultaneously with the offloaded HTB.
+ 	 */
+ 	if (WARN_ON(priv->htb.maj_id))
+ 		return -EINVAL;
+ 
+ 	switch (mqprio->mode) {
+ 	case TC_MQPRIO_MODE_DCB:
+ 		return mlx5e_setup_tc_mqprio_dcb(priv, &mqprio->qopt);
+ 	case TC_MQPRIO_MODE_CHANNEL:
+ 		return mlx5e_setup_tc_mqprio_channel(priv, mqprio);
+ 	default:
+ 		return -EOPNOTSUPP;
++>>>>>>> ec60c4581bd9 (net/mlx5e: Support MQPRIO channel mode)
 +	}
 +
 +	new_channels.params = priv->channels.params;
 +	new_channels.params.num_tc = tc ? tc : 1;
 +
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = priv->channels.params;
 +		priv->channels.params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			priv->channels.params = old_params;
 +
 +		goto out;
  	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels,
 +					 mlx5e_num_channels_changed_ctx, NULL);
 +
 +out:
 +	priv->max_opened_tc = max_t(u8, priv->max_opened_tc,
 +				    priv->channels.params.num_tc);
 +	mutex_unlock(&priv->state_lock);
 +	return err;
  }
  
  static int mlx5e_setup_tc_htb(struct mlx5e_priv *priv, struct tc_htb_qopt_offload *htb)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 73a162266789..0b4372d77124 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -73,6 +73,7 @@ struct page_pool;
 #define MLX5E_SW2HW_MTU(params, swmtu) ((swmtu) + ((params)->hard_mtu))
 
 #define MLX5E_MAX_NUM_TC	8
+#define MLX5E_MAX_NUM_MQPRIO_CH_TC TC_QOPT_MAX_QUEUE
 
 #define MLX5_RX_HEADROOM NET_SKB_PAD
 #define MLX5_SKB_FRAG_SZ(len)	(SKB_DATA_ALIGN(len) +	\
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
