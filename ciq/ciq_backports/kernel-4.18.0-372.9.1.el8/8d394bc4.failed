dm: fix double accounting of flush with data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Mike Snitzer <snitzer@redhat.com>
commit 8d394bc4adf588ca4a0650745167cb83f86c18c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/8d394bc4.failed

DM handles a flush with data by first issuing an empty flush and then
once it completes the REQ_PREFLUSH flag is removed and the payload is
issued.  The problem fixed by this commit is that both the empty flush
bio and the data payload will account the full extent of the data
payload.

Fix this by factoring out dm_io_acct() and having it wrap all IO
accounting to set the size of  bio with REQ_PREFLUSH to 0, account the
IO, and then restore the original size.

	Cc: stable@vger.kernel.org
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 8d394bc4adf588ca4a0650745167cb83f86c18c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index cea43bc71f38,c72a271ea999..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -566,18 -526,7 +592,22 @@@ static void start_io_acct(struct dm_io 
  static void end_io_acct(struct mapped_device *md, struct bio *bio,
  			unsigned long start_time, struct dm_stats_aux *stats_aux)
  {
++<<<<<<< HEAD
 +	unsigned long duration = jiffies - start_time;
 +
 +	bio_end_io_acct(bio, start_time);
 +
 +	if (unlikely(dm_stats_used(&md->stats)))
 +		dm_stats_account_io(&md->stats, bio_data_dir(bio),
 +				    bio->bi_iter.bi_sector, bio_sectors(bio),
 +				    true, duration, stats_aux);
 +
 +	/* nudge anyone waiting on suspend queue */
 +	if (unlikely(wq_has_sleeper(&md->wait)))
 +		wake_up(&md->wait);
++=======
+ 	dm_io_acct(true, md, bio, start_time, stats_aux);
++>>>>>>> 8d394bc4adf5 (dm: fix double accounting of flush with data)
  }
  
  static struct dm_io *alloc_io(struct mapped_device *md, struct bio *bio)
diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c
index 35d368c418d0..80328f1d1083 100644
--- a/drivers/md/dm-stats.c
+++ b/drivers/md/dm-stats.c
@@ -621,13 +621,14 @@ static void __dm_stat_bio(struct dm_stat *s, int bi_rw,
 
 void dm_stats_account_io(struct dm_stats *stats, unsigned long bi_rw,
 			 sector_t bi_sector, unsigned bi_sectors, bool end,
-			 unsigned long duration_jiffies,
+			 unsigned long start_time,
 			 struct dm_stats_aux *stats_aux)
 {
 	struct dm_stat *s;
 	sector_t end_sector;
 	struct dm_stats_last_position *last;
 	bool got_precise_time;
+	unsigned long duration_jiffies = 0;
 
 	if (unlikely(!bi_sectors))
 		return;
@@ -647,7 +648,8 @@ void dm_stats_account_io(struct dm_stats *stats, unsigned long bi_rw,
 				       ));
 		WRITE_ONCE(last->last_sector, end_sector);
 		WRITE_ONCE(last->last_rw, bi_rw);
-	}
+	} else
+		duration_jiffies = jiffies - start_time;
 
 	rcu_read_lock();
 
diff --git a/drivers/md/dm-stats.h b/drivers/md/dm-stats.h
index 2ddfae678f32..09fa579e2e24 100644
--- a/drivers/md/dm-stats.h
+++ b/drivers/md/dm-stats.h
@@ -32,7 +32,7 @@ int dm_stats_message(struct mapped_device *md, unsigned argc, char **argv,
 
 void dm_stats_account_io(struct dm_stats *stats, unsigned long bi_rw,
 			 sector_t bi_sector, unsigned bi_sectors, bool end,
-			 unsigned long duration_jiffies,
+			 unsigned long start_time,
 			 struct dm_stats_aux *aux);
 
 static inline bool dm_stats_used(struct dm_stats *st)
* Unmerged path drivers/md/dm.c
