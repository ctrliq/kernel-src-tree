net/mlx5e: Support multiple RSS contexts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit f01cc58c18d6457bd88b2c77c916a9e072f2b633
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/f01cc58c.failed

Add support to multiple RSS contexts. Resources of the non-default
RSS contexts are allocated and created on demand. Each RSS context
can be controlled and configured separately, via the implemented
ethtool ops. Here we limit the num of total contexts to 16.

We do not enforce any kind of new limitation over the indirection table
content. More specifically, two separate contexts can be configured to
fully or partially point to the same set of receive rings.

The default RSS context (index 0) is created with its full set of TIRs.
All other contexts are created with an empty set, then TIRs are added
upon first usage when steering rules are added.
We use a reference counting mechanism to make sure an RSS context is
not removed before the rules pointing to it.

Block ethtool set_channels operations when multiple RSS contexts exist,
as currently the kernel doesn't protect against inconsistent channels
configs that break non-default RSS contexts.

	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit f01cc58c18d6457bd88b2c77c916a9e072f2b633)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,839a753fda32..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -422,8 -418,10 +422,13 @@@ int mlx5e_ethtool_set_channels(struct m
  {
  	struct mlx5e_params *cur_params = &priv->channels.params;
  	unsigned int count = ch->combined_count;
 -	struct mlx5e_params new_params;
 +	struct mlx5e_channels new_channels = {};
  	bool arfs_enabled;
++<<<<<<< HEAD
++=======
+ 	int rss_cnt;
+ 	bool opened;
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	int err = 0;
  
  	if (!count) {
@@@ -458,22 -456,23 +463,38 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	new_channels.params = *cur_params;
 +	new_channels.params.num_channels = count;
++=======
+ 	/* Don't allow changing the number of channels if non-default RSS contexts exist,
+ 	 * the kernel doesn't protect against set_channels operations that break them.
+ 	 */
+ 	rss_cnt = mlx5e_rx_res_rss_cnt(priv->rx_res) - 1;
+ 	if (rss_cnt) {
+ 		err = -EINVAL;
+ 		netdev_err(priv->netdev, "%s: Non-default RSS contexts exist (%d), cannot change the number of channels\n",
+ 			   __func__, rss_cnt);
+ 		goto out;
+ 	}
+ 
+ 	new_params = *cur_params;
+ 	new_params.num_channels = count;
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
 +
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
  
 -	opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
 +		old_params = *cur_params;
 +		*cur_params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			*cur_params = old_params;
 +
 +		goto out;
 +	}
  
 -	arfs_enabled = opened && (priv->netdev->features & NETIF_F_NTUPLE);
 +	arfs_enabled = priv->netdev->features & NETIF_F_NTUPLE;
  	if (arfs_enabled)
  		mlx5e_arfs_disable(priv);
  
@@@ -1214,88 -1206,64 +1235,138 @@@ static u32 mlx5e_get_rxfh_indir_size(st
  	return mlx5e_ethtool_get_rxfh_indir_size(priv);
  }
  
- int mlx5e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
- 		   u8 *hfunc)
+ static int mlx5e_get_rxfh_context(struct net_device *dev, u32 *indir,
+ 				  u8 *key, u8 *hfunc, u32 rss_context)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +
 +	if (indir)
 +		memcpy(indir, rss->indirection_rqt,
 +		       sizeof(rss->indirection_rqt));
 +
 +	if (key)
 +		memcpy(key, rss->toeplitz_hash_key,
 +		       sizeof(rss->toeplitz_hash_key));
 +
 +	if (hfunc)
 +		*hfunc = rss->hfunc;
 +
 +	return 0;
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int err;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	err = mlx5e_rx_res_rss_get_rxfh(priv->rx_res, rss_context, indir, key, hfunc);
+ 	mutex_unlock(&priv->state_lock);
+ 	return err;
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
+ }
+ 
+ static int mlx5e_set_rxfh_context(struct net_device *dev, const u32 *indir,
+ 				  const u8 *key, const u8 hfunc,
+ 				  u32 *rss_context, bool delete)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int err;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	if (delete) {
+ 		err = mlx5e_rx_res_rss_destroy(priv->rx_res, *rss_context);
+ 		goto unlock;
+ 	}
+ 
+ 	if (*rss_context == ETH_RXFH_CONTEXT_ALLOC) {
+ 		unsigned int count = priv->channels.params.num_channels;
+ 
+ 		err = mlx5e_rx_res_rss_init(priv->rx_res, rss_context, count);
+ 		if (err)
+ 			goto unlock;
+ 	}
+ 
+ 	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, *rss_context, indir, key,
+ 					hfunc == ETH_RSS_HASH_NO_CHANGE ? NULL : &hfunc);
+ 
+ unlock:
+ 	mutex_unlock(&priv->state_lock);
+ 	return err;
+ }
+ 
+ int mlx5e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+ 		   u8 *hfunc)
+ {
+ 	return mlx5e_get_rxfh_context(netdev, indir, key, hfunc, 0);
  }
  
  int mlx5e_set_rxfh(struct net_device *dev, const u32 *indir,
  		   const u8 *key, const u8 hfunc)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
 -	int err;
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +	int inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
 +	bool refresh_tirs = false;
 +	bool refresh_rqt = false;
 +	void *in;
 +
 +	if ((hfunc != ETH_RSS_HASH_NO_CHANGE) &&
 +	    (hfunc != ETH_RSS_HASH_XOR) &&
 +	    (hfunc != ETH_RSS_HASH_TOP))
 +		return -EINVAL;
 +
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
  
  	mutex_lock(&priv->state_lock);
++<<<<<<< HEAD
 +
 +	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hfunc) {
 +		rss->hfunc = hfunc;
 +		refresh_rqt = true;
 +		refresh_tirs = true;
 +	}
 +
 +	if (indir) {
 +		memcpy(rss->indirection_rqt, indir,
 +		       sizeof(rss->indirection_rqt));
 +		refresh_rqt = true;
 +	}
 +
 +	if (key) {
 +		memcpy(rss->toeplitz_hash_key, key,
 +		       sizeof(rss->toeplitz_hash_key));
 +		refresh_tirs = refresh_tirs || rss->hfunc == ETH_RSS_HASH_TOP;
 +	}
 +
 +	if (refresh_rqt && test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_redirect_rqt_param rrp = {
 +			.is_rss = true,
 +			{
 +				.rss = {
 +					.hfunc = rss->hfunc,
 +					.channels  = &priv->channels,
 +				},
 +			},
 +		};
 +		u32 rqtn = priv->indir_rqt.rqtn;
 +
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
 +	}
 +
 +	if (refresh_tirs)
 +		mlx5e_modify_tirs_hash(priv, in);
 +
++=======
+ 	err = mlx5e_rx_res_rss_set_rxfh(priv->rx_res, 0, indir, key,
+ 					hfunc == ETH_RSS_HASH_NO_CHANGE ? NULL : &hfunc);
++>>>>>>> f01cc58c18d6 (net/mlx5e: Support multiple RSS contexts)
  	mutex_unlock(&priv->state_lock);
 -	return err;
 +
 +	kvfree(in);
 +
 +	return 0;
  }
  
  #define MLX5E_PFC_PREVEN_AUTO_TOUT_MSEC		100
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rss.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
