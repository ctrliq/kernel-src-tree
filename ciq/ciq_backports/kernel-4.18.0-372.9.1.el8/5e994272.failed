net/mlx5e: Term table handling of internal port rules

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Ariel Levkovich <lariel@nvidia.com>
commit 5e9942721749fc96b9df4b0545474153316c0571
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/5e994272.failed

Adjust termination table logic to handle rules which
involve internal port as filter or forwarding device.

For cases where the rule forwards from internal port
to uplink, always choose to go via termination table.
This is because it is not known from where the packet
originally arrived to the internal port and it is possible
that it came from the uplink itself, in which case
a term table is required to perform hairpin.
If the packet arrived from a vport, going via term
table has no effect.

For cases where the rule forwards to an internal port
from uplink the rep pointer will point to the uplink rep,
avoid going via termination table as it is not required.

	Signed-off-by: Ariel Levkovich <lariel@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 5e9942721749fc96b9df4b0545474153316c0571)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
index b45954905845,182306bbefaa..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
@@@ -219,8 -219,8 +219,13 @@@ mlx5_eswitch_termtbl_required(struct ml
  
  	if (!MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, termination_table) ||
  	    !MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, ignore_flow_level) ||
++<<<<<<< HEAD
 +	    attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH ||
 +	    !mlx5_eswitch_offload_is_uplink_port(esw, spec))
++=======
+ 	    mlx5_esw_attr_flags_skip(attr->flags) ||
+ 	    (!mlx5_eswitch_offload_is_uplink_port(esw, spec) && !esw_attr->int_port))
++>>>>>>> 5e9942721749 (net/mlx5e: Term table handling of internal port rules)
  		return false;
  
  	/* push vlan on RX */
@@@ -229,7 -229,8 +234,12 @@@
  
  	/* hairpin */
  	for (i = esw_attr->split_count; i < esw_attr->out_count; i++)
++<<<<<<< HEAD
 +		if (esw_attr->dests[i].rep->vport == MLX5_VPORT_UPLINK)
++=======
+ 		if (!esw_attr->dest_int_port && esw_attr->dests[i].rep &&
+ 		    esw_attr->dests[i].rep->vport == MLX5_VPORT_UPLINK)
++>>>>>>> 5e9942721749 (net/mlx5e: Term table handling of internal port rules)
  			return true;
  
  	return false;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
