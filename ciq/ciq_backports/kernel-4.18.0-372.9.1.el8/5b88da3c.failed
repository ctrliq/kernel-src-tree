ALSA: gus: Allocate resources with device-managed APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 5b88da3c800f21a76b9fd755c604402c15b10855
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/5b88da3c.failed

This patch converts the resource management in ISA gus drivers with
devres as a clean up.  Each manual resource management is converted
with the corresponding devres helper.  The remove callback became
superfluous and dropped.

This should give no user-visible functional changes.

Link: https://lore.kernel.org/r/20210715075941.23332-66-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 5b88da3c800f21a76b9fd755c604402c15b10855)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/isa/gus/gusclassic.c
#	sound/isa/gus/gusextreme.c
#	sound/isa/gus/gusmax.c
#	sound/isa/gus/interwave.c
diff --cc sound/isa/gus/gusclassic.c
index 434b914cb039,09cc53ceea2a..000000000000
--- a/sound/isa/gus/gusclassic.c
+++ b/sound/isa/gus/gusclassic.c
@@@ -192,15 -191,6 +192,18 @@@ static int snd_gusclassic_probe(struct 
  
  	dev_set_drvdata(dev, card);
  	return 0;
++<<<<<<< HEAD
 +
 +out:	snd_card_free(card);
 +	return error;
 +}
 +
 +static int snd_gusclassic_remove(struct device *dev, unsigned int n)
 +{
 +	snd_card_free(dev_get_drvdata(dev));
 +	return 0;
++=======
++>>>>>>> 5b88da3c800f (ALSA: gus: Allocate resources with device-managed APIs)
  }
  
  static struct isa_driver snd_gusclassic_driver = {
diff --cc sound/isa/gus/gusextreme.c
index 751030717f3f,63d9f2d75df0..000000000000
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@@ -321,15 -320,6 +321,18 @@@ static int snd_gusextreme_probe(struct 
  
  	dev_set_drvdata(dev, card);
  	return 0;
++<<<<<<< HEAD
 +
 +out:	snd_card_free(card);
 +	return error;
 +}
 +
 +static int snd_gusextreme_remove(struct device *dev, unsigned int n)
 +{
 +	snd_card_free(dev_get_drvdata(dev));
 +	return 0;
++=======
++>>>>>>> 5b88da3c800f (ALSA: gus: Allocate resources with device-managed APIs)
  }
  
  static struct isa_driver snd_gusextreme_driver = {
diff --cc sound/isa/gus/gusmax.c
index 5eb1d7bd93ee,6834c0560064..000000000000
--- a/sound/isa/gus/gusmax.c
+++ b/sound/isa/gus/gusmax.c
@@@ -344,16 -328,6 +329,19 @@@ static int snd_gusmax_probe(struct devi
  
  	dev_set_drvdata(pdev, card);
  	return 0;
++<<<<<<< HEAD
 +
 + _err:
 +	snd_card_free(card);
 +	return err;
 +}
 +
 +static int snd_gusmax_remove(struct device *devptr, unsigned int dev)
 +{
 +	snd_card_free(dev_get_drvdata(devptr));
 +	return 0;
++=======
++>>>>>>> 5b88da3c800f (ALSA: gus: Allocate resources with device-managed APIs)
  }
  
  #define DEV_NAME "gusmax"
diff --cc sound/isa/gus/interwave.c
index 7f27dc5d809d,20f490e9d563..000000000000
--- a/sound/isa/gus/interwave.c
+++ b/sound/isa/gus/interwave.c
@@@ -849,12 -829,6 +835,15 @@@ static int snd_interwave_isa_probe(stru
  	}
  }
  
++<<<<<<< HEAD
 +static int snd_interwave_isa_remove(struct device *devptr, unsigned int dev)
 +{
 +	snd_card_free(dev_get_drvdata(devptr));
 +	return 0;
 +}
 +
++=======
++>>>>>>> 5b88da3c800f (ALSA: gus: Allocate resources with device-managed APIs)
  static struct isa_driver snd_interwave_driver = {
  	.match		= snd_interwave_isa_match,
  	.probe		= snd_interwave_isa_probe,
diff --git a/sound/isa/gus/gus_main.c b/sound/isa/gus/gus_main.c
index e7abbba9f377..3c5c128c27ec 100644
--- a/sound/isa/gus/gus_main.c
+++ b/sound/isa/gus/gus_main.c
@@ -96,24 +96,10 @@ static void snd_gus_init_control(struct snd_gus_card *gus)
 
 static int snd_gus_free(struct snd_gus_card *gus)
 {
-	if (gus->gf1.res_port2 == NULL)
-		goto __hw_end;
-	snd_gf1_stop(gus);
-	snd_gus_init_dma_irq(gus, 0);
-      __hw_end:
-	release_and_free_resource(gus->gf1.res_port1);
-	release_and_free_resource(gus->gf1.res_port2);
-	if (gus->gf1.irq >= 0)
-		free_irq(gus->gf1.irq, (void *) gus);
-	if (gus->gf1.dma1 >= 0) {
-		disable_dma(gus->gf1.dma1);
-		free_dma(gus->gf1.dma1);
+	if (gus->gf1.res_port2) {
+		snd_gf1_stop(gus);
+		snd_gus_init_dma_irq(gus, 0);
 	}
-	if (!gus->equal_dma && gus->gf1.dma2 >= 0) {
-		disable_dma(gus->gf1.dma2);
-		free_dma(gus->gf1.dma2);
-	}
-	kfree(gus);
 	return 0;
 }
 
@@ -139,7 +125,7 @@ int snd_gus_create(struct snd_card *card,
 	};
 
 	*rgus = NULL;
-	gus = kzalloc(sizeof(*gus), GFP_KERNEL);
+	gus = devm_kzalloc(card->dev, sizeof(*gus), GFP_KERNEL);
 	if (gus == NULL)
 		return -ENOMEM;
 	spin_lock_init(&gus->reg_lock);
@@ -165,35 +151,33 @@ int snd_gus_create(struct snd_card *card,
 	gus->gf1.reg_timerctrl = GUSP(gus, TIMERCNTRL);
 	gus->gf1.reg_timerdata = GUSP(gus, TIMERDATA);
 	/* allocate resources */
-	gus->gf1.res_port1 = request_region(port, 16, "GUS GF1 (Adlib/SB)");
+	gus->gf1.res_port1 = devm_request_region(card->dev, port, 16,
+						 "GUS GF1 (Adlib/SB)");
 	if (!gus->gf1.res_port1) {
 		snd_printk(KERN_ERR "gus: can't grab SB port 0x%lx\n", port);
-		snd_gus_free(gus);
 		return -EBUSY;
 	}
-	gus->gf1.res_port2 = request_region(port + 0x100, 12, "GUS GF1 (Synth)");
+	gus->gf1.res_port2 = devm_request_region(card->dev, port + 0x100, 12,
+						 "GUS GF1 (Synth)");
 	if (!gus->gf1.res_port2) {
 		snd_printk(KERN_ERR "gus: can't grab synth port 0x%lx\n", port + 0x100);
-		snd_gus_free(gus);
 		return -EBUSY;
 	}
-	if (irq >= 0 && request_irq(irq, snd_gus_interrupt, 0, "GUS GF1", (void *) gus)) {
+	if (irq >= 0 && devm_request_irq(card->dev, irq, snd_gus_interrupt, 0,
+					 "GUS GF1", (void *) gus)) {
 		snd_printk(KERN_ERR "gus: can't grab irq %d\n", irq);
-		snd_gus_free(gus);
 		return -EBUSY;
 	}
 	gus->gf1.irq = irq;
 	card->sync_irq = irq;
-	if (request_dma(dma1, "GUS - 1")) {
+	if (snd_devm_request_dma(card->dev, dma1, "GUS - 1")) {
 		snd_printk(KERN_ERR "gus: can't grab DMA1 %d\n", dma1);
-		snd_gus_free(gus);
 		return -EBUSY;
 	}
 	gus->gf1.dma1 = dma1;
 	if (dma2 >= 0 && dma1 != dma2) {
-		if (request_dma(dma2, "GUS - 2")) {
+		if (snd_devm_request_dma(card->dev, dma2, "GUS - 2")) {
 			snd_printk(KERN_ERR "gus: can't grab DMA2 %d\n", dma2);
-			snd_gus_free(gus);
 			return -EBUSY;
 		}
 		gus->gf1.dma2 = dma2;
@@ -218,10 +202,8 @@ int snd_gus_create(struct snd_card *card,
 	gus->gf1.volume_ramp = 25;
 	gus->gf1.smooth_pan = 1;
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, gus, &ops);
-	if (err < 0) {
-		snd_gus_free(gus);
+	if (err < 0)
 		return err;
-	}
 	*rgus = gus;
 	return 0;
 }
* Unmerged path sound/isa/gus/gusclassic.c
* Unmerged path sound/isa/gus/gusextreme.c
* Unmerged path sound/isa/gus/gusmax.c
* Unmerged path sound/isa/gus/interwave.c
