tee: optee: Fix incorrect page free bug

jira LE-1907
cve CVE-2021-44733
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Sumit Garg <sumit.garg@linaro.org>
commit 18549bf4b21c739a9def39f27dcac53e27286ab5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/18549bf4.failed

Pointer to the allocated pages (struct page *page) has already
progressed towards the end of allocation. It is incorrect to perform
__free_pages(page, order) using this pointer as we would free any
arbitrary pages. Fix this by stop modifying the page pointer.

Fixes: ec185dd3ab25 ("optee: Fix memory leak when failing to register shm pages")
	Cc: stable@vger.kernel.org
	Reported-by: Patrik Lantz <patrik.lantz@axis.com>
	Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
	Reviewed-by: Tyler Hicks <tyhicks@linux.microsoft.com>
	Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
(cherry picked from commit 18549bf4b21c739a9def39f27dcac53e27286ab5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tee/optee/core.c
diff --cc drivers/tee/optee/core.c
index 0491a41e8d58,2a66a5203d2f..000000000000
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@@ -26,199 -15,55 +26,204 @@@
  #include <linux/string.h>
  #include <linux/tee_drv.h>
  #include <linux/types.h>
 +#include <linux/uaccess.h>
  #include <linux/workqueue.h>
  #include "optee_private.h"
 +#include "optee_smc.h"
 +#include "shm_pool.h"
  
 -int optee_pool_op_alloc_helper(struct tee_shm_pool_mgr *poolm,
 -			       struct tee_shm *shm, size_t size,
 -			       int (*shm_register)(struct tee_context *ctx,
 -						   struct tee_shm *shm,
 -						   struct page **pages,
 -						   size_t num_pages,
 -						   unsigned long start))
 -{
 -	unsigned int order = get_order(size);
 -	struct page *page;
 -	int rc = 0;
 +#define DRIVER_NAME "optee"
  
 -	page = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
 -	if (!page)
 -		return -ENOMEM;
 +#define OPTEE_SHM_NUM_PRIV_PAGES	CONFIG_OPTEE_SHM_NUM_PRIV_PAGES
  
 -	shm->kaddr = page_address(page);
 -	shm->paddr = page_to_phys(page);
 -	shm->size = PAGE_SIZE << order;
 +/**
 + * optee_from_msg_param() - convert from OPTEE_MSG parameters to
 + *			    struct tee_param
 + * @params:	subsystem internal parameter representation
 + * @num_params:	number of elements in the parameter arrays
 + * @msg_params:	OPTEE_MSG parameters
 + * Returns 0 on success or <0 on failure
 + */
 +int optee_from_msg_param(struct tee_param *params, size_t num_params,
 +			 const struct optee_msg_param *msg_params)
 +{
 +	int rc;
 +	size_t n;
 +	struct tee_shm *shm;
 +	phys_addr_t pa;
 +
 +	for (n = 0; n < num_params; n++) {
 +		struct tee_param *p = params + n;
 +		const struct optee_msg_param *mp = msg_params + n;
 +		u32 attr = mp->attr & OPTEE_MSG_ATTR_TYPE_MASK;
 +
 +		switch (attr) {
 +		case OPTEE_MSG_ATTR_TYPE_NONE:
 +			p->attr = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
 +			memset(&p->u, 0, sizeof(p->u));
 +			break;
 +		case OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:
 +		case OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:
 +		case OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:
 +			p->attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT +
 +				  attr - OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;
 +			p->u.value.a = mp->u.value.a;
 +			p->u.value.b = mp->u.value.b;
 +			p->u.value.c = mp->u.value.c;
 +			break;
 +		case OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:
 +		case OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:
 +		case OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:
 +			p->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT +
 +				  attr - OPTEE_MSG_ATTR_TYPE_TMEM_INPUT;
 +			p->u.memref.size = mp->u.tmem.size;
 +			shm = (struct tee_shm *)(unsigned long)
 +				mp->u.tmem.shm_ref;
 +			if (!shm) {
 +				p->u.memref.shm_offs = 0;
 +				p->u.memref.shm = NULL;
 +				break;
 +			}
 +			rc = tee_shm_get_pa(shm, 0, &pa);
 +			if (rc)
 +				return rc;
 +			p->u.memref.shm_offs = mp->u.tmem.buf_ptr - pa;
 +			p->u.memref.shm = shm;
 +			break;
 +		case OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:
 +		case OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:
 +		case OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:
 +			p->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT +
 +				  attr - OPTEE_MSG_ATTR_TYPE_RMEM_INPUT;
 +			p->u.memref.size = mp->u.rmem.size;
 +			shm = (struct tee_shm *)(unsigned long)
 +				mp->u.rmem.shm_ref;
 +
 +			if (!shm) {
 +				p->u.memref.shm_offs = 0;
 +				p->u.memref.shm = NULL;
 +				break;
 +			}
 +			p->u.memref.shm_offs = mp->u.rmem.offs;
 +			p->u.memref.shm = shm;
  
 -	if (shm_register) {
 -		unsigned int nr_pages = 1 << order, i;
 -		struct page **pages;
 +			break;
  
 -		pages = kcalloc(nr_pages, sizeof(*pages), GFP_KERNEL);
 -		if (!pages) {
 -			rc = -ENOMEM;
 -			goto err;
 +		default:
 +			return -EINVAL;
  		}
 +	}
 +	return 0;
 +}
  
++<<<<<<< HEAD
 +static int to_msg_param_tmp_mem(struct optee_msg_param *mp,
 +				const struct tee_param *p)
 +{
 +	int rc;
 +	phys_addr_t pa;
++=======
+ 		for (i = 0; i < nr_pages; i++)
+ 			pages[i] = page + i;
++>>>>>>> 18549bf4b21c (tee: optee: Fix incorrect page free bug)
  
 -		shm->flags |= TEE_SHM_REGISTER;
 -		rc = shm_register(shm->ctx, shm, pages, nr_pages,
 -				  (unsigned long)shm->kaddr);
 -		kfree(pages);
 -		if (rc)
 -			goto err;
 +	mp->attr = OPTEE_MSG_ATTR_TYPE_TMEM_INPUT + p->attr -
 +		   TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
 +
 +	mp->u.tmem.shm_ref = (unsigned long)p->u.memref.shm;
 +	mp->u.tmem.size = p->u.memref.size;
 +
 +	if (!p->u.memref.shm) {
 +		mp->u.tmem.buf_ptr = 0;
 +		return 0;
  	}
  
 +	rc = tee_shm_get_pa(p->u.memref.shm, p->u.memref.shm_offs, &pa);
 +	if (rc)
 +		return rc;
 +
 +	mp->u.tmem.buf_ptr = pa;
 +	mp->attr |= OPTEE_MSG_ATTR_CACHE_PREDEFINED <<
 +		    OPTEE_MSG_ATTR_CACHE_SHIFT;
 +
  	return 0;
 +}
  
 -err:
 -	__free_pages(page, order);
 -	return rc;
 +static int to_msg_param_reg_mem(struct optee_msg_param *mp,
 +				const struct tee_param *p)
 +{
 +	mp->attr = OPTEE_MSG_ATTR_TYPE_RMEM_INPUT + p->attr -
 +		   TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
 +
 +	mp->u.rmem.shm_ref = (unsigned long)p->u.memref.shm;
 +	mp->u.rmem.size = p->u.memref.size;
 +	mp->u.rmem.offs = p->u.memref.shm_offs;
 +	return 0;
 +}
 +
 +/**
 + * optee_to_msg_param() - convert from struct tee_params to OPTEE_MSG parameters
 + * @msg_params:	OPTEE_MSG parameters
 + * @num_params:	number of elements in the parameter arrays
 + * @params:	subsystem itnernal parameter representation
 + * Returns 0 on success or <0 on failure
 + */
 +int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params,
 +		       const struct tee_param *params)
 +{
 +	int rc;
 +	size_t n;
 +
 +	for (n = 0; n < num_params; n++) {
 +		const struct tee_param *p = params + n;
 +		struct optee_msg_param *mp = msg_params + n;
 +
 +		switch (p->attr) {
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
 +			mp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;
 +			memset(&mp->u, 0, sizeof(mp->u));
 +			break;
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
 +			mp->attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT + p->attr -
 +				   TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
 +			mp->u.value.a = p->u.value.a;
 +			mp->u.value.b = p->u.value.b;
 +			mp->u.value.c = p->u.value.c;
 +			break;
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
 +		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
 +			if (tee_shm_is_registered(p->u.memref.shm))
 +				rc = to_msg_param_reg_mem(mp, p);
 +			else
 +				rc = to_msg_param_tmp_mem(mp, p);
 +			if (rc)
 +				return rc;
 +			break;
 +		default:
 +			return -EINVAL;
 +		}
 +	}
 +	return 0;
 +}
 +
 +static void optee_get_version(struct tee_device *teedev,
 +			      struct tee_ioctl_version_data *vers)
 +{
 +	struct tee_ioctl_version_data v = {
 +		.impl_id = TEE_IMPL_ID_OPTEE,
 +		.impl_caps = TEE_OPTEE_CAP_TZ,
 +		.gen_caps = TEE_GEN_CAP_GP,
 +	};
 +	struct optee *optee = tee_get_drvdata(teedev);
 +
 +	if (optee->sec_caps & OPTEE_SMC_SEC_CAP_DYNAMIC_SHM)
 +		v.gen_caps |= TEE_GEN_CAP_REG_MEM;
 +	if (optee->sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL)
 +		v.gen_caps |= TEE_GEN_CAP_MEMREF_NULL;
 +	*vers = v;
  }
  
  static void optee_bus_scan(struct work_struct *work)
* Unmerged path drivers/tee/optee/core.c
