ALSA: memalloc: Unify x86 SG-buffer handling (take#3)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 2c95b92ecd92e784785b1db8cccc4f0f2bfa850c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/2c95b92e.failed

This is a second attempt to unify the x86-specific SG-buffer handling
code with the new standard non-contiguous page handler.

The first try (in commit 2d9ea39917a4) failed due to the wrong page
and address calculations, hence reverted.  (And the second try failed
due to a copy&paste error.)  Now it's corrected with the previous fix
for noncontig pages, and the proper sg page iteration by this patch.

After the migration, SNDRV_DMA_TYPE_DMA_SG becomes identical with
SNDRV_DMA_TYPE_NONCONTIG on x86, while others still fall back to
SNDRV_DMA_TYPE_DEV.

	Tested-by: Alex Xu (Hello71) <alex_y_xu@yahoo.ca>
	Tested-by: Harald Arnesen <harald@skogtun.org>
Link: https://lore.kernel.org/r/20211017074859.24112-4-tiwai@suse.de
Link: https://lore.kernel.org/r/20211109062235.22310-1-tiwai@suse.de
Link: https://lore.kernel.org/r/20211116073358.19741-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 2c95b92ecd92e784785b1db8cccc4f0f2bfa850c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/memalloc.h
#	sound/core/memalloc.c
#	sound/core/sgbuf.c
diff --cc include/sound/memalloc.h
index 3ab084438fdc,653dfffb3ac8..000000000000
--- a/include/sound/memalloc.h
+++ b/include/sound/memalloc.h
@@@ -30,20 -35,22 +30,36 @@@ struct snd_dma_device 
  #define SNDRV_DMA_TYPE_UNKNOWN		0	/* not defined */
  #define SNDRV_DMA_TYPE_CONTINUOUS	1	/* continuous no-DMA memory */
  #define SNDRV_DMA_TYPE_DEV		2	/* generic device continuous */
++<<<<<<< HEAD
 +#define SNDRV_DMA_TYPE_DEV_UC		5	/* continuous non-cahced */
 +#ifdef CONFIG_SND_DMA_SGBUF
 +#define SNDRV_DMA_TYPE_DEV_SG		3	/* generic device SG-buffer */
 +#define SNDRV_DMA_TYPE_DEV_UC_SG	6	/* SG non-cached */
 +#else
 +#define SNDRV_DMA_TYPE_DEV_SG	SNDRV_DMA_TYPE_DEV /* no SG-buf support */
 +#define SNDRV_DMA_TYPE_DEV_UC_SG	SNDRV_DMA_TYPE_DEV_UC
 +#endif
++=======
+ #define SNDRV_DMA_TYPE_DEV_WC		5	/* continuous write-combined */
++>>>>>>> 2c95b92ecd92 (ALSA: memalloc: Unify x86 SG-buffer handling (take#3))
  #ifdef CONFIG_GENERIC_ALLOCATOR
  #define SNDRV_DMA_TYPE_DEV_IRAM		4	/* generic device iram-buffer */
  #else
  #define SNDRV_DMA_TYPE_DEV_IRAM	SNDRV_DMA_TYPE_DEV
  #endif
  #define SNDRV_DMA_TYPE_VMALLOC		7	/* vmalloc'ed buffer */
++<<<<<<< HEAD
++=======
+ #define SNDRV_DMA_TYPE_NONCONTIG	8	/* non-coherent SG buffer */
+ #define SNDRV_DMA_TYPE_NONCOHERENT	9	/* non-coherent buffer */
+ #ifdef CONFIG_SND_DMA_SGBUF
+ #define SNDRV_DMA_TYPE_DEV_SG		SNDRV_DMA_TYPE_NONCONTIG
+ #define SNDRV_DMA_TYPE_DEV_WC_SG	6	/* SG write-combined */
+ #else
+ #define SNDRV_DMA_TYPE_DEV_SG	SNDRV_DMA_TYPE_DEV /* no SG-buf support */
+ #define SNDRV_DMA_TYPE_DEV_WC_SG	SNDRV_DMA_TYPE_DEV_WC
+ #endif
++>>>>>>> 2c95b92ecd92 (ALSA: memalloc: Unify x86 SG-buffer handling (take#3))
  
  /*
   * info for buffer allocation
diff --cc sound/core/memalloc.c
index 369f77b4aaf4,d1fcd1d5adae..000000000000
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@@ -226,32 -120,626 +226,652 @@@ EXPORT_SYMBOL(snd_dma_alloc_pages_fallb
   */
  void snd_dma_free_pages(struct snd_dma_buffer *dmab)
  {
 -	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
 -
 -	if (ops && ops->free)
 -		ops->free(dmab);
 +	switch (dmab->dev.type) {
 +	case SNDRV_DMA_TYPE_CONTINUOUS:
 +		free_pages_exact(dmab->area, dmab->bytes);
 +		break;
 +	case SNDRV_DMA_TYPE_VMALLOC:
 +		vfree(dmab->area);
 +		break;
 +#ifdef CONFIG_HAS_DMA
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +	case SNDRV_DMA_TYPE_DEV_IRAM:
 +		snd_free_dev_iram(dmab);
 +		break;
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +	case SNDRV_DMA_TYPE_DEV:
 +	case SNDRV_DMA_TYPE_DEV_UC:
 +		snd_free_dev_pages(dmab);
 +		break;
 +#endif
 +#ifdef CONFIG_SND_DMA_SGBUF
 +	case SNDRV_DMA_TYPE_DEV_SG:
 +	case SNDRV_DMA_TYPE_DEV_UC_SG:
 +		snd_free_sgbuf_pages(dmab);
 +		break;
 +#endif
 +	default:
 +		pr_err("snd-malloc: invalid device type %d\n", dmab->dev.type);
 +	}
  }
  EXPORT_SYMBOL(snd_dma_free_pages);
++<<<<<<< HEAD
++=======
+ 
+ /* called by devres */
+ static void __snd_release_pages(struct device *dev, void *res)
+ {
+ 	snd_dma_free_pages(res);
+ }
+ 
+ /**
+  * snd_devm_alloc_dir_pages - allocate the buffer and manage with devres
+  * @dev: the device pointer
+  * @type: the DMA buffer type
+  * @dir: DMA direction
+  * @size: the buffer size to allocate
+  *
+  * Allocate buffer pages depending on the given type and manage using devres.
+  * The pages will be released automatically at the device removal.
+  *
+  * Unlike snd_dma_alloc_pages(), this function requires the real device pointer,
+  * hence it can't work with SNDRV_DMA_TYPE_CONTINUOUS or
+  * SNDRV_DMA_TYPE_VMALLOC type.
+  *
+  * The function returns the snd_dma_buffer object at success, or NULL if failed.
+  */
+ struct snd_dma_buffer *
+ snd_devm_alloc_dir_pages(struct device *dev, int type,
+ 			 enum dma_data_direction dir, size_t size)
+ {
+ 	struct snd_dma_buffer *dmab;
+ 	int err;
+ 
+ 	if (WARN_ON(type == SNDRV_DMA_TYPE_CONTINUOUS ||
+ 		    type == SNDRV_DMA_TYPE_VMALLOC))
+ 		return NULL;
+ 
+ 	dmab = devres_alloc(__snd_release_pages, sizeof(*dmab), GFP_KERNEL);
+ 	if (!dmab)
+ 		return NULL;
+ 
+ 	err = snd_dma_alloc_dir_pages(type, dev, dir, size, dmab);
+ 	if (err < 0) {
+ 		devres_free(dmab);
+ 		return NULL;
+ 	}
+ 
+ 	devres_add(dev, dmab);
+ 	return dmab;
+ }
+ EXPORT_SYMBOL_GPL(snd_devm_alloc_dir_pages);
+ 
+ /**
+  * snd_dma_buffer_mmap - perform mmap of the given DMA buffer
+  * @dmab: buffer allocation information
+  * @area: VM area information
+  */
+ int snd_dma_buffer_mmap(struct snd_dma_buffer *dmab,
+ 			struct vm_area_struct *area)
+ {
+ 	const struct snd_malloc_ops *ops;
+ 
+ 	if (!dmab)
+ 		return -ENOENT;
+ 	ops = snd_dma_get_ops(dmab);
+ 	if (ops && ops->mmap)
+ 		return ops->mmap(dmab, area);
+ 	else
+ 		return -ENOENT;
+ }
+ EXPORT_SYMBOL(snd_dma_buffer_mmap);
+ 
+ #ifdef CONFIG_HAS_DMA
+ /**
+  * snd_dma_buffer_sync - sync DMA buffer between CPU and device
+  * @dmab: buffer allocation information
+  * @mode: sync mode
+  */
+ void snd_dma_buffer_sync(struct snd_dma_buffer *dmab,
+ 			 enum snd_dma_sync_mode mode)
+ {
+ 	const struct snd_malloc_ops *ops;
+ 
+ 	if (!dmab || !dmab->dev.need_sync)
+ 		return;
+ 	ops = snd_dma_get_ops(dmab);
+ 	if (ops && ops->sync)
+ 		ops->sync(dmab, mode);
+ }
+ EXPORT_SYMBOL_GPL(snd_dma_buffer_sync);
+ #endif /* CONFIG_HAS_DMA */
+ 
+ /**
+  * snd_sgbuf_get_addr - return the physical address at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_addr)
+ 		return ops->get_addr(dmab, offset);
+ 	else
+ 		return dmab->addr + offset;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_addr);
+ 
+ /**
+  * snd_sgbuf_get_page - return the physical page at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ struct page *snd_sgbuf_get_page(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_page)
+ 		return ops->get_page(dmab, offset);
+ 	else
+ 		return virt_to_page(dmab->area + offset);
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_page);
+ 
+ /**
+  * snd_sgbuf_get_chunk_size - compute the max chunk size with continuous pages
+  *	on sg-buffer
+  * @dmab: buffer allocation information
+  * @ofs: offset in the ring buffer
+  * @size: the requested size
+  */
+ unsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,
+ 				      unsigned int ofs, unsigned int size)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_chunk_size)
+ 		return ops->get_chunk_size(dmab, ofs, size);
+ 	else
+ 		return size;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_chunk_size);
+ 
+ /*
+  * Continuous pages allocator
+  */
+ static void *snd_dma_continuous_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL);
+ 	void *p = alloc_pages_exact(size, gfp);
+ 
+ 	if (p)
+ 		dmab->addr = page_to_phys(virt_to_page(p));
+ 	return p;
+ }
+ 
+ static void snd_dma_continuous_free(struct snd_dma_buffer *dmab)
+ {
+ 	free_pages_exact(dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_continuous_mmap(struct snd_dma_buffer *dmab,
+ 				   struct vm_area_struct *area)
+ {
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       dmab->addr >> PAGE_SHIFT,
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_continuous_ops = {
+ 	.alloc = snd_dma_continuous_alloc,
+ 	.free = snd_dma_continuous_free,
+ 	.mmap = snd_dma_continuous_mmap,
+ };
+ 
+ /*
+  * VMALLOC allocator
+  */
+ static void *snd_dma_vmalloc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL | __GFP_HIGHMEM);
+ 
+ 	return __vmalloc(size, gfp);
+ }
+ 
+ static void snd_dma_vmalloc_free(struct snd_dma_buffer *dmab)
+ {
+ 	vfree(dmab->area);
+ }
+ 
+ static int snd_dma_vmalloc_mmap(struct snd_dma_buffer *dmab,
+ 				struct vm_area_struct *area)
+ {
+ 	return remap_vmalloc_range(area, dmab->area, 0);
+ }
+ 
+ #define get_vmalloc_page_addr(dmab, offset) \
+ 	page_to_phys(vmalloc_to_page((dmab)->area + (offset)))
+ 
+ static dma_addr_t snd_dma_vmalloc_get_addr(struct snd_dma_buffer *dmab,
+ 					   size_t offset)
+ {
+ 	return get_vmalloc_page_addr(dmab, offset) + offset % PAGE_SIZE;
+ }
+ 
+ static struct page *snd_dma_vmalloc_get_page(struct snd_dma_buffer *dmab,
+ 					     size_t offset)
+ {
+ 	return vmalloc_to_page(dmab->area + offset);
+ }
+ 
+ static unsigned int
+ snd_dma_vmalloc_get_chunk_size(struct snd_dma_buffer *dmab,
+ 			       unsigned int ofs, unsigned int size)
+ {
+ 	unsigned int start, end;
+ 	unsigned long addr;
+ 
+ 	start = ALIGN_DOWN(ofs, PAGE_SIZE);
+ 	end = ofs + size - 1; /* the last byte address */
+ 	/* check page continuity */
+ 	addr = get_vmalloc_page_addr(dmab, start);
+ 	for (;;) {
+ 		start += PAGE_SIZE;
+ 		if (start > end)
+ 			break;
+ 		addr += PAGE_SIZE;
+ 		if (get_vmalloc_page_addr(dmab, start) != addr)
+ 			return start - ofs;
+ 	}
+ 	/* ok, all on continuous pages */
+ 	return size;
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_vmalloc_ops = {
+ 	.alloc = snd_dma_vmalloc_alloc,
+ 	.free = snd_dma_vmalloc_free,
+ 	.mmap = snd_dma_vmalloc_mmap,
+ 	.get_addr = snd_dma_vmalloc_get_addr,
+ 	.get_page = snd_dma_vmalloc_get_page,
+ 	.get_chunk_size = snd_dma_vmalloc_get_chunk_size,
+ };
+ 
+ #ifdef CONFIG_HAS_DMA
+ /*
+  * IRAM allocator
+  */
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ static void *snd_dma_iram_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	struct device *dev = dmab->dev.dev;
+ 	struct gen_pool *pool;
+ 	void *p;
+ 
+ 	if (dev->of_node) {
+ 		pool = of_gen_pool_get(dev->of_node, "iram", 0);
+ 		/* Assign the pool into private_data field */
+ 		dmab->private_data = pool;
+ 
+ 		p = gen_pool_dma_alloc_align(pool, size, &dmab->addr, PAGE_SIZE);
+ 		if (p)
+ 			return p;
+ 	}
+ 
+ 	/* Internal memory might have limited size and no enough space,
+ 	 * so if we fail to malloc, try to fetch memory traditionally.
+ 	 */
+ 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+ 	return __snd_dma_alloc_pages(dmab, size);
+ }
+ 
+ static void snd_dma_iram_free(struct snd_dma_buffer *dmab)
+ {
+ 	struct gen_pool *pool = dmab->private_data;
+ 
+ 	if (pool && dmab->area)
+ 		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_iram_mmap(struct snd_dma_buffer *dmab,
+ 			     struct vm_area_struct *area)
+ {
+ 	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       dmab->addr >> PAGE_SHIFT,
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_iram_ops = {
+ 	.alloc = snd_dma_iram_alloc,
+ 	.free = snd_dma_iram_free,
+ 	.mmap = snd_dma_iram_mmap,
+ };
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ 
+ #define DEFAULT_GFP \
+ 	(GFP_KERNEL | \
+ 	 __GFP_COMP |    /* compound page lets parts be mapped */ \
+ 	 __GFP_NORETRY | /* don't trigger OOM-killer */ \
+ 	 __GFP_NOWARN)   /* no stack trace print - this call is non-critical */
+ 
+ /*
+  * Coherent device pages allocator
+  */
+ static void *snd_dma_dev_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	void *p;
+ 
+ 	p = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr, DEFAULT_GFP);
+ #ifdef CONFIG_X86
+ 	if (p && dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC)
+ 		set_memory_wc((unsigned long)p, PAGE_ALIGN(size) >> PAGE_SHIFT);
+ #endif
+ 	return p;
+ }
+ 
+ static void snd_dma_dev_free(struct snd_dma_buffer *dmab)
+ {
+ #ifdef CONFIG_X86
+ 	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC)
+ 		set_memory_wb((unsigned long)dmab->area,
+ 			      PAGE_ALIGN(dmab->bytes) >> PAGE_SHIFT);
+ #endif
+ 	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+ }
+ 
+ static int snd_dma_dev_mmap(struct snd_dma_buffer *dmab,
+ 			    struct vm_area_struct *area)
+ {
+ #ifdef CONFIG_X86
+ 	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC)
+ 		area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ #endif
+ 	return dma_mmap_coherent(dmab->dev.dev, area,
+ 				 dmab->area, dmab->addr, dmab->bytes);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_dev_ops = {
+ 	.alloc = snd_dma_dev_alloc,
+ 	.free = snd_dma_dev_free,
+ 	.mmap = snd_dma_dev_mmap,
+ };
+ 
+ /*
+  * Write-combined pages
+  */
+ #ifdef CONFIG_X86
+ /* On x86, share the same ops as the standard dev ops */
+ #define snd_dma_wc_ops	snd_dma_dev_ops
+ #else /* CONFIG_X86 */
+ static void *snd_dma_wc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	return dma_alloc_wc(dmab->dev.dev, size, &dmab->addr, DEFAULT_GFP);
+ }
+ 
+ static void snd_dma_wc_free(struct snd_dma_buffer *dmab)
+ {
+ 	dma_free_wc(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+ }
+ 
+ static int snd_dma_wc_mmap(struct snd_dma_buffer *dmab,
+ 			   struct vm_area_struct *area)
+ {
+ 	return dma_mmap_wc(dmab->dev.dev, area,
+ 			   dmab->area, dmab->addr, dmab->bytes);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_wc_ops = {
+ 	.alloc = snd_dma_wc_alloc,
+ 	.free = snd_dma_wc_free,
+ 	.mmap = snd_dma_wc_mmap,
+ };
+ #endif /* CONFIG_X86 */
+ 
+ /*
+  * Non-contiguous pages allocator
+  */
+ static void *snd_dma_noncontig_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	struct sg_table *sgt;
+ 	void *p;
+ 
+ 	sgt = dma_alloc_noncontiguous(dmab->dev.dev, size, dmab->dev.dir,
+ 				      DEFAULT_GFP, 0);
+ 	if (!sgt)
+ 		return NULL;
+ 	dmab->dev.need_sync = dma_need_sync(dmab->dev.dev, dmab->dev.dir);
+ 	p = dma_vmap_noncontiguous(dmab->dev.dev, size, sgt);
+ 	if (p)
+ 		dmab->private_data = sgt;
+ 	else
+ 		dma_free_noncontiguous(dmab->dev.dev, size, sgt, dmab->dev.dir);
+ 	return p;
+ }
+ 
+ static void snd_dma_noncontig_free(struct snd_dma_buffer *dmab)
+ {
+ 	dma_vunmap_noncontiguous(dmab->dev.dev, dmab->area);
+ 	dma_free_noncontiguous(dmab->dev.dev, dmab->bytes, dmab->private_data,
+ 			       dmab->dev.dir);
+ }
+ 
+ static int snd_dma_noncontig_mmap(struct snd_dma_buffer *dmab,
+ 				  struct vm_area_struct *area)
+ {
+ 	return dma_mmap_noncontiguous(dmab->dev.dev, area,
+ 				      dmab->bytes, dmab->private_data);
+ }
+ 
+ static void snd_dma_noncontig_sync(struct snd_dma_buffer *dmab,
+ 				   enum snd_dma_sync_mode mode)
+ {
+ 	if (mode == SNDRV_DMA_SYNC_CPU) {
+ 		if (dmab->dev.dir == DMA_TO_DEVICE)
+ 			return;
+ 		dma_sync_sgtable_for_cpu(dmab->dev.dev, dmab->private_data,
+ 					 dmab->dev.dir);
+ 		invalidate_kernel_vmap_range(dmab->area, dmab->bytes);
+ 	} else {
+ 		if (dmab->dev.dir == DMA_FROM_DEVICE)
+ 			return;
+ 		flush_kernel_vmap_range(dmab->area, dmab->bytes);
+ 		dma_sync_sgtable_for_device(dmab->dev.dev, dmab->private_data,
+ 					    dmab->dev.dir);
+ 	}
+ }
+ 
+ static inline void snd_dma_noncontig_iter_set(struct snd_dma_buffer *dmab,
+ 					      struct sg_page_iter *piter,
+ 					      size_t offset)
+ {
+ 	struct sg_table *sgt = dmab->private_data;
+ 
+ 	__sg_page_iter_start(piter, sgt->sgl, sgt->orig_nents,
+ 			     offset >> PAGE_SHIFT);
+ }
+ 
+ static dma_addr_t snd_dma_noncontig_get_addr(struct snd_dma_buffer *dmab,
+ 					     size_t offset)
+ {
+ 	struct sg_dma_page_iter iter;
+ 
+ 	snd_dma_noncontig_iter_set(dmab, &iter.base, offset);
+ 	__sg_page_iter_dma_next(&iter);
+ 	return sg_page_iter_dma_address(&iter) + offset % PAGE_SIZE;
+ }
+ 
+ static struct page *snd_dma_noncontig_get_page(struct snd_dma_buffer *dmab,
+ 					       size_t offset)
+ {
+ 	struct sg_page_iter iter;
+ 
+ 	snd_dma_noncontig_iter_set(dmab, &iter, offset);
+ 	__sg_page_iter_next(&iter);
+ 	return sg_page_iter_page(&iter);
+ }
+ 
+ static unsigned int
+ snd_dma_noncontig_get_chunk_size(struct snd_dma_buffer *dmab,
+ 				 unsigned int ofs, unsigned int size)
+ {
+ 	struct sg_dma_page_iter iter;
+ 	unsigned int start, end;
+ 	unsigned long addr;
+ 
+ 	start = ALIGN_DOWN(ofs, PAGE_SIZE);
+ 	end = ofs + size - 1; /* the last byte address */
+ 	snd_dma_noncontig_iter_set(dmab, &iter.base, start);
+ 	if (!__sg_page_iter_dma_next(&iter))
+ 		return 0;
+ 	/* check page continuity */
+ 	addr = sg_page_iter_dma_address(&iter);
+ 	for (;;) {
+ 		start += PAGE_SIZE;
+ 		if (start > end)
+ 			break;
+ 		addr += PAGE_SIZE;
+ 		if (!__sg_page_iter_dma_next(&iter) ||
+ 		    sg_page_iter_dma_address(&iter) != addr)
+ 			return start - ofs;
+ 	}
+ 	/* ok, all on continuous pages */
+ 	return size;
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_noncontig_ops = {
+ 	.alloc = snd_dma_noncontig_alloc,
+ 	.free = snd_dma_noncontig_free,
+ 	.mmap = snd_dma_noncontig_mmap,
+ 	.sync = snd_dma_noncontig_sync,
+ 	.get_addr = snd_dma_noncontig_get_addr,
+ 	.get_page = snd_dma_noncontig_get_page,
+ 	.get_chunk_size = snd_dma_noncontig_get_chunk_size,
+ };
+ 
+ /* x86-specific SG-buffer with WC pages */
+ #ifdef CONFIG_SND_DMA_SGBUF
+ #define sg_wc_address(it) ((unsigned long)page_address(sg_page_iter_page(it)))
+ 
+ static void *snd_dma_sg_wc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	void *p = snd_dma_noncontig_alloc(dmab, size);
+ 	struct sg_table *sgt = dmab->private_data;
+ 	struct sg_page_iter iter;
+ 
+ 	if (!p)
+ 		return NULL;
+ 	for_each_sgtable_page(sgt, &iter, 0)
+ 		set_memory_wc(sg_wc_address(&iter), 1);
+ 	return p;
+ }
+ 
+ static void snd_dma_sg_wc_free(struct snd_dma_buffer *dmab)
+ {
+ 	struct sg_table *sgt = dmab->private_data;
+ 	struct sg_page_iter iter;
+ 
+ 	for_each_sgtable_page(sgt, &iter, 0)
+ 		set_memory_wb(sg_wc_address(&iter), 1);
+ 	snd_dma_noncontig_free(dmab);
+ }
+ 
+ static int snd_dma_sg_wc_mmap(struct snd_dma_buffer *dmab,
+ 			      struct vm_area_struct *area)
+ {
+ 	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ 	return dma_mmap_noncontiguous(dmab->dev.dev, area,
+ 				      dmab->bytes, dmab->private_data);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_sg_wc_ops = {
+ 	.alloc = snd_dma_sg_wc_alloc,
+ 	.free = snd_dma_sg_wc_free,
+ 	.mmap = snd_dma_sg_wc_mmap,
+ 	.sync = snd_dma_noncontig_sync,
+ 	.get_addr = snd_dma_noncontig_get_addr,
+ 	.get_page = snd_dma_noncontig_get_page,
+ 	.get_chunk_size = snd_dma_noncontig_get_chunk_size,
+ };
+ #endif /* CONFIG_SND_DMA_SGBUF */
+ 
+ /*
+  * Non-coherent pages allocator
+  */
+ static void *snd_dma_noncoherent_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	dmab->dev.need_sync = dma_need_sync(dmab->dev.dev, dmab->dev.dir);
+ 	return dma_alloc_noncoherent(dmab->dev.dev, size, &dmab->addr,
+ 				     dmab->dev.dir, DEFAULT_GFP);
+ }
+ 
+ static void snd_dma_noncoherent_free(struct snd_dma_buffer *dmab)
+ {
+ 	dma_free_noncoherent(dmab->dev.dev, dmab->bytes, dmab->area,
+ 			     dmab->addr, dmab->dev.dir);
+ }
+ 
+ static int snd_dma_noncoherent_mmap(struct snd_dma_buffer *dmab,
+ 				    struct vm_area_struct *area)
+ {
+ 	area->vm_page_prot = vm_get_page_prot(area->vm_flags);
+ 	return dma_mmap_pages(dmab->dev.dev, area,
+ 			      area->vm_end - area->vm_start,
+ 			      virt_to_page(dmab->area));
+ }
+ 
+ static void snd_dma_noncoherent_sync(struct snd_dma_buffer *dmab,
+ 				     enum snd_dma_sync_mode mode)
+ {
+ 	if (mode == SNDRV_DMA_SYNC_CPU) {
+ 		if (dmab->dev.dir != DMA_TO_DEVICE)
+ 			dma_sync_single_for_cpu(dmab->dev.dev, dmab->addr,
+ 						dmab->bytes, dmab->dev.dir);
+ 	} else {
+ 		if (dmab->dev.dir != DMA_FROM_DEVICE)
+ 			dma_sync_single_for_device(dmab->dev.dev, dmab->addr,
+ 						   dmab->bytes, dmab->dev.dir);
+ 	}
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_noncoherent_ops = {
+ 	.alloc = snd_dma_noncoherent_alloc,
+ 	.free = snd_dma_noncoherent_free,
+ 	.mmap = snd_dma_noncoherent_mmap,
+ 	.sync = snd_dma_noncoherent_sync,
+ };
+ 
+ #endif /* CONFIG_HAS_DMA */
+ 
+ /*
+  * Entry points
+  */
+ static const struct snd_malloc_ops *dma_ops[] = {
+ 	[SNDRV_DMA_TYPE_CONTINUOUS] = &snd_dma_continuous_ops,
+ 	[SNDRV_DMA_TYPE_VMALLOC] = &snd_dma_vmalloc_ops,
+ #ifdef CONFIG_HAS_DMA
+ 	[SNDRV_DMA_TYPE_DEV] = &snd_dma_dev_ops,
+ 	[SNDRV_DMA_TYPE_DEV_WC] = &snd_dma_wc_ops,
+ 	[SNDRV_DMA_TYPE_NONCONTIG] = &snd_dma_noncontig_ops,
+ 	[SNDRV_DMA_TYPE_NONCOHERENT] = &snd_dma_noncoherent_ops,
+ #ifdef CONFIG_SND_DMA_SGBUF
+ 	[SNDRV_DMA_TYPE_DEV_WC_SG] = &snd_dma_sg_wc_ops,
+ #endif
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ 	[SNDRV_DMA_TYPE_DEV_IRAM] = &snd_dma_iram_ops,
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ #endif /* CONFIG_HAS_DMA */
+ };
+ 
+ static const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab)
+ {
+ 	if (WARN_ON_ONCE(!dmab))
+ 		return NULL;
+ 	if (WARN_ON_ONCE(dmab->dev.type <= SNDRV_DMA_TYPE_UNKNOWN ||
+ 			 dmab->dev.type >= ARRAY_SIZE(dma_ops)))
+ 		return NULL;
+ 	return dma_ops[dmab->dev.type];
+ }
++>>>>>>> 2c95b92ecd92 (ALSA: memalloc: Unify x86 SG-buffer handling (take#3))
* Unmerged path sound/core/sgbuf.c
* Unmerged path include/sound/memalloc.h
diff --git a/sound/core/Makefile b/sound/core/Makefile
index 79e1407cd0de..350d704ced98 100644
--- a/sound/core/Makefile
+++ b/sound/core/Makefile
@@ -19,7 +19,6 @@ snd-$(CONFIG_SND_JACK)	  += ctljack.o jack.o
 snd-pcm-y := pcm.o pcm_native.o pcm_lib.o pcm_misc.o \
 		pcm_memory.o memalloc.o
 snd-pcm-$(CONFIG_SND_PCM_TIMER) += pcm_timer.o
-snd-pcm-$(CONFIG_SND_DMA_SGBUF) += sgbuf.o
 snd-pcm-$(CONFIG_SND_PCM_ELD) += pcm_drm_eld.o
 snd-pcm-$(CONFIG_SND_PCM_IEC958) += pcm_iec958.o
 
* Unmerged path sound/core/memalloc.c
* Unmerged path sound/core/sgbuf.c
