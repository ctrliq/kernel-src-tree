ice: Use xdp_buf instead of rx_buf for xsk zero-copy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 57f7f8b6bc0bc80d94443f94fe5f21f266499a2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/57f7f8b6.failed

In order to use the new xsk batched buffer allocation interface, a
pointer to an array of struct xsk_buff pointers need to be provided so
that the function can put the result of the allocation there. In the
ice driver, we already have a ring that stores pointers to
xdp_buffs. This is only used for the xsk zero-copy driver and is a
union with the structure that is used for the regular non zero-copy
path. Unfortunately, that structure is larger than the xdp_buffs
pointers which mean that there will be a stride (of 20 bytes) between
each xdp_buff pointer. And feeding this into the xsk_buff_alloc_batch
interface will not work since it assumes a regular array of xdp_buff
pointers (each 8 bytes with 0 bytes in-between them on a 64-bit
system).

To fix this, remove the xdp_buff pointer from the rx_buf union and
move it one step higher to the union above which only has pointers to
arrays in it. This solves the problem and we can directly feed the SW
ring of xdp_buff pointers straight into the allocation function in the
next patch when that interface is used. This will improve performance.

	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20210922075613.12186-4-magnus.karlsson@gmail.com
(cherry picked from commit 57f7f8b6bc0bc80d94443f94fe5f21f266499a2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_xsk.c
diff --cc drivers/net/ethernet/intel/ice/ice_xsk.c
index 295bfdac4d32,f4ab5259a56c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_xsk.c
+++ b/drivers/net/ethernet/intel/ice/ice_xsk.c
@@@ -431,12 -428,12 +431,16 @@@ static void ice_bump_ntc(struct ice_rx_
   * Returns the skb on success, NULL on failure.
   */
  static struct sk_buff *
++<<<<<<< HEAD
 +ice_construct_skb_zc(struct ice_rx_ring *rx_ring, struct ice_rx_buf *rx_buf)
++=======
+ ice_construct_skb_zc(struct ice_ring *rx_ring, struct xdp_buff **xdp_arr)
++>>>>>>> 57f7f8b6bc0b (ice: Use xdp_buf instead of rx_buf for xsk zero-copy)
  {
- 	unsigned int metasize = rx_buf->xdp->data - rx_buf->xdp->data_meta;
- 	unsigned int datasize = rx_buf->xdp->data_end - rx_buf->xdp->data;
- 	unsigned int datasize_hard = rx_buf->xdp->data_end -
- 				     rx_buf->xdp->data_hard_start;
+ 	struct xdp_buff *xdp = *xdp_arr;
+ 	unsigned int metasize = xdp->data - xdp->data_meta;
+ 	unsigned int datasize = xdp->data_end - xdp->data;
+ 	unsigned int datasize_hard = xdp->data_end - xdp->data_hard_start;
  	struct sk_buff *skb;
  
  	skb = __napi_alloc_skb(&rx_ring->q_vector->napi, datasize_hard,
diff --git a/drivers/net/ethernet/intel/ice/ice_txrx.h b/drivers/net/ethernet/intel/ice/ice_txrx.h
index 65020bffafd4..c0c03d1dbc51 100644
--- a/drivers/net/ethernet/intel/ice/ice_txrx.h
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.h
@@ -164,17 +164,10 @@ struct ice_tx_offload_params {
 };
 
 struct ice_rx_buf {
-	union {
-		struct {
-			dma_addr_t dma;
-			struct page *page;
-			unsigned int page_offset;
-			u16 pagecnt_bias;
-		};
-		struct {
-			struct xdp_buff *xdp;
-		};
-	};
+	dma_addr_t dma;
+	struct page *page;
+	unsigned int page_offset;
+	u16 pagecnt_bias;
 };
 
 struct ice_q_stats {
@@ -269,6 +262,7 @@ struct ice_rx_ring {
 	u8 __iomem *tail;
 	union {
 		struct ice_rx_buf *rx_buf;
+		struct xdp_buff **xdp_buf;
 	};
 	/* CL2 - 2nd cacheline starts here */
 	struct xdp_rxq_info xdp_rxq;
* Unmerged path drivers/net/ethernet/intel/ice/ice_xsk.c
