ice: Remove excess error variables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Tony Nguyen <anthony.l.nguyen@intel.com>
commit 2ccc1c1ccc671b8bb33ad7845dcf6c75d3c892ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/2ccc1c1c.failed

ice_status previously had a variable to contain these values where other
error codes had a variable as well. With ice_status now being an int,
there is no need for two variables to hold error values. In cases where
this occurs, remove one of the excess variables and use a single one.
Some initialization of variables are no longer needed and have been
removed.

	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
(cherry picked from commit 2ccc1c1ccc671b8bb33ad7845dcf6c75d3c892ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_common.c
#	drivers/net/ethernet/intel/ice/ice_devlink.c
#	drivers/net/ethernet/intel/ice/ice_ethtool.c
#	drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
#	drivers/net/ethernet/intel/ice/ice_fw_update.c
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_tc_lib.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice_common.c
index 1c7ece0676d5,cc8297e1db3a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_common.c
+++ b/drivers/net/ethernet/intel/ice/ice_common.c
@@@ -4482,12 -4495,10 +4482,17 @@@ ice_ena_vsi_rdma_qset(struct ice_port_i
  	node.data.elem_type = ICE_AQC_ELEM_TYPE_LEAF;
  	for (i = 0; i < num_qsets; i++) {
  		node.node_teid = buf->rdma_qsets[i].qset_teid;
++<<<<<<< HEAD
 +		status = ice_sched_add_node(pi, hw->num_tx_sched_layers - 1,
 +					    &node);
 +		if (status) {
 +			ret = ice_status_to_errno(status);
++=======
+ 		ret = ice_sched_add_node(pi, hw->num_tx_sched_layers - 1,
+ 					 &node);
+ 		if (ret)
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  			break;
- 		}
  		qset_teid[i] = le32_to_cpu(node.node_teid);
  	}
  rdma_error_exit:
diff --cc drivers/net/ethernet/intel/ice/ice_devlink.c
index 212d0917749d,50003331addc..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_devlink.c
+++ b/drivers/net/ethernet/intel/ice/ice_devlink.c
@@@ -251,7 -251,6 +251,10 @@@ static int ice_devlink_info_get(struct 
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
  	struct ice_info_ctx *ctx;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	size_t i;
  	int err;
  
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool.c
index be50950576d4,71869c2b2390..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@@ -261,9 -270,8 +261,13 @@@ ice_get_eeprom(struct net_device *netde
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
 +	enum ice_status status;
  	struct device *dev;
++<<<<<<< HEAD
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	u8 *buf;
  
  	dev = ice_pf_to_dev(pf);
@@@ -276,21 -284,19 +280,29 @@@
  	if (!buf)
  		return -ENOMEM;
  
- 	status = ice_acquire_nvm(hw, ICE_RES_READ);
- 	if (status) {
+ 	ret = ice_acquire_nvm(hw, ICE_RES_READ);
+ 	if (ret) {
  		dev_err(dev, "ice_acquire_nvm failed, err %d aq_err %s\n",
++<<<<<<< HEAD
 +			status,
 +			ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			ret, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		ret = -EIO;
  		goto out;
  	}
  
- 	status = ice_read_flat_nvm(hw, eeprom->offset, &eeprom->len, buf,
- 				   false);
- 	if (status) {
+ 	ret = ice_read_flat_nvm(hw, eeprom->offset, &eeprom->len, buf,
+ 				false);
+ 	if (ret) {
  		dev_err(dev, "ice_read_flat_nvm failed, err %d aq_err %s\n",
++<<<<<<< HEAD
 +			status,
 +			ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			ret, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		ret = -EIO;
  		goto release;
  	}
@@@ -1054,8 -1049,7 +1066,12 @@@ ice_get_fecparam(struct net_device *net
  	struct ice_link_status *link_info;
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_port_info *pi;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	pi = vsi->port_info;
  
@@@ -1929,8 -1934,7 +1945,12 @@@ ice_get_link_ksettings(struct net_devic
  	struct ice_aqc_get_phy_caps_data *caps;
  	struct ice_link_status *hw_link_info;
  	struct ice_vsi *vsi = np->vsi;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	ethtool_link_ksettings_zero_link_mode(ks, supported);
  	ethtool_link_ksettings_zero_link_mode(ks, advertising);
@@@ -2201,11 -2205,10 +2221,14 @@@ ice_set_link_ksettings(struct net_devic
  	struct ice_pf *pf = np->vsi->back;
  	struct ice_port_info *pi;
  	u8 autoneg_changed = 0;
 +	enum ice_status status;
  	u64 phy_type_high = 0;
  	u64 phy_type_low = 0;
- 	int err = 0;
  	bool linkup;
++<<<<<<< HEAD
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	pi = np->vsi->port_info;
  
@@@ -2990,11 -2997,10 +3013,15 @@@ ice_set_pauseparam(struct net_device *n
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_hw *hw = &pf->hw;
  	struct ice_port_info *pi;
 +	enum ice_status status;
  	u8 aq_failures;
  	bool link_up;
++<<<<<<< HEAD
 +	int err = 0;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	u32 is_an;
+ 	int err;
  
  	pi = vsi->port_info;
  	hw_link_info = &pi->phy.link_info;
@@@ -3064,18 -3070,15 +3091,30 @@@
  
  	if (aq_failures & ICE_SET_FC_AQ_FAIL_GET) {
  		netdev_info(netdev, "Set fc failed on the get_phy_capabilities call with err %d aq_err %s\n",
++<<<<<<< HEAD
 +			    status,
 +			    ice_aq_str(hw->adminq.sq_last_status));
 +		err = -EAGAIN;
 +	} else if (aq_failures & ICE_SET_FC_AQ_FAIL_SET) {
 +		netdev_info(netdev, "Set fc failed on the set_phy_config call with err %d aq_err %s\n",
 +			    status,
 +			    ice_aq_str(hw->adminq.sq_last_status));
 +		err = -EAGAIN;
 +	} else if (aq_failures & ICE_SET_FC_AQ_FAIL_UPDATE) {
 +		netdev_info(netdev, "Set fc failed on the get_link_info call with err %d aq_err %s\n",
 +			    status,
 +			    ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			    err, ice_aq_str(hw->adminq.sq_last_status));
+ 		err = -EAGAIN;
+ 	} else if (aq_failures & ICE_SET_FC_AQ_FAIL_SET) {
+ 		netdev_info(netdev, "Set fc failed on the set_phy_config call with err %d aq_err %s\n",
+ 			    err, ice_aq_str(hw->adminq.sq_last_status));
+ 		err = -EAGAIN;
+ 	} else if (aq_failures & ICE_SET_FC_AQ_FAIL_UPDATE) {
+ 		netdev_info(netdev, "Set fc failed on the get_link_info call with err %d aq_err %s\n",
+ 			    err, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		err = -EAGAIN;
  	}
  
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
index 38960bcc384c,bbc64d6ce4cd..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
@@@ -581,24 -580,20 +581,39 @@@ ice_fdir_set_hw_fltr_rule(struct ice_p
  	 * actions (NULL) and zero actions 0.
  	 */
  	prof_id = flow + tun * ICE_FLTR_PTYPE_MAX;
++<<<<<<< HEAD
 +	status = ice_flow_add_prof(hw, ICE_BLK_FD, ICE_FLOW_RX, prof_id, seg,
 +				   TNL_SEG_CNT(tun), &prof);
 +	if (status)
 +		return ice_status_to_errno(status);
 +	status = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, main_vsi->idx,
 +				    main_vsi->idx, ICE_FLOW_PRIO_NORMAL,
 +				    seg, &entry1_h);
 +	if (status) {
 +		err = ice_status_to_errno(status);
 +		goto err_prof;
 +	}
 +	status = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, main_vsi->idx,
 +				    ctrl_vsi->idx, ICE_FLOW_PRIO_NORMAL,
 +				    seg, &entry2_h);
 +	if (status) {
 +		err = ice_status_to_errno(status);
++=======
+ 	err = ice_flow_add_prof(hw, ICE_BLK_FD, ICE_FLOW_RX, prof_id, seg,
+ 				TNL_SEG_CNT(tun), &prof);
+ 	if (err)
+ 		return err;
+ 	err = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, main_vsi->idx,
+ 				 main_vsi->idx, ICE_FLOW_PRIO_NORMAL,
+ 				 seg, &entry1_h);
+ 	if (err)
+ 		goto err_prof;
+ 	err = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, main_vsi->idx,
+ 				 ctrl_vsi->idx, ICE_FLOW_PRIO_NORMAL,
+ 				 seg, &entry2_h);
+ 	if (err)
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		goto err_entry;
- 	}
  
  	hw_prof->fdir_seg[tun] = seg;
  	hw_prof->entry_h[0][tun] = entry1_h;
@@@ -1209,11 -1203,9 +1224,15 @@@ ice_fdir_write_fltr(struct ice_pf *pf, 
  	}
  
  	ice_fdir_get_prgm_desc(hw, input, &desc, add);
++<<<<<<< HEAD
 +	status = ice_fdir_get_gen_prgm_pkt(hw, input, pkt, false, is_tun);
 +	if (status) {
 +		err = ice_status_to_errno(status);
++=======
+ 	err = ice_fdir_get_gen_prgm_pkt(hw, input, pkt, false, is_tun);
+ 	if (err)
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		goto err_free_all;
- 	}
  	err = ice_prgm_fdir_fltr(ctrl_vsi, &desc, pkt);
  	if (err)
  		goto err_free_all;
@@@ -1223,12 -1215,10 +1242,17 @@@
  	if (has_frag) {
  		/* does not return error */
  		ice_fdir_get_prgm_desc(hw, input, &desc, add);
++<<<<<<< HEAD
 +		status = ice_fdir_get_gen_prgm_pkt(hw, input, frag_pkt, true,
 +						   is_tun);
 +		if (status) {
 +			err = ice_status_to_errno(status);
++=======
+ 		err = ice_fdir_get_gen_prgm_pkt(hw, input, frag_pkt, true,
+ 						is_tun);
+ 		if (err)
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  			goto err_frag;
- 		}
  		err = ice_prgm_fdir_fltr(ctrl_vsi, &desc, frag_pkt);
  		if (err)
  			goto err_frag;
diff --cc drivers/net/ethernet/intel/ice/ice_fw_update.c
index ff801f4064a0,a11a5626ff8c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fw_update.c
+++ b/drivers/net/ethernet/intel/ice/ice_fw_update.c
@@@ -445,7 -442,6 +445,10 @@@ ice_erase_nvm_module(struct ice_pf *pf
  	struct ice_rq_event_info event;
  	struct ice_hw *hw = &pf->hw;
  	struct devlink *devlink;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	int err;
  
  	dev_dbg(dev, "Beginning erase of flash component '%s', module 0x%02x\n", component, module);
@@@ -530,11 -525,10 +533,15 @@@ static int ice_switch_flash_banks(struc
  
  	memset(&event, 0, sizeof(event));
  
- 	status = ice_nvm_write_activate(hw, activate_flags);
- 	if (status) {
+ 	err = ice_nvm_write_activate(hw, activate_flags);
+ 	if (err) {
  		dev_err(dev, "Failed to switch active flash banks, err %d aq_err %s\n",
++<<<<<<< HEAD
 +			status,
 +			ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			err, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		NL_SET_ERR_MSG_MOD(extack, "Failed to switch active flash banks");
  		return -EIO;
  	}
@@@ -670,7 -664,6 +677,10 @@@ int ice_flash_pldm_image(struct ice_pf 
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
  	struct ice_fwu_priv priv;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	int err;
  
  	switch (preservation) {
@@@ -692,11 -685,10 +702,15 @@@
  	priv.pf = pf;
  	priv.activate_flags = preservation;
  
- 	status = ice_acquire_nvm(hw, ICE_RES_WRITE);
- 	if (status) {
+ 	err = ice_acquire_nvm(hw, ICE_RES_WRITE);
+ 	if (err) {
  		dev_err(dev, "Failed to acquire device flash lock, err %d aq_err %s\n",
++<<<<<<< HEAD
 +			status,
 +			ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			err, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		NL_SET_ERR_MSG_MOD(extack, "Failed to acquire device flash lock");
  		return -EIO;
  	}
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 68fc7a57568e,c4c8e14fcf13..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -1627,21 -1749,21 +1627,30 @@@ ice_vsi_add_vlan(struct ice_vsi *vsi, u
  int ice_vsi_kill_vlan(struct ice_vsi *vsi, u16 vid)
  {
  	struct ice_pf *pf = vsi->back;
 +	enum ice_status status;
  	struct device *dev;
++<<<<<<< HEAD
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	dev = ice_pf_to_dev(pf);
  
- 	status = ice_fltr_remove_vlan(vsi, vid, ICE_FWD_TO_VSI);
- 	if (!status) {
+ 	err = ice_fltr_remove_vlan(vsi, vid, ICE_FWD_TO_VSI);
+ 	if (!err) {
  		vsi->num_vlan--;
++<<<<<<< HEAD
 +	} else if (status == ICE_ERR_DOES_NOT_EXIST) {
++=======
+ 	} else if (err == -ENOENT) {
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		dev_dbg(dev, "Failed to remove VLAN %d on VSI %i, it does not exist, error: %d\n",
- 			vid, vsi->vsi_num, status);
+ 			vid, vsi->vsi_num, err);
+ 		err = 0;
  	} else {
  		dev_err(dev, "Error removing VLAN %d on vsi %i error: %d\n",
- 			vid, vsi->vsi_num, status);
+ 			vid, vsi->vsi_num, err);
  		err = -EIO;
  	}
  
@@@ -1983,8 -2105,7 +1992,12 @@@ int ice_vsi_manage_vlan_insertion(struc
  {
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	ctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);
  	if (!ctxt)
@@@ -2026,8 -2146,7 +2038,12 @@@ int ice_vsi_manage_vlan_stripping(struc
  {
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	/* do not allow modifying VLAN stripping when a port VLAN is configured
  	 * on this VSI
@@@ -2570,14 -2704,26 +2585,31 @@@ ice_vsi_setup(struct ice_pf *pf, struc
  	}
  
  	/* configure VSI nodes based on number of queues and TC's */
 -	ice_for_each_traffic_class(i) {
 -		if (!(vsi->tc_cfg.ena_tc & BIT(i)))
 -			continue;
 +	for (i = 0; i < vsi->tc_cfg.numtc; i++)
 +		max_txqs[i] = vsi->alloc_txq;
  
++<<<<<<< HEAD
 +	status = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
 +				 max_txqs);
 +	if (status) {
++=======
+ 		if (vsi->type == ICE_VSI_CHNL) {
+ 			if (!vsi->alloc_txq && vsi->num_txq)
+ 				max_txqs[i] = vsi->num_txq;
+ 			else
+ 				max_txqs[i] = pf->num_lan_tx;
+ 		} else {
+ 			max_txqs[i] = vsi->alloc_txq;
+ 		}
+ 	}
+ 
+ 	dev_dbg(dev, "vsi->tc_cfg.ena_tc = %d\n", vsi->tc_cfg.ena_tc);
+ 	ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
+ 			      max_txqs);
+ 	if (ret) {
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		dev_err(dev, "VSI %d failed lan queue config, error %d\n",
- 			vsi->vsi_num, status);
+ 			vsi->vsi_num, ret);
  		goto unroll_clear_rings;
  	}
  
@@@ -3246,11 -3410,18 +3278,24 @@@ int ice_vsi_rebuild(struct ice_vsi *vsi
  			max_txqs[i] += vsi->num_xdp_txq;
  	}
  
++<<<<<<< HEAD
 +	status = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
 +				 max_txqs);
 +	if (status) {
++=======
+ 	if (test_bit(ICE_FLAG_TC_MQPRIO, pf->flags))
+ 		/* If MQPRIO is set, means channel code path, hence for main
+ 		 * VSI's, use TC as 1
+ 		 */
+ 		ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, 1, max_txqs);
+ 	else
+ 		ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx,
+ 				      vsi->tc_cfg.ena_tc, max_txqs);
+ 
+ 	if (ret) {
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		dev_err(ice_pf_to_dev(pf), "VSI %d failed lan queue config, error %d\n",
- 			vsi->vsi_num, status);
+ 			vsi->vsi_num, ret);
  		if (init_vsi) {
  			ret = -EIO;
  			goto err_vectors;
@@@ -3382,12 -3704,16 +3427,21 @@@ int ice_vsi_cfg_tc(struct ice_vsi *vsi
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	status = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, vsi->tc_cfg.ena_tc,
 +				 max_txqs);
++=======
+ 	if (vsi->type == ICE_VSI_PF &&
+ 	    test_bit(ICE_FLAG_TC_MQPRIO, pf->flags))
+ 		ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx, 1, max_txqs);
+ 	else
+ 		ret = ice_cfg_vsi_lan(vsi->port_info, vsi->idx,
+ 				      vsi->tc_cfg.ena_tc, max_txqs);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
- 	if (status) {
+ 	if (ret) {
  		dev_err(dev, "VSI %d failed TC config, error %d\n",
- 			vsi->vsi_num, status);
+ 			vsi->vsi_num, ret);
  		ret = -EIO;
  		goto out;
  	}
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index a13eae346070,1e2b053332aa..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -285,10 -295,9 +285,10 @@@ static int ice_vsi_sync_fltr(struct ice
  	bool promisc_forced_on = false;
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
 +	enum ice_status status = 0;
  	u32 changed_flags = 0;
  	u8 promisc_m;
- 	int err = 0;
+ 	int err;
  
  	if (!vsi->netdev)
  		return -EINVAL;
@@@ -318,15 -327,13 +318,18 @@@
  	}
  
  	/* Remove MAC addresses in the unsync list */
- 	status = ice_fltr_remove_mac_list(vsi, &vsi->tmp_unsync_list);
+ 	err = ice_fltr_remove_mac_list(vsi, &vsi->tmp_unsync_list);
  	ice_fltr_free_list(dev, &vsi->tmp_unsync_list);
- 	if (status) {
+ 	if (err) {
  		netdev_err(netdev, "Failed to delete MAC filters\n");
  		/* if we failed because of alloc failures, just bail */
++<<<<<<< HEAD
 +		if (status == ICE_ERR_NO_MEMORY) {
 +			err = -ENOMEM;
++=======
+ 		if (err == -ENOMEM)
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  			goto out;
- 		}
  	}
  
  	/* Add MAC addresses in the sync list */
@@@ -336,7 -343,7 +339,11 @@@
  	 * 'if' condition and report it as error. Instead continue processing
  	 * rest of the function.
  	 */
++<<<<<<< HEAD
 +	if (status && status != ICE_ERR_ALREADY_EXISTS) {
++=======
+ 	if (err && err != -EEXIST) {
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		netdev_err(netdev, "Failed to add MAC filters\n");
  		/* If there is no more space for new umac filters, VSI
  		 * should go into promiscuous mode. There should be some
@@@ -1834,8 -1878,7 +1843,12 @@@ static int ice_init_nvm_phy_type(struc
  {
  	struct ice_aqc_get_phy_caps_data *pcaps;
  	struct ice_pf *pf = pi->hw->back;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	pcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);
  	if (!pcaps)
@@@ -1945,8 -1988,7 +1958,12 @@@ static int ice_init_phy_user_cfg(struc
  	struct ice_aqc_get_phy_caps_data *pcaps;
  	struct ice_phy_info *phy = &pi->phy;
  	struct ice_pf *pf = pi->hw->back;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	if (!(phy->link_info.link_info & ICE_AQ_MEDIA_AVAILABLE))
  		return -EIO;
@@@ -2017,8 -2059,7 +2034,12 @@@ static int ice_configure_phy(struct ice
  	struct ice_aqc_set_phy_cfg_data *cfg;
  	struct ice_phy_info *phy = &pi->phy;
  	struct ice_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int err = 0;
++=======
+ 	int err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	/* Ensure we have media as we cannot configure a medialess port */
  	if (!(phy->link_info.link_info & ICE_AQ_MEDIA_AVAILABLE))
@@@ -3370,8 -3527,9 +3391,8 @@@ ice_vlan_rx_kill_vid(struct net_device 
   */
  static int ice_setup_pf_sw(struct ice_pf *pf)
  {
 -	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_vsi *vsi;
- 	int status = 0;
+ 	int status;
  
  	if (ice_is_reset_in_progress(pf->state))
  		return -EBUSY;
@@@ -5175,11 -5351,10 +5196,15 @@@ static int ice_set_mac_address(struct n
  	struct ice_pf *pf = vsi->back;
  	struct ice_hw *hw = &pf->hw;
  	struct sockaddr *addr = pi;
 +	enum ice_status status;
  	u8 old_mac[ETH_ALEN];
  	u8 flags = 0;
++<<<<<<< HEAD
 +	int err = 0;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	u8 *mac;
+ 	int err;
  
  	mac = (u8 *)addr->sa_data;
  
@@@ -5205,15 -5386,15 +5230,25 @@@
  	netif_addr_unlock_bh(netdev);
  
  	/* Clean up old MAC filter. Not an error if old filter doesn't exist */
++<<<<<<< HEAD
 +	status = ice_fltr_remove_mac(vsi, old_mac, ICE_FWD_TO_VSI);
 +	if (status && status != ICE_ERR_DOES_NOT_EXIST) {
++=======
+ 	err = ice_fltr_remove_mac(vsi, old_mac, ICE_FWD_TO_VSI);
+ 	if (err && err != -ENOENT) {
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		err = -EADDRNOTAVAIL;
  		goto err_update_filters;
  	}
  
  	/* Add filter for new MAC. If filter exists, return success */
++<<<<<<< HEAD
 +	status = ice_fltr_add_mac(vsi, mac, ICE_FWD_TO_VSI);
 +	if (status == ICE_ERR_ALREADY_EXISTS)
++=======
+ 	err = ice_fltr_add_mac(vsi, mac, ICE_FWD_TO_VSI);
+ 	if (err == -EEXIST)
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		/* Although this MAC filter is already present in hardware it's
  		 * possible in some cases (e.g. bonding) that dev_addr was
  		 * modified outside of the driver and needs to be restored back
@@@ -6328,7 -6526,6 +6363,10 @@@ static void ice_vsi_release_all(struct 
  static int ice_vsi_rebuild_by_type(struct ice_pf *pf, enum ice_vsi_type type)
  {
  	struct device *dev = ice_pf_to_dev(pf);
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	int i, err;
  
  	ice_for_each_vsi(pf, i) {
@@@ -6346,11 -6543,10 +6384,15 @@@
  		}
  
  		/* replay filters for the VSI */
- 		status = ice_replay_vsi(&pf->hw, vsi->idx);
- 		if (status) {
+ 		err = ice_replay_vsi(&pf->hw, vsi->idx);
+ 		if (err) {
  			dev_err(dev, "replay VSI failed, error %d, VSI index %d, type %s\n",
++<<<<<<< HEAD
 +				status, vsi->idx,
 +				ice_vsi_type_str(type));
++=======
+ 				err, vsi->idx, ice_vsi_type_str(type));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  			return -EIO;
  		}
  
@@@ -6414,7 -6610,6 +6456,10 @@@ static void ice_rebuild(struct ice_pf *
  {
  	struct device *dev = ice_pf_to_dev(pf);
  	struct ice_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	enum ice_status ret;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	int err;
  
  	if (test_bit(ICE_DOWN, pf->state))
@@@ -6422,10 -6617,9 +6467,16 @@@
  
  	dev_dbg(dev, "rebuilding PF after reset_type=%d\n", reset_type);
  
++<<<<<<< HEAD
 +	ret = ice_init_all_ctrlq(hw);
 +	if (ret) {
 +		dev_err(dev, "control queues init failed %d\n",
 +			ret);
++=======
+ 	err = ice_init_all_ctrlq(hw);
+ 	if (err) {
+ 		dev_err(dev, "control queues init failed %d\n", err);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		goto err_init_ctrlq;
  	}
  
@@@ -6439,10 -6633,9 +6490,16 @@@
  			ice_load_pkg(NULL, pf);
  	}
  
++<<<<<<< HEAD
 +	ret = ice_clear_pf_cfg(hw);
 +	if (ret) {
 +		dev_err(dev, "clear PF configuration failed %d\n",
 +			ret);
++=======
+ 	err = ice_clear_pf_cfg(hw);
+ 	if (err) {
+ 		dev_err(dev, "clear PF configuration failed %d\n", err);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		goto err_init_ctrlq;
  	}
  
@@@ -6879,8 -7079,7 +6936,12 @@@ static int ice_vsi_update_bridge_mode(s
  	struct ice_aqc_vsi_props *vsi_props;
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	vsi_props = &vsi->info;
  
@@@ -6898,11 -7097,10 +6959,15 @@@
  		ctxt->info.sw_flags &= ~ICE_AQ_VSI_SW_FLAG_ALLOW_LB;
  	ctxt->info.valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_SW_VALID);
  
- 	status = ice_update_vsi(hw, vsi->idx, ctxt, NULL);
- 	if (status) {
+ 	ret = ice_update_vsi(hw, vsi->idx, ctxt, NULL);
+ 	if (ret) {
  		dev_err(ice_pf_to_dev(vsi->back), "update VSI for bridge mode failed, bmode = %d err %d aq_err %s\n",
++<<<<<<< HEAD
 +			bmode, status,
 +			ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			bmode, ret, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		ret = -EIO;
  		goto out;
  	}
@@@ -7107,7 -8348,6 +7172,10 @@@ int ice_open_internal(struct net_devic
  	struct ice_vsi *vsi = np->vsi;
  	struct ice_pf *pf = vsi->back;
  	struct ice_port_info *pi;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	int err;
  
  	if (test_bit(ICE_NEEDS_RESTART, pf->state)) {
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
index 6abf9ed1dd2e,d64df81d4893..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
@@@ -603,29 -602,26 +603,46 @@@ ice_vc_fdir_write_flow_prof(struct ice_
  	prof_id = ICE_FLOW_PROF_FD(vf_vsi->vsi_num, flow,
  				   tun ? ICE_FLTR_PTYPE_MAX : 0);
  
++<<<<<<< HEAD
 +	status = ice_flow_add_prof(hw, ICE_BLK_FD, ICE_FLOW_RX, prof_id, seg,
 +				   tun + 1, &prof);
 +	ret = ice_status_to_errno(status);
++=======
+ 	ret = ice_flow_add_prof(hw, ICE_BLK_FD, ICE_FLOW_RX, prof_id, seg,
+ 				tun + 1, &prof);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	if (ret) {
  		dev_dbg(dev, "Could not add VSI flow 0x%x for VF %d\n",
  			flow, vf->vf_id);
  		goto err_exit;
  	}
  
++<<<<<<< HEAD
 +	status = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, vf_vsi->idx,
 +				    vf_vsi->idx, ICE_FLOW_PRIO_NORMAL,
 +				    seg, &entry1_h);
 +	ret = ice_status_to_errno(status);
++=======
+ 	ret = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, vf_vsi->idx,
+ 				 vf_vsi->idx, ICE_FLOW_PRIO_NORMAL,
+ 				 seg, &entry1_h);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	if (ret) {
  		dev_dbg(dev, "Could not add flow 0x%x VSI entry for VF %d\n",
  			flow, vf->vf_id);
  		goto err_prof;
  	}
  
++<<<<<<< HEAD
 +	status = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, vf_vsi->idx,
 +				    ctrl_vsi->idx, ICE_FLOW_PRIO_NORMAL,
 +				    seg, &entry2_h);
 +	ret = ice_status_to_errno(status);
++=======
+ 	ret = ice_flow_add_entry(hw, ICE_BLK_FD, prof_id, vf_vsi->idx,
+ 				 ctrl_vsi->idx, ICE_FLOW_PRIO_NORMAL,
+ 				 seg, &entry2_h);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	if (ret) {
  		dev_dbg(dev,
  			"Could not add flow 0x%x Ctrl VSI entry for VF %d\n",
@@@ -1229,8 -1224,7 +1246,12 @@@ static int ice_vc_fdir_write_fltr(struc
  		return -ENOMEM;
  
  	ice_fdir_get_prgm_desc(hw, input, &desc, add);
++<<<<<<< HEAD
 +	status = ice_fdir_get_gen_prgm_pkt(hw, input, pkt, false, is_tun);
 +	ret = ice_status_to_errno(status);
++=======
+ 	ret = ice_fdir_get_gen_prgm_pkt(hw, input, pkt, false, is_tun);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	if (ret) {
  		dev_dbg(dev, "Gen training pkt for VF %d ptype %d failed\n",
  			vf->vf_id, input->flow_type);
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 3b25caebf610,f0fe8e193f2c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -653,8 -653,7 +653,12 @@@ static int ice_vsi_manage_pvid(struct i
  	struct ice_hw *hw = &vsi->back->hw;
  	struct ice_aqc_vsi_props *info;
  	struct ice_vsi_ctx *ctxt;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	ctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);
  	if (!ctxt)
@@@ -677,11 -676,10 +681,15 @@@
  	info->valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_VLAN_VALID |
  					   ICE_AQ_VSI_PROP_SW_VALID);
  
- 	status = ice_update_vsi(hw, vsi->idx, ctxt, NULL);
- 	if (status) {
+ 	ret = ice_update_vsi(hw, vsi->idx, ctxt, NULL);
+ 	if (ret) {
  		dev_info(ice_hw_to_dev(hw), "update VSI for port VLAN failed, err %d aq_err %s\n",
++<<<<<<< HEAD
 +			 status,
 +			 ice_aq_str(hw->adminq.sq_last_status));
++=======
+ 			 ret, ice_aq_str(hw->adminq.sq_last_status));
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		ret = -EIO;
  		goto out;
  	}
@@@ -1750,11 -1751,10 +1758,15 @@@ static int ice_init_vf_vsi_res(struct i
  	}
  
  	eth_broadcast_addr(broadcast);
- 	status = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);
- 	if (status) {
+ 	err = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);
+ 	if (err) {
  		dev_err(dev, "Failed to add broadcast MAC filter for VF %d, error %d\n",
++<<<<<<< HEAD
 +			vf->vf_id, status);
 +		err = ice_status_to_errno(status);
++=======
+ 			vf->vf_id, err);
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		goto release_vsi;
  	}
  
@@@ -1998,7 -2000,6 +2010,10 @@@ int ice_sriov_configure(struct pci_dev 
  {
  	struct ice_pf *pf = pci_get_drvdata(pdev);
  	struct device *dev = ice_pf_to_dev(pf);
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  	int err;
  
  	err = ice_check_sriov_allowed(pf);
@@@ -2018,9 -2019,9 +2033,15 @@@
  		return -EBUSY;
  	}
  
++<<<<<<< HEAD
 +	status = ice_mbx_init_snapshot(&pf->hw, num_vfs);
 +	if (status)
 +		return ice_status_to_errno(status);
++=======
+ 	err = ice_mbx_init_snapshot(&pf->hw, num_vfs);
+ 	if (err)
+ 		return err;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	err = ice_pci_sriov_ena(pf, num_vfs);
  	if (err) {
@@@ -3784,8 -3780,7 +3804,12 @@@ ice_vc_add_mac_addr(struct ice_vf *vf, 
  {
  	struct device *dev = ice_pf_to_dev(vf->pf);
  	u8 *mac_addr = vc_ether_addr->addr;
++<<<<<<< HEAD
 +	enum ice_status status;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  
  	/* device MAC already added */
  	if (ether_addr_equal(mac_addr, vf->dev_lan_addr.addr))
@@@ -3796,8 -3791,8 +3820,13 @@@
  		return -EPERM;
  	}
  
++<<<<<<< HEAD
 +	status = ice_fltr_add_mac(vsi, mac_addr, ICE_FWD_TO_VSI);
 +	if (status == ICE_ERR_ALREADY_EXISTS) {
++=======
+ 	ret = ice_fltr_add_mac(vsi, mac_addr, ICE_FWD_TO_VSI);
+ 	if (ret == -EEXIST) {
++>>>>>>> 2ccc1c1ccc67 (ice: Remove excess error variables)
  		dev_dbg(dev, "MAC %pM already exists for VF %d\n", mac_addr,
  			vf->vf_id);
  		/* don't return since we might need to update
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_common.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_devlink.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fw_update.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
