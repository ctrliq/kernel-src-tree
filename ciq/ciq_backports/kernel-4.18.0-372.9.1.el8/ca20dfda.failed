net/mlx5e: Allow only complete TXQs partition in MQPRIO channel mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Tariq Toukan <tariqt@nvidia.com>
commit ca20dfda05ae0531c8f5117b6ac989816f6cf658
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/ca20dfda.failed

Do not allow configurations of MQPRIO channel mode that do not
fully define and utilize the channels txqs.

Fixes: ec60c4581bd9 ("net/mlx5e: Support MQPRIO channel mode")
	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit ca20dfda05ae0531c8f5117b6ac989816f6cf658)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index c234e374c4b8,336aa07313da..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3385,8 -2930,90 +3385,92 @@@ static int mlx5e_setup_tc_mqprio(struc
  	if (tc && tc != MLX5E_MAX_NUM_TC)
  		return -EINVAL;
  
 -	new_params = priv->channels.params;
 -	mlx5e_params_mqprio_dcb_set(&new_params, tc ? tc : 1);
 +	mutex_lock(&priv->state_lock);
  
++<<<<<<< HEAD
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_num_channels_changed_ctx, NULL, true);
+ 
+ 	priv->max_opened_tc = max_t(u8, priv->max_opened_tc,
+ 				    mlx5e_get_dcb_num_tc(&priv->channels.params));
+ 	return err;
+ }
+ 
+ static int mlx5e_mqprio_channel_validate(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5e_ptp *ptp_channel;
+ 	int agg_count = 0;
+ 	int i;
+ 
+ 	ptp_channel = priv->channels.ptp;
+ 	if (ptp_channel && test_bit(MLX5E_PTP_STATE_TX, ptp_channel->state)) {
+ 		netdev_err(netdev,
+ 			   "Cannot activate MQPRIO mode channel since it conflicts with TX port TS\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mqprio->qopt.offset[0] != 0 || mqprio->qopt.num_tc < 1 ||
+ 	    mqprio->qopt.num_tc > MLX5E_MAX_NUM_MQPRIO_CH_TC)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < mqprio->qopt.num_tc; i++) {
+ 		if (!mqprio->qopt.count[i]) {
+ 			netdev_err(netdev, "Zero size for queue-group (%d) is not supported\n", i);
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->min_rate[i]) {
+ 			netdev_err(netdev, "Min tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		if (mqprio->max_rate[i]) {
+ 			netdev_err(netdev, "Max tx rate is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (mqprio->qopt.offset[i] != agg_count) {
+ 			netdev_err(netdev, "Discontinuous queues config is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 		agg_count += mqprio->qopt.count[i];
+ 	}
+ 
+ 	if (priv->channels.params.num_channels != agg_count) {
+ 		netdev_err(netdev, "Num of queues (%d) does not match available (%d)\n",
+ 			   agg_count, priv->channels.params.num_channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_setup_tc_mqprio_channel(struct mlx5e_priv *priv,
+ 					 struct tc_mqprio_qopt_offload *mqprio)
+ {
+ 	mlx5e_fp_preactivate preactivate;
+ 	struct mlx5e_params new_params;
+ 	bool nch_changed;
+ 	int err;
+ 
+ 	err = mlx5e_mqprio_channel_validate(priv, mqprio);
+ 	if (err)
+ 		return err;
+ 
+ 	new_params = priv->channels.params;
+ 	mlx5e_params_mqprio_channel_set(&new_params, &mqprio->qopt);
+ 
+ 	nch_changed = mlx5e_get_dcb_num_tc(&priv->channels.params) > 1;
+ 	preactivate = nch_changed ? mlx5e_num_channels_changed_ctx :
+ 		mlx5e_update_netdev_queues_ctx;
+ 	return mlx5e_safe_switch_params(priv, &new_params, preactivate, NULL, true);
+ }
+ 
+ static int mlx5e_setup_tc_mqprio(struct mlx5e_priv *priv,
+ 				 struct tc_mqprio_qopt_offload *mqprio)
+ {
++>>>>>>> ca20dfda05ae (net/mlx5e: Allow only complete TXQs partition in MQPRIO channel mode)
  	/* MQPRIO is another toplevel qdisc that can't be attached
  	 * simultaneously with the offloaded HTB.
  	 */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
