device-dax: add an allocation interface for device-dax instances

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit c2f3011ee697f85ba0166fb3780332aafc66b8f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/c2f3011e.failed

In preparation for a facility that enables dax regions to be sub-divided,
introduce infrastructure to track and allocate region capacity.

The new dax_region/available_size attribute is only enabled for volatile
hmem devices, not pmem devices that are defined by nvdimm namespace
boundaries.  This is per Jeff's feedback the last time dynamic device-dax
capacity allocation support was discussed.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Vishal Verma <vishal.l.verma@intel.com>
	Cc: Brice Goglin <Brice.Goglin@inria.fr>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Dave Jiang <dave.jiang@intel.com>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Jia He <justin.he@arm.com>
	Cc: Joao Martins <joao.m.martins@oracle.com>
	Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Ard Biesheuvel <ardb@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Ben Skeggs <bskeggs@redhat.com>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: David Airlie <airlied@linux.ie>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Hulk Robot <hulkci@huawei.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Jason Yan <yanaijie@huawei.com>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: "Jérôme Glisse" <jglisse@redhat.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: kernel test robot <lkp@intel.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Paul Mackerras <paulus@ozlabs.org>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Stefano Stabellini <sstabellini@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Cc: Wei Yang <richard.weiyang@linux.alibaba.com>
	Cc: Will Deacon <will@kernel.org>
Link: https://lore.kernel.org/linux-nvdimm/x49shpp3zn8.fsf@segfault.boston.devel.redhat.com
Link: https://lkml.kernel.org/r/159643101035.4062302.6785857915652647857.stgit@dwillia2-desk3.amr.corp.intel.com
Link: https://lkml.kernel.org/r/160106112801.30709.14601438735305335071.stgit@dwillia2-desk3.amr.corp.intel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c2f3011ee697f85ba0166fb3780332aafc66b8f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/bus.c
#	drivers/dax/bus.h
#	drivers/dax/hmem/hmem.c
#	drivers/dax/pmem/core.c
diff --cc drivers/dax/bus.c
index dffa4655e128,0a48ce378686..000000000000
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@@ -412,7 -495,26 +501,30 @@@ struct dev_dax *devm_create_dev_dax(str
  	if (!dev_dax)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	memcpy(&dev_dax->pgmap, data->pgmap, sizeof(struct dev_pagemap));
++=======
+ 	dev_dax->region = dax_region;
+ 	dev = &dev_dax->dev;
+ 	device_initialize(dev);
+ 	dev_set_name(dev, "dax%d.%d", dax_region->id, data->id);
+ 
+ 	rc = alloc_dev_dax_range(dev_dax, data->size);
+ 	if (rc)
+ 		goto err_range;
+ 
+ 	if (data->pgmap) {
+ 		dev_WARN_ONCE(parent, !is_static(dax_region),
+ 			"custom dev_pagemap requires a static dax_region\n");
+ 
+ 		dev_dax->pgmap = kmemdup(data->pgmap,
+ 				sizeof(struct dev_pagemap), GFP_KERNEL);
+ 		if (!dev_dax->pgmap) {
+ 			rc = -ENOMEM;
+ 			goto err_pgmap;
+ 		}
+ 	}
++>>>>>>> c2f3011ee697 (device-dax: add an allocation interface for device-dax instances)
  
  	/*
  	 * No 'host' or dax_operations since there is no access to this
@@@ -427,12 -529,8 +539,17 @@@
  	/* a device_dax instance is dead while the driver is not attached */
  	kill_dax(dax_dev);
  
++<<<<<<< HEAD
 +	/* from here on we're committed to teardown via dax_dev_release() */
 +	dev = &dev_dax->dev;
 +	device_initialize(dev);
 +
 +	dev_dax->dax_dev = dax_dev;
 +	dev_dax->region = dax_region;
++=======
+ 	/* from here on we're committed to teardown via dev_dax_release() */
+ 	dev_dax->dax_dev = dax_dev;
++>>>>>>> c2f3011ee697 (device-dax: add an allocation interface for device-dax instances)
  	dev_dax->target_node = dax_region->target_node;
  	kref_get(&dax_region->kref);
  
@@@ -459,7 -556,11 +575,15 @@@
  
  	return dev_dax;
  
++<<<<<<< HEAD
 + err:
++=======
+ err_alloc_dax:
+ 	kfree(dev_dax->pgmap);
+ err_pgmap:
+ 	free_dev_dax_range(dev_dax);
+ err_range:
++>>>>>>> c2f3011ee697 (device-dax: add an allocation interface for device-dax instances)
  	kfree(dev_dax);
  
  	return ERR_PTR(rc);
diff --cc drivers/dax/bus.h
index 299c2e7fac09,44592a8cac0f..000000000000
--- a/drivers/dax/bus.h
+++ b/drivers/dax/bus.h
@@@ -21,6 -25,7 +24,10 @@@ struct dev_dax_data 
  	struct dax_region *dax_region;
  	struct dev_pagemap *pgmap;
  	enum dev_dax_subsys subsys;
++<<<<<<< HEAD
++=======
+ 	resource_size_t size;
++>>>>>>> c2f3011ee697 (device-dax: add an allocation interface for device-dax instances)
  	int id;
  };
  
diff --cc drivers/dax/hmem/hmem.c
index b84fe17178d8,e7b64539e23e..000000000000
--- a/drivers/dax/hmem/hmem.c
+++ b/drivers/dax/hmem/hmem.c
@@@ -20,17 -19,15 +20,21 @@@ static int dax_hmem_probe(struct platfo
  		return -ENOMEM;
  
  	mri = dev->platform_data;
 +	memcpy(&pgmap.res, res, sizeof(*res));
 +
  	dax_region = alloc_dax_region(dev, pdev->id, res, mri->target_node,
- 			PMD_SIZE);
+ 			PMD_SIZE, 0);
  	if (!dax_region)
  		return -ENOMEM;
  
  	data = (struct dev_dax_data) {
  		.dax_region = dax_region,
  		.id = 0,
++<<<<<<< HEAD
 +		.pgmap = &pgmap,
++=======
+ 		.size = resource_size(res),
++>>>>>>> c2f3011ee697 (device-dax: add an allocation interface for device-dax instances)
  	};
  	dev_dax = devm_create_dev_dax(&data);
  	if (IS_ERR(dev_dax))
diff --cc drivers/dax/pmem/core.c
index 615ebe8bfa98,4fe700884338..000000000000
--- a/drivers/dax/pmem/core.c
+++ b/drivers/dax/pmem/core.c
@@@ -63,6 -64,7 +64,10 @@@ struct dev_dax *__dax_pmem_probe(struc
  		.id = id,
  		.pgmap = &pgmap,
  		.subsys = subsys,
++<<<<<<< HEAD
++=======
+ 		.size = resource_size(&res),
++>>>>>>> c2f3011ee697 (device-dax: add an allocation interface for device-dax instances)
  	};
  	dev_dax = devm_create_dev_dax(&data);
  
* Unmerged path drivers/dax/bus.c
* Unmerged path drivers/dax/bus.h
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
index 6f41597afb47..c14a9085d003 100644
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@ -30,7 +30,7 @@ void dax_bus_exit(void);
  * @kref: to pin while other agents have a need to do lookups
  * @dev: parent device backing this region
  * @align: allocation and mapping alignment for child dax devices
- * @res: physical address range of the region
+ * @res: resource tree to track instance allocations
  */
 struct dax_region {
 	int id;
* Unmerged path drivers/dax/hmem/hmem.c
* Unmerged path drivers/dax/pmem/core.c
