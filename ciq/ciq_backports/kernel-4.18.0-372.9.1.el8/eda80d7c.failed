ALSA: memalloc: Fix regression with SNDRV_DMA_TYPE_CONTINUOUS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit eda80d7c9c4db0f55f130e38c682e19b58d5add7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/eda80d7c.failed

The recent code refactoring made the mmap of continuous pages to be
done via the own helper snd_dma_continuous_mmap() with
remap_pfn_range().  There I overlooked that dmab->addr isn't set for
the allocation with SNDRV_DMA_TYPE_CONTINUOUS.  This resulted always
in an error at mmap with this buffer type on the system such as
Intel SST Baytrail driver.

This patch fixes the regression by passing the correct address.

Fixes: 30b7ba6972d5 ("ALSA: core: Add continuous and vmalloc mmap ops")
	Reported-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/8d6674da-7d7b-803e-acc9-7de6cb1223fa@redhat.com
Link: https://lore.kernel.org/r/20210801113801.31290-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit eda80d7c9c4db0f55f130e38c682e19b58d5add7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/core/memalloc.c
diff --cc sound/core/memalloc.c
index fb571e6ead5e,439a358ecfe9..000000000000
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@@ -226,32 -120,288 +226,314 @@@ EXPORT_SYMBOL(snd_dma_alloc_pages_fallb
   */
  void snd_dma_free_pages(struct snd_dma_buffer *dmab)
  {
 -	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
 -
 -	if (ops && ops->free)
 -		ops->free(dmab);
 +	switch (dmab->dev.type) {
 +	case SNDRV_DMA_TYPE_CONTINUOUS:
 +		free_pages_exact(dmab->area, dmab->bytes);
 +		break;
 +	case SNDRV_DMA_TYPE_VMALLOC:
 +		vfree(dmab->area);
 +		break;
 +#ifdef CONFIG_HAS_DMA
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +	case SNDRV_DMA_TYPE_DEV_IRAM:
 +		snd_free_dev_iram(dmab);
 +		break;
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +	case SNDRV_DMA_TYPE_DEV:
 +	case SNDRV_DMA_TYPE_DEV_UC:
 +		snd_free_dev_pages(dmab);
 +		break;
 +#endif
 +#ifdef CONFIG_SND_DMA_SGBUF
 +	case SNDRV_DMA_TYPE_DEV_SG:
 +	case SNDRV_DMA_TYPE_DEV_UC_SG:
 +		snd_free_sgbuf_pages(dmab);
 +		break;
 +#endif
 +	default:
 +		pr_err("snd-malloc: invalid device type %d\n", dmab->dev.type);
 +	}
  }
  EXPORT_SYMBOL(snd_dma_free_pages);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * snd_dma_buffer_mmap - perform mmap of the given DMA buffer
+  * @dmab: buffer allocation information
+  * @area: VM area information
+  */
+ int snd_dma_buffer_mmap(struct snd_dma_buffer *dmab,
+ 			struct vm_area_struct *area)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->mmap)
+ 		return ops->mmap(dmab, area);
+ 	else
+ 		return -ENOENT;
+ }
+ EXPORT_SYMBOL(snd_dma_buffer_mmap);
+ 
+ /**
+  * snd_sgbuf_get_addr - return the physical address at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_addr)
+ 		return ops->get_addr(dmab, offset);
+ 	else
+ 		return dmab->addr + offset;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_addr);
+ 
+ /**
+  * snd_sgbuf_get_page - return the physical page at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ struct page *snd_sgbuf_get_page(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_page)
+ 		return ops->get_page(dmab, offset);
+ 	else
+ 		return virt_to_page(dmab->area + offset);
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_page);
+ 
+ /**
+  * snd_sgbuf_get_chunk_size - compute the max chunk size with continuous pages
+  *	on sg-buffer
+  * @dmab: buffer allocation information
+  * @ofs: offset in the ring buffer
+  * @size: the requested size
+  */
+ unsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,
+ 				      unsigned int ofs, unsigned int size)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_chunk_size)
+ 		return ops->get_chunk_size(dmab, ofs, size);
+ 	else
+ 		return size;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_chunk_size);
+ 
+ /*
+  * Continuous pages allocator
+  */
+ static int snd_dma_continuous_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL);
+ 
+ 	dmab->area = alloc_pages_exact(size, gfp);
+ 	return 0;
+ }
+ 
+ static void snd_dma_continuous_free(struct snd_dma_buffer *dmab)
+ {
+ 	free_pages_exact(dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_continuous_mmap(struct snd_dma_buffer *dmab,
+ 				   struct vm_area_struct *area)
+ {
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       page_to_pfn(virt_to_page(dmab->area)),
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_continuous_ops = {
+ 	.alloc = snd_dma_continuous_alloc,
+ 	.free = snd_dma_continuous_free,
+ 	.mmap = snd_dma_continuous_mmap,
+ };
+ 
+ /*
+  * VMALLOC allocator
+  */
+ static int snd_dma_vmalloc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL | __GFP_HIGHMEM);
+ 
+ 	dmab->area = __vmalloc(size, gfp);
+ 	return 0;
+ }
+ 
+ static void snd_dma_vmalloc_free(struct snd_dma_buffer *dmab)
+ {
+ 	vfree(dmab->area);
+ }
+ 
+ static int snd_dma_vmalloc_mmap(struct snd_dma_buffer *dmab,
+ 				struct vm_area_struct *area)
+ {
+ 	return remap_vmalloc_range(area, dmab->area, 0);
+ }
+ 
+ static dma_addr_t snd_dma_vmalloc_get_addr(struct snd_dma_buffer *dmab,
+ 					   size_t offset)
+ {
+ 	return page_to_phys(vmalloc_to_page(dmab->area + offset)) +
+ 		offset % PAGE_SIZE;
+ }
+ 
+ static struct page *snd_dma_vmalloc_get_page(struct snd_dma_buffer *dmab,
+ 					     size_t offset)
+ {
+ 	return vmalloc_to_page(dmab->area + offset);
+ }
+ 
+ static unsigned int
+ snd_dma_vmalloc_get_chunk_size(struct snd_dma_buffer *dmab,
+ 			       unsigned int ofs, unsigned int size)
+ {
+ 	ofs %= PAGE_SIZE;
+ 	size += ofs;
+ 	if (size > PAGE_SIZE)
+ 		size = PAGE_SIZE;
+ 	return size - ofs;
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_vmalloc_ops = {
+ 	.alloc = snd_dma_vmalloc_alloc,
+ 	.free = snd_dma_vmalloc_free,
+ 	.mmap = snd_dma_vmalloc_mmap,
+ 	.get_addr = snd_dma_vmalloc_get_addr,
+ 	.get_page = snd_dma_vmalloc_get_page,
+ 	.get_chunk_size = snd_dma_vmalloc_get_chunk_size,
+ };
+ 
+ #ifdef CONFIG_HAS_DMA
+ /*
+  * IRAM allocator
+  */
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ static int snd_dma_iram_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	struct device *dev = dmab->dev.dev;
+ 	struct gen_pool *pool;
+ 
+ 	if (dev->of_node) {
+ 		pool = of_gen_pool_get(dev->of_node, "iram", 0);
+ 		/* Assign the pool into private_data field */
+ 		dmab->private_data = pool;
+ 
+ 		dmab->area = gen_pool_dma_alloc_align(pool, size, &dmab->addr,
+ 						      PAGE_SIZE);
+ 		if (dmab->area)
+ 			return 0;
+ 	}
+ 
+ 	/* Internal memory might have limited size and no enough space,
+ 	 * so if we fail to malloc, try to fetch memory traditionally.
+ 	 */
+ 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+ 	return __snd_dma_alloc_pages(dmab, size);
+ }
+ 
+ static void snd_dma_iram_free(struct snd_dma_buffer *dmab)
+ {
+ 	struct gen_pool *pool = dmab->private_data;
+ 
+ 	if (pool && dmab->area)
+ 		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_iram_mmap(struct snd_dma_buffer *dmab,
+ 			     struct vm_area_struct *area)
+ {
+ 	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       dmab->addr >> PAGE_SHIFT,
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_iram_ops = {
+ 	.alloc = snd_dma_iram_alloc,
+ 	.free = snd_dma_iram_free,
+ 	.mmap = snd_dma_iram_mmap,
+ };
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ 
+ /*
+  * Coherent device pages allocator
+  */
+ static int snd_dma_dev_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp_flags;
+ 
+ 	gfp_flags = GFP_KERNEL
+ 		| __GFP_COMP	/* compound page lets parts be mapped */
+ 		| __GFP_NORETRY /* don't trigger OOM-killer */
+ 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
+ 	dmab->area = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr,
+ 					gfp_flags);
+ #ifdef CONFIG_X86
+ 	if (dmab->area && dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
+ 		set_memory_wc((unsigned long)dmab->area,
+ 			      PAGE_ALIGN(size) >> PAGE_SHIFT);
+ #endif
+ 	return 0;
+ }
+ 
+ static void snd_dma_dev_free(struct snd_dma_buffer *dmab)
+ {
+ #ifdef CONFIG_X86
+ 	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
+ 		set_memory_wb((unsigned long)dmab->area,
+ 			      PAGE_ALIGN(dmab->bytes) >> PAGE_SHIFT);
+ #endif
+ 	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+ }
+ 
+ static int snd_dma_dev_mmap(struct snd_dma_buffer *dmab,
+ 			    struct vm_area_struct *area)
+ {
+ 	return dma_mmap_coherent(dmab->dev.dev, area,
+ 				 dmab->area, dmab->addr, dmab->bytes);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_dev_ops = {
+ 	.alloc = snd_dma_dev_alloc,
+ 	.free = snd_dma_dev_free,
+ 	.mmap = snd_dma_dev_mmap,
+ };
+ #endif /* CONFIG_HAS_DMA */
+ 
+ /*
+  * Entry points
+  */
+ static const struct snd_malloc_ops *dma_ops[] = {
+ 	[SNDRV_DMA_TYPE_CONTINUOUS] = &snd_dma_continuous_ops,
+ 	[SNDRV_DMA_TYPE_VMALLOC] = &snd_dma_vmalloc_ops,
+ #ifdef CONFIG_HAS_DMA
+ 	[SNDRV_DMA_TYPE_DEV] = &snd_dma_dev_ops,
+ 	[SNDRV_DMA_TYPE_DEV_UC] = &snd_dma_dev_ops,
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ 	[SNDRV_DMA_TYPE_DEV_IRAM] = &snd_dma_iram_ops,
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ #endif /* CONFIG_HAS_DMA */
+ #ifdef CONFIG_SND_DMA_SGBUF
+ 	[SNDRV_DMA_TYPE_DEV_SG] = &snd_dma_sg_ops,
+ 	[SNDRV_DMA_TYPE_DEV_UC_SG] = &snd_dma_sg_ops,
+ #endif
+ };
+ 
+ static const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab)
+ {
+ 	if (WARN_ON_ONCE(dmab->dev.type <= SNDRV_DMA_TYPE_UNKNOWN ||
+ 			 dmab->dev.type >= ARRAY_SIZE(dma_ops)))
+ 		return NULL;
+ 	return dma_ops[dmab->dev.type];
+ }
++>>>>>>> eda80d7c9c4d (ALSA: memalloc: Fix regression with SNDRV_DMA_TYPE_CONTINUOUS)
* Unmerged path sound/core/memalloc.c
