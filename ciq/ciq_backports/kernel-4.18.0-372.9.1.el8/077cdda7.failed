net/mlx5e: TC, Fix memory leak with rules with internal port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 077cdda764c7f147e03e6065ba0cd1dbc1bf00d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/077cdda7.failed

Fix a memory leak with decap rule with internal port as destination
device. The driver allocates a modify hdr action but doesn't set
the flow attr modify hdr action which results in skipping releasing
the modify hdr action when releasing the flow.

backtrace:
    [<000000005f8c651c>] krealloc+0x83/0xd0
    [<000000009f59b143>] alloc_mod_hdr_actions+0x156/0x310 [mlx5_core]
    [<000000002257f342>] mlx5e_tc_match_to_reg_set_and_get_id+0x12a/0x360 [mlx5_core]
    [<00000000b44ea75a>] mlx5e_tc_add_fdb_flow+0x962/0x1470 [mlx5_core]
    [<0000000003e384a0>] __mlx5e_add_fdb_flow+0x54c/0xb90 [mlx5_core]
    [<00000000ed8b22b6>] mlx5e_configure_flower+0xe45/0x4af0 [mlx5_core]
    [<00000000024f4ab5>] mlx5e_rep_indr_offload.isra.0+0xfe/0x1b0 [mlx5_core]
    [<000000006c3bb494>] mlx5e_rep_indr_setup_tc_cb+0x90/0x130 [mlx5_core]
    [<00000000d3dac2ea>] tc_setup_cb_add+0x1d2/0x420

Fixes: b16eb3c81fe2 ("net/mlx5: Support internal port as decap route device")
	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 077cdda764c7f147e03e6065ba0cd1dbc1bf00d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 36dc4da53fcf,5e454a14428f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1437,6 -1424,26 +1437,29 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  		err = mlx5e_attach_decap_route(priv, flow);
  		if (err)
  			goto err_out;
++<<<<<<< HEAD
++=======
+ 
+ 		if (!attr->chain && esw_attr->int_port) {
+ 			/* If decap route device is internal port, change the
+ 			 * source vport value in reg_c0 back to uplink just in
+ 			 * case the rule performs goto chain > 0. If we have a miss
+ 			 * on chain > 0 we want the metadata regs to hold the
+ 			 * chain id so SW will resume handling of this packet
+ 			 * from the proper chain.
+ 			 */
+ 			u32 metadata = mlx5_eswitch_get_vport_metadata_for_set(esw,
+ 									esw_attr->in_rep->vport);
+ 
+ 			err = mlx5e_tc_match_to_reg_set(priv->mdev, &parse_attr->mod_hdr_acts,
+ 							MLX5_FLOW_NAMESPACE_FDB, VPORT_TO_REG,
+ 							metadata);
+ 			if (err)
+ 				goto err_out;
+ 
+ 			attr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+ 		}
++>>>>>>> 077cdda764c7 (net/mlx5e: TC, Fix memory leak with rules with internal port)
  	}
  
  	if (flow_flag_test(flow, L3_TO_L2_DECAP)) {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
