optee: Fix multi page dynamic shm pool alloc

jira LE-1907
cve CVE-2021-44733
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Sumit Garg <sumit.garg@linaro.org>
commit 5a769f6ff439cedc547395a6dc78faa26108f741
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/5a769f6f.failed

optee_shm_register() expected pages to be passed as an array of page
pointers rather than as an array of contiguous pages. So fix that via
correctly passing pages as per expectation.

Fixes: a249dd200d03 ("tee: optee: Fix dynamic shm pool allocations")
	Reported-by: Vincent Cao <vincent.t.cao@intel.com>
	Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
	Tested-by: Vincent Cao <vincent.t.cao@intel.com>
	Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
(cherry picked from commit 5a769f6ff439cedc547395a6dc78faa26108f741)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tee/optee/shm_pool.c
diff --cc drivers/tee/optee/shm_pool.c
index 49397813fff1,d767eebf30bd..000000000000
--- a/drivers/tee/optee/shm_pool.c
+++ b/drivers/tee/optee/shm_pool.c
@@@ -35,7 -27,26 +35,30 @@@ static int pool_op_alloc(struct tee_shm
  	shm->paddr = page_to_phys(page);
  	shm->size = PAGE_SIZE << order;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	if (shm->flags & TEE_SHM_DMA_BUF) {
+ 		unsigned int nr_pages = 1 << order, i;
+ 		struct page **pages;
+ 
+ 		pages = kcalloc(nr_pages, sizeof(pages), GFP_KERNEL);
+ 		if (!pages)
+ 			return -ENOMEM;
+ 
+ 		for (i = 0; i < nr_pages; i++) {
+ 			pages[i] = page;
+ 			page++;
+ 		}
+ 
+ 		shm->flags |= TEE_SHM_REGISTER;
+ 		rc = optee_shm_register(shm->ctx, shm, pages, nr_pages,
+ 					(unsigned long)shm->kaddr);
+ 		kfree(pages);
+ 	}
+ 
+ 	return rc;
++>>>>>>> 5a769f6ff439 (optee: Fix multi page dynamic shm pool alloc)
  }
  
  static void pool_op_free(struct tee_shm_pool_mgr *poolm,
* Unmerged path drivers/tee/optee/shm_pool.c
