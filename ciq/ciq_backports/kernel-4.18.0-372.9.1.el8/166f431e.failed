net/mlx5e: Add indirect tc offload of ovs internal port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Ariel Levkovich <lariel@nvidia.com>
commit 166f431ec6beaf472bc2e116a202a127b64779e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/166f431e.failed

Register callbacks for tc blocks of ovs internal port devices.

This allows an indirect offloading rules that apply on
such devices as the filter device.

In case a rule is added to a tc block of an internal port,
the mlx5 driver will implicitly add a matching on the internal
port's unique vport metadata value to the rule's matching list.
Therefore, only packets that previously hit a rule that redirects
to an internal port and got the vport metadata overwritten to the
internal port's unique metadata, can match on such indirect rule.

Offloading of both ingress and egress tc blocks of internal ports
is supported as opposed to other devices where only ingress block
offloading is supported.

	Signed-off-by: Ariel Levkovich <lariel@nvidia.com>
	Reviewed-by: Paul Blakey <paulb@nvidia.com>
	Reviewed-by: Vlad Buslov <vladbu@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 166f431ec6beaf472bc2e116a202a127b64779e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
index 525cab02c6b1,fcb0892c08a9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
@@@ -423,10 -441,24 +432,29 @@@ mlx5e_rep_indr_setup_block(struct net_d
  	struct flow_block_cb *block_cb;
  
  	if (!mlx5e_tc_tun_device_to_offload(priv, netdev) &&
++<<<<<<< HEAD
 +	    !(is_vlan_dev(netdev) && vlan_dev_real_dev(netdev) == rpriv->netdev))
 +		return -EOPNOTSUPP;
++=======
+ 	    !(is_vlan_dev(netdev) && vlan_dev_real_dev(netdev) == rpriv->netdev) &&
+ 	    !is_ovs_int_port) {
+ 		if (!(netif_is_macvlan(netdev) && macvlan_dev_real_dev(netdev) == rpriv->netdev))
+ 			return -EOPNOTSUPP;
+ 		if (!mlx5e_rep_macvlan_mode_supported(netdev)) {
+ 			netdev_warn(netdev, "Offloading ingress filter is supported only with macvlan passthru mode");
+ 			return -EOPNOTSUPP;
+ 		}
+ 	}
++>>>>>>> 166f431ec6be (net/mlx5e: Add indirect tc offload of ovs internal port)
+ 
+ 	if (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS &&
+ 	    f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS && !is_ovs_int_port)
+ 		return -EOPNOTSUPP;
  
- 	if (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 	if (is_ovs_int_port && !mlx5e_tc_int_port_supported(esw))
  		return -EOPNOTSUPP;
  
  	f->unlocked_driver_cb = true;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 36dc4da53fcf,e11a906d70c7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1604,6 -1618,12 +1630,15 @@@ static void mlx5e_tc_del_fdb_flow(struc
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT)
  		mlx5_fc_destroy(esw_attr->counter_dev, attr->counter);
  
++<<<<<<< HEAD
++=======
+ 	if (esw_attr->int_port)
+ 		mlx5e_tc_int_port_put(mlx5e_get_int_port_priv(priv), esw_attr->int_port);
+ 
+ 	if (esw_attr->dest_int_port)
+ 		mlx5e_tc_int_port_put(mlx5e_get_int_port_priv(priv), esw_attr->dest_int_port);
+ 
++>>>>>>> 166f431ec6be (net/mlx5e: Add indirect tc offload of ovs internal port)
  	if (flow_flag_test(flow, L3_TO_L2_DECAP))
  		mlx5e_detach_decap(priv, flow);
  
@@@ -4027,6 -4283,14 +4062,17 @@@ static int parse_tc_fdb_actions(struct 
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Forward to/from internal port can only have 1 dest */
+ 	if ((netif_is_ovs_master(parse_attr->filter_dev) || esw_attr->dest_int_port) &&
+ 	    esw_attr->out_count > 1) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Rules with internal port can have only one destination");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
++>>>>>>> 166f431ec6be (net/mlx5e: Add indirect tc offload of ovs internal port)
  	/* always set IP version for indirect table handling */
  	attr->ip_version = mlx5e_tc_get_ip_version(&parse_attr->spec, true);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index fd48fcf08e5f,42f8ee2e5d9f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -456,6 -467,8 +456,11 @@@ struct mlx5_esw_flow_attr 
  	struct mlx5_eswitch_rep *in_rep;
  	struct mlx5_core_dev	*in_mdev;
  	struct mlx5_core_dev    *counter_dev;
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_tc_int_port *dest_int_port;
+ 	struct mlx5e_tc_int_port *int_port;
++>>>>>>> 166f431ec6be (net/mlx5e: Add indirect tc offload of ovs internal port)
  
  	int split_count;
  	int out_count;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a066d41cc204..04ce44828bd0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -87,12 +87,18 @@ mlx5_eswitch_set_rule_flow_source(struct mlx5_eswitch *esw,
 				  struct mlx5_flow_spec *spec,
 				  struct mlx5_esw_flow_attr *attr)
 {
-	if (MLX5_CAP_ESW_FLOWTABLE(esw->dev, flow_source) &&
-	    attr && attr->in_rep)
-		spec->flow_context.flow_source =
-			attr->in_rep->vport == MLX5_VPORT_UPLINK ?
-				MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK :
-				MLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT;
+	if (!MLX5_CAP_ESW_FLOWTABLE(esw->dev, flow_source) || !attr || !attr->in_rep)
+		return;
+
+	if (attr->int_port) {
+		spec->flow_context.flow_source = mlx5e_tc_int_port_get_flow_source(attr->int_port);
+
+		return;
+	}
+
+	spec->flow_context.flow_source = (attr->in_rep->vport == MLX5_VPORT_UPLINK) ?
+					 MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK :
+					 MLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT;
 }
 
 /* Actually only the upper 16 bits of reg c0 need to be cleared, but the lower 16 bits
@@ -122,6 +128,8 @@ mlx5_eswitch_set_rule_source_port(struct mlx5_eswitch *esw,
 				  struct mlx5_eswitch *src_esw,
 				  u16 vport)
 {
+	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
+	u32 metadata;
 	void *misc2;
 	void *misc;
 
@@ -131,10 +139,16 @@ mlx5_eswitch_set_rule_source_port(struct mlx5_eswitch *esw,
 	if (mlx5_eswitch_vport_match_metadata_enabled(esw)) {
 		if (mlx5_esw_indir_table_decap_vport(attr))
 			vport = mlx5_esw_indir_table_decap_vport(attr);
+
+		if (esw_attr->int_port)
+			metadata =
+				mlx5e_tc_int_port_get_metadata_for_match(esw_attr->int_port);
+		else
+			metadata =
+				mlx5_eswitch_get_vport_metadata_for_match(src_esw, vport);
+
 		misc2 = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters_2);
-		MLX5_SET(fte_match_set_misc2, misc2, metadata_reg_c_0,
-			 mlx5_eswitch_get_vport_metadata_for_match(src_esw,
-								   vport));
+		MLX5_SET(fte_match_set_misc2, misc2, metadata_reg_c_0, metadata);
 
 		misc2 = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters_2);
 		MLX5_SET(fte_match_set_misc2, misc2, metadata_reg_c_0,
