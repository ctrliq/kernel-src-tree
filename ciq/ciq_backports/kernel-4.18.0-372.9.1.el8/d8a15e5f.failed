ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit d8a15e5fcae132dc6a44847535ce355f6fba46f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/d8a15e5f.failed

First thing the pipelines function which have "struct device *dev" as
parameter do is:
struct snd_sof_dev *sdev = dev_get_drvdata(dev);

and in all cases the passed dev is actually coming from sdev->dev.

Skip this steps and pass directly the sdev to all pipelines related
functions as few of them already does this.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
Link: https://lore.kernel.org/r/20211006111651.10027-1-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit d8a15e5fcae132dc6a44847535ce355f6fba46f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/pm.c
#	sound/soc/sof/sof-audio.c
#	sound/soc/sof/sof-audio.h
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/pm.c
index 891e8b924fb7,e65f4f4d6df9..000000000000
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@@ -157,7 -157,7 +157,11 @@@ static int sof_resume(struct device *de
  	}
  
  	/* restore pipelines */
++<<<<<<< HEAD
 +	ret = sof_set_up_pipelines(sdev->dev);
++=======
+ 	ret = sof_set_up_pipelines(sdev, false);
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  	if (ret < 0) {
  		dev_err(sdev->dev,
  			"error: failed to restore pipeline after resume %d\n",
@@@ -208,7 -208,7 +212,11 @@@ static int sof_suspend(struct device *d
  	if (target_state == SOF_DSP_PM_D0)
  		goto suspend;
  
++<<<<<<< HEAD
 +	sof_tear_down_pipelines(dev);
++=======
+ 	sof_tear_down_pipelines(sdev, false);
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  
  	/* release trace */
  	snd_sof_release_trace(sdev);
diff --cc sound/soc/sof/sof-audio.c
index f17b0b574e42,7cbe757c1fe2..000000000000
--- a/sound/soc/sof/sof-audio.c
+++ b/sound/soc/sof/sof-audio.c
@@@ -210,6 -235,266 +210,269 @@@ use_count_dec
  }
  EXPORT_SYMBOL(sof_widget_setup);
  
++<<<<<<< HEAD
++=======
+ static int sof_route_setup_ipc(struct snd_sof_dev *sdev, struct snd_sof_route *sroute)
+ {
+ 	struct sof_ipc_pipe_comp_connect *connect;
+ 	struct sof_ipc_reply reply;
+ 	int ret;
+ 
+ 	/* skip if there's no private data */
+ 	if (!sroute->private)
+ 		return 0;
+ 
+ 	/* nothing to do if route is already set up */
+ 	if (sroute->setup)
+ 		return 0;
+ 
+ 	connect = sroute->private;
+ 
+ 	dev_dbg(sdev->dev, "setting up route %s -> %s\n",
+ 		sroute->src_widget->widget->name,
+ 		sroute->sink_widget->widget->name);
+ 
+ 	/* send ipc */
+ 	ret = sof_ipc_tx_message(sdev->ipc,
+ 				 connect->hdr.cmd,
+ 				 connect, sizeof(*connect),
+ 				 &reply, sizeof(reply));
+ 	if (ret < 0) {
+ 		dev_err(sdev->dev, "%s: route setup failed %d\n", __func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	sroute->setup = true;
+ 
+ 	return 0;
+ }
+ 
+ static int sof_route_setup(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *wsource,
+ 			   struct snd_soc_dapm_widget *wsink)
+ {
+ 	struct snd_sof_widget *src_widget = wsource->dobj.private;
+ 	struct snd_sof_widget *sink_widget = wsink->dobj.private;
+ 	struct snd_sof_route *sroute;
+ 	bool route_found = false;
+ 
+ 	/* ignore routes involving virtual widgets in topology */
+ 	switch (src_widget->id) {
+ 	case snd_soc_dapm_out_drv:
+ 	case snd_soc_dapm_output:
+ 	case snd_soc_dapm_input:
+ 		return 0;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	switch (sink_widget->id) {
+ 	case snd_soc_dapm_out_drv:
+ 	case snd_soc_dapm_output:
+ 	case snd_soc_dapm_input:
+ 		return 0;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/* find route matching source and sink widgets */
+ 	list_for_each_entry(sroute, &sdev->route_list, list)
+ 		if (sroute->src_widget == src_widget && sroute->sink_widget == sink_widget) {
+ 			route_found = true;
+ 			break;
+ 		}
+ 
+ 	if (!route_found) {
+ 		dev_err(sdev->dev, "error: cannot find SOF route for source %s -> %s sink\n",
+ 			wsource->name, wsink->name);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return sof_route_setup_ipc(sdev, sroute);
+ }
+ 
+ static int sof_setup_pipeline_connections(struct snd_sof_dev *sdev,
+ 					  struct snd_soc_dapm_widget_list *list, int dir)
+ {
+ 	struct snd_soc_dapm_widget *widget;
+ 	struct snd_soc_dapm_path *p;
+ 	int ret;
+ 	int i;
+ 
+ 	/*
+ 	 * Set up connections between widgets in the sink/source paths based on direction.
+ 	 * Some non-SOF widgets exist in topology either for compatibility or for the
+ 	 * purpose of connecting a pipeline from a host to a DAI in order to receive the DAPM
+ 	 * events. But they are not handled by the firmware. So ignore them.
+ 	 */
+ 	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+ 		for_each_dapm_widgets(list, i, widget) {
+ 			if (!widget->dobj.private)
+ 				continue;
+ 
+ 			snd_soc_dapm_widget_for_each_sink_path(widget, p)
+ 				if (p->sink->dobj.private) {
+ 					ret = sof_route_setup(sdev, widget, p->sink);
+ 					if (ret < 0)
+ 						return ret;
+ 				}
+ 		}
+ 	} else {
+ 		for_each_dapm_widgets(list, i, widget) {
+ 			if (!widget->dobj.private)
+ 				continue;
+ 
+ 			snd_soc_dapm_widget_for_each_source_path(widget, p)
+ 				if (p->source->dobj.private) {
+ 					ret = sof_route_setup(sdev, p->source, widget);
+ 					if (ret < 0)
+ 						return ret;
+ 				}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int sof_widget_list_setup(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm, int dir)
+ {
+ 	struct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;
+ 	struct snd_soc_dapm_widget *widget;
+ 	int i, ret, num_widgets;
+ 
+ 	/* nothing to set up */
+ 	if (!list)
+ 		return 0;
+ 
+ 	/* set up widgets in the list */
+ 	for_each_dapm_widgets(list, num_widgets, widget) {
+ 		struct snd_sof_widget *swidget = widget->dobj.private;
+ 		struct snd_sof_widget *pipe_widget;
+ 
+ 		if (!swidget)
+ 			continue;
+ 
+ 		/*
+ 		 * The scheduler widget for a pipeline is not part of the connected DAPM
+ 		 * widget list and it needs to be set up before the widgets in the pipeline
+ 		 * are set up. The use_count for the scheduler widget is incremented for every
+ 		 * widget in a given pipeline to ensure that it is freed only after the last
+ 		 * widget in the pipeline is freed.
+ 		 */
+ 		pipe_widget = swidget->pipe_widget;
+ 		if (!pipe_widget) {
+ 			dev_err(sdev->dev, "error: no pipeline widget found for %s\n",
+ 				swidget->widget->name);
+ 			ret = -EINVAL;
+ 			goto widget_free;
+ 		}
+ 
+ 		ret = sof_widget_setup(sdev, pipe_widget);
+ 		if (ret < 0)
+ 			goto widget_free;
+ 
+ 		/* set up the widget */
+ 		ret = sof_widget_setup(sdev, swidget);
+ 		if (ret < 0) {
+ 			sof_widget_free(sdev, pipe_widget);
+ 			goto widget_free;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * error in setting pipeline connections will result in route status being reset for
+ 	 * routes that were successfully set up when the widgets are freed.
+ 	 */
+ 	ret = sof_setup_pipeline_connections(sdev, list, dir);
+ 	if (ret < 0)
+ 		goto widget_free;
+ 
+ 	/* complete pipelines */
+ 	for_each_dapm_widgets(list, i, widget) {
+ 		struct snd_sof_widget *swidget = widget->dobj.private;
+ 		struct snd_sof_widget *pipe_widget;
+ 
+ 		if (!swidget)
+ 			continue;
+ 
+ 		pipe_widget = swidget->pipe_widget;
+ 		if (!pipe_widget) {
+ 			dev_err(sdev->dev, "error: no pipeline widget found for %s\n",
+ 				swidget->widget->name);
+ 			ret = -EINVAL;
+ 			goto widget_free;
+ 		}
+ 
+ 		if (pipe_widget->complete)
+ 			continue;
+ 
+ 		pipe_widget->complete = snd_sof_complete_pipeline(sdev, pipe_widget);
+ 		if (pipe_widget->complete < 0) {
+ 			ret = pipe_widget->complete;
+ 			goto widget_free;
+ 		}
+ 	}
+ 
+ 	return 0;
+ 
+ widget_free:
+ 	/* free all widgets that have been set up successfully */
+ 	for_each_dapm_widgets(list, i, widget) {
+ 		struct snd_sof_widget *swidget = widget->dobj.private;
+ 
+ 		if (!swidget)
+ 			continue;
+ 
+ 		if (!num_widgets--)
+ 			break;
+ 
+ 		sof_widget_free(sdev, swidget);
+ 		sof_widget_free(sdev, swidget->pipe_widget);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ int sof_widget_list_free(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm, int dir)
+ {
+ 	struct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;
+ 	struct snd_soc_dapm_widget *widget;
+ 	int i, ret;
+ 	int ret1 = 0;
+ 
+ 	/* nothing to free */
+ 	if (!list)
+ 		return 0;
+ 
+ 	/*
+ 	 * Free widgets in the list. This can fail but continue freeing other widgets to keep
+ 	 * use_counts balanced.
+ 	 */
+ 	for_each_dapm_widgets(list, i, widget) {
+ 		struct snd_sof_widget *swidget = widget->dobj.private;
+ 
+ 		if (!swidget)
+ 			continue;
+ 
+ 		/*
+ 		 * free widget and its pipe_widget. Either of these can fail, but free as many as
+ 		 * possible before freeing the list and returning the error.
+ 		 */
+ 		ret = sof_widget_free(sdev, swidget);
+ 		if (ret < 0)
+ 			ret1 = ret;
+ 
+ 		ret = sof_widget_free(sdev, swidget->pipe_widget);
+ 		if (ret < 0)
+ 			ret1 = ret;
+ 	}
+ 
+ 	snd_soc_dapm_dai_free_widgets(&list);
+ 	spcm->stream[dir].list = NULL;
+ 
+ 	return ret1;
+ }
+ 
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  /*
   * helper to determine if there are only D0i3 compatible
   * streams active
@@@ -308,12 -593,10 +571,15 @@@ const struct sof_ipc_pipe_new *snd_sof_
  	return NULL;
  }
  
++<<<<<<< HEAD
 +int sof_set_up_pipelines(struct device *dev)
++=======
+ int sof_set_up_pipelines(struct snd_sof_dev *sdev, bool verify)
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  {
- 	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
  	struct snd_sof_widget *swidget;
  	struct snd_sof_route *sroute;
 +	struct snd_sof_dai *dai;
  	int ret;
  
  	/* restore pipeline components */
@@@ -377,8 -648,12 +643,8 @@@
  	list_for_each_entry(swidget, &sdev->widget_list, list) {
  		switch (swidget->id) {
  		case snd_soc_dapm_scheduler:
 -			/* only complete static pipelines */
 -			if (!verify && swidget->dynamic_pipeline_widget)
 -				continue;
 -
  			swidget->complete =
- 				snd_sof_complete_pipeline(dev, swidget);
+ 				snd_sof_complete_pipeline(sdev, swidget);
  			break;
  		default:
  			break;
@@@ -389,21 -664,31 +655,24 @@@
  }
  
  /*
 - * This function doesn't free widgets during suspend. It only resets the set up status for all
 - * routes and use_count for all widgets.
 + * This function doesn't free widgets. It only resets the set up status for all routes and
 + * use_count for all widgets.
   */
++<<<<<<< HEAD
 +void sof_tear_down_pipelines(struct device *dev)
++=======
+ int sof_tear_down_pipelines(struct snd_sof_dev *sdev, bool verify)
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  {
- 	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
  	struct snd_sof_widget *swidget;
  	struct snd_sof_route *sroute;
 -	int ret;
  
  	/*
 -	 * This function is called during suspend and for one-time topology verification during
 -	 * first boot. In both cases, there is no need to protect swidget->use_count and
 -	 * sroute->setup because during suspend all streams are suspended and during topology
 -	 * loading the sound card unavailable to open PCMs.
 +	 * No need to protect swidget->use_count and sroute->setup as this function is called only
 +	 * during the suspend callback and all streams should be suspended by then
  	 */
 -	list_for_each_entry_reverse(swidget, &sdev->widget_list, list) {
 -		if (!verify) {
 -			swidget->use_count = 0;
 -			continue;
 -		}
 -
 -		ret = sof_widget_free(sdev, swidget);
 -		if (ret < 0)
 -			return ret;
 -	}
 +	list_for_each_entry(swidget, &sdev->widget_list, list)
 +		swidget->use_count = 0;
  
  	list_for_each_entry(sroute, &sdev->route_list, list)
  		sroute->setup = false;
diff --cc sound/soc/sof/sof-audio.h
index d358d455da1e,fe2ffe02fdfb..000000000000
--- a/sound/soc/sof/sof-audio.h
+++ b/sound/soc/sof/sof-audio.h
@@@ -243,8 -246,8 +243,13 @@@ int snd_sof_ipc_set_get_comp_data(struc
  int sof_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_hw_params *params);
  
  /* PM */
++<<<<<<< HEAD
 +int sof_set_up_pipelines(struct device *dev);
 +void sof_tear_down_pipelines(struct device *dev);
++=======
+ int sof_set_up_pipelines(struct snd_sof_dev *sdev, bool verify);
+ int sof_tear_down_pipelines(struct snd_sof_dev *sdev, bool verify);
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  int sof_set_hw_params_upon_resume(struct device *dev);
  bool snd_sof_stream_suspend_ignored(struct snd_sof_dev *sdev);
  bool snd_sof_dsp_only_d0i3_compatible_stream_active(struct snd_sof_dev *sdev);
diff --cc sound/soc/sof/topology.c
index e0e5650e1611,6a0dbd4487c0..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -3459,8 -3465,23 +3457,28 @@@ static int sof_complete(struct snd_soc_
  		}
  	}
  
++<<<<<<< HEAD
 +	/* set up static pipelines */
 +	return sof_set_up_pipelines(scomp->dev);
++=======
+ 	/* verify topology components loading including dynamic pipelines */
+ 	if (sof_core_debug & SOF_DBG_VERIFY_TPLG) {
+ 		ret = sof_set_up_pipelines(sdev, true);
+ 		if (ret < 0) {
+ 			dev_err(sdev->dev, "error: topology verification failed %d\n", ret);
+ 			return ret;
+ 		}
+ 
+ 		ret = sof_tear_down_pipelines(sdev, true);
+ 		if (ret < 0) {
+ 			dev_err(sdev->dev, "error: topology tear down pipelines failed %d\n", ret);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	/* set up static pipelines */
+ 	return sof_set_up_pipelines(sdev, false);
++>>>>>>> d8a15e5fcae1 (ASoC: SOF: pipelines: Harmonize all functions to use struct snd_sof_dev)
  }
  
  /* manifest - optional to inform component of manifest */
* Unmerged path sound/soc/sof/pm.c
* Unmerged path sound/soc/sof/sof-audio.c
* Unmerged path sound/soc/sof/sof-audio.h
* Unmerged path sound/soc/sof/topology.c
