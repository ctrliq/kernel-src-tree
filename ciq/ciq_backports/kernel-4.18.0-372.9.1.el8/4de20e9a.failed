net/mlx5: Bridge, release bridge in same function where it is taken

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit 4de20e9a1225866a9a2ac2e12cddee51455991fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/4de20e9a.failed

Refactor mlx5_esw_bridge_vport_link() to release the bridge instance if
mlx5_esw_bridge_vport_init() returned an error instead of relying on it to
release the bridge. This improves the design because object instance is
taken and released in same layer and simplifies following patches that add
more logic to mlx5_esw_bridge_vport_link().

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 4de20e9a1225866a9a2ac2e12cddee51455991fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
index b503562f97d0,4bca480e3e7d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
@@@ -265,11 -639,428 +265,38 @@@ mlx5_esw_bridge_lookup(int ifindex, str
  	return bridge;
  }
  
 -static int mlx5_esw_bridge_port_insert(struct mlx5_esw_bridge_port *port,
 -				       struct mlx5_esw_bridge *bridge)
 -{
 -	return xa_insert(&bridge->vports, port->vport_num, port, GFP_KERNEL);
 -}
 -
 -static struct mlx5_esw_bridge_port *
 -mlx5_esw_bridge_port_lookup(u16 vport_num, struct mlx5_esw_bridge *bridge)
 -{
 -	return xa_load(&bridge->vports, vport_num);
 -}
 -
 -static void mlx5_esw_bridge_port_erase(struct mlx5_esw_bridge_port *port,
 -				       struct mlx5_esw_bridge *bridge)
 -{
 -	xa_erase(&bridge->vports, port->vport_num);
 -}
 -
 -static void mlx5_esw_bridge_fdb_entry_refresh(unsigned long lastuse,
 -					      struct mlx5_esw_bridge_fdb_entry *entry)
 -{
 -	trace_mlx5_esw_bridge_fdb_entry_refresh(entry);
 -
 -	entry->lastuse = lastuse;
 -	mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
 -					   entry->key.vid,
 -					   SWITCHDEV_FDB_ADD_TO_BRIDGE);
 -}
 -
 -static void
 -mlx5_esw_bridge_fdb_entry_cleanup(struct mlx5_esw_bridge_fdb_entry *entry,
 -				  struct mlx5_esw_bridge *bridge)
 -{
 -	trace_mlx5_esw_bridge_fdb_entry_cleanup(entry);
 -
 -	rhashtable_remove_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);
 -	mlx5_del_flow_rules(entry->egress_handle);
 -	if (entry->filter_handle)
 -		mlx5_del_flow_rules(entry->filter_handle);
 -	mlx5_del_flow_rules(entry->ingress_handle);
 -	mlx5_fc_destroy(bridge->br_offloads->esw->dev, entry->ingress_counter);
 -	list_del(&entry->vlan_list);
 -	list_del(&entry->list);
 -	kvfree(entry);
 -}
 -
 -static void mlx5_esw_bridge_fdb_flush(struct mlx5_esw_bridge *bridge)
 -{
 -	struct mlx5_esw_bridge_fdb_entry *entry, *tmp;
 -
 -	list_for_each_entry_safe(entry, tmp, &bridge->fdb_list, list) {
 -		if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER))
 -			mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
 -							   entry->key.vid,
 -							   SWITCHDEV_FDB_DEL_TO_BRIDGE);
 -		mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
 -	}
 -}
 -
 -static struct mlx5_esw_bridge_vlan *
 -mlx5_esw_bridge_vlan_lookup(u16 vid, struct mlx5_esw_bridge_port *port)
 -{
 -	return xa_load(&port->vlans, vid);
 -}
 -
 -static int
 -mlx5_esw_bridge_vlan_push_create(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)
 -{
 -	struct {
 -		__be16	h_vlan_proto;
 -		__be16	h_vlan_TCI;
 -	} vlan_hdr = { htons(ETH_P_8021Q), htons(vlan->vid) };
 -	struct mlx5_pkt_reformat_params reformat_params = {};
 -	struct mlx5_pkt_reformat *pkt_reformat;
 -
 -	if (!BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, reformat_insert)) ||
 -	    MLX5_CAP_GEN_2(esw->dev, max_reformat_insert_size) < sizeof(vlan_hdr) ||
 -	    MLX5_CAP_GEN_2(esw->dev, max_reformat_insert_offset) <
 -	    offsetof(struct vlan_ethhdr, h_vlan_proto)) {
 -		esw_warn(esw->dev, "Packet reformat INSERT_HEADER is not supported\n");
 -		return -EOPNOTSUPP;
 -	}
 -
 -	reformat_params.type = MLX5_REFORMAT_TYPE_INSERT_HDR;
 -	reformat_params.param_0 = MLX5_REFORMAT_CONTEXT_ANCHOR_MAC_START;
 -	reformat_params.param_1 = offsetof(struct vlan_ethhdr, h_vlan_proto);
 -	reformat_params.size = sizeof(vlan_hdr);
 -	reformat_params.data = &vlan_hdr;
 -	pkt_reformat = mlx5_packet_reformat_alloc(esw->dev,
 -						  &reformat_params,
 -						  MLX5_FLOW_NAMESPACE_FDB);
 -	if (IS_ERR(pkt_reformat)) {
 -		esw_warn(esw->dev, "Failed to alloc packet reformat INSERT_HEADER (err=%ld)\n",
 -			 PTR_ERR(pkt_reformat));
 -		return PTR_ERR(pkt_reformat);
 -	}
 -
 -	vlan->pkt_reformat_push = pkt_reformat;
 -	return 0;
 -}
 -
 -static void
 -mlx5_esw_bridge_vlan_push_cleanup(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)
 -{
 -	mlx5_packet_reformat_dealloc(esw->dev, vlan->pkt_reformat_push);
 -	vlan->pkt_reformat_push = NULL;
 -}
 -
 -static int
 -mlx5_esw_bridge_vlan_pop_create(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)
 -{
 -	struct mlx5_pkt_reformat_params reformat_params = {};
 -	struct mlx5_pkt_reformat *pkt_reformat;
 -
 -	if (!BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, reformat_remove)) ||
 -	    MLX5_CAP_GEN_2(esw->dev, max_reformat_remove_size) < sizeof(struct vlan_hdr) ||
 -	    MLX5_CAP_GEN_2(esw->dev, max_reformat_remove_offset) <
 -	    offsetof(struct vlan_ethhdr, h_vlan_proto)) {
 -		esw_warn(esw->dev, "Packet reformat REMOVE_HEADER is not supported\n");
 -		return -EOPNOTSUPP;
 -	}
 -
 -	reformat_params.type = MLX5_REFORMAT_TYPE_REMOVE_HDR;
 -	reformat_params.param_0 = MLX5_REFORMAT_CONTEXT_ANCHOR_MAC_START;
 -	reformat_params.param_1 = offsetof(struct vlan_ethhdr, h_vlan_proto);
 -	reformat_params.size = sizeof(struct vlan_hdr);
 -	pkt_reformat = mlx5_packet_reformat_alloc(esw->dev,
 -						  &reformat_params,
 -						  MLX5_FLOW_NAMESPACE_FDB);
 -	if (IS_ERR(pkt_reformat)) {
 -		esw_warn(esw->dev, "Failed to alloc packet reformat REMOVE_HEADER (err=%ld)\n",
 -			 PTR_ERR(pkt_reformat));
 -		return PTR_ERR(pkt_reformat);
 -	}
 -
 -	vlan->pkt_reformat_pop = pkt_reformat;
 -	return 0;
 -}
 -
 -static void
 -mlx5_esw_bridge_vlan_pop_cleanup(struct mlx5_esw_bridge_vlan *vlan, struct mlx5_eswitch *esw)
 -{
 -	mlx5_packet_reformat_dealloc(esw->dev, vlan->pkt_reformat_pop);
 -	vlan->pkt_reformat_pop = NULL;
 -}
 -
 -static struct mlx5_esw_bridge_vlan *
 -mlx5_esw_bridge_vlan_create(u16 vid, u16 flags, struct mlx5_esw_bridge_port *port,
 -			    struct mlx5_eswitch *esw)
 -{
 -	struct mlx5_esw_bridge_vlan *vlan;
 -	int err;
 -
 -	vlan = kvzalloc(sizeof(*vlan), GFP_KERNEL);
 -	if (!vlan)
 -		return ERR_PTR(-ENOMEM);
 -
 -	vlan->vid = vid;
 -	vlan->flags = flags;
 -	INIT_LIST_HEAD(&vlan->fdb_list);
 -
 -	if (flags & BRIDGE_VLAN_INFO_PVID) {
 -		err = mlx5_esw_bridge_vlan_push_create(vlan, esw);
 -		if (err)
 -			goto err_vlan_push;
 -	}
 -	if (flags & BRIDGE_VLAN_INFO_UNTAGGED) {
 -		err = mlx5_esw_bridge_vlan_pop_create(vlan, esw);
 -		if (err)
 -			goto err_vlan_pop;
 -	}
 -
 -	err = xa_insert(&port->vlans, vid, vlan, GFP_KERNEL);
 -	if (err)
 -		goto err_xa_insert;
 -
 -	trace_mlx5_esw_bridge_vlan_create(vlan);
 -	return vlan;
 -
 -err_xa_insert:
 -	if (vlan->pkt_reformat_pop)
 -		mlx5_esw_bridge_vlan_pop_cleanup(vlan, esw);
 -err_vlan_pop:
 -	if (vlan->pkt_reformat_push)
 -		mlx5_esw_bridge_vlan_push_cleanup(vlan, esw);
 -err_vlan_push:
 -	kvfree(vlan);
 -	return ERR_PTR(err);
 -}
 -
 -static void mlx5_esw_bridge_vlan_erase(struct mlx5_esw_bridge_port *port,
 -				       struct mlx5_esw_bridge_vlan *vlan)
 -{
 -	xa_erase(&port->vlans, vlan->vid);
 -}
 -
 -static void mlx5_esw_bridge_vlan_flush(struct mlx5_esw_bridge_vlan *vlan,
 -				       struct mlx5_esw_bridge *bridge)
 -{
 -	struct mlx5_esw_bridge_fdb_entry *entry, *tmp;
 -
 -	list_for_each_entry_safe(entry, tmp, &vlan->fdb_list, vlan_list) {
 -		if (!(entry->flags & MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER))
 -			mlx5_esw_bridge_fdb_offload_notify(entry->dev, entry->key.addr,
 -							   entry->key.vid,
 -							   SWITCHDEV_FDB_DEL_TO_BRIDGE);
 -		mlx5_esw_bridge_fdb_entry_cleanup(entry, bridge);
 -	}
 -
 -	if (vlan->pkt_reformat_pop)
 -		mlx5_esw_bridge_vlan_pop_cleanup(vlan, bridge->br_offloads->esw);
 -	if (vlan->pkt_reformat_push)
 -		mlx5_esw_bridge_vlan_push_cleanup(vlan, bridge->br_offloads->esw);
 -}
 -
 -static void mlx5_esw_bridge_vlan_cleanup(struct mlx5_esw_bridge_port *port,
 -					 struct mlx5_esw_bridge_vlan *vlan,
 -					 struct mlx5_esw_bridge *bridge)
 -{
 -	trace_mlx5_esw_bridge_vlan_cleanup(vlan);
 -	mlx5_esw_bridge_vlan_flush(vlan, bridge);
 -	mlx5_esw_bridge_vlan_erase(port, vlan);
 -	kvfree(vlan);
 -}
 -
 -static void mlx5_esw_bridge_port_vlans_flush(struct mlx5_esw_bridge_port *port,
 -					     struct mlx5_esw_bridge *bridge)
 -{
 -	struct mlx5_esw_bridge_vlan *vlan;
 -	unsigned long index;
 -
 -	xa_for_each(&port->vlans, index, vlan)
 -		mlx5_esw_bridge_vlan_cleanup(port, vlan, bridge);
 -}
 -
 -static struct mlx5_esw_bridge_vlan *
 -mlx5_esw_bridge_port_vlan_lookup(u16 vid, u16 vport_num, struct mlx5_esw_bridge *bridge,
 -				 struct mlx5_eswitch *esw)
 -{
 -	struct mlx5_esw_bridge_port *port;
 -	struct mlx5_esw_bridge_vlan *vlan;
 -
 -	port = mlx5_esw_bridge_port_lookup(vport_num, bridge);
 -	if (!port) {
 -		/* FDB is added asynchronously on wq while port might have been deleted
 -		 * concurrently. Report on 'info' logging level and skip the FDB offload.
 -		 */
 -		esw_info(esw->dev, "Failed to lookup bridge port (vport=%u)\n", vport_num);
 -		return ERR_PTR(-EINVAL);
 -	}
 -
 -	vlan = mlx5_esw_bridge_vlan_lookup(vid, port);
 -	if (!vlan) {
 -		/* FDB is added asynchronously on wq while vlan might have been deleted
 -		 * concurrently. Report on 'info' logging level and skip the FDB offload.
 -		 */
 -		esw_info(esw->dev, "Failed to lookup bridge port vlan metadata (vport=%u)\n",
 -			 vport_num);
 -		return ERR_PTR(-EINVAL);
 -	}
 -
 -	return vlan;
 -}
 -
 -static struct mlx5_esw_bridge_fdb_entry *
 -mlx5_esw_bridge_fdb_entry_init(struct net_device *dev, u16 vport_num, const unsigned char *addr,
 -			       u16 vid, bool added_by_user, struct mlx5_eswitch *esw,
 -			       struct mlx5_esw_bridge *bridge)
 -{
 -	struct mlx5_esw_bridge_vlan *vlan = NULL;
 -	struct mlx5_esw_bridge_fdb_entry *entry;
 -	struct mlx5_flow_handle *handle;
 -	struct mlx5_fc *counter;
 -	struct mlx5e_priv *priv;
 -	int err;
 -
 -	if (bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG && vid) {
 -		vlan = mlx5_esw_bridge_port_vlan_lookup(vid, vport_num, bridge, esw);
 -		if (IS_ERR(vlan))
 -			return ERR_CAST(vlan);
 -	}
 -
 -	priv = netdev_priv(dev);
 -	entry = kvzalloc(sizeof(*entry), GFP_KERNEL);
 -	if (!entry)
 -		return ERR_PTR(-ENOMEM);
 -
 -	ether_addr_copy(entry->key.addr, addr);
 -	entry->key.vid = vid;
 -	entry->dev = dev;
 -	entry->vport_num = vport_num;
 -	entry->lastuse = jiffies;
 -	if (added_by_user)
 -		entry->flags |= MLX5_ESW_BRIDGE_FLAG_ADDED_BY_USER;
 -
 -	counter = mlx5_fc_create(priv->mdev, true);
 -	if (IS_ERR(counter)) {
 -		err = PTR_ERR(counter);
 -		goto err_ingress_fc_create;
 -	}
 -	entry->ingress_counter = counter;
 -
 -	handle = mlx5_esw_bridge_ingress_flow_create(vport_num, addr, vlan, mlx5_fc_id(counter),
 -						     bridge);
 -	if (IS_ERR(handle)) {
 -		err = PTR_ERR(handle);
 -		esw_warn(esw->dev, "Failed to create ingress flow(vport=%u,err=%d)\n",
 -			 vport_num, err);
 -		goto err_ingress_flow_create;
 -	}
 -	entry->ingress_handle = handle;
 -
 -	if (bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG) {
 -		handle = mlx5_esw_bridge_ingress_filter_flow_create(vport_num, addr, bridge);
 -		if (IS_ERR(handle)) {
 -			err = PTR_ERR(handle);
 -			esw_warn(esw->dev, "Failed to create ingress filter(vport=%u,err=%d)\n",
 -				 vport_num, err);
 -			goto err_ingress_filter_flow_create;
 -		}
 -		entry->filter_handle = handle;
 -	}
 -
 -	handle = mlx5_esw_bridge_egress_flow_create(vport_num, addr, vlan, bridge);
 -	if (IS_ERR(handle)) {
 -		err = PTR_ERR(handle);
 -		esw_warn(esw->dev, "Failed to create egress flow(vport=%u,err=%d)\n",
 -			 vport_num, err);
 -		goto err_egress_flow_create;
 -	}
 -	entry->egress_handle = handle;
 -
 -	err = rhashtable_insert_fast(&bridge->fdb_ht, &entry->ht_node, fdb_ht_params);
 -	if (err) {
 -		esw_warn(esw->dev, "Failed to insert FDB flow(vport=%u,err=%d)\n", vport_num, err);
 -		goto err_ht_init;
 -	}
 -
 -	if (vlan)
 -		list_add(&entry->vlan_list, &vlan->fdb_list);
 -	else
 -		INIT_LIST_HEAD(&entry->vlan_list);
 -	list_add(&entry->list, &bridge->fdb_list);
 -
 -	trace_mlx5_esw_bridge_fdb_entry_init(entry);
 -	return entry;
 -
 -err_ht_init:
 -	mlx5_del_flow_rules(entry->egress_handle);
 -err_egress_flow_create:
 -	if (entry->filter_handle)
 -		mlx5_del_flow_rules(entry->filter_handle);
 -err_ingress_filter_flow_create:
 -	mlx5_del_flow_rules(entry->ingress_handle);
 -err_ingress_flow_create:
 -	mlx5_fc_destroy(priv->mdev, entry->ingress_counter);
 -err_ingress_fc_create:
 -	kvfree(entry);
 -	return ERR_PTR(err);
 -}
 -
 -int mlx5_esw_bridge_ageing_time_set(unsigned long ageing_time, struct mlx5_eswitch *esw,
 -				    struct mlx5_vport *vport)
 -{
 -	if (!vport->bridge)
 -		return -EINVAL;
 -
 -	vport->bridge->ageing_time = clock_t_to_jiffies(ageing_time);
 -	return 0;
 -}
 -
 -int mlx5_esw_bridge_vlan_filtering_set(bool enable, struct mlx5_eswitch *esw,
 -				       struct mlx5_vport *vport)
 -{
 -	struct mlx5_esw_bridge *bridge;
 -	bool filtering;
 -
 -	if (!vport->bridge)
 -		return -EINVAL;
 -
 -	bridge = vport->bridge;
 -	filtering = bridge->flags & MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;
 -	if (filtering == enable)
 -		return 0;
 -
 -	mlx5_esw_bridge_fdb_flush(bridge);
 -	if (enable)
 -		bridge->flags |= MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;
 -	else
 -		bridge->flags &= ~MLX5_ESW_BRIDGE_VLAN_FILTERING_FLAG;
 -
 -	return 0;
 -}
 -
 -static int mlx5_esw_bridge_vport_init(struct mlx5_esw_bridge_offloads *br_offloads,
 -				      struct mlx5_esw_bridge *bridge,
 +static int mlx5_esw_bridge_vport_init(struct mlx5_esw_bridge *bridge,
  				      struct mlx5_vport *vport)
  {
++<<<<<<< HEAD
 +	vport->bridge = bridge;
 +	return 0;
++=======
+ 	struct mlx5_eswitch *esw = br_offloads->esw;
+ 	struct mlx5_esw_bridge_port *port;
+ 	int err;
+ 
+ 	port = kvzalloc(sizeof(*port), GFP_KERNEL);
+ 	if (!port)
+ 		return -ENOMEM;
+ 
+ 	port->vport_num = vport->vport;
+ 	xa_init(&port->vlans);
+ 	err = mlx5_esw_bridge_port_insert(port, bridge);
+ 	if (err) {
+ 		esw_warn(esw->dev, "Failed to insert port metadata (vport=%u,err=%d)\n",
+ 			 vport->vport, err);
+ 		goto err_port_insert;
+ 	}
+ 	trace_mlx5_esw_bridge_vport_init(port);
+ 
+ 	vport->bridge = bridge;
+ 	return 0;
+ 
+ err_port_insert:
+ 	kvfree(port);
+ 	return err;
++>>>>>>> 4de20e9a1225 (net/mlx5: Bridge, release bridge in same function where it is taken)
  }
  
  static int mlx5_esw_bridge_vport_cleanup(struct mlx5_esw_bridge_offloads *br_offloads,
@@@ -293,7 -1103,16 +320,20 @@@ int mlx5_esw_bridge_vport_link(int ifin
  		return PTR_ERR(bridge);
  	}
  
++<<<<<<< HEAD
 +	return mlx5_esw_bridge_vport_init(bridge, vport);
++=======
+ 	err = mlx5_esw_bridge_vport_init(br_offloads, bridge, vport);
+ 	if (err) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Error initializing port");
+ 		goto err_vport;
+ 	}
+ 	return 0;
+ 
+ err_vport:
+ 	mlx5_esw_bridge_put(br_offloads, bridge);
+ 	return err;
++>>>>>>> 4de20e9a1225 (net/mlx5: Bridge, release bridge in same function where it is taken)
  }
  
  int mlx5_esw_bridge_vport_unlink(int ifindex, struct mlx5_esw_bridge_offloads *br_offloads,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c
