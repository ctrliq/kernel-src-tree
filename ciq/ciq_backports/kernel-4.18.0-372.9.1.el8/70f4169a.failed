selinux: parse contexts for mount options early

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Ondrej Mosnacek <omosnace@redhat.com>
commit 70f4169ab421b277caf7429e84f468d8c47aa00a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/70f4169a.failed

Commit b8b87fd954b4 ("selinux: Fix selinux_sb_mnt_opts_compat()")
started to parse mount options into SIDs in selinux_add_opt() if policy
has already been loaded. Since it's extremely unlikely that anyone would
depend on the ability to set SELinux contexts on fs_context before
loading the policy and then mounting that context after simplify the
logic by always parsing the options early.

Note that the multi-step mounting is only possible with the new
fscontext mount API and wasn't possible before its introduction.

	Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 70f4169ab421b277caf7429e84f468d8c47aa00a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 594018c0c481,ab32303e6618..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -339,15 -339,7 +339,14 @@@ static void inode_free_security(struct 
  	}
  }
  
 +static void superblock_free_security(struct super_block *sb)
 +{
 +	struct superblock_security_struct *sbsec = sb->s_security;
 +	sb->s_security = NULL;
 +	kfree(sbsec);
 +}
 +
  struct selinux_mnt_opts {
- 	const char *fscontext, *context, *rootcontext, *defcontext;
  	u32 fscontext_sid;
  	u32 context_sid;
  	u32 rootcontext_sid;
@@@ -684,37 -657,29 +667,57 @@@ static int selinux_set_mnt_opts(struct 
  	 * than once with different security options.
  	 */
  	if (opts) {
++<<<<<<< HEAD
 +		if (opts->fscontext) {
 +			rc = parse_sid(sb, opts->fscontext, &fscontext_sid);
 +			if (rc)
 +				goto out;
++=======
+ 		if (opts->fscontext_sid) {
+ 			fscontext_sid = opts->fscontext_sid;
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  			if (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,
  					fscontext_sid))
  				goto out_double_mount;
  			sbsec->flags |= FSCONTEXT_MNT;
  		}
++<<<<<<< HEAD
 +		if (opts->context) {
 +			rc = parse_sid(sb, opts->context, &context_sid);
 +			if (rc)
 +				goto out;
++=======
+ 		if (opts->context_sid) {
+ 			context_sid = opts->context_sid;
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  			if (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,
  					context_sid))
  				goto out_double_mount;
  			sbsec->flags |= CONTEXT_MNT;
  		}
++<<<<<<< HEAD
 +		if (opts->rootcontext) {
 +			rc = parse_sid(sb, opts->rootcontext, &rootcontext_sid);
 +			if (rc)
 +				goto out;
++=======
+ 		if (opts->rootcontext_sid) {
+ 			rootcontext_sid = opts->rootcontext_sid;
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  			if (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,
  					rootcontext_sid))
  				goto out_double_mount;
  			sbsec->flags |= ROOTCONTEXT_MNT;
  		}
++<<<<<<< HEAD
 +		if (opts->defcontext) {
 +			rc = parse_sid(sb, opts->defcontext, &defcontext_sid);
 +			if (rc)
 +				goto out;
++=======
+ 		if (opts->defcontext_sid) {
+ 			defcontext_sid = opts->defcontext_sid;
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  			if (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid,
  					defcontext_sid))
  				goto out_double_mount;
@@@ -2784,9 -2678,7 +2782,13 @@@ static int selinux_sb_mnt_opts_compat(s
  static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)
  {
  	struct selinux_mnt_opts *opts = mnt_opts;
++<<<<<<< HEAD
 +	struct superblock_security_struct *sbsec = sb->s_security;
 +	u32 sid;
 +	int rc;
++=======
+ 	struct superblock_security_struct *sbsec = selinux_superblock(sb);
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  
  	if (!(sbsec->flags & SE_SBINITIALIZED))
  		return 0;
@@@ -2794,34 -2686,26 +2796,55 @@@
  	if (!opts)
  		return 0;
  
++<<<<<<< HEAD
 +	if (opts->fscontext) {
 +		rc = parse_sid(sb, opts->fscontext, &sid);
 +		if (rc)
 +			return rc;
 +		if (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))
 +			goto out_bad_option;
 +	}
 +	if (opts->context) {
 +		rc = parse_sid(sb, opts->context, &sid);
 +		if (rc)
 +			return rc;
 +		if (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))
++=======
+ 	if (opts->fscontext_sid) {
+ 		if (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,
+ 			       opts->fscontext_sid))
  			goto out_bad_option;
  	}
- 	if (opts->rootcontext) {
+ 	if (opts->context_sid) {
+ 		if (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,
+ 			       opts->context_sid))
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
+ 			goto out_bad_option;
+ 	}
+ 	if (opts->rootcontext_sid) {
  		struct inode_security_struct *root_isec;
  		root_isec = backing_inode_security(sb->s_root);
++<<<<<<< HEAD
 +		rc = parse_sid(sb, opts->rootcontext, &sid);
 +		if (rc)
 +			return rc;
 +		if (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))
 +			goto out_bad_option;
 +	}
 +	if (opts->defcontext) {
 +		rc = parse_sid(sb, opts->defcontext, &sid);
 +		if (rc)
 +			return rc;
 +		if (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))
++=======
+ 		if (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,
+ 			       opts->rootcontext_sid))
+ 			goto out_bad_option;
+ 	}
+ 	if (opts->defcontext_sid) {
+ 		if (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid,
+ 			       opts->defcontext_sid))
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  			goto out_bad_option;
  	}
  	return 0;
@@@ -2893,33 -2776,8 +2915,38 @@@ static int selinux_fs_context_dup(struc
  	if (!src)
  		return 0;
  
++<<<<<<< HEAD
 +	fc->security = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
 +	if (!fc->security)
 +		return -ENOMEM;
 +
 +	opts = fc->security;
 +
 +	if (src->fscontext) {
 +		opts->fscontext = kstrdup(src->fscontext, GFP_KERNEL);
 +		if (!opts->fscontext)
 +			return -ENOMEM;
 +	}
 +	if (src->context) {
 +		opts->context = kstrdup(src->context, GFP_KERNEL);
 +		if (!opts->context)
 +			return -ENOMEM;
 +	}
 +	if (src->rootcontext) {
 +		opts->rootcontext = kstrdup(src->rootcontext, GFP_KERNEL);
 +		if (!opts->rootcontext)
 +			return -ENOMEM;
 +	}
 +	if (src->defcontext) {
 +		opts->defcontext = kstrdup(src->defcontext, GFP_KERNEL);
 +		if (!opts->defcontext)
 +			return -ENOMEM;
 +	}
 +	return 0;
++=======
+ 	fc->security = kmemdup(src, sizeof(*src), GFP_KERNEL);
+ 	return fc->security ? 0 : -ENOMEM;
++>>>>>>> 70f4169ab421 (selinux: parse contexts for mount options early)
  }
  
  static const struct fs_parameter_spec selinux_fs_parameters[] = {
* Unmerged path security/selinux/hooks.c
