ext4: fix error code in ext4_commit_super

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Fengnan Chang <changfengnan@vivo.com>
commit f88f1466e2a2e5ca17dfada436d3efa1b03a3972
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/f88f1466.failed

We should set the error code when ext4_commit_super check argument failed.
Found in code review.
Fixes: c4be0c1dc4cdc ("filesystem freeze: add error handling of write_super_lockfs/unlockfs").

	Cc: stable@kernel.org
	Signed-off-by: Fengnan Chang <changfengnan@vivo.com>
	Reviewed-by: Andreas Dilger <adilger@dilger.ca>
Link: https://lore.kernel.org/r/20210402101631.561-1-changfengnan@vivo.com
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit f88f1466e2a2e5ca17dfada436d3efa1b03a3972)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index 92750402ffcb,1f5ef17f714a..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -5084,27 -5524,74 +5084,45 @@@ static int ext4_commit_super(struct sup
  	 */
  	if (!(sb->s_flags & SB_RDONLY))
  		ext4_update_tstamp(es, s_wtime);
 -	es->s_kbytes_written =
 -		cpu_to_le64(sbi->s_kbytes_written +
 -		    ((part_stat_read(sb->s_bdev, sectors[STAT_WRITE]) -
 -		      sbi->s_sectors_written_start) >> 1));
 -	if (percpu_counter_initialized(&sbi->s_freeclusters_counter))
 +	if (sb->s_bdev->bd_part)
 +		es->s_kbytes_written =
 +			cpu_to_le64(EXT4_SB(sb)->s_kbytes_written +
 +			    ((part_stat_read(sb->s_bdev->bd_part,
 +					     sectors[STAT_WRITE]) -
 +			      EXT4_SB(sb)->s_sectors_written_start) >> 1));
 +	else
 +		es->s_kbytes_written =
 +			cpu_to_le64(EXT4_SB(sb)->s_kbytes_written);
 +	if (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))
  		ext4_free_blocks_count_set(es,
 -			EXT4_C2B(sbi, percpu_counter_sum_positive(
 -				&sbi->s_freeclusters_counter)));
 -	if (percpu_counter_initialized(&sbi->s_freeinodes_counter))
 +			EXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(
 +				&EXT4_SB(sb)->s_freeclusters_counter)));
 +	if (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))
  		es->s_free_inodes_count =
  			cpu_to_le32(percpu_counter_sum_positive(
 -				&sbi->s_freeinodes_counter));
 -	/* Copy error information to the on-disk superblock */
 -	spin_lock(&sbi->s_error_lock);
 -	if (sbi->s_add_error_count > 0) {
 -		es->s_state |= cpu_to_le16(EXT4_ERROR_FS);
 -		if (!es->s_first_error_time && !es->s_first_error_time_hi) {
 -			__ext4_update_tstamp(&es->s_first_error_time,
 -					     &es->s_first_error_time_hi,
 -					     sbi->s_first_error_time);
 -			strncpy(es->s_first_error_func, sbi->s_first_error_func,
 -				sizeof(es->s_first_error_func));
 -			es->s_first_error_line =
 -				cpu_to_le32(sbi->s_first_error_line);
 -			es->s_first_error_ino =
 -				cpu_to_le32(sbi->s_first_error_ino);
 -			es->s_first_error_block =
 -				cpu_to_le64(sbi->s_first_error_block);
 -			es->s_first_error_errcode =
 -				ext4_errno_to_code(sbi->s_first_error_code);
 -		}
 -		__ext4_update_tstamp(&es->s_last_error_time,
 -				     &es->s_last_error_time_hi,
 -				     sbi->s_last_error_time);
 -		strncpy(es->s_last_error_func, sbi->s_last_error_func,
 -			sizeof(es->s_last_error_func));
 -		es->s_last_error_line = cpu_to_le32(sbi->s_last_error_line);
 -		es->s_last_error_ino = cpu_to_le32(sbi->s_last_error_ino);
 -		es->s_last_error_block = cpu_to_le64(sbi->s_last_error_block);
 -		es->s_last_error_errcode =
 -				ext4_errno_to_code(sbi->s_last_error_code);
 -		/*
 -		 * Start the daily error reporting function if it hasn't been
 -		 * started already
 -		 */
 -		if (!es->s_error_count)
 -			mod_timer(&sbi->s_err_report, jiffies + 24*60*60*HZ);
 -		le32_add_cpu(&es->s_error_count, sbi->s_add_error_count);
 -		sbi->s_add_error_count = 0;
 -	}
 -	spin_unlock(&sbi->s_error_lock);
 -
 +				&EXT4_SB(sb)->s_freeinodes_counter));
 +	BUFFER_TRACE(sbh, "marking dirty");
  	ext4_superblock_csum_set(sb);
++<<<<<<< HEAD
 +	if (sync)
 +		lock_buffer(sbh);
++=======
+ 	unlock_buffer(sbh);
+ }
+ 
+ static int ext4_commit_super(struct super_block *sb)
+ {
+ 	struct buffer_head *sbh = EXT4_SB(sb)->s_sbh;
+ 	int error = 0;
+ 
+ 	if (!sbh)
+ 		return -EINVAL;
+ 	if (block_device_ejected(sb))
+ 		return -ENODEV;
+ 
+ 	ext4_update_super(sb);
+ 
++>>>>>>> f88f1466e2a2 (ext4: fix error code in ext4_commit_super)
  	if (buffer_write_io_error(sbh) || !buffer_uptodate(sbh)) {
  		/*
  		 * Oh, dear.  A previous attempt to write the
* Unmerged path fs/ext4/super.c
