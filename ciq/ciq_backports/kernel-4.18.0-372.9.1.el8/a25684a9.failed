ALSA: memalloc: Support for non-contiguous page allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit a25684a956468ee8bbbee44649e41e5d447e5adc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/a25684a9.failed

This patch adds the support for allocation of non-contiguous DMA pages
in the common memalloc helper.  It's another SG-buffer type, but
unlike the existing one, this is directional and requires the explicit
sync / invalidation of dirty pages on non-coherent architectures.

For this enhancement, the following points are changed:
- snd_dma_device stores the DMA direction.
- snd_dma_device stores need_sync flag indicating whether the explicit
  sync is required or not.
- A new variant of helper functions, snd_dma_alloc_dir_pages() and
  *_all() are introduced; the old snd_dma_alloc_pages() and *_all()
  kept as just wrappers with DMA_BIDIRECTIONAL.
- A new helper snd_dma_buffer_sync() is introduced; this gets called
  in the appropriate places.
- A new allocation type, SNDRV_DMA_TYPE_NONCONTIG, is introduced.

When the driver allocates pages with this new type, and it may require
the SNDRV_PCM_INFO_EXPLICIT_SYNC flag set to the PCM hardware.info for
taking the full control of PCM applptr and hwptr changes (that implies
disabling the mmap of control/status data).  When the buffer
allocation is managed by snd_pcm_set_managed_buffer(), this flag is
automatically set depending on the result of dma_need_sync()
internally.  Otherwise, if the buffer is managed manually, the driver
has to set the flag explicitly, too.

The explicit sync between CPU and device for non-coherent memory is
performed at the points before and after read/write transfer as well
as the applptr/hwptr syncptr ioctl.  In the case of mmap mode,
user-space is supposed to call the syncptr ioctl with the hwptr flag
to update and fetch the status at first; this corresponds to CPU-sync.
Then user-space advances the applptr via syncptr ioctl again with
applptr flag, and this corresponds to the device sync with flushing.

Other than the DMA direction and the explicit sync, the usage of this
new buffer type is almost equivalent with the existing
SNDRV_DMA_TYPE_DEV_SG; you can get the page and the address via
snd_sgbuf_get_page() and snd_sgbuf_get_addr(), also calculate the
continuous pages via snd_sgbuf_get_chunk_size().

For those SG-page handling, the non-contig type shares the same ops
with the vmalloc handler.  As we do always vmap the SG pages at first,
the actual address can be deduced from the vmapped address easily
without iterating the SG-list.

Link: https://lore.kernel.org/r/20211017074859.24112-2-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a25684a956468ee8bbbee44649e41e5d447e5adc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/memalloc.h
#	sound/core/memalloc.c
#	sound/core/memalloc_local.h
diff --cc include/sound/memalloc.h
index 3ab084438fdc,1457eba1ac53..000000000000
--- a/include/sound/memalloc.h
+++ b/include/sound/memalloc.h
@@@ -12,6 -13,8 +13,11 @@@
  #include <asm/page.h>
  
  struct device;
++<<<<<<< HEAD
++=======
+ struct vm_area_struct;
+ struct sg_table;
++>>>>>>> a25684a95646 (ALSA: memalloc: Support for non-contiguous page allocation)
  
  /*
   * buffer device info
@@@ -64,65 -70,56 +73,112 @@@ static inline unsigned int snd_sgbuf_al
  	return (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
  }
  
 +#ifdef CONFIG_SND_DMA_SGBUF
 +/*
 + * Scatter-Gather generic device pages
 + */
 +void *snd_malloc_sgbuf_pages(struct device *device,
 +			     size_t size, struct snd_dma_buffer *dmab,
 +			     size_t *res_size);
 +int snd_free_sgbuf_pages(struct snd_dma_buffer *dmab);
 +
 +struct snd_sg_page {
 +	void *buf;
 +	dma_addr_t addr;
 +};
 +
 +struct snd_sg_buf {
 +	int size;	/* allocated byte size */
 +	int pages;	/* allocated pages */
 +	int tblsize;	/* allocated table size */
 +	struct snd_sg_page *table;	/* address table */
 +	struct page **page_table;	/* page table (for vmap/vunmap) */
 +	struct device *dev;
 +};
 +
 +/*
 + * return the physical address at the corresponding offset
 + */
 +static inline dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab,
 +					   size_t offset)
 +{
 +	struct snd_sg_buf *sgbuf = dmab->private_data;
 +	dma_addr_t addr;
 +
 +	if (!sgbuf)
 +		return dmab->addr + offset;
 +	addr = sgbuf->table[offset >> PAGE_SHIFT].addr;
 +	addr &= ~((dma_addr_t)PAGE_SIZE - 1);
 +	return addr + offset % PAGE_SIZE;
 +}
 +
 +unsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,
 +				      unsigned int ofs, unsigned int size);
 +#else
 +/* non-SG versions */
 +static inline dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab,
 +					    size_t offset)
 +{
 +	return dmab->addr + offset;
 +}
 +
 +#define snd_sgbuf_get_chunk_size(dmab, ofs, size)	(size)
 +
 +#endif /* CONFIG_SND_DMA_SGBUF */
 +
  /* allocate/release a buffer */
- int snd_dma_alloc_pages(int type, struct device *dev, size_t size,
- 			struct snd_dma_buffer *dmab);
+ int snd_dma_alloc_dir_pages(int type, struct device *dev,
+ 			    enum dma_data_direction dir, size_t size,
+ 			    struct snd_dma_buffer *dmab);
+ 
+ static inline int snd_dma_alloc_pages(int type, struct device *dev,
+ 				      size_t size, struct snd_dma_buffer *dmab)
+ {
+ 	return snd_dma_alloc_dir_pages(type, dev, DMA_BIDIRECTIONAL, size, dmab);
+ }
+ 
  int snd_dma_alloc_pages_fallback(int type, struct device *dev, size_t size,
                                   struct snd_dma_buffer *dmab);
  void snd_dma_free_pages(struct snd_dma_buffer *dmab);
++<<<<<<< HEAD
++=======
+ int snd_dma_buffer_mmap(struct snd_dma_buffer *dmab,
+ 			struct vm_area_struct *area);
+ 
+ enum snd_dma_sync_mode { SNDRV_DMA_SYNC_CPU, SNDRV_DMA_SYNC_DEVICE };
+ #ifdef CONFIG_HAS_DMA
+ void snd_dma_buffer_sync(struct snd_dma_buffer *dmab,
+ 			 enum snd_dma_sync_mode mode);
+ #else
+ static inline void snd_dma_buffer_sync(struct snd_dma_buffer *dmab,
+ 				       enum snd_dma_sync_mode mode) {}
+ #endif
+ 
+ void snd_dma_buffer_sync(struct snd_dma_buffer *dmab,
+ 			 enum snd_dma_sync_mode mode);
+ 
+ dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab, size_t offset);
+ struct page *snd_sgbuf_get_page(struct snd_dma_buffer *dmab, size_t offset);
+ unsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,
+ 				      unsigned int ofs, unsigned int size);
+ 
+ /* device-managed memory allocator */
+ struct snd_dma_buffer *snd_devm_alloc_dir_pages(struct device *dev, int type,
+ 						enum dma_data_direction dir,
+ 						size_t size);
+ 
+ static inline struct snd_dma_buffer *
+ snd_devm_alloc_pages(struct device *dev, int type, size_t size)
+ {
+ 	return snd_devm_alloc_dir_pages(dev, type, DMA_BIDIRECTIONAL, size);
+ }
+ 
+ static inline struct sg_table *
+ snd_dma_noncontig_sg_table(struct snd_dma_buffer *dmab)
+ {
+ 	return dmab->private_data;
+ }
++>>>>>>> a25684a95646 (ALSA: memalloc: Support for non-contiguous page allocation)
  
  #endif /* __SOUND_MEMALLOC_H */
  
diff --cc sound/core/memalloc.c
index fb571e6ead5e,11f9a68bf94c..000000000000
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@@ -123,11 -54,10 +126,12 @@@ static inline gfp_t snd_mem_get_gfp_fla
   * Return: Zero if the buffer with the given size is allocated successfully,
   * otherwise a negative value on error.
   */
- int snd_dma_alloc_pages(int type, struct device *device, size_t size,
- 			struct snd_dma_buffer *dmab)
+ int snd_dma_alloc_dir_pages(int type, struct device *device,
+ 			    enum dma_data_direction dir, size_t size,
+ 			    struct snd_dma_buffer *dmab)
  {
 +	gfp_t gfp;
 +
  	if (WARN_ON(!size))
  		return -ENXIO;
  	if (WARN_ON(!dmab))
@@@ -136,47 -66,12 +140,48 @@@
  	size = PAGE_ALIGN(size);
  	dmab->dev.type = type;
  	dmab->dev.dev = device;
+ 	dmab->dev.dir = dir;
  	dmab->bytes = 0;
 +	dmab->area = NULL;
  	dmab->addr = 0;
  	dmab->private_data = NULL;
 -	dmab->area = __snd_dma_alloc_pages(dmab, size);
 -	if (!dmab->area)
 +	switch (type) {
 +	case SNDRV_DMA_TYPE_CONTINUOUS:
 +		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL);
 +		dmab->area = alloc_pages_exact(size, gfp);
 +		break;
 +	case SNDRV_DMA_TYPE_VMALLOC:
 +		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL | __GFP_HIGHMEM);
 +		dmab->area = __vmalloc(size, gfp, PAGE_KERNEL);
 +		break;
 +#ifdef CONFIG_HAS_DMA
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +	case SNDRV_DMA_TYPE_DEV_IRAM:
 +		snd_malloc_dev_iram(dmab, size);
 +		if (dmab->area)
 +			break;
 +		/* Internal memory might have limited size and no enough space,
 +		 * so if we fail to malloc, try to fetch memory traditionally.
 +		 */
 +		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +		/* fall through */
 +	case SNDRV_DMA_TYPE_DEV:
 +	case SNDRV_DMA_TYPE_DEV_UC:
 +		snd_malloc_dev_pages(dmab, size);
 +		break;
 +#endif
 +#ifdef CONFIG_SND_DMA_SGBUF
 +	case SNDRV_DMA_TYPE_DEV_SG:
 +	case SNDRV_DMA_TYPE_DEV_UC_SG:
 +		snd_malloc_sgbuf_pages(device, size, dmab, NULL);
 +		break;
 +#endif
 +	default:
 +		pr_err("snd-malloc: invalid device type %d\n", type);
 +		return -ENXIO;
 +	}
 +	if (! dmab->area)
  		return -ENOMEM;
  	dmab->bytes = size;
  	return 0;
@@@ -226,32 -120,472 +231,498 @@@ EXPORT_SYMBOL(snd_dma_alloc_pages_fallb
   */
  void snd_dma_free_pages(struct snd_dma_buffer *dmab)
  {
 -	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
 -
 -	if (ops && ops->free)
 -		ops->free(dmab);
 +	switch (dmab->dev.type) {
 +	case SNDRV_DMA_TYPE_CONTINUOUS:
 +		free_pages_exact(dmab->area, dmab->bytes);
 +		break;
 +	case SNDRV_DMA_TYPE_VMALLOC:
 +		vfree(dmab->area);
 +		break;
 +#ifdef CONFIG_HAS_DMA
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +	case SNDRV_DMA_TYPE_DEV_IRAM:
 +		snd_free_dev_iram(dmab);
 +		break;
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +	case SNDRV_DMA_TYPE_DEV:
 +	case SNDRV_DMA_TYPE_DEV_UC:
 +		snd_free_dev_pages(dmab);
 +		break;
 +#endif
 +#ifdef CONFIG_SND_DMA_SGBUF
 +	case SNDRV_DMA_TYPE_DEV_SG:
 +	case SNDRV_DMA_TYPE_DEV_UC_SG:
 +		snd_free_sgbuf_pages(dmab);
 +		break;
 +#endif
 +	default:
 +		pr_err("snd-malloc: invalid device type %d\n", dmab->dev.type);
 +	}
  }
  EXPORT_SYMBOL(snd_dma_free_pages);
++<<<<<<< HEAD
++=======
+ 
+ /* called by devres */
+ static void __snd_release_pages(struct device *dev, void *res)
+ {
+ 	snd_dma_free_pages(res);
+ }
+ 
+ /**
+  * snd_devm_alloc_dir_pages - allocate the buffer and manage with devres
+  * @dev: the device pointer
+  * @type: the DMA buffer type
+  * @dir: DMA direction
+  * @size: the buffer size to allocate
+  *
+  * Allocate buffer pages depending on the given type and manage using devres.
+  * The pages will be released automatically at the device removal.
+  *
+  * Unlike snd_dma_alloc_pages(), this function requires the real device pointer,
+  * hence it can't work with SNDRV_DMA_TYPE_CONTINUOUS or
+  * SNDRV_DMA_TYPE_VMALLOC type.
+  *
+  * The function returns the snd_dma_buffer object at success, or NULL if failed.
+  */
+ struct snd_dma_buffer *
+ snd_devm_alloc_dir_pages(struct device *dev, int type,
+ 			 enum dma_data_direction dir, size_t size)
+ {
+ 	struct snd_dma_buffer *dmab;
+ 	int err;
+ 
+ 	if (WARN_ON(type == SNDRV_DMA_TYPE_CONTINUOUS ||
+ 		    type == SNDRV_DMA_TYPE_VMALLOC))
+ 		return NULL;
+ 
+ 	dmab = devres_alloc(__snd_release_pages, sizeof(*dmab), GFP_KERNEL);
+ 	if (!dmab)
+ 		return NULL;
+ 
+ 	err = snd_dma_alloc_dir_pages(type, dev, dir, size, dmab);
+ 	if (err < 0) {
+ 		devres_free(dmab);
+ 		return NULL;
+ 	}
+ 
+ 	devres_add(dev, dmab);
+ 	return dmab;
+ }
+ EXPORT_SYMBOL_GPL(snd_devm_alloc_dir_pages);
+ 
+ /**
+  * snd_dma_buffer_mmap - perform mmap of the given DMA buffer
+  * @dmab: buffer allocation information
+  * @area: VM area information
+  */
+ int snd_dma_buffer_mmap(struct snd_dma_buffer *dmab,
+ 			struct vm_area_struct *area)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->mmap)
+ 		return ops->mmap(dmab, area);
+ 	else
+ 		return -ENOENT;
+ }
+ EXPORT_SYMBOL(snd_dma_buffer_mmap);
+ 
+ #ifdef CONFIG_HAS_DMA
+ /**
+  * snd_dma_buffer_sync - sync DMA buffer between CPU and device
+  * @dmab: buffer allocation information
+  * @mod: sync mode
+  */
+ void snd_dma_buffer_sync(struct snd_dma_buffer *dmab,
+ 			 enum snd_dma_sync_mode mode)
+ {
+ 	const struct snd_malloc_ops *ops;
+ 
+ 	if (!dmab || !dmab->dev.need_sync)
+ 		return;
+ 	ops = snd_dma_get_ops(dmab);
+ 	if (ops && ops->sync)
+ 		ops->sync(dmab, mode);
+ }
+ EXPORT_SYMBOL_GPL(snd_dma_buffer_sync);
+ #endif /* CONFIG_HAS_DMA */
+ 
+ /**
+  * snd_sgbuf_get_addr - return the physical address at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_addr)
+ 		return ops->get_addr(dmab, offset);
+ 	else
+ 		return dmab->addr + offset;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_addr);
+ 
+ /**
+  * snd_sgbuf_get_page - return the physical page at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ struct page *snd_sgbuf_get_page(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_page)
+ 		return ops->get_page(dmab, offset);
+ 	else
+ 		return virt_to_page(dmab->area + offset);
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_page);
+ 
+ /**
+  * snd_sgbuf_get_chunk_size - compute the max chunk size with continuous pages
+  *	on sg-buffer
+  * @dmab: buffer allocation information
+  * @ofs: offset in the ring buffer
+  * @size: the requested size
+  */
+ unsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,
+ 				      unsigned int ofs, unsigned int size)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_chunk_size)
+ 		return ops->get_chunk_size(dmab, ofs, size);
+ 	else
+ 		return size;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_chunk_size);
+ 
+ /*
+  * Continuous pages allocator
+  */
+ static void *snd_dma_continuous_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL);
+ 	void *p = alloc_pages_exact(size, gfp);
+ 
+ 	if (p)
+ 		dmab->addr = page_to_phys(virt_to_page(p));
+ 	return p;
+ }
+ 
+ static void snd_dma_continuous_free(struct snd_dma_buffer *dmab)
+ {
+ 	free_pages_exact(dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_continuous_mmap(struct snd_dma_buffer *dmab,
+ 				   struct vm_area_struct *area)
+ {
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       dmab->addr >> PAGE_SHIFT,
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_continuous_ops = {
+ 	.alloc = snd_dma_continuous_alloc,
+ 	.free = snd_dma_continuous_free,
+ 	.mmap = snd_dma_continuous_mmap,
+ };
+ 
+ /*
+  * VMALLOC allocator
+  */
+ static void *snd_dma_vmalloc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL | __GFP_HIGHMEM);
+ 
+ 	return __vmalloc(size, gfp);
+ }
+ 
+ static void snd_dma_vmalloc_free(struct snd_dma_buffer *dmab)
+ {
+ 	vfree(dmab->area);
+ }
+ 
+ static int snd_dma_vmalloc_mmap(struct snd_dma_buffer *dmab,
+ 				struct vm_area_struct *area)
+ {
+ 	return remap_vmalloc_range(area, dmab->area, 0);
+ }
+ 
+ #define get_vmalloc_page_addr(dmab, offset) \
+ 	page_to_phys(vmalloc_to_page((dmab)->area + (offset)))
+ 
+ static dma_addr_t snd_dma_vmalloc_get_addr(struct snd_dma_buffer *dmab,
+ 					   size_t offset)
+ {
+ 	return get_vmalloc_page_addr(dmab, offset) + offset % PAGE_SIZE;
+ }
+ 
+ static struct page *snd_dma_vmalloc_get_page(struct snd_dma_buffer *dmab,
+ 					     size_t offset)
+ {
+ 	return vmalloc_to_page(dmab->area + offset);
+ }
+ 
+ static unsigned int
+ snd_dma_vmalloc_get_chunk_size(struct snd_dma_buffer *dmab,
+ 			       unsigned int ofs, unsigned int size)
+ {
+ 	unsigned int start, end;
+ 	unsigned long addr;
+ 
+ 	start = ALIGN_DOWN(ofs, PAGE_SIZE);
+ 	end = ofs + size - 1; /* the last byte address */
+ 	/* check page continuity */
+ 	addr = get_vmalloc_page_addr(dmab, start);
+ 	for (;;) {
+ 		start += PAGE_SIZE;
+ 		if (start > end)
+ 			break;
+ 		addr += PAGE_SIZE;
+ 		if (get_vmalloc_page_addr(dmab, start) != addr)
+ 			return start - ofs;
+ 	}
+ 	/* ok, all on continuous pages */
+ 	return size;
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_vmalloc_ops = {
+ 	.alloc = snd_dma_vmalloc_alloc,
+ 	.free = snd_dma_vmalloc_free,
+ 	.mmap = snd_dma_vmalloc_mmap,
+ 	.get_addr = snd_dma_vmalloc_get_addr,
+ 	.get_page = snd_dma_vmalloc_get_page,
+ 	.get_chunk_size = snd_dma_vmalloc_get_chunk_size,
+ };
+ 
+ #ifdef CONFIG_HAS_DMA
+ /*
+  * IRAM allocator
+  */
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ static void *snd_dma_iram_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	struct device *dev = dmab->dev.dev;
+ 	struct gen_pool *pool;
+ 	void *p;
+ 
+ 	if (dev->of_node) {
+ 		pool = of_gen_pool_get(dev->of_node, "iram", 0);
+ 		/* Assign the pool into private_data field */
+ 		dmab->private_data = pool;
+ 
+ 		p = gen_pool_dma_alloc_align(pool, size, &dmab->addr, PAGE_SIZE);
+ 		if (p)
+ 			return p;
+ 	}
+ 
+ 	/* Internal memory might have limited size and no enough space,
+ 	 * so if we fail to malloc, try to fetch memory traditionally.
+ 	 */
+ 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+ 	return __snd_dma_alloc_pages(dmab, size);
+ }
+ 
+ static void snd_dma_iram_free(struct snd_dma_buffer *dmab)
+ {
+ 	struct gen_pool *pool = dmab->private_data;
+ 
+ 	if (pool && dmab->area)
+ 		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_iram_mmap(struct snd_dma_buffer *dmab,
+ 			     struct vm_area_struct *area)
+ {
+ 	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       dmab->addr >> PAGE_SHIFT,
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_iram_ops = {
+ 	.alloc = snd_dma_iram_alloc,
+ 	.free = snd_dma_iram_free,
+ 	.mmap = snd_dma_iram_mmap,
+ };
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ 
+ #define DEFAULT_GFP \
+ 	(GFP_KERNEL | \
+ 	 __GFP_COMP |    /* compound page lets parts be mapped */ \
+ 	 __GFP_NORETRY | /* don't trigger OOM-killer */ \
+ 	 __GFP_NOWARN)   /* no stack trace print - this call is non-critical */
+ 
+ /*
+  * Coherent device pages allocator
+  */
+ static void *snd_dma_dev_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	void *p;
+ 
+ 	p = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr, DEFAULT_GFP);
+ #ifdef CONFIG_X86
+ 	if (p && dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC)
+ 		set_memory_wc((unsigned long)p, PAGE_ALIGN(size) >> PAGE_SHIFT);
+ #endif
+ 	return p;
+ }
+ 
+ static void snd_dma_dev_free(struct snd_dma_buffer *dmab)
+ {
+ #ifdef CONFIG_X86
+ 	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC)
+ 		set_memory_wb((unsigned long)dmab->area,
+ 			      PAGE_ALIGN(dmab->bytes) >> PAGE_SHIFT);
+ #endif
+ 	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+ }
+ 
+ static int snd_dma_dev_mmap(struct snd_dma_buffer *dmab,
+ 			    struct vm_area_struct *area)
+ {
+ #ifdef CONFIG_X86
+ 	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC)
+ 		area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ #endif
+ 	return dma_mmap_coherent(dmab->dev.dev, area,
+ 				 dmab->area, dmab->addr, dmab->bytes);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_dev_ops = {
+ 	.alloc = snd_dma_dev_alloc,
+ 	.free = snd_dma_dev_free,
+ 	.mmap = snd_dma_dev_mmap,
+ };
+ 
+ /*
+  * Write-combined pages
+  */
+ #ifdef CONFIG_X86
+ /* On x86, share the same ops as the standard dev ops */
+ #define snd_dma_wc_ops	snd_dma_dev_ops
+ #else /* CONFIG_X86 */
+ static void *snd_dma_wc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	return dma_alloc_wc(dmab->dev.dev, size, &dmab->addr, DEFAULT_GFP);
+ }
+ 
+ static void snd_dma_wc_free(struct snd_dma_buffer *dmab)
+ {
+ 	dma_free_wc(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+ }
+ 
+ static int snd_dma_wc_mmap(struct snd_dma_buffer *dmab,
+ 			   struct vm_area_struct *area)
+ {
+ 	return dma_mmap_wc(dmab->dev.dev, area,
+ 			   dmab->area, dmab->addr, dmab->bytes);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_wc_ops = {
+ 	.alloc = snd_dma_wc_alloc,
+ 	.free = snd_dma_wc_free,
+ 	.mmap = snd_dma_wc_mmap,
+ };
+ #endif /* CONFIG_X86 */
+ 
+ /*
+  * Non-contiguous pages allocator
+  */
+ static void *snd_dma_noncontig_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	struct sg_table *sgt;
+ 	void *p;
+ 
+ 	sgt = dma_alloc_noncontiguous(dmab->dev.dev, size, dmab->dev.dir,
+ 				      DEFAULT_GFP, 0);
+ 	if (!sgt)
+ 		return NULL;
+ 	dmab->dev.need_sync = dma_need_sync(dmab->dev.dev, dmab->dev.dir);
+ 	p = dma_vmap_noncontiguous(dmab->dev.dev, size, sgt);
+ 	if (p)
+ 		dmab->private_data = sgt;
+ 	else
+ 		dma_free_noncontiguous(dmab->dev.dev, size, sgt, dmab->dev.dir);
+ 	return p;
+ }
+ 
+ static void snd_dma_noncontig_free(struct snd_dma_buffer *dmab)
+ {
+ 	dma_vunmap_noncontiguous(dmab->dev.dev, dmab->area);
+ 	dma_free_noncontiguous(dmab->dev.dev, dmab->bytes, dmab->private_data,
+ 			       dmab->dev.dir);
+ }
+ 
+ static int snd_dma_noncontig_mmap(struct snd_dma_buffer *dmab,
+ 				  struct vm_area_struct *area)
+ {
+ 	return dma_mmap_noncontiguous(dmab->dev.dev, area,
+ 				      dmab->bytes, dmab->private_data);
+ }
+ 
+ static void snd_dma_noncontig_sync(struct snd_dma_buffer *dmab,
+ 				   enum snd_dma_sync_mode mode)
+ {
+ 	if (mode == SNDRV_DMA_SYNC_CPU) {
+ 		if (dmab->dev.dir == DMA_TO_DEVICE)
+ 			return;
+ 		dma_sync_sgtable_for_cpu(dmab->dev.dev, dmab->private_data,
+ 					 dmab->dev.dir);
+ 		invalidate_kernel_vmap_range(dmab->area, dmab->bytes);
+ 	} else {
+ 		if (dmab->dev.dir == DMA_FROM_DEVICE)
+ 			return;
+ 		flush_kernel_vmap_range(dmab->area, dmab->bytes);
+ 		dma_sync_sgtable_for_device(dmab->dev.dev, dmab->private_data,
+ 					    dmab->dev.dir);
+ 	}
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_noncontig_ops = {
+ 	.alloc = snd_dma_noncontig_alloc,
+ 	.free = snd_dma_noncontig_free,
+ 	.mmap = snd_dma_noncontig_mmap,
+ 	.sync = snd_dma_noncontig_sync,
+ 	/* re-use vmalloc helpers for get_* ops */
+ 	.get_addr = snd_dma_vmalloc_get_addr,
+ 	.get_page = snd_dma_vmalloc_get_page,
+ 	.get_chunk_size = snd_dma_vmalloc_get_chunk_size,
+ };
+ 
+ #endif /* CONFIG_HAS_DMA */
+ 
+ /*
+  * Entry points
+  */
+ static const struct snd_malloc_ops *dma_ops[] = {
+ 	[SNDRV_DMA_TYPE_CONTINUOUS] = &snd_dma_continuous_ops,
+ 	[SNDRV_DMA_TYPE_VMALLOC] = &snd_dma_vmalloc_ops,
+ #ifdef CONFIG_HAS_DMA
+ 	[SNDRV_DMA_TYPE_DEV] = &snd_dma_dev_ops,
+ 	[SNDRV_DMA_TYPE_DEV_WC] = &snd_dma_wc_ops,
+ 	[SNDRV_DMA_TYPE_NONCONTIG] = &snd_dma_noncontig_ops,
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ 	[SNDRV_DMA_TYPE_DEV_IRAM] = &snd_dma_iram_ops,
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ #endif /* CONFIG_HAS_DMA */
+ #ifdef CONFIG_SND_DMA_SGBUF
+ 	[SNDRV_DMA_TYPE_DEV_SG] = &snd_dma_sg_ops,
+ 	[SNDRV_DMA_TYPE_DEV_WC_SG] = &snd_dma_sg_ops,
+ #endif
+ };
+ 
+ static const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab)
+ {
+ 	if (WARN_ON_ONCE(dmab->dev.type <= SNDRV_DMA_TYPE_UNKNOWN ||
+ 			 dmab->dev.type >= ARRAY_SIZE(dma_ops)))
+ 		return NULL;
+ 	return dma_ops[dmab->dev.type];
+ }
++>>>>>>> a25684a95646 (ALSA: memalloc: Support for non-contiguous page allocation)
* Unmerged path sound/core/memalloc_local.h
* Unmerged path include/sound/memalloc.h
* Unmerged path sound/core/memalloc.c
* Unmerged path sound/core/memalloc_local.h
diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c
index dfe5a64e19d2..e4e176854ce7 100644
--- a/sound/core/pcm_compat.c
+++ b/sound/core/pcm_compat.c
@@ -453,6 +453,8 @@ static int snd_pcm_ioctl_sync_ptr_x32(struct snd_pcm_substream *substream,
 	sstatus.suspended_state = status->suspended_state;
 	sstatus.audio_tstamp = status->audio_tstamp;
 	snd_pcm_stream_unlock_irq(substream);
+	if (!(sflags & SNDRV_PCM_SYNC_PTR_APPL))
+		snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 	if (put_user(sstatus.state, &src->s.status.state) ||
 	    put_user(sstatus.hw_ptr, &src->s.status.hw_ptr) ||
 	    put_user(sstatus.tstamp.tv_sec, &src->s.status.tstamp_sec) ||
@@ -533,6 +535,8 @@ static int snd_pcm_ioctl_sync_ptr_buggy(struct snd_pcm_substream *substream,
 	sync_ptr.s.status.suspended_state = status->suspended_state;
 	sync_ptr.s.status.audio_tstamp = status->audio_tstamp;
 	snd_pcm_stream_unlock_irq(substream);
+	if (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL))
+		snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 	if (copy_to_user(_sync_ptr, &sync_ptr, sizeof(sync_ptr)))
 		return -EFAULT;
 	return 0;
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ca35239c304e..1b019e9c061c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -106,6 +106,7 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 		frames -= transfer;
 		ofs = 0;
 	}
+	snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 }
 
 #ifdef CONFIG_SND_DEBUG
@@ -2256,8 +2257,12 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 			goto _end_unlock;
 		}
 		snd_pcm_stream_unlock_irq(substream);
+		if (!is_playback)
+			snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_CPU);
 		err = writer(substream, appl_ofs, data, offset, frames,
 			     transfer);
+		if (is_playback)
+			snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 		snd_pcm_stream_lock_irq(substream);
 		if (err < 0)
 			goto _end_unlock;
diff --git a/sound/core/pcm_local.h b/sound/core/pcm_local.h
index e3b3558aeab6..c05af3ccab2e 100644
--- a/sound/core/pcm_local.h
+++ b/sound/core/pcm_local.h
@@ -78,4 +78,11 @@ struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
 		for ((subs) = (pcm)->streams[str].substream; (subs); \
 		     (subs) = (subs)->next)
 
+static inline void snd_pcm_dma_buffer_sync(struct snd_pcm_substream *substream,
+					   enum snd_dma_sync_mode mode)
+{
+	if (substream->runtime->info & SNDRV_PCM_INFO_EXPLICIT_SYNC)
+		snd_dma_buffer_sync(snd_pcm_get_dma_buf(substream), mode);
+}
+
 #endif	/* __SOUND_CORE_PCM_LOCAL_H */
diff --git a/sound/core/pcm_memory.c b/sound/core/pcm_memory.c
index a9d04d31c1ed..a8c179d2d0a2 100644
--- a/sound/core/pcm_memory.c
+++ b/sound/core/pcm_memory.c
@@ -32,15 +32,20 @@ module_param(max_alloc_per_card, ulong, 0644);
 MODULE_PARM_DESC(max_alloc_per_card, "Max total allocation bytes per card.");
 
 static int do_alloc_pages(struct snd_card *card, int type, struct device *dev,
-			  size_t size, struct snd_dma_buffer *dmab)
+			  int str, size_t size, struct snd_dma_buffer *dmab)
 {
+	enum dma_data_direction dir;
 	int err;
 
 	if (max_alloc_per_card &&
 	    card->total_pcm_alloc_bytes + size > max_alloc_per_card)
 		return -ENOMEM;
 
-	err = snd_dma_alloc_pages(type, dev, size, dmab);
+	if (str == SNDRV_PCM_STREAM_PLAYBACK)
+		dir = DMA_TO_DEVICE;
+	else
+		dir = DMA_FROM_DEVICE;
+	err = snd_dma_alloc_dir_pages(type, dev, dir, size, dmab);
 	if (!err) {
 		mutex_lock(&card->memory_mutex);
 		card->total_pcm_alloc_bytes += dmab->bytes;
@@ -76,7 +81,7 @@ static int preallocate_pcm_pages(struct snd_pcm_substream *substream, size_t siz
 
 	do {
 		err = do_alloc_pages(card, dmab->dev.type, dmab->dev.dev,
-				     size, dmab);
+				     substream->stream, size, dmab);
 		if (err != -ENOMEM)
 			return err;
 		size >>= 1;
@@ -174,6 +179,7 @@ static void snd_pcm_lib_preallocate_proc_write(struct snd_info_entry *entry,
 			if (do_alloc_pages(card,
 					   substream->dma_buffer.dev.type,
 					   substream->dma_buffer.dev.dev,
+					   substream->stream,
 					   size, &new_dmab) < 0) {
 				buffer->error = -ENOMEM;
 				pr_debug("ALSA pcmC%dD%d%c,%d:%s: cannot preallocate for size %zu\n",
@@ -404,6 +410,7 @@ int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size)
 		if (do_alloc_pages(card,
 				   substream->dma_buffer.dev.type,
 				   substream->dma_buffer.dev.dev,
+				   substream->stream,
 				   size, dmab) < 0) {
 			kfree(dmab);
 			pr_debug("ALSA pcmC%dD%d%c,%d:%s: cannot preallocate for size %zu\n",
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 4cfa2e3398f4..5eb0bf20360b 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -2671,6 +2671,13 @@ int snd_pcm_open_substream(struct snd_pcm *pcm, int stream,
 		goto error;
 	}
 
+	/* automatically set EXPLICIT_SYNC flag in the managed mode whenever
+	 * the DMA buffer requires it
+	 */
+	if (substream->managed_buffer_alloc &&
+	    substream->dma_buffer.dev.need_sync)
+		substream->runtime->hw.info |= SNDRV_PCM_INFO_EXPLICIT_SYNC;
+
 	*rsubstream = substream;
 	return 0;
 
@@ -2898,6 +2905,8 @@ static snd_pcm_sframes_t snd_pcm_rewind(struct snd_pcm_substream *substream,
 		ret = rewind_appl_ptr(substream, frames,
 				      snd_pcm_hw_avail(substream));
 	snd_pcm_stream_unlock_irq(substream);
+	if (ret >= 0)
+		snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 	return ret;
 }
 
@@ -2915,6 +2924,8 @@ static snd_pcm_sframes_t snd_pcm_forward(struct snd_pcm_substream *substream,
 		ret = forward_appl_ptr(substream, frames,
 				       snd_pcm_avail(substream));
 	snd_pcm_stream_unlock_irq(substream);
+	if (ret >= 0)
+		snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 	return ret;
 }
 
@@ -2928,6 +2939,8 @@ static int snd_pcm_delay(struct snd_pcm_substream *substream,
 	if (delay && !err)
 		*delay = snd_pcm_calc_delay(substream);
 	snd_pcm_stream_unlock_irq(substream);
+	snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_CPU);
+
 	return err;
 }
 		
@@ -2978,6 +2991,8 @@ static int snd_pcm_sync_ptr(struct snd_pcm_substream *substream,
 	sync_ptr.s.status.suspended_state = status->suspended_state;
 	sync_ptr.s.status.audio_tstamp = status->audio_tstamp;
 	snd_pcm_stream_unlock_irq(substream);
+	if (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL))
+		snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 	if (copy_to_user(_sync_ptr, &sync_ptr, sizeof(sync_ptr)))
 		return -EFAULT;
 	return 0;
@@ -3069,6 +3084,8 @@ static int snd_pcm_ioctl_sync_ptr_compat(struct snd_pcm_substream *substream,
 	sstatus.suspended_state = status->suspended_state;
 	sstatus.audio_tstamp = status->audio_tstamp;
 	snd_pcm_stream_unlock_irq(substream);
+	if (!(sflags & SNDRV_PCM_SYNC_PTR_APPL))
+		snd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);
 	if (put_user(sstatus.state, &src->s.status.state) ||
 	    put_user(sstatus.hw_ptr, &src->s.status.hw_ptr) ||
 	    put_user(sstatus.tstamp.tv_sec, &src->s.status.tstamp_sec) ||
