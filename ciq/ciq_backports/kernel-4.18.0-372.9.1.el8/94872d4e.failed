net/mlx5e: Cleanup safe switch channels API by passing params

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Maxim Mikityanskiy <maximmi@nvidia.com>
commit 94872d4ef9c09cb0938595b473c68f4a5fb138f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/94872d4e.failed

mlx5e_safe_switch_channels accepts new_chs as a parameter and opens new
channels in place, then copying them to priv->channels. It requires all
the callers to allocate space for this temporary storage of the new
channels.

This commit cleans up the API by replacing new_chs with new_params, a
meaningful subset of new_chs to be filled by the caller. The temporary
space for the new channels is allocated inside mlx5e_safe_switch_params
(a new name for mlx5e_safe_switch_channels). An extra copy of params is
made, but since it's control flow, it's not critical.

	Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 94872d4ef9c09cb0938595b473c68f4a5fb138f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 9cd4c188c5a0,b636d63358d2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -1014,10 -1018,10 +1014,17 @@@ int fn##_ctx(struct mlx5e_priv *priv, v
  	return fn(priv); \
  }
  int mlx5e_safe_reopen_channels(struct mlx5e_priv *priv);
++<<<<<<< HEAD
 +int mlx5e_safe_switch_channels(struct mlx5e_priv *priv,
 +			       struct mlx5e_channels *new_chs,
 +			       mlx5e_fp_preactivate preactivate,
 +			       void *context);
++=======
+ int mlx5e_safe_switch_params(struct mlx5e_priv *priv,
+ 			     struct mlx5e_params *new_params,
+ 			     mlx5e_fp_preactivate preactivate,
+ 			     void *context, bool reset);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  int mlx5e_update_tx_netdev_queues(struct mlx5e_priv *priv);
  int mlx5e_num_channels_changed(struct mlx5e_priv *priv);
  int mlx5e_num_channels_changed_ctx(struct mlx5e_priv *priv, void *context);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index f23c67575073,a4c8d8d00d5a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -1149,35 -1149,23 +1149,50 @@@ static int mlx5e_update_trust_state_hw(
  
  static int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state)
  {
++<<<<<<< HEAD
 +	struct mlx5e_channels new_channels = {};
 +	bool reset_channels = true;
 +	bool opened;
 +	int err = 0;
++=======
+ 	struct mlx5e_params new_params;
+ 	bool reset = true;
+ 	int err;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  	mutex_lock(&priv->state_lock);
  
- 	new_channels.params = priv->channels.params;
- 	mlx5e_params_calc_trust_tx_min_inline_mode(priv->mdev, &new_channels.params,
+ 	new_params = priv->channels.params;
+ 	mlx5e_params_calc_trust_tx_min_inline_mode(priv->mdev, &new_params,
  						   trust_state);
  
 +	opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
 +	if (!opened)
 +		reset_channels = false;
 +
  	/* Skip if tx_min_inline is the same */
++<<<<<<< HEAD
 +	if (new_channels.params.tx_min_inline_mode ==
 +	    priv->channels.params.tx_min_inline_mode)
 +		reset_channels = false;
 +
 +	if (reset_channels) {
 +		err = mlx5e_safe_switch_channels(priv, &new_channels,
 +						 mlx5e_update_trust_state_hw,
 +						 &trust_state);
 +	} else {
 +		err = mlx5e_update_trust_state_hw(priv, &trust_state);
 +		if (!err && !opened)
 +			priv->channels.params = new_channels.params;
 +	}
++=======
+ 	if (new_params.tx_min_inline_mode == priv->channels.params.tx_min_inline_mode)
+ 		reset = false;
+ 
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_update_trust_state_hw,
+ 				       &trust_state, reset);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  	mutex_unlock(&priv->state_lock);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index ece5963738c0,ef4a330c4cfa..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -372,12 -373,7 +372,16 @@@ int mlx5e_ethtool_set_ringparam(struct 
  	if (err)
  		goto unlock;
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		goto unlock;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  unlock:
  	mutex_unlock(&priv->state_lock);
@@@ -422,8 -418,9 +426,8 @@@ int mlx5e_ethtool_set_channels(struct m
  {
  	struct mlx5e_params *cur_params = &priv->channels.params;
  	unsigned int count = ch->combined_count;
- 	struct mlx5e_channels new_channels = {};
+ 	struct mlx5e_params new_params;
  	bool arfs_enabled;
 -	bool opened;
  	int err = 0;
  
  	if (!count) {
@@@ -458,28 -455,18 +462,33 @@@
  		goto out;
  	}
  
- 	new_channels.params = *cur_params;
- 	new_channels.params.num_channels = count;
+ 	new_params = *cur_params;
+ 	new_params.num_channels = count;
  
 -	opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
  
 -	arfs_enabled = opened && (priv->netdev->features & NETIF_F_NTUPLE);
 +		old_params = *cur_params;
 +		*cur_params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			*cur_params = old_params;
 +
 +		goto out;
 +	}
 +
 +	arfs_enabled = priv->netdev->features & NETIF_F_NTUPLE;
  	if (arfs_enabled)
  		mlx5e_arfs_disable(priv);
  
  	/* Switch to new channels, set new parameters and close old ones */
++<<<<<<< HEAD
 +	err = mlx5e_safe_switch_channels(priv, &new_channels,
 +					 mlx5e_num_channels_changed_ctx, NULL);
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_num_channels_changed_ctx, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  	if (arfs_enabled) {
  		int err2 = mlx5e_arfs_enable(priv);
@@@ -576,8 -561,9 +585,8 @@@ int mlx5e_ethtool_set_coalesce(struct m
  {
  	struct dim_cq_moder *rx_moder, *tx_moder;
  	struct mlx5_core_dev *mdev = priv->mdev;
- 	struct mlx5e_channels new_channels = {};
+ 	struct mlx5e_params new_params;
  	bool reset_rx, reset_tx;
 -	bool reset = true;
  	int err = 0;
  
  	if (!MLX5_CAP_GEN(mdev, cq_moderation))
@@@ -614,35 -600,31 +623,39 @@@
  	reset_tx = !!coal->use_adaptive_tx_coalesce != priv->channels.params.tx_dim_enabled;
  
  	if (reset_rx) {
- 		u8 mode = MLX5E_GET_PFLAG(&new_channels.params,
+ 		u8 mode = MLX5E_GET_PFLAG(&new_params,
  					  MLX5E_PFLAG_RX_CQE_BASED_MODER);
  
- 		mlx5e_reset_rx_moderation(&new_channels.params, mode);
+ 		mlx5e_reset_rx_moderation(&new_params, mode);
  	}
  	if (reset_tx) {
- 		u8 mode = MLX5E_GET_PFLAG(&new_channels.params,
+ 		u8 mode = MLX5E_GET_PFLAG(&new_params,
  					  MLX5E_PFLAG_TX_CQE_BASED_MODER);
  
- 		mlx5e_reset_tx_moderation(&new_channels.params, mode);
+ 		mlx5e_reset_tx_moderation(&new_params, mode);
  	}
  
 -	/* If DIM state hasn't changed, it's possible to modify interrupt
 -	 * moderation parameters on the fly, even if the channels are open.
 -	 */
 -	if (!reset_rx && !reset_tx && test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		goto out;
 +	}
 +
 +	if (!reset_rx && !reset_tx) {
  		if (!coal->use_adaptive_rx_coalesce)
  			mlx5e_set_priv_channels_rx_coalesce(priv, coal);
  		if (!coal->use_adaptive_tx_coalesce)
  			mlx5e_set_priv_channels_tx_coalesce(priv, coal);
 -		reset = false;
 +		priv->channels.params = new_channels.params;
 +		goto out;
  	}
  
++<<<<<<< HEAD
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, reset);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
 +out:
  	mutex_unlock(&priv->state_lock);
  	return err;
  }
@@@ -1883,18 -1862,13 +1896,22 @@@ static int set_pflag_cqe_based_moder(st
  	if (!mode_changed)
  		return 0;
  
- 	new_channels.params = priv->channels.params;
+ 	new_params = priv->channels.params;
  	if (is_rx_cq)
- 		mlx5e_set_rx_cq_mode_params(&new_channels.params, cq_period_mode);
+ 		mlx5e_set_rx_cq_mode_params(&new_params, cq_period_mode);
  	else
- 		mlx5e_set_tx_cq_mode_params(&new_channels.params, cq_period_mode);
+ 		mlx5e_set_tx_cq_mode_params(&new_params, cq_period_mode);
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	return mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  }
  
  static int set_pflag_tx_cqe_based_moder(struct net_device *netdev, bool enable)
@@@ -1919,15 -1893,16 +1936,28 @@@ int mlx5e_modify_rx_cqe_compression_loc
  	if (curr_val == new_val)
  		return 0;
  
++<<<<<<< HEAD
 +	new_channels.params = priv->channels.params;
 +	MLX5E_SET_PFLAG(&new_channels.params, MLX5E_PFLAG_RX_CQE_COMPRESS, new_val);
 +
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	new_params = priv->channels.params;
+ 	MLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_RX_CQE_COMPRESS, new_val);
+ 	if (priv->tstamp.rx_filter != HWTSTAMP_FILTER_NONE)
+ 		new_params.ptp_rx = new_val;
+ 
+ 	if (new_params.ptp_rx == priv->channels.params.ptp_rx)
+ 		err = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);
+ 	else
+ 		err = mlx5e_safe_switch_params(priv, &new_params, mlx5e_ptp_rx_manage_fs_ctx,
+ 					       &new_params.ptp_rx, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	if (err)
  		return err;
  
@@@ -1978,17 -1948,12 +2008,21 @@@ static int set_pflag_rx_striding_rq(str
  		return -EINVAL;
  	}
  
- 	new_channels.params = priv->channels.params;
+ 	new_params = priv->channels.params;
  
- 	MLX5E_SET_PFLAG(&new_channels.params, MLX5E_PFLAG_RX_STRIDING_RQ, enable);
- 	mlx5e_set_rq_type(mdev, &new_channels.params);
+ 	MLX5E_SET_PFLAG(&new_params, MLX5E_PFLAG_RX_STRIDING_RQ, enable);
+ 	mlx5e_set_rq_type(mdev, &new_params);
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	return mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  }
  
  static int set_pflag_rx_no_csum_complete(struct net_device *netdev, bool enable)
@@@ -2017,23 -1982,16 +2051,31 @@@ static int set_pflag_tx_mpwqe_common(st
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5_core_dev *mdev = priv->mdev;
++<<<<<<< HEAD
 +	struct mlx5e_channels new_channels = {};
 +	int err;
++=======
+ 	struct mlx5e_params new_params;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
 -	if (enable && !MLX5_CAP_ETH(mdev, enhanced_multi_pkt_send_wqe))
 +	if (enable && !mlx5e_tx_mpwqe_supported(mdev))
  		return -EOPNOTSUPP;
  
- 	new_channels.params = priv->channels.params;
+ 	new_params = priv->channels.params;
  
- 	MLX5E_SET_PFLAG(&new_channels.params, flag, enable);
+ 	MLX5E_SET_PFLAG(&new_params, flag, enable);
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
 +	return err;
++=======
+ 	return mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  }
  
  static int set_pflag_xdp_tx_mpwqe(struct net_device *netdev, bool enable)
@@@ -2073,22 -2031,10 +2115,27 @@@ static int set_pflag_tx_port_ts(struct 
  	 * has the same log_sq_size.
  	 */
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = priv->channels.params;
 +		priv->channels.params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			priv->channels.params = old_params;
 +		goto out;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels,
 +					 mlx5e_num_channels_changed_ctx, NULL);
 +out:
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_num_channels_changed_ctx, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	if (!err)
 -		priv->tx_ptp_opened = true;
 +		priv->port_ptp_opened = true;
  
  	return err;
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 12c3751bdd22,feb347e81448..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2867,41 -2909,32 +2867,67 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
 +int mlx5e_safe_switch_channels(struct mlx5e_priv *priv,
 +			       struct mlx5e_channels *new_chs,
 +			       mlx5e_fp_preactivate preactivate,
 +			       void *context)
 +{
 +	bool opened;
 +	int err;
 +
 +	opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
 +
 +	if (opened) {
 +		err = mlx5e_open_channels(priv, new_chs);
 +		if (err)
 +			return err;
 +	}
 +
 +	err = mlx5e_switch_priv_channels(priv, new_chs, preactivate, context);
 +	if (err)
 +		goto err_close;
 +
 +	return 0;
 +
 +err_close:
 +	if (opened)
 +		mlx5e_close_channels(new_chs);
++=======
+ int mlx5e_safe_switch_params(struct mlx5e_priv *priv,
+ 			     struct mlx5e_params *params,
+ 			     mlx5e_fp_preactivate preactivate,
+ 			     void *context, bool reset)
+ {
+ 	struct mlx5e_channels new_chs = {};
+ 	int err;
+ 
+ 	reset &= test_bit(MLX5E_STATE_OPENED, &priv->state);
+ 	if (!reset)
+ 		return mlx5e_switch_priv_params(priv, params, preactivate, context);
+ 
+ 	new_chs.params = *params;
+ 	err = mlx5e_open_channels(priv, &new_chs);
+ 	if (err)
+ 		return err;
+ 	err = mlx5e_switch_priv_channels(priv, &new_chs, preactivate, context);
+ 	if (err)
+ 		mlx5e_close_channels(&new_chs);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  	return err;
  }
  
  int mlx5e_safe_reopen_channels(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	struct mlx5e_channels new_channels = {};
 +
 +	new_channels.params = priv->channels.params;
 +	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	return mlx5e_safe_switch_params(priv, &priv->channels.params, NULL, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  }
  
  void mlx5e_timestamp_init(struct mlx5e_priv *priv)
@@@ -3378,23 -3410,11 +3404,28 @@@ static int mlx5e_setup_tc_mqprio(struc
  		goto out;
  	}
  
- 	new_channels.params = priv->channels.params;
- 	new_channels.params.num_tc = tc ? tc : 1;
+ 	new_params = priv->channels.params;
+ 	new_params.num_tc = tc ? tc : 1;
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = priv->channels.params;
 +		priv->channels.params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			priv->channels.params = old_params;
 +
 +		goto out;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels,
 +					 mlx5e_num_channels_changed_ctx, NULL);
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_num_channels_changed_ctx, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  out:
  	priv->max_opened_tc = max_t(u8, priv->max_opened_tc,
@@@ -3611,10 -3639,10 +3642,14 @@@ static int set_feature_lro(struct net_d
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5_core_dev *mdev = priv->mdev;
- 	struct mlx5e_channels new_channels = {};
  	struct mlx5e_params *cur_params;
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_params new_params;
+ 	bool reset = true;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	int err = 0;
 +	bool reset;
  
  	mutex_lock(&priv->state_lock);
  
@@@ -3632,30 -3660,17 +3667,40 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	reset = test_bit(MLX5E_STATE_OPENED, &priv->state);
 +
 +	new_channels.params = *cur_params;
 +	new_channels.params.lro_en = enable;
++=======
+ 	new_params = *cur_params;
+ 	new_params.lro_en = enable;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
 -	if (cur_params->rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ) {
 +	if (cur_params->rq_wq_type != MLX5_WQ_TYPE_CYCLIC) {
  		if (mlx5e_rx_mpwqe_is_linear_skb(mdev, cur_params, NULL) ==
- 		    mlx5e_rx_mpwqe_is_linear_skb(mdev, &new_channels.params, NULL))
+ 		    mlx5e_rx_mpwqe_is_linear_skb(mdev, &new_params, NULL))
  			reset = false;
  	}
  
++<<<<<<< HEAD
 +	if (!reset) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = *cur_params;
 +		*cur_params = new_channels.params;
 +		err = mlx5e_modify_tirs_lro(priv);
 +		if (err)
 +			*cur_params = old_params;
 +		goto out;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels,
 +					 mlx5e_modify_tirs_lro_ctx, NULL);
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params,
+ 				       mlx5e_modify_tirs_lro_ctx, NULL, reset);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  out:
  	mutex_unlock(&priv->state_lock);
  	return err;
@@@ -3893,21 -3899,18 +3938,27 @@@ int mlx5e_change_mtu(struct net_device 
  		     mlx5e_fp_preactivate preactivate)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
- 	struct mlx5e_channels new_channels = {};
+ 	struct mlx5e_params new_params;
  	struct mlx5e_params *params;
 -	bool reset = true;
  	int err = 0;
 +	bool reset;
  
  	mutex_lock(&priv->state_lock);
  
  	params = &priv->channels.params;
  
++<<<<<<< HEAD
 +	reset = !params->lro_en;
 +	reset = reset && test_bit(MLX5E_STATE_OPENED, &priv->state);
 +
 +	new_channels.params = *params;
 +	new_channels.params.sw_mtu = new_mtu;
 +	err = mlx5e_validate_params(priv->mdev, &new_channels.params);
++=======
+ 	new_params = *params;
+ 	new_params.sw_mtu = new_mtu;
+ 	err = mlx5e_validate_params(priv->mdev, &new_params);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	if (err)
  		goto out;
  
@@@ -3926,42 -3929,29 +3977,52 @@@
  		goto out;
  	}
  
 -	if (params->lro_en)
 -		reset = false;
 -
  	if (params->rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ) {
++<<<<<<< HEAD
 +		bool is_linear = mlx5e_rx_mpwqe_is_linear_skb(priv->mdev,
 +							      &new_channels.params,
 +							      NULL);
++=======
+ 		bool is_linear_old = mlx5e_rx_mpwqe_is_linear_skb(priv->mdev, params, NULL);
+ 		bool is_linear_new = mlx5e_rx_mpwqe_is_linear_skb(priv->mdev,
+ 								  &new_params, NULL);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  		u8 ppw_old = mlx5e_mpwqe_log_pkts_per_wqe(params, NULL);
- 		u8 ppw_new = mlx5e_mpwqe_log_pkts_per_wqe(&new_channels.params, NULL);
+ 		u8 ppw_new = mlx5e_mpwqe_log_pkts_per_wqe(&new_params, NULL);
  
 -		/* Always reset in linear mode - hw_mtu is used in data path.
 -		 * Check that the mode was non-linear and didn't change.
 -		 * If XSK is active, XSK RQs are linear.
 -		 */
 -		if (!is_linear_old && !is_linear_new && !priv->xsk.refcnt &&
 -		    ppw_old == ppw_new)
 -			reset = false;
 +		/* If XSK is active, XSK RQs are linear. */
 +		is_linear |= priv->xsk.refcnt;
 +
 +		/* Always reset in linear mode - hw_mtu is used in data path. */
 +		reset = reset && (is_linear || (ppw_old != ppw_new));
  	}
  
++<<<<<<< HEAD
 +	if (!reset) {
 +		unsigned int old_mtu = params->sw_mtu;
 +
 +		params->sw_mtu = new_mtu;
 +		if (preactivate) {
 +			err = preactivate(priv, NULL);
 +			if (err) {
 +				params->sw_mtu = old_mtu;
 +				goto out;
 +			}
 +		}
 +		netdev->mtu = params->sw_mtu;
 +		goto out;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, preactivate, NULL);
 +	if (err)
 +		goto out;
 +
 +	netdev->mtu = new_channels.params.sw_mtu;
++=======
+ 	err = mlx5e_safe_switch_params(priv, &new_params, preactivate, NULL, reset);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  out:
 -	netdev->mtu = params->sw_mtu;
  	mutex_unlock(&priv->state_lock);
  	return err;
  }
@@@ -3971,9 -3961,18 +4032,13 @@@ static int mlx5e_change_nic_mtu(struct 
  	return mlx5e_change_mtu(netdev, new_mtu, mlx5e_set_dev_port_mtu_ctx);
  }
  
 -int mlx5e_ptp_rx_manage_fs_ctx(struct mlx5e_priv *priv, void *ctx)
 -{
 -	bool set  = *(bool *)ctx;
 -
 -	return mlx5e_ptp_rx_manage_fs(priv, set);
 -}
 -
  int mlx5e_hwstamp_set(struct mlx5e_priv *priv, struct ifreq *ifr)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_params new_params;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	struct hwtstamp_config config;
 -	bool rx_cqe_compress_def;
  	int err;
  
  	if (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz) ||
@@@ -3993,11 -3992,13 +4058,21 @@@
  	}
  
  	mutex_lock(&priv->state_lock);
++<<<<<<< HEAD
 +	/* RX HW timestamp */
 +	switch (config.rx_filter) {
 +	case HWTSTAMP_FILTER_NONE:
 +		/* Reset CQE compression to Admin default */
 +		mlx5e_modify_rx_cqe_compression_locked(priv, priv->channels.params.rx_cqe_compress_def);
++=======
+ 	new_params = priv->channels.params;
+ 	rx_cqe_compress_def = priv->channels.params.rx_cqe_compress_def;
+ 
+ 	/* RX HW timestamp */
+ 	switch (config.rx_filter) {
+ 	case HWTSTAMP_FILTER_NONE:
+ 		new_params.ptp_rx = false;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  		break;
  	case HWTSTAMP_FILTER_ALL:
  	case HWTSTAMP_FILTER_SOME:
@@@ -4014,15 -4015,7 +4089,19 @@@
  	case HWTSTAMP_FILTER_PTP_V2_SYNC:
  	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
  	case HWTSTAMP_FILTER_NTP_ALL:
++<<<<<<< HEAD
 +		/* Disable CQE compression */
 +		if (MLX5E_GET_PFLAG(&priv->channels.params, MLX5E_PFLAG_RX_CQE_COMPRESS))
 +			netdev_warn(priv->netdev, "Disabling RX cqe compression\n");
 +		err = mlx5e_modify_rx_cqe_compression_locked(priv, false);
 +		if (err) {
 +			netdev_err(priv->netdev, "Failed disabling cqe compression err=%d\n", err);
 +			mutex_unlock(&priv->state_lock);
 +			return err;
 +		}
++=======
+ 		new_params.ptp_rx = rx_cqe_compress_def;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  		config.rx_filter = HWTSTAMP_FILTER_ALL;
  		break;
  	default:
@@@ -4030,6 -4023,16 +4109,19 @@@
  		return -ERANGE;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (new_params.ptp_rx == priv->channels.params.ptp_rx)
+ 		goto out;
+ 
+ 	err = mlx5e_safe_switch_params(priv, &new_params, mlx5e_ptp_rx_manage_fs_ctx,
+ 				       &new_params.ptp_rx, true);
+ 	if (err) {
+ 		mutex_unlock(&priv->state_lock);
+ 		return err;
+ 	}
+ out:
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	memcpy(&priv->tstamp, &config, sizeof(config));
  	mutex_unlock(&priv->state_lock);
  
@@@ -4386,9 -4387,10 +4478,13 @@@ static void mlx5e_rq_replace_xdp_prog(s
  static int mlx5e_xdp_set(struct net_device *netdev, struct bpf_prog *prog)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_params new_params;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	struct bpf_prog *old_prog;
 +	bool reset, was_opened;
  	int err = 0;
 -	bool reset;
  	int i;
  
  	mutex_lock(&priv->state_lock);
@@@ -4403,29 -4404,15 +4499,41 @@@
  	/* no need for full reset when exchanging programs */
  	reset = (!priv->channels.params.xdp_prog || !prog);
  
++<<<<<<< HEAD
 +	if (was_opened && !reset)
 +		/* num_channels is invariant here, so we can take the
 +		 * batched reference right upfront.
 +		 */
 +		bpf_prog_add(prog, priv->channels.num);
 +
 +	if (was_opened && reset) {
 +		struct mlx5e_channels new_channels = {};
 +
 +		new_channels.params = priv->channels.params;
 +		new_channels.params.xdp_prog = prog;
 +		mlx5e_set_rq_type(priv->mdev, &new_channels.params);
 +		old_prog = priv->channels.params.xdp_prog;
 +
 +		err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
 +		if (err)
 +			goto unlock;
 +	} else {
 +		/* exchange programs, extra prog reference we got from caller
 +		 * as long as we don't fail from this point onwards.
 +		 */
 +		old_prog = xchg(&priv->channels.params.xdp_prog, prog);
 +	}
++=======
+ 	new_params = priv->channels.params;
+ 	new_params.xdp_prog = prog;
+ 	if (reset)
+ 		mlx5e_set_rq_type(priv->mdev, &new_params);
+ 	old_prog = priv->channels.params.xdp_prog;
+ 
+ 	err = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, reset);
+ 	if (err)
+ 		goto unlock;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  
  	if (old_prog)
  		bpf_prog_put(old_prog);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index e73e098ed210,612a7f69366d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -480,24 -481,15 +480,35 @@@ static const struct mlx5e_profile mlx5i
  static int mlx5i_change_mtu(struct net_device *netdev, int new_mtu)
  {
  	struct mlx5e_priv *priv = mlx5i_epriv(netdev);
++<<<<<<< HEAD
 +	struct mlx5e_channels new_channels = {};
 +	struct mlx5e_params *params;
++=======
+ 	struct mlx5e_params new_params;
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	int err = 0;
  
  	mutex_lock(&priv->state_lock);
  
++<<<<<<< HEAD
 +	params = &priv->channels.params;
 +
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		params->sw_mtu = new_mtu;
 +		netdev->mtu = params->sw_mtu;
 +		goto out;
 +	}
 +
 +	new_channels.params = *params;
 +	new_channels.params.sw_mtu = new_mtu;
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	new_params = priv->channels.params;
+ 	new_params.sw_mtu = new_mtu;
+ 
+ 	err = mlx5e_safe_switch_params(priv, &new_params, NULL, NULL, true);
++>>>>>>> 94872d4ef9c0 (net/mlx5e: Cleanup safe switch channels API by passing params)
  	if (err)
  		goto out;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
