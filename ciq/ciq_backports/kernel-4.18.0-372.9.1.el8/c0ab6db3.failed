optee: simplify optee_release()

jira LE-1907
cve CVE-2021-44733
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Jens Wiklander <jens.wiklander@linaro.org>
commit c0ab6db39a908d86ed44e8a5632548e2ec1b4dca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/c0ab6db3.failed

Simplifies optee_release() with a new helper function,
optee_close_session_helper() which has been factored out from
optee_close_session().

A separate optee_release_supp() is added for the supplicant device.

	Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
	Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
(cherry picked from commit c0ab6db39a908d86ed44e8a5632548e2ec1b4dca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tee/optee/core.c
diff --cc drivers/tee/optee/core.c
index 0491a41e8d58,79f67a79e7b7..000000000000
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@@ -287,20 -275,6 +284,23 @@@ static void optee_release_helper(struc
  	if (!ctxdata)
  		return;
  
++<<<<<<< HEAD
 +	shm = tee_shm_alloc(ctx, sizeof(struct optee_msg_arg), TEE_SHM_MAPPED);
 +	if (!IS_ERR(shm)) {
 +		arg = tee_shm_get_va(shm, 0);
 +		/*
 +		 * If va2pa fails for some reason, we can't call into
 +		 * secure world, only free the memory. Secure OS will leak
 +		 * sessions and finally refuse more sessions, but we will
 +		 * at least let normal world reclaim its memory.
 +		 */
 +		if (!IS_ERR(arg))
 +			if (tee_shm_va2pa(shm, arg, &parg))
 +				arg = NULL; /* prevent usage of parg below */
 +	}
 +
++=======
++>>>>>>> c0ab6db39a90 (optee: simplify optee_release())
  	list_for_each_entry_safe(sess, sess_tmp, &ctxdata->sess_list,
  				 list_node) {
  		list_del(&sess->list_node);
diff --git a/drivers/tee/optee/call.c b/drivers/tee/optee/call.c
index 437500004448..3ffdf9251dda 100644
--- a/drivers/tee/optee/call.c
+++ b/drivers/tee/optee/call.c
@@ -297,12 +297,28 @@ int optee_open_session(struct tee_context *ctx,
 	return rc;
 }
 
-int optee_close_session(struct tee_context *ctx, u32 session)
+int optee_close_session_helper(struct tee_context *ctx, u32 session)
 {
-	struct optee_context_data *ctxdata = ctx->data;
 	struct tee_shm *shm;
 	struct optee_msg_arg *msg_arg;
 	phys_addr_t msg_parg;
+
+	shm = get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
+	if (IS_ERR(shm))
+		return PTR_ERR(shm);
+
+	msg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;
+	msg_arg->session = session;
+	optee_do_call_with_arg(ctx, msg_parg);
+
+	tee_shm_free(shm);
+
+	return 0;
+}
+
+int optee_close_session(struct tee_context *ctx, u32 session)
+{
+	struct optee_context_data *ctxdata = ctx->data;
 	struct optee_session *sess;
 
 	/* Check that the session is valid and remove it from the list */
@@ -315,16 +331,7 @@ int optee_close_session(struct tee_context *ctx, u32 session)
 		return -EINVAL;
 	kfree(sess);
 
-	shm = get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
-	if (IS_ERR(shm))
-		return PTR_ERR(shm);
-
-	msg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;
-	msg_arg->session = session;
-	optee_do_call_with_arg(ctx, msg_parg);
-
-	tee_shm_free(shm);
-	return 0;
+	return optee_close_session_helper(ctx, session);
 }
 
 int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
* Unmerged path drivers/tee/optee/core.c
diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index 0b388ab3c6a5..a41dd926bba0 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -161,6 +161,7 @@ u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg);
 int optee_open_session(struct tee_context *ctx,
 		       struct tee_ioctl_open_session_arg *arg,
 		       struct tee_param *param);
+int optee_close_session_helper(struct tee_context *ctx, u32 session);
 int optee_close_session(struct tee_context *ctx, u32 session);
 int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
 		      struct tee_param *param);
