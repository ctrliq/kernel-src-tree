fget: clarify and improve __fget_files() implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit e386dfc56f837da66d00a078e5314bc8382fab83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/e386dfc5.failed

Commit 054aa8d439b9 ("fget: check that the fd still exists after getting
a ref to it") fixed a race with getting a reference to a file just as it
was being closed.  It was a fairly minimal patch, and I didn't think
re-checking the file pointer lookup would be a measurable overhead,
since it was all right there and cached.

But I was wrong, as pointed out by the kernel test robot.

The 'poll2' case of the will-it-scale.per_thread_ops benchmark regressed
quite noticeably.  Admittedly it seems to be a very artificial test:
doing "poll()" system calls on regular files in a very tight loop in
multiple threads.

That means that basically all the time is spent just looking up file
descriptors without ever doing anything useful with them (not that doing
'poll()' on a regular file is useful to begin with).  And as a result it
shows the extra "re-check fd" cost as a sore thumb.

Happily, the regression is fixable by just writing the code to loook up
the fd to be better and clearer.  There's still a cost to verify the
file pointer, but now it's basically in the noise even for that
benchmark that does nothing else - and the code is more understandable
and has better comments too.

[ Side note: this patch is also a classic case of one that looks very
  messy with the default greedy Myers diff - it's much more legible with
  either the patience of histogram diff algorithm ]

Link: https://lore.kernel.org/lkml/20211210053743.GA36420@xsang-OptiPlex-9020/
Link: https://lore.kernel.org/lkml/20211213083154.GA20853@linux.intel.com/
	Reported-by: kernel test robot <oliver.sang@intel.com>
	Tested-by: Carel Si <beibei.si@intel.com>
	Cc: Jann Horn <jannh@google.com>
	Cc: Miklos Szeredi <mszeredi@redhat.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e386dfc56f837da66d00a078e5314bc8382fab83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/file.c
diff --cc fs/file.c
index f356b1134a5e,97d212a9b814..000000000000
--- a/fs/file.c
+++ b/fs/file.c
@@@ -854,22 -902,7 +909,26 @@@ static struct file *__fget_files(struc
  	struct file *file;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +loop:
 +	file = fcheck_files(files, fd);
 +	if (file) {
 +		/* File object ref couldn't be taken.
 +		 * dup2() atomicity guarantee is the reason
 +		 * we loop to catch the new file (or NULL pointer)
 +		 */
 +		if (file->f_mode & mask)
 +			file = NULL;
 +		else if (!get_file_rcu_many(file, refs))
 +			goto loop;
 +		else if (files_lookup_fd_raw(files, fd) != file) {
 +			fput_many(file, refs);
 +			goto loop;
 +		}
 +	}
++=======
+ 	file = __fget_files_rcu(files, fd, mask, refs);
++>>>>>>> e386dfc56f83 (fget: clarify and improve __fget_files() implementation)
  	rcu_read_unlock();
  
  	return file;
* Unmerged path fs/file.c
