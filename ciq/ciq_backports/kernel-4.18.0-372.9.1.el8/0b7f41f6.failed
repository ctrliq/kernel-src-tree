tcp-zerocopy: Update returned getsockopt() optlen.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Arjun Roy <arjunroy@google.com>
commit 0b7f41f68710ccbf7d029c749616e5d26ae8f74d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/0b7f41f6.failed

TCP receive zerocopy currently does not update the returned optlen for
getsockopt() if the user passed in a larger than expected value.
Thus, userspace cannot properly determine if all the fields are set in
the passed-in struct. This patch sets the optlen for this case before
returning, in keeping with the expected operation of getsockopt().

Fixes: c8856c051454 ("tcp-zerocopy: Return inq along with tcp receive zerocopy.")
	Signed-off-by: Arjun Roy <arjunroy@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Soheil Hassas Yeganeh <soheil@google.com>
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0b7f41f68710ccbf7d029c749616e5d26ae8f74d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index fed129a064e8,48aa457a9516..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -3699,8 -3667,13 +3699,16 @@@ static int do_tcp_getsockopt(struct soc
  
  		if (get_user(len, optlen))
  			return -EFAULT;
 -		if (len < offsetofend(struct tcp_zerocopy_receive, length))
 +		if (len != sizeof(zc))
  			return -EINVAL;
++<<<<<<< HEAD
++=======
+ 		if (len > sizeof(zc)) {
+ 			len = sizeof(zc);
+ 			if (put_user(len, optlen))
+ 				return -EFAULT;
+ 		}
++>>>>>>> 0b7f41f68710 (tcp-zerocopy: Update returned getsockopt() optlen.)
  		if (copy_from_user(&zc, optval, len))
  			return -EFAULT;
  		lock_sock(sk);
* Unmerged path net/ipv4/tcp.c
