ext4: fix possible UAF when remounting r/o a mmp-protected file system

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Theodore Ts'o <tytso@mit.edu>
commit 61bb4a1c417e5b95d9edb4f887f131de32e419cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/61bb4a1c.failed

After commit 618f003199c6 ("ext4: fix memory leak in
ext4_fill_super"), after the file system is remounted read-only, there
is a race where the kmmpd thread can exit, causing sbi->s_mmp_tsk to
point at freed memory, which the call to ext4_stop_mmpd() can trip
over.

Fix this by only allowing kmmpd() to exit when it is stopped via
ext4_stop_mmpd().

Link: https://lore.kernel.org/r/20210707002433.3719773-1-tytso@mit.edu
	Reported-by: Ye Bin <yebin10@huawei.com>
Bug-Report-Link: <20210629143603.2166962-1-yebin10@huawei.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 61bb4a1c417e5b95d9edb4f887f131de32e419cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/mmp.c
#	fs/ext4/super.c
diff --cc fs/ext4/mmp.c
index 601dc102919f,bc364c119af6..000000000000
--- a/fs/ext4/mmp.c
+++ b/fs/ext4/mmp.c
@@@ -248,10 -239,13 +243,20 @@@ static int kmmpd(void *data
  
  	retval = write_mmp_block(sb, bh);
  
++<<<<<<< HEAD
 +exit_thread:
 +	EXT4_SB(sb)->s_mmp_tsk = NULL;
 +	kfree(data);
 +	brelse(bh);
++=======
+ wait_to_exit:
+ 	while (!kthread_should_stop()) {
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 		if (!kthread_should_stop())
+ 			schedule();
+ 	}
+ 	set_current_state(TASK_RUNNING);
++>>>>>>> 61bb4a1c417e (ext4: fix possible UAF when remounting r/o a mmp-protected file system)
  	return retval;
  }
  
diff --cc fs/ext4/super.c
index 338507562b31,b8ff0399e171..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -5489,10 -5986,13 +5489,14 @@@ static int ext4_remount(struct super_bl
  			    (sbi->s_mount_state & EXT4_VALID_FS))
  				es->s_state = cpu_to_le16(sbi->s_mount_state);
  
 -			if (sbi->s_journal) {
 -				/*
 -				 * We let remount-ro finish even if marking fs
 -				 * as clean failed...
 -				 */
 +			if (sbi->s_journal)
  				ext4_mark_recovery_complete(sb, es);
++<<<<<<< HEAD
 +			if (sbi->s_mmp_tsk)
 +				kthread_stop(sbi->s_mmp_tsk);
++=======
+ 			}
++>>>>>>> 61bb4a1c417e (ext4: fix possible UAF when remounting r/o a mmp-protected file system)
  		} else {
  			/* Make sure we can mount this feature set readwrite */
  			if (ext4_has_feature_readonly(sb) ||
@@@ -5600,9 -6103,12 +5604,12 @@@
  		}
  	}
  #endif
 -	if (!test_opt(sb, BLOCK_VALIDITY) && sbi->s_system_blks)
 +	if (!test_opt(sb, BLOCK_VALIDITY) && sbi->system_blks)
  		ext4_release_system_zone(sb);
  
+ 	if (!ext4_has_feature_mmp(sb) || sb_rdonly(sb))
+ 		ext4_stop_mmpd(sbi);
+ 
  	/*
  	 * Some options can be enabled by ext4 and/or by VFS mount flag
  	 * either way we need to make sure it matches in both *flags and
* Unmerged path fs/ext4/mmp.c
* Unmerged path fs/ext4/super.c
