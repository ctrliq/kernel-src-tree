net/mlx5: Embed mlx5_ttc_table

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-372.9.1.el8
commit-author Maor Gottlieb <maorg@nvidia.com>
commit f4b45940e9b9e0dc5f602e86e93c785547d226d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.9.1.el8/f4b45940.failed

mlx5_ttc_table struct shouldn't be exposed to the users so
this patch make it internal to ttc.

In addition add a getter function to get the TTC flow table for users
that need to add a rule which points on it.

	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
(cherry picked from commit f4b45940e9b9e0dc5f602e86e93c785547d226d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
#	drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.c
#	drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 6d1dade3f38c,e348c276eaa1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -231,10 -167,10 +231,15 @@@ struct mlx5e_flow_steering 
  #endif
  	struct mlx5e_tc_table           tc;
  	struct mlx5e_promisc_table      promisc;
 -	struct mlx5e_vlan_table         *vlan;
 +	struct mlx5e_vlan_table         vlan;
  	struct mlx5e_l2_table           l2;
++<<<<<<< HEAD
 +	struct mlx5e_ttc_table          ttc;
 +	struct mlx5e_ttc_table          inner_ttc;
++=======
+ 	struct mlx5_ttc_table           *ttc;
+ 	struct mlx5_ttc_table           *inner_ttc;
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  #ifdef CONFIG_MLX5_EN_ARFS
  	struct mlx5e_arfs_tables       *arfs;
  #endif
@@@ -243,29 -179,16 +248,32 @@@
  #endif
  	struct mlx5e_fs_udp            *udp;
  	struct mlx5e_fs_any            *any;
 -	struct mlx5e_ptp_fs            *ptp_fs;
  };
  
 -void mlx5e_set_ttc_params(struct mlx5e_priv *priv,
 -			  struct ttc_params *ttc_params, bool tunnel);
 +struct ttc_params {
 +	struct mlx5_flow_table_attr ft_attr;
 +	u32 any_tt_tirn;
 +	u32 indir_tirn[MLX5E_NUM_INDIR_TIRS];
 +	struct mlx5e_ttc_table *inner_ttc;
 +};
 +
 +void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv, struct ttc_params *ttc_params);
 +void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params);
 +
 +int mlx5e_create_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
 +			   struct mlx5e_ttc_table *ttc);
 +void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv,
 +			     struct mlx5e_ttc_table *ttc);
  
+ void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv);
+ int mlx5e_create_ttc_table(struct mlx5e_priv *priv);
+ 
  void mlx5e_destroy_flow_table(struct mlx5e_flow_table *ft);
 +int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
 +		       struct mlx5_flow_destination *new_dest);
 +struct mlx5_flow_destination
 +mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type);
 +int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type);
  
  void mlx5e_enable_cvlan_filter(struct mlx5e_priv *priv);
  void mlx5e_disable_cvlan_filter(struct mlx5e_priv *priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index 909faa6c89d7,7aa25a5e29d7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@@ -124,7 -124,7 +124,11 @@@ static int fs_udp_add_default_rule(stru
  	fs_udp = priv->fs.udp;
  	fs_udp_t = &fs_udp->tables[type];
  
++<<<<<<< HEAD
 +	dest = mlx5e_ttc_get_default_dest(priv, fs_udp2tt(type));
++=======
+ 	dest = mlx5_ttc_get_default_dest(priv->fs.ttc, fs_udp2tt(type));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	rule = mlx5_add_flow_rules(fs_udp_t->t, NULL, &flow_act, &dest, 1);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
@@@ -259,7 -259,7 +263,11 @@@ static int fs_udp_disable(struct mlx5e_
  
  	for (i = 0; i < FS_UDP_NUM_TYPES; i++) {
  		/* Modify ttc rules destination to point back to the indir TIRs */
++<<<<<<< HEAD
 +		err = mlx5e_ttc_fwd_default_dest(priv, fs_udp2tt(i));
++=======
+ 		err = mlx5_ttc_fwd_default_dest(priv->fs.ttc, fs_udp2tt(i));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		if (err) {
  			netdev_err(priv->netdev,
  				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@@ -281,7 -281,7 +289,11 @@@ static int fs_udp_enable(struct mlx5e_p
  		dest.ft = priv->fs.udp->tables[i].t;
  
  		/* Modify ttc rules destination to point on the accel_fs FTs */
++<<<<<<< HEAD
 +		err = mlx5e_ttc_fwd_dest(priv, fs_udp2tt(i), &dest);
++=======
+ 		err = mlx5_ttc_fwd_dest(priv->fs.ttc, fs_udp2tt(i), &dest);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		if (err) {
  			netdev_err(priv->netdev,
  				   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
@@@ -401,7 -401,7 +413,11 @@@ static int fs_any_add_default_rule(stru
  	fs_any = priv->fs.any;
  	fs_any_t = &fs_any->table;
  
++<<<<<<< HEAD
 +	dest = mlx5e_ttc_get_default_dest(priv, MLX5E_TT_ANY);
++=======
+ 	dest = mlx5_ttc_get_default_dest(priv->fs.ttc, MLX5_TT_ANY);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	rule = mlx5_add_flow_rules(fs_any_t->t, NULL, &flow_act, &dest, 1);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
@@@ -514,7 -514,7 +530,11 @@@ static int fs_any_disable(struct mlx5e_
  	int err;
  
  	/* Modify ttc rules destination to point back to the indir TIRs */
++<<<<<<< HEAD
 +	err = mlx5e_ttc_fwd_default_dest(priv, MLX5E_TT_ANY);
++=======
+ 	err = mlx5_ttc_fwd_default_dest(priv->fs.ttc, MLX5_TT_ANY);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	if (err) {
  		netdev_err(priv->netdev,
  			   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@@ -533,7 -533,7 +553,11 @@@ static int fs_any_enable(struct mlx5e_p
  	dest.ft = priv->fs.any->table.t;
  
  	/* Modify ttc rules destination to point on the accel_fs FTs */
++<<<<<<< HEAD
 +	err = mlx5e_ttc_fwd_dest(priv, MLX5E_TT_ANY, &dest);
++=======
+ 	err = mlx5_ttc_fwd_dest(priv->fs.ttc, MLX5_TT_ANY, &dest);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	if (err) {
  		netdev_err(priv->netdev,
  			   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
index e51f60b55daa,4c4ee524176c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
@@@ -161,7 -161,7 +161,11 @@@ static int accel_fs_tcp_add_default_rul
  	fs_tcp = priv->fs.accel_tcp;
  	accel_fs_t = &fs_tcp->tables[type];
  
++<<<<<<< HEAD
 +	dest = mlx5e_ttc_get_default_dest(priv, fs_accel2tt(type));
++=======
+ 	dest = mlx5_ttc_get_default_dest(priv->fs.ttc, fs_accel2tt(type));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	rule = mlx5_add_flow_rules(accel_fs_t->t, NULL, &flow_act, &dest, 1);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
@@@ -307,7 -307,7 +311,11 @@@ static int accel_fs_tcp_disable(struct 
  
  	for (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++) {
  		/* Modify ttc rules destination to point back to the indir TIRs */
++<<<<<<< HEAD
 +		err = mlx5e_ttc_fwd_default_dest(priv, fs_accel2tt(i));
++=======
+ 		err = mlx5_ttc_fwd_default_dest(priv->fs.ttc, fs_accel2tt(i));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		if (err) {
  			netdev_err(priv->netdev,
  				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@@ -329,7 -329,7 +337,11 @@@ static int accel_fs_tcp_enable(struct m
  		dest.ft = priv->fs.accel_tcp->tables[i].t;
  
  		/* Modify ttc rules destination to point on the accel_fs FTs */
++<<<<<<< HEAD
 +		err = mlx5e_ttc_fwd_dest(priv, fs_accel2tt(i), &dest);
++=======
+ 		err = mlx5_ttc_fwd_dest(priv->fs.ttc, fs_accel2tt(i), &dest);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		if (err) {
  			netdev_err(priv->netdev,
  				   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 34119ce92031,17da23dff0ed..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@@ -265,7 -265,8 +265,12 @@@ static int rx_create(struct mlx5e_priv 
  	accel_esp = priv->ipsec->rx_fs;
  	fs_prot = &accel_esp->fs_prot[type];
  
++<<<<<<< HEAD
 +	fs_prot->default_dest = mlx5e_ttc_get_default_dest(priv, fs_esp2tt(type));
++=======
+ 	fs_prot->default_dest =
+ 		mlx5_ttc_get_default_dest(priv->fs.ttc, fs_esp2tt(type));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	err = rx_err_create_ft(priv, fs_prot, &fs_prot->rx_err);
  	if (err)
@@@ -301,7 -302,7 +306,11 @@@ static int rx_ft_get(struct mlx5e_priv 
  	/* connect */
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
  	dest.ft = fs_prot->ft;
++<<<<<<< HEAD
 +	mlx5e_ttc_fwd_dest(priv, fs_esp2tt(type), &dest);
++=======
+ 	mlx5_ttc_fwd_dest(priv->fs.ttc, fs_esp2tt(type), &dest);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  out:
  	mutex_unlock(&fs_prot->prot_mutex);
@@@ -320,7 -321,7 +329,11 @@@ static void rx_ft_put(struct mlx5e_pri
  		goto out;
  
  	/* disconnect */
++<<<<<<< HEAD
 +	mlx5e_ttc_fwd_default_dest(priv, fs_esp2tt(type));
++=======
+ 	mlx5_ttc_fwd_default_dest(priv->fs.ttc, fs_esp2tt(type));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	/* remove FT */
  	rx_destroy(priv, type);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 25403af32859,fe5d82fa6e92..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@@ -120,7 -120,7 +120,11 @@@ static int arfs_disable(struct mlx5e_pr
  
  	for (i = 0; i < ARFS_NUM_TYPES; i++) {
  		/* Modify ttc rules destination back to their default */
++<<<<<<< HEAD
 +		err = mlx5e_ttc_fwd_default_dest(priv, arfs_get_tt(i));
++=======
+ 		err = mlx5_ttc_fwd_default_dest(priv->fs.ttc, arfs_get_tt(i));
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		if (err) {
  			netdev_err(priv->netdev,
  				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@@ -149,7 -149,7 +153,11 @@@ int mlx5e_arfs_enable(struct mlx5e_pri
  	for (i = 0; i < ARFS_NUM_TYPES; i++) {
  		dest.ft = priv->fs.arfs->arfs_tables[i].ft.t;
  		/* Modify ttc rules destination to point on the aRFS FTs */
++<<<<<<< HEAD
 +		err = mlx5e_ttc_fwd_dest(priv, arfs_get_tt(i), &dest);
++=======
+ 		err = mlx5_ttc_fwd_dest(priv->fs.ttc, arfs_get_tt(i), &dest);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		if (err) {
  			netdev_err(priv->netdev,
  				   "%s: modify ttc[%d] dest to arfs, failed err(%d)\n",
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 059efb0721cd,5c754e9af669..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -694,7 -718,7 +694,11 @@@ static int mlx5e_add_promisc_rule(struc
  	if (!spec)
  		return -ENOMEM;
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
++<<<<<<< HEAD
 +	dest.ft = priv->fs.ttc.ft.t;
++=======
+ 	dest.ft = mlx5_get_ttc_flow_table(priv->fs.ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	rule_p = &priv->fs.promisc.rule;
  	*rule_p = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);
@@@ -830,587 -854,59 +834,595 @@@ void mlx5e_destroy_flow_table(struct ml
  	ft->t = NULL;
  }
  
 -static void mlx5e_set_inner_ttc_params(struct mlx5e_priv *priv,
 -				       struct ttc_params *ttc_params)
 +static void mlx5e_cleanup_ttc_rules(struct mlx5e_ttc_table *ttc)
 +{
 +	int i;
 +
 +	for (i = 0; i < MLX5E_NUM_TT; i++) {
 +		if (!IS_ERR_OR_NULL(ttc->rules[i].rule)) {
 +			mlx5_del_flow_rules(ttc->rules[i].rule);
 +			ttc->rules[i].rule = NULL;
 +		}
 +	}
 +
 +	for (i = 0; i < MLX5E_NUM_TUNNEL_TT; i++) {
 +		if (!IS_ERR_OR_NULL(ttc->tunnel_rules[i])) {
 +			mlx5_del_flow_rules(ttc->tunnel_rules[i]);
 +			ttc->tunnel_rules[i] = NULL;
 +		}
 +	}
 +}
 +
 +struct mlx5e_etype_proto {
 +	u16 etype;
 +	u8 proto;
 +};
 +
 +static struct mlx5e_etype_proto ttc_rules[] = {
 +	[MLX5E_TT_IPV4_TCP] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_TCP,
 +	},
 +	[MLX5E_TT_IPV6_TCP] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_TCP,
 +	},
 +	[MLX5E_TT_IPV4_UDP] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_UDP,
 +	},
 +	[MLX5E_TT_IPV6_UDP] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_UDP,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_AH] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_AH,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_AH] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_AH,
 +	},
 +	[MLX5E_TT_IPV4_IPSEC_ESP] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_ESP,
 +	},
 +	[MLX5E_TT_IPV6_IPSEC_ESP] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_ESP,
 +	},
 +	[MLX5E_TT_IPV4] = {
 +		.etype = ETH_P_IP,
 +		.proto = 0,
 +	},
 +	[MLX5E_TT_IPV6] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = 0,
 +	},
 +	[MLX5E_TT_ANY] = {
 +		.etype = 0,
 +		.proto = 0,
 +	},
 +};
 +
 +static struct mlx5e_etype_proto ttc_tunnel_rules[] = {
 +	[MLX5E_TT_IPV4_GRE] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_GRE,
 +	},
 +	[MLX5E_TT_IPV6_GRE] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_GRE,
 +	},
 +	[MLX5E_TT_IPV4_IPIP] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_IPIP,
 +	},
 +	[MLX5E_TT_IPV6_IPIP] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_IPIP,
 +	},
 +	[MLX5E_TT_IPV4_IPV6] = {
 +		.etype = ETH_P_IP,
 +		.proto = IPPROTO_IPV6,
 +	},
 +	[MLX5E_TT_IPV6_IPV6] = {
 +		.etype = ETH_P_IPV6,
 +		.proto = IPPROTO_IPV6,
 +	},
 +
 +};
 +
 +u8 mlx5e_get_proto_by_tunnel_type(enum mlx5e_tunnel_types tt)
 +{
 +	return ttc_tunnel_rules[tt].proto;
 +}
 +
 +static bool mlx5e_tunnel_proto_supported_rx(struct mlx5_core_dev *mdev, u8 proto_type)
 +{
 +	switch (proto_type) {
 +	case IPPROTO_GRE:
 +		return MLX5_CAP_ETH(mdev, tunnel_stateless_gre);
 +	case IPPROTO_IPIP:
 +	case IPPROTO_IPV6:
 +		return (MLX5_CAP_ETH(mdev, tunnel_stateless_ip_over_ip) ||
 +			MLX5_CAP_ETH(mdev, tunnel_stateless_ip_over_ip_rx));
 +	default:
 +		return false;
 +	}
 +}
 +
 +static bool mlx5e_tunnel_any_rx_proto_supported(struct mlx5_core_dev *mdev)
  {
 -	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
  	int tt;
  
 -	memset(ttc_params, 0, sizeof(*ttc_params));
 -	ttc_params->ns = mlx5_get_flow_namespace(priv->mdev,
 -						 MLX5_FLOW_NAMESPACE_KERNEL);
 -	ft_attr->level = MLX5E_INNER_TTC_FT_LEVEL;
 -	ft_attr->prio = MLX5E_NIC_PRIO;
 +	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
 +		if (mlx5e_tunnel_proto_supported_rx(mdev, ttc_tunnel_rules[tt].proto))
 +			return true;
 +	}
 +	return false;
 +}
  
 -	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
 -		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 -		ttc_params->dests[tt].tir_num =
 -			tt == MLX5_TT_ANY ?
 -				mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0) :
 -				mlx5e_rx_res_get_tirn_rss_inner(priv->rx_res,
 -								tt);
 +bool mlx5e_tunnel_inner_ft_supported(struct mlx5_core_dev *mdev)
 +{
 +	return (mlx5e_tunnel_any_rx_proto_supported(mdev) &&
 +		MLX5_CAP_FLOWTABLE_NIC_RX(mdev, ft_field_support.inner_ip_version));
 +}
 +
 +static u8 mlx5e_etype_to_ipv(u16 ethertype)
 +{
 +	if (ethertype == ETH_P_IP)
 +		return 4;
 +
 +	if (ethertype == ETH_P_IPV6)
 +		return 6;
 +
 +	return 0;
 +}
 +
 +static struct mlx5_flow_handle *
 +mlx5e_generate_ttc_rule(struct mlx5e_priv *priv,
 +			struct mlx5_flow_table *ft,
 +			struct mlx5_flow_destination *dest,
 +			u16 etype,
 +			u8 proto)
 +{
 +	int match_ipv_outer = MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, ft_field_support.outer_ip_version);
 +	MLX5_DECLARE_FLOW_ACT(flow_act);
 +	struct mlx5_flow_handle *rule;
 +	struct mlx5_flow_spec *spec;
 +	int err = 0;
 +	u8 ipv;
 +
 +	spec = kvzalloc(sizeof(*spec), GFP_KERNEL);
 +	if (!spec)
 +		return ERR_PTR(-ENOMEM);
 +
 +	if (proto) {
 +		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
 +		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);
 +		MLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, proto);
 +	}
 +
 +	ipv = mlx5e_etype_to_ipv(etype);
 +	if (match_ipv_outer && ipv) {
 +		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
 +		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_version);
 +		MLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version, ipv);
 +	} else if (etype) {
 +		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
 +		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ethertype);
 +		MLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype, etype);
 +	}
 +
 +	rule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, 1);
 +	if (IS_ERR(rule)) {
 +		err = PTR_ERR(rule);
 +		netdev_err(priv->netdev, "%s: add rule failed\n", __func__);
  	}
 +
 +	kvfree(spec);
 +	return err ? ERR_PTR(err) : rule;
  }
  
 -void mlx5e_set_ttc_params(struct mlx5e_priv *priv,
 -			  struct ttc_params *ttc_params, bool tunnel)
 +static int mlx5e_generate_ttc_table_rules(struct mlx5e_priv *priv,
 +					  struct ttc_params *params,
 +					  struct mlx5e_ttc_table *ttc)
 +{
 +	struct mlx5_flow_destination dest = {};
 +	struct mlx5_flow_handle **trules;
 +	struct mlx5e_ttc_rule *rules;
 +	struct mlx5_flow_table *ft;
 +	int tt;
 +	int err;
  
 +	ft = ttc->ft.t;
 +	rules = ttc->rules;
 +
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 +	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
 +		struct mlx5e_ttc_rule *rule = &rules[tt];
 +
 +		if (tt == MLX5E_TT_ANY)
 +			dest.tir_num = params->any_tt_tirn;
 +		else
 +			dest.tir_num = params->indir_tirn[tt];
 +
 +		rule->rule = mlx5e_generate_ttc_rule(priv, ft, &dest,
 +						     ttc_rules[tt].etype,
 +						     ttc_rules[tt].proto);
 +		if (IS_ERR(rule->rule)) {
 +			err = PTR_ERR(rule->rule);
 +			rule->rule = NULL;
 +			goto del_rules;
 +		}
 +		rule->default_dest = dest;
 +	}
 +
 +	if (!params->inner_ttc || !mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		return 0;
 +
 +	trules    = ttc->tunnel_rules;
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
 +	dest.ft   = params->inner_ttc->ft.t;
 +	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
 +		if (!mlx5e_tunnel_proto_supported_rx(priv->mdev,
 +						     ttc_tunnel_rules[tt].proto))
 +			continue;
 +		trules[tt] = mlx5e_generate_ttc_rule(priv, ft, &dest,
 +						     ttc_tunnel_rules[tt].etype,
 +						     ttc_tunnel_rules[tt].proto);
 +		if (IS_ERR(trules[tt])) {
 +			err = PTR_ERR(trules[tt]);
 +			trules[tt] = NULL;
 +			goto del_rules;
 +		}
 +	}
 +
 +	return 0;
 +
 +del_rules:
 +	mlx5e_cleanup_ttc_rules(ttc);
 +	return err;
 +}
 +
 +static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc,
 +					 bool use_ipv)
  {
 -	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
 +	int inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);
 +	struct mlx5e_flow_table *ft = &ttc->ft;
 +	int ix = 0;
 +	u32 *in;
 +	int err;
 +	u8 *mc;
 +
 +	ft->g = kcalloc(MLX5E_TTC_NUM_GROUPS,
 +			sizeof(*ft->g), GFP_KERNEL);
 +	if (!ft->g)
 +		return -ENOMEM;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in) {
 +		kfree(ft->g);
 +		ft->g = NULL;
 +		return -ENOMEM;
 +	}
 +
 +	/* L4 Group */
 +	mc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);
 +	MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ip_protocol);
 +	if (use_ipv)
 +		MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ip_version);
 +	else
 +		MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);
 +	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
 +	MLX5_SET_CFG(in, start_flow_index, ix);
 +	ix += MLX5E_TTC_GROUP1_SIZE;
 +	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 +	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 +	if (IS_ERR(ft->g[ft->num_groups]))
 +		goto err;
 +	ft->num_groups++;
 +
 +	/* L3 Group */
 +	MLX5_SET(fte_match_param, mc, outer_headers.ip_protocol, 0);
 +	MLX5_SET_CFG(in, start_flow_index, ix);
 +	ix += MLX5E_TTC_GROUP2_SIZE;
 +	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 +	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 +	if (IS_ERR(ft->g[ft->num_groups]))
 +		goto err;
 +	ft->num_groups++;
 +
 +	/* Any Group */
 +	memset(in, 0, inlen);
 +	MLX5_SET_CFG(in, start_flow_index, ix);
 +	ix += MLX5E_TTC_GROUP3_SIZE;
 +	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 +	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 +	if (IS_ERR(ft->g[ft->num_groups]))
 +		goto err;
 +	ft->num_groups++;
 +
 +	kvfree(in);
 +	return 0;
 +
 +err:
 +	err = PTR_ERR(ft->g[ft->num_groups]);
 +	ft->g[ft->num_groups] = NULL;
 +	kvfree(in);
 +
 +	return err;
 +}
 +
 +static struct mlx5_flow_handle *
 +mlx5e_generate_inner_ttc_rule(struct mlx5e_priv *priv,
 +			      struct mlx5_flow_table *ft,
 +			      struct mlx5_flow_destination *dest,
 +			      u16 etype, u8 proto)
 +{
 +	MLX5_DECLARE_FLOW_ACT(flow_act);
 +	struct mlx5_flow_handle *rule;
 +	struct mlx5_flow_spec *spec;
 +	int err = 0;
 +	u8 ipv;
 +
 +	spec = kvzalloc(sizeof(*spec), GFP_KERNEL);
 +	if (!spec)
 +		return ERR_PTR(-ENOMEM);
 +
 +	ipv = mlx5e_etype_to_ipv(etype);
 +	if (etype && ipv) {
 +		spec->match_criteria_enable = MLX5_MATCH_INNER_HEADERS;
 +		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, inner_headers.ip_version);
 +		MLX5_SET(fte_match_param, spec->match_value, inner_headers.ip_version, ipv);
 +	}
 +
 +	if (proto) {
 +		spec->match_criteria_enable = MLX5_MATCH_INNER_HEADERS;
 +		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, inner_headers.ip_protocol);
 +		MLX5_SET(fte_match_param, spec->match_value, inner_headers.ip_protocol, proto);
 +	}
 +
 +	rule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, 1);
 +	if (IS_ERR(rule)) {
 +		err = PTR_ERR(rule);
 +		netdev_err(priv->netdev, "%s: add rule failed\n", __func__);
 +	}
 +
 +	kvfree(spec);
 +	return err ? ERR_PTR(err) : rule;
 +}
 +
 +static int mlx5e_generate_inner_ttc_table_rules(struct mlx5e_priv *priv,
 +						struct ttc_params *params,
 +						struct mlx5e_ttc_table *ttc)
 +{
 +	struct mlx5_flow_destination dest = {};
 +	struct mlx5e_ttc_rule *rules;
 +	struct mlx5_flow_table *ft;
 +	int err;
  	int tt;
  
 -	memset(ttc_params, 0, sizeof(*ttc_params));
 -	ttc_params->ns = mlx5_get_flow_namespace(priv->mdev,
 -						 MLX5_FLOW_NAMESPACE_KERNEL);
 +	ft = ttc->ft.t;
 +	rules = ttc->rules;
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 +
 +	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
 +		struct mlx5e_ttc_rule *rule = &rules[tt];
 +
 +		if (tt == MLX5E_TT_ANY)
 +			dest.tir_num = params->any_tt_tirn;
 +		else
 +			dest.tir_num = params->indir_tirn[tt];
 +
 +		rule->rule = mlx5e_generate_inner_ttc_rule(priv, ft, &dest,
 +							   ttc_rules[tt].etype,
 +							   ttc_rules[tt].proto);
 +		if (IS_ERR(rule->rule)) {
 +			err = PTR_ERR(rule->rule);
 +			rule->rule = NULL;
 +			goto del_rules;
 +		}
 +		rule->default_dest = dest;
 +	}
 +
 +	return 0;
 +
 +del_rules:
 +
 +	mlx5e_cleanup_ttc_rules(ttc);
 +	return err;
 +}
 +
 +static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 +{
 +	int inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);
 +	struct mlx5e_flow_table *ft = &ttc->ft;
 +	int ix = 0;
 +	u32 *in;
 +	int err;
 +	u8 *mc;
 +
 +	ft->g = kcalloc(MLX5E_INNER_TTC_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);
 +	if (!ft->g)
 +		return -ENOMEM;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in) {
 +		kfree(ft->g);
 +		ft->g = NULL;
 +		return -ENOMEM;
 +	}
 +
 +	/* L4 Group */
 +	mc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);
 +	MLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_protocol);
 +	MLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_version);
 +	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_INNER_HEADERS);
 +	MLX5_SET_CFG(in, start_flow_index, ix);
 +	ix += MLX5E_INNER_TTC_GROUP1_SIZE;
 +	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 +	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 +	if (IS_ERR(ft->g[ft->num_groups]))
 +		goto err;
 +	ft->num_groups++;
 +
 +	/* L3 Group */
 +	MLX5_SET(fte_match_param, mc, inner_headers.ip_protocol, 0);
 +	MLX5_SET_CFG(in, start_flow_index, ix);
 +	ix += MLX5E_INNER_TTC_GROUP2_SIZE;
 +	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 +	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 +	if (IS_ERR(ft->g[ft->num_groups]))
 +		goto err;
 +	ft->num_groups++;
 +
 +	/* Any Group */
 +	memset(in, 0, inlen);
 +	MLX5_SET_CFG(in, start_flow_index, ix);
 +	ix += MLX5E_INNER_TTC_GROUP3_SIZE;
 +	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 +	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
 +	if (IS_ERR(ft->g[ft->num_groups]))
 +		goto err;
 +	ft->num_groups++;
 +
 +	kvfree(in);
 +	return 0;
 +
 +err:
 +	err = PTR_ERR(ft->g[ft->num_groups]);
 +	ft->g[ft->num_groups] = NULL;
 +	kvfree(in);
 +
 +	return err;
 +}
 +
 +void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv,
 +				struct ttc_params *ttc_params)
 +{
 +	ttc_params->any_tt_tirn = priv->direct_tir[0].tirn;
 +	ttc_params->inner_ttc = &priv->fs.inner_ttc;
 +}
 +
 +static void mlx5e_set_inner_ttc_ft_params(struct ttc_params *ttc_params)
 +{
 +	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
 +
 +	ft_attr->max_fte = MLX5E_INNER_TTC_TABLE_SIZE;
 +	ft_attr->level = MLX5E_INNER_TTC_FT_LEVEL;
 +	ft_attr->prio = MLX5E_NIC_PRIO;
 +}
 +
 +void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params)
 +
 +{
 +	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
 +
 +	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
  	ft_attr->level = MLX5E_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_NIC_PRIO;
 +}
  
 -	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
 -		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 -		ttc_params->dests[tt].tir_num =
 -			tt == MLX5_TT_ANY ?
 -				mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0) :
 -				mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
 +static int mlx5e_create_inner_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
 +					struct mlx5e_ttc_table *ttc)
 +{
 +	struct mlx5e_flow_table *ft = &ttc->ft;
 +	int err;
 +
 +	ft->t = mlx5_create_flow_table(priv->fs.ns, &params->ft_attr);
 +	if (IS_ERR(ft->t)) {
 +		err = PTR_ERR(ft->t);
 +		ft->t = NULL;
 +		return err;
  	}
  
 -	ttc_params->inner_ttc = tunnel;
 -	if (!tunnel || !mlx5_tunnel_inner_ft_supported(priv->mdev))
 -		return;
 +	err = mlx5e_create_inner_ttc_table_groups(ttc);
 +	if (err)
 +		goto err;
  
++<<<<<<< HEAD
 +	err = mlx5e_generate_inner_ttc_table_rules(priv, params, ttc);
 +	if (err)
 +		goto err;
 +
 +	return 0;
 +
 +err:
 +	mlx5e_destroy_flow_table(ft);
 +	return err;
 +}
 +
 +static void mlx5e_destroy_inner_ttc_table(struct mlx5e_priv *priv,
 +					  struct mlx5e_ttc_table *ttc)
 +{
 +	mlx5e_cleanup_ttc_rules(ttc);
 +	mlx5e_destroy_flow_table(&ttc->ft);
 +}
 +
 +void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv,
 +			     struct mlx5e_ttc_table *ttc)
 +{
 +	mlx5e_cleanup_ttc_rules(ttc);
 +	mlx5e_destroy_flow_table(&ttc->ft);
 +}
 +
 +int mlx5e_create_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
 +			   struct mlx5e_ttc_table *ttc)
 +{
 +	bool match_ipv_outer = MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, ft_field_support.outer_ip_version);
 +	struct mlx5e_flow_table *ft = &ttc->ft;
 +	int err;
 +
 +	ft->t = mlx5_create_flow_table(priv->fs.ns, &params->ft_attr);
 +	if (IS_ERR(ft->t)) {
 +		err = PTR_ERR(ft->t);
 +		ft->t = NULL;
 +		return err;
++=======
+ 	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
+ 		ttc_params->tunnel_dests[tt].type =
+ 			MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		ttc_params->tunnel_dests[tt].ft =
+ 			mlx5_get_ttc_flow_table(priv->fs.inner_ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	}
 +
 +	err = mlx5e_create_ttc_table_groups(ttc, match_ipv_outer);
 +	if (err)
 +		goto err;
 +
 +	err = mlx5e_generate_ttc_table_rules(priv, params, ttc);
 +	if (err)
 +		goto err;
 +
 +	return 0;
 +err:
 +	mlx5e_destroy_flow_table(ft);
 +	return err;
 +}
 +
 +int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
 +		       struct mlx5_flow_destination *new_dest)
 +{
 +	return mlx5_modify_rule_destination(priv->fs.ttc.rules[type].rule, new_dest, NULL);
 +}
 +
 +struct mlx5_flow_destination
 +mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
 +{
 +	struct mlx5_flow_destination *dest = &priv->fs.ttc.rules[type].default_dest;
 +
 +	WARN_ONCE(dest->type != MLX5_FLOW_DESTINATION_TYPE_TIR,
 +		  "TTC[%d] default dest is not setup yet", type);
 +
 +	return *dest;
 +}
 +
 +int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
 +{
 +	struct mlx5_flow_destination dest = mlx5e_ttc_get_default_dest(priv, type);
 +
 +	return mlx5e_ttc_fwd_dest(priv, type, &dest);
  }
  
  static void mlx5e_del_l2_flow_rule(struct mlx5e_priv *priv,
@@@ -1443,7 -939,7 +1455,11 @@@ static int mlx5e_add_l2_flow_rule(struc
  			       outer_headers.dmac_47_16);
  
  	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
++<<<<<<< HEAD
 +	dest.ft = priv->fs.ttc.ft.t;
++=======
+ 	dest.ft = mlx5_get_ttc_flow_table(priv->fs.ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	switch (type) {
  	case MLX5E_FULLMATCH:
@@@ -1729,13 -1231,50 +1745,53 @@@ err_destroy_vlan_table
  static void mlx5e_destroy_vlan_table(struct mlx5e_priv *priv)
  {
  	mlx5e_del_vlan_rules(priv);
 -	mlx5e_destroy_flow_table(&priv->fs.vlan->ft);
 -	kvfree(priv->fs.vlan);
 +	mlx5e_destroy_flow_table(&priv->fs.vlan.ft);
  }
  
- int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
+ static void mlx5e_destroy_inner_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	if (!mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		return;
+ 	mlx5_destroy_ttc_table(priv->fs.inner_ttc);
+ }
+ 
+ void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	mlx5_destroy_ttc_table(priv->fs.ttc);
+ }
+ 
+ static int mlx5e_create_inner_ttc_table(struct mlx5e_priv *priv)
  {
  	struct ttc_params ttc_params = {};
++<<<<<<< HEAD
 +	int tt, err;
++=======
+ 
+ 	if (!mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		return 0;
+ 
+ 	mlx5e_set_inner_ttc_params(priv, &ttc_params);
+ 	priv->fs.inner_ttc = mlx5_create_ttc_table(priv->mdev, &ttc_params);
+ 	if (IS_ERR(priv->fs.inner_ttc))
+ 		return PTR_ERR(priv->fs.inner_ttc);
+ 	return 0;
+ }
+ 
+ int mlx5e_create_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	struct ttc_params ttc_params = {};
+ 
+ 	mlx5e_set_ttc_params(priv, &ttc_params, true);
+ 	priv->fs.ttc = mlx5_create_ttc_table(priv->mdev, &ttc_params);
+ 	if (IS_ERR(priv->fs.ttc))
+ 		return PTR_ERR(priv->fs.ttc);
+ 	return 0;
+ }
+ 
+ int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
+ {
+ 	int err;
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	priv->fs.ns = mlx5_get_flow_namespace(priv->mdev,
  					       MLX5_FLOW_NAMESPACE_KERNEL);
@@@ -1750,26 -1289,15 +1806,38 @@@
  		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
  	}
  
++<<<<<<< HEAD
 +	mlx5e_set_ttc_basic_params(priv, &ttc_params);
 +
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev)) {
 +		mlx5e_set_inner_ttc_ft_params(&ttc_params);
 +		for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +			ttc_params.indir_tirn[tt] = priv->inner_indir_tir[tt].tirn;
 +
 +		err = mlx5e_create_inner_ttc_table(priv, &ttc_params, &priv->fs.inner_ttc);
 +		if (err) {
 +			netdev_err(priv->netdev, "Failed to create inner ttc table, err=%d\n",
 +				   err);
 +			goto err_destroy_arfs_tables;
 +		}
 +	}
 +
 +	mlx5e_set_ttc_ft_params(&ttc_params);
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
 +
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
++=======
+ 	err = mlx5e_create_inner_ttc_table(priv);
+ 	if (err) {
+ 		netdev_err(priv->netdev,
+ 			   "Failed to create inner ttc table, err=%d\n",
+ 			   err);
+ 		goto err_destroy_arfs_tables;
+ 	}
+ 
+ 	err = mlx5e_create_ttc_table(priv);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	if (err) {
  		netdev_err(priv->netdev, "Failed to create ttc table, err=%d\n",
  			   err);
@@@ -1797,10 -1329,11 +1865,16 @@@
  err_destroy_l2_table:
  	mlx5e_destroy_l2_table(priv);
  err_destroy_ttc_table:
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +err_destroy_inner_ttc_table:
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		mlx5e_destroy_inner_ttc_table(priv, &priv->fs.inner_ttc);
++=======
+ 	mlx5e_destroy_ttc_table(priv);
+ err_destroy_inner_ttc_table:
+ 	mlx5e_destroy_inner_ttc_table(priv);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  err_destroy_arfs_tables:
  	mlx5e_arfs_destroy_tables(priv);
  
@@@ -1809,11 -1342,11 +1883,16 @@@
  
  void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv)
  {
 -	mlx5e_ptp_free_rx_fs(priv);
  	mlx5e_destroy_vlan_table(priv);
  	mlx5e_destroy_l2_table(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		mlx5e_destroy_inner_ttc_table(priv, &priv->fs.inner_ttc);
++=======
+ 	mlx5e_destroy_ttc_table(priv);
+ 	mlx5e_destroy_inner_ttc_table(priv);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	mlx5e_arfs_destroy_tables(priv);
  	mlx5e_ethtool_cleanup_steering(priv);
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 98da6dcc9ee9,1e520640f7e0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -664,12 -660,11 +664,20 @@@ static int mlx5e_create_rep_ttc_table(s
  		/* To give uplik rep TTC a lower level for chaining from root ft */
  		ttc_params.ft_attr.level = MLX5E_TTC_FT_LEVEL + 1;
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
 +
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
 +	if (err) {
 +		netdev_err(priv->netdev, "Failed to create rep ttc table, err=%d\n", err);
++=======
+ 	priv->fs.ttc = mlx5_create_ttc_table(priv->mdev, &ttc_params);
+ 	if (IS_ERR(priv->fs.ttc)) {
+ 		err = PTR_ERR(priv->fs.ttc);
+ 		netdev_err(priv->netdev, "Failed to create rep ttc table, err=%d\n",
+ 			   err);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		return err;
  	}
  	return 0;
@@@ -687,7 -682,7 +695,11 @@@ static int mlx5e_create_rep_root_ft(str
  		/* non uplik reps will skip any bypass tables and go directly to
  		 * their own ttc
  		 */
++<<<<<<< HEAD
 +		rpriv->root_ft = priv->fs.ttc.ft.t;
++=======
+ 		rpriv->root_ft = mlx5_get_ttc_flow_table(priv->fs.ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		return 0;
  	}
  
@@@ -809,17 -796,13 +821,23 @@@ static int mlx5e_init_rep_rx(struct mlx
  err_destroy_root_ft:
  	mlx5e_destroy_rep_root_ft(priv);
  err_destroy_ttc_table:
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +err_destroy_direct_tirs:
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_tirs:
 +	mlx5e_destroy_indirect_tirs(priv);
 +err_destroy_direct_rqts:
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_rqts:
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5_destroy_ttc_table(priv->fs.ttc);
+ err_destroy_rx_res:
+ 	mlx5e_rx_res_destroy(priv->rx_res);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
 -	mlx5e_rx_res_free(priv->rx_res);
 -	priv->rx_res = NULL;
  	return err;
  }
  
@@@ -830,12 -811,11 +848,17 @@@ static void mlx5e_cleanup_rep_rx(struc
  	mlx5e_ethtool_cleanup_steering(priv);
  	rep_vport_rx_rule_destroy(priv);
  	mlx5e_destroy_rep_root_ft(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_indirect_tirs(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5_destroy_ttc_table(priv->fs.ttc);
+ 	mlx5e_rx_res_destroy(priv->rx_res);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	mlx5e_close_drop_rq(&priv->drop_rq);
 -	mlx5e_rx_res_free(priv->rx_res);
 -	priv->rx_res = NULL;
  }
  
  static int mlx5e_init_ul_rep_rx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,1a606dc8bed5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -346,8 -344,8 +346,13 @@@ struct mlx5e_hairpin 
  
  	int num_channels;
  	struct mlx5e_rqt indir_rqt;
++<<<<<<< HEAD
 +	u32 indir_tirn[MLX5E_NUM_INDIR_TIRS];
 +	struct mlx5e_ttc_table ttc;
++=======
+ 	struct mlx5e_tir indir_tir[MLX5E_NUM_INDIR_TIRS];
+ 	struct mlx5_ttc_table *ttc;
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  };
  
  struct mlx5e_hairpin_entry {
@@@ -647,12 -624,15 +652,24 @@@ static int mlx5e_hairpin_rss_init(struc
  		goto err_create_indirect_tirs;
  
  	mlx5e_hairpin_set_ttc_params(hp, &ttc_params);
++<<<<<<< HEAD
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &hp->ttc);
 +	if (err)
++=======
+ 	hp->ttc = mlx5_create_ttc_table(priv->mdev, &ttc_params);
+ 	if (IS_ERR(hp->ttc)) {
+ 		err = PTR_ERR(hp->ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  		goto err_create_ttc_table;
+ 	}
  
  	netdev_dbg(priv->netdev, "add hairpin: using %d channels rss ttc table id %x\n",
++<<<<<<< HEAD
 +		   hp->num_channels, hp->ttc.ft.t->id);
++=======
+ 		   hp->num_channels,
+ 		   mlx5_get_ttc_flow_table(priv->fs.ttc)->id);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	return 0;
  
@@@ -666,11 -646,9 +683,15 @@@ err_create_indirect_tirs
  
  static void mlx5e_hairpin_rss_cleanup(struct mlx5e_hairpin *hp)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = hp->func_priv;
 +
 +	mlx5e_destroy_ttc_table(priv, &hp->ttc);
++=======
+ 	mlx5_destroy_ttc_table(hp->ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	mlx5e_hairpin_destroy_indirect_tirs(hp);
 -	mlx5e_rqt_destroy(&hp->indir_rqt);
 +	mlx5e_destroy_rqt(priv, &hp->indir_rqt);
  }
  
  static struct mlx5e_hairpin *
@@@ -912,9 -890,10 +933,14 @@@ static int mlx5e_hairpin_flow_add(struc
  attach_flow:
  	if (hpe->hp->num_channels > 1) {
  		flow_flag_set(flow, HAIRPIN_RSS);
++<<<<<<< HEAD
 +		flow->attr->nic_attr->hairpin_ft = hpe->hp->ttc.ft.t;
++=======
+ 		flow->attr->nic_attr->hairpin_ft =
+ 			mlx5_get_ttc_flow_table(hpe->hp->ttc);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	} else {
 -		flow->attr->nic_attr->hairpin_tirn = mlx5e_tir_get_tirn(&hpe->hp->direct_tir);
 +		flow->attr->nic_attr->hairpin_tirn = hpe->hp->tirn;
  	}
  
  	flow->hpe = hpe;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index f3988eec3041,67571e5040d6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -320,8 -314,7 +320,12 @@@ static void mlx5i_cleanup_tx(struct mlx
  
  static int mlx5i_create_flow_steering(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	struct ttc_params ttc_params = {};
 +	int tt, err;
++=======
+ 	int err;
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  
  	priv->fs.ns = mlx5_get_flow_namespace(priv->mdev,
  					       MLX5_FLOW_NAMESPACE_KERNEL);
@@@ -336,12 -329,7 +340,16 @@@
  		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
  	}
  
++<<<<<<< HEAD
 +	mlx5e_set_ttc_basic_params(priv, &ttc_params);
 +	mlx5e_set_ttc_ft_params(&ttc_params);
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
 +
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
++=======
+ 	err = mlx5e_create_ttc_table(priv);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	if (err) {
  		netdev_err(priv->netdev, "Failed to create ttc table, err=%d\n",
  			   err);
@@@ -358,7 -346,7 +366,11 @@@ err_destroy_arfs_tables
  
  static void mlx5i_destroy_flow_steering(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
++=======
+ 	mlx5e_destroy_ttc_table(priv);
++>>>>>>> f4b45940e9b9 (net/mlx5: Embed mlx5_ttc_table)
  	mlx5e_arfs_destroy_tables(priv);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lib/fs_ttc.h
