vsock/virtio: initialize the_virtio_vsock before using VQs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-531.el8
commit-author Alexandru Matei <alexandru.matei@uipath.com>
commit 53b08c4985158430fd6d035fb49443bada535210
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-531.el8/53b08c49.failed

Once VQs are filled with empty buffers and we kick the host, it can send
connection requests. If the_virtio_vsock is not initialized before,
replies are silently dropped and do not reach the host.

virtio_transport_send_pkt() can queue packets once the_virtio_vsock is
set, but they won't be processed until vsock->tx_run is set to true. We
queue vsock->send_pkt_work when initialization finishes to send those
packets queued earlier.

Fixes: 0deab087b16a ("vsock/virtio: use RCU to avoid use-after-free on the_virtio_vsock")
	Signed-off-by: Alexandru Matei <alexandru.matei@uipath.com>
	Reviewed-by: Stefano Garzarella <sgarzare@redhat.com>
Link: https://lore.kernel.org/r/20231024191742.14259-1-alexandru.matei@uipath.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 53b08c4985158430fd6d035fb49443bada535210)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/vmw_vsock/virtio_transport.c
diff --cc net/vmw_vsock/virtio_transport.c
index 9dfae792bd4f,b80bf681327b..000000000000
--- a/net/vmw_vsock/virtio_transport.c
+++ b/net/vmw_vsock/virtio_transport.c
@@@ -550,11 -544,95 +550,103 @@@ static int virtio_vsock_probe(struct vi
  		virtio_vsock_tx_done,
  		virtio_vsock_event_done,
  	};
++<<<<<<< HEAD
 +	static const char * const names[] = {
 +		"rx",
 +		"tx",
 +		"event",
 +	};
++=======
+ 	int ret;
+ 
+ 	ret = virtio_find_vqs(vdev, VSOCK_VQ_MAX, vsock->vqs, callbacks, names,
+ 			      NULL);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	virtio_vsock_update_guest_cid(vsock);
+ 
+ 	virtio_device_ready(vdev);
+ 
+ 	return 0;
+ }
+ 
+ static void virtio_vsock_vqs_start(struct virtio_vsock *vsock)
+ {
+ 	mutex_lock(&vsock->tx_lock);
+ 	vsock->tx_run = true;
+ 	mutex_unlock(&vsock->tx_lock);
+ 
+ 	mutex_lock(&vsock->rx_lock);
+ 	virtio_vsock_rx_fill(vsock);
+ 	vsock->rx_run = true;
+ 	mutex_unlock(&vsock->rx_lock);
+ 
+ 	mutex_lock(&vsock->event_lock);
+ 	virtio_vsock_event_fill(vsock);
+ 	vsock->event_run = true;
+ 	mutex_unlock(&vsock->event_lock);
+ 
+ 	/* virtio_transport_send_pkt() can queue packets once
+ 	 * the_virtio_vsock is set, but they won't be processed until
+ 	 * vsock->tx_run is set to true. We queue vsock->send_pkt_work
+ 	 * when initialization finishes to send those packets queued
+ 	 * earlier.
+ 	 * We don't need to queue the other workers (rx, event) because
+ 	 * as long as we don't fill the queues with empty buffers, the
+ 	 * host can't send us any notification.
+ 	 */
+ 	queue_work(virtio_vsock_workqueue, &vsock->send_pkt_work);
+ }
+ 
+ static void virtio_vsock_vqs_del(struct virtio_vsock *vsock)
+ {
+ 	struct virtio_device *vdev = vsock->vdev;
+ 	struct sk_buff *skb;
+ 
+ 	/* Reset all connected sockets when the VQs disappear */
+ 	vsock_for_each_connected_socket(&virtio_transport.transport,
+ 					virtio_vsock_reset_sock);
+ 
+ 	/* Stop all work handlers to make sure no one is accessing the device,
+ 	 * so we can safely call virtio_reset_device().
+ 	 */
+ 	mutex_lock(&vsock->rx_lock);
+ 	vsock->rx_run = false;
+ 	mutex_unlock(&vsock->rx_lock);
+ 
+ 	mutex_lock(&vsock->tx_lock);
+ 	vsock->tx_run = false;
+ 	mutex_unlock(&vsock->tx_lock);
+ 
+ 	mutex_lock(&vsock->event_lock);
+ 	vsock->event_run = false;
+ 	mutex_unlock(&vsock->event_lock);
+ 
+ 	/* Flush all device writes and interrupts, device will not use any
+ 	 * more buffers.
+ 	 */
+ 	virtio_reset_device(vdev);
+ 
+ 	mutex_lock(&vsock->rx_lock);
+ 	while ((skb = virtqueue_detach_unused_buf(vsock->vqs[VSOCK_VQ_RX])))
+ 		kfree_skb(skb);
+ 	mutex_unlock(&vsock->rx_lock);
+ 
+ 	mutex_lock(&vsock->tx_lock);
+ 	while ((skb = virtqueue_detach_unused_buf(vsock->vqs[VSOCK_VQ_TX])))
+ 		kfree_skb(skb);
+ 	mutex_unlock(&vsock->tx_lock);
+ 
+ 	virtio_vsock_skb_queue_purge(&vsock->send_pkt_queue);
+ 
+ 	/* Delete virtqueues and flush outstanding callbacks if any */
+ 	vdev->config->del_vqs(vdev);
+ }
+ 
+ static int virtio_vsock_probe(struct virtio_device *vdev)
+ {
++>>>>>>> 53b08c498515 (vsock/virtio: initialize the_virtio_vsock before using VQs)
  	struct virtio_vsock *vsock = NULL;
  	int ret;
  
@@@ -599,27 -668,20 +691,28 @@@
  	INIT_WORK(&vsock->event_work, virtio_transport_event_work);
  	INIT_WORK(&vsock->send_pkt_work, virtio_transport_send_pkt_work);
  
 -	if (virtio_has_feature(vdev, VIRTIO_VSOCK_F_SEQPACKET))
 -		vsock->seqpacket_allow = true;
 -
  	vdev->priv = vsock;
  
 -	ret = virtio_vsock_vqs_init(vsock);
 -	if (ret < 0)
 -		goto out;
 +	virtio_device_ready(vdev);
 +
 +	mutex_lock(&vsock->tx_lock);
 +	vsock->tx_run = true;
 +	mutex_unlock(&vsock->tx_lock);
 +
 +	mutex_lock(&vsock->rx_lock);
 +	virtio_vsock_rx_fill(vsock);
 +	vsock->rx_run = true;
 +	mutex_unlock(&vsock->rx_lock);
 +
 +	mutex_lock(&vsock->event_lock);
 +	virtio_vsock_event_fill(vsock);
 +	vsock->event_run = true;
 +	mutex_unlock(&vsock->event_lock);
  
  	rcu_assign_pointer(the_virtio_vsock, vsock);
+ 	virtio_vsock_vqs_start(vsock);
  
  	mutex_unlock(&the_virtio_vsock_mutex);
 -
  	return 0;
  
  out:
@@@ -698,6 -715,50 +791,53 @@@ static void virtio_vsock_remove(struct 
  	kfree(vsock);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ static int virtio_vsock_freeze(struct virtio_device *vdev)
+ {
+ 	struct virtio_vsock *vsock = vdev->priv;
+ 
+ 	mutex_lock(&the_virtio_vsock_mutex);
+ 
+ 	rcu_assign_pointer(the_virtio_vsock, NULL);
+ 	synchronize_rcu();
+ 
+ 	virtio_vsock_vqs_del(vsock);
+ 
+ 	mutex_unlock(&the_virtio_vsock_mutex);
+ 
+ 	return 0;
+ }
+ 
+ static int virtio_vsock_restore(struct virtio_device *vdev)
+ {
+ 	struct virtio_vsock *vsock = vdev->priv;
+ 	int ret;
+ 
+ 	mutex_lock(&the_virtio_vsock_mutex);
+ 
+ 	/* Only one virtio-vsock device per guest is supported */
+ 	if (rcu_dereference_protected(the_virtio_vsock,
+ 				lockdep_is_held(&the_virtio_vsock_mutex))) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	ret = virtio_vsock_vqs_init(vsock);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	rcu_assign_pointer(the_virtio_vsock, vsock);
+ 	virtio_vsock_vqs_start(vsock);
+ 
+ out:
+ 	mutex_unlock(&the_virtio_vsock_mutex);
+ 	return ret;
+ }
+ #endif /* CONFIG_PM_SLEEP */
+ 
++>>>>>>> 53b08c498515 (vsock/virtio: initialize the_virtio_vsock before using VQs)
  static struct virtio_device_id id_table[] = {
  	{ VIRTIO_ID_VSOCK, VIRTIO_DEV_ANY_ID },
  	{ 0 },
* Unmerged path net/vmw_vsock/virtio_transport.c
