vsock/virtio: factor our the code to initialize and delete VQs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-531.el8
commit-author Stefano Garzarella <sgarzare@redhat.com>
commit a103209886264a3289f7e53e7ed389d0391fb23f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-531.el8/a1032098.failed

Add virtio_vsock_vqs_init() and virtio_vsock_vqs_del() with the code
that was in virtio_vsock_probe() and virtio_vsock_remove to initialize
and delete VQs.

These new functions will be used in the next commit to support device
suspend/resume

	Signed-off-by: Stefano Garzarella <sgarzare@redhat.com>
	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit a103209886264a3289f7e53e7ed389d0391fb23f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/vmw_vsock/virtio_transport.c
diff --cc net/vmw_vsock/virtio_transport.c
index 9dfae792bd4f,31f4f6f40614..000000000000
--- a/net/vmw_vsock/virtio_transport.c
+++ b/net/vmw_vsock/virtio_transport.c
@@@ -585,22 -588,6 +565,25 @@@ static int virtio_vsock_vqs_init(struc
  
  	virtio_vsock_update_guest_cid(vsock);
  
++<<<<<<< HEAD
 +	vsock->rx_buf_nr = 0;
 +	vsock->rx_buf_max_nr = 0;
 +	atomic_set(&vsock->queued_replies, 0);
 +
 +	mutex_init(&vsock->tx_lock);
 +	mutex_init(&vsock->rx_lock);
 +	mutex_init(&vsock->event_lock);
 +	spin_lock_init(&vsock->send_pkt_list_lock);
 +	INIT_LIST_HEAD(&vsock->send_pkt_list);
 +	INIT_WORK(&vsock->rx_work, virtio_transport_rx_work);
 +	INIT_WORK(&vsock->tx_work, virtio_transport_tx_work);
 +	INIT_WORK(&vsock->event_work, virtio_transport_event_work);
 +	INIT_WORK(&vsock->send_pkt_work, virtio_transport_send_pkt_work);
 +
 +	vdev->priv = vsock;
 +
++=======
++>>>>>>> a10320988626 (vsock/virtio: factor our the code to initialize and delete VQs)
  	virtio_device_ready(vdev);
  
  	mutex_lock(&vsock->tx_lock);
@@@ -617,29 -604,15 +600,21 @@@
  	vsock->event_run = true;
  	mutex_unlock(&vsock->event_lock);
  
++<<<<<<< HEAD
 +	rcu_assign_pointer(the_virtio_vsock, vsock);
 +
 +	mutex_unlock(&the_virtio_vsock_mutex);
++=======
++>>>>>>> a10320988626 (vsock/virtio: factor our the code to initialize and delete VQs)
  	return 0;
- 
- out:
- 	kfree(vsock);
- 	mutex_unlock(&the_virtio_vsock_mutex);
- 	return ret;
  }
  
- static void virtio_vsock_remove(struct virtio_device *vdev)
+ static void virtio_vsock_vqs_del(struct virtio_vsock *vsock)
  {
- 	struct virtio_vsock *vsock = vdev->priv;
+ 	struct virtio_device *vdev = vsock->vdev;
  	struct virtio_vsock_pkt *pkt;
  
- 	mutex_lock(&the_virtio_vsock_mutex);
- 
- 	vdev->priv = NULL;
- 	rcu_assign_pointer(the_virtio_vsock, NULL);
- 	synchronize_rcu();
- 
- 	/* Reset all connected sockets when the device disappear */
+ 	/* Reset all connected sockets when the VQs disappear */
  	vsock_for_each_connected_socket(&virtio_transport.transport,
  					virtio_vsock_reset_sock);
  
* Unmerged path net/vmw_vsock/virtio_transport.c
