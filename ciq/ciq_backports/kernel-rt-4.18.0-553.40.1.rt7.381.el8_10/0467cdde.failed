s390/pci: Sort PCI functions prior to creating virtual busses

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.40.1.rt7.381.el8_10
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 0467cdde8c4320bbfdb31a8cff1277b202f677fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.40.1.rt7.381.el8_10/0467cdde.failed

Instead of relying on the observed but not architected firmware behavior
that PCI functions from the same card are listed in ascending RID order
in clp_list_pci() ensure this by sorting. To allow for sorting separate
the initial clp_list_pci() and creation of the virtual PCI busses.

Note that fundamentally in our per-PCI function hotplug design non RID
order of discovery is still possible. For example when the two PFs of
a two port NIC are hotplugged after initial boot and in descending RID
order. In this case the virtual PCI bus would be created by the second
PF using that PF's UID as domain number instead of that of the first PF.
Thus the domain number would then change from the UID of the second PF
to that of the first PF on reboot but there is really nothing we can do
about that since changing domain numbers at runtime seems even worse.
This only impacts the domain number as the RIDs are consistent and thus
even with just the second PF visible it will show up in the correct
position on the virtual bus.

	Reviewed-by: Gerd Bayer <gbayer@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 0467cdde8c4320bbfdb31a8cff1277b202f677fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
diff --cc arch/s390/pci/pci.c
index 162ca752cec9,b7efa96776ea..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -27,6 -27,9 +27,12 @@@
  #include <linux/seq_file.h>
  #include <linux/jump_label.h>
  #include <linux/pci.h>
++<<<<<<< HEAD
++=======
+ #include <linux/printk.h>
+ #include <linux/lockdep.h>
+ #include <linux/list_sort.h>
++>>>>>>> 0467cdde8c43 (s390/pci: Sort PCI functions prior to creating virtual busses)
  
  #include <asm/isc.h>
  #include <asm/airq.h>
@@@ -885,9 -801,23 +890,22 @@@ struct zpci_dev *zpci_create_device(u3
  	zdev->state =  state;
  
  	kref_init(&zdev->kref);
 -	mutex_init(&zdev->state_lock);
 -	mutex_init(&zdev->fmb_lock);
 +	mutex_init(&zdev->lock);
  	mutex_init(&zdev->kzdev_lock);
  
+ 	return zdev;
+ 
+ error:
+ 	zpci_dbg(0, "crt fid:%x, rc:%d\n", fid, rc);
+ 	kfree(zdev);
+ 	return ERR_PTR(rc);
+ }
+ 
+ int zpci_add_device(struct zpci_dev *zdev)
+ {
+ 	int rc;
+ 
+ 	zpci_dbg(1, "add fid:%x, fh:%x, c:%d\n", zdev->fid, zdev->fh, zdev->state);
  	rc = zpci_init_iommu(zdev);
  	if (rc)
  		goto error;
@@@ -1197,14 -1165,9 +1256,17 @@@ static int __init pci_base_init(void
  	if (rc)
  		goto out_irq;
  
++<<<<<<< HEAD
 +	rc = zpci_dma_init();
 +	if (rc)
 +		goto out_dma;
 +
 +	rc = clp_scan_pci_devices();
++=======
+ 	rc = zpci_scan_devices();
++>>>>>>> 0467cdde8c43 (s390/pci: Sort PCI functions prior to creating virtual busses)
  	if (rc)
  		goto out_find;
- 	zpci_bus_scan_busses();
  
  	s390_pci_initialized = 1;
  	return 0;
diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h
index 15948089980a..25dae71f4671 100644
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -129,6 +129,7 @@ struct zpci_dev {
 	u16		vfn;		/* virtual function number */
 	u16		pchid;		/* physical channel ID */
 	u16		maxstbl;	/* Maximum store block size */
+	u16		rid;		/* RID as supplied by firmware */
 	u8		pfgid;		/* function group ID */
 	u8		pft;		/* pci function type */
 	u8		port;
@@ -215,12 +216,14 @@ extern struct airq_iv *zpci_aif_sbv;
 ----------------------------------------------------------------------------- */
 /* Base stuff */
 struct zpci_dev *zpci_create_device(u32 fid, u32 fh, enum zpci_state state);
+int zpci_add_device(struct zpci_dev *zdev);
 int zpci_enable_device(struct zpci_dev *);
 int zpci_disable_device(struct zpci_dev *);
 int zpci_scan_configured_device(struct zpci_dev *zdev, u32 fh);
 int zpci_deconfigure_device(struct zpci_dev *zdev);
 void zpci_device_reserved(struct zpci_dev *zdev);
 bool zpci_is_device_configured(struct zpci_dev *zdev);
+int zpci_scan_devices(void);
 
 int zpci_hot_reset_device(struct zpci_dev *zdev);
 int zpci_register_ioat(struct zpci_dev *, u8, u64, u64, u64, u8 *);
@@ -231,7 +234,7 @@ void zpci_update_fh(struct zpci_dev *zdev, u32 fh);
 /* CLP */
 int rhel8_clp_rescan_pci_devices_simple(void);
 int clp_setup_writeback_mio(void);
-int clp_scan_pci_devices(void);
+int clp_scan_pci_devices(struct list_head *scan_list);
 int clp_query_pci_fn(struct zpci_dev *zdev);
 int clp_enable_fh(struct zpci_dev *zdev, u32 *fh, u8 nr_dma_as);
 int clp_disable_fh(struct zpci_dev *zdev, u32 *fh);
* Unmerged path arch/s390/pci/pci.c
diff --git a/arch/s390/pci/pci_clp.c b/arch/s390/pci/pci_clp.c
index 34759316747b..0e3a6b839ce9 100644
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@ -163,8 +163,10 @@ static int clp_store_query_pci_fn(struct zpci_dev *zdev,
 	zdev->port = response->port;
 	zdev->uid = response->uid;
 	zdev->fmb_length = sizeof(u32) * response->fmb_len;
-	zdev->rid_available = response->rid_avail;
 	zdev->is_physfn = response->is_physfn;
+	zdev->rid_available = response->rid_avail;
+	if (zdev->rid_available)
+		zdev->rid = response->rid;
 	if (!s390_pci_no_rid && zdev->rid_available)
 		zdev->devfn = response->rid & ZPCI_RID_MASK_DEVFN;
 
@@ -406,6 +408,7 @@ static int clp_find_pci(struct clp_req_rsp_list_pci *rrb, u32 fid,
 
 static void __clp_add(struct clp_fh_list_entry *entry, void *data)
 {
+	struct list_head *scan_list = data;
 	struct zpci_dev *zdev;
 
 	if (!entry->vendor_id)
@@ -416,10 +419,11 @@ static void __clp_add(struct clp_fh_list_entry *entry, void *data)
 		zpci_zdev_put(zdev);
 		return;
 	}
-	zpci_create_device(entry->fid, entry->fh, entry->config_state);
+	zdev = zpci_create_device(entry->fid, entry->fh, entry->config_state);
+	list_add_tail(&zdev->entry, scan_list);
 }
 
-int clp_scan_pci_devices(void)
+int clp_scan_pci_devices(struct list_head *scan_list)
 {
 	struct clp_req_rsp_list_pci *rrb;
 	int rc;
@@ -428,7 +432,7 @@ int clp_scan_pci_devices(void)
 	if (!rrb)
 		return -ENOMEM;
 
-	rc = clp_list_pci(rrb, NULL, __clp_add);
+	rc = clp_list_pci(rrb, scan_list, __clp_add);
 
 	clp_free_block(rrb);
 	return rc;
diff --git a/arch/s390/pci/pci_event.c b/arch/s390/pci/pci_event.c
index b3961f1016ea..74edb6fb6582 100644
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -328,6 +328,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 			zdev = zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_CONFIGURED);
 			if (IS_ERR(zdev))
 				break;
+			zpci_add_device(zdev);
 		} else {
 			/* the configuration request may be stale */
 			if (zdev->state != ZPCI_FN_STATE_STANDBY)
@@ -337,10 +338,14 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 		zpci_scan_configured_device(zdev, ccdf->fh);
 		break;
 	case 0x0302: /* Reserved -> Standby */
-		if (!zdev)
-			zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_STANDBY);
-		else
+		if (!zdev) {
+			zdev = zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_STANDBY);
+			if (IS_ERR(zdev))
+				break;
+			zpci_add_device(zdev);
+		} else {
 			zpci_update_fh(zdev, ccdf->fh);
+		}
 		break;
 	case 0x0303: /* Deconfiguration requested */
 		if (zdev) {
@@ -369,7 +374,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 		break;
 	case 0x0306: /* 0x308 or 0x302 for multiple devices */
 		zpci_remove_reserved_devices();
-		clp_scan_pci_devices();
+		zpci_scan_devices();
 		break;
 	case 0x0308: /* Standby -> Reserved */
 		if (!zdev)
