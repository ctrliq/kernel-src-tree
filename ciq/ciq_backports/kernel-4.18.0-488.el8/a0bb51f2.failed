x86/xen: Split HVM vector callback setup and interrupt gate allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-488.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit a0bb51f2638e0810c347024679239fd10a8f7990
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-488.el8/a0bb51f2.failed

As a preparatory change for making alloc_intr_gate() __init split
xen_callback_vector() into callback vector setup via hypercall
(xen_setup_callback_vector()) and interrupt gate allocation
(xen_alloc_callback_vector()).

xen_setup_callback_vector() is being called twice: on init and upon
system resume from xen_hvm_post_suspend(). alloc_intr_gate() only
needs to be called once.

	Suggested-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/20200428093824.1451532-2-vkuznets@redhat.com


(cherry picked from commit a0bb51f2638e0810c347024679239fd10a8f7990)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/xen/events/events_base.c
diff --cc drivers/xen/events/events_base.c
index 0fec7600660b,eb35c3cda9a6..000000000000
--- a/drivers/xen/events/events_base.c
+++ b/drivers/xen/events/events_base.c
@@@ -1644,19 -1645,24 +1643,30 @@@ void xen_setup_callback_vector(void
  
  	if (xen_have_vector_callback) {
  		callback_via = HVM_CALLBACK_VECTOR(HYPERVISOR_CALLBACK_VECTOR);
- 		rc = xen_set_callback_via(callback_via);
- 		if (rc) {
+ 		if (xen_set_callback_via(callback_via)) {
  			pr_err("Request for Xen HVM callback vector failed\n");
  			xen_have_vector_callback = 0;
- 			return;
  		}
++<<<<<<< HEAD
 +		pr_info("Xen HVM callback vector for event delivery is enabled\n");
 +		alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR,
 +				xen_hvm_callback_vector);
++=======
++>>>>>>> a0bb51f2638e (x86/xen: Split HVM vector callback setup and interrupt gate allocation)
  	}
  }
+ 
+ static __init void xen_alloc_callback_vector(void)
+ {
+ 	if (!xen_have_vector_callback)
+ 		return;
+ 
+ 	pr_info("Xen HVM callback vector for event delivery is enabled\n");
+ 	alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, xen_hvm_callback_vector);
+ }
  #else
- void xen_callback_vector(void) {}
+ void xen_setup_callback_vector(void) {}
+ static inline void xen_alloc_callback_vector(void) {}
  #endif
  
  #undef MODULE_PARAM_PREFIX
diff --git a/arch/x86/xen/suspend_hvm.c b/arch/x86/xen/suspend_hvm.c
index e666b614cf6d..5152afe16876 100644
--- a/arch/x86/xen/suspend_hvm.c
+++ b/arch/x86/xen/suspend_hvm.c
@@ -13,6 +13,6 @@ void xen_hvm_post_suspend(int suspend_cancelled)
 		xen_hvm_init_shared_info();
 		xen_vcpu_restore();
 	}
-	xen_callback_vector();
+	xen_setup_callback_vector();
 	xen_unplug_emulated_devices();
 }
diff --git a/arch/x86/xen/xen-ops.h b/arch/x86/xen/xen-ops.h
index 3b34745d0a52..cfd03838e494 100644
--- a/arch/x86/xen/xen-ops.h
+++ b/arch/x86/xen/xen-ops.h
@@ -57,7 +57,7 @@ void xen_enable_sysenter(void);
 void xen_enable_syscall(void);
 void xen_vcpu_restore(void);
 
-void xen_callback_vector(void);
+void xen_setup_callback_vector(void);
 void xen_hvm_init_shared_info(void);
 void xen_unplug_emulated_devices(void);
 
* Unmerged path drivers/xen/events/events_base.c
