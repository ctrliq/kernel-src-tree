tools/power turbostat: Expand probe_intel_uncore_frequency()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-553.5.1.el8_10
commit-author Len Brown <len.brown@intel.com>
commit bb6181fa6bc942aac3f7f2fa8e3831952a2ef118
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.5.1.el8_10/bb6181fa.failed

Print current frequency along with the current (and initial) limits

Probe and print uncore config also for machines using the new cluster API

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit bb6181fa6bc942aac3f7f2fa8e3831952a2ef118)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index d97d767214c5,bbd2e0edadfa..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -3773,423 -4493,193 +3773,474 @@@ int probe_nhm_msrs(unsigned int family
  
  	base_hz = base_ratio * bclk * 1000000;
  	has_base_hz = 1;
 -
 -	if (platform->enable_tsc_tweak)
 -		tsc_tweak = base_hz / tsc_hz;
 +	return 1;
  }
  
 -static void remove_underbar(char *s)
 +/*
 + * SLV client has support for unique MSRs:
 + *
 + * MSR_CC6_DEMOTION_POLICY_CONFIG
 + * MSR_MC6_DEMOTION_POLICY_CONFIG
 + */
 +
 +int has_slv_msrs(unsigned int family, unsigned int model)
  {
 -	char *to = s;
 +	if (!genuine_intel)
 +		return 0;
  
 -	while (*s) {
 -		if (*s != '_')
 -			*to++ = *s;
 -		s++;
 -	}
 +	if (family != 6)
 +		return 0;
  
 -	*to = 0;
 +	switch (model) {
 +	case INTEL_FAM6_ATOM_SILVERMONT:
 +	case INTEL_FAM6_ATOM_SILVERMONT_MID:
 +	case INTEL_FAM6_ATOM_AIRMONT_MID:
 +		return 1;
 +	}
 +	return 0;
  }
  
 -static void dump_turbo_ratio_info(void)
 +int is_dnv(unsigned int family, unsigned int model)
  {
 -	if (!has_turbo)
 -		return;
 -
 -	if (!platform->has_nhm_msrs)
 -		return;
 -
 -	if (platform->trl_msrs & TRL_LIMIT2)
 -		dump_turbo_ratio_limit2();
  
 -	if (platform->trl_msrs & TRL_LIMIT1)
 -		dump_turbo_ratio_limit1();
 +	if (!genuine_intel)
 +		return 0;
  
 -	if (platform->trl_msrs & TRL_BASE) {
 -		dump_turbo_ratio_limits(MSR_TURBO_RATIO_LIMIT);
 +	if (family != 6)
 +		return 0;
  
 -		if (is_hybrid)
 -			dump_turbo_ratio_limits(MSR_SECONDARY_TURBO_RATIO_LIMIT);
 +	switch (model) {
 +	case INTEL_FAM6_ATOM_GOLDMONT_D:
 +		return 1;
  	}
 +	return 0;
 +}
  
 -	if (platform->trl_msrs & TRL_ATOM)
 -		dump_atom_turbo_ratio_limits();
 +int is_bdx(unsigned int family, unsigned int model)
 +{
  
 -	if (platform->trl_msrs & TRL_KNL)
 -		dump_knl_turbo_ratio_limits();
 +	if (!genuine_intel)
 +		return 0;
  
 -	if (platform->has_config_tdp)
 -		dump_config_tdp();
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_BROADWELL_X:
 +		return 1;
 +	}
 +	return 0;
  }
  
 -static int read_sysfs_int(char *path)
 +int is_skx(unsigned int family, unsigned int model)
  {
 -	FILE *input;
 -	int retval = -1;
  
 -	input = fopen(path, "r");
 -	if (input == NULL) {
 -		if (debug)
 -			fprintf(outf, "NSFOD %s\n", path);
 -		return (-1);
 -	}
 -	if (fscanf(input, "%d", &retval) != 1)
 -		err(1, "%s: failed to read int from file", path);
 -	fclose(input);
 +	if (!genuine_intel)
 +		return 0;
  
 -	return (retval);
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_SKYLAKE_X:
 +		return 1;
 +	}
 +	return 0;
  }
  
 -static void dump_sysfs_file(char *path)
 +int is_icx(unsigned int family, unsigned int model)
  {
 -	FILE *input;
 -	char cpuidle_buf[64];
  
 -	input = fopen(path, "r");
 -	if (input == NULL) {
 -		if (debug)
 -			fprintf(outf, "NSFOD %s\n", path);
 -		return;
 -	}
 -	if (!fgets(cpuidle_buf, sizeof(cpuidle_buf), input))
 -		err(1, "%s: failed to read file", path);
 -	fclose(input);
 +	if (!genuine_intel)
 +		return 0;
  
 -	fprintf(outf, "%s: %s", strrchr(path, '/') + 1, cpuidle_buf);
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_ICELAKE_X:
 +		return 1;
 +	}
 +	return 0;
  }
  
 -static void probe_intel_uncore_frequency(void)
 +int is_spr(unsigned int family, unsigned int model)
  {
 -	int i, j;
 -	char path[256];
  
  	if (!genuine_intel)
 -		return;
 +		return 0;
  
 -	if (access("/sys/devices/system/cpu/intel_uncore_frequency/package_00_die_00/current_freq_khz", R_OK))
 -		goto probe_cluster;
 +	if (family != 6)
 +		return 0;
  
 -	BIC_PRESENT(BIC_UNCORE_MHZ);
 +	switch (model) {
 +	case INTEL_FAM6_SAPPHIRERAPIDS_X:
 +		return 1;
 +	}
 +	return 0;
 +}
  
 -	if (quiet)
 -		return;
 +int is_ehl(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
  
 -	for (i = 0; i < topo.num_packages; ++i) {
 -		for (j = 0; j < topo.num_die; ++j) {
 -			int k, l;
 -			char path_base[128];
 +	if (family != 6)
 +		return 0;
  
 -			sprintf(path_base, "/sys/devices/system/cpu/intel_uncore_frequency/package_%02d_die_%02d", i,
 -				j);
 +	switch (model) {
 +	case INTEL_FAM6_ATOM_TREMONT:
 +		return 1;
 +	}
 +	return 0;
 +}
  
 -			sprintf(path, "%s/min_freq_khz", path_base);
 -			k = read_sysfs_int(path);
 -			sprintf(path, "%s/max_freq_khz", path_base);
 -			l = read_sysfs_int(path);
 -			fprintf(outf, "Uncore Frequency package%d die%d: %d - %d MHz ", i, j, k / 1000, l / 1000);
 +int is_jvl(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
  
 -			sprintf(path, "%s/initial_min_freq_khz", path_base);
 -			k = read_sysfs_int(path);
 -			sprintf(path, "%s/initial_max_freq_khz", path_base);
 -			l = read_sysfs_int(path);
 -			fprintf(outf, "(%d - %d MHz)", k / 1000, l / 1000);
 +	if (family != 6)
 +		return 0;
  
 -			sprintf(path, "%s/current_freq_khz", path_base);
 -			k = read_sysfs_int(path);
 -			fprintf(outf, " %d MHz\n", k / 1000);
 -		}
 +	switch (model) {
 +	case INTEL_FAM6_ATOM_TREMONT_D:
 +		return 1;
  	}
 -	return;
 +	return 0;
 +}
 +
 +int has_turbo_ratio_limit(unsigned int family, unsigned int model)
 +{
 +	if (has_slv_msrs(family, model))
 +		return 0;
 +
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +		/* Nehalem compatible, but do not include turbo-ratio limit support */
 +	case INTEL_FAM6_NEHALEM_EX:	/* Nehalem-EX Xeon - Beckton */
 +	case INTEL_FAM6_XEON_PHI_KNL:	/* PHI - Knights Landing (different MSR definition) */
 +		return 0;
 +	default:
 +		return 1;
 +	}
 +}
 +
 +int has_atom_turbo_ratio_limit(unsigned int family, unsigned int model)
 +{
 +	if (has_slv_msrs(family, model))
 +		return 1;
 +
 +	return 0;
 +}
 +
 +int has_ivt_turbo_ratio_limit(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
 +
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_IVYBRIDGE_X:	/* IVB Xeon */
 +	case INTEL_FAM6_HASWELL_X:	/* HSW Xeon */
 +		return 1;
 +	default:
 +		return 0;
 +	}
 +}
 +
 +int has_hsw_turbo_ratio_limit(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
 +
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_HASWELL_X:	/* HSW Xeon */
 +		return 1;
 +	default:
 +		return 0;
 +	}
 +}
 +
 +int has_knl_turbo_ratio_limit(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
 +
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_XEON_PHI_KNL:	/* Knights Landing */
 +		return 1;
 +	default:
 +		return 0;
 +	}
 +}
 +
 +int has_glm_turbo_ratio_limit(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
 +
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_ATOM_GOLDMONT:
 +	case INTEL_FAM6_SKYLAKE_X:
 +	case INTEL_FAM6_ICELAKE_X:
 +	case INTEL_FAM6_SAPPHIRERAPIDS_X:
 +		return 1;
 +	default:
 +		return 0;
 +	}
 +}
 +
 +int has_config_tdp(unsigned int family, unsigned int model)
 +{
 +	if (!genuine_intel)
 +		return 0;
 +
 +	if (family != 6)
 +		return 0;
 +
 +	switch (model) {
 +	case INTEL_FAM6_IVYBRIDGE:	/* IVB */
 +	case INTEL_FAM6_HASWELL:	/* HSW */
 +	case INTEL_FAM6_HASWELL_X:	/* HSX */
 +	case INTEL_FAM6_HASWELL_L:	/* HSW */
 +	case INTEL_FAM6_HASWELL_G:	/* HSW */
 +	case INTEL_FAM6_BROADWELL:	/* BDW */
 +	case INTEL_FAM6_BROADWELL_G:	/* BDW */
 +	case INTEL_FAM6_BROADWELL_X:	/* BDX */
 +	case INTEL_FAM6_SKYLAKE_L:	/* SKL */
 +	case INTEL_FAM6_CANNONLAKE_L:	/* CNL */
 +	case INTEL_FAM6_SKYLAKE_X:	/* SKX */
 +	case INTEL_FAM6_ICELAKE_X:	/* ICX */
 +	case INTEL_FAM6_SAPPHIRERAPIDS_X:	/* SPR */
 +	case INTEL_FAM6_XEON_PHI_KNL:	/* Knights Landing */
 +		return 1;
 +	default:
 +		return 0;
 +	}
 +}
 +
 +/*
 + * tcc_offset_bits:
 + * 0: Tcc Offset not supported (Default)
 + * 6: Bit 29:24 of MSR_PLATFORM_INFO
 + * 4: Bit 27:24 of MSR_PLATFORM_INFO
 + */
 +void check_tcc_offset(int model)
 +{
 +	unsigned long long msr;
 +
 +	if (!genuine_intel)
 +		return;
 +
 +	switch (model) {
 +	case INTEL_FAM6_SKYLAKE_L:
 +	case INTEL_FAM6_SKYLAKE:
 +	case INTEL_FAM6_KABYLAKE_L:
 +	case INTEL_FAM6_KABYLAKE:
 +	case INTEL_FAM6_ICELAKE_L:
 +	case INTEL_FAM6_ICELAKE:
 +	case INTEL_FAM6_TIGERLAKE_L:
 +	case INTEL_FAM6_TIGERLAKE:
 +	case INTEL_FAM6_COMETLAKE:
 +		if (!get_msr(base_cpu, MSR_PLATFORM_INFO, &msr)) {
 +			msr = (msr >> 30) & 1;
 +			if (msr)
 +				tcc_offset_bits = 6;
 +		}
 +		return;
 +	default:
 +		return;
 +	}
 +}
 +
 +static void remove_underbar(char *s)
 +{
 +	char *to = s;
 +
 +	while (*s) {
 +		if (*s != '_')
 +			*to++ = *s;
 +		s++;
 +	}
 +
 +	*to = 0;
 +}
 +
 +static void dump_cstate_pstate_config_info(unsigned int family, unsigned int model)
 +{
 +	if (!do_nhm_platform_info)
 +		return;
 +
 +	dump_nhm_platform_info();
 +
 +	if (has_hsw_turbo_ratio_limit(family, model))
 +		dump_hsw_turbo_ratio_limits();
 +
 +	if (has_ivt_turbo_ratio_limit(family, model))
 +		dump_ivt_turbo_ratio_limits();
 +
 +	if (has_turbo_ratio_limit(family, model)) {
 +		dump_turbo_ratio_limits(MSR_TURBO_RATIO_LIMIT, family, model);
 +
 +		if (is_hybrid)
 +			dump_turbo_ratio_limits(MSR_SECONDARY_TURBO_RATIO_LIMIT, family, model);
 +	}
 +
 +	if (has_atom_turbo_ratio_limit(family, model))
 +		dump_atom_turbo_ratio_limits();
 +
 +	if (has_knl_turbo_ratio_limit(family, model))
 +		dump_knl_turbo_ratio_limits();
 +
 +	if (has_config_tdp(family, model))
 +		dump_config_tdp();
 +
 +	dump_nhm_cst_cfg();
 +}
 +
 +static int read_sysfs_int(char *path)
 +{
 +	FILE *input;
 +	int retval = -1;
 +
 +	input = fopen(path, "r");
 +	if (input == NULL) {
 +		if (debug)
 +			fprintf(outf, "NSFOD %s\n", path);
 +		return (-1);
 +	}
 +	if (fscanf(input, "%d", &retval) != 1)
 +		err(1, "%s: failed to read int from file", path);
 +	fclose(input);
 +
 +	return (retval);
 +}
 +
 +static void dump_sysfs_file(char *path)
 +{
 +	FILE *input;
 +	char cpuidle_buf[64];
 +
 +	input = fopen(path, "r");
 +	if (input == NULL) {
 +		if (debug)
 +			fprintf(outf, "NSFOD %s\n", path);
 +		return;
 +	}
 +	if (!fgets(cpuidle_buf, sizeof(cpuidle_buf), input))
 +		err(1, "%s: failed to read file", path);
 +	fclose(input);
 +
 +	fprintf(outf, "%s: %s", strrchr(path, '/') + 1, cpuidle_buf);
 +}
 +
 +static void intel_uncore_frequency_probe(void)
 +{
 +	int i, j;
- 	char path[128];
++	char path[256];
 +
 +	if (!genuine_intel)
 +		return;
 +
- 	if (access("/sys/devices/system/cpu/intel_uncore_frequency/package_00_die_00", R_OK))
- 		return;
++	if (access("/sys/devices/system/cpu/intel_uncore_frequency/package_00_die_00/current_freq_khz", R_OK))
++		goto probe_cluster;
 +
++<<<<<<< HEAD
 +	if (!access("/sys/devices/system/cpu/intel_uncore_frequency/package_00_die_00/current_freq_khz", R_OK))
 +		BIC_PRESENT(BIC_UNCORE_MHZ);
++=======
++	BIC_PRESENT(BIC_UNCORE_MHZ);
++>>>>>>> bb6181fa6bc9 (tools/power turbostat: Expand probe_intel_uncore_frequency())
 +
 +	if (quiet)
 +		return;
 +
 +	for (i = 0; i < topo.num_packages; ++i) {
 +		for (j = 0; j < topo.num_die; ++j) {
 +			int k, l;
++			char path_base[128];
++
++			sprintf(path_base, "/sys/devices/system/cpu/intel_uncore_frequency/package_%02d_die_%02d", i,
++				j);
 +
- 			sprintf(path, "/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/min_freq_khz",
- 				i, j);
++			sprintf(path, "%s/min_freq_khz", path_base);
 +			k = read_sysfs_int(path);
- 			sprintf(path, "/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/max_freq_khz",
- 				i, j);
++			sprintf(path, "%s/max_freq_khz", path_base);
 +			l = read_sysfs_int(path);
- 			fprintf(outf, "Uncore Frequency pkg%d die%d: %d - %d MHz ", i, j, k / 1000, l / 1000);
++			fprintf(outf, "Uncore Frequency package%d die%d: %d - %d MHz ", i, j, k / 1000, l / 1000);
 +
- 			sprintf(path,
- 				"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/initial_min_freq_khz",
- 				i, j);
++			sprintf(path, "%s/initial_min_freq_khz", path_base);
 +			k = read_sysfs_int(path);
- 			sprintf(path,
- 				"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/initial_max_freq_khz",
- 				i, j);
++			sprintf(path, "%s/initial_max_freq_khz", path_base);
 +			l = read_sysfs_int(path);
- 			fprintf(outf, "(%d - %d MHz)\n", k / 1000, l / 1000);
++			fprintf(outf, "(%d - %d MHz)", k / 1000, l / 1000);
++
++			sprintf(path, "%s/current_freq_khz", path_base);
++			k = read_sysfs_int(path);
++			fprintf(outf, " %d MHz\n", k / 1000);
 +		}
 +	}
++	return;
+ 
+ probe_cluster:
+ 	if (access("/sys/devices/system/cpu/intel_uncore_frequency/uncore00/current_freq_khz", R_OK))
+ 		return;
+ 
+ 	if (quiet)
+ 		return;
+ 
+ 	for (i = 0;; ++i) {
+ 		int k, l;
+ 		char path_base[128];
+ 		int package_id, domain_id, cluster_id;
+ 
+ 		sprintf(path_base, "/sys/devices/system/cpu/intel_uncore_frequency/uncore%02d", i);
+ 
+ 		if (access(path_base, R_OK))
+ 			break;
+ 
+ 		sprintf(path, "%s/package_id", path_base);
+ 		package_id = read_sysfs_int(path);
+ 
+ 		sprintf(path, "%s/domain_id", path_base);
+ 		domain_id = read_sysfs_int(path);
+ 
+ 		sprintf(path, "%s/fabric_cluster_id", path_base);
+ 		cluster_id = read_sysfs_int(path);
+ 
+ 		sprintf(path, "%s/min_freq_khz", path_base);
+ 		k = read_sysfs_int(path);
+ 		sprintf(path, "%s/max_freq_khz", path_base);
+ 		l = read_sysfs_int(path);
+ 		fprintf(outf, "Uncore Frequency package%d domain%d cluster%d: %d - %d MHz ", package_id, domain_id,
+ 			cluster_id, k / 1000, l / 1000);
+ 
+ 		sprintf(path, "%s/initial_min_freq_khz", path_base);
+ 		k = read_sysfs_int(path);
+ 		sprintf(path, "%s/initial_max_freq_khz", path_base);
+ 		l = read_sysfs_int(path);
+ 		fprintf(outf, "(%d - %d MHz)", k / 1000, l / 1000);
+ 
+ 		sprintf(path, "%s/current_freq_khz", path_base);
+ 		k = read_sysfs_int(path);
+ 		fprintf(outf, " %d MHz\n", k / 1000);
+ 	}
  }
  
 -static void probe_graphics(void)
 -{
 -	if (!access("/sys/class/drm/card0/power/rc6_residency_ms", R_OK))
 -		BIC_PRESENT(BIC_GFX_rc6);
 -
 -	if (!access("/sys/class/drm/card0/gt_cur_freq_mhz", R_OK) ||
 -	    !access("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", R_OK))
 -		BIC_PRESENT(BIC_GFXMHz);
 -
 -	if (!access("/sys/class/drm/card0/gt_act_freq_mhz", R_OK) ||
 -	    !access("/sys/class/graphics/fb0/device/drm/card0/gt_act_freq_mhz", R_OK))
 -		BIC_PRESENT(BIC_GFXACTMHz);
 -}
 -
  static void dump_sysfs_cstate_config(void)
  {
  	char path[64];
* Unmerged path tools/power/x86/turbostat/turbostat.c
