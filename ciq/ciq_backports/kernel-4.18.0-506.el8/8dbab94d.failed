cpufreq: intel_pstate: Read all MSRs on the target CPU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-506.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 8dbab94d45fb1094cefac7956b7fb987a36e2b12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-506.el8/8dbab94d.failed

Some of the MSR accesses in intel_pstate are carried out on the CPU
that is running the code, but the values coming from them are used
for the performance scaling of the other CPUs.

This is problematic, for example, on hybrid platforms where
MSR_TURBO_RATIO_LIMIT for P-cores and E-cores is different, so the
values read from it on a P-core are generally not applicable to E-cores
and the other way around.

For this reason, make the driver access all MSRs on the target CPU on
platforms using the "core" pstate_funcs callbacks which is the case for
all of the hybrid platforms released to date.  For this purpose, pass
a CPU argument to the ->get_max(), ->get_max_physical(), ->get_min()
and ->get_turbo() pstate_funcs callbacks and from there pass it to
rdmsrl_on_cpu() or rdmsrl_safe_on_cpu() to access the MSR on the target
CPU.

Fixes: 46573fd6369f ("cpufreq: intel_pstate: hybrid: Rework HWP calibration")
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Tested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Cc: 5.15+ <stable@vger.kernel.org> # 5.15+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 8dbab94d45fb1094cefac7956b7fb987a36e2b12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 60b20f67e16b,457694a2d0e8..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -554,10 -531,12 +554,19 @@@ static void intel_pstate_hybrid_hwp_adj
  {
  	int perf_ctl_max_phys = cpu->pstate.max_pstate_physical;
  	int perf_ctl_scaling = cpu->pstate.perf_ctl_scaling;
++<<<<<<< HEAD
 +	int perf_ctl_turbo = pstate_funcs.get_turbo();
 +	int scaling = cpu->pstate.scaling;
 +
 +	pr_debug("CPU%d: perf_ctl_max_phys = %d\n", cpu->cpu, perf_ctl_max_phys);
++=======
+ 	int perf_ctl_turbo = pstate_funcs.get_turbo(cpu->cpu);
+ 	int turbo_freq = perf_ctl_turbo * perf_ctl_scaling;
+ 	int scaling = cpu->pstate.scaling;
+ 
+ 	pr_debug("CPU%d: perf_ctl_max_phys = %d\n", cpu->cpu, perf_ctl_max_phys);
+ 	pr_debug("CPU%d: perf_ctl_max = %d\n", cpu->cpu, pstate_funcs.get_max(cpu->cpu));
++>>>>>>> 8dbab94d45fb (cpufreq: intel_pstate: Read all MSRs on the target CPU)
  	pr_debug("CPU%d: perf_ctl_turbo = %d\n", cpu->cpu, perf_ctl_turbo);
  	pr_debug("CPU%d: perf_ctl_scaling = %d\n", cpu->cpu, perf_ctl_scaling);
  	pr_debug("CPU%d: HWP_CAP guaranteed = %d\n", cpu->cpu, cpu->pstate.max_pstate);
* Unmerged path drivers/cpufreq/intel_pstate.c
