driver core: make kobj_type constant.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-506.el8
commit-author Wedson Almeida Filho <wedsonaf@google.com>
commit ee6d3dd4ed48ab24b74bab3c3977b8218518247d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-506.el8/ee6d3dd4.failed

This way instances of kobj_type (which contain function pointers) can be
stored in .rodata, which means that they cannot be [easily/accidentally]
modified at runtime.

	Signed-off-by: Wedson Almeida Filho <wedsonaf@google.com>
Link: https://lore.kernel.org/r/20211224231345.777370-1-wedsonaf@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ee6d3dd4ed48ab24b74bab3c3977b8218518247d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/kobject.c
diff --cc lib/kobject.c
index 9e5d537e0443,56fa037501b5..000000000000
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@@ -446,11 -454,14 +446,11 @@@ EXPORT_SYMBOL(kobject_add)
   * @parent: pointer to the parent of this kobject.
   * @fmt: the name of the kobject.
   *
 - * This function combines the call to kobject_init() and kobject_add().
 - *
 - * If this function returns an error, kobject_put() must be called to
 - * properly clean up the memory associated with the object.  This is the
 - * same type of error handling after a call to kobject_add() and kobject
 - * lifetime rules are the same here.
 + * This function combines the call to kobject_init() and
 + * kobject_add().  The same type of error handling after a call to
 + * kobject_add() and kobject lifetime rules are the same here.
   */
- int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
+ int kobject_init_and_add(struct kobject *kobj, const struct kobj_type *ktype,
  			 struct kobject *parent, const char *fmt, ...)
  {
  	va_list args;
@@@ -647,7 -678,8 +647,12 @@@ EXPORT_SYMBOL(kobject_get_unless_zero)
   */
  static void kobject_cleanup(struct kobject *kobj)
  {
++<<<<<<< HEAD
 +	struct kobj_type *t = get_ktype(kobj);
++=======
+ 	struct kobject *parent = kobj->parent;
+ 	const struct kobj_type *t = get_ktype(kobj);
++>>>>>>> ee6d3dd4ed48 (driver core: make kobj_type constant.)
  	const char *name = kobj->name;
  
  	pr_debug("kobject: '%s' (%p): %s, parent %p\n",
diff --git a/Documentation/kobject.txt b/Documentation/kobject.txt
index fc9485d79061..643ca3fca3d1 100644
--- a/Documentation/kobject.txt
+++ b/Documentation/kobject.txt
@@ -118,7 +118,7 @@ Initialization of kobjects
 Code which creates a kobject must, of course, initialize that object. Some
 of the internal fields are setup with a (mandatory) call to kobject_init()::
 
-    void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
+    void kobject_init(struct kobject *kobj, const struct kobj_type *ktype);
 
 The ktype is required for a kobject to be created properly, as every kobject
 must have an associated kobj_type.  After calling kobject_init(), to
@@ -156,7 +156,7 @@ kobject_name()::
 There is a helper function to both initialize and add the kobject to the
 kernel at the same time, called surprisingly enough kobject_init_and_add()::
 
-    int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
+    int kobject_init_and_add(struct kobject *kobj, const struct kobj_type *ktype,
                              struct kobject *parent, const char *fmt, ...);
 
 The arguments are the same as the individual kobject_init() and
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index eaed32d33882..c240b428aeeb 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -219,7 +219,7 @@ static struct kobj_type bus_ktype = {
 
 static int bus_uevent_filter(struct kset *kset, struct kobject *kobj)
 {
-	struct kobj_type *ktype = get_ktype(kobj);
+	const struct kobj_type *ktype = get_ktype(kobj);
 
 	if (ktype == &bus_ktype)
 		return 1;
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 1483cbf70991..ba30c074559f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2449,7 +2449,7 @@ static struct kobj_type device_ktype = {
 
 static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 {
-	struct kobj_type *ktype = get_ktype(kobj);
+	const struct kobj_type *ktype = get_ktype(kobj);
 
 	if (ktype == &device_ktype) {
 		struct device *dev = kobj_to_dev(kobj);
diff --git a/include/linux/kobject.h b/include/linux/kobject.h
index 330358f93467..9a8c2de32f2b 100644
--- a/include/linux/kobject.h
+++ b/include/linux/kobject.h
@@ -68,7 +68,7 @@ struct kobject {
 	struct list_head	entry;
 	struct kobject		*parent;
 	struct kset		*kset;
-	struct kobj_type	*ktype;
+	const struct kobj_type	*ktype;
 	struct kernfs_node	*sd; /* sysfs directory entry */
 	struct kref		kref;
 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
@@ -96,13 +96,13 @@ static inline const char *kobject_name(const struct kobject *kobj)
 	return kobj->name;
 }
 
-extern void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
+extern void kobject_init(struct kobject *kobj, const struct kobj_type *ktype);
 extern __printf(3, 4) __must_check
 int kobject_add(struct kobject *kobj, struct kobject *parent,
 		const char *fmt, ...);
 extern __printf(4, 5) __must_check
 int kobject_init_and_add(struct kobject *kobj,
-			 struct kobj_type *ktype, struct kobject *parent,
+			 const struct kobj_type *ktype, struct kobject *parent,
 			 const char *fmt, ...);
 
 extern void kobject_del(struct kobject *kobj);
@@ -213,7 +213,7 @@ static inline void kset_put(struct kset *k)
 	kobject_put(&k->kobj);
 }
 
-static inline struct kobj_type *get_ktype(struct kobject *kobj)
+static inline const struct kobj_type *get_ktype(struct kobject *kobj)
 {
 	return kobj->ktype;
 }
diff --git a/kernel/params.c b/kernel/params.c
index bcdfc2393dc8..186bc540444c 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -947,7 +947,7 @@ static const struct sysfs_ops module_sysfs_ops = {
 
 static int uevent_filter(struct kset *kset, struct kobject *kobj)
 {
-	struct kobj_type *ktype = get_ktype(kobj);
+	const struct kobj_type *ktype = get_ktype(kobj);
 
 	if (ktype == &module_ktype)
 		return 1;
* Unmerged path lib/kobject.c
