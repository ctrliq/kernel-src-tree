cpufreq: Generalize of_perf_domain_get_sharing_cpumask phandle format

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-506.el8
commit-author Hector Martin <marcan@marcan.st>
commit d182dc6de93225cd853de4db68a1a77501bedb6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-506.el8/d182dc6d.failed

of_perf_domain_get_sharing_cpumask currently assumes a 1-argument
phandle format, and directly returns the argument. Generalize this to
return the full of_phandle_args, so it can be used by drivers which use
other phandle styles (e.g. separate nodes). This also requires changing
the CPU sharing match to compare the full args structure.

Also, make sure to of_node_put(args.np) (the original code was leaking a
reference).

	Signed-off-by: Hector Martin <marcan@marcan.st>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit d182dc6de93225cd853de4db68a1a77501bedb6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/mediatek-cpufreq-hw.c
#	include/linux/cpufreq.h
diff --cc include/linux/cpufreq.h
index 9bf76b2cd807,6a94a6eaad27..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -1023,6 -1077,89 +1023,92 @@@ static inline int cpufreq_table_count_v
  
  	return count;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * cpufreq_table_set_inefficient() - Mark a frequency as inefficient
+  * @policy:	the &struct cpufreq_policy containing the inefficient frequency
+  * @frequency:	the inefficient frequency
+  *
+  * The &struct cpufreq_policy must use a sorted frequency table
+  *
+  * Return:	%0 on success or a negative errno code
+  */
+ 
+ static inline int
+ cpufreq_table_set_inefficient(struct cpufreq_policy *policy,
+ 			      unsigned int frequency)
+ {
+ 	struct cpufreq_frequency_table *pos;
+ 
+ 	/* Not supported */
+ 	if (policy->freq_table_sorted == CPUFREQ_TABLE_UNSORTED)
+ 		return -EINVAL;
+ 
+ 	cpufreq_for_each_valid_entry(pos, policy->freq_table) {
+ 		if (pos->frequency == frequency) {
+ 			pos->flags |= CPUFREQ_INEFFICIENT_FREQ;
+ 			policy->efficiencies_available = true;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static inline int parse_perf_domain(int cpu, const char *list_name,
+ 				    const char *cell_name,
+ 				    struct of_phandle_args *args)
+ {
+ 	struct device_node *cpu_np;
+ 	int ret;
+ 
+ 	cpu_np = of_cpu_device_node_get(cpu);
+ 	if (!cpu_np)
+ 		return -ENODEV;
+ 
+ 	ret = of_parse_phandle_with_args(cpu_np, list_name, cell_name, 0,
+ 					 args);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	of_node_put(cpu_np);
+ 
+ 	return 0;
+ }
+ 
+ static inline int of_perf_domain_get_sharing_cpumask(int pcpu, const char *list_name,
+ 						     const char *cell_name, struct cpumask *cpumask,
+ 						     struct of_phandle_args *pargs)
+ {
+ 	int cpu, ret;
+ 	struct of_phandle_args args;
+ 
+ 	ret = parse_perf_domain(pcpu, list_name, cell_name, pargs);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	cpumask_set_cpu(pcpu, cpumask);
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		if (cpu == pcpu)
+ 			continue;
+ 
+ 		ret = parse_perf_domain(cpu, list_name, cell_name, &args);
+ 		if (ret < 0)
+ 			continue;
+ 
+ 		if (pargs->np == args.np && pargs->args_count == args.args_count &&
+ 		    !memcmp(pargs->args, args.args, sizeof(args.args[0]) * args.args_count))
+ 			cpumask_set_cpu(cpu, cpumask);
+ 
+ 		of_node_put(args.np);
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> d182dc6de932 (cpufreq: Generalize of_perf_domain_get_sharing_cpumask phandle format)
  #else
  static inline int cpufreq_boost_trigger_state(int state)
  {
@@@ -1042,6 -1179,20 +1128,23 @@@ static inline bool policy_has_boost_fre
  {
  	return false;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int
+ cpufreq_table_set_inefficient(struct cpufreq_policy *policy,
+ 			      unsigned int frequency)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static inline int of_perf_domain_get_sharing_cpumask(int pcpu, const char *list_name,
+ 						     const char *cell_name, struct cpumask *cpumask,
+ 						     struct of_phandle_args *pargs)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> d182dc6de932 (cpufreq: Generalize of_perf_domain_get_sharing_cpumask phandle format)
  #endif
  
  #if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)
* Unmerged path drivers/cpufreq/mediatek-cpufreq-hw.c
* Unmerged path drivers/cpufreq/mediatek-cpufreq-hw.c
* Unmerged path include/linux/cpufreq.h
