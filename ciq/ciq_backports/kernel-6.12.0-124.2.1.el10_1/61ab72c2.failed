x86/bugs: Restructure ITS mitigation

jira KERNEL-156
Rebuild_History Non-Buildable kernel-6.12.0-124.2.1.el10_1
commit-author David Kaplan <david.kaplan@amd.com>
commit 61ab72c2c6bf24f28b3dbfd3126e984d5afa8424
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-124.2.1.el10_1/61ab72c2.failed

Restructure the ITS mitigation to use select/update/apply functions like
the other mitigations.

There is a particularly complex interaction between ITS and Retbleed as CDT
(Call Depth Tracking) is a mitigation for both, and either its=stuff or
retbleed=stuff will attempt to enable CDT.

retbleed_update_mitigation() runs first and will check the necessary
pre-conditions for CDT if either ITS or Retbleed stuffing is selected.  If
checks pass and ITS stuffing is selected, it will select stuffing for
Retbleed as well.

its_update_mitigation() runs after and will either select stuffing if
retbleed stuffing was enabled, or fall back to the default (aligned thunks)
if stuffing could not be enabled.

Enablement of CDT is done exclusively in retbleed_apply_mitigation().
its_apply_mitigation() is only used to enable aligned thunks.

	Signed-off-by: David Kaplan <david.kaplan@amd.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/20250516193212.128782-1-david.kaplan@amd.com
(cherry picked from commit 61ab72c2c6bf24f28b3dbfd3126e984d5afa8424)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 95b4e9a10dd7,3d5796d25f78..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -34,22 -34,66 +34,24 @@@
  
  #include "cpu.h"
  
 -/*
 - * Speculation Vulnerability Handling
 - *
 - * Each vulnerability is handled with the following functions:
 - *   <vuln>_select_mitigation() -- Selects a mitigation to use.  This should
 - *				   take into account all relevant command line
 - *				   options.
 - *   <vuln>_update_mitigation() -- This is called after all vulnerabilities have
 - *				   selected a mitigation, in case the selection
 - *				   may want to change based on other choices
 - *				   made.  This function is optional.
 - *   <vuln>_apply_mitigation() -- Enable the selected mitigation.
 - *
 - * The compile-time mitigation in all cases should be AUTO.  An explicit
 - * command-line option can override AUTO.  If no such option is
 - * provided, <vuln>_select_mitigation() will override AUTO to the best
 - * mitigation option.
 - */
 -
  static void __init spectre_v1_select_mitigation(void);
 -static void __init spectre_v1_apply_mitigation(void);
  static void __init spectre_v2_select_mitigation(void);
 -static void __init spectre_v2_update_mitigation(void);
 -static void __init spectre_v2_apply_mitigation(void);
  static void __init retbleed_select_mitigation(void);
 -static void __init retbleed_update_mitigation(void);
 -static void __init retbleed_apply_mitigation(void);
  static void __init spectre_v2_user_select_mitigation(void);
 -static void __init spectre_v2_user_update_mitigation(void);
 -static void __init spectre_v2_user_apply_mitigation(void);
  static void __init ssb_select_mitigation(void);
 -static void __init ssb_apply_mitigation(void);
  static void __init l1tf_select_mitigation(void);
 -static void __init l1tf_apply_mitigation(void);
  static void __init mds_select_mitigation(void);
 -static void __init mds_update_mitigation(void);
 -static void __init mds_apply_mitigation(void);
 +static void __init md_clear_update_mitigation(void);
 +static void __init md_clear_select_mitigation(void);
  static void __init taa_select_mitigation(void);
 -static void __init taa_update_mitigation(void);
 -static void __init taa_apply_mitigation(void);
  static void __init mmio_select_mitigation(void);
 -static void __init mmio_update_mitigation(void);
 -static void __init mmio_apply_mitigation(void);
 -static void __init rfds_select_mitigation(void);
 -static void __init rfds_update_mitigation(void);
 -static void __init rfds_apply_mitigation(void);
  static void __init srbds_select_mitigation(void);
 -static void __init srbds_apply_mitigation(void);
  static void __init l1d_flush_select_mitigation(void);
  static void __init srso_select_mitigation(void);
 -static void __init srso_update_mitigation(void);
 -static void __init srso_apply_mitigation(void);
  static void __init gds_select_mitigation(void);
 -static void __init gds_apply_mitigation(void);
 -static void __init bhi_select_mitigation(void);
 -static void __init bhi_update_mitigation(void);
 -static void __init bhi_apply_mitigation(void);
  static void __init its_select_mitigation(void);
+ static void __init its_update_mitigation(void);
+ static void __init its_apply_mitigation(void);
  
  /* The base value of the SPEC_CTRL MSR without task-specific bits set */
  u64 x86_spec_ctrl_base;
@@@ -192,6 -224,54 +194,57 @@@ void __init cpu_select_mitigations(void
  	srso_select_mitigation();
  	gds_select_mitigation();
  	its_select_mitigation();
++<<<<<<< HEAD
++=======
+ 	bhi_select_mitigation();
+ 
+ 	/*
+ 	 * After mitigations are selected, some may need to update their
+ 	 * choices.
+ 	 */
+ 	spectre_v2_update_mitigation();
+ 	/*
+ 	 * retbleed_update_mitigation() relies on the state set by
+ 	 * spectre_v2_update_mitigation(); specifically it wants to know about
+ 	 * spectre_v2=ibrs.
+ 	 */
+ 	retbleed_update_mitigation();
+ 	/*
+ 	 * its_update_mitigation() depends on spectre_v2_update_mitigation()
+ 	 * and retbleed_update_mitigation().
+ 	 */
+ 	its_update_mitigation();
+ 
+ 	/*
+ 	 * spectre_v2_user_update_mitigation() depends on
+ 	 * retbleed_update_mitigation(), specifically the STIBP
+ 	 * selection is forced for UNRET or IBPB.
+ 	 */
+ 	spectre_v2_user_update_mitigation();
+ 	mds_update_mitigation();
+ 	taa_update_mitigation();
+ 	mmio_update_mitigation();
+ 	rfds_update_mitigation();
+ 	bhi_update_mitigation();
+ 	/* srso_update_mitigation() depends on retbleed_update_mitigation(). */
+ 	srso_update_mitigation();
+ 
+ 	spectre_v1_apply_mitigation();
+ 	spectre_v2_apply_mitigation();
+ 	retbleed_apply_mitigation();
+ 	spectre_v2_user_apply_mitigation();
+ 	ssb_apply_mitigation();
+ 	l1tf_apply_mitigation();
+ 	mds_apply_mitigation();
+ 	taa_apply_mitigation();
+ 	mmio_apply_mitigation();
+ 	rfds_apply_mitigation();
+ 	srbds_apply_mitigation();
+ 	srso_apply_mitigation();
+ 	gds_apply_mitigation();
+ 	its_apply_mitigation();
+ 	bhi_apply_mitigation();
++>>>>>>> 61ab72c2c6bf (x86/bugs: Restructure ITS mitigation)
  }
  
  /*
@@@ -984,8 -1123,20 +1037,19 @@@ enum spectre_v2_mitigation spectre_v2_e
  #undef pr_fmt
  #define pr_fmt(fmt)     "RETBleed: " fmt
  
+ enum its_mitigation {
+ 	ITS_MITIGATION_OFF,
+ 	ITS_MITIGATION_AUTO,
+ 	ITS_MITIGATION_VMEXIT_ONLY,
+ 	ITS_MITIGATION_ALIGNED_THUNKS,
+ 	ITS_MITIGATION_RETPOLINE_STUFF,
+ };
+ 
+ static enum its_mitigation its_mitigation __ro_after_init =
+ 	IS_ENABLED(CONFIG_MITIGATION_ITS) ? ITS_MITIGATION_AUTO : ITS_MITIGATION_OFF;
+ 
  enum retbleed_mitigation {
  	RETBLEED_MITIGATION_NONE,
 -	RETBLEED_MITIGATION_AUTO,
  	RETBLEED_MITIGATION_UNRET,
  	RETBLEED_MITIGATION_IBPB,
  	RETBLEED_MITIGATION_IBRS,
@@@ -1064,71 -1253,64 +1128,128 @@@ static void __init retbleed_select_miti
  	if (!boot_cpu_has_bug(X86_BUG_RETBLEED) || cpu_mitigations_off())
  		return;
  
++<<<<<<< HEAD
 +	switch (retbleed_cmd) {
 +	case RETBLEED_CMD_OFF:
++=======
+ 	if (retbleed_mitigation == RETBLEED_MITIGATION_NONE)
+ 		goto out;
+ 
+ 	/*
+ 	 * retbleed=stuff is only allowed on Intel.  If stuffing can't be used
+ 	 * then a different mitigation will be selected below.
+ 	 *
+ 	 * its=stuff will also attempt to enable stuffing.
+ 	 */
+ 	if (retbleed_mitigation == RETBLEED_MITIGATION_STUFF ||
+ 	    its_mitigation == ITS_MITIGATION_RETPOLINE_STUFF) {
+ 		if (spectre_v2_enabled != SPECTRE_V2_RETPOLINE) {
+ 			pr_err("WARNING: retbleed=stuff depends on spectre_v2=retpoline\n");
+ 			retbleed_mitigation = RETBLEED_MITIGATION_AUTO;
+ 		} else {
+ 			if (retbleed_mitigation != RETBLEED_MITIGATION_STUFF)
+ 				pr_info("Retbleed mitigation updated to stuffing\n");
+ 
+ 			retbleed_mitigation = RETBLEED_MITIGATION_STUFF;
+ 		}
+ 	}
+ 	/*
+ 	 * Let IBRS trump all on Intel without affecting the effects of the
+ 	 * retbleed= cmdline option except for call depth based stuffing
+ 	 */
+ 	if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) {
+ 		switch (spectre_v2_enabled) {
+ 		case SPECTRE_V2_IBRS:
+ 			retbleed_mitigation = RETBLEED_MITIGATION_IBRS;
+ 			break;
+ 		case SPECTRE_V2_EIBRS:
+ 		case SPECTRE_V2_EIBRS_RETPOLINE:
+ 		case SPECTRE_V2_EIBRS_LFENCE:
+ 			retbleed_mitigation = RETBLEED_MITIGATION_EIBRS;
+ 			break;
+ 		default:
+ 			if (retbleed_mitigation != RETBLEED_MITIGATION_STUFF)
+ 				pr_err(RETBLEED_INTEL_MSG);
+ 		}
+ 		/* If nothing has set the mitigation yet, default to NONE. */
+ 		if (retbleed_mitigation == RETBLEED_MITIGATION_AUTO)
+ 			retbleed_mitigation = RETBLEED_MITIGATION_NONE;
+ 	}
+ out:
+ 	pr_info("%s\n", retbleed_strings[retbleed_mitigation]);
+ }
+ 
+ 
+ static void __init retbleed_apply_mitigation(void)
+ {
+ 	bool mitigate_smt = false;
+ 
+ 	switch (retbleed_mitigation) {
+ 	case RETBLEED_MITIGATION_NONE:
++>>>>>>> 61ab72c2c6bf (x86/bugs: Restructure ITS mitigation)
  		return;
  
 +	case RETBLEED_CMD_UNRET:
 +		if (IS_ENABLED(CONFIG_MITIGATION_UNRET_ENTRY)) {
 +			retbleed_mitigation = RETBLEED_MITIGATION_UNRET;
 +		} else {
 +			pr_err("WARNING: kernel not compiled with MITIGATION_UNRET_ENTRY.\n");
 +			goto do_cmd_auto;
 +		}
 +		break;
 +
 +	case RETBLEED_CMD_IBPB:
 +		if (!boot_cpu_has(X86_FEATURE_IBPB)) {
 +			pr_err("WARNING: CPU does not support IBPB.\n");
 +			goto do_cmd_auto;
 +		} else if (IS_ENABLED(CONFIG_MITIGATION_IBPB_ENTRY)) {
 +			retbleed_mitigation = RETBLEED_MITIGATION_IBPB;
 +		} else {
 +			pr_err("WARNING: kernel not compiled with MITIGATION_IBPB_ENTRY.\n");
 +			goto do_cmd_auto;
 +		}
 +		break;
 +
 +	case RETBLEED_CMD_STUFF:
 +		if (IS_ENABLED(CONFIG_MITIGATION_CALL_DEPTH_TRACKING) &&
 +		    spectre_v2_enabled == SPECTRE_V2_RETPOLINE) {
 +			if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) {
 +				pr_err("WARNING: retbleed=stuff only supported for Intel CPUs.\n");
 +				goto do_cmd_auto;
 +			}
 +			retbleed_mitigation = RETBLEED_MITIGATION_STUFF;
 +
 +		} else {
 +			if (IS_ENABLED(CONFIG_MITIGATION_CALL_DEPTH_TRACKING))
 +				pr_err("WARNING: retbleed=stuff depends on spectre_v2=retpoline\n");
 +			else
 +				pr_err("WARNING: kernel not compiled with MITIGATION_CALL_DEPTH_TRACKING.\n");
 +
 +			goto do_cmd_auto;
 +		}
 +		break;
 +
 +do_cmd_auto:
 +	case RETBLEED_CMD_AUTO:
 +		if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD ||
 +		    boot_cpu_data.x86_vendor == X86_VENDOR_HYGON) {
 +			if (IS_ENABLED(CONFIG_MITIGATION_UNRET_ENTRY))
 +				retbleed_mitigation = RETBLEED_MITIGATION_UNRET;
 +			else if (IS_ENABLED(CONFIG_MITIGATION_IBPB_ENTRY) &&
 +				 boot_cpu_has(X86_FEATURE_IBPB))
 +				retbleed_mitigation = RETBLEED_MITIGATION_IBPB;
 +		}
 +
 +		/*
 +		 * The Intel mitigation (IBRS or eIBRS) was already selected in
 +		 * spectre_v2_select_mitigation().  'retbleed_mitigation' will
 +		 * be set accordingly below.
 +		 */
 +
 +		break;
 +	}
 +
 +	switch (retbleed_mitigation) {
  	case RETBLEED_MITIGATION_UNRET:
  		setup_force_cpu_cap(X86_FEATURE_RETHUNK);
  		setup_force_cpu_cap(X86_FEATURE_UNRET);
* Unmerged path arch/x86/kernel/cpu/bugs.c
