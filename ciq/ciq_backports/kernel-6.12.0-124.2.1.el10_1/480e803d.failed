x86/bugs: Restructure spectre_v2 mitigation

jira KERNEL-156
Rebuild_History Non-Buildable kernel-6.12.0-124.2.1.el10_1
commit-author David Kaplan <david.kaplan@amd.com>
commit 480e803dacf8be92b1104ca65f2be4cb0e191375
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-124.2.1.el10_1/480e803d.failed

Restructure spectre_v2 to use select/update/apply functions to create
consistent vulnerability handling.

The spectre_v2 mitigation may be updated based on the selected retbleed
mitigation.

	Signed-off-by: David Kaplan <david.kaplan@amd.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
Link: https://lore.kernel.org/20250418161721.1855190-14-david.kaplan@amd.com
(cherry picked from commit 480e803dacf8be92b1104ca65f2be4cb0e191375)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index eaabc5443ada,93d07438eea7..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -34,10 -34,36 +34,12 @@@
  
  #include "cpu.h"
  
 -/*
 - * Speculation Vulnerability Handling
 - *
 - * Each vulnerability is handled with the following functions:
 - *   <vuln>_select_mitigation() -- Selects a mitigation to use.  This should
 - *				   take into account all relevant command line
 - *				   options.
 - *   <vuln>_update_mitigation() -- This is called after all vulnerabilities have
 - *				   selected a mitigation, in case the selection
 - *				   may want to change based on other choices
 - *				   made.  This function is optional.
 - *   <vuln>_apply_mitigation() -- Enable the selected mitigation.
 - *
 - * The compile-time mitigation in all cases should be AUTO.  An explicit
 - * command-line option can override AUTO.  If no such option is
 - * provided, <vuln>_select_mitigation() will override AUTO to the best
 - * mitigation option.
 - */
 -
  static void __init spectre_v1_select_mitigation(void);
 -static void __init spectre_v1_apply_mitigation(void);
  static void __init spectre_v2_select_mitigation(void);
+ static void __init spectre_v2_update_mitigation(void);
+ static void __init spectre_v2_apply_mitigation(void);
  static void __init retbleed_select_mitigation(void);
 -static void __init retbleed_update_mitigation(void);
 -static void __init retbleed_apply_mitigation(void);
  static void __init spectre_v2_user_select_mitigation(void);
 -static void __init spectre_v2_user_update_mitigation(void);
 -static void __init spectre_v2_user_apply_mitigation(void);
  static void __init ssb_select_mitigation(void);
  static void __init l1tf_select_mitigation(void);
  static void __init mds_select_mitigation(void);
@@@ -191,7 -213,43 +193,47 @@@ void __init cpu_select_mitigations(void
  	 */
  	srso_select_mitigation();
  	gds_select_mitigation();
++<<<<<<< HEAD
 +	its_select_mitigation();
++=======
+ 	bhi_select_mitigation();
+ 
+ 	/*
+ 	 * After mitigations are selected, some may need to update their
+ 	 * choices.
+ 	 */
+ 	spectre_v2_update_mitigation();
+ 	/*
+ 	 * retbleed_update_mitigation() relies on the state set by
+ 	 * spectre_v2_update_mitigation(); specifically it wants to know about
+ 	 * spectre_v2=ibrs.
+ 	 */
+ 	retbleed_update_mitigation();
+ 
+ 	/*
+ 	 * spectre_v2_user_update_mitigation() depends on
+ 	 * retbleed_update_mitigation(), specifically the STIBP
+ 	 * selection is forced for UNRET or IBPB.
+ 	 */
+ 	spectre_v2_user_update_mitigation();
+ 	mds_update_mitigation();
+ 	taa_update_mitigation();
+ 	mmio_update_mitigation();
+ 	rfds_update_mitigation();
+ 	bhi_update_mitigation();
+ 
+ 	spectre_v1_apply_mitigation();
+ 	spectre_v2_apply_mitigation();
+ 	retbleed_apply_mitigation();
+ 	spectre_v2_user_apply_mitigation();
+ 	mds_apply_mitigation();
+ 	taa_apply_mitigation();
+ 	mmio_apply_mitigation();
+ 	rfds_apply_mitigation();
+ 	srbds_apply_mitigation();
+ 	gds_apply_mitigation();
+ 	bhi_apply_mitigation();
++>>>>>>> 480e803dacf8 (x86/bugs: Restructure spectre_v2 mitigation)
  }
  
  /*
@@@ -1935,14 -1933,34 +1962,34 @@@ static void __init spectre_v2_select_mi
  		break;
  
  	case SPECTRE_V2_CMD_EIBRS_RETPOLINE:
- 		mode = SPECTRE_V2_EIBRS_RETPOLINE;
+ 		spectre_v2_enabled = SPECTRE_V2_EIBRS_RETPOLINE;
  		break;
  	}
+ }
+ 
+ static void __init spectre_v2_update_mitigation(void)
+ {
+ 	if (spectre_v2_cmd == SPECTRE_V2_CMD_AUTO) {
+ 		if (IS_ENABLED(CONFIG_MITIGATION_IBRS_ENTRY) &&
+ 		    boot_cpu_has_bug(X86_BUG_RETBLEED) &&
 -		    retbleed_mitigation != RETBLEED_MITIGATION_NONE &&
 -		    retbleed_mitigation != RETBLEED_MITIGATION_STUFF &&
++		    retbleed_cmd != RETBLEED_CMD_OFF &&
++		    retbleed_cmd != RETBLEED_CMD_STUFF &&
+ 		    boot_cpu_has(X86_FEATURE_IBRS) &&
+ 		    boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) {
+ 			spectre_v2_enabled = SPECTRE_V2_IBRS;
+ 		}
+ 	}
  
- 	if (mode == SPECTRE_V2_EIBRS && unprivileged_ebpf_enabled())
+ 	if (boot_cpu_has_bug(X86_BUG_SPECTRE_V2) && !cpu_mitigations_off())
+ 		pr_info("%s\n", spectre_v2_strings[spectre_v2_enabled]);
+ }
+ 
+ static void __init spectre_v2_apply_mitigation(void)
+ {
+ 	if (spectre_v2_enabled == SPECTRE_V2_EIBRS && unprivileged_ebpf_enabled())
  		pr_err(SPECTRE_V2_EIBRS_EBPF_MSG);
  
- 	if (spectre_v2_in_ibrs_mode(mode)) {
+ 	if (spectre_v2_in_ibrs_mode(spectre_v2_enabled)) {
  		if (boot_cpu_has(X86_FEATURE_AUTOIBRS)) {
  			msr_set_bit(MSR_EFER, _EFER_AUTOIBRS);
  		} else {
@@@ -1978,18 -1998,12 +2027,22 @@@
  	 * JMPs gets protection against BHI and Intramode-BTI, but RET
  	 * prediction from a non-RSB predictor is still a risk.
  	 */
- 	if (mode == SPECTRE_V2_EIBRS_LFENCE ||
- 	    mode == SPECTRE_V2_EIBRS_RETPOLINE ||
- 	    mode == SPECTRE_V2_RETPOLINE)
+ 	if (spectre_v2_enabled == SPECTRE_V2_EIBRS_LFENCE ||
+ 	    spectre_v2_enabled == SPECTRE_V2_EIBRS_RETPOLINE ||
+ 	    spectre_v2_enabled == SPECTRE_V2_RETPOLINE)
  		spec_ctrl_disable_kernel_rrsba();
  
++<<<<<<< HEAD
 +	if (boot_cpu_has(X86_BUG_BHI))
 +		bhi_select_mitigation();
 +
 +	spectre_v2_enabled = mode;
 +	pr_info("%s\n", spectre_v2_strings[mode]);
 +
 +	spectre_v2_select_rsb_mitigation(mode);
++=======
+ 	spectre_v2_select_rsb_mitigation(spectre_v2_enabled);
++>>>>>>> 480e803dacf8 (x86/bugs: Restructure spectre_v2 mitigation)
  
  	/*
  	 * Retpoline protects the kernel, but doesn't protect firmware.  IBRS
* Unmerged path arch/x86/kernel/cpu/bugs.c
