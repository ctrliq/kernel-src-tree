x86/bugs: Remove md_clear_*_mitigation()

jira KERNEL-156
Rebuild_History Non-Buildable kernel-6.12.0-124.2.1.el10_1
commit-author David Kaplan <david.kaplan@amd.com>
commit 6f0960a760eb926d8a2b9fe6fc7a1086cba14dd1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-124.2.1.el10_1/6f0960a7.failed

The functionality in md_clear_update_mitigation() and
md_clear_select_mitigation() is now integrated into the select/update
functions for the MDS, TAA, MMIO, and RFDS vulnerabilities.

	Signed-off-by: David Kaplan <david.kaplan@amd.com>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
Link: https://lore.kernel.org/20250418161721.1855190-6-david.kaplan@amd.com
(cherry picked from commit 6f0960a760eb926d8a2b9fe6fc7a1086cba14dd1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index f2cbc864a5e8,98476b8ba4fd..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -41,10 -60,17 +41,15 @@@ static void __init spectre_v2_user_sele
  static void __init ssb_select_mitigation(void);
  static void __init l1tf_select_mitigation(void);
  static void __init mds_select_mitigation(void);
++<<<<<<< HEAD
 +static void __init md_clear_update_mitigation(void);
 +static void __init md_clear_select_mitigation(void);
++=======
+ static void __init mds_update_mitigation(void);
+ static void __init mds_apply_mitigation(void);
++>>>>>>> 6f0960a760eb (x86/bugs: Remove md_clear_*_mitigation())
  static void __init taa_select_mitigation(void);
 -static void __init taa_update_mitigation(void);
 -static void __init taa_apply_mitigation(void);
  static void __init mmio_select_mitigation(void);
 -static void __init mmio_update_mitigation(void);
 -static void __init mmio_apply_mitigation(void);
 -static void __init rfds_select_mitigation(void);
 -static void __init rfds_update_mitigation(void);
 -static void __init rfds_apply_mitigation(void);
  static void __init srbds_select_mitigation(void);
  static void __init l1d_flush_select_mitigation(void);
  static void __init srso_select_mitigation(void);
@@@ -181,7 -198,10 +186,14 @@@ void __init cpu_select_mitigations(void
  	spectre_v2_user_select_mitigation();
  	ssb_select_mitigation();
  	l1tf_select_mitigation();
++<<<<<<< HEAD
 +	md_clear_select_mitigation();
++=======
+ 	mds_select_mitigation();
+ 	taa_select_mitigation();
+ 	mmio_select_mitigation();
+ 	rfds_select_mitigation();
++>>>>>>> 6f0960a760eb (x86/bugs: Remove md_clear_*_mitigation())
  	srbds_select_mitigation();
  	l1d_flush_select_mitigation();
  
@@@ -560,72 -689,6 +572,75 @@@ static __init int rfds_parse_cmdline(ch
  early_param("reg_file_data_sampling", rfds_parse_cmdline);
  
  #undef pr_fmt
++<<<<<<< HEAD
 +#define pr_fmt(fmt)     "" fmt
 +
 +static void __init md_clear_update_mitigation(void)
 +{
 +	if (cpu_mitigations_off())
 +		return;
 +
 +	if (!boot_cpu_has(X86_FEATURE_CLEAR_CPU_BUF))
 +		goto out;
 +
 +	/*
 +	 * X86_FEATURE_CLEAR_CPU_BUF is now enabled. Update MDS, TAA and MMIO
 +	 * Stale Data mitigation, if necessary.
 +	 */
 +	if (mds_mitigation == MDS_MITIGATION_OFF &&
 +	    boot_cpu_has_bug(X86_BUG_MDS)) {
 +		mds_mitigation = MDS_MITIGATION_FULL;
 +		mds_select_mitigation();
 +	}
 +	if (taa_mitigation == TAA_MITIGATION_OFF &&
 +	    boot_cpu_has_bug(X86_BUG_TAA)) {
 +		taa_mitigation = TAA_MITIGATION_VERW;
 +		taa_select_mitigation();
 +	}
 +	/*
 +	 * MMIO_MITIGATION_OFF is not checked here so that cpu_buf_vm_clear
 +	 * gets updated correctly as per X86_FEATURE_CLEAR_CPU_BUF state.
 +	 */
 +	if (boot_cpu_has_bug(X86_BUG_MMIO_STALE_DATA)) {
 +		mmio_mitigation = MMIO_MITIGATION_VERW;
 +		mmio_select_mitigation();
 +	}
 +	if (rfds_mitigation == RFDS_MITIGATION_OFF &&
 +	    boot_cpu_has_bug(X86_BUG_RFDS)) {
 +		rfds_mitigation = RFDS_MITIGATION_VERW;
 +		rfds_select_mitigation();
 +	}
 +out:
 +	if (boot_cpu_has_bug(X86_BUG_MDS))
 +		pr_info("MDS: %s\n", mds_strings[mds_mitigation]);
 +	if (boot_cpu_has_bug(X86_BUG_TAA))
 +		pr_info("TAA: %s\n", taa_strings[taa_mitigation]);
 +	if (boot_cpu_has_bug(X86_BUG_MMIO_STALE_DATA))
 +		pr_info("MMIO Stale Data: %s\n", mmio_strings[mmio_mitigation]);
 +	else if (boot_cpu_has_bug(X86_BUG_MMIO_UNKNOWN))
 +		pr_info("MMIO Stale Data: Unknown: No mitigations\n");
 +	if (boot_cpu_has_bug(X86_BUG_RFDS))
 +		pr_info("Register File Data Sampling: %s\n", rfds_strings[rfds_mitigation]);
 +}
 +
 +static void __init md_clear_select_mitigation(void)
 +{
 +	mds_select_mitigation();
 +	taa_select_mitigation();
 +	mmio_select_mitigation();
 +	rfds_select_mitigation();
 +
 +	/*
 +	 * As these mitigations are inter-related and rely on VERW instruction
 +	 * to clear the microarchitural buffers, update and print their status
 +	 * after mitigation selection is done for each of these vulnerabilities.
 +	 */
 +	md_clear_update_mitigation();
 +}
 +
 +#undef pr_fmt
++=======
++>>>>>>> 6f0960a760eb (x86/bugs: Remove md_clear_*_mitigation())
  #define pr_fmt(fmt)	"SRBDS: " fmt
  
  enum srbds_mitigations {
* Unmerged path arch/x86/kernel/cpu/bugs.c
