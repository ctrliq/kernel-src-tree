raid5: fix missing io accounting in raid5_align_endio()

jira LE-3845
Rebuild_History Non-Buildable kernel-4.18.0-553.69.1.el8_10
commit-author Yu Kuai <yukuai3@huawei.com>
commit 05048cbccab79e9fb9030274170ccd710fe69474
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.69.1.el8_10/05048cbc.failed

Io will only be accounted as done from raid5_align_endio() if the io
succeeded, and io inflight counter will be leaked if such io failed.

Fix this problem by switching to use md_account_bio() for io accounting.

	Signed-off-by: Yu Kuai <yukuai3@huawei.com>
	Reviewed-by: Xiao Ni <xni@redhat.com>
	Signed-off-by: Song Liu <song@kernel.org>
Link: https://lore.kernel.org/r/20230621165110.1498313-4-yukuai1@huaweicloud.com
(cherry picked from commit 05048cbccab79e9fb9030274170ccd710fe69474)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index a8595925e153,32a87193bad7..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -5522,26 -5468,17 +5522,32 @@@ static struct bio *remove_bio_from_retr
   */
  static void raid5_align_endio(struct bio *bi)
  {
++<<<<<<< HEAD
 +	struct md_io_acct *md_io_acct = bi->bi_private;
 +	struct bio *raid_bi = md_io_acct->orig_bio;
 +	struct mddev *mddev;
 +	struct r5conf *conf;
 +	struct md_rdev *rdev;
 +	blk_status_t error = bi->bi_status;
 +	unsigned long start_time = md_io_acct->start_time;
++=======
+ 	struct bio *raid_bi = bi->bi_private;
+ 	struct md_rdev *rdev = (void *)raid_bi->bi_next;
+ 	struct mddev *mddev = rdev->mddev;
+ 	struct r5conf *conf = mddev->private;
+ 	blk_status_t error = bi->bi_status;
++>>>>>>> 05048cbccab7 (raid5: fix missing io accounting in raid5_align_endio())
  
  	bio_put(bi);
- 
- 	rdev = (void*)raid_bi->bi_next;
  	raid_bi->bi_next = NULL;
- 	mddev = rdev->mddev;
- 	conf = mddev->private;
- 
  	rdev_dec_pending(rdev, conf->mddev);
  
  	if (!error) {
++<<<<<<< HEAD
 +		if (blk_queue_io_stat(raid_bi->bi_disk->queue))
 +			bio_end_io_acct(raid_bi, start_time);
++=======
++>>>>>>> 05048cbccab7 (raid5: fix missing io accounting in raid5_align_endio())
  		bio_endio(raid_bi);
  		if (atomic_dec_and_test(&conf->active_aligned_reads))
  			wake_up(&conf->wait_for_quiescent);
@@@ -5560,7 -5497,6 +5566,10 @@@ static int raid5_read_one_chunk(struct 
  	struct md_rdev *rdev;
  	sector_t sector, end_sector, first_bad;
  	int bad_sectors, dd_idx;
++<<<<<<< HEAD
 +	struct md_io_acct *md_io_acct;
++=======
++>>>>>>> 05048cbccab7 (raid5: fix missing io accounting in raid5_align_endio())
  	bool did_inc;
  
  	if (!in_chunk_boundary(mddev, raid_bio)) {
@@@ -5597,16 -5533,13 +5606,26 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	align_bio = bio_clone_fast(raid_bio, GFP_NOIO, &mddev->io_acct_set);
 +	md_io_acct = container_of(align_bio, struct md_io_acct, bio_clone);
 +	raid_bio->bi_next = (void *)rdev;
 +	if (blk_queue_io_stat(raid_bio->bi_disk->queue))
 +		md_io_acct->start_time = bio_start_io_acct(raid_bio);
 +	md_io_acct->orig_bio = raid_bio;
 +
 +	bio_set_dev(align_bio, rdev->bdev);
 +	align_bio->bi_end_io = raid5_align_endio;
 +	align_bio->bi_private = md_io_acct;
++=======
+ 	md_account_bio(mddev, &raid_bio);
+ 	raid_bio->bi_next = (void *)rdev;
+ 
+ 	align_bio = bio_alloc_clone(rdev->bdev, raid_bio, GFP_NOIO,
+ 				    &mddev->bio_set);
+ 	align_bio->bi_end_io = raid5_align_endio;
+ 	align_bio->bi_private = raid_bio;
++>>>>>>> 05048cbccab7 (raid5: fix missing io accounting in raid5_align_endio())
  	align_bio->bi_iter.bi_sector = sector;
  
  	/* No reshape active, so we can trust rdev->data_offset */
* Unmerged path drivers/md/raid5.c
