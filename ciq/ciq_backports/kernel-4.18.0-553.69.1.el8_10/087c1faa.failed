ipv6: mcast: extend RCU protection in igmp6_send()

jira LE-3845
cve CVE-2025-21759
Rebuild_History Non-Buildable kernel-4.18.0-553.69.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 087c1faa594fa07a66933d750c0b2610aa1a2946
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.69.1.el8_10/087c1faa.failed

igmp6_send() can be called without RTNL or RCU being held.

Extend RCU protection so that we can safely fetch the net pointer
and avoid a potential UAF.

Note that we no longer can use sock_alloc_send_skb() because
ipv6.igmp_sk uses GFP_KERNEL allocations which can sleep.

Instead use alloc_skb() and charge the net->ipv6.igmp_sk
socket under RCU protection.

Fixes: b8ad0cbc58f7 ("[NETNS][IPV6] mcast - handle several network namespace")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Link: https://patch.msgid.link/20250207135841.1948589-9-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 087c1faa594fa07a66933d750c0b2610aa1a2946)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/mcast.c
diff --cc net/ipv6/mcast.c
index 109d8cd70433,81a739ebf709..000000000000
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@@ -2009,17 -2190,15 +2009,23 @@@ static void igmp6_send(struct in6_addr 
  	payload_len = len + sizeof(ra);
  	full_len = sizeof(struct ipv6hdr) + payload_len;
  
+ 	skb = alloc_skb(hlen + tlen + full_len, GFP_KERNEL);
+ 
  	rcu_read_lock();
++<<<<<<< HEAD
 +	IP6_UPD_PO_STATS(net, __in6_dev_get(dev),
 +		      IPSTATS_MIB_OUT, full_len);
 +	rcu_read_unlock();
 +
 +	skb = sock_alloc_send_skb(sk, hlen + tlen + full_len, 1, &err);
++=======
++>>>>>>> 087c1faa594f (ipv6: mcast: extend RCU protection in igmp6_send())
  
+ 	net = dev_net_rcu(dev);
+ 	idev = __in6_dev_get(dev);
+ 	IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTREQUESTS);
  	if (!skb) {
- 		rcu_read_lock();
- 		IP6_INC_STATS(net, __in6_dev_get(dev),
- 			      IPSTATS_MIB_OUTDISCARDS);
+ 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
  		rcu_read_unlock();
  		return;
  	}
* Unmerged path net/ipv6/mcast.c
