md/raid1: switch to use md_account_bio() for io accounting

jira LE-3845
Rebuild_History Non-Buildable kernel-4.18.0-553.69.1.el8_10
commit-author Yu Kuai <yukuai3@huawei.com>
commit bb2a9acefaf9ce5bbc1e70f407e34599233d0243
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.69.1.el8_10/bb2a9ace.failed

Two problems can be fixed this way:

1) 'active_io' will represent inflight io instead of io that is
dispatching.

2) If io accounting is enabled or disabled while io is still inflight,
bio_start_io_acct() and bio_end_io_acct() is not balanced and io
inflight counter will be leaked.

	Signed-off-by: Yu Kuai <yukuai3@huawei.com>
	Reviewed-by: Xiao Ni <xni@redhat.com>
	Signed-off-by: Song Liu <song@kernel.org>
Link: https://lore.kernel.org/r/20230621165110.1498313-5-yukuai1@huaweicloud.com
(cherry picked from commit bb2a9acefaf9ce5bbc1e70f407e34599233d0243)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index be9f5fe29baa,06fa1580501f..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -308,8 -304,6 +308,11 @@@ static void call_bio_endio(struct r1bi
  	if (!test_bit(R1BIO_Uptodate, &r1_bio->state))
  		bio->bi_status = BLK_STS_IOERR;
  
++<<<<<<< HEAD
 +	if (blk_queue_io_stat(bio->bi_disk->queue))
 +		bio_end_io_acct(bio, r1_bio->start_time);
++=======
++>>>>>>> bb2a9acefaf9 (md/raid1: switch to use md_account_bio() for io accounting)
  	bio_endio(bio);
  }
  
@@@ -1342,11 -1301,12 +1345,20 @@@ static void raid1_read_request(struct m
  	}
  
  	r1_bio->read_disk = rdisk;
++<<<<<<< HEAD
 +
 +	if (!r1bio_existed && blk_queue_io_stat(bio->bi_disk->queue))
 +		r1_bio->start_time = bio_start_io_acct(bio);
 +
 +	read_bio = bio_clone_fast(bio, gfp, &mddev->bio_set);
++=======
+ 	if (!r1bio_existed) {
+ 		md_account_bio(mddev, &bio);
+ 		r1_bio->master_bio = bio;
+ 	}
+ 	read_bio = bio_alloc_clone(mirror->rdev->bdev, bio, gfp,
+ 				   &mddev->bio_set);
++>>>>>>> bb2a9acefaf9 (md/raid1: switch to use md_account_bio() for io accounting)
  
  	r1_bio->bios[rdisk] = read_bio;
  
@@@ -1545,8 -1498,8 +1557,13 @@@ static void raid1_write_request(struct 
  		r1_bio->sectors = max_sectors;
  	}
  
++<<<<<<< HEAD
 +	if (blk_queue_io_stat(bio->bi_disk->queue))
 +		r1_bio->start_time = bio_start_io_acct(bio);
++=======
+ 	md_account_bio(mddev, &bio);
+ 	r1_bio->master_bio = bio;
++>>>>>>> bb2a9acefaf9 (md/raid1: switch to use md_account_bio() for io accounting)
  	atomic_set(&r1_bio->remaining, 1);
  	atomic_set(&r1_bio->behind_remaining, 0);
  
* Unmerged path drivers/md/raid1.c
diff --git a/drivers/md/raid1.h b/drivers/md/raid1.h
index ccf10e59b116..b7eb09e8c025 100644
--- a/drivers/md/raid1.h
+++ b/drivers/md/raid1.h
@@ -158,7 +158,6 @@ struct r1bio {
 	sector_t		sector;
 	int			sectors;
 	unsigned long		state;
-	unsigned long		start_time;
 	struct mddev		*mddev;
 	/*
 	 * original bio going to /dev/mdx
