md/md-bitmap: remove the last parameter for bimtap_ops->endwrite()

jira LE-3845
Rebuild_History Non-Buildable kernel-4.18.0-553.69.1.el8_10
commit-author Yu Kuai <yukuai3@huawei.com>
commit 4f0e7d0e03b7b80af84759a9e7cfb0f81ac4adae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.69.1.el8_10/4f0e7d0e.failed

For the case that IO failed for one rdev, the bit will be mark as NEEDED
in following cases:

1) If badblocks is set and rdev is not faulty;
2) If rdev is faulty;

Case 1) is useless because synchronize data to badblocks make no sense.
Case 2) can be replaced with mddev->degraded.

Also remove R1BIO_Degraded, R10BIO_Degraded and STRIPE_DEGRADED since
case 2) no longer use them.

	Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Link: https://lore.kernel.org/r/20250109015145.158868-3-yukuai1@huaweicloud.com
	Signed-off-by: Song Liu <song@kernel.org>
(cherry picked from commit 4f0e7d0e03b7b80af84759a9e7cfb0f81ac4adae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md-bitmap.c
#	drivers/md/md-bitmap.h
#	drivers/md/raid1.c
#	drivers/md/raid10.c
#	drivers/md/raid5-cache.c
#	drivers/md/raid5.c
diff --cc drivers/md/md-bitmap.c
index 7f6620cf22e7,ec4ecd96e6b1..000000000000
--- a/drivers/md/md-bitmap.c
+++ b/drivers/md/md-bitmap.c
@@@ -1501,20 -1724,14 +1501,25 @@@ int md_bitmap_startwrite(struct bitmap 
  	}
  	return 0;
  }
 +EXPORT_SYMBOL(md_bitmap_startwrite);
  
++<<<<<<< HEAD
 +void md_bitmap_endwrite(struct bitmap *bitmap, sector_t offset,
 +			unsigned long sectors, int success, int behind)
++=======
+ static void bitmap_endwrite(struct mddev *mddev, sector_t offset,
+ 			    unsigned long sectors)
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  {
 -	struct bitmap *bitmap = mddev->bitmap;
 -
  	if (!bitmap)
  		return;
 +	if (behind) {
 +		if (atomic_dec_and_test(&bitmap->behind_writes))
 +			wake_up(&bitmap->behind_wait);
 +		pr_debug("dec write-behind count %d/%lu\n",
 +			 atomic_read(&bitmap->behind_writes),
 +			 bitmap->mddev->bitmap_info.max_write_behind);
 +	}
  
  	while (sectors) {
  		sector_t blocks;
diff --cc drivers/md/md-bitmap.h
index 8a3788c9bfef,31c93019c76b..000000000000
--- a/drivers/md/md-bitmap.h
+++ b/drivers/md/md-bitmap.h
@@@ -152,85 -58,58 +152,97 @@@ typedef struct bitmap_super_s 
   *    devices.  For raid10 it is the size of the array.
   */
  
 -struct md_bitmap_stats {
 -	u64		events_cleared;
 -	int		behind_writes;
 -	bool		behind_wait;
 +#ifdef __KERNEL__
  
 -	unsigned long	missing_pages;
 -	unsigned long	file_pages;
 -	unsigned long	sync_size;
 -	unsigned long	pages;
 -	struct file	*file;
 +/* the in-memory bitmap is represented by bitmap_pages */
 +struct bitmap_page {
 +	/*
 +	 * map points to the actual memory page
 +	 */
 +	char *map;
 +	/*
 +	 * in emergencies (when map cannot be alloced), hijack the map
 +	 * pointer and use it as two counters itself
 +	 */
 +	unsigned int hijacked:1;
 +	/*
 +	 * If any counter in this page is '1' or '2' - and so could be
 +	 * cleared then that page is marked as 'pending'
 +	 */
 +	unsigned int pending:1;
 +	/*
 +	 * count of dirty bits on the page
 +	 */
 +	unsigned int  count:30;
  };
  
 -struct bitmap_operations {
 -	bool (*enabled)(struct mddev *mddev);
 -	int (*create)(struct mddev *mddev, int slot);
 -	int (*resize)(struct mddev *mddev, sector_t blocks, int chunksize,
 -		      bool init);
 -
 -	int (*load)(struct mddev *mddev);
 -	void (*destroy)(struct mddev *mddev);
 -	void (*flush)(struct mddev *mddev);
 -	void (*write_all)(struct mddev *mddev);
 -	void (*dirty_bits)(struct mddev *mddev, unsigned long s,
 -			   unsigned long e);
 -	void (*unplug)(struct mddev *mddev, bool sync);
 -	void (*daemon_work)(struct mddev *mddev);
 -
 -	void (*start_behind_write)(struct mddev *mddev);
 -	void (*end_behind_write)(struct mddev *mddev);
 -	void (*wait_behind_writes)(struct mddev *mddev);
 +/* the main bitmap structure - one per mddev */
 +struct bitmap {
  
 +	struct bitmap_counts {
 +		spinlock_t lock;
 +		struct bitmap_page *bp;
 +		unsigned long pages;		/* total number of pages
 +						 * in the bitmap */
 +		unsigned long missing_pages;	/* number of pages
 +						 * not yet allocated */
 +		unsigned long chunkshift;	/* chunksize = 2^chunkshift
 +						 * (for bitops) */
 +		unsigned long chunks;		/* Total number of data
 +						 * chunks for the array */
 +	} counts;
 +
 +	struct mddev *mddev; /* the md device that the bitmap is for */
 +
++<<<<<<< HEAD
 +	__u64	events_cleared;
 +	int need_sync;
++=======
+ 	int (*startwrite)(struct mddev *mddev, sector_t offset,
+ 			  unsigned long sectors);
+ 	void (*endwrite)(struct mddev *mddev, sector_t offset,
+ 			 unsigned long sectors);
+ 	bool (*start_sync)(struct mddev *mddev, sector_t offset,
+ 			   sector_t *blocks, bool degraded);
+ 	void (*end_sync)(struct mddev *mddev, sector_t offset, sector_t *blocks);
+ 	void (*cond_end_sync)(struct mddev *mddev, sector_t sector, bool force);
+ 	void (*close_sync)(struct mddev *mddev);
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
 +
 +	struct bitmap_storage {
 +		struct file *file;		/* backing disk file */
 +		struct page *sb_page;		/* cached copy of the bitmap
 +						 * file superblock */
 +		struct page **filemap;		/* list of cache pages for
 +						 * the file */
 +		unsigned long *filemap_attr;	/* attributes associated
 +						 * w/ filemap pages */
 +		unsigned long file_pages;	/* number of pages in the file*/
 +		unsigned long bytes;		/* total bytes in the bitmap */
 +	} storage;
 +
 +	unsigned long flags;
 +
 +	int allclean;
 +
 +	atomic_t behind_writes;
 +	unsigned long behind_writes_used; /* highest actual value at runtime */
  
 -	void (*update_sb)(void *data);
 -	int (*get_stats)(void *data, struct md_bitmap_stats *stats);
 -
 -	void (*sync_with_cluster)(struct mddev *mddev,
 -				  sector_t old_lo, sector_t old_hi,
 -				  sector_t new_lo, sector_t new_hi);
 -	void *(*get_from_slot)(struct mddev *mddev, int slot);
 -	int (*copy_from_slot)(struct mddev *mddev, int slot, sector_t *lo,
 -			      sector_t *hi, bool clear_bits);
 -	void (*set_pages)(void *data, unsigned long pages);
 -	void (*free)(void *data);
 +	/*
 +	 * the bitmap daemon - periodically wakes up and sweeps the bitmap
 +	 * file, cleaning up bits and flushing out pages to disk as necessary
 +	 */
 +	unsigned long daemon_lastrun; /* jiffies of last run */
 +	unsigned long last_end_sync; /* when we lasted called end_sync to
 +				      * update bitmap with resync progress */
 +
 +	atomic_t pending_writes; /* pending writes to the bitmap file */
 +	wait_queue_head_t write_wait;
 +	wait_queue_head_t overflow_wait;
 +	wait_queue_head_t behind_wait;
 +
 +	struct kernfs_node *sysfs_can_clear;
 +	int cluster_slot;		/* Slot offset for clustered env */
  };
  
  /* the bitmap API */
diff --cc drivers/md/raid1.c
index be9f5fe29baa,4d09d85321b6..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -426,12 -419,12 +426,17 @@@ static void close_write(struct r1bio *r
  		bio_put(r1_bio->behind_master_bio);
  		r1_bio->behind_master_bio = NULL;
  	}
 -
 -	if (test_bit(R1BIO_BehindIO, &r1_bio->state))
 -		mddev->bitmap_ops->end_behind_write(mddev);
  	/* clear the bitmap if all writes complete successfully */
++<<<<<<< HEAD
 +	md_bitmap_endwrite(r1_bio->mddev->bitmap, r1_bio->sector,
 +			   r1_bio->sectors,
 +			   !test_bit(R1BIO_Degraded, &r1_bio->state),
 +			   test_bit(R1BIO_BehindIO, &r1_bio->state));
 +	md_write_end(r1_bio->mddev);
++=======
+ 	mddev->bitmap_ops->endwrite(mddev, r1_bio->sector, r1_bio->sectors);
+ 	md_write_end(mddev);
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  }
  
  static void r1_bio_write_done(struct r1bio *r1_bio)
@@@ -1445,20 -1529,12 +1448,17 @@@ static void raid1_write_request(struct 
  		 * write-mostly, which means we could allocate write behind
  		 * bio later.
  		 */
 -		if (!is_discard && rdev && test_bit(WriteMostly, &rdev->flags))
 +		if (rdev && test_bit(WriteMostly, &rdev->flags))
  			write_behind = true;
  
 +		if (rdev && unlikely(test_bit(Blocked, &rdev->flags))) {
 +			atomic_inc(&rdev->nr_pending);
 +			blocked_rdev = rdev;
 +			break;
 +		}
  		r1_bio->bios[i] = NULL;
- 		if (!rdev || test_bit(Faulty, &rdev->flags)) {
- 			if (i < conf->raid_disks)
- 				set_bit(R1BIO_Degraded, &r1_bio->state);
+ 		if (!rdev || test_bit(Faulty, &rdev->flags))
  			continue;
- 		}
  
  		atomic_inc(&rdev->nr_pending);
  		if (test_bit(WriteErrorSeen, &rdev->flags)) {
diff --cc drivers/md/raid10.c
index b1a170bf1f6a,340a4710c222..000000000000
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@@ -432,12 -426,11 +432,17 @@@ static void raid10_end_read_request(str
  
  static void close_write(struct r10bio *r10_bio)
  {
 -	struct mddev *mddev = r10_bio->mddev;
 -
  	/* clear the bitmap if all writes complete successfully */
++<<<<<<< HEAD
 +	md_bitmap_endwrite(r10_bio->mddev->bitmap, r10_bio->sector,
 +			   r10_bio->sectors,
 +			   !test_bit(R10BIO_Degraded, &r10_bio->state),
 +			   0);
 +	md_write_end(r10_bio->mddev);
++=======
+ 	mddev->bitmap_ops->endwrite(mddev, r10_bio->sector, r10_bio->sectors);
+ 	md_write_end(mddev);
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  }
  
  static void one_write_done(struct r10bio *r10_bio)
diff --cc drivers/md/raid5-cache.c
index b96cdbb7b148,217b3223ef70..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -322,10 -313,8 +322,15 @@@ void r5c_handle_cached_data_endio(struc
  		if (sh->dev[i].written) {
  			set_bit(R5_UPTODATE, &sh->dev[i].flags);
  			r5c_return_dev_pending_writes(conf, &sh->dev[i]);
++<<<<<<< HEAD
 +			md_bitmap_endwrite(conf->mddev->bitmap, sh->sector,
 +					   RAID5_STRIPE_SECTORS(conf),
 +					   !test_bit(STRIPE_DEGRADED, &sh->state),
 +					   0);
++=======
+ 			conf->mddev->bitmap_ops->endwrite(conf->mddev,
+ 					sh->sector, RAID5_STRIPE_SECTORS(conf));
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  		}
  	}
  }
diff --cc drivers/md/raid5.c
index a8595925e153,a5a619400d8f..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -1369,11 -1342,9 +1369,9 @@@ again
  			if (should_defer && op_is_write(op))
  				bio_list_add(&pending_bios, rbi);
  			else
 -				submit_bio_noacct(rbi);
 +				generic_make_request(rbi);
  		}
  		if (!rdev && !rrdev) {
- 			if (op_is_write(op))
- 				set_bit(STRIPE_DEGRADED, &sh->state);
  			pr_debug("skip op %d on disc %d for sector %llu\n",
  				bi->bi_opf, i, (unsigned long long)sh->sector);
  			clear_bit(R5_LOCKED, &sh->dev[i].flags);
@@@ -3733,8 -3660,8 +3730,13 @@@ handle_failed_stripe(struct r5conf *con
  			bi = nextbi;
  		}
  		if (bitmap_end)
++<<<<<<< HEAD
 +			md_bitmap_endwrite(conf->mddev->bitmap, sh->sector,
 +					   RAID5_STRIPE_SECTORS(conf), 0, 0);
++=======
+ 			conf->mddev->bitmap_ops->endwrite(conf->mddev,
+ 					sh->sector, RAID5_STRIPE_SECTORS(conf));
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  		bitmap_end = 0;
  		/* and fail all 'written' */
  		bi = sh->dev[i].written;
@@@ -3779,8 -3706,8 +3781,13 @@@
  			}
  		}
  		if (bitmap_end)
++<<<<<<< HEAD
 +			md_bitmap_endwrite(conf->mddev->bitmap, sh->sector,
 +					   RAID5_STRIPE_SECTORS(conf), 0, 0);
++=======
+ 			conf->mddev->bitmap_ops->endwrite(conf->mddev,
+ 					sh->sector, RAID5_STRIPE_SECTORS(conf));
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  		/* If we were in the middle of a write the parity block might
  		 * still be locked - so just clear all R5_LOCKED flags
  		 */
@@@ -4131,10 -4056,8 +4138,15 @@@ returnbi
  					bio_endio(wbi);
  					wbi = wbi2;
  				}
++<<<<<<< HEAD
 +				md_bitmap_endwrite(conf->mddev->bitmap, sh->sector,
 +						   RAID5_STRIPE_SECTORS(conf),
 +						   !test_bit(STRIPE_DEGRADED, &sh->state),
 +						   0);
++=======
+ 				conf->mddev->bitmap_ops->endwrite(conf->mddev,
+ 					sh->sector, RAID5_STRIPE_SECTORS(conf));
++>>>>>>> 4f0e7d0e03b7 (md/md-bitmap: remove the last parameter for bimtap_ops->endwrite())
  				if (head_sh->batch_head) {
  					sh = list_first_entry(&sh->batch_list,
  							      struct stripe_head,
* Unmerged path drivers/md/md-bitmap.c
* Unmerged path drivers/md/md-bitmap.h
* Unmerged path drivers/md/raid1.c
diff --git a/drivers/md/raid1.h b/drivers/md/raid1.h
index ccf10e59b116..cbe9da5be3d5 100644
--- a/drivers/md/raid1.h
+++ b/drivers/md/raid1.h
@@ -189,7 +189,6 @@ struct r1bio {
 enum r1bio_state {
 	R1BIO_Uptodate,
 	R1BIO_IsSync,
-	R1BIO_Degraded,
 	R1BIO_BehindIO,
 /* Set ReadError on bios that experience a readerror so that
  * raid1d knows what to do with them.
* Unmerged path drivers/md/raid10.c
diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index e9a0efc5a831..1edf9d2f8b17 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -163,7 +163,6 @@ enum r10bio_state {
 	R10BIO_IsSync,
 	R10BIO_IsRecover,
 	R10BIO_IsReshape,
-	R10BIO_Degraded,
 /* Set ReadError on bios that experience a read error
  * so that raid10d knows what to do with them.
  */
* Unmerged path drivers/md/raid5-cache.c
* Unmerged path drivers/md/raid5.c
diff --git a/drivers/md/raid5.h b/drivers/md/raid5.h
index daddd305349a..5af31655716e 100644
--- a/drivers/md/raid5.h
+++ b/drivers/md/raid5.h
@@ -358,7 +358,6 @@ enum {
 	STRIPE_REPLACED,
 	STRIPE_PREREAD_ACTIVE,
 	STRIPE_DELAYED,
-	STRIPE_DEGRADED,
 	STRIPE_BIT_DELAY,
 	STRIPE_EXPANDING,
 	STRIPE_EXPAND_SOURCE,
