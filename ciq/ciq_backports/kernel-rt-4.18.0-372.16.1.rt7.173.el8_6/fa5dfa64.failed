gfs2: buffered write prefaulting

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.16.1.rt7.173.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit fa5dfa645d85910d747f4e0c97f19e5e97d1c270
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.16.1.rt7.173.el8_6/fa5dfa64.failed

In gfs2_file_buffered_write, to increase the likelihood that all the
user memory we're trying to write will be resident in memory, carry out
the write in chunks and fault in each chunk of user memory before trying
to write it.  Otherwise, some workloads will trigger frequent short
"internal" writes, causing filesystem blocks to be allocated and then
partially deallocated again when writing into holes, which is wasteful
and breaks reservations.

Neither the chunked writes nor any of the short "internal" writes are
user visible.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit fa5dfa645d85910d747f4e0c97f19e5e97d1c270)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 37f4489b53a0,5eda1bcc85e3..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -771,10 -778,8 +771,10 @@@ static inline bool should_fault_in_page
  	size_t count = iov_iter_count(i);
  	size_t size, offs;
  
- 	if (likely(!count))
+ 	if (!count)
  		return false;
 +	if (ret <= 0 && ret != -EFAULT)
 +		return false;
  	if (!iter_is_iovec(i))
  		return false;
  
@@@ -978,23 -1069,12 +991,29 @@@ retry_under_glock
  	if (inode == sdp->sd_rindex)
  		gfs2_glock_dq_uninit(statfs_gh);
  
 -	if (ret <= 0 && ret != -EFAULT)
 -		goto out_unlock;
 +	from->count = orig_count - read;
 +	if (should_fault_in_pages(ret, from, &prev_count, &window_size)) {
 +		size_t leftover;
  
++<<<<<<< HEAD
 +		gfs2_holder_allow_demote(gh);
 +		leftover = fault_in_iov_iter_readable(from, window_size);
 +		gfs2_holder_disallow_demote(gh);
 +		if (leftover != window_size) {
 +			from->count = min(from->count, window_size - leftover);
 +			if (!gfs2_holder_queued(gh)) {
 +				if (read)
 +					goto out_uninit;
 +				goto retry;
 +			}
 +			goto retry_under_glock;
 +		}
 +	}
++=======
+ 	from->count = orig_count - written;
+ 	if (should_fault_in_pages(from, iocb, &prev_count, &window_size))
+ 		goto retry_under_glock;
++>>>>>>> fa5dfa645d85 (gfs2: buffered write prefaulting)
  out_unlock:
  	if (gfs2_holder_queued(gh))
  		gfs2_glock_dq(gh);
* Unmerged path fs/gfs2/file.c
