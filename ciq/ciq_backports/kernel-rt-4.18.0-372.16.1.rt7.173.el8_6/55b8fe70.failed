gup: Introduce FOLL_NOFAULT flag to disable page faults

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.16.1.rt7.173.el8_6
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 55b8fe703bc51200d4698596c90813453b35ae63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.16.1.rt7.173.el8_6/55b8fe70.failed

Introduce a new FOLL_NOFAULT flag that causes get_user_pages to return
-EFAULT when it would otherwise trigger a page fault.  This is roughly
similar to FOLL_FAST_ONLY but available on all architectures, and less
fragile.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 55b8fe703bc51200d4698596c90813453b35ae63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
diff --cc include/linux/mm.h
index a5582d37267e,2f0e6b9f8f3b..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -2752,8 -2851,8 +2752,13 @@@ struct page *follow_page(struct vm_area
  #define FOLL_FORCE	0x10	/* get_user_pages read/write w/o permission */
  #define FOLL_NOWAIT	0x20	/* if a disk transfer is needed, start the IO
  				 * and return without waiting upon it */
++<<<<<<< HEAD
 +#define FOLL_POPULATE	0x40	/* fault in page */
 +#define FOLL_SPLIT	0x80	/* don't return transhuge pages, split them */
++=======
+ #define FOLL_POPULATE	0x40	/* fault in pages (with FOLL_MLOCK) */
+ #define FOLL_NOFAULT	0x80	/* do not fault in pages */
++>>>>>>> 55b8fe703bc5 (gup: Introduce FOLL_NOFAULT flag to disable page faults)
  #define FOLL_HWPOISON	0x100	/* check page is hwpoisoned */
  #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
  #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
* Unmerged path include/linux/mm.h
diff --git a/mm/gup.c b/mm/gup.c
index 992475088545..18212ec6a741 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -929,6 +929,8 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
+	if (*flags & FOLL_NOFAULT)
+		return -EFAULT;
 	if (*flags & FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (*flags & FOLL_REMOTE)
@@ -2740,7 +2742,7 @@ static int internal_get_user_pages_fast(unsigned long start,
 
 	if (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |
 				       FOLL_FORCE | FOLL_PIN | FOLL_GET |
-				       FOLL_FAST_ONLY)))
+				       FOLL_FAST_ONLY | FOLL_NOFAULT)))
 		return -EINVAL;
 
 	if (gup_flags & FOLL_PIN)
