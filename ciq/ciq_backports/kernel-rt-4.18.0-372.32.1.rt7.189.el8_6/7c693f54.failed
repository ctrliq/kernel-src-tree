x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS

jira LE-1907
cve CVE-2022-23825
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.32.1.rt7.189.el8_6
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit 7c693f54c873691a4b7da05c7e0f74e67745d144
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.32.1.rt7.189.el8_6/7c693f54.failed

Extend spectre_v2= boot option with Kernel IBRS.

  [jpoimboe: no STIBP with IBRS]

	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 7c693f54c873691a4b7da05c7e0f74e67745d144)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/kernel-parameters.txt
#	arch/x86/include/asm/nospec-branch.h
#	arch/x86/kernel/cpu/bugs.c
diff --cc Documentation/admin-guide/kernel-parameters.txt
index 25c1d34da432,0aeea69e9b7a..000000000000
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@@ -4860,12 -5590,6 +4860,15 @@@
  			eibrs,retpoline   - enhanced IBRS + Retpolines
  			eibrs,lfence      - enhanced IBRS + LFENCE
  			ibrs		  - use IBRS to protect kernel
++<<<<<<< HEAD
 +			ibrs_always	  - use IBRS to protect both kernel
 +					    and userland
 +			retpoline,ibrs_user
 +					  - replace indirect branches
 +					    with retpolines and use
 +					    IBRS to protect userland
++=======
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  
  			Not specifying this option is equivalent to
  			spectre_v2=auto.
diff --cc arch/x86/include/asm/nospec-branch.h
index 12722d2e7709,e14046daa7ba..000000000000
--- a/arch/x86/include/asm/nospec-branch.h
+++ b/arch/x86/include/asm/nospec-branch.h
@@@ -223,8 -212,6 +223,11 @@@ enum spectre_v2_mitigation 
  	SPECTRE_V2_EIBRS_RETPOLINE,
  	SPECTRE_V2_EIBRS_LFENCE,
  	SPECTRE_V2_IBRS,
++<<<<<<< HEAD
 +	SPECTRE_V2_RETPOLINE_IBRS_USER,
 +	SPECTRE_V2_IBRS_ALWAYS,
++=======
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  };
  
  /* The indirect branch speculation control variants */
diff --cc arch/x86/kernel/cpu/bugs.c
index ff842ff87312,2d7896493220..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -796,9 -972,7 +796,13 @@@ enum spectre_v2_mitigation_cmd 
  	SPECTRE_V2_CMD_EIBRS,
  	SPECTRE_V2_CMD_EIBRS_RETPOLINE,
  	SPECTRE_V2_CMD_EIBRS_LFENCE,
++<<<<<<< HEAD
 +	SPECTRE_V2_CMD_RETPOLINE_IBRS_USER,
  	SPECTRE_V2_CMD_IBRS,
 +	SPECTRE_V2_CMD_IBRS_ALWAYS,
++=======
++	SPECTRE_V2_CMD_IBRS,
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  };
  
  enum spectre_v2_user_cmd {
@@@ -970,9 -1152,7 +975,13 @@@ static const char * const spectre_v2_st
  	[SPECTRE_V2_EIBRS]			= "Mitigation: Enhanced IBRS",
  	[SPECTRE_V2_EIBRS_LFENCE]		= "Mitigation: Enhanced IBRS + LFENCE",
  	[SPECTRE_V2_EIBRS_RETPOLINE]		= "Mitigation: Enhanced IBRS + Retpolines",
++<<<<<<< HEAD
 +	[SPECTRE_V2_IBRS]			= "Mitigation: IBRS (kernel)",
 +	[SPECTRE_V2_RETPOLINE_IBRS_USER]	= "Mitigation: Full retpoline and IBRS (user space)",
 +	[SPECTRE_V2_IBRS_ALWAYS]		= "Mitigation: IBRS (kernel and user space)",
++=======
+ 	[SPECTRE_V2_IBRS]			= "Mitigation: IBRS",
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  };
  
  static const struct {
@@@ -990,9 -1170,7 +999,13 @@@
  	{ "eibrs,lfence",	SPECTRE_V2_CMD_EIBRS_LFENCE,	  false },
  	{ "eibrs,retpoline",	SPECTRE_V2_CMD_EIBRS_RETPOLINE,	  false },
  	{ "auto",		SPECTRE_V2_CMD_AUTO,		  false },
++<<<<<<< HEAD
 +	{ "ibrs",		SPECTRE_V2_CMD_IBRS,		  false },
 +	{ "ibrs_always",	SPECTRE_V2_CMD_IBRS_ALWAYS,	  false },
 +	{ "retpoline,ibrs_user", SPECTRE_V2_CMD_RETPOLINE_IBRS_USER, false},
++=======
+ 	{ "ibrs",		SPECTRE_V2_CMD_IBRS,              false },
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  };
  
  static void __init spec_v2_print_cond(const char *reason, bool secure)
@@@ -1056,19 -1233,22 +1069,38 @@@ static enum spectre_v2_mitigation_cmd _
  		return SPECTRE_V2_CMD_AUTO;
  	}
  
++<<<<<<< HEAD
 +	if (cmd == SPECTRE_V2_CMD_IBRS ||
 +	    cmd == SPECTRE_V2_CMD_IBRS_ALWAYS ||
 +	    cmd == SPECTRE_V2_CMD_RETPOLINE_IBRS_USER) {
 +		if (!boot_cpu_has(X86_FEATURE_IBRS)) {
 +			pr_err("%s selected but CPU doesn't have IBRS. Switching to AUTO select\n",
 +				mitigation_options[i].option);
 +			return SPECTRE_V2_CMD_AUTO;
 +		}
 +		if (boot_cpu_has(X86_FEATURE_IBRS_ENHANCED)) {
 +			pr_err("%s selected but CPU has eIBRS. Fall back to use eIBRS instead\n",
 +				mitigation_options[i].option);
 +			return SPECTRE_V2_CMD_EIBRS;
 +		}
++=======
+ 	if (cmd == SPECTRE_V2_CMD_IBRS && boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) {
+ 		pr_err("%s selected but not Intel CPU. Switching to AUTO select\n",
+ 		       mitigation_options[i].option);
+ 		return SPECTRE_V2_CMD_AUTO;
+ 	}
+ 
+ 	if (cmd == SPECTRE_V2_CMD_IBRS && !boot_cpu_has(X86_FEATURE_IBRS)) {
+ 		pr_err("%s selected but CPU doesn't have IBRS. Switching to AUTO select\n",
+ 		       mitigation_options[i].option);
+ 		return SPECTRE_V2_CMD_AUTO;
+ 	}
+ 
+ 	if (cmd == SPECTRE_V2_CMD_IBRS && boot_cpu_has(X86_FEATURE_XENPV)) {
+ 		pr_err("%s selected but running as XenPV guest. Switching to AUTO select\n",
+ 		       mitigation_options[i].option);
+ 		return SPECTRE_V2_CMD_AUTO;
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  	}
  
  	spec_v2_print_cond(mitigation_options[i].option,
@@@ -1110,12 -1290,12 +1142,21 @@@ static void __init spectre_v2_select_mi
  			break;
  		}
  
++<<<<<<< HEAD
 +		/*
 +		 * For Skylake, we print a warning if IBRS isn't chosen.
 +		 */
 +		if (is_skylake_era() && boot_cpu_has(X86_FEATURE_IBRS)) {
 +			pr_warn("Using retpoline on Skylake-generation processors may not fully mitigate the vulnerability.\n");
 +			pr_warn("Add the \"spectre_v2=ibrs\" kernel boot flag to enable IBRS on Skylake systems that need full mitigation.\n");
++=======
+ 		if (boot_cpu_has_bug(X86_BUG_RETBLEED) &&
+ 		    retbleed_cmd != RETBLEED_CMD_OFF &&
+ 		    boot_cpu_has(X86_FEATURE_IBRS) &&
+ 		    boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) {
+ 			mode = SPECTRE_V2_IBRS;
+ 			break;
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  		}
  
  		mode = spectre_v2_select_retpoline();
@@@ -1134,6 -1314,9 +1175,12 @@@
  		mode = spectre_v2_select_retpoline();
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case SPECTRE_V2_CMD_IBRS:
+ 		mode = SPECTRE_V2_IBRS;
+ 		break;
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  
  	case SPECTRE_V2_CMD_EIBRS:
  		mode = SPECTRE_V2_EIBRS;
@@@ -1179,18 -1334,21 +1226,22 @@@
  	if (mode == SPECTRE_V2_EIBRS && unprivileged_ebpf_enabled())
  		pr_err(SPECTRE_V2_EIBRS_EBPF_MSG);
  
- 	if (spectre_v2_in_eibrs_mode(mode)) {
+ 	if (spectre_v2_in_ibrs_mode(mode)) {
  		/* Force it so VMEXIT will restore correctly */
  		x86_spec_ctrl_base |= SPEC_CTRL_IBRS;
 -		write_spec_ctrl_current(x86_spec_ctrl_base, true);
 +		wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
  	}
  
  	switch (mode) {
  	case SPECTRE_V2_NONE:
  	case SPECTRE_V2_EIBRS:
 +	default:
  		break;
  
+ 	case SPECTRE_V2_IBRS:
+ 		setup_force_cpu_cap(X86_FEATURE_KERNEL_IBRS);
+ 		break;
+ 
  	case SPECTRE_V2_LFENCE:
  	case SPECTRE_V2_EIBRS_LFENCE:
  		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_LFENCE);
@@@ -1217,18 -1375,17 +1268,29 @@@
  	pr_info("Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch\n");
  
  	/*
++<<<<<<< HEAD
 +	 * Retpoline means the kernel is safe because it has no indirect
 +	 * branches. Enhanced IBRS protects firmware too, so, enable restricted
 +	 * speculation around firmware calls only when Enhanced IBRS isn't
 +	 * supported or kernel IBRS isn't enabled.
++=======
+ 	 * Retpoline protects the kernel, but doesn't protect firmware.  IBRS
+ 	 * and Enhanced IBRS protect firmware too, so enable IBRS around
+ 	 * firmware calls only when IBRS / Enhanced IBRS aren't otherwise
+ 	 * enabled.
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  	 *
  	 * Use "mode" to check Enhanced IBRS instead of boot_cpu_has(), because
  	 * the user might select retpoline on the kernel command line and if
  	 * the CPU supports Enhanced IBRS, kernel might un-intentionally not
  	 * enable IBRS around firmware calls.
  	 */
++<<<<<<< HEAD
 +	if (boot_cpu_has(X86_FEATURE_IBRS) &&
 +	   !(x86_spec_ctrl_base & SPEC_CTRL_IBRS)) {
++=======
+ 	if (boot_cpu_has(X86_FEATURE_IBRS) && !spectre_v2_in_ibrs_mode(mode)) {
++>>>>>>> 7c693f54c873 (x86/speculation: Add spectre_v2=ibrs option to support Kernel IBRS)
  		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);
  		pr_info("Enabling Restricted Speculation for firmware calls\n");
  	}
* Unmerged path Documentation/admin-guide/kernel-parameters.txt
* Unmerged path arch/x86/include/asm/nospec-branch.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
