KVM: emulate: do not adjust size of fastop and setcc subroutines

jira LE-1907
cve CVE-2022-23825
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.32.1.rt7.189.el8_6
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 79629181607e801c0b41b8790ac4ee2eb5d7bc3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.32.1.rt7.189.el8_6/79629181.failed

Instead of doing complicated calculations to find the size of the subroutines
(which are even more complicated because they need to be stringified into
an asm statement), just hardcode to 16.

It is less dense for a few combinations of IBT/SLS/retbleed, but it has
the advantage of being really simple.

	Cc: stable@vger.kernel.org # 5.15.x: 84e7051c0bc1: x86/kvm: fix FASTOP_SIZE when return thunks are enabled
	Cc: stable@vger.kernel.org
	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 79629181607e801c0b41b8790ac4ee2eb5d7bc3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/emulate.c
diff --cc arch/x86/kvm/emulate.c
index 7745708ea5f4,f8382abe22ff..000000000000
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@@ -187,12 -189,10 +187,15 @@@
  #define X8(x...) X4(x), X4(x)
  #define X16(x...) X8(x), X8(x)
  
++<<<<<<< HEAD
 +#define NR_FASTOP (ilog2(sizeof(ulong)) + 1)
 +#define FASTOP_SIZE 8
 +
++=======
++>>>>>>> 79629181607e (KVM: emulate: do not adjust size of fastop and setcc subroutines)
  struct opcode {
 -	u64 flags;
 -	u8 intercept;
 -	u8 pad[7];
 +	u64 flags : 56;
 +	u64 intercept : 8;
  	union {
  		int (*execute)(struct x86_emulate_ctxt *ctxt);
  		const struct opcode *group;
@@@ -427,18 -436,27 +436,32 @@@ static int fastop(struct x86_emulate_ct
  	FOP_END
  
  /* Special case for SETcc - 1 instruction per cc */
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Depending on .config the SETcc functions look like:
+  *
+  * ENDBR			[4 bytes; CONFIG_X86_KERNEL_IBT]
+  * SETcc %al			[3 bytes]
+  * RET | JMP __x86_return_thunk	[1,5 bytes; CONFIG_RETHUNK]
+  * INT3				[1 byte; CONFIG_SLS]
+  */
+ #define SETCC_ALIGN	16
+ 
++>>>>>>> 79629181607e (KVM: emulate: do not adjust size of fastop and setcc subroutines)
  #define FOP_SETCC(op) \
 -	".align " __stringify(SETCC_ALIGN) " \n\t" \
 +	".align 4 \n\t" \
  	".type " #op ", @function \n\t" \
  	#op ": \n\t" \
 -	ASM_ENDBR \
  	#op " %al \n\t" \
 -	__FOP_RET(#op) \
 -	".skip " __stringify(SETCC_ALIGN) " - (.-" #op "), 0xcc \n\t"
 +	__FOP_RET(#op)
  
 -__FOP_START(setcc, SETCC_ALIGN)
 +asm(".pushsection .fixup, \"ax\"\n"
 +    "kvm_fastop_exception: xor %esi, %esi; ret\n"
 +    ".popsection");
 +
 +FOP_START(setcc)
  FOP_SETCC(seto)
  FOP_SETCC(setno)
  FOP_SETCC(setc)
* Unmerged path arch/x86/kvm/emulate.c
