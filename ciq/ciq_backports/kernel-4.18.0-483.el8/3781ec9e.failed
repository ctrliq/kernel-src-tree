gfs2: Uninline and improve glock_{set,clear}_object

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-483.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 3781ec9e09123d955b93fc8522ffb683a51f865d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-483.el8/3781ec9e.failed

Those functions have reached a size at which having them inline isn't
useful anymore, so uninline them.  In addition, report the glock name on
assertion failures.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 3781ec9e09123d955b93fc8522ffb683a51f865d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.h
diff --cc fs/gfs2/glock.h
index 885d044e536c,e4be9e4bc979..000000000000
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@@ -285,46 -308,6 +288,49 @@@ static inline bool gfs2_holder_queued(s
  	return !list_empty(&gh->gh_list);
  }
  
++<<<<<<< HEAD
 +/**
 + * glock_set_object - set the gl_object field of a glock
 + * @gl: the glock
 + * @object: the object
 + */
 +static inline void glock_set_object(struct gfs2_glock *gl, void *object)
 +{
 +	spin_lock(&gl->gl_lockref.lock);
 +	if (gfs2_assert_warn(gl->gl_name.ln_sbd, gl->gl_object == NULL))
 +		gfs2_dump_glock(NULL, gl, true);
 +	gl->gl_object = object;
 +	spin_unlock(&gl->gl_lockref.lock);
 +}
 +
 +/**
 + * glock_clear_object - clear the gl_object field of a glock
 + * @gl: the glock
 + * @object: the object
 + *
 + * I'd love to similarly add this:
 + *	else if (gfs2_assert_warn(gl->gl_sbd, gl->gl_object == object))
 + *		gfs2_dump_glock(NULL, gl, true);
 + * Unfortunately, that's not possible because as soon as gfs2_delete_inode
 + * frees the block in the rgrp, another process can reassign it for an I_NEW
 + * inode in gfs2_create_inode because that calls new_inode, not gfs2_iget.
 + * That means gfs2_delete_inode may subsequently try to call this function
 + * for a glock that's already pointing to a brand new inode. If we clear the
 + * new inode's gl_object, we'll introduce metadata corruption. Function
 + * gfs2_delete_inode calls clear_inode which calls gfs2_clear_inode which also
 + * tries to clear gl_object, so it's more than just gfs2_delete_inode.
 + *
 + */
 +static inline void glock_clear_object(struct gfs2_glock *gl, void *object)
 +{
 +	spin_lock(&gl->gl_lockref.lock);
 +	if (gl->gl_object == object)
 +		gl->gl_object = NULL;
 +	spin_unlock(&gl->gl_lockref.lock);
 +}
 +
++=======
++>>>>>>> 3781ec9e0912 (gfs2: Uninline and improve glock_{set,clear}_object)
  static inline void gfs2_holder_allow_demote(struct gfs2_holder *gh)
  {
  	struct gfs2_glock *gl = gh->gh_gl;
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index e1065b22de7e..eb7c9852877e 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -897,6 +897,48 @@ __acquires(&gl->gl_lockref.lock)
 	return;
 }
 
+/**
+ * glock_set_object - set the gl_object field of a glock
+ * @gl: the glock
+ * @object: the object
+ */
+void glock_set_object(struct gfs2_glock *gl, void *object)
+{
+	void *prev_object;
+
+	spin_lock(&gl->gl_lockref.lock);
+	prev_object = gl->gl_object;
+	gl->gl_object = object;
+	spin_unlock(&gl->gl_lockref.lock);
+	if (gfs2_assert_warn(gl->gl_name.ln_sbd, prev_object == NULL)) {
+		pr_warn("glock=%u/%llx\n",
+			gl->gl_name.ln_type,
+			(unsigned long long)gl->gl_name.ln_number);
+		gfs2_dump_glock(NULL, gl, true);
+	}
+}
+
+/**
+ * glock_clear_object - clear the gl_object field of a glock
+ * @gl: the glock
+ */
+void glock_clear_object(struct gfs2_glock *gl, void *object)
+{
+	void *prev_object;
+
+	spin_lock(&gl->gl_lockref.lock);
+	prev_object = gl->gl_object;
+	gl->gl_object = NULL;
+	spin_unlock(&gl->gl_lockref.lock);
+	if (gfs2_assert_warn(gl->gl_name.ln_sbd,
+			     prev_object == object || prev_object == NULL)) {
+		pr_warn("glock=%u/%llx\n",
+			gl->gl_name.ln_type,
+			(unsigned long long)gl->gl_name.ln_number);
+		gfs2_dump_glock(NULL, gl, true);
+	}
+}
+
 void gfs2_inode_remember_delete(struct gfs2_glock *gl, u64 generation)
 {
 	struct gfs2_inode_lvb *ri = (void *)gl->gl_lksb.sb_lvbptr;
* Unmerged path fs/gfs2/glock.h
