gfs2: Remove support for glock holder auto-demotion (2)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-483.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6b46a06100dd0e0ebe400573e94ccd09163bfd5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-483.el8/6b46a061.failed

As a follow-up to the previous commit, move the recovery related code in
__gfs2_glock_dq() to gfs2_glock_dq() where it better fits.  No
functional change.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6b46a06100dd0e0ebe400573e94ccd09163bfd5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index e05d4ce9aac6,524f3c96b9a4..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -1591,64 -1594,24 +1590,73 @@@ static void __gfs2_glock_dq(struct gfs2
  	int fast_path = 0;
  
  	/*
++<<<<<<< HEAD
 +	 * This while loop is similar to function demote_incompat_holders:
 +	 * If the glock is due to be demoted (which may be from another node
 +	 * or even if this holder is GL_NOCACHE), the weak holders are
 +	 * demoted as well, allowing the glock to be demoted.
 +	 */
 +	while (gh) {
 +		/*
 +		 * If we're in the process of file system withdraw, we cannot
 +		 * just dequeue any glocks until our journal is recovered, lest
 +		 * we introduce file system corruption. We need two exceptions
 +		 * to this rule: We need to allow unlocking of nondisk glocks
 +		 * and the glock for our own journal that needs recovery.
 +		 */
 +		if (test_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags) &&
 +		    glock_blocked_by_withdraw(gl) &&
 +		    gh->gh_gl != sdp->sd_jinode_gl) {
 +			sdp->sd_glock_dqs_held++;
 +			spin_unlock(&gl->gl_lockref.lock);
 +			might_sleep();
 +			wait_on_bit(&sdp->sd_flags, SDF_WITHDRAW_RECOVERY,
 +				    TASK_UNINTERRUPTIBLE);
 +			spin_lock(&gl->gl_lockref.lock);
 +		}
 +
 +		/*
 +		 * This holder should not be cached, so mark it for demote.
 +		 * Note: this should be done before the check for needs_demote
 +		 * below.
 +		 */
 +		if (gh->gh_flags & GL_NOCACHE)
 +			handle_callback(gl, LM_ST_UNLOCKED, 0, false);
++=======
+ 	 * This holder should not be cached, so mark it for demote.
+ 	 * Note: this should be done before the check for needs_demote
+ 	 * below.
+ 	 */
+ 	if (gh->gh_flags & GL_NOCACHE)
+ 		handle_callback(gl, LM_ST_UNLOCKED, 0, false);
++>>>>>>> 6b46a06100dd (gfs2: Remove support for glock holder auto-demotion (2))
  
 -	list_del_init(&gh->gh_list);
 -	clear_bit(HIF_HOLDER, &gh->gh_iflags);
 -	trace_gfs2_glock_queue(gh, 0);
 +		list_del_init(&gh->gh_list);
 +		clear_bit(HIF_HOLDER, &gh->gh_iflags);
 +		trace_gfs2_glock_queue(gh, 0);
  
 -	/*
 -	 * If there hasn't been a demote request we are done.
 -	 * (Let the remaining holders, if any, keep holding it.)
 -	 */
 -	if (!needs_demote(gl)) {
 -		if (list_empty(&gl->gl_holders))
 -			fast_path = 1;
 +		/*
 +		 * If there hasn't been a demote request we are done.
 +		 * (Let the remaining holders, if any, keep holding it.)
 +		 */
 +		if (!needs_demote(gl)) {
 +			if (list_empty(&gl->gl_holders))
 +				fast_path = 1;
 +			break;
 +		}
 +		/*
 +		 * If we have another strong holder (we cannot auto-demote)
 +		 * we are done. It keeps holding it until it is done.
 +		 */
 +		if (find_first_strong_holder(gl))
 +			break;
 +
 +		/*
 +		 * If we have a weak holder at the head of the list, it
 +		 * (and all others like it) must be auto-demoted. If there
 +		 * are no more weak holders, we exit the while loop.
 +		 */
 +		gh = find_first_holder(gl);
  	}
  
  	if (!test_bit(GLF_LFLUSH, &gl->gl_flags) && demote_ok(gl))
* Unmerged path fs/gfs2/glock.c
