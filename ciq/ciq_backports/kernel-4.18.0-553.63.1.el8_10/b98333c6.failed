dlm: fix possible lkb_resource null dereference

jira LE-3629
Rebuild_History Non-Buildable kernel-4.18.0-553.63.1.el8_10
commit-author Alexander Aring <aahringo@redhat.com>
commit b98333c67daf887c724cd692e88e2db9418c0861
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.63.1.el8_10/b98333c6.failed

This patch fixes a possible null pointer dereference when this function is
called from request_lock() as lkb->lkb_resource is not assigned yet,
only after validate_lock_args() by calling attach_lkb(). Another issue
is that a resource name could be a non printable bytearray and we cannot
assume to be ASCII coded.

The log functionality is probably never being hit when DLM is used in
normal way and no debug logging is enabled. The null pointer dereference
can only occur on a new created lkb that does not have the resource
assigned yet, it probably never hits the null pointer dereference but we
should be sure that other changes might not change this behaviour and we
actually can hit the mentioned null pointer dereference.

In this patch we just drop the printout of the resource name, the lkb id
is enough to make a possible connection to a resource name if this
exists.

	Signed-off-by: Alexander Aring <aahringo@redhat.com>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit b98333c67daf887c724cd692e88e2db9418c0861)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/lock.c
diff --cc fs/dlm/lock.c
index 0733727c255c,dddedaef5e93..000000000000
--- a/fs/dlm/lock.c
+++ b/fs/dlm/lock.c
@@@ -2920,14 -2853,25 +2920,34 @@@ static int validate_lock_args(struct dl
  	lkb->lkb_lksb = args->lksb;
  	lkb->lkb_lvbptr = args->lksb->sb_lvbptr;
  	lkb->lkb_ownpid = (int) current->pid;
 +	lkb->lkb_timeout_cs = args->timeout;
  	rv = 0;
   out:
++<<<<<<< HEAD
 +	if (rv)
 +		log_debug(ls, "validate_lock_args %d %x %x %x %d %d %s",
 +			  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,
 +			  lkb->lkb_status, lkb->lkb_wait_type,
 +			  lkb->lkb_resource->res_name);
++=======
+ 	switch (rv) {
+ 	case 0:
+ 		break;
+ 	case -EINVAL:
+ 		/* annoy the user because dlm usage is wrong */
+ 		WARN_ON(1);
+ 		log_error(ls, "%s %d %x %x %x %d %d", __func__,
+ 			  rv, lkb->lkb_id, dlm_iflags_val(lkb), args->flags,
+ 			  lkb->lkb_status, lkb->lkb_wait_type);
+ 		break;
+ 	default:
+ 		log_debug(ls, "%s %d %x %x %x %d %d", __func__,
+ 			  rv, lkb->lkb_id, dlm_iflags_val(lkb), args->flags,
+ 			  lkb->lkb_status, lkb->lkb_wait_type);
+ 		break;
+ 	}
+ 
++>>>>>>> b98333c67daf (dlm: fix possible lkb_resource null dereference)
  	return rv;
  }
  
* Unmerged path fs/dlm/lock.c
