net/mlx5: Lag, set different uplink vport metadata in multiport eswitch mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-508.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 73af3711c7028286136bb7e9422b19f5a016626d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-508.el8/73af3711.failed

In a follow-up commit multiport eswitch mode will use a shared fdb.
In shared fdb there is a single eswitch fdb and traffic could come from any
port. to distinguish between the ports set a different metadata per uplink port.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 73af3711c7028286136bb7e9422b19f5a016626d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
#	drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
index 3799f89ed1a6,2f7f2af312d7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
@@@ -5,21 -5,84 +5,87 @@@
  #include <net/nexthop.h>
  #include "lag/lag.h"
  #include "eswitch.h"
+ #include "esw/acl/ofld.h"
  #include "lib/mlx5.h"
  
++<<<<<<< HEAD
 +static int add_mpesw_rule(struct mlx5_lag *ldev)
++=======
+ static void mlx5_mpesw_metadata_cleanup(struct mlx5_lag *ldev)
+ {
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5_eswitch *esw;
+ 	u32 pf_metadata;
+ 	int i;
+ 
+ 	for (i = 0; i < ldev->ports; i++) {
+ 		dev = ldev->pf[i].dev;
+ 		esw = dev->priv.eswitch;
+ 		pf_metadata = ldev->lag_mpesw.pf_metadata[i];
+ 		if (!pf_metadata)
+ 			continue;
+ 		mlx5_esw_acl_ingress_vport_metadata_update(esw, MLX5_VPORT_UPLINK, 0);
+ 		mlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_MULTIPORT_ESW,
+ 					 (void *)0);
+ 		mlx5_esw_match_metadata_free(esw, pf_metadata);
+ 		ldev->lag_mpesw.pf_metadata[i] = 0;
+ 	}
+ }
+ 
+ static int mlx5_mpesw_metadata_set(struct mlx5_lag *ldev)
+ {
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5_eswitch *esw;
+ 	u32 pf_metadata;
+ 	int i, err;
+ 
+ 	for (i = 0; i < ldev->ports; i++) {
+ 		dev = ldev->pf[i].dev;
+ 		esw = dev->priv.eswitch;
+ 		pf_metadata = mlx5_esw_match_metadata_alloc(esw);
+ 		if (!pf_metadata) {
+ 			err = -ENOSPC;
+ 			goto err_metadata;
+ 		}
+ 
+ 		ldev->lag_mpesw.pf_metadata[i] = pf_metadata;
+ 		err = mlx5_esw_acl_ingress_vport_metadata_update(esw, MLX5_VPORT_UPLINK,
+ 								 pf_metadata);
+ 		if (err)
+ 			goto err_metadata;
+ 	}
+ 
+ 	for (i = 0; i < ldev->ports; i++) {
+ 		dev = ldev->pf[i].dev;
+ 		mlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_MULTIPORT_ESW,
+ 					 (void *)0);
+ 	}
+ 
+ 	return 0;
+ 
+ err_metadata:
+ 	mlx5_mpesw_metadata_cleanup(ldev);
+ 	return err;
+ }
+ 
+ static int enable_mpesw(struct mlx5_lag *ldev)
++>>>>>>> 73af3711c702 (net/mlx5: Lag, set different uplink vport metadata in multiport eswitch mode)
  {
  	struct mlx5_core_dev *dev = ldev->pf[MLX5_LAG_P1].dev;
  	int err;
  
 -	if (ldev->mode != MLX5_LAG_MODE_NONE)
 -		return -EINVAL;
 +	if (atomic_add_return(1, &ldev->lag_mpesw.mpesw_rule_count) != 1)
 +		return 0;
  
 -	if (mlx5_eswitch_mode(dev) != MLX5_ESWITCH_OFFLOADS ||
 -	    !MLX5_CAP_PORT_SELECTION(dev, port_select_flow_table) ||
 -	    !MLX5_CAP_GEN(dev, create_lag_when_not_master_up) ||
 -	    !mlx5_lag_check_prereq(ldev))
 -		return -EOPNOTSUPP;
 +	if (ldev->mode != MLX5_LAG_MODE_NONE) {
 +		err = -EINVAL;
 +		goto out_err;
 +	}
  
+ 	err = mlx5_mpesw_metadata_set(ldev);
+ 	if (err)
+ 		return err;
+ 
  	err = mlx5_activate_lag(ldev, NULL, MLX5_LAG_MODE_MPESW, false);
  	if (err) {
  		mlx5_core_warn(dev, "Failed to create LAG in MPESW mode (%d)\n", err);
@@@ -29,15 -92,16 +95,25 @@@
  	return 0;
  
  out_err:
++<<<<<<< HEAD
 +	atomic_dec(&ldev->lag_mpesw.mpesw_rule_count);
++=======
+ 	mlx5_mpesw_metadata_cleanup(ldev);
++>>>>>>> 73af3711c702 (net/mlx5: Lag, set different uplink vport metadata in multiport eswitch mode)
  	return err;
  }
  
 -static void disable_mpesw(struct mlx5_lag *ldev)
 +static void del_mpesw_rule(struct mlx5_lag *ldev)
  {
++<<<<<<< HEAD
 +	if (!atomic_dec_return(&ldev->lag_mpesw.mpesw_rule_count) &&
 +	    ldev->mode == MLX5_LAG_MODE_MPESW)
++=======
+ 	if (ldev->mode == MLX5_LAG_MODE_MPESW) {
+ 		mlx5_mpesw_metadata_cleanup(ldev);
++>>>>>>> 73af3711c702 (net/mlx5: Lag, set different uplink vport metadata in multiport eswitch mode)
  		mlx5_disable_lag(ldev);
+ 	}
  }
  
  static void mlx5_mpesw_work(struct work_struct *work)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
index 818f19b5a984,02520f27a033..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
@@@ -9,7 -9,7 +9,11 @@@
  
  struct lag_mpesw {
  	struct work_struct mpesw_work;
++<<<<<<< HEAD
 +	atomic_t mpesw_rule_count;
++=======
+ 	u32 pf_metadata[MLX5_MAX_PORTS];
++>>>>>>> 73af3711c702 (net/mlx5: Lag, set different uplink vport metadata in multiport eswitch mode)
  };
  
  enum mpesw_op {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 41c2e7eaf51e..7be5dd84be46 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -1024,8 +1024,23 @@ static void mlx5e_cleanup_rep_rx(struct mlx5e_priv *priv)
 	priv->rx_res = NULL;
 }
 
+static void mlx5e_rep_mpesw_work(struct work_struct *work)
+{
+	struct mlx5_rep_uplink_priv *uplink_priv =
+		container_of(work, struct mlx5_rep_uplink_priv,
+			     mpesw_work);
+	struct mlx5e_rep_priv *rpriv =
+		container_of(uplink_priv, struct mlx5e_rep_priv,
+			     uplink_priv);
+	struct mlx5e_priv *priv = netdev_priv(rpriv->netdev);
+
+	rep_vport_rx_rule_destroy(priv);
+	mlx5e_create_rep_vport_rx_rule(priv);
+}
+
 static int mlx5e_init_ul_rep_rx(struct mlx5e_priv *priv)
 {
+	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 	int err;
 
 	mlx5e_create_q_counters(priv);
@@ -1035,12 +1050,17 @@ static int mlx5e_init_ul_rep_rx(struct mlx5e_priv *priv)
 
 	mlx5e_tc_int_port_init_rep_rx(priv);
 
+	INIT_WORK(&rpriv->uplink_priv.mpesw_work, mlx5e_rep_mpesw_work);
+
 out:
 	return err;
 }
 
 static void mlx5e_cleanup_ul_rep_rx(struct mlx5e_priv *priv)
 {
+	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+
+	cancel_work_sync(&rpriv->uplink_priv.mpesw_work);
 	mlx5e_tc_int_port_cleanup_rep_rx(priv);
 	mlx5e_cleanup_rep_rx(priv);
 	mlx5e_destroy_q_counters(priv);
@@ -1149,6 +1169,19 @@ static int mlx5e_update_rep_rx(struct mlx5e_priv *priv)
 	return 0;
 }
 
+static int mlx5e_rep_event_mpesw(struct mlx5e_priv *priv)
+{
+	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+	struct mlx5_eswitch_rep *rep = rpriv->rep;
+
+	if (rep->vport != MLX5_VPORT_UPLINK)
+		return NOTIFY_DONE;
+
+	queue_work(priv->wq, &rpriv->uplink_priv.mpesw_work);
+
+	return NOTIFY_OK;
+}
+
 static int uplink_rep_async_event(struct notifier_block *nb, unsigned long event, void *data)
 {
 	struct mlx5e_priv *priv = container_of(nb, struct mlx5e_priv, events_nb);
@@ -1170,6 +1203,8 @@ static int uplink_rep_async_event(struct notifier_block *nb, unsigned long event
 
 	if (event == MLX5_DEV_EVENT_PORT_AFFINITY)
 		return mlx5e_rep_tc_event_port_affinity(priv);
+	else if (event == MLX5_DEV_EVENT_MULTIPORT_ESW)
+		return mlx5e_rep_event_mpesw(priv);
 
 	return NOTIFY_DONE;
 }
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 0abe3313c673..dcfad0bf0f45 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -103,6 +103,8 @@ struct mlx5_rep_uplink_priv {
 
 	/* tc action stats */
 	struct mlx5e_tc_act_stats_handle *action_stats_handle;
+
+	struct work_struct mpesw_work;
 };
 
 struct mlx5e_rep_priv {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 8036ef5e42fe..0532a61d63bf 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -217,6 +217,7 @@ struct mlx5_rsc_debug {
 enum mlx5_dev_event {
 	MLX5_DEV_EVENT_SYS_ERROR = 128, /* 0 - 127 are FW events */
 	MLX5_DEV_EVENT_PORT_AFFINITY = 129,
+	MLX5_DEV_EVENT_MULTIPORT_ESW = 130,
 };
 
 enum mlx5_port_status {
