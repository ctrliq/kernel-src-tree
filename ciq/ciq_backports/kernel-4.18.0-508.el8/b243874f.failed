NFSv4: fix open failure with O_ACCMODE flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-508.el8
commit-author ChenXiaoSong <chenxiaosong2@huawei.com>
commit b243874f6f9568b2daf1a00e9222cacdc15e159c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-508.el8/b243874f.failed

open() with O_ACCMODE|O_DIRECT flags secondly will fail.

Reproducer:
  1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/
  2. fd = open("/mnt/file", O_ACCMODE|O_DIRECT|O_CREAT)
  3. close(fd)
  4. fd = open("/mnt/file", O_ACCMODE|O_DIRECT)

Server nfsd4_decode_share_access() will fail with error nfserr_bad_xdr when
client use incorrect share access mode of 0.

Fix this by using NFS4_SHARE_ACCESS_BOTH share access mode in client,
just like firstly opening.

Fixes: ce4ef7c0a8a05 ("NFS: Split out NFS v4 file operations")
	Signed-off-by: ChenXiaoSong <chenxiaosong2@huawei.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit b243874f6f9568b2daf1a00e9222cacdc15e159c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4file.c
diff --cc fs/nfs/nfs4file.c
index cf17c1e91f76,7b861e4f0533..000000000000
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@@ -49,8 -51,9 +50,13 @@@ nfs4_file_open(struct inode *inode, str
  	if (err)
  		return err;
  
+ 	f_mode = filp->f_mode;
  	if ((openflags & O_ACCMODE) == 3)
++<<<<<<< HEAD
 +		return nfs_open(inode, filp);
++=======
+ 		f_mode |= flags_to_mode(openflags);
++>>>>>>> b243874f6f95 (NFSv4: fix open failure with O_ACCMODE flag)
  
  	/* We can't create new files here */
  	openflags &= ~(O_CREAT|O_EXCL);
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 0749dc7cab62..ccadca190062 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1971,16 +1971,6 @@ const struct dentry_operations nfs4_dentry_operations = {
 };
 EXPORT_SYMBOL_GPL(nfs4_dentry_operations);
 
-static fmode_t flags_to_mode(int flags)
-{
-	fmode_t res = (__force fmode_t)flags & FMODE_EXEC;
-	if ((flags & O_ACCMODE) != O_WRONLY)
-		res |= FMODE_READ;
-	if ((flags & O_ACCMODE) != O_RDONLY)
-		res |= FMODE_WRITE;
-	return res;
-}
-
 static struct nfs_open_context *create_nfs_open_context(struct dentry *dentry, int open_flags, struct file *filp)
 {
 	return alloc_nfs_open_context(dentry, flags_to_mode(open_flags), filp);
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fbfb09390f25..189019148450 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -42,6 +42,16 @@ static inline bool nfs_lookup_is_soft_revalidate(const struct dentry *dentry)
 	return true;
 }
 
+static inline fmode_t flags_to_mode(int flags)
+{
+	fmode_t res = (__force fmode_t)flags & FMODE_EXEC;
+	if ((flags & O_ACCMODE) != O_WRONLY)
+		res |= FMODE_READ;
+	if ((flags & O_ACCMODE) != O_RDONLY)
+		res |= FMODE_WRITE;
+	return res;
+}
+
 /*
  * Note: RFC 1813 doesn't limit the number of auth flavors that
  * a server can return, so make something up.
* Unmerged path fs/nfs/nfs4file.c
