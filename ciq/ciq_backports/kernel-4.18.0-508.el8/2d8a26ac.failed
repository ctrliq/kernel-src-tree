s390/uvdevice: Add 'Lock Secret Store' UVC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-508.el8
commit-author Steffen Eiden <seiden@linux.ibm.com>
commit 2d8a26acaf88a9174bcd44b607c5aa2ca9f5718f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-508.el8/2d8a26ac.failed

Userspace can call the Lock Secret Store Ultravisor Call
using IOCTLs on the uvdevice. The Lock Secret Store UV call
disables all additions of secrets for the future.

The uvdevice is merely transporting the request from userspace to the
Ultravisor.

	Signed-off-by: Steffen Eiden <seiden@linux.ibm.com>
	Reviewed-by: Janosch Frank <frankja@linux.ibm.com>
Link: https://lore.kernel.org/r/20230615100533.3996107-6-seiden@linux.ibm.com
	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Message-Id: <20230615100533.3996107-6-seiden@linux.ibm.com>
(cherry picked from commit 2d8a26acaf88a9174bcd44b607c5aa2ca9f5718f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uv.h
#	arch/s390/include/uapi/asm/uvdevice.h
#	drivers/s390/char/uvdevice.c
diff --cc arch/s390/include/asm/uv.h
index 066f948100bd,3203ffbdde6b..000000000000
--- a/arch/s390/include/asm/uv.h
+++ b/arch/s390/include/asm/uv.h
@@@ -57,6 -58,9 +57,12 @@@
  #define UVC_CMD_SET_SHARED_ACCESS	0x1000
  #define UVC_CMD_REMOVE_SHARED_ACCESS	0x1001
  #define UVC_CMD_RETR_ATTEST		0x1020
++<<<<<<< HEAD
++=======
+ #define UVC_CMD_ADD_SECRET		0x1031
+ #define UVC_CMD_LIST_SECRETS		0x1033
+ #define UVC_CMD_LOCK_SECRETS		0x1034
++>>>>>>> 2d8a26acaf88 (s390/uvdevice: Add 'Lock Secret Store' UVC)
  
  /* Bits in installed uv calls */
  enum uv_cmds_inst {
@@@ -86,6 -91,9 +92,12 @@@
  	BIT_UVC_CMD_DUMP_CPU = 26,
  	BIT_UVC_CMD_DUMP_COMPLETE = 27,
  	BIT_UVC_CMD_RETR_ATTEST = 28,
++<<<<<<< HEAD
++=======
+ 	BIT_UVC_CMD_ADD_SECRET = 29,
+ 	BIT_UVC_CMD_LIST_SECRETS = 30,
+ 	BIT_UVC_CMD_LOCK_SECRETS = 31,
++>>>>>>> 2d8a26acaf88 (s390/uvdevice: Add 'Lock Secret Store' UVC)
  };
  
  enum uv_feat_ind {
diff --cc arch/s390/include/uapi/asm/uvdevice.h
index 10a5ac918e02,b9c2f14a6af3..000000000000
--- a/arch/s390/include/uapi/asm/uvdevice.h
+++ b/arch/s390/include/uapi/asm/uvdevice.h
@@@ -46,6 -75,28 +46,32 @@@ struct uvio_attest 
  #define UVIO_DEVICE_NAME "uv"
  #define UVIO_TYPE_UVC 'u'
  
++<<<<<<< HEAD
 +#define UVIO_IOCTL_ATT _IOWR(UVIO_TYPE_UVC, 0x01, struct uvio_ioctl_cb)
++=======
+ enum UVIO_IOCTL_NR {
+ 	UVIO_IOCTL_UVDEV_INFO_NR = 0x00,
+ 	UVIO_IOCTL_ATT_NR,
+ 	UVIO_IOCTL_ADD_SECRET_NR,
+ 	UVIO_IOCTL_LIST_SECRETS_NR,
+ 	UVIO_IOCTL_LOCK_SECRETS_NR,
+ 	/* must be the last entry */
+ 	UVIO_IOCTL_NUM_IOCTLS
+ };
+ 
+ #define UVIO_IOCTL(nr)		_IOWR(UVIO_TYPE_UVC, nr, struct uvio_ioctl_cb)
+ #define UVIO_IOCTL_UVDEV_INFO	UVIO_IOCTL(UVIO_IOCTL_UVDEV_INFO_NR)
+ #define UVIO_IOCTL_ATT		UVIO_IOCTL(UVIO_IOCTL_ATT_NR)
+ #define UVIO_IOCTL_ADD_SECRET	UVIO_IOCTL(UVIO_IOCTL_ADD_SECRET_NR)
+ #define UVIO_IOCTL_LIST_SECRETS	UVIO_IOCTL(UVIO_IOCTL_LIST_SECRETS_NR)
+ #define UVIO_IOCTL_LOCK_SECRETS	UVIO_IOCTL(UVIO_IOCTL_LOCK_SECRETS_NR)
+ 
+ #define UVIO_SUPP_CALL(nr)	(1ULL << (nr))
+ #define UVIO_SUPP_UDEV_INFO	UVIO_SUPP_CALL(UVIO_IOCTL_UDEV_INFO_NR)
+ #define UVIO_SUPP_ATT		UVIO_SUPP_CALL(UVIO_IOCTL_ATT_NR)
+ #define UVIO_SUPP_ADD_SECRET	UVIO_SUPP_CALL(UVIO_IOCTL_ADD_SECRET_NR)
+ #define UVIO_SUPP_LIST_SECRETS	UVIO_SUPP_CALL(UVIO_IOCTL_LIST_SECRETS_NR)
+ #define UVIO_SUPP_LOCK_SECRETS	UVIO_SUPP_CALL(UVIO_IOCTL_LOCK_SECRETS_NR)
++>>>>>>> 2d8a26acaf88 (s390/uvdevice: Add 'Lock Secret Store' UVC)
  
  #endif /* __S390_ASM_UVDEVICE_H */
diff --cc drivers/s390/char/uvdevice.c
index 66505d7166a6,144cd2e03590..000000000000
--- a/drivers/s390/char/uvdevice.c
+++ b/drivers/s390/char/uvdevice.c
@@@ -31,6 -32,55 +31,58 @@@
  #include <asm/uvdevice.h>
  #include <asm/uv.h>
  
++<<<<<<< HEAD
++=======
+ #define BIT_UVIO_INTERNAL U32_MAX
+ /* Mapping from IOCTL-nr to UVC-bit */
+ static const u32 ioctl_nr_to_uvc_bit[] __initconst = {
+ 	[UVIO_IOCTL_UVDEV_INFO_NR] = BIT_UVIO_INTERNAL,
+ 	[UVIO_IOCTL_ATT_NR] = BIT_UVC_CMD_RETR_ATTEST,
+ 	[UVIO_IOCTL_ADD_SECRET_NR] = BIT_UVC_CMD_ADD_SECRET,
+ 	[UVIO_IOCTL_LIST_SECRETS_NR] = BIT_UVC_CMD_LIST_SECRETS,
+ 	[UVIO_IOCTL_LOCK_SECRETS_NR] = BIT_UVC_CMD_LOCK_SECRETS,
+ };
+ 
+ static_assert(ARRAY_SIZE(ioctl_nr_to_uvc_bit) == UVIO_IOCTL_NUM_IOCTLS);
+ 
+ static struct uvio_uvdev_info uvdev_info = {
+ 	.supp_uvio_cmds = GENMASK_ULL(UVIO_IOCTL_NUM_IOCTLS - 1, 0),
+ };
+ 
+ static void __init set_supp_uv_cmds(unsigned long *supp_uv_cmds)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < UVIO_IOCTL_NUM_IOCTLS; i++) {
+ 		if (ioctl_nr_to_uvc_bit[i] == BIT_UVIO_INTERNAL)
+ 			continue;
+ 		if (!test_bit_inv(ioctl_nr_to_uvc_bit[i], uv_info.inst_calls_list))
+ 			continue;
+ 		__set_bit(i, supp_uv_cmds);
+ 	}
+ }
+ 
+ /**
+  * uvio_uvdev_info() - get information about the uvdevice
+  *
+  * @uv_ioctl: ioctl control block
+  *
+  * Lists all IOCTLs that are supported by this uvdevice
+  */
+ static int uvio_uvdev_info(struct uvio_ioctl_cb *uv_ioctl)
+ {
+ 	void __user *user_buf_arg = (void __user *)uv_ioctl->argument_addr;
+ 
+ 	if (uv_ioctl->argument_len < sizeof(uvdev_info))
+ 		return -EINVAL;
+ 	if (copy_to_user(user_buf_arg, &uvdev_info, sizeof(uvdev_info)))
+ 		return -EFAULT;
+ 
+ 	uv_ioctl->uv_rc = UVC_RC_EXECUTED;
+ 	return 0;
+ }
+ 
++>>>>>>> 2d8a26acaf88 (s390/uvdevice: Add 'Lock Secret Store' UVC)
  static int uvio_build_uvcb_attest(struct uv_cb_attest *uvcb_attest, u8 *arcb,
  				  u8 *meas, u8 *add_data, struct uvio_attest *uvio_attest)
  {
@@@ -184,8 -234,161 +236,139 @@@ out
  	return ret;
  }
  
 -/** uvio_add_secret() - perform an Add Secret UVC
 - *
 - * @uv_ioctl: ioctl control block
 - *
 - * uvio_add_secret() performs the Add Secret Ultravisor Call.
 - *
 - * The given userspace argument address and size are verified to be
 - * valid but every other check is made by the Ultravisor
 - * (UV). Therefore UV errors won't result in a negative return
 - * value. The request is then copied to kernelspace, the UV-call is
 - * performed and the results are copied back to userspace.
 - *
 - * The argument has to point to an Add Secret Request Control Block
 - * which is an encrypted and cryptographically verified request that
 - * inserts a protected guest's secrets into the Ultravisor for later
 - * use.
 - *
 - * If the Add Secret UV facility is not present, UV will return
 - * invalid command rc. This won't be fenced in the driver and does not
 - * result in a negative return value.
 - *
 - * Context: might sleep
 - *
 - * Return: 0 on success or a negative error code on error.
 - */
 -static int uvio_add_secret(struct uvio_ioctl_cb *uv_ioctl)
 +static int uvio_copy_and_check_ioctl(struct uvio_ioctl_cb *ioctl, void __user *argp)
  {
++<<<<<<< HEAD
++=======
+ 	void __user *user_buf_arg = (void __user *)uv_ioctl->argument_addr;
+ 	struct uv_cb_guest_addr uvcb = {
+ 		.header.len = sizeof(uvcb),
+ 		.header.cmd = UVC_CMD_ADD_SECRET,
+ 	};
+ 	void *asrcb = NULL;
+ 	int ret;
+ 
+ 	if (uv_ioctl->argument_len > UVIO_ADD_SECRET_MAX_LEN)
+ 		return -EINVAL;
+ 	if (uv_ioctl->argument_len == 0)
+ 		return -EINVAL;
+ 
+ 	asrcb = kvzalloc(uv_ioctl->argument_len, GFP_KERNEL);
+ 	if (!asrcb)
+ 		return -ENOMEM;
+ 
+ 	ret = -EFAULT;
+ 	if (copy_from_user(asrcb, user_buf_arg, uv_ioctl->argument_len))
+ 		goto out;
+ 
+ 	ret = 0;
+ 	uvcb.addr = (u64)asrcb;
+ 	uv_call_sched(0, (u64)&uvcb);
+ 	uv_ioctl->uv_rc = uvcb.header.rc;
+ 	uv_ioctl->uv_rrc = uvcb.header.rrc;
+ 
+ out:
+ 	kvfree(asrcb);
+ 	return ret;
+ }
+ 
+ /** uvio_list_secrets() - perform a List Secret UVC
+  * @uv_ioctl: ioctl control block
+  *
+  * uvio_list_secrets() performs the List Secret Ultravisor Call. It verifies
+  * that the given userspace argument address is valid and its size is sane.
+  * Every other check is made by the Ultravisor (UV) and won't result in a
+  * negative return value. It builds the request, performs the UV-call, and
+  * copies the result to userspace.
+  *
+  * The argument specifies the location for the result of the UV-Call.
+  *
+  * If the List Secrets UV facility is not present, UV will return invalid
+  * command rc. This won't be fenced in the driver and does not result in a
+  * negative return value.
+  *
+  * Context: might sleep
+  *
+  * Return: 0 on success or a negative error code on error.
+  */
+ static int uvio_list_secrets(struct uvio_ioctl_cb *uv_ioctl)
+ {
+ 	void __user *user_buf_arg = (void __user *)uv_ioctl->argument_addr;
+ 	struct uv_cb_guest_addr uvcb = {
+ 		.header.len = sizeof(uvcb),
+ 		.header.cmd = UVC_CMD_LIST_SECRETS,
+ 	};
+ 	void *secrets = NULL;
+ 	int ret = 0;
+ 
+ 	if (uv_ioctl->argument_len != UVIO_LIST_SECRETS_LEN)
+ 		return -EINVAL;
+ 
+ 	secrets = kvzalloc(UVIO_LIST_SECRETS_LEN, GFP_KERNEL);
+ 	if (!secrets)
+ 		return -ENOMEM;
+ 
+ 	uvcb.addr = (u64)secrets;
+ 	uv_call_sched(0, (u64)&uvcb);
+ 	uv_ioctl->uv_rc = uvcb.header.rc;
+ 	uv_ioctl->uv_rrc = uvcb.header.rrc;
+ 
+ 	if (copy_to_user(user_buf_arg, secrets, UVIO_LIST_SECRETS_LEN))
+ 		ret = -EFAULT;
+ 
+ 	kvfree(secrets);
+ 	return ret;
+ }
+ 
+ /** uvio_lock_secrets() - perform a Lock Secret Store UVC
+  * @uv_ioctl: ioctl control block
+  *
+  * uvio_lock_secrets() performs the Lock Secret Store Ultravisor Call. It
+  * performs the UV-call and copies the return codes to the ioctl control block.
+  * After this call was dispatched successfully every following Add Secret UVC
+  * and Lock Secrets UVC will fail with return code 0x102.
+  *
+  * The argument address and size must be 0.
+  *
+  * If the Lock Secrets UV facility is not present, UV will return invalid
+  * command rc. This won't be fenced in the driver and does not result in a
+  * negative return value.
+  *
+  * Context: might sleep
+  *
+  * Return: 0 on success or a negative error code on error.
+  */
+ static int uvio_lock_secrets(struct uvio_ioctl_cb *ioctl)
+ {
+ 	struct uv_cb_nodata uvcb = {
+ 		.header.len = sizeof(uvcb),
+ 		.header.cmd = UVC_CMD_LOCK_SECRETS,
+ 	};
+ 
+ 	if (ioctl->argument_addr || ioctl->argument_len)
+ 		return -EINVAL;
+ 
+ 	uv_call(0, (u64)&uvcb);
+ 	ioctl->uv_rc = uvcb.header.rc;
+ 	ioctl->uv_rrc = uvcb.header.rrc;
+ 
+ 	return 0;
+ }
+ 
+ static int uvio_copy_and_check_ioctl(struct uvio_ioctl_cb *ioctl, void __user *argp,
+ 				     unsigned long cmd)
+ {
+ 	u8 nr = _IOC_NR(cmd);
+ 
+ 	if (_IOC_DIR(cmd) != (_IOC_READ | _IOC_WRITE))
+ 		return -ENOIOCTLCMD;
+ 	if (_IOC_TYPE(cmd) != UVIO_TYPE_UVC)
+ 		return -ENOIOCTLCMD;
+ 	if (nr >= UVIO_IOCTL_NUM_IOCTLS)
+ 		return -ENOIOCTLCMD;
+ 	if (_IOC_SIZE(cmd) != sizeof(*ioctl))
+ 		return -ENOIOCTLCMD;
++>>>>>>> 2d8a26acaf88 (s390/uvdevice: Add 'Lock Secret Store' UVC)
  	if (copy_from_user(ioctl, argp, sizeof(*ioctl)))
  		return -EFAULT;
  	if (ioctl->flags != 0)
@@@ -204,14 -407,28 +387,26 @@@ static long uvio_ioctl(struct file *fil
  	void __user *argp = (void __user *)arg;
  	struct uvio_ioctl_cb uv_ioctl = { };
  	long ret;
 -	int nr;
 -
 -	nr = uvio_copy_and_check_ioctl(&uv_ioctl, argp, cmd);
 -	if (nr < 0)
 -		return nr;
  
 -	switch (nr) {
 -	case UVIO_IOCTL_UVDEV_INFO_NR:
 -		ret = uvio_uvdev_info(&uv_ioctl);
 -		break;
 -	case UVIO_IOCTL_ATT_NR:
 +	switch (cmd) {
 +	case UVIO_IOCTL_ATT:
 +		ret = uvio_copy_and_check_ioctl(&uv_ioctl, argp);
 +		if (ret)
 +			return ret;
  		ret = uvio_attestation(&uv_ioctl);
  		break;
++<<<<<<< HEAD
++=======
+ 	case UVIO_IOCTL_ADD_SECRET_NR:
+ 		ret = uvio_add_secret(&uv_ioctl);
+ 		break;
+ 	case UVIO_IOCTL_LIST_SECRETS_NR:
+ 		ret = uvio_list_secrets(&uv_ioctl);
+ 		break;
+ 	case UVIO_IOCTL_LOCK_SECRETS_NR:
+ 		ret = uvio_lock_secrets(&uv_ioctl);
+ 		break;
++>>>>>>> 2d8a26acaf88 (s390/uvdevice: Add 'Lock Secret Store' UVC)
  	default:
  		ret = -ENOIOCTLCMD;
  		break;
* Unmerged path arch/s390/include/asm/uv.h
* Unmerged path arch/s390/include/uapi/asm/uvdevice.h
* Unmerged path drivers/s390/char/uvdevice.c
