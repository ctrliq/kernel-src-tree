NFS: Further fixes to the writeback error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-508.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit c6fd3511c3397dd9cbc6dc5d105bbedb69bf4061
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-508.el8/c6fd3511.failed

When we handle an error by redirtying the page, we're not corrupting the
mapping, so we don't want the error to be recorded in the mapping.
If the caller has specified a sync_mode of WB_SYNC_NONE, we can just
return AOP_WRITEPAGE_ACTIVATE. However if we're dealing with
WB_SYNC_ALL, we need to ensure that retries happen when the errors are
non-fatal.

	Reported-by: Olga Kornievskaia <aglo@umich.edu>
Fixes: 8fc75bed96bb ("NFS: Fix up return value on fatal errors in nfs_page_async_flush()")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit c6fd3511c3397dd9cbc6dc5d105bbedb69bf4061)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/write.c
diff --cc fs/nfs/write.c
index 8341ae058ad0,2f41659e232e..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -698,21 -707,35 +692,33 @@@ int nfs_writepages(struct address_spac
  {
  	struct inode *inode = mapping->host;
  	struct nfs_pageio_descriptor pgio;
 -	struct nfs_io_completion *ioc = NULL;
 -	unsigned int mntflags = NFS_SERVER(inode)->flags;
 -	int priority = 0;
 +	struct nfs_io_completion *ioc;
  	int err;
  
 -	if (wbc->sync_mode == WB_SYNC_NONE &&
 -	    NFS_SERVER(inode)->write_congested)
 -		return 0;
 -
  	nfs_inc_stats(inode, NFSIOS_VFSWRITEPAGES);
  
 -	if (!(mntflags & NFS_MOUNT_WRITE_EAGER) || wbc->for_kupdate ||
 -	    wbc->for_background || wbc->for_sync || wbc->for_reclaim) {
 -		ioc = nfs_io_completion_alloc(GFP_KERNEL);
 -		if (ioc)
 -			nfs_io_completion_init(ioc, nfs_io_completion_commit,
 -					       inode);
 -		priority = wb_priority(wbc);
 -	}
 +	ioc = nfs_io_completion_alloc(GFP_KERNEL);
 +	if (ioc)
 +		nfs_io_completion_init(ioc, nfs_io_completion_commit, inode);
  
++<<<<<<< HEAD
 +	nfs_pageio_init_write(&pgio, inode, wb_priority(wbc), false,
 +				&nfs_async_write_completion_ops);
 +	pgio.pg_io_completion = ioc;
 +	err = write_cache_pages(mapping, wbc, nfs_writepages_callback, &pgio);
 +	pgio.pg_error = 0;
 +	nfs_pageio_complete(&pgio);
++=======
+ 	do {
+ 		nfs_pageio_init_write(&pgio, inode, priority, false,
+ 				      &nfs_async_write_completion_ops);
+ 		pgio.pg_io_completion = ioc;
+ 		err = write_cache_pages(mapping, wbc, nfs_writepages_callback,
+ 					&pgio);
+ 		pgio.pg_error = 0;
+ 		nfs_pageio_complete(&pgio);
+ 	} while (err < 0 && !nfs_error_is_fatal(err));
++>>>>>>> c6fd3511c339 (NFS: Further fixes to the writeback error handling)
  	nfs_io_completion_put(ioc);
  
  	if (err < 0)
* Unmerged path fs/nfs/write.c
