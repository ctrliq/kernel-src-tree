net/mlx5e: TC, Add peer flow in mpesw mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-508.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 8ce81fc01b52a17073353e0d483a2434abd2e392
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-508.el8/8ce81fc0.failed

While at it rename mlx5_lag_mpesw_is_activated() to mlx5_lag_is_mpesw() to
be consistent with checking if other lag modes are activated.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 8ce81fc01b52a17073353e0d483a2434abd2e392)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index 18d679255fcc,2d36123cc05e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -515,7 -461,7 +515,11 @@@ static int mlx5_devlink_esw_port_metada
  	if (!MLX5_ESWITCH_MANAGER(dev))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	ctx->val.vbool = mlx5_eswitch_vport_match_metadata_enabled(dev->priv.eswitch);
++=======
+ 	ctx->val.vbool = mlx5_lag_is_mpesw(dev);
++>>>>>>> 8ce81fc01b52 (net/mlx5e: TC, Add peer flow in mpesw mode)
  	return 0;
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 4d8bb59d806b,fd2a0b431f3d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -4261,12 -4311,7 +4261,16 @@@ static bool is_lag_dev(struct mlx5e_pri
  
  static bool is_multiport_eligible(struct mlx5e_priv *priv, struct net_device *out_dev)
  {
++<<<<<<< HEAD
 +	if (same_hw_reps(priv, out_dev) &&
 +	    MLX5_CAP_PORT_SELECTION(priv->mdev, port_select_flow_table) &&
 +	    MLX5_CAP_GEN(priv->mdev, create_lag_when_not_master_up))
 +		return true;
 +
 +	return false;
++=======
+ 	return same_hw_reps(priv, out_dev) && mlx5_lag_is_mpesw(priv->mdev);
++>>>>>>> 8ce81fc01b52 (net/mlx5e: TC, Add peer flow in mpesw mode)
  }
  
  bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
index 818f19b5a984,d857ea988bf2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
@@@ -28,15 -27,8 +28,21 @@@ struct mlx5_mpesw_work_st 
  int mlx5_lag_mpesw_do_mirred(struct mlx5_core_dev *mdev,
  			     struct net_device *out_dev,
  			     struct netlink_ext_ack *extack);
++<<<<<<< HEAD
 +bool mlx5_lag_mpesw_is_activated(struct mlx5_core_dev *dev);
 +void mlx5_lag_del_mpesw_rule(struct mlx5_core_dev *dev);
 +int mlx5_lag_add_mpesw_rule(struct mlx5_core_dev *dev);
 +#if IS_ENABLED(CONFIG_MLX5_ESWITCH)
 +void mlx5_lag_mpesw_init(struct mlx5_lag *ldev);
 +void mlx5_lag_mpesw_cleanup(struct mlx5_lag *ldev);
 +#else
 +static inline void mlx5_lag_mpesw_init(struct mlx5_lag *ldev) {}
 +static inline void mlx5_lag_mpesw_cleanup(struct mlx5_lag *ldev) {}
 +#endif
++=======
+ bool mlx5_lag_is_mpesw(struct mlx5_core_dev *dev);
+ void mlx5_lag_mpesw_disable(struct mlx5_core_dev *dev);
+ int mlx5_lag_mpesw_enable(struct mlx5_core_dev *dev);
++>>>>>>> 8ce81fc01b52 (net/mlx5e: TC, Add peer flow in mpesw mode)
  
  #endif /* __MLX5_LAG_MPESW_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
index ceb6434149bd..decad34ecd09 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
@@ -97,7 +97,8 @@ static int get_route_and_out_devs(struct mlx5e_priv *priv,
 	      mlx5e_is_uplink_rep(netdev_priv(*out_dev))))
 		return -EOPNOTSUPP;
 
-	if (mlx5e_eswitch_uplink_rep(priv->netdev) && *out_dev != priv->netdev)
+	if (mlx5e_eswitch_uplink_rep(priv->netdev) && *out_dev != priv->netdev &&
+	    !mlx5_lag_is_mpesw(priv->mdev))
 		return -EOPNOTSUPP;
 
 	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2bd1e4b2fd9c..f829380755cb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -444,7 +444,7 @@ esw_setup_vport_dest(struct mlx5_flow_destination *dest, struct mlx5_flow_act *f
 			MLX5_CAP_GEN(esw_attr->dests[attr_idx].mdev, vhca_id);
 		dest[dest_idx].vport.flags |= MLX5_FLOW_DEST_VPORT_VHCA_ID;
 		if (dest[dest_idx].vport.num == MLX5_VPORT_UPLINK &&
-		    mlx5_lag_mpesw_is_activated(esw->dev))
+		    mlx5_lag_is_mpesw(esw->dev))
 			dest[dest_idx].type = MLX5_FLOW_DESTINATION_TYPE_UPLINK;
 	}
 	if (esw_attr->dests[attr_idx].flags & MLX5_ESW_DEST_ENCAP_VALID) {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c b/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
index 3799f89ed1a6..5b2a66f97a93 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.c
@@ -112,7 +112,7 @@ int mlx5_lag_mpesw_do_mirred(struct mlx5_core_dev *mdev,
 	return -EOPNOTSUPP;
 }
 
-bool mlx5_lag_mpesw_is_activated(struct mlx5_core_dev *dev)
+bool mlx5_lag_is_mpesw(struct mlx5_core_dev *dev)
 {
 	struct mlx5_lag *ldev = mlx5_lag_dev(dev);
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag/mpesw.h
