nfsd: call op_release, even when op_func returns an error

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-508.el8
commit-author Jeff Layton <jlayton@kernel.org>
commit 15a8b55dbb1ba154d82627547c5761cac884d810
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-508.el8/15a8b55d.failed

For ops with "trivial" replies, nfsd4_encode_operation will shortcut
most of the encoding work and skip to just marshalling up the status.
One of the things it skips is calling op_release. This could cause a
memory leak in the layoutget codepath if there is an error at an
inopportune time.

Have the compound processing engine always call op_release, even when
op_func sets an error in op->status. With this change, we also need
nfsd4_block_get_device_info_scsi to set the gd_device pointer to NULL
on error to avoid a double free.

	Reported-by: Zhi Li <yieli@redhat.com>
Link: https://bugzilla.redhat.com/show_bug.cgi?id=2181403
Fixes: 34b1744c91cc ("nfsd4: define ->op_release for compound ops")
	Signed-off-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 15a8b55dbb1ba154d82627547c5761cac884d810)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/blocklayout.c
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/blocklayout.c
index f37ab27217cb,01d7fd108cf3..000000000000
--- a/fs/nfsd/blocklayout.c
+++ b/fs/nfsd/blocklayout.c
@@@ -373,6 -294,11 +373,14 @@@ nfsd4_block_get_device_info_scsi(struc
  	}
  
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ out_free_dev:
+ 	kfree(dev);
+ 	gdp->gd_device = NULL;
+ 	return ret;
++>>>>>>> 15a8b55dbb1b (nfsd: call op_release, even when op_func returns an error)
  }
  
  static __be32
diff --cc fs/nfsd/nfs4xdr.c
index 125cd3a73206,7799835c2196..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -5130,8 -5455,10 +5126,15 @@@ nfsd4_encode_operation(struct nfsd4_com
  						so->so_replay.rp_buf, len);
  	}
  status:
++<<<<<<< HEAD
 +	/* Note that op->status is already in network byte order: */
 +	write_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);
++=======
+ 	*p = op->status;
+ release:
+ 	if (opdesc && opdesc->op_release)
+ 		opdesc->op_release(&op->u);
++>>>>>>> 15a8b55dbb1b (nfsd: call op_release, even when op_func returns an error)
  }
  
  /* 
* Unmerged path fs/nfsd/blocklayout.c
* Unmerged path fs/nfsd/nfs4xdr.c
