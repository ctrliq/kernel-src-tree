KVM: arm64: Restore mdcr_el2 from vcpu

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-512.el8
commit-author Fuad Tabba <tabba@google.com>
commit 1460b4b25fde52cbee746c11a4b1d3185f2e2847
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-512.el8/1460b4b2.failed

On deactivating traps, restore the value of mdcr_el2 from the
newly created and preserved host value vcpu context, rather than
directly reading the hardware register.

Up until and including this patch the two values are the same,
i.e., the hardware register and the vcpu one. A future patch will
be changing the value of mdcr_el2 on activating traps, and this
ensures that its value will be restored.

No functional change intended.

	Signed-off-by: Fuad Tabba <tabba@google.com>
	Acked-by: Will Deacon <will@kernel.org>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20210817081134.2918285-7-tabba@google.com
(cherry picked from commit 1460b4b25fde52cbee746c11a4b1d3185f2e2847)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_host.h
#	arch/arm64/kvm/hyp/include/hyp/switch.h
#	arch/arm64/kvm/hyp/nvhe/switch.c
#	arch/arm64/kvm/hyp/vhe/sysreg-sr.c
diff --cc arch/arm64/include/asm/kvm_host.h
index 7f58bd229b69,76462c6a91ee..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -293,10 -284,16 +293,20 @@@ struct kvm_vcpu_arch 
  	void *sve_state;
  	unsigned int sve_max_vl;
  
++<<<<<<< HEAD
 +	/* HYP configuration */
++=======
+ 	/* Stage 2 paging state used by the hardware on next switch */
+ 	struct kvm_s2_mmu *hw_mmu;
+ 
+ 	/* Values of trap registers for the guest. */
++>>>>>>> 1460b4b25fde (KVM: arm64: Restore mdcr_el2 from vcpu)
  	u64 hcr_el2;
 -	u64 mdcr_el2;
 +	u32 mdcr_el2;
  
+ 	/* Values of trap registers for the host before guest entry. */
+ 	u64 mdcr_el2_host;
+ 
  	/* Exception Information */
  	struct kvm_vcpu_fault_info fault;
  
diff --cc arch/arm64/kvm/hyp/include/hyp/switch.h
index 238c109f9a01,a0e78a6027be..000000000000
--- a/arch/arm64/kvm/hyp/include/hyp/switch.h
+++ b/arch/arm64/kvm/hyp/include/hyp/switch.h
@@@ -92,15 -88,22 +92,26 @@@ static inline void __activate_traps_com
  	 * counter, which could make a PMXEVCNTR_EL0 access UNDEF at
  	 * EL1 instead of being trapped to EL2.
  	 */
++<<<<<<< HEAD
 +	write_sysreg(0, pmselr_el0);
 +	write_sysreg(ARMV8_PMU_USERENR_MASK, pmuserenr_el0);
++=======
+ 	if (kvm_arm_support_pmu_v3()) {
+ 		write_sysreg(0, pmselr_el0);
+ 		write_sysreg(ARMV8_PMU_USERENR_MASK, pmuserenr_el0);
+ 	}
+ 
+ 	vcpu->arch.mdcr_el2_host = read_sysreg(mdcr_el2);
++>>>>>>> 1460b4b25fde (KVM: arm64: Restore mdcr_el2 from vcpu)
  	write_sysreg(vcpu->arch.mdcr_el2, mdcr_el2);
  }
  
- static inline void __deactivate_traps_common(void)
+ static inline void __deactivate_traps_common(struct kvm_vcpu *vcpu)
  {
+ 	write_sysreg(vcpu->arch.mdcr_el2_host, mdcr_el2);
+ 
  	write_sysreg(0, hstr_el2);
 -	if (kvm_arm_support_pmu_v3())
 -		write_sysreg(0, pmuserenr_el0);
 +	write_sysreg(0, pmuserenr_el0);
  }
  
  static inline void ___activate_traps(struct kvm_vcpu *vcpu)
diff --cc arch/arm64/kvm/hyp/nvhe/switch.c
index 6ea15e7c1532,2ea764a48958..000000000000
--- a/arch/arm64/kvm/hyp/nvhe/switch.c
+++ b/arch/arm64/kvm/hyp/nvhe/switch.c
@@@ -60,7 -68,8 +60,12 @@@ static void __activate_traps(struct kvm
  
  static void __deactivate_traps(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	u64 mdcr_el2;
++=======
+ 	extern char __kvm_hyp_host_vector[];
+ 	u64 cptr;
++>>>>>>> 1460b4b25fde (KVM: arm64: Restore mdcr_el2 from vcpu)
  
  	___deactivate_traps(vcpu);
  
@@@ -83,19 -90,20 +86,27 @@@
  		isb();
  	}
  
- 	__deactivate_traps_common();
+ 	vcpu->arch.mdcr_el2_host &= MDCR_EL2_HPMN_MASK |
+ 				    MDCR_EL2_E2PB_MASK << MDCR_EL2_E2PB_SHIFT |
+ 				    MDCR_EL2_E2TB_MASK << MDCR_EL2_E2TB_SHIFT;
  
++<<<<<<< HEAD
 +	mdcr_el2 &= MDCR_EL2_HPMN_MASK;
 +	mdcr_el2 |= MDCR_EL2_E2PB_MASK << MDCR_EL2_E2PB_SHIFT;
 +
 +	write_sysreg(mdcr_el2, mdcr_el2);
 +	write_sysreg(HCR_HOST_NVHE_FLAGS, hcr_el2);
 +	write_sysreg(CPTR_EL2_DEFAULT, cptr_el2);
 +}
++=======
+ 	__deactivate_traps_common(vcpu);
+ 
+ 	write_sysreg(this_cpu_ptr(&kvm_init_params)->hcr_el2, hcr_el2);
++>>>>>>> 1460b4b25fde (KVM: arm64: Restore mdcr_el2 from vcpu)
  
 -	cptr = CPTR_EL2_DEFAULT;
 -	if (vcpu_has_sve(vcpu) && (vcpu->arch.flags & KVM_ARM64_FP_ENABLED))
 -		cptr |= CPTR_EL2_TZ;
 -
 -	write_sysreg(cptr, cptr_el2);
 -	write_sysreg(__kvm_hyp_host_vector, vbar_el2);
 +static void __deactivate_vm(struct kvm_vcpu *vcpu)
 +{
 +	write_sysreg(0, vttbr_el2);
  }
  
  /* Save VGICv3 state on non-VHE systems */
diff --cc arch/arm64/kvm/hyp/vhe/sysreg-sr.c
index 996471e4c138,007a12dd4351..000000000000
--- a/arch/arm64/kvm/hyp/vhe/sysreg-sr.c
+++ b/arch/arm64/kvm/hyp/vhe/sysreg-sr.c
@@@ -100,8 -100,8 +100,13 @@@ void kvm_vcpu_put_sysregs_vhe(struct kv
  	struct kvm_cpu_context *guest_ctxt = &vcpu->arch.ctxt;
  	struct kvm_cpu_context *host_ctxt;
  
++<<<<<<< HEAD
 +	host_ctxt = &__hyp_this_cpu_ptr(kvm_host_data)->host_ctxt;
 +	deactivate_traps_vhe_put();
++=======
+ 	host_ctxt = &this_cpu_ptr(&kvm_host_data)->host_ctxt;
+ 	deactivate_traps_vhe_put(vcpu);
++>>>>>>> 1460b4b25fde (KVM: arm64: Restore mdcr_el2 from vcpu)
  
  	__sysreg_save_el1_state(guest_ctxt);
  	__sysreg_save_user_state(guest_ctxt);
* Unmerged path arch/arm64/include/asm/kvm_host.h
diff --git a/arch/arm64/include/asm/kvm_hyp.h b/arch/arm64/include/asm/kvm_hyp.h
index a2b413a85270..e0fbb119c1a4 100644
--- a/arch/arm64/include/asm/kvm_hyp.h
+++ b/arch/arm64/include/asm/kvm_hyp.h
@@ -100,7 +100,7 @@ void __fpsimd_restore_state(struct user_fpsimd_state *fp_regs);
 
 #ifndef __KVM_NVHE_HYPERVISOR__
 void activate_traps_vhe_load(struct kvm_vcpu *vcpu);
-void deactivate_traps_vhe_put(void);
+void deactivate_traps_vhe_put(struct kvm_vcpu *vcpu);
 #endif
 
 u64 __guest_enter(struct kvm_vcpu *vcpu, struct kvm_cpu_context *host_ctxt);
* Unmerged path arch/arm64/kvm/hyp/include/hyp/switch.h
* Unmerged path arch/arm64/kvm/hyp/nvhe/switch.c
diff --git a/arch/arm64/kvm/hyp/vhe/switch.c b/arch/arm64/kvm/hyp/vhe/switch.c
index 8c97c98b2b31..c1486a862202 100644
--- a/arch/arm64/kvm/hyp/vhe/switch.c
+++ b/arch/arm64/kvm/hyp/vhe/switch.c
@@ -91,17 +91,13 @@ void activate_traps_vhe_load(struct kvm_vcpu *vcpu)
 	__activate_traps_common(vcpu);
 }
 
-void deactivate_traps_vhe_put(void)
+void deactivate_traps_vhe_put(struct kvm_vcpu *vcpu)
 {
-	u64 mdcr_el2 = read_sysreg(mdcr_el2);
+	vcpu->arch.mdcr_el2_host &= MDCR_EL2_HPMN_MASK |
+				    MDCR_EL2_E2PB_MASK << MDCR_EL2_E2PB_SHIFT |
+				    MDCR_EL2_TPMS;
 
-	mdcr_el2 &= MDCR_EL2_HPMN_MASK |
-		    MDCR_EL2_E2PB_MASK << MDCR_EL2_E2PB_SHIFT |
-		    MDCR_EL2_TPMS;
-
-	write_sysreg(mdcr_el2, mdcr_el2);
-
-	__deactivate_traps_common();
+	__deactivate_traps_common(vcpu);
 }
 
 /* Switch to the guest for VHE systems running in EL2 */
* Unmerged path arch/arm64/kvm/hyp/vhe/sysreg-sr.c
