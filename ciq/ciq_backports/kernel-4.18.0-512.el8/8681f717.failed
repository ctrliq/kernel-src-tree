KVM: arm64: PMU: Restore the host's PMUSERENR_EL0

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-512.el8
commit-author Reiji Watanabe <reijiw@google.com>
commit 8681f71759010503892f9e3ddb05f65c0f21b690
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-512.el8/8681f717.failed

Restore the host's PMUSERENR_EL0 value instead of clearing it,
before returning back to userspace, as the host's EL0 might have
a direct access to PMU registers (some bits of PMUSERENR_EL0 for
might not be zero for the host EL0).

Fixes: 83a7a4d643d3 ("arm64: perf: Enable PMU counter userspace access for perf event")
	Signed-off-by: Reiji Watanabe <reijiw@google.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20230603025035.3781797-2-reijiw@google.com
(cherry picked from commit 8681f71759010503892f9e3ddb05f65c0f21b690)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/hyp/include/hyp/switch.h
diff --cc arch/arm64/kvm/hyp/include/hyp/switch.h
index 238c109f9a01,0dcb8f7620d1..000000000000
--- a/arch/arm64/kvm/hyp/include/hyp/switch.h
+++ b/arch/arm64/kvm/hyp/include/hyp/switch.h
@@@ -92,15 -81,51 +92,47 @@@ static inline void __activate_traps_com
  	 * counter, which could make a PMXEVCNTR_EL0 access UNDEF at
  	 * EL1 instead of being trapped to EL2.
  	 */
++<<<<<<< HEAD
 +	write_sysreg(0, pmselr_el0);
 +	write_sysreg(ARMV8_PMU_USERENR_MASK, pmuserenr_el0);
++=======
+ 	if (kvm_arm_support_pmu_v3()) {
+ 		struct kvm_cpu_context *hctxt;
+ 
+ 		write_sysreg(0, pmselr_el0);
+ 
+ 		hctxt = &this_cpu_ptr(&kvm_host_data)->host_ctxt;
+ 		ctxt_sys_reg(hctxt, PMUSERENR_EL0) = read_sysreg(pmuserenr_el0);
+ 		write_sysreg(ARMV8_PMU_USERENR_MASK, pmuserenr_el0);
+ 	}
+ 
+ 	vcpu->arch.mdcr_el2_host = read_sysreg(mdcr_el2);
++>>>>>>> 8681f7175901 (KVM: arm64: PMU: Restore the host's PMUSERENR_EL0)
  	write_sysreg(vcpu->arch.mdcr_el2, mdcr_el2);
 -
 -	if (cpus_have_final_cap(ARM64_SME)) {
 -		sysreg_clear_set_s(SYS_HFGRTR_EL2,
 -				   HFGxTR_EL2_nSMPRI_EL1_MASK |
 -				   HFGxTR_EL2_nTPIDR2_EL0_MASK,
 -				   0);
 -		sysreg_clear_set_s(SYS_HFGWTR_EL2,
 -				   HFGxTR_EL2_nSMPRI_EL1_MASK |
 -				   HFGxTR_EL2_nTPIDR2_EL0_MASK,
 -				   0);
 -	}
  }
  
 -static inline void __deactivate_traps_common(struct kvm_vcpu *vcpu)
 +static inline void __deactivate_traps_common(void)
  {
 -	write_sysreg(vcpu->arch.mdcr_el2_host, mdcr_el2);
 -
  	write_sysreg(0, hstr_el2);
++<<<<<<< HEAD
 +	write_sysreg(0, pmuserenr_el0);
++=======
+ 	if (kvm_arm_support_pmu_v3()) {
+ 		struct kvm_cpu_context *hctxt;
+ 
+ 		hctxt = &this_cpu_ptr(&kvm_host_data)->host_ctxt;
+ 		write_sysreg(ctxt_sys_reg(hctxt, PMUSERENR_EL0), pmuserenr_el0);
+ 	}
+ 
+ 	if (cpus_have_final_cap(ARM64_SME)) {
+ 		sysreg_clear_set_s(SYS_HFGRTR_EL2, 0,
+ 				   HFGxTR_EL2_nSMPRI_EL1_MASK |
+ 				   HFGxTR_EL2_nTPIDR2_EL0_MASK);
+ 		sysreg_clear_set_s(SYS_HFGWTR_EL2, 0,
+ 				   HFGxTR_EL2_nSMPRI_EL1_MASK |
+ 				   HFGxTR_EL2_nTPIDR2_EL0_MASK);
+ 	}
++>>>>>>> 8681f7175901 (KVM: arm64: PMU: Restore the host's PMUSERENR_EL0)
  }
  
  static inline void ___activate_traps(struct kvm_vcpu *vcpu)
* Unmerged path arch/arm64/kvm/hyp/include/hyp/switch.h
