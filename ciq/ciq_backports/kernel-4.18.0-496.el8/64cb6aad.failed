net/sched: taprio: dynamic max_sdu larger than the max_mtu is unlimited

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit 64cb6aad12328015202af5b2a9623c6bcc021855
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/64cb6aad.failed

It makes no sense to keep randomly large max_sdu values, especially if
larger than the device's max_mtu. These are visible in "tc qdisc show".
Such a max_sdu is practically unlimited and will cause no packets for
that traffic class to be dropped on enqueue.

Just set max_sdu_dynamic to U32_MAX, which in the logic below causes
taprio to save a max_frm_len of U32_MAX and a max_sdu presented to user
space of 0 (unlimited).

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Kurt Kanzenbach <kurt@linutronix.de>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 64cb6aad12328015202af5b2a9623c6bcc021855)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_taprio.c
diff --cc net/sched/sch_taprio.c
index 45d4da9669a4,1f469861eae3..000000000000
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@@ -228,7 -244,64 +228,68 @@@ static ktime_t get_interval_end_time(st
  
  static int length_to_duration(struct taprio_sched *q, int len)
  {
++<<<<<<< HEAD
 +	return div_u64(len * atomic64_read(&q->picos_per_byte), 1000);
++=======
+ 	return div_u64(len * atomic64_read(&q->picos_per_byte), PSEC_PER_NSEC);
+ }
+ 
+ static int duration_to_length(struct taprio_sched *q, u64 duration)
+ {
+ 	return div_u64(duration * PSEC_PER_NSEC, atomic64_read(&q->picos_per_byte));
+ }
+ 
+ /* Sets sched->max_sdu[] and sched->max_frm_len[] to the minimum between the
+  * q->max_sdu[] requested by the user and the max_sdu dynamically determined by
+  * the maximum open gate durations at the given link speed.
+  */
+ static void taprio_update_queue_max_sdu(struct taprio_sched *q,
+ 					struct sched_gate_list *sched,
+ 					struct qdisc_size_table *stab)
+ {
+ 	struct net_device *dev = qdisc_dev(q->root);
+ 	int num_tc = netdev_get_num_tc(dev);
+ 	u32 max_sdu_from_user;
+ 	u32 max_sdu_dynamic;
+ 	u32 max_sdu;
+ 	int tc;
+ 
+ 	for (tc = 0; tc < num_tc; tc++) {
+ 		max_sdu_from_user = q->max_sdu[tc] ?: U32_MAX;
+ 
+ 		/* TC gate never closes => keep the queueMaxSDU
+ 		 * selected by the user
+ 		 */
+ 		if (sched->max_open_gate_duration[tc] == sched->cycle_time) {
+ 			max_sdu_dynamic = U32_MAX;
+ 		} else {
+ 			u32 max_frm_len;
+ 
+ 			max_frm_len = duration_to_length(q, sched->max_open_gate_duration[tc]);
+ 			/* Compensate for L1 overhead from size table,
+ 			 * but don't let the frame size go negative
+ 			 */
+ 			if (stab) {
+ 				max_frm_len -= stab->szopts.overhead;
+ 				max_frm_len = max_t(int, max_frm_len,
+ 						    dev->hard_header_len + 1);
+ 			}
+ 			max_sdu_dynamic = max_frm_len - dev->hard_header_len;
+ 			if (max_sdu_dynamic > dev->max_mtu)
+ 				max_sdu_dynamic = U32_MAX;
+ 		}
+ 
+ 		max_sdu = min(max_sdu_dynamic, max_sdu_from_user);
+ 
+ 		if (max_sdu != U32_MAX) {
+ 			sched->max_frm_len[tc] = max_sdu + dev->hard_header_len;
+ 			sched->max_sdu[tc] = max_sdu;
+ 		} else {
+ 			sched->max_frm_len[tc] = U32_MAX; /* never oversized */
+ 			sched->max_sdu[tc] = 0;
+ 		}
+ 	}
++>>>>>>> 64cb6aad1232 (net/sched: taprio: dynamic max_sdu larger than the max_mtu is unlimited)
  }
  
  /* Returns the entry corresponding to next available interval. If
* Unmerged path net/sched/sch_taprio.c
