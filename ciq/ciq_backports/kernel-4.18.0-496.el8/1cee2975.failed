s390/dasd: add autoquiesce feature

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Stefan Haberland <sth@linux.ibm.com>
commit 1cee2975bbabd89df1097c354867192106b058ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/1cee2975.failed

Add the internal logic to check for autoquiesce triggers and handle
them.

Quiesce and resume are functions that tell Linux to stop/resume
issuing I/Os to a specific DASD.
The DASD driver allows a manual quiesce/resume via ioctl.

Autoquiesce will define an amount of triggers that will lead to
an automatic quiesce if a certain event occurs.
There is no automatic resume.

All events will be reported via DASD Extended Error Reporting (EER)
if configured.

	Signed-off-by: Stefan Haberland <sth@linux.ibm.com>
	Reviewed-by: Jan Hoeppner <hoeppner@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
Link: https://lore.kernel.org/r/20230405142017.2446986-3-sth@linux.ibm.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 1cee2975bbabd89df1097c354867192106b058ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/dasd.c
diff --cc drivers/s390/block/dasd.c
index bc6177f37572,8186473b9aa7..000000000000
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@@ -4081,68 -3959,32 +4082,95 @@@ void dasd_schedule_requeue(struct dasd_
  }
  EXPORT_SYMBOL(dasd_schedule_requeue);
  
++<<<<<<< HEAD
 +int dasd_generic_pm_freeze(struct ccw_device *cdev)
 +{
 +	struct dasd_device *device = dasd_device_from_cdev(cdev);
 +
 +	if (IS_ERR(device))
 +		return PTR_ERR(device);
 +
 +	/* mark device as suspended */
 +	set_bit(DASD_FLAG_SUSPENDED, &device->flags);
 +
 +	if (device->discipline->freeze)
 +		device->discipline->freeze(device);
 +
 +	/* disallow new I/O  */
 +	dasd_device_set_stop_bits(device, DASD_STOPPED_PM);
 +
 +	return dasd_generic_requeue_all_requests(device);
 +}
 +EXPORT_SYMBOL_GPL(dasd_generic_pm_freeze);
 +
 +int dasd_generic_restore_device(struct ccw_device *cdev)
 +{
 +	struct dasd_device *device = dasd_device_from_cdev(cdev);
 +	int rc = 0;
 +
 +	if (IS_ERR(device))
 +		return PTR_ERR(device);
 +
 +	/* allow new IO again */
 +	dasd_device_remove_stop_bits(device,
 +				     (DASD_STOPPED_PM | DASD_UNRESUMED_PM));
 +
 +	dasd_schedule_device_bh(device);
 +
 +	/*
 +	 * call discipline restore function
 +	 * if device is stopped do nothing e.g. for disconnected devices
 +	 */
 +	if (device->discipline->restore && !(device->stopped))
 +		rc = device->discipline->restore(device);
 +	if (rc || device->stopped)
 +		/*
 +		 * if the resume failed for the DASD we put it in
 +		 * an UNRESUMED stop state
 +		 */
 +		device->stopped |= DASD_UNRESUMED_PM;
 +
 +	if (device->block) {
 +		dasd_schedule_block_bh(device->block);
 +		if (device->block->request_queue)
 +			blk_mq_run_hw_queues(device->block->request_queue,
 +					     true);
 +	}
 +
 +	clear_bit(DASD_FLAG_SUSPENDED, &device->flags);
 +	dasd_put_device(device);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(dasd_generic_restore_device);
++=======
+ static int dasd_handle_autoquiesce(struct dasd_device *device,
+ 				   struct dasd_ccw_req *cqr,
+ 				   unsigned int reason)
+ {
+ 	/* in any case write eer message with reason */
+ 	if (dasd_eer_enabled(device))
+ 		dasd_eer_write(device, cqr, reason);
+ 
+ 	if (!test_bit(reason, &device->aq_mask))
+ 		return 0;
+ 
+ 	/* notify eer about autoquiesce */
+ 	if (dasd_eer_enabled(device))
+ 		dasd_eer_write(device, NULL, DASD_EER_AUTOQUIESCE);
+ 
+ 	pr_info("%s: The DASD has been put in the quiesce state\n",
+ 		dev_name(&device->cdev->dev));
+ 	dasd_device_set_stop_bits(device, DASD_STOPPED_QUIESCE);
+ 
+ 	if (device->features & DASD_FEATURE_REQUEUEQUIESCE)
+ 		dasd_schedule_requeue(device);
+ 
+ 	return 1;
+ }
++>>>>>>> 1cee2975bbab (s390/dasd: add autoquiesce feature)
  
  static struct dasd_ccw_req *dasd_generic_build_rdc(struct dasd_device *device,
 +						   void *rdc_buffer,
  						   int rdc_buffer_size,
  						   int magic)
  {
diff --git a/arch/s390/include/uapi/asm/dasd.h b/arch/s390/include/uapi/asm/dasd.h
index 93d1ccd3304c..9c49c3d67cd5 100644
--- a/arch/s390/include/uapi/asm/dasd.h
+++ b/arch/s390/include/uapi/asm/dasd.h
@@ -78,6 +78,7 @@ typedef struct dasd_information2_t {
  * 0x040: give access to raw eckd data
  * 0x080: enable discard support
  * 0x100: enable autodisable for IFCC errors (default)
+ * 0x200: enable requeue of all requests on autoquiesce
  */
 #define DASD_FEATURE_READONLY	      0x001
 #define DASD_FEATURE_USEDIAG	      0x002
@@ -88,6 +89,7 @@ typedef struct dasd_information2_t {
 #define DASD_FEATURE_USERAW	      0x040
 #define DASD_FEATURE_DISCARD	      0x080
 #define DASD_FEATURE_PATH_AUTODISABLE 0x100
+#define DASD_FEATURE_REQUEUEQUIESCE   0x200
 #define DASD_FEATURE_DEFAULT	      DASD_FEATURE_PATH_AUTODISABLE
 
 #define DASD_PARTN_BITS 2
* Unmerged path drivers/s390/block/dasd.c
diff --git a/drivers/s390/block/dasd_eer.c b/drivers/s390/block/dasd_eer.c
index 5ae64af9ccea..22338033e6bf 100644
--- a/drivers/s390/block/dasd_eer.c
+++ b/drivers/s390/block/dasd_eer.c
@@ -387,6 +387,7 @@ void dasd_eer_write(struct dasd_device *device, struct dasd_ccw_req *cqr,
 		break;
 	case DASD_EER_NOPATH:
 	case DASD_EER_NOSPC:
+	case DASD_EER_AUTOQUIESCE:
 		dasd_eer_write_standard_trigger(device, NULL, id);
 		break;
 	case DASD_EER_STATECHANGE:
diff --git a/drivers/s390/block/dasd_int.h b/drivers/s390/block/dasd_int.h
index f3620c619357..7f7ac8fbc20c 100644
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@ -455,6 +455,7 @@ extern struct dasd_discipline *dasd_diag_discipline_pointer;
 #define DASD_EER_STATECHANGE 3
 #define DASD_EER_PPRCSUSPEND 4
 #define DASD_EER_NOSPC	     5
+#define DASD_EER_AUTOQUIESCE 31
 
 /* DASD path handling */
 
@@ -633,6 +634,7 @@ struct dasd_device {
 	struct dasd_format_entry format_entry;
 	struct kset *paths_info;
 	struct dasd_copy_relation *copy;
+	unsigned long aq_mask;
 };
 
 struct dasd_block {
