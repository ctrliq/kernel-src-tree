net: ethernet: mtk_eth_wed: add axi bus support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 2b2ba3ecb2411c5e2a0d670be5e9ded2c93351e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/2b2ba3ec.failed

Other than pcie bus, introduce support for axi bus to mtk wed driver.
Axi bus is used to connect mt7986-wmac soc chip available on mt7986
device.

	Tested-by: Daniel Golle <daniel@makrotopia.org>
Co-developed-by: Bo Jiao <Bo.Jiao@mediatek.com>
	Signed-off-by: Bo Jiao <Bo.Jiao@mediatek.com>
Co-developed-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 2b2ba3ecb2411c5e2a0d670be5e9ded2c93351e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index d1ef5b563ddf,099b6e0df619..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -293,9 -356,14 +312,20 @@@ mtk_wed_detach(struct mtk_wed_device *d
  	mtk_wed_free_buffer(dev);
  	mtk_wed_free_tx_rings(dev);
  
++<<<<<<< HEAD
 +	if (of_dma_is_coherent(wlan_node))
 +		regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
 +				   BIT(hw->index), BIT(hw->index));
++=======
+ 	if (dev->wlan.bus_type == MTK_WED_BUS_PCIE) {
+ 		struct device_node *wlan_node;
+ 
+ 		wlan_node = dev->wlan.pci_dev->dev.of_node;
+ 		if (of_dma_is_coherent(wlan_node) && hw->hifsys)
+ 			regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
+ 					   BIT(hw->index), BIT(hw->index));
+ 	}
++>>>>>>> 2b2ba3ecb241 (net: ethernet: mtk_eth_wed: add axi bus support)
  
  	if (!hw_list[!hw->index]->wed_dev &&
  	    hw->eth->dma_dev != hw->eth->dev)
@@@ -308,6 -376,68 +338,71 @@@
  	mutex_unlock(&hw_lock);
  }
  
++<<<<<<< HEAD
++=======
+ #define PCIE_BASE_ADDR0		0x11280000
+ static void
+ mtk_wed_bus_init(struct mtk_wed_device *dev)
+ {
+ 	switch (dev->wlan.bus_type) {
+ 	case MTK_WED_BUS_PCIE: {
+ 		struct device_node *np = dev->hw->eth->dev->of_node;
+ 		struct regmap *regs;
+ 
+ 		regs = syscon_regmap_lookup_by_phandle(np,
+ 						       "mediatek,wed-pcie");
+ 		if (IS_ERR(regs))
+ 			break;
+ 
+ 		regmap_update_bits(regs, 0, BIT(0), BIT(0));
+ 
+ 		wed_w32(dev, MTK_WED_PCIE_INT_CTRL,
+ 			FIELD_PREP(MTK_WED_PCIE_INT_CTRL_POLL_EN, 2));
+ 
+ 		/* pcie interrupt control: pola/source selection */
+ 		wed_set(dev, MTK_WED_PCIE_INT_CTRL,
+ 			MTK_WED_PCIE_INT_CTRL_MSK_EN_POLA |
+ 			FIELD_PREP(MTK_WED_PCIE_INT_CTRL_SRC_SEL, 1));
+ 		wed_r32(dev, MTK_WED_PCIE_INT_CTRL);
+ 
+ 		wed_w32(dev, MTK_WED_PCIE_CFG_INTM, PCIE_BASE_ADDR0 | 0x180);
+ 		wed_w32(dev, MTK_WED_PCIE_CFG_BASE, PCIE_BASE_ADDR0 | 0x184);
+ 
+ 		/* pcie interrupt status trigger register */
+ 		wed_w32(dev, MTK_WED_PCIE_INT_TRIGGER, BIT(24));
+ 		wed_r32(dev, MTK_WED_PCIE_INT_TRIGGER);
+ 
+ 		/* pola setting */
+ 		wed_set(dev, MTK_WED_PCIE_INT_CTRL,
+ 			MTK_WED_PCIE_INT_CTRL_MSK_EN_POLA);
+ 		break;
+ 	}
+ 	case MTK_WED_BUS_AXI:
+ 		wed_set(dev, MTK_WED_WPDMA_INT_CTRL,
+ 			MTK_WED_WPDMA_INT_CTRL_SIG_SRC |
+ 			FIELD_PREP(MTK_WED_WPDMA_INT_CTRL_SRC_SEL, 0));
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void
+ mtk_wed_set_wpdma(struct mtk_wed_device *dev)
+ {
+ 	if (dev->hw->version == 1) {
+ 		wed_w32(dev, MTK_WED_WPDMA_CFG_BASE,  dev->wlan.wpdma_phys);
+ 	} else {
+ 		mtk_wed_bus_init(dev);
+ 
+ 		wed_w32(dev, MTK_WED_WPDMA_CFG_BASE,  dev->wlan.wpdma_int);
+ 		wed_w32(dev, MTK_WED_WPDMA_CFG_INT_MASK,  dev->wlan.wpdma_mask);
+ 		wed_w32(dev, MTK_WED_WPDMA_CFG_TX,  dev->wlan.wpdma_tx);
+ 		wed_w32(dev, MTK_WED_WPDMA_CFG_TX_FREE,  dev->wlan.wpdma_txfree);
+ 	}
+ }
+ 
++>>>>>>> 2b2ba3ecb241 (net: ethernet: mtk_eth_wed: add axi bus support)
  static void
  mtk_wed_hw_init_early(struct mtk_wed_device *dev)
  {
@@@ -639,7 -856,11 +736,15 @@@ mtk_wed_attach(struct mtk_wed_device *d
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	dev_info(&dev->wlan.pci_dev->dev, "attaching wed device %d\n", hw->index);
++=======
+ 	device = dev->wlan.bus_type == MTK_WED_BUS_PCIE
+ 		? &dev->wlan.pci_dev->dev
+ 		: &dev->wlan.platform_dev->dev;
+ 	dev_info(device, "attaching wed device %d version %d\n",
+ 		 hw->index, hw->version);
++>>>>>>> 2b2ba3ecb241 (net: ethernet: mtk_eth_wed: add axi bus support)
  
  	dev->hw = hw;
  	dev->dev = hw->dev;
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
diff --git a/drivers/net/ethernet/mediatek/mtk_wed_regs.h b/drivers/net/ethernet/mediatek/mtk_wed_regs.h
index eec22daebd30..4db9de00f7b6 100644
--- a/drivers/net/ethernet/mediatek/mtk_wed_regs.h
+++ b/drivers/net/ethernet/mediatek/mtk_wed_regs.h
@@ -161,6 +161,8 @@ struct mtk_wdma_desc {
 
 #define MTK_WED_WPDMA_INT_CTRL				0x520
 #define MTK_WED_WPDMA_INT_CTRL_SUBRT_ADV		BIT(21)
+#define MTK_WED_WPDMA_INT_CTRL_SIG_SRC			BIT(22)
+#define MTK_WED_WPDMA_INT_CTRL_SRC_SEL			GENMASK(17, 16)
 
 #define MTK_WED_WPDMA_INT_MASK				0x524
 
diff --git a/include/linux/soc/mediatek/mtk_wed.h b/include/linux/soc/mediatek/mtk_wed.h
index 7e00cca06709..db9455bd538a 100644
--- a/include/linux/soc/mediatek/mtk_wed.h
+++ b/include/linux/soc/mediatek/mtk_wed.h
@@ -11,6 +11,11 @@
 struct mtk_wed_hw;
 struct mtk_wdma_desc;
 
+enum mtk_wed_bus_tye {
+	MTK_WED_BUS_PCIE,
+	MTK_WED_BUS_AXI,
+};
+
 struct mtk_wed_ring {
 	struct mtk_wdma_desc *desc;
 	dma_addr_t desc_phys;
@@ -42,7 +47,11 @@ struct mtk_wed_device {
 
 	/* filled by driver: */
 	struct {
-		struct pci_dev *pci_dev;
+		union {
+			struct platform_device *platform_dev;
+			struct pci_dev *pci_dev;
+		};
+		enum mtk_wed_bus_tye bus_type;
 
 		u32 wpdma_phys;
 
