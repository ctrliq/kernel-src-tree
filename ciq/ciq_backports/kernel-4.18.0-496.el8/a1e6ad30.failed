net/sched: taprio: calculate guard band against actual TC gate close time

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit a1e6ad30fa193962b5aa61ea4d12ee83a7ce9020
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/a1e6ad30.failed

taprio_dequeue_from_txq() looks at the entry->end_time to determine
whether the skb will overrun its traffic class gate, as if at the end of
the schedule entry there surely is a "gate close" event for it. Hint:
maybe there isn't.

For each schedule entry, introduce an array of kernel times which
actually tracks when in the future will there be an *actual* gate close
event for that traffic class, and use that in the guard band overrun
calculation.

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Kurt Kanzenbach <kurt@linutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a1e6ad30fa193962b5aa61ea4d12ee83a7ce9020)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_taprio.c
diff --cc net/sched/sch_taprio.c
index f060d7e1bd80,e625f8f8704f..000000000000
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@@ -37,15 -43,15 +37,24 @@@ struct sched_entry 
  	 * respective traffic class gate closes
  	 */
  	u64 gate_duration[TC_MAX_QUEUE];
++<<<<<<< HEAD
 +	struct list_head list;
 +
 +	/* The instant that this entry ends and the next one
 +	 * should open, the qdisc will make some effort so that no
 +	 * packet leaves after this time.
++=======
+ 	atomic_t budget[TC_MAX_QUEUE];
+ 	/* The qdisc makes some effort so that no packet leaves
+ 	 * after this time
++>>>>>>> a1e6ad30fa19 (net/sched: taprio: calculate guard band against actual TC gate close time)
  	 */
+ 	ktime_t gate_close_time[TC_MAX_QUEUE];
+ 	struct list_head list;
+ 	/* Used to calculate when to advance the schedule */
  	ktime_t end_time;
  	ktime_t next_txtime;
 +	atomic_t budget;
  	int index;
  	u32 gate_mask;
  	u32 interval;
@@@ -1047,7 -1149,15 +1076,19 @@@ static void setup_first_end_time(struc
  	sched->cycle_end_time = ktime_add_ns(base, cycle);
  
  	first->end_time = ktime_add_ns(base, first->interval);
++<<<<<<< HEAD
 +	taprio_set_budget(q, first);
++=======
+ 	taprio_set_budgets(q, sched, first);
+ 
+ 	for (tc = 0; tc < num_tc; tc++) {
+ 		if (first->gate_duration[tc] == sched->cycle_time)
+ 			first->gate_close_time[tc] = KTIME_MAX;
+ 		else
+ 			first->gate_close_time[tc] = ktime_add_ns(base, first->gate_duration[tc]);
+ 	}
+ 
++>>>>>>> a1e6ad30fa19 (net/sched: taprio: calculate guard band against actual TC gate close time)
  	rcu_assign_pointer(q->current_entry, NULL);
  }
  
* Unmerged path net/sched/sch_taprio.c
