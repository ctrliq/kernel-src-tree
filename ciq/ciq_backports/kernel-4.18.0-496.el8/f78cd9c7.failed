net: ethernet: mtk_wed: update mtk_wed_stop

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit f78cd9c783e09a0fe454b0fc8b39c22025d7869e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/f78cd9c7.failed

Update mtk_wed_stop routine and rename old mtk_wed_stop() to
mtk_wed_deinit(). This is a preliminary patch to add Wireless Ethernet
Dispatcher reset support.

Co-developed-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit f78cd9c783e09a0fe454b0fc8b39c22025d7869e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
#	include/linux/soc/mediatek/mtk_wed.h
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index 420f6a7c88c7,42b7e0407a9b..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -273,6 -546,33 +267,36 @@@ mtk_wed_stop(struct mtk_wed_device *dev
  	wdma_w32(dev, MTK_WDMA_INT_MASK, 0);
  	wdma_w32(dev, MTK_WDMA_INT_GRP2, 0);
  	wed_w32(dev, MTK_WED_WPDMA_INT_MASK, 0);
++<<<<<<< HEAD
++=======
+ 
+ 	if (dev->hw->version == 1)
+ 		return;
+ 
+ 	wed_w32(dev, MTK_WED_EXT_INT_MASK1, 0);
+ 	wed_w32(dev, MTK_WED_EXT_INT_MASK2, 0);
+ }
+ 
+ static void
+ mtk_wed_deinit(struct mtk_wed_device *dev)
+ {
+ 	mtk_wed_stop(dev);
+ 	mtk_wed_dma_disable(dev);
+ 
+ 	wed_clr(dev, MTK_WED_CTRL,
+ 		MTK_WED_CTRL_WDMA_INT_AGENT_EN |
+ 		MTK_WED_CTRL_WPDMA_INT_AGENT_EN |
+ 		MTK_WED_CTRL_WED_TX_BM_EN |
+ 		MTK_WED_CTRL_WED_TX_FREE_AGENT_EN);
+ 
+ 	if (dev->hw->version == 1)
+ 		return;
+ 
+ 	wed_clr(dev, MTK_WED_CTRL,
+ 		MTK_WED_CTRL_RX_ROUTE_QM_EN |
+ 		MTK_WED_CTRL_WED_RX_BM_EN |
+ 		MTK_WED_CTRL_RX_RRO_QM_EN);
++>>>>>>> f78cd9c783e0 (net: ethernet: mtk_wed: update mtk_wed_stop)
  }
  
  static void
@@@ -283,19 -582,27 +307,19 @@@ mtk_wed_detach(struct mtk_wed_device *d
  
  	mutex_lock(&hw_lock);
  
- 	mtk_wed_stop(dev);
+ 	mtk_wed_deinit(dev);
  
 -	mtk_wdma_rx_reset(dev);
 -	mtk_wed_reset(dev, MTK_WED_RESET_WED);
 -	mtk_wed_free_tx_buffer(dev);
 -	mtk_wed_free_tx_rings(dev);
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
  
 -	if (mtk_wed_get_rx_capa(dev)) {
 -		mtk_wed_wo_reset(dev);
 -		mtk_wed_free_rx_rings(dev);
 -		mtk_wed_wo_deinit(hw);
 -	}
 +	mtk_wed_reset(dev, MTK_WED_RESET_WED);
  
 -	if (dev->wlan.bus_type == MTK_WED_BUS_PCIE) {
 -		struct device_node *wlan_node;
 +	mtk_wed_free_buffer(dev);
 +	mtk_wed_free_tx_rings(dev);
  
 -		wlan_node = dev->wlan.pci_dev->dev.of_node;
 -		if (of_dma_is_coherent(wlan_node) && hw->hifsys)
 -			regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
 -					   BIT(hw->index), BIT(hw->index));
 -	}
 +	if (of_dma_is_coherent(wlan_node))
 +		regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
 +				   BIT(hw->index), BIT(hw->index));
  
  	if (!hw_list[!hw->index]->wed_dev &&
  	    hw->eth->dma_dev != hw->eth->dev)
@@@ -312,10 -683,10 +336,10 @@@ static voi
  mtk_wed_hw_init_early(struct mtk_wed_device *dev)
  {
  	u32 mask, set;
 +	u32 offset;
  
- 	mtk_wed_stop(dev);
+ 	mtk_wed_deinit(dev);
  	mtk_wed_reset(dev, MTK_WED_RESET_WED);
 -	mtk_wed_set_wpdma(dev);
  
  	mask = MTK_WED_WDMA_GLO_CFG_BT_SIZE |
  	       MTK_WED_WDMA_GLO_CFG_DYNAMIC_DMAD_RECYCLE |
diff --cc include/linux/soc/mediatek/mtk_wed.h
index 7e00cca06709,c43510e541df..000000000000
--- a/include/linux/soc/mediatek/mtk_wed.h
+++ b/include/linux/soc/mediatek/mtk_wed.h
@@@ -113,6 -228,14 +113,17 @@@ mtk_wed_device_attach(struct mtk_wed_de
  	(_dev)->ops->irq_get(_dev, _mask)
  #define mtk_wed_device_irq_set_mask(_dev, _mask) \
  	(_dev)->ops->irq_set_mask(_dev, _mask)
++<<<<<<< HEAD
++=======
+ #define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs) \
+ 	(_dev)->ops->rx_ring_setup(_dev, _ring, _regs)
+ #define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash) \
+ 	(_dev)->ops->ppe_check(_dev, _skb, _reason, _hash)
+ #define mtk_wed_device_update_msg(_dev, _id, _msg, _len) \
+ 	(_dev)->ops->msg_update(_dev, _id, _msg, _len)
+ #define mtk_wed_device_stop(_dev) (_dev)->ops->stop(_dev)
+ #define mtk_wed_device_dma_reset(_dev) (_dev)->ops->reset_dma(_dev)
++>>>>>>> f78cd9c783e0 (net: ethernet: mtk_wed: update mtk_wed_stop)
  #else
  static inline bool mtk_wed_device_active(struct mtk_wed_device *dev)
  {
@@@ -126,6 -249,11 +137,14 @@@
  #define mtk_wed_device_reg_write(_dev, _reg, _val) do {} while (0)
  #define mtk_wed_device_irq_get(_dev, _mask) 0
  #define mtk_wed_device_irq_set_mask(_dev, _mask) do {} while (0)
++<<<<<<< HEAD
++=======
+ #define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs) -ENODEV
+ #define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash)  do {} while (0)
+ #define mtk_wed_device_update_msg(_dev, _id, _msg, _len) -ENODEV
+ #define mtk_wed_device_stop(_dev) do {} while (0)
+ #define mtk_wed_device_dma_reset(_dev) do {} while (0)
++>>>>>>> f78cd9c783e0 (net: ethernet: mtk_wed: update mtk_wed_stop)
  #endif
  
  #endif
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
* Unmerged path include/linux/soc/mediatek/mtk_wed.h
