netfilter: nf_tables: make table handle allocation per-netns friendly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit ab482c6b66a4a8c0a8c0b0f577a785cf9ff1c2e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/ab482c6b.failed

mutex is per-netns, move table_netns to the pernet area.

*read-write* to 0xffffffff883a01e8 of 8 bytes by task 6542 on cpu 0:
 nf_tables_newtable+0x6dc/0xc00 net/netfilter/nf_tables_api.c:1221
 nfnetlink_rcv_batch net/netfilter/nfnetlink.c:513 [inline]
 nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:634 [inline]
 nfnetlink_rcv+0xa6a/0x13a0 net/netfilter/nfnetlink.c:652
 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
 netlink_unicast+0x652/0x730 net/netlink/af_netlink.c:1345
 netlink_sendmsg+0x643/0x740 net/netlink/af_netlink.c:1921

Fixes: f102d66b335a ("netfilter: nf_tables: use dedicated mutex to guard transactions")
	Reported-by: Abhishek Shah <abhishek.shah@columbia.edu>
	Reviewed-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit ab482c6b66a4a8c0a8c0b0f577a785cf9ff1c2e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
diff --cc include/net/netfilter/nf_tables.h
index 6c8e93a3cf77,cdb7db9b0e25..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -1534,4 -1645,44 +1534,47 @@@ __printf(2, 3) int nft_request_module(s
  #else
  static inline int nft_request_module(struct net *net, const char *fmt, ...) { return -ENOENT; }
  #endif
++<<<<<<< HEAD
++=======
+ 
+ struct nftables_pernet {
+ 	struct list_head	tables;
+ 	struct list_head	commit_list;
+ 	struct list_head	module_list;
+ 	struct list_head	notify_list;
+ 	struct mutex		commit_mutex;
+ 	u64			table_handle;
+ 	unsigned int		base_seq;
+ 	u8			validate_state;
+ };
+ 
+ extern unsigned int nf_tables_net_id;
+ 
+ static inline struct nftables_pernet *nft_pernet(const struct net *net)
+ {
+ 	return net_generic(net, nf_tables_net_id);
+ }
+ 
+ #define __NFT_REDUCE_READONLY	1UL
+ #define NFT_REDUCE_READONLY	(void *)__NFT_REDUCE_READONLY
+ 
+ static inline bool nft_reduce_is_readonly(const struct nft_expr *expr)
+ {
+ 	return expr->ops->reduce == NFT_REDUCE_READONLY;
+ }
+ 
+ void nft_reg_track_update(struct nft_regs_track *track,
+ 			  const struct nft_expr *expr, u8 dreg, u8 len);
+ void nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg, u8 len);
+ void __nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg);
+ 
+ static inline bool nft_reg_track_cmp(struct nft_regs_track *track,
+ 				     const struct nft_expr *expr, u8 dreg)
+ {
+ 	return track->regs[dreg].selector &&
+ 	       track->regs[dreg].selector->ops == expr->ops &&
+ 	       track->regs[dreg].num_reg == 0;
+ }
+ 
++>>>>>>> ab482c6b66a4 (netfilter: nf_tables: make table handle allocation per-netns friendly)
  #endif /* _NET_NF_TABLES_H */
diff --cc net/netfilter/nf_tables_api.c
index 81e33804d4d3,0951f31caabe..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1075,9 -1234,11 +1074,15 @@@ static int nf_tables_newtable(struct ne
  	INIT_LIST_HEAD(&table->flowtables);
  	table->family = family;
  	table->flags = flags;
++<<<<<<< HEAD
 +	table->handle = ++table_handle;
++=======
+ 	table->handle = ++nft_net->table_handle;
+ 	if (table->flags & NFT_TABLE_F_OWNER)
+ 		table->nlpid = NETLINK_CB(skb).portid;
++>>>>>>> ab482c6b66a4 (netfilter: nf_tables: make table handle allocation per-netns friendly)
  
 -	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);
 +	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
  	err = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);
  	if (err < 0)
  		goto err_trans;
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
