s390/dasd: add aq_timeouts autoquiesce trigger

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Stefan Haberland <sth@linux.ibm.com>
commit 0c1a14748133024a33aa8ffd763ca7f5c03bb27e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/0c1a1474.failed

Add a sysfs attribute aq_timeouts that controls after how many
timeouts a autoquiesce event might be triggered.

The default value is 32768 which is the maximum number of retries
for the DASD device driver DASD_RETRIES_MAX. This means that the
timeout trigger will never happen.

The default value for DASD retries is 255.
Setting the value to below 255 will trigger the timeout autoquiesce
event before an IO error is generated.

Also add the check for the configured amount of timeouts and trigger
an autoquiesce event if exceeded.

	Signed-off-by: Stefan Haberland <sth@linux.ibm.com>
	Reviewed-by: Jan Hoeppner <hoeppner@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
Link: https://lore.kernel.org/r/20230405142017.2446986-6-sth@linux.ibm.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 0c1a14748133024a33aa8ffd763ca7f5c03bb27e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/dasd_devmap.c
#	drivers/s390/block/dasd_int.h
diff --cc drivers/s390/block/dasd_devmap.c
index 6205dec03411,620fab01b710..000000000000
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@@ -1476,6 -1477,128 +1476,131 @@@ dasd_eer_store(struct device *dev, stru
  static DEVICE_ATTR(eer_enabled, 0644, dasd_eer_show, dasd_eer_store);
  
  /*
++<<<<<<< HEAD
++=======
+  * aq_mask controls if the DASD should be quiesced on certain triggers
+  * The aq_mask attribute is interpreted as bitmap of the DASD_EER_* triggers.
+  */
+ static ssize_t dasd_aq_mask_show(struct device *dev, struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct dasd_devmap *devmap;
+ 	unsigned int aq_mask = 0;
+ 
+ 	devmap = dasd_find_busid(dev_name(dev));
+ 	if (!IS_ERR(devmap))
+ 		aq_mask = devmap->aq_mask;
+ 
+ 	return sysfs_emit(buf, "%d\n", aq_mask);
+ }
+ 
+ static ssize_t dasd_aq_mask_store(struct device *dev, struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct dasd_devmap *devmap;
+ 	unsigned int val;
+ 
+ 	if (kstrtouint(buf, 0, &val) || val > DASD_EER_VALID)
+ 		return -EINVAL;
+ 
+ 	devmap = dasd_devmap_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(devmap))
+ 		return PTR_ERR(devmap);
+ 
+ 	spin_lock(&dasd_devmap_lock);
+ 	devmap->aq_mask = val;
+ 	if (devmap->device)
+ 		devmap->device->aq_mask = devmap->aq_mask;
+ 	spin_unlock(&dasd_devmap_lock);
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(aq_mask, 0644, dasd_aq_mask_show, dasd_aq_mask_store);
+ 
+ /*
+  * aq_requeue controls if requests are returned to the blocklayer on quiesce
+  * or if requests are only not started
+  */
+ static ssize_t dasd_aqr_show(struct device *dev, struct device_attribute *attr,
+ 			     char *buf)
+ {
+ 	struct dasd_devmap *devmap;
+ 	int flag;
+ 
+ 	devmap = dasd_find_busid(dev_name(dev));
+ 	if (!IS_ERR(devmap))
+ 		flag = (devmap->features & DASD_FEATURE_REQUEUEQUIESCE) != 0;
+ 	else
+ 		flag = (DASD_FEATURE_DEFAULT &
+ 			DASD_FEATURE_REQUEUEQUIESCE) != 0;
+ 	return sysfs_emit(buf, "%d\n", flag);
+ }
+ 
+ static ssize_t dasd_aqr_store(struct device *dev, struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+ 	bool val;
+ 	int rc;
+ 
+ 	if (kstrtobool(buf, &val))
+ 		return -EINVAL;
+ 
+ 	rc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_REQUEUEQUIESCE, val);
+ 
+ 	return rc ? : count;
+ }
+ 
+ static DEVICE_ATTR(aq_requeue, 0644, dasd_aqr_show, dasd_aqr_store);
+ 
+ /*
+  * aq_timeouts controls how much retries have to time out until
+  * a device gets autoquiesced
+  */
+ static ssize_t
+ dasd_aq_timeouts_show(struct device *dev, struct device_attribute *attr,
+ 		      char *buf)
+ {
+ 	struct dasd_device *device;
+ 	int len;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return -ENODEV;
+ 	len = sysfs_emit(buf, "%u\n", device->aq_timeouts);
+ 	dasd_put_device(device);
+ 	return len;
+ }
+ 
+ static ssize_t
+ dasd_aq_timeouts_store(struct device *dev, struct device_attribute *attr,
+ 		       const char *buf, size_t count)
+ {
+ 	struct dasd_device *device;
+ 	unsigned int val;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return -ENODEV;
+ 
+ 	if ((kstrtouint(buf, 10, &val) != 0) ||
+ 	    val > DASD_RETRIES_MAX || val == 0) {
+ 		dasd_put_device(device);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (val)
+ 		device->aq_timeouts = val;
+ 
+ 	dasd_put_device(device);
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(aq_timeouts, 0644, dasd_aq_timeouts_show,
+ 		   dasd_aq_timeouts_store);
+ 
+ /*
++>>>>>>> 0c1a14748133 (s390/dasd: add aq_timeouts autoquiesce trigger)
   * expiration time for default requests
   */
  static ssize_t
@@@ -2327,6 -2447,9 +2452,12 @@@ static struct attribute * dasd_attrs[] 
  	&dev_attr_copy_pair.attr,
  	&dev_attr_copy_role.attr,
  	&dev_attr_ping.attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_aq_mask.attr,
+ 	&dev_attr_aq_requeue.attr,
+ 	&dev_attr_aq_timeouts.attr,
++>>>>>>> 0c1a14748133 (s390/dasd: add aq_timeouts autoquiesce trigger)
  	NULL,
  };
  
diff --cc drivers/s390/block/dasd_int.h
index f3620c619357,33f812f0e515..000000000000
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@@ -633,6 -637,8 +633,11 @@@ struct dasd_device 
  	struct dasd_format_entry format_entry;
  	struct kset *paths_info;
  	struct dasd_copy_relation *copy;
++<<<<<<< HEAD
++=======
+ 	unsigned long aq_mask;
+ 	unsigned int aq_timeouts;
++>>>>>>> 0c1a14748133 (s390/dasd: add aq_timeouts autoquiesce trigger)
  };
  
  struct dasd_block {
diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index bc6177f37572..a7daa84369ff 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -2020,6 +2020,16 @@ static void __dasd_device_process_final_queue(struct dasd_device *device,
 	}
 }
 
+/*
+ * check if device should be autoquiesced due to too many timeouts
+ */
+static void __dasd_device_check_autoquiesce_timeout(struct dasd_device *device,
+						    struct dasd_ccw_req *cqr)
+{
+	if ((device->default_retries - cqr->retries) >= device->aq_timeouts)
+		dasd_handle_autoquiesce(device, cqr, DASD_EER_TIMEOUTS);
+}
+
 /*
  * Take a look at the first request on the ccw queue and check
  * if it reached its expire time. If so, terminate the IO.
@@ -2054,6 +2064,7 @@ static void __dasd_device_check_expire(struct dasd_device *device)
 				"remaining\n", cqr, (cqr->expires/HZ),
 				cqr->retries);
 		}
+		__dasd_device_check_autoquiesce_timeout(device, cqr);
 	}
 }
 
* Unmerged path drivers/s390/block/dasd_devmap.c
diff --git a/drivers/s390/block/dasd_eckd.c b/drivers/s390/block/dasd_eckd.c
index b26a9795d198..e8e29c6a7dde 100644
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -2125,6 +2125,7 @@ dasd_eckd_check_characteristics(struct dasd_device *device)
 	device->default_retries = DASD_RETRIES;
 	device->path_thrhld = DASD_ECKD_PATH_THRHLD;
 	device->path_interval = DASD_ECKD_PATH_INTERVAL;
+	device->aq_timeouts = DASD_RETRIES_MAX;
 
 	if (private->gneq) {
 		value = 1;
* Unmerged path drivers/s390/block/dasd_int.h
