net: ethernet: mtk_wed: return status value in mtk_wdma_rx_reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit b0488c4598a599157ac9b588541c3c6c5055e80f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/b0488c45.failed

Move MTK_WDMA_RESET_IDX configuration in mtk_wdma_rx_reset routine.
Increase poll timeout to 10ms in order to be aligned with vendor sdk.
This is a preliminary patch to add Wireless Ethernet Dispatcher reset
support.

Co-developed-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit b0488c4598a599157ac9b588541c3c6c5055e80f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index 420f6a7c88c7,4ab2ec9dc5d3..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -65,6 -95,58 +65,61 @@@ mtk_wed_read_reset(struct mtk_wed_devic
  	return wed_r32(dev, MTK_WED_RESET);
  }
  
++<<<<<<< HEAD
++=======
+ static u32
+ mtk_wdma_read_reset(struct mtk_wed_device *dev)
+ {
+ 	return wdma_r32(dev, MTK_WDMA_GLO_CFG);
+ }
+ 
+ static int
+ mtk_wdma_rx_reset(struct mtk_wed_device *dev)
+ {
+ 	u32 status, mask = MTK_WDMA_GLO_CFG_RX_DMA_BUSY;
+ 	int i, ret;
+ 
+ 	wdma_clr(dev, MTK_WDMA_GLO_CFG, MTK_WDMA_GLO_CFG_RX_DMA_EN);
+ 	ret = readx_poll_timeout(mtk_wdma_read_reset, dev, status,
+ 				 !(status & mask), 0, 10000);
+ 	if (ret)
+ 		dev_err(dev->hw->dev, "rx reset failed\n");
+ 
+ 	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
+ 	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->rx_wdma); i++) {
+ 		if (dev->rx_wdma[i].desc)
+ 			continue;
+ 
+ 		wdma_w32(dev,
+ 			 MTK_WDMA_RING_RX(i) + MTK_WED_RING_OFS_CPU_IDX, 0);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void
+ mtk_wdma_tx_reset(struct mtk_wed_device *dev)
+ {
+ 	u32 status, mask = MTK_WDMA_GLO_CFG_TX_DMA_BUSY;
+ 	int i;
+ 
+ 	wdma_clr(dev, MTK_WDMA_GLO_CFG, MTK_WDMA_GLO_CFG_TX_DMA_EN);
+ 	if (readx_poll_timeout(mtk_wdma_read_reset, dev, status,
+ 			       !(status & mask), 0, 1000))
+ 		dev_err(dev->hw->dev, "tx reset failed\n");
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->tx_wdma); i++) {
+ 		if (dev->tx_wdma[i].desc)
+ 			continue;
+ 
+ 		wdma_w32(dev,
+ 			 MTK_WDMA_RING_TX(i) + MTK_WED_RING_OFS_CPU_IDX, 0);
+ 	}
+ }
+ 
++>>>>>>> b0488c4598a5 (net: ethernet: mtk_wed: return status value in mtk_wdma_rx_reset)
  static void
  mtk_wed_reset(struct mtk_wed_device *dev, u32 mask)
  {
@@@ -285,17 -571,31 +340,32 @@@ mtk_wed_detach(struct mtk_wed_device *d
  
  	mtk_wed_stop(dev);
  
- 	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
- 	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
- 
+ 	mtk_wdma_rx_reset(dev);
  	mtk_wed_reset(dev, MTK_WED_RESET_WED);
 -	if (mtk_wed_get_rx_capa(dev)) {
 -		wdma_clr(dev, MTK_WDMA_GLO_CFG, MTK_WDMA_GLO_CFG_TX_DMA_EN);
 -		wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_TX);
 -		wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
 -	}
  
 -	mtk_wed_free_tx_buffer(dev);
 +	mtk_wed_free_buffer(dev);
  	mtk_wed_free_tx_rings(dev);
  
++<<<<<<< HEAD
 +	if (of_dma_is_coherent(wlan_node))
 +		regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
 +				   BIT(hw->index), BIT(hw->index));
++=======
+ 	if (mtk_wed_get_rx_capa(dev)) {
+ 		mtk_wed_wo_reset(dev);
+ 		mtk_wed_free_rx_rings(dev);
+ 		mtk_wed_wo_deinit(hw);
+ 	}
+ 
+ 	if (dev->wlan.bus_type == MTK_WED_BUS_PCIE) {
+ 		struct device_node *wlan_node;
+ 
+ 		wlan_node = dev->wlan.pci_dev->dev.of_node;
+ 		if (of_dma_is_coherent(wlan_node) && hw->hifsys)
+ 			regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
+ 					   BIT(hw->index), BIT(hw->index));
+ 	}
++>>>>>>> b0488c4598a5 (net: ethernet: mtk_wed: return status value in mtk_wdma_rx_reset)
  
  	if (!hw_list[!hw->index]->wed_dev &&
  	    hw->eth->dma_dev != hw->eth->dev)
@@@ -456,8 -1002,7 +526,12 @@@ mtk_wed_reset_dma(struct mtk_wed_devic
  		wed_w32(dev, MTK_WED_RESET_IDX, 0);
  	}
  
++<<<<<<< HEAD
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
++=======
+ 	mtk_wdma_rx_reset(dev);
++>>>>>>> b0488c4598a5 (net: ethernet: mtk_wed: return status value in mtk_wdma_rx_reset)
  
  	if (busy) {
  		mtk_wed_reset(dev, MTK_WED_RESET_WDMA_INT_AGENT);
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
