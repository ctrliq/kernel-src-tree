net/sched: taprio: don't segment unnecessarily

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit 39b02d6d104a285836d98be2ad00c7f484d43a16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/39b02d6d.failed

Improve commit 497cc00224cf ("taprio: Handle short intervals and large
packets") to only perform segmentation when skb->len exceeds what
taprio_dequeue() expects.

In practice, this will make the biggest difference when a traffic class
gate is always open in the schedule. This is because the max_frm_len
will be U32_MAX, and such large skb->len values as Kurt reported will be
sent just fine unsegmented.

What I don't seem to know how to handle is how to make sure that the
segmented skbs themselves are smaller than the maximum frame size given
by the current queueMaxSDU[tc]. Nonetheless, we still need to drop
those, otherwise the Qdisc will hang.

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Kurt Kanzenbach <kurt@linutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 39b02d6d104a285836d98be2ad00c7f484d43a16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_taprio.c
diff --cc net/sched/sch_taprio.c
index 45d4da9669a4,9781b47962bb..000000000000
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@@ -482,11 -566,6 +482,14 @@@ static int taprio_enqueue_one(struct sk
  			return qdisc_drop(skb, sch, to_free);
  	}
  
++<<<<<<< HEAD
 +	/* Devices with full offload are expected to honor this in hardware */
 +	tc = netdev_get_prio_tc_map(dev, prio);
 +	if (skb->len > q->max_frm_len[tc])
 +		return qdisc_drop(skb, sch, to_free);
 +
++=======
++>>>>>>> 39b02d6d104a (net/sched: taprio: don't segment unnecessarily)
  	qdisc_qstats_backlog_inc(sch, skb);
  	sch->q.qlen++;
  
* Unmerged path net/sched/sch_taprio.c
