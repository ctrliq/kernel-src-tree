net: ethernet: mtk_wed: move MTK_WDMA_RESET_IDX_TX configuration in mtk_wdma_tx_reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 92b1169660ebe80e09c546555521a043cf7d26bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/92b11696.failed

Remove duplicated code. Increase poll timeout to 10ms in order to be
aligned with vendor sdk.
This is a preliminary patch to add Wireless Ethernet Dispatcher reset
support.

Co-developed-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 92b1169660ebe80e09c546555521a043cf7d26bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index 420f6a7c88c7,dbe10bbdb6f6..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -65,6 -95,57 +65,60 @@@ mtk_wed_read_reset(struct mtk_wed_devic
  	return wed_r32(dev, MTK_WED_RESET);
  }
  
++<<<<<<< HEAD
++=======
+ static u32
+ mtk_wdma_read_reset(struct mtk_wed_device *dev)
+ {
+ 	return wdma_r32(dev, MTK_WDMA_GLO_CFG);
+ }
+ 
+ static int
+ mtk_wdma_rx_reset(struct mtk_wed_device *dev)
+ {
+ 	u32 status, mask = MTK_WDMA_GLO_CFG_RX_DMA_BUSY;
+ 	int i, ret;
+ 
+ 	wdma_clr(dev, MTK_WDMA_GLO_CFG, MTK_WDMA_GLO_CFG_RX_DMA_EN);
+ 	ret = readx_poll_timeout(mtk_wdma_read_reset, dev, status,
+ 				 !(status & mask), 0, 10000);
+ 	if (ret)
+ 		dev_err(dev->hw->dev, "rx reset failed\n");
+ 
+ 	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
+ 	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->rx_wdma); i++) {
+ 		if (dev->rx_wdma[i].desc)
+ 			continue;
+ 
+ 		wdma_w32(dev,
+ 			 MTK_WDMA_RING_RX(i) + MTK_WED_RING_OFS_CPU_IDX, 0);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void
+ mtk_wdma_tx_reset(struct mtk_wed_device *dev)
+ {
+ 	u32 status, mask = MTK_WDMA_GLO_CFG_TX_DMA_BUSY;
+ 	int i;
+ 
+ 	wdma_clr(dev, MTK_WDMA_GLO_CFG, MTK_WDMA_GLO_CFG_TX_DMA_EN);
+ 	if (readx_poll_timeout(mtk_wdma_read_reset, dev, status,
+ 			       !(status & mask), 0, 10000))
+ 		dev_err(dev->hw->dev, "tx reset failed\n");
+ 
+ 	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_TX);
+ 	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->tx_wdma); i++)
+ 		wdma_w32(dev,
+ 			 MTK_WDMA_RING_TX(i) + MTK_WED_RING_OFS_CPU_IDX, 0);
+ }
+ 
++>>>>>>> 92b1169660eb (net: ethernet: mtk_wed: move MTK_WDMA_RESET_IDX_TX configuration in mtk_wdma_tx_reset)
  static void
  mtk_wed_reset(struct mtk_wed_device *dev, u32 mask)
  {
@@@ -285,17 -570,25 +339,23 @@@ mtk_wed_detach(struct mtk_wed_device *d
  
  	mtk_wed_stop(dev);
  
++<<<<<<< HEAD
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
 +
 +	mtk_wed_reset(dev, MTK_WED_RESET_WED);
 +
 +	mtk_wed_free_buffer(dev);
++=======
+ 	mtk_wdma_rx_reset(dev);
+ 	mtk_wed_reset(dev, MTK_WED_RESET_WED);
+ 	mtk_wed_free_tx_buffer(dev);
++>>>>>>> 92b1169660eb (net: ethernet: mtk_wed: move MTK_WDMA_RESET_IDX_TX configuration in mtk_wdma_tx_reset)
  	mtk_wed_free_tx_rings(dev);
  
 -	if (mtk_wed_get_rx_capa(dev)) {
 -		mtk_wed_wo_reset(dev);
 -		mtk_wed_free_rx_rings(dev);
 -		mtk_wed_wo_deinit(hw);
 -	}
 -
 -	if (dev->wlan.bus_type == MTK_WED_BUS_PCIE) {
 -		struct device_node *wlan_node;
 -
 -		wlan_node = dev->wlan.pci_dev->dev.of_node;
 -		if (of_dma_is_coherent(wlan_node) && hw->hifsys)
 -			regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
 -					   BIT(hw->index), BIT(hw->index));
 -	}
 +	if (of_dma_is_coherent(wlan_node))
 +		regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
 +				   BIT(hw->index), BIT(hw->index));
  
  	if (!hw_list[!hw->index]->wed_dev &&
  	    hw->eth->dma_dev != hw->eth->dev)
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
