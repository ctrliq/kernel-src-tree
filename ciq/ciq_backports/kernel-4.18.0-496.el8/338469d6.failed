net/sched: clear actions pointer in miss cookie init fail

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Pedro Tammela <pctammela@mojatatu.com>
commit 338469d677e5d426f5ada88761f16f6d2c7c1981
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/338469d6.failed

Palash reports a UAF when using a modified version of syzkaller[1].

When 'tcf_exts_miss_cookie_base_alloc()' fails in 'tcf_exts_init_ex()'
a call to 'tcf_exts_destroy()' is made to free up the tcf_exts
resources.
In flower, a call to '__fl_put()' when 'tcf_exts_init_ex()' fails is made;
Then calling 'tcf_exts_destroy()', which triggers an UAF since the
already freed tcf_exts action pointer is lingering in the struct.

Before the offending patch, this was not an issue since there was no
case where the tcf_exts action pointer could linger. Therefore, restore
the old semantic by clearing the action pointer in case of a failure to
initialize the miss_cookie.

[1] https://github.com/cmu-pasta/linux-kernel-enriched-corpus

v1->v2: Fix compilation on configs without tc actions (kernel test robot)

Fixes: 80cd22c35c90 ("net/sched: cls_api: Support hardware miss to tc action")
	Reported-by: Palash Oswal <oswalpalash@gmail.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Pedro Tammela <pctammela@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 338469d677e5d426f5ada88761f16f6d2c7c1981)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index cbeb5ab635f8,35785a36c802..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -3061,8 -3202,50 +3061,51 @@@ out
  	return skb->len;
  }
  
++<<<<<<< HEAD
++=======
+ int tcf_exts_init_ex(struct tcf_exts *exts, struct net *net, int action,
+ 		     int police, struct tcf_proto *tp, u32 handle,
+ 		     bool use_action_miss)
+ {
+ 	int err = 0;
+ 
+ #ifdef CONFIG_NET_CLS_ACT
+ 	exts->type = 0;
+ 	exts->nr_actions = 0;
+ 	/* Note: we do not own yet a reference on net.
+ 	 * This reference might be taken later from tcf_exts_get_net().
+ 	 */
+ 	exts->net = net;
+ 	exts->actions = kcalloc(TCA_ACT_MAX_PRIO, sizeof(struct tc_action *),
+ 				GFP_KERNEL);
+ 	if (!exts->actions)
+ 		return -ENOMEM;
+ #endif
+ 
+ 	exts->action = action;
+ 	exts->police = police;
+ 
+ 	if (!use_action_miss)
+ 		return 0;
+ 
+ 	err = tcf_exts_miss_cookie_base_alloc(exts, tp, handle);
+ 	if (err)
+ 		goto err_miss_alloc;
+ 
+ 	return 0;
+ 
+ err_miss_alloc:
+ 	tcf_exts_destroy(exts);
+ #ifdef CONFIG_NET_CLS_ACT
+ 	exts->actions = NULL;
+ #endif
+ 	return err;
+ }
+ EXPORT_SYMBOL(tcf_exts_init_ex);
+ 
++>>>>>>> 338469d677e5 (net/sched: clear actions pointer in miss cookie init fail)
  void tcf_exts_destroy(struct tcf_exts *exts)
  {
 -	tcf_exts_miss_cookie_base_destroy(exts);
 -
  #ifdef CONFIG_NET_CLS_ACT
  	if (exts->actions) {
  		tcf_action_destroy(exts->actions, TCA_ACT_UNBIND);
* Unmerged path net/sched/cls_api.c
