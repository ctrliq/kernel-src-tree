net/sched: cls_api: Initialize miss_cookie_node when action miss is not used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Ivan Vecera <ivecera@redhat.com>
commit 2cc8a008d62f3c04eeb7ec6fe59e542802bb8df3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/2cc8a008.failed

Function tcf_exts_init_ex() sets exts->miss_cookie_node ptr only
when use_action_miss is true so it assumes in other case that
the field is set to NULL by the caller. If not then the field
contains garbage and subsequent tcf_exts_destroy() call results
in a crash.
Ensure that the field .miss_cookie_node pointer is NULL when
use_action_miss parameter is false to avoid this potential scenario.

Fixes: 80cd22c35c90 ("net/sched: cls_api: Support hardware miss to tc action")
	Signed-off-by: Ivan Vecera <ivecera@redhat.com>
	Reviewed-by: Pedro Tammela <pctammela@mojatatu.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
Link: https://lore.kernel.org/r/20230420183634.1139391-1-ivecera@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2cc8a008d62f3c04eeb7ec6fe59e542802bb8df3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index cbeb5ab635f8,3c3629c9e7b6..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -3061,8 -3202,51 +3061,52 @@@ out
  	return skb->len;
  }
  
++<<<<<<< HEAD
++=======
+ int tcf_exts_init_ex(struct tcf_exts *exts, struct net *net, int action,
+ 		     int police, struct tcf_proto *tp, u32 handle,
+ 		     bool use_action_miss)
+ {
+ 	int err = 0;
+ 
+ #ifdef CONFIG_NET_CLS_ACT
+ 	exts->type = 0;
+ 	exts->nr_actions = 0;
+ 	exts->miss_cookie_node = NULL;
+ 	/* Note: we do not own yet a reference on net.
+ 	 * This reference might be taken later from tcf_exts_get_net().
+ 	 */
+ 	exts->net = net;
+ 	exts->actions = kcalloc(TCA_ACT_MAX_PRIO, sizeof(struct tc_action *),
+ 				GFP_KERNEL);
+ 	if (!exts->actions)
+ 		return -ENOMEM;
+ #endif
+ 
+ 	exts->action = action;
+ 	exts->police = police;
+ 
+ 	if (!use_action_miss)
+ 		return 0;
+ 
+ 	err = tcf_exts_miss_cookie_base_alloc(exts, tp, handle);
+ 	if (err)
+ 		goto err_miss_alloc;
+ 
+ 	return 0;
+ 
+ err_miss_alloc:
+ 	tcf_exts_destroy(exts);
+ #ifdef CONFIG_NET_CLS_ACT
+ 	exts->actions = NULL;
+ #endif
+ 	return err;
+ }
+ EXPORT_SYMBOL(tcf_exts_init_ex);
+ 
++>>>>>>> 2cc8a008d62f (net/sched: cls_api: Initialize miss_cookie_node when action miss is not used)
  void tcf_exts_destroy(struct tcf_exts *exts)
  {
 -	tcf_exts_miss_cookie_base_destroy(exts);
 -
  #ifdef CONFIG_NET_CLS_ACT
  	if (exts->actions) {
  		tcf_action_destroy(exts->actions, TCA_ACT_UNBIND);
* Unmerged path net/sched/cls_api.c
