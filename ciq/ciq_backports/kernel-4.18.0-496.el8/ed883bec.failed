net: ethernet: mtk_wed: add reset to rx_ring_setup callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit ed883bec679b027b198d57a336715f8298fb88b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/ed883bec.failed

This patch adds reset parameter to mtk_wed_rx_ring_setup signature
in order to align rx_ring_setup callback to tx_ring_setup one introduced
in 'commit 23dca7a90017 ("net: ethernet: mtk_wed: add reset to
tx_ring_setup callback")'

Co-developed-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
Link: https://lore.kernel.org/r/29c6e7a5469e784406cf3e2920351d1207713d05.1670239984.git.lorenzo@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit ed883bec679b027b198d57a336715f8298fb88b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
#	include/linux/soc/mediatek/mtk_wed.h
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index 420f6a7c88c7,06b6cc53fa02..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -534,6 -1209,64 +534,67 @@@ mtk_wed_wdma_ring_setup(struct mtk_wed_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mtk_wed_wdma_tx_ring_setup(struct mtk_wed_device *dev, int idx, int size,
+ 			   bool reset)
+ {
+ 	u32 desc_size = sizeof(struct mtk_wdma_desc) * dev->hw->version;
+ 	struct mtk_wed_ring *wdma;
+ 
+ 	if (idx >= ARRAY_SIZE(dev->tx_wdma))
+ 		return -EINVAL;
+ 
+ 	wdma = &dev->tx_wdma[idx];
+ 	if (!reset && mtk_wed_ring_alloc(dev, wdma, MTK_WED_WDMA_RING_SIZE,
+ 					 desc_size, true))
+ 		return -ENOMEM;
+ 
+ 	wdma_w32(dev, MTK_WDMA_RING_TX(idx) + MTK_WED_RING_OFS_BASE,
+ 		 wdma->desc_phys);
+ 	wdma_w32(dev, MTK_WDMA_RING_TX(idx) + MTK_WED_RING_OFS_COUNT,
+ 		 size);
+ 	wdma_w32(dev, MTK_WDMA_RING_TX(idx) + MTK_WED_RING_OFS_CPU_IDX, 0);
+ 	wdma_w32(dev, MTK_WDMA_RING_TX(idx) + MTK_WED_RING_OFS_DMA_IDX, 0);
+ 
+ 	if (reset)
+ 		mtk_wed_ring_reset(wdma, MTK_WED_WDMA_RING_SIZE, true);
+ 
+ 	if (!idx)  {
+ 		wed_w32(dev, MTK_WED_WDMA_RING_TX + MTK_WED_RING_OFS_BASE,
+ 			wdma->desc_phys);
+ 		wed_w32(dev, MTK_WED_WDMA_RING_TX + MTK_WED_RING_OFS_COUNT,
+ 			size);
+ 		wed_w32(dev, MTK_WED_WDMA_RING_TX + MTK_WED_RING_OFS_CPU_IDX,
+ 			0);
+ 		wed_w32(dev, MTK_WED_WDMA_RING_TX + MTK_WED_RING_OFS_DMA_IDX,
+ 			0);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ mtk_wed_ppe_check(struct mtk_wed_device *dev, struct sk_buff *skb,
+ 		  u32 reason, u32 hash)
+ {
+ 	struct mtk_eth *eth = dev->hw->eth;
+ 	struct ethhdr *eh;
+ 
+ 	if (!skb)
+ 		return;
+ 
+ 	if (reason != MTK_PPE_CPU_REASON_HIT_UNBIND_RATE_REACHED)
+ 		return;
+ 
+ 	skb_set_mac_header(skb, 0);
+ 	eh = eth_hdr(skb);
+ 	skb->protocol = eh->h_proto;
+ 	mtk_ppe_check_skb(eth->ppe[dev->hw->index], skb, hash);
+ }
+ 
++>>>>>>> ed883bec679b (net: ethernet: mtk_wed: add reset to rx_ring_setup callback)
  static void
  mtk_wed_configure_irq(struct mtk_wed_device *dev, u32 irq_mask)
  {
@@@ -731,6 -1572,39 +792,42 @@@ mtk_wed_txfree_ring_setup(struct mtk_we
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mtk_wed_rx_ring_setup(struct mtk_wed_device *dev, int idx, void __iomem *regs,
+ 		      bool reset)
+ {
+ 	struct mtk_wed_ring *ring = &dev->rx_ring[idx];
+ 
+ 	if (WARN_ON(idx >= ARRAY_SIZE(dev->rx_ring)))
+ 		return -EINVAL;
+ 
+ 	if (!reset && mtk_wed_ring_alloc(dev, ring, MTK_WED_RX_RING_SIZE,
+ 					 sizeof(*ring->desc), false))
+ 		return -ENOMEM;
+ 
+ 	if (mtk_wed_wdma_tx_ring_setup(dev, idx, MTK_WED_WDMA_RING_SIZE,
+ 				       reset))
+ 		return -ENOMEM;
+ 
+ 	ring->reg_base = MTK_WED_RING_RX_DATA(idx);
+ 	ring->wpdma = regs;
+ 	ring->flags |= MTK_WED_RING_CONFIGURED;
+ 
+ 	/* WPDMA ->  WED */
+ 	wpdma_rx_w32(dev, idx, MTK_WED_RING_OFS_BASE, ring->desc_phys);
+ 	wpdma_rx_w32(dev, idx, MTK_WED_RING_OFS_COUNT, MTK_WED_RX_RING_SIZE);
+ 
+ 	wed_w32(dev, MTK_WED_WPDMA_RING_RX_DATA(idx) + MTK_WED_RING_OFS_BASE,
+ 		ring->desc_phys);
+ 	wed_w32(dev, MTK_WED_WPDMA_RING_RX_DATA(idx) + MTK_WED_RING_OFS_COUNT,
+ 		MTK_WED_RX_RING_SIZE);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> ed883bec679b (net: ethernet: mtk_wed: add reset to rx_ring_setup callback)
  static u32
  mtk_wed_irq_get(struct mtk_wed_device *dev, u32 mask)
  {
diff --cc include/linux/soc/mediatek/mtk_wed.h
index 7e00cca06709,a0746d4aec20..000000000000
--- a/include/linux/soc/mediatek/mtk_wed.h
+++ b/include/linux/soc/mediatek/mtk_wed.h
@@@ -59,10 -158,16 +59,16 @@@ struct mtk_wed_device 
  struct mtk_wed_ops {
  	int (*attach)(struct mtk_wed_device *dev);
  	int (*tx_ring_setup)(struct mtk_wed_device *dev, int ring,
++<<<<<<< HEAD
 +			     void __iomem *regs);
++=======
+ 			     void __iomem *regs, bool reset);
+ 	int (*rx_ring_setup)(struct mtk_wed_device *dev, int ring,
+ 			     void __iomem *regs, bool reset);
++>>>>>>> ed883bec679b (net: ethernet: mtk_wed: add reset to rx_ring_setup callback)
  	int (*txfree_ring_setup)(struct mtk_wed_device *dev,
  				 void __iomem *regs);
 -	int (*msg_update)(struct mtk_wed_device *dev, int cmd_id,
 -			  void *data, int len);
  	void (*detach)(struct mtk_wed_device *dev);
 -	void (*ppe_check)(struct mtk_wed_device *dev, struct sk_buff *skb,
 -			  u32 reason, u32 hash);
  
  	void (*stop)(struct mtk_wed_device *dev);
  	void (*start)(struct mtk_wed_device *dev, u32 irq_mask);
@@@ -113,6 -228,14 +119,17 @@@ mtk_wed_device_attach(struct mtk_wed_de
  	(_dev)->ops->irq_get(_dev, _mask)
  #define mtk_wed_device_irq_set_mask(_dev, _mask) \
  	(_dev)->ops->irq_set_mask(_dev, _mask)
++<<<<<<< HEAD
++=======
+ #define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs, _reset) \
+ 	(_dev)->ops->rx_ring_setup(_dev, _ring, _regs, _reset)
+ #define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash) \
+ 	(_dev)->ops->ppe_check(_dev, _skb, _reason, _hash)
+ #define mtk_wed_device_update_msg(_dev, _id, _msg, _len) \
+ 	(_dev)->ops->msg_update(_dev, _id, _msg, _len)
+ #define mtk_wed_device_stop(_dev) (_dev)->ops->stop(_dev)
+ #define mtk_wed_device_dma_reset(_dev) (_dev)->ops->reset_dma(_dev)
++>>>>>>> ed883bec679b (net: ethernet: mtk_wed: add reset to rx_ring_setup callback)
  #else
  static inline bool mtk_wed_device_active(struct mtk_wed_device *dev)
  {
@@@ -126,6 -249,11 +143,14 @@@
  #define mtk_wed_device_reg_write(_dev, _reg, _val) do {} while (0)
  #define mtk_wed_device_irq_get(_dev, _mask) 0
  #define mtk_wed_device_irq_set_mask(_dev, _mask) do {} while (0)
++<<<<<<< HEAD
++=======
+ #define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs, _reset) -ENODEV
+ #define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash)  do {} while (0)
+ #define mtk_wed_device_update_msg(_dev, _id, _msg, _len) -ENODEV
+ #define mtk_wed_device_stop(_dev) do {} while (0)
+ #define mtk_wed_device_dma_reset(_dev) do {} while (0)
++>>>>>>> ed883bec679b (net: ethernet: mtk_wed: add reset to rx_ring_setup callback)
  #endif
  
  #endif
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
diff --git a/drivers/net/wireless/mediatek/mt76/dma.c b/drivers/net/wireless/mediatek/mt76/dma.c
index 8dca8d2447b7..195cf10088b5 100644
--- a/drivers/net/wireless/mediatek/mt76/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/dma.c
@@ -648,7 +648,7 @@ mt76_dma_wed_setup(struct mt76_dev *dev, struct mt76_queue *q)
 			q->wed_regs = wed->txfree_ring.reg_base;
 		break;
 	case MT76_WED_Q_RX:
-		ret = mtk_wed_device_rx_ring_setup(wed, ring, q->regs);
+		ret = mtk_wed_device_rx_ring_setup(wed, ring, q->regs, false);
 		if (!ret)
 			q->wed_regs = wed->rx_ring[ring].reg_base;
 		break;
* Unmerged path include/linux/soc/mediatek/mtk_wed.h
