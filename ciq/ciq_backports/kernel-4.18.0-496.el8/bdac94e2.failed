s390/dasd: add aq_requeue sysfs attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Stefan Haberland <sth@linux.ibm.com>
commit bdac94e29564bab9f24c2700f16ff11f31af7c11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/bdac94e2.failed

Add a sysfs attribute to control if all IO requests will be requeued to
the blocklayer in case of an autoquiesce event or not.

A value of 1 means that in case of an autoquiesce event all IO requests
will be requeued to the blocklayer.

A value of 0 means that the device will only be stopped.

	Signed-off-by: Stefan Haberland <sth@linux.ibm.com>
	Reviewed-by: Jan Hoeppner <hoeppner@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
Link: https://lore.kernel.org/r/20230405142017.2446986-5-sth@linux.ibm.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit bdac94e29564bab9f24c2700f16ff11f31af7c11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/dasd_devmap.c
diff --cc drivers/s390/block/dasd_devmap.c
index 6205dec03411,95c7959c7949..000000000000
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@@ -1476,6 -1477,82 +1476,85 @@@ dasd_eer_store(struct device *dev, stru
  static DEVICE_ATTR(eer_enabled, 0644, dasd_eer_show, dasd_eer_store);
  
  /*
++<<<<<<< HEAD
++=======
+  * aq_mask controls if the DASD should be quiesced on certain triggers
+  * The aq_mask attribute is interpreted as bitmap of the DASD_EER_* triggers.
+  */
+ static ssize_t dasd_aq_mask_show(struct device *dev, struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct dasd_devmap *devmap;
+ 	unsigned int aq_mask = 0;
+ 
+ 	devmap = dasd_find_busid(dev_name(dev));
+ 	if (!IS_ERR(devmap))
+ 		aq_mask = devmap->aq_mask;
+ 
+ 	return sysfs_emit(buf, "%d\n", aq_mask);
+ }
+ 
+ static ssize_t dasd_aq_mask_store(struct device *dev, struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct dasd_devmap *devmap;
+ 	unsigned int val;
+ 
+ 	if (kstrtouint(buf, 0, &val) || val > DASD_EER_VALID)
+ 		return -EINVAL;
+ 
+ 	devmap = dasd_devmap_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(devmap))
+ 		return PTR_ERR(devmap);
+ 
+ 	spin_lock(&dasd_devmap_lock);
+ 	devmap->aq_mask = val;
+ 	if (devmap->device)
+ 		devmap->device->aq_mask = devmap->aq_mask;
+ 	spin_unlock(&dasd_devmap_lock);
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(aq_mask, 0644, dasd_aq_mask_show, dasd_aq_mask_store);
+ 
+ /*
+  * aq_requeue controls if requests are returned to the blocklayer on quiesce
+  * or if requests are only not started
+  */
+ static ssize_t dasd_aqr_show(struct device *dev, struct device_attribute *attr,
+ 			     char *buf)
+ {
+ 	struct dasd_devmap *devmap;
+ 	int flag;
+ 
+ 	devmap = dasd_find_busid(dev_name(dev));
+ 	if (!IS_ERR(devmap))
+ 		flag = (devmap->features & DASD_FEATURE_REQUEUEQUIESCE) != 0;
+ 	else
+ 		flag = (DASD_FEATURE_DEFAULT &
+ 			DASD_FEATURE_REQUEUEQUIESCE) != 0;
+ 	return sysfs_emit(buf, "%d\n", flag);
+ }
+ 
+ static ssize_t dasd_aqr_store(struct device *dev, struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+ 	bool val;
+ 	int rc;
+ 
+ 	if (kstrtobool(buf, &val))
+ 		return -EINVAL;
+ 
+ 	rc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_REQUEUEQUIESCE, val);
+ 
+ 	return rc ? : count;
+ }
+ 
+ static DEVICE_ATTR(aq_requeue, 0644, dasd_aqr_show, dasd_aqr_store);
+ 
+ /*
++>>>>>>> bdac94e29564 (s390/dasd: add aq_requeue sysfs attribute)
   * expiration time for default requests
   */
  static ssize_t
@@@ -2327,6 -2401,8 +2406,11 @@@ static struct attribute * dasd_attrs[] 
  	&dev_attr_copy_pair.attr,
  	&dev_attr_copy_role.attr,
  	&dev_attr_ping.attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_aq_mask.attr,
+ 	&dev_attr_aq_requeue.attr,
++>>>>>>> bdac94e29564 (s390/dasd: add aq_requeue sysfs attribute)
  	NULL,
  };
  
* Unmerged path drivers/s390/block/dasd_devmap.c
