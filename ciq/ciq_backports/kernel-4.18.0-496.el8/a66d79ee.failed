net: ethernet: mtk_wed: add wcid overwritten support for wed v1

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Sujuan Chen <sujuan.chen@mediatek.com>
commit a66d79ee0bd5140a64b72cde588f8c83a55a1eb9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/a66d79ee.failed

All wed versions should enable the wcid overwritten feature,
since the wcid size is controlled by the wlan driver.

	Tested-by: Sujuan Chen <sujuan.chen@mediatek.com>
Co-developed-by: Bo Jiao <bo.jiao@mediatek.com>
	Signed-off-by: Bo Jiao <bo.jiao@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a66d79ee0bd5140a64b72cde588f8c83a55a1eb9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index 420f6a7c88c7,16d7af88bbac..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -249,12 -508,27 +249,33 @@@ mtk_wed_dma_disable(struct mtk_wed_devi
  		MTK_WED_GLO_CFG_TX_DMA_EN |
  		MTK_WED_GLO_CFG_RX_DMA_EN);
  
 -	wdma_clr(dev, MTK_WDMA_GLO_CFG,
 +	regmap_write(dev->hw->mirror, dev->hw->index * 4, 0);
 +	wdma_m32(dev, MTK_WDMA_GLO_CFG,
  		 MTK_WDMA_GLO_CFG_TX_DMA_EN |
  		 MTK_WDMA_GLO_CFG_RX_INFO1_PRERES |
++<<<<<<< HEAD
 +		 MTK_WDMA_GLO_CFG_RX_INFO2_PRERES |
 +		 MTK_WDMA_GLO_CFG_RX_INFO3_PRERES, 0);
++=======
+ 		 MTK_WDMA_GLO_CFG_RX_INFO2_PRERES);
+ 
+ 	if (dev->hw->version == 1) {
+ 		regmap_write(dev->hw->mirror, dev->hw->index * 4, 0);
+ 		wdma_clr(dev, MTK_WDMA_GLO_CFG,
+ 			 MTK_WDMA_GLO_CFG_RX_INFO3_PRERES);
+ 	} else {
+ 		wed_clr(dev, MTK_WED_WPDMA_GLO_CFG,
+ 			MTK_WED_WPDMA_GLO_CFG_RX_DRV_R0_PKT_PROC |
+ 			MTK_WED_WPDMA_GLO_CFG_RX_DRV_R0_CRX_SYNC);
+ 
+ 		wed_clr(dev, MTK_WED_WPDMA_RX_D_GLO_CFG,
+ 			MTK_WED_WPDMA_RX_D_RX_DRV_EN);
+ 		wed_clr(dev, MTK_WED_WDMA_GLO_CFG,
+ 			MTK_WED_WDMA_GLO_CFG_TX_DDONE_CHK);
+ 	}
+ 
+ 	mtk_wed_set_512_support(dev, false);
++>>>>>>> a66d79ee0bd5 (net: ethernet: mtk_wed: add wcid overwritten support for wed v1)
  }
  
  static void
@@@ -598,14 -1269,30 +619,40 @@@ mtk_wed_start(struct mtk_wed_device *de
  	mtk_wed_configure_irq(dev, irq_mask);
  
  	mtk_wed_set_ext_int(dev, true);
 -
 +	val = dev->wlan.wpdma_phys |
 +	      MTK_PCIE_MIRROR_MAP_EN |
 +	      FIELD_PREP(MTK_PCIE_MIRROR_MAP_WED_ID, dev->hw->index);
 +
++<<<<<<< HEAD
 +	if (dev->hw->index)
 +		val |= BIT(1);
 +	val |= BIT(0);
 +	regmap_write(dev->hw->mirror, dev->hw->index * 4, val);
++=======
+ 	if (dev->hw->version == 1) {
+ 		u32 val = dev->wlan.wpdma_phys | MTK_PCIE_MIRROR_MAP_EN |
+ 			  FIELD_PREP(MTK_PCIE_MIRROR_MAP_WED_ID,
+ 				     dev->hw->index);
+ 
+ 		val |= BIT(0) | (BIT(1) * !!dev->hw->index);
+ 		regmap_write(dev->hw->mirror, dev->hw->index * 4, val);
+ 	} else {
+ 		/* driver set mid ready and only once */
+ 		wed_w32(dev, MTK_WED_EXT_INT_MASK1,
+ 			MTK_WED_EXT_INT_STATUS_WPDMA_MID_RDY);
+ 		wed_w32(dev, MTK_WED_EXT_INT_MASK2,
+ 			MTK_WED_EXT_INT_STATUS_WPDMA_MID_RDY);
+ 
+ 		wed_r32(dev, MTK_WED_EXT_INT_MASK1);
+ 		wed_r32(dev, MTK_WED_EXT_INT_MASK2);
+ 
+ 		if (mtk_wed_rro_cfg(dev))
+ 			return;
+ 
+ 	}
++>>>>>>> a66d79ee0bd5 (net: ethernet: mtk_wed: add wcid overwritten support for wed v1)
+ 
+ 	mtk_wed_set_512_support(dev, dev->wlan.wcid_512);
  
  	mtk_wed_dma_enable(dev);
  	dev->running = true;
@@@ -657,9 -1350,26 +704,19 @@@ mtk_wed_attach(struct mtk_wed_device *d
  	}
  
  	mtk_wed_hw_init_early(dev);
++<<<<<<< HEAD
 +	regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP, BIT(hw->index), 0);
 +
++=======
+ 	if (hw->version == 1) {
+ 		regmap_update_bits(hw->hifsys, HIFSYS_DMA_AG_MAP,
+ 				   BIT(hw->index), 0);
+ 	} else {
+ 		dev->rev_id = wed_r32(dev, MTK_WED_REV_ID);
+ 		ret = mtk_wed_wo_init(hw);
+ 	}
++>>>>>>> a66d79ee0bd5 (net: ethernet: mtk_wed: add wcid overwritten support for wed v1)
  out:
 -	if (ret)
 -		mtk_wed_detach(dev);
 -unlock:
  	mutex_unlock(&hw_lock);
  
  	return ret;
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
diff --git a/drivers/net/ethernet/mediatek/mtk_wed_regs.h b/drivers/net/ethernet/mediatek/mtk_wed_regs.h
index eec22daebd30..c9048d9b5746 100644
--- a/drivers/net/ethernet/mediatek/mtk_wed_regs.h
+++ b/drivers/net/ethernet/mediatek/mtk_wed_regs.h
@@ -18,6 +18,8 @@ struct mtk_wdma_desc {
 	__le32 info;
 } __packed __aligned(4);
 
+#define MTK_WED_REV_ID					0x004
+
 #define MTK_WED_RESET					0x008
 #define MTK_WED_RESET_TX_BM				BIT(0)
 #define MTK_WED_RESET_TX_FREE_AGENT			BIT(4)
diff --git a/include/linux/soc/mediatek/mtk_wed.h b/include/linux/soc/mediatek/mtk_wed.h
index 7e00cca06709..e52450161f8f 100644
--- a/include/linux/soc/mediatek/mtk_wed.h
+++ b/include/linux/soc/mediatek/mtk_wed.h
@@ -29,6 +29,9 @@ struct mtk_wed_device {
 	int wdma_idx;
 	int irq;
 
+	/* used by wlan driver */
+	u32 rev_id;
+
 	struct mtk_wed_ring tx_ring[MTK_WED_TX_QUEUES];
 	struct mtk_wed_ring txfree_ring;
 	struct mtk_wed_ring tx_wdma[MTK_WED_TX_QUEUES];
