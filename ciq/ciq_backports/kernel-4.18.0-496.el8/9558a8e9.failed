s390/dasd: add aq_mask sysfs attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Stefan Haberland <sth@linux.ibm.com>
commit 9558a8e9d4a681e67b3abe9cabf3e3d8825af57e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/9558a8e9.failed

Add sysfs attribute that controls the DASD autoquiesce feature.
The autoquiesce is disabled when 0 is echoed to the attribute.

A value greater than 0 will enable the feature.
The aq_mask attribute will accept an unsigned integer and the value
will be interpreted as bitmask defining the trigger events that will
lead to an automatic quiesce.

The following autoquiesce triggers will currently be available:

DASD_EER_FATALERROR  1 - any final I/O error
DASD_EER_NOPATH      2 - no remaining paths for the device
DASD_EER_STATECHANGE 3 - a state change interrupt occurred
DASD_EER_PPRCSUSPEND 4 - the device is PPRC suspended
DASD_EER_NOSPC       5 - there is no space remaining on an ESE device
DASD_EER_TIMEOUT     6 - a certain amount of timeouts occurred
DASD_EER_STARTIO     7 - the IO start function encountered an error

The currently supported maximum value is 255.

Bit 31 is reserved for internal usage.
Bit 0 is not used.

Example:

 - deactivate autoquiesce
   $ echo 0 > /sys/bus/ccw/0.0.1234/aq_mask

 - enable autoquiesce for FATALERROR, NOPATH and TIMEOUT
   (0000 0000 0000 0000  0000 0000 0100 0110 => 70)
   $ echo 70 > /sys/bus/ccw/0.0.1234/aq_mask

	Signed-off-by: Stefan Haberland <sth@linux.ibm.com>
	Reviewed-by: Jan Hoeppner <hoeppner@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
Link: https://lore.kernel.org/r/20230405142017.2446986-4-sth@linux.ibm.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9558a8e9d4a681e67b3abe9cabf3e3d8825af57e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/dasd_int.h
diff --cc drivers/s390/block/dasd_int.h
index f3620c619357,c4633a4aeeb1..000000000000
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@@ -449,12 -444,22 +449,31 @@@ struct dasd_discipline 
  
  extern struct dasd_discipline *dasd_diag_discipline_pointer;
  
++<<<<<<< HEAD
 +/* Trigger IDs for extended error reporting */
 +#define DASD_EER_FATALERROR  1
 +#define DASD_EER_NOPATH      2
 +#define DASD_EER_STATECHANGE 3
 +#define DASD_EER_PPRCSUSPEND 4
 +#define DASD_EER_NOSPC	     5
++=======
+ /* Trigger IDs for extended error reporting DASD EER and autoquiesce */
+ enum eer_trigger {
+ 	DASD_EER_FATALERROR = 1,
+ 	DASD_EER_NOPATH,
+ 	DASD_EER_STATECHANGE,
+ 	DASD_EER_PPRCSUSPEND,
+ 	DASD_EER_NOSPC,
+ 	DASD_EER_TIMEOUTS,
+ 	DASD_EER_STARTIO,
+ 
+ 	/* enum end marker, only add new trigger above */
+ 	DASD_EER_MAX,
+ 	DASD_EER_AUTOQUIESCE = 31, /* internal only */
+ };
+ 
+ #define DASD_EER_VALID ((1U << DASD_EER_MAX) - 1)
++>>>>>>> 9558a8e9d4a6 (s390/dasd: add aq_mask sysfs attribute)
  
  /* DASD path handling */
  
diff --git a/drivers/s390/block/dasd_devmap.c b/drivers/s390/block/dasd_devmap.c
index 6205dec03411..151722750c59 100644
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@ -50,6 +50,7 @@ struct dasd_devmap {
         unsigned short features;
 	struct dasd_device *device;
 	struct dasd_copy_relation *copy;
+	unsigned int aq_mask;
 };
 
 /*
@@ -1475,6 +1476,47 @@ dasd_eer_store(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR(eer_enabled, 0644, dasd_eer_show, dasd_eer_store);
 
+/*
+ * aq_mask controls if the DASD should be quiesced on certain triggers
+ * The aq_mask attribute is interpreted as bitmap of the DASD_EER_* triggers.
+ */
+static ssize_t dasd_aq_mask_show(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	struct dasd_devmap *devmap;
+	unsigned int aq_mask = 0;
+
+	devmap = dasd_find_busid(dev_name(dev));
+	if (!IS_ERR(devmap))
+		aq_mask = devmap->aq_mask;
+
+	return sysfs_emit(buf, "%d\n", aq_mask);
+}
+
+static ssize_t dasd_aq_mask_store(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct dasd_devmap *devmap;
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val) || val > DASD_EER_VALID)
+		return -EINVAL;
+
+	devmap = dasd_devmap_from_cdev(to_ccwdev(dev));
+	if (IS_ERR(devmap))
+		return PTR_ERR(devmap);
+
+	spin_lock(&dasd_devmap_lock);
+	devmap->aq_mask = val;
+	if (devmap->device)
+		devmap->device->aq_mask = devmap->aq_mask;
+	spin_unlock(&dasd_devmap_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(aq_mask, 0644, dasd_aq_mask_show, dasd_aq_mask_store);
+
 /*
  * expiration time for default requests
  */
@@ -2327,6 +2369,7 @@ static struct attribute * dasd_attrs[] = {
 	&dev_attr_copy_pair.attr,
 	&dev_attr_copy_role.attr,
 	&dev_attr_ping.attr,
+	&dev_attr_aq_mask.attr,
 	NULL,
 };
 
* Unmerged path drivers/s390/block/dasd_int.h
