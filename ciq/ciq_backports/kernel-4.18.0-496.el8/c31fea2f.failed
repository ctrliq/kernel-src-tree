md: add error_handlers for raid0 and linear

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Mariusz Tkaczyk <mariusz.tkaczyk@linux.intel.com>
commit c31fea2f8e2a72c817f318016bbc327095175a9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/c31fea2f.failed

After the commit 9631abdbf406c("md: Set MD_BROKEN for RAID1 and RAID10")
MD_BROKEN must be set if array is failed because state_store() checks it.
If it is set then -EBUSY is returned to userspace.

For raid0 and linear MD_BROKEN is not set by error_handler(). As a result
mdadm is unable to trigger clean-up actions. It is a regression.

This patch adds appropriate error_handler for raid0 and linear. The
error handler sets MD_BROKEN for this device.

	Reviewed-by: Xiao Ni <xni@redhat.com>
	Signed-off-by: Mariusz Tkaczyk <mariusz.tkaczyk@linux.intel.com>
	Signed-off-by: Song Liu <song@kernel.org>
Link: https://lore.kernel.org/r/20230306130317.3418-1-mariusz.tkaczyk@linux.intel.com
(cherry picked from commit c31fea2f8e2a72c817f318016bbc327095175a9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md-linear.c
#	drivers/md/md.h
#	drivers/md/raid0.c
diff --cc drivers/md/md-linear.c
index c51e9769d6d9,4eb72b9dd933..000000000000
--- a/drivers/md/md-linear.c
+++ b/drivers/md/md-linear.c
@@@ -329,7 -297,7 +340,11 @@@ static struct md_personality linear_per
  	.hot_add_disk	= linear_add,
  	.size		= linear_size,
  	.quiesce	= linear_quiesce,
++<<<<<<< HEAD
 +	.congested	= linear_congested,
++=======
+ 	.error_handler	= linear_error,
++>>>>>>> c31fea2f8e2a (md: add error_handlers for raid0 and linear)
  };
  
  static int __init linear_init (void)
diff --cc drivers/md/md.h
index 0c75af113f4a,fd8f260ed5f8..000000000000
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@@ -799,17 -790,9 +799,21 @@@ extern void mddev_destroy_serial_pool(s
  struct md_rdev *md_find_rdev_nr_rcu(struct mddev *mddev, int nr);
  struct md_rdev *md_find_rdev_rcu(struct mddev *mddev, dev_t dev);
  
- static inline bool is_mddev_broken(struct md_rdev *rdev, const char *md_type)
+ static inline bool is_rdev_broken(struct md_rdev *rdev)
  {
++<<<<<<< HEAD
 +	int flags = rdev->bdev->bd_disk->flags;
 +
 +	if (!(flags & GENHD_FL_UP)) {
 +		if (!test_and_set_bit(MD_BROKEN, &rdev->mddev->flags))
 +			pr_warn("md: %s: %s array has a missing/failed member\n",
 +				mdname(rdev->mddev), md_type);
 +		return true;
 +	}
 +	return false;
++=======
+ 	return !disk_live(rdev->bdev->bd_disk);
++>>>>>>> c31fea2f8e2a (md: add error_handlers for raid0 and linear)
  }
  
  static inline void rdev_dec_pending(struct md_rdev *rdev, struct mddev *mddev)
diff --cc drivers/md/raid0.c
index 4444042c65f2,f8ee9a95e25d..000000000000
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@@ -802,7 -778,7 +813,11 @@@ static struct md_personality raid0_pers
  	.size		= raid0_size,
  	.takeover	= raid0_takeover,
  	.quiesce	= raid0_quiesce,
++<<<<<<< HEAD
 +	.congested	= raid0_congested,
++=======
+ 	.error_handler	= raid0_error,
++>>>>>>> c31fea2f8e2a (md: add error_handlers for raid0 and linear)
  };
  
  static int __init raid0_init (void)
* Unmerged path drivers/md/md-linear.c
diff --git a/drivers/md/md.c b/drivers/md/md.c
index 1557c90e6a40..ab6df0003e36 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -8091,6 +8091,9 @@ void md_error(struct mddev *mddev, struct md_rdev *rdev)
 		return;
 	mddev->pers->error_handler(mddev, rdev);
 
+	if (mddev->pers->level == 0 || mddev->pers->level == LEVEL_LINEAR)
+		return;
+
 	if (mddev->degraded && !test_bit(MD_BROKEN, &mddev->flags))
 		set_bit(MD_RECOVERY_RECOVER, &mddev->recovery);
 	sysfs_notify_dirent_safe(rdev->sysfs_state);
* Unmerged path drivers/md/md.h
* Unmerged path drivers/md/raid0.c
