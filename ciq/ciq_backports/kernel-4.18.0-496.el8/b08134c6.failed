net: ethernet: mtk_wed: add mtk_wed_rx_reset routine

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit b08134c6e10938c8de3e47763674a2aa6f380d92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/b08134c6.failed

Introduce mtk_wed_rx_reset routine in order to reset rx DMA for Wireless
Ethernet Dispatcher available on MT7986 SoC.

Co-developed-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit b08134c6e10938c8de3e47763674a2aa6f380d92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mediatek/mtk_wed.c
#	drivers/net/ethernet/mediatek/mtk_wed_regs.h
diff --cc drivers/net/ethernet/mediatek/mtk_wed.c
index 420f6a7c88c7,9594885d5e50..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@@ -436,17 -1078,17 +524,18 @@@ mtk_wed_reset_dma(struct mtk_wed_devic
  	int i;
  
  	for (i = 0; i < ARRAY_SIZE(dev->tx_ring); i++) {
 -		if (!dev->tx_ring[i].desc)
 +		struct mtk_wdma_desc *desc = dev->tx_ring[i].desc;
 +
 +		if (!desc)
  			continue;
  
 -		mtk_wed_ring_reset(&dev->tx_ring[i], MTK_WED_TX_RING_SIZE,
 -				   true);
 +		mtk_wed_ring_reset(desc, MTK_WED_TX_RING_SIZE);
  	}
  
- 	if (mtk_wed_poll_busy(dev))
- 		busy = mtk_wed_check_busy(dev);
- 
+ 	/* 1. reset WED tx DMA */
+ 	wed_clr(dev, MTK_WED_GLO_CFG, MTK_WED_GLO_CFG_TX_DMA_EN);
+ 	busy = mtk_wed_poll_busy(dev, MTK_WED_GLO_CFG,
+ 				 MTK_WED_GLO_CFG_TX_DMA_BUSY);
  	if (busy) {
  		mtk_wed_reset(dev, MTK_WED_RESET_WED_TX_DMA);
  	} else {
@@@ -456,8 -1096,12 +543,17 @@@
  		wed_w32(dev, MTK_WED_RESET_IDX, 0);
  	}
  
++<<<<<<< HEAD
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, MTK_WDMA_RESET_IDX_RX);
 +	wdma_w32(dev, MTK_WDMA_RESET_IDX, 0);
++=======
+ 	/* 2. reset WDMA rx DMA */
+ 	busy = !!mtk_wdma_rx_reset(dev);
+ 	wed_clr(dev, MTK_WED_WDMA_GLO_CFG, MTK_WED_WDMA_GLO_CFG_RX_DRV_EN);
+ 	if (!busy)
+ 		busy = mtk_wed_poll_busy(dev, MTK_WED_WDMA_GLO_CFG,
+ 					 MTK_WED_WDMA_GLO_CFG_RX_DRV_BUSY);
++>>>>>>> b08134c6e109 (net: ethernet: mtk_wed: add mtk_wed_rx_reset routine)
  
  	if (busy) {
  		mtk_wed_reset(dev, MTK_WED_RESET_WDMA_INT_AGENT);
@@@ -494,6 -1152,16 +604,19 @@@
  		wed_w32(dev, MTK_WED_WPDMA_RESET_IDX, 0);
  	}
  
++<<<<<<< HEAD
++=======
+ 	dev->init_done = false;
+ 	if (dev->hw->version == 1)
+ 		return;
+ 
+ 	if (!busy) {
+ 		wed_w32(dev, MTK_WED_RESET_IDX, MTK_WED_RESET_WPDMA_IDX_RX);
+ 		wed_w32(dev, MTK_WED_RESET_IDX, 0);
+ 	}
+ 
+ 	mtk_wed_rx_reset(dev);
++>>>>>>> b08134c6e109 (net: ethernet: mtk_wed: add mtk_wed_rx_reset routine)
  }
  
  static int
@@@ -587,12 -1382,14 +710,21 @@@ mtk_wed_dma_enable(struct mtk_wed_devic
  static void
  mtk_wed_start(struct mtk_wed_device *dev, u32 irq_mask)
  {
 +	u32 val;
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < ARRAY_SIZE(dev->tx_wdma); i++)
 +		if (!dev->tx_wdma[i].desc)
 +			mtk_wed_wdma_ring_setup(dev, i, 16);
++=======
+ 	if (mtk_wed_get_rx_capa(dev) && mtk_wed_rx_buffer_alloc(dev))
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->rx_wdma); i++)
+ 		if (!dev->rx_wdma[i].desc)
+ 			mtk_wed_wdma_rx_ring_setup(dev, i, 16);
++>>>>>>> b08134c6e109 (net: ethernet: mtk_wed: add mtk_wed_rx_reset routine)
  
  	mtk_wed_hw_init(dev);
  	mtk_wed_configure_irq(dev, irq_mask);
@@@ -650,10 -1470,14 +782,18 @@@ mtk_wed_attach(struct mtk_wed_device *d
  	    of_dma_is_coherent(hw->eth->dev->of_node))
  		mtk_eth_set_dma_device(hw->eth, hw->dev);
  
 -	ret = mtk_wed_tx_buffer_alloc(dev);
 -	if (ret)
 +	ret = mtk_wed_buffer_alloc(dev);
 +	if (ret) {
 +		mtk_wed_detach(dev);
  		goto out;
++<<<<<<< HEAD
++=======
+ 
+ 	if (mtk_wed_get_rx_capa(dev)) {
+ 		ret = mtk_wed_rro_alloc(dev);
+ 		if (ret)
+ 			goto out;
++>>>>>>> b08134c6e109 (net: ethernet: mtk_wed: add mtk_wed_rx_reset routine)
  	}
  
  	mtk_wed_hw_init_early(dev);
diff --cc drivers/net/ethernet/mediatek/mtk_wed_regs.h
index eec22daebd30,0a50bb98c5ea..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_wed_regs.h
+++ b/drivers/net/ethernet/mediatek/mtk_wed_regs.h
@@@ -18,15 -20,23 +18,19 @@@ struct mtk_wdma_desc 
  	__le32 info;
  } __packed __aligned(4);
  
 -#define MTK_WED_REV_ID					0x004
 -
  #define MTK_WED_RESET					0x008
  #define MTK_WED_RESET_TX_BM				BIT(0)
+ #define MTK_WED_RESET_RX_BM				BIT(1)
  #define MTK_WED_RESET_TX_FREE_AGENT			BIT(4)
  #define MTK_WED_RESET_WPDMA_TX_DRV			BIT(8)
  #define MTK_WED_RESET_WPDMA_RX_DRV			BIT(9)
+ #define MTK_WED_RESET_WPDMA_RX_D_DRV			BIT(10)
  #define MTK_WED_RESET_WPDMA_INT_AGENT			BIT(11)
  #define MTK_WED_RESET_WED_TX_DMA			BIT(12)
+ #define MTK_WED_RESET_WED_RX_DMA			BIT(13)
+ #define MTK_WED_RESET_WDMA_TX_DRV			BIT(16)
  #define MTK_WED_RESET_WDMA_RX_DRV			BIT(17)
  #define MTK_WED_RESET_WDMA_INT_AGENT			BIT(19)
 -#define MTK_WED_RESET_RX_RRO_QM				BIT(20)
 -#define MTK_WED_RESET_RX_ROUTE_QM			BIT(21)
  #define MTK_WED_RESET_WED				BIT(31)
  
  #define MTK_WED_CTRL					0x00c
@@@ -123,8 -162,11 +127,10 @@@
  #define MTK_WED_RESET_IDX				0x20c
  #define MTK_WED_RESET_IDX_TX				GENMASK(3, 0)
  #define MTK_WED_RESET_IDX_RX				GENMASK(17, 16)
+ #define MTK_WED_RESET_IDX_RX_V2				GENMASK(7, 6)
+ #define MTK_WED_RESET_WPDMA_IDX_RX			GENMASK(31, 30)
  
  #define MTK_WED_TX_MIB(_n)				(0x2a0 + (_n) * 4)
 -#define MTK_WED_RX_MIB(_n)				(0x2e0 + (_n) * 4)
  
  #define MTK_WED_RING_TX(_n)				(0x300 + (_n) * 0x10)
  
@@@ -176,6 -269,31 +182,34 @@@
  
  #define MTK_WED_WPDMA_RING_TX(_n)			(0x600 + (_n) * 0x10)
  #define MTK_WED_WPDMA_RING_RX(_n)			(0x700 + (_n) * 0x10)
++<<<<<<< HEAD
++=======
+ #define MTK_WED_WPDMA_RING_RX_DATA(_n)			(0x730 + (_n) * 0x10)
+ 
+ #define MTK_WED_WPDMA_RX_D_GLO_CFG			0x75c
+ #define MTK_WED_WPDMA_RX_D_RX_DRV_EN			BIT(0)
+ #define MTK_WED_WPDMA_RX_D_RX_DRV_BUSY			BIT(1)
+ #define MTK_WED_WPDMA_RX_D_FSM_RETURN_IDLE		BIT(3)
+ #define MTK_WED_WPDMA_RX_D_RST_INIT_COMPLETE		BIT(4)
+ #define MTK_WED_WPDMA_RX_D_INIT_PHASE_RXEN_SEL		GENMASK(11, 7)
+ #define MTK_WED_WPDMA_RX_D_RXD_READ_LEN			GENMASK(31, 24)
+ 
+ #define MTK_WED_WPDMA_RX_D_RST_IDX			0x760
+ #define MTK_WED_WPDMA_RX_D_RST_CRX_IDX			GENMASK(17, 16)
+ #define MTK_WED_WPDMA_RX_D_RST_DRV_IDX			GENMASK(25, 24)
+ 
+ #define MTK_WED_WPDMA_RX_GLO_CFG			0x76c
+ #define MTK_WED_WPDMA_RX_RING				0x770
+ 
+ #define MTK_WED_WPDMA_RX_D_MIB(_n)			(0x774 + (_n) * 4)
+ #define MTK_WED_WPDMA_RX_D_PROCESSED_MIB(_n)		(0x784 + (_n) * 4)
+ #define MTK_WED_WPDMA_RX_D_COHERENT_MIB			0x78c
+ 
+ #define MTK_WED_WDMA_RING_TX				0x800
+ 
+ #define MTK_WED_WDMA_TX_MIB				0x810
+ 
++>>>>>>> b08134c6e109 (net: ethernet: mtk_wed: add mtk_wed_rx_reset routine)
  #define MTK_WED_WDMA_RING_RX(_n)			(0x900 + (_n) * 0x10)
  #define MTK_WED_WDMA_RX_THRES(_n)			(0x940 + (_n) * 0x4)
  
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed.c
* Unmerged path drivers/net/ethernet/mediatek/mtk_wed_regs.h
