net/sched: keep the max_frm_len information inside struct sched_gate_list

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-496.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit a878fd46fe43ec97f3f8664173fe1d23984c3453
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-496.el8/a878fd46.failed

I have one practical reason for doing this and one concerning correctness.

The practical reason has to do with a follow-up patch, which aims to mix
2 sources of max_sdu (one coming from the user and the other automatically
calculated based on TC gate durations @current link speed). Among those
2 sources of input, we must always select the smaller max_sdu value, but
this can change at various link speeds. So the max_sdu coming from the
user must be kept separated from the value that is operationally used
(the minimum of the 2), because otherwise we overwrite it and forget
what the user asked us to do.

To solve that, this patch proposes that struct sched_gate_list contains
the operationally active max_frm_len, and q->max_sdu contains just what
was requested by the user.

The reason having to do with correctness is based on the following
observation: the admin sched_gate_list becomes operational at a given
base_time in the future. Until then, it is inactive and applies no
shaping, all gates are open, etc. So the queueMaxSDU dropping shouldn't
apply either (this is a mechanism to ensure that packets smaller than
the largest gate duration for that TC don't hang the port; clearly it
makes little sense if the gates are always open).

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Kurt Kanzenbach <kurt@linutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a878fd46fe43ec97f3f8664173fe1d23984c3453)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_taprio.c
diff --cc net/sched/sch_taprio.c
index dbfb1f4e9bfd,d3e3be543fae..000000000000
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@@ -84,7 -93,7 +85,11 @@@ struct taprio_sched 
  	struct sched_gate_list __rcu *admin_sched;
  	struct hrtimer advance_timer;
  	struct list_head taprio_list;
++<<<<<<< HEAD
 +	u32 max_frm_len[TC_MAX_QUEUE]; /* for the fast path */
++=======
+ 	int cur_txq[TC_MAX_QUEUE];
++>>>>>>> a878fd46fe43 (net/sched: keep the max_frm_len information inside struct sched_gate_list)
  	u32 max_sdu[TC_MAX_QUEUE]; /* for dump and offloading */
  	u32 txtime_delay;
  };
@@@ -228,9 -243,24 +233,24 @@@ static ktime_t get_interval_end_time(st
  
  static int length_to_duration(struct taprio_sched *q, int len)
  {
 -	return div_u64(len * atomic64_read(&q->picos_per_byte), PSEC_PER_NSEC);
 +	return div_u64(len * atomic64_read(&q->picos_per_byte), 1000);
  }
  
+ static void taprio_update_queue_max_sdu(struct taprio_sched *q,
+ 					struct sched_gate_list *sched)
+ {
+ 	struct net_device *dev = qdisc_dev(q->root);
+ 	int num_tc = netdev_get_num_tc(dev);
+ 	int tc;
+ 
+ 	for (tc = 0; tc < num_tc; tc++) {
+ 		if (q->max_sdu[tc])
+ 			sched->max_frm_len[tc] = q->max_sdu[tc] + dev->hard_header_len;
+ 		else
+ 			sched->max_frm_len[tc] = U32_MAX; /* never oversized */
+ 	}
+ }
+ 
  /* Returns the entry corresponding to next available interval. If
   * validate_interval is set, it only validates whether the timestamp occurs
   * when the gate corresponding to the skb's traffic class is open.
* Unmerged path net/sched/sch_taprio.c
