x86/efistub: Avoid legacy decompressor when doing EFI boot

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit a1b87d54f4e45ff5e0d081fb1d9db3bf1a8fb39a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/a1b87d54.failed

The bare metal decompressor code was never really intended to run in a
hosted environment such as the EFI boot services, and does a few things
that are becoming problematic in the context of EFI boot now that the
logo requirements are getting tighter: EFI executables will no longer be
allowed to consist of a single executable section that is mapped with
read, write and execute permissions if they are intended for use in a
context where Secure Boot is enabled (and where Microsoft's set of
certificates is used, i.e., every x86 PC built to run Windows).

To avoid stepping on reserved memory before having inspected the E820
tables, and to ensure the correct placement when running a kernel build
that is non-relocatable, the bare metal decompressor moves its own
executable image to the end of the allocation that was reserved for it,
in order to perform the decompression in place. This means the region in
question requires both write and execute permissions, which either need
to be given upfront (which EFI will no longer permit), or need to be
applied on demand using the existing page fault handling framework.

However, the physical placement of the kernel is usually randomized
anyway, and even if it isn't, a dedicated decompression output buffer
can be allocated anywhere in memory using EFI APIs when still running in
the boot services, given that EFI support already implies a relocatable
kernel. This means that decompression in place is never necessary, nor
is moving the compressed image from one end to the other.

Since EFI already maps all of memory 1:1, it is also unnecessary to
create new page tables or handle page faults when decompressing the
kernel. That means there is also no need to replace the special
exception handlers for SEV. Generally, there is little need to do
any of the things that the decompressor does beyond

- initialize SEV encryption, if needed,
- perform the 4/5 level paging switch, if needed,
- decompress the kernel
- relocate the kernel

So do all of this from the EFI stub code, and avoid the bare metal
decompressor altogether.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Link: https://lore.kernel.org/r/20230807162720.545787-24-ardb@kernel.org
(cherry picked from commit a1b87d54f4e45ff5e0d081fb1d9db3bf1a8fb39a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/Makefile
#	arch/x86/boot/compressed/eboot.c
#	arch/x86/boot/compressed/efi_mixed.S
#	arch/x86/boot/compressed/head_32.S
#	arch/x86/include/asm/efi.h
diff --cc arch/x86/boot/compressed/Makefile
index 3c10eb222545,71fc531b95b4..000000000000
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@@ -51,21 -62,26 +51,34 @@@ KBUILD_AFLAGS  := $(KBUILD_CFLAGS) -D__
  GCOV_PROFILE := n
  UBSAN_SANITIZE :=n
  
 -KBUILD_LDFLAGS := -m elf_$(UTS_MACHINE)
 -KBUILD_LDFLAGS += $(call ld-option,--no-ld-generated-unwind-info)
 +LDFLAGS := -m elf_$(UTS_MACHINE)
  # Compressed kernel should be built as PIE since it may be loaded at any
  # address by the bootloader.
 -LDFLAGS_vmlinux := -pie $(call ld-option, --no-dynamic-linker)
 -ifdef CONFIG_LD_ORPHAN_WARN
 -LDFLAGS_vmlinux += --orphan-handling=$(CONFIG_LD_ORPHAN_WARN_LEVEL)
 +ifeq ($(CONFIG_X86_32),y)
 +LDFLAGS += $(call ld-option, -pie) $(call ld-option, --no-dynamic-linker)
 +else
 +# To build 64-bit compressed kernel as PIE, we disable relocation
 +# overflow check to avoid relocation overflow error with a new linker
 +# command-line option, -z noreloc-overflow.
 +LDFLAGS += $(shell $(LD) --help 2>&1 | grep -q "\-z noreloc-overflow" \
 +	&& echo "-z noreloc-overflow -pie --no-dynamic-linker")
  endif
++<<<<<<< HEAD
 +LDFLAGS_vmlinux := -T
++=======
+ LDFLAGS_vmlinux += -z noexecstack
+ ifeq ($(CONFIG_LD_IS_BFD),y)
+ LDFLAGS_vmlinux += $(call ld-option,--no-warn-rwx-segments)
+ endif
+ ifeq ($(CONFIG_EFI_STUB),y)
+ # ensure that the static EFI stub library will be pulled in, even if it is
+ # never referenced explicitly from the startup code
+ LDFLAGS_vmlinux += -u efi_pe_entry
+ endif
+ LDFLAGS_vmlinux += -T
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot)
  
 -hostprogs	:= mkpiggy
 +hostprogs-y	:= mkpiggy
  HOST_EXTRACFLAGS += -I$(srctree)/tools/include
  
  sed-voffset := -e 's/^\([0-9a-fA-F]*\) [ABCDGRSTVW] \(_text\|__bss_start\|_end\)$$/\#define VO_\2 _AC(0x\1,UL)/p'
diff --cc arch/x86/boot/compressed/eboot.c
index c2a7652f4460,e976288728e9..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -16,39 -15,27 +16,51 @@@
  #include <asm/setup.h>
  #include <asm/desc.h>
  #include <asm/boot.h>
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
++=======
+ #include <asm/kaslr.h>
+ #include <asm/sev.h>
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
 +
 +#include "../string.h"
 +#include "eboot.h"
  
 -#include "efistub.h"
 -#include "x86-stub.h"
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +static efi_system_table_t *sys_table;
 +static const efi_dxe_services_table_t *efi_dxe_table;
  
 +static struct efi_config *efi_early;
++=======
+ const efi_system_table_t *efi_system_table;
+ const efi_dxe_services_table_t *efi_dxe_table;
+ static efi_loaded_image_t *image = NULL;
+ static efi_memory_attribute_protocol_t *memattr;
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  
 -typedef union sev_memory_acceptance_protocol sev_memory_acceptance_protocol_t;
 -union sev_memory_acceptance_protocol {
 -	struct {
 -		efi_status_t (__efiapi * allow_unaccepted_memory)(
 -			sev_memory_acceptance_protocol_t *);
 -	};
 -	struct {
 -		u32 allow_unaccepted_memory;
 -	} mixed_mode;
 -};
 +__pure const struct efi_config *__efi_early(void)
 +{
 +	return efi_early;
 +}
 +
 +#define BOOT_SERVICES(bits)						\
 +static void setup_boot_services##bits(struct efi_config *c)		\
 +{									\
 +	efi_system_table_##bits##_t *table;				\
 +									\
 +	table = (typeof(table))sys_table;				\
 +									\
 +	c->runtime_services	= table->runtime;			\
 +	c->boot_services	= table->boottime;			\
 +	c->text_output		= table->con_out;			\
 +}
 +BOOT_SERVICES(32);
 +BOOT_SERVICES(64);
 +
 +void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 +{
 +	efi_call_proto(efi_simple_text_output_protocol, output_string,
 +		       efi_early->text_output, str);
 +}
  
  static efi_status_t
  preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
@@@ -292,57 -284,35 +304,79 @@@ adjust_memory_range_protection(unsigne
  	}
  }
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +/*
 + * Trampoline takes 2 pages and can be loaded in first megabyte of memory
 + * with its end placed between 128k and 640k where BIOS might start.
 + * (see arch/x86/boot/compressed/pgtable_64.c)
 + *
 + * We cannot find exact trampoline placement since memory map
 + * can be modified by UEFI, and it can alter the computed address.
 + */
 +
 +#define TRAMPOLINE_PLACEMENT_BASE ((128 - 8)*1024)
 +#define TRAMPOLINE_PLACEMENT_SIZE (640*1024 - (128 - 8)*1024)
 +
 +void startup_32(struct boot_params *boot_params);
 +
 +static void
 +setup_memory_protection(unsigned long image_base, unsigned long image_size)
 +{
 +	/*
 +	 * Allow execution of possible trampoline used
 +	 * for switching between 4- and 5-level page tables
 +	 * and relocated kernel image.
 +	 */
 +
 +	adjust_memory_range_protection(TRAMPOLINE_PLACEMENT_BASE,
 +				       TRAMPOLINE_PLACEMENT_SIZE);
 +
 +#ifdef CONFIG_64BIT
 +	if (image_base != (unsigned long)startup_32)
 +		adjust_memory_range_protection(image_base, image_size);
 +#else
 +	/*
 +	 * Clear protection flags on a whole range of possible
 +	 * addresses used for KASLR. We don't need to do that
 +	 * on x86_64, since KASLR/extraction is performed after
 +	 * dedicated identity page tables are built and we only
 +	 * need to remove possible protection on relocated image
 +	 * itself disregarding further relocations.
 +	 */
 +	adjust_memory_range_protection(LOAD_PHYSICAL_ADDR,
 +				       KERNEL_IMAGE_SIZE - LOAD_PHYSICAL_ADDR);
 +#endif
++=======
+ static void setup_unaccepted_memory(void)
+ {
+ 	efi_guid_t mem_acceptance_proto = OVMF_SEV_MEMORY_ACCEPTANCE_PROTOCOL_GUID;
+ 	sev_memory_acceptance_protocol_t *proto;
+ 	efi_status_t status;
+ 
+ 	if (!IS_ENABLED(CONFIG_UNACCEPTED_MEMORY))
+ 		return;
+ 
+ 	/*
+ 	 * Enable unaccepted memory before calling exit boot services in order
+ 	 * for the UEFI to not accept all memory on EBS.
+ 	 */
+ 	status = efi_bs_call(locate_protocol, &mem_acceptance_proto, NULL,
+ 			     (void **)&proto);
+ 	if (status != EFI_SUCCESS)
+ 		return;
+ 
+ 	status = efi_call_proto(proto, allow_unaccepted_memory);
+ 	if (status != EFI_SUCCESS)
+ 		efi_err("Memory acceptance protocol failed\n");
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  }
  
  static const efi_char16_t apple[] = L"Apple";
  
- static void setup_quirks(struct boot_params *boot_params,
- 			 unsigned long image_base,
- 			 unsigned long image_size)
+ static void setup_quirks(struct boot_params *boot_params)
  {
  	efi_char16_t *fw_vendor = (efi_char16_t *)(unsigned long)
 -		efi_table_attr(efi_system_table, fw_vendor);
 +		efi_table_attr(efi_system_table, fw_vendor, sys_table);
  
  	if (!memcmp(fw_vendor, apple, sizeof(apple))) {
  		if (IS_ENABLED(CONFIG_APPLE_PROPERTIES))
@@@ -484,46 -456,35 +515,53 @@@ struct boot_params *make_boot_params(st
  	int options_size = 0;
  	efi_status_t status;
  	char *cmdline_ptr;
 +	u16 *s2;
 +	u8 *s1;
 +	int i;
 +	unsigned long ramdisk_addr;
 +	unsigned long ramdisk_size;
  
 -	efi_system_table = sys_table_arg;
 +	efi_early = c;
 +	sys_table = (efi_system_table_t *)(unsigned long)efi_early->table;
 +	handle = (void *)(unsigned long)efi_early->image_handle;
  
  	/* Check if we were booted by the EFI firmware */
 -	if (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 -		efi_exit(handle, EFI_INVALID_PARAMETER);
 +	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 +		return NULL;
  
 -	status = efi_bs_call(handle_protocol, handle, &proto, (void **)&image);
 +	if (efi_early->is64)
 +		setup_boot_services64(efi_early);
 +	else
 +		setup_boot_services32(efi_early);
 +
 +	status = efi_call_early(handle_protocol, handle,
 +				&proto, (void *)&image);
  	if (status != EFI_SUCCESS) {
 -		efi_err("Failed to get handle for LOADED_IMAGE_PROTOCOL\n");
 -		efi_exit(handle, status);
 +		efi_printk(sys_table, "Failed to get handle for LOADED_IMAGE_PROTOCOL\n");
 +		return NULL;
  	}
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	status = efi_low_alloc(sys_table, 0x4000, 1,
 +			       (unsigned long *)&boot_params);
++=======
+ 	image_base = efi_table_attr(image, image_base);
+ 
+ 	status = efi_allocate_pages(sizeof(struct boot_params),
+ 				    (unsigned long *)&boot_params, ULONG_MAX);
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  	if (status != EFI_SUCCESS) {
 -		efi_err("Failed to allocate lowmem for boot params\n");
 -		efi_exit(handle, status);
 +		efi_printk(sys_table, "Failed to allocate lowmem for boot params\n");
 +		return NULL;
  	}
  
 -	memset(boot_params, 0x0, sizeof(struct boot_params));
 +	memset(boot_params, 0x0, 0x4000);
  
  	hdr = &boot_params->hdr;
 +	bi = &boot_params->apm_bios_info;
  
 -	/* Copy the setup header from the second sector to boot_params */
 -	memcpy(&hdr->jump, image_base + 512,
 -	       sizeof(struct setup_header) - offsetof(struct setup_header, jump));
 +	/* Copy the second sector to boot_params */
 +	memcpy(&hdr->jump, image->image_base + 512, 512);
  
  	/*
  	 * Fill out some of the header fields ourselves because the
@@@ -840,74 -760,167 +878,183 @@@ static efi_status_t exit_boot(struct bo
  	return EFI_SUCCESS;
  }
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
++=======
+ static bool have_unsupported_snp_features(void)
+ {
+ 	u64 unsupported;
+ 
+ 	unsupported = snp_get_unsupported_features(sev_get_status());
+ 	if (unsupported) {
+ 		efi_err("Unsupported SEV-SNP features detected: 0x%llx\n",
+ 			unsupported);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ static void efi_get_seed(void *seed, int size)
+ {
+ 	efi_get_random_bytes(size, seed);
+ 
+ 	/*
+ 	 * This only updates seed[0] when running on 32-bit, but in that case,
+ 	 * seed[1] is not used anyway, as there is no virtual KASLR on 32-bit.
+ 	 */
+ 	*(unsigned long *)seed ^= kaslr_get_random_long("EFI");
+ }
+ 
+ static void error(char *str)
+ {
+ 	efi_warn("Decompression failed: %s\n", str);
+ }
+ 
+ static efi_status_t efi_decompress_kernel(unsigned long *kernel_entry)
+ {
+ 	unsigned long virt_addr = LOAD_PHYSICAL_ADDR;
+ 	unsigned long addr, alloc_size, entry;
+ 	efi_status_t status;
+ 	u32 seed[2] = {};
+ 
+ 	/* determine the required size of the allocation */
+ 	alloc_size = ALIGN(max_t(unsigned long, output_len, kernel_total_size),
+ 			   MIN_KERNEL_ALIGN);
+ 
+ 	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && !efi_nokaslr) {
+ 		u64 range = KERNEL_IMAGE_SIZE - LOAD_PHYSICAL_ADDR - kernel_total_size;
+ 
+ 		efi_get_seed(seed, sizeof(seed));
+ 
+ 		virt_addr += (range * seed[1]) >> 32;
+ 		virt_addr &= ~(CONFIG_PHYSICAL_ALIGN - 1);
+ 	}
+ 
+ 	status = efi_random_alloc(alloc_size, CONFIG_PHYSICAL_ALIGN, &addr,
+ 				  seed[0], EFI_LOADER_CODE,
+ 				  EFI_X86_KERNEL_ALLOC_LIMIT);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	entry = decompress_kernel((void *)addr, virt_addr, error);
+ 	if (entry == ULONG_MAX) {
+ 		efi_free(alloc_size, addr);
+ 		return EFI_LOAD_ERROR;
+ 	}
+ 
+ 	*kernel_entry = addr + entry;
+ 
+ 	efi_adjust_memory_range_protection(addr, kernel_total_size);
+ 
+ 	return EFI_SUCCESS;
+ }
+ 
+ static void __noreturn enter_kernel(unsigned long kernel_addr,
+ 				    struct boot_params *boot_params)
+ {
+ 	/* enter decompressed kernel with boot_params pointer in RSI/ESI */
+ 	asm("jmp *%0"::"r"(kernel_addr), "S"(boot_params));
+ 
+ 	unreachable();
+ }
+ 
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  /*
 - * On success, this routine will jump to the relocated image directly and never
 - * return.  On failure, it will exit to the firmware via efi_exit() instead of
 - * returning.
 + * On success we return a pointer to a boot_params structure, and NULL
 + * on failure.
   */
 -void __noreturn efi_stub_entry(efi_handle_t handle,
 -			       efi_system_table_t *sys_table_arg,
 -			       struct boot_params *boot_params)
 +struct boot_params *
 +efi_main(struct efi_config *c, struct boot_params *boot_params)
  {
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	unsigned long bzimage_addr = (unsigned long)startup_32;
 +	struct desc_ptr *gdt = NULL;
 +	efi_loaded_image_t *image;
 +	struct setup_header *hdr = &boot_params->hdr;
++=======
+ 	efi_guid_t guid = EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID;
+ 	struct setup_header *hdr = &boot_params->hdr;
+ 	const struct linux_efi_initrd *initrd = NULL;
+ 	unsigned long kernel_entry;
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  	efi_status_t status;
 +	struct desc_struct *desc;
 +	void *handle;
 +	efi_system_table_t *_table;
 +	bool is64;
 +	unsigned long cmdline_paddr;
  
 -	efi_system_table = sys_table_arg;
 -	/* Check if we were booted by the EFI firmware */
 -	if (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 -		efi_exit(handle, EFI_INVALID_PARAMETER);
 -
 -	if (have_unsupported_snp_features())
 -		efi_exit(handle, EFI_UNSUPPORTED);
 -
 -	if (IS_ENABLED(CONFIG_EFI_DXE_MEM_ATTRIBUTES)) {
 -		efi_dxe_table = get_efi_config_table(EFI_DXE_SERVICES_TABLE_GUID);
 -		if (efi_dxe_table &&
 -		    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
 -			efi_warn("Ignoring DXE services table: invalid signature\n");
 -			efi_dxe_table = NULL;
 -		}
 -	}
 +	efi_early = c;
  
 -	/* grab the memory attributes protocol if it exists */
 -	efi_bs_call(locate_protocol, &guid, NULL, (void **)&memattr);
 +	_table = (efi_system_table_t *)(unsigned long)efi_early->table;
 +	handle = (void *)(unsigned long)efi_early->image_handle;
 +	is64 = efi_early->is64;
  
 -	status = efi_setup_5level_paging();
 -	if (status != EFI_SUCCESS) {
 -		efi_err("efi_setup_5level_paging() failed!\n");
 +	sys_table = _table;
 +
 +	/* Check if we were booted by the EFI firmware */
 +	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
  		goto fail;
 +
 +	if (is64)
 +		setup_boot_services64(efi_early);
 +	else
 +		setup_boot_services32(efi_early);
 +
 +	efi_dxe_table = get_efi_config_table(sys_table, EFI_DXE_SERVICES_TABLE_GUID);
 +	if (efi_dxe_table &&
 +	    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
 +		efi_printk(sys_table, "Ignoring DXE services table: invalid signature\n");
 +		efi_dxe_table = NULL;
  	}
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	/*
 +	 * If the kernel isn't already loaded at the preferred load
 +	 * address, relocate it.
 +	 */
 +	if (bzimage_addr != hdr->pref_address) {
 +		status = efi_relocate_kernel(sys_table, &bzimage_addr,
 +					     hdr->init_size, hdr->init_size,
 +					     hdr->pref_address,
 +					     hdr->kernel_alignment,
 +					     LOAD_PHYSICAL_ADDR);
 +		if (status != EFI_SUCCESS) {
 +			efi_printk(sys_table, "efi_relocate_kernel() failed!\n");
++=======
+ #ifdef CONFIG_CMDLINE_BOOL
+ 	status = efi_parse_options(CONFIG_CMDLINE);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_err("Failed to parse options\n");
+ 		goto fail;
+ 	}
+ #endif
+ 	if (!IS_ENABLED(CONFIG_CMDLINE_OVERRIDE)) {
+ 		unsigned long cmdline_paddr = ((u64)hdr->cmd_line_ptr |
+ 					       ((u64)boot_params->ext_cmd_line_ptr << 32));
+ 		status = efi_parse_options((char *)cmdline_paddr);
+ 		if (status != EFI_SUCCESS) {
+ 			efi_err("Failed to parse options\n");
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  			goto fail;
  		}
 +		hdr->pref_address = hdr->code32_start;
  	}
 +	hdr->code32_start = (u32)bzimage_addr;
  
+ 	status = efi_decompress_kernel(&kernel_entry);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_err("Failed to decompress kernel\n");
+ 		goto fail;
+ 	}
+ 
  	/*
 -	 * At this point, an initrd may already have been loaded by the
 -	 * bootloader and passed via bootparams. We permit an initrd loaded
 -	 * from the LINUX_EFI_INITRD_MEDIA_GUID device path to supersede it.
 -	 *
 -	 * If the device path is not present, any command-line initrd=
 -	 * arguments will be processed only if image is not NULL, which will be
 -	 * the case only if we were loaded via the PE entry point.
 +	 * make_boot_params() may have been called before efi_main(), in which
 +	 * case this is the second time we parse the cmdline. This is ok,
 +	 * parsing the cmdline multiple times does not have side-effects.
  	 */
 -	status = efi_load_initrd(image, hdr->initrd_addr_max, ULONG_MAX,
 -				 &initrd);
 -	if (status != EFI_SUCCESS)
 -		goto fail;
 -	if (initrd && initrd->size > 0) {
 -		efi_set_u64_split(initrd->base, &hdr->ramdisk_image,
 -				  &boot_params->ext_ramdisk_image);
 -		efi_set_u64_split(initrd->size, &hdr->ramdisk_size,
 -				  &boot_params->ext_ramdisk_size);
 -	}
 -
 +	cmdline_paddr = ((u64)hdr->cmd_line_ptr |
 +			 ((u64)boot_params->ext_cmd_line_ptr << 32));
 +	efi_parse_options((char *)cmdline_paddr);
  
  	/*
  	 * If the boot loader gave us a value for secure_boot then we use that,
@@@ -927,119 -940,48 +1074,135 @@@
  
  	setup_efi_pci(boot_params);
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	setup_quirks(boot_params, bzimage_addr, hdr->init_size);
++=======
+ 	setup_quirks(boot_params);
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  
 -	setup_unaccepted_memory();
 +	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
 +				sizeof(*gdt), (void **)&gdt);
 +	if (status != EFI_SUCCESS) {
 +		efi_printk(sys_table, "Failed to allocate memory for 'gdt' structure\n");
 +		goto fail;
 +	}
  
 -	status = exit_boot(boot_params, handle);
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	gdt->size = 0x800;
 +	status = efi_low_alloc(sys_table, gdt->size, 8,
 +			   (unsigned long *)&gdt->address);
  	if (status != EFI_SUCCESS) {
 -		efi_err("exit_boot() failed!\n");
 +		efi_printk(sys_table, "Failed to allocate memory for 'gdt'\n");
  		goto fail;
  	}
  
 +	status = exit_boot(boot_params, handle, is64);
 +	if (status != EFI_SUCCESS) {
 +		efi_printk(sys_table, "exit_boot() failed!\n");
 +		goto fail;
 +	}
 +
 +	memset((char *)gdt->address, 0x0, gdt->size);
 +	desc = (struct desc_struct *)gdt->address;
 +
 +	/* The first GDT is a dummy. */
 +	desc++;
 +
 +	if (IS_ENABLED(CONFIG_X86_64)) {
 +		/* __KERNEL32_CS */
 +		desc->limit0	= 0xffff;
 +		desc->base0	= 0x0000;
 +		desc->base1	= 0x0000;
 +		desc->type	= SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;
 +		desc->s		= DESC_TYPE_CODE_DATA;
 +		desc->dpl	= 0;
 +		desc->p		= 1;
 +		desc->limit1	= 0xf;
 +		desc->avl	= 0;
 +		desc->l		= 0;
 +		desc->d		= SEG_OP_SIZE_32BIT;
 +		desc->g		= SEG_GRANULARITY_4KB;
 +		desc->base2	= 0x00;
 +
 +		desc++;
 +	} else {
 +		/* Second entry is unused on 32-bit */
 +		desc++;
 +	}
 +
 +	/* __KERNEL_CS */
 +	desc->limit0	= 0xffff;
 +	desc->base0	= 0x0000;
 +	desc->base1	= 0x0000;
 +	desc->type	= SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;
 +	desc->s		= DESC_TYPE_CODE_DATA;
 +	desc->dpl	= 0;
 +	desc->p		= 1;
 +	desc->limit1	= 0xf;
 +	desc->avl	= 0;
 +
 +	if (IS_ENABLED(CONFIG_X86_64)) {
 +		desc->l = 1;
 +		desc->d = 0;
 +	} else {
 +		desc->l = 0;
 +		desc->d = SEG_OP_SIZE_32BIT;
 +	}
 +	desc->g		= SEG_GRANULARITY_4KB;
 +	desc->base2	= 0x00;
 +	desc++;
 +
 +	/* __KERNEL_DS */
 +	desc->limit0	= 0xffff;
 +	desc->base0	= 0x0000;
 +	desc->base1	= 0x0000;
 +	desc->type	= SEG_TYPE_DATA | SEG_TYPE_READ_WRITE;
 +	desc->s		= DESC_TYPE_CODE_DATA;
 +	desc->dpl	= 0;
 +	desc->p		= 1;
 +	desc->limit1	= 0xf;
 +	desc->avl	= 0;
 +	desc->l		= 0;
 +	desc->d		= SEG_OP_SIZE_32BIT;
 +	desc->g		= SEG_GRANULARITY_4KB;
 +	desc->base2	= 0x00;
 +	desc++;
 +
 +	if (IS_ENABLED(CONFIG_X86_64)) {
 +		/* Task segment value */
 +		desc->limit0	= 0x0000;
 +		desc->base0	= 0x0000;
 +		desc->base1	= 0x0000;
 +		desc->type	= SEG_TYPE_TSS;
 +		desc->s		= 0;
 +		desc->dpl	= 0;
 +		desc->p		= 1;
 +		desc->limit1	= 0x0;
 +		desc->avl	= 0;
 +		desc->l		= 0;
 +		desc->d		= 0;
 +		desc->g		= SEG_GRANULARITY_4KB;
 +		desc->base2	= 0x00;
 +		desc++;
 +	}
 +
 +	asm volatile("cli");
 +	asm volatile ("lgdt %0" : : "m" (*gdt));
 +
 +	return boot_params;
++=======
+ 	/*
+ 	 * Call the SEV init code while still running with the firmware's
+ 	 * GDT/IDT, so #VC exceptions will be handled by EFI.
+ 	 */
+ 	sev_enable(boot_params);
+ 
+ 	efi_5level_switch();
+ 
+ 	enter_kernel(kernel_entry, boot_params);
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot):drivers/firmware/efi/libstub/x86-stub.c
  fail:
 -	efi_err("efi_stub_entry() failed!\n");
 +	efi_printk(sys_table, "efi_main() failed!\n");
  
 -	efi_exit(handle, status);
 +	return NULL;
  }
 -
 -#ifdef CONFIG_EFI_HANDOVER_PROTOCOL
 -void efi_handover_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,
 -			struct boot_params *boot_params)
 -{
 -	extern char _bss[], _ebss[];
 -
 -	memset(_bss, 0, _ebss - _bss);
 -	efi_stub_entry(handle, sys_table_arg, boot_params);
 -}
 -
 -#ifndef CONFIG_EFI_MIXED
 -extern __alias(efi_handover_entry)
 -void efi32_stub_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,
 -		      struct boot_params *boot_params);
 -
 -extern __alias(efi_handover_entry)
 -void efi64_stub_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,
 -		      struct boot_params *boot_params);
 -#endif
 -#endif
diff --cc arch/x86/boot/compressed/head_32.S
index 0411ad3c848c,1cfe9802a42f..000000000000
--- a/arch/x86/boot/compressed/head_32.S
+++ b/arch/x86/boot/compressed/head_32.S
@@@ -97,7 -83,7 +97,11 @@@ ENTRY(startup_32
   */
  
  #ifdef CONFIG_RELOCATABLE
++<<<<<<< HEAD
 +	movl	%ebp, %ebx
++=======
+ 	leal	startup_32@GOTOFF(%edx), %ebx
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot)
  	movl	BP_kernel_alignment(%esi), %eax
  	decl	%eax
  	addl    %eax, %ebx
diff --cc arch/x86/include/asm/efi.h
index fe461b858f74,b0994ae3bc23..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -44,8 -90,7 +44,12 @@@ static inline void efi_fpu_end(void
  }
  
  #ifdef CONFIG_X86_32
++<<<<<<< HEAD
 +
 +extern asmlinkage unsigned long efi_call_phys(void *, ...);
++=======
+ #define EFI_X86_KERNEL_ALLOC_LIMIT		(SZ_512M - 1)
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot)
  
  #define arch_efi_call_virt_setup()					\
  ({									\
@@@ -59,23 -104,17 +63,22 @@@
  	efi_fpu_end();							\
  })
  
 +#define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
 +
  #else /* !CONFIG_X86_32 */
- 
- #define EFI_LOADER_SIGNATURE	"EL64"
+ #define EFI_X86_KERNEL_ALLOC_LIMIT		EFI_ALLOC_LIMIT
  
 -extern asmlinkage u64 __efi_call(void *fp, ...);
 +extern asmlinkage u64 efi_call(void *fp, ...);
  
 -extern bool efi_disable_ibt_for_runtime;
 -
 -#define efi_call(...) ({						\
 -	__efi_nargs_check(efi_call, 7, __VA_ARGS__);			\
 -	__efi_call(__VA_ARGS__);					\
 -})
 +/*
 + * struct efi_scratch - Scratch space used while switching to/from efi_mm
 + * @phys_stack: stack used during EFI Mixed Mode
 + * @prev_mm:    store/restore stolen mm_struct while switching to/from efi_mm
 + */
 +struct efi_scratch {
 +	u64			phys_stack;
 +	struct mm_struct	*prev_mm;
 +} __packed;
  
  #define arch_efi_call_virt_setup()					\
  ({									\
@@@ -174,17 -217,11 +177,23 @@@ efi_status_t efi_set_virtual_address_ma
  
  /* arch specific definitions used by the stub code */
  
 -#ifdef CONFIG_EFI_MIXED
 -
 +struct efi_config {
 +	u64 image_handle;
 +	u64 table;
 +	u64 runtime_services;
 +	u64 boot_services;
 +	u64 text_output;
 +	efi_status_t (*call)(unsigned long, ...);
 +	bool is64;
 +} __packed;
 +
++<<<<<<< HEAD
 +__pure const struct efi_config *__efi_early(void);
++=======
+ #define EFI_ALLOC_LIMIT		(efi_is_64bit() ? ULONG_MAX : U32_MAX)
+ 
+ #define ARCH_HAS_EFISTUB_WRAPPERS
++>>>>>>> a1b87d54f4e4 (x86/efistub: Avoid legacy decompressor when doing EFI boot)
  
  static inline bool efi_is_64bit(void)
  {
* Unmerged path arch/x86/boot/compressed/efi_mixed.S
* Unmerged path arch/x86/boot/compressed/Makefile
* Unmerged path arch/x86/boot/compressed/eboot.c
* Unmerged path arch/x86/boot/compressed/efi_mixed.S
* Unmerged path arch/x86/boot/compressed/head_32.S
* Unmerged path arch/x86/include/asm/efi.h
diff --git a/arch/x86/include/asm/sev.h b/arch/x86/include/asm/sev.h
index 13dc2a9d23c1..917509cf12ca 100644
--- a/arch/x86/include/asm/sev.h
+++ b/arch/x86/include/asm/sev.h
@@ -157,6 +157,7 @@ static __always_inline void sev_es_nmi_complete(void)
 		__sev_es_nmi_complete();
 }
 extern int __init sev_es_efi_map_ghcbs(pgd_t *pgd);
+extern void sev_enable(struct boot_params *bp);
 
 static inline int rmpadjust(unsigned long vaddr, bool rmp_psize, unsigned long attrs)
 {
@@ -208,6 +209,7 @@ static inline void sev_es_ist_exit(void) { }
 static inline int sev_es_setup_ap_jump_table(struct real_mode_header *rmh) { return 0; }
 static inline void sev_es_nmi_complete(void) { }
 static inline int sev_es_efi_map_ghcbs(pgd_t *pgd) { return 0; }
+static inline void sev_enable(struct boot_params *bp) { }
 static inline int pvalidate(unsigned long vaddr, bool rmp_psize, bool validate) { return 0; }
 static inline int rmpadjust(unsigned long vaddr, bool rmp_psize, unsigned long attrs) { return 0; }
 static inline void setup_ghcb(void) { }
