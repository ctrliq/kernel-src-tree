efi/libstub: Add memory attribute protocol definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Evgeniy Baskov <baskov@ispras.ru>
commit 79729f26b074a5d2722c27fa76cc45ef721e65cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/79729f26.failed

EFI_MEMORY_ATTRIBUTE_PROTOCOL servers as a better alternative to
DXE services for setting memory attributes in EFI Boot Services
environment. This protocol is better since it is a part of UEFI
specification itself and not UEFI PI specification like DXE
services.

Add EFI_MEMORY_ATTRIBUTE_PROTOCOL definitions.
Support mixed mode properly for its calls.

	Tested-by: Mario Limonciello <mario.limonciello@amd.com>
	Signed-off-by: Evgeniy Baskov <baskov@ispras.ru>
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 79729f26b074a5d2722c27fa76cc45ef721e65cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/efi.h
#	drivers/firmware/efi/libstub/efistub.h
#	include/linux/efi.h
diff --cc arch/x86/include/asm/efi.h
index fe461b858f74,cd19b9eca3f6..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -204,43 -228,169 +204,169 @@@ static inline bool efi_is_native(void
  	return efi_is_64bit();
  }
  
 -#define efi_table_attr(inst, attr)					\
 -	(efi_is_native() ? (inst)->attr					\
 -			 : efi_mixed_table_attr((inst), attr))
 -
 -#define efi_mixed_table_attr(inst, attr)				\
 -	(__typeof__(inst->attr))					\
 -		_Generic(inst->mixed_mode.attr,				\
 -		u32:		(unsigned long)(inst->mixed_mode.attr),	\
 -		default:	(inst->mixed_mode.attr))
 -
 -/*
 - * The following macros allow translating arguments if necessary from native to
 - * mixed mode. The use case for this is to initialize the upper 32 bits of
 - * output parameters, and where the 32-bit method requires a 64-bit argument,
 - * which must be split up into two arguments to be thunked properly.
 - *
 - * As examples, the AllocatePool boot service returns the address of the
 - * allocation, but it will not set the high 32 bits of the address. To ensure
 - * that the full 64-bit address is initialized, we zero-init the address before
 - * calling the thunk.
 - *
 - * The FreePages boot service takes a 64-bit physical address even in 32-bit
 - * mode. For the thunk to work correctly, a native 64-bit call of
 - * 	free_pages(addr, size)
 - * must be translated to
 - * 	efi64_thunk(free_pages, addr & U32_MAX, addr >> 32, size)
 - * so that the two 32-bit halves of addr get pushed onto the stack separately.
 - */
 -
 -static inline void *efi64_zero_upper(void *p)
 -{
 -	((u32 *)p)[1] = 0;
 -	return p;
 -}
 -
 -static inline u32 efi64_convert_status(efi_status_t status)
 -{
 -	return (u32)(status | (u64)status >> 32);
 -}
 +#define efi_mixed_mode_cast(attr)					\
 +	__builtin_choose_expr(						\
 +		__builtin_types_compatible_p(u32, __typeof__(attr)),	\
 +			(unsigned long)(attr), (attr))
 +
 +#define efi_table_attr(table, attr, instance) ({			\
 +	__typeof__(((table##_t *)0)->attr) __ret;			\
 +	if (efi_is_native()) {						\
 +		__ret = ((table##_t *)(unsigned long)instance)->attr;	\
 +	} else {							\
 +		__ret = (__typeof__(__ret))efi_mixed_mode_cast(		\
 +		((table##_t *)(unsigned long)instance)->mixed_mode.attr);\
 +	}								\
 +	__ret;								\
 +})
  
 +#define efi_call_proto(protocol, f, instance, ...)			\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(protocol, f, instance),	\
 +		instance, ##__VA_ARGS__)
 +
 +#define efi_dxe_call(f, ...)						\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(efi_dxe_services_table,	\
 +					       f,			\
 +					       efi_dxe_table),		\
 +				##__VA_ARGS__)
 +
 +#define efi_call_early(f, ...)						\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(efi_boot_services, f,	\
 +		__efi_early()->boot_services), __VA_ARGS__)
 +
++<<<<<<< HEAD
 +#define efi_call_runtime(f, ...)					\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(efi_runtime_services, f,	\
 +		__efi_early()->runtime_services), __VA_ARGS__)
++=======
+ #define __efi64_split(val)		(val) & U32_MAX, (u64)(val) >> 32
+ 
+ #define __efi64_argmap_free_pages(addr, size)				\
+ 	((addr), 0, (size))
+ 
+ #define __efi64_argmap_get_memory_map(mm_size, mm, key, size, ver)	\
+ 	((mm_size), (mm), efi64_zero_upper(key), efi64_zero_upper(size), (ver))
+ 
+ #define __efi64_argmap_allocate_pool(type, size, buffer)		\
+ 	((type), (size), efi64_zero_upper(buffer))
+ 
+ #define __efi64_argmap_create_event(type, tpl, f, c, event)		\
+ 	((type), (tpl), (f), (c), efi64_zero_upper(event))
+ 
+ #define __efi64_argmap_set_timer(event, type, time)			\
+ 	((event), (type), lower_32_bits(time), upper_32_bits(time))
+ 
+ #define __efi64_argmap_wait_for_event(num, event, index)		\
+ 	((num), (event), efi64_zero_upper(index))
+ 
+ #define __efi64_argmap_handle_protocol(handle, protocol, interface)	\
+ 	((handle), (protocol), efi64_zero_upper(interface))
+ 
+ #define __efi64_argmap_locate_protocol(protocol, reg, interface)	\
+ 	((protocol), (reg), efi64_zero_upper(interface))
+ 
+ #define __efi64_argmap_locate_device_path(protocol, path, handle)	\
+ 	((protocol), (path), efi64_zero_upper(handle))
+ 
+ #define __efi64_argmap_exit(handle, status, size, data)			\
+ 	((handle), efi64_convert_status(status), (size), (data))
+ 
+ /* PCI I/O */
+ #define __efi64_argmap_get_location(protocol, seg, bus, dev, func)	\
+ 	((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),	\
+ 	 efi64_zero_upper(dev), efi64_zero_upper(func))
+ 
+ /* LoadFile */
+ #define __efi64_argmap_load_file(protocol, path, policy, bufsize, buf)	\
+ 	((protocol), (path), (policy), efi64_zero_upper(bufsize), (buf))
+ 
+ /* Graphics Output Protocol */
+ #define __efi64_argmap_query_mode(gop, mode, size, info)		\
+ 	((gop), (mode), efi64_zero_upper(size), efi64_zero_upper(info))
+ 
+ /* TCG2 protocol */
+ #define __efi64_argmap_hash_log_extend_event(prot, fl, addr, size, ev)	\
+ 	((prot), (fl), 0ULL, (u64)(addr), 0ULL, (u64)(size), 0ULL, ev)
+ 
+ /* DXE services */
+ #define __efi64_argmap_get_memory_space_descriptor(phys, desc) \
+ 	(__efi64_split(phys), (desc))
+ 
+ #define __efi64_argmap_set_memory_space_attributes(phys, size, flags) \
+ 	(__efi64_split(phys), __efi64_split(size), __efi64_split(flags))
+ 
+ /* file protocol */
+ #define __efi64_argmap_open(prot, newh, fname, mode, attr) \
+ 	((prot), efi64_zero_upper(newh), (fname), __efi64_split(mode), \
+ 	 __efi64_split(attr))
+ 
+ #define __efi64_argmap_set_position(pos) (__efi64_split(pos))
+ 
+ /* file system protocol */
+ #define __efi64_argmap_open_volume(prot, file) \
+ 	((prot), efi64_zero_upper(file))
+ 
+ /* Memory Attribute Protocol */
+ #define __efi64_argmap_set_memory_attributes(protocol, phys, size, flags) \
+ 	((protocol), __efi64_split(phys), __efi64_split(size), __efi64_split(flags))
+ 
+ #define __efi64_argmap_clear_memory_attributes(protocol, phys, size, flags) \
+ 	((protocol), __efi64_split(phys), __efi64_split(size), __efi64_split(flags))
+ 
+ /*
+  * The macros below handle the plumbing for the argument mapping. To add a
+  * mapping for a specific EFI method, simply define a macro
+  * __efi64_argmap_<method name>, following the examples above.
+  */
+ 
+ #define __efi64_thunk_map(inst, func, ...)				\
+ 	efi64_thunk(inst->mixed_mode.func,				\
+ 		__efi64_argmap(__efi64_argmap_ ## func(__VA_ARGS__),	\
+ 			       (__VA_ARGS__)))
+ 
+ #define __efi64_argmap(mapped, args)					\
+ 	__PASTE(__efi64_argmap__, __efi_nargs(__efi_eat mapped))(mapped, args)
+ #define __efi64_argmap__0(mapped, args) __efi_eval mapped
+ #define __efi64_argmap__1(mapped, args) __efi_eval args
+ 
+ #define __efi_eat(...)
+ #define __efi_eval(...) __VA_ARGS__
+ 
+ static inline efi_status_t __efi64_widen_efi_status(u64 status)
+ {
+ 	/* use rotate to move the value of bit #31 into position #63 */
+ 	return ror64(rol32(status, 1), 1);
+ }
+ 
+ /* The macro below handles dispatching via the thunk if needed */
+ 
+ #define efi_fn_call(inst, func, ...)					\
+ 	(efi_is_native() ? (inst)->func(__VA_ARGS__)			\
+ 			 : efi_mixed_call((inst), func, ##__VA_ARGS__))
+ 
+ #define efi_mixed_call(inst, func, ...)					\
+ 	_Generic(inst->func(__VA_ARGS__),				\
+ 	efi_status_t:							\
+ 		__efi64_widen_efi_status(				\
+ 			__efi64_thunk_map(inst, func, ##__VA_ARGS__)),	\
+ 	u64: ({ BUILD_BUG(); ULONG_MAX; }),				\
+ 	default:							\
+ 		(__typeof__(inst->func(__VA_ARGS__)))			\
+ 			__efi64_thunk_map(inst, func, ##__VA_ARGS__))
+ 
+ #else /* CONFIG_EFI_MIXED */
+ 
+ static inline bool efi_is_64bit(void)
+ {
+ 	return IS_ENABLED(CONFIG_X86_64);
+ }
+ 
+ #endif /* CONFIG_EFI_MIXED */
++>>>>>>> 79729f26b074 (efi/libstub: Add memory attribute protocol definitions)
  
  extern bool efi_reboot_required(void);
  extern bool efi_is_table_address(unsigned long phys_addr);
diff --cc drivers/firmware/efi/libstub/efistub.h
index 386522b5d9b5,5388c7a9eb16..000000000000
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@@ -25,32 -29,924 +25,928 @@@
  #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
  #endif
  
 -#ifndef EFI_ALLOC_LIMIT
 -#define EFI_ALLOC_LIMIT		ULONG_MAX
 -#endif
 +extern int __pure nokaslr(void);
 +extern int __pure is_quiet(void);
  
 -extern bool efi_nochunk;
 -extern bool efi_nokaslr;
 -extern int efi_loglevel;
 -extern bool efi_novamap;
 +extern void set_nokaslr(int val);
  
 -extern const efi_system_table_t *efi_system_table;
 +#define pr_efi(sys_table, msg)		do {				\
 +	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\
 +} while (0)
  
 -typedef union efi_dxe_services_table efi_dxe_services_table_t;
 -extern const efi_dxe_services_table_t *efi_dxe_table;
 +#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
  
 -efi_status_t __efiapi efi_pe_entry(efi_handle_t handle,
 -				   efi_system_table_t *sys_table_arg);
 +void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
  
 -#ifndef ARCH_HAS_EFISTUB_WRAPPERS
 +unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
  
 -#define efi_is_native()			(true)
 -#define efi_table_attr(inst, attr)	(inst)->attr
 -#define efi_fn_call(inst, func, ...)	(inst)->func(__VA_ARGS__)
 +efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 +					    void *handle,
 +					    unsigned long *new_fdt_addr,
 +					    unsigned long max_addr,
 +					    u64 initrd_addr, u64 initrd_size,
 +					    char *cmdline_ptr,
 +					    unsigned long fdt_addr,
 +					    unsigned long fdt_size);
  
 -#endif
 +void *get_fdt(efi_system_table_t *sys_table, unsigned long *fdt_size);
  
++<<<<<<< HEAD
++=======
+ #define efi_call_proto(inst, func, ...) ({			\
+ 	__typeof__(inst) __inst = (inst);			\
+ 	efi_fn_call(__inst, func, __inst, ##__VA_ARGS__);	\
+ })
+ #define efi_bs_call(func, ...) \
+ 	efi_fn_call(efi_table_attr(efi_system_table, boottime), func, ##__VA_ARGS__)
+ #define efi_rt_call(func, ...) \
+ 	efi_fn_call(efi_table_attr(efi_system_table, runtime), func, ##__VA_ARGS__)
+ #define efi_dxe_call(func, ...) \
+ 	efi_fn_call(efi_dxe_table, func, ##__VA_ARGS__)
+ 
+ #define efi_info(fmt, ...) \
+ 	efi_printk(KERN_INFO fmt, ##__VA_ARGS__)
+ #define efi_warn(fmt, ...) \
+ 	efi_printk(KERN_WARNING "WARNING: " fmt, ##__VA_ARGS__)
+ #define efi_err(fmt, ...) \
+ 	efi_printk(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
+ #define efi_debug(fmt, ...) \
+ 	efi_printk(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
+ 
+ #define efi_printk_once(fmt, ...) 		\
+ ({						\
+ 	static bool __print_once;		\
+ 	bool __ret_print_once = !__print_once;	\
+ 						\
+ 	if (!__print_once) {			\
+ 		__print_once = true;		\
+ 		efi_printk(fmt, ##__VA_ARGS__);	\
+ 	}					\
+ 	__ret_print_once;			\
+ })
+ 
+ #define efi_info_once(fmt, ...) \
+ 	efi_printk_once(KERN_INFO fmt, ##__VA_ARGS__)
+ #define efi_warn_once(fmt, ...) \
+ 	efi_printk_once(KERN_WARNING "WARNING: " fmt, ##__VA_ARGS__)
+ #define efi_err_once(fmt, ...) \
+ 	efi_printk_once(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
+ #define efi_debug_once(fmt, ...) \
+ 	efi_printk_once(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
+ 
+ /* Helper macros for the usual case of using simple C variables: */
+ #ifndef fdt_setprop_inplace_var
+ #define fdt_setprop_inplace_var(fdt, node_offset, name, var) \
+ 	fdt_setprop_inplace((fdt), (node_offset), (name), &(var), sizeof(var))
+ #endif
+ 
+ #ifndef fdt_setprop_var
+ #define fdt_setprop_var(fdt, node_offset, name, var) \
+ 	fdt_setprop((fdt), (node_offset), (name), &(var), sizeof(var))
+ #endif
+ 
+ #define get_efi_var(name, vendor, ...)				\
+ 	efi_rt_call(get_variable, (efi_char16_t *)(name),	\
+ 		    (efi_guid_t *)(vendor), __VA_ARGS__)
+ 
+ #define set_efi_var(name, vendor, ...)				\
+ 	efi_rt_call(set_variable, (efi_char16_t *)(name),	\
+ 		    (efi_guid_t *)(vendor), __VA_ARGS__)
+ 
+ #define efi_get_handle_at(array, idx)					\
+ 	(efi_is_native() ? (array)[idx] 				\
+ 		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
+ 
+ #define efi_get_handle_num(size)					\
+ 	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
+ 
+ #define for_each_efi_handle(handle, array, size, i)			\
+ 	for (i = 0;							\
+ 	     i < efi_get_handle_num(size) &&				\
+ 		((handle = efi_get_handle_at((array), i)) || true);	\
+ 	     i++)
+ 
+ static inline
+ void efi_set_u64_split(u64 data, u32 *lo, u32 *hi)
+ {
+ 	*lo = lower_32_bits(data);
+ 	*hi = upper_32_bits(data);
+ }
+ 
+ /*
+  * Allocation types for calls to boottime->allocate_pages.
+  */
+ #define EFI_ALLOCATE_ANY_PAGES		0
+ #define EFI_ALLOCATE_MAX_ADDRESS	1
+ #define EFI_ALLOCATE_ADDRESS		2
+ #define EFI_MAX_ALLOCATE_TYPE		3
+ 
+ /*
+  * The type of search to perform when calling boottime->locate_handle
+  */
+ #define EFI_LOCATE_ALL_HANDLES			0
+ #define EFI_LOCATE_BY_REGISTER_NOTIFY		1
+ #define EFI_LOCATE_BY_PROTOCOL			2
+ 
+ /*
+  * boottime->stall takes the time period in microseconds
+  */
+ #define EFI_USEC_PER_SEC		1000000
+ 
+ /*
+  * boottime->set_timer takes the time in 100ns units
+  */
+ #define EFI_100NSEC_PER_USEC	((u64)10)
+ 
+ /*
+  * An efi_boot_memmap is used by efi_get_memory_map() to return the
+  * EFI memory map in a dynamically allocated buffer.
+  *
+  * The buffer allocated for the EFI memory map includes extra room for
+  * a minimum of EFI_MMAP_NR_SLACK_SLOTS additional EFI memory descriptors.
+  * This facilitates the reuse of the EFI memory map buffer when a second
+  * call to ExitBootServices() is needed because of intervening changes to
+  * the EFI memory map. Other related structures, e.g. x86 e820ext, need
+  * to factor in this headroom requirement as well.
+  */
+ #define EFI_MMAP_NR_SLACK_SLOTS	8
+ 
+ typedef struct efi_generic_dev_path efi_device_path_protocol_t;
+ 
+ union efi_device_path_to_text_protocol {
+ 	struct {
+ 		efi_char16_t *(__efiapi *convert_device_node_to_text)(
+ 					const efi_device_path_protocol_t *,
+ 					bool, bool);
+ 		efi_char16_t *(__efiapi *convert_device_path_to_text)(
+ 					const efi_device_path_protocol_t *,
+ 					bool, bool);
+ 	};
+ 	struct {
+ 		u32 convert_device_node_to_text;
+ 		u32 convert_device_path_to_text;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_device_path_to_text_protocol efi_device_path_to_text_protocol_t;
+ 
+ union efi_device_path_from_text_protocol {
+ 	struct {
+ 		efi_device_path_protocol_t *
+ 			(__efiapi *convert_text_to_device_node)(const efi_char16_t *);
+ 		efi_device_path_protocol_t *
+ 			(__efiapi *convert_text_to_device_path)(const efi_char16_t *);
+ 	};
+ 	struct {
+ 		u32 convert_text_to_device_node;
+ 		u32 convert_text_to_device_path;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_device_path_from_text_protocol efi_device_path_from_text_protocol_t;
+ 
+ typedef void *efi_event_t;
+ /* Note that notifications won't work in mixed mode */
+ typedef void (__efiapi *efi_event_notify_t)(efi_event_t, void *);
+ 
+ #define EFI_EVT_TIMER		0x80000000U
+ #define EFI_EVT_RUNTIME		0x40000000U
+ #define EFI_EVT_NOTIFY_WAIT	0x00000100U
+ #define EFI_EVT_NOTIFY_SIGNAL	0x00000200U
+ 
+ /**
+  * efi_set_event_at() - add event to events array
+  *
+  * @events:	array of UEFI events
+  * @ids:	index where to put the event in the array
+  * @event:	event to add to the aray
+  *
+  * boottime->wait_for_event() takes an array of events as input.
+  * Provide a helper to set it up correctly for mixed mode.
+  */
+ static inline
+ void efi_set_event_at(efi_event_t *events, size_t idx, efi_event_t event)
+ {
+ 	if (efi_is_native())
+ 		events[idx] = event;
+ 	else
+ 		((u32 *)events)[idx] = (u32)(unsigned long)event;
+ }
+ 
+ #define EFI_TPL_APPLICATION	4
+ #define EFI_TPL_CALLBACK	8
+ #define EFI_TPL_NOTIFY		16
+ #define EFI_TPL_HIGH_LEVEL	31
+ 
+ typedef enum {
+ 	EfiTimerCancel,
+ 	EfiTimerPeriodic,
+ 	EfiTimerRelative
+ } EFI_TIMER_DELAY;
+ 
+ /*
+  * EFI Boot Services table
+  */
+ union efi_boot_services {
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		void *raise_tpl;
+ 		void *restore_tpl;
+ 		efi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,
+ 							efi_physical_addr_t *);
+ 		efi_status_t (__efiapi *free_pages)(efi_physical_addr_t,
+ 						    unsigned long);
+ 		efi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,
+ 							unsigned long *,
+ 							unsigned long *, u32 *);
+ 		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
+ 						       void **);
+ 		efi_status_t (__efiapi *free_pool)(void *);
+ 		efi_status_t (__efiapi *create_event)(u32, unsigned long,
+ 						      efi_event_notify_t, void *,
+ 						      efi_event_t *);
+ 		efi_status_t (__efiapi *set_timer)(efi_event_t,
+ 						  EFI_TIMER_DELAY, u64);
+ 		efi_status_t (__efiapi *wait_for_event)(unsigned long,
+ 							efi_event_t *,
+ 							unsigned long *);
+ 		void *signal_event;
+ 		efi_status_t (__efiapi *close_event)(efi_event_t);
+ 		void *check_event;
+ 		void *install_protocol_interface;
+ 		void *reinstall_protocol_interface;
+ 		void *uninstall_protocol_interface;
+ 		efi_status_t (__efiapi *handle_protocol)(efi_handle_t,
+ 							 efi_guid_t *, void **);
+ 		void *__reserved;
+ 		void *register_protocol_notify;
+ 		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
+ 						       void *, unsigned long *,
+ 						       efi_handle_t *);
+ 		efi_status_t (__efiapi *locate_device_path)(efi_guid_t *,
+ 							    efi_device_path_protocol_t **,
+ 							    efi_handle_t *);
+ 		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
+ 								     void *);
+ 		efi_status_t (__efiapi *load_image)(bool, efi_handle_t,
+ 						    efi_device_path_protocol_t *,
+ 						    void *, unsigned long,
+ 						    efi_handle_t *);
+ 		efi_status_t (__efiapi *start_image)(efi_handle_t, unsigned long *,
+ 						     efi_char16_t **);
+ 		efi_status_t __noreturn (__efiapi *exit)(efi_handle_t,
+ 							 efi_status_t,
+ 							 unsigned long,
+ 							 efi_char16_t *);
+ 		efi_status_t (__efiapi *unload_image)(efi_handle_t);
+ 		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
+ 							    unsigned long);
+ 		void *get_next_monotonic_count;
+ 		efi_status_t (__efiapi *stall)(unsigned long);
+ 		void *set_watchdog_timer;
+ 		void *connect_controller;
+ 		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
+ 							       efi_handle_t,
+ 							       efi_handle_t);
+ 		void *open_protocol;
+ 		void *close_protocol;
+ 		void *open_protocol_information;
+ 		void *protocols_per_handle;
+ 		void *locate_handle_buffer;
+ 		efi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,
+ 							 void **);
+ 		efi_status_t (__efiapi *install_multiple_protocol_interfaces)(efi_handle_t *, ...);
+ 		efi_status_t (__efiapi *uninstall_multiple_protocol_interfaces)(efi_handle_t, ...);
+ 		void *calculate_crc32;
+ 		void (__efiapi *copy_mem)(void *, const void *, unsigned long);
+ 		void (__efiapi *set_mem)(void *, unsigned long, unsigned char);
+ 		void *create_event_ex;
+ 	};
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		u32 raise_tpl;
+ 		u32 restore_tpl;
+ 		u32 allocate_pages;
+ 		u32 free_pages;
+ 		u32 get_memory_map;
+ 		u32 allocate_pool;
+ 		u32 free_pool;
+ 		u32 create_event;
+ 		u32 set_timer;
+ 		u32 wait_for_event;
+ 		u32 signal_event;
+ 		u32 close_event;
+ 		u32 check_event;
+ 		u32 install_protocol_interface;
+ 		u32 reinstall_protocol_interface;
+ 		u32 uninstall_protocol_interface;
+ 		u32 handle_protocol;
+ 		u32 __reserved;
+ 		u32 register_protocol_notify;
+ 		u32 locate_handle;
+ 		u32 locate_device_path;
+ 		u32 install_configuration_table;
+ 		u32 load_image;
+ 		u32 start_image;
+ 		u32 exit;
+ 		u32 unload_image;
+ 		u32 exit_boot_services;
+ 		u32 get_next_monotonic_count;
+ 		u32 stall;
+ 		u32 set_watchdog_timer;
+ 		u32 connect_controller;
+ 		u32 disconnect_controller;
+ 		u32 open_protocol;
+ 		u32 close_protocol;
+ 		u32 open_protocol_information;
+ 		u32 protocols_per_handle;
+ 		u32 locate_handle_buffer;
+ 		u32 locate_protocol;
+ 		u32 install_multiple_protocol_interfaces;
+ 		u32 uninstall_multiple_protocol_interfaces;
+ 		u32 calculate_crc32;
+ 		u32 copy_mem;
+ 		u32 set_mem;
+ 		u32 create_event_ex;
+ 	} mixed_mode;
+ };
+ 
+ typedef enum {
+ 	EfiGcdMemoryTypeNonExistent,
+ 	EfiGcdMemoryTypeReserved,
+ 	EfiGcdMemoryTypeSystemMemory,
+ 	EfiGcdMemoryTypeMemoryMappedIo,
+ 	EfiGcdMemoryTypePersistent,
+ 	EfiGcdMemoryTypeMoreReliable,
+ 	EfiGcdMemoryTypeMaximum
+ } efi_gcd_memory_type_t;
+ 
+ typedef struct {
+ 	efi_physical_addr_t base_address;
+ 	u64 length;
+ 	u64 capabilities;
+ 	u64 attributes;
+ 	efi_gcd_memory_type_t gcd_memory_type;
+ 	void *image_handle;
+ 	void *device_handle;
+ } efi_gcd_memory_space_desc_t;
+ 
+ /*
+  * EFI DXE Services table
+  */
+ union efi_dxe_services_table {
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		void *add_memory_space;
+ 		void *allocate_memory_space;
+ 		void *free_memory_space;
+ 		void *remove_memory_space;
+ 		efi_status_t (__efiapi *get_memory_space_descriptor)(efi_physical_addr_t,
+ 								     efi_gcd_memory_space_desc_t *);
+ 		efi_status_t (__efiapi *set_memory_space_attributes)(efi_physical_addr_t,
+ 								     u64, u64);
+ 		void *get_memory_space_map;
+ 		void *add_io_space;
+ 		void *allocate_io_space;
+ 		void *free_io_space;
+ 		void *remove_io_space;
+ 		void *get_io_space_descriptor;
+ 		void *get_io_space_map;
+ 		void *dispatch;
+ 		void *schedule;
+ 		void *trust;
+ 		void *process_firmware_volume;
+ 		void *set_memory_space_capabilities;
+ 	};
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		u32 add_memory_space;
+ 		u32 allocate_memory_space;
+ 		u32 free_memory_space;
+ 		u32 remove_memory_space;
+ 		u32 get_memory_space_descriptor;
+ 		u32 set_memory_space_attributes;
+ 		u32 get_memory_space_map;
+ 		u32 add_io_space;
+ 		u32 allocate_io_space;
+ 		u32 free_io_space;
+ 		u32 remove_io_space;
+ 		u32 get_io_space_descriptor;
+ 		u32 get_io_space_map;
+ 		u32 dispatch;
+ 		u32 schedule;
+ 		u32 trust;
+ 		u32 process_firmware_volume;
+ 		u32 set_memory_space_capabilities;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_memory_attribute_protocol efi_memory_attribute_protocol_t;
+ 
+ union efi_memory_attribute_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *get_memory_attributes)(
+ 			efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64 *);
+ 
+ 		efi_status_t (__efiapi *set_memory_attributes)(
+ 			efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);
+ 
+ 		efi_status_t (__efiapi *clear_memory_attributes)(
+ 			efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);
+ 	};
+ 	struct {
+ 		u32 get_memory_attributes;
+ 		u32 set_memory_attributes;
+ 		u32 clear_memory_attributes;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;
+ 
+ union efi_uga_draw_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *get_mode)(efi_uga_draw_protocol_t *,
+ 						  u32*, u32*, u32*, u32*);
+ 		void *set_mode;
+ 		void *blt;
+ 	};
+ 	struct {
+ 		u32 get_mode;
+ 		u32 set_mode;
+ 		u32 blt;
+ 	} mixed_mode;
+ };
+ 
+ typedef struct {
+ 	u16 scan_code;
+ 	efi_char16_t unicode_char;
+ } efi_input_key_t;
+ 
+ union efi_simple_text_input_protocol {
+ 	struct {
+ 		void *reset;
+ 		efi_status_t (__efiapi *read_keystroke)(efi_simple_text_input_protocol_t *,
+ 							efi_input_key_t *);
+ 		efi_event_t wait_for_key;
+ 	};
+ 	struct {
+ 		u32 reset;
+ 		u32 read_keystroke;
+ 		u32 wait_for_key;
+ 	} mixed_mode;
+ };
+ 
+ efi_status_t efi_wait_for_key(unsigned long usec, efi_input_key_t *key);
+ 
+ union efi_simple_text_output_protocol {
+ 	struct {
+ 		void *reset;
+ 		efi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,
+ 						       efi_char16_t *);
+ 		void *test_string;
+ 	};
+ 	struct {
+ 		u32 reset;
+ 		u32 output_string;
+ 		u32 test_string;
+ 	} mixed_mode;
+ };
+ 
+ #define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
+ #define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1
+ #define PIXEL_BIT_MASK					2
+ #define PIXEL_BLT_ONLY					3
+ #define PIXEL_FORMAT_MAX				4
+ 
+ typedef struct {
+ 	u32 red_mask;
+ 	u32 green_mask;
+ 	u32 blue_mask;
+ 	u32 reserved_mask;
+ } efi_pixel_bitmask_t;
+ 
+ typedef struct {
+ 	u32 version;
+ 	u32 horizontal_resolution;
+ 	u32 vertical_resolution;
+ 	int pixel_format;
+ 	efi_pixel_bitmask_t pixel_information;
+ 	u32 pixels_per_scan_line;
+ } efi_graphics_output_mode_info_t;
+ 
+ typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
+ 
+ union efi_graphics_output_protocol_mode {
+ 	struct {
+ 		u32 max_mode;
+ 		u32 mode;
+ 		efi_graphics_output_mode_info_t *info;
+ 		unsigned long size_of_info;
+ 		efi_physical_addr_t frame_buffer_base;
+ 		unsigned long frame_buffer_size;
+ 	};
+ 	struct {
+ 		u32 max_mode;
+ 		u32 mode;
+ 		u32 info;
+ 		u32 size_of_info;
+ 		u64 frame_buffer_base;
+ 		u32 frame_buffer_size;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
+ 
+ union efi_graphics_output_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *query_mode)(efi_graphics_output_protocol_t *,
+ 						    u32, unsigned long *,
+ 						    efi_graphics_output_mode_info_t **);
+ 		efi_status_t (__efiapi *set_mode)  (efi_graphics_output_protocol_t *, u32);
+ 		void *blt;
+ 		efi_graphics_output_protocol_mode_t *mode;
+ 	};
+ 	struct {
+ 		u32 query_mode;
+ 		u32 set_mode;
+ 		u32 blt;
+ 		u32 mode;
+ 	} mixed_mode;
+ };
+ 
+ typedef union {
+ 	struct {
+ 		u32			revision;
+ 		efi_handle_t		parent_handle;
+ 		efi_system_table_t	*system_table;
+ 		efi_handle_t		device_handle;
+ 		void			*file_path;
+ 		void			*reserved;
+ 		u32			load_options_size;
+ 		void			*load_options;
+ 		void			*image_base;
+ 		__aligned_u64		image_size;
+ 		unsigned int		image_code_type;
+ 		unsigned int		image_data_type;
+ 		efi_status_t		(__efiapi *unload)(efi_handle_t image_handle);
+ 	};
+ 	struct {
+ 		u32		revision;
+ 		u32		parent_handle;
+ 		u32		system_table;
+ 		u32		device_handle;
+ 		u32		file_path;
+ 		u32		reserved;
+ 		u32		load_options_size;
+ 		u32		load_options;
+ 		u32		image_base;
+ 		__aligned_u64	image_size;
+ 		u32		image_code_type;
+ 		u32		image_data_type;
+ 		u32		unload;
+ 	} mixed_mode;
+ } efi_loaded_image_t;
+ 
+ typedef struct {
+ 	u64			size;
+ 	u64			file_size;
+ 	u64			phys_size;
+ 	efi_time_t		create_time;
+ 	efi_time_t		last_access_time;
+ 	efi_time_t		modification_time;
+ 	__aligned_u64		attribute;
+ 	efi_char16_t		filename[];
+ } efi_file_info_t;
+ 
+ typedef union efi_file_protocol efi_file_protocol_t;
+ 
+ union efi_file_protocol {
+ 	struct {
+ 		u64		revision;
+ 		efi_status_t	(__efiapi *open)	(efi_file_protocol_t *,
+ 							 efi_file_protocol_t **,
+ 							 efi_char16_t *, u64,
+ 							 u64);
+ 		efi_status_t	(__efiapi *close)	(efi_file_protocol_t *);
+ 		efi_status_t	(__efiapi *delete)	(efi_file_protocol_t *);
+ 		efi_status_t	(__efiapi *read)	(efi_file_protocol_t *,
+ 							 unsigned long *,
+ 							 void *);
+ 		efi_status_t	(__efiapi *write)	(efi_file_protocol_t *,
+ 							 unsigned long, void *);
+ 		efi_status_t	(__efiapi *get_position)(efi_file_protocol_t *,
+ 							 u64 *);
+ 		efi_status_t	(__efiapi *set_position)(efi_file_protocol_t *,
+ 							 u64);
+ 		efi_status_t	(__efiapi *get_info)	(efi_file_protocol_t *,
+ 							 efi_guid_t *,
+ 							 unsigned long *,
+ 							 void *);
+ 		efi_status_t	(__efiapi *set_info)	(efi_file_protocol_t *,
+ 							 efi_guid_t *,
+ 							 unsigned long,
+ 							 void *);
+ 		efi_status_t	(__efiapi *flush)	(efi_file_protocol_t *);
+ 	};
+ 	struct {
+ 		u64 revision;
+ 		u32 open;
+ 		u32 close;
+ 		u32 delete;
+ 		u32 read;
+ 		u32 write;
+ 		u32 get_position;
+ 		u32 set_position;
+ 		u32 get_info;
+ 		u32 set_info;
+ 		u32 flush;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_simple_file_system_protocol efi_simple_file_system_protocol_t;
+ 
+ union efi_simple_file_system_protocol {
+ 	struct {
+ 		u64		revision;
+ 		efi_status_t	(__efiapi *open_volume)(efi_simple_file_system_protocol_t *,
+ 							efi_file_protocol_t **);
+ 	};
+ 	struct {
+ 		u64 revision;
+ 		u32 open_volume;
+ 	} mixed_mode;
+ };
+ 
+ #define EFI_FILE_MODE_READ	0x0000000000000001
+ #define EFI_FILE_MODE_WRITE	0x0000000000000002
+ #define EFI_FILE_MODE_CREATE	0x8000000000000000
+ 
+ typedef enum {
+ 	EfiPciIoWidthUint8,
+ 	EfiPciIoWidthUint16,
+ 	EfiPciIoWidthUint32,
+ 	EfiPciIoWidthUint64,
+ 	EfiPciIoWidthFifoUint8,
+ 	EfiPciIoWidthFifoUint16,
+ 	EfiPciIoWidthFifoUint32,
+ 	EfiPciIoWidthFifoUint64,
+ 	EfiPciIoWidthFillUint8,
+ 	EfiPciIoWidthFillUint16,
+ 	EfiPciIoWidthFillUint32,
+ 	EfiPciIoWidthFillUint64,
+ 	EfiPciIoWidthMaximum
+ } EFI_PCI_IO_PROTOCOL_WIDTH;
+ 
+ typedef enum {
+ 	EfiPciIoAttributeOperationGet,
+ 	EfiPciIoAttributeOperationSet,
+ 	EfiPciIoAttributeOperationEnable,
+ 	EfiPciIoAttributeOperationDisable,
+ 	EfiPciIoAttributeOperationSupported,
+     EfiPciIoAttributeOperationMaximum
+ } EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+ 
+ typedef struct {
+ 	u32 read;
+ 	u32 write;
+ } efi_pci_io_protocol_access_32_t;
+ 
+ typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
+ 
+ typedef
+ efi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
+ 						   EFI_PCI_IO_PROTOCOL_WIDTH,
+ 						   u32 offset,
+ 						   unsigned long count,
+ 						   void *buffer);
+ 
+ typedef struct {
+ 	void *read;
+ 	void *write;
+ } efi_pci_io_protocol_access_t;
+ 
+ typedef struct {
+ 	efi_pci_io_protocol_cfg_t read;
+ 	efi_pci_io_protocol_cfg_t write;
+ } efi_pci_io_protocol_config_access_t;
+ 
+ union efi_pci_io_protocol {
+ 	struct {
+ 		void *poll_mem;
+ 		void *poll_io;
+ 		efi_pci_io_protocol_access_t mem;
+ 		efi_pci_io_protocol_access_t io;
+ 		efi_pci_io_protocol_config_access_t pci;
+ 		void *copy_mem;
+ 		void *map;
+ 		void *unmap;
+ 		void *allocate_buffer;
+ 		void *free_buffer;
+ 		void *flush;
+ 		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
+ 						      unsigned long *segment_nr,
+ 						      unsigned long *bus_nr,
+ 						      unsigned long *device_nr,
+ 						      unsigned long *func_nr);
+ 		void *attributes;
+ 		void *get_bar_attributes;
+ 		void *set_bar_attributes;
+ 		uint64_t romsize;
+ 		void *romimage;
+ 	};
+ 	struct {
+ 		u32 poll_mem;
+ 		u32 poll_io;
+ 		efi_pci_io_protocol_access_32_t mem;
+ 		efi_pci_io_protocol_access_32_t io;
+ 		efi_pci_io_protocol_access_32_t pci;
+ 		u32 copy_mem;
+ 		u32 map;
+ 		u32 unmap;
+ 		u32 allocate_buffer;
+ 		u32 free_buffer;
+ 		u32 flush;
+ 		u32 get_location;
+ 		u32 attributes;
+ 		u32 get_bar_attributes;
+ 		u32 set_bar_attributes;
+ 		u64 romsize;
+ 		u32 romimage;
+ 	} mixed_mode;
+ };
+ 
+ #define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
+ #define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
+ #define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
+ #define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+ #define EFI_PCI_IO_ATTRIBUTE_IO 0x0100
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
+ #define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
+ #define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
+ #define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
+ #define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
+ #define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
+ 
+ struct efi_dev_path;
+ 
+ typedef union apple_properties_protocol apple_properties_protocol_t;
+ 
+ union apple_properties_protocol {
+ 	struct {
+ 		unsigned long version;
+ 		efi_status_t (__efiapi *get)(apple_properties_protocol_t *,
+ 					     struct efi_dev_path *,
+ 					     efi_char16_t *, void *, u32 *);
+ 		efi_status_t (__efiapi *set)(apple_properties_protocol_t *,
+ 					     struct efi_dev_path *,
+ 					     efi_char16_t *, void *, u32);
+ 		efi_status_t (__efiapi *del)(apple_properties_protocol_t *,
+ 					     struct efi_dev_path *,
+ 					     efi_char16_t *);
+ 		efi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,
+ 						 void *buffer, u32 *);
+ 	};
+ 	struct {
+ 		u32 version;
+ 		u32 get;
+ 		u32 set;
+ 		u32 del;
+ 		u32 get_all;
+ 	} mixed_mode;
+ };
+ 
+ typedef u32 efi_tcg2_event_log_format;
+ 
+ #define INITRD_EVENT_TAG_ID 0x8F3B22ECU
+ #define LOAD_OPTIONS_EVENT_TAG_ID 0x8F3B22EDU
+ #define EV_EVENT_TAG 0x00000006U
+ #define EFI_TCG2_EVENT_HEADER_VERSION	0x1
+ 
+ struct efi_tcg2_event {
+ 	u32		event_size;
+ 	struct {
+ 		u32	header_size;
+ 		u16	header_version;
+ 		u32	pcr_index;
+ 		u32	event_type;
+ 	} __packed event_header;
+ 	/* u8[] event follows here */
+ } __packed;
+ 
+ struct efi_tcg2_tagged_event {
+ 	u32 tagged_event_id;
+ 	u32 tagged_event_data_size;
+ 	/* u8  tagged event data follows here */
+ } __packed;
+ 
+ typedef struct efi_tcg2_event efi_tcg2_event_t;
+ typedef struct efi_tcg2_tagged_event efi_tcg2_tagged_event_t;
+ typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
+ 
+ union efi_tcg2_protocol {
+ 	struct {
+ 		void *get_capability;
+ 		efi_status_t (__efiapi *get_event_log)(efi_tcg2_protocol_t *,
+ 						       efi_tcg2_event_log_format,
+ 						       efi_physical_addr_t *,
+ 						       efi_physical_addr_t *,
+ 						       efi_bool_t *);
+ 		efi_status_t (__efiapi *hash_log_extend_event)(efi_tcg2_protocol_t *,
+ 							       u64,
+ 							       efi_physical_addr_t,
+ 							       u64,
+ 							       const efi_tcg2_event_t *);
+ 		void *submit_command;
+ 		void *get_active_pcr_banks;
+ 		void *set_active_pcr_banks;
+ 		void *get_result_of_set_active_pcr_banks;
+ 	};
+ 	struct {
+ 		u32 get_capability;
+ 		u32 get_event_log;
+ 		u32 hash_log_extend_event;
+ 		u32 submit_command;
+ 		u32 get_active_pcr_banks;
+ 		u32 set_active_pcr_banks;
+ 		u32 get_result_of_set_active_pcr_banks;
+ 	} mixed_mode;
+ };
+ 
+ struct riscv_efi_boot_protocol {
+ 	u64 revision;
+ 
+ 	efi_status_t (__efiapi *get_boot_hartid)(struct riscv_efi_boot_protocol *,
+ 						 unsigned long *boot_hartid);
+ };
+ 
+ typedef union efi_load_file_protocol efi_load_file_protocol_t;
+ typedef union efi_load_file_protocol efi_load_file2_protocol_t;
+ 
+ union efi_load_file_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *load_file)(efi_load_file_protocol_t *,
+ 						   efi_device_path_protocol_t *,
+ 						   bool, unsigned long *, void *);
+ 	};
+ 	struct {
+ 		u32 load_file;
+ 	} mixed_mode;
+ };
+ 
+ typedef struct {
+ 	u32 attributes;
+ 	u16 file_path_list_length;
+ 	u8 variable_data[];
+ 	// efi_char16_t description[];
+ 	// efi_device_path_protocol_t file_path_list[];
+ 	// u8 optional_data[];
+ } __packed efi_load_option_t;
+ 
+ #define EFI_LOAD_OPTION_ACTIVE		0x0001U
+ #define EFI_LOAD_OPTION_FORCE_RECONNECT	0x0002U
+ #define EFI_LOAD_OPTION_HIDDEN		0x0008U
+ #define EFI_LOAD_OPTION_CATEGORY	0x1f00U
+ #define   EFI_LOAD_OPTION_CATEGORY_BOOT	0x0000U
+ #define   EFI_LOAD_OPTION_CATEGORY_APP	0x0100U
+ 
+ #define EFI_LOAD_OPTION_BOOT_MASK \
+ 	(EFI_LOAD_OPTION_ACTIVE|EFI_LOAD_OPTION_HIDDEN|EFI_LOAD_OPTION_CATEGORY)
+ #define EFI_LOAD_OPTION_MASK (EFI_LOAD_OPTION_FORCE_RECONNECT|EFI_LOAD_OPTION_BOOT_MASK)
+ 
+ typedef struct {
+ 	u32 attributes;
+ 	u16 file_path_list_length;
+ 	const efi_char16_t *description;
+ 	const efi_device_path_protocol_t *file_path_list;
+ 	u32 optional_data_size;
+ 	const void *optional_data;
+ } efi_load_option_unpacked_t;
+ 
+ void efi_pci_disable_bridge_busmaster(void);
+ 
+ typedef efi_status_t (*efi_exit_boot_map_processing)(
+ 	struct efi_boot_memmap *map,
+ 	void *priv);
+ 
+ efi_status_t efi_exit_boot_services(void *handle, void *priv,
+ 				    efi_exit_boot_map_processing priv_func);
+ 
+ efi_status_t efi_boot_kernel(void *handle, efi_loaded_image_t *image,
+ 			     unsigned long kernel_addr, char *cmdline_ptr);
+ 
+ void *get_fdt(unsigned long *fdt_size);
+ 
+ efi_status_t efi_alloc_virtmap(efi_memory_desc_t **virtmap,
+ 			       unsigned long *desc_size, u32 *desc_ver);
++>>>>>>> 79729f26b074 (efi/libstub: Add memory attribute protocol definitions)
  void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
  		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
  		     int *count);
diff --cc include/linux/efi.h
index ce03c6896970,507390dda8b9..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -833,8 -386,12 +833,13 @@@ void efi_native_runtime_setup(void)
  #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
  #define APPLE_PROPERTIES_PROTOCOL_GUID		EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
  #define EFI_TCG2_PROTOCOL_GUID			EFI_GUID(0x607f766c, 0x7455, 0x42be,  0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)
 -#define EFI_LOAD_FILE_PROTOCOL_GUID		EFI_GUID(0x56ec3091, 0x954c, 0x11d2,  0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
 -#define EFI_LOAD_FILE2_PROTOCOL_GUID		EFI_GUID(0x4006c0c1, 0xfcb3, 0x403e,  0x99, 0x6d, 0x4a, 0x6c, 0x87, 0x24, 0xe0, 0x6d)
  #define EFI_RT_PROPERTIES_TABLE_GUID		EFI_GUID(0xeb66918a, 0x7eef, 0x402a,  0x84, 0x2e, 0x93, 0x1d, 0x21, 0xc3, 0x8a, 0xe9)
  #define EFI_DXE_SERVICES_TABLE_GUID		EFI_GUID(0x05ad34ba, 0x6f02, 0x4214,  0x95, 0x2e, 0x4d, 0xa0, 0x39, 0x8e, 0x2b, 0xb9)
++<<<<<<< HEAD
++=======
+ #define EFI_SMBIOS_PROTOCOL_GUID		EFI_GUID(0x03583ff6, 0xcb36, 0x4940,  0x94, 0x7e, 0xb9, 0xb3, 0x9f, 0x4a, 0xfa, 0xf7)
+ #define EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID	EFI_GUID(0xf4560cf6, 0x40ec, 0x4b4a,  0xa1, 0x92, 0xbf, 0x1d, 0x57, 0xd0, 0xb1, 0x89)
++>>>>>>> 79729f26b074 (efi/libstub: Add memory attribute protocol definitions)
  
  #define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
  #define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
* Unmerged path arch/x86/include/asm/efi.h
* Unmerged path drivers/firmware/efi/libstub/efistub.h
* Unmerged path include/linux/efi.h
