x86/boot: Construct PE/COFF .text section from assembler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit efa089e63b56bdc5eca754b995cb039dd7a5457e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/efa089e6.failed

Now that the size of the setup block is visible to the assembler, it is
possible to populate the PE/COFF header fields from the asm code
directly, instead of poking the values into the binary using the build
tool. This will make it easier to reorganize the section layout without
having to tweak the build tool in lockstep.

This change has no impact on the resulting bzImage binary.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20230915171623.655440-15-ardb@google.com
(cherry picked from commit efa089e63b56bdc5eca754b995cb039dd7a5457e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/tools/build.c
diff --cc arch/x86/boot/tools/build.c
index db1a6f7dea68,9712f27e32c1..000000000000
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@@ -48,13 -48,10 +48,18 @@@ typedef unsigned int   u32
  u8 buf[SETUP_SECT_MAX*512];
  
  #define PECOFF_RELOC_RESERVE 0x20
 -#define PECOFF_COMPAT_RESERVE 0x20
  
++<<<<<<< HEAD
 +unsigned long efi32_stub_entry;
 +unsigned long efi64_stub_entry;
 +unsigned long efi_pe_entry;
 +unsigned long startup_64;
 +unsigned long _ehead;
 +unsigned long _end;
++=======
+ static unsigned long efi32_pe_entry;
+ static unsigned long _edata;
++>>>>>>> efa089e63b56 (x86/boot: Construct PE/COFF .text section from assembler)
  
  /*----------------------------------------------------------------------*/
  
@@@ -198,35 -198,22 +203,38 @@@ static void update_pecoff_setup_and_rel
  	 */
  	put_unaligned_le32(reloc_offset + 10, &buf[reloc_offset]);
  	put_unaligned_le32(10, &buf[reloc_offset + 4]);
 +}
  
 -#ifdef CONFIG_EFI_MIXED
 -	update_pecoff_section_header(".compat", compat_offset, PECOFF_COMPAT_RESERVE);
++<<<<<<< HEAD
 +static void update_pecoff_text(unsigned int text_start, unsigned int file_sz,
 +			       unsigned int init_sz)
 +{
 +	unsigned int pe_header;
 +	unsigned int text_sz = file_sz - text_start;
 +	unsigned int bss_sz = init_sz - file_sz;
 +
 +	pe_header = get_unaligned_le32(&buf[0x3c]);
  
  	/*
 -	 * Put the IA-32 machine type (0x14c) and the associated entry point
 -	 * address in the .compat section, so loaders can figure out which other
 -	 * execution modes this image supports.
 +	 * Size of code: Subtract the size of the first sector (512 bytes)
 +	 * which includes the header.
  	 */
 -	buf[compat_offset] = 0x1;
 -	buf[compat_offset + 1] = 0x8;
 -	put_unaligned_le16(0x14c, &buf[compat_offset + 2]);
 -	put_unaligned_le32(efi32_pe_entry + size, &buf[compat_offset + 4]);
 -#endif
 +	put_unaligned_le32(file_sz - 512 + bss_sz, &buf[pe_header + 0x1c]);
 +
 +	/* Size of image */
 +	put_unaligned_le32(init_sz, &buf[pe_header + 0x50]);
 +
 +	/*
 +	 * Address of entry point for PE/COFF executable
 +	 */
 +	put_unaligned_le32(text_start + efi_pe_entry, &buf[pe_header + 0x28]);
 +
 +	update_pecoff_section_header_fields(".text", text_start, text_sz + bss_sz,
 +					    text_sz, text_start);
  }
  
++=======
++>>>>>>> efa089e63b56 (x86/boot: Construct PE/COFF .text section from assembler)
  static int reserve_pecoff_reloc_section(int c)
  {
  	/* Reserve 0x20 bytes for .reloc section */
@@@ -234,41 -221,9 +242,47 @@@
  	return PECOFF_RELOC_RESERVE;
  }
  
++<<<<<<< HEAD
 +static void efi_stub_defaults(void)
 +{
 +	/* Defaults for old kernel */
 +#ifdef CONFIG_X86_32
 +	efi_pe_entry = 0x10;
 +#else
 +	efi_pe_entry = 0x210;
 +	startup_64 = 0x200;
 +#endif
 +}
 +
 +static void efi_stub_entry_update(void)
 +{
 +	unsigned long addr = efi32_stub_entry;
 +
 +#ifdef CONFIG_X86_64
 +	/* Yes, this is really how we defined it :( */
 +	addr = efi64_stub_entry - 0x200;
 +#endif
 +
 +#ifdef CONFIG_EFI_MIXED
 +	if (efi32_stub_entry != addr)
 +		die("32-bit and 64-bit EFI entry points do not match\n");
 +#endif
 +	put_unaligned_le32(addr, &buf[0x264]);
 +}
 +
  #else
  
  static inline void update_pecoff_setup_and_reloc(unsigned int size) {}
 +static inline void update_pecoff_text(unsigned int text_start,
 +				      unsigned int file_sz,
 +				      unsigned int init_sz) {}
 +static inline void efi_stub_defaults(void) {}
 +static inline void efi_stub_entry_update(void) {}
++=======
++#else
++
++static inline void update_pecoff_setup_and_reloc(unsigned int size) {}
++>>>>>>> efa089e63b56 (x86/boot: Construct PE/COFF .text section from assembler)
  
  static inline int reserve_pecoff_reloc_section(int c)
  {
@@@ -305,12 -266,8 +319,17 @@@ static void parse_zoffset(char *fname
  	p = (char *)buf;
  
  	while (p && *p) {
++<<<<<<< HEAD
 +		PARSE_ZOFS(p, efi32_stub_entry);
 +		PARSE_ZOFS(p, efi64_stub_entry);
 +		PARSE_ZOFS(p, efi_pe_entry);
 +		PARSE_ZOFS(p, startup_64);
 +		PARSE_ZOFS(p, _ehead);
 +		PARSE_ZOFS(p, _end);
++=======
+ 		PARSE_ZOFS(p, efi32_pe_entry);
+ 		PARSE_ZOFS(p, _edata);
++>>>>>>> efa089e63b56 (x86/boot: Construct PE/COFF .text section from assembler)
  
  		p = strchr(p, '\n');
  		while (p && (*p == '\r' || *p == '\n'))
@@@ -373,37 -331,6 +390,40 @@@ int main(int argc, char ** argv
  	kernel = mmap(NULL, sz, PROT_READ, MAP_SHARED, fd, 0);
  	if (kernel == MAP_FAILED)
  		die("Unable to mmap '%s': %m", argv[2]);
++<<<<<<< HEAD
 +	/* Number of 16-byte paragraphs, including space for a 4-byte CRC */
 +	sys_size = (sz + 15 + 4) / 16;
 +
 +	/* Patch the setup code with the appropriate size parameters */
 +	buf[0x1f1] = setup_sectors-1;
 +	put_unaligned_le32(sys_size, &buf[0x1f4]);
 +
 +	init_sz = get_unaligned_le32(&buf[0x260]);
 +#ifdef CONFIG_EFI_STUB
 +	/*
 +	 * The decompression buffer will start at ImageBase. When relocating
 +	 * the compressed kernel to its end, we must ensure that the head
 +	 * section does not get overwritten.  The head section occupies
 +	 * [i, i + _ehead), and the destination is [init_sz - _end, init_sz).
 +	 *
 +	 * At present these should never overlap, because 'i' is at most 32k
 +	 * because of SETUP_SECT_MAX, '_ehead' is less than 1k, and the
 +	 * calculation of INIT_SIZE in boot/header.S ensures that
 +	 * 'init_sz - _end' is at least 64k.
 +	 *
 +	 * For future-proofing, increase init_sz if necessary.
 +	 */
 +
 +	if (init_sz - _end < i + _ehead) {
 +		init_sz = (i + _ehead + _end + 4095) & ~4095;
 +		put_unaligned_le32(init_sz, &buf[0x260]);
 +	}
 +#endif
 +	update_pecoff_text(setup_sectors * 512, i + (sys_size * 16), init_sz);
 +
 +	efi_stub_entry_update();
++=======
++>>>>>>> efa089e63b56 (x86/boot: Construct PE/COFF .text section from assembler)
  
  	crc = partial_crc32(buf, i, crc);
  	if (fwrite(buf, 1, i, dest) != i)
diff --git a/arch/x86/boot/header.S b/arch/x86/boot/header.S
index 941d1e9413b4..0cd9adfa7653 100644
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@ -133,14 +133,12 @@ optional_header:
 	.byte	0x02				# MajorLinkerVersion
 	.byte	0x14				# MinorLinkerVersion
 
-	# Filled in by build.c
-	.long	0				# SizeOfCode
+	.long	setup_size + ZO__end - 0x200	# SizeOfCode
 
 	.long	0				# SizeOfInitializedData
 	.long	0				# SizeOfUninitializedData
 
-	# Filled in by build.c
-	.long	0x0000				# AddressOfEntryPoint
+	.long	setup_size + ZO_efi_pe_entry	# AddressOfEntryPoint
 
 	.long	0x0200				# BaseOfCode
 #ifdef CONFIG_X86_32
@@ -165,10 +163,7 @@ extra_header_fields:
 	.word	0				# MinorSubsystemVersion
 	.long	0				# Win32VersionValue
 
-	#
-	# The size of the bzImage is written in tools/build.c
-	#
-	.long	0				# SizeOfImage
+	.long	setup_size + ZO__end 		# SizeOfImage
 
 	.long	0x200				# SizeOfHeaders
 	.long	0				# CheckSum
@@ -232,18 +227,15 @@ section_table:
 	.word	0				# NumberOfLineNumbers
 	.long	0x42100040			# Characteristics (section flags)
 
-	#
-	# The offset & size fields are filled in by build.c.
-	#
 	.ascii	".text"
 	.byte	0
 	.byte	0
 	.byte	0
-	.long	0
-	.long	0x0				# startup_{32,64}
-	.long	0				# Size of initialized data
+	.long	ZO__end
+	.long	setup_size
+	.long	ZO__edata			# Size of initialized data
 						# on disk
-	.long	0x0				# startup_{32,64}
+	.long	setup_size
 	.long	0				# PointerToRelocations
 	.long	0				# PointerToLineNumbers
 	.word	0				# NumberOfRelocations
* Unmerged path arch/x86/boot/tools/build.c
