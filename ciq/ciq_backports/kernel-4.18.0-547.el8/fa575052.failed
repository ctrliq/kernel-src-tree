x86/boot: Drop PE/COFF .reloc section

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit fa5750521e0a4efbc1af05223da9c4bbd6c21c83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/fa575052.failed

Ancient buggy EFI loaders may have required a .reloc section to be
present at some point in time, but this has not been true for a long
time so the .reloc section can just be dropped.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20230915171623.655440-16-ardb@google.com
(cherry picked from commit fa5750521e0a4efbc1af05223da9c4bbd6c21c83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/header.S
#	arch/x86/boot/setup.ld
#	arch/x86/boot/tools/build.c
diff --cc arch/x86/boot/header.S
index 941d1e9413b4,9e9641e220a7..000000000000
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@@ -212,29 -151,29 +212,33 @@@ section_table
  	.long	0				# PointerToLineNumbers
  	.word	0				# NumberOfRelocations
  	.word	0				# NumberOfLineNumbers
 -	.long	IMAGE_SCN_CNT_CODE		| \
 -		IMAGE_SCN_MEM_READ		| \
 -		IMAGE_SCN_MEM_EXECUTE		# Characteristics
 +	.long	0x60500020			# Characteristics (section flags)
  
 -#ifdef CONFIG_EFI_MIXED
++<<<<<<< HEAD
  	#
 -	# The offset & size fields are filled in by build.c.
 +	# The EFI application loader requires a relocation section
 +	# because EFI applications must be relocatable. The .reloc
 +	# offset & size fields are filled in by build.c.
  	#
 -	.asciz	".compat"
 +	.ascii	".reloc"
 +	.byte	0
 +	.byte	0
  	.long	0
 -	.long	0x0
 -	.long	0				# Size of initialized data
 -						# on disk
 -	.long	0x0
 +	.long	0
 +	.long	0				# SizeOfRawData
 +	.long	0				# PointerToRawData
  	.long	0				# PointerToRelocations
  	.long	0				# PointerToLineNumbers
  	.word	0				# NumberOfRelocations
  	.word	0				# NumberOfLineNumbers
 -	.long	IMAGE_SCN_CNT_INITIALIZED_DATA	| \
 -		IMAGE_SCN_MEM_READ		| \
 -		IMAGE_SCN_MEM_DISCARDABLE	# Characteristics
 -#endif
 +	.long	0x42100040			# Characteristics (section flags)
  
++=======
++#ifdef CONFIG_EFI_MIXED
++>>>>>>> fa5750521e0a (x86/boot: Drop PE/COFF .reloc section)
 +	#
 +	# The offset & size fields are filled in by build.c.
 +	#
  	.ascii	".text"
  	.byte	0
  	.byte	0
diff --cc arch/x86/boot/setup.ld
index 96a6c7563538,6d389499565c..000000000000
--- a/arch/x86/boot/setup.ld
+++ b/arch/x86/boot/setup.ld
@@@ -38,6 -39,10 +38,13 @@@ SECTION
  	.signature	: {
  		setup_sig = .;
  		LONG(0x5a5aaa55)
++<<<<<<< HEAD
++=======
+ 
+ 		/* Reserve some extra space for the compat section */
+ 		setup_size = ALIGN(ABSOLUTE(.) + 32, 512);
+ 		setup_sects = ABSOLUTE(setup_size / 512);
++>>>>>>> fa5750521e0a (x86/boot: Drop PE/COFF .reloc section)
  	}
  
  
diff --cc arch/x86/boot/tools/build.c
index db1a6f7dea68,faccff9743a3..000000000000
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@@ -47,14 -47,10 +47,18 @@@ typedef unsigned int   u32
  /* This must be large enough to hold the entire setup */
  u8 buf[SETUP_SECT_MAX*512];
  
++<<<<<<< HEAD
 +#define PECOFF_RELOC_RESERVE 0x20
++=======
+ #define PECOFF_COMPAT_RESERVE 0x20
++>>>>>>> fa5750521e0a (x86/boot: Drop PE/COFF .reloc section)
  
 -static unsigned long efi32_pe_entry;
 -static unsigned long _edata;
 +unsigned long efi32_stub_entry;
 +unsigned long efi64_stub_entry;
 +unsigned long efi_pe_entry;
 +unsigned long startup_64;
 +unsigned long _ehead;
 +unsigned long _end;
  
  /*----------------------------------------------------------------------*/
  
@@@ -183,99 -179,41 +187,108 @@@ static void update_pecoff_section_heade
  	update_pecoff_section_header_fields(section_name, offset, size, size, offset);
  }
  
- static void update_pecoff_setup_and_reloc(unsigned int size)
+ static void update_pecoff_setup(unsigned int size)
  {
  	u32 setup_offset = 0x200;
++<<<<<<< HEAD
 +	u32 reloc_offset = size - PECOFF_RELOC_RESERVE;
 +	u32 setup_size = reloc_offset - setup_offset;
 +
 +	update_pecoff_section_header(".setup", setup_offset, setup_size);
 +	update_pecoff_section_header(".reloc", reloc_offset, PECOFF_RELOC_RESERVE);
 +
 +	/*
 +	 * Modify .reloc section contents with a single entry. The
 +	 * relocation is applied to offset 10 of the relocation section.
 +	 */
 +	put_unaligned_le32(reloc_offset + 10, &buf[reloc_offset]);
 +	put_unaligned_le32(10, &buf[reloc_offset + 4]);
 +}
++=======
+ 	u32 compat_offset = size - PECOFF_COMPAT_RESERVE;
+ 	u32 setup_size = compat_offset - setup_offset;
+ 
+ 	update_pecoff_section_header(".setup", setup_offset, setup_size);
++>>>>>>> fa5750521e0a (x86/boot: Drop PE/COFF .reloc section)
  
 -#ifdef CONFIG_EFI_MIXED
 -	update_pecoff_section_header(".compat", compat_offset, PECOFF_COMPAT_RESERVE);
 +static void update_pecoff_text(unsigned int text_start, unsigned int file_sz,
 +			       unsigned int init_sz)
 +{
 +	unsigned int pe_header;
 +	unsigned int text_sz = file_sz - text_start;
 +	unsigned int bss_sz = init_sz - file_sz;
 +
 +	pe_header = get_unaligned_le32(&buf[0x3c]);
 +
 +	/*
 +	 * Size of code: Subtract the size of the first sector (512 bytes)
 +	 * which includes the header.
 +	 */
 +	put_unaligned_le32(file_sz - 512 + bss_sz, &buf[pe_header + 0x1c]);
 +
 +	/* Size of image */
 +	put_unaligned_le32(init_sz, &buf[pe_header + 0x50]);
  
  	/*
 -	 * Put the IA-32 machine type (0x14c) and the associated entry point
 -	 * address in the .compat section, so loaders can figure out which other
 -	 * execution modes this image supports.
 +	 * Address of entry point for PE/COFF executable
  	 */
 -	buf[compat_offset] = 0x1;
 -	buf[compat_offset + 1] = 0x8;
 -	put_unaligned_le16(0x14c, &buf[compat_offset + 2]);
 -	put_unaligned_le32(efi32_pe_entry + size, &buf[compat_offset + 4]);
 +	put_unaligned_le32(text_start + efi_pe_entry, &buf[pe_header + 0x28]);
 +
 +	update_pecoff_section_header_fields(".text", text_start, text_sz + bss_sz,
 +					    text_sz, text_start);
 +}
 +
++<<<<<<< HEAD
 +static int reserve_pecoff_reloc_section(int c)
 +{
 +	/* Reserve 0x20 bytes for .reloc section */
 +	memset(buf+c, 0, PECOFF_RELOC_RESERVE);
 +	return PECOFF_RELOC_RESERVE;
 +}
 +
 +static void efi_stub_defaults(void)
 +{
 +	/* Defaults for old kernel */
 +#ifdef CONFIG_X86_32
 +	efi_pe_entry = 0x10;
 +#else
 +	efi_pe_entry = 0x210;
 +	startup_64 = 0x200;
  #endif
  }
  
 +static void efi_stub_entry_update(void)
 +{
 +	unsigned long addr = efi32_stub_entry;
 +
 +#ifdef CONFIG_X86_64
 +	/* Yes, this is really how we defined it :( */
 +	addr = efi64_stub_entry - 0x200;
 +#endif
 +
 +#ifdef CONFIG_EFI_MIXED
 +	if (efi32_stub_entry != addr)
 +		die("32-bit and 64-bit EFI entry points do not match\n");
 +#endif
 +	put_unaligned_le32(addr, &buf[0x264]);
 +}
 +
 +#else
 +
 +static inline void update_pecoff_setup_and_reloc(unsigned int size) {}
 +static inline void update_pecoff_text(unsigned int text_start,
 +				      unsigned int file_sz,
 +				      unsigned int init_sz) {}
 +static inline void efi_stub_defaults(void) {}
 +static inline void efi_stub_entry_update(void) {}
++=======
+ #else
+ 
+ static inline void update_pecoff_setup(unsigned int size) {}
++>>>>>>> fa5750521e0a (x86/boot: Drop PE/COFF .reloc section)
  
- static inline int reserve_pecoff_reloc_section(int c)
- {
- 	return 0;
- }
  #endif /* CONFIG_EFI_STUB */
  
 -static int reserve_pecoff_compat_section(int c)
 -{
 -	/* Reserve 0x20 bytes for .compat section */
 -	memset(buf+c, 0, PECOFF_COMPAT_RESERVE);
 -	return PECOFF_COMPAT_RESERVE;
 -}
  
  /*
   * Parse zoffset.h and find the entry points. We could just #include zoffset.h
@@@ -352,7 -283,7 +365,11 @@@ int main(int argc, char ** argv
  		die("Boot block hasn't got boot flag (0xAA55)");
  	fclose(file);
  
++<<<<<<< HEAD
 +	c += reserve_pecoff_reloc_section(c);
++=======
+ 	c += reserve_pecoff_compat_section(c);
++>>>>>>> fa5750521e0a (x86/boot: Drop PE/COFF .reloc section)
  
  	/* Pad unused space with zeros */
  	setup_sectors = (c + 511) / 512;
* Unmerged path arch/x86/boot/header.S
* Unmerged path arch/x86/boot/setup.ld
* Unmerged path arch/x86/boot/tools/build.c
