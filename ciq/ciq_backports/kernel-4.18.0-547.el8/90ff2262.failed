efi/x86: Don't depend on firmware GDT layout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Arvind Sankar <nivedita@alum.mit.edu>
commit 90ff226281e1083988a42cfc51f89d91734cc55e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/90ff2262.failed

When booting in mixed mode, the firmware's GDT is still installed at
handover entry in efi32_stub_entry. We save the GDTR for later use in
__efi64_thunk but we are assuming that descriptor 2 (__KERNEL_CS) is a
valid 32-bit code segment descriptor and that descriptor 3
(__KERNEL_DS/__BOOT_DS) is a valid data segment descriptor.

This happens to be true for OVMF (it actually uses descriptor 1 for data
segments, but descriptor 3 is also setup as data), but we shouldn't
depend on this being the case.

Fix this by saving the code and data selectors in addition to the GDTR
in efi32_stub_entry, and restoring them in __efi64_thunk before calling
the firmware. The UEFI specification guarantees that selectors will be
flat, so using the DS selector for all the segment registers should be
enough.

We also need to install our own GDT before initializing segment
registers in startup_32, so move the GDT load up to the beginning of the
function.

[ardb: mention mixed mode in the commit log]

	Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
Link: https://lore.kernel.org/r/20200202171353.3736319-3-nivedita@alum.mit.edu
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 90ff226281e1083988a42cfc51f89d91734cc55e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/efi_thunk_64.S
#	arch/x86/boot/compressed/head_64.S
diff --cc arch/x86/boot/compressed/efi_thunk_64.S
index 5af41b130925,2b2049259619..000000000000
--- a/arch/x86/boot/compressed/efi_thunk_64.S
+++ b/arch/x86/boot/compressed/efi_thunk_64.S
@@@ -112,11 -100,13 +121,21 @@@ ENDPROC(efi_exit32
   *
   * The stack should represent the 32-bit calling convention.
   */
++<<<<<<< HEAD
 +ENTRY(efi_enter32)
 +	movl	$__KERNEL_DS, %eax
 +	movl	%eax, %ds
 +	movl	%eax, %es
 +	movl	%eax, %ss
++=======
+ SYM_FUNC_START_LOCAL(efi_enter32)
+ 	/* Load firmware selector into data and stack segment registers */
+ 	movl	%edx, %ds
+ 	movl	%edx, %es
+ 	movl	%edx, %fs
+ 	movl	%edx, %gs
+ 	movl	%edx, %ss
++>>>>>>> 90ff226281e1 (efi/x86: Don't depend on firmware GDT layout)
  
  	/* Reload pgtables */
  	movl	%cr3, %eax
@@@ -176,16 -163,20 +195,28 @@@ ENDPROC(efi_enter32
  
  	.data
  	.balign	8
 -SYM_DATA_START(efi32_boot_gdt)
 -	.word	0
 -	.quad	0
 -SYM_DATA_END(efi32_boot_gdt)
 -
 +	.global	efi32_boot_gdt
 +efi32_boot_gdt:	.word	0
 +		.quad	0
 +
++<<<<<<< HEAD
 +save_gdt:	.word	0
 +		.quad	0
 +func_rt_ptr:	.quad	0
 +
 +	.global efi_gdt64
 +efi_gdt64:
++=======
+ SYM_DATA_START(efi32_boot_cs)
+ 	.word	0
+ SYM_DATA_END(efi32_boot_cs)
+ 
+ SYM_DATA_START(efi32_boot_ds)
+ 	.word	0
+ SYM_DATA_END(efi32_boot_ds)
+ 
+ SYM_DATA_START(efi_gdt64)
++>>>>>>> 90ff226281e1 (efi/x86: Don't depend on firmware GDT layout)
  	.word	efi_gdt64_end - efi_gdt64
  	.long	0			/* Filled out by user */
  	.word	0
diff --cc arch/x86/boot/compressed/head_64.S
index 059f9dcdd2cc,c56b30bd9c7b..000000000000
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@@ -53,19 -53,7 +53,22 @@@ SYM_FUNC_START(startup_32
  	 * all need to be under the 4G limit.
  	 */
  	cld
 +	/*
 +	 * Test KEEP_SEGMENTS flag to see if the bootloader is asking
 +	 * us to not reload segments
 +	 */
 +	testb $KEEP_SEGMENTS, BP_loadflags(%esi)
 +	jnz 1f
 +
  	cli
++<<<<<<< HEAD
 +	movl	$(__BOOT_DS), %eax
 +	movl	%eax, %ds
 +	movl	%eax, %es
 +	movl	%eax, %ss
 +1:
++=======
++>>>>>>> 90ff226281e1 (efi/x86: Don't depend on firmware GDT layout)
  
  /*
   * Calculate the delta between where we were compiled to run
@@@ -236,12 -232,14 +245,23 @@@ SYM_FUNC_START(efi32_stub_entry
  1:	pop	%ebp
  	subl	$1b, %ebp
  
++<<<<<<< HEAD
 +	movl	%ecx, efi32_config(%ebp)
 +	movl	%edx, efi32_config+8(%ebp)
 +	sgdtl	efi32_boot_gdt(%ebp)
 +
 +	leal	efi32_config(%ebp), %eax
 +	movl	%eax, efi_config(%ebp)
++=======
+ 	movl	%ecx, efi32_boot_args(%ebp)
+ 	movl	%edx, efi32_boot_args+4(%ebp)
+ 	movb	$0, efi_is64(%ebp)
++>>>>>>> 90ff226281e1 (efi/x86: Don't depend on firmware GDT layout)
+ 
+ 	/* Save firmware GDTR and code/data selectors */
+ 	sgdtl	efi32_boot_gdt(%ebp)
+ 	movw	%cs, efi32_boot_cs(%ebp)
+ 	movw	%ds, efi32_boot_ds(%ebp)
  
  	/* Disable paging */
  	movl	%cr0, %eax
* Unmerged path arch/x86/boot/compressed/efi_thunk_64.S
* Unmerged path arch/x86/boot/compressed/head_64.S
