x86/efistub: Perform SNP feature test while running in the firmware

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 31c77a50992e8dd136feed7b67073bb5f1f978cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/31c77a50.failed

Before refactoring the EFI stub boot flow to avoid the legacy bare metal
decompressor, duplicate the SNP feature check in the EFI stub before
handing over to the kernel proper.

The SNP feature check can be performed while running under the EFI boot
services, which means it can force the boot to fail gracefully and
return an error to the bootloader if the loaded kernel does not
implement support for all the features that the hypervisor enabled.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Link: https://lore.kernel.org/r/20230807162720.545787-23-ardb@kernel.org
(cherry picked from commit 31c77a50992e8dd136feed7b67073bb5f1f978cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
#	arch/x86/include/asm/sev.h
diff --cc arch/x86/boot/compressed/eboot.c
index c2a7652f4460,b4685da2b8d5..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -16,39 -15,30 +16,40 @@@
  #include <asm/setup.h>
  #include <asm/desc.h>
  #include <asm/boot.h>
+ #include <asm/sev.h>
  
 -#include "efistub.h"
 -#include "x86-stub.h"
 -
 -/* Maximum physical address for 64-bit kernel with 4-level paging */
 -#define MAXMEM_X86_64_4LEVEL (1ull << 46)
 -
 -const efi_system_table_t *efi_system_table;
 -const efi_dxe_services_table_t *efi_dxe_table;
 -u32 image_offset __section(".data");
 -static efi_loaded_image_t *image = NULL;
 -static efi_memory_attribute_protocol_t *memattr;
 -
 -typedef union sev_memory_acceptance_protocol sev_memory_acceptance_protocol_t;
 -union sev_memory_acceptance_protocol {
 -	struct {
 -		efi_status_t (__efiapi * allow_unaccepted_memory)(
 -			sev_memory_acceptance_protocol_t *);
 -	};
 -	struct {
 -		u32 allow_unaccepted_memory;
 -	} mixed_mode;
 -};
 +#include "../string.h"
 +#include "eboot.h"
 +
 +static efi_system_table_t *sys_table;
 +static const efi_dxe_services_table_t *efi_dxe_table;
 +
 +static struct efi_config *efi_early;
 +
 +__pure const struct efi_config *__efi_early(void)
 +{
 +	return efi_early;
 +}
 +
 +#define BOOT_SERVICES(bits)						\
 +static void setup_boot_services##bits(struct efi_config *c)		\
 +{									\
 +	efi_system_table_##bits##_t *table;				\
 +									\
 +	table = (typeof(table))sys_table;				\
 +									\
 +	c->runtime_services	= table->runtime;			\
 +	c->boot_services	= table->boottime;			\
 +	c->text_output		= table->con_out;			\
 +}
 +BOOT_SERVICES(32);
 +BOOT_SERVICES(64);
 +
 +void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 +{
 +	efi_call_proto(efi_simple_text_output_protocol, output_string,
 +		       efi_early->text_output, str);
 +}
  
  static efi_status_t
  preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
@@@ -840,46 -791,68 +841,95 @@@ static efi_status_t exit_boot(struct bo
  	return EFI_SUCCESS;
  }
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
++=======
+ static bool have_unsupported_snp_features(void)
+ {
+ 	u64 unsupported;
+ 
+ 	unsupported = snp_get_unsupported_features(sev_get_status());
+ 	if (unsupported) {
+ 		efi_err("Unsupported SEV-SNP features detected: 0x%llx\n",
+ 			unsupported);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ static void __noreturn enter_kernel(unsigned long kernel_addr,
+ 				    struct boot_params *boot_params)
+ {
+ 	/* enter decompressed kernel with boot_params pointer in RSI/ESI */
+ 	asm("jmp *%0"::"r"(kernel_addr), "S"(boot_params));
+ 
+ 	unreachable();
+ }
+ 
++>>>>>>> 31c77a50992e (x86/efistub: Perform SNP feature test while running in the firmware):drivers/firmware/efi/libstub/x86-stub.c
  /*
 - * On success, this routine will jump to the relocated image directly and never
 - * return.  On failure, it will exit to the firmware via efi_exit() instead of
 - * returning.
 + * On success we return a pointer to a boot_params structure, and NULL
 + * on failure.
   */
 -void __noreturn efi_stub_entry(efi_handle_t handle,
 -			       efi_system_table_t *sys_table_arg,
 -			       struct boot_params *boot_params)
 +struct boot_params *
 +efi_main(struct efi_config *c, struct boot_params *boot_params)
  {
 -	efi_guid_t guid = EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID;
  	unsigned long bzimage_addr = (unsigned long)startup_32;
 -	unsigned long buffer_start, buffer_end;
 +	struct desc_ptr *gdt = NULL;
 +	efi_loaded_image_t *image;
  	struct setup_header *hdr = &boot_params->hdr;
 -	const struct linux_efi_initrd *initrd = NULL;
  	efi_status_t status;
 +	struct desc_struct *desc;
 +	void *handle;
 +	efi_system_table_t *_table;
 +	bool is64;
 +	unsigned long cmdline_paddr;
 +
 +	efi_early = c;
 +
 +	_table = (efi_system_table_t *)(unsigned long)efi_early->table;
 +	handle = (void *)(unsigned long)efi_early->image_handle;
 +	is64 = efi_early->is64;
 +
 +	sys_table = _table;
  
 -	efi_system_table = sys_table_arg;
  	/* Check if we were booted by the EFI firmware */
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
++=======
+ 	if (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
+ 		efi_exit(handle, EFI_INVALID_PARAMETER);
+ 
+ 	if (have_unsupported_snp_features())
+ 		efi_exit(handle, EFI_UNSUPPORTED);
+ 
+ 	if (IS_ENABLED(CONFIG_EFI_DXE_MEM_ATTRIBUTES)) {
+ 		efi_dxe_table = get_efi_config_table(EFI_DXE_SERVICES_TABLE_GUID);
+ 		if (efi_dxe_table &&
+ 		    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
+ 			efi_warn("Ignoring DXE services table: invalid signature\n");
+ 			efi_dxe_table = NULL;
+ 		}
+ 	}
+ 
+ 	/* grab the memory attributes protocol if it exists */
+ 	efi_bs_call(locate_protocol, &guid, NULL, (void **)&memattr);
+ 
+ 	status = efi_setup_5level_paging();
+ 	if (status != EFI_SUCCESS) {
+ 		efi_err("efi_setup_5level_paging() failed!\n");
++>>>>>>> 31c77a50992e (x86/efistub: Perform SNP feature test while running in the firmware):drivers/firmware/efi/libstub/x86-stub.c
  		goto fail;
 +
 +	if (is64)
 +		setup_boot_services64(efi_early);
 +	else
 +		setup_boot_services32(efi_early);
 +
 +	efi_dxe_table = get_efi_config_table(sys_table, EFI_DXE_SERVICES_TABLE_GUID);
 +	if (efi_dxe_table &&
 +	    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
 +		efi_printk(sys_table, "Ignoring DXE services table: invalid signature\n");
 +		efi_dxe_table = NULL;
  	}
  
  	/*
diff --cc arch/x86/include/asm/sev.h
index 13dc2a9d23c1,b97d239e18ea..000000000000
--- a/arch/x86/include/asm/sev.h
+++ b/arch/x86/include/asm/sev.h
@@@ -202,6 -209,9 +202,12 @@@ void snp_set_wakeup_secondary_cpu(void)
  bool snp_init(struct boot_params *bp);
  void __init __noreturn snp_abort(void);
  int snp_issue_guest_request(u64 exit_code, struct snp_req_data *input, struct snp_guest_request_ioctl *rio);
++<<<<<<< HEAD
++=======
+ void snp_accept_memory(phys_addr_t start, phys_addr_t end);
+ u64 snp_get_unsupported_features(u64 status);
+ u64 sev_get_status(void);
++>>>>>>> 31c77a50992e (x86/efistub: Perform SNP feature test while running in the firmware)
  #else
  static inline void sev_es_ist_enter(struct pt_regs *regs) { }
  static inline void sev_es_ist_exit(void) { }
@@@ -225,6 -235,10 +231,13 @@@ static inline int snp_issue_guest_reque
  {
  	return -ENOTTY;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void snp_accept_memory(phys_addr_t start, phys_addr_t end) { }
+ static inline u64 snp_get_unsupported_features(u64 status) { return 0; }
+ static inline u64 sev_get_status(void) { return 0; }
++>>>>>>> 31c77a50992e (x86/efistub: Perform SNP feature test while running in the firmware)
  #endif
  
  #endif
* Unmerged path arch/x86/boot/compressed/eboot.c
diff --git a/arch/x86/boot/compressed/sev.c b/arch/x86/boot/compressed/sev.c
index 18e97f3e5e15..eae03c686e30 100644
--- a/arch/x86/boot/compressed/sev.c
+++ b/arch/x86/boot/compressed/sev.c
@@ -328,20 +328,25 @@ static void enforce_vmpl0(void)
  */
 #define SNP_FEATURES_PRESENT	MSR_AMD64_SNP_DEBUG_SWAP
 
+u64 snp_get_unsupported_features(u64 status)
+{
+	if (!(status & MSR_AMD64_SEV_SNP_ENABLED))
+		return 0;
+
+	return status & SNP_FEATURES_IMPL_REQ & ~SNP_FEATURES_PRESENT;
+}
+
 void snp_check_features(void)
 {
 	u64 unsupported;
 
-	if (!(sev_status & MSR_AMD64_SEV_SNP_ENABLED))
-		return;
-
 	/*
 	 * Terminate the boot if hypervisor has enabled any feature lacking
 	 * guest side implementation. Pass on the unsupported features mask through
 	 * EXIT_INFO_2 of the GHCB protocol so that those features can be reported
 	 * as part of the guest boot failure.
 	 */
-	unsupported = sev_status & SNP_FEATURES_IMPL_REQ & ~SNP_FEATURES_PRESENT;
+	unsupported = snp_get_unsupported_features(sev_status);
 	if (unsupported) {
 		if (ghcb_version < 2 || (!boot_ghcb && !early_setup_ghcb()))
 			sev_es_terminate(SEV_TERM_SET_GEN, GHCB_SNP_UNSUPPORTED);
@@ -351,35 +356,22 @@ void snp_check_features(void)
 	}
 }
 
-void sev_enable(struct boot_params *bp)
+/*
+ * sev_check_cpu_support - Check for SEV support in the CPU capabilities
+ *
+ * Returns < 0 if SEV is not supported, otherwise the position of the
+ * encryption bit in the page table descriptors.
+ */
+static int sev_check_cpu_support(void)
 {
 	unsigned int eax, ebx, ecx, edx;
-	struct msr m;
-	bool snp;
-
-	/*
-	 * bp->cc_blob_address should only be set by boot/compressed kernel.
-	 * Initialize it to 0 to ensure that uninitialized values from
-	 * buggy bootloaders aren't propagated.
-	 */
-	if (bp)
-		bp->cc_blob_address = 0;
-
-	/*
-	 * Do an initial SEV capability check before snp_init() which
-	 * loads the CPUID page and the same checks afterwards are done
-	 * without the hypervisor and are trustworthy.
-	 *
-	 * If the HV fakes SEV support, the guest will crash'n'burn
-	 * which is good enough.
-	 */
 
 	/* Check for the SME/SEV support leaf */
 	eax = 0x80000000;
 	ecx = 0;
 	native_cpuid(&eax, &ebx, &ecx, &edx);
 	if (eax < 0x8000001f)
-		return;
+		return -ENODEV;
 
 	/*
 	 * Check for the SME/SEV feature:
@@ -394,6 +386,35 @@ void sev_enable(struct boot_params *bp)
 	native_cpuid(&eax, &ebx, &ecx, &edx);
 	/* Check whether SEV is supported */
 	if (!(eax & BIT(1)))
+		return -ENODEV;
+
+	return ebx & 0x3f;
+}
+
+void sev_enable(struct boot_params *bp)
+{
+	struct msr m;
+	int bitpos;
+	bool snp;
+
+	/*
+	 * bp->cc_blob_address should only be set by boot/compressed kernel.
+	 * Initialize it to 0 to ensure that uninitialized values from
+	 * buggy bootloaders aren't propagated.
+	 */
+	if (bp)
+		bp->cc_blob_address = 0;
+
+	/*
+	 * Do an initial SEV capability check before snp_init() which
+	 * loads the CPUID page and the same checks afterwards are done
+	 * without the hypervisor and are trustworthy.
+	 *
+	 * If the HV fakes SEV support, the guest will crash'n'burn
+	 * which is good enough.
+	 */
+
+	if (sev_check_cpu_support() < 0)
 		return;
 
 	/*
@@ -404,26 +425,8 @@ void sev_enable(struct boot_params *bp)
 
 	/* Now repeat the checks with the SNP CPUID table. */
 
-	/* Recheck the SME/SEV support leaf */
-	eax = 0x80000000;
-	ecx = 0;
-	native_cpuid(&eax, &ebx, &ecx, &edx);
-	if (eax < 0x8000001f)
-		return;
-
-	/*
-	 * Recheck for the SME/SEV feature:
-	 *   CPUID Fn8000_001F[EAX]
-	 *   - Bit 0 - Secure Memory Encryption support
-	 *   - Bit 1 - Secure Encrypted Virtualization support
-	 *   CPUID Fn8000_001F[EBX]
-	 *   - Bits 5:0 - Pagetable bit position used to indicate encryption
-	 */
-	eax = 0x8000001f;
-	ecx = 0;
-	native_cpuid(&eax, &ebx, &ecx, &edx);
-	/* Check whether SEV is supported */
-	if (!(eax & BIT(1))) {
+	bitpos = sev_check_cpu_support();
+	if (bitpos < 0) {
 		if (snp)
 			error("SEV-SNP support indicated by CC blob, but not CPUID.");
 		return;
@@ -455,7 +458,24 @@ void sev_enable(struct boot_params *bp)
 	if (snp && !(sev_status & MSR_AMD64_SEV_SNP_ENABLED))
 		error("SEV-SNP supported indicated by CC blob, but not SEV status MSR.");
 
-	sme_me_mask = BIT_ULL(ebx & 0x3f);
+	sme_me_mask = BIT_ULL(bitpos);
+}
+
+/*
+ * sev_get_status - Retrieve the SEV status mask
+ *
+ * Returns 0 if the CPU is not SEV capable, otherwise the value of the
+ * AMD64_SEV MSR.
+ */
+u64 sev_get_status(void)
+{
+	struct msr m;
+
+	if (sev_check_cpu_support() < 0)
+		return 0;
+
+	boot_rdmsr(MSR_AMD64_SEV, &m);
+	return m.q;
 }
 
 /* Search for Confidential Computing blob in the EFI config table. */
* Unmerged path arch/x86/include/asm/sev.h
