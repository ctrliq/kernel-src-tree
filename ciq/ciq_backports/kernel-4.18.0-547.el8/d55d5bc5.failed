x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit d55d5bc5d937743aa8ebb7ca3af25111053b5d8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/d55d5bc5.failed

The x86 decompressor is built and linked as a separate executable, but
it shares components with the kernel proper, which are either #include'd
as C files, or linked into the decompresor as a static library (e.g, the
EFI stub)

Both the kernel itself and the decompressor define a global symbol
'boot_params' to refer to the boot_params struct, but in the former
case, it refers to the struct directly, whereas in the decompressor, it
refers to a global pointer variable referring to the struct boot_params
passed by the bootloader or constructed from scratch.

This ambiguity is unfortunate, and makes it impossible to assign this
decompressor variable from the x86 EFI stub, given that declaring it as
extern results in a clash. So rename the decompressor version (whose
scope is limited) to boot_params_ptr.

[ mingo: Renamed 'boot_params_p' to 'boot_params_ptr' for clarity ]

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Cc: linux-kernel@vger.kernel.org
(cherry picked from commit d55d5bc5d937743aa8ebb7ca3af25111053b5d8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/acpi.c
#	arch/x86/boot/compressed/mem.c
#	arch/x86/boot/compressed/misc.h
#	arch/x86/boot/compressed/pgtable_64.c
#	arch/x86/include/asm/boot.h
diff --cc arch/x86/boot/compressed/acpi.c
index a34b9e2becc8,55c98fdd67d2..000000000000
--- a/arch/x86/boot/compressed/acpi.c
+++ b/arch/x86/boot/compressed/acpi.c
@@@ -180,10 -156,7 +180,14 @@@ acpi_physical_address get_rsdp_addr(voi
  {
  	acpi_physical_address pa;
  
++<<<<<<< HEAD
 +	pa = get_acpi_rsdp();
 +
 +	if (!pa)
 +		pa = boot_params->acpi_rsdp_addr;
++=======
+ 	pa = boot_params_ptr->acpi_rsdp_addr;
++>>>>>>> d55d5bc5d937 (x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr')
  
  	if (!pa)
  		pa = efi_get_rsdp_addr();
@@@ -205,7 -202,16 +209,20 @@@ static unsigned long get_acpi_srat_tabl
  	char arg[10];
  	u8 *entry;
  
++<<<<<<< HEAD
 +	rsdp = (struct acpi_table_rsdp *)(long)boot_params->acpi_rsdp_addr;
++=======
+ 	/*
+ 	 * Check whether we were given an RSDP on the command line. We don't
+ 	 * stash this in boot params because the kernel itself may have
+ 	 * different ideas about whether to trust a command-line parameter.
+ 	 */
+ 	rsdp = (struct acpi_table_rsdp *)get_cmdline_acpi_rsdp();
+ 	if (!rsdp)
+ 		rsdp = (struct acpi_table_rsdp *)(long)
+ 			boot_params_ptr->acpi_rsdp_addr;
+ 
++>>>>>>> d55d5bc5d937 (x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr')
  	if (!rsdp)
  		return 0;
  
diff --cc arch/x86/boot/compressed/misc.h
index d2acd22fc568,c0d502bd8716..000000000000
--- a/arch/x86/boot/compressed/misc.h
+++ b/arch/x86/boot/compressed/misc.h
@@@ -50,7 -59,8 +50,12 @@@ extern char _head[], _end[]
  /* misc.c */
  extern memptr free_mem_ptr;
  extern memptr free_mem_end_ptr;
++<<<<<<< HEAD
 +extern struct boot_params *boot_params;
++=======
+ void *malloc(int size);
+ void free(void *where);
++>>>>>>> d55d5bc5d937 (x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr')
  void __putstr(const char *s);
  void __puthex(unsigned long value);
  #define error_putstr(__x)  __putstr(__x)
diff --cc arch/x86/boot/compressed/pgtable_64.c
index af8b429eafb0,51f957b24ba7..000000000000
--- a/arch/x86/boot/compressed/pgtable_64.c
+++ b/arch/x86/boot/compressed/pgtable_64.c
@@@ -38,11 -24,10 +38,10 @@@ static char trampoline_save[TRAMPOLINE_
   * purposes.
   *
   * Avoid putting the pointer into .bss as it will be cleared between
 - * configure_5level_paging() and extract_kernel().
 + * paging_prepare() and extract_kernel().
   */
 -unsigned long *trampoline_32bit __section(".data");
 +unsigned long *trampoline_32bit __section(.data);
  
- extern struct boot_params *boot_params;
  int cmdline_find_option_bool(const char *option);
  
  static unsigned long find_trampoline_placement(void)
@@@ -57,8 -42,18 +56,23 @@@
  	 * This code is based on reserve_bios_regions().
  	 */
  
++<<<<<<< HEAD
 +	ebda_start = *(unsigned short *)0x40e << 4;
 +	bios_start = *(unsigned short *)0x413 << 10;
++=======
+ 	/*
+ 	 * EFI systems may not provide legacy ROM. The memory may not be mapped
+ 	 * at all.
+ 	 *
+ 	 * Only look for values in the legacy ROM for non-EFI system.
+ 	 */
+ 	signature = (char *)&boot_params_ptr->efi_info.efi_loader_signature;
+ 	if (strncmp(signature, EFI32_LOADER_SIGNATURE, 4) &&
+ 	    strncmp(signature, EFI64_LOADER_SIGNATURE, 4)) {
+ 		ebda_start = *(unsigned short *)0x40e << 4;
+ 		bios_start = *(unsigned short *)0x413 << 10;
+ 	}
++>>>>>>> d55d5bc5d937 (x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr')
  
  	if (bios_start < BIOS_START_MIN || bios_start > BIOS_START_MAX)
  		bios_start = BIOS_START_MAX;
@@@ -105,12 -100,13 +119,16 @@@
  	return bios_start - TRAMPOLINE_32BIT_SIZE;
  }
  
 -asmlinkage void configure_5level_paging(struct boot_params *bp, void *pgtable)
 +struct paging_config paging_prepare(void *rmode)
  {
 -	void (*toggle_la57)(void *cr3);
 -	bool l5_required = false;
 +	struct paging_config paging_config = {};
  
  	/* Initialize boot_params. Required for cmdline_find_option_bool(). */
++<<<<<<< HEAD
 +	boot_params = rmode;
++=======
+ 	boot_params_ptr = bp;
++>>>>>>> d55d5bc5d937 (x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr')
  
  	/*
  	 * Check if LA57 is desired and supported.
diff --cc arch/x86/include/asm/boot.h
index 680c320363db,74d5a1723d2d..000000000000
--- a/arch/x86/include/asm/boot.h
+++ b/arch/x86/include/asm/boot.h
@@@ -55,4 -62,14 +55,17 @@@
  # define BOOT_STACK_SIZE	0x1000
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifndef __ASSEMBLY__
+ extern unsigned int output_len;
+ extern const unsigned long kernel_total_size;
+ 
+ unsigned long decompress_kernel(unsigned char *outbuf, unsigned long virt_addr,
+ 				void (*error)(char *x));
+ 
+ extern struct boot_params *boot_params_ptr;
+ #endif
+ 
++>>>>>>> d55d5bc5d937 (x86/boot: Rename conflicting 'boot_params' pointer to 'boot_params_ptr')
  #endif /* _ASM_X86_BOOT_H */
* Unmerged path arch/x86/boot/compressed/mem.c
* Unmerged path arch/x86/boot/compressed/acpi.c
diff --git a/arch/x86/boot/compressed/cmdline.c b/arch/x86/boot/compressed/cmdline.c
index f1add5d85da9..c1bb180973ea 100644
--- a/arch/x86/boot/compressed/cmdline.c
+++ b/arch/x86/boot/compressed/cmdline.c
@@ -14,9 +14,9 @@ static inline char rdfs8(addr_t addr)
 #include "../cmdline.c"
 unsigned long get_cmd_line_ptr(void)
 {
-	unsigned long cmd_line_ptr = boot_params->hdr.cmd_line_ptr;
+	unsigned long cmd_line_ptr = boot_params_ptr->hdr.cmd_line_ptr;
 
-	cmd_line_ptr |= (u64)boot_params->ext_cmd_line_ptr << 32;
+	cmd_line_ptr |= (u64)boot_params_ptr->ext_cmd_line_ptr << 32;
 
 	return cmd_line_ptr;
 }
diff --git a/arch/x86/boot/compressed/ident_map_64.c b/arch/x86/boot/compressed/ident_map_64.c
index 3f39bdfe0345..8181431d629e 100644
--- a/arch/x86/boot/compressed/ident_map_64.c
+++ b/arch/x86/boot/compressed/ident_map_64.c
@@ -159,8 +159,9 @@ void initialize_identity_maps(void *rmode)
 	 * or does not touch all the pages covering them.
 	 */
 	kernel_add_identity_map((unsigned long)_head, (unsigned long)_end);
-	boot_params = rmode;
-	kernel_add_identity_map((unsigned long)boot_params, (unsigned long)(boot_params + 1));
+	boot_params_ptr = rmode;
+	kernel_add_identity_map((unsigned long)boot_params_ptr,
+				(unsigned long)(boot_params_ptr + 1));
 	cmdline = get_cmd_line_ptr();
 	kernel_add_identity_map(cmdline, cmdline + COMMAND_LINE_SIZE);
 
@@ -168,7 +169,7 @@ void initialize_identity_maps(void *rmode)
 	 * Also map the setup_data entries passed via boot_params in case they
 	 * need to be accessed by uncompressed kernel via the identity mapping.
 	 */
-	sd = (struct setup_data *)boot_params->hdr.setup_data;
+	sd = (struct setup_data *)boot_params_ptr->hdr.setup_data;
 	while (sd) {
 		unsigned long sd_addr = (unsigned long)sd;
 
diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c
index 02947edb6dc9..c30aada8a4bf 100644
--- a/arch/x86/boot/compressed/kaslr.c
+++ b/arch/x86/boot/compressed/kaslr.c
@@ -72,7 +72,7 @@ static unsigned long get_boot_seed(void)
 	unsigned long hash = 0;
 
 	hash = rotate_xor(hash, build_str, sizeof(build_str));
-	hash = rotate_xor(hash, boot_params, sizeof(*boot_params));
+	hash = rotate_xor(hash, boot_params_ptr, sizeof(*boot_params_ptr));
 
 	return hash;
 }
@@ -362,7 +362,7 @@ static void handle_mem_options(void)
 static void mem_avoid_init(unsigned long input, unsigned long input_size,
 			   unsigned long output)
 {
-	unsigned long init_size = boot_params->hdr.init_size;
+	unsigned long init_size = boot_params_ptr->hdr.init_size;
 	u64 initrd_start, initrd_size;
 	u64 cmd_line, cmd_line_size;
 	char *ptr;
@@ -375,10 +375,10 @@ static void mem_avoid_init(unsigned long input, unsigned long input_size,
 	mem_avoid[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;
 
 	/* Avoid initrd. */
-	initrd_start  = (u64)boot_params->ext_ramdisk_image << 32;
-	initrd_start |= boot_params->hdr.ramdisk_image;
-	initrd_size  = (u64)boot_params->ext_ramdisk_size << 32;
-	initrd_size |= boot_params->hdr.ramdisk_size;
+	initrd_start  = (u64)boot_params_ptr->ext_ramdisk_image << 32;
+	initrd_start |= boot_params_ptr->hdr.ramdisk_image;
+	initrd_size  = (u64)boot_params_ptr->ext_ramdisk_size << 32;
+	initrd_size |= boot_params_ptr->hdr.ramdisk_size;
 	mem_avoid[MEM_AVOID_INITRD].start = initrd_start;
 	mem_avoid[MEM_AVOID_INITRD].size = initrd_size;
 	/* No need to set mapping for initrd, it will be handled in VO. */
@@ -394,8 +394,8 @@ static void mem_avoid_init(unsigned long input, unsigned long input_size,
 	mem_avoid[MEM_AVOID_CMDLINE].size = cmd_line_size;
 
 	/* Avoid boot parameters. */
-	mem_avoid[MEM_AVOID_BOOTPARAMS].start = (unsigned long)boot_params;
-	mem_avoid[MEM_AVOID_BOOTPARAMS].size = sizeof(*boot_params);
+	mem_avoid[MEM_AVOID_BOOTPARAMS].start = (unsigned long)boot_params_ptr;
+	mem_avoid[MEM_AVOID_BOOTPARAMS].size = sizeof(*boot_params_ptr);
 
 	/* We don't need to set a mapping for setup_data. */
 
@@ -428,7 +428,7 @@ static bool mem_avoid_overlap(struct mem_vector *img,
 	}
 
 	/* Avoid all entries in the setup_data linked list. */
-	ptr = (struct setup_data *)(unsigned long)boot_params->hdr.setup_data;
+	ptr = (struct setup_data *)(unsigned long)boot_params_ptr->hdr.setup_data;
 	while (ptr) {
 		struct mem_vector avoid;
 
@@ -691,7 +691,7 @@ static bool process_mem_region(struct mem_vector *region,
 static bool
 process_efi_entries(unsigned long minimum, unsigned long image_size)
 {
-	struct efi_info *e = &boot_params->efi_info;
+	struct efi_info *e = &boot_params_ptr->efi_info;
 	bool efi_mirror_found = false;
 	struct mem_vector region;
 	efi_memory_desc_t *md;
@@ -773,8 +773,8 @@ static void process_e820_entries(unsigned long minimum,
 	struct boot_e820_entry *entry;
 
 	/* Verify potential e820 positions, appending to slots list. */
-	for (i = 0; i < boot_params->e820_entries; i++) {
-		entry = &boot_params->e820_table[i];
+	for (i = 0; i < boot_params_ptr->e820_entries; i++) {
+		entry = &boot_params_ptr->e820_table[i];
 		/* Skip non-RAM entries. */
 		if (entry->type != E820_TYPE_RAM)
 			continue;
@@ -844,7 +844,7 @@ void choose_random_location(unsigned long input,
 		return;
 	}
 
-	boot_params->hdr.loadflags |= KASLR_FLAG;
+	boot_params_ptr->hdr.loadflags |= KASLR_FLAG;
 
 	/* Record the various known unsafe memory ranges. */
 	mem_avoid_init(input, input_size, *output);
* Unmerged path arch/x86/boot/compressed/mem.c
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index 013afaeba37d..0e62c12e1d5f 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -45,7 +45,7 @@ void *memmove(void *dest, const void *src, size_t n);
 /*
  * This is set up by the setup-routine at boot-time
  */
-struct boot_params *boot_params;
+struct boot_params *boot_params_ptr;
 
 struct port_io_ops pio_ops;
 
@@ -127,8 +127,8 @@ void __putstr(const char *s)
 	if (lines == 0 || cols == 0)
 		return;
 
-	x = boot_params->screen_info.orig_x;
-	y = boot_params->screen_info.orig_y;
+	x = boot_params_ptr->screen_info.orig_x;
+	y = boot_params_ptr->screen_info.orig_y;
 
 	while ((c = *s++) != '\0') {
 		if (c == '\n') {
@@ -149,8 +149,8 @@ void __putstr(const char *s)
 		}
 	}
 
-	boot_params->screen_info.orig_x = x;
-	boot_params->screen_info.orig_y = y;
+	boot_params_ptr->screen_info.orig_x = x;
+	boot_params_ptr->screen_info.orig_y = y;
 
 	pos = (x + cols * y) * 2;	/* Update cursor position */
 	outb(14, vidport);
@@ -353,14 +353,14 @@ asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,
 	unsigned long needed_size;
 
 	/* Retain x86 boot parameters pointer passed from startup_32/64. */
-	boot_params = rmode;
+	boot_params_ptr = rmode;
 
 	/* Clear flags intended for solely in-kernel use. */
-	boot_params->hdr.loadflags &= ~KASLR_FLAG;
+	boot_params_ptr->hdr.loadflags &= ~KASLR_FLAG;
 
-	sanitize_boot_params(boot_params);
+	sanitize_boot_params(boot_params_ptr);
 
-	if (boot_params->screen_info.orig_video_mode == 7) {
+	if (boot_params_ptr->screen_info.orig_video_mode == 7) {
 		vidmem = (char *) 0xb0000;
 		vidport = 0x3b4;
 	} else {
@@ -368,8 +368,8 @@ asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,
 		vidport = 0x3d4;
 	}
 
-	lines = boot_params->screen_info.orig_video_lines;
-	cols = boot_params->screen_info.orig_video_cols;
+	lines = boot_params_ptr->screen_info.orig_video_lines;
+	cols = boot_params_ptr->screen_info.orig_video_cols;
 
 	init_default_io_ops();
 
@@ -388,7 +388,7 @@ asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,
 	 * so that early debugging output from the RSDP parsing code can be
 	 * collected.
 	 */
-	boot_params->acpi_rsdp_addr = get_rsdp_addr();
+	boot_params_ptr->acpi_rsdp_addr = get_rsdp_addr();
 
 	debug_putstr("early console in extract_kernel\n");
 
* Unmerged path arch/x86/boot/compressed/misc.h
* Unmerged path arch/x86/boot/compressed/pgtable_64.c
diff --git a/arch/x86/boot/compressed/sev.c b/arch/x86/boot/compressed/sev.c
index 18e97f3e5e15..215499bb8c32 100644
--- a/arch/x86/boot/compressed/sev.c
+++ b/arch/x86/boot/compressed/sev.c
@@ -546,7 +546,7 @@ void sev_prep_identity_maps(unsigned long top_level_pgt)
 	 * accessed after switchover.
 	 */
 	if (sev_snp_enabled()) {
-		unsigned long cc_info_pa = boot_params->cc_blob_address;
+		unsigned long cc_info_pa = boot_params_ptr->cc_blob_address;
 		struct cc_blob_sev_info *cc_info;
 
 		kernel_add_identity_map(cc_info_pa, cc_info_pa + sizeof(*cc_info));
* Unmerged path arch/x86/include/asm/boot.h
