efi/libstub/x86: Use mandatory 16-byte stack alignment in mixed mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit ac3c76cc6d6deef573dd8c14232f20c6aa744f83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/ac3c76cc.failed

Reduce the stack frame of the EFI stub's mixed mode thunk routine by
8 bytes, by moving the GDT and return addresses to EBP and EBX, which
we need to preserve anyway, since their top halves will be cleared by
the call into 32-bit firmware code. Doing so results in the UEFI code
being entered with a 16 byte aligned stack, as mandated by the UEFI
spec, fixing the last occurrence in the 64-bit kernel where we violate
this requirement.

Also, move the saved GDT from a global variable to an unused part of the
stack frame, and touch up some other parts of the code.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20200113172245.27925-3-ardb@kernel.org
(cherry picked from commit ac3c76cc6d6deef573dd8c14232f20c6aa744f83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/efi_thunk_64.S
diff --cc arch/x86/boot/compressed/efi_thunk_64.S
index 5af41b130925,8fb7f6799c52..000000000000
--- a/arch/x86/boot/compressed/efi_thunk_64.S
+++ b/arch/x86/boot/compressed/efi_thunk_64.S
@@@ -27,12 -27,9 +27,18 @@@ SYM_FUNC_START(efi64_thunk
  	push	%rbp
  	push	%rbx
  
++<<<<<<< HEAD
 +	subq	$8, %rsp
 +	leaq	efi_exit32(%rip), %rax
 +	movl	%eax, 4(%rsp)
 +	leaq	efi_gdt64(%rip), %rax
 +	movl	%eax, (%rsp)
 +	movl	%eax, 2(%rax)		/* Fixup the gdt base address */
++=======
+ 	leaq	1f(%rip), %rbp
+ 	leaq	efi_gdt64(%rip), %rbx
+ 	movl	%ebx, 2(%rbx)		/* Fixup the gdt base address */
++>>>>>>> ac3c76cc6d6d (efi/libstub/x86: Use mandatory 16-byte stack alignment in mixed mode)
  
  	movl	%ds, %eax
  	push	%rax
@@@ -48,16 -45,11 +54,14 @@@
  	movl	%esi, 0x0(%rsp)
  	movl	%edx, 0x4(%rsp)
  	movl	%ecx, 0x8(%rsp)
- 	movq	%r8, %rsi
- 	movl	%esi, 0xc(%rsp)
- 	movq	%r9, %rsi
- 	movl	%esi,  0x10(%rsp)
+ 	movl	%r8d, 0xc(%rsp)
+ 	movl	%r9d, 0x10(%rsp)
  
- 	sgdt	save_gdt(%rip)
+ 	sgdt	0x14(%rsp)
  
 +	leaq	1f(%rip), %rbx
 +	movq	%rbx, func_rt_ptr(%rip)
 +
  	/*
  	 * Switch to gdt with 32-bit segments. This is the firmware GDT
  	 * that was installed when the kernel started executing. This
@@@ -71,9 -63,9 +75,13 @@@
  	pushq	%rax
  	lretq
  
++<<<<<<< HEAD
 +1:	addq	$32, %rsp
- 
- 	lgdt	save_gdt(%rip)
++=======
+ 1:	lgdt	0x14(%rsp)
+ 	addq	$32, %rsp
+ 	movq	%rdi, %rax
++>>>>>>> ac3c76cc6d6d (efi/libstub/x86: Use mandatory 16-byte stack alignment in mixed mode)
  
  	pop	%rbx
  	movl	%ebx, %ss
@@@ -176,16 -152,12 +175,20 @@@ ENDPROC(efi_enter32
  
  	.data
  	.balign	8
 -SYM_DATA_START(efi32_boot_gdt)
 -	.word	0
 -	.quad	0
 -SYM_DATA_END(efi32_boot_gdt)
 -
 +	.global	efi32_boot_gdt
 +efi32_boot_gdt:	.word	0
 +		.quad	0
 +
++<<<<<<< HEAD
 +save_gdt:	.word	0
 +		.quad	0
 +func_rt_ptr:	.quad	0
 +
 +	.global efi_gdt64
 +efi_gdt64:
++=======
+ SYM_DATA_START(efi_gdt64)
++>>>>>>> ac3c76cc6d6d (efi/libstub/x86: Use mandatory 16-byte stack alignment in mixed mode)
  	.word	efi_gdt64_end - efi_gdt64
  	.long	0			/* Filled out by user */
  	.word	0
* Unmerged path arch/x86/boot/compressed/efi_thunk_64.S
