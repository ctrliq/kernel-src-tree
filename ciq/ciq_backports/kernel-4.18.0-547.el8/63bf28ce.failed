efi: x86: Wipe setup_data on pure EFI boot

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 63bf28ceb3ebbe76048c3fb2987996ca1ae64f83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/63bf28ce.failed

When booting the x86 kernel via EFI using the LoadImage/StartImage boot
services [as opposed to the deprecated EFI handover protocol], the setup
header is taken from the image directly, and given that EFI's LoadImage
has no Linux/x86 specific knowledge regarding struct bootparams or
struct setup_header, any absolute addresses in the setup header must
originate from the file and not from a prior loading stage.

Since we cannot generally predict where LoadImage() decides to load an
image (*), such absolute addresses must be treated as suspect: even if a
prior boot stage intended to make them point somewhere inside the
[signed] image, there is no way to validate that, and if they point at
an arbitrary location in memory, the setup_data nodes will not be
covered by any signatures or TPM measurements either, and could be made
to contain an arbitrary sequence of SETUP_xxx nodes, which could
interfere quite badly with the early x86 boot sequence.

(*) Note that, while LoadImage() does take a buffer/size tuple in
addition to a device path, which can be used to provide the image
contents directly, it will re-allocate such images, as the memory
footprint of an image is generally larger than the PE/COFF file
representation.

	Cc: <stable@vger.kernel.org> # v5.10+
Link: https://lore.kernel.org/all/20220904165321.1140894-1-Jason@zx2c4.com/
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Acked-by: Jason A. Donenfeld <Jason@zx2c4.com>
(cherry picked from commit 63bf28ceb3ebbe76048c3fb2987996ca1ae64f83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index 19db743a88f9,7a7abc8959d2..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -548,42 -516,20 +548,54 @@@ struct boot_params *make_boot_params(st
  	hdr->ramdisk_image = 0;
  	hdr->ramdisk_size = 0;
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	/* Clear APM BIOS info */
 +	memset(bi, 0, sizeof(*bi));
++=======
+ 	/*
+ 	 * Disregard any setup data that was provided by the bootloader:
+ 	 * setup_data could be pointing anywhere, and we have no way of
+ 	 * authenticating or validating the payload.
+ 	 */
+ 	hdr->setup_data = 0;
+ 
+ 	efi_stub_entry(handle, sys_table_arg, boot_params);
+ 	/* not reached */
++>>>>>>> 63bf28ceb3eb (efi: x86: Wipe setup_data on pure EFI boot):drivers/firmware/efi/libstub/x86-stub.c
 +
 +	status = efi_parse_options(cmdline_ptr);
 +	if (status != EFI_SUCCESS)
 +		goto fail2;
 +
 +	status = handle_cmdline_files(sys_table, image,
 +				      (char *)(unsigned long)hdr->cmd_line_ptr,
 +				      "initrd=", hdr->initrd_addr_max,
 +				      &ramdisk_addr, &ramdisk_size);
 +
 +	if (status != EFI_SUCCESS &&
 +	    hdr->xloadflags & XLF_CAN_BE_LOADED_ABOVE_4G) {
 +		efi_printk(sys_table, "Trying to load files to higher address\n");
 +		status = handle_cmdline_files(sys_table, image,
 +				      (char *)(unsigned long)hdr->cmd_line_ptr,
 +				      "initrd=", -1UL,
 +				      &ramdisk_addr, &ramdisk_size);
 +	}
 +
 +	if (status != EFI_SUCCESS)
 +		goto fail2;
 +	hdr->ramdisk_image = ramdisk_addr & 0xffffffff;
 +	hdr->ramdisk_size  = ramdisk_size & 0xffffffff;
 +	boot_params->ext_ramdisk_image = (u64)ramdisk_addr >> 32;
 +	boot_params->ext_ramdisk_size  = (u64)ramdisk_size >> 32;
  
 +	return boot_params;
 +
 +fail2:
 +	efi_free(sys_table, options_size, hdr->cmd_line_ptr);
  fail:
 -	efi_free(sizeof(struct boot_params), (unsigned long)boot_params);
 +	efi_free(sys_table, 0x4000, (unsigned long)boot_params);
  
 -	efi_exit(handle, status);
 +	return NULL;
  }
  
  static void add_e820ext(struct boot_params *params,
* Unmerged path arch/x86/boot/compressed/eboot.c
