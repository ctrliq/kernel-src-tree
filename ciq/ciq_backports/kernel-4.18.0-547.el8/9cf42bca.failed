efi: libstub: use EFI_LOADER_CODE region when moving the kernel in memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 9cf42bca30e98a1c6c9e8abf876940a551eaa3d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/9cf42bca.failed

The EFI spec is not very clear about which permissions are being given
when allocating pages of a certain type. However, it is quite obvious
that EFI_LOADER_CODE is more likely to permit execution than
EFI_LOADER_DATA, which becomes relevant once we permit booting the
kernel proper with the firmware's 1:1 mapping still active.

Ostensibly, recent systems such as the Surface Pro X grant executable
permissions to EFI_LOADER_CODE regions but not EFI_LOADER_DATA regions.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 9cf42bca30e98a1c6c9e8abf876940a551eaa3d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/libstub/alignedmem.c
#	drivers/firmware/efi/libstub/arm64-stub.c
#	drivers/firmware/efi/libstub/efistub.h
#	drivers/firmware/efi/libstub/mem.c
#	drivers/firmware/efi/libstub/randomalloc.c
diff --cc drivers/firmware/efi/libstub/arm64-stub.c
index 80927ef51bdc,7f0aab3a8ab3..000000000000
--- a/drivers/firmware/efi/libstub/arm64-stub.c
+++ b/drivers/firmware/efi/libstub/arm64-stub.c
@@@ -110,43 -101,34 +110,69 @@@ efi_status_t handle_kernel_image(efi_sy
  		 * If KASLR is enabled, and we have some randomness available,
  		 * locate the kernel at a randomized offset in physical memory.
  		 */
++<<<<<<< HEAD
 +		*reserve_size = kernel_memsize + offset;
 +		status = efi_random_alloc(sys_table_arg, *reserve_size,
 +					  MIN_KIMG_ALIGN, reserve_addr,
 +					  (u32)phys_seed);
 +
 +		*image_addr = *reserve_addr + offset;
++=======
+ 		status = efi_random_alloc(*reserve_size, min_kimg_align,
+ 					  reserve_addr, phys_seed,
+ 					  EFI_LOADER_CODE);
+ 		if (status != EFI_SUCCESS)
+ 			efi_warn("efi_random_alloc() failed: 0x%lx\n", status);
++>>>>>>> 9cf42bca30e9 (efi: libstub: use EFI_LOADER_CODE region when moving the kernel in memory)
  	} else {
 -		status = EFI_OUT_OF_RESOURCES;
 +		/*
 +		 * Else, try a straight allocation at the preferred offset.
 +		 * This will work around the issue where, if dram_base == 0x0,
 +		 * efi_low_alloc() refuses to allocate at 0x0 (to prevent the
 +		 * address of the allocation to be mistaken for a FAIL return
 +		 * value or a NULL pointer). It will also ensure that, on
 +		 * platforms where the [dram_base, dram_base + TEXT_OFFSET)
 +		 * interval is partially occupied by the firmware (like on APM
 +		 * Mustang), we can still place the kernel at the address
 +		 * 'dram_base + TEXT_OFFSET'.
 +		 */
 +		if (*image_addr == preferred_offset)
 +			return EFI_SUCCESS;
 +
 +		*image_addr = *reserve_addr = preferred_offset;
 +		*reserve_size = round_up(kernel_memsize, EFI_ALLOC_ALIGN);
 +
 +		status = efi_call_early(allocate_pages, EFI_ALLOCATE_ADDRESS,
 +					EFI_LOADER_DATA,
 +					*reserve_size / EFI_PAGE_SIZE,
 +					(efi_physical_addr_t *)reserve_addr);
  	}
  
  	if (status != EFI_SUCCESS) {
++<<<<<<< HEAD
 +		*reserve_size = kernel_memsize + TEXT_OFFSET;
 +		status = efi_low_alloc(sys_table_arg, *reserve_size,
 +				       MIN_KIMG_ALIGN, reserve_addr);
++=======
+ 		if (!check_image_region((u64)_text, kernel_memsize)) {
+ 			efi_err("FIRMWARE BUG: Image BSS overlaps adjacent EFI memory region\n");
+ 		} else if (IS_ALIGNED((u64)_text, min_kimg_align)) {
+ 			/*
+ 			 * Just execute from wherever we were loaded by the
+ 			 * UEFI PE/COFF loader if the alignment is suitable.
+ 			 */
+ 			*image_addr = (u64)_text;
+ 			*reserve_size = 0;
+ 			goto clean_image_to_poc;
+ 		}
+ 
+ 		status = efi_allocate_pages_aligned(*reserve_size, reserve_addr,
+ 						    ULONG_MAX, min_kimg_align,
+ 						    EFI_LOADER_CODE);
++>>>>>>> 9cf42bca30e9 (efi: libstub: use EFI_LOADER_CODE region when moving the kernel in memory)
  
  		if (status != EFI_SUCCESS) {
 -			efi_err("Failed to relocate kernel\n");
 +			pr_efi_err(sys_table_arg, "Failed to relocate kernel\n");
  			*reserve_size = 0;
  			return status;
  		}
diff --cc drivers/firmware/efi/libstub/efistub.h
index 386522b5d9b5,e85916ed5311..000000000000
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@@ -55,15 -877,147 +55,158 @@@ void efi_get_virtmap(efi_memory_desc_t 
  		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
  		     int *count);
  
 -efi_status_t efi_get_random_bytes(unsigned long size, u8 *out);
 +efi_status_t efi_get_random_bytes(efi_system_table_t *sys_table,
 +				  unsigned long size, u8 *out);
  
++<<<<<<< HEAD
 +efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
 +			      unsigned long size, unsigned long align,
 +			      unsigned long *addr, unsigned long random_seed);
++=======
+ efi_status_t efi_random_alloc(unsigned long size, unsigned long align,
+ 			      unsigned long *addr, unsigned long random_seed,
+ 			      int memory_type);
++>>>>>>> 9cf42bca30e9 (efi: libstub: use EFI_LOADER_CODE region when moving the kernel in memory)
  
 -efi_status_t check_platform_features(void);
 +efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
  
++<<<<<<< HEAD
 +void *get_efi_config_table(efi_system_table_t *sys_table, efi_guid_t guid);
++=======
+ void *get_efi_config_table(efi_guid_t guid);
+ 
+ /* NOTE: These functions do not print a trailing newline after the string */
+ void efi_char16_puts(efi_char16_t *);
+ void efi_puts(const char *str);
+ 
+ __printf(1, 2) int efi_printk(char const *fmt, ...);
+ 
+ void efi_free(unsigned long size, unsigned long addr);
+ 
+ void efi_apply_loadoptions_quirk(const void **load_options, u32 *load_options_size);
+ 
+ char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
+ 
+ efi_status_t efi_get_memory_map(struct efi_boot_memmap **map,
+ 				bool install_cfg_tbl);
+ 
+ efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
+ 				unsigned long max);
+ 
+ efi_status_t efi_allocate_pages_aligned(unsigned long size, unsigned long *addr,
+ 					unsigned long max, unsigned long align,
+ 					int memory_type);
+ 
+ efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
+ 				 unsigned long *addr, unsigned long min);
+ 
+ efi_status_t efi_relocate_kernel(unsigned long *image_addr,
+ 				 unsigned long image_size,
+ 				 unsigned long alloc_size,
+ 				 unsigned long preferred_addr,
+ 				 unsigned long alignment,
+ 				 unsigned long min_addr);
+ 
+ efi_status_t efi_parse_options(char const *cmdline);
+ 
+ void efi_parse_option_graphics(char *option);
+ 
+ efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
+ 			   unsigned long size);
+ 
+ efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
+ 				  const efi_char16_t *optstr,
+ 				  int optstr_size,
+ 				  unsigned long soft_limit,
+ 				  unsigned long hard_limit,
+ 				  unsigned long *load_addr,
+ 				  unsigned long *load_size);
+ 
+ 
+ static inline efi_status_t efi_load_dtb(efi_loaded_image_t *image,
+ 					unsigned long *load_addr,
+ 					unsigned long *load_size)
+ {
+ 	return handle_cmdline_files(image, L"dtb=", sizeof(L"dtb=") - 2,
+ 				    ULONG_MAX, ULONG_MAX, load_addr, load_size);
+ }
+ 
+ efi_status_t efi_load_initrd(efi_loaded_image_t *image,
+ 			     unsigned long soft_limit,
+ 			     unsigned long hard_limit,
+ 			     const struct linux_efi_initrd **out);
+ /*
+  * This function handles the architcture specific differences between arm and
+  * arm64 regarding where the kernel image must be loaded and any memory that
+  * must be reserved. On failure it is required to free all
+  * all allocations it has made.
+  */
+ efi_status_t handle_kernel_image(unsigned long *image_addr,
+ 				 unsigned long *image_size,
+ 				 unsigned long *reserve_addr,
+ 				 unsigned long *reserve_size,
+ 				 efi_loaded_image_t *image,
+ 				 efi_handle_t image_handle);
+ 
+ /* shared entrypoint between the normal stub and the zboot stub */
+ efi_status_t efi_stub_common(efi_handle_t handle,
+ 			     efi_loaded_image_t *image,
+ 			     unsigned long image_addr,
+ 			     char *cmdline_ptr);
+ 
+ efi_status_t efi_handle_cmdline(efi_loaded_image_t *image, char **cmdline_ptr);
+ 
+ asmlinkage void __noreturn efi_enter_kernel(unsigned long entrypoint,
+ 					    unsigned long fdt_addr,
+ 					    unsigned long fdt_size);
+ 
+ void efi_handle_post_ebs_state(void);
+ 
+ enum efi_secureboot_mode efi_get_secureboot(void);
+ 
+ #ifdef CONFIG_RESET_ATTACK_MITIGATION
+ void efi_enable_reset_attack_mitigation(void);
+ #else
+ static inline void
+ efi_enable_reset_attack_mitigation(void) { }
+ #endif
+ 
+ void efi_retrieve_tpm2_eventlog(void);
+ 
+ struct screen_info *alloc_screen_info(void);
+ void free_screen_info(struct screen_info *si);
+ 
+ void efi_cache_sync_image(unsigned long image_base,
+ 			  unsigned long alloc_size,
+ 			  unsigned long code_size);
+ 
+ struct efi_smbios_record {
+ 	u8	type;
+ 	u8	length;
+ 	u16	handle;
+ };
+ 
+ struct efi_smbios_type1_record {
+ 	struct efi_smbios_record	header;
+ 
+ 	u8				manufacturer;
+ 	u8				product_name;
+ 	u8				version;
+ 	u8				serial_number;
+ 	efi_guid_t			uuid;
+ 	u8				wakeup_type;
+ 	u8				sku_number;
+ 	u8				family;
+ };
+ 
+ #define efi_get_smbios_string(__type, __name) ({			\
+ 	int size = sizeof(struct efi_smbios_type ## __type ## _record);	\
+ 	int off = offsetof(struct efi_smbios_type ## __type ## _record,	\
+ 			   __name);					\
+ 	__efi_get_smbios_string(__type, off, size);			\
+ })
+ 
+ const u8 *__efi_get_smbios_string(u8 type, int offset, int recsize);
++>>>>>>> 9cf42bca30e9 (efi: libstub: use EFI_LOADER_CODE region when moving the kernel in memory)
  
  #endif
* Unmerged path drivers/firmware/efi/libstub/alignedmem.c
* Unmerged path drivers/firmware/efi/libstub/mem.c
* Unmerged path drivers/firmware/efi/libstub/randomalloc.c
* Unmerged path drivers/firmware/efi/libstub/alignedmem.c
* Unmerged path drivers/firmware/efi/libstub/arm64-stub.c
* Unmerged path drivers/firmware/efi/libstub/efistub.h
* Unmerged path drivers/firmware/efi/libstub/mem.c
* Unmerged path drivers/firmware/efi/libstub/randomalloc.c
