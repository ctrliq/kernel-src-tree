efi/libstub: Add limit argument to efi_random_alloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit bc5ddceff4c14494d83449ad45c985e6cd353fce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/bc5ddcef.failed

x86 will need to limit the kernel memory allocation to the lowest 512
MiB of memory, to match the behavior of the existing bare metal KASLR
physical randomization logic. So in preparation for that, add a limit
parameter to efi_random_alloc() and wire it up.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Link: https://lore.kernel.org/r/20230807162720.545787-22-ardb@kernel.org
(cherry picked from commit bc5ddceff4c14494d83449ad45c985e6cd353fce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/libstub/arm64-stub.c
#	drivers/firmware/efi/libstub/efistub.h
#	drivers/firmware/efi/libstub/randomalloc.c
#	drivers/firmware/efi/libstub/zboot.c
diff --cc drivers/firmware/efi/libstub/arm64-stub.c
index 80927ef51bdc,8c40fc89f5f9..000000000000
--- a/drivers/firmware/efi/libstub/arm64-stub.c
+++ b/drivers/firmware/efi/libstub/arm64-stub.c
@@@ -110,34 -104,13 +110,42 @@@ efi_status_t handle_kernel_image(efi_sy
  		 * If KASLR is enabled, and we have some randomness available,
  		 * locate the kernel at a randomized offset in physical memory.
  		 */
++<<<<<<< HEAD
 +		*reserve_size = kernel_memsize + offset;
 +		status = efi_random_alloc(sys_table_arg, *reserve_size,
 +					  MIN_KIMG_ALIGN, reserve_addr,
 +					  (u32)phys_seed);
 +
 +		*image_addr = *reserve_addr + offset;
++=======
+ 		status = efi_random_alloc(*reserve_size, min_kimg_align,
+ 					  reserve_addr, phys_seed,
+ 					  EFI_LOADER_CODE, EFI_ALLOC_LIMIT);
+ 		if (status != EFI_SUCCESS)
+ 			efi_warn("efi_random_alloc() failed: 0x%lx\n", status);
++>>>>>>> bc5ddceff4c1 (efi/libstub: Add limit argument to efi_random_alloc())
  	} else {
 -		status = EFI_OUT_OF_RESOURCES;
 +		/*
 +		 * Else, try a straight allocation at the preferred offset.
 +		 * This will work around the issue where, if dram_base == 0x0,
 +		 * efi_low_alloc() refuses to allocate at 0x0 (to prevent the
 +		 * address of the allocation to be mistaken for a FAIL return
 +		 * value or a NULL pointer). It will also ensure that, on
 +		 * platforms where the [dram_base, dram_base + TEXT_OFFSET)
 +		 * interval is partially occupied by the firmware (like on APM
 +		 * Mustang), we can still place the kernel at the address
 +		 * 'dram_base + TEXT_OFFSET'.
 +		 */
 +		if (*image_addr == preferred_offset)
 +			return EFI_SUCCESS;
 +
 +		*image_addr = *reserve_addr = preferred_offset;
 +		*reserve_size = round_up(kernel_memsize, EFI_ALLOC_ALIGN);
 +
 +		status = efi_call_early(allocate_pages, EFI_ALLOCATE_ADDRESS,
 +					EFI_LOADER_DATA,
 +					*reserve_size / EFI_PAGE_SIZE,
 +					(efi_physical_addr_t *)reserve_addr);
  	}
  
  	if (status != EFI_SUCCESS) {
diff --cc drivers/firmware/efi/libstub/efistub.h
index 386522b5d9b5,9823f6fb3e01..000000000000
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@@ -55,15 -952,195 +55,21 @@@ void efi_get_virtmap(efi_memory_desc_t 
  		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
  		     int *count);
  
 -efi_status_t efi_get_random_bytes(unsigned long size, u8 *out);
 +efi_status_t efi_get_random_bytes(efi_system_table_t *sys_table,
 +				  unsigned long size, u8 *out);
  
++<<<<<<< HEAD
 +efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
 +			      unsigned long size, unsigned long align,
 +			      unsigned long *addr, unsigned long random_seed);
++=======
+ efi_status_t efi_random_alloc(unsigned long size, unsigned long align,
+ 			      unsigned long *addr, unsigned long random_seed,
+ 			      int memory_type, unsigned long alloc_limit);
++>>>>>>> bc5ddceff4c1 (efi/libstub: Add limit argument to efi_random_alloc())
  
 -efi_status_t efi_random_get_seed(void);
 -
 -efi_status_t check_platform_features(void);
 -
 -void *get_efi_config_table(efi_guid_t guid);
 -
 -/* NOTE: These functions do not print a trailing newline after the string */
 -void efi_char16_puts(efi_char16_t *);
 -void efi_puts(const char *str);
 -
 -__printf(1, 2) int efi_printk(char const *fmt, ...);
 -
 -void efi_free(unsigned long size, unsigned long addr);
 -
 -void efi_apply_loadoptions_quirk(const void **load_options, u32 *load_options_size);
 -
 -char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
 -
 -efi_status_t efi_get_memory_map(struct efi_boot_memmap **map,
 -				bool install_cfg_tbl);
 -
 -efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
 -				unsigned long max);
 -
 -efi_status_t efi_allocate_pages_aligned(unsigned long size, unsigned long *addr,
 -					unsigned long max, unsigned long align,
 -					int memory_type);
 -
 -efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
 -				 unsigned long *addr, unsigned long min);
 -
 -efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 -				 unsigned long image_size,
 -				 unsigned long alloc_size,
 -				 unsigned long preferred_addr,
 -				 unsigned long alignment,
 -				 unsigned long min_addr);
 -
 -efi_status_t efi_parse_options(char const *cmdline);
 -
 -void efi_parse_option_graphics(char *option);
 -
 -efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
 -			   unsigned long size);
 -
 -efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
 -				  const efi_char16_t *optstr,
 -				  int optstr_size,
 -				  unsigned long soft_limit,
 -				  unsigned long hard_limit,
 -				  unsigned long *load_addr,
 -				  unsigned long *load_size);
 -
 -
 -static inline efi_status_t efi_load_dtb(efi_loaded_image_t *image,
 -					unsigned long *load_addr,
 -					unsigned long *load_size)
 -{
 -	return handle_cmdline_files(image, L"dtb=", sizeof(L"dtb=") - 2,
 -				    ULONG_MAX, ULONG_MAX, load_addr, load_size);
 -}
 -
 -efi_status_t efi_load_initrd(efi_loaded_image_t *image,
 -			     unsigned long soft_limit,
 -			     unsigned long hard_limit,
 -			     const struct linux_efi_initrd **out);
 -/*
 - * This function handles the architcture specific differences between arm and
 - * arm64 regarding where the kernel image must be loaded and any memory that
 - * must be reserved. On failure it is required to free all
 - * all allocations it has made.
 - */
 -efi_status_t handle_kernel_image(unsigned long *image_addr,
 -				 unsigned long *image_size,
 -				 unsigned long *reserve_addr,
 -				 unsigned long *reserve_size,
 -				 efi_loaded_image_t *image,
 -				 efi_handle_t image_handle);
 -
 -/* shared entrypoint between the normal stub and the zboot stub */
 -efi_status_t efi_stub_common(efi_handle_t handle,
 -			     efi_loaded_image_t *image,
 -			     unsigned long image_addr,
 -			     char *cmdline_ptr);
 -
 -efi_status_t efi_handle_cmdline(efi_loaded_image_t *image, char **cmdline_ptr);
 -
 -asmlinkage void __noreturn efi_enter_kernel(unsigned long entrypoint,
 -					    unsigned long fdt_addr,
 -					    unsigned long fdt_size);
 -
 -void efi_handle_post_ebs_state(void);
 -
 -enum efi_secureboot_mode efi_get_secureboot(void);
 -
 -#ifdef CONFIG_RESET_ATTACK_MITIGATION
 -void efi_enable_reset_attack_mitigation(void);
 -#else
 -static inline void
 -efi_enable_reset_attack_mitigation(void) { }
 -#endif
 -
 -void efi_retrieve_tpm2_eventlog(void);
 -
 -struct screen_info *alloc_screen_info(void);
 -struct screen_info *__alloc_screen_info(void);
 -void free_screen_info(struct screen_info *si);
 -
 -void efi_cache_sync_image(unsigned long image_base,
 -			  unsigned long alloc_size);
 -
 -struct efi_smbios_record {
 -	u8	type;
 -	u8	length;
 -	u16	handle;
 -};
 -
 -const struct efi_smbios_record *efi_get_smbios_record(u8 type);
 -
 -struct efi_smbios_type1_record {
 -	struct efi_smbios_record	header;
 -
 -	u8				manufacturer;
 -	u8				product_name;
 -	u8				version;
 -	u8				serial_number;
 -	efi_guid_t			uuid;
 -	u8				wakeup_type;
 -	u8				sku_number;
 -	u8				family;
 -};
 -
 -struct efi_smbios_type4_record {
 -	struct efi_smbios_record	header;
 -
 -	u8				socket;
 -	u8				processor_type;
 -	u8				processor_family;
 -	u8				processor_manufacturer;
 -	u8				processor_id[8];
 -	u8				processor_version;
 -	u8				voltage;
 -	u16				external_clock;
 -	u16				max_speed;
 -	u16				current_speed;
 -	u8				status;
 -	u8				processor_upgrade;
 -	u16				l1_cache_handle;
 -	u16				l2_cache_handle;
 -	u16				l3_cache_handle;
 -	u8				serial_number;
 -	u8				asset_tag;
 -	u8				part_number;
 -	u8				core_count;
 -	u8				enabled_core_count;
 -	u8				thread_count;
 -	u16				processor_characteristics;
 -	u16				processor_family2;
 -	u16				core_count2;
 -	u16				enabled_core_count2;
 -	u16				thread_count2;
 -	u16				thread_enabled;
 -};
 -
 -#define efi_get_smbios_string(__record, __type, __name) ({		\
 -	int off = offsetof(struct efi_smbios_type ## __type ## _record,	\
 -			   __name);					\
 -	__efi_get_smbios_string((__record), __type, off);		\
 -})
 -
 -const u8 *__efi_get_smbios_string(const struct efi_smbios_record *record,
 -				  u8 type, int offset);
 -
 -void efi_remap_image(unsigned long image_base, unsigned alloc_size,
 -		     unsigned long code_size);
 -
 -asmlinkage efi_status_t __efiapi
 -efi_zboot_entry(efi_handle_t handle, efi_system_table_t *systab);
 +efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
  
 -efi_status_t allocate_unaccepted_bitmap(__u32 nr_desc,
 -					struct efi_boot_memmap *map);
 -void process_unaccepted_memory(u64 start, u64 end);
 -void accept_memory(phys_addr_t start, phys_addr_t end);
 -void arch_accept_memory(phys_addr_t start, phys_addr_t end);
 +void *get_efi_config_table(efi_system_table_t *sys_table, efi_guid_t guid);
  
  #endif
* Unmerged path drivers/firmware/efi/libstub/randomalloc.c
* Unmerged path drivers/firmware/efi/libstub/zboot.c
* Unmerged path drivers/firmware/efi/libstub/arm64-stub.c
* Unmerged path drivers/firmware/efi/libstub/efistub.h
* Unmerged path drivers/firmware/efi/libstub/randomalloc.c
* Unmerged path drivers/firmware/efi/libstub/zboot.c
