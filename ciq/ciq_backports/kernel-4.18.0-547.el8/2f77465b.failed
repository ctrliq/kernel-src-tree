x86/efistub: Avoid placing the kernel below LOAD_PHYSICAL_ADDR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 2f77465b05b1270c832b5e2ee27037672ad2a10a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/2f77465b.failed

The EFI stub's kernel placement logic randomizes the physical placement
of the kernel by taking all available memory into account, and picking a
region at random, based on a random seed.

When KASLR is disabled, this seed is set to 0x0, and this results in the
lowest available region of memory to be selected for loading the kernel,
even if this is below LOAD_PHYSICAL_ADDR. Some of this memory is
typically reserved for the GFP_DMA region, to accommodate masters that
can only access the first 16 MiB of system memory.

Even if such devices are rare these days, we may still end up with a
warning in the kernel log, as reported by Tom:

 swapper/0: page allocation failure: order:10, mode:0xcc1(GFP_KERNEL|GFP_DMA), nodemask=(null),cpuset=/,mems_allowed=0

Fix this by tweaking the random allocation logic to accept a low bound
on the placement, and set it to LOAD_PHYSICAL_ADDR.

Fixes: a1b87d54f4e4 ("x86/efistub: Avoid legacy decompressor when doing EFI boot")
	Reported-by: Tom Englund <tomenglund26@gmail.com>
Closes: https://bugzilla.kernel.org/show_bug.cgi?id=218404
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 2f77465b05b1270c832b5e2ee27037672ad2a10a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/libstub/efistub.h
#	drivers/firmware/efi/libstub/kaslr.c
#	drivers/firmware/efi/libstub/randomalloc.c
#	drivers/firmware/efi/libstub/x86-stub.c
#	drivers/firmware/efi/libstub/zboot.c
diff --cc drivers/firmware/efi/libstub/efistub.h
index 386522b5d9b5,c04b82ea40f2..000000000000
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@@ -55,15 -952,204 +55,22 @@@ void efi_get_virtmap(efi_memory_desc_t 
  		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
  		     int *count);
  
 -efi_status_t efi_get_random_bytes(unsigned long size, u8 *out);
 +efi_status_t efi_get_random_bytes(efi_system_table_t *sys_table,
 +				  unsigned long size, u8 *out);
  
++<<<<<<< HEAD
 +efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
 +			      unsigned long size, unsigned long align,
 +			      unsigned long *addr, unsigned long random_seed);
++=======
+ efi_status_t efi_random_alloc(unsigned long size, unsigned long align,
+ 			      unsigned long *addr, unsigned long random_seed,
+ 			      int memory_type, unsigned long alloc_min,
+ 			      unsigned long alloc_max);
++>>>>>>> 2f77465b05b1 (x86/efistub: Avoid placing the kernel below LOAD_PHYSICAL_ADDR)
  
 -efi_status_t efi_random_get_seed(void);
 -
 -efi_status_t check_platform_features(void);
 -
 -void *get_efi_config_table(efi_guid_t guid);
 -
 -/* NOTE: These functions do not print a trailing newline after the string */
 -void efi_char16_puts(efi_char16_t *);
 -void efi_puts(const char *str);
 -
 -__printf(1, 2) int efi_printk(char const *fmt, ...);
 -
 -void efi_free(unsigned long size, unsigned long addr);
 -
 -void efi_apply_loadoptions_quirk(const void **load_options, u32 *load_options_size);
 -
 -char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
 -
 -efi_status_t efi_get_memory_map(struct efi_boot_memmap **map,
 -				bool install_cfg_tbl);
 -
 -efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
 -				unsigned long max);
 -
 -efi_status_t efi_allocate_pages_aligned(unsigned long size, unsigned long *addr,
 -					unsigned long max, unsigned long align,
 -					int memory_type);
 -
 -efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
 -				 unsigned long *addr, unsigned long min);
 -
 -efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 -				 unsigned long image_size,
 -				 unsigned long alloc_size,
 -				 unsigned long preferred_addr,
 -				 unsigned long alignment,
 -				 unsigned long min_addr);
 -
 -efi_status_t efi_parse_options(char const *cmdline);
 -
 -void efi_parse_option_graphics(char *option);
 -
 -efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
 -			   unsigned long size);
 -
 -efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
 -				  const efi_char16_t *optstr,
 -				  int optstr_size,
 -				  unsigned long soft_limit,
 -				  unsigned long hard_limit,
 -				  unsigned long *load_addr,
 -				  unsigned long *load_size);
 -
 -
 -static inline efi_status_t efi_load_dtb(efi_loaded_image_t *image,
 -					unsigned long *load_addr,
 -					unsigned long *load_size)
 -{
 -	return handle_cmdline_files(image, L"dtb=", sizeof(L"dtb=") - 2,
 -				    ULONG_MAX, ULONG_MAX, load_addr, load_size);
 -}
 -
 -efi_status_t efi_load_initrd(efi_loaded_image_t *image,
 -			     unsigned long soft_limit,
 -			     unsigned long hard_limit,
 -			     const struct linux_efi_initrd **out);
 -/*
 - * This function handles the architcture specific differences between arm and
 - * arm64 regarding where the kernel image must be loaded and any memory that
 - * must be reserved. On failure it is required to free all
 - * all allocations it has made.
 - */
 -efi_status_t handle_kernel_image(unsigned long *image_addr,
 -				 unsigned long *image_size,
 -				 unsigned long *reserve_addr,
 -				 unsigned long *reserve_size,
 -				 efi_loaded_image_t *image,
 -				 efi_handle_t image_handle);
 -
 -/* shared entrypoint between the normal stub and the zboot stub */
 -efi_status_t efi_stub_common(efi_handle_t handle,
 -			     efi_loaded_image_t *image,
 -			     unsigned long image_addr,
 -			     char *cmdline_ptr);
 -
 -efi_status_t efi_handle_cmdline(efi_loaded_image_t *image, char **cmdline_ptr);
 -
 -asmlinkage void __noreturn efi_enter_kernel(unsigned long entrypoint,
 -					    unsigned long fdt_addr,
 -					    unsigned long fdt_size);
 -
 -void efi_handle_post_ebs_state(void);
 -
 -enum efi_secureboot_mode efi_get_secureboot(void);
 -
 -#ifdef CONFIG_RESET_ATTACK_MITIGATION
 -void efi_enable_reset_attack_mitigation(void);
 -#else
 -static inline void
 -efi_enable_reset_attack_mitigation(void) { }
 -#endif
 -
 -void efi_retrieve_tpm2_eventlog(void);
 -
 -struct screen_info *alloc_screen_info(void);
 -struct screen_info *__alloc_screen_info(void);
 -void free_screen_info(struct screen_info *si);
 -
 -void efi_cache_sync_image(unsigned long image_base,
 -			  unsigned long alloc_size);
 -
 -struct efi_smbios_record {
 -	u8	type;
 -	u8	length;
 -	u16	handle;
 -};
 -
 -const struct efi_smbios_record *efi_get_smbios_record(u8 type);
 -
 -struct efi_smbios_type1_record {
 -	struct efi_smbios_record	header;
 -
 -	u8				manufacturer;
 -	u8				product_name;
 -	u8				version;
 -	u8				serial_number;
 -	efi_guid_t			uuid;
 -	u8				wakeup_type;
 -	u8				sku_number;
 -	u8				family;
 -};
 -
 -struct efi_smbios_type4_record {
 -	struct efi_smbios_record	header;
 -
 -	u8				socket;
 -	u8				processor_type;
 -	u8				processor_family;
 -	u8				processor_manufacturer;
 -	u8				processor_id[8];
 -	u8				processor_version;
 -	u8				voltage;
 -	u16				external_clock;
 -	u16				max_speed;
 -	u16				current_speed;
 -	u8				status;
 -	u8				processor_upgrade;
 -	u16				l1_cache_handle;
 -	u16				l2_cache_handle;
 -	u16				l3_cache_handle;
 -	u8				serial_number;
 -	u8				asset_tag;
 -	u8				part_number;
 -	u8				core_count;
 -	u8				enabled_core_count;
 -	u8				thread_count;
 -	u16				processor_characteristics;
 -	u16				processor_family2;
 -	u16				core_count2;
 -	u16				enabled_core_count2;
 -	u16				thread_count2;
 -	u16				thread_enabled;
 -};
 -
 -#define efi_get_smbios_string(__record, __type, __name) ({		\
 -	int off = offsetof(struct efi_smbios_type ## __type ## _record,	\
 -			   __name);					\
 -	__efi_get_smbios_string((__record), __type, off);		\
 -})
 -
 -const u8 *__efi_get_smbios_string(const struct efi_smbios_record *record,
 -				  u8 type, int offset);
 -
 -void efi_remap_image(unsigned long image_base, unsigned alloc_size,
 -		     unsigned long code_size);
 -efi_status_t efi_kaslr_relocate_kernel(unsigned long *image_addr,
 -				       unsigned long *reserve_addr,
 -				       unsigned long *reserve_size,
 -				       unsigned long kernel_size,
 -				       unsigned long kernel_codesize,
 -				       unsigned long kernel_memsize,
 -				       u32 phys_seed);
 -u32 efi_kaslr_get_phys_seed(efi_handle_t image_handle);
 -
 -asmlinkage efi_status_t __efiapi
 -efi_zboot_entry(efi_handle_t handle, efi_system_table_t *systab);
 +efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
  
 -efi_status_t allocate_unaccepted_bitmap(__u32 nr_desc,
 -					struct efi_boot_memmap *map);
 -void process_unaccepted_memory(u64 start, u64 end);
 -void accept_memory(phys_addr_t start, phys_addr_t end);
 -void arch_accept_memory(phys_addr_t start, phys_addr_t end);
 +void *get_efi_config_table(efi_system_table_t *sys_table, efi_guid_t guid);
  
  #endif
* Unmerged path drivers/firmware/efi/libstub/kaslr.c
* Unmerged path drivers/firmware/efi/libstub/randomalloc.c
* Unmerged path drivers/firmware/efi/libstub/x86-stub.c
* Unmerged path drivers/firmware/efi/libstub/zboot.c
* Unmerged path drivers/firmware/efi/libstub/efistub.h
* Unmerged path drivers/firmware/efi/libstub/kaslr.c
* Unmerged path drivers/firmware/efi/libstub/randomalloc.c
* Unmerged path drivers/firmware/efi/libstub/x86-stub.c
* Unmerged path drivers/firmware/efi/libstub/zboot.c
