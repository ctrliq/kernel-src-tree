x86/efistub: Perform 4/5 level paging switch from the stub

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit cb1c9e02b0c13032c3aec325643453ba48e96e17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/cb1c9e02.failed

In preparation for updating the EFI stub boot flow to avoid the bare
metal decompressor code altogether, implement the support code for
switching between 4 and 5 levels of paging before jumping to the kernel
proper.

Reuse the newly refactored trampoline that the bare metal decompressor
uses, but relies on EFI APIs to allocate 32-bit addressable memory and
remap it with the appropriate permissions. Given that the bare metal
decompressor will no longer call into the trampoline if the number of
paging levels is already set correctly, it is no longer needed to remove
NX restrictions from the memory range where this trampoline may end up.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Link: https://lore.kernel.org/r/20230807162720.545787-17-ardb@kernel.org
(cherry picked from commit cb1c9e02b0c13032c3aec325643453ba48e96e17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
#	drivers/firmware/efi/libstub/Makefile
#	drivers/firmware/efi/libstub/efi-stub-helper.c
#	drivers/firmware/efi/libstub/efistub.h
diff --cc arch/x86/boot/compressed/eboot.c
index c2a7652f4460,af5f50617a5b..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -17,38 -16,27 +17,43 @@@
  #include <asm/desc.h>
  #include <asm/boot.h>
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +#include "../string.h"
 +#include "eboot.h"
++=======
+ #include "efistub.h"
+ #include "x86-stub.h"
++>>>>>>> cb1c9e02b0c1 (x86/efistub: Perform 4/5 level paging switch from the stub):drivers/firmware/efi/libstub/x86-stub.c
  
 -/* Maximum physical address for 64-bit kernel with 4-level paging */
 -#define MAXMEM_X86_64_4LEVEL (1ull << 46)
 -
 -const efi_system_table_t *efi_system_table;
 -const efi_dxe_services_table_t *efi_dxe_table;
 -u32 image_offset __section(".data");
 -static efi_loaded_image_t *image = NULL;
 -
 -typedef union sev_memory_acceptance_protocol sev_memory_acceptance_protocol_t;
 -union sev_memory_acceptance_protocol {
 -	struct {
 -		efi_status_t (__efiapi * allow_unaccepted_memory)(
 -			sev_memory_acceptance_protocol_t *);
 -	};
 -	struct {
 -		u32 allow_unaccepted_memory;
 -	} mixed_mode;
 -};
 +static efi_system_table_t *sys_table;
 +static const efi_dxe_services_table_t *efi_dxe_table;
 +
 +static struct efi_config *efi_early;
 +
 +__pure const struct efi_config *__efi_early(void)
 +{
 +	return efi_early;
 +}
 +
 +#define BOOT_SERVICES(bits)						\
 +static void setup_boot_services##bits(struct efi_config *c)		\
 +{									\
 +	efi_system_table_##bits##_t *table;				\
 +									\
 +	table = (typeof(table))sys_table;				\
 +									\
 +	c->runtime_services	= table->runtime;			\
 +	c->boot_services	= table->boottime;			\
 +	c->text_output		= table->con_out;			\
 +}
 +BOOT_SERVICES(32);
 +BOOT_SERVICES(64);
 +
 +void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 +{
 +	efi_call_proto(efi_simple_text_output_protocol, output_string,
 +		       efi_early->text_output, str);
 +}
  
  static efi_status_t
  preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
@@@ -292,19 -279,7 +297,23 @@@ void efi_adjust_memory_range_protection
  	}
  }
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +/*
 + * Trampoline takes 2 pages and can be loaded in first megabyte of memory
 + * with its end placed between 128k and 640k where BIOS might start.
 + * (see arch/x86/boot/compressed/pgtable_64.c)
 + *
 + * We cannot find exact trampoline placement since memory map
 + * can be modified by UEFI, and it can alter the computed address.
 + */
 +
 +#define TRAMPOLINE_PLACEMENT_BASE ((128 - 8)*1024)
 +#define TRAMPOLINE_PLACEMENT_SIZE (640*1024 - (128 - 8)*1024)
 +
 +void startup_32(struct boot_params *boot_params);
++=======
+ extern const u8 startup_32[], startup_64[];
++>>>>>>> cb1c9e02b0c1 (x86/efistub: Perform 4/5 level paging switch from the stub):drivers/firmware/efi/libstub/x86-stub.c
  
  static void
  setup_memory_protection(unsigned long image_base, unsigned long image_size)
@@@ -882,13 -819,51 +882,19 @@@ efi_main(struct efi_config *c, struct b
  		efi_dxe_table = NULL;
  	}
  
+ 	status = efi_setup_5level_paging();
+ 	if (status != EFI_SUCCESS) {
+ 		efi_err("efi_setup_5level_paging() failed!\n");
+ 		goto fail;
+ 	}
+ 
  	/*
 -	 * If the kernel isn't already loaded at a suitable address,
 -	 * relocate it.
 -	 *
 -	 * It must be loaded above LOAD_PHYSICAL_ADDR.
 -	 *
 -	 * The maximum address for 64-bit is 1 << 46 for 4-level paging. This
 -	 * is defined as the macro MAXMEM, but unfortunately that is not a
 -	 * compile-time constant if 5-level paging is configured, so we instead
 -	 * define our own macro for use here.
 -	 *
 -	 * For 32-bit, the maximum address is complicated to figure out, for
 -	 * now use KERNEL_IMAGE_SIZE, which will be 512MiB, the same as what
 -	 * KASLR uses.
 -	 *
 -	 * Also relocate it if image_offset is zero, i.e. the kernel wasn't
 -	 * loaded by LoadImage, but rather by a bootloader that called the
 -	 * handover entry. The reason we must always relocate in this case is
 -	 * to handle the case of systemd-boot booting a unified kernel image,
 -	 * which is a PE executable that contains the bzImage and an initrd as
 -	 * COFF sections. The initrd section is placed after the bzImage
 -	 * without ensuring that there are at least init_size bytes available
 -	 * for the bzImage, and thus the compressed kernel's startup code may
 -	 * overwrite the initrd unless it is moved out of the way.
 +	 * If the kernel isn't already loaded at the preferred load
 +	 * address, relocate it.
  	 */
 -
 -	buffer_start = ALIGN(bzimage_addr - image_offset,
 -			     hdr->kernel_alignment);
 -	buffer_end = buffer_start + hdr->init_size;
 -
 -	if ((buffer_start < LOAD_PHYSICAL_ADDR)				     ||
 -	    (IS_ENABLED(CONFIG_X86_32) && buffer_end > KERNEL_IMAGE_SIZE)    ||
 -	    (IS_ENABLED(CONFIG_X86_64) && buffer_end > MAXMEM_X86_64_4LEVEL) ||
 -	    (image_offset == 0)) {
 -		extern char _bss[];
 -
 -		status = efi_relocate_kernel(&bzimage_addr,
 -					     (unsigned long)_bss - bzimage_addr,
 -					     hdr->init_size,
 +	if (bzimage_addr != hdr->pref_address) {
 +		status = efi_relocate_kernel(sys_table, &bzimage_addr,
 +					     hdr->init_size, hdr->init_size,
  					     hdr->pref_address,
  					     hdr->kernel_alignment,
  					     LOAD_PHYSICAL_ADDR);
@@@ -936,110 -945,35 +942,117 @@@
  		goto fail;
  	}
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	gdt->size = 0x800;
 +	status = efi_low_alloc(sys_table, gdt->size, 8,
 +			   (unsigned long *)&gdt->address);
 +	if (status != EFI_SUCCESS) {
 +		efi_printk(sys_table, "Failed to allocate memory for 'gdt'\n");
 +		goto fail;
 +	}
++=======
+ 	efi_5level_switch();
+ 
+ 	if (IS_ENABLED(CONFIG_X86_64))
+ 		bzimage_addr += startup_64 - startup_32;
++>>>>>>> cb1c9e02b0c1 (x86/efistub: Perform 4/5 level paging switch from the stub):drivers/firmware/efi/libstub/x86-stub.c
  
 -	enter_kernel(bzimage_addr, boot_params);
 -fail:
 -	efi_err("efi_stub_entry() failed!\n");
 +	status = exit_boot(boot_params, handle, is64);
 +	if (status != EFI_SUCCESS) {
 +		efi_printk(sys_table, "exit_boot() failed!\n");
 +		goto fail;
 +	}
  
 -	efi_exit(handle, status);
 -}
 +	memset((char *)gdt->address, 0x0, gdt->size);
 +	desc = (struct desc_struct *)gdt->address;
 +
 +	/* The first GDT is a dummy. */
 +	desc++;
 +
 +	if (IS_ENABLED(CONFIG_X86_64)) {
 +		/* __KERNEL32_CS */
 +		desc->limit0	= 0xffff;
 +		desc->base0	= 0x0000;
 +		desc->base1	= 0x0000;
 +		desc->type	= SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;
 +		desc->s		= DESC_TYPE_CODE_DATA;
 +		desc->dpl	= 0;
 +		desc->p		= 1;
 +		desc->limit1	= 0xf;
 +		desc->avl	= 0;
 +		desc->l		= 0;
 +		desc->d		= SEG_OP_SIZE_32BIT;
 +		desc->g		= SEG_GRANULARITY_4KB;
 +		desc->base2	= 0x00;
 +
 +		desc++;
 +	} else {
 +		/* Second entry is unused on 32-bit */
 +		desc++;
 +	}
  
 -#ifdef CONFIG_EFI_HANDOVER_PROTOCOL
 -void efi_handover_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,
 -			struct boot_params *boot_params)
 -{
 -	extern char _bss[], _ebss[];
 +	/* __KERNEL_CS */
 +	desc->limit0	= 0xffff;
 +	desc->base0	= 0x0000;
 +	desc->base1	= 0x0000;
 +	desc->type	= SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;
 +	desc->s		= DESC_TYPE_CODE_DATA;
 +	desc->dpl	= 0;
 +	desc->p		= 1;
 +	desc->limit1	= 0xf;
 +	desc->avl	= 0;
 +
 +	if (IS_ENABLED(CONFIG_X86_64)) {
 +		desc->l = 1;
 +		desc->d = 0;
 +	} else {
 +		desc->l = 0;
 +		desc->d = SEG_OP_SIZE_32BIT;
 +	}
 +	desc->g		= SEG_GRANULARITY_4KB;
 +	desc->base2	= 0x00;
 +	desc++;
 +
 +	/* __KERNEL_DS */
 +	desc->limit0	= 0xffff;
 +	desc->base0	= 0x0000;
 +	desc->base1	= 0x0000;
 +	desc->type	= SEG_TYPE_DATA | SEG_TYPE_READ_WRITE;
 +	desc->s		= DESC_TYPE_CODE_DATA;
 +	desc->dpl	= 0;
 +	desc->p		= 1;
 +	desc->limit1	= 0xf;
 +	desc->avl	= 0;
 +	desc->l		= 0;
 +	desc->d		= SEG_OP_SIZE_32BIT;
 +	desc->g		= SEG_GRANULARITY_4KB;
 +	desc->base2	= 0x00;
 +	desc++;
 +
 +	if (IS_ENABLED(CONFIG_X86_64)) {
 +		/* Task segment value */
 +		desc->limit0	= 0x0000;
 +		desc->base0	= 0x0000;
 +		desc->base1	= 0x0000;
 +		desc->type	= SEG_TYPE_TSS;
 +		desc->s		= 0;
 +		desc->dpl	= 0;
 +		desc->p		= 1;
 +		desc->limit1	= 0x0;
 +		desc->avl	= 0;
 +		desc->l		= 0;
 +		desc->d		= 0;
 +		desc->g		= SEG_GRANULARITY_4KB;
 +		desc->base2	= 0x00;
 +		desc++;
 +	}
  
 -	memset(_bss, 0, _ebss - _bss);
 -	efi_stub_entry(handle, sys_table_arg, boot_params);
 -}
 +	asm volatile("cli");
 +	asm volatile ("lgdt %0" : : "m" (*gdt));
  
 -#ifndef CONFIG_EFI_MIXED
 -extern __alias(efi_handover_entry)
 -void efi32_stub_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,
 -		      struct boot_params *boot_params);
 +	return boot_params;
 +fail:
 +	efi_printk(sys_table, "efi_main() failed!\n");
  
 -extern __alias(efi_handover_entry)
 -void efi64_stub_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,
 -		      struct boot_params *boot_params);
 -#endif
 -#endif
 +	return NULL;
 +}
diff --cc drivers/firmware/efi/libstub/Makefile
index 5e462c0292d3,ae8874401a9f..000000000000
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@@ -43,12 -82,50 +43,55 @@@ arm-deps-$(CONFIG_ARM64) += sort.
  $(obj)/lib-%.o: $(srctree)/lib/%.c FORCE
  	$(call if_changed_rule,cc_o_c)
  
 -lib-$(CONFIG_EFI_GENERIC_STUB)	+= efi-stub.o string.o intrinsics.o systable.o \
 -				   screen_info.o efi-stub-entry.o
 +lib-$(CONFIG_EFI_ARMSTUB)	+= arm-stub.o fdt.o string.o \
 +				   $(patsubst %.c,lib-%.o,$(arm-deps-y))
  
  lib-$(CONFIG_ARM)		+= arm32-stub.o
++<<<<<<< HEAD
 +lib-$(CONFIG_ARM64)		+= arm64-stub.o
 +CFLAGS_arm64-stub.o 		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
++=======
+ lib-$(CONFIG_ARM64)		+= arm64.o arm64-stub.o smbios.o
+ lib-$(CONFIG_X86)		+= x86-stub.o
+ lib-$(CONFIG_X86_64)		+= x86-5lvl.o
+ lib-$(CONFIG_RISCV)		+= riscv.o riscv-stub.o
+ lib-$(CONFIG_LOONGARCH)		+= loongarch.o loongarch-stub.o
+ 
+ CFLAGS_arm32-stub.o		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
+ 
+ zboot-obj-$(CONFIG_RISCV)	:= lib-clz_ctz.o lib-ashldi3.o
+ lib-$(CONFIG_EFI_ZBOOT)		+= zboot.o $(zboot-obj-y)
+ 
+ lib-$(CONFIG_UNACCEPTED_MEMORY) += unaccepted_memory.o bitmap.o find.o
+ 
+ extra-y				:= $(lib-y)
+ lib-y				:= $(patsubst %.o,%.stub.o,$(lib-y))
+ 
+ # Even when -mbranch-protection=none is set, Clang will generate a
+ # .note.gnu.property for code-less object files (like lib/ctype.c),
+ # so work around this by explicitly removing the unwanted section.
+ # https://bugs.llvm.org/show_bug.cgi?id=46480
+ STUBCOPY_FLAGS-y		+= --remove-section=.note.gnu.property
+ 
+ #
+ # For x86, bootloaders like systemd-boot or grub-efi do not zero-initialize the
+ # .bss section, so the .bss section of the EFI stub needs to be included in the
+ # .data section of the compressed kernel to ensure initialization. Rename the
+ # .bss section here so it's easy to pick out in the linker script.
+ #
+ STUBCOPY_FLAGS-$(CONFIG_X86)	+= --rename-section .bss=.bss.efistub,load,alloc
+ STUBCOPY_RELOC-$(CONFIG_X86_32)	:= R_386_32
+ STUBCOPY_RELOC-$(CONFIG_X86_64)	:= R_X86_64_64
+ 
+ #
+ # ARM discards the .data section because it disallows r/w data in the
+ # decompressor. So move our .data to .data.efistub and .bss to .bss.efistub,
+ # which are preserved explicitly by the decompressor linker script.
+ #
+ STUBCOPY_FLAGS-$(CONFIG_ARM)	+= --rename-section .data=.data.efistub	\
+ 				   --rename-section .bss=.bss.efistub,load,alloc
+ STUBCOPY_RELOC-$(CONFIG_ARM)	:= R_ARM_ABS
++>>>>>>> cb1c9e02b0c1 (x86/efistub: Perform 4/5 level paging switch from the stub)
  
  #
  # arm64 puts the stub in the kernel proper, which will unnecessarily retain all
diff --cc drivers/firmware/efi/libstub/efi-stub-helper.c
index 6e2d10272add,bfa30625f5d0..000000000000
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@@ -462,51 -42,58 +462,89 @@@ static efi_status_t efi_open_volume(efi
   */
  efi_status_t efi_parse_options(char const *cmdline)
  {
 -	size_t len;
 -	efi_status_t status;
 -	char *str, *buf;
 +	char *str;
 +
 +	str = strstr(cmdline, "nokaslr");
 +	if (str == cmdline || (str && str > cmdline && *(str - 1) == ' '))
 +		__nokaslr = 1;
 +
 +	str = strstr(cmdline, "quiet");
 +	if (str == cmdline || (str && str > cmdline && *(str - 1) == ' '))
 +		__quiet = 1;
  
 -	if (!cmdline)
 +	/*
 +	 * If no EFI parameters were specified on the cmdline we've got
 +	 * nothing to do.
 +	 */
 +	str = strstr(cmdline, "efi=");
 +	if (!str)
  		return EFI_SUCCESS;
  
 -	len = strnlen(cmdline, COMMAND_LINE_SIZE - 1) + 1;
 -	status = efi_bs_call(allocate_pool, EFI_LOADER_DATA, len, (void **)&buf);
 -	if (status != EFI_SUCCESS)
 -		return status;
 +	/* Skip ahead to first argument */
 +	str += strlen("efi=");
  
++<<<<<<< HEAD
 +	/*
 +	 * Remember, because efi= is also used by the kernel we need to
 +	 * skip over arguments we don't understand.
 +	 */
 +	while (*str && *str != ' ') {
 +		if (!strncmp(str, "nochunk", 7)) {
 +			str += strlen("nochunk");
 +			__chunk_size = -1UL;
++=======
+ 	memcpy(buf, cmdline, len - 1);
+ 	buf[len - 1] = '\0';
+ 	str = skip_spaces(buf);
+ 
+ 	while (*str) {
+ 		char *param, *val;
+ 
+ 		str = next_arg(str, &param, &val);
+ 		if (!val && !strcmp(param, "--"))
+ 			break;
+ 
+ 		if (!strcmp(param, "nokaslr")) {
+ 			efi_nokaslr = true;
+ 		} else if (!strcmp(param, "quiet")) {
+ 			efi_loglevel = CONSOLE_LOGLEVEL_QUIET;
+ 		} else if (!strcmp(param, "noinitrd")) {
+ 			efi_noinitrd = true;
+ 		} else if (IS_ENABLED(CONFIG_X86_64) && !strcmp(param, "no5lvl")) {
+ 			efi_no5lvl = true;
+ 		} else if (!strcmp(param, "efi") && val) {
+ 			efi_nochunk = parse_option_str(val, "nochunk");
+ 			efi_novamap |= parse_option_str(val, "novamap");
+ 
+ 			efi_nosoftreserve = IS_ENABLED(CONFIG_EFI_SOFT_RESERVE) &&
+ 					    parse_option_str(val, "nosoftreserve");
+ 
+ 			if (parse_option_str(val, "disable_early_pci_dma"))
+ 				efi_disable_pci_dma = true;
+ 			if (parse_option_str(val, "no_disable_early_pci_dma"))
+ 				efi_disable_pci_dma = false;
+ 			if (parse_option_str(val, "debug"))
+ 				efi_loglevel = CONSOLE_LOGLEVEL_DEBUG;
+ 		} else if (!strcmp(param, "video") &&
+ 			   val && strstarts(val, "efifb:")) {
+ 			efi_parse_option_graphics(val + strlen("efifb:"));
++>>>>>>> cb1c9e02b0c1 (x86/efistub: Perform 4/5 level paging switch from the stub)
  		}
 +
 +		if (IS_ENABLED(CONFIG_EFI_SOFT_RESERVE) &&
 +		    !strncmp(str, "nosoftreserve", 7)) {
 +			str += strlen("nosoftreserve");
 +			efi_nosoftreserve = 1;
 +		}
 +
 +		/* Group words together, delimited by "," */
 +		while (*str && *str != ' ' && *str != ',')
 +			str++;
 +
 +		if (*str == ',')
 +			str++;
  	}
 -	efi_bs_call(free_pool, buf);
 +
  	return EFI_SUCCESS;
  }
  
diff --cc drivers/firmware/efi/libstub/efistub.h
index 386522b5d9b5,06b7abc92ced..000000000000
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@@ -25,32 -29,925 +25,40 @@@
  #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
  #endif
  
 -#ifndef EFI_ALLOC_LIMIT
 -#define EFI_ALLOC_LIMIT		ULONG_MAX
 -#endif
 +extern int __pure nokaslr(void);
 +extern int __pure is_quiet(void);
  
++<<<<<<< HEAD
 +extern void set_nokaslr(int val);
++=======
+ extern bool efi_no5lvl;
+ extern bool efi_nochunk;
+ extern bool efi_nokaslr;
+ extern int efi_loglevel;
+ extern bool efi_novamap;
++>>>>>>> cb1c9e02b0c1 (x86/efistub: Perform 4/5 level paging switch from the stub)
  
 -extern const efi_system_table_t *efi_system_table;
 -
 -typedef union efi_dxe_services_table efi_dxe_services_table_t;
 -extern const efi_dxe_services_table_t *efi_dxe_table;
 -
 -efi_status_t __efiapi efi_pe_entry(efi_handle_t handle,
 -				   efi_system_table_t *sys_table_arg);
 -
 -#ifndef ARCH_HAS_EFISTUB_WRAPPERS
 -
 -#define efi_is_native()			(true)
 -#define efi_table_attr(inst, attr)	(inst)->attr
 -#define efi_fn_call(inst, func, ...)	(inst)->func(__VA_ARGS__)
 -
 -#endif
 -
 -#define efi_call_proto(inst, func, ...) ({			\
 -	__typeof__(inst) __inst = (inst);			\
 -	efi_fn_call(__inst, func, __inst, ##__VA_ARGS__);	\
 -})
 -#define efi_bs_call(func, ...) \
 -	efi_fn_call(efi_table_attr(efi_system_table, boottime), func, ##__VA_ARGS__)
 -#define efi_rt_call(func, ...) \
 -	efi_fn_call(efi_table_attr(efi_system_table, runtime), func, ##__VA_ARGS__)
 -#define efi_dxe_call(func, ...) \
 -	efi_fn_call(efi_dxe_table, func, ##__VA_ARGS__)
 -
 -#define efi_info(fmt, ...) \
 -	efi_printk(KERN_INFO fmt, ##__VA_ARGS__)
 -#define efi_warn(fmt, ...) \
 -	efi_printk(KERN_WARNING "WARNING: " fmt, ##__VA_ARGS__)
 -#define efi_err(fmt, ...) \
 -	efi_printk(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
 -#define efi_debug(fmt, ...) \
 -	efi_printk(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
 -
 -#define efi_printk_once(fmt, ...) 		\
 -({						\
 -	static bool __print_once;		\
 -	bool __ret_print_once = !__print_once;	\
 -						\
 -	if (!__print_once) {			\
 -		__print_once = true;		\
 -		efi_printk(fmt, ##__VA_ARGS__);	\
 -	}					\
 -	__ret_print_once;			\
 -})
 -
 -#define efi_info_once(fmt, ...) \
 -	efi_printk_once(KERN_INFO fmt, ##__VA_ARGS__)
 -#define efi_warn_once(fmt, ...) \
 -	efi_printk_once(KERN_WARNING "WARNING: " fmt, ##__VA_ARGS__)
 -#define efi_err_once(fmt, ...) \
 -	efi_printk_once(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
 -#define efi_debug_once(fmt, ...) \
 -	efi_printk_once(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
 -
 -/* Helper macros for the usual case of using simple C variables: */
 -#ifndef fdt_setprop_inplace_var
 -#define fdt_setprop_inplace_var(fdt, node_offset, name, var) \
 -	fdt_setprop_inplace((fdt), (node_offset), (name), &(var), sizeof(var))
 -#endif
 -
 -#ifndef fdt_setprop_var
 -#define fdt_setprop_var(fdt, node_offset, name, var) \
 -	fdt_setprop((fdt), (node_offset), (name), &(var), sizeof(var))
 -#endif
 -
 -#define get_efi_var(name, vendor, ...)				\
 -	efi_rt_call(get_variable, (efi_char16_t *)(name),	\
 -		    (efi_guid_t *)(vendor), __VA_ARGS__)
 -
 -#define set_efi_var(name, vendor, ...)				\
 -	efi_rt_call(set_variable, (efi_char16_t *)(name),	\
 -		    (efi_guid_t *)(vendor), __VA_ARGS__)
 -
 -#define efi_get_handle_at(array, idx)					\
 -	(efi_is_native() ? (array)[idx] 				\
 -		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
 -
 -#define efi_get_handle_num(size)					\
 -	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
 -
 -#define for_each_efi_handle(handle, array, size, i)			\
 -	for (i = 0;							\
 -	     i < efi_get_handle_num(size) &&				\
 -		((handle = efi_get_handle_at((array), i)) || true);	\
 -	     i++)
 -
 -static inline
 -void efi_set_u64_split(u64 data, u32 *lo, u32 *hi)
 -{
 -	*lo = lower_32_bits(data);
 -	*hi = upper_32_bits(data);
 -}
 -
 -/*
 - * Allocation types for calls to boottime->allocate_pages.
 - */
 -#define EFI_ALLOCATE_ANY_PAGES		0
 -#define EFI_ALLOCATE_MAX_ADDRESS	1
 -#define EFI_ALLOCATE_ADDRESS		2
 -#define EFI_MAX_ALLOCATE_TYPE		3
 -
 -/*
 - * The type of search to perform when calling boottime->locate_handle
 - */
 -#define EFI_LOCATE_ALL_HANDLES			0
 -#define EFI_LOCATE_BY_REGISTER_NOTIFY		1
 -#define EFI_LOCATE_BY_PROTOCOL			2
 -
 -/*
 - * boottime->stall takes the time period in microseconds
 - */
 -#define EFI_USEC_PER_SEC		1000000
 -
 -/*
 - * boottime->set_timer takes the time in 100ns units
 - */
 -#define EFI_100NSEC_PER_USEC	((u64)10)
 -
 -/*
 - * An efi_boot_memmap is used by efi_get_memory_map() to return the
 - * EFI memory map in a dynamically allocated buffer.
 - *
 - * The buffer allocated for the EFI memory map includes extra room for
 - * a minimum of EFI_MMAP_NR_SLACK_SLOTS additional EFI memory descriptors.
 - * This facilitates the reuse of the EFI memory map buffer when a second
 - * call to ExitBootServices() is needed because of intervening changes to
 - * the EFI memory map. Other related structures, e.g. x86 e820ext, need
 - * to factor in this headroom requirement as well.
 - */
 -#define EFI_MMAP_NR_SLACK_SLOTS	8
 -
 -typedef struct efi_generic_dev_path efi_device_path_protocol_t;
 -
 -union efi_device_path_to_text_protocol {
 -	struct {
 -		efi_char16_t *(__efiapi *convert_device_node_to_text)(
 -					const efi_device_path_protocol_t *,
 -					bool, bool);
 -		efi_char16_t *(__efiapi *convert_device_path_to_text)(
 -					const efi_device_path_protocol_t *,
 -					bool, bool);
 -	};
 -	struct {
 -		u32 convert_device_node_to_text;
 -		u32 convert_device_path_to_text;
 -	} mixed_mode;
 -};
 -
 -typedef union efi_device_path_to_text_protocol efi_device_path_to_text_protocol_t;
 -
 -union efi_device_path_from_text_protocol {
 -	struct {
 -		efi_device_path_protocol_t *
 -			(__efiapi *convert_text_to_device_node)(const efi_char16_t *);
 -		efi_device_path_protocol_t *
 -			(__efiapi *convert_text_to_device_path)(const efi_char16_t *);
 -	};
 -	struct {
 -		u32 convert_text_to_device_node;
 -		u32 convert_text_to_device_path;
 -	} mixed_mode;
 -};
 -
 -typedef union efi_device_path_from_text_protocol efi_device_path_from_text_protocol_t;
 -
 -typedef void *efi_event_t;
 -/* Note that notifications won't work in mixed mode */
 -typedef void (__efiapi *efi_event_notify_t)(efi_event_t, void *);
 -
 -#define EFI_EVT_TIMER		0x80000000U
 -#define EFI_EVT_RUNTIME		0x40000000U
 -#define EFI_EVT_NOTIFY_WAIT	0x00000100U
 -#define EFI_EVT_NOTIFY_SIGNAL	0x00000200U
 -
 -/**
 - * efi_set_event_at() - add event to events array
 - *
 - * @events:	array of UEFI events
 - * @ids:	index where to put the event in the array
 - * @event:	event to add to the aray
 - *
 - * boottime->wait_for_event() takes an array of events as input.
 - * Provide a helper to set it up correctly for mixed mode.
 - */
 -static inline
 -void efi_set_event_at(efi_event_t *events, size_t idx, efi_event_t event)
 -{
 -	if (efi_is_native())
 -		events[idx] = event;
 -	else
 -		((u32 *)events)[idx] = (u32)(unsigned long)event;
 -}
 -
 -#define EFI_TPL_APPLICATION	4
 -#define EFI_TPL_CALLBACK	8
 -#define EFI_TPL_NOTIFY		16
 -#define EFI_TPL_HIGH_LEVEL	31
 -
 -typedef enum {
 -	EfiTimerCancel,
 -	EfiTimerPeriodic,
 -	EfiTimerRelative
 -} EFI_TIMER_DELAY;
 -
 -/*
 - * EFI Boot Services table
 - */
 -union efi_boot_services {
 -	struct {
 -		efi_table_hdr_t hdr;
 -		void *raise_tpl;
 -		void *restore_tpl;
 -		efi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,
 -							efi_physical_addr_t *);
 -		efi_status_t (__efiapi *free_pages)(efi_physical_addr_t,
 -						    unsigned long);
 -		efi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,
 -							unsigned long *,
 -							unsigned long *, u32 *);
 -		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
 -						       void **);
 -		efi_status_t (__efiapi *free_pool)(void *);
 -		efi_status_t (__efiapi *create_event)(u32, unsigned long,
 -						      efi_event_notify_t, void *,
 -						      efi_event_t *);
 -		efi_status_t (__efiapi *set_timer)(efi_event_t,
 -						  EFI_TIMER_DELAY, u64);
 -		efi_status_t (__efiapi *wait_for_event)(unsigned long,
 -							efi_event_t *,
 -							unsigned long *);
 -		void *signal_event;
 -		efi_status_t (__efiapi *close_event)(efi_event_t);
 -		void *check_event;
 -		void *install_protocol_interface;
 -		void *reinstall_protocol_interface;
 -		void *uninstall_protocol_interface;
 -		efi_status_t (__efiapi *handle_protocol)(efi_handle_t,
 -							 efi_guid_t *, void **);
 -		void *__reserved;
 -		void *register_protocol_notify;
 -		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
 -						       void *, unsigned long *,
 -						       efi_handle_t *);
 -		efi_status_t (__efiapi *locate_device_path)(efi_guid_t *,
 -							    efi_device_path_protocol_t **,
 -							    efi_handle_t *);
 -		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
 -								     void *);
 -		efi_status_t (__efiapi *load_image)(bool, efi_handle_t,
 -						    efi_device_path_protocol_t *,
 -						    void *, unsigned long,
 -						    efi_handle_t *);
 -		efi_status_t (__efiapi *start_image)(efi_handle_t, unsigned long *,
 -						     efi_char16_t **);
 -		efi_status_t __noreturn (__efiapi *exit)(efi_handle_t,
 -							 efi_status_t,
 -							 unsigned long,
 -							 efi_char16_t *);
 -		efi_status_t (__efiapi *unload_image)(efi_handle_t);
 -		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
 -							    unsigned long);
 -		void *get_next_monotonic_count;
 -		efi_status_t (__efiapi *stall)(unsigned long);
 -		void *set_watchdog_timer;
 -		void *connect_controller;
 -		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
 -							       efi_handle_t,
 -							       efi_handle_t);
 -		void *open_protocol;
 -		void *close_protocol;
 -		void *open_protocol_information;
 -		void *protocols_per_handle;
 -		void *locate_handle_buffer;
 -		efi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,
 -							 void **);
 -		efi_status_t (__efiapi *install_multiple_protocol_interfaces)(efi_handle_t *, ...);
 -		efi_status_t (__efiapi *uninstall_multiple_protocol_interfaces)(efi_handle_t, ...);
 -		void *calculate_crc32;
 -		void (__efiapi *copy_mem)(void *, const void *, unsigned long);
 -		void (__efiapi *set_mem)(void *, unsigned long, unsigned char);
 -		void *create_event_ex;
 -	};
 -	struct {
 -		efi_table_hdr_t hdr;
 -		u32 raise_tpl;
 -		u32 restore_tpl;
 -		u32 allocate_pages;
 -		u32 free_pages;
 -		u32 get_memory_map;
 -		u32 allocate_pool;
 -		u32 free_pool;
 -		u32 create_event;
 -		u32 set_timer;
 -		u32 wait_for_event;
 -		u32 signal_event;
 -		u32 close_event;
 -		u32 check_event;
 -		u32 install_protocol_interface;
 -		u32 reinstall_protocol_interface;
 -		u32 uninstall_protocol_interface;
 -		u32 handle_protocol;
 -		u32 __reserved;
 -		u32 register_protocol_notify;
 -		u32 locate_handle;
 -		u32 locate_device_path;
 -		u32 install_configuration_table;
 -		u32 load_image;
 -		u32 start_image;
 -		u32 exit;
 -		u32 unload_image;
 -		u32 exit_boot_services;
 -		u32 get_next_monotonic_count;
 -		u32 stall;
 -		u32 set_watchdog_timer;
 -		u32 connect_controller;
 -		u32 disconnect_controller;
 -		u32 open_protocol;
 -		u32 close_protocol;
 -		u32 open_protocol_information;
 -		u32 protocols_per_handle;
 -		u32 locate_handle_buffer;
 -		u32 locate_protocol;
 -		u32 install_multiple_protocol_interfaces;
 -		u32 uninstall_multiple_protocol_interfaces;
 -		u32 calculate_crc32;
 -		u32 copy_mem;
 -		u32 set_mem;
 -		u32 create_event_ex;
 -	} mixed_mode;
 -};
 -
 -typedef enum {
 -	EfiGcdMemoryTypeNonExistent,
 -	EfiGcdMemoryTypeReserved,
 -	EfiGcdMemoryTypeSystemMemory,
 -	EfiGcdMemoryTypeMemoryMappedIo,
 -	EfiGcdMemoryTypePersistent,
 -	EfiGcdMemoryTypeMoreReliable,
 -	EfiGcdMemoryTypeMaximum
 -} efi_gcd_memory_type_t;
 -
 -typedef struct {
 -	efi_physical_addr_t base_address;
 -	u64 length;
 -	u64 capabilities;
 -	u64 attributes;
 -	efi_gcd_memory_type_t gcd_memory_type;
 -	void *image_handle;
 -	void *device_handle;
 -} efi_gcd_memory_space_desc_t;
 -
 -/*
 - * EFI DXE Services table
 - */
 -union efi_dxe_services_table {
 -	struct {
 -		efi_table_hdr_t hdr;
 -		void *add_memory_space;
 -		void *allocate_memory_space;
 -		void *free_memory_space;
 -		void *remove_memory_space;
 -		efi_status_t (__efiapi *get_memory_space_descriptor)(efi_physical_addr_t,
 -								     efi_gcd_memory_space_desc_t *);
 -		efi_status_t (__efiapi *set_memory_space_attributes)(efi_physical_addr_t,
 -								     u64, u64);
 -		void *get_memory_space_map;
 -		void *add_io_space;
 -		void *allocate_io_space;
 -		void *free_io_space;
 -		void *remove_io_space;
 -		void *get_io_space_descriptor;
 -		void *get_io_space_map;
 -		void *dispatch;
 -		void *schedule;
 -		void *trust;
 -		void *process_firmware_volume;
 -		void *set_memory_space_capabilities;
 -	};
 -	struct {
 -		efi_table_hdr_t hdr;
 -		u32 add_memory_space;
 -		u32 allocate_memory_space;
 -		u32 free_memory_space;
 -		u32 remove_memory_space;
 -		u32 get_memory_space_descriptor;
 -		u32 set_memory_space_attributes;
 -		u32 get_memory_space_map;
 -		u32 add_io_space;
 -		u32 allocate_io_space;
 -		u32 free_io_space;
 -		u32 remove_io_space;
 -		u32 get_io_space_descriptor;
 -		u32 get_io_space_map;
 -		u32 dispatch;
 -		u32 schedule;
 -		u32 trust;
 -		u32 process_firmware_volume;
 -		u32 set_memory_space_capabilities;
 -	} mixed_mode;
 -};
 -
 -typedef union efi_memory_attribute_protocol efi_memory_attribute_protocol_t;
 -
 -union efi_memory_attribute_protocol {
 -	struct {
 -		efi_status_t (__efiapi *get_memory_attributes)(
 -			efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64 *);
 -
 -		efi_status_t (__efiapi *set_memory_attributes)(
 -			efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);
 -
 -		efi_status_t (__efiapi *clear_memory_attributes)(
 -			efi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);
 -	};
 -	struct {
 -		u32 get_memory_attributes;
 -		u32 set_memory_attributes;
 -		u32 clear_memory_attributes;
 -	} mixed_mode;
 -};
 -
 -typedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;
 -
 -union efi_uga_draw_protocol {
 -	struct {
 -		efi_status_t (__efiapi *get_mode)(efi_uga_draw_protocol_t *,
 -						  u32*, u32*, u32*, u32*);
 -		void *set_mode;
 -		void *blt;
 -	};
 -	struct {
 -		u32 get_mode;
 -		u32 set_mode;
 -		u32 blt;
 -	} mixed_mode;
 -};
 -
 -typedef struct {
 -	u16 scan_code;
 -	efi_char16_t unicode_char;
 -} efi_input_key_t;
 -
 -union efi_simple_text_input_protocol {
 -	struct {
 -		void *reset;
 -		efi_status_t (__efiapi *read_keystroke)(efi_simple_text_input_protocol_t *,
 -							efi_input_key_t *);
 -		efi_event_t wait_for_key;
 -	};
 -	struct {
 -		u32 reset;
 -		u32 read_keystroke;
 -		u32 wait_for_key;
 -	} mixed_mode;
 -};
 -
 -efi_status_t efi_wait_for_key(unsigned long usec, efi_input_key_t *key);
 -
 -union efi_simple_text_output_protocol {
 -	struct {
 -		void *reset;
 -		efi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,
 -						       efi_char16_t *);
 -		void *test_string;
 -	};
 -	struct {
 -		u32 reset;
 -		u32 output_string;
 -		u32 test_string;
 -	} mixed_mode;
 -};
 -
 -#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
 -#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1
 -#define PIXEL_BIT_MASK					2
 -#define PIXEL_BLT_ONLY					3
 -#define PIXEL_FORMAT_MAX				4
 -
 -typedef struct {
 -	u32 red_mask;
 -	u32 green_mask;
 -	u32 blue_mask;
 -	u32 reserved_mask;
 -} efi_pixel_bitmask_t;
 -
 -typedef struct {
 -	u32 version;
 -	u32 horizontal_resolution;
 -	u32 vertical_resolution;
 -	int pixel_format;
 -	efi_pixel_bitmask_t pixel_information;
 -	u32 pixels_per_scan_line;
 -} efi_graphics_output_mode_info_t;
 -
 -typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
 -
 -union efi_graphics_output_protocol_mode {
 -	struct {
 -		u32 max_mode;
 -		u32 mode;
 -		efi_graphics_output_mode_info_t *info;
 -		unsigned long size_of_info;
 -		efi_physical_addr_t frame_buffer_base;
 -		unsigned long frame_buffer_size;
 -	};
 -	struct {
 -		u32 max_mode;
 -		u32 mode;
 -		u32 info;
 -		u32 size_of_info;
 -		u64 frame_buffer_base;
 -		u32 frame_buffer_size;
 -	} mixed_mode;
 -};
 -
 -typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
 -
 -union efi_graphics_output_protocol {
 -	struct {
 -		efi_status_t (__efiapi *query_mode)(efi_graphics_output_protocol_t *,
 -						    u32, unsigned long *,
 -						    efi_graphics_output_mode_info_t **);
 -		efi_status_t (__efiapi *set_mode)  (efi_graphics_output_protocol_t *, u32);
 -		void *blt;
 -		efi_graphics_output_protocol_mode_t *mode;
 -	};
 -	struct {
 -		u32 query_mode;
 -		u32 set_mode;
 -		u32 blt;
 -		u32 mode;
 -	} mixed_mode;
 -};
 -
 -typedef union {
 -	struct {
 -		u32			revision;
 -		efi_handle_t		parent_handle;
 -		efi_system_table_t	*system_table;
 -		efi_handle_t		device_handle;
 -		void			*file_path;
 -		void			*reserved;
 -		u32			load_options_size;
 -		void			*load_options;
 -		void			*image_base;
 -		__aligned_u64		image_size;
 -		unsigned int		image_code_type;
 -		unsigned int		image_data_type;
 -		efi_status_t		(__efiapi *unload)(efi_handle_t image_handle);
 -	};
 -	struct {
 -		u32		revision;
 -		u32		parent_handle;
 -		u32		system_table;
 -		u32		device_handle;
 -		u32		file_path;
 -		u32		reserved;
 -		u32		load_options_size;
 -		u32		load_options;
 -		u32		image_base;
 -		__aligned_u64	image_size;
 -		u32		image_code_type;
 -		u32		image_data_type;
 -		u32		unload;
 -	} mixed_mode;
 -} efi_loaded_image_t;
 -
 -typedef struct {
 -	u64			size;
 -	u64			file_size;
 -	u64			phys_size;
 -	efi_time_t		create_time;
 -	efi_time_t		last_access_time;
 -	efi_time_t		modification_time;
 -	__aligned_u64		attribute;
 -	efi_char16_t		filename[];
 -} efi_file_info_t;
 -
 -typedef union efi_file_protocol efi_file_protocol_t;
 +#define pr_efi(sys_table, msg)		do {				\
 +	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\
 +} while (0)
  
 -union efi_file_protocol {
 -	struct {
 -		u64		revision;
 -		efi_status_t	(__efiapi *open)	(efi_file_protocol_t *,
 -							 efi_file_protocol_t **,
 -							 efi_char16_t *, u64,
 -							 u64);
 -		efi_status_t	(__efiapi *close)	(efi_file_protocol_t *);
 -		efi_status_t	(__efiapi *delete)	(efi_file_protocol_t *);
 -		efi_status_t	(__efiapi *read)	(efi_file_protocol_t *,
 -							 unsigned long *,
 -							 void *);
 -		efi_status_t	(__efiapi *write)	(efi_file_protocol_t *,
 -							 unsigned long, void *);
 -		efi_status_t	(__efiapi *get_position)(efi_file_protocol_t *,
 -							 u64 *);
 -		efi_status_t	(__efiapi *set_position)(efi_file_protocol_t *,
 -							 u64);
 -		efi_status_t	(__efiapi *get_info)	(efi_file_protocol_t *,
 -							 efi_guid_t *,
 -							 unsigned long *,
 -							 void *);
 -		efi_status_t	(__efiapi *set_info)	(efi_file_protocol_t *,
 -							 efi_guid_t *,
 -							 unsigned long,
 -							 void *);
 -		efi_status_t	(__efiapi *flush)	(efi_file_protocol_t *);
 -	};
 -	struct {
 -		u64 revision;
 -		u32 open;
 -		u32 close;
 -		u32 delete;
 -		u32 read;
 -		u32 write;
 -		u32 get_position;
 -		u32 set_position;
 -		u32 get_info;
 -		u32 set_info;
 -		u32 flush;
 -	} mixed_mode;
 -};
 +#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
  
 -typedef union efi_simple_file_system_protocol efi_simple_file_system_protocol_t;
 +void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
  
 -union efi_simple_file_system_protocol {
 -	struct {
 -		u64		revision;
 -		efi_status_t	(__efiapi *open_volume)(efi_simple_file_system_protocol_t *,
 -							efi_file_protocol_t **);
 -	};
 -	struct {
 -		u64 revision;
 -		u32 open_volume;
 -	} mixed_mode;
 -};
 +unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
  
 -#define EFI_FILE_MODE_READ	0x0000000000000001
 -#define EFI_FILE_MODE_WRITE	0x0000000000000002
 -#define EFI_FILE_MODE_CREATE	0x8000000000000000
 -
 -typedef enum {
 -	EfiPciIoWidthUint8,
 -	EfiPciIoWidthUint16,
 -	EfiPciIoWidthUint32,
 -	EfiPciIoWidthUint64,
 -	EfiPciIoWidthFifoUint8,
 -	EfiPciIoWidthFifoUint16,
 -	EfiPciIoWidthFifoUint32,
 -	EfiPciIoWidthFifoUint64,
 -	EfiPciIoWidthFillUint8,
 -	EfiPciIoWidthFillUint16,
 -	EfiPciIoWidthFillUint32,
 -	EfiPciIoWidthFillUint64,
 -	EfiPciIoWidthMaximum
 -} EFI_PCI_IO_PROTOCOL_WIDTH;
 -
 -typedef enum {
 -	EfiPciIoAttributeOperationGet,
 -	EfiPciIoAttributeOperationSet,
 -	EfiPciIoAttributeOperationEnable,
 -	EfiPciIoAttributeOperationDisable,
 -	EfiPciIoAttributeOperationSupported,
 -    EfiPciIoAttributeOperationMaximum
 -} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
 -
 -typedef struct {
 -	u32 read;
 -	u32 write;
 -} efi_pci_io_protocol_access_32_t;
 -
 -typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
 -
 -typedef
 -efi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
 -						   EFI_PCI_IO_PROTOCOL_WIDTH,
 -						   u32 offset,
 -						   unsigned long count,
 -						   void *buffer);
 -
 -typedef struct {
 -	void *read;
 -	void *write;
 -} efi_pci_io_protocol_access_t;
 -
 -typedef struct {
 -	efi_pci_io_protocol_cfg_t read;
 -	efi_pci_io_protocol_cfg_t write;
 -} efi_pci_io_protocol_config_access_t;
 -
 -union efi_pci_io_protocol {
 -	struct {
 -		void *poll_mem;
 -		void *poll_io;
 -		efi_pci_io_protocol_access_t mem;
 -		efi_pci_io_protocol_access_t io;
 -		efi_pci_io_protocol_config_access_t pci;
 -		void *copy_mem;
 -		void *map;
 -		void *unmap;
 -		void *allocate_buffer;
 -		void *free_buffer;
 -		void *flush;
 -		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
 -						      unsigned long *segment_nr,
 -						      unsigned long *bus_nr,
 -						      unsigned long *device_nr,
 -						      unsigned long *func_nr);
 -		void *attributes;
 -		void *get_bar_attributes;
 -		void *set_bar_attributes;
 -		uint64_t romsize;
 -		void *romimage;
 -	};
 -	struct {
 -		u32 poll_mem;
 -		u32 poll_io;
 -		efi_pci_io_protocol_access_32_t mem;
 -		efi_pci_io_protocol_access_32_t io;
 -		efi_pci_io_protocol_access_32_t pci;
 -		u32 copy_mem;
 -		u32 map;
 -		u32 unmap;
 -		u32 allocate_buffer;
 -		u32 free_buffer;
 -		u32 flush;
 -		u32 get_location;
 -		u32 attributes;
 -		u32 get_bar_attributes;
 -		u32 set_bar_attributes;
 -		u64 romsize;
 -		u32 romimage;
 -	} mixed_mode;
 -};
 -
 -#define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
 -#define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
 -#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
 -#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
 -#define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
 -#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
 -#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
 -#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
 -#define EFI_PCI_IO_ATTRIBUTE_IO 0x0100
 -#define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
 -#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
 -#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
 -#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
 -#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
 -#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
 -#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
 -#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
 -#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
 -#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
 -
 -struct efi_dev_path;
 -
 -typedef union apple_properties_protocol apple_properties_protocol_t;
 -
 -union apple_properties_protocol {
 -	struct {
 -		unsigned long version;
 -		efi_status_t (__efiapi *get)(apple_properties_protocol_t *,
 -					     struct efi_dev_path *,
 -					     efi_char16_t *, void *, u32 *);
 -		efi_status_t (__efiapi *set)(apple_properties_protocol_t *,
 -					     struct efi_dev_path *,
 -					     efi_char16_t *, void *, u32);
 -		efi_status_t (__efiapi *del)(apple_properties_protocol_t *,
 -					     struct efi_dev_path *,
 -					     efi_char16_t *);
 -		efi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,
 -						 void *buffer, u32 *);
 -	};
 -	struct {
 -		u32 version;
 -		u32 get;
 -		u32 set;
 -		u32 del;
 -		u32 get_all;
 -	} mixed_mode;
 -};
 -
 -typedef u32 efi_tcg2_event_log_format;
 -
 -#define INITRD_EVENT_TAG_ID 0x8F3B22ECU
 -#define LOAD_OPTIONS_EVENT_TAG_ID 0x8F3B22EDU
 -#define EV_EVENT_TAG 0x00000006U
 -#define EFI_TCG2_EVENT_HEADER_VERSION	0x1
 -
 -struct efi_tcg2_event {
 -	u32		event_size;
 -	struct {
 -		u32	header_size;
 -		u16	header_version;
 -		u32	pcr_index;
 -		u32	event_type;
 -	} __packed event_header;
 -	/* u8[] event follows here */
 -} __packed;
 -
 -struct efi_tcg2_tagged_event {
 -	u32 tagged_event_id;
 -	u32 tagged_event_data_size;
 -	/* u8  tagged event data follows here */
 -} __packed;
 -
 -typedef struct efi_tcg2_event efi_tcg2_event_t;
 -typedef struct efi_tcg2_tagged_event efi_tcg2_tagged_event_t;
 -typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
 -
 -union efi_tcg2_protocol {
 -	struct {
 -		void *get_capability;
 -		efi_status_t (__efiapi *get_event_log)(efi_tcg2_protocol_t *,
 -						       efi_tcg2_event_log_format,
 -						       efi_physical_addr_t *,
 -						       efi_physical_addr_t *,
 -						       efi_bool_t *);
 -		efi_status_t (__efiapi *hash_log_extend_event)(efi_tcg2_protocol_t *,
 -							       u64,
 -							       efi_physical_addr_t,
 -							       u64,
 -							       const efi_tcg2_event_t *);
 -		void *submit_command;
 -		void *get_active_pcr_banks;
 -		void *set_active_pcr_banks;
 -		void *get_result_of_set_active_pcr_banks;
 -	};
 -	struct {
 -		u32 get_capability;
 -		u32 get_event_log;
 -		u32 hash_log_extend_event;
 -		u32 submit_command;
 -		u32 get_active_pcr_banks;
 -		u32 set_active_pcr_banks;
 -		u32 get_result_of_set_active_pcr_banks;
 -	} mixed_mode;
 -};
 -
 -struct riscv_efi_boot_protocol {
 -	u64 revision;
 -
 -	efi_status_t (__efiapi *get_boot_hartid)(struct riscv_efi_boot_protocol *,
 -						 unsigned long *boot_hartid);
 -};
 -
 -typedef union efi_load_file_protocol efi_load_file_protocol_t;
 -typedef union efi_load_file_protocol efi_load_file2_protocol_t;
 -
 -union efi_load_file_protocol {
 -	struct {
 -		efi_status_t (__efiapi *load_file)(efi_load_file_protocol_t *,
 -						   efi_device_path_protocol_t *,
 -						   bool, unsigned long *, void *);
 -	};
 -	struct {
 -		u32 load_file;
 -	} mixed_mode;
 -};
 -
 -typedef struct {
 -	u32 attributes;
 -	u16 file_path_list_length;
 -	u8 variable_data[];
 -	// efi_char16_t description[];
 -	// efi_device_path_protocol_t file_path_list[];
 -	// u8 optional_data[];
 -} __packed efi_load_option_t;
 -
 -#define EFI_LOAD_OPTION_ACTIVE		0x0001U
 -#define EFI_LOAD_OPTION_FORCE_RECONNECT	0x0002U
 -#define EFI_LOAD_OPTION_HIDDEN		0x0008U
 -#define EFI_LOAD_OPTION_CATEGORY	0x1f00U
 -#define   EFI_LOAD_OPTION_CATEGORY_BOOT	0x0000U
 -#define   EFI_LOAD_OPTION_CATEGORY_APP	0x0100U
 -
 -#define EFI_LOAD_OPTION_BOOT_MASK \
 -	(EFI_LOAD_OPTION_ACTIVE|EFI_LOAD_OPTION_HIDDEN|EFI_LOAD_OPTION_CATEGORY)
 -#define EFI_LOAD_OPTION_MASK (EFI_LOAD_OPTION_FORCE_RECONNECT|EFI_LOAD_OPTION_BOOT_MASK)
 -
 -typedef struct {
 -	u32 attributes;
 -	u16 file_path_list_length;
 -	const efi_char16_t *description;
 -	const efi_device_path_protocol_t *file_path_list;
 -	u32 optional_data_size;
 -	const void *optional_data;
 -} efi_load_option_unpacked_t;
 -
 -void efi_pci_disable_bridge_busmaster(void);
 -
 -typedef efi_status_t (*efi_exit_boot_map_processing)(
 -	struct efi_boot_memmap *map,
 -	void *priv);
 -
 -efi_status_t efi_exit_boot_services(void *handle, void *priv,
 -				    efi_exit_boot_map_processing priv_func);
 -
 -efi_status_t efi_boot_kernel(void *handle, efi_loaded_image_t *image,
 -			     unsigned long kernel_addr, char *cmdline_ptr);
 +efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 +					    void *handle,
 +					    unsigned long *new_fdt_addr,
 +					    unsigned long max_addr,
 +					    u64 initrd_addr, u64 initrd_size,
 +					    char *cmdline_ptr,
 +					    unsigned long fdt_addr,
 +					    unsigned long fdt_size);
  
 -void *get_fdt(unsigned long *fdt_size);
 +void *get_fdt(efi_system_table_t *sys_table, unsigned long *fdt_size);
  
 -efi_status_t efi_alloc_virtmap(efi_memory_desc_t **virtmap,
 -			       unsigned long *desc_size, u32 *desc_ver);
  void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
  		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
  		     int *count);
* Unmerged path arch/x86/boot/compressed/eboot.c
* Unmerged path drivers/firmware/efi/libstub/Makefile
* Unmerged path drivers/firmware/efi/libstub/efi-stub-helper.c
* Unmerged path drivers/firmware/efi/libstub/efistub.h
diff --git a/drivers/firmware/efi/libstub/x86-5lvl.c b/drivers/firmware/efi/libstub/x86-5lvl.c
new file mode 100644
index 000000000000..479dd445acdc
--- /dev/null
+++ b/drivers/firmware/efi/libstub/x86-5lvl.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <linux/efi.h>
+
+#include <asm/boot.h>
+#include <asm/desc.h>
+#include <asm/efi.h>
+
+#include "efistub.h"
+#include "x86-stub.h"
+
+bool efi_no5lvl;
+
+static void (*la57_toggle)(void *cr3);
+
+static const struct desc_struct gdt[] = {
+	[GDT_ENTRY_KERNEL32_CS] = GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),
+	[GDT_ENTRY_KERNEL_CS]   = GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),
+};
+
+/*
+ * Enabling (or disabling) 5 level paging is tricky, because it can only be
+ * done from 32-bit mode with paging disabled. This means not only that the
+ * code itself must be running from 32-bit addressable physical memory, but
+ * also that the root page table must be 32-bit addressable, as programming
+ * a 64-bit value into CR3 when running in 32-bit mode is not supported.
+ */
+efi_status_t efi_setup_5level_paging(void)
+{
+	u8 tmpl_size = (u8 *)&trampoline_ljmp_imm_offset - (u8 *)&trampoline_32bit_src;
+	efi_status_t status;
+	u8 *la57_code;
+
+	if (!efi_is_64bit())
+		return EFI_SUCCESS;
+
+	/* check for 5 level paging support */
+	if (native_cpuid_eax(0) < 7 ||
+	    !(native_cpuid_ecx(7) & (1 << (X86_FEATURE_LA57 & 31))))
+		return EFI_SUCCESS;
+
+	/* allocate some 32-bit addressable memory for code and a page table */
+	status = efi_allocate_pages(2 * PAGE_SIZE, (unsigned long *)&la57_code,
+				    U32_MAX);
+	if (status != EFI_SUCCESS)
+		return status;
+
+	la57_toggle = memcpy(la57_code, trampoline_32bit_src, tmpl_size);
+	memset(la57_code + tmpl_size, 0x90, PAGE_SIZE - tmpl_size);
+
+	/*
+	 * To avoid the need to allocate a 32-bit addressable stack, the
+	 * trampoline uses a LJMP instruction to switch back to long mode.
+	 * LJMP takes an absolute destination address, which needs to be
+	 * fixed up at runtime.
+	 */
+	*(u32 *)&la57_code[trampoline_ljmp_imm_offset] += (unsigned long)la57_code;
+
+	efi_adjust_memory_range_protection((unsigned long)la57_toggle, PAGE_SIZE);
+
+	return EFI_SUCCESS;
+}
+
+void efi_5level_switch(void)
+{
+	bool want_la57 = IS_ENABLED(CONFIG_X86_5LEVEL) && !efi_no5lvl;
+	bool have_la57 = native_read_cr4() & X86_CR4_LA57;
+	bool need_toggle = want_la57 ^ have_la57;
+	u64 *pgt = (void *)la57_toggle + PAGE_SIZE;
+	u64 *cr3 = (u64 *)__native_read_cr3();
+	u64 *new_cr3;
+
+	if (!la57_toggle || !need_toggle)
+		return;
+
+	if (!have_la57) {
+		/*
+		 * 5 level paging will be enabled, so a root level page needs
+		 * to be allocated from the 32-bit addressable physical region,
+		 * with its first entry referring to the existing hierarchy.
+		 */
+		new_cr3 = memset(pgt, 0, PAGE_SIZE);
+		new_cr3[0] = (u64)cr3 | _PAGE_TABLE_NOENC;
+	} else {
+		/* take the new root table pointer from the current entry #0 */
+		new_cr3 = (u64 *)(cr3[0] & PAGE_MASK);
+
+		/* copy the new root table if it is not 32-bit addressable */
+		if ((u64)new_cr3 > U32_MAX)
+			new_cr3 = memcpy(pgt, new_cr3, PAGE_SIZE);
+	}
+
+	native_load_gdt(&(struct desc_ptr){ sizeof(gdt) - 1, (u64)gdt });
+
+	la57_toggle(new_cr3);
+}
diff --git a/drivers/firmware/efi/libstub/x86-stub.h b/drivers/firmware/efi/libstub/x86-stub.h
new file mode 100644
index 000000000000..37c5a36b9d8c
--- /dev/null
+++ b/drivers/firmware/efi/libstub/x86-stub.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#include <linux/efi.h>
+
+extern void trampoline_32bit_src(void *, bool);
+extern const u16 trampoline_ljmp_imm_offset;
+
+void efi_adjust_memory_range_protection(unsigned long start,
+					unsigned long size);
+
+#ifdef CONFIG_X86_64
+efi_status_t efi_setup_5level_paging(void);
+void efi_5level_switch(void);
+#else
+static inline efi_status_t efi_setup_5level_paging(void) { return EFI_SUCCESS; }
+static inline void efi_5level_switch(void) {}
+#endif
