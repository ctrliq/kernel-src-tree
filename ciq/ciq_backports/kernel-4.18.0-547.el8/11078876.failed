x86/efistub: Prefer EFI memory attributes protocol over DXE services

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 11078876b7a6a1b7226344fecab968945c806832
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/11078876.failed

Currently, the EFI stub relies on DXE services in some cases to clear
non-execute restrictions from page allocations that need to be
executable. This is dodgy, because DXE services are not specified by
UEFI but by PI, and they are not intended for consumption by OS loaders.
However, no alternative existed at the time.

Now, there is a new UEFI protocol that should be used instead, so if it
exists, prefer it over the DXE services calls.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Link: https://lore.kernel.org/r/20230807162720.545787-18-ardb@kernel.org
(cherry picked from commit 11078876b7a6a1b7226344fecab968945c806832)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index c2a7652f4460,acb1c65bf8ac..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -17,38 -16,28 +17,46 @@@
  #include <asm/desc.h>
  #include <asm/boot.h>
  
 -#include "efistub.h"
 -#include "x86-stub.h"
 +#include "../string.h"
 +#include "eboot.h"
  
 -/* Maximum physical address for 64-bit kernel with 4-level paging */
 -#define MAXMEM_X86_64_4LEVEL (1ull << 46)
 +static efi_system_table_t *sys_table;
 +static const efi_dxe_services_table_t *efi_dxe_table;
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +static struct efi_config *efi_early;
++=======
+ const efi_system_table_t *efi_system_table;
+ const efi_dxe_services_table_t *efi_dxe_table;
+ u32 image_offset __section(".data");
+ static efi_loaded_image_t *image = NULL;
+ static efi_memory_attribute_protocol_t *memattr;
++>>>>>>> 11078876b7a6 (x86/efistub: Prefer EFI memory attributes protocol over DXE services):drivers/firmware/efi/libstub/x86-stub.c
  
 -typedef union sev_memory_acceptance_protocol sev_memory_acceptance_protocol_t;
 -union sev_memory_acceptance_protocol {
 -	struct {
 -		efi_status_t (__efiapi * allow_unaccepted_memory)(
 -			sev_memory_acceptance_protocol_t *);
 -	};
 -	struct {
 -		u32 allow_unaccepted_memory;
 -	} mixed_mode;
 -};
 +__pure const struct efi_config *__efi_early(void)
 +{
 +	return efi_early;
 +}
 +
 +#define BOOT_SERVICES(bits)						\
 +static void setup_boot_services##bits(struct efi_config *c)		\
 +{									\
 +	efi_system_table_##bits##_t *table;				\
 +									\
 +	table = (typeof(table))sys_table;				\
 +									\
 +	c->runtime_services	= table->runtime;			\
 +	c->boot_services	= table->boottime;			\
 +	c->text_output		= table->con_out;			\
 +}
 +BOOT_SERVICES(32);
 +BOOT_SERVICES(64);
 +
 +void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 +{
 +	efi_call_proto(efi_simple_text_output_protocol, output_string,
 +		       efi_early->text_output, str);
 +}
  
  static efi_status_t
  preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
@@@ -840,55 -790,93 +854,77 @@@ static efi_status_t exit_boot(struct bo
  	return EFI_SUCCESS;
  }
  
 -static void __noreturn enter_kernel(unsigned long kernel_addr,
 -				    struct boot_params *boot_params)
 -{
 -	/* enter decompressed kernel with boot_params pointer in RSI/ESI */
 -	asm("jmp *%0"::"r"(kernel_addr), "S"(boot_params));
 -
 -	unreachable();
 -}
 -
  /*
 - * On success, this routine will jump to the relocated image directly and never
 - * return.  On failure, it will exit to the firmware via efi_exit() instead of
 - * returning.
 + * On success we return a pointer to a boot_params structure, and NULL
 + * on failure.
   */
 -void __noreturn efi_stub_entry(efi_handle_t handle,
 -			       efi_system_table_t *sys_table_arg,
 -			       struct boot_params *boot_params)
 +struct boot_params *
 +efi_main(struct efi_config *c, struct boot_params *boot_params)
  {
+ 	efi_guid_t guid = EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID;
  	unsigned long bzimage_addr = (unsigned long)startup_32;
 -	unsigned long buffer_start, buffer_end;
 +	struct desc_ptr *gdt = NULL;
 +	efi_loaded_image_t *image;
  	struct setup_header *hdr = &boot_params->hdr;
 -	const struct linux_efi_initrd *initrd = NULL;
  	efi_status_t status;
 +	struct desc_struct *desc;
 +	void *handle;
 +	efi_system_table_t *_table;
 +	bool is64;
 +	unsigned long cmdline_paddr;
 +
 +	efi_early = c;
 +
 +	_table = (efi_system_table_t *)(unsigned long)efi_early->table;
 +	handle = (void *)(unsigned long)efi_early->image_handle;
 +	is64 = efi_early->is64;
 +
 +	sys_table = _table;
  
 -	efi_system_table = sys_table_arg;
  	/* Check if we were booted by the EFI firmware */
 -	if (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 -		efi_exit(handle, EFI_INVALID_PARAMETER);
 +	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 +		goto fail;
 +
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	if (is64)
 +		setup_boot_services64(efi_early);
 +	else
 +		setup_boot_services32(efi_early);
  
 +	efi_dxe_table = get_efi_config_table(sys_table, EFI_DXE_SERVICES_TABLE_GUID);
 +	if (efi_dxe_table &&
 +	    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
 +		efi_printk(sys_table, "Ignoring DXE services table: invalid signature\n");
 +		efi_dxe_table = NULL;
 +	}
 +
++=======
+ 	if (IS_ENABLED(CONFIG_EFI_DXE_MEM_ATTRIBUTES)) {
+ 		efi_dxe_table = get_efi_config_table(EFI_DXE_SERVICES_TABLE_GUID);
+ 		if (efi_dxe_table &&
+ 		    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
+ 			efi_warn("Ignoring DXE services table: invalid signature\n");
+ 			efi_dxe_table = NULL;
+ 		}
+ 	}
+ 
+ 	/* grab the memory attributes protocol if it exists */
+ 	efi_bs_call(locate_protocol, &guid, NULL, (void **)&memattr);
+ 
+ 	status = efi_setup_5level_paging();
+ 	if (status != EFI_SUCCESS) {
+ 		efi_err("efi_setup_5level_paging() failed!\n");
+ 		goto fail;
+ 	}
+ 
++>>>>>>> 11078876b7a6 (x86/efistub: Prefer EFI memory attributes protocol over DXE services):drivers/firmware/efi/libstub/x86-stub.c
  	/*
 -	 * If the kernel isn't already loaded at a suitable address,
 -	 * relocate it.
 -	 *
 -	 * It must be loaded above LOAD_PHYSICAL_ADDR.
 -	 *
 -	 * The maximum address for 64-bit is 1 << 46 for 4-level paging. This
 -	 * is defined as the macro MAXMEM, but unfortunately that is not a
 -	 * compile-time constant if 5-level paging is configured, so we instead
 -	 * define our own macro for use here.
 -	 *
 -	 * For 32-bit, the maximum address is complicated to figure out, for
 -	 * now use KERNEL_IMAGE_SIZE, which will be 512MiB, the same as what
 -	 * KASLR uses.
 -	 *
 -	 * Also relocate it if image_offset is zero, i.e. the kernel wasn't
 -	 * loaded by LoadImage, but rather by a bootloader that called the
 -	 * handover entry. The reason we must always relocate in this case is
 -	 * to handle the case of systemd-boot booting a unified kernel image,
 -	 * which is a PE executable that contains the bzImage and an initrd as
 -	 * COFF sections. The initrd section is placed after the bzImage
 -	 * without ensuring that there are at least init_size bytes available
 -	 * for the bzImage, and thus the compressed kernel's startup code may
 -	 * overwrite the initrd unless it is moved out of the way.
 +	 * If the kernel isn't already loaded at the preferred load
 +	 * address, relocate it.
  	 */
 -
 -	buffer_start = ALIGN(bzimage_addr - image_offset,
 -			     hdr->kernel_alignment);
 -	buffer_end = buffer_start + hdr->init_size;
 -
 -	if ((buffer_start < LOAD_PHYSICAL_ADDR)				     ||
 -	    (IS_ENABLED(CONFIG_X86_32) && buffer_end > KERNEL_IMAGE_SIZE)    ||
 -	    (IS_ENABLED(CONFIG_X86_64) && buffer_end > MAXMEM_X86_64_4LEVEL) ||
 -	    (image_offset == 0)) {
 -		extern char _bss[];
 -
 -		status = efi_relocate_kernel(&bzimage_addr,
 -					     (unsigned long)_bss - bzimage_addr,
 -					     hdr->init_size,
 +	if (bzimage_addr != hdr->pref_address) {
 +		status = efi_relocate_kernel(sys_table, &bzimage_addr,
 +					     hdr->init_size, hdr->init_size,
  					     hdr->pref_address,
  					     hdr->kernel_alignment,
  					     LOAD_PHYSICAL_ADDR);
* Unmerged path arch/x86/boot/compressed/eboot.c
