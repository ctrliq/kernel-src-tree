x86/decompressor: Store boot_params pointer in callee save register

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 8b63cba746f86a754d66e302c43209cc9b9b6e39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/8b63cba7.failed

Instead of pushing and popping %RSI several times to preserve the struct
boot_params pointer across the execution of the startup code, move it
into a callee save register before the first call into C, and copy it
back when needed.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Link: https://lore.kernel.org/r/20230807162720.545787-8-ardb@kernel.org
(cherry picked from commit 8b63cba746f86a754d66e302c43209cc9b9b6e39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/head_64.S
diff --cc arch/x86/boot/compressed/head_64.S
index 6cee4cfafe11,19bf810409e2..000000000000
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@@ -392,11 -447,25 +391,26 @@@ SYM_CODE_START(startup_64
  	/* Save the trampoline address in RCX */
  	movq	%rax, %rcx
  
 -	/* Set up 32-bit addressable stack */
 -	leaq	TRAMPOLINE_32BIT_STACK_END(%rcx), %rsp
 -
  	/*
++<<<<<<< HEAD
 +	 * Load the address of trampoline_return() into RDI.
 +	 * It will be used by the trampoline to return to the main code.
++=======
+ 	 * Preserve live 64-bit registers on the stack: this is necessary
+ 	 * because the architecture does not guarantee that GPRs will retain
+ 	 * their full 64-bit values across a 32-bit mode switch.
+ 	 */
+ 	pushq	%r15
+ 	pushq	%rbp
+ 	pushq	%rbx
+ 
+ 	/*
+ 	 * Push the 64-bit address of trampoline_return() onto the new stack.
+ 	 * It will be used by the trampoline to return to the main code. Due to
+ 	 * the 32-bit mode switch, it cannot be kept it in a register either.
++>>>>>>> 8b63cba746f8 (x86/decompressor: Store boot_params pointer in callee save register)
  	 */
  	leaq	trampoline_return(%rip), %rdi
 -	pushq	%rdi
  
  	/* Switch to compatibility mode (CS.L = 0 CS.D = 1) via far return */
  	pushq	$__KERNEL32_CS
@@@ -404,22 -473,22 +418,30 @@@
  	pushq	%rax
  	lretq
  trampoline_return:
++<<<<<<< HEAD
++=======
+ 	/* Restore live 64-bit registers */
+ 	popq	%rbx
+ 	popq	%rbp
+ 	popq	%r15
+ 
++>>>>>>> 8b63cba746f8 (x86/decompressor: Store boot_params pointer in callee save register)
  	/* Restore the stack, the 32-bit trampoline uses its own stack */
 -	leaq	rva(boot_stack_end)(%rbx), %rsp
 +	leaq	boot_stack_end(%rbx), %rsp
  
  	/*
  	 * cleanup_trampoline() would restore trampoline memory.
  	 *
  	 * RDI is address of the page table to use instead of page table
  	 * in trampoline memory (if required).
- 	 *
- 	 * RSI holds real mode data and needs to be preserved across
- 	 * this function call.
  	 */
++<<<<<<< HEAD
 +	pushq	%rsi
 +	leaq	top_pgtable(%rbx), %rdi
++=======
+ 	leaq	rva(top_pgtable)(%rbx), %rdi
++>>>>>>> 8b63cba746f8 (x86/decompressor: Store boot_params pointer in callee save register)
  	call	cleanup_trampoline
- 	popq	%rsi
  
  	/* Zero EFLAGS */
  	pushq	$0
@@@ -429,11 -498,10 +451,10 @@@
   * Copy the compressed kernel to the end of our buffer
   * where decompression in place becomes safe.
   */
- 	pushq	%rsi
  	leaq	(_bss-8)(%rip), %rsi
 -	leaq	rva(_bss-8)(%rbx), %rdi
 -	movl	$(_bss - startup_32), %ecx
 -	shrl	$3, %ecx
 +	leaq	(_bss-8)(%rbx), %rdi
 +	movq	$_bss /* - $startup_32 */, %rcx
 +	shrq	$3, %rcx
  	std
  	rep	movsq
  	cld
@@@ -536,8 -536,6 +556,11 @@@ SYM_FUNC_END(efi64_stub_entry
  	shrq	$3, %rcx
  	rep	stosq
  
++<<<<<<< HEAD
 +	pushq	%rsi
 +
++=======
++>>>>>>> 8b63cba746f8 (x86/decompressor: Store boot_params pointer in callee save register)
  	call	load_stage2_idt
  
  	/* Pass boot_params to initialize_identity_maps() */
@@@ -548,20 -545,21 +570,26 @@@
  /*
   * Do the extraction, and jump to the new kernel..
   */
- 	pushq	%rsi			/* Save the real mode argument */
- 	movq	%rsi, %rdi		/* real mode address */
+ 	/* pass struct boot_params pointer */
+ 	movq	%r15, %rdi
  	leaq	boot_heap(%rip), %rsi	/* malloc area for uncompression */
  	leaq	input_data(%rip), %rdx  /* input_data */
 -	movl	input_len(%rip), %ecx	/* input_len */
 +	movl	$z_input_len, %ecx	/* input_len */
  	movq	%rbp, %r8		/* output target address */
++<<<<<<< HEAD
 +	movl	$z_output_len, %r9d	/* decompressed length, end of relocs */
 +	call	extract_kernel		/* returns kernel location in %rax */
 +	popq	%rsi
++=======
+ 	movl	output_len(%rip), %r9d	/* decompressed length, end of relocs */
+ 	call	extract_kernel		/* returns kernel entry point in %rax */
++>>>>>>> 8b63cba746f8 (x86/decompressor: Store boot_params pointer in callee save register)
  
  /*
   * Jump to the decompressed kernel.
   */
+ 	movq	%r15, %rsi
  	jmp	*%rax
 -SYM_FUNC_END(.Lrelocated)
  
  	.code32
  /*
* Unmerged path arch/x86/boot/compressed/head_64.S
