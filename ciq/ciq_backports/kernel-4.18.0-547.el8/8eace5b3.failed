x86/boot: Omit compression buffer from PE/COFF image memory footprint

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-547.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 8eace5b3555606e684739bef5bcdfcfe68235257
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-547.el8/8eace5b3.failed

Now that the EFI stub decompresses the kernel and hands over to the
decompressed image directly, there is no longer a need to provide a
decompression buffer as part of the .BSS allocation of the PE/COFF
image. It also means the PE/COFF image can be loaded anywhere in memory,
and setting the preferred image base is unnecessary. So drop the
handling of this from the header and from the build tool.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20230912090051.4014114-22-ardb@google.com
(cherry picked from commit 8eace5b3555606e684739bef5bcdfcfe68235257)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/tools/build.c
diff --cc arch/x86/boot/tools/build.c
index d681aab2613e,0354c223e354..000000000000
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@@ -53,12 -53,19 +53,28 @@@ u8 buf[SETUP_SECT_MAX*512]
  
  #define PECOFF_RELOC_RESERVE 0x20
  
++<<<<<<< HEAD
 +unsigned long efi32_stub_entry;
 +unsigned long efi64_stub_entry;
 +unsigned long efi_pe_entry;
 +unsigned long startup_64;
 +unsigned long _ehead;
 +unsigned long _end;
++=======
+ #ifdef CONFIG_EFI_MIXED
+ #define PECOFF_COMPAT_RESERVE 0x20
+ #else
+ #define PECOFF_COMPAT_RESERVE 0x0
+ #endif
+ 
+ static unsigned long efi32_stub_entry;
+ static unsigned long efi64_stub_entry;
+ static unsigned long efi_pe_entry;
+ static unsigned long efi32_pe_entry;
+ static unsigned long kernel_info;
+ static unsigned long startup_64;
+ static unsigned long _end;
++>>>>>>> 8eace5b35556 (x86/boot: Omit compression buffer from PE/COFF image memory footprint)
  
  /*----------------------------------------------------------------------*/
  
@@@ -202,10 -212,23 +218,9 @@@ static void update_pecoff_setup_and_rel
  	 */
  	put_unaligned_le32(reloc_offset + 10, &buf[reloc_offset]);
  	put_unaligned_le32(10, &buf[reloc_offset + 4]);
 -
 -#ifdef CONFIG_EFI_MIXED
 -	update_pecoff_section_header(".compat", compat_offset, PECOFF_COMPAT_RESERVE);
 -
 -	/*
 -	 * Put the IA-32 machine type (0x14c) and the associated entry point
 -	 * address in the .compat section, so loaders can figure out which other
 -	 * execution modes this image supports.
 -	 */
 -	buf[compat_offset] = 0x1;
 -	buf[compat_offset + 1] = 0x8;
 -	put_unaligned_le16(0x14c, &buf[compat_offset + 2]);
 -	put_unaligned_le32(efi32_pe_entry + size, &buf[compat_offset + 4]);
 -#endif
  }
  
- static void update_pecoff_text(unsigned int text_start, unsigned int file_sz,
- 			       unsigned int init_sz)
+ static void update_pecoff_text(unsigned int text_start, unsigned int file_sz)
  {
  	unsigned int pe_header;
  	unsigned int text_sz = file_sz - text_start;
@@@ -312,8 -342,9 +326,7 @@@ static void parse_zoffset(char *fname
  		PARSE_ZOFS(p, efi32_stub_entry);
  		PARSE_ZOFS(p, efi64_stub_entry);
  		PARSE_ZOFS(p, efi_pe_entry);
 -		PARSE_ZOFS(p, efi32_pe_entry);
 -		PARSE_ZOFS(p, kernel_info);
  		PARSE_ZOFS(p, startup_64);
- 		PARSE_ZOFS(p, _ehead);
  		PARSE_ZOFS(p, _end);
  
  		p = strchr(p, '\n');
@@@ -390,30 -426,11 +403,14 @@@ int main(int argc, char ** argv
  	buf[0x1f1] = setup_sectors-1;
  	put_unaligned_le32(sys_size, &buf[0x1f4]);
  
- 	init_sz = get_unaligned_le32(&buf[0x260]);
- #ifdef CONFIG_EFI_STUB
- 	/*
- 	 * The decompression buffer will start at ImageBase. When relocating
- 	 * the compressed kernel to its end, we must ensure that the head
- 	 * section does not get overwritten.  The head section occupies
- 	 * [i, i + _ehead), and the destination is [init_sz - _end, init_sz).
- 	 *
- 	 * At present these should never overlap, because 'i' is at most 32k
- 	 * because of SETUP_SECT_MAX, '_ehead' is less than 1k, and the
- 	 * calculation of INIT_SIZE in boot/header.S ensures that
- 	 * 'init_sz - _end' is at least 64k.
- 	 *
- 	 * For future-proofing, increase init_sz if necessary.
- 	 */
- 
- 	if (init_sz - _end < i + _ehead) {
- 		init_sz = (i + _ehead + _end + 4095) & ~4095;
- 		put_unaligned_le32(init_sz, &buf[0x260]);
- 	}
- #endif
- 	update_pecoff_text(setup_sectors * 512, i + (sys_size * 16), init_sz);
+ 	update_pecoff_text(setup_sectors * 512, i + (sys_size * 16));
  
  	efi_stub_entry_update();
++<<<<<<< HEAD
++=======
+ 	/* Update kernel_info offset. */
+ 	put_unaligned_le32(kernel_info, &buf[0x268]);
++>>>>>>> 8eace5b35556 (x86/boot: Omit compression buffer from PE/COFF image memory footprint)
  
  	crc = partial_crc32(buf, i, crc);
  	if (fwrite(buf, 1, i, dest) != i)
diff --git a/arch/x86/boot/header.S b/arch/x86/boot/header.S
index 4df6cba47914..763bed306fcf 100644
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@ -148,12 +148,10 @@ optional_header:
 #endif
 
 extra_header_fields:
-	# PE specification requires ImageBase to be 64k aligned
-	.set	image_base, (LOAD_PHYSICAL_ADDR + 0xffff) & ~0xffff
 #ifdef CONFIG_X86_32
-	.long	image_base			# ImageBase
+	.long	0				# ImageBase
 #else
-	.quad	image_base			# ImageBase
+	.quad	0				# ImageBase
 #endif
 	.long	0x20				# SectionAlignment
 	.long	0x20				# FileAlignment
* Unmerged path arch/x86/boot/tools/build.c
