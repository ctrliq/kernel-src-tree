mm: memcg: use larger batches for proactive reclaim

jira LE-4623
Rebuild_History Non-Buildable kernel-4.18.0-553.81.1.el8_10
commit-author T.J. Mercier <tjmercier@google.com>
commit 287d5fedb377ddc232b216b882723305b27ae31a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.81.1.el8_10/287d5fed.failed

Before 388536ac291 ("mm:vmscan: fix inaccurate reclaim during proactive
reclaim") we passed the number of pages for the reclaim request directly
to try_to_free_mem_cgroup_pages, which could lead to significant
overreclaim.  After 0388536ac291 the number of pages was limited to a
maximum 32 (SWAP_CLUSTER_MAX) to reduce the amount of overreclaim. 
However such a small batch size caused a regression in reclaim performance
due to many more reclaim start/stop cycles inside memory_reclaim.  The
restart cost is amortized over more pages with larger batch sizes, and
becomes a significant component of the runtime if the batch size is too
small.

Reclaim tries to balance nr_to_reclaim fidelity with fairness across nodes
and cgroups over which the pages are spread.  As such, the bigger the
request, the bigger the absolute overreclaim error.  Historic in-kernel
users of reclaim have used fixed, small sized requests to approach an
appropriate reclaim rate over time.  When we reclaim a user request of
arbitrary size, use decaying batch sizes to manage error while maintaining
reasonable throughput.

MGLRU enabled - memcg LRU used
root - full reclaim       pages/sec   time (sec)
pre-0388536ac291      :    68047        10.46
post-0388536ac291     :    13742        inf
(reclaim-reclaimed)/4 :    67352        10.51

MGLRU enabled - memcg LRU not used
/uid_0 - 1G reclaim       pages/sec   time (sec)  overreclaim (MiB)
pre-0388536ac291      :    258822       1.12            107.8
post-0388536ac291     :    105174       2.49            3.5
(reclaim-reclaimed)/4 :    233396       1.12            -7.4

MGLRU enabled - memcg LRU not used
/uid_0 - full reclaim     pages/sec   time (sec)
pre-0388536ac291      :    72334        7.09
post-0388536ac291     :    38105        14.45
(reclaim-reclaimed)/4 :    72914        6.96

[tjmercier@google.com: v4]
  Link: https://lkml.kernel.org/r/20240206175251.3364296-1-tjmercier@google.com
Link: https://lkml.kernel.org/r/20240202233855.1236422-1-tjmercier@google.com
Fixes: 0388536ac291 ("mm:vmscan: fix inaccurate reclaim during proactive reclaim")
	Signed-off-by: T.J. Mercier <tjmercier@google.com>
	Reviewed-by: Yosry Ahmed <yosryahmed@google.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Michal Koutny <mkoutny@suse.com>
	Acked-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Muchun Song <songmuchun@bytedance.com>
	Cc: Efly Young <yangyifei03@kuaishou.com>
	Cc: Yu Zhao <yuzhao@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 287d5fedb377ddc232b216b882723305b27ae31a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index e3d7fee03b47,cb216d30a221..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -6753,7 -6979,10 +6753,9 @@@ static ssize_t memory_reclaim(struct ke
  	if (err)
  		return err;
  
 -	reclaim_options	= MEMCG_RECLAIM_MAY_SWAP | MEMCG_RECLAIM_PROACTIVE;
  	while (nr_reclaimed < nr_to_reclaim) {
+ 		/* Will converge on zero, but reclaim enforces a minimum */
+ 		unsigned long batch_size = (nr_to_reclaim - nr_reclaimed) / 4;
  		unsigned long reclaimed;
  
  		if (signal_pending(current))
@@@ -6768,8 -6997,7 +6770,12 @@@
  			lru_add_drain_all();
  
  		reclaimed = try_to_free_mem_cgroup_pages(memcg,
++<<<<<<< HEAD
 +					min(nr_to_reclaim - nr_reclaimed, SWAP_CLUSTER_MAX),
 +					GFP_KERNEL, true);
++=======
+ 					batch_size, GFP_KERNEL, reclaim_options);
++>>>>>>> 287d5fedb377 (mm: memcg: use larger batches for proactive reclaim)
  
  		if (!reclaimed && !nr_retries--)
  			return -EAGAIN;
* Unmerged path mm/memcontrol.c
