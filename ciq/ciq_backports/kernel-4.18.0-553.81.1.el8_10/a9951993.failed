mm: fix apply_to_existing_page_range()

jira LE-4623
Rebuild_History Non-Buildable kernel-4.18.0-553.81.1.el8_10
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit a995199384347261bb3f21b2e171fa7f988bd2f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.81.1.el8_10/a9951993.failed

In the case of apply_to_existing_page_range(), apply_to_pte_range() is
reached with 'create' set to false.  When !create, the loop over the PTE
page table is broken.

apply_to_pte_range() will only move to the next PTE entry if 'create' is
true or if the current entry is not pte_none().

This means that the user of apply_to_existing_page_range() will not have
'fn' called for any entries after the first pte_none() in the PTE page
table.

Fix the loop logic in apply_to_pte_range().

There are no known runtime issues from this, but the fix is trivial enough
for stable@ even without a known buggy user. 

Link: https://lkml.kernel.org/r/20250409094043.1629234-1-kirill.shutemov@linux.intel.com
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Fixes: be1db4753ee6 ("mm/memory.c: add apply_to_existing_page_range() helper")
	Cc: Daniel Axtens <dja@axtens.net>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit a995199384347261bb3f21b2e171fa7f988bd2f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
diff --cc mm/memory.c
index a628697ff682,44481fe7c629..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -2234,13 -2937,14 +2234,18 @@@ static int apply_to_pte_range(struct mm
  
  	if (fn) {
  		do {
++<<<<<<< HEAD
 +			if (create || !pte_none(*pte)) {
 +				err = fn(pte++, addr, data);
++=======
+ 			if (create || !pte_none(ptep_get(pte))) {
+ 				err = fn(pte, addr, data);
++>>>>>>> a99519938434 (mm: fix apply_to_existing_page_range())
  				if (err)
  					break;
  			}
- 		} while (addr += PAGE_SIZE, addr != end);
+ 		} while (pte++, addr += PAGE_SIZE, addr != end);
  	}
 -	*mask |= PGTBL_PTE_MODIFIED;
  
  	arch_leave_lazy_mmu_mode();
  
* Unmerged path mm/memory.c
