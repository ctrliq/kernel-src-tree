mm/vmalloc: extend __find_vmap_area() with one more argument

jira LE-4623
Rebuild_History Non-Buildable kernel-4.18.0-553.81.1.el8_10
commit-author Uladzislau Rezki (Sony) <urezki@gmail.com>
commit 899c6efe58dbe8cb9768057ffc206d03e5a89ce8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.81.1.el8_10/899c6efe.failed

__find_vmap_area() finds a "vmap_area" based on passed address.  It scan
the specific "vmap_area_root" rb-tree.  Extend the function with one extra
argument, so any tree can be specified where the search has to be done.

There is no functional change as a result of this patch.

Link: https://lkml.kernel.org/r/20220607093449.3100-5-urezki@gmail.com
	Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
	Reviewed-by: Baoquan He <bhe@redhat.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Nicholas Piggin <npiggin@gmail.com>
	Cc: Oleksiy Avramchenko <oleksiy.avramchenko@sony.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 899c6efe58dbe8cb9768057ffc206d03e5a89ce8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmalloc.c
diff --cc mm/vmalloc.c
index 18f338df308e,dd6cdb201195..000000000000
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@@ -437,10 -790,37 +437,39 @@@ unsigned long vmalloc_nr_pages(void
  	return atomic_long_read(&nr_vmalloc_pages);
  }
  
++<<<<<<< HEAD
 +static struct vmap_area *__find_vmap_area(unsigned long addr)
++=======
+ /* Look up the first VA which satisfies addr < va_end, NULL if none. */
+ static struct vmap_area *find_vmap_area_exceed_addr(unsigned long addr)
  {
+ 	struct vmap_area *va = NULL;
  	struct rb_node *n = vmap_area_root.rb_node;
  
+ 	addr = (unsigned long)kasan_reset_tag((void *)addr);
+ 
+ 	while (n) {
+ 		struct vmap_area *tmp;
+ 
+ 		tmp = rb_entry(n, struct vmap_area, rb_node);
+ 		if (tmp->va_end > addr) {
+ 			va = tmp;
+ 			if (tmp->va_start <= addr)
+ 				break;
+ 
+ 			n = n->rb_left;
+ 		} else
+ 			n = n->rb_right;
+ 	}
+ 
+ 	return va;
+ }
+ 
+ static struct vmap_area *__find_vmap_area(unsigned long addr, struct rb_root *root)
++>>>>>>> 899c6efe58db (mm/vmalloc: extend __find_vmap_area() with one more argument)
+ {
+ 	struct rb_node *n = root->rb_node;
+ 
 -	addr = (unsigned long)kasan_reset_tag((void *)addr);
 -
  	while (n) {
  		struct vmap_area *va;
  
* Unmerged path mm/vmalloc.c
