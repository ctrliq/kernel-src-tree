net/mlx5e: Convert TIR to a dedicated object

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Maxim Mikityanskiy <maximmi@nvidia.com>
commit a6696735d694b365bca45873e9dbca26120a8375
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/a6696735.failed

Code related to TIR is now encapsulated into a dedicated object and put
into new files en/tir.{c,h}. All usages are converted.

The Builder pattern is used to initialize a TIR. It allows to create a
multitude of different configurations, turning on and off some specific
features in different combinations, without having long parameter lists,
initializers per usage and repeating code in initializers.

	Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a6696735d694b365bca45873e9dbca26120a8375)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index b5072a3a2585,148e2f92881b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -27,7 -27,7 +27,11 @@@ mlx5_core-$(CONFIG_MLX5_CORE_EN) += en_
  		en_selftest.o en/port.o en/monitor_stats.o en/health.o \
  		en/reporter_tx.o en/reporter_rx.o en/params.o en/xsk/pool.o \
  		en/xsk/setup.o en/xsk/rx.o en/xsk/tx.o en/devlink.o en/ptp.o \
++<<<<<<< HEAD
 +		en/qos.o en/trap.o en/fs_tt_redirect.o
++=======
+ 		en/qos.o en/trap.o en/fs_tt_redirect.o en/rqt.o en/tir.o
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
  #
  # Netdev extra
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 73a162266789,6a72b6f0366a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -944,23 -921,7 +943,27 @@@ int mlx5e_vlan_rx_kill_vid(struct net_d
  			   u16 vid);
  void mlx5e_timestamp_init(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +struct mlx5e_redirect_rqt_param {
 +	bool is_rss;
 +	union {
 +		u32 rqn; /* Direct RQN (Non-RSS) */
 +		struct {
 +			u8 hfunc;
 +			struct mlx5e_channels *channels;
 +		} rss; /* RSS data */
 +	};
 +};
 +
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp);
 +void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_rss_params *rss_params,
 +				    const struct mlx5e_tirc_config *ttconfig,
 +				    void *tirc, bool inner);
 +void mlx5e_modify_tirs_hash(struct mlx5e_priv *priv, void *in);
++=======
+ int mlx5e_modify_tirs_hash(struct mlx5e_priv *priv);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  struct mlx5e_tirc_config mlx5e_tirc_get_default_config(enum mlx5e_traffic_types tt);
  
  struct mlx5e_xsk_param;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,9264d18b0964..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -1238,25 -1218,21 +1238,24 @@@ int mlx5e_set_rxfh(struct net_device *d
  		   const u8 *key, const u8 hfunc)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +	int inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
++=======
+ 	struct mlx5e_rss_params *rss;
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  	bool refresh_tirs = false;
  	bool refresh_rqt = false;
- 	void *in;
  
  	if ((hfunc != ETH_RSS_HASH_NO_CHANGE) &&
  	    (hfunc != ETH_RSS_HASH_XOR) &&
  	    (hfunc != ETH_RSS_HASH_TOP))
  		return -EINVAL;
  
- 	in = kvzalloc(inlen, GFP_KERNEL);
- 	if (!in)
- 		return -ENOMEM;
- 
  	mutex_lock(&priv->state_lock);
  
 -	rss = &priv->rx_res->rss_params;
 -
 -	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hash.hfunc) {
 -		rss->hash.hfunc = hfunc;
 +	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hfunc) {
 +		rss->hfunc = hfunc;
  		refresh_rqt = true;
  		refresh_tirs = true;
  	}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
index b416a8ee2eed,494f6f832407..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
@@@ -848,17 -847,13 +846,18 @@@ static int mlx5e_set_rss_hash_opt(struc
  	if (nfc->data & RXH_L4_B_2_3)
  		rx_hash_field |= MLX5_HASH_FIELD_SEL_L4_DPORT;
  
- 	in = kvzalloc(inlen, GFP_KERNEL);
- 	if (!in)
- 		return -ENOMEM;
- 
  	mutex_lock(&priv->state_lock);
  
 -	if (rx_hash_field == priv->rx_res->rss_params.rx_hash_fields[tt])
 +	if (rx_hash_field == priv->rss_params.rx_hash_fields[tt])
  		goto out;
  
++<<<<<<< HEAD
 +	priv->rss_params.rx_hash_fields[tt] = rx_hash_field;
 +	mlx5e_modify_tirs_hash(priv, in);
++=======
+ 	priv->rx_res->rss_params.rx_hash_fields[tt] = rx_hash_field;
+ 	mlx5e_modify_tirs_hash(priv);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
  out:
  	mutex_unlock(&priv->state_lock);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 15e30d82e985,7bed96a9c320..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2249,118 -2227,78 +2249,123 @@@ err_destroy_rqts
  	return err;
  }
  
 -static int mlx5e_create_xsk_rqts(struct mlx5e_priv *priv)
 +void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
  {
 -	int err;
 -	int ix;
 +	int i;
  
 -	for (ix = 0; ix < priv->max_nch; ix++) {
 -		err = mlx5e_rqt_init_direct(&priv->rx_res->channels[ix].xsk_rqt,
 -					    priv->mdev, false, priv->drop_rq.rqn);
 -		if (unlikely(err))
 -			goto err_destroy_rqts;
 -	}
 +	for (i = 0; i < n; i++)
 +		mlx5e_destroy_rqt(priv, &tirs[i].rqt);
 +}
  
 -	return 0;
++<<<<<<< HEAD
 +static int mlx5e_rx_hash_fn(int hfunc)
 +{
 +	return (hfunc == ETH_RSS_HASH_TOP) ?
 +	       MLX5_RX_HASH_FN_TOEPLITZ :
 +	       MLX5_RX_HASH_FN_INVERTED_XOR8;
 +}
  
 -err_destroy_rqts:
 -	mlx5_core_warn(priv->mdev, "create xsk rqts failed, %d\n", err);
 -	while (--ix >= 0)
 -		mlx5e_rqt_destroy(&priv->rx_res->channels[ix].xsk_rqt);
 +int mlx5e_bits_invert(unsigned long a, int size)
++=======
++static void mlx5e_redirect_rqts_to_channels(struct mlx5e_priv *priv,
++					    struct mlx5e_channels *chs)
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
 +{
 +	int inv = 0;
 +	int i;
  
 -	return err;
 +	for (i = 0; i < size; i++)
 +		inv |= (test_bit(size - i - 1, &a) ? 1 : 0) << i;
 +
 +	return inv;
  }
  
 -void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv)
 +static void mlx5e_fill_rqt_rqns(struct mlx5e_priv *priv, int sz,
 +				struct mlx5e_redirect_rqt_param rrp, void *rqtc)
  {
 -	unsigned int ix;
 +	int i;
  
 -	for (ix = 0; ix < priv->max_nch; ix++)
 -		mlx5e_rqt_destroy(&priv->rx_res->channels[ix].direct_rqt);
 +	for (i = 0; i < sz; i++) {
 +		u32 rqn;
 +
 +		if (rrp.is_rss) {
 +			int ix = i;
 +
 +			if (rrp.rss.hfunc == ETH_RSS_HASH_XOR)
 +				ix = mlx5e_bits_invert(i, ilog2(sz));
 +
 +			ix = priv->rss_params.indirection_rqt[ix];
 +			rqn = rrp.rss.channels->c[ix]->rq.rqn;
 +		} else {
 +			rqn = rrp.rqn;
 +		}
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
  }
  
 -static void mlx5e_destroy_xsk_rqts(struct mlx5e_priv *priv)
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp)
  {
 -	unsigned int ix;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	int inlen;
 +	u32 *in;
 +	int err;
  
 -	for (ix = 0; ix < priv->max_nch; ix++)
 -		mlx5e_rqt_destroy(&priv->rx_res->channels[ix].xsk_rqt);
 +	inlen = MLX5_ST_SZ_BYTES(modify_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(modify_rqt_in, in, ctx);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(modify_rqt_in, in, bitmask.rqn_list, 1);
 +	mlx5e_fill_rqt_rqns(priv, sz, rrp, rqtc);
 +	err = mlx5_core_modify_rqt(mdev, rqtn, in, inlen);
 +
 +	kvfree(in);
 +	return err;
  }
  
 -static void mlx5e_redirect_rqts_to_channels(struct mlx5e_priv *priv,
 -					    struct mlx5e_channels *chs)
 +static u32 mlx5e_get_direct_rqn(struct mlx5e_priv *priv, int ix,
 +				struct mlx5e_redirect_rqt_param rrp)
  {
 -	struct mlx5e_rx_res *res = priv->rx_res;
 -	unsigned int ix;
 -	u32 *rqns;
 +	if (!rrp.is_rss)
 +		return rrp.rqn;
  
 -	rqns = kvmalloc_array(chs->num, sizeof(*rqns), GFP_KERNEL);
 -	if (rqns) {
 -		for (ix = 0; ix < chs->num; ix++)
 -			rqns[ix] = chs->c[ix]->rq.rqn;
 +	if (ix >= rrp.rss.channels->num)
 +		return priv->drop_rq.rqn;
  
 -		mlx5e_rqt_redirect_indir(&res->indir_rqt, rqns, chs->num,
 -					 res->rss_params.hash.hfunc,
 -					 &res->rss_params.indir);
 -		kvfree(rqns);
 -	}
 -
 -	for (ix = 0; ix < priv->max_nch; ix++) {
 -		u32 rqn = priv->drop_rq.rqn;
 +	return rrp.rss.channels->c[ix]->rq.rqn;
 +}
  
 -		if (ix < chs->num)
 -			rqn = chs->c[ix]->rq.rqn;
 +static void mlx5e_redirect_rqts(struct mlx5e_priv *priv,
 +				struct mlx5e_redirect_rqt_param rrp)
 +{
 +	u32 rqtn;
 +	int ix;
  
 -		mlx5e_rqt_redirect_direct(&res->channels[ix].direct_rqt, rqn);
 +	if (priv->indir_rqt.enabled) {
 +		/* RSS RQ table */
 +		rqtn = priv->indir_rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
  	}
  
 -	if (priv->profile->rx_ptp_support) {
 -		u32 rqn;
 +	for (ix = 0; ix < priv->max_nch; ix++) {
 +		struct mlx5e_redirect_rqt_param direct_rrp = {
 +			.is_rss = false,
 +			{
 +				.rqn    = mlx5e_get_direct_rqn(priv, ix, rrp)
 +			},
 +		};
  
 -		if (mlx5e_ptp_get_rqn(priv->channels.ptp, &rqn))
 -			rqn = priv->drop_rq.rqn;
 +		/* Direct RQ Tables */
 +		if (!priv->direct_tir[ix].rqt.enabled)
 +			continue;
  
 -		mlx5e_rqt_redirect_direct(&res->ptp.rqt, rqn);
 +		rqtn = priv->direct_tir[ix].rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, 1, direct_rrp);
  	}
  }
  
@@@ -2440,130 -2364,91 +2445,190 @@@ struct mlx5e_tirc_config mlx5e_tirc_get
  	return tirc_default_config[tt];
  }
  
++<<<<<<< HEAD
 +static void mlx5e_build_tir_ctx_lro(struct mlx5e_params *params, void *tirc)
 +{
 +	if (!params->lro_en)
 +		return;
 +
 +#define ROUGH_MAX_L2_L3_HDR_SZ 256
 +
 +	MLX5_SET(tirc, tirc, lro_enable_mask,
 +		 MLX5_TIRC_LRO_ENABLE_MASK_IPV4_LRO |
 +		 MLX5_TIRC_LRO_ENABLE_MASK_IPV6_LRO);
 +	MLX5_SET(tirc, tirc, lro_max_ip_payload_size,
 +		 (MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ - ROUGH_MAX_L2_L3_HDR_SZ) >> 8);
 +	MLX5_SET(tirc, tirc, lro_timeout_period_usecs, params->lro_timeout);
 +}
 +
 +void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_rss_params *rss_params,
 +				    const struct mlx5e_tirc_config *ttconfig,
 +				    void *tirc, bool inner)
 +{
 +	void *hfso = inner ? MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner) :
 +			     MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);
 +
 +	MLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_rx_hash_fn(rss_params->hfunc));
 +	if (rss_params->hfunc == ETH_RSS_HASH_TOP) {
 +		void *rss_key = MLX5_ADDR_OF(tirc, tirc,
 +					     rx_hash_toeplitz_key);
 +		size_t len = MLX5_FLD_SZ_BYTES(tirc,
 +					       rx_hash_toeplitz_key);
 +
 +		MLX5_SET(tirc, tirc, rx_hash_symmetric, 1);
 +		memcpy(rss_key, rss_params->toeplitz_hash_key, len);
 +	}
 +	MLX5_SET(rx_hash_field_select, hfso, l3_prot_type,
 +		 ttconfig->l3_prot_type);
 +	MLX5_SET(rx_hash_field_select, hfso, l4_prot_type,
 +		 ttconfig->l4_prot_type);
 +	MLX5_SET(rx_hash_field_select, hfso, selected_fields,
 +		 ttconfig->rx_hash_fields);
 +}
 +
 +static void mlx5e_update_rx_hash_fields(struct mlx5e_tirc_config *ttconfig,
++=======
+ static void mlx5e_update_rx_hash_fields(struct mlx5e_rss_params_traffic_type *rss_tt,
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  					enum mlx5e_traffic_types tt,
  					u32 rx_hash_fields)
  {
- 	*ttconfig                = tirc_default_config[tt];
- 	ttconfig->rx_hash_fields = rx_hash_fields;
+ 	*rss_tt = (struct mlx5e_rss_params_traffic_type) {
+ 		.l3_prot_type = tirc_default_config[tt].l3_prot_type,
+ 		.l4_prot_type = tirc_default_config[tt].l4_prot_type,
+ 		.rx_hash_fields = rx_hash_fields,
+ 	};
  }
  
- void mlx5e_modify_tirs_hash(struct mlx5e_priv *priv, void *in)
+ int mlx5e_modify_tirs_hash(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	void *tirc = MLX5_ADDR_OF(modify_tir_in, in, ctx);
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	int ctxlen = MLX5_ST_SZ_BYTES(tirc);
 +	struct mlx5e_tirc_config ttconfig;
 +	int tt;
++=======
+ 	struct mlx5e_rss_params_hash *rss_hash = &priv->rx_res->rss_params.hash;
+ 	struct mlx5e_rss_params *rss = &priv->rx_res->rss_params;
+ 	struct mlx5e_rss_params_traffic_type rss_tt;
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	struct mlx5e_tir_builder *builder;
+ 	enum mlx5e_traffic_types tt;
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
- 	MLX5_SET(modify_tir_in, in, bitmask.hash, 1);
+ 	builder = mlx5e_tir_builder_alloc(true);
+ 	if (!builder)
+ 		return -ENOMEM;
  
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
++<<<<<<< HEAD
 +		memset(tirc, 0, ctxlen);
 +		mlx5e_update_rx_hash_fields(&ttconfig, tt,
 +					    rss->rx_hash_fields[tt]);
 +		mlx5e_build_indir_tir_ctx_hash(rss, &ttconfig, tirc, false);
 +		mlx5_core_modify_tir(mdev, priv->indir_tir[tt].tirn, in);
 +	}
 +
 +	/* Verify inner tirs resources allocated */
 +	if (!priv->inner_indir_tir[0].tirn)
 +		return;
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		memset(tirc, 0, ctxlen);
 +		mlx5e_update_rx_hash_fields(&ttconfig, tt,
 +					    rss->rx_hash_fields[tt]);
 +		mlx5e_build_indir_tir_ctx_hash(rss, &ttconfig, tirc, true);
 +		mlx5_core_modify_tir(mdev, priv->inner_indir_tir[tt].tirn, in);
++=======
+ 		mlx5e_update_rx_hash_fields(&rss_tt, tt, rss->rx_hash_fields[tt]);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, false);
+ 		mlx5e_tir_modify(&res->rss[tt].indir_tir, builder);
+ 		mlx5e_tir_builder_clear(builder);
  	}
+ 
+ 	/* Verify inner tirs resources allocated */
+ 	if (!res->rss[0].inner_indir_tir.tirn)
+ 		goto out;
+ 
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
+ 		mlx5e_update_rx_hash_fields(&rss_tt, tt, rss->rx_hash_fields[tt]);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, true);
+ 		mlx5e_tir_modify(&res->rss[tt].indir_tir, builder);
+ 		mlx5e_tir_builder_clear(builder);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
+ 	}
+ 
+ out:
+ 	mlx5e_tir_builder_free(builder);
+ 	return 0;
  }
  
  static int mlx5e_modify_tirs_lro(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
 +	void *in;
 +	void *tirc;
 +	int inlen;
++=======
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	struct mlx5e_tir_builder *builder;
+ 	struct mlx5e_lro_param lro_param;
+ 	enum mlx5e_traffic_types tt;
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  	int err;
- 	int tt;
  	int ix;
  
- 	inlen = MLX5_ST_SZ_BYTES(modify_tir_in);
- 	in = kvzalloc(inlen, GFP_KERNEL);
- 	if (!in)
+ 	builder = mlx5e_tir_builder_alloc(true);
+ 	if (!builder)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	MLX5_SET(modify_tir_in, in, bitmask.lro, 1);
 +	tirc = MLX5_ADDR_OF(modify_tir_in, in, ctx);
 +
 +	mlx5e_build_tir_ctx_lro(&priv->channels.params, tirc);
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		err = mlx5_core_modify_tir(mdev, priv->indir_tir[tt].tirn, in);
++=======
+ 	lro_param = mlx5e_get_lro_param(&priv->channels.params);
+ 	mlx5e_tir_builder_build_lro(builder, &lro_param);
+ 
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
+ 		err = mlx5e_tir_modify(&res->rss[tt].indir_tir, builder);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  		if (err)
- 			goto free_in;
+ 			goto err_free_builder;
  
  		/* Verify inner tirs resources allocated */
 -		if (!res->rss[0].inner_indir_tir.tirn)
 +		if (!priv->inner_indir_tir[0].tirn)
  			continue;
  
++<<<<<<< HEAD
 +		err = mlx5_core_modify_tir(mdev, priv->inner_indir_tir[tt].tirn, in);
++=======
+ 		err = mlx5e_tir_modify(&res->rss[tt].inner_indir_tir, builder);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  		if (err)
- 			goto free_in;
+ 			goto err_free_builder;
  	}
  
  	for (ix = 0; ix < priv->max_nch; ix++) {
++<<<<<<< HEAD
 +		err = mlx5_core_modify_tir(mdev, priv->direct_tir[ix].tirn, in);
++=======
+ 		err = mlx5e_tir_modify(&res->channels[ix].direct_tir, builder);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  		if (err)
- 			goto free_in;
+ 			goto err_free_builder;
  	}
  
- free_in:
- 	kvfree(in);
- 
+ err_free_builder:
+ 	mlx5e_tir_builder_free(builder);
  	return err;
  }
  
@@@ -3182,159 -3079,193 +3247,322 @@@ static void mlx5e_cleanup_nic_tx(struc
  	mlx5e_destroy_tises(priv);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_build_indir_tir_ctx_common(struct mlx5e_priv *priv,
 +					     u32 rqtn, u32 *tirc)
 +{
 +	MLX5_SET(tirc, tirc, transport_domain, priv->mdev->mlx5e_res.hw_objs.td.tdn);
 +	MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +	MLX5_SET(tirc, tirc, indirect_table, rqtn);
 +	MLX5_SET(tirc, tirc, tunneled_offload_en,
 +		 priv->channels.params.tunneled_offload_en);
 +
 +	mlx5e_build_tir_ctx_lro(&priv->channels.params, tirc);
 +}
 +
 +static void mlx5e_build_indir_tir_ctx(struct mlx5e_priv *priv,
 +				      enum mlx5e_traffic_types tt,
 +				      u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, priv->indir_rqt.rqtn, tirc);
 +	mlx5e_build_indir_tir_ctx_hash(&priv->rss_params,
 +				       &tirc_default_config[tt], tirc, false);
 +}
 +
 +static void mlx5e_build_direct_tir_ctx(struct mlx5e_priv *priv, u32 rqtn, u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, rqtn, tirc);
 +	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_INVERTED_XOR8);
 +}
 +
 +static void mlx5e_build_inner_indir_tir_ctx(struct mlx5e_priv *priv,
 +					    enum mlx5e_traffic_types tt,
 +					    u32 *tirc)
 +{
 +	mlx5e_build_indir_tir_ctx_common(priv, priv->indir_rqt.rqtn, tirc);
 +	mlx5e_build_indir_tir_ctx_hash(&priv->rss_params,
 +				       &tirc_default_config[tt], tirc, true);
 +}
 +
 +int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv, bool inner_ttc)
 +{
 +	struct mlx5e_tir *tir;
 +	void *tirc;
 +	int inlen;
 +	int i = 0;
 +	int err;
 +	u32 *in;
 +	int tt;
++=======
+ int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv, bool inner_ttc)
+ {
+ 	struct mlx5e_rss_params_hash *rss_hash = &priv->rx_res->rss_params.hash;
+ 	bool inner_ft_support = priv->channels.params.tunneled_offload_en;
+ 	struct mlx5e_rss_params *rss = &priv->rx_res->rss_params;
+ 	struct mlx5e_rss_params_traffic_type rss_tt;
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	enum mlx5e_traffic_types tt, max_tt;
+ 	struct mlx5e_tir_builder *builder;
+ 	struct mlx5e_lro_param lro_param;
+ 	u32 indir_rqtn;
+ 	int err = 0;
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
- 	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
- 	in = kvzalloc(inlen, GFP_KERNEL);
- 	if (!in)
+ 	builder = mlx5e_tir_builder_alloc(false);
+ 	if (!builder)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
 +		memset(in, 0, inlen);
 +		tir = &priv->indir_tir[tt];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_indir_tir_ctx(priv, tt, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
++=======
+ 	lro_param = mlx5e_get_lro_param(&priv->channels.params);
+ 	indir_rqtn = mlx5e_rqt_get_rqtn(&res->indir_rqt);
+ 
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
+ 		mlx5e_tir_builder_build_rqt(builder, priv->mdev->mlx5e_res.hw_objs.td.tdn,
+ 					    indir_rqtn, inner_ft_support);
+ 		mlx5e_tir_builder_build_lro(builder, &lro_param);
+ 		mlx5e_update_rx_hash_fields(&rss_tt, tt, rss->rx_hash_fields[tt]);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, false);
+ 
+ 		err = mlx5e_tir_init(&res->rss[tt].indir_tir, builder, priv->mdev, true);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  		if (err) {
  			mlx5_core_warn(priv->mdev, "create indirect tirs failed, %d\n", err);
- 			goto err_destroy_inner_tirs;
+ 			goto err_destroy_tirs;
  		}
+ 
+ 		mlx5e_tir_builder_clear(builder);
  	}
  
  	if (!inner_ttc || !mlx5e_tunnel_inner_ft_supported(priv->mdev))
  		goto out;
  
++<<<<<<< HEAD
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++) {
 +		memset(in, 0, inlen);
 +		tir = &priv->inner_indir_tir[i];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_inner_indir_tir_ctx(priv, i, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
++=======
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
+ 		mlx5e_tir_builder_build_rqt(builder, priv->mdev->mlx5e_res.hw_objs.td.tdn,
+ 					    indir_rqtn, inner_ft_support);
+ 		mlx5e_tir_builder_build_lro(builder, &lro_param);
+ 		mlx5e_update_rx_hash_fields(&rss_tt, tt, rss->rx_hash_fields[tt]);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, true);
+ 
+ 		err = mlx5e_tir_init(&res->rss[tt].inner_indir_tir, builder, priv->mdev, true);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  		if (err) {
  			mlx5_core_warn(priv->mdev, "create inner indirect tirs failed, %d\n", err);
  			goto err_destroy_inner_tirs;
  		}
- 	}
  
- out:
- 	kvfree(in);
+ 		mlx5e_tir_builder_clear(builder);
+ 	}
  
- 	return 0;
+ 	goto out;
  
  err_destroy_inner_tirs:
++<<<<<<< HEAD
 +	for (i--; i >= 0; i--)
 +		mlx5e_destroy_tir(priv->mdev, &priv->inner_indir_tir[i]);
 +
 +	for (tt--; tt >= 0; tt--)
 +		mlx5e_destroy_tir(priv->mdev, &priv->indir_tir[tt]);
++=======
+ 	max_tt = tt;
+ 	for (tt = 0; tt < max_tt; tt++)
+ 		mlx5e_tir_destroy(&res->rss[tt].inner_indir_tir);
+ 
+ 	tt = MLX5E_NUM_INDIR_TIRS;
+ err_destroy_tirs:
+ 	max_tt = tt;
+ 	for (tt = 0; tt < max_tt; tt++)
+ 		mlx5e_tir_destroy(&res->rss[tt].indir_tir);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
- 	kvfree(in);
+ out:
+ 	mlx5e_tir_builder_free(builder);
  
  	return err;
  }
  
++<<<<<<< HEAD
 +int mlx5e_create_direct_tirs(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
 +{
 +	struct mlx5e_tir *tir;
 +	void *tirc;
 +	int inlen;
 +	int err = 0;
 +	u32 *in;
 +	int ix;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	for (ix = 0; ix < n; ix++) {
 +		memset(in, 0, inlen);
 +		tir = &tirs[ix];
 +		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
 +		mlx5e_build_direct_tir_ctx(priv, tir->rqt.rqtn, tirc);
 +		err = mlx5e_create_tir(priv->mdev, tir, in);
 +		if (unlikely(err))
 +			goto err_destroy_ch_tirs;
 +	}
 +
 +	goto out;
 +
 +err_destroy_ch_tirs:
 +	mlx5_core_warn(priv->mdev, "create tirs failed, %d\n", err);
 +	for (ix--; ix >= 0; ix--)
 +		mlx5e_destroy_tir(priv->mdev, &tirs[ix]);
 +
 +out:
 +	kvfree(in);
++=======
+ static int mlx5e_create_direct_tir(struct mlx5e_priv *priv, struct mlx5e_tir *tir,
+ 				   struct mlx5e_tir_builder *builder, struct mlx5e_rqt *rqt)
+ {
+ 	bool inner_ft_support = priv->channels.params.tunneled_offload_en;
+ 	struct mlx5e_lro_param lro_param;
+ 	int err = 0;
+ 
+ 	lro_param = mlx5e_get_lro_param(&priv->channels.params);
+ 
+ 	mlx5e_tir_builder_build_rqt(builder, priv->mdev->mlx5e_res.hw_objs.td.tdn,
+ 				    mlx5e_rqt_get_rqtn(rqt), inner_ft_support);
+ 	mlx5e_tir_builder_build_lro(builder, &lro_param);
+ 	mlx5e_tir_builder_build_direct(builder);
+ 
+ 	err = mlx5e_tir_init(tir, builder, priv->mdev, true);
+ 	if (unlikely(err))
+ 		mlx5_core_warn(priv->mdev, "create tirs failed, %d\n", err);
+ 
+ 	mlx5e_tir_builder_clear(builder);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
  	return err;
  }
  
++<<<<<<< HEAD
 +void mlx5e_destroy_indirect_tirs(struct mlx5e_priv *priv)
 +{
 +	int i;
 +
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++)
 +		mlx5e_destroy_tir(priv->mdev, &priv->indir_tir[i]);
++=======
+ int mlx5e_create_direct_tirs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	struct mlx5e_tir_builder *builder;
+ 	int err = 0;
+ 	int ix;
+ 
+ 	builder = mlx5e_tir_builder_alloc(false);
+ 	if (!builder)
+ 		return -ENOMEM;
+ 
+ 	for (ix = 0; ix < priv->max_nch; ix++) {
+ 		err = mlx5e_create_direct_tir(priv, &res->channels[ix].direct_tir,
+ 					      builder, &res->channels[ix].direct_rqt);
+ 		if (err)
+ 			goto err_destroy_tirs;
+ 	}
+ 
+ 	goto out;
+ 
+ err_destroy_tirs:
+ 	while (--ix >= 0)
+ 		mlx5e_tir_destroy(&res->channels[ix].direct_tir);
+ 
+ out:
+ 	mlx5e_tir_builder_free(builder);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_create_xsk_tirs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	struct mlx5e_tir_builder *builder;
+ 	int err;
+ 	int ix;
+ 
+ 	builder = mlx5e_tir_builder_alloc(false);
+ 	if (!builder)
+ 		return -ENOMEM;
+ 
+ 	for (ix = 0; ix < priv->max_nch; ix++) {
+ 		err = mlx5e_create_direct_tir(priv, &res->channels[ix].xsk_tir,
+ 					      builder, &res->channels[ix].xsk_rqt);
+ 		if (err)
+ 			goto err_destroy_tirs;
+ 	}
+ 
+ 	goto out;
+ 
+ err_destroy_tirs:
+ 	while (--ix >= 0)
+ 		mlx5e_tir_destroy(&res->channels[ix].xsk_tir);
+ 
+ out:
+ 	mlx5e_tir_builder_free(builder);
+ 
+ 	return err;
+ }
+ 
+ void mlx5e_destroy_indirect_tirs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	enum mlx5e_traffic_types tt;
+ 
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
+ 		mlx5e_tir_destroy(&res->rss[tt].indir_tir);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  
  	/* Verify inner tirs resources allocated */
 -	if (!res->rss[0].inner_indir_tir.tirn)
 +	if (!priv->inner_indir_tir[0].tirn)
  		return;
  
++<<<<<<< HEAD
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++)
 +		mlx5e_destroy_tir(priv->mdev, &priv->inner_indir_tir[i]);
++=======
+ 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
+ 		mlx5e_tir_destroy(&res->rss[tt].inner_indir_tir);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  }
  
 -void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv)
 +void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
  {
 -	unsigned int ix;
 +	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < n; i++)
 +		mlx5e_destroy_tir(priv->mdev, &tirs[i]);
++=======
+ 	for (ix = 0; ix < priv->max_nch; ix++)
+ 		mlx5e_tir_destroy(&priv->rx_res->channels[ix].direct_tir);
+ }
+ 
+ static void mlx5e_destroy_xsk_tirs(struct mlx5e_priv *priv)
+ {
+ 	unsigned int ix;
+ 
+ 	for (ix = 0; ix < priv->max_nch; ix++)
+ 		mlx5e_tir_destroy(&priv->rx_res->channels[ix].xsk_tir);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  }
  
  static int mlx5e_modify_channels_scatter_fcs(struct mlx5e_channels *chs, bool enable)
@@@ -4999,10 -4873,14 +5227,14 @@@ static void mlx5e_nic_cleanup(struct ml
  static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
++<<<<<<< HEAD
 +	u16 max_nch = priv->max_nch;
++=======
+ 	struct mlx5e_tir_builder *tir_builder;
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  	int err;
  
 -	priv->rx_res = kvzalloc(sizeof(*priv->rx_res), GFP_KERNEL);
 -	if (!priv->rx_res)
 -		return -ENOMEM;
 -
 -	mlx5e_build_rss_params(&priv->rx_res->rss_params, priv->channels.params.num_channels);
 +	mlx5e_build_rss_params(&priv->rss_params, priv->channels.params.num_channels);
  
  	mlx5e_create_q_counters(priv);
  
@@@ -5036,6 -4914,22 +5268,25 @@@
  	if (unlikely(err))
  		goto err_destroy_xsk_rqts;
  
++<<<<<<< HEAD
++=======
+ 	err = mlx5e_rqt_init_direct(&priv->rx_res->ptp.rqt, priv->mdev, false,
+ 				    priv->drop_rq.rqn);
+ 	if (err)
+ 		goto err_destroy_xsk_tirs;
+ 
+ 	tir_builder = mlx5e_tir_builder_alloc(false);
+ 	if (!tir_builder) {
+ 		err = -ENOMEM;
+ 		goto err_destroy_ptp_rqt;
+ 	}
+ 	err = mlx5e_create_direct_tir(priv, &priv->rx_res->ptp.tir, tir_builder,
+ 				      &priv->rx_res->ptp.rqt);
+ 	mlx5e_tir_builder_free(tir_builder);
+ 	if (err)
+ 		goto err_destroy_ptp_rqt;
+ 
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  	err = mlx5e_create_flow_steering(priv);
  	if (err) {
  		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
@@@ -5060,12 -4954,16 +5311,19 @@@ err_tc_nic_cleanup
  	mlx5e_tc_nic_cleanup(priv);
  err_destroy_flow_steering:
  	mlx5e_destroy_flow_steering(priv);
++<<<<<<< HEAD
++=======
+ err_destroy_ptp_direct_tir:
+ 	mlx5e_tir_destroy(&priv->rx_res->ptp.tir);
+ err_destroy_ptp_rqt:
+ 	mlx5e_rqt_destroy(&priv->rx_res->ptp.rqt);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  err_destroy_xsk_tirs:
 -	mlx5e_destroy_xsk_tirs(priv);
 +	mlx5e_destroy_direct_tirs(priv, priv->xsk_tir, max_nch);
  err_destroy_xsk_rqts:
 -	mlx5e_destroy_xsk_rqts(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->xsk_tir, max_nch);
  err_destroy_direct_tirs:
 -	mlx5e_destroy_direct_tirs(priv);
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
  err_destroy_indirect_tirs:
  	mlx5e_destroy_indirect_tirs(priv);
  err_destroy_direct_rqts:
@@@ -5086,14 -4984,18 +5344,22 @@@ static void mlx5e_cleanup_nic_rx(struc
  	mlx5e_accel_cleanup_rx(priv);
  	mlx5e_tc_nic_cleanup(priv);
  	mlx5e_destroy_flow_steering(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_tirs(priv, priv->xsk_tir, max_nch);
 +	mlx5e_destroy_direct_rqts(priv, priv->xsk_tir, max_nch);
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
++=======
+ 	mlx5e_tir_destroy(&priv->rx_res->ptp.tir);
+ 	mlx5e_rqt_destroy(&priv->rx_res->ptp.rqt);
+ 	mlx5e_destroy_xsk_tirs(priv);
+ 	mlx5e_destroy_xsk_rqts(priv);
+ 	mlx5e_destroy_direct_tirs(priv);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
  	mlx5e_destroy_indirect_tirs(priv);
 -	mlx5e_destroy_direct_rqts(priv);
 -	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
  	mlx5e_close_drop_rq(&priv->drop_rq);
  	mlx5e_destroy_q_counters(priv);
 -	kvfree(priv->rx_res);
 -	priv->rx_res = NULL;
  }
  
  static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,c5ab3e81d13e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -583,16 -531,18 +591,25 @@@ static int mlx5e_hairpin_create_indirec
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
  		struct mlx5e_tirc_config ttconfig = mlx5e_tirc_get_default_config(tt);
  
- 		memset(in, 0, MLX5_ST_SZ_BYTES(create_tir_in));
- 		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
+ 		rss_tt = (struct mlx5e_rss_params_traffic_type) {
+ 			.l3_prot_type = ttconfig.l3_prot_type,
+ 			.l4_prot_type = ttconfig.l4_prot_type,
+ 			.rx_hash_fields = ttconfig.rx_hash_fields,
+ 		};
  
++<<<<<<< HEAD
 +		MLX5_SET(tirc, tirc, transport_domain, hp->tdn);
 +		MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
 +		MLX5_SET(tirc, tirc, indirect_table, hp->indir_rqt.rqtn);
 +		mlx5e_build_indir_tir_ctx_hash(&priv->rss_params, &ttconfig, tirc, false);
- 
- 		err = mlx5_core_create_tir(hp->func_mdev, in,
- 					   &hp->indir_tirn[tt]);
++=======
+ 		mlx5e_tir_builder_build_rqt(builder, hp->tdn,
+ 					    mlx5e_rqt_get_rqtn(&hp->indir_rqt),
+ 					    false);
+ 		mlx5e_tir_builder_build_rss(builder, rss_hash, &rss_tt, false);
++>>>>>>> a6696735d694 (net/mlx5e: Convert TIR to a dedicated object)
+ 
+ 		err = mlx5e_tir_init(&hp->indir_tir[tt], builder, hp->func_mdev, false);
  		if (err) {
  			mlx5_core_warn(hp->func_mdev, "create indirect tirs failed, %d\n", err);
  			goto err_destroy_tirs;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tir.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tir.c
new file mode 100644
index 000000000000..3ec94da45d36
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tir.c
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/* Copyright (c) 2021, Mellanox Technologies inc. All rights reserved. */
+
+#include "tir.h"
+#include "params.h"
+#include <linux/mlx5/transobj.h>
+
+#define MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ (64 * 1024)
+
+/* max() doesn't work inside square brackets. */
+#define MLX5E_TIR_CMD_IN_SZ_DW ( \
+	MLX5_ST_SZ_DW(create_tir_in) > MLX5_ST_SZ_DW(modify_tir_in) ? \
+	MLX5_ST_SZ_DW(create_tir_in) : MLX5_ST_SZ_DW(modify_tir_in) \
+)
+
+struct mlx5e_tir_builder {
+	u32 in[MLX5E_TIR_CMD_IN_SZ_DW];
+	bool modify;
+};
+
+struct mlx5e_tir_builder *mlx5e_tir_builder_alloc(bool modify)
+{
+	struct mlx5e_tir_builder *builder;
+
+	builder = kvzalloc(sizeof(*builder), GFP_KERNEL);
+	builder->modify = modify;
+
+	return builder;
+}
+
+void mlx5e_tir_builder_free(struct mlx5e_tir_builder *builder)
+{
+	kvfree(builder);
+}
+
+void mlx5e_tir_builder_clear(struct mlx5e_tir_builder *builder)
+{
+	memset(builder->in, 0, sizeof(builder->in));
+}
+
+static void *mlx5e_tir_builder_get_tirc(struct mlx5e_tir_builder *builder)
+{
+	if (builder->modify)
+		return MLX5_ADDR_OF(modify_tir_in, builder->in, ctx);
+	return MLX5_ADDR_OF(create_tir_in, builder->in, ctx);
+}
+
+void mlx5e_tir_builder_build_inline(struct mlx5e_tir_builder *builder, u32 tdn, u32 rqn)
+{
+	void *tirc = mlx5e_tir_builder_get_tirc(builder);
+
+	WARN_ON(builder->modify);
+
+	MLX5_SET(tirc, tirc, transport_domain, tdn);
+	MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_DIRECT);
+	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_NONE);
+	MLX5_SET(tirc, tirc, inline_rqn, rqn);
+}
+
+void mlx5e_tir_builder_build_rqt(struct mlx5e_tir_builder *builder, u32 tdn,
+				 u32 rqtn, bool inner_ft_support)
+{
+	void *tirc = mlx5e_tir_builder_get_tirc(builder);
+
+	WARN_ON(builder->modify);
+
+	MLX5_SET(tirc, tirc, transport_domain, tdn);
+	MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_INDIRECT);
+	MLX5_SET(tirc, tirc, indirect_table, rqtn);
+	MLX5_SET(tirc, tirc, tunneled_offload_en, inner_ft_support);
+}
+
+void mlx5e_tir_builder_build_lro(struct mlx5e_tir_builder *builder,
+				 const struct mlx5e_lro_param *lro_param)
+{
+	void *tirc = mlx5e_tir_builder_get_tirc(builder);
+	const unsigned int rough_max_l2_l3_hdr_sz = 256;
+
+	if (builder->modify)
+		MLX5_SET(modify_tir_in, builder->in, bitmask.lro, 1);
+
+	if (!lro_param->enabled)
+		return;
+
+	MLX5_SET(tirc, tirc, lro_enable_mask,
+		 MLX5_TIRC_LRO_ENABLE_MASK_IPV4_LRO |
+		 MLX5_TIRC_LRO_ENABLE_MASK_IPV6_LRO);
+	MLX5_SET(tirc, tirc, lro_max_ip_payload_size,
+		 (MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ - rough_max_l2_l3_hdr_sz) >> 8);
+	MLX5_SET(tirc, tirc, lro_timeout_period_usecs, lro_param->timeout);
+}
+
+static int mlx5e_hfunc_to_hw(u8 hfunc)
+{
+	switch (hfunc) {
+	case ETH_RSS_HASH_TOP:
+		return MLX5_RX_HASH_FN_TOEPLITZ;
+	case ETH_RSS_HASH_XOR:
+		return MLX5_RX_HASH_FN_INVERTED_XOR8;
+	default:
+		return MLX5_RX_HASH_FN_NONE;
+	}
+}
+
+void mlx5e_tir_builder_build_rss(struct mlx5e_tir_builder *builder,
+				 const struct mlx5e_rss_params_hash *rss_hash,
+				 const struct mlx5e_rss_params_traffic_type *rss_tt,
+				 bool inner)
+{
+	void *tirc = mlx5e_tir_builder_get_tirc(builder);
+	void *hfso;
+
+	if (builder->modify)
+		MLX5_SET(modify_tir_in, builder->in, bitmask.hash, 1);
+
+	MLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_hfunc_to_hw(rss_hash->hfunc));
+	if (rss_hash->hfunc == ETH_RSS_HASH_TOP) {
+		const size_t len = MLX5_FLD_SZ_BYTES(tirc, rx_hash_toeplitz_key);
+		void *rss_key = MLX5_ADDR_OF(tirc, tirc, rx_hash_toeplitz_key);
+
+		MLX5_SET(tirc, tirc, rx_hash_symmetric, 1);
+		memcpy(rss_key, rss_hash->toeplitz_hash_key, len);
+	}
+
+	if (inner)
+		hfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner);
+	else
+		hfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);
+	MLX5_SET(rx_hash_field_select, hfso, l3_prot_type, rss_tt->l3_prot_type);
+	MLX5_SET(rx_hash_field_select, hfso, l4_prot_type, rss_tt->l4_prot_type);
+	MLX5_SET(rx_hash_field_select, hfso, selected_fields, rss_tt->rx_hash_fields);
+}
+
+void mlx5e_tir_builder_build_direct(struct mlx5e_tir_builder *builder)
+{
+	void *tirc = mlx5e_tir_builder_get_tirc(builder);
+
+	WARN_ON(builder->modify);
+
+	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_INVERTED_XOR8);
+}
+
+int mlx5e_tir_init(struct mlx5e_tir *tir, struct mlx5e_tir_builder *builder,
+		   struct mlx5_core_dev *mdev, bool reg)
+{
+	int err;
+
+	tir->mdev = mdev;
+
+	err = mlx5_core_create_tir(tir->mdev, builder->in, &tir->tirn);
+	if (err)
+		return err;
+
+	if (reg) {
+		struct mlx5e_hw_objs *res = &tir->mdev->mlx5e_res.hw_objs;
+
+		mutex_lock(&res->td.list_lock);
+		list_add(&tir->list, &res->td.tirs_list);
+		mutex_unlock(&res->td.list_lock);
+	} else {
+		INIT_LIST_HEAD(&tir->list);
+	}
+
+	return 0;
+}
+
+void mlx5e_tir_destroy(struct mlx5e_tir *tir)
+{
+	struct mlx5e_hw_objs *res = &tir->mdev->mlx5e_res.hw_objs;
+
+	/* Skip mutex if list_del is no-op (the TIR wasn't registered in the
+	 * list). list_empty will never return true for an item of tirs_list,
+	 * and READ_ONCE/WRITE_ONCE in list_empty/list_del guarantee consistency
+	 * of the list->next value.
+	 */
+	if (!list_empty(&tir->list)) {
+		mutex_lock(&res->td.list_lock);
+		list_del(&tir->list);
+		mutex_unlock(&res->td.list_lock);
+	}
+
+	mlx5_core_destroy_tir(tir->mdev, tir->tirn);
+}
+
+int mlx5e_tir_modify(struct mlx5e_tir *tir, struct mlx5e_tir_builder *builder)
+{
+	return mlx5_core_modify_tir(tir->mdev, tir->tirn, builder->in);
+}
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tir.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tir.h
new file mode 100644
index 000000000000..25b8a2edf6cc
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tir.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2021, Mellanox Technologies inc. All rights reserved. */
+
+#ifndef __MLX5_EN_TIR_H__
+#define __MLX5_EN_TIR_H__
+
+#include <linux/kernel.h>
+
+struct mlx5e_rss_params_hash {
+	u8 hfunc;
+	u8 toeplitz_hash_key[40];
+};
+
+struct mlx5e_rss_params_traffic_type {
+	u8 l3_prot_type;
+	u8 l4_prot_type;
+	u32 rx_hash_fields;
+};
+
+struct mlx5e_tir_builder;
+struct mlx5e_lro_param;
+
+struct mlx5e_tir_builder *mlx5e_tir_builder_alloc(bool modify);
+void mlx5e_tir_builder_free(struct mlx5e_tir_builder *builder);
+void mlx5e_tir_builder_clear(struct mlx5e_tir_builder *builder);
+
+void mlx5e_tir_builder_build_inline(struct mlx5e_tir_builder *builder, u32 tdn, u32 rqn);
+void mlx5e_tir_builder_build_rqt(struct mlx5e_tir_builder *builder, u32 tdn,
+				 u32 rqtn, bool inner_ft_support);
+void mlx5e_tir_builder_build_lro(struct mlx5e_tir_builder *builder,
+				 const struct mlx5e_lro_param *lro_param);
+void mlx5e_tir_builder_build_rss(struct mlx5e_tir_builder *builder,
+				 const struct mlx5e_rss_params_hash *rss_hash,
+				 const struct mlx5e_rss_params_traffic_type *rss_tt,
+				 bool inner);
+void mlx5e_tir_builder_build_direct(struct mlx5e_tir_builder *builder);
+
+struct mlx5_core_dev;
+
+struct mlx5e_tir {
+	struct mlx5_core_dev *mdev;
+	u32 tirn;
+	struct list_head list;
+};
+
+int mlx5e_tir_init(struct mlx5e_tir *tir, struct mlx5e_tir_builder *builder,
+		   struct mlx5_core_dev *mdev, bool reg);
+void mlx5e_tir_destroy(struct mlx5e_tir *tir);
+
+static inline u32 mlx5e_tir_get_tirn(struct mlx5e_tir *tir)
+{
+	return tir->tirn;
+}
+
+int mlx5e_tir_modify(struct mlx5e_tir *tir, struct mlx5e_tir_builder *builder);
+
+#endif /* __MLX5_EN_TIR_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c b/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
index 90bd7328df42..c07464a150f4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/trap.c
@@ -202,30 +202,19 @@ static void mlx5e_close_trap_rq(struct mlx5e_rq *rq)
 static int mlx5e_create_trap_direct_rq_tir(struct mlx5_core_dev *mdev, struct mlx5e_tir *tir,
 					   u32 rqn)
 {
-	void *tirc;
-	int inlen;
-	u32 *in;
+	struct mlx5e_tir_builder *builder;
 	int err;
 
-	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
-	in = kvzalloc(inlen, GFP_KERNEL);
-	if (!in)
+	builder = mlx5e_tir_builder_alloc(false);
+	if (!builder)
 		return -ENOMEM;
 
-	tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
-	MLX5_SET(tirc, tirc, transport_domain, mdev->mlx5e_res.hw_objs.td.tdn);
-	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_NONE);
-	MLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_DIRECT);
-	MLX5_SET(tirc, tirc, inline_rqn, rqn);
-	err = mlx5e_create_tir(mdev, tir, in);
-	kvfree(in);
+	mlx5e_tir_builder_build_inline(builder, mdev->mlx5e_res.hw_objs.td.tdn, rqn);
+	err = mlx5e_tir_init(tir, builder, mdev, true);
 
-	return err;
-}
+	mlx5e_tir_builder_free(builder);
 
-static void mlx5e_destroy_trap_direct_rq_tir(struct mlx5_core_dev *mdev, struct mlx5e_tir *tir)
-{
-	mlx5e_destroy_tir(mdev, tir);
+	return err;
 }
 
 static void mlx5e_build_trap_params(struct mlx5_core_dev *mdev,
@@ -287,7 +276,7 @@ static struct mlx5e_trap *mlx5e_open_trap(struct mlx5e_priv *priv)
 
 void mlx5e_close_trap(struct mlx5e_trap *trap)
 {
-	mlx5e_destroy_trap_direct_rq_tir(trap->mdev, &trap->tir);
+	mlx5e_tir_destroy(&trap->tir);
 	mlx5e_close_trap_rq(&trap->rq);
 	netif_napi_del(&trap->napi);
 	kvfree(trap);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
index f3bdd063051a..c4db367d4baf 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
@@ -36,34 +36,6 @@
  * Global resources are common to all the netdevices crated on the same nic.
  */
 
-int mlx5e_create_tir(struct mlx5_core_dev *mdev, struct mlx5e_tir *tir, u32 *in)
-{
-	struct mlx5e_hw_objs *res = &mdev->mlx5e_res.hw_objs;
-	int err;
-
-	err = mlx5_core_create_tir(mdev, in, &tir->tirn);
-	if (err)
-		return err;
-
-	mutex_lock(&res->td.list_lock);
-	list_add(&tir->list, &res->td.tirs_list);
-	mutex_unlock(&res->td.list_lock);
-
-	return 0;
-}
-
-void mlx5e_destroy_tir(struct mlx5_core_dev *mdev,
-		       struct mlx5e_tir *tir)
-{
-	struct mlx5e_hw_objs *res = &mdev->mlx5e_res.hw_objs;
-
-	mutex_lock(&res->td.list_lock);
-	list_del(&tir->list);
-	mutex_unlock(&res->td.list_lock);
-
-	mlx5_core_destroy_tir(mdev, tir->tirn);
-}
-
 void mlx5e_mkey_set_relaxed_ordering(struct mlx5_core_dev *mdev, void *mkc)
 {
 	bool ro_pci_enable = pcie_relaxed_ordering_enabled(mdev->pdev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
