ice: Match on all profiles in slow-path

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Wojciech Drewek <wojciech.drewek@intel.com>
commit b70bc066d77b460a63a8c3fb2ea0d811ce862a83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/b70bc066.failed

In switchdev mode, slow-path rules need to match all protocols, in order
to correctly redirect unfiltered or missed packets to the uplink. To set
this up for the virtual function to uplink flow, the rule that redirects
packets to the control VSI must have the tunnel type set to
ICE_SW_TUN_AND_NON_TUN. As a result of that new tunnel type being set,
ice_get_compat_fv_bitmap will select ICE_PROF_ALL. At that point all
profiles would be selected for this rule, resulting in the desired
behavior. Without this change slow-path would not work with
tunnel protocols.

Fixes: 8b032a55c1bd ("ice: low level support for tunnels")
	Signed-off-by: Wojciech Drewek <wojciech.drewek@intel.com>
	Tested-by: Sandeep Penigalapati <sandeep.penigalapati@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit b70bc066d77b460a63a8c3fb2ea0d811ce862a83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_eswitch.c
#	drivers/net/ethernet/intel/ice/ice_protocol_type.h
#	drivers/net/ethernet/intel/ice/ice_switch.c
diff --cc drivers/net/ethernet/intel/ice/ice_eswitch.c
index 91e928768421,73edc24d81d5..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c
+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c
@@@ -7,6 -7,102 +7,105 @@@
  #include "ice_fltr.h"
  #include "ice_repr.h"
  #include "ice_devlink.h"
++<<<<<<< HEAD
++=======
+ #include "ice_tc_lib.h"
+ 
+ /**
+  * ice_eswitch_add_vf_mac_rule - add adv rule with VF's MAC
+  * @pf: pointer to PF struct
+  * @vf: pointer to VF struct
+  * @mac: VF's MAC address
+  *
+  * This function adds advanced rule that forwards packets with
+  * VF's MAC address (src MAC) to the corresponding switchdev ctrl VSI queue.
+  */
+ int
+ ice_eswitch_add_vf_mac_rule(struct ice_pf *pf, struct ice_vf *vf, const u8 *mac)
+ {
+ 	struct ice_vsi *ctrl_vsi = pf->switchdev.control_vsi;
+ 	struct ice_adv_rule_info rule_info = { 0 };
+ 	struct ice_adv_lkup_elem *list;
+ 	struct ice_hw *hw = &pf->hw;
+ 	const u16 lkups_cnt = 1;
+ 	int err;
+ 
+ 	list = kcalloc(lkups_cnt, sizeof(*list), GFP_ATOMIC);
+ 	if (!list)
+ 		return -ENOMEM;
+ 
+ 	list[0].type = ICE_MAC_OFOS;
+ 	ether_addr_copy(list[0].h_u.eth_hdr.src_addr, mac);
+ 	eth_broadcast_addr(list[0].m_u.eth_hdr.src_addr);
+ 
+ 	rule_info.sw_act.flag |= ICE_FLTR_TX;
+ 	rule_info.sw_act.vsi_handle = ctrl_vsi->idx;
+ 	rule_info.sw_act.fltr_act = ICE_FWD_TO_Q;
+ 	rule_info.rx = false;
+ 	rule_info.sw_act.fwd_id.q_id = hw->func_caps.common_cap.rxq_first_id +
+ 				       ctrl_vsi->rxq_map[vf->vf_id];
+ 	rule_info.flags_info.act |= ICE_SINGLE_ACT_LB_ENABLE;
+ 	rule_info.flags_info.act_valid = true;
+ 	rule_info.tun_type = ICE_SW_TUN_AND_NON_TUN;
+ 
+ 	err = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info,
+ 			       vf->repr->mac_rule);
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(pf), "Unable to add VF mac rule in switchdev mode for VF %d",
+ 			vf->vf_id);
+ 	else
+ 		vf->repr->rule_added = true;
+ 
+ 	kfree(list);
+ 	return err;
+ }
+ 
+ /**
+  * ice_eswitch_replay_vf_mac_rule - replay adv rule with VF's MAC
+  * @vf: pointer to vF struct
+  *
+  * This function replays VF's MAC rule after reset.
+  */
+ void ice_eswitch_replay_vf_mac_rule(struct ice_vf *vf)
+ {
+ 	int err;
+ 
+ 	if (!ice_is_switchdev_running(vf->pf))
+ 		return;
+ 
+ 	if (is_valid_ether_addr(vf->hw_lan_addr.addr)) {
+ 		err = ice_eswitch_add_vf_mac_rule(vf->pf, vf,
+ 						  vf->hw_lan_addr.addr);
+ 		if (err) {
+ 			dev_err(ice_pf_to_dev(vf->pf), "Failed to add MAC %pM for VF %d\n, error %d\n",
+ 				vf->hw_lan_addr.addr, vf->vf_id, err);
+ 			return;
+ 		}
+ 		vf->num_mac++;
+ 
+ 		ether_addr_copy(vf->dev_lan_addr.addr, vf->hw_lan_addr.addr);
+ 	}
+ }
+ 
+ /**
+  * ice_eswitch_del_vf_mac_rule - delete adv rule with VF's MAC
+  * @vf: pointer to the VF struct
+  *
+  * Delete the advanced rule that was used to forward packets with the VF's MAC
+  * address (src MAC) to the corresponding switchdev ctrl VSI queue.
+  */
+ void ice_eswitch_del_vf_mac_rule(struct ice_vf *vf)
+ {
+ 	if (!ice_is_switchdev_running(vf->pf))
+ 		return;
+ 
+ 	if (!vf->repr->rule_added)
+ 		return;
+ 
+ 	ice_rem_adv_rule_by_id(&vf->pf->hw, vf->repr->mac_rule);
+ 	vf->repr->rule_added = false;
+ }
++>>>>>>> b70bc066d77b (ice: Match on all profiles in slow-path)
  
  /**
   * ice_eswitch_setup_env - configure switchdev HW filters
diff --cc drivers/net/ethernet/intel/ice/ice_protocol_type.h
index 0b220dfa7457,695b6dd61dc2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_protocol_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_protocol_type.h
@@@ -41,6 -45,15 +41,18 @@@ enum ice_protocol_type 
  	ICE_PROTOCOL_LAST
  };
  
++<<<<<<< HEAD
++=======
+ enum ice_sw_tunnel_type {
+ 	ICE_NON_TUN = 0,
+ 	ICE_SW_TUN_AND_NON_TUN,
+ 	ICE_SW_TUN_VXLAN,
+ 	ICE_SW_TUN_GENEVE,
+ 	ICE_SW_TUN_NVGRE,
+ 	ICE_ALL_TUNNELS /* All tunnel types including NVGRE */
+ };
+ 
++>>>>>>> b70bc066d77b (ice: Match on all profiles in slow-path)
  /* Decoders for ice_prot_id:
   * - F: First
   * - I: Inner
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 86fa235a6bc5,475ec2afa210..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -4169,9 -4519,31 +4169,33 @@@ static voi
  ice_get_compat_fv_bitmap(struct ice_hw *hw, struct ice_adv_rule_info *rinfo,
  			 unsigned long *bm)
  {
 -	enum ice_prof_type prof_type;
 -
  	bitmap_zero(bm, ICE_MAX_NUM_PROFILES);
  
++<<<<<<< HEAD
 +	ice_get_sw_fv_bitmap(hw, ICE_PROF_NON_TUN, bm);
++=======
+ 	switch (rinfo->tun_type) {
+ 	case ICE_NON_TUN:
+ 		prof_type = ICE_PROF_NON_TUN;
+ 		break;
+ 	case ICE_ALL_TUNNELS:
+ 		prof_type = ICE_PROF_TUN_ALL;
+ 		break;
+ 	case ICE_SW_TUN_GENEVE:
+ 	case ICE_SW_TUN_VXLAN:
+ 		prof_type = ICE_PROF_TUN_UDP;
+ 		break;
+ 	case ICE_SW_TUN_NVGRE:
+ 		prof_type = ICE_PROF_TUN_GRE;
+ 		break;
+ 	case ICE_SW_TUN_AND_NON_TUN:
+ 	default:
+ 		prof_type = ICE_PROF_ALL;
+ 		break;
+ 	}
+ 
+ 	ice_get_sw_fv_bitmap(hw, prof_type, bm);
++>>>>>>> b70bc066d77b (ice: Match on all profiles in slow-path)
  }
  
  /**
@@@ -4837,6 -5306,15 +4861,18 @@@ ice_add_adv_rule(struct ice_hw *hw, str
  	if (status)
  		goto err_ice_add_adv_rule;
  
++<<<<<<< HEAD
++=======
+ 	if (rinfo->tun_type != ICE_NON_TUN &&
+ 	    rinfo->tun_type != ICE_SW_TUN_AND_NON_TUN) {
+ 		status = ice_fill_adv_packet_tun(hw, rinfo->tun_type,
+ 						 s_rule->pdata.lkup_tx_rx.hdr,
+ 						 pkt_offsets);
+ 		if (status)
+ 			goto err_ice_add_adv_rule;
+ 	}
+ 
++>>>>>>> b70bc066d77b (ice: Match on all profiles in slow-path)
  	status = ice_aq_sw_rules(hw, (struct ice_aqc_sw_rules *)s_rule,
  				 rule_buf_sz, 1, ice_aqc_opc_add_sw_rules,
  				 NULL);
* Unmerged path drivers/net/ethernet/intel/ice/ice_eswitch.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_protocol_type.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
