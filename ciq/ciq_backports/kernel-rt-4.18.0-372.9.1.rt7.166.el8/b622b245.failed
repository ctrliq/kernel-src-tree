software node: Allow node addition to already existing device

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit b622b24519f5b008f6d4e20e5675eaffa8fbd87b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/b622b245.failed

If the node is added to an already exiting device, the node
needs to be also linked to the device separately.

This will make sure the reference count is kept in balance
also when the node is injected to a device afterwards.

Fixes: e68d0119e328 ("software node: Introduce device_add_software_node()")
	Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Cc: stable <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/20210414075438.64547-1-heikki.krogerus@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b622b24519f5b008f6d4e20e5675eaffa8fbd87b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/swnode.c
diff --cc drivers/base/swnode.c
index a113c24c8871,3cc11b813f28..000000000000
--- a/drivers/base/swnode.c
+++ b/drivers/base/swnode.c
@@@ -990,6 -1016,62 +990,65 @@@ void fwnode_remove_software_node(struc
  EXPORT_SYMBOL_GPL(fwnode_remove_software_node);
  
  /**
++<<<<<<< HEAD
++=======
+  * device_add_software_node - Assign software node to a device
+  * @dev: The device the software node is meant for.
+  * @node: The software node.
+  *
+  * This function will make @node the secondary firmware node pointer of @dev. If
+  * @dev has no primary node, then @node will become the primary node. The
+  * function will register @node automatically if it wasn't already registered.
+  */
+ int device_add_software_node(struct device *dev, const struct software_node *node)
+ {
+ 	struct swnode *swnode;
+ 	int ret;
+ 
+ 	/* Only one software node per device. */
+ 	if (dev_to_swnode(dev))
+ 		return -EBUSY;
+ 
+ 	swnode = software_node_to_swnode(node);
+ 	if (swnode) {
+ 		kobject_get(&swnode->kobj);
+ 	} else {
+ 		ret = software_node_register(node);
+ 		if (ret)
+ 			return ret;
+ 
+ 		swnode = software_node_to_swnode(node);
+ 	}
+ 
+ 	set_secondary_fwnode(dev, &swnode->fwnode);
+ 	software_node_notify(dev, KOBJ_ADD);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(device_add_software_node);
+ 
+ /**
+  * device_remove_software_node - Remove device's software node
+  * @dev: The device with the software node.
+  *
+  * This function will unregister the software node of @dev.
+  */
+ void device_remove_software_node(struct device *dev)
+ {
+ 	struct swnode *swnode;
+ 
+ 	swnode = dev_to_swnode(dev);
+ 	if (!swnode)
+ 		return;
+ 
+ 	software_node_notify(dev, KOBJ_REMOVE);
+ 	set_secondary_fwnode(dev, NULL);
+ 	kobject_put(&swnode->kobj);
+ }
+ EXPORT_SYMBOL_GPL(device_remove_software_node);
+ 
+ /**
++>>>>>>> b622b24519f5 (software node: Allow node addition to already existing device)
   * device_create_managed_software_node - Create a software node for a device
   * @dev: The device the software node is assigned to.
   * @properties: Device properties for the software node.
@@@ -1032,20 -1113,14 +1091,20 @@@ int software_node_notify(struct device 
  	struct swnode *swnode;
  	int ret;
  
 -	swnode = dev_to_swnode(dev);
 -	if (!swnode)
 +	if (!fwnode)
 +		return 0;
 +
 +	if (!is_software_node(fwnode))
 +		fwnode = fwnode->secondary;
 +	if (!is_software_node(fwnode))
  		return 0;
  
 +	swnode = to_swnode(fwnode);
 +
  	switch (action) {
  	case KOBJ_ADD:
- 		ret = sysfs_create_link(&dev->kobj, &swnode->kobj,
- 					"software_node");
+ 		ret = sysfs_create_link_nowarn(&dev->kobj, &swnode->kobj,
+ 					       "software_node");
  		if (ret)
  			break;
  
* Unmerged path drivers/base/swnode.c
