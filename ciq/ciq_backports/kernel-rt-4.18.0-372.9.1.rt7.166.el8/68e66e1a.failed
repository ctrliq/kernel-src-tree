net/mlx5e: Fix vlan data lost during suspend flow

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Moshe Shemesh <moshe@nvidia.com>
commit 68e66e1a69cd94f934522348ab232af49863452a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/68e66e1a.failed

During suspend flow the driver calls mlx5e_destroy_vlan_table() which
does not only delete the vlans steering flow rules, but also frees the
data on currently active vlans, thus it is not restored during resume
flow.

This fix keeps the vlan data on suspend flow and frees it only on driver
remove flow.

Fixes: 6783f0a21a3c ("net/mlx5e: Dynamic alloc vlan table for netdev when needed")
	Signed-off-by: Moshe Shemesh <moshe@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 68e66e1a69cd94f934522348ab232af49863452a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 6d1dade3f38c,a88a1a48229f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -273,7 -199,9 +273,13 @@@ void mlx5e_disable_cvlan_filter(struct 
  int mlx5e_create_flow_steering(struct mlx5e_priv *priv);
  void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +u8 mlx5e_get_proto_by_tunnel_type(enum mlx5e_tunnel_types tt);
++=======
+ int mlx5e_fs_init(struct mlx5e_priv *priv);
+ void mlx5e_fs_cleanup(struct mlx5e_priv *priv);
+ 
++>>>>>>> 68e66e1a69cd (net/mlx5e: Fix vlan data lost during suspend flow)
  int mlx5e_add_vlan_trap(struct mlx5e_priv *priv, int  trap_id, int tir_num);
  void mlx5e_remove_vlan_trap(struct mlx5e_priv *priv);
  int mlx5e_add_mac_trap(struct mlx5e_priv *priv, int  trap_id, int tir_num);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 1f20327ca7bb,d226cc5ab1d1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -1692,10 -1182,11 +1692,14 @@@ static int mlx5e_create_vlan_table_grou
  
  static int mlx5e_create_vlan_table(struct mlx5e_priv *priv)
  {
 +	struct mlx5e_flow_table *ft = &priv->fs.vlan.ft;
  	struct mlx5_flow_table_attr ft_attr = {};
 -	struct mlx5e_flow_table *ft;
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	ft = &priv->fs.vlan->ft;
++>>>>>>> 68e66e1a69cd (net/mlx5e: Fix vlan data lost during suspend flow)
  	ft->num_groups = 0;
  
  	ft_attr.max_fte = MLX5E_VLAN_TABLE_SIZE;
@@@ -1703,12 -1194,9 +1707,18 @@@
  	ft_attr.prio = MLX5E_NIC_PRIO;
  
  	ft->t = mlx5_create_flow_table(priv->fs.ns, &ft_attr);
++<<<<<<< HEAD
 +
 +	if (IS_ERR(ft->t)) {
 +		err = PTR_ERR(ft->t);
 +		ft->t = NULL;
 +		return err;
 +	}
++=======
+ 	if (IS_ERR(ft->t))
+ 		return PTR_ERR(ft->t);
+ 
++>>>>>>> 68e66e1a69cd (net/mlx5e: Fix vlan data lost during suspend flow)
  	ft->g = kcalloc(MLX5E_NUM_VLAN_GROUPS, sizeof(*ft->g), GFP_KERNEL);
  	if (!ft->g) {
  		err = -ENOMEM;
@@@ -1727,7 -1215,6 +1737,10 @@@ err_free_g
  	kfree(ft->g);
  err_destroy_vlan_table:
  	mlx5_destroy_flow_table(ft->t);
++<<<<<<< HEAD
 +	ft->t = NULL;
++=======
++>>>>>>> 68e66e1a69cd (net/mlx5e: Fix vlan data lost during suspend flow)
  
  	return err;
  }
@@@ -1735,7 -1222,45 +1748,49 @@@
  static void mlx5e_destroy_vlan_table(struct mlx5e_priv *priv)
  {
  	mlx5e_del_vlan_rules(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_flow_table(&priv->fs.vlan.ft);
++=======
+ 	mlx5e_destroy_flow_table(&priv->fs.vlan->ft);
+ }
+ 
+ static void mlx5e_destroy_inner_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	if (!mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		return;
+ 	mlx5_destroy_ttc_table(priv->fs.inner_ttc);
+ }
+ 
+ void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	mlx5_destroy_ttc_table(priv->fs.ttc);
+ }
+ 
+ static int mlx5e_create_inner_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	struct ttc_params ttc_params = {};
+ 
+ 	if (!mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		return 0;
+ 
+ 	mlx5e_set_inner_ttc_params(priv, &ttc_params);
+ 	priv->fs.inner_ttc = mlx5_create_inner_ttc_table(priv->mdev,
+ 							 &ttc_params);
+ 	if (IS_ERR(priv->fs.inner_ttc))
+ 		return PTR_ERR(priv->fs.inner_ttc);
+ 	return 0;
+ }
+ 
+ int mlx5e_create_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	struct ttc_params ttc_params = {};
+ 
+ 	mlx5e_set_ttc_params(priv, &ttc_params, true);
+ 	priv->fs.ttc = mlx5_create_ttc_table(priv->mdev, &ttc_params);
+ 	if (IS_ERR(priv->fs.ttc))
+ 		return PTR_ERR(priv->fs.ttc);
+ 	return 0;
++>>>>>>> 68e66e1a69cd (net/mlx5e: Fix vlan data lost during suspend flow)
  }
  
  int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 5647a28ac255..60cd416cd76c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -4976,6 +4976,12 @@ static int mlx5e_nic_init(struct mlx5_core_dev *mdev,
 
 	mlx5e_timestamp_init(priv);
 
+	err = mlx5e_fs_init(priv);
+	if (err) {
+		mlx5_core_err(mdev, "FS initialization failed, %d\n", err);
+		return err;
+	}
+
 	err = mlx5e_ipsec_init(priv);
 	if (err)
 		mlx5_core_err(mdev, "IPSec initialization failed, %d\n", err);
@@ -4999,6 +5005,7 @@ static void mlx5e_nic_cleanup(struct mlx5e_priv *priv)
 	mlx5e_devlink_port_unregister(priv);
 	mlx5e_tls_cleanup(priv);
 	mlx5e_ipsec_cleanup(priv);
+	mlx5e_fs_cleanup(priv);
 }
 
 static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
