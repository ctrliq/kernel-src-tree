driver core: fw_devlink: Handle suppliers that don't use driver core

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 74c782cff77b3533290148df1fa6f8c7db5e60d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/74c782cf.failed

Device links only work between devices that use the driver core to match
and bind a driver to a device. So, add an API for frameworks to let the
driver core know that a fwnode has been initialized by a driver without
using the driver core.

Then use this information to make sure that fw_devlink doesn't make the
consumers wait indefinitely on suppliers that'll never bind to a driver.

	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20210205222644.2357303-6-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 74c782cff77b3533290148df1fa6f8c7db5e60d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fwnode.h
diff --cc include/linux/fwnode.h
index 9d299e828851,dfefd43a737c..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -13,9 -10,8 +13,13 @@@
  #define _LINUX_FWNODE_H_
  
  #include <linux/types.h>
 +#include <linux/rh_kabi.h>
  #include <linux/list.h>
++<<<<<<< HEAD
 +#include <linux/bits.h>
++=======
+ #include <linux/err.h>
++>>>>>>> 74c782cff77b (driver core: fw_devlink: Handle suppliers that don't use driver core)
  
  struct fwnode_operations;
  struct device;
diff --git a/drivers/base/core.c b/drivers/base/core.c
index e736ab40e755..487ff23e06ad 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1626,6 +1626,17 @@ static int fw_devlink_create_devlink(struct device *con,
 
 	sup_dev = get_dev_from_fwnode(sup_handle);
 	if (sup_dev) {
+		/*
+		 * If it's one of those drivers that don't actually bind to
+		 * their device using driver core, then don't wait on this
+		 * supplier device indefinitely.
+		 */
+		if (sup_dev->links.status == DL_DEV_NO_DRIVER &&
+		    sup_handle->flags & FWNODE_FLAG_INITIALIZED) {
+			ret = -EINVAL;
+			goto out;
+		}
+
 		/*
 		 * If this fails, it is due to cycles in device links.  Just
 		 * give up on this link and treat it as invalid.
@@ -1645,6 +1656,10 @@ static int fw_devlink_create_devlink(struct device *con,
 		goto out;
 	}
 
+	/* Supplier that's already initialized without a struct device. */
+	if (sup_handle->flags & FWNODE_FLAG_INITIALIZED)
+		return -EINVAL;
+
 	/*
 	 * DL_FLAG_SYNC_STATE_ONLY doesn't block probing and supports
 	 * cycles. So cycle detection isn't necessary and shouldn't be
* Unmerged path include/linux/fwnode.h
