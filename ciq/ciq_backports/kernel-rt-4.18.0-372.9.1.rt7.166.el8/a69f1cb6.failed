ice: exit bypass mode once hardware finishes timestamp calibration

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit a69f1cb62aecedddaec445aff28f095793b1c28c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/a69f1cb6.failed

Once the E822 device has sent and received one packet, the hardware
computes the internal delay of the PHY using a process known as Vernier
calibration. This calibration calculates a more accurate offset for the
Tx and Rx timestamps. To make use of this offset, we need to exit the
bypass mode. This cannot be done until the PHY has completed offset
calibration, as indicated by the offset valid bits.

To handle this, introduce a kthread work item which will poll the offset
valid bits every few milliseconds seeing if it is safe to exit bypass
mode.

Once we have finished calibrating the offsets, we can program the total
Tx and Rx offset registers and turn off the bypass bit. This allows the
hardware to include the more precise vernier calibration offset, and
improves the timestamp precision.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit a69f1cb62aecedddaec445aff28f095793b1c28c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ptp.c
#	drivers/net/ethernet/intel/ice/ice_ptp.h
#	drivers/net/ethernet/intel/ice/ice_ptp_hw.c
#	drivers/net/ethernet/intel/ice/ice_ptp_hw.h
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.c
index d8979dfd7d47,14b371a8f301..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.c
@@@ -689,7 -691,393 +689,397 @@@ static int ice_ptp_write_adj(struct ice
   */
  static u64 ice_base_incval(struct ice_pf *pf)
  {
++<<<<<<< HEAD
 +	return ICE_PTP_NOMINAL_INCVAL_E810;
++=======
+ 	struct ice_hw *hw = &pf->hw;
+ 	u64 incval;
+ 
+ 	if (ice_is_e810(hw))
+ 		incval = ICE_PTP_NOMINAL_INCVAL_E810;
+ 	else if (ice_e822_time_ref(hw) < NUM_ICE_TIME_REF_FREQ)
+ 		incval = ice_e822_nominal_incval(ice_e822_time_ref(hw));
+ 	else
+ 		incval = UNKNOWN_INCVAL_E822;
+ 
+ 	dev_dbg(ice_pf_to_dev(pf), "PTP: using base increment value of 0x%016llx\n",
+ 		incval);
+ 
+ 	return incval;
+ }
+ 
+ /**
+  * ice_ptp_reset_ts_memory_quad - Reset timestamp memory for one quad
+  * @pf: The PF private data structure
+  * @quad: The quad (0-4)
+  */
+ static void ice_ptp_reset_ts_memory_quad(struct ice_pf *pf, int quad)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 
+ 	ice_write_quad_reg_e822(hw, quad, Q_REG_TS_CTRL, Q_REG_TS_CTRL_M);
+ 	ice_write_quad_reg_e822(hw, quad, Q_REG_TS_CTRL, ~(u32)Q_REG_TS_CTRL_M);
+ }
+ 
+ /**
+  * ice_ptp_check_tx_fifo - Check whether Tx FIFO is in an OK state
+  * @port: PTP port for which Tx FIFO is checked
+  */
+ static int ice_ptp_check_tx_fifo(struct ice_ptp_port *port)
+ {
+ 	int quad = port->port_num / ICE_PORTS_PER_QUAD;
+ 	int offs = port->port_num % ICE_PORTS_PER_QUAD;
+ 	struct ice_pf *pf;
+ 	struct ice_hw *hw;
+ 	u32 val, phy_sts;
+ 	int err;
+ 
+ 	pf = ptp_port_to_pf(port);
+ 	hw = &pf->hw;
+ 
+ 	if (port->tx_fifo_busy_cnt == FIFO_OK)
+ 		return 0;
+ 
+ 	/* need to read FIFO state */
+ 	if (offs == 0 || offs == 1)
+ 		err = ice_read_quad_reg_e822(hw, quad, Q_REG_FIFO01_STATUS,
+ 					     &val);
+ 	else
+ 		err = ice_read_quad_reg_e822(hw, quad, Q_REG_FIFO23_STATUS,
+ 					     &val);
+ 
+ 	if (err) {
+ 		dev_err(ice_pf_to_dev(pf), "PTP failed to check port %d Tx FIFO, err %d\n",
+ 			port->port_num, err);
+ 		return err;
+ 	}
+ 
+ 	if (offs & 0x1)
+ 		phy_sts = (val & Q_REG_FIFO13_M) >> Q_REG_FIFO13_S;
+ 	else
+ 		phy_sts = (val & Q_REG_FIFO02_M) >> Q_REG_FIFO02_S;
+ 
+ 	if (phy_sts & FIFO_EMPTY) {
+ 		port->tx_fifo_busy_cnt = FIFO_OK;
+ 		return 0;
+ 	}
+ 
+ 	port->tx_fifo_busy_cnt++;
+ 
+ 	dev_dbg(ice_pf_to_dev(pf), "Try %d, port %d FIFO not empty\n",
+ 		port->tx_fifo_busy_cnt, port->port_num);
+ 
+ 	if (port->tx_fifo_busy_cnt == ICE_PTP_FIFO_NUM_CHECKS) {
+ 		dev_dbg(ice_pf_to_dev(pf),
+ 			"Port %d Tx FIFO still not empty; resetting quad %d\n",
+ 			port->port_num, quad);
+ 		ice_ptp_reset_ts_memory_quad(pf, quad);
+ 		port->tx_fifo_busy_cnt = FIFO_OK;
+ 		return 0;
+ 	}
+ 
+ 	return -EAGAIN;
+ }
+ 
+ /**
+  * ice_ptp_check_tx_offset_valid - Check if the Tx PHY offset is valid
+  * @port: the PTP port to check
+  *
+  * Checks whether the Tx offset for the PHY associated with this port is
+  * valid. Returns 0 if the offset is valid, and a non-zero error code if it is
+  * not.
+  */
+ static int ice_ptp_check_tx_offset_valid(struct ice_ptp_port *port)
+ {
+ 	struct ice_pf *pf = ptp_port_to_pf(port);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	u32 val;
+ 	int err;
+ 
+ 	err = ice_ptp_check_tx_fifo(port);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port->port_num, P_REG_TX_OV_STATUS,
+ 				    &val);
+ 	if (err) {
+ 		dev_err(dev, "Failed to read TX_OV_STATUS for port %d, err %d\n",
+ 			port->port_num, err);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	if (!(val & P_REG_TX_OV_STATUS_OV_M))
+ 		return -EAGAIN;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_check_rx_offset_valid - Check if the Rx PHY offset is valid
+  * @port: the PTP port to check
+  *
+  * Checks whether the Rx offset for the PHY associated with this port is
+  * valid. Returns 0 if the offset is valid, and a non-zero error code if it is
+  * not.
+  */
+ static int ice_ptp_check_rx_offset_valid(struct ice_ptp_port *port)
+ {
+ 	struct ice_pf *pf = ptp_port_to_pf(port);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	int err;
+ 	u32 val;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port->port_num, P_REG_RX_OV_STATUS,
+ 				    &val);
+ 	if (err) {
+ 		dev_err(dev, "Failed to read RX_OV_STATUS for port %d, err %d\n",
+ 			port->port_num, err);
+ 		return err;
+ 	}
+ 
+ 	if (!(val & P_REG_RX_OV_STATUS_OV_M))
+ 		return -EAGAIN;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_check_offset_valid - Check port offset valid bit
+  * @port: Port for which offset valid bit is checked
+  *
+  * Returns 0 if both Tx and Rx offset are valid, and -EAGAIN if one of the
+  * offset is not ready.
+  */
+ static int ice_ptp_check_offset_valid(struct ice_ptp_port *port)
+ {
+ 	int tx_err, rx_err;
+ 
+ 	/* always check both Tx and Rx offset validity */
+ 	tx_err = ice_ptp_check_tx_offset_valid(port);
+ 	rx_err = ice_ptp_check_rx_offset_valid(port);
+ 
+ 	if (tx_err || rx_err)
+ 		return -EAGAIN;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_wait_for_offset_valid - Check for valid Tx and Rx offsets
+  * @work: Pointer to the kthread_work structure for this task
+  *
+  * Check whether both the Tx and Rx offsets are valid for enabling the vernier
+  * calibration.
+  *
+  * Once we have valid offsets from hardware, update the total Tx and Rx
+  * offsets, and exit bypass mode. This enables more precise timestamps using
+  * the extra data measured during the vernier calibration process.
+  */
+ static void ice_ptp_wait_for_offset_valid(struct kthread_work *work)
+ {
+ 	struct ice_ptp_port *port;
+ 	int err;
+ 	struct device *dev;
+ 	struct ice_pf *pf;
+ 	struct ice_hw *hw;
+ 
+ 	port = container_of(work, struct ice_ptp_port, ov_work.work);
+ 	pf = ptp_port_to_pf(port);
+ 	hw = &pf->hw;
+ 	dev = ice_pf_to_dev(pf);
+ 
+ 	if (ice_ptp_check_offset_valid(port)) {
+ 		/* Offsets not ready yet, try again later */
+ 		kthread_queue_delayed_work(pf->ptp.kworker,
+ 					   &port->ov_work,
+ 					   msecs_to_jiffies(100));
+ 		return;
+ 	}
+ 
+ 	/* Offsets are valid, so it is safe to exit bypass mode */
+ 	err = ice_phy_exit_bypass_e822(hw, port->port_num);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to exit bypass mode for PHY port %u, err %d\n",
+ 			 port->port_num, err);
+ 		return;
+ 	}
+ }
+ 
+ /**
+  * ice_ptp_port_phy_stop - Stop timestamping for a PHY port
+  * @ptp_port: PTP port to stop
+  */
+ static int
+ ice_ptp_port_phy_stop(struct ice_ptp_port *ptp_port)
+ {
+ 	struct ice_pf *pf = ptp_port_to_pf(ptp_port);
+ 	u8 port = ptp_port->port_num;
+ 	struct ice_hw *hw = &pf->hw;
+ 	int err;
+ 
+ 	if (ice_is_e810(hw))
+ 		return 0;
+ 
+ 	mutex_lock(&ptp_port->ps_lock);
+ 
+ 	kthread_cancel_delayed_work_sync(&ptp_port->ov_work);
+ 
+ 	err = ice_stop_phy_timer_e822(hw, port, true);
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(pf), "PTP failed to set PHY port %d down, err %d\n",
+ 			port, err);
+ 
+ 	mutex_unlock(&ptp_port->ps_lock);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_port_phy_restart - (Re)start and calibrate PHY timestamping
+  * @ptp_port: PTP port for which the PHY start is set
+  *
+  * Start the PHY timestamping block, and initiate Vernier timestamping
+  * calibration. If timestamping cannot be calibrated (such as if link is down)
+  * then disable the timestamping block instead.
+  */
+ static int
+ ice_ptp_port_phy_restart(struct ice_ptp_port *ptp_port)
+ {
+ 	struct ice_pf *pf = ptp_port_to_pf(ptp_port);
+ 	u8 port = ptp_port->port_num;
+ 	struct ice_hw *hw = &pf->hw;
+ 	int err;
+ 
+ 	if (ice_is_e810(hw))
+ 		return 0;
+ 
+ 	if (!ptp_port->link_up)
+ 		return ice_ptp_port_phy_stop(ptp_port);
+ 
+ 	mutex_lock(&ptp_port->ps_lock);
+ 
+ 	kthread_cancel_delayed_work_sync(&ptp_port->ov_work);
+ 
+ 	/* temporarily disable Tx timestamps while calibrating PHY offset */
+ 	ptp_port->tx.calibrating = true;
+ 	ptp_port->tx_fifo_busy_cnt = 0;
+ 
+ 	/* Start the PHY timer in bypass mode */
+ 	err = ice_start_phy_timer_e822(hw, port, true);
+ 	if (err)
+ 		goto out_unlock;
+ 
+ 	/* Enable Tx timestamps right away */
+ 	ptp_port->tx.calibrating = false;
+ 
+ 	kthread_queue_delayed_work(pf->ptp.kworker, &ptp_port->ov_work, 0);
+ 
+ out_unlock:
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(pf), "PTP failed to set PHY port %d up, err %d\n",
+ 			port, err);
+ 
+ 	mutex_unlock(&ptp_port->ps_lock);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_link_change - Set or clear port registers for timestamping
+  * @pf: Board private structure
+  * @port: Port for which the PHY start is set
+  * @linkup: Link is up or down
+  */
+ int ice_ptp_link_change(struct ice_pf *pf, u8 port, bool linkup)
+ {
+ 	struct ice_ptp_port *ptp_port;
+ 
+ 	if (!test_bit(ICE_FLAG_PTP_SUPPORTED, pf->flags))
+ 		return 0;
+ 
+ 	if (port >= ICE_NUM_EXTERNAL_PORTS)
+ 		return -EINVAL;
+ 
+ 	ptp_port = &pf->ptp.port;
+ 	if (ptp_port->port_num != port)
+ 		return -EINVAL;
+ 
+ 	/* Update cached link err for this port immediately */
+ 	ptp_port->link_up = linkup;
+ 
+ 	if (!test_bit(ICE_FLAG_PTP, pf->flags))
+ 		/* PTP is not setup */
+ 		return -EAGAIN;
+ 
+ 	return ice_ptp_port_phy_restart(ptp_port);
+ }
+ 
+ /**
+  * ice_ptp_reset_ts_memory - Reset timestamp memory for all quads
+  * @pf: The PF private data structure
+  */
+ static void ice_ptp_reset_ts_memory(struct ice_pf *pf)
+ {
+ 	int quad;
+ 
+ 	quad = pf->hw.port_info->lport / ICE_PORTS_PER_QUAD;
+ 	ice_ptp_reset_ts_memory_quad(pf, quad);
+ }
+ 
+ /**
+  * ice_ptp_tx_ena_intr - Enable or disable the Tx timestamp interrupt
+  * @pf: PF private structure
+  * @ena: bool value to enable or disable interrupt
+  * @threshold: Minimum number of packets at which intr is triggered
+  *
+  * Utility function to enable or disable Tx timestamp interrupt and threshold
+  */
+ static int ice_ptp_tx_ena_intr(struct ice_pf *pf, bool ena, u32 threshold)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 	int err = 0;
+ 	int quad;
+ 	u32 val;
+ 
+ 	ice_ptp_reset_ts_memory(pf);
+ 
+ 	for (quad = 0; quad < ICE_MAX_QUAD; quad++) {
+ 		err = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG,
+ 					     &val);
+ 		if (err)
+ 			break;
+ 
+ 		if (ena) {
+ 			val |= Q_REG_TX_MEM_GBL_CFG_INTR_ENA_M;
+ 			val &= ~Q_REG_TX_MEM_GBL_CFG_INTR_THR_M;
+ 			val |= ((threshold << Q_REG_TX_MEM_GBL_CFG_INTR_THR_S) &
+ 				Q_REG_TX_MEM_GBL_CFG_INTR_THR_M);
+ 		} else {
+ 			val &= ~Q_REG_TX_MEM_GBL_CFG_INTR_ENA_M;
+ 		}
+ 
+ 		err = ice_write_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG,
+ 					      val);
+ 		if (err)
+ 			break;
+ 	}
+ 
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(pf), "PTP failed in intr ena, err %d\n",
+ 			err);
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_reset_phy_timestamping - Reset PHY timestamping block
+  * @pf: Board private structure
+  */
+ static void ice_ptp_reset_phy_timestamping(struct ice_pf *pf)
+ {
+ 	ice_ptp_port_phy_restart(&pf->ptp.port);
++>>>>>>> a69f1cb62aec (ice: exit bypass mode once hardware finishes timestamp calibration)
  }
  
  /**
@@@ -1853,10 -2263,27 +2243,19 @@@ void ice_ptp_reset(struct ice_pf *pf
  	/* Release the global hardware lock */
  	ice_ptp_unlock(hw);
  
 -	if (!ice_is_e810(hw)) {
 -		/* Enable quad interrupts */
 -		err = ice_ptp_tx_ena_intr(pf, true, itr);
 -		if (err)
 -			goto err;
 -	}
 -
 -reset_ts:
 -	/* Restart the PHY timestamping block */
 -	ice_ptp_reset_phy_timestamping(pf);
 -
  pfr:
  	/* Init Tx structures */
- 	if (ice_is_e810(&pf->hw))
+ 	if (ice_is_e810(&pf->hw)) {
  		err = ice_ptp_init_tx_e810(pf, &ptp->port.tx);
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		kthread_init_delayed_work(&ptp->port.ov_work,
+ 					  ice_ptp_wait_for_offset_valid);
+ 		err = ice_ptp_init_tx_e822(pf, &ptp->port.tx,
+ 					   ptp->port.port_num);
+ 	}
++>>>>>>> a69f1cb62aec (ice: exit bypass mode once hardware finishes timestamp calibration)
  	if (err)
  		goto err;
  
@@@ -2013,7 -2437,14 +2412,18 @@@ static int ice_ptp_init_work(struct ice
   */
  static int ice_ptp_init_port(struct ice_pf *pf, struct ice_ptp_port *ptp_port)
  {
++<<<<<<< HEAD
 +	return ice_ptp_init_tx_e810(pf, &ptp_port->tx);
++=======
+ 	mutex_init(&ptp_port->ps_lock);
+ 
+ 	if (ice_is_e810(&pf->hw))
+ 		return ice_ptp_init_tx_e810(pf, &ptp_port->tx);
+ 
+ 	kthread_init_delayed_work(&ptp_port->ov_work,
+ 				  ice_ptp_wait_for_offset_valid);
+ 	return ice_ptp_init_tx_e822(pf, &ptp_port->tx, ptp_port->port_num);
++>>>>>>> a69f1cb62aec (ice: exit bypass mode once hardware finishes timestamp calibration)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.h
index e7411d5003d7,afd048d69959..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.h
@@@ -101,15 -104,24 +101,31 @@@ struct ice_ptp_tx 
  /**
   * struct ice_ptp_port - data used to initialize an external port for PTP
   *
 - * This structure contains data indicating whether a single external port is
 - * ready for PTP functionality. It is used to track the port initialization
 - * and determine when the port's PHY offset is valid.
 + * This structure contains PTP data related to the external ports. Currently
 + * it is used for tracking the Tx timestamps of a port. In the future this
 + * structure will also hold information for the E822 port initialization
 + * logic.
   *
   * @tx: Tx timestamp tracking for this port
++<<<<<<< HEAD
 + */
 +struct ice_ptp_port {
 +	struct ice_ptp_tx tx;
++=======
+  * @ov_work: delayed work task for tracking when PHY offset is valid
+  * @ps_lock: mutex used to protect the overall PTP PHY start procedure
+  * @link_up: indicates whether the link is up
+  * @tx_fifo_busy_cnt: number of times the Tx FIFO was busy
+  * @port_num: the port number this structure represents
+  */
+ struct ice_ptp_port {
+ 	struct ice_ptp_tx tx;
+ 	struct kthread_delayed_work ov_work;
+ 	struct mutex ps_lock; /* protects overall PTP PHY start procedure */
+ 	bool link_up;
+ 	u8 tx_fifo_busy_cnt;
+ 	u8 port_num;
++>>>>>>> a69f1cb62aec (ice: exit bypass mode once hardware finishes timestamp calibration)
  };
  
  #define GLTSYN_TGT_H_IDX_MAX		4
diff --cc drivers/net/ethernet/intel/ice/ice_ptp_hw.c
index 5dbd4d91dba1,ec8450f034e6..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
@@@ -51,6 -80,2447 +51,2450 @@@ u8 ice_get_ptp_src_clock_index(struct i
  	return hw->func_caps.ts_func_info.tmr_index_assoc;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ice_ptp_read_src_incval - Read source timer increment value
+  * @hw: pointer to HW struct
+  *
+  * Read the increment value of the source timer and return it.
+  */
+ static u64 ice_ptp_read_src_incval(struct ice_hw *hw)
+ {
+ 	u32 lo, hi;
+ 	u8 tmr_idx;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 
+ 	lo = rd32(hw, GLTSYN_INCVAL_L(tmr_idx));
+ 	hi = rd32(hw, GLTSYN_INCVAL_H(tmr_idx));
+ 
+ 	return ((u64)(hi & INCVAL_HIGH_M) << 32) | lo;
+ }
+ 
+ /**
+  * ice_ptp_src_cmd - Prepare source timer for a timer command
+  * @hw: pointer to HW structure
+  * @cmd: Timer command
+  *
+  * Prepare the source timer for an upcoming timer sync command.
+  */
+ static void ice_ptp_src_cmd(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)
+ {
+ 	u32 cmd_val;
+ 	u8 tmr_idx;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 	cmd_val = tmr_idx << SEL_CPK_SRC;
+ 
+ 	switch (cmd) {
+ 	case INIT_TIME:
+ 		cmd_val |= GLTSYN_CMD_INIT_TIME;
+ 		break;
+ 	case INIT_INCVAL:
+ 		cmd_val |= GLTSYN_CMD_INIT_INCVAL;
+ 		break;
+ 	case ADJ_TIME:
+ 		cmd_val |= GLTSYN_CMD_ADJ_TIME;
+ 		break;
+ 	case ADJ_TIME_AT_TIME:
+ 		cmd_val |= GLTSYN_CMD_ADJ_INIT_TIME;
+ 		break;
+ 	case READ_TIME:
+ 		cmd_val |= GLTSYN_CMD_READ_TIME;
+ 		break;
+ 	}
+ 
+ 	wr32(hw, GLTSYN_CMD, cmd_val);
+ }
+ 
+ /**
+  * ice_ptp_exec_tmr_cmd - Execute all prepared timer commands
+  * @hw: pointer to HW struct
+  *
+  * Write the SYNC_EXEC_CMD bit to the GLTSYN_CMD_SYNC register, and flush the
+  * write immediately. This triggers the hardware to begin executing all of the
+  * source and PHY timer commands synchronously.
+  */
+ static void ice_ptp_exec_tmr_cmd(struct ice_hw *hw)
+ {
+ 	wr32(hw, GLTSYN_CMD_SYNC, SYNC_EXEC_CMD);
+ 	ice_flush(hw);
+ }
+ 
+ /* E822 family functions
+  *
+  * The following functions operate on the E822 family of devices.
+  */
+ 
+ /**
+  * ice_fill_phy_msg_e822 - Fill message data for a PHY register access
+  * @msg: the PHY message buffer to fill in
+  * @port: the port to access
+  * @offset: the register offset
+  */
+ static void
+ ice_fill_phy_msg_e822(struct ice_sbq_msg_input *msg, u8 port, u16 offset)
+ {
+ 	int phy_port, phy, quadtype;
+ 
+ 	phy_port = port % ICE_PORTS_PER_PHY;
+ 	phy = port / ICE_PORTS_PER_PHY;
+ 	quadtype = (port / ICE_PORTS_PER_QUAD) % ICE_NUM_QUAD_TYPE;
+ 
+ 	if (quadtype == 0) {
+ 		msg->msg_addr_low = P_Q0_L(P_0_BASE + offset, phy_port);
+ 		msg->msg_addr_high = P_Q0_H(P_0_BASE + offset, phy_port);
+ 	} else {
+ 		msg->msg_addr_low = P_Q1_L(P_4_BASE + offset, phy_port);
+ 		msg->msg_addr_high = P_Q1_H(P_4_BASE + offset, phy_port);
+ 	}
+ 
+ 	if (phy == 0)
+ 		msg->dest_dev = rmn_0;
+ 	else if (phy == 1)
+ 		msg->dest_dev = rmn_1;
+ 	else
+ 		msg->dest_dev = rmn_2;
+ }
+ 
+ /**
+  * ice_is_64b_phy_reg_e822 - Check if this is a 64bit PHY register
+  * @low_addr: the low address to check
+  * @high_addr: on return, contains the high address of the 64bit register
+  *
+  * Checks if the provided low address is one of the known 64bit PHY values
+  * represented as two 32bit registers. If it is, return the appropriate high
+  * register offset to use.
+  */
+ static bool ice_is_64b_phy_reg_e822(u16 low_addr, u16 *high_addr)
+ {
+ 	switch (low_addr) {
+ 	case P_REG_PAR_PCS_TX_OFFSET_L:
+ 		*high_addr = P_REG_PAR_PCS_TX_OFFSET_U;
+ 		return true;
+ 	case P_REG_PAR_PCS_RX_OFFSET_L:
+ 		*high_addr = P_REG_PAR_PCS_RX_OFFSET_U;
+ 		return true;
+ 	case P_REG_PAR_TX_TIME_L:
+ 		*high_addr = P_REG_PAR_TX_TIME_U;
+ 		return true;
+ 	case P_REG_PAR_RX_TIME_L:
+ 		*high_addr = P_REG_PAR_RX_TIME_U;
+ 		return true;
+ 	case P_REG_TOTAL_TX_OFFSET_L:
+ 		*high_addr = P_REG_TOTAL_TX_OFFSET_U;
+ 		return true;
+ 	case P_REG_TOTAL_RX_OFFSET_L:
+ 		*high_addr = P_REG_TOTAL_RX_OFFSET_U;
+ 		return true;
+ 	case P_REG_UIX66_10G_40G_L:
+ 		*high_addr = P_REG_UIX66_10G_40G_U;
+ 		return true;
+ 	case P_REG_UIX66_25G_100G_L:
+ 		*high_addr = P_REG_UIX66_25G_100G_U;
+ 		return true;
+ 	case P_REG_TX_CAPTURE_L:
+ 		*high_addr = P_REG_TX_CAPTURE_U;
+ 		return true;
+ 	case P_REG_RX_CAPTURE_L:
+ 		*high_addr = P_REG_RX_CAPTURE_U;
+ 		return true;
+ 	case P_REG_TX_TIMER_INC_PRE_L:
+ 		*high_addr = P_REG_TX_TIMER_INC_PRE_U;
+ 		return true;
+ 	case P_REG_RX_TIMER_INC_PRE_L:
+ 		*high_addr = P_REG_RX_TIMER_INC_PRE_U;
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * ice_is_40b_phy_reg_e822 - Check if this is a 40bit PHY register
+  * @low_addr: the low address to check
+  * @high_addr: on return, contains the high address of the 40bit value
+  *
+  * Checks if the provided low address is one of the known 40bit PHY values
+  * split into two registers with the lower 8 bits in the low register and the
+  * upper 32 bits in the high register. If it is, return the appropriate high
+  * register offset to use.
+  */
+ static bool ice_is_40b_phy_reg_e822(u16 low_addr, u16 *high_addr)
+ {
+ 	switch (low_addr) {
+ 	case P_REG_TIMETUS_L:
+ 		*high_addr = P_REG_TIMETUS_U;
+ 		return true;
+ 	case P_REG_PAR_RX_TUS_L:
+ 		*high_addr = P_REG_PAR_RX_TUS_U;
+ 		return true;
+ 	case P_REG_PAR_TX_TUS_L:
+ 		*high_addr = P_REG_PAR_TX_TUS_U;
+ 		return true;
+ 	case P_REG_PCS_RX_TUS_L:
+ 		*high_addr = P_REG_PCS_RX_TUS_U;
+ 		return true;
+ 	case P_REG_PCS_TX_TUS_L:
+ 		*high_addr = P_REG_PCS_TX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PAR_RX_TUS_L:
+ 		*high_addr = P_REG_DESK_PAR_RX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PAR_TX_TUS_L:
+ 		*high_addr = P_REG_DESK_PAR_TX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PCS_RX_TUS_L:
+ 		*high_addr = P_REG_DESK_PCS_RX_TUS_U;
+ 		return true;
+ 	case P_REG_DESK_PCS_TX_TUS_L:
+ 		*high_addr = P_REG_DESK_PCS_TX_TUS_U;
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * ice_read_phy_reg_e822 - Read a PHY register
+  * @hw: pointer to the HW struct
+  * @port: PHY port to read from
+  * @offset: PHY register offset to read
+  * @val: on return, the contents read from the PHY
+  *
+  * Read a PHY register for the given port over the device sideband queue.
+  */
+ int
+ ice_read_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 *val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	ice_fill_phy_msg_e822(&msg, port, offset);
+ 	msg.opcode = ice_sbq_msg_rd;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	*val = msg.data;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_64b_phy_reg_e822 - Read a 64bit value from PHY registers
+  * @hw: pointer to the HW struct
+  * @port: PHY port to read from
+  * @low_addr: offset of the lower register to read from
+  * @val: on return, the contents of the 64bit value from the PHY registers
+  *
+  * Reads the two registers associated with a 64bit value and returns it in the
+  * val pointer. The offset always specifies the lower register offset to use.
+  * The high offset is looked up. This function only operates on registers
+  * known to be two parts of a 64bit value.
+  */
+ static int
+ ice_read_64b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 *val)
+ {
+ 	u32 low, high;
+ 	u16 high_addr;
+ 	int err;
+ 
+ 	/* Only operate on registers known to be split into two 32bit
+ 	 * registers.
+ 	 */
+ 	if (!ice_is_64b_phy_reg_e822(low_addr, &high_addr)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Invalid 64b register addr 0x%08x\n",
+ 			  low_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, low_addr, &low);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read from low register 0x%08x\n, err %d",
+ 			  low_addr, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, high_addr, &high);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read from high register 0x%08x\n, err %d",
+ 			  high_addr, err);
+ 		return err;
+ 	}
+ 
+ 	*val = (u64)high << 32 | low;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_phy_reg_e822 - Write a PHY register
+  * @hw: pointer to the HW struct
+  * @port: PHY port to write to
+  * @offset: PHY register offset to write
+  * @val: The value to write to the register
+  *
+  * Write a PHY register for the given port over the device sideband queue.
+  */
+ int
+ ice_write_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	ice_fill_phy_msg_e822(&msg, port, offset);
+ 	msg.opcode = ice_sbq_msg_wr;
+ 	msg.data = val;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_40b_phy_reg_e822 - Write a 40b value to the PHY
+  * @hw: pointer to the HW struct
+  * @port: port to write to
+  * @low_addr: offset of the low register
+  * @val: 40b value to write
+  *
+  * Write the provided 40b value to the two associated registers by splitting
+  * it up into two chunks, the lower 8 bits and the upper 32 bits.
+  */
+ static int
+ ice_write_40b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 val)
+ {
+ 	u32 low, high;
+ 	u16 high_addr;
+ 	int err;
+ 
+ 	/* Only operate on registers known to be split into a lower 8 bit
+ 	 * register and an upper 32 bit register.
+ 	 */
+ 	if (!ice_is_40b_phy_reg_e822(low_addr, &high_addr)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Invalid 40b register addr 0x%08x\n",
+ 			  low_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	low = (u32)(val & P_REG_40B_LOW_M);
+ 	high = (u32)(val >> P_REG_40B_HIGH_S);
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, low_addr, low);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to low register 0x%08x\n, err %d",
+ 			  low_addr, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, high_addr, high);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to high register 0x%08x\n, err %d",
+ 			  high_addr, err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_64b_phy_reg_e822 - Write a 64bit value to PHY registers
+  * @hw: pointer to the HW struct
+  * @port: PHY port to read from
+  * @low_addr: offset of the lower register to read from
+  * @val: the contents of the 64bit value to write to PHY
+  *
+  * Write the 64bit value to the two associated 32bit PHY registers. The offset
+  * is always specified as the lower register, and the high address is looked
+  * up. This function only operates on registers known to be two parts of
+  * a 64bit value.
+  */
+ static int
+ ice_write_64b_phy_reg_e822(struct ice_hw *hw, u8 port, u16 low_addr, u64 val)
+ {
+ 	u32 low, high;
+ 	u16 high_addr;
+ 	int err;
+ 
+ 	/* Only operate on registers known to be split into two 32bit
+ 	 * registers.
+ 	 */
+ 	if (!ice_is_64b_phy_reg_e822(low_addr, &high_addr)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Invalid 64b register addr 0x%08x\n",
+ 			  low_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	low = lower_32_bits(val);
+ 	high = upper_32_bits(val);
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, low_addr, low);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to low register 0x%08x\n, err %d",
+ 			  low_addr, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, high_addr, high);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write to high register 0x%08x\n, err %d",
+ 			  high_addr, err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_fill_quad_msg_e822 - Fill message data for quad register access
+  * @msg: the PHY message buffer to fill in
+  * @quad: the quad to access
+  * @offset: the register offset
+  *
+  * Fill a message buffer for accessing a register in a quad shared between
+  * multiple PHYs.
+  */
+ static void
+ ice_fill_quad_msg_e822(struct ice_sbq_msg_input *msg, u8 quad, u16 offset)
+ {
+ 	u32 addr;
+ 
+ 	msg->dest_dev = rmn_0;
+ 
+ 	if ((quad % ICE_NUM_QUAD_TYPE) == 0)
+ 		addr = Q_0_BASE + offset;
+ 	else
+ 		addr = Q_1_BASE + offset;
+ 
+ 	msg->msg_addr_low = lower_16_bits(addr);
+ 	msg->msg_addr_high = upper_16_bits(addr);
+ }
+ 
+ /**
+  * ice_read_quad_reg_e822 - Read a PHY quad register
+  * @hw: pointer to the HW struct
+  * @quad: quad to read from
+  * @offset: quad register offset to read
+  * @val: on return, the contents read from the quad
+  *
+  * Read a quad register over the device sideband queue. Quad registers are
+  * shared between multiple PHYs.
+  */
+ int
+ ice_read_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 *val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	if (quad >= ICE_MAX_QUAD)
+ 		return -EINVAL;
+ 
+ 	ice_fill_quad_msg_e822(&msg, quad, offset);
+ 	msg.opcode = ice_sbq_msg_rd;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	*val = msg.data;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_write_quad_reg_e822 - Write a PHY quad register
+  * @hw: pointer to the HW struct
+  * @quad: quad to write to
+  * @offset: quad register offset to write
+  * @val: The value to write to the register
+  *
+  * Write a quad register over the device sideband queue. Quad registers are
+  * shared between multiple PHYs.
+  */
+ int
+ ice_write_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 val)
+ {
+ 	struct ice_sbq_msg_input msg = {0};
+ 	int err;
+ 
+ 	if (quad >= ICE_MAX_QUAD)
+ 		return -EINVAL;
+ 
+ 	ice_fill_quad_msg_e822(&msg, quad, offset);
+ 	msg.opcode = ice_sbq_msg_wr;
+ 	msg.data = val;
+ 
+ 	err = ice_sbq_rw_reg(hw, &msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to send message to PHY, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_phy_tstamp_e822 - Read a PHY timestamp out of the quad block
+  * @hw: pointer to the HW struct
+  * @quad: the quad to read from
+  * @idx: the timestamp index to read
+  * @tstamp: on return, the 40bit timestamp value
+  *
+  * Read a 40bit timestamp value out of the two associated registers in the
+  * quad memory block that is shared between the internal PHYs of the E822
+  * family of devices.
+  */
+ static int
+ ice_read_phy_tstamp_e822(struct ice_hw *hw, u8 quad, u8 idx, u64 *tstamp)
+ {
+ 	u16 lo_addr, hi_addr;
+ 	u32 lo, hi;
+ 	int err;
+ 
+ 	lo_addr = (u16)TS_L(Q_REG_TX_MEMORY_BANK_START, idx);
+ 	hi_addr = (u16)TS_H(Q_REG_TX_MEMORY_BANK_START, idx);
+ 
+ 	err = ice_read_quad_reg_e822(hw, quad, lo_addr, &lo);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read low PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_read_quad_reg_e822(hw, quad, hi_addr, &hi);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read high PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* For E822 based internal PHYs, the timestamp is reported with the
+ 	 * lower 8 bits in the low register, and the upper 32 bits in the high
+ 	 * register.
+ 	 */
+ 	*tstamp = ((u64)hi) << TS_PHY_HIGH_S | ((u64)lo & TS_PHY_LOW_M);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_clear_phy_tstamp_e822 - Clear a timestamp from the quad block
+  * @hw: pointer to the HW struct
+  * @quad: the quad to read from
+  * @idx: the timestamp index to reset
+  *
+  * Clear a timestamp, resetting its valid bit, from the PHY quad block that is
+  * shared between the internal PHYs on the E822 devices.
+  */
+ static int
+ ice_clear_phy_tstamp_e822(struct ice_hw *hw, u8 quad, u8 idx)
+ {
+ 	u16 lo_addr, hi_addr;
+ 	int err;
+ 
+ 	lo_addr = (u16)TS_L(Q_REG_TX_MEMORY_BANK_START, idx);
+ 	hi_addr = (u16)TS_H(Q_REG_TX_MEMORY_BANK_START, idx);
+ 
+ 	err = ice_write_quad_reg_e822(hw, quad, lo_addr, 0);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to clear low PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_write_quad_reg_e822(hw, quad, hi_addr, 0);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to clear high PTP timestamp register, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_cgu_reg_e822 - Read a CGU register
+  * @hw: pointer to the HW struct
+  * @addr: Register address to read
+  * @val: storage for register value read
+  *
+  * Read the contents of a register of the Clock Generation Unit. Only
+  * applicable to E822 devices.
+  */
+ static int
+ ice_read_cgu_reg_e822(struct ice_hw *hw, u32 addr, u32 *val)
+ {
+ 	struct ice_sbq_msg_input cgu_msg;
+ 	int err;
+ 
+ 	cgu_msg.opcode = ice_sbq_msg_rd;
+ 	cgu_msg.dest_dev = cgu;
+ 	cgu_msg.msg_addr_low = addr;
+ 	cgu_msg.msg_addr_high = 0x0;
+ 
+ 	err = ice_sbq_rw_reg(hw, &cgu_msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read CGU register 0x%04x, err %d\n",
+ 			  addr, err);
+ 		return err;
+ 	}
+ 
+ 	*val = cgu_msg.data;
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_write_cgu_reg_e822 - Write a CGU register
+  * @hw: pointer to the HW struct
+  * @addr: Register address to write
+  * @val: value to write into the register
+  *
+  * Write the specified value to a register of the Clock Generation Unit. Only
+  * applicable to E822 devices.
+  */
+ static int
+ ice_write_cgu_reg_e822(struct ice_hw *hw, u32 addr, u32 val)
+ {
+ 	struct ice_sbq_msg_input cgu_msg;
+ 	int err;
+ 
+ 	cgu_msg.opcode = ice_sbq_msg_wr;
+ 	cgu_msg.dest_dev = cgu;
+ 	cgu_msg.msg_addr_low = addr;
+ 	cgu_msg.msg_addr_high = 0x0;
+ 	cgu_msg.data = val;
+ 
+ 	err = ice_sbq_rw_reg(hw, &cgu_msg);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write CGU register 0x%04x, err %d\n",
+ 			  addr, err);
+ 		return err;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_clk_freq_str - Convert time_ref_freq to string
+  * @clk_freq: Clock frequency
+  *
+  * Convert the specified TIME_REF clock frequency to a string.
+  */
+ static const char *ice_clk_freq_str(u8 clk_freq)
+ {
+ 	switch ((enum ice_time_ref_freq)clk_freq) {
+ 	case ICE_TIME_REF_FREQ_25_000:
+ 		return "25 MHz";
+ 	case ICE_TIME_REF_FREQ_122_880:
+ 		return "122.88 MHz";
+ 	case ICE_TIME_REF_FREQ_125_000:
+ 		return "125 MHz";
+ 	case ICE_TIME_REF_FREQ_153_600:
+ 		return "153.6 MHz";
+ 	case ICE_TIME_REF_FREQ_156_250:
+ 		return "156.25 MHz";
+ 	case ICE_TIME_REF_FREQ_245_760:
+ 		return "245.76 MHz";
+ 	default:
+ 		return "Unknown";
+ 	}
+ }
+ 
+ /**
+  * ice_clk_src_str - Convert time_ref_src to string
+  * @clk_src: Clock source
+  *
+  * Convert the specified clock source to its string name.
+  */
+ static const char *ice_clk_src_str(u8 clk_src)
+ {
+ 	switch ((enum ice_clk_src)clk_src) {
+ 	case ICE_CLK_SRC_TCX0:
+ 		return "TCX0";
+ 	case ICE_CLK_SRC_TIME_REF:
+ 		return "TIME_REF";
+ 	default:
+ 		return "Unknown";
+ 	}
+ }
+ 
+ /**
+  * ice_cfg_cgu_pll_e822 - Configure the Clock Generation Unit
+  * @hw: pointer to the HW struct
+  * @clk_freq: Clock frequency to program
+  * @clk_src: Clock source to select (TIME_REF, or TCX0)
+  *
+  * Configure the Clock Generation Unit with the desired clock frequency and
+  * time reference, enabling the PLL which drives the PTP hardware clock.
+  */
+ static int
+ ice_cfg_cgu_pll_e822(struct ice_hw *hw, enum ice_time_ref_freq clk_freq,
+ 		     enum ice_clk_src clk_src)
+ {
+ 	union tspll_ro_bwm_lf bwm_lf;
+ 	union nac_cgu_dword19 dw19;
+ 	union nac_cgu_dword22 dw22;
+ 	union nac_cgu_dword24 dw24;
+ 	union nac_cgu_dword9 dw9;
+ 	int err;
+ 
+ 	if (clk_freq >= NUM_ICE_TIME_REF_FREQ) {
+ 		dev_warn(ice_hw_to_dev(hw), "Invalid TIME_REF frequency %u\n",
+ 			 clk_freq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (clk_src >= NUM_ICE_CLK_SRC) {
+ 		dev_warn(ice_hw_to_dev(hw), "Invalid clock source %u\n",
+ 			 clk_src);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (clk_src == ICE_CLK_SRC_TCX0 &&
+ 	    clk_freq != ICE_TIME_REF_FREQ_25_000) {
+ 		dev_warn(ice_hw_to_dev(hw),
+ 			 "TCX0 only supports 25 MHz frequency\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD9, &dw9.val);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD24, &dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_cgu_reg_e822(hw, TSPLL_RO_BWM_LF, &bwm_lf.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Log the current clock configuration */
+ 	ice_debug(hw, ICE_DBG_PTP, "Current CGU configuration -- %s, clk_src %s, clk_freq %s, PLL %s\n",
+ 		  dw24.field.ts_pll_enable ? "enabled" : "disabled",
+ 		  ice_clk_src_str(dw24.field.time_ref_sel),
+ 		  ice_clk_freq_str(dw9.field.time_ref_freq_sel),
+ 		  bwm_lf.field.plllock_true_lock_cri ? "locked" : "unlocked");
+ 
+ 	/* Disable the PLL before changing the clock source or frequency */
+ 	if (dw24.field.ts_pll_enable) {
+ 		dw24.field.ts_pll_enable = 0;
+ 
+ 		err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	/* Set the frequency */
+ 	dw9.field.time_ref_freq_sel = clk_freq;
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD9, dw9.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the TS PLL feedback divisor */
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD19, &dw19.val);
+ 	if (err)
+ 		return err;
+ 
+ 	dw19.field.tspll_fbdiv_intgr = e822_cgu_params[clk_freq].feedback_div;
+ 	dw19.field.tspll_ndivratio = 1;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD19, dw19.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the TS PLL post divisor */
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD22, &dw22.val);
+ 	if (err)
+ 		return err;
+ 
+ 	dw22.field.time1588clk_div = e822_cgu_params[clk_freq].post_pll_div;
+ 	dw22.field.time1588clk_sel_div2 = 0;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD22, dw22.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the TS PLL pre divisor and clock source */
+ 	err = ice_read_cgu_reg_e822(hw, NAC_CGU_DWORD24, &dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	dw24.field.ref1588_ck_div = e822_cgu_params[clk_freq].refclk_pre_div;
+ 	dw24.field.tspll_fbdiv_frac = e822_cgu_params[clk_freq].frac_n_div;
+ 	dw24.field.time_ref_sel = clk_src;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Finally, enable the PLL */
+ 	dw24.field.ts_pll_enable = 1;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, NAC_CGU_DWORD24, dw24.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Wait to verify if the PLL locks */
+ 	usleep_range(1000, 5000);
+ 
+ 	err = ice_read_cgu_reg_e822(hw, TSPLL_RO_BWM_LF, &bwm_lf.val);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!bwm_lf.field.plllock_true_lock_cri) {
+ 		dev_warn(ice_hw_to_dev(hw), "CGU PLL failed to lock\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* Log the current clock configuration */
+ 	ice_debug(hw, ICE_DBG_PTP, "New CGU configuration -- %s, clk_src %s, clk_freq %s, PLL %s\n",
+ 		  dw24.field.ts_pll_enable ? "enabled" : "disabled",
+ 		  ice_clk_src_str(dw24.field.time_ref_sel),
+ 		  ice_clk_freq_str(dw9.field.time_ref_freq_sel),
+ 		  bwm_lf.field.plllock_true_lock_cri ? "locked" : "unlocked");
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_init_cgu_e822 - Initialize CGU with settings from firmware
+  * @hw: pointer to the HW structure
+  *
+  * Initialize the Clock Generation Unit of the E822 device.
+  */
+ static int ice_init_cgu_e822(struct ice_hw *hw)
+ {
+ 	struct ice_ts_func_info *ts_info = &hw->func_caps.ts_func_info;
+ 	union tspll_cntr_bist_settings cntr_bist;
+ 	int err;
+ 
+ 	err = ice_read_cgu_reg_e822(hw, TSPLL_CNTR_BIST_SETTINGS,
+ 				    &cntr_bist.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Disable sticky lock detection so lock err reported is accurate */
+ 	cntr_bist.field.i_plllock_sel_0 = 0;
+ 	cntr_bist.field.i_plllock_sel_1 = 0;
+ 
+ 	err = ice_write_cgu_reg_e822(hw, TSPLL_CNTR_BIST_SETTINGS,
+ 				     cntr_bist.val);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Configure the CGU PLL using the parameters from the function
+ 	 * capabilities.
+ 	 */
+ 	err = ice_cfg_cgu_pll_e822(hw, ts_info->time_ref,
+ 				   (enum ice_clk_src)ts_info->clk_src);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_set_vernier_wl - Set the window length for vernier calibration
+  * @hw: pointer to the HW struct
+  *
+  * Set the window length used for the vernier port calibration process.
+  */
+ static int ice_ptp_set_vernier_wl(struct ice_hw *hw)
+ {
+ 	u8 port;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		int err;
+ 
+ 		err = ice_write_phy_reg_e822(hw, port, P_REG_WL,
+ 					     PTP_VERNIER_WL);
+ 		if (err) {
+ 			ice_debug(hw, ICE_DBG_PTP, "Failed to set vernier window length for port %u, err %d\n",
+ 				  port, err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_init_phc_e822 - Perform E822 specific PHC initialization
+  * @hw: pointer to HW struct
+  *
+  * Perform PHC initialization steps specific to E822 devices.
+  */
+ static int ice_ptp_init_phc_e822(struct ice_hw *hw)
+ {
+ 	int err;
+ 	u32 regval;
+ 
+ 	/* Enable reading switch and PHY registers over the sideband queue */
+ #define PF_SB_REM_DEV_CTL_SWITCH_READ BIT(1)
+ #define PF_SB_REM_DEV_CTL_PHY0 BIT(2)
+ 	regval = rd32(hw, PF_SB_REM_DEV_CTL);
+ 	regval |= (PF_SB_REM_DEV_CTL_SWITCH_READ |
+ 		   PF_SB_REM_DEV_CTL_PHY0);
+ 	wr32(hw, PF_SB_REM_DEV_CTL, regval);
+ 
+ 	/* Initialize the Clock Generation Unit */
+ 	err = ice_init_cgu_e822(hw);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Set window length for all the ports */
+ 	return ice_ptp_set_vernier_wl(hw);
+ }
+ 
+ /**
+  * ice_ptp_prep_phy_time_e822 - Prepare PHY port with initial time
+  * @hw: pointer to the HW struct
+  * @time: Time to initialize the PHY port clocks to
+  *
+  * Program the PHY port registers with a new initial time value. The port
+  * clock will be initialized once the driver issues an INIT_TIME sync
+  * command. The time value is the upper 32 bits of the PHY timer, usually in
+  * units of nominal nanoseconds.
+  */
+ static int
+ ice_ptp_prep_phy_time_e822(struct ice_hw *hw, u32 time)
+ {
+ 	u64 phy_time;
+ 	u8 port;
+ 	int err;
+ 
+ 	/* The time represents the upper 32 bits of the PHY timer, so we need
+ 	 * to shift to account for this when programming.
+ 	 */
+ 	phy_time = (u64)time << 32;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		/* Tx case */
+ 		err = ice_write_64b_phy_reg_e822(hw, port,
+ 						 P_REG_TX_TIMER_INC_PRE_L,
+ 						 phy_time);
+ 		if (err)
+ 			goto exit_err;
+ 
+ 		/* Rx case */
+ 		err = ice_write_64b_phy_reg_e822(hw, port,
+ 						 P_REG_RX_TIMER_INC_PRE_L,
+ 						 phy_time);
+ 		if (err)
+ 			goto exit_err;
+ 	}
+ 
+ 	return 0;
+ 
+ exit_err:
+ 	ice_debug(hw, ICE_DBG_PTP, "Failed to write init time for port %u, err %d\n",
+ 		  port, err);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_prep_port_adj_e822 - Prepare a single port for time adjust
+  * @hw: pointer to HW struct
+  * @port: Port number to be programmed
+  * @time: time in cycles to adjust the port Tx and Rx clocks
+  *
+  * Program the port for an atomic adjustment by writing the Tx and Rx timer
+  * registers. The atomic adjustment won't be completed until the driver issues
+  * an ADJ_TIME command.
+  *
+  * Note that time is not in units of nanoseconds. It is in clock time
+  * including the lower sub-nanosecond portion of the port timer.
+  *
+  * Negative adjustments are supported using 2s complement arithmetic.
+  */
+ int
+ ice_ptp_prep_port_adj_e822(struct ice_hw *hw, u8 port, s64 time)
+ {
+ 	u32 l_time, u_time;
+ 	int err;
+ 
+ 	l_time = lower_32_bits(time);
+ 	u_time = upper_32_bits(time);
+ 
+ 	/* Tx case */
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_TIMER_INC_PRE_L,
+ 				     l_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_TIMER_INC_PRE_U,
+ 				     u_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	/* Rx case */
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_TIMER_INC_PRE_L,
+ 				     l_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_TIMER_INC_PRE_U,
+ 				     u_time);
+ 	if (err)
+ 		goto exit_err;
+ 
+ 	return 0;
+ 
+ exit_err:
+ 	ice_debug(hw, ICE_DBG_PTP, "Failed to write time adjust for port %u, err %d\n",
+ 		  port, err);
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_prep_phy_adj_e822 - Prep PHY ports for a time adjustment
+  * @hw: pointer to HW struct
+  * @adj: adjustment in nanoseconds
+  *
+  * Prepare the PHY ports for an atomic time adjustment by programming the PHY
+  * Tx and Rx port registers. The actual adjustment is completed by issuing an
+  * ADJ_TIME or ADJ_TIME_AT_TIME sync command.
+  */
+ static int
+ ice_ptp_prep_phy_adj_e822(struct ice_hw *hw, s32 adj)
+ {
+ 	s64 cycles;
+ 	u8 port;
+ 
+ 	/* The port clock supports adjustment of the sub-nanosecond portion of
+ 	 * the clock. We shift the provided adjustment in nanoseconds to
+ 	 * calculate the appropriate adjustment to program into the PHY ports.
+ 	 */
+ 	if (adj > 0)
+ 		cycles = (s64)adj << 32;
+ 	else
+ 		cycles = -(((s64)-adj) << 32);
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		int err;
+ 
+ 		err = ice_ptp_prep_port_adj_e822(hw, port, cycles);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_prep_phy_incval_e822 - Prepare PHY ports for time adjustment
+  * @hw: pointer to HW struct
+  * @incval: new increment value to prepare
+  *
+  * Prepare each of the PHY ports for a new increment value by programming the
+  * port's TIMETUS registers. The new increment value will be updated after
+  * issuing an INIT_INCVAL command.
+  */
+ static int
+ ice_ptp_prep_phy_incval_e822(struct ice_hw *hw, u64 incval)
+ {
+ 	int err;
+ 	u8 port;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		err = ice_write_40b_phy_reg_e822(hw, port, P_REG_TIMETUS_L,
+ 						 incval);
+ 		if (err)
+ 			goto exit_err;
+ 	}
+ 
+ 	return 0;
+ 
+ exit_err:
+ 	ice_debug(hw, ICE_DBG_PTP, "Failed to write incval for port %u, err %d\n",
+ 		  port, err);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_ptp_read_port_capture - Read a port's local time capture
+  * @hw: pointer to HW struct
+  * @port: Port number to read
+  * @tx_ts: on return, the Tx port time capture
+  * @rx_ts: on return, the Rx port time capture
+  *
+  * Read the port's Tx and Rx local time capture values.
+  *
+  * Note this has no equivalent for the E810 devices.
+  */
+ static int
+ ice_ptp_read_port_capture(struct ice_hw *hw, u8 port, u64 *tx_ts, u64 *rx_ts)
+ {
+ 	int err;
+ 
+ 	/* Tx case */
+ 	err = ice_read_64b_phy_reg_e822(hw, port, P_REG_TX_CAPTURE_L, tx_ts);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read REG_TX_CAPTURE, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "tx_init = 0x%016llx\n",
+ 		  (unsigned long long)*tx_ts);
+ 
+ 	/* Rx case */
+ 	err = ice_read_64b_phy_reg_e822(hw, port, P_REG_RX_CAPTURE_L, rx_ts);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read RX_CAPTURE, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "rx_init = 0x%016llx\n",
+ 		  (unsigned long long)*rx_ts);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_one_port_cmd - Prepare a single PHY port for a timer command
+  * @hw: pointer to HW struct
+  * @port: Port to which cmd has to be sent
+  * @cmd: Command to be sent to the port
+  *
+  * Prepare the requested port for an upcoming timer sync command.
+  *
+  * Note there is no equivalent of this operation on E810, as that device
+  * always handles all external PHYs internally.
+  */
+ static int
+ ice_ptp_one_port_cmd(struct ice_hw *hw, u8 port, enum ice_ptp_tmr_cmd cmd)
+ {
+ 	u32 cmd_val, val;
+ 	u8 tmr_idx;
+ 	int err;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 	cmd_val = tmr_idx << SEL_PHY_SRC;
+ 	switch (cmd) {
+ 	case INIT_TIME:
+ 		cmd_val |= PHY_CMD_INIT_TIME;
+ 		break;
+ 	case INIT_INCVAL:
+ 		cmd_val |= PHY_CMD_INIT_INCVAL;
+ 		break;
+ 	case ADJ_TIME:
+ 		cmd_val |= PHY_CMD_ADJ_TIME;
+ 		break;
+ 	case READ_TIME:
+ 		cmd_val |= PHY_CMD_READ_TIME;
+ 		break;
+ 	case ADJ_TIME_AT_TIME:
+ 		cmd_val |= PHY_CMD_ADJ_TIME_AT_TIME;
+ 		break;
+ 	}
+ 
+ 	/* Tx case */
+ 	/* Read, modify, write */
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_TX_TMR_CMD, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read TX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Modify necessary bits only and perform write */
+ 	val &= ~TS_CMD_MASK;
+ 	val |= cmd_val;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_TMR_CMD, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write back TX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Rx case */
+ 	/* Read, modify, write */
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_RX_TMR_CMD, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read RX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Modify necessary bits only and perform write */
+ 	val &= ~TS_CMD_MASK;
+ 	val |= cmd_val;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_TMR_CMD, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write back RX_TMR_CMD, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_ptp_port_cmd_e822 - Prepare all ports for a timer command
+  * @hw: pointer to the HW struct
+  * @cmd: timer command to prepare
+  *
+  * Prepare all ports connected to this device for an upcoming timer sync
+  * command.
+  */
+ static int
+ ice_ptp_port_cmd_e822(struct ice_hw *hw, enum ice_ptp_tmr_cmd cmd)
+ {
+ 	u8 port;
+ 
+ 	for (port = 0; port < ICE_NUM_EXTERNAL_PORTS; port++) {
+ 		int err;
+ 
+ 		err = ice_ptp_one_port_cmd(hw, port, cmd);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* E822 Vernier calibration functions
+  *
+  * The following functions are used as part of the vernier calibration of
+  * a port. This calibration increases the precision of the timestamps on the
+  * port.
+  */
+ 
+ /**
+  * ice_phy_get_speed_and_fec_e822 - Get link speed and FEC based on serdes mode
+  * @hw: pointer to HW struct
+  * @port: the port to read from
+  * @link_out: if non-NULL, holds link speed on success
+  * @fec_out: if non-NULL, holds FEC algorithm on success
+  *
+  * Read the serdes data for the PHY port and extract the link speed and FEC
+  * algorithm.
+  */
+ static int
+ ice_phy_get_speed_and_fec_e822(struct ice_hw *hw, u8 port,
+ 			       enum ice_ptp_link_spd *link_out,
+ 			       enum ice_ptp_fec_mode *fec_out)
+ {
+ 	enum ice_ptp_link_spd link;
+ 	enum ice_ptp_fec_mode fec;
+ 	u32 serdes;
+ 	int err;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_LINK_SPEED, &serdes);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read serdes info\n");
+ 		return err;
+ 	}
+ 
+ 	/* Determine the FEC algorithm */
+ 	fec = (enum ice_ptp_fec_mode)P_REG_LINK_SPEED_FEC_MODE(serdes);
+ 
+ 	serdes &= P_REG_LINK_SPEED_SERDES_M;
+ 
+ 	/* Determine the link speed */
+ 	if (fec == ICE_PTP_FEC_MODE_RS_FEC) {
+ 		switch (serdes) {
+ 		case ICE_PTP_SERDES_25G:
+ 			link = ICE_PTP_LNK_SPD_25G_RS;
+ 			break;
+ 		case ICE_PTP_SERDES_50G:
+ 			link = ICE_PTP_LNK_SPD_50G_RS;
+ 			break;
+ 		case ICE_PTP_SERDES_100G:
+ 			link = ICE_PTP_LNK_SPD_100G_RS;
+ 			break;
+ 		default:
+ 			return -EIO;
+ 		}
+ 	} else {
+ 		switch (serdes) {
+ 		case ICE_PTP_SERDES_1G:
+ 			link = ICE_PTP_LNK_SPD_1G;
+ 			break;
+ 		case ICE_PTP_SERDES_10G:
+ 			link = ICE_PTP_LNK_SPD_10G;
+ 			break;
+ 		case ICE_PTP_SERDES_25G:
+ 			link = ICE_PTP_LNK_SPD_25G;
+ 			break;
+ 		case ICE_PTP_SERDES_40G:
+ 			link = ICE_PTP_LNK_SPD_40G;
+ 			break;
+ 		case ICE_PTP_SERDES_50G:
+ 			link = ICE_PTP_LNK_SPD_50G;
+ 			break;
+ 		default:
+ 			return -EIO;
+ 		}
+ 	}
+ 
+ 	if (link_out)
+ 		*link_out = link;
+ 	if (fec_out)
+ 		*fec_out = fec;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_cfg_lane_e822 - Configure PHY quad for single/multi-lane timestamp
+  * @hw: pointer to HW struct
+  * @port: to configure the quad for
+  */
+ static void ice_phy_cfg_lane_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	int err;
+ 	u32 val;
+ 	u8 quad;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, NULL);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to get PHY link speed, err %d\n",
+ 			  err);
+ 		return;
+ 	}
+ 
+ 	quad = port / ICE_PORTS_PER_QUAD;
+ 
+ 	err = ice_read_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read TX_MEM_GLB_CFG, err %d\n",
+ 			  err);
+ 		return;
+ 	}
+ 
+ 	if (link_spd >= ICE_PTP_LNK_SPD_40G)
+ 		val &= ~Q_REG_TX_MEM_GBL_CFG_LANE_TYPE_M;
+ 	else
+ 		val |= Q_REG_TX_MEM_GBL_CFG_LANE_TYPE_M;
+ 
+ 	err = ice_write_quad_reg_e822(hw, quad, Q_REG_TX_MEM_GBL_CFG, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write back TX_MEM_GBL_CFG, err %d\n",
+ 			  err);
+ 		return;
+ 	}
+ }
+ 
+ /**
+  * ice_phy_cfg_uix_e822 - Configure Serdes UI to TU conversion for E822
+  * @hw: pointer to the HW structure
+  * @port: the port to configure
+  *
+  * Program the conversion ration of Serdes clock "unit intervals" (UIs) to PHC
+  * hardware clock time units (TUs). That is, determine the number of TUs per
+  * serdes unit interval, and program the UIX registers with this conversion.
+  *
+  * This conversion is used as part of the calibration process when determining
+  * the additional error of a timestamp vs the real time of transmission or
+  * receipt of the packet.
+  *
+  * Hardware uses the number of TUs per 66 UIs, written to the UIX registers
+  * for the two main serdes clock rates, 10G/40G and 25G/100G serdes clocks.
+  *
+  * To calculate the conversion ratio, we use the following facts:
+  *
+  * a) the clock frequency in Hz (cycles per second)
+  * b) the number of TUs per cycle (the increment value of the clock)
+  * c) 1 second per 1 billion nanoseconds
+  * d) the duration of 66 UIs in nanoseconds
+  *
+  * Given these facts, we can use the following table to work out what ratios
+  * to multiply in order to get the number of TUs per 66 UIs:
+  *
+  * cycles |   1 second   | incval (TUs) | nanoseconds
+  * -------+--------------+--------------+-------------
+  * second | 1 billion ns |    cycle     |   66 UIs
+  *
+  * To perform the multiplication using integers without too much loss of
+  * precision, we can take use the following equation:
+  *
+  * (freq * incval * 6600 LINE_UI ) / ( 100 * 1 billion)
+  *
+  * We scale up to using 6600 UI instead of 66 in order to avoid fractional
+  * nanosecond UIs (66 UI at 10G/40G is 6.4 ns)
+  *
+  * The increment value has a maximum expected range of about 34 bits, while
+  * the frequency value is about 29 bits. Multiplying these values shouldn't
+  * overflow the 64 bits. However, we must then further multiply them again by
+  * the Serdes unit interval duration. To avoid overflow here, we split the
+  * overall divide by 1e11 into a divide by 256 (shift down by 8 bits) and
+  * a divide by 390,625,000. This does lose some precision, but avoids
+  * miscalculation due to arithmetic overflow.
+  */
+ static int ice_phy_cfg_uix_e822(struct ice_hw *hw, u8 port)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, uix;
+ 	int err;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second divided by 256 */
+ 	tu_per_sec = (cur_freq * clk_incval) >> 8;
+ 
+ #define LINE_UI_10G_40G 640 /* 6600 UIs is 640 nanoseconds at 10Gb/40Gb */
+ #define LINE_UI_25G_100G 256 /* 6600 UIs is 256 nanoseconds at 25Gb/100Gb */
+ 
+ 	/* Program the 10Gb/40Gb conversion ratio */
+ 	uix = div_u64(tu_per_sec * LINE_UI_10G_40G, 390625000);
+ 
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_UIX66_10G_40G_L,
+ 					 uix);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write UIX66_10G_40G, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	/* Program the 25Gb/100Gb conversion ratio */
+ 	uix = div_u64(tu_per_sec * LINE_UI_25G_100G, 390625000);
+ 
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_UIX66_25G_100G_L,
+ 					 uix);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to write UIX66_25G_100G, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_cfg_parpcs_e822 - Configure TUs per PAR/PCS clock cycle
+  * @hw: pointer to the HW struct
+  * @port: port to configure
+  *
+  * Configure the number of TUs for the PAR and PCS clocks used as part of the
+  * timestamp calibration process. This depends on the link speed, as the PHY
+  * uses different markers depending on the speed.
+  *
+  * 1Gb/10Gb/25Gb:
+  * - Tx/Rx PAR/PCS markers
+  *
+  * 25Gb RS:
+  * - Tx/Rx Reed Solomon gearbox PAR/PCS markers
+  *
+  * 40Gb/50Gb:
+  * - Tx/Rx PAR/PCS markers
+  * - Rx Deskew PAR/PCS markers
+  *
+  * 50G RS and 100GB RS:
+  * - Tx/Rx Reed Solomon gearbox PAR/PCS markers
+  * - Rx Deskew PAR/PCS markers
+  * - Tx PAR/PCS markers
+  *
+  * To calculate the conversion, we use the PHC clock frequency (cycles per
+  * second), the increment value (TUs per cycle), and the related PHY clock
+  * frequency to calculate the TUs per unit of the PHY link clock. The
+  * following table shows how the units convert:
+  *
+  * cycles |  TUs  | second
+  * -------+-------+--------
+  * second | cycle | cycles
+  *
+  * For each conversion register, look up the appropriate frequency from the
+  * e822 PAR/PCS table and calculate the TUs per unit of that clock. Program
+  * this to the appropriate register, preparing hardware to perform timestamp
+  * calibration to calculate the total Tx or Rx offset to adjust the timestamp
+  * in order to calibrate for the internal PHY delays.
+  *
+  * Note that the increment value ranges up to ~34 bits, and the clock
+  * frequency is ~29 bits, so multiplying them together should fit within the
+  * 64 bit arithmetic.
+  */
+ static int ice_phy_cfg_parpcs_e822(struct ice_hw *hw, u8 port)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, phy_tus;
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per cycle of the PHC clock */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* For each PHY conversion register, look up the appropriate link
+ 	 * speed frequency and determine the TUs per that clock's cycle time.
+ 	 * Split this into a high and low value and then program the
+ 	 * appropriate register. If that link speed does not use the
+ 	 * associated register, write zeros to clear it instead.
+ 	 */
+ 
+ 	/* P_REG_PAR_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_par_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_par_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PAR_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_PAR_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_par_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_par_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PAR_RX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_PCS_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_pcs_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_pcs_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PCS_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_PCS_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_pcs_clk)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_pcs_clk);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_PCS_RX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PAR_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_desk_rsgb_par)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_desk_rsgb_par);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PAR_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PAR_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_desk_rsgb_par)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_desk_rsgb_par);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PAR_RX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PCS_TX_TUS */
+ 	if (e822_vernier[link_spd].tx_desk_rsgb_pcs)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].tx_desk_rsgb_pcs);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PCS_TX_TUS_L,
+ 					 phy_tus);
+ 	if (err)
+ 		return err;
+ 
+ 	/* P_REG_DESK_PCS_RX_TUS */
+ 	if (e822_vernier[link_spd].rx_desk_rsgb_pcs)
+ 		phy_tus = div_u64(tu_per_sec,
+ 				  e822_vernier[link_spd].rx_desk_rsgb_pcs);
+ 	else
+ 		phy_tus = 0;
+ 
+ 	return ice_write_40b_phy_reg_e822(hw, port, P_REG_DESK_PCS_RX_TUS_L,
+ 					  phy_tus);
+ }
+ 
+ /**
+  * ice_calc_fixed_tx_offset_e822 - Calculated Fixed Tx offset for a port
+  * @hw: pointer to the HW struct
+  * @link_spd: the Link speed to calculate for
+  *
+  * Calculate the fixed offset due to known static latency data.
+  */
+ static u64
+ ice_calc_fixed_tx_offset_e822(struct ice_hw *hw, enum ice_ptp_link_spd link_spd)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, fixed_offset;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* Calculate number of TUs to add for the fixed Tx latency. Since the
+ 	 * latency measurement is in 1/100th of a nanosecond, we need to
+ 	 * multiply by tu_per_sec and then divide by 1e11. This calculation
+ 	 * overflows 64 bit integer arithmetic, so break it up into two
+ 	 * divisions by 1e4 first then by 1e7.
+ 	 */
+ 	fixed_offset = div_u64(tu_per_sec, 10000);
+ 	fixed_offset *= e822_vernier[link_spd].tx_fixed_delay;
+ 	fixed_offset = div_u64(fixed_offset, 10000000);
+ 
+ 	return fixed_offset;
+ }
+ 
+ /**
+  * ice_phy_cfg_tx_offset_e822 - Configure total Tx timestamp offset
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * Program the P_REG_TOTAL_TX_OFFSET register with the total number of TUs to
+  * adjust Tx timestamps by. This is calculated by combining some known static
+  * latency along with the Vernier offset computations done by hardware.
+  *
+  * This function must be called only after the offset registers are valid,
+  * i.e. after the Vernier calibration wait has passed, to ensure that the PHY
+  * has measured the offset.
+  *
+  * To avoid overflow, when calculating the offset based on the known static
+  * latency values, we use measurements in 1/100th of a nanosecond, and divide
+  * the TUs per second up front. This avoids overflow while allowing
+  * calculation of the adjustment using integer arithmetic.
+  */
+ static int ice_phy_cfg_tx_offset_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	u64 total_offset, val;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset = ice_calc_fixed_tx_offset_e822(hw, link_spd);
+ 
+ 	/* Read the first Vernier offset from the PHY register and add it to
+ 	 * the total offset.
+ 	 */
+ 	if (link_spd == ICE_PTP_LNK_SPD_1G ||
+ 	    link_spd == ICE_PTP_LNK_SPD_10G ||
+ 	    link_spd == ICE_PTP_LNK_SPD_25G ||
+ 	    link_spd == ICE_PTP_LNK_SPD_25G_RS ||
+ 	    link_spd == ICE_PTP_LNK_SPD_40G ||
+ 	    link_spd == ICE_PTP_LNK_SPD_50G) {
+ 		err = ice_read_64b_phy_reg_e822(hw, port,
+ 						P_REG_PAR_PCS_TX_OFFSET_L,
+ 						&val);
+ 		if (err)
+ 			return err;
+ 
+ 		total_offset += val;
+ 	}
+ 
+ 	/* For Tx, we only need to use the second Vernier offset for
+ 	 * multi-lane link speeds with RS-FEC. The lanes will always be
+ 	 * aligned.
+ 	 */
+ 	if (link_spd == ICE_PTP_LNK_SPD_50G_RS ||
+ 	    link_spd == ICE_PTP_LNK_SPD_100G_RS) {
+ 		err = ice_read_64b_phy_reg_e822(hw, port,
+ 						P_REG_PAR_TX_TIME_L,
+ 						&val);
+ 		if (err)
+ 			return err;
+ 
+ 		total_offset += val;
+ 	}
+ 
+ 	/* Now that the total offset has been calculated, program it to the
+ 	 * PHY and indicate that the Tx offset is ready. After this,
+ 	 * timestamps will be enabled.
+ 	 */
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_TX_OFFSET_L,
+ 					 total_offset);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_cfg_fixed_tx_offset_e822 - Configure Tx offset for bypass mode
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * Calculate and program the fixed Tx offset, and indicate that the offset is
+  * ready. This can be used when operating in bypass mode.
+  */
+ static int
+ ice_phy_cfg_fixed_tx_offset_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	u64 total_offset;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset = ice_calc_fixed_tx_offset_e822(hw, link_spd);
+ 
+ 	/* Program the fixed Tx offset into the P_REG_TOTAL_TX_OFFSET_L
+ 	 * register, then indicate that the Tx offset is ready. After this,
+ 	 * timestamps will be enabled.
+ 	 *
+ 	 * Note that this skips including the more precise offsets generated
+ 	 * by the Vernier calibration.
+ 	 */
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_TX_OFFSET_L,
+ 					 total_offset);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_calc_pmd_adj_e822 - Calculate PMD adjustment for Rx
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to adjust for
+  * @link_spd: the current link speed of the PHY
+  * @fec_mode: the current FEC mode of the PHY
+  * @pmd_adj: on return, the amount to adjust the Rx total offset by
+  *
+  * Calculates the adjustment to Rx timestamps due to PMD alignment in the PHY.
+  * This varies by link speed and FEC mode. The value calculated accounts for
+  * various delays caused when receiving a packet.
+  */
+ static int
+ ice_phy_calc_pmd_adj_e822(struct ice_hw *hw, u8 port,
+ 			  enum ice_ptp_link_spd link_spd,
+ 			  enum ice_ptp_fec_mode fec_mode, u64 *pmd_adj)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, mult, adj;
+ 	u8 pmd_align;
+ 	u32 val;
+ 	int err;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_PMD_ALIGNMENT, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read PMD alignment, err %d\n",
+ 			  err);
+ 		return err;
+ 	}
+ 
+ 	pmd_align = (u8)val;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* The PMD alignment adjustment measurement depends on the link speed,
+ 	 * and whether FEC is enabled. For each link speed, the alignment
+ 	 * adjustment is calculated by dividing a value by the length of
+ 	 * a Time Unit in nanoseconds.
+ 	 *
+ 	 * 1G: align == 4 ? 10 * 0.8 : (align + 6 % 10) * 0.8
+ 	 * 10G: align == 65 ? 0 : (align * 0.1 * 32/33)
+ 	 * 10G w/FEC: align * 0.1 * 32/33
+ 	 * 25G: align == 65 ? 0 : (align * 0.4 * 32/33)
+ 	 * 25G w/FEC: align * 0.4 * 32/33
+ 	 * 40G: align == 65 ? 0 : (align * 0.1 * 32/33)
+ 	 * 40G w/FEC: align * 0.1 * 32/33
+ 	 * 50G: align == 65 ? 0 : (align * 0.4 * 32/33)
+ 	 * 50G w/FEC: align * 0.8 * 32/33
+ 	 *
+ 	 * For RS-FEC, if align is < 17 then we must also add 1.6 * 32/33.
+ 	 *
+ 	 * To allow for calculating this value using integer arithmetic, we
+ 	 * instead start with the number of TUs per second, (inverse of the
+ 	 * length of a Time Unit in nanoseconds), multiply by a value based
+ 	 * on the PMD alignment register, and then divide by the right value
+ 	 * calculated based on the table above. To avoid integer overflow this
+ 	 * division is broken up into a step of dividing by 125 first.
+ 	 */
+ 	if (link_spd == ICE_PTP_LNK_SPD_1G) {
+ 		if (pmd_align == 4)
+ 			mult = 10;
+ 		else
+ 			mult = (pmd_align + 6) % 10;
+ 	} else if (link_spd == ICE_PTP_LNK_SPD_10G ||
+ 		   link_spd == ICE_PTP_LNK_SPD_25G ||
+ 		   link_spd == ICE_PTP_LNK_SPD_40G ||
+ 		   link_spd == ICE_PTP_LNK_SPD_50G) {
+ 		/* If Clause 74 FEC, always calculate PMD adjust */
+ 		if (pmd_align != 65 || fec_mode == ICE_PTP_FEC_MODE_CLAUSE74)
+ 			mult = pmd_align;
+ 		else
+ 			mult = 0;
+ 	} else if (link_spd == ICE_PTP_LNK_SPD_25G_RS ||
+ 		   link_spd == ICE_PTP_LNK_SPD_50G_RS ||
+ 		   link_spd == ICE_PTP_LNK_SPD_100G_RS) {
+ 		if (pmd_align < 17)
+ 			mult = pmd_align + 40;
+ 		else
+ 			mult = pmd_align;
+ 	} else {
+ 		ice_debug(hw, ICE_DBG_PTP, "Unknown link speed %d, skipping PMD adjustment\n",
+ 			  link_spd);
+ 		mult = 0;
+ 	}
+ 
+ 	/* In some cases, there's no need to adjust for the PMD alignment */
+ 	if (!mult) {
+ 		*pmd_adj = 0;
+ 		return 0;
+ 	}
+ 
+ 	/* Calculate the adjustment by multiplying TUs per second by the
+ 	 * appropriate multiplier and divisor. To avoid overflow, we first
+ 	 * divide by 125, and then handle remaining divisor based on the link
+ 	 * speed pmd_adj_divisor value.
+ 	 */
+ 	adj = div_u64(tu_per_sec, 125);
+ 	adj *= mult;
+ 	adj = div_u64(adj, e822_vernier[link_spd].pmd_adj_divisor);
+ 
+ 	/* Finally, for 25G-RS and 50G-RS, a further adjustment for the Rx
+ 	 * cycle count is necessary.
+ 	 */
+ 	if (link_spd == ICE_PTP_LNK_SPD_25G_RS) {
+ 		u64 cycle_adj;
+ 		u8 rx_cycle;
+ 
+ 		err = ice_read_phy_reg_e822(hw, port, P_REG_RX_40_TO_160_CNT,
+ 					    &val);
+ 		if (err) {
+ 			ice_debug(hw, ICE_DBG_PTP, "Failed to read 25G-RS Rx cycle count, err %d\n",
+ 				  err);
+ 			return err;
+ 		}
+ 
+ 		rx_cycle = val & P_REG_RX_40_TO_160_CNT_RXCYC_M;
+ 		if (rx_cycle) {
+ 			mult = (4 - rx_cycle) * 40;
+ 
+ 			cycle_adj = div_u64(tu_per_sec, 125);
+ 			cycle_adj *= mult;
+ 			cycle_adj = div_u64(cycle_adj, e822_vernier[link_spd].pmd_adj_divisor);
+ 
+ 			adj += cycle_adj;
+ 		}
+ 	} else if (link_spd == ICE_PTP_LNK_SPD_50G_RS) {
+ 		u64 cycle_adj;
+ 		u8 rx_cycle;
+ 
+ 		err = ice_read_phy_reg_e822(hw, port, P_REG_RX_80_TO_160_CNT,
+ 					    &val);
+ 		if (err) {
+ 			ice_debug(hw, ICE_DBG_PTP, "Failed to read 50G-RS Rx cycle count, err %d\n",
+ 				  err);
+ 			return err;
+ 		}
+ 
+ 		rx_cycle = val & P_REG_RX_80_TO_160_CNT_RXCYC_M;
+ 		if (rx_cycle) {
+ 			mult = rx_cycle * 40;
+ 
+ 			cycle_adj = div_u64(tu_per_sec, 125);
+ 			cycle_adj *= mult;
+ 			cycle_adj = div_u64(cycle_adj, e822_vernier[link_spd].pmd_adj_divisor);
+ 
+ 			adj += cycle_adj;
+ 		}
+ 	}
+ 
+ 	/* Return the calculated adjustment */
+ 	*pmd_adj = adj;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_calc_fixed_rx_offset_e822 - Calculated the fixed Rx offset for a port
+  * @hw: pointer to HW struct
+  * @link_spd: The Link speed to calculate for
+  *
+  * Determine the fixed Rx latency for a given link speed.
+  */
+ static u64
+ ice_calc_fixed_rx_offset_e822(struct ice_hw *hw, enum ice_ptp_link_spd link_spd)
+ {
+ 	u64 cur_freq, clk_incval, tu_per_sec, fixed_offset;
+ 
+ 	cur_freq = ice_e822_pll_freq(ice_e822_time_ref(hw));
+ 	clk_incval = ice_ptp_read_src_incval(hw);
+ 
+ 	/* Calculate TUs per second */
+ 	tu_per_sec = cur_freq * clk_incval;
+ 
+ 	/* Calculate number of TUs to add for the fixed Rx latency. Since the
+ 	 * latency measurement is in 1/100th of a nanosecond, we need to
+ 	 * multiply by tu_per_sec and then divide by 1e11. This calculation
+ 	 * overflows 64 bit integer arithmetic, so break it up into two
+ 	 * divisions by 1e4 first then by 1e7.
+ 	 */
+ 	fixed_offset = div_u64(tu_per_sec, 10000);
+ 	fixed_offset *= e822_vernier[link_spd].rx_fixed_delay;
+ 	fixed_offset = div_u64(fixed_offset, 10000000);
+ 
+ 	return fixed_offset;
+ }
+ 
+ /**
+  * ice_phy_cfg_rx_offset_e822 - Configure total Rx timestamp offset
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * Program the P_REG_TOTAL_RX_OFFSET register with the number of Time Units to
+  * adjust Rx timestamps by. This combines calculations from the Vernier offset
+  * measurements taken in hardware with some data about known fixed delay as
+  * well as adjusting for multi-lane alignment delay.
+  *
+  * This function must be called only after the offset registers are valid,
+  * i.e. after the Vernier calibration wait has passed, to ensure that the PHY
+  * has measured the offset.
+  *
+  * To avoid overflow, when calculating the offset based on the known static
+  * latency values, we use measurements in 1/100th of a nanosecond, and divide
+  * the TUs per second up front. This avoids overflow while allowing
+  * calculation of the adjustment using integer arithmetic.
+  */
+ static int ice_phy_cfg_rx_offset_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	u64 total_offset, pmd, val;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset = ice_calc_fixed_rx_offset_e822(hw, link_spd);
+ 
+ 	/* Read the first Vernier offset from the PHY register and add it to
+ 	 * the total offset.
+ 	 */
+ 	err = ice_read_64b_phy_reg_e822(hw, port,
+ 					P_REG_PAR_PCS_RX_OFFSET_L,
+ 					&val);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset += val;
+ 
+ 	/* For Rx, all multi-lane link speeds include a second Vernier
+ 	 * calibration, because the lanes might not be aligned.
+ 	 */
+ 	if (link_spd == ICE_PTP_LNK_SPD_40G ||
+ 	    link_spd == ICE_PTP_LNK_SPD_50G ||
+ 	    link_spd == ICE_PTP_LNK_SPD_50G_RS ||
+ 	    link_spd == ICE_PTP_LNK_SPD_100G_RS) {
+ 		err = ice_read_64b_phy_reg_e822(hw, port,
+ 						P_REG_PAR_RX_TIME_L,
+ 						&val);
+ 		if (err)
+ 			return err;
+ 
+ 		total_offset += val;
+ 	}
+ 
+ 	/* In addition, Rx must account for the PMD alignment */
+ 	err = ice_phy_calc_pmd_adj_e822(hw, port, link_spd, fec_mode, &pmd);
+ 	if (err)
+ 		return err;
+ 
+ 	/* For RS-FEC, this adjustment adds delay, but for other modes, it
+ 	 * subtracts delay.
+ 	 */
+ 	if (fec_mode == ICE_PTP_FEC_MODE_RS_FEC)
+ 		total_offset += pmd;
+ 	else
+ 		total_offset -= pmd;
+ 
+ 	/* Now that the total offset has been calculated, program it to the
+ 	 * PHY and indicate that the Rx offset is ready. After this,
+ 	 * timestamps will be enabled.
+ 	 */
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_RX_OFFSET_L,
+ 					 total_offset);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_cfg_fixed_rx_offset_e822 - Configure fixed Rx offset for bypass mode
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * Calculate and program the fixed Rx offset, and indicate that the offset is
+  * ready. This can be used when operating in bypass mode.
+  */
+ static int
+ ice_phy_cfg_fixed_rx_offset_e822(struct ice_hw *hw, u8 port)
+ {
+ 	enum ice_ptp_link_spd link_spd;
+ 	enum ice_ptp_fec_mode fec_mode;
+ 	u64 total_offset;
+ 	int err;
+ 
+ 	err = ice_phy_get_speed_and_fec_e822(hw, port, &link_spd, &fec_mode);
+ 	if (err)
+ 		return err;
+ 
+ 	total_offset = ice_calc_fixed_rx_offset_e822(hw, link_spd);
+ 
+ 	/* Program the fixed Rx offset into the P_REG_TOTAL_RX_OFFSET_L
+ 	 * register, then indicate that the Rx offset is ready. After this,
+ 	 * timestamps will be enabled.
+ 	 *
+ 	 * Note that this skips including the more precise offsets generated
+ 	 * by Vernier calibration.
+ 	 */
+ 	err = ice_write_64b_phy_reg_e822(hw, port, P_REG_TOTAL_RX_OFFSET_L,
+ 					 total_offset);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_read_phy_and_phc_time_e822 - Simultaneously capture PHC and PHY time
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to read
+  * @phy_time: on return, the 64bit PHY timer value
+  * @phc_time: on return, the lower 64bits of PHC time
+  *
+  * Issue a READ_TIME timer command to simultaneously capture the PHY and PHC
+  * timer values.
+  */
+ static int
+ ice_read_phy_and_phc_time_e822(struct ice_hw *hw, u8 port, u64 *phy_time,
+ 			       u64 *phc_time)
+ {
+ 	u64 tx_time, rx_time;
+ 	u32 zo, lo;
+ 	u8 tmr_idx;
+ 	int err;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 
+ 	/* Prepare the PHC timer for a READ_TIME capture command */
+ 	ice_ptp_src_cmd(hw, READ_TIME);
+ 
+ 	/* Prepare the PHY timer for a READ_TIME capture command */
+ 	err = ice_ptp_one_port_cmd(hw, port, READ_TIME);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Issue the sync to start the READ_TIME capture */
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	/* Read the captured PHC time from the shadow time registers */
+ 	zo = rd32(hw, GLTSYN_SHTIME_0(tmr_idx));
+ 	lo = rd32(hw, GLTSYN_SHTIME_L(tmr_idx));
+ 	*phc_time = (u64)lo << 32 | zo;
+ 
+ 	/* Read the captured PHY time from the PHY shadow registers */
+ 	err = ice_ptp_read_port_capture(hw, port, &tx_time, &rx_time);
+ 	if (err)
+ 		return err;
+ 
+ 	/* If the PHY Tx and Rx timers don't match, log a warning message.
+ 	 * Note that this should not happen in normal circumstances since the
+ 	 * driver always programs them together.
+ 	 */
+ 	if (tx_time != rx_time)
+ 		dev_warn(ice_hw_to_dev(hw),
+ 			 "PHY port %u Tx and Rx timers do not match, tx_time 0x%016llX, rx_time 0x%016llX\n",
+ 			 port, (unsigned long long)tx_time,
+ 			 (unsigned long long)rx_time);
+ 
+ 	*phy_time = tx_time;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_sync_phy_timer_e822 - Synchronize the PHY timer with PHC timer
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to synchronize
+  *
+  * Perform an adjustment to ensure that the PHY and PHC timers are in sync.
+  * This is done by issuing a READ_TIME command which triggers a simultaneous
+  * read of the PHY timer and PHC timer. Then we use the difference to
+  * calculate an appropriate 2s complement addition to add to the PHY timer in
+  * order to ensure it reads the same value as the primary PHC timer.
+  */
+ static int ice_sync_phy_timer_e822(struct ice_hw *hw, u8 port)
+ {
+ 	u64 phc_time, phy_time, difference;
+ 	int err;
+ 
+ 	if (!ice_ptp_lock(hw)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to acquire PTP semaphore\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = ice_read_phy_and_phc_time_e822(hw, port, &phy_time, &phc_time);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	/* Calculate the amount required to add to the port time in order for
+ 	 * it to match the PHC time.
+ 	 *
+ 	 * Note that the port adjustment is done using 2s complement
+ 	 * arithmetic. This is convenient since it means that we can simply
+ 	 * calculate the difference between the PHC time and the port time,
+ 	 * and it will be interpreted correctly.
+ 	 */
+ 	difference = phc_time - phy_time;
+ 
+ 	err = ice_ptp_prep_port_adj_e822(hw, port, (s64)difference);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	err = ice_ptp_one_port_cmd(hw, port, ADJ_TIME);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	/* Issue the sync to activate the time adjustment */
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	/* Re-capture the timer values to flush the command registers and
+ 	 * verify that the time was properly adjusted.
+ 	 */
+ 	err = ice_read_phy_and_phc_time_e822(hw, port, &phy_time, &phc_time);
+ 	if (err)
+ 		goto err_unlock;
+ 
+ 	dev_info(ice_hw_to_dev(hw),
+ 		 "Port %u PHY time synced to PHC: 0x%016llX, 0x%016llX\n",
+ 		 port, (unsigned long long)phy_time,
+ 		 (unsigned long long)phc_time);
+ 
+ 	ice_ptp_unlock(hw);
+ 
+ 	return 0;
+ 
+ err_unlock:
+ 	ice_ptp_unlock(hw);
+ 	return err;
+ }
+ 
+ /**
+  * ice_stop_phy_timer_e822 - Stop the PHY clock timer
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to stop
+  * @soft_reset: if true, hold the SOFT_RESET bit of P_REG_PS
+  *
+  * Stop the clock of a PHY port. This must be done as part of the flow to
+  * re-calibrate Tx and Rx timestamping offsets whenever the clock time is
+  * initialized or when link speed changes.
+  */
+ int
+ ice_stop_phy_timer_e822(struct ice_hw *hw, u8 port, bool soft_reset)
+ {
+ 	int err;
+ 	u32 val;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_TX_OR, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_RX_OR, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	val &= ~P_REG_PS_START_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val &= ~P_REG_PS_ENA_CLK_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	if (soft_reset) {
+ 		val |= P_REG_PS_SFT_RESET_M;
+ 		err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "Disabled clock on PHY port %u\n", port);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_start_phy_timer_e822 - Start the PHY clock timer
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to start
+  * @bypass: if true, start the PHY in bypass mode
+  *
+  * Start the clock of a PHY port. This must be done as part of the flow to
+  * re-calibrate Tx and Rx timestamping offsets whenever the clock time is
+  * initialized or when link speed changes.
+  *
+  * Bypass mode enables timestamps immediately without waiting for Vernier
+  * calibration to complete. Hardware will still continue taking Vernier
+  * measurements on Tx or Rx of packets, but they will not be applied to
+  * timestamps. Use ice_phy_exit_bypass_e822 to exit bypass mode once hardware
+  * has completed offset calculation.
+  */
+ int
+ ice_start_phy_timer_e822(struct ice_hw *hw, u8 port, bool bypass)
+ {
+ 	u32 lo, hi, val;
+ 	u64 incval;
+ 	u8 tmr_idx;
+ 	int err;
+ 
+ 	tmr_idx = ice_get_ptp_src_clock_index(hw);
+ 
+ 	err = ice_stop_phy_timer_e822(hw, port, false);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_phy_cfg_lane_e822(hw, port);
+ 
+ 	err = ice_phy_cfg_uix_e822(hw, port);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_phy_cfg_parpcs_e822(hw, port);
+ 	if (err)
+ 		return err;
+ 
+ 	lo = rd32(hw, GLTSYN_INCVAL_L(tmr_idx));
+ 	hi = rd32(hw, GLTSYN_INCVAL_H(tmr_idx));
+ 	incval = (u64)hi << 32 | lo;
+ 
+ 	err = ice_write_40b_phy_reg_e822(hw, port, P_REG_TIMETUS_L, incval);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_ptp_one_port_cmd(hw, port, INIT_INCVAL);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	val |= P_REG_PS_SFT_RESET_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val |= P_REG_PS_START_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val &= ~P_REG_PS_SFT_RESET_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_ptp_one_port_cmd(hw, port, INIT_INCVAL);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	val |= P_REG_PS_ENA_CLK_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	val |= P_REG_PS_LOAD_OFFSET_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err)
+ 		return err;
+ 
+ 	ice_ptp_exec_tmr_cmd(hw);
+ 
+ 	err = ice_sync_phy_timer_e822(hw, port);
+ 	if (err)
+ 		return err;
+ 
+ 	if (bypass) {
+ 		val |= P_REG_PS_BYPASS_MODE_M;
+ 		/* Enter BYPASS mode, enabling timestamps immediately. */
+ 		err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 		if (err)
+ 			return err;
+ 
+ 		/* Program the fixed Tx offset */
+ 		err = ice_phy_cfg_fixed_tx_offset_e822(hw, port);
+ 		if (err)
+ 			return err;
+ 
+ 		/* Program the fixed Rx offset */
+ 		err = ice_phy_cfg_fixed_rx_offset_e822(hw, port);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	ice_debug(hw, ICE_DBG_PTP, "Enabled clock on PHY port %u\n", port);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_phy_exit_bypass_e822 - Exit bypass mode, after vernier calculations
+  * @hw: pointer to the HW struct
+  * @port: the PHY port to configure
+  *
+  * After hardware finishes vernier calculations for the Tx and Rx offset, this
+  * function can be used to exit bypass mode by updating the total Tx and Rx
+  * offsets, and then disabling bypass. This will enable hardware to include
+  * the more precise offset calibrations, increasing precision of the generated
+  * timestamps.
+  *
+  * This cannot be done until hardware has measured the offsets, which requires
+  * waiting until at least one packet has been sent and received by the device.
+  */
+ int ice_phy_exit_bypass_e822(struct ice_hw *hw, u8 port)
+ {
+ 	int err;
+ 	u32 val;
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_TX_OV_STATUS, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read TX_OV_STATUS for port %u, err %d\n",
+ 			  port, err);
+ 		return err;
+ 	}
+ 
+ 	if (!(val & P_REG_TX_OV_STATUS_OV_M)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Tx offset is not yet valid for port %u\n",
+ 			  port);
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_RX_OV_STATUS, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read RX_OV_STATUS for port %u, err %d\n",
+ 			  port, err);
+ 		return err;
+ 	}
+ 
+ 	if (!(val & P_REG_TX_OV_STATUS_OV_M)) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Rx offset is not yet valid for port %u\n",
+ 			  port);
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = ice_phy_cfg_tx_offset_e822(hw, port);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to program total Tx offset for port %u, err %d\n",
+ 			  port, err);
+ 		return err;
+ 	}
+ 
+ 	err = ice_phy_cfg_rx_offset_e822(hw, port);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to program total Rx offset for port %u, err %d\n",
+ 			  port, err);
+ 		return err;
+ 	}
+ 
+ 	/* Exit bypass mode now that the offset has been updated */
+ 	err = ice_read_phy_reg_e822(hw, port, P_REG_PS, &val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to read P_REG_PS for port %u, err %d\n",
+ 			  port, err);
+ 		return err;
+ 	}
+ 
+ 	if (!(val & P_REG_PS_BYPASS_MODE_M))
+ 		ice_debug(hw, ICE_DBG_PTP, "Port %u not in bypass mode\n",
+ 			  port);
+ 
+ 	val &= ~P_REG_PS_BYPASS_MODE_M;
+ 	err = ice_write_phy_reg_e822(hw, port, P_REG_PS, val);
+ 	if (err) {
+ 		ice_debug(hw, ICE_DBG_PTP, "Failed to disable bypass for port %u, err %d\n",
+ 			  port, err);
+ 		return err;
+ 	}
+ 
+ 	dev_info(ice_hw_to_dev(hw), "Exiting bypass mode on PHY port %u\n",
+ 		 port);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a69f1cb62aec (ice: exit bypass mode once hardware finishes timestamp calibration)
  /* E810 functions
   *
   * The following functions operate on the E810 series devices which use
diff --cc drivers/net/ethernet/intel/ice/ice_ptp_hw.h
index 55a414e87018,519e75462e67..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp_hw.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp_hw.h
@@@ -27,6 -133,59 +27,62 @@@ int ice_ptp_write_incval_locked(struct 
  int ice_ptp_adj_clock(struct ice_hw *hw, s32 adj);
  int ice_read_phy_tstamp(struct ice_hw *hw, u8 block, u8 idx, u64 *tstamp);
  int ice_clear_phy_tstamp(struct ice_hw *hw, u8 block, u8 idx);
++<<<<<<< HEAD
++=======
+ int ice_ptp_init_phc(struct ice_hw *hw);
+ 
+ /* E822 family functions */
+ int ice_read_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 *val);
+ int ice_write_phy_reg_e822(struct ice_hw *hw, u8 port, u16 offset, u32 val);
+ int ice_read_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 *val);
+ int ice_write_quad_reg_e822(struct ice_hw *hw, u8 quad, u16 offset, u32 val);
+ int ice_ptp_prep_port_adj_e822(struct ice_hw *hw, u8 port, s64 time);
+ 
+ /**
+  * ice_e822_time_ref - Get the current TIME_REF from capabilities
+  * @hw: pointer to the HW structure
+  *
+  * Returns the current TIME_REF from the capabilities structure.
+  */
+ static inline enum ice_time_ref_freq ice_e822_time_ref(struct ice_hw *hw)
+ {
+ 	return hw->func_caps.ts_func_info.time_ref;
+ }
+ 
+ /**
+  * ice_set_e822_time_ref - Set new TIME_REF
+  * @hw: pointer to the HW structure
+  * @time_ref: new TIME_REF to set
+  *
+  * Update the TIME_REF in the capabilities structure in response to some
+  * change, such as an update to the CGU registers.
+  */
+ static inline void
+ ice_set_e822_time_ref(struct ice_hw *hw, enum ice_time_ref_freq time_ref)
+ {
+ 	hw->func_caps.ts_func_info.time_ref = time_ref;
+ }
+ 
+ static inline u64 ice_e822_pll_freq(enum ice_time_ref_freq time_ref)
+ {
+ 	return e822_time_ref[time_ref].pll_freq;
+ }
+ 
+ static inline u64 ice_e822_nominal_incval(enum ice_time_ref_freq time_ref)
+ {
+ 	return e822_time_ref[time_ref].nominal_incval;
+ }
+ 
+ static inline u64 ice_e822_pps_delay(enum ice_time_ref_freq time_ref)
+ {
+ 	return e822_time_ref[time_ref].pps_delay;
+ }
+ 
+ /* E822 Vernier calibration functions */
+ int ice_stop_phy_timer_e822(struct ice_hw *hw, u8 port, bool soft_reset);
+ int ice_start_phy_timer_e822(struct ice_hw *hw, u8 port, bool bypass);
+ int ice_phy_exit_bypass_e822(struct ice_hw *hw, u8 port);
++>>>>>>> a69f1cb62aec (ice: exit bypass mode once hardware finishes timestamp calibration)
  
  /* E810 family functions */
  int ice_ptp_init_phy_e810(struct ice_hw *hw);
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_hw.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_hw.h
