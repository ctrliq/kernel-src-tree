net/mlx5e: Decouple TTC logic from mlx5e

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Maor Gottlieb <maorg@nvidia.com>
commit bc29764ed9a2335a4f2453eba3f270ca84164a6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/bc29764e.failed

Remove dependency in the mlx5e driver from the TTC implementation
by changing the TTC related functions to receive mlx5 generic arguments.
It allows to decouple TTC logic from mlx5e and reused by other parts of
mlx5 driver.

	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit bc29764ed9a2335a4f2453eba3f270ca84164a6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 6d1dade3f38c,c289f7004e10..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -107,28 -94,30 +107,37 @@@ struct mlx5e_tirc_config 
  				 MLX5_HASH_FIELD_SEL_DST_IP   |\
  				 MLX5_HASH_FIELD_SEL_IPSEC_SPI)
  
 -enum mlx5_tunnel_types {
 -	MLX5_TT_IPV4_GRE,
 -	MLX5_TT_IPV6_GRE,
 -	MLX5_TT_IPV4_IPIP,
 -	MLX5_TT_IPV6_IPIP,
 -	MLX5_TT_IPV4_IPV6,
 -	MLX5_TT_IPV6_IPV6,
 -	MLX5_NUM_TUNNEL_TT,
 +enum mlx5e_tunnel_types {
 +	MLX5E_TT_IPV4_GRE,
 +	MLX5E_TT_IPV6_GRE,
 +	MLX5E_TT_IPV4_IPIP,
 +	MLX5E_TT_IPV6_IPIP,
 +	MLX5E_TT_IPV4_IPV6,
 +	MLX5E_TT_IPV6_IPV6,
 +	MLX5E_NUM_TUNNEL_TT,
  };
  
 -bool mlx5_tunnel_inner_ft_supported(struct mlx5_core_dev *mdev);
 +bool mlx5e_tunnel_inner_ft_supported(struct mlx5_core_dev *mdev);
  
- struct mlx5e_ttc_rule {
+ struct mlx5_ttc_rule {
  	struct mlx5_flow_handle *rule;
  	struct mlx5_flow_destination default_dest;
  };
  
  /* L3/L4 traffic type classifier */
++<<<<<<< HEAD
 +struct mlx5e_ttc_table {
 +	struct mlx5e_flow_table ft;
 +	struct mlx5e_ttc_rule rules[MLX5E_NUM_TT];
 +	struct mlx5_flow_handle *tunnel_rules[MLX5E_NUM_TUNNEL_TT];
++=======
+ struct mlx5_ttc_table {
+ 	int num_groups;
+ 	struct mlx5_flow_table *t;
+ 	struct mlx5_flow_group **g;
+ 	struct mlx5_ttc_rule rules[MLX5_NUM_TT];
+ 	struct mlx5_flow_handle *tunnel_rules[MLX5_NUM_TUNNEL_TT];
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  };
  
  /* NIC prio FTS */
@@@ -231,10 -223,10 +240,10 @@@ struct mlx5e_flow_steering 
  #endif
  	struct mlx5e_tc_table           tc;
  	struct mlx5e_promisc_table      promisc;
 -	struct mlx5e_vlan_table         *vlan;
 +	struct mlx5e_vlan_table         vlan;
  	struct mlx5e_l2_table           l2;
- 	struct mlx5e_ttc_table          ttc;
- 	struct mlx5e_ttc_table          inner_ttc;
+ 	struct mlx5_ttc_table           ttc;
+ 	struct mlx5_ttc_table           inner_ttc;
  #ifdef CONFIG_MLX5_EN_ARFS
  	struct mlx5e_arfs_tables       *arfs;
  #endif
@@@ -246,26 -238,29 +255,36 @@@
  };
  
  struct ttc_params {
+ 	struct mlx5_flow_namespace *ns;
  	struct mlx5_flow_table_attr ft_attr;
- 	u32 any_tt_tirn;
- 	u32 indir_tirn[MLX5E_NUM_INDIR_TIRS];
- 	struct mlx5e_ttc_table *inner_ttc;
+ 	struct mlx5_flow_destination dests[MLX5_NUM_TT];
+ 	bool   inner_ttc;
+ 	struct mlx5_flow_destination tunnel_dests[MLX5_NUM_TUNNEL_TT];
  };
  
- void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv, struct ttc_params *ttc_params);
- void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params);
+ void mlx5e_set_ttc_params(struct mlx5e_priv *priv,
+ 			  struct ttc_params *ttc_params, bool tunnel);
  
- int mlx5e_create_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
- 			   struct mlx5e_ttc_table *ttc);
- void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv,
- 			     struct mlx5e_ttc_table *ttc);
+ int mlx5_create_ttc_table(struct mlx5_core_dev *dev, struct ttc_params *params,
+ 			  struct mlx5_ttc_table *ttc);
+ void mlx5_destroy_ttc_table(struct mlx5_ttc_table *ttc);
  
  void mlx5e_destroy_flow_table(struct mlx5e_flow_table *ft);
++<<<<<<< HEAD
 +int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
 +		       struct mlx5_flow_destination *new_dest);
 +struct mlx5_flow_destination
 +mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type);
 +int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type);
++=======
+ int mlx5_ttc_fwd_dest(struct mlx5_ttc_table *ttc, enum mlx5_traffic_types type,
+ 		      struct mlx5_flow_destination *new_dest);
+ struct mlx5_flow_destination
+ mlx5_ttc_get_default_dest(struct mlx5_ttc_table *ttc,
+ 			  enum mlx5_traffic_types type);
+ int mlx5_ttc_fwd_default_dest(struct mlx5_ttc_table *ttc,
+ 			      enum mlx5_traffic_types type);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  
  void mlx5e_enable_cvlan_filter(struct mlx5e_priv *priv);
  void mlx5e_disable_cvlan_filter(struct mlx5e_priv *priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index 909faa6c89d7,68cc3a8fd6b7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@@ -401,7 -402,7 +402,11 @@@ static int fs_any_add_default_rule(stru
  	fs_any = priv->fs.any;
  	fs_any_t = &fs_any->table;
  
++<<<<<<< HEAD
 +	dest = mlx5e_ttc_get_default_dest(priv, MLX5E_TT_ANY);
++=======
+ 	dest = mlx5_ttc_get_default_dest(&priv->fs.ttc, MLX5_TT_ANY);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	rule = mlx5_add_flow_rules(fs_any_t->t, NULL, &flow_act, &dest, 1);
  	if (IS_ERR(rule)) {
  		err = PTR_ERR(rule);
@@@ -514,7 -515,7 +519,11 @@@ static int fs_any_disable(struct mlx5e_
  	int err;
  
  	/* Modify ttc rules destination to point back to the indir TIRs */
++<<<<<<< HEAD
 +	err = mlx5e_ttc_fwd_default_dest(priv, MLX5E_TT_ANY);
++=======
+ 	err = mlx5_ttc_fwd_default_dest(&priv->fs.ttc, MLX5_TT_ANY);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev,
  			   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@@ -533,7 -534,7 +542,11 @@@ static int fs_any_enable(struct mlx5e_p
  	dest.ft = priv->fs.any->table.t;
  
  	/* Modify ttc rules destination to point on the accel_fs FTs */
++<<<<<<< HEAD
 +	err = mlx5e_ttc_fwd_dest(priv, MLX5E_TT_ANY, &dest);
++=======
+ 	err = mlx5_ttc_fwd_dest(&priv->fs.ttc, MLX5_TT_ANY, &dest);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev,
  			   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 059efb0721cd,a03842d132f6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -1032,42 -1057,34 +1030,62 @@@ static int mlx5_generate_ttc_table_rule
  	int tt;
  	int err;
  
- 	ft = ttc->ft.t;
+ 	ft = ttc->t;
  	rules = ttc->rules;
++<<<<<<< HEAD
 +
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 +	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
 +		struct mlx5e_ttc_rule *rule = &rules[tt];
 +
 +		if (tt == MLX5E_TT_ANY)
 +			dest.tir_num = params->any_tt_tirn;
 +		else
 +			dest.tir_num = params->indir_tirn[tt];
 +
 +		rule->rule = mlx5e_generate_ttc_rule(priv, ft, &dest,
 +						     ttc_rules[tt].etype,
 +						     ttc_rules[tt].proto);
++=======
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		struct mlx5_ttc_rule *rule = &rules[tt];
+ 
+ 		rule->rule = mlx5_generate_ttc_rule(dev, ft, &params->dests[tt],
+ 						    ttc_rules[tt].etype,
+ 						    ttc_rules[tt].proto);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		if (IS_ERR(rule->rule)) {
  			err = PTR_ERR(rule->rule);
  			rule->rule = NULL;
  			goto del_rules;
  		}
- 		rule->default_dest = dest;
+ 		rule->default_dest = params->dests[tt];
  	}
  
++<<<<<<< HEAD
 +	if (!params->inner_ttc || !mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		return 0;
 +
 +	trules    = ttc->tunnel_rules;
 +	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
 +	dest.ft   = params->inner_ttc->ft.t;
 +	for (tt = 0; tt < MLX5E_NUM_TUNNEL_TT; tt++) {
 +		if (!mlx5e_tunnel_proto_supported_rx(priv->mdev,
 +						     ttc_tunnel_rules[tt].proto))
++=======
+ 	if (!params->inner_ttc || !mlx5_tunnel_inner_ft_supported(dev))
+ 		return 0;
+ 
+ 	trules    = ttc->tunnel_rules;
+ 	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
+ 		if (!mlx5_tunnel_proto_supported_rx(dev,
+ 						    ttc_tunnel_rules[tt].proto))
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  			continue;
- 		trules[tt] = mlx5e_generate_ttc_rule(priv, ft, &dest,
- 						     ttc_tunnel_rules[tt].etype,
- 						     ttc_tunnel_rules[tt].proto);
+ 		trules[tt] = mlx5_generate_ttc_rule(dev, ft,
+ 						    &params->tunnel_dests[tt],
+ 						    ttc_tunnel_rules[tt].etype,
+ 						    ttc_tunnel_rules[tt].proto);
  		if (IS_ERR(trules[tt])) {
  			err = PTR_ERR(trules[tt]);
  			trules[tt] = NULL;
@@@ -1092,9 -1108,8 +1109,14 @@@ static int mlx5_create_ttc_table_groups
  	int err;
  	u8 *mc;
  
++<<<<<<< HEAD
 +	ft->g = kcalloc(MLX5E_TTC_NUM_GROUPS,
 +			sizeof(*ft->g), GFP_KERNEL);
 +	if (!ft->g)
++=======
+ 	ttc->g = kcalloc(MLX5_TTC_NUM_GROUPS, sizeof(*ttc->g), GFP_KERNEL);
+ 	if (!ttc->g)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		return -ENOMEM;
  	in = kvzalloc(inlen, GFP_KERNEL);
  	if (!in) {
@@@ -1112,32 -1127,32 +1134,32 @@@
  		MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);
  	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_TTC_GROUP1_SIZE;
 +	ix += MLX5E_TTC_GROUP1_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* L3 Group */
  	MLX5_SET(fte_match_param, mc, outer_headers.ip_protocol, 0);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_TTC_GROUP2_SIZE;
 +	ix += MLX5E_TTC_GROUP2_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* Any Group */
  	memset(in, 0, inlen);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_TTC_GROUP3_SIZE;
 +	ix += MLX5E_TTC_GROUP3_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	kvfree(in);
  	return 0;
@@@ -1199,21 -1213,16 +1220,30 @@@ static int mlx5_generate_inner_ttc_tabl
  	int err;
  	int tt;
  
- 	ft = ttc->ft.t;
+ 	ft = ttc->t;
  	rules = ttc->rules;
- 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
 +		struct mlx5e_ttc_rule *rule = &rules[tt];
 +
 +		if (tt == MLX5E_TT_ANY)
 +			dest.tir_num = params->any_tt_tirn;
 +		else
 +			dest.tir_num = params->indir_tirn[tt];
 +
 +		rule->rule = mlx5e_generate_inner_ttc_rule(priv, ft, &dest,
 +							   ttc_rules[tt].etype,
 +							   ttc_rules[tt].proto);
++=======
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		struct mlx5_ttc_rule *rule = &rules[tt];
+ 
+ 		rule->rule = mlx5_generate_inner_ttc_rule(dev, ft,
+ 							  &params->dests[tt],
+ 							  ttc_rules[tt].etype,
+ 							  ttc_rules[tt].proto);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		if (IS_ERR(rule->rule)) {
  			err = PTR_ERR(rule->rule);
  			rule->rule = NULL;
@@@ -1239,8 -1247,9 +1268,14 @@@ static int mlx5_create_inner_ttc_table_
  	int err;
  	u8 *mc;
  
++<<<<<<< HEAD
 +	ft->g = kcalloc(MLX5E_INNER_TTC_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);
 +	if (!ft->g)
++=======
+ 	ttc->g = kcalloc(MLX5_INNER_TTC_NUM_GROUPS, sizeof(*ttc->g),
+ 			 GFP_KERNEL);
+ 	if (!ttc->g)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		return -ENOMEM;
  	in = kvzalloc(inlen, GFP_KERNEL);
  	if (!in) {
@@@ -1255,32 -1264,32 +1290,32 @@@
  	MLX5_SET_TO_ONES(fte_match_param, mc, inner_headers.ip_version);
  	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_INNER_HEADERS);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_INNER_TTC_GROUP1_SIZE;
 +	ix += MLX5E_INNER_TTC_GROUP1_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* L3 Group */
  	MLX5_SET(fte_match_param, mc, inner_headers.ip_protocol, 0);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_INNER_TTC_GROUP2_SIZE;
 +	ix += MLX5E_INNER_TTC_GROUP2_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	/* Any Group */
  	memset(in, 0, inlen);
  	MLX5_SET_CFG(in, start_flow_index, ix);
 -	ix += MLX5_INNER_TTC_GROUP3_SIZE;
 +	ix += MLX5E_INNER_TTC_GROUP3_SIZE;
  	MLX5_SET_CFG(in, end_flow_index, ix - 1);
- 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
- 	if (IS_ERR(ft->g[ft->num_groups]))
+ 	ttc->g[ttc->num_groups] = mlx5_create_flow_group(ttc->t, in);
+ 	if (IS_ERR(ttc->g[ttc->num_groups]))
  		goto err;
- 	ft->num_groups++;
+ 	ttc->num_groups++;
  
  	kvfree(in);
  	return 0;
@@@ -1293,42 -1302,72 +1328,91 @@@ err
  	return err;
  }
  
++<<<<<<< HEAD
 +void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv,
 +				struct ttc_params *ttc_params)
 +{
 +	ttc_params->any_tt_tirn = priv->direct_tir[0].tirn;
 +	ttc_params->inner_ttc = &priv->fs.inner_ttc;
 +}
 +
 +static void mlx5e_set_inner_ttc_ft_params(struct ttc_params *ttc_params)
++=======
+ static void mlx5e_set_inner_ttc_params(struct mlx5e_priv *priv,
+ 				       struct ttc_params *ttc_params)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
  	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
+ 	int tt;
  
++<<<<<<< HEAD
 +	ft_attr->max_fte = MLX5E_INNER_TTC_TABLE_SIZE;
++=======
+ 	memset(ttc_params, 0, sizeof(*ttc_params));
+ 	ttc_params->ns = mlx5_get_flow_namespace(priv->mdev,
+ 						 MLX5_FLOW_NAMESPACE_KERNEL);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	ft_attr->level = MLX5E_INNER_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_NIC_PRIO;
+ 
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		ttc_params->dests[tt].tir_num =
+ 			tt == MLX5_TT_ANY ?
+ 				mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0) :
+ 				mlx5e_rx_res_get_tirn_rss_inner(priv->rx_res,
+ 								tt);
+ 	}
  }
  
- void mlx5e_set_ttc_ft_params(struct ttc_params *ttc_params)
+ void mlx5e_set_ttc_params(struct mlx5e_priv *priv,
+ 			  struct ttc_params *ttc_params, bool tunnel)
  
  {
  	struct mlx5_flow_table_attr *ft_attr = &ttc_params->ft_attr;
+ 	int tt;
  
++<<<<<<< HEAD
 +	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
++=======
+ 	memset(ttc_params, 0, sizeof(*ttc_params));
+ 	ttc_params->ns = mlx5_get_flow_namespace(priv->mdev,
+ 						 MLX5_FLOW_NAMESPACE_KERNEL);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	ft_attr->level = MLX5E_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_NIC_PRIO;
+ 
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		ttc_params->dests[tt].tir_num =
+ 			tt == MLX5_TT_ANY ?
+ 				mlx5e_rx_res_get_tirn_direct(priv->rx_res, 0) :
+ 				mlx5e_rx_res_get_tirn_rss(priv->rx_res, tt);
+ 	}
+ 
+ 	ttc_params->inner_ttc = tunnel;
+ 	if (!tunnel || !mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		return;
+ 
+ 	for (tt = 0; tt < MLX5_NUM_TUNNEL_TT; tt++) {
+ 		ttc_params->tunnel_dests[tt].type =
+ 			MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		ttc_params->tunnel_dests[tt].ft = priv->fs.inner_ttc.t;
+ 	}
  }
  
- static int mlx5e_create_inner_ttc_table(struct mlx5e_priv *priv, struct ttc_params *params,
- 					struct mlx5e_ttc_table *ttc)
+ static int mlx5_create_inner_ttc_table(struct mlx5_core_dev *dev,
+ 				       struct ttc_params *params,
+ 				       struct mlx5_ttc_table *ttc)
  {
- 	struct mlx5e_flow_table *ft = &ttc->ft;
  	int err;
  
- 	ft->t = mlx5_create_flow_table(priv->fs.ns, &params->ft_attr);
- 	if (IS_ERR(ft->t)) {
- 		err = PTR_ERR(ft->t);
- 		ft->t = NULL;
+ 	WARN_ON_ONCE(params->ft_attr.max_fte);
+ 	params->ft_attr.max_fte = MLX5_INNER_TTC_TABLE_SIZE;
+ 	ttc->t = mlx5_create_flow_table(params->ns, &params->ft_attr);
+ 	if (IS_ERR(ttc->t)) {
+ 		err = PTR_ERR(ttc->t);
+ 		ttc->t = NULL;
  		return err;
  	}
  
@@@ -1389,16 -1439,18 +1484,27 @@@ destroy_ttc
  	return err;
  }
  
++<<<<<<< HEAD
 +int mlx5e_ttc_fwd_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type,
 +		       struct mlx5_flow_destination *new_dest)
++=======
+ int mlx5_ttc_fwd_dest(struct mlx5_ttc_table *ttc, enum mlx5_traffic_types type,
+ 		      struct mlx5_flow_destination *new_dest)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
- 	return mlx5_modify_rule_destination(priv->fs.ttc.rules[type].rule, new_dest, NULL);
+ 	return mlx5_modify_rule_destination(ttc->rules[type].rule, new_dest,
+ 					    NULL);
  }
  
  struct mlx5_flow_destination
++<<<<<<< HEAD
 +mlx5e_ttc_get_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
++=======
+ mlx5_ttc_get_default_dest(struct mlx5_ttc_table *ttc,
+ 			  enum mlx5_traffic_types type)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
- 	struct mlx5_flow_destination *dest = &priv->fs.ttc.rules[type].default_dest;
+ 	struct mlx5_flow_destination *dest = &ttc->rules[type].default_dest;
  
  	WARN_ONCE(dest->type != MLX5_FLOW_DESTINATION_TYPE_TIR,
  		  "TTC[%d] default dest is not setup yet", type);
@@@ -1406,11 -1458,12 +1512,16 @@@
  	return *dest;
  }
  
++<<<<<<< HEAD
 +int mlx5e_ttc_fwd_default_dest(struct mlx5e_priv *priv, enum mlx5e_traffic_types type)
++=======
+ int mlx5_ttc_fwd_default_dest(struct mlx5_ttc_table *ttc,
+ 			      enum mlx5_traffic_types type)
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  {
- 	struct mlx5_flow_destination dest = mlx5e_ttc_get_default_dest(priv, type);
+ 	struct mlx5_flow_destination dest = mlx5_ttc_get_default_dest(ttc, type);
  
- 	return mlx5e_ttc_fwd_dest(priv, type, &dest);
+ 	return mlx5_ttc_fwd_dest(ttc, type, &dest);
  }
  
  static void mlx5e_del_l2_flow_rule(struct mlx5e_priv *priv,
@@@ -1750,26 -1810,20 +1861,39 @@@ int mlx5e_create_flow_steering(struct m
  		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
  	}
  
++<<<<<<< HEAD
 +	mlx5e_set_ttc_basic_params(priv, &ttc_params);
 +
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev)) {
 +		mlx5e_set_inner_ttc_ft_params(&ttc_params);
 +		for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +			ttc_params.indir_tirn[tt] = priv->inner_indir_tir[tt].tirn;
 +
 +		err = mlx5e_create_inner_ttc_table(priv, &ttc_params, &priv->fs.inner_ttc);
++=======
+ 	if (mlx5_tunnel_inner_ft_supported(priv->mdev)) {
+ 		mlx5e_set_inner_ttc_params(priv, &ttc_params);
+ 		err = mlx5_create_inner_ttc_table(priv->mdev, &ttc_params,
+ 						  &priv->fs.inner_ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  		if (err) {
- 			netdev_err(priv->netdev, "Failed to create inner ttc table, err=%d\n",
+ 			netdev_err(priv->netdev,
+ 				   "Failed to create inner ttc table, err=%d\n",
  				   err);
  			goto err_destroy_arfs_tables;
  		}
  	}
  
++<<<<<<< HEAD
 +	mlx5e_set_ttc_ft_params(&ttc_params);
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
 +
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
++=======
+ 	mlx5e_set_ttc_params(priv, &ttc_params, true);
+ 	err = mlx5_create_ttc_table(priv->mdev, &ttc_params, &priv->fs.ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev, "Failed to create ttc table, err=%d\n",
  			   err);
@@@ -1797,10 -1855,12 +1921,15 @@@
  err_destroy_l2_table:
  	mlx5e_destroy_l2_table(priv);
  err_destroy_ttc_table:
- 	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
+ 	mlx5_destroy_ttc_table(&priv->fs.ttc);
  err_destroy_inner_ttc_table:
++<<<<<<< HEAD
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		mlx5e_destroy_inner_ttc_table(priv, &priv->fs.inner_ttc);
++=======
+ 	if (mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		mlx5_destroy_inner_ttc_table(&priv->fs.inner_ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  err_destroy_arfs_tables:
  	mlx5e_arfs_destroy_tables(priv);
  
@@@ -1809,11 -1869,12 +1938,17 @@@
  
  void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv)
  {
 -	mlx5e_ptp_free_rx_fs(priv);
  	mlx5e_destroy_vlan_table(priv);
  	mlx5e_destroy_l2_table(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +	if (mlx5e_tunnel_inner_ft_supported(priv->mdev))
 +		mlx5e_destroy_inner_ttc_table(priv, &priv->fs.inner_ttc);
++=======
+ 	mlx5_destroy_ttc_table(&priv->fs.ttc);
+ 	if (mlx5_tunnel_inner_ft_supported(priv->mdev))
+ 		mlx5_destroy_inner_ttc_table(&priv->fs.inner_ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	mlx5e_arfs_destroy_tables(priv);
  	mlx5e_ethtool_cleanup_steering(priv);
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 98da6dcc9ee9,9817a176916a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -657,17 -654,13 +657,25 @@@ static int mlx5e_create_rep_ttc_table(s
  					      MLX5_FLOW_NAMESPACE_KERNEL);
  
  	/* The inner_ttc in the ttc params is intentionally not set */
++<<<<<<< HEAD
 +	ttc_params.any_tt_tirn = priv->direct_tir[0].tirn;
 +	mlx5e_set_ttc_ft_params(&ttc_params);
++=======
+ 	mlx5e_set_ttc_params(priv, &ttc_params, false);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  
  	if (rep->vport != MLX5_VPORT_UPLINK)
  		/* To give uplik rep TTC a lower level for chaining from root ft */
  		ttc_params.ft_attr.level = MLX5E_TTC_FT_LEVEL + 1;
  
++<<<<<<< HEAD
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
 +
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
++=======
+ 	err = mlx5_create_ttc_table(priv->mdev, &ttc_params, &priv->fs.ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev, "Failed to create rep ttc table, err=%d\n", err);
  		return err;
@@@ -809,17 -794,13 +817,23 @@@ static int mlx5e_init_rep_rx(struct mlx
  err_destroy_root_ft:
  	mlx5e_destroy_rep_root_ft(priv);
  err_destroy_ttc_table:
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +err_destroy_direct_tirs:
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_tirs:
 +	mlx5e_destroy_indirect_tirs(priv);
 +err_destroy_direct_rqts:
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +err_destroy_indirect_rqts:
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5_destroy_ttc_table(&priv->fs.ttc);
+ err_destroy_rx_res:
+ 	mlx5e_rx_res_destroy(priv->rx_res);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
 -	mlx5e_rx_res_free(priv->rx_res);
 -	priv->rx_res = NULL;
  	return err;
  }
  
@@@ -830,12 -809,11 +844,17 @@@ static void mlx5e_cleanup_rep_rx(struc
  	mlx5e_ethtool_cleanup_steering(priv);
  	rep_vport_rx_rule_destroy(priv);
  	mlx5e_destroy_rep_root_ft(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_indirect_tirs(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5_destroy_ttc_table(&priv->fs.ttc);
+ 	mlx5e_rx_res_destroy(priv->rx_res);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	mlx5e_close_drop_rq(&priv->drop_rq);
 -	mlx5e_rx_res_free(priv->rx_res);
 -	priv->rx_res = NULL;
  }
  
  static int mlx5e_init_ul_rep_rx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,afbd0caf31ae..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -346,8 -344,8 +346,13 @@@ struct mlx5e_hairpin 
  
  	int num_channels;
  	struct mlx5e_rqt indir_rqt;
++<<<<<<< HEAD
 +	u32 indir_tirn[MLX5E_NUM_INDIR_TIRS];
 +	struct mlx5e_ttc_table ttc;
++=======
+ 	struct mlx5e_tir indir_tir[MLX5E_NUM_INDIR_TIRS];
+ 	struct mlx5_ttc_table ttc;
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  };
  
  struct mlx5e_hairpin_entry {
@@@ -622,12 -595,16 +627,25 @@@ static void mlx5e_hairpin_set_ttc_param
  
  	memset(ttc_params, 0, sizeof(*ttc_params));
  
++<<<<<<< HEAD
 +	ttc_params->any_tt_tirn = hp->tirn;
 +
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params->indir_tirn[tt] = hp->indir_tirn[tt];
 +
 +	ft_attr->max_fte = MLX5E_TTC_TABLE_SIZE;
++=======
+ 	ttc_params->ns = mlx5_get_flow_namespace(hp->func_mdev,
+ 						 MLX5_FLOW_NAMESPACE_KERNEL);
+ 	for (tt = 0; tt < MLX5_NUM_TT; tt++) {
+ 		ttc_params->dests[tt].type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		ttc_params->dests[tt].tir_num =
+ 			tt == MLX5_TT_ANY ?
+ 				mlx5e_tir_get_tirn(&hp->direct_tir) :
+ 				mlx5e_tir_get_tirn(&hp->indir_tir[tt]);
+ 	}
+ 
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	ft_attr->level = MLX5E_TC_TTC_FT_LEVEL;
  	ft_attr->prio = MLX5E_TC_PRIO;
  }
@@@ -666,11 -643,9 +684,9 @@@ err_create_indirect_tirs
  
  static void mlx5e_hairpin_rss_cleanup(struct mlx5e_hairpin *hp)
  {
- 	struct mlx5e_priv *priv = hp->func_priv;
- 
- 	mlx5e_destroy_ttc_table(priv, &hp->ttc);
+ 	mlx5_destroy_ttc_table(&hp->ttc);
  	mlx5e_hairpin_destroy_indirect_tirs(hp);
 -	mlx5e_rqt_destroy(&hp->indir_rqt);
 +	mlx5e_destroy_rqt(priv, &hp->indir_rqt);
  }
  
  static struct mlx5e_hairpin *
@@@ -912,9 -887,9 +928,9 @@@ static int mlx5e_hairpin_flow_add(struc
  attach_flow:
  	if (hpe->hp->num_channels > 1) {
  		flow_flag_set(flow, HAIRPIN_RSS);
- 		flow->attr->nic_attr->hairpin_ft = hpe->hp->ttc.ft.t;
+ 		flow->attr->nic_attr->hairpin_ft = hpe->hp->ttc.t;
  	} else {
 -		flow->attr->nic_attr->hairpin_tirn = mlx5e_tir_get_tirn(&hpe->hp->direct_tir);
 +		flow->attr->nic_attr->hairpin_tirn = hpe->hp->tirn;
  	}
  
  	flow->hpe = hpe;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index f3988eec3041,e04b758f20e3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -336,12 -330,8 +336,17 @@@ static int mlx5i_create_flow_steering(s
  		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
  	}
  
++<<<<<<< HEAD
 +	mlx5e_set_ttc_basic_params(priv, &ttc_params);
 +	mlx5e_set_ttc_ft_params(&ttc_params);
 +	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
 +		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
 +
 +	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
++=======
+ 	mlx5e_set_ttc_params(priv, &ttc_params, true);
+ 	err = mlx5_create_ttc_table(priv->mdev, &ttc_params, &priv->fs.ttc);
++>>>>>>> bc29764ed9a2 (net/mlx5e: Decouple TTC logic from mlx5e)
  	if (err) {
  		netdev_err(priv->netdev, "Failed to create ttc table, err=%d\n",
  			   err);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
index e51f60b55daa..2380cd90eca9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/fs_tcp.c
@@ -161,7 +161,7 @@ static int accel_fs_tcp_add_default_rule(struct mlx5e_priv *priv,
 	fs_tcp = priv->fs.accel_tcp;
 	accel_fs_t = &fs_tcp->tables[type];
 
-	dest = mlx5e_ttc_get_default_dest(priv, fs_accel2tt(type));
+	dest = mlx5_ttc_get_default_dest(&priv->fs.ttc, fs_accel2tt(type));
 	rule = mlx5_add_flow_rules(accel_fs_t->t, NULL, &flow_act, &dest, 1);
 	if (IS_ERR(rule)) {
 		err = PTR_ERR(rule);
@@ -307,7 +307,7 @@ static int accel_fs_tcp_disable(struct mlx5e_priv *priv)
 
 	for (i = 0; i < ACCEL_FS_TCP_NUM_TYPES; i++) {
 		/* Modify ttc rules destination to point back to the indir TIRs */
-		err = mlx5e_ttc_fwd_default_dest(priv, fs_accel2tt(i));
+		err = mlx5_ttc_fwd_default_dest(&priv->fs.ttc, fs_accel2tt(i));
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@ -329,7 +329,7 @@ static int accel_fs_tcp_enable(struct mlx5e_priv *priv)
 		dest.ft = priv->fs.accel_tcp->tables[i].t;
 
 		/* Modify ttc rules destination to point on the accel_fs FTs */
-		err = mlx5e_ttc_fwd_dest(priv, fs_accel2tt(i), &dest);
+		err = mlx5_ttc_fwd_dest(&priv->fs.ttc, fs_accel2tt(i), &dest);
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] destination to accel failed, err(%d)\n",
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
index 34119ce92031..28181d9d9807 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c
@@ -265,7 +265,7 @@ static int rx_create(struct mlx5e_priv *priv, enum accel_fs_esp_type type)
 	accel_esp = priv->ipsec->rx_fs;
 	fs_prot = &accel_esp->fs_prot[type];
 
-	fs_prot->default_dest = mlx5e_ttc_get_default_dest(priv, fs_esp2tt(type));
+	fs_prot->default_dest = mlx5_ttc_get_default_dest(&priv->fs.ttc, fs_esp2tt(type));
 
 	err = rx_err_create_ft(priv, fs_prot, &fs_prot->rx_err);
 	if (err)
@@ -301,7 +301,7 @@ static int rx_ft_get(struct mlx5e_priv *priv, enum accel_fs_esp_type type)
 	/* connect */
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
 	dest.ft = fs_prot->ft;
-	mlx5e_ttc_fwd_dest(priv, fs_esp2tt(type), &dest);
+	mlx5_ttc_fwd_dest(&priv->fs.ttc, fs_esp2tt(type), &dest);
 
 out:
 	mutex_unlock(&fs_prot->prot_mutex);
@@ -320,7 +320,7 @@ static void rx_ft_put(struct mlx5e_priv *priv, enum accel_fs_esp_type type)
 		goto out;
 
 	/* disconnect */
-	mlx5e_ttc_fwd_default_dest(priv, fs_esp2tt(type));
+	mlx5_ttc_fwd_default_dest(&priv->fs.ttc, fs_esp2tt(type));
 
 	/* remove FT */
 	rx_destroy(priv, type);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 25403af32859..9f183b888d6b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -120,7 +120,7 @@ static int arfs_disable(struct mlx5e_priv *priv)
 
 	for (i = 0; i < ARFS_NUM_TYPES; i++) {
 		/* Modify ttc rules destination back to their default */
-		err = mlx5e_ttc_fwd_default_dest(priv, arfs_get_tt(i));
+		err = mlx5_ttc_fwd_default_dest(&priv->fs.ttc, arfs_get_tt(i));
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] default destination failed, err(%d)\n",
@@ -149,7 +149,7 @@ int mlx5e_arfs_enable(struct mlx5e_priv *priv)
 	for (i = 0; i < ARFS_NUM_TYPES; i++) {
 		dest.ft = priv->fs.arfs->arfs_tables[i].ft.t;
 		/* Modify ttc rules destination to point on the aRFS FTs */
-		err = mlx5e_ttc_fwd_dest(priv, arfs_get_tt(i), &dest);
+		err = mlx5_ttc_fwd_dest(&priv->fs.ttc, arfs_get_tt(i), &dest);
 		if (err) {
 			netdev_err(priv->netdev,
 				   "%s: modify ttc[%d] dest to arfs, failed err(%d)\n",
@@ -206,7 +206,7 @@ static int arfs_add_default_rule(struct mlx5e_priv *priv,
 		return -EINVAL;
 	}
 
-	/* FIXME: Must use mlx5e_ttc_get_default_dest(),
+	/* FIXME: Must use mlx5_ttc_get_default_dest(),
 	 * but can't since TTC default is not setup yet !
 	 */
 	dest.tir_num = tir[tt].tirn;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
