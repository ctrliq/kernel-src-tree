ALSA: memalloc: Minor refactoring

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 723c1252e058dc854f9d031e3e6526ca62f9f5c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/723c1252.failed

Return the pointer directly from alloc ops instead of setting
dmab->area at each place.  It simplifies the code a bit.

	Acked-by: Mark Brown <broonie@kernel.org>
Link: https://lore.kernel.org/r/20210802072815.13551-2-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 723c1252e058dc854f9d031e3e6526ca62f9f5c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/core/memalloc.c
#	sound/core/memalloc_local.h
#	sound/core/sgbuf.c
diff --cc sound/core/memalloc.c
index fb571e6ead5e,1980d1e37bcc..000000000000
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@@ -15,99 -15,27 +15,109 @@@
  #include <asm/set_memory.h>
  #endif
  #include <sound/memalloc.h>
 -#include "memalloc_local.h"
  
 -static const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab);
 +/*
 + *
 + *  Bus-specific memory allocators
 + *
 + */
  
 -/* a cast to gfp flag from the dev pointer; for CONTINUOUS and VMALLOC types */
 -static inline gfp_t snd_mem_get_gfp_flags(const struct snd_dma_buffer *dmab,
 -					  gfp_t default_gfp)
 +#ifdef CONFIG_HAS_DMA
 +/* allocate the coherent DMA pages */
 +static void snd_malloc_dev_pages(struct snd_dma_buffer *dmab, size_t size)
  {
 -	if (!dmab->dev.dev)
 -		return default_gfp;
 -	else
 -		return (__force gfp_t)(unsigned long)dmab->dev.dev;
 +	gfp_t gfp_flags;
 +
 +	gfp_flags = GFP_KERNEL
 +		| __GFP_COMP	/* compound page lets parts be mapped */
 +		| __GFP_NORETRY /* don't trigger OOM-killer */
 +		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
 +	dmab->area = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr,
 +					gfp_flags);
 +#ifdef CONFIG_X86
 +	if (dmab->area && dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
 +		set_memory_wc((unsigned long)dmab->area,
 +			      PAGE_ALIGN(size) >> PAGE_SHIFT);
 +#endif
  }
  
++<<<<<<< HEAD
 +/* free the coherent DMA pages */
 +static void snd_free_dev_pages(struct snd_dma_buffer *dmab)
++=======
+ static void *__snd_dma_alloc_pages(struct snd_dma_buffer *dmab, size_t size)
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  {
 -	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
 +#ifdef CONFIG_X86
 +	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
 +		set_memory_wb((unsigned long)dmab->area,
 +			      PAGE_ALIGN(dmab->bytes) >> PAGE_SHIFT);
 +#endif
 +	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 +}
 +
++<<<<<<< HEAD
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +/**
 + * snd_malloc_dev_iram - allocate memory from on-chip internal ram
 + * @dmab: buffer allocation record to store the allocated data
 + * @size: number of bytes to allocate from the iram
 + *
 + * This function requires iram phandle provided via of_node
 + */
 +static void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
 +{
 +	struct device *dev = dmab->dev.dev;
 +	struct gen_pool *pool = NULL;
 +
 +	dmab->area = NULL;
 +	dmab->addr = 0;
 +
 +	if (dev->of_node)
 +		pool = of_gen_pool_get(dev->of_node, "iram", 0);
  
 +	if (!pool)
 +		return;
 +
 +	/* Assign the pool into private_data field */
 +	dmab->private_data = pool;
 +
 +	dmab->area = gen_pool_dma_alloc_align(pool, size, &dmab->addr,
 +					PAGE_SIZE);
 +}
 +
 +/**
 + * snd_free_dev_iram - free allocated specific memory from on-chip internal ram
 + * @dmab: buffer allocation record to store the allocated data
 + */
 +static void snd_free_dev_iram(struct snd_dma_buffer *dmab)
 +{
 +	struct gen_pool *pool = dmab->private_data;
 +
 +	if (pool && dmab->area)
 +		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
 +}
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +#endif /* CONFIG_HAS_DMA */
 +
 +/*
 + *
 + *  ALSA generic memory management
 + *
 + */
 +
 +static inline gfp_t snd_mem_get_gfp_flags(const struct device *dev,
 +					  gfp_t default_gfp)
 +{
 +	if (!dev)
 +		return default_gfp;
 +	else
 +		return (__force gfp_t)(unsigned long)dev;
++=======
+ 	if (WARN_ON_ONCE(!ops || !ops->alloc))
+ 		return NULL;
+ 	return ops->alloc(dmab, size);
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  }
  
  /**
@@@ -126,8 -54,6 +136,11 @@@
  int snd_dma_alloc_pages(int type, struct device *device, size_t size,
  			struct snd_dma_buffer *dmab)
  {
++<<<<<<< HEAD
 +	gfp_t gfp;
 +
++=======
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  	if (WARN_ON(!size))
  		return -ENXIO;
  	if (WARN_ON(!dmab))
@@@ -137,46 -63,10 +150,50 @@@
  	dmab->dev.type = type;
  	dmab->dev.dev = device;
  	dmab->bytes = 0;
- 	dmab->area = NULL;
  	dmab->addr = 0;
  	dmab->private_data = NULL;
++<<<<<<< HEAD
 +	switch (type) {
 +	case SNDRV_DMA_TYPE_CONTINUOUS:
 +		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL);
 +		dmab->area = alloc_pages_exact(size, gfp);
 +		break;
 +	case SNDRV_DMA_TYPE_VMALLOC:
 +		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL | __GFP_HIGHMEM);
 +		dmab->area = __vmalloc(size, gfp, PAGE_KERNEL);
 +		break;
 +#ifdef CONFIG_HAS_DMA
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +	case SNDRV_DMA_TYPE_DEV_IRAM:
 +		snd_malloc_dev_iram(dmab, size);
 +		if (dmab->area)
 +			break;
 +		/* Internal memory might have limited size and no enough space,
 +		 * so if we fail to malloc, try to fetch memory traditionally.
 +		 */
 +		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +		/* fall through */
 +	case SNDRV_DMA_TYPE_DEV:
 +	case SNDRV_DMA_TYPE_DEV_UC:
 +		snd_malloc_dev_pages(dmab, size);
 +		break;
 +#endif
 +#ifdef CONFIG_SND_DMA_SGBUF
 +	case SNDRV_DMA_TYPE_DEV_SG:
 +	case SNDRV_DMA_TYPE_DEV_UC_SG:
 +		snd_malloc_sgbuf_pages(device, size, dmab, NULL);
 +		break;
 +#endif
 +	default:
 +		pr_err("snd-malloc: invalid device type %d\n", type);
 +		return -ENXIO;
 +	}
 +	if (! dmab->area)
++=======
+ 	dmab->area = __snd_dma_alloc_pages(dmab, size);
+ 	if (!dmab->area)
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  		return -ENOMEM;
  	dmab->bytes = size;
  	return 0;
@@@ -226,32 -115,331 +243,357 @@@ EXPORT_SYMBOL(snd_dma_alloc_pages_fallb
   */
  void snd_dma_free_pages(struct snd_dma_buffer *dmab)
  {
 -	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
 -
 -	if (ops && ops->free)
 -		ops->free(dmab);
 +	switch (dmab->dev.type) {
 +	case SNDRV_DMA_TYPE_CONTINUOUS:
 +		free_pages_exact(dmab->area, dmab->bytes);
 +		break;
 +	case SNDRV_DMA_TYPE_VMALLOC:
 +		vfree(dmab->area);
 +		break;
 +#ifdef CONFIG_HAS_DMA
 +#ifdef CONFIG_GENERIC_ALLOCATOR
 +	case SNDRV_DMA_TYPE_DEV_IRAM:
 +		snd_free_dev_iram(dmab);
 +		break;
 +#endif /* CONFIG_GENERIC_ALLOCATOR */
 +	case SNDRV_DMA_TYPE_DEV:
 +	case SNDRV_DMA_TYPE_DEV_UC:
 +		snd_free_dev_pages(dmab);
 +		break;
 +#endif
 +#ifdef CONFIG_SND_DMA_SGBUF
 +	case SNDRV_DMA_TYPE_DEV_SG:
 +	case SNDRV_DMA_TYPE_DEV_UC_SG:
 +		snd_free_sgbuf_pages(dmab);
 +		break;
 +#endif
 +	default:
 +		pr_err("snd-malloc: invalid device type %d\n", dmab->dev.type);
 +	}
  }
  EXPORT_SYMBOL(snd_dma_free_pages);
++<<<<<<< HEAD
++=======
+ 
+ /* called by devres */
+ static void __snd_release_pages(struct device *dev, void *res)
+ {
+ 	snd_dma_free_pages(res);
+ }
+ 
+ /**
+  * snd_devm_alloc_pages - allocate the buffer and manage with devres
+  * @dev: the device pointer
+  * @type: the DMA buffer type
+  * @size: the buffer size to allocate
+  *
+  * Allocate buffer pages depending on the given type and manage using devres.
+  * The pages will be released automatically at the device removal.
+  *
+  * Unlike snd_dma_alloc_pages(), this function requires the real device pointer,
+  * hence it can't work with SNDRV_DMA_TYPE_CONTINUOUS or
+  * SNDRV_DMA_TYPE_VMALLOC type.
+  *
+  * The function returns the snd_dma_buffer object at success, or NULL if failed.
+  */
+ struct snd_dma_buffer *
+ snd_devm_alloc_pages(struct device *dev, int type, size_t size)
+ {
+ 	struct snd_dma_buffer *dmab;
+ 	int err;
+ 
+ 	if (WARN_ON(type == SNDRV_DMA_TYPE_CONTINUOUS ||
+ 		    type == SNDRV_DMA_TYPE_VMALLOC))
+ 		return NULL;
+ 
+ 	dmab = devres_alloc(__snd_release_pages, sizeof(*dmab), GFP_KERNEL);
+ 	if (!dmab)
+ 		return NULL;
+ 
+ 	err = snd_dma_alloc_pages(type, dev, size, dmab);
+ 	if (err < 0) {
+ 		devres_free(dmab);
+ 		return NULL;
+ 	}
+ 
+ 	devres_add(dev, dmab);
+ 	return dmab;
+ }
+ EXPORT_SYMBOL_GPL(snd_devm_alloc_pages);
+ 
+ /**
+  * snd_dma_buffer_mmap - perform mmap of the given DMA buffer
+  * @dmab: buffer allocation information
+  * @area: VM area information
+  */
+ int snd_dma_buffer_mmap(struct snd_dma_buffer *dmab,
+ 			struct vm_area_struct *area)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->mmap)
+ 		return ops->mmap(dmab, area);
+ 	else
+ 		return -ENOENT;
+ }
+ EXPORT_SYMBOL(snd_dma_buffer_mmap);
+ 
+ /**
+  * snd_sgbuf_get_addr - return the physical address at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ dma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_addr)
+ 		return ops->get_addr(dmab, offset);
+ 	else
+ 		return dmab->addr + offset;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_addr);
+ 
+ /**
+  * snd_sgbuf_get_page - return the physical page at the corresponding offset
+  * @dmab: buffer allocation information
+  * @offset: offset in the ring buffer
+  */
+ struct page *snd_sgbuf_get_page(struct snd_dma_buffer *dmab, size_t offset)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_page)
+ 		return ops->get_page(dmab, offset);
+ 	else
+ 		return virt_to_page(dmab->area + offset);
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_page);
+ 
+ /**
+  * snd_sgbuf_get_chunk_size - compute the max chunk size with continuous pages
+  *	on sg-buffer
+  * @dmab: buffer allocation information
+  * @ofs: offset in the ring buffer
+  * @size: the requested size
+  */
+ unsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,
+ 				      unsigned int ofs, unsigned int size)
+ {
+ 	const struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);
+ 
+ 	if (ops && ops->get_chunk_size)
+ 		return ops->get_chunk_size(dmab, ofs, size);
+ 	else
+ 		return size;
+ }
+ EXPORT_SYMBOL(snd_sgbuf_get_chunk_size);
+ 
+ /*
+  * Continuous pages allocator
+  */
+ static void *snd_dma_continuous_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL);
+ 
+ 	return alloc_pages_exact(size, gfp);
+ }
+ 
+ static void snd_dma_continuous_free(struct snd_dma_buffer *dmab)
+ {
+ 	free_pages_exact(dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_continuous_mmap(struct snd_dma_buffer *dmab,
+ 				   struct vm_area_struct *area)
+ {
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       page_to_pfn(virt_to_page(dmab->area)),
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_continuous_ops = {
+ 	.alloc = snd_dma_continuous_alloc,
+ 	.free = snd_dma_continuous_free,
+ 	.mmap = snd_dma_continuous_mmap,
+ };
+ 
+ /*
+  * VMALLOC allocator
+  */
+ static void *snd_dma_vmalloc_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp = snd_mem_get_gfp_flags(dmab, GFP_KERNEL | __GFP_HIGHMEM);
+ 
+ 	return __vmalloc(size, gfp);
+ }
+ 
+ static void snd_dma_vmalloc_free(struct snd_dma_buffer *dmab)
+ {
+ 	vfree(dmab->area);
+ }
+ 
+ static int snd_dma_vmalloc_mmap(struct snd_dma_buffer *dmab,
+ 				struct vm_area_struct *area)
+ {
+ 	return remap_vmalloc_range(area, dmab->area, 0);
+ }
+ 
+ static dma_addr_t snd_dma_vmalloc_get_addr(struct snd_dma_buffer *dmab,
+ 					   size_t offset)
+ {
+ 	return page_to_phys(vmalloc_to_page(dmab->area + offset)) +
+ 		offset % PAGE_SIZE;
+ }
+ 
+ static struct page *snd_dma_vmalloc_get_page(struct snd_dma_buffer *dmab,
+ 					     size_t offset)
+ {
+ 	return vmalloc_to_page(dmab->area + offset);
+ }
+ 
+ static unsigned int
+ snd_dma_vmalloc_get_chunk_size(struct snd_dma_buffer *dmab,
+ 			       unsigned int ofs, unsigned int size)
+ {
+ 	ofs %= PAGE_SIZE;
+ 	size += ofs;
+ 	if (size > PAGE_SIZE)
+ 		size = PAGE_SIZE;
+ 	return size - ofs;
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_vmalloc_ops = {
+ 	.alloc = snd_dma_vmalloc_alloc,
+ 	.free = snd_dma_vmalloc_free,
+ 	.mmap = snd_dma_vmalloc_mmap,
+ 	.get_addr = snd_dma_vmalloc_get_addr,
+ 	.get_page = snd_dma_vmalloc_get_page,
+ 	.get_chunk_size = snd_dma_vmalloc_get_chunk_size,
+ };
+ 
+ #ifdef CONFIG_HAS_DMA
+ /*
+  * IRAM allocator
+  */
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ static void *snd_dma_iram_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	struct device *dev = dmab->dev.dev;
+ 	struct gen_pool *pool;
+ 	void *p;
+ 
+ 	if (dev->of_node) {
+ 		pool = of_gen_pool_get(dev->of_node, "iram", 0);
+ 		/* Assign the pool into private_data field */
+ 		dmab->private_data = pool;
+ 
+ 		p = gen_pool_dma_alloc_align(pool, size, &dmab->addr, PAGE_SIZE);
+ 		if (p)
+ 			return p;
+ 	}
+ 
+ 	/* Internal memory might have limited size and no enough space,
+ 	 * so if we fail to malloc, try to fetch memory traditionally.
+ 	 */
+ 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+ 	return __snd_dma_alloc_pages(dmab, size);
+ }
+ 
+ static void snd_dma_iram_free(struct snd_dma_buffer *dmab)
+ {
+ 	struct gen_pool *pool = dmab->private_data;
+ 
+ 	if (pool && dmab->area)
+ 		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
+ }
+ 
+ static int snd_dma_iram_mmap(struct snd_dma_buffer *dmab,
+ 			     struct vm_area_struct *area)
+ {
+ 	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+ 	return remap_pfn_range(area, area->vm_start,
+ 			       dmab->addr >> PAGE_SHIFT,
+ 			       area->vm_end - area->vm_start,
+ 			       area->vm_page_prot);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_iram_ops = {
+ 	.alloc = snd_dma_iram_alloc,
+ 	.free = snd_dma_iram_free,
+ 	.mmap = snd_dma_iram_mmap,
+ };
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ 
+ /*
+  * Coherent device pages allocator
+  */
+ static void *snd_dma_dev_alloc(struct snd_dma_buffer *dmab, size_t size)
+ {
+ 	gfp_t gfp_flags;
+ 	void *p;
+ 
+ 	gfp_flags = GFP_KERNEL
+ 		| __GFP_COMP	/* compound page lets parts be mapped */
+ 		| __GFP_NORETRY /* don't trigger OOM-killer */
+ 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
+ 	p = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr, gfp_flags);
+ #ifdef CONFIG_X86
+ 	if (p && dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
+ 		set_memory_wc((unsigned long)p, PAGE_ALIGN(size) >> PAGE_SHIFT);
+ #endif
+ 	return p;
+ }
+ 
+ static void snd_dma_dev_free(struct snd_dma_buffer *dmab)
+ {
+ #ifdef CONFIG_X86
+ 	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
+ 		set_memory_wb((unsigned long)dmab->area,
+ 			      PAGE_ALIGN(dmab->bytes) >> PAGE_SHIFT);
+ #endif
+ 	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+ }
+ 
+ static int snd_dma_dev_mmap(struct snd_dma_buffer *dmab,
+ 			    struct vm_area_struct *area)
+ {
+ 	return dma_mmap_coherent(dmab->dev.dev, area,
+ 				 dmab->area, dmab->addr, dmab->bytes);
+ }
+ 
+ static const struct snd_malloc_ops snd_dma_dev_ops = {
+ 	.alloc = snd_dma_dev_alloc,
+ 	.free = snd_dma_dev_free,
+ 	.mmap = snd_dma_dev_mmap,
+ };
+ #endif /* CONFIG_HAS_DMA */
+ 
+ /*
+  * Entry points
+  */
+ static const struct snd_malloc_ops *dma_ops[] = {
+ 	[SNDRV_DMA_TYPE_CONTINUOUS] = &snd_dma_continuous_ops,
+ 	[SNDRV_DMA_TYPE_VMALLOC] = &snd_dma_vmalloc_ops,
+ #ifdef CONFIG_HAS_DMA
+ 	[SNDRV_DMA_TYPE_DEV] = &snd_dma_dev_ops,
+ 	[SNDRV_DMA_TYPE_DEV_UC] = &snd_dma_dev_ops,
+ #ifdef CONFIG_GENERIC_ALLOCATOR
+ 	[SNDRV_DMA_TYPE_DEV_IRAM] = &snd_dma_iram_ops,
+ #endif /* CONFIG_GENERIC_ALLOCATOR */
+ #endif /* CONFIG_HAS_DMA */
+ #ifdef CONFIG_SND_DMA_SGBUF
+ 	[SNDRV_DMA_TYPE_DEV_SG] = &snd_dma_sg_ops,
+ 	[SNDRV_DMA_TYPE_DEV_UC_SG] = &snd_dma_sg_ops,
+ #endif
+ };
+ 
+ static const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab)
+ {
+ 	if (WARN_ON_ONCE(dmab->dev.type <= SNDRV_DMA_TYPE_UNKNOWN ||
+ 			 dmab->dev.type >= ARRAY_SIZE(dma_ops)))
+ 		return NULL;
+ 	return dma_ops[dmab->dev.type];
+ }
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
diff --cc sound/core/sgbuf.c
index dbb612239270,a46129f3de12..000000000000
--- a/sound/core/sgbuf.c
+++ b/sound/core/sgbuf.c
@@@ -52,9 -63,7 +52,13 @@@ int snd_free_sgbuf_pages(struct snd_dma
  
  #define MAX_ALLOC_PAGES		32
  
++<<<<<<< HEAD
 +void *snd_malloc_sgbuf_pages(struct device *device,
 +			     size_t size, struct snd_dma_buffer *dmab,
 +			     size_t *res_size)
++=======
+ static void *snd_dma_sg_alloc(struct snd_dma_buffer *dmab, size_t size)
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  {
  	struct snd_sg_buf *sgbuf;
  	unsigned int i, pages, chunk, maxpages;
@@@ -63,11 -72,10 +67,16 @@@
  	struct page **pgtable;
  	int type = SNDRV_DMA_TYPE_DEV;
  	pgprot_t prot = PAGE_KERNEL;
+ 	void *area;
  
 +	dmab->area = NULL;
 +	dmab->addr = 0;
  	dmab->private_data = sgbuf = kzalloc(sizeof(*sgbuf), GFP_KERNEL);
++<<<<<<< HEAD
 +	if (! sgbuf)
++=======
+ 	if (!sgbuf)
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  		return NULL;
  	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC_SG) {
  		type = SNDRV_DMA_TYPE_DEV_UC;
@@@ -122,15 -128,13 +131,22 @@@
  	}
  
  	sgbuf->size = size;
- 	dmab->area = vmap(sgbuf->page_table, sgbuf->pages, VM_MAP, prot);
- 	if (! dmab->area)
+ 	area = vmap(sgbuf->page_table, sgbuf->pages, VM_MAP, prot);
+ 	if (!area)
  		goto _failed;
++<<<<<<< HEAD
 +	if (res_size)
 +		*res_size = sgbuf->size;
 +	return dmab->area;
 +
 + _failed:
 +	snd_free_sgbuf_pages(dmab); /* free the table */
++=======
+ 	return area;
+ 
+  _failed:
+ 	snd_dma_sg_free(dmab); /* free the table */
++>>>>>>> 723c1252e058 (ALSA: memalloc: Minor refactoring)
  	return NULL;
  }
  
* Unmerged path sound/core/memalloc_local.h
* Unmerged path sound/core/memalloc.c
* Unmerged path sound/core/memalloc_local.h
* Unmerged path sound/core/sgbuf.c
