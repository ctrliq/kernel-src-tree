scsi: mpi3mr: Fix cmnd getting marked as in use forever

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit b3911ab3a76e216cd97c6fdc05132e57c3e6941c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/b3911ab3.failed

When a driver command which requires the driver to issue a follow up
command using the same command frame is outstanding and a soft reset
operation occurs, then that driver command frame is getting marked as in
use permanently and won't be reused again.

Clear the driver command frames while flushing out the outstanding commands
and avoid issuing any new requests using these command frames while soft
reset is going on.

Link: https://lore.kernel.org/r/20220210095817.22828-6-sreekanth.reddy@broadcom.com
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b3911ab3a76e216cd97c6fdc05132e57c3e6941c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr_os.c
diff --cc drivers/scsi/mpi3mr/mpi3mr_os.c
index d2fad5e62b25,fa4785029e9c..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@@ -1692,6 -1788,145 +1700,148 @@@ out_failed
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mpi3mr_complete_evt_ack - event ack request completion
+  * @mrioc: Adapter instance reference
+  * @drv_cmd: Internal command tracker
+  *
+  * This is the completion handler for non blocking event
+  * acknowledgment sent to the firmware and this will issue any
+  * pending event acknowledgment request.
+  *
+  * Return: Nothing
+  */
+ static void mpi3mr_complete_evt_ack(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd)
+ {
+ 	u16 cmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_EVTACKCMD_MIN;
+ 	struct delayed_evt_ack_node *delayed_evtack = NULL;
+ 
+ 	if (drv_cmd->state & MPI3MR_CMD_RESET)
+ 		goto clear_drv_cmd;
+ 
+ 	if (drv_cmd->ioc_status != MPI3_IOCSTATUS_SUCCESS) {
+ 		dprint_event_th(mrioc,
+ 		    "immediate event ack failed with ioc_status(0x%04x) log_info(0x%08x)\n",
+ 		    (drv_cmd->ioc_status & MPI3_IOCSTATUS_STATUS_MASK),
+ 		    drv_cmd->ioc_loginfo);
+ 	}
+ 
+ 	if (!list_empty(&mrioc->delayed_evtack_cmds_list)) {
+ 		delayed_evtack =
+ 			list_entry(mrioc->delayed_evtack_cmds_list.next,
+ 			    struct delayed_evt_ack_node, list);
+ 		mpi3mr_send_event_ack(mrioc, delayed_evtack->event, drv_cmd,
+ 		    delayed_evtack->event_ctx);
+ 		list_del(&delayed_evtack->list);
+ 		kfree(delayed_evtack);
+ 		return;
+ 	}
+ clear_drv_cmd:
+ 	drv_cmd->state = MPI3MR_CMD_NOTUSED;
+ 	drv_cmd->callback = NULL;
+ 	clear_bit(cmd_idx, mrioc->evtack_cmds_bitmap);
+ }
+ 
+ /**
+  * mpi3mr_send_event_ack - Issue event acknwoledgment request
+  * @mrioc: Adapter instance reference
+  * @event: MPI3 event id
+  * @cmdparam: Internal command tracker
+  * @event_ctx: event context
+  *
+  * Issues event acknowledgment request to the firmware if there
+  * is a free command to send the event ack else it to a pend
+  * list so that it will be processed on a completion of a prior
+  * event acknowledgment .
+  *
+  * Return: Nothing
+  */
+ static void mpi3mr_send_event_ack(struct mpi3mr_ioc *mrioc, u8 event,
+ 	struct mpi3mr_drv_cmd *cmdparam, u32 event_ctx)
+ {
+ 	struct mpi3_event_ack_request evtack_req;
+ 	int retval = 0;
+ 	u8 retrycount = 5;
+ 	u16 cmd_idx = MPI3MR_NUM_EVTACKCMD;
+ 	struct mpi3mr_drv_cmd *drv_cmd = cmdparam;
+ 	struct delayed_evt_ack_node *delayed_evtack = NULL;
+ 
+ 	if (drv_cmd) {
+ 		dprint_event_th(mrioc,
+ 		    "sending delayed event ack in the top half for event(0x%02x), event_ctx(0x%08x)\n",
+ 		    event, event_ctx);
+ 		goto issue_cmd;
+ 	}
+ 	dprint_event_th(mrioc,
+ 	    "sending event ack in the top half for event(0x%02x), event_ctx(0x%08x)\n",
+ 	    event, event_ctx);
+ 	do {
+ 		cmd_idx = find_first_zero_bit(mrioc->evtack_cmds_bitmap,
+ 		    MPI3MR_NUM_EVTACKCMD);
+ 		if (cmd_idx < MPI3MR_NUM_EVTACKCMD) {
+ 			if (!test_and_set_bit(cmd_idx,
+ 			    mrioc->evtack_cmds_bitmap))
+ 				break;
+ 			cmd_idx = MPI3MR_NUM_EVTACKCMD;
+ 		}
+ 	} while (retrycount--);
+ 
+ 	if (cmd_idx >= MPI3MR_NUM_EVTACKCMD) {
+ 		delayed_evtack = kzalloc(sizeof(*delayed_evtack),
+ 		    GFP_ATOMIC);
+ 		if (!delayed_evtack)
+ 			return;
+ 		INIT_LIST_HEAD(&delayed_evtack->list);
+ 		delayed_evtack->event = event;
+ 		delayed_evtack->event_ctx = event_ctx;
+ 		list_add_tail(&delayed_evtack->list,
+ 		    &mrioc->delayed_evtack_cmds_list);
+ 		dprint_event_th(mrioc,
+ 		    "event ack in the top half for event(0x%02x), event_ctx(0x%08x) is postponed\n",
+ 		    event, event_ctx);
+ 		return;
+ 	}
+ 	drv_cmd = &mrioc->evtack_cmds[cmd_idx];
+ 
+ issue_cmd:
+ 	cmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_EVTACKCMD_MIN;
+ 
+ 	memset(&evtack_req, 0, sizeof(evtack_req));
+ 	if (drv_cmd->state & MPI3MR_CMD_PENDING) {
+ 		dprint_event_th(mrioc,
+ 		    "sending event ack failed due to command in use\n");
+ 		goto out;
+ 	}
+ 	drv_cmd->state = MPI3MR_CMD_PENDING;
+ 	drv_cmd->is_waiting = 0;
+ 	drv_cmd->callback = mpi3mr_complete_evt_ack;
+ 	evtack_req.host_tag = cpu_to_le16(drv_cmd->host_tag);
+ 	evtack_req.function = MPI3_FUNCTION_EVENT_ACK;
+ 	evtack_req.event = event;
+ 	evtack_req.event_context = cpu_to_le32(event_ctx);
+ 	retval = mpi3mr_admin_request_post(mrioc, &evtack_req,
+ 	    sizeof(evtack_req), 1);
+ 	if (retval) {
+ 		dprint_event_th(mrioc,
+ 		    "posting event ack request is failed\n");
+ 		goto out_failed;
+ 	}
+ 
+ 	dprint_event_th(mrioc,
+ 	    "event ack in the top half for event(0x%02x), event_ctx(0x%08x) is posted\n",
+ 	    event, event_ctx);
+ out:
+ 	return;
+ out_failed:
+ 	drv_cmd->state = MPI3MR_CMD_NOTUSED;
+ 	drv_cmd->callback = NULL;
+ 	clear_bit(cmd_idx, mrioc->evtack_cmds_bitmap);
+ }
+ 
+ /**
++>>>>>>> b3911ab3a76e (scsi: mpi3mr: Fix cmnd getting marked as in use forever)
   * mpi3mr_pcietopochg_evt_th - PCIETopologyChange evt tophalf
   * @mrioc: Adapter instance reference
   * @event_reply: event data
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_os.c
