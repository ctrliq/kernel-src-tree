lib/iov_iter: initialize "flags" in new pipe_buffer

jira LE-1907
cve CVE-2022-0847
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Max Kellermann <max.kellermann@ionos.com>
commit 9d2231c5d74e13b2a0546fee6737ee4446017903
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/9d2231c5.failed

The functions copy_page_to_iter_pipe() and push_pipe() can both
allocate a new pipe_buffer, but the "flags" member initializer is
missing.

Fixes: 241699cd72a8 ("new iov_iter flavour: pipe-backed")
To: Alexander Viro <viro@zeniv.linux.org.uk>
To: linux-fsdevel@vger.kernel.org
To: linux-kernel@vger.kernel.org
	Cc: stable@vger.kernel.org
	Signed-off-by: Max Kellermann <max.kellermann@ionos.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 9d2231c5d74e13b2a0546fee6737ee4446017903)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/iov_iter.c
diff --cc lib/iov_iter.c
index 9dc104aa8867,6dd5330f7a99..000000000000
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@@ -391,18 -407,22 +391,24 @@@ static size_t copy_page_to_iter_pipe(st
  			i->iov_offset += bytes;
  			goto out;
  		}
 -		i_head++;
 -		buf = &pipe->bufs[i_head & p_mask];
 +		idx = next_idx(idx, pipe);
 +		buf = &pipe->bufs[idx];
  	}
 -	if (pipe_full(i_head, p_tail, pipe->max_usage))
 +	if (idx == pipe->curbuf && pipe->nrbufs)
  		return 0;
 -
 +	pipe->nrbufs++;
  	buf->ops = &page_cache_pipe_buf_ops;
++<<<<<<< HEAD
 +	get_page(buf->page = page);
++=======
+ 	buf->flags = 0;
+ 	get_page(page);
+ 	buf->page = page;
++>>>>>>> 9d2231c5d74e (lib/iov_iter: initialize "flags" in new pipe_buffer)
  	buf->offset = offset;
  	buf->len = bytes;
 -
 -	pipe->head = i_head + 1;
  	i->iov_offset = offset + bytes;
 -	i->head = i_head;
 +	i->idx = idx;
  out:
  	i->count -= bytes;
  	return bytes;
@@@ -501,17 -576,18 +507,31 @@@ static size_t push_pipe(struct iov_ite
  		struct page *page = alloc_page(GFP_USER);
  		if (!page)
  			break;
++<<<<<<< HEAD
 +		pipe->nrbufs++;
 +		pipe->bufs[idx].ops = &default_pipe_buf_ops;
 +		pipe->bufs[idx].page = page;
 +		pipe->bufs[idx].offset = 0;
 +		if (left <= PAGE_SIZE) {
 +			pipe->bufs[idx].len = left;
++=======
+ 
+ 		buf->ops = &default_pipe_buf_ops;
+ 		buf->flags = 0;
+ 		buf->page = page;
+ 		buf->offset = 0;
+ 		buf->len = min_t(ssize_t, left, PAGE_SIZE);
+ 		left -= buf->len;
+ 		iter_head++;
+ 		pipe->head = iter_head;
+ 
+ 		if (left == 0)
++>>>>>>> 9d2231c5d74e (lib/iov_iter: initialize "flags" in new pipe_buffer)
  			return size;
 +		}
 +		pipe->bufs[idx].len = PAGE_SIZE;
 +		left -= PAGE_SIZE;
 +		idx = next_idx(idx, pipe);
  	}
  	return size - left;
  }
* Unmerged path lib/iov_iter.c
