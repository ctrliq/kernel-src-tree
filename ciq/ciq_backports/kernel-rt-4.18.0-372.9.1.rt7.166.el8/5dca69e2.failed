software node: Handle software node injection to an existing device properly

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 5dca69e26fe97f17d4a6cbd6872103c868577b14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/5dca69e2.failed

The function software_node_notify() - the function that creates
and removes the symlinks between the node and the device - was
called unconditionally in device_add_software_node() and
device_remove_software_node(), but it needs to be called in
those functions only in the special case where the node is
added to a device that has already been registered.

This fixes NULL pointer dereference that happens if
device_remove_software_node() is used with device that was
never registered.

Fixes: b622b24519f5 ("software node: Allow node addition to already existing device")
Reported-and-tested-by: Dominik Brodowski <linux@dominikbrodowski.net>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5dca69e26fe97f17d4a6cbd6872103c868577b14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/swnode.c
diff --cc drivers/base/swnode.c
index a113c24c8871,d1f1a8240120..000000000000
--- a/drivers/base/swnode.c
+++ b/drivers/base/swnode.c
@@@ -990,6 -1016,71 +990,74 @@@ void fwnode_remove_software_node(struc
  EXPORT_SYMBOL_GPL(fwnode_remove_software_node);
  
  /**
++<<<<<<< HEAD
++=======
+  * device_add_software_node - Assign software node to a device
+  * @dev: The device the software node is meant for.
+  * @node: The software node.
+  *
+  * This function will make @node the secondary firmware node pointer of @dev. If
+  * @dev has no primary node, then @node will become the primary node. The
+  * function will register @node automatically if it wasn't already registered.
+  */
+ int device_add_software_node(struct device *dev, const struct software_node *node)
+ {
+ 	struct swnode *swnode;
+ 	int ret;
+ 
+ 	/* Only one software node per device. */
+ 	if (dev_to_swnode(dev))
+ 		return -EBUSY;
+ 
+ 	swnode = software_node_to_swnode(node);
+ 	if (swnode) {
+ 		kobject_get(&swnode->kobj);
+ 	} else {
+ 		ret = software_node_register(node);
+ 		if (ret)
+ 			return ret;
+ 
+ 		swnode = software_node_to_swnode(node);
+ 	}
+ 
+ 	set_secondary_fwnode(dev, &swnode->fwnode);
+ 
+ 	/*
+ 	 * If the device has been fully registered by the time this function is
+ 	 * called, software_node_notify() must be called separately so that the
+ 	 * symlinks get created and the reference count of the node is kept in
+ 	 * balance.
+ 	 */
+ 	if (device_is_registered(dev))
+ 		software_node_notify(dev, KOBJ_ADD);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(device_add_software_node);
+ 
+ /**
+  * device_remove_software_node - Remove device's software node
+  * @dev: The device with the software node.
+  *
+  * This function will unregister the software node of @dev.
+  */
+ void device_remove_software_node(struct device *dev)
+ {
+ 	struct swnode *swnode;
+ 
+ 	swnode = dev_to_swnode(dev);
+ 	if (!swnode)
+ 		return;
+ 
+ 	if (device_is_registered(dev))
+ 		software_node_notify(dev, KOBJ_REMOVE);
+ 	set_secondary_fwnode(dev, NULL);
+ 	kobject_put(&swnode->kobj);
+ }
+ EXPORT_SYMBOL_GPL(device_remove_software_node);
+ 
+ /**
++>>>>>>> 5dca69e26fe9 (software node: Handle software node injection to an existing device properly)
   * device_create_managed_software_node - Create a software node for a device
   * @dev: The device the software node is assigned to.
   * @properties: Device properties for the software node.
@@@ -1032,20 -1122,13 +1100,24 @@@ int software_node_notify(struct device 
  	struct swnode *swnode;
  	int ret;
  
 -	swnode = dev_to_swnode(dev);
 -	if (!swnode)
 +	if (!fwnode)
 +		return 0;
 +
 +	if (!is_software_node(fwnode))
 +		fwnode = fwnode->secondary;
 +	if (!is_software_node(fwnode))
  		return 0;
  
 +	swnode = to_swnode(fwnode);
 +
  	switch (action) {
  	case KOBJ_ADD:
++<<<<<<< HEAD
 +		ret = sysfs_create_link(&dev->kobj, &swnode->kobj,
 +					"software_node");
++=======
+ 		ret = sysfs_create_link(&dev->kobj, &swnode->kobj, "software_node");
++>>>>>>> 5dca69e26fe9 (software node: Handle software node injection to an existing device properly)
  		if (ret)
  			break;
  
* Unmerged path drivers/base/swnode.c
