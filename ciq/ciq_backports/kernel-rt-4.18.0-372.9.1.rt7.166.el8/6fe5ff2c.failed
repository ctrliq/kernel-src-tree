net/mlx5e: Create struct mlx5e_rss_params_hash

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Maxim Mikityanskiy <maximmi@nvidia.com>
commit 6fe5ff2c77805f1a3a4abf226087bf9ce1299371
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/6fe5ff2c.failed

This commit introduces a new struct to store RSS hash parameters: hash
function and hash key. The existing usages are changed to use the new
struct.

	Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 6fe5ff2c77805f1a3a4abf226087bf9ce1299371)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,4167f4e4211e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -1192,7 -1172,7 +1192,11 @@@ static int mlx5e_set_link_ksettings(str
  
  u32 mlx5e_ethtool_get_rxfh_key_size(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	return sizeof(priv->rss_params.toeplitz_hash_key);
++=======
+ 	return sizeof(priv->rx_res->rss_params.hash.toeplitz_hash_key);
++>>>>>>> 6fe5ff2c7780 (net/mlx5e: Create struct mlx5e_rss_params_hash)
  }
  
  static u32 mlx5e_get_rxfh_key_size(struct net_device *netdev)
@@@ -1218,18 -1198,18 +1222,17 @@@ int mlx5e_get_rxfh(struct net_device *n
  		   u8 *hfunc)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rss_params *rss;
 -
 -	rss = &priv->rx_res->rss_params;
 +	struct mlx5e_rss_params *rss = &priv->rss_params;
  
  	if (indir)
 -		memcpy(indir, rss->indir.table, sizeof(rss->indir.table));
 +		memcpy(indir, rss->indirection_rqt,
 +		       sizeof(rss->indirection_rqt));
  
  	if (key)
- 		memcpy(key, rss->toeplitz_hash_key,
- 		       sizeof(rss->toeplitz_hash_key));
+ 		memcpy(key, rss->hash.toeplitz_hash_key, sizeof(rss->hash.toeplitz_hash_key));
  
  	if (hfunc)
- 		*hfunc = rss->hfunc;
+ 		*hfunc = rss->hash.hfunc;
  
  	return 0;
  }
@@@ -1255,8 -1235,10 +1258,15 @@@ int mlx5e_set_rxfh(struct net_device *d
  
  	mutex_lock(&priv->state_lock);
  
++<<<<<<< HEAD
 +	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hfunc) {
 +		rss->hfunc = hfunc;
++=======
+ 	rss = &priv->rx_res->rss_params;
+ 
+ 	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hash.hfunc) {
+ 		rss->hash.hfunc = hfunc;
++>>>>>>> 6fe5ff2c7780 (net/mlx5e: Create struct mlx5e_rss_params_hash)
  		refresh_rqt = true;
  		refresh_tirs = true;
  	}
@@@ -1274,18 -1254,20 +1283,33 @@@
  	}
  
  	if (refresh_rqt && test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 -		u32 *rqns;
 -
 +		struct mlx5e_redirect_rqt_param rrp = {
 +			.is_rss = true,
 +			{
 +				.rss = {
 +					.hfunc = rss->hfunc,
 +					.channels  = &priv->channels,
 +				},
 +			},
 +		};
 +		u32 rqtn = priv->indir_rqt.rqtn;
 +
++<<<<<<< HEAD
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
++=======
+ 		rqns = kvmalloc_array(priv->channels.num, sizeof(*rqns), GFP_KERNEL);
+ 		if (rqns) {
+ 			unsigned int ix;
+ 
+ 			for (ix = 0; ix < priv->channels.num; ix++)
+ 				rqns[ix] = priv->channels.c[ix]->rq.rqn;
+ 
+ 			mlx5e_rqt_redirect_indir(&priv->rx_res->indir_rqt, rqns,
+ 						 priv->channels.num,
+ 						 rss->hash.hfunc, &rss->indir);
+ 			kvfree(rqns);
+ 		}
++>>>>>>> 6fe5ff2c7780 (net/mlx5e: Create struct mlx5e_rss_params_hash)
  	}
  
  	if (refresh_tirs)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 15e30d82e985,10e6bebe8c74..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2249,102 -2227,67 +2249,109 @@@ err_destroy_rqts
  	return err;
  }
  
 -static int mlx5e_create_xsk_rqts(struct mlx5e_priv *priv)
 +void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv, struct mlx5e_tir *tirs, int n)
  {
 -	int err;
 -	int ix;
 +	int i;
  
 -	for (ix = 0; ix < priv->max_nch; ix++) {
 -		err = mlx5e_rqt_init_direct(&priv->rx_res->channels[ix].xsk_rqt,
 -					    priv->mdev, false, priv->drop_rq.rqn);
 -		if (unlikely(err))
 -			goto err_destroy_rqts;
 -	}
 +	for (i = 0; i < n; i++)
 +		mlx5e_destroy_rqt(priv, &tirs[i].rqt);
 +}
  
 -	return 0;
 +static int mlx5e_rx_hash_fn(int hfunc)
 +{
 +	return (hfunc == ETH_RSS_HASH_TOP) ?
 +	       MLX5_RX_HASH_FN_TOEPLITZ :
 +	       MLX5_RX_HASH_FN_INVERTED_XOR8;
 +}
  
 -err_destroy_rqts:
 -	mlx5_core_warn(priv->mdev, "create xsk rqts failed, %d\n", err);
 -	while (--ix >= 0)
 -		mlx5e_rqt_destroy(&priv->rx_res->channels[ix].xsk_rqt);
 +int mlx5e_bits_invert(unsigned long a, int size)
 +{
 +	int inv = 0;
 +	int i;
  
 -	return err;
 +	for (i = 0; i < size; i++)
 +		inv |= (test_bit(size - i - 1, &a) ? 1 : 0) << i;
 +
++<<<<<<< HEAD
 +	return inv;
  }
  
 -void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv)
 +static void mlx5e_fill_rqt_rqns(struct mlx5e_priv *priv, int sz,
 +				struct mlx5e_redirect_rqt_param rrp, void *rqtc)
  {
 -	unsigned int ix;
 +	int i;
 +
 +	for (i = 0; i < sz; i++) {
 +		u32 rqn;
 +
 +		if (rrp.is_rss) {
 +			int ix = i;
 +
 +			if (rrp.rss.hfunc == ETH_RSS_HASH_XOR)
 +				ix = mlx5e_bits_invert(i, ilog2(sz));
  
 -	for (ix = 0; ix < priv->max_nch; ix++)
 -		mlx5e_rqt_destroy(&priv->rx_res->channels[ix].direct_rqt);
 +			ix = priv->rss_params.indirection_rqt[ix];
 +			rqn = rrp.rss.channels->c[ix]->rq.rqn;
 +		} else {
 +			rqn = rrp.rqn;
 +		}
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
  }
  
 -static void mlx5e_destroy_xsk_rqts(struct mlx5e_priv *priv)
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp)
  {
 -	unsigned int ix;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	int inlen;
 +	u32 *in;
 +	int err;
 +
 +	inlen = MLX5_ST_SZ_BYTES(modify_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(modify_rqt_in, in, ctx);
  
 -	for (ix = 0; ix < priv->max_nch; ix++)
 -		mlx5e_rqt_destroy(&priv->rx_res->channels[ix].xsk_rqt);
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(modify_rqt_in, in, bitmask.rqn_list, 1);
 +	mlx5e_fill_rqt_rqns(priv, sz, rrp, rqtc);
 +	err = mlx5_core_modify_rqt(mdev, rqtn, in, inlen);
 +
 +	kvfree(in);
 +	return err;
  }
  
 -static int mlx5e_rx_hash_fn(int hfunc)
 +static u32 mlx5e_get_direct_rqn(struct mlx5e_priv *priv, int ix,
 +				struct mlx5e_redirect_rqt_param rrp)
  {
 -	return (hfunc == ETH_RSS_HASH_TOP) ?
 -	       MLX5_RX_HASH_FN_TOEPLITZ :
 -	       MLX5_RX_HASH_FN_INVERTED_XOR8;
 +	if (!rrp.is_rss)
 +		return rrp.rqn;
 +
 +	if (ix >= rrp.rss.channels->num)
 +		return priv->drop_rq.rqn;
 +
 +	return rrp.rss.channels->c[ix]->rq.rqn;
  }
  
 -static void mlx5e_redirect_rqts_to_channels(struct mlx5e_priv *priv,
 -					    struct mlx5e_channels *chs)
 +static void mlx5e_redirect_rqts(struct mlx5e_priv *priv,
 +				struct mlx5e_redirect_rqt_param rrp)
  {
 -	struct mlx5e_rx_res *res = priv->rx_res;
 -	unsigned int ix;
 -	u32 *rqns;
 -
 -	rqns = kvmalloc_array(chs->num, sizeof(*rqns), GFP_KERNEL);
 -	if (rqns) {
 -		for (ix = 0; ix < chs->num; ix++)
 -			rqns[ix] = chs->c[ix]->rq.rqn;
 +	u32 rqtn;
 +	int ix;
  
 +	if (priv->indir_rqt.enabled) {
 +		/* RSS RQ table */
 +		rqtn = priv->indir_rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
++=======
+ 		mlx5e_rqt_redirect_indir(&res->indir_rqt, rqns, chs->num,
+ 					 res->rss_params.hash.hfunc,
+ 					 &res->rss_params.indir);
+ 		kvfree(rqns);
++>>>>>>> 6fe5ff2c7780 (net/mlx5e: Create struct mlx5e_rss_params_hash)
  	}
  
  	for (ix = 0; ix < priv->max_nch; ix++) {
@@@ -4659,10 -4591,10 +4666,17 @@@ void mlx5e_build_rss_params(struct mlx5
  {
  	enum mlx5e_traffic_types tt;
  
++<<<<<<< HEAD
 +	rss_params->hfunc = ETH_RSS_HASH_TOP;
 +	netdev_rss_key_fill(rss_params->toeplitz_hash_key,
 +			    sizeof(rss_params->toeplitz_hash_key));
 +	mlx5e_build_default_indir_rqt(rss_params->indirection_rqt,
++=======
+ 	rss_params->hash.hfunc = ETH_RSS_HASH_TOP;
+ 	netdev_rss_key_fill(rss_params->hash.toeplitz_hash_key,
+ 			    sizeof(rss_params->hash.toeplitz_hash_key));
+ 	mlx5e_build_default_indir_rqt(rss_params->indir.table,
++>>>>>>> 6fe5ff2c7780 (net/mlx5e: Create struct mlx5e_rss_params_hash)
  				      MLX5E_INDIR_RQT_SIZE, num_channels);
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
  		rss_params->rx_hash_fields[tt] =
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,b4d58dd5c849..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -516,60 -494,22 +516,66 @@@ static void mlx5e_hairpin_destroy_trans
  	mlx5_core_dealloc_transport_domain(hp->func_mdev, hp->tdn);
  }
  
 -static int mlx5e_hairpin_create_indirect_rqt(struct mlx5e_hairpin *hp)
 +static int mlx5e_hairpin_fill_rqt_rqns(struct mlx5e_hairpin *hp, void *rqtc)
  {
  	struct mlx5e_priv *priv = hp->func_priv;
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_rss_params_indir *indir;
 -	int err;
 +	int i, ix, sz = MLX5E_INDIR_RQT_SIZE;
 +	u32 *indirection_rqt, rqn;
  
 -	indir = kvmalloc(sizeof(*indir), GFP_KERNEL);
 -	if (!indir)
 +	indirection_rqt = kcalloc(sz, sizeof(*indirection_rqt), GFP_KERNEL);
 +	if (!indirection_rqt)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	mlx5e_build_default_indir_rqt(indirection_rqt, sz,
 +				      hp->num_channels);
++=======
+ 	mlx5e_build_default_indir_rqt(indir->table, MLX5E_INDIR_RQT_SIZE, hp->num_channels);
+ 	err = mlx5e_rqt_init_indir(&hp->indir_rqt, mdev, hp->pair->rqn, hp->num_channels,
+ 				    priv->rx_res->rss_params.hash.hfunc, indir);
++>>>>>>> 6fe5ff2c7780 (net/mlx5e: Create struct mlx5e_rss_params_hash)
  
 -	kvfree(indir);
 +	for (i = 0; i < sz; i++) {
 +		ix = i;
 +		if (priv->rss_params.hfunc == ETH_RSS_HASH_XOR)
 +			ix = mlx5e_bits_invert(i, ilog2(sz));
 +		ix = indirection_rqt[ix];
 +		rqn = hp->pair->rqn[ix];
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
 +
 +	kfree(indirection_rqt);
 +	return 0;
 +}
 +
 +static int mlx5e_hairpin_create_indirect_rqt(struct mlx5e_hairpin *hp)
 +{
 +	int inlen, err, sz = MLX5E_INDIR_RQT_SIZE;
 +	struct mlx5e_priv *priv = hp->func_priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	u32 *in;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(rqtc, rqtc, rqt_max_size, sz);
 +
 +	err = mlx5e_hairpin_fill_rqt_rqns(hp, rqtc);
 +	if (err)
 +		goto out;
 +
 +	err = mlx5_core_create_rqt(mdev, in, inlen, &hp->indir_rqt.rqtn);
 +	if (!err)
 +		hp->indir_rqt.enabled = true;
 +
 +out:
 +	kvfree(in);
  	return err;
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
