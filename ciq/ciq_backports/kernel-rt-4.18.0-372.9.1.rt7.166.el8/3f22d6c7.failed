net/mlx5e: Move RX resources to a separate struct

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Maxim Mikityanskiy <maximmi@nvidia.com>
commit 3f22d6c77bb91b3429814c3baae91903c8cf7f90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/3f22d6c7.failed

This commit moves RQTs and TIRs to a separate struct that is allocated
dynamically in profiles that support these RX resources (all profiles,
except IPoIB PKey). It also allows to remove rqt_enabled flags, as RQTs
are always enabled in profiles that support RX resources.

	Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 3f22d6c77bb91b3429814c3baae91903c8cf7f90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 73a162266789,2cd2fbf6764d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -58,6 -58,7 +58,10 @@@
  #include "en/qos.h"
  #include "lib/hv_vhca.h"
  #include "lib/clock.h"
++<<<<<<< HEAD
++=======
+ #include "en/rx_res.h"
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  
  extern const struct net_device_ops mlx5e_netdev_ops;
  struct page_pool;
@@@ -139,10 -140,7 +143,9 @@@
  #define MLX5E_PARAMS_DEFAULT_MIN_RX_WQES                0x80
  #define MLX5E_PARAMS_DEFAULT_MIN_RX_WQES_MPW            0x2
  
 +#define MLX5E_LOG_INDIR_RQT_SIZE       0x8
 +#define MLX5E_INDIR_RQT_SIZE           BIT(MLX5E_LOG_INDIR_RQT_SIZE)
  #define MLX5E_MIN_NUM_CHANNELS         0x1
- #define MLX5E_MAX_NUM_CHANNELS         (MLX5E_INDIR_RQT_SIZE / 2)
  #define MLX5E_MAX_NUM_SQS              (MLX5E_MAX_NUM_CHANNELS * MLX5E_MAX_NUM_TC)
  #define MLX5E_TX_CQ_POLL_BUDGET        128
  #define MLX5E_TX_XSK_POLL_BUDGET       64
@@@ -743,29 -743,11 +746,35 @@@ enum 
  	MLX5E_STATE_XDP_ACTIVE,
  };
  
++<<<<<<< HEAD
 +struct mlx5e_rqt {
 +	u32              rqtn;
 +	bool		 enabled;
 +};
 +
 +struct mlx5e_tir {
 +	u32		  tirn;
 +	struct mlx5e_rqt  rqt;
 +	struct list_head  list;
 +};
 +
++=======
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  enum {
  	MLX5E_TC_PRIO = 0,
  	MLX5E_NIC_PRIO
  };
  
++<<<<<<< HEAD
 +struct mlx5e_rss_params {
 +	u32	indirection_rqt[MLX5E_INDIR_RQT_SIZE];
 +	u32	rx_hash_fields[MLX5E_NUM_INDIR_TIRS];
 +	u8	toeplitz_hash_key[40];
 +	u8	hfunc;
 +};
 +
++=======
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  struct mlx5e_modify_sq_param {
  	int curr_state;
  	int next_state;
@@@ -835,12 -817,7 +844,16 @@@ struct mlx5e_priv 
  
  	struct mlx5e_channels      channels;
  	u32                        tisn[MLX5_MAX_PORTS][MLX5E_MAX_NUM_TC];
++<<<<<<< HEAD
 +	struct mlx5e_rqt           indir_rqt;
 +	struct mlx5e_tir           indir_tir[MLX5E_NUM_INDIR_TIRS];
 +	struct mlx5e_tir           inner_indir_tir[MLX5E_NUM_INDIR_TIRS];
 +	struct mlx5e_tir           direct_tir[MLX5E_MAX_NUM_CHANNELS];
 +	struct mlx5e_tir           xsk_tir[MLX5E_MAX_NUM_CHANNELS];
 +	struct mlx5e_rss_params    rss_params;
++=======
+ 	struct mlx5e_rx_res       *rx_res;
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	u32                        tx_rates[MLX5E_MAX_NUM_SQS];
  
  	struct mlx5e_flow_steering fs;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
index f9afbdefded5,c832a3dbdc74..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
@@@ -441,14 -561,103 +441,102 @@@ close_cqs
  	return err;
  }
  
 -static void mlx5e_ptp_close_queues(struct mlx5e_ptp *c)
 +static void mlx5e_ptp_close_queues(struct mlx5e_port_ptp *c)
  {
 -	if (test_bit(MLX5E_PTP_STATE_RX, c->state)) {
 -		mlx5e_close_rq(&c->rq);
 -		mlx5e_close_cq(&c->rq.cq);
 -	}
 -	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
 -		mlx5e_ptp_close_txqsqs(c);
 -		mlx5e_ptp_close_tx_cqs(c);
 -	}
 +	mlx5e_ptp_close_txqsqs(c);
 +	mlx5e_ptp_close_cqs(c);
  }
  
++<<<<<<< HEAD
 +int mlx5e_port_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
 +			u8 lag_port, struct mlx5e_port_ptp **cp)
++=======
+ static int mlx5e_ptp_set_state(struct mlx5e_ptp *c, struct mlx5e_params *params)
+ {
+ 	if (MLX5E_GET_PFLAG(params, MLX5E_PFLAG_TX_PORT_TS))
+ 		__set_bit(MLX5E_PTP_STATE_TX, c->state);
+ 
+ 	if (params->ptp_rx)
+ 		__set_bit(MLX5E_PTP_STATE_RX, c->state);
+ 
+ 	return bitmap_empty(c->state, MLX5E_PTP_STATE_NUM_STATES) ? -EINVAL : 0;
+ }
+ 
+ static void mlx5e_ptp_rx_unset_fs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_ptp_fs *ptp_fs = priv->fs.ptp_fs;
+ 
+ 	if (!ptp_fs->valid)
+ 		return;
+ 
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->l2_rule);
+ 	mlx5e_fs_tt_redirect_any_destroy(priv);
+ 
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v6_rule);
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v4_rule);
+ 	mlx5e_fs_tt_redirect_udp_destroy(priv);
+ 	ptp_fs->valid = false;
+ }
+ 
+ static int mlx5e_ptp_rx_set_fs(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_ptp_fs *ptp_fs = priv->fs.ptp_fs;
+ 	u32 tirn = priv->rx_res->ptp_tir.tirn;
+ 	struct mlx5_flow_handle *rule;
+ 	int err;
+ 
+ 	if (ptp_fs->valid)
+ 		return 0;
+ 
+ 	err = mlx5e_fs_tt_redirect_udp_create(priv);
+ 	if (err)
+ 		goto out_free;
+ 
+ 	rule = mlx5e_fs_tt_redirect_udp_add_rule(priv, MLX5E_TT_IPV4_UDP,
+ 						 tirn, PTP_EV_PORT);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_fs_udp;
+ 	}
+ 	ptp_fs->udp_v4_rule = rule;
+ 
+ 	rule = mlx5e_fs_tt_redirect_udp_add_rule(priv, MLX5E_TT_IPV6_UDP,
+ 						 tirn, PTP_EV_PORT);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_udp_v4_rule;
+ 	}
+ 	ptp_fs->udp_v6_rule = rule;
+ 
+ 	err = mlx5e_fs_tt_redirect_any_create(priv);
+ 	if (err)
+ 		goto out_destroy_udp_v6_rule;
+ 
+ 	rule = mlx5e_fs_tt_redirect_any_add_rule(priv, tirn, ETH_P_1588);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		goto out_destroy_fs_any;
+ 	}
+ 	ptp_fs->l2_rule = rule;
+ 	ptp_fs->valid = true;
+ 
+ 	return 0;
+ 
+ out_destroy_fs_any:
+ 	mlx5e_fs_tt_redirect_any_destroy(priv);
+ out_destroy_udp_v6_rule:
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v6_rule);
+ out_destroy_udp_v4_rule:
+ 	mlx5e_fs_tt_redirect_del_rule(ptp_fs->udp_v4_rule);
+ out_destroy_fs_udp:
+ 	mlx5e_fs_tt_redirect_udp_destroy(priv);
+ out_free:
+ 	return err;
+ }
+ 
+ int mlx5e_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
+ 		   u8 lag_port, struct mlx5e_ptp **cp)
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  {
  	struct net_device *netdev = priv->netdev;
  	struct mlx5_core_dev *mdev = priv->mdev;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
index 313a708e351b,27dc6336d000..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
@@@ -139,28 -184,14 +139,36 @@@ void mlx5e_deactivate_xsk(struct mlx5e_
  	/* TX queue is disabled on close. */
  }
  
 +static int mlx5e_redirect_xsk_rqt(struct mlx5e_priv *priv, u16 ix, u32 rqn)
 +{
 +	struct mlx5e_redirect_rqt_param direct_rrp = {
 +		.is_rss = false,
 +		{
 +			.rqn = rqn,
 +		},
 +	};
 +
 +	u32 rqtn = priv->xsk_tir[ix].rqt.rqtn;
 +
 +	return mlx5e_redirect_rqt(priv, rqtn, 1, direct_rrp);
 +}
 +
  int mlx5e_xsk_redirect_rqt_to_channel(struct mlx5e_priv *priv, struct mlx5e_channel *c)
  {
++<<<<<<< HEAD
 +	return mlx5e_redirect_xsk_rqt(priv, c->ix, c->xskrq.rqn);
++=======
+ 	return mlx5e_rqt_redirect_direct(&priv->rx_res->xsk_tirs[c->ix].rqt, c->xskrq.rqn);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  }
  
  int mlx5e_xsk_redirect_rqt_to_drop(struct mlx5e_priv *priv, u16 ix)
  {
++<<<<<<< HEAD
 +	return mlx5e_redirect_xsk_rqt(priv, ix, priv->drop_rq.rqn);
++=======
+ 	return mlx5e_rqt_redirect_direct(&priv->rx_res->xsk_tirs[ix].rqt, priv->drop_rq.rqn);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  }
  
  int mlx5e_xsk_redirect_rqts_to_channels(struct mlx5e_priv *priv, struct mlx5e_channels *chs)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index f0d51e7c3d41,8a75b37edcc2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -1218,11 -1198,12 +1218,13 @@@ int mlx5e_get_rxfh(struct net_device *n
  		   u8 *hfunc)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
- 	struct mlx5e_rss_params *rss = &priv->rss_params;
+ 	struct mlx5e_rss_params *rss;
+ 
+ 	rss = &priv->rx_res->rss_params;
  
  	if (indir)
 -		memcpy(indir, rss->indir.table, sizeof(rss->indir.table));
 +		memcpy(indir, rss->indirection_rqt,
 +		       sizeof(rss->indirection_rqt));
  
  	if (key)
  		memcpy(key, rss->toeplitz_hash_key,
@@@ -1274,18 -1256,20 +1278,33 @@@ int mlx5e_set_rxfh(struct net_device *d
  	}
  
  	if (refresh_rqt && test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 -		u32 *rqns;
 -
 +		struct mlx5e_redirect_rqt_param rrp = {
 +			.is_rss = true,
 +			{
 +				.rss = {
 +					.hfunc = rss->hfunc,
 +					.channels  = &priv->channels,
 +				},
 +			},
 +		};
 +		u32 rqtn = priv->indir_rqt.rqtn;
 +
++<<<<<<< HEAD
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
++=======
+ 		rqns = kvmalloc_array(priv->channels.num, sizeof(*rqns), GFP_KERNEL);
+ 		if (rqns) {
+ 			unsigned int ix;
+ 
+ 			for (ix = 0; ix < priv->channels.num; ix++)
+ 				rqns[ix] = priv->channels.c[ix]->rq.rqn;
+ 
+ 			mlx5e_rqt_redirect_indir(&priv->rx_res->indir_rqt, rqns,
+ 						 priv->channels.num,
+ 						 rss->hfunc, &rss->indir);
+ 			kvfree(rqns);
+ 		}
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	}
  
  	if (refresh_tirs)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 15e30d82e985,c1ff4bc348bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2180,49 -2194,12 +2180,54 @@@ void mlx5e_close_channels(struct mlx5e_
  	chs->num = 0;
  }
  
 +static int
 +mlx5e_create_rqt(struct mlx5e_priv *priv, int sz, struct mlx5e_rqt *rqt)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	int inlen;
 +	int err;
 +	u32 *in;
 +	int i;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(rqtc, rqtc, rqt_max_size, sz);
 +
 +	for (i = 0; i < sz; i++)
 +		MLX5_SET(rqtc, rqtc, rq_num[i], priv->drop_rq.rqn);
 +
 +	err = mlx5_core_create_rqt(mdev, in, inlen, &rqt->rqtn);
 +	if (!err)
 +		rqt->enabled = true;
 +
 +	kvfree(in);
 +	return err;
 +}
 +
 +void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt)
 +{
 +	rqt->enabled = false;
 +	mlx5_core_destroy_rqt(priv->mdev, rqt->rqtn);
 +}
 +
  int mlx5e_create_indirect_rqt(struct mlx5e_priv *priv)
  {
 +	struct mlx5e_rqt *rqt = &priv->indir_rqt;
  	int err;
  
++<<<<<<< HEAD
 +	err = mlx5e_create_rqt(priv, MLX5E_INDIR_RQT_SIZE, rqt);
++=======
+ 	err = mlx5e_rqt_init_direct(&priv->rx_res->indir_rqt, priv->mdev, true,
+ 				    priv->drop_rq.rqn);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	if (err)
  		mlx5_core_warn(priv->mdev, "create indirect rqts failed, %d\n", err);
  	return err;
@@@ -2244,7 -2222,7 +2249,11 @@@ int mlx5e_create_direct_rqts(struct mlx
  err_destroy_rqts:
  	mlx5_core_warn(priv->mdev, "create rqts failed, %d\n", err);
  	for (ix--; ix >= 0; ix--)
++<<<<<<< HEAD
 +		mlx5e_destroy_rqt(priv, &tirs[ix].rqt);
++=======
+ 		mlx5e_rqt_destroy(&tirs[ix].rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  
  	return err;
  }
@@@ -2254,7 -2232,7 +2263,11 @@@ void mlx5e_destroy_direct_rqts(struct m
  	int i;
  
  	for (i = 0; i < n; i++)
++<<<<<<< HEAD
 +		mlx5e_destroy_rqt(priv, &tirs[i].rqt);
++=======
+ 		mlx5e_rqt_destroy(&tirs[i].rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  }
  
  static int mlx5e_rx_hash_fn(int hfunc)
@@@ -2264,132 -2242,55 +2277,176 @@@
  	       MLX5_RX_HASH_FN_INVERTED_XOR8;
  }
  
 -static void mlx5e_redirect_rqts_to_channels(struct mlx5e_priv *priv,
 -					    struct mlx5e_channels *chs)
 +int mlx5e_bits_invert(unsigned long a, int size)
  {
++<<<<<<< HEAD
 +	int inv = 0;
 +	int i;
 +
 +	for (i = 0; i < size; i++)
 +		inv |= (test_bit(size - i - 1, &a) ? 1 : 0) << i;
 +
 +	return inv;
 +}
 +
 +static void mlx5e_fill_rqt_rqns(struct mlx5e_priv *priv, int sz,
 +				struct mlx5e_redirect_rqt_param rrp, void *rqtc)
 +{
 +	int i;
 +
 +	for (i = 0; i < sz; i++) {
 +		u32 rqn;
 +
 +		if (rrp.is_rss) {
 +			int ix = i;
 +
 +			if (rrp.rss.hfunc == ETH_RSS_HASH_XOR)
 +				ix = mlx5e_bits_invert(i, ilog2(sz));
 +
 +			ix = priv->rss_params.indirection_rqt[ix];
 +			rqn = rrp.rss.channels->c[ix]->rq.rqn;
 +		} else {
 +			rqn = rrp.rqn;
 +		}
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
 +}
 +
 +int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz,
 +		       struct mlx5e_redirect_rqt_param rrp)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	int inlen;
 +	u32 *in;
 +	int err;
 +
 +	inlen = MLX5_ST_SZ_BYTES(modify_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(modify_rqt_in, in, ctx);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(modify_rqt_in, in, bitmask.rqn_list, 1);
 +	mlx5e_fill_rqt_rqns(priv, sz, rrp, rqtc);
 +	err = mlx5_core_modify_rqt(mdev, rqtn, in, inlen);
 +
 +	kvfree(in);
 +	return err;
 +}
 +
 +static u32 mlx5e_get_direct_rqn(struct mlx5e_priv *priv, int ix,
 +				struct mlx5e_redirect_rqt_param rrp)
 +{
 +	if (!rrp.is_rss)
 +		return rrp.rqn;
 +
 +	if (ix >= rrp.rss.channels->num)
 +		return priv->drop_rq.rqn;
 +
 +	return rrp.rss.channels->c[ix]->rq.rqn;
 +}
 +
 +static void mlx5e_redirect_rqts(struct mlx5e_priv *priv,
 +				struct mlx5e_redirect_rqt_param rrp)
 +{
 +	u32 rqtn;
 +	int ix;
 +
 +	if (priv->indir_rqt.enabled) {
 +		/* RSS RQ table */
 +		rqtn = priv->indir_rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, MLX5E_INDIR_RQT_SIZE, rrp);
++=======
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	unsigned int ix;
+ 	u32 *rqns;
+ 
+ 	rqns = kvmalloc_array(chs->num, sizeof(*rqns), GFP_KERNEL);
+ 	if (rqns) {
+ 		for (ix = 0; ix < chs->num; ix++)
+ 			rqns[ix] = chs->c[ix]->rq.rqn;
+ 
+ 		mlx5e_rqt_redirect_indir(&res->indir_rqt, rqns, chs->num,
+ 					 res->rss_params.hfunc,
+ 					 &res->rss_params.indir);
+ 		kvfree(rqns);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	}
  
  	for (ix = 0; ix < priv->max_nch; ix++) {
 -		u32 rqn = priv->drop_rq.rqn;
 +		struct mlx5e_redirect_rqt_param direct_rrp = {
 +			.is_rss = false,
 +			{
 +				.rqn    = mlx5e_get_direct_rqn(priv, ix, rrp)
 +			},
 +		};
 +
++<<<<<<< HEAD
 +		/* Direct RQ Tables */
 +		if (!priv->direct_tir[ix].rqt.enabled)
 +			continue;
  
 +		rqtn = priv->direct_tir[ix].rqt.rqtn;
 +		mlx5e_redirect_rqt(priv, rqtn, 1, direct_rrp);
++=======
+ 		if (ix < chs->num)
+ 			rqn = chs->c[ix]->rq.rqn;
+ 
+ 		mlx5e_rqt_redirect_direct(&res->direct_tirs[ix].rqt, rqn);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	}
 +}
  
 -	if (priv->profile->rx_ptp_support) {
 -		u32 rqn;
 +static void mlx5e_redirect_rqts_to_channels(struct mlx5e_priv *priv,
 +					    struct mlx5e_channels *chs)
 +{
 +	struct mlx5e_redirect_rqt_param rrp = {
 +		.is_rss        = true,
 +		{
 +			.rss = {
 +				.channels  = chs,
 +				.hfunc     = priv->rss_params.hfunc,
 +			}
 +		},
 +	};
  
++<<<<<<< HEAD
 +	mlx5e_redirect_rqts(priv, rrp);
++=======
+ 		if (mlx5e_ptp_get_rqn(priv->channels.ptp, &rqn))
+ 			rqn = priv->drop_rq.rqn;
+ 
+ 		mlx5e_rqt_redirect_direct(&res->ptp_tir.rqt, rqn);
+ 	}
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  }
  
  static void mlx5e_redirect_rqts_to_drop(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	struct mlx5e_redirect_rqt_param drop_rrp = {
 +		.is_rss = false,
 +		{
 +			.rqn = priv->drop_rq.rqn,
 +		},
 +	};
 +
 +	mlx5e_redirect_rqts(priv, drop_rrp);
++=======
+ 	struct mlx5e_rx_res *res = priv->rx_res;
+ 	unsigned int ix;
+ 
+ 	mlx5e_rqt_redirect_direct(&res->indir_rqt, priv->drop_rq.rqn);
+ 
+ 	for (ix = 0; ix < priv->max_nch; ix++)
+ 		mlx5e_rqt_redirect_direct(&res->direct_tirs[ix].rqt, priv->drop_rq.rqn);
+ 
+ 	if (priv->profile->rx_ptp_support)
+ 		mlx5e_rqt_redirect_direct(&res->ptp_tir.rqt, priv->drop_rq.rqn);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  }
  
  static const struct mlx5e_tirc_config tirc_default_config[MLX5E_NUM_INDIR_TIRS] = {
@@@ -2745,8 -2648,9 +2804,14 @@@ int mlx5e_num_channels_changed(struct m
  
  	mlx5e_set_default_xps_cpumasks(priv, &priv->channels.params);
  
++<<<<<<< HEAD
 +	if (!netif_is_rxfh_configured(priv->netdev))
 +		mlx5e_build_default_indir_rqt(priv->rss_params.indirection_rqt,
++=======
+ 	/* This function may be called on attach, before priv->rx_res is created. */
+ 	if (!netif_is_rxfh_configured(priv->netdev) && priv->rx_res)
+ 		mlx5e_build_default_indir_rqt(priv->rx_res->rss_params.indir.table,
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  					      MLX5E_INDIR_RQT_SIZE, count);
  
  	return 0;
@@@ -5036,6 -4900,14 +5110,17 @@@ static int mlx5e_init_nic_rx(struct mlx
  	if (unlikely(err))
  		goto err_destroy_xsk_rqts;
  
++<<<<<<< HEAD
++=======
+ 	err = mlx5e_create_direct_rqts(priv, &priv->rx_res->ptp_tir, 1);
+ 	if (err)
+ 		goto err_destroy_xsk_tirs;
+ 
+ 	err = mlx5e_create_direct_tirs(priv, &priv->rx_res->ptp_tir, 1);
+ 	if (err)
+ 		goto err_destroy_ptp_rqt;
+ 
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	err = mlx5e_create_flow_steering(priv);
  	if (err) {
  		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
@@@ -5060,18 -4932,22 +5145,29 @@@ err_tc_nic_cleanup
  	mlx5e_tc_nic_cleanup(priv);
  err_destroy_flow_steering:
  	mlx5e_destroy_flow_steering(priv);
++<<<<<<< HEAD
++=======
+ err_destroy_ptp_direct_tir:
+ 	mlx5e_destroy_direct_tirs(priv, &priv->rx_res->ptp_tir, 1);
+ err_destroy_ptp_rqt:
+ 	mlx5e_destroy_direct_rqts(priv, &priv->rx_res->ptp_tir, 1);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  err_destroy_xsk_tirs:
- 	mlx5e_destroy_direct_tirs(priv, priv->xsk_tir, max_nch);
+ 	mlx5e_destroy_direct_tirs(priv, priv->rx_res->xsk_tirs, max_nch);
  err_destroy_xsk_rqts:
- 	mlx5e_destroy_direct_rqts(priv, priv->xsk_tir, max_nch);
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->xsk_tirs, max_nch);
  err_destroy_direct_tirs:
- 	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
+ 	mlx5e_destroy_direct_tirs(priv, priv->rx_res->direct_tirs, max_nch);
  err_destroy_indirect_tirs:
  	mlx5e_destroy_indirect_tirs(priv);
  err_destroy_direct_rqts:
- 	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->direct_tirs, max_nch);
  err_destroy_indirect_rqts:
++<<<<<<< HEAD
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
  err_destroy_q_counters:
@@@ -5086,14 -4964,18 +5184,27 @@@ static void mlx5e_cleanup_nic_rx(struc
  	mlx5e_accel_cleanup_rx(priv);
  	mlx5e_tc_nic_cleanup(priv);
  	mlx5e_destroy_flow_steering(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_tirs(priv, priv->xsk_tir, max_nch);
 +	mlx5e_destroy_direct_rqts(priv, priv->xsk_tir, max_nch);
 +	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_indirect_tirs(priv);
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5e_destroy_direct_tirs(priv, &priv->rx_res->ptp_tir, 1);
+ 	mlx5e_destroy_direct_rqts(priv, &priv->rx_res->ptp_tir, 1);
+ 	mlx5e_destroy_direct_tirs(priv, priv->rx_res->xsk_tirs, max_nch);
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->xsk_tirs, max_nch);
+ 	mlx5e_destroy_direct_tirs(priv, priv->rx_res->direct_tirs, max_nch);
+ 	mlx5e_destroy_indirect_tirs(priv);
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->direct_tirs, max_nch);
+ 	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	mlx5e_close_drop_rq(&priv->drop_rq);
  	mlx5e_destroy_q_counters(priv);
+ 	kvfree(priv->rx_res);
+ 	priv->rx_res = NULL;
  }
  
  static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 98da6dcc9ee9,590a7ae35155..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -815,11 -816,13 +820,17 @@@ err_destroy_direct_tirs
  err_destroy_indirect_tirs:
  	mlx5e_destroy_indirect_tirs(priv);
  err_destroy_direct_rqts:
- 	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->direct_tirs, max_nch);
  err_destroy_indirect_rqts:
++<<<<<<< HEAD
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
+ 	kvfree(priv->rx_res);
+ 	priv->rx_res = NULL;
  	return err;
  }
  
@@@ -831,11 -834,13 +842,18 @@@ static void mlx5e_cleanup_rep_rx(struc
  	rep_vport_rx_rule_destroy(priv);
  	mlx5e_destroy_rep_root_ft(priv);
  	mlx5e_destroy_ttc_table(priv, &priv->fs.ttc);
- 	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
+ 	mlx5e_destroy_direct_tirs(priv, priv->rx_res->direct_tirs, max_nch);
  	mlx5e_destroy_indirect_tirs(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->direct_tirs, max_nch);
+ 	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	mlx5e_close_drop_rq(&priv->drop_rq);
+ 	kvfree(priv->rx_res);
+ 	priv->rx_res = NULL;
  }
  
  static int mlx5e_init_ul_rep_rx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e0f6d7e16317,4c00abc472be..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -516,60 -494,22 +516,66 @@@ static void mlx5e_hairpin_destroy_trans
  	mlx5_core_dealloc_transport_domain(hp->func_mdev, hp->tdn);
  }
  
 -static int mlx5e_hairpin_create_indirect_rqt(struct mlx5e_hairpin *hp)
 +static int mlx5e_hairpin_fill_rqt_rqns(struct mlx5e_hairpin *hp, void *rqtc)
  {
  	struct mlx5e_priv *priv = hp->func_priv;
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_rss_params_indir *indir;
 -	int err;
 +	int i, ix, sz = MLX5E_INDIR_RQT_SIZE;
 +	u32 *indirection_rqt, rqn;
  
 -	indir = kvmalloc(sizeof(*indir), GFP_KERNEL);
 -	if (!indir)
 +	indirection_rqt = kcalloc(sz, sizeof(*indirection_rqt), GFP_KERNEL);
 +	if (!indirection_rqt)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	mlx5e_build_default_indir_rqt(indirection_rqt, sz,
 +				      hp->num_channels);
++=======
+ 	mlx5e_build_default_indir_rqt(indir->table, MLX5E_INDIR_RQT_SIZE, hp->num_channels);
+ 	err = mlx5e_rqt_init_indir(&hp->indir_rqt, mdev, hp->pair->rqn, hp->num_channels,
+ 				   priv->rx_res->rss_params.hfunc, indir);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  
 -	kvfree(indir);
 +	for (i = 0; i < sz; i++) {
 +		ix = i;
 +		if (priv->rss_params.hfunc == ETH_RSS_HASH_XOR)
 +			ix = mlx5e_bits_invert(i, ilog2(sz));
 +		ix = indirection_rqt[ix];
 +		rqn = hp->pair->rqn[ix];
 +		MLX5_SET(rqtc, rqtc, rq_num[i], rqn);
 +	}
 +
 +	kfree(indirection_rqt);
 +	return 0;
 +}
 +
 +static int mlx5e_hairpin_create_indirect_rqt(struct mlx5e_hairpin *hp)
 +{
 +	int inlen, err, sz = MLX5E_INDIR_RQT_SIZE;
 +	struct mlx5e_priv *priv = hp->func_priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqtc;
 +	u32 *in;
 +
 +	inlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
 +	rqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);
 +
 +	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
 +	MLX5_SET(rqtc, rqtc, rqt_max_size, sz);
 +
 +	err = mlx5e_hairpin_fill_rqt_rqns(hp, rqtc);
 +	if (err)
 +		goto out;
 +
 +	err = mlx5_core_create_rqt(mdev, in, inlen, &hp->indir_rqt.rqtn);
 +	if (!err)
 +		hp->indir_rqt.enabled = true;
 +
 +out:
 +	kvfree(in);
  	return err;
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index f3988eec3041,685d23e90450..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -405,9 -403,9 +409,13 @@@ err_destroy_direct_tirs
  err_destroy_indirect_tirs:
  	mlx5e_destroy_indirect_tirs(priv);
  err_destroy_direct_rqts:
- 	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->direct_tirs, max_nch);
  err_destroy_indirect_rqts:
++<<<<<<< HEAD
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  err_close_drop_rq:
  	mlx5e_close_drop_rq(&priv->drop_rq);
  err_destroy_q_counters:
@@@ -420,12 -420,14 +430,19 @@@ static void mlx5i_cleanup_rx(struct mlx
  	u16 max_nch = priv->max_nch;
  
  	mlx5i_destroy_flow_steering(priv);
- 	mlx5e_destroy_direct_tirs(priv, priv->direct_tir, max_nch);
+ 	mlx5e_destroy_direct_tirs(priv, priv->rx_res->direct_tirs, max_nch);
  	mlx5e_destroy_indirect_tirs(priv);
++<<<<<<< HEAD
 +	mlx5e_destroy_direct_rqts(priv, priv->direct_tir, max_nch);
 +	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
++=======
+ 	mlx5e_destroy_direct_rqts(priv, priv->rx_res->direct_tirs, max_nch);
+ 	mlx5e_rqt_destroy(&priv->rx_res->indir_rqt);
++>>>>>>> 3f22d6c77bb9 (net/mlx5e: Move RX resources to a separate struct)
  	mlx5e_close_drop_rq(&priv->drop_rq);
  	mlx5e_destroy_q_counters(priv);
+ 	kvfree(priv->rx_res);
+ 	priv->rx_res = NULL;
  }
  
  /* The stats groups order is opposite to the update_stats() order calls */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 6d1dade3f38c..e77e996f6b8e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@ -168,6 +168,8 @@ enum {
 					 MLX5E_INNER_TTC_GROUP2_SIZE +\
 					 MLX5E_INNER_TTC_GROUP3_SIZE)
 
+struct mlx5e_priv;
+
 #ifdef CONFIG_MLX5_EN_RXNFC
 
 struct mlx5e_ethtool_table {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
new file mode 100644
index 000000000000..0520ee39c162
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2021, Mellanox Technologies inc. All rights reserved. */
+
+#ifndef __MLX5_EN_RX_RES_H__
+#define __MLX5_EN_RX_RES_H__
+
+#include <linux/kernel.h>
+#include "rqt.h"
+#include "fs.h"
+
+#define MLX5E_MAX_NUM_CHANNELS (MLX5E_INDIR_RQT_SIZE / 2)
+
+struct mlx5e_rss_params {
+	struct mlx5e_rss_params_indir indir;
+	u32 rx_hash_fields[MLX5E_NUM_INDIR_TIRS];
+	u8 toeplitz_hash_key[40];
+	u8 hfunc;
+};
+
+struct mlx5e_tir {
+	u32 tirn;
+	struct mlx5e_rqt rqt;
+	struct list_head list;
+};
+
+struct mlx5e_rx_res {
+	struct mlx5e_rqt indir_rqt;
+	struct mlx5e_tir indir_tirs[MLX5E_NUM_INDIR_TIRS];
+	struct mlx5e_tir inner_indir_tirs[MLX5E_NUM_INDIR_TIRS];
+	struct mlx5e_tir direct_tirs[MLX5E_MAX_NUM_CHANNELS];
+	struct mlx5e_tir xsk_tirs[MLX5E_MAX_NUM_CHANNELS];
+	struct mlx5e_tir ptp_tir;
+	struct mlx5e_rss_params rss_params;
+};
+
+#endif /* __MLX5_EN_RX_RES_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
index 1d166cb4f6f5..cc8720717ff3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
@@ -642,7 +642,7 @@ int mlx5e_ktls_add_rx(struct net_device *netdev, struct sock *sk,
 	priv_rx->sw_stats = &priv->tls->sw_stats;
 	mlx5e_set_ktls_rx_priv_ctx(tls_ctx, priv_rx);
 
-	rqtn = priv->direct_tir[rxq].rqt.rqtn;
+	rqtn = priv->rx_res->direct_tirs[rxq].rqt.rqtn;
 
 	err = mlx5e_ktls_create_tir(mdev, &priv_rx->tirn, rqtn);
 	if (err)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 25403af32859..b1efbcbb2573 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -192,7 +192,7 @@ static int arfs_add_default_rule(struct mlx5e_priv *priv,
 				 enum arfs_type type)
 {
 	struct arfs_table *arfs_t = &priv->fs.arfs->arfs_tables[type];
-	struct mlx5e_tir *tir = priv->indir_tir;
+	struct mlx5e_tir *tir = priv->rx_res->indir_tirs;
 	struct mlx5_flow_destination dest = {};
 	MLX5_DECLARE_FLOW_ACT(flow_act);
 	enum mlx5e_traffic_types tt;
@@ -553,7 +553,7 @@ static struct mlx5_flow_handle *arfs_add_rule(struct mlx5e_priv *priv,
 		       16);
 	}
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
-	dest.tir_num = priv->direct_tir[arfs_rule->rxq].tirn;
+	dest.tir_num = priv->rx_res->direct_tirs[arfs_rule->rxq].tirn;
 	rule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);
 	if (IS_ERR(rule)) {
 		err = PTR_ERR(rule);
@@ -576,7 +576,7 @@ static void arfs_modify_rule_rq(struct mlx5e_priv *priv,
 	int err = 0;
 
 	dst.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
-	dst.tir_num = priv->direct_tir[rxq].tirn;
+	dst.tir_num = priv->rx_res->direct_tirs[rxq].tirn;
 	err =  mlx5_modify_rule_destination(rule, &dst, NULL);
 	if (err)
 		netdev_warn(priv->netdev,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 059efb0721cd..1d6f6d49676c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@ -1296,7 +1296,7 @@ static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 void mlx5e_set_ttc_basic_params(struct mlx5e_priv *priv,
 				struct ttc_params *ttc_params)
 {
-	ttc_params->any_tt_tirn = priv->direct_tir[0].tirn;
+	ttc_params->any_tt_tirn = priv->rx_res->direct_tirs[0].tirn;
 	ttc_params->inner_ttc = &priv->fs.inner_ttc;
 }
 
@@ -1755,7 +1755,7 @@ int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
 	if (mlx5e_tunnel_inner_ft_supported(priv->mdev)) {
 		mlx5e_set_inner_ttc_ft_params(&ttc_params);
 		for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
-			ttc_params.indir_tirn[tt] = priv->inner_indir_tir[tt].tirn;
+			ttc_params.indir_tirn[tt] = priv->rx_res->inner_indir_tirs[tt].tirn;
 
 		err = mlx5e_create_inner_ttc_table(priv, &ttc_params, &priv->fs.inner_ttc);
 		if (err) {
@@ -1767,7 +1767,7 @@ int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
 
 	mlx5e_set_ttc_ft_params(&ttc_params);
 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
-		ttc_params.indir_tirn[tt] = priv->indir_tir[tt].tirn;
+		ttc_params.indir_tirn[tt] = priv->rx_res->indir_tirs[tt].tirn;
 
 	err = mlx5e_create_ttc_table(priv, &ttc_params, &priv->fs.ttc);
 	if (err) {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
index b416a8ee2eed..b30967a316d1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
@@ -425,7 +425,8 @@ add_ethtool_flow_rule(struct mlx5e_priv *priv,
 		u16 ix;
 
 		mlx5e_qid_get_ch_and_group(params, fs->ring_cookie, &ix, &group);
-		tir = group == MLX5E_RQ_GROUP_XSK ? priv->xsk_tir : priv->direct_tir;
+		tir = group == MLX5E_RQ_GROUP_XSK ? priv->rx_res->xsk_tirs :
+						    priv->rx_res->direct_tirs;
 
 		dst = kzalloc(sizeof(*dst), GFP_KERNEL);
 		if (!dst) {
@@ -854,10 +855,10 @@ static int mlx5e_set_rss_hash_opt(struct mlx5e_priv *priv,
 
 	mutex_lock(&priv->state_lock);
 
-	if (rx_hash_field == priv->rss_params.rx_hash_fields[tt])
+	if (rx_hash_field == priv->rx_res->rss_params.rx_hash_fields[tt])
 		goto out;
 
-	priv->rss_params.rx_hash_fields[tt] = rx_hash_field;
+	priv->rx_res->rss_params.rx_hash_fields[tt] = rx_hash_field;
 	mlx5e_modify_tirs_hash(priv, in);
 
 out:
@@ -876,7 +877,7 @@ static int mlx5e_get_rss_hash_opt(struct mlx5e_priv *priv,
 	if (tt == MLX5E_NUM_INDIR_TIRS)
 		return -EINVAL;
 
-	hash_field = priv->rss_params.rx_hash_fields[tt];
+	hash_field = priv->rx_res->rss_params.rx_hash_fields[tt];
 	nfc->data = 0;
 
 	if (hash_field & MLX5_HASH_FIELD_SEL_SRC_IP)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
