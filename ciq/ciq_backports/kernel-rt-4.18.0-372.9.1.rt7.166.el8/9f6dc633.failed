dm: interlock pending dm_io and dm_wait_for_bios_completion

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Mike Snitzer <snitzer@redhat.com>
commit 9f6dc633761006f974701d4c88da71ab68670749
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/9f6dc633.failed

Commit d208b89401e0 ("dm: fix mempool NULL pointer race when
completing IO") didn't go far enough.

When bio_end_io_acct ends the count of in-flight I/Os may reach zero
and the DM device may be suspended. There is a possibility that the
suspend races with dm_stats_account_io.

Fix this by adding percpu "pending_io" counters to track outstanding
dm_io. Move kicking of suspend queue to dm_io_dec_pending(). Also,
rename md_in_flight_bios() to dm_in_flight_bios() and update it to
iterate all pending_io counters.

Fixes: d208b89401e0 ("dm: fix mempool NULL pointer race when completing IO")
	Cc: stable@vger.kernel.org
Co-developed-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 9f6dc633761006f974701d4c88da71ab68670749)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index cea43bc71f38,18329b33e8cd..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1779,12 -1564,18 +1782,19 @@@ static void cleanup_mapped_device(struc
  		spin_lock(&_minor_lock);
  		md->disk->private_data = NULL;
  		spin_unlock(&_minor_lock);
 -		if (dm_get_md_type(md) != DM_TYPE_NONE) {
 -			dm_sysfs_exit(md);
 -			del_gendisk(md->disk);
 -		}
 -		dm_queue_destroy_crypto_profile(md->queue);
 -		blk_cleanup_disk(md->disk);
 +		del_gendisk(md->disk);
 +		put_disk(md->disk);
  	}
  
++<<<<<<< HEAD
 +	if (md->queue)
 +		blk_cleanup_queue(md->queue);
++=======
+ 	if (md->pending_io) {
+ 		free_percpu(md->pending_io);
+ 		md->pending_io = NULL;
+ 	}
++>>>>>>> 9f6dc6337610 (dm: interlock pending dm_io and dm_wait_for_bios_completion)
  
  	cleanup_srcu_struct(&md->io_barrier);
  
@@@ -1890,8 -1679,8 +1900,13 @@@ static struct mapped_device *alloc_dev(
  	if (!md->wq)
  		goto bad;
  
++<<<<<<< HEAD
 +	md->bdev = bdget_disk(md->disk, 0);
 +	if (!md->bdev)
++=======
+ 	md->pending_io = alloc_percpu(unsigned long);
+ 	if (!md->pending_io)
++>>>>>>> 9f6dc6337610 (dm: interlock pending dm_io and dm_wait_for_bios_completion)
  		goto bad;
  
  	dm_stats_init(&md->stats);
@@@ -2306,16 -2090,13 +2321,18 @@@ void dm_put(struct mapped_device *md
  }
  EXPORT_SYMBOL_GPL(dm_put);
  
- static bool md_in_flight_bios(struct mapped_device *md)
+ static bool dm_in_flight_bios(struct mapped_device *md)
  {
  	int cpu;
++<<<<<<< HEAD
 +	struct hd_struct *part = &dm_disk(md)->part0;
 +	long sum = 0;
++=======
+ 	unsigned long sum = 0;
++>>>>>>> 9f6dc6337610 (dm: interlock pending dm_io and dm_wait_for_bios_completion)
  
- 	for_each_possible_cpu(cpu) {
- 		sum += part_stat_local_read_cpu(part, in_flight[0], cpu);
- 		sum += part_stat_local_read_cpu(part, in_flight[1], cpu);
- 	}
+ 	for_each_possible_cpu(cpu)
+ 		sum += *per_cpu_ptr(md->pending_io, cpu);
  
  	return sum != 0;
  }
diff --git a/drivers/md/dm-core.h b/drivers/md/dm-core.h
index 9f310e561e6d..77175ea7ef3b 100644
--- a/drivers/md/dm-core.h
+++ b/drivers/md/dm-core.h
@@ -63,6 +63,8 @@ struct mapped_device {
 	struct gendisk *disk;
 	struct dax_device *dax_dev;
 
+	unsigned long __percpu *pending_io;
+
 	/*
 	 * A list of ios that arrived while we were suspended.
 	 */
* Unmerged path drivers/md/dm.c
