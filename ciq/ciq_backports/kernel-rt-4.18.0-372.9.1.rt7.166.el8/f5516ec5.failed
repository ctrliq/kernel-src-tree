device-dax: make pgmap optional for instance creation

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit f5516ec5efb9fe0f426a46eeef25d389d3c2f988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/f5516ec5.failed

The passed in dev_pagemap is only required in the pmem case as the
libnvdimm core may have reserved a vmem_altmap for dev_memremap_pages() to
place the memmap in pmem directly.  In the hmem case there is no agent
reserving an altmap so it can all be handled by a core internal default.

Pass the resource range via a new @range property of 'struct
dev_dax_data'.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Vishal Verma <vishal.l.verma@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Brice Goglin <Brice.Goglin@inria.fr>
	Cc: Dave Jiang <dave.jiang@intel.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Jia He <justin.he@arm.com>
	Cc: Joao Martins <joao.m.martins@oracle.com>
	Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Ard Biesheuvel <ardb@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Ben Skeggs <bskeggs@redhat.com>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: David Airlie <airlied@linux.ie>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Hulk Robot <hulkci@huawei.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Jason Yan <yanaijie@huawei.com>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: "Jérôme Glisse" <jglisse@redhat.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: kernel test robot <lkp@intel.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Paul Mackerras <paulus@ozlabs.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Stefano Stabellini <sstabellini@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Cc: Wei Yang <richard.weiyang@linux.alibaba.com>
	Cc: Will Deacon <will@kernel.org>
Link: https://lkml.kernel.org/r/159643099958.4062302.10379230791041872886.stgit@dwillia2-desk3.amr.corp.intel.com
Link: https://lkml.kernel.org/r/160106110513.30709.4303239334850606031.stgit@dwillia2-desk3.amr.corp.intel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f5516ec5efb9fe0f426a46eeef25d389d3c2f988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/dax-private.h
#	drivers/dax/device.c
#	drivers/dax/kmem.c
diff --cc drivers/dax/dax-private.h
index 6f41597afb47,6779f683671d..000000000000
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@@ -49,15 -41,25 +49,32 @@@ struct dax_region 
   * @target_node: effective numa node if dev_dax memory range is onlined
   * @dev - device core
   * @pgmap - pgmap for memmap setup / lifetime (driver owned)
++<<<<<<< HEAD
++=======
+  * @range: resource range for the instance
+  * @dax_mem_res: physical address range of hotadded DAX memory
+  * @dax_mem_name: name for hotadded DAX memory via add_memory_driver_managed()
++>>>>>>> f5516ec5efb9 (device-dax: make pgmap optional for instance creation)
   */
  struct dev_dax {
  	struct dax_region *region;
  	struct dax_device *dax_dev;
  	int target_node;
  	struct device dev;
++<<<<<<< HEAD
 +	struct dev_pagemap pgmap;
++=======
+ 	struct dev_pagemap *pgmap;
+ 	struct range range;
+ 	struct resource *dax_kmem_res;
++>>>>>>> f5516ec5efb9 (device-dax: make pgmap optional for instance creation)
  };
  
+ static inline u64 range_len(struct range *range)
+ {
+ 	return range->end - range->start + 1;
+ }
+ 
  static inline struct dev_dax *to_dev_dax(struct device *dev)
  {
  	return container_of(dev, struct dev_dax, dev);
diff --cc drivers/dax/device.c
index eaa651ddeccd,287cf0a3db23..000000000000
--- a/drivers/dax/device.c
+++ b/drivers/dax/device.c
@@@ -408,8 -411,16 +410,21 @@@ int dev_dax_probe(struct device *dev
  		return -EBUSY;
  	}
  
++<<<<<<< HEAD
 +	dev_dax->pgmap.type = MEMORY_DEVICE_DEVDAX;
 +	addr = devm_memremap_pages(dev, &dev_dax->pgmap);
++=======
+ 	pgmap = dev_dax->pgmap;
+ 	if (!pgmap) {
+ 		pgmap = devm_kzalloc(dev, sizeof(*pgmap), GFP_KERNEL);
+ 		if (!pgmap)
+ 			return -ENOMEM;
+ 		pgmap->res.start = range->start;
+ 		pgmap->res.end = range->end;
+ 	}
+ 	pgmap->type = MEMORY_DEVICE_GENERIC;
+ 	addr = devm_memremap_pages(dev, pgmap);
++>>>>>>> f5516ec5efb9 (device-dax: make pgmap optional for instance creation)
  	if (IS_ERR(addr))
  		return PTR_ERR(addr);
  
* Unmerged path drivers/dax/kmem.c
diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index dffa4655e128..96bd64ba95a5 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -271,7 +271,7 @@ static ssize_t size_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct dev_dax *dev_dax = to_dev_dax(dev);
-	unsigned long long size = resource_size(&dev_dax->region->res);
+	unsigned long long size = range_len(&dev_dax->range);
 
 	return sprintf(buf, "%llu\n", size);
 }
@@ -293,19 +293,12 @@ static ssize_t target_node_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(target_node);
 
-static unsigned long long dev_dax_resource(struct dev_dax *dev_dax)
-{
-	struct dax_region *dax_region = dev_dax->region;
-
-	return dax_region->res.start;
-}
-
 static ssize_t resource_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct dev_dax *dev_dax = to_dev_dax(dev);
 
-	return sprintf(buf, "%#llx\n", dev_dax_resource(dev_dax));
+	return sprintf(buf, "%#llx\n", dev_dax->range.start);
 }
 static DEVICE_ATTR(resource, 0400, resource_show, NULL);
 
@@ -376,6 +369,7 @@ static void dev_dax_release(struct device *dev)
 
 	dax_region_put(dax_region);
 	put_dax(dax_dev);
+	kfree(dev_dax->pgmap);
 	kfree(dev_dax);
 }
 
@@ -412,7 +406,12 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
 	if (!dev_dax)
 		return ERR_PTR(-ENOMEM);
 
-	memcpy(&dev_dax->pgmap, data->pgmap, sizeof(struct dev_pagemap));
+	if (data->pgmap) {
+		dev_dax->pgmap = kmemdup(data->pgmap,
+				sizeof(struct dev_pagemap), GFP_KERNEL);
+		if (!dev_dax->pgmap)
+			goto err_pgmap;
+	}
 
 	/*
 	 * No 'host' or dax_operations since there is no access to this
@@ -421,18 +420,19 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
 	dax_dev = alloc_dax(dev_dax, NULL, NULL, DAXDEV_F_SYNC);
 	if (IS_ERR(dax_dev)) {
 		rc = PTR_ERR(dax_dev);
-		goto err;
+		goto err_alloc_dax;
 	}
 
 	/* a device_dax instance is dead while the driver is not attached */
 	kill_dax(dax_dev);
 
-	/* from here on we're committed to teardown via dax_dev_release() */
+	/* from here on we're committed to teardown via dev_dax_release() */
 	dev = &dev_dax->dev;
 	device_initialize(dev);
 
 	dev_dax->dax_dev = dax_dev;
 	dev_dax->region = dax_region;
+	dev_dax->range = data->range;
 	dev_dax->target_node = dax_region->target_node;
 	kref_get(&dax_region->kref);
 
@@ -458,8 +458,9 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
 		return ERR_PTR(rc);
 
 	return dev_dax;
-
- err:
+err_alloc_dax:
+	kfree(dev_dax->pgmap);
+err_pgmap:
 	kfree(dev_dax);
 
 	return ERR_PTR(rc);
diff --git a/drivers/dax/bus.h b/drivers/dax/bus.h
index 299c2e7fac09..4aeb36da83a4 100644
--- a/drivers/dax/bus.h
+++ b/drivers/dax/bus.h
@@ -3,6 +3,7 @@
 #ifndef __DAX_BUS_H__
 #define __DAX_BUS_H__
 #include <linux/device.h>
+#include <linux/range.h>
 
 struct dev_dax;
 struct resource;
@@ -21,6 +22,7 @@ struct dev_dax_data {
 	struct dax_region *dax_region;
 	struct dev_pagemap *pgmap;
 	enum dev_dax_subsys subsys;
+	struct range range;
 	int id;
 };
 
* Unmerged path drivers/dax/dax-private.h
* Unmerged path drivers/dax/device.c
diff --git a/drivers/dax/hmem/hmem.c b/drivers/dax/hmem/hmem.c
index b84fe17178d8..af82d6ba820a 100644
--- a/drivers/dax/hmem/hmem.c
+++ b/drivers/dax/hmem/hmem.c
@@ -8,7 +8,6 @@
 static int dax_hmem_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct dev_pagemap pgmap = { };
 	struct dax_region *dax_region;
 	struct memregion_info *mri;
 	struct dev_dax_data data;
@@ -20,8 +19,6 @@ static int dax_hmem_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	mri = dev->platform_data;
-	memcpy(&pgmap.res, res, sizeof(*res));
-
 	dax_region = alloc_dax_region(dev, pdev->id, res, mri->target_node,
 			PMD_SIZE);
 	if (!dax_region)
@@ -30,7 +27,10 @@ static int dax_hmem_probe(struct platform_device *pdev)
 	data = (struct dev_dax_data) {
 		.dax_region = dax_region,
 		.id = 0,
-		.pgmap = &pgmap,
+		.range = {
+			.start = res->start,
+			.end = res->end,
+		},
 	};
 	dev_dax = devm_create_dev_dax(&data);
 	if (IS_ERR(dev_dax))
* Unmerged path drivers/dax/kmem.c
diff --git a/drivers/dax/pmem/core.c b/drivers/dax/pmem/core.c
index 615ebe8bfa98..4b6cfd1a89c1 100644
--- a/drivers/dax/pmem/core.c
+++ b/drivers/dax/pmem/core.c
@@ -63,6 +63,10 @@ struct dev_dax *__dax_pmem_probe(struct device *dev, enum dev_dax_subsys subsys)
 		.id = id,
 		.pgmap = &pgmap,
 		.subsys = subsys,
+		.range = {
+			.start = res.start,
+			.end = res.end,
+		},
 	};
 	dev_dax = devm_create_dev_dax(&data);
 
diff --git a/tools/testing/nvdimm/dax-dev.c b/tools/testing/nvdimm/dax-dev.c
index f36e708265b8..fed09ba22577 100644
--- a/tools/testing/nvdimm/dax-dev.c
+++ b/tools/testing/nvdimm/dax-dev.c
@@ -17,12 +17,12 @@
 phys_addr_t dax_pgoff_to_phys(struct dev_dax *dev_dax, pgoff_t pgoff,
 		unsigned long size)
 {
-	struct resource *res = &dev_dax->region->res;
+	struct range *range = &dev_dax->range;
 	phys_addr_t addr;
 
-	addr = pgoff * PAGE_SIZE + res->start;
-	if (addr >= res->start && addr <= res->end) {
-		if (addr + size - 1 <= res->end) {
+	addr = pgoff * PAGE_SIZE + range->start;
+	if (addr >= range->start && addr <= range->end) {
+		if (addr + size - 1 <= range->end) {
 			if (get_nfit_res(addr)) {
 				struct page *page;
 
