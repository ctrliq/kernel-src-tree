net/mlx5: Fix some error handling paths in 'mlx5e_tc_add_fdb_flow()'

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Christophe JAILLET <christophe.jaillet@wanadoo.fr>
commit 31108d142f3632970f6f3e0224bd1c6781c9f87d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/31108d14.failed

All the error handling paths of 'mlx5e_tc_add_fdb_flow()' end to 'err_out'
where 'flow_flag_set(flow, FAILED);' is called.

All but the new error handling paths added by the commits given in the
Fixes tag below.

Fix these error handling paths and branch to 'err_out'.

Fixes: 166f431ec6be ("net/mlx5e: Add indirect tc offload of ovs internal port")
Fixes: b16eb3c81fe2 ("net/mlx5: Support internal port as decap route device")
	Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 31108d142f3632970f6f3e0224bd1c6781c9f87d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 36dc4da53fcf,ca74ed616382..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1437,6 -1425,24 +1437,27 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  		err = mlx5e_attach_decap_route(priv, flow);
  		if (err)
  			goto err_out;
++<<<<<<< HEAD
++=======
+ 
+ 		if (!attr->chain && esw_attr->int_port) {
+ 			/* If decap route device is internal port, change the
+ 			 * source vport value in reg_c0 back to uplink just in
+ 			 * case the rule performs goto chain > 0. If we have a miss
+ 			 * on chain > 0 we want the metadata regs to hold the
+ 			 * chain id so SW will resume handling of this packet
+ 			 * from the proper chain.
+ 			 */
+ 			u32 metadata = mlx5_eswitch_get_vport_metadata_for_set(esw,
+ 									esw_attr->in_rep->vport);
+ 
+ 			err = mlx5e_tc_match_to_reg_set(priv->mdev, &parse_attr->mod_hdr_acts,
+ 							MLX5_FLOW_NAMESPACE_FDB, VPORT_TO_REG,
+ 							metadata);
+ 			if (err)
+ 				goto err_out;
+ 		}
++>>>>>>> 31108d142f36 (net/mlx5: Fix some error handling paths in 'mlx5e_tc_add_fdb_flow()')
  	}
  
  	if (flow_flag_test(flow, L3_TO_L2_DECAP)) {
@@@ -1445,8 -1451,35 +1466,40 @@@
  			goto err_out;
  	}
  
++<<<<<<< HEAD
 +	parse_attr = attr->parse_attr;
 +	esw_attr = attr->esw_attr;
++=======
+ 	if (netif_is_ovs_master(parse_attr->filter_dev)) {
+ 		struct mlx5e_tc_int_port *int_port;
+ 
+ 		if (attr->chain) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "Internal port rule is only supported on chain 0");
+ 			err = -EOPNOTSUPP;
+ 			goto err_out;
+ 		}
+ 
+ 		if (attr->dest_chain) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "Internal port rule offload doesn't support goto action");
+ 			err = -EOPNOTSUPP;
+ 			goto err_out;
+ 		}
+ 
+ 		int_port = mlx5e_tc_int_port_get(mlx5e_get_int_port_priv(priv),
+ 						 parse_attr->filter_dev->ifindex,
+ 						 flow_flag_test(flow, EGRESS) ?
+ 						 MLX5E_TC_INT_PORT_EGRESS :
+ 						 MLX5E_TC_INT_PORT_INGRESS);
+ 		if (IS_ERR(int_port)) {
+ 			err = PTR_ERR(int_port);
+ 			goto err_out;
+ 		}
+ 
+ 		esw_attr->int_port = int_port;
+ 	}
++>>>>>>> 31108d142f36 (net/mlx5: Fix some error handling paths in 'mlx5e_tc_add_fdb_flow()')
  
  	for (out_index = 0; out_index < MLX5_MAX_FLOW_FWD_VPORTS; out_index++) {
  		struct net_device *out_dev;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
