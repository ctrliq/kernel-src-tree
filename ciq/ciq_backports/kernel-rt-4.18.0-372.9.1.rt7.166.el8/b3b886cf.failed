net/mlx5e: Refactor on-the-fly configuration changes

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Maxim Mikityanskiy <maximmi@mellanox.com>
commit b3b886cf965d5f8d8e51f9481ce60ee8f9548580
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/b3b886cf.failed

This commit extends mlx5e_safe_switch_channels() to support on-the-fly
configuration changes, when the channels are open, but don't need to be
recreated. Such flows exist when a parameter being changed doesn't
affect how the queues are created, or when the queues can be modified
while remaining active.

Before this commit, such flows were handled as special cases on the
caller site. This commit adds this functionality to
mlx5e_safe_switch_channels(), allowing the caller to pass a boolean
indicating whether it's required to recreate the channels or it's
allowed to skip it. The logic of switching channel parameters is now
completely encapsulated into mlx5e_safe_switch_channels().

	Signed-off-by: Maxim Mikityanskiy <maximmi@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit b3b886cf965d5f8d8e51f9481ce60ee8f9548580)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index f23c67575073,0b0273fac6e3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -1150,9 -1150,8 +1150,14 @@@ static int mlx5e_update_trust_state_hw(
  static int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state)
  {
  	struct mlx5e_channels new_channels = {};
++<<<<<<< HEAD
 +	bool reset_channels = true;
 +	bool opened;
 +	int err = 0;
++=======
+ 	bool reset = true;
+ 	int err;
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  
  	mutex_lock(&priv->state_lock);
  
@@@ -1167,18 -1162,12 +1172,27 @@@
  	/* Skip if tx_min_inline is the same */
  	if (new_channels.params.tx_min_inline_mode ==
  	    priv->channels.params.tx_min_inline_mode)
++<<<<<<< HEAD
 +		reset_channels = false;
 +
 +	if (reset_channels) {
 +		err = mlx5e_safe_switch_channels(priv, &new_channels,
 +						 mlx5e_update_trust_state_hw,
 +						 &trust_state);
 +	} else {
 +		err = mlx5e_update_trust_state_hw(priv, &trust_state);
 +		if (!err && !opened)
 +			priv->channels.params = new_channels.params;
 +	}
 +
++=======
+ 		reset = false;
+ 
+ 	err = mlx5e_safe_switch_channels(priv, &new_channels,
+ 					 mlx5e_update_trust_state_hw,
+ 					 &trust_state, reset);
+ 
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	mutex_unlock(&priv->state_lock);
  
  	return err;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index ece5963738c0,82994175aded..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -372,12 -373,7 +372,16 @@@ int mlx5e_ethtool_set_ringparam(struct 
  	if (err)
  		goto unlock;
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		goto unlock;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, true);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  
  unlock:
  	mutex_unlock(&priv->state_lock);
@@@ -1889,12 -1868,7 +1892,16 @@@ static int set_pflag_cqe_based_moder(st
  	else
  		mlx5e_set_tx_cq_mode_params(&new_channels.params, cq_period_mode);
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, true);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  }
  
  static int set_pflag_tx_cqe_based_moder(struct net_device *netdev, bool enable)
@@@ -1921,13 -1895,14 +1928,21 @@@ int mlx5e_modify_rx_cqe_compression_loc
  
  	new_channels.params = priv->channels.params;
  	MLX5E_SET_PFLAG(&new_channels.params, MLX5E_PFLAG_RX_CQE_COMPRESS, new_val);
 -	if (priv->tstamp.rx_filter != HWTSTAMP_FILTER_NONE)
 -		new_channels.params.ptp_rx = new_val;
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	if (new_channels.params.ptp_rx == priv->channels.params.ptp_rx)
+ 		err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, true);
+ 	else
+ 		err = mlx5e_safe_switch_channels(priv, &new_channels, mlx5e_ptp_rx_manage_fs_ctx,
+ 						 &new_channels.params.ptp_rx, true);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	if (err)
  		return err;
  
@@@ -1983,12 -1953,7 +1998,16 @@@ static int set_pflag_rx_striding_rq(str
  	MLX5E_SET_PFLAG(&new_channels.params, MLX5E_PFLAG_RX_STRIDING_RQ, enable);
  	mlx5e_set_rq_type(mdev, &new_channels.params);
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
++=======
+ 	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, true);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  }
  
  static int set_pflag_rx_no_csum_complete(struct net_device *netdev, bool enable)
@@@ -2027,13 -1991,7 +2046,17 @@@ static int set_pflag_tx_mpwqe_common(st
  
  	MLX5E_SET_PFLAG(&new_channels.params, flag, enable);
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		priv->channels.params = new_channels.params;
 +		return 0;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
 +	return err;
++=======
+ 	return mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, true);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  }
  
  static int set_pflag_xdp_tx_mpwqe(struct net_device *netdev, bool enable)
@@@ -2073,22 -2031,10 +2096,26 @@@ static int set_pflag_tx_port_ts(struct 
  	 * has the same log_sq_size.
  	 */
  
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = priv->channels.params;
 +		priv->channels.params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			priv->channels.params = old_params;
 +		goto out;
 +	}
 +
  	err = mlx5e_safe_switch_channels(priv, &new_channels,
++<<<<<<< HEAD
 +					 mlx5e_num_channels_changed_ctx, NULL);
 +out:
++=======
+ 					 mlx5e_num_channels_changed_ctx, NULL, true);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	if (!err)
 -		priv->tx_ptp_opened = true;
 +		priv->port_ptp_opened = true;
  
  	return err;
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 12c3751bdd22,7686d4997696..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3381,20 -3414,8 +3388,20 @@@ static int mlx5e_setup_tc_mqprio(struc
  	new_channels.params = priv->channels.params;
  	new_channels.params.num_tc = tc ? tc : 1;
  
 +	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = priv->channels.params;
 +		priv->channels.params = new_channels.params;
 +		err = mlx5e_num_channels_changed(priv);
 +		if (err)
 +			priv->channels.params = old_params;
 +
 +		goto out;
 +	}
 +
  	err = mlx5e_safe_switch_channels(priv, &new_channels,
- 					 mlx5e_num_channels_changed_ctx, NULL);
+ 					 mlx5e_num_channels_changed_ctx, NULL, true);
  
  out:
  	priv->max_opened_tc = max_t(u8, priv->max_opened_tc,
@@@ -3613,8 -3642,8 +3620,12 @@@ static int set_feature_lro(struct net_d
  	struct mlx5_core_dev *mdev = priv->mdev;
  	struct mlx5e_channels new_channels = {};
  	struct mlx5e_params *cur_params;
++<<<<<<< HEAD
++=======
+ 	bool reset = true;
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	int err = 0;
 +	bool reset;
  
  	mutex_lock(&priv->state_lock);
  
@@@ -3641,17 -3668,6 +3652,20 @@@
  		if (mlx5e_rx_mpwqe_is_linear_skb(mdev, cur_params, NULL) ==
  		    mlx5e_rx_mpwqe_is_linear_skb(mdev, &new_channels.params, NULL))
  			reset = false;
++<<<<<<< HEAD
 +	}
 +
 +	if (!reset) {
 +		struct mlx5e_params old_params;
 +
 +		old_params = *cur_params;
 +		*cur_params = new_channels.params;
 +		err = mlx5e_modify_tirs_lro(priv);
 +		if (err)
 +			*cur_params = old_params;
 +		goto out;
++=======
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	}
  
  	err = mlx5e_safe_switch_channels(priv, &new_channels,
@@@ -3895,8 -3902,8 +3909,12 @@@ int mlx5e_change_mtu(struct net_device 
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5e_channels new_channels = {};
  	struct mlx5e_params *params;
++<<<<<<< HEAD
++=======
+ 	bool reset = true;
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	int err = 0;
 +	bool reset;
  
  	mutex_lock(&priv->state_lock);
  
@@@ -3926,42 -3930,29 +3944,61 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (params->lro_en)
+ 		reset = false;
+ 
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	if (params->rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ) {
 -		bool is_linear_old = mlx5e_rx_mpwqe_is_linear_skb(priv->mdev, params, NULL);
 -		bool is_linear_new = mlx5e_rx_mpwqe_is_linear_skb(priv->mdev,
 -								  &new_channels.params, NULL);
 +		bool is_linear = mlx5e_rx_mpwqe_is_linear_skb(priv->mdev,
 +							      &new_channels.params,
 +							      NULL);
  		u8 ppw_old = mlx5e_mpwqe_log_pkts_per_wqe(params, NULL);
  		u8 ppw_new = mlx5e_mpwqe_log_pkts_per_wqe(&new_channels.params, NULL);
  
++<<<<<<< HEAD
 +		/* If XSK is active, XSK RQs are linear. */
 +		is_linear |= priv->xsk.refcnt;
 +
 +		/* Always reset in linear mode - hw_mtu is used in data path. */
 +		reset = reset && (is_linear || (ppw_old != ppw_new));
 +	}
 +
 +	if (!reset) {
 +		unsigned int old_mtu = params->sw_mtu;
 +
 +		params->sw_mtu = new_mtu;
 +		if (preactivate) {
 +			err = preactivate(priv, NULL);
 +			if (err) {
 +				params->sw_mtu = old_mtu;
 +				goto out;
 +			}
 +		}
 +		netdev->mtu = params->sw_mtu;
 +		goto out;
 +	}
 +
 +	err = mlx5e_safe_switch_channels(priv, &new_channels, preactivate, NULL);
 +	if (err)
 +		goto out;
 +
 +	netdev->mtu = new_channels.params.sw_mtu;
++=======
+ 		/* Always reset in linear mode - hw_mtu is used in data path.
+ 		 * Check that the mode was non-linear and didn't change.
+ 		 * If XSK is active, XSK RQs are linear.
+ 		 */
+ 		if (!is_linear_old && !is_linear_new && !priv->xsk.refcnt &&
+ 		    ppw_old == ppw_new)
+ 			reset = false;
+ 	}
+ 
+ 	err = mlx5e_safe_switch_channels(priv, &new_channels, preactivate, NULL, reset);
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  
  out:
 -	netdev->mtu = params->sw_mtu;
  	mutex_unlock(&priv->state_lock);
  	return err;
  }
@@@ -4030,6 -4024,16 +4067,19 @@@ int mlx5e_hwstamp_set(struct mlx5e_pri
  		return -ERANGE;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (new_channels.params.ptp_rx == priv->channels.params.ptp_rx)
+ 		goto out;
+ 
+ 	err = mlx5e_safe_switch_channels(priv, &new_channels, mlx5e_ptp_rx_manage_fs_ctx,
+ 					 &new_channels.params.ptp_rx, true);
+ 	if (err) {
+ 		mutex_unlock(&priv->state_lock);
+ 		return err;
+ 	}
+ out:
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  	memcpy(&priv->tstamp, &config, sizeof(config));
  	mutex_unlock(&priv->state_lock);
  
@@@ -4402,38 -4405,20 +4453,41 @@@ static int mlx5e_xdp_set(struct net_dev
  	/* no need for full reset when exchanging programs */
  	reset = (!priv->channels.params.xdp_prog || !prog);
  
++<<<<<<< HEAD
 +	if (was_opened && !reset)
 +		/* num_channels is invariant here, so we can take the
 +		 * batched reference right upfront.
 +		 */
 +		bpf_prog_add(prog, priv->channels.num);
 +
 +	if (was_opened && reset) {
 +		struct mlx5e_channels new_channels = {};
 +
 +		new_channels.params = priv->channels.params;
 +		new_channels.params.xdp_prog = prog;
++=======
+ 	new_channels.params = priv->channels.params;
+ 	new_channels.params.xdp_prog = prog;
+ 	if (reset)
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  		mlx5e_set_rq_type(priv->mdev, &new_channels.params);
- 		old_prog = priv->channels.params.xdp_prog;
+ 	old_prog = priv->channels.params.xdp_prog;
  
- 		err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
- 		if (err)
- 			goto unlock;
- 	} else {
- 		/* exchange programs, extra prog reference we got from caller
- 		 * as long as we don't fail from this point onwards.
- 		 */
- 		old_prog = xchg(&priv->channels.params.xdp_prog, prog);
- 	}
+ 	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, reset);
+ 	if (err)
+ 		goto unlock;
  
  	if (old_prog)
  		bpf_prog_put(old_prog);
  
++<<<<<<< HEAD
 +	if (!was_opened && reset) /* change RQ type according to priv->xdp_prog */
 +		mlx5e_set_rq_type(priv->mdev, &priv->channels.params);
 +
 +	if (!was_opened || reset)
++=======
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state) || reset)
++>>>>>>> b3b886cf965d (net/mlx5e: Refactor on-the-fly configuration changes)
  		goto unlock;
  
  	/* exchanging programs w/o reset, we update ref counts on behalf
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 9cd4c188c5a0..d37b25a0a355 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -1017,7 +1017,7 @@ int mlx5e_safe_reopen_channels(struct mlx5e_priv *priv);
 int mlx5e_safe_switch_channels(struct mlx5e_priv *priv,
 			       struct mlx5e_channels *new_chs,
 			       mlx5e_fp_preactivate preactivate,
-			       void *context);
+			       void *context, bool reset);
 int mlx5e_update_tx_netdev_queues(struct mlx5e_priv *priv);
 int mlx5e_num_channels_changed(struct mlx5e_priv *priv);
 int mlx5e_num_channels_changed_ctx(struct mlx5e_priv *priv, void *context);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index e73e098ed210..685a2de3252e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@ -497,7 +497,7 @@ static int mlx5i_change_mtu(struct net_device *netdev, int new_mtu)
 	new_channels.params = *params;
 	new_channels.params.sw_mtu = new_mtu;
 
-	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL);
+	err = mlx5e_safe_switch_channels(priv, &new_channels, NULL, NULL, true);
 	if (err)
 		goto out;
 
