net/mlx5e: Add RQ to PTP channel

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Aya Levin <ayal@nvidia.com>
commit a099da8ffcf6d4f6d41719bd41878ff529ab6b55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/a099da8f.failed

Enhance PTP channel to allow PTP without disabling CQE compression. Add
RQ, TIR and PTP_RX_STATE to PTP channel. When this bit is set, PTP
channel manages its RQ, and PTP traffic is directed to the PTP-RQ which
is not affected by compression.

	Signed-off-by: Aya Levin <ayal@nvidia.com>
	Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a099da8ffcf6d4f6d41719bd41878ff529ab6b55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
index f9afbdefded5,7f7dfaed9fb4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
@@@ -3,6 -3,15 +3,18 @@@
  
  #include "en/ptp.h"
  #include "en/txrx.h"
++<<<<<<< HEAD
++=======
+ #include "en/params.h"
+ 
+ #define MLX5E_PTP_CHANNEL_IX 0
+ 
+ struct mlx5e_ptp_params {
+ 	struct mlx5e_params params;
+ 	struct mlx5e_sq_param txq_sq_param;
+ 	struct mlx5e_rq_param rq_param;
+ };
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  
  struct mlx5e_skb_cb_hwtstamp {
  	ktime_t cqe_hwtstamp;
@@@ -116,9 -125,9 +128,10 @@@ static bool mlx5e_ptp_poll_ts_cq(struc
  
  static int mlx5e_ptp_napi_poll(struct napi_struct *napi, int budget)
  {
 -	struct mlx5e_ptp *c = container_of(napi, struct mlx5e_ptp, napi);
 +	struct mlx5e_port_ptp *c = container_of(napi, struct mlx5e_port_ptp,
 +						napi);
  	struct mlx5e_ch_stats *ch_stats = c->stats;
+ 	struct mlx5e_rq *rq = &c->rq;
  	bool busy = false;
  	int work_done = 0;
  	int i;
@@@ -127,10 -136,20 +140,18 @@@
  
  	ch_stats->poll++;
  
 -	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
 -		for (i = 0; i < c->num_tc; i++) {
 -			busy |= mlx5e_poll_tx_cq(&c->ptpsq[i].txqsq.cq, budget);
 -			busy |= mlx5e_ptp_poll_ts_cq(&c->ptpsq[i].ts_cq, budget);
 -		}
 +	for (i = 0; i < c->num_tc; i++) {
 +		busy |= mlx5e_poll_tx_cq(&c->ptpsq[i].txqsq.cq, budget);
 +		busy |= mlx5e_ptp_poll_ts_cq(&c->ptpsq[i].ts_cq, budget);
  	}
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state) && likely(budget)) {
+ 		work_done = mlx5e_poll_rx_cq(&rq->cq, budget);
+ 		busy |= work_done == budget;
+ 		busy |= INDIRECT_CALL_2(rq->post_wqes,
+ 					mlx5e_post_rx_mpwqes,
+ 					mlx5e_post_rx_wqes,
+ 					rq);
+ 	}
  
  	if (busy) {
  		work_done = budget;
@@@ -142,10 -161,14 +163,12 @@@
  
  	ch_stats->arm++;
  
 -	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
 -		for (i = 0; i < c->num_tc; i++) {
 -			mlx5e_cq_arm(&c->ptpsq[i].txqsq.cq);
 -			mlx5e_cq_arm(&c->ptpsq[i].ts_cq);
 -		}
 +	for (i = 0; i < c->num_tc; i++) {
 +		mlx5e_cq_arm(&c->ptpsq[i].txqsq.cq);
 +		mlx5e_cq_arm(&c->ptpsq[i].ts_cq);
  	}
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state))
+ 		mlx5e_cq_arm(&rq->cq);
  
  out:
  	rcu_read_unlock();
@@@ -327,8 -350,8 +350,13 @@@ static void mlx5e_ptp_close_txqsqs(stru
  		mlx5e_ptp_close_txqsq(&c->ptpsq[tc]);
  }
  
++<<<<<<< HEAD
 +static int mlx5e_ptp_open_cqs(struct mlx5e_port_ptp *c,
 +			      struct mlx5e_ptp_params *cparams)
++=======
+ static int mlx5e_ptp_open_tx_cqs(struct mlx5e_ptp *c,
+ 				 struct mlx5e_ptp_params *cparams)
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  {
  	struct mlx5e_params *params = &cparams->params;
  	struct mlx5e_create_cq_param ccp = {};
@@@ -376,7 -399,25 +404,29 @@@ out_err_txqsq_cq
  	return err;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_ptp_close_cqs(struct mlx5e_port_ptp *c)
++=======
+ static int mlx5e_ptp_open_rx_cq(struct mlx5e_ptp *c,
+ 				struct mlx5e_ptp_params *cparams)
+ {
+ 	struct mlx5e_create_cq_param ccp = {};
+ 	struct dim_cq_moder ptp_moder = {};
+ 	struct mlx5e_cq_param *cq_param;
+ 	struct mlx5e_cq *cq = &c->rq.cq;
+ 
+ 	ccp.node     = dev_to_node(mlx5_core_dma_dev(c->mdev));
+ 	ccp.ch_stats = c->stats;
+ 	ccp.napi     = &c->napi;
+ 	ccp.ix       = MLX5E_PTP_CHANNEL_IX;
+ 
+ 	cq_param = &cparams->rq_param.cqp;
+ 
+ 	return mlx5e_open_cq(c->priv, ptp_moder, cq_param, &ccp, cq);
+ }
+ 
+ static void mlx5e_ptp_close_tx_cqs(struct mlx5e_ptp *c)
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  {
  	int tc;
  
@@@ -402,7 -443,21 +452,25 @@@ static void mlx5e_ptp_build_sq_param(st
  	mlx5e_build_tx_cq_param(mdev, params, &param->cqp);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_ptp_build_params(struct mlx5e_port_ptp *c,
++=======
+ static void mlx5e_ptp_build_rq_param(struct mlx5_core_dev *mdev,
+ 				     struct net_device *netdev,
+ 				     u16 q_counter,
+ 				     struct mlx5e_ptp_params *ptp_params)
+ {
+ 	struct mlx5e_rq_param *rq_params = &ptp_params->rq_param;
+ 	struct mlx5e_params *params = &ptp_params->params;
+ 
+ 	params->rq_wq_type = MLX5_WQ_TYPE_CYCLIC;
+ 	mlx5e_init_rq_type_params(mdev, params);
+ 	params->sw_mtu = netdev->max_mtu;
+ 	mlx5e_build_rq_param(mdev, params, NULL, q_counter, rq_params);
+ }
+ 
+ static void mlx5e_ptp_build_params(struct mlx5e_ptp *c,
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  				   struct mlx5e_ptp_params *cparams,
  				   struct mlx5e_params *orig)
  {
@@@ -415,40 -470,111 +483,129 @@@
  	params->num_tc = orig->num_tc;
  
  	/* SQ */
++<<<<<<< HEAD
 +	params->log_sq_size = orig->log_sq_size;
 +
 +	mlx5e_ptp_build_sq_param(c->mdev, params, &cparams->txq_sq_param);
++=======
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
+ 		params->log_sq_size = orig->log_sq_size;
+ 		mlx5e_ptp_build_sq_param(c->mdev, params, &cparams->txq_sq_param);
+ 	}
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state))
+ 		mlx5e_ptp_build_rq_param(c->mdev, c->netdev, c->priv->q_counter, cparams);
+ }
+ 
+ static int mlx5e_init_ptp_rq(struct mlx5e_ptp *c, struct mlx5e_params *params,
+ 			     struct mlx5e_rq *rq)
+ {
+ 	struct mlx5_core_dev *mdev = c->mdev;
+ 	struct mlx5e_priv *priv = c->priv;
+ 	int err;
+ 
+ 	rq->wq_type      = params->rq_wq_type;
+ 	rq->pdev         = mdev->device;
+ 	rq->netdev       = priv->netdev;
+ 	rq->priv         = priv;
+ 	rq->clock        = &mdev->clock;
+ 	rq->tstamp       = &priv->tstamp;
+ 	rq->mdev         = mdev;
+ 	rq->hw_mtu       = MLX5E_SW2HW_MTU(params, params->sw_mtu);
+ 	rq->stats        = &c->priv->ptp_stats.rq;
+ 	rq->ptp_cyc2time = mlx5_rq_ts_translator(mdev);
+ 	err = mlx5e_rq_set_handlers(rq, params, false);
+ 	if (err)
+ 		return err;
+ 
+ 	return xdp_rxq_info_reg(&rq->xdp_rxq, rq->netdev, rq->ix, 0);
+ }
+ 
+ static int mlx5e_ptp_open_rq(struct mlx5e_ptp *c, struct mlx5e_params *params,
+ 			     struct mlx5e_rq_param *rq_param)
+ {
+ 	int node = dev_to_node(c->mdev->device);
+ 	int err;
+ 
+ 	err = mlx5e_init_ptp_rq(c, params, &c->rq);
+ 	if (err)
+ 		return err;
+ 
+ 	return mlx5e_open_rq(params, rq_param, NULL, node, &c->rq);
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  }
  
 -static int mlx5e_ptp_open_queues(struct mlx5e_ptp *c,
 +static int mlx5e_ptp_open_queues(struct mlx5e_port_ptp *c,
  				 struct mlx5e_ptp_params *cparams)
  {
  	int err;
  
++<<<<<<< HEAD
 +	err = mlx5e_ptp_open_cqs(c, cparams);
 +	if (err)
 +		return err;
 +
 +	err = mlx5e_ptp_open_txqsqs(c, cparams);
 +	if (err)
 +		goto close_cqs;
 +
 +	return 0;
 +
 +close_cqs:
 +	mlx5e_ptp_close_cqs(c);
++=======
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
+ 		err = mlx5e_ptp_open_tx_cqs(c, cparams);
+ 		if (err)
+ 			return err;
+ 
+ 		err = mlx5e_ptp_open_txqsqs(c, cparams);
+ 		if (err)
+ 			goto close_tx_cqs;
+ 	}
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state)) {
+ 		err = mlx5e_ptp_open_rx_cq(c, cparams);
+ 		if (err)
+ 			goto close_txqsq;
+ 
+ 		err = mlx5e_ptp_open_rq(c, &cparams->params, &cparams->rq_param);
+ 		if (err)
+ 			goto close_rx_cq;
+ 	}
+ 	return 0;
+ 
+ close_rx_cq:
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state))
+ 		mlx5e_close_cq(&c->rq.cq);
+ close_txqsq:
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state))
+ 		mlx5e_ptp_close_txqsqs(c);
+ close_tx_cqs:
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state))
+ 		mlx5e_ptp_close_tx_cqs(c);
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  
  	return err;
  }
  
 -static void mlx5e_ptp_close_queues(struct mlx5e_ptp *c)
 +static void mlx5e_ptp_close_queues(struct mlx5e_port_ptp *c)
  {
++<<<<<<< HEAD
 +	mlx5e_ptp_close_txqsqs(c);
 +	mlx5e_ptp_close_cqs(c);
++=======
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state)) {
+ 		mlx5e_close_rq(&c->rq);
+ 		mlx5e_close_cq(&c->rq.cq);
+ 	}
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
+ 		mlx5e_ptp_close_txqsqs(c);
+ 		mlx5e_ptp_close_tx_cqs(c);
+ 	}
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  }
  
 -static int mlx5e_ptp_set_state(struct mlx5e_ptp *c, struct mlx5e_params *params)
 -{
 -	if (MLX5E_GET_PFLAG(params, MLX5E_PFLAG_TX_PORT_TS))
 -		__set_bit(MLX5E_PTP_STATE_TX, c->state);
 -
 -	return bitmap_empty(c->state, MLX5E_PTP_STATE_NUM_STATES) ? -EINVAL : 0;
 -}
 -
 -int mlx5e_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
 -		   u8 lag_port, struct mlx5e_ptp **cp)
 +int mlx5e_port_ptp_open(struct mlx5e_priv *priv, struct mlx5e_params *params,
 +			u8 lag_port, struct mlx5e_port_ptp **cp)
  {
  	struct net_device *netdev = priv->netdev;
  	struct mlx5_core_dev *mdev = priv->mdev;
@@@ -515,16 -638,25 +672,35 @@@ void mlx5e_ptp_activate_channel(struct 
  
  	napi_enable(&c->napi);
  
++<<<<<<< HEAD
 +	for (tc = 0; tc < c->num_tc; tc++)
 +		mlx5e_activate_txqsq(&c->ptpsq[tc].txqsq);
++=======
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
+ 		for (tc = 0; tc < c->num_tc; tc++)
+ 			mlx5e_activate_txqsq(&c->ptpsq[tc].txqsq);
+ 	}
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state))
+ 		mlx5e_activate_rq(&c->rq);
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  }
  
 -void mlx5e_ptp_deactivate_channel(struct mlx5e_ptp *c)
 +void mlx5e_ptp_deactivate_channel(struct mlx5e_port_ptp *c)
  {
  	int tc;
  
++<<<<<<< HEAD
 +	for (tc = 0; tc < c->num_tc; tc++)
 +		mlx5e_deactivate_txqsq(&c->ptpsq[tc].txqsq);
++=======
+ 	if (test_bit(MLX5E_PTP_STATE_RX, c->state))
+ 		mlx5e_deactivate_rq(&c->rq);
+ 
+ 	if (test_bit(MLX5E_PTP_STATE_TX, c->state)) {
+ 		for (tc = 0; tc < c->num_tc; tc++)
+ 			mlx5e_deactivate_txqsq(&c->ptpsq[tc].txqsq);
+ 	}
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  
  	napi_disable(&c->napi);
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.h
index 28aa5ae118f4,cc6a48a43233..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.h
@@@ -17,9 -16,16 +17,20 @@@ struct mlx5e_ptpsq 
  	struct mlx5e_ptp_cq_stats *cq_stats;
  };
  
++<<<<<<< HEAD
 +struct mlx5e_port_ptp {
++=======
+ enum {
+ 	MLX5E_PTP_STATE_TX,
+ 	MLX5E_PTP_STATE_RX,
+ 	MLX5E_PTP_STATE_NUM_STATES,
+ };
+ 
+ struct mlx5e_ptp {
++>>>>>>> a099da8ffcf6 (net/mlx5e: Add RQ to PTP channel)
  	/* data path */
  	struct mlx5e_ptpsq         ptpsq[MLX5E_MAX_NUM_TC];
+ 	struct mlx5e_rq            rq;
  	struct napi_struct         napi;
  	struct device             *pdev;
  	struct net_device         *netdev;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 9cd4c188c5a0..ba7441265366 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -734,6 +734,7 @@ struct mlx5e_port_ptp_stats {
 	struct mlx5e_ch_stats ch;
 	struct mlx5e_sq_stats sq[MLX5E_MAX_NUM_TC];
 	struct mlx5e_ptp_cq_stats cq[MLX5E_MAX_NUM_TC];
+	struct mlx5e_rq_stats rq;
 } ____cacheline_aligned_in_smp;
 
 enum {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.h
