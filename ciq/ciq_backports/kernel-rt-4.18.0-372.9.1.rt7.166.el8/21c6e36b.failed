ice: tighter control over VSI_DOWN state

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 21c6e36b1e556af2a6eaf15faa14c51e3b4c854e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/21c6e36b.failed

The driver had comments to the effect of: This flag should be set before
calling this function. While reviewing code it was found that there were
several violations of this policy, which could introduce hard to find
bugs or races.

Fix the violations of the "VSI DOWN state must be set before calling
ice_down" and make checking the state into code with a WARN_ON.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 21c6e36b1e556af2a6eaf15faa14c51e3b4c854e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_main.c
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index a13eae346070,865f2231bb24..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -6064,12 -6236,13 +6066,18 @@@ int ice_down(struct ice_vsi *vsi
  {
  	int i, tx_err, rx_err, link_err = 0;
  
++<<<<<<< HEAD
 +	/* Caller of this function is expected to set the
 +	 * vsi->state ICE_DOWN bit
 +	 */
 +	if (vsi->netdev) {
++=======
+ 	WARN_ON(!test_bit(ICE_VSI_DOWN, vsi->state));
+ 
+ 	if (vsi->netdev && vsi->type == ICE_VSI_PF) {
++>>>>>>> 21c6e36b1e55 (ice: tighter control over VSI_DOWN state)
  		netif_carrier_off(vsi->netdev);
  		netif_tx_disable(vsi->netdev);
 -	} else if (vsi->type == ICE_VSI_SWITCHDEV_CTRL) {
 -		ice_eswitch_stop_all_tx_queues(vsi->back);
  	}
  
  	ice_vsi_dis_irq(vsi);
diff --git a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c
index be50950576d4..d1fbed6ecaa5 100644
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@ -1290,8 +1290,10 @@ static int ice_set_priv_flags(struct net_device *netdev, u32 flags)
 	}
 	if (test_bit(ICE_FLAG_LEGACY_RX, change_flags)) {
 		/* down and up VSI so that changes of Rx cfg are reflected. */
-		ice_down(vsi);
-		ice_up(vsi);
+		if (!test_and_set_bit(ICE_VSI_DOWN, vsi->state)) {
+			ice_down(vsi);
+			ice_up(vsi);
+		}
 	}
 	/* don't allow modification of this flag when a single VF is in
 	 * promiscuous mode because it's not supported
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
