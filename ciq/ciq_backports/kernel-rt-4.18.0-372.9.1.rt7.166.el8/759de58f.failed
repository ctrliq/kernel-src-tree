arm64: switch to ->regset_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 759de58f28b1cd90a485d3bf1ce49236a153ce51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/759de58f.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 759de58f28b1cd90a485d3bf1ce49236a153ce51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/ptrace.c
diff --cc arch/arm64/kernel/ptrace.c
index 75b1a69a377c,902d987fdd35..000000000000
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@@ -645,9 -608,11 +613,8 @@@ static int __fpr_get(struct task_struc
  }
  
  static int fpr_get(struct task_struct *target, const struct user_regset *regset,
- 		   unsigned int pos, unsigned int count,
- 		   void *kbuf, void __user *ubuf)
+ 		   struct membuf to)
  {
 -	if (!system_supports_fpsimd())
 -		return -EINVAL;
 -
  	if (target == current)
  		fpsimd_preserve_current_state();
  
@@@ -1016,10 -958,9 +957,9 @@@ static void pac_address_keys_from_user(
  
  static int pac_address_keys_get(struct task_struct *target,
  				const struct user_regset *regset,
- 				unsigned int pos, unsigned int count,
- 				void *kbuf, void __user *ubuf)
+ 				struct membuf to)
  {
 -	struct ptrauth_keys_user *keys = &target->thread.keys_user;
 +	struct ptrauth_keys *keys = &target->thread.keys_user;
  	struct user_pac_address_keys user_keys;
  
  	if (!system_supports_address_auth())
@@@ -1067,10 -1007,9 +1006,9 @@@ static void pac_generic_keys_from_user(
  
  static int pac_generic_keys_get(struct task_struct *target,
  				const struct user_regset *regset,
- 				unsigned int pos, unsigned int count,
- 				void *kbuf, void __user *ubuf)
+ 				struct membuf to)
  {
 -	struct ptrauth_keys_user *keys = &target->thread.keys_user;
 +	struct ptrauth_keys *keys = &target->thread.keys_user;
  	struct user_pac_generic_keys user_keys;
  
  	if (!system_supports_generic_auth())
@@@ -1145,7 -1083,8 +1082,12 @@@ static const struct user_regset aarch64
  		 */
  		.size = sizeof(u32),
  		.align = sizeof(u32),
++<<<<<<< HEAD
 +		.get = fpr_get,
++=======
+ 		.active = fpr_active,
+ 		.regset_get = fpr_get,
++>>>>>>> 759de58f28b1 (arm64: switch to ->regset_get())
  		.set = fpr_set
  	},
  	[REGSET_TLS] = {
@@@ -1235,56 -1174,31 +1177,60 @@@ enum compat_regset 
  	REGSET_COMPAT_VFP,
  };
  
 -static inline compat_ulong_t compat_get_user_reg(struct task_struct *task, int idx)
 -{
 -	struct pt_regs *regs = task_pt_regs(task);
 -
 -	switch (idx) {
 -	case 15:
 -		return regs->pc;
 -	case 16:
 -		return pstate_to_compat_psr(regs->pstate);
 -	case 17:
 -		return regs->orig_x0;
 -	default:
 -		return regs->regs[idx];
 -	}
 -}
 -
  static int compat_gpr_get(struct task_struct *target,
  			  const struct user_regset *regset,
- 			  unsigned int pos, unsigned int count,
- 			  void *kbuf, void __user *ubuf)
+ 			  struct membuf to)
  {
- 	int ret = 0;
- 	unsigned int i, start, num_regs;
+ 	int i = 0;
  
++<<<<<<< HEAD
 +	/* Calculate the number of AArch32 registers contained in count */
 +	num_regs = count / regset->size;
 +
 +	/* Convert pos into an register number */
 +	start = pos / regset->size;
 +
 +	if (start + num_regs > regset->n)
 +		return -EIO;
 +
 +	for (i = 0; i < num_regs; ++i) {
 +		unsigned int idx = start + i;
 +		compat_ulong_t reg;
 +
 +		switch (idx) {
 +		case 15:
 +			reg = task_pt_regs(target)->pc;
 +			break;
 +		case 16:
 +			reg = task_pt_regs(target)->pstate;
 +			break;
 +		case 17:
 +			reg = task_pt_regs(target)->orig_x0;
 +			break;
 +		default:
 +			reg = task_pt_regs(target)->regs[idx];
 +		}
 +
 +		if (kbuf) {
 +			memcpy(kbuf, &reg, sizeof(reg));
 +			kbuf += sizeof(reg);
 +		} else {
 +			ret = copy_to_user(ubuf, &reg, sizeof(reg));
 +			if (ret) {
 +				ret = -EFAULT;
 +				break;
 +			}
 +
 +			ubuf += sizeof(reg);
 +		}
 +	}
 +
 +	return ret;
++=======
+ 	while (to.left)
+ 		membuf_store(&to, compat_get_user_reg(target, i++));
+ 	return 0;
++>>>>>>> 759de58f28b1 (arm64: switch to ->regset_get())
  }
  
  static int compat_gpr_set(struct task_struct *target,
@@@ -1355,8 -1269,10 +1300,7 @@@ static int compat_vfp_get(struct task_s
  {
  	struct user_fpsimd_state *uregs;
  	compat_ulong_t fpscr;
- 	int ret, vregs_end_pos;
  
 -	if (!system_supports_fpsimd())
 -		return -EINVAL;
 -
  	uregs = &target->thread.uw.fpsimd_state;
  
  	if (target == current)
@@@ -1447,7 -1356,8 +1381,12 @@@ static const struct user_regset aarch32
  		.n = VFP_STATE_SIZE / sizeof(compat_ulong_t),
  		.size = sizeof(compat_ulong_t),
  		.align = sizeof(compat_ulong_t),
++<<<<<<< HEAD
 +		.get = compat_vfp_get,
++=======
+ 		.active = fpr_active,
+ 		.regset_get = compat_vfp_get,
++>>>>>>> 759de58f28b1 (arm64: switch to ->regset_get())
  		.set = compat_vfp_set
  	},
  };
* Unmerged path arch/arm64/kernel/ptrace.c
