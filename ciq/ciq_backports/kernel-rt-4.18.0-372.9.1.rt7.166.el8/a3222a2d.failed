net/mlx5e: Allow to match on ICMP parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.9.1.rt7.166.el8
commit-author Maor Dickman <maord@nvidia.com>
commit a3222a2da0a2d6c7682252d4bfdff05721a82b95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.9.1.rt7.166.el8/a3222a2d.failed

Support matching on ICMPv4/6 type and code parameters using misc3
section of match parameters.

	Signed-off-by: Maor Dickman <maord@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a3222a2da0a2d6c7682252d4bfdff05721a82b95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 809b4bb03c8e,54ea0dae7ded..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2040,9 -1961,12 +2040,13 @@@ static int __parse_cls_flower(struct ml
  				    misc_parameters);
  	void *misc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
  				    misc_parameters);
+ 	void *misc_c_3 = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
+ 				    misc_parameters_3);
+ 	void *misc_v_3 = MLX5_ADDR_OF(fte_match_param, spec->match_value,
+ 				    misc_parameters_3);
  	struct flow_rule *rule = flow_cls_offload_flow_rule(f);
  	struct flow_dissector *dissector = rule->match.dissector;
 +	enum fs_flow_table_type fs_type;
  	u16 addr_type = 0;
  	u8 ip_proto = 0;
  	u8 *match_level;
@@@ -2397,27 -2314,49 +2402,72 @@@
  		if (match.mask->flags)
  			*match_level = MLX5_MATCH_L4;
  	}
+ 	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ICMP)) {
+ 		struct flow_match_icmp match;
  
++<<<<<<< HEAD
 +	/* Currenlty supported only for MPLS over UDP */
 +	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_MPLS) &&
 +	    !netif_is_bareudp(filter_dev)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Matching on MPLS is supported only for MPLS over UDP");
 +		netdev_err(priv->netdev,
 +			   "Matching on MPLS is supported only for MPLS over UDP\n");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	/* Currenlty supported only for MPLS over UDP */
 +	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_MPLS) &&
 +	    !netif_is_bareudp(filter_dev)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Matching on MPLS is supported only for MPLS over UDP");
 +		netdev_err(priv->netdev,
 +			   "Matching on MPLS is supported only for MPLS over UDP\n");
 +		return -EOPNOTSUPP;
 +	}
 +
++=======
+ 		flow_rule_match_icmp(rule, &match);
+ 		switch (ip_proto) {
+ 		case IPPROTO_ICMP:
+ 			if (!(MLX5_CAP_GEN(priv->mdev, flex_parser_protocols) &
+ 			      MLX5_FLEX_PROTO_ICMP))
+ 				return -EOPNOTSUPP;
+ 			MLX5_SET(fte_match_set_misc3, misc_c_3, icmp_type,
+ 				 match.mask->type);
+ 			MLX5_SET(fte_match_set_misc3, misc_v_3, icmp_type,
+ 				 match.key->type);
+ 			MLX5_SET(fte_match_set_misc3, misc_c_3, icmp_code,
+ 				 match.mask->code);
+ 			MLX5_SET(fte_match_set_misc3, misc_v_3, icmp_code,
+ 				 match.key->code);
+ 			break;
+ 		case IPPROTO_ICMPV6:
+ 			if (!(MLX5_CAP_GEN(priv->mdev, flex_parser_protocols) &
+ 			      MLX5_FLEX_PROTO_ICMPV6))
+ 				return -EOPNOTSUPP;
+ 			MLX5_SET(fte_match_set_misc3, misc_c_3, icmpv6_type,
+ 				 match.mask->type);
+ 			MLX5_SET(fte_match_set_misc3, misc_v_3, icmpv6_type,
+ 				 match.key->type);
+ 			MLX5_SET(fte_match_set_misc3, misc_c_3, icmpv6_code,
+ 				 match.mask->code);
+ 			MLX5_SET(fte_match_set_misc3, misc_v_3, icmpv6_code,
+ 				 match.key->code);
+ 			break;
+ 		default:
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "Code and type matching only with ICMP and ICMPv6");
+ 			netdev_err(priv->netdev,
+ 				   "Code and type matching only with ICMP and ICMPv6\n");
+ 			return -EINVAL;
+ 		}
+ 		if (match.mask->code || match.mask->type) {
+ 			*match_level = MLX5_MATCH_L4;
+ 			spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_3;
+ 		}
+ 	}
++>>>>>>> a3222a2da0a2 (net/mlx5e: Allow to match on ICMP parameters)
  	return 0;
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h
index dc3d2508f5c6..92a029a800a0 100644
--- a/include/linux/mlx5/device.h
+++ b/include/linux/mlx5/device.h
@@ -1142,6 +1142,8 @@ enum mlx5_flex_parser_protos {
 	MLX5_FLEX_PROTO_GENEVE	      = 1 << 3,
 	MLX5_FLEX_PROTO_CW_MPLS_GRE   = 1 << 4,
 	MLX5_FLEX_PROTO_CW_MPLS_UDP   = 1 << 5,
+	MLX5_FLEX_PROTO_ICMP	      = 1 << 8,
+	MLX5_FLEX_PROTO_ICMPV6	      = 1 << 9,
 };
 
 /* MLX5 DEV CAPs */
