RDMA/mlx5: Delete device resource mutex that didn't protect anything

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 8c9e7f0325fe57ef55bacfa82d10857b4433fef3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8c9e7f03.failed

The dev->devr.mutex was intended to protect GSI QP pointer change in the
struct mlx5_ib_port_resources when it is accessed from the
pkey_change_work. However that pointer isn't changed during the runtime
and once IB/core adds MAD, it stays stable.

Link: https://lore.kernel.org/r/6e338c561033df20d92e1371fc6a7a0d93aad945.1627040189.git.leonro@nvidia.com
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 8c9e7f0325fe57ef55bacfa82d10857b4433fef3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/gsi.c
diff --cc drivers/infiniband/hw/mlx5/gsi.c
index bd398d2fb10c,e549d6fa4a41..000000000000
--- a/drivers/infiniband/hw/mlx5/gsi.c
+++ b/drivers/infiniband/hw/mlx5/gsi.c
@@@ -154,11 -152,19 +152,8 @@@ int mlx5_ib_create_gsi(struct ib_pd *pd
  		ret = PTR_ERR(gsi->rx_qp);
  		goto err_destroy_cq;
  	}
 -	gsi->rx_qp->device = pd->device;
 -	gsi->rx_qp->pd = pd;
 -	gsi->rx_qp->real_qp = gsi->rx_qp;
 -
 -	gsi->rx_qp->qp_type = hw_init_attr.qp_type;
 -	gsi->rx_qp->send_cq = hw_init_attr.send_cq;
 -	gsi->rx_qp->recv_cq = hw_init_attr.recv_cq;
 -	gsi->rx_qp->event_handler = hw_init_attr.event_handler;
 -	spin_lock_init(&gsi->rx_qp->mr_lock);
 -	INIT_LIST_HEAD(&gsi->rx_qp->rdma_mrs);
 -	INIT_LIST_HEAD(&gsi->rx_qp->sig_mrs);
  
  	dev->devr.ports[attr->port_num - 1].gsi = gsi;
- 
- 	mutex_unlock(&dev->devr.mutex);
- 
  	return 0;
  
  err_destroy_cq:
@@@ -179,8 -184,7 +173,12 @@@ int mlx5_ib_destroy_gsi(struct mlx5_ib_
  	int qp_index;
  	int ret;
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->devr.mutex);
 +	ret = ib_destroy_qp(gsi->rx_qp);
++=======
+ 	ret = mlx5_ib_destroy_qp(gsi->rx_qp, NULL);
++>>>>>>> 8c9e7f0325fe (RDMA/mlx5: Delete device resource mutex that didn't protect anything)
  	if (ret) {
  		mlx5_ib_warn(dev, "unable to destroy hardware GSI QP. error %d\n",
  			     ret);
* Unmerged path drivers/infiniband/hw/mlx5/gsi.c
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 6d2d441e7487..c645c2894d44 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -2515,6 +2515,13 @@ static void pkey_change_handler(struct work_struct *work)
 		container_of(work, struct mlx5_ib_port_resources,
 			     pkey_change_work);
 
+	if (!ports->gsi)
+		/*
+		 * We got this event before device was fully configured
+		 * and MAD registration code wasn't called/finished yet.
+		 */
+		return;
+
 	mlx5_ib_gsi_pkey_change(ports->gsi);
 }
 
@@ -2809,8 +2816,6 @@ static int mlx5_ib_dev_res_init(struct mlx5_ib_dev *dev)
 	if (!MLX5_CAP_GEN(dev->mdev, xrc))
 		return -EOPNOTSUPP;
 
-	mutex_init(&devr->mutex);
-
 	devr->p0 = rdma_zalloc_drv_obj(ibdev, ib_pd);
 	if (!devr->p0)
 		return -ENOMEM;
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index d830340b092b..215e2ff2d421 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -788,8 +788,6 @@ struct mlx5_ib_resources {
 	struct ib_srq	*s0;
 	struct ib_srq	*s1;
 	struct mlx5_ib_port_resources ports[2];
-	/* Protects changes to the port resources */
-	struct mutex	mutex;
 };
 
 struct mlx5_ib_counters {
