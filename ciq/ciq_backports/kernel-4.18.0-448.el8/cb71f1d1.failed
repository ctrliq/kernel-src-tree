wifi: mac80211: add sta link addition/removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit cb71f1d136a635decf43c3b502ee34fb05640fcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/cb71f1d1.failed

Add the necessary infrastructure, including a new driver
method, to add/remove links to/from a station. To do this,
refactor the link alloc/free a bit, splitting that so we
can do it without linking them, to handle failures better.

Note that a station entry must be created representing an
MLD or a non-MLD STA, it cannot change between the two.
When representing an MLD, the 'deflink' is used for the
first link, which might be removed later, in which case
the memory isn't reused.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit cb71f1d136a635decf43c3b502ee34fb05640fcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/mac80211.h
#	net/mac80211/driver-ops.h
#	net/mac80211/sta_info.c
#	net/mac80211/sta_info.h
#	net/mac80211/trace.h
diff --cc include/net/mac80211.h
index 7ae1aa619f5c,1bc9d1d9769a..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -2080,19 -2148,24 +2080,34 @@@ struct ieee80211_sta_txpwr 
   * @support_p2p_ps: indicates whether the STA supports P2P PS mechanism or not.
   * @max_rc_amsdu_len: Maximum A-MSDU size in bytes recommended by rate control.
   * @max_tid_amsdu_len: Maximum A-MSDU size in bytes for this TID
 + * @txpwr: the station tx power configuration
   * @txq: per-TID data TX queues (if driver uses the TXQ abstraction); note that
   *	the last entry (%IEEE80211_NUM_TIDS) is used for non-data frames
++<<<<<<< HEAD
++=======
+  * @deflink: This holds the default link STA information, for non MLO STA all link
+  *	specific STA information is accessed through @deflink or through
+  *	link[0] which points to address of @deflink. For MLO Link STA
+  *	the first added link STA will point to deflink.
+  * @link: reference to Link Sta entries. For Non MLO STA, except 1st link,
+  *	i.e link[0] all links would be assigned to NULL by default and
+  *	would access link information via @deflink or link[0]. For MLO
+  *	STA, first link STA being added will point its link pointer to
+  *	@deflink address and remaining would be allocated and the address
+  *	would be assigned to link[link_id] where link_id is the id assigned
+  *	by the AP.
+  * @valid_links: bitmap of valid links, or 0 for non-MLO
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
   */
  struct ieee80211_sta {
 +	u32 supp_rates[NUM_NL80211_BANDS];
  	u8 addr[ETH_ALEN];
  	u16 aid;
 +	struct ieee80211_sta_ht_cap ht_cap;
 +	struct ieee80211_sta_vht_cap vht_cap;
 +	struct ieee80211_sta_he_cap he_cap;
 +	struct ieee80211_he_6ghz_capa he_6ghz_capa;
 +	struct ieee80211_sta_eht_cap eht_cap;
  	u16 max_rx_aggregation_subframes;
  	bool wme;
  	u8 uapsd_queues;
@@@ -2129,6 -2199,10 +2144,13 @@@
  
  	struct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];
  
++<<<<<<< HEAD
++=======
+ 	u16 valid_links;
+ 	struct ieee80211_link_sta deflink;
+ 	struct ieee80211_link_sta *link[IEEE80211_MLD_MAX_NUM_LINKS];
+ 
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  	/* must be last */
  	u8 drv_priv[] __aligned(sizeof(void *));
  };
@@@ -3941,6 -4039,20 +3963,23 @@@ struct ieee80211_prep_tx_info 
   *	radar channel.
   *	The caller is expected to set chandef pointer to NULL in order to
   *	disable background CAC/radar detection.
++<<<<<<< HEAD
++=======
+  * @net_fill_forward_path: Called from .ndo_fill_forward_path in order to
+  *	resolve a path for hardware flow offloading
+  * @change_vif_links: Change the valid links on an interface, note that while
+  *	removing the old link information is still valid (link_conf pointer),
+  *	but may immediately disappear after the function returns. The old or
+  *	new links bitmaps may be 0 if going from/to a non-MLO situation.
+  *	The @old[] array contains pointers to the old bss_conf structures
+  *	that were already removed, in case they're needed.
+  *	This callback can sleep.
+  * @change_sta_links: Change the valid links of a station, similar to
+  *	@change_vif_links. This callback can sleep.
+  *	Note that a sta can also be inserted or removed with valid links,
+  *	i.e. passed to @sta_add/@sta_state with sta->valid_links not zero.
+  *	In fact, cannot change from having valid_links and not having them.
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
   */
  struct ieee80211_ops {
  	void (*tx)(struct ieee80211_hw *hw,
@@@ -4271,6 -4391,19 +4310,22 @@@
  				     struct ieee80211_sta *sta, u8 flowid);
  	int (*set_radar_background)(struct ieee80211_hw *hw,
  				    struct cfg80211_chan_def *chandef);
++<<<<<<< HEAD
++=======
+ 	int (*net_fill_forward_path)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_vif *vif,
+ 				     struct ieee80211_sta *sta,
+ 				     struct net_device_path_ctx *ctx,
+ 				     struct net_device_path *path);
+ 	int (*change_vif_links)(struct ieee80211_hw *hw,
+ 				struct ieee80211_vif *vif,
+ 				u16 old_links, u16 new_links,
+ 				struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);
+ 	int (*change_sta_links)(struct ieee80211_hw *hw,
+ 				struct ieee80211_vif *vif,
+ 				struct ieee80211_sta *sta,
+ 				u16 old_links, u16 new_links);
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  };
  
  /**
diff --cc net/mac80211/driver-ops.h
index 173a201d5e6d,52be89f8f0bc..000000000000
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@@ -1486,4 -1511,68 +1486,71 @@@ static inline void drv_twt_teardown_req
  	trace_drv_return_void(local);
  }
  
++<<<<<<< HEAD
++=======
+ static inline int drv_net_fill_forward_path(struct ieee80211_local *local,
+ 					    struct ieee80211_sub_if_data *sdata,
+ 					    struct ieee80211_sta *sta,
+ 					    struct net_device_path_ctx *ctx,
+ 					    struct net_device_path *path)
+ {
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	sdata = get_bss_sdata(sdata);
+ 	if (!check_sdata_in_driver(sdata))
+ 		return -EIO;
+ 
+ 	trace_drv_net_fill_forward_path(local, sdata, sta);
+ 	if (local->ops->net_fill_forward_path)
+ 		ret = local->ops->net_fill_forward_path(&local->hw,
+ 							&sdata->vif, sta,
+ 							ctx, path);
+ 	trace_drv_return_int(local, ret);
+ 
+ 	return ret;
+ }
+ 
+ static inline int drv_change_vif_links(struct ieee80211_local *local,
+ 				       struct ieee80211_sub_if_data *sdata,
+ 				       u16 old_links, u16 new_links,
+ 				       struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+ {
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	might_sleep();
+ 
+ 	if (!check_sdata_in_driver(sdata))
+ 		return -EIO;
+ 
+ 	trace_drv_change_vif_links(local, sdata, old_links, new_links);
+ 	if (local->ops->change_vif_links)
+ 		ret = local->ops->change_vif_links(&local->hw, &sdata->vif,
+ 						   old_links, new_links, old);
+ 	trace_drv_return_int(local, ret);
+ 
+ 	return ret;
+ }
+ 
+ static inline int drv_change_sta_links(struct ieee80211_local *local,
+ 				       struct ieee80211_sub_if_data *sdata,
+ 				       struct ieee80211_sta *sta,
+ 				       u16 old_links, u16 new_links)
+ {
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	might_sleep();
+ 
+ 	if (!check_sdata_in_driver(sdata))
+ 		return -EIO;
+ 
+ 	trace_drv_change_sta_links(local, sdata, sta, old_links, new_links);
+ 	if (local->ops->change_sta_links)
+ 		ret = local->ops->change_sta_links(&local->hw, &sdata->vif, sta,
+ 						   old_links, new_links);
+ 	trace_drv_return_int(local, ret);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  #endif /* __MAC80211_DRIVER_OPS */
diff --cc net/mac80211/sta_info.c
index f2be4a7c4886,b1426a2459e8..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -245,6 -250,30 +250,33 @@@ struct sta_info *sta_info_get_by_idx(st
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static void sta_info_free_link(struct link_sta_info *link_sta)
+ {
+ 	free_percpu(link_sta->pcpu_rx_stats);
+ }
+ 
+ static void sta_remove_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct sta_link_alloc *alloc = NULL;
+ 
+ 	if (WARN_ON(!sta->link[link_id]))
+ 		return;
+ 
+ 	if (sta->link[link_id] != &sta->deflink)
+ 		alloc = container_of(sta->link[link_id], typeof(*alloc), info);
+ 
+ 	sta->sta.valid_links &= ~BIT(link_id);
+ 	sta->link[link_id] = NULL;
+ 	sta->sta.link[link_id] = NULL;
+ 	if (alloc) {
+ 		sta_info_free_link(&alloc->info);
+ 		kfree(alloc);
+ 	}
+ }
+ 
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  /**
   * sta_info_free - free STA
   *
@@@ -287,7 -325,8 +328,12 @@@ void sta_info_free(struct ieee80211_loc
  #ifdef CONFIG_MAC80211_MESH
  	kfree(sta->mesh);
  #endif
++<<<<<<< HEAD
 +	free_percpu(sta->pcpu_rx_stats);
++=======
+ 
+ 	sta_info_free_link(&sta->deflink);
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  	kfree(sta);
  }
  
@@@ -333,8 -372,44 +379,47 @@@ static int sta_prepare_rate_control(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int sta_info_alloc_link(struct ieee80211_local *local,
+ 			       struct link_sta_info *link_info,
+ 			       gfp_t gfp)
+ {
+ 	struct ieee80211_hw *hw = &local->hw;
+ 	int i;
+ 
+ 	if (ieee80211_hw_check(hw, USES_RSS)) {
+ 		link_info->pcpu_rx_stats =
+ 			alloc_percpu_gfp(struct ieee80211_sta_rx_stats, gfp);
+ 		if (!link_info->pcpu_rx_stats)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	link_info->rx_stats.last_rx = jiffies;
+ 	u64_stats_init(&link_info->rx_stats.syncp);
+ 
+ 	ewma_signal_init(&link_info->rx_stats_avg.signal);
+ 	ewma_avg_signal_init(&link_info->status_stats.avg_ack_signal);
+ 	for (i = 0; i < ARRAY_SIZE(link_info->rx_stats_avg.chain_signal); i++)
+ 		ewma_signal_init(&link_info->rx_stats_avg.chain_signal[i]);
+ 
+ 	return 0;
+ }
+ 
+ static void sta_info_add_link(struct sta_info *sta,
+ 			      unsigned int link_id,
+ 			      struct link_sta_info *link_info,
+ 			      struct ieee80211_link_sta *link_sta)
+ {
+ 	link_info->sta = sta;
+ 	link_info->link_id = link_id;
+ 	sta->link[link_id] = link_info;
+ 	sta->sta.link[link_id] = link_sta;
+ }
+ 
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
- 				const u8 *addr, gfp_t gfp)
+ 				const u8 *addr, int link_id, gfp_t gfp)
  {
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_hw *hw = &local->hw;
@@@ -345,12 -420,19 +430,28 @@@
  	if (!sta)
  		return NULL;
  
++<<<<<<< HEAD
 +	if (ieee80211_hw_check(hw, USES_RSS)) {
 +		sta->pcpu_rx_stats =
 +			alloc_percpu_gfp(struct ieee80211_sta_rx_stats, gfp);
 +		if (!sta->pcpu_rx_stats)
 +			goto free;
 +	}
++=======
+ 	sta->local = local;
+ 	sta->sdata = sdata;
+ 
+ 	if (sta_info_alloc_link(local, &sta->deflink, gfp))
+ 		return NULL;
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
+ 
+ 	if (link_id >= 0) {
+ 		sta_info_add_link(sta, link_id, &sta->deflink,
+ 				  &sta->sta.deflink);
+ 		sta->sta.valid_links = BIT(link_id);
+ 	} else {
+ 		sta_info_add_link(sta, 0, &sta->deflink, &sta->sta.deflink);
+ 	}
  
  	spin_lock_init(&sta->lock);
  	spin_lock_init(&sta->ps_lock);
@@@ -524,7 -599,7 +625,11 @@@ free_txq
  	if (sta->sta.txq[0])
  		kfree(to_txq_info(sta->sta.txq[0]));
  free:
++<<<<<<< HEAD
 +	free_percpu(sta->pcpu_rx_stats);
++=======
+ 	sta_info_free_link(&sta->deflink);
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  #ifdef CONFIG_MAC80211_MESH
  	kfree(sta->mesh);
  #endif
diff --cc net/mac80211/sta_info.h
index addc78b398f0,8ec65bb7d13e..000000000000
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@@ -543,30 -622,18 +543,44 @@@ struct ieee80211_fragment_cache 
   * @fast_rx: RX fastpath information
   * @tdls_chandef: a TDLS peer can have a wider chandef that is compatible to
   *	the BSS one.
 + * @tx_stats: TX statistics
 + * @tx_stats.packets: # of packets transmitted
 + * @tx_stats.bytes: # of bytes in all packets transmitted
 + * @tx_stats.last_rate: last TX rate
 + * @tx_stats.msdu: # of transmitted MSDUs per TID
 + * @rx_stats: RX statistics
 + * @rx_stats_avg: averaged RX statistics
 + * @rx_stats_avg.signal: averaged signal
 + * @rx_stats_avg.chain_signal: averaged per-chain signal
 + * @pcpu_rx_stats: per-CPU RX statistics, assigned only if the driver needs
 + *	this (by advertising the USES_RSS hw flag)
 + * @status_stats: TX status statistics
 + * @status_stats.filtered: # of filtered frames
 + * @status_stats.retry_failed: # of frames that failed after retry
 + * @status_stats.retry_count: # of retries attempted
 + * @status_stats.lost_packets: # of lost packets
 + * @status_stats.last_pkt_time: timestamp of last ACKed packet
 + * @status_stats.msdu_retries: # of MSDU retries
 + * @status_stats.msdu_failed: # of failed MSDUs
 + * @status_stats.last_ack: last ack timestamp (jiffies)
 + * @status_stats.last_ack_signal: last ACK signal
 + * @status_stats.ack_signal_filled: last ACK signal validity
 + * @status_stats.avg_ack_signal: average ACK signal
   * @frags: fragment cache
++<<<<<<< HEAD
++=======
+  * @deflink: This is the default link STA information, for non MLO STA all link
+  *	specific STA information is accessed through @deflink or through
+  *	link[0] which points to address of @deflink. For MLO Link STA
+  *	the first added link STA will point to deflink.
+  * @link: reference to Link Sta entries. For Non MLO STA, except 1st link,
+  *	i.e link[0] all links would be assigned to NULL by default and
+  *	would access link information via @deflink or link[0]. For MLO
+  *	STA, first link STA being added will point its link pointer to
+  *	@deflink address and remaining would be allocated and the address
+  *	would be assigned to link[link_id] where link_id is the id assigned
+  *	by the AP.
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
   */
  struct sta_info {
  	/* General information, mostly static */
@@@ -675,6 -707,9 +689,12 @@@
  
  	struct ieee80211_fragment_cache frags;
  
++<<<<<<< HEAD
++=======
+ 	struct link_sta_info deflink;
+ 	struct link_sta_info *link[IEEE80211_MLD_MAX_NUM_LINKS];
+ 
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  	/* keep last! */
  	struct ieee80211_sta sta;
  };
@@@ -854,8 -889,11 +874,12 @@@ u32 sta_get_expected_throughput(struct 
  
  void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
  			  unsigned long exp_time);
 +u8 sta_info_tx_streams(struct sta_info *sta);
  
+ int ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id);
+ int ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id);
+ void ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id);
+ 
  void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta);
  void ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta);
  void ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta);
diff --cc net/mac80211/trace.h
index 17e7760d8348,9804634e7d99..000000000000
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@@ -1972,6 -2018,501 +1972,504 @@@ DEFINE_EVENT(local_sdata_evt, drv_abort
  	TP_ARGS(local, sdata)
  );
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(drv_set_default_unicast_key,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 int key_idx),
+ 
+ 	TP_ARGS(local, sdata, key_idx),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(int, key_idx)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->key_idx = key_idx;
+ 	),
+ 
+ 	TP_printk(LOCAL_PR_FMT VIF_PR_FMT " key_idx:%d",
+ 		  LOCAL_PR_ARG, VIF_PR_ARG, __entry->key_idx)
+ );
+ 
+ TRACE_EVENT(drv_channel_switch_beacon,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct cfg80211_chan_def *chandef),
+ 
+ 	TP_ARGS(local, sdata, chandef),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		CHANDEF_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		CHANDEF_ASSIGN(chandef);
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " channel switch to " CHANDEF_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_pre_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_channel_switch *ch_switch),
+ 
+ 	TP_ARGS(local, sdata, ch_switch),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		CHANDEF_ENTRY
+ 		__field(u64, timestamp)
+ 		__field(u32, device_timestamp)
+ 		__field(bool, block_tx)
+ 		__field(u8, count)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		CHANDEF_ASSIGN(&ch_switch->chandef)
+ 		__entry->timestamp = ch_switch->timestamp;
+ 		__entry->device_timestamp = ch_switch->device_timestamp;
+ 		__entry->block_tx = ch_switch->block_tx;
+ 		__entry->count = ch_switch->count;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " prepare channel switch to "
+ 		CHANDEF_PR_FMT  " count:%d block_tx:%d timestamp:%llu",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->count,
+ 		__entry->block_tx, __entry->timestamp
+ 	)
+ );
+ 
+ DEFINE_EVENT(local_sdata_evt, drv_post_channel_switch,
+ 	     TP_PROTO(struct ieee80211_local *local,
+ 		      struct ieee80211_sub_if_data *sdata),
+ 	     TP_ARGS(local, sdata)
+ );
+ 
+ DEFINE_EVENT(local_sdata_evt, drv_abort_channel_switch,
+ 	     TP_PROTO(struct ieee80211_local *local,
+ 		      struct ieee80211_sub_if_data *sdata),
+ 	     TP_ARGS(local, sdata)
+ );
+ 
+ TRACE_EVENT(drv_channel_switch_rx_beacon,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_channel_switch *ch_switch),
+ 
+ 	TP_ARGS(local, sdata, ch_switch),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		CHANDEF_ENTRY
+ 		__field(u64, timestamp)
+ 		__field(u32, device_timestamp)
+ 		__field(bool, block_tx)
+ 		__field(u8, count)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		CHANDEF_ASSIGN(&ch_switch->chandef)
+ 		__entry->timestamp = ch_switch->timestamp;
+ 		__entry->device_timestamp = ch_switch->device_timestamp;
+ 		__entry->block_tx = ch_switch->block_tx;
+ 		__entry->count = ch_switch->count;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT
+ 		" received a channel switch beacon to "
+ 		CHANDEF_PR_FMT  " count:%d block_tx:%d timestamp:%llu",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->count,
+ 		__entry->block_tx, __entry->timestamp
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_get_txpower,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 int dbm, int ret),
+ 
+ 	TP_ARGS(local, sdata, dbm, ret),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(int, dbm)
+ 		__field(int, ret)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->dbm = dbm;
+ 		__entry->ret = ret;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " dbm:%d ret:%d",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->dbm, __entry->ret
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_tdls_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, u8 oper_class,
+ 		 struct cfg80211_chan_def *chandef),
+ 
+ 	TP_ARGS(local, sdata, sta, oper_class, chandef),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, oper_class)
+ 		CHANDEF_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->oper_class = oper_class;
+ 		CHANDEF_ASSIGN(chandef)
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " tdls channel switch to"
+ 		CHANDEF_PR_FMT  " oper_class:%d " STA_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->oper_class,
+ 		STA_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_tdls_cancel_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta),
+ 
+ 	TP_ARGS(local, sdata, sta),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT
+ 		" tdls cancel channel switch with " STA_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_tdls_recv_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_tdls_ch_sw_params *params),
+ 
+ 	TP_ARGS(local, sdata, params),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(u8, action_code)
+ 		STA_ENTRY
+ 		CHANDEF_ENTRY
+ 		__field(u32, status)
+ 		__field(bool, peer_initiator)
+ 		__field(u32, timestamp)
+ 		__field(u16, switch_time)
+ 		__field(u16, switch_timeout)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_NAMED_ASSIGN(params->sta);
+ 		CHANDEF_ASSIGN(params->chandef)
+ 		__entry->peer_initiator = params->sta->tdls_initiator;
+ 		__entry->action_code = params->action_code;
+ 		__entry->status = params->status;
+ 		__entry->timestamp = params->timestamp;
+ 		__entry->switch_time = params->switch_time;
+ 		__entry->switch_timeout = params->switch_timeout;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " received tdls channel switch packet"
+ 		" action:%d status:%d time:%d switch time:%d switch"
+ 		" timeout:%d initiator: %d chan:" CHANDEF_PR_FMT STA_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->action_code, __entry->status,
+ 		__entry->timestamp, __entry->switch_time,
+ 		__entry->switch_timeout, __entry->peer_initiator,
+ 		CHANDEF_PR_ARG, STA_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_wake_tx_queue,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct txq_info *txq),
+ 
+ 	TP_ARGS(local, sdata, txq),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, ac)
+ 		__field(u8, tid)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		struct ieee80211_sta *sta = txq->txq.sta;
+ 
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->ac = txq->txq.ac;
+ 		__entry->tid = txq->txq.tid;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " ac:%d tid:%d",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->ac, __entry->tid
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_get_ftm_responder_stats,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct cfg80211_ftm_responder_stats *ftm_stats),
+ 
+ 	TP_ARGS(local, sdata, ftm_stats),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG
+ 	)
+ );
+ 
+ DEFINE_EVENT(local_sdata_addr_evt, drv_update_vif_offload,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata),
+ 	TP_ARGS(local, sdata)
+ );
+ 
+ DECLARE_EVENT_CLASS(sta_flag_evt,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, bool enabled),
+ 
+ 	TP_ARGS(local, sdata, sta, enabled),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(bool, enabled)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->enabled = enabled;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " enabled:%d",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->enabled
+ 	)
+ );
+ 
+ DEFINE_EVENT(sta_flag_evt, drv_sta_set_4addr,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, bool enabled),
+ 
+ 	TP_ARGS(local, sdata, sta, enabled)
+ );
+ 
+ DEFINE_EVENT(sta_flag_evt, drv_sta_set_decap_offload,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, bool enabled),
+ 
+ 	TP_ARGS(local, sdata, sta, enabled)
+ );
+ 
+ TRACE_EVENT(drv_add_twt_setup,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sta *sta,
+ 		 struct ieee80211_twt_setup *twt,
+ 		 struct ieee80211_twt_params *twt_agrt),
+ 
+ 	TP_ARGS(local, sta, twt, twt_agrt),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, dialog_token)
+ 		__field(u8, control)
+ 		__field(__le16, req_type)
+ 		__field(__le64, twt)
+ 		__field(u8, duration)
+ 		__field(__le16, mantissa)
+ 		__field(u8, channel)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->dialog_token = twt->dialog_token;
+ 		__entry->control = twt->control;
+ 		__entry->req_type = twt_agrt->req_type;
+ 		__entry->twt = twt_agrt->twt;
+ 		__entry->duration = twt_agrt->min_twt_dur;
+ 		__entry->mantissa = twt_agrt->mantissa;
+ 		__entry->channel = twt_agrt->channel;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT STA_PR_FMT
+ 		" token:%d control:0x%02x req_type:0x%04x"
+ 		" twt:%llu duration:%d mantissa:%d channel:%d",
+ 		LOCAL_PR_ARG, STA_PR_ARG, __entry->dialog_token,
+ 		__entry->control, le16_to_cpu(__entry->req_type),
+ 		le64_to_cpu(__entry->twt), __entry->duration,
+ 		le16_to_cpu(__entry->mantissa), __entry->channel
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_twt_teardown_request,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sta *sta, u8 flowid),
+ 
+ 	TP_ARGS(local, sta, flowid),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, flowid)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->flowid = flowid;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT STA_PR_FMT " flowid:%d",
+ 		LOCAL_PR_ARG, STA_PR_ARG, __entry->flowid
+ 	)
+ );
+ 
+ DEFINE_EVENT(sta_event, drv_net_fill_forward_path,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta),
+ 	TP_ARGS(local, sdata, sta)
+ );
+ 
+ TRACE_EVENT(drv_change_vif_links,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 u16 old_links, u16 new_links),
+ 
+ 	TP_ARGS(local, sdata, old_links, new_links),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(u16, old_links)
+ 		__field(u16, new_links)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->old_links = old_links;
+ 		__entry->new_links = new_links;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " old_links:0x%04x, new_links:0x%04x\n",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->old_links, __entry->new_links
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_change_sta_links,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta,
+ 		 u16 old_links, u16 new_links),
+ 
+ 	TP_ARGS(local, sdata, sta, old_links, new_links),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(u16, old_links)
+ 		__field(u16, new_links)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->old_links = old_links;
+ 		__entry->new_links = new_links;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT STA_PR_FMT " old_links:0x%04x, new_links:0x%04x\n",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG,
+ 		__entry->old_links, __entry->new_links
+ 	)
+ );
+ 
++>>>>>>> cb71f1d136a6 (wifi: mac80211: add sta link addition/removal)
  /*
   * Tracing for API calls that drivers call.
   */
* Unmerged path include/net/mac80211.h
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f7b5957d466a..980090e786ea 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1818,7 +1818,7 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 	    !sdata->u.mgd.associated)
 		return -EINVAL;
 
-	sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
+	sta = sta_info_alloc(sdata, mac, -1, GFP_KERNEL);
 	if (!sta)
 		return -ENOMEM;
 
* Unmerged path net/mac80211/driver-ops.h
diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c
index cfd5e16e19ac..46a4e485f4eb 100644
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@ -629,7 +629,7 @@ ieee80211_ibss_add_sta(struct ieee80211_sub_if_data *sdata, const u8 *bssid,
 	scan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);
 	rcu_read_unlock();
 
-	sta = sta_info_alloc(sdata, addr, GFP_KERNEL);
+	sta = sta_info_alloc(sdata, addr, -1, GFP_KERNEL);
 	if (!sta) {
 		rcu_read_lock();
 		return NULL;
@@ -1229,7 +1229,7 @@ void ieee80211_ibss_rx_no_sta(struct ieee80211_sub_if_data *sdata,
 	scan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);
 	rcu_read_unlock();
 
-	sta = sta_info_alloc(sdata, addr, GFP_ATOMIC);
+	sta = sta_info_alloc(sdata, addr, -1, GFP_ATOMIC);
 	if (!sta)
 		return;
 
diff --git a/net/mac80211/mesh_plink.c b/net/mac80211/mesh_plink.c
index a829470dd59e..c0f141887991 100644
--- a/net/mac80211/mesh_plink.c
+++ b/net/mac80211/mesh_plink.c
@@ -510,7 +510,7 @@ __mesh_sta_info_alloc(struct ieee80211_sub_if_data *sdata, u8 *hw_addr)
 	if (aid < 0)
 		return NULL;
 
-	sta = sta_info_alloc(sdata, hw_addr, GFP_KERNEL);
+	sta = sta_info_alloc(sdata, hw_addr, -1, GFP_KERNEL);
 	if (!sta)
 		return NULL;
 
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index dbd8b816487b..f6fefbb104bc 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -5572,7 +5572,7 @@ static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 	}
 
 	if (!have_sta) {
-		new_sta = sta_info_alloc(sdata, cbss->bssid, GFP_KERNEL);
+		new_sta = sta_info_alloc(sdata, cbss->bssid, -1, GFP_KERNEL);
 		if (!new_sta)
 			return -ENOMEM;
 	}
diff --git a/net/mac80211/ocb.c b/net/mac80211/ocb.c
index 1b28b4d92936..5283bbc2a8c5 100644
--- a/net/mac80211/ocb.c
+++ b/net/mac80211/ocb.c
@@ -69,7 +69,7 @@ void ieee80211_ocb_rx_no_sta(struct ieee80211_sub_if_data *sdata,
 	scan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);
 	rcu_read_unlock();
 
-	sta = sta_info_alloc(sdata, addr, GFP_ATOMIC);
+	sta = sta_info_alloc(sdata, addr, -1, GFP_ATOMIC);
 	if (!sta)
 		return;
 
* Unmerged path net/mac80211/sta_info.c
* Unmerged path net/mac80211/sta_info.h
* Unmerged path net/mac80211/trace.h
