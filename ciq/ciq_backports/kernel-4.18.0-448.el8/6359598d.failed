wifi: mac80211: split IEEE80211_STA_DISABLE_WMM to link data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 6359598df67fe7d4d335298f50a23cb55dd1547b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6359598d.failed

If we decide to stop tracking QoS/WMM parameters, then
this should be a per-link decision. Move the flag to
the link instead.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 6359598df67fe7d4d335298f50a23cb55dd1547b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ieee80211_i.h
#	net/mac80211/mlme.c
diff --cc net/mac80211/ieee80211_i.h
index 9f2fe5f6d317,3e360bcaa03b..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -361,16 -361,20 +361,19 @@@ enum ieee80211_sta_flags 
  	IEEE80211_STA_MFP_ENABLED	= BIT(6),
  	IEEE80211_STA_UAPSD_ENABLED	= BIT(7),
  	IEEE80211_STA_NULLFUNC_ACKED	= BIT(8),
++<<<<<<< HEAD
 +	IEEE80211_STA_RESET_SIGNAL_AVE	= BIT(9),
 +	IEEE80211_STA_DISABLE_40MHZ	= BIT(10),
 +	IEEE80211_STA_DISABLE_VHT	= BIT(11),
 +	IEEE80211_STA_DISABLE_80P80MHZ	= BIT(12),
 +	IEEE80211_STA_DISABLE_160MHZ	= BIT(13),
 +	IEEE80211_STA_DISABLE_WMM	= BIT(14),
++=======
++>>>>>>> 6359598df67f (wifi: mac80211: split IEEE80211_STA_DISABLE_WMM to link data)
  	IEEE80211_STA_ENABLE_RRM	= BIT(15),
 -};
 -
 -typedef u32 __bitwise ieee80211_conn_flags_t;
 -
 -enum ieee80211_conn_flags {
 -	IEEE80211_CONN_DISABLE_HT	= (__force ieee80211_conn_flags_t)BIT(0),
 -	IEEE80211_CONN_DISABLE_40MHZ	= (__force ieee80211_conn_flags_t)BIT(1),
 -	IEEE80211_CONN_DISABLE_VHT	= (__force ieee80211_conn_flags_t)BIT(2),
 -	IEEE80211_CONN_DISABLE_80P80MHZ	= (__force ieee80211_conn_flags_t)BIT(3),
 -	IEEE80211_CONN_DISABLE_160MHZ	= (__force ieee80211_conn_flags_t)BIT(4),
 -	IEEE80211_CONN_DISABLE_HE	= (__force ieee80211_conn_flags_t)BIT(5),
 -	IEEE80211_CONN_DISABLE_EHT	= (__force ieee80211_conn_flags_t)BIT(6),
 -	IEEE80211_CONN_DISABLE_320MHZ	= (__force ieee80211_conn_flags_t)BIT(7),
 +	IEEE80211_STA_DISABLE_HE	= BIT(16),
 +	IEEE80211_STA_DISABLE_EHT	= BIT(17),
 +	IEEE80211_STA_DISABLE_320MHZ	= BIT(18),
  };
  
  struct ieee80211_mgd_auth_data {
@@@ -903,6 -869,111 +906,114 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	ieee80211_conn_flags_t conn_flags;
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool have_beacon;
+ 	bool tracking_signal_avg;
+ 	bool disable_wmm_tracking;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 	struct timer_list chswitch_timer;
+ 	struct work_struct chswitch_work;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ 
+ 	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
+ 
+ 	struct ieee80211_bss_conf *conf;
+ };
+ 
++>>>>>>> 6359598df67f (wifi: mac80211: split IEEE80211_STA_DISABLE_WMM to link data)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
diff --cc net/mac80211/mlme.c
index 6cd411ed25d6,918f095950f0..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -2508,24 -2533,27 +2508,30 @@@ static void ieee80211_set_disassoc(stru
  	del_timer_sync(&sdata->u.mgd.conn_mon_timer);
  	del_timer_sync(&sdata->u.mgd.bcn_mon_timer);
  	del_timer_sync(&sdata->u.mgd.timer);
 -	del_timer_sync(&link->u.mgd.chswitch_timer);
 +	del_timer_sync(&sdata->u.mgd.chswitch_timer);
  
 -	link->conf->dtim_period = 0;
 -	link->conf->beacon_rate = NULL;
 +	sdata->vif.bss_conf.dtim_period = 0;
 +	sdata->vif.bss_conf.beacon_rate = NULL;
  
++<<<<<<< HEAD
 +	ifmgd->have_beacon = false;
++=======
+ 	link->u.mgd.have_beacon = false;
+ 	link->u.mgd.tracking_signal_avg = false;
+ 	link->u.mgd.disable_wmm_tracking = false;
++>>>>>>> 6359598df67f (wifi: mac80211: split IEEE80211_STA_DISABLE_WMM to link data)
  
  	ifmgd->flags = 0;
 -	link->u.mgd.conn_flags = 0;
  	mutex_lock(&local->mtx);
 -	ieee80211_link_release_channel(link);
 +	ieee80211_vif_release_channel(sdata);
  
 -	link->conf->csa_active = false;
 -	link->u.mgd.csa_waiting_bcn = false;
 -	link->u.mgd.csa_ignored_same_chan = false;
 -	if (link->csa_block_tx) {
 +	sdata->vif.bss_conf.csa_active = false;
 +	ifmgd->csa_waiting_bcn = false;
 +	ifmgd->csa_ignored_same_chan = false;
 +	if (sdata->csa_block_tx) {
  		ieee80211_wake_vif_queues(local, sdata,
  					  IEEE80211_QUEUE_STOP_REASON_CSA);
 -		link->csa_block_tx = false;
 +		sdata->csa_block_tx = false;
  	}
  	mutex_unlock(&local->mtx);
  
@@@ -3750,17 -3793,17 +3756,28 @@@ static bool ieee80211_assoc_success(str
  	 * that effect because the AP values is an unsigned
  	 * 4-bit value.
  	 */
 -	link->u.mgd.wmm_last_param_set = -1;
 -	link->u.mgd.mu_edca_last_param_set = -1;
 +	ifmgd->wmm_last_param_set = -1;
 +	ifmgd->mu_edca_last_param_set = -1;
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_WMM) {
 +		ieee80211_set_wmm_default(sdata, false, false);
 +	} else if (!ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
 +					     elems->wmm_param_len,
 +					     elems->mu_edca_param_set)) {
 +		/* still enable QoS since we might have HT/VHT */
 +		ieee80211_set_wmm_default(sdata, false, true);
 +		/* set the disable-WMM flag in this case to disable
++=======
+ 	if (link->u.mgd.disable_wmm_tracking) {
+ 		ieee80211_set_wmm_default(link, false, false);
+ 	} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 					     elems->wmm_param_len,
+ 					     elems->mu_edca_param_set)) {
+ 		/* still enable QoS since we might have HT/VHT */
+ 		ieee80211_set_wmm_default(link, false, true);
+ 		/* disable WMM tracking in this case to disable
++>>>>>>> 6359598df67f (wifi: mac80211: split IEEE80211_STA_DISABLE_WMM to link data)
  		 * tracking WMM parameter changes in the beacon if
  		 * the parameters weren't actually valid. Doing so
  		 * avoids changing parameters very strangely when
@@@ -4348,8 -4398,8 +4365,13 @@@ static void ieee80211_rx_mgmt_beacon(st
  					 rx_status->device_timestamp,
  					 elems, true);
  
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_WMM) &&
 +	    ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
++=======
+ 	if (!link->u.mgd.disable_wmm_tracking &&
+ 	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
++>>>>>>> 6359598df67f (wifi: mac80211: split IEEE80211_STA_DISABLE_WMM to link data)
  				     elems->wmm_param_len,
  				     elems->mu_edca_param_set))
  		changed |= BSS_CHANGED_QOS;
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/mlme.c
