net/mlx5e: CT, Remove redundant flow args from tc ct calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit a572c0a748e6f7e04fb56d65139edbece4cb113d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a572c0a7.failed

The flow arg is not being used so remove it.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a572c0a748e6f7e04fb56d65139edbece4cb113d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index bdde5fe4e17e,0f4d3b9dd979..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@@ -1886,71 -1923,8 +1885,70 @@@ err_ft
  	return ERR_PTR(err);
  }
  
 +static struct mlx5_flow_handle *
 +__mlx5_tc_ct_flow_offload_clear(struct mlx5_tc_ct_priv *ct_priv,
 +				struct mlx5_flow_spec *orig_spec,
 +				struct mlx5_flow_attr *attr,
 +				struct mlx5e_tc_mod_hdr_acts *mod_acts)
 +{
 +	struct mlx5e_priv *priv = netdev_priv(ct_priv->netdev);
 +	u32 attr_sz = ns_to_attr_sz(ct_priv->ns_type);
 +	struct mlx5_flow_attr *pre_ct_attr;
 +	struct mlx5_modify_hdr *mod_hdr;
 +	struct mlx5_flow_handle *rule;
 +	struct mlx5_ct_flow *ct_flow;
 +	int err;
 +
 +	ct_flow = kzalloc(sizeof(*ct_flow), GFP_KERNEL);
 +	if (!ct_flow)
 +		return ERR_PTR(-ENOMEM);
 +
 +	/* Base esw attributes on original rule attribute */
 +	pre_ct_attr = mlx5_alloc_flow_attr(ct_priv->ns_type);
 +	if (!pre_ct_attr) {
 +		err = -ENOMEM;
 +		goto err_attr;
 +	}
 +
 +	memcpy(pre_ct_attr, attr, attr_sz);
 +
 +	mod_hdr = mlx5_modify_header_alloc(priv->mdev, ct_priv->ns_type,
 +					   mod_acts->num_actions,
 +					   mod_acts->actions);
 +	if (IS_ERR(mod_hdr)) {
 +		err = PTR_ERR(mod_hdr);
 +		ct_dbg("Failed to add create ct clear mod hdr");
 +		goto err_mod_hdr;
 +	}
 +
 +	pre_ct_attr->modify_hdr = mod_hdr;
 +
 +	rule = mlx5_tc_rule_insert(priv, orig_spec, pre_ct_attr);
 +	if (IS_ERR(rule)) {
 +		err = PTR_ERR(rule);
 +		ct_dbg("Failed to add ct clear rule");
 +		goto err_insert;
 +	}
 +
 +	attr->ct_attr.ct_flow = ct_flow;
 +	ct_flow->pre_ct_attr = pre_ct_attr;
 +	ct_flow->pre_ct_rule = rule;
 +	return rule;
 +
 +err_insert:
 +	mlx5_modify_header_dealloc(priv->mdev, mod_hdr);
 +err_mod_hdr:
 +	netdev_warn(priv->netdev,
 +		    "Failed to offload ct clear flow, err %d\n", err);
 +	kfree(pre_ct_attr);
 +err_attr:
 +	kfree(ct_flow);
 +
 +	return ERR_PTR(err);
 +}
 +
  struct mlx5_flow_handle *
  mlx5_tc_ct_flow_offload(struct mlx5_tc_ct_priv *priv,
- 			struct mlx5e_tc_flow *flow,
  			struct mlx5_flow_spec *spec,
  			struct mlx5_flow_attr *attr,
  			struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts)
@@@ -1962,11 -1935,7 +1960,15 @@@
  		return ERR_PTR(-EOPNOTSUPP);
  
  	mutex_lock(&priv->control_lock);
++<<<<<<< HEAD
 +
 +	if (clear_action)
 +		rule = __mlx5_tc_ct_flow_offload_clear(priv, spec, attr, mod_hdr_acts);
 +	else
 +		rule = __mlx5_tc_ct_flow_offload(priv, flow, spec, attr);
++=======
+ 	rule = __mlx5_tc_ct_flow_offload(priv, spec, attr);
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  	mutex_unlock(&priv->control_lock);
  
  	return rule;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
index b689701ac7d8,9ffba584b982..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
@@@ -107,6 -111,16 +107,19 @@@ struct mlx5e_tc_flow 
  	struct mlx5_flow_attr *attr;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_handle *
+ mlx5e_tc_rule_offload(struct mlx5e_priv *priv,
+ 		      struct mlx5_flow_spec *spec,
+ 		      struct mlx5_flow_attr *attr);
+ 
+ void
+ mlx5e_tc_rule_unoffload(struct mlx5e_priv *priv,
+ 			struct mlx5_flow_handle *rule,
+ 			struct mlx5_flow_attr *attr);
+ 
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  u8 mlx5e_tc_get_ip_version(struct mlx5_flow_spec *spec, bool outer);
  
  struct mlx5_flow_handle *
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e11d6f95f302,1287193a019b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -309,6 -301,56 +309,59 @@@ mlx5_tc_rule_delete(struct mlx5e_priv *
  	mlx5e_del_offloaded_nic_rule(priv, rule, attr);
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_handle *
+ mlx5e_tc_rule_offload(struct mlx5e_priv *priv,
+ 		      struct mlx5_flow_spec *spec,
+ 		      struct mlx5_flow_attr *attr)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 
+ 	if (attr->flags & MLX5_ATTR_FLAG_CT) {
+ 		struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts =
+ 			&attr->parse_attr->mod_hdr_acts;
+ 
+ 		return mlx5_tc_ct_flow_offload(get_ct_priv(priv),
+ 					       spec, attr,
+ 					       mod_hdr_acts);
+ 	}
+ 
+ 	if (!is_mdev_switchdev_mode(priv->mdev))
+ 		return mlx5e_add_offloaded_nic_rule(priv, spec, attr);
+ 
+ 	if (attr->flags & MLX5_ATTR_FLAG_SAMPLE)
+ 		return mlx5e_tc_sample_offload(get_sample_priv(priv), spec, attr);
+ 
+ 	return mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
+ }
+ 
+ void
+ mlx5e_tc_rule_unoffload(struct mlx5e_priv *priv,
+ 			struct mlx5_flow_handle *rule,
+ 			struct mlx5_flow_attr *attr)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 
+ 	if (attr->flags & MLX5_ATTR_FLAG_CT) {
+ 		mlx5_tc_ct_delete_flow(get_ct_priv(priv), attr);
+ 		return;
+ 	}
+ 
+ 	if (!is_mdev_switchdev_mode(priv->mdev)) {
+ 		mlx5e_del_offloaded_nic_rule(priv, rule, attr);
+ 		return;
+ 	}
+ 
+ 	if (attr->flags & MLX5_ATTR_FLAG_SAMPLE) {
+ 		mlx5e_tc_sample_unoffload(get_sample_priv(priv), rule, attr);
+ 		return;
+ 	}
+ 
+ 	mlx5_eswitch_del_offloaded_rule(esw, rule, attr);
+ }
+ 
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  int
  mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
  			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
@@@ -1091,8 -1133,8 +1144,13 @@@ mlx5e_tc_add_nic_flow(struct mlx5e_pri
  			return err;
  	}
  
++<<<<<<< HEAD
 +	if (flow_flag_test(flow, CT))
 +		flow->rule[0] = mlx5_tc_ct_flow_offload(get_ct_priv(priv), flow, &parse_attr->spec,
++=======
+ 	if (attr->flags & MLX5_ATTR_FLAG_CT)
+ 		flow->rule[0] = mlx5_tc_ct_flow_offload(get_ct_priv(priv), &parse_attr->spec,
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  							attr, &parse_attr->mod_hdr_acts);
  	else
  		flow->rule[0] = mlx5e_add_offloaded_nic_rule(priv, &parse_attr->spec,
@@@ -1126,8 -1168,8 +1184,13 @@@ static void mlx5e_tc_del_nic_flow(struc
  
  	flow_flag_clear(flow, OFFLOADED);
  
++<<<<<<< HEAD
 +	if (flow_flag_test(flow, CT))
 +		mlx5_tc_ct_delete_flow(get_ct_priv(flow->priv), flow, attr);
++=======
+ 	if (attr->flags & MLX5_ATTR_FLAG_CT)
+ 		mlx5_tc_ct_delete_flow(get_ct_priv(flow->priv), attr);
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  	else if (!IS_ERR_OR_NULL(flow->rule[0]))
  		mlx5e_del_offloaded_nic_rule(priv, flow->rule[0], attr);
  
@@@ -1161,26 -1203,12 +1224,30 @@@ mlx5e_tc_offload_fdb_rules(struct mlx5_
  			   struct mlx5_flow_spec *spec,
  			   struct mlx5_flow_attr *attr)
  {
 +	struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts;
  	struct mlx5_flow_handle *rule;
  
 -	if (attr->flags & MLX5_ATTR_FLAG_SLOW_PATH)
 +	if (attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH)
  		return mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
  
++<<<<<<< HEAD
 +	if (flow_flag_test(flow, CT)) {
 +		mod_hdr_acts = &attr->parse_attr->mod_hdr_acts;
 +
 +		rule = mlx5_tc_ct_flow_offload(get_ct_priv(flow->priv),
 +					       flow, spec, attr,
 +					       mod_hdr_acts);
 +#if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
 +	} else if (flow_flag_test(flow, SAMPLE)) {
 +		rule = mlx5e_tc_sample_offload(get_sample_priv(flow->priv), spec, attr,
 +					       mlx5e_tc_get_flow_tun_id(flow));
 +#endif
 +	} else {
 +		rule = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
 +	}
++=======
+ 	rule = mlx5e_tc_rule_offload(flow->priv, spec, attr);
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  
  	if (IS_ERR(rule))
  		return rule;
@@@ -1197,6 -1220,10 +1264,13 @@@
  	}
  
  	return rule;
++<<<<<<< HEAD
++=======
+ 
+ err_rule1:
+ 	mlx5e_tc_rule_unoffload(flow->priv, rule, attr);
+ 	return flow->rule[1];
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  }
  
  void mlx5e_tc_unoffload_fdb_rules(struct mlx5_eswitch *esw,
@@@ -1211,15 -1238,7 +1285,19 @@@
  	if (attr->esw_attr->split_count)
  		mlx5_eswitch_del_fwd_rule(esw, flow->rule[1], attr);
  
++<<<<<<< HEAD
 +	if (flow_flag_test(flow, CT))
 +		mlx5_tc_ct_delete_flow(get_ct_priv(flow->priv), flow, attr);
 +#if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
 +	else if (flow_flag_test(flow, SAMPLE))
 +		mlx5e_tc_sample_unoffload(get_sample_priv(flow->priv), flow->rule[0], attr);
 +#endif
 +	else
 +offload_rule_0:
 +		mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
++=======
+ 	mlx5e_tc_rule_unoffload(flow->priv, flow->rule[0], attr);
++>>>>>>> a572c0a748e6 (net/mlx5e: CT, Remove redundant flow args from tc ct calls)
  }
  
  struct mlx5_flow_handle *
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
index 99662af1e41a..2b21c7b97a52 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
@@ -116,13 +116,11 @@ mlx5_tc_ct_parse_action(struct mlx5_tc_ct_priv *priv,
 
 struct mlx5_flow_handle *
 mlx5_tc_ct_flow_offload(struct mlx5_tc_ct_priv *priv,
-			struct mlx5e_tc_flow *flow,
 			struct mlx5_flow_spec *spec,
 			struct mlx5_flow_attr *attr,
 			struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 void
 mlx5_tc_ct_delete_flow(struct mlx5_tc_ct_priv *priv,
-		       struct mlx5e_tc_flow *flow,
 		       struct mlx5_flow_attr *attr);
 
 bool
@@ -183,7 +181,6 @@ mlx5_tc_ct_parse_action(struct mlx5_tc_ct_priv *priv,
 
 static inline struct mlx5_flow_handle *
 mlx5_tc_ct_flow_offload(struct mlx5_tc_ct_priv *priv,
-			struct mlx5e_tc_flow *flow,
 			struct mlx5_flow_spec *spec,
 			struct mlx5_flow_attr *attr,
 			struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts)
@@ -193,7 +190,6 @@ mlx5_tc_ct_flow_offload(struct mlx5_tc_ct_priv *priv,
 
 static inline void
 mlx5_tc_ct_delete_flow(struct mlx5_tc_ct_priv *priv,
-		       struct mlx5e_tc_flow *flow,
 		       struct mlx5_flow_attr *attr)
 {
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
