ASoC: wm_adsp: Expand firmware loading search options

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Simon Trimmer <simont@opensource.cirrus.com>
commit b6b62d942bbc4d926bcf3799ea3bcaeb105fd04f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b6b62d94.failed

The parts supported by this driver can have product-specific
firmware and tunings files. Typically these have been used on
embedded systems where the manufacturer is responsible for
installing the correct product-specific firmware files into
/lib/firmware. However, the linux-firmware repository places all
available firmwares into /lib/firmware and it is up to the driver to
select the correct product-specific firmware from that directory.

For example a product containing four smart amplifiers may provide
firmware specific for that product and each of the amplifiers may
have coefficient files containing tunings for their placement in the
mechanical design.

This change extends firmware (wmfw) and coefficient (bin) filenames
to be of the general form:

<cirrus/>part-dspN-fwtype<-system_name<-asoc_component_prefix>>.type

Where the cirrus subdirectory, system_name and asoc_component_prefix
are optional.

New files will be placed in the cirrus subdirectory to avoid
polluting the main /lib/firmware/ location. The generic name must be
searched in /lib/firmware before /lib/firmware/cirrus so that a
generic file in the new location does not override existing
product-specific files in the legacy location.

The search order for firmware files is:
  - cirrus/part-dspN-fwtype-system_name-asoc_component_prefix.wmfw
  - cirrus/part-dspN-fwtype-system_name.wmfw
  - part-dspN-fwtype.wmfw
  - cirrus/part-dspN-fwtype.wmfw

- Qualifications are added to the filename so that rightwards is more
  specific.
- The system_name is provided by the codec driver.
- The asoc_component_prefix is used to identify tunings for individual
  parts because it would already exist to disambiguate the controls
  and it makes it obvious which firmware file applies to which device.

The optional coefficient file must have the same filename
construction as the discovered wmfw except:
  - where the wmfw has only system_name then the bin file can
    optionally include the asoc_component_prefix. This is to allow a
    common wmfw for all amps but separate tunings per amp.

	Signed-off-by: Simon Trimmer <simont@opensource.cirrus.com>
	Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20220303155016.122125-1-simont@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit b6b62d942bbc4d926bcf3799ea3bcaeb105fd04f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
#	sound/soc/codecs/wm_adsp.h
diff --cc sound/soc/codecs/wm_adsp.c
index c1b5ea3b5718,375cb14aaccd..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -1673,1072 -715,155 +1673,1184 @@@ static int wm_adsp_check_coeff_flags(st
  
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(wm_adsp_write_ctl);
  
 -int wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,
 -		     unsigned int alg, void *buf, size_t len)
 +static int wm_adsp_parse_coeff(struct wm_adsp *dsp,
 +			       const struct wmfw_region *region)
  {
 -	struct cs_dsp_coeff_ctl *cs_ctl;
 +	struct wm_adsp_alg_region alg_region = {};
 +	struct wm_coeff_parsed_alg alg_blk;
 +	struct wm_coeff_parsed_coeff coeff_blk;
 +	const u8 *data = region->data;
 +	int i, ret;
  
 -	cs_ctl = cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg);
 -	if (!cs_ctl)
 -		return -EINVAL;
 +	wm_coeff_parse_alg(dsp, &data, &alg_blk);
 +	for (i = 0; i < alg_blk.ncoeff; i++) {
 +		wm_coeff_parse_coeff(dsp, &data, &coeff_blk);
  
 -	if (len > cs_ctl->len)
 -		return -EINVAL;
 +		switch (coeff_blk.ctl_type) {
 +		case WMFW_CTL_TYPE_BYTES:
 +			break;
 +		case WMFW_CTL_TYPE_ACKED:
 +			if (coeff_blk.flags & WMFW_CTL_FLAG_SYS)
 +				continue;	/* ignore */
 +
 +			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
 +						WMFW_CTL_FLAG_VOLATILE |
 +						WMFW_CTL_FLAG_WRITEABLE |
 +						WMFW_CTL_FLAG_READABLE,
 +						0);
 +			if (ret)
 +				return -EINVAL;
 +			break;
 +		case WMFW_CTL_TYPE_HOSTEVENT:
 +			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
 +						WMFW_CTL_FLAG_SYS |
 +						WMFW_CTL_FLAG_VOLATILE |
 +						WMFW_CTL_FLAG_WRITEABLE |
 +						WMFW_CTL_FLAG_READABLE,
 +						0);
 +			if (ret)
 +				return -EINVAL;
 +			break;
 +		case WMFW_CTL_TYPE_HOST_BUFFER:
 +			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
 +						WMFW_CTL_FLAG_SYS |
 +						WMFW_CTL_FLAG_VOLATILE |
 +						WMFW_CTL_FLAG_READABLE,
 +						0);
 +			if (ret)
 +				return -EINVAL;
 +			break;
 +		default:
 +			adsp_err(dsp, "Unknown control type: %d\n",
 +				 coeff_blk.ctl_type);
 +			return -EINVAL;
 +		}
 +
 +		alg_region.type = coeff_blk.mem_type;
 +		alg_region.alg = alg_blk.id;
 +
 +		ret = wm_adsp_create_control(dsp, &alg_region,
 +					     coeff_blk.offset,
 +					     coeff_blk.len,
 +					     coeff_blk.name,
 +					     coeff_blk.name_len,
 +					     coeff_blk.flags,
 +					     coeff_blk.ctl_type);
 +		if (ret < 0)
 +			adsp_err(dsp, "Failed to create control: %.*s, %d\n",
 +				 coeff_blk.name_len, coeff_blk.name, ret);
 +	}
  
 -	return cs_dsp_coeff_read_ctrl(cs_ctl, 0, buf, len);
 +	return 0;
  }
 -EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
  
 -static void wm_adsp_release_firmware_files(struct wm_adsp *dsp,
 -					   const struct firmware *wmfw_firmware,
 -					   char *wmfw_filename,
 -					   const struct firmware *coeff_firmware,
 -					   char *coeff_filename)
 +static unsigned int wm_adsp1_parse_sizes(struct wm_adsp *dsp,
 +					 const char * const file,
 +					 unsigned int pos,
 +					 const struct firmware *firmware)
  {
 -	if (wmfw_firmware)
 -		release_firmware(wmfw_firmware);
 -	kfree(wmfw_filename);
 +	const struct wmfw_adsp1_sizes *adsp1_sizes;
  
 -	if (coeff_firmware)
 -		release_firmware(coeff_firmware);
 -	kfree(coeff_filename);
 +	adsp1_sizes = (void *)&firmware->data[pos];
 +
 +	adsp_dbg(dsp, "%s: %d DM, %d PM, %d ZM\n", file,
 +		 le32_to_cpu(adsp1_sizes->dm), le32_to_cpu(adsp1_sizes->pm),
 +		 le32_to_cpu(adsp1_sizes->zm));
 +
 +	return pos + sizeof(*adsp1_sizes);
  }
  
 -static int wm_adsp_request_firmware_file(struct wm_adsp *dsp,
 -					 const struct firmware **firmware, char **filename,
 -					 const char *dir, const char *system_name,
 -					 const char *asoc_component_prefix,
 -					 const char *filetype)
 +static unsigned int wm_adsp2_parse_sizes(struct wm_adsp *dsp,
 +					 const char * const file,
 +					 unsigned int pos,
 +					 const struct firmware *firmware)
  {
 -	struct cs_dsp *cs_dsp = &dsp->cs_dsp;
 -	char *s, c;
 -	int ret = 0;
 +	const struct wmfw_adsp2_sizes *adsp2_sizes;
  
 -	if (system_name && asoc_component_prefix)
 -		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-%s.%s", dir, dsp->part,
 -				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
 -				      asoc_component_prefix, filetype);
 -	else if (system_name)
 -		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s.%s", dir, dsp->part,
 -				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
 -				      filetype);
 -	else
 -		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s.%s", dir, dsp->part, dsp->fwf_name,
 -				      wm_adsp_fw[dsp->fw].file, filetype);
 +	adsp2_sizes = (void *)&firmware->data[pos];
  
 -	if (*filename == NULL)
 -		return -ENOMEM;
 +	adsp_dbg(dsp, "%s: %d XM, %d YM %d PM, %d ZM\n", file,
 +		 le32_to_cpu(adsp2_sizes->xm), le32_to_cpu(adsp2_sizes->ym),
 +		 le32_to_cpu(adsp2_sizes->pm), le32_to_cpu(adsp2_sizes->zm));
  
 -	/*
 -	 * Make sure that filename is lower-case and any non alpha-numeric
 -	 * characters except full stop and forward slash are replaced with
 -	 * hyphens.
 -	 */
 -	s = *filename;
 -	while (*s) {
 -		c = *s;
 -		if (isalnum(c))
 -			*s = tolower(c);
 -		else if ((c != '.') && (c != '/'))
 -			*s = '-';
 -		s++;
 -	}
 +	return pos + sizeof(*adsp2_sizes);
 +}
  
 -	ret = firmware_request_nowarn(firmware, *filename, cs_dsp->dev);
 -	if (ret != 0) {
 -		adsp_dbg(dsp, "Failed to request '%s'\n", *filename);
 -		kfree(*filename);
 -		*filename = NULL;
 +static bool wm_adsp_validate_version(struct wm_adsp *dsp, unsigned int version)
 +{
 +	switch (version) {
 +	case 0:
 +		adsp_warn(dsp, "Deprecated file format %d\n", version);
 +		return true;
 +	case 1:
 +	case 2:
 +		return true;
 +	default:
 +		return false;
  	}
 -
 -	return ret;
  }
  
 -static const char *cirrus_dir = "cirrus/";
 -static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,
 -					  const struct firmware **wmfw_firmware,
 -					  char **wmfw_filename,
 -					  const struct firmware **coeff_firmware,
 -					  char **coeff_filename)
 +static bool wm_halo_validate_version(struct wm_adsp *dsp, unsigned int version)
 +{
 +	switch (version) {
 +	case 3:
 +		return true;
 +	default:
 +		return false;
 +	}
 +}
 +
 +static int wm_adsp_load(struct wm_adsp *dsp)
 +{
 +	LIST_HEAD(buf_list);
 +	const struct firmware *firmware;
 +	struct regmap *regmap = dsp->regmap;
 +	unsigned int pos = 0;
 +	const struct wmfw_header *header;
 +	const struct wmfw_adsp1_sizes *adsp1_sizes;
 +	const struct wmfw_footer *footer;
 +	const struct wmfw_region *region;
 +	const struct wm_adsp_region *mem;
 +	const char *region_name;
 +	char *file, *text = NULL;
 +	struct wm_adsp_buf *buf;
 +	unsigned int reg;
 +	int regions = 0;
 +	int ret, offset, type;
 +
 +	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +	if (file == NULL)
 +		return -ENOMEM;
 +
 +	snprintf(file, PAGE_SIZE, "%s-%s-%s.wmfw", dsp->part, dsp->fwf_name,
 +		 wm_adsp_fw[dsp->fw].file);
 +	file[PAGE_SIZE - 1] = '\0';
 +
 +	ret = request_firmware(&firmware, file, dsp->dev);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to request '%s'\n", file);
 +		goto out;
 +	}
 +	ret = -EINVAL;
 +
 +	pos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);
 +	if (pos >= firmware->size) {
 +		adsp_err(dsp, "%s: file too short, %zu bytes\n",
 +			 file, firmware->size);
 +		goto out_fw;
 +	}
 +
 +	header = (void *)&firmware->data[0];
 +
 +	if (memcmp(&header->magic[0], "WMFW", 4) != 0) {
 +		adsp_err(dsp, "%s: invalid magic\n", file);
 +		goto out_fw;
 +	}
 +
 +	if (!dsp->ops->validate_version(dsp, header->ver)) {
 +		adsp_err(dsp, "%s: unknown file format %d\n",
 +			 file, header->ver);
 +		goto out_fw;
 +	}
 +
 +	adsp_info(dsp, "Firmware version: %d\n", header->ver);
 +	dsp->fw_ver = header->ver;
 +
 +	if (header->core != dsp->type) {
 +		adsp_err(dsp, "%s: invalid core %d != %d\n",
 +			 file, header->core, dsp->type);
 +		goto out_fw;
 +	}
 +
 +	pos = sizeof(*header);
 +	pos = dsp->ops->parse_sizes(dsp, file, pos, firmware);
 +
 +	footer = (void *)&firmware->data[pos];
 +	pos += sizeof(*footer);
 +
 +	if (le32_to_cpu(header->len) != pos) {
 +		adsp_err(dsp, "%s: unexpected header length %d\n",
 +			 file, le32_to_cpu(header->len));
 +		goto out_fw;
 +	}
 +
 +	adsp_dbg(dsp, "%s: timestamp %llu\n", file,
 +		 le64_to_cpu(footer->timestamp));
 +
 +	while (pos < firmware->size &&
 +	       sizeof(*region) < firmware->size - pos) {
 +		region = (void *)&(firmware->data[pos]);
 +		region_name = "Unknown";
 +		reg = 0;
 +		text = NULL;
 +		offset = le32_to_cpu(region->offset) & 0xffffff;
 +		type = be32_to_cpu(region->type) & 0xff;
 +
 +		switch (type) {
 +		case WMFW_NAME_TEXT:
 +			region_name = "Firmware name";
 +			text = kzalloc(le32_to_cpu(region->len) + 1,
 +				       GFP_KERNEL);
 +			break;
 +		case WMFW_ALGORITHM_DATA:
 +			region_name = "Algorithm";
 +			ret = wm_adsp_parse_coeff(dsp, region);
 +			if (ret != 0)
 +				goto out_fw;
 +			break;
 +		case WMFW_INFO_TEXT:
 +			region_name = "Information";
 +			text = kzalloc(le32_to_cpu(region->len) + 1,
 +				       GFP_KERNEL);
 +			break;
 +		case WMFW_ABSOLUTE:
 +			region_name = "Absolute";
 +			reg = offset;
 +			break;
 +		case WMFW_ADSP1_PM:
 +		case WMFW_ADSP1_DM:
 +		case WMFW_ADSP2_XM:
 +		case WMFW_ADSP2_YM:
 +		case WMFW_ADSP1_ZM:
 +		case WMFW_HALO_PM_PACKED:
 +		case WMFW_HALO_XM_PACKED:
 +		case WMFW_HALO_YM_PACKED:
 +			mem = wm_adsp_find_region(dsp, type);
 +			if (!mem) {
 +				adsp_err(dsp, "No region of type: %x\n", type);
 +				ret = -EINVAL;
 +				goto out_fw;
 +			}
 +
 +			region_name = wm_adsp_mem_region_name(type);
 +			reg = dsp->ops->region_to_reg(mem, offset);
 +			break;
 +		default:
 +			adsp_warn(dsp,
 +				  "%s.%d: Unknown region type %x at %d(%x)\n",
 +				  file, regions, type, pos, pos);
 +			break;
 +		}
 +
 +		adsp_dbg(dsp, "%s.%d: %d bytes at %d in %s\n", file,
 +			 regions, le32_to_cpu(region->len), offset,
 +			 region_name);
 +
 +		if (le32_to_cpu(region->len) >
 +		    firmware->size - pos - sizeof(*region)) {
 +			adsp_err(dsp,
 +				 "%s.%d: %s region len %d bytes exceeds file length %zu\n",
 +				 file, regions, region_name,
 +				 le32_to_cpu(region->len), firmware->size);
 +			ret = -EINVAL;
 +			goto out_fw;
 +		}
 +
 +		if (text) {
 +			memcpy(text, region->data, le32_to_cpu(region->len));
 +			adsp_info(dsp, "%s: %s\n", file, text);
 +			kfree(text);
 +			text = NULL;
 +		}
 +
 +		if (reg) {
 +			buf = wm_adsp_buf_alloc(region->data,
 +						le32_to_cpu(region->len),
 +						&buf_list);
 +			if (!buf) {
 +				adsp_err(dsp, "Out of memory\n");
 +				ret = -ENOMEM;
 +				goto out_fw;
 +			}
 +
 +			ret = regmap_raw_write_async(regmap, reg, buf->buf,
 +						     le32_to_cpu(region->len));
 +			if (ret != 0) {
 +				adsp_err(dsp,
 +					"%s.%d: Failed to write %d bytes at %d in %s: %d\n",
 +					file, regions,
 +					le32_to_cpu(region->len), offset,
 +					region_name, ret);
 +				goto out_fw;
 +			}
 +		}
 +
 +		pos += le32_to_cpu(region->len) + sizeof(*region);
 +		regions++;
 +	}
 +
 +	ret = regmap_async_complete(regmap);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to complete async write: %d\n", ret);
 +		goto out_fw;
 +	}
 +
 +	if (pos > firmware->size)
 +		adsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",
 +			  file, regions, pos - firmware->size);
 +
 +	wm_adsp_debugfs_save_wmfwname(dsp, file);
 +
 +out_fw:
 +	regmap_async_complete(regmap);
 +	wm_adsp_buf_free(&buf_list);
 +	release_firmware(firmware);
 +	kfree(text);
 +out:
 +	kfree(file);
 +
 +	return ret;
 +}
 +
 +/*
 + * Find wm_coeff_ctl with input name as its subname
 + * If not found, return NULL
 + */
 +static struct wm_coeff_ctl *wm_adsp_get_ctl(struct wm_adsp *dsp,
 +					     const char *name, int type,
 +					     unsigned int alg)
 +{
 +	struct wm_coeff_ctl *pos, *rslt = NULL;
 +	const char *fw_txt = wm_adsp_fw_text[dsp->fw];
 +
 +	list_for_each_entry(pos, &dsp->ctl_list, list) {
 +		if (!pos->subname)
 +			continue;
 +		if (strncmp(pos->subname, name, pos->subname_len) == 0 &&
 +		    pos->fw_name == fw_txt &&
 +		    pos->alg_region.alg == alg &&
 +		    pos->alg_region.type == type) {
 +			rslt = pos;
 +			break;
 +		}
 +	}
 +
 +	return rslt;
 +}
 +
 +int wm_adsp_write_ctl(struct wm_adsp *dsp, const char *name, int type,
 +		      unsigned int alg, void *buf, size_t len)
 +{
 +	struct wm_coeff_ctl *ctl;
 +	struct snd_kcontrol *kcontrol;
 +	char ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 +	int ret;
 +
 +	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
 +	if (!ctl)
 +		return -EINVAL;
 +
 +	if (len > ctl->len)
 +		return -EINVAL;
 +
 +	ret = wm_coeff_write_ctrl(ctl, buf, len);
 +	if (ret)
 +		return ret;
 +
 +	if (ctl->flags & WMFW_CTL_FLAG_SYS)
 +		return 0;
 +
 +	if (dsp->component->name_prefix)
 +		snprintf(ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s %s",
 +			 dsp->component->name_prefix, ctl->name);
 +	else
 +		snprintf(ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s",
 +			 ctl->name);
 +
 +	kcontrol = snd_soc_card_get_kcontrol(dsp->component->card, ctl_name);
 +	if (!kcontrol) {
 +		adsp_err(dsp, "Can't find kcontrol %s\n", ctl_name);
 +		return -EINVAL;
 +	}
 +
 +	snd_ctl_notify(dsp->component->card->snd_card,
 +		       SNDRV_CTL_EVENT_MASK_VALUE, &kcontrol->id);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(wm_adsp_write_ctl);
 +
 +int wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,
 +		     unsigned int alg, void *buf, size_t len)
 +{
 +	struct wm_coeff_ctl *ctl;
 +
 +	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
 +	if (!ctl)
 +		return -EINVAL;
 +
 +	if (len > ctl->len)
 +		return -EINVAL;
 +
 +	return wm_coeff_read_ctrl(ctl, buf, len);
 +}
 +EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
 +
 +static void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,
 +				  const struct wm_adsp_alg_region *alg_region)
 +{
 +	struct wm_coeff_ctl *ctl;
 +
 +	list_for_each_entry(ctl, &dsp->ctl_list, list) {
 +		if (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&
 +		    alg_region->alg == ctl->alg_region.alg &&
 +		    alg_region->type == ctl->alg_region.type) {
 +			ctl->alg_region.base = alg_region->base;
 +		}
 +	}
 +}
 +
++<<<<<<< HEAD
 +static void *wm_adsp_read_algs(struct wm_adsp *dsp, size_t n_algs,
 +			       const struct wm_adsp_region *mem,
 +			       unsigned int pos, unsigned int len)
 +{
 +	void *alg;
 +	unsigned int reg;
 +	int ret;
 +	__be32 val;
 +
 +	if (n_algs == 0) {
 +		adsp_err(dsp, "No algorithms\n");
 +		return ERR_PTR(-EINVAL);
++=======
++static int wm_adsp_request_firmware_file(struct wm_adsp *dsp,
++					 const struct firmware **firmware, char **filename,
++					 const char *dir, const char *system_name,
++					 const char *asoc_component_prefix,
++					 const char *filetype)
++{
++	struct cs_dsp *cs_dsp = &dsp->cs_dsp;
++	char *s, c;
++	int ret = 0;
++
++	if (system_name && asoc_component_prefix)
++		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-%s.%s", dir, dsp->part,
++				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
++				      asoc_component_prefix, filetype);
++	else if (system_name)
++		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s.%s", dir, dsp->part,
++				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
++				      filetype);
++	else
++		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s.%s", dir, dsp->part, dsp->fwf_name,
++				      wm_adsp_fw[dsp->fw].file, filetype);
++
++	if (*filename == NULL)
++		return -ENOMEM;
++
++	/*
++	 * Make sure that filename is lower-case and any non alpha-numeric
++	 * characters except full stop and forward slash are replaced with
++	 * hyphens.
++	 */
++	s = *filename;
++	while (*s) {
++		c = *s;
++		if (isalnum(c))
++			*s = tolower(c);
++		else if ((c != '.') && (c != '/'))
++			*s = '-';
++		s++;
++	}
++
++	ret = firmware_request_nowarn(firmware, *filename, cs_dsp->dev);
++	if (ret != 0) {
++		adsp_dbg(dsp, "Failed to request '%s'\n", *filename);
++		kfree(*filename);
++		*filename = NULL;
++>>>>>>> b6b62d942bbc (ASoC: wm_adsp: Expand firmware loading search options)
 +	}
 +
 +	if (n_algs > 1024) {
 +		adsp_err(dsp, "Algorithm count %zx excessive\n", n_algs);
 +		return ERR_PTR(-EINVAL);
 +	}
 +
 +	/* Read the terminator first to validate the length */
 +	reg = dsp->ops->region_to_reg(mem, pos + len);
 +
 +	ret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm list end: %d\n",
 +			ret);
 +		return ERR_PTR(ret);
 +	}
 +
 +	if (be32_to_cpu(val) != 0xbedead)
 +		adsp_warn(dsp, "Algorithm list end %x 0x%x != 0xbedead\n",
 +			  reg, be32_to_cpu(val));
 +
 +	/* Convert length from DSP words to bytes */
 +	len *= sizeof(u32);
 +
 +	alg = kzalloc(len, GFP_KERNEL | GFP_DMA);
 +	if (!alg)
 +		return ERR_PTR(-ENOMEM);
 +
 +	reg = dsp->ops->region_to_reg(mem, pos);
 +
 +	ret = regmap_raw_read(dsp->regmap, reg, alg, len);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm list: %d\n", ret);
 +		kfree(alg);
 +		return ERR_PTR(ret);
 +	}
 +
 +	return alg;
 +}
 +
++<<<<<<< HEAD
 +static struct wm_adsp_alg_region *
 +	wm_adsp_find_alg_region(struct wm_adsp *dsp, int type, unsigned int id)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +
 +	list_for_each_entry(alg_region, &dsp->alg_regions, list) {
 +		if (id == alg_region->alg && type == alg_region->type)
 +			return alg_region;
 +	}
 +
 +	return NULL;
 +}
 +
 +static struct wm_adsp_alg_region *wm_adsp_create_region(struct wm_adsp *dsp,
 +							int type, __be32 id,
 +							__be32 base)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +
 +	alg_region = kzalloc(sizeof(*alg_region), GFP_KERNEL);
 +	if (!alg_region)
 +		return ERR_PTR(-ENOMEM);
 +
 +	alg_region->type = type;
 +	alg_region->alg = be32_to_cpu(id);
 +	alg_region->base = be32_to_cpu(base);
 +
 +	list_add_tail(&alg_region->list, &dsp->alg_regions);
 +
 +	if (dsp->fw_ver > 0)
 +		wm_adsp_ctl_fixup_base(dsp, alg_region);
 +
 +	return alg_region;
 +}
 +
 +static void wm_adsp_free_alg_regions(struct wm_adsp *dsp)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +
 +	while (!list_empty(&dsp->alg_regions)) {
 +		alg_region = list_first_entry(&dsp->alg_regions,
 +					      struct wm_adsp_alg_region,
 +					      list);
 +		list_del(&alg_region->list);
 +		kfree(alg_region);
 +	}
 +}
 +
 +static void wmfw_parse_id_header(struct wm_adsp *dsp,
 +				 struct wmfw_id_hdr *fw, int nalgs)
 +{
 +	dsp->fw_id = be32_to_cpu(fw->id);
 +	dsp->fw_id_version = be32_to_cpu(fw->ver);
 +
 +	adsp_info(dsp, "Firmware: %x v%d.%d.%d, %d algorithms\n",
 +		  dsp->fw_id, (dsp->fw_id_version & 0xff0000) >> 16,
 +		  (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,
 +		  nalgs);
 +}
 +
 +static void wmfw_v3_parse_id_header(struct wm_adsp *dsp,
 +				    struct wmfw_v3_id_hdr *fw, int nalgs)
 +{
 +	dsp->fw_id = be32_to_cpu(fw->id);
 +	dsp->fw_id_version = be32_to_cpu(fw->ver);
 +	dsp->fw_vendor_id = be32_to_cpu(fw->vendor_id);
 +
 +	adsp_info(dsp, "Firmware: %x vendor: 0x%x v%d.%d.%d, %d algorithms\n",
 +		  dsp->fw_id, dsp->fw_vendor_id,
 +		  (dsp->fw_id_version & 0xff0000) >> 16,
 +		  (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,
 +		  nalgs);
 +}
 +
 +static int wm_adsp_create_regions(struct wm_adsp *dsp, __be32 id, int nregions,
 +				const int *type, __be32 *base)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +	int i;
 +
 +	for (i = 0; i < nregions; i++) {
 +		alg_region = wm_adsp_create_region(dsp, type[i], id, base[i]);
 +		if (IS_ERR(alg_region))
 +			return PTR_ERR(alg_region);
 +	}
++=======
++static const char *cirrus_dir = "cirrus/";
++static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,
++					  const struct firmware **wmfw_firmware,
++					  char **wmfw_filename,
++					  const struct firmware **coeff_firmware,
++					  char **coeff_filename)
+ {
+ 	const char *system_name = dsp->system_name;
+ 	const char *asoc_component_prefix = dsp->component->name_prefix;
+ 	int ret = 0;
  
- 	return 0;
+ 	if (system_name && asoc_component_prefix) {
+ 		if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
+ 						   cirrus_dir, system_name,
+ 						   asoc_component_prefix, "wmfw")) {
+ 			adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
+ 			wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
+ 						      cirrus_dir, system_name,
+ 						      asoc_component_prefix, "bin");
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	if (system_name) {
+ 		if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
+ 						   cirrus_dir, system_name,
+ 						   NULL, "wmfw")) {
+ 			adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
+ 			if (asoc_component_prefix)
+ 				wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
+ 							      cirrus_dir, system_name,
+ 							      asoc_component_prefix, "bin");
++>>>>>>> b6b62d942bbc (ASoC: wm_adsp: Expand firmware loading search options)
+ 
+ 			if (!*coeff_firmware)
+ 				wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
+ 							      cirrus_dir, system_name,
+ 							      NULL, "bin");
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
+ 					   "", NULL, NULL, "wmfw")) {
+ 		adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
+ 		wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
+ 					      "", NULL, NULL, "bin");
+ 		return 0;
+ 	}
+ 
+ 	ret = wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
+ 					    cirrus_dir, NULL, NULL, "wmfw");
+ 	if (!ret) {
+ 		adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
+ 		wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
+ 					      cirrus_dir, NULL, NULL, "bin");
+ 		return 0;
+ 	}
+ 
+ 	adsp_err(dsp, "Failed to request firmware <%s>%s-%s-%s<-%s<%s>>.wmfw\n",
+ 		 cirrus_dir, dsp->part, dsp->fwf_name, wm_adsp_fw[dsp->fw].file,
+ 		 system_name, asoc_component_prefix);
+ 
+ 	return -ENOENT;
  }
  
 -static int wm_adsp_common_init(struct wm_adsp *dsp)
 +static int wm_adsp1_setup_algs(struct wm_adsp *dsp)
 +{
 +	struct wmfw_adsp1_id_hdr adsp1_id;
 +	struct wmfw_adsp1_alg_hdr *adsp1_alg;
 +	struct wm_adsp_alg_region *alg_region;
 +	const struct wm_adsp_region *mem;
 +	unsigned int pos, len;
 +	size_t n_algs;
 +	int i, ret;
 +
 +	mem = wm_adsp_find_region(dsp, WMFW_ADSP1_DM);
 +	if (WARN_ON(!mem))
 +		return -EINVAL;
 +
 +	ret = regmap_raw_read(dsp->regmap, mem->base, &adsp1_id,
 +			      sizeof(adsp1_id));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm info: %d\n",
 +			 ret);
 +		return ret;
 +	}
 +
 +	n_algs = be32_to_cpu(adsp1_id.n_algs);
 +
 +	wmfw_parse_id_header(dsp, &adsp1_id.fw, n_algs);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,
 +					   adsp1_id.fw.id, adsp1_id.zm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,
 +					   adsp1_id.fw.id, adsp1_id.dm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	/* Calculate offset and length in DSP words */
 +	pos = sizeof(adsp1_id) / sizeof(u32);
 +	len = (sizeof(*adsp1_alg) * n_algs) / sizeof(u32);
 +
 +	adsp1_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
 +	if (IS_ERR(adsp1_alg))
 +		return PTR_ERR(adsp1_alg);
 +
 +	for (i = 0; i < n_algs; i++) {
 +		adsp_info(dsp, "%d: ID %x v%d.%d.%d DM@%x ZM@%x\n",
 +			  i, be32_to_cpu(adsp1_alg[i].alg.id),
 +			  (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff0000) >> 16,
 +			  (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff00) >> 8,
 +			  be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff,
 +			  be32_to_cpu(adsp1_alg[i].dm),
 +			  be32_to_cpu(adsp1_alg[i].zm));
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,
 +						   adsp1_alg[i].alg.id,
 +						   adsp1_alg[i].dm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp1_alg[i + 1].dm);
 +				len -= be32_to_cpu(adsp1_alg[i].dm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region DM with ID %x\n",
 +					  be32_to_cpu(adsp1_alg[i].alg.id));
 +			}
 +		}
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,
 +						   adsp1_alg[i].alg.id,
 +						   adsp1_alg[i].zm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp1_alg[i + 1].zm);
 +				len -= be32_to_cpu(adsp1_alg[i].zm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region ZM with ID %x\n",
 +					  be32_to_cpu(adsp1_alg[i].alg.id));
 +			}
 +		}
 +	}
 +
 +out:
 +	kfree(adsp1_alg);
 +	return ret;
 +}
 +
 +static int wm_adsp2_setup_algs(struct wm_adsp *dsp)
 +{
 +	struct wmfw_adsp2_id_hdr adsp2_id;
 +	struct wmfw_adsp2_alg_hdr *adsp2_alg;
 +	struct wm_adsp_alg_region *alg_region;
 +	const struct wm_adsp_region *mem;
 +	unsigned int pos, len;
 +	size_t n_algs;
 +	int i, ret;
 +
 +	mem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);
 +	if (WARN_ON(!mem))
 +		return -EINVAL;
 +
 +	ret = regmap_raw_read(dsp->regmap, mem->base, &adsp2_id,
 +			      sizeof(adsp2_id));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm info: %d\n",
 +			 ret);
 +		return ret;
 +	}
 +
 +	n_algs = be32_to_cpu(adsp2_id.n_algs);
 +
 +	wmfw_parse_id_header(dsp, &adsp2_id.fw, n_algs);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,
 +					   adsp2_id.fw.id, adsp2_id.xm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,
 +					   adsp2_id.fw.id, adsp2_id.ym);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,
 +					   adsp2_id.fw.id, adsp2_id.zm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	/* Calculate offset and length in DSP words */
 +	pos = sizeof(adsp2_id) / sizeof(u32);
 +	len = (sizeof(*adsp2_alg) * n_algs) / sizeof(u32);
 +
 +	adsp2_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
 +	if (IS_ERR(adsp2_alg))
 +		return PTR_ERR(adsp2_alg);
 +
 +	for (i = 0; i < n_algs; i++) {
 +		adsp_info(dsp,
 +			  "%d: ID %x v%d.%d.%d XM@%x YM@%x ZM@%x\n",
 +			  i, be32_to_cpu(adsp2_alg[i].alg.id),
 +			  (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff0000) >> 16,
 +			  (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff00) >> 8,
 +			  be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff,
 +			  be32_to_cpu(adsp2_alg[i].xm),
 +			  be32_to_cpu(adsp2_alg[i].ym),
 +			  be32_to_cpu(adsp2_alg[i].zm));
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,
 +						   adsp2_alg[i].alg.id,
 +						   adsp2_alg[i].xm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp2_alg[i + 1].xm);
 +				len -= be32_to_cpu(adsp2_alg[i].xm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region XM with ID %x\n",
 +					  be32_to_cpu(adsp2_alg[i].alg.id));
 +			}
 +		}
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,
 +						   adsp2_alg[i].alg.id,
 +						   adsp2_alg[i].ym);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp2_alg[i + 1].ym);
 +				len -= be32_to_cpu(adsp2_alg[i].ym);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region YM with ID %x\n",
 +					  be32_to_cpu(adsp2_alg[i].alg.id));
 +			}
 +		}
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,
 +						   adsp2_alg[i].alg.id,
 +						   adsp2_alg[i].zm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp2_alg[i + 1].zm);
 +				len -= be32_to_cpu(adsp2_alg[i].zm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region ZM with ID %x\n",
 +					  be32_to_cpu(adsp2_alg[i].alg.id));
 +			}
 +		}
 +	}
 +
 +out:
 +	kfree(adsp2_alg);
 +	return ret;
 +}
 +
 +static int wm_halo_create_regions(struct wm_adsp *dsp, __be32 id,
 +				  __be32 xm_base, __be32 ym_base)
 +{
 +	static const int types[] = {
 +		WMFW_ADSP2_XM, WMFW_HALO_XM_PACKED,
 +		WMFW_ADSP2_YM, WMFW_HALO_YM_PACKED
 +	};
 +	__be32 bases[] = { xm_base, xm_base, ym_base, ym_base };
 +
 +	return wm_adsp_create_regions(dsp, id, ARRAY_SIZE(types), types, bases);
 +}
 +
 +static int wm_halo_setup_algs(struct wm_adsp *dsp)
 +{
 +	struct wmfw_halo_id_hdr halo_id;
 +	struct wmfw_halo_alg_hdr *halo_alg;
 +	const struct wm_adsp_region *mem;
 +	unsigned int pos, len;
 +	size_t n_algs;
 +	int i, ret;
 +
 +	mem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);
 +	if (WARN_ON(!mem))
 +		return -EINVAL;
 +
 +	ret = regmap_raw_read(dsp->regmap, mem->base, &halo_id,
 +			      sizeof(halo_id));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm info: %d\n",
 +			 ret);
 +		return ret;
 +	}
 +
 +	n_algs = be32_to_cpu(halo_id.n_algs);
 +
 +	wmfw_v3_parse_id_header(dsp, &halo_id.fw, n_algs);
 +
 +	ret = wm_halo_create_regions(dsp, halo_id.fw.id,
 +				     halo_id.xm_base, halo_id.ym_base);
 +	if (ret)
 +		return ret;
 +
 +	/* Calculate offset and length in DSP words */
 +	pos = sizeof(halo_id) / sizeof(u32);
 +	len = (sizeof(*halo_alg) * n_algs) / sizeof(u32);
 +
 +	halo_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
 +	if (IS_ERR(halo_alg))
 +		return PTR_ERR(halo_alg);
 +
 +	for (i = 0; i < n_algs; i++) {
 +		adsp_info(dsp,
 +			  "%d: ID %x v%d.%d.%d XM@%x YM@%x\n",
 +			  i, be32_to_cpu(halo_alg[i].alg.id),
 +			  (be32_to_cpu(halo_alg[i].alg.ver) & 0xff0000) >> 16,
 +			  (be32_to_cpu(halo_alg[i].alg.ver) & 0xff00) >> 8,
 +			  be32_to_cpu(halo_alg[i].alg.ver) & 0xff,
 +			  be32_to_cpu(halo_alg[i].xm_base),
 +			  be32_to_cpu(halo_alg[i].ym_base));
 +
 +		ret = wm_halo_create_regions(dsp, halo_alg[i].alg.id,
 +					     halo_alg[i].xm_base,
 +					     halo_alg[i].ym_base);
 +		if (ret)
 +			goto out;
 +	}
 +
 +out:
 +	kfree(halo_alg);
 +	return ret;
 +}
 +
 +static int wm_adsp_load_coeff(struct wm_adsp *dsp)
 +{
 +	LIST_HEAD(buf_list);
 +	struct regmap *regmap = dsp->regmap;
 +	struct wmfw_coeff_hdr *hdr;
 +	struct wmfw_coeff_item *blk;
 +	const struct firmware *firmware;
 +	const struct wm_adsp_region *mem;
 +	struct wm_adsp_alg_region *alg_region;
 +	const char *region_name;
 +	int ret, pos, blocks, type, offset, reg;
 +	char *file;
 +	struct wm_adsp_buf *buf;
 +
 +	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +	if (file == NULL)
 +		return -ENOMEM;
 +
 +	snprintf(file, PAGE_SIZE, "%s-%s-%s.bin", dsp->part, dsp->fwf_name,
 +		 wm_adsp_fw[dsp->fw].file);
 +	file[PAGE_SIZE - 1] = '\0';
 +
 +	ret = request_firmware(&firmware, file, dsp->dev);
 +	if (ret != 0) {
 +		adsp_warn(dsp, "Failed to request '%s'\n", file);
 +		ret = 0;
 +		goto out;
 +	}
 +	ret = -EINVAL;
 +
 +	if (sizeof(*hdr) >= firmware->size) {
 +		adsp_err(dsp, "%s: file too short, %zu bytes\n",
 +			file, firmware->size);
 +		goto out_fw;
 +	}
 +
 +	hdr = (void *)&firmware->data[0];
 +	if (memcmp(hdr->magic, "WMDR", 4) != 0) {
 +		adsp_err(dsp, "%s: invalid magic\n", file);
 +		goto out_fw;
 +	}
 +
 +	switch (be32_to_cpu(hdr->rev) & 0xff) {
 +	case 1:
 +		break;
 +	default:
 +		adsp_err(dsp, "%s: Unsupported coefficient file format %d\n",
 +			 file, be32_to_cpu(hdr->rev) & 0xff);
 +		ret = -EINVAL;
 +		goto out_fw;
 +	}
 +
 +	adsp_dbg(dsp, "%s: v%d.%d.%d\n", file,
 +		(le32_to_cpu(hdr->ver) >> 16) & 0xff,
 +		(le32_to_cpu(hdr->ver) >>  8) & 0xff,
 +		le32_to_cpu(hdr->ver) & 0xff);
 +
 +	pos = le32_to_cpu(hdr->len);
 +
 +	blocks = 0;
 +	while (pos < firmware->size &&
 +	       sizeof(*blk) < firmware->size - pos) {
 +		blk = (void *)(&firmware->data[pos]);
 +
 +		type = le16_to_cpu(blk->type);
 +		offset = le16_to_cpu(blk->offset);
 +
 +		adsp_dbg(dsp, "%s.%d: %x v%d.%d.%d\n",
 +			 file, blocks, le32_to_cpu(blk->id),
 +			 (le32_to_cpu(blk->ver) >> 16) & 0xff,
 +			 (le32_to_cpu(blk->ver) >>  8) & 0xff,
 +			 le32_to_cpu(blk->ver) & 0xff);
 +		adsp_dbg(dsp, "%s.%d: %d bytes at 0x%x in %x\n",
 +			 file, blocks, le32_to_cpu(blk->len), offset, type);
 +
 +		reg = 0;
 +		region_name = "Unknown";
 +		switch (type) {
 +		case (WMFW_NAME_TEXT << 8):
 +		case (WMFW_INFO_TEXT << 8):
 +		case (WMFW_METADATA << 8):
 +			break;
 +		case (WMFW_ABSOLUTE << 8):
 +			/*
 +			 * Old files may use this for global
 +			 * coefficients.
 +			 */
 +			if (le32_to_cpu(blk->id) == dsp->fw_id &&
 +			    offset == 0) {
 +				region_name = "global coefficients";
 +				mem = wm_adsp_find_region(dsp, type);
 +				if (!mem) {
 +					adsp_err(dsp, "No ZM\n");
 +					break;
 +				}
 +				reg = dsp->ops->region_to_reg(mem, 0);
 +
 +			} else {
 +				region_name = "register";
 +				reg = offset;
 +			}
 +			break;
 +
 +		case WMFW_ADSP1_DM:
 +		case WMFW_ADSP1_ZM:
 +		case WMFW_ADSP2_XM:
 +		case WMFW_ADSP2_YM:
 +		case WMFW_HALO_XM_PACKED:
 +		case WMFW_HALO_YM_PACKED:
 +		case WMFW_HALO_PM_PACKED:
 +			adsp_dbg(dsp, "%s.%d: %d bytes in %x for %x\n",
 +				 file, blocks, le32_to_cpu(blk->len),
 +				 type, le32_to_cpu(blk->id));
 +
 +			mem = wm_adsp_find_region(dsp, type);
 +			if (!mem) {
 +				adsp_err(dsp, "No base for region %x\n", type);
 +				break;
 +			}
 +
 +			alg_region = wm_adsp_find_alg_region(dsp, type,
 +						le32_to_cpu(blk->id));
 +			if (alg_region) {
 +				reg = alg_region->base;
 +				reg = dsp->ops->region_to_reg(mem, reg);
 +				reg += offset;
 +			} else {
 +				adsp_err(dsp, "No %x for algorithm %x\n",
 +					 type, le32_to_cpu(blk->id));
 +			}
 +			break;
 +
 +		default:
 +			adsp_err(dsp, "%s.%d: Unknown region type %x at %d\n",
 +				 file, blocks, type, pos);
 +			break;
 +		}
 +
 +		if (reg) {
 +			if (le32_to_cpu(blk->len) >
 +			    firmware->size - pos - sizeof(*blk)) {
 +				adsp_err(dsp,
 +					 "%s.%d: %s region len %d bytes exceeds file length %zu\n",
 +					 file, blocks, region_name,
 +					 le32_to_cpu(blk->len),
 +					 firmware->size);
 +				ret = -EINVAL;
 +				goto out_fw;
 +			}
 +
 +			buf = wm_adsp_buf_alloc(blk->data,
 +						le32_to_cpu(blk->len),
 +						&buf_list);
 +			if (!buf) {
 +				adsp_err(dsp, "Out of memory\n");
 +				ret = -ENOMEM;
 +				goto out_fw;
 +			}
 +
 +			adsp_dbg(dsp, "%s.%d: Writing %d bytes at %x\n",
 +				 file, blocks, le32_to_cpu(blk->len),
 +				 reg);
 +			ret = regmap_raw_write_async(regmap, reg, buf->buf,
 +						     le32_to_cpu(blk->len));
 +			if (ret != 0) {
 +				adsp_err(dsp,
 +					"%s.%d: Failed to write to %x in %s: %d\n",
 +					file, blocks, reg, region_name, ret);
 +			}
 +		}
 +
 +		pos += (le32_to_cpu(blk->len) + sizeof(*blk) + 3) & ~0x03;
 +		blocks++;
 +	}
 +
 +	ret = regmap_async_complete(regmap);
 +	if (ret != 0)
 +		adsp_err(dsp, "Failed to complete async write: %d\n", ret);
 +
 +	if (pos > firmware->size)
 +		adsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",
 +			  file, blocks, pos - firmware->size);
 +
 +	wm_adsp_debugfs_save_binname(dsp, file);
 +
 +out_fw:
 +	regmap_async_complete(regmap);
 +	release_firmware(firmware);
 +	wm_adsp_buf_free(&buf_list);
 +out:
 +	kfree(file);
 +	return ret;
 +}
 +
 +static int wm_adsp_create_name(struct wm_adsp *dsp)
  {
  	char *p;
  
diff --cc sound/soc/codecs/wm_adsp.h
index f22131d9cc29,375009a65828..000000000000
--- a/sound/soc/codecs/wm_adsp.h
+++ b/sound/soc/codecs/wm_adsp.h
@@@ -20,79 -21,25 +20,83 @@@
  #define WM_ADSP_COMPR_OK                 0
  #define WM_ADSP_COMPR_VOICE_TRIGGER      1
  
 +#define WM_ADSP2_REGION_0 BIT(0)
 +#define WM_ADSP2_REGION_1 BIT(1)
 +#define WM_ADSP2_REGION_2 BIT(2)
 +#define WM_ADSP2_REGION_3 BIT(3)
 +#define WM_ADSP2_REGION_4 BIT(4)
 +#define WM_ADSP2_REGION_5 BIT(5)
 +#define WM_ADSP2_REGION_6 BIT(6)
 +#define WM_ADSP2_REGION_7 BIT(7)
 +#define WM_ADSP2_REGION_8 BIT(8)
 +#define WM_ADSP2_REGION_9 BIT(9)
 +#define WM_ADSP2_REGION_1_9 (WM_ADSP2_REGION_1 | \
 +		WM_ADSP2_REGION_2 | WM_ADSP2_REGION_3 | \
 +		WM_ADSP2_REGION_4 | WM_ADSP2_REGION_5 | \
 +		WM_ADSP2_REGION_6 | WM_ADSP2_REGION_7 | \
 +		WM_ADSP2_REGION_8 | WM_ADSP2_REGION_9)
 +#define WM_ADSP2_REGION_ALL (WM_ADSP2_REGION_0 | WM_ADSP2_REGION_1_9)
 +
 +struct wm_adsp_region {
 +	int type;
 +	unsigned int base;
 +};
 +
 +struct wm_adsp_alg_region {
 +	struct list_head list;
 +	unsigned int alg;
 +	int type;
 +	unsigned int base;
 +};
 +
  struct wm_adsp_compr;
  struct wm_adsp_compr_buf;
 +struct wm_adsp_ops;
  
  struct wm_adsp {
 -	struct cs_dsp cs_dsp;
  	const char *part;
 +	const char *name;
  	const char *fwf_name;
++<<<<<<< HEAD
 +	int rev;
 +	int num;
 +	int type;
 +	struct device *dev;
 +	struct regmap *regmap;
++=======
+ 	const char *system_name;
++>>>>>>> b6b62d942bbc (ASoC: wm_adsp: Expand firmware loading search options)
  	struct snd_soc_component *component;
  
 -	unsigned int sys_config_size;
 +	const struct wm_adsp_ops *ops;
  
 -	int fw;
 +	unsigned int base;
 +	unsigned int base_sysinfo;
 +	unsigned int sysclk_reg;
 +	unsigned int sysclk_mask;
 +	unsigned int sysclk_shift;
  
 -	struct work_struct boot_work;
 +	struct list_head alg_regions;
 +
 +	unsigned int fw_id;
 +	unsigned int fw_id_version;
 +	unsigned int fw_vendor_id;
 +
 +	const struct wm_adsp_region *mem;
 +	int num_mems;
 +
 +	int fw;
 +	int fw_ver;
  
  	bool preloaded;
 +	bool booted;
 +	bool running;
  	bool fatal_error;
  
 +	struct list_head ctl_list;
 +
 +	struct work_struct boot_work;
 +
  	struct list_head compr_list;
  	struct list_head buffer_list;
  
* Unmerged path sound/soc/codecs/wm_adsp.c
* Unmerged path sound/soc/codecs/wm_adsp.h
