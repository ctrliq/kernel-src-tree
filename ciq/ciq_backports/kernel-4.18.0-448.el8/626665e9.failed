scsi: mpi3mr: Get target object based on rphy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit 626665e9c38d3d35b2cdb111b9e813b396d7284e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/626665e9.failed

When device is registered with the STL then get the corresponding device's
target object using the rphy in below callback functions:

 - mpi3mr_target_alloc()

 - mpi3mr_slave_alloc()

 - mpi3mr_slave_configure()

 - mpi3mr_slave_destroy()

Link: https://lore.kernel.org/r/20220804131226.16653-11-sreekanth.reddy@broadcom.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 626665e9c38d3d35b2cdb111b9e813b396d7284e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_fw.c
#	drivers/scsi/mpi3mr/mpi3mr_os.c
#	drivers/scsi/mpi3mr/mpi3mr_transport.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 8de3e5650c79,a91a57b88877..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -796,6 -987,22 +796,25 @@@ struct scmd_priv 
   * @logdata_buf: Circular buffer to store log data entries
   * @logdata_buf_idx: Index of entry in buffer to store
   * @logdata_entry_sz: log data entry size
++<<<<<<< HEAD
++=======
+  * @pend_large_data_sz: Counter to track pending large data
+  * @io_throttle_data_length: I/O size to track in 512b blocks
+  * @io_throttle_high: I/O size to start throttle in 512b blocks
+  * @io_throttle_low: I/O size to stop throttle in 512b blocks
+  * @num_io_throttle_group: Maximum number of throttle groups
+  * @throttle_groups: Pointer to throttle group info structures
+  * @cfg_page: Default memory for configuration pages
+  * @cfg_page_dma: Configuration page DMA address
+  * @cfg_page_sz: Default configuration page memory size
+  * @sas_transport_enabled: SAS transport enabled or not
+  * @scsi_device_channel: Channel ID for SCSI devices
+  * @sas_hba: SAS node for the controller
+  * @sas_expander_list: SAS node list of expanders
+  * @sas_node_lock: Lock to protect SAS node list
+  * @hba_port_table_list: List of HBA Ports
+  * @enclosure_list: List of Enclosure objects
++>>>>>>> 626665e9c38d (scsi: mpi3mr: Get target object based on rphy)
   */
  struct mpi3mr_ioc {
  	struct list_head list;
@@@ -960,6 -1168,25 +979,28 @@@
  	u8 *logdata_buf;
  	u16 logdata_buf_idx;
  	u16 logdata_entry_sz;
++<<<<<<< HEAD
++=======
+ 
+ 	atomic_t pend_large_data_sz;
+ 	u32 io_throttle_data_length;
+ 	u32 io_throttle_high;
+ 	u32 io_throttle_low;
+ 	u16 num_io_throttle_group;
+ 	struct mpi3mr_throttle_group_info *throttle_groups;
+ 
+ 	void *cfg_page;
+ 	dma_addr_t cfg_page_dma;
+ 	u16 cfg_page_sz;
+ 
+ 	u8 sas_transport_enabled;
+ 	u8 scsi_device_channel;
+ 	struct mpi3mr_sas_node sas_hba;
+ 	struct list_head sas_expander_list;
+ 	spinlock_t sas_node_lock;
+ 	struct list_head hba_port_table_list;
+ 	struct list_head enclosure_list;
++>>>>>>> 626665e9c38d (scsi: mpi3mr: Get target object based on rphy)
  };
  
  /**
@@@ -1084,6 -1311,54 +1125,55 @@@ int mpi3mr_pel_get_seqnum_post(struct m
  	struct mpi3mr_drv_cmd *drv_cmd);
  void mpi3mr_app_save_logdata(struct mpi3mr_ioc *mrioc, char *event_data,
  	u16 event_data_size);
 -struct mpi3mr_enclosure_node *mpi3mr_enclosure_find_by_handle(
 -	struct mpi3mr_ioc *mrioc, u16 handle);
 -extern const struct attribute_group *mpi3mr_host_groups[];
 +extern struct device_attribute *mpi3mr_host_attrs[];
  extern const struct attribute_group *mpi3mr_dev_groups[];
++<<<<<<< HEAD
++=======
+ 
+ int mpi3mr_cfg_get_dev_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_device_page0 *dev_pg0, u16 pg_sz, u32 form, u32 form_spec);
+ int mpi3mr_cfg_get_sas_phy_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_phy_page0 *phy_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_phy_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_phy_page1 *phy_pg1, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_exp_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_expander_page0 *exp_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_exp_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_expander_page1 *exp_pg1, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_enclosure_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_enclosure_page0 *encl_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_io_unit_pg0(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page0 *sas_io_unit_pg0, u16 pg_sz);
+ int mpi3mr_cfg_get_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
+ int mpi3mr_cfg_set_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
+ int mpi3mr_cfg_get_driver_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_driver_page1 *driver_pg1, u16 pg_sz);
+ 
+ u8 mpi3mr_is_expander_device(u16 device_info);
+ int mpi3mr_expander_add(struct mpi3mr_ioc *mrioc, u16 handle);
+ void mpi3mr_expander_remove(struct mpi3mr_ioc *mrioc, u64 sas_address,
+ 	struct mpi3mr_hba_port *hba_port);
+ struct mpi3mr_sas_node *__mpi3mr_expander_find_by_handle(struct mpi3mr_ioc
+ 	*mrioc, u16 handle);
+ struct mpi3mr_hba_port *mpi3mr_get_hba_port_by_id(struct mpi3mr_ioc *mrioc,
+ 	u8 port_id);
+ void mpi3mr_sas_host_refresh(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_sas_host_add(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_update_links(struct mpi3mr_ioc *mrioc,
+ 	u64 sas_address_parent, u16 handle, u8 phy_number, u8 link_rate,
+ 	struct mpi3mr_hba_port *hba_port);
+ void mpi3mr_remove_tgtdev_from_host(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ struct mpi3mr_tgt_dev *__mpi3mr_get_tgtdev_by_addr_and_rphy(
+ 	struct mpi3mr_ioc *mrioc, u64 sas_address, struct sas_rphy *rphy);
+ void mpi3mr_print_device_event_notice(struct mpi3mr_ioc *mrioc,
+ 	bool device_add);
++>>>>>>> 626665e9c38d (scsi: mpi3mr: Get target object based on rphy)
  #endif /*MPI3MR_H_INCLUDED*/
diff --cc drivers/scsi/mpi3mr/mpi3mr_fw.c
index a891e8c285f7,295ad8c1aeeb..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@@ -3709,6 -3742,13 +3709,16 @@@ retry_init
  		mrioc->max_host_ios = min_t(int, mrioc->max_host_ios,
  		    MPI3MR_HOST_IOS_KDUMP);
  
++<<<<<<< HEAD
++=======
+ 	if (!(mrioc->facts.ioc_capabilities &
+ 	    MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED)) {
+ 		mrioc->sas_transport_enabled = 1;
+ 		mrioc->scsi_device_channel = 1;
+ 		mrioc->shost->max_channel = 1;
+ 	}
+ 
++>>>>>>> 626665e9c38d (scsi: mpi3mr: Get target object based on rphy)
  	mrioc->reply_sz = mrioc->facts.reply_sz;
  
  	retval = mpi3mr_check_reset_dma_mask(mrioc);
diff --cc drivers/scsi/mpi3mr/mpi3mr_os.c
index c851b53cb9f5,bdc0603c5d5f..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@@ -3862,8 -4275,12 +3904,17 @@@ static int mpi3mr_target_alloc(struct s
  		tgt_dev->starget = starget;
  		atomic_set(&scsi_tgt_priv_data->block_io, 0);
  		retval = 0;
++<<<<<<< HEAD
 +	} else
 +		retval = -ENXIO;
++=======
+ 		scsi_tgt_priv_data->io_throttle_enabled =
+ 		    tgt_dev->io_throttle_enabled;
+ 		if (tgt_dev->dev_type == MPI3_DEVICE_DEVFORM_VD)
+ 			scsi_tgt_priv_data->throttle_group =
+ 			    tgt_dev->dev_spec.vd_inf.tg;
+ 	}
++>>>>>>> 626665e9c38d (scsi: mpi3mr: Get target object based on rphy)
  	spin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);
  
  	return retval;
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_transport.c
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_fw.c
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_os.c
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_transport.c
