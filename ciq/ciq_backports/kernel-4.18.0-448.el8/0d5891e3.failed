wifi: mac80211: Allow EAPOL tx from specific link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Andrei Otcheretianski <andrei.otcheretianski@intel.com>
commit 0d5891e347a4924a6e6fd8e2799e3d3c762983eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0d5891e3.failed

Allow link source address on TX.

	Signed-off-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 0d5891e347a4924a6e6fd8e2799e3d3c762983eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/rx.c
diff --cc net/mac80211/rx.c
index d7c490a8a620,9f1ea8c840e9..000000000000
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@@ -2524,6 -2532,35 +2524,38 @@@ __ieee80211_data_to_8023(struct ieee802
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ bool ieee80211_is_our_addr(struct ieee80211_sub_if_data *sdata,
+ 			   const u8 *addr, int *out_link_id)
+ {
+ 	unsigned int link_id;
+ 
+ 	/* non-MLO, or MLD address replaced by hardware */
+ 	if (ether_addr_equal(sdata->vif.addr, addr))
+ 		return true;
+ 
+ 	if (!sdata->vif.valid_links)
+ 		return false;
+ 
+ 	for (link_id = 0; link_id < ARRAY_SIZE(sdata->vif.link_conf); link_id++) {
+ 		struct ieee80211_bss_conf *conf;
+ 
+ 		conf = rcu_dereference(sdata->vif.link_conf[link_id]);
+ 
+ 		if (!conf)
+ 			continue;
+ 		if (ether_addr_equal(conf->addr, addr)) {
+ 			if (out_link_id)
+ 				*out_link_id = link_id;
+ 			return true;
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 0d5891e347a4 (wifi: mac80211: Allow EAPOL tx from specific link)
  /*
   * requires that rx->skb is a frame with ethernet header
   */
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index fef9c92d74a2..ff350d8bbf2d 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1850,6 +1850,9 @@ void __ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata);
 void ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata);
 void ieee80211_clear_fast_rx(struct sta_info *sta);
 
+bool ieee80211_is_our_addr(struct ieee80211_sub_if_data *sdata,
+			   const u8 *addr, int *out_link_id);
+
 /* STA code */
 void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata);
 int ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,
* Unmerged path net/mac80211/rx.c
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 245049905763..ae62ea212fdf 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2780,7 +2780,7 @@ static struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,
 		     (sdata->vif.type != NL80211_IFTYPE_OCB) &&
 		     !multicast && !authorized &&
 		     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||
-		      !ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN)))) {
+		      !ieee80211_is_our_addr(sdata, skb->data + ETH_ALEN, NULL)))) {
 #ifdef CONFIG_MAC80211_VERBOSE_DEBUG
 		net_info_ratelimited("%s: dropped frame to %pM (unauthorized port)\n",
 				    sdata->name, hdr.addr1);
