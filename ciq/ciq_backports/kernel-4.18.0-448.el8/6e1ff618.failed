ice: fix access-beyond-end in the switch code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Alexander Lobakin <alexandr.lobakin@intel.com>
commit 6e1ff618737a2ffa12191dcd99f83ef07fac2e45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6e1ff618.failed

Global `-Warray-bounds` enablement revealed some problems, one of
which is the way we define and use AQC rules messages.
In fact, they have a shared header, followed by the actual message,
which can be of one of several different formats. So it is
straightforward enough to define that header as a separate struct
and then embed it into message structures as needed, but currently
all the formats reside in one union coupled with the header. Then,
the code allocates only the memory needed for a particular message
format, leaving the union potentially incomplete.
There are no actual reads or writes beyond the end of an allocated
chunk, but at the same time, the whole implementation is fragile and
backed by an equilibrium rather than strong type and memory checks.

Define the structures the other way around: one for the common
header and the rest for the actual formats with the header embedded.
There are no places where several union members would be used at the
same time anyway. This allows to use proper struct_size() and let
the compiler know what is going to be done.
Finally, unsilence `-Warray-bounds` back for ice_switch.c.

Other little things worth mentioning:
* &ice_sw_rule_vsi_list_query is not used anywhere, remove it. It's
  weird anyway to talk to hardware with purely kernel types
  (bitmaps);
* expand the ICE_SW_RULE_*_SIZE() macros to pass a structure
  variable name to struct_size() to let it do strict typechecking;
* rename ice_sw_rule_lkup_rx_tx::hdr to ::hdr_data to keep ::hdr
  for the header structure to have the same name for it constistenly
  everywhere;
* drop the duplicate of %ICE_SW_RULE_RX_TX_NO_HDR_SIZE residing in
  ice_switch.h.

Fixes: 9daf8208dd4d ("ice: Add support for switch filter programming")
Fixes: 66486d8943ba ("ice: replace single-element array used for C struct hack")
	Signed-off-by: Alexander Lobakin <alexandr.lobakin@intel.com>
	Reviewed-by: Marcin Szycik <marcin.szycik@linux.intel.com>
	Acked-by: Tony Nguyen <anthony.l.nguyen@intel.com>
Link: https://lore.kernel.org/r/20220601105924.2841410-1-alexandr.lobakin@intel.com
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 6e1ff618737a2ffa12191dcd99f83ef07fac2e45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_switch.c
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 7b15835f7479,8d8f3eec79ee..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -1215,18 -1233,62 +1215,77 @@@ static const u8 dummy_ipv6_gtp_packet[
  	0x00, 0x00,
  };
  
++<<<<<<< HEAD
 +#define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr) + \
 +	 (DUMMY_ETH_HDR_LEN * \
 +	  sizeof(((struct ice_sw_rule_lkup_rx_tx *)0)->hdr[0])))
 +#define ICE_SW_RULE_RX_TX_NO_HDR_SIZE \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr))
 +#define ICE_SW_RULE_LG_ACT_SIZE(n) \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lg_act.act) + \
 +	 ((n) * sizeof(((struct ice_sw_rule_lg_act *)0)->act[0])))
 +#define ICE_SW_RULE_VSI_LIST_SIZE(n) \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.vsi_list.vsi) + \
 +	 ((n) * sizeof(((struct ice_sw_rule_vsi_list *)0)->vsi[0])))
++=======
+ static const struct ice_dummy_pkt_profile ice_dummy_pkt_profiles[] = {
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPU | ICE_PKT_OUTER_IPV6 |
+ 				  ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPU | ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU),
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPC | ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPC),
+ 	ICE_PKT_PROFILE(gre_ipv6_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6 |
+ 				      ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_ipv6_udp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(gre_udp, ICE_PKT_TUN_NVGRE),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_tcp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6 |
+ 					  ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_tcp, ICE_PKT_TUN_UDP | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_udp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(udp_tun_udp, ICE_PKT_TUN_UDP),
+ 	ICE_PKT_PROFILE(vlan_udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP |
+ 				       ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(vlan_udp, ICE_PKT_INNER_UDP | ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(udp, ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(vlan_tcp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(tcp_ipv6, ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(vlan_tcp, ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(tcp, 0),
+ };
+ 
+ #define ICE_SW_RULE_RX_TX_HDR_SIZE(s, l)	struct_size((s), hdr_data, (l))
+ #define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s)	\
+ 	ICE_SW_RULE_RX_TX_HDR_SIZE((s), DUMMY_ETH_HDR_LEN)
+ #define ICE_SW_RULE_RX_TX_NO_HDR_SIZE(s)	\
+ 	ICE_SW_RULE_RX_TX_HDR_SIZE((s), 0)
+ #define ICE_SW_RULE_LG_ACT_SIZE(s, n)		struct_size((s), act, (n))
+ #define ICE_SW_RULE_VSI_LIST_SIZE(s, n)		struct_size((s), vsi, (n))
++>>>>>>> 6e1ff618737a (ice: fix access-beyond-end in the switch code)
  
  /* this is a recipe to profile association bitmap */
  static DECLARE_BITMAP(recipe_to_profile[ICE_MAX_NUM_RECIPES],
@@@ -2251,9 -2371,11 +2310,10 @@@ static void ice_fill_sw_info(struct ice
   */
  static void
  ice_fill_sw_rule(struct ice_hw *hw, struct ice_fltr_info *f_info,
- 		 struct ice_aqc_sw_rules_elem *s_rule, enum ice_adminq_opc opc)
+ 		 struct ice_sw_rule_lkup_rx_tx *s_rule,
+ 		 enum ice_adminq_opc opc)
  {
  	u16 vlan_id = ICE_MAX_VLAN_ID + 1;
 -	u16 vlan_tpid = ETH_P_8021Q;
  	void *daddr = NULL;
  	u16 eth_hdr_sz;
  	u8 *eth_hdr;
@@@ -5649,9 -5634,8 +5706,14 @@@ ice_find_dummy_packet(struct ice_adv_lk
   */
  static int
  ice_fill_adv_dummy_packet(struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,
++<<<<<<< HEAD
 +			  struct ice_aqc_sw_rules_elem *s_rule,
 +			  const u8 *dummy_pkt, u16 pkt_len,
 +			  const struct ice_dummy_pkt_offsets *offsets)
++=======
+ 			  struct ice_sw_rule_lkup_rx_tx *s_rule,
+ 			  const struct ice_dummy_pkt_profile *profile)
++>>>>>>> 6e1ff618737a (ice: fix access-beyond-end in the switch code)
  {
  	u8 *pkt;
  	u16 i;
@@@ -5659,11 -5643,12 +5721,11 @@@
  	/* Start with a packet with a pre-defined/dummy content. Then, fill
  	 * in the header values to be looked up or matched.
  	 */
- 	pkt = s_rule->pdata.lkup_tx_rx.hdr;
+ 	pkt = s_rule->hdr_data;
  
 -	memcpy(pkt, profile->pkt, profile->pkt_len);
 +	memcpy(pkt, dummy_pkt, pkt_len);
  
  	for (i = 0; i < lkups_cnt; i++) {
 -		const struct ice_dummy_pkt_offsets *offsets = profile->offsets;
  		enum ice_protocol_type type;
  		u16 offset = 0, len = 0, j;
  		bool found = false;
@@@ -5748,7 -5733,7 +5810,11 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	s_rule->pdata.lkup_tx_rx.hdr_len = cpu_to_le16(pkt_len);
++=======
+ 	s_rule->hdr_len = cpu_to_le16(profile->pkt_len);
++>>>>>>> 6e1ff618737a (ice: fix access-beyond-end in the switch code)
  
  	return 0;
  }
@@@ -5971,12 -5956,11 +6037,18 @@@ ice_add_adv_rule(struct ice_hw *hw, str
  		 struct ice_rule_query_data *added_entry)
  {
  	struct ice_adv_fltr_mgmt_list_entry *m_entry, *adv_fltr = NULL;
++<<<<<<< HEAD
 +	u16 rid = 0, i, pkt_len, rule_buf_sz, vsi_handle;
 +	const struct ice_dummy_pkt_offsets *pkt_offsets;
 +	struct ice_aqc_sw_rules_elem *s_rule = NULL;
++=======
+ 	struct ice_sw_rule_lkup_rx_tx *s_rule = NULL;
+ 	const struct ice_dummy_pkt_profile *profile;
+ 	u16 rid = 0, i, rule_buf_sz, vsi_handle;
++>>>>>>> 6e1ff618737a (ice: fix access-beyond-end in the switch code)
  	struct list_head *rule_head;
  	struct ice_switch_info *sw;
 +	const u8 *pkt = NULL;
  	u16 word_cnt;
  	u32 act = 0;
  	int status;
@@@ -6051,7 -6033,7 +6123,11 @@@
  		}
  		return status;
  	}
++<<<<<<< HEAD
 +	rule_buf_sz = ICE_SW_RULE_RX_TX_NO_HDR_SIZE + pkt_len;
++=======
+ 	rule_buf_sz = ICE_SW_RULE_RX_TX_HDR_SIZE(s_rule, profile->pkt_len);
++>>>>>>> 6e1ff618737a (ice: fix access-beyond-end in the switch code)
  	s_rule = kzalloc(rule_buf_sz, GFP_KERNEL);
  	if (!s_rule)
  		return -ENOMEM;
@@@ -6100,27 -6082,25 +6176,31 @@@
  	 * by caller)
  	 */
  	if (rinfo->rx) {
- 		s_rule->type = cpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_RX);
- 		s_rule->pdata.lkup_tx_rx.src =
- 			cpu_to_le16(hw->port_info->lport);
+ 		s_rule->hdr.type = cpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_RX);
+ 		s_rule->src = cpu_to_le16(hw->port_info->lport);
  	} else {
- 		s_rule->type = cpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_TX);
- 		s_rule->pdata.lkup_tx_rx.src = cpu_to_le16(rinfo->sw_act.src);
+ 		s_rule->hdr.type = cpu_to_le16(ICE_AQC_SW_RULES_T_LKUP_TX);
+ 		s_rule->src = cpu_to_le16(rinfo->sw_act.src);
  	}
  
- 	s_rule->pdata.lkup_tx_rx.recipe_id = cpu_to_le16(rid);
- 	s_rule->pdata.lkup_tx_rx.act = cpu_to_le32(act);
+ 	s_rule->recipe_id = cpu_to_le16(rid);
+ 	s_rule->act = cpu_to_le32(act);
  
 -	status = ice_fill_adv_dummy_packet(lkups, lkups_cnt, s_rule, profile);
 +	status = ice_fill_adv_dummy_packet(lkups, lkups_cnt, s_rule, pkt,
 +					   pkt_len, pkt_offsets);
  	if (status)
  		goto err_ice_add_adv_rule;
  
  	if (rinfo->tun_type != ICE_NON_TUN &&
  	    rinfo->tun_type != ICE_SW_TUN_AND_NON_TUN) {
  		status = ice_fill_adv_packet_tun(hw, rinfo->tun_type,
++<<<<<<< HEAD
 +						 s_rule->pdata.lkup_tx_rx.hdr,
 +						 pkt_offsets);
++=======
+ 						 s_rule->hdr_data,
+ 						 profile->offsets);
++>>>>>>> 6e1ff618737a (ice: fix access-beyond-end in the switch code)
  		if (status)
  			goto err_ice_add_adv_rule;
  	}
diff --git a/drivers/net/ethernet/intel/ice/Makefile b/drivers/net/ethernet/intel/ice/Makefile
index e65759e49fad..c36faa7d1471 100644
--- a/drivers/net/ethernet/intel/ice/Makefile
+++ b/drivers/net/ethernet/intel/ice/Makefile
@@ -36,8 +36,3 @@ ice-$(CONFIG_DCB) += ice_dcb.o ice_dcb_nl.o ice_dcb_lib.o
 ice-$(CONFIG_RFS_ACCEL) += ice_arfs.o
 ice-$(CONFIG_XDP_SOCKETS) += ice_xsk.o
 ice-$(CONFIG_ICE_SWITCHDEV) += ice_eswitch.o
-
-# FIXME: temporarily silence -Warray-bounds on non W=1+ builds
-ifndef KBUILD_EXTRA_WARN
-CFLAGS_ice_switch.o += -Wno-array-bounds
-endif
diff --git a/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h b/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
index 476310d43e3b..7521782ee3de 100644
--- a/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
+++ b/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
@@ -539,12 +539,30 @@ struct ice_aqc_sw_rules {
 	__le32 addr_low;
 };
 
+/* Add switch rule response:
+ * Content of return buffer is same as the input buffer. The status field and
+ * LUT index are updated as part of the response
+ */
+struct ice_aqc_sw_rules_elem_hdr {
+	__le16 type; /* Switch rule type, one of T_... */
+#define ICE_AQC_SW_RULES_T_LKUP_RX		0x0
+#define ICE_AQC_SW_RULES_T_LKUP_TX		0x1
+#define ICE_AQC_SW_RULES_T_LG_ACT		0x2
+#define ICE_AQC_SW_RULES_T_VSI_LIST_SET		0x3
+#define ICE_AQC_SW_RULES_T_VSI_LIST_CLEAR	0x4
+#define ICE_AQC_SW_RULES_T_PRUNE_LIST_SET	0x5
+#define ICE_AQC_SW_RULES_T_PRUNE_LIST_CLEAR	0x6
+	__le16 status;
+} __packed __aligned(sizeof(__le16));
+
 /* Add/Update/Get/Remove lookup Rx/Tx command/response entry
  * This structures describes the lookup rules and associated actions. "index"
  * is returned as part of a response to a successful Add command, and can be
  * used to identify the rule for Update/Get/Remove commands.
  */
 struct ice_sw_rule_lkup_rx_tx {
+	struct ice_aqc_sw_rules_elem_hdr hdr;
+
 	__le16 recipe_id;
 #define ICE_SW_RECIPE_LOGICAL_PORT_FWD		10
 	/* Source port for LOOKUP_RX and source VSI in case of LOOKUP_TX */
@@ -621,14 +639,16 @@ struct ice_sw_rule_lkup_rx_tx {
 	 * lookup-type
 	 */
 	__le16 hdr_len;
-	u8 hdr[];
-};
+	u8 hdr_data[];
+} __packed __aligned(sizeof(__le16));
 
 /* Add/Update/Remove large action command/response entry
  * "index" is returned as part of a response to a successful Add command, and
  * can be used to identify the action for Update/Get/Remove commands.
  */
 struct ice_sw_rule_lg_act {
+	struct ice_aqc_sw_rules_elem_hdr hdr;
+
 	__le16 index; /* Index in large action table */
 	__le16 size;
 	/* Max number of large actions */
@@ -682,45 +702,19 @@ struct ice_sw_rule_lg_act {
 #define ICE_LG_ACT_STAT_COUNT_S		3
 #define ICE_LG_ACT_STAT_COUNT_M		(0x7F << ICE_LG_ACT_STAT_COUNT_S)
 	__le32 act[]; /* array of size for actions */
-};
+} __packed __aligned(sizeof(__le16));
 
 /* Add/Update/Remove VSI list command/response entry
  * "index" is returned as part of a response to a successful Add command, and
  * can be used to identify the VSI list for Update/Get/Remove commands.
  */
 struct ice_sw_rule_vsi_list {
+	struct ice_aqc_sw_rules_elem_hdr hdr;
+
 	__le16 index; /* Index of VSI/Prune list */
 	__le16 number_vsi;
 	__le16 vsi[]; /* Array of number_vsi VSI numbers */
-};
-
-/* Query VSI list command/response entry */
-struct ice_sw_rule_vsi_list_query {
-	__le16 index;
-	DECLARE_BITMAP(vsi_list, ICE_MAX_VSI);
-} __packed;
-
-/* Add switch rule response:
- * Content of return buffer is same as the input buffer. The status field and
- * LUT index are updated as part of the response
- */
-struct ice_aqc_sw_rules_elem {
-	__le16 type; /* Switch rule type, one of T_... */
-#define ICE_AQC_SW_RULES_T_LKUP_RX		0x0
-#define ICE_AQC_SW_RULES_T_LKUP_TX		0x1
-#define ICE_AQC_SW_RULES_T_LG_ACT		0x2
-#define ICE_AQC_SW_RULES_T_VSI_LIST_SET		0x3
-#define ICE_AQC_SW_RULES_T_VSI_LIST_CLEAR	0x4
-#define ICE_AQC_SW_RULES_T_PRUNE_LIST_SET	0x5
-#define ICE_AQC_SW_RULES_T_PRUNE_LIST_CLEAR	0x6
-	__le16 status;
-	union {
-		struct ice_sw_rule_lkup_rx_tx lkup_tx_rx;
-		struct ice_sw_rule_lg_act lg_act;
-		struct ice_sw_rule_vsi_list vsi_list;
-		struct ice_sw_rule_vsi_list_query vsi_list_query;
-	} __packed pdata;
-};
+} __packed __aligned(sizeof(__le16));
 
 /* Query PFC Mode (direct 0x0302)
  * Set PFC Mode (direct 0x0303)
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
diff --git a/drivers/net/ethernet/intel/ice/ice_switch.h b/drivers/net/ethernet/intel/ice/ice_switch.h
index 31b8b006b339..709f20990a85 100644
--- a/drivers/net/ethernet/intel/ice/ice_switch.h
+++ b/drivers/net/ethernet/intel/ice/ice_switch.h
@@ -23,9 +23,6 @@
 #define ICE_PROFID_IPV6_GTPU_TEID			46
 #define ICE_PROFID_IPV6_GTPU_IPV6_TCP_INNER		70
 
-#define ICE_SW_RULE_RX_TX_NO_HDR_SIZE \
-	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr))
-
 /* VSI context structure for add/get/update/free operations */
 struct ice_vsi_ctx {
 	u16 vsi_num;
