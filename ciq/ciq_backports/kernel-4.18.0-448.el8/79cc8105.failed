mm, oom: fix missing tlb_finish_mmu() in __oom_reap_task_mm().

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
commit 79cc81057eef7ad846588976296ab0f266c1a7a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/79cc8105.failed

Commit 93065ac753e4 ("mm, oom: distinguish blockable mode for mmu
notifiers") has added an ability to skip over vmas with blockable mmu
notifiers. This however didn't call tlb_finish_mmu as it should.

As a result inc_tlb_flush_pending has been called without its pairing
dec_tlb_flush_pending and all callers mm_tlb_flush_pending would flush
even though this is not really needed.  This alone is not harmful and it
seems there shouldn't be any such callers for oom victims at all but
there is no real reason to skip tlb_finish_mmu on early skip either so
call it.

[mhocko@suse.com: new changelog]
Link: http://lkml.kernel.org/r/b752d1d5-81ad-7a35-2394-7870641be51c@i-love.sakura.ne.jp
	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: David Rientjes <rientjes@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 79cc81057eef7ad846588976296ab0f266c1a7a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/oom_kill.c
diff --cc mm/oom_kill.c
index 4952564ef199,f10aa5360616..000000000000
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@@ -529,14 -516,13 +529,20 @@@ bool __oom_reap_task_mm(struct mm_struc
  		 * count elevated without a good reason.
  		 */
  		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
 -			const unsigned long start = vma->vm_start;
 -			const unsigned long end = vma->vm_end;
 +			struct mmu_notifier_range range;
  			struct mmu_gather tlb;
  
++<<<<<<< HEAD
 +			mmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0,
 +						vma, mm, vma->vm_start,
 +						vma->vm_end);
 +			tlb_gather_mmu(&tlb, mm, range.start, range.end);
 +			if (mmu_notifier_invalidate_range_start_nonblock(&range)) {
++=======
+ 			tlb_gather_mmu(&tlb, mm, start, end);
+ 			if (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {
+ 				tlb_finish_mmu(&tlb, start, end);
++>>>>>>> 79cc81057eef (mm, oom: fix missing tlb_finish_mmu() in __oom_reap_task_mm().)
  				ret = false;
  				continue;
  			}
* Unmerged path mm/oom_kill.c
