ath11k: Move parameters in bus_params to hw_params

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
commit 92c1858e4399edc093a41cbf8f74874bdab59da7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/92c1858e.failed

In ath11k, bus_params were added with an intention to hold
parameters related to bus (AHB/PCI), but this is not true
as some bus parameters being different between chipsets of
the same bus.

With the addition of WCN6750 to ath11k, bus parameters are
going to be entirely different among AHB devices. Therefore,
it is wise to move bus_params to hw_params and get rid of
bus_params entirely.

Also, mhi_support parameter is not used anywhere in the driver,
remove it from bus_params.

Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1

	Signed-off-by: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
	Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
Link: https://lore.kernel.org/r/20220429170502.20080-3-quic_mpubbise@quicinc.com
(cherry picked from commit 92c1858e4399edc093a41cbf8f74874bdab59da7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/ath11k/core.h
#	drivers/net/wireless/ath/ath11k/pci.c
#	drivers/net/wireless/ath/ath11k/pcic.c
diff --cc drivers/net/wireless/ath/ath11k/core.h
index f3d02f55f8ea,d8ab28413d95..000000000000
--- a/drivers/net/wireless/ath/ath11k/core.h
+++ b/drivers/net/wireless/ath/ath11k/core.h
@@@ -700,12 -748,12 +700,21 @@@ struct ath11k_board_data 
  	size_t len;
  };
  
++<<<<<<< HEAD
 +struct ath11k_bus_params {
 +	bool mhi_support;
 +	bool m3_fw_support;
 +	bool fixed_bdf_addr;
 +	bool fixed_mem_region;
 +	bool static_window_map;
++=======
+ struct ath11k_pci_ops {
+ 	int (*wakeup)(struct ath11k_base *ab);
+ 	void (*release)(struct ath11k_base *ab);
+ 	int (*get_msi_irq)(struct ath11k_base *ab, unsigned int vector);
+ 	void (*window_write32)(struct ath11k_base *ab, u32 offset, u32 value);
+ 	u32 (*window_read32)(struct ath11k_base *ab, u32 offset);
++>>>>>>> 92c1858e4399 (ath11k: Move parameters in bus_params to hw_params)
  };
  
  /* IPQ8074 HW channel counters frequency value in hertz */
diff --cc drivers/net/wireless/ath/ath11k/pci.c
index ae4b3aa98fc3,dedf1b88ddf6..000000000000
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@@ -145,6 -66,66 +145,69 @@@ static inline void ath11k_pci_select_wi
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ ath11k_pci_window_write32(struct ath11k_base *ab, u32 offset, u32 value)
+ {
+ 	struct ath11k_pci *ab_pci = ath11k_pci_priv(ab);
+ 	u32 window_start = ATH11K_PCI_WINDOW_START;
+ 
+ 	spin_lock_bh(&ab_pci->window_lock);
+ 	ath11k_pci_select_window(ab_pci, offset);
+ 	iowrite32(value, ab->mem + window_start +
+ 		  (offset & ATH11K_PCI_WINDOW_RANGE_MASK));
+ 	spin_unlock_bh(&ab_pci->window_lock);
+ }
+ 
+ static u32 ath11k_pci_window_read32(struct ath11k_base *ab, u32 offset)
+ {
+ 	struct ath11k_pci *ab_pci = ath11k_pci_priv(ab);
+ 	u32 window_start = ATH11K_PCI_WINDOW_START;
+ 	u32 val;
+ 
+ 	spin_lock_bh(&ab_pci->window_lock);
+ 	ath11k_pci_select_window(ab_pci, offset);
+ 	val = ioread32(ab->mem + window_start +
+ 		       (offset & ATH11K_PCI_WINDOW_RANGE_MASK));
+ 	spin_unlock_bh(&ab_pci->window_lock);
+ 
+ 	return val;
+ }
+ 
+ int ath11k_pci_get_msi_irq(struct ath11k_base *ab, unsigned int vector)
+ {
+ 	struct pci_dev *pci_dev = to_pci_dev(ab->dev);
+ 
+ 	return pci_irq_vector(pci_dev, vector);
+ }
+ 
+ static const struct ath11k_pci_ops ath11k_pci_ops_qca6390 = {
+ 	.wakeup = ath11k_pci_bus_wake_up,
+ 	.release = ath11k_pci_bus_release,
+ 	.get_msi_irq = ath11k_pci_get_msi_irq,
+ 	.window_write32 = ath11k_pci_window_write32,
+ 	.window_read32 = ath11k_pci_window_read32,
+ };
+ 
+ static const struct ath11k_pci_ops ath11k_pci_ops_qcn9074 = {
+ 	.get_msi_irq = ath11k_pci_get_msi_irq,
+ 	.window_write32 = ath11k_pci_window_write32,
+ 	.window_read32 = ath11k_pci_window_read32,
+ };
+ 
+ static const struct ath11k_msi_config msi_config_one_msi = {
+ 	.total_vectors = 1,
+ 	.total_users = 4,
+ 	.users = (struct ath11k_msi_user[]) {
+ 		{ .name = "MHI", .num_vectors = 3, .base_vector = 0 },
+ 		{ .name = "CE", .num_vectors = 1, .base_vector = 0 },
+ 		{ .name = "WAKE", .num_vectors = 1, .base_vector = 0 },
+ 		{ .name = "DP", .num_vectors = 1, .base_vector = 0 },
+ 	},
+ };
+ 
++>>>>>>> 92c1858e4399 (ath11k: Move parameters in bus_params to hw_params)
  static inline void ath11k_pci_select_static_window(struct ath11k_pci *ab_pci)
  {
  	u32 umac_window;
@@@ -1404,11 -753,11 +1467,15 @@@ static int ath11k_pci_probe(struct pci_
  			ret = -EOPNOTSUPP;
  			goto err_pci_free_region;
  		}
 -
 -		ab->pci.ops = &ath11k_pci_ops_qca6390;
 +		ab_pci->msi_config = &ath11k_msi_config[0];
  		break;
  	case QCN9074_DEVICE_ID:
++<<<<<<< HEAD
 +		ab_pci->msi_config = &ath11k_msi_config[1];
 +		ab->bus_params.static_window_map = true;
++=======
+ 		ab->pci.ops = &ath11k_pci_ops_qcn9074;
++>>>>>>> 92c1858e4399 (ath11k: Move parameters in bus_params to hw_params)
  		ab->hw_rev = ATH11K_HW_QCN9074_HW10;
  		break;
  	case WCN6855_DEVICE_ID:
* Unmerged path drivers/net/wireless/ath/ath11k/pcic.c
diff --git a/drivers/net/wireless/ath/ath11k/ahb.c b/drivers/net/wireless/ath/ath11k/ahb.c
index c7ff98b317b6..d4d2a6843d1d 100644
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: BSD-3-Clause-Clear
 /*
  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -28,13 +29,6 @@ static const struct of_device_id ath11k_ahb_of_match[] = {
 
 MODULE_DEVICE_TABLE(of, ath11k_ahb_of_match);
 
-static const struct ath11k_bus_params ath11k_ahb_bus_params = {
-	.mhi_support = false,
-	.m3_fw_support = false,
-	.fixed_bdf_addr = true,
-	.fixed_mem_region = true,
-};
-
 #define ATH11K_IRQ_CE0_OFFSET 4
 
 static const char *irq_name[ATH11K_IRQ_NUM_MAX] = {
@@ -686,8 +680,7 @@ static int ath11k_ahb_probe(struct platform_device *pdev)
 	}
 
 	ab = ath11k_core_alloc(&pdev->dev, sizeof(struct ath11k_ahb),
-			       ATH11K_BUS_AHB,
-			       &ath11k_ahb_bus_params);
+			       ATH11K_BUS_AHB);
 	if (!ab) {
 		dev_err(&pdev->dev, "failed to allocate ath11k base\n");
 		return -ENOMEM;
diff --git a/drivers/net/wireless/ath/ath11k/core.c b/drivers/net/wireless/ath/ath11k/core.c
index 241b5e0c8d3f..a7bdd55d28fd 100644
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -102,6 +102,10 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.dbr_debug_support = true,
 		.global_reset = false,
 		.bios_sar_capa = NULL,
+		.m3_fw_support = false,
+		.fixed_bdf_addr = true,
+		.fixed_mem_region = true,
+		.static_window_map = false,
 	},
 	{
 		.hw_rev = ATH11K_HW_IPQ6018_HW10,
@@ -170,6 +174,10 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.dbr_debug_support = true,
 		.global_reset = false,
 		.bios_sar_capa = NULL,
+		.m3_fw_support = false,
+		.fixed_bdf_addr = true,
+		.fixed_mem_region = true,
+		.static_window_map = false,
 	},
 	{
 		.name = "qca6390 hw2.0",
@@ -237,6 +245,10 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.dbr_debug_support = false,
 		.global_reset = true,
 		.bios_sar_capa = NULL,
+		.m3_fw_support = true,
+		.fixed_bdf_addr = false,
+		.fixed_mem_region = false,
+		.static_window_map = false,
 	},
 	{
 		.name = "qcn9074 hw1.0",
@@ -304,6 +316,10 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.dbr_debug_support = true,
 		.global_reset = false,
 		.bios_sar_capa = NULL,
+		.m3_fw_support = true,
+		.fixed_bdf_addr = false,
+		.fixed_mem_region = false,
+		.static_window_map = true,
 	},
 	{
 		.name = "wcn6855 hw2.0",
@@ -371,6 +387,10 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.dbr_debug_support = false,
 		.global_reset = true,
 		.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,
+		.m3_fw_support = true,
+		.fixed_bdf_addr = false,
+		.fixed_mem_region = false,
+		.static_window_map = false,
 	},
 	{
 		.name = "wcn6855 hw2.1",
@@ -437,6 +457,10 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.dbr_debug_support = false,
 		.global_reset = true,
 		.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,
+		.m3_fw_support = true,
+		.fixed_bdf_addr = false,
+		.fixed_mem_region = false,
+		.static_window_map = false,
 	},
 };
 
@@ -1645,8 +1669,7 @@ void ath11k_core_free(struct ath11k_base *ab)
 EXPORT_SYMBOL(ath11k_core_free);
 
 struct ath11k_base *ath11k_core_alloc(struct device *dev, size_t priv_size,
-				      enum ath11k_bus bus,
-				      const struct ath11k_bus_params *bus_params)
+				      enum ath11k_bus bus)
 {
 	struct ath11k_base *ab;
 
@@ -1684,7 +1707,6 @@ struct ath11k_base *ath11k_core_alloc(struct device *dev, size_t priv_size,
 	init_completion(&ab->wow.wakeup_completed);
 
 	ab->dev = dev;
-	ab->bus_params = *bus_params;
 	ab->hif.bus = bus;
 
 	return ab;
* Unmerged path drivers/net/wireless/ath/ath11k/core.h
diff --git a/drivers/net/wireless/ath/ath11k/hw.h b/drivers/net/wireless/ath/ath11k/hw.h
index 29546d8de738..9223434e0f20 100644
--- a/drivers/net/wireless/ath/ath11k/hw.h
+++ b/drivers/net/wireless/ath/ath11k/hw.h
@@ -196,6 +196,10 @@ struct ath11k_hw_params {
 	bool dbr_debug_support;
 	bool global_reset;
 	const struct cfg80211_sar_capa *bios_sar_capa;
+	bool m3_fw_support;
+	bool fixed_bdf_addr;
+	bool fixed_mem_region;
+	bool static_window_map;
 };
 
 struct ath11k_hw_ops {
* Unmerged path drivers/net/wireless/ath/ath11k/pci.c
* Unmerged path drivers/net/wireless/ath/ath11k/pcic.c
diff --git a/drivers/net/wireless/ath/ath11k/qmi.c b/drivers/net/wireless/ath/ath11k/qmi.c
index ffb8aa7dfb02..65e078e75781 100644
--- a/drivers/net/wireless/ath/ath11k/qmi.c
+++ b/drivers/net/wireless/ath/ath11k/qmi.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: BSD-3-Clause-Clear
 /*
  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/elf.h>
@@ -1648,7 +1649,7 @@ static int ath11k_qmi_host_cap_send(struct ath11k_base *ab)
 	req.bdf_support_valid = 1;
 	req.bdf_support = 1;
 
-	if (ab->bus_params.m3_fw_support) {
+	if (ab->hw_params.m3_fw_support) {
 		req.m3_support_valid = 1;
 		req.m3_support = 1;
 		req.m3_cache_support_valid = 1;
@@ -1803,7 +1804,7 @@ static int ath11k_qmi_respond_fw_mem_request(struct ath11k_base *ab)
 	 * failure to FW and FW will then request mulitple blocks of small
 	 * chunk size memory.
 	 */
-	if (!(ab->bus_params.fixed_mem_region ||
+	if (!(ab->hw_params.fixed_mem_region ||
 	      test_bit(ATH11K_FLAG_FIXED_MEM_RGN, &ab->dev_flags)) &&
 	      ab->qmi.target_mem_delayed) {
 		delayed = true;
@@ -1873,7 +1874,7 @@ static void ath11k_qmi_free_target_mem_chunk(struct ath11k_base *ab)
 	int i;
 
 	for (i = 0; i < ab->qmi.mem_seg_count; i++) {
-		if ((ab->bus_params.fixed_mem_region ||
+		if ((ab->hw_params.fixed_mem_region ||
 		     test_bit(ATH11K_FLAG_FIXED_MEM_RGN, &ab->dev_flags)) &&
 		     ab->qmi.target_mem[i].iaddr)
 			iounmap(ab->qmi.target_mem[i].iaddr);
@@ -2120,7 +2121,7 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 
 	memset(&resp, 0, sizeof(resp));
 
-	if (ab->bus_params.fixed_bdf_addr) {
+	if (ab->hw_params.fixed_bdf_addr) {
 		bdf_addr = ioremap(ab->hw_params.bdf_addr, ab->hw_params.fw.board_size);
 		if (!bdf_addr) {
 			ath11k_warn(ab, "qmi ioremap error for bdf_addr\n");
@@ -2149,7 +2150,7 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 			req->end = 1;
 		}
 
-		if (ab->bus_params.fixed_bdf_addr ||
+		if (ab->hw_params.fixed_bdf_addr ||
 		    type == ATH11K_QMI_FILE_TYPE_EEPROM) {
 			req->data_valid = 0;
 			req->end = 1;
@@ -2158,7 +2159,7 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 			memcpy(req->data, temp, req->data_len);
 		}
 
-		if (ab->bus_params.fixed_bdf_addr) {
+		if (ab->hw_params.fixed_bdf_addr) {
 			if (type == ATH11K_QMI_FILE_TYPE_CALDATA)
 				bdf_addr += ab->hw_params.fw.cal_offset;
 
@@ -2197,7 +2198,7 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 			goto err_iounmap;
 		}
 
-		if (ab->bus_params.fixed_bdf_addr ||
+		if (ab->hw_params.fixed_bdf_addr ||
 		    type == ATH11K_QMI_FILE_TYPE_EEPROM) {
 			remaining = 0;
 		} else {
@@ -2210,7 +2211,7 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 	}
 
 err_iounmap:
-	if (ab->bus_params.fixed_bdf_addr)
+	if (ab->hw_params.fixed_bdf_addr)
 		iounmap(bdf_addr);
 
 err_free_req:
@@ -2349,7 +2350,7 @@ static void ath11k_qmi_m3_free(struct ath11k_base *ab)
 {
 	struct m3_mem_region *m3_mem = &ab->qmi.m3_mem;
 
-	if (!ab->bus_params.m3_fw_support || !m3_mem->vaddr)
+	if (!ab->hw_params.m3_fw_support || !m3_mem->vaddr)
 		return;
 
 	dma_free_coherent(ab->dev, m3_mem->size,
@@ -2369,7 +2370,7 @@ static int ath11k_qmi_wlanfw_m3_info_send(struct ath11k_base *ab)
 	memset(&req, 0, sizeof(req));
 	memset(&resp, 0, sizeof(resp));
 
-	if (ab->bus_params.m3_fw_support) {
+	if (ab->hw_params.m3_fw_support) {
 		ret = ath11k_qmi_m3_load(ab);
 		if (ret) {
 			ath11k_err(ab, "failed to load m3 firmware: %d", ret);
@@ -2788,7 +2789,7 @@ static void ath11k_qmi_msg_mem_request_cb(struct qmi_handle *qmi_hdl,
 			   msg->mem_seg[i].type, msg->mem_seg[i].size);
 	}
 
-	if (ab->bus_params.fixed_mem_region ||
+	if (ab->hw_params.fixed_mem_region ||
 	    test_bit(ATH11K_FLAG_FIXED_MEM_RGN, &ab->dev_flags)) {
 		ret = ath11k_qmi_assign_target_mem_chunk(ab);
 		if (ret) {
