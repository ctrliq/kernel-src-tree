raw: fix a typo in raw_icmp_error()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 97a4d46b1516250d640c1ae0c9e7129d160d6a1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/97a4d46b.failed

I accidentally broke IPv4 traceroute, by swapping iph->saddr
and iph->daddr.

Probably because raw_icmp_error() and raw_v4_input()
use different order for iph->saddr and iph->daddr.

Fixes: ba44f8182ec2 ("raw: use more conventional iterators")
	Reported-by: John Sperbeck <jsperbeck@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/20220623193540.2851799-1-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 97a4d46b1516250d640c1ae0c9e7129d160d6a1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/raw.c
diff --cc net/ipv4/raw.c
index 946f8761caa1,006c1f0ed8b4..000000000000
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@@ -290,31 -262,27 +290,38 @@@ static void raw_err(struct sock *sk, st
  
  void raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)
  {
 -	struct net *net = dev_net(skb->dev);
 -	struct hlist_nulls_head *hlist;
 -	struct hlist_nulls_node *hnode;
 -	int dif = skb->dev->ifindex;
 -	int sdif = inet_sdif(skb);
 -	const struct iphdr *iph;
 -	struct sock *sk;
  	int hash;
 +	struct sock *raw_sk;
 +	const struct iphdr *iph;
 +	struct net *net;
  
  	hash = protocol & (RAW_HTABLE_SIZE - 1);
 -	hlist = &raw_v4_hashinfo.ht[hash];
  
 -	rcu_read_lock();
 -	sk_nulls_for_each(sk, hnode, hlist) {
 +	read_lock(&raw_v4_hashinfo.lock);
 +	raw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);
 +	if (raw_sk) {
 +		int dif = skb->dev->ifindex;
 +		int sdif = inet_sdif(skb);
 +
  		iph = (const struct iphdr *)skb->data;
++<<<<<<< HEAD
 +		net = dev_net(skb->dev);
 +
 +		while ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,
 +						iph->daddr, iph->saddr,
 +						dif, sdif)) != NULL) {
 +			raw_err(raw_sk, skb, info);
 +			raw_sk = sk_next(raw_sk);
 +			iph = (const struct iphdr *)skb->data;
 +		}
++=======
+ 		if (!raw_v4_match(net, sk, iph->protocol,
+ 				  iph->daddr, iph->saddr, dif, sdif))
+ 			continue;
+ 		raw_err(sk, skb, info);
++>>>>>>> 97a4d46b1516 (raw: fix a typo in raw_icmp_error())
  	}
 -	rcu_read_unlock();
 +	read_unlock(&raw_v4_hashinfo.lock);
  }
  
  static int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)
* Unmerged path net/ipv4/raw.c
