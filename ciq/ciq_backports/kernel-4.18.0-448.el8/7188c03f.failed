scsi: mpi3mr: Enable Enclosure device add event

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit 7188c03ff8849cebdc3a88a3f3af1436c8ba8155
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7188c03f.failed

Enable and process the Enclosure device add event.

Link: https://lore.kernel.org/r/20220804131226.16653-5-sreekanth.reddy@broadcom.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7188c03ff8849cebdc3a88a3f3af1436c8ba8155)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_os.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 8de3e5650c79,542b4624c19c..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -425,6 -437,41 +425,44 @@@ struct mpi3mr_intr_info 
  };
  
  /**
++<<<<<<< HEAD
++=======
+  * struct mpi3mr_throttle_group_info - Throttle group info
+  *
+  * @io_divert: Flag indicates io divert is on or off for the TG
+  * @need_qd_reduction: Flag to indicate QD reduction is needed
+  * @qd_reduction: Queue Depth reduction in units of 10%
+  * @fw_qd: QueueDepth value reported by the firmware
+  * @modified_qd: Modified QueueDepth value due to throttling
+  * @id: Throttle Group ID.
+  * @high: High limit to turn on throttling in 512 byte blocks
+  * @low: Low limit to turn off throttling in 512 byte blocks
+  * @pend_large_data_sz: Counter to track pending large data
+  */
+ struct mpi3mr_throttle_group_info {
+ 	u8 io_divert;
+ 	u8 need_qd_reduction;
+ 	u8 qd_reduction;
+ 	u16 fw_qd;
+ 	u16 modified_qd;
+ 	u16 id;
+ 	u32 high;
+ 	u32 low;
+ 	atomic_t pend_large_data_sz;
+ };
+ 
+ /**
+  * struct mpi3mr_enclosure_node - enclosure information
+  * @list: List of enclosures
+  * @pg0: Enclosure page 0;
+  */
+ struct mpi3mr_enclosure_node {
+ 	struct list_head list;
+ 	struct mpi3_enclosure_page0 pg0;
+ };
+ 
+ /**
++>>>>>>> 7188c03ff884 (scsi: mpi3mr: Enable Enclosure device add event)
   * struct tgt_dev_sas_sata - SAS/SATA device specific
   * information cached from firmware given data
   *
@@@ -490,8 -549,10 +529,9 @@@ union _form_spec_inf 
   * @dev_type: SAS/SATA/PCIE device type
   * @is_hidden: Should be exposed to upper layers or not
   * @host_exposed: Already exposed to host or not
 - * @io_throttle_enabled: I/O throttling needed or not
   * @q_depth: Device specific Queue Depth
   * @wwid: World wide ID
+  * @enclosure_logical_id: Enclosure logical identifier
   * @dev_spec: Device type specific information
   * @ref_count: Reference count
   */
@@@ -506,8 -568,10 +547,9 @@@ struct mpi3mr_tgt_dev 
  	u8 dev_type;
  	u8 is_hidden;
  	u8 host_exposed;
 -	u8 io_throttle_enabled;
  	u16 q_depth;
  	u64 wwid;
+ 	u64 enclosure_logical_id;
  	union _form_spec_inf dev_spec;
  	struct kref ref_count;
  };
@@@ -796,6 -882,16 +838,19 @@@ struct scmd_priv 
   * @logdata_buf: Circular buffer to store log data entries
   * @logdata_buf_idx: Index of entry in buffer to store
   * @logdata_entry_sz: log data entry size
++<<<<<<< HEAD
++=======
+  * @pend_large_data_sz: Counter to track pending large data
+  * @io_throttle_data_length: I/O size to track in 512b blocks
+  * @io_throttle_high: I/O size to start throttle in 512b blocks
+  * @io_throttle_low: I/O size to stop throttle in 512b blocks
+  * @num_io_throttle_group: Maximum number of throttle groups
+  * @throttle_groups: Pointer to throttle group info structures
+  * @cfg_page: Default memory for configuration pages
+  * @cfg_page_dma: Configuration page DMA address
+  * @cfg_page_sz: Default configuration page memory size
+  * @enclosure_list: List of Enclosure objects
++>>>>>>> 7188c03ff884 (scsi: mpi3mr: Enable Enclosure device add event)
   */
  struct mpi3mr_ioc {
  	struct list_head list;
@@@ -960,6 -1057,19 +1015,22 @@@
  	u8 *logdata_buf;
  	u16 logdata_buf_idx;
  	u16 logdata_entry_sz;
++<<<<<<< HEAD
++=======
+ 
+ 	atomic_t pend_large_data_sz;
+ 	u32 io_throttle_data_length;
+ 	u32 io_throttle_high;
+ 	u32 io_throttle_low;
+ 	u16 num_io_throttle_group;
+ 	struct mpi3mr_throttle_group_info *throttle_groups;
+ 
+ 	void *cfg_page;
+ 	dma_addr_t cfg_page_dma;
+ 	u16 cfg_page_sz;
+ 
+ 	struct list_head enclosure_list;
++>>>>>>> 7188c03ff884 (scsi: mpi3mr: Enable Enclosure device add event)
  };
  
  /**
@@@ -1084,6 -1194,34 +1155,12 @@@ int mpi3mr_pel_get_seqnum_post(struct m
  	struct mpi3mr_drv_cmd *drv_cmd);
  void mpi3mr_app_save_logdata(struct mpi3mr_ioc *mrioc, char *event_data,
  	u16 event_data_size);
++<<<<<<< HEAD
 +extern struct device_attribute *mpi3mr_host_attrs[];
++=======
+ struct mpi3mr_enclosure_node *mpi3mr_enclosure_find_by_handle(
+ 	struct mpi3mr_ioc *mrioc, u16 handle);
+ extern const struct attribute_group *mpi3mr_host_groups[];
++>>>>>>> 7188c03ff884 (scsi: mpi3mr: Enable Enclosure device add event)
  extern const struct attribute_group *mpi3mr_dev_groups[];
 -
 -int mpi3mr_cfg_get_dev_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
 -	struct mpi3_device_page0 *dev_pg0, u16 pg_sz, u32 form, u32 form_spec);
 -int mpi3mr_cfg_get_sas_phy_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
 -	struct mpi3_sas_phy_page0 *phy_pg0, u16 pg_sz, u32 form,
 -	u32 form_spec);
 -int mpi3mr_cfg_get_sas_phy_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
 -	struct mpi3_sas_phy_page1 *phy_pg1, u16 pg_sz, u32 form,
 -	u32 form_spec);
 -int mpi3mr_cfg_get_sas_exp_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
 -	struct mpi3_sas_expander_page0 *exp_pg0, u16 pg_sz, u32 form,
 -	u32 form_spec);
 -int mpi3mr_cfg_get_sas_exp_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
 -	struct mpi3_sas_expander_page1 *exp_pg1, u16 pg_sz, u32 form,
 -	u32 form_spec);
 -int mpi3mr_cfg_get_enclosure_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
 -	struct mpi3_enclosure_page0 *encl_pg0, u16 pg_sz, u32 form,
 -	u32 form_spec);
 -int mpi3mr_cfg_get_sas_io_unit_pg0(struct mpi3mr_ioc *mrioc,
 -	struct mpi3_sas_io_unit_page0 *sas_io_unit_pg0, u16 pg_sz);
 -int mpi3mr_cfg_get_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
 -	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
 -int mpi3mr_cfg_set_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
 -	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
 -int mpi3mr_cfg_get_driver_pg1(struct mpi3mr_ioc *mrioc,
 -	struct mpi3_driver_page1 *driver_pg1, u16 pg_sz);
  #endif /*MPI3MR_H_INCLUDED*/
diff --cc drivers/scsi/mpi3mr/mpi3mr_os.c
index c851b53cb9f5,18a9bd02a953..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@@ -941,10 -1013,12 +941,15 @@@ void mpi3mr_rfresh_tgtdevs(struct mpi3m
   * Return: Nothing.
   */
  static void mpi3mr_update_tgtdev(struct mpi3mr_ioc *mrioc,
 -	struct mpi3mr_tgt_dev *tgtdev, struct mpi3_device_page0 *dev_pg0,
 -	bool is_added)
 +	struct mpi3mr_tgt_dev *tgtdev, struct mpi3_device_page0 *dev_pg0)
  {
  	u16 flags = 0;
++<<<<<<< HEAD
 +	struct mpi3mr_stgt_priv_data *scsi_tgt_priv_data;
++=======
+ 	struct mpi3mr_stgt_priv_data *scsi_tgt_priv_data = NULL;
+ 	struct mpi3mr_enclosure_node *enclosure_dev = NULL;
++>>>>>>> 7188c03ff884 (scsi: mpi3mr: Enable Enclosure device add event)
  	u8 prot_mask = 0;
  
  	tgtdev->perst_id = le16_to_cpu(dev_pg0->persistent_id);
@@@ -955,10 -1029,24 +960,19 @@@
  	tgtdev->slot = le16_to_cpu(dev_pg0->slot);
  	tgtdev->q_depth = le16_to_cpu(dev_pg0->queue_depth);
  	tgtdev->wwid = le64_to_cpu(dev_pg0->wwid);
+ 	tgtdev->devpg0_flag = le16_to_cpu(dev_pg0->flags);
+ 
+ 	if (tgtdev->encl_handle)
+ 		enclosure_dev = mpi3mr_enclosure_find_by_handle(mrioc,
+ 		    tgtdev->encl_handle);
+ 	if (enclosure_dev)
+ 		tgtdev->enclosure_logical_id = le64_to_cpu(
+ 		    enclosure_dev->pg0.enclosure_logical_id);
+ 
+ 	flags = tgtdev->devpg0_flag;
  
- 	flags = le16_to_cpu(dev_pg0->flags);
  	tgtdev->is_hidden = (flags & MPI3_DEVICE0_FLAGS_HIDDEN);
  
 -	if (is_added == true)
 -		tgtdev->io_throttle_enabled =
 -		    (flags & MPI3_DEVICE0_FLAGS_IO_THROTTLING_REQUIRED) ? 1 : 0;
 -
 -
  	if (tgtdev->starget && tgtdev->starget->hostdata) {
  		scsi_tgt_priv_data = (struct mpi3mr_stgt_priv_data *)
  		    tgtdev->starget->hostdata;
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
diff --git a/drivers/scsi/mpi3mr/mpi3mr_fw.c b/drivers/scsi/mpi3mr/mpi3mr_fw.c
index a891e8c285f7..5591f6cac48e 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@ -244,6 +244,9 @@ static void mpi3mr_print_event_data(struct mpi3mr_ioc *mrioc,
 	case MPI3_EVENT_ENCL_DEVICE_STATUS_CHANGE:
 		desc = "Enclosure Device Status Change";
 		break;
+	case MPI3_EVENT_ENCL_DEVICE_ADDED:
+		desc = "Enclosure Added";
+		break;
 	case MPI3_EVENT_HARD_RESET_RECEIVED:
 		desc = "Hard Reset Received";
 		break;
@@ -3643,6 +3646,7 @@ static int mpi3mr_enable_events(struct mpi3mr_ioc *mrioc)
 	mpi3mr_unmask_events(mrioc, MPI3_EVENT_DEVICE_INFO_CHANGED);
 	mpi3mr_unmask_events(mrioc, MPI3_EVENT_DEVICE_STATUS_CHANGE);
 	mpi3mr_unmask_events(mrioc, MPI3_EVENT_ENCL_DEVICE_STATUS_CHANGE);
+	mpi3mr_unmask_events(mrioc, MPI3_EVENT_ENCL_DEVICE_ADDED);
 	mpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_TOPOLOGY_CHANGE_LIST);
 	mpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_DISCOVERY);
 	mpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_DEVICE_DISCOVERY_ERROR);
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_os.c
