cfg80211: Indicate MLO connection info in connect and roam callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Veerendranath Jakkam <quic_vjakkam@quicinc.com>
commit efbabc11650040c64884ff3019b88c7bcc0ceb1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/efbabc11.failed

The MLO links used for connection with an MLD AP are decided by the
driver in case of SME offloaded to driver.

Add support for the drivers to indicate the information of links used
for MLO connection in connect and roam callbacks, update the connected
links information in wdev from connect/roam result sent by driver.
Also, send the connected links information to userspace.

Add a netlink flag attribute to indicate that userspace supports
handling of MLO connection. Drivers must not do MLO connection when this
flag is not set. This is to maintain backwards compatibility with older
supplicant versions which doesn't have support for MLO connection.

	Signed-off-by: Veerendranath Jakkam <quic_vjakkam@quicinc.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit efbabc11650040c64884ff3019b88c7bcc0ceb1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/wil6210/wmi.c
#	drivers/staging/rtl8723bs/os_dep/ioctl_cfg80211.c
#	include/net/cfg80211.h
#	include/uapi/linux/nl80211.h
#	net/wireless/nl80211.c
#	net/wireless/sme.c
diff --cc drivers/net/wireless/ath/wil6210/wmi.c
index 5d991243cdb5,ea7bd403e706..000000000000
--- a/drivers/net/wireless/ath/wil6210/wmi.c
+++ b/drivers/net/wireless/ath/wil6210/wmi.c
@@@ -1250,8 -1449,421 +1250,426 @@@ wmi_evt_sched_scan_result(struct wil621
  	cfg80211_sched_scan_results(wiphy, 0);
  }
  
++<<<<<<< HEAD
 +/**
 + * Some events are ignored for purpose; and need not be interpreted as
++=======
+ static void wil_link_stats_store_basic(struct wil6210_vif *vif,
+ 				       struct wmi_link_stats_basic *basic)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 	u8 cid = basic->cid;
+ 	struct wil_sta_info *sta;
+ 
+ 	if (cid >= wil->max_assoc_sta) {
+ 		wil_err(wil, "invalid cid %d\n", cid);
+ 		return;
+ 	}
+ 
+ 	sta = &wil->sta[cid];
+ 	sta->fw_stats_basic = *basic;
+ }
+ 
+ static void wil_link_stats_store_global(struct wil6210_vif *vif,
+ 					struct wmi_link_stats_global *global)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 
+ 	wil->fw_stats_global.stats = *global;
+ }
+ 
+ static void wmi_link_stats_parse(struct wil6210_vif *vif, u64 tsf,
+ 				 bool has_next, void *payload,
+ 				 size_t payload_size)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 	size_t hdr_size = sizeof(struct wmi_link_stats_record);
+ 	size_t stats_size, record_size, expected_size;
+ 	struct wmi_link_stats_record *hdr;
+ 
+ 	if (payload_size < hdr_size) {
+ 		wil_err(wil, "link stats wrong event size %zu\n", payload_size);
+ 		return;
+ 	}
+ 
+ 	while (payload_size >= hdr_size) {
+ 		hdr = payload;
+ 		stats_size = le16_to_cpu(hdr->record_size);
+ 		record_size = hdr_size + stats_size;
+ 
+ 		if (payload_size < record_size) {
+ 			wil_err(wil, "link stats payload ended unexpectedly, size %zu < %zu\n",
+ 				payload_size, record_size);
+ 			return;
+ 		}
+ 
+ 		switch (hdr->record_type_id) {
+ 		case WMI_LINK_STATS_TYPE_BASIC:
+ 			expected_size = sizeof(struct wmi_link_stats_basic);
+ 			if (stats_size < expected_size) {
+ 				wil_err(wil, "link stats invalid basic record size %zu < %zu\n",
+ 					stats_size, expected_size);
+ 				return;
+ 			}
+ 			if (vif->fw_stats_ready) {
+ 				/* clean old statistics */
+ 				vif->fw_stats_tsf = 0;
+ 				vif->fw_stats_ready = false;
+ 			}
+ 
+ 			wil_link_stats_store_basic(vif, payload + hdr_size);
+ 
+ 			if (!has_next) {
+ 				vif->fw_stats_tsf = tsf;
+ 				vif->fw_stats_ready = true;
+ 			}
+ 
+ 			break;
+ 		case WMI_LINK_STATS_TYPE_GLOBAL:
+ 			expected_size = sizeof(struct wmi_link_stats_global);
+ 			if (stats_size < sizeof(struct wmi_link_stats_global)) {
+ 				wil_err(wil, "link stats invalid global record size %zu < %zu\n",
+ 					stats_size, expected_size);
+ 				return;
+ 			}
+ 
+ 			if (wil->fw_stats_global.ready) {
+ 				/* clean old statistics */
+ 				wil->fw_stats_global.tsf = 0;
+ 				wil->fw_stats_global.ready = false;
+ 			}
+ 
+ 			wil_link_stats_store_global(vif, payload + hdr_size);
+ 
+ 			if (!has_next) {
+ 				wil->fw_stats_global.tsf = tsf;
+ 				wil->fw_stats_global.ready = true;
+ 			}
+ 
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 
+ 		/* skip to next record */
+ 		payload += record_size;
+ 		payload_size -= record_size;
+ 	}
+ }
+ 
+ static void
+ wmi_evt_link_stats(struct wil6210_vif *vif, int id, void *d, int len)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 	struct wmi_link_stats_event *evt = d;
+ 	size_t payload_size;
+ 
+ 	if (len < offsetof(struct wmi_link_stats_event, payload)) {
+ 		wil_err(wil, "stats event way too short %d\n", len);
+ 		return;
+ 	}
+ 	payload_size = le16_to_cpu(evt->payload_size);
+ 	if (len < sizeof(struct wmi_link_stats_event) + payload_size) {
+ 		wil_err(wil, "stats event too short %d\n", len);
+ 		return;
+ 	}
+ 
+ 	wmi_link_stats_parse(vif, le64_to_cpu(evt->tsf), evt->has_next,
+ 			     evt->payload, payload_size);
+ }
+ 
+ /* find cid and ringid for the station vif
+  *
+  * return error, if other interfaces are used or ring was not found
+  */
+ static int wil_find_cid_ringid_sta(struct wil6210_priv *wil,
+ 				   struct wil6210_vif *vif,
+ 				   int *cid,
+ 				   int *ringid)
+ {
+ 	struct wil_ring *ring;
+ 	struct wil_ring_tx_data *txdata;
+ 	int min_ring_id = wil_get_min_tx_ring_id(wil);
+ 	int i;
+ 	u8 lcid;
+ 
+ 	if (!(vif->wdev.iftype == NL80211_IFTYPE_STATION ||
+ 	      vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
+ 		wil_err(wil, "invalid interface type %d\n", vif->wdev.iftype);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* In the STA mode, it is expected to have only one ring
+ 	 * for the AP we are connected to.
+ 	 * find it and return the cid associated with it.
+ 	 */
+ 	for (i = min_ring_id; i < WIL6210_MAX_TX_RINGS; i++) {
+ 		ring = &wil->ring_tx[i];
+ 		txdata = &wil->ring_tx_data[i];
+ 		if (!ring->va || !txdata->enabled || txdata->mid != vif->mid)
+ 			continue;
+ 
+ 		lcid = wil->ring2cid_tid[i][0];
+ 		if (lcid >= wil->max_assoc_sta) /* skip BCAST */
+ 			continue;
+ 
+ 		wil_dbg_wmi(wil, "find sta -> ringid %d cid %d\n", i, lcid);
+ 		*cid = lcid;
+ 		*ringid = i;
+ 		return 0;
+ 	}
+ 
+ 	wil_dbg_wmi(wil, "find sta cid while no rings active?\n");
+ 
+ 	return -ENOENT;
+ }
+ 
+ static void
+ wmi_evt_auth_status(struct wil6210_vif *vif, int id, void *d, int len)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 	struct net_device *ndev = vif_to_ndev(vif);
+ 	struct wmi_ft_auth_status_event *data = d;
+ 	int ie_len = len - offsetof(struct wmi_ft_auth_status_event, ie_info);
+ 	int rc, cid = 0, ringid = 0;
+ 	struct cfg80211_ft_event_params ft;
+ 	u16 d_len;
+ 	/* auth_alg(u16) + auth_transaction(u16) + status_code(u16) */
+ 	const size_t auth_ie_offset = sizeof(u16) * 3;
+ 	struct auth_no_hdr *auth = (struct auth_no_hdr *)data->ie_info;
+ 
+ 	/* check the status */
+ 	if (ie_len >= 0 && data->status != WMI_FW_STATUS_SUCCESS) {
+ 		wil_err(wil, "FT: auth failed. status %d\n", data->status);
+ 		goto fail;
+ 	}
+ 
+ 	if (ie_len < auth_ie_offset) {
+ 		wil_err(wil, "FT: auth event too short, len %d\n", len);
+ 		goto fail;
+ 	}
+ 
+ 	d_len = le16_to_cpu(data->ie_len);
+ 	if (d_len != ie_len) {
+ 		wil_err(wil,
+ 			"FT: auth ie length mismatch, d_len %d should be %d\n",
+ 			d_len, ie_len);
+ 		goto fail;
+ 	}
+ 
+ 	if (!test_bit(wil_vif_ft_roam, wil->status)) {
+ 		wil_err(wil, "FT: Not in roaming state\n");
+ 		goto fail;
+ 	}
+ 
+ 	if (le16_to_cpu(auth->auth_transaction) != 2) {
+ 		wil_err(wil, "FT: auth error. auth_transaction %d\n",
+ 			le16_to_cpu(auth->auth_transaction));
+ 		goto fail;
+ 	}
+ 
+ 	if (le16_to_cpu(auth->auth_alg) != WLAN_AUTH_FT) {
+ 		wil_err(wil, "FT: auth error. auth_alg %d\n",
+ 			le16_to_cpu(auth->auth_alg));
+ 		goto fail;
+ 	}
+ 
+ 	wil_dbg_wmi(wil, "FT: Auth to %pM successfully\n", data->mac_addr);
+ 	wil_hex_dump_wmi("FT Auth ies : ", DUMP_PREFIX_OFFSET, 16, 1,
+ 			 data->ie_info, d_len, true);
+ 
+ 	/* find cid and ringid */
+ 	rc = wil_find_cid_ringid_sta(wil, vif, &cid, &ringid);
+ 	if (rc) {
+ 		wil_err(wil, "No valid cid found\n");
+ 		goto fail;
+ 	}
+ 
+ 	if (vif->privacy) {
+ 		/* For secure assoc, remove old keys */
+ 		rc = wmi_del_cipher_key(vif, 0, wil->sta[cid].addr,
+ 					WMI_KEY_USE_PAIRWISE);
+ 		if (rc) {
+ 			wil_err(wil, "WMI_DELETE_CIPHER_KEY_CMD(PTK) failed\n");
+ 			goto fail;
+ 		}
+ 		rc = wmi_del_cipher_key(vif, 0, wil->sta[cid].addr,
+ 					WMI_KEY_USE_RX_GROUP);
+ 		if (rc) {
+ 			wil_err(wil, "WMI_DELETE_CIPHER_KEY_CMD(GTK) failed\n");
+ 			goto fail;
+ 		}
+ 	}
+ 
+ 	memset(&ft, 0, sizeof(ft));
+ 	ft.ies = data->ie_info + auth_ie_offset;
+ 	ft.ies_len = d_len - auth_ie_offset;
+ 	ft.target_ap = data->mac_addr;
+ 	cfg80211_ft_event(ndev, &ft);
+ 
+ 	return;
+ 
+ fail:
+ 	wil6210_disconnect(vif, NULL, WLAN_REASON_PREV_AUTH_NOT_VALID);
+ }
+ 
+ static void
+ wmi_evt_reassoc_status(struct wil6210_vif *vif, int id, void *d, int len)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 	struct net_device *ndev = vif_to_ndev(vif);
+ 	struct wiphy *wiphy = wil_to_wiphy(wil);
+ 	struct wmi_ft_reassoc_status_event *data = d;
+ 	int ies_len = len - offsetof(struct wmi_ft_reassoc_status_event,
+ 				     ie_info);
+ 	int rc = -ENOENT, cid = 0, ringid = 0;
+ 	int ch; /* channel number (primary) */
+ 	size_t assoc_req_ie_len = 0, assoc_resp_ie_len = 0;
+ 	u8 *assoc_req_ie = NULL, *assoc_resp_ie = NULL;
+ 	/* capinfo(u16) + listen_interval(u16) + current_ap mac addr + IEs */
+ 	const size_t assoc_req_ie_offset = sizeof(u16) * 2 + ETH_ALEN;
+ 	/* capinfo(u16) + status_code(u16) + associd(u16) + IEs */
+ 	const size_t assoc_resp_ie_offset = sizeof(u16) * 3;
+ 	u16 d_len;
+ 	int freq;
+ 	struct cfg80211_roam_info info;
+ 
+ 	if (ies_len < 0) {
+ 		wil_err(wil, "ft reassoc event too short, len %d\n", len);
+ 		goto fail;
+ 	}
+ 
+ 	wil_dbg_wmi(wil, "Reasoc Status event: status=%d, aid=%d",
+ 		    data->status, data->aid);
+ 	wil_dbg_wmi(wil, "    mac_addr=%pM, beacon_ie_len=%d",
+ 		    data->mac_addr, data->beacon_ie_len);
+ 	wil_dbg_wmi(wil, "    reassoc_req_ie_len=%d, reassoc_resp_ie_len=%d",
+ 		    le16_to_cpu(data->reassoc_req_ie_len),
+ 		    le16_to_cpu(data->reassoc_resp_ie_len));
+ 
+ 	d_len = le16_to_cpu(data->beacon_ie_len) +
+ 		le16_to_cpu(data->reassoc_req_ie_len) +
+ 		le16_to_cpu(data->reassoc_resp_ie_len);
+ 	if (d_len != ies_len) {
+ 		wil_err(wil,
+ 			"ft reassoc ie length mismatch, d_len %d should be %d\n",
+ 			d_len, ies_len);
+ 		goto fail;
+ 	}
+ 
+ 	/* check the status */
+ 	if (data->status != WMI_FW_STATUS_SUCCESS) {
+ 		wil_err(wil, "ft reassoc failed. status %d\n", data->status);
+ 		goto fail;
+ 	}
+ 
+ 	/* find cid and ringid */
+ 	rc = wil_find_cid_ringid_sta(wil, vif, &cid, &ringid);
+ 	if (rc) {
+ 		wil_err(wil, "No valid cid found\n");
+ 		goto fail;
+ 	}
+ 
+ 	ch = data->channel + 1;
+ 	wil_info(wil, "FT: Roam %pM channel [%d] cid %d aid %d\n",
+ 		 data->mac_addr, ch, cid, data->aid);
+ 
+ 	wil_hex_dump_wmi("reassoc AI : ", DUMP_PREFIX_OFFSET, 16, 1,
+ 			 data->ie_info, len - sizeof(*data), true);
+ 
+ 	/* figure out IE's */
+ 	if (le16_to_cpu(data->reassoc_req_ie_len) > assoc_req_ie_offset) {
+ 		assoc_req_ie = &data->ie_info[assoc_req_ie_offset];
+ 		assoc_req_ie_len = le16_to_cpu(data->reassoc_req_ie_len) -
+ 			assoc_req_ie_offset;
+ 	}
+ 	if (le16_to_cpu(data->reassoc_resp_ie_len) <= assoc_resp_ie_offset) {
+ 		wil_err(wil, "FT: reassoc resp ie len is too short, len %d\n",
+ 			le16_to_cpu(data->reassoc_resp_ie_len));
+ 		goto fail;
+ 	}
+ 
+ 	assoc_resp_ie = &data->ie_info[le16_to_cpu(data->reassoc_req_ie_len) +
+ 		assoc_resp_ie_offset];
+ 	assoc_resp_ie_len = le16_to_cpu(data->reassoc_resp_ie_len) -
+ 		assoc_resp_ie_offset;
+ 
+ 	if (test_bit(wil_status_resetting, wil->status) ||
+ 	    !test_bit(wil_status_fwready, wil->status)) {
+ 		wil_err(wil, "FT: status_resetting, cancel reassoc event\n");
+ 		/* no need for cleanup, wil_reset will do that */
+ 		return;
+ 	}
+ 
+ 	mutex_lock(&wil->mutex);
+ 
+ 	/* ring modify to set the ring for the roamed AP settings */
+ 	wil_dbg_wmi(wil,
+ 		    "ft modify tx config for connection CID %d ring %d\n",
+ 		    cid, ringid);
+ 
+ 	rc = wil->txrx_ops.tx_ring_modify(vif, ringid, cid, 0);
+ 	if (rc) {
+ 		wil_err(wil, "modify TX for CID %d MID %d ring %d failed (%d)\n",
+ 			cid, vif->mid, ringid, rc);
+ 		mutex_unlock(&wil->mutex);
+ 		goto fail;
+ 	}
+ 
+ 	/* Update the driver STA members with the new bss */
+ 	wil->sta[cid].aid = data->aid;
+ 	wil->sta[cid].stats.ft_roams++;
+ 	ether_addr_copy(wil->sta[cid].addr, vif->bss->bssid);
+ 	mutex_unlock(&wil->mutex);
+ 	del_timer_sync(&vif->connect_timer);
+ 
+ 	cfg80211_ref_bss(wiphy, vif->bss);
+ 	freq = ieee80211_channel_to_frequency(ch, NL80211_BAND_60GHZ);
+ 
+ 	memset(&info, 0, sizeof(info));
+ 	info.links[0].channel = ieee80211_get_channel(wiphy, freq);
+ 	info.links[0].bss = vif->bss;
+ 	info.req_ie = assoc_req_ie;
+ 	info.req_ie_len = assoc_req_ie_len;
+ 	info.resp_ie = assoc_resp_ie;
+ 	info.resp_ie_len = assoc_resp_ie_len;
+ 	cfg80211_roamed(ndev, &info, GFP_KERNEL);
+ 	vif->bss = NULL;
+ 
+ 	return;
+ 
+ fail:
+ 	wil6210_disconnect(vif, NULL, WLAN_REASON_PREV_AUTH_NOT_VALID);
+ }
+ 
+ static void
+ wmi_evt_link_monitor(struct wil6210_vif *vif, int id, void *d, int len)
+ {
+ 	struct wil6210_priv *wil = vif_to_wil(vif);
+ 	struct net_device *ndev = vif_to_ndev(vif);
+ 	struct wmi_link_monitor_event *evt = d;
+ 	enum nl80211_cqm_rssi_threshold_event event_type;
+ 
+ 	if (len < sizeof(*evt)) {
+ 		wil_err(wil, "link monitor event too short %d\n", len);
+ 		return;
+ 	}
+ 
+ 	wil_dbg_wmi(wil, "link monitor event, type %d rssi %d (stored %d)\n",
+ 		    evt->type, evt->rssi_level, wil->cqm_rssi_thold);
+ 
+ 	if (evt->type != WMI_LINK_MONITOR_NOTIF_RSSI_THRESHOLD_EVT)
+ 		/* ignore */
+ 		return;
+ 
+ 	event_type = (evt->rssi_level > wil->cqm_rssi_thold ?
+ 		      NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH :
+ 		      NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW);
+ 	cfg80211_cqm_rssi_notify(ndev, event_type, evt->rssi_level, GFP_KERNEL);
+ }
+ 
+ /* Some events are ignored for purpose; and need not be interpreted as
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
   * "unhandled events"
   */
  static void wmi_evt_ignore(struct wil6210_vif *vif, int id, void *d, int len)
diff --cc drivers/staging/rtl8723bs/os_dep/ioctl_cfg80211.c
index 02178e25fbb8,cf35125b7891..000000000000
--- a/drivers/staging/rtl8723bs/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8723bs/os_dep/ioctl_cfg80211.c
@@@ -539,9 -450,8 +539,14 @@@ check_bss
  
  		notify_channel = ieee80211_get_channel(wiphy, freq);
  
++<<<<<<< HEAD
 +		DBG_871X(FUNC_ADPT_FMT" call cfg80211_roamed\n", FUNC_ADPT_ARG(padapter));
 +		roam_info.channel = notify_channel;
 +		roam_info.bssid = cur_network->network.MacAddress;
++=======
+ 		roam_info.links[0].channel = notify_channel;
+ 		roam_info.links[0].bssid = cur_network->network.mac_address;
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  		roam_info.req_ie =
  			pmlmepriv->assoc_req+sizeof(struct ieee80211_hdr_3addr)+2;
  		roam_info.req_ie_len =
diff --cc include/net/cfg80211.h
index 3eeec9c7c79b,996782c44838..000000000000
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@@ -5667,6 -5767,32 +5671,35 @@@ static inline void *wdev_priv(struct wi
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * wdev_chandef - return chandef pointer from wireless_dev
+  * @wdev: the wdev
+  * @link_id: the link ID for MLO
+  *
+  * Return: The chandef depending on the mode, or %NULL.
+  */
+ struct cfg80211_chan_def *wdev_chandef(struct wireless_dev *wdev,
+ 				       unsigned int link_id);
+ 
+ static inline void WARN_INVALID_LINK_ID(struct wireless_dev *wdev,
+ 					unsigned int link_id)
+ {
+ 	WARN_ON(link_id && !wdev->valid_links);
+ 	WARN_ON(wdev->valid_links &&
+ 		!(wdev->valid_links & BIT(link_id)));
+ }
+ 
+ #define for_each_valid_link(link_info, link_id)			\
+ 	for (link_id = 0;					\
+ 	     link_id < ((link_info)->valid_links ?		\
+ 			ARRAY_SIZE((link_info)->links) : 1);	\
+ 	     link_id++)						\
+ 		if (!(link_info)->valid_links ||		\
+ 		    ((link_info)->valid_links & BIT(link_id)))
+ 
+ /**
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
   * DOC: Utility functions
   *
   * cfg80211 offers a number of utility functions that can be useful.
diff --cc include/uapi/linux/nl80211.h
index 89c2cfb97539,89f64f46b98d..000000000000
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@@ -2653,6 -2683,17 +2653,20 @@@ enum nl80211_commands 
   *	association request when used with NL80211_CMD_NEW_STATION). Can be set
   *	only if %NL80211_STA_FLAG_WME is set.
   *
++<<<<<<< HEAD
++=======
+  * @NL80211_ATTR_MLO_LINK_ID: A (u8) link ID for use with MLO, to be used with
+  *	various commands that need a link ID to operate.
+  * @NL80211_ATTR_MLO_LINKS: A nested array of links, each containing some
+  *	per-link information and a link ID.
+  * @NL80211_ATTR_MLD_ADDR: An MLD address, used with various commands such as
+  *	authenticate/associate.
+  *
+  * @NL80211_ATTR_MLO_SUPPORT: Flag attribute to indicate user space supports MLO
+  *	connection. Used with %NL80211_CMD_CONNECT. If this attribute is not
+  *	included in NL80211_CMD_CONNECT drivers must not perform MLO connection.
+  *
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
   * @NUM_NL80211_ATTR: total number of nl80211_attrs available
   * @NL80211_ATTR_MAX: highest attribute number currently defined
   * @__NL80211_ATTR_AFTER_LAST: internal use
@@@ -3167,6 -3208,12 +3181,15 @@@ enum nl80211_attrs 
  
  	NL80211_ATTR_DISABLE_EHT,
  
++<<<<<<< HEAD
++=======
+ 	NL80211_ATTR_MLO_LINKS,
+ 	NL80211_ATTR_MLO_LINK_ID,
+ 	NL80211_ATTR_MLD_ADDR,
+ 
+ 	NL80211_ATTR_MLO_SUPPORT,
+ 
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  	/* add attributes here, update the policy in nl80211.c */
  
  	__NL80211_ATTR_AFTER_LAST,
diff --cc net/wireless/nl80211.c
index 718221cdc6c2,6a45801c783c..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -792,6 -792,12 +792,15 @@@ static const struct nla_policy nl80211_
  				 NL80211_EHT_MIN_CAPABILITY_LEN,
  				 NL80211_EHT_MAX_CAPABILITY_LEN),
  	[NL80211_ATTR_DISABLE_EHT] = { .type = NLA_FLAG },
++<<<<<<< HEAD
++=======
+ 	[NL80211_ATTR_MLO_LINKS] =
+ 		NLA_POLICY_NESTED_ARRAY(nl80211_policy),
+ 	[NL80211_ATTR_MLO_LINK_ID] =
+ 		NLA_POLICY_RANGE(NLA_U8, 0, IEEE80211_MLD_MAX_NUM_LINKS),
+ 	[NL80211_ATTR_MLD_ADDR] = NLA_POLICY_EXACT_LEN(ETH_ALEN),
+ 	[NL80211_ATTR_MLO_SUPPORT] = { .type = NLA_FLAG },
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  };
  
  /* policy for the key attributes */
diff --cc net/wireless/sme.c
index 1001c6b3bcf5,00be498aab2e..000000000000
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@@ -677,6 -698,19 +677,22 @@@ static void disconnect_work(struct work
  
  DECLARE_WORK(cfg80211_disconnect_work, disconnect_work);
  
++<<<<<<< HEAD
++=======
+ static void
+ cfg80211_connect_result_release_bsses(struct wireless_dev *wdev,
+ 				      struct cfg80211_connect_resp_params *cr)
+ {
+ 	unsigned int link;
+ 
+ 	for_each_valid_link(cr, link) {
+ 		if (!cr->links[link].bss)
+ 			continue;
+ 		cfg80211_unhold_bss(bss_from_pub(cr->links[link].bss));
+ 		cfg80211_put_bss(wdev->wiphy, cr->links[link].bss);
+ 	}
+ }
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  
  /*
   * API calls for drivers implementing connect/disconnect and
@@@ -735,39 -781,60 +763,79 @@@ void __cfg80211_connect_result(struct n
  	}
  #endif
  
++<<<<<<< HEAD
 +	if (!cr->bss && (cr->status == WLAN_STATUS_SUCCESS)) {
 +		WARN_ON_ONCE(!wiphy_to_rdev(wdev->wiphy)->ops->connect);
 +		cr->bss = cfg80211_get_bss(wdev->wiphy, NULL, cr->bssid,
 +					   wdev->ssid, wdev->ssid_len,
 +					   wdev->conn_bss_type,
 +					   IEEE80211_PRIVACY_ANY);
 +		if (cr->bss)
 +			cfg80211_hold_bss(bss_from_pub(cr->bss));
++=======
+ 	if (cr->status == WLAN_STATUS_SUCCESS) {
+ 		for_each_valid_link(cr, link) {
+ 			if (WARN_ON_ONCE(!cr->links[link].bss))
+ 				break;
+ 		}
+ 
+ 		for_each_valid_link(cr, link) {
+ 			if (cr->links[link].bss)
+ 				continue;
+ 
+ 			cr->links[link].bss =
+ 				cfg80211_get_bss(wdev->wiphy, NULL,
+ 						 cr->links[link].bssid,
+ 						 wdev->u.client.ssid,
+ 						 wdev->u.client.ssid_len,
+ 						 wdev->conn_bss_type,
+ 						 IEEE80211_PRIVACY_ANY);
+ 			if (!cr->links[link].bss) {
+ 				bss_not_found = true;
+ 				break;
+ 			}
+ 			cfg80211_hold_bss(bss_from_pub(cr->links[link].bss));
+ 		}
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  	}
  
 -	cfg80211_wdev_release_bsses(wdev);
 +	if (wdev->current_bss) {
 +		cfg80211_unhold_bss(wdev->current_bss);
 +		cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
 +		wdev->current_bss = NULL;
 +	}
  
  	if (cr->status != WLAN_STATUS_SUCCESS) {
  		kfree_sensitive(wdev->connect_keys);
  		wdev->connect_keys = NULL;
 -		wdev->u.client.ssid_len = 0;
 +		wdev->ssid_len = 0;
  		wdev->conn_owner_nlportid = 0;
- 		if (cr->bss) {
- 			cfg80211_unhold_bss(bss_from_pub(cr->bss));
- 			cfg80211_put_bss(wdev->wiphy, cr->bss);
- 		}
+ 		cfg80211_connect_result_release_bsses(wdev, cr);
  		cfg80211_sme_free(wdev);
  		return;
  	}
  
- 	if (WARN_ON(!cr->bss))
+ 	if (WARN_ON(bss_not_found)) {
+ 		cfg80211_connect_result_release_bsses(wdev, cr);
  		return;
+ 	}
  
++<<<<<<< HEAD
 +	wdev->current_bss = bss_from_pub(cr->bss);
++=======
+ 	memset(wdev->links, 0, sizeof(wdev->links));
+ 	wdev->valid_links = cr->valid_links;
+ 	for_each_valid_link(cr, link)
+ 		wdev->links[link].client.current_bss =
+ 			bss_from_pub(cr->links[link].bss);
+ 	wdev->connected = true;
+ 	ether_addr_copy(wdev->u.client.connected_addr, connected_addr);
+ 	if (cr->valid_links) {
+ 		for_each_valid_link(cr, link)
+ 			memcpy(wdev->links[link].addr, cr->links[link].addr,
+ 			       ETH_ALEN);
+ 	}
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  
  	if (!(wdev->wiphy->flags & WIPHY_FLAG_HAS_STATIC_WEP))
  		cfg80211_upload_connect_keys(wdev);
@@@ -801,47 -922,25 +923,60 @@@ void cfg80211_connect_done(struct net_d
  	struct cfg80211_event *ev;
  	unsigned long flags;
  	u8 *next;
+ 	size_t link_info_size = 0;
+ 	unsigned int link;
  
++<<<<<<< HEAD
 +	if (params->bss) {
 +		struct cfg80211_internal_bss *ibss = bss_from_pub(params->bss);
 +
 +		if (list_empty(&ibss->list)) {
 +			struct cfg80211_bss *found = NULL, *tmp = params->bss;
 +
 +			found = cfg80211_get_bss(wdev->wiphy, NULL,
 +						 params->bss->bssid,
 +						 wdev->ssid, wdev->ssid_len,
 +						 wdev->conn_bss_type,
 +						 IEEE80211_PRIVACY_ANY);
 +			if (found) {
 +				/* The same BSS is already updated so use it
 +				 * instead, as it has latest info.
 +				 */
 +				params->bss = found;
 +			} else {
 +				/* Update with BSS provided by driver, it will
 +				 * be freshly added and ref cnted, we can free
 +				 * the old one.
 +				 *
 +				 * signal_valid can be false, as we are not
 +				 * expecting the BSS to be found.
 +				 *
 +				 * keep the old timestamp to avoid confusion
 +				 */
 +				cfg80211_bss_update(rdev, ibss, false,
 +						    ibss->ts);
 +			}
 +
 +			cfg80211_put_bss(wdev->wiphy, tmp);
 +		}
++=======
+ 	for_each_valid_link(params, link) {
+ 		cfg80211_update_link_bss(wdev, &params->links[link].bss);
+ 		link_info_size += params->links[link].bssid ? ETH_ALEN : 0;
+ 		link_info_size += params->links[link].addr ? ETH_ALEN : 0;
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  	}
  
- 	ev = kzalloc(sizeof(*ev) + (params->bssid ? ETH_ALEN : 0) +
+ 	ev = kzalloc(sizeof(*ev) + (params->ap_mld_addr ? ETH_ALEN : 0) +
  		     params->req_ie_len + params->resp_ie_len +
  		     params->fils.kek_len + params->fils.pmk_len +
- 		     (params->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);
+ 		     (params->fils.pmkid ? WLAN_PMKID_LEN : 0) + link_info_size,
+ 		     gfp);
+ 
  	if (!ev) {
- 		cfg80211_put_bss(wdev->wiphy, params->bss);
+ 		for_each_valid_link(params, link)
+ 			cfg80211_put_bss(wdev->wiphy,
+ 					 params->links[link].bss);
  		return;
  	}
  
@@@ -915,19 -1037,43 +1073,54 @@@ void __cfg80211_roamed(struct wireless_
  		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
  		goto out;
  
 -	if (WARN_ON(!wdev->connected))
 +	if (WARN_ON(!wdev->current_bss))
  		goto out;
  
++<<<<<<< HEAD
 +	cfg80211_unhold_bss(wdev->current_bss);
 +	cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
 +	wdev->current_bss = NULL;
++=======
+ 	if (info->valid_links) {
+ 		if (WARN_ON(!info->ap_mld_addr))
+ 			goto out;
+ 
+ 		for_each_valid_link(info, link) {
+ 			if (WARN_ON(!info->links[link].addr))
+ 				goto out;
+ 		}
+ 	}
  
- 	if (WARN_ON(!info->bss))
- 		return;
+ 	cfg80211_wdev_release_bsses(wdev);
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  
+ 	for_each_valid_link(info, link) {
+ 		if (WARN_ON(!info->links[link].bss))
+ 			goto out;
+ 	}
+ 
++<<<<<<< HEAD
 +	cfg80211_hold_bss(bss_from_pub(info->bss));
 +	wdev->current_bss = bss_from_pub(info->bss);
- 
++=======
+ 	memset(wdev->links, 0, sizeof(wdev->links));
+ 	wdev->valid_links = info->valid_links;
+ 	for_each_valid_link(info, link) {
+ 		cfg80211_hold_bss(bss_from_pub(info->links[link].bss));
+ 		wdev->links[link].client.current_bss =
+ 			bss_from_pub(info->links[link].bss);
+ 	}
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
+ 
+ 	connected_addr = info->valid_links ?
+ 			 info->ap_mld_addr :
+ 			 info->links[0].bss->bssid;
+ 	ether_addr_copy(wdev->u.client.connected_addr, connected_addr);
+ 	if (info->valid_links) {
+ 		for_each_valid_link(info, link)
+ 			memcpy(wdev->links[link].addr, info->links[link].addr,
+ 			       ETH_ALEN);
+ 	}
  	wdev->unprot_beacon_reported = 0;
  	nl80211_send_roamed(wiphy_to_rdev(wdev->wiphy),
  			    wdev->netdev, info, GFP_KERNEL);
@@@ -969,17 -1118,34 +1165,43 @@@ void cfg80211_roamed(struct net_device 
  	struct cfg80211_event *ev;
  	unsigned long flags;
  	u8 *next;
+ 	unsigned int link;
+ 	size_t link_info_size = 0;
+ 	bool bss_not_found = false;
  
++<<<<<<< HEAD
 +	if (!info->bss) {
 +		info->bss = cfg80211_get_bss(wdev->wiphy, info->channel,
 +					     info->bssid, wdev->ssid,
 +					     wdev->ssid_len,
 +					     wdev->conn_bss_type,
 +					     IEEE80211_PRIVACY_ANY);
++=======
+ 	for_each_valid_link(info, link) {
+ 		link_info_size += info->links[link].addr ? ETH_ALEN : 0;
+ 		link_info_size += info->links[link].bssid ? ETH_ALEN : 0;
+ 
+ 		if (info->links[link].bss)
+ 			continue;
+ 
+ 		info->links[link].bss =
+ 			cfg80211_get_bss(wdev->wiphy,
+ 					 info->links[link].channel,
+ 					 info->links[link].bssid,
+ 					 wdev->u.client.ssid,
+ 					 wdev->u.client.ssid_len,
+ 					 wdev->conn_bss_type,
+ 					 IEEE80211_PRIVACY_ANY);
+ 
+ 		if (!info->links[link].bss) {
+ 			bss_not_found = true;
+ 			break;
+ 		}
++>>>>>>> efbabc116500 (cfg80211: Indicate MLO connection info in connect and roam callbacks)
  	}
  
- 	if (WARN_ON(!info->bss))
- 		return;
+ 	if (WARN_ON(bss_not_found))
+ 		goto out;
  
  	ev = kzalloc(sizeof(*ev) + info->req_ie_len + info->resp_ie_len +
  		     info->fils.kek_len + info->fils.pmk_len +
diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 7229eb2d5036..0ba9b3ed06ea 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -807,7 +807,7 @@ void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
 		cfg80211_put_bss(ar->wiphy, bss);
 	} else if (vif->sme_state == SME_CONNECTED) {
 		struct cfg80211_roam_info roam_info = {
-			.bss = bss,
+			.links[0].bss = bss,
 			.req_ie = assoc_req_ie,
 			.req_ie_len = assoc_req_len,
 			.resp_ie = assoc_resp_ie,
* Unmerged path drivers/net/wireless/ath/wil6210/wmi.c
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index 605206abe424..bda407430270 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -6015,8 +6015,8 @@ brcmf_bss_roaming_done(struct brcmf_cfg80211_info *cfg,
 done:
 	kfree(buf);
 
-	roam_info.channel = notify_channel;
-	roam_info.bssid = profile->bssid;
+	roam_info.links[0].channel = notify_channel;
+	roam_info.links[0].bssid = profile->bssid;
 	roam_info.req_ie = conn_info->req_ie;
 	roam_info.req_ie_len = conn_info->req_ie_len;
 	roam_info.resp_ie = conn_info->resp_ie;
@@ -6059,7 +6059,7 @@ brcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,
 		} else {
 			conn_params.status = WLAN_STATUS_AUTH_TIMEOUT;
 		}
-		conn_params.bssid = profile->bssid;
+		conn_params.links[0].bssid = profile->bssid;
 		conn_params.req_ie = conn_info->req_ie;
 		conn_params.req_ie_len = conn_info->req_ie_len;
 		conn_params.resp_ie = conn_info->resp_ie;
diff --git a/drivers/net/wireless/rndis_wlan.c b/drivers/net/wireless/rndis_wlan.c
index 682abd5e085a..ff1f823024ad 100644
--- a/drivers/net/wireless/rndis_wlan.c
+++ b/drivers/net/wireless/rndis_wlan.c
@@ -2827,8 +2827,9 @@ static void rndis_wlan_do_link_up_work(struct usbnet *usbdev)
 						resp_ie_len, 0, GFP_KERNEL);
 		} else {
 			struct cfg80211_roam_info roam_info = {
-				.channel = get_current_channel(usbdev, NULL),
-				.bssid = bssid,
+				.links[0].channel =
+					get_current_channel(usbdev, NULL),
+				.links[0].bssid = bssid,
 				.req_ie = req_ie,
 				.req_ie_len = req_ie_len,
 				.resp_ie = resp_ie,
* Unmerged path drivers/staging/rtl8723bs/os_dep/ioctl_cfg80211.c
diff --git a/drivers/staging/wlan-ng/cfg80211.c b/drivers/staging/wlan-ng/cfg80211.c
index 42912257e2b9..3c332e6a7b05 100644
--- a/drivers/staging/wlan-ng/cfg80211.c
+++ b/drivers/staging/wlan-ng/cfg80211.c
@@ -668,7 +668,7 @@ void prism2_disconnected(struct wlandevice *wlandev)
 void prism2_roamed(struct wlandevice *wlandev)
 {
 	struct cfg80211_roam_info roam_info = {
-		.bssid = wlandev->bssid,
+		.links[0].bssid = wlandev->bssid,
 	};
 
 	cfg80211_roamed(wlandev->netdev, &roam_info, GFP_KERNEL);
* Unmerged path include/net/cfg80211.h
* Unmerged path include/uapi/linux/nl80211.h
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index dde8de9bb5a5..89867f683f81 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -42,8 +42,8 @@ void cfg80211_rx_assoc_resp(struct net_device *dev, struct cfg80211_bss *bss,
 
 	memset(&cr, 0, sizeof(cr));
 	cr.status = (int)le16_to_cpu(mgmt->u.assoc_resp.status_code);
-	cr.bssid = mgmt->bssid;
-	cr.bss = bss;
+	cr.links[0].bssid = mgmt->bssid;
+	cr.links[0].bss = bss;
 	cr.req_ie = req_ies;
 	cr.req_ie_len = req_ies_len;
 	cr.resp_ie = resp_ie;
* Unmerged path net/wireless/nl80211.c
* Unmerged path net/wireless/sme.c
