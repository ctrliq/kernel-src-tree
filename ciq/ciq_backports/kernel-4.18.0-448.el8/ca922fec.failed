KVM: s390: pci: Hook to access KVM lowlevel from VFIO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Pierre Morel <pmorel@linux.ibm.com>
commit ca922fecda6caa5162409406dc3b663062d75089
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ca922fec.failed

We have a cross dependency between KVM and VFIO when using
s390 vfio_pci_zdev extensions for PCI passthrough
To be able to keep both subsystem modular we add a registering
hook inside the S390 core code.

This fixes a build problem when VFIO is built-in and KVM is built
as a module.

	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Reported-by: kernel test robot <lkp@intel.com>
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
Fixes: 09340b2fca007 ("KVM: s390: pci: add routines to start/stop interpretive execution")
	Cc: <stable@vger.kernel.org>
	Acked-by: Janosch Frank <frankja@linux.ibm.com>
	Acked-by: Randy Dunlap <rdunlap@infradead.org> # build-tested
Link: https://lore.kernel.org/r/20220819122945.9309-1-pmorel@linux.ibm.com
Message-Id: <20220819122945.9309-1-pmorel@linux.ibm.com>
	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
(cherry picked from commit ca922fecda6caa5162409406dc3b663062d75089)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/kvm_host.h
#	arch/s390/kvm/pci.c
#	arch/s390/pci/Makefile
#	drivers/vfio/pci/vfio_pci_zdev.c
diff --cc arch/s390/include/asm/kvm_host.h
index 502db6311e38,b1e98a9ed152..000000000000
--- a/arch/s390/include/asm/kvm_host.h
+++ b/arch/s390/include/asm/kvm_host.h
@@@ -1031,4 -1035,14 +1031,17 @@@ static inline void kvm_arch_flush_shado
  static inline void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu) {}
  static inline void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu) {}
  
++<<<<<<< HEAD
++=======
+ #define __KVM_HAVE_ARCH_VM_FREE
+ void kvm_arch_free_vm(struct kvm *kvm);
+ 
+ struct zpci_kvm_hook {
+ 	int (*kvm_register)(void *opaque, struct kvm *kvm);
+ 	void (*kvm_unregister)(void *opaque);
+ };
+ 
+ extern struct zpci_kvm_hook zpci_kvm_hook;
+ 
++>>>>>>> ca922fecda6c (KVM: s390: pci: Hook to access KVM lowlevel from VFIO)
  #endif
diff --cc arch/s390/kvm/pci.c
index b232c8cbaa81,bb8c335d17b9..000000000000
--- a/arch/s390/kvm/pci.c
+++ b/arch/s390/kvm/pci.c
@@@ -423,6 -425,251 +423,254 @@@ static void kvm_s390_pci_dev_release(st
  	kfree(kzdev);
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Register device with the specified KVM. If interpetation facilities are
+  * available, enable them and let userspace indicate whether or not they will
+  * be used (specify SHM bit to disable).
+  */
+ static int kvm_s390_pci_register_kvm(void *opaque, struct kvm *kvm)
+ {
+ 	struct zpci_dev *zdev = opaque;
+ 	int rc;
+ 
+ 	if (!zdev)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&zdev->kzdev_lock);
+ 
+ 	if (zdev->kzdev || zdev->gisa != 0 || !kvm) {
+ 		mutex_unlock(&zdev->kzdev_lock);
+ 		return -EINVAL;
+ 	}
+ 
+ 	kvm_get_kvm(kvm);
+ 
+ 	mutex_lock(&kvm->lock);
+ 
+ 	rc = kvm_s390_pci_dev_open(zdev);
+ 	if (rc)
+ 		goto err;
+ 
+ 	/*
+ 	 * If interpretation facilities aren't available, add the device to
+ 	 * the kzdev list but don't enable for interpretation.
+ 	 */
+ 	if (!kvm_s390_pci_interp_allowed())
+ 		goto out;
+ 
+ 	/*
+ 	 * If this is the first request to use an interpreted device, make the
+ 	 * necessary vcpu changes
+ 	 */
+ 	if (!kvm->arch.use_zpci_interp)
+ 		kvm_s390_vcpu_pci_enable_interp(kvm);
+ 
+ 	if (zdev_enabled(zdev)) {
+ 		rc = zpci_disable_device(zdev);
+ 		if (rc)
+ 			goto err;
+ 	}
+ 
+ 	/*
+ 	 * Store information about the identity of the kvm guest allowed to
+ 	 * access this device via interpretation to be used by host CLP
+ 	 */
+ 	zdev->gisa = (u32)virt_to_phys(&kvm->arch.sie_page2->gisa);
+ 
+ 	rc = zpci_enable_device(zdev);
+ 	if (rc)
+ 		goto clear_gisa;
+ 
+ 	/* Re-register the IOMMU that was already created */
+ 	rc = zpci_register_ioat(zdev, 0, zdev->start_dma, zdev->end_dma,
+ 				virt_to_phys(zdev->dma_table));
+ 	if (rc)
+ 		goto clear_gisa;
+ 
+ out:
+ 	zdev->kzdev->kvm = kvm;
+ 
+ 	spin_lock(&kvm->arch.kzdev_list_lock);
+ 	list_add_tail(&zdev->kzdev->entry, &kvm->arch.kzdev_list);
+ 	spin_unlock(&kvm->arch.kzdev_list_lock);
+ 
+ 	mutex_unlock(&kvm->lock);
+ 	mutex_unlock(&zdev->kzdev_lock);
+ 	return 0;
+ 
+ clear_gisa:
+ 	zdev->gisa = 0;
+ err:
+ 	if (zdev->kzdev)
+ 		kvm_s390_pci_dev_release(zdev);
+ 	mutex_unlock(&kvm->lock);
+ 	mutex_unlock(&zdev->kzdev_lock);
+ 	kvm_put_kvm(kvm);
+ 	return rc;
+ }
+ 
+ static void kvm_s390_pci_unregister_kvm(void *opaque)
+ {
+ 	struct zpci_dev *zdev = opaque;
+ 	struct kvm *kvm;
+ 
+ 	if (!zdev)
+ 		return;
+ 
+ 	mutex_lock(&zdev->kzdev_lock);
+ 
+ 	if (WARN_ON(!zdev->kzdev)) {
+ 		mutex_unlock(&zdev->kzdev_lock);
+ 		return;
+ 	}
+ 
+ 	kvm = zdev->kzdev->kvm;
+ 	mutex_lock(&kvm->lock);
+ 
+ 	/*
+ 	 * A 0 gisa means interpretation was never enabled, just remove the
+ 	 * device from the list.
+ 	 */
+ 	if (zdev->gisa == 0)
+ 		goto out;
+ 
+ 	/* Forwarding must be turned off before interpretation */
+ 	if (zdev->kzdev->fib.fmt0.aibv != 0)
+ 		kvm_s390_pci_aif_disable(zdev, true);
+ 
+ 	/* Remove the host CLP guest designation */
+ 	zdev->gisa = 0;
+ 
+ 	if (zdev_enabled(zdev)) {
+ 		if (zpci_disable_device(zdev))
+ 			goto out;
+ 	}
+ 
+ 	if (zpci_enable_device(zdev))
+ 		goto out;
+ 
+ 	/* Re-register the IOMMU that was already created */
+ 	zpci_register_ioat(zdev, 0, zdev->start_dma, zdev->end_dma,
+ 			   virt_to_phys(zdev->dma_table));
+ 
+ out:
+ 	spin_lock(&kvm->arch.kzdev_list_lock);
+ 	list_del(&zdev->kzdev->entry);
+ 	spin_unlock(&kvm->arch.kzdev_list_lock);
+ 	kvm_s390_pci_dev_release(zdev);
+ 
+ 	mutex_unlock(&kvm->lock);
+ 	mutex_unlock(&zdev->kzdev_lock);
+ 
+ 	kvm_put_kvm(kvm);
+ }
+ 
+ void kvm_s390_pci_init_list(struct kvm *kvm)
+ {
+ 	spin_lock_init(&kvm->arch.kzdev_list_lock);
+ 	INIT_LIST_HEAD(&kvm->arch.kzdev_list);
+ }
+ 
+ void kvm_s390_pci_clear_list(struct kvm *kvm)
+ {
+ 	/*
+ 	 * This list should already be empty, either via vfio device closures
+ 	 * or kvm fd cleanup.
+ 	 */
+ 	spin_lock(&kvm->arch.kzdev_list_lock);
+ 	WARN_ON_ONCE(!list_empty(&kvm->arch.kzdev_list));
+ 	spin_unlock(&kvm->arch.kzdev_list_lock);
+ }
+ 
+ static struct zpci_dev *get_zdev_from_kvm_by_fh(struct kvm *kvm, u32 fh)
+ {
+ 	struct zpci_dev *zdev = NULL;
+ 	struct kvm_zdev *kzdev;
+ 
+ 	spin_lock(&kvm->arch.kzdev_list_lock);
+ 	list_for_each_entry(kzdev, &kvm->arch.kzdev_list, entry) {
+ 		if (kzdev->zdev->fh == fh) {
+ 			zdev = kzdev->zdev;
+ 			break;
+ 		}
+ 	}
+ 	spin_unlock(&kvm->arch.kzdev_list_lock);
+ 
+ 	return zdev;
+ }
+ 
+ static int kvm_s390_pci_zpci_reg_aen(struct zpci_dev *zdev,
+ 				     struct kvm_s390_zpci_op *args)
+ {
+ 	struct zpci_fib fib = {};
+ 	bool hostflag;
+ 
+ 	fib.fmt0.aibv = args->u.reg_aen.ibv;
+ 	fib.fmt0.isc = args->u.reg_aen.isc;
+ 	fib.fmt0.noi = args->u.reg_aen.noi;
+ 	if (args->u.reg_aen.sb != 0) {
+ 		fib.fmt0.aisb = args->u.reg_aen.sb;
+ 		fib.fmt0.aisbo = args->u.reg_aen.sbo;
+ 		fib.fmt0.sum = 1;
+ 	} else {
+ 		fib.fmt0.aisb = 0;
+ 		fib.fmt0.aisbo = 0;
+ 		fib.fmt0.sum = 0;
+ 	}
+ 
+ 	hostflag = !(args->u.reg_aen.flags & KVM_S390_ZPCIOP_REGAEN_HOST);
+ 	return kvm_s390_pci_aif_enable(zdev, &fib, hostflag);
+ }
+ 
+ int kvm_s390_pci_zpci_op(struct kvm *kvm, struct kvm_s390_zpci_op *args)
+ {
+ 	struct kvm_zdev *kzdev;
+ 	struct zpci_dev *zdev;
+ 	int r;
+ 
+ 	zdev = get_zdev_from_kvm_by_fh(kvm, args->fh);
+ 	if (!zdev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&zdev->kzdev_lock);
+ 	mutex_lock(&kvm->lock);
+ 
+ 	kzdev = zdev->kzdev;
+ 	if (!kzdev) {
+ 		r = -ENODEV;
+ 		goto out;
+ 	}
+ 	if (kzdev->kvm != kvm) {
+ 		r = -EPERM;
+ 		goto out;
+ 	}
+ 
+ 	switch (args->op) {
+ 	case KVM_S390_ZPCIOP_REG_AEN:
+ 		/* Fail on unknown flags */
+ 		if (args->u.reg_aen.flags & ~KVM_S390_ZPCIOP_REGAEN_HOST) {
+ 			r = -EINVAL;
+ 			break;
+ 		}
+ 		r = kvm_s390_pci_zpci_reg_aen(zdev, args);
+ 		break;
+ 	case KVM_S390_ZPCIOP_DEREG_AEN:
+ 		r = kvm_s390_pci_aif_disable(zdev, false);
+ 		break;
+ 	default:
+ 		r = -EINVAL;
+ 	}
+ 
+ out:
+ 	mutex_unlock(&kvm->lock);
+ 	mutex_unlock(&zdev->kzdev_lock);
+ 	return r;
+ }
+ 
++>>>>>>> ca922fecda6c (KVM: s390: pci: Hook to access KVM lowlevel from VFIO)
  int kvm_s390_pci_init(void)
  {
  	aift = kzalloc(sizeof(struct zpci_aift), GFP_KERNEL);
diff --cc arch/s390/pci/Makefile
index b4e3c84772a1,5ae31ca9dd44..000000000000
--- a/arch/s390/pci/Makefile
+++ b/arch/s390/pci/Makefile
@@@ -5,4 -5,5 +5,9 @@@
  
  obj-$(CONFIG_PCI)	+= pci.o pci_irq.o pci_dma.o pci_clp.o pci_sysfs.o \
  			   pci_event.o pci_debug.o pci_insn.o pci_mmio.o \
++<<<<<<< HEAD
 +			   pci_bus.o
++=======
+ 			   pci_bus.o pci_kvm_hook.o
+ obj-$(CONFIG_PCI_IOV)	+= pci_iov.o
++>>>>>>> ca922fecda6c (KVM: s390: pci: Hook to access KVM lowlevel from VFIO)
diff --cc drivers/vfio/pci/vfio_pci_zdev.c
index 21cbdad2a1e1,0cbdcd14f1c8..000000000000
--- a/drivers/vfio/pci/vfio_pci_zdev.c
+++ b/drivers/vfio/pci/vfio_pci_zdev.c
@@@ -148,3 -140,30 +148,33 @@@ int vfio_pci_info_zdev_add_caps(struct 
  
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ int vfio_pci_zdev_open_device(struct vfio_pci_core_device *vdev)
+ {
+ 	struct zpci_dev *zdev = to_zpci(vdev->pdev);
+ 
+ 	if (!zdev)
+ 		return -ENODEV;
+ 
+ 	if (!vdev->vdev.kvm)
+ 		return 0;
+ 
+ 	if (zpci_kvm_hook.kvm_register)
+ 		return zpci_kvm_hook.kvm_register(zdev, vdev->vdev.kvm);
+ 
+ 	return -ENOENT;
+ }
+ 
+ void vfio_pci_zdev_close_device(struct vfio_pci_core_device *vdev)
+ {
+ 	struct zpci_dev *zdev = to_zpci(vdev->pdev);
+ 
+ 	if (!zdev || !vdev->vdev.kvm)
+ 		return;
+ 
+ 	if (zpci_kvm_hook.kvm_unregister)
+ 		zpci_kvm_hook.kvm_unregister(zdev);
+ }
++>>>>>>> ca922fecda6c (KVM: s390: pci: Hook to access KVM lowlevel from VFIO)
* Unmerged path arch/s390/include/asm/kvm_host.h
* Unmerged path arch/s390/kvm/pci.c
* Unmerged path arch/s390/pci/Makefile
diff --git a/arch/s390/pci/pci_kvm_hook.c b/arch/s390/pci/pci_kvm_hook.c
new file mode 100644
index 000000000000..ff34baf50a3e
--- /dev/null
+++ b/arch/s390/pci/pci_kvm_hook.c
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * VFIO ZPCI devices support
+ *
+ * Copyright (C) IBM Corp. 2022.  All rights reserved.
+ *	Author(s): Pierre Morel <pmorel@linux.ibm.com>
+ */
+#include <linux/kvm_host.h>
+
+struct zpci_kvm_hook zpci_kvm_hook;
+EXPORT_SYMBOL_GPL(zpci_kvm_hook);
* Unmerged path drivers/vfio/pci/vfio_pci_zdev.c
