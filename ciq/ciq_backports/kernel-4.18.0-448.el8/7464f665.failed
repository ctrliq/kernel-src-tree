wifi: cfg80211: add cfg80211_get_iftype_ext_capa()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 7464f665158e09f3f29116d8d0676824c1f1eeda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7464f665.failed

Add a helper function cfg80211_get_iftype_ext_capa() to
look up interface type-specific (extended) capabilities.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 7464f665158e09f3f29116d8d0676824c1f1eeda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/util.c
diff --cc net/wireless/util.c
index 2eda097aee7f,2c127951764a..000000000000
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@@ -2417,3 -2447,60 +2417,63 @@@ bool cfg80211_iftype_allowed(struct wip
  	return false;
  }
  EXPORT_SYMBOL(cfg80211_iftype_allowed);
++<<<<<<< HEAD
++=======
+ 
+ void cfg80211_remove_link(struct wireless_dev *wdev, unsigned int link_id)
+ {
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+ 
+ 	ASSERT_WDEV_LOCK(wdev);
+ 
+ 	switch (wdev->iftype) {
+ 	case NL80211_IFTYPE_AP:
+ 	case NL80211_IFTYPE_P2P_GO:
+ 		__cfg80211_stop_ap(rdev, wdev->netdev, link_id, true);
+ 		break;
+ 	default:
+ 		/* per-link not relevant */
+ 		break;
+ 	}
+ 
+ 	wdev->valid_links &= ~BIT(link_id);
+ 
+ 	rdev_del_intf_link(rdev, wdev, link_id);
+ 
+ 	eth_zero_addr(wdev->links[link_id].addr);
+ }
+ 
+ void cfg80211_remove_links(struct wireless_dev *wdev)
+ {
+ 	unsigned int link_id;
+ 
+ 	wdev_lock(wdev);
+ 	if (wdev->valid_links) {
+ 		for_each_valid_link(wdev, link_id)
+ 			cfg80211_remove_link(wdev, link_id);
+ 	}
+ 	wdev_unlock(wdev);
+ }
+ 
+ int cfg80211_remove_virtual_intf(struct cfg80211_registered_device *rdev,
+ 				 struct wireless_dev *wdev)
+ {
+ 	cfg80211_remove_links(wdev);
+ 
+ 	return rdev_del_virtual_intf(rdev, wdev);
+ }
+ 
+ const struct wiphy_iftype_ext_capab *
+ cfg80211_get_iftype_ext_capa(struct wiphy *wiphy, enum nl80211_iftype type)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < wiphy->num_iftype_ext_capab; i++) {
+ 		if (wiphy->iftype_ext_capab[i].iftype == type)
+ 			return &wiphy->iftype_ext_capab[i];
+ 	}
+ 
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(cfg80211_get_iftype_ext_capa);
++>>>>>>> 7464f665158e (wifi: cfg80211: add cfg80211_get_iftype_ext_capa())
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index cd95695599be..50f911b763ac 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -4894,6 +4894,14 @@ struct wiphy_iftype_ext_capab {
 	u8 extended_capabilities_len;
 };
 
+/**
+ * cfg80211_get_iftype_ext_capa - lookup interface type extended capability
+ * @wiphy: the wiphy to look up from
+ * @type: the interface type to look up
+ */
+const struct wiphy_iftype_ext_capab *
+cfg80211_get_iftype_ext_capa(struct wiphy *wiphy, enum nl80211_iftype type);
+
 /**
  * struct cfg80211_pmsr_capabilities - cfg80211 peer measurement capabilities
  * @max_peers: maximum number of peers in a single measurement
* Unmerged path net/wireless/util.c
