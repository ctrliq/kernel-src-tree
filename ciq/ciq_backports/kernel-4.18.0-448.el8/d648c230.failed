wifi: nl80211: support MLO in auth/assoc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit d648c23024bd01333acd2fd5e34bcde0ffb66b16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d648c230.failed

For authentication, we need the BSS, the link_id and the AP
MLD address to create the link and station, (for now) the
driver assigns a link address and sends the frame, the MLD
address needs to be the address of the interface.

For association, pass the list of BSSes that were selected
for the MLO connection, along with extra per-STA profile
elements, the AP MLD address and the link ID on which the
association request should be sent.

Note that for now we don't have a proper way to pass the link
address(es) and so the driver/mac80211 will select one, but
depending on how that selection works it means that assoc w/o
auth data still being around (mac80211 implementation detail)
the association won't necessarily work - so this will need to
be extended in the future to sort out the link addressing.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit d648c23024bd01333acd2fd5e34bcde0ffb66b16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/nl80211.h
#	net/wireless/mlme.c
#	net/wireless/nl80211.c
#	net/wireless/sme.c
diff --cc include/uapi/linux/nl80211.h
index 89c2cfb97539,60ad9a9f153d..000000000000
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@@ -2653,6 -2683,13 +2653,16 @@@ enum nl80211_commands 
   *	association request when used with NL80211_CMD_NEW_STATION). Can be set
   *	only if %NL80211_STA_FLAG_WME is set.
   *
++<<<<<<< HEAD
++=======
+  * @NL80211_ATTR_MLO_LINK_ID: A (u8) link ID for use with MLO, to be used with
+  *	various commands that need a link ID to operate.
+  * @NL80211_ATTR_MLO_LINKS: A nested array of links, each containing some
+  *	per-link information and a link ID.
+  * @NL80211_ATTR_MLD_ADDR: An MLD address, used with various commands such as
+  *	authenticate/associate.
+  *
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
   * @NUM_NL80211_ATTR: total number of nl80211_attrs available
   * @NL80211_ATTR_MAX: highest attribute number currently defined
   * @__NL80211_ATTR_AFTER_LAST: internal use
@@@ -3167,6 -3204,10 +3177,13 @@@ enum nl80211_attrs 
  
  	NL80211_ATTR_DISABLE_EHT,
  
++<<<<<<< HEAD
++=======
+ 	NL80211_ATTR_MLO_LINKS,
+ 	NL80211_ATTR_MLO_LINK_ID,
+ 	NL80211_ATTR_MLD_ADDR,
+ 
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
  	/* add attributes here, update the policy in nl80211.c */
  
  	__NL80211_ATTR_AFTER_LAST,
diff --cc net/wireless/mlme.c
index dde8de9bb5a5,d92eed0e52cd..000000000000
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@@ -256,24 -238,24 +256,37 @@@ int cfg80211_mlme_auth(struct cfg80211_
  
  	ASSERT_WDEV_LOCK(wdev);
  
++<<<<<<< HEAD
 +	if (auth_type == NL80211_AUTHTYPE_SHARED_KEY)
 +		if (!key || !key_len || key_idx < 0 || key_idx > 3)
++=======
+ 	if (!req->bss)
+ 		return -ENOENT;
+ 
+ 	if (req->link_id >= 0 &&
+ 	    !(wdev->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))
+ 		return -EINVAL;
+ 
+ 	if (req->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
+ 		if (!req->key || !req->key_len ||
+ 		    req->key_idx < 0 || req->key_idx > 3)
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
  			return -EINVAL;
 -	}
  
 -	if (wdev->connected &&
 -	    ether_addr_equal(req->bss->bssid, wdev->u.client.connected_addr))
 +	if (wdev->current_bss &&
 +	    ether_addr_equal(bssid, wdev->current_bss->pub.bssid))
  		return -EALREADY;
  
 -	return rdev_auth(rdev, dev, req);
 +	req.bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,
 +				   IEEE80211_BSS_TYPE_ESS,
 +				   IEEE80211_PRIVACY_ANY);
 +	if (!req.bss)
 +		return -ENOENT;
 +
 +	err = rdev_auth(rdev, dev, &req);
 +
 +	cfg80211_put_bss(&rdev->wiphy, req.bss);
 +	return err;
  }
  
  /*  Do a logical ht_capa &= ht_capa_mask.  */
@@@ -320,9 -302,18 +333,24 @@@ int cfg80211_mlme_assoc(struct cfg80211
  
  	ASSERT_WDEV_LOCK(wdev);
  
++<<<<<<< HEAD
 +	if (wdev->current_bss &&
 +	    (!req->prev_bssid || !ether_addr_equal(wdev->current_bss->pub.bssid,
 +						   req->prev_bssid)))
++=======
+ 	for (i = 1; i < ARRAY_SIZE(req->links); i++) {
+ 		if (!req->links[i].bss)
+ 			continue;
+ 		for (j = 0; j < i; j++) {
+ 			if (req->links[i].bss == req->links[j].bss)
+ 				return -EINVAL;
+ 		}
+ 	}
+ 
+ 	if (wdev->connected &&
+ 	    (!req->prev_bssid ||
+ 	     !ether_addr_equal(wdev->u.client.connected_addr, req->prev_bssid)))
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
  		return -EALREADY;
  
  	cfg80211_oper_and_ht_capa(&req->ht_capa_mask,
diff --cc net/wireless/nl80211.c
index 61943281a64c,9bc66a21ac3a..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -792,6 -792,11 +792,14 @@@ static const struct nla_policy nl80211_
  				 NL80211_EHT_MIN_CAPABILITY_LEN,
  				 NL80211_EHT_MAX_CAPABILITY_LEN),
  	[NL80211_ATTR_DISABLE_EHT] = { .type = NLA_FLAG },
++<<<<<<< HEAD
++=======
+ 	[NL80211_ATTR_MLO_LINKS] =
+ 		NLA_POLICY_NESTED_ARRAY(nl80211_policy),
+ 	[NL80211_ATTR_MLO_LINK_ID] =
+ 		NLA_POLICY_RANGE(NLA_U8, 0, IEEE80211_MLD_MAX_NUM_LINKS),
+ 	[NL80211_ATTR_MLD_ADDR] = NLA_POLICY_EXACT_LEN(ETH_ALEN),
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
  };
  
  /* policy for the key attributes */
@@@ -10164,12 -10279,29 +10172,32 @@@ static int nl80211_authenticate(struct 
  	if (local_state_change)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	req.auth_type = auth_type;
+ 	req.key = key.p.key;
+ 	req.key_len = key.p.key_len;
+ 	req.key_idx = key.idx;
+ 	req.link_id = nl80211_link_id_or_invalid(info->attrs);
+ 	if (req.link_id >= 0) {
+ 		if (!info->attrs[NL80211_ATTR_MLD_ADDR])
+ 			return -EINVAL;
+ 		req.ap_mld_addr = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);
+ 	}
+ 
+ 	req.bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,
+ 				   IEEE80211_BSS_TYPE_ESS,
+ 				   IEEE80211_PRIVACY_ANY);
+ 	if (!req.bss)
+ 		return -ENOENT;
+ 
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
  	wdev_lock(dev->ieee80211_ptr);
 -	err = cfg80211_mlme_auth(rdev, dev, &req);
 +	err = cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,
 +				 ssid, ssid_len, ie, ie_len,
 +				 key.p.key, key.p.key_len, key.idx,
 +				 auth_data, auth_data_len);
  	wdev_unlock(dev->ieee80211_ptr);
 -
 -	cfg80211_put_bss(&rdev->wiphy, req.bss);
 -
  	return err;
  }
  
diff --cc net/wireless/sme.c
index 1001c6b3bcf5,b3c6ce4f85ee..000000000000
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@@ -167,13 -168,19 +167,29 @@@ static int cfg80211_conn_do_work(struc
  		if (WARN_ON(!rdev->ops->auth))
  			return -EOPNOTSUPP;
  		wdev->conn->state = CFG80211_CONN_AUTHENTICATING;
++<<<<<<< HEAD
 +		return cfg80211_mlme_auth(rdev, wdev->netdev,
 +					  params->channel, params->auth_type,
 +					  params->bssid,
 +					  params->ssid, params->ssid_len,
 +					  NULL, 0,
 +					  params->key, params->key_len,
 +					  params->key_idx, NULL, 0);
++=======
+ 		auth_req.key = params->key;
+ 		auth_req.key_len = params->key_len;
+ 		auth_req.key_idx = params->key_idx;
+ 		auth_req.auth_type = params->auth_type;
+ 		auth_req.bss = cfg80211_get_bss(&rdev->wiphy, params->channel,
+ 						params->bssid,
+ 						params->ssid, params->ssid_len,
+ 						IEEE80211_BSS_TYPE_ESS,
+ 						IEEE80211_PRIVACY_ANY);
+ 		auth_req.link_id = -1;
+ 		err = cfg80211_mlme_auth(rdev, wdev->netdev, &auth_req);
+ 		cfg80211_put_bss(&rdev->wiphy, auth_req.bss);
+ 		return err;
++>>>>>>> d648c23024bd (wifi: nl80211: support MLO in auth/assoc)
  	case CFG80211_CONN_AUTH_FAILED_TIMEOUT:
  		*treason = NL80211_TIMEOUT_AUTH;
  		return -ENOTCONN;
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 3eeec9c7c79b..f010f315f9ca 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -2714,6 +2714,12 @@ static inline const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 id)
  *	Authentication algorithm number, i.e., starting at the Authentication
  *	transaction sequence number field.
  * @auth_data_len: Length of auth_data buffer in octets
+ * @link_id: if >= 0, indicates authentication should be done as an MLD,
+ *	the interface address is included as the MLD address and the
+ *	necessary link (with the given link_id) will be created (and
+ *	given an MLD address) by the driver
+ * @ap_mld_addr: AP MLD address in case of authentication request with
+ *	an AP MLD, valid iff @link_id >= 0
  */
 struct cfg80211_auth_request {
 	struct cfg80211_bss *bss;
@@ -2724,6 +2730,21 @@ struct cfg80211_auth_request {
 	u8 key_len, key_idx;
 	const u8 *auth_data;
 	size_t auth_data_len;
+	s8 link_id;
+	const u8 *ap_mld_addr;
+};
+
+/**
+ * struct cfg80211_assoc_link - per-link information for MLO association
+ * @bss: the BSS pointer, see also &struct cfg80211_assoc_request::bss;
+ *	if this is %NULL for a link, that link is not requested
+ * @elems: extra elements for the per-STA profile for this link
+ * @elems_len: length of the elements
+ */
+struct cfg80211_assoc_link {
+	struct cfg80211_bss *bss;
+	const u8 *elems;
+	size_t elems_len;
 };
 
 /**
@@ -2757,6 +2778,8 @@ enum cfg80211_assoc_req_flags {
  *	given a reference that it must give back to cfg80211_send_rx_assoc()
  *	or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
  *	association requests while already associating must be rejected.
+ *	This also applies to the @links.bss parameter, which is used instead
+ *	of this one (it is %NULL) for MLO associations.
  * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
  * @ie_len: Length of ie buffer in octets
  * @use_mfp: Use management frame protection (IEEE 802.11w) in this association
@@ -2781,6 +2804,11 @@ enum cfg80211_assoc_req_flags {
  *	with 16 octets of STA Nonce followed by 16 octets of AP Nonce.
  * @s1g_capa: S1G capability override
  * @s1g_capa_mask: S1G capability override mask
+ * @links: per-link information for MLO connections
+ * @link_id: >= 0 for MLO connections, where links are given, and indicates
+ *	the link on which the association request should be sent
+ * @ap_mld_addr: AP MLD address in case of MLO association request,
+ *	valid iff @link_id >= 0
  */
 struct cfg80211_assoc_request {
 	struct cfg80211_bss *bss;
@@ -2796,6 +2824,9 @@ struct cfg80211_assoc_request {
 	size_t fils_kek_len;
 	const u8 *fils_nonces;
 	struct ieee80211_s1g_cap s1g_capa, s1g_capa_mask;
+	struct cfg80211_assoc_link links[IEEE80211_MLD_MAX_NUM_LINKS];
+	const u8 *ap_mld_addr;
+	s8 link_id;
 };
 
 /**
* Unmerged path include/uapi/linux/nl80211.h
* Unmerged path net/wireless/mlme.c
* Unmerged path net/wireless/nl80211.c
* Unmerged path net/wireless/sme.c
