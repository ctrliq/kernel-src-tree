wifi: mac80211: keep recently active tx queues in scheduling list

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Felix Fietkau <nbd@nbd.name>
commit 8ccc07028cb7aaa6ad313f24a9442c7796416e19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8ccc0702.failed

This allows proper deficit accounting to ensure that they don't carry their
deficit until the next time they become active

	Signed-off-by: Felix Fietkau <nbd@nbd.name>
	Acked-by: Toke Høiland-Jørgensen <toke@toke.dk>
Link: https://lore.kernel.org/r/20220625212411.36675-4-nbd@nbd.name
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 8ccc07028cb7aaa6ad313f24a9442c7796416e19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/sta_info.h
#	net/mac80211/tx.c
diff --cc net/mac80211/sta_info.h
index addc78b398f0,70ee55ec5518..000000000000
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@@ -139,9 -138,8 +139,14 @@@ enum ieee80211_agg_stop_reason 
  struct airtime_info {
  	u64 rx_airtime;
  	u64 tx_airtime;
++<<<<<<< HEAD
 +	u64 v_t;
 +	u64 last_scheduled;
 +	struct list_head list;
++=======
+ 	u32 last_active;
+ 	s32 deficit;
++>>>>>>> 8ccc07028cb7 (wifi: mac80211: keep recently active tx queues in scheduling list)
  	atomic_t aql_tx_pending; /* Estimated airtime for frames pending */
  	u32 aql_limit_low;
  	u32 aql_limit_high;
diff --cc net/mac80211/tx.c
index 59b212870021,71c1d2a5eef3..000000000000
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@@ -3784,50 -3800,98 +3784,117 @@@ out
  }
  EXPORT_SYMBOL(ieee80211_tx_dequeue);
  
++<<<<<<< HEAD
++=======
+ static inline s32 ieee80211_sta_deficit(struct sta_info *sta, u8 ac)
+ {
+ 	struct airtime_info *air_info = &sta->airtime[ac];
+ 
+ 	return air_info->deficit - atomic_read(&air_info->aql_tx_pending);
+ }
+ 
+ static void
+ ieee80211_txq_set_active(struct txq_info *txqi)
+ {
+ 	struct sta_info *sta;
+ 
+ 	if (!txqi->txq.sta)
+ 		return;
+ 
+ 	sta = container_of(txqi->txq.sta, struct sta_info, sta);
+ 	sta->airtime[txqi->txq.ac].last_active = (u32)jiffies;
+ }
+ 
+ static bool
+ ieee80211_txq_keep_active(struct txq_info *txqi)
+ {
+ 	struct sta_info *sta;
+ 	u32 diff;
+ 
+ 	if (!txqi->txq.sta)
+ 		return false;
+ 
+ 	sta = container_of(txqi->txq.sta, struct sta_info, sta);
+ 	if (ieee80211_sta_deficit(sta, txqi->txq.ac) >= 0)
+ 		return false;
+ 
+ 	diff = (u32)jiffies - sta->airtime[txqi->txq.ac].last_active;
+ 
+ 	return diff <= AIRTIME_ACTIVE_DURATION;
+ }
+ 
++>>>>>>> 8ccc07028cb7 (wifi: mac80211: keep recently active tx queues in scheduling list)
  struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
  {
  	struct ieee80211_local *local = hw_to_local(hw);
 +	struct airtime_sched_info *air_sched;
 +	u64 now = ktime_get_coarse_boottime_ns();
  	struct ieee80211_txq *ret = NULL;
 -	struct txq_info *txqi = NULL, *head = NULL;
 -	bool found_eligible_txq = false;
 +	struct airtime_info *air_info;
 +	struct txq_info *txqi = NULL;
 +	struct rb_node *node;
 +	bool first = false;
  
 -	spin_lock_bh(&local->active_txq_lock[ac]);
 +	air_sched = &local->airtime[ac];
 +	spin_lock_bh(&air_sched->lock);
  
 - begin:
 -	txqi = list_first_entry_or_null(&local->active_txqs[ac],
 -					struct txq_info,
 -					schedule_order);
 -	if (!txqi)
 -		goto out;
 +	node = air_sched->schedule_pos;
  
 -	if (txqi == head) {
 -		if (!found_eligible_txq)
 -			goto out;
 -		else
 -			found_eligible_txq = false;
 +begin:
 +	if (!node) {
 +		node = rb_first_cached(&air_sched->active_txqs);
 +		first = true;
 +	} else {
 +		node = rb_next(node);
  	}
  
++<<<<<<< HEAD
 +	if (!node)
++=======
+ 	if (!head)
+ 		head = txqi;
+ 
+ 	if (txqi->txq.sta) {
+ 		struct sta_info *sta = container_of(txqi->txq.sta,
+ 						    struct sta_info, sta);
+ 		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
+ 		s32 deficit = ieee80211_sta_deficit(sta, txqi->txq.ac);
+ 
+ 		if (aql_check)
+ 			found_eligible_txq = true;
+ 
+ 		if (deficit < 0)
+ 			sta->airtime[txqi->txq.ac].deficit +=
+ 				sta->airtime_weight;
+ 
+ 		if (deficit < 0 || !aql_check) {
+ 			list_move_tail(&txqi->schedule_order,
+ 				       &local->active_txqs[txqi->txq.ac]);
+ 			goto begin;
+ 		}
+ 	}
+ 
+ 	if (txqi->schedule_round == local->schedule_round[ac])
++>>>>>>> 8ccc07028cb7 (wifi: mac80211: keep recently active tx queues in scheduling list)
  		goto out;
  
 -	list_del_init(&txqi->schedule_order);
 -	txqi->schedule_round = local->schedule_round[ac];
 -	ret = &txqi->txq;
 +	txqi = container_of(node, struct txq_info, schedule_order);
 +	air_info = to_airtime_info(&txqi->txq);
 +
 +	if (air_info->v_t > air_sched->v_t &&
 +	    (!first || !airtime_catchup_v_t(air_sched, air_info->v_t, now)))
 +		goto out;
 +
 +	if (!ieee80211_txq_airtime_check(hw, &txqi->txq)) {
 +		first = false;
 +		goto begin;
 +	}
  
 +	air_sched->schedule_pos = node;
 +	air_sched->last_schedule_activity = now;
 +	ret = &txqi->txq;
  out:
 -	spin_unlock_bh(&local->active_txq_lock[ac]);
 +	spin_unlock_bh(&air_sched->lock);
  	return ret;
  }
  EXPORT_SYMBOL(ieee80211_next_txq);
@@@ -4023,16 -3902,35 +4090,41 @@@ void ieee80211_return_txq(struct ieee80
  {
  	struct ieee80211_local *local = hw_to_local(hw);
  	struct txq_info *txqi = to_txq_info(txq);
+ 	bool has_queue;
  
 -	spin_lock_bh(&local->active_txq_lock[txq->ac]);
 +	spin_lock_bh(&local->airtime[txq->ac].lock);
  
++<<<<<<< HEAD
 +	if (!RB_EMPTY_NODE(&txqi->schedule_order) && !force &&
 +	    !txq_has_queue(txq))
 +		__ieee80211_unschedule_txq(hw, txq, false);
++=======
+ 	has_queue = force || txq_has_queue(txq);
+ 	if (list_empty(&txqi->schedule_order) &&
+ 	    (has_queue || ieee80211_txq_keep_active(txqi))) {
+ 		/* If airtime accounting is active, always enqueue STAs at the
+ 		 * head of the list to ensure that they only get moved to the
+ 		 * back by the airtime DRR scheduler once they have a negative
+ 		 * deficit. A station that already has a negative deficit will
+ 		 * get immediately moved to the back of the list on the next
+ 		 * call to ieee80211_next_txq().
+ 		 */
+ 		if (txqi->txq.sta && local->airtime_flags && has_queue &&
+ 		    wiphy_ext_feature_isset(local->hw.wiphy,
+ 					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+ 			list_add(&txqi->schedule_order,
+ 				 &local->active_txqs[txq->ac]);
+ 		else
+ 			list_add_tail(&txqi->schedule_order,
+ 				      &local->active_txqs[txq->ac]);
+ 		if (has_queue)
+ 			ieee80211_txq_set_active(txqi);
+ 	}
++>>>>>>> 8ccc07028cb7 (wifi: mac80211: keep recently active tx queues in scheduling list)
  
 -	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
 +	spin_unlock_bh(&local->airtime[txq->ac].lock);
  }
 -EXPORT_SYMBOL(__ieee80211_schedule_txq);
 +EXPORT_SYMBOL(ieee80211_return_txq);
  
  DEFINE_STATIC_KEY_FALSE(aql_disable);
  
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index be4db4fb3d33..143da5b2901b 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -83,6 +83,13 @@ extern const u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS];
 
 #define IEEE80211_MAX_NAN_INSTANCE_ID 255
 
+
+/*
+ * Keep a station's queues on the active list for deficit accounting purposes
+ * if it was active or queued during the last 100ms
+ */
+#define AIRTIME_ACTIVE_DURATION (HZ / 10)
+
 struct ieee80211_bss {
 	u32 device_ts_beacon, device_ts_presp;
 
* Unmerged path net/mac80211/sta_info.h
* Unmerged path net/mac80211/tx.c
