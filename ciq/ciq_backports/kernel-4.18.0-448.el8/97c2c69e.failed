virtio-net: support XDP when not more queues

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Xuan Zhuo <xuanzhuo@linux.alibaba.com>
commit 97c2c69e1926260c78c7f1c0b2c987934f1dc7a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/97c2c69e.failed

The number of queues implemented by many virtio backends is limited,
especially some machines have a large number of CPUs. In this case, it
is often impossible to allocate a separate queue for
XDP_TX/XDP_REDIRECT, then xdp cannot be loaded to work, even xdp does
not use the XDP_TX/XDP_REDIRECT.

This patch allows XDP_TX/XDP_REDIRECT to run by reuse the existing SQ
with __netif_tx_lock() hold when there are not enough queues.

	Signed-off-by: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
	Reviewed-by: Dust Li <dust.li@linux.alibaba.com>
	Acked-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 97c2c69e1926260c78c7f1c0b2c987934f1dc7a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/virtio_net.c
diff --cc drivers/net/virtio_net.c
index 8f71eb2ce0d1,e97288dd6e5a..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -2492,12 -2452,15 +2526,11 @@@ static int virtnet_xdp_set(struct net_d
  
  	/* XDP requires extra queues for XDP_TX */
  	if (curr_qp + xdp_qp > vi->max_queue_pairs) {
- 		NL_SET_ERR_MSG_MOD(extack, "Too few free TX rings available");
- 		netdev_warn(dev, "request %i queues but max is %i\n",
+ 		netdev_warn(dev, "XDP request %i queues but max is %i. XDP_TX and XDP_REDIRECT will operate in a slower locked tx mode.\n",
  			    curr_qp + xdp_qp, vi->max_queue_pairs);
- 		return -ENOMEM;
+ 		xdp_qp = 0;
  	}
  
 -	old_prog = rtnl_dereference(vi->rq[0].xdp_prog);
 -	if (!prog && !old_prog)
 -		return 0;
 -
  	if (prog)
  		bpf_prog_add(prog, vi->max_queue_pairs - 1);
  
@@@ -2515,15 -2487,18 +2548,29 @@@
  	netif_set_real_num_rx_queues(dev, curr_qp + xdp_qp);
  	vi->xdp_queue_pairs = xdp_qp;
  
++<<<<<<< HEAD
++=======
+ 	if (prog) {
+ 		vi->xdp_enabled = true;
+ 		for (i = 0; i < vi->max_queue_pairs; i++) {
+ 			rcu_assign_pointer(vi->rq[i].xdp_prog, prog);
+ 			if (i == 0 && !old_prog)
+ 				virtnet_clear_guest_offloads(vi);
+ 		}
+ 	} else {
+ 		vi->xdp_enabled = false;
+ 	}
+ 
++>>>>>>> 97c2c69e1926 (virtio-net: support XDP when not more queues)
  	for (i = 0; i < vi->max_queue_pairs; i++) {
 +		old_prog = rtnl_dereference(vi->rq[i].xdp_prog);
 +		rcu_assign_pointer(vi->rq[i].xdp_prog, prog);
 +		if (i == 0) {
 +			if (!old_prog)
 +				virtnet_clear_guest_offloads(vi);
 +			if (!prog)
 +				virtnet_restore_guest_offloads(vi);
 +		}
  		if (old_prog)
  			bpf_prog_put(old_prog);
  		if (netif_running(dev)) {
@@@ -2574,6 -2555,32 +2621,35 @@@ static int virtnet_get_phys_port_name(s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int virtnet_set_features(struct net_device *dev,
+ 				netdev_features_t features)
+ {
+ 	struct virtnet_info *vi = netdev_priv(dev);
+ 	u64 offloads;
+ 	int err;
+ 
+ 	if ((dev->features ^ features) & NETIF_F_LRO) {
+ 		if (vi->xdp_enabled)
+ 			return -EBUSY;
+ 
+ 		if (features & NETIF_F_LRO)
+ 			offloads = vi->guest_offloads_capable;
+ 		else
+ 			offloads = vi->guest_offloads_capable &
+ 				   ~GUEST_OFFLOAD_LRO_MASK;
+ 
+ 		err = virtnet_set_guest_offloads(vi, offloads);
+ 		if (err)
+ 			return err;
+ 		vi->guest_offloads = offloads;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 97c2c69e1926 (virtio-net: support XDP when not more queues)
  static const struct net_device_ops virtnet_netdev = {
  	.ndo_open            = virtnet_open,
  	.ndo_stop   	     = virtnet_close,
* Unmerged path drivers/net/virtio_net.c
