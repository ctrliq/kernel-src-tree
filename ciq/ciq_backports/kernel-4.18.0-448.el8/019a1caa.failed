Bluetooth: btintel: Refactoring setup routine for bootloader devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tedd Ho-Jeong An <tedd.an@intel.com>
commit 019a1caa7fd2c9bb689f9a15fe8cb1d53aa6d8b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/019a1caa.failed

This patch refactors the setup routines for legacy and TLV based
bootloader devices to the combined setup, and move the related functions
from btusb to btintel.

	Signed-off-by: Tedd Ho-Jeong An <tedd.an@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 019a1caa7fd2c9bb689f9a15fe8cb1d53aa6d8b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btintel.c
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btintel.c
index 949020fa0142,8593b27b7c4a..000000000000
--- a/drivers/bluetooth/btintel.c
+++ b/drivers/bluetooth/btintel.c
@@@ -1800,7 -2351,8 +2305,12 @@@ int btintel_configure_setup(struct hci_
  	hdev->manufacturer = 2;
  	hdev->setup = btintel_setup_combined;
  	hdev->shutdown = btintel_shutdown_combined;
++<<<<<<< HEAD
 +	hdev->set_diag = btintel_set_diag_mfg;
++=======
+ 	hdev->hw_error = btintel_hw_error;
+ 	hdev->set_diag = btintel_set_diag_combined;
++>>>>>>> 019a1caa7fd2 (Bluetooth: btintel: Refactoring setup routine for bootloader devices)
  	hdev->set_bdaddr = btintel_set_bdaddr;
  
  	return 0;
diff --cc drivers/bluetooth/btusb.c
index 26b67f0b060b,26863d8c1337..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -75,7 -59,7 +74,11 @@@ static struct usb_driver btusb_driver
  #define BTUSB_WIDEBAND_SPEECH	0x400000
  #define BTUSB_VALID_LE_STATES   0x800000
  #define BTUSB_QCA_WCN6855	0x1000000
++<<<<<<< HEAD
 +#define BTUSB_INTEL_NEWGEN	0x2000000
++=======
+ #define BTUSB_INTEL_BROKEN_INITIAL_NCMD 0x4000000
++>>>>>>> 019a1caa7fd2 (Bluetooth: btintel: Refactoring setup routine for bootloader devices)
  
  static const struct usb_device_id btusb_table[] = {
  	/* Generic Bluetooth USB device */
@@@ -376,38 -358,29 +379,44 @@@ static const struct usb_device_id black
  	{ USB_DEVICE(0x1286, 0x204e), .driver_info = BTUSB_MARVELL },
  
  	/* Intel Bluetooth devices */
- 	{ USB_DEVICE(0x8087, 0x0025), .driver_info = BTUSB_INTEL_NEW |
+ 	{ USB_DEVICE(0x8087, 0x0025), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH |
  						     BTUSB_VALID_LE_STATES },
- 	{ USB_DEVICE(0x8087, 0x0026), .driver_info = BTUSB_INTEL_NEW |
+ 	{ USB_DEVICE(0x8087, 0x0026), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH },
- 	{ USB_DEVICE(0x8087, 0x0029), .driver_info = BTUSB_INTEL_NEW |
+ 	{ USB_DEVICE(0x8087, 0x0029), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH },
- 	{ USB_DEVICE(0x8087, 0x0032), .driver_info = BTUSB_INTEL_NEWGEN |
+ 	{ USB_DEVICE(0x8087, 0x0032), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH},
++<<<<<<< HEAD
 +	{ USB_DEVICE(0x8087, 0x0033), .driver_info = BTUSB_INTEL_NEWGEN |
 +						     BTUSB_WIDEBAND_SPEECH},
 +	{ USB_DEVICE(0x8087, 0x0033), .driver_info = BTUSB_INTEL_NEWGEN |
 +						     BTUSB_WIDEBAND_SPEECH},
++=======
+ 	{ USB_DEVICE(0x8087, 0x0033), .driver_info = BTUSB_INTEL_COMBINED |
+ 						     BTUSB_WIDEBAND_SPEECH |
+ 						     BTUSB_VALID_LE_STATES },
++>>>>>>> 019a1caa7fd2 (Bluetooth: btintel: Refactoring setup routine for bootloader devices)
  	{ USB_DEVICE(0x8087, 0x07da), .driver_info = BTUSB_CSR },
 -	{ USB_DEVICE(0x8087, 0x07dc), .driver_info = BTUSB_INTEL_COMBINED |
 -						     BTUSB_INTEL_BROKEN_INITIAL_NCMD },
 +	{ USB_DEVICE(0x8087, 0x07dc), .driver_info = BTUSB_INTEL_COMBINED },
  	{ USB_DEVICE(0x8087, 0x0a2a), .driver_info = BTUSB_INTEL_COMBINED },
- 	{ USB_DEVICE(0x8087, 0x0a2b), .driver_info = BTUSB_INTEL_NEW |
+ 	{ USB_DEVICE(0x8087, 0x0a2b), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH },
  	{ USB_DEVICE(0x8087, 0x0aa7), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH },
- 	{ USB_DEVICE(0x8087, 0x0aaa), .driver_info = BTUSB_INTEL_NEW |
+ 	{ USB_DEVICE(0x8087, 0x0aaa), .driver_info = BTUSB_INTEL_COMBINED |
  						     BTUSB_WIDEBAND_SPEECH |
  						     BTUSB_VALID_LE_STATES },
 +	{ USB_DEVICE(0x0489, 0xe0cc), .driver_info = BTUSB_QCA_WCN6855 |
 +						     BTUSB_WIDEBAND_SPEECH |
 +						     BTUSB_VALID_LE_STATES },
 +	{ USB_DEVICE(0x0489, 0xe0d6), .driver_info = BTUSB_QCA_WCN6855 |
 +						     BTUSB_WIDEBAND_SPEECH |
 +						     BTUSB_VALID_LE_STATES },
 +	{ USB_DEVICE(0x0489, 0xe0e3), .driver_info = BTUSB_QCA_WCN6855 |
 +						     BTUSB_WIDEBAND_SPEECH |
 +						     BTUSB_VALID_LE_STATES },
  
  	/* Other Intel Bluetooth devices */
  	{ USB_VENDOR_AND_INTERFACE_INFO(0x8087, 0xe0, 0x01, 0x01),
@@@ -2142,616 -2102,17 +2122,630 @@@ static int btusb_send_frame_intel(struc
  	return -EILSEQ;
  }
  
++<<<<<<< HEAD
 +static int btusb_setup_intel_new_get_fw_name(struct intel_version *ver,
 +					     struct intel_boot_params *params,
 +					     char *fw_name, size_t len,
 +					     const char *suffix)
 +{
 +	switch (ver->hw_variant) {
 +	case 0x0b:	/* SfP */
 +	case 0x0c:	/* WsP */
 +		snprintf(fw_name, len, "intel/ibt-%u-%u.%s",
 +			le16_to_cpu(ver->hw_variant),
 +			le16_to_cpu(params->dev_revid),
 +			suffix);
 +		break;
 +	case 0x11:	/* JfP */
 +	case 0x12:	/* ThP */
 +	case 0x13:	/* HrP */
 +	case 0x14:	/* CcP */
 +		snprintf(fw_name, len, "intel/ibt-%u-%u-%u.%s",
 +			le16_to_cpu(ver->hw_variant),
 +			le16_to_cpu(ver->hw_revision),
 +			le16_to_cpu(ver->fw_revision),
 +			suffix);
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	return 0;
 +}
 +
 +static int btusb_download_wait(struct hci_dev *hdev, ktime_t calltime, int msec)
 +{
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	ktime_t delta, rettime;
 +	unsigned long long duration;
 +	int err;
 +
 +	set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
 +
 +	bt_dev_info(hdev, "Waiting for firmware download to complete");
 +
 +	err = wait_on_bit_timeout(&data->flags, BTUSB_DOWNLOADING,
 +				  TASK_INTERRUPTIBLE,
 +				  msecs_to_jiffies(msec));
 +	if (err == -EINTR) {
 +		bt_dev_err(hdev, "Firmware loading interrupted");
 +		return err;
 +	}
 +
 +	if (err) {
 +		bt_dev_err(hdev, "Firmware loading timeout");
 +		return -ETIMEDOUT;
 +	}
 +
 +	if (test_bit(BTUSB_FIRMWARE_FAILED, &data->flags)) {
 +		bt_dev_err(hdev, "Firmware loading failed");
 +		return -ENOEXEC;
 +	}
 +
 +	rettime = ktime_get();
 +	delta = ktime_sub(rettime, calltime);
 +	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
 +
 +	bt_dev_info(hdev, "Firmware loaded in %llu usecs", duration);
 +
 +	return 0;
 +}
 +
 +static int btusb_intel_download_firmware(struct hci_dev *hdev,
 +					 struct intel_version *ver,
 +					 struct intel_boot_params *params,
 +					 u32 *boot_param)
 +{
 +	const struct firmware *fw;
 +	char fwname[64];
 +	int err;
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	ktime_t calltime;
 +
 +	if (!ver || !params)
 +		return -EINVAL;
 +
 +	/* The firmware variant determines if the device is in bootloader
 +	 * mode or is running operational firmware. The value 0x06 identifies
 +	 * the bootloader and the value 0x23 identifies the operational
 +	 * firmware.
 +	 *
 +	 * When the operational firmware is already present, then only
 +	 * the check for valid Bluetooth device address is needed. This
 +	 * determines if the device will be added as configured or
 +	 * unconfigured controller.
 +	 *
 +	 * It is not possible to use the Secure Boot Parameters in this
 +	 * case since that command is only available in bootloader mode.
 +	 */
 +	if (ver->fw_variant == 0x23) {
 +		clear_bit(BTUSB_BOOTLOADER, &data->flags);
 +		btintel_check_bdaddr(hdev);
 +
 +		/* SfP and WsP don't seem to update the firmware version on file
 +		 * so version checking is currently possible.
 +		 */
 +		switch (ver->hw_variant) {
 +		case 0x0b:	/* SfP */
 +		case 0x0c:	/* WsP */
 +			return 0;
 +		}
 +
 +		/* Proceed to download to check if the version matches */
 +		goto download;
 +	}
 +
 +	/* Read the secure boot parameters to identify the operating
 +	 * details of the bootloader.
 +	 */
 +	err = btintel_read_boot_params(hdev, params);
 +	if (err)
 +		return err;
 +
 +	/* It is required that every single firmware fragment is acknowledged
 +	 * with a command complete event. If the boot parameters indicate
 +	 * that this bootloader does not send them, then abort the setup.
 +	 */
 +	if (params->limited_cce != 0x00) {
 +		bt_dev_err(hdev, "Unsupported Intel firmware loading method (%u)",
 +			   params->limited_cce);
 +		return -EINVAL;
 +	}
 +
 +	/* If the OTP has no valid Bluetooth device address, then there will
 +	 * also be no valid address for the operational firmware.
 +	 */
 +	if (!bacmp(&params->otp_bdaddr, BDADDR_ANY)) {
 +		bt_dev_info(hdev, "No device address configured");
 +		set_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);
 +	}
 +
 +download:
 +	/* With this Intel bootloader only the hardware variant and device
 +	 * revision information are used to select the right firmware for SfP
 +	 * and WsP.
 +	 *
 +	 * The firmware filename is ibt-<hw_variant>-<dev_revid>.sfi.
 +	 *
 +	 * Currently the supported hardware variants are:
 +	 *   11 (0x0b) for iBT3.0 (LnP/SfP)
 +	 *   12 (0x0c) for iBT3.5 (WsP)
 +	 *
 +	 * For ThP/JfP and for future SKU's, the FW name varies based on HW
 +	 * variant, HW revision and FW revision, as these are dependent on CNVi
 +	 * and RF Combination.
 +	 *
 +	 *   17 (0x11) for iBT3.5 (JfP)
 +	 *   18 (0x12) for iBT3.5 (ThP)
 +	 *
 +	 * The firmware file name for these will be
 +	 * ibt-<hw_variant>-<hw_revision>-<fw_revision>.sfi.
 +	 *
 +	 */
 +	err = btusb_setup_intel_new_get_fw_name(ver, params, fwname,
 +						sizeof(fwname), "sfi");
 +	if (err < 0) {
 +		if (!test_bit(BTUSB_BOOTLOADER, &data->flags)) {
 +			/* Firmware has already been loaded */
 +			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
 +			return 0;
 +		}
 +
 +		bt_dev_err(hdev, "Unsupported Intel firmware naming");
 +		return -EINVAL;
 +	}
 +
 +	err = firmware_request_nowarn(&fw, fwname, &hdev->dev);
 +	if (err < 0) {
 +		if (!test_bit(BTUSB_BOOTLOADER, &data->flags)) {
 +			/* Firmware has already been loaded */
 +			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
 +			return 0;
 +		}
 +
 +		bt_dev_err(hdev, "Failed to load Intel firmware file %s (%d)",
 +			   fwname, err);
 +		return err;
 +	}
 +
 +	bt_dev_info(hdev, "Found device firmware: %s", fwname);
 +
 +	if (fw->size < 644) {
 +		bt_dev_err(hdev, "Invalid size of firmware file (%zu)",
 +			   fw->size);
 +		err = -EBADF;
 +		goto done;
 +	}
 +
 +	calltime = ktime_get();
 +
 +	set_bit(BTUSB_DOWNLOADING, &data->flags);
 +
 +	/* Start firmware downloading and get boot parameter */
 +	err = btintel_download_firmware(hdev, ver, fw, boot_param);
 +	if (err < 0) {
 +		if (err == -EALREADY) {
 +			/* Firmware has already been loaded */
 +			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
 +			err = 0;
 +			goto done;
 +		}
 +
 +		/* When FW download fails, send Intel Reset to retry
 +		 * FW download.
 +		 */
 +		btintel_reset_to_bootloader(hdev);
 +		goto done;
 +	}
 +
 +	/* Before switching the device into operational mode and with that
 +	 * booting the loaded firmware, wait for the bootloader notification
 +	 * that all fragments have been successfully received.
 +	 *
 +	 * When the event processing receives the notification, then the
 +	 * BTUSB_DOWNLOADING flag will be cleared.
 +	 *
 +	 * The firmware loading should not take longer than 5 seconds
 +	 * and thus just timeout if that happens and fail the setup
 +	 * of this device.
 +	 */
 +	err = btusb_download_wait(hdev, calltime, 5000);
 +	if (err == -ETIMEDOUT)
 +		btintel_reset_to_bootloader(hdev);
 +
 +done:
 +	release_firmware(fw);
 +	return err;
 +}
 +
 +static void btusb_setup_intel_newgen_get_fw_name(const struct intel_version_tlv *ver_tlv,
 +						 char *fw_name, size_t len,
 +						 const char *suffix)
 +{
 +	/* The firmware file name for new generation controllers will be
 +	 * ibt-<cnvi_top type+cnvi_top step>-<cnvr_top type+cnvr_top step>
 +	 */
 +	snprintf(fw_name, len, "intel/ibt-%04x-%04x.%s",
 +		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvi_top),
 +					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvi_top)),
 +		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvr_top),
 +					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvr_top)),
 +		 suffix);
 +}
 +
 +static int btusb_intel_download_firmware_newgen(struct hci_dev *hdev,
 +						struct intel_version_tlv *ver,
 +						u32 *boot_param)
 +{
 +	const struct firmware *fw;
 +	char fwname[64];
 +	int err;
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	ktime_t calltime;
 +
 +	if (!ver || !boot_param)
 +		return -EINVAL;
 +
 +	/* The firmware variant determines if the device is in bootloader
 +	 * mode or is running operational firmware. The value 0x03 identifies
 +	 * the bootloader and the value 0x23 identifies the operational
 +	 * firmware.
 +	 *
 +	 * When the operational firmware is already present, then only
 +	 * the check for valid Bluetooth device address is needed. This
 +	 * determines if the device will be added as configured or
 +	 * unconfigured controller.
 +	 *
 +	 * It is not possible to use the Secure Boot Parameters in this
 +	 * case since that command is only available in bootloader mode.
 +	 */
 +	if (ver->img_type == 0x03) {
 +		clear_bit(BTUSB_BOOTLOADER, &data->flags);
 +		btintel_check_bdaddr(hdev);
 +	}
 +
 +	/* If the OTP has no valid Bluetooth device address, then there will
 +	 * also be no valid address for the operational firmware.
 +	 */
 +	if (!bacmp(&ver->otp_bd_addr, BDADDR_ANY)) {
 +		bt_dev_info(hdev, "No device address configured");
 +		set_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);
 +	}
 +
 +	btusb_setup_intel_newgen_get_fw_name(ver, fwname, sizeof(fwname), "sfi");
 +	err = firmware_request_nowarn(&fw, fwname, &hdev->dev);
 +	if (err < 0) {
 +		if (!test_bit(BTUSB_BOOTLOADER, &data->flags)) {
 +			/* Firmware has already been loaded */
 +			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
 +			return 0;
 +		}
 +
 +		bt_dev_err(hdev, "Failed to load Intel firmware file %s (%d)",
 +			   fwname, err);
 +
 +		return err;
 +	}
 +
 +	bt_dev_info(hdev, "Found device firmware: %s", fwname);
 +
 +	if (fw->size < 644) {
 +		bt_dev_err(hdev, "Invalid size of firmware file (%zu)",
 +			   fw->size);
 +		err = -EBADF;
 +		goto done;
 +	}
 +
 +	calltime = ktime_get();
 +
 +	set_bit(BTUSB_DOWNLOADING, &data->flags);
 +
 +	/* Start firmware downloading and get boot parameter */
 +	err = btintel_download_firmware_newgen(hdev, ver, fw, boot_param,
 +					       INTEL_HW_VARIANT(ver->cnvi_bt),
 +					       ver->sbe_type);
 +	if (err < 0) {
 +		if (err == -EALREADY) {
 +			/* Firmware has already been loaded */
 +			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
 +			err = 0;
 +			goto done;
 +		}
 +
 +		/* When FW download fails, send Intel Reset to retry
 +		 * FW download.
 +		 */
 +		btintel_reset_to_bootloader(hdev);
 +		goto done;
 +	}
 +
 +	/* Before switching the device into operational mode and with that
 +	 * booting the loaded firmware, wait for the bootloader notification
 +	 * that all fragments have been successfully received.
 +	 *
 +	 * When the event processing receives the notification, then the
 +	 * BTUSB_DOWNLOADING flag will be cleared.
 +	 *
 +	 * The firmware loading should not take longer than 5 seconds
 +	 * and thus just timeout if that happens and fail the setup
 +	 * of this device.
 +	 */
 +	err = btusb_download_wait(hdev, calltime, 5000);
 +	if (err == -ETIMEDOUT)
 +		btintel_reset_to_bootloader(hdev);
 +
 +done:
 +	release_firmware(fw);
 +	return err;
 +}
 +
 +static int btusb_boot_wait(struct hci_dev *hdev, ktime_t calltime, int msec)
 +{
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	ktime_t delta, rettime;
 +	unsigned long long duration;
 +	int err;
 +
 +	bt_dev_info(hdev, "Waiting for device to boot");
 +
 +	err = wait_on_bit_timeout(&data->flags, BTUSB_BOOTING,
 +				  TASK_INTERRUPTIBLE,
 +				  msecs_to_jiffies(msec));
 +	if (err == -EINTR) {
 +		bt_dev_err(hdev, "Device boot interrupted");
 +		return -EINTR;
 +	}
 +
 +	if (err) {
 +		bt_dev_err(hdev, "Device boot timeout");
 +		return -ETIMEDOUT;
 +	}
 +
 +	rettime = ktime_get();
 +	delta = ktime_sub(rettime, calltime);
 +	duration = (unsigned long long) ktime_to_ns(delta) >> 10;
 +
 +	bt_dev_info(hdev, "Device booted in %llu usecs", duration);
 +
 +	return 0;
 +}
 +
 +static int btusb_intel_boot(struct hci_dev *hdev, u32 boot_addr)
 +{
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	ktime_t calltime;
 +	int err;
 +
 +	calltime = ktime_get();
 +
 +	set_bit(BTUSB_BOOTING, &data->flags);
 +
 +	err = btintel_send_intel_reset(hdev, boot_addr);
 +	if (err) {
 +		bt_dev_err(hdev, "Intel Soft Reset failed (%d)", err);
 +		btintel_reset_to_bootloader(hdev);
 +		return err;
 +	}
 +
 +	/* The bootloader will not indicate when the device is ready. This
 +	 * is done by the operational firmware sending bootup notification.
 +	 *
 +	 * Booting into operational firmware should not take longer than
 +	 * 1 second. However if that happens, then just fail the setup
 +	 * since something went wrong.
 +	 */
 +	err = btusb_boot_wait(hdev, calltime, 1000);
 +	if (err == -ETIMEDOUT)
 +		btintel_reset_to_bootloader(hdev);
 +
 +	return err;
 +}
 +
 +static int btusb_setup_intel_new(struct hci_dev *hdev)
 +{
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	struct intel_version ver;
 +	struct intel_boot_params params;
 +	u32 boot_param;
 +	char ddcname[64];
 +	int err;
 +	struct intel_debug_features features;
 +
 +	BT_DBG("%s", hdev->name);
 +
 +	/* Set the default boot parameter to 0x0 and it is updated to
 +	 * SKU specific boot parameter after reading Intel_Write_Boot_Params
 +	 * command while downloading the firmware.
 +	 */
 +	boot_param = 0x00000000;
 +
 +	/* Read the Intel version information to determine if the device
 +	 * is in bootloader mode or if it already has operational firmware
 +	 * loaded.
 +	 */
 +	err = btintel_read_version(hdev, &ver);
 +	if (err) {
 +		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
 +		btintel_reset_to_bootloader(hdev);
 +		return err;
 +	}
 +
 +	err = btintel_version_info(hdev, &ver);
 +	if (err)
 +		return err;
 +
 +	err = btusb_intel_download_firmware(hdev, &ver, &params, &boot_param);
 +	if (err)
 +		return err;
 +
 +	/* controller is already having an operational firmware */
 +	if (ver.fw_variant == 0x23)
 +		goto finish;
 +
 +	err = btusb_intel_boot(hdev, boot_param);
 +	if (err)
 +		return err;
 +
 +	clear_bit(BTUSB_BOOTLOADER, &data->flags);
 +
 +	err = btusb_setup_intel_new_get_fw_name(&ver, &params, ddcname,
 +						sizeof(ddcname), "ddc");
 +
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Unsupported Intel firmware naming");
 +	} else {
 +		/* Once the device is running in operational mode, it needs to
 +		 * apply the device configuration (DDC) parameters.
 +		 *
 +		 * The device can work without DDC parameters, so even if it
 +		 * fails to load the file, no need to fail the setup.
 +		 */
 +		btintel_load_ddc_config(hdev, ddcname);
 +	}
 +
 +	/* Read the Intel version information after loading the FW  */
 +	err = btintel_read_version(hdev, &ver);
 +	if (err)
 +		return err;
 +
 +	btintel_version_info(hdev, &ver);
 +
 +finish:
 +	/* Set the event mask for Intel specific vendor events. This enables
 +	 * a few extra events that are useful during general operation. It
 +	 * does not enable any debugging related events.
 +	 *
 +	 * The device will function correctly without these events enabled
 +	 * and thus no need to fail the setup.
 +	 */
 +	btintel_set_event_mask(hdev, false);
 +
 +	/* Read the Intel supported features and if new exception formats
 +	 * supported, need to load the additional DDC config to enable.
 +	 */
 +	btintel_read_debug_features(hdev, &features);
 +
 +	/* Set DDC mask for available debug features */
 +	btintel_set_debug_features(hdev, &features);
 +
 +	return 0;
 +}
 +
 +static int btusb_setup_intel_newgen(struct hci_dev *hdev)
 +{
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	u32 boot_param;
 +	char ddcname[64];
 +	int err;
 +	struct intel_debug_features features;
 +	struct intel_version_tlv version;
 +
 +	bt_dev_dbg(hdev, "");
 +
 +	/* Set the default boot parameter to 0x0 and it is updated to
 +	 * SKU specific boot parameter after reading Intel_Write_Boot_Params
 +	 * command while downloading the firmware.
 +	 */
 +	boot_param = 0x00000000;
 +
 +	/* Read the Intel version information to determine if the device
 +	 * is in bootloader mode or if it already has operational firmware
 +	 * loaded.
 +	 */
 +	err = btintel_read_version_tlv(hdev, &version);
 +	if (err) {
 +		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
 +		btintel_reset_to_bootloader(hdev);
 +		return err;
 +	}
 +
 +	err = btintel_version_info_tlv(hdev, &version);
 +	if (err)
 +		return err;
 +
 +	err = btusb_intel_download_firmware_newgen(hdev, &version, &boot_param);
 +	if (err)
 +		return err;
 +
 +	/* check if controller is already having an operational firmware */
 +	if (version.img_type == 0x03)
 +		goto finish;
 +
 +	err = btusb_intel_boot(hdev, boot_param);
 +	if (err)
 +		return err;
 +
 +	clear_bit(BTUSB_BOOTLOADER, &data->flags);
 +
 +	btusb_setup_intel_newgen_get_fw_name(&version, ddcname, sizeof(ddcname),
 +					     "ddc");
 +	/* Once the device is running in operational mode, it needs to
 +	 * apply the device configuration (DDC) parameters.
 +	 *
 +	 * The device can work without DDC parameters, so even if it
 +	 * fails to load the file, no need to fail the setup.
 +	 */
 +	btintel_load_ddc_config(hdev, ddcname);
 +
 +	/* Read the Intel supported features and if new exception formats
 +	 * supported, need to load the additional DDC config to enable.
 +	 */
 +	btintel_read_debug_features(hdev, &features);
 +
 +	/* Set DDC mask for available debug features */
 +	btintel_set_debug_features(hdev, &features);
 +
 +	/* Read the Intel version information after loading the FW  */
 +	err = btintel_read_version_tlv(hdev, &version);
 +	if (err)
 +		return err;
 +
 +	btintel_version_info_tlv(hdev, &version);
 +
 +finish:
 +	/* Set the event mask for Intel specific vendor events. This enables
 +	 * a few extra events that are useful during general operation. It
 +	 * does not enable any debugging related events.
 +	 *
 +	 * The device will function correctly without these events enabled
 +	 * and thus no need to fail the setup.
 +	 */
 +	btintel_set_event_mask(hdev, false);
 +
 +	return 0;
 +}
 +
 +static int btusb_shutdown_intel_new(struct hci_dev *hdev)
 +{
 +	struct sk_buff *skb;
 +
 +	/* Send HCI Reset to the controller to stop any BT activity which
 +	 * were triggered. This will help to save power and maintain the
 +	 * sync b/w Host and controller
 +	 */
 +	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
 +	if (IS_ERR(skb)) {
 +		bt_dev_err(hdev, "HCI reset during shutdown failed");
 +		return PTR_ERR(skb);
 +	}
 +	kfree_skb(skb);
 +
 +	return 0;
 +}
 +
++=======
+ /* UHW CR mapping */
+ #define MTK_BT_MISC		0x70002510
+ #define MTK_BT_SUBSYS_RST	0x70002610
+ #define MTK_UDMA_INT_STA_BT	0x74000024
+ #define MTK_UDMA_INT_STA_BT1	0x74000308
+ #define MTK_BT_WDT_STATUS	0x740003A0
+ #define MTK_EP_RST_OPT		0x74011890
+ #define MTK_EP_RST_IN_OUT_OPT	0x00010001
+ #define MTK_BT_RST_DONE		0x00000100
+ #define MTK_BT_RESET_WAIT_MS	100
+ #define MTK_BT_RESET_NUM_TRIES	10
++>>>>>>> 019a1caa7fd2 (Bluetooth: btintel: Refactoring setup routine for bootloader devices)
  #define FIRMWARE_MT7663		"mediatek/mt7663pr2h.bin"
  #define FIRMWARE_MT7668		"mediatek/mt7668pr2h.bin"
  
@@@ -4258,16 -3721,23 +4252,25 @@@ static int btusb_probe(struct usb_inter
  	init_usb_anchor(&data->ctrl_anchor);
  	spin_lock_init(&data->rxlock);
  
++<<<<<<< HEAD
 +	if (id->driver_info & BTUSB_INTEL_NEW) {
++=======
+ 	priv_size = 0;
+ 
+ 	data->recv_event = hci_recv_frame;
+ 	data->recv_bulk = btusb_recv_bulk;
+ 
+ 	if (id->driver_info & BTUSB_INTEL_COMBINED) {
+ 		/* Allocate extra space for Intel device */
+ 		priv_size += sizeof(struct btintel_data);
+ 
+ 		/* Override the rx handlers */
++>>>>>>> 019a1caa7fd2 (Bluetooth: btintel: Refactoring setup routine for bootloader devices)
  		data->recv_event = btusb_recv_event_intel;
  		data->recv_bulk = btusb_recv_bulk_intel;
- 		set_bit(BTUSB_BOOTLOADER, &data->flags);
- 	} else {
- 		data->recv_event = hci_recv_frame;
- 		data->recv_bulk = btusb_recv_bulk;
  	}
  
 -	data->recv_acl = hci_recv_frame;
 -
 -	hdev = hci_alloc_dev_priv(priv_size);
 +	hdev = hci_alloc_dev();
  	if (!hdev)
  		return -ENOMEM;
  
@@@ -4372,19 -3824,9 +4357,6 @@@
  		set_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);
  		set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
  		set_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks);
--
- 		data->recv_event = btusb_recv_event_intel;
- 		data->recv_bulk = btusb_recv_bulk_intel;
- 		set_bit(BTUSB_BOOTLOADER, &data->flags);
 -		if (id->driver_info & BTUSB_INTEL_BROKEN_INITIAL_NCMD)
 -			btintel_set_flag(hdev, INTEL_BROKEN_INITIAL_NCMD);
  	}
  
  	if (id->driver_info & BTUSB_MARVELL)
* Unmerged path drivers/bluetooth/btintel.c
diff --git a/drivers/bluetooth/btintel.h b/drivers/bluetooth/btintel.h
index 773241e9644f..46ed9888e3bf 100644
--- a/drivers/bluetooth/btintel.h
+++ b/drivers/bluetooth/btintel.h
@@ -179,17 +179,15 @@ int btintel_read_boot_params(struct hci_dev *hdev,
 			     struct intel_boot_params *params);
 int btintel_download_firmware(struct hci_dev *dev, struct intel_version *ver,
 			      const struct firmware *fw, u32 *boot_param);
-int btintel_download_firmware_newgen(struct hci_dev *hdev,
-				     struct intel_version_tlv *ver,
-				     const struct firmware *fw,
-				     u32 *boot_param, u8 hw_variant,
-				     u8 sbe_type);
 void btintel_reset_to_bootloader(struct hci_dev *hdev);
 int btintel_read_debug_features(struct hci_dev *hdev,
 				struct intel_debug_features *features);
 int btintel_set_debug_features(struct hci_dev *hdev,
 			       const struct intel_debug_features *features);
 int btintel_configure_setup(struct hci_dev *hdev);
+void btintel_bootup(struct hci_dev *hdev, const void *ptr, unsigned int len);
+void btintel_secure_send_result(struct hci_dev *hdev,
+				const void *ptr, unsigned int len);
 #else
 
 static inline int btintel_check_bdaddr(struct hci_dev *hdev)
@@ -293,14 +291,6 @@ static inline int btintel_download_firmware(struct hci_dev *dev,
 	return -EOPNOTSUPP;
 }
 
-static inline int btintel_download_firmware_newgen(struct hci_dev *hdev,
-						   const struct firmware *fw,
-						   u32 *boot_param,
-						   u8 hw_variant, u8 sbe_type)
-{
-	return -EOPNOTSUPP;
-}
-
 static inline void btintel_reset_to_bootloader(struct hci_dev *hdev)
 {
 }
@@ -322,4 +312,13 @@ static inline int btintel_configure_setup(struct hci_dev *hdev)
 	return -ENODEV;
 }
 
+static inline void btintel_bootup(struct hci_dev *hdev,
+				  const void *ptr, unsigned int len)
+{
+}
+
+static inline void btintel_secure_send_result(struct hci_dev *hdev,
+				const void *ptr, unsigned int len)
+{
+}
 #endif
* Unmerged path drivers/bluetooth/btusb.c
