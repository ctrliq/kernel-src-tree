xfs: Make attr name schemes consistent

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Allison Henderson <allison.henderson@oracle.com>
commit 816c8e39b7ea0875640312c9ed3be0d5a68d7183
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/816c8e39.failed

This patch renames the following functions to make the nameing scheme more consistent:
xfs_attr_shortform_remove -> xfs_attr_sf_removename
xfs_attr_node_remove_name -> xfs_attr_node_removename
xfs_attr_set_fmt -> xfs_attr_sf_addname

	Suggested-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Allison Henderson <allison.henderson@oracle.com>
	Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 816c8e39b7ea0875640312c9ed3be0d5a68d7183)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
diff --cc fs/xfs/libxfs/xfs_attr.c
index bc11a1b3959d,611dc67234a6..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -63,6 -61,10 +63,13 @@@ STATIC int xfs_attr_node_hasname(xfs_da
  				 struct xfs_da_state **state);
  STATIC int xfs_attr_fillstate(xfs_da_state_t *state);
  STATIC int xfs_attr_refillstate(xfs_da_state_t *state);
++<<<<<<< HEAD
++=======
+ STATIC int xfs_attr_set_iter(struct xfs_delattr_context *dac,
+ 			     struct xfs_buf **leaf_bp);
+ STATIC int xfs_attr_node_removename(struct xfs_da_args *args,
+ 				    struct xfs_da_state *state);
++>>>>>>> 816c8e39b7ea (xfs: Make attr name schemes consistent)
  
  int
  xfs_inode_hasattr(
@@@ -241,13 -243,68 +248,19 @@@ xfs_attr_is_shortform
  		ip->i_afp->if_nextents == 0);
  }
  
 -/*
 - * Checks to see if a delayed attribute transaction should be rolled.  If so,
 - * transaction is finished or rolled as needed.
 - */
 -STATIC int
 -xfs_attr_trans_roll(
 -	struct xfs_delattr_context	*dac)
 -{
 -	struct xfs_da_args		*args = dac->da_args;
 -	int				error;
 -
 -	if (dac->flags & XFS_DAC_DEFER_FINISH) {
 -		/*
 -		 * The caller wants us to finish all the deferred ops so that we
 -		 * avoid pinning the log tail with a large number of deferred
 -		 * ops.
 -		 */
 -		dac->flags &= ~XFS_DAC_DEFER_FINISH;
 -		error = xfs_defer_finish(&args->trans);
 -	} else
 -		error = xfs_trans_roll_inode(&args->trans, args->dp);
 -
 -	return error;
 -}
 -
 -/*
 - * Set the attribute specified in @args.
 - */
 -int
 -xfs_attr_set_args(
 -	struct xfs_da_args		*args)
 -{
 -	struct xfs_buf			*leaf_bp = NULL;
 -	int				error = 0;
 -	struct xfs_delattr_context	dac = {
 -		.da_args	= args,
 -	};
 -
 -	do {
 -		error = xfs_attr_set_iter(&dac, &leaf_bp);
 -		if (error != -EAGAIN)
 -			break;
 -
 -		error = xfs_attr_trans_roll(&dac);
 -		if (error) {
 -			if (leaf_bp)
 -				xfs_trans_brelse(args->trans, leaf_bp);
 -			return error;
 -		}
 -	} while (true);
 -
 -	return error;
 -}
 -
  STATIC int
++<<<<<<< HEAD
 +xfs_attr_set_fmt(
 +	struct xfs_da_args	*args)
++=======
+ xfs_attr_sf_addname(
+ 	struct xfs_delattr_context	*dac,
+ 	struct xfs_buf			**leaf_bp)
++>>>>>>> 816c8e39b7ea (xfs: Make attr name schemes consistent)
  {
 -	struct xfs_da_args		*args = dac->da_args;
 -	struct xfs_inode		*dp = args->dp;
 -	int				error = 0;
 +	struct xfs_buf          *leaf_bp = NULL;
 +	struct xfs_inode	*dp = args->dp;
 +	int			error, error2 = 0;
  
  	/*
  	 * Try to add the attr to the attribute list in the inode.
@@@ -335,39 -409,49 +348,48 @@@ xfs_attr_set_args
  			if (error)
  				return error;
  
 -			dac->dela_state = XFS_DAS_FOUND_NBLK;
 +			goto node;
 +		} else if (error) {
 +			return error;
  		}
 -		return -EAGAIN;
 -	case XFS_DAS_FOUND_LBLK:
 +
  		/*
 -		 * If there was an out-of-line value, allocate the blocks we
 -		 * identified for its storage and copy the value.  This is done
 -		 * after we create the attribute so that we don't overflow the
 -		 * maximum size of a transaction and/or hit a deadlock.
 +		 * Commit the transaction that added the attr name so that
 +		 * later routines can manage their own transactions.
  		 */
 -
 -		/* Open coded xfs_attr_rmtval_set without trans handling */
 -		if ((dac->flags & XFS_DAC_LEAF_ADDNAME_INIT) == 0) {
 -			dac->flags |= XFS_DAC_LEAF_ADDNAME_INIT;
 -			if (args->rmtblkno > 0) {
 -				error = xfs_attr_rmtval_find_space(dac);
 -				if (error)
 -					return error;
 -			}
++<<<<<<< HEAD
 +		error = xfs_trans_roll_inode(&args->trans, dp);
 +		if (error)
 +			return error;
++=======
++		if (xfs_attr_is_shortform(dp))
++			return xfs_attr_sf_addname(dac, leaf_bp);
++		if (*leaf_bp != NULL) {
++			xfs_trans_bhold_release(args->trans, *leaf_bp);
++			*leaf_bp = NULL;
+ 		}
++>>>>>>> 816c8e39b7ea (xfs: Make attr name schemes consistent)
  
  		/*
 -		 * Repeat allocating remote blocks for the attr value until
 -		 * blkcnt drops to zero.
 +		 * If there was an out-of-line value, allocate the blocks we
 +		 * identified for its storage and copy the value.  This is done
 +		 * after we create the attribute so that we don't overflow the
 +		 * maximum size of a transaction and/or hit a deadlock.
  		 */
 -		if (dac->blkcnt > 0) {
 -			error = xfs_attr_rmtval_set_blk(dac);
 +		if (args->rmtblkno > 0) {
 +			error = xfs_attr_rmtval_set(args);
  			if (error)
  				return error;
 -			return -EAGAIN;
  		}
  
 -		error = xfs_attr_rmtval_set_value(args);
 -		if (error)
 -			return error;
 -
 -		/*
 -		 * If this is not a rename, clear the incomplete flag and we're
 -		 * done.
 -		 */
  		if (!(args->op_flags & XFS_DA_OP_RENAME)) {
 +			/*
 +			 * Added a "remote" value, just clear the incomplete
 +			 *flag.
 +			 */
  			if (args->rmtblkno > 0)
  				error = xfs_attr3_leaf_clearflag(args);
 +
  			return error;
  		}
  
@@@ -1102,13 -1223,7 +1124,17 @@@ xfs_attr_node_addname_clear_incomplete
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
 +	/*
 +	 * Remove the name and update the hashvals in the tree.
 +	 */
 +	blk = &state->path.blk[state->path.active-1];
 +	ASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);
 +	error = xfs_attr3_leaf_remove(blk->bp, args);
 +	xfs_da3_fixhashpath(state, &state->path);
++=======
+ 	error = xfs_attr_node_removename(args, state);
++>>>>>>> 816c8e39b7ea (xfs: Make attr name schemes consistent)
  
  	/*
  	 * Check to see if the tree needs to be collapsed.
@@@ -1258,54 -1380,111 +1284,160 @@@ xfs_attr_node_removename
  
  	trace_xfs_attr_node_removename(args);
  
++<<<<<<< HEAD
 +	error = xfs_attr_node_removename_setup(args, &state);
 +	if (error)
++=======
+ 	switch (dac->dela_state) {
+ 	case XFS_DAS_UNINIT:
+ 		if (!xfs_inode_hasattr(dp))
+ 			return -ENOATTR;
+ 
+ 		/*
+ 		 * Shortform or leaf formats don't require transaction rolls and
+ 		 * thus state transitions. Call the right helper and return.
+ 		 */
+ 		if (dp->i_afp->if_format == XFS_DINODE_FMT_LOCAL)
+ 			return xfs_attr_sf_removename(args);
+ 
+ 		if (xfs_attr_is_leaf(dp))
+ 			return xfs_attr_leaf_removename(args);
+ 
+ 		/*
+ 		 * Node format may require transaction rolls. Set up the
+ 		 * state context and fall into the state machine.
+ 		 */
+ 		if (!dac->da_state) {
+ 			error = xfs_attr_node_removename_setup(dac);
+ 			if (error)
+ 				return error;
+ 			state = dac->da_state;
+ 		}
+ 
+ 		/* fallthrough */
+ 	case XFS_DAS_RMTBLK:
+ 		dac->dela_state = XFS_DAS_RMTBLK;
+ 
+ 		/*
+ 		 * If there is an out-of-line value, de-allocate the blocks.
+ 		 * This is done before we remove the attribute so that we don't
+ 		 * overflow the maximum size of a transaction and/or hit a
+ 		 * deadlock.
+ 		 */
+ 		if (args->rmtblkno > 0) {
+ 			/*
+ 			 * May return -EAGAIN. Roll and repeat until all remote
+ 			 * blocks are removed.
+ 			 */
+ 			error = __xfs_attr_rmtval_remove(dac);
+ 			if (error == -EAGAIN)
+ 				return error;
+ 			else if (error)
+ 				goto out;
+ 
+ 			/*
+ 			 * Refill the state structure with buffers (the prior
+ 			 * calls released our buffers) and close out this
+ 			 * transaction before proceeding.
+ 			 */
+ 			ASSERT(args->rmtblkno == 0);
+ 			error = xfs_attr_refillstate(state);
+ 			if (error)
+ 				goto out;
+ 			dac->dela_state = XFS_DAS_RM_NAME;
+ 			dac->flags |= XFS_DAC_DEFER_FINISH;
+ 			return -EAGAIN;
+ 		}
+ 
+ 		/* fallthrough */
+ 	case XFS_DAS_RM_NAME:
+ 		/*
+ 		 * If we came here fresh from a transaction roll, reattach all
+ 		 * the buffers to the current transaction.
+ 		 */
+ 		if (dac->dela_state == XFS_DAS_RM_NAME) {
+ 			error = xfs_attr_refillstate(state);
+ 			if (error)
+ 				goto out;
+ 		}
+ 
+ 		retval = xfs_attr_node_removename(args, state);
+ 
+ 		/*
+ 		 * Check to see if the tree needs to be collapsed. If so, roll
+ 		 * the transacton and fall into the shrink state.
+ 		 */
+ 		if (retval && (state->path.active > 1)) {
+ 			error = xfs_da3_join(state);
+ 			if (error)
+ 				goto out;
+ 
+ 			dac->flags |= XFS_DAC_DEFER_FINISH;
+ 			dac->dela_state = XFS_DAS_RM_SHRINK;
+ 			return -EAGAIN;
+ 		}
+ 
+ 		/* fallthrough */
+ 	case XFS_DAS_RM_SHRINK:
+ 		/*
+ 		 * If the result is small enough, push it all into the inode.
+ 		 * This is our final state so it's safe to return a dirty
+ 		 * transaction.
+ 		 */
+ 		if (xfs_attr_is_leaf(dp))
+ 			error = xfs_attr_node_shrink(args, state);
+ 		ASSERT(error != -EAGAIN);
+ 		break;
+ 	default:
+ 		ASSERT(0);
+ 		error = -EINVAL;
++>>>>>>> 816c8e39b7ea (xfs: Make attr name schemes consistent)
  		goto out;
 +
 +	/*
 +	 * If there is an out-of-line value, de-allocate the blocks.
 +	 * This is done before we remove the attribute so that we don't
 +	 * overflow the maximum size of a transaction and/or hit a deadlock.
 +	 */
 +	if (args->rmtblkno > 0) {
 +		error = xfs_attr_rmtval_remove(args);
 +		if (error)
 +			goto out;
 +
 +		/*
 +		 * Refill the state structure with buffers, the prior calls
 +		 * released our buffers.
 +		 */
 +		error = xfs_attr_refillstate(state);
 +		if (error)
 +			goto out;
 +	}
 +	retval = xfs_attr_node_remove_name(args, state);
 +
 +	/*
 +	 * Check to see if the tree needs to be collapsed.
 +	 */
 +	if (retval && (state->path.active > 1)) {
 +		error = xfs_da3_join(state);
 +		if (error)
 +			goto out;
 +		error = xfs_defer_finish(&args->trans);
 +		if (error)
 +			goto out;
 +		/*
 +		 * Commit the Btree join operation and start a new trans.
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, dp);
 +		if (error)
 +			goto out;
  	}
 +
 +	/*
 +	 * If the result is small enough, push it all into the inode.
 +	 */
 +	if (xfs_attr_is_leaf(dp))
 +		error = xfs_attr_node_shrink(args, state);
 +
  out:
  	if (state)
  		xfs_da_state_free(state);
* Unmerged path fs/xfs/libxfs/xfs_attr.c
diff --git a/fs/xfs/libxfs/xfs_attr_leaf.c b/fs/xfs/libxfs/xfs_attr_leaf.c
index 556184b63061..ef6f0431f793 100644
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@ -773,7 +773,7 @@ xfs_attr_fork_remove(
  * Remove an attribute from the shortform attribute list structure.
  */
 int
-xfs_attr_shortform_remove(
+xfs_attr_sf_removename(
 	struct xfs_da_args		*args)
 {
 	struct xfs_attr_shortform	*sf;
diff --git a/fs/xfs/libxfs/xfs_attr_leaf.h b/fs/xfs/libxfs/xfs_attr_leaf.h
index 9b1c59f40a26..efa757f1e912 100644
--- a/fs/xfs/libxfs/xfs_attr_leaf.h
+++ b/fs/xfs/libxfs/xfs_attr_leaf.h
@@ -51,7 +51,7 @@ int	xfs_attr_shortform_lookup(struct xfs_da_args *args);
 int	xfs_attr_shortform_getvalue(struct xfs_da_args *args);
 int	xfs_attr_shortform_to_leaf(struct xfs_da_args *args,
 			struct xfs_buf **leaf_bp);
-int	xfs_attr_shortform_remove(struct xfs_da_args *args);
+int	xfs_attr_sf_removename(struct xfs_da_args *args);
 int	xfs_attr_sf_findname(struct xfs_da_args *args,
 			     struct xfs_attr_sf_entry **sfep,
 			     unsigned int *basep);
