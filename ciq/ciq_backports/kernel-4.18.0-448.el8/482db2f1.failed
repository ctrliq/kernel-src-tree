xfrm: store and rely on direction to construct offload flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 482db2f1dd211f73ad9d71e33ae15c1df6379982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/482db2f1.failed

XFRM state doesn't need anything from flags except to understand
direction, so store it separately. For future patches, such change
will allow us to reuse xfrm_dev_offload for policy offload too, which
has three possible directions instead of two.

	Reviewed-by: Raed Salem <raeds@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 482db2f1dd211f73ad9d71e33ae15c1df6379982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
#	net/xfrm/xfrm_device.c
diff --cc include/net/xfrm.h
index 4e0cf1a72c8a,45422f7be0c5..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -126,27 -124,37 +126,40 @@@ struct xfrm_state_walk 
  	u8			proto;
  	u32			seq;
  	struct xfrm_address_filter *filter;
 +
 +	RH_KABI_RESERVE(1)
  };
  
++<<<<<<< HEAD
 +struct xfrm_state_offload {
++=======
+ enum {
+ 	XFRM_DEV_OFFLOAD_IN = 1,
+ 	XFRM_DEV_OFFLOAD_OUT,
+ };
+ 
+ struct xfrm_dev_offload {
++>>>>>>> 482db2f1dd21 (xfrm: store and rely on direction to construct offload flags)
  	struct net_device	*dev;
 -	netdevice_tracker	dev_tracker;
 -	struct net_device	*real_dev;
  	unsigned long		offload_handle;
 +	unsigned int		num_exthdrs;
  	u8			flags;
 -	u8			dir : 2;
 -};
++<<<<<<< HEAD
  
 -struct xfrm_mode {
 -	u8 encap;
 -	u8 family;
 -	u8 flags;
 -};
 -
 -/* Flags for xfrm_mode. */
 -enum {
 -	XFRM_MODE_FLAG_TUNNEL = 1,
 +	RH_KABI_USE(1, struct net_device *real_dev)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
++=======
++	u8			dir : 2;
++>>>>>>> 482db2f1dd21 (xfrm: store and rely on direction to construct offload flags)
  };
  
 -enum xfrm_replay_mode {
 -	XFRM_REPLAY_MODE_LEGACY,
 -	XFRM_REPLAY_MODE_BMP,
 -	XFRM_REPLAY_MODE_ESN,
 +/* This is only defined to protect KABI in xfrm_state */
 +struct tasklet_hrtimer {
 +	struct hrtimer          timer;
 +	struct tasklet_struct   tasklet;
 +	enum hrtimer_restart    (*function)(struct hrtimer *);
  };
  
  /* Full description of state of transformer. */
diff --cc net/xfrm/xfrm_device.c
index cfa52a1abc36,c818afca9137..000000000000
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@@ -118,11 -115,12 +118,17 @@@ struct sk_buff *validate_xmit_xfrm(stru
  	if (!(features & NETIF_F_HW_ESP))
  		esp_features = features & ~(NETIF_F_SG | NETIF_F_CSUM_MASK);
  
++<<<<<<< HEAD
 +	x = skb->sp->xvec[skb->sp->len - 1];
 +	if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
++=======
+ 	sp = skb_sec_path(skb);
+ 	x = sp->xvec[sp->len - 1];
+ 	if (xo->flags & XFRM_GRO || x->xso.dir == XFRM_DEV_OFFLOAD_IN)
++>>>>>>> 482db2f1dd21 (xfrm: store and rely on direction to construct offload flags)
  		return skb;
  
 -	/* This skb was already validated on the upper/virtual dev */
 +	/* This skb was already validated on the master dev */
  	if ((x->xso.dev != dev) && (x->xso.real_dev == dev))
  		return skb;
  
@@@ -268,17 -262,23 +274,23 @@@ int xfrm_dev_state_add(struct net *net
  	}
  
  	xso->dev = dev;
 -	netdev_tracker_alloc(dev, &xso->dev_tracker, GFP_ATOMIC);
  	xso->real_dev = dev;
 -	/* Don't forward bit that is not implemented */
 -	xso->flags = xuo->flags & ~XFRM_OFFLOAD_IPV6;
 +	xso->num_exthdrs = 1;
 +	xso->flags = xuo->flags;
  
+ 	if (xuo->flags & XFRM_OFFLOAD_INBOUND)
+ 		xso->dir = XFRM_DEV_OFFLOAD_IN;
+ 	else
+ 		xso->dir = XFRM_DEV_OFFLOAD_OUT;
+ 
  	err = dev->xfrmdev_ops->xdo_dev_state_add(x);
  	if (err) {
 +		xso->num_exthdrs = 0;
  		xso->flags = 0;
  		xso->dev = NULL;
+ 		xso->dir = 0;
  		xso->real_dev = NULL;
 -		dev_put_track(dev, &xso->dev_tracker);
 +		dev_put(dev);
  
  		if (err != -EOPNOTSUPP)
  			return err;
* Unmerged path include/net/xfrm.h
* Unmerged path net/xfrm/xfrm_device.c
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index 8c2bf7218631..9ae583f9a9c3 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -845,7 +845,8 @@ static int copy_user_offload(struct xfrm_state_offload *xso, struct sk_buff *skb
 	xuo = nla_data(attr);
 	memset(xuo, 0, sizeof(*xuo));
 	xuo->ifindex = xso->dev->ifindex;
-	xuo->flags = xso->flags;
+	if (xso->dir == XFRM_DEV_OFFLOAD_IN)
+		xuo->flags = XFRM_OFFLOAD_INBOUND;
 
 	return 0;
 }
