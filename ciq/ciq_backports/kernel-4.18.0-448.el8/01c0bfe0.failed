mm: rename gfpflags_to_migratetype to gfp_migratetype for same convention

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Wei Yang <richard.weiyang@gmail.com>
commit 01c0bfe061f309b848d51619f20495ee2acd7727
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/01c0bfe0.failed

Pageblock migrate type is encoded in GFP flags, just as zone_type and
zonelist.

Currently we use gfp_zone() and gfp_zonelist() to extract related
information, it would be proper to use the same naming convention for
migrate type.

	Signed-off-by: Wei Yang <richard.weiyang@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Pankaj Gupta <pankaj.gupta.linux@gmail.com>
Link: http://lkml.kernel.org/r/20200329080823.7735-1-richard.weiyang@gmail.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 01c0bfe061f309b848d51619f20495ee2acd7727)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_owner.c
diff --cc mm/page_owner.c
index 3a4589b25a28,360461509423..000000000000
--- a/mm/page_owner.c
+++ b/mm/page_owner.c
@@@ -396,8 -358,8 +395,13 @@@ print_page_owner(char __user *buf, size
  
  	/* Print information relevant to grouping pages by mobility */
  	pageblock_mt = get_pageblock_migratetype(page);
++<<<<<<< HEAD
 +	page_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);
 +	ret += scnprintf(kbuf + ret, count - ret,
++=======
+ 	page_mt  = gfp_migratetype(page_owner->gfp_mask);
+ 	ret += snprintf(kbuf + ret, count - ret,
++>>>>>>> 01c0bfe061f3 (mm: rename gfpflags_to_migratetype to gfp_migratetype for same convention)
  			"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\n",
  			pfn,
  			migratetype_names[page_mt],
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 798e5a818c80..f31b094e7469 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -288,7 +288,7 @@ struct vm_area_struct;
 #define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)
 #define GFP_MOVABLE_SHIFT 3
 
-static inline int gfpflags_to_migratetype(const gfp_t gfp_flags)
+static inline int gfp_migratetype(const gfp_t gfp_flags)
 {
 	VM_WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
 	BUILD_BUG_ON((1UL << GFP_MOVABLE_SHIFT) != ___GFP_MOVABLE);
diff --git a/mm/compaction.c b/mm/compaction.c
index 2c3b74d50487..13c5f1345e4a 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -2255,7 +2255,7 @@ compact_zone(struct compact_control *cc, struct capture_control *capc)
 	INIT_LIST_HEAD(&cc->freepages);
 	INIT_LIST_HEAD(&cc->migratepages);
 
-	cc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);
+	cc->migratetype = gfp_migratetype(cc->gfp_mask);
 	ret = compaction_suitable(cc->zone, cc->order, cc->alloc_flags,
 							cc->highest_zoneidx);
 	/* Compaction is likely to fail */
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 1f4a77a1aaaf..0751bf4f16bf 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -4426,7 +4426,7 @@ gfp_to_alloc_flags(gfp_t gfp_mask)
 		alloc_flags |= ALLOC_KSWAPD;
 
 #ifdef CONFIG_CMA
-	if (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)
+	if (gfp_migratetype(gfp_mask) == MIGRATE_MOVABLE)
 		alloc_flags |= ALLOC_CMA;
 #endif
 	return alloc_flags;
@@ -4879,7 +4879,7 @@ static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,
 	ac->highest_zoneidx = gfp_zone(gfp_mask);
 	ac->zonelist = node_zonelist(preferred_nid, gfp_mask);
 	ac->nodemask = nodemask;
-	ac->migratetype = gfpflags_to_migratetype(gfp_mask);
+	ac->migratetype = gfp_migratetype(gfp_mask);
 
 	if (cpusets_enabled()) {
 		*alloc_mask |= __GFP_HARDWALL;
* Unmerged path mm/page_owner.c
