vfio/mdev: Remove mdev_parent_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
Rebuild_CHGLOG: - Revert "vfio/mdev: Remove mdev_parent_ops" (Jocelyn Falempe) [2115880]
Rebuild_FUZZ: 88.00%
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 6b42f491e17ce13f5ff7f2d1f49c73a0f4c47b20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6b42f491.failed

The last useful member in this struct is the supported_type_groups, move
it to the mdev_driver and delete mdev_parent_ops.

Replace it with mdev_driver as an argument to mdev_register_device()

	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20220411141403.86980-33-hch@lst.de
	Reviewed-by: Kirti Wankhede <kwankhede@nvidia.com>
	Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
(cherry picked from commit 6b42f491e17ce13f5ff7f2d1f49c73a0f4c47b20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/vfio-mediated-device.txt
#	drivers/gpu/drm/i915/gvt/kvmgt.c
#	drivers/s390/cio/vfio_ccw_ops.c
#	drivers/s390/crypto/vfio_ap_ops.c
#	drivers/vfio/mdev/mdev_core.c
#	drivers/vfio/mdev/mdev_sysfs.c
#	include/linux/mdev.h
#	samples/vfio-mdev/mbochs.c
#	samples/vfio-mdev/mdpy.c
#	samples/vfio-mdev/mtty.c
diff --cc Documentation/vfio-mediated-device.txt
index c3f69bcaf96e,784bbeb22adc..000000000000
--- a/Documentation/vfio-mediated-device.txt
+++ b/Documentation/vfio-mediated-device.txt
@@@ -104,9 -103,9 +104,15 @@@ structure to represent a mediated devic
        * @driver: device driver structure
        */
       struct mdev_driver {
++<<<<<<< HEAD:Documentation/vfio-mediated-device.txt
 +	     const char *name;
 +	     int  (*probe)  (struct device *dev);
 +	     void (*remove) (struct device *dev);
++=======
+ 	     int  (*probe)  (struct mdev_device *dev);
+ 	     void (*remove) (struct mdev_device *dev);
+ 	     struct attribute_group **supported_type_groups;
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops):Documentation/driver-api/vfio-mediated-device.rst
  	     struct device_driver    driver;
       };
  
@@@ -122,51 -120,21 +128,57 @@@ to register and unregister itself with 
  
      extern void mdev_unregister_driver(struct mdev_driver *drv);
  
++<<<<<<< HEAD:Documentation/vfio-mediated-device.txt
 +The mediated bus driver is responsible for adding mediated devices to the VFIO
 +group when devices are bound to the driver and removing mediated devices from
 +the VFIO when devices are unbound from the driver.
 +
 +
 +Physical Device Driver Interface
 +--------------------------------
 +
 +The physical device driver interface provides the mdev_parent_ops[3] structure
 +to define the APIs to manage work in the mediated core driver that is related
 +to the physical device.
 +
 +The structures in the mdev_parent_ops structure are as follows:
 +
 +* dev_attr_groups: attributes of the parent device
 +* mdev_attr_groups: attributes of the mediated device
 +* supported_config: attributes to define supported configurations
++=======
+ The mediated bus driver's probe function should create a vfio_device on top of
+ the mdev_device and connect it to an appropriate implementation of
+ vfio_device_ops.
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops):Documentation/driver-api/vfio-mediated-device.rst
 +
 +The functions in the mdev_parent_ops structure are as follows:
  
 -When a driver wants to add the GUID creation sysfs to an existing device it has
 -probe'd to then it should call::
 +* create: allocate basic resources in a driver for a mediated device
 +* remove: free resources in a driver when a mediated device is destroyed
 +
 +(Note that mdev-core provides no implicit serialization of create/remove
 +callbacks per mdev parent device, per mdev type, or any other categorization.
 +Vendor drivers are expected to be fully asynchronous in this respect or
 +provide their own internal resource protection.)
 +
 +The callbacks in the mdev_parent_ops structure are as follows:
 +
 +* open: open callback of mediated device
 +* close: close callback of mediated device
 +* ioctl: ioctl callback of mediated device
 +* read : read emulation callback
 +* write: write emulation callback
 +* mmap: mmap emulation callback
 +
 +A driver should use the mdev_parent_ops structure in the function call to
 +register itself with the mdev core driver::
  
  	extern int  mdev_register_device(struct device *dev,
- 	                                 const struct mdev_parent_ops *ops);
+ 	                                 struct mdev_driver *mdev_driver);
  
 -This will provide the 'mdev_supported_types/XX/create' files which can then be
 -used to trigger the creation of a mdev_device. The created mdev_device will be
 -attached to the specified driver.
 -
 -When the driver needs to remove itself it calls::
 +However, the mdev_parent_ops structure is not required in the function call
 +that a driver should use to unregister itself with the mdev core driver::
  
  	extern void mdev_unregister_device(struct device *dev);
  
diff --cc drivers/gpu/drm/i915/gvt/kvmgt.c
index 5bd0c74fc4ad,0787ba5c301f..000000000000
--- a/drivers/gpu/drm/i915/gvt/kvmgt.c
+++ b/drivers/gpu/drm/i915/gvt/kvmgt.c
@@@ -1764,48 -1663,72 +1764,63 @@@ static const struct attribute_group *in
  	NULL,
  };
  
 -static const struct vfio_device_ops intel_vgpu_dev_ops = {
 -	.open_device	= intel_vgpu_open_device,
 -	.close_device	= intel_vgpu_close_device,
 -	.read		= intel_vgpu_read,
 -	.write		= intel_vgpu_write,
 -	.mmap		= intel_vgpu_mmap,
 -	.ioctl		= intel_vgpu_ioctl,
 +static struct mdev_parent_ops intel_vgpu_ops = {
 +	.mdev_attr_groups       = intel_vgpu_groups,
 +	.create			= intel_vgpu_create,
 +	.remove			= intel_vgpu_remove,
 +
 +	.open			= intel_vgpu_open,
 +	.release		= intel_vgpu_release,
 +
 +	.read			= intel_vgpu_read,
 +	.write			= intel_vgpu_write,
 +	.mmap			= intel_vgpu_mmap,
 +	.ioctl			= intel_vgpu_ioctl,
  };
  
 -static int intel_vgpu_probe(struct mdev_device *mdev)
 +static int kvmgt_host_init(struct device *dev, void *gvt, const void *ops)
  {
 -	struct device *pdev = mdev_parent_dev(mdev);
 -	struct intel_gvt *gvt = kdev_to_i915(pdev)->gvt;
 -	struct intel_vgpu_type *type;
 -	struct intel_vgpu *vgpu;
  	int ret;
  
 -	type = &gvt->types[mdev_get_type_group_id(mdev)];
 -	if (!type)
 -		return -EINVAL;
 -
 -	vgpu = intel_gvt_create_vgpu(gvt, type);
 -	if (IS_ERR(vgpu)) {
 -		gvt_err("failed to create intel vgpu: %ld\n", PTR_ERR(vgpu));
 -		return PTR_ERR(vgpu);
 -	}
 +	ret = intel_gvt_init_vgpu_type_groups((struct intel_gvt *)gvt);
 +	if (ret)
 +		return ret;
  
 -	INIT_WORK(&vgpu->release_work, intel_vgpu_release_work);
 -	vfio_init_group_dev(&vgpu->vfio_device, &mdev->dev,
 -			    &intel_vgpu_dev_ops);
 +	intel_gvt_ops = ops;
 +	intel_vgpu_ops.supported_type_groups = gvt_vgpu_type_groups;
  
 -	dev_set_drvdata(&mdev->dev, vgpu);
 -	ret = vfio_register_emulated_iommu_dev(&vgpu->vfio_device);
 -	if (ret) {
 -		intel_gvt_destroy_vgpu(vgpu);
 -		return ret;
 -	}
 +	ret = mdev_register_device(dev, &intel_vgpu_ops);
 +	if (ret)
 +		intel_gvt_cleanup_vgpu_type_groups((struct intel_gvt *)gvt);
  
 -	gvt_dbg_core("intel_vgpu_create succeeded for mdev: %s\n",
 -		     dev_name(mdev_dev(mdev)));
 -	return 0;
 +	return ret;
  }
  
 -static void intel_vgpu_remove(struct mdev_device *mdev)
 +static void kvmgt_host_exit(struct device *dev, void *gvt)
  {
 -	struct intel_vgpu *vgpu = dev_get_drvdata(&mdev->dev);
 -
 -	if (WARN_ON_ONCE(vgpu->attached))
 -		return;
 -	intel_gvt_destroy_vgpu(vgpu);
 +	mdev_unregister_device(dev);
 +	intel_gvt_cleanup_vgpu_type_groups((struct intel_gvt *)gvt);
  }
  
++<<<<<<< HEAD
 +static int kvmgt_page_track_add(unsigned long handle, u64 gfn)
++=======
+ static struct mdev_driver intel_vgpu_mdev_driver = {
+ 	.driver = {
+ 		.name		= "intel_vgpu_mdev",
+ 		.owner		= THIS_MODULE,
+ 		.dev_groups	= intel_vgpu_groups,
+ 	},
+ 	.probe		= intel_vgpu_probe,
+ 	.remove		= intel_vgpu_remove,
+ 	.supported_type_groups	= gvt_vgpu_type_groups,
+ };
+ 
+ int intel_gvt_page_track_add(struct intel_vgpu *info, u64 gfn)
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  {
 -	struct kvm *kvm = info->kvm;
 +	struct kvmgt_guest_info *info;
 +	struct kvm *kvm;
  	struct kvm_memory_slot *slot;
  	int idx;
  
@@@ -2165,57 -1922,242 +2180,197 @@@ static void kvmgt_dma_unmap_guest_page(
  	entry = __gvt_cache_find_dma_addr(vgpu, dma_addr);
  	if (entry)
  		kref_put(&entry->ref, __gvt_dma_release);
 -	mutex_unlock(&vgpu->cache_lock);
 +	mutex_unlock(&vdev->cache_lock);
  }
  
 -static void init_device_info(struct intel_gvt *gvt)
 +static int kvmgt_rw_gpa(unsigned long handle, unsigned long gpa,
 +			void *buf, unsigned long len, bool write)
  {
 -	struct intel_gvt_device_info *info = &gvt->device_info;
 -	struct pci_dev *pdev = to_pci_dev(gvt->gt->i915->drm.dev);
 +	struct kvmgt_guest_info *info;
  
 -	info->max_support_vgpus = 8;
 -	info->cfg_space_size = PCI_CFG_SPACE_EXP_SIZE;
 -	info->mmio_size = 2 * 1024 * 1024;
 -	info->mmio_bar = 0;
 -	info->gtt_start_offset = 8 * 1024 * 1024;
 -	info->gtt_entry_size = 8;
 -	info->gtt_entry_size_shift = 3;
 -	info->gmadr_bytes_in_cmd = 8;
 -	info->max_surface_size = 36 * 1024 * 1024;
 -	info->msi_cap_offset = pdev->msi_cap;
 -}
 +	if (!handle_valid(handle))
 +		return -ESRCH;
  
 -static void intel_gvt_test_and_emulate_vblank(struct intel_gvt *gvt)
 -{
 -	struct intel_vgpu *vgpu;
 -	int id;
 +	info = (struct kvmgt_guest_info *)handle;
  
 -	mutex_lock(&gvt->lock);
 -	idr_for_each_entry((&(gvt)->vgpu_idr), (vgpu), (id)) {
 -		if (test_and_clear_bit(INTEL_GVT_REQUEST_EMULATE_VBLANK + id,
 -				       (void *)&gvt->service_request)) {
 -			if (vgpu->active)
 -				intel_vgpu_emulate_vblank(vgpu);
 -		}
 -	}
 -	mutex_unlock(&gvt->lock);
 +	return vfio_dma_rw(kvmgt_vdev(info->vgpu)->vfio_group,
 +			   gpa, buf, len, write);
  }
  
 -static int gvt_service_thread(void *data)
 +static int kvmgt_read_gpa(unsigned long handle, unsigned long gpa,
 +			void *buf, unsigned long len)
  {
 -	struct intel_gvt *gvt = (struct intel_gvt *)data;
 -	int ret;
 -
 -	gvt_dbg_core("service thread start\n");
 -
 -	while (!kthread_should_stop()) {
 -		ret = wait_event_interruptible(gvt->service_thread_wq,
 -				kthread_should_stop() || gvt->service_request);
 -
 -		if (kthread_should_stop())
 -			break;
 -
 -		if (WARN_ONCE(ret, "service thread is waken up by signal.\n"))
 -			continue;
 -
 -		intel_gvt_test_and_emulate_vblank(gvt);
 -
 -		if (test_bit(INTEL_GVT_REQUEST_SCHED,
 -				(void *)&gvt->service_request) ||
 -			test_bit(INTEL_GVT_REQUEST_EVENT_SCHED,
 -					(void *)&gvt->service_request)) {
 -			intel_gvt_schedule(gvt);
 -		}
 -	}
 -
 -	return 0;
 +	return kvmgt_rw_gpa(handle, gpa, buf, len, false);
  }
  
 -static void clean_service_thread(struct intel_gvt *gvt)
 +static int kvmgt_write_gpa(unsigned long handle, unsigned long gpa,
 +			void *buf, unsigned long len)
  {
 -	kthread_stop(gvt->service_thread);
 +	return kvmgt_rw_gpa(handle, gpa, buf, len, true);
  }
  
 -static int init_service_thread(struct intel_gvt *gvt)
 +static unsigned long kvmgt_virt_to_pfn(void *addr)
  {
 -	init_waitqueue_head(&gvt->service_thread_wq);
 -
 -	gvt->service_thread = kthread_run(gvt_service_thread,
 -			gvt, "gvt_service_thread");
 -	if (IS_ERR(gvt->service_thread)) {
 -		gvt_err("fail to start service thread.\n");
 -		return PTR_ERR(gvt->service_thread);
 -	}
 -	return 0;
 +	return PFN_DOWN(__pa(addr));
  }
  
 -/**
 - * intel_gvt_clean_device - clean a GVT device
 - * @i915: i915 private
 - *
 - * This function is called at the driver unloading stage, to free the
 - * resources owned by a GVT device.
 - *
 - */
 -static void intel_gvt_clean_device(struct drm_i915_private *i915)
 +static bool kvmgt_is_valid_gfn(unsigned long handle, unsigned long gfn)
  {
 -	struct intel_gvt *gvt = fetch_and_zero(&i915->gvt);
 +	struct kvmgt_guest_info *info;
 +	struct kvm *kvm;
 +	int idx;
 +	bool ret;
  
 -	if (drm_WARN_ON(&i915->drm, !gvt))
 -		return;
 +	if (!handle_valid(handle))
 +		return false;
 +
 +	info = (struct kvmgt_guest_info *)handle;
 +	kvm = info->kvm;
  
 +	idx = srcu_read_lock(&kvm->srcu);
 +	ret = kvm_is_visible_gfn(kvm, gfn);
 +	srcu_read_unlock(&kvm->srcu, idx);
 +
++<<<<<<< HEAD
++=======
+ 	mdev_unregister_device(i915->drm.dev);
+ 	intel_gvt_cleanup_vgpu_type_groups(gvt);
+ 	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
+ 	intel_gvt_clean_vgpu_types(gvt);
+ 
+ 	intel_gvt_debugfs_clean(gvt);
+ 	clean_service_thread(gvt);
+ 	intel_gvt_clean_cmd_parser(gvt);
+ 	intel_gvt_clean_sched_policy(gvt);
+ 	intel_gvt_clean_workload_scheduler(gvt);
+ 	intel_gvt_clean_gtt(gvt);
+ 	intel_gvt_free_firmware(gvt);
+ 	intel_gvt_clean_mmio_info(gvt);
+ 	idr_destroy(&gvt->vgpu_idr);
+ 
+ 	kfree(i915->gvt);
+ }
+ 
+ /**
+  * intel_gvt_init_device - initialize a GVT device
+  * @i915: drm i915 private data
+  *
+  * This function is called at the initialization stage, to initialize
+  * necessary GVT components.
+  *
+  * Returns:
+  * Zero on success, negative error code if failed.
+  *
+  */
+ static int intel_gvt_init_device(struct drm_i915_private *i915)
+ {
+ 	struct intel_gvt *gvt;
+ 	struct intel_vgpu *vgpu;
+ 	int ret;
+ 
+ 	if (drm_WARN_ON(&i915->drm, i915->gvt))
+ 		return -EEXIST;
+ 
+ 	gvt = kzalloc(sizeof(struct intel_gvt), GFP_KERNEL);
+ 	if (!gvt)
+ 		return -ENOMEM;
+ 
+ 	gvt_dbg_core("init gvt device\n");
+ 
+ 	idr_init_base(&gvt->vgpu_idr, 1);
+ 	spin_lock_init(&gvt->scheduler.mmio_context_lock);
+ 	mutex_init(&gvt->lock);
+ 	mutex_init(&gvt->sched_lock);
+ 	gvt->gt = to_gt(i915);
+ 	i915->gvt = gvt;
+ 
+ 	init_device_info(gvt);
+ 
+ 	ret = intel_gvt_setup_mmio_info(gvt);
+ 	if (ret)
+ 		goto out_clean_idr;
+ 
+ 	intel_gvt_init_engine_mmio_context(gvt);
+ 
+ 	ret = intel_gvt_load_firmware(gvt);
+ 	if (ret)
+ 		goto out_clean_mmio_info;
+ 
+ 	ret = intel_gvt_init_irq(gvt);
+ 	if (ret)
+ 		goto out_free_firmware;
+ 
+ 	ret = intel_gvt_init_gtt(gvt);
+ 	if (ret)
+ 		goto out_free_firmware;
+ 
+ 	ret = intel_gvt_init_workload_scheduler(gvt);
+ 	if (ret)
+ 		goto out_clean_gtt;
+ 
+ 	ret = intel_gvt_init_sched_policy(gvt);
+ 	if (ret)
+ 		goto out_clean_workload_scheduler;
+ 
+ 	ret = intel_gvt_init_cmd_parser(gvt);
+ 	if (ret)
+ 		goto out_clean_sched_policy;
+ 
+ 	ret = init_service_thread(gvt);
+ 	if (ret)
+ 		goto out_clean_cmd_parser;
+ 
+ 	ret = intel_gvt_init_vgpu_types(gvt);
+ 	if (ret)
+ 		goto out_clean_thread;
+ 
+ 	vgpu = intel_gvt_create_idle_vgpu(gvt);
+ 	if (IS_ERR(vgpu)) {
+ 		ret = PTR_ERR(vgpu);
+ 		gvt_err("failed to create idle vgpu\n");
+ 		goto out_clean_types;
+ 	}
+ 	gvt->idle_vgpu = vgpu;
+ 
+ 	intel_gvt_debugfs_init(gvt);
+ 
+ 	ret = intel_gvt_init_vgpu_type_groups(gvt);
+ 	if (ret)
+ 		goto out_destroy_idle_vgpu;
+ 
+ 	ret = mdev_register_device(i915->drm.dev, &intel_vgpu_mdev_driver);
+ 	if (ret)
+ 		goto out_cleanup_vgpu_type_groups;
+ 
+ 	gvt_dbg_core("gvt device initialization is done\n");
+ 	return 0;
+ 
+ out_cleanup_vgpu_type_groups:
+ 	intel_gvt_cleanup_vgpu_type_groups(gvt);
+ out_destroy_idle_vgpu:
+ 	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
+ 	intel_gvt_debugfs_clean(gvt);
+ out_clean_types:
+ 	intel_gvt_clean_vgpu_types(gvt);
+ out_clean_thread:
+ 	clean_service_thread(gvt);
+ out_clean_cmd_parser:
+ 	intel_gvt_clean_cmd_parser(gvt);
+ out_clean_sched_policy:
+ 	intel_gvt_clean_sched_policy(gvt);
+ out_clean_workload_scheduler:
+ 	intel_gvt_clean_workload_scheduler(gvt);
+ out_clean_gtt:
+ 	intel_gvt_clean_gtt(gvt);
+ out_free_firmware:
+ 	intel_gvt_free_firmware(gvt);
+ out_clean_mmio_info:
+ 	intel_gvt_clean_mmio_info(gvt);
+ out_clean_idr:
+ 	idr_destroy(&gvt->vgpu_idr);
+ 	kfree(gvt);
+ 	i915->gvt = NULL;
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  	return ret;
  }
  
diff --cc drivers/s390/cio/vfio_ccw_ops.c
index bee98d0c629f,c4d60cdbf247..000000000000
--- a/drivers/s390/cio/vfio_ccw_ops.c
+++ b/drivers/s390/cio/vfio_ccw_ops.c
@@@ -632,17 -639,24 +632,37 @@@ static void vfio_ccw_mdev_request(struc
  	}
  }
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops vfio_ccw_mdev_ops = {
 +	.owner			= THIS_MODULE,
++=======
+ static const struct vfio_device_ops vfio_ccw_dev_ops = {
+ 	.open_device = vfio_ccw_mdev_open_device,
+ 	.close_device = vfio_ccw_mdev_close_device,
+ 	.read = vfio_ccw_mdev_read,
+ 	.write = vfio_ccw_mdev_write,
+ 	.ioctl = vfio_ccw_mdev_ioctl,
+ 	.request = vfio_ccw_mdev_request,
+ };
+ 
+ struct mdev_driver vfio_ccw_mdev_driver = {
+ 	.driver = {
+ 		.name = "vfio_ccw_mdev",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 	},
+ 	.probe = vfio_ccw_mdev_probe,
+ 	.remove = vfio_ccw_mdev_remove,
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  	.supported_type_groups  = mdev_type_groups,
 +	.create			= vfio_ccw_mdev_create,
 +	.remove			= vfio_ccw_mdev_remove,
 +	.open			= vfio_ccw_mdev_open,
 +	.release		= vfio_ccw_mdev_release,
 +	.read			= vfio_ccw_mdev_read,
 +	.write			= vfio_ccw_mdev_write,
 +	.ioctl			= vfio_ccw_mdev_ioctl,
 +	.request		= vfio_ccw_mdev_request,
  };
  
  int vfio_ccw_mdev_reg(struct subchannel *sch)
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,ee0a3bf8f476..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -1362,22 -1481,42 +1362,56 @@@ static ssize_t vfio_ap_mdev_ioctl(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops vfio_ap_matrix_ops = {
 +	.owner			= THIS_MODULE,
 +	.supported_type_groups	= vfio_ap_mdev_type_groups,
 +	.mdev_attr_groups	= vfio_ap_mdev_attr_groups,
 +	.create			= vfio_ap_mdev_create,
 +	.remove			= vfio_ap_mdev_remove,
 +	.open			= vfio_ap_mdev_open,
 +	.release		= vfio_ap_mdev_release,
 +	.ioctl			= vfio_ap_mdev_ioctl,
++=======
+ static const struct vfio_device_ops vfio_ap_matrix_dev_ops = {
+ 	.open_device = vfio_ap_mdev_open_device,
+ 	.close_device = vfio_ap_mdev_close_device,
+ 	.ioctl = vfio_ap_mdev_ioctl,
+ };
+ 
+ static struct mdev_driver vfio_ap_matrix_driver = {
+ 	.driver = {
+ 		.name = "vfio_ap_mdev",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 		.dev_groups = vfio_ap_mdev_attr_groups,
+ 	},
+ 	.probe = vfio_ap_mdev_probe,
+ 	.remove = vfio_ap_mdev_remove,
+ 	.supported_type_groups = vfio_ap_mdev_type_groups,
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  };
  
  int vfio_ap_mdev_register(void)
  {
 -	int ret;
 -
  	atomic_set(&matrix_dev->available_instances, MAX_ZDEV_ENTRIES_EXT);
  
++<<<<<<< HEAD
 +	return mdev_register_device(&matrix_dev->device, &vfio_ap_matrix_ops);
++=======
+ 	ret = mdev_register_driver(&vfio_ap_matrix_driver);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = mdev_register_device(&matrix_dev->device, &vfio_ap_matrix_driver);
+ 	if (ret)
+ 		goto err_driver;
+ 	return 0;
+ 
+ err_driver:
+ 	mdev_unregister_driver(&vfio_ap_matrix_driver);
+ 	return ret;
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  }
  
  void vfio_ap_mdev_unregister(void)
diff --cc drivers/vfio/mdev/mdev_core.c
index 9911809e7d76,19a20ff420b7..000000000000
--- a/drivers/vfio/mdev/mdev_core.c
+++ b/drivers/vfio/mdev/mdev_core.c
@@@ -156,7 -122,7 +156,11 @@@ int mdev_register_device(struct device 
  	char *envp[] = { env_string, NULL };
  
  	/* check for mandatory ops */
++<<<<<<< HEAD
 +	if (!ops || !ops->create || !ops->remove || !ops->supported_type_groups)
++=======
+ 	if (!mdev_driver->supported_type_groups)
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  		return -EINVAL;
  
  	dev = get_device(dev);
@@@ -286,12 -246,8 +290,17 @@@ int mdev_device_create(struct kobject *
  {
  	int ret;
  	struct mdev_device *mdev, *tmp;
++<<<<<<< HEAD
 +	struct mdev_parent *parent;
 +	struct mdev_type *type = to_mdev_type(kobj);
 +
 +	parent = mdev_get_parent(type->parent);
 +	if (!parent)
 +		return -EINVAL;
++=======
+ 	struct mdev_parent *parent = type->parent;
+ 	struct mdev_driver *drv = parent->mdev_driver;
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  
  	mutex_lock(&mdev_list_lock);
  
@@@ -307,11 -262,18 +316,23 @@@
  	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
  	if (!mdev) {
  		mutex_unlock(&mdev_list_lock);
 -		return -ENOMEM;
 +		ret = -ENOMEM;
 +		goto mdev_fail;
  	}
  
++<<<<<<< HEAD
 +	memcpy(&mdev->uuid, &uuid, sizeof(uuid_le));
++=======
+ 	device_initialize(&mdev->dev);
+ 	mdev->dev.parent  = parent->dev;
+ 	mdev->dev.bus = &mdev_bus_type;
+ 	mdev->dev.release = mdev_device_release;
+ 	mdev->type = type;
+ 	/* Pairs with the put in mdev_device_release() */
+ 	kobject_get(&type->kobj);
+ 
+ 	guid_copy(&mdev->uuid, uuid);
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  	list_add(&mdev->next, &mdev_list);
  	mutex_unlock(&mdev_list_lock);
  
diff --cc drivers/vfio/mdev/mdev_sysfs.c
index e1196b7c9d4e,5a3873d1a275..000000000000
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@@ -93,9 -93,11 +93,14 @@@ static struct kobj_type mdev_type_ktyp
  };
  
  static struct mdev_type *add_mdev_supported_type(struct mdev_parent *parent,
 -						 unsigned int type_group_id)
 +						 struct attribute_group *group)
  {
  	struct mdev_type *type;
++<<<<<<< HEAD
++=======
+ 	struct attribute_group *group =
+ 		parent->mdev_driver->supported_type_groups[type_group_id];
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  	int ret;
  
  	if (!group->name) {
@@@ -150,8 -153,11 +155,14 @@@ attr_create_failed
  
  static void remove_mdev_supported_type(struct mdev_type *type)
  {
++<<<<<<< HEAD
++=======
+ 	struct attribute_group *group =
+ 		type->parent->mdev_driver->supported_type_groups[type->type_group_id];
+ 
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  	sysfs_remove_files(&type->kobj,
 -			   (const struct attribute **)group->attrs);
 +			   (const struct attribute **)type->group->attrs);
  	kobject_put(type->devices_kobj);
  	sysfs_remove_file(&type->kobj, &mdev_type_attr_create.attr);
  	kobject_del(&type->kobj);
@@@ -162,11 -168,10 +173,11 @@@ static int add_mdev_supported_type_grou
  {
  	int i;
  
- 	for (i = 0; parent->ops->supported_type_groups[i]; i++) {
+ 	for (i = 0; parent->mdev_driver->supported_type_groups[i]; i++) {
  		struct mdev_type *type;
  
 -		type = add_mdev_supported_type(parent, i);
 +		type = add_mdev_supported_type(parent,
 +					parent->ops->supported_type_groups[i]);
  		if (IS_ERR(type)) {
  			struct mdev_type *ltype, *tmp;
  
diff --cc include/linux/mdev.h
index 4ae0933f93f1,1f6f57a3c316..000000000000
--- a/include/linux/mdev.h
+++ b/include/linux/mdev.h
@@@ -13,94 -10,26 +13,97 @@@
  #ifndef MDEV_H
  #define MDEV_H
  
 -struct mdev_type;
 +struct mdev_device;
  
 -struct mdev_device {
 -	struct device dev;
 -	guid_t uuid;
 -	void *driver_data;
 -	struct list_head next;
 -	struct mdev_type *type;
 -	bool active;
 -};
 +/*
 + * Called by the parent device driver to set the device which represents
 + * this mdev in iommu protection scope. By default, the iommu device is
 + * NULL, that indicates using vendor defined isolation.
 + *
 + * @dev: the mediated device that iommu will isolate.
 + * @iommu_device: a pci device which represents the iommu for @dev.
 + *
 + * Return 0 for success, otherwise negative error value.
 + */
 +int mdev_set_iommu_device(struct device *dev, struct device *iommu_device);
  
 -static inline struct mdev_device *to_mdev_device(struct device *dev)
 -{
 -	return container_of(dev, struct mdev_device, dev);
 -}
 +struct device *mdev_get_iommu_device(struct device *dev);
  
 -unsigned int mdev_get_type_group_id(struct mdev_device *mdev);
 -unsigned int mtype_get_type_group_id(struct mdev_type *mtype);
 -struct device *mtype_get_parent_dev(struct mdev_type *mtype);
++<<<<<<< HEAD
 +/**
 + * struct mdev_parent_ops - Structure to be registered for each parent device to
 + * register the device to mdev module.
 + *
 + * @owner:		The module owner.
 + * @dev_attr_groups:	Attributes of the parent device.
 + * @mdev_attr_groups:	Attributes of the mediated device.
 + * @supported_type_groups: Attributes to define supported types. It is mandatory
 + *			to provide supported types.
 + * @create:		Called to allocate basic resources in parent device's
 + *			driver for a particular mediated device. It is
 + *			mandatory to provide create ops.
 + *			@kobj: kobject of type for which 'create' is called.
 + *			@mdev: mdev_device structure on of mediated device
 + *			      that is being created
 + *			Returns integer: success (0) or error (< 0)
 + * @remove:		Called to free resources in parent device's driver for a
 + *			a mediated device. It is mandatory to provide 'remove'
 + *			ops.
 + *			@mdev: mdev_device device structure which is being
 + *			       destroyed
 + *			Returns integer: success (0) or error (< 0)
 + * @open:		Open mediated device.
 + *			@mdev: mediated device.
 + *			Returns integer: success (0) or error (< 0)
 + * @release:		release mediated device
 + *			@mdev: mediated device.
 + * @read:		Read emulation callback
 + *			@mdev: mediated device structure
 + *			@buf: read buffer
 + *			@count: number of bytes to read
 + *			@ppos: address.
 + *			Retuns number on bytes read on success or error.
 + * @write:		Write emulation callback
 + *			@mdev: mediated device structure
 + *			@buf: write buffer
 + *			@count: number of bytes to be written
 + *			@ppos: address.
 + *			Retuns number on bytes written on success or error.
 + * @ioctl:		IOCTL callback
 + *			@mdev: mediated device structure
 + *			@cmd: ioctl command
 + *			@arg: arguments to ioctl
 + * @mmap:		mmap callback
 + *			@mdev: mediated device structure
 + *			@vma: vma structure
 + * @request:		request callback to release device
 + *			@mdev: mediated device structure
 + *			@count: request sequence number
 + * Parent device that support mediated device should be registered with mdev
 + * module with mdev_parent_ops structure.
 + **/
 +struct mdev_parent_ops {
 +	struct module   *owner;
 +	const struct attribute_group **dev_attr_groups;
 +	const struct attribute_group **mdev_attr_groups;
 +	struct attribute_group **supported_type_groups;
 +
 +	int     (*create)(struct kobject *kobj, struct mdev_device *mdev);
 +	int     (*remove)(struct mdev_device *mdev);
 +	int     (*open)(struct mdev_device *mdev);
 +	void    (*release)(struct mdev_device *mdev);
 +	ssize_t (*read)(struct mdev_device *mdev, char __user *buf,
 +			size_t count, loff_t *ppos);
 +	ssize_t (*write)(struct mdev_device *mdev, const char __user *buf,
 +			 size_t count, loff_t *ppos);
 +	long	(*ioctl)(struct mdev_device *mdev, unsigned int cmd,
 +			 unsigned long arg);
 +	int	(*mmap)(struct mdev_device *mdev, struct vm_area_struct *vma);
 +	void	(*request)(struct mdev_device *mdev, unsigned int count);
 +};
  
++=======
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  /* interface for exporting mdev supported type attributes */
  struct mdev_type_attribute {
  	struct attribute attr;
@@@ -121,16 -52,17 +124,24 @@@ struct mdev_type_attribute mdev_type_at
  
  /**
   * struct mdev_driver - Mediated device driver
 + * @name: driver name
   * @probe: called when new device created
   * @remove: called when device removed
+  * @supported_type_groups: Attributes to define supported types. It is mandatory
+  *			to provide supported types.
   * @driver: device driver structure
   *
   **/
  struct mdev_driver {
++<<<<<<< HEAD
 +	const char *name;
 +	int  (*probe)(struct device *dev);
 +	void (*remove)(struct device *dev);
++=======
+ 	int (*probe)(struct mdev_device *dev);
+ 	void (*remove)(struct mdev_device *dev);
+ 	struct attribute_group **supported_type_groups;
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  	struct device_driver driver;
  };
  
@@@ -143,17 -81,20 +154,22 @@@ extern const uuid_le *mdev_uuid_p(struc
  
  extern struct bus_type mdev_bus_type;
  
++<<<<<<< HEAD
 +extern int  mdev_register_device(struct device *dev,
 +				 const struct mdev_parent_ops *ops);
 +extern void mdev_unregister_device(struct device *dev);
++=======
+ int mdev_register_device(struct device *dev, struct mdev_driver *mdev_driver);
+ void mdev_unregister_device(struct device *dev);
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
 +
 +extern int  mdev_register_driver(struct mdev_driver *drv, struct module *owner);
 +extern void mdev_unregister_driver(struct mdev_driver *drv);
 +
 +extern struct device *mdev_parent_dev(struct mdev_device *mdev);
 +extern struct device *mdev_dev(struct mdev_device *mdev);
 +extern struct mdev_device *mdev_from_dev(struct device *dev);
  
 -int mdev_register_driver(struct mdev_driver *drv);
 -void mdev_unregister_driver(struct mdev_driver *drv);
 -
 -struct device *mdev_parent_dev(struct mdev_device *mdev);
 -static inline struct device *mdev_dev(struct mdev_device *mdev)
 -{
 -	return &mdev->dev;
 -}
 -static inline struct mdev_device *mdev_from_dev(struct device *dev)
 -{
 -	return dev->bus == &mdev_bus_type ? to_mdev_device(dev) : NULL;
 -}
 +extern int mdev_type_kobj_to_group_id(struct kobject *kobj);
  
  #endif /* MDEV_H */
diff --cc samples/vfio-mdev/mbochs.c
index 6be4f1ce987b,344c2901a82b..000000000000
--- a/samples/vfio-mdev/mbochs.c
+++ b/samples/vfio-mdev/mbochs.c
@@@ -1307,18 -1395,24 +1307,39 @@@ static struct attribute_group *mdev_typ
  	NULL,
  };
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops mdev_fops = {
 +	.owner			= THIS_MODULE,
 +	.mdev_attr_groups	= mdev_dev_groups,
 +	.supported_type_groups	= mdev_type_groups,
 +	.create			= mbochs_create,
 +	.remove			= mbochs_remove,
 +	.open			= mbochs_open,
 +	.release		= mbochs_close,
 +	.read			= mbochs_read,
 +	.write			= mbochs_write,
 +	.ioctl			= mbochs_ioctl,
 +	.mmap			= mbochs_mmap,
++=======
+ static const struct vfio_device_ops mbochs_dev_ops = {
+ 	.close_device = mbochs_close_device,
+ 	.read = mbochs_read,
+ 	.write = mbochs_write,
+ 	.ioctl = mbochs_ioctl,
+ 	.mmap = mbochs_mmap,
+ };
+ 
+ static struct mdev_driver mbochs_driver = {
+ 	.driver = {
+ 		.name = "mbochs",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 		.dev_groups = mdev_dev_groups,
+ 	},
+ 	.probe = mbochs_probe,
+ 	.remove	= mbochs_remove,
+ 	.supported_type_groups = mdev_type_groups,
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  };
  
  static const struct file_operations vd_fops = {
@@@ -1355,11 -1455,11 +1376,11 @@@ static int __init mbochs_dev_init(void
  
  	ret = device_register(&mbochs_dev);
  	if (ret)
 -		goto err_class;
 +		goto failed2;
  
- 	ret = mdev_register_device(&mbochs_dev, &mdev_fops);
+ 	ret = mdev_register_device(&mbochs_dev, &mbochs_driver);
  	if (ret)
 -		goto err_device;
 +		goto failed3;
  
  	return 0;
  
diff --cc samples/vfio-mdev/mdpy.c
index d774717cd906,e8c46eb2e246..000000000000
--- a/samples/vfio-mdev/mdpy.c
+++ b/samples/vfio-mdev/mdpy.c
@@@ -725,18 -707,23 +725,38 @@@ static struct attribute_group *mdev_typ
  	NULL,
  };
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops mdev_fops = {
 +	.owner			= THIS_MODULE,
 +	.mdev_attr_groups	= mdev_dev_groups,
 +	.supported_type_groups	= mdev_type_groups,
 +	.create			= mdpy_create,
 +	.remove			= mdpy_remove,
 +	.open			= mdpy_open,
 +	.release		= mdpy_close,
 +	.read			= mdpy_read,
 +	.write			= mdpy_write,
 +	.ioctl			= mdpy_ioctl,
 +	.mmap			= mdpy_mmap,
++=======
+ static const struct vfio_device_ops mdpy_dev_ops = {
+ 	.read = mdpy_read,
+ 	.write = mdpy_write,
+ 	.ioctl = mdpy_ioctl,
+ 	.mmap = mdpy_mmap,
+ };
+ 
+ static struct mdev_driver mdpy_driver = {
+ 	.driver = {
+ 		.name = "mdpy",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 		.dev_groups = mdev_dev_groups,
+ 	},
+ 	.probe = mdpy_probe,
+ 	.remove	= mdpy_remove,
+ 	.supported_type_groups = mdev_type_groups,
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  };
  
  static const struct file_operations vd_fops = {
@@@ -773,11 -764,11 +793,11 @@@ static int __init mdpy_dev_init(void
  
  	ret = device_register(&mdpy_dev);
  	if (ret)
 -		goto err_class;
 +		goto failed2;
  
- 	ret = mdev_register_device(&mdpy_dev, &mdev_fops);
+ 	ret = mdev_register_device(&mdpy_dev, &mdpy_driver);
  	if (ret)
 -		goto err_device;
 +		goto failed3;
  
  	return 0;
  
diff --cc samples/vfio-mdev/mtty.c
index 7abb79d8313d,f42a59ed2e3f..000000000000
--- a/samples/vfio-mdev/mtty.c
+++ b/samples/vfio-mdev/mtty.c
@@@ -1413,18 -1285,23 +1413,38 @@@ struct attribute_group *mdev_type_group
  	NULL,
  };
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops mdev_fops = {
 +	.owner                  = THIS_MODULE,
 +	.dev_attr_groups        = mtty_dev_groups,
 +	.mdev_attr_groups       = mdev_dev_groups,
 +	.supported_type_groups  = mdev_type_groups,
 +	.create                 = mtty_create,
 +	.remove			= mtty_remove,
 +	.open                   = mtty_open,
 +	.release                = mtty_close,
 +	.read                   = mtty_read,
 +	.write                  = mtty_write,
 +	.ioctl		        = mtty_ioctl,
++=======
+ static const struct vfio_device_ops mtty_dev_ops = {
+ 	.name = "vfio-mtty",
+ 	.read = mtty_read,
+ 	.write = mtty_write,
+ 	.ioctl = mtty_ioctl,
+ };
+ 
+ static struct mdev_driver mtty_driver = {
+ 	.driver = {
+ 		.name = "mtty",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 		.dev_groups = mdev_dev_groups,
+ 	},
+ 	.probe = mtty_probe,
+ 	.remove	= mtty_remove,
+ 	.supported_type_groups = mdev_type_groups,
++>>>>>>> 6b42f491e17c (vfio/mdev: Remove mdev_parent_ops)
  };
  
  static void mtty_device_release(struct device *dev)
@@@ -1468,28 -1350,22 +1488,28 @@@ static int __init mtty_dev_init(void
  
  	ret = device_register(&mtty_dev.dev);
  	if (ret)
 -		goto err_class;
 +		goto failed2;
  
- 	ret = mdev_register_device(&mtty_dev.dev, &mdev_fops);
+ 	ret = mdev_register_device(&mtty_dev.dev, &mtty_driver);
  	if (ret)
 -		goto err_device;
 -	return 0;
 +		goto failed3;
 +
 +	mutex_init(&mdev_list_lock);
 +	INIT_LIST_HEAD(&mdev_devices_list);
 +
 +	goto all_done;
 +
 +failed3:
  
 -err_device:
  	device_unregister(&mtty_dev.dev);
 -err_class:
 +failed2:
  	class_destroy(mtty_dev.vd_class);
 -err_driver:
 -	mdev_unregister_driver(&mtty_driver);
 -err_cdev:
 +
 +failed1:
  	cdev_del(&mtty_dev.vd_cdev);
 -	unregister_chrdev_region(mtty_dev.vd_devt, MINORMASK + 1);
 +	unregister_chrdev_region(mtty_dev.vd_devt, MINORMASK);
 +
 +all_done:
  	return ret;
  }
  
* Unmerged path Documentation/vfio-mediated-device.txt
* Unmerged path drivers/gpu/drm/i915/gvt/kvmgt.c
* Unmerged path drivers/s390/cio/vfio_ccw_ops.c
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
* Unmerged path drivers/vfio/mdev/mdev_core.c
diff --git a/drivers/vfio/mdev/mdev_private.h b/drivers/vfio/mdev/mdev_private.h
index c9f2a9819818..99540ad29431 100644
--- a/drivers/vfio/mdev/mdev_private.h
+++ b/drivers/vfio/mdev/mdev_private.h
@@ -18,7 +18,7 @@ void mdev_bus_unregister(void);
 
 struct mdev_parent {
 	struct device *dev;
-	const struct mdev_parent_ops *ops;
+	struct mdev_driver *mdev_driver;
 	struct kref ref;
 	struct list_head next;
 	struct kset *mdev_types_kset;
* Unmerged path drivers/vfio/mdev/mdev_sysfs.c
* Unmerged path include/linux/mdev.h
* Unmerged path samples/vfio-mdev/mbochs.c
* Unmerged path samples/vfio-mdev/mdpy.c
* Unmerged path samples/vfio-mdev/mtty.c
