wifi: mac80211: refactor some key code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 8cbf0c2ab6dfd61066a6ce49d9d37d3d25b2d05f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8cbf0c2a.failed

There's some pretty close code here, with the exception
of RCU dereference vs. protected dereference. Refactor
this to just return a pointer and then do the deref in
the caller later.

Change-Id: Ide5315e2792da6ac66eaf852293306a3ac71ced9
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 8cbf0c2ab6dfd61066a6ce49d9d37d3d25b2d05f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/cfg.c
diff --cc net/mac80211/cfg.c
index 06a33a8449c5,881efbfb96f6..000000000000
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@@ -545,20 -579,7 +579,24 @@@ static int ieee80211_del_key(struct wip
  	mutex_lock(&local->sta_mtx);
  	mutex_lock(&local->key_mtx);
  
++<<<<<<< HEAD
 +	if (mac_addr) {
 +		ret = -ENOENT;
 +
 +		sta = sta_info_get_bss(sdata, mac_addr);
 +		if (!sta)
 +			goto out_unlock;
 +
 +		if (pairwise)
 +			key = key_mtx_dereference(local, sta->ptk[key_idx]);
 +		else
 +			key = key_mtx_dereference(local, sta->gtk[key_idx]);
 +	} else
 +		key = key_mtx_dereference(local, sdata->keys[key_idx]);
 +
++=======
+ 	key = ieee80211_lookup_key(sdata, key_idx, pairwise, mac_addr);
++>>>>>>> 8cbf0c2ab6df (wifi: mac80211: refactor some key code)
  	if (!key) {
  		ret = -ENOENT;
  		goto out_unlock;
@@@ -595,20 -615,7 +632,24 @@@ static int ieee80211_get_key(struct wip
  
  	rcu_read_lock();
  
++<<<<<<< HEAD
 +	if (mac_addr) {
 +		sta = sta_info_get_bss(sdata, mac_addr);
 +		if (!sta)
 +			goto out;
 +
 +		if (pairwise && key_idx < NUM_DEFAULT_KEYS)
 +			key = rcu_dereference(sta->ptk[key_idx]);
 +		else if (!pairwise &&
 +			 key_idx < NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS +
 +			 NUM_DEFAULT_BEACON_KEYS)
 +			key = rcu_dereference(sta->gtk[key_idx]);
 +	} else
 +		key = rcu_dereference(sdata->keys[key_idx]);
 +
++=======
+ 	key = ieee80211_lookup_key(sdata, key_idx, pairwise, mac_addr);
++>>>>>>> 8cbf0c2ab6df (wifi: mac80211: refactor some key code)
  	if (!key)
  		goto out;
  
* Unmerged path net/mac80211/cfg.c
diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index b3fb41c0c77f..e994dcea1ce3 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -163,6 +163,8 @@ void ieee80211_reenable_keys(struct ieee80211_sub_if_data *sdata);
 
 #define key_mtx_dereference(local, ref) \
 	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))
+#define rcu_dereference_check_key_mtx(local, ref) \
+	rcu_dereference_check(ref, lockdep_is_held(&((local)->key_mtx)))
 
 void ieee80211_delayed_tailroom_dec(struct work_struct *wk);
 
