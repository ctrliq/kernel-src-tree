raw: Fix mixed declarations error in raw_icmp_error().

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Kuniyuki Iwashima <kuniyu@amazon.com>
commit 5da39e31b1b0eb62b8ed369ad9615da850239e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/5da39e31.failed

The trailing semicolon causes a compiler error, so let's remove it.

net/ipv4/raw.c: In function ‘raw_icmp_error’:
net/ipv4/raw.c:266:2: error: ISO C90 forbids mixed declarations and code [-Werror=declaration-after-statement]
  266 |  struct hlist_nulls_head *hlist;
      |  ^~~~~~

Fixes: ba44f8182ec2 ("raw: use more conventional iterators")
	Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5da39e31b1b0eb62b8ed369ad9615da850239e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/raw.c
diff --cc net/ipv4/raw.c
index 946f8761caa1,b3b255db9021..000000000000
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@@ -290,31 -262,27 +290,41 @@@ static void raw_err(struct sock *sk, st
  
  void raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)
  {
++<<<<<<< HEAD
++=======
+ 	struct net *net = dev_net(skb->dev);
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
+ 	int dif = skb->dev->ifindex;
+ 	int sdif = inet_sdif(skb);
+ 	const struct iphdr *iph;
+ 	struct sock *sk;
++>>>>>>> 5da39e31b1b0 (raw: Fix mixed declarations error in raw_icmp_error().)
  	int hash;
 +	struct sock *raw_sk;
 +	const struct iphdr *iph;
 +	struct net *net;
  
  	hash = protocol & (RAW_HTABLE_SIZE - 1);
 -	hlist = &raw_v4_hashinfo.ht[hash];
  
 -	rcu_read_lock();
 -	hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
 +	read_lock(&raw_v4_hashinfo.lock);
 +	raw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);
 +	if (raw_sk) {
 +		int dif = skb->dev->ifindex;
 +		int sdif = inet_sdif(skb);
 +
  		iph = (const struct iphdr *)skb->data;
 -		if (!raw_v4_match(net, sk, iph->protocol,
 -				  iph->saddr, iph->daddr, dif, sdif))
 -			continue;
 -		raw_err(sk, skb, info);
 +		net = dev_net(skb->dev);
 +
 +		while ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,
 +						iph->daddr, iph->saddr,
 +						dif, sdif)) != NULL) {
 +			raw_err(raw_sk, skb, info);
 +			raw_sk = sk_next(raw_sk);
 +			iph = (const struct iphdr *)skb->data;
 +		}
  	}
 -	rcu_read_unlock();
 +	read_unlock(&raw_v4_hashinfo.lock);
  }
  
  static int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)
* Unmerged path net/ipv4/raw.c
