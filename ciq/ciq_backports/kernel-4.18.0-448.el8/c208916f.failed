iommu: Express DMA strictness via the domain type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit c208916fe6c7b84e3ec95cd91853039596eeb2cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c208916f.failed

Eliminate the iommu_get_dma_strict() indirection and pipe the
information through the domain type from the beginning. Besides
the flow simplification this also has several nice side-effects:

 - Automatically implies strict mode for untrusted devices by
   virtue of their IOMMU_DOMAIN_DMA override.
 - Ensures that we only end up using flush queues for drivers
   which are aware of them and can actually benefit.
 - Allows us to handle flush queue init failure by falling back
   to strict mode instead of leaving it to possibly blow up later.

	Reviewed-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
Link: https://lore.kernel.org/r/47083d69155577f1367877b1594921948c366eb3.1628682049.git.robin.murphy@arm.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit c208916fe6c7b84e3ec95cd91853039596eeb2cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
#	include/linux/iommu.h
diff --cc drivers/iommu/iommu.c
index 68cce8e962ce,e09f0d433683..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -374,21 -355,13 +377,18 @@@ static int __init iommu_dma_setup(char 
  }
  early_param("iommu.strict", iommu_dma_setup);
  
 -void iommu_set_dma_strict(void)
 +void iommu_set_dma_strict(bool strict)
  {
++<<<<<<< HEAD
 +	if (strict || !(iommu_cmd_line & IOMMU_CMD_LINE_STRICT))
 +		iommu_dma_strict = strict;
++=======
+ 	iommu_dma_strict = true;
+ 	if (iommu_def_domain_type == IOMMU_DOMAIN_DMA_FQ)
+ 		iommu_def_domain_type = IOMMU_DOMAIN_DMA;
++>>>>>>> c208916fe6c7 (iommu: Express DMA strictness via the domain type)
  }
  
- bool iommu_get_dma_strict(struct iommu_domain *domain)
- {
- 	/* only allow lazy flushing for DMA domains */
- 	if (domain->type == IOMMU_DOMAIN_DMA)
- 		return iommu_dma_strict;
- 	return true;
- }
- EXPORT_SYMBOL_GPL(iommu_get_dma_strict);
- 
  static ssize_t iommu_group_attr_show(struct kobject *kobj,
  				     struct attribute *__attr, char *buf)
  {
diff --cc include/linux/iommu.h
index b00fb18b7995,923a8d1c5e39..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -554,8 -503,7 +554,12 @@@ int iommu_enable_nesting(struct iommu_d
  int iommu_set_pgtable_quirks(struct iommu_domain *domain,
  		unsigned long quirks);
  
++<<<<<<< HEAD
 +void iommu_set_dma_strict(bool val);
 +bool iommu_get_dma_strict(struct iommu_domain *domain);
++=======
+ void iommu_set_dma_strict(void);
++>>>>>>> c208916fe6c7 (iommu: Express DMA strictness via the domain type)
  
  extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
  			      unsigned long iova, int flags);
diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c
index 36f675968a2f..13a3128f8042 100644
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -387,13 +387,15 @@ static int iommu_dma_init_domain(struct iommu_domain *domain, dma_addr_t base,
 
 	init_iova_domain(iovad, 1UL << order, base_pfn);
 
-	if (!cookie->fq_domain && !dev_is_untrusted(dev) &&
-	    domain->ops->flush_iotlb_all && !iommu_get_dma_strict(domain)) {
+	/* If the FQ fails we can simply fall back to strict mode */
+	if (domain->type == IOMMU_DOMAIN_DMA_FQ && !cookie->fq_domain) {
 		if (init_iova_flush_queue(iovad, iommu_dma_flush_iotlb_all,
-					  iommu_dma_entry_dtor))
+					  iommu_dma_entry_dtor)) {
 			pr_warn("iova flush queue initialization failed\n");
-		else
+			domain->type = IOMMU_DOMAIN_DMA;
+		} else {
 			cookie->fq_domain = domain;
+		}
 	}
 
 	return iova_reserve_iommu_regions(dev, domain);
* Unmerged path drivers/iommu/iommu.c
* Unmerged path include/linux/iommu.h
