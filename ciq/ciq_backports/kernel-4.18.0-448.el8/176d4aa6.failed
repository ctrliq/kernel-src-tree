scsi: mpi3mr: Support SAS transport class callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit 176d4aa69c6e0f24857b9cf516f79750dea85771
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/176d4aa6.failed

Add support for the following SAS transport class callbacks:

 - get_linkerrors
 - get_enclosure_identifier
 - get_bay_identifier
 - phy_reset
 - phy_enable
 - set_phy_speed
 - smp_handler

Link: https://lore.kernel.org/r/20220804131226.16653-14-sreekanth.reddy@broadcom.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 176d4aa69c6e0f24857b9cf516f79750dea85771)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_fw.c
#	drivers/scsi/mpi3mr/mpi3mr_transport.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 8de3e5650c79,d20316787b8f..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -1084,6 -1321,61 +1084,62 @@@ int mpi3mr_pel_get_seqnum_post(struct m
  	struct mpi3mr_drv_cmd *drv_cmd);
  void mpi3mr_app_save_logdata(struct mpi3mr_ioc *mrioc, char *event_data,
  	u16 event_data_size);
 -struct mpi3mr_enclosure_node *mpi3mr_enclosure_find_by_handle(
 -	struct mpi3mr_ioc *mrioc, u16 handle);
 -extern const struct attribute_group *mpi3mr_host_groups[];
 +extern struct device_attribute *mpi3mr_host_attrs[];
  extern const struct attribute_group *mpi3mr_dev_groups[];
++<<<<<<< HEAD
++=======
+ 
+ extern struct sas_function_template mpi3mr_transport_functions;
+ extern struct scsi_transport_template *mpi3mr_transport_template;
+ 
+ int mpi3mr_cfg_get_dev_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_device_page0 *dev_pg0, u16 pg_sz, u32 form, u32 form_spec);
+ int mpi3mr_cfg_get_sas_phy_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_phy_page0 *phy_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_phy_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_phy_page1 *phy_pg1, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_exp_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_expander_page0 *exp_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_exp_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_expander_page1 *exp_pg1, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_enclosure_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_enclosure_page0 *encl_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_io_unit_pg0(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page0 *sas_io_unit_pg0, u16 pg_sz);
+ int mpi3mr_cfg_get_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
+ int mpi3mr_cfg_set_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
+ int mpi3mr_cfg_get_driver_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_driver_page1 *driver_pg1, u16 pg_sz);
+ 
+ u8 mpi3mr_is_expander_device(u16 device_info);
+ int mpi3mr_expander_add(struct mpi3mr_ioc *mrioc, u16 handle);
+ void mpi3mr_expander_remove(struct mpi3mr_ioc *mrioc, u64 sas_address,
+ 	struct mpi3mr_hba_port *hba_port);
+ struct mpi3mr_sas_node *__mpi3mr_expander_find_by_handle(struct mpi3mr_ioc
+ 	*mrioc, u16 handle);
+ struct mpi3mr_hba_port *mpi3mr_get_hba_port_by_id(struct mpi3mr_ioc *mrioc,
+ 	u8 port_id);
+ void mpi3mr_sas_host_refresh(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_sas_host_add(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_update_links(struct mpi3mr_ioc *mrioc,
+ 	u64 sas_address_parent, u16 handle, u8 phy_number, u8 link_rate,
+ 	struct mpi3mr_hba_port *hba_port);
+ void mpi3mr_remove_tgtdev_from_host(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ int mpi3mr_report_tgtdev_to_sas_transport(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ void mpi3mr_remove_tgtdev_from_sas_transport(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ struct mpi3mr_tgt_dev *__mpi3mr_get_tgtdev_by_addr_and_rphy(
+ 	struct mpi3mr_ioc *mrioc, u64 sas_address, struct sas_rphy *rphy);
+ void mpi3mr_print_device_event_notice(struct mpi3mr_ioc *mrioc,
+ 	bool device_add);
++>>>>>>> 176d4aa69c6e (scsi: mpi3mr: Support SAS transport class callbacks)
  #endif /*MPI3MR_H_INCLUDED*/
diff --cc drivers/scsi/mpi3mr/mpi3mr_fw.c
index a891e8c285f7,866ad2269b13..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@@ -3709,6 -3749,14 +3709,17 @@@ retry_init
  		mrioc->max_host_ios = min_t(int, mrioc->max_host_ios,
  		    MPI3MR_HOST_IOS_KDUMP);
  
++<<<<<<< HEAD
++=======
+ 	if (!(mrioc->facts.ioc_capabilities &
+ 	    MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED)) {
+ 		mrioc->sas_transport_enabled = 1;
+ 		mrioc->scsi_device_channel = 1;
+ 		mrioc->shost->max_channel = 1;
+ 		mrioc->shost->transportt = mpi3mr_transport_template;
+ 	}
+ 
++>>>>>>> 176d4aa69c6e (scsi: mpi3mr: Support SAS transport class callbacks)
  	mrioc->reply_sz = mrioc->facts.reply_sz;
  
  	retval = mpi3mr_check_reset_dma_mask(mrioc);
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_transport.c
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --git a/drivers/scsi/mpi3mr/mpi3mr_os.c b/drivers/scsi/mpi3mr/mpi3mr_os.c
index c851b53cb9f5..cc365d55cf8f 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@ -4644,18 +4644,33 @@ static int __init mpi3mr_init(void)
 	pr_info("Loading %s version %s\n", MPI3MR_DRIVER_NAME,
 	    MPI3MR_DRIVER_VERSION);
 
+	mpi3mr_transport_template =
+	    sas_attach_transport(&mpi3mr_transport_functions);
+	if (!mpi3mr_transport_template) {
+		pr_err("%s failed to load due to sas transport attach failure\n",
+		    MPI3MR_DRIVER_NAME);
+		return -ENODEV;
+	}
+
 	ret_val = pci_register_driver(&mpi3mr_pci_driver);
 	if (ret_val) {
 		pr_err("%s failed to load due to pci register driver failure\n",
 		    MPI3MR_DRIVER_NAME);
-		return ret_val;
+		goto err_pci_reg_fail;
 	}
 
 	ret_val = driver_create_file(&mpi3mr_pci_driver.driver,
 				     &driver_attr_event_counter);
 	if (ret_val)
-		pci_unregister_driver(&mpi3mr_pci_driver);
+		goto err_event_counter;
+
+	return ret_val;
+
+err_event_counter:
+	pci_unregister_driver(&mpi3mr_pci_driver);
 
+err_pci_reg_fail:
+	sas_release_transport(mpi3mr_transport_template);
 	return ret_val;
 }
 
@@ -4672,6 +4687,7 @@ static void __exit mpi3mr_exit(void)
 	driver_remove_file(&mpi3mr_pci_driver.driver,
 			   &driver_attr_event_counter);
 	pci_unregister_driver(&mpi3mr_pci_driver);
+	sas_release_transport(mpi3mr_transport_template);
 }
 
 module_init(mpi3mr_init);
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_transport.c
