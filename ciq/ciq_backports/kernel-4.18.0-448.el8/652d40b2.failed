s390/pci: fix DMA cleanup on hard deconfigure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 652d40b2f8bec14957295f999e3d329c3b53390f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/652d40b2.failed

In commit dee60c0dbc83 ("s390/pci: add zpci_event_hard_deconfigured()")
we added a zdev_enabled() check to what was previously an uncoditional
call to zpci_disable_device(). There are two problems with that. Firstly
zpci_had_deconfigured() is only called on event 0x0304 for which the
device is always already disabled by the platform so it is always false.
Secondly zpci_disable_device() not only disables the device but also
calls zpci_dma_exit_device() which is thus not called and we leak the
DMA tables.

Fix this by calling zpci_disable_device() unconditionally to perform
Linux side cleanup including the freeing of DMA tables.

Fixes: dee60c0dbc83 ("s390/pci: add zpci_event_hard_deconfigured()")
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Acked-by: Pierre Morel <pmorel@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 652d40b2f8bec14957295f999e3d329c3b53390f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/pci/pci_event.c
index 4b2bb5dfb29a,ae3054d85491..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -73,6 -74,26 +74,29 @@@ void zpci_event_error(void *data
  		__zpci_event_error(data);
  }
  
++<<<<<<< HEAD
++=======
+ static void zpci_event_hard_deconfigured(struct zpci_dev *zdev, u32 fh)
+ {
+ 	enum zpci_state state;
+ 
+ 	zdev->fh = fh;
+ 	/* Give the driver a hint that the function is
+ 	 * already unusable.
+ 	 */
+ 	zpci_bus_remove_device(zdev, true);
+ 	/* Even though the device is already gone we still
+ 	 * need to free zPCI resources as part of the disable.
+ 	 */
+ 	zpci_disable_device(zdev);
+ 	zdev->state = ZPCI_FN_STATE_STANDBY;
+ 	if (!clp_get_state(zdev->fid, &state) &&
+ 	    state == ZPCI_FN_STATE_RESERVED) {
+ 		zpci_zdev_put(zdev);
+ 	}
+ }
+ 
++>>>>>>> 652d40b2f8be (s390/pci: fix DMA cleanup on hard deconfigure)
  static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
  {
  	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
* Unmerged path arch/s390/pci/pci_event.c
