s390/pci: ioremap() align with generic code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit a999eb96fdd4da488ac3085c40e20d61de26f6af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a999eb96.failed

Let's use the same signature and parameter names as in the generic
ioremap() definition making the physical address' type explicit.

Add a check against address wrap around as in the generic
lib/ioremap.c:ioremap_prot() code.

Finally use free_vm_area() instead of vunmap() as in the generic code.
Besides being clearer free_vm_area() can also skip a few additional
checks compared with vunmap().

	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit a999eb96fdd4da488ac3085c40e20d61de26f6af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/io.h
diff --cc arch/s390/include/asm/io.h
index ca421614722f,da014e4f8113..000000000000
--- a/arch/s390/include/asm/io.h
+++ b/arch/s390/include/asm/io.h
@@@ -26,11 -26,7 +26,15 @@@ void unxlate_dev_mem_ptr(phys_addr_t ph
  
  #define IO_SPACE_LIMIT 0
  
++<<<<<<< HEAD
 +#define ioremap_nocache(addr, size)	ioremap(addr, size)
 +#define ioremap_wc			ioremap_nocache
 +#define ioremap_wt			ioremap_nocache
 +
 +void __iomem *ioremap(unsigned long offset, unsigned long size);
++=======
+ void __iomem *ioremap(phys_addr_t addr, size_t size);
++>>>>>>> a999eb96fdd4 (s390/pci: ioremap() align with generic code)
  void iounmap(volatile void __iomem *addr);
  
  static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
* Unmerged path arch/s390/include/asm/io.h
diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c
index 0438bf359bdb..fa08bf043315 100644
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -225,28 +225,29 @@ void __iowrite64_copy(void __iomem *to, const void *from, size_t count)
        zpci_memcpy_toio(to, from, count);
 }
 
-void __iomem *ioremap(unsigned long ioaddr, unsigned long size)
+void __iomem *ioremap(phys_addr_t addr, size_t size)
 {
+	unsigned long offset, vaddr;
 	struct vm_struct *area;
-	unsigned long offset;
+	phys_addr_t last_addr;
 
-	if (!size)
+	last_addr = addr + size - 1;
+	if (!size || last_addr < addr)
 		return NULL;
 
 	if (!static_branch_unlikely(&have_mio))
-		return (void __iomem *) ioaddr;
+		return (void __iomem *) addr;
 
-	offset = ioaddr & ~PAGE_MASK;
-	ioaddr &= PAGE_MASK;
+	offset = addr & ~PAGE_MASK;
+	addr &= PAGE_MASK;
 	size = PAGE_ALIGN(size + offset);
 	area = get_vm_area(size, VM_IOREMAP);
 	if (!area)
 		return NULL;
 
-	if (ioremap_page_range((unsigned long) area->addr,
-			       (unsigned long) area->addr + size,
-			       ioaddr, PAGE_KERNEL)) {
-		vunmap(area->addr);
+	vaddr = (unsigned long) area->addr;
+	if (ioremap_page_range(vaddr, vaddr + size, addr, PAGE_KERNEL)) {
+		free_vm_area(area);
 		return NULL;
 	}
 	return (void __iomem *) ((unsigned long) area->addr + offset);
