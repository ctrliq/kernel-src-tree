mm/vmscan: increase the timeout if page reclaim is not making progress

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Mel Gorman <mgorman@techsingularity.net>
commit a19594ca4a8bfb5980de7bcc6ae6cbce8ff9680e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a19594ca.failed

Tracing of the stutterp workload showed the following delays

      1 usect_delayed=124000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=128000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=176000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=536000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=544000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=556000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=624000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=716000 reason=VMSCAN_THROTTLE_NOPROGRESS
      1 usect_delayed=772000 reason=VMSCAN_THROTTLE_NOPROGRESS
      2 usect_delayed=512000 reason=VMSCAN_THROTTLE_NOPROGRESS
     16 usect_delayed=120000 reason=VMSCAN_THROTTLE_NOPROGRESS
     53 usect_delayed=116000 reason=VMSCAN_THROTTLE_NOPROGRESS
    116 usect_delayed=112000 reason=VMSCAN_THROTTLE_NOPROGRESS
   5907 usect_delayed=108000 reason=VMSCAN_THROTTLE_NOPROGRESS
  71741 usect_delayed=104000 reason=VMSCAN_THROTTLE_NOPROGRESS

All the throttling hit the full timeout and then there was wakeup delays
meaning that the wakeups are premature as no other reclaimer such as
kswapd has made progress.  This patch increases the maximum timeout.

Link: https://lkml.kernel.org/r/20211022144651.19914-8-mgorman@techsingularity.net
	Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Andreas Dilger <adilger.kernel@dilger.ca>
	Cc: "Darrick J . Wong" <djwong@kernel.org>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: NeilBrown <neilb@suse.de>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: "Theodore Ts'o" <tytso@mit.edu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a19594ca4a8bfb5980de7bcc6ae6cbce8ff9680e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmscan.c
diff --cc mm/vmscan.c
index c09c607fa724,9c125f793bf5..000000000000
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@@ -981,6 -1006,91 +981,94 @@@ static void handle_write_error(struct a
  	unlock_page(page);
  }
  
++<<<<<<< HEAD
++=======
+ void reclaim_throttle(pg_data_t *pgdat, enum vmscan_throttle_state reason)
+ {
+ 	wait_queue_head_t *wqh = &pgdat->reclaim_wait[reason];
+ 	long timeout, ret;
+ 	DEFINE_WAIT(wait);
+ 
+ 	/*
+ 	 * Do not throttle IO workers, kthreads other than kswapd or
+ 	 * workqueues. They may be required for reclaim to make
+ 	 * forward progress (e.g. journalling workqueues or kthreads).
+ 	 */
+ 	if (!current_is_kswapd() &&
+ 	    current->flags & (PF_IO_WORKER|PF_KTHREAD))
+ 		return;
+ 
+ 	/*
+ 	 * These figures are pulled out of thin air.
+ 	 * VMSCAN_THROTTLE_ISOLATED is a transient condition based on too many
+ 	 * parallel reclaimers which is a short-lived event so the timeout is
+ 	 * short. Failing to make progress or waiting on writeback are
+ 	 * potentially long-lived events so use a longer timeout. This is shaky
+ 	 * logic as a failure to make progress could be due to anything from
+ 	 * writeback to a slow device to excessive references pages at the tail
+ 	 * of the inactive LRU.
+ 	 */
+ 	switch(reason) {
+ 	case VMSCAN_THROTTLE_WRITEBACK:
+ 		timeout = HZ/10;
+ 
+ 		if (atomic_inc_return(&pgdat->nr_writeback_throttled) == 1) {
+ 			WRITE_ONCE(pgdat->nr_reclaim_start,
+ 				node_page_state(pgdat, NR_THROTTLED_WRITTEN));
+ 		}
+ 
+ 		break;
+ 	case VMSCAN_THROTTLE_NOPROGRESS:
+ 		timeout = HZ/2;
+ 		break;
+ 	case VMSCAN_THROTTLE_ISOLATED:
+ 		timeout = HZ/50;
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		timeout = HZ;
+ 		break;
+ 	}
+ 
+ 	prepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);
+ 	ret = schedule_timeout(timeout);
+ 	finish_wait(wqh, &wait);
+ 
+ 	if (reason == VMSCAN_THROTTLE_WRITEBACK)
+ 		atomic_dec(&pgdat->nr_writeback_throttled);
+ 
+ 	trace_mm_vmscan_throttled(pgdat->node_id, jiffies_to_usecs(timeout),
+ 				jiffies_to_usecs(timeout - ret),
+ 				reason);
+ }
+ 
+ /*
+  * Account for pages written if tasks are throttled waiting on dirty
+  * pages to clean. If enough pages have been cleaned since throttling
+  * started then wakeup the throttled tasks.
+  */
+ void __acct_reclaim_writeback(pg_data_t *pgdat, struct page *page,
+ 							int nr_throttled)
+ {
+ 	unsigned long nr_written;
+ 
+ 	inc_node_page_state(page, NR_THROTTLED_WRITTEN);
+ 
+ 	/*
+ 	 * This is an inaccurate read as the per-cpu deltas may not
+ 	 * be synchronised. However, given that the system is
+ 	 * writeback throttled, it is not worth taking the penalty
+ 	 * of getting an accurate count. At worst, the throttle
+ 	 * timeout guarantees forward progress.
+ 	 */
+ 	nr_written = node_page_state(pgdat, NR_THROTTLED_WRITTEN) -
+ 		READ_ONCE(pgdat->nr_reclaim_start);
+ 
+ 	if (nr_written > SWAP_CLUSTER_MAX * nr_throttled)
+ 		wake_up(&pgdat->reclaim_wait[VMSCAN_THROTTLE_WRITEBACK]);
+ }
+ 
++>>>>>>> a19594ca4a8b (mm/vmscan: increase the timeout if page reclaim is not making progress)
  /* possible outcome of pageout() */
  typedef enum {
  	/* failed to write page out, page is locked */
* Unmerged path mm/vmscan.c
