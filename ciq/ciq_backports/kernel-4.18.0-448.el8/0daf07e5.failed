raw: convert raw sockets to RCU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 0daf07e527095e64ee8927ce297ab626643e9f51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0daf07e5.failed

Using rwlock in networking code is extremely risky.
writers can starve if enough readers are constantly
grabing the rwlock.

I thought rwlock were at fault and sent this patch:

https://lkml.org/lkml/2022/6/17/272

But Peter and Linus essentially told me rwlock had to be unfair.

We need to get rid of rwlock in networking code.

Without this fix, following script triggers soft lockups:

for i in {1..48}
do
 ping -f -n -q 127.0.0.1 &
 sleep 0.1
done

Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0daf07e527095e64ee8927ce297ab626643e9f51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/raw.c
#	net/ipv4/raw_diag.c
#	net/ipv6/af_inet6.c
#	net/ipv6/raw.c
diff --cc net/ipv4/raw.c
index 946f8761caa1,d28bf0b901a2..000000000000
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@@ -97,14 -91,15 +95,20 @@@ EXPORT_SYMBOL_GPL(raw_v4_hashinfo)
  int raw_hash_sk(struct sock *sk)
  {
  	struct raw_hashinfo *h = sk->sk_prot->h.raw_hash;
- 	struct hlist_head *head;
+ 	struct hlist_nulls_head *hlist;
  
- 	head = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];
+ 	hlist = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];
  
  	write_lock_bh(&h->lock);
++<<<<<<< HEAD
 +	sk_add_node(sk, head);
++=======
+ 	hlist_nulls_add_head_rcu(&sk->sk_nulls_node, hlist);
+ 	sock_set_flag(sk, SOCK_RCU_FREE);
+ 	write_unlock_bh(&h->lock);
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
 +	write_unlock_bh(&h->lock);
  
  	return 0;
  }
@@@ -173,23 -162,20 +177,40 @@@ static int icmp_filter(const struct soc
   */
  static int raw_v4_input(struct sk_buff *skb, const struct iphdr *iph, int hash)
  {
++<<<<<<< HEAD
 +	int sdif = inet_sdif(skb);
 +	int dif = inet_iif(skb);
 +	struct sock *sk;
 +	struct hlist_head *head;
++=======
+ 	struct net *net = dev_net(skb->dev);
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
+ 	int sdif = inet_sdif(skb);
+ 	int dif = inet_iif(skb);
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	int delivered = 0;
 -	struct sock *sk;
 +	struct net *net;
 +
++<<<<<<< HEAD
 +	read_lock(&raw_v4_hashinfo.lock);
 +	head = &raw_v4_hashinfo.ht[hash];
 +	if (hlist_empty(head))
 +		goto out;
  
 +	net = dev_net(skb->dev);
 +	sk = __raw_v4_lookup(net, __sk_head(head), iph->protocol,
 +			     iph->saddr, iph->daddr, dif, sdif);
 +
 +	while (sk) {
++=======
+ 	hlist = &raw_v4_hashinfo.ht[hash];
+ 	rcu_read_lock();
+ 	hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
+ 		if (!raw_v4_match(net, sk, iph->protocol,
+ 				  iph->saddr, iph->daddr, dif, sdif))
+ 			continue;
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  		delivered = 1;
  		if ((iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &&
  		    ip_mc_sf_allow(sk, iph->daddr, iph->saddr,
@@@ -200,12 -186,8 +221,16 @@@
  			if (clone)
  				raw_rcv(sk, clone);
  		}
 +		sk = __raw_v4_lookup(net, sk_next(sk), iph->protocol,
 +				     iph->saddr, iph->daddr,
 +				     dif, sdif);
  	}
++<<<<<<< HEAD
 +out:
 +	read_unlock(&raw_v4_hashinfo.lock);
++=======
+ 	rcu_read_unlock();
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	return delivered;
  }
  
@@@ -290,31 -262,27 +315,48 @@@ static void raw_err(struct sock *sk, st
  
  void raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)
  {
++<<<<<<< HEAD
++=======
+ 	struct net *net = dev_net(skb->dev);;
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
+ 	int dif = skb->dev->ifindex;
+ 	int sdif = inet_sdif(skb);
+ 	const struct iphdr *iph;
+ 	struct sock *sk;
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	int hash;
 +	struct sock *raw_sk;
 +	const struct iphdr *iph;
 +	struct net *net;
  
  	hash = protocol & (RAW_HTABLE_SIZE - 1);
++<<<<<<< HEAD
 +
 +	read_lock(&raw_v4_hashinfo.lock);
 +	raw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);
 +	if (raw_sk) {
 +		int dif = skb->dev->ifindex;
 +		int sdif = inet_sdif(skb);
 +
++=======
+ 	hlist = &raw_v4_hashinfo.ht[hash];
+ 
+ 	rcu_read_lock();
+ 	hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  		iph = (const struct iphdr *)skb->data;
 -		if (!raw_v4_match(net, sk, iph->protocol,
 -				  iph->saddr, iph->daddr, dif, sdif))
 -			continue;
 -		raw_err(sk, skb, info);
 +		net = dev_net(skb->dev);
 +
 +		while ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,
 +						iph->daddr, iph->saddr,
 +						dif, sdif)) != NULL) {
 +			raw_err(raw_sk, skb, info);
 +			raw_sk = sk_next(raw_sk);
 +			iph = (const struct iphdr *)skb->data;
 +		}
  	}
- 	read_unlock(&raw_v4_hashinfo.lock);
+ 	rcu_read_unlock();
  }
  
  static int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)
@@@ -996,26 -943,27 +1038,36 @@@ struct proto raw_prot = 
  };
  
  #ifdef CONFIG_PROC_FS
- static struct sock *raw_get_first(struct seq_file *seq)
+ static struct sock *raw_get_first(struct seq_file *seq, int bucket)
  {
++<<<<<<< HEAD
 +	struct sock *sk;
 +	struct raw_hashinfo *h = PDE_DATA(file_inode(seq->file));
++=======
+ 	struct raw_hashinfo *h = pde_data(file_inode(seq->file));
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	struct raw_iter_state *state = raw_seq_private(seq);
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
+ 	struct sock *sk;
  
- 	for (state->bucket = 0; state->bucket < RAW_HTABLE_SIZE;
+ 	for (state->bucket = bucket; state->bucket < RAW_HTABLE_SIZE;
  			++state->bucket) {
- 		sk_for_each(sk, &h->ht[state->bucket])
+ 		hlist = &h->ht[state->bucket];
+ 		hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
  			if (sock_net(sk) == seq_file_net(seq))
- 				goto found;
+ 				return sk;
+ 		}
  	}
- 	sk = NULL;
- found:
- 	return sk;
+ 	return NULL;
  }
  
  static struct sock *raw_get_next(struct seq_file *seq, struct sock *sk)
  {
++<<<<<<< HEAD
 +	struct raw_hashinfo *h = PDE_DATA(file_inode(seq->file));
++=======
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	struct raw_iter_state *state = raw_seq_private(seq);
  
  	do {
@@@ -1042,11 -986,9 +1090,15 @@@ static struct sock *raw_get_idx(struct 
  }
  
  void *raw_seq_start(struct seq_file *seq, loff_t *pos)
- 	__acquires(&h->lock)
+ 	__acquires(RCU)
  {
++<<<<<<< HEAD
 +	struct raw_hashinfo *h = PDE_DATA(file_inode(seq->file));
 +
 +	read_lock(&h->lock);
++=======
+ 	rcu_read_lock();
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	return *pos ? raw_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
  }
  EXPORT_SYMBOL_GPL(raw_seq_start);
@@@ -1065,11 -1007,9 +1117,15 @@@ void *raw_seq_next(struct seq_file *seq
  EXPORT_SYMBOL_GPL(raw_seq_next);
  
  void raw_seq_stop(struct seq_file *seq, void *v)
- 	__releases(&h->lock)
+ 	__releases(RCU)
  {
++<<<<<<< HEAD
 +	struct raw_hashinfo *h = PDE_DATA(file_inode(seq->file));
 +
 +	read_unlock(&h->lock);
++=======
+ 	rcu_read_unlock();
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  }
  EXPORT_SYMBOL_GPL(raw_seq_stop);
  
diff --cc net/ipv4/raw_diag.c
index 5f3757d25183,5f208e840d85..000000000000
--- a/net/ipv4/raw_diag.c
+++ b/net/ipv4/raw_diag.c
@@@ -57,33 -57,34 +57,43 @@@ static struct sock *raw_lookup(struct n
  static struct sock *raw_sock_get(struct net *net, const struct inet_diag_req_v2 *r)
  {
  	struct raw_hashinfo *hashinfo = raw_get_hashinfo(r);
++<<<<<<< HEAD
 +	struct sock *sk = NULL, *s;
++=======
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
+ 	struct sock *sk;
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	int slot;
  
  	if (IS_ERR(hashinfo))
  		return ERR_CAST(hashinfo);
  
- 	read_lock(&hashinfo->lock);
+ 	rcu_read_lock();
  	for (slot = 0; slot < RAW_HTABLE_SIZE; slot++) {
++<<<<<<< HEAD
 +		sk_for_each(s, &hashinfo->ht[slot]) {
 +			sk = raw_lookup(net, s, r);
 +			if (sk) {
++=======
+ 		hlist = &hashinfo->ht[slot];
+ 		hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
+ 			if (raw_lookup(net, sk, r)) {
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  				/*
  				 * Grab it and keep until we fill
- 				 * diag meaage to be reported, so
+ 				 * diag message to be reported, so
  				 * caller should call sock_put then.
- 				 * We can do that because we're keeping
- 				 * hashinfo->lock here.
  				 */
- 				sock_hold(sk);
- 				goto out_unlock;
+ 				if (refcount_inc_not_zero(&sk->sk_refcnt))
+ 					goto out_unlock;
  			}
  		}
  	}
 -	sk = ERR_PTR(-ENOENT);
  out_unlock:
- 	read_unlock(&hashinfo->lock);
+ 	rcu_read_unlock();
  
 -	return sk;
 +	return sk ? sk : ERR_PTR(-ENOENT);
  }
  
  static int raw_diag_dump_one(struct netlink_callback *cb,
diff --cc net/ipv6/af_inet6.c
index f18962aceaec,658823e91eca..000000000000
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@@ -63,7 -59,11 +63,12 @@@
  #endif
  #include <net/calipso.h>
  #include <net/seg6.h>
 -#include <net/rpl.h>
 -#include <net/compat.h>
  #include <net/xfrm.h>
++<<<<<<< HEAD
++=======
+ #include <net/ioam6.h>
+ #include <net/rawv6.h>
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  
  #include <linux/uaccess.h>
  #include <linux/mroute6.h>
diff --cc net/ipv6/raw.c
index 1d4284c2d260,f6119998700e..000000000000
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@@ -65,47 -61,30 +65,45 @@@
  
  #define	ICMPV6_HDRLEN	4	/* ICMPv6 header, RFC 4443 Section 2.1 */
  
- struct raw_hashinfo raw_v6_hashinfo = {
- 	.lock = __RW_LOCK_UNLOCKED(raw_v6_hashinfo.lock),
- };
+ struct raw_hashinfo raw_v6_hashinfo;
  EXPORT_SYMBOL_GPL(raw_v6_hashinfo);
  
 -bool raw_v6_match(struct net *net, struct sock *sk, unsigned short num,
 -		  const struct in6_addr *loc_addr,
 -		  const struct in6_addr *rmt_addr, int dif, int sdif)
 +struct sock *__raw_v6_lookup(struct net *net, struct sock *sk,
 +		unsigned short num, const struct in6_addr *loc_addr,
 +		const struct in6_addr *rmt_addr, int dif, int sdif)
  {
 -	if (inet_sk(sk)->inet_num != num ||
 -	    !net_eq(sock_net(sk), net) ||
 -	    (!ipv6_addr_any(&sk->sk_v6_daddr) &&
 -	     !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||
 -	    !raw_sk_bound_dev_eq(net, sk->sk_bound_dev_if,
 -				 dif, sdif))
 -		return false;
 -
 -	if (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||
 -	    ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr) ||
 -	    (ipv6_addr_is_multicast(loc_addr) &&
 -	     inet6_mc_check(sk, loc_addr, rmt_addr)))
 -		return true;
 -
 -	return false;
 +	bool is_multicast = ipv6_addr_is_multicast(loc_addr);
 +
 +	sk_for_each_from(sk)
 +		if (inet_sk(sk)->inet_num == num) {
 +
 +			if (!net_eq(sock_net(sk), net))
 +				continue;
 +
 +			if (!ipv6_addr_any(&sk->sk_v6_daddr) &&
 +			    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr))
 +				continue;
 +
 +			if (sk->sk_bound_dev_if &&
 +			    sk->sk_bound_dev_if != dif &&
 +			    sk->sk_bound_dev_if != sdif)
 +				continue;
 +
 +			if (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
 +				if (ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr))
 +					goto found;
 +				if (is_multicast &&
 +				    inet6_mc_check(sk, loc_addr, rmt_addr))
 +					goto found;
 +				continue;
 +			}
 +			goto found;
 +		}
 +	sk = NULL;
 +found:
 +	return sk;
  }
 -EXPORT_SYMBOL_GPL(raw_v6_match);
 +EXPORT_SYMBOL_GPL(__raw_v6_lookup);
  
  /*
   *	0 - deliver
@@@ -161,6 -140,9 +159,12 @@@ EXPORT_SYMBOL(rawv6_mh_filter_unregiste
   */
  static bool ipv6_raw_deliver(struct sk_buff *skb, int nexthdr)
  {
++<<<<<<< HEAD
++=======
+ 	struct net *net = dev_net(skb->dev);
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	const struct in6_addr *saddr;
  	const struct in6_addr *daddr;
  	struct sock *sk;
@@@ -172,20 -153,14 +176,26 @@@
  	daddr = saddr + 1;
  
  	hash = nexthdr & (RAW_HTABLE_SIZE - 1);
++<<<<<<< HEAD
 +
 +	read_lock(&raw_v6_hashinfo.lock);
 +	sk = sk_head(&raw_v6_hashinfo.ht[hash]);
 +
 +	if (!sk)
 +		goto out;
 +
 +	net = dev_net(skb->dev);
 +	sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr,
 +			     inet6_iif(skb), inet6_sdif(skb));
 +
 +	while (sk) {
++=======
+ 	hlist = &raw_v6_hashinfo.ht[hash];
+ 	rcu_read_lock();
+ 	hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  		int filtered;
  
 -		if (!raw_v6_match(net, sk, nexthdr, daddr, saddr,
 -				  inet6_iif(skb), inet6_sdif(skb)))
 -			continue;
  		delivered = true;
  		switch (nexthdr) {
  		case IPPROTO_ICMPV6:
@@@ -224,11 -199,8 +234,15 @@@
  				rawv6_rcv(sk, clone);
  			}
  		}
 +		sk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr,
 +				     inet6_iif(skb), inet6_sdif(skb));
  	}
++<<<<<<< HEAD
 +out:
 +	read_unlock(&raw_v6_hashinfo.lock);
++=======
+ 	rcu_read_unlock();
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	return delivered;
  }
  
@@@ -366,30 -332,28 +380,43 @@@ static void rawv6_err(struct sock *sk, 
  void raw6_icmp_error(struct sk_buff *skb, int nexthdr,
  		u8 type, u8 code, int inner_offset, __be32 info)
  {
++<<<<<<< HEAD
++=======
+ 	const struct in6_addr *saddr, *daddr;
+ 	struct net *net = dev_net(skb->dev);
+ 	struct hlist_nulls_head *hlist;
+ 	struct hlist_nulls_node *hnode;
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  	struct sock *sk;
  	int hash;
 +	const struct in6_addr *saddr, *daddr;
 +	struct net *net;
  
  	hash = nexthdr & (RAW_HTABLE_SIZE - 1);
++<<<<<<< HEAD
 +
 +	read_lock(&raw_v6_hashinfo.lock);
 +	sk = sk_head(&raw_v6_hashinfo.ht[hash]);
 +	if (sk) {
++=======
+ 	hlist = &raw_v6_hashinfo.ht[hash];
+ 	rcu_read_lock();
+ 	hlist_nulls_for_each_entry(sk, hnode, hlist, sk_nulls_node) {
++>>>>>>> 0daf07e52709 (raw: convert raw sockets to RCU)
  		/* Note: ipv6_hdr(skb) != skb->data */
  		const struct ipv6hdr *ip6h = (const struct ipv6hdr *)skb->data;
  		saddr = &ip6h->saddr;
  		daddr = &ip6h->daddr;
 +		net = dev_net(skb->dev);
  
 -		if (!raw_v6_match(net, sk, nexthdr, &ip6h->saddr, &ip6h->daddr,
 -				  inet6_iif(skb), inet6_iif(skb)))
 -			continue;
 -		rawv6_err(sk, skb, NULL, type, code, inner_offset, info);
 +		while ((sk = __raw_v6_lookup(net, sk, nexthdr, saddr, daddr,
 +					     inet6_iif(skb), inet6_iif(skb)))) {
 +			rawv6_err(sk, skb, NULL, type, code,
 +					inner_offset, info);
 +			sk = sk_next(sk);
 +		}
  	}
- 	read_unlock(&raw_v6_hashinfo.lock);
+ 	rcu_read_unlock();
  }
  
  static inline int rawv6_rcv_skb(struct sock *sk, struct sk_buff *skb)
diff --git a/include/net/raw.h b/include/net/raw.h
index 9c9fa98a91a4..d3d430a09be3 100644
--- a/include/net/raw.h
+++ b/include/net/raw.h
@@ -38,9 +38,18 @@ int raw_rcv(struct sock *, struct sk_buff *);
 
 struct raw_hashinfo {
 	rwlock_t lock;
-	struct hlist_head ht[RAW_HTABLE_SIZE];
+	struct hlist_nulls_head ht[RAW_HTABLE_SIZE];
 };
 
+static inline void raw_hashinfo_init(struct raw_hashinfo *hashinfo)
+{
+	int i;
+
+	rwlock_init(&hashinfo->lock);
+	for (i = 0; i < RAW_HTABLE_SIZE; i++)
+		INIT_HLIST_NULLS_HEAD(&hashinfo->ht[i], i);
+}
+
 #ifdef CONFIG_PROC_FS
 int raw_proc_init(void);
 void raw_proc_exit(void);
diff --git a/include/net/rawv6.h b/include/net/rawv6.h
index 53d86b6055e8..2efa4a88616f 100644
--- a/include/net/rawv6.h
+++ b/include/net/rawv6.h
@@ -3,6 +3,7 @@
 #define _NET_RAWV6_H
 
 #include <net/protocol.h>
+#include <net/raw.h>
 
 extern struct raw_hashinfo raw_v6_hashinfo;
 struct sock *__raw_v6_lookup(struct net *net, struct sock *sk,
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 086864d35db6..9d4da1e6ad66 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1935,6 +1935,8 @@ static int __init inet_init(void)
 
 	sock_skb_cb_check_size(sizeof(struct inet_skb_parm));
 
+	raw_hashinfo_init(&raw_v4_hashinfo);
+
 	rc = proto_register(&tcp_prot, 1);
 	if (rc)
 		goto out;
* Unmerged path net/ipv4/raw.c
* Unmerged path net/ipv4/raw_diag.c
* Unmerged path net/ipv6/af_inet6.c
* Unmerged path net/ipv6/raw.c
