treewide: use get_random_u32() when possible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jason A. Donenfeld <Jason@zx2c4.com>
commit a251c17aa558d8e3128a528af5cf8b9d7caae4fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a251c17a.failed

The prandom_u32() function has been a deprecated inline wrapper around
get_random_u32() for several releases now, and compiles down to the
exact same code. Replace the deprecated wrapper with a direct call to
the real function. The same also applies to get_random_int(), which is
just a wrapper around get_random_u32(). This was done as a basic find
and replace.

	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Yury Norov <yury.norov@gmail.com>
	Reviewed-by: Jan Kara <jack@suse.cz> # for ext4
	Acked-by: Toke Høiland-Jørgensen <toke@toke.dk> # for sch_cake
	Acked-by: Chuck Lever <chuck.lever@oracle.com> # for nfsd
	Acked-by: Jakub Kicinski <kuba@kernel.org>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com> # for thunderbolt
	Acked-by: Darrick J. Wong <djwong@kernel.org> # for xfs
	Acked-by: Helge Deller <deller@gmx.de> # for parisc
	Acked-by: Heiko Carstens <hca@linux.ibm.com> # for s390
	Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
(cherry picked from commit a251c17aa558d8e3128a528af5cf8b9d7caae4fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/tests/drm_buddy_test.c
#	drivers/infiniband/hw/cxgb4/cm.c
#	drivers/media/test-drivers/vivid/vivid-touch-cap.c
#	drivers/misc/habanalabs/gaudi2/gaudi2.c
#	drivers/net/wireless/microchip/wilc1000/cfg80211.c
#	drivers/nvme/common/auth.c
#	fs/exfat/inode.c
#	fs/ext4/ioctl.c
#	fs/f2fs/namei.c
#	fs/nfsd/nfs4state.c
#	fs/ntfs3/fslog.c
#	fs/ubifs/journal.c
#	fs/xfs/xfs_icache.c
#	fs/xfs/xfs_log.c
#	kernel/bpf/bloom_filter.c
#	kernel/kcsan/selftest.c
#	lib/reed_solomon/test_rslib.c
#	lib/test_fprobe.c
#	lib/test_kprobes.c
#	net/unix/af_unix.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index e79f5b92ebbb,499a425a3379..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -2463,21 -2468,13 +2463,25 @@@ static int accept_cr(struct c4iw_ep *ep
  			opt2 |= CCTRL_ECN_V(1);
  	}
  
 +	skb_get(skb);
 +	rpl = cplhdr(skb);
  	if (!is_t4(adapter_type)) {
++<<<<<<< HEAD
 +		skb_trim(skb, roundup(sizeof(*rpl5), 16));
 +		rpl5 = (void *)rpl;
 +		INIT_TP_WR(rpl5, ep->hwtid);
 +	} else {
 +		skb_trim(skb, sizeof(*rpl));
 +		INIT_TP_WR(rpl, ep->hwtid);
 +	}
 +	OPCODE_TID(rpl) = cpu_to_be32(MK_OPCODE_TID(CPL_PASS_ACCEPT_RPL,
 +						    ep->hwtid));
++=======
+ 		u32 isn = (get_random_u32() & ~7UL) - 1;
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  
 -		skb = get_skb(skb, roundup(sizeof(*rpl5), 16), GFP_KERNEL);
 -		rpl5 = __skb_put_zero(skb, roundup(sizeof(*rpl5), 16));
 -		rpl = (void *)rpl5;
 -		INIT_TP_WR_CPL(rpl5, CPL_PASS_ACCEPT_RPL, ep->hwtid);
 +	if (CHELSIO_CHIP_VERSION(adapter_type) > CHELSIO_T4) {
 +		u32 isn = (prandom_u32() & ~7UL) - 1;
  		opt2 |= T5_OPT_2_VALID_F;
  		opt2 |= CONG_CNTRL_V(CONG_ALG_TAHOE);
  		opt2 |= T5_ISS_F;
diff --cc fs/ext4/ioctl.c
index 13f14ea35f73,ded535535b27..000000000000
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@@ -196,13 -452,14 +196,20 @@@ static long swap_inode_boot_loader(stru
  	swap_inode_data(inode, inode_bl);
  
  	inode->i_ctime = inode_bl->i_ctime = current_time(inode);
 -	inode_inc_iversion(inode);
  
++<<<<<<< HEAD
 +	inode->i_generation = prandom_u32();
 +	inode_bl->i_generation = prandom_u32();
 +	reset_inode_seed(inode);
 +	reset_inode_seed(inode_bl);
++=======
+ 	inode->i_generation = get_random_u32();
+ 	inode_bl->i_generation = get_random_u32();
+ 	ext4_reset_inode_seed(inode);
+ 	ext4_reset_inode_seed(inode_bl);
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  
 -	ext4_discard_preallocations(inode, 0);
 +	ext4_discard_preallocations(inode);
  
  	err = ext4_mark_inode_dirty(handle, inode);
  	if (err < 0) {
diff --cc fs/f2fs/namei.c
index 231b7f3ea7d3,a389772fd212..000000000000
--- a/fs/f2fs/namei.c
+++ b/fs/f2fs/namei.c
@@@ -51,8 -49,8 +51,13 @@@ static struct inode *f2fs_new_inode(str
  	inode->i_ino = ino;
  	inode->i_blocks = 0;
  	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
++<<<<<<< HEAD
 +	F2FS_I(inode)->i_crtime = timespec64_to_timespec(inode->i_mtime);
 +	inode->i_generation = sbi->s_next_generation++;
++=======
+ 	F2FS_I(inode)->i_crtime = inode->i_mtime;
+ 	inode->i_generation = get_random_u32();
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  
  	if (S_ISDIR(inode->i_mode))
  		F2FS_I(inode)->i_current_depth = 1;
diff --cc fs/nfsd/nfs4state.c
index 142ba4ae6430,4e718500a00c..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -4165,6 -4346,59 +4165,62 @@@ out
  	return -ENOMEM;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned long
+ nfsd_courtesy_client_count(struct shrinker *shrink, struct shrink_control *sc)
+ {
+ 	int cnt;
+ 	struct nfsd_net *nn = container_of(shrink,
+ 			struct nfsd_net, nfsd_client_shrinker);
+ 
+ 	cnt = atomic_read(&nn->nfsd_courtesy_clients);
+ 	if (cnt > 0)
+ 		mod_delayed_work(laundry_wq, &nn->nfsd_shrinker_work, 0);
+ 	return (unsigned long)cnt;
+ }
+ 
+ static unsigned long
+ nfsd_courtesy_client_scan(struct shrinker *shrink, struct shrink_control *sc)
+ {
+ 	return SHRINK_STOP;
+ }
+ 
+ int
+ nfsd4_init_leases_net(struct nfsd_net *nn)
+ {
+ 	struct sysinfo si;
+ 	u64 max_clients;
+ 
+ 	nn->nfsd4_lease = 90;	/* default lease time */
+ 	nn->nfsd4_grace = 90;
+ 	nn->somebody_reclaimed = false;
+ 	nn->track_reclaim_completes = false;
+ 	nn->clverifier_counter = get_random_u32();
+ 	nn->clientid_base = get_random_u32();
+ 	nn->clientid_counter = nn->clientid_base + 1;
+ 	nn->s2s_cp_cl_id = nn->clientid_counter++;
+ 
+ 	atomic_set(&nn->nfs4_client_count, 0);
+ 	si_meminfo(&si);
+ 	max_clients = (u64)si.totalram * si.mem_unit / (1024 * 1024 * 1024);
+ 	max_clients *= NFS4_CLIENTS_PER_GB;
+ 	nn->nfs4_max_clients = max_t(int, max_clients, NFS4_CLIENTS_PER_GB);
+ 
+ 	atomic_set(&nn->nfsd_courtesy_clients, 0);
+ 	nn->nfsd_client_shrinker.scan_objects = nfsd_courtesy_client_scan;
+ 	nn->nfsd_client_shrinker.count_objects = nfsd_courtesy_client_count;
+ 	nn->nfsd_client_shrinker.seeks = DEFAULT_SEEKS;
+ 	return register_shrinker(&nn->nfsd_client_shrinker, "nfsd-client");
+ }
+ 
+ void
+ nfsd4_leases_net_shutdown(struct nfsd_net *nn)
+ {
+ 	unregister_shrinker(&nn->nfsd_client_shrinker);
+ }
+ 
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  static void init_nfs4_replay(struct nfs4_replay *rp)
  {
  	rp->rp_status = nfserr_serverfault;
diff --cc fs/ubifs/journal.c
index 07b4956e0425,4619652046cf..000000000000
--- a/fs/ubifs/journal.c
+++ b/fs/ubifs/journal.c
@@@ -503,7 -503,7 +503,11 @@@ static void mark_inode_clean(struct ubi
  static void set_dent_cookie(struct ubifs_info *c, struct ubifs_dent_node *dent)
  {
  	if (c->double_hash)
++<<<<<<< HEAD
 +		dent->cookie = prandom_u32();
++=======
+ 		dent->cookie = (__force __le32) get_random_u32();
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  	else
  		dent->cookie = 0;
  }
diff --cc fs/xfs/xfs_icache.c
index 2ee8fefb589b,eae7427062cf..000000000000
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@@ -596,9 -594,9 +596,15 @@@ xfs_iget_cache_miss
  	 * value and hence we must also read the inode off disk even when
  	 * initializing new inodes.
  	 */
++<<<<<<< HEAD
 +	if (xfs_sb_version_has_v3inode(&mp->m_sb) &&
 +	    (flags & XFS_IGET_CREATE) && !(mp->m_flags & XFS_MOUNT_IKEEP)) {
 +		VFS_I(ip)->i_generation = prandom_u32();
++=======
+ 	if (xfs_has_v3inodes(mp) &&
+ 	    (flags & XFS_IGET_CREATE) && !xfs_has_ikeep(mp)) {
+ 		VFS_I(ip)->i_generation = get_random_u32();
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  	} else {
  		struct xfs_buf		*bp;
  
diff --cc fs/xfs/xfs_log.c
index 06474c360c0a,f02a0dd522b3..000000000000
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@@ -3524,8 -3544,7 +3524,12 @@@ xlog_ticket_alloc
  	tic->t_curr_res		= unit_res;
  	tic->t_cnt		= cnt;
  	tic->t_ocnt		= cnt;
++<<<<<<< HEAD
 +	tic->t_tid		= prandom_u32();
 +	tic->t_clientid		= client;
++=======
+ 	tic->t_tid		= get_random_u32();
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  	if (permanent)
  		tic->t_flags |= XLOG_TIC_PERM_RESERV;
  
diff --cc net/unix/af_unix.c
index c53c106047b1,b3545fc68097..000000000000
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@@ -899,18 -1146,20 +899,23 @@@ static int unix_autobind(struct socket 
  	addr->name->sun_family = AF_UNIX;
  	refcount_set(&addr->refcnt, 1);
  
++<<<<<<< HEAD
++=======
+ 	ordernum = get_random_u32();
+ 	lastnum = ordernum & 0xFFFFF;
++>>>>>>> a251c17aa558 (treewide: use get_random_u32() when possible)
  retry:
 -	ordernum = (ordernum + 1) & 0xFFFFF;
 -	sprintf(addr->name->sun_path + 1, "%05x", ordernum);
 +	addr->len = sprintf(addr->name->sun_path+1, "%05x", ordernum) + 1 + sizeof(short);
 +	addr->hash = unix_hash_fold(csum_partial(addr->name, addr->len, 0));
  
 -	new_hash = unix_abstract_hash(addr->name, addr->len, sk->sk_type);
 -	unix_table_double_lock(net, old_hash, new_hash);
 +	spin_lock(&unix_table_lock);
 +	ordernum = (ordernum+1)&0xFFFFF;
  
 -	if (__unix_find_socket_byname(net, addr->name, addr->len, new_hash)) {
 -		unix_table_double_unlock(net, old_hash, new_hash);
 -
 -		/* __unix_find_socket_byname() may take long time if many names
 +	if (__unix_find_socket_byname(net, addr->name, addr->len, sock->type,
 +				      addr->hash)) {
 +		spin_unlock(&unix_table_lock);
 +		/*
 +		 * __unix_find_socket_byname() may take long time if many names
  		 * are already in use.
  		 */
  		cond_resched();
* Unmerged path drivers/gpu/drm/tests/drm_buddy_test.c
* Unmerged path drivers/media/test-drivers/vivid/vivid-touch-cap.c
* Unmerged path drivers/misc/habanalabs/gaudi2/gaudi2.c
* Unmerged path drivers/net/wireless/microchip/wilc1000/cfg80211.c
* Unmerged path drivers/nvme/common/auth.c
* Unmerged path fs/exfat/inode.c
* Unmerged path fs/ntfs3/fslog.c
* Unmerged path kernel/bpf/bloom_filter.c
* Unmerged path kernel/kcsan/selftest.c
* Unmerged path lib/reed_solomon/test_rslib.c
* Unmerged path lib/test_fprobe.c
* Unmerged path lib/test_kprobes.c
diff --git a/Documentation/networking/filter.rst b/Documentation/networking/filter.rst
index 0a2c39d6701e..70aaa2388471 100644
--- a/Documentation/networking/filter.rst
+++ b/Documentation/networking/filter.rst
@@ -298,7 +298,7 @@ Possible BPF extensions are shown in the following table:
   vlan_tci                              skb_vlan_tag_get(skb)
   vlan_avail                            skb_vlan_tag_present(skb)
   vlan_tpid                             skb->vlan_proto
-  rand                                  prandom_u32()
+  rand                                  get_random_u32()
   ===================================   =================================================
 
 These extensions can also be prefixed with '#'.
diff --git a/arch/parisc/kernel/process.c b/arch/parisc/kernel/process.c
index b931745815e0..2d456521df26 100644
--- a/arch/parisc/kernel/process.c
+++ b/arch/parisc/kernel/process.c
@@ -329,7 +329,7 @@ void *dereference_kernel_function_descriptor(void *ptr)
 
 static inline unsigned long brk_rnd(void)
 {
-	return (get_random_int() & BRK_RND_MASK) << PAGE_SHIFT;
+	return (get_random_u32() & BRK_RND_MASK) << PAGE_SHIFT;
 }
 
 unsigned long arch_randomize_brk(struct mm_struct *mm)
diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c
index 43b308cfdf53..ff6d171ba9a5 100644
--- a/arch/parisc/kernel/sys_parisc.c
+++ b/arch/parisc/kernel/sys_parisc.c
@@ -237,14 +237,14 @@ static unsigned long mmap_rnd(void)
 	unsigned long rnd = 0;
 
 	if (current->flags & PF_RANDOMIZE)
-		rnd = get_random_int() & MMAP_RND_MASK;
+		rnd = get_random_u32() & MMAP_RND_MASK;
 
 	return rnd << PAGE_SHIFT;
 }
 
 unsigned long arch_mmap_rnd(void)
 {
-	return (get_random_int() & MMAP_RND_MASK) << PAGE_SHIFT;
+	return (get_random_u32() & MMAP_RND_MASK) << PAGE_SHIFT;
 }
 
 static unsigned long mmap_legacy_base(void)
diff --git a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c
index 0a7627cdb34e..54aff943a6a3 100644
--- a/arch/s390/mm/mmap.c
+++ b/arch/s390/mm/mmap.c
@@ -48,7 +48,7 @@ static inline int mmap_is_legacy(struct rlimit *rlim_stack)
 
 unsigned long arch_mmap_rnd(void)
 {
-	return (get_random_int() & MMAP_RND_MASK) << PAGE_SHIFT;
+	return (get_random_u32() & MMAP_RND_MASK) << PAGE_SHIFT;
 }
 
 static unsigned long mmap_base_legacy(unsigned long rnd)
diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c
index 45b1a646fe2e..fdca869e4f49 100644
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -559,7 +559,7 @@ static void bsp_init_amd(struct cpuinfo_x86 *c)
 		va_align.flags    = ALIGN_VA_32 | ALIGN_VA_64;
 
 		/* A random value per boot for bit slice [12:upper_bit) */
-		va_align.bits = get_random_int() & va_align.mask;
+		va_align.bits = get_random_u32() & va_align.mask;
 	}
 
 	if (cpu_has(c, X86_FEATURE_MWAITX))
diff --git a/drivers/crypto/chelsio/chtls/chtls_cm.c b/drivers/crypto/chelsio/chtls/chtls_cm.c
index df314aa43762..be6e89777c8e 100644
--- a/drivers/crypto/chelsio/chtls/chtls_cm.c
+++ b/drivers/crypto/chelsio/chtls/chtls_cm.c
@@ -985,7 +985,7 @@ static void chtls_pass_accept_rpl(struct sk_buff *skb,
 	opt2 |= T5_OPT_2_VALID_F;
 	rpl5->opt0 = cpu_to_be64(opt0);
 	rpl5->opt2 = cpu_to_be32(opt2);
-	rpl5->iss = cpu_to_be32((prandom_u32() & ~7UL) - 1);
+	rpl5->iss = cpu_to_be32((get_random_u32() & ~7UL) - 1);
 	set_wr_txq(skb, CPL_PRIORITY_SETUP, csk->port_id);
 	t4_set_arp_err_handler(skb, sk, chtls_accept_rpl_arp_failure);
 	cxgb4_l2t_send(csk->egress_dev, skb, csk->l2t_entry);
diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.c b/drivers/gpu/drm/i915/i915_gem_gtt.c
index 36489be4896b..8a43ac707484 100644
--- a/drivers/gpu/drm/i915/i915_gem_gtt.c
+++ b/drivers/gpu/drm/i915/i915_gem_gtt.c
@@ -134,12 +134,12 @@ static u64 random_offset(u64 start, u64 end, u64 len, u64 align)
 	range = round_down(end - len, align) - round_up(start, align);
 	if (range) {
 		if (sizeof(unsigned long) == sizeof(u64)) {
-			addr = get_random_long();
+			addr = get_random_u64();
 		} else {
-			addr = get_random_int();
+			addr = get_random_u32();
 			if (range > U32_MAX) {
 				addr <<= 32;
-				addr |= get_random_int();
+				addr |= get_random_u32();
 			}
 		}
 		div64_u64_rem(addr, range, &addr);
diff --git a/drivers/gpu/drm/i915/selftests/i915_selftest.c b/drivers/gpu/drm/i915/selftests/i915_selftest.c
index 1bc11c09faef..c98730477b91 100644
--- a/drivers/gpu/drm/i915/selftests/i915_selftest.c
+++ b/drivers/gpu/drm/i915/selftests/i915_selftest.c
@@ -134,7 +134,7 @@ static int __run_selftests(const char *name,
 	int err = 0;
 
 	while (!i915_selftest.random_seed)
-		i915_selftest.random_seed = get_random_int();
+		i915_selftest.random_seed = get_random_u32();
 
 	i915_selftest.timeout_jiffies =
 		i915_selftest.timeout_ms ?
diff --git a/drivers/gpu/drm/selftests/test-drm_mm.c b/drivers/gpu/drm/selftests/test-drm_mm.c
index b768b53c4aee..1dc41d73d17e 100644
--- a/drivers/gpu/drm/selftests/test-drm_mm.c
+++ b/drivers/gpu/drm/selftests/test-drm_mm.c
@@ -2463,7 +2463,7 @@ static int __init test_drm_mm_init(void)
 	int err;
 
 	while (!random_seed)
-		random_seed = get_random_int();
+		random_seed = get_random_u32();
 
 	pr_info("Testing DRM range manager (struct drm_mm), with random_seed=0x%x max_iterations=%u max_prime=%u\n",
 		random_seed, max_iterations, max_prime);
* Unmerged path drivers/gpu/drm/tests/drm_buddy_test.c
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
diff --git a/drivers/infiniband/hw/hfi1/tid_rdma.c b/drivers/infiniband/hw/hfi1/tid_rdma.c
index 2a7abf7a1f7f..18b05ffb415a 100644
--- a/drivers/infiniband/hw/hfi1/tid_rdma.c
+++ b/drivers/infiniband/hw/hfi1/tid_rdma.c
@@ -850,7 +850,7 @@ void hfi1_kern_init_ctxt_generations(struct hfi1_ctxtdata *rcd)
 	int i;
 
 	for (i = 0; i < RXE_NUM_TID_FLOWS; i++) {
-		rcd->flows[i].generation = mask_generation(prandom_u32());
+		rcd->flows[i].generation = mask_generation(get_random_u32());
 		kern_set_hw_flow(rcd, KERN_GENERATION_RESERVED, i);
 	}
 }
diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index d13ecbdd4391..a37cfac5e23f 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -96,7 +96,7 @@ static void __propagate_pkey_ev(struct mlx4_ib_dev *dev, int port_num,
 __be64 mlx4_ib_gen_node_guid(void)
 {
 #define NODE_GUID_HI	((u64) (((u64)IB_OPENIB_OUI) << 40))
-	return cpu_to_be64(NODE_GUID_HI | prandom_u32());
+	return cpu_to_be64(NODE_GUID_HI | get_random_u32());
 }
 
 __be64 mlx4_ib_get_new_demux_tid(struct mlx4_ib_demux_ctx *ctx)
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
index fd9d7f2c4d64..a605cf66b83e 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
@@ -465,7 +465,7 @@ static int ipoib_cm_req_handler(struct ib_cm_id *cm_id,
 		goto err_qp;
 	}
 
-	psn = prandom_u32() & 0xffffff;
+	psn = get_random_u32() & 0xffffff;
 	ret = ipoib_cm_modify_rx_qp(dev, cm_id, p->qp, psn);
 	if (ret)
 		goto err_modify;
diff --git a/drivers/md/raid5-cache.c b/drivers/md/raid5-cache.c
index 60c737636973..dd653fd2d7bb 100644
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@ -3005,7 +3005,7 @@ static int r5l_load_log(struct r5l_log *log)
 	}
 create:
 	if (create_super) {
-		log->last_cp_seq = prandom_u32();
+		log->last_cp_seq = get_random_u32();
 		cp = 0;
 		r5l_log_write_empty_meta_block(log, cp, log->last_cp_seq);
 		/*
* Unmerged path drivers/media/test-drivers/vivid/vivid-touch-cap.c
* Unmerged path drivers/misc/habanalabs/gaudi2/gaudi2.c
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index 95dcea260f17..a7f166c7476e 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -4374,7 +4374,7 @@ static u32 bond_rr_gen_slave_id(struct bonding *bond)
 
 	switch (packets_per_slave) {
 	case 0:
-		slave_id = prandom_u32();
+		slave_id = get_random_u32();
 		break;
 	case 1:
 		slave_id = this_cpu_inc_return(*bond->rr_tx_counter);
diff --git a/drivers/net/ethernet/broadcom/cnic.c b/drivers/net/ethernet/broadcom/cnic.c
index c5cca63b8571..acbe680d3063 100644
--- a/drivers/net/ethernet/broadcom/cnic.c
+++ b/drivers/net/ethernet/broadcom/cnic.c
@@ -4165,7 +4165,7 @@ static int cnic_cm_init_bnx2_hw(struct cnic_dev *dev)
 {
 	u32 seed;
 
-	seed = prandom_u32();
+	seed = get_random_u32();
 	cnic_ctx_wr(dev, 45, 0, seed);
 	return 0;
 }
diff --git a/drivers/net/ethernet/rocker/rocker_main.c b/drivers/net/ethernet/rocker/rocker_main.c
index fbd127ea6ae3..eb55d43c23c5 100644
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@ -133,7 +133,7 @@ static int rocker_reg_test(const struct rocker *rocker)
 	u64 test_reg;
 	u64 rnd;
 
-	rnd = prandom_u32();
+	rnd = get_random_u32();
 	rnd >>= 1;
 	rocker_write32(rocker, TEST_REG, rnd);
 	test_reg = rocker_read32(rocker, TEST_REG);
@@ -143,9 +143,9 @@ static int rocker_reg_test(const struct rocker *rocker)
 		return -EIO;
 	}
 
-	rnd = prandom_u32();
+	rnd = get_random_u32();
 	rnd <<= 31;
-	rnd |= prandom_u32();
+	rnd |= get_random_u32();
 	rocker_write64(rocker, TEST_REG64, rnd);
 	test_reg = rocker_read64(rocker, TEST_REG64);
 	if (test_reg != rnd * 2) {
diff --git a/drivers/net/wireless/marvell/mwifiex/cfg80211.c b/drivers/net/wireless/marvell/mwifiex/cfg80211.c
index 6f23ec34e2e2..cf3ef7433e7b 100644
--- a/drivers/net/wireless/marvell/mwifiex/cfg80211.c
+++ b/drivers/net/wireless/marvell/mwifiex/cfg80211.c
@@ -250,7 +250,7 @@ mwifiex_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
 	tx_info->pkt_len = pkt_len;
 
 	mwifiex_form_mgmt_frame(skb, buf, len);
-	*cookie = prandom_u32() | 1;
+	*cookie = get_random_u32() | 1;
 
 	if (ieee80211_is_action(mgmt->frame_control))
 		skb = mwifiex_clone_skb_for_tx_status(priv,
@@ -314,7 +314,7 @@ mwifiex_cfg80211_remain_on_channel(struct wiphy *wiphy,
 					 duration);
 
 	if (!ret) {
-		*cookie = prandom_u32() | 1;
+		*cookie = get_random_u32() | 1;
 		priv->roc_cfg.cookie = *cookie;
 		priv->roc_cfg.chan = *chan;
 
* Unmerged path drivers/net/wireless/microchip/wilc1000/cfg80211.c
diff --git a/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c b/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c
index c274ba2e4dae..bdb394090f78 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c
+++ b/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c
@@ -429,7 +429,7 @@ qtnf_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
 {
 	struct qtnf_vif *vif = qtnf_netdev_get_priv(wdev->netdev);
 	const struct ieee80211_mgmt *mgmt_frame = (void *)params->buf;
-	u32 short_cookie = prandom_u32();
+	u32 short_cookie = get_random_u32();
 	u16 flags = 0;
 	u16 freq;
 
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 5584178bb8e2..166a187d595c 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -6077,7 +6077,7 @@ static int wl1271_register_hw(struct wl1271 *wl)
 			wl1271_warning("Fuse mac address is zero. using random mac\n");
 			/* Use TI oui and a random nic */
 			oui_addr = WLCORE_TI_OUI_ADDRESS;
-			nic_addr = get_random_int();
+			nic_addr = get_random_u32();
 		} else {
 			oui_addr = wl->fuse_oui_addr;
 			/* fuse has the BD_ADDR, the WLAN addresses are the next two */
* Unmerged path drivers/nvme/common/auth.c
diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index c79baac2a257..db9042a9e6bd 100644
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -253,7 +253,7 @@ static void send_act_open_req(struct cxgbi_sock *csk, struct sk_buff *skb,
 	} else if (is_t5(lldi->adapter_type)) {
 		struct cpl_t5_act_open_req *req =
 				(struct cpl_t5_act_open_req *)skb->head;
-		u32 isn = (prandom_u32() & ~7UL) - 1;
+		u32 isn = (get_random_u32() & ~7UL) - 1;
 
 		INIT_TP_WR(req, 0);
 		OPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ,
@@ -281,7 +281,7 @@ static void send_act_open_req(struct cxgbi_sock *csk, struct sk_buff *skb,
 	} else {
 		struct cpl_t6_act_open_req *req =
 				(struct cpl_t6_act_open_req *)skb->head;
-		u32 isn = (prandom_u32() & ~7UL) - 1;
+		u32 isn = (get_random_u32() & ~7UL) - 1;
 
 		INIT_TP_WR(req, 0);
 		OPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ,
diff --git a/drivers/target/iscsi/cxgbit/cxgbit_cm.c b/drivers/target/iscsi/cxgbit/cxgbit_cm.c
index c34a69624762..3a96a00e50fa 100644
--- a/drivers/target/iscsi/cxgbit/cxgbit_cm.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_cm.c
@@ -1205,7 +1205,7 @@ cxgbit_pass_accept_rpl(struct cxgbit_sock *csk, struct cpl_pass_accept_req *req)
 	opt2 |= CONG_CNTRL_V(CONG_ALG_NEWRENO);
 
 	opt2 |= T5_ISS_F;
-	rpl5->iss = cpu_to_be32((prandom_u32() & ~7UL) - 1);
+	rpl5->iss = cpu_to_be32((get_random_u32() & ~7UL) - 1);
 
 	opt2 |= T5_OPT_2_VALID_F;
 
diff --git a/drivers/thunderbolt/xdomain.c b/drivers/thunderbolt/xdomain.c
index 01d6b724ca51..9f6827ff9290 100644
--- a/drivers/thunderbolt/xdomain.c
+++ b/drivers/thunderbolt/xdomain.c
@@ -1965,7 +1965,7 @@ int tb_xdomain_init(void)
 	tb_property_add_immediate(xdomain_property_dir, "deviceid", 0x1);
 	tb_property_add_immediate(xdomain_property_dir, "devicerv", 0x80000100);
 
-	xdomain_property_block_gen = prandom_u32();
+	xdomain_property_block_gen = get_random_u32();
 	return 0;
 }
 
diff --git a/drivers/video/fbdev/uvesafb.c b/drivers/video/fbdev/uvesafb.c
index 64e84e29bc9c..aa62f2771471 100644
--- a/drivers/video/fbdev/uvesafb.c
+++ b/drivers/video/fbdev/uvesafb.c
@@ -166,7 +166,7 @@ static int uvesafb_exec(struct uvesafb_ktask *task)
 	memcpy(&m->id, &uvesafb_cn_id, sizeof(m->id));
 	m->seq = seq;
 	m->len = len;
-	m->ack = prandom_u32();
+	m->ack = get_random_u32();
 
 	/* uvesafb_task structure */
 	memcpy(m + 1, &task->t, sizeof(task->t));
* Unmerged path fs/exfat/inode.c
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 9f94224f79d6..5f31fdf65014 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -1134,7 +1134,7 @@ struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,
 					EXT4_GROUP_INFO_IBITMAP_CORRUPT);
 		goto out;
 	}
-	inode->i_generation = prandom_u32();
+	inode->i_generation = get_random_u32();
 
 	/* Precompute checksum seed for inode metadata */
 	if (ext4_has_metadata_csum(sb)) {
* Unmerged path fs/ext4/ioctl.c
diff --git a/fs/ext4/mmp.c b/fs/ext4/mmp.c
index 543dd656f65e..43d50b50a4e4 100644
--- a/fs/ext4/mmp.c
+++ b/fs/ext4/mmp.c
@@ -271,7 +271,7 @@ static unsigned int mmp_new_seq(void)
 	u32 new_seq;
 
 	do {
-		new_seq = prandom_u32();
+		new_seq = get_random_u32();
 	} while (new_seq > EXT4_MMP_SEQ_MAX);
 
 	return new_seq;
* Unmerged path fs/f2fs/namei.c
diff --git a/fs/fat/inode.c b/fs/fat/inode.c
index 8c8e862143bc..20bb5e71a7c0 100644
--- a/fs/fat/inode.c
+++ b/fs/fat/inode.c
@@ -520,7 +520,7 @@ int fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)
 	inode->i_uid = sbi->options.fs_uid;
 	inode->i_gid = sbi->options.fs_gid;
 	inode_inc_iversion(inode);
-	inode->i_generation = prandom_u32();
+	inode->i_generation = get_random_u32();
 
 	if ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {
 		inode->i_generation &= ~1;
* Unmerged path fs/nfsd/nfs4state.c
* Unmerged path fs/ntfs3/fslog.c
* Unmerged path fs/ubifs/journal.c
diff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c
index 9fffd73f0754..a3f6b4d3d230 100644
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@ -805,7 +805,7 @@ xfs_ialloc_ag_alloc(
 	 * number from being easily guessable.
 	 */
 	error = xfs_ialloc_inode_init(args.mp, tp, NULL, newlen, pag->pag_agno,
-			args.agbno, args.len, prandom_u32());
+			args.agbno, args.len, get_random_u32());
 
 	if (error)
 		return error;
* Unmerged path fs/xfs/xfs_icache.c
* Unmerged path fs/xfs/xfs_log.c
diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h
index d81a9cc38434..6e42dd6aad8b 100644
--- a/include/net/netfilter/nf_queue.h
+++ b/include/net/netfilter/nf_queue.h
@@ -41,7 +41,7 @@ void nf_queue_entry_free(struct nf_queue_entry *entry);
 static inline void init_hashrandom(u32 *jhash_initval)
 {
 	while (*jhash_initval == 0)
-		*jhash_initval = prandom_u32();
+		*jhash_initval = get_random_u32();
 }
 
 static inline u32 hash_v4(const struct iphdr *iph, u32 initval)
diff --git a/include/net/red.h b/include/net/red.h
index cc9f6b0d7f1e..13191f597ab5 100644
--- a/include/net/red.h
+++ b/include/net/red.h
@@ -364,7 +364,7 @@ static inline unsigned long red_calc_qavg(const struct red_parms *p,
 
 static inline u32 red_random(const struct red_parms *p)
 {
-	return reciprocal_divide(prandom_u32(), p->max_P_reciprocal);
+	return reciprocal_divide(get_random_u32(), p->max_P_reciprocal);
 }
 
 static inline int red_mark_probability(const struct red_parms *p,
diff --git a/include/net/sock.h b/include/net/sock.h
index d04d3dd8b996..6fb64ea9f370 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1967,7 +1967,7 @@ static inline kuid_t sock_net_uid(const struct net *net, const struct sock *sk)
 
 static inline u32 net_tx_rndhash(void)
 {
-	u32 v = prandom_u32();
+	u32 v = get_random_u32();
 
 	return v ?: 1;
 }
* Unmerged path kernel/bpf/bloom_filter.c
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 7d76b902c771..c590fdec210d 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -968,7 +968,7 @@ static int bpf_jit_blind_insn(const struct bpf_insn *from,
 			      bool emit_zext)
 {
 	struct bpf_insn *to = to_buff;
-	u32 imm_rnd = get_random_int();
+	u32 imm_rnd = get_random_u32();
 	s16 off;
 
 	BUILD_BUG_ON(BPF_REG_AX  + 1 != MAX_BPF_JIT_REG);
diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c
index 856deb219039..80b5dc04adc8 100644
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -508,7 +508,7 @@ static struct bpf_map *htab_map_alloc(union bpf_attr *attr)
 	if (htab->map.map_flags & BPF_F_ZERO_SEED)
 		htab->hashrnd = 0;
 	else
-		htab->hashrnd = get_random_int();
+		htab->hashrnd = get_random_u32();
 
 	htab_init_buckets(htab);
 
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 811f19052d90..7a3ff83dd26b 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -11798,7 +11798,7 @@ static int opt_subreg_zext_lo32_rnd_hi32(struct bpf_verifier_env *env,
 			    aux[adj_idx].ptr_type == PTR_TO_CTX)
 				continue;
 
-			imm_rnd = get_random_int();
+			imm_rnd = get_random_u32();
 			rnd_hi32_patch[0] = insn;
 			rnd_hi32_patch[1].imm = imm_rnd;
 			rnd_hi32_patch[3].dst_reg = load_reg;
* Unmerged path kernel/kcsan/selftest.c
diff --git a/lib/random32.c b/lib/random32.c
index 4d0e05e471d7..ee743ca0090d 100644
--- a/lib/random32.c
+++ b/lib/random32.c
@@ -47,7 +47,7 @@
  *	@state: pointer to state structure holding seeded state.
  *
  *	This is used for pseudo-randomness with no outside seeding.
- *	For more random results, use prandom_u32().
+ *	For more random results, use get_random_u32().
  */
 u32 prandom_u32_state(struct rnd_state *state)
 {
* Unmerged path lib/reed_solomon/test_rslib.c
* Unmerged path lib/test_fprobe.c
* Unmerged path lib/test_kprobes.c
diff --git a/lib/test_min_heap.c b/lib/test_min_heap.c
index d19c8080fd4d..7b01b4387cfb 100644
--- a/lib/test_min_heap.c
+++ b/lib/test_min_heap.c
@@ -83,7 +83,7 @@ static __init int test_heapify_all(bool min_heap)
 	/* Test with randomly generated values. */
 	heap.nr = ARRAY_SIZE(values);
 	for (i = 0; i < heap.nr; i++)
-		values[i] = get_random_int();
+		values[i] = get_random_u32();
 
 	min_heapify_all(&heap, &funcs);
 	err += pop_verify_heap(min_heap, &heap, &funcs);
@@ -116,7 +116,7 @@ static __init int test_heap_push(bool min_heap)
 
 	/* Test with randomly generated values. */
 	while (heap.nr < heap.size) {
-		temp = get_random_int();
+		temp = get_random_u32();
 		min_heap_push(&heap, &temp, &funcs);
 	}
 	err += pop_verify_heap(min_heap, &heap, &funcs);
@@ -158,7 +158,7 @@ static __init int test_heap_pop_push(bool min_heap)
 
 	/* Test with randomly generated values. */
 	for (i = 0; i < ARRAY_SIZE(data); i++) {
-		temp = get_random_int();
+		temp = get_random_u32();
 		min_heap_pop_push(&heap, &temp, &funcs);
 	}
 	err += pop_verify_heap(min_heap, &heap, &funcs);
diff --git a/lib/test_rhashtable.c b/lib/test_rhashtable.c
index 3e5f5b39f04a..463d4c4d932b 100644
--- a/lib/test_rhashtable.c
+++ b/lib/test_rhashtable.c
@@ -294,7 +294,7 @@ static int __init test_rhltable(unsigned int entries)
 	if (WARN_ON(err))
 		goto out_free;
 
-	k = prandom_u32();
+	k = get_random_u32();
 	ret = 0;
 	for (i = 0; i < entries; i++) {
 		rhl_test_objects[i].value.id = k;
@@ -372,12 +372,12 @@ static int __init test_rhltable(unsigned int entries)
 	pr_info("test %d random rhlist add/delete operations\n", entries);
 	for (j = 0; j < entries; j++) {
 		u32 i = prandom_u32_max(entries);
-		u32 prand = prandom_u32();
+		u32 prand = get_random_u32();
 
 		cond_resched();
 
 		if (prand == 0)
-			prand = prandom_u32();
+			prand = get_random_u32();
 
 		if (prand & 1) {
 			prand >>= 1;
diff --git a/mm/shmem.c b/mm/shmem.c
index c53a4c0338e8..ed57c72e3e6d 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -2226,7 +2226,7 @@ static struct inode *shmem_get_inode(struct super_block *sb, const struct inode
 		inode_init_owner(inode, dir, mode);
 		inode->i_blocks = 0;
 		inode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);
-		inode->i_generation = prandom_u32();
+		inode->i_generation = get_random_u32();
 		info = SHMEM_I(inode);
 		memset(info, 0, (char *)inode - (char *)info);
 		spin_lock_init(&info->lock);
diff --git a/mm/slab.c b/mm/slab.c
index 3017670bfa3e..fa0e194e6507 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -2393,7 +2393,7 @@ static bool freelist_state_initialize(union freelist_init_state *state,
 	unsigned int rand;
 
 	/* Use best entropy available to define a random shift */
-	rand = get_random_int();
+	rand = get_random_u32();
 
 	/* Use a random state if the pre-computed list is not available */
 	if (!cachep->random_seq) {
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index e791962b909f..a5158a909349 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -2366,7 +2366,7 @@ static void mod_cur_headers(struct pktgen_dev *pkt_dev)
 		for (i = 0; i < pkt_dev->nr_labels; i++)
 			if (pkt_dev->labels[i] & MPLS_STACK_BOTTOM)
 				pkt_dev->labels[i] = MPLS_STACK_BOTTOM |
-					     ((__force __be32)prandom_u32() &
+					     ((__force __be32)get_random_u32() &
 						      htonl(0x000fffff));
 	}
 
@@ -2470,7 +2470,7 @@ static void mod_cur_headers(struct pktgen_dev *pkt_dev)
 
 			for (i = 0; i < 4; i++) {
 				pkt_dev->cur_in6_daddr.s6_addr32[i] =
-				    (((__force __be32)prandom_u32() |
+				    (((__force __be32)get_random_u32() |
 				      pkt_dev->min_in6_daddr.s6_addr32[i]) &
 				     pkt_dev->max_in6_daddr.s6_addr32[i]);
 			}
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 5ad19572d74a..a217883ef5b7 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -3416,7 +3416,7 @@ static __net_init int rt_genid_init(struct net *net)
 {
 	atomic_set(&net->ipv4.rt_genid, 0);
 	atomic_set(&net->fnhe_genid, 0);
-	atomic_set(&net->ipv4.dev_addr_genid, get_random_int());
+	atomic_set(&net->ipv4.dev_addr_genid, get_random_u32());
 	return 0;
 }
 
diff --git a/net/ipv4/tcp_cdg.c b/net/ipv4/tcp_cdg.c
index 06fbe102a425..4f5597d8bfb0 100644
--- a/net/ipv4/tcp_cdg.c
+++ b/net/ipv4/tcp_cdg.c
@@ -242,7 +242,7 @@ static bool tcp_cdg_backoff(struct sock *sk, u32 grad)
 	struct cdg *ca = inet_csk_ca(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
 
-	if (prandom_u32() <= nexp_u32(grad * backoff_factor))
+	if (get_random_u32() <= nexp_u32(grad * backoff_factor))
 		return false;
 
 	if (use_ineff) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 4a432858266c..af483d33fc73 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -249,7 +249,7 @@ int udp_lib_get_port(struct sock *sk, unsigned short snum,
 		inet_get_local_port_range(net, &low, &high);
 		remaining = (high - low) + 1;
 
-		rand = prandom_u32();
+		rand = get_random_u32();
 		first = reciprocal_scale(rand, remaining) + low;
 		/*
 		 * force rand to be an odd multiple of UDP_HTABLE_SIZE
diff --git a/net/ipv6/ip6_flowlabel.c b/net/ipv6/ip6_flowlabel.c
index f994f50e1516..d7e36d79a538 100644
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@ -208,7 +208,7 @@ static struct ip6_flowlabel *fl_intern(struct net *net,
 	spin_lock_bh(&ip6_fl_lock);
 	if (label == 0) {
 		for (;;) {
-			fl->label = htonl(prandom_u32())&IPV6_FLOWLABEL_MASK;
+			fl->label = htonl(get_random_u32())&IPV6_FLOWLABEL_MASK;
 			if (fl->label) {
 				lfl = __fl_lookup(net, fl->label);
 				if (!lfl)
diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c
index 3829b565c645..5615ce355e09 100644
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@ -17,7 +17,7 @@ static u32 __ipv6_select_ident(struct net *net,
 	u32 id;
 
 	do {
-		id = prandom_u32();
+		id = get_random_u32();
 	} while (!id);
 
 	return id;
diff --git a/net/netfilter/ipvs/ip_vs_conn.c b/net/netfilter/ipvs/ip_vs_conn.c
index 2e7addd140ec..57f25eeca1c3 100644
--- a/net/netfilter/ipvs/ip_vs_conn.c
+++ b/net/netfilter/ipvs/ip_vs_conn.c
@@ -1249,7 +1249,7 @@ void ip_vs_random_dropentry(struct netns_ipvs *ipvs)
 	 * Randomly scan 1/32 of the whole table every second
 	 */
 	for (idx = 0; idx < (ip_vs_conn_tab_size>>5); idx++) {
-		unsigned int hash = prandom_u32() & ip_vs_conn_tab_mask;
+		unsigned int hash = get_random_u32() & ip_vs_conn_tab_mask;
 
 		hlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {
 			if (cp->ipvs != ipvs)
diff --git a/net/netfilter/xt_statistic.c b/net/netfilter/xt_statistic.c
index 8710fdba2ae2..ed092721298a 100644
--- a/net/netfilter/xt_statistic.c
+++ b/net/netfilter/xt_statistic.c
@@ -37,7 +37,7 @@ statistic_mt(const struct sk_buff *skb, struct xt_action_param *par)
 
 	switch (info->mode) {
 	case XT_STATISTIC_MODE_RANDOM:
-		if ((prandom_u32() & 0x7FFFFFFF) < info->u.random.probability)
+		if ((get_random_u32() & 0x7FFFFFFF) < info->u.random.probability)
 			ret = !ret;
 		break;
 	case XT_STATISTIC_MODE_NTH:
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index c0dd8f3118c0..a72ee4049a79 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -1041,7 +1041,7 @@ static int sample(struct datapath *dp, struct sk_buff *skb,
 	actions = nla_next(sample_arg, &rem);
 
 	if ((arg->probability != U32_MAX) &&
-	    (!arg->probability || prandom_u32() > arg->probability)) {
+	    (!arg->probability || get_random_u32() > arg->probability)) {
 		if (last)
 			consume_skb(skb);
 		return 0;
diff --git a/net/sched/sch_cake.c b/net/sched/sch_cake.c
index a43a58a73d09..520c156e520b 100644
--- a/net/sched/sch_cake.c
+++ b/net/sched/sch_cake.c
@@ -573,7 +573,7 @@ static bool cobalt_should_drop(struct cobalt_vars *vars,
 
 	/* Simple BLUE implementation.  Lack of ECN is deliberate. */
 	if (vars->p_drop)
-		drop |= (prandom_u32() < vars->p_drop);
+		drop |= (get_random_u32() < vars->p_drop);
 
 	/* Overload the drop_next field as an activity timeout */
 	if (!vars->count)
diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c
index 4cafd220f614..aebec6164823 100644
--- a/net/sched/sch_netem.c
+++ b/net/sched/sch_netem.c
@@ -175,7 +175,7 @@ static inline struct netem_skb_cb *netem_skb_cb(struct sk_buff *skb)
 static void init_crandom(struct crndstate *state, unsigned long rho)
 {
 	state->rho = rho;
-	state->last = prandom_u32();
+	state->last = get_random_u32();
 }
 
 /* get_crandom - correlated random number generator
@@ -188,9 +188,9 @@ static u32 get_crandom(struct crndstate *state)
 	unsigned long answer;
 
 	if (!state || state->rho == 0)	/* no correlation */
-		return prandom_u32();
+		return get_random_u32();
 
-	value = prandom_u32();
+	value = get_random_u32();
 	rho = (u64)state->rho + 1;
 	answer = (value * ((1ull<<32) - rho) + state->last * rho) >> 32;
 	state->last = answer;
@@ -204,7 +204,7 @@ static u32 get_crandom(struct crndstate *state)
 static bool loss_4state(struct netem_sched_data *q)
 {
 	struct clgstate *clg = &q->clg;
-	u32 rnd = prandom_u32();
+	u32 rnd = get_random_u32();
 
 	/*
 	 * Makes a comparison between rnd and the transition
@@ -272,15 +272,15 @@ static bool loss_gilb_ell(struct netem_sched_data *q)
 
 	switch (clg->state) {
 	case GOOD_STATE:
-		if (prandom_u32() < clg->a1)
+		if (get_random_u32() < clg->a1)
 			clg->state = BAD_STATE;
-		if (prandom_u32() < clg->a4)
+		if (get_random_u32() < clg->a4)
 			return true;
 		break;
 	case BAD_STATE:
-		if (prandom_u32() < clg->a2)
+		if (get_random_u32() < clg->a2)
 			clg->state = GOOD_STATE;
-		if (prandom_u32() > clg->a3)
+		if (get_random_u32() > clg->a3)
 			return true;
 	}
 
@@ -636,7 +636,7 @@ static void get_slot_next(struct netem_sched_data *q, u64 now)
 
 	if (!q->slot_dist)
 		next_delay = q->slot_config.min_delay +
-				(prandom_u32() *
+				(get_random_u32() *
 				 (q->slot_config.max_delay -
 				  q->slot_config.min_delay) >> 32);
 	else
diff --git a/net/sunrpc/auth_gss/gss_krb5_wrap.c b/net/sunrpc/auth_gss/gss_krb5_wrap.c
index b912da181237..2e8b765e024f 100644
--- a/net/sunrpc/auth_gss/gss_krb5_wrap.c
+++ b/net/sunrpc/auth_gss/gss_krb5_wrap.c
@@ -130,8 +130,8 @@ gss_krb5_make_confounder(char *p, u32 conflen)
 
 	/* initialize to random value */
 	if (i == 0) {
-		i = prandom_u32();
-		i = (i << 32) | prandom_u32();
+		i = get_random_u32();
+		i = (i << 32) | get_random_u32();
 	}
 
 	switch (conflen) {
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index bfe34224c04d..f8f4bb802151 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -1841,7 +1841,7 @@ xprt_alloc_xid(struct rpc_xprt *xprt)
 static void
 xprt_init_xid(struct rpc_xprt *xprt)
 {
-	xprt->xid = prandom_u32();
+	xprt->xid = get_random_u32();
 }
 
 static void
* Unmerged path net/unix/af_unix.c
