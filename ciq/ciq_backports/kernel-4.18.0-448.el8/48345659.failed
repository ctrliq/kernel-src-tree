wifi: mac80211: don't set link address for station

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 483456590adee7b97b201c6c5880095be14e1fd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/48345659.failed

We need to handle the link addresses for station differently,
they will be determined by the association code, stored, and
then applied when the links are actually created on success,
cfg80211 will fill in the right addresses per the data we're
sending back to it.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 483456590adee7b97b201c6c5880095be14e1fd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/iface.c
diff --cc net/mac80211/iface.c
index 0a38d98d9882,f4341f378d4e..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -365,6 -368,206 +365,209 @@@ static int ieee80211_open(struct net_de
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_link_setup(struct ieee80211_link_data *link)
+ {
+ 	if (link->sdata->vif.type == NL80211_IFTYPE_STATION)
+ 		ieee80211_mgd_setup_link(link);
+ }
+ 
+ static void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
+ 				int link_id,
+ 				struct ieee80211_link_data *link,
+ 				struct ieee80211_bss_conf *link_conf)
+ {
+ 	bool deflink = link_id < 0;
+ 
+ 	if (link_id < 0)
+ 		link_id = 0;
+ 
+ 	rcu_assign_pointer(sdata->vif.link_conf[link_id], link_conf);
+ 	rcu_assign_pointer(sdata->link[link_id], link);
+ 
+ 	link->sdata = sdata;
+ 	link->link_id = link_id;
+ 	link->conf = link_conf;
+ 	link_conf->link_id = link_id;
+ 
+ 	INIT_WORK(&link->csa_finalize_work,
+ 		  ieee80211_csa_finalize_work);
+ 	INIT_WORK(&link->color_change_finalize_work,
+ 		  ieee80211_color_change_finalize_work);
+ 	INIT_LIST_HEAD(&link->assigned_chanctx_list);
+ 	INIT_LIST_HEAD(&link->reserved_chanctx_list);
+ 	INIT_DELAYED_WORK(&link->dfs_cac_timer_work,
+ 			  ieee80211_dfs_cac_timer_work);
+ 
+ 	if (!deflink) {
+ 		switch (sdata->vif.type) {
+ 		case NL80211_IFTYPE_AP:
+ 			ether_addr_copy(link_conf->addr,
+ 					sdata->wdev.links[link_id].addr);
+ 			WARN_ON(!(sdata->wdev.valid_links & BIT(link_id)));
+ 			break;
+ 		case NL80211_IFTYPE_STATION:
+ 			break;
+ 		default:
+ 			WARN_ON(1);
+ 		}
+ 	}
+ }
+ 
+ static void ieee80211_link_stop(struct ieee80211_link_data *link)
+ {
+ 	if (link->sdata->vif.type == NL80211_IFTYPE_STATION)
+ 		ieee80211_mgd_stop_link(link);
+ }
+ 
+ struct link_container {
+ 	struct ieee80211_link_data data;
+ 	struct ieee80211_bss_conf conf;
+ };
+ 
+ static void ieee80211_free_links(struct ieee80211_sub_if_data *sdata,
+ 				 struct link_container **links)
+ {
+ 	unsigned int link_id;
+ 
+ 	synchronize_rcu();
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		if (!links[link_id])
+ 			continue;
+ 		ieee80211_link_stop(&links[link_id]->data);
+ 		kfree(links[link_id]);
+ 	}
+ }
+ 
+ static int ieee80211_vif_update_links(struct ieee80211_sub_if_data *sdata,
+ 				      struct link_container **to_free,
+ 				      u16 new_links)
+ {
+ 	u16 old_links = sdata->vif.valid_links;
+ 	unsigned long add = new_links & ~old_links;
+ 	unsigned long rem = old_links & ~new_links;
+ 	unsigned int link_id;
+ 	int ret;
+ 	struct link_container *links[IEEE80211_MLD_MAX_NUM_LINKS] = {}, *link;
+ 	struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	struct ieee80211_link_data *old_data[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	bool use_deflink = old_links == 0; /* set for error case */
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	memset(to_free, 0, sizeof(links));
+ 
+ 	if (old_links == new_links)
+ 		return 0;
+ 
+ 	/* allocate new link structures first */
+ 	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		link = kzalloc(sizeof(*link), GFP_KERNEL);
+ 		if (!link) {
+ 			ret = -ENOMEM;
+ 			goto free;
+ 		}
+ 		links[link_id] = link;
+ 	}
+ 
+ 	/* keep track of the old pointers for the driver */
+ 	BUILD_BUG_ON(sizeof(old) != sizeof(sdata->vif.link_conf));
+ 	memcpy(old, sdata->vif.link_conf, sizeof(old));
+ 	/* and for us in error cases */
+ 	BUILD_BUG_ON(sizeof(old_data) != sizeof(sdata->link));
+ 	memcpy(old_data, sdata->link, sizeof(old_data));
+ 
+ 	/* link them into data structures */
+ 	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		WARN_ON(!use_deflink &&
+ 			rcu_access_pointer(sdata->link[link_id]) == &sdata->deflink);
+ 
+ 		link = links[link_id];
+ 		ieee80211_link_init(sdata, link_id, &link->data, &link->conf);
+ 		ieee80211_link_setup(&link->data);
+ 	}
+ 
+ 	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		RCU_INIT_POINTER(sdata->link[link_id], NULL);
+ 		RCU_INIT_POINTER(sdata->vif.link_conf[link_id], NULL);
+ 	}
+ 
+ 	sdata->vif.valid_links = new_links;
+ 
+ 	/* tell the driver */
+ 	ret = drv_change_vif_links(sdata->local, sdata,
+ 				   old_links, new_links,
+ 				   old);
+ 	if (ret) {
+ 		/* restore config */
+ 		memcpy(sdata->link, old_data, sizeof(old_data));
+ 		memcpy(sdata->vif.link_conf, old, sizeof(old));
+ 		sdata->vif.valid_links = old_links;
+ 		/* and free the newly allocated links */
+ 		goto deinit;
+ 	}
+ 
+ 	/* use deflink/bss_conf again if and only if there are no more links */
+ 	use_deflink = new_links == 0;
+ 
+ 	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		if (rcu_access_pointer(sdata->link[link_id]) == &sdata->deflink)
+ 			continue;
+ 		/*
+ 		 * we must have allocated the data through this path so
+ 		 * we know we can free both at the same time
+ 		 */
+ 		to_free[link_id] = container_of(rcu_access_pointer(sdata->link[link_id]),
+ 						typeof(*links[link_id]),
+ 						data);
+ 	}
+ 
+ 	goto deinit;
+ free:
+ 	/* if we failed during allocation, only free all */
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		kfree(links[link_id]);
+ 		links[link_id] = NULL;
+ 	}
+ deinit:
+ 	if (use_deflink)
+ 		ieee80211_link_init(sdata, -1, &sdata->deflink,
+ 				    &sdata->vif.bss_conf);
+ 	return ret;
+ }
+ 
+ int ieee80211_vif_set_links(struct ieee80211_sub_if_data *sdata,
+ 			    u16 new_links)
+ {
+ 	struct link_container *links[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	int ret;
+ 
+ 	ret = ieee80211_vif_update_links(sdata, links, new_links);
+ 	ieee80211_free_links(sdata, links);
+ 
+ 	return ret;
+ }
+ 
+ static void ieee80211_vif_clear_links(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct link_container *links[IEEE80211_MLD_MAX_NUM_LINKS];
+ 
+ 	/*
+ 	 * The locking here is different because when we free links
+ 	 * in the station case we need to be able to cancel_work_sync()
+ 	 * something that also takes the lock.
+ 	 */
+ 
+ 	sdata_lock(sdata);
+ 	ieee80211_vif_update_links(sdata, links, 0);
+ 	sdata_unlock(sdata);
+ 
+ 	ieee80211_free_links(sdata, links);
+ }
+ 
++>>>>>>> 483456590ade (wifi: mac80211: don't set link address for station)
  static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, bool going_down)
  {
  	struct ieee80211_local *local = sdata->local;
* Unmerged path net/mac80211/iface.c
