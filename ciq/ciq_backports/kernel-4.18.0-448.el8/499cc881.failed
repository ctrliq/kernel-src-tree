ASoC: SOF: Intel: hda-ipc: Do not process IPC reply before firmware boot

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit 499cc881b09c8283ab5e75b0d6d21cb427722161
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/499cc881.failed

It is not yet clear, but it is possible to create a firmware so broken
that it will send a reply message before a FW_READY message (it is not
yet clear if FW_READY will arrive later).
Since the reply_data is allocated only after the FW_READY message, this
will lead to a NULL pointer dereference if not filtered out.

The issue was reported with IPC4 firmware but the same condition is present
for IPC3.

	Reported-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220712122357.31282-3-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 499cc881b09c8283ab5e75b0d6d21cb427722161)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda-ipc.c
diff --cc sound/soc/sof/intel/hda-ipc.c
index 0395638c43ae,65e688f749ea..000000000000
--- a/sound/soc/sof/intel/hda-ipc.c
+++ b/sound/soc/sof/intel/hda-ipc.c
@@@ -100,6 -117,77 +100,80 @@@ void hda_dsp_ipc_get_reply(struct snd_s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ irqreturn_t hda_dsp_ipc4_irq_thread(int irq, void *context)
+ {
+ 	struct sof_ipc4_msg notification_data = {{ 0 }};
+ 	struct snd_sof_dev *sdev = context;
+ 	bool ipc_irq = false;
+ 	u32 hipcie, hipct;
+ 
+ 	hipcie = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE);
+ 	if (hipcie & HDA_DSP_REG_HIPCIE_DONE) {
+ 		/* DSP received the message */
+ 		snd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL,
+ 					HDA_DSP_REG_HIPCCTL_DONE, 0);
+ 		hda_dsp_ipc_dsp_done(sdev);
+ 
+ 		ipc_irq = true;
+ 	}
+ 
+ 	hipct = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCT);
+ 	if (hipct & HDA_DSP_REG_HIPCT_BUSY) {
+ 		/* Message from DSP (reply or notification) */
+ 		u32 hipcte = snd_sof_dsp_read(sdev, HDA_DSP_BAR,
+ 					      HDA_DSP_REG_HIPCTE);
+ 		u32 primary = hipct & HDA_DSP_REG_HIPCT_MSG_MASK;
+ 		u32 extension = hipcte & HDA_DSP_REG_HIPCTE_MSG_MASK;
+ 
+ 		/* mask BUSY interrupt */
+ 		snd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL,
+ 					HDA_DSP_REG_HIPCCTL_BUSY, 0);
+ 
+ 		if (primary & SOF_IPC4_MSG_DIR_MASK) {
+ 			/* Reply received */
+ 			if (likely(sdev->fw_state == SOF_FW_BOOT_COMPLETE)) {
+ 				struct sof_ipc4_msg *data = sdev->ipc->msg.reply_data;
+ 
+ 				data->primary = primary;
+ 				data->extension = extension;
+ 
+ 				spin_lock_irq(&sdev->ipc_lock);
+ 
+ 				snd_sof_ipc_get_reply(sdev);
+ 				snd_sof_ipc_reply(sdev, data->primary);
+ 
+ 				spin_unlock_irq(&sdev->ipc_lock);
+ 			} else {
+ 				dev_dbg_ratelimited(sdev->dev,
+ 						    "IPC reply before FW_READY: %#x|%#x\n",
+ 						    primary, extension);
+ 			}
+ 		} else {
+ 			/* Notification received */
+ 
+ 			notification_data.primary = primary;
+ 			notification_data.extension = extension;
+ 			sdev->ipc->msg.rx_data = &notification_data;
+ 			snd_sof_ipc_msgs_rx(sdev);
+ 			sdev->ipc->msg.rx_data = NULL;
+ 		}
+ 
+ 		/* Let DSP know that we have finished processing the message */
+ 		hda_dsp_ipc_host_done(sdev);
+ 
+ 		ipc_irq = true;
+ 	}
+ 
+ 	if (!ipc_irq)
+ 		/* This interrupt is not shared so no need to return IRQ_NONE. */
+ 		dev_dbg_ratelimited(sdev->dev, "nothing to do in IPC IRQ thread\n");
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
++>>>>>>> 499cc881b09c (ASoC: SOF: Intel: hda-ipc: Do not process IPC reply before firmware boot)
  /* IPC handler thread */
  irqreturn_t hda_dsp_ipc_irq_thread(int irq, void *context)
  {
* Unmerged path sound/soc/sof/intel/hda-ipc.c
