mm/swapfile.c: add __swap_entry_free_locked()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Huang Ying <ying.huang@intel.com>
commit b32d5f32b9dbe64970f41602066f7904df15f3e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b32d5f32.failed

The part of __swap_entry_free() with lock held is separated into a new
function __swap_entry_free_locked().  Because we want to reuse that
piece of code in some other places.

Just mechanical code refactoring, there is no any functional change in
this function.

Link: http://lkml.kernel.org/r/20180720071845.17920-8-ying.huang@intel.com
	Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
	Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
	Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b32d5f32b9dbe64970f41602066f7904df15f3e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/swapfile.c
diff --cc mm/swapfile.c
index eeb5474766d3,d44b2d60a66a..000000000000
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@@ -1197,74 -1123,10 +1197,78 @@@ static struct swap_info_struct *swap_in
  	return p;
  }
  
++<<<<<<< HEAD
 +/*
 + * Check whether swap entry is valid in the swap device.  If so,
 + * return pointer to swap_info_struct, and keep the swap entry valid
 + * via preventing the swap device from being swapoff, until
 + * put_swap_device() is called.  Otherwise return NULL.
 + *
 + * The entirety of the RCU read critical section must come before the
 + * return from or after the call to synchronize_rcu() in
 + * enable_swap_info() or swapoff().  So if "si->flags & SWP_VALID" is
 + * true, the si->map, si->cluster_info, etc. must be valid in the
 + * critical section.
 + *
 + * Notice that swapoff or swapoff+swapon can still happen before the
 + * rcu_read_lock() in get_swap_device() or after the rcu_read_unlock()
 + * in put_swap_device() if there isn't any other way to prevent
 + * swapoff, such as page lock, page table lock, etc.  The caller must
 + * be prepared for that.  For example, the following situation is
 + * possible.
 + *
 + *   CPU1				CPU2
 + *   do_swap_page()
 + *     ...				swapoff+swapon
 + *     __read_swap_cache_async()
 + *       swapcache_prepare()
 + *         __swap_duplicate()
 + *           // check swap_map
 + *     // verify PTE not changed
 + *
 + * In __swap_duplicate(), the swap_map need to be checked before
 + * changing partly because the specified swap entry may be for another
 + * swap device which has been swapoff.  And in do_swap_page(), after
 + * the page is read from the swap device, the PTE is verified not
 + * changed with the page table locked to check whether the swap device
 + * has been swapoff or swapoff+swapon.
 + */
 +struct swap_info_struct *get_swap_device(swp_entry_t entry)
 +{
 +	struct swap_info_struct *si;
 +	unsigned long offset;
 +
 +	if (!entry.val)
 +		goto out;
 +	si = swp_swap_info(entry);
 +	if (!si)
 +		goto bad_nofile;
 +
 +	rcu_read_lock();
 +	if (!(si->flags & SWP_VALID))
 +		goto unlock_out;
 +	offset = swp_offset(entry);
 +	if (offset >= si->max)
 +		goto unlock_out;
 +
 +	return si;
 +bad_nofile:
 +	pr_err("%s: %s%08lx\n", __func__, Bad_file, entry.val);
 +out:
 +	return NULL;
 +unlock_out:
 +	rcu_read_unlock();
 +	return NULL;
 +}
 +
 +static unsigned char __swap_entry_free(struct swap_info_struct *p,
 +				       swp_entry_t entry, unsigned char usage)
++=======
+ static unsigned char __swap_entry_free_locked(struct swap_info_struct *p,
+ 					      unsigned long offset,
+ 					      unsigned char usage)
++>>>>>>> b32d5f32b9db (mm/swapfile.c: add __swap_entry_free_locked())
  {
- 	struct swap_cluster_info *ci;
- 	unsigned long offset = swp_offset(entry);
  	unsigned char count;
  	unsigned char has_cache;
  
* Unmerged path mm/swapfile.c
