net: tcp: use kfree_skb_reason() for tcp_v{4,6}_do_rcv()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit 8eba65fa5f06519042b98564089b942d795e3f8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8eba65fa.failed

Replace kfree_skb() used in tcp_v4_do_rcv() and tcp_v6_do_rcv() with
kfree_skb_reason().

	Reviewed-by: Mengen Sun <mengensun@tencent.com>
	Reviewed-by: Hao Peng <flyingpeng@tencent.com>
	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8eba65fa5f06519042b98564089b942d795e3f8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/tcp_ipv4.c
index 46d2e6848354,d42824aedc36..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1652,6 -1768,8 +1654,11 @@@ discard
  	return 0;
  
  csum_err:
++<<<<<<< HEAD
++=======
+ 	reason = SKB_DROP_REASON_TCP_CSUM;
+ 	trace_tcp_bad_csum(skb);
++>>>>>>> 8eba65fa5f06 (net: tcp: use kfree_skb_reason() for tcp_v{4,6}_do_rcv())
  	TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);
  	TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);
  	goto discard;
diff --cc net/ipv6/tcp_ipv6.c
index 8cdff0ded837,91cee8010285..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1351,11 -1471,13 +1351,17 @@@ out
   * This is because we cannot sleep with the original spinlock
   * held.
   */
 -INDIRECT_CALLABLE_SCOPE
 -int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
 +static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct ipv6_pinfo *np = inet6_sk(sk);
++=======
+ 	struct ipv6_pinfo *np = tcp_inet6_sk(sk);
+ 	struct sk_buff *opt_skb = NULL;
+ 	enum skb_drop_reason reason;
++>>>>>>> 8eba65fa5f06 (net: tcp: use kfree_skb_reason() for tcp_v{4,6}_do_rcv())
  	struct tcp_sock *tp;
 +	struct sk_buff *opt_skb = NULL;
  
  	/* Imagine: socket is IPv6. IPv4 packet arrives,
  	   goes to IPv4 receive handler and backlogged.
@@@ -1441,9 -1565,11 +1448,14 @@@ reset
  discard:
  	if (opt_skb)
  		__kfree_skb(opt_skb);
- 	kfree_skb(skb);
+ 	kfree_skb_reason(skb, reason);
  	return 0;
  csum_err:
++<<<<<<< HEAD
++=======
+ 	reason = SKB_DROP_REASON_TCP_CSUM;
+ 	trace_tcp_bad_csum(skb);
++>>>>>>> 8eba65fa5f06 (net: tcp: use kfree_skb_reason() for tcp_v{4,6}_do_rcv())
  	TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);
  	TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);
  	goto discard;
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
