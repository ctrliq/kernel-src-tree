wifi: mac80211: use link in start/stop ap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Shaul Triebitz <shaul.triebitz@intel.com>
commit d9f83f22a7913149fc8687b1cc54a28505d25990
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d9f83f22.failed

Use link and link_conf according to the link_id
provided by cfg in start_ap/stop_ap and change_beacon.
Also use them in the functions called by them.
Note that for a non MLD device, the link_id is 0,
and link[0] and link_conf[0] equal to deflink and
bss_conf respectively (what was there before).

Also, call vif_info_change for BSS related changes (SSID), and
link_info_change for LINK related changes (instead of the
legacy bss_info_change).

	Signed-off-by: Shaul Triebitz <shaul.triebitz@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit d9f83f22a7913149fc8687b1cc54a28505d25990)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/cfg.c
diff --cc net/mac80211/cfg.c
index 0990954e0931,f1ee73d96dfb..000000000000
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@@ -856,7 -870,7 +858,11 @@@ ieee80211_set_probe_resp(struct ieee802
  	if (!resp || !resp_len)
  		return 1;
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.probe_resp, sdata);
++=======
+ 	old = sdata_dereference(link->u.ap.probe_resp, sdata);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  
  	new = kzalloc(sizeof(struct probe_resp) + resp_len, GFP_KERNEL);
  	if (!new)
@@@ -872,7 -886,7 +878,11 @@@
  	else if (cca)
  		new->cntdwn_counter_offsets[0] = cca->counter_offset_presp;
  
++<<<<<<< HEAD
 +	rcu_assign_pointer(sdata->u.ap.probe_resp, new);
++=======
+ 	rcu_assign_pointer(link->u.ap.probe_resp, new);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	if (old)
  		kfree_rcu(old, rcu_head);
  
@@@ -892,13 -908,13 +904,21 @@@ static int ieee80211_set_fils_discovery
  	fd->min_interval = params->min_interval;
  	fd->max_interval = params->max_interval;
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.fils_discovery, sdata);
++=======
+ 	old = sdata_dereference(link->u.ap.fils_discovery, sdata);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	new = kzalloc(sizeof(*new) + params->tmpl_len, GFP_KERNEL);
  	if (!new)
  		return -ENOMEM;
  	new->len = params->tmpl_len;
  	memcpy(new->data, params->tmpl, params->tmpl_len);
++<<<<<<< HEAD
 +	rcu_assign_pointer(sdata->u.ap.fils_discovery, new);
++=======
+ 	rcu_assign_pointer(link->u.ap.fils_discovery, new);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  
  	if (old)
  		kfree_rcu(old, rcu_head);
@@@ -915,13 -933,13 +937,21 @@@ ieee80211_set_unsol_bcast_probe_resp(st
  	if (!params->tmpl || !params->tmpl_len)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.unsol_bcast_probe_resp, sdata);
++=======
+ 	old = sdata_dereference(link->u.ap.unsol_bcast_probe_resp, sdata);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	new = kzalloc(sizeof(*new) + params->tmpl_len, GFP_KERNEL);
  	if (!new)
  		return -ENOMEM;
  	new->len = params->tmpl_len;
  	memcpy(new->data, params->tmpl, params->tmpl_len);
++<<<<<<< HEAD
 +	rcu_assign_pointer(sdata->u.ap.unsol_bcast_probe_resp, new);
++=======
+ 	rcu_assign_pointer(link->u.ap.unsol_bcast_probe_resp, new);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  
  	if (old)
  		kfree_rcu(old, rcu_head);
@@@ -1001,9 -1017,11 +1029,16 @@@ static int ieee80211_assign_beacon(stru
  	int new_head_len, new_tail_len;
  	int size, err;
  	u32 changed = BSS_CHANGED_BEACON;
+ 	struct ieee80211_link_data *link = sdata->link[params->link_id];
+ 	struct ieee80211_bss_conf *link_conf =
+ 		sdata->vif.link_conf[params->link_id];
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.beacon, sdata);
 +
++=======
+ 	old = sdata_dereference(link->u.ap.beacon, sdata);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  
  	/* Need to have a beacon head if we don't have one yet */
  	if (!params->head && !old)
@@@ -1109,7 -1128,8 +1145,12 @@@
  		changed |= BSS_CHANGED_FTM_RESPONDER;
  	}
  
++<<<<<<< HEAD
 +	rcu_assign_pointer(sdata->u.ap.beacon, new);
++=======
+ 	rcu_assign_pointer(link->u.ap.beacon, new);
+ 	sdata->u.ap.active = true;
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  
  	if (old)
  		kfree_rcu(old, rcu_head);
@@@ -1133,27 -1152,30 +1173,40 @@@ static int ieee80211_start_ap(struct wi
  		      BSS_CHANGED_TWT;
  	int i, err;
  	int prev_beacon_int;
+ 	unsigned int link_id = params->beacon.link_id;
+ 	struct ieee80211_link_data *link = sdata->link[link_id];
+ 	struct ieee80211_bss_conf *link_conf = sdata->vif.link_conf[link_id];
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.beacon, sdata);
++=======
+ 	old = sdata_dereference(link->u.ap.beacon, sdata);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	if (old)
  		return -EALREADY;
  
  	if (params->smps_mode != NL80211_SMPS_OFF)
  		return -ENOTSUPP;
  
++<<<<<<< HEAD
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +
 +	sdata->needed_rx_chains = sdata->local->rx_chains;
++=======
+ 	link->smps_mode = IEEE80211_SMPS_OFF;
  
- 	prev_beacon_int = sdata->vif.bss_conf.beacon_int;
- 	sdata->vif.bss_conf.beacon_int = params->beacon_interval;
+ 	link->needed_rx_chains = sdata->local->rx_chains;
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
+ 
+ 	prev_beacon_int = link_conf->beacon_int;
+ 	link_conf->beacon_int = params->beacon_interval;
  
  	if (params->he_cap && params->he_oper) {
- 		sdata->vif.bss_conf.he_support = true;
- 		sdata->vif.bss_conf.htc_trig_based_pkt_ext =
+ 		link_conf->he_support = true;
+ 		link_conf->htc_trig_based_pkt_ext =
  			le32_get_bits(params->he_oper->he_oper_params,
  			      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);
- 		sdata->vif.bss_conf.frame_time_rts_th =
+ 		link_conf->frame_time_rts_th =
  			le32_get_bits(params->he_oper->he_oper_params,
  			      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
  		changed |= BSS_CHANGED_HE_OBSS_PD;
@@@ -1171,13 -1194,13 +1225,20 @@@
  	}
  
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	err = ieee80211_vif_use_channel(sdata, &params->chandef,
 +					IEEE80211_CHANCTX_SHARED);
 +	if (!err)
 +		ieee80211_vif_copy_chanctx_to_vlans(sdata, false);
++=======
+ 	err = ieee80211_link_use_channel(link, &params->chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
+ 	if (!err)
+ 		ieee80211_link_copy_chanctx_to_vlans(link, false);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	mutex_unlock(&local->mtx);
  	if (err) {
- 		sdata->vif.bss_conf.beacon_int = prev_beacon_int;
+ 		link_conf->beacon_int = prev_beacon_int;
  		return err;
  	}
  
@@@ -1203,28 -1226,28 +1264,38 @@@
  			params->crypto.control_port_no_preauth;
  	}
  
++<<<<<<< HEAD
 +	sdata->vif.bss_conf.dtim_period = params->dtim_period;
 +	sdata->vif.bss_conf.enable_beacon = true;
 +	sdata->vif.bss_conf.allow_p2p_go_ps = sdata->vif.p2p;
 +	sdata->vif.bss_conf.twt_responder = params->twt_responder;
 +	sdata->vif.bss_conf.he_obss_pd = params->he_obss_pd;
 +	sdata->vif.bss_conf.he_bss_color = params->beacon.he_bss_color;
 +	sdata->vif.bss_conf.s1g = params->chandef.chan->band ==
++=======
+ 	link_conf->dtim_period = params->dtim_period;
+ 	link_conf->enable_beacon = true;
+ 	link_conf->allow_p2p_go_ps = sdata->vif.p2p;
+ 	link_conf->twt_responder = params->twt_responder;
+ 	link_conf->he_obss_pd = params->he_obss_pd;
+ 	link_conf->he_bss_color = params->beacon.he_bss_color;
+ 	sdata->vif.cfg.s1g = params->chandef.chan->band ==
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  				  NL80211_BAND_S1GHZ;
  
 -	sdata->vif.cfg.ssid_len = params->ssid_len;
 +	sdata->vif.bss_conf.ssid_len = params->ssid_len;
  	if (params->ssid_len)
 -		memcpy(sdata->vif.cfg.ssid, params->ssid,
 +		memcpy(sdata->vif.bss_conf.ssid, params->ssid,
  		       params->ssid_len);
- 	sdata->vif.bss_conf.hidden_ssid =
+ 	link_conf->hidden_ssid =
  		(params->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE);
  
- 	memset(&sdata->vif.bss_conf.p2p_noa_attr, 0,
- 	       sizeof(sdata->vif.bss_conf.p2p_noa_attr));
- 	sdata->vif.bss_conf.p2p_noa_attr.oppps_ctwindow =
+ 	memset(&link_conf->p2p_noa_attr, 0,
+ 	       sizeof(link_conf->p2p_noa_attr));
+ 	link_conf->p2p_noa_attr.oppps_ctwindow =
  		params->p2p_ctwindow & IEEE80211_P2P_OPPPS_CTWINDOW_MASK;
  	if (params->p2p_opp_ps)
- 		sdata->vif.bss_conf.p2p_noa_attr.oppps_ctwindow |=
+ 		link_conf->p2p_noa_attr.oppps_ctwindow |=
  					IEEE80211_P2P_OPPPS_ENABLE_BIT;
  
  	sdata->beacon_rate_set = false;
@@@ -1264,11 -1289,12 +1337,20 @@@
  
  	err = drv_start_ap(sdata->local, sdata);
  	if (err) {
++<<<<<<< HEAD
 +		old = sdata_dereference(sdata->u.ap.beacon, sdata);
 +
 +		if (old)
 +			kfree_rcu(old, rcu_head);
 +		RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
++=======
+ 		old = sdata_dereference(link->u.ap.beacon, sdata);
+ 
+ 		if (old)
+ 			kfree_rcu(old, rcu_head);
+ 		RCU_INIT_POINTER(link->u.ap.beacon, NULL);
+ 		sdata->u.ap.active = false;
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  		goto error;
  	}
  
@@@ -1283,7 -1310,7 +1366,11 @@@
  
  error:
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 	ieee80211_link_release_channel(link);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	mutex_unlock(&local->mtx);
  
  	return err;
@@@ -1303,10 -1330,11 +1390,15 @@@ static int ieee80211_change_beacon(stru
  	/* don't allow changing the beacon while a countdown is in place - offset
  	 * of channel switch counter may change
  	 */
- 	if (sdata->vif.bss_conf.csa_active || sdata->vif.bss_conf.color_change_active)
+ 	if (link_conf->csa_active || link_conf->color_change_active)
  		return -EBUSY;
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.beacon, sdata);
++=======
+ 	old = sdata_dereference(sdata->link[params->link_id]->u.ap.beacon,
+ 				sdata);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	if (!old)
  		return -ENOENT;
  
@@@ -1325,17 -1352,18 +1416,26 @@@
  	return 0;
  }
  
- static void ieee80211_free_next_beacon(struct ieee80211_sub_if_data *sdata)
+ static void ieee80211_free_next_beacon(struct ieee80211_link_data *link)
  {
++<<<<<<< HEAD
 +	if (!sdata->u.ap.next_beacon)
 +		return;
 +
 +	kfree(sdata->u.ap.next_beacon->mbssid_ies);
 +	kfree(sdata->u.ap.next_beacon);
 +	sdata->u.ap.next_beacon = NULL;
++=======
+ 	if (!link->u.ap.next_beacon)
+ 		return;
+ 
+ 	kfree(link->u.ap.next_beacon->mbssid_ies);
+ 	kfree(link->u.ap.next_beacon);
+ 	link->u.ap.next_beacon = NULL;
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  }
  
 -static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
 -			     unsigned int link_id)
 +static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
  {
  	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
  	struct ieee80211_sub_if_data *vlan;
@@@ -1348,23 -1378,24 +1450,43 @@@
  
  	sdata_assert_lock(sdata);
  
++<<<<<<< HEAD
 +	old_beacon = sdata_dereference(sdata->u.ap.beacon, sdata);
 +	if (!old_beacon)
 +		return -ENOENT;
 +	old_probe_resp = sdata_dereference(sdata->u.ap.probe_resp, sdata);
 +	old_fils_discovery = sdata_dereference(sdata->u.ap.fils_discovery,
 +					       sdata);
 +	old_unsol_bcast_probe_resp =
 +		sdata_dereference(sdata->u.ap.unsol_bcast_probe_resp,
++=======
+ 	old_beacon = sdata_dereference(link->u.ap.beacon, sdata);
+ 	if (!old_beacon)
+ 		return -ENOENT;
+ 	old_probe_resp = sdata_dereference(link->u.ap.probe_resp,
+ 					   sdata);
+ 	old_fils_discovery = sdata_dereference(link->u.ap.fils_discovery,
+ 					       sdata);
+ 	old_unsol_bcast_probe_resp =
+ 		sdata_dereference(link->u.ap.unsol_bcast_probe_resp,
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  				  sdata);
  
  	/* abort any running channel switch */
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	sdata->vif.bss_conf.csa_active = false;
 +	if (sdata->csa_block_tx) {
 +		ieee80211_wake_vif_queues(local, sdata,
 +					  IEEE80211_QUEUE_STOP_REASON_CSA);
 +		sdata->csa_block_tx = false;
++=======
+ 	link_conf->csa_active = false;
+ 	if (link->csa_block_tx) {
+ 		ieee80211_wake_vif_queues(local, sdata,
+ 					  IEEE80211_QUEUE_STOP_REASON_CSA);
+ 		link->csa_block_tx = false;
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	}
  
  	mutex_unlock(&local->mtx);
@@@ -1377,10 -1408,11 +1499,18 @@@
  	netif_carrier_off(dev);
  
  	/* remove beacon and probe response */
++<<<<<<< HEAD
 +	RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
 +	RCU_INIT_POINTER(sdata->u.ap.probe_resp, NULL);
 +	RCU_INIT_POINTER(sdata->u.ap.fils_discovery, NULL);
 +	RCU_INIT_POINTER(sdata->u.ap.unsol_bcast_probe_resp, NULL);
++=======
+ 	sdata->u.ap.active = false;
+ 	RCU_INIT_POINTER(link->u.ap.beacon, NULL);
+ 	RCU_INIT_POINTER(link->u.ap.probe_resp, NULL);
+ 	RCU_INIT_POINTER(link->u.ap.fils_discovery, NULL);
+ 	RCU_INIT_POINTER(link->u.ap.unsol_bcast_probe_resp, NULL);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	kfree_rcu(old_beacon, rcu_head);
  	if (old_probe_resp)
  		kfree_rcu(old_probe_resp, rcu_head);
@@@ -1395,15 -1427,16 +1525,20 @@@
  	__sta_info_flush(sdata, true);
  	ieee80211_free_keys(sdata, true);
  
- 	sdata->vif.bss_conf.enable_beacon = false;
+ 	link_conf->enable_beacon = false;
  	sdata->beacon_rate_set = false;
 -	sdata->vif.cfg.ssid_len = 0;
 +	sdata->vif.bss_conf.ssid_len = 0;
  	clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);
 -	ieee80211_link_info_change_notify(sdata, link_id,
 -					  BSS_CHANGED_BEACON_ENABLED);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);
  
  	if (sdata->wdev.cac_started) {
++<<<<<<< HEAD
 +		chandef = sdata->vif.bss_conf.chandef;
 +		cancel_delayed_work_sync(&sdata->dfs_cac_timer_work);
++=======
+ 		chandef = link_conf->chandef;
+ 		cancel_delayed_work_sync(&link->dfs_cac_timer_work);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  		cfg80211_cac_event(sdata->dev, &chandef,
  				   NL80211_RADAR_CAC_ABORTED,
  				   GFP_KERNEL);
@@@ -1416,8 -1449,8 +1551,13 @@@
  	ieee80211_purge_tx_queue(&local->hw, &sdata->u.ap.ps.bc_buf);
  
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 	ieee80211_link_copy_chanctx_to_vlans(link, true);
+ 	ieee80211_link_release_channel(link);
++>>>>>>> d9f83f22a791 (wifi: mac80211: use link in start/stop ap)
  	mutex_unlock(&local->mtx);
  
  	return 0;
@@@ -3299,12 -3342,13 +3439,12 @@@ static int ieee80211_set_after_csa_beac
  
  	switch (sdata->vif.type) {
  	case NL80211_IFTYPE_AP:
 -		if (!sdata->deflink.u.ap.next_beacon)
 +		if (!sdata->u.ap.next_beacon)
  			return -EINVAL;
  
 -		err = ieee80211_assign_beacon(sdata,
 -					      sdata->deflink.u.ap.next_beacon,
 +		err = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
  					      NULL, NULL);
- 		ieee80211_free_next_beacon(sdata);
+ 		ieee80211_free_next_beacon(&sdata->deflink);
  
  		if (err < 0)
  			return err;
@@@ -4299,12 -4347,13 +4439,12 @@@ ieee80211_set_after_color_change_beacon
  	case NL80211_IFTYPE_AP: {
  		int ret;
  
 -		if (!sdata->deflink.u.ap.next_beacon)
 +		if (!sdata->u.ap.next_beacon)
  			return -EINVAL;
  
 -		ret = ieee80211_assign_beacon(sdata,
 -					      sdata->deflink.u.ap.next_beacon,
 +		ret = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
  					      NULL, NULL);
- 		ieee80211_free_next_beacon(sdata);
+ 		ieee80211_free_next_beacon(&sdata->deflink);
  
  		if (ret < 0)
  			return ret;
* Unmerged path net/mac80211/cfg.c
