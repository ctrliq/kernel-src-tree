usbnet: add method for reporting speed without MII

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
Rebuild_CHGLOG: - net: usb: usbnet: add method for reporting speed without MII (José Ignacio Tornos Martínez) [1984353]
Rebuild_FUZZ: 90.91%
commit-author Oliver Neukum <oneukum@suse.com>
commit 956baa99571bbaf88f3e91190dfb498c685b0e21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/956baa99.failed

The old method for reporting link speed assumed a driver uses the
generic phy (mii) MDIO read/write functions. CDC devices don't
expose the phy.

Add a primitive internal version reporting back directly what
the CDC notification/status operations recorded.

v2: rebased on upstream
v3: changed names and made clear which units are used
v4: moved hunks to correct patch; rewrote commmit messages

	Signed-off-by: Oliver Neukum <oneukum@suse.com>
	Tested-by: Roland Dreier <roland@kernel.org>
	Reviewed-by: Grant Grundler <grundler@chromium.org>
	Tested-by: Grant Grundler <grundler@chromium.org>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 956baa99571bbaf88f3e91190dfb498c685b0e21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/usbnet.c
diff --cc drivers/net/usb/usbnet.c
index deb2c3357562,ecf62849f4c1..000000000000
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@@ -968,9 -959,30 +968,34 @@@ int usbnet_get_link_ksettings(struct ne
  
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(usbnet_get_link_ksettings_mii);
 +EXPORT_SYMBOL_GPL(usbnet_get_link_ksettings);
  
++<<<<<<< HEAD
 +int usbnet_set_link_ksettings(struct net_device *net,
++=======
+ int usbnet_get_link_ksettings_internal(struct net_device *net,
+ 					struct ethtool_link_ksettings *cmd)
+ {
+ 	struct usbnet *dev = netdev_priv(net);
+ 
+ 	/* the assumption that speed is equal on tx and rx
+ 	 * is deeply engrained into the networking layer.
+ 	 * For wireless stuff it is not true.
+ 	 * We assume that rx_speed matters more.
+ 	 */
+ 	if (dev->rx_speed != SPEED_UNSET)
+ 		cmd->base.speed = dev->rx_speed / 1000000;
+ 	else if (dev->tx_speed != SPEED_UNSET)
+ 		cmd->base.speed = dev->tx_speed / 1000000;
+ 	else
+ 		cmd->base.speed = SPEED_UNKNOWN;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(usbnet_get_link_ksettings_internal);
+ 
+ int usbnet_set_link_ksettings_mii(struct net_device *net,
++>>>>>>> 956baa99571b (usbnet: add method for reporting speed without MII)
  			      const struct ethtool_link_ksettings *cmd)
  {
  	struct usbnet *dev = netdev_priv(net);
* Unmerged path drivers/net/usb/usbnet.c
diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 1272acd68930..cf97447bed6c 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -53,6 +53,9 @@ struct usbnet {
 	u32			hard_mtu;	/* count any extra framing */
 	size_t			rx_urb_size;	/* size for rx urbs */
 	struct mii_if_info	mii;
+	long			rx_speed;	/* If MII not used */
+	long			tx_speed;	/* If MII not used */
+#		define SPEED_UNSET	-1
 
 	/* various kinds of pending driver work */
 	struct sk_buff_head	rxq;
@@ -81,8 +84,6 @@ struct usbnet {
 #		define EVENT_LINK_CHANGE	11
 #		define EVENT_SET_RX_MODE	12
 #		define EVENT_NO_IP_ALIGN	13
-	u32			rx_speed;	/* in bps - NOT Mbps */
-	u32			tx_speed;	/* in bps - NOT Mbps */
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
@@ -271,6 +272,8 @@ extern int usbnet_get_link_ksettings(struct net_device *net,
 				     struct ethtool_link_ksettings *cmd);
 extern int usbnet_set_link_ksettings(struct net_device *net,
 				     const struct ethtool_link_ksettings *cmd);
+extern int usbnet_get_link_ksettings_internal(struct net_device *net,
+				     struct ethtool_link_ksettings *cmd);
 extern u32 usbnet_get_link(struct net_device *net);
 extern u32 usbnet_get_msglevel(struct net_device *);
 extern void usbnet_set_msglevel(struct net_device *, u32);
