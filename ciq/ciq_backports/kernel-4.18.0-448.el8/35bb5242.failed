net/mlx5e: Move goto action checks into tc_action goto post parse op

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 35bb5242148fa16fd5b2f28b508e0c031e90c672
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/35bb5242.failed

Move goto action checks from parse nic/fdb funcs into the tc action
infra goto post parse op.
While moving this part also use NL_SET_ERR_MSG_MOD() instead of
NL_SET_ERR_MSG().

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 35bb5242148fa16fd5b2f28b508e0c031e90c672)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index abcf89c03680,eec919f1b476..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -3491,116 -3230,17 +3491,111 @@@ parse_tc_nic_actions(struct mlx5e_priv 
  	if (err)
  		return err;
  
 -	attr->nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
 +	nic_attr = attr->nic_attr;
 +	nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
  	parse_attr = attr->parse_attr;
 -	parse_state = &parse_attr->parse_state;
 -	mlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);
 -	parse_state->ct_priv = get_ct_priv(priv);
 -	hdrs = parse_state->hdrs;
  
 -	err = parse_tc_actions(parse_state, flow_action);
 -	if (err)
 -		return err;
 +	flow_action_for_each(i, act, flow_action) {
 +		switch (act->id) {
 +		case FLOW_ACTION_ACCEPT:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_KERNEL,
 +						    parse_attr, hdrs, NULL, extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_KERNEL,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags,
 +						   extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
 +		case FLOW_ACTION_REDIRECT: {
 +			struct net_device *peer_dev = act->dev;
 +
 +			if (priv->netdev->netdev_ops == peer_dev->netdev_ops &&
 +			    same_hw_devs(priv, netdev_priv(peer_dev))) {
 +				parse_attr->mirred_ifindex[0] = peer_dev->ifindex;
 +				flow_flag_set(flow, HAIRPIN);
 +				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "device is not on same HW, can't offload");
 +				netdev_warn(priv->netdev, "device %s not on same HW, can't offload\n",
 +					    peer_dev->name);
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_MARK: {
 +			u32 mark = act->mark;
 +
 +			if (mark & ~MLX5E_TC_FLOW_ID_MASK) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Bad flow mark - only 16 bit is supported");
 +				return -EINVAL;
 +			}
 +
 +			nic_attr->flow_tag = mark;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 +			}
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
 +			break;
 +		case FLOW_ACTION_CT:
 +			clear_action = act->ct.action & TCA_CT_ACT_CLEAR;
 +
 +			/* It's redundant to do ct clear more than once. */
 +			if (clear_action && attr->ct_clear)
 +				break;
 +
 +			err = mlx5_tc_ct_parse_action(get_ct_priv(priv), attr,
 +						      &parse_attr->mod_hdr_acts,
 +						      act, extack);
 +			if (err)
 +				return err;
 +
 +			flow_flag_set(flow, CT);
 +			attr->ct_clear = clear_action;
 +			break;
 +		default:
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "The offload action is not supported in NIC action");
 +			return -EOPNOTSUPP;
 +		}
 +	}
 +
 +	attr->action = action;
  
- 	if (attr->dest_chain && parse_attr->mirred_ifindex[0]) {
- 		NL_SET_ERR_MSG(extack, "Mirroring goto chain rules isn't supported");
- 		return -EOPNOTSUPP;
- 	}
- 
  	err = actions_prepare_mod_hdr_actions(priv, flow, attr, hdrs, extack);
  	if (err)
  		return err;
@@@ -4295,30 -3379,6 +4290,33 @@@ static int parse_tc_fdb_actions(struct 
  	if (!actions_match_supported(priv, flow_action, parse_attr, flow, extack))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (attr->dest_chain && decap) {
 +		/* It can be supported if we'll create a mapping for
 +		 * the tunnel device only (without tunnel), and set
 +		 * this tunnel id with this decap flow.
 +		 *
 +		 * On restore (miss), we'll just set this saved tunnel
 +		 * device.
 +		 */
 +
 +		NL_SET_ERR_MSG(extack, "Decap with goto isn't supported");
 +		netdev_warn(priv->netdev, "Decap with goto isn't supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	/* Allocate sample attribute only when there is a sample action and
 +	 * no errors after parsing.
 +	 */
 +	if (flow_flag_test(flow, SAMPLE)) {
 +		attr->sample_attr = kzalloc(sizeof(*attr->sample_attr), GFP_KERNEL);
 +		if (!attr->sample_attr)
 +			return -ENOMEM;
 +		*attr->sample_attr = sample_attr;
 +	}
 +
++=======
++>>>>>>> 35bb5242148f (net/mlx5e: Move goto action checks into tc_action goto post parse op)
  	return 0;
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
