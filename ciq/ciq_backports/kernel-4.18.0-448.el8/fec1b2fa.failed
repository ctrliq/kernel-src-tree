scsi: target: iscsi: Fix a race condition between login_work and the login thread

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Maurizio Lombardi <mlombard@redhat.com>
commit fec1b2fa62c162d03f5dcd7b03e3c89d3116d49f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/fec1b2fa.failed

In case a malicious initiator sends some random data immediately after a
login PDU; the iscsi_target_sk_data_ready() callback will schedule the
login_work and, at the same time, the negotiation may end without clearing
the LOGIN_FLAGS_INITIAL_PDU flag (because no additional PDU exchanges are
required to complete the login).

The login has been completed but the login_work function will find the
LOGIN_FLAGS_INITIAL_PDU flag set and will never stop from rescheduling
itself; at this point, if the initiator drops the connection, the
iscsit_conn structure will be freed, login_work will dereference a released
socket structure and the kernel crashes.

BUG: kernel NULL pointer dereference, address: 0000000000000230
PF: supervisor write access in kernel mode
PF: error_code(0x0002) - not-present page
Workqueue: events iscsi_target_do_login_rx [iscsi_target_mod]
RIP: 0010:_raw_read_lock_bh+0x15/0x30
Call trace:
 iscsi_target_do_login_rx+0x75/0x3f0 [iscsi_target_mod]
 process_one_work+0x1e8/0x3c0

Fix this bug by forcing login_work to stop after the login has been
completed and the socket callbacks have been restored.

Add a comment to clearify the return values of iscsi_target_do_login()

	Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
Link: https://lore.kernel.org/r/20221115125638.102517-1-mlombard@redhat.com
	Reviewed-by: Mike Christie <michael.christie@oracle.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit fec1b2fa62c162d03f5dcd7b03e3c89d3116d49f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target_nego.c
diff --cc drivers/target/iscsi/iscsi_target_nego.c
index 41f009fad63c,ff49c8f3fe24..000000000000
--- a/drivers/target/iscsi/iscsi_target_nego.c
+++ b/drivers/target/iscsi/iscsi_target_nego.c
@@@ -976,7 -1018,14 +976,18 @@@ static int iscsi_target_handle_csg_one(
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int iscsi_target_do_login(struct iscsi_conn *conn, struct iscsi_login *login)
++=======
+ /*
+  * RETURN VALUE:
+  *
+  *  1 = Login successful
+  * -1 = Login failed
+  *  0 = More PDU exchanges required
+  */
+ static int iscsi_target_do_login(struct iscsit_conn *conn, struct iscsi_login *login)
++>>>>>>> fec1b2fa62c1 (scsi: target: iscsi: Fix a race condition between login_work and the login thread)
  {
  	int pdu_count = 0;
  	struct iscsi_login_req *login_req;
* Unmerged path drivers/target/iscsi/iscsi_target_nego.c
