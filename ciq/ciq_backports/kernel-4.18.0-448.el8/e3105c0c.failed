ASoC: SOF: Intel: HDA: Set IPC4-specific DSP ops for CaVS platforms

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit e3105c0ccc3e706584030159b6fde54cab2f8aef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/e3105c0c.failed

Add implementation of low level, platform dependent IPC4 message handling
and set the DSP ops for IPC4 for APL, CNL and TGL platforms.

Co-developed-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Link: https://lore.kernel.org/r/20220511171648.1622993-2-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit e3105c0ccc3e706584030159b6fde54cab2f8aef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/apl.c
#	sound/soc/sof/intel/cnl.c
#	sound/soc/sof/intel/hda.h
#	sound/soc/sof/intel/tgl.c
diff --cc sound/soc/sof/intel/apl.c
index 4dc643dd7756,4c67110a073e..000000000000
--- a/sound/soc/sof/intel/apl.c
+++ b/sound/soc/sof/intel/apl.c
@@@ -26,113 -26,52 +26,130 @@@ static const struct snd_sof_debugfs_ma
  };
  
  /* apollolake ops */
 -struct snd_sof_dsp_ops sof_apl_ops;
 -EXPORT_SYMBOL_NS(sof_apl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);
 -
 -int sof_apl_ops_init(struct snd_sof_dev *sdev)
 -{
 -	/* common defaults */
 -	memcpy(&sof_apl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));
 -
 +struct snd_sof_dsp_ops sof_apl_ops = {
  	/* probe/remove/shutdown */
 -	sof_apl_ops.shutdown	= hda_dsp_shutdown;
 -
 +	.probe		= hda_dsp_probe,
 +	.remove		= hda_dsp_remove,
 +	.shutdown	= hda_dsp_shutdown,
 +
 +	/* Register IO */
 +	.write		= sof_io_write,
 +	.read		= sof_io_read,
 +	.write64	= sof_io_write64,
 +	.read64		= sof_io_read64,
 +
 +	/* Block IO */
 +	.block_read	= sof_block_read,
 +	.block_write	= sof_block_write,
 +
 +	/* Mailbox IO */
 +	.mailbox_read	= sof_mailbox_read,
 +	.mailbox_write	= sof_mailbox_write,
 +
++<<<<<<< HEAD
 +	/* doorbell */
 +	.irq_thread	= hda_dsp_ipc_irq_thread,
 +
 +	/* ipc */
 +	.send_msg	= hda_dsp_ipc_send_msg,
 +	.fw_ready	= sof_fw_ready,
 +	.get_mailbox_offset = hda_dsp_ipc_get_mailbox_offset,
 +	.get_window_offset = hda_dsp_ipc_get_window_offset,
++=======
+ 	if (sdev->pdata->ipc_type == SOF_IPC) {
+ 		/* doorbell */
+ 		sof_apl_ops.irq_thread	= hda_dsp_ipc_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_apl_ops.send_msg	= hda_dsp_ipc_send_msg;
+ 	}
+ 
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		sof_apl_ops.irq_thread	= hda_dsp_ipc4_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_apl_ops.send_msg	= hda_dsp_ipc4_send_msg;
+ 	}
++>>>>>>> e3105c0ccc3e (ASoC: SOF: Intel: HDA: Set IPC4-specific DSP ops for CaVS platforms)
  
 -	/* set DAI driver ops */
 -	hda_set_dai_drv_ops(sdev, &sof_apl_ops);
 +	.ipc_msg_data	= hda_ipc_msg_data,
 +	.set_stream_data_offset = hda_set_stream_data_offset,
 +
 +	/* machine driver */
 +	.machine_select = hda_machine_select,
 +	.machine_register = sof_machine_register,
 +	.machine_unregister = sof_machine_unregister,
 +	.set_mach_params = hda_set_mach_params,
  
  	/* debug */
 -	sof_apl_ops.debug_map	= apl_dsp_debugfs;
 -	sof_apl_ops.debug_map_count	= ARRAY_SIZE(apl_dsp_debugfs);
 -	sof_apl_ops.ipc_dump	= hda_ipc_dump;
 +	.debug_map	= apl_dsp_debugfs,
 +	.debug_map_count	= ARRAY_SIZE(apl_dsp_debugfs),
 +	.dbg_dump	= hda_dsp_dump,
 +	.ipc_dump	= hda_ipc_dump,
 +	.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,
 +
 +	/* stream callbacks */
 +	.pcm_open	= hda_dsp_pcm_open,
 +	.pcm_close	= hda_dsp_pcm_close,
 +	.pcm_hw_params	= hda_dsp_pcm_hw_params,
 +	.pcm_hw_free	= hda_dsp_stream_hw_free,
 +	.pcm_trigger	= hda_dsp_pcm_trigger,
 +	.pcm_pointer	= hda_dsp_pcm_pointer,
 +	.pcm_ack	= hda_dsp_pcm_ack,
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_PROBES)
 +	/* probe callbacks */
 +	.probe_assign	= hda_probe_compr_assign,
 +	.probe_free	= hda_probe_compr_free,
 +	.probe_set_params	= hda_probe_compr_set_params,
 +	.probe_trigger	= hda_probe_compr_trigger,
 +	.probe_pointer	= hda_probe_compr_pointer,
 +#endif
 +
 +	/* firmware loading */
 +	.load_firmware = snd_sof_load_firmware_raw,
  
  	/* firmware run */
 -	sof_apl_ops.run = hda_dsp_cl_boot_firmware;
 +	.run = hda_dsp_cl_boot_firmware,
  
  	/* pre/post fw run */
 -	sof_apl_ops.post_fw_run = hda_dsp_post_fw_run;
 +	.pre_fw_run = hda_dsp_pre_fw_run,
 +	.post_fw_run = hda_dsp_post_fw_run,
  
 -	/* dsp core get/put */
 -	sof_apl_ops.core_get = hda_dsp_core_get;
 +	/* parse platform specific extended manifest */
 +	.parse_platform_ext_manifest = hda_dsp_ext_man_get_cavs_config_data,
  
 -	return 0;
 +	/* dsp core get/put */
 +	.core_get = hda_dsp_core_get,
 +
 +	/* trace callback */
 +	.trace_init = hda_dsp_trace_init,
 +	.trace_release = hda_dsp_trace_release,
 +	.trace_trigger = hda_dsp_trace_trigger,
 +
 +	/* DAI drivers */
 +	.drv		= skl_dai,
 +	.num_drv	= SOF_SKL_NUM_DAIS,
 +
 +	/* PM */
 +	.suspend		= hda_dsp_suspend,
 +	.resume			= hda_dsp_resume,
 +	.runtime_suspend	= hda_dsp_runtime_suspend,
 +	.runtime_resume		= hda_dsp_runtime_resume,
 +	.runtime_idle		= hda_dsp_runtime_idle,
 +	.set_hw_params_upon_resume = hda_dsp_set_hw_params_upon_resume,
 +	.set_power_state	= hda_dsp_set_power_state,
 +
 +	/* ALSA HW info flags */
 +	.hw_info =	SNDRV_PCM_INFO_MMAP |
 +			SNDRV_PCM_INFO_MMAP_VALID |
 +			SNDRV_PCM_INFO_INTERLEAVED |
 +			SNDRV_PCM_INFO_PAUSE |
 +			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
 +
 +	.dsp_arch_ops = &sof_xtensa_arch_ops,
  };
 -EXPORT_SYMBOL_NS(sof_apl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);
 +EXPORT_SYMBOL(sof_apl_ops);
  
  const struct sof_intel_dsp_desc apl_chip_info = {
  	/* Apollolake */
diff --cc sound/soc/sof/intel/cnl.c
index 7477c9aee374,7a22d7e4a46c..000000000000
--- a/sound/soc/sof/intel/cnl.c
+++ b/sound/soc/sof/intel/cnl.c
@@@ -244,113 -323,53 +323,131 @@@ void cnl_ipc_dump(struct snd_sof_dev *s
  }
  
  /* cannonlake ops */
 -struct snd_sof_dsp_ops sof_cnl_ops;
 -EXPORT_SYMBOL_NS(sof_cnl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);
 +struct snd_sof_dsp_ops sof_cnl_ops = {
 +	/* probe/remove/shutdown */
 +	.probe		= hda_dsp_probe,
 +	.remove		= hda_dsp_remove,
 +	.shutdown	= hda_dsp_shutdown,
  
 -int sof_cnl_ops_init(struct snd_sof_dev *sdev)
 -{
 -	/* common defaults */
 -	memcpy(&sof_cnl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));
 +	/* Register IO */
 +	.write		= sof_io_write,
 +	.read		= sof_io_read,
 +	.write64	= sof_io_write64,
 +	.read64		= sof_io_read64,
  
 -	/* probe/remove/shutdown */
 -	sof_cnl_ops.shutdown	= hda_dsp_shutdown;
 +	/* Block IO */
 +	.block_read	= sof_block_read,
 +	.block_write	= sof_block_write,
 +
 +	/* Mailbox IO */
 +	.mailbox_read	= sof_mailbox_read,
 +	.mailbox_write	= sof_mailbox_write,
 +
++<<<<<<< HEAD
 +	/* doorbell */
 +	.irq_thread	= cnl_ipc_irq_thread,
  
 +	/* ipc */
 +	.send_msg	= cnl_ipc_send_msg,
 +	.fw_ready	= sof_fw_ready,
 +	.get_mailbox_offset = hda_dsp_ipc_get_mailbox_offset,
 +	.get_window_offset = hda_dsp_ipc_get_window_offset,
++=======
+ 	/* ipc */
+ 	if (sdev->pdata->ipc_type == SOF_IPC) {
+ 		/* doorbell */
+ 		sof_cnl_ops.irq_thread	= cnl_ipc_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_cnl_ops.send_msg	= cnl_ipc_send_msg;
+ 	}
+ 
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		sof_cnl_ops.irq_thread	= cnl_ipc4_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_cnl_ops.send_msg	= cnl_ipc4_send_msg;
+ 	}
++>>>>>>> e3105c0ccc3e (ASoC: SOF: Intel: HDA: Set IPC4-specific DSP ops for CaVS platforms)
 +
 +	.ipc_msg_data	= hda_ipc_msg_data,
 +	.set_stream_data_offset = hda_set_stream_data_offset,
  
 -	/* set DAI driver ops */
 -	hda_set_dai_drv_ops(sdev, &sof_cnl_ops);
 +	/* machine driver */
 +	.machine_select = hda_machine_select,
 +	.machine_register = sof_machine_register,
 +	.machine_unregister = sof_machine_unregister,
 +	.set_mach_params = hda_set_mach_params,
  
  	/* debug */
 -	sof_cnl_ops.debug_map	= cnl_dsp_debugfs;
 -	sof_cnl_ops.debug_map_count	= ARRAY_SIZE(cnl_dsp_debugfs);
 -	sof_cnl_ops.ipc_dump	= cnl_ipc_dump;
 +	.debug_map	= cnl_dsp_debugfs,
 +	.debug_map_count	= ARRAY_SIZE(cnl_dsp_debugfs),
 +	.dbg_dump	= hda_dsp_dump,
 +	.ipc_dump	= cnl_ipc_dump,
 +	.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,
 +
 +	/* stream callbacks */
 +	.pcm_open	= hda_dsp_pcm_open,
 +	.pcm_close	= hda_dsp_pcm_close,
 +	.pcm_hw_params	= hda_dsp_pcm_hw_params,
 +	.pcm_hw_free	= hda_dsp_stream_hw_free,
 +	.pcm_trigger	= hda_dsp_pcm_trigger,
 +	.pcm_pointer	= hda_dsp_pcm_pointer,
 +	.pcm_ack	= hda_dsp_pcm_ack,
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_PROBES)
 +	/* probe callbacks */
 +	.probe_assign	= hda_probe_compr_assign,
 +	.probe_free	= hda_probe_compr_free,
 +	.probe_set_params	= hda_probe_compr_set_params,
 +	.probe_trigger	= hda_probe_compr_trigger,
 +	.probe_pointer	= hda_probe_compr_pointer,
 +#endif
 +
 +	/* firmware loading */
 +	.load_firmware = snd_sof_load_firmware_raw,
  
  	/* pre/post fw run */
 -	sof_cnl_ops.post_fw_run = hda_dsp_post_fw_run;
 +	.pre_fw_run = hda_dsp_pre_fw_run,
 +	.post_fw_run = hda_dsp_post_fw_run,
  
 -	/* firmware run */
 -	sof_cnl_ops.run = hda_dsp_cl_boot_firmware;
 +	/* parse platform specific extended manifest */
 +	.parse_platform_ext_manifest = hda_dsp_ext_man_get_cavs_config_data,
  
  	/* dsp core get/put */
 -	sof_cnl_ops.core_get = hda_dsp_core_get;
 +	.core_get = hda_dsp_core_get,
  
 -	return 0;
 +	/* firmware run */
 +	.run = hda_dsp_cl_boot_firmware,
 +
 +	/* trace callback */
 +	.trace_init = hda_dsp_trace_init,
 +	.trace_release = hda_dsp_trace_release,
 +	.trace_trigger = hda_dsp_trace_trigger,
 +
 +	/* DAI drivers */
 +	.drv		= skl_dai,
 +	.num_drv	= SOF_SKL_NUM_DAIS,
 +
 +	/* PM */
 +	.suspend		= hda_dsp_suspend,
 +	.resume			= hda_dsp_resume,
 +	.runtime_suspend	= hda_dsp_runtime_suspend,
 +	.runtime_resume		= hda_dsp_runtime_resume,
 +	.runtime_idle		= hda_dsp_runtime_idle,
 +	.set_hw_params_upon_resume = hda_dsp_set_hw_params_upon_resume,
 +	.set_power_state	= hda_dsp_set_power_state,
 +
 +	/* ALSA HW info flags */
 +	.hw_info =	SNDRV_PCM_INFO_MMAP |
 +			SNDRV_PCM_INFO_MMAP_VALID |
 +			SNDRV_PCM_INFO_INTERLEAVED |
 +			SNDRV_PCM_INFO_PAUSE |
 +			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
 +
 +	.dsp_arch_ops = &sof_xtensa_arch_ops,
  };
 -EXPORT_SYMBOL_NS(sof_cnl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);
 +EXPORT_SYMBOL(sof_cnl_ops);
  
  const struct sof_intel_dsp_desc cnl_chip_info = {
  	/* Cannonlake */
diff --cc sound/soc/sof/intel/hda.h
index 1ed56c3ec7e2,535791c7d187..000000000000
--- a/sound/soc/sof/intel/hda.h
+++ b/sound/soc/sof/intel/hda.h
@@@ -763,4 -762,12 +763,15 @@@ int hda_ctrl_dai_widget_free(struct snd
  
  extern int sof_hda_position_quirk;
  
++<<<<<<< HEAD
++=======
+ void hda_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops);
+ 
+ /* IPC4 */
+ irqreturn_t cnl_ipc4_irq_thread(int irq, void *context);
+ int cnl_ipc4_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg);
+ irqreturn_t hda_dsp_ipc4_irq_thread(int irq, void *context);
+ int hda_dsp_ipc4_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg);
+ 
++>>>>>>> e3105c0ccc3e (ASoC: SOF: Intel: HDA: Set IPC4-specific DSP ops for CaVS platforms)
  #endif
diff --cc sound/soc/sof/intel/tgl.c
index fceb528ed5d9,c93526591a91..000000000000
--- a/sound/soc/sof/intel/tgl.c
+++ b/sound/soc/sof/intel/tgl.c
@@@ -61,114 -59,54 +61,132 @@@ static int tgl_dsp_core_put(struct snd_
  }
  
  /* Tigerlake ops */
 -struct snd_sof_dsp_ops sof_tgl_ops;
 -EXPORT_SYMBOL_NS(sof_tgl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);
 +struct snd_sof_dsp_ops sof_tgl_ops = {
 +	/* probe/remove/shutdown */
 +	.probe		= hda_dsp_probe,
 +	.remove		= hda_dsp_remove,
 +	.shutdown	= hda_dsp_shutdown,
  
 -int sof_tgl_ops_init(struct snd_sof_dev *sdev)
 -{
 -	/* common defaults */
 -	memcpy(&sof_tgl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));
 +	/* Register IO */
 +	.write		= sof_io_write,
 +	.read		= sof_io_read,
 +	.write64	= sof_io_write64,
 +	.read64		= sof_io_read64,
  
 -	/* probe/remove/shutdown */
 -	sof_tgl_ops.shutdown	= hda_dsp_shutdown;
 +	/* Block IO */
 +	.block_read	= sof_block_read,
 +	.block_write	= sof_block_write,
 +
 +	/* Mailbox IO */
 +	.mailbox_read	= sof_mailbox_read,
 +	.mailbox_write	= sof_mailbox_write,
  
++<<<<<<< HEAD
 +	/* doorbell */
 +	.irq_thread	= cnl_ipc_irq_thread,
 +
 +	/* ipc */
 +	.send_msg	= cnl_ipc_send_msg,
 +	.fw_ready	= sof_fw_ready,
 +	.get_mailbox_offset = hda_dsp_ipc_get_mailbox_offset,
 +	.get_window_offset = hda_dsp_ipc_get_window_offset,
++=======
+ 	if (sdev->pdata->ipc_type == SOF_IPC) {
+ 		/* doorbell */
+ 		sof_tgl_ops.irq_thread	= cnl_ipc_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_tgl_ops.send_msg	= cnl_ipc_send_msg;
+ 	}
+ 
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		/* doorbell */
+ 		sof_tgl_ops.irq_thread	= cnl_ipc4_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_tgl_ops.send_msg	= cnl_ipc4_send_msg;
+ 	}
++>>>>>>> e3105c0ccc3e (ASoC: SOF: Intel: HDA: Set IPC4-specific DSP ops for CaVS platforms)
 +
 +	.ipc_msg_data	= hda_ipc_msg_data,
 +	.set_stream_data_offset = hda_set_stream_data_offset,
  
 -	/* set DAI driver ops */
 -	hda_set_dai_drv_ops(sdev, &sof_tgl_ops);
 +	/* machine driver */
 +	.machine_select = hda_machine_select,
 +	.machine_register = sof_machine_register,
 +	.machine_unregister = sof_machine_unregister,
 +	.set_mach_params = hda_set_mach_params,
  
  	/* debug */
 -	sof_tgl_ops.debug_map	= tgl_dsp_debugfs;
 -	sof_tgl_ops.debug_map_count	= ARRAY_SIZE(tgl_dsp_debugfs);
 -	sof_tgl_ops.ipc_dump	= cnl_ipc_dump;
 +	.debug_map	= tgl_dsp_debugfs,
 +	.debug_map_count	= ARRAY_SIZE(tgl_dsp_debugfs),
 +	.dbg_dump	= hda_dsp_dump,
 +	.ipc_dump	= cnl_ipc_dump,
 +	.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,
 +
 +	/* stream callbacks */
 +	.pcm_open	= hda_dsp_pcm_open,
 +	.pcm_close	= hda_dsp_pcm_close,
 +	.pcm_hw_params	= hda_dsp_pcm_hw_params,
 +	.pcm_hw_free	= hda_dsp_stream_hw_free,
 +	.pcm_trigger	= hda_dsp_pcm_trigger,
 +	.pcm_pointer	= hda_dsp_pcm_pointer,
 +	.pcm_ack	= hda_dsp_pcm_ack,
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_PROBES)
 +	/* probe callbacks */
 +	.probe_assign	= hda_probe_compr_assign,
 +	.probe_free	= hda_probe_compr_free,
 +	.probe_set_params	= hda_probe_compr_set_params,
 +	.probe_trigger	= hda_probe_compr_trigger,
 +	.probe_pointer	= hda_probe_compr_pointer,
 +#endif
 +
 +	/* firmware loading */
 +	.load_firmware = snd_sof_load_firmware_raw,
  
  	/* pre/post fw run */
 -	sof_tgl_ops.post_fw_run = hda_dsp_post_fw_run;
 +	.pre_fw_run = hda_dsp_pre_fw_run,
 +	.post_fw_run = hda_dsp_post_fw_run,
  
 -	/* firmware run */
 -	sof_tgl_ops.run = hda_dsp_cl_boot_firmware_iccmax;
 +	/* parse platform specific extended manifest */
 +	.parse_platform_ext_manifest = hda_dsp_ext_man_get_cavs_config_data,
  
  	/* dsp core get/put */
 -	sof_tgl_ops.core_get = tgl_dsp_core_get;
 -	sof_tgl_ops.core_put = tgl_dsp_core_put;
 +	.core_get = tgl_dsp_core_get,
 +	.core_put = tgl_dsp_core_put,
 +
 +	/* firmware run */
 +	.run = hda_dsp_cl_boot_firmware_iccmax,
 +
 +	/* trace callback */
 +	.trace_init = hda_dsp_trace_init,
 +	.trace_release = hda_dsp_trace_release,
 +	.trace_trigger = hda_dsp_trace_trigger,
 +
 +	/* DAI drivers */
 +	.drv		= skl_dai,
 +	.num_drv	= SOF_SKL_NUM_DAIS,
 +
 +	/* PM */
 +	.suspend		= hda_dsp_suspend,
 +	.resume			= hda_dsp_resume,
 +	.runtime_suspend	= hda_dsp_runtime_suspend,
 +	.runtime_resume		= hda_dsp_runtime_resume,
 +	.runtime_idle		= hda_dsp_runtime_idle,
 +	.set_hw_params_upon_resume = hda_dsp_set_hw_params_upon_resume,
 +	.set_power_state	= hda_dsp_set_power_state,
 +
 +	/* ALSA HW info flags */
 +	.hw_info =	SNDRV_PCM_INFO_MMAP |
 +			SNDRV_PCM_INFO_MMAP_VALID |
 +			SNDRV_PCM_INFO_INTERLEAVED |
 +			SNDRV_PCM_INFO_PAUSE |
 +			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
  
 -	return 0;
 +	.dsp_arch_ops = &sof_xtensa_arch_ops,
  };
 -EXPORT_SYMBOL_NS(sof_tgl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);
 +EXPORT_SYMBOL(sof_tgl_ops);
  
  const struct sof_intel_dsp_desc tgl_chip_info = {
  	/* Tigerlake , Alderlake */
* Unmerged path sound/soc/sof/intel/apl.c
* Unmerged path sound/soc/sof/intel/cnl.c
diff --git a/sound/soc/sof/intel/hda-ipc.c b/sound/soc/sof/intel/hda-ipc.c
index 0395638c43ae..f08011249955 100644
--- a/sound/soc/sof/intel/hda-ipc.c
+++ b/sound/soc/sof/intel/hda-ipc.c
@@ -15,6 +15,7 @@
  * Hardware interface for generic Intel audio DSP HDA IP
  */
 
+#include <sound/sof/ipc4/header.h>
 #include "../ops.h"
 #include "hda.h"
 
@@ -65,6 +66,22 @@ int hda_dsp_ipc_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
 	return 0;
 }
 
+int hda_dsp_ipc4_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)
+{
+	struct sof_ipc4_msg *msg_data = msg->msg_data;
+
+	/* send the message via mailbox */
+	if (msg_data->data_size)
+		sof_mailbox_write(sdev, sdev->host_box.offset, msg_data->data_ptr,
+				  msg_data->data_size);
+
+	snd_sof_dsp_write(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE, msg_data->extension);
+	snd_sof_dsp_write(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCI,
+			  msg_data->primary | HDA_DSP_REG_HIPCI_BUSY);
+
+	return 0;
+}
+
 void hda_dsp_ipc_get_reply(struct snd_sof_dev *sdev)
 {
 	struct snd_sof_ipc_msg *msg = sdev->msg;
@@ -100,6 +117,71 @@ void hda_dsp_ipc_get_reply(struct snd_sof_dev *sdev)
 	}
 }
 
+irqreturn_t hda_dsp_ipc4_irq_thread(int irq, void *context)
+{
+	struct sof_ipc4_msg notification_data = {{ 0 }};
+	struct snd_sof_dev *sdev = context;
+	bool ipc_irq = false;
+	u32 hipcie, hipct;
+
+	hipcie = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE);
+	if (hipcie & HDA_DSP_REG_HIPCIE_DONE) {
+		/* DSP received the message */
+		snd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL,
+					HDA_DSP_REG_HIPCCTL_DONE, 0);
+		hda_dsp_ipc_dsp_done(sdev);
+
+		ipc_irq = true;
+	}
+
+	hipct = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCT);
+	if (hipct & HDA_DSP_REG_HIPCT_BUSY) {
+		/* Message from DSP (reply or notification) */
+		u32 hipcte = snd_sof_dsp_read(sdev, HDA_DSP_BAR,
+					      HDA_DSP_REG_HIPCTE);
+		u32 primary = hipct & HDA_DSP_REG_HIPCT_MSG_MASK;
+		u32 extension = hipcte & HDA_DSP_REG_HIPCTE_MSG_MASK;
+
+		/* mask BUSY interrupt */
+		snd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL,
+					HDA_DSP_REG_HIPCCTL_BUSY, 0);
+
+		if (primary & SOF_IPC4_MSG_DIR_MASK) {
+			/* Reply received */
+			struct sof_ipc4_msg *data = sdev->ipc->msg.reply_data;
+
+			data->primary = primary;
+			data->extension = extension;
+
+			spin_lock_irq(&sdev->ipc_lock);
+
+			snd_sof_ipc_get_reply(sdev);
+			snd_sof_ipc_reply(sdev, data->primary);
+
+			spin_unlock_irq(&sdev->ipc_lock);
+		} else {
+			/* Notification received */
+
+			notification_data.primary = primary;
+			notification_data.extension = extension;
+			sdev->ipc->msg.rx_data = &notification_data;
+			snd_sof_ipc_msgs_rx(sdev);
+			sdev->ipc->msg.rx_data = NULL;
+		}
+
+		/* Let DSP know that we have finished processing the message */
+		hda_dsp_ipc_host_done(sdev);
+
+		ipc_irq = true;
+	}
+
+	if (!ipc_irq)
+		/* This interrupt is not shared so no need to return IRQ_NONE. */
+		dev_dbg_ratelimited(sdev->dev, "nothing to do in IPC IRQ thread\n");
+
+	return IRQ_HANDLED;
+}
+
 /* IPC handler thread */
 irqreturn_t hda_dsp_ipc_irq_thread(int irq, void *context)
 {
* Unmerged path sound/soc/sof/intel/hda.h
* Unmerged path sound/soc/sof/intel/tgl.c
