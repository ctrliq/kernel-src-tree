NFS: Trigger the "ls -l" readdir heuristic sooner

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Benjamin Coddington <bcodding@redhat.com>
commit 85aa8ddc3818718208c3cfdfda9c8c908c9dead1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/85aa8ddc.failed

Since commit 1a34c8c9a49e ("NFS: Support larger readdir buffers") has
updated dtsize, and with recent improvements to the READDIRPLUS helper
heuristic, the heuristic may not trigger until many dentries are emitted
to userspace.   This will cause many thousands of GETATTR calls for "ls
-l" when the directory's pagecache has already been populated.  This
manifests as poor performance for long directory listings after an
initially fast "ls -l".

Fix this by emitting only 17 entries for any first pass through the NFS
directory's ->iterate_shared(), which allows userpace to prime the
counters for the heuristic.

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 85aa8ddc3818718208c3cfdfda9c8c908c9dead1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/dir.c
diff --cc fs/nfs/dir.c
index ce0607cf0a27,ea1ceffa1d3a..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -1002,8 -1085,9 +1004,9 @@@ static void nfs_do_filldir(struct nfs_r
  	struct file	*file = desc->file;
  	struct nfs_cache_array *array;
  	unsigned int i;
+ 	bool first_emit = !desc->dir_cookie;
  
 -	array = kmap_local_page(desc->page);
 +	array = kmap(desc->page);
  	for (i = desc->cache_entry_index; i < array->size; i++) {
  		struct nfs_cache_array_entry *ent;
  
@@@ -1025,8 -1109,10 +1028,15 @@@
  			desc->ctx->pos = desc->dir_cookie;
  		else
  			desc->ctx->pos++;
++<<<<<<< HEAD
 +		if (desc->duped != 0)
 +			desc->duped = 1;
++=======
+ 		if (first_emit && i > NFS_READDIR_CACHE_MISS_THRESHOLD + 1) {
+ 			desc->eob = true;
+ 			break;
+ 		}
++>>>>>>> 85aa8ddc3818 (NFS: Trigger the "ls -l" readdir heuristic sooner)
  	}
  	if (array->page_is_eof)
  		desc->eof = !desc->eob;
@@@ -1087,6 -1194,19 +1097,22 @@@ out
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ static bool nfs_readdir_handle_cache_misses(struct inode *inode,
+ 					    struct nfs_readdir_descriptor *desc,
+ 					    unsigned int cache_misses,
+ 					    bool force_clear)
+ {
+ 	if (desc->ctx->pos == 0 || !desc->plus)
+ 		return false;
+ 	if (cache_misses <= NFS_READDIR_CACHE_MISS_THRESHOLD && !force_clear)
+ 		return false;
+ 	trace_nfs_readdir_force_readdirplus(inode);
+ 	return true;
+ }
+ 
++>>>>>>> 85aa8ddc3818 (NFS: Trigger the "ls -l" readdir heuristic sooner)
  /* The file offset position represents the dirent entry number.  A
     last cookie cache takes care of the common case of reading the
     whole directory.
* Unmerged path fs/nfs/dir.c
