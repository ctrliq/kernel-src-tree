scsi: mpi3mr: Enable STL on HBAs where multipath is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit c4723e68a0d816f23e0807908cdb66e67528594f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c4723e68.failed

Register the SAS, SATA devices to SCSI Transport Layer (STL) only if
multipath capability is disabled in the controller's firmware.

Link: https://lore.kernel.org/r/20220804131226.16653-9-sreekanth.reddy@broadcom.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c4723e68a0d816f23e0807908cdb66e67528594f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_os.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 8de3e5650c79,8c8703efbe15..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -490,8 -649,13 +490,14 @@@ union _form_spec_inf 
   * @dev_type: SAS/SATA/PCIE device type
   * @is_hidden: Should be exposed to upper layers or not
   * @host_exposed: Already exposed to host or not
++<<<<<<< HEAD
++=======
+  * @io_unit_port: IO Unit port ID
+  * @non_stl: Is this device not to be attached with SAS TL
+  * @io_throttle_enabled: I/O throttling needed or not
++>>>>>>> c4723e68a0d8 (scsi: mpi3mr: Enable STL on HBAs where multipath is disabled)
   * @q_depth: Device specific Queue Depth
   * @wwid: World wide ID
 - * @enclosure_logical_id: Enclosure logical identifier
   * @dev_spec: Device type specific information
   * @ref_count: Reference count
   */
@@@ -506,8 -670,13 +512,14 @@@ struct mpi3mr_tgt_dev 
  	u8 dev_type;
  	u8 is_hidden;
  	u8 host_exposed;
++<<<<<<< HEAD
++=======
+ 	u8 io_unit_port;
+ 	u8 non_stl;
+ 	u8 io_throttle_enabled;
++>>>>>>> c4723e68a0d8 (scsi: mpi3mr: Enable STL on HBAs where multipath is disabled)
  	u16 q_depth;
  	u64 wwid;
 -	u64 enclosure_logical_id;
  	union _form_spec_inf dev_spec;
  	struct kref ref_count;
  };
@@@ -796,6 -987,21 +808,24 @@@ struct scmd_priv 
   * @logdata_buf: Circular buffer to store log data entries
   * @logdata_buf_idx: Index of entry in buffer to store
   * @logdata_entry_sz: log data entry size
++<<<<<<< HEAD
++=======
+  * @pend_large_data_sz: Counter to track pending large data
+  * @io_throttle_data_length: I/O size to track in 512b blocks
+  * @io_throttle_high: I/O size to start throttle in 512b blocks
+  * @io_throttle_low: I/O size to stop throttle in 512b blocks
+  * @num_io_throttle_group: Maximum number of throttle groups
+  * @throttle_groups: Pointer to throttle group info structures
+  * @cfg_page: Default memory for configuration pages
+  * @cfg_page_dma: Configuration page DMA address
+  * @cfg_page_sz: Default configuration page memory size
+  * @sas_transport_enabled: SAS transport enabled or not
+  * @sas_hba: SAS node for the controller
+  * @sas_expander_list: SAS node list of expanders
+  * @sas_node_lock: Lock to protect SAS node list
+  * @hba_port_table_list: List of HBA Ports
+  * @enclosure_list: List of Enclosure objects
++>>>>>>> c4723e68a0d8 (scsi: mpi3mr: Enable STL on HBAs where multipath is disabled)
   */
  struct mpi3mr_ioc {
  	struct list_head list;
@@@ -960,6 -1167,24 +990,27 @@@
  	u8 *logdata_buf;
  	u16 logdata_buf_idx;
  	u16 logdata_entry_sz;
++<<<<<<< HEAD
++=======
+ 
+ 	atomic_t pend_large_data_sz;
+ 	u32 io_throttle_data_length;
+ 	u32 io_throttle_high;
+ 	u32 io_throttle_low;
+ 	u16 num_io_throttle_group;
+ 	struct mpi3mr_throttle_group_info *throttle_groups;
+ 
+ 	void *cfg_page;
+ 	dma_addr_t cfg_page_dma;
+ 	u16 cfg_page_sz;
+ 
+ 	u8 sas_transport_enabled;
+ 	struct mpi3mr_sas_node sas_hba;
+ 	struct list_head sas_expander_list;
+ 	spinlock_t sas_node_lock;
+ 	struct list_head hba_port_table_list;
+ 	struct list_head enclosure_list;
++>>>>>>> c4723e68a0d8 (scsi: mpi3mr: Enable STL on HBAs where multipath is disabled)
  };
  
  /**
diff --cc drivers/scsi/mpi3mr/mpi3mr_os.c
index c851b53cb9f5,533fdf9385df..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@@ -1042,10 -1141,33 +1051,33 @@@ static void mpi3mr_update_tgtdev(struc
  	{
  		struct mpi3_device0_vd_format *vdinf =
  		    &dev_pg0->device_specific.vd_format;
 -		struct mpi3mr_throttle_group_info *tg = NULL;
 -		u16 vdinf_io_throttle_group =
 -		    le16_to_cpu(vdinf->io_throttle_group);
  
 -		tgtdev->dev_spec.vd_inf.state = vdinf->vd_state;
 +		tgtdev->dev_spec.vol_inf.state = vdinf->vd_state;
  		if (vdinf->vd_state == MPI3_DEVICE0_VD_STATE_OFFLINE)
  			tgtdev->is_hidden = 1;
++<<<<<<< HEAD
++=======
+ 		tgtdev->non_stl = 1;
+ 		tgtdev->dev_spec.vd_inf.tg_id = vdinf_io_throttle_group;
+ 		tgtdev->dev_spec.vd_inf.tg_high =
+ 		    le16_to_cpu(vdinf->io_throttle_group_high) * 2048;
+ 		tgtdev->dev_spec.vd_inf.tg_low =
+ 		    le16_to_cpu(vdinf->io_throttle_group_low) * 2048;
+ 		if (vdinf_io_throttle_group < mrioc->num_io_throttle_group) {
+ 			tg = mrioc->throttle_groups + vdinf_io_throttle_group;
+ 			tg->id = vdinf_io_throttle_group;
+ 			tg->high = tgtdev->dev_spec.vd_inf.tg_high;
+ 			tg->low = tgtdev->dev_spec.vd_inf.tg_low;
+ 			tg->qd_reduction =
+ 			    tgtdev->dev_spec.vd_inf.tg_qd_reduction;
+ 			if (is_added == true)
+ 				tg->fw_qd = tgtdev->q_depth;
+ 			tg->modified_qd = tgtdev->q_depth;
+ 		}
+ 		tgtdev->dev_spec.vd_inf.tg = tg;
+ 		if (scsi_tgt_priv_data)
+ 			scsi_tgt_priv_data->throttle_group = tg;
++>>>>>>> c4723e68a0d8 (scsi: mpi3mr: Enable STL on HBAs where multipath is disabled)
  		break;
  	}
  	default:
@@@ -1546,9 -1859,12 +1584,12 @@@ static int mpi3mr_create_tgtdev(struct 
  	u16 perst_id = 0;
  
  	perst_id = le16_to_cpu(dev_pg0->persistent_id);
+ 	if (perst_id == MPI3_DEVICE0_PERSISTENTID_INVALID)
+ 		return retval;
+ 
  	tgtdev = mpi3mr_get_tgtdev_by_perst_id(mrioc, perst_id);
  	if (tgtdev) {
 -		mpi3mr_update_tgtdev(mrioc, tgtdev, dev_pg0, true);
 +		mpi3mr_update_tgtdev(mrioc, tgtdev, dev_pg0);
  		mpi3mr_tgtdev_put(tgtdev);
  	} else {
  		tgtdev = mpi3mr_alloc_tgtdev();
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
diff --git a/drivers/scsi/mpi3mr/mpi3mr_fw.c b/drivers/scsi/mpi3mr/mpi3mr_fw.c
index a891e8c285f7..fd3d3dd8c4d2 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@ -1140,6 +1140,13 @@ mpi3mr_revalidate_factsdata(struct mpi3mr_ioc *mrioc)
 		return -EPERM;
 	}
 
+	if ((mrioc->sas_transport_enabled) && (mrioc->facts.ioc_capabilities &
+	    MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED))
+		ioc_err(mrioc,
+		    "critical error: multipath capability is enabled at the\n"
+		    "\tcontroller while sas transport support is enabled at the\n"
+		    "\tdriver, please reboot the system or reload the driver\n");
+
 	dev_handle_bitmap_sz = mrioc->facts.max_devhandle / 8;
 	if (mrioc->facts.max_devhandle % 8)
 		dev_handle_bitmap_sz++;
@@ -3433,6 +3440,7 @@ static const struct {
 	char *name;
 } mpi3mr_capabilities[] = {
 	{ MPI3_IOCFACTS_CAPABILITY_RAID_CAPABLE, "RAID" },
+	{ MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED, "MultiPath" },
 };
 
 /**
@@ -3709,6 +3717,11 @@ int mpi3mr_init_ioc(struct mpi3mr_ioc *mrioc)
 		mrioc->max_host_ios = min_t(int, mrioc->max_host_ios,
 		    MPI3MR_HOST_IOS_KDUMP);
 
+	if (!(mrioc->facts.ioc_capabilities &
+	    MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED)) {
+		mrioc->sas_transport_enabled = 1;
+	}
+
 	mrioc->reply_sz = mrioc->facts.reply_sz;
 
 	retval = mpi3mr_check_reset_dma_mask(mrioc);
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_os.c
