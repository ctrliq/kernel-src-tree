device property: Add iomap to fwnode operations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sakari Ailus <sakari.ailus@linux.intel.com>
commit 68b979d068d3d0dceb14c446f664433d96f20a7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/68b979d0.failed

Add iomap() fwnode operation to implement fwnode_iomap() through fwnode
operations, moving the code in fwnode_iomap() to OF framework.

Note that the IS_ENABLED(CONFIG_OF_ADDRESS) && is_of_node(fwnode) check is
needed for Sparc that has its own implementation of of_iomap anyway. Let
the pre-compiler to handle that check.

	Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 68b979d068d3d0dceb14c446f664433d96f20a7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/property.c
#	include/linux/fwnode.h
diff --cc drivers/of/property.c
index 1028b0a60417,ac2aa5221069..000000000000
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@@ -1355,11 -1461,20 +1355,24 @@@ static int of_link_property(struct devi
  		}
  		s++;
  	}
 -	return 0;
 +	return ret;
  }
  
++<<<<<<< HEAD
 +static int of_fwnode_add_links(struct fwnode_handle *fwnode,
 +			       struct device *dev)
++=======
+ static void __iomem *of_fwnode_iomap(struct fwnode_handle *fwnode, int index)
+ {
+ #ifdef CONFIG_OF_ADDRESS
+ 	return of_iomap(to_of_node(fwnode), index);
+ #else
+ 	return NULL;
+ #endif
+ }
+ 
+ static int of_fwnode_add_links(struct fwnode_handle *fwnode)
++>>>>>>> 68b979d068d3 (device property: Add iomap to fwnode operations)
  {
  	struct property *p;
  	struct device_node *con_np = to_of_node(fwnode);
diff --cc include/linux/fwnode.h
index 006b5d37b7ec,ebbc3bf03f95..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -143,10 -148,8 +143,15 @@@ struct fwnode_operations 
  	(*graph_get_port_parent)(struct fwnode_handle *fwnode);
  	int (*graph_parse_endpoint)(const struct fwnode_handle *fwnode,
  				    struct fwnode_endpoint *endpoint);
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(int (*add_links)(struct fwnode_handle *fwnode,
 +			 struct device *dev))
 +	RH_KABI_EXTEND(const char *(*get_name)(const struct fwnode_handle *fwnode))
 +	RH_KABI_EXTEND(const char *(*get_name_prefix)(const struct fwnode_handle *fwnode))
++=======
+ 	void __iomem *(*iomap)(struct fwnode_handle *fwnode, int index);
+ 	int (*add_links)(struct fwnode_handle *fwnode);
++>>>>>>> 68b979d068d3 (device property: Add iomap to fwnode operations)
  };
  
  #define fwnode_has_op(fwnode, op)				\
diff --git a/drivers/base/property.c b/drivers/base/property.c
index abc5b5a3201c..78fbe5bb5408 100644
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@ -935,10 +935,7 @@ EXPORT_SYMBOL_GPL(device_get_phy_mode);
  */
 void __iomem *fwnode_iomap(struct fwnode_handle *fwnode, int index)
 {
-	if (IS_ENABLED(CONFIG_OF_ADDRESS) && is_of_node(fwnode))
-		return of_iomap(to_of_node(fwnode), index);
-
-	return NULL;
+	return fwnode_call_ptr_op(fwnode, iomap, index);
 }
 EXPORT_SYMBOL(fwnode_iomap);
 
* Unmerged path drivers/of/property.c
* Unmerged path include/linux/fwnode.h
