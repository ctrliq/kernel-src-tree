wifi: mac80211: mlme: Fix missing unlock on beacon RX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Rafael Mendonca <rafaelmendsr@gmail.com>
commit 883b8dc1a8766464d5bde4d97e1d7c795d990d31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/883b8dc1.failed

Commit 98b0b467466c ("wifi: mac80211: mlme: use correct link_sta")
switched to link station instead of deflink and added some checks to do
that, which are done with the 'sta_mtx' mutex held. However, the error
path of these checks does not unlock 'sta_mtx' before returning.

Fixes: 98b0b467466c ("wifi: mac80211: mlme: use correct link_sta")
	Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
Link: https://lore.kernel.org/r/20220924184042.778676-1-rafaelmendsr@gmail.com
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 883b8dc1a8766464d5bde4d97e1d7c795d990d31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,c0fbffd9b153..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -5541,6 -4787,1520 +5541,1523 @@@ static int ieee80211_prep_channel(struc
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_mgmt *mgmt,
+ 				    struct ieee802_11_elems *elems,
+ 				    const u8 *elem_start, unsigned int elem_len)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id;
+ 	struct sta_info *sta;
+ 	u64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};
+ 	int err;
+ 
+ 	mutex_lock(&sdata->local->sta_mtx);
+ 	/*
+ 	 * station info was already allocated and inserted before
+ 	 * the association and should be available to us
+ 	 */
+ 	sta = sta_info_get(sdata, assoc_data->ap_addr);
+ 	if (WARN_ON(!sta))
+ 		goto out_err;
+ 
+ 	if (sdata->vif.valid_links) {
+ 		u16 valid_links = 0;
+ 
+ 		for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 			if (!assoc_data->link[link_id].bss)
+ 				continue;
+ 			valid_links |= BIT(link_id);
+ 
+ 			if (link_id != assoc_data->assoc_link_id) {
+ 				err = ieee80211_sta_allocate_link(sta, link_id);
+ 				if (err)
+ 					goto out_err;
+ 			}
+ 		}
+ 
+ 		ieee80211_vif_set_links(sdata, valid_links);
+ 	}
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 		struct link_sta_info *link_sta;
+ 
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (WARN_ON(!link))
+ 			goto out_err;
+ 
+ 		if (sdata->vif.valid_links)
+ 			link_info(link,
+ 				  "local address %pM, AP link address %pM\n",
+ 				  link->conf->addr,
+ 				  assoc_data->link[link_id].bss->bssid);
+ 
+ 		link_sta = rcu_dereference_protected(sta->link[link_id],
+ 						     lockdep_is_held(&local->sta_mtx));
+ 		if (WARN_ON(!link_sta))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_prep_channel(sdata, link,
+ 						     assoc_data->link[link_id].bss,
+ 						     &link->u.mgd.conn_flags);
+ 			if (err)
+ 				goto out_err;
+ 		}
+ 
+ 		err = ieee80211_mgd_setup_link_sta(link, sta, link_sta,
+ 						   assoc_data->link[link_id].bss);
+ 		if (err)
+ 			goto out_err;
+ 
+ 		if (!ieee80211_assoc_config_link(link, link_sta,
+ 						 assoc_data->link[link_id].bss,
+ 						 mgmt, elem_start, elem_len,
+ 						 &changed[link_id]))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_sta_activate_link(sta, link_id);
+ 			if (err)
+ 				goto out_err;
+ 		}
+ 	}
+ 
+ 	rate_control_rate_init(sta);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
+ 		set_sta_flag(sta, WLAN_STA_MFP);
+ 		sta->sta.mfp = true;
+ 	} else {
+ 		sta->sta.mfp = false;
+ 	}
+ 
+ 	ieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,
+ 					      elems->ext_capab_len);
+ 
+ 	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
+ 		       local->hw.queues >= IEEE80211_NUM_ACS;
+ 
+ 	err = sta_info_move_state(sta, IEEE80211_STA_ASSOC);
+ 	if (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
+ 		err = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);
+ 	if (err) {
+ 		sdata_info(sdata,
+ 			   "failed to move station %pM to desired state\n",
+ 			   sta->sta.addr);
+ 		WARN_ON(__sta_info_destroy(sta));
+ 		goto out_err;
+ 	}
+ 
+ 	if (sdata->wdev.use_4addr)
+ 		drv_sta_set_4addr(local, sdata, &sta->sta, true);
+ 
+ 	mutex_unlock(&sdata->local->sta_mtx);
+ 
+ 	ieee80211_set_associated(sdata, assoc_data, changed);
+ 
+ 	/*
+ 	 * If we're using 4-addr mode, let the AP know that we're
+ 	 * doing so, so that it can create the STA VLAN on its side
+ 	 */
+ 	if (ifmgd->use_4addr)
+ 		ieee80211_send_4addr_nullfunc(local, sdata);
+ 
+ 	/*
+ 	 * Start timer to probe the connection to the AP now.
+ 	 * Also start the timer that will detect beacon loss.
+ 	 */
+ 	ieee80211_sta_reset_beacon_monitor(sdata);
+ 	ieee80211_sta_reset_conn_monitor(sdata);
+ 
+ 	return true;
+ out_err:
+ 	eth_zero_addr(sdata->vif.cfg.ap_addr);
+ 	mutex_unlock(&sdata->local->sta_mtx);
+ 	return false;
+ }
+ 
+ static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
+ 					 struct ieee80211_mgmt *mgmt,
+ 					 size_t len)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	u16 capab_info, status_code, aid;
+ 	struct ieee802_11_elems *elems;
+ 	int ac;
+ 	const u8 *elem_start;
+ 	unsigned int elem_len;
+ 	bool reassoc;
+ 	struct ieee80211_event event = {
+ 		.type = MLME_EVENT,
+ 		.u.mlme.data = ASSOC_EVENT,
+ 	};
+ 	struct ieee80211_prep_tx_info info = {};
+ 	struct cfg80211_rx_assoc_resp resp = {
+ 		.uapsd_queues = -1,
+ 	};
+ 	unsigned int link_id;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	if (!assoc_data)
+ 		return;
+ 
+ 	if (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) ||
+ 	    !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))
+ 		return;
+ 
+ 	/*
+ 	 * AssocResp and ReassocResp have identical structure, so process both
+ 	 * of them in this function.
+ 	 */
+ 
+ 	if (len < 24 + 6)
+ 		return;
+ 
+ 	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
+ 	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
+ 	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
+ 	if (assoc_data->s1g)
+ 		elem_start = mgmt->u.s1g_assoc_resp.variable;
+ 	else
+ 		elem_start = mgmt->u.assoc_resp.variable;
+ 
+ 	/*
+ 	 * Note: this may not be perfect, AP might misbehave - if
+ 	 * anyone needs to rely on perfect complete notification
+ 	 * with the exact right subtype, then we need to track what
+ 	 * we actually transmitted.
+ 	 */
+ 	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
+ 				 IEEE80211_STYPE_ASSOC_REQ;
+ 
+ 	if (assoc_data->fils_kek_len &&
+ 	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
+ 		return;
+ 
+ 	elem_len = len - (elem_start - (u8 *)mgmt);
+ 	elems = ieee802_11_parse_elems(elem_start, elem_len, false, NULL);
+ 	if (!elems)
+ 		goto notify_driver;
+ 
+ 	if (elems->aid_resp)
+ 		aid = le16_to_cpu(elems->aid_resp->aid);
+ 	else if (assoc_data->s1g)
+ 		aid = 0; /* TODO */
+ 	else
+ 		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+ 
+ 	/*
+ 	 * The 5 MSB of the AID field are reserved
+ 	 * (802.11-2016 9.4.1.8 AID field)
+ 	 */
+ 	aid &= 0x7ff;
+ 
+ 	sdata_info(sdata,
+ 		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
+ 		   reassoc ? "Rea" : "A", assoc_data->ap_addr,
+ 		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
+ 
+ 	ifmgd->broken_ap = false;
+ 
+ 	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
+ 	    elems->timeout_int &&
+ 	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
+ 		u32 tu, ms;
+ 
+ 		cfg80211_assoc_comeback(sdata->dev, assoc_data->ap_addr,
+ 					le32_to_cpu(elems->timeout_int->value));
+ 
+ 		tu = le32_to_cpu(elems->timeout_int->value);
+ 		ms = tu * 1024 / 1000;
+ 		sdata_info(sdata,
+ 			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
+ 			   assoc_data->ap_addr, tu, ms);
+ 		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
+ 		assoc_data->timeout_started = true;
+ 		if (ms > IEEE80211_ASSOC_TIMEOUT)
+ 			run_again(sdata, assoc_data->timeout);
+ 		goto notify_driver;
+ 	}
+ 
+ 	if (status_code != WLAN_STATUS_SUCCESS) {
+ 		sdata_info(sdata, "%pM denied association (code=%d)\n",
+ 			   assoc_data->ap_addr, status_code);
+ 		event.u.mlme.status = MLME_DENIED;
+ 		event.u.mlme.reason = status_code;
+ 		drv_event_callback(sdata->local, sdata, &event);
+ 	} else {
+ 		if (aid == 0 || aid > IEEE80211_MAX_AID) {
+ 			sdata_info(sdata,
+ 				   "invalid AID value %d (out of range), turn off PS\n",
+ 				   aid);
+ 			aid = 0;
+ 			ifmgd->broken_ap = true;
+ 		}
+ 
+ 		if (sdata->vif.valid_links) {
+ 			if (!elems->multi_link) {
+ 				sdata_info(sdata,
+ 					   "MLO association with %pM but no multi-link element in response!\n",
+ 					   assoc_data->ap_addr);
+ 				goto abandon_assoc;
+ 			}
+ 
+ 			if (le16_get_bits(elems->multi_link->control,
+ 					  IEEE80211_ML_CONTROL_TYPE) !=
+ 					IEEE80211_ML_CONTROL_TYPE_BASIC) {
+ 				sdata_info(sdata,
+ 					   "bad multi-link element (control=0x%x)\n",
+ 					   le16_to_cpu(elems->multi_link->control));
+ 				goto abandon_assoc;
+ 			} else {
+ 				struct ieee80211_mle_basic_common_info *common;
+ 
+ 				common = (void *)elems->multi_link->variable;
+ 
+ 				if (memcmp(assoc_data->ap_addr,
+ 					   common->mld_mac_addr, ETH_ALEN)) {
+ 					sdata_info(sdata,
+ 						   "AP MLD MAC address mismatch: got %pM expected %pM\n",
+ 						   common->mld_mac_addr,
+ 						   assoc_data->ap_addr);
+ 					goto abandon_assoc;
+ 				}
+ 			}
+ 		}
+ 
+ 		sdata->vif.cfg.aid = aid;
+ 
+ 		if (!ieee80211_assoc_success(sdata, mgmt, elems,
+ 					     elem_start, elem_len)) {
+ 			/* oops -- internal error -- send timeout for now */
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
+ 			goto notify_driver;
+ 		}
+ 		event.u.mlme.status = MLME_SUCCESS;
+ 		drv_event_callback(sdata->local, sdata, &event);
+ 		sdata_info(sdata, "associated\n");
+ 
+ 		info.success = 1;
+ 	}
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (!link)
+ 			continue;
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 		resp.links[link_id].bss = assoc_data->link[link_id].bss;
+ 		resp.links[link_id].addr = link->conf->addr;
+ 
+ 		/* get uapsd queues configuration - same for all links */
+ 		resp.uapsd_queues = 0;
+ 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+ 			if (link->tx_conf[ac].uapsd)
+ 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+ 	}
+ 
+ 	ieee80211_destroy_assoc_data(sdata,
+ 				     status_code == WLAN_STATUS_SUCCESS ?
+ 					ASSOC_SUCCESS :
+ 					ASSOC_REJECTED);
+ 
+ 	resp.buf = (u8 *)mgmt;
+ 	resp.len = len;
+ 	resp.req_ies = ifmgd->assoc_req_ies;
+ 	resp.req_ies_len = ifmgd->assoc_req_ies_len;
+ 	if (sdata->vif.valid_links)
+ 		resp.ap_mld_addr = assoc_data->ap_addr;
+ 	cfg80211_rx_assoc_resp(sdata->dev, &resp);
+ notify_driver:
+ 	drv_mgd_complete_tx(sdata->local, sdata, &info);
+ 	kfree(elems);
+ 	return;
+ abandon_assoc:
+ 	ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 	goto notify_driver;
+ }
+ 
+ static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
+ 				  struct ieee80211_mgmt *mgmt, size_t len,
+ 				  struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_bss *bss;
+ 	struct ieee80211_channel *channel;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	channel = ieee80211_get_channel_khz(local->hw.wiphy,
+ 					ieee80211_rx_status_to_khz(rx_status));
+ 	if (!channel)
+ 		return;
+ 
+ 	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
+ 	if (bss) {
+ 		link->conf->beacon_rate = bss->beacon_rate;
+ 		ieee80211_rx_bss_put(local, bss);
+ 	}
+ }
+ 
+ 
+ static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_link_data *link,
+ 					 struct sk_buff *skb)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+ 	struct ieee80211_if_managed *ifmgd;
+ 	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
+ 	struct ieee80211_channel *channel;
+ 	size_t baselen, len = skb->len;
+ 
+ 	ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	/*
+ 	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
+ 	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
+ 	 * a Probe Response frame [..], the Address 1 field of the Probe
+ 	 * Response frame shall be set to the broadcast address [..]"
+ 	 * So, on 6GHz band we should also accept broadcast responses.
+ 	 */
+ 	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
+ 					rx_status->freq);
+ 	if (!channel)
+ 		return;
+ 
+ 	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
+ 	    (channel->band != NL80211_BAND_6GHZ ||
+ 	     !is_broadcast_ether_addr(mgmt->da)))
+ 		return; /* ignore ProbeResp to foreign address */
+ 
+ 	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+ 	if (baselen > len)
+ 		return;
+ 
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 	if (ifmgd->associated &&
+ 	    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))
+ 		ieee80211_reset_ap_probe(sdata);
+ }
+ 
+ /*
+  * This is the canonical list of information elements we care about,
+  * the filter code also gives us all changes to the Microsoft OUI
+  * (00:50:F2) vendor IE which is used for WMM which we need to track,
+  * as well as the DTPC IE (part of the Cisco OUI) used for signaling
+  * changes to requested client power.
+  *
+  * We implement beacon filtering in software since that means we can
+  * avoid processing the frame here and in cfg80211, and userspace
+  * will not be able to tell whether the hardware supports it or not.
+  *
+  * XXX: This list needs to be dynamic -- userspace needs to be able to
+  *	add items it requires. It also needs to be able to tell us to
+  *	look out for other vendor IEs.
+  */
+ static const u64 care_about_ies =
+ 	(1ULL << WLAN_EID_COUNTRY) |
+ 	(1ULL << WLAN_EID_ERP_INFO) |
+ 	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
+ 	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
+ 	(1ULL << WLAN_EID_HT_CAPABILITY) |
+ 	(1ULL << WLAN_EID_HT_OPERATION) |
+ 	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
+ 
+ static void ieee80211_handle_beacon_sig(struct ieee80211_link_data *link,
+ 					struct ieee80211_if_managed *ifmgd,
+ 					struct ieee80211_bss_conf *bss_conf,
+ 					struct ieee80211_local *local,
+ 					struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 
+ 	/* Track average RSSI from the Beacon frames of the current AP */
+ 
+ 	if (!link->u.mgd.tracking_signal_avg) {
+ 		link->u.mgd.tracking_signal_avg = true;
+ 		ewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);
+ 		link->u.mgd.last_cqm_event_signal = 0;
+ 		link->u.mgd.count_beacon_signal = 1;
+ 		link->u.mgd.last_ave_beacon_signal = 0;
+ 	} else {
+ 		link->u.mgd.count_beacon_signal++;
+ 	}
+ 
+ 	ewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,
+ 			       -rx_status->signal);
+ 
+ 	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_sig = link->u.mgd.last_ave_beacon_signal;
+ 		struct ieee80211_event event = {
+ 			.type = RSSI_EVENT,
+ 		};
+ 
+ 		/*
+ 		 * if signal crosses either of the boundaries, invoke callback
+ 		 * with appropriate parameters
+ 		 */
+ 		if (sig > ifmgd->rssi_max_thold &&
+ 		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
+ 			link->u.mgd.last_ave_beacon_signal = sig;
+ 			event.u.rssi.data = RSSI_EVENT_HIGH;
+ 			drv_event_callback(local, sdata, &event);
+ 		} else if (sig < ifmgd->rssi_min_thold &&
+ 			   (last_sig >= ifmgd->rssi_max_thold ||
+ 			   last_sig == 0)) {
+ 			link->u.mgd.last_ave_beacon_signal = sig;
+ 			event.u.rssi.data = RSSI_EVENT_LOW;
+ 			drv_event_callback(local, sdata, &event);
+ 		}
+ 	}
+ 
+ 	if (bss_conf->cqm_rssi_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
+ 	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
+ 		int thold = bss_conf->cqm_rssi_thold;
+ 		int hyst = bss_conf->cqm_rssi_hyst;
+ 
+ 		if (sig < thold &&
+ 		    (last_event == 0 || sig < last_event - hyst)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+ 				sig, GFP_KERNEL);
+ 		} else if (sig > thold &&
+ 			   (last_event == 0 || sig > last_event + hyst)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+ 				sig, GFP_KERNEL);
+ 		}
+ 	}
+ 
+ 	if (bss_conf->cqm_rssi_low &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
+ 		int low = bss_conf->cqm_rssi_low;
+ 		int high = bss_conf->cqm_rssi_high;
+ 
+ 		if (sig < low &&
+ 		    (last_event == 0 || last_event >= low)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+ 				sig, GFP_KERNEL);
+ 		} else if (sig > high &&
+ 			   (last_event == 0 || last_event <= high)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+ 				sig, GFP_KERNEL);
+ 		}
+ 	}
+ }
+ 
+ static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
+ 				    struct cfg80211_bss *bss)
+ {
+ 	if (ether_addr_equal(tx_bssid, bss->bssid))
+ 		return true;
+ 	if (!bss->transmitted_bss)
+ 		return false;
+ 	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
+ }
+ 
+ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,
+ 				     struct ieee80211_hdr *hdr, size_t len,
+ 				     struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 	struct ieee80211_mgmt *mgmt = (void *) hdr;
+ 	size_t baselen;
+ 	struct ieee802_11_elems *elems;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	struct ieee80211_channel *chan;
+ 	struct link_sta_info *link_sta;
+ 	struct sta_info *sta;
+ 	u32 changed = 0;
+ 	bool erp_valid;
+ 	u8 erp_value = 0;
+ 	u32 ncrc = 0;
+ 	u8 *bssid, *variable = mgmt->u.beacon.variable;
+ 	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	/* Process beacon from the current BSS */
+ 	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
+ 	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
+ 		struct ieee80211_ext *ext = (void *) mgmt;
+ 
+ 		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
+ 			variable = ext->u.s1g_short_beacon.variable;
+ 		else
+ 			variable = ext->u.s1g_beacon.variable;
+ 	}
+ 
+ 	baselen = (u8 *) variable - (u8 *) mgmt;
+ 	if (baselen > len)
+ 		return;
+ 
+ 	rcu_read_lock();
+ 	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
+ 	if (!chanctx_conf) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 
+ 	if (ieee80211_rx_status_to_khz(rx_status) !=
+ 	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 	chan = chanctx_conf->def.chan;
+ 	rcu_read_unlock();
+ 
+ 	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
+ 	    !WARN_ON(sdata->vif.valid_links) &&
+ 	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {
+ 		elems = ieee802_11_parse_elems(variable, len - baselen, false,
+ 					       ifmgd->assoc_data->link[0].bss);
+ 		if (!elems)
+ 			return;
+ 
+ 		ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 		if (elems->dtim_period)
+ 			link->u.mgd.dtim_period = elems->dtim_period;
+ 		link->u.mgd.have_beacon = true;
+ 		ifmgd->assoc_data->need_beacon = false;
+ 		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
+ 			link->conf->sync_tsf =
+ 				le64_to_cpu(mgmt->u.beacon.timestamp);
+ 			link->conf->sync_device_ts =
+ 				rx_status->device_timestamp;
+ 			link->conf->sync_dtim_count = elems->dtim_count;
+ 		}
+ 
+ 		if (elems->mbssid_config_ie)
+ 			bss_conf->profile_periodicity =
+ 				elems->mbssid_config_ie->profile_periodicity;
+ 		else
+ 			bss_conf->profile_periodicity = 0;
+ 
+ 		if (elems->ext_capab_len >= 11 &&
+ 		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
+ 			bss_conf->ema_ap = true;
+ 		else
+ 			bss_conf->ema_ap = false;
+ 
+ 		/* continue assoc process */
+ 		ifmgd->assoc_data->timeout = jiffies;
+ 		ifmgd->assoc_data->timeout_started = true;
+ 		run_again(sdata, ifmgd->assoc_data->timeout);
+ 		kfree(elems);
+ 		return;
+ 	}
+ 
+ 	if (!ifmgd->associated ||
+ 	    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))
+ 		return;
+ 	bssid = link->u.mgd.bssid;
+ 
+ 	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
+ 		ieee80211_handle_beacon_sig(link, ifmgd, bss_conf,
+ 					    local, rx_status);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
+ 		mlme_dbg_ratelimited(sdata,
+ 				     "cancelling AP probe due to a received beacon\n");
+ 		ieee80211_reset_ap_probe(sdata);
+ 	}
+ 
+ 	/*
+ 	 * Push the beacon loss detection into the future since
+ 	 * we are processing a beacon from the AP just now.
+ 	 */
+ 	ieee80211_sta_reset_beacon_monitor(sdata);
+ 
+ 	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
+ 	 * element (which carries the beacon interval). Don't forget to add a
+ 	 * bit to care_about_ies[] above if mac80211 is interested in a
+ 	 * changing S1G element.
+ 	 */
+ 	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
+ 		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
+ 	elems = ieee802_11_parse_elems_crc(variable, len - baselen,
+ 					   false, care_about_ies, ncrc,
+ 					   link->u.mgd.bss);
+ 	if (!elems)
+ 		return;
+ 	ncrc = elems->crc;
+ 
+ 	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
+ 	    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {
+ 		if (local->hw.conf.dynamic_ps_timeout > 0) {
+ 			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
+ 				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
+ 				ieee80211_hw_config(local,
+ 						    IEEE80211_CONF_CHANGE_PS);
+ 			}
+ 			ieee80211_send_nullfunc(local, sdata, false);
+ 		} else if (!local->pspolling && sdata->u.mgd.powersave) {
+ 			local->pspolling = true;
+ 
+ 			/*
+ 			 * Here is assumed that the driver will be
+ 			 * able to send ps-poll frame and receive a
+ 			 * response even though power save mode is
+ 			 * enabled, but some drivers might require
+ 			 * to disable power save here. This needs
+ 			 * to be investigated.
+ 			 */
+ 			ieee80211_send_pspoll(local, sdata);
+ 		}
+ 	}
+ 
+ 	if (sdata->vif.p2p ||
+ 	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
+ 		struct ieee80211_p2p_noa_attr noa = {};
+ 		int ret;
+ 
+ 		ret = cfg80211_get_p2p_attr(variable,
+ 					    len - baselen,
+ 					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
+ 					    (u8 *) &noa, sizeof(noa));
+ 		if (ret >= 2) {
+ 			if (link->u.mgd.p2p_noa_index != noa.index) {
+ 				/* valid noa_attr and index changed */
+ 				link->u.mgd.p2p_noa_index = noa.index;
+ 				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
+ 				changed |= BSS_CHANGED_P2P_PS;
+ 				/*
+ 				 * make sure we update all information, the CRC
+ 				 * mechanism doesn't look at P2P attributes.
+ 				 */
+ 				link->u.mgd.beacon_crc_valid = false;
+ 			}
+ 		} else if (link->u.mgd.p2p_noa_index != -1) {
+ 			/* noa_attr not found and we had valid noa_attr before */
+ 			link->u.mgd.p2p_noa_index = -1;
+ 			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
+ 			changed |= BSS_CHANGED_P2P_PS;
+ 			link->u.mgd.beacon_crc_valid = false;
+ 		}
+ 	}
+ 
+ 	if (link->u.mgd.csa_waiting_bcn)
+ 		ieee80211_chswitch_post_beacon(link);
+ 
+ 	/*
+ 	 * Update beacon timing and dtim count on every beacon appearance. This
+ 	 * will allow the driver to use the most updated values. Do it before
+ 	 * comparing this one with last received beacon.
+ 	 * IMPORTANT: These parameters would possibly be out of sync by the time
+ 	 * the driver will use them. The synchronized view is currently
+ 	 * guaranteed only in certain callbacks.
+ 	 */
+ 	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
+ 	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
+ 		link->conf->sync_tsf =
+ 			le64_to_cpu(mgmt->u.beacon.timestamp);
+ 		link->conf->sync_device_ts =
+ 			rx_status->device_timestamp;
+ 		link->conf->sync_dtim_count = elems->dtim_count;
+ 	}
+ 
+ 	if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||
+ 	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
+ 		goto free;
+ 	link->u.mgd.beacon_crc = ncrc;
+ 	link->u.mgd.beacon_crc_valid = true;
+ 
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 	ieee80211_sta_process_chanswitch(link, rx_status->mactime,
+ 					 rx_status->device_timestamp,
+ 					 elems, true);
+ 
+ 	if (!link->u.mgd.disable_wmm_tracking &&
+ 	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 				     elems->wmm_param_len,
+ 				     elems->mu_edca_param_set))
+ 		changed |= BSS_CHANGED_QOS;
+ 
+ 	/*
+ 	 * If we haven't had a beacon before, tell the driver about the
+ 	 * DTIM period (and beacon timing if desired) now.
+ 	 */
+ 	if (!link->u.mgd.have_beacon) {
+ 		/* a few bogus AP send dtim_period = 0 or no TIM IE */
+ 		bss_conf->dtim_period = elems->dtim_period ?: 1;
+ 
+ 		changed |= BSS_CHANGED_BEACON_INFO;
+ 		link->u.mgd.have_beacon = true;
+ 
+ 		mutex_lock(&local->iflist_mtx);
+ 		ieee80211_recalc_ps(local);
+ 		mutex_unlock(&local->iflist_mtx);
+ 
+ 		ieee80211_recalc_ps_vif(sdata);
+ 	}
+ 
+ 	if (elems->erp_info) {
+ 		erp_valid = true;
+ 		erp_value = elems->erp_info[0];
+ 	} else {
+ 		erp_valid = false;
+ 	}
+ 
+ 	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
+ 		changed |= ieee80211_handle_bss_capability(link,
+ 				le16_to_cpu(mgmt->u.beacon.capab_info),
+ 				erp_valid, erp_value);
+ 
+ 	mutex_lock(&local->sta_mtx);
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
+ 	if (WARN_ON(!sta)) {
+ 		mutex_unlock(&local->sta_mtx);
+ 		goto free;
+ 	}
+ 	link_sta = rcu_dereference_protected(sta->link[link->link_id],
+ 					     lockdep_is_held(&local->sta_mtx));
+ 	if (WARN_ON(!link_sta)) {
+ 		mutex_unlock(&local->sta_mtx);
+ 		goto free;
+ 	}
+ 
+ 	changed |= ieee80211_recalc_twt_req(link, link_sta, elems);
+ 
+ 	if (ieee80211_config_bw(link, elems->ht_cap_elem,
+ 				elems->vht_cap_elem, elems->ht_operation,
+ 				elems->vht_operation, elems->he_operation,
+ 				elems->eht_operation,
+ 				elems->s1g_oper, bssid, &changed)) {
+ 		mutex_unlock(&local->sta_mtx);
+ 		sdata_info(sdata,
+ 			   "failed to follow AP %pM bandwidth change, disconnect\n",
+ 			   bssid);
+ 		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
+ 				       WLAN_REASON_DEAUTH_LEAVING,
+ 				       true, deauth_buf);
+ 		ieee80211_report_disconnect(sdata, deauth_buf,
+ 					    sizeof(deauth_buf), true,
+ 					    WLAN_REASON_DEAUTH_LEAVING,
+ 					    false);
+ 		goto free;
+ 	}
+ 
+ 	if (sta && elems->opmode_notif)
+ 		ieee80211_vht_handle_opmode(sdata, link_sta,
+ 					    *elems->opmode_notif,
+ 					    rx_status->band);
+ 	mutex_unlock(&local->sta_mtx);
+ 
+ 	changed |= ieee80211_handle_pwr_constr(link, chan, mgmt,
+ 					       elems->country_elem,
+ 					       elems->country_elem_len,
+ 					       elems->pwr_constr_elem,
+ 					       elems->cisco_dtpc_elem);
+ 
+ 	ieee80211_link_info_change_notify(sdata, link, changed);
+ free:
+ 	kfree(elems);
+ }
+ 
+ void ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,
+ 				 struct sk_buff *skb)
+ {
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_rx_status *rx_status;
+ 	struct ieee80211_hdr *hdr;
+ 	u16 fc;
+ 
+ 	rx_status = (struct ieee80211_rx_status *) skb->cb;
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+ 	fc = le16_to_cpu(hdr->frame_control);
+ 
+ 	sdata_lock(sdata);
+ 	switch (fc & IEEE80211_FCTL_STYPE) {
+ 	case IEEE80211_STYPE_S1G_BEACON:
+ 		ieee80211_rx_mgmt_beacon(link, hdr, skb->len, rx_status);
+ 		break;
+ 	}
+ 	sdata_unlock(sdata);
+ }
+ 
+ void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+ 				  struct sk_buff *skb)
+ {
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_rx_status *rx_status;
+ 	struct ieee80211_mgmt *mgmt;
+ 	u16 fc;
+ 	int ies_len;
+ 
+ 	rx_status = (struct ieee80211_rx_status *) skb->cb;
+ 	mgmt = (struct ieee80211_mgmt *) skb->data;
+ 	fc = le16_to_cpu(mgmt->frame_control);
+ 
+ 	sdata_lock(sdata);
+ 
+ 	switch (fc & IEEE80211_FCTL_STYPE) {
+ 	case IEEE80211_STYPE_BEACON:
+ 		ieee80211_rx_mgmt_beacon(link, (void *)mgmt,
+ 					 skb->len, rx_status);
+ 		break;
+ 	case IEEE80211_STYPE_PROBE_RESP:
+ 		ieee80211_rx_mgmt_probe_resp(link, skb);
+ 		break;
+ 	case IEEE80211_STYPE_AUTH:
+ 		ieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_DEAUTH:
+ 		ieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_DISASSOC:
+ 		ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_ASSOC_RESP:
+ 	case IEEE80211_STYPE_REASSOC_RESP:
+ 		ieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_ACTION:
+ 		if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {
+ 			struct ieee802_11_elems *elems;
+ 
+ 			ies_len = skb->len -
+ 				  offsetof(struct ieee80211_mgmt,
+ 					   u.action.u.chan_switch.variable);
+ 
+ 			if (ies_len < 0)
+ 				break;
+ 
+ 			/* CSA IE cannot be overridden, no need for BSSID */
+ 			elems = ieee802_11_parse_elems(
+ 					mgmt->u.action.u.chan_switch.variable,
+ 					ies_len, true, NULL);
+ 
+ 			if (elems && !elems->parse_error)
+ 				ieee80211_sta_process_chanswitch(link,
+ 								 rx_status->mactime,
+ 								 rx_status->device_timestamp,
+ 								 elems, false);
+ 			kfree(elems);
+ 		} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
+ 			struct ieee802_11_elems *elems;
+ 
+ 			ies_len = skb->len -
+ 				  offsetof(struct ieee80211_mgmt,
+ 					   u.action.u.ext_chan_switch.variable);
+ 
+ 			if (ies_len < 0)
+ 				break;
+ 
+ 			/*
+ 			 * extended CSA IE can't be overridden, no need for
+ 			 * BSSID
+ 			 */
+ 			elems = ieee802_11_parse_elems(
+ 					mgmt->u.action.u.ext_chan_switch.variable,
+ 					ies_len, true, NULL);
+ 
+ 			if (elems && !elems->parse_error) {
+ 				/* for the handling code pretend it was an IE */
+ 				elems->ext_chansw_ie =
+ 					&mgmt->u.action.u.ext_chan_switch.data;
+ 
+ 				ieee80211_sta_process_chanswitch(link,
+ 								 rx_status->mactime,
+ 								 rx_status->device_timestamp,
+ 								 elems, false);
+ 			}
+ 
+ 			kfree(elems);
+ 		}
+ 		break;
+ 	}
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_sta_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.timer);
+ 
+ 	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+ }
+ 
+ void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
+ 				   u8 reason, bool tx)
+ {
+ 	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH, reason,
+ 			       tx, frame_buf);
+ 
+ 	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
+ 				    reason, false);
+ }
+ 
+ static int ieee80211_auth(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_auth_data *auth_data = ifmgd->auth_data;
+ 	u32 tx_flags = 0;
+ 	u16 trans = 1;
+ 	u16 status = 0;
+ 	struct ieee80211_prep_tx_info info = {
+ 		.subtype = IEEE80211_STYPE_AUTH,
+ 	};
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	if (WARN_ON_ONCE(!auth_data))
+ 		return -EINVAL;
+ 
+ 	auth_data->tries++;
+ 
+ 	if (auth_data->tries > IEEE80211_AUTH_MAX_TRIES) {
+ 		sdata_info(sdata, "authentication with %pM timed out\n",
+ 			   auth_data->ap_addr);
+ 
+ 		/*
+ 		 * Most likely AP is not in the range so remove the
+ 		 * bss struct for that AP.
+ 		 */
+ 		cfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);
+ 
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	if (auth_data->algorithm == WLAN_AUTH_SAE)
+ 		info.duration = jiffies_to_msecs(IEEE80211_AUTH_TIMEOUT_SAE);
+ 
+ 	drv_mgd_prepare_tx(local, sdata, &info);
+ 
+ 	sdata_info(sdata, "send auth to %pM (try %d/%d)\n",
+ 		   auth_data->ap_addr, auth_data->tries,
+ 		   IEEE80211_AUTH_MAX_TRIES);
+ 
+ 	auth_data->expected_transaction = 2;
+ 
+ 	if (auth_data->algorithm == WLAN_AUTH_SAE) {
+ 		trans = auth_data->sae_trans;
+ 		status = auth_data->sae_status;
+ 		auth_data->expected_transaction = trans;
+ 	}
+ 
+ 	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
+ 		tx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
+ 			   IEEE80211_TX_INTFL_MLME_CONN_TX;
+ 
+ 	ieee80211_send_auth(sdata, trans, auth_data->algorithm, status,
+ 			    auth_data->data, auth_data->data_len,
+ 			    auth_data->ap_addr, auth_data->ap_addr,
+ 			    NULL, 0, 0, tx_flags);
+ 
+ 	if (tx_flags == 0) {
+ 		if (auth_data->algorithm == WLAN_AUTH_SAE)
+ 			auth_data->timeout = jiffies +
+ 				IEEE80211_AUTH_TIMEOUT_SAE;
+ 		else
+ 			auth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
+ 	} else {
+ 		auth_data->timeout =
+ 			round_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);
+ 	}
+ 
+ 	auth_data->timeout_started = true;
+ 	run_again(sdata, auth_data->timeout);
+ 
+ 	return 0;
+ }
+ 
+ static int ieee80211_do_assoc(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	int ret;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	assoc_data->tries++;
+ 	if (assoc_data->tries > IEEE80211_ASSOC_MAX_TRIES) {
+ 		sdata_info(sdata, "association with %pM timed out\n",
+ 			   assoc_data->ap_addr);
+ 
+ 		/*
+ 		 * Most likely AP is not in the range so remove the
+ 		 * bss struct for that AP.
+ 		 */
+ 		cfg80211_unlink_bss(local->hw.wiphy,
+ 				    assoc_data->link[assoc_data->assoc_link_id].bss);
+ 
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	sdata_info(sdata, "associate with %pM (try %d/%d)\n",
+ 		   assoc_data->ap_addr, assoc_data->tries,
+ 		   IEEE80211_ASSOC_MAX_TRIES);
+ 	ret = ieee80211_send_assoc(sdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 		assoc_data->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;
+ 		assoc_data->timeout_started = true;
+ 		run_again(sdata, assoc_data->timeout);
+ 	} else {
+ 		assoc_data->timeout =
+ 			round_jiffies_up(jiffies +
+ 					 IEEE80211_ASSOC_TIMEOUT_LONG);
+ 		assoc_data->timeout_started = true;
+ 		run_again(sdata, assoc_data->timeout);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,
+ 				  __le16 fc, bool acked)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 
+ 	sdata->u.mgd.status_fc = fc;
+ 	sdata->u.mgd.status_acked = acked;
+ 	sdata->u.mgd.status_received = true;
+ 
+ 	ieee80211_queue_work(&local->hw, &sdata->work);
+ }
+ 
+ void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_lock(sdata);
+ 
+ 	if (ifmgd->status_received) {
+ 		__le16 fc = ifmgd->status_fc;
+ 		bool status_acked = ifmgd->status_acked;
+ 
+ 		ifmgd->status_received = false;
+ 		if (ifmgd->auth_data && ieee80211_is_auth(fc)) {
+ 			if (status_acked) {
+ 				if (ifmgd->auth_data->algorithm ==
+ 				    WLAN_AUTH_SAE)
+ 					ifmgd->auth_data->timeout =
+ 						jiffies +
+ 						IEEE80211_AUTH_TIMEOUT_SAE;
+ 				else
+ 					ifmgd->auth_data->timeout =
+ 						jiffies +
+ 						IEEE80211_AUTH_TIMEOUT_SHORT;
+ 				run_again(sdata, ifmgd->auth_data->timeout);
+ 			} else {
+ 				ifmgd->auth_data->timeout = jiffies - 1;
+ 			}
+ 			ifmgd->auth_data->timeout_started = true;
+ 		} else if (ifmgd->assoc_data &&
+ 			   (ieee80211_is_assoc_req(fc) ||
+ 			    ieee80211_is_reassoc_req(fc))) {
+ 			if (status_acked) {
+ 				ifmgd->assoc_data->timeout =
+ 					jiffies + IEEE80211_ASSOC_TIMEOUT_SHORT;
+ 				run_again(sdata, ifmgd->assoc_data->timeout);
+ 			} else {
+ 				ifmgd->assoc_data->timeout = jiffies - 1;
+ 			}
+ 			ifmgd->assoc_data->timeout_started = true;
+ 		}
+ 	}
+ 
+ 	if (ifmgd->auth_data && ifmgd->auth_data->timeout_started &&
+ 	    time_after(jiffies, ifmgd->auth_data->timeout)) {
+ 		if (ifmgd->auth_data->done || ifmgd->auth_data->waiting) {
+ 			/*
+ 			 * ok ... we waited for assoc or continuation but
+ 			 * userspace didn't do it, so kill the auth data
+ 			 */
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 		} else if (ieee80211_auth(sdata)) {
+ 			u8 ap_addr[ETH_ALEN];
+ 			struct ieee80211_event event = {
+ 				.type = MLME_EVENT,
+ 				.u.mlme.data = AUTH_EVENT,
+ 				.u.mlme.status = MLME_TIMEOUT,
+ 			};
+ 
+ 			memcpy(ap_addr, ifmgd->auth_data->ap_addr, ETH_ALEN);
+ 
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 
+ 			cfg80211_auth_timeout(sdata->dev, ap_addr);
+ 			drv_event_callback(sdata->local, sdata, &event);
+ 		}
+ 	} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)
+ 		run_again(sdata, ifmgd->auth_data->timeout);
+ 
+ 	if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started &&
+ 	    time_after(jiffies, ifmgd->assoc_data->timeout)) {
+ 		if ((ifmgd->assoc_data->need_beacon &&
+ 		     !sdata->deflink.u.mgd.have_beacon) ||
+ 		    ieee80211_do_assoc(sdata)) {
+ 			struct ieee80211_event event = {
+ 				.type = MLME_EVENT,
+ 				.u.mlme.data = ASSOC_EVENT,
+ 				.u.mlme.status = MLME_TIMEOUT,
+ 			};
+ 
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
+ 			drv_event_callback(sdata->local, sdata, &event);
+ 		}
+ 	} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)
+ 		run_again(sdata, ifmgd->assoc_data->timeout);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL &&
+ 	    ifmgd->associated) {
+ 		u8 *bssid = sdata->deflink.u.mgd.bssid;
+ 		int max_tries;
+ 
+ 		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
+ 			max_tries = max_nullfunc_tries;
+ 		else
+ 			max_tries = max_probe_tries;
+ 
+ 		/* ACK received for nullfunc probing frame */
+ 		if (!ifmgd->probe_send_count)
+ 			ieee80211_reset_ap_probe(sdata);
+ 		else if (ifmgd->nullfunc_failed) {
+ 			if (ifmgd->probe_send_count < max_tries) {
+ 				mlme_dbg(sdata,
+ 					 "No ack for nullfunc frame to AP %pM, try %d/%i\n",
+ 					 bssid, ifmgd->probe_send_count,
+ 					 max_tries);
+ 				ieee80211_mgd_probe_ap_send(sdata);
+ 			} else {
+ 				mlme_dbg(sdata,
+ 					 "No ack for nullfunc frame to AP %pM, disconnecting.\n",
+ 					 bssid);
+ 				ieee80211_sta_connection_lost(sdata,
+ 					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
+ 					false);
+ 			}
+ 		} else if (time_is_after_jiffies(ifmgd->probe_timeout))
+ 			run_again(sdata, ifmgd->probe_timeout);
+ 		else if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 			mlme_dbg(sdata,
+ 				 "Failed to send nullfunc to AP %pM after %dms, disconnecting\n",
+ 				 bssid, probe_wait_ms);
+ 			ieee80211_sta_connection_lost(sdata,
+ 				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
+ 		} else if (ifmgd->probe_send_count < max_tries) {
+ 			mlme_dbg(sdata,
+ 				 "No probe response from AP %pM after %dms, try %d/%i\n",
+ 				 bssid, probe_wait_ms,
+ 				 ifmgd->probe_send_count, max_tries);
+ 			ieee80211_mgd_probe_ap_send(sdata);
+ 		} else {
+ 			/*
+ 			 * We actually lost the connection ... or did we?
+ 			 * Let's make sure!
+ 			 */
+ 			mlme_dbg(sdata,
+ 				 "No probe response from AP %pM after %dms, disconnecting.\n",
+ 				 bssid, probe_wait_ms);
+ 
+ 			ieee80211_sta_connection_lost(sdata,
+ 				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
+ 		}
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_sta_bcn_mon_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.bcn_mon_timer);
+ 
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
+ 		return;
+ 
+ 	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
+ 		return;
+ 
+ 	sdata->u.mgd.connection_loss = false;
+ 	ieee80211_queue_work(&sdata->local->hw,
+ 			     &sdata->u.mgd.beacon_connection_loss_work);
+ }
+ 
+ static void ieee80211_sta_conn_mon_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.conn_mon_timer);
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct sta_info *sta;
+ 	unsigned long timeout;
+ 
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
+ 		return;
+ 
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
+ 	if (!sta)
+ 		return;
+ 
+ 	timeout = sta->deflink.status_stats.last_ack;
+ 	if (time_before(sta->deflink.status_stats.last_ack, sta->deflink.rx_stats.last_rx))
+ 		timeout = sta->deflink.rx_stats.last_rx;
+ 	timeout += IEEE80211_CONNECTION_IDLE_TIME;
+ 
+ 	/* If timeout is after now, then update timer to fire at
+ 	 * the later date, but do not actually probe at this time.
+ 	 */
+ 	if (time_is_after_jiffies(timeout)) {
+ 		mod_timer(&ifmgd->conn_mon_timer, round_jiffies_up(timeout));
+ 		return;
+ 	}
+ 
+ 	ieee80211_queue_work(&local->hw, &ifmgd->monitor_work);
+ }
+ 
+ static void ieee80211_sta_monitor_work(struct work_struct *work)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		container_of(work, struct ieee80211_sub_if_data,
+ 			     u.mgd.monitor_work);
+ 
+ 	ieee80211_mgd_probe_ap(sdata, false);
+ }
+ 
+ static void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata)
+ {
+ 	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+ 		__ieee80211_stop_poll(sdata);
+ 
+ 		/* let's probe the connection once */
+ 		if (!ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
+ 			ieee80211_queue_work(&sdata->local->hw,
+ 					     &sdata->u.mgd.monitor_work);
+ 	}
+ }
+ 
+ #ifdef CONFIG_PM
+ void ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	sdata_lock(sdata);
+ 
+ 	if (ifmgd->auth_data || ifmgd->assoc_data) {
+ 		const u8 *ap_addr = ifmgd->auth_data ?
+ 				ifmgd->auth_data->ap_addr :
+ 				ifmgd->assoc_data->ap_addr;
+ 
+ 		/*
+ 		 * If we are trying to authenticate / associate while suspending,
+ 		 * cfg80211 won't know and won't actually abort those attempts,
+ 		 * thus we need to do that ourselves.
+ 		 */
+ 		ieee80211_send_deauth_disassoc(sdata, ap_addr, ap_addr,
+ 					       IEEE80211_STYPE_DEAUTH,
+ 					       WLAN_REASON_DEAUTH_LEAVING,
+ 					       false, frame_buf);
+ 		if (ifmgd->assoc_data)
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 		if (ifmgd->auth_data)
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
+ 				      IEEE80211_DEAUTH_FRAME_LEN,
+ 				      false);
+ 	}
+ 
+ 	/* This is a bit of a hack - we should find a better and more generic
+ 	 * solution to this. Normally when suspending, cfg80211 will in fact
+ 	 * deauthenticate. However, it doesn't (and cannot) stop an ongoing
+ 	 * auth (not so important) or assoc (this is the problem) process.
+ 	 *
+ 	 * As a consequence, it can happen that we are in the process of both
+ 	 * associating and suspending, and receive an association response
+ 	 * after cfg80211 has checked if it needs to disconnect, but before
+ 	 * we actually set the flag to drop incoming frames. This will then
+ 	 * cause the workqueue flush to process the association response in
+ 	 * the suspend, resulting in a successful association just before it
+ 	 * tries to remove the interface from the driver, which now though
+ 	 * has a channel context assigned ... this results in issues.
+ 	 *
+ 	 * To work around this (for now) simply deauth here again if we're
+ 	 * now connected.
+ 	 */
+ 	if (ifmgd->associated && !sdata->local->wowlan) {
+ 		u8 bssid[ETH_ALEN];
+ 		struct cfg80211_deauth_request req = {
+ 			.reason_code = WLAN_REASON_DEAUTH_LEAVING,
+ 			.bssid = bssid,
+ 		};
+ 
+ 		memcpy(bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
+ 		ieee80211_mgd_deauth(sdata, &req);
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ #endif
+ 
+ void ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_lock(sdata);
+ 	if (!ifmgd->associated) {
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {
+ 		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;
+ 		mlme_dbg(sdata, "driver requested disconnect after resume\n");
+ 		ieee80211_sta_connection_lost(sdata,
+ 					      WLAN_REASON_UNSPECIFIED,
+ 					      true);
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_HW_RESTART) {
+ 		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_HW_RESTART;
+ 		mlme_dbg(sdata, "driver requested disconnect after hardware restart\n");
+ 		ieee80211_sta_connection_lost(sdata,
+ 					      WLAN_REASON_UNSPECIFIED,
+ 					      true);
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_request_smps_mgd_work(struct work_struct *work)
+ {
+ 	struct ieee80211_link_data *link =
+ 		container_of(work, struct ieee80211_link_data,
+ 			     u.mgd.request_smps_work);
+ 
+ 	sdata_lock(link->sdata);
+ 	__ieee80211_request_smps_mgd(link->sdata, link,
+ 				     link->u.mgd.driver_smps_mode);
+ 	sdata_unlock(link->sdata);
+ }
+ 
+ /* interface setup */
+ void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
+ 	INIT_WORK(&ifmgd->beacon_connection_loss_work,
+ 		  ieee80211_beacon_connection_loss_work);
+ 	INIT_WORK(&ifmgd->csa_connection_drop_work,
+ 		  ieee80211_csa_connection_drop_work);
+ 	INIT_DELAYED_WORK(&ifmgd->tdls_peer_del_work,
+ 			  ieee80211_tdls_peer_del_work);
+ 	timer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);
+ 	timer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);
+ 	timer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);
+ 	INIT_DELAYED_WORK(&ifmgd->tx_tspec_wk,
+ 			  ieee80211_sta_handle_tspec_ac_params_wk);
+ 
+ 	ifmgd->flags = 0;
+ 	ifmgd->powersave = sdata->wdev.ps;
+ 	ifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;
+ 	ifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;
+ 	/* Setup TDLS data */
+ 	spin_lock_init(&ifmgd->teardown_lock);
+ 	ifmgd->teardown_skb = NULL;
+ 	ifmgd->orig_teardown_skb = NULL;
+ }
+ 
+ void ieee80211_mgd_setup_link(struct ieee80211_link_data *link)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id = link->link_id;
+ 
+ 	link->u.mgd.p2p_noa_index = -1;
+ 	link->u.mgd.conn_flags = 0;
+ 	link->conf->bssid = link->u.mgd.bssid;
+ 
+ 	INIT_WORK(&link->u.mgd.request_smps_work,
+ 		  ieee80211_request_smps_mgd_work);
+ 	if (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
+ 	else
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_OFF;
+ 
+ 	INIT_WORK(&link->u.mgd.chswitch_work, ieee80211_chswitch_work);
+ 	timer_setup(&link->u.mgd.chswitch_timer, ieee80211_chswitch_timer, 0);
+ 
+ 	if (sdata->u.mgd.assoc_data)
+ 		ether_addr_copy(link->conf->addr,
+ 				sdata->u.mgd.assoc_data->link[link_id].addr);
+ }
+ 
+ /* scan finished notification */
+ void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 
+ 	/* Restart STA timers */
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+ 		if (ieee80211_sdata_running(sdata))
+ 			ieee80211_restart_sta_timer(sdata);
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> 883b8dc1a876 (wifi: mac80211: mlme: Fix missing unlock on beacon RX)
  static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
  			       u8 *dtim_count, u8 *dtim_period)
  {
* Unmerged path net/mac80211/mlme.c
