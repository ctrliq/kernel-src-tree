netfilter: ip6t_rt: fix rt0_hdr parsing in rt_mt6

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Xin Long <lucien.xin@gmail.com>
commit a482c5e00a9b5a194085bcd372ac36141028becb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a482c5e0.failed

In rt_mt6(), when it's a nonlinear skb, the 1st skb_header_pointer()
only copies sizeof(struct ipv6_rt_hdr) to _route that rh points to.
The access by ((const struct rt0_hdr *)rh)->reserved will overflow
the buffer. So this access should be moved below the 2nd call to
skb_header_pointer().

Besides, after the 2nd skb_header_pointer(), its return value should
also be checked, othersize, *rp may cause null-pointer-ref.

v1->v2:
  - clean up some old debugging log.

Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a482c5e00a9b5a194085bcd372ac36141028becb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/netfilter/ip6t_rt.c
diff --cc net/ipv6/netfilter/ip6t_rt.c
index 21bf6bf04323,4ad8b2032f1f..000000000000
--- a/net/ipv6/netfilter/ip6t_rt.c
+++ b/net/ipv6/netfilter/ip6t_rt.c
@@@ -68,32 -60,7 +63,36 @@@ static bool rt_mt6(const struct sk_buf
  		return false;
  	}
  
++<<<<<<< HEAD
 +	pr_debug("IPv6 RT LEN %u %u ", hdrlen, rh->hdrlen);
 +	pr_debug("TYPE %04X ", rh->type);
 +	pr_debug("SGS_LEFT %u %02X\n", rh->segments_left, rh->segments_left);
 +
 +	pr_debug("IPv6 RT segsleft %02X ",
 +		 segsleft_match(rtinfo->segsleft[0], rtinfo->segsleft[1],
 +				rh->segments_left,
 +				!!(rtinfo->invflags & IP6T_RT_INV_SGS)));
 +	pr_debug("type %02X %02X %02X ",
 +		 rtinfo->rt_type, rh->type,
 +		 (!(rtinfo->flags & IP6T_RT_TYP) ||
 +		  ((rtinfo->rt_type == rh->type) ^
 +		   !!(rtinfo->invflags & IP6T_RT_INV_TYP))));
 +	pr_debug("len %02X %04X %02X ",
 +		 rtinfo->hdrlen, hdrlen,
 +		 !(rtinfo->flags & IP6T_RT_LEN) ||
 +		  ((rtinfo->hdrlen == hdrlen) ^
 +		   !!(rtinfo->invflags & IP6T_RT_INV_LEN)));
 +	pr_debug("res %02X %02X %02X ",
 +		 rtinfo->flags & IP6T_RT_RES,
 +		 ((const struct rt0_hdr *)rh)->reserved,
 +		 !((rtinfo->flags & IP6T_RT_RES) &&
 +		   (((const struct rt0_hdr *)rh)->reserved)));
 +
 +	ret = (rh != NULL) &&
 +	      (segsleft_match(rtinfo->segsleft[0], rtinfo->segsleft[1],
++=======
+ 	ret = (segsleft_match(rtinfo->segsleft[0], rtinfo->segsleft[1],
++>>>>>>> a482c5e00a9b (netfilter: ip6t_rt: fix rt0_hdr parsing in rt_mt6)
  			      rh->segments_left,
  			      !!(rtinfo->invflags & IP6T_RT_INV_SGS))) &&
  	      (!(rtinfo->flags & IP6T_RT_LEN) ||
* Unmerged path net/ipv6/netfilter/ip6t_rt.c
