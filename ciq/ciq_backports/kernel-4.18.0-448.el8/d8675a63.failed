wifi: mac80211: RCU-ify link/link_conf pointers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit d8675a63518c6148827838058feb7f18403faed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d8675a63.failed

Since links can be added and removed dynamically, we need to
somehow protect the sdata->link[] and vif->link_conf[] array
pointers from disappearing when accessing them without locks.
RCU-ify the pointers to achieve this, which requires quite a
bit of rework.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit d8675a63518c6148827838058feb7f18403faed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
#	include/net/mac80211.h
#	net/mac80211/cfg.c
#	net/mac80211/chan.c
#	net/mac80211/debugfs_netdev.c
#	net/mac80211/driver-ops.h
#	net/mac80211/ht.c
#	net/mac80211/ibss.c
#	net/mac80211/ieee80211_i.h
#	net/mac80211/iface.c
#	net/mac80211/main.c
#	net/mac80211/mesh.c
#	net/mac80211/mlme.c
#	net/mac80211/ocb.c
#	net/mac80211/offchannel.c
#	net/mac80211/sta_info.c
#	net/mac80211/tdls.c
#	net/mac80211/trace.h
#	net/mac80211/tx.c
#	net/mac80211/util.c
#	net/mac80211/vht.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index f7335ea74d6a,6bad95eeb709..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -1905,7 -1916,12 +1906,16 @@@ static void mac80211_hwsim_tx_frame(str
  static void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,
  				     struct ieee80211_vif *vif)
  {
++<<<<<<< HEAD
 +	struct mac80211_hwsim_data *data = arg;
++=======
+ 	struct mac80211_hwsim_link_data *link_data = arg;
+ 	u32 link_id = link_data->link_id;
+ 	struct ieee80211_bss_conf *link_conf;
+ 	struct mac80211_hwsim_data *data =
+ 		container_of(link_data, struct mac80211_hwsim_data,
+ 			     link_data[link_id]);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_hw *hw = data->hw;
  	struct ieee80211_tx_info *info;
  	struct ieee80211_rate *txrate;
@@@ -2111,13 -2139,33 +2125,41 @@@ static void mac80211_hwsim_bcn_en_iter(
  		(*count)++;
  }
  
 -static void mac80211_hwsim_vif_info_changed(struct ieee80211_hw *hw,
 +static void mac80211_hwsim_bss_info_changed(struct ieee80211_hw *hw,
  					    struct ieee80211_vif *vif,
++<<<<<<< HEAD
 +					    struct ieee80211_bss_conf *info,
 +					    u32 changed)
 +{
 +	struct hwsim_vif_priv *vp = (void *)vif->drv_priv;
 +	struct mac80211_hwsim_data *data = hw->priv;
++=======
+ 					    u64 changed)
+ {
+ 	struct hwsim_vif_priv *vp = (void *)vif->drv_priv;
+ 
+ 	hwsim_check_magic(vif);
+ 
+ 	wiphy_dbg(hw->wiphy, "%s(changed=0x%llx vif->addr=%pM)\n",
+ 		  __func__, changed, vif->addr);
+ 
+ 	if (changed & BSS_CHANGED_ASSOC) {
+ 		wiphy_dbg(hw->wiphy, "  ASSOC: assoc=%d aid=%d\n",
+ 			  vif->cfg.assoc, vif->cfg.aid);
+ 		vp->assoc = vif->cfg.assoc;
+ 		vp->aid = vif->cfg.aid;
+ 	}
+ }
+ 
+ static void mac80211_hwsim_link_info_changed(struct ieee80211_hw *hw,
+ 					     struct ieee80211_vif *vif,
+ 					     struct ieee80211_bss_conf *info,
+ 					     u32 link_id, u64 changed)
+ {
+ 	struct hwsim_vif_priv *vp = (void *)vif->drv_priv;
+ 	struct mac80211_hwsim_data *data = hw->priv;
+ 	struct mac80211_hwsim_link_data *link_data = &data->link_data[link_id];
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	hwsim_check_magic(vif);
  
diff --cc include/net/mac80211.h
index f38672457468,044ed417b06f..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -1750,7 -1787,10 +1750,12 @@@ enum ieee80211_offload_flags 
   */
  struct ieee80211_vif {
  	enum nl80211_iftype type;
 -	struct ieee80211_vif_cfg cfg;
  	struct ieee80211_bss_conf bss_conf;
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_bss_conf __rcu *link_conf[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	u16 valid_links;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	u8 addr[ETH_ALEN] __aligned(2);
  	bool p2p;
  
@@@ -3964,10 -4076,20 +3969,22 @@@ struct ieee80211_ops 
  	void (*bss_info_changed)(struct ieee80211_hw *hw,
  				 struct ieee80211_vif *vif,
  				 struct ieee80211_bss_conf *info,
++<<<<<<< HEAD
 +				 u32 changed);
++=======
+ 				 u64 changed);
+ 	void (*vif_cfg_changed)(struct ieee80211_hw *hw,
+ 				struct ieee80211_vif *vif,
+ 				u64 changed);
+ 	void (*link_info_changed)(struct ieee80211_hw *hw,
+ 				  struct ieee80211_vif *vif,
+ 				  struct ieee80211_bss_conf *info,
+ 				  unsigned int link_id,
+ 				  u64 changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 -			unsigned int link_id);
 -	void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 -			unsigned int link_id);
 +	int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 +	void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  
  	u64 (*prepare_multicast)(struct ieee80211_hw *hw,
  				 struct netdev_hw_addr_list *mc_list);
diff --cc net/mac80211/cfg.c
index f176465a1e43,3d66e40af7a9..000000000000
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@@ -39,7 -39,8 +39,12 @@@ static void ieee80211_set_mu_mimo_follo
  		memcpy(sdata->vif.bss_conf.mu_group.position,
  		       params->vht_mumimo_groups + WLAN_MEMBERSHIP_LEN,
  		       WLAN_USER_POSITION_LEN);
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_MU_GROUPS);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_MU_GROUPS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		/* don't care about endianness - just check for 0 */
  		memcpy(&membership, params->vht_mumimo_groups,
  		       WLAN_MEMBERSHIP_LEN);
@@@ -829,9 -841,10 +834,16 @@@ static int ieee80211_set_monitor_channe
  		sdata = wiphy_dereference(local->hw.wiphy,
  					  local->monitor_sdata);
  		if (sdata) {
++<<<<<<< HEAD
 +			ieee80211_vif_release_channel(sdata);
 +			ret = ieee80211_vif_use_channel(sdata, chandef,
 +					IEEE80211_CHANCTX_EXCLUSIVE);
++=======
+ 			ieee80211_link_release_channel(&sdata->deflink);
+ 			ret = ieee80211_link_use_channel(&sdata->deflink,
+ 							 chandef,
+ 							 IEEE80211_CHANCTX_EXCLUSIVE);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
  	} else if (local->open_count == local->monitors) {
  		local->_oper_chandef = *chandef;
@@@ -1001,9 -1018,9 +1014,13 @@@ static int ieee80211_assign_beacon(stru
  	int new_head_len, new_tail_len;
  	int size, err;
  	u32 changed = BSS_CHANGED_BEACON;
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
 +
 +	old = sdata_dereference(sdata->u.ap.beacon, sdata);
  
 -	old = sdata_dereference(link->u.ap.beacon, sdata);
  
  	/* Need to have a beacon head if we don't have one yet */
  	if (!params->head && !old)
@@@ -1133,8 -1151,17 +1150,20 @@@ static int ieee80211_start_ap(struct wi
  		      BSS_CHANGED_TWT;
  	int i, err;
  	int prev_beacon_int;
++<<<<<<< HEAD
++=======
+ 	unsigned int link_id = params->beacon.link_id;
+ 	struct ieee80211_link_data *link;
+ 	struct ieee80211_bss_conf *link_conf;
+ 
+ 	link = sdata_dereference(sdata->link[link_id], sdata);
+ 	if (!link)
+ 		return -ENOLINK;
+ 
+ 	link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	old = sdata_dereference(link->u.ap.beacon, sdata);
 +	old = sdata_dereference(sdata->u.ap.beacon, sdata);
  	if (old)
  		return -EALREADY;
  
@@@ -1239,9 -1267,9 +1268,9 @@@
  	}
  
  	if (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))
 -		link_conf->beacon_tx_rate = params->beacon_rate;
 +		sdata->vif.bss_conf.beacon_tx_rate = params->beacon_rate;
  
- 	err = ieee80211_assign_beacon(sdata, &params->beacon, NULL, NULL);
+ 	err = ieee80211_assign_beacon(sdata, link, &params->beacon, NULL, NULL);
  	if (err < 0)
  		goto error;
  	changed |= err;
@@@ -1273,7 -1304,8 +1302,12 @@@
  	}
  
  	ieee80211_recalc_dtim(local, sdata);
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_vif_cfg_change_notify(sdata, BSS_CHANGED_SSID);
+ 	ieee80211_link_info_change_notify(sdata, link, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	netif_carrier_on(dev);
  	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
@@@ -1292,21 -1324,27 +1326,39 @@@ error
  static int ieee80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
  				   struct cfg80211_beacon_data *params)
  {
++<<<<<<< HEAD
 +	struct ieee80211_sub_if_data *sdata;
 +	struct ieee80211_bss_conf *bss_conf;
 +	struct beacon_data *old;
 +	int err;
++=======
+ 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+ 	struct ieee80211_link_data *link;
+ 	struct beacon_data *old;
+ 	int err;
+ 	struct ieee80211_bss_conf *link_conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 +	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
  	sdata_assert_lock(sdata);
  
+ 	link = sdata_dereference(sdata->link[params->link_id], sdata);
+ 	if (!link)
+ 		return -ENOLINK;
+ 
+ 	link_conf = link->conf;
+ 
  	/* don't allow changing the beacon while a countdown is in place - offset
  	 * of channel switch counter may change
  	 */
 -	if (link_conf->csa_active || link_conf->color_change_active)
 +	if (sdata->vif.bss_conf.csa_active || sdata->vif.bss_conf.color_change_active)
  		return -EBUSY;
  
++<<<<<<< HEAD
 +	old = sdata_dereference(sdata->u.ap.beacon, sdata);
++=======
+ 	old = sdata_dereference(link->u.ap.beacon, sdata);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	if (!old)
  		return -ENOENT;
  
@@@ -1321,7 -1358,7 +1373,11 @@@
  		err |= BSS_CHANGED_HE_BSS_COLOR;
  	}
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, err);
++=======
+ 	ieee80211_link_info_change_notify(sdata, link, err);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	return 0;
  }
  
@@@ -1345,6 -1383,9 +1401,12 @@@ static int ieee80211_stop_ap(struct wip
  	struct fils_discovery_data *old_fils_discovery;
  	struct unsol_bcast_probe_resp_data *old_unsol_bcast_probe_resp;
  	struct cfg80211_chan_def chandef;
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_link_data *link =
+ 		sdata_dereference(sdata->link[link_id], sdata);
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	sdata_assert_lock(sdata);
  
@@@ -1395,15 -1438,16 +1457,20 @@@
  	__sta_info_flush(sdata, true);
  	ieee80211_free_keys(sdata, true);
  
 -	link_conf->enable_beacon = false;
 +	sdata->vif.bss_conf.enable_beacon = false;
  	sdata->beacon_rate_set = false;
 -	sdata->vif.cfg.ssid_len = 0;
 +	sdata->vif.bss_conf.ssid_len = 0;
  	clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);
++=======
+ 	ieee80211_link_info_change_notify(sdata, link,
+ 					  BSS_CHANGED_BEACON_ENABLED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (sdata->wdev.cac_started) {
 -		chandef = link_conf->chandef;
 -		cancel_delayed_work_sync(&link->dfs_cac_timer_work);
 +		chandef = sdata->vif.bss_conf.chandef;
 +		cancel_delayed_work_sync(&sdata->dfs_cac_timer_work);
  		cfg80211_cac_event(sdata->dev, &chandef,
  				   NL80211_RADAR_CAC_ABORTED,
  				   GFP_KERNEL);
@@@ -1548,36 -1592,83 +1615,110 @@@ static void sta_apply_mesh_params(struc
  #endif
  }
  
 -static int sta_link_apply_parameters(struct ieee80211_local *local,
 +static void sta_apply_airtime_params(struct ieee80211_local *local,
  				     struct sta_info *sta,
 -				     struct link_station_parameters *params)
 +				     struct station_parameters *params)
  {
++<<<<<<< HEAD
 +	u8 ac;
 +
 +	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
 +		struct airtime_sched_info *air_sched = &local->airtime[ac];
 +		struct airtime_info *air_info = &sta->airtime[ac];
 +		struct txq_info *txqi;
 +		u8 tid;
 +
 +		spin_lock_bh(&air_sched->lock);
 +		for (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {
 +			if (air_info->weight == params->airtime_weight ||
 +			    !sta->sta.txq[tid] ||
 +			    ac != ieee80211_ac_from_tid(tid))
 +				continue;
++=======
+ 	int ret = 0;
+ 	struct ieee80211_supported_band *sband;
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	u32 link_id = params->link_id < 0 ? 0 : params->link_id;
+ 	struct ieee80211_link_data *link =
+ 		sdata_dereference(sdata->link[link_id], sdata);
+ 	struct link_sta_info *link_sta =
+ 		rcu_dereference_protected(sta->link[link_id],
+ 					  lockdep_is_held(&local->sta_mtx));
+ 
+ 	if (!link || !link_sta)
+ 		return -EINVAL;
+ 
+ 	sband = ieee80211_get_link_sband(link);
+ 	if (!sband)
+ 		return -EINVAL;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
 +
 +			airtime_weight_set(air_info, params->airtime_weight);
 +
 +			txqi = to_txq_info(sta->sta.txq[tid]);
 +			if (RB_EMPTY_NODE(&txqi->schedule_order))
 +				continue;
  
 -	if (params->link_mac) {
 -		memcpy(link_sta->addr, params->link_mac, ETH_ALEN);
 -		memcpy(link_sta->pub->addr, params->link_mac, ETH_ALEN);
 +			ieee80211_update_airtime_weight(local, air_sched,
 +							0, true);
 +		}
 +		spin_unlock_bh(&air_sched->lock);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (params->txpwr_set) {
+ 		link_sta->pub->txpwr.type = params->txpwr.type;
+ 		if (params->txpwr.type == NL80211_TX_POWER_LIMITED)
+ 			link_sta->pub->txpwr.power = params->txpwr.power;
+ 		ret = drv_sta_set_txpwr(local, sdata, sta);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (params->supported_rates &&
+ 	    params->supported_rates_len) {
+ 		ieee80211_parse_bitrates(&link->conf->chandef,
+ 					 sband, params->supported_rates,
+ 					 params->supported_rates_len,
+ 					 &link_sta->pub->supp_rates[sband->band]);
+ 	}
+ 
+ 	if (params->ht_capa)
+ 		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
+ 						  params->ht_capa, link_sta);
+ 
+ 	/* VHT can override some HT caps such as the A-MSDU max length */
+ 	if (params->vht_capa)
+ 		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
+ 						    params->vht_capa, link_sta);
+ 
+ 	if (params->he_capa)
+ 		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
+ 						  (void *)params->he_capa,
+ 						  params->he_capa_len,
+ 						  (void *)params->he_6ghz_capa,
+ 						  link_sta);
+ 
+ 	if (params->eht_capa)
+ 		ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
+ 						    (u8 *)params->he_capa,
+ 						    params->he_capa_len,
+ 						    params->eht_capa,
+ 						    params->eht_capa_len,
+ 						    link_sta);
+ 
+ 	if (params->opmode_notif_used) {
+ 		/* returned value is only needed for rc update, but the
+ 		 * rc isn't initialized here yet, so ignore it
+ 		 */
+ 		__ieee80211_vht_handle_opmode(sdata, link_sta,
+ 					      params->opmode_notif,
+ 					      sband->band);
+ 	}
+ 
+ 	return ret;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  static int sta_apply_parameters(struct ieee80211_local *local,
@@@ -1587,9 -1678,16 +1728,22 @@@
  	int ret = 0;
  	struct ieee80211_supported_band *sband;
  	struct ieee80211_sub_if_data *sdata = sta->sdata;
++<<<<<<< HEAD
 +	u32 mask, set;
 +
 +	sband = ieee80211_get_sband(sdata);
++=======
+ 	u32 link_id = params->link_sta_params.link_id < 0 ?
+ 		      0 : params->link_sta_params.link_id;
+ 	struct ieee80211_link_data *link;
+ 	u32 mask, set;
+ 
+ 	link = sdata_dereference(sdata->link[link_id], sdata);
+ 	if (!link)
+ 		return -ENOLINK;
+ 
+ 	sband = ieee80211_get_link_sband(link);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	if (!sband)
  		return -EINVAL;
  
@@@ -2332,7 -2399,8 +2493,12 @@@ static int ieee80211_update_mesh_config
  	if (_chg_mesh_attr(NL80211_MESHCONF_HT_OPMODE, mask)) {
  		conf->ht_opmode = nconf->ht_opmode;
  		sdata->vif.bss_conf.ht_operation_mode = nconf->ht_opmode;
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_HT);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_HT);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT, mask))
  		conf->dot11MeshHWMPactivePathToRootTimeout =
@@@ -2380,12 -2448,12 +2546,17 @@@ static int ieee80211_join_mesh(struct w
  	sdata->control_port_over_nl80211 = setup->control_port_over_nl80211;
  
  	/* can mesh use other SMPS modes? */
 -	sdata->deflink.smps_mode = IEEE80211_SMPS_OFF;
 -	sdata->deflink.needed_rx_chains = sdata->local->rx_chains;
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	sdata->needed_rx_chains = sdata->local->rx_chains;
  
  	mutex_lock(&sdata->local->mtx);
++<<<<<<< HEAD
 +	err = ieee80211_vif_use_channel(sdata, &setup->chandef,
 +					IEEE80211_CHANCTX_SHARED);
++=======
+ 	err = ieee80211_link_use_channel(&sdata->deflink, &setup->chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&sdata->local->mtx);
  	if (err)
  		return err;
@@@ -2399,7 -2467,7 +2570,11 @@@ static int ieee80211_leave_mesh(struct 
  
  	ieee80211_stop_mesh(sdata);
  	mutex_lock(&sdata->local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 	ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	kfree(sdata->u.mesh.ie);
  	mutex_unlock(&sdata->local->mtx);
  
@@@ -2487,7 -2555,7 +2662,11 @@@ static int ieee80211_change_bss(struct 
  		changed |= BSS_CHANGED_P2P_PS;
  	}
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return 0;
  }
@@@ -2528,7 -2596,8 +2707,12 @@@ static int ieee80211_set_txq_params(str
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_QOS);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_QOS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return 0;
  }
@@@ -2677,7 -2746,8 +2861,12 @@@ static int ieee80211_set_mcast_rate(str
  	memcpy(sdata->vif.bss_conf.mcast_rate, rate,
  	       sizeof(int) * NUM_NL80211_BANDS);
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_MCAST_RATE);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_MCAST_RATE);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return 0;
  }
@@@ -2891,6 -2962,7 +3080,10 @@@ static int ieee80211_testmode_dump(stru
  #endif
  
  int __ieee80211_request_smps_mgd(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
++=======
+ 				 struct ieee80211_link_data *link,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  				 enum ieee80211_smps_mode smps_mode)
  {
  	const u8 *ap;
@@@ -2904,8 -2976,8 +3097,13 @@@
  	if (WARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	old_req = sdata->u.mgd.req_smps;
 +	sdata->u.mgd.req_smps = smps_mode;
++=======
+ 	old_req = link->u.mgd.req_smps;
+ 	link->u.mgd.req_smps = smps_mode;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (old_req == smps_mode &&
  	    smps_mode != IEEE80211_SMPS_AUTOMATIC)
@@@ -2917,10 -2989,10 +3115,17 @@@
  	 * the new value until we associate.
  	 */
  	if (!sdata->u.mgd.associated ||
++<<<<<<< HEAD
 +	    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT)
 +		return 0;
 +
 +	ap = sdata->u.mgd.bssid;
++=======
+ 	    link->conf->chandef.width == NL80211_CHAN_WIDTH_20_NOHT)
+ 		return 0;
+ 
+ 	ap = link->u.mgd.bssid;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	rcu_read_lock();
  	list_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {
@@@ -2944,7 -3016,7 +3149,11 @@@
  	err = ieee80211_send_smps_action(sdata, smps_mode,
  					 ap, ap);
  	if (err)
++<<<<<<< HEAD
 +		sdata->u.mgd.req_smps = old_req;
++=======
+ 		link->u.mgd.req_smps = old_req;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	else if (smps_mode != IEEE80211_SMPS_OFF && tdls_peer_found)
  		ieee80211_teardown_tdls_peers(sdata);
  
@@@ -2972,7 -3045,16 +3181,20 @@@ static int ieee80211_set_power_mgmt(str
  
  	/* no change, but if automatic follow powersave */
  	sdata_lock(sdata);
++<<<<<<< HEAD
 +	__ieee80211_request_smps_mgd(sdata, sdata->u.mgd.req_smps);
++=======
+ 	for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 		struct ieee80211_link_data *link;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 
+ 		if (!link)
+ 			continue;
+ 		__ieee80211_request_smps_mgd(sdata, link,
+ 					     link->u.mgd.req_smps);
+ 	}
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	sdata_unlock(sdata);
  
  	if (ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))
@@@ -3010,7 -3092,8 +3232,12 @@@ static int ieee80211_set_cqm_rssi_confi
  	/* tell the driver upon association, unless already associated */
  	if (sdata->u.mgd.associated &&
  	    sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_CQM);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_CQM);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return 0;
  }
@@@ -3035,7 -3118,8 +3262,12 @@@ static int ieee80211_set_cqm_rssi_range
  	/* tell the driver upon association, unless already associated */
  	if (sdata->u.mgd.associated &&
  	    sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_CQM);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_CQM);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return 0;
  }
@@@ -3123,11 -3208,11 +3355,16 @@@ static int ieee80211_start_radar_detect
  	}
  
  	/* whatever, but channel contexts should not complain about that one */
 -	sdata->deflink.smps_mode = IEEE80211_SMPS_OFF;
 -	sdata->deflink.needed_rx_chains = local->rx_chains;
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	sdata->needed_rx_chains = local->rx_chains;
  
++<<<<<<< HEAD
 +	err = ieee80211_vif_use_channel(sdata, chandef,
 +					IEEE80211_CHANCTX_SHARED);
++=======
+ 	err = ieee80211_link_use_channel(&sdata->deflink, chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	if (err)
  		goto out_unlock;
  
@@@ -3152,10 -3237,10 +3389,14 @@@ static void ieee80211_end_cac(struct wi
  		 * by the time it gets it, sdata->wdev.cac_started
  		 * will no longer be true
  		 */
 -		cancel_delayed_work(&sdata->deflink.dfs_cac_timer_work);
 +		cancel_delayed_work(&sdata->dfs_cac_timer_work);
  
  		if (sdata->wdev.cac_started) {
++<<<<<<< HEAD
 +			ieee80211_vif_release_channel(sdata);
++=======
+ 			ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			sdata->wdev.cac_started = false;
  		}
  	}
@@@ -3299,12 -3384,13 +3540,17 @@@ static int ieee80211_set_after_csa_beac
  
  	switch (sdata->vif.type) {
  	case NL80211_IFTYPE_AP:
 -		if (!sdata->deflink.u.ap.next_beacon)
 +		if (!sdata->u.ap.next_beacon)
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		err = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
++=======
+ 		err = ieee80211_assign_beacon(sdata, &sdata->deflink,
+ 					      sdata->deflink.u.ap.next_beacon,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					      NULL, NULL);
 -		ieee80211_free_next_beacon(&sdata->deflink);
 +		ieee80211_free_next_beacon(sdata);
  
  		if (err < 0)
  			return err;
@@@ -3355,10 -3441,10 +3601,14 @@@ static int __ieee80211_csa_finalize(str
  		 * many times while waiting for other interfaces to use their
  		 * reservations
  		 */
 -		if (sdata->deflink.reserved_ready)
 +		if (sdata->reserved_ready)
  			return 0;
  
++<<<<<<< HEAD
 +		return ieee80211_vif_use_reserved_context(sdata);
++=======
+ 		return ieee80211_link_use_reserved_context(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  
  	if (!cfg80211_chandef_identical(&sdata->vif.bss_conf.chandef,
@@@ -3371,12 -3457,12 +3621,16 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	if (sdata->deflink.csa_block_tx) {
 +	if (sdata->csa_block_tx) {
  		ieee80211_wake_vif_queues(local, sdata,
  					  IEEE80211_QUEUE_STOP_REASON_CSA);
 -		sdata->deflink.csa_block_tx = false;
 +		sdata->csa_block_tx = false;
  	}
  
  	err = drv_post_channel_switch(sdata);
@@@ -3470,9 -3556,11 +3724,11 @@@ static int ieee80211_set_csa_beacon(str
  		csa.n_counter_offsets_presp = params->n_counter_offsets_presp;
  		csa.count = params->count;
  
- 		err = ieee80211_assign_beacon(sdata, &params->beacon_csa, &csa, NULL);
+ 		err = ieee80211_assign_beacon(sdata, &sdata->deflink,
+ 					      &params->beacon_csa, &csa,
+ 					      NULL);
  		if (err < 0) {
 -			ieee80211_free_next_beacon(&sdata->deflink);
 +			ieee80211_free_next_beacon(sdata);
  			return err;
  		}
  		*changed |= err;
@@@ -3623,16 -3711,16 +3879,26 @@@ __ieee80211_channel_switch(struct wiph
  	if (err)
  		goto out;
  
++<<<<<<< HEAD
 +	err = ieee80211_vif_reserve_chanctx(sdata, &params->chandef,
 +					    chanctx->mode,
 +					    params->radar_required);
++=======
+ 	err = ieee80211_link_reserve_chanctx(&sdata->deflink, &params->chandef,
+ 					     chanctx->mode,
+ 					     params->radar_required);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	if (err)
  		goto out;
  
  	/* if reservation is invalid then this will fail */
  	err = ieee80211_check_combinations(sdata, NULL, chanctx->mode, 0);
  	if (err) {
++<<<<<<< HEAD
 +		ieee80211_vif_unreserve_chanctx(sdata);
++=======
+ 		ieee80211_link_unreserve_chanctx(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		goto out;
  	}
  
@@@ -3642,7 -3730,7 +3908,11 @@@
  
  	err = ieee80211_set_csa_beacon(sdata, params, &changed);
  	if (err) {
++<<<<<<< HEAD
 +		ieee80211_vif_unreserve_chanctx(sdata);
++=======
+ 		ieee80211_link_unreserve_chanctx(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		goto out;
  	}
  
@@@ -3658,7 -3747,8 +3928,12 @@@
  					  params->count, params->block_tx);
  
  	if (changed) {
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		drv_channel_switch_beacon(sdata, &params->chandef);
  	} else {
  		/* if the beacon didn't change, we can finalize immediately */
@@@ -3899,9 -3991,15 +4175,21 @@@ static int ieee80211_cfg_get_channel(st
  	int ret = -ENODATA;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 +	if (chanctx_conf) {
 +		*chandef = sdata->vif.bss_conf.chandef;
++=======
+ 	link = rcu_dereference(sdata->link[link_id]);
+ 	if (!link) {
+ 		ret = -ENOLINK;
+ 		goto out;
+ 	}
+ 
+ 	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
+ 	if (chanctx_conf) {
+ 		*chandef = link->conf->chandef;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		ret = 0;
  	} else if (local->open_count > 0 &&
  		   local->open_count == local->monitors &&
@@@ -3957,9 -4058,11 +4247,17 @@@ static int ieee80211_set_ap_chanwidth(s
  	int ret;
  	u32 changed = 0;
  
++<<<<<<< HEAD
 +	ret = ieee80211_vif_change_bandwidth(sdata, chandef, &changed);
 +	if (ret == 0)
 +		ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	link = sdata_dereference(sdata->link[link_id], sdata);
+ 
+ 	ret = ieee80211_link_change_bandwidth(link, chandef, &changed);
+ 	if (ret == 0)
+ 		ieee80211_link_info_change_notify(sdata, link, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return ret;
  }
@@@ -4299,12 -4402,13 +4597,17 @@@ ieee80211_set_after_color_change_beacon
  	case NL80211_IFTYPE_AP: {
  		int ret;
  
 -		if (!sdata->deflink.u.ap.next_beacon)
 +		if (!sdata->u.ap.next_beacon)
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		ret = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
++=======
+ 		ret = ieee80211_assign_beacon(sdata, &sdata->deflink,
+ 					      sdata->deflink.u.ap.next_beacon,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					      NULL, NULL);
 -		ieee80211_free_next_beacon(&sdata->deflink);
 +		ieee80211_free_next_beacon(sdata);
  
  		if (ret < 0)
  			return ret;
@@@ -4344,10 -4448,11 +4647,11 @@@ ieee80211_set_color_change_beacon(struc
  			params->counter_offset_presp;
  		color_change.count = params->count;
  
- 		err = ieee80211_assign_beacon(sdata, &params->beacon_color_change,
+ 		err = ieee80211_assign_beacon(sdata, &sdata->deflink,
+ 					      &params->beacon_color_change,
  					      NULL, &color_change);
  		if (err < 0) {
 -			ieee80211_free_next_beacon(&sdata->deflink);
 +			ieee80211_free_next_beacon(sdata);
  			return err;
  		}
  		*changed |= err;
@@@ -4367,7 -4472,7 +4671,11 @@@ ieee80211_color_change_bss_config_notif
  	sdata->vif.bss_conf.he_bss_color.enabled = enable;
  	changed |= BSS_CHANGED_HE_BSS_COLOR;
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (!sdata->vif.bss_conf.nontransmitted && sdata->vif.mbssid_tx_vif) {
  		struct ieee80211_sub_if_data *child;
@@@ -4377,8 -4482,9 +4685,14 @@@
  			if (child != sdata && child->vif.mbssid_tx_vif == &sdata->vif) {
  				child->vif.bss_conf.he_bss_color.color = color;
  				child->vif.bss_conf.he_bss_color.enabled = enable;
++<<<<<<< HEAD
 +				ieee80211_bss_info_change_notify(child,
 +								 BSS_CHANGED_HE_BSS_COLOR);
++=======
+ 				ieee80211_link_info_change_notify(child,
+ 								  &child->deflink,
+ 								  BSS_CHANGED_HE_BSS_COLOR);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			}
  		}
  		mutex_unlock(&sdata->local->iflist_mtx);
diff --cc net/mac80211/chan.c
index 37035c3e5f8a,8d384956fde5..000000000000
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@@ -67,12 -67,12 +67,21 @@@ static bool ieee80211_can_create_new_ch
  }
  
  static struct ieee80211_chanctx *
++<<<<<<< HEAD
 +ieee80211_vif_get_chanctx(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_local *local __maybe_unused = sdata->local;
 +	struct ieee80211_chanctx_conf *conf;
 +
 +	conf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,
++=======
+ ieee80211_link_get_chanctx(struct ieee80211_link_data *link)
+ {
+ 	struct ieee80211_local *local __maybe_unused = link->sdata->local;
+ 	struct ieee80211_chanctx_conf *conf;
+ 
+ 	conf = rcu_dereference_protected(link->conf->chanctx_conf,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					 lockdep_is_held(&local->chanctx_mtx));
  	if (!conf)
  		return NULL;
@@@ -112,9 -112,11 +121,15 @@@ ieee80211_chanctx_non_reserved_chandef(
  
  	lockdep_assert_held(&local->chanctx_mtx);
  
 -	list_for_each_entry(link, &ctx->assigned_links,
 +	list_for_each_entry(sdata, &ctx->assigned_vifs,
  			    assigned_chanctx_list) {
++<<<<<<< HEAD
 +		if (sdata->reserved_chanctx != NULL)
++=======
+ 		struct ieee80211_bss_conf *link_conf = link->conf;
+ 
+ 		if (link->reserved_chanctx)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			continue;
  
  		if (!compat)
@@@ -238,14 -250,71 +252,74 @@@ ieee80211_get_max_required_bw(struct ie
  		    !(sta->sdata->bss && sta->sdata->bss == sdata->bss))
  			continue;
  
 -		max_bw = max(max_bw, ieee80211_get_sta_bw(sta, link_id));
 +		max_bw = max(max_bw, ieee80211_get_sta_bw(sta));
  	}
+ 
+ 	return max_bw;
+ }
+ 
+ static enum nl80211_chan_width
++<<<<<<< HEAD
++=======
+ ieee80211_get_chanctx_vif_max_required_bw(struct ieee80211_sub_if_data *sdata,
+ 					  struct ieee80211_chanctx_conf *conf)
+ {
+ 	enum nl80211_chan_width max_bw = NL80211_CHAN_WIDTH_20_NOHT;
+ 	struct ieee80211_vif *vif = &sdata->vif;
+ 	int link_id;
+ 
+ 	rcu_read_lock();
+ 	for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 		enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20_NOHT;
+ 		struct ieee80211_bss_conf *link_conf =
+ 			rcu_dereference(sdata->vif.link_conf[link_id]);
+ 
+ 		if (!link_conf)
+ 			continue;
+ 
+ 		if (rcu_access_pointer(link_conf->chanctx_conf) != conf)
+ 			continue;
+ 
+ 		switch (vif->type) {
+ 		case NL80211_IFTYPE_AP:
+ 		case NL80211_IFTYPE_AP_VLAN:
+ 			width = ieee80211_get_max_required_bw(sdata, link_id);
+ 			break;
+ 		case NL80211_IFTYPE_STATION:
+ 			/*
+ 			 * The ap's sta->bandwidth is not set yet at this
+ 			 * point, so take the width from the chandef, but
+ 			 * account also for TDLS peers
+ 			 */
+ 			width = max(link_conf->chandef.width,
+ 				    ieee80211_get_max_required_bw(sdata, link_id));
+ 			break;
+ 		case NL80211_IFTYPE_P2P_DEVICE:
+ 		case NL80211_IFTYPE_NAN:
+ 			continue;
+ 		case NL80211_IFTYPE_ADHOC:
+ 		case NL80211_IFTYPE_MESH_POINT:
+ 		case NL80211_IFTYPE_OCB:
+ 			width = link_conf->chandef.width;
+ 			break;
+ 		case NL80211_IFTYPE_WDS:
+ 		case NL80211_IFTYPE_UNSPECIFIED:
+ 		case NUM_NL80211_IFTYPES:
+ 		case NL80211_IFTYPE_MONITOR:
+ 		case NL80211_IFTYPE_P2P_CLIENT:
+ 		case NL80211_IFTYPE_P2P_GO:
+ 			WARN_ON_ONCE(1);
+ 		}
+ 
+ 		max_bw = max(max_bw, width);
+ 	}
  	rcu_read_unlock();
  
  	return max_bw;
  }
  
  static enum nl80211_chan_width
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  ieee80211_get_chanctx_max_required_bw(struct ieee80211_local *local,
  				      struct ieee80211_chanctx_conf *conf)
  {
@@@ -298,7 -335,8 +372,12 @@@
  
  	/* use the configured bandwidth in case of monitor interface */
  	sdata = rcu_dereference(local->monitor_sdata);
++<<<<<<< HEAD
 +	if (sdata && rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) == conf)
++=======
+ 	if (sdata &&
+ 	    rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) == conf)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		max_bw = max(max_bw, conf->def.width);
  
  	rcu_read_unlock();
@@@ -368,24 -408,36 +447,31 @@@ static void ieee80211_chan_bw_change(st
  		if (!ieee80211_sdata_running(sta->sdata))
  			continue;
  
++<<<<<<< HEAD
 +		if (rcu_access_pointer(sta->sdata->vif.bss_conf.chanctx_conf) !=
 +		    &ctx->conf)
 +			continue;
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sta->sdata->link); link_id++) {
+ 			struct ieee80211_bss_conf *link_conf =
+ 				rcu_dereference(sdata->vif.link_conf[link_id]);
+ 			struct link_sta_info *link_sta;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -			if (!link_conf)
 -				continue;
 -
 -			if (rcu_access_pointer(link_conf->chanctx_conf) != &ctx->conf)
 -				continue;
 -
 -			link_sta = rcu_dereference(sta->link[link_id]);
 -			if (!link_sta)
 -				continue;
 -
 -			new_sta_bw = ieee80211_sta_cur_vht_bw(link_sta);
 +		new_sta_bw = ieee80211_sta_cur_vht_bw(sta);
  
 -			/* nothing change */
 -			if (new_sta_bw == link_sta->pub->bandwidth)
 -				continue;
 +		/* nothing change */
 +		if (new_sta_bw == sta->sta.bandwidth)
 +			continue;
  
 -			/* vif changed to narrow BW and narrow BW for station wasn't
 -			 * requested or vise versa */
 -			if ((new_sta_bw < link_sta->pub->bandwidth) == !narrowed)
 -				continue;
 +		/* vif changed to narrow BW and narrow BW for station wasn't
 +		 * requested or vise versa */
 +		if ((new_sta_bw < sta->sta.bandwidth) == !narrowed)
 +			continue;
  
 -			link_sta->pub->bandwidth = new_sta_bw;
 -			rate_control_rate_update(local, sband, sta, link_id,
 -						 IEEE80211_RC_BW_CHANGED);
 -		}
 +		sta->sta.bandwidth = new_sta_bw;
 +		rate_control_rate_update(local, sband, sta,
 +					 IEEE80211_RC_BW_CHANGED);
  	}
  	rcu_read_unlock();
  }
@@@ -508,9 -560,17 +594,23 @@@ bool ieee80211_is_radar_required(struc
  
  	rcu_read_lock();
  	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
++<<<<<<< HEAD
 +		if (sdata->radar_required) {
 +			rcu_read_unlock();
 +			return true;
++=======
+ 		unsigned int link_id;
+ 
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			struct ieee80211_link_data *link;
+ 
+ 			link = rcu_dereference(sdata->link[link_id]);
+ 
+ 			if (link && link->radar_required) {
+ 				rcu_read_unlock();
+ 				return true;
+ 			}
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
  	}
  	rcu_read_unlock();
@@@ -531,15 -591,27 +631,35 @@@ ieee80211_chanctx_radar_required(struc
  
  	rcu_read_lock();
  	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 -		unsigned int link_id;
 -
  		if (!ieee80211_sdata_running(sdata))
  			continue;
++<<<<<<< HEAD
 +		if (rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) != conf)
 +			continue;
 +		if (!sdata->radar_required)
 +			continue;
 +
 +		required = true;
 +		break;
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			struct ieee80211_link_data *link;
+ 
+ 			link = rcu_dereference(sdata->link[link_id]);
+ 			if (!link)
+ 				continue;
+ 
+ 			if (rcu_access_pointer(link->conf->chanctx_conf) != conf)
+ 				continue;
+ 			if (!link->radar_required)
+ 				continue;
+ 			required = true;
+ 			break;
+ 		}
+ 
+ 		if (required)
+ 			break;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  	rcu_read_unlock();
  
@@@ -694,13 -766,24 +814,19 @@@ void ieee80211_recalc_chanctx_chantype(
  		if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
  			continue;
  
++<<<<<<< HEAD
 +		if (!compat)
 +			compat = &sdata->vif.bss_conf.chandef;
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			struct ieee80211_bss_conf *link_conf =
+ 				rcu_dereference(sdata->vif.link_conf[link_id]);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -			if (!link_conf)
 -				continue;
 -
 -			if (rcu_access_pointer(link_conf->chanctx_conf) != conf)
 -				continue;
 -
 -			if (!compat)
 -				compat = &link_conf->chandef;
 -
 -			compat = cfg80211_chandef_compatible(&link_conf->chandef,
 -							     compat);
 -			if (WARN_ON_ONCE(!compat))
 -				break;
 -		}
 +		compat = cfg80211_chandef_compatible(
 +				&sdata->vif.bss_conf.chandef, compat);
 +		if (WARN_ON_ONCE(!compat))
 +			break;
  	}
  
  	/* TDLS peers can sometimes affect the chandef width */
@@@ -759,7 -844,7 +885,11 @@@ static int ieee80211_assign_vif_chanctx
  	if (WARN_ON(sdata->vif.type == NL80211_IFTYPE_NAN))
  		return -ENOTSUPP;
  
++<<<<<<< HEAD
 +	conf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,
++=======
+ 	conf = rcu_dereference_protected(link->conf->chanctx_conf,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					 lockdep_is_held(&local->chanctx_mtx));
  
  	if (conf) {
@@@ -781,9 -866,9 +911,13 @@@
  	}
  
  out:
++<<<<<<< HEAD
 +	rcu_assign_pointer(sdata->vif.bss_conf.chanctx_conf, conf);
++=======
+ 	rcu_assign_pointer(link->conf->chanctx_conf, conf);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	sdata->vif.cfg.idle = !conf;
 +	sdata->vif.bss_conf.idle = !conf;
  
  	if (curr_ctx && ieee80211_chanctx_num_assigned(local, curr_ctx) > 0) {
  		ieee80211_recalc_chanctx_chantype(local, curr_ctx);
@@@ -845,30 -921,42 +979,65 @@@ void ieee80211_recalc_smps_chanctx(stru
  		case NL80211_IFTYPE_OCB:
  			break;
  		default:
 -			continue;
 +			WARN_ON_ONCE(1);
  		}
  
++<<<<<<< HEAD
 +		switch (sdata->smps_mode) {
 +		default:
 +			WARN_ONCE(1, "Invalid SMPS mode %d\n",
 +				  sdata->smps_mode);
 +			fallthrough;
 +		case IEEE80211_SMPS_OFF:
 +			needed_static = sdata->needed_rx_chains;
 +			needed_dynamic = sdata->needed_rx_chains;
 +			break;
 +		case IEEE80211_SMPS_DYNAMIC:
 +			needed_static = 1;
 +			needed_dynamic = sdata->needed_rx_chains;
 +			break;
 +		case IEEE80211_SMPS_STATIC:
 +			needed_static = 1;
 +			needed_dynamic = 1;
 +			break;
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			struct ieee80211_link_data *link;
+ 
+ 			link = rcu_dereference(sdata->link[link_id]);
+ 
+ 			if (!link)
+ 				continue;
+ 
+ 			if (rcu_access_pointer(link->conf->chanctx_conf) != &chanctx->conf)
+ 				continue;
+ 
+ 			switch (link->smps_mode) {
+ 			default:
+ 				WARN_ONCE(1, "Invalid SMPS mode %d\n",
+ 					  link->smps_mode);
+ 				fallthrough;
+ 			case IEEE80211_SMPS_OFF:
+ 				needed_static = link->needed_rx_chains;
+ 				needed_dynamic = link->needed_rx_chains;
+ 				break;
+ 			case IEEE80211_SMPS_DYNAMIC:
+ 				needed_static = 1;
+ 				needed_dynamic = link->needed_rx_chains;
+ 				break;
+ 			case IEEE80211_SMPS_STATIC:
+ 				needed_static = 1;
+ 				needed_dynamic = 1;
+ 				break;
+ 			}
+ 
+ 			rx_chains_static = max(rx_chains_static, needed_static);
+ 			rx_chains_dynamic = max(rx_chains_dynamic, needed_dynamic);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
 +
 +		rx_chains_static = max(rx_chains_static, needed_static);
 +		rx_chains_dynamic = max(rx_chains_dynamic, needed_dynamic);
  	}
  
  	/* Disable SMPS for the monitor interface */
@@@ -899,9 -987,12 +1068,15 @@@
  }
  
  static void
 -__ieee80211_link_copy_chanctx_to_vlans(struct ieee80211_link_data *link,
 -				       bool clear)
 +__ieee80211_vif_copy_chanctx_to_vlans(struct ieee80211_sub_if_data *sdata,
 +				      bool clear)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	unsigned int link_id = link->link_id;
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local __maybe_unused = sdata->local;
  	struct ieee80211_sub_if_data *vlan;
  	struct ieee80211_chanctx_conf *conf;
@@@ -924,14 -1015,23 +1099,28 @@@
  	if (clear)
  		conf = NULL;
  
++<<<<<<< HEAD
 +	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
 +		rcu_assign_pointer(vlan->vif.bss_conf.chanctx_conf, conf);
++=======
+ 	rcu_read_lock();
+ 	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {
+ 		struct ieee80211_bss_conf *vlan_conf;
+ 
+ 		vlan_conf = rcu_dereference(vlan->vif.link_conf[link_id]);
+ 		if (WARN_ON(!vlan_conf))
+ 			continue;
+ 
+ 		rcu_assign_pointer(vlan_conf->chanctx_conf, conf);
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
 -void ieee80211_link_copy_chanctx_to_vlans(struct ieee80211_link_data *link,
 -					  bool clear)
 +void ieee80211_vif_copy_chanctx_to_vlans(struct ieee80211_sub_if_data *sdata,
 +					 bool clear)
  {
 -	struct ieee80211_local *local = link->sdata->local;
 +	struct ieee80211_local *local = sdata->local;
  
  	mutex_lock(&local->chanctx_mtx);
  
@@@ -1101,23 -1205,36 +1290,46 @@@ ieee80211_vif_chanctx_reservation_compl
  }
  
  static void
 -ieee80211_link_update_chandef(struct ieee80211_link_data *link,
 -			      const struct cfg80211_chan_def *chandef)
 +ieee80211_vif_update_chandef(struct ieee80211_sub_if_data *sdata,
 +			     const struct cfg80211_chan_def *chandef)
  {
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 -	unsigned int link_id = link->link_id;
  	struct ieee80211_sub_if_data *vlan;
  
++<<<<<<< HEAD
 +	sdata->vif.bss_conf.chandef = *chandef;
++=======
+ 	link->conf->chandef = *chandef;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (sdata->vif.type != NL80211_IFTYPE_AP)
  		return;
  
++<<<<<<< HEAD
 +	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
 +		vlan->vif.bss_conf.chandef = *chandef;
++=======
+ 	rcu_read_lock();
+ 	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {
+ 		struct ieee80211_bss_conf *vlan_conf;
+ 
+ 		vlan_conf = rcu_dereference(vlan->vif.link_conf[link_id]);
+ 		if (WARN_ON(!vlan_conf))
+ 			continue;
+ 
+ 		vlan_conf->chandef = *chandef;
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  static int
 -ieee80211_link_use_reserved_reassign(struct ieee80211_link_data *link)
 +ieee80211_vif_use_reserved_reassign(struct ieee80211_sub_if_data *sdata)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_vif_chanctx_switch vif_chsw[1] = {};
  	struct ieee80211_chanctx *old_ctx, *new_ctx;
@@@ -1188,25 -1306,26 +1400,38 @@@
  	ieee80211_recalc_radar_chanctx(local, new_ctx);
  
  	if (changed)
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 		ieee80211_link_info_change_notify(sdata, link, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  out:
 -	ieee80211_link_chanctx_reservation_complete(link);
 +	ieee80211_vif_chanctx_reservation_complete(sdata);
  	return err;
  }
  
  static int
 -ieee80211_link_use_reserved_assign(struct ieee80211_link_data *link)
 +ieee80211_vif_use_reserved_assign(struct ieee80211_sub_if_data *sdata)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_chanctx *old_ctx, *new_ctx;
  	const struct cfg80211_chan_def *chandef;
  	int err;
  
++<<<<<<< HEAD
 +	old_ctx = ieee80211_vif_get_chanctx(sdata);
 +	new_ctx = sdata->reserved_chanctx;
++=======
+ 	old_ctx = ieee80211_link_get_chanctx(link);
+ 	new_ctx = link->reserved_chanctx;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	if (WARN_ON(!link->reserved_ready))
 +	if (WARN_ON(!sdata->reserved_ready))
  		return -EINVAL;
  
  	if (WARN_ON(old_ctx))
@@@ -1508,14 -1631,16 +1733,19 @@@ static int ieee80211_vif_use_reserved_s
  			goto err;
  		}
  
 -		list_for_each_entry(link, &ctx->reserved_links,
 +		list_for_each_entry(sdata, &ctx->reserved_vifs,
  				    reserved_chanctx_list) {
++<<<<<<< HEAD
++=======
+ 			struct ieee80211_sub_if_data *sdata = link->sdata;
+ 			struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			u32 changed = 0;
  
 -			if (!ieee80211_link_has_in_place_reservation(link))
 +			if (!ieee80211_vif_has_in_place_reservation(sdata))
  				continue;
  
 -			rcu_assign_pointer(link_conf->chanctx_conf,
 +			rcu_assign_pointer(sdata->vif.bss_conf.chanctx_conf,
  					   &ctx->conf);
  
  			if (sdata->vif.type == NL80211_IFTYPE_AP)
@@@ -1524,16 -1649,16 +1754,22 @@@
  
  			ieee80211_check_fast_xmit_iface(sdata);
  
 -			link->radar_required = link->reserved_radar_required;
 +			sdata->radar_required = sdata->reserved_radar_required;
  
 -			if (link_conf->chandef.width != link->reserved_chandef.width)
 +			if (sdata->vif.bss_conf.chandef.width !=
 +			    sdata->reserved_chandef.width)
  				changed = BSS_CHANGED_BANDWIDTH;
  
 -			ieee80211_link_update_chandef(link, &link->reserved_chandef);
 +			ieee80211_vif_update_chandef(sdata, &sdata->reserved_chandef);
  			if (changed)
++<<<<<<< HEAD
 +				ieee80211_bss_info_change_notify(sdata,
 +								 changed);
++=======
+ 				ieee80211_link_info_change_notify(sdata,
+ 								  link,
+ 								  changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  			ieee80211_recalc_txpower(sdata, false);
  		}
@@@ -1626,8 -1751,10 +1862,13 @@@ err
  	return err;
  }
  
 -static void __ieee80211_link_release_channel(struct ieee80211_link_data *link)
 +static void __ieee80211_vif_release_channel(struct ieee80211_sub_if_data *sdata)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_chanctx_conf *conf;
  	struct ieee80211_chanctx *ctx;
@@@ -1663,10 -1788,11 +1904,14 @@@
  		ieee80211_vif_use_reserved_switch(local);
  }
  
 -int ieee80211_link_use_channel(struct ieee80211_link_data *link,
 -			       const struct cfg80211_chan_def *chandef,
 -			       enum ieee80211_chanctx_mode mode)
 +int ieee80211_vif_use_channel(struct ieee80211_sub_if_data *sdata,
 +			      const struct cfg80211_chan_def *chandef,
 +			      enum ieee80211_chanctx_mode mode)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_chanctx *ctx;
  	u8 radar_detect_width = 0;
@@@ -1686,7 -1812,7 +1931,11 @@@
  	if (ret > 0)
  		radar_detect_width = BIT(chandef->width);
  
++<<<<<<< HEAD
 +	sdata->radar_required = ret;
++=======
+ 	link->radar_required = ret;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	ret = ieee80211_check_combinations(sdata, chandef, mode,
  					   radar_detect_width);
@@@ -1784,10 -1911,12 +2033,15 @@@ int ieee80211_vif_use_reserved_context(
  	return 0;
  }
  
 -int ieee80211_link_change_bandwidth(struct ieee80211_link_data *link,
 -				    const struct cfg80211_chan_def *chandef,
 -				    u32 *changed)
 +int ieee80211_vif_change_bandwidth(struct ieee80211_sub_if_data *sdata,
 +				   const struct cfg80211_chan_def *chandef,
 +				   u32 *changed)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_chanctx_conf *conf;
  	struct ieee80211_chanctx *ctx;
@@@ -1867,8 -1998,12 +2121,15 @@@ void ieee80211_vif_release_channel(stru
  	mutex_unlock(&sdata->local->chanctx_mtx);
  }
  
 -void ieee80211_link_vlan_copy_chanctx(struct ieee80211_link_data *link)
 +void ieee80211_vif_vlan_copy_chanctx(struct ieee80211_sub_if_data *sdata)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	unsigned int link_id = link->link_id;
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
+ 	struct ieee80211_bss_conf *ap_conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_sub_if_data *ap;
  	struct ieee80211_chanctx_conf *conf;
@@@ -1880,9 -2015,12 +2141,18 @@@
  
  	mutex_lock(&local->chanctx_mtx);
  
++<<<<<<< HEAD
 +	conf = rcu_dereference_protected(ap->vif.bss_conf.chanctx_conf,
 +					 lockdep_is_held(&local->chanctx_mtx));
 +	rcu_assign_pointer(sdata->vif.bss_conf.chanctx_conf, conf);
++=======
+ 	rcu_read_lock();
+ 	ap_conf = rcu_dereference(ap->vif.link_conf[link_id]);
+ 	conf = rcu_dereference_protected(ap_conf->chanctx_conf,
+ 					 lockdep_is_held(&local->chanctx_mtx));
+ 	rcu_assign_pointer(link_conf->chanctx_conf, conf);
+ 	rcu_read_unlock();
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&local->chanctx_mtx);
  }
  
diff --cc net/mac80211/debugfs_netdev.c
index cf71484658c6,1e5b041a5cea..000000000000
--- a/net/mac80211/debugfs_netdev.c
+++ b/net/mac80211/debugfs_netdev.c
@@@ -256,7 -256,7 +256,11 @@@ static int ieee80211_set_smps(struct ie
  		return -EOPNOTSUPP;
  
  	sdata_lock(sdata);
++<<<<<<< HEAD
 +	err = __ieee80211_request_smps_mgd(sdata, smps_mode);
++=======
+ 	err = __ieee80211_request_smps_mgd(sdata, &sdata->deflink, smps_mode);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	sdata_unlock(sdata);
  
  	return err;
diff --cc net/mac80211/driver-ops.h
index 173a201d5e6d,ee3ac1a01bb0..000000000000
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@@ -147,10 -147,28 +147,35 @@@ static inline int drv_config(struct iee
  	return ret;
  }
  
++<<<<<<< HEAD
 +static inline void drv_bss_info_changed(struct ieee80211_local *local,
 +					struct ieee80211_sub_if_data *sdata,
 +					struct ieee80211_bss_conf *info,
 +					u32 changed)
++=======
+ static inline void drv_vif_cfg_changed(struct ieee80211_local *local,
+ 				       struct ieee80211_sub_if_data *sdata,
+ 				       u64 changed)
+ {
+ 	might_sleep();
+ 
+ 	if (!check_sdata_in_driver(sdata))
+ 		return;
+ 
+ 	trace_drv_vif_cfg_changed(local, sdata, changed);
+ 	if (local->ops->vif_cfg_changed)
+ 		local->ops->vif_cfg_changed(&local->hw, &sdata->vif, changed);
+ 	else if (local->ops->bss_info_changed)
+ 		local->ops->bss_info_changed(&local->hw, &sdata->vif,
+ 					     &sdata->vif.bss_conf, changed);
+ 	trace_drv_return_void(local);
+ }
+ 
+ static inline void drv_link_info_changed(struct ieee80211_local *local,
+ 					 struct ieee80211_sub_if_data *sdata,
+ 					 struct ieee80211_bss_conf *info,
+ 					 int link_id, u64 changed)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  {
  	might_sleep();
  
@@@ -172,9 -190,13 +197,19 @@@
  	if (!check_sdata_in_driver(sdata))
  		return;
  
++<<<<<<< HEAD
 +	trace_drv_bss_info_changed(local, sdata, info, changed);
 +	if (local->ops->bss_info_changed)
 +		local->ops->bss_info_changed(&local->hw, &sdata->vif, info, changed);
++=======
+ 	trace_drv_link_info_changed(local, sdata, info, link_id, changed);
+ 	if (local->ops->link_info_changed)
+ 		local->ops->link_info_changed(&local->hw, &sdata->vif,
+ 					      info, link_id, changed);
+ 	else if (local->ops->bss_info_changed)
+ 		local->ops->bss_info_changed(&local->hw, &sdata->vif,
+ 					     info, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	trace_drv_return_void(local);
  }
  
@@@ -969,9 -996,9 +1004,13 @@@ static inline int drv_start_ap(struct i
  	if (!check_sdata_in_driver(sdata))
  		return -EIO;
  
++<<<<<<< HEAD
 +	trace_drv_start_ap(local, sdata, &sdata->vif.bss_conf);
++=======
+ 	trace_drv_start_ap(local, sdata, link_id);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	if (local->ops->start_ap)
 -		ret = local->ops->start_ap(&local->hw, &sdata->vif, link_id);
 +		ret = local->ops->start_ap(&local->hw, &sdata->vif);
  	trace_drv_return_int(local, ret);
  	return ret;
  }
diff --cc net/mac80211/ht.c
index 2eb7641f5556,ea7ce87b7ec4..000000000000
--- a/net/mac80211/ht.c
+++ b/net/mac80211/ht.c
@@@ -138,8 -138,10 +138,13 @@@ void ieee80211_apply_htcap_overrides(st
  bool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,
  				       struct ieee80211_supported_band *sband,
  				       const struct ieee80211_ht_cap *ht_cap_ie,
 -				       struct link_sta_info *link_sta)
 +				       struct sta_info *sta)
  {
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_bss_conf *link_conf;
+ 	struct sta_info *sta = link_sta->sta;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	struct ieee80211_sta_ht_cap ht_cap, own_cap;
  	u8 ampdu_info, tx_mcs_set_cap;
  	int i, max_tx_streams;
@@@ -243,11 -246,18 +249,22 @@@
  		sta->sta.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_HT_3839;
  
   apply:
 -	changed = memcmp(&link_sta->pub->ht_cap, &ht_cap, sizeof(ht_cap));
 +	changed = memcmp(&sta->sta.ht_cap, &ht_cap, sizeof(ht_cap));
  
 -	memcpy(&link_sta->pub->ht_cap, &ht_cap, sizeof(ht_cap));
 +	memcpy(&sta->sta.ht_cap, &ht_cap, sizeof(ht_cap));
  
++<<<<<<< HEAD
 +	switch (sdata->vif.bss_conf.chandef.width) {
++=======
+ 	rcu_read_lock();
+ 	link_conf = rcu_dereference(sdata->vif.link_conf[link_sta->link_id]);
+ 	if (WARN_ON(!link_conf))
+ 		width = NL80211_CHAN_WIDTH_20_NOHT;
+ 	else
+ 		width = link_conf->chandef.width;
+ 
+ 	switch (width) {
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	default:
  		WARN_ON_ONCE(1);
  		fallthrough;
@@@ -263,10 -273,11 +280,11 @@@
  				IEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;
  		break;
  	}
+ 	rcu_read_unlock();
  
 -	link_sta->pub->bandwidth = bw;
 +	sta->sta.bandwidth = bw;
  
 -	link_sta->cur_max_bandwidth =
 +	sta->cur_max_bandwidth =
  		ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
  				IEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;
  
@@@ -541,29 -552,37 +559,55 @@@ int ieee80211_send_smps_action(struct i
  
  void ieee80211_request_smps_mgd_work(struct work_struct *work)
  {
 -	struct ieee80211_link_data *link =
 -		container_of(work, struct ieee80211_link_data,
 +	struct ieee80211_sub_if_data *sdata =
 +		container_of(work, struct ieee80211_sub_if_data,
  			     u.mgd.request_smps_work);
  
++<<<<<<< HEAD
 +	sdata_lock(sdata);
 +	__ieee80211_request_smps_mgd(sdata, sdata->u.mgd.driver_smps_mode);
 +	sdata_unlock(sdata);
++=======
+ 	sdata_lock(link->sdata);
+ 	__ieee80211_request_smps_mgd(link->sdata, link,
+ 				     link->u.mgd.driver_smps_mode);
+ 	sdata_unlock(link->sdata);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
 -void ieee80211_request_smps(struct ieee80211_vif *vif, unsigned int link_id,
 +void ieee80211_request_smps(struct ieee80211_vif *vif,
  			    enum ieee80211_smps_mode smps_mode)
  {
  	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_link_data *link;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (WARN_ON_ONCE(vif->type != NL80211_IFTYPE_STATION))
  		return;
  
++<<<<<<< HEAD
 +	if (sdata->u.mgd.driver_smps_mode == smps_mode)
 +		return;
 +
 +	sdata->u.mgd.driver_smps_mode = smps_mode;
 +	ieee80211_queue_work(&sdata->local->hw,
 +			     &sdata->u.mgd.request_smps_work);
++=======
+ 	rcu_read_lock();
+ 	link = rcu_dereference(sdata->link[link_id]);
+ 	if (WARN_ON(!link))
+ 		goto out;
+ 
+ 	if (link->u.mgd.driver_smps_mode == smps_mode)
+ 		goto out;
+ 
+ 	link->u.mgd.driver_smps_mode = smps_mode;
+ 	ieee80211_queue_work(&sdata->local->hw, &link->u.mgd.request_smps_work);
+ out:
+ 	rcu_read_unlock();
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  /* this might change ... don't want non-open drivers using it */
  EXPORT_SYMBOL_GPL(ieee80211_request_smps);
diff --cc net/mac80211/ibss.c
index ff7a39ac5d28,393c7595bfa4..000000000000
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@@ -300,8 -300,8 +300,13 @@@ static void __ieee80211_sta_join_ibss(s
  	radar_required = err;
  
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	if (ieee80211_vif_use_channel(sdata, &chandef,
 +				      ifibss->fixed_channel ?
++=======
+ 	if (ieee80211_link_use_channel(&sdata->deflink, &chandef,
+ 				       ifibss->fixed_channel ?
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					IEEE80211_CHANCTX_SHARED :
  					IEEE80211_CHANCTX_EXCLUSIVE)) {
  		sdata_info(sdata, "Failed to join IBSS, no channel context\n");
@@@ -370,7 -370,7 +375,11 @@@
  		RCU_INIT_POINTER(ifibss->presp, NULL);
  		kfree_rcu(presp, rcu_head);
  		mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +		ieee80211_vif_release_channel(sdata);
++=======
+ 		ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		mutex_unlock(&local->mtx);
  		sdata_info(sdata, "Failed to join IBSS, driver failure: %d\n",
  			   err);
@@@ -722,7 -722,7 +731,11 @@@ static void ieee80211_ibss_disconnect(s
  						BSS_CHANGED_IBSS);
  	drv_leave_ibss(local, sdata);
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 	ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&local->mtx);
  }
  
@@@ -1847,10 -1848,10 +1860,14 @@@ int ieee80211_ibss_join(struct ieee8021
  		| IEEE80211_HT_PARAM_RIFS_MODE;
  
  	changed |= BSS_CHANGED_HT | BSS_CHANGED_MCAST_RATE;
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	sdata->deflink.smps_mode = IEEE80211_SMPS_OFF;
 -	sdata->deflink.needed_rx_chains = local->rx_chains;
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	sdata->needed_rx_chains = local->rx_chains;
  	sdata->control_port_over_nl80211 = params->control_port_over_nl80211;
  
  	ieee80211_queue_work(&local->hw, &sdata->work);
diff --cc net/mac80211/ieee80211_i.h
index 92293634a474,f6791b47f78f..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -903,6 -868,103 +903,106 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool have_beacon;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ 
+ 	struct ieee80211_bss_conf *conf;
+ };
+ 
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
@@@ -1015,6 -1046,9 +1115,12 @@@
  		struct ieee80211_if_nan nan;
  	} u;
  
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_link_data deflink;
+ 	struct ieee80211_link_data __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
+ 
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  #ifdef CONFIG_MAC80211_DEBUGFS
  	struct {
  		struct dentry *subdir_stations;
@@@ -1835,7 -1717,12 +1939,16 @@@ u64 ieee80211_calculate_rx_timestamp(st
  int ieee80211_hw_config(struct ieee80211_local *local, u32 changed);
  void ieee80211_tx_set_protected(struct ieee80211_tx_data *tx);
  void ieee80211_bss_info_change_notify(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +				      u32 changed);
++=======
+ 				      u64 changed);
+ void ieee80211_vif_cfg_change_notify(struct ieee80211_sub_if_data *sdata,
+ 				     u64 changed);
+ void ieee80211_link_info_change_notify(struct ieee80211_sub_if_data *sdata,
+ 				       struct ieee80211_link_data *link,
+ 				       u64 changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  void ieee80211_configure_filter(struct ieee80211_local *local);
  u32 ieee80211_reset_erp_info(struct ieee80211_sub_if_data *sdata);
  
@@@ -2111,21 -1992,25 +2224,25 @@@ voi
  ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
  				    struct ieee80211_supported_band *sband,
  				    const struct ieee80211_vht_cap *vht_cap_ie,
 -				    struct link_sta_info *link_sta);
 -enum ieee80211_sta_rx_bandwidth
 -ieee80211_sta_cap_rx_bw(struct link_sta_info *link_sta);
 -enum ieee80211_sta_rx_bandwidth
 -ieee80211_sta_cur_vht_bw(struct link_sta_info *link_sta);
 -void ieee80211_sta_set_rx_nss(struct link_sta_info *link_sta);
 +				    struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta);
 +void ieee80211_sta_set_rx_nss(struct sta_info *sta);
  enum ieee80211_sta_rx_bandwidth
  ieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width);
 -enum nl80211_chan_width
 -ieee80211_sta_cap_chan_bw(struct link_sta_info *link_sta);
 +enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta);
  void ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
++=======
+ 				 struct ieee80211_link_data *link,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  				 struct ieee80211_mgmt *mgmt);
  u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
 -				  struct link_sta_info *sta,
 -				  u8 opmode, enum nl80211_band band);
 +                                  struct sta_info *sta, u8 opmode,
 +				  enum nl80211_band band);
  void ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
 -				 struct link_sta_info *sta,
 -				 u8 opmode, enum nl80211_band band);
 +				 struct sta_info *sta, u8 opmode,
 +				 enum nl80211_band band);
  void ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,
  				      struct ieee80211_sta_vht_cap *vht_cap);
  void ieee80211_get_vht_mask_from_cap(__le16 vht_cap,
@@@ -2393,8 -2278,10 +2510,15 @@@ u32 ieee80211_sta_get_rates(struct ieee
  			    struct ieee802_11_elems *elems,
  			    enum nl80211_band band, u32 *basic_rates);
  int __ieee80211_request_smps_mgd(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +				 enum ieee80211_smps_mode smps_mode);
 +void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata);
++=======
+ 				 struct ieee80211_link_data *link,
+ 				 enum ieee80211_smps_mode smps_mode);
+ void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata,
+ 			   struct ieee80211_link_data *link);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  void ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata);
  
  size_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset);
diff --cc net/mac80211/iface.c
index 0a38d98d9882,55b0a1fa92ab..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -80,7 -80,8 +80,12 @@@ void ieee80211_recalc_txpower(struct ie
  {
  	if (__ieee80211_recalc_txpower(sdata) ||
  	    (update_bss && ieee80211_sdata_running(sdata)))
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_TXPOWER);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_TXPOWER);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  static u32 __ieee80211_idle_off(struct ieee80211_local *local)
@@@ -472,7 -480,7 +477,11 @@@ static void ieee80211_do_stop(struct ie
  		chandef = sdata->vif.bss_conf.chandef;
  		WARN_ON(local->suspended);
  		mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +		ieee80211_vif_release_channel(sdata);
++=======
+ 		ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		mutex_unlock(&local->mtx);
  		cfg80211_cac_event(sdata->dev, &chandef,
  				   NL80211_RADAR_CAC_ABORTED,
@@@ -956,6 -1021,66 +965,69 @@@ static void ieee80211_set_default_queue
  	sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
+ 				int link_id,
+ 				struct ieee80211_link_data *link,
+ 				struct ieee80211_bss_conf *link_conf)
+ {
+ 	bool deflink = link_id < 0;
+ 
+ 	if (link_id < 0)
+ 		link_id = 0;
+ 
+ 	rcu_assign_pointer(sdata->vif.link_conf[link_id], link_conf);
+ 	rcu_assign_pointer(sdata->link[link_id], link);
+ 
+ 	link->sdata = sdata;
+ 	link->link_id = link_id;
+ 	link->conf = link_conf;
+ 
+ 	INIT_WORK(&link->csa_finalize_work,
+ 		  ieee80211_csa_finalize_work);
+ 	INIT_WORK(&link->color_change_finalize_work,
+ 		  ieee80211_color_change_finalize_work);
+ 	INIT_LIST_HEAD(&link->assigned_chanctx_list);
+ 	INIT_LIST_HEAD(&link->reserved_chanctx_list);
+ 	INIT_DELAYED_WORK(&link->dfs_cac_timer_work,
+ 			  ieee80211_dfs_cac_timer_work);
+ 
+ 	if (!deflink) {
+ 		switch (sdata->vif.type) {
+ 		case NL80211_IFTYPE_AP:
+ 			ether_addr_copy(link_conf->addr,
+ 					sdata->wdev.links[link_id].addr);
+ 			WARN_ON(!(sdata->wdev.valid_links & BIT(link_id)));
+ 			break;
+ 		case NL80211_IFTYPE_STATION:
+ 			eth_random_addr(link_conf->addr);
+ 			ether_addr_copy(sdata->wdev.links[link_id].addr,
+ 					link_conf->addr);
+ 			break;
+ 		default:
+ 			WARN_ON(1);
+ 		}
+ 	}
+ }
+ 
+ static void ieee80211_sdata_init(struct ieee80211_local *local,
+ 				 struct ieee80211_sub_if_data *sdata)
+ {
+ 	sdata->local = local;
+ 
+ 	/*
+ 	 * Initialize the default link, so we can use link_id 0 for non-MLD,
+ 	 * and that continues to work for non-MLD-aware drivers that use just
+ 	 * vif.bss_conf instead of vif.link_conf.
+ 	 *
+ 	 * Note that we never change this, so if link ID 0 isn't used in an
+ 	 * MLD connection, we get a separate allocation for it.
+ 	 */
+ 	ieee80211_link_init(sdata, -1, &sdata->deflink, &sdata->vif.bss_conf);
+ }
+ 
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
  {
  	struct ieee80211_sub_if_data *sdata;
@@@ -1003,8 -1129,8 +1075,13 @@@
  	mutex_unlock(&local->iflist_mtx);
  
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	ret = ieee80211_vif_use_channel(sdata, &local->monitor_chandef,
 +					IEEE80211_CHANCTX_EXCLUSIVE);
++=======
+ 	ret = ieee80211_link_use_channel(&sdata->deflink, &local->monitor_chandef,
+ 					 IEEE80211_CHANCTX_EXCLUSIVE);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&local->mtx);
  	if (ret) {
  		mutex_lock(&local->iflist_mtx);
@@@ -1048,7 -1174,7 +1125,11 @@@ void ieee80211_del_virtual_monitor(stru
  	synchronize_net();
  
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 	ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&local->mtx);
  
  	drv_remove_interface(local, sdata);
@@@ -1153,8 -1279,8 +1234,13 @@@ int ieee80211_do_open(struct wireless_d
  	switch (sdata->vif.type) {
  	case NL80211_IFTYPE_AP_VLAN:
  		/* no need to tell driver, but set carrier and chanctx */
++<<<<<<< HEAD
 +		if (rtnl_dereference(sdata->bss->beacon)) {
 +			ieee80211_vif_vlan_copy_chanctx(sdata);
++=======
+ 		if (sdata->bss->active) {
+ 			ieee80211_link_vlan_copy_chanctx(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			netif_carrier_on(dev);
  			ieee80211_set_vif_encap_ops(sdata);
  		} else {
@@@ -1226,7 -1352,8 +1312,12 @@@
  		if (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&
  		    sdata->vif.type != NL80211_IFTYPE_NAN)
  			changed |= ieee80211_reset_erp_info(sdata);
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  		switch (sdata->vif.type) {
  		case NL80211_IFTYPE_STATION:
@@@ -1410,7 -1537,8 +1501,12 @@@ static void ieee80211_iface_process_skb
  			break;
  		}
  		case WLAN_VHT_ACTION_GROUPID_MGMT:
++<<<<<<< HEAD
 +			ieee80211_process_mu_groups(sdata, mgmt);
++=======
+ 			ieee80211_process_mu_groups(sdata, &sdata->deflink,
+ 						    mgmt);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			break;
  		default:
  			WARN_ON(1);
@@@ -1558,7 -1692,7 +1654,11 @@@ static void ieee80211_recalc_smps_work(
  	struct ieee80211_sub_if_data *sdata =
  		container_of(work, struct ieee80211_sub_if_data, recalc_smps);
  
++<<<<<<< HEAD
 +	ieee80211_recalc_smps(sdata);
++=======
+ 	ieee80211_recalc_smps(sdata, &sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  /*
@@@ -2222,3 -2355,97 +2322,100 @@@ void ieee80211_vif_dec_num_mcast(struc
  	else if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
  		atomic_dec(&sdata->u.vlan.num_mcast_sta);
  }
++<<<<<<< HEAD
++=======
+ 
+ int ieee80211_vif_set_links(struct ieee80211_sub_if_data *sdata,
+ 			    u16 new_links)
+ {
+ 	u16 old_links = sdata->vif.valid_links;
+ 	unsigned long add = new_links & ~old_links;
+ 	unsigned long rem = old_links & ~new_links;
+ 	unsigned int link_id;
+ 	int ret;
+ 	struct {
+ 		struct ieee80211_link_data data;
+ 		struct ieee80211_bss_conf conf;
+ 		struct rcu_head rcu_head;
+ 	} *links[IEEE80211_MLD_MAX_NUM_LINKS] = {}, *link;
+ 	struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	struct ieee80211_link_data *old_data[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	bool use_deflink = old_links == 0; /* set for error case */
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	if (old_links == new_links)
+ 		return 0;
+ 
+ 	/* allocate new link structures first */
+ 	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		link = kzalloc(sizeof(*link), GFP_KERNEL);
+ 		if (!link) {
+ 			ret = -ENOMEM;
+ 			goto free;
+ 		}
+ 		links[link_id] = link;
+ 	}
+ 
+ 	/* keep track of the old pointers for the driver */
+ 	BUILD_BUG_ON(sizeof(old) != sizeof(sdata->vif.link_conf));
+ 	memcpy(old, sdata->vif.link_conf, sizeof(old));
+ 	/* and for us in error cases */
+ 	BUILD_BUG_ON(sizeof(old_data) != sizeof(sdata->link));
+ 	memcpy(old_data, sdata->link, sizeof(old_data));
+ 
+ 	/* link them into data structures */
+ 	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		WARN_ON(!use_deflink &&
+ 			rcu_access_pointer(sdata->link[link_id]) == &sdata->deflink);
+ 
+ 		link = links[link_id];
+ 		ieee80211_link_init(sdata, link_id, &link->data, &link->conf);
+ 	}
+ 
+ 	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		RCU_INIT_POINTER(sdata->link[link_id], NULL);
+ 		RCU_INIT_POINTER(sdata->vif.link_conf[link_id], NULL);
+ 	}
+ 
+ 	sdata->vif.valid_links = new_links;
+ 
+ 	/* tell the driver */
+ 	ret = drv_change_vif_links(sdata->local, sdata,
+ 				   old_links, new_links,
+ 				   old);
+ 	if (ret) {
+ 		/* restore config */
+ 		memcpy(sdata->link, old_data, sizeof(old_data));
+ 		memcpy(sdata->vif.link_conf, old, sizeof(old));
+ 		sdata->vif.valid_links = old_links;
+ 		/* and free the newly allocated links */
+ 		goto free;
+ 	}
+ 
+ 	/* use deflink/bss_conf again if and only if there are no more links */
+ 	use_deflink = new_links == 0;
+ 
+ 	/* now use this to free the old links */
+ 	memset(links, 0, sizeof(links));
+ 	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+ 		if (rcu_access_pointer(sdata->link[link_id]) == &sdata->deflink)
+ 			continue;
+ 		/*
+ 		 * we must have allocated the data through this path so
+ 		 * we know we can free both at the same time
+ 		 */
+ 		links[link_id] = container_of(rcu_access_pointer(sdata->link[link_id]),
+ 					      typeof(*links[link_id]),
+ 					      data);
+ 	}
+ 
+ free:
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++)
+ 		kfree_rcu(links[link_id], rcu_head);
+ 	if (use_deflink)
+ 		ieee80211_link_init(sdata, -1, &sdata->deflink,
+ 				    &sdata->vif.bss_conf);
+ 	return ret;
+ }
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
diff --cc net/mac80211/main.c
index ae06e4025b16,191f4d35ef60..000000000000
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@@ -208,7 -214,80 +208,82 @@@ void ieee80211_bss_info_change_notify(s
  	if (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
  		return;
  
++<<<<<<< HEAD
 +	drv_bss_info_changed(local, sdata, &sdata->vif.bss_conf, changed);
++=======
+ 	if (WARN_ON_ONCE(changed & (BSS_CHANGED_BEACON |
+ 				    BSS_CHANGED_BEACON_ENABLED) &&
+ 			 sdata->vif.type != NL80211_IFTYPE_AP &&
+ 			 sdata->vif.type != NL80211_IFTYPE_ADHOC &&
+ 			 sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
+ 			 sdata->vif.type != NL80211_IFTYPE_OCB))
+ 		return;
+ 
+ 	if (WARN_ON_ONCE(sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE ||
+ 			 sdata->vif.type == NL80211_IFTYPE_NAN ||
+ 			 (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
+ 			  !sdata->vif.bss_conf.mu_mimo_owner &&
+ 			  !(changed & BSS_CHANGED_TXPOWER))))
+ 		return;
+ 
+ 	if (!check_sdata_in_driver(sdata))
+ 		return;
+ 
+ 	if (changed & BSS_CHANGED_VIF_CFG_FLAGS) {
+ 		u64 ch = changed & BSS_CHANGED_VIF_CFG_FLAGS;
+ 
+ 		trace_drv_vif_cfg_changed(local, sdata, changed);
+ 		if (local->ops->vif_cfg_changed)
+ 			local->ops->vif_cfg_changed(&local->hw, &sdata->vif, ch);
+ 	}
+ 
+ 	if (changed & ~BSS_CHANGED_VIF_CFG_FLAGS) {
+ 		u64 ch = changed & ~BSS_CHANGED_VIF_CFG_FLAGS;
+ 
+ 		/* FIXME: should be for each link */
+ 		trace_drv_link_info_changed(local, sdata, &sdata->vif.bss_conf,
+ 					    0, changed);
+ 		if (local->ops->link_info_changed)
+ 			local->ops->link_info_changed(&local->hw, &sdata->vif,
+ 						      &sdata->vif.bss_conf,
+ 						      0, ch);
+ 	}
+ 
+ 	if (local->ops->bss_info_changed)
+ 		local->ops->bss_info_changed(&local->hw, &sdata->vif,
+ 					     &sdata->vif.bss_conf, changed);
+ 	trace_drv_return_void(local);
+ }
+ 
+ void ieee80211_vif_cfg_change_notify(struct ieee80211_sub_if_data *sdata,
+ 				     u64 changed)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 
+ 	WARN_ON_ONCE(changed & ~BSS_CHANGED_VIF_CFG_FLAGS);
+ 
+ 	if (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+ 		return;
+ 
+ 	drv_vif_cfg_changed(local, sdata, changed);
+ }
+ 
+ void ieee80211_link_info_change_notify(struct ieee80211_sub_if_data *sdata,
+ 				       struct ieee80211_link_data *link,
+ 				       u64 changed)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 
+ 	WARN_ON_ONCE(changed & BSS_CHANGED_VIF_CFG_FLAGS);
+ 
+ 	if (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+ 		return;
+ 
+ 	if (!check_sdata_in_driver(sdata))
+ 		return;
+ 
+ 	drv_link_info_changed(local, sdata, link->conf, link->link_id, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  u32 ieee80211_reset_erp_info(struct ieee80211_sub_if_data *sdata)
diff --cc net/mac80211/mesh.c
index 5b1e1fde82db,ba4e0921fa5d..000000000000
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@@ -1056,7 -1056,7 +1056,11 @@@ int ieee80211_start_mesh(struct ieee802
  	}
  
  	ieee80211_recalc_dtim(local, sdata);
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	netif_carrier_on(sdata->dev);
  	return 0;
@@@ -1080,7 -1080,8 +1084,12 @@@ void ieee80211_stop_mesh(struct ieee802
  	sdata->vif.bss_conf.enable_beacon = false;
  	sdata->beacon_rate_set = false;
  	clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_BEACON_ENABLED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	/* remove beacon */
  	bcn = sdata_dereference(ifmsh->beacon, sdata);
@@@ -1578,7 -1579,7 +1587,11 @@@ static void mesh_bss_info_changed(struc
  		if (ieee80211_mesh_rebuild_beacon(sdata))
  			return;
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  void ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata)
diff --cc net/mac80211/mlme.c
index 74762996ec47,52a41416b8bb..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -1837,7 -1836,8 +1837,12 @@@ void ieee80211_recalc_ps_vif(struct iee
  
  	if (sdata->vif.bss_conf.ps != ps_allowed) {
  		sdata->vif.bss_conf.ps = ps_allowed;
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_PS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  }
  
@@@ -2033,7 -2033,8 +2038,12 @@@ __ieee80211_sta_handle_tspec_ac_params(
  void ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata)
  {
  	if (__ieee80211_sta_handle_tspec_ac_params(sdata))
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_QOS);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_QOS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  static void ieee80211_sta_handle_tspec_ac_params_wk(struct work_struct *work)
@@@ -2338,7 -2340,7 +2348,11 @@@ static void ieee80211_set_associated(st
  	ieee80211_recalc_ps(local);
  	mutex_unlock(&local->iflist_mtx);
  
++<<<<<<< HEAD
 +	ieee80211_recalc_smps(sdata);
++=======
+ 	ieee80211_recalc_smps(sdata, &sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	ieee80211_recalc_ps_vif(sdata);
  
  	netif_carrier_on(sdata->dev);
@@@ -2920,11 -2922,12 +2934,17 @@@ static void ieee80211_destroy_auth_data
  		del_timer_sync(&sdata->u.mgd.timer);
  		sta_info_destroy_addr(sdata, auth_data->bss->bssid);
  
++<<<<<<< HEAD
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 		eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		sdata->u.mgd.flags = 0;
  		mutex_lock(&sdata->local->mtx);
 -		ieee80211_link_release_channel(&sdata->deflink);
 +		ieee80211_vif_release_channel(sdata);
  		mutex_unlock(&sdata->local->mtx);
  	}
  
@@@ -2949,8 -2952,9 +2969,14 @@@ static void ieee80211_destroy_assoc_dat
  		del_timer_sync(&sdata->u.mgd.timer);
  		sta_info_destroy_addr(sdata, assoc_data->bss->bssid);
  
++<<<<<<< HEAD
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 		eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		sdata->u.mgd.flags = 0;
  		sdata->vif.bss_conf.mu_mimo_owner = false;
  
@@@ -4386,7 -4396,8 +4412,12 @@@ static void ieee80211_rx_mgmt_beacon(st
  					       elems->pwr_constr_elem,
  					       elems->cisco_dtpc_elem);
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  changed);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  free:
  	kfree(elems);
  }
@@@ -5693,9 -5707,10 +5724,16 @@@ skip_rates
  		 * tell driver about BSSID, basic rates and timing
  		 * this was set up above, before setting the channel
  		 */
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata,
 +			BSS_CHANGED_BSSID | BSS_CHANGED_BASIC_RATES |
 +			BSS_CHANGED_BEACON_INT);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID |
+ 						  BSS_CHANGED_BASIC_RATES |
+ 						  BSS_CHANGED_BEACON_INT);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  		if (assoc)
  			sta_info_pre_move_state(new_sta, IEEE80211_STA_AUTH);
@@@ -5860,11 -5875,12 +5898,17 @@@ int ieee80211_mgd_auth(struct ieee80211
  	return 0;
  
   err_clear:
++<<<<<<< HEAD
 +	eth_zero_addr(ifmgd->bssid);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 	eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_BSSID);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	ifmgd->auth_data = NULL;
  	mutex_lock(&sdata->local->mtx);
 -	ieee80211_link_release_channel(&sdata->deflink);
 +	ieee80211_vif_release_channel(sdata);
  	mutex_unlock(&sdata->local->mtx);
  	kfree(auth_data);
  	return err;
@@@ -6206,8 -6223,9 +6250,14 @@@ int ieee80211_mgd_assoc(struct ieee8021
  
  	return 0;
   err_clear:
++<<<<<<< HEAD
 +	eth_zero_addr(ifmgd->bssid);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 	eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_BSSID);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	ifmgd->assoc_data = NULL;
   err_free:
  	kfree(assoc_data);
diff --cc net/mac80211/ocb.c
index 1b28b4d92936,2ca2164a3098..000000000000
--- a/net/mac80211/ocb.c
+++ b/net/mac80211/ocb.c
@@@ -182,12 -182,12 +182,17 @@@ int ieee80211_ocb_join(struct ieee80211
  		return -EINVAL;
  
  	sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
 -	sdata->deflink.smps_mode = IEEE80211_SMPS_OFF;
 -	sdata->deflink.needed_rx_chains = sdata->local->rx_chains;
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	sdata->needed_rx_chains = sdata->local->rx_chains;
  
  	mutex_lock(&sdata->local->mtx);
++<<<<<<< HEAD
 +	err = ieee80211_vif_use_channel(sdata, &setup->chandef,
 +					IEEE80211_CHANCTX_SHARED);
++=======
+ 	err = ieee80211_link_use_channel(&sdata->deflink, &setup->chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&sdata->local->mtx);
  	if (err)
  		return err;
@@@ -229,7 -229,7 +234,11 @@@ int ieee80211_ocb_leave(struct ieee8021
  	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_OCB);
  
  	mutex_lock(&sdata->local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 	ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	mutex_unlock(&sdata->local->mtx);
  
  	skb_queue_purge(&sdata->skb_queue);
diff --cc net/mac80211/offchannel.c
index 09a1c2d722be,be79ae68754e..000000000000
--- a/net/mac80211/offchannel.c
+++ b/net/mac80211/offchannel.c
@@@ -118,8 -118,9 +118,14 @@@ void ieee80211_offchannel_stop_vifs(str
  			set_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,
  				&sdata->state);
  			sdata->vif.bss_conf.enable_beacon = false;
++<<<<<<< HEAD
 +			ieee80211_bss_info_change_notify(
 +				sdata, BSS_CHANGED_BEACON_ENABLED);
++=======
+ 			ieee80211_link_info_change_notify(
+ 				sdata, &sdata->deflink,
+ 				BSS_CHANGED_BEACON_ENABLED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
  
  		if (sdata->vif.type == NL80211_IFTYPE_STATION &&
@@@ -155,8 -156,9 +161,14 @@@ void ieee80211_offchannel_return(struc
  		if (test_and_clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,
  				       &sdata->state)) {
  			sdata->vif.bss_conf.enable_beacon = true;
++<<<<<<< HEAD
 +			ieee80211_bss_info_change_notify(
 +				sdata, BSS_CHANGED_BEACON_ENABLED);
++=======
+ 			ieee80211_link_info_change_notify(
+ 				sdata, &sdata->deflink,
+ 				BSS_CHANGED_BEACON_ENABLED);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
  	}
  	mutex_unlock(&local->iflist_mtx);
diff --cc net/mac80211/sta_info.c
index d25b297851c4,20aad688c9c9..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -624,7 -731,8 +624,12 @@@ ieee80211_recalc_p2p_go_ps_allowed(stru
  
  	if (allow_p2p_go_ps != sdata->vif.bss_conf.allow_p2p_go_ps) {
  		sdata->vif.bss_conf.allow_p2p_go_ps = allow_p2p_go_ps;
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_P2P_PS);
++=======
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_P2P_PS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  }
  
diff --cc net/mac80211/tdls.c
index 601011867929,71883ffd7061..000000000000
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@@ -1335,7 -1336,8 +1335,12 @@@ iee80211_tdls_recalc_ht_protection(stru
  		return;
  
  	sdata->vif.bss_conf.ht_operation_mode = opmode;
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_HT);
++=======
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_HT);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
  int ieee80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
diff --cc net/mac80211/trace.h
index 17e7760d8348,6aa06fba5b50..000000000000
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@@ -406,6 -405,57 +406,60 @@@ TRACE_EVENT(drv_bss_info_changed
  		__field(bool, ibss_joined)
  		__field(bool, ibss_creator)
  		__field(u16, aid)
++<<<<<<< HEAD
++=======
+ 		__dynamic_array(u32, arp_addr_list,
+ 				sdata->vif.cfg.arp_addr_cnt > IEEE80211_BSS_ARP_ADDR_LIST_LEN ?
+ 					IEEE80211_BSS_ARP_ADDR_LIST_LEN :
+ 					sdata->vif.cfg.arp_addr_cnt)
+ 		__field(int, arp_addr_cnt)
+ 		__dynamic_array(u8, ssid, sdata->vif.cfg.ssid_len)
+ 		__field(int, s1g)
+ 		__field(bool, idle)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->changed = changed;
+ 		__entry->aid = sdata->vif.cfg.aid;
+ 		__entry->assoc = sdata->vif.cfg.assoc;
+ 		__entry->ibss_joined = sdata->vif.cfg.ibss_joined;
+ 		__entry->ibss_creator = sdata->vif.cfg.ibss_creator;
+ 
+ 		__entry->arp_addr_cnt = sdata->vif.cfg.arp_addr_cnt;
+ 		memcpy(__get_dynamic_array(arp_addr_list),
+ 		       sdata->vif.cfg.arp_addr_list,
+ 		       sizeof(u32) * (sdata->vif.cfg.arp_addr_cnt > IEEE80211_BSS_ARP_ADDR_LIST_LEN ?
+ 					IEEE80211_BSS_ARP_ADDR_LIST_LEN :
+ 					sdata->vif.cfg.arp_addr_cnt));
+ 		memcpy(__get_dynamic_array(ssid),
+ 		       sdata->vif.cfg.ssid,
+ 		       sdata->vif.cfg.ssid_len);
+ 		__entry->s1g = sdata->vif.cfg.s1g;
+ 		__entry->idle = sdata->vif.cfg.idle;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT  VIF_PR_FMT " changed:%#llx",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->changed
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_link_info_changed,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_bss_conf *link_conf,
+ 		 int link_id, u64 changed),
+ 
+ 	TP_ARGS(local, sdata, link_conf, link_id, changed),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(u64, changed)
+ 		__field(int, link_id)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		__field(bool, cts)
  		__field(bool, shortpre)
  		__field(bool, shortslot)
@@@ -1710,9 -1751,9 +1764,15 @@@ DEFINE_EVENT(local_sdata_chanctx, drv_u
  TRACE_EVENT(drv_start_ap,
  	TP_PROTO(struct ieee80211_local *local,
  		 struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +		 struct ieee80211_bss_conf *info),
 +
 +	TP_ARGS(local, sdata, info),
++=======
+ 		 unsigned int link_id),
+ 
+ 	TP_ARGS(local, sdata, link_id),
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	TP_STRUCT__entry(
  		LOCAL_ENTRY
@@@ -1724,12 -1766,20 +1784,27 @@@
  	),
  
  	TP_fast_assign(
+ 		struct ieee80211_bss_conf *info =
+ 			sdata_dereference(sdata->vif.link_conf[link_id], sdata);
+ 
  		LOCAL_ASSIGN;
  		VIF_ASSIGN;
++<<<<<<< HEAD
 +		__entry->dtimper = info->dtim_period;
 +		__entry->bcnint = info->beacon_int;
 +		memcpy(__get_dynamic_array(ssid), info->ssid, info->ssid_len);
 +		__entry->hidden_ssid = info->hidden_ssid;
++=======
+ 		__entry->link_id = link_id;
+ 		if (info) {
+ 			__entry->dtimper = info->dtim_period;
+ 			__entry->bcnint = info->beacon_int;
+ 			__entry->hidden_ssid = info->hidden_ssid;
+ 		}
+ 		memcpy(__get_dynamic_array(ssid),
+ 		       sdata->vif.cfg.ssid,
+ 		       sdata->vif.cfg.ssid_len);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	),
  
  	TP_printk(
diff --cc net/mac80211/tx.c
index d8b87f355d0c,4a7a714de79e..000000000000
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@@ -4683,6 -4605,7 +4684,10 @@@ static void __ieee80211_beacon_add_tim(
  	u8 *pos, *tim;
  	int aid0 = 0;
  	int i, have_bits = 0, n1, n2;
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	/* Generate bitmap for TIM only if there are any STAs in power save
  	 * mode. */
@@@ -4755,10 -4679,10 +4761,17 @@@ static int ieee80211_beacon_add_tim(str
  	 * of the tim bitmap in mac80211 and the driver.
  	 */
  	if (local->tim_in_locked_section) {
++<<<<<<< HEAD
 +		__ieee80211_beacon_add_tim(sdata, ps, skb, is_template);
 +	} else {
 +		spin_lock_bh(&local->tim_lock);
 +		__ieee80211_beacon_add_tim(sdata, ps, skb, is_template);
++=======
+ 		__ieee80211_beacon_add_tim(sdata, link, ps, skb, is_template);
+ 	} else {
+ 		spin_lock_bh(&local->tim_lock);
+ 		__ieee80211_beacon_add_tim(sdata, link, ps, skb, is_template);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		spin_unlock_bh(&local->tim_lock);
  	}
  
@@@ -4766,7 -4690,8 +4779,12 @@@
  }
  
  static void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +					struct beacon_data *beacon)
++=======
+ 					struct beacon_data *beacon,
+ 					struct ieee80211_link_data *link)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  {
  	u8 *beacon_data, count, max_count = 1;
  	struct probe_resp *resp;
@@@ -4791,12 -4716,11 +4809,20 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	resp = rcu_dereference(sdata->u.ap.probe_resp);
 +
 +	bcn_offsets = beacon->cntdwn_counter_offsets;
 +	count = beacon->cntdwn_current_counter;
 +	if (sdata->vif.bss_conf.csa_active)
++=======
+ 	resp = rcu_dereference(link->u.ap.probe_resp);
+ 
+ 	bcn_offsets = beacon->cntdwn_counter_offsets;
+ 	count = beacon->cntdwn_current_counter;
+ 	if (link->conf->csa_active)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		max_count = IEEE80211_MAX_CNTDWN_COUNTERS_NUM;
  
  	for (i = 0; i < max_count; ++i) {
@@@ -4939,14 -4858,15 +4962,23 @@@ EXPORT_SYMBOL(ieee80211_beacon_cntdwn_i
  
  static int ieee80211_beacon_protect(struct sk_buff *skb,
  				    struct ieee80211_local *local,
++<<<<<<< HEAD
 +				    struct ieee80211_sub_if_data *sdata)
++=======
+ 				    struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_link_data *link)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  {
  	ieee80211_tx_result res;
  	struct ieee80211_tx_data tx;
  	struct sk_buff *check_skb;
  
  	memset(&tx, 0, sizeof(tx));
++<<<<<<< HEAD
 +	tx.key = rcu_dereference(sdata->default_beacon_key);
++=======
+ 	tx.key = rcu_dereference(link->default_beacon_key);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	if (!tx.key)
  		return 0;
  	tx.local = local;
@@@ -5001,7 -4922,7 +5034,11 @@@ ieee80211_beacon_get_finish(struct ieee
  	memset(&txrc, 0, sizeof(txrc));
  	txrc.hw = hw;
  	txrc.sband = local->hw.wiphy->bands[band];
++<<<<<<< HEAD
 +	txrc.bss_conf = &sdata->vif.bss_conf;
++=======
+ 	txrc.bss_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	txrc.skb = skb;
  	txrc.reported_rate.idx = -1;
  	if (sdata->beacon_rate_set && sdata->beacon_rateidx_mask[band])
@@@ -5049,7 -4971,7 +5087,11 @@@ ieee80211_beacon_get_ap(struct ieee8021
  		if (!is_template)
  			ieee80211_beacon_update_cntdwn(vif);
  
++<<<<<<< HEAD
 +		ieee80211_set_beacon_cntdwn(sdata, beacon);
++=======
+ 		ieee80211_set_beacon_cntdwn(sdata, beacon, link);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  
  	/* headroom, head length,
@@@ -5065,7 -4987,7 +5107,11 @@@
  	skb_reserve(skb, local->tx_headroom);
  	skb_put_data(skb, beacon->head, beacon->head_len);
  
++<<<<<<< HEAD
 +	ieee80211_beacon_add_tim(sdata, &ap->ps, skb, is_template);
++=======
+ 	ieee80211_beacon_add_tim(sdata, link, &ap->ps, skb, is_template);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (offs) {
  		offs->tim_offset = beacon->head_len;
@@@ -5084,11 -5006,11 +5130,19 @@@
  	if (beacon->tail)
  		skb_put_data(skb, beacon->tail, beacon->tail_len);
  
++<<<<<<< HEAD
 +	if (ieee80211_beacon_protect(skb, local, sdata) < 0)
 +		return NULL;
 +
 +	ieee80211_beacon_get_finish(hw, vif, offs, beacon, skb, chanctx_conf,
 +				    csa_off_base);
++=======
+ 	if (ieee80211_beacon_protect(skb, local, sdata, link) < 0)
+ 		return NULL;
+ 
+ 	ieee80211_beacon_get_finish(hw, vif, link, offs, beacon, skb,
+ 				    chanctx_conf, csa_off_base);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	return skb;
  }
  
@@@ -5107,7 -5031,11 +5162,15 @@@ __ieee80211_beacon_get(struct ieee80211
  	rcu_read_lock();
  
  	sdata = vif_to_sdata(vif);
++<<<<<<< HEAD
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
++=======
+ 	link = rcu_dereference(sdata->link[link_id]);
+ 	if (!link)
+ 		goto out;
+ 	chanctx_conf =
+ 		rcu_dereference(link->conf->chanctx_conf);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	if (!ieee80211_sdata_running(sdata) || !chanctx_conf)
  		goto out;
@@@ -5116,13 -5044,11 +5179,21 @@@
  		memset(offs, 0, sizeof(*offs));
  
  	if (sdata->vif.type == NL80211_IFTYPE_AP) {
++<<<<<<< HEAD
 +		struct ieee80211_if_ap *ap = &sdata->u.ap;
 +
 +		beacon = rcu_dereference(ap->beacon);
 +		if (!beacon)
 +			goto out;
 +
 +		skb = ieee80211_beacon_get_ap(hw, vif, offs, is_template,
++=======
+ 		beacon = rcu_dereference(link->u.ap.beacon);
+ 		if (!beacon)
+ 			goto out;
+ 
+ 		skb = ieee80211_beacon_get_ap(hw, vif, link, offs, is_template,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					      beacon, chanctx_conf);
  	} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
  		struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
@@@ -5136,7 -5062,7 +5207,11 @@@
  			if (!is_template)
  				__ieee80211_beacon_update_cntdwn(beacon);
  
++<<<<<<< HEAD
 +			ieee80211_set_beacon_cntdwn(sdata, beacon);
++=======
+ 			ieee80211_set_beacon_cntdwn(sdata, beacon, link);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
  
  		skb = dev_alloc_skb(local->tx_headroom + beacon->head_len +
@@@ -5150,7 -5076,7 +5225,11 @@@
  		hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
  						 IEEE80211_STYPE_BEACON);
  
++<<<<<<< HEAD
 +		ieee80211_beacon_get_finish(hw, vif, offs, beacon, skb,
++=======
+ 		ieee80211_beacon_get_finish(hw, vif, link, offs, beacon, skb,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					    chanctx_conf, 0);
  	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
  		struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
@@@ -5168,7 -5094,7 +5247,11 @@@
  				 */
  				__ieee80211_beacon_update_cntdwn(beacon);
  
++<<<<<<< HEAD
 +			ieee80211_set_beacon_cntdwn(sdata, beacon);
++=======
+ 			ieee80211_set_beacon_cntdwn(sdata, beacon, link);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		}
  
  		if (ifmsh->sync_ops)
@@@ -5183,7 -5109,8 +5266,12 @@@
  			goto out;
  		skb_reserve(skb, local->tx_headroom);
  		skb_put_data(skb, beacon->head, beacon->head_len);
++<<<<<<< HEAD
 +		ieee80211_beacon_add_tim(sdata, &ifmsh->ps, skb, is_template);
++=======
+ 		ieee80211_beacon_add_tim(sdata, link, &ifmsh->ps, skb,
+ 					 is_template);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  		if (offs) {
  			offs->tim_offset = beacon->head_len;
@@@ -5191,7 -5118,7 +5279,11 @@@
  		}
  
  		skb_put_data(skb, beacon->tail, beacon->tail_len);
++<<<<<<< HEAD
 +		ieee80211_beacon_get_finish(hw, vif, offs, beacon, skb,
++=======
+ 		ieee80211_beacon_get_finish(hw, vif, link, offs, beacon, skb,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  					    chanctx_conf, 0);
  	} else {
  		WARN_ON(1);
diff --cc net/mac80211/util.c
index 4d96211366a1,3e29ef1f81ad..000000000000
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@@ -1701,8 -1702,9 +1701,14 @@@ void ieee80211_set_wmm_default(struct i
  	    sdata->vif.type != NL80211_IFTYPE_NAN) {
  		sdata->vif.bss_conf.qos = enable_qos;
  		if (bss_notify)
++<<<<<<< HEAD
 +			ieee80211_bss_info_change_notify(sdata,
 +							 BSS_CHANGED_QOS);
++=======
+ 			ieee80211_link_info_change_notify(sdata,
+ 							  &sdata->deflink,
+ 							  BSS_CHANGED_QOS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  }
  
@@@ -2257,7 -2259,8 +2263,12 @@@ static void ieee80211_handle_reconfig_f
  }
  
  static void ieee80211_assign_chanctx(struct ieee80211_local *local,
++<<<<<<< HEAD
 +				     struct ieee80211_sub_if_data *sdata)
++=======
+ 				     struct ieee80211_sub_if_data *sdata,
+ 				     struct ieee80211_link_data *link)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  {
  	struct ieee80211_chanctx_conf *conf;
  	struct ieee80211_chanctx *ctx;
@@@ -2266,11 -2269,11 +2277,19 @@@
  		return;
  
  	mutex_lock(&local->chanctx_mtx);
++<<<<<<< HEAD
 +	conf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,
 +					 lockdep_is_held(&local->chanctx_mtx));
 +	if (conf) {
 +		ctx = container_of(conf, struct ieee80211_chanctx, conf);
 +		drv_assign_vif_chanctx(local, sdata, ctx);
++=======
+ 	conf = rcu_dereference_protected(link->conf->chanctx_conf,
+ 					 lockdep_is_held(&local->chanctx_mtx));
+ 	if (conf) {
+ 		ctx = container_of(conf, struct ieee80211_chanctx, conf);
+ 		drv_assign_vif_chanctx(local, sdata, link->link_id, ctx);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  	mutex_unlock(&local->chanctx_mtx);
  }
@@@ -2476,7 -2479,7 +2495,11 @@@ int ieee80211_reconfig(struct ieee80211
  		sdata = wiphy_dereference(local->hw.wiphy,
  					  local->monitor_sdata);
  		if (sdata && ieee80211_sdata_running(sdata))
++<<<<<<< HEAD
 +			ieee80211_assign_chanctx(local, sdata);
++=======
+ 			ieee80211_assign_chanctx(local, sdata, &sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	}
  
  	/* reconfigure hardware */
@@@ -2486,12 -2489,23 +2509,30 @@@
  
  	/* Finally also reconfigure all the BSS information */
  	list_for_each_entry(sdata, &local->interfaces, list) {
++<<<<<<< HEAD
++=======
+ 		unsigned int link_id;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  		u32 changed;
  
  		if (!ieee80211_sdata_running(sdata))
  			continue;
  
++<<<<<<< HEAD
 +		ieee80211_assign_chanctx(local, sdata);
++=======
+ 		sdata_lock(sdata);
+ 		for (link_id = 0;
+ 		     link_id < ARRAY_SIZE(sdata->vif.link_conf);
+ 		     link_id++) {
+ 			struct ieee80211_link_data *link;
+ 
+ 			link = sdata_dereference(sdata->link[link_id], sdata);
+ 			if (link)
+ 				ieee80211_assign_chanctx(local, sdata, link);
+ 		}
+ 		sdata_unlock(sdata);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  		switch (sdata->vif.type) {
  		case NL80211_IFTYPE_AP_VLAN:
@@@ -2800,7 -2814,8 +2841,12 @@@ void ieee80211_resume_disconnect(struc
  }
  EXPORT_SYMBOL_GPL(ieee80211_resume_disconnect);
  
++<<<<<<< HEAD
 +void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata)
++=======
+ void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata,
+ 			   struct ieee80211_link_data *link)
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  {
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_chanctx_conf *chanctx_conf;
@@@ -2808,7 -2823,7 +2854,11 @@@
  
  	mutex_lock(&local->chanctx_mtx);
  
++<<<<<<< HEAD
 +	chanctx_conf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,
++=======
+ 	chanctx_conf = rcu_dereference_protected(link->conf->chanctx_conf,
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  						 lockdep_is_held(&local->chanctx_mtx));
  
  	/*
@@@ -3979,7 -3992,7 +4029,11 @@@ void ieee80211_dfs_cac_cancel(struct ie
  
  		if (sdata->wdev.cac_started) {
  			chandef = sdata->vif.bss_conf.chandef;
++<<<<<<< HEAD
 +			ieee80211_vif_release_channel(sdata);
++=======
+ 			ieee80211_link_release_channel(&sdata->deflink);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  			cfg80211_cac_event(sdata->dev,
  					   &chandef,
  					   NL80211_RADAR_CAC_ABORTED,
@@@ -4422,11 -4435,15 +4476,21 @@@ static u8 ieee80211_chanctx_radar_detec
  	 * until it replaces the other context.
  	 */
  	WARN_ON(ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER &&
 -		!list_empty(&ctx->assigned_links));
 +		!list_empty(&ctx->assigned_vifs));
  
++<<<<<<< HEAD
 +	list_for_each_entry(sdata, &ctx->assigned_vifs, assigned_chanctx_list)
 +		if (sdata->radar_required)
 +			radar_detect |= BIT(sdata->vif.bss_conf.chandef.width);
++=======
+ 	list_for_each_entry(link, &ctx->assigned_links, assigned_chanctx_list) {
+ 		if (!link->radar_required)
+ 			continue;
+ 
+ 		radar_detect |=
+ 			BIT(link->conf->chandef.width);
+ 	}
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	return radar_detect;
  }
diff --cc net/mac80211/vht.c
index bc39bec42e54,c804890dc623..000000000000
--- a/net/mac80211/vht.c
+++ b/net/mac80211/vht.c
@@@ -330,33 -336,42 +330,49 @@@ ieee80211_vht_cap_ie_to_sta_vht_cap(str
  }
  
  /* FIXME: move this to some better location - parses HE/EHT now */
 -enum ieee80211_sta_rx_bandwidth
 -ieee80211_sta_cap_rx_bw(struct link_sta_info *link_sta)
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta)
  {
++<<<<<<< HEAD
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
 +	struct ieee80211_sta_he_cap *he_cap = &sta->sta.he_cap;
 +	struct ieee80211_sta_eht_cap *eht_cap = &sta->sta.eht_cap;
++=======
+ 	unsigned int link_id = link_sta->link_id;
+ 	struct ieee80211_sub_if_data *sdata = link_sta->sta->sdata;
+ 	struct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;
+ 	struct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;
+ 	struct ieee80211_sta_eht_cap *eht_cap = &link_sta->pub->eht_cap;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	u32 cap_width;
  
  	if (he_cap->has_he) {
+ 		struct ieee80211_bss_conf *link_conf;
+ 		enum ieee80211_sta_rx_bandwidth ret;
  		u8 info;
  
+ 		rcu_read_lock();
+ 		link_conf = rcu_dereference(sdata->vif.link_conf[link_id]);
+ 
  		if (eht_cap->has_eht &&
 -		    link_conf->chandef.chan->band == NL80211_BAND_6GHZ) {
 +		    sta->sdata->vif.bss_conf.chandef.chan->band ==
 +		    NL80211_BAND_6GHZ) {
  			info = eht_cap->eht_cap_elem.phy_cap_info[0];
  
- 			if (info & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ)
- 				return IEEE80211_STA_RX_BW_320;
+ 			if (info & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ) {
+ 				ret = IEEE80211_STA_RX_BW_320;
+ 				goto out;
+ 			}
  		}
  
  		info = he_cap->he_cap_elem.phy_cap_info[0];
  
 -		if (link_conf->chandef.chan->band == NL80211_BAND_2GHZ) {
 +		if (sta->sdata->vif.bss_conf.chandef.chan->band ==
 +				NL80211_BAND_2GHZ) {
  			if (info & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G)
- 				return IEEE80211_STA_RX_BW_40;
+ 				ret = IEEE80211_STA_RX_BW_40;
  			else
- 				return IEEE80211_STA_RX_BW_20;
+ 				ret = IEEE80211_STA_RX_BW_20;
+ 			goto out;
  		}
  
  		if (info & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G ||
@@@ -466,14 -488,24 +486,33 @@@ ieee80211_chan_width_to_rx_bw(enum nl80
  }
  
  /* FIXME: rename/move - this deals with everything not just VHT */
 -enum ieee80211_sta_rx_bandwidth
 -ieee80211_sta_cur_vht_bw(struct link_sta_info *link_sta)
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta)
  {
++<<<<<<< HEAD
 +	struct ieee80211_sub_if_data *sdata = sta->sdata;
++=======
+ 	struct sta_info *sta = link_sta->sta;
+ 	struct ieee80211_bss_conf *link_conf;
+ 	enum nl80211_chan_width bss_width;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  	enum ieee80211_sta_rx_bandwidth bw;
 +	enum nl80211_chan_width bss_width = sdata->vif.bss_conf.chandef.width;
  
++<<<<<<< HEAD
 +	bw = ieee80211_sta_cap_rx_bw(sta);
 +	bw = min(bw, sta->cur_max_bandwidth);
++=======
+ 	rcu_read_lock();
+ 	link_conf = rcu_dereference(sta->sdata->vif.link_conf[link_sta->link_id]);
+ 	if (WARN_ON(!link_conf))
+ 		bss_width = NL80211_CHAN_WIDTH_20_NOHT;
+ 	else
+ 		bss_width = link_conf->chandef.width;
+ 	rcu_read_unlock();
+ 
+ 	bw = ieee80211_sta_cap_rx_bw(link_sta);
+ 	bw = min(bw, link_sta->cur_max_bandwidth);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
  	/* Don't consider AP's bandwidth for TDLS peers, section 11.23.1 of
  	 * IEEE80211-2016 specification makes higher bandwidth operation
@@@ -645,11 -677,12 +684,18 @@@ u32 __ieee80211_vht_handle_opmode(struc
  }
  
  void ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +				 struct ieee80211_mgmt *mgmt)
 +{
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
++=======
+ 				 struct ieee80211_link_data *link,
+ 				 struct ieee80211_mgmt *mgmt)
+ {
+ 	struct ieee80211_bss_conf *link_conf = link->conf;
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  
 -	if (!link_conf->mu_mimo_owner)
 +	if (!sdata->vif.bss_conf.mu_mimo_owner)
  		return;
  
  	if (!memcmp(mgmt->u.action.u.vht_group_notif.position,
@@@ -665,19 -698,25 +711,39 @@@
  	       mgmt->u.action.u.vht_group_notif.position,
  	       WLAN_USER_POSITION_LEN);
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_MU_GROUPS);
++=======
+ 	ieee80211_link_info_change_notify(sdata, link,
+ 					  BSS_CHANGED_MU_GROUPS);
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  
 -void ieee80211_update_mu_groups(struct ieee80211_vif *vif, unsigned int link_id,
 +void ieee80211_update_mu_groups(struct ieee80211_vif *vif,
  				const u8 *membership, const u8 *position)
  {
++<<<<<<< HEAD
 +	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
 +
 +	if (WARN_ON_ONCE(!vif->bss_conf.mu_mimo_owner))
 +		return;
 +
 +	memcpy(bss_conf->mu_group.membership, membership, WLAN_MEMBERSHIP_LEN);
 +	memcpy(bss_conf->mu_group.position, position, WLAN_USER_POSITION_LEN);
++=======
+ 	struct ieee80211_bss_conf *link_conf;
+ 
+ 	rcu_read_lock();
+ 	link_conf = rcu_dereference(vif->link_conf[link_id]);
+ 
+ 	if (!WARN_ON_ONCE(!link_conf || !link_conf->mu_mimo_owner)) {
+ 		memcpy(link_conf->mu_group.membership, membership,
+ 		       WLAN_MEMBERSHIP_LEN);
+ 		memcpy(link_conf->mu_group.position, position,
+ 		       WLAN_USER_POSITION_LEN);
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> d8675a63518c (wifi: mac80211: RCU-ify link/link_conf pointers)
  }
  EXPORT_SYMBOL_GPL(ieee80211_update_mu_groups);
  
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
* Unmerged path include/net/mac80211.h
* Unmerged path net/mac80211/cfg.c
* Unmerged path net/mac80211/chan.c
* Unmerged path net/mac80211/debugfs_netdev.c
* Unmerged path net/mac80211/driver-ops.h
* Unmerged path net/mac80211/ht.c
* Unmerged path net/mac80211/ibss.c
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/iface.c
* Unmerged path net/mac80211/main.c
* Unmerged path net/mac80211/mesh.c
* Unmerged path net/mac80211/mlme.c
* Unmerged path net/mac80211/ocb.c
* Unmerged path net/mac80211/offchannel.c
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index d7c490a8a620..04ac38e648c8 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -4148,9 +4148,13 @@ static bool ieee80211_is_our_addr(struct ieee80211_sub_if_data *sdata,
 		return false;
 
 	for (link_id = 0; link_id < ARRAY_SIZE(sdata->vif.link_conf); link_id++) {
-		if (!sdata->vif.link_conf[link_id])
+		struct ieee80211_bss_conf *conf;
+
+		conf = rcu_dereference(sdata->vif.link_conf[link_id]);
+
+		if (!conf)
 			continue;
-		if (ether_addr_equal(sdata->vif.link_conf[link_id]->addr, addr)) {
+		if (ether_addr_equal(conf->addr, addr)) {
 			if (out_link_id)
 				*out_link_id = link_id;
 			return true;
* Unmerged path net/mac80211/sta_info.c
* Unmerged path net/mac80211/tdls.c
* Unmerged path net/mac80211/trace.h
* Unmerged path net/mac80211/tx.c
* Unmerged path net/mac80211/util.c
* Unmerged path net/mac80211/vht.c
