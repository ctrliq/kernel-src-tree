net: tcp: add skb drop reasons to tcp_add_backlog()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit 7a26dc9e7b43f5a24c4b843713e728582adf1c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7a26dc9e.failed

Pass the address of drop_reason to tcp_add_backlog() to store the
reasons for skb drops when fails. Following drop reasons are
introduced:

SKB_DROP_REASON_SOCKET_BACKLOG

	Reviewed-by: Mengen Sun <mengensun@tencent.com>
	Reviewed-by: Hao Peng <flyingpeng@tencent.com>
	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7a26dc9e7b43f5a24c4b843713e728582adf1c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/net/tcp.h
#	include/trace/events/skb.h
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc include/linux/skbuff.h
index 6050fa383222,f7f33c79945b..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,54 +318,58 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
+ 	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+ 					 * see the document for rp_filter
+ 					 * in ip-sysctl.rst for more
+ 					 * information
+ 					 */
+ 	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+ 						  * is multicast, but L3 is
+ 						  * unicast.
+ 						  */
+ 	SKB_DROP_REASON_XFRM_POLICY,	/* xfrm policy check failed */
+ 	SKB_DROP_REASON_IP_NOPROTO,	/* no support for IP protocol */
+ 	SKB_DROP_REASON_SOCKET_RCVBUFF,	/* socket receive buff is full */
+ 	SKB_DROP_REASON_PROTO_MEM,	/* proto memory limition, such as
+ 					 * udp packet drop out of
+ 					 * udp_memory_allocated.
+ 					 */
+ 	SKB_DROP_REASON_TCP_MD5NOTFOUND,	/* no MD5 hash and one
+ 						 * expected, corresponding
+ 						 * to LINUX_MIB_TCPMD5NOTFOUND
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5UNEXPECTED,	/* MD5 hash and we're not
+ 						 * expecting one, corresponding
+ 						 * to LINUX_MIB_TCPMD5UNEXPECTED
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5FAILURE,	/* MD5 hash and its wrong,
+ 					 * corresponding to
+ 					 * LINUX_MIB_TCPMD5FAILURE
+ 					 */
+ 	SKB_DROP_REASON_SOCKET_BACKLOG,	/* failed to add skb to socket
+ 					 * backlog (see
+ 					 * LINUX_MIB_TCPBACKLOGDROP)
+ 					 */
++>>>>>>> 7a26dc9e7b43 (net: tcp: add skb drop reasons to tcp_add_backlog())
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/net/tcp.h
index 14aa93f5fd52,04f4650e0ff0..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -1359,25 -1364,28 +1359,44 @@@ static inline __sum16 __tcp_checksum_co
  static inline bool tcp_checksum_complete(struct sk_buff *skb)
  {
  	return !skb_csum_unnecessary(skb) &&
 -		__skb_checksum_complete(skb);
 +		__tcp_checksum_complete(skb);
  }
  
++<<<<<<< HEAD
 +bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
++=======
+ bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb,
+ 		     enum skb_drop_reason *reason);
+ 
+ #ifdef CONFIG_INET
+ void __sk_defer_free_flush(struct sock *sk);
+ 
+ static inline void sk_defer_free_flush(struct sock *sk)
+ {
+ 	if (llist_empty(&sk->defer_list))
+ 		return;
+ 	__sk_defer_free_flush(sk);
+ }
+ #else
+ static inline void sk_defer_free_flush(struct sock *sk) {}
+ #endif
+ 
++>>>>>>> 7a26dc9e7b43 (net: tcp: add skb drop reasons to tcp_add_backlog())
  int tcp_filter(struct sock *sk, struct sk_buff *skb);
 +
 +#undef STATE_TRACE
 +
 +#ifdef STATE_TRACE
 +static const char *statename[]={
 +	"Unused","Established","Syn Sent","Syn Recv",
 +	"Fin Wait 1","Fin Wait 2","Time Wait", "Close",
 +	"Close Wait","Last ACK","Listen","Closing"
 +};
 +#endif
  void tcp_set_state(struct sock *sk, int state);
 +
  void tcp_done(struct sock *sk);
 +
  int tcp_abort(struct sock *sk, int err);
  
  static inline void tcp_sack_reset(struct tcp_options_received *rx_opt)
diff --cc include/trace/events/skb.h
index 294c61bbe44b,bfccd77e9071..000000000000
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@@ -11,6 -11,27 +11,30 @@@
  
  #define TRACE_SKB_DROP_REASON					\
  	EM(SKB_DROP_REASON_NOT_SPECIFIED, NOT_SPECIFIED)	\
++<<<<<<< HEAD
++=======
+ 	EM(SKB_DROP_REASON_NO_SOCKET, NO_SOCKET)		\
+ 	EM(SKB_DROP_REASON_PKT_TOO_SMALL, PKT_TOO_SMALL)	\
+ 	EM(SKB_DROP_REASON_TCP_CSUM, TCP_CSUM)			\
+ 	EM(SKB_DROP_REASON_SOCKET_FILTER, SOCKET_FILTER)	\
+ 	EM(SKB_DROP_REASON_UDP_CSUM, UDP_CSUM)			\
+ 	EM(SKB_DROP_REASON_NETFILTER_DROP, NETFILTER_DROP)	\
+ 	EM(SKB_DROP_REASON_OTHERHOST, OTHERHOST)		\
+ 	EM(SKB_DROP_REASON_IP_CSUM, IP_CSUM)			\
+ 	EM(SKB_DROP_REASON_IP_INHDR, IP_INHDR)			\
+ 	EM(SKB_DROP_REASON_IP_RPFILTER, IP_RPFILTER)		\
+ 	EM(SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST,		\
+ 	   UNICAST_IN_L2_MULTICAST)				\
+ 	EM(SKB_DROP_REASON_XFRM_POLICY, XFRM_POLICY)		\
+ 	EM(SKB_DROP_REASON_IP_NOPROTO, IP_NOPROTO)		\
+ 	EM(SKB_DROP_REASON_SOCKET_RCVBUFF, SOCKET_RCVBUFF)	\
+ 	EM(SKB_DROP_REASON_PROTO_MEM, PROTO_MEM)		\
+ 	EM(SKB_DROP_REASON_TCP_MD5NOTFOUND, TCP_MD5NOTFOUND)	\
+ 	EM(SKB_DROP_REASON_TCP_MD5UNEXPECTED,			\
+ 	   TCP_MD5UNEXPECTED)					\
+ 	EM(SKB_DROP_REASON_TCP_MD5FAILURE, TCP_MD5FAILURE)	\
+ 	EM(SKB_DROP_REASON_SOCKET_BACKLOG, SOCKET_BACKLOG)	\
++>>>>>>> 7a26dc9e7b43 (net: tcp: add skb drop reasons to tcp_add_backlog())
  	EMe(SKB_DROP_REASON_MAX, MAX)
  
  #undef EM
diff --cc net/ipv4/tcp_ipv4.c
index 46d2e6848354,cbca8637ba2f..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1696,10 -1811,10 +1696,11 @@@ int tcp_v4_early_demux(struct sk_buff *
  	return 0;
  }
  
- bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb)
+ bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb,
+ 		     enum skb_drop_reason *reason)
  {
 -	u32 limit, tail_gso_size, tail_gso_segs;
 +	u32 limit = sk->sk_rcvbuf + sk->sk_sndbuf;
 +	u32 tail_gso_size, tail_gso_segs;
  	struct skb_shared_info *shinfo;
  	const struct tcphdr *th;
  	struct tcphdr *thtail;
@@@ -1722,6 -1837,8 +1723,11 @@@
  
  	if (unlikely(tcp_checksum_complete(skb))) {
  		bh_unlock_sock(sk);
++<<<<<<< HEAD
++=======
+ 		trace_tcp_bad_csum(skb);
+ 		*reason = SKB_DROP_REASON_TCP_CSUM;
++>>>>>>> 7a26dc9e7b43 (net: tcp: add skb drop reasons to tcp_add_backlog())
  		__TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);
  		__TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);
  		return true;
@@@ -1997,8 -2135,9 +2004,14 @@@ process
  	ret = 0;
  	if (!sock_owned_by_user(sk)) {
  		ret = tcp_v4_do_rcv(sk, skb);
++<<<<<<< HEAD
 +	} else if (tcp_add_backlog(sk, skb)) {
 +		goto discard_and_relse;
++=======
+ 	} else {
+ 		if (tcp_add_backlog(sk, skb, &drop_reason))
+ 			goto discard_and_relse;
++>>>>>>> 7a26dc9e7b43 (net: tcp: add skb drop reasons to tcp_add_backlog())
  	}
  	bh_unlock_sock(sk);
  
diff --cc net/ipv6/tcp_ipv6.c
index 8cdff0ded837,abf0ad547858..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1636,11 -1783,11 +1636,17 @@@ process
  	ret = 0;
  	if (!sock_owned_by_user(sk)) {
  		ret = tcp_v6_do_rcv(sk, skb);
++<<<<<<< HEAD
 +	} else if (tcp_add_backlog(sk, skb)) {
 +		goto discard_and_relse;
++=======
+ 	} else {
+ 		if (tcp_add_backlog(sk, skb, &drop_reason))
+ 			goto discard_and_relse;
++>>>>>>> 7a26dc9e7b43 (net: tcp: add skb drop reasons to tcp_add_backlog())
  	}
  	bh_unlock_sock(sk);
 +
  put_and_return:
  	if (refcounted)
  		sock_put(sk);
* Unmerged path include/linux/skbuff.h
* Unmerged path include/net/tcp.h
* Unmerged path include/trace/events/skb.h
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
