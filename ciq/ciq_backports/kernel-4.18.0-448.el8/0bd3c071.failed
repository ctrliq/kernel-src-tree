ASoC: Intel: boards: use software node API in Atom boards

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 0bd3c071e6e7e140c8b39caab99b3b6f05cb5290
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0bd3c071.failed

The function device_add_properties() is going to be removed.
Replacing it with software node API equivalents.

	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Co-developed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20210813151116.23931-9-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 0bd3c071e6e7e140c8b39caab99b3b6f05cb5290)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/boards/bytcht_es8316.c
#	sound/soc/intel/boards/bytcr_rt5640.c
#	sound/soc/intel/boards/bytcr_rt5651.c
diff --cc sound/soc/intel/boards/bytcht_es8316.c
index 902689f3586e,055248f104b2..000000000000
--- a/sound/soc/intel/boards/bytcht_es8316.c
+++ b/sound/soc/intel/boards/bytcht_es8316.c
@@@ -462,6 -460,9 +462,12 @@@ static int snd_byt_cht_es8316_mc_probe(
  	struct property_entry props[MAX_NO_PROPS] = {};
  	struct byt_cht_es8316_private *priv;
  	const struct dmi_system_id *dmi_id;
++<<<<<<< HEAD
++=======
+ 	struct device *dev = &pdev->dev;
+ 	struct snd_soc_acpi_mach *mach;
+ 	struct fwnode_handle *fwnode;
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  	const char *platform_name;
  	struct acpi_device *adev;
  	struct device *codec_dev;
@@@ -602,6 -625,7 +617,10 @@@
  	return 0;
  
  err_put_codec:
++<<<<<<< HEAD
++=======
+ 	device_remove_software_node(priv->codec_dev);
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  	put_device(priv->codec_dev);
  	return ret;
  }
@@@ -612,6 -636,7 +631,10 @@@ static int snd_byt_cht_es8316_mc_remove
  	struct byt_cht_es8316_private *priv = snd_soc_card_get_drvdata(card);
  
  	gpiod_put(priv->speaker_en_gpio);
++<<<<<<< HEAD
++=======
+ 	device_remove_software_node(priv->codec_dev);
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  	put_device(priv->codec_dev);
  	return 0;
  }
diff --cc sound/soc/intel/boards/bytcr_rt5640.c
index a0b88d1e22ab,fecccff76caf..000000000000
--- a/sound/soc/intel/boards/bytcr_rt5640.c
+++ b/sound/soc/intel/boards/bytcr_rt5640.c
@@@ -1127,54 -1016,19 +1129,64 @@@ static int byt_rt5640_add_codec_device_
  	if (byt_rt5640_quirk & BYT_RT5640_JD_NOT_INV)
  		props[cnt++] = PROPERTY_ENTRY_BOOL("realtek,jack-detect-not-inverted");
  
- 	return device_add_properties(i2c_dev, props);
+ 	fwnode = fwnode_create_software_node(props, NULL);
+ 	if (IS_ERR(fwnode)) {
+ 		/* put_device() is handled in caller */
+ 		return PTR_ERR(fwnode);
+ 	}
+ 
+ 	ret = device_add_software_node(i2c_dev, to_software_node(fwnode));
+ 
+ 	fwnode_handle_put(fwnode);
+ 
+ 	return ret;
  }
  
 +/* Some Android devs specify IRQs/GPIOS in a special AMCR0F28 ACPI device */
 +static const struct acpi_gpio_params amcr0f28_jd_gpio = { 1, 0, false };
 +
 +static const struct acpi_gpio_mapping amcr0f28_gpios[] = {
 +	{ "rt5640-jd-gpios", &amcr0f28_jd_gpio, 1 },
 +	{ }
 +};
 +
 +static int byt_rt5640_get_amcr0f28_settings(struct snd_soc_card *card)
 +{
 +	struct byt_rt5640_private *priv = snd_soc_card_get_drvdata(card);
 +	struct rt5640_set_jack_data *data = &priv->jack_data;
 +	struct acpi_device *adev;
 +	int ret = 0;
 +
 +	adev = acpi_dev_get_first_match_dev("AMCR0F28", "1", -1);
 +	if (!adev) {
 +		dev_err(card->dev, "error cannot find AMCR0F28 adev\n");
 +		return -ENOENT;
 +	}
 +
 +	data->codec_irq_override = acpi_dev_gpio_irq_get(adev, 0);
 +	if (data->codec_irq_override < 0) {
 +		ret = data->codec_irq_override;
 +		dev_err(card->dev, "error %d getting codec IRQ\n", ret);
 +		goto put_adev;
 +	}
 +
 +	if (BYT_RT5640_JDSRC(byt_rt5640_quirk) == RT5640_JD_SRC_EXT_GPIO) {
 +		acpi_dev_add_driver_gpios(adev, amcr0f28_gpios);
 +		data->jd_gpio = devm_fwnode_gpiod_get(card->dev, acpi_fwnode_handle(adev),
 +						      "rt5640-jd", GPIOD_IN, "rt5640-jd");
 +		acpi_dev_remove_driver_gpios(adev);
 +
 +		if (IS_ERR(data->jd_gpio)) {
 +			ret = PTR_ERR(data->jd_gpio);
 +			dev_err(card->dev, "error %d getting jd GPIO\n", ret);
 +		}
 +	}
 +
 +put_adev:
 +	acpi_dev_put(adev);
 +	return ret;
 +}
 +
  static int byt_rt5640_init(struct snd_soc_pcm_runtime *runtime)
  {
  	struct snd_soc_card *card = runtime->card;
@@@ -1798,9 -1596,7 +1810,13 @@@ static int snd_byt_rt5640_mc_probe(stru
  	return ret_val;
  
  err:
++<<<<<<< HEAD
 +err_remove_gpios:
 +	if (byt_rt5640_quirk & BYT_RT5640_JD_HP_ELITEP_1000G2)
 +		acpi_dev_remove_driver_gpios(ACPI_COMPANION(priv->codec_dev));
++=======
+ 	device_remove_software_node(priv->codec_dev);
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  err_device:
  	put_device(priv->codec_dev);
  	return ret_val;
@@@ -1811,9 -1607,7 +1827,13 @@@ static int snd_byt_rt5640_mc_remove(str
  	struct snd_soc_card *card = platform_get_drvdata(pdev);
  	struct byt_rt5640_private *priv = snd_soc_card_get_drvdata(card);
  
++<<<<<<< HEAD
 +	if (byt_rt5640_quirk & BYT_RT5640_JD_HP_ELITEP_1000G2)
 +		acpi_dev_remove_driver_gpios(ACPI_COMPANION(priv->codec_dev));
 +
++=======
+ 	device_remove_software_node(priv->codec_dev);
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  	put_device(priv->codec_dev);
  	return 0;
  }
diff --cc sound/soc/intel/boards/bytcr_rt5651.c
index 91cd080923e0,e94c9124d4f4..000000000000
--- a/sound/soc/intel/boards/bytcr_rt5651.c
+++ b/sound/soc/intel/boards/bytcr_rt5651.c
@@@ -986,9 -1008,9 +999,9 @@@ static int snd_byt_rt5651_mc_probe(stru
  	}
  
  	/* Must be called before register_card, also see declaration comment. */
- 	ret_val = byt_rt5651_add_codec_device_props(codec_dev);
+ 	ret_val = byt_rt5651_add_codec_device_props(codec_dev, priv);
  	if (ret_val)
 -		goto err_device;
 +		goto err;
  
  	/* Cherry Trail devices use an external amplifier enable gpio */
  	if (soc_intel_is_cht() && !byt_rt5651_gpios)
@@@ -1107,6 -1138,8 +1120,11 @@@
  	return ret_val;
  
  err:
++<<<<<<< HEAD
++=======
+ 	device_remove_software_node(priv->codec_dev);
+ err_device:
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  	put_device(priv->codec_dev);
  	return ret_val;
  }
@@@ -1116,6 -1149,7 +1134,10 @@@ static int snd_byt_rt5651_mc_remove(str
  	struct snd_soc_card *card = platform_get_drvdata(pdev);
  	struct byt_rt5651_private *priv = snd_soc_card_get_drvdata(card);
  
++<<<<<<< HEAD
++=======
+ 	device_remove_software_node(priv->codec_dev);
++>>>>>>> 0bd3c071e6e7 (ASoC: Intel: boards: use software node API in Atom boards)
  	put_device(priv->codec_dev);
  	return 0;
  }
* Unmerged path sound/soc/intel/boards/bytcht_es8316.c
* Unmerged path sound/soc/intel/boards/bytcr_rt5640.c
* Unmerged path sound/soc/intel/boards/bytcr_rt5651.c
