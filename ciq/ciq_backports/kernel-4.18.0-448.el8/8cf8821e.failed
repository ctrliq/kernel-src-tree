net: Exempt multicast addresses from five-second neighbor lifetime

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jeff Dike <jdike@akamai.com>
commit 8cf8821e15cd553339a5b48ee555a0439c2b2742
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8cf8821e.failed

Commit 58956317c8de ("neighbor: Improve garbage collection")
guarantees neighbour table entries a five-second lifetime.  Processes
which make heavy use of multicast can fill the neighour table with
multicast addresses in five seconds.  At that point, neighbour entries
can't be GC-ed because they aren't five seconds old yet, the kernel
log starts to fill up with "neighbor table overflow!" messages, and
sends start to fail.

This patch allows multicast addresses to be thrown out before they've
lived out their five seconds.  This makes room for non-multicast
addresses and makes messages to all addresses more reliable in these
circumstances.

Fixes: 58956317c8de ("neighbor: Improve garbage collection")
	Signed-off-by: Jeff Dike <jdike@akamai.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://lore.kernel.org/r/20201113015815.31397-1-jdike@akamai.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 8cf8821e15cd553339a5b48ee555a0439c2b2742)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/neighbour.h
#	net/ipv6/ndisc.c
diff --cc include/net/neighbour.h
index 4a28266053bd,22ced1381ede..000000000000
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@@ -212,6 -204,9 +212,12 @@@ struct neigh_table 
  	int			(*pconstructor)(struct pneigh_entry *);
  	void			(*pdestructor)(struct pneigh_entry *);
  	void			(*proxy_redo)(struct sk_buff *skb);
++<<<<<<< HEAD
++=======
+ 	int			(*is_multicast)(const void *pkey);
+ 	bool			(*allow_add)(const struct net_device *dev,
+ 					     struct netlink_ext_ack *extack);
++>>>>>>> 8cf8821e15cd (net: Exempt multicast addresses from five-second neighbor lifetime)
  	char			*id;
  	struct neigh_parms	parms;
  	struct list_head	parms_list;
diff --cc net/ipv6/ndisc.c
index 6c2dd7375f5f,76717478f173..000000000000
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@@ -117,6 -116,8 +118,11 @@@ struct neigh_table nd_tbl = 
  	.pconstructor =	pndisc_constructor,
  	.pdestructor =	pndisc_destructor,
  	.proxy_redo =	pndisc_redo,
++<<<<<<< HEAD
++=======
+ 	.is_multicast =	ndisc_is_multicast,
+ 	.allow_add  =   ndisc_allow_add,
++>>>>>>> 8cf8821e15cd (net: Exempt multicast addresses from five-second neighbor lifetime)
  	.id =		"ndisc_cache",
  	.parms = {
  		.tbl			= &nd_tbl,
* Unmerged path include/net/neighbour.h
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index f976e92436a4..9f79a4c2086b 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -238,6 +238,8 @@ static int neigh_forced_gc(struct neigh_table *tbl)
 
 			write_lock(&n->lock);
 			if ((n->nud_state == NUD_FAILED) ||
+			    (tbl->is_multicast &&
+			     tbl->is_multicast(n->primary_key)) ||
 			    time_after(tref, n->updated))
 				remove = true;
 			write_unlock(&n->lock);
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 850a6f13a082..cc583904fcb9 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -129,6 +129,7 @@ static int arp_constructor(struct neighbour *neigh);
 static void arp_solicit(struct neighbour *neigh, struct sk_buff *skb);
 static void arp_error_report(struct neighbour *neigh, struct sk_buff *skb);
 static void parp_redo(struct sk_buff *skb);
+static int arp_is_multicast(const void *pkey);
 
 static const struct neigh_ops arp_generic_ops = {
 	.family =		AF_INET,
@@ -160,6 +161,7 @@ struct neigh_table arp_tbl = {
 	.key_eq		= arp_key_eq,
 	.constructor	= arp_constructor,
 	.proxy_redo	= parp_redo,
+	.is_multicast	= arp_is_multicast,
 	.id		= "arp_cache",
 	.parms		= {
 		.tbl			= &arp_tbl,
@@ -932,6 +934,10 @@ static void parp_redo(struct sk_buff *skb)
 	arp_process(dev_net(skb->dev), NULL, skb);
 }
 
+static int arp_is_multicast(const void *pkey)
+{
+	return ipv4_is_multicast(*((__be32 *)pkey));
+}
 
 /*
  *	Receive an arp request from the device layer.
* Unmerged path net/ipv6/ndisc.c
