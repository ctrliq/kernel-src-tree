s390/pci: improve zpci_dev reference counting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit c122383d221dfa2f41cfe5e672540595de986fde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c122383d.failed

Currently zpci_dev uses kref based reference counting but only accounts
for one original reference plus one reference from an added pci_dev to
its underlying zpci_dev. Counting just the original reference worked
until the pci_dev reference was added in commit 2a671f77ee49 ("s390/pci:
fix use after free of zpci_dev") because once a zpci_dev goes away, i.e.
enters the reserved state, it would immediately get released. However
with the pci_dev reference this is no longer the case and the zpci_dev
may still appear in multiple availability events indicating that it was
reserved. This was solved by detecting when the zpci_dev is already on
its way out but still hanging around. This has however shown some light
on how unusual our zpci_dev reference counting is.

Improve upon this by modelling zpci_dev reference counting on pci_dev.
Analogous to pci_get_slot() increment the reference count in
get_zdev_by_fid(). Thus all users of get_zdev_by_fid() must drop the
reference once they are done with the zpci_dev.

Similar to pci_scan_single_device(), zpci_create_device() returns the
device with an initial count of 1 and the device added to the zpci_list
(analogous to the PCI bus' device_list). In turn users of
zpci_create_device() must only drop the reference once the device is
gone from the point of view of the zPCI subsystem, it might still be
referenced by the common PCI subsystem though.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit c122383d221dfa2f41cfe5e672540595de986fde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_clp.c
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/pci/pci_clp.c
index 45c5438cc74b,1057d7af4a55..000000000000
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@@ -372,8 -406,11 +374,16 @@@ static void __clp_add(struct clp_fh_lis
  		return;
  
  	zdev = get_zdev_by_fid(entry->fid);
++<<<<<<< HEAD
 +	if (!zdev)
 +		clp_add_pci_device(entry->fid, entry->fh, entry->config_state);
++=======
+ 	if (zdev) {
+ 		zpci_zdev_put(zdev);
+ 		return;
+ 	}
+ 	zpci_create_device(entry->fid, entry->fh, entry->config_state);
++>>>>>>> c122383d221d (s390/pci: improve zpci_dev reference counting)
  }
  
  int clp_scan_pci_devices(void)
diff --cc arch/s390/pci/pci_event.c
index 82630a0d942f,ea9db5cea64e..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -296,12 -299,25 +298,16 @@@ void zpci_event_error(void *data
  static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
  {
  	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
++<<<<<<< HEAD
 +	struct pci_dev *pdev = NULL;
++=======
+ 	bool existing_zdev = !!zdev;
++>>>>>>> c122383d221d (s390/pci: improve zpci_dev reference counting)
  	enum zpci_state state;
 +	int ret;
 +
 +	if (zdev && zdev->zbus->bus)
 +		pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
  
  	zpci_dbg(3, "avl fid:%x, fh:%x, pec:%x\n",
  		 ccdf->fid, ccdf->fh, ccdf->pec);
diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c
index 0442729136d5..bfa6b98621cb 100644
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -67,6 +67,7 @@ struct zpci_dev *get_zdev_by_fid(u32 fid)
 	list_for_each_entry(tmp, &zpci_list, entry) {
 		if (tmp->fid == fid) {
 			zdev = tmp;
+			zpci_zdev_get(zdev);
 			break;
 		}
 	}
diff --git a/arch/s390/pci/pci_bus.h b/arch/s390/pci/pci_bus.h
index 8808ff0835b8..0c61c26af6bb 100644
--- a/arch/s390/pci/pci_bus.h
+++ b/arch/s390/pci/pci_bus.h
@@ -14,7 +14,8 @@ int zpci_bus_init(void);
 void zpci_release_device(struct kref *kref);
 static inline void zpci_zdev_put(struct zpci_dev *zdev)
 {
-	kref_put(&zdev->kref, zpci_release_device);
+	if (zdev)
+		kref_put(&zdev->kref, zpci_release_device);
 }
 
 static inline void zpci_zdev_get(struct zpci_dev *zdev)
* Unmerged path arch/s390/pci/pci_clp.c
* Unmerged path arch/s390/pci/pci_event.c
