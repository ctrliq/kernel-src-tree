ASoC: SOF: Add a new op to set up volume table

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 48d2a1ceae03610a431535aca9106eab4201b191
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/48d2a1ce.failed

Add a new op set_up_volume_table for control IPC ops. Define and set
the op for IPC3.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
Link: https://lore.kernel.org/r/20220426171743.171061-2-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 48d2a1ceae03610a431535aca9106eab4201b191)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc3-control.c
#	sound/soc/sof/sof-audio.h
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/sof-audio.h
index 8fa422446727,d8ab8600e328..000000000000
--- a/sound/soc/sof/sof-audio.h
+++ b/sound/soc/sof/sof-audio.h
@@@ -30,13 -30,48 +30,27 @@@
  
  #define WIDGET_IS_DAI(id) ((id) == snd_soc_dapm_dai_in || (id) == snd_soc_dapm_dai_out)
  
++<<<<<<< HEAD
++=======
+ #define SOF_DAI_CLK_INTEL_SSP_MCLK	0
+ #define SOF_DAI_CLK_INTEL_SSP_BCLK	1
+ 
+ /*
+  * Volume fractional word length define to 16 sets
+  * the volume linear gain value to use Qx.16 format
+  */
+ #define VOLUME_FWL	16
+ 
+ #define SOF_TLV_ITEMS 3
+ 
++>>>>>>> 48d2a1ceae03 (ASoC: SOF: Add a new op to set up volume table)
  struct snd_sof_widget;
  struct snd_sof_route;
 -struct snd_sof_control;
 -struct snd_sof_dai;
 -
 -struct snd_sof_dai_config_data {
 -	int dai_index;
 -	int dai_data; /* contains DAI-specific information */
 -};
 -
 -/**
 - * struct sof_ipc_pcm_ops - IPC-specific PCM ops
 - * @hw_params: Function pointer for hw_params
 - * @hw_free: Function pointer for hw_free
 - * @trigger: Function pointer for trigger
 - * @dai_link_fixup: Function pointer for DAI link fixup
 - */
 -struct sof_ipc_pcm_ops {
 -	int (*hw_params)(struct snd_soc_component *component, struct snd_pcm_substream *substream,
 -			 struct snd_pcm_hw_params *params,
 -			 struct snd_sof_platform_stream_params *platform_params);
 -	int (*hw_free)(struct snd_soc_component *component, struct snd_pcm_substream *substream);
 -	int (*trigger)(struct snd_soc_component *component,  struct snd_pcm_substream *substream,
 -		       int cmd);
 -	int (*dai_link_fixup)(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_hw_params *params);
 -};
  
  /**
 - * struct sof_ipc_tplg_control_ops - IPC-specific ops for topology kcontrol IO
 + * struct ipc_tplg_control_ops - IPC-specific ops for topology kcontrol IO
   */
 -struct sof_ipc_tplg_control_ops {
 +struct ipc_tplg_control_ops {
  	bool (*volume_put)(struct snd_sof_control *scontrol, struct snd_ctl_elem_value *ucontrol);
  	int (*volume_get)(struct snd_sof_control *scontrol, struct snd_ctl_elem_value *ucontrol);
  	bool (*switch_put)(struct snd_sof_control *scontrol, struct snd_ctl_elem_value *ucontrol);
@@@ -53,6 -88,11 +67,14 @@@
  			     const unsigned int __user *binary_data, unsigned int size);
  	/* update control data based on notification from the DSP */
  	void (*update)(struct snd_sof_dev *sdev, void *ipc_control_message);
++<<<<<<< HEAD
++=======
+ 	/* Optional callback to setup kcontrols associated with an swidget */
+ 	int (*widget_kcontrol_setup)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	/* mandatory callback to set up volume table for volume kcontrols */
+ 	int (*set_up_volume_table)(struct snd_sof_control *scontrol, int tlv[SOF_TLV_ITEMS],
+ 				   int size);
++>>>>>>> 48d2a1ceae03 (ASoC: SOF: Add a new op to set up volume table)
  };
  
  /**
diff --cc sound/soc/sof/topology.c
index 9d9e8416c0b0,739f343010fc..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -28,18 -27,11 +28,17 @@@
  #define VOL_TWENTIETH_ROOT_OF_TEN	73533
  /* 40th root of 10 in Q1.16 fixed-point notation*/
  #define VOL_FORTIETH_ROOT_OF_TEN	69419
 -
 +/*
 + * Volume fractional word length define to 16 sets
 + * the volume linear gain value to use Qx.16 format
 + */
 +#define VOLUME_FWL	16
  /* 0.5 dB step value in topology TLV */
  #define VOL_HALF_DB_STEP	50
 +/* Full volume for default values */
 +#define VOL_ZERO_DB	BIT(VOLUME_FWL)
  
  /* TLV data items */
- #define TLV_ITEMS	3
  #define TLV_MIN		0
  #define TLV_STEP	1
  #define TLV_MUTE	2
@@@ -141,179 -133,7 +140,183 @@@ int sof_update_ipc_object(struct snd_so
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct sof_widget_data {
 +	int ctrl_type;
 +	int ipc_cmd;
 +	struct sof_abi_hdr *pdata;
 +	struct snd_sof_control *control;
 +};
 +
 +/* send pcm params ipc */
 +static int ipc_pcm_params(struct snd_sof_widget *swidget, int dir)
 +{
 +	struct sof_ipc_pcm_params_reply ipc_params_reply;
 +	struct snd_soc_component *scomp = swidget->scomp;
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct sof_ipc_pcm_params pcm;
 +	struct snd_pcm_hw_params *params;
 +	struct snd_sof_pcm *spcm;
 +	int ret;
 +
 +	memset(&pcm, 0, sizeof(pcm));
 +
 +	/* get runtime PCM params using widget's stream name */
 +	spcm = snd_sof_find_spcm_name(scomp, swidget->widget->sname);
 +	if (!spcm) {
 +		dev_err(scomp->dev, "error: cannot find PCM for %s\n",
 +			swidget->widget->name);
 +		return -EINVAL;
 +	}
 +
 +	params = &spcm->params[dir];
 +
 +	/* set IPC PCM params */
 +	pcm.hdr.size = sizeof(pcm);
 +	pcm.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_PARAMS;
 +	pcm.comp_id = swidget->comp_id;
 +	pcm.params.hdr.size = sizeof(pcm.params);
 +	pcm.params.direction = dir;
 +	pcm.params.sample_valid_bytes = params_width(params) >> 3;
 +	pcm.params.buffer_fmt = SOF_IPC_BUFFER_INTERLEAVED;
 +	pcm.params.rate = params_rate(params);
 +	pcm.params.channels = params_channels(params);
 +	pcm.params.host_period_bytes = params_period_bytes(params);
 +
 +	/* set format */
 +	switch (params_format(params)) {
 +	case SNDRV_PCM_FORMAT_S16:
 +		pcm.params.frame_fmt = SOF_IPC_FRAME_S16_LE;
 +		break;
 +	case SNDRV_PCM_FORMAT_S24:
 +		pcm.params.frame_fmt = SOF_IPC_FRAME_S24_4LE;
 +		break;
 +	case SNDRV_PCM_FORMAT_S32:
 +		pcm.params.frame_fmt = SOF_IPC_FRAME_S32_LE;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	/* send IPC to the DSP */
 +	ret = sof_ipc_tx_message(sdev->ipc, pcm.hdr.cmd, &pcm, sizeof(pcm),
 +				 &ipc_params_reply, sizeof(ipc_params_reply));
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: pcm params failed for %s\n",
 +			swidget->widget->name);
 +
 +	return ret;
 +}
 +
 + /* send stream trigger ipc */
 +static int ipc_trigger(struct snd_sof_widget *swidget, int cmd)
 +{
 +	struct snd_soc_component *scomp = swidget->scomp;
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct sof_ipc_stream stream;
 +	struct sof_ipc_reply reply;
 +	int ret;
 +
 +	/* set IPC stream params */
 +	stream.hdr.size = sizeof(stream);
 +	stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | cmd;
 +	stream.comp_id = swidget->comp_id;
 +
 +	/* send IPC to the DSP */
 +	ret = sof_ipc_tx_message(sdev->ipc, stream.hdr.cmd, &stream,
 +				 sizeof(stream), &reply, sizeof(reply));
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: failed to trigger %s\n",
 +			swidget->widget->name);
 +
 +	return ret;
 +}
 +
 +static int sof_keyword_dapm_event(struct snd_soc_dapm_widget *w,
 +				  struct snd_kcontrol *k, int event)
 +{
 +	struct snd_sof_widget *swidget = w->dobj.private;
 +	struct snd_soc_component *scomp;
 +	int stream = SNDRV_PCM_STREAM_CAPTURE;
 +	struct snd_sof_pcm *spcm;
 +	int ret = 0;
 +
 +	if (!swidget)
 +		return 0;
 +
 +	scomp = swidget->scomp;
 +
 +	dev_dbg(scomp->dev, "received event %d for widget %s\n",
 +		event, w->name);
 +
 +	/* get runtime PCM params using widget's stream name */
 +	spcm = snd_sof_find_spcm_name(scomp, swidget->widget->sname);
 +	if (!spcm) {
 +		dev_err(scomp->dev, "error: cannot find PCM for %s\n",
 +			swidget->widget->name);
 +		return -EINVAL;
 +	}
 +
 +	/* process events */
 +	switch (event) {
 +	case SND_SOC_DAPM_PRE_PMU:
 +		if (spcm->stream[stream].suspend_ignored) {
 +			dev_dbg(scomp->dev, "PRE_PMU event ignored, KWD pipeline is already RUNNING\n");
 +			return 0;
 +		}
 +
 +		/* set pcm params */
 +		ret = ipc_pcm_params(swidget, stream);
 +		if (ret < 0) {
 +			dev_err(scomp->dev,
 +				"error: failed to set pcm params for widget %s\n",
 +				swidget->widget->name);
 +			break;
 +		}
 +
 +		/* start trigger */
 +		ret = ipc_trigger(swidget, SOF_IPC_STREAM_TRIG_START);
 +		if (ret < 0)
 +			dev_err(scomp->dev,
 +				"error: failed to trigger widget %s\n",
 +				swidget->widget->name);
 +		break;
 +	case SND_SOC_DAPM_POST_PMD:
 +		if (spcm->stream[stream].suspend_ignored) {
 +			dev_dbg(scomp->dev, "POST_PMD even ignored, KWD pipeline will remain RUNNING\n");
 +			return 0;
 +		}
 +
 +		/* stop trigger */
 +		ret = ipc_trigger(swidget, SOF_IPC_STREAM_TRIG_STOP);
 +		if (ret < 0)
 +			dev_err(scomp->dev,
 +				"error: failed to trigger widget %s\n",
 +				swidget->widget->name);
 +
 +		/* pcm free */
 +		ret = ipc_trigger(swidget, SOF_IPC_STREAM_PCM_FREE);
 +		if (ret < 0)
 +			dev_err(scomp->dev,
 +				"error: failed to trigger widget %s\n",
 +				swidget->widget->name);
 +		break;
 +	default:
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +/* event handlers for keyword detect component */
 +static const struct snd_soc_tplg_widget_events sof_kwd_events[] = {
 +	{SOF_KEYWORD_DETECT_DAPM_EVENT, sof_keyword_dapm_event},
 +};
 +
 +static inline int get_tlv_data(const int *p, int tlv[TLV_ITEMS])
++=======
+ static inline int get_tlv_data(const int *p, int tlv[SOF_TLV_ITEMS])
++>>>>>>> 48d2a1ceae03 (ASoC: SOF: Add a new op to set up volume table)
  {
  	/* we only support dB scale TLV type at the moment */
  	if ((int)p[SNDRV_CTL_TLVO_TYPE] != SNDRV_CTL_TLVT_DB_SCALE)
@@@ -1154,9 -768,8 +1154,14 @@@ static int sof_control_load_volume(stru
  	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
  	struct snd_soc_tplg_mixer_control *mc =
  		container_of(hdr, struct snd_soc_tplg_mixer_control, hdr);
++<<<<<<< HEAD
 +	struct sof_ipc_ctrl_data *cdata;
 +	int tlv[TLV_ITEMS];
 +	unsigned int i;
++=======
+ 	int tlv[SOF_TLV_ITEMS];
+ 	unsigned int mask;
++>>>>>>> 48d2a1ceae03 (ASoC: SOF: Add a new op to set up volume table)
  	int ret;
  
  	/* validate topology data */
* Unmerged path sound/soc/sof/ipc3-control.c
* Unmerged path sound/soc/sof/ipc3-control.c
* Unmerged path sound/soc/sof/sof-audio.h
* Unmerged path sound/soc/sof/topology.c
