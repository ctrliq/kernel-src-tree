scsi: mpi3mr: Free enclosure objects during driver unload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit 130fc180a48141cb6fbfdb30138a114cf9be61c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/130fc180.failed

Free the enclosure device objects during driver unload and before
rescanning the target devices during controller reset.

Link: https://lore.kernel.org/r/20220912135742.11764-7-sreekanth.reddy@broadcom.com
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 130fc180a48141cb6fbfdb30138a114cf9be61c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_os.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 8de3e5650c79,883ed59f731f..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -1084,6 -1330,67 +1084,68 @@@ int mpi3mr_pel_get_seqnum_post(struct m
  	struct mpi3mr_drv_cmd *drv_cmd);
  void mpi3mr_app_save_logdata(struct mpi3mr_ioc *mrioc, char *event_data,
  	u16 event_data_size);
 -struct mpi3mr_enclosure_node *mpi3mr_enclosure_find_by_handle(
 -	struct mpi3mr_ioc *mrioc, u16 handle);
 -extern const struct attribute_group *mpi3mr_host_groups[];
 +extern struct device_attribute *mpi3mr_host_attrs[];
  extern const struct attribute_group *mpi3mr_dev_groups[];
++<<<<<<< HEAD
++=======
+ 
+ extern struct sas_function_template mpi3mr_transport_functions;
+ extern struct scsi_transport_template *mpi3mr_transport_template;
+ 
+ int mpi3mr_cfg_get_dev_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_device_page0 *dev_pg0, u16 pg_sz, u32 form, u32 form_spec);
+ int mpi3mr_cfg_get_sas_phy_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_phy_page0 *phy_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_phy_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_phy_page1 *phy_pg1, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_exp_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_expander_page0 *exp_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_exp_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_sas_expander_page1 *exp_pg1, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_enclosure_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,
+ 	struct mpi3_enclosure_page0 *encl_pg0, u16 pg_sz, u32 form,
+ 	u32 form_spec);
+ int mpi3mr_cfg_get_sas_io_unit_pg0(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page0 *sas_io_unit_pg0, u16 pg_sz);
+ int mpi3mr_cfg_get_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
+ int mpi3mr_cfg_set_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz);
+ int mpi3mr_cfg_get_driver_pg1(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_driver_page1 *driver_pg1, u16 pg_sz);
+ 
+ u8 mpi3mr_is_expander_device(u16 device_info);
+ int mpi3mr_expander_add(struct mpi3mr_ioc *mrioc, u16 handle);
+ void mpi3mr_expander_remove(struct mpi3mr_ioc *mrioc, u64 sas_address,
+ 	struct mpi3mr_hba_port *hba_port);
+ struct mpi3mr_sas_node *__mpi3mr_expander_find_by_handle(struct mpi3mr_ioc
+ 	*mrioc, u16 handle);
+ struct mpi3mr_hba_port *mpi3mr_get_hba_port_by_id(struct mpi3mr_ioc *mrioc,
+ 	u8 port_id);
+ void mpi3mr_sas_host_refresh(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_sas_host_add(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_update_links(struct mpi3mr_ioc *mrioc,
+ 	u64 sas_address_parent, u16 handle, u8 phy_number, u8 link_rate,
+ 	struct mpi3mr_hba_port *hba_port);
+ void mpi3mr_remove_tgtdev_from_host(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ int mpi3mr_report_tgtdev_to_sas_transport(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ void mpi3mr_remove_tgtdev_from_sas_transport(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_tgt_dev *tgtdev);
+ struct mpi3mr_tgt_dev *__mpi3mr_get_tgtdev_by_addr_and_rphy(
+ 	struct mpi3mr_ioc *mrioc, u64 sas_address, struct sas_rphy *rphy);
+ void mpi3mr_print_device_event_notice(struct mpi3mr_ioc *mrioc,
+ 	bool device_add);
+ void mpi3mr_refresh_sas_ports(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_refresh_expanders(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_add_event_wait_for_device_refresh(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_flush_drv_cmds(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_flush_cmds_for_unrecovered_controller(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_free_enclosure_list(struct mpi3mr_ioc *mrioc);
++>>>>>>> 130fc180a481 (scsi: mpi3mr: Free enclosure objects during driver unload)
  #endif /*MPI3MR_H_INCLUDED*/
diff --cc drivers/scsi/mpi3mr/mpi3mr_os.c
index 763813eeab8b,282ec4b382da..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@@ -1156,6 -1335,135 +1156,138 @@@ out
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mpi3mr_free_enclosure_list - release enclosures
+  * @mrioc: Adapter instance reference
+  *
+  * Free memory allocated during encloure add.
+  *
+  * Return nothing.
+  */
+ void mpi3mr_free_enclosure_list(struct mpi3mr_ioc *mrioc)
+ {
+ 	struct mpi3mr_enclosure_node *enclosure_dev, *enclosure_dev_next;
+ 
+ 	list_for_each_entry_safe(enclosure_dev,
+ 	    enclosure_dev_next, &mrioc->enclosure_list, list) {
+ 		list_del(&enclosure_dev->list);
+ 		kfree(enclosure_dev);
+ 	}
+ }
+ 
+ /**
+  * mpi3mr_enclosure_find_by_handle - enclosure search by handle
+  * @mrioc: Adapter instance reference
+  * @handle: Firmware device handle of the enclosure
+  *
+  * This searches for enclosure device based on handle, then returns the
+  * enclosure object.
+  *
+  * Return: Enclosure object reference or NULL
+  */
+ struct mpi3mr_enclosure_node *mpi3mr_enclosure_find_by_handle(
+ 	struct mpi3mr_ioc *mrioc, u16 handle)
+ {
+ 	struct mpi3mr_enclosure_node *enclosure_dev, *r = NULL;
+ 
+ 	list_for_each_entry(enclosure_dev, &mrioc->enclosure_list, list) {
+ 		if (le16_to_cpu(enclosure_dev->pg0.enclosure_handle) != handle)
+ 			continue;
+ 		r = enclosure_dev;
+ 		goto out;
+ 	}
+ out:
+ 	return r;
+ }
+ 
+ /**
+  * mpi3mr_encldev_add_chg_evt_debug - debug for enclosure event
+  * @mrioc: Adapter instance reference
+  * @encl_pg0: Enclosure page 0.
+  * @is_added: Added event or not
+  *
+  * Return nothing.
+  */
+ static void mpi3mr_encldev_add_chg_evt_debug(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3_enclosure_page0 *encl_pg0, u8 is_added)
+ {
+ 	char *reason_str = NULL;
+ 
+ 	if (!(mrioc->logging_level & MPI3_DEBUG_EVENT_WORK_TASK))
+ 		return;
+ 
+ 	if (is_added)
+ 		reason_str = "enclosure added";
+ 	else
+ 		reason_str = "enclosure dev status changed";
+ 
+ 	ioc_info(mrioc,
+ 	    "%s: handle(0x%04x), enclosure logical id(0x%016llx)\n",
+ 	    reason_str, le16_to_cpu(encl_pg0->enclosure_handle),
+ 	    (unsigned long long)le64_to_cpu(encl_pg0->enclosure_logical_id));
+ 	ioc_info(mrioc,
+ 	    "number of slots(%d), port(%d), flags(0x%04x), present(%d)\n",
+ 	    le16_to_cpu(encl_pg0->num_slots), encl_pg0->io_unit_port,
+ 	    le16_to_cpu(encl_pg0->flags),
+ 	    ((le16_to_cpu(encl_pg0->flags) &
+ 	      MPI3_ENCLS0_FLAGS_ENCL_DEV_PRESENT_MASK) >> 4));
+ }
+ 
+ /**
+  * mpi3mr_encldev_add_chg_evt_bh - Enclosure evt bottomhalf
+  * @mrioc: Adapter instance reference
+  * @fwevt: Firmware event reference
+  *
+  * Prints information about the Enclosure device status or
+  * Enclosure add events if logging is enabled and add or remove
+  * the enclosure from the controller's internal list of
+  * enclosures.
+  *
+  * Return: Nothing.
+  */
+ static void mpi3mr_encldev_add_chg_evt_bh(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_fwevt *fwevt)
+ {
+ 	struct mpi3mr_enclosure_node *enclosure_dev = NULL;
+ 	struct mpi3_enclosure_page0 *encl_pg0;
+ 	u16 encl_handle;
+ 	u8 added, present;
+ 
+ 	encl_pg0 = (struct mpi3_enclosure_page0 *) fwevt->event_data;
+ 	added = (fwevt->event_id == MPI3_EVENT_ENCL_DEVICE_ADDED) ? 1 : 0;
+ 	mpi3mr_encldev_add_chg_evt_debug(mrioc, encl_pg0, added);
+ 
+ 
+ 	encl_handle = le16_to_cpu(encl_pg0->enclosure_handle);
+ 	present = ((le16_to_cpu(encl_pg0->flags) &
+ 	      MPI3_ENCLS0_FLAGS_ENCL_DEV_PRESENT_MASK) >> 4);
+ 
+ 	if (encl_handle)
+ 		enclosure_dev = mpi3mr_enclosure_find_by_handle(mrioc,
+ 		    encl_handle);
+ 	if (!enclosure_dev && present) {
+ 		enclosure_dev =
+ 			kzalloc(sizeof(struct mpi3mr_enclosure_node),
+ 			    GFP_KERNEL);
+ 		if (!enclosure_dev)
+ 			return;
+ 		list_add_tail(&enclosure_dev->list,
+ 		    &mrioc->enclosure_list);
+ 	}
+ 	if (enclosure_dev) {
+ 		if (!present) {
+ 			list_del(&enclosure_dev->list);
+ 			kfree(enclosure_dev);
+ 		} else
+ 			memcpy(&enclosure_dev->pg0, encl_pg0,
+ 			    sizeof(enclosure_dev->pg0));
+ 
+ 	}
+ }
+ 
+ /**
++>>>>>>> 130fc180a481 (scsi: mpi3mr: Free enclosure objects during driver unload)
   * mpi3mr_sastopochg_evt_debug - SASTopoChange details
   * @mrioc: Adapter instance reference
   * @event_data: SAS topology change list event data
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
diff --git a/drivers/scsi/mpi3mr/mpi3mr_fw.c b/drivers/scsi/mpi3mr/mpi3mr_fw.c
index 697cfbded476..09499385aecb 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@ -4059,6 +4059,8 @@ void mpi3mr_free_mem(struct mpi3mr_ioc *mrioc)
 	u16 i;
 	struct mpi3mr_intr_info *intr_info;
 
+	mpi3mr_free_enclosure_list(mrioc);
+
 	if (mrioc->sense_buf_pool) {
 		if (mrioc->sense_buf)
 			dma_pool_free(mrioc->sense_buf_pool, mrioc->sense_buf,
@@ -4687,6 +4689,8 @@ int mpi3mr_soft_reset_handler(struct mpi3mr_ioc *mrioc,
 	mpi3mr_flush_host_io(mrioc);
 	mpi3mr_cleanup_fwevt_list(mrioc);
 	mpi3mr_invalidate_devhandles(mrioc);
+	mpi3mr_free_enclosure_list(mrioc);
+
 	if (mrioc->prepare_for_reset) {
 		mrioc->prepare_for_reset = 0;
 		mrioc->prepare_for_reset_timeout_counter = 0;
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_os.c
