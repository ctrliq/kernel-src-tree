ipv4: Calculate multipath hash inside switch statement

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ido Schimmel <idosch@OSS.NVIDIA.COM>
commit 2e68ea92684181412b73979baf1af7d04619c52c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2e68ea92.failed

A subsequent patch will add another multipath hash policy where the
multipath hash is calculated directly by the policy specific code and
not outside of the switch statement.

Prepare for this change by moving the multipath hash calculation inside
the switch statement.

No functional changes intended.

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2e68ea92684181412b73979baf1af7d04619c52c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/route.c
diff --cc net/ipv4/route.c
index 5ad19572d74a,9d61e969446e..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1898,8 -1910,9 +1898,8 @@@ out
  int fib_multipath_hash(const struct net *net, const struct flowi4 *fl4,
  		       const struct sk_buff *skb, struct flow_keys *flkeys)
  {
 -	u32 multipath_hash = fl4 ? fl4->flowi4_multipath_hash : 0;
  	struct flow_keys hash_keys;
- 	u32 mhash;
+ 	u32 mhash = 0;
  
  	switch (net->ipv4.sysctl_fib_multipath_hash_policy) {
  	case 0:
@@@ -1944,10 -1958,44 +1945,44 @@@
  			hash_keys.ports.dst = fl4->fl4_dport;
  			hash_keys.basic.ip_proto = fl4->flowi4_proto;
  		}
+ 		mhash = flow_hash_from_keys(&hash_keys);
  		break;
++<<<<<<< HEAD
++=======
+ 	case 2:
+ 		memset(&hash_keys, 0, sizeof(hash_keys));
+ 		/* skb is currently provided only when forwarding */
+ 		if (skb) {
+ 			struct flow_keys keys;
+ 
+ 			skb_flow_dissect_flow_keys(skb, &keys, 0);
+ 			/* Inner can be v4 or v6 */
+ 			if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
+ 				hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 				hash_keys.addrs.v4addrs.src = keys.addrs.v4addrs.src;
+ 				hash_keys.addrs.v4addrs.dst = keys.addrs.v4addrs.dst;
+ 			} else if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {
+ 				hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+ 				hash_keys.addrs.v6addrs.src = keys.addrs.v6addrs.src;
+ 				hash_keys.addrs.v6addrs.dst = keys.addrs.v6addrs.dst;
+ 				hash_keys.tags.flow_label = keys.tags.flow_label;
+ 				hash_keys.basic.ip_proto = keys.basic.ip_proto;
+ 			} else {
+ 				/* Same as case 0 */
+ 				hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 				ip_multipath_l3_keys(skb, &hash_keys);
+ 			}
+ 		} else {
+ 			/* Same as case 0 */
+ 			hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 			hash_keys.addrs.v4addrs.src = fl4->saddr;
+ 			hash_keys.addrs.v4addrs.dst = fl4->daddr;
+ 		}
+ 		mhash = flow_hash_from_keys(&hash_keys);
+ 		break;
++>>>>>>> 2e68ea926841 (ipv4: Calculate multipath hash inside switch statement)
  	}
- 	mhash = flow_hash_from_keys(&hash_keys);
  
 -	if (multipath_hash)
 -		mhash = jhash_2words(mhash, multipath_hash, 0);
 -
  	return mhash >> 1;
  }
  #endif /* CONFIG_IP_ROUTE_MULTIPATH */
* Unmerged path net/ipv4/route.c
