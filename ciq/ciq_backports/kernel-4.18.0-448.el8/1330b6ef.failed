skb: make drop reason booleanable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 1330b6ef3313fcec577d2b020c290dc8b9f11f1a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1330b6ef.failed

We have a number of cases where function returns drop/no drop
decision as a boolean. Now that we want to report the reason
code as well we have to pass extra output arguments.

We can make the reason code evaluate correctly as bool.

I believe we're good to reorder the reasons as they are
reported to user space as strings.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1330b6ef3313fcec577d2b020c290dc8b9f11f1a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/net/tcp.h
#	net/ipv4/tcp.c
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc include/linux/skbuff.h
index 6050fa383222,26538ceb4b01..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,136 +318,140 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_NOT_DROPPED_YET = 0,
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
+ 	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+ 					 * see the document for rp_filter
+ 					 * in ip-sysctl.rst for more
+ 					 * information
+ 					 */
+ 	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+ 						  * is multicast, but L3 is
+ 						  * unicast.
+ 						  */
+ 	SKB_DROP_REASON_XFRM_POLICY,	/* xfrm policy check failed */
+ 	SKB_DROP_REASON_IP_NOPROTO,	/* no support for IP protocol */
+ 	SKB_DROP_REASON_SOCKET_RCVBUFF,	/* socket receive buff is full */
+ 	SKB_DROP_REASON_PROTO_MEM,	/* proto memory limition, such as
+ 					 * udp packet drop out of
+ 					 * udp_memory_allocated.
+ 					 */
+ 	SKB_DROP_REASON_TCP_MD5NOTFOUND,	/* no MD5 hash and one
+ 						 * expected, corresponding
+ 						 * to LINUX_MIB_TCPMD5NOTFOUND
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5UNEXPECTED,	/* MD5 hash and we're not
+ 						 * expecting one, corresponding
+ 						 * to LINUX_MIB_TCPMD5UNEXPECTED
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5FAILURE,	/* MD5 hash and its wrong,
+ 					 * corresponding to
+ 					 * LINUX_MIB_TCPMD5FAILURE
+ 					 */
+ 	SKB_DROP_REASON_SOCKET_BACKLOG,	/* failed to add skb to socket
+ 					 * backlog (see
+ 					 * LINUX_MIB_TCPBACKLOGDROP)
+ 					 */
+ 	SKB_DROP_REASON_TCP_FLAGS,	/* TCP flags invalid */
+ 	SKB_DROP_REASON_TCP_ZEROWINDOW,	/* TCP receive window size is zero,
+ 					 * see LINUX_MIB_TCPZEROWINDOWDROP
+ 					 */
+ 	SKB_DROP_REASON_TCP_OLD_DATA,	/* the TCP data reveived is already
+ 					 * received before (spurious retrans
+ 					 * may happened), see
+ 					 * LINUX_MIB_DELAYEDACKLOST
+ 					 */
+ 	SKB_DROP_REASON_TCP_OVERWINDOW,	/* the TCP data is out of window,
+ 					 * the seq of the first byte exceed
+ 					 * the right edges of receive
+ 					 * window
+ 					 */
+ 	SKB_DROP_REASON_TCP_OFOMERGE,	/* the data of skb is already in
+ 					 * the ofo queue, corresponding to
+ 					 * LINUX_MIB_TCPOFOMERGE
+ 					 */
+ 	SKB_DROP_REASON_IP_OUTNOROUTES,	/* route lookup failed */
+ 	SKB_DROP_REASON_BPF_CGROUP_EGRESS,	/* dropped by
+ 						 * BPF_PROG_TYPE_CGROUP_SKB
+ 						 * eBPF program
+ 						 */
+ 	SKB_DROP_REASON_IPV6DISABLED,	/* IPv6 is disabled on the device */
+ 	SKB_DROP_REASON_NEIGH_CREATEFAIL,	/* failed to create neigh
+ 						 * entry
+ 						 */
+ 	SKB_DROP_REASON_NEIGH_FAILED,	/* neigh entry in failed state */
+ 	SKB_DROP_REASON_NEIGH_QUEUEFULL,	/* arp_queue for neigh
+ 						 * entry is full
+ 						 */
+ 	SKB_DROP_REASON_NEIGH_DEAD,	/* neigh entry is dead */
+ 	SKB_DROP_REASON_TC_EGRESS,	/* dropped in TC egress HOOK */
+ 	SKB_DROP_REASON_QDISC_DROP,	/* dropped by qdisc when packet
+ 					 * outputting (failed to enqueue to
+ 					 * current qdisc)
+ 					 */
+ 	SKB_DROP_REASON_CPU_BACKLOG,	/* failed to enqueue the skb to
+ 					 * the per CPU backlog queue. This
+ 					 * can be caused by backlog queue
+ 					 * full (see netdev_max_backlog in
+ 					 * net.rst) or RPS flow limit
+ 					 */
+ 	SKB_DROP_REASON_XDP,		/* dropped by XDP in input path */
+ 	SKB_DROP_REASON_TC_INGRESS,	/* dropped in TC ingress HOOK */
+ 	SKB_DROP_REASON_PTYPE_ABSENT,	/* not packet_type found to handle
+ 					 * the skb. For an etner packet,
+ 					 * this means that L3 protocol is
+ 					 * not supported
+ 					 */
+ 	SKB_DROP_REASON_SKB_CSUM,	/* sk_buff checksum computation
+ 					 * error
+ 					 */
+ 	SKB_DROP_REASON_SKB_GSO_SEG,	/* gso segmentation error */
+ 	SKB_DROP_REASON_SKB_UCOPY_FAULT,	/* failed to copy data from
+ 						 * user space, e.g., via
+ 						 * zerocopy_sg_from_iter()
+ 						 * or skb_orphan_frags_rx()
+ 						 */
+ 	SKB_DROP_REASON_DEV_HDR,	/* device driver specific
+ 					 * header/metadata is invalid
+ 					 */
+ 	/* the device is not ready to xmit/recv due to any of its data
+ 	 * structure that is not up/ready/initialized, e.g., the IFF_UP is
+ 	 * not set, or driver specific tun->tfiles[txq] is not initialized
+ 	 */
+ 	SKB_DROP_REASON_DEV_READY,
+ 	SKB_DROP_REASON_FULL_RING,	/* ring buffer is full */
+ 	SKB_DROP_REASON_NOMEM,		/* error due to OOM */
+ 	SKB_DROP_REASON_HDR_TRUNC,      /* failed to trunc/extract the header
+ 					 * from networking data, e.g., failed
+ 					 * to pull the protocol header from
+ 					 * frags via pskb_may_pull()
+ 					 */
+ 	SKB_DROP_REASON_TAP_FILTER,     /* dropped by (ebpf) filter directly
+ 					 * attached to tun/tap, e.g., via
+ 					 * TUNSETFILTEREBPF
+ 					 */
+ 	SKB_DROP_REASON_TAP_TXFILTER,	/* dropped by tx filter implemented
+ 					 * at tun/tap, e.g., check_filter()
+ 					 */
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/net/tcp.h
index b28247822b8f,ee8237b58e1d..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -1634,14 -1667,19 +1634,23 @@@ struct tcp_md5sig_key *__tcp_md5_do_loo
  					   const union tcp_md5_addr *addr,
  					   int family);
  static inline struct tcp_md5sig_key *
 -tcp_md5_do_lookup(const struct sock *sk, int l3index,
 -		  const union tcp_md5_addr *addr, int family)
 +tcp_md5_do_lookup(const struct sock *sk,
 +		  const union tcp_md5_addr *addr,
 +		  int family)
  {
 -	if (!static_branch_unlikely(&tcp_md5_needed))
 +	if (!static_key_false(&tcp_md5_needed))
  		return NULL;
 -	return __tcp_md5_do_lookup(sk, l3index, addr, family);
 +	return __tcp_md5_do_lookup(sk, addr, family);
  }
++<<<<<<< HEAD
++=======
+ 
+ enum skb_drop_reason
+ tcp_inbound_md5_hash(const struct sock *sk, const struct sk_buff *skb,
+ 		     const void *saddr, const void *daddr,
+ 		     int family, int dif, int sdif);
+ 
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  
  #define tcp_twsk_md5_key(twsk)	((twsk)->tw_md5_key)
  #else
@@@ -1651,6 -1689,14 +1660,17 @@@ static inline struct tcp_md5sig_key *tc
  {
  	return NULL;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline enum skb_drop_reason
+ tcp_inbound_md5_hash(const struct sock *sk, const struct sk_buff *skb,
+ 		     const void *saddr, const void *daddr,
+ 		     int family, int dif, int sdif);
+ {
+ 	return SKB_NOT_DROPPED_YET;
+ }
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  #define tcp_twsk_md5_key(twsk)	NULL
  #endif
  
diff --cc net/ipv4/tcp.c
index 2fededb1560d,b5f032958b2c..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -3921,6 -4433,73 +3921,76 @@@ int tcp_md5_hash_key(struct tcp_md5sig_
  }
  EXPORT_SYMBOL(tcp_md5_hash_key);
  
++<<<<<<< HEAD
++=======
+ /* Called with rcu_read_lock() */
+ enum skb_drop_reason
+ tcp_inbound_md5_hash(const struct sock *sk, const struct sk_buff *skb,
+ 		     const void *saddr, const void *daddr,
+ 		     int family, int dif, int sdif)
+ {
+ 	/*
+ 	 * This gets called for each TCP segment that arrives
+ 	 * so we want to be efficient.
+ 	 * We have 3 drop cases:
+ 	 * o No MD5 hash and one expected.
+ 	 * o MD5 hash and we're not expecting one.
+ 	 * o MD5 hash and its wrong.
+ 	 */
+ 	const __u8 *hash_location = NULL;
+ 	struct tcp_md5sig_key *hash_expected;
+ 	const struct tcphdr *th = tcp_hdr(skb);
+ 	struct tcp_sock *tp = tcp_sk(sk);
+ 	int genhash, l3index;
+ 	u8 newhash[16];
+ 
+ 	/* sdif set, means packet ingressed via a device
+ 	 * in an L3 domain and dif is set to the l3mdev
+ 	 */
+ 	l3index = sdif ? dif : 0;
+ 
+ 	hash_expected = tcp_md5_do_lookup(sk, l3index, saddr, family);
+ 	hash_location = tcp_parse_md5sig_option(th);
+ 
+ 	/* We've parsed the options - do we have a hash? */
+ 	if (!hash_expected && !hash_location)
+ 		return SKB_NOT_DROPPED_YET;
+ 
+ 	if (hash_expected && !hash_location) {
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);
+ 		return SKB_DROP_REASON_TCP_MD5NOTFOUND;
+ 	}
+ 
+ 	if (!hash_expected && hash_location) {
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);
+ 		return SKB_DROP_REASON_TCP_MD5UNEXPECTED;
+ 	}
+ 
+ 	/* check the signature */
+ 	genhash = tp->af_specific->calc_md5_hash(newhash, hash_expected,
+ 						 NULL, skb);
+ 
+ 	if (genhash || memcmp(hash_location, newhash, 16) != 0) {
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);
+ 		if (family == AF_INET) {
+ 			net_info_ratelimited("MD5 Hash failed for (%pI4, %d)->(%pI4, %d)%s L3 index %d\n",
+ 					saddr, ntohs(th->source),
+ 					daddr, ntohs(th->dest),
+ 					genhash ? " tcp_v4_calc_md5_hash failed"
+ 					: "", l3index);
+ 		} else {
+ 			net_info_ratelimited("MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u L3 index %d\n",
+ 					genhash ? "failed" : "mismatch",
+ 					saddr, ntohs(th->source),
+ 					daddr, ntohs(th->dest), l3index);
+ 		}
+ 		return SKB_DROP_REASON_TCP_MD5FAILURE;
+ 	}
+ 	return SKB_NOT_DROPPED_YET;
+ }
+ EXPORT_SYMBOL(tcp_inbound_md5_hash);
+ 
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  #endif
  
  void tcp_done(struct sock *sk)
diff --cc net/ipv4/tcp_ipv4.c
index 95c80d8a7e12,81694a354110..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1913,7 -1965,10 +1913,14 @@@ process
  		struct sock *nsk;
  
  		sk = req->rsk_listener;
++<<<<<<< HEAD
 +		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))) {
++=======
+ 		drop_reason = tcp_inbound_md5_hash(sk, skb,
+ 						   &iph->saddr, &iph->daddr,
+ 						   AF_INET, dif, sdif);
+ 		if (unlikely(drop_reason)) {
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  			sk_drops_add(sk, skb);
  			reqsk_put(req);
  			goto discard_it;
@@@ -1975,13 -2042,17 +1982,19 @@@
  		goto discard_and_relse;
  	}
  
++<<<<<<< HEAD
 +	if (tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))
++=======
+ 	drop_reason = tcp_inbound_md5_hash(sk, skb, &iph->saddr,
+ 					   &iph->daddr, AF_INET, dif, sdif);
+ 	if (drop_reason)
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  		goto discard_and_relse;
  
 -	nf_reset_ct(skb);
 +	nf_reset(skb);
  
 -	if (tcp_filter(sk, skb)) {
 -		drop_reason = SKB_DROP_REASON_SOCKET_FILTER;
 +	if (tcp_filter(sk, skb))
  		goto discard_and_relse;
 -	}
  	th = (const struct tcphdr *)skb->data;
  	iph = ip_hdr(skb);
  	tcp_v4_fill_cb(skb, iph, th);
diff --cc net/ipv6/tcp_ipv6.c
index 8cdff0ded837,13678d3908fa..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1558,7 -1632,10 +1558,14 @@@ process
  		struct sock *nsk;
  
  		sk = req->rsk_listener;
++<<<<<<< HEAD
 +		if (tcp_v6_inbound_md5_hash(sk, skb, dif, sdif)) {
++=======
+ 		drop_reason = tcp_inbound_md5_hash(sk, skb,
+ 						   &hdr->saddr, &hdr->daddr,
+ 						   AF_INET6, dif, sdif);
+ 		if (drop_reason) {
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  			sk_drops_add(sk, skb);
  			reqsk_put(req);
  			goto discard_it;
@@@ -1610,14 -1706,15 +1617,20 @@@
  		goto discard_and_relse;
  	}
  
++<<<<<<< HEAD
 +	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
++=======
+ 	drop_reason = tcp_inbound_md5_hash(sk, skb, &hdr->saddr, &hdr->daddr,
+ 					   AF_INET6, dif, sdif);
+ 	if (drop_reason)
++>>>>>>> 1330b6ef3313 (skb: make drop reason booleanable)
  		goto discard_and_relse;
  
 -	if (tcp_filter(sk, skb)) {
 -		drop_reason = SKB_DROP_REASON_SOCKET_FILTER;
 +	if (tcp_v6_inbound_md5_hash(sk, skb, dif, sdif))
 +		goto discard_and_relse;
 +
 +	if (tcp_filter(sk, skb))
  		goto discard_and_relse;
 -	}
  	th = (const struct tcphdr *)skb->data;
  	hdr = ipv6_hdr(skb);
  	tcp_v6_fill_cb(skb, hdr, th);
* Unmerged path include/linux/skbuff.h
* Unmerged path include/net/tcp.h
* Unmerged path net/ipv4/tcp.c
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
