net/mlx5: Let user configure max_macs generic param

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Shay Drory <shayd@nvidia.com>
commit 8680a60fc1fc19b5bcf50f6cfd9b5d08fc799926
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8680a60f.failed

Currently, max_macs is taking 70Kbytes of memory per function. This
size is not needed in all use cases, and is critical with large scale.
Hence, allow user to configure the number of max_macs.

For example, to reduce the number of max_macs to 1, execute::
$ devlink dev param set pci/0000:00:0b.0 name max_macs value 1 \
              cmode driverinit
$ devlink dev reload pci/0000:00:0b.0

	Signed-off-by: Shay Drory <shayd@nvidia.com>
	Reviewed-by: Moshe Shemesh <moshe@nvidia.com>
	Reviewed-by: Parav Pandit <parav@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 8680a60fc1fc19b5bcf50f6cfd9b5d08fc799926)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/devlink/mlx5.rst
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
diff --cc Documentation/networking/devlink/mlx5.rst
index cbc9b443eb2d,38e94ed65936..000000000000
--- a/Documentation/networking/devlink/mlx5.rst
+++ b/Documentation/networking/devlink/mlx5.rst
@@@ -14,8 -14,18 +14,20 @@@ Parameter
  
     * - Name
       - Mode
 -     - Validation
     * - ``enable_roce``
       - driverinit
++<<<<<<< HEAD
++=======
+    * - ``io_eq_size``
+      - driverinit
+      - The range is between 64 and 4096.
+    * - ``event_eq_size``
+      - driverinit
+      - The range is between 64 and 4096.
+    * - ``max_macs``
+      - driverinit
+      - The range is between 1 and 2^31. Only power of 2 values are supported.
++>>>>>>> 8680a60fc1fc (net/mlx5: Let user configure max_macs generic param)
  
  The ``mlx5`` driver also implements the following driver-specific
  parameters.
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index 24fbc7212646,d1093bb2d436..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -608,8 -619,220 +608,68 @@@ static void mlx5_devlink_set_params_ini
  						   value);
  	}
  #endif
 -
 -	value.vu32 = MLX5_COMP_EQ_SIZE;
 -	devlink_param_driverinit_value_set(devlink,
 -					   DEVLINK_PARAM_GENERIC_ID_IO_EQ_SIZE,
 -					   value);
 -
 -	value.vu32 = MLX5_NUM_ASYNC_EQE;
 -	devlink_param_driverinit_value_set(devlink,
 -					   DEVLINK_PARAM_GENERIC_ID_EVENT_EQ_SIZE,
 -					   value);
 -}
 -
 -static const struct devlink_param enable_eth_param =
 -	DEVLINK_PARAM_GENERIC(ENABLE_ETH, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
 -			      NULL, NULL, NULL);
 -
 -static int mlx5_devlink_eth_param_register(struct devlink *devlink)
 -{
 -	struct mlx5_core_dev *dev = devlink_priv(devlink);
 -	union devlink_param_value value;
 -	int err;
 -
 -	if (!mlx5_eth_supported(dev))
 -		return 0;
 -
 -	err = devlink_param_register(devlink, &enable_eth_param);
 -	if (err)
 -		return err;
 -
 -	value.vbool = true;
 -	devlink_param_driverinit_value_set(devlink,
 -					   DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH,
 -					   value);
 -	return 0;
 -}
 -
 -static void mlx5_devlink_eth_param_unregister(struct devlink *devlink)
 -{
 -	struct mlx5_core_dev *dev = devlink_priv(devlink);
 -
 -	if (!mlx5_eth_supported(dev))
 -		return;
 -
 -	devlink_param_unregister(devlink, &enable_eth_param);
 -}
 -
 -static int mlx5_devlink_enable_rdma_validate(struct devlink *devlink, u32 id,
 -					     union devlink_param_value val,
 -					     struct netlink_ext_ack *extack)
 -{
 -	struct mlx5_core_dev *dev = devlink_priv(devlink);
 -	bool new_state = val.vbool;
 -
 -	if (new_state && !mlx5_rdma_supported(dev))
 -		return -EOPNOTSUPP;
 -	return 0;
 -}
 -
 -static const struct devlink_param enable_rdma_param =
 -	DEVLINK_PARAM_GENERIC(ENABLE_RDMA, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
 -			      NULL, NULL, mlx5_devlink_enable_rdma_validate);
 -
 -static int mlx5_devlink_rdma_param_register(struct devlink *devlink)
 -{
 -	union devlink_param_value value;
 -	int err;
 -
 -	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))
 -		return 0;
 -
 -	err = devlink_param_register(devlink, &enable_rdma_param);
 -	if (err)
 -		return err;
 -
 -	value.vbool = true;
 -	devlink_param_driverinit_value_set(devlink,
 -					   DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,
 -					   value);
 -	return 0;
 -}
 -
 -static void mlx5_devlink_rdma_param_unregister(struct devlink *devlink)
 -{
 -	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))
 -		return;
 -
 -	devlink_param_unregister(devlink, &enable_rdma_param);
 -}
 -
 -static const struct devlink_param enable_vnet_param =
 -	DEVLINK_PARAM_GENERIC(ENABLE_VNET, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
 -			      NULL, NULL, NULL);
 -
 -static int mlx5_devlink_vnet_param_register(struct devlink *devlink)
 -{
 -	struct mlx5_core_dev *dev = devlink_priv(devlink);
 -	union devlink_param_value value;
 -	int err;
 -
 -	if (!mlx5_vnet_supported(dev))
 -		return 0;
 -
 -	err = devlink_param_register(devlink, &enable_vnet_param);
 -	if (err)
 -		return err;
 -
 -	value.vbool = true;
 -	devlink_param_driverinit_value_set(devlink,
 -					   DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET,
 -					   value);
 -	return 0;
 -}
 -
 -static void mlx5_devlink_vnet_param_unregister(struct devlink *devlink)
 -{
 -	struct mlx5_core_dev *dev = devlink_priv(devlink);
 -
 -	if (!mlx5_vnet_supported(dev))
 -		return;
 -
 -	devlink_param_unregister(devlink, &enable_vnet_param);
 -}
 -
 -static int mlx5_devlink_auxdev_params_register(struct devlink *devlink)
 -{
 -	int err;
 -
 -	err = mlx5_devlink_eth_param_register(devlink);
 -	if (err)
 -		return err;
 -
 -	err = mlx5_devlink_rdma_param_register(devlink);
 -	if (err)
 -		goto rdma_err;
 -
 -	err = mlx5_devlink_vnet_param_register(devlink);
 -	if (err)
 -		goto vnet_err;
 -	return 0;
 -
 -vnet_err:
 -	mlx5_devlink_rdma_param_unregister(devlink);
 -rdma_err:
 -	mlx5_devlink_eth_param_unregister(devlink);
 -	return err;
 -}
 -
 -static void mlx5_devlink_auxdev_params_unregister(struct devlink *devlink)
 -{
 -	mlx5_devlink_vnet_param_unregister(devlink);
 -	mlx5_devlink_rdma_param_unregister(devlink);
 -	mlx5_devlink_eth_param_unregister(devlink);
  }
  
+ static int mlx5_devlink_max_uc_list_validate(struct devlink *devlink, u32 id,
+ 					     union devlink_param_value val,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 
+ 	if (val.vu32 == 0) {
+ 		NL_SET_ERR_MSG_MOD(extack, "max_macs value must be greater than 0");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!is_power_of_2(val.vu32)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Only power of 2 values are supported for max_macs");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ilog2(val.vu32) >
+ 	    MLX5_CAP_GEN_MAX(dev, log_max_current_uc_list)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "max_macs value is out of the supported range");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct devlink_param max_uc_list_param =
+ 	DEVLINK_PARAM_GENERIC(MAX_MACS, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, mlx5_devlink_max_uc_list_validate);
+ 
+ static int mlx5_devlink_max_uc_list_param_register(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	union devlink_param_value value;
+ 	int err;
+ 
+ 	if (!MLX5_CAP_GEN_MAX(dev, log_max_current_uc_list_wr_supported))
+ 		return 0;
+ 
+ 	err = devlink_param_register(devlink, &max_uc_list_param);
+ 	if (err)
+ 		return err;
+ 
+ 	value.vu32 = 1 << MLX5_CAP_GEN(dev, log_max_current_uc_list);
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_MAX_MACS,
+ 					   value);
+ 	return 0;
+ }
+ 
+ static void
+ mlx5_devlink_max_uc_list_param_unregister(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 
+ 	if (!MLX5_CAP_GEN_MAX(dev, log_max_current_uc_list_wr_supported))
+ 		return;
+ 
+ 	devlink_param_unregister(devlink, &max_uc_list_param);
+ }
+ 
  #define MLX5_TRAP_DROP(_id, _group_id)					\
  	DEVLINK_TRAP_GENERIC(DROP, DROP, _id,				\
  			     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id, \
@@@ -665,6 -888,14 +725,17 @@@ int mlx5_devlink_register(struct devlin
  
  	mlx5_devlink_set_params_init_values(devlink);
  
++<<<<<<< HEAD
++=======
+ 	err = mlx5_devlink_auxdev_params_register(devlink);
+ 	if (err)
+ 		goto auxdev_reg_err;
+ 
+ 	err = mlx5_devlink_max_uc_list_param_register(devlink);
+ 	if (err)
+ 		goto max_uc_list_err;
+ 
++>>>>>>> 8680a60fc1fc (net/mlx5: Let user configure max_macs generic param)
  	err = mlx5_devlink_traps_register(devlink);
  	if (err)
  		goto traps_reg_err;
@@@ -675,6 -906,10 +746,13 @@@
  	return 0;
  
  traps_reg_err:
++<<<<<<< HEAD
++=======
+ 	mlx5_devlink_max_uc_list_param_unregister(devlink);
+ max_uc_list_err:
+ 	mlx5_devlink_auxdev_params_unregister(devlink);
+ auxdev_reg_err:
++>>>>>>> 8680a60fc1fc (net/mlx5: Let user configure max_macs generic param)
  	devlink_params_unregister(devlink, mlx5_devlink_params,
  				  ARRAY_SIZE(mlx5_devlink_params));
  	return err;
@@@ -683,6 -918,8 +761,11 @@@
  void mlx5_devlink_unregister(struct devlink *devlink)
  {
  	mlx5_devlink_traps_unregister(devlink);
++<<<<<<< HEAD
++=======
+ 	mlx5_devlink_max_uc_list_param_unregister(devlink);
+ 	mlx5_devlink_auxdev_params_unregister(devlink);
++>>>>>>> 8680a60fc1fc (net/mlx5: Let user configure max_macs generic param)
  	devlink_params_unregister(devlink, mlx5_devlink_params,
  				  ARRAY_SIZE(mlx5_devlink_params));
  }
* Unmerged path Documentation/networking/devlink/mlx5.rst
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index f1e595d886bf..af1e2b74d667 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -486,10 +486,26 @@ static int handle_hca_cap_odp(struct mlx5_core_dev *dev, void *set_ctx)
 	return set_caps(dev, set_ctx, MLX5_SET_HCA_CAP_OP_MOD_ODP);
 }
 
+static int max_uc_list_get_devlink_param(struct mlx5_core_dev *dev)
+{
+	struct devlink *devlink = priv_to_devlink(dev);
+	union devlink_param_value val;
+	int err;
+
+	err = devlink_param_driverinit_value_get(devlink,
+						 DEVLINK_PARAM_GENERIC_ID_MAX_MACS,
+						 &val);
+	if (!err)
+		return val.vu32;
+	mlx5_core_dbg(dev, "Failed to get param. err = %d\n", err);
+	return err;
+}
+
 static int handle_hca_cap(struct mlx5_core_dev *dev, void *set_ctx)
 {
 	struct mlx5_profile *prof = &dev->profile;
 	void *set_hca_cap;
+	int max_uc_list;
 	int err;
 
 	err = mlx5_core_get_caps(dev, MLX5_CAP_GENERAL);
@@ -563,6 +579,11 @@ static int handle_hca_cap(struct mlx5_core_dev *dev, void *set_ctx)
 	if (MLX5_CAP_GEN(dev, roce_rw_supported))
 		MLX5_SET(cmd_hca_cap, set_hca_cap, roce, mlx5_is_roce_init_enabled(dev));
 
+	max_uc_list = max_uc_list_get_devlink_param(dev);
+	if (max_uc_list > 0)
+		MLX5_SET(cmd_hca_cap, set_hca_cap, log_max_current_uc_list,
+			 ilog2(max_uc_list));
+
 	return set_caps(dev, set_ctx, MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE);
 }
 
