ACPI: utils: Add api to read _SUB from ACPI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit 93064e15c8a3a8394319a11b8037666e4b7d653d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/93064e15.failed

Add a wrapper function to read the _SUB string from ACPI.

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Link: https://lore.kernel.org/r/20220707151037.3901050-2-sbinding@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 93064e15c8a3a8394319a11b8037666e4b7d653d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/acpi.h
diff --cc include/linux/acpi.h
index 19fe38e45f30,968a187f14f0..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -997,6 -1024,31 +998,34 @@@ static inline int acpi_get_local_addres
  	return -ENODEV;
  }
  
++<<<<<<< HEAD
++=======
+ static inline const char *acpi_get_subsystem_id(acpi_handle handle)
+ {
+ 	return ERR_PTR(-ENODEV);
+ }
+ 
+ static inline int acpi_register_wakeup_handler(int wake_irq,
+ 	bool (*wakeup)(void *context), void *context)
+ {
+ 	return -ENXIO;
+ }
+ 
+ static inline void acpi_unregister_wakeup_handler(
+ 	bool (*wakeup)(void *context), void *context) { }
+ 
+ struct acpi_osc_context;
+ static inline u32 acpi_osc_ctx_get_pci_control(struct acpi_osc_context *context)
+ {
+ 	return 0;
+ }
+ 
+ static inline u32 acpi_osc_ctx_get_cxl_control(struct acpi_osc_context *context)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> 93064e15c8a3 (ACPI: utils: Add api to read _SUB from ACPI)
  #endif	/* !CONFIG_ACPI */
  
  #ifdef CONFIG_ACPI_HOTPLUG_IOAPIC
diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index acd144f8dcb6..73c27d14456c 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -323,6 +323,44 @@ int acpi_get_local_address(acpi_handle handle, u32 *addr)
 }
 EXPORT_SYMBOL(acpi_get_local_address);
 
+#define ACPI_MAX_SUB_BUF_SIZE	9
+
+const char *acpi_get_subsystem_id(acpi_handle handle)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	const char *sub;
+	size_t len;
+
+	status = acpi_evaluate_object(handle, METHOD_NAME__SUB, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_handle_debug(handle, "Reading ACPI _SUB failed: %#x\n", status);
+		return ERR_PTR(-ENODATA);
+	}
+
+	obj = buffer.pointer;
+	if (obj->type == ACPI_TYPE_STRING) {
+		len = strlen(obj->string.pointer);
+		if (len < ACPI_MAX_SUB_BUF_SIZE && len > 0) {
+			sub = kstrdup(obj->string.pointer, GFP_KERNEL);
+			if (!sub)
+				sub = ERR_PTR(-ENOMEM);
+		} else {
+			acpi_handle_err(handle, "ACPI _SUB Length %zu is Invalid\n", len);
+			sub = ERR_PTR(-ENODATA);
+		}
+	} else {
+		acpi_handle_warn(handle, "Warning ACPI _SUB did not return a string\n");
+		sub = ERR_PTR(-ENODATA);
+	}
+
+	acpi_os_free(buffer.pointer);
+
+	return sub;
+}
+EXPORT_SYMBOL_GPL(acpi_get_subsystem_id);
+
 acpi_status
 acpi_evaluate_reference(acpi_handle handle,
 			acpi_string pathname,
* Unmerged path include/linux/acpi.h
