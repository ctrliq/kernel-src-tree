xfs: Remove xfs_attr_rmtval_set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Allison Henderson <allison.henderson@oracle.com>
commit 0e6acf29db6f463027d1ff7cea86a641da89f0d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0e6acf29.failed

This function is no longer used, so it is safe to remove

	Signed-off-by: Allison Henderson <allison.henderson@oracle.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
(cherry picked from commit 0e6acf29db6f463027d1ff7cea86a641da89f0d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr_remote.c
#	fs/xfs/libxfs/xfs_attr_remote.h
diff --cc fs/xfs/libxfs/xfs_attr_remote.c
index 48d8e9caf86f,0c8bee3abc3b..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@@ -562,69 -562,66 +562,130 @@@ xfs_attr_rmtval_stale
  }
  
  /*
++<<<<<<< HEAD
 + * Write the value associated with an attribute into the out-of-line buffer
 + * that we have defined for it.
 + */
 +int
 +xfs_attr_rmtval_set(
 +	struct xfs_da_args	*args)
 +{
 +	struct xfs_inode	*dp = args->dp;
 +	struct xfs_bmbt_irec	map;
 +	xfs_dablk_t		lblkno;
 +	int			blkcnt;
 +	int			nmap;
 +	int			error;
 +
 +	trace_xfs_attr_rmtval_set(args);
++=======
+  * Find a hole for the attr and store it in the delayed attr context.  This
+  * initializes the context to roll through allocating an attr extent for a
+  * delayed attr operation
+  */
+ int
+ xfs_attr_rmtval_find_space(
+ 	struct xfs_delattr_context	*dac)
+ {
+ 	struct xfs_da_args		*args = dac->da_args;
+ 	struct xfs_bmbt_irec		*map = &dac->map;
+ 	int				error;
+ 
+ 	dac->lblkno = 0;
+ 	dac->blkcnt = 0;
+ 	args->rmtblkcnt = 0;
+ 	args->rmtblkno = 0;
+ 	memset(map, 0, sizeof(struct xfs_bmbt_irec));
++>>>>>>> 0e6acf29db6f (xfs: Remove xfs_attr_rmtval_set)
  
  	error = xfs_attr_rmt_find_hole(args);
  	if (error)
  		return error;
  
++<<<<<<< HEAD
 +	blkcnt = args->rmtblkcnt;
 +	lblkno = (xfs_dablk_t)args->rmtblkno;
 +	/*
 +	 * Roll through the "value", allocating blocks on disk as required.
 +	 */
 +	while (blkcnt > 0) {
 +		/*
 +		 * Allocate a single extent, up to the size of the value.
 +		 *
 +		 * Note that we have to consider this a data allocation as we
 +		 * write the remote attribute without logging the contents.
 +		 * Hence we must ensure that we aren't using blocks that are on
 +		 * the busy list so that we don't overwrite blocks which have
 +		 * recently been freed but their transactions are not yet
 +		 * committed to disk. If we overwrite the contents of a busy
 +		 * extent and then crash then the block may not contain the
 +		 * correct metadata after log recovery occurs.
 +		 */
 +		nmap = 1;
 +		error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,
 +				  blkcnt, XFS_BMAPI_ATTRFORK, args->total, &map,
 +				  &nmap);
 +		if (error)
 +			return error;
 +		error = xfs_defer_finish(&args->trans);
 +		if (error)
 +			return error;
 +
 +		ASSERT(nmap == 1);
 +		ASSERT((map.br_startblock != DELAYSTARTBLOCK) &&
 +		       (map.br_startblock != HOLESTARTBLOCK));
 +		lblkno += map.br_blockcount;
 +		blkcnt -= map.br_blockcount;
 +
 +		/*
 +		 * Start the next trans in the chain.
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, dp);
 +		if (error)
 +			return error;
 +	}
 +
 +	return xfs_attr_rmtval_set_value(args);
++=======
+ 	dac->blkcnt = args->rmtblkcnt;
+ 	dac->lblkno = args->rmtblkno;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Write one block of the value associated with an attribute into the
+  * out-of-line buffer that we have defined for it. This is similar to a subset
+  * of xfs_attr_rmtval_set, but records the current block to the delayed attr
+  * context, and leaves transaction handling to the caller.
+  */
+ int
+ xfs_attr_rmtval_set_blk(
+ 	struct xfs_delattr_context	*dac)
+ {
+ 	struct xfs_da_args		*args = dac->da_args;
+ 	struct xfs_inode		*dp = args->dp;
+ 	struct xfs_bmbt_irec		*map = &dac->map;
+ 	int nmap;
+ 	int error;
+ 
+ 	nmap = 1;
+ 	error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)dac->lblkno,
+ 			dac->blkcnt, XFS_BMAPI_ATTRFORK, args->total,
+ 			map, &nmap);
+ 	if (error)
+ 		return error;
+ 
+ 	ASSERT(nmap == 1);
+ 	ASSERT((map->br_startblock != DELAYSTARTBLOCK) &&
+ 	       (map->br_startblock != HOLESTARTBLOCK));
+ 
+ 	/* roll attribute extent map forwards */
+ 	dac->lblkno += map->br_blockcount;
+ 	dac->blkcnt -= map->br_blockcount;
+ 
+ 	return 0;
++>>>>>>> 0e6acf29db6f (xfs: Remove xfs_attr_rmtval_set)
  }
  
  /*
diff --cc fs/xfs/libxfs/xfs_attr_remote.h
index 9eee615da156,61b85b918db8..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.h
+++ b/fs/xfs/libxfs/xfs_attr_remote.h
@@@ -9,8 -9,6 +9,11 @@@
  int xfs_attr3_rmt_blocks(struct xfs_mount *mp, int attrlen);
  
  int xfs_attr_rmtval_get(struct xfs_da_args *args);
++<<<<<<< HEAD
 +int xfs_attr_rmtval_set(struct xfs_da_args *args);
 +int xfs_attr_rmtval_remove(struct xfs_da_args *args);
++=======
++>>>>>>> 0e6acf29db6f (xfs: Remove xfs_attr_rmtval_set)
  int xfs_attr_rmtval_stale(struct xfs_inode *ip, struct xfs_bmbt_irec *map,
  		xfs_buf_flags_t incore_flags);
  int xfs_attr_rmtval_invalidate(struct xfs_da_args *args);
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.c
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.h
