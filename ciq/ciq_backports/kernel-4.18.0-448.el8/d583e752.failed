drm/bridge: anx7625: check the return on anx7625_aux_trans

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tom Rix <trix@redhat.com>
commit d583e752732421b26fef0d65020565f3bef12248
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d583e752.failed

Clang static analysis reports this issue
anx7625.c:876:13: warning: The left operand of '&' is
  a garbage value
  if (!(bcap & 0xOA01)) {
        ~~~~ ^

bcap is only set by a successful call to
anx7625_aux_trans().  So check.

Fixes: cd1637c7e480 ("drm/bridge: anx7625: add HDCP support")
	Signed-off-by: Tom Rix <trix@redhat.com>
Fixes: adca62ec370c ("drm/bridge: anx7625: Support reading edid through aux channel")
	Signed-off-by: Robert Foss <robert.foss@linaro.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20220303201943.501746-1-trix@redhat.com
	Reviewed-by: Robert Foss <robert.foss@linaro.org>
(cherry picked from commit d583e752732421b26fef0d65020565f3bef12248)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/bridge/analogix/anx7625.c
diff --cc drivers/gpu/drm/bridge/analogix/anx7625.c
index 439c7bed33ff,69122bea4c1e..000000000000
--- a/drivers/gpu/drm/bridge/analogix/anx7625.c
+++ b/drivers/gpu/drm/bridge/analogix/anx7625.c
@@@ -597,6 -688,238 +597,241 @@@ static int anx7625_dsi_config(struct an
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int anx7625_api_dpi_config(struct anx7625_data *ctx)
+ {
+ 	struct device *dev = &ctx->client->dev;
+ 	u16 freq = ctx->dt.pixelclock.min / 1000;
+ 	int ret;
+ 
+ 	/* configure pixel clock */
+ 	ret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				PIXEL_CLOCK_L, freq & 0xFF);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 PIXEL_CLOCK_H, (freq >> 8));
+ 
+ 	/* set DPI mode */
+ 	/* set to DPI PLL module sel */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,
+ 				 MIPI_DIGITAL_PLL_9, 0x20);
+ 	/* power down MIPI */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,
+ 				 MIPI_LANE_CTRL_10, 0x08);
+ 	/* enable DPI mode */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,
+ 				 MIPI_DIGITAL_PLL_18, 0x1C);
+ 	/* set first edge */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,
+ 				 VIDEO_CONTROL_0, 0x06);
+ 	if (ret < 0)
+ 		DRM_DEV_ERROR(dev, "IO error : dpi phy set failed.\n");
+ 
+ 	return ret;
+ }
+ 
+ static int anx7625_dpi_config(struct anx7625_data *ctx)
+ {
+ 	struct device *dev = &ctx->client->dev;
+ 	int ret;
+ 
+ 	DRM_DEV_DEBUG_DRIVER(dev, "config dpi\n");
+ 
+ 	/* DSC disable */
+ 	ret = anx7625_write_and(ctx, ctx->i2c.rx_p0_client,
+ 				R_DSC_CTRL_0, ~DSC_EN);
+ 	if (ret < 0) {
+ 		DRM_DEV_ERROR(dev, "IO error : disable dsc failed.\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = anx7625_config_bit_matrix(ctx);
+ 	if (ret < 0) {
+ 		DRM_DEV_ERROR(dev, "config bit matrix failed.\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = anx7625_api_dpi_config(ctx);
+ 	if (ret < 0) {
+ 		DRM_DEV_ERROR(dev, "mipi phy(dpi) setup failed.\n");
+ 		return ret;
+ 	}
+ 
+ 	/* set MIPI RX EN */
+ 	ret = anx7625_write_or(ctx, ctx->i2c.rx_p0_client,
+ 			       AP_AV_STATUS, AP_MIPI_RX_EN);
+ 	/* clear mute flag */
+ 	ret |= anx7625_write_and(ctx, ctx->i2c.rx_p0_client,
+ 				 AP_AV_STATUS, (u8)~AP_MIPI_MUTE);
+ 	if (ret < 0)
+ 		DRM_DEV_ERROR(dev, "IO error : enable mipi rx failed.\n");
+ 
+ 	return ret;
+ }
+ 
+ static int anx7625_read_flash_status(struct anx7625_data *ctx)
+ {
+ 	return anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, R_RAM_CTRL);
+ }
+ 
+ static int anx7625_hdcp_key_probe(struct anx7625_data *ctx)
+ {
+ 	int ret, val;
+ 	struct device *dev = &ctx->client->dev;
+ 	u8 ident[FLASH_BUF_LEN];
+ 
+ 	ret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				FLASH_ADDR_HIGH, 0x91);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 FLASH_ADDR_LOW, 0xA0);
+ 	if (ret < 0) {
+ 		dev_err(dev, "IO error : set key flash address.\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				FLASH_LEN_HIGH, (FLASH_BUF_LEN - 1) >> 8);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 FLASH_LEN_LOW, (FLASH_BUF_LEN - 1) & 0xFF);
+ 	if (ret < 0) {
+ 		dev_err(dev, "IO error : set key flash len.\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				R_FLASH_RW_CTRL, FLASH_READ);
+ 	ret |= readx_poll_timeout(anx7625_read_flash_status,
+ 				  ctx, val,
+ 				  ((val & FLASH_DONE) || (val < 0)),
+ 				  2000,
+ 				  2000 * 150);
+ 	if (ret) {
+ 		dev_err(dev, "flash read access fail!\n");
+ 		return -EIO;
+ 	}
+ 
+ 	ret = anx7625_reg_block_read(ctx, ctx->i2c.rx_p0_client,
+ 				     FLASH_BUF_BASE_ADDR,
+ 				     FLASH_BUF_LEN, ident);
+ 	if (ret < 0) {
+ 		dev_err(dev, "read flash data fail!\n");
+ 		return -EIO;
+ 	}
+ 
+ 	if (ident[29] == 0xFF && ident[30] == 0xFF && ident[31] == 0xFF)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int anx7625_hdcp_key_load(struct anx7625_data *ctx)
+ {
+ 	int ret;
+ 	struct device *dev = &ctx->client->dev;
+ 
+ 	/* Select HDCP 1.4 KEY */
+ 	ret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				R_BOOT_RETRY, 0x12);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 FLASH_ADDR_HIGH, HDCP14KEY_START_ADDR >> 8);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 FLASH_ADDR_LOW, HDCP14KEY_START_ADDR & 0xFF);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 R_RAM_LEN_H, HDCP14KEY_SIZE >> 12);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 R_RAM_LEN_L, HDCP14KEY_SIZE >> 4);
+ 
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 R_RAM_ADDR_H, 0);
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 R_RAM_ADDR_L, 0);
+ 	/* Enable HDCP 1.4 KEY load */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
+ 				 R_RAM_CTRL, DECRYPT_EN | LOAD_START);
+ 	dev_dbg(dev, "load HDCP 1.4 key done\n");
+ 	return ret;
+ }
+ 
+ static int anx7625_hdcp_disable(struct anx7625_data *ctx)
+ {
+ 	int ret;
+ 	struct device *dev = &ctx->client->dev;
+ 
+ 	dev_dbg(dev, "disable HDCP 1.4\n");
+ 
+ 	/* Disable HDCP */
+ 	ret = anx7625_write_and(ctx, ctx->i2c.rx_p1_client, 0xee, 0x9f);
+ 	/* Try auth flag */
+ 	ret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xec, 0x10);
+ 	/* Interrupt for DRM */
+ 	ret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xff, 0x01);
+ 	if (ret < 0)
+ 		dev_err(dev, "fail to disable HDCP\n");
+ 
+ 	return anx7625_write_and(ctx, ctx->i2c.tx_p0_client,
+ 				 TX_HDCP_CTRL0, ~HARD_AUTH_EN & 0xFF);
+ }
+ 
+ static int anx7625_hdcp_enable(struct anx7625_data *ctx)
+ {
+ 	u8 bcap;
+ 	int ret;
+ 	struct device *dev = &ctx->client->dev;
+ 
+ 	ret = anx7625_hdcp_key_probe(ctx);
+ 	if (ret) {
+ 		dev_dbg(dev, "no key found, not to do hdcp\n");
+ 		return ret;
+ 	}
+ 
+ 	/* Read downstream capability */
+ 	ret = anx7625_aux_trans(ctx, DP_AUX_NATIVE_READ, 0x68028, 1, &bcap);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (!(bcap & 0x01)) {
+ 		pr_warn("downstream not support HDCP 1.4, cap(%x).\n", bcap);
+ 		return 0;
+ 	}
+ 
+ 	dev_dbg(dev, "enable HDCP 1.4\n");
+ 
+ 	/* First clear HDCP state */
+ 	ret = anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,
+ 				TX_HDCP_CTRL0,
+ 				KSVLIST_VLD | BKSV_SRM_PASS | RE_AUTHEN);
+ 	usleep_range(1000, 1100);
+ 	/* Second clear HDCP state */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,
+ 				 TX_HDCP_CTRL0,
+ 				 KSVLIST_VLD | BKSV_SRM_PASS | RE_AUTHEN);
+ 
+ 	/* Set time for waiting KSVR */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,
+ 				 SP_TX_WAIT_KSVR_TIME, 0xc8);
+ 	/* Set time for waiting R0 */
+ 	ret |= anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,
+ 				 SP_TX_WAIT_R0_TIME, 0xb0);
+ 	ret |= anx7625_hdcp_key_load(ctx);
+ 	if (ret) {
+ 		pr_warn("prepare HDCP key failed.\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xee, 0x20);
+ 
+ 	/* Try auth flag */
+ 	ret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xec, 0x10);
+ 	/* Interrupt for DRM */
+ 	ret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xff, 0x01);
+ 	if (ret < 0)
+ 		dev_err(dev, "fail to enable HDCP\n");
+ 
+ 	return anx7625_write_or(ctx, ctx->i2c.tx_p0_client,
+ 				TX_HDCP_CTRL0, HARD_AUTH_EN);
+ }
+ 
++>>>>>>> d583e7527324 (drm/bridge: anx7625: check the return on anx7625_aux_trans)
  static void anx7625_dp_start(struct anx7625_data *ctx)
  {
  	int ret;
* Unmerged path drivers/gpu/drm/bridge/analogix/anx7625.c
