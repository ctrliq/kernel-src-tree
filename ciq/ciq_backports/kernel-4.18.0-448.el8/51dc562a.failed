s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 51dc562af09dfb1a0d3cc806f64f0d72704647b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/51dc562a.failed

Let's hot plug an adapter, domain or control domain into the guest when it
is assigned to a matrix mdev that is attached to a KVM guest. Likewise,
let's hot unplug an adapter, domain or control domain from the guest when
it is unassigned from a matrix_mdev that is attached to a KVM guest.

Whenever an assignment or unassignment of an adapter, domain or control
domain is performed, the APQNs and control domains assigned to the matrix
mdev will be filtered and assigned to the AP control block
(APCB) that supplies the AP configuration to the guest so that no
adapter, domain or control domain that is not in the host's AP
configuration nor any APQN that does not reference a queue device bound
to the vfio_ap device driver is assigned.

After updating the APCB, if the mdev is in use by a KVM guest, it is
hot plugged into the guest to dynamically provide access to the adapters,
domains and control domains provided via the newly refreshed APCB.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit 51dc562af09dfb1a0d3cc806f64f0d72704647b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,561e68f69955..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -322,9 -605,99 +322,102 @@@ static void vfio_ap_matrix_init(struct 
  	matrix->adm_max = info->apxa ? info->Nd : 15;
  }
  
++<<<<<<< HEAD
 +static int vfio_ap_mdev_create(struct kobject *kobj, struct mdev_device *mdev)
++=======
+ static void vfio_ap_mdev_update_guest_apcb(struct ap_matrix_mdev *matrix_mdev)
+ {
+ 	if (matrix_mdev->kvm)
+ 		kvm_arch_crypto_set_masks(matrix_mdev->kvm,
+ 					  matrix_mdev->shadow_apcb.apm,
+ 					  matrix_mdev->shadow_apcb.aqm,
+ 					  matrix_mdev->shadow_apcb.adm);
+ }
+ 
+ static bool vfio_ap_mdev_filter_cdoms(struct ap_matrix_mdev *matrix_mdev)
+ {
+ 	DECLARE_BITMAP(prev_shadow_adm, AP_DOMAINS);
+ 
+ 	bitmap_copy(prev_shadow_adm, matrix_mdev->shadow_apcb.adm, AP_DOMAINS);
+ 	bitmap_and(matrix_mdev->shadow_apcb.adm, matrix_mdev->matrix.adm,
+ 		   (unsigned long *)matrix_dev->info.adm, AP_DOMAINS);
+ 
+ 	return !bitmap_equal(prev_shadow_adm, matrix_mdev->shadow_apcb.adm,
+ 			     AP_DOMAINS);
+ }
+ 
+ /*
+  * vfio_ap_mdev_filter_matrix - filter the APQNs assigned to the matrix mdev
+  *				to ensure no queue devices are passed through to
+  *				the guest that are not bound to the vfio_ap
+  *				device driver.
+  *
+  * @matrix_mdev: the matrix mdev whose matrix is to be filtered.
+  *
+  * Note: If an APQN referencing a queue device that is not bound to the vfio_ap
+  *	 driver, its APID will be filtered from the guest's APCB. The matrix
+  *	 structure precludes filtering an individual APQN, so its APID will be
+  *	 filtered.
+  *
+  * Return: a boolean value indicating whether the KVM guest's APCB was changed
+  *	   by the filtering or not.
+  */
+ static bool vfio_ap_mdev_filter_matrix(unsigned long *apm, unsigned long *aqm,
+ 				       struct ap_matrix_mdev *matrix_mdev)
+ {
+ 	int ret;
+ 	unsigned long apid, apqi, apqn;
+ 	DECLARE_BITMAP(prev_shadow_apm, AP_DEVICES);
+ 	DECLARE_BITMAP(prev_shadow_aqm, AP_DOMAINS);
+ 
+ 	ret = ap_qci(&matrix_dev->info);
+ 	if (ret)
+ 		return false;
+ 
+ 	bitmap_copy(prev_shadow_apm, matrix_mdev->shadow_apcb.apm, AP_DEVICES);
+ 	bitmap_copy(prev_shadow_aqm, matrix_mdev->shadow_apcb.aqm, AP_DOMAINS);
+ 	vfio_ap_matrix_init(&matrix_dev->info, &matrix_mdev->shadow_apcb);
+ 
+ 	/*
+ 	 * Copy the adapters, domains and control domains to the shadow_apcb
+ 	 * from the matrix mdev, but only those that are assigned to the host's
+ 	 * AP configuration.
+ 	 */
+ 	bitmap_and(matrix_mdev->shadow_apcb.apm, matrix_mdev->matrix.apm,
+ 		   (unsigned long *)matrix_dev->info.apm, AP_DEVICES);
+ 	bitmap_and(matrix_mdev->shadow_apcb.aqm, matrix_mdev->matrix.aqm,
+ 		   (unsigned long *)matrix_dev->info.aqm, AP_DOMAINS);
+ 
+ 	for_each_set_bit_inv(apid, apm, AP_DEVICES) {
+ 		for_each_set_bit_inv(apqi, aqm, AP_DOMAINS) {
+ 			/*
+ 			 * If the APQN is not bound to the vfio_ap device
+ 			 * driver, then we can't assign it to the guest's
+ 			 * AP configuration. The AP architecture won't
+ 			 * allow filtering of a single APQN, so let's filter
+ 			 * the APID since an adapter represents a physical
+ 			 * hardware device.
+ 			 */
+ 			apqn = AP_MKQID(apid, apqi);
+ 
+ 			if (!vfio_ap_mdev_get_queue(matrix_mdev, apqn)) {
+ 				clear_bit_inv(apid,
+ 					      matrix_mdev->shadow_apcb.apm);
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	return !bitmap_equal(prev_shadow_apm, matrix_mdev->shadow_apcb.apm,
+ 			     AP_DEVICES) ||
+ 	       !bitmap_equal(prev_shadow_aqm, matrix_mdev->shadow_apcb.aqm,
+ 			     AP_DOMAINS);
+ }
+ 
+ static int vfio_ap_mdev_probe(struct mdev_device *mdev)
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  {
  	struct ap_matrix_mdev *matrix_mdev;
 -	int ret;
  
  	if ((atomic_dec_if_positive(&matrix_dev->available_instances) < 0))
  		return -EPERM;
@@@ -596,16 -966,10 +689,17 @@@ static ssize_t assign_adapter_store(str
  {
  	int ret;
  	unsigned long apid;
++<<<<<<< HEAD
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
 +
 +	mutex_lock(&matrix_dev->lock);
++=======
+ 	DECLARE_BITMAP(apm_delta, AP_DEVICES);
+ 	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
  
- 	/* If the KVM guest is running, disallow assignment of adapter */
- 	if (matrix_mdev->kvm) {
- 		ret = -EBUSY;
- 		goto done;
- 	}
+ 	get_update_locks_for_mdev(matrix_mdev);
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  
  	ret = kstrtoul(buf, 0, &apid);
  	if (ret)
@@@ -616,28 -980,25 +710,39 @@@
  		goto done;
  	}
  
 +	/*
 +	 * Set the bit in the AP mask (APM) corresponding to the AP adapter
 +	 * number (APID). The bits in the mask, from most significant to least
 +	 * significant bit, correspond to APIDs 0-255.
 +	 */
 +	ret = vfio_ap_mdev_verify_queues_reserved_for_apid(matrix_mdev, apid);
 +	if (ret)
 +		goto done;
 +
  	set_bit_inv(apid, matrix_mdev->matrix.apm);
  
 -	ret = vfio_ap_mdev_validate_masks(matrix_mdev);
 -	if (ret) {
 -		clear_bit_inv(apid, matrix_mdev->matrix.apm);
 -		goto done;
 -	}
 +	ret = vfio_ap_mdev_verify_no_sharing(matrix_mdev);
 +	if (ret)
 +		goto share_err;
  
++<<<<<<< HEAD
++=======
+ 	vfio_ap_mdev_link_adapter(matrix_mdev, apid);
+ 	memset(apm_delta, 0, sizeof(apm_delta));
+ 	set_bit_inv(apid, apm_delta);
+ 
+ 	if (vfio_ap_mdev_filter_matrix(apm_delta,
+ 				       matrix_mdev->matrix.aqm, matrix_mdev))
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  	ret = count;
 +	goto done;
 +
 +share_err:
 +	clear_bit_inv(apid, matrix_mdev->matrix.apm);
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  
  	return ret;
  }
@@@ -664,17 -1039,10 +769,11 @@@ static ssize_t unassign_adapter_store(s
  {
  	int ret;
  	unsigned long apid;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
 -	get_update_locks_for_mdev(matrix_mdev);
 +	mutex_lock(&matrix_dev->lock);
  
- 	/* If the KVM guest is running, disallow unassignment of adapter */
- 	if (matrix_mdev->kvm) {
- 		ret = -EBUSY;
- 		goto done;
- 	}
- 
  	ret = kstrtoul(buf, 0, &apid);
  	if (ret)
  		goto done;
@@@ -685,9 -1053,16 +784,19 @@@
  	}
  
  	clear_bit_inv((unsigned long)apid, matrix_mdev->matrix.apm);
++<<<<<<< HEAD
++=======
+ 	vfio_ap_mdev_unlink_adapter(matrix_mdev, apid);
+ 
+ 	if (test_bit_inv(apid, matrix_mdev->shadow_apcb.apm)) {
+ 		clear_bit_inv(apid, matrix_mdev->shadow_apcb.apm);
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 	}
+ 
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  	ret = count;
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(unassign_adapter);
@@@ -748,18 -1113,11 +857,17 @@@ static ssize_t assign_domain_store(stru
  {
  	int ret;
  	unsigned long apqi;
++<<<<<<< HEAD
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
 +	unsigned long max_apqi = matrix_mdev->matrix.aqm_max;
++=======
+ 	DECLARE_BITMAP(aqm_delta, AP_DOMAINS);
+ 	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  
 -	get_update_locks_for_mdev(matrix_mdev);
 +	mutex_lock(&matrix_dev->lock);
  
- 	/* If the KVM guest is running, disallow assignment of domain */
- 	if (matrix_mdev->kvm) {
- 		ret = -EBUSY;
- 		goto done;
- 	}
- 
  	ret = kstrtoul(buf, 0, &apqi);
  	if (ret)
  		goto done;
@@@ -768,23 -1127,25 +877,34 @@@
  		goto done;
  	}
  
 +	ret = vfio_ap_mdev_verify_queues_reserved_for_apqi(matrix_mdev, apqi);
 +	if (ret)
 +		goto done;
 +
  	set_bit_inv(apqi, matrix_mdev->matrix.aqm);
  
 -	ret = vfio_ap_mdev_validate_masks(matrix_mdev);
 -	if (ret) {
 -		clear_bit_inv(apqi, matrix_mdev->matrix.aqm);
 -		goto done;
 -	}
 +	ret = vfio_ap_mdev_verify_no_sharing(matrix_mdev);
 +	if (ret)
 +		goto share_err;
  
++<<<<<<< HEAD
++=======
+ 	vfio_ap_mdev_link_domain(matrix_mdev, apqi);
+ 	memset(aqm_delta, 0, sizeof(aqm_delta));
+ 	set_bit_inv(apqi, aqm_delta);
+ 
+ 	if (vfio_ap_mdev_filter_matrix(matrix_mdev->matrix.apm, aqm_delta,
+ 				       matrix_mdev))
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  	ret = count;
 +	goto done;
 +
 +share_err:
 +	clear_bit_inv(apqi, matrix_mdev->matrix.aqm);
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  
  	return ret;
  }
@@@ -812,17 -1186,10 +932,11 @@@ static ssize_t unassign_domain_store(st
  {
  	int ret;
  	unsigned long apqi;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
 -	get_update_locks_for_mdev(matrix_mdev);
 +	mutex_lock(&matrix_dev->lock);
  
- 	/* If the KVM guest is running, disallow unassignment of domain */
- 	if (matrix_mdev->kvm) {
- 		ret = -EBUSY;
- 		goto done;
- 	}
- 
  	ret = kstrtoul(buf, 0, &apqi);
  	if (ret)
  		goto done;
@@@ -833,6 -1200,13 +947,16 @@@
  	}
  
  	clear_bit_inv((unsigned long)apqi, matrix_mdev->matrix.aqm);
++<<<<<<< HEAD
++=======
+ 	vfio_ap_mdev_unlink_domain(matrix_mdev, apqi);
+ 
+ 	if (test_bit_inv(apqi, matrix_mdev->shadow_apcb.aqm)) {
+ 		clear_bit_inv(apqi, matrix_mdev->shadow_apcb.aqm);
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 	}
+ 
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  	ret = count;
  
  done:
@@@ -861,17 -1235,10 +985,11 @@@ static ssize_t assign_control_domain_st
  {
  	int ret;
  	unsigned long id;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
 -	get_update_locks_for_mdev(matrix_mdev);
 +	mutex_lock(&matrix_dev->lock);
  
- 	/* If the KVM guest is running, disallow assignment of control domain */
- 	if (matrix_mdev->kvm) {
- 		ret = -EBUSY;
- 		goto done;
- 	}
- 
  	ret = kstrtoul(buf, 0, &id);
  	if (ret)
  		goto done;
@@@ -887,9 -1254,12 +1005,15 @@@
  	 * number of control domains that can be assigned.
  	 */
  	set_bit_inv(id, matrix_mdev->matrix.adm);
++<<<<<<< HEAD
++=======
+ 	if (vfio_ap_mdev_filter_cdoms(matrix_mdev))
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  	ret = count;
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(assign_control_domain);
@@@ -914,18 -1284,10 +1038,16 @@@ static ssize_t unassign_control_domain_
  {
  	int ret;
  	unsigned long domid;
++<<<<<<< HEAD
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
 +	unsigned long max_domid =  matrix_mdev->matrix.adm_max;
++=======
+ 	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  
 -	get_update_locks_for_mdev(matrix_mdev);
 +	mutex_lock(&matrix_dev->lock);
  
- 	/* If a KVM guest is running, disallow unassignment of control domain */
- 	if (matrix_mdev->kvm) {
- 		ret = -EBUSY;
- 		goto done;
- 	}
- 
  	ret = kstrtoul(buf, 0, &domid);
  	if (ret)
  		goto done;
@@@ -935,9 -1298,15 +1058,18 @@@
  	}
  
  	clear_bit_inv(domid, matrix_mdev->matrix.adm);
++<<<<<<< HEAD
++=======
+ 
+ 	if (test_bit_inv(domid, matrix_mdev->shadow_apcb.adm)) {
+ 		clear_bit_inv(domid, matrix_mdev->shadow_apcb.adm);
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 	}
+ 
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  	ret = count;
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(unassign_control_domain);
@@@ -1077,13 -1435,9 +1209,17 @@@ static int vfio_ap_mdev_set_kvm(struct 
  
  		kvm_get_kvm(kvm);
  		matrix_mdev->kvm = kvm;
++<<<<<<< HEAD
 +		kvm_arch_crypto_set_masks(kvm,
 +					  matrix_mdev->matrix.apm,
 +					  matrix_mdev->matrix.aqm,
 +					  matrix_mdev->matrix.adm);
++=======
+ 		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
++>>>>>>> 51dc562af09d (s390/vfio-ap: allow hot plug/unplug of AP devices when assigned/unassigned)
  
 -		release_update_locks_for_kvm(kvm);
 +		mutex_unlock(&kvm->lock);
 +		mutex_unlock(&matrix_dev->lock);
  	}
  
  	return 0;
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
