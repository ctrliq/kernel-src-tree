ACPI/IORT: Provide a generic helper to retrieve reserve regions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
commit 55be25b8b5e4e2fd680cfb073b84a74a79c002fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/55be25b8.failed

Currently IORT provides a helper to retrieve HW MSI reserve regions.
Change this to a generic helper to retrieve any IORT related reserve
regions. This will be useful when we add support for RMR nodes in
subsequent patches.

[Lorenzo: For ACPI IORT]

	Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Steven Price <steven.price@arm.com>
	Tested-by: Laurentiu Tudor <laurentiu.tudor@nxp.com>
	Tested-by: Hanjun Guo <guohanjun@huawei.com>
	Reviewed-by: Hanjun Guo <guohanjun@huawei.com>
	Signed-off-by: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
	Acked-by: Robin Murphy <robin.murphy@arm.com>
Link: https://lore.kernel.org/r/20220615101044.1972-4-shameerali.kolothum.thodi@huawei.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 55be25b8b5e4e2fd680cfb073b84a74a79c002fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/arm64/iort.c
#	include/linux/acpi_iort.h
diff --cc drivers/acpi/arm64/iort.c
index 387675a639bf,cd5d1d7823cb..000000000000
--- a/drivers/acpi/arm64/iort.c
+++ b/drivers/acpi/arm64/iort.c
@@@ -814,35 -806,13 +814,45 @@@ static struct acpi_iort_node *iort_get_
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static inline const struct iommu_ops *iort_fwspec_iommu_ops(struct device *dev)
 +{
 +	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
 +
 +	return (fwspec && fwspec->ops) ? fwspec->ops : NULL;
 +}
 +
 +static inline int iort_add_device_replay(struct device *dev)
 +{
 +	int err = 0;
 +
 +	if (dev->bus && !device_iommu_mapped(dev))
 +		err = iommu_probe_device(dev);
 +
 +	return err;
 +}
 +
 +/**
 + * iort_iommu_msi_get_resv_regions - Reserved region driver helper
 + * @dev: Device from iommu_get_resv_regions()
 + * @head: Reserved region list from iommu_get_resv_regions()
 + *
 + * Returns: Number of msi reserved regions on success (0 if platform
 + *          doesn't require the reservation or no associated msi regions),
 + *          appropriate error value otherwise. The ITS interrupt translation
 + *          spaces (ITS_base + SZ_64K, SZ_64K) associated with the device
 + *          are the msi reserved regions.
 + */
 +int iort_iommu_msi_get_resv_regions(struct device *dev, struct list_head *head)
++=======
+ /*
+  * Retrieve platform specific HW MSI reserve regions.
+  * The ITS interrupt translation spaces (ITS_base + SZ_64K, SZ_64K)
+  * associated with the device are the HW MSI reserved regions.
+  */
+ static void iort_iommu_msi_get_resv_regions(struct device *dev,
+ 					    struct list_head *head)
++>>>>>>> 55be25b8b5e4 (ACPI/IORT: Provide a generic helper to retrieve reserve regions)
  {
  	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
  	struct acpi_iort_its_group *its;
@@@ -885,16 -855,22 +895,26 @@@
  
  			region = iommu_alloc_resv_region(base + SZ_64K, SZ_64K,
  							 prot, IOMMU_RESV_MSI);
 -			if (region)
 +			if (region) {
  				list_add_tail(&region->list, head);
 +				resv++;
 +			}
  		}
  	}
 +
 +	return (resv == its->its_count) ? resv : -ENODEV;
  }
  
+ /**
+  * iort_iommu_get_resv_regions - Generic helper to retrieve reserved regions.
+  * @dev: Device from iommu_get_resv_regions()
+  * @head: Reserved region list from iommu_get_resv_regions()
+  */
+ void iort_iommu_get_resv_regions(struct device *dev, struct list_head *head)
+ {
+ 	iort_iommu_msi_get_resv_regions(dev, head);
+ }
+ 
  static inline bool iort_iommu_driver_enabled(u8 type)
  {
  	switch (type) {
@@@ -1097,11 -1035,10 +1117,18 @@@ const struct iommu_ops *iort_iommu_conf
  }
  
  #else
++<<<<<<< HEAD
 +int iort_iommu_msi_get_resv_regions(struct device *dev, struct list_head *head)
 +{ return 0; }
 +const struct iommu_ops *iort_iommu_configure_id(struct device *dev,
 +						const u32 *input_id)
 +{ return NULL; }
++=======
+ void iort_iommu_get_resv_regions(struct device *dev, struct list_head *head)
+ { }
+ int iort_iommu_configure_id(struct device *dev, const u32 *input_id)
+ { return -ENODEV; }
++>>>>>>> 55be25b8b5e4 (ACPI/IORT: Provide a generic helper to retrieve reserve regions)
  #endif
  
  static int nc_dma_get_range(struct device *dev, u64 *size)
diff --cc include/linux/acpi_iort.h
index 98e1a817c6f3,e5d2de9caf7f..000000000000
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@@ -46,10 -34,10 +46,17 @@@ struct irq_domain *iort_get_device_doma
  void acpi_configure_pmsi_domain(struct device *dev);
  int iort_pmsi_get_dev_id(struct device *dev, u32 *dev_id);
  /* IOMMU interface */
++<<<<<<< HEAD
 +void iort_dma_setup(struct device *dev, u64 *dma_addr, u64 *size);
 +const struct iommu_ops *iort_iommu_configure_id(struct device *dev,
 +						const u32 *id_in);
 +int iort_iommu_msi_get_resv_regions(struct device *dev, struct list_head *head);
++=======
+ int iort_dma_get_ranges(struct device *dev, u64 *size);
+ int iort_iommu_configure_id(struct device *dev, const u32 *id_in);
+ void iort_iommu_get_resv_regions(struct device *dev, struct list_head *head);
+ phys_addr_t acpi_iort_dma_get_max_cpu_address(void);
++>>>>>>> 55be25b8b5e4 (ACPI/IORT: Provide a generic helper to retrieve reserve regions)
  #else
  static inline void acpi_iort_init(void) { }
  static inline u32 iort_msi_map_id(struct device *dev, u32 id)
@@@ -59,14 -47,16 +66,22 @@@ static inline struct irq_domain *iort_g
  { return NULL; }
  static inline void acpi_configure_pmsi_domain(struct device *dev) { }
  /* IOMMU interface */
 -static inline int iort_dma_get_ranges(struct device *dev, u64 *size)
 -{ return -ENODEV; }
 -static inline int iort_iommu_configure_id(struct device *dev, const u32 *id_in)
 -{ return -ENODEV; }
 +static inline void iort_dma_setup(struct device *dev, u64 *dma_addr,
 +				  u64 *size) { }
 +static inline const struct iommu_ops *iort_iommu_configure_id(
 +				      struct device *dev, const u32 *id_in)
 +{ return NULL; }
  static inline
++<<<<<<< HEAD
 +int iort_iommu_msi_get_resv_regions(struct device *dev, struct list_head *head)
 +{ return 0; }
++=======
+ void iort_iommu_get_resv_regions(struct device *dev, struct list_head *head)
+ { }
+ 
+ static inline phys_addr_t acpi_iort_dma_get_max_cpu_address(void)
+ { return PHYS_ADDR_MAX; }
++>>>>>>> 55be25b8b5e4 (ACPI/IORT: Provide a generic helper to retrieve reserve regions)
  #endif
  
  #endif /* __ACPI_IORT_H__ */
* Unmerged path drivers/acpi/arm64/iort.c
diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c
index 973eea51365e..864f1cd5e1a3 100644
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -200,7 +200,7 @@ void iommu_dma_get_resv_regions(struct device *dev, struct list_head *list)
 {
 
 	if (!is_of_node(dev_iommu_fwspec_get(dev)->iommu_fwnode))
-		iort_iommu_msi_get_resv_regions(dev, list);
+		iort_iommu_get_resv_regions(dev, list);
 
 }
 EXPORT_SYMBOL(iommu_dma_get_resv_regions);
* Unmerged path include/linux/acpi_iort.h
