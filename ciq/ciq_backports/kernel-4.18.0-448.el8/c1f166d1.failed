net: ipv4: use kfree_skb_reason() in ip_rcv_finish_core()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit c1f166d1f7eef212096a98b22f5acf92f9af353d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c1f166d1.failed

Replace kfree_skb() with kfree_skb_reason() in ip_rcv_finish_core(),
following drop reasons are introduced:

SKB_DROP_REASON_IP_RPFILTER
SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST

	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1f166d1f7eef212096a98b22f5acf92f9af353d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/trace/events/skb.h
#	net/ipv4/ip_input.c
diff --cc include/linux/skbuff.h
index 6050fa383222,4baba45f223d..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,31 +318,35 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
+ 	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+ 					 * see the document for rp_filter
+ 					 * in ip-sysctl.rst for more
+ 					 * information
+ 					 */
+ 	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+ 						  * is multicast, but L3 is
+ 						  * unicast.
+ 						  */
++>>>>>>> c1f166d1f7ee (net: ipv4: use kfree_skb_reason() in ip_rcv_finish_core())
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/trace/events/skb.h
index 294c61bbe44b,485a1d3034a4..000000000000
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@@ -11,6 -11,18 +11,21 @@@
  
  #define TRACE_SKB_DROP_REASON					\
  	EM(SKB_DROP_REASON_NOT_SPECIFIED, NOT_SPECIFIED)	\
++<<<<<<< HEAD
++=======
+ 	EM(SKB_DROP_REASON_NO_SOCKET, NO_SOCKET)		\
+ 	EM(SKB_DROP_REASON_PKT_TOO_SMALL, PKT_TOO_SMALL)	\
+ 	EM(SKB_DROP_REASON_TCP_CSUM, TCP_CSUM)			\
+ 	EM(SKB_DROP_REASON_SOCKET_FILTER, SOCKET_FILTER)	\
+ 	EM(SKB_DROP_REASON_UDP_CSUM, UDP_CSUM)			\
+ 	EM(SKB_DROP_REASON_NETFILTER_DROP, NETFILTER_DROP)	\
+ 	EM(SKB_DROP_REASON_OTHERHOST, OTHERHOST)		\
+ 	EM(SKB_DROP_REASON_IP_CSUM, IP_CSUM)			\
+ 	EM(SKB_DROP_REASON_IP_INHDR, IP_INHDR)			\
+ 	EM(SKB_DROP_REASON_IP_RPFILTER, IP_RPFILTER)		\
+ 	EM(SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST,		\
+ 	   UNICAST_IN_L2_MULTICAST)				\
++>>>>>>> c1f166d1f7ee (net: ipv4: use kfree_skb_reason() in ip_rcv_finish_core())
  	EMe(SKB_DROP_REASON_MAX, MAX)
  
  #undef EM
diff --cc net/ipv4/ip_input.c
index 17dd51970d0a,d5222c0fa87c..000000000000
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@@ -316,16 -318,17 +316,21 @@@ static int ip_rcv_finish(struct net *ne
  {
  	const struct iphdr *iph = ip_hdr(skb);
  	int (*edemux)(struct sk_buff *skb);
++<<<<<<< HEAD
 +	struct net_device *dev = skb->dev;
++=======
+ 	int err, drop_reason;
++>>>>>>> c1f166d1f7ee (net: ipv4: use kfree_skb_reason() in ip_rcv_finish_core())
  	struct rtable *rt;
- 	int err;
+ 
+ 	drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;
  
 -	if (ip_can_use_hint(skb, iph, hint)) {
 -		err = ip_route_use_hint(skb, iph->daddr, iph->saddr, iph->tos,
 -					dev, hint);
 -		if (unlikely(err))
 -			goto drop_error;
 -	}
 +	/* if ingress device is enslaved to an L3 master device pass the
 +	 * skb to its handler for processing
 +	 */
 +	skb = l3mdev_ip_rcv(skb);
 +	if (!skb)
 +		return NET_RX_SUCCESS;
  
  	if (net->ipv4.sysctl_ip_early_demux &&
  	    !skb_dst(skb) &&
@@@ -395,14 -398,16 +400,16 @@@
  		 * so-called "hole-196" attack) so do it for both.
  		 */
  		if (in_dev &&
- 		    IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST))
+ 		    IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST)) {
+ 			drop_reason = SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST;
  			goto drop;
+ 		}
  	}
  
 -	return NET_RX_SUCCESS;
 +	return dst_input(skb);
  
  drop:
- 	kfree_skb(skb);
+ 	kfree_skb_reason(skb, drop_reason);
  	return NET_RX_DROP;
  
  drop_error:
* Unmerged path include/linux/skbuff.h
* Unmerged path include/trace/events/skb.h
* Unmerged path net/ipv4/ip_input.c
