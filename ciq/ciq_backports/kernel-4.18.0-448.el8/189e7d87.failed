KVM: s390: pci: register pci hooks without interpretation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Matthew Rosato <mjrosato@linux.ibm.com>
commit 189e7d876e48d7c791fe1c9c01516f70f5621a9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/189e7d87.failed

The kvm registration hooks must be registered even if the facilities
necessary for zPCI interpretation are unavailable, as vfio-pci-zdev will
expect to use the hooks regardless.
This fixes an issue where vfio-pci-zdev will fail its open function
because of a missing kvm_register when running on hardware that does not
support zPCI interpretation.

Fixes: ca922fecda6c ("KVM: s390: pci: Hook to access KVM lowlevel from VFIO")
	Signed-off-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
Link: https://lore.kernel.org/r/20220920193025.135655-1-mjrosato@linux.ibm.com
Message-Id: <20220920193025.135655-1-mjrosato@linux.ibm.com>
	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
(cherry picked from commit 189e7d876e48d7c791fe1c9c01516f70f5621a9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/pci.c
diff --cc arch/s390/kvm/pci.c
index b232c8cbaa81,c50c1645c0ae..000000000000
--- a/arch/s390/kvm/pci.c
+++ b/arch/s390/kvm/pci.c
@@@ -423,8 -425,259 +423,14 @@@ static void kvm_s390_pci_dev_release(st
  	kfree(kzdev);
  }
  
 -
 -/*
 - * Register device with the specified KVM. If interpetation facilities are
 - * available, enable them and let userspace indicate whether or not they will
 - * be used (specify SHM bit to disable).
 - */
 -static int kvm_s390_pci_register_kvm(void *opaque, struct kvm *kvm)
 -{
 -	struct zpci_dev *zdev = opaque;
 -	int rc;
 -
 -	if (!zdev)
 -		return -EINVAL;
 -
 -	mutex_lock(&zdev->kzdev_lock);
 -
 -	if (zdev->kzdev || zdev->gisa != 0 || !kvm) {
 -		mutex_unlock(&zdev->kzdev_lock);
 -		return -EINVAL;
 -	}
 -
 -	kvm_get_kvm(kvm);
 -
 -	mutex_lock(&kvm->lock);
 -
 -	rc = kvm_s390_pci_dev_open(zdev);
 -	if (rc)
 -		goto err;
 -
 -	/*
 -	 * If interpretation facilities aren't available, add the device to
 -	 * the kzdev list but don't enable for interpretation.
 -	 */
 -	if (!kvm_s390_pci_interp_allowed())
 -		goto out;
 -
 -	/*
 -	 * If this is the first request to use an interpreted device, make the
 -	 * necessary vcpu changes
 -	 */
 -	if (!kvm->arch.use_zpci_interp)
 -		kvm_s390_vcpu_pci_enable_interp(kvm);
 -
 -	if (zdev_enabled(zdev)) {
 -		rc = zpci_disable_device(zdev);
 -		if (rc)
 -			goto err;
 -	}
 -
 -	/*
 -	 * Store information about the identity of the kvm guest allowed to
 -	 * access this device via interpretation to be used by host CLP
 -	 */
 -	zdev->gisa = (u32)virt_to_phys(&kvm->arch.sie_page2->gisa);
 -
 -	rc = zpci_enable_device(zdev);
 -	if (rc)
 -		goto clear_gisa;
 -
 -	/* Re-register the IOMMU that was already created */
 -	rc = zpci_register_ioat(zdev, 0, zdev->start_dma, zdev->end_dma,
 -				virt_to_phys(zdev->dma_table));
 -	if (rc)
 -		goto clear_gisa;
 -
 -out:
 -	zdev->kzdev->kvm = kvm;
 -
 -	spin_lock(&kvm->arch.kzdev_list_lock);
 -	list_add_tail(&zdev->kzdev->entry, &kvm->arch.kzdev_list);
 -	spin_unlock(&kvm->arch.kzdev_list_lock);
 -
 -	mutex_unlock(&kvm->lock);
 -	mutex_unlock(&zdev->kzdev_lock);
 -	return 0;
 -
 -clear_gisa:
 -	zdev->gisa = 0;
 -err:
 -	if (zdev->kzdev)
 -		kvm_s390_pci_dev_release(zdev);
 -	mutex_unlock(&kvm->lock);
 -	mutex_unlock(&zdev->kzdev_lock);
 -	kvm_put_kvm(kvm);
 -	return rc;
 -}
 -
 -static void kvm_s390_pci_unregister_kvm(void *opaque)
 -{
 -	struct zpci_dev *zdev = opaque;
 -	struct kvm *kvm;
 -
 -	if (!zdev)
 -		return;
 -
 -	mutex_lock(&zdev->kzdev_lock);
 -
 -	if (WARN_ON(!zdev->kzdev)) {
 -		mutex_unlock(&zdev->kzdev_lock);
 -		return;
 -	}
 -
 -	kvm = zdev->kzdev->kvm;
 -	mutex_lock(&kvm->lock);
 -
 -	/*
 -	 * A 0 gisa means interpretation was never enabled, just remove the
 -	 * device from the list.
 -	 */
 -	if (zdev->gisa == 0)
 -		goto out;
 -
 -	/* Forwarding must be turned off before interpretation */
 -	if (zdev->kzdev->fib.fmt0.aibv != 0)
 -		kvm_s390_pci_aif_disable(zdev, true);
 -
 -	/* Remove the host CLP guest designation */
 -	zdev->gisa = 0;
 -
 -	if (zdev_enabled(zdev)) {
 -		if (zpci_disable_device(zdev))
 -			goto out;
 -	}
 -
 -	if (zpci_enable_device(zdev))
 -		goto out;
 -
 -	/* Re-register the IOMMU that was already created */
 -	zpci_register_ioat(zdev, 0, zdev->start_dma, zdev->end_dma,
 -			   virt_to_phys(zdev->dma_table));
 -
 -out:
 -	spin_lock(&kvm->arch.kzdev_list_lock);
 -	list_del(&zdev->kzdev->entry);
 -	spin_unlock(&kvm->arch.kzdev_list_lock);
 -	kvm_s390_pci_dev_release(zdev);
 -
 -	mutex_unlock(&kvm->lock);
 -	mutex_unlock(&zdev->kzdev_lock);
 -
 -	kvm_put_kvm(kvm);
 -}
 -
 -void kvm_s390_pci_init_list(struct kvm *kvm)
 -{
 -	spin_lock_init(&kvm->arch.kzdev_list_lock);
 -	INIT_LIST_HEAD(&kvm->arch.kzdev_list);
 -}
 -
 -void kvm_s390_pci_clear_list(struct kvm *kvm)
 -{
 -	/*
 -	 * This list should already be empty, either via vfio device closures
 -	 * or kvm fd cleanup.
 -	 */
 -	spin_lock(&kvm->arch.kzdev_list_lock);
 -	WARN_ON_ONCE(!list_empty(&kvm->arch.kzdev_list));
 -	spin_unlock(&kvm->arch.kzdev_list_lock);
 -}
 -
 -static struct zpci_dev *get_zdev_from_kvm_by_fh(struct kvm *kvm, u32 fh)
 -{
 -	struct zpci_dev *zdev = NULL;
 -	struct kvm_zdev *kzdev;
 -
 -	spin_lock(&kvm->arch.kzdev_list_lock);
 -	list_for_each_entry(kzdev, &kvm->arch.kzdev_list, entry) {
 -		if (kzdev->zdev->fh == fh) {
 -			zdev = kzdev->zdev;
 -			break;
 -		}
 -	}
 -	spin_unlock(&kvm->arch.kzdev_list_lock);
 -
 -	return zdev;
 -}
 -
 -static int kvm_s390_pci_zpci_reg_aen(struct zpci_dev *zdev,
 -				     struct kvm_s390_zpci_op *args)
 -{
 -	struct zpci_fib fib = {};
 -	bool hostflag;
 -
 -	fib.fmt0.aibv = args->u.reg_aen.ibv;
 -	fib.fmt0.isc = args->u.reg_aen.isc;
 -	fib.fmt0.noi = args->u.reg_aen.noi;
 -	if (args->u.reg_aen.sb != 0) {
 -		fib.fmt0.aisb = args->u.reg_aen.sb;
 -		fib.fmt0.aisbo = args->u.reg_aen.sbo;
 -		fib.fmt0.sum = 1;
 -	} else {
 -		fib.fmt0.aisb = 0;
 -		fib.fmt0.aisbo = 0;
 -		fib.fmt0.sum = 0;
 -	}
 -
 -	hostflag = !(args->u.reg_aen.flags & KVM_S390_ZPCIOP_REGAEN_HOST);
 -	return kvm_s390_pci_aif_enable(zdev, &fib, hostflag);
 -}
 -
 -int kvm_s390_pci_zpci_op(struct kvm *kvm, struct kvm_s390_zpci_op *args)
 -{
 -	struct kvm_zdev *kzdev;
 -	struct zpci_dev *zdev;
 -	int r;
 -
 -	zdev = get_zdev_from_kvm_by_fh(kvm, args->fh);
 -	if (!zdev)
 -		return -ENODEV;
 -
 -	mutex_lock(&zdev->kzdev_lock);
 -	mutex_lock(&kvm->lock);
 -
 -	kzdev = zdev->kzdev;
 -	if (!kzdev) {
 -		r = -ENODEV;
 -		goto out;
 -	}
 -	if (kzdev->kvm != kvm) {
 -		r = -EPERM;
 -		goto out;
 -	}
 -
 -	switch (args->op) {
 -	case KVM_S390_ZPCIOP_REG_AEN:
 -		/* Fail on unknown flags */
 -		if (args->u.reg_aen.flags & ~KVM_S390_ZPCIOP_REGAEN_HOST) {
 -			r = -EINVAL;
 -			break;
 -		}
 -		r = kvm_s390_pci_zpci_reg_aen(zdev, args);
 -		break;
 -	case KVM_S390_ZPCIOP_DEREG_AEN:
 -		r = kvm_s390_pci_aif_disable(zdev, false);
 -		break;
 -	default:
 -		r = -EINVAL;
 -	}
 -
 -out:
 -	mutex_unlock(&kvm->lock);
 -	mutex_unlock(&zdev->kzdev_lock);
 -	return r;
 -}
 -
  int kvm_s390_pci_init(void)
  {
+ 	zpci_kvm_hook.kvm_register = kvm_s390_pci_register_kvm;
+ 	zpci_kvm_hook.kvm_unregister = kvm_s390_pci_unregister_kvm;
+ 
+ 	if (!kvm_s390_pci_interp_allowed())
+ 		return 0;
+ 
  	aift = kzalloc(sizeof(struct zpci_aift), GFP_KERNEL);
  	if (!aift)
  		return -ENOMEM;
@@@ -437,6 -690,12 +443,16 @@@
  
  void kvm_s390_pci_exit(void)
  {
++<<<<<<< HEAD
++	mutex_destroy(&aift->aift_lock);
++=======
+ 	zpci_kvm_hook.kvm_register = NULL;
+ 	zpci_kvm_hook.kvm_unregister = NULL;
++>>>>>>> 189e7d876e48 (KVM: s390: pci: register pci hooks without interpretation)
+ 
+ 	if (!kvm_s390_pci_interp_allowed())
+ 		return;
+ 
  	mutex_destroy(&aift->aift_lock);
  
  	kfree(aift);
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index d9a77ff8733f..af919a2fdf8f 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -503,7 +503,7 @@ int kvm_arch_init(void *opaque)
 		goto out;
 	}
 
-	if (kvm_s390_pci_interp_allowed()) {
+	if (IS_ENABLED(CONFIG_VFIO_PCI_ZDEV_KVM)) {
 		rc = kvm_s390_pci_init();
 		if (rc) {
 			pr_err("Unable to allocate AIFT for PCI\n");
@@ -525,7 +525,7 @@ int kvm_arch_init(void *opaque)
 void kvm_arch_exit(void)
 {
 	kvm_s390_gib_destroy();
-	if (kvm_s390_pci_interp_allowed())
+	if (IS_ENABLED(CONFIG_VFIO_PCI_ZDEV_KVM))
 		kvm_s390_pci_exit();
 	debug_unregister(kvm_s390_dbf);
 	debug_unregister(kvm_s390_dbf_uv);
* Unmerged path arch/s390/kvm/pci.c
