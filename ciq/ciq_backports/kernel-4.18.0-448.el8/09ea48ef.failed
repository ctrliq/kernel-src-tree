vfio: Make vfio_(un)register_notifier accept a vfio_device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
Rebuild_CHGLOG: - Revert "vfio: Make vfio_(un)register_notifier accept a vfio_device" (Jocelyn Falempe) [2115880]
Rebuild_FUZZ: 92.80%
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 09ea48efffa3156218980e20aaf23dcc7d6000fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/09ea48ef.failed

All callers have a struct vfio_device trivially available, pass it in
directly and avoid calling the expensive vfio_group_get_from_dev().

	Acked-by: Eric Farman <farman@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Reviewed-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Kevin Tian <kevin.tian@intel.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
Link: https://lore.kernel.org/r/1-v4-8045e76bf00b+13d-vfio_mdev_no_group_jgg@nvidia.com
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit 09ea48efffa3156218980e20aaf23dcc7d6000fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gvt/kvmgt.c
#	drivers/s390/cio/vfio_ccw_ops.c
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/gpu/drm/i915/gvt/kvmgt.c
index 5bd0c74fc4ad,1cec4f1fdfac..000000000000
--- a/drivers/gpu/drm/i915/gvt/kvmgt.c
+++ b/drivers/gpu/drm/i915/gvt/kvmgt.c
@@@ -909,12 -806,12 +909,17 @@@ static int intel_vgpu_open(struct mdev_
  	int ret;
  	struct vfio_group *vfio_group;
  
 -	vgpu->iommu_notifier.notifier_call = intel_vgpu_iommu_notifier;
 -	vgpu->group_notifier.notifier_call = intel_vgpu_group_notifier;
 +	vdev->iommu_notifier.notifier_call = intel_vgpu_iommu_notifier;
 +	vdev->group_notifier.notifier_call = intel_vgpu_group_notifier;
  
  	events = VFIO_IOMMU_NOTIFY_DMA_UNMAP;
++<<<<<<< HEAD
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY, &events,
 +				&vdev->iommu_notifier);
++=======
+ 	ret = vfio_register_notifier(vfio_dev, VFIO_IOMMU_NOTIFY, &events,
+ 				     &vgpu->iommu_notifier);
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  	if (ret != 0) {
  		gvt_vgpu_err("vfio_register_notifier for iommu failed: %d\n",
  			ret);
@@@ -922,8 -819,8 +927,13 @@@
  	}
  
  	events = VFIO_GROUP_NOTIFY_SET_KVM;
++<<<<<<< HEAD
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY, &events,
 +				&vdev->group_notifier);
++=======
+ 	ret = vfio_register_notifier(vfio_dev, VFIO_GROUP_NOTIFY, &events,
+ 				     &vgpu->group_notifier);
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  	if (ret != 0) {
  		gvt_vgpu_err("vfio_register_notifier for group failed: %d\n",
  			ret);
@@@ -946,26 -846,39 +956,35 @@@
  		goto undo_group;
  	}
  
 -	ret = -EEXIST;
 -	if (__kvmgt_vgpu_exist(vgpu))
 +	ret = kvmgt_guest_init(mdev);
 +	if (ret)
  		goto undo_group;
  
 -	vgpu->attached = true;
 -	kvm_get_kvm(vgpu->kvm);
 -
 -	kvmgt_protect_table_init(vgpu);
 -	gvt_cache_init(vgpu);
 -
 -	vgpu->track_node.track_write = kvmgt_page_track_write;
 -	vgpu->track_node.track_flush_slot = kvmgt_page_track_flush_slot;
 -	kvm_page_track_register_notifier(vgpu->kvm, &vgpu->track_node);
 -
 -	debugfs_create_ulong(KVMGT_DEBUGFS_FILENAME, 0444, vgpu->debugfs,
 -			     &vgpu->nr_cache_entries);
 +	intel_gvt_ops->vgpu_activate(vgpu);
  
 -	intel_gvt_activate_vgpu(vgpu);
 -
 -	atomic_set(&vgpu->released, 0);
 -	return 0;
 +	atomic_set(&vdev->released, 0);
 +	return ret;
  
  undo_group:
 -	vfio_group_put_external_user(vgpu->vfio_group);
 -	vgpu->vfio_group = NULL;
 +	vfio_group_put_external_user(vdev->vfio_group);
 +	vdev->vfio_group = NULL;
  
  undo_register:
++<<<<<<< HEAD
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
 +					&vdev->group_notifier);
 +
 +undo_iommu:
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +					&vdev->iommu_notifier);
++=======
+ 	vfio_unregister_notifier(vfio_dev, VFIO_GROUP_NOTIFY,
+ 				 &vgpu->group_notifier);
+ 
+ undo_iommu:
+ 	vfio_unregister_notifier(vfio_dev, VFIO_IOMMU_NOTIFY,
+ 				 &vgpu->iommu_notifier);
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  out:
  	return ret;
  }
@@@ -984,26 -896,24 +1003,36 @@@ static void intel_vgpu_release_msi_even
  
  static void __intel_vgpu_release(struct intel_vgpu *vgpu)
  {
 +	struct kvmgt_vdev *vdev = kvmgt_vdev(vgpu);
  	struct drm_i915_private *i915 = vgpu->gvt->gt->i915;
 +	struct kvmgt_guest_info *info;
  	int ret;
  
 -	if (!vgpu->attached)
 +	if (!handle_valid(vgpu->handle))
  		return;
  
 -	if (atomic_cmpxchg(&vgpu->released, 0, 1))
 +	if (atomic_cmpxchg(&vdev->released, 0, 1))
  		return;
  
 -	intel_gvt_release_vgpu(vgpu);
 +	intel_gvt_ops->vgpu_release(vgpu);
 +
++<<<<<<< HEAD
 +	ret = vfio_unregister_notifier(mdev_dev(vdev->mdev), VFIO_IOMMU_NOTIFY,
 +					&vdev->iommu_notifier);
 +	drm_WARN(&i915->drm, ret,
 +		 "vfio_unregister_notifier for iommu failed: %d\n", ret);
  
 +	ret = vfio_unregister_notifier(mdev_dev(vdev->mdev), VFIO_GROUP_NOTIFY,
 +					&vdev->group_notifier);
++=======
+ 	ret = vfio_unregister_notifier(&vgpu->vfio_device, VFIO_IOMMU_NOTIFY,
+ 				       &vgpu->iommu_notifier);
+ 	drm_WARN(&i915->drm, ret,
+ 		 "vfio_unregister_notifier for iommu failed: %d\n", ret);
+ 
+ 	ret = vfio_unregister_notifier(&vgpu->vfio_device, VFIO_GROUP_NOTIFY,
+ 				       &vgpu->group_notifier);
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  	drm_WARN(&i915->drm, ret,
  		 "vfio_unregister_notifier for group failed: %d\n", ret);
  
diff --cc drivers/s390/cio/vfio_ccw_ops.c
index bee98d0c629f,b49e2e9db2dc..000000000000
--- a/drivers/s390/cio/vfio_ccw_ops.c
+++ b/drivers/s390/cio/vfio_ccw_ops.c
@@@ -165,7 -183,7 +165,11 @@@ static int vfio_ccw_mdev_open(struct md
  
  	private->nb.notifier_call = vfio_ccw_mdev_notifier;
  
++<<<<<<< HEAD
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
++=======
+ 	ret = vfio_register_notifier(vdev, VFIO_IOMMU_NOTIFY,
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  				     &events, &private->nb);
  	if (ret)
  		return ret;
@@@ -186,8 -204,7 +190,12 @@@
  
  out_unregister:
  	vfio_ccw_unregister_dev_regions(private);
++<<<<<<< HEAD
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +				 &private->nb);
++=======
+ 	vfio_unregister_notifier(vdev, VFIO_IOMMU_NOTIFY, &private->nb);
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  	return ret;
  }
  
@@@ -205,8 -222,7 +213,12 @@@ static void vfio_ccw_mdev_release(struc
  
  	cp_free(&private->cp);
  	vfio_ccw_unregister_dev_regions(private);
++<<<<<<< HEAD
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +				 &private->nb);
++=======
+ 	vfio_unregister_notifier(vdev, VFIO_IOMMU_NOTIFY, &private->nb);
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  }
  
  static ssize_t vfio_ccw_mdev_read_io_region(struct vfio_ccw_private *private,
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,bfa7ee6ef532..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -1281,36 -1406,35 +1281,59 @@@ static int vfio_ap_mdev_open(struct mde
  	matrix_mdev->group_notifier.notifier_call = vfio_ap_mdev_group_notifier;
  	events = VFIO_GROUP_NOTIFY_SET_KVM;
  
++<<<<<<< HEAD
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
 +				     &events, &matrix_mdev->group_notifier);
 +	if (ret) {
 +		module_put(THIS_MODULE);
++=======
+ 	ret = vfio_register_notifier(vdev, VFIO_GROUP_NOTIFY, &events,
+ 				     &matrix_mdev->group_notifier);
+ 	if (ret)
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  		return ret;
 +	}
  
  	matrix_mdev->iommu_notifier.notifier_call = vfio_ap_mdev_iommu_notifier;
  	events = VFIO_IOMMU_NOTIFY_DMA_UNMAP;
++<<<<<<< HEAD
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +				     &events, &matrix_mdev->iommu_notifier);
 +	if (!ret)
 +		return ret;
 +
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
++=======
+ 	ret = vfio_register_notifier(vdev, VFIO_IOMMU_NOTIFY, &events,
+ 				     &matrix_mdev->iommu_notifier);
+ 	if (ret)
+ 		goto out_unregister_group;
+ 	return 0;
+ 
+ out_unregister_group:
+ 	vfio_unregister_notifier(vdev, VFIO_GROUP_NOTIFY,
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  				 &matrix_mdev->group_notifier);
 +	module_put(THIS_MODULE);
  	return ret;
  }
  
 -static void vfio_ap_mdev_close_device(struct vfio_device *vdev)
 +static void vfio_ap_mdev_release(struct mdev_device *mdev)
  {
 -	struct ap_matrix_mdev *matrix_mdev =
 -		container_of(vdev, struct ap_matrix_mdev, vdev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
++<<<<<<< HEAD
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +				 &matrix_mdev->iommu_notifier);
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
++=======
+ 	vfio_unregister_notifier(vdev, VFIO_IOMMU_NOTIFY,
+ 				 &matrix_mdev->iommu_notifier);
+ 	vfio_unregister_notifier(vdev, VFIO_GROUP_NOTIFY,
++>>>>>>> 09ea48efffa3 (vfio: Make vfio_(un)register_notifier accept a vfio_device)
  				 &matrix_mdev->group_notifier);
 -	vfio_ap_mdev_unset_kvm(matrix_mdev);
 +	vfio_ap_mdev_unset_kvm(matrix_mdev, matrix_mdev->kvm);
 +	module_put(THIS_MODULE);
  }
  
  static int vfio_ap_mdev_get_device_info(unsigned long arg)
* Unmerged path drivers/gpu/drm/i915/gvt/kvmgt.c
* Unmerged path drivers/s390/cio/vfio_ccw_ops.c
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c
index 6b6579dad759..c1c16e107406 100644
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@ -2276,19 +2276,16 @@ static int vfio_unregister_group_notifier(struct vfio_group *group,
 	return ret;
 }
 
-int vfio_register_notifier(struct device *dev, enum vfio_notify_type type,
-			   unsigned long *events, struct notifier_block *nb)
+int vfio_register_notifier(struct vfio_device *device,
+			   enum vfio_notify_type type, unsigned long *events,
+			   struct notifier_block *nb)
 {
-	struct vfio_group *group;
+	struct vfio_group *group = device->group;
 	int ret;
 
-	if (!dev || !nb || !events || (*events == 0))
+	if (!nb || !events || (*events == 0))
 		return -EINVAL;
 
-	group = vfio_group_get_from_dev(dev);
-	if (!group)
-		return -ENODEV;
-
 	switch (type) {
 	case VFIO_IOMMU_NOTIFY:
 		ret = vfio_register_iommu_notifier(group, events, nb);
@@ -2299,25 +2296,20 @@ int vfio_register_notifier(struct device *dev, enum vfio_notify_type type,
 	default:
 		ret = -EINVAL;
 	}
-
-	vfio_group_put(group);
 	return ret;
 }
 EXPORT_SYMBOL(vfio_register_notifier);
 
-int vfio_unregister_notifier(struct device *dev, enum vfio_notify_type type,
+int vfio_unregister_notifier(struct vfio_device *device,
+			     enum vfio_notify_type type,
 			     struct notifier_block *nb)
 {
-	struct vfio_group *group;
+	struct vfio_group *group = device->group;
 	int ret;
 
-	if (!dev || !nb)
+	if (!nb)
 		return -EINVAL;
 
-	group = vfio_group_get_from_dev(dev);
-	if (!group)
-		return -ENODEV;
-
 	switch (type) {
 	case VFIO_IOMMU_NOTIFY:
 		ret = vfio_unregister_iommu_notifier(group, nb);
@@ -2328,8 +2320,6 @@ int vfio_unregister_notifier(struct device *dev, enum vfio_notify_type type,
 	default:
 		ret = -EINVAL;
 	}
-
-	vfio_group_put(group);
 	return ret;
 }
 EXPORT_SYMBOL(vfio_unregister_notifier);
diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 96af7a2ad4d3..5a136fb9b577 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -141,11 +141,11 @@ enum vfio_notify_type {
 /* events for VFIO_GROUP_NOTIFY */
 #define VFIO_GROUP_NOTIFY_SET_KVM	BIT(0)
 
-extern int vfio_register_notifier(struct device *dev,
+extern int vfio_register_notifier(struct vfio_device *device,
 				  enum vfio_notify_type type,
 				  unsigned long *required_events,
 				  struct notifier_block *nb);
-extern int vfio_unregister_notifier(struct device *dev,
+extern int vfio_unregister_notifier(struct vfio_device *device,
 				    enum vfio_notify_type type,
 				    struct notifier_block *nb);
 
