net: memcg: late association of sock to memcg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Shakeel Butt <shakeelb@google.com>
commit d752a4986532cb6305dfd5290a614cde8072769d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d752a498.failed

If a TCP socket is allocated in IRQ context or cloned from unassociated
(i.e. not associated to a memcg) in IRQ context then it will remain
unassociated for its whole life. Almost half of the TCPs created on the
system are created in IRQ context, so, memory used by such sockets will
not be accounted by the memcg.

This issue is more widespread in cgroup v1 where network memory
accounting is opt-in but it can happen in cgroup v2 if the source socket
for the cloning was created in root memcg.

To fix the issue, just do the association of the sockets at the accept()
time in the process context and then force charge the memory buffer
already used and reserved by the socket.

	Signed-off-by: Shakeel Butt <shakeelb@google.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d752a4986532cb6305dfd5290a614cde8072769d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/sock.c
diff --cc net/core/sock.c
index 4a4d3fa82db5,8f71684305c3..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -1912,8 -1830,11 +1912,16 @@@ struct sock *sk_clone_lock(const struc
  		atomic_set(&newsk->sk_zckey, 0);
  
  		sock_reset_flag(newsk, SOCK_DONE);
++<<<<<<< HEAD
 +		mem_cgroup_sk_alloc(newsk);
 +		cgroup_sk_clone(&newsk->sk_cgrp_data);
++=======
+ 
+ 		/* sk->sk_memcg will be populated at accept() time */
+ 		newsk->sk_memcg = NULL;
+ 
+ 		cgroup_sk_alloc(&newsk->sk_cgrp_data);
++>>>>>>> d752a4986532 (net: memcg: late association of sock to memcg)
  
  		rcu_read_lock();
  		filter = rcu_dereference(sk->sk_filter);
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index ec04fec970d9..36a4b9c6150c 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -7166,20 +7166,6 @@ void mem_cgroup_sk_alloc(struct sock *sk)
 	if (!mem_cgroup_sockets_enabled)
 		return;
 
-	/*
-	 * Socket cloning can throw us here with sk_memcg already
-	 * filled. It won't however, necessarily happen from
-	 * process context. So the test for root memcg given
-	 * the current task's memcg won't help us in this case.
-	 *
-	 * Respecting the original socket's memcg is a better
-	 * decision in this case.
-	 */
-	if (sk->sk_memcg) {
-		css_get(&sk->sk_memcg->css);
-		return;
-	}
-
 	/* Do not associate the sock with unrelated interrupted task's memcg. */
 	if (in_interrupt())
 		return;
* Unmerged path net/core/sock.c
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index f4cb1c50e999..3ef7c5346759 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -500,6 +500,26 @@ struct sock *inet_csk_accept(struct sock *sk, int flags, int *err, bool kern)
 		}
 		spin_unlock_bh(&queue->fastopenq.lock);
 	}
+
+	if (mem_cgroup_sockets_enabled) {
+		int amt;
+
+		/* atomically get the memory usage, set and charge the
+		 * sk->sk_memcg.
+		 */
+		lock_sock(newsk);
+
+		/* The sk has not been accepted yet, no need to look at
+		 * sk->sk_wmem_queued.
+		 */
+		amt = sk_mem_pages(newsk->sk_forward_alloc +
+				   atomic_read(&sk->sk_rmem_alloc));
+		mem_cgroup_sk_alloc(newsk);
+		if (newsk->sk_memcg && amt)
+			mem_cgroup_charge_skmem(newsk->sk_memcg, amt);
+
+		release_sock(newsk);
+	}
 out:
 	release_sock(sk);
 	if (req)
