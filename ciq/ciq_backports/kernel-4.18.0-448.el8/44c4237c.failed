dmaengine: idxd: force wq context cleanup on device disable path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 44c4237cf3436bda2b185ff728123651ad133f69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/44c4237c.failed

Testing shown that when a wq mode is setup to be dedicated and then torn
down and reconfigured to shared, the wq configured end up being dedicated
anyays. The root cause is when idxd_device_wqs_clear_state() gets called
during idxd_driver removal, idxd_wq_disable_cleanup() does not get called
vs when the wq driver is removed first. The check of wq state being
"enabled" causes the cleanup to be bypassed. However, idxd_driver->remove()
releases all wq drivers. So the wqs goes to "disabled" state and will never
be "enabled". By that point, the driver has no idea if the wq was
previously configured or clean. So force call idxd_wq_disable_cleanup() on
all wqs always to make sure everything gets cleaned up.

	Reported-by: Tony Zhu <tony.zhu@intel.com>
	Tested-by: Tony Zhu <tony.zhu@intel.com>
Fixes: 0dcfe41e9a4c ("dmanegine: idxd: cleanup all device related bits after disabling device")
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Co-developed-by: Fenghua Yu <fenghua.yu@intel.com>
	Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
Link: https://lore.kernel.org/r/20220628230056.2527816-1-fenghua.yu@intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 44c4237cf3436bda2b185ff728123651ad133f69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/device.c
diff --cc drivers/dma/idxd/device.c
index 2251a382322d,5a8cc52c1abf..000000000000
--- a/drivers/dma/idxd/device.c
+++ b/drivers/dma/idxd/device.c
@@@ -715,13 -715,10 +715,18 @@@ static void idxd_device_wqs_clear_state
  	for (i = 0; i < idxd->max_wqs; i++) {
  		struct idxd_wq *wq = idxd->wqs[i];
  
++<<<<<<< HEAD
 +		if (wq->state == IDXD_WQ_ENABLED) {
 +			mutex_lock(&wq->wq_lock);
 +			idxd_wq_disable_cleanup(wq);
 +			wq->state = IDXD_WQ_DISABLED;
 +			mutex_unlock(&wq->wq_lock);
 +		}
++=======
+ 		mutex_lock(&wq->wq_lock);
+ 		idxd_wq_disable_cleanup(wq);
++>>>>>>> 44c4237cf343 (dmaengine: idxd: force wq context cleanup on device disable path)
  		idxd_wq_device_reset_cleanup(wq);
 -		mutex_unlock(&wq->wq_lock);
  	}
  }
  
* Unmerged path drivers/dma/idxd/device.c
