wifi: mac80211: limit A-MSDU subframes for client too

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 175ad2ec89feb8c01f87be64882af67481b1b1f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/175ad2ec.failed

In AP/mesh where the stations are added by userspace, we
limit the number of A-MSDU subframes according to the
extended capabilities.

Refactor the code and extend that also to client-side.

Fixes: 506bcfa8abeb ("mac80211: limit the A-MSDU Tx based on peer's capabilities")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 175ad2ec89feb8c01f87be64882af67481b1b1f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/sta_info.c
diff --cc net/mac80211/sta_info.c
index d25b297851c4,eed88630594f..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -2604,3 -2665,122 +2604,125 @@@ void ieee80211_sta_set_expected_through
  
  	sta_update_codel_params(sta, thr);
  }
++<<<<<<< HEAD
++=======
+ 
+ int ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct sta_link_alloc *alloc;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	/* must represent an MLD from the start */
+ 	if (WARN_ON(!sta->sta.valid_links))
+ 		return -EINVAL;
+ 
+ 	if (WARN_ON(sta->sta.valid_links & BIT(link_id) ||
+ 		    sta->link[link_id]))
+ 		return -EBUSY;
+ 
+ 	alloc = kzalloc(sizeof(*alloc), GFP_KERNEL);
+ 	if (!alloc)
+ 		return -ENOMEM;
+ 
+ 	ret = sta_info_alloc_link(sdata->local, &alloc->info, GFP_KERNEL);
+ 	if (ret) {
+ 		kfree(alloc);
+ 		return ret;
+ 	}
+ 
+ 	sta_info_add_link(sta, link_id, &alloc->info, &alloc->sta);
+ 
+ 	return 0;
+ }
+ 
+ static int link_sta_info_hash_add(struct ieee80211_local *local,
+ 				  struct link_sta_info *link_sta)
+ {
+ 	return rhltable_insert(&local->link_sta_hash,
+ 			       &link_sta->link_hash_node,
+ 			       link_sta_rht_params);
+ }
+ 
+ void ieee80211_sta_free_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	lockdep_assert_held(&sta->sdata->local->sta_mtx);
+ 
+ 	sta_remove_link(sta, link_id, false);
+ }
+ 
+ int ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct link_sta_info *link_sta;
+ 	u16 old_links = sta->sta.valid_links;
+ 	u16 new_links = old_links | BIT(link_id);
+ 	int ret;
+ 
+ 	link_sta = rcu_dereference_protected(sta->link[link_id],
+ 					     lockdep_is_held(&sdata->local->sta_mtx));
+ 
+ 	if (WARN_ON(old_links == new_links || !link_sta))
+ 		return -EINVAL;
+ 
+ 	sta->sta.valid_links = new_links;
+ 
+ 	if (!test_sta_flag(sta, WLAN_STA_INSERTED)) {
+ 		ret = 0;
+ 		goto hash;
+ 	}
+ 
+ 	ret = drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				   old_links, new_links);
+ 	if (ret) {
+ 		sta->sta.valid_links = old_links;
+ 		sta_remove_link(sta, link_id, false);
+ 	}
+ 
+ hash:
+ 	link_sta_info_hash_add(sdata->local, link_sta);
+ 
+ 	return ret;
+ }
+ 
+ void ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	sta->sta.valid_links &= ~BIT(link_id);
+ 
+ 	if (test_sta_flag(sta, WLAN_STA_INSERTED))
+ 		drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				     sta->sta.valid_links,
+ 				     sta->sta.valid_links & ~BIT(link_id));
+ 
+ 	sta_remove_link(sta, link_id, true);
+ }
+ 
+ void ieee80211_sta_set_max_amsdu_subframes(struct sta_info *sta,
+ 					   const u8 *ext_capab,
+ 					   unsigned int ext_capab_len)
+ {
+ 	u8 val;
+ 
+ 	sta->sta.max_amsdu_subframes = 0;
+ 
+ 	if (ext_capab_len < 8)
+ 		return;
+ 
+ 	/* The sender might not have sent the last bit, consider it to be 0 */
+ 	val = u8_get_bits(ext_capab[7], WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB);
+ 
+ 	/* we did get all the bits, take the MSB as well */
+ 	if (ext_capab_len >= 9)
+ 		val |= u8_get_bits(ext_capab[8],
+ 				   WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB) << 1;
+ 
+ 	if (val)
+ 		sta->sta.max_amsdu_subframes = 4 << val;
+ }
++>>>>>>> 175ad2ec89fe (wifi: mac80211: limit A-MSDU subframes for client too)
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 10637d509537..f7b89855045a 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1674,33 +1674,8 @@ static int sta_apply_parameters(struct ieee80211_local *local,
 		sta->sta.max_sp = params->max_sp;
 	}
 
-	/* The sender might not have sent the last bit, consider it to be 0 */
-	if (params->ext_capab_len >= 8) {
-		u8 val = (params->ext_capab[7] &
-			  WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB) >> 7;
-
-		/* we did get all the bits, take the MSB as well */
-		if (params->ext_capab_len >= 9) {
-			u8 val_msb = params->ext_capab[8] &
-				WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB;
-			val_msb <<= 1;
-			val |= val_msb;
-		}
-
-		switch (val) {
-		case 1:
-			sta->sta.max_amsdu_subframes = 32;
-			break;
-		case 2:
-			sta->sta.max_amsdu_subframes = 16;
-			break;
-		case 3:
-			sta->sta.max_amsdu_subframes = 8;
-			break;
-		default:
-			sta->sta.max_amsdu_subframes = 0;
-		}
-	}
+	ieee80211_sta_set_max_amsdu_subframes(sta, params->ext_capab,
+					      params->ext_capab_len);
 
 	/*
 	 * cfg80211 validates this (1-2007) and allows setting the AID
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 446accddbebd..6bf12c083995 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -3726,6 +3726,9 @@ static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
 		sta->sta.mfp = false;
 	}
 
+	ieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,
+					      elems->ext_capab_len);
+
 	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
 		       local->hw.queues >= IEEE80211_NUM_ACS;
 
* Unmerged path net/mac80211/sta_info.c
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index addc78b398f0..8646671cd3f4 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -862,6 +862,10 @@ void ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta);
 
 unsigned long ieee80211_sta_last_active(struct sta_info *sta);
 
+void ieee80211_sta_set_max_amsdu_subframes(struct sta_info *sta,
+					   const u8 *ext_capab,
+					   unsigned int ext_capab_len);
+
 enum sta_stats_type {
 	STA_STATS_RATE_TYPE_INVALID = 0,
 	STA_STATS_RATE_TYPE_LEGACY,
