wifi: mac80211: mlme: refactor assoc link setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 1845c1d4a455e000dbf66dc4126c98837ac3e528
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1845c1d4.failed

Factor out the code to set up the assoc link into a
new function ieee80211_setup_assoc_link().

While at it, also modify the 'override' handling to
just take into account whether or not the conn_flags
were changed, which is what we need to setup again
the channel later.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 1845c1d4a455e000dbf66dc4126c98837ac3e528)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,292ad46daa9d..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -5910,11 -6271,12 +6026,18 @@@ int ieee80211_mgd_assoc(struct ieee8021
  	struct ieee80211_bss *bss = (void *)req->bss->priv;
  	struct ieee80211_mgd_assoc_data *assoc_data;
  	const struct cfg80211_bss_ies *beacon_ies;
++<<<<<<< HEAD
 +	struct ieee80211_supported_band *sband;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +	const struct element *ssid_elem, *ht_elem, *vht_elem;
++=======
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 	const struct element *ssid_elem;
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	ieee80211_conn_flags_t conn_flags = 0;
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  	int i, err;
- 	bool override = false;
+ 	bool override;
  
  	assoc_data = kzalloc(sizeof(*assoc_data) + req->ie_len, GFP_KERNEL);
  	if (!assoc_data)
@@@ -5969,8 -6332,6 +6092,11 @@@
  
  	/* prepare assoc data */
  
++<<<<<<< HEAD
 +	ifmgd->beacon_crc_valid = false;
 +
++=======
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  	assoc_data->wmm = bss->wmm_used &&
  			  (local->hw.queues >= IEEE80211_NUM_ACS);
  
@@@ -5985,23 -6346,21 +6111,35 @@@
  		if (req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP40 ||
  		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP ||
  		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP104) {
++<<<<<<< HEAD
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 			conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 			conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  			netdev_info(sdata->dev,
  				    "disabling HT/VHT/HE due to WEP/TKIP use\n");
  		}
  	}
  
- 	sband = local->hw.wiphy->bands[req->bss->channel->band];
- 
  	/* also disable HT/VHT/HE/EHT if the AP doesn't use WMM */
  	if (!bss->wmm_used) {
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  		netdev_info(sdata->dev,
  			    "disabling HT/VHT/HE as WMM/QoS is not supported by the AP\n");
  	}
@@@ -6040,28 -6418,15 +6197,37 @@@
  
  	assoc_data->bss = req->bss;
  	assoc_data->capability = req->bss->capability;
- 	assoc_data->supp_rates = bss->supp_rates;
- 	assoc_data->supp_rates_len = bss->supp_rates_len;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	ht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_HT_OPERATION);
 +	if (ht_elem && ht_elem->datalen >= sizeof(struct ieee80211_ht_operation))
 +		assoc_data->ap_ht_param =
 +			((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;
 +	else if (!is_6ghz)
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +	vht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_VHT_CAPABILITY);
 +	if (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {
 +		memcpy(&assoc_data->ap_vht_cap, vht_elem->data,
 +		       sizeof(struct ieee80211_vht_cap));
 +	} else if (is_5ghz) {
 +		sdata_info(sdata,
 +			   "VHT capa missing/short, disabling VHT/HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT |
 +				IEEE80211_STA_DISABLE_HE |
 +				IEEE80211_STA_DISABLE_EHT;
 +	}
 +	rcu_read_unlock();
++=======
+ 	/* default timeout */
+ 	assoc_data->timeout = jiffies;
+ 	assoc_data->timeout_started = true;
+ 
+ 	conn_flags |= ieee80211_setup_assoc_link(sdata, assoc_data, req,
+ 						 conn_flags);
+ 	override = link->u.mgd.conn_flags != conn_flags;
+ 	link->u.mgd.conn_flags |= conn_flags;
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  
  	if (WARN((sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD) &&
  		 ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK),
@@@ -6105,53 -6470,10 +6271,55 @@@
  	sdata->control_port_no_preauth = req->crypto.control_port_no_preauth;
  
  	/* kick off associate process */
- 
  	ifmgd->assoc_data = assoc_data;
++<<<<<<< HEAD
 +	ifmgd->dtim_period = 0;
 +	ifmgd->have_beacon = false;
 +
 +	/* override HT/VHT configuration only if the AP and we support it */
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
 +		struct ieee80211_sta_ht_cap sta_ht_cap;
 +
 +		if (req->flags & ASSOC_REQ_DISABLE_HT)
 +			override = true;
 +
 +		memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
 +		ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
 +
 +		/* check for 40 MHz disable override */
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_40MHZ) &&
 +		    sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&
 +		    !(sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))
 +			override = true;
 +
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
 +		    req->flags & ASSOC_REQ_DISABLE_VHT)
 +			override = true;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_HT) {
 +		mlme_dbg(sdata, "HT disabled by flag, disabling HT/VHT/HE\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_VHT) {
 +		mlme_dbg(sdata, "VHT disabled by flag, disabling VHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_HE) {
 +		mlme_dbg(sdata, "HE disabled by flag, disabling HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
++=======
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  
  	if (req->flags & ASSOC_REQ_DISABLE_EHT)
 -		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
  
  	err = ieee80211_prep_connection(sdata, req->bss, true, override);
  	if (err)
@@@ -6180,64 -6502,16 +6348,53 @@@
  		assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
  		assoc_data->timeout_started = true;
  		assoc_data->need_beacon = true;
++<<<<<<< HEAD
 +	} else if (beacon_ies) {
 +		const struct element *elem;
 +		u8 dtim_count = 0;
 +
 +		ieee80211_get_dtim(beacon_ies, &dtim_count,
 +				   &ifmgd->dtim_period);
 +
 +		ifmgd->have_beacon = true;
 +		assoc_data->timeout = jiffies;
 +		assoc_data->timeout_started = true;
 +
 +		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
 +			sdata->vif.bss_conf.sync_tsf = beacon_ies->tsf;
 +			sdata->vif.bss_conf.sync_device_ts =
 +				bss->device_ts_beacon;
 +			sdata->vif.bss_conf.sync_dtim_count = dtim_count;
 +		}
 +
 +		elem = cfg80211_find_ext_elem(WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION,
 +					      beacon_ies->data, beacon_ies->len);
 +		if (elem && elem->datalen >= 3)
 +			sdata->vif.bss_conf.profile_periodicity = elem->data[2];
 +		else
 +			sdata->vif.bss_conf.profile_periodicity = 0;
 +
 +		elem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,
 +					  beacon_ies->data, beacon_ies->len);
 +		if (elem && elem->datalen >= 11 &&
 +		    (elem->data[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
 +			sdata->vif.bss_conf.ema_ap = true;
 +		else
 +			sdata->vif.bss_conf.ema_ap = false;
 +	} else {
 +		assoc_data->timeout = jiffies;
 +		assoc_data->timeout_started = true;
++=======
++>>>>>>> 1845c1d4a455 (wifi: mac80211: mlme: refactor assoc link setup)
  	}
  	rcu_read_unlock();
  
  	run_again(sdata, assoc_data->timeout);
  
- 	if (bss->corrupt_data) {
- 		char *corrupt_type = "data";
- 		if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_BEACON) {
- 			if (bss->corrupt_data &
- 					IEEE80211_BSS_CORRUPT_PROBE_RESP)
- 				corrupt_type = "beacon and probe response";
- 			else
- 				corrupt_type = "beacon";
- 		} else if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP)
- 			corrupt_type = "probe response";
- 		sdata_info(sdata, "associating with AP with corrupt %s\n",
- 			   corrupt_type);
- 	}
- 
  	return 0;
   err_clear:
 -	eth_zero_addr(sdata->deflink.u.mgd.bssid);
 -	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
 -					  BSS_CHANGED_BSSID);
 +	eth_zero_addr(ifmgd->bssid);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
  	ifmgd->assoc_data = NULL;
   err_free:
  	kfree(assoc_data);
* Unmerged path net/mac80211/mlme.c
