ipv6: Add custom multipath hash policy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ido Schimmel <idosch@OSS.NVIDIA.COM>
commit 73c2c5cbb15a8a82d5bea52594b0beb038963bcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/73c2c5cb.failed

Add a new multipath hash policy where the packet fields used for hash
calculation are determined by user space via the
fib_multipath_hash_fields sysctl that was introduced in the previous
patch.

The current set of available packet fields includes both outer and inner
fields, which requires two invocations of the flow dissector. Avoid
unnecessary dissection of the outer or inner flows by skipping
dissection if none of the outer or inner fields are required.

In accordance with the existing policies, when an skb is not available,
packet fields are extracted from the provided flow key. In which case,
only outer fields are considered.

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 73c2c5cbb15a8a82d5bea52594b0beb038963bcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/ip-sysctl.txt
#	net/ipv6/sysctl_net_ipv6.c
diff --cc Documentation/networking/ip-sysctl.txt
index e84d1a075b75,a5c250044500..000000000000
--- a/Documentation/networking/ip-sysctl.txt
+++ b/Documentation/networking/ip-sysctl.txt
@@@ -1412,11 -1764,43 +1412,47 @@@ flowlabel_reflect - BOOLEA
  
  fib_multipath_hash_policy - INTEGER
  	Controls which hash policy to use for multipath routes.
 -
  	Default: 0 (Layer 3)
 -
  	Possible values:
++<<<<<<< HEAD:Documentation/networking/ip-sysctl.txt
 +	0 - Layer 3 (source and destination addresses plus flow label)
 +	1 - Layer 4 (standard 5-tuple)
 +	2 - Layer 3 or inner Layer 3 if present
++=======
+ 
+ 	- 0 - Layer 3 (source and destination addresses plus flow label)
+ 	- 1 - Layer 4 (standard 5-tuple)
+ 	- 2 - Layer 3 or inner Layer 3 if present
+ 	- 3 - Custom multipath hash. Fields used for multipath hash calculation
+ 	  are determined by fib_multipath_hash_fields sysctl
+ 
+ fib_multipath_hash_fields - UNSIGNED INTEGER
+ 	When fib_multipath_hash_policy is set to 3 (custom multipath hash), the
+ 	fields used for multipath hash calculation are determined by this
+ 	sysctl.
+ 
+ 	This value is a bitmask which enables various fields for multipath hash
+ 	calculation.
+ 
+ 	Possible fields are:
+ 
+ 	====== ============================
+ 	0x0001 Source IP address
+ 	0x0002 Destination IP address
+ 	0x0004 IP protocol
+ 	0x0008 Flow Label
+ 	0x0010 Source port
+ 	0x0020 Destination port
+ 	0x0040 Inner source IP address
+ 	0x0080 Inner destination IP address
+ 	0x0100 Inner IP protocol
+ 	0x0200 Inner Flow Label
+ 	0x0400 Inner source port
+ 	0x0800 Inner destination port
+ 	====== ============================
+ 
+ 	Default: 0x0007 (source IP, destination IP and IP protocol)
++>>>>>>> 73c2c5cbb15a (ipv6: Add custom multipath hash policy):Documentation/networking/ip-sysctl.rst
  
  anycast_src_echo_reply - BOOLEAN
  	Controls the use of anycast addresses as source addresses for ICMPv6
diff --cc net/ipv6/sysctl_net_ipv6.c
index de15142a40ef,160bea5db973..000000000000
--- a/net/ipv6/sysctl_net_ipv6.c
+++ b/net/ipv6/sysctl_net_ipv6.c
@@@ -21,12 -22,15 +21,18 @@@
  #include <net/calipso.h>
  #endif
  
++<<<<<<< HEAD
 +static int auto_flowlabels_min;
++=======
+ static int two = 2;
+ static int three = 3;
+ static int flowlabel_reflect_max = 0x7;
++>>>>>>> 73c2c5cbb15a (ipv6: Add custom multipath hash policy)
  static int auto_flowlabels_max = IP6_AUTO_FLOW_LABEL_MAX;
 -static u32 rt6_multipath_hash_fields_all_mask =
 -	FIB_MULTIPATH_HASH_FIELD_ALL_MASK;
  
  static int proc_rt6_multipath_hash_policy(struct ctl_table *table, int write,
 -					  void *buffer, size_t *lenp, loff_t *ppos)
 +					  void __user *buffer, size_t *lenp,
 +					  loff_t *ppos)
  {
  	struct net *net;
  	int ret;
@@@ -148,7 -153,16 +154,20 @@@ static struct ctl_table ipv6_table_temp
  		.mode		= 0644,
  		.proc_handler   = proc_rt6_multipath_hash_policy,
  		.extra1		= SYSCTL_ZERO,
++<<<<<<< HEAD
 +		.extra2		= SYSCTL_ONE,
++=======
+ 		.extra2		= &three,
+ 	},
+ 	{
+ 		.procname	= "fib_multipath_hash_fields",
+ 		.data		= &init_net.ipv6.sysctl.multipath_hash_fields,
+ 		.maxlen		= sizeof(u32),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_douintvec_minmax,
+ 		.extra1		= SYSCTL_ONE,
+ 		.extra2		= &rt6_multipath_hash_fields_all_mask,
++>>>>>>> 73c2c5cbb15a (ipv6: Add custom multipath hash policy)
  	},
  	{
  		.procname	= "seg6_flowlabel",
* Unmerged path Documentation/networking/ip-sysctl.txt
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index c1e0d32e62c4..0aa9e43142f5 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -2025,6 +2025,125 @@ static void ip6_multipath_l3_keys(const struct sk_buff *skb,
 	}
 }
 
+static u32 rt6_multipath_custom_hash_outer(const struct net *net,
+					   const struct sk_buff *skb,
+					   bool *p_has_inner)
+{
+	u32 hash_fields = ip6_multipath_hash_fields(net);
+	struct flow_keys keys, hash_keys;
+
+	if (!(hash_fields & FIB_MULTIPATH_HASH_FIELD_OUTER_MASK))
+		return 0;
+
+	memset(&hash_keys, 0, sizeof(hash_keys));
+	skb_flow_dissect_flow_keys(skb, &keys, FLOW_DISSECTOR_F_STOP_AT_ENCAP);
+
+	hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_IP)
+		hash_keys.addrs.v6addrs.src = keys.addrs.v6addrs.src;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_IP)
+		hash_keys.addrs.v6addrs.dst = keys.addrs.v6addrs.dst;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_IP_PROTO)
+		hash_keys.basic.ip_proto = keys.basic.ip_proto;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_FLOWLABEL)
+		hash_keys.tags.flow_label = keys.tags.flow_label;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_PORT)
+		hash_keys.ports.src = keys.ports.src;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_PORT)
+		hash_keys.ports.dst = keys.ports.dst;
+
+	*p_has_inner = !!(keys.control.flags & FLOW_DIS_ENCAPSULATION);
+	return flow_hash_from_keys(&hash_keys);
+}
+
+static u32 rt6_multipath_custom_hash_inner(const struct net *net,
+					   const struct sk_buff *skb,
+					   bool has_inner)
+{
+	u32 hash_fields = ip6_multipath_hash_fields(net);
+	struct flow_keys keys, hash_keys;
+
+	/* We assume the packet carries an encapsulation, but if none was
+	 * encountered during dissection of the outer flow, then there is no
+	 * point in calling the flow dissector again.
+	 */
+	if (!has_inner)
+		return 0;
+
+	if (!(hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_MASK))
+		return 0;
+
+	memset(&hash_keys, 0, sizeof(hash_keys));
+	skb_flow_dissect_flow_keys(skb, &keys, 0);
+
+	if (!(keys.control.flags & FLOW_DIS_ENCAPSULATION))
+		return 0;
+
+	if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
+		hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+		if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP)
+			hash_keys.addrs.v4addrs.src = keys.addrs.v4addrs.src;
+		if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP)
+			hash_keys.addrs.v4addrs.dst = keys.addrs.v4addrs.dst;
+	} else if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {
+		hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+		if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP)
+			hash_keys.addrs.v6addrs.src = keys.addrs.v6addrs.src;
+		if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP)
+			hash_keys.addrs.v6addrs.dst = keys.addrs.v6addrs.dst;
+		if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_FLOWLABEL)
+			hash_keys.tags.flow_label = keys.tags.flow_label;
+	}
+
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_IP_PROTO)
+		hash_keys.basic.ip_proto = keys.basic.ip_proto;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_PORT)
+		hash_keys.ports.src = keys.ports.src;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_PORT)
+		hash_keys.ports.dst = keys.ports.dst;
+
+	return flow_hash_from_keys(&hash_keys);
+}
+
+static u32 rt6_multipath_custom_hash_skb(const struct net *net,
+					 const struct sk_buff *skb)
+{
+	u32 mhash, mhash_inner;
+	bool has_inner = true;
+
+	mhash = rt6_multipath_custom_hash_outer(net, skb, &has_inner);
+	mhash_inner = rt6_multipath_custom_hash_inner(net, skb, has_inner);
+
+	return jhash_2words(mhash, mhash_inner, 0);
+}
+
+static u32 rt6_multipath_custom_hash_fl6(const struct net *net,
+					 const struct flowi6 *fl6)
+{
+	u32 hash_fields = ip6_multipath_hash_fields(net);
+	struct flow_keys hash_keys;
+
+	if (!(hash_fields & FIB_MULTIPATH_HASH_FIELD_OUTER_MASK))
+		return 0;
+
+	memset(&hash_keys, 0, sizeof(hash_keys));
+	hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_IP)
+		hash_keys.addrs.v6addrs.src = fl6->saddr;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_IP)
+		hash_keys.addrs.v6addrs.dst = fl6->daddr;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_IP_PROTO)
+		hash_keys.basic.ip_proto = fl6->flowi6_proto;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_FLOWLABEL)
+		hash_keys.tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_PORT)
+		hash_keys.ports.src = fl6->fl6_sport;
+	if (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_PORT)
+		hash_keys.ports.dst = fl6->fl6_dport;
+
+	return flow_hash_from_keys(&hash_keys);
+}
+
 /* if skb is set it will be used and fl6 can be NULL */
 u32 rt6_multipath_hash(const struct net *net, const struct flowi6 *fl6,
 		       const struct sk_buff *skb, struct flow_keys *flkeys)
@@ -2115,6 +2234,12 @@ u32 rt6_multipath_hash(const struct net *net, const struct flowi6 *fl6,
 		}
 		mhash = flow_hash_from_keys(&hash_keys);
 		break;
+	case 3:
+		if (skb)
+			mhash = rt6_multipath_custom_hash_skb(net, skb);
+		else
+			mhash = rt6_multipath_custom_hash_fl6(net, fl6);
+		break;
 	}
 
 	return mhash >> 1;
* Unmerged path net/ipv6/sysctl_net_ipv6.c
