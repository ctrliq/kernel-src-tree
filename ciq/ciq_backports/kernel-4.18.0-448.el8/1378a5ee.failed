mm: store compound_nr as well as compound_order

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Matthew Wilcox (Oracle) <willy@infradead.org>
commit 1378a5ee451a5e87d0d8dd6356a0b7844db231f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1378a5ee.failed

Patch series "THP prep patches".

These are some generic cleanups and improvements, which I would like
merged into mmotm soon.  The first one should be a performance improvement
for all users of compound pages, and the others are aimed at getting code
to compile away when CONFIG_TRANSPARENT_HUGEPAGE is disabled (ie small
systems).  Also better documented / less confusing than the current prefix
mixture of compound, hpage and thp.

This patch (of 7):

This removes a few instructions from functions which need to know how many
pages are in a compound page.  The storage used is either page->mapping on
64-bit or page->index on 32-bit.  Both of these are fine to overlay on
tail pages.

	Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: William Kucharski <william.kucharski@oracle.com>
	Reviewed-by: Zi Yan <ziy@nvidia.com>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
Link: http://lkml.kernel.org/r/20200629151959.15779-1-willy@infradead.org
Link: http://lkml.kernel.org/r/20200629151959.15779-2-willy@infradead.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1378a5ee451a5e87d0d8dd6356a0b7844db231f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm_types.h
diff --cc include/linux/mm_types.h
index 5c430882072e,496c3ff97cce..000000000000
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@@ -146,12 -134,7 +146,16 @@@ struct page 
  			unsigned char compound_dtor;
  			unsigned char compound_order;
  			atomic_t compound_mapcount;
++<<<<<<< HEAD
 +			/*
 +			 * mapcount_seqcount is serialized by the
 +			 * PG_locked bit spinlock from the first tail
 +			 * page.
 +			 */
 +			RH_KABI_EXTEND(unsigned int mapcount_seqcount)
++=======
+ 			unsigned int compound_nr; /* 1 << compound_order */
++>>>>>>> 1378a5ee451a (mm: store compound_nr as well as compound_order)
  		};
  		struct {	/* Second tail page of compound page */
  			unsigned long _compound_pad_1;	/* compound_head */
diff --git a/include/linux/mm.h b/include/linux/mm.h
index e3b1a16638a0..94101f809ef2 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -835,12 +835,15 @@ static inline int compound_pincount(struct page *page)
 static inline void set_compound_order(struct page *page, unsigned int order)
 {
 	page[1].compound_order = order;
+	page[1].compound_nr = 1U << order;
 }
 
 /* Returns the number of pages in this potentially compound page. */
 static inline unsigned long compound_nr(struct page *page)
 {
-	return 1UL << compound_order(page);
+	if (!PageHead(page))
+		return 1;
+	return page[1].compound_nr;
 }
 
 /* Returns the number of bytes in this potentially compound page. */
* Unmerged path include/linux/mm_types.h
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 1f4a77a1aaaf..5b534e459d3f 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -676,8 +676,6 @@ void prep_compound_page(struct page *page, unsigned int order)
 	int i;
 	int nr_pages = 1 << order;
 
-	set_compound_page_dtor(page, COMPOUND_PAGE_DTOR);
-	set_compound_order(page, order);
 	__SetPageHead(page);
 	for (i = 1; i < nr_pages; i++) {
 		struct page *p = page + i;
@@ -685,6 +683,9 @@ void prep_compound_page(struct page *page, unsigned int order)
 		p->mapping = TAIL_MAPPING;
 		set_compound_head(p, page);
 	}
+
+	set_compound_page_dtor(page, COMPOUND_PAGE_DTOR);
+	set_compound_order(page, order);
 	atomic_set(compound_mapcount_ptr(page), -1);
 	if (hpage_pincount_available(page))
 		atomic_set(compound_pincount_ptr(page), 0);
