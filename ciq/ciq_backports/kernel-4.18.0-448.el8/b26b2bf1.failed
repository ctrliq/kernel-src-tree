xfs: rename struct xfs_eofblocks to xfs_icwalk

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit b26b2bf14f823e9597118c01993aeba9aeb9a701
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b26b2bf1.failed

The xfs_eofblocks structure is no longer well-named -- nowadays it
provides optional filtering criteria to any walk of the incore inode
cache.  Only one of the cache walk goals has anything to do with
clearing of speculative post-EOF preallocations, so change the name to
be more appropriate.

	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit b26b2bf14f823e9597118c01993aeba9aeb9a701)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
#	fs/xfs/xfs_icache.c
#	fs/xfs/xfs_icache.h
#	fs/xfs/xfs_ioctl.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_file.c
index 50a5bdf7fede,9fd5a82a814c..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -776,8 -779,8 +776,13 @@@ write_retry
  		xfs_flush_inodes(ip->i_mount);
  
  		xfs_iunlock(ip, iolock);
++<<<<<<< HEAD
 +		eofb.eof_flags = XFS_EOF_FLAGS_SYNC;
 +		xfs_blockgc_free_space(ip->i_mount, &eofb);
++=======
+ 		icw.icw_flags = XFS_ICWALK_FLAG_SYNC;
+ 		xfs_blockgc_free_space(ip->i_mount, &icw);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		goto write_retry;
  	}
  
diff --cc fs/xfs/xfs_icache.c
index bcf460a4fea6,4e4682879bbd..000000000000
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@@ -55,13 -56,13 +55,18 @@@ xfs_icwalk_tag(enum xfs_icwalk_goal goa
  }
  
  static int xfs_icwalk(struct xfs_mount *mp,
- 		enum xfs_icwalk_goal goal, struct xfs_eofblocks *eofb);
+ 		enum xfs_icwalk_goal goal, struct xfs_icwalk *icw);
  static int xfs_icwalk_ag(struct xfs_perag *pag,
- 		enum xfs_icwalk_goal goal, struct xfs_eofblocks *eofb);
+ 		enum xfs_icwalk_goal goal, struct xfs_icwalk *icw);
  
  /*
++<<<<<<< HEAD
 + * Private inode cache walk flags for struct xfs_eofblocks.  Must not coincide
 + * with XFS_EOF_FLAGS_*.
++=======
+  * Private inode cache walk flags for struct xfs_icwalk.  Must not
+  * coincide with XFS_ICWALK_FLAGS_VALID.
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
   */
  #define XFS_ICWALK_FLAG_DROP_UDQUOT	(1U << 31)
  #define XFS_ICWALK_FLAG_DROP_GDQUOT	(1U << 30)
@@@ -916,8 -914,9 +921,14 @@@ xfs_dqrele_all_inodes
   * Return true if we grabbed it, false otherwise.
   */
  static bool
++<<<<<<< HEAD
 +xfs_reclaim_inode_grab(
 +	struct xfs_inode	*ip)
++=======
+ xfs_reclaim_igrab(
+ 	struct xfs_inode	*ip,
+ 	struct xfs_icwalk	*icw)
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  {
  	ASSERT(rcu_read_lock_held());
  
@@@ -928,6 -927,14 +939,17 @@@
  		spin_unlock(&ip->i_flags_lock);
  		return false;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/* Don't reclaim a sick inode unless the caller asked for it. */
+ 	if (ip->i_sick &&
+ 	    (!icw || !(icw->icw_flags & XFS_ICWALK_FLAG_RECLAIM_SICK))) {
+ 		spin_unlock(&ip->i_flags_lock);
+ 		return false;
+ 	}
+ 
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	__xfs_iflags_set(ip, XFS_IRECLAIM);
  	spin_unlock(&ip->i_flags_lock);
  	return true;
@@@ -1122,11 -1049,16 +1144,24 @@@ voi
  xfs_reclaim_inodes(
  	struct xfs_mount	*mp)
  {
++<<<<<<< HEAD
 +	int		nr_to_scan = INT_MAX;
 +
 +	while (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {
 +		xfs_ail_push_all_sync(mp->m_ail);
 +		xfs_reclaim_inodes_ag(mp, &nr_to_scan);
++=======
+ 	struct xfs_icwalk	icw = {
+ 		.icw_flags	= 0,
+ 	};
+ 
+ 	if (xfs_want_reclaim_sick(mp))
+ 		icw.icw_flags |= XFS_ICWALK_FLAG_RECLAIM_SICK;
+ 
+ 	while (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {
+ 		xfs_ail_push_all_sync(mp->m_ail);
+ 		xfs_icwalk(mp, XFS_ICWALK_RECLAIM, &icw);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	}
  }
  
@@@ -1142,11 -1074,19 +1177,26 @@@ xfs_reclaim_inodes_nr
  	struct xfs_mount	*mp,
  	int			nr_to_scan)
  {
++<<<<<<< HEAD
++=======
+ 	struct xfs_icwalk	icw = {
+ 		.icw_flags	= XFS_ICWALK_FLAG_SCAN_LIMIT,
+ 		.icw_scan_limit	= nr_to_scan,
+ 	};
+ 
+ 	if (xfs_want_reclaim_sick(mp))
+ 		icw.icw_flags |= XFS_ICWALK_FLAG_RECLAIM_SICK;
+ 
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	/* kick background reclaimer and push the AIL */
  	xfs_reclaim_work_queue(mp);
  	xfs_ail_push_all(mp->m_ail);
  
++<<<<<<< HEAD
 +	xfs_reclaim_inodes_ag(mp, &nr_to_scan);
++=======
+ 	xfs_icwalk(mp, XFS_ICWALK_RECLAIM, &icw);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	return 0;
  }
  
@@@ -1171,20 -1111,20 +1221,33 @@@ xfs_reclaim_inodes_count
  }
  
  STATIC bool
- xfs_inode_match_id(
+ xfs_icwalk_match_id(
  	struct xfs_inode	*ip,
- 	struct xfs_eofblocks	*eofb)
+ 	struct xfs_icwalk	*icw)
  {
++<<<<<<< HEAD
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&
 +	    !uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))
 +		return false;
 +
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&
 +	    !gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))
 +		return false;
 +
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&
 +	    ip->i_projid != eofb->eof_prid)
++=======
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_UID) &&
+ 	    !uid_eq(VFS_I(ip)->i_uid, icw->icw_uid))
+ 		return false;
+ 
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_GID) &&
+ 	    !gid_eq(VFS_I(ip)->i_gid, icw->icw_gid))
+ 		return false;
+ 
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_PRID) &&
+ 	    ip->i_projid != icw->icw_prid)
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		return false;
  
  	return true;
@@@ -1195,20 -1135,20 +1258,33 @@@
   * criteria match. This is for global/internal scans only.
   */
  STATIC bool
- xfs_inode_match_id_union(
+ xfs_icwalk_match_id_union(
  	struct xfs_inode	*ip,
- 	struct xfs_eofblocks	*eofb)
+ 	struct xfs_icwalk	*icw)
  {
++<<<<<<< HEAD
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&
 +	    uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))
 +		return true;
 +
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&
 +	    gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))
 +		return true;
 +
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&
 +	    ip->i_projid == eofb->eof_prid)
++=======
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_UID) &&
+ 	    uid_eq(VFS_I(ip)->i_uid, icw->icw_uid))
+ 		return true;
+ 
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_GID) &&
+ 	    gid_eq(VFS_I(ip)->i_gid, icw->icw_gid))
+ 		return true;
+ 
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_PRID) &&
+ 	    ip->i_projid == icw->icw_prid)
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		return true;
  
  	return false;
@@@ -1226,19 -1166,19 +1302,29 @@@ xfs_icwalk_match
  {
  	bool			match;
  
- 	if (!eofb)
+ 	if (!icw)
  		return true;
  
++<<<<<<< HEAD
 +	if (eofb->eof_flags & XFS_EOF_FLAGS_UNION)
 +		match = xfs_inode_match_id_union(ip, eofb);
++=======
+ 	if (icw->icw_flags & XFS_ICWALK_FLAG_UNION)
+ 		match = xfs_icwalk_match_id_union(ip, icw);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	else
- 		match = xfs_inode_match_id(ip, eofb);
+ 		match = xfs_icwalk_match_id(ip, icw);
  	if (!match)
  		return false;
  
  	/* skip the inode if the file size is too small */
++<<<<<<< HEAD
 +	if ((eofb->eof_flags & XFS_EOF_FLAGS_MINFILESIZE) &&
 +	    XFS_ISIZE(ip) < eofb->eof_min_file_size)
++=======
+ 	if ((icw->icw_flags & XFS_ICWALK_FLAG_MINFILESIZE) &&
+ 	    XFS_ISIZE(ip) < icw->icw_min_file_size)
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		return false;
  
  	return true;
@@@ -1270,7 -1209,7 +1356,11 @@@ xfs_inode_free_eofblocks
  {
  	bool			wait;
  
++<<<<<<< HEAD
 +	wait = eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC);
++=======
+ 	wait = icw && (icw->icw_flags & XFS_ICWALK_FLAG_SYNC);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  
  	if (!xfs_iflags_test(ip, XFS_IEOFBLOCKS))
  		return 0;
@@@ -1433,7 -1372,7 +1523,11 @@@ xfs_inode_free_cowblocks
  	bool			wait;
  	int			ret = 0;
  
++<<<<<<< HEAD
 +	wait = eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC);
++=======
+ 	wait = icw && (icw->icw_flags & XFS_ICWALK_FLAG_SYNC);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  
  	if (!xfs_iflags_test(ip, XFS_ICOWBLOCKS))
  		return 0;
@@@ -1624,9 -1563,9 +1718,9 @@@ xfs_blockgc_free_dquots
  	struct xfs_dquot	*udqp,
  	struct xfs_dquot	*gdqp,
  	struct xfs_dquot	*pdqp,
 -	unsigned int		iwalk_flags)
 +	unsigned int		eof_flags)
  {
- 	struct xfs_eofblocks	eofb = {0};
+ 	struct xfs_icwalk	icw = {0};
  	bool			do_work = false;
  
  	if (!udqp && !gdqp && !pdqp)
@@@ -1636,23 -1575,23 +1730,41 @@@
  	 * Run a scan to free blocks using the union filter to cover all
  	 * applicable quotas in a single scan.
  	 */
++<<<<<<< HEAD
 +	eofb.eof_flags = XFS_EOF_FLAGS_UNION | eof_flags;
 +
 +	if (XFS_IS_UQUOTA_ENFORCED(mp) && udqp && xfs_dquot_lowsp(udqp)) {
 +		eofb.eof_uid = make_kuid(mp->m_super->s_user_ns, udqp->q_id);
 +		eofb.eof_flags |= XFS_EOF_FLAGS_UID;
++=======
+ 	icw.icw_flags = XFS_ICWALK_FLAG_UNION | iwalk_flags;
+ 
+ 	if (XFS_IS_UQUOTA_ENFORCED(mp) && udqp && xfs_dquot_lowsp(udqp)) {
+ 		icw.icw_uid = make_kuid(mp->m_super->s_user_ns, udqp->q_id);
+ 		icw.icw_flags |= XFS_ICWALK_FLAG_UID;
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		do_work = true;
  	}
  
  	if (XFS_IS_UQUOTA_ENFORCED(mp) && gdqp && xfs_dquot_lowsp(gdqp)) {
++<<<<<<< HEAD
 +		eofb.eof_gid = make_kgid(mp->m_super->s_user_ns, gdqp->q_id);
 +		eofb.eof_flags |= XFS_EOF_FLAGS_GID;
++=======
+ 		icw.icw_gid = make_kgid(mp->m_super->s_user_ns, gdqp->q_id);
+ 		icw.icw_flags |= XFS_ICWALK_FLAG_GID;
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		do_work = true;
  	}
  
  	if (XFS_IS_PQUOTA_ENFORCED(mp) && pdqp && xfs_dquot_lowsp(pdqp)) {
++<<<<<<< HEAD
 +		eofb.eof_prid = pdqp->q_id;
 +		eofb.eof_flags |= XFS_EOF_FLAGS_PRID;
++=======
+ 		icw.icw_prid = pdqp->q_id;
+ 		icw.icw_flags |= XFS_ICWALK_FLAG_PRID;
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		do_work = true;
  	}
  
@@@ -1683,13 -1631,16 +1795,23 @@@ xfs_blockgc_free_quota
  static inline bool
  xfs_icwalk_igrab(
  	enum xfs_icwalk_goal	goal,
++<<<<<<< HEAD
 +	struct xfs_inode	*ip)
++=======
+ 	struct xfs_inode	*ip,
+ 	struct xfs_icwalk	*icw)
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  {
  	switch (goal) {
  	case XFS_ICWALK_DQRELE:
  		return xfs_dqrele_igrab(ip);
  	case XFS_ICWALK_BLOCKGC:
  		return xfs_blockgc_igrab(ip);
++<<<<<<< HEAD
++=======
+ 	case XFS_ICWALK_RECLAIM:
+ 		return xfs_reclaim_igrab(ip, icw);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	default:
  		return false;
  	}
@@@ -1703,17 -1654,21 +1825,22 @@@ static inline in
  xfs_icwalk_process_inode(
  	enum xfs_icwalk_goal	goal,
  	struct xfs_inode	*ip,
++<<<<<<< HEAD
 +	struct xfs_eofblocks	*eofb)
++=======
+ 	struct xfs_perag	*pag,
+ 	struct xfs_icwalk	*icw)
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  {
  	int			error = 0;
  
  	switch (goal) {
  	case XFS_ICWALK_DQRELE:
- 		xfs_dqrele_inode(ip, eofb);
+ 		xfs_dqrele_inode(ip, icw);
  		break;
  	case XFS_ICWALK_BLOCKGC:
- 		error = xfs_blockgc_scan_inode(ip, eofb);
+ 		error = xfs_blockgc_scan_inode(ip, icw);
  		break;
 -	case XFS_ICWALK_RECLAIM:
 -		xfs_reclaim_inode(ip, pag);
 -		break;
  	}
  	return error;
  }
@@@ -1770,7 -1729,7 +1897,11 @@@ restart
  		for (i = 0; i < nr_found; i++) {
  			struct xfs_inode *ip = batch[i];
  
++<<<<<<< HEAD
 +			if (done || !xfs_icwalk_igrab(goal, ip))
++=======
+ 			if (done || !xfs_icwalk_igrab(goal, ip, icw))
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  				batch[i] = NULL;
  
  			/*
@@@ -1798,7 -1757,8 +1929,12 @@@
  		for (i = 0; i < nr_found; i++) {
  			if (!batch[i])
  				continue;
++<<<<<<< HEAD
 +			error = xfs_icwalk_process_inode(goal, batch[i], eofb);
++=======
+ 			error = xfs_icwalk_process_inode(goal, batch[i], pag,
+ 					icw);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  			if (error == -EAGAIN) {
  				skipped++;
  				continue;
@@@ -1813,8 -1773,19 +1949,16 @@@
  
  		cond_resched();
  
++<<<<<<< HEAD
++=======
+ 		if (icw && (icw->icw_flags & XFS_ICWALK_FLAG_SCAN_LIMIT)) {
+ 			icw->icw_scan_limit -= XFS_LOOKUP_BATCH;
+ 			if (icw->icw_scan_limit <= 0)
+ 				break;
+ 		}
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  	} while (nr_found && !done);
  
 -	if (goal == XFS_ICWALK_RECLAIM) {
 -		if (done)
 -			first_index = 0;
 -		WRITE_ONCE(pag->pag_ici_reclaim_cursor, first_index);
 -	}
 -
  	if (skipped) {
  		delay(1);
  		goto restart;
diff --cc fs/xfs/xfs_icache.h
index 7ad0509d072c,00dc98a92835..000000000000
--- a/fs/xfs/xfs_icache.h
+++ b/fs/xfs/xfs_icache.h
@@@ -9,14 -9,28 +9,24 @@@
  struct xfs_mount;
  struct xfs_perag;
  
++<<<<<<< HEAD
 +struct xfs_eofblocks {
 +	__u32		eof_flags;
 +	kuid_t		eof_uid;
 +	kgid_t		eof_gid;
 +	prid_t		eof_prid;
 +	__u64		eof_min_file_size;
++=======
+ struct xfs_icwalk {
+ 	__u32		icw_flags;
+ 	kuid_t		icw_uid;
+ 	kgid_t		icw_gid;
+ 	prid_t		icw_prid;
+ 	__u64		icw_min_file_size;
+ 	int		icw_scan_limit;
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  };
  
 -/* Flags that reflect xfs_fs_eofblocks functionality. */
 -#define XFS_ICWALK_FLAG_SYNC		(1U << 0) /* sync/wait mode scan */
 -#define XFS_ICWALK_FLAG_UID		(1U << 1) /* filter by uid */
 -#define XFS_ICWALK_FLAG_GID		(1U << 2) /* filter by gid */
 -#define XFS_ICWALK_FLAG_PRID		(1U << 3) /* filter by project id */
 -#define XFS_ICWALK_FLAG_MINFILESIZE	(1U << 4) /* filter by min file size */
 -
 -#define XFS_ICWALK_FLAGS_VALID		(XFS_ICWALK_FLAG_SYNC | \
 -					 XFS_ICWALK_FLAG_UID | \
 -					 XFS_ICWALK_FLAG_GID | \
 -					 XFS_ICWALK_FLAG_PRID | \
 -					 XFS_ICWALK_FLAG_MINFILESIZE)
 -
  /*
   * Flags for xfs_iget()
   */
@@@ -42,9 -56,9 +52,15 @@@ void xfs_inode_mark_reclaimable(struct 
  
  int xfs_blockgc_free_dquots(struct xfs_mount *mp, struct xfs_dquot *udqp,
  		struct xfs_dquot *gdqp, struct xfs_dquot *pdqp,
++<<<<<<< HEAD
 +		unsigned int eof_flags);
 +int xfs_blockgc_free_quota(struct xfs_inode *ip, unsigned int eof_flags);
 +int xfs_blockgc_free_space(struct xfs_mount *mp, struct xfs_eofblocks *eofb);
++=======
+ 		unsigned int iwalk_flags);
+ int xfs_blockgc_free_quota(struct xfs_inode *ip, unsigned int iwalk_flags);
+ int xfs_blockgc_free_space(struct xfs_mount *mp, struct xfs_icwalk *icm);
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  
  void xfs_inode_set_eofblocks_tag(struct xfs_inode *ip);
  void xfs_inode_clear_eofblocks_tag(struct xfs_inode *ip);
diff --cc fs/xfs/xfs_ioctl.c
index 614ad024026b,0f6794333b01..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -2026,14 -1887,25 +2026,31 @@@ xfs_fs_eofblocks_from_user
  	    memchr_inv(src->pad64, 0, sizeof(src->pad64)))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	dst->eof_flags = src->eof_flags;
 +	dst->eof_prid = src->eof_prid;
 +	dst->eof_min_file_size = src->eof_min_file_size;
- 
- 	dst->eof_uid = INVALID_UID;
++=======
+ 	dst->icw_flags = 0;
+ 	if (src->eof_flags & XFS_EOF_FLAGS_SYNC)
+ 		dst->icw_flags |= XFS_ICWALK_FLAG_SYNC;
+ 	if (src->eof_flags & XFS_EOF_FLAGS_UID)
+ 		dst->icw_flags |= XFS_ICWALK_FLAG_UID;
+ 	if (src->eof_flags & XFS_EOF_FLAGS_GID)
+ 		dst->icw_flags |= XFS_ICWALK_FLAG_GID;
+ 	if (src->eof_flags & XFS_EOF_FLAGS_PRID)
+ 		dst->icw_flags |= XFS_ICWALK_FLAG_PRID;
+ 	if (src->eof_flags & XFS_EOF_FLAGS_MINFILESIZE)
+ 		dst->icw_flags |= XFS_ICWALK_FLAG_MINFILESIZE;
+ 
+ 	dst->icw_prid = src->eof_prid;
+ 	dst->icw_min_file_size = src->eof_min_file_size;
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
+ 
+ 	dst->icw_uid = INVALID_UID;
  	if (src->eof_flags & XFS_EOF_FLAGS_UID) {
- 		dst->eof_uid = make_kuid(current_user_ns(), src->eof_uid);
- 		if (!uid_valid(dst->eof_uid))
+ 		dst->icw_uid = make_kuid(current_user_ns(), src->eof_uid);
+ 		if (!uid_valid(dst->icw_uid))
  			return -EINVAL;
  	}
  
diff --cc fs/xfs/xfs_trace.h
index 03c6c91ee9a9,a10612155377..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -3900,31 -3901,33 +3900,42 @@@ DECLARE_EVENT_CLASS(xfs_icwalk_class
  	),
  	TP_fast_assign(
  		__entry->dev = mp->m_super->s_dev;
++<<<<<<< HEAD
 +		__entry->flags = eofb ? eofb->eof_flags : 0;
 +		__entry->uid = eofb ? from_kuid(mp->m_super->s_user_ns,
 +						eofb->eof_uid) : 0;
 +		__entry->gid = eofb ? from_kgid(mp->m_super->s_user_ns,
 +						eofb->eof_gid) : 0;
 +		__entry->prid = eofb ? eofb->eof_prid : 0;
 +		__entry->min_file_size = eofb ? eofb->eof_min_file_size : 0;
++=======
+ 		__entry->flags = icw ? icw->icw_flags : 0;
+ 		__entry->uid = icw ? from_kuid(mp->m_super->s_user_ns,
+ 						icw->icw_uid) : 0;
+ 		__entry->gid = icw ? from_kgid(mp->m_super->s_user_ns,
+ 						icw->icw_gid) : 0;
+ 		__entry->prid = icw ? icw->icw_prid : 0;
+ 		__entry->min_file_size = icw ? icw->icw_min_file_size : 0;
+ 		__entry->scan_limit = icw ? icw->icw_scan_limit : 0;
++>>>>>>> b26b2bf14f82 (xfs: rename struct xfs_eofblocks to xfs_icwalk)
  		__entry->caller_ip = caller_ip;
  	),
 -	TP_printk("dev %d:%d flags 0x%x uid %u gid %u prid %u minsize %llu scan_limit %d caller %pS",
 +	TP_printk("dev %d:%d flags 0x%x uid %u gid %u prid %u minsize %llu caller %pS",
  		  MAJOR(__entry->dev), MINOR(__entry->dev),
  		  __entry->flags,
  		  __entry->uid,
  		  __entry->gid,
  		  __entry->prid,
  		  __entry->min_file_size,
 -		  __entry->scan_limit,
  		  (char *)__entry->caller_ip)
  );
- #define DEFINE_EOFBLOCKS_EVENT(name)	\
- DEFINE_EVENT(xfs_eofblocks_class, name,	\
- 	TP_PROTO(struct xfs_mount *mp, struct xfs_eofblocks *eofb, \
+ #define DEFINE_ICWALK_EVENT(name)	\
+ DEFINE_EVENT(xfs_icwalk_class, name,	\
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_icwalk *icw, \
  		 unsigned long caller_ip), \
- 	TP_ARGS(mp, eofb, caller_ip))
- DEFINE_EOFBLOCKS_EVENT(xfs_ioc_free_eofblocks);
- DEFINE_EOFBLOCKS_EVENT(xfs_blockgc_free_space);
+ 	TP_ARGS(mp, icw, caller_ip))
+ DEFINE_ICWALK_EVENT(xfs_ioc_free_eofblocks);
+ DEFINE_ICWALK_EVENT(xfs_blockgc_free_space);
  
  #endif /* _TRACE_XFS_H */
  
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path fs/xfs/xfs_icache.c
* Unmerged path fs/xfs/xfs_icache.h
* Unmerged path fs/xfs/xfs_ioctl.c
* Unmerged path fs/xfs/xfs_trace.h
