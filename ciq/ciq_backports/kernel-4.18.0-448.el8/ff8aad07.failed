ASoC: cs35l41: Move cs35l41 fs errata into shared code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit ff8aad072e6388243fb0c76db4154d0883988384
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ff8aad07.failed

This sequence is required to setup firmware, and will
be needed for hda driver.

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
	Signed-off-by: Vitaly Rodionov <vitalyr@opensource.cirrus.com>
	Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20220509214703.4482-8-vitalyr@opensource.cirrus.com
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit ff8aad072e6388243fb0c76db4154d0883988384)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/cs35l41.h
#	sound/soc/codecs/cs35l41-lib.c
#	sound/soc/codecs/cs35l41.c
diff --cc include/sound/cs35l41.h
index 1f1e3c6c9be1,d0cfb41495b0..000000000000
--- a/include/sound/cs35l41.h
+++ b/include/sound/cs35l41.h
@@@ -27,8 -780,109 +27,109 @@@ struct cs35l41_platform_data 
  	int bst_ipk;
  	int bst_cap;
  	int dout_hiz;
 -	struct cs35l41_gpio_cfg gpio1;
 -	struct cs35l41_gpio_cfg gpio2;
 -	unsigned int spk_pos;
 -
 -	enum cs35l41_boost_type bst_type;
 +	struct cs35l41_irq_cfg irq_config1;
 +	struct cs35l41_irq_cfg irq_config2;
  };
  
++<<<<<<< HEAD
++=======
+ struct cs35l41_otp_packed_element_t {
+ 	u32 reg;
+ 	u8 shift;
+ 	u8 size;
+ };
+ 
+ struct cs35l41_otp_map_element_t {
+ 	u32 id;
+ 	u32 num_elements;
+ 	const struct cs35l41_otp_packed_element_t *map;
+ 	u32 bit_offset;
+ 	u32 word_offset;
+ };
+ 
+ enum cs35l41_cspl_mbox_status {
+ 	CSPL_MBOX_STS_RUNNING = 0,
+ 	CSPL_MBOX_STS_PAUSED = 1,
+ 	CSPL_MBOX_STS_RDY_FOR_REINIT = 2,
+ };
+ 
+ enum cs35l41_cspl_mbox_cmd {
+ 	CSPL_MBOX_CMD_NONE = 0,
+ 	CSPL_MBOX_CMD_PAUSE = 1,
+ 	CSPL_MBOX_CMD_RESUME = 2,
+ 	CSPL_MBOX_CMD_REINIT = 3,
+ 	CSPL_MBOX_CMD_STOP_PRE_REINIT = 4,
+ 	CSPL_MBOX_CMD_HIBERNATE = 5,
+ 	CSPL_MBOX_CMD_OUT_OF_HIBERNATE = 6,
+ 	CSPL_MBOX_CMD_UNKNOWN_CMD = -1,
+ 	CSPL_MBOX_CMD_INVALID_SEQUENCE = -2,
+ };
+ 
+ /*
+  * IRQs
+  */
+ #define CS35L41_IRQ(_irq, _name, _hand)		\
+ 	{					\
+ 		.irq = CS35L41_ ## _irq ## _IRQ,\
+ 		.name = _name,			\
+ 		.handler = _hand,		\
+ 	}
+ 
+ struct cs35l41_irq {
+ 	int irq;
+ 	const char *name;
+ 	irqreturn_t (*handler)(int irq, void *data);
+ };
+ 
+ #define CS35L41_REG_IRQ(_reg, _irq)					\
+ 	[CS35L41_ ## _irq ## _IRQ] = {					\
+ 		.reg_offset = (CS35L41_ ## _reg) - CS35L41_IRQ1_STATUS1,\
+ 		.mask = CS35L41_ ## _irq ## _MASK			\
+ 	}
+ 
+ /* (0x0000E010) CS35L41_IRQ1_STATUS1 */
+ #define CS35L41_BST_OVP_ERR_SHIFT		6
+ #define CS35L41_BST_OVP_ERR_MASK		BIT(CS35L41_BST_OVP_ERR_SHIFT)
+ #define CS35L41_BST_DCM_UVP_ERR_SHIFT		7
+ #define CS35L41_BST_DCM_UVP_ERR_MASK		BIT(CS35L41_BST_DCM_UVP_ERR_SHIFT)
+ #define CS35L41_BST_SHORT_ERR_SHIFT		8
+ #define CS35L41_BST_SHORT_ERR_MASK		BIT(CS35L41_BST_SHORT_ERR_SHIFT)
+ #define CS35L41_TEMP_WARN_SHIFT			15
+ #define CS35L41_TEMP_WARN_MASK			BIT(CS35L41_TEMP_WARN_SHIFT)
+ #define CS35L41_TEMP_ERR_SHIFT			17
+ #define CS35L41_TEMP_ERR_MASK			BIT(CS35L41_TEMP_ERR_SHIFT)
+ #define CS35L41_AMP_SHORT_ERR_SHIFT		31
+ #define CS35L41_AMP_SHORT_ERR_MASK		BIT(CS35L41_AMP_SHORT_ERR_SHIFT)
+ 
+ enum cs35l41_irq_list {
+ 	CS35L41_BST_OVP_ERR_IRQ,
+ 	CS35L41_BST_DCM_UVP_ERR_IRQ,
+ 	CS35L41_BST_SHORT_ERR_IRQ,
+ 	CS35L41_TEMP_WARN_IRQ,
+ 	CS35L41_TEMP_ERR_IRQ,
+ 	CS35L41_AMP_SHORT_ERR_IRQ,
+ 
+ 	CS35L41_NUM_IRQ
+ };
+ 
+ extern struct regmap_config cs35l41_regmap_i2c;
+ extern struct regmap_config cs35l41_regmap_spi;
+ 
+ int cs35l41_test_key_unlock(struct device *dev, struct regmap *regmap);
+ int cs35l41_test_key_lock(struct device *dev, struct regmap *regmap);
+ int cs35l41_otp_unpack(struct device *dev, struct regmap *regmap);
+ int cs35l41_register_errata_patch(struct device *dev, struct regmap *reg, unsigned int reg_revid);
+ int cs35l41_set_channels(struct device *dev, struct regmap *reg,
+ 			 unsigned int tx_num, unsigned int *tx_slot,
+ 			 unsigned int rx_num, unsigned int *rx_slot);
+ int cs35l41_gpio_config(struct regmap *regmap, struct cs35l41_hw_cfg *hw_cfg);
+ int cs35l41_set_cspl_mbox_cmd(struct device *dev, struct regmap *regmap,
+ 			      enum cs35l41_cspl_mbox_cmd cmd);
+ int cs35l41_write_fs_errata(struct device *dev, struct regmap *regmap);
+ int cs35l41_init_boost(struct device *dev, struct regmap *regmap,
+ 		       struct cs35l41_hw_cfg *hw_cfg);
+ bool cs35l41_safe_reset(struct regmap *regmap, enum cs35l41_boost_type b_type);
+ int cs35l41_global_enable(struct regmap *regmap, enum cs35l41_boost_type b_type, int enable);
+ 
++>>>>>>> ff8aad072e63 (ASoC: cs35l41: Move cs35l41 fs errata into shared code)
  #endif /* __CS35L41_H */
diff --cc sound/soc/codecs/cs35l41.c
index 25c67931882a,75527649bb14..000000000000
--- a/sound/soc/codecs/cs35l41.c
+++ b/sound/soc/codecs/cs35l41.c
@@@ -1185,59 -1093,70 +1185,113 @@@ static int cs35l41_handle_pdata(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct reg_sequence cs35l41_reva0_errata_patch[] = {
 +	{ 0x00000040,			 0x00005555 },
 +	{ 0x00000040,			 0x0000AAAA },
 +	{ 0x00003854,			 0x05180240 },
 +	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
 +	{ 0x00004310,			 0x00000000 },
 +	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
 +	{ CS35L41_OTP_TRIM_30,		 0x9091A1C8 },
 +	{ 0x00003014,			 0x0200EE0E },
 +	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
 +	{ 0x00000054,			 0x00000004 },
 +	{ CS35L41_IRQ1_DB3,		 0x00000000 },
 +	{ CS35L41_IRQ2_DB3,		 0x00000000 },
 +	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ 0x00000040,			 0x0000CCCC },
 +	{ 0x00000040,			 0x00003333 },
 +	{ CS35L41_PWR_CTRL2,		 0x00000000 },
 +	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
 +};
 +
 +static const struct reg_sequence cs35l41_revb0_errata_patch[] = {
 +	{ 0x00000040,			 0x00005555 },
 +	{ 0x00000040,			 0x0000AAAA },
 +	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
 +	{ 0x00004310,			 0x00000000 },
 +	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
 +	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
 +	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ 0x00000040,			 0x0000CCCC },
 +	{ 0x00000040,			 0x00003333 },
 +	{ CS35L41_PWR_CTRL2,		 0x00000000 },
 +	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
 +};
++=======
+ static int cs35l41_dsp_init(struct cs35l41_private *cs35l41)
+ {
+ 	struct wm_adsp *dsp;
+ 	int ret;
++>>>>>>> ff8aad072e63 (ASoC: cs35l41: Move cs35l41 fs errata into shared code)
 +
 +static const struct reg_sequence cs35l41_revb2_errata_patch[] = {
 +	{ 0x00000040,			 0x00005555 },
 +	{ 0x00000040,			 0x0000AAAA },
 +	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
 +	{ 0x00004310,			 0x00000000 },
 +	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
 +	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
 +	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ 0x00000040,			 0x0000CCCC },
 +	{ 0x00000040,			 0x00003333 },
 +	{ CS35L41_PWR_CTRL2,		 0x00000000 },
 +	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
 +};
  
 -	dsp = &cs35l41->dsp;
 -	dsp->part = "cs35l41";
 -	dsp->cs_dsp.num = 1;
 -	dsp->cs_dsp.type = WMFW_HALO;
 -	dsp->cs_dsp.rev = 0;
 -	dsp->fw = 9; /* 9 is WM_ADSP_FW_SPK_PROT in wm_adsp.c */
 -	dsp->toggle_preload = true;
 -	dsp->cs_dsp.dev = cs35l41->dev;
 -	dsp->cs_dsp.regmap = cs35l41->regmap;
 -	dsp->cs_dsp.base = CS35L41_DSP1_CTRL_BASE;
 -	dsp->cs_dsp.base_sysinfo = CS35L41_DSP1_SYS_ID;
 -	dsp->cs_dsp.mem = cs35l41_dsp1_regions;
 -	dsp->cs_dsp.num_mems = ARRAY_SIZE(cs35l41_dsp1_regions);
 -	dsp->cs_dsp.lock_regions = 0xFFFFFFFF;
 -
++<<<<<<< HEAD
 +int cs35l41_probe(struct cs35l41_private *cs35l41,
 +		  struct cs35l41_platform_data *pdata)
++=======
+ 	ret = cs35l41_write_fs_errata(cs35l41->dev, cs35l41->regmap);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = wm_halo_init(dsp);
+ 	if (ret) {
+ 		dev_err(cs35l41->dev, "wm_halo_init failed: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX5_SRC,
+ 			   CS35L41_INPUT_SRC_VPMON);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_VPMON failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX6_SRC,
+ 			   CS35L41_INPUT_SRC_CLASSH);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_CLASSH failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX7_SRC,
+ 			   CS35L41_INPUT_SRC_TEMPMON);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_TEMPMON failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX8_SRC,
+ 			   CS35L41_INPUT_SRC_RSVD);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_RSVD failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 
+ 	return 0;
+ 
+ err_dsp:
+ 	wm_adsp2_remove(dsp);
+ 
+ 	return ret;
+ }
+ 
+ int cs35l41_probe(struct cs35l41_private *cs35l41, const struct cs35l41_hw_cfg *hw_cfg)
++>>>>>>> ff8aad072e63 (ASoC: cs35l41: Move cs35l41 fs errata into shared code)
  {
  	u32 regid, reg_revid, i, mtl_revid, int_status, chipid_match;
  	int irq_pol = 0;
* Unmerged path sound/soc/codecs/cs35l41-lib.c
* Unmerged path include/sound/cs35l41.h
* Unmerged path sound/soc/codecs/cs35l41-lib.c
* Unmerged path sound/soc/codecs/cs35l41.c
