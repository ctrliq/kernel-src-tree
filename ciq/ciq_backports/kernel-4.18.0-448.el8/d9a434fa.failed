scsi: core: Fix warning in scsi_alloc_sgtables()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jason Yan <yanaijie@huawei.com>
commit d9a434fa0c12ed5f7afe1e9dd30003ab5d059b85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d9a434fa.failed

As explained in SG_IO howto[1]:

"If iovec_count is non-zero then 'dxfer_len' should be equal to the sum of
iov_len lengths. If not, the minimum of the two is the transfer length."

When iovec_count is non-zero and dxfer_len is zero, the sg_io() just
genarated a null bio, and finally caused a warning below. To fix it, skip
generating a bio for this request if dxfer_len is zero.

[1] https://tldp.org/HOWTO/SCSI-Generic-HOWTO/x198.html

WARNING: CPU: 2 PID: 3643 at drivers/scsi/scsi_lib.c:1032 scsi_alloc_sgtables+0xc7d/0xf70 drivers/scsi/scsi_lib.c:1032
Modules linked in:

CPU: 2 PID: 3643 Comm: syz-executor397 Not tainted
5.17.0-rc3-syzkaller-00316-gb81b1829e7e3 #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-204/01/2014
RIP: 0010:scsi_alloc_sgtables+0xc7d/0xf70 drivers/scsi/scsi_lib.c:1032
Code: e7 fc 31 ff 44 89 f6 e8 c1 4e e7 fc 45 85 f6 0f 84 1a f5 ff ff e8
93 4c e7 fc 83 c5 01 0f b7 ed e9 0f f5 ff ff e8 83 4c e7 fc <0f> 0b 41
   bc 0a 00 00 00 e9 2b fb ff ff 41 bc 09 00 00 00 e9 20 fb
RSP: 0018:ffffc90000d07558 EFLAGS: 00010293
RAX: 0000000000000000 RBX: ffff88801bfc96a0 RCX: 0000000000000000
RDX: ffff88801c876000 RSI: ffffffff849060bd RDI: 0000000000000003
RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
R10: ffffffff849055b9 R11: 0000000000000000 R12: ffff888012b8c000
R13: ffff88801bfc9580 R14: 0000000000000000 R15: ffff88801432c000
FS:  00007effdec8e700(0000) GS:ffff88802cc00000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007effdec6d718 CR3: 00000000206d6000 CR4: 0000000000150ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 scsi_setup_scsi_cmnd drivers/scsi/scsi_lib.c:1219 [inline]
 scsi_prepare_cmd drivers/scsi/scsi_lib.c:1614 [inline]
 scsi_queue_rq+0x283e/0x3630 drivers/scsi/scsi_lib.c:1730
 blk_mq_dispatch_rq_list+0x6ea/0x22e0 block/blk-mq.c:1851
 __blk_mq_sched_dispatch_requests+0x20b/0x410 block/blk-mq-sched.c:299
 blk_mq_sched_dispatch_requests+0xfb/0x180 block/blk-mq-sched.c:332
 __blk_mq_run_hw_queue+0xf9/0x350 block/blk-mq.c:1968
 __blk_mq_delay_run_hw_queue+0x5b6/0x6c0 block/blk-mq.c:2045
 blk_mq_run_hw_queue+0x30f/0x480 block/blk-mq.c:2096
 blk_mq_sched_insert_request+0x340/0x440 block/blk-mq-sched.c:451
 blk_execute_rq+0xcc/0x340 block/blk-mq.c:1231
 sg_io+0x67c/0x1210 drivers/scsi/scsi_ioctl.c:485
 scsi_ioctl_sg_io drivers/scsi/scsi_ioctl.c:866 [inline]
 scsi_ioctl+0xa66/0x1560 drivers/scsi/scsi_ioctl.c:921
 sd_ioctl+0x199/0x2a0 drivers/scsi/sd.c:1576
 blkdev_ioctl+0x37a/0x800 block/ioctl.c:588
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:874 [inline]
 __se_sys_ioctl fs/ioctl.c:860 [inline]
 __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:860
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x44/0xae
RIP: 0033:0x7effdecdc5d9
Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 81 14 00 00 90 48 89 f8 48 89
f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01
f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007effdec8e2f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007effded664c0 RCX: 00007effdecdc5d9
RDX: 0000000020002300 RSI: 0000000000002285 RDI: 0000000000000004
RBP: 00007effded34034 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000003
R13: 00007effded34054 R14: 2f30656c69662f2e R15: 00007effded664c8

Link: https://lore.kernel.org/r/20220720025120.3226770-1-yanaijie@huawei.com
Fixes: 25636e282fe9 ("block: fix SG_IO vector request data length handling")
	Reported-by: syzbot+d44b35ecfb807e5af0b5@syzkaller.appspotmail.com
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Jason Yan <yanaijie@huawei.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d9a434fa0c12ed5f7afe1e9dd30003ab5d059b85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_ioctl.c
diff --cc drivers/scsi/scsi_ioctl.c
index 07674ac32a68,729e309e6034..000000000000
--- a/drivers/scsi/scsi_ioctl.c
+++ b/drivers/scsi/scsi_ioctl.c
@@@ -188,6 -167,700 +188,703 @@@ static int scsi_ioctl_get_pci(struct sc
  		? -EFAULT: 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int sg_get_version(int __user *p)
+ {
+ 	static const int sg_version_num = 30527;
+ 	return put_user(sg_version_num, p);
+ }
+ 
+ static int sg_set_timeout(struct scsi_device *sdev, int __user *p)
+ {
+ 	int timeout, err = get_user(timeout, p);
+ 
+ 	if (!err)
+ 		sdev->sg_timeout = clock_t_to_jiffies(timeout);
+ 
+ 	return err;
+ }
+ 
+ static int sg_get_reserved_size(struct scsi_device *sdev, int __user *p)
+ {
+ 	int val = min(sdev->sg_reserved_size,
+ 		      queue_max_bytes(sdev->request_queue));
+ 
+ 	return put_user(val, p);
+ }
+ 
+ static int sg_set_reserved_size(struct scsi_device *sdev, int __user *p)
+ {
+ 	int size, err = get_user(size, p);
+ 
+ 	if (err)
+ 		return err;
+ 
+ 	if (size < 0)
+ 		return -EINVAL;
+ 
+ 	sdev->sg_reserved_size = min_t(unsigned int, size,
+ 				       queue_max_bytes(sdev->request_queue));
+ 	return 0;
+ }
+ 
+ /*
+  * will always return that we are ATAPI even for a real SCSI drive, I'm not
+  * so sure this is worth doing anything about (why would you care??)
+  */
+ static int sg_emulated_host(struct request_queue *q, int __user *p)
+ {
+ 	return put_user(1, p);
+ }
+ 
+ static int scsi_get_idlun(struct scsi_device *sdev, void __user *argp)
+ {
+ 	struct scsi_idlun v = {
+ 		.dev_id = (sdev->id & 0xff) +
+ 			((sdev->lun & 0xff) << 8) +
+ 			((sdev->channel & 0xff) << 16) +
+ 			((sdev->host->host_no & 0xff) << 24),
+ 		.host_unique_id = sdev->host->unique_id
+ 	};
+ 	if (copy_to_user(argp, &v, sizeof(struct scsi_idlun)))
+ 		return -EFAULT;
+ 	return 0;
+ }
+ 
+ static int scsi_send_start_stop(struct scsi_device *sdev, int data)
+ {
+ 	u8 cdb[MAX_COMMAND_SIZE] = { };
+ 
+ 	cdb[0] = START_STOP;
+ 	cdb[4] = data;
+ 	return ioctl_internal_command(sdev, cdb, START_STOP_TIMEOUT,
+ 				      NORMAL_RETRIES);
+ }
+ 
+ /*
+  * Check if the given command is allowed.
+  *
+  * Only a subset of commands are allowed for unprivileged users. Commands used
+  * to format the media, update the firmware, etc. are not permitted.
+  */
+ bool scsi_cmd_allowed(unsigned char *cmd, fmode_t mode)
+ {
+ 	/* root can do any command. */
+ 	if (capable(CAP_SYS_RAWIO))
+ 		return true;
+ 
+ 	/* Anybody who can open the device can do a read-safe command */
+ 	switch (cmd[0]) {
+ 	/* Basic read-only commands */
+ 	case TEST_UNIT_READY:
+ 	case REQUEST_SENSE:
+ 	case READ_6:
+ 	case READ_10:
+ 	case READ_12:
+ 	case READ_16:
+ 	case READ_BUFFER:
+ 	case READ_DEFECT_DATA:
+ 	case READ_CAPACITY: /* also GPCMD_READ_CDVD_CAPACITY */
+ 	case READ_LONG:
+ 	case INQUIRY:
+ 	case MODE_SENSE:
+ 	case MODE_SENSE_10:
+ 	case LOG_SENSE:
+ 	case START_STOP:
+ 	case GPCMD_VERIFY_10:
+ 	case VERIFY_16:
+ 	case REPORT_LUNS:
+ 	case SERVICE_ACTION_IN_16:
+ 	case RECEIVE_DIAGNOSTIC:
+ 	case MAINTENANCE_IN: /* also GPCMD_SEND_KEY, which is a write command */
+ 	case GPCMD_READ_BUFFER_CAPACITY:
+ 	/* Audio CD commands */
+ 	case GPCMD_PLAY_CD:
+ 	case GPCMD_PLAY_AUDIO_10:
+ 	case GPCMD_PLAY_AUDIO_MSF:
+ 	case GPCMD_PLAY_AUDIO_TI:
+ 	case GPCMD_PAUSE_RESUME:
+ 	/* CD/DVD data reading */
+ 	case GPCMD_READ_CD:
+ 	case GPCMD_READ_CD_MSF:
+ 	case GPCMD_READ_DISC_INFO:
+ 	case GPCMD_READ_DVD_STRUCTURE:
+ 	case GPCMD_READ_HEADER:
+ 	case GPCMD_READ_TRACK_RZONE_INFO:
+ 	case GPCMD_READ_SUBCHANNEL:
+ 	case GPCMD_READ_TOC_PMA_ATIP:
+ 	case GPCMD_REPORT_KEY:
+ 	case GPCMD_SCAN:
+ 	case GPCMD_GET_CONFIGURATION:
+ 	case GPCMD_READ_FORMAT_CAPACITIES:
+ 	case GPCMD_GET_EVENT_STATUS_NOTIFICATION:
+ 	case GPCMD_GET_PERFORMANCE:
+ 	case GPCMD_SEEK:
+ 	case GPCMD_STOP_PLAY_SCAN:
+ 	/* ZBC */
+ 	case ZBC_IN:
+ 		return true;
+ 	/* Basic writing commands */
+ 	case WRITE_6:
+ 	case WRITE_10:
+ 	case WRITE_VERIFY:
+ 	case WRITE_12:
+ 	case WRITE_VERIFY_12:
+ 	case WRITE_16:
+ 	case WRITE_LONG:
+ 	case WRITE_LONG_2:
+ 	case WRITE_SAME:
+ 	case WRITE_SAME_16:
+ 	case WRITE_SAME_32:
+ 	case ERASE:
+ 	case GPCMD_MODE_SELECT_10:
+ 	case MODE_SELECT:
+ 	case LOG_SELECT:
+ 	case GPCMD_BLANK:
+ 	case GPCMD_CLOSE_TRACK:
+ 	case GPCMD_FLUSH_CACHE:
+ 	case GPCMD_FORMAT_UNIT:
+ 	case GPCMD_REPAIR_RZONE_TRACK:
+ 	case GPCMD_RESERVE_RZONE_TRACK:
+ 	case GPCMD_SEND_DVD_STRUCTURE:
+ 	case GPCMD_SEND_EVENT:
+ 	case GPCMD_SEND_OPC:
+ 	case GPCMD_SEND_CUE_SHEET:
+ 	case GPCMD_SET_SPEED:
+ 	case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+ 	case GPCMD_LOAD_UNLOAD:
+ 	case GPCMD_SET_STREAMING:
+ 	case GPCMD_SET_READ_AHEAD:
+ 	/* ZBC */
+ 	case ZBC_OUT:
+ 		return (mode & FMODE_WRITE);
+ 	default:
+ 		return false;
+ 	}
+ }
+ EXPORT_SYMBOL(scsi_cmd_allowed);
+ 
+ static int scsi_fill_sghdr_rq(struct scsi_device *sdev, struct request *rq,
+ 		struct sg_io_hdr *hdr, fmode_t mode)
+ {
+ 	struct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);
+ 
+ 	if (hdr->cmd_len < 6)
+ 		return -EMSGSIZE;
+ 	if (copy_from_user(scmd->cmnd, hdr->cmdp, hdr->cmd_len))
+ 		return -EFAULT;
+ 	if (!scsi_cmd_allowed(scmd->cmnd, mode))
+ 		return -EPERM;
+ 	scmd->cmd_len = hdr->cmd_len;
+ 
+ 	rq->timeout = msecs_to_jiffies(hdr->timeout);
+ 	if (!rq->timeout)
+ 		rq->timeout = sdev->sg_timeout;
+ 	if (!rq->timeout)
+ 		rq->timeout = BLK_DEFAULT_SG_TIMEOUT;
+ 	if (rq->timeout < BLK_MIN_SG_TIMEOUT)
+ 		rq->timeout = BLK_MIN_SG_TIMEOUT;
+ 
+ 	return 0;
+ }
+ 
+ static int scsi_complete_sghdr_rq(struct request *rq, struct sg_io_hdr *hdr,
+ 		struct bio *bio)
+ {
+ 	struct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);
+ 	int r, ret = 0;
+ 
+ 	/*
+ 	 * fill in all the output members
+ 	 */
+ 	hdr->status = scmd->result & 0xff;
+ 	hdr->masked_status = status_byte(scmd->result);
+ 	hdr->msg_status = COMMAND_COMPLETE;
+ 	hdr->host_status = host_byte(scmd->result);
+ 	hdr->driver_status = 0;
+ 	if (scsi_status_is_check_condition(hdr->status))
+ 		hdr->driver_status = DRIVER_SENSE;
+ 	hdr->info = 0;
+ 	if (hdr->masked_status || hdr->host_status || hdr->driver_status)
+ 		hdr->info |= SG_INFO_CHECK;
+ 	hdr->resid = scmd->resid_len;
+ 	hdr->sb_len_wr = 0;
+ 
+ 	if (scmd->sense_len && hdr->sbp) {
+ 		int len = min((unsigned int) hdr->mx_sb_len, scmd->sense_len);
+ 
+ 		if (!copy_to_user(hdr->sbp, scmd->sense_buffer, len))
+ 			hdr->sb_len_wr = len;
+ 		else
+ 			ret = -EFAULT;
+ 	}
+ 
+ 	r = blk_rq_unmap_user(bio);
+ 	if (!ret)
+ 		ret = r;
+ 
+ 	return ret;
+ }
+ 
+ static int sg_io(struct scsi_device *sdev, struct sg_io_hdr *hdr, fmode_t mode)
+ {
+ 	unsigned long start_time;
+ 	ssize_t ret = 0;
+ 	int writing = 0;
+ 	int at_head = 0;
+ 	struct request *rq;
+ 	struct scsi_cmnd *scmd;
+ 	struct bio *bio;
+ 
+ 	if (hdr->interface_id != 'S')
+ 		return -EINVAL;
+ 
+ 	if (hdr->dxfer_len > (queue_max_hw_sectors(sdev->request_queue) << 9))
+ 		return -EIO;
+ 
+ 	if (hdr->dxfer_len)
+ 		switch (hdr->dxfer_direction) {
+ 		default:
+ 			return -EINVAL;
+ 		case SG_DXFER_TO_DEV:
+ 			writing = 1;
+ 			break;
+ 		case SG_DXFER_TO_FROM_DEV:
+ 		case SG_DXFER_FROM_DEV:
+ 			break;
+ 		}
+ 	if (hdr->flags & SG_FLAG_Q_AT_HEAD)
+ 		at_head = 1;
+ 
+ 	rq = scsi_alloc_request(sdev->request_queue, writing ?
+ 			     REQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);
+ 	if (IS_ERR(rq))
+ 		return PTR_ERR(rq);
+ 	scmd = blk_mq_rq_to_pdu(rq);
+ 
+ 	if (hdr->cmd_len > sizeof(scmd->cmnd)) {
+ 		ret = -EINVAL;
+ 		goto out_put_request;
+ 	}
+ 
+ 	ret = scsi_fill_sghdr_rq(sdev, rq, hdr, mode);
+ 	if (ret < 0)
+ 		goto out_put_request;
+ 
+ 	ret = 0;
+ 	if (hdr->iovec_count && hdr->dxfer_len) {
+ 		struct iov_iter i;
+ 		struct iovec *iov = NULL;
+ 
+ 		ret = import_iovec(rq_data_dir(rq), hdr->dxferp,
+ 				   hdr->iovec_count, 0, &iov, &i);
+ 		if (ret < 0)
+ 			goto out_put_request;
+ 
+ 		/* SG_IO howto says that the shorter of the two wins */
+ 		iov_iter_truncate(&i, hdr->dxfer_len);
+ 
+ 		ret = blk_rq_map_user_iov(rq->q, rq, NULL, &i, GFP_KERNEL);
+ 		kfree(iov);
+ 	} else if (hdr->dxfer_len)
+ 		ret = blk_rq_map_user(rq->q, rq, NULL, hdr->dxferp,
+ 				      hdr->dxfer_len, GFP_KERNEL);
+ 
+ 	if (ret)
+ 		goto out_put_request;
+ 
+ 	bio = rq->bio;
+ 	scmd->allowed = 0;
+ 
+ 	start_time = jiffies;
+ 
+ 	blk_execute_rq(rq, at_head);
+ 
+ 	hdr->duration = jiffies_to_msecs(jiffies - start_time);
+ 
+ 	ret = scsi_complete_sghdr_rq(rq, hdr, bio);
+ 
+ out_put_request:
+ 	blk_mq_free_request(rq);
+ 	return ret;
+ }
+ 
+ /**
+  * sg_scsi_ioctl  --  handle deprecated SCSI_IOCTL_SEND_COMMAND ioctl
+  * @q:		request queue to send scsi commands down
+  * @mode:	mode used to open the file through which the ioctl has been
+  *		submitted
+  * @sic:	userspace structure describing the command to perform
+  *
+  * Send down the scsi command described by @sic to the device below
+  * the request queue @q.
+  *
+  * Notes:
+  *   -  This interface is deprecated - users should use the SG_IO
+  *      interface instead, as this is a more flexible approach to
+  *      performing SCSI commands on a device.
+  *   -  The SCSI command length is determined by examining the 1st byte
+  *      of the given command. There is no way to override this.
+  *   -  Data transfers are limited to PAGE_SIZE
+  *   -  The length (x + y) must be at least OMAX_SB_LEN bytes long to
+  *      accommodate the sense buffer when an error occurs.
+  *      The sense buffer is truncated to OMAX_SB_LEN (16) bytes so that
+  *      old code will not be surprised.
+  *   -  If a Unix error occurs (e.g. ENOMEM) then the user will receive
+  *      a negative return and the Unix error code in 'errno'.
+  *      If the SCSI command succeeds then 0 is returned.
+  *      Positive numbers returned are the compacted SCSI error codes (4
+  *      bytes in one int) where the lowest byte is the SCSI status.
+  */
+ static int sg_scsi_ioctl(struct request_queue *q, fmode_t mode,
+ 		struct scsi_ioctl_command __user *sic)
+ {
+ 	struct request *rq;
+ 	int err;
+ 	unsigned int in_len, out_len, bytes, opcode, cmdlen;
+ 	struct scsi_cmnd *scmd;
+ 	char *buffer = NULL;
+ 
+ 	if (!sic)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * get in an out lengths, verify they don't exceed a page worth of data
+ 	 */
+ 	if (get_user(in_len, &sic->inlen))
+ 		return -EFAULT;
+ 	if (get_user(out_len, &sic->outlen))
+ 		return -EFAULT;
+ 	if (in_len > PAGE_SIZE || out_len > PAGE_SIZE)
+ 		return -EINVAL;
+ 	if (get_user(opcode, sic->data))
+ 		return -EFAULT;
+ 
+ 	bytes = max(in_len, out_len);
+ 	if (bytes) {
+ 		buffer = kzalloc(bytes, GFP_NOIO | GFP_USER | __GFP_NOWARN);
+ 		if (!buffer)
+ 			return -ENOMEM;
+ 
+ 	}
+ 
+ 	rq = scsi_alloc_request(q, in_len ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);
+ 	if (IS_ERR(rq)) {
+ 		err = PTR_ERR(rq);
+ 		goto error_free_buffer;
+ 	}
+ 	scmd = blk_mq_rq_to_pdu(rq);
+ 
+ 	cmdlen = COMMAND_SIZE(opcode);
+ 
+ 	/*
+ 	 * get command and data to send to device, if any
+ 	 */
+ 	err = -EFAULT;
+ 	scmd->cmd_len = cmdlen;
+ 	if (copy_from_user(scmd->cmnd, sic->data, cmdlen))
+ 		goto error;
+ 
+ 	if (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))
+ 		goto error;
+ 
+ 	err = -EPERM;
+ 	if (!scsi_cmd_allowed(scmd->cmnd, mode))
+ 		goto error;
+ 
+ 	/* default.  possible overridden later */
+ 	scmd->allowed = 5;
+ 
+ 	switch (opcode) {
+ 	case SEND_DIAGNOSTIC:
+ 	case FORMAT_UNIT:
+ 		rq->timeout = FORMAT_UNIT_TIMEOUT;
+ 		scmd->allowed = 1;
+ 		break;
+ 	case START_STOP:
+ 		rq->timeout = START_STOP_TIMEOUT;
+ 		break;
+ 	case MOVE_MEDIUM:
+ 		rq->timeout = MOVE_MEDIUM_TIMEOUT;
+ 		break;
+ 	case READ_ELEMENT_STATUS:
+ 		rq->timeout = READ_ELEMENT_STATUS_TIMEOUT;
+ 		break;
+ 	case READ_DEFECT_DATA:
+ 		rq->timeout = READ_DEFECT_DATA_TIMEOUT;
+ 		scmd->allowed = 1;
+ 		break;
+ 	default:
+ 		rq->timeout = BLK_DEFAULT_SG_TIMEOUT;
+ 		break;
+ 	}
+ 
+ 	if (bytes) {
+ 		err = blk_rq_map_kern(q, rq, buffer, bytes, GFP_NOIO);
+ 		if (err)
+ 			goto error;
+ 	}
+ 
+ 	blk_execute_rq(rq, false);
+ 
+ 	err = scmd->result & 0xff;	/* only 8 bit SCSI status */
+ 	if (err) {
+ 		if (scmd->sense_len && scmd->sense_buffer) {
+ 			/* limit sense len for backward compatibility */
+ 			if (copy_to_user(sic->data, scmd->sense_buffer,
+ 					 min(scmd->sense_len, 16U)))
+ 				err = -EFAULT;
+ 		}
+ 	} else {
+ 		if (copy_to_user(sic->data, buffer, out_len))
+ 			err = -EFAULT;
+ 	}
+ 
+ error:
+ 	blk_mq_free_request(rq);
+ 
+ error_free_buffer:
+ 	kfree(buffer);
+ 
+ 	return err;
+ }
+ 
+ int put_sg_io_hdr(const struct sg_io_hdr *hdr, void __user *argp)
+ {
+ #ifdef CONFIG_COMPAT
+ 	if (in_compat_syscall()) {
+ 		struct compat_sg_io_hdr hdr32 =  {
+ 			.interface_id	 = hdr->interface_id,
+ 			.dxfer_direction = hdr->dxfer_direction,
+ 			.cmd_len	 = hdr->cmd_len,
+ 			.mx_sb_len	 = hdr->mx_sb_len,
+ 			.iovec_count	 = hdr->iovec_count,
+ 			.dxfer_len	 = hdr->dxfer_len,
+ 			.dxferp		 = (uintptr_t)hdr->dxferp,
+ 			.cmdp		 = (uintptr_t)hdr->cmdp,
+ 			.sbp		 = (uintptr_t)hdr->sbp,
+ 			.timeout	 = hdr->timeout,
+ 			.flags		 = hdr->flags,
+ 			.pack_id	 = hdr->pack_id,
+ 			.usr_ptr	 = (uintptr_t)hdr->usr_ptr,
+ 			.status		 = hdr->status,
+ 			.masked_status	 = hdr->masked_status,
+ 			.msg_status	 = hdr->msg_status,
+ 			.sb_len_wr	 = hdr->sb_len_wr,
+ 			.host_status	 = hdr->host_status,
+ 			.driver_status	 = hdr->driver_status,
+ 			.resid		 = hdr->resid,
+ 			.duration	 = hdr->duration,
+ 			.info		 = hdr->info,
+ 		};
+ 
+ 		if (copy_to_user(argp, &hdr32, sizeof(hdr32)))
+ 			return -EFAULT;
+ 
+ 		return 0;
+ 	}
+ #endif
+ 
+ 	if (copy_to_user(argp, hdr, sizeof(*hdr)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(put_sg_io_hdr);
+ 
+ int get_sg_io_hdr(struct sg_io_hdr *hdr, const void __user *argp)
+ {
+ #ifdef CONFIG_COMPAT
+ 	struct compat_sg_io_hdr hdr32;
+ 
+ 	if (in_compat_syscall()) {
+ 		if (copy_from_user(&hdr32, argp, sizeof(hdr32)))
+ 			return -EFAULT;
+ 
+ 		*hdr = (struct sg_io_hdr) {
+ 			.interface_id	 = hdr32.interface_id,
+ 			.dxfer_direction = hdr32.dxfer_direction,
+ 			.cmd_len	 = hdr32.cmd_len,
+ 			.mx_sb_len	 = hdr32.mx_sb_len,
+ 			.iovec_count	 = hdr32.iovec_count,
+ 			.dxfer_len	 = hdr32.dxfer_len,
+ 			.dxferp		 = compat_ptr(hdr32.dxferp),
+ 			.cmdp		 = compat_ptr(hdr32.cmdp),
+ 			.sbp		 = compat_ptr(hdr32.sbp),
+ 			.timeout	 = hdr32.timeout,
+ 			.flags		 = hdr32.flags,
+ 			.pack_id	 = hdr32.pack_id,
+ 			.usr_ptr	 = compat_ptr(hdr32.usr_ptr),
+ 			.status		 = hdr32.status,
+ 			.masked_status	 = hdr32.masked_status,
+ 			.msg_status	 = hdr32.msg_status,
+ 			.sb_len_wr	 = hdr32.sb_len_wr,
+ 			.host_status	 = hdr32.host_status,
+ 			.driver_status	 = hdr32.driver_status,
+ 			.resid		 = hdr32.resid,
+ 			.duration	 = hdr32.duration,
+ 			.info		 = hdr32.info,
+ 		};
+ 
+ 		return 0;
+ 	}
+ #endif
+ 
+ 	if (copy_from_user(hdr, argp, sizeof(*hdr)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(get_sg_io_hdr);
+ 
+ #ifdef CONFIG_COMPAT
+ struct compat_cdrom_generic_command {
+ 	unsigned char	cmd[CDROM_PACKET_SIZE];
+ 	compat_caddr_t	buffer;
+ 	compat_uint_t	buflen;
+ 	compat_int_t	stat;
+ 	compat_caddr_t	sense;
+ 	unsigned char	data_direction;
+ 	unsigned char	pad[3];
+ 	compat_int_t	quiet;
+ 	compat_int_t	timeout;
+ 	compat_caddr_t	unused;
+ };
+ #endif
+ 
+ static int scsi_get_cdrom_generic_arg(struct cdrom_generic_command *cgc,
+ 				      const void __user *arg)
+ {
+ #ifdef CONFIG_COMPAT
+ 	if (in_compat_syscall()) {
+ 		struct compat_cdrom_generic_command cgc32;
+ 
+ 		if (copy_from_user(&cgc32, arg, sizeof(cgc32)))
+ 			return -EFAULT;
+ 
+ 		*cgc = (struct cdrom_generic_command) {
+ 			.buffer		= compat_ptr(cgc32.buffer),
+ 			.buflen		= cgc32.buflen,
+ 			.stat		= cgc32.stat,
+ 			.sense		= compat_ptr(cgc32.sense),
+ 			.data_direction	= cgc32.data_direction,
+ 			.quiet		= cgc32.quiet,
+ 			.timeout	= cgc32.timeout,
+ 			.unused		= compat_ptr(cgc32.unused),
+ 		};
+ 		memcpy(&cgc->cmd, &cgc32.cmd, CDROM_PACKET_SIZE);
+ 		return 0;
+ 	}
+ #endif
+ 	if (copy_from_user(cgc, arg, sizeof(*cgc)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int scsi_put_cdrom_generic_arg(const struct cdrom_generic_command *cgc,
+ 				      void __user *arg)
+ {
+ #ifdef CONFIG_COMPAT
+ 	if (in_compat_syscall()) {
+ 		struct compat_cdrom_generic_command cgc32 = {
+ 			.buffer		= (uintptr_t)(cgc->buffer),
+ 			.buflen		= cgc->buflen,
+ 			.stat		= cgc->stat,
+ 			.sense		= (uintptr_t)(cgc->sense),
+ 			.data_direction	= cgc->data_direction,
+ 			.quiet		= cgc->quiet,
+ 			.timeout	= cgc->timeout,
+ 			.unused		= (uintptr_t)(cgc->unused),
+ 		};
+ 		memcpy(&cgc32.cmd, &cgc->cmd, CDROM_PACKET_SIZE);
+ 
+ 		if (copy_to_user(arg, &cgc32, sizeof(cgc32)))
+ 			return -EFAULT;
+ 
+ 		return 0;
+ 	}
+ #endif
+ 	if (copy_to_user(arg, cgc, sizeof(*cgc)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int scsi_cdrom_send_packet(struct scsi_device *sdev, fmode_t mode,
+ 		void __user *arg)
+ {
+ 	struct cdrom_generic_command cgc;
+ 	struct sg_io_hdr hdr;
+ 	int err;
+ 
+ 	err = scsi_get_cdrom_generic_arg(&cgc, arg);
+ 	if (err)
+ 		return err;
+ 
+ 	cgc.timeout = clock_t_to_jiffies(cgc.timeout);
+ 	memset(&hdr, 0, sizeof(hdr));
+ 	hdr.interface_id = 'S';
+ 	hdr.cmd_len = sizeof(cgc.cmd);
+ 	hdr.dxfer_len = cgc.buflen;
+ 	switch (cgc.data_direction) {
+ 	case CGC_DATA_UNKNOWN:
+ 		hdr.dxfer_direction = SG_DXFER_UNKNOWN;
+ 		break;
+ 	case CGC_DATA_WRITE:
+ 		hdr.dxfer_direction = SG_DXFER_TO_DEV;
+ 		break;
+ 	case CGC_DATA_READ:
+ 		hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+ 		break;
+ 	case CGC_DATA_NONE:
+ 		hdr.dxfer_direction = SG_DXFER_NONE;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	hdr.dxferp = cgc.buffer;
+ 	hdr.sbp = cgc.sense;
+ 	if (hdr.sbp)
+ 		hdr.mx_sb_len = sizeof(struct request_sense);
+ 	hdr.timeout = jiffies_to_msecs(cgc.timeout);
+ 	hdr.cmdp = ((struct cdrom_generic_command __user *) arg)->cmd;
+ 	hdr.cmd_len = sizeof(cgc.cmd);
+ 
+ 	err = sg_io(sdev, &hdr, mode);
+ 	if (err == -EFAULT)
+ 		return -EFAULT;
+ 
+ 	if (hdr.status)
+ 		return -EIO;
+ 
+ 	cgc.stat = err;
+ 	cgc.buflen = hdr.resid;
+ 	if (scsi_put_cdrom_generic_arg(&cgc, arg))
+ 		return -EFAULT;
+ 
+ 	return err;
+ }
+ 
+ static int scsi_ioctl_sg_io(struct scsi_device *sdev, fmode_t mode,
+ 		void __user *argp)
+ {
+ 	struct sg_io_hdr hdr;
+ 	int error;
+ 
+ 	error = get_sg_io_hdr(&hdr, argp);
+ 	if (error)
+ 		return error;
+ 	error = sg_io(sdev, &hdr, mode);
+ 	if (error == -EFAULT)
+ 		return error;
+ 	if (put_sg_io_hdr(&hdr, argp))
+ 		return -EFAULT;
+ 	return error;
+ }
++>>>>>>> d9a434fa0c12 (scsi: core: Fix warning in scsi_alloc_sgtables())
  
  /**
   * scsi_ioctl - Dispatch ioctl to scsi device
* Unmerged path drivers/scsi/scsi_ioctl.c
