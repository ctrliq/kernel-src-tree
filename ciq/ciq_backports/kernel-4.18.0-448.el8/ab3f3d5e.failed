net/mlx5e: Add mirred/redirect to tc action infra

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit ab3f3d5efffaa26ae67c8c92524424b50df5cd13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ab3f3d5e.failed

Add parsing support by implementing struct mlx5e_tc_act
for this action.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit ab3f3d5efffaa26ae67c8c92524424b50df5cd13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 478a0ab6470d,8712a5ca8f55..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -46,6 -46,13 +46,16 @@@ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     +
  					en/tc_tun_vxlan.o en/tc_tun_gre.o en/tc_tun_geneve.o \
  					en/tc_tun_mplsoudp.o diag/en_tc_tracepoint.o \
  					en/tc/post_act.o en/tc/int_port.o
++<<<<<<< HEAD
++=======
+ 
+ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     += en/tc/act/act.o en/tc/act/drop.o en/tc/act/trap.o \
+ 					en/tc/act/accept.o en/tc/act/mark.o en/tc/act/goto.o \
+ 					en/tc/act/tun.o en/tc/act/csum.o en/tc/act/pedit.o \
+ 					en/tc/act/vlan.o en/tc/act/vlan_mangle.o en/tc/act/mpls.o \
+ 					en/tc/act/mirred.o en/tc/act/mirred_nic.o
+ 
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  mlx5_core-$(CONFIG_MLX5_TC_CT)	     += en/tc_ct.o
  mlx5_core-$(CONFIG_MLX5_TC_SAMPLE)   += en/tc/sample.o
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
index b689701ac7d8,f832c26ff2c3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
@@@ -115,7 -119,11 +115,12 @@@ mlx5e_tc_offload_fdb_rules(struct mlx5_
  			   struct mlx5_flow_spec *spec,
  			   struct mlx5_flow_attr *attr);
  
 -bool mlx5e_is_eswitch_flow(struct mlx5e_tc_flow *flow);
 -bool mlx5e_is_ft_flow(struct mlx5e_tc_flow *flow);
  bool mlx5e_is_offloaded_flow(struct mlx5e_tc_flow *flow);
++<<<<<<< HEAD
++=======
+ int mlx5e_get_flow_namespace(struct mlx5e_tc_flow *flow);
+ bool mlx5e_same_hw_devs(struct mlx5e_priv *priv, struct mlx5e_priv *peer_priv);
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  
  static inline void __flow_flag_set(struct mlx5e_tc_flow *flow, unsigned long flag)
  {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index abcf89c03680,d1e803098e0d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -39,9 -39,6 +39,12 @@@
  #include <linux/rhashtable.h>
  #include <linux/refcount.h>
  #include <linux/completion.h>
++<<<<<<< HEAD
 +#include <linux/if_macvlan.h>
 +#include <net/tc_act/tc_pedit.h>
 +#include <net/tc_act/tc_csum.h>
++=======
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  #include <net/psample.h>
  #include <net/arp.h>
  #include <net/ipv6_stubs.h>
@@@ -3290,56 -3115,6 +3291,59 @@@ bool mlx5e_same_hw_devs(struct mlx5e_pr
  	return (fsystem_guid == psystem_guid);
  }
  
++<<<<<<< HEAD
 +static bool same_vf_reps(struct mlx5e_priv *priv,
 +			 struct net_device *out_dev)
 +{
 +	return mlx5e_eswitch_vf_rep(priv->netdev) &&
 +	       priv->netdev == out_dev;
 +}
 +
 +static int add_vlan_rewrite_action(struct mlx5e_priv *priv, int namespace,
 +				   const struct flow_action_entry *act,
 +				   struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				   struct pedit_headers_action *hdrs,
 +				   u32 *action, struct netlink_ext_ack *extack)
 +{
 +	u16 mask16 = VLAN_VID_MASK;
 +	u16 val16 = act->vlan.vid & VLAN_VID_MASK;
 +	const struct flow_action_entry pedit_act = {
 +		.id = FLOW_ACTION_MANGLE,
 +		.mangle.htype = FLOW_ACT_MANGLE_HDR_TYPE_ETH,
 +		.mangle.offset = offsetof(struct vlan_ethhdr, h_vlan_TCI),
 +		.mangle.mask = ~(u32)be16_to_cpu(*(__be16 *)&mask16),
 +		.mangle.val = (u32)be16_to_cpu(*(__be16 *)&val16),
 +	};
 +	u8 match_prio_mask, match_prio_val;
 +	void *headers_c, *headers_v;
 +	int err;
 +
 +	headers_c = get_match_headers_criteria(*action, &parse_attr->spec);
 +	headers_v = get_match_headers_value(*action, &parse_attr->spec);
 +
 +	if (!(MLX5_GET(fte_match_set_lyr_2_4, headers_c, cvlan_tag) &&
 +	      MLX5_GET(fte_match_set_lyr_2_4, headers_v, cvlan_tag))) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "VLAN rewrite action must have VLAN protocol match");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	match_prio_mask = MLX5_GET(fte_match_set_lyr_2_4, headers_c, first_prio);
 +	match_prio_val = MLX5_GET(fte_match_set_lyr_2_4, headers_v, first_prio);
 +	if (act->vlan.prio != (match_prio_val & match_prio_mask)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Changing VLAN prio is not supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	err = parse_tc_pedit_action(priv, &pedit_act, namespace, parse_attr, hdrs, NULL, extack);
 +	*action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +
 +	return err;
 +}
 +
++=======
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  static int
  add_vlan_prio_tag_rewrite_action(struct mlx5e_priv *priv,
  				 struct mlx5e_tc_flow_parse_attr *parse_attr,
@@@ -3497,87 -3220,11 +3501,90 @@@ parse_tc_nic_actions(struct mlx5e_priv 
  
  	flow_action_for_each(i, act, flow_action) {
  		switch (act->id) {
++<<<<<<< HEAD
 +		case FLOW_ACTION_ACCEPT:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_KERNEL,
 +						    parse_attr, hdrs, NULL, extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_KERNEL,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags,
 +						   extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
 +		case FLOW_ACTION_REDIRECT: {
 +			struct net_device *peer_dev = act->dev;
 +
 +			if (priv->netdev->netdev_ops == peer_dev->netdev_ops &&
 +			    same_hw_devs(priv, netdev_priv(peer_dev))) {
 +				parse_attr->mirred_ifindex[0] = peer_dev->ifindex;
 +				flow_flag_set(flow, HAIRPIN);
 +				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "device is not on same HW, can't offload");
 +				netdev_warn(priv->netdev, "device %s not on same HW, can't offload\n",
 +					    peer_dev->name);
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_MARK: {
 +			u32 mark = act->mark;
 +
 +			if (mark & ~MLX5E_TC_FLOW_ID_MASK) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Bad flow mark - only 16 bit is supported");
 +				return -EINVAL;
 +			}
 +
 +			nic_attr->flow_tag = mark;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 +			}
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
 +			break;
++=======
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  		case FLOW_ACTION_CT:
 +			clear_action = act->ct.action & TCA_CT_ACT_CLEAR;
 +
 +			/* It's redundant to do ct clear more than once. */
 +			if (clear_action && attr->ct_clear)
 +				break;
 +
  			err = mlx5_tc_ct_parse_action(get_ct_priv(priv), attr,
  						      &parse_attr->mod_hdr_acts,
  						      act, extack);
@@@ -3621,147 -3276,7 +3628,151 @@@ static bool is_merged_eswitch_vfs(struc
  	return (MLX5_CAP_ESW(priv->mdev, merged_eswitch) &&
  		mlx5e_eswitch_vf_rep(priv->netdev) &&
  		mlx5e_eswitch_vf_rep(peer_netdev) &&
++<<<<<<< HEAD
 +		same_hw_devs(priv, peer_priv));
 +}
 +
 +static int parse_tc_vlan_action(struct mlx5e_priv *priv,
 +				const struct flow_action_entry *act,
 +				struct mlx5_esw_flow_attr *attr,
 +				u32 *action,
 +				struct netlink_ext_ack *extack)
 +{
 +	u8 vlan_idx = attr->total_vlan;
 +
 +	if (vlan_idx >= MLX5_FS_VLAN_DEPTH) {
 +		NL_SET_ERR_MSG_MOD(extack, "Total vlans used is greater than supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	switch (act->id) {
 +	case FLOW_ACTION_VLAN_POP:
 +		if (vlan_idx) {
 +			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
 +								 MLX5_FS_VLAN_DEPTH)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "vlan pop action is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;
 +		} else {
 +			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +		}
 +		break;
 +	case FLOW_ACTION_VLAN_PUSH:
 +		attr->vlan_vid[vlan_idx] = act->vlan.vid;
 +		attr->vlan_prio[vlan_idx] = act->vlan.prio;
 +		attr->vlan_proto[vlan_idx] = act->vlan.proto;
 +		if (!attr->vlan_proto[vlan_idx])
 +			attr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);
 +
 +		if (vlan_idx) {
 +			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
 +								 MLX5_FS_VLAN_DEPTH)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "vlan push action is not supported for vlan depth > 1");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;
 +		} else {
 +			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev, 1) &&
 +			    (act->vlan.proto != htons(ETH_P_8021Q) ||
 +			     act->vlan.prio)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "vlan push action is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
 +		}
 +		break;
 +	default:
 +		NL_SET_ERR_MSG_MOD(extack, "Unexpected action id for VLAN");
 +		return -EINVAL;
 +	}
 +
 +	attr->total_vlan = vlan_idx + 1;
 +
 +	return 0;
 +}
 +
 +static struct net_device *get_fdb_out_dev(struct net_device *uplink_dev,
 +					  struct net_device *out_dev)
 +{
 +	struct net_device *fdb_out_dev = out_dev;
 +	struct net_device *uplink_upper;
 +
 +	rcu_read_lock();
 +	uplink_upper = netdev_master_upper_dev_get_rcu(uplink_dev);
 +	if (uplink_upper && netif_is_lag_master(uplink_upper) &&
 +	    uplink_upper == out_dev) {
 +		fdb_out_dev = uplink_dev;
 +	} else if (netif_is_lag_master(out_dev)) {
 +		fdb_out_dev = bond_option_active_slave_get_rcu(netdev_priv(out_dev));
 +		if (fdb_out_dev &&
 +		    (!mlx5e_eswitch_rep(fdb_out_dev) ||
 +		     !netdev_port_same_parent_id(fdb_out_dev, uplink_dev)))
 +			fdb_out_dev = NULL;
 +	}
 +	rcu_read_unlock();
 +	return fdb_out_dev;
++=======
+ 		mlx5e_same_hw_devs(priv, peer_priv));
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
 +}
 +
 +static int add_vlan_push_action(struct mlx5e_priv *priv,
 +				struct mlx5_flow_attr *attr,
 +				struct net_device **out_dev,
 +				u32 *action,
 +				struct netlink_ext_ack *extack)
 +{
 +	struct net_device *vlan_dev = *out_dev;
 +	struct flow_action_entry vlan_act = {
 +		.id = FLOW_ACTION_VLAN_PUSH,
 +		.vlan.vid = vlan_dev_vlan_id(vlan_dev),
 +		.vlan.proto = vlan_dev_vlan_proto(vlan_dev),
 +		.vlan.prio = 0,
 +	};
 +	int err;
 +
 +	err = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, action, extack);
 +	if (err)
 +		return err;
 +
 +	rcu_read_lock();
 +	*out_dev = dev_get_by_index_rcu(dev_net(vlan_dev), dev_get_iflink(vlan_dev));
 +	rcu_read_unlock();
 +	if (!*out_dev)
 +		return -ENODEV;
 +
 +	if (is_vlan_dev(*out_dev))
 +		err = add_vlan_push_action(priv, attr, out_dev, action, extack);
 +
 +	return err;
 +}
 +
 +static int add_vlan_pop_action(struct mlx5e_priv *priv,
 +			       struct mlx5_flow_attr *attr,
 +			       u32 *action,
 +			       struct netlink_ext_ack *extack)
 +{
 +	struct flow_action_entry vlan_act = {
 +		.id = FLOW_ACTION_VLAN_POP,
 +	};
 +	int nest_level, err = 0;
 +
 +	nest_level = attr->parse_attr->filter_dev->lower_level -
 +						priv->netdev->lower_level;
 +	while (nest_level--) {
 +		err = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, action, extack);
 +		if (err)
 +			return err;
 +	}
 +
 +	return err;
  }
  
  static bool same_hw_reps(struct mlx5e_priv *priv,
@@@ -3797,62 -3312,6 +3808,65 @@@ bool mlx5e_is_valid_eswitch_fwd_dev(str
  	       same_port_devs(priv, netdev_priv(out_dev));
  }
  
++<<<<<<< HEAD
 +static bool is_duplicated_output_device(struct net_device *dev,
 +					struct net_device *out_dev,
 +					int *ifindexes, int if_count,
 +					struct netlink_ext_ack *extack)
 +{
 +	int i;
 +
 +	for (i = 0; i < if_count; i++) {
 +		if (ifindexes[i] == out_dev->ifindex) {
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "can't duplicate output to same device");
 +			netdev_err(dev, "can't duplicate output to same device: %s\n",
 +				   out_dev->name);
 +			return true;
 +		}
 +	}
 +
 +	return false;
 +}
 +
 +static int verify_uplink_forwarding(struct mlx5e_priv *priv,
 +				    struct mlx5e_tc_flow *flow,
 +				    struct net_device *out_dev,
 +				    struct netlink_ext_ack *extack)
 +{
 +	struct mlx5_esw_flow_attr *attr = flow->attr->esw_attr;
 +	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +	struct mlx5e_rep_priv *rep_priv;
 +
 +	/* Forwarding non encapsulated traffic between
 +	 * uplink ports is allowed only if
 +	 * termination_table_raw_traffic cap is set.
 +	 *
 +	 * Input vport was stored attr->in_rep.
 +	 * In LAG case, *priv* is the private data of
 +	 * uplink which may be not the input vport.
 +	 */
 +	rep_priv = mlx5e_rep_to_rep_priv(attr->in_rep);
 +
 +	if (!(mlx5e_eswitch_uplink_rep(rep_priv->netdev) &&
 +	      mlx5e_eswitch_uplink_rep(out_dev)))
 +		return 0;
 +
 +	if (!MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev,
 +					termination_table_raw_traffic)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "devices are both uplink, can't offload forwarding");
 +			return -EOPNOTSUPP;
 +	} else if (out_dev != rep_priv->netdev) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "devices are not the same uplink, can't offload forwarding");
 +		return -EOPNOTSUPP;
 +	}
 +	return 0;
 +}
 +
++=======
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  int mlx5e_set_fwd_to_int_port_actions(struct mlx5e_priv *priv,
  				      struct mlx5_flow_attr *attr,
  				      int ifindex,
@@@ -3897,23 -3356,18 +3911,32 @@@ static int parse_tc_fdb_actions(struct 
  				struct mlx5e_tc_flow *flow,
  				struct netlink_ext_ack *extack)
  {
 +	struct pedit_headers_action hdrs[2] = {};
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct mlx5e_tc_act_parse_state *parse_state;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
- 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	struct mlx5e_sample_attr sample_attr = {};
 +	const struct ip_tunnel_info *info = NULL;
  	struct mlx5_flow_attr *attr = flow->attr;
++<<<<<<< HEAD
 +	int ifindexes[MLX5_MAX_FLOW_FWD_VPORTS];
 +	bool ft_flow = mlx5e_is_ft_flow(flow);
 +	const struct flow_action_entry *act;
 +	struct mlx5_esw_flow_attr *esw_attr;
 +	bool encap = false, decap = false;
 +	u32 action = attr->action;
 +	int err, i, if_count = 0;
 +	bool ptype_host = false;
 +	bool mpls_push = false;
 +	bool clear_action;
++=======
+ 	enum mlx5_flow_namespace_type ns_type;
+ 	const struct flow_action_entry *act;
+ 	struct mlx5_esw_flow_attr *esw_attr;
+ 	struct pedit_headers_action *hdrs;
+ 	struct mlx5e_tc_act *tc_act;
+ 	bool ptype_host = false;
+ 	int err, i;
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  
  	err = flow_action_supported(flow_action, extack);
  	if (err)
@@@ -4040,192 -3435,6 +4063,195 @@@
  
  			break;
  		}
++<<<<<<< HEAD
 +		case FLOW_ACTION_REDIRECT:
 +		case FLOW_ACTION_MIRRED: {
 +			struct mlx5e_priv *out_priv;
 +			struct net_device *out_dev;
 +
 +			out_dev = act->dev;
 +			if (!out_dev) {
 +				/* out_dev is NULL when filters with
 +				 * non-existing mirred device are replayed to
 +				 * the driver.
 +				 */
 +				return -EINVAL;
 +			}
 +
 +			if (mpls_push && !netif_is_bareudp(out_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls is supported only through a bareudp device");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (ft_flow && out_dev == priv->netdev) {
 +				/* Ignore forward to self rules generated
 +				 * by adding both mlx5 devs to the flow table
 +				 * block on a normal nft offload setup.
 +				 */
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (esw_attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "can't support more output ports, can't offload forwarding");
 +				netdev_warn(priv->netdev,
 +					    "can't support more than %d output ports, can't offload forwarding\n",
 +					    esw_attr->out_count);
 +				return -EOPNOTSUPP;
 +			}
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			if (encap) {
 +				parse_attr->mirred_ifindex[esw_attr->out_count] =
 +					out_dev->ifindex;
 +				parse_attr->tun_info[esw_attr->out_count] =
 +					mlx5e_dup_tun_info(info);
 +				if (!parse_attr->tun_info[esw_attr->out_count])
 +					return -ENOMEM;
 +				encap = false;
 +				esw_attr->dests[esw_attr->out_count].flags |=
 +					MLX5_ESW_DEST_ENCAP;
 +				esw_attr->out_count++;
 +				/* attr->dests[].rep is resolved when we
 +				 * handle encap
 +				 */
 +			} else if (netdev_port_same_parent_id(priv->netdev, out_dev)) {
 +				struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +				struct net_device *uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
 +
 +				if (is_duplicated_output_device(priv->netdev,
 +								out_dev,
 +								ifindexes,
 +								if_count,
 +								extack))
 +					return -EOPNOTSUPP;
 +
 +				ifindexes[if_count] = out_dev->ifindex;
 +				if_count++;
 +
 +				out_dev = get_fdb_out_dev(uplink_dev, out_dev);
 +				if (!out_dev)
 +					return -ENODEV;
 +
 +				if (is_vlan_dev(out_dev)) {
 +					err = add_vlan_push_action(priv, attr,
 +								   &out_dev,
 +								   &action, extack);
 +					if (err)
 +						return err;
 +				}
 +
 +				if (is_vlan_dev(parse_attr->filter_dev)) {
 +					err = add_vlan_pop_action(priv, attr,
 +								  &action, extack);
 +					if (err)
 +						return err;
 +				}
 +
 +				if (netif_is_macvlan(out_dev))
 +					out_dev = macvlan_dev_real_dev(out_dev);
 +
 +				err = verify_uplink_forwarding(priv, flow, out_dev, extack);
 +				if (err)
 +					return err;
 +
 +				if (!mlx5e_is_valid_eswitch_fwd_dev(priv, out_dev)) {
 +					NL_SET_ERR_MSG_MOD(extack,
 +							   "devices are not on same switch HW, can't offload forwarding");
 +					return -EOPNOTSUPP;
 +				}
 +
 +				if (same_vf_reps(priv, out_dev)) {
 +					NL_SET_ERR_MSG_MOD(extack,
 +							   "can't forward from a VF to itself");
 +					return -EOPNOTSUPP;
 +				}
 +
 +				out_priv = netdev_priv(out_dev);
 +				rpriv = out_priv->ppriv;
 +				esw_attr->dests[esw_attr->out_count].rep = rpriv->rep;
 +				esw_attr->dests[esw_attr->out_count].mdev = out_priv->mdev;
 +				esw_attr->out_count++;
 +			} else if (netif_is_ovs_master(out_dev)) {
 +				err = mlx5e_set_fwd_to_int_port_actions(priv, attr,
 +									out_dev->ifindex,
 +									MLX5E_TC_INT_PORT_EGRESS,
 +									&action,
 +									esw_attr->out_count);
 +				if (err)
 +					return err;
 +
 +				esw_attr->out_count++;
 +			} else if (parse_attr->filter_dev != priv->netdev) {
 +				/* All mlx5 devices are called to configure
 +				 * high level device filters. Therefore, the
 +				 * *attempt* to  install a filter on invalid
 +				 * eswitch should not trigger an explicit error
 +				 */
 +				return -EINVAL;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "devices are not on same switch HW, can't offload forwarding");
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_TUNNEL_ENCAP:
 +			info = act->tunnel;
 +			if (info) {
 +				encap = true;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Zero tunnel attributes is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			break;
 +		case FLOW_ACTION_VLAN_PUSH:
 +		case FLOW_ACTION_VLAN_POP:
 +			if (act->id == FLOW_ACTION_VLAN_PUSH &&
 +			    (action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP)) {
 +				/* Replace vlan pop+push with vlan modify */
 +				action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +				err = add_vlan_rewrite_action(priv,
 +							      MLX5_FLOW_NAMESPACE_FDB,
 +							      act, parse_attr, hdrs,
 +							      &action, extack);
 +			} else {
 +				err = parse_tc_vlan_action(priv, act, esw_attr, &action, extack);
 +			}
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_FDB,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_TUNNEL_DECAP:
 +			decap = true;
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
 +			break;
++=======
++>>>>>>> ab3f3d5efffa (net/mlx5e: Add mirred/redirect to tc action infra)
  		case FLOW_ACTION_CT:
  			if (flow_flag_test(flow, SAMPLE)) {
  				NL_SET_ERR_MSG_MOD(extack, "Sample action with connection tracking is not supported");
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c
new file mode 100644
index 000000000000..a0832b86016c
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c
@@ -0,0 +1,315 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+#include <linux/if_macvlan.h>
+#include <linux/if_vlan.h>
+#include <net/bareudp.h>
+#include <net/bonding.h>
+#include "act.h"
+#include "vlan.h"
+#include "en/tc_tun_encap.h"
+#include "en/tc_priv.h"
+#include "en_rep.h"
+
+static bool
+same_vf_reps(struct mlx5e_priv *priv, struct net_device *out_dev)
+{
+	return mlx5e_eswitch_vf_rep(priv->netdev) &&
+	       priv->netdev == out_dev;
+}
+
+static int
+verify_uplink_forwarding(struct mlx5e_priv *priv,
+			 struct mlx5_flow_attr *attr,
+			 struct net_device *out_dev,
+			 struct netlink_ext_ack *extack)
+{
+	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+	struct mlx5e_rep_priv *rep_priv;
+
+	/* Forwarding non encapsulated traffic between
+	 * uplink ports is allowed only if
+	 * termination_table_raw_traffic cap is set.
+	 *
+	 * Input vport was stored attr->in_rep.
+	 * In LAG case, *priv* is the private data of
+	 * uplink which may be not the input vport.
+	 */
+	rep_priv = mlx5e_rep_to_rep_priv(attr->esw_attr->in_rep);
+
+	if (!(mlx5e_eswitch_uplink_rep(rep_priv->netdev) &&
+	      mlx5e_eswitch_uplink_rep(out_dev)))
+		return 0;
+
+	if (!MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev,
+					termination_table_raw_traffic)) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "devices are both uplink, can't offload forwarding");
+			pr_err("devices %s %s are both uplink, can't offload forwarding\n",
+			       priv->netdev->name, out_dev->name);
+			return -EOPNOTSUPP;
+	} else if (out_dev != rep_priv->netdev) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "devices are not the same uplink, can't offload forwarding");
+		pr_err("devices %s %s are both uplink but not the same, can't offload forwarding\n",
+		       priv->netdev->name, out_dev->name);
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static bool
+is_duplicated_output_device(struct net_device *dev,
+			    struct net_device *out_dev,
+			    int *ifindexes, int if_count,
+			    struct netlink_ext_ack *extack)
+{
+	int i;
+
+	for (i = 0; i < if_count; i++) {
+		if (ifindexes[i] == out_dev->ifindex) {
+			NL_SET_ERR_MSG_MOD(extack, "can't duplicate output to same device");
+			netdev_err(dev, "can't duplicate output to same device: %s\n",
+				   out_dev->name);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static struct net_device *
+get_fdb_out_dev(struct net_device *uplink_dev, struct net_device *out_dev)
+{
+	struct net_device *fdb_out_dev = out_dev;
+	struct net_device *uplink_upper;
+
+	rcu_read_lock();
+	uplink_upper = netdev_master_upper_dev_get_rcu(uplink_dev);
+	if (uplink_upper && netif_is_lag_master(uplink_upper) &&
+	    uplink_upper == out_dev) {
+		fdb_out_dev = uplink_dev;
+	} else if (netif_is_lag_master(out_dev)) {
+		fdb_out_dev = bond_option_active_slave_get_rcu(netdev_priv(out_dev));
+		if (fdb_out_dev &&
+		    (!mlx5e_eswitch_rep(fdb_out_dev) ||
+		     !netdev_port_same_parent_id(fdb_out_dev, uplink_dev)))
+			fdb_out_dev = NULL;
+	}
+	rcu_read_unlock();
+	return fdb_out_dev;
+}
+
+static bool
+tc_act_can_offload_mirred(struct mlx5e_tc_act_parse_state *parse_state,
+			  const struct flow_action_entry *act,
+			  int act_index)
+{
+	struct netlink_ext_ack *extack = parse_state->extack;
+	struct mlx5e_tc_flow *flow = parse_state->flow;
+	struct mlx5e_tc_flow_parse_attr *parse_attr;
+	struct net_device *out_dev = act->dev;
+	struct mlx5e_priv *priv = flow->priv;
+	struct mlx5_esw_flow_attr *esw_attr;
+
+	parse_attr = flow->attr->parse_attr;
+	esw_attr = flow->attr->esw_attr;
+
+	if (!out_dev) {
+		/* out_dev is NULL when filters with
+		 * non-existing mirred device are replayed to
+		 * the driver.
+		 */
+		return false;
+	}
+
+	if (parse_state->mpls_push && !netif_is_bareudp(out_dev)) {
+		NL_SET_ERR_MSG_MOD(extack, "mpls is supported only through a bareudp device");
+		return false;
+	}
+
+	if (mlx5e_is_ft_flow(flow) && out_dev == priv->netdev) {
+		/* Ignore forward to self rules generated
+		 * by adding both mlx5 devs to the flow table
+		 * block on a normal nft offload setup.
+		 */
+		return false;
+	}
+
+	if (esw_attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "can't support more output ports, can't offload forwarding");
+		netdev_warn(priv->netdev,
+			    "can't support more than %d output ports, can't offload forwarding\n",
+			    esw_attr->out_count);
+		return false;
+	}
+
+	if (parse_state->encap ||
+	    netdev_port_same_parent_id(priv->netdev, out_dev) ||
+	    netif_is_ovs_master(out_dev))
+		return true;
+
+	if (parse_attr->filter_dev != priv->netdev) {
+		/* All mlx5 devices are called to configure
+		 * high level device filters. Therefore, the
+		 * *attempt* to  install a filter on invalid
+		 * eswitch should not trigger an explicit error
+		 */
+		return false;
+	}
+
+	NL_SET_ERR_MSG_MOD(extack, "devices are not on same switch HW, can't offload forwarding");
+	netdev_warn(priv->netdev,
+		    "devices %s %s not on same switch HW, can't offload forwarding\n",
+		    netdev_name(priv->netdev),
+		    out_dev->name);
+
+	return false;
+}
+
+static int
+parse_mirred_encap(struct mlx5e_tc_act_parse_state *parse_state,
+		   const struct flow_action_entry *act,
+		   struct mlx5_flow_attr *attr)
+{
+	struct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;
+	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
+	struct net_device *out_dev = act->dev;
+
+	parse_attr->mirred_ifindex[esw_attr->out_count] = out_dev->ifindex;
+	parse_attr->tun_info[esw_attr->out_count] =
+		mlx5e_dup_tun_info(parse_state->tun_info);
+
+	if (!parse_attr->tun_info[esw_attr->out_count])
+		return -ENOMEM;
+
+	parse_state->encap = false;
+	esw_attr->dests[esw_attr->out_count].flags |= MLX5_ESW_DEST_ENCAP;
+	esw_attr->out_count++;
+	/* attr->dests[].rep is resolved when we handle encap */
+
+	return 0;
+}
+
+static int
+parse_mirred(struct mlx5e_tc_act_parse_state *parse_state,
+	     const struct flow_action_entry *act,
+	     struct mlx5e_priv *priv,
+	     struct mlx5_flow_attr *attr)
+{
+	struct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;
+	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
+	struct netlink_ext_ack *extack = parse_state->extack;
+	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+	struct net_device *out_dev = act->dev;
+	struct net_device *uplink_dev;
+	struct mlx5e_priv *out_priv;
+	struct mlx5_eswitch *esw;
+	int *ifindexes;
+	int if_count;
+	int err;
+
+	esw = priv->mdev->priv.eswitch;
+	uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
+	ifindexes = parse_state->ifindexes;
+	if_count = parse_state->if_count;
+
+	if (is_duplicated_output_device(priv->netdev, out_dev, ifindexes, if_count, extack))
+		return -EOPNOTSUPP;
+
+	parse_state->ifindexes[if_count] = out_dev->ifindex;
+	parse_state->if_count++;
+
+	out_dev = get_fdb_out_dev(uplink_dev, out_dev);
+	if (!out_dev)
+		return -ENODEV;
+
+	if (is_vlan_dev(out_dev)) {
+		err = mlx5e_tc_act_vlan_add_push_action(priv, attr, &out_dev, extack);
+		if (err)
+			return err;
+	}
+
+	if (is_vlan_dev(parse_attr->filter_dev)) {
+		err = mlx5e_tc_act_vlan_add_pop_action(priv, attr, extack);
+		if (err)
+			return err;
+	}
+
+	if (netif_is_macvlan(out_dev))
+		out_dev = macvlan_dev_real_dev(out_dev);
+
+	err = verify_uplink_forwarding(priv, attr, out_dev, extack);
+	if (err)
+		return err;
+
+	if (!mlx5e_is_valid_eswitch_fwd_dev(priv, out_dev)) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "devices are not on same switch HW, can't offload forwarding");
+		return -EOPNOTSUPP;
+	}
+
+	if (same_vf_reps(priv, out_dev)) {
+		NL_SET_ERR_MSG_MOD(extack, "can't forward from a VF to itself");
+		return -EOPNOTSUPP;
+	}
+
+	out_priv = netdev_priv(out_dev);
+	rpriv = out_priv->ppriv;
+	esw_attr->dests[esw_attr->out_count].rep = rpriv->rep;
+	esw_attr->dests[esw_attr->out_count].mdev = out_priv->mdev;
+	esw_attr->out_count++;
+
+	return 0;
+}
+
+static int
+parse_mirred_ovs_master(struct mlx5e_tc_act_parse_state *parse_state,
+			const struct flow_action_entry *act,
+			struct mlx5e_priv *priv,
+			struct mlx5_flow_attr *attr)
+{
+	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
+	struct net_device *out_dev = act->dev;
+	int err;
+
+	err = mlx5e_set_fwd_to_int_port_actions(priv, attr, out_dev->ifindex,
+						MLX5E_TC_INT_PORT_EGRESS,
+						&attr->action, esw_attr->out_count);
+	if (err)
+		return err;
+
+	esw_attr->out_count++;
+	return 0;
+}
+
+static int
+tc_act_parse_mirred(struct mlx5e_tc_act_parse_state *parse_state,
+		    const struct flow_action_entry *act,
+		    struct mlx5e_priv *priv,
+		    struct mlx5_flow_attr *attr)
+{
+	struct net_device *out_dev = act->dev;
+	int err = -EOPNOTSUPP;
+
+	if (parse_state->encap)
+		err = parse_mirred_encap(parse_state, act, attr);
+	else if (netdev_port_same_parent_id(priv->netdev, out_dev))
+		err = parse_mirred(parse_state, act, priv, attr);
+	else if (netif_is_ovs_master(out_dev))
+		err = parse_mirred_ovs_master(parse_state, act, priv, attr);
+
+	if (err)
+		return err;
+
+	attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
+			MLX5_FLOW_CONTEXT_ACTION_COUNT;
+
+	return 0;
+}
+
+struct mlx5e_tc_act mlx5e_tc_act_mirred = {
+	.can_offload = tc_act_can_offload_mirred,
+	.parse_action = tc_act_parse_mirred,
+};
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred_nic.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred_nic.c
new file mode 100644
index 000000000000..2c74567b6d25
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred_nic.c
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+#include "act.h"
+#include "en/tc_priv.h"
+
+static bool
+tc_act_can_offload_mirred_nic(struct mlx5e_tc_act_parse_state *parse_state,
+			      const struct flow_action_entry *act,
+			      int act_index)
+{
+	struct netlink_ext_ack *extack = parse_state->extack;
+	struct mlx5e_tc_flow *flow = parse_state->flow;
+	struct net_device *out_dev = act->dev;
+	struct mlx5e_priv *priv = flow->priv;
+
+	if (act->id != FLOW_ACTION_REDIRECT)
+		return false;
+
+	if (priv->netdev->netdev_ops != out_dev->netdev_ops ||
+	    !mlx5e_same_hw_devs(priv, netdev_priv(out_dev))) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "devices are not on same switch HW, can't offload forwarding");
+		netdev_warn(priv->netdev,
+			    "devices %s %s not on same switch HW, can't offload forwarding\n",
+			    netdev_name(priv->netdev),
+			    out_dev->name);
+		return false;
+	}
+
+	return true;
+}
+
+static int
+tc_act_parse_mirred_nic(struct mlx5e_tc_act_parse_state *parse_state,
+			const struct flow_action_entry *act,
+			struct mlx5e_priv *priv,
+			struct mlx5_flow_attr *attr)
+{
+	attr->parse_attr->mirred_ifindex[0] = act->dev->ifindex;
+	flow_flag_set(parse_state->flow, HAIRPIN);
+	attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
+			MLX5_FLOW_CONTEXT_ACTION_COUNT;
+
+	return 0;
+}
+
+struct mlx5e_tc_act mlx5e_tc_act_mirred_nic = {
+	.can_offload = tc_act_can_offload_mirred_nic,
+	.parse_action = tc_act_parse_mirred_nic,
+};
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
