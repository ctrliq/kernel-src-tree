wifi: mac80211: don't check carrier in chanctx code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Andrei Otcheretianski <andrei.otcheretianski@intel.com>
commit e10b680118774cf43e02f9e1fc84989636d1b5e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/e10b6801.failed

We check here that we don't enable TX (netif_carrier_ok())
before we actually start using some channel context, but to
our knowledge this check has never triggered, and with MLO
it's just wrong since links can be added and removed much
more dynamically than before.

Simply remove the checks, there's no really good way to do
anything that would replace them.

	Signed-off-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit e10b680118774cf43e02f9e1fc84989636d1b5e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/chan.c
diff --cc net/mac80211/chan.c
index 37035c3e5f8a,2e9bc285f0a5..000000000000
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@@ -1856,14 -1983,15 +1854,18 @@@ int ieee80211_vif_change_bandwidth(stru
  	return ret;
  }
  
 -void ieee80211_link_release_channel(struct ieee80211_link_data *link)
 +void ieee80211_vif_release_channel(struct ieee80211_sub_if_data *sdata)
  {
++<<<<<<< HEAD
 +	WARN_ON(sdata->dev && netif_carrier_ok(sdata->dev));
 +
 +	lockdep_assert_held(&sdata->local->mtx);
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
++>>>>>>> e10b68011877 (wifi: mac80211: don't check carrier in chanctx code)
  
  	mutex_lock(&sdata->local->chanctx_mtx);
 -	if (rcu_access_pointer(link->conf->chanctx_conf)) {
 -		lockdep_assert_held(&sdata->local->mtx);
 -		__ieee80211_link_release_channel(link);
 -	}
 +	__ieee80211_vif_release_channel(sdata);
  	mutex_unlock(&sdata->local->chanctx_mtx);
  }
  
* Unmerged path net/mac80211/chan.c
