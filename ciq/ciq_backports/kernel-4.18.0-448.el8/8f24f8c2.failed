efi/libstub: Annotate firmware routines as __efiapi

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 8f24f8c2fc82f701866419dcb594e2cc1d3f46ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8f24f8c2.failed

Annotate all the firmware routines (boot services, runtime services and
protocol methods) called in the boot context as __efiapi, and make
it expand to __attribute__((ms_abi)) on 64-bit x86. This allows us
to use the compiler to generate the calls into firmware that use the
MS calling convention instead of the SysV one.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Cc: Arvind Sankar <nivedita@alum.mit.edu>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: James Morse <james.morse@arm.com>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: https://lkml.kernel.org/r/20191224151025.32482-13-ardb@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8f24f8c2fc82f701866419dcb594e2cc1d3f46ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.h
#	include/linux/efi.h
diff --cc arch/x86/boot/compressed/eboot.h
index 26f1f2635f64,99f35343d443..000000000000
--- a/arch/x86/boot/compressed/eboot.h
+++ b/arch/x86/boot/compressed/eboot.h
@@@ -12,21 -12,12 +12,26 @@@
  
  #define DESC_TYPE_CODE_DATA	(1 << 0)
  
 -typedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;
 +typedef struct {
 +	u32 get_mode;
 +	u32 set_mode;
 +	u32 blt;
 +} efi_uga_draw_protocol_32_t;
  
 -union efi_uga_draw_protocol {
 +typedef struct {
 +	u64 get_mode;
 +	u64 set_mode;
 +	u64 blt;
 +} efi_uga_draw_protocol_64_t;
 +
 +typedef union {
  	struct {
++<<<<<<< HEAD
 +		void *get_mode;
++=======
+ 		efi_status_t (__efiapi *get_mode)(efi_uga_draw_protocol_t *,
+ 						  u32*, u32*, u32*, u32*);
++>>>>>>> 8f24f8c2fc82 (efi/libstub: Annotate firmware routines as __efiapi)
  		void *set_mode;
  		void *blt;
  	};
diff --cc include/linux/efi.h
index 87f30fc4c480,2074b737aa17..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -475,7 -397,11 +490,15 @@@ union efi_pci_io_protocol 
  		void *allocate_buffer;
  		void *free_buffer;
  		void *flush;
++<<<<<<< HEAD
 +		void *get_location;
++=======
+ 		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
+ 						      unsigned long *segment_nr,
+ 						      unsigned long *bus_nr,
+ 						      unsigned long *device_nr,
+ 						      unsigned long *func_nr);
++>>>>>>> 8f24f8c2fc82 (efi/libstub: Annotate firmware routines as __efiapi)
  		void *attributes;
  		void *get_bar_attributes;
  		void *set_bar_attributes;
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 2eab962b1977..44fe4068c2e4 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1994,11 +1994,12 @@ config EFI
 	  platforms.
 
 config EFI_STUB
-       bool "EFI stub support"
-       depends on EFI && !X86_USE_3DNOW
-       select RELOCATABLE
-       ---help---
-          This kernel feature allows a bzImage to be loaded directly
+	bool "EFI stub support"
+	depends on EFI && !X86_USE_3DNOW
+	depends on $(cc-option,-mabi=ms) || X86_32
+	select RELOCATABLE
+	---help---
+	  This kernel feature allows a bzImage to be loaded directly
 	  by EFI firmware without the use of a bootloader.
 
 	  See Documentation/efi-stub.txt for more information.
* Unmerged path arch/x86/boot/compressed/eboot.h
diff --git a/drivers/firmware/efi/libstub/random.c b/drivers/firmware/efi/libstub/random.c
index d0aa79166a50..ccec0dbe07ec 100644
--- a/drivers/firmware/efi/libstub/random.c
+++ b/drivers/firmware/efi/libstub/random.c
@@ -27,10 +27,12 @@ typedef struct {
 
 union efi_rng_protocol {
 	struct {
-		efi_status_t (*get_info)(efi_rng_protocol_t *,
-					 unsigned long *, efi_guid_t *);
-		efi_status_t (*get_rng)(efi_rng_protocol_t *,
-					efi_guid_t *, unsigned long, u8 *out);
+		efi_status_t (__efiapi *get_info)(efi_rng_protocol_t *,
+						  unsigned long *,
+						  efi_guid_t *);
+		efi_status_t (__efiapi *get_rng)(efi_rng_protocol_t *,
+						 efi_guid_t *, unsigned long,
+						 u8 *out);
 	};
 	struct {
 		u32 get_info;
* Unmerged path include/linux/efi.h
