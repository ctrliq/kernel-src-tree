net/mlx5: Lag, move lag files into directory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Maor Gottlieb <maorg@nvidia.com>
commit 3d677735d3b7f00f42cfd57a51d3d2109cf65f87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/3d677735.failed

Downstream patches add another lag related file so it makes
sense to have all the lag files in a dedicated directory.

	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 3d677735d3b7f00f42cfd57a51d3d2109cf65f87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c
index 1d6a85a9f663,810a15b83b9f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c
@@@ -2,8 -2,9 +2,14 @@@
  /* Copyright (c) 2019 Mellanox Technologies. */
  
  #include <linux/netdevice.h>
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
 +#include "lag.h"
 +#include "lag_mp.h"
++=======
+ #include <net/nexthop.h>
+ #include "lag/lag.h"
+ #include "lag/mp.h"
++>>>>>>> 3d677735d3b7 (net/mlx5: Lag, move lag files into directory):drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c
  #include "mlx5_core.h"
  #include "eswitch.h"
  #include "lib/mlx5.h"
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/Makefile b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 478a0ab6470d..cf6093a0fa21 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@ -14,7 +14,7 @@ obj-$(CONFIG_MLX5_CORE) += mlx5_core.o
 mlx5_core-y :=	main.o cmd.o debugfs.o fw.o eq.o uar.o pagealloc.o \
 		health.o mcg.o cq.o alloc.o port.o mr.o pd.o \
 		transobj.o vport.o sriov.o fs_cmd.o fs_core.o pci_irq.o \
-		fs_counters.o fs_ft_pool.o rl.o lag.o dev.o events.o wq.o lib/gid.o \
+		fs_counters.o fs_ft_pool.o rl.o lag/lag.o dev.o events.o wq.o lib/gid.o \
 		lib/devcom.o lib/pci_vsc.o lib/dm.o lib/fs_ttc.o diag/fs_tracepoint.o \
 		diag/fw_tracer.o diag/crdump.o devlink.o diag/rsc_dump.o \
 		fw_reset.o qos.o lib/tout.o
@@ -37,7 +37,7 @@ mlx5_core-$(CONFIG_MLX5_EN_ARFS)     += en_arfs.o
 mlx5_core-$(CONFIG_MLX5_EN_RXNFC)    += en_fs_ethtool.o
 mlx5_core-$(CONFIG_MLX5_CORE_EN_DCB) += en_dcbnl.o en/port_buffer.o
 mlx5_core-$(CONFIG_PCI_HYPERV_INTERFACE) += en/hv_vhca_stats.o
-mlx5_core-$(CONFIG_MLX5_ESWITCH)     += lag_mp.o lib/geneve.o lib/port_tun.o \
+mlx5_core-$(CONFIG_MLX5_ESWITCH)     += lag/mp.o lib/geneve.o lib/port_tun.o \
 					en_rep.o en/rep/bond.o en/mod_hdr.o \
 					en/mapping.o
 mlx5_core-$(CONFIG_MLX5_CLS_ACT)     += en_tc.o en/rep/tc.o en/rep/neigh.o \
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag.c b/drivers/net/ethernet/mellanox/mlx5/core/lag/lag.c
similarity index 99%
rename from drivers/net/ethernet/mellanox/mlx5/core/lag.c
rename to drivers/net/ethernet/mellanox/mlx5/core/lag/lag.c
index ca594cc6ecb7..ab091b9d6b11 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/lag.c
@@ -38,7 +38,7 @@
 #include "mlx5_core.h"
 #include "eswitch.h"
 #include "lag.h"
-#include "lag_mp.h"
+#include "mp.h"
 
 /* General purpose, use for short periods of time.
  * Beware of lock dependencies (preferably, no locks should be acquired
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag.h b/drivers/net/ethernet/mellanox/mlx5/core/lag/lag.h
similarity index 98%
rename from drivers/net/ethernet/mellanox/mlx5/core/lag.h
rename to drivers/net/ethernet/mellanox/mlx5/core/lag/lag.h
index d4bae528954e..c268663c89b4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag/lag.h
@@ -5,7 +5,7 @@
 #define __MLX5_LAG_H__
 
 #include "mlx5_core.h"
-#include "lag_mp.h"
+#include "mp.h"
 
 enum {
 	MLX5_LAG_P1,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag/mp.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h b/drivers/net/ethernet/mellanox/mlx5/core/lag/mp.h
similarity index 100%
rename from drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
rename to drivers/net/ethernet/mellanox/mlx5/core/lag/mp.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
deleted file mode 100644
index 1d6a85a9f663..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
+++ /dev/null
@@ -1,342 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
-/* Copyright (c) 2019 Mellanox Technologies. */
-
-#include <linux/netdevice.h>
-#include "lag.h"
-#include "lag_mp.h"
-#include "mlx5_core.h"
-#include "eswitch.h"
-#include "lib/mlx5.h"
-
-static bool __mlx5_lag_is_multipath(struct mlx5_lag *ldev)
-{
-	return !!(ldev->flags & MLX5_LAG_FLAG_MULTIPATH);
-}
-
-static bool mlx5_lag_multipath_check_prereq(struct mlx5_lag *ldev)
-{
-	if (!mlx5_lag_is_ready(ldev))
-		return false;
-
-	if (__mlx5_lag_is_active(ldev) && !__mlx5_lag_is_multipath(ldev))
-		return false;
-
-	return mlx5_esw_multipath_prereq(ldev->pf[MLX5_LAG_P1].dev,
-					 ldev->pf[MLX5_LAG_P2].dev);
-}
-
-bool mlx5_lag_is_multipath(struct mlx5_core_dev *dev)
-{
-	struct mlx5_lag *ldev;
-	bool res;
-
-	ldev = mlx5_lag_dev(dev);
-	res  = ldev && __mlx5_lag_is_multipath(ldev);
-
-	return res;
-}
-
-/**
- * mlx5_lag_set_port_affinity
- *
- * @ldev: lag device
- * @port:
- *     0 - set normal affinity.
- *     1 - set affinity to port 1.
- *     2 - set affinity to port 2.
- *
- **/
-static void mlx5_lag_set_port_affinity(struct mlx5_lag *ldev,
-				       enum mlx5_lag_port_affinity port)
-{
-	struct lag_tracker tracker;
-
-	if (!__mlx5_lag_is_multipath(ldev))
-		return;
-
-	switch (port) {
-	case MLX5_LAG_NORMAL_AFFINITY:
-		tracker.netdev_state[MLX5_LAG_P1].tx_enabled = true;
-		tracker.netdev_state[MLX5_LAG_P2].tx_enabled = true;
-		tracker.netdev_state[MLX5_LAG_P1].link_up = true;
-		tracker.netdev_state[MLX5_LAG_P2].link_up = true;
-		break;
-	case MLX5_LAG_P1_AFFINITY:
-		tracker.netdev_state[MLX5_LAG_P1].tx_enabled = true;
-		tracker.netdev_state[MLX5_LAG_P1].link_up = true;
-		tracker.netdev_state[MLX5_LAG_P2].tx_enabled = false;
-		tracker.netdev_state[MLX5_LAG_P2].link_up = false;
-		break;
-	case MLX5_LAG_P2_AFFINITY:
-		tracker.netdev_state[MLX5_LAG_P1].tx_enabled = false;
-		tracker.netdev_state[MLX5_LAG_P1].link_up = false;
-		tracker.netdev_state[MLX5_LAG_P2].tx_enabled = true;
-		tracker.netdev_state[MLX5_LAG_P2].link_up = true;
-		break;
-	default:
-		mlx5_core_warn(ldev->pf[MLX5_LAG_P1].dev,
-			       "Invalid affinity port %d", port);
-		return;
-	}
-
-	if (tracker.netdev_state[MLX5_LAG_P1].tx_enabled)
-		mlx5_notifier_call_chain(ldev->pf[MLX5_LAG_P1].dev->priv.events,
-					 MLX5_DEV_EVENT_PORT_AFFINITY,
-					 (void *)0);
-
-	if (tracker.netdev_state[MLX5_LAG_P2].tx_enabled)
-		mlx5_notifier_call_chain(ldev->pf[MLX5_LAG_P2].dev->priv.events,
-					 MLX5_DEV_EVENT_PORT_AFFINITY,
-					 (void *)0);
-
-	mlx5_modify_lag(ldev, &tracker);
-}
-
-static void mlx5_lag_fib_event_flush(struct notifier_block *nb)
-{
-	struct lag_mp *mp = container_of(nb, struct lag_mp, fib_nb);
-
-	flush_workqueue(mp->wq);
-}
-
-struct mlx5_fib_event_work {
-	struct work_struct work;
-	struct mlx5_lag *ldev;
-	unsigned long event;
-	union {
-		struct fib_entry_notifier_info fen_info;
-		struct fib_nh_notifier_info fnh_info;
-	};
-};
-
-static void mlx5_lag_fib_route_event(struct mlx5_lag *ldev,
-				     unsigned long event,
-				     struct fib_info *fi)
-{
-	struct lag_mp *mp = &ldev->lag_mp;
-
-	/* Handle delete event */
-	if (event == FIB_EVENT_ENTRY_DEL) {
-		/* stop track */
-		if (mp->mfi == fi)
-			mp->mfi = NULL;
-		return;
-	}
-
-	/* Handle add/replace event */
-	if (fi->fib_nhs == 1) {
-		if (__mlx5_lag_is_active(ldev)) {
-			struct net_device *nh_dev = fi->fib_nh[0].nh_dev;
-			int i = mlx5_lag_dev_get_netdev_idx(ldev, nh_dev);
-
-			if (i < 0)
-				i = MLX5_LAG_NORMAL_AFFINITY;
-			else
-				++i;
-
-			mlx5_lag_set_port_affinity(ldev, i);
-		}
-		return;
-	}
-
-	if (fi->fib_nhs != 2)
-		return;
-
-	/* Verify next hops are ports of the same hca */
-	if (!(fi->fib_nh[0].nh_dev == ldev->pf[MLX5_LAG_P1].netdev &&
-	      fi->fib_nh[1].nh_dev == ldev->pf[MLX5_LAG_P2].netdev) &&
-	    !(fi->fib_nh[0].nh_dev == ldev->pf[MLX5_LAG_P2].netdev &&
-	      fi->fib_nh[1].nh_dev == ldev->pf[MLX5_LAG_P1].netdev)) {
-		mlx5_core_warn(ldev->pf[MLX5_LAG_P1].dev,
-			       "Multipath offload require two ports of the same HCA\n");
-		return;
-	}
-
-	/* First time we see multipath route */
-	if (!mp->mfi && !__mlx5_lag_is_active(ldev)) {
-		struct lag_tracker tracker;
-
-		tracker = ldev->tracker;
-		mlx5_activate_lag(ldev, &tracker, MLX5_LAG_FLAG_MULTIPATH, false);
-	}
-
-	mlx5_lag_set_port_affinity(ldev, MLX5_LAG_NORMAL_AFFINITY);
-	mp->mfi = fi;
-}
-
-static void mlx5_lag_fib_nexthop_event(struct mlx5_lag *ldev,
-				       unsigned long event,
-				       struct fib_nh *fib_nh,
-				       struct fib_info *fi)
-{
-	struct lag_mp *mp = &ldev->lag_mp;
-
-	/* Check the nh event is related to the route */
-	if (!mp->mfi || mp->mfi != fi)
-		return;
-
-	/* nh added/removed */
-	if (event == FIB_EVENT_NH_DEL) {
-		int i = mlx5_lag_dev_get_netdev_idx(ldev, fib_nh->nh_dev);
-
-		if (i >= 0) {
-			i = (i + 1) % 2 + 1; /* peer port */
-			mlx5_lag_set_port_affinity(ldev, i);
-		}
-	} else if (event == FIB_EVENT_NH_ADD &&
-		   fi->fib_nhs == 2) {
-		mlx5_lag_set_port_affinity(ldev, MLX5_LAG_NORMAL_AFFINITY);
-	}
-}
-
-static void mlx5_lag_fib_update(struct work_struct *work)
-{
-	struct mlx5_fib_event_work *fib_work =
-		container_of(work, struct mlx5_fib_event_work, work);
-	struct mlx5_lag *ldev = fib_work->ldev;
-	struct fib_nh *fib_nh;
-
-	/* Protect internal structures from changes */
-	rtnl_lock();
-	switch (fib_work->event) {
-	case FIB_EVENT_ENTRY_REPLACE:
-	case FIB_EVENT_ENTRY_DEL:
-		mlx5_lag_fib_route_event(ldev, fib_work->event,
-					 fib_work->fen_info.fi);
-		fib_info_put(fib_work->fen_info.fi);
-		break;
-	case FIB_EVENT_NH_ADD:
-	case FIB_EVENT_NH_DEL:
-		fib_nh = fib_work->fnh_info.fib_nh;
-		mlx5_lag_fib_nexthop_event(ldev,
-					   fib_work->event,
-					   fib_work->fnh_info.fib_nh,
-					   fib_nh->nh_parent);
-		fib_info_put(fib_work->fnh_info.fib_nh->nh_parent);
-		break;
-	}
-
-	rtnl_unlock();
-	kfree(fib_work);
-}
-
-static struct mlx5_fib_event_work *
-mlx5_lag_init_fib_work(struct mlx5_lag *ldev, unsigned long event)
-{
-	struct mlx5_fib_event_work *fib_work;
-
-	fib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);
-	if (WARN_ON(!fib_work))
-		return NULL;
-
-	INIT_WORK(&fib_work->work, mlx5_lag_fib_update);
-	fib_work->ldev = ldev;
-	fib_work->event = event;
-
-	return fib_work;
-}
-
-static int mlx5_lag_fib_event(struct notifier_block *nb,
-			      unsigned long event,
-			      void *ptr)
-{
-	struct lag_mp *mp = container_of(nb, struct lag_mp, fib_nb);
-	struct mlx5_lag *ldev = container_of(mp, struct mlx5_lag, lag_mp);
-	struct fib_notifier_info *info = ptr;
-	struct mlx5_fib_event_work *fib_work;
-	struct fib_entry_notifier_info *fen_info;
-	struct fib_nh_notifier_info *fnh_info;
-	struct fib_info *fi;
-
-	if (info->family != AF_INET)
-		return NOTIFY_DONE;
-
-	if (!mlx5_lag_multipath_check_prereq(ldev))
-		return NOTIFY_DONE;
-
-	switch (event) {
-	case FIB_EVENT_ENTRY_REPLACE:
-	case FIB_EVENT_ENTRY_DEL:
-		fen_info = container_of(info, struct fib_entry_notifier_info,
-					info);
-		fi = fen_info->fi;
-		if (fi->fib_dev != ldev->pf[MLX5_LAG_P1].netdev &&
-		    fi->fib_dev != ldev->pf[MLX5_LAG_P2].netdev) {
-			return NOTIFY_DONE;
-		}
-		fib_work = mlx5_lag_init_fib_work(ldev, event);
-		if (!fib_work)
-			return NOTIFY_DONE;
-		fib_work->fen_info = *fen_info;
-		/* Take reference on fib_info to prevent it from being
-		 * freed while work is queued. Release it afterwards.
-		 */
-		fib_info_hold(fib_work->fen_info.fi);
-		break;
-	case FIB_EVENT_NH_ADD:
-	case FIB_EVENT_NH_DEL:
-		fnh_info = container_of(info, struct fib_nh_notifier_info,
-					info);
-		fib_work = mlx5_lag_init_fib_work(ldev, event);
-		if (!fib_work)
-			return NOTIFY_DONE;
-		fib_work->fnh_info = *fnh_info;
-		fib_info_hold(fib_work->fnh_info.fib_nh->nh_parent);
-		break;
-	default:
-		return NOTIFY_DONE;
-	}
-
-	queue_work(mp->wq, &fib_work->work);
-
-	return NOTIFY_DONE;
-}
-
-void mlx5_lag_mp_reset(struct mlx5_lag *ldev)
-{
-	/* Clear mfi, as it might become stale when a route delete event
-	 * has been missed, see mlx5_lag_fib_route_event().
-	 */
-	ldev->lag_mp.mfi = NULL;
-}
-
-int mlx5_lag_mp_init(struct mlx5_lag *ldev)
-{
-	struct lag_mp *mp = &ldev->lag_mp;
-	int err;
-
-	/* always clear mfi, as it might become stale when a route delete event
-	 * has been missed
-	 */
-	mp->mfi = NULL;
-
-	if (mp->fib_nb.notifier_call)
-		return 0;
-
-	mp->wq = create_singlethread_workqueue("mlx5_lag_mp");
-	if (!mp->wq)
-		return -ENOMEM;
-
-	mp->fib_nb.notifier_call = mlx5_lag_fib_event;
-	err = register_fib_notifier(&init_net, &mp->fib_nb,
-				    mlx5_lag_fib_event_flush, NULL);
-	if (err) {
-		destroy_workqueue(mp->wq);
-		mp->fib_nb.notifier_call = NULL;
-	}
-
-	return err;
-}
-
-void mlx5_lag_mp_cleanup(struct mlx5_lag *ldev)
-{
-	struct lag_mp *mp = &ldev->lag_mp;
-
-	if (!mp->fib_nb.notifier_call)
-		return;
-
-	unregister_fib_notifier(&init_net, &mp->fib_nb);
-	destroy_workqueue(mp->wq);
-	mp->fib_nb.notifier_call = NULL;
-	mp->mfi = NULL;
-}
