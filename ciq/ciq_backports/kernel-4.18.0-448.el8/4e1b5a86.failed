s390/uaccess: add missing EX_TABLE entries to __clear_user()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Heiko Carstens <hca@linux.ibm.com>
commit 4e1b5a86a5edfbefc9396d41b0fc1a2ebd0101b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/4e1b5a86.failed

For some exception types the instruction address points behind the
instruction that caused the exception. Take that into account and add
the missing exception table entries.

	Cc: <stable@vger.kernel.org>
	Reviewed-by: Vasily Gorbik <gor@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 4e1b5a86a5edfbefc9396d41b0fc1a2ebd0101b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/lib/uaccess.c
diff --cc arch/s390/lib/uaccess.c
index 555c9a5831cb,720036fb1924..000000000000
--- a/arch/s390/lib/uaccess.c
+++ b/arch/s390/lib/uaccess.c
@@@ -387,8 -155,9 +387,14 @@@ static inline unsigned long clear_user_
  
  	tmp1 = -4096UL;
  	asm volatile(
++<<<<<<< HEAD
 +		"0: .insn ss,0xc80000000000,0(%0,%1),0(%4),0\n"
 +		"   jz	  4f\n"
++=======
+ 		"   lr	  0,%[spec]\n"
+ 		"0: mvcos 0(%1),0(%4),%0\n"
+ 		"6: jz	  4f\n"
++>>>>>>> 4e1b5a86a5ed (s390/uaccess: add missing EX_TABLE entries to __clear_user())
  		"1: algr  %0,%2\n"
  		"   slgr  %1,%2\n"
  		"   j	  0b\n"
@@@ -397,116 -166,15 +403,121 @@@
  		"   slgr  %3,%1\n"
  		"   clgr  %0,%3\n"	/* copy crosses next page boundary? */
  		"   jnh	  5f\n"
++<<<<<<< HEAD
 +		"3: .insn ss,0xc80000000000,0(%3,%1),0(%4),0\n"
 +		"   slgr  %0,%3\n"
++=======
+ 		"3: mvcos 0(%1),0(%4),%3\n"
+ 		"7: slgr  %0,%3\n"
++>>>>>>> 4e1b5a86a5ed (s390/uaccess: add missing EX_TABLE entries to __clear_user())
  		"   j	  5f\n"
  		"4: slgr  %0,%0\n"
  		"5:\n"
- 		EX_TABLE(0b,2b) EX_TABLE(3b,5b)
+ 		EX_TABLE(0b,2b) EX_TABLE(6b,2b) EX_TABLE(3b,5b) EX_TABLE(7b,5b)
  		: "+a" (size), "+a" (to), "+a" (tmp1), "=a" (tmp2)
 -		: "a" (empty_zero_page), [spec] "d" (spec.val)
 -		: "cc", "memory", "0");
 +		: "a" (empty_zero_page), "d" (reg0) : "cc", "memory");
  	return size;
  }
 +
 +static inline unsigned long clear_user_xc(void __user *to, unsigned long size)
 +{
 +	mm_segment_t old_fs;
 +	unsigned long tmp1, tmp2;
 +
 +	old_fs = enable_sacf_uaccess();
 +	asm volatile(
 +		"   sacf  256\n"
 +		"   aghi  %0,-1\n"
 +		"   jo    5f\n"
 +		"   bras  %3,3f\n"
 +		"   xc    0(1,%1),0(%1)\n"
 +		"0: aghi  %0,257\n"
 +		"   la    %2,255(%1)\n" /* %2 = ptr + 255 */
 +		"   srl   %2,12\n"
 +		"   sll   %2,12\n"	/* %2 = (ptr + 255) & -4096 */
 +		"   slgr  %2,%1\n"
 +		"   clgr  %0,%2\n"	/* clear crosses next page boundary? */
 +		"   jnh   5f\n"
 +		"   aghi  %2,-1\n"
 +		"1: ex    %2,0(%3)\n"
 +		"   aghi  %2,1\n"
 +		"   slgr  %0,%2\n"
 +		"   j     5f\n"
 +		"2: xc    0(256,%1),0(%1)\n"
 +		"   la    %1,256(%1)\n"
 +		"3: aghi  %0,-256\n"
 +		"   jnm   2b\n"
 +		"4: ex    %0,0(%3)\n"
 +		"5: slgr  %0,%0\n"
 +		"6: sacf  768\n"
 +		EX_TABLE(1b,6b) EX_TABLE(2b,0b) EX_TABLE(4b,0b)
 +		: "+a" (size), "+a" (to), "=a" (tmp1), "=a" (tmp2)
 +		: : "cc", "memory");
 +	disable_sacf_uaccess(old_fs);
 +	return size;
 +}
 +
 +unsigned long __clear_user(void __user *to, unsigned long size)
 +{
 +	if (copy_with_mvcos())
 +			return clear_user_mvcos(to, size);
 +	return clear_user_xc(to, size);
 +}
  EXPORT_SYMBOL(__clear_user);
 +
 +static inline unsigned long strnlen_user_srst(const char __user *src,
 +					      unsigned long size)
 +{
 +	register unsigned long reg0 asm("0") = 0;
 +	unsigned long tmp1, tmp2;
 +
 +	asm volatile(
 +		"   la    %2,0(%1)\n"
 +		"   la    %3,0(%0,%1)\n"
 +		"   slgr  %0,%0\n"
 +		"   sacf  256\n"
 +		"0: srst  %3,%2\n"
 +		"   jo    0b\n"
 +		"   la    %0,1(%3)\n"	/* strnlen_user results includes \0 */
 +		"   slgr  %0,%1\n"
 +		"1: sacf  768\n"
 +		EX_TABLE(0b,1b)
 +		: "+a" (size), "+a" (src), "=a" (tmp1), "=a" (tmp2)
 +		: "d" (reg0) : "cc", "memory");
 +	return size;
 +}
 +
 +unsigned long __strnlen_user(const char __user *src, unsigned long size)
 +{
 +	mm_segment_t old_fs;
 +	unsigned long len;
 +
 +	if (unlikely(!size))
 +		return 0;
 +	old_fs = enable_sacf_uaccess();
 +	len = strnlen_user_srst(src, size);
 +	disable_sacf_uaccess(old_fs);
 +	return len;
 +}
 +EXPORT_SYMBOL(__strnlen_user);
 +
 +long __strncpy_from_user(char *dst, const char __user *src, long size)
 +{
 +	size_t done, len, offset, len_str;
 +
 +	if (unlikely(size <= 0))
 +		return 0;
 +	done = 0;
 +	do {
 +		offset = (size_t)src & (L1_CACHE_BYTES - 1);
 +		len = min(size - done, L1_CACHE_BYTES - offset);
 +		if (copy_from_user(dst, src, len))
 +			return -EFAULT;
 +		len_str = strnlen(dst, len);
 +		done += len_str;
 +		src += len_str;
 +		dst += len_str;
 +	} while ((len_str == len) && (done < size));
 +	return done;
 +}
 +EXPORT_SYMBOL(__strncpy_from_user);
* Unmerged path arch/s390/lib/uaccess.c
