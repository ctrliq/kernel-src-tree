wifi: mac80211: mlme: transmit assoc frame with address translation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 4ca04ed36478e21b037fc379a7e6f52d0e6d8d52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/4ca04ed3.failed

To transmit the association frame to the right station and
with address translation, use the correct addresses there
and set up the AP address in the configuration earlier so
it's applied during the transmit of auth/assoc frames.

Fixes: 81151ce462e5 ("wifi: mac80211: support MLO authentication/association with one link")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 4ca04ed36478e21b037fc379a7e6f52d0e6d8d52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,8c614daedeb8..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -1094,20 -1085,377 +1094,376 @@@ skip_rates
  	 * If AP doesn't support HT, mark HE and EHT as disabled.
  	 * If on the 5GHz band, make sure it supports VHT.
  	 */
 -	if (assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT ||
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT ||
  	    (sband->band == NL80211_BAND_5GHZ &&
 -	     assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT))
 -		assoc_data->link[link_id].conn_flags |=
 -			IEEE80211_CONN_DISABLE_HE |
 -			IEEE80211_CONN_DISABLE_EHT;
 +	     ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +			        IEEE80211_STA_DISABLE_EHT;
  
 -	/* if present, add any custom IEs that go before HE */
 -	offset = ieee80211_add_before_he_elems(skb, extra_elems,
 -					       extra_elems_len,
 -					       offset);
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		ieee80211_add_he_ie(sdata, skb, sband);
  
 -	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HE)) {
 -		ieee80211_add_he_ie(sdata, skb, sband,
 -				    assoc_data->link[link_id].conn_flags);
 -		ADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_HE_CAPABILITY);
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
 +			ieee80211_add_eht_ie(sdata, skb, sband);
  	}
  
++<<<<<<< HEAD
 +	/* if present, add any custom non-vendor IEs that go after HE */
++=======
+ 	/*
+ 	 * careful - need to know about all the present elems before
+ 	 * calling ieee80211_assoc_add_ml_elem(), so add this one if
+ 	 * we're going to put it after the ML element
+ 	 */
+ 	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
+ 		ADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_EHT_CAPABILITY);
+ 
+ 	if (link_id == assoc_data->assoc_link_id)
+ 		ieee80211_assoc_add_ml_elem(sdata, skb, orig_capab, ext_capa,
+ 					    present_elems);
+ 
+ 	/* crash if somebody gets it wrong */
+ 	present_elems = NULL;
+ 
+ 	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
+ 		ieee80211_add_eht_ie(sdata, skb, sband);
+ 
+ 	if (sband->band == NL80211_BAND_S1GHZ) {
+ 		ieee80211_add_aid_request_ie(sdata, skb);
+ 		ieee80211_add_s1g_capab_ie(sdata, &sband->s1g_cap, skb);
+ 	}
+ 
+ 	if (iftd && iftd->vendor_elems.data && iftd->vendor_elems.len)
+ 		skb_put_data(skb, iftd->vendor_elems.data, iftd->vendor_elems.len);
+ 
+ 	if (link)
+ 		link->u.mgd.conn_flags = assoc_data->link[link_id].conn_flags;
+ 
+ 	return offset;
+ }
+ 
+ static void ieee80211_add_non_inheritance_elem(struct sk_buff *skb,
+ 					       const u16 *outer,
+ 					       const u16 *inner)
+ {
+ 	unsigned int skb_len = skb->len;
+ 	bool added = false;
+ 	int i, j;
+ 	u8 *len, *list_len = NULL;
+ 
+ 	skb_put_u8(skb, WLAN_EID_EXTENSION);
+ 	len = skb_put(skb, 1);
+ 	skb_put_u8(skb, WLAN_EID_EXT_NON_INHERITANCE);
+ 
+ 	for (i = 0; i < PRESENT_ELEMS_MAX && outer[i]; i++) {
+ 		u16 elem = outer[i];
+ 		bool have_inner = false;
+ 		bool at_extension = false;
+ 
+ 		/* should at least be sorted in the sense of normal -> ext */
+ 		WARN_ON(at_extension && elem < PRESENT_ELEM_EXT_OFFS);
+ 
+ 		/* switch to extension list */
+ 		if (!at_extension && elem >= PRESENT_ELEM_EXT_OFFS) {
+ 			at_extension = true;
+ 			if (!list_len)
+ 				skb_put_u8(skb, 0);
+ 			list_len = NULL;
+ 		}
+ 
+ 		for (j = 0; j < PRESENT_ELEMS_MAX && inner[j]; j++) {
+ 			if (elem == inner[j]) {
+ 				have_inner = true;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (have_inner)
+ 			continue;
+ 
+ 		if (!list_len) {
+ 			list_len = skb_put(skb, 1);
+ 			*list_len = 0;
+ 		}
+ 		*list_len += 1;
+ 		skb_put_u8(skb, (u8)elem);
+ 	}
+ 
+ 	if (!added)
+ 		skb_trim(skb, skb_len);
+ 	else
+ 		*len = skb->len - skb_len - 2;
+ }
+ 
+ static void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,
+ 					struct sk_buff *skb, u16 capab,
+ 					const struct element *ext_capa,
+ 					const u16 *outer_present_elems)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_multi_link_elem *ml_elem;
+ 	struct ieee80211_mle_basic_common_info *common;
+ 	const struct wiphy_iftype_ext_capab *ift_ext_capa;
+ 	__le16 eml_capa = 0, mld_capa_ops = 0;
+ 	unsigned int link_id;
+ 	u8 *ml_elem_len;
+ 	void *capab_pos;
+ 
+ 	if (!sdata->vif.valid_links)
+ 		return;
+ 
+ 	ift_ext_capa = cfg80211_get_iftype_ext_capa(local->hw.wiphy,
+ 						    ieee80211_vif_type_p2p(&sdata->vif));
+ 	if (ift_ext_capa) {
+ 		eml_capa = cpu_to_le16(ift_ext_capa->eml_capabilities);
+ 		mld_capa_ops = cpu_to_le16(ift_ext_capa->mld_capa_and_ops);
+ 	}
+ 
+ 	skb_put_u8(skb, WLAN_EID_EXTENSION);
+ 	ml_elem_len = skb_put(skb, 1);
+ 	skb_put_u8(skb, WLAN_EID_EXT_EHT_MULTI_LINK);
+ 	ml_elem = skb_put(skb, sizeof(*ml_elem));
+ 	ml_elem->control =
+ 		cpu_to_le16(IEEE80211_ML_CONTROL_TYPE_BASIC |
+ 			    IEEE80211_MLC_BASIC_PRES_EML_CAPA |
+ 			    IEEE80211_MLC_BASIC_PRES_MLD_CAPA_OP);
+ 	common = skb_put(skb, sizeof(*common));
+ 	common->len = sizeof(*common) +
+ 		      2 + /* EML capabilities */
+ 		      2;  /* MLD capa/ops */
+ 	memcpy(common->mld_mac_addr, sdata->vif.addr, ETH_ALEN);
+ 	skb_put_data(skb, &eml_capa, sizeof(eml_capa));
+ 	/* need indication from userspace to support this */
+ 	mld_capa_ops &= ~cpu_to_le16(IEEE80211_MLD_CAP_OP_TID_TO_LINK_MAP_NEG_SUPP);
+ 	skb_put_data(skb, &mld_capa_ops, sizeof(mld_capa_ops));
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		u16 link_present_elems[PRESENT_ELEMS_MAX] = {};
+ 		const u8 *extra_elems;
+ 		size_t extra_elems_len;
+ 		size_t extra_used;
+ 		u8 *subelem_len = NULL;
+ 		__le16 ctrl;
+ 
+ 		if (!assoc_data->link[link_id].bss ||
+ 		    link_id == assoc_data->assoc_link_id)
+ 			continue;
+ 
+ 		extra_elems = assoc_data->link[link_id].elems;
+ 		extra_elems_len = assoc_data->link[link_id].elems_len;
+ 
+ 		skb_put_u8(skb, IEEE80211_MLE_SUBELEM_PER_STA_PROFILE);
+ 		subelem_len = skb_put(skb, 1);
+ 
+ 		ctrl = cpu_to_le16(link_id |
+ 				   IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE |
+ 				   IEEE80211_MLE_STA_CONTROL_STA_MAC_ADDR_PRESENT);
+ 		skb_put_data(skb, &ctrl, sizeof(ctrl));
+ 		skb_put_u8(skb, 1 + ETH_ALEN); /* STA Info Length */
+ 		skb_put_data(skb, assoc_data->link[link_id].addr,
+ 			     ETH_ALEN);
+ 		/*
+ 		 * Now add the contents of the (re)association request,
+ 		 * but the "listen interval" and "current AP address"
+ 		 * (if applicable) are skipped. So we only have
+ 		 * the capability field (remember the position and fill
+ 		 * later), followed by the elements added below by
+ 		 * calling ieee80211_assoc_link_elems().
+ 		 */
+ 		capab_pos = skb_put(skb, 2);
+ 
+ 		extra_used = ieee80211_assoc_link_elems(sdata, skb, &capab,
+ 							ext_capa,
+ 							extra_elems,
+ 							extra_elems_len,
+ 							link_id, NULL,
+ 							link_present_elems);
+ 		if (extra_elems)
+ 			skb_put_data(skb, extra_elems + extra_used,
+ 				     extra_elems_len - extra_used);
+ 
+ 		put_unaligned_le16(capab, capab_pos);
+ 
+ 		ieee80211_add_non_inheritance_elem(skb, outer_present_elems,
+ 						   link_present_elems);
+ 
+ 		ieee80211_fragment_element(skb, subelem_len);
+ 	}
+ 
+ 	ieee80211_fragment_element(skb, ml_elem_len);
+ }
+ 
+ static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_link_data *link;
+ 	struct sk_buff *skb;
+ 	struct ieee80211_mgmt *mgmt;
+ 	u8 *pos, qos_info, *ie_start;
+ 	size_t offset, noffset;
+ 	u16 capab = WLAN_CAPABILITY_ESS, link_capab;
+ 	__le16 listen_int;
+ 	struct element *ext_capa = NULL;
+ 	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
+ 	struct ieee80211_prep_tx_info info = {};
+ 	unsigned int link_id, n_links = 0;
+ 	u16 present_elems[PRESENT_ELEMS_MAX] = {};
+ 	void *capab_pos;
+ 	size_t size;
+ 	int ret;
+ 
+ 	/* we know it's writable, cast away the const */
+ 	if (assoc_data->ie_len)
+ 		ext_capa = (void *)cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,
+ 						      assoc_data->ie,
+ 						      assoc_data->ie_len);
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	size = local->hw.extra_tx_headroom +
+ 	       sizeof(*mgmt) + /* bit too much but doesn't matter */
+ 	       2 + assoc_data->ssid_len + /* SSID */
+ 	       assoc_data->ie_len + /* extra IEs */
+ 	       (assoc_data->fils_kek_len ? 16 /* AES-SIV */ : 0) +
+ 	       9; /* WMM */
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
+ 		const struct ieee80211_sband_iftype_data *iftd;
+ 		struct ieee80211_supported_band *sband;
+ 
+ 		if (!cbss)
+ 			continue;
+ 
+ 		sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
+ 		n_links++;
+ 		/* add STA profile elements length */
+ 		size += assoc_data->link[link_id].elems_len;
+ 		/* and supported rates length */
+ 		size += 4 + sband->n_bitrates;
+ 		/* supported channels */
+ 		size += 2 + 2 * sband->n_channels;
+ 
+ 		iftd = ieee80211_get_sband_iftype_data(sband, iftype);
+ 		if (iftd)
+ 			size += iftd->vendor_elems.len;
+ 
+ 		/* power capability */
+ 		size += 4;
+ 
+ 		/* HT, VHT, HE, EHT */
+ 		size += 2 + sizeof(struct ieee80211_ht_cap);
+ 		size += 2 + sizeof(struct ieee80211_vht_cap);
+ 		size += 2 + 1 + sizeof(struct ieee80211_he_cap_elem) +
+ 			sizeof(struct ieee80211_he_mcs_nss_supp) +
+ 			IEEE80211_HE_PPE_THRES_MAX_LEN;
+ 
+ 		if (sband->band == NL80211_BAND_6GHZ)
+ 			size += 2 + 1 + sizeof(struct ieee80211_he_6ghz_capa);
+ 
+ 		size += 2 + 1 + sizeof(struct ieee80211_eht_cap_elem) +
+ 			sizeof(struct ieee80211_eht_mcs_nss_supp) +
+ 			IEEE80211_EHT_PPE_THRES_MAX_LEN;
+ 
+ 		/* non-inheritance element */
+ 		size += 2 + 2 + PRESENT_ELEMS_MAX;
+ 
+ 		/* should be the same across all BSSes */
+ 		if (cbss->capability & WLAN_CAPABILITY_PRIVACY)
+ 			capab |= WLAN_CAPABILITY_PRIVACY;
+ 	}
+ 
+ 	if (sdata->vif.valid_links) {
+ 		/* consider the multi-link element with STA profile */
+ 		size += sizeof(struct ieee80211_multi_link_elem);
+ 		/* max common info field in basic multi-link element */
+ 		size += sizeof(struct ieee80211_mle_basic_common_info) +
+ 			2 + /* capa & op */
+ 			2; /* EML capa */
+ 
+ 		/*
+ 		 * The capability elements were already considered above;
+ 		 * note this over-estimates a bit because there's no
+ 		 * STA profile for the assoc link.
+ 		 */
+ 		size += (n_links - 1) *
+ 			(1 + 1 + /* subelement ID/length */
+ 			 2 + /* STA control */
+ 			 1 + ETH_ALEN + 2 /* STA Info field */);
+ 	}
+ 
+ 	link = sdata_dereference(sdata->link[assoc_data->assoc_link_id], sdata);
+ 	if (WARN_ON(!link))
+ 		return -EINVAL;
+ 
+ 	if (WARN_ON(!assoc_data->link[assoc_data->assoc_link_id].bss))
+ 		return -EINVAL;
+ 
+ 	skb = alloc_skb(size, GFP_KERNEL);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	skb_reserve(skb, local->hw.extra_tx_headroom);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_ENABLE_RRM)
+ 		capab |= WLAN_CAPABILITY_RADIO_MEASURE;
+ 
+ 	/* Set MBSSID support for HE AP if needed */
+ 	if (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
+ 	    ext_capa && ext_capa->datalen >= 3)
+ 		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
+ 
+ 	mgmt = skb_put_zero(skb, 24);
+ 	memcpy(mgmt->da, sdata->vif.cfg.ap_addr, ETH_ALEN);
+ 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+ 	memcpy(mgmt->bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
+ 
+ 	listen_int = cpu_to_le16(assoc_data->s1g ?
+ 			ieee80211_encode_usf(local->hw.conf.listen_interval) :
+ 			local->hw.conf.listen_interval);
+ 	if (!is_zero_ether_addr(assoc_data->prev_ap_addr)) {
+ 		skb_put(skb, 10);
+ 		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+ 						  IEEE80211_STYPE_REASSOC_REQ);
+ 		capab_pos = &mgmt->u.reassoc_req.capab_info;
+ 		mgmt->u.reassoc_req.listen_interval = listen_int;
+ 		memcpy(mgmt->u.reassoc_req.current_ap,
+ 		       assoc_data->prev_ap_addr, ETH_ALEN);
+ 		info.subtype = IEEE80211_STYPE_REASSOC_REQ;
+ 	} else {
+ 		skb_put(skb, 4);
+ 		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+ 						  IEEE80211_STYPE_ASSOC_REQ);
+ 		capab_pos = &mgmt->u.assoc_req.capab_info;
+ 		mgmt->u.assoc_req.listen_interval = listen_int;
+ 		info.subtype = IEEE80211_STYPE_ASSOC_REQ;
+ 	}
+ 
+ 	/* SSID */
+ 	pos = skb_put(skb, 2 + assoc_data->ssid_len);
+ 	ie_start = pos;
+ 	*pos++ = WLAN_EID_SSID;
+ 	*pos++ = assoc_data->ssid_len;
+ 	memcpy(pos, assoc_data->ssid, assoc_data->ssid_len);
+ 
+ 	/* add the elements for the assoc (main) link */
+ 	link_capab = capab;
+ 	offset = ieee80211_assoc_link_elems(sdata, skb, &link_capab,
+ 					    ext_capa,
+ 					    assoc_data->ie,
+ 					    assoc_data->ie_len,
+ 					    assoc_data->assoc_link_id, link,
+ 					    present_elems);
+ 	put_unaligned_le16(link_capab, capab_pos);
+ 
+ 	/* if present, add any custom non-vendor IEs */
++>>>>>>> 4ca04ed36478 (wifi: mac80211: mlme: transmit assoc frame with address translation)
  	if (assoc_data->ie_len) {
  		noffset = ieee80211_ie_split_vendor(assoc_data->ie,
  						    assoc_data->ie_len,
@@@ -5541,153 -4786,1665 +5897,1666 @@@ static int ieee80211_prep_channel(struc
  	return ret;
  }
  
- static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
- 			       u8 *dtim_count, u8 *dtim_period)
++<<<<<<< HEAD
++=======
+ static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_mgmt *mgmt,
+ 				    struct ieee802_11_elems *elems,
+ 				    const u8 *elem_start, unsigned int elem_len)
  {
- 	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
- 	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
- 					 ies->len);
- 	const struct ieee80211_tim_ie *tim = NULL;
- 	const struct ieee80211_bssid_index *idx;
- 	bool valid = tim_ie && tim_ie[1] >= 2;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id;
+ 	struct sta_info *sta;
+ 	u64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};
+ 	int err;
  
- 	if (valid)
- 		tim = (void *)(tim_ie + 2);
+ 	mutex_lock(&sdata->local->sta_mtx);
+ 	/*
+ 	 * station info was already allocated and inserted before
+ 	 * the association and should be available to us
+ 	 */
+ 	sta = sta_info_get(sdata, assoc_data->ap_addr);
+ 	if (WARN_ON(!sta))
+ 		goto out_err;
  
- 	if (dtim_count)
- 		*dtim_count = valid ? tim->dtim_count : 0;
+ 	if (sdata->vif.valid_links) {
+ 		u16 valid_links = 0;
  
- 	if (dtim_period)
- 		*dtim_period = valid ? tim->dtim_period : 0;
+ 		for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 			if (!assoc_data->link[link_id].bss)
+ 				continue;
+ 			valid_links |= BIT(link_id);
  
- 	/* Check if value is overridden by non-transmitted profile */
- 	if (!idx_ie || idx_ie[1] < 3)
- 		return valid;
+ 			if (link_id != assoc_data->assoc_link_id) {
+ 				err = ieee80211_sta_allocate_link(sta, link_id);
+ 				if (err)
+ 					goto out_err;
+ 			}
+ 		}
  
- 	idx = (void *)(idx_ie + 2);
+ 		ieee80211_vif_set_links(sdata, valid_links);
+ 	}
  
- 	if (dtim_count)
- 		*dtim_count = idx->dtim_count;
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 		struct link_sta_info *link_sta;
  
- 	if (dtim_period)
- 		*dtim_period = idx->dtim_period;
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
  
- 	return true;
- }
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (WARN_ON(!link))
+ 			goto out_err;
+ 
+ 		if (sdata->vif.valid_links)
+ 			link_info(link,
+ 				  "local address %pM, AP link address %pM\n",
+ 				  link->conf->addr,
+ 				  assoc_data->link[link_id].bss->bssid);
+ 
+ 		link_sta = rcu_dereference_protected(sta->link[link_id],
+ 						     lockdep_is_held(&local->sta_mtx));
+ 		if (WARN_ON(!link_sta))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_prep_channel(sdata, link,
+ 						     assoc_data->link[link_id].bss,
+ 						     &link->u.mgd.conn_flags);
+ 			if (err)
+ 				goto out_err;
+ 		}
  
- static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
- 				     struct cfg80211_bss *cbss, bool assoc,
- 				     bool override)
- {
- 	struct ieee80211_local *local = sdata->local;
- 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
- 	struct ieee80211_bss *bss = (void *)cbss->priv;
- 	struct sta_info *new_sta = NULL;
- 	struct ieee80211_supported_band *sband;
- 	bool have_sta = false;
- 	int err;
+ 		err = ieee80211_mgd_setup_link_sta(link, sta, link_sta,
+ 						   assoc_data->link[link_id].bss);
+ 		if (err)
+ 			goto out_err;
+ 
+ 		if (!ieee80211_assoc_config_link(link, link_sta,
+ 						 assoc_data->link[link_id].bss,
+ 						 mgmt, elem_start, elem_len,
+ 						 &changed[link_id]))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_sta_activate_link(sta, link_id);
+ 			if (err)
+ 				goto out_err;
+ 		}
+ 	}
  
- 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 	rate_control_rate_init(sta);
  
- 	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data))
- 		return -EINVAL;
+ 	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
+ 		set_sta_flag(sta, WLAN_STA_MFP);
+ 		sta->sta.mfp = true;
+ 	} else {
+ 		sta->sta.mfp = false;
+ 	}
  
- 	/* If a reconfig is happening, bail out */
- 	if (local->in_reconfig)
- 		return -EBUSY;
+ 	ieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,
+ 					      elems->ext_capab_len);
  
- 	if (assoc) {
- 		rcu_read_lock();
- 		have_sta = sta_info_get(sdata, cbss->bssid);
- 		rcu_read_unlock();
- 	}
+ 	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
+ 		       local->hw.queues >= IEEE80211_NUM_ACS;
  
- 	if (!have_sta) {
- 		new_sta = sta_info_alloc(sdata, cbss->bssid, GFP_KERNEL);
- 		if (!new_sta)
- 			return -ENOMEM;
+ 	err = sta_info_move_state(sta, IEEE80211_STA_ASSOC);
+ 	if (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
+ 		err = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);
+ 	if (err) {
+ 		sdata_info(sdata,
+ 			   "failed to move station %pM to desired state\n",
+ 			   sta->sta.addr);
+ 		WARN_ON(__sta_info_destroy(sta));
+ 		goto out_err;
  	}
  
- 	/*
- 	 * Set up the information for the new channel before setting the
- 	 * new channel. We can't - completely race-free - change the basic
- 	 * rates bitmap and the channel (sband) that it refers to, but if
- 	 * we set it up before we at least avoid calling into the driver's
- 	 * bss_info_changed() method with invalid information (since we do
- 	 * call that from changing the channel - only for IDLE and perhaps
- 	 * some others, but ...).
- 	 *
- 	 * So to avoid that, just set up all the new information before the
- 	 * channel, but tell the driver to apply it only afterwards, since
- 	 * it might need the new channel for that.
- 	 */
- 	if (new_sta) {
- 		u32 rates = 0, basic_rates = 0;
- 		bool have_higher_than_11mbit = false;
- 		int min_rate = INT_MAX, min_rate_index = -1;
- 		const struct cfg80211_bss_ies *ies;
- 		int shift = ieee80211_vif_get_shift(&sdata->vif);
+ 	if (sdata->wdev.use_4addr)
+ 		drv_sta_set_4addr(local, sdata, &sta->sta, true);
  
- 		/* TODO: S1G Basic Rate Set is expressed elsewhere */
- 		if (cbss->channel->band == NL80211_BAND_S1GHZ) {
- 			ieee80211_s1g_sta_rate_init(new_sta);
- 			goto skip_rates;
- 		}
+ 	mutex_unlock(&sdata->local->sta_mtx);
  
- 		ieee80211_get_rates(sband, bss->supp_rates,
- 				    bss->supp_rates_len,
- 				    &rates, &basic_rates,
- 				    &have_higher_than_11mbit,
- 				    &min_rate, &min_rate_index,
- 				    shift);
+ 	ieee80211_set_associated(sdata, assoc_data, changed);
+ 
+ 	/*
+ 	 * If we're using 4-addr mode, let the AP know that we're
+ 	 * doing so, so that it can create the STA VLAN on its side
+ 	 */
+ 	if (ifmgd->use_4addr)
+ 		ieee80211_send_4addr_nullfunc(local, sdata);
+ 
+ 	/*
+ 	 * Start timer to probe the connection to the AP now.
+ 	 * Also start the timer that will detect beacon loss.
+ 	 */
+ 	ieee80211_sta_reset_beacon_monitor(sdata);
+ 	ieee80211_sta_reset_conn_monitor(sdata);
+ 
+ 	return true;
+ out_err:
+ 	eth_zero_addr(sdata->vif.cfg.ap_addr);
+ 	mutex_unlock(&sdata->local->sta_mtx);
+ 	return false;
+ }
+ 
+ static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
+ 					 struct ieee80211_mgmt *mgmt,
+ 					 size_t len)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	u16 capab_info, status_code, aid;
+ 	struct ieee802_11_elems *elems;
+ 	int ac;
+ 	const u8 *elem_start;
+ 	unsigned int elem_len;
+ 	bool reassoc;
+ 	struct ieee80211_event event = {
+ 		.type = MLME_EVENT,
+ 		.u.mlme.data = ASSOC_EVENT,
+ 	};
+ 	struct ieee80211_prep_tx_info info = {};
+ 	struct cfg80211_rx_assoc_resp resp = {
+ 		.uapsd_queues = -1,
+ 	};
+ 	unsigned int link_id;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	if (!assoc_data)
+ 		return;
+ 
+ 	if (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) ||
+ 	    !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))
+ 		return;
+ 
+ 	/*
+ 	 * AssocResp and ReassocResp have identical structure, so process both
+ 	 * of them in this function.
+ 	 */
+ 
+ 	if (len < 24 + 6)
+ 		return;
+ 
+ 	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
+ 	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
+ 	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
+ 	if (assoc_data->s1g)
+ 		elem_start = mgmt->u.s1g_assoc_resp.variable;
+ 	else
+ 		elem_start = mgmt->u.assoc_resp.variable;
+ 
+ 	/*
+ 	 * Note: this may not be perfect, AP might misbehave - if
+ 	 * anyone needs to rely on perfect complete notification
+ 	 * with the exact right subtype, then we need to track what
+ 	 * we actually transmitted.
+ 	 */
+ 	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
+ 				 IEEE80211_STYPE_ASSOC_REQ;
+ 
+ 	if (assoc_data->fils_kek_len &&
+ 	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
+ 		return;
+ 
+ 	elem_len = len - (elem_start - (u8 *)mgmt);
+ 	elems = ieee802_11_parse_elems(elem_start, elem_len, false, NULL);
+ 	if (!elems)
+ 		goto notify_driver;
+ 
+ 	if (elems->aid_resp)
+ 		aid = le16_to_cpu(elems->aid_resp->aid);
+ 	else if (assoc_data->s1g)
+ 		aid = 0; /* TODO */
+ 	else
+ 		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+ 
+ 	/*
+ 	 * The 5 MSB of the AID field are reserved
+ 	 * (802.11-2016 9.4.1.8 AID field)
+ 	 */
+ 	aid &= 0x7ff;
+ 
+ 	sdata_info(sdata,
+ 		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
+ 		   reassoc ? "Rea" : "A", assoc_data->ap_addr,
+ 		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
+ 
+ 	ifmgd->broken_ap = false;
+ 
+ 	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
+ 	    elems->timeout_int &&
+ 	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
+ 		u32 tu, ms;
+ 
+ 		cfg80211_assoc_comeback(sdata->dev, assoc_data->ap_addr,
+ 					le32_to_cpu(elems->timeout_int->value));
+ 
+ 		tu = le32_to_cpu(elems->timeout_int->value);
+ 		ms = tu * 1024 / 1000;
+ 		sdata_info(sdata,
+ 			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
+ 			   assoc_data->ap_addr, tu, ms);
+ 		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
+ 		assoc_data->timeout_started = true;
+ 		if (ms > IEEE80211_ASSOC_TIMEOUT)
+ 			run_again(sdata, assoc_data->timeout);
+ 		goto notify_driver;
+ 	}
+ 
+ 	if (status_code != WLAN_STATUS_SUCCESS) {
+ 		sdata_info(sdata, "%pM denied association (code=%d)\n",
+ 			   assoc_data->ap_addr, status_code);
+ 		event.u.mlme.status = MLME_DENIED;
+ 		event.u.mlme.reason = status_code;
+ 		drv_event_callback(sdata->local, sdata, &event);
+ 	} else {
+ 		if (aid == 0 || aid > IEEE80211_MAX_AID) {
+ 			sdata_info(sdata,
+ 				   "invalid AID value %d (out of range), turn off PS\n",
+ 				   aid);
+ 			aid = 0;
+ 			ifmgd->broken_ap = true;
+ 		}
+ 
+ 		if (sdata->vif.valid_links) {
+ 			if (!elems->multi_link) {
+ 				sdata_info(sdata,
+ 					   "MLO association with %pM but no multi-link element in response!\n",
+ 					   assoc_data->ap_addr);
+ 				goto abandon_assoc;
+ 			}
+ 
+ 			if (le16_get_bits(elems->multi_link->control,
+ 					  IEEE80211_ML_CONTROL_TYPE) !=
+ 					IEEE80211_ML_CONTROL_TYPE_BASIC) {
+ 				sdata_info(sdata,
+ 					   "bad multi-link element (control=0x%x)\n",
+ 					   le16_to_cpu(elems->multi_link->control));
+ 				goto abandon_assoc;
+ 			} else {
+ 				struct ieee80211_mle_basic_common_info *common;
+ 
+ 				common = (void *)elems->multi_link->variable;
+ 
+ 				if (memcmp(assoc_data->ap_addr,
+ 					   common->mld_mac_addr, ETH_ALEN)) {
+ 					sdata_info(sdata,
+ 						   "AP MLD MAC address mismatch: got %pM expected %pM\n",
+ 						   common->mld_mac_addr,
+ 						   assoc_data->ap_addr);
+ 					goto abandon_assoc;
+ 				}
+ 			}
+ 		}
+ 
+ 		sdata->vif.cfg.aid = aid;
+ 
+ 		if (!ieee80211_assoc_success(sdata, mgmt, elems,
+ 					     elem_start, elem_len)) {
+ 			/* oops -- internal error -- send timeout for now */
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
+ 			goto notify_driver;
+ 		}
+ 		event.u.mlme.status = MLME_SUCCESS;
+ 		drv_event_callback(sdata->local, sdata, &event);
+ 		sdata_info(sdata, "associated\n");
+ 
+ 		info.success = 1;
+ 	}
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (!link)
+ 			continue;
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 		resp.links[link_id].bss = assoc_data->link[link_id].bss;
+ 		resp.links[link_id].addr = link->conf->addr;
+ 
+ 		/* get uapsd queues configuration - same for all links */
+ 		resp.uapsd_queues = 0;
+ 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+ 			if (link->tx_conf[ac].uapsd)
+ 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+ 	}
+ 
+ 	ieee80211_destroy_assoc_data(sdata,
+ 				     status_code == WLAN_STATUS_SUCCESS ?
+ 					ASSOC_SUCCESS :
+ 					ASSOC_REJECTED);
+ 
+ 	resp.buf = (u8 *)mgmt;
+ 	resp.len = len;
+ 	resp.req_ies = ifmgd->assoc_req_ies;
+ 	resp.req_ies_len = ifmgd->assoc_req_ies_len;
+ 	if (sdata->vif.valid_links)
+ 		resp.ap_mld_addr = assoc_data->ap_addr;
+ 	cfg80211_rx_assoc_resp(sdata->dev, &resp);
+ notify_driver:
+ 	drv_mgd_complete_tx(sdata->local, sdata, &info);
+ 	kfree(elems);
+ 	return;
+ abandon_assoc:
+ 	ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 	goto notify_driver;
+ }
+ 
+ static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
+ 				  struct ieee80211_mgmt *mgmt, size_t len,
+ 				  struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_bss *bss;
+ 	struct ieee80211_channel *channel;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	channel = ieee80211_get_channel_khz(local->hw.wiphy,
+ 					ieee80211_rx_status_to_khz(rx_status));
+ 	if (!channel)
+ 		return;
+ 
+ 	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
+ 	if (bss) {
+ 		link->conf->beacon_rate = bss->beacon_rate;
+ 		ieee80211_rx_bss_put(local, bss);
+ 	}
+ }
+ 
+ 
+ static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_link_data *link,
+ 					 struct sk_buff *skb)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+ 	struct ieee80211_if_managed *ifmgd;
+ 	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
+ 	struct ieee80211_channel *channel;
+ 	size_t baselen, len = skb->len;
+ 
+ 	ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	/*
+ 	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
+ 	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
+ 	 * a Probe Response frame [..], the Address 1 field of the Probe
+ 	 * Response frame shall be set to the broadcast address [..]"
+ 	 * So, on 6GHz band we should also accept broadcast responses.
+ 	 */
+ 	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
+ 					rx_status->freq);
+ 	if (!channel)
+ 		return;
+ 
+ 	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
+ 	    (channel->band != NL80211_BAND_6GHZ ||
+ 	     !is_broadcast_ether_addr(mgmt->da)))
+ 		return; /* ignore ProbeResp to foreign address */
+ 
+ 	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+ 	if (baselen > len)
+ 		return;
+ 
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 	if (ifmgd->associated &&
+ 	    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))
+ 		ieee80211_reset_ap_probe(sdata);
+ }
+ 
+ /*
+  * This is the canonical list of information elements we care about,
+  * the filter code also gives us all changes to the Microsoft OUI
+  * (00:50:F2) vendor IE which is used for WMM which we need to track,
+  * as well as the DTPC IE (part of the Cisco OUI) used for signaling
+  * changes to requested client power.
+  *
+  * We implement beacon filtering in software since that means we can
+  * avoid processing the frame here and in cfg80211, and userspace
+  * will not be able to tell whether the hardware supports it or not.
+  *
+  * XXX: This list needs to be dynamic -- userspace needs to be able to
+  *	add items it requires. It also needs to be able to tell us to
+  *	look out for other vendor IEs.
+  */
+ static const u64 care_about_ies =
+ 	(1ULL << WLAN_EID_COUNTRY) |
+ 	(1ULL << WLAN_EID_ERP_INFO) |
+ 	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
+ 	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
+ 	(1ULL << WLAN_EID_HT_CAPABILITY) |
+ 	(1ULL << WLAN_EID_HT_OPERATION) |
+ 	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
+ 
+ static void ieee80211_handle_beacon_sig(struct ieee80211_link_data *link,
+ 					struct ieee80211_if_managed *ifmgd,
+ 					struct ieee80211_bss_conf *bss_conf,
+ 					struct ieee80211_local *local,
+ 					struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 
+ 	/* Track average RSSI from the Beacon frames of the current AP */
+ 
+ 	if (!link->u.mgd.tracking_signal_avg) {
+ 		link->u.mgd.tracking_signal_avg = true;
+ 		ewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);
+ 		link->u.mgd.last_cqm_event_signal = 0;
+ 		link->u.mgd.count_beacon_signal = 1;
+ 		link->u.mgd.last_ave_beacon_signal = 0;
+ 	} else {
+ 		link->u.mgd.count_beacon_signal++;
+ 	}
+ 
+ 	ewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,
+ 			       -rx_status->signal);
+ 
+ 	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_sig = link->u.mgd.last_ave_beacon_signal;
+ 		struct ieee80211_event event = {
+ 			.type = RSSI_EVENT,
+ 		};
+ 
+ 		/*
+ 		 * if signal crosses either of the boundaries, invoke callback
+ 		 * with appropriate parameters
+ 		 */
+ 		if (sig > ifmgd->rssi_max_thold &&
+ 		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
+ 			link->u.mgd.last_ave_beacon_signal = sig;
+ 			event.u.rssi.data = RSSI_EVENT_HIGH;
+ 			drv_event_callback(local, sdata, &event);
+ 		} else if (sig < ifmgd->rssi_min_thold &&
+ 			   (last_sig >= ifmgd->rssi_max_thold ||
+ 			   last_sig == 0)) {
+ 			link->u.mgd.last_ave_beacon_signal = sig;
+ 			event.u.rssi.data = RSSI_EVENT_LOW;
+ 			drv_event_callback(local, sdata, &event);
+ 		}
+ 	}
+ 
+ 	if (bss_conf->cqm_rssi_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
+ 	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
+ 		int thold = bss_conf->cqm_rssi_thold;
+ 		int hyst = bss_conf->cqm_rssi_hyst;
+ 
+ 		if (sig < thold &&
+ 		    (last_event == 0 || sig < last_event - hyst)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+ 				sig, GFP_KERNEL);
+ 		} else if (sig > thold &&
+ 			   (last_event == 0 || sig > last_event + hyst)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+ 				sig, GFP_KERNEL);
+ 		}
+ 	}
+ 
+ 	if (bss_conf->cqm_rssi_low &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
+ 		int low = bss_conf->cqm_rssi_low;
+ 		int high = bss_conf->cqm_rssi_high;
+ 
+ 		if (sig < low &&
+ 		    (last_event == 0 || last_event >= low)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+ 				sig, GFP_KERNEL);
+ 		} else if (sig > high &&
+ 			   (last_event == 0 || last_event <= high)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+ 				sig, GFP_KERNEL);
+ 		}
+ 	}
+ }
+ 
+ static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
+ 				    struct cfg80211_bss *bss)
+ {
+ 	if (ether_addr_equal(tx_bssid, bss->bssid))
+ 		return true;
+ 	if (!bss->transmitted_bss)
+ 		return false;
+ 	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
+ }
+ 
+ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,
+ 				     struct ieee80211_hdr *hdr, size_t len,
+ 				     struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 	struct ieee80211_mgmt *mgmt = (void *) hdr;
+ 	size_t baselen;
+ 	struct ieee802_11_elems *elems;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	struct ieee80211_channel *chan;
+ 	struct link_sta_info *link_sta;
+ 	struct sta_info *sta;
+ 	u32 changed = 0;
+ 	bool erp_valid;
+ 	u8 erp_value = 0;
+ 	u32 ncrc = 0;
+ 	u8 *bssid, *variable = mgmt->u.beacon.variable;
+ 	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	/* Process beacon from the current BSS */
+ 	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
+ 	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
+ 		struct ieee80211_ext *ext = (void *) mgmt;
+ 
+ 		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
+ 			variable = ext->u.s1g_short_beacon.variable;
+ 		else
+ 			variable = ext->u.s1g_beacon.variable;
+ 	}
+ 
+ 	baselen = (u8 *) variable - (u8 *) mgmt;
+ 	if (baselen > len)
+ 		return;
+ 
+ 	rcu_read_lock();
+ 	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
+ 	if (!chanctx_conf) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 
+ 	if (ieee80211_rx_status_to_khz(rx_status) !=
+ 	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 	chan = chanctx_conf->def.chan;
+ 	rcu_read_unlock();
+ 
+ 	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
+ 	    !WARN_ON(sdata->vif.valid_links) &&
+ 	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {
+ 		elems = ieee802_11_parse_elems(variable, len - baselen, false,
+ 					       ifmgd->assoc_data->link[0].bss);
+ 		if (!elems)
+ 			return;
+ 
+ 		ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 		if (elems->dtim_period)
+ 			link->u.mgd.dtim_period = elems->dtim_period;
+ 		link->u.mgd.have_beacon = true;
+ 		ifmgd->assoc_data->need_beacon = false;
+ 		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
+ 			link->conf->sync_tsf =
+ 				le64_to_cpu(mgmt->u.beacon.timestamp);
+ 			link->conf->sync_device_ts =
+ 				rx_status->device_timestamp;
+ 			link->conf->sync_dtim_count = elems->dtim_count;
+ 		}
+ 
+ 		if (elems->mbssid_config_ie)
+ 			bss_conf->profile_periodicity =
+ 				elems->mbssid_config_ie->profile_periodicity;
+ 		else
+ 			bss_conf->profile_periodicity = 0;
+ 
+ 		if (elems->ext_capab_len >= 11 &&
+ 		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
+ 			bss_conf->ema_ap = true;
+ 		else
+ 			bss_conf->ema_ap = false;
+ 
+ 		/* continue assoc process */
+ 		ifmgd->assoc_data->timeout = jiffies;
+ 		ifmgd->assoc_data->timeout_started = true;
+ 		run_again(sdata, ifmgd->assoc_data->timeout);
+ 		kfree(elems);
+ 		return;
+ 	}
+ 
+ 	if (!ifmgd->associated ||
+ 	    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))
+ 		return;
+ 	bssid = link->u.mgd.bssid;
+ 
+ 	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
+ 		ieee80211_handle_beacon_sig(link, ifmgd, bss_conf,
+ 					    local, rx_status);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
+ 		mlme_dbg_ratelimited(sdata,
+ 				     "cancelling AP probe due to a received beacon\n");
+ 		ieee80211_reset_ap_probe(sdata);
+ 	}
+ 
+ 	/*
+ 	 * Push the beacon loss detection into the future since
+ 	 * we are processing a beacon from the AP just now.
+ 	 */
+ 	ieee80211_sta_reset_beacon_monitor(sdata);
+ 
+ 	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
+ 	 * element (which carries the beacon interval). Don't forget to add a
+ 	 * bit to care_about_ies[] above if mac80211 is interested in a
+ 	 * changing S1G element.
+ 	 */
+ 	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
+ 		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
+ 	elems = ieee802_11_parse_elems_crc(variable, len - baselen,
+ 					   false, care_about_ies, ncrc,
+ 					   link->u.mgd.bss);
+ 	if (!elems)
+ 		return;
+ 	ncrc = elems->crc;
+ 
+ 	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
+ 	    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {
+ 		if (local->hw.conf.dynamic_ps_timeout > 0) {
+ 			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
+ 				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
+ 				ieee80211_hw_config(local,
+ 						    IEEE80211_CONF_CHANGE_PS);
+ 			}
+ 			ieee80211_send_nullfunc(local, sdata, false);
+ 		} else if (!local->pspolling && sdata->u.mgd.powersave) {
+ 			local->pspolling = true;
+ 
+ 			/*
+ 			 * Here is assumed that the driver will be
+ 			 * able to send ps-poll frame and receive a
+ 			 * response even though power save mode is
+ 			 * enabled, but some drivers might require
+ 			 * to disable power save here. This needs
+ 			 * to be investigated.
+ 			 */
+ 			ieee80211_send_pspoll(local, sdata);
+ 		}
+ 	}
+ 
+ 	if (sdata->vif.p2p ||
+ 	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
+ 		struct ieee80211_p2p_noa_attr noa = {};
+ 		int ret;
+ 
+ 		ret = cfg80211_get_p2p_attr(variable,
+ 					    len - baselen,
+ 					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
+ 					    (u8 *) &noa, sizeof(noa));
+ 		if (ret >= 2) {
+ 			if (link->u.mgd.p2p_noa_index != noa.index) {
+ 				/* valid noa_attr and index changed */
+ 				link->u.mgd.p2p_noa_index = noa.index;
+ 				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
+ 				changed |= BSS_CHANGED_P2P_PS;
+ 				/*
+ 				 * make sure we update all information, the CRC
+ 				 * mechanism doesn't look at P2P attributes.
+ 				 */
+ 				link->u.mgd.beacon_crc_valid = false;
+ 			}
+ 		} else if (link->u.mgd.p2p_noa_index != -1) {
+ 			/* noa_attr not found and we had valid noa_attr before */
+ 			link->u.mgd.p2p_noa_index = -1;
+ 			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
+ 			changed |= BSS_CHANGED_P2P_PS;
+ 			link->u.mgd.beacon_crc_valid = false;
+ 		}
+ 	}
+ 
+ 	if (link->u.mgd.csa_waiting_bcn)
+ 		ieee80211_chswitch_post_beacon(link);
+ 
+ 	/*
+ 	 * Update beacon timing and dtim count on every beacon appearance. This
+ 	 * will allow the driver to use the most updated values. Do it before
+ 	 * comparing this one with last received beacon.
+ 	 * IMPORTANT: These parameters would possibly be out of sync by the time
+ 	 * the driver will use them. The synchronized view is currently
+ 	 * guaranteed only in certain callbacks.
+ 	 */
+ 	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
+ 	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
+ 		link->conf->sync_tsf =
+ 			le64_to_cpu(mgmt->u.beacon.timestamp);
+ 		link->conf->sync_device_ts =
+ 			rx_status->device_timestamp;
+ 		link->conf->sync_dtim_count = elems->dtim_count;
+ 	}
+ 
+ 	if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||
+ 	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
+ 		goto free;
+ 	link->u.mgd.beacon_crc = ncrc;
+ 	link->u.mgd.beacon_crc_valid = true;
+ 
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 	ieee80211_sta_process_chanswitch(link, rx_status->mactime,
+ 					 rx_status->device_timestamp,
+ 					 elems, true);
+ 
+ 	if (!link->u.mgd.disable_wmm_tracking &&
+ 	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 				     elems->wmm_param_len,
+ 				     elems->mu_edca_param_set))
+ 		changed |= BSS_CHANGED_QOS;
+ 
+ 	/*
+ 	 * If we haven't had a beacon before, tell the driver about the
+ 	 * DTIM period (and beacon timing if desired) now.
+ 	 */
+ 	if (!link->u.mgd.have_beacon) {
+ 		/* a few bogus AP send dtim_period = 0 or no TIM IE */
+ 		bss_conf->dtim_period = elems->dtim_period ?: 1;
+ 
+ 		changed |= BSS_CHANGED_BEACON_INFO;
+ 		link->u.mgd.have_beacon = true;
+ 
+ 		mutex_lock(&local->iflist_mtx);
+ 		ieee80211_recalc_ps(local);
+ 		mutex_unlock(&local->iflist_mtx);
+ 
+ 		ieee80211_recalc_ps_vif(sdata);
+ 	}
+ 
+ 	if (elems->erp_info) {
+ 		erp_valid = true;
+ 		erp_value = elems->erp_info[0];
+ 	} else {
+ 		erp_valid = false;
+ 	}
+ 
+ 	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
+ 		changed |= ieee80211_handle_bss_capability(link,
+ 				le16_to_cpu(mgmt->u.beacon.capab_info),
+ 				erp_valid, erp_value);
+ 
+ 	mutex_lock(&local->sta_mtx);
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
+ 	if (WARN_ON(!sta))
+ 		goto free;
+ 	link_sta = rcu_dereference_protected(sta->link[link->link_id],
+ 					     lockdep_is_held(&local->sta_mtx));
+ 	if (WARN_ON(!link_sta))
+ 		goto free;
+ 
+ 	changed |= ieee80211_recalc_twt_req(link, link_sta, elems);
+ 
+ 	if (ieee80211_config_bw(link, elems->ht_cap_elem,
+ 				elems->vht_cap_elem, elems->ht_operation,
+ 				elems->vht_operation, elems->he_operation,
+ 				elems->eht_operation,
+ 				elems->s1g_oper, bssid, &changed)) {
+ 		mutex_unlock(&local->sta_mtx);
+ 		sdata_info(sdata,
+ 			   "failed to follow AP %pM bandwidth change, disconnect\n",
+ 			   bssid);
+ 		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
+ 				       WLAN_REASON_DEAUTH_LEAVING,
+ 				       true, deauth_buf);
+ 		ieee80211_report_disconnect(sdata, deauth_buf,
+ 					    sizeof(deauth_buf), true,
+ 					    WLAN_REASON_DEAUTH_LEAVING,
+ 					    false);
+ 		goto free;
+ 	}
+ 
+ 	if (sta && elems->opmode_notif)
+ 		ieee80211_vht_handle_opmode(sdata, link_sta,
+ 					    *elems->opmode_notif,
+ 					    rx_status->band);
+ 	mutex_unlock(&local->sta_mtx);
+ 
+ 	changed |= ieee80211_handle_pwr_constr(link, chan, mgmt,
+ 					       elems->country_elem,
+ 					       elems->country_elem_len,
+ 					       elems->pwr_constr_elem,
+ 					       elems->cisco_dtpc_elem);
+ 
+ 	ieee80211_link_info_change_notify(sdata, link, changed);
+ free:
+ 	kfree(elems);
+ }
+ 
+ void ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,
+ 				 struct sk_buff *skb)
+ {
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_rx_status *rx_status;
+ 	struct ieee80211_hdr *hdr;
+ 	u16 fc;
+ 
+ 	rx_status = (struct ieee80211_rx_status *) skb->cb;
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+ 	fc = le16_to_cpu(hdr->frame_control);
+ 
+ 	sdata_lock(sdata);
+ 	switch (fc & IEEE80211_FCTL_STYPE) {
+ 	case IEEE80211_STYPE_S1G_BEACON:
+ 		ieee80211_rx_mgmt_beacon(link, hdr, skb->len, rx_status);
+ 		break;
+ 	}
+ 	sdata_unlock(sdata);
+ }
+ 
+ void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+ 				  struct sk_buff *skb)
+ {
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_rx_status *rx_status;
+ 	struct ieee80211_mgmt *mgmt;
+ 	u16 fc;
+ 	int ies_len;
+ 
+ 	rx_status = (struct ieee80211_rx_status *) skb->cb;
+ 	mgmt = (struct ieee80211_mgmt *) skb->data;
+ 	fc = le16_to_cpu(mgmt->frame_control);
+ 
+ 	sdata_lock(sdata);
+ 
+ 	switch (fc & IEEE80211_FCTL_STYPE) {
+ 	case IEEE80211_STYPE_BEACON:
+ 		ieee80211_rx_mgmt_beacon(link, (void *)mgmt,
+ 					 skb->len, rx_status);
+ 		break;
+ 	case IEEE80211_STYPE_PROBE_RESP:
+ 		ieee80211_rx_mgmt_probe_resp(link, skb);
+ 		break;
+ 	case IEEE80211_STYPE_AUTH:
+ 		ieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_DEAUTH:
+ 		ieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_DISASSOC:
+ 		ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_ASSOC_RESP:
+ 	case IEEE80211_STYPE_REASSOC_RESP:
+ 		ieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_ACTION:
+ 		if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {
+ 			struct ieee802_11_elems *elems;
+ 
+ 			ies_len = skb->len -
+ 				  offsetof(struct ieee80211_mgmt,
+ 					   u.action.u.chan_switch.variable);
+ 
+ 			if (ies_len < 0)
+ 				break;
+ 
+ 			/* CSA IE cannot be overridden, no need for BSSID */
+ 			elems = ieee802_11_parse_elems(
+ 					mgmt->u.action.u.chan_switch.variable,
+ 					ies_len, true, NULL);
+ 
+ 			if (elems && !elems->parse_error)
+ 				ieee80211_sta_process_chanswitch(link,
+ 								 rx_status->mactime,
+ 								 rx_status->device_timestamp,
+ 								 elems, false);
+ 			kfree(elems);
+ 		} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
+ 			struct ieee802_11_elems *elems;
+ 
+ 			ies_len = skb->len -
+ 				  offsetof(struct ieee80211_mgmt,
+ 					   u.action.u.ext_chan_switch.variable);
+ 
+ 			if (ies_len < 0)
+ 				break;
+ 
+ 			/*
+ 			 * extended CSA IE can't be overridden, no need for
+ 			 * BSSID
+ 			 */
+ 			elems = ieee802_11_parse_elems(
+ 					mgmt->u.action.u.ext_chan_switch.variable,
+ 					ies_len, true, NULL);
+ 
+ 			if (elems && !elems->parse_error) {
+ 				/* for the handling code pretend it was an IE */
+ 				elems->ext_chansw_ie =
+ 					&mgmt->u.action.u.ext_chan_switch.data;
+ 
+ 				ieee80211_sta_process_chanswitch(link,
+ 								 rx_status->mactime,
+ 								 rx_status->device_timestamp,
+ 								 elems, false);
+ 			}
+ 
+ 			kfree(elems);
+ 		}
+ 		break;
+ 	}
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_sta_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.timer);
+ 
+ 	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+ }
+ 
+ void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
+ 				   u8 reason, bool tx)
+ {
+ 	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH, reason,
+ 			       tx, frame_buf);
+ 
+ 	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
+ 				    reason, false);
+ }
+ 
+ static int ieee80211_auth(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_auth_data *auth_data = ifmgd->auth_data;
+ 	u32 tx_flags = 0;
+ 	u16 trans = 1;
+ 	u16 status = 0;
+ 	struct ieee80211_prep_tx_info info = {
+ 		.subtype = IEEE80211_STYPE_AUTH,
+ 	};
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	if (WARN_ON_ONCE(!auth_data))
+ 		return -EINVAL;
+ 
+ 	auth_data->tries++;
+ 
+ 	if (auth_data->tries > IEEE80211_AUTH_MAX_TRIES) {
+ 		sdata_info(sdata, "authentication with %pM timed out\n",
+ 			   auth_data->ap_addr);
+ 
+ 		/*
+ 		 * Most likely AP is not in the range so remove the
+ 		 * bss struct for that AP.
+ 		 */
+ 		cfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);
+ 
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	if (auth_data->algorithm == WLAN_AUTH_SAE)
+ 		info.duration = jiffies_to_msecs(IEEE80211_AUTH_TIMEOUT_SAE);
+ 
+ 	drv_mgd_prepare_tx(local, sdata, &info);
+ 
+ 	sdata_info(sdata, "send auth to %pM (try %d/%d)\n",
+ 		   auth_data->ap_addr, auth_data->tries,
+ 		   IEEE80211_AUTH_MAX_TRIES);
+ 
+ 	auth_data->expected_transaction = 2;
+ 
+ 	if (auth_data->algorithm == WLAN_AUTH_SAE) {
+ 		trans = auth_data->sae_trans;
+ 		status = auth_data->sae_status;
+ 		auth_data->expected_transaction = trans;
+ 	}
+ 
+ 	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
+ 		tx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
+ 			   IEEE80211_TX_INTFL_MLME_CONN_TX;
+ 
+ 	ieee80211_send_auth(sdata, trans, auth_data->algorithm, status,
+ 			    auth_data->data, auth_data->data_len,
+ 			    auth_data->ap_addr, auth_data->ap_addr,
+ 			    NULL, 0, 0, tx_flags);
+ 
+ 	if (tx_flags == 0) {
+ 		if (auth_data->algorithm == WLAN_AUTH_SAE)
+ 			auth_data->timeout = jiffies +
+ 				IEEE80211_AUTH_TIMEOUT_SAE;
+ 		else
+ 			auth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
+ 	} else {
+ 		auth_data->timeout =
+ 			round_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);
+ 	}
+ 
+ 	auth_data->timeout_started = true;
+ 	run_again(sdata, auth_data->timeout);
+ 
+ 	return 0;
+ }
+ 
+ static int ieee80211_do_assoc(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	int ret;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	assoc_data->tries++;
+ 	if (assoc_data->tries > IEEE80211_ASSOC_MAX_TRIES) {
+ 		sdata_info(sdata, "association with %pM timed out\n",
+ 			   assoc_data->ap_addr);
+ 
+ 		/*
+ 		 * Most likely AP is not in the range so remove the
+ 		 * bss struct for that AP.
+ 		 */
+ 		cfg80211_unlink_bss(local->hw.wiphy,
+ 				    assoc_data->link[assoc_data->assoc_link_id].bss);
+ 
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	sdata_info(sdata, "associate with %pM (try %d/%d)\n",
+ 		   assoc_data->ap_addr, assoc_data->tries,
+ 		   IEEE80211_ASSOC_MAX_TRIES);
+ 	ret = ieee80211_send_assoc(sdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 		assoc_data->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;
+ 		assoc_data->timeout_started = true;
+ 		run_again(sdata, assoc_data->timeout);
+ 	} else {
+ 		assoc_data->timeout =
+ 			round_jiffies_up(jiffies +
+ 					 IEEE80211_ASSOC_TIMEOUT_LONG);
+ 		assoc_data->timeout_started = true;
+ 		run_again(sdata, assoc_data->timeout);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,
+ 				  __le16 fc, bool acked)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 
+ 	sdata->u.mgd.status_fc = fc;
+ 	sdata->u.mgd.status_acked = acked;
+ 	sdata->u.mgd.status_received = true;
+ 
+ 	ieee80211_queue_work(&local->hw, &sdata->work);
+ }
+ 
+ void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_lock(sdata);
+ 
+ 	if (ifmgd->status_received) {
+ 		__le16 fc = ifmgd->status_fc;
+ 		bool status_acked = ifmgd->status_acked;
+ 
+ 		ifmgd->status_received = false;
+ 		if (ifmgd->auth_data && ieee80211_is_auth(fc)) {
+ 			if (status_acked) {
+ 				if (ifmgd->auth_data->algorithm ==
+ 				    WLAN_AUTH_SAE)
+ 					ifmgd->auth_data->timeout =
+ 						jiffies +
+ 						IEEE80211_AUTH_TIMEOUT_SAE;
+ 				else
+ 					ifmgd->auth_data->timeout =
+ 						jiffies +
+ 						IEEE80211_AUTH_TIMEOUT_SHORT;
+ 				run_again(sdata, ifmgd->auth_data->timeout);
+ 			} else {
+ 				ifmgd->auth_data->timeout = jiffies - 1;
+ 			}
+ 			ifmgd->auth_data->timeout_started = true;
+ 		} else if (ifmgd->assoc_data &&
+ 			   (ieee80211_is_assoc_req(fc) ||
+ 			    ieee80211_is_reassoc_req(fc))) {
+ 			if (status_acked) {
+ 				ifmgd->assoc_data->timeout =
+ 					jiffies + IEEE80211_ASSOC_TIMEOUT_SHORT;
+ 				run_again(sdata, ifmgd->assoc_data->timeout);
+ 			} else {
+ 				ifmgd->assoc_data->timeout = jiffies - 1;
+ 			}
+ 			ifmgd->assoc_data->timeout_started = true;
+ 		}
+ 	}
+ 
+ 	if (ifmgd->auth_data && ifmgd->auth_data->timeout_started &&
+ 	    time_after(jiffies, ifmgd->auth_data->timeout)) {
+ 		if (ifmgd->auth_data->done || ifmgd->auth_data->waiting) {
+ 			/*
+ 			 * ok ... we waited for assoc or continuation but
+ 			 * userspace didn't do it, so kill the auth data
+ 			 */
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 		} else if (ieee80211_auth(sdata)) {
+ 			u8 ap_addr[ETH_ALEN];
+ 			struct ieee80211_event event = {
+ 				.type = MLME_EVENT,
+ 				.u.mlme.data = AUTH_EVENT,
+ 				.u.mlme.status = MLME_TIMEOUT,
+ 			};
+ 
+ 			memcpy(ap_addr, ifmgd->auth_data->ap_addr, ETH_ALEN);
+ 
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 
+ 			cfg80211_auth_timeout(sdata->dev, ap_addr);
+ 			drv_event_callback(sdata->local, sdata, &event);
+ 		}
+ 	} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)
+ 		run_again(sdata, ifmgd->auth_data->timeout);
+ 
+ 	if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started &&
+ 	    time_after(jiffies, ifmgd->assoc_data->timeout)) {
+ 		if ((ifmgd->assoc_data->need_beacon &&
+ 		     !sdata->deflink.u.mgd.have_beacon) ||
+ 		    ieee80211_do_assoc(sdata)) {
+ 			struct ieee80211_event event = {
+ 				.type = MLME_EVENT,
+ 				.u.mlme.data = ASSOC_EVENT,
+ 				.u.mlme.status = MLME_TIMEOUT,
+ 			};
+ 
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
+ 			drv_event_callback(sdata->local, sdata, &event);
+ 		}
+ 	} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)
+ 		run_again(sdata, ifmgd->assoc_data->timeout);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL &&
+ 	    ifmgd->associated) {
+ 		u8 *bssid = sdata->deflink.u.mgd.bssid;
+ 		int max_tries;
+ 
+ 		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
+ 			max_tries = max_nullfunc_tries;
+ 		else
+ 			max_tries = max_probe_tries;
+ 
+ 		/* ACK received for nullfunc probing frame */
+ 		if (!ifmgd->probe_send_count)
+ 			ieee80211_reset_ap_probe(sdata);
+ 		else if (ifmgd->nullfunc_failed) {
+ 			if (ifmgd->probe_send_count < max_tries) {
+ 				mlme_dbg(sdata,
+ 					 "No ack for nullfunc frame to AP %pM, try %d/%i\n",
+ 					 bssid, ifmgd->probe_send_count,
+ 					 max_tries);
+ 				ieee80211_mgd_probe_ap_send(sdata);
+ 			} else {
+ 				mlme_dbg(sdata,
+ 					 "No ack for nullfunc frame to AP %pM, disconnecting.\n",
+ 					 bssid);
+ 				ieee80211_sta_connection_lost(sdata,
+ 					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
+ 					false);
+ 			}
+ 		} else if (time_is_after_jiffies(ifmgd->probe_timeout))
+ 			run_again(sdata, ifmgd->probe_timeout);
+ 		else if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 			mlme_dbg(sdata,
+ 				 "Failed to send nullfunc to AP %pM after %dms, disconnecting\n",
+ 				 bssid, probe_wait_ms);
+ 			ieee80211_sta_connection_lost(sdata,
+ 				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
+ 		} else if (ifmgd->probe_send_count < max_tries) {
+ 			mlme_dbg(sdata,
+ 				 "No probe response from AP %pM after %dms, try %d/%i\n",
+ 				 bssid, probe_wait_ms,
+ 				 ifmgd->probe_send_count, max_tries);
+ 			ieee80211_mgd_probe_ap_send(sdata);
+ 		} else {
+ 			/*
+ 			 * We actually lost the connection ... or did we?
+ 			 * Let's make sure!
+ 			 */
+ 			mlme_dbg(sdata,
+ 				 "No probe response from AP %pM after %dms, disconnecting.\n",
+ 				 bssid, probe_wait_ms);
+ 
+ 			ieee80211_sta_connection_lost(sdata,
+ 				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
+ 		}
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_sta_bcn_mon_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.bcn_mon_timer);
+ 
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
+ 		return;
+ 
+ 	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
+ 		return;
+ 
+ 	sdata->u.mgd.connection_loss = false;
+ 	ieee80211_queue_work(&sdata->local->hw,
+ 			     &sdata->u.mgd.beacon_connection_loss_work);
+ }
+ 
+ static void ieee80211_sta_conn_mon_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.conn_mon_timer);
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct sta_info *sta;
+ 	unsigned long timeout;
+ 
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
+ 		return;
+ 
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
+ 	if (!sta)
+ 		return;
+ 
+ 	timeout = sta->deflink.status_stats.last_ack;
+ 	if (time_before(sta->deflink.status_stats.last_ack, sta->deflink.rx_stats.last_rx))
+ 		timeout = sta->deflink.rx_stats.last_rx;
+ 	timeout += IEEE80211_CONNECTION_IDLE_TIME;
+ 
+ 	/* If timeout is after now, then update timer to fire at
+ 	 * the later date, but do not actually probe at this time.
+ 	 */
+ 	if (time_is_after_jiffies(timeout)) {
+ 		mod_timer(&ifmgd->conn_mon_timer, round_jiffies_up(timeout));
+ 		return;
+ 	}
+ 
+ 	ieee80211_queue_work(&local->hw, &ifmgd->monitor_work);
+ }
+ 
+ static void ieee80211_sta_monitor_work(struct work_struct *work)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		container_of(work, struct ieee80211_sub_if_data,
+ 			     u.mgd.monitor_work);
+ 
+ 	ieee80211_mgd_probe_ap(sdata, false);
+ }
+ 
+ static void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata)
+ {
+ 	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+ 		__ieee80211_stop_poll(sdata);
+ 
+ 		/* let's probe the connection once */
+ 		if (!ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
+ 			ieee80211_queue_work(&sdata->local->hw,
+ 					     &sdata->u.mgd.monitor_work);
+ 	}
+ }
+ 
+ #ifdef CONFIG_PM
+ void ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	sdata_lock(sdata);
+ 
+ 	if (ifmgd->auth_data || ifmgd->assoc_data) {
+ 		const u8 *ap_addr = ifmgd->auth_data ?
+ 				ifmgd->auth_data->ap_addr :
+ 				ifmgd->assoc_data->ap_addr;
+ 
+ 		/*
+ 		 * If we are trying to authenticate / associate while suspending,
+ 		 * cfg80211 won't know and won't actually abort those attempts,
+ 		 * thus we need to do that ourselves.
+ 		 */
+ 		ieee80211_send_deauth_disassoc(sdata, ap_addr, ap_addr,
+ 					       IEEE80211_STYPE_DEAUTH,
+ 					       WLAN_REASON_DEAUTH_LEAVING,
+ 					       false, frame_buf);
+ 		if (ifmgd->assoc_data)
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 		if (ifmgd->auth_data)
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
+ 				      IEEE80211_DEAUTH_FRAME_LEN,
+ 				      false);
+ 	}
+ 
+ 	/* This is a bit of a hack - we should find a better and more generic
+ 	 * solution to this. Normally when suspending, cfg80211 will in fact
+ 	 * deauthenticate. However, it doesn't (and cannot) stop an ongoing
+ 	 * auth (not so important) or assoc (this is the problem) process.
+ 	 *
+ 	 * As a consequence, it can happen that we are in the process of both
+ 	 * associating and suspending, and receive an association response
+ 	 * after cfg80211 has checked if it needs to disconnect, but before
+ 	 * we actually set the flag to drop incoming frames. This will then
+ 	 * cause the workqueue flush to process the association response in
+ 	 * the suspend, resulting in a successful association just before it
+ 	 * tries to remove the interface from the driver, which now though
+ 	 * has a channel context assigned ... this results in issues.
+ 	 *
+ 	 * To work around this (for now) simply deauth here again if we're
+ 	 * now connected.
+ 	 */
+ 	if (ifmgd->associated && !sdata->local->wowlan) {
+ 		u8 bssid[ETH_ALEN];
+ 		struct cfg80211_deauth_request req = {
+ 			.reason_code = WLAN_REASON_DEAUTH_LEAVING,
+ 			.bssid = bssid,
+ 		};
+ 
+ 		memcpy(bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
+ 		ieee80211_mgd_deauth(sdata, &req);
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ #endif
+ 
+ void ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_lock(sdata);
+ 	if (!ifmgd->associated) {
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {
+ 		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;
+ 		mlme_dbg(sdata, "driver requested disconnect after resume\n");
+ 		ieee80211_sta_connection_lost(sdata,
+ 					      WLAN_REASON_UNSPECIFIED,
+ 					      true);
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_HW_RESTART) {
+ 		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_HW_RESTART;
+ 		mlme_dbg(sdata, "driver requested disconnect after hardware restart\n");
+ 		ieee80211_sta_connection_lost(sdata,
+ 					      WLAN_REASON_UNSPECIFIED,
+ 					      true);
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_request_smps_mgd_work(struct work_struct *work)
+ {
+ 	struct ieee80211_link_data *link =
+ 		container_of(work, struct ieee80211_link_data,
+ 			     u.mgd.request_smps_work);
+ 
+ 	sdata_lock(link->sdata);
+ 	__ieee80211_request_smps_mgd(link->sdata, link,
+ 				     link->u.mgd.driver_smps_mode);
+ 	sdata_unlock(link->sdata);
+ }
+ 
+ /* interface setup */
+ void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
+ 	INIT_WORK(&ifmgd->beacon_connection_loss_work,
+ 		  ieee80211_beacon_connection_loss_work);
+ 	INIT_WORK(&ifmgd->csa_connection_drop_work,
+ 		  ieee80211_csa_connection_drop_work);
+ 	INIT_DELAYED_WORK(&ifmgd->tdls_peer_del_work,
+ 			  ieee80211_tdls_peer_del_work);
+ 	timer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);
+ 	timer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);
+ 	timer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);
+ 	INIT_DELAYED_WORK(&ifmgd->tx_tspec_wk,
+ 			  ieee80211_sta_handle_tspec_ac_params_wk);
+ 
+ 	ifmgd->flags = 0;
+ 	ifmgd->powersave = sdata->wdev.ps;
+ 	ifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;
+ 	ifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;
+ 	/* Setup TDLS data */
+ 	spin_lock_init(&ifmgd->teardown_lock);
+ 	ifmgd->teardown_skb = NULL;
+ 	ifmgd->orig_teardown_skb = NULL;
+ }
+ 
+ void ieee80211_mgd_setup_link(struct ieee80211_link_data *link)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id = link->link_id;
+ 
+ 	link->u.mgd.p2p_noa_index = -1;
+ 	link->u.mgd.conn_flags = 0;
+ 	link->conf->bssid = link->u.mgd.bssid;
+ 
+ 	INIT_WORK(&link->u.mgd.request_smps_work,
+ 		  ieee80211_request_smps_mgd_work);
+ 	if (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
+ 	else
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_OFF;
+ 
+ 	INIT_WORK(&link->u.mgd.chswitch_work, ieee80211_chswitch_work);
+ 	timer_setup(&link->u.mgd.chswitch_timer, ieee80211_chswitch_timer, 0);
+ 
+ 	if (sdata->u.mgd.assoc_data)
+ 		ether_addr_copy(link->conf->addr,
+ 				sdata->u.mgd.assoc_data->link[link_id].addr);
+ }
+ 
+ /* scan finished notification */
+ void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 
+ 	/* Restart STA timers */
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+ 		if (ieee80211_sdata_running(sdata))
+ 			ieee80211_restart_sta_timer(sdata);
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> 4ca04ed36478 (wifi: mac80211: mlme: transmit assoc frame with address translation)
+ static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
+ 			       u8 *dtim_count, u8 *dtim_period)
+ {
+ 	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
+ 	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
+ 					 ies->len);
+ 	const struct ieee80211_tim_ie *tim = NULL;
+ 	const struct ieee80211_bssid_index *idx;
+ 	bool valid = tim_ie && tim_ie[1] >= 2;
+ 
+ 	if (valid)
+ 		tim = (void *)(tim_ie + 2);
+ 
+ 	if (dtim_count)
+ 		*dtim_count = valid ? tim->dtim_count : 0;
+ 
+ 	if (dtim_period)
+ 		*dtim_period = valid ? tim->dtim_period : 0;
+ 
+ 	/* Check if value is overridden by non-transmitted profile */
+ 	if (!idx_ie || idx_ie[1] < 3)
+ 		return valid;
+ 
+ 	idx = (void *)(idx_ie + 2);
+ 
+ 	if (dtim_count)
+ 		*dtim_count = idx->dtim_count;
+ 
+ 	if (dtim_period)
+ 		*dtim_period = idx->dtim_period;
+ 
+ 	return true;
+ }
+ 
+ static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 -				     struct cfg80211_bss *cbss, s8 link_id,
 -				     const u8 *ap_mld_addr, bool assoc,
++				     struct cfg80211_bss *cbss, bool assoc,
+ 				     bool override)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	struct sta_info *new_sta = NULL;
 -	struct ieee80211_link_data *link;
++	struct ieee80211_supported_band *sband;
+ 	bool have_sta = false;
 -	bool mlo;
+ 	int err;
+ 
 -	if (link_id >= 0) {
 -		mlo = true;
 -		if (WARN_ON(!ap_mld_addr))
 -			return -EINVAL;
 -		err = ieee80211_vif_set_links(sdata, BIT(link_id));
 -	} else {
 -		if (WARN_ON(ap_mld_addr))
 -			return -EINVAL;
 -		ap_mld_addr = cbss->bssid;
 -		err = ieee80211_vif_set_links(sdata, 0);
 -		link_id = 0;
 -		mlo = false;
 -	}
 -
 -	if (err)
 -		return err;
 -
 -	link = sdata_dereference(sdata->link[link_id], sdata);
 -	if (WARN_ON(!link)) {
 -		err = -ENOLINK;
 -		goto out_err;
 -	}
 -
 -	if (mlo && !is_valid_ether_addr(link->conf->addr))
 -		eth_random_addr(link->conf->addr);
++	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
 -	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data)) {
 -		err = -EINVAL;
 -		goto out_err;
 -	}
++	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data))
++		return -EINVAL;
+ 
+ 	/* If a reconfig is happening, bail out */
 -	if (local->in_reconfig) {
 -		err = -EBUSY;
 -		goto out_err;
 -	}
++	if (local->in_reconfig)
++		return -EBUSY;
+ 
+ 	if (assoc) {
 -		rcu_read_lock();
 -		have_sta = sta_info_get(sdata, ap_mld_addr);
 -		rcu_read_unlock();
 -	}
 -
 -	if (!have_sta) {
 -		if (mlo)
 -			new_sta = sta_info_alloc_with_link(sdata, ap_mld_addr,
 -							   link_id, cbss->bssid,
 -							   GFP_KERNEL);
 -		else
 -			new_sta = sta_info_alloc(sdata, ap_mld_addr, GFP_KERNEL);
 -
 -		if (!new_sta) {
 -			err = -ENOMEM;
 -			goto out_err;
 -		}
++		rcu_read_lock();
++		have_sta = sta_info_get(sdata, cbss->bssid);
++		rcu_read_unlock();
++	}
+ 
 -		new_sta->sta.mlo = mlo;
++	if (!have_sta) {
++		new_sta = sta_info_alloc(sdata, cbss->bssid, GFP_KERNEL);
++		if (!new_sta)
++			return -ENOMEM;
+ 	}
+ 
+ 	/*
+ 	 * Set up the information for the new channel before setting the
+ 	 * new channel. We can't - completely race-free - change the basic
+ 	 * rates bitmap and the channel (sband) that it refers to, but if
+ 	 * we set it up before we at least avoid calling into the driver's
+ 	 * bss_info_changed() method with invalid information (since we do
+ 	 * call that from changing the channel - only for IDLE and perhaps
+ 	 * some others, but ...).
+ 	 *
+ 	 * So to avoid that, just set up all the new information before the
+ 	 * channel, but tell the driver to apply it only afterwards, since
+ 	 * it might need the new channel for that.
+ 	 */
+ 	if (new_sta) {
++		u32 rates = 0, basic_rates = 0;
++		bool have_higher_than_11mbit = false;
++		int min_rate = INT_MAX, min_rate_index = -1;
+ 		const struct cfg80211_bss_ies *ies;
 -		struct link_sta_info *link_sta;
++		int shift = ieee80211_vif_get_shift(&sdata->vif);
+ 
 -		rcu_read_lock();
 -		link_sta = rcu_dereference(new_sta->link[link_id]);
 -		if (WARN_ON(!link_sta)) {
 -			rcu_read_unlock();
 -			sta_info_free(local, new_sta);
 -			err = -EINVAL;
 -			goto out_err;
++		/* TODO: S1G Basic Rate Set is expressed elsewhere */
++		if (cbss->channel->band == NL80211_BAND_S1GHZ) {
++			ieee80211_s1g_sta_rate_init(new_sta);
++			goto skip_rates;
+ 		}
+ 
 -		err = ieee80211_mgd_setup_link_sta(link, new_sta,
 -						   link_sta, cbss);
 -		if (err) {
 -			rcu_read_unlock();
++		ieee80211_get_rates(sband, bss->supp_rates,
++				    bss->supp_rates_len,
++				    &rates, &basic_rates,
++				    &have_higher_than_11mbit,
++				    &min_rate, &min_rate_index,
++				    shift);
 +
 +		/*
 +		 * This used to be a workaround for basic rates missing
 +		 * in the association response frame. Now that we no
 +		 * longer use the basic rates from there, it probably
 +		 * doesn't happen any more, but keep the workaround so
 +		 * in case some *other* APs are buggy in different ways
 +		 * we can connect -- with a warning.
 +		 * Allow this workaround only in case the AP provided at least
 +		 * one rate.
 +		 */
 +		if (min_rate_index < 0) {
 +			sdata_info(sdata,
 +				   "No legacy rates in association response\n");
 +
  			sta_info_free(local, new_sta);
 -			goto out_err;
 +			return -EINVAL;
 +		} else if (!basic_rates) {
 +			sdata_info(sdata,
 +				   "No basic rates, using min rate instead\n");
 +			basic_rates = BIT(min_rate_index);
  		}
  
 -		memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
 +		if (rates)
 +			new_sta->sta.supp_rates[cbss->channel->band] = rates;
 +		else
 +			sdata_info(sdata,
 +				   "No rates found, keeping mandatory only\n");
 +
 +		sdata->vif.bss_conf.basic_rates = basic_rates;
 +
 +		/* cf. IEEE 802.11 9.2.12 */
 +		if (cbss->channel->band == NL80211_BAND_2GHZ &&
 +		    have_higher_than_11mbit)
 +			sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
 +		else
 +			sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
 +
 +skip_rates:
 +		memcpy(ifmgd->bssid, cbss->bssid, ETH_ALEN);
  
  		/* set timing information */
 -		link->conf->beacon_int = cbss->beacon_interval;
 +		sdata->vif.bss_conf.beacon_int = cbss->beacon_interval;
 +		rcu_read_lock();
  		ies = rcu_dereference(cbss->beacon_ies);
  		if (ies) {
 -			link->conf->sync_tsf = ies->tsf;
 -			link->conf->sync_device_ts =
 +			sdata->vif.bss_conf.sync_tsf = ies->tsf;
 +			sdata->vif.bss_conf.sync_device_ts =
  				bss->device_ts_beacon;
  
  			ieee80211_get_dtim(ies,
@@@ -5873,9 -6639,13 +7742,17 @@@ int ieee80211_mgd_auth(struct ieee80211
  					    false);
  	}
  
 -	sdata_info(sdata, "authenticate with %pM\n", auth_data->ap_addr);
 +	sdata_info(sdata, "authenticate with %pM\n", req->bss->bssid);
  
++<<<<<<< HEAD
 +	err = ieee80211_prep_connection(sdata, req->bss, cont_auth, false);
++=======
+ 	/* needed for transmitting the auth frame(s) properly */
+ 	memcpy(sdata->vif.cfg.ap_addr, auth_data->ap_addr, ETH_ALEN);
+ 
+ 	err = ieee80211_prep_connection(sdata, req->bss, req->link_id,
+ 					req->ap_mld_addr, cont_auth, false);
++>>>>>>> 4ca04ed36478 (wifi: mac80211: mlme: transmit assoc frame with address translation)
  	if (err)
  		goto err_clear;
  
@@@ -6105,55 -7095,25 +7982,63 @@@ int ieee80211_mgd_assoc(struct ieee8021
  	sdata->control_port_no_preauth = req->crypto.control_port_no_preauth;
  
  	/* kick off associate process */
 +
  	ifmgd->assoc_data = assoc_data;
 +	ifmgd->dtim_period = 0;
 +	ifmgd->have_beacon = false;
  
 -	for (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {
 -		if (!assoc_data->link[i].bss)
 -			continue;
 -		if (i == assoc_data->assoc_link_id)
 -			continue;
 -		/* only calculate the flags, hence link == NULL */
 -		err = ieee80211_prep_channel(sdata, NULL, assoc_data->link[i].bss,
 -					     &assoc_data->link[i].conn_flags);
 -		if (err)
 -			goto err_clear;
 +	/* override HT/VHT configuration only if the AP and we support it */
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
 +		struct ieee80211_sta_ht_cap sta_ht_cap;
 +
 +		if (req->flags & ASSOC_REQ_DISABLE_HT)
 +			override = true;
 +
 +		memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
 +		ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
 +
 +		/* check for 40 MHz disable override */
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_40MHZ) &&
 +		    sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&
 +		    !(sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))
 +			override = true;
 +
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
 +		    req->flags & ASSOC_REQ_DISABLE_VHT)
 +			override = true;
 +	}
 +
++<<<<<<< HEAD
 +	if (req->flags & ASSOC_REQ_DISABLE_HT) {
 +		mlme_dbg(sdata, "HT disabled by flag, disabling HT/VHT/HE\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_VHT) {
 +		mlme_dbg(sdata, "VHT disabled by flag, disabling VHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_HE) {
 +		mlme_dbg(sdata, "HE disabled by flag, disabling HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
  	}
  
 +	if (req->flags & ASSOC_REQ_DISABLE_EHT)
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +
 +	err = ieee80211_prep_connection(sdata, req->bss, true, override);
++=======
+ 	/* needed for transmitting the assoc frames properly */
+ 	memcpy(sdata->vif.cfg.ap_addr, assoc_data->ap_addr, ETH_ALEN);
+ 
+ 	err = ieee80211_prep_connection(sdata, cbss, req->link_id,
+ 					req->ap_mld_addr, true, override);
++>>>>>>> 4ca04ed36478 (wifi: mac80211: mlme: transmit assoc frame with address translation)
  	if (err)
  		goto err_clear;
  
* Unmerged path net/mac80211/mlme.c
