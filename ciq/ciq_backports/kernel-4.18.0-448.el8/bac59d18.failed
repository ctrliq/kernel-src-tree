x86/setup: Fix static memory detection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Guenter Roeck <linux@roeck-us.net>
commit bac59d18c7018a2fd5e800a1e72a8271bf404977
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/bac59d18.failed

When booting x86 images in qemu, the following warning is seen randomly
if DEBUG_LOCKDEP is enabled.

  WARNING: CPU: 0 PID: 1 at kernel/locking/lockdep.c:1119
	  lockdep_register_key+0xc0/0x100

static_obj() returns true if an address is between _stext and _end.

On x86, this includes the brk memory space. Problem is that this memory
block is not static on x86; its unused portions are released after init
and can be allocated. This results in the observed warning if a lockdep
object is allocated from this memory.

Solve the problem by implementing arch_is_kernel_initmem_freed() for
x86 and have it return true if an address is within the released memory
range.

The same problem was solved for s390 with commit

  7a5da02de8d6e ("locking/lockdep: check for freed initmem in static_obj()"),

which introduced arch_is_kernel_initmem_freed().

	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Acked-by: Peter Zijlstra <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200131021159.9178-1-linux@roeck-us.net
(cherry picked from commit bac59d18c7018a2fd5e800a1e72a8271bf404977)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/setup.c
diff --cc arch/x86/kernel/setup.c
index 38411413fd6b,e6b545047f38..000000000000
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@@ -139,8 -59,13 +139,18 @@@ RESERVE_BRK(dmi_alloc, 65536)
  #endif
  
  
++<<<<<<< HEAD
 +static __initdata unsigned long _brk_start = (unsigned long)__brk_base;
 +unsigned long _brk_end = (unsigned long)__brk_base;
++=======
+ /*
+  * Range of the BSS area. The size of the BSS area is determined
+  * at link time, with RESERVE_BRK*() facility reserving additional
+  * chunks.
+  */
+ unsigned long _brk_start = (unsigned long)__brk_base;
+ unsigned long _brk_end   = (unsigned long)__brk_base;
++>>>>>>> bac59d18c701 (x86/setup: Fix static memory detection)
  
  struct boot_params boot_params;
  
diff --git a/arch/x86/include/asm/sections.h b/arch/x86/include/asm/sections.h
index 11f973064c08..113deb377c2d 100644
--- a/arch/x86/include/asm/sections.h
+++ b/arch/x86/include/asm/sections.h
@@ -2,6 +2,8 @@
 #ifndef _ASM_X86_SECTIONS_H
 #define _ASM_X86_SECTIONS_H
 
+#define arch_is_kernel_initmem_freed arch_is_kernel_initmem_freed
+
 #include <asm-generic/sections.h>
 #include <asm/extable.h>
 
@@ -14,4 +16,22 @@ extern char __end_rodata_hpage_align[];
 
 extern char __end_of_kernel_reserve[];
 
+extern unsigned long _brk_start, _brk_end;
+
+static inline bool arch_is_kernel_initmem_freed(unsigned long addr)
+{
+	/*
+	 * If _brk_start has not been cleared, brk allocation is incomplete,
+	 * and we can not make assumptions about its use.
+	 */
+	if (_brk_start)
+		return 0;
+
+	/*
+	 * After brk allocation is complete, space between _brk_end and _end
+	 * is available for allocation.
+	 */
+	return addr >= _brk_end && addr < (unsigned long)&_end;
+}
+
 #endif	/* _ASM_X86_SECTIONS_H */
* Unmerged path arch/x86/kernel/setup.c
