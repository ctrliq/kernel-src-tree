net/mlx5e: Add mpls push/pop to tc action infra

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 163b766f566294bf7449bf4fb33ad4ae092dce03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/163b766f.failed

Add parsing support by implementing struct mlx5e_tc_act
for this action.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 163b766f566294bf7449bf4fb33ad4ae092dce03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 478a0ab6470d,530acd000d6b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -46,6 -46,12 +46,15 @@@ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     +
  					en/tc_tun_vxlan.o en/tc_tun_gre.o en/tc_tun_geneve.o \
  					en/tc_tun_mplsoudp.o diag/en_tc_tracepoint.o \
  					en/tc/post_act.o en/tc/int_port.o
++<<<<<<< HEAD
++=======
+ 
+ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     += en/tc/act/act.o en/tc/act/drop.o en/tc/act/trap.o \
+ 					en/tc/act/accept.o en/tc/act/mark.o en/tc/act/goto.o \
+ 					en/tc/act/tun.o en/tc/act/csum.o en/tc/act/pedit.o \
+ 					en/tc/act/vlan.o en/tc/act/vlan_mangle.o en/tc/act/mpls.o
+ 
++>>>>>>> 163b766f5662 (net/mlx5e: Add mpls push/pop to tc action infra)
  mlx5_core-$(CONFIG_MLX5_TC_CT)	     += en/tc_ct.o
  mlx5_core-$(CONFIG_MLX5_TC_SAMPLE)   += en/tc/sample.o
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index abcf89c03680,9602d2fb7736..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -3906,14 -3474,13 +3906,17 @@@ static int parse_tc_fdb_actions(struct 
  	struct mlx5_flow_attr *attr = flow->attr;
  	int ifindexes[MLX5_MAX_FLOW_FWD_VPORTS];
  	bool ft_flow = mlx5e_is_ft_flow(flow);
 -	enum mlx5_flow_namespace_type ns_type;
  	const struct flow_action_entry *act;
  	struct mlx5_esw_flow_attr *esw_attr;
 -	struct pedit_headers_action *hdrs;
 -	struct mlx5e_tc_act *tc_act;
 +	bool encap = false, decap = false;
 +	u32 action = attr->action;
  	int err, i, if_count = 0;
  	bool ptype_host = false;
++<<<<<<< HEAD
 +	bool mpls_push = false;
 +	bool clear_action;
++=======
++>>>>>>> 163b766f5662 (net/mlx5e: Add mpls push/pop to tc action infra)
  
  	err = flow_action_supported(flow_action, extack);
  	if (err)
@@@ -3933,69 -3504,6 +3936,72 @@@
  
  			ptype_host = true;
  			break;
++<<<<<<< HEAD
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_TRAP:
 +			if (!flow_offload_has_one_action(flow_action)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "action trap is supported as a sole action only");
 +				return -EOPNOTSUPP;
 +			}
 +			action |= (MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				   MLX5_FLOW_CONTEXT_ACTION_COUNT);
 +			attr->flags |= MLX5_ESW_ATTR_FLAG_SLOW_PATH;
 +			break;
 +		case FLOW_ACTION_MPLS_PUSH:
 +			if (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,
 +							reformat_l2_to_l3_tunnel) ||
 +			    act->mpls_push.proto != htons(ETH_P_MPLS_UC)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls push is supported only for mpls_uc protocol");
 +				return -EOPNOTSUPP;
 +			}
 +			mpls_push = true;
 +			break;
 +		case FLOW_ACTION_MPLS_POP:
 +			/* we only support mpls pop if it is the first action
 +			 * and the filter net device is bareudp. Subsequent
 +			 * actions can be pedit and the last can be mirred
 +			 * egress redirect.
 +			 */
 +			if (i) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls pop supported only as first action");
 +				return -EOPNOTSUPP;
 +			}
 +			if (!netif_is_bareudp(parse_attr->filter_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls pop supported only on bareudp devices");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			parse_attr->eth.h_proto = act->mpls_pop.proto;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
 +			flow_flag_set(flow, L3_TO_L2_DECAP);
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_FDB,
 +						    parse_attr, hdrs, flow, extack);
 +			if (err)
 +				return err;
 +
 +			if (!flow_flag_test(flow, L3_TO_L2_DECAP)) {
 +				action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +				esw_attr->split_count = esw_attr->out_count;
 +			}
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags, extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
++=======
++>>>>>>> 163b766f5662 (net/mlx5e: Add mpls push/pop to tc action infra)
  		case FLOW_ACTION_REDIRECT_INGRESS: {
  			struct net_device *out_dev;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c
new file mode 100644
index 000000000000..784fc4f68b1e
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+#include <net/bareudp.h>
+#include "act.h"
+#include "en/tc_priv.h"
+
+static bool
+tc_act_can_offload_mpls_push(struct mlx5e_tc_act_parse_state *parse_state,
+			     const struct flow_action_entry *act,
+			     int act_index)
+{
+	struct netlink_ext_ack *extack = parse_state->extack;
+	struct mlx5e_priv *priv = parse_state->flow->priv;
+
+	if (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, reformat_l2_to_l3_tunnel) ||
+	    act->mpls_push.proto != htons(ETH_P_MPLS_UC)) {
+		NL_SET_ERR_MSG_MOD(extack, "mpls push is supported only for mpls_uc protocol");
+		return false;
+	}
+
+	return true;
+}
+
+static int
+tc_act_parse_mpls_push(struct mlx5e_tc_act_parse_state *parse_state,
+		       const struct flow_action_entry *act,
+		       struct mlx5e_priv *priv,
+		       struct mlx5_flow_attr *attr)
+{
+	parse_state->mpls_push = true;
+
+	return 0;
+}
+
+static bool
+tc_act_can_offload_mpls_pop(struct mlx5e_tc_act_parse_state *parse_state,
+			    const struct flow_action_entry *act,
+			    int act_index)
+{
+	struct netlink_ext_ack *extack = parse_state->extack;
+	struct mlx5e_tc_flow *flow = parse_state->flow;
+	struct net_device *filter_dev;
+
+	filter_dev = flow->attr->parse_attr->filter_dev;
+
+	/* we only support mpls pop if it is the first action
+	 * and the filter net device is bareudp. Subsequent
+	 * actions can be pedit and the last can be mirred
+	 * egress redirect.
+	 */
+	if (act_index) {
+		NL_SET_ERR_MSG_MOD(extack, "mpls pop supported only as first action");
+		return false;
+	}
+
+	if (!netif_is_bareudp(filter_dev)) {
+		NL_SET_ERR_MSG_MOD(extack, "mpls pop supported only on bareudp devices");
+		return false;
+	}
+
+	return true;
+}
+
+static int
+tc_act_parse_mpls_pop(struct mlx5e_tc_act_parse_state *parse_state,
+		      const struct flow_action_entry *act,
+		      struct mlx5e_priv *priv,
+		      struct mlx5_flow_attr *attr)
+{
+	attr->parse_attr->eth.h_proto = act->mpls_pop.proto;
+	attr->action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
+	flow_flag_set(parse_state->flow, L3_TO_L2_DECAP);
+
+	return 0;
+}
+
+struct mlx5e_tc_act mlx5e_tc_act_mpls_push = {
+	.can_offload = tc_act_can_offload_mpls_push,
+	.parse_action = tc_act_parse_mpls_push,
+};
+
+struct mlx5e_tc_act mlx5e_tc_act_mpls_pop = {
+	.can_offload = tc_act_can_offload_mpls_pop,
+	.parse_action = tc_act_parse_mpls_pop,
+};
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
