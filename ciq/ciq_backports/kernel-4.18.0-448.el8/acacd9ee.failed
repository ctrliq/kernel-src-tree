ASoC: SOF: Intel: cnl: Do not process IPC reply before firmware boot

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit acacd9eefd0def5a83244d88e5483b5f38ee7287
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/acacd9ee.failed

It is not yet clear, but it is possible to create a firmware so broken
that it will send a reply message before a FW_READY message (it is not
yet clear if FW_READY will arrive later).
Since the reply_data is allocated only after the FW_READY message, this
will lead to a NULL pointer dereference if not filtered out.

The issue was reported with IPC4 firmware but the same condition is present
for IPC3.

	Reported-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220712122357.31282-2-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit acacd9eefd0def5a83244d88e5483b5f38ee7287)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/cnl.c
diff --cc sound/soc/sof/intel/cnl.c
index e5af2645e72d,a064453f0bc3..000000000000
--- a/sound/soc/sof/intel/cnl.c
+++ b/sound/soc/sof/intel/cnl.c
@@@ -29,6 -32,74 +29,77 @@@ static const struct snd_sof_debugfs_ma
  static void cnl_ipc_host_done(struct snd_sof_dev *sdev);
  static void cnl_ipc_dsp_done(struct snd_sof_dev *sdev);
  
++<<<<<<< HEAD
++=======
+ irqreturn_t cnl_ipc4_irq_thread(int irq, void *context)
+ {
+ 	struct sof_ipc4_msg notification_data = {{ 0 }};
+ 	struct snd_sof_dev *sdev = context;
+ 	bool ipc_irq = false;
+ 	u32 hipcida, hipctdr;
+ 
+ 	hipcida = snd_sof_dsp_read(sdev, HDA_DSP_BAR, CNL_DSP_REG_HIPCIDA);
+ 	if (hipcida & CNL_DSP_REG_HIPCIDA_DONE) {
+ 		/* DSP received the message */
+ 		snd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,
+ 					CNL_DSP_REG_HIPCCTL,
+ 					CNL_DSP_REG_HIPCCTL_DONE, 0);
+ 		cnl_ipc_dsp_done(sdev);
+ 
+ 		ipc_irq = true;
+ 	}
+ 
+ 	hipctdr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, CNL_DSP_REG_HIPCTDR);
+ 	if (hipctdr & CNL_DSP_REG_HIPCTDR_BUSY) {
+ 		/* Message from DSP (reply or notification) */
+ 		u32 hipctdd = snd_sof_dsp_read(sdev, HDA_DSP_BAR,
+ 					       CNL_DSP_REG_HIPCTDD);
+ 		u32 primary = hipctdr & CNL_DSP_REG_HIPCTDR_MSG_MASK;
+ 		u32 extension = hipctdd & CNL_DSP_REG_HIPCTDD_MSG_MASK;
+ 
+ 		if (primary & SOF_IPC4_MSG_DIR_MASK) {
+ 			/* Reply received */
+ 			if (likely(sdev->fw_state == SOF_FW_BOOT_COMPLETE)) {
+ 				struct sof_ipc4_msg *data = sdev->ipc->msg.reply_data;
+ 
+ 				data->primary = primary;
+ 				data->extension = extension;
+ 
+ 				spin_lock_irq(&sdev->ipc_lock);
+ 
+ 				snd_sof_ipc_get_reply(sdev);
+ 				snd_sof_ipc_reply(sdev, data->primary);
+ 
+ 				spin_unlock_irq(&sdev->ipc_lock);
+ 			} else {
+ 				dev_dbg_ratelimited(sdev->dev,
+ 						    "IPC reply before FW_READY: %#x|%#x\n",
+ 						    primary, extension);
+ 			}
+ 		} else {
+ 			/* Notification received */
+ 			notification_data.primary = primary;
+ 			notification_data.extension = extension;
+ 
+ 			sdev->ipc->msg.rx_data = &notification_data;
+ 			snd_sof_ipc_msgs_rx(sdev);
+ 			sdev->ipc->msg.rx_data = NULL;
+ 		}
+ 
+ 		/* Let DSP know that we have finished processing the message */
+ 		cnl_ipc_host_done(sdev);
+ 
+ 		ipc_irq = true;
+ 	}
+ 
+ 	if (!ipc_irq)
+ 		/* This interrupt is not shared so no need to return IRQ_NONE. */
+ 		dev_dbg_ratelimited(sdev->dev, "nothing to do in IPC IRQ thread\n");
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
++>>>>>>> acacd9eefd0d (ASoC: SOF: Intel: cnl: Do not process IPC reply before firmware boot)
  irqreturn_t cnl_ipc_irq_thread(int irq, void *context)
  {
  	struct snd_sof_dev *sdev = context;
* Unmerged path sound/soc/sof/intel/cnl.c
