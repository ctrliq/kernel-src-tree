s390/pci: deconfigure device on release

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit a9045c2210448473a321a8bf266541e5644aaae2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a9045c22.failed

When zpci_release_device() is called on a zPCI function that is still
configured it would not be deconfigured. Until now this hasn't caused
any problems because zpci_zdev_put() is only ever called for devices
in Standby or Reserved. Fix it by adding sclp_pci_deconfigure() to the
switch when in Configured state.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit a9045c2210448473a321a8bf266541e5644aaae2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
diff --cc arch/s390/pci/pci.c
index 6af47e2fa8a9,5d6b838c0f22..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -812,15 -782,19 +812,23 @@@ void zpci_device_reserved(struct zpci_d
  void zpci_release_device(struct kref *kref)
  {
  	struct zpci_dev *zdev = container_of(kref, struct zpci_dev, kref);
+ 	int ret;
  
  	if (zdev->zbus->bus)
 -		zpci_remove_device(zdev, false);
 -
 -	if (zdev_enabled(zdev))
 -		zpci_disable_device(zdev);
 +		zpci_remove_device(zdev);
  
  	switch (zdev->state) {
++<<<<<<< HEAD
 +	case ZPCI_FN_STATE_ONLINE:
 +	case ZPCI_FN_STATE_CONFIGURED:
 +		zpci_disable_device(zdev);
 +		/* fallthrough */
++=======
+ 	case ZPCI_FN_STATE_CONFIGURED:
+ 		ret = sclp_pci_deconfigure(zdev->fid);
+ 		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
+ 		fallthrough;
++>>>>>>> a9045c221044 (s390/pci: deconfigure device on release)
  	case ZPCI_FN_STATE_STANDBY:
  		if (zdev->has_hp_slot)
  			zpci_exit_slot(zdev);
* Unmerged path arch/s390/pci/pci.c
