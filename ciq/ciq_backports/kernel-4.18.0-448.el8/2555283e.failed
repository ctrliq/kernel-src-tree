mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse

jira LE-1907
cve CVE-2022-42703
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jann Horn <jannh@google.com>
commit 2555283eb40df89945557273121e9393ef9b542b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2555283e.failed

anon_vma->degree tracks the combined number of child anon_vmas and VMAs
that use the anon_vma as their ->anon_vma.

anon_vma_clone() then assumes that for any anon_vma attached to
src->anon_vma_chain other than src->anon_vma, it is impossible for it to
be a leaf node of the VMA tree, meaning that for such VMAs ->degree is
elevated by 1 because of a child anon_vma, meaning that if ->degree
equals 1 there are no VMAs that use the anon_vma as their ->anon_vma.

This assumption is wrong because the ->degree optimization leads to leaf
nodes being abandoned on anon_vma_clone() - an existing anon_vma is
reused and no new parent-child relationship is created.  So it is
possible to reuse an anon_vma for one VMA while it is still tied to
another VMA.

This is an issue because is_mergeable_anon_vma() and its callers assume
that if two VMAs have the same ->anon_vma, the list of anon_vmas
attached to the VMAs is guaranteed to be the same.  When this assumption
is violated, vma_merge() can merge pages into a VMA that is not attached
to the corresponding anon_vma, leading to dangling page->mapping
pointers that will be dereferenced during rmap walks.

Fix it by separately tracking the number of child anon_vmas and the
number of VMAs using the anon_vma as their ->anon_vma.

Fixes: 7a3ef208e662 ("mm: prevent endless growth of anon_vma hierarchy")
	Cc: stable@kernel.org
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2555283eb40df89945557273121e9393ef9b542b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/rmap.c
diff --cc mm/rmap.c
index f905e25efc0c,93d5a6f793d2..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -291,11 -297,10 +292,15 @@@ int anon_vma_clone(struct vm_area_struc
  		anon_vma_chain_link(dst, avc, anon_vma);
  
  		/*
- 		 * Reuse existing anon_vma if its degree lower than two,
- 		 * that means it has no vma and only one anon_vma child.
+ 		 * Reuse existing anon_vma if it has no vma and only one
+ 		 * anon_vma child.
  		 *
++<<<<<<< HEAD
 +		 * Do not chose parent anon_vma, otherwise first child
 +		 * will always reuse it. Root anon_vma is never reused:
++=======
+ 		 * Root anon_vma is never reused:
++>>>>>>> 2555283eb40d (mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse)
  		 * it has self-parent reference and at least one child.
  		 */
  		if (!dst->anon_vma && src->anon_vma &&
diff --git a/include/linux/rmap.h b/include/linux/rmap.h
index 8d04e7deedc6..297744ea4dd0 100644
--- a/include/linux/rmap.h
+++ b/include/linux/rmap.h
@@ -39,12 +39,15 @@ struct anon_vma {
 	atomic_t refcount;
 
 	/*
-	 * Count of child anon_vmas and VMAs which points to this anon_vma.
+	 * Count of child anon_vmas. Equals to the count of all anon_vmas that
+	 * have ->parent pointing to this one, including itself.
 	 *
 	 * This counter is used for making decision about reusing anon_vma
 	 * instead of forking new one. See comments in function anon_vma_clone.
 	 */
-	unsigned degree;
+	unsigned long num_children;
+	/* Count of VMAs whose ->anon_vma pointer points to this object. */
+	unsigned long num_active_vmas;
 
 	struct anon_vma *parent;	/* Parent of this anon_vma */
 
* Unmerged path mm/rmap.c
