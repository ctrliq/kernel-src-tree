ASoC: cs35l41: Move cs35l41_set_cspl_mbox_cmd to shared code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit caf7c1f1de9f011ea0e6494fcb1b2ba203bd3422
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/caf7c1f1.failed

This function is used to control the DSP Firmware for cs35l41,
and will be needed by the cs35l41 hda driver, when firmware
support is added.

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
	Signed-off-by: Vitaly Rodionov <vitalyr@opensource.cirrus.com>
	Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20220509214703.4482-7-vitalyr@opensource.cirrus.com
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit caf7c1f1de9f011ea0e6494fcb1b2ba203bd3422)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/cs35l41.h
#	sound/soc/codecs/cs35l41-lib.c
#	sound/soc/codecs/cs35l41.c
#	sound/soc/codecs/cs35l41.h
diff --cc include/sound/cs35l41.h
index 1f1e3c6c9be1,2271471225b1..000000000000
--- a/include/sound/cs35l41.h
+++ b/include/sound/cs35l41.h
@@@ -27,8 -780,108 +27,108 @@@ struct cs35l41_platform_data 
  	int bst_ipk;
  	int bst_cap;
  	int dout_hiz;
 -	struct cs35l41_gpio_cfg gpio1;
 -	struct cs35l41_gpio_cfg gpio2;
 -	unsigned int spk_pos;
 -
 -	enum cs35l41_boost_type bst_type;
 +	struct cs35l41_irq_cfg irq_config1;
 +	struct cs35l41_irq_cfg irq_config2;
  };
  
++<<<<<<< HEAD
++=======
+ struct cs35l41_otp_packed_element_t {
+ 	u32 reg;
+ 	u8 shift;
+ 	u8 size;
+ };
+ 
+ struct cs35l41_otp_map_element_t {
+ 	u32 id;
+ 	u32 num_elements;
+ 	const struct cs35l41_otp_packed_element_t *map;
+ 	u32 bit_offset;
+ 	u32 word_offset;
+ };
+ 
+ enum cs35l41_cspl_mbox_status {
+ 	CSPL_MBOX_STS_RUNNING = 0,
+ 	CSPL_MBOX_STS_PAUSED = 1,
+ 	CSPL_MBOX_STS_RDY_FOR_REINIT = 2,
+ };
+ 
+ enum cs35l41_cspl_mbox_cmd {
+ 	CSPL_MBOX_CMD_NONE = 0,
+ 	CSPL_MBOX_CMD_PAUSE = 1,
+ 	CSPL_MBOX_CMD_RESUME = 2,
+ 	CSPL_MBOX_CMD_REINIT = 3,
+ 	CSPL_MBOX_CMD_STOP_PRE_REINIT = 4,
+ 	CSPL_MBOX_CMD_HIBERNATE = 5,
+ 	CSPL_MBOX_CMD_OUT_OF_HIBERNATE = 6,
+ 	CSPL_MBOX_CMD_UNKNOWN_CMD = -1,
+ 	CSPL_MBOX_CMD_INVALID_SEQUENCE = -2,
+ };
+ 
+ /*
+  * IRQs
+  */
+ #define CS35L41_IRQ(_irq, _name, _hand)		\
+ 	{					\
+ 		.irq = CS35L41_ ## _irq ## _IRQ,\
+ 		.name = _name,			\
+ 		.handler = _hand,		\
+ 	}
+ 
+ struct cs35l41_irq {
+ 	int irq;
+ 	const char *name;
+ 	irqreturn_t (*handler)(int irq, void *data);
+ };
+ 
+ #define CS35L41_REG_IRQ(_reg, _irq)					\
+ 	[CS35L41_ ## _irq ## _IRQ] = {					\
+ 		.reg_offset = (CS35L41_ ## _reg) - CS35L41_IRQ1_STATUS1,\
+ 		.mask = CS35L41_ ## _irq ## _MASK			\
+ 	}
+ 
+ /* (0x0000E010) CS35L41_IRQ1_STATUS1 */
+ #define CS35L41_BST_OVP_ERR_SHIFT		6
+ #define CS35L41_BST_OVP_ERR_MASK		BIT(CS35L41_BST_OVP_ERR_SHIFT)
+ #define CS35L41_BST_DCM_UVP_ERR_SHIFT		7
+ #define CS35L41_BST_DCM_UVP_ERR_MASK		BIT(CS35L41_BST_DCM_UVP_ERR_SHIFT)
+ #define CS35L41_BST_SHORT_ERR_SHIFT		8
+ #define CS35L41_BST_SHORT_ERR_MASK		BIT(CS35L41_BST_SHORT_ERR_SHIFT)
+ #define CS35L41_TEMP_WARN_SHIFT			15
+ #define CS35L41_TEMP_WARN_MASK			BIT(CS35L41_TEMP_WARN_SHIFT)
+ #define CS35L41_TEMP_ERR_SHIFT			17
+ #define CS35L41_TEMP_ERR_MASK			BIT(CS35L41_TEMP_ERR_SHIFT)
+ #define CS35L41_AMP_SHORT_ERR_SHIFT		31
+ #define CS35L41_AMP_SHORT_ERR_MASK		BIT(CS35L41_AMP_SHORT_ERR_SHIFT)
+ 
+ enum cs35l41_irq_list {
+ 	CS35L41_BST_OVP_ERR_IRQ,
+ 	CS35L41_BST_DCM_UVP_ERR_IRQ,
+ 	CS35L41_BST_SHORT_ERR_IRQ,
+ 	CS35L41_TEMP_WARN_IRQ,
+ 	CS35L41_TEMP_ERR_IRQ,
+ 	CS35L41_AMP_SHORT_ERR_IRQ,
+ 
+ 	CS35L41_NUM_IRQ
+ };
+ 
+ extern struct regmap_config cs35l41_regmap_i2c;
+ extern struct regmap_config cs35l41_regmap_spi;
+ 
+ int cs35l41_test_key_unlock(struct device *dev, struct regmap *regmap);
+ int cs35l41_test_key_lock(struct device *dev, struct regmap *regmap);
+ int cs35l41_otp_unpack(struct device *dev, struct regmap *regmap);
+ int cs35l41_register_errata_patch(struct device *dev, struct regmap *reg, unsigned int reg_revid);
+ int cs35l41_set_channels(struct device *dev, struct regmap *reg,
+ 			 unsigned int tx_num, unsigned int *tx_slot,
+ 			 unsigned int rx_num, unsigned int *rx_slot);
+ int cs35l41_gpio_config(struct regmap *regmap, struct cs35l41_hw_cfg *hw_cfg);
+ int cs35l41_set_cspl_mbox_cmd(struct device *dev, struct regmap *regmap,
+ 			      enum cs35l41_cspl_mbox_cmd cmd);
+ int cs35l41_init_boost(struct device *dev, struct regmap *regmap,
+ 		       struct cs35l41_hw_cfg *hw_cfg);
+ bool cs35l41_safe_reset(struct regmap *regmap, enum cs35l41_boost_type b_type);
+ int cs35l41_global_enable(struct regmap *regmap, enum cs35l41_boost_type b_type, int enable);
+ 
++>>>>>>> caf7c1f1de9f (ASoC: cs35l41: Move cs35l41_set_cspl_mbox_cmd to shared code)
  #endif /* __CS35L41_H */
diff --cc sound/soc/codecs/cs35l41.c
index 25c67931882a,0285946688f7..000000000000
--- a/sound/soc/codecs/cs35l41.c
+++ b/sound/soc/codecs/cs35l41.c
@@@ -197,6 -179,75 +197,78 @@@ static SOC_ENUM_SINGLE_DECL(pcm_sft_ram
  			    CS35L41_AMP_DIG_VOL_CTRL, 0,
  			    cs35l41_pcm_sftramp_text);
  
++<<<<<<< HEAD
++=======
+ static int cs35l41_dsp_preload_ev(struct snd_soc_dapm_widget *w,
+ 				  struct snd_kcontrol *kcontrol, int event)
+ {
+ 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+ 	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
+ 	int ret;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		if (cs35l41->dsp.cs_dsp.booted)
+ 			return 0;
+ 
+ 		return wm_adsp_early_event(w, kcontrol, event);
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		if (cs35l41->dsp.preloaded)
+ 			return 0;
+ 
+ 		if (cs35l41->dsp.cs_dsp.running) {
+ 			ret = wm_adsp_event(w, kcontrol, event);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		return wm_adsp_early_event(w, kcontrol, event);
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static int cs35l41_dsp_audio_ev(struct snd_soc_dapm_widget *w,
+ 				struct snd_kcontrol *kcontrol, int event)
+ {
+ 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+ 	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
+ 	unsigned int fw_status;
+ 	int ret;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		if (!cs35l41->dsp.cs_dsp.running)
+ 			return wm_adsp_event(w, kcontrol, event);
+ 
+ 		ret = regmap_read(cs35l41->regmap, CS35L41_DSP_MBOX_2, &fw_status);
+ 		if (ret < 0) {
+ 			dev_err(cs35l41->dev,
+ 				"Failed to read firmware status: %d\n", ret);
+ 			return ret;
+ 		}
+ 
+ 		switch (fw_status) {
+ 		case CSPL_MBOX_STS_RUNNING:
+ 		case CSPL_MBOX_STS_PAUSED:
+ 			break;
+ 		default:
+ 			dev_err(cs35l41->dev, "Firmware status is invalid: %u\n",
+ 				fw_status);
+ 			return -EINVAL;
+ 		}
+ 
+ 		return cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
+ 						 CSPL_MBOX_CMD_RESUME);
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		return cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
+ 						 CSPL_MBOX_CMD_PAUSE);
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
++>>>>>>> caf7c1f1de9f (ASoC: cs35l41: Move cs35l41_set_cspl_mbox_cmd to shared code)
  static const char * const cs35l41_pcm_source_texts[] = {"ASP", "DSP"};
  static const unsigned int cs35l41_pcm_source_values[] = {0x08, 0x32};
  static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_pcm_source_enum,
@@@ -1425,6 -1362,167 +1497,170 @@@ void cs35l41_remove(struct cs35l41_priv
  }
  EXPORT_SYMBOL_GPL(cs35l41_remove);
  
++<<<<<<< HEAD
++=======
+ static int __maybe_unused cs35l41_runtime_suspend(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "Runtime suspend\n");
+ 
+ 	if (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)
+ 		return 0;
+ 
+ 	dev_dbg(cs35l41->dev, "Enter hibernate\n");
+ 
+ 	cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
+ 	regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0088);
+ 	regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0188);
+ 
+ 	// Don't wait for ACK since bus activity would wake the device
+ 	regmap_write(cs35l41->regmap, CS35L41_DSP_VIRT1_MBOX_1,
+ 		     CSPL_MBOX_CMD_HIBERNATE);
+ 
+ 	regcache_cache_only(cs35l41->regmap, true);
+ 	regcache_mark_dirty(cs35l41->regmap);
+ 
+ 	return 0;
+ }
+ 
+ static void cs35l41_wait_for_pwrmgt_sts(struct cs35l41_private *cs35l41)
+ {
+ 	const int pwrmgt_retries = 10;
+ 	unsigned int sts;
+ 	int i, ret;
+ 
+ 	for (i = 0; i < pwrmgt_retries; i++) {
+ 		ret = regmap_read(cs35l41->regmap, CS35L41_PWRMGT_STS, &sts);
+ 		if (ret)
+ 			dev_err(cs35l41->dev, "Failed to read PWRMGT_STS: %d\n", ret);
+ 		else if (!(sts & CS35L41_WR_PEND_STS_MASK))
+ 			return;
+ 
+ 		udelay(20);
+ 	}
+ 
+ 	dev_err(cs35l41->dev, "Timed out reading PWRMGT_STS\n");
+ }
+ 
+ static int cs35l41_exit_hibernate(struct cs35l41_private *cs35l41)
+ {
+ 	const int wake_retries = 20;
+ 	const int sleep_retries = 5;
+ 	int ret, i, j;
+ 
+ 	for (i = 0; i < sleep_retries; i++) {
+ 		dev_dbg(cs35l41->dev, "Exit hibernate\n");
+ 
+ 		for (j = 0; j < wake_retries; j++) {
+ 			ret = cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
+ 							CSPL_MBOX_CMD_OUT_OF_HIBERNATE);
+ 			if (!ret)
+ 				break;
+ 
+ 			usleep_range(100, 200);
+ 		}
+ 
+ 		if (j < wake_retries) {
+ 			dev_dbg(cs35l41->dev, "Wake success at cycle: %d\n", j);
+ 			return 0;
+ 		}
+ 
+ 		dev_err(cs35l41->dev, "Wake failed, re-enter hibernate: %d\n", ret);
+ 
+ 		cs35l41_wait_for_pwrmgt_sts(cs35l41);
+ 		regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0088);
+ 
+ 		cs35l41_wait_for_pwrmgt_sts(cs35l41);
+ 		regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0188);
+ 
+ 		cs35l41_wait_for_pwrmgt_sts(cs35l41);
+ 		regmap_write(cs35l41->regmap, CS35L41_PWRMGT_CTL, 0x3);
+ 	}
+ 
+ 	dev_err(cs35l41->dev, "Timed out waking device\n");
+ 
+ 	return -ETIMEDOUT;
+ }
+ 
+ static int __maybe_unused cs35l41_runtime_resume(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	dev_dbg(cs35l41->dev, "Runtime resume\n");
+ 
+ 	if (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)
+ 		return 0;
+ 
+ 	regcache_cache_only(cs35l41->regmap, false);
+ 
+ 	ret = cs35l41_exit_hibernate(cs35l41);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Test key needs to be unlocked to allow the OTP settings to re-apply */
+ 	cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);
+ 	ret = regcache_sync(cs35l41->regmap);
+ 	cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);
+ 	if (ret) {
+ 		dev_err(cs35l41->dev, "Failed to restore register cache: %d\n", ret);
+ 		return ret;
+ 	}
+ 	cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_suspend(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "System suspend, disabling IRQ\n");
+ 	disable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_suspend_noirq(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "Late system suspend, reenabling IRQ\n");
+ 	enable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_resume_noirq(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "Early system resume, disabling IRQ\n");
+ 	disable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_resume(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "System resume, reenabling IRQ\n");
+ 	enable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ const struct dev_pm_ops cs35l41_pm_ops = {
+ 	SET_RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume, NULL)
+ 
+ 	SET_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend, cs35l41_sys_resume)
+ 	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend_noirq, cs35l41_sys_resume_noirq)
+ };
+ EXPORT_SYMBOL_GPL(cs35l41_pm_ops);
+ 
++>>>>>>> caf7c1f1de9f (ASoC: cs35l41: Move cs35l41_set_cspl_mbox_cmd to shared code)
  MODULE_DESCRIPTION("ASoC CS35L41 driver");
  MODULE_AUTHOR("David Rhodes, Cirrus Logic Inc, <david.rhodes@cirrus.com>");
  MODULE_LICENSE("GPL");
diff --cc sound/soc/codecs/cs35l41.h
index cf3f38565ade,c85cbc1dd333..000000000000
--- a/sound/soc/codecs/cs35l41.h
+++ b/sound/soc/codecs/cs35l41.h
@@@ -730,31 -21,12 +730,34 @@@
  #define CS35L41_RX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
  #define CS35L41_TX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
  
 -extern const struct dev_pm_ops cs35l41_pm_ops;
 +extern struct regmap_config cs35l41_regmap_i2c;
 +extern struct regmap_config cs35l41_regmap_spi;
 +
++<<<<<<< HEAD
 +struct cs35l41_otp_packed_element_t {
 +	u32 reg;
 +	u8 shift;
 +	u8 size;
 +};
 +
 +struct cs35l41_otp_map_element_t {
 +	u32 id;
 +	u32 num_elements;
 +	const struct cs35l41_otp_packed_element_t *map;
 +	u32 bit_offset;
 +	u32 word_offset;
 +};
 +
 +extern const struct cs35l41_otp_map_element_t
 +				cs35l41_otp_map_map[CS35L41_NUM_OTP_MAPS];
 +
 +#define CS35L41_REGSTRIDE		4
  
++=======
++>>>>>>> caf7c1f1de9f (ASoC: cs35l41: Move cs35l41_set_cspl_mbox_cmd to shared code)
  struct cs35l41_private {
 -	struct wm_adsp dsp; /* needs to be first member */
  	struct snd_soc_codec *codec;
 -	struct cs35l41_hw_cfg hw_cfg;
 +	struct cs35l41_platform_data pdata;
  	struct device *dev;
  	struct regmap *regmap;
  	struct regulator_bulk_data supplies[CS35L41_NUM_SUPPLIES];
* Unmerged path sound/soc/codecs/cs35l41-lib.c
* Unmerged path include/sound/cs35l41.h
* Unmerged path sound/soc/codecs/cs35l41-lib.c
* Unmerged path sound/soc/codecs/cs35l41.c
* Unmerged path sound/soc/codecs/cs35l41.h
