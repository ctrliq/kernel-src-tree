wifi: cfg80211: extend cfg80211_rx_assoc_resp() for MLO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 5cd212cb6415aa604ada17d5150847fd65d27337
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/5cd212cb.failed

Extend the cfg80211_rx_assoc_resp() to cover multiple
BSSes, the AP MLD address and local link addresses
for MLO.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 5cd212cb6415aa604ada17d5150847fd65d27337)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/cfg80211.h
#	net/mac80211/mlme.c
#	net/wireless/mlme.c
diff --cc include/net/cfg80211.h
index d9d8fef7db3d,2fe3eff11a8b..000000000000
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@@ -6709,6 -6886,27 +6709,30 @@@ void cfg80211_auth_timeout(struct net_d
   *	as the AC bitmap in the QoS info field
   * @req_ies: information elements from the (Re)Association Request frame
   * @req_ies_len: length of req_ies data
++<<<<<<< HEAD
++=======
+  * @ap_mld_addr: AP MLD address (in case of MLO)
+  * @links: per-link information indexed by link ID, use links[0] for
+  *	non-MLO connections
+  */
+ struct cfg80211_rx_assoc_resp {
+ 	const u8 *buf;
+ 	size_t len;
+ 	const u8 *req_ies;
+ 	size_t req_ies_len;
+ 	int uapsd_queues;
+ 	const u8 *ap_mld_addr;
+ 	struct {
+ 		const u8 *addr;
+ 		struct cfg80211_bss *bss;
+ 	} links[IEEE80211_MLD_MAX_NUM_LINKS];
+ };
+ 
+ /**
+  * cfg80211_rx_assoc_resp - notification of processed association response
+  * @dev: network device
+  * @data: association response data, &struct cfg80211_rx_assoc_resp
++>>>>>>> 5cd212cb6415 (wifi: cfg80211: extend cfg80211_rx_assoc_resp() for MLO)
   *
   * After being asked to associate via cfg80211_ops::assoc() the driver must
   * call either this function or cfg80211_auth_timeout().
diff --cc net/mac80211/mlme.c
index 58887336ec66,29c1fe8b9f4a..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -3944,8 -3995,12 +3944,17 @@@ static void ieee80211_rx_mgmt_assoc_res
  		info.success = 1;
  	}
  
++<<<<<<< HEAD
 +	cfg80211_rx_assoc_resp(sdata->dev, cbss, (u8 *)mgmt, len, uapsd_queues,
 +			       ifmgd->assoc_req_ies, ifmgd->assoc_req_ies_len);
++=======
+ 	resp.links[0].bss = cbss;
+ 	resp.buf = (u8 *)mgmt;
+ 	resp.len = len;
+ 	resp.req_ies = ifmgd->assoc_req_ies;
+ 	resp.req_ies_len = ifmgd->assoc_req_ies_len;
+ 	cfg80211_rx_assoc_resp(sdata->dev, &resp);
++>>>>>>> 5cd212cb6415 (wifi: cfg80211: extend cfg80211_rx_assoc_resp() for MLO)
  notify_driver:
  	drv_mgd_complete_tx(sdata->local, sdata, &info);
  	kfree(elems);
diff --cc net/wireless/mlme.c
index 54121647d29f,80f11a29cb86..000000000000
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@@ -28,29 -27,42 +28,68 @@@ void cfg80211_rx_assoc_resp(struct net_
  	struct wireless_dev *wdev = dev->ieee80211_ptr;
  	struct wiphy *wiphy = wdev->wiphy;
  	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
++<<<<<<< HEAD
 +	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
 +	struct cfg80211_connect_resp_params cr;
 +	const u8 *resp_ie = mgmt->u.assoc_resp.variable;
 +	size_t resp_ie_len = len - offsetof(struct ieee80211_mgmt,
 +					    u.assoc_resp.variable);
 +
 +	if (bss->channel->band == NL80211_BAND_S1GHZ) {
 +		resp_ie = (u8 *)&mgmt->u.s1g_assoc_resp.variable;
 +		resp_ie_len = len - offsetof(struct ieee80211_mgmt,
 +					     u.s1g_assoc_resp.variable);
 +	}
 +
 +	memset(&cr, 0, sizeof(cr));
 +	cr.status = (int)le16_to_cpu(mgmt->u.assoc_resp.status_code);
 +	cr.bssid = mgmt->bssid;
 +	cr.bss = bss;
 +	cr.req_ie = req_ies;
 +	cr.req_ie_len = req_ies_len;
 +	cr.resp_ie = resp_ie;
 +	cr.resp_ie_len = resp_ie_len;
 +	cr.timeout_reason = NL80211_TIMEOUT_UNSPECIFIED;
 +
 +	trace_cfg80211_send_rx_assoc(dev, bss);
++=======
+ 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)data->buf;
+ 	struct cfg80211_connect_resp_params cr = {
+ 		.timeout_reason = NL80211_TIMEOUT_UNSPECIFIED,
+ 		.req_ie = data->req_ies,
+ 		.req_ie_len = data->req_ies_len,
+ 		.resp_ie = mgmt->u.assoc_resp.variable,
+ 		.resp_ie_len = data->len -
+ 			       offsetof(struct ieee80211_mgmt,
+ 					u.assoc_resp.variable),
+ 		.status = le16_to_cpu(mgmt->u.assoc_resp.status_code),
+ 		.ap_mld_addr = data->ap_mld_addr,
+ 	};
+ 	unsigned int link_id;
+ 
+ 	for (link_id = 0; link_id < ARRAY_SIZE(data->links); link_id++) {
+ 		cr.links[link_id].bss = data->links[link_id].bss;
+ 		if (!cr.links[link_id].bss)
+ 			continue;
+ 		cr.links[link_id].bssid = data->links[link_id].bss->bssid;
+ 		cr.links[link_id].addr = data->links[link_id].addr;
+ 		/* need to have local link addresses for MLO connections */
+ 		WARN_ON(cr.ap_mld_addr && !cr.links[link_id].addr);
+ 
+ 		if (cr.links[link_id].bss->channel->band == NL80211_BAND_S1GHZ) {
+ 			WARN_ON(link_id);
+ 			cr.resp_ie = (u8 *)&mgmt->u.s1g_assoc_resp.variable;
+ 			cr.resp_ie_len = data->len -
+ 					 offsetof(struct ieee80211_mgmt,
+ 						  u.s1g_assoc_resp.variable);
+ 		}
+ 
+ 		if (cr.ap_mld_addr)
+ 			cr.valid_links |= BIT(link_id);
+ 	}
+ 
+ 	trace_cfg80211_send_rx_assoc(dev, data);
++>>>>>>> 5cd212cb6415 (wifi: cfg80211: extend cfg80211_rx_assoc_resp() for MLO)
  
  	/*
  	 * This is a bit of a hack, we don't notify userspace of
@@@ -59,8 -71,15 +98,20 @@@
  	 * frame instead of reassoc.
  	 */
  	if (cfg80211_sme_rx_assoc_resp(wdev, cr.status)) {
++<<<<<<< HEAD
 +		cfg80211_unhold_bss(bss_from_pub(bss));
 +		cfg80211_put_bss(wiphy, bss);
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(data->links); link_id++) {
+ 			struct cfg80211_bss *bss = data->links[link_id].bss;
+ 
+ 			if (!bss)
+ 				continue;
+ 
+ 			cfg80211_unhold_bss(bss_from_pub(bss));
+ 			cfg80211_put_bss(wiphy, bss);
+ 		}
++>>>>>>> 5cd212cb6415 (wifi: cfg80211: extend cfg80211_rx_assoc_resp() for MLO)
  		return;
  	}
  
* Unmerged path include/net/cfg80211.h
* Unmerged path net/mac80211/mlme.c
* Unmerged path net/wireless/mlme.c
diff --git a/net/wireless/trace.h b/net/wireless/trace.h
index cf7472b8675b..bd6c4a239e52 100644
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -2827,20 +2827,20 @@ DEFINE_EVENT(netdev_evt_only, cfg80211_send_rx_auth,
 );
 
 TRACE_EVENT(cfg80211_send_rx_assoc,
-	TP_PROTO(struct net_device *netdev, struct cfg80211_bss *bss),
-	TP_ARGS(netdev, bss),
+	TP_PROTO(struct net_device *netdev,
+		 struct cfg80211_rx_assoc_resp *data),
+	TP_ARGS(netdev, data),
 	TP_STRUCT__entry(
 		NETDEV_ENTRY
-		MAC_ENTRY(bssid)
-		CHAN_ENTRY
+		MAC_ENTRY(ap_addr)
 	),
 	TP_fast_assign(
 		NETDEV_ASSIGN;
-		MAC_ASSIGN(bssid, bss->bssid);
-		CHAN_ASSIGN(bss->channel);
+		MAC_ASSIGN(ap_addr,
+			   data->ap_mld_addr ?: data->links[0].bss->bssid);
 	),
-	TP_printk(NETDEV_PR_FMT ", " MAC_PR_FMT ", " CHAN_PR_FMT,
-		  NETDEV_PR_ARG, MAC_PR_ARG(bssid), CHAN_PR_ARG)
+	TP_printk(NETDEV_PR_FMT ", " MAC_PR_FMT,
+		  NETDEV_PR_ARG, MAC_PR_ARG(ap_addr))
 );
 
 DECLARE_EVENT_CLASS(netdev_frame_event,
