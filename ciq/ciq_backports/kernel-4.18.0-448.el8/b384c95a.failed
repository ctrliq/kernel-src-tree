net: icmp: add skb drop reasons to icmp protocol

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit b384c95a861eebf47e88695cf6a29f34e0b10b0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b384c95a.failed

Replace kfree_skb() used in icmp_rcv() and icmpv6_rcv() with
kfree_skb_reason().

In order to get the reasons of the skb drops after icmp message handle,
we change the return type of 'handler()' in 'struct icmp_control' from
'bool' to 'enum skb_drop_reason'. This may change its original
intention, as 'false' means failure, but 'SKB_NOT_DROPPED_YET' means
success now. Therefore, all 'handler' and the call of them need to be
handled. Following 'handler' functions are involved:

icmp_unreach()
icmp_redirect()
icmp_echo()
icmp_timestamp()
icmp_discard()

And following new drop reasons are added:

SKB_DROP_REASON_ICMP_CSUM
SKB_DROP_REASON_INVALID_PROTO

The reason 'INVALID_PROTO' is introduced for the case that the packet
doesn't follow rfc 1122 and is dropped. This is not a common case, and
I believe we can locate the problem from the data in the packet. For now,
this 'INVALID_PROTO' is used for the icmp broadcasts with wrong types.

Maybe there should be a document file for these reasons. For example,
list all the case that causes the 'UNHANDLED_PROTO' and 'INVALID_PROTO'
drop reason. Therefore, users can locate their problems according to the
document.

	Reviewed-by: Hao Peng <flyingpeng@tencent.com>
	Reviewed-by: Jiang Biao <benbjiang@tencent.com>
	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b384c95a861eebf47e88695cf6a29f34e0b10b0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/trace/events/skb.h
#	net/ipv4/icmp.c
#	net/ipv6/icmp.c
diff --cc include/linux/skbuff.h
index 6050fa383222,9b81ba497665..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,139 +318,143 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_NOT_DROPPED_YET = 0,
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
+ 	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+ 					 * see the document for rp_filter
+ 					 * in ip-sysctl.rst for more
+ 					 * information
+ 					 */
+ 	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+ 						  * is multicast, but L3 is
+ 						  * unicast.
+ 						  */
+ 	SKB_DROP_REASON_XFRM_POLICY,	/* xfrm policy check failed */
+ 	SKB_DROP_REASON_IP_NOPROTO,	/* no support for IP protocol */
+ 	SKB_DROP_REASON_SOCKET_RCVBUFF,	/* socket receive buff is full */
+ 	SKB_DROP_REASON_PROTO_MEM,	/* proto memory limition, such as
+ 					 * udp packet drop out of
+ 					 * udp_memory_allocated.
+ 					 */
+ 	SKB_DROP_REASON_TCP_MD5NOTFOUND,	/* no MD5 hash and one
+ 						 * expected, corresponding
+ 						 * to LINUX_MIB_TCPMD5NOTFOUND
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5UNEXPECTED,	/* MD5 hash and we're not
+ 						 * expecting one, corresponding
+ 						 * to LINUX_MIB_TCPMD5UNEXPECTED
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5FAILURE,	/* MD5 hash and its wrong,
+ 					 * corresponding to
+ 					 * LINUX_MIB_TCPMD5FAILURE
+ 					 */
+ 	SKB_DROP_REASON_SOCKET_BACKLOG,	/* failed to add skb to socket
+ 					 * backlog (see
+ 					 * LINUX_MIB_TCPBACKLOGDROP)
+ 					 */
+ 	SKB_DROP_REASON_TCP_FLAGS,	/* TCP flags invalid */
+ 	SKB_DROP_REASON_TCP_ZEROWINDOW,	/* TCP receive window size is zero,
+ 					 * see LINUX_MIB_TCPZEROWINDOWDROP
+ 					 */
+ 	SKB_DROP_REASON_TCP_OLD_DATA,	/* the TCP data reveived is already
+ 					 * received before (spurious retrans
+ 					 * may happened), see
+ 					 * LINUX_MIB_DELAYEDACKLOST
+ 					 */
+ 	SKB_DROP_REASON_TCP_OVERWINDOW,	/* the TCP data is out of window,
+ 					 * the seq of the first byte exceed
+ 					 * the right edges of receive
+ 					 * window
+ 					 */
+ 	SKB_DROP_REASON_TCP_OFOMERGE,	/* the data of skb is already in
+ 					 * the ofo queue, corresponding to
+ 					 * LINUX_MIB_TCPOFOMERGE
+ 					 */
+ 	SKB_DROP_REASON_IP_OUTNOROUTES,	/* route lookup failed */
+ 	SKB_DROP_REASON_BPF_CGROUP_EGRESS,	/* dropped by
+ 						 * BPF_PROG_TYPE_CGROUP_SKB
+ 						 * eBPF program
+ 						 */
+ 	SKB_DROP_REASON_IPV6DISABLED,	/* IPv6 is disabled on the device */
+ 	SKB_DROP_REASON_NEIGH_CREATEFAIL,	/* failed to create neigh
+ 						 * entry
+ 						 */
+ 	SKB_DROP_REASON_NEIGH_FAILED,	/* neigh entry in failed state */
+ 	SKB_DROP_REASON_NEIGH_QUEUEFULL,	/* arp_queue for neigh
+ 						 * entry is full
+ 						 */
+ 	SKB_DROP_REASON_NEIGH_DEAD,	/* neigh entry is dead */
+ 	SKB_DROP_REASON_TC_EGRESS,	/* dropped in TC egress HOOK */
+ 	SKB_DROP_REASON_QDISC_DROP,	/* dropped by qdisc when packet
+ 					 * outputting (failed to enqueue to
+ 					 * current qdisc)
+ 					 */
+ 	SKB_DROP_REASON_CPU_BACKLOG,	/* failed to enqueue the skb to
+ 					 * the per CPU backlog queue. This
+ 					 * can be caused by backlog queue
+ 					 * full (see netdev_max_backlog in
+ 					 * net.rst) or RPS flow limit
+ 					 */
+ 	SKB_DROP_REASON_XDP,		/* dropped by XDP in input path */
+ 	SKB_DROP_REASON_TC_INGRESS,	/* dropped in TC ingress HOOK */
+ 	SKB_DROP_REASON_UNHANDLED_PROTO,	/* protocol not implemented
+ 						 * or not supported
+ 						 */
+ 	SKB_DROP_REASON_SKB_CSUM,	/* sk_buff checksum computation
+ 					 * error
+ 					 */
+ 	SKB_DROP_REASON_SKB_GSO_SEG,	/* gso segmentation error */
+ 	SKB_DROP_REASON_SKB_UCOPY_FAULT,	/* failed to copy data from
+ 						 * user space, e.g., via
+ 						 * zerocopy_sg_from_iter()
+ 						 * or skb_orphan_frags_rx()
+ 						 */
+ 	SKB_DROP_REASON_DEV_HDR,	/* device driver specific
+ 					 * header/metadata is invalid
+ 					 */
+ 	/* the device is not ready to xmit/recv due to any of its data
+ 	 * structure that is not up/ready/initialized, e.g., the IFF_UP is
+ 	 * not set, or driver specific tun->tfiles[txq] is not initialized
+ 	 */
+ 	SKB_DROP_REASON_DEV_READY,
+ 	SKB_DROP_REASON_FULL_RING,	/* ring buffer is full */
+ 	SKB_DROP_REASON_NOMEM,		/* error due to OOM */
+ 	SKB_DROP_REASON_HDR_TRUNC,      /* failed to trunc/extract the header
+ 					 * from networking data, e.g., failed
+ 					 * to pull the protocol header from
+ 					 * frags via pskb_may_pull()
+ 					 */
+ 	SKB_DROP_REASON_TAP_FILTER,     /* dropped by (ebpf) filter directly
+ 					 * attached to tun/tap, e.g., via
+ 					 * TUNSETFILTEREBPF
+ 					 */
+ 	SKB_DROP_REASON_TAP_TXFILTER,	/* dropped by tx filter implemented
+ 					 * at tun/tap, e.g., check_filter()
+ 					 */
+ 	SKB_DROP_REASON_ICMP_CSUM,	/* ICMP checksum error */
+ 	SKB_DROP_REASON_INVALID_PROTO,	/* the packet doesn't follow RFC
+ 					 * 2211, such as a broadcasts
+ 					 * ICMP_TIMESTAMP
+ 					 */
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/trace/events/skb.h
index 294c61bbe44b,42647114fffe..000000000000
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@@ -11,6 -11,58 +11,61 @@@
  
  #define TRACE_SKB_DROP_REASON					\
  	EM(SKB_DROP_REASON_NOT_SPECIFIED, NOT_SPECIFIED)	\
++<<<<<<< HEAD
++=======
+ 	EM(SKB_DROP_REASON_NO_SOCKET, NO_SOCKET)		\
+ 	EM(SKB_DROP_REASON_PKT_TOO_SMALL, PKT_TOO_SMALL)	\
+ 	EM(SKB_DROP_REASON_TCP_CSUM, TCP_CSUM)			\
+ 	EM(SKB_DROP_REASON_SOCKET_FILTER, SOCKET_FILTER)	\
+ 	EM(SKB_DROP_REASON_UDP_CSUM, UDP_CSUM)			\
+ 	EM(SKB_DROP_REASON_NETFILTER_DROP, NETFILTER_DROP)	\
+ 	EM(SKB_DROP_REASON_OTHERHOST, OTHERHOST)		\
+ 	EM(SKB_DROP_REASON_IP_CSUM, IP_CSUM)			\
+ 	EM(SKB_DROP_REASON_IP_INHDR, IP_INHDR)			\
+ 	EM(SKB_DROP_REASON_IP_RPFILTER, IP_RPFILTER)		\
+ 	EM(SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST,		\
+ 	   UNICAST_IN_L2_MULTICAST)				\
+ 	EM(SKB_DROP_REASON_XFRM_POLICY, XFRM_POLICY)		\
+ 	EM(SKB_DROP_REASON_IP_NOPROTO, IP_NOPROTO)		\
+ 	EM(SKB_DROP_REASON_SOCKET_RCVBUFF, SOCKET_RCVBUFF)	\
+ 	EM(SKB_DROP_REASON_PROTO_MEM, PROTO_MEM)		\
+ 	EM(SKB_DROP_REASON_TCP_MD5NOTFOUND, TCP_MD5NOTFOUND)	\
+ 	EM(SKB_DROP_REASON_TCP_MD5UNEXPECTED,			\
+ 	   TCP_MD5UNEXPECTED)					\
+ 	EM(SKB_DROP_REASON_TCP_MD5FAILURE, TCP_MD5FAILURE)	\
+ 	EM(SKB_DROP_REASON_SOCKET_BACKLOG, SOCKET_BACKLOG)	\
+ 	EM(SKB_DROP_REASON_TCP_FLAGS, TCP_FLAGS)		\
+ 	EM(SKB_DROP_REASON_TCP_ZEROWINDOW, TCP_ZEROWINDOW)	\
+ 	EM(SKB_DROP_REASON_TCP_OLD_DATA, TCP_OLD_DATA)		\
+ 	EM(SKB_DROP_REASON_TCP_OVERWINDOW, TCP_OVERWINDOW)	\
+ 	EM(SKB_DROP_REASON_TCP_OFOMERGE, TCP_OFOMERGE)		\
+ 	EM(SKB_DROP_REASON_IP_OUTNOROUTES, IP_OUTNOROUTES)	\
+ 	EM(SKB_DROP_REASON_BPF_CGROUP_EGRESS,			\
+ 	   BPF_CGROUP_EGRESS)					\
+ 	EM(SKB_DROP_REASON_IPV6DISABLED, IPV6DISABLED)		\
+ 	EM(SKB_DROP_REASON_NEIGH_CREATEFAIL, NEIGH_CREATEFAIL)	\
+ 	EM(SKB_DROP_REASON_NEIGH_FAILED, NEIGH_FAILED)		\
+ 	EM(SKB_DROP_REASON_NEIGH_QUEUEFULL, NEIGH_QUEUEFULL)	\
+ 	EM(SKB_DROP_REASON_NEIGH_DEAD, NEIGH_DEAD)		\
+ 	EM(SKB_DROP_REASON_TC_EGRESS, TC_EGRESS)		\
+ 	EM(SKB_DROP_REASON_QDISC_DROP, QDISC_DROP)		\
+ 	EM(SKB_DROP_REASON_CPU_BACKLOG, CPU_BACKLOG)		\
+ 	EM(SKB_DROP_REASON_XDP, XDP)				\
+ 	EM(SKB_DROP_REASON_TC_INGRESS, TC_INGRESS)		\
+ 	EM(SKB_DROP_REASON_UNHANDLED_PROTO, UNHANDLED_PROTO)	\
+ 	EM(SKB_DROP_REASON_SKB_CSUM, SKB_CSUM)			\
+ 	EM(SKB_DROP_REASON_SKB_GSO_SEG, SKB_GSO_SEG)		\
+ 	EM(SKB_DROP_REASON_SKB_UCOPY_FAULT, SKB_UCOPY_FAULT)	\
+ 	EM(SKB_DROP_REASON_DEV_HDR, DEV_HDR)			\
+ 	EM(SKB_DROP_REASON_DEV_READY, DEV_READY)		\
+ 	EM(SKB_DROP_REASON_FULL_RING, FULL_RING)		\
+ 	EM(SKB_DROP_REASON_NOMEM, NOMEM)			\
+ 	EM(SKB_DROP_REASON_HDR_TRUNC, HDR_TRUNC)		\
+ 	EM(SKB_DROP_REASON_TAP_FILTER, TAP_FILTER)		\
+ 	EM(SKB_DROP_REASON_TAP_TXFILTER, TAP_TXFILTER)		\
+ 	EM(SKB_DROP_REASON_ICMP_CSUM, ICMP_CSUM)		\
+ 	EM(SKB_DROP_REASON_INVALID_PROTO, INVALID_PROTO)	\
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  	EMe(SKB_DROP_REASON_MAX, MAX)
  
  #undef EM
diff --cc net/ipv4/icmp.c
index 6c52ca27bf6f,236debd9fded..000000000000
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@@ -921,11 -964,11 +924,16 @@@ static enum skb_drop_reason icmp_redire
  
  	if (!pskb_may_pull(skb, sizeof(struct iphdr))) {
  		/* there aught to be a stat */
- 		return false;
+ 		return SKB_DROP_REASON_NOMEM;
  	}
  
++<<<<<<< HEAD
 +	icmp_socket_deliver(skb, icmp_hdr(skb)->un.gateway);
 +	return true;
++=======
+ 	icmp_socket_deliver(skb, ntohl(icmp_hdr(skb)->un.gateway));
+ 	return SKB_NOT_DROPPED_YET;
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  }
  
  /*
@@@ -940,26 -983,141 +948,40 @@@
   *	See also WRT handling of options once they are done and working.
   */
  
- static bool icmp_echo(struct sk_buff *skb)
+ static enum skb_drop_reason icmp_echo(struct sk_buff *skb)
  {
 -	struct icmp_bxm icmp_param;
  	struct net *net;
  
  	net = dev_net(skb_dst(skb)->dev);
++<<<<<<< HEAD
 +	if (!net->ipv4.sysctl_icmp_echo_ignore_all) {
 +		struct icmp_bxm icmp_param;
++=======
+ 	/* should there be an ICMP stat for ignored echos? */
+ 	if (net->ipv4.sysctl_icmp_echo_ignore_all)
+ 		return SKB_NOT_DROPPED_YET;
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  
 -	icmp_param.data.icmph	   = *icmp_hdr(skb);
 -	icmp_param.skb		   = skb;
 -	icmp_param.offset	   = 0;
 -	icmp_param.data_len	   = skb->len;
 -	icmp_param.head_len	   = sizeof(struct icmphdr);
 -
 -	if (icmp_param.data.icmph.type == ICMP_ECHO)
 +		icmp_param.data.icmph	   = *icmp_hdr(skb);
  		icmp_param.data.icmph.type = ICMP_ECHOREPLY;
++<<<<<<< HEAD
 +		icmp_param.skb		   = skb;
 +		icmp_param.offset	   = 0;
 +		icmp_param.data_len	   = skb->len;
 +		icmp_param.head_len	   = sizeof(struct icmphdr);
 +		icmp_reply(&icmp_param, skb);
 +	}
 +	/* should there be an ICMP stat for ignored echos? */
 +	return true;
++=======
+ 	else if (!icmp_build_probe(skb, &icmp_param.data.icmph))
+ 		return SKB_NOT_DROPPED_YET;
+ 
+ 	icmp_reply(&icmp_param, skb);
+ 	return SKB_NOT_DROPPED_YET;
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  }
  
 -/*	Helper for icmp_echo and icmpv6_echo_reply.
 - *	Searches for net_device that matches PROBE interface identifier
 - *		and builds PROBE reply message in icmphdr.
 - *
 - *	Returns false if PROBE responses are disabled via sysctl
 - */
 -
 -bool icmp_build_probe(struct sk_buff *skb, struct icmphdr *icmphdr)
 -{
 -	struct icmp_ext_hdr *ext_hdr, _ext_hdr;
 -	struct icmp_ext_echo_iio *iio, _iio;
 -	struct net *net = dev_net(skb->dev);
 -	struct net_device *dev;
 -	char buff[IFNAMSIZ];
 -	u16 ident_len;
 -	u8 status;
 -
 -	if (!net->ipv4.sysctl_icmp_echo_enable_probe)
 -		return false;
 -
 -	/* We currently only support probing interfaces on the proxy node
 -	 * Check to ensure L-bit is set
 -	 */
 -	if (!(ntohs(icmphdr->un.echo.sequence) & 1))
 -		return false;
 -	/* Clear status bits in reply message */
 -	icmphdr->un.echo.sequence &= htons(0xFF00);
 -	if (icmphdr->type == ICMP_EXT_ECHO)
 -		icmphdr->type = ICMP_EXT_ECHOREPLY;
 -	else
 -		icmphdr->type = ICMPV6_EXT_ECHO_REPLY;
 -	ext_hdr = skb_header_pointer(skb, 0, sizeof(_ext_hdr), &_ext_hdr);
 -	/* Size of iio is class_type dependent.
 -	 * Only check header here and assign length based on ctype in the switch statement
 -	 */
 -	iio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(iio->extobj_hdr), &_iio);
 -	if (!ext_hdr || !iio)
 -		goto send_mal_query;
 -	if (ntohs(iio->extobj_hdr.length) <= sizeof(iio->extobj_hdr) ||
 -	    ntohs(iio->extobj_hdr.length) > sizeof(_iio))
 -		goto send_mal_query;
 -	ident_len = ntohs(iio->extobj_hdr.length) - sizeof(iio->extobj_hdr);
 -	iio = skb_header_pointer(skb, sizeof(_ext_hdr),
 -				 sizeof(iio->extobj_hdr) + ident_len, &_iio);
 -	if (!iio)
 -		goto send_mal_query;
 -
 -	status = 0;
 -	dev = NULL;
 -	switch (iio->extobj_hdr.class_type) {
 -	case ICMP_EXT_ECHO_CTYPE_NAME:
 -		if (ident_len >= IFNAMSIZ)
 -			goto send_mal_query;
 -		memset(buff, 0, sizeof(buff));
 -		memcpy(buff, &iio->ident.name, ident_len);
 -		dev = dev_get_by_name(net, buff);
 -		break;
 -	case ICMP_EXT_ECHO_CTYPE_INDEX:
 -		if (ident_len != sizeof(iio->ident.ifindex))
 -			goto send_mal_query;
 -		dev = dev_get_by_index(net, ntohl(iio->ident.ifindex));
 -		break;
 -	case ICMP_EXT_ECHO_CTYPE_ADDR:
 -		if (ident_len < sizeof(iio->ident.addr.ctype3_hdr) ||
 -		    ident_len != sizeof(iio->ident.addr.ctype3_hdr) +
 -				 iio->ident.addr.ctype3_hdr.addrlen)
 -			goto send_mal_query;
 -		switch (ntohs(iio->ident.addr.ctype3_hdr.afi)) {
 -		case ICMP_AFI_IP:
 -			if (iio->ident.addr.ctype3_hdr.addrlen != sizeof(struct in_addr))
 -				goto send_mal_query;
 -			dev = ip_dev_find(net, iio->ident.addr.ip_addr.ipv4_addr);
 -			break;
 -#if IS_ENABLED(CONFIG_IPV6)
 -		case ICMP_AFI_IP6:
 -			if (iio->ident.addr.ctype3_hdr.addrlen != sizeof(struct in6_addr))
 -				goto send_mal_query;
 -			dev = ipv6_stub->ipv6_dev_find(net, &iio->ident.addr.ip_addr.ipv6_addr, dev);
 -			dev_hold(dev);
 -			break;
 -#endif
 -		default:
 -			goto send_mal_query;
 -		}
 -		break;
 -	default:
 -		goto send_mal_query;
 -	}
 -	if (!dev) {
 -		icmphdr->code = ICMP_EXT_CODE_NO_IF;
 -		return true;
 -	}
 -	/* Fill bits in reply message */
 -	if (dev->flags & IFF_UP)
 -		status |= ICMP_EXT_ECHOREPLY_ACTIVE;
 -	if (__in_dev_get_rcu(dev) && __in_dev_get_rcu(dev)->ifa_list)
 -		status |= ICMP_EXT_ECHOREPLY_IPV4;
 -	if (!list_empty(&rcu_dereference(dev->ip6_ptr)->addr_list))
 -		status |= ICMP_EXT_ECHOREPLY_IPV6;
 -	dev_put(dev);
 -	icmphdr->un.echo.sequence |= htons(status);
 -	return true;
 -send_mal_query:
 -	icmphdr->code = ICMP_EXT_CODE_MAL_QUERY;
 -	return true;
 -}
 -EXPORT_SYMBOL_GPL(icmp_build_probe);
 -
  /*
   *	Handle ICMP Timestamp requests.
   *	RFC 1122: 3.2.2.8 MAY implement ICMP timestamp requests.
@@@ -1046,16 -1209,32 +1073,36 @@@ int icmp_rcv(struct sk_buff *skb
  	icmph = icmp_hdr(skb);
  
  	ICMPMSGIN_INC_STATS(net, icmph->type);
++<<<<<<< HEAD
++=======
+ 
+ 	/* Check for ICMP Extended Echo (PROBE) messages */
+ 	if (icmph->type == ICMP_EXT_ECHO) {
+ 		/* We can't use icmp_pointers[].handler() because it is an array of
+ 		 * size NR_ICMP_TYPES + 1 (19 elements) and PROBE has code 42.
+ 		 */
+ 		reason = icmp_echo(skb);
+ 		goto reason_check;
+ 	}
+ 
+ 	if (icmph->type == ICMP_EXT_ECHOREPLY) {
+ 		reason = ping_rcv(skb);
+ 		goto reason_check;
+ 	}
+ 
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  	/*
  	 *	18 is the highest 'known' ICMP type. Anything else is a mystery
  	 *
  	 *	RFC 1122: 3.2.2  Unknown ICMP messages types MUST be silently
  	 *		  discarded.
  	 */
- 	if (icmph->type > NR_ICMP_TYPES)
+ 	if (icmph->type > NR_ICMP_TYPES) {
+ 		reason = SKB_DROP_REASON_UNHANDLED_PROTO;
  		goto error;
+ 	}
  
 +
  	/*
  	 *	Parse the ICMP message
  	 */
@@@ -1080,9 -1261,9 +1129,15 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	success = icmp_pointers[icmph->type].handler(skb);
 +
 +	if (success)  {
++=======
+ 	reason = icmp_pointers[icmph->type].handler(skb);
+ reason_check:
+ 	if (!reason)  {
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  		consume_skb(skb);
  		return NET_RX_SUCCESS;
  	}
diff --cc net/ipv6/icmp.c
index 56cce2f40e72,01c8003c9fc9..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -802,7 -864,9 +802,13 @@@ out
  
  static int icmpv6_rcv(struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct net_device *dev = skb->dev;
++=======
+ 	enum skb_drop_reason reason = SKB_DROP_REASON_NOT_SPECIFIED;
+ 	struct net *net = dev_net(skb->dev);
+ 	struct net_device *dev = icmp6_dev(skb);
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  	struct inet6_dev *idev = __in6_dev_get(dev);
  	const struct in6_addr *saddr, *daddr;
  	struct icmp6hdr *hdr;
@@@ -855,9 -929,13 +865,16 @@@
  		break;
  
  	case ICMPV6_ECHO_REPLY:
- 		success = ping_rcv(skb);
+ 		reason = ping_rcv(skb);
+ 		break;
+ 
++<<<<<<< HEAD
++=======
+ 	case ICMPV6_EXT_ECHO_REPLY:
+ 		reason = ping_rcv(skb);
  		break;
  
++>>>>>>> b384c95a861e (net: icmp: add skb drop reasons to icmp protocol)
  	case ICMPV6_PKT_TOOBIG:
  		/* BUGGG_FUTURE: if packet contains rthdr, we cannot update
  		   standard destination cache. Seems, only "advanced"
* Unmerged path include/linux/skbuff.h
diff --git a/include/net/ping.h b/include/net/ping.h
index fd080e043a6e..a124a25f941b 100644
--- a/include/net/ping.h
+++ b/include/net/ping.h
@@ -80,7 +80,7 @@ int  ping_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 int  ping_common_sendmsg(int family, struct msghdr *msg, size_t len,
 			 void *user_icmph, size_t icmph_len);
 int  ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
-bool ping_rcv(struct sk_buff *skb);
+enum skb_drop_reason ping_rcv(struct sk_buff *skb);
 
 #ifdef CONFIG_PROC_FS
 void *ping_seq_start(struct seq_file *seq, loff_t *pos, sa_family_t family);
* Unmerged path include/trace/events/skb.h
* Unmerged path net/ipv4/icmp.c
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index 4bc0ed5f26bd..715a81d06900 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -980,12 +980,12 @@ EXPORT_SYMBOL_GPL(ping_queue_rcv_skb);
  *	All we need to do is get the socket.
  */
 
-bool ping_rcv(struct sk_buff *skb)
+enum skb_drop_reason ping_rcv(struct sk_buff *skb)
 {
+	enum skb_drop_reason reason = SKB_DROP_REASON_NO_SOCKET;
 	struct sock *sk;
 	struct net *net = dev_net(skb->dev);
 	struct icmphdr *icmph = icmp_hdr(skb);
-	bool rc = false;
 
 	/* We assume the packet has already been checked by icmp_rcv */
 
@@ -1000,15 +1000,17 @@ bool ping_rcv(struct sk_buff *skb)
 		struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
 
 		pr_debug("rcv on socket %p\n", sk);
-		if (skb2 && !ping_queue_rcv_skb(sk, skb2))
-			rc = true;
+		if (skb2)
+			reason = __ping_queue_rcv_skb(sk, skb2);
+		else
+			reason = SKB_DROP_REASON_NOMEM;
 		sock_put(sk);
 	}
 
-	if (!rc)
+	if (reason)
 		pr_debug("no socket, dropping\n");
 
-	return rc;
+	return reason;
 }
 EXPORT_SYMBOL_GPL(ping_rcv);
 
* Unmerged path net/ipv6/icmp.c
