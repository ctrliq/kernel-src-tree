raw: Use helpers for the hlist_nulls variant.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Kuniyuki Iwashima <kuniyu@amazon.com>
commit f289c02bf41b55fbfccf21d72c4ac44cd4a7a107
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f289c02b.failed

hlist_nulls_add_head_rcu() and hlist_nulls_for_each_entry() have dedicated
macros for sk.

	Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f289c02bf41b55fbfccf21d72c4ac44cd4a7a107)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/raw.c
#	net/ipv4/raw_diag.c
#	net/ipv6/raw.c
diff --cc net/ipv4/raw.c
index 946f8761caa1,959bea12dc48..000000000000
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@@ -97,14 -91,15 +97,20 @@@ EXPORT_SYMBOL_GPL(raw_v4_hashinfo)
  int raw_hash_sk(struct sock *sk)
  {
  	struct raw_hashinfo *h = sk->sk_prot->h.raw_hash;
 -	struct hlist_nulls_head *hlist;
 +	struct hlist_head *head;
  
 -	hlist = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];
 +	head = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];
  
  	write_lock_bh(&h->lock);
++<<<<<<< HEAD
 +	sk_add_node(sk, head);
++=======
+ 	__sk_nulls_add_node_rcu(sk, hlist);
+ 	sock_set_flag(sk, SOCK_RCU_FREE);
+ 	write_unlock_bh(&h->lock);
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  	sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
 +	write_unlock_bh(&h->lock);
  
  	return 0;
  }
@@@ -173,23 -162,20 +179,32 @@@ static int icmp_filter(const struct soc
   */
  static int raw_v4_input(struct sk_buff *skb, const struct iphdr *iph, int hash)
  {
 -	struct net *net = dev_net(skb->dev);
 -	struct hlist_nulls_head *hlist;
 -	struct hlist_nulls_node *hnode;
  	int sdif = inet_sdif(skb);
  	int dif = inet_iif(skb);
 -	int delivered = 0;
  	struct sock *sk;
 +	struct hlist_head *head;
 +	int delivered = 0;
 +	struct net *net;
  
++<<<<<<< HEAD
 +	read_lock(&raw_v4_hashinfo.lock);
 +	head = &raw_v4_hashinfo.ht[hash];
 +	if (hlist_empty(head))
 +		goto out;
 +
 +	net = dev_net(skb->dev);
 +	sk = __raw_v4_lookup(net, __sk_head(head), iph->protocol,
 +			     iph->saddr, iph->daddr, dif, sdif);
 +
 +	while (sk) {
++=======
+ 	hlist = &raw_v4_hashinfo.ht[hash];
+ 	rcu_read_lock();
+ 	sk_nulls_for_each(sk, hnode, hlist) {
+ 		if (!raw_v4_match(net, sk, iph->protocol,
+ 				  iph->saddr, iph->daddr, dif, sdif))
+ 			continue;
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  		delivered = 1;
  		if ((iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &&
  		    ip_mc_sf_allow(sk, iph->daddr, iph->saddr,
@@@ -290,31 -262,27 +305,36 @@@ static void raw_err(struct sock *sk, st
  
  void raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)
  {
 -	struct net *net = dev_net(skb->dev);
 -	struct hlist_nulls_head *hlist;
 -	struct hlist_nulls_node *hnode;
 -	int dif = skb->dev->ifindex;
 -	int sdif = inet_sdif(skb);
 -	const struct iphdr *iph;
 -	struct sock *sk;
  	int hash;
 +	struct sock *raw_sk;
 +	const struct iphdr *iph;
 +	struct net *net;
  
  	hash = protocol & (RAW_HTABLE_SIZE - 1);
 -	hlist = &raw_v4_hashinfo.ht[hash];
  
++<<<<<<< HEAD
 +	read_lock(&raw_v4_hashinfo.lock);
 +	raw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);
 +	if (raw_sk) {
 +		int dif = skb->dev->ifindex;
 +		int sdif = inet_sdif(skb);
 +
++=======
+ 	rcu_read_lock();
+ 	sk_nulls_for_each(sk, hnode, hlist) {
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  		iph = (const struct iphdr *)skb->data;
 -		if (!raw_v4_match(net, sk, iph->protocol,
 -				  iph->saddr, iph->daddr, dif, sdif))
 -			continue;
 -		raw_err(sk, skb, info);
 +		net = dev_net(skb->dev);
 +
 +		while ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,
 +						iph->daddr, iph->saddr,
 +						dif, sdif)) != NULL) {
 +			raw_err(raw_sk, skb, info);
 +			raw_sk = sk_next(raw_sk);
 +			iph = (const struct iphdr *)skb->data;
 +		}
  	}
 -	rcu_read_unlock();
 +	read_unlock(&raw_v4_hashinfo.lock);
  }
  
  static int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)
@@@ -996,21 -943,23 +1016,26 @@@ struct proto raw_prot = 
  };
  
  #ifdef CONFIG_PROC_FS
 -static struct sock *raw_get_first(struct seq_file *seq, int bucket)
 +static struct sock *raw_get_first(struct seq_file *seq)
  {
 -	struct raw_hashinfo *h = pde_data(file_inode(seq->file));
 -	struct raw_iter_state *state = raw_seq_private(seq);
 -	struct hlist_nulls_head *hlist;
 -	struct hlist_nulls_node *hnode;
  	struct sock *sk;
 +	struct raw_hashinfo *h = PDE_DATA(file_inode(seq->file));
 +	struct raw_iter_state *state = raw_seq_private(seq);
  
 -	for (state->bucket = bucket; state->bucket < RAW_HTABLE_SIZE;
 +	for (state->bucket = 0; state->bucket < RAW_HTABLE_SIZE;
  			++state->bucket) {
++<<<<<<< HEAD
 +		sk_for_each(sk, &h->ht[state->bucket])
++=======
+ 		hlist = &h->ht[state->bucket];
+ 		sk_nulls_for_each(sk, hnode, hlist) {
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  			if (sock_net(sk) == seq_file_net(seq))
 -				return sk;
 -		}
 +				goto found;
  	}
 -	return NULL;
 +	sk = NULL;
 +found:
 +	return sk;
  }
  
  static struct sock *raw_get_next(struct seq_file *seq, struct sock *sk)
diff --cc net/ipv4/raw_diag.c
index 5f3757d25183,ac4b6525d3c6..000000000000
--- a/net/ipv4/raw_diag.c
+++ b/net/ipv4/raw_diag.c
@@@ -63,20 -65,18 +63,26 @@@ static struct sock *raw_sock_get(struc
  	if (IS_ERR(hashinfo))
  		return ERR_CAST(hashinfo);
  
 -	rcu_read_lock();
 +	read_lock(&hashinfo->lock);
  	for (slot = 0; slot < RAW_HTABLE_SIZE; slot++) {
++<<<<<<< HEAD
 +		sk_for_each(s, &hashinfo->ht[slot]) {
 +			sk = raw_lookup(net, s, r);
 +			if (sk) {
++=======
+ 		hlist = &hashinfo->ht[slot];
+ 		sk_nulls_for_each(sk, hnode, hlist) {
+ 			if (raw_lookup(net, sk, r)) {
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  				/*
  				 * Grab it and keep until we fill
 -				 * diag message to be reported, so
 +				 * diag meaage to be reported, so
  				 * caller should call sock_put then.
 +				 * We can do that because we're keeping
 +				 * hashinfo->lock here.
  				 */
 -				if (refcount_inc_not_zero(&sk->sk_refcnt))
 -					goto out_unlock;
 +				sock_hold(sk);
 +				goto out_unlock;
  			}
  		}
  	}
@@@ -157,7 -160,8 +163,12 @@@ static void raw_diag_dump(struct sk_buf
  	for (slot = s_slot; slot < RAW_HTABLE_SIZE; s_num = 0, slot++) {
  		num = 0;
  
++<<<<<<< HEAD
 +		sk_for_each(sk, &hashinfo->ht[slot]) {
++=======
+ 		hlist = &hashinfo->ht[slot];
+ 		sk_nulls_for_each(sk, hnode, hlist) {
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  			struct inet_sock *inet = inet_sk(sk);
  
  			if (!net_eq(sock_net(sk), net))
diff --cc net/ipv6/raw.c
index 1d4284c2d260,46b560aacc11..000000000000
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@@ -172,20 -153,14 +172,26 @@@ static bool ipv6_raw_deliver(struct sk_
  	daddr = saddr + 1;
  
  	hash = nexthdr & (RAW_HTABLE_SIZE - 1);
++<<<<<<< HEAD
 +
 +	read_lock(&raw_v6_hashinfo.lock);
 +	sk = sk_head(&raw_v6_hashinfo.ht[hash]);
 +
 +	if (!sk)
 +		goto out;
 +
 +	net = dev_net(skb->dev);
 +	sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr,
 +			     inet6_iif(skb), inet6_sdif(skb));
 +
 +	while (sk) {
++=======
+ 	hlist = &raw_v6_hashinfo.ht[hash];
+ 	rcu_read_lock();
+ 	sk_nulls_for_each(sk, hnode, hlist) {
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  		int filtered;
  
 -		if (!raw_v6_match(net, sk, nexthdr, daddr, saddr,
 -				  inet6_iif(skb), inet6_sdif(skb)))
 -			continue;
  		delivered = true;
  		switch (nexthdr) {
  		case IPPROTO_ICMPV6:
@@@ -366,16 -332,17 +372,22 @@@ static void rawv6_err(struct sock *sk, 
  void raw6_icmp_error(struct sk_buff *skb, int nexthdr,
  		u8 type, u8 code, int inner_offset, __be32 info)
  {
 -	const struct in6_addr *saddr, *daddr;
 -	struct net *net = dev_net(skb->dev);
 -	struct hlist_nulls_head *hlist;
 -	struct hlist_nulls_node *hnode;
  	struct sock *sk;
  	int hash;
 +	const struct in6_addr *saddr, *daddr;
 +	struct net *net;
  
  	hash = nexthdr & (RAW_HTABLE_SIZE - 1);
++<<<<<<< HEAD
 +
 +	read_lock(&raw_v6_hashinfo.lock);
 +	sk = sk_head(&raw_v6_hashinfo.ht[hash]);
 +	if (sk) {
++=======
+ 	hlist = &raw_v6_hashinfo.ht[hash];
+ 	rcu_read_lock();
+ 	sk_nulls_for_each(sk, hnode, hlist) {
++>>>>>>> f289c02bf41b (raw: Use helpers for the hlist_nulls variant.)
  		/* Note: ipv6_hdr(skb) != skb->data */
  		const struct ipv6hdr *ip6h = (const struct ipv6hdr *)skb->data;
  		saddr = &ip6h->saddr;
* Unmerged path net/ipv4/raw.c
* Unmerged path net/ipv4/raw_diag.c
* Unmerged path net/ipv6/raw.c
