scsi: mpi3mr: Scan the devices during resume time

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit f84e8b5bb57eb64391a45f95ebf0e2a179d8c566
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f84e8b5b.failed

Scan the target devices during system resume time and add or remove the
target device with the SML if the corresponding target device is newly
added or removed respectively.

Link: https://lore.kernel.org/r/20220912135742.11764-8-sreekanth.reddy@broadcom.com
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f84e8b5bb57eb64391a45f95ebf0e2a179d8c566)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 8de3e5650c79,5b105044bf66..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -124,6 -130,10 +124,13 @@@ extern atomic64_t event_counter
  
  #define MPI3MR_WATCHDOG_INTERVAL		1000 /* in milli seconds */
  
++<<<<<<< HEAD
++=======
+ #define MPI3MR_DEFAULT_CFG_PAGE_SZ		1024 /* in bytes */
+ 
+ #define MPI3MR_RESET_TOPOLOGY_SETTLE_TIME	10
+ 
++>>>>>>> f84e8b5bb57e (scsi: mpi3mr: Scan the devices during resume time)
  #define MPI3MR_SCMD_TIMEOUT    (60 * HZ)
  #define MPI3MR_EH_SCMD_TIMEOUT (60 * HZ)
  
diff --cc drivers/scsi/mpi3mr/mpi3mr_fw.c
index 697cfbded476,f841a44d3a63..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@@ -3910,8 -4042,11 +3910,14 @@@ retry_init
  		goto out_failed;
  	}
  
++<<<<<<< HEAD
++=======
+ 	mrioc->device_refresh_on = 1;
+ 	mpi3mr_add_event_wait_for_device_refresh(mrioc);
+ 
++>>>>>>> f84e8b5bb57e (scsi: mpi3mr: Scan the devices during resume time)
  	ioc_info(mrioc, "sending port enable\n");
 -	retval = mpi3mr_issue_port_enable(mrioc, 1);
 +	retval = mpi3mr_issue_port_enable(mrioc, 0);
  	if (retval) {
  		ioc_err(mrioc, "failed to issue port enable\n");
  		goto out_failed;
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --git a/drivers/scsi/mpi3mr/mpi3mr_os.c b/drivers/scsi/mpi3mr/mpi3mr_os.c
index 763813eeab8b..a5f0cf3ee1e9 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@ -4592,13 +4592,17 @@ mpi3mr_resume(struct device *dev)
 	}
 
 	mrioc->stop_drv_processing = 0;
+	mpi3mr_invalidate_devhandles(mrioc);
+	mpi3mr_free_enclosure_list(mrioc);
 	mpi3mr_memset_buffers(mrioc);
 	r = mpi3mr_reinit_ioc(mrioc, 1);
 	if (r) {
 		ioc_err(mrioc, "resuming controller failed[%d]\n", r);
 		return r;
 	}
+	ssleep(MPI3MR_RESET_TOPOLOGY_SETTLE_TIME);
 	scsi_unblock_requests(shost);
+	mrioc->device_refresh_on = 0;
 	mpi3mr_start_watchdog(mrioc);
 
 	return 0;
