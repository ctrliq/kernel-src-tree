ice: remove circular header dependencies on ice.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 649c87c6ff52efccf7832a690c0959e012ecce73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/649c87c6.failed

Several headers in the ice driver include ice.h even though they are
themselves included by that header. The most notable of these is
ice_common.h, but several other headers also do this.

Such a recursive inclusion is problematic as it forces headers to be
included in a strict order, otherwise compilation errors can result. The
circular inclusions do not trigger an endless loop due to standard
header inclusion guards, however other errors can occur.

For example, ice_flow.h defines ice_rss_hash_cfg, which is used by
ice_sriov.h as part of the definition of ice_vf_hash_ip_ctx.

ice_flow.h includes ice_acl.h, which includes ice_common.h, and which
finally includes ice.h. Since ice.h itself includes ice_sriov.h, this
creates a circular dependency.

The definition in ice_sriov.h requires things from ice_flow.h, but
ice_flow.h itself will lead to trying to load ice_sriov.h as part of its
process for expanding ice.h. The current code avoids this issue by
having an implicit dependency without the include of ice_flow.h.

If we were to fix that so that ice_sriov.h explicitly depends on
ice_flow.h the following pattern would occur:

  ice_flow.h -> ice_acl.h -> ice_common.h -> ice.h -> ice_sriov.h

At this point, during the expansion of, the header guard for ice_flow.h
is already set, so when ice_sriov.h attempts to load the ice_flow.h
header it is skipped. Then, we go on to begin including the rest of
ice_sriov.h, including structure definitions which depend on
ice_rss_hash_cfg. This produces a compiler warning because
ice_rss_hash_cfg hasn't yet been included. Remember, we're just at the
start of ice_flow.h!

If the order of headers is incorrect (ice_flow.h is not implicitly
loaded first in all files which include ice_sriov.h) then we get the
same failure.

Removing this recursive inclusion requires fixing a few cases where some
headers depended on the header inclusions from ice.h. In addition, a few
other changes are also required.

Most notably, ice_hw_to_dev is implemented as a macro in ice_osdep.h,
which is the likely reason that ice_common.h includes ice.h at all. This
macro implementation requires the full definition of ice_pf in order to
properly compile.

Fix this by moving it to a function declared in ice_main.c, so that we
do not require all files to depend on the layout of the ice_pf
structure.

Note that this change only fixes circular dependencies, but it does not
fully resolve all implicit dependencies where one header may depend on
the inclusion of another. I tried to fix as many of the implicit
dependencies as I noticed, but fixing them all requires a somewhat
tedious analysis of each header and attempting to compile it separately.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 649c87c6ff52efccf7832a690c0959e012ecce73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_common.h
#	drivers/net/ethernet/intel/ice/ice_sriov.h
diff --cc drivers/net/ethernet/intel/ice/ice.h
index dc1d16430838,e9aa1fb43c3a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -51,9 -51,7 +51,13 @@@
  #include <net/gre.h>
  #include <net/udp_tunnel.h>
  #include <net/vxlan.h>
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_DCB)
 +#include <scsi/iscsi_proto.h>
 +#endif /* CONFIG_DCB */
++=======
+ #include <net/gtp.h>
++>>>>>>> 649c87c6ff52 (ice: remove circular header dependencies on ice.h)
  #include "ice_devids.h"
  #include "ice_type.h"
  #include "ice_txrx.h"
diff --cc drivers/net/ethernet/intel/ice/ice_common.h
index 1c57097ddf0b,872ea7d2332d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_common.h
+++ b/drivers/net/ethernet/intel/ice/ice_common.h
@@@ -4,7 -4,8 +4,12 @@@
  #ifndef _ICE_COMMON_H_
  #define _ICE_COMMON_H_
  
++<<<<<<< HEAD
 +#include "ice.h"
++=======
+ #include <linux/bitfield.h>
+ 
++>>>>>>> 649c87c6ff52 (ice: remove circular header dependencies on ice.h)
  #include "ice_type.h"
  #include "ice_nvm.h"
  #include "ice_flex_pipe.h"
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.h
index 68686a3fd7e8,a5ef3c46953a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.h
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.h
@@@ -3,40 -3,414 +3,45 @@@
  
  #ifndef _ICE_SRIOV_H_
  #define _ICE_SRIOV_H_
++<<<<<<< HEAD
++=======
+ #include "ice_virtchnl_fdir.h"
+ #include "ice_vsi_vlan_ops.h"
++>>>>>>> 649c87c6ff52 (ice: remove circular header dependencies on ice.h)
  
 -/* Restrict number of MAC Addr and VLAN that non-trusted VF can programmed */
 -#define ICE_MAX_VLAN_PER_VF		8
 -/* MAC filters: 1 is reserved for the VF's default/perm_addr/LAA MAC, 1 for
 - * broadcast, and 16 for additional unicast/multicast filters
 - */
 -#define ICE_MAX_MACADDR_PER_VF		18
 -
 -/* Malicious Driver Detection */
 -#define ICE_MDD_EVENTS_THRESHOLD		30
 -
 -/* Static VF transaction/status register def */
 -#define VF_DEVICE_STATUS		0xAA
 -#define VF_TRANS_PENDING_M		0x20
 -
 -/* wait defines for polling PF_PCI_CIAD register status */
 -#define ICE_PCI_CIAD_WAIT_COUNT		100
 -#define ICE_PCI_CIAD_WAIT_DELAY_US	1
 -
 -/* VF resource constraints */
 -#define ICE_MAX_VF_COUNT		256
 -#define ICE_MIN_QS_PER_VF		1
 -#define ICE_NONQ_VECS_VF		1
 -#define ICE_MAX_SCATTER_QS_PER_VF	16
 -#define ICE_MAX_RSS_QS_PER_VF		16
 -#define ICE_NUM_VF_MSIX_MED		17
 -#define ICE_NUM_VF_MSIX_SMALL		5
 -#define ICE_NUM_VF_MSIX_MULTIQ_MIN	3
 -#define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
 -#define ICE_MAX_VF_RESET_TRIES		40
 -#define ICE_MAX_VF_RESET_SLEEP_MS	20
 -
 -/* VF Hash Table access functions
 - *
 - * These functions provide abstraction for interacting with the VF hash table.
 - * In general, direct access to the hash table should be avoided outside of
 - * these functions where possible.
 - *
 - * The VF entries in the hash table are protected by reference counting to
 - * track lifetime of accesses from the table. The ice_get_vf_by_id() function
 - * obtains a reference to the VF structure which must be dropped by using
 - * ice_put_vf().
 - */
 +#include "ice_type.h"
 +#include "ice_controlq.h"
  
 -/**
 - * ice_for_each_vf - Iterate over each VF entry
 - * @pf: pointer to the PF private structure
 - * @bkt: bucket index used for iteration
 - * @vf: pointer to the VF entry currently being processed in the loop.
 - *
 - * The bkt variable is an unsigned integer iterator used to traverse the VF
 - * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
 - * Use vf->vf_id to get the id number if needed.
 - *
 - * The caller is expected to be under the table_lock mutex for the entire
 - * loop. Use this iterator if your loop is long or if it might sleep.
 +/* Defining the mailbox message threshold as 63 asynchronous
 + * pending messages. Normal VF functionality does not require
 + * sending more than 63 asynchronous pending message.
   */
 -#define ice_for_each_vf(pf, bkt, vf) \
 -	hash_for_each((pf)->vfs.table, (bkt), (vf), entry)
 -
 -/**
 - * ice_for_each_vf_rcu - Iterate over each VF entry protected by RCU
 - * @pf: pointer to the PF private structure
 - * @bkt: bucket index used for iteration
 - * @vf: pointer to the VF entry currently being processed in the loop.
 - *
 - * The bkt variable is an unsigned integer iterator used to traverse the VF
 - * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
 - * Use vf->vf_id to get the id number if needed.
 - *
 - * The caller is expected to be under rcu_read_lock() for the entire loop.
 - * Only use this iterator if your loop is short and you can guarantee it does
 - * not sleep.
 - */
 -#define ice_for_each_vf_rcu(pf, bkt, vf) \
 -	hash_for_each_rcu((pf)->vfs.table, (bkt), (vf), entry)
 -
 -/* Specific VF states */
 -enum ice_vf_states {
 -	ICE_VF_STATE_INIT = 0,		/* PF is initializing VF */
 -	ICE_VF_STATE_ACTIVE,		/* VF resources are allocated for use */
 -	ICE_VF_STATE_QS_ENA,		/* VF queue(s) enabled */
 -	ICE_VF_STATE_DIS,
 -	ICE_VF_STATE_MC_PROMISC,
 -	ICE_VF_STATE_UC_PROMISC,
 -	ICE_VF_STATES_NBITS
 -};
 -
 -/* VF capabilities */
 -enum ice_virtchnl_cap {
 -	ICE_VIRTCHNL_VF_CAP_L2 = 0,
 -	ICE_VIRTCHNL_VF_CAP_PRIVILEGE,
 -};
 -
 -struct ice_time_mac {
 -	unsigned long time_modified;
 -	u8 addr[ETH_ALEN];
 -};
 -
 -/* VF MDD events print structure */
 -struct ice_mdd_vf_events {
 -	u16 count;			/* total count of Rx|Tx events */
 -	/* count number of the last printed event */
 -	u16 last_printed;
 -};
 -
 -struct ice_vf;
 -
 -struct ice_vc_vf_ops {
 -	int (*get_ver_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*get_vf_res_msg)(struct ice_vf *vf, u8 *msg);
 -	void (*reset_vf)(struct ice_vf *vf);
 -	int (*add_mac_addr_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*del_mac_addr_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*cfg_qs_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*ena_qs_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*dis_qs_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*request_qs_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*cfg_irq_map_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*config_rss_key)(struct ice_vf *vf, u8 *msg);
 -	int (*config_rss_lut)(struct ice_vf *vf, u8 *msg);
 -	int (*get_stats_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*cfg_promiscuous_mode_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*add_vlan_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*remove_vlan_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*ena_vlan_stripping)(struct ice_vf *vf);
 -	int (*dis_vlan_stripping)(struct ice_vf *vf);
 -	int (*handle_rss_cfg_msg)(struct ice_vf *vf, u8 *msg, bool add);
 -	int (*add_fdir_fltr_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*del_fdir_fltr_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*get_offload_vlan_v2_caps)(struct ice_vf *vf);
 -	int (*add_vlan_v2_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*remove_vlan_v2_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*ena_vlan_stripping_v2_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*dis_vlan_stripping_v2_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*ena_vlan_insertion_v2_msg)(struct ice_vf *vf, u8 *msg);
 -	int (*dis_vlan_insertion_v2_msg)(struct ice_vf *vf, u8 *msg);
 -};
 -
 -/* Virtchnl/SR-IOV config info */
 -struct ice_vfs {
 -	DECLARE_HASHTABLE(table, 8);	/* table of VF entries */
 -	struct mutex table_lock;	/* Lock for protecting the hash table */
 -	u16 num_supported;		/* max supported VFs on this PF */
 -	u16 num_qps_per;		/* number of queue pairs per VF */
 -	u16 num_msix_per;		/* number of MSI-X vectors per VF */
 -	unsigned long last_printed_mdd_jiffies;	/* MDD message rate limit */
 -	DECLARE_BITMAP(malvfs, ICE_MAX_VF_COUNT); /* malicious VF indicator */
 -};
 -
 -/* VF information structure */
 -struct ice_vf {
 -	struct hlist_node entry;
 -	struct rcu_head rcu;
 -	struct kref refcnt;
 -	struct ice_pf *pf;
 -
 -	/* Used during virtchnl message handling and NDO ops against the VF
 -	 * that will trigger a VFR
 -	 */
 -	struct mutex cfg_lock;
 -
 -	u16 vf_id;			/* VF ID in the PF space */
 -	u16 lan_vsi_idx;		/* index into PF struct */
 -	u16 ctrl_vsi_idx;
 -	struct ice_vf_fdir fdir;
 -	/* first vector index of this VF in the PF space */
 -	int first_vector_idx;
 -	struct ice_sw *vf_sw_id;	/* switch ID the VF VSIs connect to */
 -	struct virtchnl_version_info vf_ver;
 -	u32 driver_caps;		/* reported by VF driver */
 -	struct virtchnl_ether_addr dev_lan_addr;
 -	struct virtchnl_ether_addr hw_lan_addr;
 -	struct ice_time_mac legacy_last_added_umac;
 -	DECLARE_BITMAP(txq_ena, ICE_MAX_RSS_QS_PER_VF);
 -	DECLARE_BITMAP(rxq_ena, ICE_MAX_RSS_QS_PER_VF);
 -	struct ice_vlan port_vlan_info;	/* Port VLAN ID, QoS, and TPID */
 -	struct virtchnl_vlan_caps vlan_v2_caps;
 -	u8 pf_set_mac:1;		/* VF MAC address set by VMM admin */
 -	u8 trusted:1;
 -	u8 spoofchk:1;
 -	u8 link_forced:1;
 -	u8 link_up:1;			/* only valid if VF link is forced */
 -	/* VSI indices - actual VSI pointers are maintained in the PF structure
 -	 * When assigned, these will be non-zero, because VSI 0 is always
 -	 * the main LAN VSI for the PF.
 -	 */
 -	u16 lan_vsi_num;		/* ID as used by firmware */
 -	unsigned int min_tx_rate;	/* Minimum Tx bandwidth limit in Mbps */
 -	unsigned int max_tx_rate;	/* Maximum Tx bandwidth limit in Mbps */
 -	DECLARE_BITMAP(vf_states, ICE_VF_STATES_NBITS);	/* VF runtime states */
 -
 -	unsigned long vf_caps;		/* VF's adv. capabilities */
 -	u8 num_req_qs;			/* num of queue pairs requested by VF */
 -	u16 num_mac;
 -	u16 num_vf_qs;			/* num of queue configured per VF */
 -	struct ice_mdd_vf_events mdd_rx_events;
 -	struct ice_mdd_vf_events mdd_tx_events;
 -	DECLARE_BITMAP(opcodes_allowlist, VIRTCHNL_OP_MAX);
 -
 -	struct ice_repr *repr;
 -
 -	struct ice_vc_vf_ops vc_ops;
 -
 -	/* devlink port data */
 -	struct devlink_port devlink_port;
 -};
 +#define ICE_ASYNC_VF_MSG_THRESHOLD	63
  
  #ifdef CONFIG_PCI_IOV
 -struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id);
 -void ice_put_vf(struct ice_vf *vf);
 -bool ice_has_vfs(struct ice_pf *pf);
 -u16 ice_get_num_vfs(struct ice_pf *pf);
 -struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf);
 -void ice_process_vflr_event(struct ice_pf *pf);
 -int ice_sriov_configure(struct pci_dev *pdev, int num_vfs);
 -int ice_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac);
 -int
 -ice_get_vf_cfg(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi);
 -
 -void ice_free_vfs(struct ice_pf *pf);
 -void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event);
 -void ice_vc_notify_link_state(struct ice_pf *pf);
 -void ice_vc_notify_reset(struct ice_pf *pf);
 -void ice_vc_notify_vf_link_state(struct ice_vf *vf);
 -void ice_vc_change_ops_to_repr(struct ice_vc_vf_ops *ops);
 -void ice_vc_set_dflt_vf_ops(struct ice_vc_vf_ops *ops);
 -bool ice_reset_all_vfs(struct ice_pf *pf, bool is_vflr);
 -bool ice_reset_vf(struct ice_vf *vf, bool is_vflr);
 -void ice_restore_all_vfs_msi_state(struct pci_dev *pdev);
 -bool
 -ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
 -		    u16 num_msg_proc, u16 num_msg_pending);
 -
  int
 -ice_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos,
 -		     __be16 vlan_proto);
 +ice_aq_send_msg_to_vf(struct ice_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval,
 +		      u8 *msg, u16 msglen, struct ice_sq_cd *cd);
  
 +u32 ice_conv_link_speed_to_virtchnl(bool adv_link_support, u16 link_speed);
  int
 -ice_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate,
 -	      int max_tx_rate);
 -
 -int ice_set_vf_trust(struct net_device *netdev, int vf_id, bool trusted);
 -
 -int ice_set_vf_link_state(struct net_device *netdev, int vf_id, int link_state);
 -
 -int ice_check_vf_ready_for_cfg(struct ice_vf *vf);
 -
 -bool ice_is_vf_disabled(struct ice_vf *vf);
 -
 -int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena);
 -
 -int ice_calc_vf_reg_idx(struct ice_vf *vf, struct ice_q_vector *q_vector);
 -
 -void ice_set_vf_state_qs_dis(struct ice_vf *vf);
 +ice_mbx_vf_state_handler(struct ice_hw *hw, struct ice_mbx_data *mbx_data,
 +			 u16 vf_id, bool *is_mal_vf);
  int
 -ice_get_vf_stats(struct net_device *netdev, int vf_id,
 -		 struct ifla_vf_stats *vf_stats);
 -bool ice_is_any_vf_in_promisc(struct ice_pf *pf);
 -void
 -ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event);
 -void ice_print_vfs_mdd_events(struct ice_pf *pf);
 -void ice_print_vf_rx_mdd_event(struct ice_vf *vf);
 -bool
 -ice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto);
 -struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf);
 +ice_mbx_clear_malvf(struct ice_mbx_snapshot *snap, unsigned long *all_malvfs,
 +		    u16 bitmap_len, u16 vf_id);
 +int ice_mbx_init_snapshot(struct ice_hw *hw, u16 vf_count);
 +void ice_mbx_deinit_snapshot(struct ice_hw *hw);
  int
 -ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
 -		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen);
 -bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id);
 -bool ice_vf_is_port_vlan_ena(struct ice_vf *vf);
 +ice_mbx_report_malvf(struct ice_hw *hw, unsigned long *all_malvfs,
 +		     u16 bitmap_len, u16 vf_id, bool *report_malvf);
  #else /* CONFIG_PCI_IOV */
 -static inline struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
 -{
 -	return NULL;
 -}
 -
 -static inline void ice_put_vf(struct ice_vf *vf)
 -{
 -}
 -
 -static inline bool ice_has_vfs(struct ice_pf *pf)
 -{
 -	return false;
 -}
 -
 -static inline u16 ice_get_num_vfs(struct ice_pf *pf)
 -{
 -	return 0;
 -}
 -
 -static inline void ice_process_vflr_event(struct ice_pf *pf) { }
 -static inline void ice_free_vfs(struct ice_pf *pf) { }
 -static inline
 -void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event) { }
 -static inline void ice_vc_notify_link_state(struct ice_pf *pf) { }
 -static inline void ice_vc_notify_reset(struct ice_pf *pf) { }
 -static inline void ice_vc_notify_vf_link_state(struct ice_vf *vf) { }
 -static inline void ice_vc_change_ops_to_repr(struct ice_vc_vf_ops *ops) { }
 -static inline void ice_vc_set_dflt_vf_ops(struct ice_vc_vf_ops *ops) { }
 -static inline void ice_set_vf_state_qs_dis(struct ice_vf *vf) { }
 -static inline
 -void ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event) { }
 -static inline void ice_print_vfs_mdd_events(struct ice_pf *pf) { }
 -static inline void ice_print_vf_rx_mdd_event(struct ice_vf *vf) { }
 -static inline void ice_restore_all_vfs_msi_state(struct pci_dev *pdev) { }
 -
 -static inline int ice_check_vf_ready_for_cfg(struct ice_vf *vf)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline bool ice_is_vf_disabled(struct ice_vf *vf)
 -{
 -	return true;
 -}
 -
 -static inline struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)
 -{
 -	return NULL;
 -}
 -
 -static inline bool
 -ice_is_malicious_vf(struct ice_pf __always_unused *pf,
 -		    struct ice_rq_event_info __always_unused *event,
 -		    u16 __always_unused num_msg_proc,
 -		    u16 __always_unused num_msg_pending)
 -{
 -	return false;
 -}
 -
 -static inline bool
 -ice_reset_all_vfs(struct ice_pf __always_unused *pf,
 -		  bool __always_unused is_vflr)
 -{
 -	return true;
 -}
 -
 -static inline bool
 -ice_reset_vf(struct ice_vf __always_unused *vf, bool __always_unused is_vflr)
 -{
 -	return true;
 -}
 -
 -static inline int
 -ice_sriov_configure(struct pci_dev __always_unused *pdev,
 -		    int __always_unused num_vfs)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_set_vf_mac(struct net_device __always_unused *netdev,
 -	       int __always_unused vf_id, u8 __always_unused *mac)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_get_vf_cfg(struct net_device __always_unused *netdev,
 -	       int __always_unused vf_id,
 -	       struct ifla_vf_info __always_unused *ivi)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_set_vf_trust(struct net_device __always_unused *netdev,
 -		 int __always_unused vf_id, bool __always_unused trusted)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_set_vf_port_vlan(struct net_device __always_unused *netdev,
 -		     int __always_unused vf_id, u16 __always_unused vid,
 -		     u8 __always_unused qos, __be16 __always_unused v_proto)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_set_vf_spoofchk(struct net_device __always_unused *netdev,
 -		    int __always_unused vf_id, bool __always_unused ena)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_set_vf_link_state(struct net_device __always_unused *netdev,
 -		      int __always_unused vf_id, int __always_unused link_state)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
  static inline int
 -ice_set_vf_bw(struct net_device __always_unused *netdev,
 -	      int __always_unused vf_id, int __always_unused min_tx_rate,
 -	      int __always_unused max_tx_rate)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int
 -ice_calc_vf_reg_idx(struct ice_vf __always_unused *vf,
 -		    struct ice_q_vector __always_unused *q_vector)
 +ice_aq_send_msg_to_vf(struct ice_hw __always_unused *hw,
 +		      u16 __always_unused vfid, u32 __always_unused v_opcode,
 +		      u32 __always_unused v_retval, u8 __always_unused *msg,
 +		      u16 __always_unused msglen,
 +		      struct ice_sq_cd __always_unused *cd)
  {
  	return 0;
  }
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
diff --git a/drivers/net/ethernet/intel/ice/ice_arfs.h b/drivers/net/ethernet/intel/ice/ice_arfs.h
index 80ed76f0cace..9669ad9bf7b5 100644
--- a/drivers/net/ethernet/intel/ice/ice_arfs.h
+++ b/drivers/net/ethernet/intel/ice/ice_arfs.h
@@ -3,6 +3,9 @@
 
 #ifndef _ICE_ARFS_H_
 #define _ICE_ARFS_H_
+
+#include "ice_fdir.h"
+
 enum ice_arfs_fltr_state {
 	ICE_ARFS_INACTIVE,
 	ICE_ARFS_ACTIVE,
* Unmerged path drivers/net/ethernet/intel/ice/ice_common.h
diff --git a/drivers/net/ethernet/intel/ice/ice_dcb.h b/drivers/net/ethernet/intel/ice/ice_dcb.h
index d73348f279f7..6abf28a14291 100644
--- a/drivers/net/ethernet/intel/ice/ice_dcb.h
+++ b/drivers/net/ethernet/intel/ice/ice_dcb.h
@@ -5,6 +5,7 @@
 #define _ICE_DCB_H_
 
 #include "ice_type.h"
+#include <scsi/iscsi_proto.h>
 
 #define ICE_DCBX_STATUS_NOT_STARTED	0
 #define ICE_DCBX_STATUS_IN_PROGRESS	1
diff --git a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
index 13c3bfc38e8f..3718a6cf2f90 100644
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
@@ -4,6 +4,7 @@
 #include "ice_common.h"
 #include "ice_flex_pipe.h"
 #include "ice_flow.h"
+#include "ice.h"
 
 /* To support tunneling entries by PF, the package will append the PF number to
  * the label; for example TNL_VXLAN_PF0, TNL_VXLAN_PF1, TNL_VXLAN_PF2, etc.
diff --git a/drivers/net/ethernet/intel/ice/ice_flow.c b/drivers/net/ethernet/intel/ice/ice_flow.c
index beed4838dcbe..ef103e47a8dc 100644
--- a/drivers/net/ethernet/intel/ice/ice_flow.c
+++ b/drivers/net/ethernet/intel/ice/ice_flow.c
@@ -3,6 +3,7 @@
 
 #include "ice_common.h"
 #include "ice_flow.h"
+#include <net/gre.h>
 
 /* Describe properties of a protocol header field */
 struct ice_flow_field_info {
diff --git a/drivers/net/ethernet/intel/ice/ice_flow.h b/drivers/net/ethernet/intel/ice/ice_flow.h
index 84b6e4464a21..b465d27d9b80 100644
--- a/drivers/net/ethernet/intel/ice/ice_flow.h
+++ b/drivers/net/ethernet/intel/ice/ice_flow.h
@@ -4,6 +4,8 @@
 #ifndef _ICE_FLOW_H_
 #define _ICE_FLOW_H_
 
+#include "ice_flex_type.h"
+
 #define ICE_FLOW_ENTRY_HANDLE_INVAL	0
 #define ICE_FLOW_FLD_OFF_INVAL		0xffff
 
diff --git a/drivers/net/ethernet/intel/ice/ice_idc_int.h b/drivers/net/ethernet/intel/ice/ice_idc_int.h
index b7796b8aecbd..4b0c86757df9 100644
--- a/drivers/net/ethernet/intel/ice/ice_idc_int.h
+++ b/drivers/net/ethernet/intel/ice/ice_idc_int.h
@@ -5,7 +5,6 @@
 #define _ICE_IDC_INT_H_
 
 #include <linux/net/intel/iidc.h>
-#include "ice.h"
 
 struct ice_pf;
 
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index e5db1d9c2627..0e67d4b4bf74 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -55,6 +55,21 @@ static DEFINE_IDA(ice_aux_ida);
 DEFINE_STATIC_KEY_FALSE(ice_xdp_locking_key);
 EXPORT_SYMBOL(ice_xdp_locking_key);
 
+/**
+ * ice_hw_to_dev - Get device pointer from the hardware structure
+ * @hw: pointer to the device HW structure
+ *
+ * Used to access the device pointer from compilation units which can't easily
+ * include the definition of struct ice_pf without leading to circular header
+ * dependencies.
+ */
+struct device *ice_hw_to_dev(struct ice_hw *hw)
+{
+	struct ice_pf *pf = container_of(hw, struct ice_pf, hw);
+
+	return &pf->pdev->dev;
+}
+
 static struct workqueue_struct *ice_wq;
 static const struct net_device_ops ice_netdev_safe_mode_ops;
 static const struct net_device_ops ice_netdev_ops;
diff --git a/drivers/net/ethernet/intel/ice/ice_osdep.h b/drivers/net/ethernet/intel/ice/ice_osdep.h
index f57c414bc0a9..7e86b0be0bd3 100644
--- a/drivers/net/ethernet/intel/ice/ice_osdep.h
+++ b/drivers/net/ethernet/intel/ice/ice_osdep.h
@@ -5,7 +5,14 @@
 #define _ICE_OSDEP_H_
 
 #include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
+#include <linux/pci_ids.h>
 #ifndef CONFIG_64BIT
 #include <linux/io-64-nonatomic-lo-hi.h>
 #endif
@@ -24,8 +31,8 @@ struct ice_dma_mem {
 	size_t size;
 };
 
-#define ice_hw_to_dev(ptr)	\
-	(&(container_of((ptr), struct ice_pf, hw))->pdev->dev)
+struct ice_hw;
+struct device *ice_hw_to_dev(struct ice_hw *hw);
 
 #ifdef CONFIG_DYNAMIC_DEBUG
 #define ice_debug(hw, type, fmt, args...) \
diff --git a/drivers/net/ethernet/intel/ice/ice_repr.h b/drivers/net/ethernet/intel/ice/ice_repr.h
index 0c77ff050d15..378a45bfa256 100644
--- a/drivers/net/ethernet/intel/ice/ice_repr.h
+++ b/drivers/net/ethernet/intel/ice/ice_repr.h
@@ -5,7 +5,6 @@
 #define _ICE_REPR_H_
 
 #include <net/dst_metadata.h>
-#include "ice.h"
 
 struct ice_repr {
 	struct ice_vsi *src_vsi;
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.h
diff --git a/drivers/net/ethernet/intel/ice/ice_type.h b/drivers/net/ethernet/intel/ice/ice_type.h
index 546145dd1f02..0ead74372bac 100644
--- a/drivers/net/ethernet/intel/ice/ice_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_type.h
@@ -9,6 +9,7 @@
 #define ICE_CHNL_MAX_TC		16
 
 #include "ice_hw_autogen.h"
+#include "ice_devids.h"
 #include "ice_osdep.h"
 #include "ice_controlq.h"
 #include "ice_lan_tx_rx.h"
diff --git a/drivers/net/ethernet/intel/ice/ice_xsk.h b/drivers/net/ethernet/intel/ice/ice_xsk.h
index 4c7bd8e9dfc4..d2cb7127d2a1 100644
--- a/drivers/net/ethernet/intel/ice/ice_xsk.h
+++ b/drivers/net/ethernet/intel/ice/ice_xsk.h
@@ -4,7 +4,6 @@
 #ifndef _ICE_XSK_H_
 #define _ICE_XSK_H_
 #include "ice_txrx.h"
-#include "ice.h"
 
 struct ice_vsi;
 
