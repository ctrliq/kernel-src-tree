ASoC: SOF: topology: Make DAI widget parsing IPC agnostic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 909dadf21aae8f7e604973218907ed39e10499e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/909dadf2.failed

Define the list of tokens pertaining to the dai_in/out widgets, parse and
save them as part of the swidget tuples array. Once topology parsing is
complete, these tokens will be applied to create the IPC structure for the
DAI component based on the topology widget_setup op in ipc3_tplg_ops.

DAI link parsing is also made IPC agnostic by parsing the list of tokens
associated with all DAI types. The config will be applied to the
respective DAI widgets during topology complete.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220314200520.1233427-17-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 909dadf21aae8f7e604973218907ed39e10499e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc3-topology.c
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/topology.c
index a127d3d2eab7,c9c72e94f696..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -603,117 -554,11 +603,118 @@@ int get_token_dai_type(void *elem, voi
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int get_token_process_type(void *elem, void *object, u32 offset)
 +{
 +	u32 *val = (u32 *)((u8 *)object + offset);
 +
 +	*val = find_process((const char *)elem);
 +	return 0;
 +}
 +
 +/* Buffers */
 +static const struct sof_topology_token buffer_tokens[] = {
 +	{SOF_TKN_BUF_SIZE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_buffer, size)},
 +	{SOF_TKN_BUF_CAPS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_buffer, caps)},
 +};
 +
 +/* DAI */
 +static const struct sof_topology_token dai_tokens[] = {
 +	{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,
 +		offsetof(struct sof_ipc_comp_dai, type)},
 +	{SOF_TKN_DAI_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_dai, dai_index)},
 +	{SOF_TKN_DAI_DIRECTION, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_dai, direction)},
 +};
 +
 +/* BE DAI link */
 +static const struct sof_topology_token dai_link_tokens[] = {
 +	{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,
 +		offsetof(struct sof_ipc_dai_config, type)},
 +	{SOF_TKN_DAI_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_dai_config, dai_index)},
 +};
 +
 +/* scheduling */
 +static const struct sof_topology_token sched_tokens[] = {
 +	{SOF_TKN_SCHED_PERIOD, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_pipe_new, period)},
 +	{SOF_TKN_SCHED_PRIORITY, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_pipe_new, priority)},
 +	{SOF_TKN_SCHED_MIPS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_pipe_new, period_mips)},
 +	{SOF_TKN_SCHED_CORE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_pipe_new, core)},
 +	{SOF_TKN_SCHED_FRAMES, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_pipe_new, frames_per_sched)},
 +	{SOF_TKN_SCHED_TIME_DOMAIN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_pipe_new, time_domain)},
 +};
 +
 +static const struct sof_topology_token pipeline_tokens[] = {
 +	{SOF_TKN_SCHED_DYNAMIC_PIPELINE, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,
 +		offsetof(struct snd_sof_widget, dynamic_pipeline_widget)},
 +
 +};
 +
 +/* volume */
 +static const struct sof_topology_token volume_tokens[] = {
 +	{SOF_TKN_VOLUME_RAMP_STEP_TYPE, SND_SOC_TPLG_TUPLE_TYPE_WORD,
 +		get_token_u32, offsetof(struct sof_ipc_comp_volume, ramp)},
 +	{SOF_TKN_VOLUME_RAMP_STEP_MS,
 +		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_volume, initial_ramp)},
 +};
 +
 +/* SRC */
 +static const struct sof_topology_token src_tokens[] = {
 +	{SOF_TKN_SRC_RATE_IN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_src, source_rate)},
 +	{SOF_TKN_SRC_RATE_OUT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_src, sink_rate)},
 +};
 +
 +/* ASRC */
 +static const struct sof_topology_token asrc_tokens[] = {
 +	{SOF_TKN_ASRC_RATE_IN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_asrc, source_rate)},
 +	{SOF_TKN_ASRC_RATE_OUT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_asrc, sink_rate)},
 +	{SOF_TKN_ASRC_ASYNCHRONOUS_MODE, SND_SOC_TPLG_TUPLE_TYPE_WORD,
 +		get_token_u32,
 +		offsetof(struct sof_ipc_comp_asrc, asynchronous_mode)},
 +	{SOF_TKN_ASRC_OPERATION_MODE, SND_SOC_TPLG_TUPLE_TYPE_WORD,
 +		get_token_u32,
 +		offsetof(struct sof_ipc_comp_asrc, operation_mode)},
 +};
 +
 +/* Tone */
 +static const struct sof_topology_token tone_tokens[] = {
 +};
 +
 +/* EFFECT */
 +static const struct sof_topology_token process_tokens[] = {
 +	{SOF_TKN_PROCESS_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING,
 +		get_token_process_type,
 +		offsetof(struct sof_ipc_comp_process, type)},
 +};
 +
 +/* PCM */
 +static const struct sof_topology_token pcm_tokens[] = {
 +	{SOF_TKN_PCM_DMAC_CONFIG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
 +		offsetof(struct sof_ipc_comp_host, dmac_config)},
 +};
 +
++=======
++>>>>>>> 909dadf21aae (ASoC: SOF: topology: Make DAI widget parsing IPC agnostic)
  /* PCM */
  static const struct sof_topology_token stream_tokens[] = {
- 	{SOF_TKN_STREAM_PLAYBACK_COMPATIBLE_D0I3,
- 		SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,
+ 	{SOF_TKN_STREAM_PLAYBACK_COMPATIBLE_D0I3, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,
  		offsetof(struct snd_sof_pcm, stream[0].d0i3_compatible)},
- 	{SOF_TKN_STREAM_CAPTURE_COMPATIBLE_D0I3,
- 		SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,
+ 	{SOF_TKN_STREAM_CAPTURE_COMPATIBLE_D0I3, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,
  		offsetof(struct snd_sof_pcm, stream[1].d0i3_compatible)},
  };
  
@@@ -1528,152 -1318,6 +1357,155 @@@ static int sof_connect_dai_widget(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * sof_comp_alloc - allocate and initialize buffer for a new component
 + * @swidget: pointer to struct snd_sof_widget containing extended data
 + * @ipc_size: IPC payload size that will be updated depending on valid
 + *  extended data.
 + * @index: ID of the pipeline the component belongs to
 + *
 + * Return: The pointer to the new allocated component, NULL if failed.
 + */
 +static struct sof_ipc_comp *sof_comp_alloc(struct snd_sof_widget *swidget, size_t *ipc_size,
 +					   int index)
 +{
 +	struct sof_ipc_comp *comp;
 +	size_t total_size = *ipc_size;
 +	size_t ext_size = sizeof(swidget->uuid);
 +
 +	/* only non-zero UUID is valid */
 +	if (!guid_is_null(&swidget->uuid))
 +		total_size += ext_size;
 +
 +	comp = kzalloc(total_size, GFP_KERNEL);
 +	if (!comp)
 +		return NULL;
 +
 +	/* configure comp new IPC message */
 +	comp->hdr.size = total_size;
 +	comp->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
 +	comp->id = swidget->comp_id;
 +	comp->pipeline_id = index;
 +	comp->core = swidget->core;
 +
 +	/* handle the extended data if needed */
 +	if (total_size > *ipc_size) {
 +		/* append extended data to the end of the component */
 +		memcpy((u8 *)comp + *ipc_size, &swidget->uuid, ext_size);
 +		comp->ext_data_length = ext_size;
 +	}
 +
 +	/* update ipc_size and return */
 +	*ipc_size = total_size;
 +	return comp;
 +}
 +
 +static int sof_widget_load_dai(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw,
 +			       struct snd_sof_dai *dai)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_dai_private_data *dai_data;
 +	struct sof_ipc_comp_dai *comp_dai;
 +	size_t ipc_size = sizeof(*comp_dai);
 +	int ret;
 +
 +	dai_data = kzalloc(sizeof(*dai_data), GFP_KERNEL);
 +	if (!dai_data)
 +		return -ENOMEM;
 +
 +	comp_dai = (struct sof_ipc_comp_dai *)
 +		   sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!comp_dai) {
 +		ret = -ENOMEM;
 +		goto free;
 +	}
 +
 +	/* configure dai IPC message */
 +	comp_dai->comp.type = SOF_COMP_DAI;
 +	comp_dai->config.hdr.size = sizeof(comp_dai->config);
 +
 +	ret = sof_parse_tokens(scomp, comp_dai, dai_tokens,
 +			       ARRAY_SIZE(dai_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dai tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto free;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &comp_dai->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dai.cfg tokens failed %d\n",
 +			private->size);
 +		goto free;
 +	}
 +
 +	dev_dbg(scomp->dev, "dai %s: type %d index %d\n",
 +		swidget->widget->name, comp_dai->type, comp_dai->dai_index);
 +	sof_dbg_comp_config(scomp, &comp_dai->config);
 +
 +	if (dai) {
 +		dai->scomp = scomp;
 +		dai_data->comp_dai = comp_dai;
 +		dai->private = dai_data;
 +	}
 +
 +	return 0;
 +
 +free:
 +	kfree(dai_data);
 +	return ret;
 +}
 +
 +/*
 + * Buffer topology
 + */
 +
 +static int sof_widget_load_buffer(struct snd_soc_component *scomp, int index,
 +				  struct snd_sof_widget *swidget,
 +				  struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_buffer *buffer;
 +	int ret;
 +
 +	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
 +	if (!buffer)
 +		return -ENOMEM;
 +
 +	/* configure dai IPC message */
 +	buffer->comp.hdr.size = sizeof(*buffer);
 +	buffer->comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_BUFFER_NEW;
 +	buffer->comp.id = swidget->comp_id;
 +	buffer->comp.type = SOF_COMP_BUFFER;
 +	buffer->comp.pipeline_id = index;
 +	buffer->comp.core = swidget->core;
 +
 +	ret = sof_parse_tokens(scomp, buffer, buffer_tokens,
 +			       ARRAY_SIZE(buffer_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse buffer tokens failed %d\n",
 +			private->size);
 +		kfree(buffer);
 +		return ret;
 +	}
 +
 +	dev_dbg(scomp->dev, "buffer %s: size %d caps 0x%x\n",
 +		swidget->widget->name, buffer->size, buffer->caps);
 +
 +	swidget->private = buffer;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 909dadf21aae (ASoC: SOF: topology: Make DAI widget parsing IPC agnostic)
  /* bind PCM ID to host component ID */
  static int spcm_bind(struct snd_soc_component *scomp, struct snd_sof_pcm *spcm,
  		     int dir)
@@@ -1746,632 -1406,65 +1578,652 @@@ err
  	return ret;
  }
  
 -static int sof_widget_bind_event(struct snd_soc_component *scomp,
 -				 struct snd_sof_widget *swidget,
 -				 u16 event_type)
 +/*
 + * Pipeline Topology
 + */
 +static int sof_widget_load_pipeline(struct snd_soc_component *scomp, int index,
 +				    struct snd_sof_widget *swidget,
 +				    struct snd_soc_tplg_dapm_widget *tw)
  {
 -	struct sof_ipc_comp *ipc_comp;
 -
 -	/* validate widget event type */
 -	switch (event_type) {
 -	case SOF_KEYWORD_DETECT_DAPM_EVENT:
 -		/* only KEYWORD_DETECT comps should handle this */
 -		if (swidget->id != snd_soc_dapm_effect)
 -			break;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_pipe_new *pipeline;
 +	struct snd_sof_widget *comp_swidget;
 +	int ret;
  
 -		ipc_comp = swidget->private;
 -		if (ipc_comp && ipc_comp->type != SOF_COMP_KEYWORD_DETECT)
 -			break;
 +	pipeline = kzalloc(sizeof(*pipeline), GFP_KERNEL);
 +	if (!pipeline)
 +		return -ENOMEM;
  
 -		/* bind event to keyword detect comp */
 -		return snd_soc_tplg_widget_bind_event(swidget->widget,
 -						      sof_kwd_events,
 -						      ARRAY_SIZE(sof_kwd_events),
 -						      event_type);
 -	default:
 -		break;
 +	/* configure dai IPC message */
 +	pipeline->hdr.size = sizeof(*pipeline);
 +	pipeline->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_NEW;
 +	pipeline->pipeline_id = index;
 +	pipeline->comp_id = swidget->comp_id;
 +
 +	/* component at start of pipeline is our stream id */
 +	comp_swidget = snd_sof_find_swidget(scomp, tw->sname);
 +	if (!comp_swidget) {
 +		dev_err(scomp->dev, "error: widget %s refers to non existent widget %s\n",
 +			tw->name, tw->sname);
 +		ret = -EINVAL;
 +		goto err;
  	}
  
 -	dev_err(scomp->dev,
 -		"error: invalid event type %d for widget %s\n",
 -		event_type, swidget->widget->name);
 -	return -EINVAL;
 -}
 +	pipeline->sched_id = comp_swidget->comp_id;
  
 -static int sof_get_token_value(u32 token_id, struct snd_sof_tuple *tuples, int num_tuples)
 -{
 -	int i;
 +	dev_dbg(scomp->dev, "tplg: pipeline id %d comp %d scheduling comp id %d\n",
 +		pipeline->pipeline_id, pipeline->comp_id, pipeline->sched_id);
  
 -	if (!tuples)
 -		return -EINVAL;
 +	ret = sof_parse_tokens(scomp, pipeline, sched_tokens,
 +			       ARRAY_SIZE(sched_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse pipeline tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
  
 -	for (i = 0; i < num_tuples; i++) {
 -		if (tuples[i].token == token_id)
 -			return tuples[i].value.v;
 +	ret = sof_parse_tokens(scomp, swidget, pipeline_tokens,
 +			       ARRAY_SIZE(pipeline_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dynamic pipeline token failed %d\n",
 +			private->size);
 +		goto err;
  	}
  
 -	return -EINVAL;
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		pipeline->core = SOF_DSP_PRIMARY_CORE;
 +
 +	if (sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_OVERRIDE))
 +		swidget->dynamic_pipeline_widget =
 +			sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_ENABLE);
 +
 +	dev_dbg(scomp->dev, "pipeline %s: period %d pri %d mips %d core %d frames %d dynamic %d\n",
 +		swidget->widget->name, pipeline->period, pipeline->priority,
 +		pipeline->period_mips, pipeline->core, pipeline->frames_per_sched,
 +		swidget->dynamic_pipeline_widget);
 +
 +	swidget->core = pipeline->core;
 +	swidget->private = pipeline;
 +
 +	return 0;
 +err:
 +	kfree(pipeline);
 +	return ret;
  }
  
 -/* external widget init - used for any driver specific init */
 -static int sof_widget_ready(struct snd_soc_component *scomp, int index,
 -			    struct snd_soc_dapm_widget *w,
 +/*
 + * Mixer topology
 + */
 +
 +static int sof_widget_load_mixer(struct snd_soc_component *scomp, int index,
 +				 struct snd_sof_widget *swidget,
 +				 struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_mixer *mixer;
 +	size_t ipc_size = sizeof(*mixer);
 +	int ret;
 +
 +	mixer = (struct sof_ipc_comp_mixer *)
 +		sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!mixer)
 +		return -ENOMEM;
 +
 +	/* configure mixer IPC message */
 +	mixer->comp.type = SOF_COMP_MIXER;
 +	mixer->config.hdr.size = sizeof(mixer->config);
 +
 +	ret = sof_parse_tokens(scomp, &mixer->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse mixer.cfg tokens failed %d\n",
 +			private->size);
 +		kfree(mixer);
 +		return ret;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &mixer->config);
 +
 +	swidget->private = mixer;
 +
 +	return 0;
 +}
 +
 +/*
 + * Mux topology
 + */
 +static int sof_widget_load_mux(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_mux *mux;
 +	size_t ipc_size = sizeof(*mux);
 +	int ret;
 +
 +	mux = (struct sof_ipc_comp_mux *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!mux)
 +		return -ENOMEM;
 +
 +	/* configure mux IPC message */
 +	mux->comp.type = SOF_COMP_MUX;
 +	mux->config.hdr.size = sizeof(mux->config);
 +
 +	ret = sof_parse_tokens(scomp, &mux->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse mux.cfg tokens failed %d\n",
 +			private->size);
 +		kfree(mux);
 +		return ret;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &mux->config);
 +
 +	swidget->private = mux;
 +
 +	return 0;
 +}
 +
 +/*
 + * PGA Topology
 + */
 +
 +static int sof_widget_load_pga(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_volume *volume;
 +	struct snd_sof_control *scontrol;
 +	size_t ipc_size = sizeof(*volume);
 +	int min_step;
 +	int max_step;
 +	int ret;
 +
 +	volume = (struct sof_ipc_comp_volume *)
 +		 sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!volume)
 +		return -ENOMEM;
 +
 +	if (!le32_to_cpu(tw->num_kcontrols)) {
 +		dev_err(scomp->dev, "error: invalid kcontrol count %d for volume\n",
 +			tw->num_kcontrols);
 +		ret = -EINVAL;
 +		goto err;
 +	}
 +
 +	/* configure volume IPC message */
 +	volume->comp.type = SOF_COMP_VOLUME;
 +	volume->config.hdr.size = sizeof(volume->config);
 +
 +	ret = sof_parse_tokens(scomp, volume, volume_tokens,
 +			       ARRAY_SIZE(volume_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +	ret = sof_parse_tokens(scomp, &volume->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &volume->config);
 +
 +	swidget->private = volume;
 +
 +	list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
 +		if (scontrol->comp_id == swidget->comp_id &&
 +		    scontrol->volume_table) {
 +			min_step = scontrol->min_volume_step;
 +			max_step = scontrol->max_volume_step;
 +			volume->min_value = scontrol->volume_table[min_step];
 +			volume->max_value = scontrol->volume_table[max_step];
 +			volume->channels = scontrol->num_channels;
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +err:
 +	kfree(volume);
 +	return ret;
 +}
 +
 +/*
 + * SRC Topology
 + */
 +
 +static int sof_widget_load_src(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_src *src;
 +	size_t ipc_size = sizeof(*src);
 +	int ret;
 +
 +	src = (struct sof_ipc_comp_src *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!src)
 +		return -ENOMEM;
 +
 +	/* configure src IPC message */
 +	src->comp.type = SOF_COMP_SRC;
 +	src->config.hdr.size = sizeof(src->config);
 +
 +	ret = sof_parse_tokens(scomp, src, src_tokens,
 +			       ARRAY_SIZE(src_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &src->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "src %s: source rate %d sink rate %d\n",
 +		swidget->widget->name, src->source_rate, src->sink_rate);
 +	sof_dbg_comp_config(scomp, &src->config);
 +
 +	swidget->private = src;
 +
 +	return 0;
 +err:
 +	kfree(src);
 +	return ret;
 +}
 +
 +/*
 + * ASRC Topology
 + */
 +
 +static int sof_widget_load_asrc(struct snd_soc_component *scomp, int index,
 +				struct snd_sof_widget *swidget,
 +				struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_asrc *asrc;
 +	size_t ipc_size = sizeof(*asrc);
 +	int ret;
 +
 +	asrc = (struct sof_ipc_comp_asrc *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!asrc)
 +		return -ENOMEM;
 +
 +	/* configure ASRC IPC message */
 +	asrc->comp.type = SOF_COMP_ASRC;
 +	asrc->config.hdr.size = sizeof(asrc->config);
 +
 +	ret = sof_parse_tokens(scomp, asrc, asrc_tokens,
 +			       ARRAY_SIZE(asrc_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &asrc->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "asrc %s: source rate %d sink rate %d "
 +		"asynch %d operation %d\n",
 +		swidget->widget->name, asrc->source_rate, asrc->sink_rate,
 +		asrc->asynchronous_mode, asrc->operation_mode);
 +	sof_dbg_comp_config(scomp, &asrc->config);
 +
 +	swidget->private = asrc;
 +
 +	return 0;
 +err:
 +	kfree(asrc);
 +	return ret;
 +}
 +
 +/*
 + * Signal Generator Topology
 + */
 +
 +static int sof_widget_load_siggen(struct snd_soc_component *scomp, int index,
 +				  struct snd_sof_widget *swidget,
 +				  struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_tone *tone;
 +	size_t ipc_size = sizeof(*tone);
 +	int ret;
 +
 +	tone = (struct sof_ipc_comp_tone *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!tone)
 +		return -ENOMEM;
 +
 +	/* configure siggen IPC message */
 +	tone->comp.type = SOF_COMP_TONE;
 +	tone->config.hdr.size = sizeof(tone->config);
 +
 +	ret = sof_parse_tokens(scomp, tone, tone_tokens,
 +			       ARRAY_SIZE(tone_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse tone tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &tone->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse tone.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "tone %s: frequency %d amplitude %d\n",
 +		swidget->widget->name, tone->frequency, tone->amplitude);
 +	sof_dbg_comp_config(scomp, &tone->config);
 +
 +	swidget->private = tone;
 +
 +	return 0;
 +err:
 +	kfree(tone);
 +	return ret;
 +}
 +
 +static int sof_get_control_data(struct snd_soc_component *scomp,
 +				struct snd_soc_dapm_widget *widget,
 +				struct sof_widget_data *wdata,
 +				size_t *size)
 +{
 +	const struct snd_kcontrol_new *kc;
 +	struct soc_mixer_control *sm;
 +	struct soc_bytes_ext *sbe;
 +	struct soc_enum *se;
 +	int i;
 +
 +	*size = 0;
 +
 +	for (i = 0; i < widget->num_kcontrols; i++) {
 +		kc = &widget->kcontrol_news[i];
 +
 +		switch (widget->dobj.widget.kcontrol_type[i]) {
 +		case SND_SOC_TPLG_TYPE_MIXER:
 +			sm = (struct soc_mixer_control *)kc->private_value;
 +			wdata[i].control = sm->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_BYTES:
 +			sbe = (struct soc_bytes_ext *)kc->private_value;
 +			wdata[i].control = sbe->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_ENUM:
 +			se = (struct soc_enum *)kc->private_value;
 +			wdata[i].control = se->dobj.private;
 +			break;
 +		default:
 +			dev_err(scomp->dev, "error: unknown kcontrol type %u in widget %s\n",
 +				widget->dobj.widget.kcontrol_type[i],
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		if (!wdata[i].control) {
 +			dev_err(scomp->dev, "error: no scontrol for widget %s\n",
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		wdata[i].pdata = wdata[i].control->control_data->data;
 +		if (!wdata[i].pdata)
 +			return -EINVAL;
 +
 +		/* make sure data is valid - data can be updated at runtime */
 +		if (widget->dobj.widget.kcontrol_type[i] == SND_SOC_TPLG_TYPE_BYTES &&
 +		    wdata[i].pdata->magic != SOF_ABI_MAGIC)
 +			return -EINVAL;
 +
 +		*size += wdata[i].pdata->size;
 +
 +		/* get data type */
 +		switch (wdata[i].control->control_data->cmd) {
 +		case SOF_CTRL_CMD_VOLUME:
 +		case SOF_CTRL_CMD_ENUM:
 +		case SOF_CTRL_CMD_SWITCH:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_VALUE;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_VALUE_CHAN_SET;
 +			break;
 +		case SOF_CTRL_CMD_BINARY:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_DATA;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_DATA_SET;
 +			break;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_process_load(struct snd_soc_component *scomp, int index,
 +			    struct snd_sof_widget *swidget,
 +			    struct snd_soc_tplg_dapm_widget *tw,
 +			    int type)
 +{
 +	struct snd_soc_dapm_widget *widget = swidget->widget;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process *process;
 +	struct sof_widget_data *wdata = NULL;
 +	size_t ipc_data_size = 0;
 +	size_t ipc_size;
 +	int offset = 0;
 +	int ret;
 +	int i;
 +
 +	/* allocate struct for widget control data sizes and types */
 +	if (widget->num_kcontrols) {
 +		wdata = kcalloc(widget->num_kcontrols,
 +				sizeof(*wdata),
 +				GFP_KERNEL);
 +
 +		if (!wdata)
 +			return -ENOMEM;
 +
 +		/* get possible component controls and get size of all pdata */
 +		ret = sof_get_control_data(scomp, widget, wdata,
 +					   &ipc_data_size);
 +
 +		if (ret < 0)
 +			goto out;
 +	}
 +
 +	ipc_size = sizeof(struct sof_ipc_comp_process) + ipc_data_size;
 +
 +	/* we are exceeding max ipc size, config needs to be sent separately */
 +	if (ipc_size > SOF_IPC_MSG_MAX_SIZE) {
 +		ipc_size -= ipc_data_size;
 +		ipc_data_size = 0;
 +	}
 +
 +	process = (struct sof_ipc_comp_process *)
 +		  sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!process) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* configure iir IPC message */
 +	process->comp.type = type;
 +	process->config.hdr.size = sizeof(process->config);
 +
 +	ret = sof_parse_tokens(scomp, &process->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &process->config);
 +
 +	/*
 +	 * found private data in control, so copy it.
 +	 * get possible component controls - get size of all pdata,
 +	 * then memcpy with headers
 +	 */
 +	if (ipc_data_size) {
 +		for (i = 0; i < widget->num_kcontrols; i++) {
 +			memcpy(&process->data[offset],
 +			       wdata[i].pdata->data,
 +			       wdata[i].pdata->size);
 +			offset += wdata[i].pdata->size;
 +		}
 +	}
 +
 +	process->size = ipc_data_size;
 +	swidget->private = process;
 +err:
 +	if (ret < 0)
 +		kfree(process);
 +out:
 +	kfree(wdata);
 +	return ret;
 +}
 +
 +/*
 + * Processing Component Topology - can be "effect", "codec", or general
 + * "processing".
 + */
 +
 +static int sof_widget_load_process(struct snd_soc_component *scomp, int index,
 +				   struct snd_sof_widget *swidget,
 +				   struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process config;
 +	int ret;
 +
 +	/* check we have some tokens - we need at least process type */
 +	if (le32_to_cpu(private->size) == 0) {
 +		dev_err(scomp->dev, "error: process tokens not found\n");
 +		return -EINVAL;
 +	}
 +
 +	memset(&config, 0, sizeof(config));
 +	config.comp.core = swidget->core;
 +
 +	/* get the process token */
 +	ret = sof_parse_tokens(scomp, &config, process_tokens,
 +			       ARRAY_SIZE(process_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	/* now load process specific data and send IPC */
 +	ret = sof_process_load(scomp, index, swidget, tw, find_process_comp_type(config.type));
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: process loading failed\n");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_widget_bind_event(struct snd_soc_component *scomp,
 +				 struct snd_sof_widget *swidget,
 +				 u16 event_type)
 +{
 +	struct sof_ipc_comp *ipc_comp;
 +
 +	/* validate widget event type */
 +	switch (event_type) {
 +	case SOF_KEYWORD_DETECT_DAPM_EVENT:
 +		/* only KEYWORD_DETECT comps should handle this */
 +		if (swidget->id != snd_soc_dapm_effect)
 +			break;
 +
 +		ipc_comp = swidget->private;
 +		if (ipc_comp && ipc_comp->type != SOF_COMP_KEYWORD_DETECT)
 +			break;
 +
 +		/* bind event to keyword detect comp */
 +		return snd_soc_tplg_widget_bind_event(swidget->widget,
 +						      sof_kwd_events,
 +						      ARRAY_SIZE(sof_kwd_events),
 +						      event_type);
 +	default:
 +		break;
 +	}
 +
 +	dev_err(scomp->dev,
 +		"error: invalid event type %d for widget %s\n",
 +		event_type, swidget->widget->name);
 +	return -EINVAL;
 +}
 +
++static int sof_get_token_value(u32 token_id, struct snd_sof_tuple *tuples, int num_tuples)
++{
++	int i;
++
++	if (!tuples)
++		return -EINVAL;
++
++	for (i = 0; i < num_tuples; i++) {
++		if (tuples[i].token == token_id)
++			return tuples[i].value.v;
++	}
++
++	return -EINVAL;
++}
++
 +/* external widget init - used for any driver specific init */
 +static int sof_widget_ready(struct snd_soc_component *scomp, int index,
 +			    struct snd_soc_dapm_widget *w,
  			    struct snd_soc_tplg_dapm_widget *tw)
  {
  	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 -	const struct sof_ipc_tplg_ops *ipc_tplg_ops = sdev->ipc->ops->tplg;
 -	const struct sof_ipc_tplg_widget_ops *widget_ops = ipc_tplg_ops->widget;
  	struct snd_sof_widget *swidget;
  	struct snd_sof_dai *dai;
++<<<<<<< HEAD
 +	struct sof_ipc_comp comp = {
 +		.core = SOF_DSP_PRIMARY_CORE,
 +	};
++=======
+ 	enum sof_tokens *token_list;
+ 	int token_list_size;
++>>>>>>> 909dadf21aae (ASoC: SOF: topology: Make DAI widget parsing IPC agnostic)
  	int ret = 0;
  
  	swidget = kzalloc(sizeof(*swidget), GFP_KERNEL);
@@@ -2391,29 -1484,8 +2243,34 @@@
  		strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
  			? tw->sname : "none");
  
++<<<<<<< HEAD
 +	ret = sof_parse_tokens(scomp, &comp, core_tokens,
 +			       ARRAY_SIZE(core_tokens), tw->priv.array,
 +			       le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing core tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		comp.core = SOF_DSP_PRIMARY_CORE;
 +
 +	swidget->core = comp.core;
 +
 +	ret = sof_parse_tokens(scomp, swidget, comp_ext_tokens, ARRAY_SIZE(comp_ext_tokens),
 +			       tw->priv.array, le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing comp_ext_tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
++=======
+ 	token_list = widget_ops[w->id].token_list;
+ 	token_list_size = widget_ops[w->id].token_list_size;
++>>>>>>> 909dadf21aae (ASoC: SOF: topology: Make DAI widget parsing IPC agnostic)
  
  	/* handle any special case widgets */
  	switch (w->id) {
@@@ -2588,8 -1663,11 +2450,16 @@@ static int sof_widget_unload(struct snd
  	}
  
  out:
++<<<<<<< HEAD
 +	/* free private value */
 +	kfree(swidget->private);
++=======
+ 	/* free IPC related data */
+ 	if (widget_ops[swidget->id].ipc_free)
+ 		widget_ops[swidget->id].ipc_free(swidget);
+ 
+ 	kfree(swidget->tuples);
++>>>>>>> 909dadf21aae (ASoC: SOF: topology: Make DAI widget parsing IPC agnostic)
  
  	/* remove and free swidget object */
  	list_del(&swidget->list);
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/topology.c
