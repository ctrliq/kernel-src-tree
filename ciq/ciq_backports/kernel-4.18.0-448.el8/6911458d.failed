wifi: mac80211: mlme: refactor assoc success handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 6911458dc4283a790194d54d6e854a6ed63e42e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6911458d.failed

Refactor the per-link setup out of ieee80211_assoc_success()
into a new function ieee80211_assoc_config_link().

It looks useless for now to parse the elements again inside
ieee80211_assoc_config_link(), but that will be done with
the link ID in the future.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 6911458dc4283a790194d54d6e854a6ed63e42e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,1829a0b6c9d4..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -3417,960 -3541,1579 +3417,1902 @@@ static bool ieee80211_twt_bcast_support
  			IEEE80211_HE_MAC_CAP2_BCAST_TWT);
  }
  
++<<<<<<< HEAD
++=======
+ static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,
+ 					struct link_sta_info *link_sta,
+ 					struct cfg80211_bss *cbss,
+ 					struct ieee80211_mgmt *mgmt,
+ 					const u8 *elem_start,
+ 					unsigned int elem_len,
+ 					u64 *changed)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
+ 	struct ieee80211_bss_conf *bss_conf = link->conf;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_elems_parse_params parse_params = {
+ 		.start = elem_start,
+ 		.len = elem_len,
+ 		.bss = cbss,
+ 	};
+ 	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
+ 	bool is_s1g = cbss->channel->band == NL80211_BAND_S1GHZ;
+ 	const struct cfg80211_bss_ies *bss_ies = NULL;
+ 	struct ieee80211_supported_band *sband;
+ 	struct ieee802_11_elems *elems;
+ 	u16 capab_info;
+ 	bool ret;
+ 
+ 	elems = ieee802_11_parse_elems_full(&parse_params);
+ 	if (!elems)
+ 		return false;
+ 
+ 	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
+ 
+ 	if (!is_s1g && !elems->supp_rates) {
+ 		sdata_info(sdata, "no SuppRates element in AssocResp\n");
+ 		ret = false;
+ 		goto out;
+ 	}
+ 
+ 	link->u.mgd.tdls_chan_switch_prohibited =
+ 		elems->ext_capab && elems->ext_capab_len >= 5 &&
+ 		(elems->ext_capab[4] & WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED);
+ 
+ 	/*
+ 	 * Some APs are erroneously not including some information in their
+ 	 * (re)association response frames. Try to recover by using the data
+ 	 * from the beacon or probe response. This seems to afflict mobile
+ 	 * 2G/3G/4G wifi routers, reported models include the "Onda PN51T",
+ 	 * "Vodafone PocketWiFi 2", "ZTE MF60" and a similar T-Mobile device.
+ 	 */
+ 	if (!is_6ghz &&
+ 	    ((assoc_data->wmm && !elems->wmm_param) ||
+ 	     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
+ 	      (!elems->ht_cap_elem || !elems->ht_operation)) ||
+ 	     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
+ 	      (!elems->vht_cap_elem || !elems->vht_operation)))) {
+ 		const struct cfg80211_bss_ies *ies;
+ 		struct ieee802_11_elems *bss_elems;
+ 
+ 		rcu_read_lock();
+ 		ies = rcu_dereference(cbss->ies);
+ 		if (ies)
+ 			bss_ies = kmemdup(ies, sizeof(*ies) + ies->len,
+ 					  GFP_ATOMIC);
+ 		rcu_read_unlock();
+ 		if (!bss_ies) {
+ 			ret = false;
+ 			goto out;
+ 		}
+ 
+ 		parse_params.start = bss_ies->data;
+ 		parse_params.len = bss_ies->len;
+ 		bss_elems = ieee802_11_parse_elems_full(&parse_params);
+ 		if (!bss_elems) {
+ 			ret = false;
+ 			goto out;
+ 		}
+ 
+ 		if (assoc_data->wmm &&
+ 		    !elems->wmm_param && bss_elems->wmm_param) {
+ 			elems->wmm_param = bss_elems->wmm_param;
+ 			sdata_info(sdata,
+ 				   "AP bug: WMM param missing from AssocResp\n");
+ 		}
+ 
+ 		/*
+ 		 * Also check if we requested HT/VHT, otherwise the AP doesn't
+ 		 * have to include the IEs in the (re)association response.
+ 		 */
+ 		if (!elems->ht_cap_elem && bss_elems->ht_cap_elem &&
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
+ 			elems->ht_cap_elem = bss_elems->ht_cap_elem;
+ 			sdata_info(sdata,
+ 				   "AP bug: HT capability missing from AssocResp\n");
+ 		}
+ 		if (!elems->ht_operation && bss_elems->ht_operation &&
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
+ 			elems->ht_operation = bss_elems->ht_operation;
+ 			sdata_info(sdata,
+ 				   "AP bug: HT operation missing from AssocResp\n");
+ 		}
+ 		if (!elems->vht_cap_elem && bss_elems->vht_cap_elem &&
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
+ 			elems->vht_cap_elem = bss_elems->vht_cap_elem;
+ 			sdata_info(sdata,
+ 				   "AP bug: VHT capa missing from AssocResp\n");
+ 		}
+ 		if (!elems->vht_operation && bss_elems->vht_operation &&
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
+ 			elems->vht_operation = bss_elems->vht_operation;
+ 			sdata_info(sdata,
+ 				   "AP bug: VHT operation missing from AssocResp\n");
+ 		}
+ 
+ 		kfree(bss_elems);
+ 	}
+ 
+ 	/*
+ 	 * We previously checked these in the beacon/probe response, so
+ 	 * they should be present here. This is just a safety net.
+ 	 */
+ 	if (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
+ 	    (!elems->wmm_param || !elems->ht_cap_elem || !elems->ht_operation)) {
+ 		sdata_info(sdata,
+ 			   "HT AP is missing WMM params or HT capability/operation\n");
+ 		ret = false;
+ 		goto out;
+ 	}
+ 
+ 	if (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
+ 	    (!elems->vht_cap_elem || !elems->vht_operation)) {
+ 		sdata_info(sdata,
+ 			   "VHT AP is missing VHT capability/operation\n");
+ 		ret = false;
+ 		goto out;
+ 	}
+ 
+ 	if (is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
+ 	    !elems->he_6ghz_capa) {
+ 		sdata_info(sdata,
+ 			   "HE 6 GHz AP is missing HE 6 GHz band capability\n");
+ 		ret = false;
+ 		goto out;
+ 	}
+ 
+ 	sband = ieee80211_get_link_sband(link);
+ 	if (!sband) {
+ 		ret = false;
+ 		goto out;
+ 	}
+ 
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
+ 	    (!elems->he_cap || !elems->he_operation)) {
+ 		mutex_unlock(&sdata->local->sta_mtx);
+ 		sdata_info(sdata,
+ 			   "HE AP is missing HE capability/operation\n");
+ 		ret = false;
+ 		goto out;
+ 	}
+ 
+ 	/* Set up internal HT/VHT capabilities */
+ 	if (elems->ht_cap_elem && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
+ 		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
+ 						  elems->ht_cap_elem,
+ 						  link_sta);
+ 
+ 	if (elems->vht_cap_elem && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
+ 						    elems->vht_cap_elem,
+ 						    link_sta);
+ 
+ 	if (elems->he_operation && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
+ 	    elems->he_cap) {
+ 		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
+ 						  elems->he_cap,
+ 						  elems->he_cap_len,
+ 						  elems->he_6ghz_capa,
+ 						  link_sta);
+ 
+ 		bss_conf->he_support = link_sta->pub->he_cap.has_he;
+ 		if (elems->rsnx && elems->rsnx_len &&
+ 		    (elems->rsnx[0] & WLAN_RSNX_CAPA_PROTECTED_TWT) &&
+ 		    wiphy_ext_feature_isset(local->hw.wiphy,
+ 					    NL80211_EXT_FEATURE_PROTECTED_TWT))
+ 			bss_conf->twt_protected = true;
+ 		else
+ 			bss_conf->twt_protected = false;
+ 
+ 		*changed |= ieee80211_recalc_twt_req(link, link_sta, elems);
+ 
+ 		if (elems->eht_operation && elems->eht_cap &&
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT)) {
+ 			ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
+ 							    elems->he_cap,
+ 							    elems->he_cap_len,
+ 							    elems->eht_cap,
+ 							    elems->eht_cap_len,
+ 							    link_sta);
+ 
+ 			bss_conf->eht_support = link_sta->pub->eht_cap.has_eht;
+ 		} else {
+ 			bss_conf->eht_support = false;
+ 		}
+ 	} else {
+ 		bss_conf->he_support = false;
+ 		bss_conf->twt_requester = false;
+ 		bss_conf->twt_protected = false;
+ 		bss_conf->eht_support = false;
+ 	}
+ 
+ 	bss_conf->twt_broadcast =
+ 		ieee80211_twt_bcast_support(sdata, bss_conf, sband, link_sta);
+ 
+ 	if (bss_conf->he_support) {
+ 		bss_conf->he_bss_color.color =
+ 			le32_get_bits(elems->he_operation->he_oper_params,
+ 				      IEEE80211_HE_OPERATION_BSS_COLOR_MASK);
+ 		bss_conf->he_bss_color.partial =
+ 			le32_get_bits(elems->he_operation->he_oper_params,
+ 				      IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR);
+ 		bss_conf->he_bss_color.enabled =
+ 			!le32_get_bits(elems->he_operation->he_oper_params,
+ 				       IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);
+ 
+ 		if (bss_conf->he_bss_color.enabled)
+ 			*changed |= BSS_CHANGED_HE_BSS_COLOR;
+ 
+ 		bss_conf->htc_trig_based_pkt_ext =
+ 			le32_get_bits(elems->he_operation->he_oper_params,
+ 				      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);
+ 		bss_conf->frame_time_rts_th =
+ 			le32_get_bits(elems->he_operation->he_oper_params,
+ 				      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
+ 
+ 		bss_conf->uora_exists = !!elems->uora_element;
+ 		if (elems->uora_element)
+ 			bss_conf->uora_ocw_range = elems->uora_element[0];
+ 
+ 		ieee80211_he_op_ie_to_bss_conf(&sdata->vif, elems->he_operation);
+ 		ieee80211_he_spr_ie_to_bss_conf(&sdata->vif, elems->he_spr);
+ 		/* TODO: OPEN: what happens if BSS color disable is set? */
+ 	}
+ 
+ 	if (cbss->transmitted_bss) {
+ 		bss_conf->nontransmitted = true;
+ 		ether_addr_copy(bss_conf->transmitter_bssid,
+ 				cbss->transmitted_bss->bssid);
+ 		bss_conf->bssid_indicator = cbss->max_bssid_indicator;
+ 		bss_conf->bssid_index = cbss->bssid_index;
+ 	}
+ 
+ 	/*
+ 	 * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data
+ 	 * in their association response, so ignore that data for our own
+ 	 * configuration. If it changed since the last beacon, we'll get the
+ 	 * next beacon and update then.
+ 	 */
+ 
+ 	/*
+ 	 * If an operating mode notification IE is present, override the
+ 	 * NSS calculation (that would be done in rate_control_rate_init())
+ 	 * and use the # of streams from that element.
+ 	 */
+ 	if (elems->opmode_notif &&
+ 	    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {
+ 		u8 nss;
+ 
+ 		nss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;
+ 		nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
+ 		nss += 1;
+ 		link_sta->pub->rx_nss = nss;
+ 	}
+ 
+ 	/*
+ 	 * Always handle WMM once after association regardless
+ 	 * of the first value the AP uses. Setting -1 here has
+ 	 * that effect because the AP values is an unsigned
+ 	 * 4-bit value.
+ 	 */
+ 	link->u.mgd.wmm_last_param_set = -1;
+ 	link->u.mgd.mu_edca_last_param_set = -1;
+ 
+ 	if (link->u.mgd.disable_wmm_tracking) {
+ 		ieee80211_set_wmm_default(link, false, false);
+ 	} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 					     elems->wmm_param_len,
+ 					     elems->mu_edca_param_set)) {
+ 		/* still enable QoS since we might have HT/VHT */
+ 		ieee80211_set_wmm_default(link, false, true);
+ 		/* disable WMM tracking in this case to disable
+ 		 * tracking WMM parameter changes in the beacon if
+ 		 * the parameters weren't actually valid. Doing so
+ 		 * avoids changing parameters very strangely when
+ 		 * the AP is going back and forth between valid and
+ 		 * invalid parameters.
+ 		 */
+ 		link->u.mgd.disable_wmm_tracking = true;
+ 	}
+ 
+ 	if (elems->max_idle_period_ie) {
+ 		bss_conf->max_idle_period =
+ 			le16_to_cpu(elems->max_idle_period_ie->max_idle_period);
+ 		bss_conf->protected_keep_alive =
+ 			!!(elems->max_idle_period_ie->idle_options &
+ 			   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);
+ 		*changed |= BSS_CHANGED_KEEP_ALIVE;
+ 	} else {
+ 		bss_conf->max_idle_period = 0;
+ 		bss_conf->protected_keep_alive = false;
+ 	}
+ 
+ 	/* set assoc capability (AID was already set earlier),
+ 	 * ieee80211_set_associated() will tell the driver */
+ 	bss_conf->assoc_capability = capab_info;
+ 
+ 	ret = true;
+ out:
+ 	kfree(elems);
+ 	kfree(bss_ies);
+ 	return ret;
+ }
+ 
+ static int ieee80211_mgd_setup_link_sta(struct ieee80211_link_data *link,
+ 					struct sta_info *sta,
+ 					struct ieee80211_link_sta *link_sta,
+ 					struct cfg80211_bss *cbss)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	u32 rates = 0, basic_rates = 0;
+ 	bool have_higher_than_11mbit = false;
+ 	int min_rate = INT_MAX, min_rate_index = -1;
+ 	/* this is clearly wrong for MLO but we'll just remove it later */
+ 	int shift = ieee80211_vif_get_shift(&sdata->vif);
+ 	struct ieee80211_supported_band *sband;
+ 
+ 	memcpy(link_sta->addr, cbss->bssid, ETH_ALEN);
+ 
+ 	/* TODO: S1G Basic Rate Set is expressed elsewhere */
+ 	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
+ 		ieee80211_s1g_sta_rate_init(sta);
+ 		return 0;
+ 	}
+ 
+ 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
+ 	ieee80211_get_rates(sband, bss->supp_rates, bss->supp_rates_len,
+ 			    &rates, &basic_rates, &have_higher_than_11mbit,
+ 			    &min_rate, &min_rate_index, shift);
+ 
+ 	/*
+ 	 * This used to be a workaround for basic rates missing
+ 	 * in the association response frame. Now that we no
+ 	 * longer use the basic rates from there, it probably
+ 	 * doesn't happen any more, but keep the workaround so
+ 	 * in case some *other* APs are buggy in different ways
+ 	 * we can connect -- with a warning.
+ 	 * Allow this workaround only in case the AP provided at least
+ 	 * one rate.
+ 	 */
+ 	if (min_rate_index < 0) {
+ 		link_info(link, "No legacy rates in association response\n");
+ 		return -EINVAL;
+ 	} else if (!basic_rates) {
+ 		link_info(link, "No basic rates, using min rate instead\n");
+ 		basic_rates = BIT(min_rate_index);
+ 	}
+ 
+ 	if (rates)
+ 		link_sta->supp_rates[cbss->channel->band] = rates;
+ 	else
+ 		link_info(link, "No rates found, keeping mandatory only\n");
+ 
+ 	link->conf->basic_rates = basic_rates;
+ 
+ 	/* cf. IEEE 802.11 9.2.12 */
+ 	link->operating_11g_mode = sband->band == NL80211_BAND_2GHZ &&
+ 				   have_higher_than_11mbit;
+ 
+ 	return 0;
+ }
+ 
+ static u8 ieee80211_max_rx_chains(struct ieee80211_link_data *link,
+ 				  struct cfg80211_bss *cbss)
+ {
+ 	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
+ 	const struct element *ht_cap_elem, *vht_cap_elem;
+ 	const struct cfg80211_bss_ies *ies;
+ 	const struct ieee80211_ht_cap *ht_cap;
+ 	const struct ieee80211_vht_cap *vht_cap;
+ 	const struct ieee80211_he_cap_elem *he_cap;
+ 	const struct element *he_cap_elem;
+ 	u16 mcs_80_map, mcs_160_map;
+ 	int i, mcs_nss_size;
+ 	bool support_160;
+ 	u8 chains = 1;
+ 
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)
+ 		return chains;
+ 
+ 	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
+ 	if (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {
+ 		ht_cap = (void *)ht_cap_elem->data;
+ 		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
+ 		/*
+ 		 * TODO: use "Tx Maximum Number Spatial Streams Supported" and
+ 		 *	 "Tx Unequal Modulation Supported" fields.
+ 		 */
+ 	}
+ 
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
+ 		return chains;
+ 
+ 	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
+ 	if (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {
+ 		u8 nss;
+ 		u16 tx_mcs_map;
+ 
+ 		vht_cap = (void *)vht_cap_elem->data;
+ 		tx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
+ 		for (nss = 8; nss > 0; nss--) {
+ 			if (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=
+ 					IEEE80211_VHT_MCS_NOT_SUPPORTED)
+ 				break;
+ 		}
+ 		/* TODO: use "Tx Highest Supported Long GI Data Rate" field? */
+ 		chains = max(chains, nss);
+ 	}
+ 
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)
+ 		return chains;
+ 
+ 	ies = rcu_dereference(cbss->ies);
+ 	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
+ 					     ies->data, ies->len);
+ 
+ 	if (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))
+ 		return chains;
+ 
+ 	/* skip one byte ext_tag_id */
+ 	he_cap = (void *)(he_cap_elem->data + 1);
+ 	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
+ 
+ 	/* invalid HE IE */
+ 	if (he_cap_elem->datalen < 1 + mcs_nss_size + sizeof(*he_cap))
+ 		return chains;
+ 
+ 	/* mcs_nss is right after he_cap info */
+ 	he_mcs_nss_supp = (void *)(he_cap + 1);
+ 
+ 	mcs_80_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
+ 
+ 	for (i = 7; i >= 0; i--) {
+ 		u8 mcs_80 = mcs_80_map >> (2 * i) & 3;
+ 
+ 		if (mcs_80 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
+ 			chains = max_t(u8, chains, i + 1);
+ 			break;
+ 		}
+ 	}
+ 
+ 	support_160 = he_cap->phy_cap_info[0] &
+ 		      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
+ 
+ 	if (!support_160)
+ 		return chains;
+ 
+ 	mcs_160_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_160);
+ 	for (i = 7; i >= 0; i--) {
+ 		u8 mcs_160 = mcs_160_map >> (2 * i) & 3;
+ 
+ 		if (mcs_160 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
+ 			chains = max_t(u8, chains, i + 1);
+ 			break;
+ 		}
+ 	}
+ 
+ 	return chains;
+ }
+ 
+ static bool
+ ieee80211_verify_peer_he_mcs_support(struct ieee80211_sub_if_data *sdata,
+ 				     const struct cfg80211_bss_ies *ies,
+ 				     const struct ieee80211_he_operation *he_op)
+ {
+ 	const struct element *he_cap_elem;
+ 	const struct ieee80211_he_cap_elem *he_cap;
+ 	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
+ 	u16 mcs_80_map_tx, mcs_80_map_rx;
+ 	u16 ap_min_req_set;
+ 	int mcs_nss_size;
+ 	int nss;
+ 
+ 	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
+ 					     ies->data, ies->len);
+ 
+ 	/* invalid HE IE */
+ 	if (!he_cap_elem || he_cap_elem->datalen < 1 + sizeof(*he_cap)) {
+ 		sdata_info(sdata,
+ 			   "Invalid HE elem, Disable HE\n");
+ 		return false;
+ 	}
+ 
+ 	/* skip one byte ext_tag_id */
+ 	he_cap = (void *)(he_cap_elem->data + 1);
+ 	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
+ 
+ 	/* invalid HE IE */
+ 	if (he_cap_elem->datalen < 1 + sizeof(*he_cap) + mcs_nss_size) {
+ 		sdata_info(sdata,
+ 			   "Invalid HE elem with nss size, Disable HE\n");
+ 		return false;
+ 	}
+ 
+ 	/* mcs_nss is right after he_cap info */
+ 	he_mcs_nss_supp = (void *)(he_cap + 1);
+ 
+ 	mcs_80_map_tx = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
+ 	mcs_80_map_rx = le16_to_cpu(he_mcs_nss_supp->rx_mcs_80);
+ 
+ 	/* P802.11-REVme/D0.3
+ 	 * 27.1.1 Introduction to the HE PHY
+ 	 * ...
+ 	 * An HE STA shall support the following features:
+ 	 * ...
+ 	 * Single spatial stream HE-MCSs 0 to 7 (transmit and receive) in all
+ 	 * supported channel widths for HE SU PPDUs
+ 	 */
+ 	if ((mcs_80_map_tx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 	    (mcs_80_map_rx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED) {
+ 		sdata_info(sdata,
+ 			   "Missing mandatory rates for 1 Nss, rx 0x%x, tx 0x%x, disable HE\n",
+ 			   mcs_80_map_tx, mcs_80_map_rx);
+ 		return false;
+ 	}
+ 
+ 	if (!he_op)
+ 		return true;
+ 
+ 	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
+ 
+ 	/*
+ 	 * Apparently iPhone 13 (at least iOS version 15.3.1) sets this to all
+ 	 * zeroes, which is nonsense, and completely inconsistent with itself
+ 	 * (it doesn't have 8 streams). Accept the settings in this case anyway.
+ 	 */
+ 	if (!ap_min_req_set)
+ 		return true;
+ 
+ 	/* make sure the AP is consistent with itself
+ 	 *
+ 	 * P802.11-REVme/D0.3
+ 	 * 26.17.1 Basic HE BSS operation
+ 	 *
+ 	 * A STA that is operating in an HE BSS shall be able to receive and
+ 	 * transmit at each of the <HE-MCS, NSS> tuple values indicated by the
+ 	 * Basic HE-MCS And NSS Set field of the HE Operation parameter of the
+ 	 * MLME-START.request primitive and shall be able to receive at each of
+ 	 * the <HE-MCS, NSS> tuple values indicated by the Supported HE-MCS and
+ 	 * NSS Set field in the HE Capabilities parameter of the MLMESTART.request
+ 	 * primitive
+ 	 */
+ 	for (nss = 8; nss > 0; nss--) {
+ 		u8 ap_op_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
+ 		u8 ap_rx_val;
+ 		u8 ap_tx_val;
+ 
+ 		if (ap_op_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
+ 			continue;
+ 
+ 		ap_rx_val = (mcs_80_map_rx >> (2 * (nss - 1))) & 3;
+ 		ap_tx_val = (mcs_80_map_tx >> (2 * (nss - 1))) & 3;
+ 
+ 		if (ap_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 		    ap_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 		    ap_rx_val < ap_op_val || ap_tx_val < ap_op_val) {
+ 			sdata_info(sdata,
+ 				   "Invalid rates for %d Nss, rx %d, tx %d oper %d, disable HE\n",
+ 				   nss, ap_rx_val, ap_rx_val, ap_op_val);
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool
+ ieee80211_verify_sta_he_mcs_support(struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_supported_band *sband,
+ 				    const struct ieee80211_he_operation *he_op)
+ {
+ 	const struct ieee80211_sta_he_cap *sta_he_cap =
+ 		ieee80211_get_he_iftype_cap(sband,
+ 					    ieee80211_vif_type_p2p(&sdata->vif));
+ 	u16 ap_min_req_set;
+ 	int i;
+ 
+ 	if (!sta_he_cap || !he_op)
+ 		return false;
+ 
+ 	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
+ 
+ 	/*
+ 	 * Apparently iPhone 13 (at least iOS version 15.3.1) sets this to all
+ 	 * zeroes, which is nonsense, and completely inconsistent with itself
+ 	 * (it doesn't have 8 streams). Accept the settings in this case anyway.
+ 	 */
+ 	if (!ap_min_req_set)
+ 		return true;
+ 
+ 	/* Need to go over for 80MHz, 160MHz and for 80+80 */
+ 	for (i = 0; i < 3; i++) {
+ 		const struct ieee80211_he_mcs_nss_supp *sta_mcs_nss_supp =
+ 			&sta_he_cap->he_mcs_nss_supp;
+ 		u16 sta_mcs_map_rx =
+ 			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i]);
+ 		u16 sta_mcs_map_tx =
+ 			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i + 1]);
+ 		u8 nss;
+ 		bool verified = true;
+ 
+ 		/*
+ 		 * For each band there is a maximum of 8 spatial streams
+ 		 * possible. Each of the sta_mcs_map_* is a 16-bit struct built
+ 		 * of 2 bits per NSS (1-8), with the values defined in enum
+ 		 * ieee80211_he_mcs_support. Need to make sure STA TX and RX
+ 		 * capabilities aren't less than the AP's minimum requirements
+ 		 * for this HE BSS per SS.
+ 		 * It is enough to find one such band that meets the reqs.
+ 		 */
+ 		for (nss = 8; nss > 0; nss--) {
+ 			u8 sta_rx_val = (sta_mcs_map_rx >> (2 * (nss - 1))) & 3;
+ 			u8 sta_tx_val = (sta_mcs_map_tx >> (2 * (nss - 1))) & 3;
+ 			u8 ap_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
+ 
+ 			if (ap_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
+ 				continue;
+ 
+ 			/*
+ 			 * Make sure the HE AP doesn't require MCSs that aren't
+ 			 * supported by the client as required by spec
+ 			 *
+ 			 * P802.11-REVme/D0.3
+ 			 * 26.17.1 Basic HE BSS operation
+ 			 *
+ 			 * An HE STA shall not attempt to join * (MLME-JOIN.request primitive)
+ 			 * a BSS, unless it supports (i.e., is able to both transmit and
+ 			 * receive using) all of the <HE-MCS, NSS> tuples in the basic
+ 			 * HE-MCS and NSS set.
+ 			 */
+ 			if (sta_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 			    sta_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 			    (ap_val > sta_rx_val) || (ap_val > sta_tx_val)) {
+ 				verified = false;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (verified)
+ 			return true;
+ 	}
+ 
+ 	/* If here, STA doesn't meet AP's HE min requirements */
+ 	return false;
+ }
+ 
+ static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
+ 				  struct ieee80211_link_data *link,
+ 				  struct cfg80211_bss *cbss,
+ 				  ieee80211_conn_flags_t *conn_flags)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	const struct ieee80211_ht_cap *ht_cap = NULL;
+ 	const struct ieee80211_ht_operation *ht_oper = NULL;
+ 	const struct ieee80211_vht_operation *vht_oper = NULL;
+ 	const struct ieee80211_he_operation *he_oper = NULL;
+ 	const struct ieee80211_eht_operation *eht_oper = NULL;
+ 	const struct ieee80211_s1g_oper_ie *s1g_oper = NULL;
+ 	struct ieee80211_supported_band *sband;
+ 	struct cfg80211_chan_def chandef;
+ 	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
+ 	bool is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	struct ieee802_11_elems *elems;
+ 	const struct cfg80211_bss_ies *ies;
+ 	int ret;
+ 	u32 i;
+ 	bool have_80mhz;
+ 
+ 	rcu_read_lock();
+ 
+ 	ies = rcu_dereference(cbss->ies);
+ 	elems = ieee802_11_parse_elems(ies->data, ies->len, false, cbss);
+ 	if (!elems) {
+ 		rcu_read_unlock();
+ 		return -ENOMEM;
+ 	}
+ 
+ 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
+ 	*conn_flags &= ~(IEEE80211_CONN_DISABLE_40MHZ |
+ 			 IEEE80211_CONN_DISABLE_80P80MHZ |
+ 			 IEEE80211_CONN_DISABLE_160MHZ);
+ 
+ 	/* disable HT/VHT/HE if we don't support them */
+ 	if (!sband->ht_cap.ht_supported && !is_6ghz) {
+ 		mlme_dbg(sdata, "HT not supported, disabling HT/VHT/HE/EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!sband->vht_cap.vht_supported && is_5ghz) {
+ 		mlme_dbg(sdata, "VHT not supported, disabling VHT/HE/EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!ieee80211_get_he_iftype_cap(sband,
+ 					 ieee80211_vif_type_p2p(&sdata->vif))) {
+ 		mlme_dbg(sdata, "HE not supported, disabling HE and EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!ieee80211_get_eht_iftype_cap(sband,
+ 					  ieee80211_vif_type_p2p(&sdata->vif))) {
+ 		mlme_dbg(sdata, "EHT not supported, disabling EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!(*conn_flags & IEEE80211_CONN_DISABLE_HT) && !is_6ghz) {
+ 		ht_oper = elems->ht_operation;
+ 		ht_cap = elems->ht_cap_elem;
+ 
+ 		if (!ht_cap) {
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			ht_oper = NULL;
+ 		}
+ 	}
+ 
+ 	if (!(*conn_flags & IEEE80211_CONN_DISABLE_VHT) && !is_6ghz) {
+ 		vht_oper = elems->vht_operation;
+ 		if (vht_oper && !ht_oper) {
+ 			vht_oper = NULL;
+ 			sdata_info(sdata,
+ 				   "AP advertised VHT without HT, disabling HT/VHT/HE\n");
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 		}
+ 
+ 		if (!elems->vht_cap_elem) {
+ 			sdata_info(sdata,
+ 				   "bad VHT capabilities, disabling VHT\n");
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			vht_oper = NULL;
+ 		}
+ 	}
+ 
+ 	if (!(*conn_flags & IEEE80211_CONN_DISABLE_HE)) {
+ 		he_oper = elems->he_operation;
+ 
+ 		if (link && is_6ghz) {
+ 			struct ieee80211_bss_conf *bss_conf;
+ 			u8 j = 0;
+ 
+ 			bss_conf = link->conf;
+ 
+ 			if (elems->pwr_constr_elem)
+ 				bss_conf->pwr_reduction = *elems->pwr_constr_elem;
+ 
+ 			BUILD_BUG_ON(ARRAY_SIZE(bss_conf->tx_pwr_env) !=
+ 				     ARRAY_SIZE(elems->tx_pwr_env));
+ 
+ 			for (i = 0; i < elems->tx_pwr_env_num; i++) {
+ 				if (elems->tx_pwr_env_len[i] >
+ 				    sizeof(bss_conf->tx_pwr_env[j]))
+ 					continue;
+ 
+ 				bss_conf->tx_pwr_env_num++;
+ 				memcpy(&bss_conf->tx_pwr_env[j], elems->tx_pwr_env[i],
+ 				       elems->tx_pwr_env_len[i]);
+ 				j++;
+ 			}
+ 		}
+ 
+ 		if (!ieee80211_verify_peer_he_mcs_support(sdata, ies, he_oper) ||
+ 		    !ieee80211_verify_sta_he_mcs_support(sdata, sband, he_oper))
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HE |
+ 				       IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	/*
+ 	 * EHT requires HE to be supported as well. Specifically for 6 GHz
+ 	 * channels, the operation channel information can only be deduced from
+ 	 * both the 6 GHz operation information (from the HE operation IE) and
+ 	 * EHT operation.
+ 	 */
+ 	if (!(*conn_flags &
+ 			(IEEE80211_CONN_DISABLE_HE |
+ 			 IEEE80211_CONN_DISABLE_EHT)) &&
+ 	    he_oper) {
+ 		const struct cfg80211_bss_ies *cbss_ies;
+ 		const u8 *eht_oper_ie;
+ 
+ 		cbss_ies = rcu_dereference(cbss->ies);
+ 		eht_oper_ie = cfg80211_find_ext_ie(WLAN_EID_EXT_EHT_OPERATION,
+ 						   cbss_ies->data, cbss_ies->len);
+ 		if (eht_oper_ie && eht_oper_ie[1] >=
+ 		    1 + sizeof(struct ieee80211_eht_operation))
+ 			eht_oper = (void *)(eht_oper_ie + 3);
+ 		else
+ 			eht_oper = NULL;
+ 	}
+ 
+ 	/* Allow VHT if at least one channel on the sband supports 80 MHz */
+ 	have_80mhz = false;
+ 	for (i = 0; i < sband->n_channels; i++) {
+ 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+ 						IEEE80211_CHAN_NO_80MHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
+ 		break;
+ 	}
+ 
+ 	if (!have_80mhz) {
+ 		sdata_info(sdata, "80 MHz not supported, disabling VHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 	}
+ 
+ 	if (sband->band == NL80211_BAND_S1GHZ) {
+ 		s1g_oper = elems->s1g_oper;
+ 		if (!s1g_oper)
+ 			sdata_info(sdata,
+ 				   "AP missing S1G operation element?\n");
+ 	}
+ 
+ 	*conn_flags |=
+ 		ieee80211_determine_chantype(sdata, link, *conn_flags,
+ 					     sband,
+ 					     cbss->channel,
+ 					     bss->vht_cap_info,
+ 					     ht_oper, vht_oper,
+ 					     he_oper, eht_oper,
+ 					     s1g_oper,
+ 					     &chandef, false);
+ 
+ 	if (link)
+ 		link->needed_rx_chains =
+ 			min(ieee80211_max_rx_chains(link, cbss),
+ 			    local->rx_chains);
+ 
+ 	rcu_read_unlock();
+ 	/* the element data was RCU protected so no longer valid anyway */
+ 	kfree(elems);
+ 	elems = NULL;
+ 
+ 	if (*conn_flags & IEEE80211_CONN_DISABLE_HE && is_6ghz) {
+ 		sdata_info(sdata, "Rejecting non-HE 6/7 GHz connection");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!link)
+ 		return 0;
+ 
+ 	/* will change later if needed */
+ 	link->smps_mode = IEEE80211_SMPS_OFF;
+ 
+ 	mutex_lock(&local->mtx);
+ 	/*
+ 	 * If this fails (possibly due to channel context sharing
+ 	 * on incompatible channels, e.g. 80+80 and 160 sharing the
+ 	 * same control channel) try to use a smaller bandwidth.
+ 	 */
+ 	ret = ieee80211_link_use_channel(link, &chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
+ 
+ 	/* don't downgrade for 5 and 10 MHz channels, though. */
+ 	if (chandef.width == NL80211_CHAN_WIDTH_5 ||
+ 	    chandef.width == NL80211_CHAN_WIDTH_10)
+ 		goto out;
+ 
+ 	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
+ 		*conn_flags |=
+ 			ieee80211_chandef_downgrade(&chandef);
+ 		ret = ieee80211_link_use_channel(link, &chandef,
+ 						 IEEE80211_CHANCTX_SHARED);
+ 	}
+  out:
+ 	mutex_unlock(&local->mtx);
+ 	return ret;
+ }
+ 
++>>>>>>> 6911458dc428 (wifi: mac80211: mlme: refactor assoc success handling)
  static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
  				    struct cfg80211_bss *cbss,
- 				    struct ieee80211_mgmt *mgmt, size_t len,
- 				    struct ieee802_11_elems *elems)
+ 				    struct ieee80211_mgmt *mgmt,
+ 				    struct ieee802_11_elems *elems,
+ 				    const u8 *elem_start, unsigned int elem_len)
  {
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  	struct ieee80211_local *local = sdata->local;
++<<<<<<< HEAD
 +	struct ieee80211_supported_band *sband;
  	struct sta_info *sta;
 -	u64 changed = 0;
 +	u16 capab_info, aid;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +	const struct cfg80211_bss_ies *bss_ies = NULL;
 +	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
 +	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
 +	bool is_s1g = cbss->channel->band == NL80211_BAND_S1GHZ;
 +	u32 changed = 0;
  	int err;
 +	bool ret;
 +
 +	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
 +
 +	if (elems->aid_resp)
 +		aid = le16_to_cpu(elems->aid_resp->aid);
 +	else if (is_s1g)
 +		aid = 0; /* TODO */
 +	else
 +		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
  
 -	mutex_lock(&sdata->local->sta_mtx);
  	/*
 -	 * station info was already allocated and inserted before
 -	 * the association and should be available to us
 +	 * The 5 MSB of the AID field are reserved
 +	 * (802.11-2016 9.4.1.8 AID field)
  	 */
 -	sta = sta_info_get(sdata, cbss->bssid);
 -	if (WARN_ON(!sta))
 -		goto out_err;
 -
 -	if (!ieee80211_assoc_config_link(&sdata->deflink, &sta->deflink,
 -					 cbss, mgmt, elem_start, elem_len,
 -					 &changed))
 -		goto out_err;
 +	aid &= 0x7ff;
  
 -	rate_control_rate_init(sta);
 +	ifmgd->broken_ap = false;
  
 -	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
 -		set_sta_flag(sta, WLAN_STA_MFP);
 -		sta->sta.mfp = true;
 -	} else {
 -		sta->sta.mfp = false;
 +	if (aid == 0 || aid > IEEE80211_MAX_AID) {
 +		sdata_info(sdata, "invalid AID value %d (out of range), turn off PS\n",
 +			   aid);
 +		aid = 0;
 +		ifmgd->broken_ap = true;
  	}
  
 -	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
 -		       local->hw.queues >= IEEE80211_NUM_ACS;
 -
 -	err = sta_info_move_state(sta, IEEE80211_STA_ASSOC);
 -	if (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
 -		err = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);
 -	if (err) {
 -		sdata_info(sdata,
 -			   "failed to move station %pM to desired state\n",
 -			   sta->sta.addr);
 -		WARN_ON(__sta_info_destroy(sta));
 -		goto out_err;
 +	if (!is_s1g && !elems->supp_rates) {
 +		sdata_info(sdata, "no SuppRates element in AssocResp\n");
 +		ret = false;
 +		goto out;
  	}
  
 -	if (sdata->wdev.use_4addr)
 -		drv_sta_set_4addr(local, sdata, &sta->sta, true);
 -
 -	mutex_unlock(&sdata->local->sta_mtx);
 -
 -	ieee80211_set_associated(sdata, cbss, changed);
 +	sdata->vif.bss_conf.aid = aid;
 +	ifmgd->tdls_chan_switch_prohibited =
 +		elems->ext_capab && elems->ext_capab_len >= 5 &&
 +		(elems->ext_capab[4] & WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED);
  
  	/*
 -	 * If we're using 4-addr mode, let the AP know that we're
 -	 * doing so, so that it can create the STA VLAN on its side
 +	 * Some APs are erroneously not including some information in their
 +	 * (re)association response frames. Try to recover by using the data
 +	 * from the beacon or probe response. This seems to afflict mobile
 +	 * 2G/3G/4G wifi routers, reported models include the "Onda PN51T",
 +	 * "Vodafone PocketWiFi 2", "ZTE MF60" and a similar T-Mobile device.
  	 */
 -	if (ifmgd->use_4addr)
 -		ieee80211_send_4addr_nullfunc(local, sdata);
 +	if (!is_6ghz &&
 +	    ((assoc_data->wmm && !elems->wmm_param) ||
 +	     (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +	      (!elems->ht_cap_elem || !elems->ht_operation)) ||
 +	     (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
 +	      (!elems->vht_cap_elem || !elems->vht_operation)))) {
 +		const struct cfg80211_bss_ies *ies;
 +		struct ieee802_11_elems *bss_elems;
  
 -	/*
 -	 * Start timer to probe the connection to the AP now.
 -	 * Also start the timer that will detect beacon loss.
 -	 */
 -	ieee80211_sta_reset_beacon_monitor(sdata);
 -	ieee80211_sta_reset_conn_monitor(sdata);
 +		rcu_read_lock();
 +		ies = rcu_dereference(cbss->ies);
 +		if (ies)
 +			bss_ies = kmemdup(ies, sizeof(*ies) + ies->len,
 +					  GFP_ATOMIC);
 +		rcu_read_unlock();
 +		if (!bss_ies) {
 +			ret = false;
 +			goto out;
 +		}
  
 -	return true;
 -out_err:
 -	mutex_unlock(&sdata->local->sta_mtx);
 -	return false;
 -}
 +		bss_elems = ieee802_11_parse_elems(bss_ies->data, bss_ies->len,
 +						   false, assoc_data->bss);
 +		if (!bss_elems) {
 +			ret = false;
 +			goto out;
 +		}
  
 -static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
 -					 struct ieee80211_mgmt *mgmt,
 -					 size_t len)
 -{
 -	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 -	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
 -	u16 capab_info, status_code, aid;
 -	struct ieee802_11_elems *elems;
 -	int ac;
 -	const u8 *elem_start;
 -	unsigned int elem_len;
 -	bool reassoc;
 -	struct cfg80211_bss *cbss;
 -	struct ieee80211_event event = {
 -		.type = MLME_EVENT,
 -		.u.mlme.data = ASSOC_EVENT,
 -	};
 -	struct ieee80211_prep_tx_info info = {};
 -	struct cfg80211_rx_assoc_resp resp = {
 -		.uapsd_queues = -1,
 -	};
 -
 -	sdata_assert_lock(sdata);
 -
 -	if (!assoc_data)
 -		return;
 +		if (assoc_data->wmm &&
 +		    !elems->wmm_param && bss_elems->wmm_param) {
 +			elems->wmm_param = bss_elems->wmm_param;
 +			sdata_info(sdata,
 +				   "AP bug: WMM param missing from AssocResp\n");
 +		}
  
 -	if (!ether_addr_equal(assoc_data->bss->bssid, mgmt->bssid))
 -		return;
 +		/*
 +		 * Also check if we requested HT/VHT, otherwise the AP doesn't
 +		 * have to include the IEs in the (re)association response.
 +		 */
 +		if (!elems->ht_cap_elem && bss_elems->ht_cap_elem &&
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
 +			elems->ht_cap_elem = bss_elems->ht_cap_elem;
 +			sdata_info(sdata,
 +				   "AP bug: HT capability missing from AssocResp\n");
 +		}
 +		if (!elems->ht_operation && bss_elems->ht_operation &&
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
 +			elems->ht_operation = bss_elems->ht_operation;
 +			sdata_info(sdata,
 +				   "AP bug: HT operation missing from AssocResp\n");
 +		}
 +		if (!elems->vht_cap_elem && bss_elems->vht_cap_elem &&
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)) {
 +			elems->vht_cap_elem = bss_elems->vht_cap_elem;
 +			sdata_info(sdata,
 +				   "AP bug: VHT capa missing from AssocResp\n");
 +		}
 +		if (!elems->vht_operation && bss_elems->vht_operation &&
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)) {
 +			elems->vht_operation = bss_elems->vht_operation;
 +			sdata_info(sdata,
 +				   "AP bug: VHT operation missing from AssocResp\n");
 +		}
  
 -	cbss = assoc_data->bss;
 +		kfree(bss_elems);
 +	}
  
  	/*
 -	 * AssocResp and ReassocResp have identical structure, so process both
 -	 * of them in this function.
 +	 * We previously checked these in the beacon/probe response, so
 +	 * they should be present here. This is just a safety net.
  	 */
 +	if (!is_6ghz && !(ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +	    (!elems->wmm_param || !elems->ht_cap_elem || !elems->ht_operation)) {
 +		sdata_info(sdata,
 +			   "HT AP is missing WMM params or HT capability/operation\n");
 +		ret = false;
 +		goto out;
 +	}
  
 -	if (len < 24 + 6)
 -		return;
 +	if (!is_6ghz && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
 +	    (!elems->vht_cap_elem || !elems->vht_operation)) {
 +		sdata_info(sdata,
 +			   "VHT AP is missing VHT capability/operation\n");
 +		ret = false;
 +		goto out;
 +	}
  
 -	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
 -	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
 -	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
 -	if (cbss->channel->band == NL80211_BAND_S1GHZ)
 -		elem_start = mgmt->u.s1g_assoc_resp.variable;
 -	else
 -		elem_start = mgmt->u.assoc_resp.variable;
 +	if (is_6ghz && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
 +	    !elems->he_6ghz_capa) {
 +		sdata_info(sdata,
 +			   "HE 6 GHz AP is missing HE 6 GHz band capability\n");
 +		ret = false;
 +		goto out;
 +	}
++=======
++	struct sta_info *sta;
++	u64 changed = 0;
++	int err;
++>>>>>>> 6911458dc428 (wifi: mac80211: mlme: refactor assoc success handling)
  
 +	mutex_lock(&sdata->local->sta_mtx);
  	/*
 -	 * Note: this may not be perfect, AP might misbehave - if
 -	 * anyone needs to rely on perfect complete notification
 -	 * with the exact right subtype, then we need to track what
 -	 * we actually transmitted.
 +	 * station info was already allocated and inserted before
 +	 * the association and should be available to us
  	 */
 -	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
 -				 IEEE80211_STYPE_ASSOC_REQ;
 +	sta = sta_info_get(sdata, cbss->bssid);
- 	if (WARN_ON(!sta)) {
- 		mutex_unlock(&sdata->local->sta_mtx);
- 		ret = false;
- 		goto out;
- 	}
++	if (WARN_ON(!sta))
++		goto out_err;
  
 -	if (assoc_data->fils_kek_len &&
 -	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
 -		return;
++<<<<<<< HEAD
 +	sband = ieee80211_get_link_sband(link);
 +	if (!sband) {
 +		mutex_unlock(&sdata->local->sta_mtx);
 +		ret = false;
 +		goto out;
 +	}
  
 -	elem_len = len - (elem_start - (u8 *)mgmt);
 -	elems = ieee802_11_parse_elems(elem_start, elem_len, false, NULL);
 -	if (!elems)
 -		goto notify_driver;
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
 +	    (!elems->he_cap || !elems->he_operation)) {
 +		mutex_unlock(&sdata->local->sta_mtx);
 +		sdata_info(sdata,
 +			   "HE AP is missing HE capability/operation\n");
 +		ret = false;
 +		goto out;
 +	}
  
 -	if (elems->aid_resp)
 -		aid = le16_to_cpu(elems->aid_resp->aid);
 -	else if (cbss->channel->band == NL80211_BAND_S1GHZ)
 -		aid = 0; /* TODO */
 -	else
 -		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
 +	/* Set up internal HT/VHT capabilities */
 +	if (elems->ht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
 +		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
 +						  elems->ht_cap_elem, sta);
  
 -	/*
 -	 * The 5 MSB of the AID field are reserved
 -	 * (802.11-2016 9.4.1.8 AID field)
 -	 */
 -	aid &= 0x7ff;
 +	if (elems->vht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
 +						    elems->vht_cap_elem, sta);
  
 -	sdata_info(sdata,
 -		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
 -		   reassoc ? "Rea" : "A", mgmt->sa,
 -		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
 +	if (elems->he_operation && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
 +	    elems->he_cap) {
 +		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
 +						  elems->he_cap,
 +						  elems->he_cap_len,
 +						  elems->he_6ghz_capa,
 +						  sta);
  
 -	ifmgd->broken_ap = false;
 +		bss_conf->he_support = sta->sta.he_cap.has_he;
 +		if (elems->rsnx && elems->rsnx_len &&
 +		    (elems->rsnx[0] & WLAN_RSNX_CAPA_PROTECTED_TWT) &&
 +		    wiphy_ext_feature_isset(local->hw.wiphy,
 +					    NL80211_EXT_FEATURE_PROTECTED_TWT))
 +			bss_conf->twt_protected = true;
 +		else
 +			bss_conf->twt_protected = false;
  
 -	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
 -	    elems->timeout_int &&
 -	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
 -		u32 tu, ms;
 +		changed |= ieee80211_recalc_twt_req(sdata, sta, elems);
  
 -		cfg80211_assoc_comeback(sdata->dev, assoc_data->bss->bssid,
 -					le32_to_cpu(elems->timeout_int->value));
 +		if (elems->eht_operation && elems->eht_cap &&
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_EHT)) {
 +			ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
 +							    elems->he_cap,
 +							    elems->he_cap_len,
 +							    elems->eht_cap,
 +							    elems->eht_cap_len,
 +							    sta);
  
 -		tu = le32_to_cpu(elems->timeout_int->value);
 -		ms = tu * 1024 / 1000;
 -		sdata_info(sdata,
 -			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
 -			   mgmt->sa, tu, ms);
 -		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
 -		assoc_data->timeout_started = true;
 -		if (ms > IEEE80211_ASSOC_TIMEOUT)
 -			run_again(sdata, assoc_data->timeout);
 -		goto notify_driver;
 +			bss_conf->eht_support = sta->sta.eht_cap.has_eht;
 +		} else {
 +			bss_conf->eht_support = false;
 +		}
 +	} else {
 +		bss_conf->he_support = false;
 +		bss_conf->twt_requester = false;
 +		bss_conf->twt_protected = false;
 +		bss_conf->eht_support = false;
  	}
  
 -	if (status_code != WLAN_STATUS_SUCCESS) {
 -		sdata_info(sdata, "%pM denied association (code=%d)\n",
 -			   mgmt->sa, status_code);
 -		ieee80211_destroy_assoc_data(sdata, ASSOC_REJECTED);
 -		event.u.mlme.status = MLME_DENIED;
 -		event.u.mlme.reason = status_code;
 -		drv_event_callback(sdata->local, sdata, &event);
 -	} else {
 -		if (aid == 0 || aid > IEEE80211_MAX_AID) {
 -			sdata_info(sdata,
 -				   "invalid AID value %d (out of range), turn off PS\n",
 -				   aid);
 -			aid = 0;
 -			ifmgd->broken_ap = true;
 -		}
 +	bss_conf->twt_broadcast =
 +		ieee80211_twt_bcast_support(sdata, bss_conf, sband, sta);
  
 -		sdata->vif.cfg.aid = aid;
 +	if (bss_conf->he_support) {
 +		bss_conf->he_bss_color.color =
 +			le32_get_bits(elems->he_operation->he_oper_params,
 +				      IEEE80211_HE_OPERATION_BSS_COLOR_MASK);
 +		bss_conf->he_bss_color.partial =
 +			le32_get_bits(elems->he_operation->he_oper_params,
 +				      IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR);
 +		bss_conf->he_bss_color.enabled =
 +			!le32_get_bits(elems->he_operation->he_oper_params,
 +				       IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);
  
 -		if (!ieee80211_assoc_success(sdata, cbss, mgmt, elems,
 -					     elem_start, elem_len)) {
 -			/* oops -- internal error -- send timeout for now */
 -			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
 -			goto notify_driver;
 -		}
 -		event.u.mlme.status = MLME_SUCCESS;
 -		drv_event_callback(sdata->local, sdata, &event);
 -		sdata_info(sdata, "associated\n");
 +		if (bss_conf->he_bss_color.enabled)
 +			changed |= BSS_CHANGED_HE_BSS_COLOR;
  
 -		/*
 -		 * destroy assoc_data afterwards, as otherwise an idle
 -		 * recalc after assoc_data is NULL but before associated
 -		 * is set can cause the interface to go idle
 -		 */
 -		ieee80211_destroy_assoc_data(sdata, ASSOC_SUCCESS);
 +		bss_conf->htc_trig_based_pkt_ext =
 +			le32_get_bits(elems->he_operation->he_oper_params,
 +			      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);
 +		bss_conf->frame_time_rts_th =
 +			le32_get_bits(elems->he_operation->he_oper_params,
 +			      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
  
 -		/* get uapsd queues configuration */
 -		resp.uapsd_queues = 0;
 -		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 -			if (sdata->deflink.tx_conf[ac].uapsd)
 -				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
 +		bss_conf->uora_exists = !!elems->uora_element;
 +		if (elems->uora_element)
 +			bss_conf->uora_ocw_range = elems->uora_element[0];
  
 -		info.success = 1;
 +		ieee80211_he_op_ie_to_bss_conf(&sdata->vif, elems->he_operation);
 +		ieee80211_he_spr_ie_to_bss_conf(&sdata->vif, elems->he_spr);
 +		/* TODO: OPEN: what happens if BSS color disable is set? */
  	}
  
 -	resp.links[0].bss = cbss;
 -	resp.buf = (u8 *)mgmt;
 -	resp.len = len;
 -	resp.req_ies = ifmgd->assoc_req_ies;
 -	resp.req_ies_len = ifmgd->assoc_req_ies_len;
 -	cfg80211_rx_assoc_resp(sdata->dev, &resp);
 -notify_driver:
 -	drv_mgd_complete_tx(sdata->local, sdata, &info);
 -	kfree(elems);
 -}
 -
 -static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
 -				  struct ieee80211_mgmt *mgmt, size_t len,
 -				  struct ieee80211_rx_status *rx_status)
 -{
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 -	struct ieee80211_local *local = sdata->local;
 -	struct ieee80211_bss *bss;
 -	struct ieee80211_channel *channel;
 +	if (cbss->transmitted_bss) {
 +		bss_conf->nontransmitted = true;
 +		ether_addr_copy(bss_conf->transmitter_bssid,
 +				cbss->transmitted_bss->bssid);
 +		bss_conf->bssid_indicator = cbss->max_bssid_indicator;
 +		bss_conf->bssid_index = cbss->bssid_index;
 +	} else {
 +		bss_conf->nontransmitted = false;
 +		memset(bss_conf->transmitter_bssid, 0,
 +		       sizeof(bss_conf->transmitter_bssid));
 +		bss_conf->bssid_indicator = 0;
 +		bss_conf->bssid_index = 0;
 +	}
  
 -	sdata_assert_lock(sdata);
 -
 -	channel = ieee80211_get_channel_khz(local->hw.wiphy,
 -					ieee80211_rx_status_to_khz(rx_status));
 -	if (!channel)
 -		return;
 -
 -	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
 -	if (bss) {
 -		link->conf->beacon_rate = bss->beacon_rate;
 -		ieee80211_rx_bss_put(local, bss);
 -	}
 -}
 -
 -
 -static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_link_data *link,
 -					 struct sk_buff *skb)
 -{
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 -	struct ieee80211_mgmt *mgmt = (void *)skb->data;
 -	struct ieee80211_if_managed *ifmgd;
 -	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
 -	struct ieee80211_channel *channel;
 -	size_t baselen, len = skb->len;
 -
 -	ifmgd = &sdata->u.mgd;
 -
 -	sdata_assert_lock(sdata);
 +	/*
 +	 * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data
 +	 * in their association response, so ignore that data for our own
 +	 * configuration. If it changed since the last beacon, we'll get the
 +	 * next beacon and update then.
 +	 */
  
  	/*
 -	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
 -	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
 -	 * a Probe Response frame [..], the Address 1 field of the Probe
 -	 * Response frame shall be set to the broadcast address [..]"
 -	 * So, on 6GHz band we should also accept broadcast responses.
 +	 * If an operating mode notification IE is present, override the
 +	 * NSS calculation (that would be done in rate_control_rate_init())
 +	 * and use the # of streams from that element.
  	 */
 -	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
 -					rx_status->freq);
 -	if (!channel)
 -		return;
 -
 -	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
 -	    (channel->band != NL80211_BAND_6GHZ ||
 -	     !is_broadcast_ether_addr(mgmt->da)))
 -		return; /* ignore ProbeResp to foreign address */
 -
 -	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
 -	if (baselen > len)
 -		return;
 -
 -	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
 +	if (elems->opmode_notif &&
 +	    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {
 +		u8 nss;
  
 -	if (ifmgd->associated &&
 -	    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))
 -		ieee80211_reset_ap_probe(sdata);
 -}
 +		nss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;
 +		nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
 +		nss += 1;
 +		sta->sta.rx_nss = nss;
 +	}
++=======
++	if (!ieee80211_assoc_config_link(&sdata->deflink, &sta->deflink,
++					 cbss, mgmt, elem_start, elem_len,
++					 &changed))
++		goto out_err;
++>>>>>>> 6911458dc428 (wifi: mac80211: mlme: refactor assoc success handling)
  
 -/*
 - * This is the canonical list of information elements we care about,
 - * the filter code also gives us all changes to the Microsoft OUI
 - * (00:50:F2) vendor IE which is used for WMM which we need to track,
 - * as well as the DTPC IE (part of the Cisco OUI) used for signaling
 - * changes to requested client power.
 - *
 - * We implement beacon filtering in software since that means we can
 - * avoid processing the frame here and in cfg80211, and userspace
 - * will not be able to tell whether the hardware supports it or not.
 - *
 - * XXX: This list needs to be dynamic -- userspace needs to be able to
 - *	add items it requires. It also needs to be able to tell us to
 - *	look out for other vendor IEs.
 - */
 -static const u64 care_about_ies =
 -	(1ULL << WLAN_EID_COUNTRY) |
 -	(1ULL << WLAN_EID_ERP_INFO) |
 -	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
 -	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
 -	(1ULL << WLAN_EID_HT_CAPABILITY) |
 -	(1ULL << WLAN_EID_HT_OPERATION) |
 -	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
 +	rate_control_rate_init(sta);
  
 -static void ieee80211_handle_beacon_sig(struct ieee80211_link_data *link,
 -					struct ieee80211_if_managed *ifmgd,
 -					struct ieee80211_bss_conf *bss_conf,
 -					struct ieee80211_local *local,
 -					struct ieee80211_rx_status *rx_status)
 -{
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 +	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
 +		set_sta_flag(sta, WLAN_STA_MFP);
 +		sta->sta.mfp = true;
 +	} else {
 +		sta->sta.mfp = false;
 +	}
  
 -	/* Track average RSSI from the Beacon frames of the current AP */
 +	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
 +		       local->hw.queues >= IEEE80211_NUM_ACS;
  
 -	if (!link->u.mgd.tracking_signal_avg) {
 -		link->u.mgd.tracking_signal_avg = true;
 -		ewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);
 -		link->u.mgd.last_cqm_event_signal = 0;
 -		link->u.mgd.count_beacon_signal = 1;
 -		link->u.mgd.last_ave_beacon_signal = 0;
 -	} else {
 -		link->u.mgd.count_beacon_signal++;
 +	err = sta_info_move_state(sta, IEEE80211_STA_ASSOC);
 +	if (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
 +		err = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);
 +	if (err) {
 +		sdata_info(sdata,
 +			   "failed to move station %pM to desired state\n",
 +			   sta->sta.addr);
 +		WARN_ON(__sta_info_destroy(sta));
- 		mutex_unlock(&sdata->local->sta_mtx);
- 		ret = false;
- 		goto out;
++		goto out_err;
  	}
  
 -	ewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,
 -			       -rx_status->signal);
 +	if (sdata->wdev.use_4addr)
 +		drv_sta_set_4addr(local, sdata, &sta->sta, true);
  
 -	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 -	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 -		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
 -		int last_sig = link->u.mgd.last_ave_beacon_signal;
 -		struct ieee80211_event event = {
 -			.type = RSSI_EVENT,
 -		};
 +	mutex_unlock(&sdata->local->sta_mtx);
  
 -		/*
 -		 * if signal crosses either of the boundaries, invoke callback
 -		 * with appropriate parameters
++<<<<<<< HEAD
 +	/*
 +	 * Always handle WMM once after association regardless
 +	 * of the first value the AP uses. Setting -1 here has
 +	 * that effect because the AP values is an unsigned
 +	 * 4-bit value.
 +	 */
 +	ifmgd->wmm_last_param_set = -1;
 +	ifmgd->mu_edca_last_param_set = -1;
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_WMM) {
 +		ieee80211_set_wmm_default(sdata, false, false);
 +	} else if (!ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
 +					     elems->wmm_param_len,
 +					     elems->mu_edca_param_set)) {
 +		/* still enable QoS since we might have HT/VHT */
 +		ieee80211_set_wmm_default(sdata, false, true);
 +		/* set the disable-WMM flag in this case to disable
 +		 * tracking WMM parameter changes in the beacon if
 +		 * the parameters weren't actually valid. Doing so
 +		 * avoids changing parameters very strangely when
 +		 * the AP is going back and forth between valid and
 +		 * invalid parameters.
  		 */
 -		if (sig > ifmgd->rssi_max_thold &&
 -		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
 -			link->u.mgd.last_ave_beacon_signal = sig;
 -			event.u.rssi.data = RSSI_EVENT_HIGH;
 -			drv_event_callback(local, sdata, &event);
 -		} else if (sig < ifmgd->rssi_min_thold &&
 -			   (last_sig >= ifmgd->rssi_max_thold ||
 -			   last_sig == 0)) {
 -			link->u.mgd.last_ave_beacon_signal = sig;
 -			event.u.rssi.data = RSSI_EVENT_LOW;
 -			drv_event_callback(local, sdata, &event);
 -		}
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_WMM;
  	}
 +	changed |= BSS_CHANGED_QOS;
  
 -	if (bss_conf->cqm_rssi_thold &&
 -	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
 -	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
 -		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
 -		int last_event = link->u.mgd.last_cqm_event_signal;
 -		int thold = bss_conf->cqm_rssi_thold;
 -		int hyst = bss_conf->cqm_rssi_hyst;
 -
 -		if (sig < thold &&
 -		    (last_event == 0 || sig < last_event - hyst)) {
 -			link->u.mgd.last_cqm_event_signal = sig;
 -			ieee80211_cqm_rssi_notify(
 -				&sdata->vif,
 -				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 -				sig, GFP_KERNEL);
 -		} else if (sig > thold &&
 -			   (last_event == 0 || sig > last_event + hyst)) {
 -			link->u.mgd.last_cqm_event_signal = sig;
 -			ieee80211_cqm_rssi_notify(
 -				&sdata->vif,
 -				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 -				sig, GFP_KERNEL);
 -		}
 +	if (elems->max_idle_period_ie) {
 +		bss_conf->max_idle_period =
 +			le16_to_cpu(elems->max_idle_period_ie->max_idle_period);
 +		bss_conf->protected_keep_alive =
 +			!!(elems->max_idle_period_ie->idle_options &
 +			   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);
 +		changed |= BSS_CHANGED_KEEP_ALIVE;
 +	} else {
 +		bss_conf->max_idle_period = 0;
 +		bss_conf->protected_keep_alive = false;
  	}
  
 -	if (bss_conf->cqm_rssi_low &&
 -	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 -		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
 -		int last_event = link->u.mgd.last_cqm_event_signal;
 -		int low = bss_conf->cqm_rssi_low;
 -		int high = bss_conf->cqm_rssi_high;
 +	/* set assoc capability (AID was already set earlier),
 +	 * ieee80211_set_associated() will tell the driver */
 +	bss_conf->assoc_capability = capab_info;
++=======
++>>>>>>> 6911458dc428 (wifi: mac80211: mlme: refactor assoc success handling)
 +	ieee80211_set_associated(sdata, cbss, changed);
  
 -		if (sig < low &&
 -		    (last_event == 0 || last_event >= low)) {
 -			link->u.mgd.last_cqm_event_signal = sig;
 -			ieee80211_cqm_rssi_notify(
 -				&sdata->vif,
 -				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 -				sig, GFP_KERNEL);
 -		} else if (sig > high &&
 -			   (last_event == 0 || last_event <= high)) {
 -			link->u.mgd.last_cqm_event_signal = sig;
 -			ieee80211_cqm_rssi_notify(
 -				&sdata->vif,
 -				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 -				sig, GFP_KERNEL);
 -		}
 -	}
 -}
 +	/*
 +	 * If we're using 4-addr mode, let the AP know that we're
 +	 * doing so, so that it can create the STA VLAN on its side
 +	 */
 +	if (ifmgd->use_4addr)
 +		ieee80211_send_4addr_nullfunc(local, sdata);
  
 -static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
 -				    struct cfg80211_bss *bss)
 -{
 -	if (ether_addr_equal(tx_bssid, bss->bssid))
 -		return true;
 -	if (!bss->transmitted_bss)
 -		return false;
 -	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
 +	/*
 +	 * Start timer to probe the connection to the AP now.
 +	 * Also start the timer that will detect beacon loss.
 +	 */
 +	ieee80211_sta_reset_beacon_monitor(sdata);
 +	ieee80211_sta_reset_conn_monitor(sdata);
 +
- 	ret = true;
-  out:
- 	kfree(bss_ies);
- 	return ret;
++	return true;
++out_err:
++	mutex_unlock(&sdata->local->sta_mtx);
++	return false;
  }
  
 -static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,
 -				     struct ieee80211_hdr *hdr, size_t len,
 -				     struct ieee80211_rx_status *rx_status)
 +static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
 +					 struct ieee80211_mgmt *mgmt,
 +					 size_t len)
  {
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 -	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 -	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
 -	struct ieee80211_mgmt *mgmt = (void *) hdr;
 -	size_t baselen;
 +	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
 +	u16 capab_info, status_code, aid;
  	struct ieee802_11_elems *elems;
 -	struct ieee80211_local *local = sdata->local;
 -	struct ieee80211_chanctx_conf *chanctx_conf;
 -	struct ieee80211_channel *chan;
 -	struct link_sta_info *link_sta;
 -	struct sta_info *sta;
 -	u32 changed = 0;
 -	bool erp_valid;
 -	u8 erp_value = 0;
 -	u32 ncrc = 0;
 -	u8 *bssid, *variable = mgmt->u.beacon.variable;
 -	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
++<<<<<<< HEAD
 +	int ac, uapsd_queues = -1;
 +	u8 *pos;
++=======
++	int ac;
++	const u8 *elem_start;
++	unsigned int elem_len;
++>>>>>>> 6911458dc428 (wifi: mac80211: mlme: refactor assoc success handling)
 +	bool reassoc;
 +	struct cfg80211_bss *cbss;
 +	struct ieee80211_event event = {
 +		.type = MLME_EVENT,
 +		.u.mlme.data = ASSOC_EVENT,
 +	};
 +	struct ieee80211_prep_tx_info info = {};
  
  	sdata_assert_lock(sdata);
  
 -	/* Process beacon from the current BSS */
 -	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
 -	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
 -		struct ieee80211_ext *ext = (void *) mgmt;
 +	if (!assoc_data)
 +		return;
  
 -		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
 -			variable = ext->u.s1g_short_beacon.variable;
 -		else
 -			variable = ext->u.s1g_beacon.variable;
 -	}
 -
 -	baselen = (u8 *) variable - (u8 *) mgmt;
 -	if (baselen > len)
 -		return;
 -
 -	rcu_read_lock();
 -	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
 -	if (!chanctx_conf) {
 -		rcu_read_unlock();
 -		return;
 -	}
 -
 -	if (ieee80211_rx_status_to_khz(rx_status) !=
 -	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
 -		rcu_read_unlock();
 +	if (!ether_addr_equal(assoc_data->bss->bssid, mgmt->bssid))
  		return;
 -	}
 -	chan = chanctx_conf->def.chan;
 -	rcu_read_unlock();
 -
 -	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
 -	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->bss)) {
 -		elems = ieee802_11_parse_elems(variable, len - baselen, false,
 -					       ifmgd->assoc_data->bss);
 -		if (!elems)
 -			return;
  
 -		ieee80211_rx_bss_info(link, mgmt, len, rx_status);
 +	cbss = assoc_data->bss;
  
 -		if (elems->dtim_period)
 -			link->u.mgd.dtim_period = elems->dtim_period;
 -		link->u.mgd.have_beacon = true;
 -		ifmgd->assoc_data->need_beacon = false;
 -		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
 -			link->conf->sync_tsf =
 -				le64_to_cpu(mgmt->u.beacon.timestamp);
 -			link->conf->sync_device_ts =
 -				rx_status->device_timestamp;
 -			link->conf->sync_dtim_count = elems->dtim_count;
 -		}
 +	/*
 +	 * AssocResp and ReassocResp have identical structure, so process both
 +	 * of them in this function.
 +	 */
  
 -		if (elems->mbssid_config_ie)
 -			bss_conf->profile_periodicity =
 -				elems->mbssid_config_ie->profile_periodicity;
 -		else
 -			bss_conf->profile_periodicity = 0;
 +	if (len < 24 + 6)
 +		return;
  
 -		if (elems->ext_capab_len >= 11 &&
 -		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
 -			bss_conf->ema_ap = true;
 -		else
 -			bss_conf->ema_ap = false;
 +	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
 +	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
 +	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
- 	pos = mgmt->u.assoc_resp.variable;
- 	aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
- 	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
- 		pos = (u8 *) mgmt->u.s1g_assoc_resp.variable;
- 		aid = 0; /* TODO */
- 	}
++	if (cbss->channel->band == NL80211_BAND_S1GHZ)
++		elem_start = mgmt->u.s1g_assoc_resp.variable;
++	else
++		elem_start = mgmt->u.assoc_resp.variable;
  
 -		/* continue assoc process */
 -		ifmgd->assoc_data->timeout = jiffies;
 -		ifmgd->assoc_data->timeout_started = true;
 -		run_again(sdata, ifmgd->assoc_data->timeout);
 -		kfree(elems);
 -		return;
 -	}
 +	/*
 +	 * Note: this may not be perfect, AP might misbehave - if
 +	 * anyone needs to rely on perfect complete notification
 +	 * with the exact right subtype, then we need to track what
 +	 * we actually transmitted.
 +	 */
 +	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
 +				 IEEE80211_STYPE_ASSOC_REQ;
  
- 	sdata_info(sdata,
- 		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
- 		   reassoc ? "Rea" : "A", mgmt->sa,
- 		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
- 
 -	if (!ifmgd->associated ||
 -	    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))
 +	if (assoc_data->fils_kek_len &&
 +	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
  		return;
 -	bssid = link->u.mgd.bssid;
  
- 	elems = ieee802_11_parse_elems(pos, len - (pos - (u8 *)mgmt), false,
- 				       assoc_data->bss);
 -	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
 -		ieee80211_handle_beacon_sig(link, ifmgd, bss_conf,
 -					    local, rx_status);
++	elem_len = len - (elem_start - (u8 *)mgmt);
++	elems = ieee802_11_parse_elems(elem_start, elem_len, false, NULL);
 +	if (!elems)
 +		goto notify_driver;
  
 -	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
 -		mlme_dbg_ratelimited(sdata,
 -				     "cancelling AP probe due to a received beacon\n");
 -		ieee80211_reset_ap_probe(sdata);
 -	}
++	if (elems->aid_resp)
++		aid = le16_to_cpu(elems->aid_resp->aid);
++	else if (cbss->channel->band == NL80211_BAND_S1GHZ)
++		aid = 0; /* TODO */
++	else
++		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+ 
+ 	/*
 -	 * Push the beacon loss detection into the future since
 -	 * we are processing a beacon from the AP just now.
++	 * The 5 MSB of the AID field are reserved
++	 * (802.11-2016 9.4.1.8 AID field)
+ 	 */
 -	ieee80211_sta_reset_beacon_monitor(sdata);
++	aid &= 0x7ff;
+ 
 -	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
 -	 * element (which carries the beacon interval). Don't forget to add a
 -	 * bit to care_about_ies[] above if mac80211 is interested in a
 -	 * changing S1G element.
 -	 */
 -	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
 -		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
 -	elems = ieee802_11_parse_elems_crc(variable, len - baselen,
 -					   false, care_about_ies, ncrc,
 -					   link->u.mgd.bss);
 -	if (!elems)
 -		return;
 -	ncrc = elems->crc;
++	sdata_info(sdata,
++		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
++		   reassoc ? "Rea" : "A", mgmt->sa,
++		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
+ 
 -	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
 -	    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {
 -		if (local->hw.conf.dynamic_ps_timeout > 0) {
 -			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
 -				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
 -				ieee80211_hw_config(local,
 -						    IEEE80211_CONF_CHANGE_PS);
 -			}
 -			ieee80211_send_nullfunc(local, sdata, false);
 -		} else if (!local->pspolling && sdata->u.mgd.powersave) {
 -			local->pspolling = true;
++	ifmgd->broken_ap = false;
+ 
 -			/*
 -			 * Here is assumed that the driver will be
 -			 * able to send ps-poll frame and receive a
 -			 * response even though power save mode is
 -			 * enabled, but some drivers might require
 -			 * to disable power save here. This needs
 -			 * to be investigated.
 -			 */
 -			ieee80211_send_pspoll(local, sdata);
 -		}
 -	}
 +	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
 +	    elems->timeout_int &&
 +	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
 +		u32 tu, ms;
  
 -	if (sdata->vif.p2p ||
 -	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
 -		struct ieee80211_p2p_noa_attr noa = {};
 -		int ret;
 +		cfg80211_assoc_comeback(sdata->dev, assoc_data->bss->bssid,
 +					le32_to_cpu(elems->timeout_int->value));
  
 -		ret = cfg80211_get_p2p_attr(variable,
 -					    len - baselen,
 -					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
 -					    (u8 *) &noa, sizeof(noa));
 -		if (ret >= 2) {
 -			if (link->u.mgd.p2p_noa_index != noa.index) {
 -				/* valid noa_attr and index changed */
 -				link->u.mgd.p2p_noa_index = noa.index;
 -				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
 -				changed |= BSS_CHANGED_P2P_PS;
 -				/*
 -				 * make sure we update all information, the CRC
 -				 * mechanism doesn't look at P2P attributes.
 -				 */
 -				link->u.mgd.beacon_crc_valid = false;
 -			}
 -		} else if (link->u.mgd.p2p_noa_index != -1) {
 -			/* noa_attr not found and we had valid noa_attr before */
 -			link->u.mgd.p2p_noa_index = -1;
 -			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
 -			changed |= BSS_CHANGED_P2P_PS;
 -			link->u.mgd.beacon_crc_valid = false;
 -		}
 +		tu = le32_to_cpu(elems->timeout_int->value);
 +		ms = tu * 1024 / 1000;
 +		sdata_info(sdata,
 +			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
 +			   mgmt->sa, tu, ms);
 +		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
 +		assoc_data->timeout_started = true;
 +		if (ms > IEEE80211_ASSOC_TIMEOUT)
 +			run_again(sdata, assoc_data->timeout);
 +		goto notify_driver;
  	}
  
 -	if (link->u.mgd.csa_waiting_bcn)
 -		ieee80211_chswitch_post_beacon(link);
 -
 -	/*
 -	 * Update beacon timing and dtim count on every beacon appearance. This
 -	 * will allow the driver to use the most updated values. Do it before
 -	 * comparing this one with last received beacon.
 -	 * IMPORTANT: These parameters would possibly be out of sync by the time
 -	 * the driver will use them. The synchronized view is currently
 -	 * guaranteed only in certain callbacks.
 -	 */
 -	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
 -	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
 -		link->conf->sync_tsf =
 -			le64_to_cpu(mgmt->u.beacon.timestamp);
 -		link->conf->sync_device_ts =
 -			rx_status->device_timestamp;
 -		link->conf->sync_dtim_count = elems->dtim_count;
 -	}
 +	if (status_code != WLAN_STATUS_SUCCESS) {
 +		sdata_info(sdata, "%pM denied association (code=%d)\n",
 +			   mgmt->sa, status_code);
 +		ieee80211_destroy_assoc_data(sdata, ASSOC_REJECTED);
 +		event.u.mlme.status = MLME_DENIED;
 +		event.u.mlme.reason = status_code;
 +		drv_event_callback(sdata->local, sdata, &event);
 +	} else {
- 		if (!ieee80211_assoc_success(sdata, cbss, mgmt, len, elems)) {
++		if (aid == 0 || aid > IEEE80211_MAX_AID) {
++			sdata_info(sdata,
++				   "invalid AID value %d (out of range), turn off PS\n",
++				   aid);
++			aid = 0;
++			ifmgd->broken_ap = true;
++		}
+ 
 -	if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||
 -	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
 -		goto free;
 -	link->u.mgd.beacon_crc = ncrc;
 -	link->u.mgd.beacon_crc_valid = true;
++		sdata->vif.cfg.aid = aid;
+ 
 -	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
++		if (!ieee80211_assoc_success(sdata, cbss, mgmt, elems,
++					     elem_start, elem_len)) {
 +			/* oops -- internal error -- send timeout for now */
 +			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
 +			goto notify_driver;
 +		}
 +		event.u.mlme.status = MLME_SUCCESS;
 +		drv_event_callback(sdata->local, sdata, &event);
 +		sdata_info(sdata, "associated\n");
  
 -	ieee80211_sta_process_chanswitch(link, rx_status->mactime,
 -					 rx_status->device_timestamp,
 -					 elems, true);
 +		/*
 +		 * destroy assoc_data afterwards, as otherwise an idle
 +		 * recalc after assoc_data is NULL but before associated
 +		 * is set can cause the interface to go idle
 +		 */
 +		ieee80211_destroy_assoc_data(sdata, ASSOC_SUCCESS);
  
 -	if (!link->u.mgd.disable_wmm_tracking &&
 -	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
 -				     elems->wmm_param_len,
 -				     elems->mu_edca_param_set))
 -		changed |= BSS_CHANGED_QOS;
 +		/* get uapsd queues configuration */
 +		uapsd_queues = 0;
 +		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 +			if (sdata->tx_conf[ac].uapsd)
 +				uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
  
 -	/*
 -	 * If we haven't had a beacon before, tell the driver about the
 -	 * DTIM period (and beacon timing if desired) now.
 -	 */
 -	if (!link->u.mgd.have_beacon) {
 -		/* a few bogus AP send dtim_period = 0 or no TIM IE */
 -		bss_conf->dtim_period = elems->dtim_period ?: 1;
 +		info.success = 1;
 +	}
  
 -		changed |= BSS_CHANGED_BEACON_INFO;
 -		link->u.mgd.have_beacon = true;
 +	cfg80211_rx_assoc_resp(sdata->dev, cbss, (u8 *)mgmt, len, uapsd_queues,
 +			       ifmgd->assoc_req_ies, ifmgd->assoc_req_ies_len);
 +notify_driver:
 +	drv_mgd_complete_tx(sdata->local, sdata, &info);
 +	kfree(elems);
 +}
  
 -		mutex_lock(&local->iflist_mtx);
 -		ieee80211_recalc_ps(local);
 -		mutex_unlock(&local->iflist_mtx);
 +static void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,
 +				  struct ieee80211_mgmt *mgmt, size_t len,
 +				  struct ieee80211_rx_status *rx_status)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_bss *bss;
 +	struct ieee80211_channel *channel;
  
 -		ieee80211_recalc_ps_vif(sdata);
 -	}
 +	sdata_assert_lock(sdata);
 +
 +	channel = ieee80211_get_channel_khz(local->hw.wiphy,
 +					ieee80211_rx_status_to_khz(rx_status));
 +	if (!channel)
 +		return;
 +
 +	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
 +	if (bss) {
 +		sdata->vif.bss_conf.beacon_rate = bss->beacon_rate;
 +		ieee80211_rx_bss_put(local, bss);
 +	}
 +}
 +
 +
 +static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_sub_if_data *sdata,
 +					 struct sk_buff *skb)
 +{
 +	struct ieee80211_mgmt *mgmt = (void *)skb->data;
 +	struct ieee80211_if_managed *ifmgd;
 +	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
 +	struct ieee80211_channel *channel;
 +	size_t baselen, len = skb->len;
 +
 +	ifmgd = &sdata->u.mgd;
 +
 +	sdata_assert_lock(sdata);
 +
 +	/*
 +	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
 +	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
 +	 * a Probe Response frame [..], the Address 1 field of the Probe
 +	 * Response frame shall be set to the broadcast address [..]"
 +	 * So, on 6GHz band we should also accept broadcast responses.
 +	 */
 +	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
 +					rx_status->freq);
 +	if (!channel)
 +		return;
 +
 +	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
 +	    (channel->band != NL80211_BAND_6GHZ ||
 +	     !is_broadcast_ether_addr(mgmt->da)))
 +		return; /* ignore ProbeResp to foreign address */
 +
 +	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
 +	if (baselen > len)
 +		return;
 +
 +	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
 +
 +	if (ifmgd->associated &&
 +	    ether_addr_equal(mgmt->bssid, ifmgd->bssid))
 +		ieee80211_reset_ap_probe(sdata);
 +}
 +
 +/*
 + * This is the canonical list of information elements we care about,
 + * the filter code also gives us all changes to the Microsoft OUI
 + * (00:50:F2) vendor IE which is used for WMM which we need to track,
 + * as well as the DTPC IE (part of the Cisco OUI) used for signaling
 + * changes to requested client power.
 + *
 + * We implement beacon filtering in software since that means we can
 + * avoid processing the frame here and in cfg80211, and userspace
 + * will not be able to tell whether the hardware supports it or not.
 + *
 + * XXX: This list needs to be dynamic -- userspace needs to be able to
 + *	add items it requires. It also needs to be able to tell us to
 + *	look out for other vendor IEs.
 + */
 +static const u64 care_about_ies =
 +	(1ULL << WLAN_EID_COUNTRY) |
 +	(1ULL << WLAN_EID_ERP_INFO) |
 +	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
 +	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
 +	(1ULL << WLAN_EID_HT_CAPABILITY) |
 +	(1ULL << WLAN_EID_HT_OPERATION) |
 +	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
 +
 +static void ieee80211_handle_beacon_sig(struct ieee80211_sub_if_data *sdata,
 +					struct ieee80211_if_managed *ifmgd,
 +					struct ieee80211_bss_conf *bss_conf,
 +					struct ieee80211_local *local,
 +					struct ieee80211_rx_status *rx_status)
 +{
 +	/* Track average RSSI from the Beacon frames of the current AP */
 +
 +	if (ifmgd->flags & IEEE80211_STA_RESET_SIGNAL_AVE) {
 +		ifmgd->flags &= ~IEEE80211_STA_RESET_SIGNAL_AVE;
 +		ewma_beacon_signal_init(&ifmgd->ave_beacon_signal);
 +		ifmgd->last_cqm_event_signal = 0;
 +		ifmgd->count_beacon_signal = 1;
 +		ifmgd->last_ave_beacon_signal = 0;
 +	} else {
 +		ifmgd->count_beacon_signal++;
 +	}
 +
 +	ewma_beacon_signal_add(&ifmgd->ave_beacon_signal, -rx_status->signal);
 +
 +	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_sig = ifmgd->last_ave_beacon_signal;
 +		struct ieee80211_event event = {
 +			.type = RSSI_EVENT,
 +		};
 +
 +		/*
 +		 * if signal crosses either of the boundaries, invoke callback
 +		 * with appropriate parameters
 +		 */
 +		if (sig > ifmgd->rssi_max_thold &&
 +		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
 +			ifmgd->last_ave_beacon_signal = sig;
 +			event.u.rssi.data = RSSI_EVENT_HIGH;
 +			drv_event_callback(local, sdata, &event);
 +		} else if (sig < ifmgd->rssi_min_thold &&
 +			   (last_sig >= ifmgd->rssi_max_thold ||
 +			   last_sig == 0)) {
 +			ifmgd->last_ave_beacon_signal = sig;
 +			event.u.rssi.data = RSSI_EVENT_LOW;
 +			drv_event_callback(local, sdata, &event);
 +		}
 +	}
 +
 +	if (bss_conf->cqm_rssi_thold &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
 +	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_event = ifmgd->last_cqm_event_signal;
 +		int thold = bss_conf->cqm_rssi_thold;
 +		int hyst = bss_conf->cqm_rssi_hyst;
 +
 +		if (sig < thold &&
 +		    (last_event == 0 || sig < last_event - hyst)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 +				sig, GFP_KERNEL);
 +		} else if (sig > thold &&
 +			   (last_event == 0 || sig > last_event + hyst)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 +				sig, GFP_KERNEL);
 +		}
 +	}
 +
 +	if (bss_conf->cqm_rssi_low &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_event = ifmgd->last_cqm_event_signal;
 +		int low = bss_conf->cqm_rssi_low;
 +		int high = bss_conf->cqm_rssi_high;
 +
 +		if (sig < low &&
 +		    (last_event == 0 || last_event >= low)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 +				sig, GFP_KERNEL);
 +		} else if (sig > high &&
 +			   (last_event == 0 || last_event <= high)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 +				sig, GFP_KERNEL);
 +		}
 +	}
 +}
 +
 +static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
 +				    struct cfg80211_bss *bss)
 +{
 +	if (ether_addr_equal(tx_bssid, bss->bssid))
 +		return true;
 +	if (!bss->transmitted_bss)
 +		return false;
 +	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
 +}
 +
 +static void ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
 +				     struct ieee80211_hdr *hdr, size_t len,
 +				     struct ieee80211_rx_status *rx_status)
 +{
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +	struct ieee80211_mgmt *mgmt = (void *) hdr;
 +	size_t baselen;
 +	struct ieee802_11_elems *elems;
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_chanctx_conf *chanctx_conf;
 +	struct ieee80211_channel *chan;
 +	struct sta_info *sta;
 +	u32 changed = 0;
 +	bool erp_valid;
 +	u8 erp_value = 0;
 +	u32 ncrc = 0;
 +	u8 *bssid, *variable = mgmt->u.beacon.variable;
 +	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
 +
 +	sdata_assert_lock(sdata);
 +
 +	/* Process beacon from the current BSS */
 +	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
 +	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
 +		struct ieee80211_ext *ext = (void *) mgmt;
 +
 +		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
 +			variable = ext->u.s1g_short_beacon.variable;
 +		else
 +			variable = ext->u.s1g_beacon.variable;
 +	}
 +
 +	baselen = (u8 *) variable - (u8 *) mgmt;
 +	if (baselen > len)
 +		return;
 +
 +	rcu_read_lock();
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 +	if (!chanctx_conf) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +
 +	if (ieee80211_rx_status_to_khz(rx_status) !=
 +	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +	chan = chanctx_conf->def.chan;
 +	rcu_read_unlock();
 +
 +	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
 +	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->bss)) {
 +		elems = ieee802_11_parse_elems(variable, len - baselen, false,
 +					       ifmgd->assoc_data->bss);
 +		if (!elems)
 +			return;
 +
 +		ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
 +
 +		if (elems->dtim_period)
 +			ifmgd->dtim_period = elems->dtim_period;
 +		ifmgd->have_beacon = true;
 +		ifmgd->assoc_data->need_beacon = false;
 +		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
 +			sdata->vif.bss_conf.sync_tsf =
 +				le64_to_cpu(mgmt->u.beacon.timestamp);
 +			sdata->vif.bss_conf.sync_device_ts =
 +				rx_status->device_timestamp;
 +			sdata->vif.bss_conf.sync_dtim_count = elems->dtim_count;
 +		}
 +
 +		if (elems->mbssid_config_ie)
 +			bss_conf->profile_periodicity =
 +				elems->mbssid_config_ie->profile_periodicity;
 +		else
 +			bss_conf->profile_periodicity = 0;
 +
 +		if (elems->ext_capab_len >= 11 &&
 +		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
 +			bss_conf->ema_ap = true;
 +		else
 +			bss_conf->ema_ap = false;
 +
 +		/* continue assoc process */
 +		ifmgd->assoc_data->timeout = jiffies;
 +		ifmgd->assoc_data->timeout_started = true;
 +		run_again(sdata, ifmgd->assoc_data->timeout);
 +		kfree(elems);
 +		return;
 +	}
 +
 +	if (!ifmgd->associated ||
 +	    !ieee80211_rx_our_beacon(bssid, ifmgd->assoc_bss))
 +		return;
 +	bssid = ifmgd->bssid;
 +
 +	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
 +		ieee80211_handle_beacon_sig(sdata, ifmgd, bss_conf,
 +					    local, rx_status);
 +
 +	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
 +		mlme_dbg_ratelimited(sdata,
 +				     "cancelling AP probe due to a received beacon\n");
 +		ieee80211_reset_ap_probe(sdata);
 +	}
 +
 +	/*
 +	 * Push the beacon loss detection into the future since
 +	 * we are processing a beacon from the AP just now.
 +	 */
 +	ieee80211_sta_reset_beacon_monitor(sdata);
 +
 +	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
 +	 * element (which carries the beacon interval). Don't forget to add a
 +	 * bit to care_about_ies[] above if mac80211 is interested in a
 +	 * changing S1G element.
 +	 */
 +	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
 +		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
 +	elems = ieee802_11_parse_elems_crc(variable, len - baselen,
 +					   false, care_about_ies, ncrc,
 +					   link->u.mgd.bss);
 +	if (!elems)
 +		return;
 +	ncrc = elems->crc;
 +
 +	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
 +	    ieee80211_check_tim(elems->tim, elems->tim_len, bss_conf->aid)) {
 +		if (local->hw.conf.dynamic_ps_timeout > 0) {
 +			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
 +				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
 +				ieee80211_hw_config(local,
 +						    IEEE80211_CONF_CHANGE_PS);
 +			}
 +			ieee80211_send_nullfunc(local, sdata, false);
 +		} else if (!local->pspolling && sdata->u.mgd.powersave) {
 +			local->pspolling = true;
 +
 +			/*
 +			 * Here is assumed that the driver will be
 +			 * able to send ps-poll frame and receive a
 +			 * response even though power save mode is
 +			 * enabled, but some drivers might require
 +			 * to disable power save here. This needs
 +			 * to be investigated.
 +			 */
 +			ieee80211_send_pspoll(local, sdata);
 +		}
 +	}
 +
 +	if (sdata->vif.p2p ||
 +	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
 +		struct ieee80211_p2p_noa_attr noa = {};
 +		int ret;
 +
 +		ret = cfg80211_get_p2p_attr(variable,
 +					    len - baselen,
 +					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
 +					    (u8 *) &noa, sizeof(noa));
 +		if (ret >= 2) {
 +			if (sdata->u.mgd.p2p_noa_index != noa.index) {
 +				/* valid noa_attr and index changed */
 +				sdata->u.mgd.p2p_noa_index = noa.index;
 +				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
 +				changed |= BSS_CHANGED_P2P_PS;
 +				/*
 +				 * make sure we update all information, the CRC
 +				 * mechanism doesn't look at P2P attributes.
 +				 */
 +				ifmgd->beacon_crc_valid = false;
 +			}
 +		} else if (sdata->u.mgd.p2p_noa_index != -1) {
 +			/* noa_attr not found and we had valid noa_attr before */
 +			sdata->u.mgd.p2p_noa_index = -1;
 +			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
 +			changed |= BSS_CHANGED_P2P_PS;
 +			ifmgd->beacon_crc_valid = false;
 +		}
 +	}
 +
 +	if (ifmgd->csa_waiting_bcn)
 +		ieee80211_chswitch_post_beacon(sdata);
 +
 +	/*
 +	 * Update beacon timing and dtim count on every beacon appearance. This
 +	 * will allow the driver to use the most updated values. Do it before
 +	 * comparing this one with last received beacon.
 +	 * IMPORTANT: These parameters would possibly be out of sync by the time
 +	 * the driver will use them. The synchronized view is currently
 +	 * guaranteed only in certain callbacks.
 +	 */
 +	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
 +	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
 +		sdata->vif.bss_conf.sync_tsf =
 +			le64_to_cpu(mgmt->u.beacon.timestamp);
 +		sdata->vif.bss_conf.sync_device_ts =
 +			rx_status->device_timestamp;
 +		sdata->vif.bss_conf.sync_dtim_count = elems->dtim_count;
 +	}
 +
 +	if ((ncrc == ifmgd->beacon_crc && ifmgd->beacon_crc_valid) ||
 +	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
 +		goto free;
 +	ifmgd->beacon_crc = ncrc;
 +	ifmgd->beacon_crc_valid = true;
 +
 +	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
 +
 +	ieee80211_sta_process_chanswitch(sdata, rx_status->mactime,
 +					 rx_status->device_timestamp,
 +					 elems, true);
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_WMM) &&
 +	    ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
 +				     elems->wmm_param_len,
 +				     elems->mu_edca_param_set))
 +		changed |= BSS_CHANGED_QOS;
 +
 +	/*
 +	 * If we haven't had a beacon before, tell the driver about the
 +	 * DTIM period (and beacon timing if desired) now.
 +	 */
 +	if (!ifmgd->have_beacon) {
 +		/* a few bogus AP send dtim_period = 0 or no TIM IE */
 +		bss_conf->dtim_period = elems->dtim_period ?: 1;
 +
 +		changed |= BSS_CHANGED_BEACON_INFO;
 +		ifmgd->have_beacon = true;
 +
 +		mutex_lock(&local->iflist_mtx);
 +		ieee80211_recalc_ps(local);
 +		mutex_unlock(&local->iflist_mtx);
 +
 +		ieee80211_recalc_ps_vif(sdata);
 +	}
  
  	if (elems->erp_info) {
  		erp_valid = true;
* Unmerged path net/mac80211/mlme.c
