net: don't allow user space to lift the device limits

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 14d7b8122fd591693a2388b98563707ba72c6780
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/14d7b812.failed

Up until commit 46e6b992c250 ("rtnetlink: allow GSO maximums to
be set on device creation") the gso_max_segs and gso_max_size
of a device were not controlled from user space.

The quoted commit added the ability to control them because of
the following setup:

 netns A  |  netns B
     veth<->veth   eth0

If eth0 has TSO limitations and user wants to efficiently forward
traffic between eth0 and the veths they should copy the TSO
limitations of eth0 onto the veths. This would happen automatically
for macvlans or ipvlan but veth users are not so lucky (given the
loose coupling).

Unfortunately the commit in question allowed users to also override
the limits on real HW devices.

It may be useful to control the max GSO size and someone may be using
that ability (not that I know of any user), so create a separate set
of knobs to reliably record the TSO limitations. Validate the user
requests.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 14d7b8122fd591693a2388b98563707ba72c6780)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index 379d8bad852d,e12f7de6d6ae..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -5047,6 -4895,18 +5054,21 @@@ static inline void netif_set_gso_max_se
  	WRITE_ONCE(dev->gso_max_segs, segs);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void netif_set_gro_max_size(struct net_device *dev,
+ 					  unsigned int size)
+ {
+ 	/* This pairs with the READ_ONCE() in skb_gro_receive() */
+ 	WRITE_ONCE(dev->gro_max_size, size);
+ }
+ 
+ void netif_set_tso_max_size(struct net_device *dev, unsigned int size);
+ void netif_set_tso_max_segs(struct net_device *dev, unsigned int segs);
+ void netif_inherit_tso_max(struct net_device *to,
+ 			   const struct net_device *from);
+ 
++>>>>>>> 14d7b8122fd5 (net: don't allow user space to lift the device limits)
  static inline void skb_gso_error_unwind(struct sk_buff *skb, __be16 protocol,
  					int pulled_hlen, u16 mac_offset,
  					int mac_len)
diff --cc net/core/dev.c
index 60f0f5f733c1,6ae085b11373..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -3072,10 -2993,55 +3072,58 @@@ undo_rx
  EXPORT_SYMBOL(netif_set_real_num_queues);
  
  /**
++<<<<<<< HEAD
++=======
+  * netif_set_tso_max_size() - set the max size of TSO frames supported
+  * @dev:	netdev to update
+  * @size:	max skb->len of a TSO frame
+  *
+  * Set the limit on the size of TSO super-frames the device can handle.
+  * Unless explicitly set the stack will assume the value of %GSO_MAX_SIZE.
+  */
+ void netif_set_tso_max_size(struct net_device *dev, unsigned int size)
+ {
+ 	dev->tso_max_size = size;
+ 	if (size < READ_ONCE(dev->gso_max_size))
+ 		netif_set_gso_max_size(dev, size);
+ }
+ EXPORT_SYMBOL(netif_set_tso_max_size);
+ 
+ /**
+  * netif_set_tso_max_segs() - set the max number of segs supported for TSO
+  * @dev:	netdev to update
+  * @segs:	max number of TCP segments
+  *
+  * Set the limit on the number of TCP segments the device can generate from
+  * a single TSO super-frame.
+  * Unless explicitly set the stack will assume the value of %GSO_MAX_SEGS.
+  */
+ void netif_set_tso_max_segs(struct net_device *dev, unsigned int segs)
+ {
+ 	dev->tso_max_segs = segs;
+ 	if (segs < READ_ONCE(dev->gso_max_segs))
+ 		netif_set_gso_max_segs(dev, segs);
+ }
+ EXPORT_SYMBOL(netif_set_tso_max_segs);
+ 
+ /**
+  * netif_inherit_tso_max() - copy all TSO limits from a lower device to an upper
+  * @to:		netdev to update
+  * @from:	netdev from which to copy the limits
+  */
+ void netif_inherit_tso_max(struct net_device *to, const struct net_device *from)
+ {
+ 	netif_set_gso_max_size(to, from->gso_max_size);
+ 	netif_set_gso_max_segs(to, from->gso_max_segs);
+ }
+ EXPORT_SYMBOL(netif_inherit_tso_max);
+ 
+ /**
++>>>>>>> 14d7b8122fd5 (net: don't allow user space to lift the device limits)
   * netif_get_num_default_rss_queues - default number of RSS queues
   *
 - * Default value is the number of physical cores if there are only 1 or 2, or
 - * divided by 2 if there are more.
 + * This routine should set an upper limit on the number of RSS queues
 + * used by default by multiqueue devices.
   */
  int netif_get_num_default_rss_queues(void)
  {
@@@ -10605,8 -10604,15 +10653,14 @@@ struct net_device *alloc_netdev_mqs(in
  
  	dev->gso_max_size = GSO_MAX_SIZE;
  	dev->gso_max_segs = GSO_MAX_SEGS;
++<<<<<<< HEAD
++=======
+ 	dev->gro_max_size = GRO_MAX_SIZE;
+ 	dev->tso_max_size = TSO_LEGACY_MAX_SIZE;
+ 	dev->tso_max_segs = TSO_MAX_SEGS;
++>>>>>>> 14d7b8122fd5 (net: don't allow user space to lift the device limits)
  	dev->upper_level = 1;
  	dev->lower_level = 1;
 -#ifdef CONFIG_LOCKDEP
 -	dev->nested_level = 0;
 -	INIT_LIST_HEAD(&dev->unlink_list);
 -#endif
  
  	INIT_LIST_HEAD(&dev->napi_list);
  	INIT_LIST_HEAD(&dev->unreg_list);
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 0a8ebe9b4f01..36bffcbc49a3 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -2669,7 +2669,7 @@ static int do_setlink(const struct sk_buff *skb,
 	if (tb[IFLA_GSO_MAX_SIZE]) {
 		u32 max_size = nla_get_u32(tb[IFLA_GSO_MAX_SIZE]);
 
-		if (max_size > GSO_MAX_SIZE) {
+		if (max_size > GSO_MAX_SIZE || max_size > dev->tso_max_size) {
 			err = -EINVAL;
 			goto errout;
 		}
@@ -2683,7 +2683,7 @@ static int do_setlink(const struct sk_buff *skb,
 	if (tb[IFLA_GSO_MAX_SEGS]) {
 		u32 max_segs = nla_get_u32(tb[IFLA_GSO_MAX_SEGS]);
 
-		if (max_segs > GSO_MAX_SEGS) {
+		if (max_segs > GSO_MAX_SEGS || max_segs > dev->tso_max_segs) {
 			err = -EINVAL;
 			goto errout;
 		}
