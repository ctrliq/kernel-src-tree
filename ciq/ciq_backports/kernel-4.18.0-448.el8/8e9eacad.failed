mptcp: fix msk traversal in mptcp_nl_cmd_set_flags()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 8e9eacad7ec7a9cbf262649ebf1fa6e6f6cc7d82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8e9eacad.failed

The MPTCP endpoint list is under RCU protection, guarded by the
pernet spinlock. mptcp_nl_cmd_set_flags() traverses the list
without acquiring the spin-lock nor under the RCU critical section.

This change addresses the issue performing the lookup and the endpoint
update under the pernet spinlock.

Fixes: 0f9f696a502e ("mptcp: add set_flags command in PM netlink")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 8e9eacad7ec7a9cbf262649ebf1fa6e6f6cc7d82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/pm_netlink.c
index 3dd5d2e8b1f9,f17a09f7fbf9..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -461,6 -466,49 +461,52 @@@ static unsigned int fill_remote_address
  	return i;
  }
  
++<<<<<<< HEAD
++=======
+ static struct mptcp_pm_addr_entry *
+ __lookup_addr_by_id(struct pm_nl_pernet *pernet, unsigned int id)
+ {
+ 	struct mptcp_pm_addr_entry *entry;
+ 
+ 	list_for_each_entry(entry, &pernet->local_addr_list, list) {
+ 		if (entry->addr.id == id)
+ 			return entry;
+ 	}
+ 	return NULL;
+ }
+ 
+ static struct mptcp_pm_addr_entry *
+ __lookup_addr(struct pm_nl_pernet *pernet, const struct mptcp_addr_info *info,
+ 	      bool lookup_by_id)
+ {
+ 	struct mptcp_pm_addr_entry *entry;
+ 
+ 	list_for_each_entry(entry, &pernet->local_addr_list, list) {
+ 		if ((!lookup_by_id && addresses_equal(&entry->addr, info, true)) ||
+ 		    (lookup_by_id && entry->addr.id == info->id))
+ 			return entry;
+ 	}
+ 	return NULL;
+ }
+ 
+ static int
+ lookup_id_by_addr(struct pm_nl_pernet *pernet, const struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_addr_entry *entry;
+ 	int ret = -1;
+ 
+ 	rcu_read_lock();
+ 	list_for_each_entry(entry, &pernet->local_addr_list, list) {
+ 		if (addresses_equal(&entry->addr, addr, entry->addr.port)) {
+ 			ret = entry->addr.id;
+ 			break;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ 
++>>>>>>> 8e9eacad7ec7 (mptcp: fix msk traversal in mptcp_nl_cmd_set_flags())
  static void mptcp_pm_create_subflow_or_signal_addr(struct mptcp_sock *msk)
  {
  	struct sock *sk = (struct sock *)msk;
@@@ -1691,18 -1771,27 +1737,34 @@@ static int mptcp_nl_cmd_set_flags(struc
  
  	if (addr.flags & MPTCP_PM_ADDR_FLAG_BACKUP)
  		bkup = 1;
 -	if (addr.addr.family == AF_UNSPEC) {
 -		lookup_by_id = 1;
 -		if (!addr.addr.id)
 -			return -EOPNOTSUPP;
 -	}
  
++<<<<<<< HEAD
 +	list_for_each_entry(entry, &pernet->local_addr_list, list) {
 +		if (addresses_equal(&entry->addr, &addr.addr, true)) {
 +			mptcp_nl_addr_backup(net, &entry->addr, bkup);
 +
 +			if (bkup)
 +				entry->flags |= MPTCP_PM_ADDR_FLAG_BACKUP;
 +			else
 +				entry->flags &= ~MPTCP_PM_ADDR_FLAG_BACKUP;
 +		}
++=======
+ 	spin_lock_bh(&pernet->lock);
+ 	entry = __lookup_addr(pernet, &addr.addr, lookup_by_id);
+ 	if (!entry) {
+ 		spin_unlock_bh(&pernet->lock);
+ 		return -EINVAL;
++>>>>>>> 8e9eacad7ec7 (mptcp: fix msk traversal in mptcp_nl_cmd_set_flags())
  	}
  
+ 	if (bkup)
+ 		entry->flags |= MPTCP_PM_ADDR_FLAG_BACKUP;
+ 	else
+ 		entry->flags &= ~MPTCP_PM_ADDR_FLAG_BACKUP;
+ 	addr = *entry;
+ 	spin_unlock_bh(&pernet->lock);
+ 
+ 	mptcp_nl_addr_backup(net, &addr.addr, bkup);
  	return 0;
  }
  
* Unmerged path net/mptcp/pm_netlink.c
