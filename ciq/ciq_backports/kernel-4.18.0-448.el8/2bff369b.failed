bonding: netlink error message support for options

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jonathan Toppins <jtoppins@redhat.com>
commit 2bff369b23542ea22d0111aaa8e0b8208bf0dc96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2bff369b.failed

Add support for reporting errors via extack in both bond_newlink
and bond_changelink.

Instead of having to look in the kernel log for why an option was not
correct just report the error to the user via the extack variable.

What is currently reported today:
  ip link add bond0 type bond
  ip link set bond0 up
  ip link set bond0 type bond mode 4
 RTNETLINK answers: Device or resource busy

After this change:
  ip link add bond0 type bond
  ip link set bond0 up
  ip link set bond0 type bond mode 4
 Error: unable to set option because the bond is up.

	Signed-off-by: Jonathan Toppins <jtoppins@redhat.com>
	Acked-by: Jay Vosburgh <jay.vosburgh@canonical.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2bff369b23542ea22d0111aaa8e0b8208bf0dc96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_netlink.c
diff --cc drivers/net/bonding/bond_netlink.c
index 5d54e11d18fa,5a6f44455b95..000000000000
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@@ -271,6 -286,37 +283,40 @@@ static int bond_changelink(struct net_d
  		if (err)
  			return err;
  	}
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (data[IFLA_BOND_NS_IP6_TARGET]) {
+ 		struct nlattr *attr;
+ 		int i = 0, rem;
+ 
+ 		bond_option_ns_ip6_targets_clear(bond);
+ 		nla_for_each_nested(attr, data[IFLA_BOND_NS_IP6_TARGET], rem) {
+ 			struct in6_addr addr6;
+ 
+ 			if (nla_len(attr) < sizeof(addr6)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid IPv6 address");
+ 				return -EINVAL;
+ 			}
+ 
+ 			addr6 = nla_get_in6_addr(attr);
+ 
+ 			bond_opt_initextra(&newval, &addr6, sizeof(addr6));
+ 			err = __bond_opt_set(bond, BOND_OPT_NS_TARGETS,
+ 					     &newval,
+ 					     data[IFLA_BOND_NS_IP6_TARGET],
+ 					     extack);
+ 			if (err)
+ 				break;
+ 			i++;
+ 		}
+ 		if (i == 0 && bond->params.arp_interval)
+ 			netdev_warn(bond->dev, "Removing last ns target with arp_interval on\n");
+ 		if (err)
+ 			return err;
+ 	}
+ #endif
++>>>>>>> 2bff369b2354 (bonding: netlink error message support for options)
  	if (data[IFLA_BOND_ARP_VALIDATE]) {
  		int arp_validate = nla_get_u32(data[IFLA_BOND_ARP_VALIDATE]);
  
@@@ -448,11 -513,22 +513,25 @@@
  		int dynamic_lb = nla_get_u8(data[IFLA_BOND_TLB_DYNAMIC_LB]);
  
  		bond_opt_initval(&newval, dynamic_lb);
- 		err = __bond_opt_set(bond, BOND_OPT_TLB_DYNAMIC_LB, &newval);
+ 		err = __bond_opt_set(bond, BOND_OPT_TLB_DYNAMIC_LB, &newval,
+ 				     data[IFLA_BOND_TLB_DYNAMIC_LB], extack);
+ 		if (err)
+ 			return err;
+ 	}
+ 
++<<<<<<< HEAD
++=======
+ 	if (data[IFLA_BOND_MISSED_MAX]) {
+ 		int missed_max = nla_get_u8(data[IFLA_BOND_MISSED_MAX]);
+ 
+ 		bond_opt_initval(&newval, missed_max);
+ 		err = __bond_opt_set(bond, BOND_OPT_MISSED_MAX, &newval,
+ 				     data[IFLA_BOND_MISSED_MAX], extack);
  		if (err)
  			return err;
  	}
  
++>>>>>>> 2bff369b2354 (bonding: netlink error message support for options)
  	return 0;
  }
  
* Unmerged path drivers/net/bonding/bond_netlink.c
diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index b93337b5a721..39b88a0635a5 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -605,27 +605,35 @@ static int bond_opt_check_deps(struct bonding *bond,
 }
 
 static void bond_opt_dep_print(struct bonding *bond,
-			       const struct bond_option *opt)
+			       const struct bond_option *opt,
+			       struct nlattr *bad_attr,
+			       struct netlink_ext_ack *extack)
 {
 	const struct bond_opt_value *modeval;
 	struct bond_params *params;
 
 	params = &bond->params;
 	modeval = bond_opt_get_val(BOND_OPT_MODE, params->mode);
-	if (test_bit(params->mode, &opt->unsuppmodes))
+	if (test_bit(params->mode, &opt->unsuppmodes)) {
 		netdev_err(bond->dev, "option %s: mode dependency failed, not supported in mode %s(%llu)\n",
 			   opt->name, modeval->string, modeval->value);
+		NL_SET_ERR_MSG_ATTR(extack, bad_attr,
+				    "option not supported in mode");
+	}
 }
 
 static void bond_opt_error_interpret(struct bonding *bond,
 				     const struct bond_option *opt,
-				     int error, const struct bond_opt_value *val)
+				     int error, const struct bond_opt_value *val,
+				     struct nlattr *bad_attr,
+				     struct netlink_ext_ack *extack)
 {
 	const struct bond_opt_value *minval, *maxval;
 	char *p;
 
 	switch (error) {
 	case -EINVAL:
+		NL_SET_ERR_MSG_ATTR(extack, bad_attr, "invalid option value");
 		if (val) {
 			if (val->string) {
 				/* sometimes RAWVAL opts may have new lines */
@@ -647,13 +655,17 @@ static void bond_opt_error_interpret(struct bonding *bond,
 			   opt->name, minval ? minval->value : 0, maxval->value);
 		break;
 	case -EACCES:
-		bond_opt_dep_print(bond, opt);
+		bond_opt_dep_print(bond, opt, bad_attr, extack);
 		break;
 	case -ENOTEMPTY:
+		NL_SET_ERR_MSG_ATTR(extack, bad_attr,
+				    "unable to set option because the bond device has slaves");
 		netdev_err(bond->dev, "option %s: unable to set because the bond device has slaves\n",
 			   opt->name);
 		break;
 	case -EBUSY:
+		NL_SET_ERR_MSG_ATTR(extack, bad_attr,
+				    "unable to set option because the bond is up");
 		netdev_err(bond->dev, "option %s: unable to set because the bond device is up\n",
 			   opt->name);
 		break;
@@ -664,6 +676,8 @@ static void bond_opt_error_interpret(struct bonding *bond,
 				*p = '\0';
 			netdev_err(bond->dev, "option %s: interface %s does not exist!\n",
 				   opt->name, val->string);
+			NL_SET_ERR_MSG_ATTR(extack, bad_attr,
+					    "interface does not exist");
 		}
 		break;
 	default:
@@ -676,13 +690,17 @@ static void bond_opt_error_interpret(struct bonding *bond,
  * @bond: target bond device
  * @option: option to set
  * @val: value to set it to
+ * @bad_attr: netlink attribue that caused the error
+ * @extack: extended netlink error structure, used when an error message
+ *          needs to be returned to the caller via netlink
  *
  * This function is used to change the bond's option value, it can be
  * used for both enabling/changing an option and for disabling it. RTNL lock
  * must be obtained before calling this function.
  */
 int __bond_opt_set(struct bonding *bond,
-		   unsigned int option, struct bond_opt_value *val)
+		   unsigned int option, struct bond_opt_value *val,
+		   struct nlattr *bad_attr, struct netlink_ext_ack *extack)
 {
 	const struct bond_opt_value *retval = NULL;
 	const struct bond_option *opt;
@@ -704,7 +722,7 @@ int __bond_opt_set(struct bonding *bond,
 	ret = opt->set(bond, retval);
 out:
 	if (ret)
-		bond_opt_error_interpret(bond, opt, ret, val);
+		bond_opt_error_interpret(bond, opt, ret, val, bad_attr, extack);
 
 	return ret;
 }
@@ -726,7 +744,7 @@ int __bond_opt_set_notify(struct bonding *bond,
 
 	ASSERT_RTNL();
 
-	ret = __bond_opt_set(bond, option, val);
+	ret = __bond_opt_set(bond, option, val, NULL, NULL);
 
 	if (!ret && (bond->dev->reg_state == NETREG_REGISTERED))
 		call_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond->dev);
diff --git a/include/net/bond_options.h b/include/net/bond_options.h
index e64833a674eb..e133ec32c243 100644
--- a/include/net/bond_options.h
+++ b/include/net/bond_options.h
@@ -101,7 +101,8 @@ struct bond_option {
 };
 
 int __bond_opt_set(struct bonding *bond, unsigned int option,
-		   struct bond_opt_value *val);
+		   struct bond_opt_value *val,
+		   struct nlattr *bad_attr, struct netlink_ext_ack *extack);
 int __bond_opt_set_notify(struct bonding *bond, unsigned int option,
 			  struct bond_opt_value *val);
 int bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf);
