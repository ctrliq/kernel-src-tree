wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit df9a9c44e91ba4305249a7e61284b15d54f70b19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/df9a9c44.failed

The functions currently take a link and check data
from it, but this needs to change for MLO. Simplify
the prototypes by passing only the needed arguments.

Remove the regulatory checks, the warnings shouldn't
trigger, and haven't as far as I know.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit df9a9c44e91ba4305249a7e61284b15d54f70b19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 38beaaa3d3f9,152d011c84f0..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -564,7 -564,7 +565,11 @@@ static void ieee80211_add_ht_ie(struct 
  	 * capable of 40 MHz -- some broken APs will never fall
  	 * back to trying to transmit in 20 MHz.
  	 */
++<<<<<<< HEAD
 +	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_40MHZ) {
++=======
+ 	if (conn_flags & IEEE80211_CONN_DISABLE_40MHZ) {
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  		cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
  		cap &= ~IEEE80211_HT_CAP_SGI_40;
  	}
@@@ -597,12 -597,13 +602,17 @@@
  
  /* This function determines vht capability flags for the association
   * and builds the IE.
-  * Note - the function may set the owner of the MU-MIMO capability
+  * Note - the function returns true to own the MU-MIMO capability
   */
++<<<<<<< HEAD
 +static void ieee80211_add_vht_ie(struct ieee80211_sub_if_data *sdata,
++=======
+ static bool ieee80211_add_vht_ie(struct ieee80211_sub_if_data *sdata,
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  				 struct sk_buff *skb,
  				 struct ieee80211_supported_band *sband,
- 				 struct ieee80211_vht_cap *ap_vht_cap)
+ 				 struct ieee80211_vht_cap *ap_vht_cap,
+ 				 ieee80211_conn_flags_t conn_flags)
  {
  	struct ieee80211_local *local = sdata->local;
  	u8 *pos;
@@@ -618,7 -620,7 +629,11 @@@
  	/* determine capability flags */
  	cap = vht_cap.cap;
  
++<<<<<<< HEAD
 +	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_80P80MHZ) {
++=======
+ 	if (conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ) {
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  		u32 bw = cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
  
  		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
@@@ -627,7 -629,7 +642,11 @@@
  			cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
  	}
  
++<<<<<<< HEAD
 +	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_160MHZ) {
++=======
+ 	if (conn_flags & IEEE80211_CONN_DISABLE_160MHZ) {
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  		cap &= ~IEEE80211_VHT_CAP_SHORT_GI_160;
  		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
  	}
@@@ -664,7 -666,7 +683,11 @@@
  		if (disable_mu_mimo)
  			cap &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;
  		else
++<<<<<<< HEAD
 +			sdata->vif.bss_conf.mu_mimo_owner = true;
++=======
+ 			mu_mimo_owner = true;
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  	}
  
  	mask = IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;
@@@ -687,22 -691,12 +712,25 @@@
   */
  static void ieee80211_add_he_ie(struct ieee80211_sub_if_data *sdata,
  				struct sk_buff *skb,
- 				struct ieee80211_supported_band *sband)
+ 				struct ieee80211_supported_band *sband,
+ 				ieee80211_conn_flags_t conn_flags)
  {
  	u8 *pos, *pre_he_pos;
- 	const struct ieee80211_sta_he_cap *he_cap = NULL;
- 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	const struct ieee80211_sta_he_cap *he_cap;
  	u8 he_cap_size;
++<<<<<<< HEAD
 +	bool reg_cap = false;
 +
 +	rcu_read_lock();
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 +	if (!WARN_ON_ONCE(!chanctx_conf))
 +		reg_cap = cfg80211_chandef_usable(sdata->wdev.wiphy,
 +						  &chanctx_conf->def,
 +						  IEEE80211_CHAN_NO_HE);
 +
 +	rcu_read_unlock();
++=======
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  
  	he_cap = ieee80211_get_he_iftype_cap(sband,
  					     ieee80211_vif_type_p2p(&sdata->vif));
@@@ -717,7 -711,7 +745,11 @@@
  				      he_cap->he_cap_elem.phy_cap_info);
  	pos = skb_put(skb, he_cap_size);
  	pre_he_pos = pos;
++<<<<<<< HEAD
 +	pos = ieee80211_ie_build_he_cap(sdata->u.mgd.flags,
++=======
+ 	pos = ieee80211_ie_build_he_cap(conn_flags,
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  					pos, he_cap, pos + he_cap_size);
  	/* trim excess if any */
  	skb_trim(skb, skb->len - (pre_he_pos + he_cap_size - pos));
@@@ -732,18 -726,7 +764,20 @@@ static void ieee80211_add_eht_ie(struc
  	u8 *pos;
  	const struct ieee80211_sta_he_cap *he_cap;
  	const struct ieee80211_sta_eht_cap *eht_cap;
- 	struct ieee80211_chanctx_conf *chanctx_conf;
  	u8 eht_cap_size;
++<<<<<<< HEAD
 +	bool reg_cap = false;
 +
 +	rcu_read_lock();
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 +	if (!WARN_ON_ONCE(!chanctx_conf))
 +		reg_cap = cfg80211_chandef_usable(sdata->wdev.wiphy,
 +						  &chanctx_conf->def,
 +						  IEEE80211_CHAN_NO_HE |
 +						  IEEE80211_CHAN_NO_EHT);
 +	rcu_read_unlock();
++=======
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  
  	he_cap = ieee80211_get_he_iftype_cap(sband,
  					     ieee80211_vif_type_p2p(&sdata->vif));
@@@ -985,124 -1088,51 +1019,146 @@@ skip_rates
  		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
  
  	/* if present, add any custom IEs that go before HT */
 -	offset = ieee80211_add_before_ht_elems(skb, assoc_data->ie,
 -					       assoc_data->ie_len,
 -					       offset);
 +	if (assoc_data->ie_len) {
 +		static const u8 before_ht[] = {
 +			WLAN_EID_SSID,
 +			WLAN_EID_SUPP_RATES,
 +			WLAN_EID_EXT_SUPP_RATES,
 +			WLAN_EID_PWR_CAPABILITY,
 +			WLAN_EID_SUPPORTED_CHANNELS,
 +			WLAN_EID_RSN,
 +			WLAN_EID_QOS_CAPA,
 +			WLAN_EID_RRM_ENABLED_CAPABILITIES,
 +			WLAN_EID_MOBILITY_DOMAIN,
 +			WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
 +			WLAN_EID_RIC_DATA,		/* reassoc only */
 +			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 +		};
 +		static const u8 after_ric[] = {
 +			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 +			WLAN_EID_HT_CAPABILITY,
 +			WLAN_EID_BSS_COEX_2040,
 +			/* luckily this is almost always there */
 +			WLAN_EID_EXT_CAPABILITY,
 +			WLAN_EID_QOS_TRAFFIC_CAPA,
 +			WLAN_EID_TIM_BCAST_REQ,
 +			WLAN_EID_INTERWORKING,
 +			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
 +			WLAN_EID_VHT_CAPABILITY,
 +			WLAN_EID_OPMODE_NOTIF,
 +		};
 +
 +		noffset = ieee80211_ie_split_ric(assoc_data->ie,
 +						 assoc_data->ie_len,
 +						 before_ht,
 +						 ARRAY_SIZE(before_ht),
 +						 after_ric,
 +						 ARRAY_SIZE(after_ric),
 +						 offset);
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
  
 -	if (WARN_ON_ONCE((link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
 -			 !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)))
 -		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
 +	if (WARN_ON_ONCE((ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +			 !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
  
  	if (sband->band != NL80211_BAND_6GHZ &&
++<<<<<<< HEAD
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
 +		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
 +				    sband, chan, sdata->smps_mode);
++=======
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
+ 		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
+ 				    sband, chan, link->smps_mode,
+ 				    link->u.mgd.conn_flags);
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  
  	/* if present, add any custom IEs that go before VHT */
 -	offset = ieee80211_add_before_vht_elems(skb, assoc_data->ie,
 -						assoc_data->ie_len,
 -						offset);
 +	if (assoc_data->ie_len) {
 +		static const u8 before_vht[] = {
 +			/*
 +			 * no need to list the ones split off before HT
 +			 * or generated here
 +			 */
 +			WLAN_EID_BSS_COEX_2040,
 +			WLAN_EID_EXT_CAPABILITY,
 +			WLAN_EID_QOS_TRAFFIC_CAPA,
 +			WLAN_EID_TIM_BCAST_REQ,
 +			WLAN_EID_INTERWORKING,
 +			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
 +		};
 +
 +		/* RIC already taken above, so no need to handle here anymore */
 +		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
 +					     before_vht, ARRAY_SIZE(before_vht),
 +					     offset);
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	/* if present, add any custom IEs that go before HE */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_he[] = {
 +			/*
 +			 * no need to list the ones split off before VHT
 +			 * or generated here
 +			 */
 +			WLAN_EID_OPMODE_NOTIF,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
 +			/* 11ai elements */
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
 +			/* TODO: add 11ah/11aj/11ak elements */
 +		};
 +
 +		/* RIC already taken above, so no need to handle here anymore */
 +		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
 +					     before_he, ARRAY_SIZE(before_he),
 +					     offset);
 +		pos = skb_put(skb, noffset - offset);
 +		memcpy(pos, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
  
  	if (sband->band != NL80211_BAND_6GHZ &&
++<<<<<<< HEAD
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_add_vht_ie(sdata, skb, sband,
 +				     &assoc_data->ap_vht_cap);
++=======
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		link->conf->mu_mimo_owner =
+ 			ieee80211_add_vht_ie(sdata, skb, sband,
+ 					     &assoc_data->ap_vht_cap,
+ 					     link->u.mgd.conn_flags);
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  
  	/*
  	 * If AP doesn't support HT, mark HE and EHT as disabled.
  	 * If on the 5GHz band, make sure it supports VHT.
  	 */
 -	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT ||
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT ||
  	    (sband->band == NL80211_BAND_5GHZ &&
 -	     link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
 -		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE |
 -						   IEEE80211_CONN_DISABLE_EHT;
 +	     ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +			        IEEE80211_STA_DISABLE_EHT;
  
 -	/* if present, add any custom IEs that go before HE */
 -	offset = ieee80211_add_before_he_elems(skb, assoc_data->ie,
 -					       assoc_data->ie_len,
 -					       offset);
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		ieee80211_add_he_ie(sdata, skb, sband);
  
++<<<<<<< HEAD
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
++=======
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)) {
+ 		ieee80211_add_he_ie(sdata, skb, sband, link->u.mgd.conn_flags);
+ 
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT))
++>>>>>>> df9a9c44e91b (wifi: mac80211: mlme: simplify adding ht/vht/he/eht elements)
  			ieee80211_add_eht_ie(sdata, skb, sband);
  	}
  
* Unmerged path net/mac80211/mlme.c
