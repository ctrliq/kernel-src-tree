wifi: mac80211: fix locking in auth/assoc timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 69371801f929ff4b3c846a45b9d49db631897cd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/69371801.failed

If we hit an authentication or association timeout, we only
release the chanctx for the deflink, and the other link(s)
are released later by ieee80211_vif_set_links(), but we're
not locking this correctly.

Fix the locking here while releasing the channels and links.

Change-Id: I9e08c1a5434592bdc75253c1abfa6c788f9f39b1
Fixes: 81151ce462e5 ("wifi: mac80211: support MLO authentication/association with one link")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 69371801f929ff4b3c846a45b9d49db631897cd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,5265d2b6db12..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -2952,13 -3412,18 +2952,19 @@@ static void ieee80211_destroy_auth_data
  		 * which is not relevant anymore.
  		 */
  		del_timer_sync(&sdata->u.mgd.timer);
 -		sta_info_destroy_addr(sdata, auth_data->ap_addr);
 +		sta_info_destroy_addr(sdata, auth_data->bss->bssid);
  
 -		/* other links are destroyed */
 -		sdata->deflink.u.mgd.conn_flags = 0;
 -		eth_zero_addr(sdata->deflink.u.mgd.bssid);
 -		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
 -						  BSS_CHANGED_BSSID);
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
  		sdata->u.mgd.flags = 0;
+ 
  		mutex_lock(&sdata->local->mtx);
++<<<<<<< HEAD
 +		ieee80211_vif_release_channel(sdata);
++=======
+ 		ieee80211_link_release_channel(&sdata->deflink);
+ 		ieee80211_vif_set_links(sdata, 0);
++>>>>>>> 69371801f929 (wifi: mac80211: fix locking in auth/assoc timeout)
  		mutex_unlock(&sdata->local->mtx);
  	}
  
@@@ -2995,18 -3462,28 +3001,29 @@@ static void ieee80211_destroy_assoc_dat
  		sdata->u.mgd.flags = 0;
  		sdata->vif.bss_conf.mu_mimo_owner = false;
  
++<<<<<<< HEAD
 +		mutex_lock(&sdata->local->mtx);
 +		ieee80211_vif_release_channel(sdata);
 +		mutex_unlock(&sdata->local->mtx);
 +
++=======
++>>>>>>> 69371801f929 (wifi: mac80211: fix locking in auth/assoc timeout)
  		if (status != ASSOC_REJECTED) {
  			struct cfg80211_assoc_failure data = {
 +				.bss[0] = assoc_data->bss,
  				.timeout = status == ASSOC_TIMEOUT,
  			};
 -			int i;
 -
 -			BUILD_BUG_ON(ARRAY_SIZE(data.bss) !=
 -				     ARRAY_SIZE(assoc_data->link));
 -
 -			for (i = 0; i < ARRAY_SIZE(data.bss); i++)
 -				data.bss[i] = assoc_data->link[i].bss;
 -
 -			if (sdata->vif.valid_links)
 -				data.ap_mld_addr = assoc_data->ap_addr;
  
  			cfg80211_assoc_failure(sdata->dev, &data);
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		mutex_lock(&sdata->local->mtx);
+ 		ieee80211_link_release_channel(&sdata->deflink);
+ 		ieee80211_vif_set_links(sdata, 0);
+ 		mutex_unlock(&sdata->local->mtx);
++>>>>>>> 69371801f929 (wifi: mac80211: fix locking in auth/assoc timeout)
  	}
  
  	kfree(assoc_data);
* Unmerged path net/mac80211/mlme.c
