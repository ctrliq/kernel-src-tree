selftests/vm: enable running select groups of tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Joel Savitz <jsavitz@redhat.com>
commit 85463321e726fe59873bbc21f2f480747810aef8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/85463321.failed

Our memory management kernel CI testing at Red Hat uses the VM
selftests and we have run into two problems:

First, our LTP tests overlap with the VM selftests.

We want to avoid unhelpful redundancy in our testing practices.

Second, we have observed the current run_vmtests.sh to report overall
failure/ambiguous results in the case that a machine lacks the necessary
hardware to perform one or more of the tests. E.g. ksm tests that
require more than one numa node.

We want to be able to run the vm selftests suitable to particular hardware.

Add the ability to run one or more groups of vm tests via run_vmtests.sh
instead of simply all-or-none in order to solve these problems.

Preserve existing default behavior of running all tests when the script
is invoked with no arguments.

Documentation of test groups is included in the patch as follows:

    # ./run_vmtests.sh [ -h || --help ]

    usage: ./tools/testing/selftests/vm/run_vmtests.sh [ -h | -t "<categories>"]
      -t: specify specific categories to tests to run
      -h: display this message

    The default behavior is to run all tests.

    Alternatively, specific groups tests can be run by passing a string
    to the -t argument containing one or more of the following categories
    separated by spaces:
    - mmap
	    tests for mmap(2)
    - gup_test
	    tests for gup using gup_test interface
    - userfaultfd
	    tests for  userfaultfd(2)
    - compaction
	    a test for the patch "Allow compaction of unevictable pages"
    - mlock
	    tests for mlock(2)
    - mremap
	    tests for mremap(2)
    - hugevm
	    tests for very large virtual address space
    - vmalloc
	    vmalloc smoke tests
    - hmm
	    hmm smoke tests
    - madv_populate
	    test memadvise(2) MADV_POPULATE_{READ,WRITE} options
    - memfd_secret
	    test memfd_secret(2)
    - process_mrelease
	    test process_mrelease(2)
    - ksm
	    ksm tests that do not require >=2 NUMA nodes
    - ksm_numa
	    ksm tests that require >=2 NUMA nodes
    - pkey
	    memory protection key tests
    - soft_dirty
    	    test soft dirty page bit semantics
    - anon_cow
            test anonymous copy-on-write semantics
    example: ./run_vmtests.sh -t "hmm mmap ksm"

Link: https://lkml.kernel.org/r/20221018231222.1884715-1-jsavitz@redhat.com
	Signed-off-by: Joel Savitz <jsavitz@redhat.com>
	Cc: Joel Savitz <jsavitz@redhat.com>
	Cc: Nico Pache <npache@redhat.com>
	Cc: Shuah Khan <shuah@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 85463321e726fe59873bbc21f2f480747810aef8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/vm/run_vmtests.sh
diff --cc tools/testing/selftests/vm/run_vmtests.sh
index 60bc7a4ab333,e26661feacf5..000000000000
--- a/tools/testing/selftests/vm/run_vmtests.sh
+++ b/tools/testing/selftests/vm/run_vmtests.sh
@@@ -5,16 -5,90 +5,96 @@@
  # Kselftest framework requirement - SKIP code is 4.
  ksft_skip=4
  
 +mnt=./huge
  exitcode=0
  
++<<<<<<< HEAD
 +#get huge pagesize and freepages from /proc/meminfo
 +while read name size unit; do
++=======
+ usage() {
+ 	cat <<EOF
+ usage: ${BASH_SOURCE[0]:-$0} [ -h | -t "<categories>"]
+   -t: specify specific categories to tests to run
+   -h: display this message
+ 
+ The default behavior is to run all tests.
+ 
+ Alternatively, specific groups tests can be run by passing a string
+ to the -t argument containing one or more of the following categories
+ separated by spaces:
+ - mmap
+ 	tests for mmap(2)
+ - gup_test
+ 	tests for gup using gup_test interface
+ - userfaultfd
+ 	tests for  userfaultfd(2)
+ - compaction
+ 	a test for the patch "Allow compaction of unevictable pages"
+ - mlock
+ 	tests for mlock(2)
+ - mremap
+ 	tests for mremap(2)
+ - hugevm
+ 	tests for very large virtual address space
+ - vmalloc
+ 	vmalloc smoke tests
+ - hmm
+ 	hmm smoke tests
+ - madv_populate
+ 	test memadvise(2) MADV_POPULATE_{READ,WRITE} options
+ - memfd_secret
+ 	test memfd_secret(2)
+ - process_mrelease
+ 	test process_mrelease(2)
+ - ksm
+ 	ksm tests that do not require >=2 NUMA nodes
+ - ksm_numa
+ 	ksm tests that require >=2 NUMA nodes
+ - pkey
+ 	memory protection key tests
+ - soft_dirty
+ 	test soft dirty page bit semantics
+ - cow
+ 	test copy-on-write semantics
+ example: ./run_vmtests.sh -t "hmm mmap ksm"
+ EOF
+ 	exit 0
+ }
+ 
+ 
+ while getopts "ht:" OPT; do
+ 	case ${OPT} in
+ 		"h") usage ;;
+ 		"t") VM_SELFTEST_ITEMS=${OPTARG} ;;
+ 	esac
+ done
+ shift $((OPTIND -1))
+ 
+ # default behavior: run all tests
+ VM_SELFTEST_ITEMS=${VM_SELFTEST_ITEMS:-default}
+ 
+ test_selected() {
+ 	if [ "$VM_SELFTEST_ITEMS" == "default" ]; then
+ 		# If no VM_SELFTEST_ITEMS are specified, run all tests
+ 		return 0
+ 	fi
+ 	# If test selected argument is one of the test items
+ 	if [[ " ${VM_SELFTEST_ITEMS[*]} " =~ " ${1} " ]]; then
+ 	        return 0
+ 	else
+ 	        return 1
+ 	fi
+ }
+ 
+ # get huge pagesize and freepages from /proc/meminfo
+ while read -r name size unit; do
++>>>>>>> 85463321e726 (selftests/vm: enable running select groups of tests)
  	if [ "$name" = "HugePages_Free:" ]; then
 -		freepgs="$size"
 +		freepgs=$size
  	fi
  	if [ "$name" = "Hugepagesize:" ]; then
 -		hpgsize_KB="$size"
 +		hpgsize_KB=$size
  	fi
  done < /proc/meminfo
  
@@@ -28,16 -102,15 +108,16 @@@ hpgsize_MB=$((hpgsize_KB / 1024)
  half_ufd_size_MB=$((((nr_cpus * hpgsize_MB + 127) / 128) * 128))
  needmem_KB=$((half_ufd_size_MB * 2 * 1024))
  
- #set proper nr_hugepages
+ # set proper nr_hugepages
  if [ -n "$freepgs" ] && [ -n "$hpgsize_KB" ]; then
 -	nr_hugepgs=$(cat /proc/sys/vm/nr_hugepages)
 +	nr_hugepgs=`cat /proc/sys/vm/nr_hugepages`
  	needpgs=$((needmem_KB / hpgsize_KB))
  	tries=2
 -	while [ "$tries" -gt 0 ] && [ "$freepgs" -lt "$needpgs" ]; do
 -		lackpgs=$((needpgs - freepgs))
 +	while [ $tries -gt 0 ] && [ $freepgs -lt $needpgs ]; do
 +		lackpgs=$(( $needpgs - $freepgs ))
  		echo 3 > /proc/sys/vm/drop_caches
 -		if ! echo $((lackpgs + nr_hugepgs)) > /proc/sys/vm/nr_hugepages; then
 +		echo $(( $lackpgs + $nr_hugepgs )) > /proc/sys/vm/nr_hugepages
 +		if [ $? -ne 0 ]; then
  			echo "Please run this test as root"
  			exit $ksft_skip
  		fi
@@@ -58,281 -131,142 +138,413 @@@ els
  	exit 1
  fi
  
- #filter 64bit architectures
+ # filter 64bit architectures
  ARCH64STR="arm64 ia64 mips64 parisc64 ppc64 ppc64le riscv64 s390x sh64 sparc64 x86_64"
 -if [ -z "$ARCH" ]; then
 -	ARCH=$(uname -m 2>/dev/null | sed -e 's/aarch64.*/arm64/')
 +if [ -z $ARCH ]; then
 +  ARCH=`uname -m 2>/dev/null | sed -e 's/aarch64.*/arm64/'`
  fi
  VADDR64=0
++<<<<<<< HEAD
 +echo "$ARCH64STR" | grep $ARCH && VADDR64=1
 +
 +mkdir $mnt
 +mount -t hugetlbfs none $mnt
 +
 +echo "---------------------"
 +echo "running hugepage-mmap"
 +echo "---------------------"
 +./hugepage-mmap
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +shmmax=`cat /proc/sys/kernel/shmmax`
 +shmall=`cat /proc/sys/kernel/shmall`
 +echo 268435456 > /proc/sys/kernel/shmmax
 +echo 4194304 > /proc/sys/kernel/shmall
 +echo "--------------------"
 +echo "running hugepage-shm"
 +echo "--------------------"
 +./hugepage-shm
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +echo $shmmax > /proc/sys/kernel/shmmax
 +echo $shmall > /proc/sys/kernel/shmall
 +
 +echo "-------------------"
 +echo "running map_hugetlb"
 +echo "-------------------"
 +./map_hugetlb
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
++=======
+ echo "$ARCH64STR" | grep "$ARCH" &>/dev/null && VADDR64=1
+ 
+ # Usage: run_test [test binary] [arbitrary test arguments...]
+ run_test() {
+ 	if test_selected ${CATEGORY}; then
+ 		local title="running $*"
+ 		local sep=$(echo -n "$title" | tr "[:graph:][:space:]" -)
+ 		printf "%s\n%s\n%s\n" "$sep" "$title" "$sep"
+ 
+ 		"$@"
+ 		local ret=$?
+ 		if [ $ret -eq 0 ]; then
+ 			echo "[PASS]"
+ 		elif [ $ret -eq $ksft_skip ]; then
+ 			echo "[SKIP]"
+ 			exitcode=$ksft_skip
+ 		else
+ 			echo "[FAIL]"
+ 			exitcode=1
+ 		fi
+ 	fi # test_selected
+ }
  
- echo "NOTE: The above hugetlb tests provide minimal coverage.  Use"
- echo "      https://github.com/libhugetlbfs/libhugetlbfs.git for"
- echo "      hugetlb regression testing."
+ CATEGORY="hugetlb" run_test ./hugepage-mmap
  
+ shmmax=$(cat /proc/sys/kernel/shmmax)
+ shmall=$(cat /proc/sys/kernel/shmall)
+ echo 268435456 > /proc/sys/kernel/shmmax
+ echo 4194304 > /proc/sys/kernel/shmall
+ CATEGORY="hugetlb" run_test ./hugepage-shm
+ echo "$shmmax" > /proc/sys/kernel/shmmax
+ echo "$shmall" > /proc/sys/kernel/shmall
+ 
+ CATEGORY="hugetlb" run_test ./map_hugetlb
+ CATEGORY="hugetlb" run_test ./hugepage-mremap
+ CATEGORY="hugetlb" run_test ./hugepage-vmemmap
+ CATEGORY="hugetlb" run_test ./hugetlb-madvise
++>>>>>>> 85463321e726 (selftests/vm: enable running select groups of tests)
+ 
+ if test_selected "hugetlb"; then
+ 	echo "NOTE: These hugetlb tests provide minimal coverage.  Use"
+ 	echo "      https://github.com/libhugetlbfs/libhugetlbfs.git for"
+ 	echo "      hugetlb regression testing."
+ fi
+ 
++<<<<<<< HEAD
 +echo "------------------------------------------------------"
 +echo "running: gup_test -u # get_user_pages_fast() benchmark"
 +echo "------------------------------------------------------"
 +./gup_test -u
 +ret_val=$?
 +
 +if [ $ret_val -eq 0 ]; then
 +	echo "[PASS]"
 +elif [ $ret_val -eq $ksft_skip ]; then
 +	 echo "[SKIP]"
 +	 exitcode=$ksft_skip
 +else
 +	echo "[FAIL]"
 +	exitcode=1
 +fi
 +
 +echo "------------------------------------------------------"
 +echo "running: gup_test -a # pin_user_pages_fast() benchmark"
 +echo "------------------------------------------------------"
 +./gup_test -a
 +ret_val=$?
 +
 +if [ $ret_val -eq 0 ]; then
 +	echo "[PASS]"
 +elif [ $ret_val -eq $ksft_skip ]; then
 +	 echo "[SKIP]"
 +	 exitcode=$ksft_skip
 +else
 +	echo "[FAIL]"
 +	exitcode=1
 +fi
 +
 +echo "------------------------------------------------------------"
 +echo "# Dump pages 0, 19, and 4096, using pin_user_pages:"
 +echo "running: gup_test -ct -F 0x1 0 19 0x1000 # dump_page() test"
 +echo "------------------------------------------------------------"
 +./gup_test -ct -F 0x1 0 19 0x1000
 +ret_val=$?
 +
 +if [ $ret_val -eq 0 ]; then
 +	echo "[PASS]"
 +elif [ $ret_val -eq $ksft_skip ]; then
 +	 echo "[SKIP]"
 +	 exitcode=$ksft_skip
 +else
 +	echo "[FAIL]"
 +	exitcode=1
 +fi
 +
 +echo "---------------------------"
 +echo "running map_fixed_noreplace"
 +echo "---------------------------"
 +./map_fixed_noreplace
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "-------------------"
 +echo "running userfaultfd"
 +echo "-------------------"
 +./userfaultfd anon 20 16
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "---------------------------"
 +echo "running userfaultfd_hugetlb"
 +echo "---------------------------"
 +# Test requires source and destination huge pages.  Size of source
 +# (half_ufd_size_MB) is passed as argument to test.
 +./userfaultfd hugetlb $half_ufd_size_MB 32 $mnt/ufd_test_file
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +rm -f $mnt/ufd_test_file
 +
 +echo "-------------------------"
 +echo "running userfaultfd_shmem"
 +echo "-------------------------"
 +./userfaultfd shmem 20 16
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
++=======
+ CATEGORY="mmap" run_test ./map_fixed_noreplace
+ 
+ # get_user_pages_fast() benchmark
+ CATEGORY="gup_test" run_test ./gup_test -u
+ # pin_user_pages_fast() benchmark
+ CATEGORY="gup_test" run_test ./gup_test -a
+ # Dump pages 0, 19, and 4096, using pin_user_pages:
+ CATEGORY="gup_test" run_test ./gup_test -ct -F 0x1 0 19 0x1000
+ 
+ uffd_mods=("" ":dev")
+ for mod in "${uffd_mods[@]}"; do
+ 	CATEGORY="userfaultfd" run_test ./userfaultfd anon${mod} 20 16
+ 	# Hugetlb tests require source and destination huge pages. Pass in half
+ 	# the size ($half_ufd_size_MB), which is used for *each*.
+ 	CATEGORY="userfaultfd" run_test ./userfaultfd hugetlb${mod} "$half_ufd_size_MB" 32
+ 	CATEGORY="userfaultfd" run_test ./userfaultfd hugetlb_shared${mod} "$half_ufd_size_MB" 32
+ 	CATEGORY="userfaultfd" run_test ./userfaultfd shmem${mod} 20 16
+ done
++>>>>>>> 85463321e726 (selftests/vm: enable running select groups of tests)
  
  #cleanup
 -echo "$nr_hugepgs" > /proc/sys/vm/nr_hugepages
 +umount $mnt
 +rm -rf $mnt
 +echo $nr_hugepgs > /proc/sys/vm/nr_hugepages
 +
++<<<<<<< HEAD
 +echo "-----------------------"
 +echo "running compaction_test"
 +echo "-----------------------"
 +./compaction_test
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "----------------------"
 +echo "running on-fault-limit"
 +echo "----------------------"
 +sudo -u nobody ./on-fault-limit
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "--------------------"
 +echo "running map_populate"
 +echo "--------------------"
 +./map_populate
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "-------------------------"
 +echo "running mlock-random-test"
 +echo "-------------------------"
 +./mlock-random-test
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "--------------------"
 +echo "running mlock2-tests"
 +echo "--------------------"
 +./mlock2-tests
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "-----------------"
 +echo "running thuge-gen"
 +echo "-----------------"
 +./thuge-gen
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +if [ $VADDR64 -ne 0 ]; then
 +echo "-----------------------------"
 +echo "running virtual_address_range"
 +echo "-----------------------------"
 +./virtual_address_range
 +if [ $? -ne 0 ]; then
 +	echo "[FAIL]"
 +	exitcode=1
 +else
 +	echo "[PASS]"
 +fi
 +
 +echo "-----------------------------"
 +echo "running virtual address 128TB switch test"
 +echo "-----------------------------"
 +./va_128TBswitch
 +if [ $? -ne 0 ]; then
 +    echo "[FAIL]"
 +    exitcode=1
 +else
 +    echo "[PASS]"
 +fi
 +fi # VADDR64
 +
 +echo "------------------------------------"
 +echo "running vmalloc stability smoke test"
 +echo "------------------------------------"
 +./test_vmalloc.sh smoke
 +ret_val=$?
 +
 +if [ $ret_val -eq 0 ]; then
 +	echo "[PASS]"
 +elif [ $ret_val -eq $ksft_skip ]; then
 +	 echo "[SKIP]"
 +	 exitcode=$ksft_skip
 +else
 +	echo "[FAIL]"
 +	exitcode=1
 +fi
 +
 +echo "------------------------------------"
 +echo "running HMM smoke test"
 +echo "------------------------------------"
 +./test_hmm.sh smoke
 +ret_val=$?
 +
 +if [ $ret_val -eq 0 ]; then
 +	echo "[PASS]"
 +elif [ $ret_val -eq $ksft_skip ]; then
 +	echo "[SKIP]"
 +	exitcode=$ksft_skip
 +else
 +	echo "[FAIL]"
 +	exitcode=1
 +fi
  
++=======
+ CATEGORY="compaction" run_test ./compaction_test
+ 
+ CATEGORY="mlock" run_test sudo -u nobody ./on-fault-limit
+ 
+ CATEGORY="mmap" run_test ./map_populate
+ 
+ CATEGORY="mlock" run_test ./mlock-random-test
+ 
+ CATEGORY="mlock" run_test ./mlock2-tests
+ 
+ CATEGORY="process_mrelease" run_test ./mrelease_test
+ 
+ CATEGORY="mremap" run_test ./mremap_test
+ 
+ CATEGORY="hugetlb" run_test ./thuge-gen
+ 
+ if [ $VADDR64 -ne 0 ]; then
+ 	CATEGORY="hugevm" run_test ./virtual_address_range
+ 
+ 	# virtual address 128TB switch test
+ 	CATEGORY="hugevm" run_test ./va_128TBswitch.sh
+ fi # VADDR64
+ 
+ # vmalloc stability smoke test
+ CATEGORY="vmalloc" run_test ./test_vmalloc.sh smoke
+ 
+ CATEGORY="mremap" run_test ./mremap_dontunmap
+ 
+ CATEGORY="hmm" run_test ./test_hmm.sh smoke
+ 
+ # MADV_POPULATE_READ and MADV_POPULATE_WRITE tests
+ CATEGORY="madv_populate" run_test ./madv_populate
+ 
+ CATEGORY="memfd_secret" run_test ./memfd_secret
+ 
+ # KSM MADV_MERGEABLE test with 10 identical pages
+ CATEGORY="ksm" run_test ./ksm_tests -M -p 10
+ # KSM unmerge test
+ CATEGORY="ksm" run_test ./ksm_tests -U
+ # KSM test with 10 zero pages and use_zero_pages = 0
+ CATEGORY="ksm" run_test ./ksm_tests -Z -p 10 -z 0
+ # KSM test with 10 zero pages and use_zero_pages = 1
+ CATEGORY="ksm" run_test ./ksm_tests -Z -p 10 -z 1
+ # KSM test with 2 NUMA nodes and merge_across_nodes = 1
+ CATEGORY="ksm_numa" run_test ./ksm_tests -N -m 1
+ # KSM test with 2 NUMA nodes and merge_across_nodes = 0
+ CATEGORY="ksm_numa" run_test ./ksm_tests -N -m 0
+ 
+ CATEGORY="ksm" run_test ./ksm_functional_tests
+ 
+ # protection_keys tests
+ if [ -x ./protection_keys_32 ]
+ then
+ 	CATEGORY="pkey" run_test ./protection_keys_32
+ fi
+ 
+ if [ -x ./protection_keys_64 ]
+ then
+ 	CATEGORY="pkey" run_test ./protection_keys_64
+ fi
+ 
+ CATEGORY="soft_dirty" run_test ./soft-dirty
+ 
+ # COW tests
+ CATEGORY="cow" run_test ./cow
+ 
++>>>>>>> 85463321e726 (selftests/vm: enable running select groups of tests)
  exit $exitcode
* Unmerged path tools/testing/selftests/vm/run_vmtests.sh
