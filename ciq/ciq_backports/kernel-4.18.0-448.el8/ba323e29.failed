wifi: mac80211: separate out connection downgrade flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit ba323e29859458fb180e8a99b4382d0cbf72d47f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ba323e29.failed

Separate out the connection downgrade flags from the ifmgd->flags
and put them into the link information instead. While at it, make
them a separate sparse type so we don't get confused about where
they belong and have static checking on correct handling.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit ba323e29859458fb180e8a99b4382d0cbf72d47f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ieee80211_i.h
#	net/mac80211/mlme.c
diff --cc net/mac80211/ieee80211_i.h
index 9f2fe5f6d317,154ff50e99a0..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -903,6 -873,105 +908,108 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	ieee80211_conn_flags_t conn_flags;
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool have_beacon;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ 
+ 	struct ieee80211_bss_conf *conf;
+ };
+ 
++>>>>>>> ba323e298594 (wifi: mac80211: separate out connection downgrade flags)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
@@@ -2449,29 -2340,29 +2553,29 @@@ bool ieee80211_chandef_he_6ghz_oper(str
  				    struct cfg80211_chan_def *chandef);
  bool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,
  				struct cfg80211_chan_def *chandef);
- u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c);
+ ieee80211_conn_flags_t ieee80211_chandef_downgrade(struct cfg80211_chan_def *c);
  
  int __must_check
 -ieee80211_link_use_channel(struct ieee80211_link_data *link,
 -			   const struct cfg80211_chan_def *chandef,
 -			   enum ieee80211_chanctx_mode mode);
 +ieee80211_vif_use_channel(struct ieee80211_sub_if_data *sdata,
 +			  const struct cfg80211_chan_def *chandef,
 +			  enum ieee80211_chanctx_mode mode);
  int __must_check
 -ieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,
 -			       const struct cfg80211_chan_def *chandef,
 -			       enum ieee80211_chanctx_mode mode,
 -			       bool radar_required);
 +ieee80211_vif_reserve_chanctx(struct ieee80211_sub_if_data *sdata,
 +			      const struct cfg80211_chan_def *chandef,
 +			      enum ieee80211_chanctx_mode mode,
 +			      bool radar_required);
  int __must_check
 -ieee80211_link_use_reserved_context(struct ieee80211_link_data *link);
 -int ieee80211_link_unreserve_chanctx(struct ieee80211_link_data *link);
 +ieee80211_vif_use_reserved_context(struct ieee80211_sub_if_data *sdata);
 +int ieee80211_vif_unreserve_chanctx(struct ieee80211_sub_if_data *sdata);
  
  int __must_check
 -ieee80211_link_change_bandwidth(struct ieee80211_link_data *link,
 -				const struct cfg80211_chan_def *chandef,
 -				u32 *changed);
 -void ieee80211_link_release_channel(struct ieee80211_link_data *link);
 -void ieee80211_link_vlan_copy_chanctx(struct ieee80211_link_data *link);
 -void ieee80211_link_copy_chanctx_to_vlans(struct ieee80211_link_data *link,
 -					  bool clear);
 +ieee80211_vif_change_bandwidth(struct ieee80211_sub_if_data *sdata,
 +			       const struct cfg80211_chan_def *chandef,
 +			       u32 *changed);
 +void ieee80211_vif_release_channel(struct ieee80211_sub_if_data *sdata);
 +void ieee80211_vif_vlan_copy_chanctx(struct ieee80211_sub_if_data *sdata);
 +void ieee80211_vif_copy_chanctx_to_vlans(struct ieee80211_sub_if_data *sdata,
 +					 bool clear);
  int ieee80211_chanctx_refcount(struct ieee80211_local *local,
  			       struct ieee80211_chanctx *ctx);
  
diff --cc net/mac80211/mlme.c
index 6cd411ed25d6,3b00383dbdbd..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -1025,14 -1024,14 +1027,14 @@@ skip_rates
  		offset = noffset;
  	}
  
- 	if (WARN_ON_ONCE((ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
- 			 !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)))
- 		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
+ 	if (WARN_ON_ONCE((sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
+ 			 !(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)))
+ 		sdata->deflink.u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
  
  	if (sband->band != NL80211_BAND_6GHZ &&
- 	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
+ 	    !(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
  		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
 -				    sband, chan, sdata->deflink.smps_mode);
 +				    sband, chan, sdata->smps_mode);
  
  	/* if present, add any custom IEs that go before VHT */
  	if (assoc_data->ie_len) {
@@@ -1433,8 -1433,8 +1435,13 @@@ ieee80211_sta_process_chanswitch(struc
  	bss = (void *)cbss->priv;
  	res = ieee80211_parse_ch_switch_ie(sdata, elems, current_band,
  					   bss->vht_cap_info,
++<<<<<<< HEAD
 +					   ifmgd->flags,
 +					   ifmgd->bssid, &csa_ie);
++=======
+ 					   sdata->deflink.u.mgd.conn_flags,
+ 					   sdata->deflink.u.mgd.bssid, &csa_ie);
++>>>>>>> ba323e298594 (wifi: mac80211: separate out connection downgrade flags)
  
  	if (!res) {
  		ch_switch.timestamp = timestamp;
@@@ -2513,19 -2517,20 +2520,20 @@@ static void ieee80211_set_disassoc(stru
  	sdata->vif.bss_conf.dtim_period = 0;
  	sdata->vif.bss_conf.beacon_rate = NULL;
  
 -	sdata->deflink.u.mgd.have_beacon = false;
 +	ifmgd->have_beacon = false;
  
  	ifmgd->flags = 0;
+ 	sdata->deflink.u.mgd.conn_flags = 0;
  	mutex_lock(&local->mtx);
 -	ieee80211_link_release_channel(&sdata->deflink);
 +	ieee80211_vif_release_channel(sdata);
  
  	sdata->vif.bss_conf.csa_active = false;
 -	sdata->deflink.u.mgd.csa_waiting_bcn = false;
 -	sdata->deflink.u.mgd.csa_ignored_same_chan = false;
 -	if (sdata->deflink.csa_block_tx) {
 +	ifmgd->csa_waiting_bcn = false;
 +	ifmgd->csa_ignored_same_chan = false;
 +	if (sdata->csa_block_tx) {
  		ieee80211_wake_vif_queues(local, sdata,
  					  IEEE80211_QUEUE_STOP_REASON_CSA);
 -		sdata->deflink.csa_block_tx = false;
 +		sdata->csa_block_tx = false;
  	}
  	mutex_unlock(&local->mtx);
  
@@@ -2953,11 -2958,13 +2961,12 @@@ static void ieee80211_destroy_auth_data
  		del_timer_sync(&sdata->u.mgd.timer);
  		sta_info_destroy_addr(sdata, auth_data->bss->bssid);
  
 -		eth_zero_addr(sdata->deflink.u.mgd.bssid);
 -		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
 -						  BSS_CHANGED_BSSID);
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
  		sdata->u.mgd.flags = 0;
+ 		sdata->deflink.u.mgd.conn_flags = 0;
  		mutex_lock(&sdata->local->mtx);
 -		ieee80211_link_release_channel(&sdata->deflink);
 +		ieee80211_vif_release_channel(sdata);
  		mutex_unlock(&sdata->local->mtx);
  	}
  
@@@ -2982,9 -2989,11 +2991,10 @@@ static void ieee80211_destroy_assoc_dat
  		del_timer_sync(&sdata->u.mgd.timer);
  		sta_info_destroy_addr(sdata, assoc_data->bss->bssid);
  
 -		eth_zero_addr(sdata->deflink.u.mgd.bssid);
 -		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
 -						  BSS_CHANGED_BSSID);
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
  		sdata->u.mgd.flags = 0;
+ 		sdata->deflink.u.mgd.conn_flags = 0;
  		sdata->vif.bss_conf.mu_mimo_owner = false;
  
  		mutex_lock(&sdata->local->mtx);
@@@ -3598,15 -3607,17 +3608,15 @@@ static bool ieee80211_assoc_success(str
  	}
  
  	/* Set up internal HT/VHT capabilities */
- 	if (elems->ht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
+ 	if (elems->ht_cap_elem && !(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
  		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
 -						  elems->ht_cap_elem,
 -						  &sta->deflink);
 +						  elems->ht_cap_elem, sta);
  
- 	if (elems->vht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
+ 	if (elems->vht_cap_elem && !(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
  		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
 -						    elems->vht_cap_elem,
 -						    &sta->deflink);
 +						    elems->vht_cap_elem, sta);
  
- 	if (elems->he_operation && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
+ 	if (elems->he_operation && !(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
  	    elems->he_cap) {
  		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
  						  elems->he_cap,
@@@ -5026,12 -5045,13 +5036,17 @@@ void ieee80211_sta_setup_sdata(struct i
  	ifmgd->powersave = sdata->wdev.ps;
  	ifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;
  	ifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;
++<<<<<<< HEAD
 +	ifmgd->p2p_noa_index = -1;
++=======
+ 	sdata->deflink.u.mgd.p2p_noa_index = -1;
+ 	sdata->deflink.u.mgd.conn_flags = 0;
++>>>>>>> ba323e298594 (wifi: mac80211: separate out connection downgrade flags)
  
  	if (sdata->local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
 -		sdata->deflink.u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
 +		ifmgd->req_smps = IEEE80211_SMPS_AUTOMATIC;
  	else
 -		sdata->deflink.u.mgd.req_smps = IEEE80211_SMPS_OFF;
 +		ifmgd->req_smps = IEEE80211_SMPS_OFF;
  
  	/* Setup TDLS data */
  	spin_lock_init(&ifmgd->teardown_lock);
@@@ -5496,16 -5516,17 +5511,17 @@@ static int ieee80211_prep_channel(struc
  				   "AP missing S1G operation element?\n");
  	}
  
- 	ifmgd->flags |= ieee80211_determine_chantype(sdata, sband,
- 						     cbss->channel,
- 						     bss->vht_cap_info,
- 						     ht_oper, vht_oper,
- 						     he_oper, eht_oper,
- 						     s1g_oper,
- 						     &chandef, false);
+ 	sdata->deflink.u.mgd.conn_flags |=
+ 		ieee80211_determine_chantype(sdata, sband,
+ 					     cbss->channel,
+ 					     bss->vht_cap_info,
+ 					     ht_oper, vht_oper,
+ 					     he_oper, eht_oper,
+ 					     s1g_oper,
+ 					     &chandef, false);
  
 -	sdata->deflink.needed_rx_chains =
 -		min(ieee80211_max_rx_chains(sdata, cbss), local->rx_chains);
 +	sdata->needed_rx_chains = min(ieee80211_max_rx_chains(sdata, cbss),
 +				      local->rx_chains);
  
  	rcu_read_unlock();
  	/* the element data was RCU protected so no longer valid anyway */
@@@ -5535,9 -5556,10 +5551,16 @@@
  		goto out;
  
  	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
++<<<<<<< HEAD
 +		ifmgd->flags |= ieee80211_chandef_downgrade(&chandef);
 +		ret = ieee80211_vif_use_channel(sdata, &chandef,
 +						IEEE80211_CHANCTX_SHARED);
++=======
+ 		sdata->deflink.u.mgd.conn_flags |=
+ 			ieee80211_chandef_downgrade(&chandef);
+ 		ret = ieee80211_link_use_channel(&sdata->deflink, &chandef,
+ 						 IEEE80211_CHANCTX_SHARED);
++>>>>>>> ba323e298594 (wifi: mac80211: separate out connection downgrade flags)
  	}
   out:
  	mutex_unlock(&local->mtx);
@@@ -6110,11 -6135,11 +6133,11 @@@ int ieee80211_mgd_assoc(struct ieee8021
  	/* kick off associate process */
  
  	ifmgd->assoc_data = assoc_data;
 -	sdata->deflink.u.mgd.dtim_period = 0;
 -	sdata->deflink.u.mgd.have_beacon = false;
 +	ifmgd->dtim_period = 0;
 +	ifmgd->have_beacon = false;
  
  	/* override HT/VHT configuration only if the AP and we support it */
- 	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
+ 	if (!(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
  		struct ieee80211_sta_ht_cap sta_ht_cap;
  
  		if (req->flags & ASSOC_REQ_DISABLE_HT)
diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c
index ff7a39ac5d28..1a29631d5adf 100644
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@ -770,20 +770,21 @@ ieee80211_ibss_process_chanswitch(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
 	enum nl80211_channel_type ch_type;
 	int err;
-	u32 sta_flags;
+	ieee80211_conn_flags_t conn_flags;
 	u32 vht_cap_info = 0;
 
 	sdata_assert_lock(sdata);
 
-	sta_flags = IEEE80211_STA_DISABLE_VHT;
+	conn_flags = IEEE80211_CONN_DISABLE_VHT;
+
 	switch (ifibss->chandef.width) {
 	case NL80211_CHAN_WIDTH_5:
 	case NL80211_CHAN_WIDTH_10:
 	case NL80211_CHAN_WIDTH_20_NOHT:
-		sta_flags |= IEEE80211_STA_DISABLE_HT;
+		conn_flags |= IEEE80211_CONN_DISABLE_HT;
 		fallthrough;
 	case NL80211_CHAN_WIDTH_20:
-		sta_flags |= IEEE80211_STA_DISABLE_40MHZ;
+		conn_flags |= IEEE80211_CONN_DISABLE_40MHZ;
 		break;
 	default:
 		break;
@@ -796,7 +797,7 @@ ieee80211_ibss_process_chanswitch(struct ieee80211_sub_if_data *sdata,
 	err = ieee80211_parse_ch_switch_ie(sdata, elems,
 					   ifibss->chandef.chan->band,
 					   vht_cap_info,
-					   sta_flags, ifibss->bssid, &csa_ie);
+					   conn_flags, ifibss->bssid, &csa_ie);
 	/* can't switch to destination channel, fail */
 	if (err < 0)
 		goto disconnect;
@@ -839,7 +840,7 @@ ieee80211_ibss_process_chanswitch(struct ieee80211_sub_if_data *sdata,
 		}
 		break;
 	default:
-		/* should not happen, sta_flags should prevent VHT modes. */
+		/* should not happen, conn_flags should prevent VHT modes. */
 		WARN_ON(1);
 		goto disconnect;
 	}
* Unmerged path net/mac80211/ieee80211_i.h
diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c
index 5b1e1fde82db..5e3b7e53c824 100644
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -1128,7 +1128,8 @@ ieee80211_mesh_process_chnswitch(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
 	struct ieee80211_supported_band *sband;
 	int err;
-	u32 sta_flags, vht_cap_info = 0;
+	ieee80211_conn_flags_t conn_flags = 0;
+	u32 vht_cap_info = 0;
 
 	sdata_assert_lock(sdata);
 
@@ -1136,16 +1137,15 @@ ieee80211_mesh_process_chnswitch(struct ieee80211_sub_if_data *sdata,
 	if (!sband)
 		return false;
 
-	sta_flags = 0;
 	switch (sdata->vif.bss_conf.chandef.width) {
 	case NL80211_CHAN_WIDTH_20_NOHT:
-		sta_flags |= IEEE80211_STA_DISABLE_HT;
+		conn_flags |= IEEE80211_CONN_DISABLE_HT;
 		fallthrough;
 	case NL80211_CHAN_WIDTH_20:
-		sta_flags |= IEEE80211_STA_DISABLE_40MHZ;
+		conn_flags |= IEEE80211_CONN_DISABLE_40MHZ;
 		fallthrough;
 	case NL80211_CHAN_WIDTH_40:
-		sta_flags |= IEEE80211_STA_DISABLE_VHT;
+		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
 		break;
 	default:
 		break;
@@ -1158,7 +1158,7 @@ ieee80211_mesh_process_chnswitch(struct ieee80211_sub_if_data *sdata,
 	memset(&params, 0, sizeof(params));
 	err = ieee80211_parse_ch_switch_ie(sdata, elems, sband->band,
 					   vht_cap_info,
-					   sta_flags, sdata->vif.addr,
+					   conn_flags, sdata->vif.addr,
 					   &csa_ie);
 	if (err < 0)
 		return false;
* Unmerged path net/mac80211/mlme.c
diff --git a/net/mac80211/spectmgmt.c b/net/mac80211/spectmgmt.c
index 76747bfdaddd..871cdac2d0f4 100644
--- a/net/mac80211/spectmgmt.c
+++ b/net/mac80211/spectmgmt.c
@@ -9,7 +9,7 @@
  * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
  * Copyright 2007-2008, Intel Corporation
  * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
- * Copyright (C) 2018, 2020 Intel Corporation
+ * Copyright (C) 2018, 2020, 2022 Intel Corporation
  */
 
 #include <linux/ieee80211.h>
@@ -23,7 +23,7 @@ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
 				 struct ieee802_11_elems *elems,
 				 enum nl80211_band current_band,
 				 u32 vht_cap_info,
-				 u32 sta_flags, u8 *bssid,
+				 ieee80211_conn_flags_t conn_flags, u8 *bssid,
 				 struct ieee80211_csa_ie *csa_ie)
 {
 	enum nl80211_band new_band = current_band;
@@ -40,13 +40,13 @@ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
 	sec_chan_offs = elems->sec_chan_offs;
 	wide_bw_chansw_ie = elems->wide_bw_chansw_ie;
 
-	if (sta_flags & (IEEE80211_STA_DISABLE_HT |
-			 IEEE80211_STA_DISABLE_40MHZ)) {
+	if (conn_flags & (IEEE80211_CONN_DISABLE_HT |
+			  IEEE80211_CONN_DISABLE_40MHZ)) {
 		sec_chan_offs = NULL;
 		wide_bw_chansw_ie = NULL;
 	}
 
-	if (sta_flags & IEEE80211_STA_DISABLE_VHT)
+	if (conn_flags & IEEE80211_CONN_DISABLE_VHT)
 		wide_bw_chansw_ie = NULL;
 
 	if (elems->ext_chansw_ie) {
@@ -93,7 +93,7 @@ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
 
 	if (sec_chan_offs) {
 		secondary_channel_offset = sec_chan_offs->sec_chan_offs;
-	} else if (!(sta_flags & IEEE80211_STA_DISABLE_HT)) {
+	} else if (!(conn_flags & IEEE80211_CONN_DISABLE_HT)) {
 		/* If the secondary channel offset IE is not present,
 		 * we can't know what's the post-CSA offset, so the
 		 * best we can do is use 20MHz.
@@ -160,10 +160,10 @@ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
 						&new_vht_chandef))
 			new_vht_chandef.chan = NULL;
 
-		if (sta_flags & IEEE80211_STA_DISABLE_80P80MHZ &&
+		if (conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ &&
 		    new_vht_chandef.width == NL80211_CHAN_WIDTH_80P80)
 			ieee80211_chandef_downgrade(&new_vht_chandef);
-		if (sta_flags & IEEE80211_STA_DISABLE_160MHZ &&
+		if (conn_flags & IEEE80211_CONN_DISABLE_160MHZ &&
 		    new_vht_chandef.width == NL80211_CHAN_WIDTH_160)
 			ieee80211_chandef_downgrade(&new_vht_chandef);
 	}
diff --git a/net/mac80211/tdls.c b/net/mac80211/tdls.c
index 601011867929..f37b4399b4c2 100644
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@ -1310,7 +1310,6 @@ static void
 iee80211_tdls_recalc_ht_protection(struct ieee80211_sub_if_data *sdata,
 				   struct sta_info *sta)
 {
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 	bool tdls_ht;
 	u16 protection = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED |
 			 IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |
@@ -1318,7 +1317,7 @@ iee80211_tdls_recalc_ht_protection(struct ieee80211_sub_if_data *sdata,
 	u16 opmode;
 
 	/* Nothing to do if the BSS connection uses HT */
-	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
+	if (!(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
 		return;
 
 	tdls_ht = (sta && sta->sta.ht_cap.ht_supported) ||
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index dc161cdfe440..2a179fd85d73 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -2933,7 +2933,7 @@ u8 ieee80211_ie_len_he_cap(struct ieee80211_sub_if_data *sdata, u8 iftype)
 				     he_cap->he_cap_elem.phy_cap_info);
 }
 
-u8 *ieee80211_ie_build_he_cap(u32 disable_flags, u8 *pos,
+u8 *ieee80211_ie_build_he_cap(ieee80211_conn_flags_t disable_flags, u8 *pos,
 			      const struct ieee80211_sta_he_cap *he_cap,
 			      u8 *end)
 {
@@ -2953,16 +2953,16 @@ u8 *ieee80211_ie_build_he_cap(u32 disable_flags, u8 *pos,
 	/* modify on stack first to calculate 'n' and 'ie_len' correctly */
 	elem = he_cap->he_cap_elem;
 
-	if (disable_flags & IEEE80211_STA_DISABLE_40MHZ)
+	if (disable_flags & IEEE80211_CONN_DISABLE_40MHZ)
 		elem.phy_cap_info[0] &=
 			~(IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
 			  IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G);
 
-	if (disable_flags & IEEE80211_STA_DISABLE_160MHZ)
+	if (disable_flags & IEEE80211_CONN_DISABLE_160MHZ)
 		elem.phy_cap_info[0] &=
 			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
 
-	if (disable_flags & IEEE80211_STA_DISABLE_80P80MHZ)
+	if (disable_flags & IEEE80211_CONN_DISABLE_80P80MHZ)
 		elem.phy_cap_info[0] &=
 			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
 
@@ -4053,21 +4053,21 @@ void ieee80211_radar_detected(struct ieee80211_hw *hw)
 }
 EXPORT_SYMBOL(ieee80211_radar_detected);
 
-u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
+ieee80211_conn_flags_t ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
 {
-	u32 ret;
+	ieee80211_conn_flags_t ret;
 	int tmp;
 
 	switch (c->width) {
 	case NL80211_CHAN_WIDTH_20:
 		c->width = NL80211_CHAN_WIDTH_20_NOHT;
-		ret = IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_VHT;
+		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;
 		break;
 	case NL80211_CHAN_WIDTH_40:
 		c->width = NL80211_CHAN_WIDTH_20;
 		c->center_freq1 = c->chan->center_freq;
-		ret = IEEE80211_STA_DISABLE_40MHZ |
-		      IEEE80211_STA_DISABLE_VHT;
+		ret = IEEE80211_CONN_DISABLE_40MHZ |
+		      IEEE80211_CONN_DISABLE_VHT;
 		break;
 	case NL80211_CHAN_WIDTH_80:
 		tmp = (30 + c->chan->center_freq - c->center_freq1)/20;
@@ -4076,13 +4076,13 @@ u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
 		/* freq_P40 */
 		c->center_freq1 = c->center_freq1 - 20 + 40 * tmp;
 		c->width = NL80211_CHAN_WIDTH_40;
-		ret = IEEE80211_STA_DISABLE_VHT;
+		ret = IEEE80211_CONN_DISABLE_VHT;
 		break;
 	case NL80211_CHAN_WIDTH_80P80:
 		c->center_freq2 = 0;
 		c->width = NL80211_CHAN_WIDTH_80;
-		ret = IEEE80211_STA_DISABLE_80P80MHZ |
-		      IEEE80211_STA_DISABLE_160MHZ;
+		ret = IEEE80211_CONN_DISABLE_80P80MHZ |
+		      IEEE80211_CONN_DISABLE_160MHZ;
 		break;
 	case NL80211_CHAN_WIDTH_160:
 		/* n_P20 */
@@ -4091,8 +4091,8 @@ u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
 		tmp /= 4;
 		c->center_freq1 = c->center_freq1 - 40 + 80 * tmp;
 		c->width = NL80211_CHAN_WIDTH_80;
-		ret = IEEE80211_STA_DISABLE_80P80MHZ |
-		      IEEE80211_STA_DISABLE_160MHZ;
+		ret = IEEE80211_CONN_DISABLE_80P80MHZ |
+		      IEEE80211_CONN_DISABLE_160MHZ;
 		break;
 	case NL80211_CHAN_WIDTH_320:
 		/* n_P20 */
@@ -4101,13 +4101,13 @@ u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
 		tmp /= 8;
 		c->center_freq1 = c->center_freq1 - 80 + 160 * tmp;
 		c->width = NL80211_CHAN_WIDTH_160;
-		ret = IEEE80211_STA_DISABLE_320MHZ;
+		ret = IEEE80211_CONN_DISABLE_320MHZ;
 		break;
 	default:
 	case NL80211_CHAN_WIDTH_20_NOHT:
 		WARN_ON_ONCE(1);
 		c->width = NL80211_CHAN_WIDTH_20_NOHT;
-		ret = IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_VHT;
+		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;
 		break;
 	case NL80211_CHAN_WIDTH_1:
 	case NL80211_CHAN_WIDTH_2:
@@ -4118,7 +4118,7 @@ u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
 	case NL80211_CHAN_WIDTH_10:
 		WARN_ON_ONCE(1);
 		/* keep c->width */
-		ret = IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_VHT;
+		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;
 		break;
 	}
 
