md/raid5: Cleanup prototype of raid5_get_active_stripe()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Logan Gunthorpe <logang@deltatee.com>
commit 2f2d51efd83225c1eb0d7771ddfe9fddd5ccd378
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2f2d51ef.failed

Drop the three bools in the prototype of raid5_get_active_stripe()
and replace them with a flags parameter.

At the same time, drop the distinction with __raid5_get_active_stripe().

	Suggested-by: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
	Signed-off-by: Song Liu <song@kernel.org>
(cherry picked from commit 2f2d51efd83225c1eb0d7771ddfe9fddd5ccd378)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
#	drivers/md/raid5.h
diff --cc drivers/md/raid5.c
index 74dbb79ad46f,84f941843364..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -763,9 -755,54 +763,60 @@@ static bool has_failed(struct r5conf *c
  	return degraded > conf->max_degraded;
  }
  
++<<<<<<< HEAD
 +struct stripe_head *
 +raid5_get_active_stripe(struct r5conf *conf, sector_t sector,
 +			int previous, int noblock, int noquiesce)
++=======
+ enum stripe_result {
+ 	STRIPE_SUCCESS = 0,
+ 	STRIPE_RETRY,
+ 	STRIPE_SCHEDULE_AND_RETRY,
+ 	STRIPE_FAIL,
+ };
+ 
+ struct stripe_request_ctx {
+ 	/* a reference to the last stripe_head for batching */
+ 	struct stripe_head *batch_last;
+ 
+ 	/* first sector in the request */
+ 	sector_t first_sector;
+ 
+ 	/* last sector in the request */
+ 	sector_t last_sector;
+ 
+ 	/*
+ 	 * bitmap to track stripe sectors that have been added to stripes
+ 	 * add one to account for unaligned requests
+ 	 */
+ 	DECLARE_BITMAP(sectors_to_do, RAID5_MAX_REQ_STRIPES + 1);
+ 
+ 	/* the request had REQ_PREFLUSH, cleared after the first stripe_head */
+ 	bool do_flush;
+ };
+ 
+ /*
+  * Block until another thread clears R5_INACTIVE_BLOCKED or
+  * there are fewer than 3/4 the maximum number of active stripes
+  * and there is an inactive stripe available.
+  */
+ static bool is_inactive_blocked(struct r5conf *conf, int hash)
+ {
+ 	int active = atomic_read(&conf->active_stripes);
+ 
+ 	if (list_empty(conf->inactive_list + hash))
+ 		return false;
+ 
+ 	if (!test_bit(R5_INACTIVE_BLOCKED, &conf->cache_state))
+ 		return true;
+ 
+ 	return active < (conf->max_nr_stripes * 3 / 4);
+ }
+ 
+ struct stripe_head *raid5_get_active_stripe(struct r5conf *conf,
+ 		struct stripe_request_ctx *ctx, sector_t sector,
+ 		unsigned int flags)
++>>>>>>> 2f2d51efd832 (md/raid5: Cleanup prototype of raid5_get_active_stripe())
  {
  	struct stripe_head *sh;
  	int hash = stripe_hash_locks_hash(conf, sector);
@@@ -774,46 -812,54 +826,92 @@@
  
  	spin_lock_irq(conf->hash_locks + hash);
  
++<<<<<<< HEAD
 +retry:
 +	wait_event_lock_irq(conf->wait_for_quiescent,
 +			    conf->quiesce == 0 || noquiesce,
 +			    *(conf->hash_locks + hash));
 +	sh = find_get_stripe(conf, sector, conf->generation - previous, hash);
 +	if (sh)
 +		goto out;
++=======
+ 	for (;;) {
+ 		if (!(flags & R5_GAS_NOQUIESCE) && conf->quiesce) {
+ 			/*
+ 			 * Must release the reference to batch_last before
+ 			 * waiting, on quiesce, otherwise the batch_last will
+ 			 * hold a reference to a stripe and raid5_quiesce()
+ 			 * will deadlock waiting for active_stripes to go to
+ 			 * zero.
+ 			 */
+ 			if (ctx && ctx->batch_last) {
+ 				raid5_release_stripe(ctx->batch_last);
+ 				ctx->batch_last = NULL;
+ 			}
++>>>>>>> 2f2d51efd832 (md/raid5: Cleanup prototype of raid5_get_active_stripe())
  
 -			wait_event_lock_irq(conf->wait_for_quiescent,
 -					    !conf->quiesce,
 -					    *(conf->hash_locks + hash));
 -		}
 +	if (test_bit(R5_INACTIVE_BLOCKED, &conf->cache_state))
 +		goto wait_for_stripe;
  
++<<<<<<< HEAD
 +	sh = get_free_stripe(conf, hash);
 +	if (sh) {
 +		r5c_check_stripe_cache_usage(conf);
 +		init_stripe(sh, sector, previous);
 +		atomic_inc(&sh->count);
 +		goto out;
++=======
+ 		sh = find_get_stripe(conf, sector, conf->generation - previous,
+ 				     hash);
+ 		if (sh)
+ 			break;
+ 
+ 		if (!test_bit(R5_INACTIVE_BLOCKED, &conf->cache_state)) {
+ 			sh = get_free_stripe(conf, hash);
+ 			if (sh) {
+ 				r5c_check_stripe_cache_usage(conf);
+ 				init_stripe(sh, sector, previous);
+ 				atomic_inc(&sh->count);
+ 				break;
+ 			}
+ 
+ 			if (!test_bit(R5_DID_ALLOC, &conf->cache_state))
+ 				set_bit(R5_ALLOC_MORE, &conf->cache_state);
+ 		}
+ 
+ 		if (flags & R5_GAS_NOBLOCK)
+ 			break;
+ 
+ 		set_bit(R5_INACTIVE_BLOCKED, &conf->cache_state);
+ 		r5l_wake_reclaim(conf->log, 0);
+ 		wait_event_lock_irq(conf->wait_for_stripe,
+ 				    is_inactive_blocked(conf, hash),
+ 				    *(conf->hash_locks + hash));
+ 		clear_bit(R5_INACTIVE_BLOCKED, &conf->cache_state);
++>>>>>>> 2f2d51efd832 (md/raid5: Cleanup prototype of raid5_get_active_stripe())
  	}
  
 +	if (!test_bit(R5_DID_ALLOC, &conf->cache_state))
 +		set_bit(R5_ALLOC_MORE, &conf->cache_state);
 +
 +wait_for_stripe:
 +	if (noblock)
 +		goto out;
 +
 +	r5c_check_stripe_cache_usage(conf);
 +	set_bit(R5_INACTIVE_BLOCKED, &conf->cache_state);
 +	r5l_wake_reclaim(conf->log, 0);
 +	wait_event_lock_irq(conf->wait_for_stripe,
 +			    !list_empty(conf->inactive_list + hash) &&
 +			    (atomic_read(&conf->active_stripes)
 +				  < (conf->max_nr_stripes * 3 / 4)
 +				 || !test_bit(R5_INACTIVE_BLOCKED,
 +					      &conf->cache_state)),
 +			    *(conf->hash_locks + hash));
 +	clear_bit(R5_INACTIVE_BLOCKED, &conf->cache_state);
 +	goto retry;
 +
 +out:
  	spin_unlock_irq(conf->hash_locks + hash);
  	return sh;
  }
@@@ -5998,8 -6009,11 +6099,16 @@@ static enum stripe_result make_stripe_r
  	pr_debug("raid456: %s, sector %llu logical %llu\n", __func__,
  		 new_sector, logical_sector);
  
++<<<<<<< HEAD
 +	sh = raid5_get_active_stripe(conf, new_sector, previous,
 +				     (bi->bi_opf & REQ_RAHEAD), 0);
++=======
+ 	if (previous)
+ 		flags |= R5_GAS_PREVIOUS;
+ 	if (bi->bi_opf & REQ_RAHEAD)
+ 		flags |= R5_GAS_NOBLOCK;
+ 	sh = raid5_get_active_stripe(conf, ctx, new_sector, flags);
++>>>>>>> 2f2d51efd832 (md/raid5: Cleanup prototype of raid5_get_active_stripe())
  	if (unlikely(!sh)) {
  		/* cannot get stripe, just give-up */
  		bi->bi_status = BLK_STS_IOERR;
diff --cc drivers/md/raid5.h
index 13bde70c396c,e873938a6125..000000000000
--- a/drivers/md/raid5.h
+++ b/drivers/md/raid5.h
@@@ -803,16 -803,24 +803,39 @@@ raid5_get_dev_page(struct stripe_head *
  }
  #endif
  
++<<<<<<< HEAD
 +extern void md_raid5_kick_device(struct r5conf *conf);
 +extern int raid5_set_cache_size(struct mddev *mddev, int size);
 +extern sector_t raid5_compute_blocknr(struct stripe_head *sh, int i, int previous);
 +extern void raid5_release_stripe(struct stripe_head *sh);
 +extern sector_t raid5_compute_sector(struct r5conf *conf, sector_t r_sector,
 +				     int previous, int *dd_idx,
 +				     struct stripe_head *sh);
 +extern struct stripe_head *
 +raid5_get_active_stripe(struct r5conf *conf, sector_t sector,
 +			int previous, int noblock, int noquiesce);
 +extern int raid5_calc_degraded(struct r5conf *conf);
 +extern int r5c_journal_mode_set(struct mddev *mddev, int journal_mode);
++=======
+ void md_raid5_kick_device(struct r5conf *conf);
+ int raid5_set_cache_size(struct mddev *mddev, int size);
+ sector_t raid5_compute_blocknr(struct stripe_head *sh, int i, int previous);
+ void raid5_release_stripe(struct stripe_head *sh);
+ sector_t raid5_compute_sector(struct r5conf *conf, sector_t r_sector,
+ 		int previous, int *dd_idx, struct stripe_head *sh);
+ 
+ struct stripe_request_ctx;
+ /* get stripe from previous generation (when reshaping) */
+ #define R5_GAS_PREVIOUS		(1 << 0)
+ /* do not block waiting for a free stripe */
+ #define R5_GAS_NOBLOCK		(1 << 1)
+ /* do not block waiting for quiesce to be released */
+ #define R5_GAS_NOQUIESCE	(1 << 2)
+ struct stripe_head *raid5_get_active_stripe(struct r5conf *conf,
+ 		struct stripe_request_ctx *ctx, sector_t sector,
+ 		unsigned int flags);
+ 
+ int raid5_calc_degraded(struct r5conf *conf);
+ int r5c_journal_mode_set(struct mddev *mddev, int journal_mode);
++>>>>>>> 2f2d51efd832 (md/raid5: Cleanup prototype of raid5_get_active_stripe())
  #endif
diff --git a/drivers/md/raid5-cache.c b/drivers/md/raid5-cache.c
index 0700ffd65552..1c69f548ed7b 100644
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@ -1935,7 +1935,8 @@ r5c_recovery_alloc_stripe(
 {
 	struct stripe_head *sh;
 
-	sh = raid5_get_active_stripe(conf, stripe_sect, 0, noblock, 0);
+	sh = raid5_get_active_stripe(conf, NULL, stripe_sect,
+				     noblock ? R5_GAS_NOBLOCK : 0);
 	if (!sh)
 		return NULL;  /* no more stripe available */
 
* Unmerged path drivers/md/raid5.c
* Unmerged path drivers/md/raid5.h
