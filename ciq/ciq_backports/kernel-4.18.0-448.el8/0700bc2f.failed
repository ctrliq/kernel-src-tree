ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Simon Trimmer <simont@opensource.cirrus.com>
commit 0700bc2fb94c28459f57a10d2ee2c7ef4cb70862
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0700bc2f.failed

This is preparation for moving the generic DSP support out of ASoC. The
majority of the handling of firmware controls is generic and this change
separates the generic and ASoC specific details into separate structures
and functions and renames the generic code named wm_* to cs_*.

	Signed-off-by: Simon Trimmer <simont@opensource.cirrus.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20210913160057.103842-11-simont@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 0700bc2fb94c28459f57a10d2ee2c7ef4cb70862)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
diff --cc sound/soc/codecs/wm_adsp.c
index c1b5ea3b5718,bd335e4240e5..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -598,21 -607,8 +598,23 @@@ static const struct 
  
  struct wm_coeff_ctl {
  	const char *name;
++<<<<<<< HEAD
 +	const char *fw_name;
 +	/* Subname is needed to match with firmware */
 +	const char *subname;
 +	unsigned int subname_len;
 +	struct wm_adsp_alg_region alg_region;
 +	struct wm_adsp *dsp;
 +	unsigned int enabled:1;
 +	struct list_head list;
 +	void *cache;
 +	unsigned int offset;
 +	size_t len;
 +	unsigned int set:1;
++=======
+ 	struct cs_dsp_coeff_ctl *cs_ctl;
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  	struct soc_bytes_ext bytes_ext;
- 	unsigned int flags;
- 	unsigned int type;
  	struct work_struct work;
  };
  
@@@ -929,16 -925,16 +931,20 @@@ static inline struct wm_coeff_ctl *byte
  	return container_of(ext, struct wm_coeff_ctl, bytes_ext);
  }
  
++<<<<<<< HEAD
 +static int wm_coeff_base_reg(struct wm_coeff_ctl *ctl, unsigned int *reg)
++=======
+ static int cs_dsp_coeff_base_reg(struct cs_dsp_coeff_ctl *ctl, unsigned int *reg)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
 -	const struct cs_dsp_alg_region *alg_region = &ctl->alg_region;
 +	const struct wm_adsp_alg_region *alg_region = &ctl->alg_region;
  	struct wm_adsp *dsp = ctl->dsp;
 -	const struct cs_dsp_region *mem;
 +	const struct wm_adsp_region *mem;
  
 -	mem = cs_dsp_find_region(dsp, alg_region->type);
 +	mem = wm_adsp_find_region(dsp, alg_region->type);
  	if (!mem) {
 -		cs_dsp_err(dsp, "No base for region %x\n",
 -			   alg_region->type);
 +		adsp_err(dsp, "No base for region %x\n",
 +			 alg_region->type);
  		return -EINVAL;
  	}
  
@@@ -953,12 -949,13 +959,13 @@@ static int wm_coeff_info(struct snd_kco
  	struct soc_bytes_ext *bytes_ext =
  		(struct soc_bytes_ext *)kctl->private_value;
  	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
+ 	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
  
- 	switch (ctl->type) {
+ 	switch (cs_ctl->type) {
  	case WMFW_CTL_TYPE_ACKED:
  		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 -		uinfo->value.integer.min = CS_DSP_ACKED_CTL_MIN_VALUE;
 -		uinfo->value.integer.max = CS_DSP_ACKED_CTL_MAX_VALUE;
 +		uinfo->value.integer.min = WM_ADSP_ACKED_CTL_MIN_VALUE;
 +		uinfo->value.integer.max = WM_ADSP_ACKED_CTL_MAX_VALUE;
  		uinfo->value.integer.step = 1;
  		uinfo->count = 1;
  		break;
@@@ -971,8 -968,8 +978,13 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int wm_coeff_write_acked_control(struct wm_coeff_ctl *ctl,
 +					unsigned int event_id)
++=======
+ static int cs_dsp_coeff_write_acked_control(struct cs_dsp_coeff_ctl *ctl,
+ 					    unsigned int event_id)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
  	struct wm_adsp *dsp = ctl->dsp;
  	__be32 val = cpu_to_be32(event_id);
@@@ -1031,8 -1028,8 +1043,13 @@@
  	return -ETIMEDOUT;
  }
  
++<<<<<<< HEAD
 +static int wm_coeff_write_ctrl_raw(struct wm_coeff_ctl *ctl,
 +				   const void *buf, size_t len)
++=======
+ static int cs_dsp_coeff_write_ctrl_raw(struct cs_dsp_coeff_ctl *ctl,
+ 				       const void *buf, size_t len)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
  	struct wm_adsp *dsp = ctl->dsp;
  	void *scratch;
@@@ -1062,8 -1059,8 +1079,13 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int wm_coeff_write_ctrl(struct wm_coeff_ctl *ctl,
 +			       const void *buf, size_t len)
++=======
+ static int cs_dsp_coeff_write_ctrl(struct cs_dsp_coeff_ctl *ctl,
+ 				   const void *buf, size_t len)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
  	int ret = 0;
  
@@@ -1088,9 -1086,9 +1111,15 @@@ static int wm_coeff_put(struct snd_kcon
  	char *p = ucontrol->value.bytes.data;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&ctl->dsp->pwr_lock);
 +	ret = wm_coeff_write_ctrl(ctl, p, ctl->len);
 +	mutex_unlock(&ctl->dsp->pwr_lock);
++=======
+ 	mutex_lock(&cs_ctl->dsp->pwr_lock);
+ 	ret = cs_dsp_coeff_write_ctrl(cs_ctl, p, cs_ctl->len);
+ 	mutex_unlock(&cs_ctl->dsp->pwr_lock);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  
  	return ret;
  }
@@@ -1101,16 -1099,17 +1130,21 @@@ static int wm_coeff_tlv_put(struct snd_
  	struct soc_bytes_ext *bytes_ext =
  		(struct soc_bytes_ext *)kctl->private_value;
  	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
+ 	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
  	int ret = 0;
  
- 	mutex_lock(&ctl->dsp->pwr_lock);
+ 	mutex_lock(&cs_ctl->dsp->pwr_lock);
  
- 	if (copy_from_user(ctl->cache, bytes, size))
+ 	if (copy_from_user(cs_ctl->cache, bytes, size))
  		ret = -EFAULT;
  	else
++<<<<<<< HEAD
 +		ret = wm_coeff_write_ctrl(ctl, ctl->cache, size);
++=======
+ 		ret = cs_dsp_coeff_write_ctrl(cs_ctl, cs_ctl->cache, size);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  
- 	mutex_unlock(&ctl->dsp->pwr_lock);
+ 	mutex_unlock(&cs_ctl->dsp->pwr_lock);
  
  	return ret;
  }
@@@ -1127,10 -1127,10 +1162,15 @@@ static int wm_coeff_put_acked(struct sn
  	if (val == 0)
  		return 0;	/* 0 means no event */
  
- 	mutex_lock(&ctl->dsp->pwr_lock);
+ 	mutex_lock(&cs_ctl->dsp->pwr_lock);
  
++<<<<<<< HEAD
 +	if (ctl->enabled && ctl->dsp->running)
 +		ret = wm_coeff_write_acked_control(ctl, val);
++=======
+ 	if (cs_ctl->enabled && cs_ctl->dsp->running)
+ 		ret = cs_dsp_coeff_write_acked_control(cs_ctl, val);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  	else
  		ret = -EPERM;
  
@@@ -1139,8 -1139,8 +1179,13 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int wm_coeff_read_ctrl_raw(struct wm_coeff_ctl *ctl,
 +				  void *buf, size_t len)
++=======
+ static int cs_dsp_coeff_read_ctrl_raw(struct cs_dsp_coeff_ctl *ctl,
+ 				      void *buf, size_t len)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
  	struct wm_adsp *dsp = ctl->dsp;
  	void *scratch;
@@@ -1170,7 -1170,7 +1215,11 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int wm_coeff_read_ctrl(struct wm_coeff_ctl *ctl, void *buf, size_t len)
++=======
+ static int cs_dsp_coeff_read_ctrl(struct cs_dsp_coeff_ctl *ctl, void *buf, size_t len)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
  	int ret = 0;
  
@@@ -1199,9 -1200,9 +1249,15 @@@ static int wm_coeff_get(struct snd_kcon
  	char *p = ucontrol->value.bytes.data;
  	int ret;
  
++<<<<<<< HEAD
 +	mutex_lock(&ctl->dsp->pwr_lock);
 +	ret = wm_coeff_read_ctrl(ctl, p, ctl->len);
 +	mutex_unlock(&ctl->dsp->pwr_lock);
++=======
+ 	mutex_lock(&cs_ctl->dsp->pwr_lock);
+ 	ret = cs_dsp_coeff_read_ctrl(cs_ctl, p, cs_ctl->len);
+ 	mutex_unlock(&cs_ctl->dsp->pwr_lock);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  
  	return ret;
  }
@@@ -1212,16 -1213,17 +1268,21 @@@ static int wm_coeff_tlv_get(struct snd_
  	struct soc_bytes_ext *bytes_ext =
  		(struct soc_bytes_ext *)kctl->private_value;
  	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
+ 	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
  	int ret = 0;
  
- 	mutex_lock(&ctl->dsp->pwr_lock);
+ 	mutex_lock(&cs_ctl->dsp->pwr_lock);
  
++<<<<<<< HEAD
 +	ret = wm_coeff_read_ctrl(ctl, ctl->cache, size);
++=======
+ 	ret = cs_dsp_coeff_read_ctrl(cs_ctl, cs_ctl->cache, size);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  
- 	if (!ret && copy_to_user(bytes, ctl->cache, size))
+ 	if (!ret && copy_to_user(bytes, cs_ctl->cache, size))
  		ret = -EFAULT;
  
- 	mutex_unlock(&ctl->dsp->pwr_lock);
+ 	mutex_unlock(&cs_ctl->dsp->pwr_lock);
  
  	return ret;
  }
@@@ -1321,9 -1321,9 +1380,9 @@@ err_kcontrol
  	return ret;
  }
  
 -static int cs_dsp_coeff_init_control_caches(struct wm_adsp *dsp)
 +static int wm_coeff_init_control_caches(struct wm_adsp *dsp)
  {
- 	struct wm_coeff_ctl *ctl;
+ 	struct cs_dsp_coeff_ctl *ctl;
  	int ret;
  
  	list_for_each_entry(ctl, &dsp->ctl_list, list) {
@@@ -1347,9 -1347,9 +1406,9 @@@
  	return 0;
  }
  
 -static int cs_dsp_coeff_sync_controls(struct wm_adsp *dsp)
 +static int wm_coeff_sync_controls(struct wm_adsp *dsp)
  {
- 	struct wm_coeff_ctl *ctl;
+ 	struct cs_dsp_coeff_ctl *ctl;
  	int ret;
  
  	list_for_each_entry(ctl, &dsp->ctl_list, list) {
@@@ -1366,10 -1366,10 +1425,10 @@@
  	return 0;
  }
  
 -static void cs_dsp_signal_event_controls(struct wm_adsp *dsp,
 +static void wm_adsp_signal_event_controls(struct wm_adsp *dsp,
  					  unsigned int event)
  {
- 	struct wm_coeff_ctl *ctl;
+ 	struct cs_dsp_coeff_ctl *ctl;
  	int ret;
  
  	list_for_each_entry(ctl, &dsp->ctl_list, list) {
@@@ -1392,29 -1392,107 +1451,111 @@@ static void wm_adsp_ctl_work(struct wor
  	struct wm_coeff_ctl *ctl = container_of(work,
  						struct wm_coeff_ctl,
  						work);
- 
- 	wmfw_add_ctl(ctl->dsp, ctl);
+ 	wmfw_add_ctl(ctl->cs_ctl->dsp, ctl);
  }
  
++<<<<<<< HEAD
 +static void wm_adsp_free_ctl_blk(struct wm_coeff_ctl *ctl)
++=======
+ static void cs_dsp_free_ctl_blk(struct cs_dsp_coeff_ctl *ctl)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
+ {
+ 	kfree(ctl->cache);
+ 	kfree(ctl->subname);
+ 	kfree(ctl);
+ }
+ 
+ static int wm_adsp_control_add(struct cs_dsp_coeff_ctl *cs_ctl)
+ {
+ 	struct wm_adsp *dsp = cs_ctl->dsp;
+ 	struct wm_coeff_ctl *ctl;
+ 	char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+ 	const char *region_name;
+ 	int ret;
+ 
+ 	if (cs_ctl->flags & WMFW_CTL_FLAG_SYS)
+ 		return 0;
+ 
+ 	region_name = cs_dsp_mem_region_name(cs_ctl->alg_region.type);
+ 	if (!region_name) {
+ 		adsp_err(dsp, "Unknown region type: %d\n", cs_ctl->alg_region.type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (dsp->fw_ver) {
+ 	case 0:
+ 	case 1:
+ 		snprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s %s %x",
+ 			 dsp->name, region_name, cs_ctl->alg_region.alg);
+ 		break;
+ 	case 2:
+ 		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
+ 				"%s%c %.12s %x", dsp->name, *region_name,
+ 				wm_adsp_fw_text[dsp->fw], cs_ctl->alg_region.alg);
+ 		break;
+ 	default:
+ 		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
+ 				"%s %.12s %x", dsp->name,
+ 				wm_adsp_fw_text[dsp->fw], cs_ctl->alg_region.alg);
+ 		break;
+ 	}
+ 
+ 	if (cs_ctl->subname) {
+ 		int avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;
+ 		int skip = 0;
+ 
+ 		if (dsp->component->name_prefix)
+ 			avail -= strlen(dsp->component->name_prefix) + 1;
+ 
+ 		/* Truncate the subname from the start if it is too long */
+ 		if (cs_ctl->subname_len > avail)
+ 			skip = cs_ctl->subname_len - avail;
+ 
+ 		snprintf(name + ret, SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret,
+ 			 " %.*s", cs_ctl->subname_len - skip, cs_ctl->subname + skip);
+ 	}
+ 
+ 	ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);
+ 	if (!ctl)
+ 		return -ENOMEM;
+ 	ctl->cs_ctl = cs_ctl;
+ 
+ 	ctl->name = kmemdup(name, strlen(name) + 1, GFP_KERNEL);
+ 	if (!ctl->name) {
+ 		ret = -ENOMEM;
+ 		goto err_ctl;
+ 	}
+ 
+ 	cs_ctl->priv = ctl;
+ 
+ 	INIT_WORK(&ctl->work, wm_adsp_ctl_work);
+ 	schedule_work(&ctl->work);
+ 
+ 	return 0;
+ 
+ err_ctl:
+ 	kfree(ctl);
+ 
+ 	return ret;
+ }
+ 
+ static void wm_adsp_control_remove(struct cs_dsp_coeff_ctl *cs_ctl)
  {
+ 	struct wm_coeff_ctl *ctl = cs_ctl->priv;
+ 
  	cancel_work_sync(&ctl->work);
  
- 	kfree(ctl->cache);
  	kfree(ctl->name);
- 	kfree(ctl->subname);
  	kfree(ctl);
  }
  
 -static int cs_dsp_create_control(struct wm_adsp *dsp,
 -				 const struct cs_dsp_alg_region *alg_region,
 -				 unsigned int offset, unsigned int len,
 -				 const char *subname, unsigned int subname_len,
 -				 unsigned int flags, unsigned int type)
 +static int wm_adsp_create_control(struct wm_adsp *dsp,
 +				  const struct wm_adsp_alg_region *alg_region,
 +				  unsigned int offset, unsigned int len,
 +				  const char *subname, unsigned int subname_len,
 +				  unsigned int flags, unsigned int type)
  {
- 	struct wm_coeff_ctl *ctl;
- 	char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
- 	const char *region_name;
+ 	struct cs_dsp_coeff_ctl *ctl;
  	int ret;
  
  	list_for_each_entry(ctl, &dsp->ctl_list, list) {
@@@ -1430,46 -1508,6 +1571,49 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	region_name = wm_adsp_mem_region_name(alg_region->type);
 +	if (!region_name) {
 +		adsp_err(dsp, "Unknown region type: %d\n", alg_region->type);
 +		return -EINVAL;
 +	}
 +
 +	switch (dsp->fw_ver) {
 +	case 0:
 +	case 1:
 +		snprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s %s %x",
 +			 dsp->name, region_name, alg_region->alg);
 +		subname = NULL; /* don't append subname */
 +		break;
 +	case 2:
 +		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
 +				"%s%c %.12s %x", dsp->name, *region_name,
 +				wm_adsp_fw_text[dsp->fw], alg_region->alg);
 +		break;
 +	default:
 +		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
 +				"%s %.12s %x", dsp->name,
 +				wm_adsp_fw_text[dsp->fw], alg_region->alg);
 +		break;
 +	}
 +
 +	if (subname) {
 +		int avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;
 +		int skip = 0;
 +
 +		if (dsp->component->name_prefix)
 +			avail -= strlen(dsp->component->name_prefix) + 1;
 +
 +		/* Truncate the subname from the start if it is too long */
 +		if (subname_len > avail)
 +			skip = subname_len - avail;
 +
 +		snprintf(name + ret, SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret,
 +			 " %.*s", subname_len - skip, subname + skip);
 +	}
 +
++=======
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  	ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);
  	if (!ctl)
  		return -ENOMEM;
@@@ -2004,14 -2036,14 +2142,20 @@@ out
  }
  
  /*
-  * Find wm_coeff_ctl with input name as its subname
+  * Find cs_dsp_coeff_ctl with input name as its subname
   * If not found, return NULL
   */
++<<<<<<< HEAD
 +static struct wm_coeff_ctl *wm_adsp_get_ctl(struct wm_adsp *dsp,
 +					     const char *name, int type,
 +					     unsigned int alg)
++=======
+ static struct cs_dsp_coeff_ctl *cs_dsp_get_ctl(struct wm_adsp *dsp,
+ 					       const char *name, int type,
+ 					       unsigned int alg)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  {
- 	struct wm_coeff_ctl *pos, *rslt = NULL;
+ 	struct cs_dsp_coeff_ctl *pos, *rslt = NULL;
  	const char *fw_txt = wm_adsp_fw_text[dsp->fw];
  
  	list_for_each_entry(pos, &dsp->ctl_list, list) {
@@@ -2037,14 -2070,16 +2182,25 @@@ int wm_adsp_write_ctl(struct wm_adsp *d
  	char ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
  	int ret;
  
++<<<<<<< HEAD
 +	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
 +	if (!ctl)
++=======
+ 	cs_ctl = cs_dsp_get_ctl(dsp, name, type, alg);
+ 	if (!cs_ctl)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  		return -EINVAL;
  
- 	if (len > ctl->len)
+ 	ctl = cs_ctl->priv;
+ 
+ 	if (len > cs_ctl->len)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	ret = wm_coeff_write_ctrl(ctl, buf, len);
++=======
+ 	ret = cs_dsp_coeff_write_ctrl(cs_ctl, buf, len);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  	if (ret)
  		return ret;
  
@@@ -2074,23 -2109,23 +2230,32 @@@ EXPORT_SYMBOL_GPL(wm_adsp_write_ctl)
  int wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,
  		     unsigned int alg, void *buf, size_t len)
  {
- 	struct wm_coeff_ctl *ctl;
+ 	struct cs_dsp_coeff_ctl *cs_ctl;
  
++<<<<<<< HEAD
 +	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
 +	if (!ctl)
++=======
+ 	cs_ctl = cs_dsp_get_ctl(dsp, name, type, alg);
+ 	if (!cs_ctl)
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  		return -EINVAL;
  
- 	if (len > ctl->len)
+ 	if (len > cs_ctl->len)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	return wm_coeff_read_ctrl(ctl, buf, len);
++=======
+ 	return cs_dsp_coeff_read_ctrl(cs_ctl, buf, len);
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  }
  EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
  
 -static void cs_dsp_ctl_fixup_base(struct wm_adsp *dsp,
 -				  const struct cs_dsp_alg_region *alg_region)
 +static void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,
 +				  const struct wm_adsp_alg_region *alg_region)
  {
- 	struct wm_coeff_ctl *ctl;
+ 	struct cs_dsp_coeff_ctl *ctl;
  
  	list_for_each_entry(ctl, &dsp->ctl_list, list) {
  		if (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&
@@@ -2898,6 -2906,57 +3063,60 @@@ err_ena
  			   ADSP1_SYS_ENA, 0);
  err_mutex:
  	mutex_unlock(&dsp->pwr_lock);
++<<<<<<< HEAD
++=======
+ 	return ret;
+ }
+ 
+ static void cs_dsp_adsp1_power_down(struct wm_adsp *dsp)
+ {
+ 	struct cs_dsp_coeff_ctl *ctl;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	dsp->running = false;
+ 	dsp->booted = false;
+ 
+ 	/* Halt the core */
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_CORE_ENA | ADSP1_START, 0);
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
+ 			   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_SYS_ENA, 0);
+ 
+ 	list_for_each_entry(ctl, &dsp->ctl_list, list)
+ 		ctl->enabled = 0;
+ 
+ 	cs_dsp_free_alg_regions(dsp);
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ }
+ 
+ int wm_adsp1_event(struct snd_soc_dapm_widget *w,
+ 		   struct snd_kcontrol *kcontrol,
+ 		   int event)
+ {
+ 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+ 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
+ 	struct wm_adsp *dsp = &dsps[w->shift];
+ 	int ret = 0;
+ 
+ 	dsp->component = component;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		ret = cs_dsp_adsp1_power_up(dsp);
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		cs_dsp_adsp1_power_down(dsp);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  
  	return ret;
  }
@@@ -3161,6 -3169,95 +3380,98 @@@ static void wm_halo_stop_watchdog(struc
  			   HALO_WDT_EN_MASK, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void cs_dsp_power_up(struct wm_adsp *dsp)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	if (dsp->ops->enable_memory) {
+ 		ret = dsp->ops->enable_memory(dsp);
+ 		if (ret != 0)
+ 			goto err_mutex;
+ 	}
+ 
+ 	if (dsp->ops->enable_core) {
+ 		ret = dsp->ops->enable_core(dsp);
+ 		if (ret != 0)
+ 			goto err_mem;
+ 	}
+ 
+ 	ret = cs_dsp_load(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = dsp->ops->setup_algs(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_load_coeff(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Initialize caches for enabled and unset controls */
+ 	ret = cs_dsp_coeff_init_control_caches(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	if (dsp->ops->disable_core)
+ 		dsp->ops->disable_core(dsp);
+ 
+ 	dsp->booted = true;
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	return;
+ 
+ err_ena:
+ 	if (dsp->ops->disable_core)
+ 		dsp->ops->disable_core(dsp);
+ err_mem:
+ 	if (dsp->ops->disable_memory)
+ 		dsp->ops->disable_memory(dsp);
+ err_mutex:
+ 	mutex_unlock(&dsp->pwr_lock);
+ }
+ 
+ static void cs_dsp_power_down(struct wm_adsp *dsp)
+ {
+ 	struct cs_dsp_coeff_ctl *ctl;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	cs_dsp_debugfs_clear(dsp);
+ 
+ 	dsp->fw_id = 0;
+ 	dsp->fw_id_version = 0;
+ 
+ 	dsp->booted = false;
+ 
+ 	if (dsp->ops->disable_memory)
+ 		dsp->ops->disable_memory(dsp);
+ 
+ 	list_for_each_entry(ctl, &dsp->ctl_list, list)
+ 		ctl->enabled = 0;
+ 
+ 	cs_dsp_free_alg_regions(dsp);
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	cs_dsp_dbg(dsp, "Shutdown complete\n");
+ }
+ 
+ static void wm_adsp_boot_work(struct work_struct *work)
+ {
+ 	struct wm_adsp *dsp = container_of(work,
+ 					   struct wm_adsp,
+ 					   boot_work);
+ 
+ 	cs_dsp_power_up(dsp);
+ }
+ 
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  int wm_adsp_early_event(struct snd_soc_dapm_widget *w,
  			struct snd_kcontrol *kcontrol, int event)
  {
@@@ -3412,17 -3520,24 +3723,19 @@@ int wm_halo_init(struct wm_adsp *dsp
  }
  EXPORT_SYMBOL_GPL(wm_halo_init);
  
 -static void cs_dsp_remove(struct wm_adsp *dsp)
 +void wm_adsp2_remove(struct wm_adsp *dsp)
  {
- 	struct wm_coeff_ctl *ctl;
+ 	struct cs_dsp_coeff_ctl *ctl;
  
  	while (!list_empty(&dsp->ctl_list)) {
- 		ctl = list_first_entry(&dsp->ctl_list, struct wm_coeff_ctl,
- 					list);
+ 		ctl = list_first_entry(&dsp->ctl_list, struct cs_dsp_coeff_ctl, list);
+ 
+ 		wm_adsp_control_remove(ctl);
+ 
  		list_del(&ctl->list);
 -		cs_dsp_free_ctl_blk(ctl);
 +		wm_adsp_free_ctl_blk(ctl);
  	}
  }
 -
 -void wm_adsp2_remove(struct wm_adsp *dsp)
 -{
 -	cs_dsp_remove(dsp);
 -}
  EXPORT_SYMBOL_GPL(wm_adsp2_remove);
  
  static inline int wm_adsp_compr_attached(struct wm_adsp_compr *compr)
@@@ -3857,7 -3973,7 +4171,11 @@@ static int wm_adsp_buffer_parse_coeff(s
  	int ret, i;
  
  	for (i = 0; i < 5; ++i) {
++<<<<<<< HEAD
 +		ret = wm_coeff_read_ctrl(ctl, &coeff_v1, sizeof(coeff_v1));
++=======
+ 		ret = cs_dsp_coeff_read_ctrl(cs_ctl, &coeff_v1, sizeof(coeff_v1));
++>>>>>>> 0700bc2fb94c (ASoC: wm_adsp: Separate generic cs_dsp_coeff_ctl handling)
  		if (ret < 0)
  			return ret;
  
@@@ -3902,9 -4018,9 +4220,9 @@@
  		return -EINVAL;
  	}
  
 -	cs_dsp_remove_padding((u32 *)&coeff_v1.name, ARRAY_SIZE(coeff_v1.name));
 +	wm_adsp_remove_padding((u32 *)&coeff_v1.name, ARRAY_SIZE(coeff_v1.name));
  
- 	buf->name = kasprintf(GFP_KERNEL, "%s-dsp-%s", ctl->dsp->part,
+ 	buf->name = kasprintf(GFP_KERNEL, "%s-dsp-%s", dsp->part,
  			      (char *)&coeff_v1.name);
  
  	compr_dbg(buf, "host_buf_ptr=%x coeff version %u\n",
* Unmerged path sound/soc/codecs/wm_adsp.c
diff --git a/sound/soc/codecs/wm_adsp.h b/sound/soc/codecs/wm_adsp.h
index f22131d9cc29..17954b8bb419 100644
--- a/sound/soc/codecs/wm_adsp.h
+++ b/sound/soc/codecs/wm_adsp.h
@@ -49,10 +49,30 @@ struct wm_adsp_alg_region {
 	unsigned int base;
 };
 
+struct wm_adsp;
 struct wm_adsp_compr;
 struct wm_adsp_compr_buf;
 struct wm_adsp_ops;
 
+struct cs_dsp_coeff_ctl {
+	const char *fw_name;
+	/* Subname is needed to match with firmware */
+	const char *subname;
+	unsigned int subname_len;
+	struct cs_dsp_alg_region alg_region;
+	struct wm_adsp *dsp;
+	unsigned int enabled:1;
+	struct list_head list;
+	void *cache;
+	unsigned int offset;
+	size_t len;
+	unsigned int set:1;
+	unsigned int flags;
+	unsigned int type;
+
+	void *priv;
+};
+
 struct wm_adsp {
 	const char *part;
 	const char *name;
