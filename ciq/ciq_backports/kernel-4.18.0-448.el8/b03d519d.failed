ice: store VF pointer instead of VF ID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit b03d519d3460f3aaf8b5afef582dd98466925352
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b03d519d.failed

The VSI structure contains a vf_id field used to associate a VSI with a
VF. This is used mainly for ICE_VSI_VF as well as partially for
ICE_VSI_CTRL associated with the VFs.

This API was designed with the idea that VFs are stored in a simple
array that was expected to be static throughout most of the driver's
life.

We plan on refactoring VF storage in a few key ways:

  1) converting from a simple static array to a hash table
  2) using krefs to track VF references obtained from the hash table
  3) use RCU to delay release of VF memory until after all references
     are dropped

This is motivated by the goal to ensure that the lifetime of VF
structures is accounted for, and prevent various use-after-free bugs.

With the existing vsi->vf_id, the reference tracking for VFs would
become somewhat convoluted, because each VSI maintains a vf_id field
which will then require performing a look up. This means all these flows
will require reference tracking and proper usage of rcu_read_lock, etc.

We know that the VF VSI will always be backed by a valid VF structure,
because the VSI is created during VF initialization and removed before
the VF is destroyed. Rely on this and store a reference to the VF in the
VSI structure instead of storing a VF ID. This will simplify the usage
and avoid the need to perform lookups on the hash table in the future.

For ICE_VSI_VF, it is expected that vsi->vf is always non-NULL after
ice_vsi_alloc succeeds. Because of this, use WARN_ON when checking if a
vsi->vf pointer is valid when dealing with VF VSIs. This will aid in
debugging code which violates this assumption and avoid more disastrous
panics.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Konrad Jankowski <konrad0.jankowski@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit b03d519d3460f3aaf8b5afef582dd98466925352)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_base.c
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_vf_vsi_vlan_ops.c
diff --cc drivers/net/ethernet/intel/ice/ice_base.c
index 1a5ece3bce79,a3094470d31d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_base.c
+++ b/drivers/net/ethernet/intel/ice/ice_base.c
@@@ -418,8 -419,22 +418,27 @@@ static int ice_setup_rx_ctx(struct ice_
  	 */
  	rlan_ctx.crcstrip = 1;
  
++<<<<<<< HEAD
 +	/* L2TSEL flag defines the reported L2 Tags in the receive descriptor */
 +	rlan_ctx.l2tsel = 1;
++=======
+ 	/* L2TSEL flag defines the reported L2 Tags in the receive descriptor
+ 	 * and it needs to remain 1 for non-DVM capable configurations to not
+ 	 * break backward compatibility for VF drivers. Setting this field to 0
+ 	 * will cause the single/outer VLAN tag to be stripped to the L2TAG2_2ND
+ 	 * field in the Rx descriptor. Setting it to 1 allows the VLAN tag to
+ 	 * be stripped in L2TAG1 of the Rx descriptor, which is where VFs will
+ 	 * check for the tag
+ 	 */
+ 	if (ice_is_dvm_ena(hw))
+ 		if (vsi->type == ICE_VSI_VF &&
+ 		    ice_vf_is_port_vlan_ena(vsi->vf))
+ 			rlan_ctx.l2tsel = 1;
+ 		else
+ 			rlan_ctx.l2tsel = 0;
+ 	else
+ 		rlan_ctx.l2tsel = 1;
++>>>>>>> b03d519d3460 (ice: store VF pointer instead of VF ID)
  
  	rlan_ctx.dtype = ICE_RX_DTYPE_NO_SPLIT;
  	rlan_ctx.hsplit_0 = ICE_RLAN_RX_HSPLIT_0_NO_SPLIT;
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 80f50982752a,5af36311a404..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -3323,9 -3145,11 +3354,9 @@@ int ice_vsi_rebuild(struct ice_vsi *vsi
  
  	pf = vsi->back;
  	vtype = vsi->type;
- 	if (vtype == ICE_VSI_VF)
- 		vf = &pf->vf[vsi->vf_id];
+ 	if (WARN_ON(vtype == ICE_VSI_VF) && !vsi->vf)
+ 		return -EINVAL;
  
 -	ice_vsi_init_vlan_ops(vsi);
 -
  	coalesce = kcalloc(vsi->num_q_vectors,
  			   sizeof(struct ice_coalesce_stored), GFP_KERNEL);
  	if (!coalesce)
@@@ -4144,7 -3968,112 +4175,103 @@@ int ice_set_link(struct ice_vsi *vsi, b
   */
  int ice_vsi_add_vlan_zero(struct ice_vsi *vsi)
  {
++<<<<<<< HEAD
 +	return ice_vsi_add_vlan(vsi, 0, ICE_FWD_TO_VSI);
++=======
+ 	struct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	struct ice_vlan vlan;
+ 	int err;
+ 
+ 	vlan = ICE_VLAN(0, 0, 0);
+ 	err = vlan_ops->add_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	/* in SVM both VLAN 0 filters are identical */
+ 	if (!ice_is_dvm_ena(&vsi->back->hw))
+ 		return 0;
+ 
+ 	vlan = ICE_VLAN(ETH_P_8021Q, 0, 0);
+ 	err = vlan_ops->add_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vsi_del_vlan_zero - delete VLAN 0 filter(s) for this VSI
+  * @vsi: VSI used to add VLAN filters
+  *
+  * Delete the VLAN 0 filters in the same manner that they were added in
+  * ice_vsi_add_vlan_zero.
+  */
+ int ice_vsi_del_vlan_zero(struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	struct ice_vlan vlan;
+ 	int err;
+ 
+ 	vlan = ICE_VLAN(0, 0, 0);
+ 	err = vlan_ops->del_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	/* in SVM both VLAN 0 filters are identical */
+ 	if (!ice_is_dvm_ena(&vsi->back->hw))
+ 		return 0;
+ 
+ 	vlan = ICE_VLAN(ETH_P_8021Q, 0, 0);
+ 	err = vlan_ops->del_vlan(vsi, &vlan);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vsi_num_zero_vlans - get number of VLAN 0 filters based on VLAN mode
+  * @vsi: VSI used to get the VLAN mode
+  *
+  * If DVM is enabled then 2 VLAN 0 filters are added, else if SVM is enabled
+  * then 1 VLAN 0 filter is added. See ice_vsi_add_vlan_zero for more details.
+  */
+ static u16 ice_vsi_num_zero_vlans(struct ice_vsi *vsi)
+ {
+ #define ICE_DVM_NUM_ZERO_VLAN_FLTRS	2
+ #define ICE_SVM_NUM_ZERO_VLAN_FLTRS	1
+ 	/* no VLAN 0 filter is created when a port VLAN is active */
+ 	if (vsi->type == ICE_VSI_VF) {
+ 		if (WARN_ON(!vsi->vf))
+ 			return 0;
+ 
+ 		if (ice_vf_is_port_vlan_ena(vsi->vf))
+ 			return 0;
+ 	}
+ 
+ 	if (ice_is_dvm_ena(&vsi->back->hw))
+ 		return ICE_DVM_NUM_ZERO_VLAN_FLTRS;
+ 	else
+ 		return ICE_SVM_NUM_ZERO_VLAN_FLTRS;
+ }
+ 
+ /**
+  * ice_vsi_has_non_zero_vlans - check if VSI has any non-zero VLANs
+  * @vsi: VSI used to determine if any non-zero VLANs have been added
+  */
+ bool ice_vsi_has_non_zero_vlans(struct ice_vsi *vsi)
+ {
+ 	return (vsi->num_vlan > ice_vsi_num_zero_vlans(vsi));
+ }
+ 
+ /**
+  * ice_vsi_num_non_zero_vlans - get the number of non-zero VLANs for this VSI
+  * @vsi: VSI used to get the number of non-zero VLANs added
+  */
+ u16 ice_vsi_num_non_zero_vlans(struct ice_vsi *vsi)
+ {
+ 	return (vsi->num_vlan - ice_vsi_num_zero_vlans(vsi));
++>>>>>>> b03d519d3460 (ice: store VF pointer instead of VF ID)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_vsi_vlan_ops.c
diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 54ee457baca7..99d97421dca4 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -107,7 +107,6 @@
 /* All VF control VSIs share the same IRQ, so assign a unique ID for them */
 #define ICE_RES_VF_CTRL_VEC_ID	(ICE_RES_RDMA_VEC_ID - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
-#define ICE_INVAL_VFID		256
 
 #define ICE_MAX_RXQS_PER_TC		256	/* Used when setting VSI context per TC Rx queues */
 
@@ -330,7 +329,7 @@ struct ice_vsi {
 	u16 vsi_num;			/* HW (absolute) index of this VSI */
 	u16 idx;			/* software index in pf->vsi[] */
 
-	s16 vf_id;			/* VF ID for SR-IOV VSIs */
+	struct ice_vf *vf;		/* VF associated with this VSI */
 
 	u16 ethtype;			/* Ethernet protocol for pause frame */
 	u16 num_gfltr;
* Unmerged path drivers/net/ethernet/intel/ice/ice_base.c
diff --git a/drivers/net/ethernet/intel/ice/ice_eswitch.c b/drivers/net/ethernet/intel/ice/ice_eswitch.c
index 34a4474731de..aeafcd699af8 100644
--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c
+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c
@@ -312,7 +312,7 @@ void ice_eswitch_update_repr(struct ice_vsi *vsi)
 	if (!ice_is_switchdev_running(pf))
 		return;
 
-	vf = &pf->vf[vsi->vf_id];
+	vf = vsi->vf;
 	repr = vf->repr;
 	repr->src_vsi = vsi;
 	repr->dst->u.port_info.port_id = vsi->vsi_num;
@@ -320,7 +320,8 @@ void ice_eswitch_update_repr(struct ice_vsi *vsi)
 	ret = ice_vsi_update_security(vsi, ice_vsi_ctx_clear_antispoof);
 	if (ret) {
 		ice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr.addr, ICE_FWD_TO_VSI);
-		dev_err(ice_pf_to_dev(pf), "Failed to update VF %d port representor", vsi->vf_id);
+		dev_err(ice_pf_to_dev(pf), "Failed to update VF %d port representor",
+			vsi->vf->vf_id);
 	}
 }
 
@@ -405,7 +406,7 @@ static void ice_eswitch_release_env(struct ice_pf *pf)
 static struct ice_vsi *
 ice_eswitch_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi)
 {
-	return ice_vsi_setup(pf, pi, ICE_VSI_SWITCHDEV_CTRL, ICE_INVAL_VFID, NULL);
+	return ice_vsi_setup(pf, pi, ICE_VSI_SWITCHDEV_CTRL, NULL, NULL);
 }
 
 /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.h b/drivers/net/ethernet/intel/ice/ice_lib.h
index 59ac60e11487..ae7eec40cd12 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_lib.h
@@ -62,7 +62,8 @@ void ice_vsi_cfg_netdev_tc(struct ice_vsi *vsi, u8 ena_tc);
 
 struct ice_vsi *
 ice_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi,
-	      enum ice_vsi_type vsi_type, u16 vf_id, struct ice_channel *ch);
+	      enum ice_vsi_type vsi_type, struct ice_vf *vf,
+	      struct ice_channel *ch);
 
 void ice_napi_del(struct ice_vsi *vsi);
 
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index f8185f20f865..b0fc76db4cd1 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -2468,7 +2468,7 @@ static int ice_vsi_req_irq_msix(struct ice_vsi *vsi, char *basename)
 			/* skip this unused q_vector */
 			continue;
 		}
-		if (vsi->type == ICE_VSI_CTRL && vsi->vf_id != ICE_INVAL_VFID)
+		if (vsi->type == ICE_VSI_CTRL && vsi->vf)
 			err = devm_request_irq(dev, irq_num, vsi->irq_handler,
 					       IRQF_SHARED, q_vector->name,
 					       q_vector);
@@ -3402,14 +3402,14 @@ void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size)
 static struct ice_vsi *
 ice_pf_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi)
 {
-	return ice_vsi_setup(pf, pi, ICE_VSI_PF, ICE_INVAL_VFID, NULL);
+	return ice_vsi_setup(pf, pi, ICE_VSI_PF, NULL, NULL);
 }
 
 static struct ice_vsi *
 ice_chnl_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi,
 		   struct ice_channel *ch)
 {
-	return ice_vsi_setup(pf, pi, ICE_VSI_CHNL, ICE_INVAL_VFID, ch);
+	return ice_vsi_setup(pf, pi, ICE_VSI_CHNL, NULL, ch);
 }
 
 /**
@@ -3423,7 +3423,7 @@ ice_chnl_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi,
 static struct ice_vsi *
 ice_ctrl_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi)
 {
-	return ice_vsi_setup(pf, pi, ICE_VSI_CTRL, ICE_INVAL_VFID, NULL);
+	return ice_vsi_setup(pf, pi, ICE_VSI_CTRL, NULL, NULL);
 }
 
 /**
@@ -3437,7 +3437,7 @@ ice_ctrl_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi)
 struct ice_vsi *
 ice_lb_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi)
 {
-	return ice_vsi_setup(pf, pi, ICE_VSI_LB, ICE_INVAL_VFID, NULL);
+	return ice_vsi_setup(pf, pi, ICE_VSI_LB, NULL, NULL);
 }
 
 /**
diff --git a/drivers/net/ethernet/intel/ice/ice_txrx.c b/drivers/net/ethernet/intel/ice/ice_txrx.c
index 7e43184738d4..51687ccce564 100644
--- a/drivers/net/ethernet/intel/ice/ice_txrx.c
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.c
@@ -1163,7 +1163,7 @@ int ice_clean_rx_irq(struct ice_rx_ring *rx_ring, int budget)
 			struct ice_vsi *ctrl_vsi = rx_ring->vsi;
 
 			if (rx_desc->wb.rxdid == FDIR_DESC_RXDID &&
-			    ctrl_vsi->vf_id != ICE_INVAL_VFID)
+			    ctrl_vsi->vf)
 				ice_vc_fdir_irq_handler(ctrl_vsi, rx_desc);
 			ice_put_rx_buf(rx_ring, NULL, 0);
 			cleaned_count++;
* Unmerged path drivers/net/ethernet/intel/ice/ice_vf_vsi_vlan_ops.c
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
index d64df81d4893..25b9c1dfc1ac 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
@@ -1288,15 +1288,16 @@ ice_vc_fdir_irq_handler(struct ice_vsi *ctrl_vsi,
 			union ice_32b_rx_flex_desc *rx_desc)
 {
 	struct ice_pf *pf = ctrl_vsi->back;
+	struct ice_vf *vf = ctrl_vsi->vf;
 	struct ice_vf_fdir_ctx *ctx_done;
 	struct ice_vf_fdir_ctx *ctx_irq;
 	struct ice_vf_fdir *fdir;
 	unsigned long flags;
 	struct device *dev;
-	struct ice_vf *vf;
 	int ret;
 
-	vf = &pf->vf[ctrl_vsi->vf_id];
+	if (WARN_ON(!vf))
+		return;
 
 	fdir = &vf->fdir;
 	ctx_done = &fdir->ctx_done;
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index e5875fdaaf40..e9f530dfb347 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@ -714,7 +714,7 @@ static struct ice_vsi *ice_vf_vsi_setup(struct ice_vf *vf)
 	struct ice_pf *pf = vf->pf;
 	struct ice_vsi *vsi;
 
-	vsi = ice_vsi_setup(pf, pi, ICE_VSI_VF, vf->vf_id, NULL);
+	vsi = ice_vsi_setup(pf, pi, ICE_VSI_VF, vf, NULL);
 
 	if (!vsi) {
 		dev_err(ice_pf_to_dev(pf), "Failed to create VF VSI\n");
@@ -741,7 +741,7 @@ struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf)
 	struct ice_pf *pf = vf->pf;
 	struct ice_vsi *vsi;
 
-	vsi = ice_vsi_setup(pf, pi, ICE_VSI_CTRL, vf->vf_id, NULL);
+	vsi = ice_vsi_setup(pf, pi, ICE_VSI_CTRL, vf, NULL);
 	if (!vsi) {
 		dev_err(ice_pf_to_dev(pf), "Failed to create VF control VSI\n");
 		ice_vf_ctrl_invalidate_vsi(vf);
@@ -2401,7 +2401,7 @@ bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id)
 
 	vsi = ice_find_vsi_from_id(pf, vsi_id);
 
-	return (vsi && (vsi->vf_id == vf->vf_id));
+	return (vsi && (vsi->vf == vf));
 }
 
 /**
