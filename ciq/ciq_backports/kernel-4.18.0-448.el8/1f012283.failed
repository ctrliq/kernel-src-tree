of/fdt: Rework early_init_dt_scan_memory() to call directly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Rob Herring <robh@kernel.org>
commit 1f012283e9360fb4007308f04cfaeb205e34b684
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1f012283.failed

Use of the of_scan_flat_dt() function predates libfdt and is discouraged
as libfdt provides a nicer set of APIs. Rework
early_init_dt_scan_memory() to be called directly and use libfdt.

	Cc: John Crispin <john@phrozen.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Frank Rowand <frowand.list@gmail.com>
	Cc: linux-mips@vger.kernel.org
	Cc: linuxppc-dev@lists.ozlabs.org
	Reviewed-by: Frank Rowand <frank.rowand@sony.com>
	Signed-off-by: Rob Herring <robh@kernel.org>
	Tested-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20211215150102.1303588-1-robh@kernel.org
(cherry picked from commit 1f012283e9360fb4007308f04cfaeb205e34b684)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/mips/ralink/of.c
#	drivers/of/fdt.c
#	include/linux/of_fdt.h
diff --cc arch/mips/ralink/of.c
index d544e7b07f7a,35a87a2da10b..000000000000
--- a/arch/mips/ralink/of.c
+++ b/arch/mips/ralink/of.c
@@@ -53,41 -53,26 +53,38 @@@ void __init device_tree_init(void
  	unflatten_and_copy_device_tree();
  }
  
- static int memory_dtb;
- 
- static int __init early_init_dt_find_memory(unsigned long node,
- 				const char *uname, int depth, void *data)
- {
- 	if (depth == 1 && !strcmp(uname, "memory@0"))
- 		memory_dtb = 1;
- 
- 	return 0;
- }
- 
  void __init plat_mem_setup(void)
  {
 -	void *dtb;
 +	void *dtb = NULL;
  
  	set_io_port_base(KSEG1);
  
  	/*
  	 * Load the builtin devicetree. This causes the chosen node to be
 -	 * parsed resulting in our memory appearing.
 +	 * parsed resulting in our memory appearing. fw_passed_dtb is used
 +	 * by CONFIG_MIPS_APPENDED_RAW_DTB as well.
  	 */
 -	dtb = get_fdt();
 +	if (fw_passed_dtb)
 +		dtb = (void *)fw_passed_dtb;
 +	else if (__dtb_start != __dtb_end)
 +		dtb = (void *)__dtb_start;
 +
  	__dt_setup_arch(dtb);
  
++<<<<<<< HEAD
 +	of_scan_flat_dt(early_init_dt_find_memory, NULL);
 +	if (memory_dtb)
 +		of_scan_flat_dt(early_init_dt_scan_memory, NULL);
++=======
+ 	if (!early_init_dt_scan_memory())
+ 		return;
+ 
+ 	if (soc_info.mem_detect)
+ 		soc_info.mem_detect();
++>>>>>>> 1f012283e936 (of/fdt: Rework early_init_dt_scan_memory() to call directly)
  	else if (soc_info.mem_size)
 -		memblock_add(soc_info.mem_base, soc_info.mem_size * SZ_1M);
 +		add_memory_region(soc_info.mem_base, soc_info.mem_size * SZ_1M,
 +				  BOOT_MEM_RAM);
  	else
  		detect_memory_region(soc_info.mem_base,
  				     soc_info.mem_size_min * SZ_1M,
diff --cc drivers/of/fdt.c
index 3a485143751f,a835c458f50a..000000000000
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@@ -1021,60 -1075,56 +1021,100 @@@ u64 __init dt_mem_next_cell(int s, cons
  	return of_read_number(p, s);
  }
  
 -/*
 +/**
   * early_init_dt_scan_memory - Look for and parse memory nodes
   */
- int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
- 				     int depth, void *data)
+ int __init early_init_dt_scan_memory(void)
  {
- 	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
- 	const __be32 *reg, *endp;
- 	int l;
- 	bool hotpluggable;
+ 	int node;
+ 	const void *fdt = initial_boot_params;
  
++<<<<<<< HEAD
 +	/* We are scanning "memory" nodes only */
 +	if (type == NULL) {
 +		/*
 +		 * The longtrail doesn't have a device_type on the
 +		 * /memory node, so look for the node called /memory@0.
 +		 */
 +		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
 +			return 0;
 +	} else if (strcmp(type, "memory") != 0)
 +		return 0;
 +
 +	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
 +	if (reg == NULL)
 +		reg = of_get_flat_dt_prop(node, "reg", &l);
 +	if (reg == NULL)
 +		return 0;
 +
 +	endp = reg + (l / sizeof(__be32));
 +	hotpluggable = of_get_flat_dt_prop(node, "hotpluggable", NULL);
 +
 +	pr_debug("memory scan node %s, reg size %d,\n", uname, l);
 +
 +	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
 +		u64 base, size;
 +
 +		base = dt_mem_next_cell(dt_root_addr_cells, &reg);
 +		size = dt_mem_next_cell(dt_root_size_cells, &reg);
 +
 +		if (size == 0)
 +			continue;
 +		pr_debug(" - %llx ,  %llx\n", (unsigned long long)base,
 +		    (unsigned long long)size);
 +
 +		early_init_dt_add_memory_arch(base, size);
 +
 +		if (!hotpluggable)
 +			continue;
 +
 +		if (early_init_dt_mark_hotplug_memory_arch(base, size))
 +			pr_warn("failed to mark hotplug range 0x%llx - 0x%llx\n",
 +				base, base + size);
- 	}
++=======
+ 	fdt_for_each_subnode(node, fdt, 0) {
+ 		const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
+ 		const __be32 *reg, *endp;
+ 		int l;
+ 		bool hotpluggable;
+ 
+ 		/* We are scanning "memory" nodes only */
+ 		if (type == NULL || strcmp(type, "memory") != 0)
+ 			continue;
+ 
+ 		reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
+ 		if (reg == NULL)
+ 			reg = of_get_flat_dt_prop(node, "reg", &l);
+ 		if (reg == NULL)
+ 			continue;
+ 
+ 		endp = reg + (l / sizeof(__be32));
+ 		hotpluggable = of_get_flat_dt_prop(node, "hotpluggable", NULL);
  
+ 		pr_debug("memory scan node %s, reg size %d,\n",
+ 			 fdt_get_name(fdt, node, NULL), l);
+ 
+ 		while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
+ 			u64 base, size;
+ 
+ 			base = dt_mem_next_cell(dt_root_addr_cells, &reg);
+ 			size = dt_mem_next_cell(dt_root_size_cells, &reg);
+ 
+ 			if (size == 0)
+ 				continue;
+ 			pr_debug(" - %llx, %llx\n", base, size);
+ 
+ 			early_init_dt_add_memory_arch(base, size);
+ 
+ 			if (!hotpluggable)
+ 				continue;
+ 
+ 			if (memblock_mark_hotplug(base, size))
+ 				pr_warn("failed to mark hotplug range 0x%llx - 0x%llx\n",
+ 					base, base + size);
+ 		}
++>>>>>>> 1f012283e936 (of/fdt: Rework early_init_dt_scan_memory() to call directly)
+ 	}
  	return 0;
  }
  
@@@ -1218,8 -1269,16 +1258,15 @@@ void __init early_init_dt_scan_nodes(vo
  	/* Initialize {size,address}-cells info */
  	early_init_dt_scan_root();
  
 -	/* Retrieve various information from the /chosen node */
 -	rc = early_init_dt_scan_chosen(boot_command_line);
 -	if (rc)
 -		pr_warn("No chosen node found, continuing without\n");
 -
  	/* Setup memory, calling early_init_dt_add_memory_arch */
++<<<<<<< HEAD
 +	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
++=======
+ 	early_init_dt_scan_memory();
+ 
+ 	/* Handle linux,usable-memory-range property */
+ 	memblock_cap_memory_range(cap_mem_addr, cap_mem_size);
++>>>>>>> 1f012283e936 (of/fdt: Rework early_init_dt_scan_memory() to call directly)
  }
  
  bool __init early_init_dt_scan(void *params)
diff --cc include/linux/of_fdt.h
index 2099fe5068d2,914739f3c192..000000000000
--- a/include/linux/of_fdt.h
+++ b/include/linux/of_fdt.h
@@@ -64,15 -55,11 +64,20 @@@ extern int of_get_flat_dt_subnode_by_na
  extern const void *of_get_flat_dt_prop(unsigned long node, const char *name,
  				       int *size);
  extern int of_flat_dt_is_compatible(unsigned long node, const char *name);
 +extern int of_flat_dt_match(unsigned long node, const char *const *matches);
  extern unsigned long of_get_flat_dt_root(void);
 +extern int of_get_flat_dt_size(void);
  extern uint32_t of_get_flat_dt_phandle(unsigned long node);
  
++<<<<<<< HEAD
 +extern int early_init_dt_scan_chosen(unsigned long node, const char *uname,
 +				     int depth, void *data);
 +extern int early_init_dt_scan_memory(unsigned long node, const char *uname,
 +				     int depth, void *data);
++=======
+ extern int early_init_dt_scan_chosen(char *cmdline);
+ extern int early_init_dt_scan_memory(void);
++>>>>>>> 1f012283e936 (of/fdt: Rework early_init_dt_scan_memory() to call directly)
  extern int early_init_dt_scan_chosen_stdout(void);
  extern void early_init_fdt_scan_reserved_mem(void);
  extern void early_init_fdt_reserve_self(void);
* Unmerged path arch/mips/ralink/of.c
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index edfd8c3ba085..6a5bbdaa7b16 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -537,19 +537,18 @@ static int  __init early_init_drmem_lmb(struct drmem_lmb *lmb,
 }
 #endif /* CONFIG_PPC_PSERIES */
 
-static int __init early_init_dt_scan_memory_ppc(unsigned long node,
-						const char *uname,
-						int depth, void *data)
+static int __init early_init_dt_scan_memory_ppc(void)
 {
 #ifdef CONFIG_PPC_PSERIES
-	if (depth == 1 &&
-	    strcmp(uname, "ibm,dynamic-reconfiguration-memory") == 0) {
+	const void *fdt = initial_boot_params;
+	int node = fdt_path_offset(fdt, "/ibm,dynamic-reconfiguration-memory");
+
+	if (node > 0)
 		walk_drmem_lmbs_early(node, NULL, early_init_drmem_lmb);
-		return 0;
-	}
+
 #endif
-	
-	return early_init_dt_scan_memory(node, uname, depth, data);
+
+	return early_init_dt_scan_memory();
 }
 
 /*
@@ -754,7 +753,7 @@ void __init early_init_devtree(void *params)
 
 	/* Scan memory nodes and rebuild MEMBLOCKs */
 	early_init_dt_scan_root();
-	of_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);
+	early_init_dt_scan_memory_ppc();
 
 	parse_early_param();
 
@@ -856,7 +855,7 @@ void __init early_get_first_memblock_info(void *params, phys_addr_t *size)
 	 */
 	add_mem_to_memblock = 0;
 	early_init_dt_scan_root();
-	of_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);
+	early_init_dt_scan_memory_ppc();
 	add_mem_to_memblock = 1;
 
 	if (size)
* Unmerged path drivers/of/fdt.c
* Unmerged path include/linux/of_fdt.h
