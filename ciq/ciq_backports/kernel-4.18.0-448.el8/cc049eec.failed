s390/pci: simplify CLP List PCI handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit cc049eecfb7adc4bfecd05eb25e425d8def96fce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/cc049eec.failed

Currently clp_get_state() and clp_refresh_fh() awkwardly use the
clp_list_pci() callback mechanism to find the entry for a specific FID
and update its zdev, respectively return its state.

This is both needlessly complex and means we are always going through
the entire PCI function list even if the FID has already been found.
Instead lets introduce a clp_find_pci() function to find a specific
entry and share the CLP List PCI request handling code with
clp_list_pci().

With that in place we can also easily make the function handle a simple
out parameter instead of directly altering the zdev allowing easier
access to the updated function handle by the caller.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit cc049eecfb7adc4bfecd05eb25e425d8def96fce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_clp.c
diff --cc arch/s390/include/asm/pci.h
index 37481081a26c,c51e64d49d4e..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -213,11 -213,13 +213,19 @@@ int zpci_unregister_ioat(struct zpci_de
  void zpci_remove_reserved_devices(void);
  
  /* CLP */
 -int clp_setup_writeback_mio(void);
  int clp_scan_pci_devices(void);
++<<<<<<< HEAD
 +int clp_add_pci_device(u32, u32, int);
 +int clp_enable_fh(struct zpci_dev *, u8);
 +int clp_disable_fh(struct zpci_dev *);
 +int clp_get_state(u32 fid, enum zpci_state *state);
++=======
+ int clp_query_pci_fn(struct zpci_dev *zdev);
+ int clp_enable_fh(struct zpci_dev *zdev, u32 *fh, u8 nr_dma_as);
+ int clp_disable_fh(struct zpci_dev *zdev, u32 *fh);
+ int clp_get_state(u32 fid, enum zpci_state *state);
+ int clp_refresh_fh(u32 fid, u32 *fh);
++>>>>>>> cc049eecfb7a (s390/pci: simplify CLP List PCI handling)
  
  /* UID */
  void update_uid_checking(bool new);
diff --cc arch/s390/pci/pci.c
index 105423d600b5,b05b86e2d2c0..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -707,56 -669,75 +709,80 @@@ int zpci_enable_device(struct zpci_dev 
  	return 0;
  
  out_dma:
- 	clp_disable_fh(zdev);
+ 	clp_disable_fh(zdev, &fh);
  out:
+ 	zdev->fh = fh;
  	return rc;
  }
 +EXPORT_SYMBOL_GPL(zpci_enable_device);
  
  int zpci_disable_device(struct zpci_dev *zdev)
  {
++<<<<<<< HEAD
 +	zpci_dma_exit_device(zdev);
 +	/*
 +	 * The zPCI function may already be disabled by the platform, this is
 +	 * detected in clp_disable_fh() which becomes a no-op.
 +	 */
 +	return clp_disable_fh(zdev) ? -EIO : 0;
 +}
 +EXPORT_SYMBOL_GPL(zpci_disable_device);
 +
 +void zpci_remove_device(struct zpci_dev *zdev)
 +{
 +	struct zpci_bus *zbus = zdev->zbus;
 +	struct pci_dev *pdev;
 +
 +	pdev = pci_get_slot(zbus->bus, zdev->devfn);
 +	if (pdev) {
 +		if (pdev->is_virtfn)
 +			return zpci_remove_virtfn(pdev, zdev->vfn);
 +		pci_stop_and_remove_bus_device_locked(pdev);
++=======
+ 	u32 fh = zdev->fh;
+ 	int cc, rc = 0;
+ 
+ 	zpci_dma_exit_device(zdev);
+ 	if (!zdev_enabled(zdev))
+ 		return 0;
+ 	cc = clp_disable_fh(zdev, &fh);
+ 	if (!cc) {
+ 		zdev->fh = fh;
+ 	} else if (cc == CLP_RC_SETPCIFN_ALRDY) {
+ 		pr_info("Disabling PCI function %08x had no effect as it was already disabled\n",
+ 			zdev->fid);
+ 		/* Function is already disabled - update handle */
+ 		rc = clp_refresh_fh(zdev->fid, &fh);
+ 		if (!rc) {
+ 			zdev->fh = fh;
+ 			rc = -EINVAL;
+ 		}
+ 	} else {
+ 		rc = -EIO;
++>>>>>>> cc049eecfb7a (s390/pci: simplify CLP List PCI handling)
  	}
 -	return rc;
  }
  
 -/**
 - * zpci_create_device() - Create a new zpci_dev and add it to the zbus
 - * @fid: Function ID of the device to be created
 - * @fh: Current Function Handle of the device to be created
 - * @state: Initial state after creation either Standby or Configured
 - *
 - * Creates a new zpci device and adds it to its, possibly newly created, zbus
 - * as well as zpci_list.
 - *
 - * Returns: the zdev on success or an error pointer otherwise
 - */
 -struct zpci_dev *zpci_create_device(u32 fid, u32 fh, enum zpci_state state)
 +int zpci_create_device(struct zpci_dev *zdev)
  {
 -	struct zpci_dev *zdev;
  	int rc;
  
 -	zpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, state);
 -	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
 -	if (!zdev)
 -		return ERR_PTR(-ENOMEM);
 +	kref_init(&zdev->kref);
  
 -	/* FID and Function Handle are the static/dynamic identifiers */
 -	zdev->fid = fid;
 -	zdev->fh = fh;
 +	spin_lock(&zpci_list_lock);
 +	list_add_tail(&zdev->entry, &zpci_list);
 +	spin_unlock(&zpci_list_lock);
  
 -	/* Query function properties and update zdev */
 -	rc = clp_query_pci_fn(zdev);
 +	rc = zpci_init_iommu(zdev);
  	if (rc)
 -		goto error;
 -	zdev->state =  state;
 +		goto out;
  
 -	kref_init(&zdev->kref);
  	mutex_init(&zdev->lock);
 -
 -	rc = zpci_init_iommu(zdev);
 -	if (rc)
 -		goto error;
 +	if (zdev->state == ZPCI_FN_STATE_CONFIGURED) {
 +		rc = zpci_enable_device(zdev);
 +		if (rc)
 +			goto out_destroy_iommu;
 +	}
  
  	rc = zpci_bus_device_register(zdev, &pci_root_ops);
  	if (rc)
diff --cc arch/s390/pci/pci_clp.c
index 45c5438cc74b,51dc2215a2b7..000000000000
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@@ -284,10 -251,7 +286,14 @@@ static int clp_set_pci_fn(struct zpci_d
  	} while (rrb->response.hdr.rsp == CLP_RC_SETPCIFN_BUSY);
  
  	if (!rc && rrb->response.hdr.rsp == CLP_RC_OK) {
++<<<<<<< HEAD
 +		zdev->fh = rrb->response.fh;
 +	} else if (!rc && rrb->response.hdr.rsp == CLP_RC_SETPCIFN_ALRDY) {
 +		/* Function is already in desired state - update handle */
 +		rc = clp_refresh_fh(zdev->fid);
++=======
+ 		*fh = rrb->response.fh;
++>>>>>>> cc049eecfb7a (s390/pci: simplify CLP List PCI handling)
  	} else {
  		zpci_err("Set PCI FN:\n");
  		zpci_err_clp(rrb->response.hdr.rsp, rc);
@@@ -298,18 -262,52 +304,56 @@@
  	return rc;
  }
  
++<<<<<<< HEAD
 +int clp_enable_fh(struct zpci_dev *zdev, u8 nr_dma_as)
++=======
+ int clp_setup_writeback_mio(void)
  {
+ 	struct clp_req_rsp_slpc_pci *rrb;
+ 	u8  wb_bit_pos;
  	int rc;
  
- 	rc = clp_set_pci_fn(zdev, nr_dma_as, CLP_SET_ENABLE_PCI_FN);
- 	zpci_dbg(3, "ena fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);
+ 	rrb = clp_alloc_block(GFP_KERNEL);
+ 	if (!rrb)
+ 		return -ENOMEM;
+ 
+ 	memset(rrb, 0, sizeof(*rrb));
+ 	rrb->request.hdr.len = sizeof(rrb->request);
+ 	rrb->request.hdr.cmd = CLP_SLPC;
+ 	rrb->response.hdr.len = sizeof(rrb->response);
+ 
+ 	rc = clp_req(rrb, CLP_LPS_PCI);
+ 	if (!rc && rrb->response.hdr.rsp == CLP_RC_OK) {
+ 		if (rrb->response.vwb) {
+ 			wb_bit_pos = rrb->response.mio_wb;
+ 			set_bit_inv(wb_bit_pos, &mio_wb_bit_mask);
+ 			zpci_dbg(3, "wb bit: %d\n", wb_bit_pos);
+ 		} else {
+ 			zpci_dbg(3, "wb bit: n.a.\n");
+ 		}
+ 
+ 	} else {
+ 		zpci_err("SLPC PCI:\n");
+ 		zpci_err_clp(rrb->response.hdr.rsp, rc);
+ 		rc = -EIO;
+ 	}
+ 	clp_free_block(rrb);
+ 	return rc;
+ }
+ 
+ int clp_enable_fh(struct zpci_dev *zdev, u32 *fh, u8 nr_dma_as)
++>>>>>>> cc049eecfb7a (s390/pci: simplify CLP List PCI handling)
+ {
+ 	int rc;
+ 
+ 	rc = clp_set_pci_fn(zdev, fh, nr_dma_as, CLP_SET_ENABLE_PCI_FN);
+ 	zpci_dbg(3, "ena fid:%x, fh:%x, rc:%d\n", zdev->fid, *fh, rc);
  	if (!rc && zpci_use_mio(zdev)) {
- 		rc = clp_set_pci_fn(zdev, nr_dma_as, CLP_SET_ENABLE_MIO);
+ 		rc = clp_set_pci_fn(zdev, fh, nr_dma_as, CLP_SET_ENABLE_MIO);
  		zpci_dbg(3, "ena mio fid:%x, fh:%x, rc:%d\n",
- 				zdev->fid, zdev->fh, rc);
+ 				zdev->fid, *fh, rc);
  		if (rc)
- 			clp_disable_fh(zdev);
+ 			clp_disable_fh(zdev, fh);
  	}
  	return rc;
  }
@@@ -391,27 -422,13 +468,17 @@@ int clp_scan_pci_devices(void
  	return rc;
  }
  
- static void __clp_refresh_fh(struct clp_fh_list_entry *entry, void *data)
- {
- 	struct zpci_dev *zdev;
- 	u32 fid = *((u32 *)data);
- 
- 	if (!entry->vendor_id || fid != entry->fid)
- 		return;
- 
- 	zdev = get_zdev_by_fid(fid);
- 	if (!zdev)
- 		return;
- 
- 	zdev->fh = entry->fh;
- }
- 
  /*
-  * Refresh the function handle of the function matching @fid
+  * Get the current function handle of the function matching @fid
   */
++<<<<<<< HEAD
 +static int clp_refresh_fh(u32 fid)
++=======
+ int clp_refresh_fh(u32 fid, u32 *fh)
++>>>>>>> cc049eecfb7a (s390/pci: simplify CLP List PCI handling)
  {
  	struct clp_req_rsp_list_pci *rrb;
+ 	struct clp_fh_list_entry entry;
  	int rc;
  
  	rrb = clp_alloc_block(GFP_NOWAIT);
* Unmerged path arch/s390/include/asm/pci.h
* Unmerged path arch/s390/pci/pci.c
* Unmerged path arch/s390/pci/pci_clp.c
