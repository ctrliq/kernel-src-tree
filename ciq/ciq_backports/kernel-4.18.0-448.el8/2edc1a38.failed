net: ip: add skb drop reasons to ip forwarding

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit 2edc1a383fda8d2f580216292dfd9daeae691e47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2edc1a38.failed

Replace kfree_skb() which is used in ip6_forward() and ip_forward()
with kfree_skb_reason().

The new drop reason 'SKB_DROP_REASON_PKT_TOO_BIG' is introduced for
the case that the length of the packet exceeds MTU and can't
fragment.

	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: Jiang Biao <benbjiang@tencent.com>
	Reviewed-by: Hao Peng <flyingpeng@tencent.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2edc1a383fda8d2f580216292dfd9daeae691e47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/trace/events/skb.h
diff --cc include/linux/skbuff.h
index 663a879cbacc,0ef11df1bc67..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,148 +318,152 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_NOT_DROPPED_YET = 0,
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
+ 	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+ 					 * see the document for rp_filter
+ 					 * in ip-sysctl.rst for more
+ 					 * information
+ 					 */
+ 	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+ 						  * is multicast, but L3 is
+ 						  * unicast.
+ 						  */
+ 	SKB_DROP_REASON_XFRM_POLICY,	/* xfrm policy check failed */
+ 	SKB_DROP_REASON_IP_NOPROTO,	/* no support for IP protocol */
+ 	SKB_DROP_REASON_SOCKET_RCVBUFF,	/* socket receive buff is full */
+ 	SKB_DROP_REASON_PROTO_MEM,	/* proto memory limition, such as
+ 					 * udp packet drop out of
+ 					 * udp_memory_allocated.
+ 					 */
+ 	SKB_DROP_REASON_TCP_MD5NOTFOUND,	/* no MD5 hash and one
+ 						 * expected, corresponding
+ 						 * to LINUX_MIB_TCPMD5NOTFOUND
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5UNEXPECTED,	/* MD5 hash and we're not
+ 						 * expecting one, corresponding
+ 						 * to LINUX_MIB_TCPMD5UNEXPECTED
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5FAILURE,	/* MD5 hash and its wrong,
+ 					 * corresponding to
+ 					 * LINUX_MIB_TCPMD5FAILURE
+ 					 */
+ 	SKB_DROP_REASON_SOCKET_BACKLOG,	/* failed to add skb to socket
+ 					 * backlog (see
+ 					 * LINUX_MIB_TCPBACKLOGDROP)
+ 					 */
+ 	SKB_DROP_REASON_TCP_FLAGS,	/* TCP flags invalid */
+ 	SKB_DROP_REASON_TCP_ZEROWINDOW,	/* TCP receive window size is zero,
+ 					 * see LINUX_MIB_TCPZEROWINDOWDROP
+ 					 */
+ 	SKB_DROP_REASON_TCP_OLD_DATA,	/* the TCP data reveived is already
+ 					 * received before (spurious retrans
+ 					 * may happened), see
+ 					 * LINUX_MIB_DELAYEDACKLOST
+ 					 */
+ 	SKB_DROP_REASON_TCP_OVERWINDOW,	/* the TCP data is out of window,
+ 					 * the seq of the first byte exceed
+ 					 * the right edges of receive
+ 					 * window
+ 					 */
+ 	SKB_DROP_REASON_TCP_OFOMERGE,	/* the data of skb is already in
+ 					 * the ofo queue, corresponding to
+ 					 * LINUX_MIB_TCPOFOMERGE
+ 					 */
+ 	SKB_DROP_REASON_IP_OUTNOROUTES,	/* route lookup failed */
+ 	SKB_DROP_REASON_BPF_CGROUP_EGRESS,	/* dropped by
+ 						 * BPF_PROG_TYPE_CGROUP_SKB
+ 						 * eBPF program
+ 						 */
+ 	SKB_DROP_REASON_IPV6DISABLED,	/* IPv6 is disabled on the device */
+ 	SKB_DROP_REASON_NEIGH_CREATEFAIL,	/* failed to create neigh
+ 						 * entry
+ 						 */
+ 	SKB_DROP_REASON_NEIGH_FAILED,	/* neigh entry in failed state */
+ 	SKB_DROP_REASON_NEIGH_QUEUEFULL,	/* arp_queue for neigh
+ 						 * entry is full
+ 						 */
+ 	SKB_DROP_REASON_NEIGH_DEAD,	/* neigh entry is dead */
+ 	SKB_DROP_REASON_TC_EGRESS,	/* dropped in TC egress HOOK */
+ 	SKB_DROP_REASON_QDISC_DROP,	/* dropped by qdisc when packet
+ 					 * outputting (failed to enqueue to
+ 					 * current qdisc)
+ 					 */
+ 	SKB_DROP_REASON_CPU_BACKLOG,	/* failed to enqueue the skb to
+ 					 * the per CPU backlog queue. This
+ 					 * can be caused by backlog queue
+ 					 * full (see netdev_max_backlog in
+ 					 * net.rst) or RPS flow limit
+ 					 */
+ 	SKB_DROP_REASON_XDP,		/* dropped by XDP in input path */
+ 	SKB_DROP_REASON_TC_INGRESS,	/* dropped in TC ingress HOOK */
+ 	SKB_DROP_REASON_UNHANDLED_PROTO,	/* protocol not implemented
+ 						 * or not supported
+ 						 */
+ 	SKB_DROP_REASON_SKB_CSUM,	/* sk_buff checksum computation
+ 					 * error
+ 					 */
+ 	SKB_DROP_REASON_SKB_GSO_SEG,	/* gso segmentation error */
+ 	SKB_DROP_REASON_SKB_UCOPY_FAULT,	/* failed to copy data from
+ 						 * user space, e.g., via
+ 						 * zerocopy_sg_from_iter()
+ 						 * or skb_orphan_frags_rx()
+ 						 */
+ 	SKB_DROP_REASON_DEV_HDR,	/* device driver specific
+ 					 * header/metadata is invalid
+ 					 */
+ 	/* the device is not ready to xmit/recv due to any of its data
+ 	 * structure that is not up/ready/initialized, e.g., the IFF_UP is
+ 	 * not set, or driver specific tun->tfiles[txq] is not initialized
+ 	 */
+ 	SKB_DROP_REASON_DEV_READY,
+ 	SKB_DROP_REASON_FULL_RING,	/* ring buffer is full */
+ 	SKB_DROP_REASON_NOMEM,		/* error due to OOM */
+ 	SKB_DROP_REASON_HDR_TRUNC,      /* failed to trunc/extract the header
+ 					 * from networking data, e.g., failed
+ 					 * to pull the protocol header from
+ 					 * frags via pskb_may_pull()
+ 					 */
+ 	SKB_DROP_REASON_TAP_FILTER,     /* dropped by (ebpf) filter directly
+ 					 * attached to tun/tap, e.g., via
+ 					 * TUNSETFILTEREBPF
+ 					 */
+ 	SKB_DROP_REASON_TAP_TXFILTER,	/* dropped by tx filter implemented
+ 					 * at tun/tap, e.g., check_filter()
+ 					 */
+ 	SKB_DROP_REASON_ICMP_CSUM,	/* ICMP checksum error */
+ 	SKB_DROP_REASON_INVALID_PROTO,	/* the packet doesn't follow RFC
+ 					 * 2211, such as a broadcasts
+ 					 * ICMP_TIMESTAMP
+ 					 */
+ 	SKB_DROP_REASON_IP_INADDRERRORS,	/* host unreachable, corresponding
+ 						 * to IPSTATS_MIB_INADDRERRORS
+ 						 */
+ 	SKB_DROP_REASON_IP_INNOROUTES,	/* network unreachable, corresponding
+ 					 * to IPSTATS_MIB_INADDRERRORS
+ 					 */
+ 	SKB_DROP_REASON_PKT_TOO_BIG,	/* packet size is too big (maybe exceed
+ 					 * the MTU)
+ 					 */
++>>>>>>> 2edc1a383fda (net: ip: add skb drop reasons to ip forwarding)
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/trace/events/skb.h
index 294c61bbe44b,2da72a9a5764..000000000000
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@@ -11,6 -11,61 +11,64 @@@
  
  #define TRACE_SKB_DROP_REASON					\
  	EM(SKB_DROP_REASON_NOT_SPECIFIED, NOT_SPECIFIED)	\
++<<<<<<< HEAD
++=======
+ 	EM(SKB_DROP_REASON_NO_SOCKET, NO_SOCKET)		\
+ 	EM(SKB_DROP_REASON_PKT_TOO_SMALL, PKT_TOO_SMALL)	\
+ 	EM(SKB_DROP_REASON_TCP_CSUM, TCP_CSUM)			\
+ 	EM(SKB_DROP_REASON_SOCKET_FILTER, SOCKET_FILTER)	\
+ 	EM(SKB_DROP_REASON_UDP_CSUM, UDP_CSUM)			\
+ 	EM(SKB_DROP_REASON_NETFILTER_DROP, NETFILTER_DROP)	\
+ 	EM(SKB_DROP_REASON_OTHERHOST, OTHERHOST)		\
+ 	EM(SKB_DROP_REASON_IP_CSUM, IP_CSUM)			\
+ 	EM(SKB_DROP_REASON_IP_INHDR, IP_INHDR)			\
+ 	EM(SKB_DROP_REASON_IP_RPFILTER, IP_RPFILTER)		\
+ 	EM(SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST,		\
+ 	   UNICAST_IN_L2_MULTICAST)				\
+ 	EM(SKB_DROP_REASON_XFRM_POLICY, XFRM_POLICY)		\
+ 	EM(SKB_DROP_REASON_IP_NOPROTO, IP_NOPROTO)		\
+ 	EM(SKB_DROP_REASON_SOCKET_RCVBUFF, SOCKET_RCVBUFF)	\
+ 	EM(SKB_DROP_REASON_PROTO_MEM, PROTO_MEM)		\
+ 	EM(SKB_DROP_REASON_TCP_MD5NOTFOUND, TCP_MD5NOTFOUND)	\
+ 	EM(SKB_DROP_REASON_TCP_MD5UNEXPECTED,			\
+ 	   TCP_MD5UNEXPECTED)					\
+ 	EM(SKB_DROP_REASON_TCP_MD5FAILURE, TCP_MD5FAILURE)	\
+ 	EM(SKB_DROP_REASON_SOCKET_BACKLOG, SOCKET_BACKLOG)	\
+ 	EM(SKB_DROP_REASON_TCP_FLAGS, TCP_FLAGS)		\
+ 	EM(SKB_DROP_REASON_TCP_ZEROWINDOW, TCP_ZEROWINDOW)	\
+ 	EM(SKB_DROP_REASON_TCP_OLD_DATA, TCP_OLD_DATA)		\
+ 	EM(SKB_DROP_REASON_TCP_OVERWINDOW, TCP_OVERWINDOW)	\
+ 	EM(SKB_DROP_REASON_TCP_OFOMERGE, TCP_OFOMERGE)		\
+ 	EM(SKB_DROP_REASON_IP_OUTNOROUTES, IP_OUTNOROUTES)	\
+ 	EM(SKB_DROP_REASON_BPF_CGROUP_EGRESS,			\
+ 	   BPF_CGROUP_EGRESS)					\
+ 	EM(SKB_DROP_REASON_IPV6DISABLED, IPV6DISABLED)		\
+ 	EM(SKB_DROP_REASON_NEIGH_CREATEFAIL, NEIGH_CREATEFAIL)	\
+ 	EM(SKB_DROP_REASON_NEIGH_FAILED, NEIGH_FAILED)		\
+ 	EM(SKB_DROP_REASON_NEIGH_QUEUEFULL, NEIGH_QUEUEFULL)	\
+ 	EM(SKB_DROP_REASON_NEIGH_DEAD, NEIGH_DEAD)		\
+ 	EM(SKB_DROP_REASON_TC_EGRESS, TC_EGRESS)		\
+ 	EM(SKB_DROP_REASON_QDISC_DROP, QDISC_DROP)		\
+ 	EM(SKB_DROP_REASON_CPU_BACKLOG, CPU_BACKLOG)		\
+ 	EM(SKB_DROP_REASON_XDP, XDP)				\
+ 	EM(SKB_DROP_REASON_TC_INGRESS, TC_INGRESS)		\
+ 	EM(SKB_DROP_REASON_UNHANDLED_PROTO, UNHANDLED_PROTO)	\
+ 	EM(SKB_DROP_REASON_SKB_CSUM, SKB_CSUM)			\
+ 	EM(SKB_DROP_REASON_SKB_GSO_SEG, SKB_GSO_SEG)		\
+ 	EM(SKB_DROP_REASON_SKB_UCOPY_FAULT, SKB_UCOPY_FAULT)	\
+ 	EM(SKB_DROP_REASON_DEV_HDR, DEV_HDR)			\
+ 	EM(SKB_DROP_REASON_DEV_READY, DEV_READY)		\
+ 	EM(SKB_DROP_REASON_FULL_RING, FULL_RING)		\
+ 	EM(SKB_DROP_REASON_NOMEM, NOMEM)			\
+ 	EM(SKB_DROP_REASON_HDR_TRUNC, HDR_TRUNC)		\
+ 	EM(SKB_DROP_REASON_TAP_FILTER, TAP_FILTER)		\
+ 	EM(SKB_DROP_REASON_TAP_TXFILTER, TAP_TXFILTER)		\
+ 	EM(SKB_DROP_REASON_ICMP_CSUM, ICMP_CSUM)		\
+ 	EM(SKB_DROP_REASON_INVALID_PROTO, INVALID_PROTO)	\
+ 	EM(SKB_DROP_REASON_IP_INADDRERRORS, IP_INADDRERRORS)	\
+ 	EM(SKB_DROP_REASON_IP_INNOROUTES, IP_INNOROUTES)	\
+ 	EM(SKB_DROP_REASON_PKT_TOO_BIG, PKT_TOO_BIG)		\
++>>>>>>> 2edc1a383fda (net: ip: add skb drop reasons to ip forwarding)
  	EMe(SKB_DROP_REASON_MAX, MAX)
  
  #undef EM
* Unmerged path include/linux/skbuff.h
* Unmerged path include/trace/events/skb.h
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index c906d36fa443..aa0c0eb45b04 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -90,6 +90,7 @@ int ip_forward(struct sk_buff *skb)
 	struct rtable *rt;	/* Route we use */
 	struct ip_options *opt	= &(IPCB(skb)->opt);
 	struct net *net;
+	SKB_DR(reason);
 
 	/* that should never happen */
 	if (skb->pkt_type != PACKET_HOST)
@@ -101,8 +102,10 @@ int ip_forward(struct sk_buff *skb)
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
-	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
+	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb)) {
+		SKB_DR_SET(reason, XFRM_POLICY);
 		goto drop;
+	}
 
 	if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
 		return NET_RX_SUCCESS;
@@ -118,8 +121,10 @@ int ip_forward(struct sk_buff *skb)
 	if (ip_hdr(skb)->ttl <= 1)
 		goto too_many_hops;
 
-	if (!xfrm4_route_forward(skb))
+	if (!xfrm4_route_forward(skb)) {
+		SKB_DR_SET(reason, XFRM_POLICY);
 		goto drop;
+	}
 
 	rt = skb_rtable(skb);
 
@@ -132,6 +137,7 @@ int ip_forward(struct sk_buff *skb)
 		IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);
 		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
 			  htonl(mtu));
+		SKB_DR_SET(reason, PKT_TOO_BIG);
 		goto drop;
 	}
 
@@ -169,7 +175,8 @@ int ip_forward(struct sk_buff *skb)
 	/* Tell the sender its packet died... */
 	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);
 	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
+	SKB_DR_SET(reason, IP_INHDR);
 drop:
-	kfree_skb(skb);
+	kfree_skb_reason(skb, reason);
 	return NET_RX_DROP;
 }
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 744dc78e0de4..7b888b382c2e 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -462,6 +462,7 @@ int ip6_forward(struct sk_buff *skb)
 	struct inet6_skb_parm *opt = IP6CB(skb);
 	struct net *net = dev_net(dst->dev);
 	struct inet6_dev *idev;
+	SKB_DR(reason);
 	u32 mtu;
 
 	idev = __in6_dev_get_safely(dev_get_by_index_rcu(net, IP6CB(skb)->iif));
@@ -513,7 +514,7 @@ int ip6_forward(struct sk_buff *skb)
 		icmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);
 		__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);
 
-		kfree_skb(skb);
+		kfree_skb_reason(skb, SKB_DROP_REASON_IP_INHDR);
 		return -ETIMEDOUT;
 	}
 
@@ -531,6 +532,7 @@ int ip6_forward(struct sk_buff *skb)
 
 	if (!xfrm6_route_forward(skb)) {
 		__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);
+		SKB_DR_SET(reason, XFRM_POLICY);
 		goto drop;
 	}
 	dst = skb_dst(skb);
@@ -590,7 +592,7 @@ int ip6_forward(struct sk_buff *skb)
 		__IP6_INC_STATS(net, idev, IPSTATS_MIB_INTOOBIGERRORS);
 		__IP6_INC_STATS(net, ip6_dst_idev(dst),
 				IPSTATS_MIB_FRAGFAILS);
-		kfree_skb(skb);
+		kfree_skb_reason(skb, SKB_DROP_REASON_PKT_TOO_BIG);
 		return -EMSGSIZE;
 	}
 
@@ -612,8 +614,9 @@ int ip6_forward(struct sk_buff *skb)
 
 error:
 	__IP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);
+	SKB_DR_SET(reason, IP_INADDRERRORS);
 drop:
-	kfree_skb(skb);
+	kfree_skb_reason(skb, reason);
 	return -EINVAL;
 }
 
