tcp: md5: fix IPv4-mapped support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Eric Dumazet <edumazet@google.com>
commit e62d2e110356093c034998e093675df83057e511
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/e62d2e11.failed

After the blamed commit, IPv4 SYN packets handled
by a dual stack IPv6 socket are dropped, even if
perfectly valid.

$ nstat | grep MD5
TcpExtTCPMD5Failure             5                  0.0

For a dual stack listener, an incoming IPv4 SYN packet
would call tcp_inbound_md5_hash() with @family == AF_INET,
while tp->af_specific is pointing to tcp_sock_ipv6_specific.

Only later when an IPv4-mapped child is created, tp->af_specific
is changed to tcp_sock_ipv6_mapped_specific.

Fixes: 7bbb765b7349 ("net/tcp: Merge TCP-MD5 inbound callbacks")
	Reported-by: Brian Vazquez <brianvv@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Reviewed-by: Dmitry Safonov <dima@arista.com>
	Tested-by: Leonard Crestez <cdleonard@gmail.com>
Link: https://lore.kernel.org/r/20220726115743.2759832-1-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit e62d2e110356093c034998e093675df83057e511)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index 2fededb1560d,766881775abb..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -3921,6 -4416,82 +3921,85 @@@ int tcp_md5_hash_key(struct tcp_md5sig_
  }
  EXPORT_SYMBOL(tcp_md5_hash_key);
  
++<<<<<<< HEAD
++=======
+ /* Called with rcu_read_lock() */
+ enum skb_drop_reason
+ tcp_inbound_md5_hash(const struct sock *sk, const struct sk_buff *skb,
+ 		     const void *saddr, const void *daddr,
+ 		     int family, int dif, int sdif)
+ {
+ 	/*
+ 	 * This gets called for each TCP segment that arrives
+ 	 * so we want to be efficient.
+ 	 * We have 3 drop cases:
+ 	 * o No MD5 hash and one expected.
+ 	 * o MD5 hash and we're not expecting one.
+ 	 * o MD5 hash and its wrong.
+ 	 */
+ 	const __u8 *hash_location = NULL;
+ 	struct tcp_md5sig_key *hash_expected;
+ 	const struct tcphdr *th = tcp_hdr(skb);
+ 	struct tcp_sock *tp = tcp_sk(sk);
+ 	int genhash, l3index;
+ 	u8 newhash[16];
+ 
+ 	/* sdif set, means packet ingressed via a device
+ 	 * in an L3 domain and dif is set to the l3mdev
+ 	 */
+ 	l3index = sdif ? dif : 0;
+ 
+ 	hash_expected = tcp_md5_do_lookup(sk, l3index, saddr, family);
+ 	hash_location = tcp_parse_md5sig_option(th);
+ 
+ 	/* We've parsed the options - do we have a hash? */
+ 	if (!hash_expected && !hash_location)
+ 		return SKB_NOT_DROPPED_YET;
+ 
+ 	if (hash_expected && !hash_location) {
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);
+ 		return SKB_DROP_REASON_TCP_MD5NOTFOUND;
+ 	}
+ 
+ 	if (!hash_expected && hash_location) {
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);
+ 		return SKB_DROP_REASON_TCP_MD5UNEXPECTED;
+ 	}
+ 
+ 	/* Check the signature.
+ 	 * To support dual stack listeners, we need to handle
+ 	 * IPv4-mapped case.
+ 	 */
+ 	if (family == AF_INET)
+ 		genhash = tcp_v4_md5_hash_skb(newhash,
+ 					      hash_expected,
+ 					      NULL, skb);
+ 	else
+ 		genhash = tp->af_specific->calc_md5_hash(newhash,
+ 							 hash_expected,
+ 							 NULL, skb);
+ 
+ 	if (genhash || memcmp(hash_location, newhash, 16) != 0) {
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);
+ 		if (family == AF_INET) {
+ 			net_info_ratelimited("MD5 Hash failed for (%pI4, %d)->(%pI4, %d)%s L3 index %d\n",
+ 					saddr, ntohs(th->source),
+ 					daddr, ntohs(th->dest),
+ 					genhash ? " tcp_v4_calc_md5_hash failed"
+ 					: "", l3index);
+ 		} else {
+ 			net_info_ratelimited("MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u L3 index %d\n",
+ 					genhash ? "failed" : "mismatch",
+ 					saddr, ntohs(th->source),
+ 					daddr, ntohs(th->dest), l3index);
+ 		}
+ 		return SKB_DROP_REASON_TCP_MD5FAILURE;
+ 	}
+ 	return SKB_NOT_DROPPED_YET;
+ }
+ EXPORT_SYMBOL(tcp_inbound_md5_hash);
+ 
++>>>>>>> e62d2e110356 (tcp: md5: fix IPv4-mapped support)
  #endif
  
  void tcp_done(struct sock *sk)
* Unmerged path net/ipv4/tcp.c
