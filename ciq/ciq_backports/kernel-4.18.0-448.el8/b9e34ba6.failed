ath11k: mhi: remove unnecessary goto from ath11k_mhi_start()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Kalle Valo <quic_kvalo@quicinc.com>
commit b9e34ba6b314780a47ac40f450ec04f18be85b5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b9e34ba6.failed

No need to have goto for a return statement, so simplify the code. While at it,
print warning messages if power up calls fail.

No functional changes.

Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2

	Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
Link: https://lore.kernel.org/r/20220401173042.17467-4-kvalo@kernel.org
(cherry picked from commit b9e34ba6b314780a47ac40f450ec04f18be85b5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/ath11k/mhi.c
diff --cc drivers/net/wireless/ath/ath11k/mhi.c
index 61d83be4841f,c44df17719f6..000000000000
--- a/drivers/net/wireless/ath/ath11k/mhi.c
+++ b/drivers/net/wireless/ath/ath11k/mhi.c
@@@ -461,202 -463,26 +461,214 @@@ void ath11k_mhi_unregister(struct ath11
  	mhi_free_controller(mhi_ctrl);
  }
  
 +static char *ath11k_mhi_state_to_str(enum ath11k_mhi_state mhi_state)
 +{
 +	switch (mhi_state) {
 +	case ATH11K_MHI_INIT:
 +		return "INIT";
 +	case ATH11K_MHI_DEINIT:
 +		return "DEINIT";
 +	case ATH11K_MHI_POWER_ON:
 +		return "POWER_ON";
 +	case ATH11K_MHI_POWER_OFF:
 +		return "POWER_OFF";
 +	case ATH11K_MHI_FORCE_POWER_OFF:
 +		return "FORCE_POWER_OFF";
 +	case ATH11K_MHI_SUSPEND:
 +		return "SUSPEND";
 +	case ATH11K_MHI_RESUME:
 +		return "RESUME";
 +	case ATH11K_MHI_TRIGGER_RDDM:
 +		return "TRIGGER_RDDM";
 +	case ATH11K_MHI_RDDM_DONE:
 +		return "RDDM_DONE";
 +	default:
 +		return "UNKNOWN";
 +	}
 +};
 +
 +static void ath11k_mhi_set_state_bit(struct ath11k_pci *ab_pci,
 +				     enum ath11k_mhi_state mhi_state)
 +{
 +	struct ath11k_base *ab = ab_pci->ab;
 +
 +	switch (mhi_state) {
 +	case ATH11K_MHI_INIT:
 +		set_bit(ATH11K_MHI_INIT, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_DEINIT:
 +		clear_bit(ATH11K_MHI_INIT, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_POWER_ON:
 +		set_bit(ATH11K_MHI_POWER_ON, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_POWER_OFF:
 +	case ATH11K_MHI_FORCE_POWER_OFF:
 +		clear_bit(ATH11K_MHI_POWER_ON, &ab_pci->mhi_state);
 +		clear_bit(ATH11K_MHI_TRIGGER_RDDM, &ab_pci->mhi_state);
 +		clear_bit(ATH11K_MHI_RDDM_DONE, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_SUSPEND:
 +		set_bit(ATH11K_MHI_SUSPEND, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_RESUME:
 +		clear_bit(ATH11K_MHI_SUSPEND, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_TRIGGER_RDDM:
 +		set_bit(ATH11K_MHI_TRIGGER_RDDM, &ab_pci->mhi_state);
 +		break;
 +	case ATH11K_MHI_RDDM_DONE:
 +		set_bit(ATH11K_MHI_RDDM_DONE, &ab_pci->mhi_state);
 +		break;
 +	default:
 +		ath11k_err(ab, "unhandled mhi state (%d)\n", mhi_state);
 +	}
 +}
 +
 +static int ath11k_mhi_check_state_bit(struct ath11k_pci *ab_pci,
 +				      enum ath11k_mhi_state mhi_state)
 +{
 +	struct ath11k_base *ab = ab_pci->ab;
 +
 +	switch (mhi_state) {
 +	case ATH11K_MHI_INIT:
 +		if (!test_bit(ATH11K_MHI_INIT, &ab_pci->mhi_state))
 +			return 0;
 +		break;
 +	case ATH11K_MHI_DEINIT:
 +	case ATH11K_MHI_POWER_ON:
 +		if (test_bit(ATH11K_MHI_INIT, &ab_pci->mhi_state) &&
 +		    !test_bit(ATH11K_MHI_POWER_ON, &ab_pci->mhi_state))
 +			return 0;
 +		break;
 +	case ATH11K_MHI_FORCE_POWER_OFF:
 +		if (test_bit(ATH11K_MHI_POWER_ON, &ab_pci->mhi_state))
 +			return 0;
 +		break;
 +	case ATH11K_MHI_POWER_OFF:
 +	case ATH11K_MHI_SUSPEND:
 +		if (test_bit(ATH11K_MHI_POWER_ON, &ab_pci->mhi_state) &&
 +		    !test_bit(ATH11K_MHI_SUSPEND, &ab_pci->mhi_state))
 +			return 0;
 +		break;
 +	case ATH11K_MHI_RESUME:
 +		if (test_bit(ATH11K_MHI_SUSPEND, &ab_pci->mhi_state))
 +			return 0;
 +		break;
 +	case ATH11K_MHI_TRIGGER_RDDM:
 +		if (test_bit(ATH11K_MHI_POWER_ON, &ab_pci->mhi_state) &&
 +		    !test_bit(ATH11K_MHI_TRIGGER_RDDM, &ab_pci->mhi_state))
 +			return 0;
 +		break;
 +	case ATH11K_MHI_RDDM_DONE:
 +		return 0;
 +	default:
 +		ath11k_err(ab, "unhandled mhi state: %s(%d)\n",
 +			   ath11k_mhi_state_to_str(mhi_state), mhi_state);
 +	}
 +
 +	ath11k_err(ab, "failed to set mhi state %s(%d) in current mhi state (0x%lx)\n",
 +		   ath11k_mhi_state_to_str(mhi_state), mhi_state,
 +		   ab_pci->mhi_state);
 +
 +	return -EINVAL;
 +}
 +
 +static int ath11k_mhi_set_state(struct ath11k_pci *ab_pci,
 +				enum ath11k_mhi_state mhi_state)
 +{
 +	struct ath11k_base *ab = ab_pci->ab;
 +	int ret;
 +
 +	ret = ath11k_mhi_check_state_bit(ab_pci, mhi_state);
 +	if (ret)
 +		goto out;
 +
 +	ath11k_dbg(ab, ATH11K_DBG_PCI, "setting mhi state: %s(%d)\n",
 +		   ath11k_mhi_state_to_str(mhi_state), mhi_state);
 +
 +	switch (mhi_state) {
 +	case ATH11K_MHI_INIT:
 +		ret = mhi_prepare_for_power_up(ab_pci->mhi_ctrl);
 +		break;
 +	case ATH11K_MHI_DEINIT:
 +		mhi_unprepare_after_power_down(ab_pci->mhi_ctrl);
 +		ret = 0;
 +		break;
 +	case ATH11K_MHI_POWER_ON:
 +		ret = mhi_sync_power_up(ab_pci->mhi_ctrl);
 +		break;
 +	case ATH11K_MHI_POWER_OFF:
 +		mhi_power_down(ab_pci->mhi_ctrl, true);
 +		ret = 0;
 +		break;
 +	case ATH11K_MHI_FORCE_POWER_OFF:
 +		mhi_power_down(ab_pci->mhi_ctrl, false);
 +		ret = 0;
 +		break;
 +	case ATH11K_MHI_SUSPEND:
 +		ret = mhi_pm_suspend(ab_pci->mhi_ctrl);
 +		break;
 +	case ATH11K_MHI_RESUME:
 +		/* Do force MHI resume as some devices like QCA6390, WCN6855
 +		 * are not in M3 state but they are functional. So just ignore
 +		 * the MHI state while resuming.
 +		 */
 +		ret = mhi_pm_resume_force(ab_pci->mhi_ctrl);
 +		break;
 +	case ATH11K_MHI_TRIGGER_RDDM:
 +		ret = mhi_force_rddm_mode(ab_pci->mhi_ctrl);
 +		break;
 +	case ATH11K_MHI_RDDM_DONE:
 +		break;
 +	default:
 +		ath11k_err(ab, "unhandled MHI state (%d)\n", mhi_state);
 +		ret = -EINVAL;
 +	}
 +
 +	if (ret)
 +		goto out;
 +
 +	ath11k_mhi_set_state_bit(ab_pci, mhi_state);
 +
 +	return 0;
 +
 +out:
 +	ath11k_err(ab, "failed to set mhi state: %s(%d)\n",
 +		   ath11k_mhi_state_to_str(mhi_state), mhi_state);
 +	return ret;
 +}
 +
  int ath11k_mhi_start(struct ath11k_pci *ab_pci)
  {
+ 	struct ath11k_base *ab = ab_pci->ab;
  	int ret;
  
  	ab_pci->mhi_ctrl->timeout_ms = MHI_TIMEOUT_DEFAULT_MS;
  
++<<<<<<< HEAD
 +	ret = ath11k_mhi_set_state(ab_pci, ATH11K_MHI_INIT);
 +	if (ret)
 +		goto out;
 +
 +	ret = ath11k_mhi_set_state(ab_pci, ATH11K_MHI_POWER_ON);
 +	if (ret)
 +		goto out;
++=======
+ 	ret = mhi_prepare_for_power_up(ab_pci->mhi_ctrl);
+ 	if (ret) {
+ 		ath11k_warn(ab, "failed to prepare mhi: %d", ret);
+ 		return ret;
+ 	}
  
- 	return 0;
+ 	ret = mhi_sync_power_up(ab_pci->mhi_ctrl);
+ 	if (ret) {
+ 		ath11k_warn(ab, "failed to power up mhi: %d", ret);
+ 		return ret;
+ 	}
++>>>>>>> b9e34ba6b314 (ath11k: mhi: remove unnecessary goto from ath11k_mhi_start())
  
- out:
- 	return ret;
+ 	return 0;
  }
  
  void ath11k_mhi_stop(struct ath11k_pci *ab_pci)
* Unmerged path drivers/net/wireless/ath/ath11k/mhi.c
