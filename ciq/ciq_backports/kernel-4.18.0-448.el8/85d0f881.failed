ASoC: SOF: ipc: Switch over to use the tx_msg and set_get_data ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit 85d0f881471531ffb081711b13df32b1f6f1f637
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/85d0f881.failed

Use the new ops for sending messages and to handle large component data
set get operation.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Daniel Baluta <daniel.baluta@nxp.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Link: https://lore.kernel.org/r/20220405172708.122168-12-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 85d0f881471531ffb081711b13df32b1f6f1f637)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc.c
diff --cc sound/soc/sof/ipc.c
index 8fa056049072,05c1ba0c2206..000000000000
--- a/sound/soc/sof/ipc.c
+++ b/sound/soc/sof/ipc.c
@@@ -393,24 -282,15 +281,28 @@@ int sof_ipc_send_msg(struct snd_sof_de
  }
  
  /* send IPC message from host to DSP */
 -int sof_ipc_tx_message(struct snd_sof_ipc *ipc, void *msg_data, size_t msg_bytes,
 -		       void *reply_data, size_t reply_bytes)
 +int sof_ipc_tx_message(struct snd_sof_ipc *ipc, u32 header,
 +		       void *msg_data, size_t msg_bytes, void *reply_data,
 +		       size_t reply_bytes)
  {
- 	const struct sof_dsp_power_state target_state = {
- 		.state = SOF_DSP_PM_D0,
- 	};
- 	int ret;
+ 	if (msg_bytes > ipc->max_payload_size ||
+ 	    reply_bytes > ipc->max_payload_size)
+ 		return -ENOBUFS;
  
++<<<<<<< HEAD
 +	/* ensure the DSP is in D0 before sending a new IPC */
 +	ret = snd_sof_dsp_set_power_state(ipc->sdev, &target_state);
 +	if (ret < 0) {
 +		dev_err(ipc->sdev->dev, "error: resuming DSP %d\n", ret);
 +		return ret;
 +	}
 +
 +	return sof_ipc_tx_message_no_pm(ipc, header, msg_data, msg_bytes,
 +					reply_data, reply_bytes);
++=======
+ 	return ipc->ops->tx_msg(ipc->sdev, msg_data, msg_bytes, reply_data,
+ 				reply_bytes, false);
++>>>>>>> 85d0f8814715 (ASoC: SOF: ipc: Switch over to use the tx_msg and set_get_data ops)
  }
  EXPORT_SYMBOL(sof_ipc_tx_message);
  
@@@ -419,12 -299,9 +311,10 @@@
   * This will be used for IPC's that can be handled by the DSP
   * even in a low-power D0 substate.
   */
 -int sof_ipc_tx_message_no_pm(struct snd_sof_ipc *ipc, void *msg_data, size_t msg_bytes,
 +int sof_ipc_tx_message_no_pm(struct snd_sof_ipc *ipc, u32 header,
 +			     void *msg_data, size_t msg_bytes,
  			     void *reply_data, size_t reply_bytes)
  {
- 	int ret;
- 
  	if (msg_bytes > ipc->max_payload_size ||
  	    reply_bytes > ipc->max_payload_size)
  		return -ENOBUFS;
@@@ -818,17 -595,13 +604,19 @@@ EXPORT_SYMBOL(snd_sof_ipc_stream_posn)
  int snd_sof_ipc_set_get_comp_data(struct snd_sof_control *scontrol, bool set)
  {
  	struct snd_soc_component *scomp = scontrol->scomp;
 -	struct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;
 +	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
  	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
- 	struct sof_ipc_fw_ready *ready = &sdev->fw_ready;
- 	struct sof_ipc_fw_version *v = &ready->version;
- 	struct sof_ipc_ctrl_data_params sparams;
+ 	const struct sof_ipc_ops *iops = sdev->ipc->ops;
  	enum sof_ipc_ctrl_type ctrl_type;
  	struct snd_sof_widget *swidget;
  	bool widget_found = false;
++<<<<<<< HEAD
 +	size_t send_bytes;
 +	u32 ipc_cmd;
 +	int err;
++=======
+ 	u32 ipc_cmd, msg_bytes;
++>>>>>>> 85d0f8814715 (ASoC: SOF: ipc: Switch over to use the tx_msg and set_get_data ops)
  
  	list_for_each_entry(swidget, &sdev->widget_list, list) {
  		if (swidget->comp_id == scontrol->comp_id) {
@@@ -910,40 -665,10 +701,43 @@@
  		return -EINVAL;
  	}
  
- 	cdata->rhdr.hdr.size = sparams.msg_bytes + sparams.hdr_bytes;
- 	cdata->num_elems = sparams.elems;
+ 	cdata->rhdr.hdr.size = msg_bytes;
  	cdata->elems_remaining = 0;
  
++<<<<<<< HEAD
 +	/* send normal size ipc in one part */
 +	if (cdata->rhdr.hdr.size <= SOF_IPC_MSG_MAX_SIZE) {
 +		err = sof_ipc_tx_message(sdev->ipc, cdata->rhdr.hdr.cmd, cdata,
 +					 cdata->rhdr.hdr.size, cdata,
 +					 cdata->rhdr.hdr.size);
 +
 +		if (err < 0)
 +			dev_err(sdev->dev, "error: set/get ctrl ipc comp %d\n",
 +				cdata->comp_id);
 +
 +		return err;
 +	}
 +
 +	/* data is bigger than max ipc size, chop into smaller pieces */
 +	dev_dbg(sdev->dev, "large ipc size %u, control size %u\n",
 +		cdata->rhdr.hdr.size, scontrol->size);
 +
 +	/* large messages is only supported from ABI 3.3.0 onwards */
 +	if (v->abi_version < SOF_ABI_VER(3, 3, 0)) {
 +		dev_err(sdev->dev, "error: incompatible FW ABI version\n");
 +		return -EINVAL;
 +	}
 +
 +	err = sof_set_get_large_ctrl_data(sdev, cdata, &sparams, set);
 +
 +	if (err < 0)
 +		dev_err(sdev->dev, "error: set/get large ctrl ipc comp %d\n",
 +			cdata->comp_id);
 +
 +	return err;
++=======
+ 	return iops->set_get_data(sdev, cdata, cdata->rhdr.hdr.size, set);
++>>>>>>> 85d0f8814715 (ASoC: SOF: ipc: Switch over to use the tx_msg and set_get_data ops)
  }
  EXPORT_SYMBOL(snd_sof_ipc_set_get_comp_data);
  
* Unmerged path sound/soc/sof/ipc.c
