wifi: mac80211: mlme: fix link_sta setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit b18d87f5d1025b55351378f953f644f07b1040b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b18d87f5.failed

We need to copy the address to both the private and public
portion of the link_sta (the private one is needed for the
hash table). Fix this.

Fixes: bbe90107e1d9 ("wifi: mac80211: mlme: refactor link station setup")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit b18d87f5d1025b55351378f953f644f07b1040b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,cca05d3c5732..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -3811,1306 -4211,127 +3811,1325 @@@ static bool ieee80211_assoc_success(str
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
 +					 struct ieee80211_mgmt *mgmt,
 +					 size_t len)
++=======
+ static int ieee80211_mgd_setup_link_sta(struct ieee80211_link_data *link,
+ 					struct sta_info *sta,
+ 					struct link_sta_info *link_sta,
+ 					struct cfg80211_bss *cbss)
++>>>>>>> b18d87f5d102 (wifi: mac80211: mlme: fix link_sta setup)
  {
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 -	struct ieee80211_local *local = sdata->local;
 -	struct ieee80211_bss *bss = (void *)cbss->priv;
 -	u32 rates = 0, basic_rates = 0;
 -	bool have_higher_than_11mbit = false;
 -	int min_rate = INT_MAX, min_rate_index = -1;
 -	/* this is clearly wrong for MLO but we'll just remove it later */
 -	int shift = ieee80211_vif_get_shift(&sdata->vif);
 -	struct ieee80211_supported_band *sband;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
 +	u16 capab_info, status_code, aid;
 +	struct ieee802_11_elems *elems;
 +	int ac, uapsd_queues = -1;
 +	u8 *pos;
 +	bool reassoc;
 +	struct cfg80211_bss *cbss;
 +	struct ieee80211_event event = {
 +		.type = MLME_EVENT,
 +		.u.mlme.data = ASSOC_EVENT,
 +	};
 +	struct ieee80211_prep_tx_info info = {};
  
++<<<<<<< HEAD
 +	sdata_assert_lock(sdata);
++=======
+ 	memcpy(link_sta->addr, cbss->bssid, ETH_ALEN);
+ 	memcpy(link_sta->pub->addr, cbss->bssid, ETH_ALEN);
++>>>>>>> b18d87f5d102 (wifi: mac80211: mlme: fix link_sta setup)
  
 -	/* TODO: S1G Basic Rate Set is expressed elsewhere */
 -	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
 -		ieee80211_s1g_sta_rate_init(sta);
 -		return 0;
 -	}
 +	if (!assoc_data)
 +		return;
  
 -	sband = local->hw.wiphy->bands[cbss->channel->band];
 +	if (!ether_addr_equal(assoc_data->bss->bssid, mgmt->bssid))
 +		return;
  
 -	ieee80211_get_rates(sband, bss->supp_rates, bss->supp_rates_len,
 -			    &rates, &basic_rates, &have_higher_than_11mbit,
 -			    &min_rate, &min_rate_index, shift);
 +	cbss = assoc_data->bss;
  
  	/*
 -	 * This used to be a workaround for basic rates missing
 -	 * in the association response frame. Now that we no
 -	 * longer use the basic rates from there, it probably
 -	 * doesn't happen any more, but keep the workaround so
 -	 * in case some *other* APs are buggy in different ways
 -	 * we can connect -- with a warning.
 -	 * Allow this workaround only in case the AP provided at least
 -	 * one rate.
 +	 * AssocResp and ReassocResp have identical structure, so process both
 +	 * of them in this function.
  	 */
 -	if (min_rate_index < 0) {
 -		link_info(link, "No legacy rates in association response\n");
 -		return -EINVAL;
 -	} else if (!basic_rates) {
 -		link_info(link, "No basic rates, using min rate instead\n");
 -		basic_rates = BIT(min_rate_index);
 +
 +	if (len < 24 + 6)
 +		return;
 +
 +	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
 +	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
 +	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
 +	pos = mgmt->u.assoc_resp.variable;
 +	aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
 +	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
 +		pos = (u8 *) mgmt->u.s1g_assoc_resp.variable;
 +		aid = 0; /* TODO */
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Note: this may not be perfect, AP might misbehave - if
 +	 * anyone needs to rely on perfect complete notification
 +	 * with the exact right subtype, then we need to track what
 +	 * we actually transmitted.
 +	 */
 +	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
 +				 IEEE80211_STYPE_ASSOC_REQ;
++=======
+ 	if (rates)
+ 		link_sta->pub->supp_rates[cbss->channel->band] = rates;
+ 	else
+ 		link_info(link, "No rates found, keeping mandatory only\n");
++>>>>>>> b18d87f5d102 (wifi: mac80211: mlme: fix link_sta setup)
  
 -	link->conf->basic_rates = basic_rates;
 +	sdata_info(sdata,
 +		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
 +		   reassoc ? "Rea" : "A", mgmt->sa,
 +		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
  
 -	/* cf. IEEE 802.11 9.2.12 */
 -	link->operating_11g_mode = sband->band == NL80211_BAND_2GHZ &&
 -				   have_higher_than_11mbit;
 +	if (assoc_data->fils_kek_len &&
 +	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
 +		return;
  
 -	return 0;
 -}
 +	elems = ieee802_11_parse_elems(pos, len - (pos - (u8 *)mgmt), false,
 +				       assoc_data->bss);
 +	if (!elems)
 +		goto notify_driver;
  
 -static u8 ieee80211_max_rx_chains(struct ieee80211_link_data *link,
 -				  struct cfg80211_bss *cbss)
 -{
 -	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
 -	const struct element *ht_cap_elem, *vht_cap_elem;
 -	const struct cfg80211_bss_ies *ies;
 -	const struct ieee80211_ht_cap *ht_cap;
 -	const struct ieee80211_vht_cap *vht_cap;
 -	const struct ieee80211_he_cap_elem *he_cap;
 -	const struct element *he_cap_elem;
 -	u16 mcs_80_map, mcs_160_map;
 -	int i, mcs_nss_size;
 -	bool support_160;
 -	u8 chains = 1;
 +	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
 +	    elems->timeout_int &&
 +	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
 +		u32 tu, ms;
  
 -	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)
 -		return chains;
 +		cfg80211_assoc_comeback(sdata->dev, assoc_data->bss->bssid,
 +					le32_to_cpu(elems->timeout_int->value));
  
 -	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
 -	if (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {
 -		ht_cap = (void *)ht_cap_elem->data;
 -		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
 -		/*
 -		 * TODO: use "Tx Maximum Number Spatial Streams Supported" and
 -		 *	 "Tx Unequal Modulation Supported" fields.
 -		 */
 +		tu = le32_to_cpu(elems->timeout_int->value);
 +		ms = tu * 1024 / 1000;
 +		sdata_info(sdata,
 +			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
 +			   mgmt->sa, tu, ms);
 +		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
 +		assoc_data->timeout_started = true;
 +		if (ms > IEEE80211_ASSOC_TIMEOUT)
 +			run_again(sdata, assoc_data->timeout);
 +		goto notify_driver;
  	}
  
 -	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
 -		return chains;
 -
 -	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
 -	if (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {
 -		u8 nss;
 -		u16 tx_mcs_map;
 -
 -		vht_cap = (void *)vht_cap_elem->data;
 -		tx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
 -		for (nss = 8; nss > 0; nss--) {
 -			if (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=
 -					IEEE80211_VHT_MCS_NOT_SUPPORTED)
 -				break;
 +	if (status_code != WLAN_STATUS_SUCCESS) {
 +		sdata_info(sdata, "%pM denied association (code=%d)\n",
 +			   mgmt->sa, status_code);
 +		ieee80211_destroy_assoc_data(sdata, ASSOC_REJECTED);
 +		event.u.mlme.status = MLME_DENIED;
 +		event.u.mlme.reason = status_code;
 +		drv_event_callback(sdata->local, sdata, &event);
 +	} else {
 +		if (!ieee80211_assoc_success(sdata, cbss, mgmt, len, elems)) {
 +			/* oops -- internal error -- send timeout for now */
 +			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
 +			goto notify_driver;
  		}
 -		/* TODO: use "Tx Highest Supported Long GI Data Rate" field? */
 -		chains = max(chains, nss);
 -	}
 +		event.u.mlme.status = MLME_SUCCESS;
 +		drv_event_callback(sdata->local, sdata, &event);
 +		sdata_info(sdata, "associated\n");
  
 -	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)
 -		return chains;
 +		/*
 +		 * destroy assoc_data afterwards, as otherwise an idle
 +		 * recalc after assoc_data is NULL but before associated
 +		 * is set can cause the interface to go idle
 +		 */
 +		ieee80211_destroy_assoc_data(sdata, ASSOC_SUCCESS);
  
 -	ies = rcu_dereference(cbss->ies);
 -	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
 -					     ies->data, ies->len);
 +		/* get uapsd queues configuration */
 +		uapsd_queues = 0;
 +		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 +			if (sdata->tx_conf[ac].uapsd)
 +				uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
  
 -	if (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))
 -		return chains;
 +		info.success = 1;
 +	}
  
 -	/* skip one byte ext_tag_id */
 -	he_cap = (void *)(he_cap_elem->data + 1);
 +	cfg80211_rx_assoc_resp(sdata->dev, cbss, (u8 *)mgmt, len, uapsd_queues,
 +			       ifmgd->assoc_req_ies, ifmgd->assoc_req_ies_len);
 +notify_driver:
 +	drv_mgd_complete_tx(sdata->local, sdata, &info);
 +	kfree(elems);
 +}
 +
 +static void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,
 +				  struct ieee80211_mgmt *mgmt, size_t len,
 +				  struct ieee80211_rx_status *rx_status)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_bss *bss;
 +	struct ieee80211_channel *channel;
 +
 +	sdata_assert_lock(sdata);
 +
 +	channel = ieee80211_get_channel_khz(local->hw.wiphy,
 +					ieee80211_rx_status_to_khz(rx_status));
 +	if (!channel)
 +		return;
 +
 +	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
 +	if (bss) {
 +		sdata->vif.bss_conf.beacon_rate = bss->beacon_rate;
 +		ieee80211_rx_bss_put(local, bss);
 +	}
 +}
 +
 +
 +static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_sub_if_data *sdata,
 +					 struct sk_buff *skb)
 +{
 +	struct ieee80211_mgmt *mgmt = (void *)skb->data;
 +	struct ieee80211_if_managed *ifmgd;
 +	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
 +	struct ieee80211_channel *channel;
 +	size_t baselen, len = skb->len;
 +
 +	ifmgd = &sdata->u.mgd;
 +
 +	sdata_assert_lock(sdata);
 +
 +	/*
 +	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
 +	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
 +	 * a Probe Response frame [..], the Address 1 field of the Probe
 +	 * Response frame shall be set to the broadcast address [..]"
 +	 * So, on 6GHz band we should also accept broadcast responses.
 +	 */
 +	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
 +					rx_status->freq);
 +	if (!channel)
 +		return;
 +
 +	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
 +	    (channel->band != NL80211_BAND_6GHZ ||
 +	     !is_broadcast_ether_addr(mgmt->da)))
 +		return; /* ignore ProbeResp to foreign address */
 +
 +	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
 +	if (baselen > len)
 +		return;
 +
 +	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
 +
 +	if (ifmgd->associated &&
 +	    ether_addr_equal(mgmt->bssid, ifmgd->bssid))
 +		ieee80211_reset_ap_probe(sdata);
 +}
 +
 +/*
 + * This is the canonical list of information elements we care about,
 + * the filter code also gives us all changes to the Microsoft OUI
 + * (00:50:F2) vendor IE which is used for WMM which we need to track,
 + * as well as the DTPC IE (part of the Cisco OUI) used for signaling
 + * changes to requested client power.
 + *
 + * We implement beacon filtering in software since that means we can
 + * avoid processing the frame here and in cfg80211, and userspace
 + * will not be able to tell whether the hardware supports it or not.
 + *
 + * XXX: This list needs to be dynamic -- userspace needs to be able to
 + *	add items it requires. It also needs to be able to tell us to
 + *	look out for other vendor IEs.
 + */
 +static const u64 care_about_ies =
 +	(1ULL << WLAN_EID_COUNTRY) |
 +	(1ULL << WLAN_EID_ERP_INFO) |
 +	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
 +	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
 +	(1ULL << WLAN_EID_HT_CAPABILITY) |
 +	(1ULL << WLAN_EID_HT_OPERATION) |
 +	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
 +
 +static void ieee80211_handle_beacon_sig(struct ieee80211_sub_if_data *sdata,
 +					struct ieee80211_if_managed *ifmgd,
 +					struct ieee80211_bss_conf *bss_conf,
 +					struct ieee80211_local *local,
 +					struct ieee80211_rx_status *rx_status)
 +{
 +	/* Track average RSSI from the Beacon frames of the current AP */
 +
 +	if (ifmgd->flags & IEEE80211_STA_RESET_SIGNAL_AVE) {
 +		ifmgd->flags &= ~IEEE80211_STA_RESET_SIGNAL_AVE;
 +		ewma_beacon_signal_init(&ifmgd->ave_beacon_signal);
 +		ifmgd->last_cqm_event_signal = 0;
 +		ifmgd->count_beacon_signal = 1;
 +		ifmgd->last_ave_beacon_signal = 0;
 +	} else {
 +		ifmgd->count_beacon_signal++;
 +	}
 +
 +	ewma_beacon_signal_add(&ifmgd->ave_beacon_signal, -rx_status->signal);
 +
 +	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_sig = ifmgd->last_ave_beacon_signal;
 +		struct ieee80211_event event = {
 +			.type = RSSI_EVENT,
 +		};
 +
 +		/*
 +		 * if signal crosses either of the boundaries, invoke callback
 +		 * with appropriate parameters
 +		 */
 +		if (sig > ifmgd->rssi_max_thold &&
 +		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
 +			ifmgd->last_ave_beacon_signal = sig;
 +			event.u.rssi.data = RSSI_EVENT_HIGH;
 +			drv_event_callback(local, sdata, &event);
 +		} else if (sig < ifmgd->rssi_min_thold &&
 +			   (last_sig >= ifmgd->rssi_max_thold ||
 +			   last_sig == 0)) {
 +			ifmgd->last_ave_beacon_signal = sig;
 +			event.u.rssi.data = RSSI_EVENT_LOW;
 +			drv_event_callback(local, sdata, &event);
 +		}
 +	}
 +
 +	if (bss_conf->cqm_rssi_thold &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
 +	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_event = ifmgd->last_cqm_event_signal;
 +		int thold = bss_conf->cqm_rssi_thold;
 +		int hyst = bss_conf->cqm_rssi_hyst;
 +
 +		if (sig < thold &&
 +		    (last_event == 0 || sig < last_event - hyst)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 +				sig, GFP_KERNEL);
 +		} else if (sig > thold &&
 +			   (last_event == 0 || sig > last_event + hyst)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 +				sig, GFP_KERNEL);
 +		}
 +	}
 +
 +	if (bss_conf->cqm_rssi_low &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_event = ifmgd->last_cqm_event_signal;
 +		int low = bss_conf->cqm_rssi_low;
 +		int high = bss_conf->cqm_rssi_high;
 +
 +		if (sig < low &&
 +		    (last_event == 0 || last_event >= low)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 +				sig, GFP_KERNEL);
 +		} else if (sig > high &&
 +			   (last_event == 0 || last_event <= high)) {
 +			ifmgd->last_cqm_event_signal = sig;
 +			ieee80211_cqm_rssi_notify(
 +				&sdata->vif,
 +				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 +				sig, GFP_KERNEL);
 +		}
 +	}
 +}
 +
 +static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
 +				    struct cfg80211_bss *bss)
 +{
 +	if (ether_addr_equal(tx_bssid, bss->bssid))
 +		return true;
 +	if (!bss->transmitted_bss)
 +		return false;
 +	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
 +}
 +
 +static void ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
 +				     struct ieee80211_hdr *hdr, size_t len,
 +				     struct ieee80211_rx_status *rx_status)
 +{
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +	struct ieee80211_mgmt *mgmt = (void *) hdr;
 +	size_t baselen;
 +	struct ieee802_11_elems *elems;
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_chanctx_conf *chanctx_conf;
 +	struct ieee80211_channel *chan;
 +	struct sta_info *sta;
 +	u32 changed = 0;
 +	bool erp_valid;
 +	u8 erp_value = 0;
 +	u32 ncrc = 0;
 +	u8 *bssid, *variable = mgmt->u.beacon.variable;
 +	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
 +
 +	sdata_assert_lock(sdata);
 +
 +	/* Process beacon from the current BSS */
 +	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
 +	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
 +		struct ieee80211_ext *ext = (void *) mgmt;
 +
 +		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
 +			variable = ext->u.s1g_short_beacon.variable;
 +		else
 +			variable = ext->u.s1g_beacon.variable;
 +	}
 +
 +	baselen = (u8 *) variable - (u8 *) mgmt;
 +	if (baselen > len)
 +		return;
 +
 +	rcu_read_lock();
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 +	if (!chanctx_conf) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +
 +	if (ieee80211_rx_status_to_khz(rx_status) !=
 +	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +	chan = chanctx_conf->def.chan;
 +	rcu_read_unlock();
 +
 +	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
 +	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->bss)) {
 +		elems = ieee802_11_parse_elems(variable, len - baselen, false,
 +					       ifmgd->assoc_data->bss);
 +		if (!elems)
 +			return;
 +
 +		ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
 +
 +		if (elems->dtim_period)
 +			ifmgd->dtim_period = elems->dtim_period;
 +		ifmgd->have_beacon = true;
 +		ifmgd->assoc_data->need_beacon = false;
 +		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
 +			sdata->vif.bss_conf.sync_tsf =
 +				le64_to_cpu(mgmt->u.beacon.timestamp);
 +			sdata->vif.bss_conf.sync_device_ts =
 +				rx_status->device_timestamp;
 +			sdata->vif.bss_conf.sync_dtim_count = elems->dtim_count;
 +		}
 +
 +		if (elems->mbssid_config_ie)
 +			bss_conf->profile_periodicity =
 +				elems->mbssid_config_ie->profile_periodicity;
 +		else
 +			bss_conf->profile_periodicity = 0;
 +
 +		if (elems->ext_capab_len >= 11 &&
 +		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
 +			bss_conf->ema_ap = true;
 +		else
 +			bss_conf->ema_ap = false;
 +
 +		/* continue assoc process */
 +		ifmgd->assoc_data->timeout = jiffies;
 +		ifmgd->assoc_data->timeout_started = true;
 +		run_again(sdata, ifmgd->assoc_data->timeout);
 +		kfree(elems);
 +		return;
 +	}
 +
 +	if (!ifmgd->associated ||
 +	    !ieee80211_rx_our_beacon(bssid, ifmgd->assoc_bss))
 +		return;
 +	bssid = ifmgd->bssid;
 +
 +	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
 +		ieee80211_handle_beacon_sig(sdata, ifmgd, bss_conf,
 +					    local, rx_status);
 +
 +	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
 +		mlme_dbg_ratelimited(sdata,
 +				     "cancelling AP probe due to a received beacon\n");
 +		ieee80211_reset_ap_probe(sdata);
 +	}
 +
 +	/*
 +	 * Push the beacon loss detection into the future since
 +	 * we are processing a beacon from the AP just now.
 +	 */
 +	ieee80211_sta_reset_beacon_monitor(sdata);
 +
 +	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
 +	 * element (which carries the beacon interval). Don't forget to add a
 +	 * bit to care_about_ies[] above if mac80211 is interested in a
 +	 * changing S1G element.
 +	 */
 +	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
 +		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
 +	elems = ieee802_11_parse_elems_crc(variable, len - baselen,
 +					   false, care_about_ies, ncrc,
 +					   link->u.mgd.bss);
 +	if (!elems)
 +		return;
 +	ncrc = elems->crc;
 +
 +	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
 +	    ieee80211_check_tim(elems->tim, elems->tim_len, bss_conf->aid)) {
 +		if (local->hw.conf.dynamic_ps_timeout > 0) {
 +			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
 +				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
 +				ieee80211_hw_config(local,
 +						    IEEE80211_CONF_CHANGE_PS);
 +			}
 +			ieee80211_send_nullfunc(local, sdata, false);
 +		} else if (!local->pspolling && sdata->u.mgd.powersave) {
 +			local->pspolling = true;
 +
 +			/*
 +			 * Here is assumed that the driver will be
 +			 * able to send ps-poll frame and receive a
 +			 * response even though power save mode is
 +			 * enabled, but some drivers might require
 +			 * to disable power save here. This needs
 +			 * to be investigated.
 +			 */
 +			ieee80211_send_pspoll(local, sdata);
 +		}
 +	}
 +
 +	if (sdata->vif.p2p ||
 +	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
 +		struct ieee80211_p2p_noa_attr noa = {};
 +		int ret;
 +
 +		ret = cfg80211_get_p2p_attr(variable,
 +					    len - baselen,
 +					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
 +					    (u8 *) &noa, sizeof(noa));
 +		if (ret >= 2) {
 +			if (sdata->u.mgd.p2p_noa_index != noa.index) {
 +				/* valid noa_attr and index changed */
 +				sdata->u.mgd.p2p_noa_index = noa.index;
 +				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
 +				changed |= BSS_CHANGED_P2P_PS;
 +				/*
 +				 * make sure we update all information, the CRC
 +				 * mechanism doesn't look at P2P attributes.
 +				 */
 +				ifmgd->beacon_crc_valid = false;
 +			}
 +		} else if (sdata->u.mgd.p2p_noa_index != -1) {
 +			/* noa_attr not found and we had valid noa_attr before */
 +			sdata->u.mgd.p2p_noa_index = -1;
 +			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
 +			changed |= BSS_CHANGED_P2P_PS;
 +			ifmgd->beacon_crc_valid = false;
 +		}
 +	}
 +
 +	if (ifmgd->csa_waiting_bcn)
 +		ieee80211_chswitch_post_beacon(sdata);
 +
 +	/*
 +	 * Update beacon timing and dtim count on every beacon appearance. This
 +	 * will allow the driver to use the most updated values. Do it before
 +	 * comparing this one with last received beacon.
 +	 * IMPORTANT: These parameters would possibly be out of sync by the time
 +	 * the driver will use them. The synchronized view is currently
 +	 * guaranteed only in certain callbacks.
 +	 */
 +	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
 +	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
 +		sdata->vif.bss_conf.sync_tsf =
 +			le64_to_cpu(mgmt->u.beacon.timestamp);
 +		sdata->vif.bss_conf.sync_device_ts =
 +			rx_status->device_timestamp;
 +		sdata->vif.bss_conf.sync_dtim_count = elems->dtim_count;
 +	}
 +
 +	if ((ncrc == ifmgd->beacon_crc && ifmgd->beacon_crc_valid) ||
 +	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
 +		goto free;
 +	ifmgd->beacon_crc = ncrc;
 +	ifmgd->beacon_crc_valid = true;
 +
 +	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
 +
 +	ieee80211_sta_process_chanswitch(sdata, rx_status->mactime,
 +					 rx_status->device_timestamp,
 +					 elems, true);
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_WMM) &&
 +	    ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
 +				     elems->wmm_param_len,
 +				     elems->mu_edca_param_set))
 +		changed |= BSS_CHANGED_QOS;
 +
 +	/*
 +	 * If we haven't had a beacon before, tell the driver about the
 +	 * DTIM period (and beacon timing if desired) now.
 +	 */
 +	if (!ifmgd->have_beacon) {
 +		/* a few bogus AP send dtim_period = 0 or no TIM IE */
 +		bss_conf->dtim_period = elems->dtim_period ?: 1;
 +
 +		changed |= BSS_CHANGED_BEACON_INFO;
 +		ifmgd->have_beacon = true;
 +
 +		mutex_lock(&local->iflist_mtx);
 +		ieee80211_recalc_ps(local);
 +		mutex_unlock(&local->iflist_mtx);
 +
 +		ieee80211_recalc_ps_vif(sdata);
 +	}
 +
 +	if (elems->erp_info) {
 +		erp_valid = true;
 +		erp_value = elems->erp_info[0];
 +	} else {
 +		erp_valid = false;
 +	}
 +
 +	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
 +		changed |= ieee80211_handle_bss_capability(link,
 +				le16_to_cpu(mgmt->u.beacon.capab_info),
 +				erp_valid, erp_value);
 +
 +	mutex_lock(&local->sta_mtx);
 +	sta = sta_info_get(sdata, bssid);
 +
 +	changed |= ieee80211_recalc_twt_req(sdata, sta, elems);
 +
 +	if (ieee80211_config_bw(sdata, sta, elems->ht_cap_elem,
 +				elems->vht_cap_elem, elems->ht_operation,
 +				elems->vht_operation, elems->he_operation,
 +				elems->eht_operation,
 +				elems->s1g_oper, bssid, &changed)) {
 +		mutex_unlock(&local->sta_mtx);
 +		sdata_info(sdata,
 +			   "failed to follow AP %pM bandwidth change, disconnect\n",
 +			   bssid);
 +		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
 +				       WLAN_REASON_DEAUTH_LEAVING,
 +				       true, deauth_buf);
 +		ieee80211_report_disconnect(sdata, deauth_buf,
 +					    sizeof(deauth_buf), true,
 +					    WLAN_REASON_DEAUTH_LEAVING,
 +					    false);
 +		goto free;
 +	}
 +
 +	if (sta && elems->opmode_notif)
 +		ieee80211_vht_handle_opmode(sdata, sta, *elems->opmode_notif,
 +					    rx_status->band);
 +	mutex_unlock(&local->sta_mtx);
 +
 +	changed |= ieee80211_handle_pwr_constr(sdata, chan, mgmt,
 +					       elems->country_elem,
 +					       elems->country_elem_len,
 +					       elems->pwr_constr_elem,
 +					       elems->cisco_dtpc_elem);
 +
 +	ieee80211_bss_info_change_notify(sdata, changed);
 +free:
 +	kfree(elems);
 +}
 +
 +void ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,
 +				 struct sk_buff *skb)
 +{
 +	struct ieee80211_rx_status *rx_status;
 +	struct ieee80211_hdr *hdr;
 +	u16 fc;
 +
 +	rx_status = (struct ieee80211_rx_status *) skb->cb;
 +	hdr = (struct ieee80211_hdr *) skb->data;
 +	fc = le16_to_cpu(hdr->frame_control);
 +
 +	sdata_lock(sdata);
 +	switch (fc & IEEE80211_FCTL_STYPE) {
 +	case IEEE80211_STYPE_S1G_BEACON:
 +		ieee80211_rx_mgmt_beacon(sdata, hdr, skb->len, rx_status);
 +		break;
 +	}
 +	sdata_unlock(sdata);
 +}
 +
 +void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
 +				  struct sk_buff *skb)
 +{
 +	struct ieee80211_rx_status *rx_status;
 +	struct ieee80211_mgmt *mgmt;
 +	u16 fc;
 +	int ies_len;
 +
 +	rx_status = (struct ieee80211_rx_status *) skb->cb;
 +	mgmt = (struct ieee80211_mgmt *) skb->data;
 +	fc = le16_to_cpu(mgmt->frame_control);
 +
 +	sdata_lock(sdata);
 +
 +	switch (fc & IEEE80211_FCTL_STYPE) {
 +	case IEEE80211_STYPE_BEACON:
 +		ieee80211_rx_mgmt_beacon(sdata, (void *)mgmt,
 +					 skb->len, rx_status);
 +		break;
 +	case IEEE80211_STYPE_PROBE_RESP:
 +		ieee80211_rx_mgmt_probe_resp(sdata, skb);
 +		break;
 +	case IEEE80211_STYPE_AUTH:
 +		ieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);
 +		break;
 +	case IEEE80211_STYPE_DEAUTH:
 +		ieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);
 +		break;
 +	case IEEE80211_STYPE_DISASSOC:
 +		ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
 +		break;
 +	case IEEE80211_STYPE_ASSOC_RESP:
 +	case IEEE80211_STYPE_REASSOC_RESP:
 +		ieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);
 +		break;
 +	case IEEE80211_STYPE_ACTION:
 +		if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {
 +			struct ieee802_11_elems *elems;
 +
 +			ies_len = skb->len -
 +				  offsetof(struct ieee80211_mgmt,
 +					   u.action.u.chan_switch.variable);
 +
 +			if (ies_len < 0)
 +				break;
 +
 +			/* CSA IE cannot be overridden, no need for BSSID */
 +			elems = ieee802_11_parse_elems(
 +					mgmt->u.action.u.chan_switch.variable,
 +					ies_len, true, NULL);
 +
 +			if (elems && !elems->parse_error)
 +				ieee80211_sta_process_chanswitch(sdata,
 +								 rx_status->mactime,
 +								 rx_status->device_timestamp,
 +								 elems, false);
 +			kfree(elems);
 +		} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
 +			struct ieee802_11_elems *elems;
 +
 +			ies_len = skb->len -
 +				  offsetof(struct ieee80211_mgmt,
 +					   u.action.u.ext_chan_switch.variable);
 +
 +			if (ies_len < 0)
 +				break;
 +
 +			/*
 +			 * extended CSA IE can't be overridden, no need for
 +			 * BSSID
 +			 */
 +			elems = ieee802_11_parse_elems(
 +					mgmt->u.action.u.ext_chan_switch.variable,
 +					ies_len, true, NULL);
 +
 +			if (elems && !elems->parse_error) {
 +				/* for the handling code pretend it was an IE */
 +				elems->ext_chansw_ie =
 +					&mgmt->u.action.u.ext_chan_switch.data;
 +
 +				ieee80211_sta_process_chanswitch(sdata,
 +								 rx_status->mactime,
 +								 rx_status->device_timestamp,
 +								 elems, false);
 +			}
 +
 +			kfree(elems);
 +		}
 +		break;
 +	}
 +	sdata_unlock(sdata);
 +}
 +
 +static void ieee80211_sta_timer(struct timer_list *t)
 +{
 +	struct ieee80211_sub_if_data *sdata =
 +		from_timer(sdata, t, u.mgd.timer);
 +
 +	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
 +}
 +
 +void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
 +				   u8 reason, bool tx)
 +{
 +	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
 +
 +	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH, reason,
 +			       tx, frame_buf);
 +
 +	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
 +				    reason, false);
 +}
 +
 +static int ieee80211_auth(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_mgd_auth_data *auth_data = ifmgd->auth_data;
 +	u32 tx_flags = 0;
 +	u16 trans = 1;
 +	u16 status = 0;
 +	struct ieee80211_prep_tx_info info = {
 +		.subtype = IEEE80211_STYPE_AUTH,
 +	};
 +
 +	sdata_assert_lock(sdata);
 +
 +	if (WARN_ON_ONCE(!auth_data))
 +		return -EINVAL;
 +
 +	auth_data->tries++;
 +
 +	if (auth_data->tries > IEEE80211_AUTH_MAX_TRIES) {
 +		sdata_info(sdata, "authentication with %pM timed out\n",
 +			   auth_data->bss->bssid);
 +
 +		/*
 +		 * Most likely AP is not in the range so remove the
 +		 * bss struct for that AP.
 +		 */
 +		cfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);
 +
 +		return -ETIMEDOUT;
 +	}
 +
 +	if (auth_data->algorithm == WLAN_AUTH_SAE)
 +		info.duration = jiffies_to_msecs(IEEE80211_AUTH_TIMEOUT_SAE);
 +
 +	drv_mgd_prepare_tx(local, sdata, &info);
 +
 +	sdata_info(sdata, "send auth to %pM (try %d/%d)\n",
 +		   auth_data->bss->bssid, auth_data->tries,
 +		   IEEE80211_AUTH_MAX_TRIES);
 +
 +	auth_data->expected_transaction = 2;
 +
 +	if (auth_data->algorithm == WLAN_AUTH_SAE) {
 +		trans = auth_data->sae_trans;
 +		status = auth_data->sae_status;
 +		auth_data->expected_transaction = trans;
 +	}
 +
 +	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
 +		tx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
 +			   IEEE80211_TX_INTFL_MLME_CONN_TX;
 +
 +	ieee80211_send_auth(sdata, trans, auth_data->algorithm, status,
 +			    auth_data->data, auth_data->data_len,
 +			    auth_data->bss->bssid,
 +			    auth_data->bss->bssid, NULL, 0, 0,
 +			    tx_flags);
 +
 +	if (tx_flags == 0) {
 +		if (auth_data->algorithm == WLAN_AUTH_SAE)
 +			auth_data->timeout = jiffies +
 +				IEEE80211_AUTH_TIMEOUT_SAE;
 +		else
 +			auth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
 +	} else {
 +		auth_data->timeout =
 +			round_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);
 +	}
 +
 +	auth_data->timeout_started = true;
 +	run_again(sdata, auth_data->timeout);
 +
 +	return 0;
 +}
 +
 +static int ieee80211_do_assoc(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
 +	struct ieee80211_local *local = sdata->local;
 +	int ret;
 +
 +	sdata_assert_lock(sdata);
 +
 +	assoc_data->tries++;
 +	if (assoc_data->tries > IEEE80211_ASSOC_MAX_TRIES) {
 +		sdata_info(sdata, "association with %pM timed out\n",
 +			   assoc_data->bss->bssid);
 +
 +		/*
 +		 * Most likely AP is not in the range so remove the
 +		 * bss struct for that AP.
 +		 */
 +		cfg80211_unlink_bss(local->hw.wiphy, assoc_data->bss);
 +
 +		return -ETIMEDOUT;
 +	}
 +
 +	sdata_info(sdata, "associate with %pM (try %d/%d)\n",
 +		   assoc_data->bss->bssid, assoc_data->tries,
 +		   IEEE80211_ASSOC_MAX_TRIES);
 +	ret = ieee80211_send_assoc(sdata);
 +	if (ret)
 +		return ret;
 +
 +	if (!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
 +		assoc_data->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;
 +		assoc_data->timeout_started = true;
 +		run_again(sdata, assoc_data->timeout);
 +	} else {
 +		assoc_data->timeout =
 +			round_jiffies_up(jiffies +
 +					 IEEE80211_ASSOC_TIMEOUT_LONG);
 +		assoc_data->timeout_started = true;
 +		run_again(sdata, assoc_data->timeout);
 +	}
 +
 +	return 0;
 +}
 +
 +void ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,
 +				  __le16 fc, bool acked)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +
 +	sdata->u.mgd.status_fc = fc;
 +	sdata->u.mgd.status_acked = acked;
 +	sdata->u.mgd.status_received = true;
 +
 +	ieee80211_queue_work(&local->hw, &sdata->work);
 +}
 +
 +void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +
 +	sdata_lock(sdata);
 +
 +	if (ifmgd->status_received) {
 +		__le16 fc = ifmgd->status_fc;
 +		bool status_acked = ifmgd->status_acked;
 +
 +		ifmgd->status_received = false;
 +		if (ifmgd->auth_data && ieee80211_is_auth(fc)) {
 +			if (status_acked) {
 +				if (ifmgd->auth_data->algorithm ==
 +				    WLAN_AUTH_SAE)
 +					ifmgd->auth_data->timeout =
 +						jiffies +
 +						IEEE80211_AUTH_TIMEOUT_SAE;
 +				else
 +					ifmgd->auth_data->timeout =
 +						jiffies +
 +						IEEE80211_AUTH_TIMEOUT_SHORT;
 +				run_again(sdata, ifmgd->auth_data->timeout);
 +			} else {
 +				ifmgd->auth_data->timeout = jiffies - 1;
 +			}
 +			ifmgd->auth_data->timeout_started = true;
 +		} else if (ifmgd->assoc_data &&
 +			   (ieee80211_is_assoc_req(fc) ||
 +			    ieee80211_is_reassoc_req(fc))) {
 +			if (status_acked) {
 +				ifmgd->assoc_data->timeout =
 +					jiffies + IEEE80211_ASSOC_TIMEOUT_SHORT;
 +				run_again(sdata, ifmgd->assoc_data->timeout);
 +			} else {
 +				ifmgd->assoc_data->timeout = jiffies - 1;
 +			}
 +			ifmgd->assoc_data->timeout_started = true;
 +		}
 +	}
 +
 +	if (ifmgd->auth_data && ifmgd->auth_data->timeout_started &&
 +	    time_after(jiffies, ifmgd->auth_data->timeout)) {
 +		if (ifmgd->auth_data->done || ifmgd->auth_data->waiting) {
 +			/*
 +			 * ok ... we waited for assoc or continuation but
 +			 * userspace didn't do it, so kill the auth data
 +			 */
 +			ieee80211_destroy_auth_data(sdata, false);
 +		} else if (ieee80211_auth(sdata)) {
 +			u8 bssid[ETH_ALEN];
 +			struct ieee80211_event event = {
 +				.type = MLME_EVENT,
 +				.u.mlme.data = AUTH_EVENT,
 +				.u.mlme.status = MLME_TIMEOUT,
 +			};
 +
 +			memcpy(bssid, ifmgd->auth_data->bss->bssid, ETH_ALEN);
 +
 +			ieee80211_destroy_auth_data(sdata, false);
 +
 +			cfg80211_auth_timeout(sdata->dev, bssid);
 +			drv_event_callback(sdata->local, sdata, &event);
 +		}
 +	} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)
 +		run_again(sdata, ifmgd->auth_data->timeout);
 +
 +	if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started &&
 +	    time_after(jiffies, ifmgd->assoc_data->timeout)) {
 +		if ((ifmgd->assoc_data->need_beacon && !ifmgd->have_beacon) ||
 +		    ieee80211_do_assoc(sdata)) {
 +			struct ieee80211_event event = {
 +				.type = MLME_EVENT,
 +				.u.mlme.data = ASSOC_EVENT,
 +				.u.mlme.status = MLME_TIMEOUT,
 +			};
 +
 +			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
 +			drv_event_callback(sdata->local, sdata, &event);
 +		}
 +	} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)
 +		run_again(sdata, ifmgd->assoc_data->timeout);
 +
 +	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL &&
 +	    ifmgd->associated) {
 +		u8 *bssid = ifmgd->bssid;
 +		int max_tries;
 +
 +		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
 +			max_tries = max_nullfunc_tries;
 +		else
 +			max_tries = max_probe_tries;
 +
 +		/* ACK received for nullfunc probing frame */
 +		if (!ifmgd->probe_send_count)
 +			ieee80211_reset_ap_probe(sdata);
 +		else if (ifmgd->nullfunc_failed) {
 +			if (ifmgd->probe_send_count < max_tries) {
 +				mlme_dbg(sdata,
 +					 "No ack for nullfunc frame to AP %pM, try %d/%i\n",
 +					 bssid, ifmgd->probe_send_count,
 +					 max_tries);
 +				ieee80211_mgd_probe_ap_send(sdata);
 +			} else {
 +				mlme_dbg(sdata,
 +					 "No ack for nullfunc frame to AP %pM, disconnecting.\n",
 +					 bssid);
 +				ieee80211_sta_connection_lost(sdata,
 +					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
 +					false);
 +			}
 +		} else if (time_is_after_jiffies(ifmgd->probe_timeout))
 +			run_again(sdata, ifmgd->probe_timeout);
 +		else if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
 +			mlme_dbg(sdata,
 +				 "Failed to send nullfunc to AP %pM after %dms, disconnecting\n",
 +				 bssid, probe_wait_ms);
 +			ieee80211_sta_connection_lost(sdata,
 +				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
 +		} else if (ifmgd->probe_send_count < max_tries) {
 +			mlme_dbg(sdata,
 +				 "No probe response from AP %pM after %dms, try %d/%i\n",
 +				 bssid, probe_wait_ms,
 +				 ifmgd->probe_send_count, max_tries);
 +			ieee80211_mgd_probe_ap_send(sdata);
 +		} else {
 +			/*
 +			 * We actually lost the connection ... or did we?
 +			 * Let's make sure!
 +			 */
 +			mlme_dbg(sdata,
 +				 "No probe response from AP %pM after %dms, disconnecting.\n",
 +				 bssid, probe_wait_ms);
 +
 +			ieee80211_sta_connection_lost(sdata,
 +				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
 +		}
 +	}
 +
 +	sdata_unlock(sdata);
 +}
 +
 +static void ieee80211_sta_bcn_mon_timer(struct timer_list *t)
 +{
 +	struct ieee80211_sub_if_data *sdata =
 +		from_timer(sdata, t, u.mgd.bcn_mon_timer);
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +
 +	if (sdata->vif.bss_conf.csa_active && !ifmgd->csa_waiting_bcn)
 +		return;
 +
 +	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
 +		return;
 +
 +	sdata->u.mgd.connection_loss = false;
 +	ieee80211_queue_work(&sdata->local->hw,
 +			     &sdata->u.mgd.beacon_connection_loss_work);
 +}
 +
 +static void ieee80211_sta_conn_mon_timer(struct timer_list *t)
 +{
 +	struct ieee80211_sub_if_data *sdata =
 +		from_timer(sdata, t, u.mgd.conn_mon_timer);
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_local *local = sdata->local;
 +	struct sta_info *sta;
 +	unsigned long timeout;
 +
 +	if (sdata->vif.bss_conf.csa_active && !ifmgd->csa_waiting_bcn)
 +		return;
 +
 +	sta = sta_info_get(sdata, ifmgd->bssid);
 +	if (!sta)
 +		return;
 +
 +	timeout = sta->status_stats.last_ack;
 +	if (time_before(sta->status_stats.last_ack, sta->rx_stats.last_rx))
 +		timeout = sta->rx_stats.last_rx;
 +	timeout += IEEE80211_CONNECTION_IDLE_TIME;
 +
 +	/* If timeout is after now, then update timer to fire at
 +	 * the later date, but do not actually probe at this time.
 +	 */
 +	if (time_is_after_jiffies(timeout)) {
 +		mod_timer(&ifmgd->conn_mon_timer, round_jiffies_up(timeout));
 +		return;
 +	}
 +
 +	ieee80211_queue_work(&local->hw, &ifmgd->monitor_work);
 +}
 +
 +static void ieee80211_sta_monitor_work(struct work_struct *work)
 +{
 +	struct ieee80211_sub_if_data *sdata =
 +		container_of(work, struct ieee80211_sub_if_data,
 +			     u.mgd.monitor_work);
 +
 +	ieee80211_mgd_probe_ap(sdata, false);
 +}
 +
 +static void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata)
 +{
 +	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
 +		__ieee80211_stop_poll(sdata);
 +
 +		/* let's probe the connection once */
 +		if (!ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
 +			ieee80211_queue_work(&sdata->local->hw,
 +					     &sdata->u.mgd.monitor_work);
 +	}
 +}
 +
 +#ifdef CONFIG_PM
 +void ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
 +
 +	sdata_lock(sdata);
 +
 +	if (ifmgd->auth_data || ifmgd->assoc_data) {
 +		const u8 *bssid = ifmgd->auth_data ?
 +				ifmgd->auth_data->bss->bssid :
 +				ifmgd->assoc_data->bss->bssid;
 +
 +		/*
 +		 * If we are trying to authenticate / associate while suspending,
 +		 * cfg80211 won't know and won't actually abort those attempts,
 +		 * thus we need to do that ourselves.
 +		 */
 +		ieee80211_send_deauth_disassoc(sdata, bssid, bssid,
 +					       IEEE80211_STYPE_DEAUTH,
 +					       WLAN_REASON_DEAUTH_LEAVING,
 +					       false, frame_buf);
 +		if (ifmgd->assoc_data)
 +			ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
 +		if (ifmgd->auth_data)
 +			ieee80211_destroy_auth_data(sdata, false);
 +		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
 +				      IEEE80211_DEAUTH_FRAME_LEN,
 +				      false);
 +	}
 +
 +	/* This is a bit of a hack - we should find a better and more generic
 +	 * solution to this. Normally when suspending, cfg80211 will in fact
 +	 * deauthenticate. However, it doesn't (and cannot) stop an ongoing
 +	 * auth (not so important) or assoc (this is the problem) process.
 +	 *
 +	 * As a consequence, it can happen that we are in the process of both
 +	 * associating and suspending, and receive an association response
 +	 * after cfg80211 has checked if it needs to disconnect, but before
 +	 * we actually set the flag to drop incoming frames. This will then
 +	 * cause the workqueue flush to process the association response in
 +	 * the suspend, resulting in a successful association just before it
 +	 * tries to remove the interface from the driver, which now though
 +	 * has a channel context assigned ... this results in issues.
 +	 *
 +	 * To work around this (for now) simply deauth here again if we're
 +	 * now connected.
 +	 */
 +	if (ifmgd->associated && !sdata->local->wowlan) {
 +		u8 bssid[ETH_ALEN];
 +		struct cfg80211_deauth_request req = {
 +			.reason_code = WLAN_REASON_DEAUTH_LEAVING,
 +			.bssid = bssid,
 +		};
 +
 +		memcpy(bssid, ifmgd->bssid, ETH_ALEN);
 +		ieee80211_mgd_deauth(sdata, &req);
 +	}
 +
 +	sdata_unlock(sdata);
 +}
 +#endif
 +
 +void ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +
 +	sdata_lock(sdata);
 +	if (!ifmgd->associated) {
 +		sdata_unlock(sdata);
 +		return;
 +	}
 +
 +	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {
 +		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;
 +		mlme_dbg(sdata, "driver requested disconnect after resume\n");
 +		ieee80211_sta_connection_lost(sdata,
 +					      WLAN_REASON_UNSPECIFIED,
 +					      true);
 +		sdata_unlock(sdata);
 +		return;
 +	}
 +
 +	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_HW_RESTART) {
 +		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_HW_RESTART;
 +		mlme_dbg(sdata, "driver requested disconnect after hardware restart\n");
 +		ieee80211_sta_connection_lost(sdata,
 +					      WLAN_REASON_UNSPECIFIED,
 +					      true);
 +		sdata_unlock(sdata);
 +		return;
 +	}
 +
 +	sdata_unlock(sdata);
 +}
 +
 +/* interface setup */
 +void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
 +{
 +	struct ieee80211_if_managed *ifmgd;
 +
 +	ifmgd = &sdata->u.mgd;
 +	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
 +	INIT_WORK(&ifmgd->chswitch_work, ieee80211_chswitch_work);
 +	INIT_WORK(&ifmgd->beacon_connection_loss_work,
 +		  ieee80211_beacon_connection_loss_work);
 +	INIT_WORK(&ifmgd->csa_connection_drop_work,
 +		  ieee80211_csa_connection_drop_work);
 +	INIT_WORK(&ifmgd->request_smps_work, ieee80211_request_smps_mgd_work);
 +	INIT_DELAYED_WORK(&ifmgd->tdls_peer_del_work,
 +			  ieee80211_tdls_peer_del_work);
 +	timer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);
 +	timer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);
 +	timer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);
 +	timer_setup(&ifmgd->chswitch_timer, ieee80211_chswitch_timer, 0);
 +	INIT_DELAYED_WORK(&ifmgd->tx_tspec_wk,
 +			  ieee80211_sta_handle_tspec_ac_params_wk);
 +
 +	ifmgd->flags = 0;
 +	ifmgd->powersave = sdata->wdev.ps;
 +	ifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;
 +	ifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;
 +	ifmgd->p2p_noa_index = -1;
 +
 +	if (sdata->local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
 +		ifmgd->req_smps = IEEE80211_SMPS_AUTOMATIC;
 +	else
 +		ifmgd->req_smps = IEEE80211_SMPS_OFF;
 +
 +	/* Setup TDLS data */
 +	spin_lock_init(&ifmgd->teardown_lock);
 +	ifmgd->teardown_skb = NULL;
 +	ifmgd->orig_teardown_skb = NULL;
 +}
 +
 +/* scan finished notification */
 +void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
 +{
 +	struct ieee80211_sub_if_data *sdata;
 +
 +	/* Restart STA timers */
 +	rcu_read_lock();
 +	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 +		if (ieee80211_sdata_running(sdata))
 +			ieee80211_restart_sta_timer(sdata);
 +	}
 +	rcu_read_unlock();
 +}
 +
 +static u8 ieee80211_max_rx_chains(struct ieee80211_sub_if_data *sdata,
 +				  struct cfg80211_bss *cbss)
 +{
 +	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	const struct element *ht_cap_elem, *vht_cap_elem;
 +	const struct cfg80211_bss_ies *ies;
 +	const struct ieee80211_ht_cap *ht_cap;
 +	const struct ieee80211_vht_cap *vht_cap;
 +	const struct ieee80211_he_cap_elem *he_cap;
 +	const struct element *he_cap_elem;
 +	u16 mcs_80_map, mcs_160_map;
 +	int i, mcs_nss_size;
 +	bool support_160;
 +	u8 chains = 1;
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT)
 +		return chains;
 +
 +	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
 +	if (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {
 +		ht_cap = (void *)ht_cap_elem->data;
 +		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
 +		/*
 +		 * TODO: use "Tx Maximum Number Spatial Streams Supported" and
 +		 *	 "Tx Unequal Modulation Supported" fields.
 +		 */
 +	}
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_VHT)
 +		return chains;
 +
 +	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
 +	if (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {
 +		u8 nss;
 +		u16 tx_mcs_map;
 +
 +		vht_cap = (void *)vht_cap_elem->data;
 +		tx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
 +		for (nss = 8; nss > 0; nss--) {
 +			if (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=
 +					IEEE80211_VHT_MCS_NOT_SUPPORTED)
 +				break;
 +		}
 +		/* TODO: use "Tx Highest Supported Long GI Data Rate" field? */
 +		chains = max(chains, nss);
 +	}
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HE)
 +		return chains;
 +
 +	ies = rcu_dereference(cbss->ies);
 +	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
 +					     ies->data, ies->len);
 +
 +	if (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))
 +		return chains;
 +
 +	/* skip one byte ext_tag_id */
 +	he_cap = (void *)(he_cap_elem->data + 1);
  	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
  
  	/* invalid HE IE */
@@@ -5541,153 -4789,1668 +5560,1681 @@@ static int ieee80211_prep_channel(struc
  	return ret;
  }
  
- static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
- 			       u8 *dtim_count, u8 *dtim_period)
++<<<<<<< HEAD
++=======
+ static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_mgmt *mgmt,
+ 				    struct ieee802_11_elems *elems,
+ 				    const u8 *elem_start, unsigned int elem_len)
  {
- 	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
- 	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
- 					 ies->len);
- 	const struct ieee80211_tim_ie *tim = NULL;
- 	const struct ieee80211_bssid_index *idx;
- 	bool valid = tim_ie && tim_ie[1] >= 2;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id;
+ 	struct sta_info *sta;
+ 	u64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};
+ 	int err;
  
- 	if (valid)
- 		tim = (void *)(tim_ie + 2);
+ 	mutex_lock(&sdata->local->sta_mtx);
+ 	/*
+ 	 * station info was already allocated and inserted before
+ 	 * the association and should be available to us
+ 	 */
+ 	sta = sta_info_get(sdata, assoc_data->ap_addr);
+ 	if (WARN_ON(!sta))
+ 		goto out_err;
  
- 	if (dtim_count)
- 		*dtim_count = valid ? tim->dtim_count : 0;
+ 	if (sdata->vif.valid_links) {
+ 		u16 valid_links = 0;
  
- 	if (dtim_period)
- 		*dtim_period = valid ? tim->dtim_period : 0;
+ 		for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 			if (!assoc_data->link[link_id].bss)
+ 				continue;
+ 			valid_links |= BIT(link_id);
  
- 	/* Check if value is overridden by non-transmitted profile */
- 	if (!idx_ie || idx_ie[1] < 3)
- 		return valid;
+ 			if (link_id != assoc_data->assoc_link_id) {
+ 				err = ieee80211_sta_allocate_link(sta, link_id);
+ 				if (err)
+ 					goto out_err;
+ 			}
+ 		}
  
- 	idx = (void *)(idx_ie + 2);
+ 		ieee80211_vif_set_links(sdata, valid_links);
+ 	}
  
- 	if (dtim_count)
- 		*dtim_count = idx->dtim_count;
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 		struct link_sta_info *link_sta;
  
- 	if (dtim_period)
- 		*dtim_period = idx->dtim_period;
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (WARN_ON(!link))
+ 			goto out_err;
+ 
+ 		if (sdata->vif.valid_links)
+ 			link_info(link,
+ 				  "local address %pM, AP link address %pM\n",
+ 				  link->conf->addr,
+ 				  assoc_data->link[link_id].bss->bssid);
+ 
+ 		link_sta = rcu_dereference_protected(sta->link[link_id],
+ 						     lockdep_is_held(&local->sta_mtx));
+ 		if (WARN_ON(!link_sta))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_prep_channel(sdata, link,
+ 						     assoc_data->link[link_id].bss,
+ 						     &link->u.mgd.conn_flags);
+ 			if (err)
+ 				goto out_err;
+ 		}
+ 
+ 		err = ieee80211_mgd_setup_link_sta(link, sta, link_sta,
+ 						   assoc_data->link[link_id].bss);
+ 		if (err)
+ 			goto out_err;
+ 
+ 		if (!ieee80211_assoc_config_link(link, link_sta,
+ 						 assoc_data->link[link_id].bss,
+ 						 mgmt, elem_start, elem_len,
+ 						 &changed[link_id]))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_sta_activate_link(sta, link_id);
+ 			if (err)
+ 				goto out_err;
+ 		}
+ 	}
+ 
+ 	rate_control_rate_init(sta);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
+ 		set_sta_flag(sta, WLAN_STA_MFP);
+ 		sta->sta.mfp = true;
+ 	} else {
+ 		sta->sta.mfp = false;
+ 	}
+ 
+ 	ieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,
+ 					      elems->ext_capab_len);
+ 
+ 	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
+ 		       local->hw.queues >= IEEE80211_NUM_ACS;
+ 
+ 	/* needed for fast-xmit setup in sta_info_move_state() */
+ 	memcpy(sdata->vif.cfg.ap_addr, assoc_data->ap_addr, ETH_ALEN);
+ 
+ 	err = sta_info_move_state(sta, IEEE80211_STA_ASSOC);
+ 	if (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
+ 		err = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);
+ 	if (err) {
+ 		sdata_info(sdata,
+ 			   "failed to move station %pM to desired state\n",
+ 			   sta->sta.addr);
+ 		WARN_ON(__sta_info_destroy(sta));
+ 		goto out_err;
+ 	}
+ 
+ 	if (sdata->wdev.use_4addr)
+ 		drv_sta_set_4addr(local, sdata, &sta->sta, true);
+ 
+ 	mutex_unlock(&sdata->local->sta_mtx);
+ 
+ 	ieee80211_set_associated(sdata, assoc_data, changed);
+ 
+ 	/*
+ 	 * If we're using 4-addr mode, let the AP know that we're
+ 	 * doing so, so that it can create the STA VLAN on its side
+ 	 */
+ 	if (ifmgd->use_4addr)
+ 		ieee80211_send_4addr_nullfunc(local, sdata);
+ 
+ 	/*
+ 	 * Start timer to probe the connection to the AP now.
+ 	 * Also start the timer that will detect beacon loss.
+ 	 */
+ 	ieee80211_sta_reset_beacon_monitor(sdata);
+ 	ieee80211_sta_reset_conn_monitor(sdata);
  
  	return true;
+ out_err:
+ 	eth_zero_addr(sdata->vif.cfg.ap_addr);
+ 	mutex_unlock(&sdata->local->sta_mtx);
+ 	return false;
  }
  
- static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
- 				     struct cfg80211_bss *cbss, bool assoc,
- 				     bool override)
+ static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
+ 					 struct ieee80211_mgmt *mgmt,
+ 					 size_t len)
  {
- 	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
- 	struct ieee80211_bss *bss = (void *)cbss->priv;
- 	struct sta_info *new_sta = NULL;
- 	struct ieee80211_supported_band *sband;
- 	bool have_sta = false;
- 	int err;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	u16 capab_info, status_code, aid;
+ 	struct ieee802_11_elems *elems;
+ 	int ac;
+ 	const u8 *elem_start;
+ 	unsigned int elem_len;
+ 	bool reassoc;
+ 	struct ieee80211_event event = {
+ 		.type = MLME_EVENT,
+ 		.u.mlme.data = ASSOC_EVENT,
+ 	};
+ 	struct ieee80211_prep_tx_info info = {};
+ 	struct cfg80211_rx_assoc_resp resp = {
+ 		.uapsd_queues = -1,
+ 	};
+ 	unsigned int link_id;
  
- 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 	sdata_assert_lock(sdata);
  
- 	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data))
- 		return -EINVAL;
+ 	if (!assoc_data)
+ 		return;
  
- 	/* If a reconfig is happening, bail out */
- 	if (local->in_reconfig)
- 		return -EBUSY;
+ 	if (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) ||
+ 	    !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))
+ 		return;
  
- 	if (assoc) {
- 		rcu_read_lock();
- 		have_sta = sta_info_get(sdata, cbss->bssid);
- 		rcu_read_unlock();
- 	}
+ 	/*
+ 	 * AssocResp and ReassocResp have identical structure, so process both
+ 	 * of them in this function.
+ 	 */
  
- 	if (!have_sta) {
- 		new_sta = sta_info_alloc(sdata, cbss->bssid, GFP_KERNEL);
- 		if (!new_sta)
- 			return -ENOMEM;
- 	}
+ 	if (len < 24 + 6)
+ 		return;
+ 
+ 	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
+ 	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
+ 	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
+ 	if (assoc_data->s1g)
+ 		elem_start = mgmt->u.s1g_assoc_resp.variable;
+ 	else
+ 		elem_start = mgmt->u.assoc_resp.variable;
  
  	/*
- 	 * Set up the information for the new channel before setting the
- 	 * new channel. We can't - completely race-free - change the basic
- 	 * rates bitmap and the channel (sband) that it refers to, but if
- 	 * we set it up before we at least avoid calling into the driver's
- 	 * bss_info_changed() method with invalid information (since we do
- 	 * call that from changing the channel - only for IDLE and perhaps
- 	 * some others, but ...).
- 	 *
- 	 * So to avoid that, just set up all the new information before the
- 	 * channel, but tell the driver to apply it only afterwards, since
- 	 * it might need the new channel for that.
+ 	 * Note: this may not be perfect, AP might misbehave - if
+ 	 * anyone needs to rely on perfect complete notification
+ 	 * with the exact right subtype, then we need to track what
+ 	 * we actually transmitted.
  	 */
- 	if (new_sta) {
- 		u32 rates = 0, basic_rates = 0;
- 		bool have_higher_than_11mbit = false;
- 		int min_rate = INT_MAX, min_rate_index = -1;
- 		const struct cfg80211_bss_ies *ies;
- 		int shift = ieee80211_vif_get_shift(&sdata->vif);
+ 	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
+ 				 IEEE80211_STYPE_ASSOC_REQ;
  
- 		/* TODO: S1G Basic Rate Set is expressed elsewhere */
- 		if (cbss->channel->band == NL80211_BAND_S1GHZ) {
- 			ieee80211_s1g_sta_rate_init(new_sta);
- 			goto skip_rates;
+ 	if (assoc_data->fils_kek_len &&
+ 	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
+ 		return;
+ 
+ 	elem_len = len - (elem_start - (u8 *)mgmt);
+ 	elems = ieee802_11_parse_elems(elem_start, elem_len, false, NULL);
+ 	if (!elems)
+ 		goto notify_driver;
+ 
+ 	if (elems->aid_resp)
+ 		aid = le16_to_cpu(elems->aid_resp->aid);
+ 	else if (assoc_data->s1g)
+ 		aid = 0; /* TODO */
+ 	else
+ 		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+ 
+ 	/*
+ 	 * The 5 MSB of the AID field are reserved
+ 	 * (802.11-2016 9.4.1.8 AID field)
+ 	 */
+ 	aid &= 0x7ff;
+ 
+ 	sdata_info(sdata,
+ 		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
+ 		   reassoc ? "Rea" : "A", assoc_data->ap_addr,
+ 		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
+ 
+ 	ifmgd->broken_ap = false;
+ 
+ 	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
+ 	    elems->timeout_int &&
+ 	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
+ 		u32 tu, ms;
+ 
+ 		cfg80211_assoc_comeback(sdata->dev, assoc_data->ap_addr,
+ 					le32_to_cpu(elems->timeout_int->value));
+ 
+ 		tu = le32_to_cpu(elems->timeout_int->value);
+ 		ms = tu * 1024 / 1000;
+ 		sdata_info(sdata,
+ 			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
+ 			   assoc_data->ap_addr, tu, ms);
+ 		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
+ 		assoc_data->timeout_started = true;
+ 		if (ms > IEEE80211_ASSOC_TIMEOUT)
+ 			run_again(sdata, assoc_data->timeout);
+ 		goto notify_driver;
+ 	}
+ 
+ 	if (status_code != WLAN_STATUS_SUCCESS) {
+ 		sdata_info(sdata, "%pM denied association (code=%d)\n",
+ 			   assoc_data->ap_addr, status_code);
+ 		event.u.mlme.status = MLME_DENIED;
+ 		event.u.mlme.reason = status_code;
+ 		drv_event_callback(sdata->local, sdata, &event);
+ 	} else {
+ 		if (aid == 0 || aid > IEEE80211_MAX_AID) {
+ 			sdata_info(sdata,
+ 				   "invalid AID value %d (out of range), turn off PS\n",
+ 				   aid);
+ 			aid = 0;
+ 			ifmgd->broken_ap = true;
+ 		}
+ 
+ 		if (sdata->vif.valid_links) {
+ 			if (!elems->multi_link) {
+ 				sdata_info(sdata,
+ 					   "MLO association with %pM but no multi-link element in response!\n",
+ 					   assoc_data->ap_addr);
+ 				goto abandon_assoc;
+ 			}
+ 
+ 			if (le16_get_bits(elems->multi_link->control,
+ 					  IEEE80211_ML_CONTROL_TYPE) !=
+ 					IEEE80211_ML_CONTROL_TYPE_BASIC) {
+ 				sdata_info(sdata,
+ 					   "bad multi-link element (control=0x%x)\n",
+ 					   le16_to_cpu(elems->multi_link->control));
+ 				goto abandon_assoc;
+ 			} else {
+ 				struct ieee80211_mle_basic_common_info *common;
+ 
+ 				common = (void *)elems->multi_link->variable;
+ 
+ 				if (memcmp(assoc_data->ap_addr,
+ 					   common->mld_mac_addr, ETH_ALEN)) {
+ 					sdata_info(sdata,
+ 						   "AP MLD MAC address mismatch: got %pM expected %pM\n",
+ 						   common->mld_mac_addr,
+ 						   assoc_data->ap_addr);
+ 					goto abandon_assoc;
+ 				}
+ 			}
+ 		}
+ 
+ 		sdata->vif.cfg.aid = aid;
+ 
+ 		if (!ieee80211_assoc_success(sdata, mgmt, elems,
+ 					     elem_start, elem_len)) {
+ 			/* oops -- internal error -- send timeout for now */
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
+ 			goto notify_driver;
+ 		}
+ 		event.u.mlme.status = MLME_SUCCESS;
+ 		drv_event_callback(sdata->local, sdata, &event);
+ 		sdata_info(sdata, "associated\n");
+ 
+ 		info.success = 1;
+ 	}
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (!link)
+ 			continue;
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 		resp.links[link_id].bss = assoc_data->link[link_id].bss;
+ 		resp.links[link_id].addr = link->conf->addr;
+ 
+ 		/* get uapsd queues configuration - same for all links */
+ 		resp.uapsd_queues = 0;
+ 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+ 			if (link->tx_conf[ac].uapsd)
+ 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+ 	}
+ 
+ 	ieee80211_destroy_assoc_data(sdata,
+ 				     status_code == WLAN_STATUS_SUCCESS ?
+ 					ASSOC_SUCCESS :
+ 					ASSOC_REJECTED);
+ 
+ 	resp.buf = (u8 *)mgmt;
+ 	resp.len = len;
+ 	resp.req_ies = ifmgd->assoc_req_ies;
+ 	resp.req_ies_len = ifmgd->assoc_req_ies_len;
+ 	if (sdata->vif.valid_links)
+ 		resp.ap_mld_addr = assoc_data->ap_addr;
+ 	cfg80211_rx_assoc_resp(sdata->dev, &resp);
+ notify_driver:
+ 	drv_mgd_complete_tx(sdata->local, sdata, &info);
+ 	kfree(elems);
+ 	return;
+ abandon_assoc:
+ 	ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 	goto notify_driver;
+ }
+ 
+ static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
+ 				  struct ieee80211_mgmt *mgmt, size_t len,
+ 				  struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_bss *bss;
+ 	struct ieee80211_channel *channel;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	channel = ieee80211_get_channel_khz(local->hw.wiphy,
+ 					ieee80211_rx_status_to_khz(rx_status));
+ 	if (!channel)
+ 		return;
+ 
+ 	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
+ 	if (bss) {
+ 		link->conf->beacon_rate = bss->beacon_rate;
+ 		ieee80211_rx_bss_put(local, bss);
+ 	}
+ }
+ 
+ 
+ static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_link_data *link,
+ 					 struct sk_buff *skb)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+ 	struct ieee80211_if_managed *ifmgd;
+ 	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
+ 	struct ieee80211_channel *channel;
+ 	size_t baselen, len = skb->len;
+ 
+ 	ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	/*
+ 	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
+ 	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
+ 	 * a Probe Response frame [..], the Address 1 field of the Probe
+ 	 * Response frame shall be set to the broadcast address [..]"
+ 	 * So, on 6GHz band we should also accept broadcast responses.
+ 	 */
+ 	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
+ 					rx_status->freq);
+ 	if (!channel)
+ 		return;
+ 
+ 	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
+ 	    (channel->band != NL80211_BAND_6GHZ ||
+ 	     !is_broadcast_ether_addr(mgmt->da)))
+ 		return; /* ignore ProbeResp to foreign address */
+ 
+ 	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+ 	if (baselen > len)
+ 		return;
+ 
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 	if (ifmgd->associated &&
+ 	    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))
+ 		ieee80211_reset_ap_probe(sdata);
+ }
+ 
+ /*
+  * This is the canonical list of information elements we care about,
+  * the filter code also gives us all changes to the Microsoft OUI
+  * (00:50:F2) vendor IE which is used for WMM which we need to track,
+  * as well as the DTPC IE (part of the Cisco OUI) used for signaling
+  * changes to requested client power.
+  *
+  * We implement beacon filtering in software since that means we can
+  * avoid processing the frame here and in cfg80211, and userspace
+  * will not be able to tell whether the hardware supports it or not.
+  *
+  * XXX: This list needs to be dynamic -- userspace needs to be able to
+  *	add items it requires. It also needs to be able to tell us to
+  *	look out for other vendor IEs.
+  */
+ static const u64 care_about_ies =
+ 	(1ULL << WLAN_EID_COUNTRY) |
+ 	(1ULL << WLAN_EID_ERP_INFO) |
+ 	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
+ 	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
+ 	(1ULL << WLAN_EID_HT_CAPABILITY) |
+ 	(1ULL << WLAN_EID_HT_OPERATION) |
+ 	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
+ 
+ static void ieee80211_handle_beacon_sig(struct ieee80211_link_data *link,
+ 					struct ieee80211_if_managed *ifmgd,
+ 					struct ieee80211_bss_conf *bss_conf,
+ 					struct ieee80211_local *local,
+ 					struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 
+ 	/* Track average RSSI from the Beacon frames of the current AP */
+ 
+ 	if (!link->u.mgd.tracking_signal_avg) {
+ 		link->u.mgd.tracking_signal_avg = true;
+ 		ewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);
+ 		link->u.mgd.last_cqm_event_signal = 0;
+ 		link->u.mgd.count_beacon_signal = 1;
+ 		link->u.mgd.last_ave_beacon_signal = 0;
+ 	} else {
+ 		link->u.mgd.count_beacon_signal++;
+ 	}
+ 
+ 	ewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,
+ 			       -rx_status->signal);
+ 
+ 	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_sig = link->u.mgd.last_ave_beacon_signal;
+ 		struct ieee80211_event event = {
+ 			.type = RSSI_EVENT,
+ 		};
+ 
+ 		/*
+ 		 * if signal crosses either of the boundaries, invoke callback
+ 		 * with appropriate parameters
+ 		 */
+ 		if (sig > ifmgd->rssi_max_thold &&
+ 		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
+ 			link->u.mgd.last_ave_beacon_signal = sig;
+ 			event.u.rssi.data = RSSI_EVENT_HIGH;
+ 			drv_event_callback(local, sdata, &event);
+ 		} else if (sig < ifmgd->rssi_min_thold &&
+ 			   (last_sig >= ifmgd->rssi_max_thold ||
+ 			   last_sig == 0)) {
+ 			link->u.mgd.last_ave_beacon_signal = sig;
+ 			event.u.rssi.data = RSSI_EVENT_LOW;
+ 			drv_event_callback(local, sdata, &event);
+ 		}
+ 	}
+ 
+ 	if (bss_conf->cqm_rssi_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
+ 	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
+ 		int thold = bss_conf->cqm_rssi_thold;
+ 		int hyst = bss_conf->cqm_rssi_hyst;
+ 
+ 		if (sig < thold &&
+ 		    (last_event == 0 || sig < last_event - hyst)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+ 				sig, GFP_KERNEL);
+ 		} else if (sig > thold &&
+ 			   (last_event == 0 || sig > last_event + hyst)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+ 				sig, GFP_KERNEL);
+ 		}
+ 	}
+ 
+ 	if (bss_conf->cqm_rssi_low &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
+ 		int low = bss_conf->cqm_rssi_low;
+ 		int high = bss_conf->cqm_rssi_high;
+ 
+ 		if (sig < low &&
+ 		    (last_event == 0 || last_event >= low)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+ 				sig, GFP_KERNEL);
+ 		} else if (sig > high &&
+ 			   (last_event == 0 || last_event <= high)) {
+ 			link->u.mgd.last_cqm_event_signal = sig;
+ 			ieee80211_cqm_rssi_notify(
+ 				&sdata->vif,
+ 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+ 				sig, GFP_KERNEL);
+ 		}
+ 	}
+ }
+ 
+ static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
+ 				    struct cfg80211_bss *bss)
+ {
+ 	if (ether_addr_equal(tx_bssid, bss->bssid))
+ 		return true;
+ 	if (!bss->transmitted_bss)
+ 		return false;
+ 	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
+ }
+ 
+ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,
+ 				     struct ieee80211_hdr *hdr, size_t len,
+ 				     struct ieee80211_rx_status *rx_status)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 	struct ieee80211_mgmt *mgmt = (void *) hdr;
+ 	size_t baselen;
+ 	struct ieee802_11_elems *elems;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	struct ieee80211_channel *chan;
+ 	struct link_sta_info *link_sta;
+ 	struct sta_info *sta;
+ 	u32 changed = 0;
+ 	bool erp_valid;
+ 	u8 erp_value = 0;
+ 	u32 ncrc = 0;
+ 	u8 *bssid, *variable = mgmt->u.beacon.variable;
+ 	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	/* Process beacon from the current BSS */
+ 	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
+ 	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
+ 		struct ieee80211_ext *ext = (void *) mgmt;
+ 
+ 		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
+ 			variable = ext->u.s1g_short_beacon.variable;
+ 		else
+ 			variable = ext->u.s1g_beacon.variable;
+ 	}
+ 
+ 	baselen = (u8 *) variable - (u8 *) mgmt;
+ 	if (baselen > len)
+ 		return;
+ 
+ 	rcu_read_lock();
+ 	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
+ 	if (!chanctx_conf) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 
+ 	if (ieee80211_rx_status_to_khz(rx_status) !=
+ 	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 	chan = chanctx_conf->def.chan;
+ 	rcu_read_unlock();
+ 
+ 	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
+ 	    !WARN_ON(sdata->vif.valid_links) &&
+ 	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {
+ 		elems = ieee802_11_parse_elems(variable, len - baselen, false,
+ 					       ifmgd->assoc_data->link[0].bss);
+ 		if (!elems)
+ 			return;
+ 
+ 		ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 		if (elems->dtim_period)
+ 			link->u.mgd.dtim_period = elems->dtim_period;
+ 		link->u.mgd.have_beacon = true;
+ 		ifmgd->assoc_data->need_beacon = false;
+ 		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
+ 			link->conf->sync_tsf =
+ 				le64_to_cpu(mgmt->u.beacon.timestamp);
+ 			link->conf->sync_device_ts =
+ 				rx_status->device_timestamp;
+ 			link->conf->sync_dtim_count = elems->dtim_count;
+ 		}
+ 
+ 		if (elems->mbssid_config_ie)
+ 			bss_conf->profile_periodicity =
+ 				elems->mbssid_config_ie->profile_periodicity;
+ 		else
+ 			bss_conf->profile_periodicity = 0;
+ 
+ 		if (elems->ext_capab_len >= 11 &&
+ 		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
+ 			bss_conf->ema_ap = true;
+ 		else
+ 			bss_conf->ema_ap = false;
+ 
+ 		/* continue assoc process */
+ 		ifmgd->assoc_data->timeout = jiffies;
+ 		ifmgd->assoc_data->timeout_started = true;
+ 		run_again(sdata, ifmgd->assoc_data->timeout);
+ 		kfree(elems);
+ 		return;
+ 	}
+ 
+ 	if (!ifmgd->associated ||
+ 	    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))
+ 		return;
+ 	bssid = link->u.mgd.bssid;
+ 
+ 	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
+ 		ieee80211_handle_beacon_sig(link, ifmgd, bss_conf,
+ 					    local, rx_status);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
+ 		mlme_dbg_ratelimited(sdata,
+ 				     "cancelling AP probe due to a received beacon\n");
+ 		ieee80211_reset_ap_probe(sdata);
+ 	}
+ 
+ 	/*
+ 	 * Push the beacon loss detection into the future since
+ 	 * we are processing a beacon from the AP just now.
+ 	 */
+ 	ieee80211_sta_reset_beacon_monitor(sdata);
+ 
+ 	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
+ 	 * element (which carries the beacon interval). Don't forget to add a
+ 	 * bit to care_about_ies[] above if mac80211 is interested in a
+ 	 * changing S1G element.
+ 	 */
+ 	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
+ 		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
+ 	elems = ieee802_11_parse_elems_crc(variable, len - baselen,
+ 					   false, care_about_ies, ncrc,
+ 					   link->u.mgd.bss);
+ 	if (!elems)
+ 		return;
+ 	ncrc = elems->crc;
+ 
+ 	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
+ 	    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {
+ 		if (local->hw.conf.dynamic_ps_timeout > 0) {
+ 			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
+ 				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
+ 				ieee80211_hw_config(local,
+ 						    IEEE80211_CONF_CHANGE_PS);
+ 			}
+ 			ieee80211_send_nullfunc(local, sdata, false);
+ 		} else if (!local->pspolling && sdata->u.mgd.powersave) {
+ 			local->pspolling = true;
+ 
+ 			/*
+ 			 * Here is assumed that the driver will be
+ 			 * able to send ps-poll frame and receive a
+ 			 * response even though power save mode is
+ 			 * enabled, but some drivers might require
+ 			 * to disable power save here. This needs
+ 			 * to be investigated.
+ 			 */
+ 			ieee80211_send_pspoll(local, sdata);
+ 		}
+ 	}
+ 
+ 	if (sdata->vif.p2p ||
+ 	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
+ 		struct ieee80211_p2p_noa_attr noa = {};
+ 		int ret;
+ 
+ 		ret = cfg80211_get_p2p_attr(variable,
+ 					    len - baselen,
+ 					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
+ 					    (u8 *) &noa, sizeof(noa));
+ 		if (ret >= 2) {
+ 			if (link->u.mgd.p2p_noa_index != noa.index) {
+ 				/* valid noa_attr and index changed */
+ 				link->u.mgd.p2p_noa_index = noa.index;
+ 				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
+ 				changed |= BSS_CHANGED_P2P_PS;
+ 				/*
+ 				 * make sure we update all information, the CRC
+ 				 * mechanism doesn't look at P2P attributes.
+ 				 */
+ 				link->u.mgd.beacon_crc_valid = false;
+ 			}
+ 		} else if (link->u.mgd.p2p_noa_index != -1) {
+ 			/* noa_attr not found and we had valid noa_attr before */
+ 			link->u.mgd.p2p_noa_index = -1;
+ 			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
+ 			changed |= BSS_CHANGED_P2P_PS;
+ 			link->u.mgd.beacon_crc_valid = false;
+ 		}
+ 	}
+ 
+ 	if (link->u.mgd.csa_waiting_bcn)
+ 		ieee80211_chswitch_post_beacon(link);
+ 
+ 	/*
+ 	 * Update beacon timing and dtim count on every beacon appearance. This
+ 	 * will allow the driver to use the most updated values. Do it before
+ 	 * comparing this one with last received beacon.
+ 	 * IMPORTANT: These parameters would possibly be out of sync by the time
+ 	 * the driver will use them. The synchronized view is currently
+ 	 * guaranteed only in certain callbacks.
+ 	 */
+ 	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
+ 	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
+ 		link->conf->sync_tsf =
+ 			le64_to_cpu(mgmt->u.beacon.timestamp);
+ 		link->conf->sync_device_ts =
+ 			rx_status->device_timestamp;
+ 		link->conf->sync_dtim_count = elems->dtim_count;
+ 	}
+ 
+ 	if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||
+ 	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
+ 		goto free;
+ 	link->u.mgd.beacon_crc = ncrc;
+ 	link->u.mgd.beacon_crc_valid = true;
+ 
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
+ 
+ 	ieee80211_sta_process_chanswitch(link, rx_status->mactime,
+ 					 rx_status->device_timestamp,
+ 					 elems, true);
+ 
+ 	if (!link->u.mgd.disable_wmm_tracking &&
+ 	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 				     elems->wmm_param_len,
+ 				     elems->mu_edca_param_set))
+ 		changed |= BSS_CHANGED_QOS;
+ 
+ 	/*
+ 	 * If we haven't had a beacon before, tell the driver about the
+ 	 * DTIM period (and beacon timing if desired) now.
+ 	 */
+ 	if (!link->u.mgd.have_beacon) {
+ 		/* a few bogus AP send dtim_period = 0 or no TIM IE */
+ 		bss_conf->dtim_period = elems->dtim_period ?: 1;
+ 
+ 		changed |= BSS_CHANGED_BEACON_INFO;
+ 		link->u.mgd.have_beacon = true;
+ 
+ 		mutex_lock(&local->iflist_mtx);
+ 		ieee80211_recalc_ps(local);
+ 		mutex_unlock(&local->iflist_mtx);
+ 
+ 		ieee80211_recalc_ps_vif(sdata);
+ 	}
+ 
+ 	if (elems->erp_info) {
+ 		erp_valid = true;
+ 		erp_value = elems->erp_info[0];
+ 	} else {
+ 		erp_valid = false;
+ 	}
+ 
+ 	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
+ 		changed |= ieee80211_handle_bss_capability(link,
+ 				le16_to_cpu(mgmt->u.beacon.capab_info),
+ 				erp_valid, erp_value);
+ 
+ 	mutex_lock(&local->sta_mtx);
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
+ 	if (WARN_ON(!sta))
+ 		goto free;
+ 	link_sta = rcu_dereference_protected(sta->link[link->link_id],
+ 					     lockdep_is_held(&local->sta_mtx));
+ 	if (WARN_ON(!link_sta))
+ 		goto free;
+ 
+ 	changed |= ieee80211_recalc_twt_req(link, link_sta, elems);
+ 
+ 	if (ieee80211_config_bw(link, elems->ht_cap_elem,
+ 				elems->vht_cap_elem, elems->ht_operation,
+ 				elems->vht_operation, elems->he_operation,
+ 				elems->eht_operation,
+ 				elems->s1g_oper, bssid, &changed)) {
+ 		mutex_unlock(&local->sta_mtx);
+ 		sdata_info(sdata,
+ 			   "failed to follow AP %pM bandwidth change, disconnect\n",
+ 			   bssid);
+ 		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
+ 				       WLAN_REASON_DEAUTH_LEAVING,
+ 				       true, deauth_buf);
+ 		ieee80211_report_disconnect(sdata, deauth_buf,
+ 					    sizeof(deauth_buf), true,
+ 					    WLAN_REASON_DEAUTH_LEAVING,
+ 					    false);
+ 		goto free;
+ 	}
+ 
+ 	if (sta && elems->opmode_notif)
+ 		ieee80211_vht_handle_opmode(sdata, link_sta,
+ 					    *elems->opmode_notif,
+ 					    rx_status->band);
+ 	mutex_unlock(&local->sta_mtx);
+ 
+ 	changed |= ieee80211_handle_pwr_constr(link, chan, mgmt,
+ 					       elems->country_elem,
+ 					       elems->country_elem_len,
+ 					       elems->pwr_constr_elem,
+ 					       elems->cisco_dtpc_elem);
+ 
+ 	ieee80211_link_info_change_notify(sdata, link, changed);
+ free:
+ 	kfree(elems);
+ }
+ 
+ void ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,
+ 				 struct sk_buff *skb)
+ {
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_rx_status *rx_status;
+ 	struct ieee80211_hdr *hdr;
+ 	u16 fc;
+ 
+ 	rx_status = (struct ieee80211_rx_status *) skb->cb;
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+ 	fc = le16_to_cpu(hdr->frame_control);
+ 
+ 	sdata_lock(sdata);
+ 	switch (fc & IEEE80211_FCTL_STYPE) {
+ 	case IEEE80211_STYPE_S1G_BEACON:
+ 		ieee80211_rx_mgmt_beacon(link, hdr, skb->len, rx_status);
+ 		break;
+ 	}
+ 	sdata_unlock(sdata);
+ }
+ 
+ void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+ 				  struct sk_buff *skb)
+ {
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_rx_status *rx_status;
+ 	struct ieee80211_mgmt *mgmt;
+ 	u16 fc;
+ 	int ies_len;
+ 
+ 	rx_status = (struct ieee80211_rx_status *) skb->cb;
+ 	mgmt = (struct ieee80211_mgmt *) skb->data;
+ 	fc = le16_to_cpu(mgmt->frame_control);
+ 
+ 	sdata_lock(sdata);
+ 
+ 	switch (fc & IEEE80211_FCTL_STYPE) {
+ 	case IEEE80211_STYPE_BEACON:
+ 		ieee80211_rx_mgmt_beacon(link, (void *)mgmt,
+ 					 skb->len, rx_status);
+ 		break;
+ 	case IEEE80211_STYPE_PROBE_RESP:
+ 		ieee80211_rx_mgmt_probe_resp(link, skb);
+ 		break;
+ 	case IEEE80211_STYPE_AUTH:
+ 		ieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_DEAUTH:
+ 		ieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_DISASSOC:
+ 		ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_ASSOC_RESP:
+ 	case IEEE80211_STYPE_REASSOC_RESP:
+ 		ieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);
+ 		break;
+ 	case IEEE80211_STYPE_ACTION:
+ 		if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {
+ 			struct ieee802_11_elems *elems;
+ 
+ 			ies_len = skb->len -
+ 				  offsetof(struct ieee80211_mgmt,
+ 					   u.action.u.chan_switch.variable);
+ 
+ 			if (ies_len < 0)
+ 				break;
+ 
+ 			/* CSA IE cannot be overridden, no need for BSSID */
+ 			elems = ieee802_11_parse_elems(
+ 					mgmt->u.action.u.chan_switch.variable,
+ 					ies_len, true, NULL);
+ 
+ 			if (elems && !elems->parse_error)
+ 				ieee80211_sta_process_chanswitch(link,
+ 								 rx_status->mactime,
+ 								 rx_status->device_timestamp,
+ 								 elems, false);
+ 			kfree(elems);
+ 		} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
+ 			struct ieee802_11_elems *elems;
+ 
+ 			ies_len = skb->len -
+ 				  offsetof(struct ieee80211_mgmt,
+ 					   u.action.u.ext_chan_switch.variable);
+ 
+ 			if (ies_len < 0)
+ 				break;
+ 
+ 			/*
+ 			 * extended CSA IE can't be overridden, no need for
+ 			 * BSSID
+ 			 */
+ 			elems = ieee802_11_parse_elems(
+ 					mgmt->u.action.u.ext_chan_switch.variable,
+ 					ies_len, true, NULL);
+ 
+ 			if (elems && !elems->parse_error) {
+ 				/* for the handling code pretend it was an IE */
+ 				elems->ext_chansw_ie =
+ 					&mgmt->u.action.u.ext_chan_switch.data;
+ 
+ 				ieee80211_sta_process_chanswitch(link,
+ 								 rx_status->mactime,
+ 								 rx_status->device_timestamp,
+ 								 elems, false);
+ 			}
+ 
+ 			kfree(elems);
+ 		}
+ 		break;
+ 	}
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_sta_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.timer);
+ 
+ 	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+ }
+ 
+ void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
+ 				   u8 reason, bool tx)
+ {
+ 	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH, reason,
+ 			       tx, frame_buf);
+ 
+ 	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
+ 				    reason, false);
+ }
+ 
+ static int ieee80211_auth(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_auth_data *auth_data = ifmgd->auth_data;
+ 	u32 tx_flags = 0;
+ 	u16 trans = 1;
+ 	u16 status = 0;
+ 	struct ieee80211_prep_tx_info info = {
+ 		.subtype = IEEE80211_STYPE_AUTH,
+ 	};
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	if (WARN_ON_ONCE(!auth_data))
+ 		return -EINVAL;
+ 
+ 	auth_data->tries++;
+ 
+ 	if (auth_data->tries > IEEE80211_AUTH_MAX_TRIES) {
+ 		sdata_info(sdata, "authentication with %pM timed out\n",
+ 			   auth_data->ap_addr);
+ 
+ 		/*
+ 		 * Most likely AP is not in the range so remove the
+ 		 * bss struct for that AP.
+ 		 */
+ 		cfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);
+ 
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	if (auth_data->algorithm == WLAN_AUTH_SAE)
+ 		info.duration = jiffies_to_msecs(IEEE80211_AUTH_TIMEOUT_SAE);
+ 
+ 	drv_mgd_prepare_tx(local, sdata, &info);
+ 
+ 	sdata_info(sdata, "send auth to %pM (try %d/%d)\n",
+ 		   auth_data->ap_addr, auth_data->tries,
+ 		   IEEE80211_AUTH_MAX_TRIES);
+ 
+ 	auth_data->expected_transaction = 2;
+ 
+ 	if (auth_data->algorithm == WLAN_AUTH_SAE) {
+ 		trans = auth_data->sae_trans;
+ 		status = auth_data->sae_status;
+ 		auth_data->expected_transaction = trans;
+ 	}
+ 
+ 	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
+ 		tx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
+ 			   IEEE80211_TX_INTFL_MLME_CONN_TX;
+ 
+ 	ieee80211_send_auth(sdata, trans, auth_data->algorithm, status,
+ 			    auth_data->data, auth_data->data_len,
+ 			    auth_data->ap_addr, auth_data->ap_addr,
+ 			    NULL, 0, 0, tx_flags);
+ 
+ 	if (tx_flags == 0) {
+ 		if (auth_data->algorithm == WLAN_AUTH_SAE)
+ 			auth_data->timeout = jiffies +
+ 				IEEE80211_AUTH_TIMEOUT_SAE;
+ 		else
+ 			auth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
+ 	} else {
+ 		auth_data->timeout =
+ 			round_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);
+ 	}
+ 
+ 	auth_data->timeout_started = true;
+ 	run_again(sdata, auth_data->timeout);
+ 
+ 	return 0;
+ }
+ 
+ static int ieee80211_do_assoc(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	int ret;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	assoc_data->tries++;
+ 	if (assoc_data->tries > IEEE80211_ASSOC_MAX_TRIES) {
+ 		sdata_info(sdata, "association with %pM timed out\n",
+ 			   assoc_data->ap_addr);
+ 
+ 		/*
+ 		 * Most likely AP is not in the range so remove the
+ 		 * bss struct for that AP.
+ 		 */
+ 		cfg80211_unlink_bss(local->hw.wiphy,
+ 				    assoc_data->link[assoc_data->assoc_link_id].bss);
+ 
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	sdata_info(sdata, "associate with %pM (try %d/%d)\n",
+ 		   assoc_data->ap_addr, assoc_data->tries,
+ 		   IEEE80211_ASSOC_MAX_TRIES);
+ 	ret = ieee80211_send_assoc(sdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 		assoc_data->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;
+ 		assoc_data->timeout_started = true;
+ 		run_again(sdata, assoc_data->timeout);
+ 	} else {
+ 		assoc_data->timeout =
+ 			round_jiffies_up(jiffies +
+ 					 IEEE80211_ASSOC_TIMEOUT_LONG);
+ 		assoc_data->timeout_started = true;
+ 		run_again(sdata, assoc_data->timeout);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,
+ 				  __le16 fc, bool acked)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 
+ 	sdata->u.mgd.status_fc = fc;
+ 	sdata->u.mgd.status_acked = acked;
+ 	sdata->u.mgd.status_received = true;
+ 
+ 	ieee80211_queue_work(&local->hw, &sdata->work);
+ }
+ 
+ void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_lock(sdata);
+ 
+ 	if (ifmgd->status_received) {
+ 		__le16 fc = ifmgd->status_fc;
+ 		bool status_acked = ifmgd->status_acked;
+ 
+ 		ifmgd->status_received = false;
+ 		if (ifmgd->auth_data && ieee80211_is_auth(fc)) {
+ 			if (status_acked) {
+ 				if (ifmgd->auth_data->algorithm ==
+ 				    WLAN_AUTH_SAE)
+ 					ifmgd->auth_data->timeout =
+ 						jiffies +
+ 						IEEE80211_AUTH_TIMEOUT_SAE;
+ 				else
+ 					ifmgd->auth_data->timeout =
+ 						jiffies +
+ 						IEEE80211_AUTH_TIMEOUT_SHORT;
+ 				run_again(sdata, ifmgd->auth_data->timeout);
+ 			} else {
+ 				ifmgd->auth_data->timeout = jiffies - 1;
+ 			}
+ 			ifmgd->auth_data->timeout_started = true;
+ 		} else if (ifmgd->assoc_data &&
+ 			   (ieee80211_is_assoc_req(fc) ||
+ 			    ieee80211_is_reassoc_req(fc))) {
+ 			if (status_acked) {
+ 				ifmgd->assoc_data->timeout =
+ 					jiffies + IEEE80211_ASSOC_TIMEOUT_SHORT;
+ 				run_again(sdata, ifmgd->assoc_data->timeout);
+ 			} else {
+ 				ifmgd->assoc_data->timeout = jiffies - 1;
+ 			}
+ 			ifmgd->assoc_data->timeout_started = true;
+ 		}
+ 	}
+ 
+ 	if (ifmgd->auth_data && ifmgd->auth_data->timeout_started &&
+ 	    time_after(jiffies, ifmgd->auth_data->timeout)) {
+ 		if (ifmgd->auth_data->done || ifmgd->auth_data->waiting) {
+ 			/*
+ 			 * ok ... we waited for assoc or continuation but
+ 			 * userspace didn't do it, so kill the auth data
+ 			 */
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 		} else if (ieee80211_auth(sdata)) {
+ 			u8 ap_addr[ETH_ALEN];
+ 			struct ieee80211_event event = {
+ 				.type = MLME_EVENT,
+ 				.u.mlme.data = AUTH_EVENT,
+ 				.u.mlme.status = MLME_TIMEOUT,
+ 			};
+ 
+ 			memcpy(ap_addr, ifmgd->auth_data->ap_addr, ETH_ALEN);
+ 
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 
+ 			cfg80211_auth_timeout(sdata->dev, ap_addr);
+ 			drv_event_callback(sdata->local, sdata, &event);
+ 		}
+ 	} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)
+ 		run_again(sdata, ifmgd->auth_data->timeout);
+ 
+ 	if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started &&
+ 	    time_after(jiffies, ifmgd->assoc_data->timeout)) {
+ 		if ((ifmgd->assoc_data->need_beacon &&
+ 		     !sdata->deflink.u.mgd.have_beacon) ||
+ 		    ieee80211_do_assoc(sdata)) {
+ 			struct ieee80211_event event = {
+ 				.type = MLME_EVENT,
+ 				.u.mlme.data = ASSOC_EVENT,
+ 				.u.mlme.status = MLME_TIMEOUT,
+ 			};
+ 
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
+ 			drv_event_callback(sdata->local, sdata, &event);
+ 		}
+ 	} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)
+ 		run_again(sdata, ifmgd->assoc_data->timeout);
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL &&
+ 	    ifmgd->associated) {
+ 		u8 *bssid = sdata->deflink.u.mgd.bssid;
+ 		int max_tries;
+ 
+ 		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
+ 			max_tries = max_nullfunc_tries;
+ 		else
+ 			max_tries = max_probe_tries;
+ 
+ 		/* ACK received for nullfunc probing frame */
+ 		if (!ifmgd->probe_send_count)
+ 			ieee80211_reset_ap_probe(sdata);
+ 		else if (ifmgd->nullfunc_failed) {
+ 			if (ifmgd->probe_send_count < max_tries) {
+ 				mlme_dbg(sdata,
+ 					 "No ack for nullfunc frame to AP %pM, try %d/%i\n",
+ 					 bssid, ifmgd->probe_send_count,
+ 					 max_tries);
+ 				ieee80211_mgd_probe_ap_send(sdata);
+ 			} else {
+ 				mlme_dbg(sdata,
+ 					 "No ack for nullfunc frame to AP %pM, disconnecting.\n",
+ 					 bssid);
+ 				ieee80211_sta_connection_lost(sdata,
+ 					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
+ 					false);
+ 			}
+ 		} else if (time_is_after_jiffies(ifmgd->probe_timeout))
+ 			run_again(sdata, ifmgd->probe_timeout);
+ 		else if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 			mlme_dbg(sdata,
+ 				 "Failed to send nullfunc to AP %pM after %dms, disconnecting\n",
+ 				 bssid, probe_wait_ms);
+ 			ieee80211_sta_connection_lost(sdata,
+ 				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
+ 		} else if (ifmgd->probe_send_count < max_tries) {
+ 			mlme_dbg(sdata,
+ 				 "No probe response from AP %pM after %dms, try %d/%i\n",
+ 				 bssid, probe_wait_ms,
+ 				 ifmgd->probe_send_count, max_tries);
+ 			ieee80211_mgd_probe_ap_send(sdata);
+ 		} else {
+ 			/*
+ 			 * We actually lost the connection ... or did we?
+ 			 * Let's make sure!
+ 			 */
+ 			mlme_dbg(sdata,
+ 				 "No probe response from AP %pM after %dms, disconnecting.\n",
+ 				 bssid, probe_wait_ms);
+ 
+ 			ieee80211_sta_connection_lost(sdata,
+ 				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
+ 		}
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_sta_bcn_mon_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.bcn_mon_timer);
+ 
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
+ 		return;
+ 
+ 	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
+ 		return;
+ 
+ 	sdata->u.mgd.connection_loss = false;
+ 	ieee80211_queue_work(&sdata->local->hw,
+ 			     &sdata->u.mgd.beacon_connection_loss_work);
+ }
+ 
+ static void ieee80211_sta_conn_mon_timer(struct timer_list *t)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		from_timer(sdata, t, u.mgd.conn_mon_timer);
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct sta_info *sta;
+ 	unsigned long timeout;
+ 
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
+ 		return;
+ 
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
+ 	if (!sta)
+ 		return;
+ 
+ 	timeout = sta->deflink.status_stats.last_ack;
+ 	if (time_before(sta->deflink.status_stats.last_ack, sta->deflink.rx_stats.last_rx))
+ 		timeout = sta->deflink.rx_stats.last_rx;
+ 	timeout += IEEE80211_CONNECTION_IDLE_TIME;
+ 
+ 	/* If timeout is after now, then update timer to fire at
+ 	 * the later date, but do not actually probe at this time.
+ 	 */
+ 	if (time_is_after_jiffies(timeout)) {
+ 		mod_timer(&ifmgd->conn_mon_timer, round_jiffies_up(timeout));
+ 		return;
+ 	}
+ 
+ 	ieee80211_queue_work(&local->hw, &ifmgd->monitor_work);
+ }
+ 
+ static void ieee80211_sta_monitor_work(struct work_struct *work)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		container_of(work, struct ieee80211_sub_if_data,
+ 			     u.mgd.monitor_work);
+ 
+ 	ieee80211_mgd_probe_ap(sdata, false);
+ }
+ 
+ static void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata)
+ {
+ 	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+ 		__ieee80211_stop_poll(sdata);
+ 
+ 		/* let's probe the connection once */
+ 		if (!ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
+ 			ieee80211_queue_work(&sdata->local->hw,
+ 					     &sdata->u.mgd.monitor_work);
+ 	}
+ }
+ 
+ #ifdef CONFIG_PM
+ void ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+ 
+ 	sdata_lock(sdata);
+ 
+ 	if (ifmgd->auth_data || ifmgd->assoc_data) {
+ 		const u8 *ap_addr = ifmgd->auth_data ?
+ 				ifmgd->auth_data->ap_addr :
+ 				ifmgd->assoc_data->ap_addr;
+ 
+ 		/*
+ 		 * If we are trying to authenticate / associate while suspending,
+ 		 * cfg80211 won't know and won't actually abort those attempts,
+ 		 * thus we need to do that ourselves.
+ 		 */
+ 		ieee80211_send_deauth_disassoc(sdata, ap_addr, ap_addr,
+ 					       IEEE80211_STYPE_DEAUTH,
+ 					       WLAN_REASON_DEAUTH_LEAVING,
+ 					       false, frame_buf);
+ 		if (ifmgd->assoc_data)
+ 			ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 		if (ifmgd->auth_data)
+ 			ieee80211_destroy_auth_data(sdata, false);
+ 		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
+ 				      IEEE80211_DEAUTH_FRAME_LEN,
+ 				      false);
+ 	}
+ 
+ 	/* This is a bit of a hack - we should find a better and more generic
+ 	 * solution to this. Normally when suspending, cfg80211 will in fact
+ 	 * deauthenticate. However, it doesn't (and cannot) stop an ongoing
+ 	 * auth (not so important) or assoc (this is the problem) process.
+ 	 *
+ 	 * As a consequence, it can happen that we are in the process of both
+ 	 * associating and suspending, and receive an association response
+ 	 * after cfg80211 has checked if it needs to disconnect, but before
+ 	 * we actually set the flag to drop incoming frames. This will then
+ 	 * cause the workqueue flush to process the association response in
+ 	 * the suspend, resulting in a successful association just before it
+ 	 * tries to remove the interface from the driver, which now though
+ 	 * has a channel context assigned ... this results in issues.
+ 	 *
+ 	 * To work around this (for now) simply deauth here again if we're
+ 	 * now connected.
+ 	 */
+ 	if (ifmgd->associated && !sdata->local->wowlan) {
+ 		u8 bssid[ETH_ALEN];
+ 		struct cfg80211_deauth_request req = {
+ 			.reason_code = WLAN_REASON_DEAUTH_LEAVING,
+ 			.bssid = bssid,
+ 		};
+ 
+ 		memcpy(bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
+ 		ieee80211_mgd_deauth(sdata, &req);
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ #endif
+ 
+ void ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	sdata_lock(sdata);
+ 	if (!ifmgd->associated) {
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {
+ 		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;
+ 		mlme_dbg(sdata, "driver requested disconnect after resume\n");
+ 		ieee80211_sta_connection_lost(sdata,
+ 					      WLAN_REASON_UNSPECIFIED,
+ 					      true);
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_HW_RESTART) {
+ 		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_HW_RESTART;
+ 		mlme_dbg(sdata, "driver requested disconnect after hardware restart\n");
+ 		ieee80211_sta_connection_lost(sdata,
+ 					      WLAN_REASON_UNSPECIFIED,
+ 					      true);
+ 		sdata_unlock(sdata);
+ 		return;
+ 	}
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_request_smps_mgd_work(struct work_struct *work)
+ {
+ 	struct ieee80211_link_data *link =
+ 		container_of(work, struct ieee80211_link_data,
+ 			     u.mgd.request_smps_work);
+ 
+ 	sdata_lock(link->sdata);
+ 	__ieee80211_request_smps_mgd(link->sdata, link,
+ 				     link->u.mgd.driver_smps_mode);
+ 	sdata_unlock(link->sdata);
+ }
+ 
+ /* interface setup */
+ void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 
+ 	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
+ 	INIT_WORK(&ifmgd->beacon_connection_loss_work,
+ 		  ieee80211_beacon_connection_loss_work);
+ 	INIT_WORK(&ifmgd->csa_connection_drop_work,
+ 		  ieee80211_csa_connection_drop_work);
+ 	INIT_DELAYED_WORK(&ifmgd->tdls_peer_del_work,
+ 			  ieee80211_tdls_peer_del_work);
+ 	timer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);
+ 	timer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);
+ 	timer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);
+ 	INIT_DELAYED_WORK(&ifmgd->tx_tspec_wk,
+ 			  ieee80211_sta_handle_tspec_ac_params_wk);
+ 
+ 	ifmgd->flags = 0;
+ 	ifmgd->powersave = sdata->wdev.ps;
+ 	ifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;
+ 	ifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;
+ 	/* Setup TDLS data */
+ 	spin_lock_init(&ifmgd->teardown_lock);
+ 	ifmgd->teardown_skb = NULL;
+ 	ifmgd->orig_teardown_skb = NULL;
+ }
+ 
+ void ieee80211_mgd_setup_link(struct ieee80211_link_data *link)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id = link->link_id;
+ 
+ 	link->u.mgd.p2p_noa_index = -1;
+ 	link->u.mgd.conn_flags = 0;
+ 	link->conf->bssid = link->u.mgd.bssid;
+ 
+ 	INIT_WORK(&link->u.mgd.request_smps_work,
+ 		  ieee80211_request_smps_mgd_work);
+ 	if (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
+ 	else
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_OFF;
+ 
+ 	INIT_WORK(&link->u.mgd.chswitch_work, ieee80211_chswitch_work);
+ 	timer_setup(&link->u.mgd.chswitch_timer, ieee80211_chswitch_timer, 0);
+ 
+ 	if (sdata->u.mgd.assoc_data)
+ 		ether_addr_copy(link->conf->addr,
+ 				sdata->u.mgd.assoc_data->link[link_id].addr);
+ }
+ 
+ /* scan finished notification */
+ void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 
+ 	/* Restart STA timers */
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+ 		if (ieee80211_sdata_running(sdata))
+ 			ieee80211_restart_sta_timer(sdata);
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> b18d87f5d102 (wifi: mac80211: mlme: fix link_sta setup)
+ static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
+ 			       u8 *dtim_count, u8 *dtim_period)
+ {
+ 	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
+ 	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
+ 					 ies->len);
+ 	const struct ieee80211_tim_ie *tim = NULL;
+ 	const struct ieee80211_bssid_index *idx;
+ 	bool valid = tim_ie && tim_ie[1] >= 2;
+ 
+ 	if (valid)
+ 		tim = (void *)(tim_ie + 2);
+ 
+ 	if (dtim_count)
+ 		*dtim_count = valid ? tim->dtim_count : 0;
+ 
+ 	if (dtim_period)
+ 		*dtim_period = valid ? tim->dtim_period : 0;
+ 
+ 	/* Check if value is overridden by non-transmitted profile */
+ 	if (!idx_ie || idx_ie[1] < 3)
+ 		return valid;
+ 
+ 	idx = (void *)(idx_ie + 2);
+ 
+ 	if (dtim_count)
+ 		*dtim_count = idx->dtim_count;
+ 
+ 	if (dtim_period)
+ 		*dtim_period = idx->dtim_period;
+ 
+ 	return true;
+ }
+ 
+ static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 -				     struct cfg80211_bss *cbss, s8 link_id,
 -				     const u8 *ap_mld_addr, bool assoc,
++				     struct cfg80211_bss *cbss, bool assoc,
+ 				     bool override)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	struct sta_info *new_sta = NULL;
 -	struct ieee80211_link_data *link;
++	struct ieee80211_supported_band *sband;
+ 	bool have_sta = false;
 -	bool mlo;
+ 	int err;
+ 
 -	if (link_id >= 0) {
 -		mlo = true;
 -		if (WARN_ON(!ap_mld_addr))
 -			return -EINVAL;
 -		err = ieee80211_vif_set_links(sdata, BIT(link_id));
 -	} else {
 -		if (WARN_ON(ap_mld_addr))
 -			return -EINVAL;
 -		ap_mld_addr = cbss->bssid;
 -		err = ieee80211_vif_set_links(sdata, 0);
 -		link_id = 0;
 -		mlo = false;
 -	}
 -
 -	if (err)
 -		return err;
 -
 -	link = sdata_dereference(sdata->link[link_id], sdata);
 -	if (WARN_ON(!link)) {
 -		err = -ENOLINK;
 -		goto out_err;
 -	}
 -
 -	if (mlo && !is_valid_ether_addr(link->conf->addr))
 -		eth_random_addr(link->conf->addr);
 -
 -	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data)) {
 -		err = -EINVAL;
 -		goto out_err;
 -	}
++	sband = local->hw.wiphy->bands[cbss->channel->band];
++
++	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data))
++		return -EINVAL;
+ 
+ 	/* If a reconfig is happening, bail out */
 -	if (local->in_reconfig) {
 -		err = -EBUSY;
 -		goto out_err;
 -	}
++	if (local->in_reconfig)
++		return -EBUSY;
+ 
+ 	if (assoc) {
+ 		rcu_read_lock();
 -		have_sta = sta_info_get(sdata, ap_mld_addr);
++		have_sta = sta_info_get(sdata, cbss->bssid);
+ 		rcu_read_unlock();
+ 	}
+ 
+ 	if (!have_sta) {
 -		if (mlo)
 -			new_sta = sta_info_alloc_with_link(sdata, ap_mld_addr,
 -							   link_id, cbss->bssid,
 -							   GFP_KERNEL);
 -		else
 -			new_sta = sta_info_alloc(sdata, ap_mld_addr, GFP_KERNEL);
 -
 -		if (!new_sta) {
 -			err = -ENOMEM;
 -			goto out_err;
 -		}
 -
 -		new_sta->sta.mlo = mlo;
++		new_sta = sta_info_alloc(sdata, cbss->bssid, GFP_KERNEL);
++		if (!new_sta)
++			return -ENOMEM;
+ 	}
+ 
+ 	/*
+ 	 * Set up the information for the new channel before setting the
+ 	 * new channel. We can't - completely race-free - change the basic
+ 	 * rates bitmap and the channel (sband) that it refers to, but if
+ 	 * we set it up before we at least avoid calling into the driver's
+ 	 * bss_info_changed() method with invalid information (since we do
+ 	 * call that from changing the channel - only for IDLE and perhaps
+ 	 * some others, but ...).
+ 	 *
+ 	 * So to avoid that, just set up all the new information before the
+ 	 * channel, but tell the driver to apply it only afterwards, since
+ 	 * it might need the new channel for that.
+ 	 */
+ 	if (new_sta) {
++		u32 rates = 0, basic_rates = 0;
++		bool have_higher_than_11mbit = false;
++		int min_rate = INT_MAX, min_rate_index = -1;
+ 		const struct cfg80211_bss_ies *ies;
++<<<<<<< HEAD
++		int shift = ieee80211_vif_get_shift(&sdata->vif);
++
++		/* TODO: S1G Basic Rate Set is expressed elsewhere */
++		if (cbss->channel->band == NL80211_BAND_S1GHZ) {
++			ieee80211_s1g_sta_rate_init(new_sta);
++			goto skip_rates;
++=======
+ 		struct link_sta_info *link_sta;
+ 
+ 		rcu_read_lock();
+ 		link_sta = rcu_dereference(new_sta->link[link_id]);
+ 		if (WARN_ON(!link_sta)) {
+ 			rcu_read_unlock();
+ 			sta_info_free(local, new_sta);
+ 			err = -EINVAL;
+ 			goto out_err;
++>>>>>>> b18d87f5d102 (wifi: mac80211: mlme: fix link_sta setup)
  		}
  
 -		err = ieee80211_mgd_setup_link_sta(link, new_sta,
 -						   link_sta, cbss);
 -		if (err) {
 -			rcu_read_unlock();
 +		ieee80211_get_rates(sband, bss->supp_rates,
 +				    bss->supp_rates_len,
 +				    &rates, &basic_rates,
 +				    &have_higher_than_11mbit,
 +				    &min_rate, &min_rate_index,
 +				    shift);
 +
 +		/*
 +		 * This used to be a workaround for basic rates missing
 +		 * in the association response frame. Now that we no
 +		 * longer use the basic rates from there, it probably
 +		 * doesn't happen any more, but keep the workaround so
 +		 * in case some *other* APs are buggy in different ways
 +		 * we can connect -- with a warning.
 +		 * Allow this workaround only in case the AP provided at least
 +		 * one rate.
 +		 */
 +		if (min_rate_index < 0) {
 +			sdata_info(sdata,
 +				   "No legacy rates in association response\n");
 +
  			sta_info_free(local, new_sta);
 -			goto out_err;
 +			return -EINVAL;
 +		} else if (!basic_rates) {
 +			sdata_info(sdata,
 +				   "No basic rates, using min rate instead\n");
 +			basic_rates = BIT(min_rate_index);
  		}
  
 -		memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
 +		if (rates)
 +			new_sta->sta.supp_rates[cbss->channel->band] = rates;
 +		else
 +			sdata_info(sdata,
 +				   "No rates found, keeping mandatory only\n");
 +
 +		sdata->vif.bss_conf.basic_rates = basic_rates;
 +
 +		/* cf. IEEE 802.11 9.2.12 */
 +		if (cbss->channel->band == NL80211_BAND_2GHZ &&
 +		    have_higher_than_11mbit)
 +			sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
 +		else
 +			sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
 +
 +skip_rates:
 +		memcpy(ifmgd->bssid, cbss->bssid, ETH_ALEN);
  
  		/* set timing information */
 -		link->conf->beacon_int = cbss->beacon_interval;
 +		sdata->vif.bss_conf.beacon_int = cbss->beacon_interval;
 +		rcu_read_lock();
  		ies = rcu_dereference(cbss->beacon_ies);
  		if (ies) {
 -			link->conf->sync_tsf = ies->tsf;
 -			link->conf->sync_device_ts =
 +			sdata->vif.bss_conf.sync_tsf = ies->tsf;
 +			sdata->vif.bss_conf.sync_device_ts =
  				bss->device_ts_beacon;
  
  			ieee80211_get_dtim(ies,
* Unmerged path net/mac80211/mlme.c
