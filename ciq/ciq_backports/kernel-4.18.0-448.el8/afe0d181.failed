wifi: mac80211: add link_id to vht.c code for MLO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit afe0d181905ed03c2379fcb81d423704f59f8788
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/afe0d181.failed

Update the code in vht.c and add the link_id parameter where
necessary.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit afe0d181905ed03c2379fcb81d423704f59f8788)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ibss.c
#	net/mac80211/ieee80211_i.h
#	net/mac80211/vht.c
diff --cc net/mac80211/ibss.c
index cfd5e16e19ac,87815a3624f3..000000000000
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@@ -1068,8 -1068,8 +1068,13 @@@ static void ieee80211_update_sta_info(s
  						   &chandef);
  			memcpy(&cap_ie, elems->vht_cap_elem, sizeof(cap_ie));
  			ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
++<<<<<<< HEAD
 +							    &cap_ie, sta);
 +			if (memcmp(&cap, &sta->sta.vht_cap, sizeof(cap)))
++=======
+ 							    &cap_ie, sta, 0);
+ 			if (memcmp(&cap, &sta->sta.deflink.vht_cap, sizeof(cap)))
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  				rates_updated |= true;
  		}
  
diff --cc net/mac80211/ieee80211_i.h
index aebf2fa517be,5be96b0bbd96..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -2094,21 -2121,25 +2094,32 @@@ voi
  ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
  				    struct ieee80211_supported_band *sband,
  				    const struct ieee80211_vht_cap *vht_cap_ie,
++<<<<<<< HEAD
 +				    struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta);
 +void ieee80211_sta_set_rx_nss(struct sta_info *sta);
++=======
+ 				    struct sta_info *sta, unsigned int link_id);
+ enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta,
+ 							unsigned int link_id);
+ enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta,
+ 							 unsigned int link_id);
+ void ieee80211_sta_set_rx_nss(struct sta_info *sta, unsigned int link_id);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  enum ieee80211_sta_rx_bandwidth
  ieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width);
- enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta);
+ enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta,
+ 						  unsigned int link_id);
  void ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,
+ 				 unsigned int link_id,
  				 struct ieee80211_mgmt *mgmt);
  u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
-                                   struct sta_info *sta, u8 opmode,
- 				  enum nl80211_band band);
+ 				  struct sta_info *sta, unsigned int link_id,
+ 				  u8 opmode, enum nl80211_band band);
  void ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
- 				 struct sta_info *sta, u8 opmode,
- 				 enum nl80211_band band);
+ 				 struct sta_info *sta, unsigned int link_id,
+ 				 u8 opmode, enum nl80211_band band);
  void ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,
  				      struct ieee80211_sta_vht_cap *vht_cap);
  void ieee80211_get_vht_mask_from_cap(__le16 vht_cap,
diff --cc net/mac80211/vht.c
index bc39bec42e54,acfe1459535f..000000000000
--- a/net/mac80211/vht.c
+++ b/net/mac80211/vht.c
@@@ -116,16 -116,16 +116,24 @@@ voi
  ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
  				    struct ieee80211_supported_band *sband,
  				    const struct ieee80211_vht_cap *vht_cap_ie,
- 				    struct sta_info *sta)
+ 				    struct sta_info *sta, unsigned int link_id)
  {
++<<<<<<< HEAD
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
++=======
+ 	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.link[link_id]->vht_cap;
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  	struct ieee80211_sta_vht_cap own_cap;
  	u32 cap_info, i;
  	bool have_80mhz;
  
  	memset(vht_cap, 0, sizeof(*vht_cap));
  
++<<<<<<< HEAD
 +	if (!sta->sta.ht_cap.ht_supported)
++=======
+ 	if (!sta->sta.link[link_id]->ht_cap.ht_supported)
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  		return;
  
  	if (!vht_cap_ie || !sband->vht_cap.vht_supported)
@@@ -295,10 -295,10 +303,17 @@@
  	switch (vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {
  	case IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:
  	case IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:
++<<<<<<< HEAD
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +		break;
 +	default:
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
++=======
+ 		sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
+ 		break;
+ 	default:
+ 		sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  
  		if (!(vht_cap->vht_mcs.tx_highest &
  				cpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE)))
@@@ -310,10 -310,11 +325,18 @@@
  		 * above) between 160 and 80+80 yet.
  		 */
  		if (cap_info & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK)
++<<<<<<< HEAD
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +	}
 +
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
++=======
+ 			sta->link[link_id]->cur_max_bandwidth =
+ 				IEEE80211_STA_RX_BW_160;
+ 	}
+ 
+ 	sta->sta.link[link_id]->bandwidth = ieee80211_sta_cur_vht_bw(sta, link_id);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  
  	switch (vht_cap->cap & IEEE80211_VHT_CAP_MAX_MPDU_MASK) {
  	case IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:
@@@ -390,16 -392,17 +413,28 @@@ enum ieee80211_sta_rx_bandwidth ieee802
  	return IEEE80211_STA_RX_BW_80;
  }
  
- enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta)
+ enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta,
+ 						  unsigned int link_id)
  {
++<<<<<<< HEAD
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
 +	u32 cap_width;
 +
 +	if (!vht_cap->vht_supported) {
 +		if (!sta->sta.ht_cap.ht_supported)
 +			return NL80211_CHAN_WIDTH_20_NOHT;
 +
 +		return sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++=======
+ 	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.link[link_id]->vht_cap;
+ 	u32 cap_width;
+ 
+ 	if (!vht_cap->vht_supported) {
+ 		if (!sta->sta.link[link_id]->ht_cap.ht_supported)
+ 			return NL80211_CHAN_WIDTH_20_NOHT;
+ 
+ 		return sta->sta.link[link_id]->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  				NL80211_CHAN_WIDTH_40 : NL80211_CHAN_WIDTH_20;
  	}
  
@@@ -414,15 -417,17 +449,26 @@@
  }
  
  enum nl80211_chan_width
- ieee80211_sta_rx_bw_to_chan_width(struct sta_info *sta)
+ ieee80211_sta_rx_bw_to_chan_width(struct sta_info *sta, unsigned int link_id)
  {
++<<<<<<< HEAD
 +	enum ieee80211_sta_rx_bandwidth cur_bw = sta->sta.bandwidth;
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
++=======
+ 	enum ieee80211_sta_rx_bandwidth cur_bw =
+ 		sta->sta.link[link_id]->bandwidth;
+ 	struct ieee80211_sta_vht_cap *vht_cap =
+ 		&sta->sta.link[link_id]->vht_cap;
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  	u32 cap_width;
  
  	switch (cur_bw) {
  	case IEEE80211_STA_RX_BW_20:
++<<<<<<< HEAD
 +		if (!sta->sta.ht_cap.ht_supported)
++=======
+ 		if (!sta->sta.link[link_id]->ht_cap.ht_supported)
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  			return NL80211_CHAN_WIDTH_20_NOHT;
  		else
  			return NL80211_CHAN_WIDTH_20;
@@@ -501,12 -507,12 +547,21 @@@ void ieee80211_sta_set_rx_nss(struct st
  	bool support_160;
  
  	/* if we received a notification already don't overwrite it */
++<<<<<<< HEAD
 +	if (sta->sta.rx_nss)
 +		return;
 +
 +	if (sta->sta.eht_cap.has_eht) {
 +		int i;
 +		const u8 *rx_nss_mcs = (void *)&sta->sta.eht_cap.eht_mcs_nss_supp;
++=======
+ 	if (sta->sta.link[link_id]->rx_nss)
+ 		return;
+ 
+ 	if (sta->sta.link[link_id]->eht_cap.has_eht) {
+ 		int i;
+ 		const u8 *rx_nss_mcs = (void *)&sta->sta.link[link_id]->eht_cap.eht_mcs_nss_supp;
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  
  		/* get the max nss for EHT over all possible bandwidths and mcs */
  		for (i = 0; i < sizeof(struct ieee80211_eht_mcs_nss_supp); i++)
@@@ -515,10 -521,10 +570,17 @@@
  						       IEEE80211_EHT_MCS_NSS_RX));
  	}
  
++<<<<<<< HEAD
 +	if (sta->sta.he_cap.has_he) {
 +		int i;
 +		u8 rx_mcs_80 = 0, rx_mcs_160 = 0;
 +		const struct ieee80211_sta_he_cap *he_cap = &sta->sta.he_cap;
++=======
+ 	if (sta->sta.link[link_id]->he_cap.has_he) {
+ 		int i;
+ 		u8 rx_mcs_80 = 0, rx_mcs_160 = 0;
+ 		const struct ieee80211_sta_he_cap *he_cap = &sta->sta.link[link_id]->he_cap;
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  		u16 mcs_160_map =
  			le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);
  		u16 mcs_80_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80);
@@@ -549,23 -555,23 +611,42 @@@
  			he_rx_nss = rx_mcs_80;
  	}
  
++<<<<<<< HEAD
 +	if (sta->sta.ht_cap.ht_supported) {
 +		if (sta->sta.ht_cap.mcs.rx_mask[0])
 +			ht_rx_nss++;
 +		if (sta->sta.ht_cap.mcs.rx_mask[1])
 +			ht_rx_nss++;
 +		if (sta->sta.ht_cap.mcs.rx_mask[2])
 +			ht_rx_nss++;
 +		if (sta->sta.ht_cap.mcs.rx_mask[3])
++=======
+ 	if (sta->sta.link[link_id]->ht_cap.ht_supported) {
+ 		if (sta->sta.link[link_id]->ht_cap.mcs.rx_mask[0])
+ 			ht_rx_nss++;
+ 		if (sta->sta.link[link_id]->ht_cap.mcs.rx_mask[1])
+ 			ht_rx_nss++;
+ 		if (sta->sta.link[link_id]->ht_cap.mcs.rx_mask[2])
+ 			ht_rx_nss++;
+ 		if (sta->sta.link[link_id]->ht_cap.mcs.rx_mask[3])
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  			ht_rx_nss++;
  		/* FIXME: consider rx_highest? */
  	}
  
++<<<<<<< HEAD
 +	if (sta->sta.vht_cap.vht_supported) {
 +		int i;
 +		u16 rx_mcs_map;
 +
 +		rx_mcs_map = le16_to_cpu(sta->sta.vht_cap.vht_mcs.rx_mcs_map);
++=======
+ 	if (sta->sta.link[link_id]->vht_cap.vht_supported) {
+ 		int i;
+ 		u16 rx_mcs_map;
+ 
+ 		rx_mcs_map = le16_to_cpu(sta->sta.link[link_id]->vht_cap.vht_mcs.rx_mcs_map);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  
  		for (i = 7; i >= 0; i--) {
  			u8 mcs = (rx_mcs_map >> (2 * i)) & 3;
@@@ -581,7 -587,7 +662,11 @@@
  	rx_nss = max(vht_rx_nss, ht_rx_nss);
  	rx_nss = max(he_rx_nss, rx_nss);
  	rx_nss = max(eht_rx_nss, rx_nss);
++<<<<<<< HEAD
 +	sta->sta.rx_nss = max_t(u8, 1, rx_nss);
++=======
+ 	sta->sta.link[link_id]->rx_nss = max_t(u8, 1, rx_nss);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  }
  
  u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
@@@ -601,8 -607,8 +686,13 @@@
  	nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
  	nss += 1;
  
++<<<<<<< HEAD
 +	if (sta->sta.rx_nss != nss) {
 +		sta->sta.rx_nss = nss;
++=======
+ 	if (sta->sta.link[link_id]->rx_nss != nss) {
+ 		sta->sta.link[link_id]->rx_nss = nss;
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  		sta_opmode.rx_nss = nss;
  		changed |= IEEE80211_RC_NSS_CHANGED;
  		sta_opmode.changed |= STA_OPMODE_N_SS_CHANGED;
@@@ -611,28 -617,28 +701,53 @@@
  	switch (opmode & IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK) {
  	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ:
  		/* ignore IEEE80211_OPMODE_NOTIF_BW_160_80P80 must not be set */
++<<<<<<< HEAD
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_20;
 +		break;
 +	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ:
 +		/* ignore IEEE80211_OPMODE_NOTIF_BW_160_80P80 must not be set */
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_40;
 +		break;
 +	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ:
 +		if (opmode & IEEE80211_OPMODE_NOTIF_BW_160_80P80)
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +		else
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
 +		break;
 +	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ:
 +		/* legacy only, no longer used by newer spec */
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +		break;
 +	}
 +
 +	new_bw = ieee80211_sta_cur_vht_bw(sta);
 +	if (new_bw != sta->sta.bandwidth) {
 +		sta->sta.bandwidth = new_bw;
 +		sta_opmode.bw = ieee80211_sta_rx_bw_to_chan_width(sta);
++=======
+ 		sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_20;
+ 		break;
+ 	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ:
+ 		/* ignore IEEE80211_OPMODE_NOTIF_BW_160_80P80 must not be set */
+ 		sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_40;
+ 		break;
+ 	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ:
+ 		if (opmode & IEEE80211_OPMODE_NOTIF_BW_160_80P80)
+ 			sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
+ 		else
+ 			sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
+ 		break;
+ 	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ:
+ 		/* legacy only, no longer used by newer spec */
+ 		sta->link[link_id]->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
+ 		break;
+ 	}
+ 
+ 	new_bw = ieee80211_sta_cur_vht_bw(sta, link_id);
+ 	if (new_bw != sta->sta.link[link_id]->bandwidth) {
+ 		sta->sta.link[link_id]->bandwidth = new_bw;
+ 		sta_opmode.bw = ieee80211_sta_rx_bw_to_chan_width(sta, link_id);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  		changed |= IEEE80211_RC_BW_CHANGED;
  		sta_opmode.changed |= STA_OPMODE_MAX_BW_CHANGED;
  	}
@@@ -665,19 -672,19 +781,23 @@@ void ieee80211_process_mu_groups(struc
  	       mgmt->u.action.u.vht_group_notif.position,
  	       WLAN_USER_POSITION_LEN);
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_MU_GROUPS);
++=======
+ 	ieee80211_link_info_change_notify(sdata, link_id, BSS_CHANGED_MU_GROUPS);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  }
  
- void ieee80211_update_mu_groups(struct ieee80211_vif *vif,
+ void ieee80211_update_mu_groups(struct ieee80211_vif *vif, unsigned int link_id,
  				const u8 *membership, const u8 *position)
  {
- 	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+ 	struct ieee80211_bss_conf *link_conf = vif->link_conf[link_id];
  
- 	if (WARN_ON_ONCE(!vif->bss_conf.mu_mimo_owner))
+ 	if (WARN_ON_ONCE(!link_conf->mu_mimo_owner))
  		return;
  
- 	memcpy(bss_conf->mu_group.membership, membership, WLAN_MEMBERSHIP_LEN);
- 	memcpy(bss_conf->mu_group.position, position, WLAN_USER_POSITION_LEN);
+ 	memcpy(link_conf->mu_group.membership, membership, WLAN_MEMBERSHIP_LEN);
+ 	memcpy(link_conf->mu_group.position, position, WLAN_USER_POSITION_LEN);
  }
  EXPORT_SYMBOL_GPL(ieee80211_update_mu_groups);
  
@@@ -692,7 -700,7 +813,11 @@@ void ieee80211_vht_handle_opmode(struc
  
  	if (changed > 0) {
  		ieee80211_recalc_min_chandef(sdata);
++<<<<<<< HEAD
 +		rate_control_rate_update(local, sband, sta, changed);
++=======
+ 		rate_control_rate_update(local, sband, sta, link_id, changed);
++>>>>>>> afe0d181905e (wifi: mac80211: add link_id to vht.c code for MLO)
  	}
  }
  
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
index dd359df49b3f..17eaf30caf1f 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
@@ -1777,7 +1777,7 @@ static void iwl_mvm_mu_mimo_iface_iterator(void *_data, u8 *mac,
 		 * the data received from firmware as if it came from the
 		 * action frame, so no conversion is needed.
 		 */
-		ieee80211_update_mu_groups(vif,
+		ieee80211_update_mu_groups(vif, 0,
 					   (u8 *)&notif->membership_status,
 					   (u8 *)&notif->user_position);
 	}
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 7d4037ae5055..8de91c10e13e 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -6439,6 +6439,7 @@ ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
  * ieee80211_update_mu_groups - set the VHT MU-MIMO groud data
  *
  * @vif: the specified virtual interface
+ * @link_id: the link ID for MLO, otherwise 0
  * @membership: 64 bits array - a bit is set if station is member of the group
  * @position: 2 bits per group id indicating the position in the group
  *
@@ -6447,7 +6448,7 @@ ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
  * matching GroupId management frame.
  * Calls to this function need to be serialized with RX path.
  */
-void ieee80211_update_mu_groups(struct ieee80211_vif *vif,
+void ieee80211_update_mu_groups(struct ieee80211_vif *vif, unsigned int link_id,
 				const u8 *membership, const u8 *position);
 
 void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f7b5957d466a..80b51eeb93ad 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1743,7 +1743,7 @@ static int sta_apply_parameters(struct ieee80211_local *local,
 	/* VHT can override some HT caps such as the A-MSDU max length */
 	if (params->vht_capa)
 		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
-						    params->vht_capa, sta);
+						    params->vht_capa, sta, 0);
 
 	if (params->he_capa)
 		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
@@ -1764,7 +1764,8 @@ static int sta_apply_parameters(struct ieee80211_local *local,
 		/* returned value is only needed for rc update, but the
 		 * rc isn't initialized here yet, so ignore it
 		 */
-		__ieee80211_vht_handle_opmode(sdata, sta, params->opmode_notif,
+		__ieee80211_vht_handle_opmode(sdata, sta, 0,
+					      params->opmode_notif,
 					      sband->band);
 	}
 
* Unmerged path net/mac80211/ibss.c
* Unmerged path net/mac80211/ieee80211_i.h
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 2581d6c14d3a..e8c3f68f3eaf 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1401,14 +1401,14 @@ static void ieee80211_iface_process_skb(struct ieee80211_local *local,
 			sta = sta_info_get_bss(sdata, mgmt->sa);
 
 			if (sta)
-				ieee80211_vht_handle_opmode(sdata, sta, opmode,
-							    band);
+				ieee80211_vht_handle_opmode(sdata, sta, 0,
+							    opmode, band);
 
 			mutex_unlock(&local->sta_mtx);
 			break;
 		}
 		case WLAN_VHT_ACTION_GROUPID_MGMT:
-			ieee80211_process_mu_groups(sdata, mgmt);
+			ieee80211_process_mu_groups(sdata, 0, mgmt);
 			break;
 		default:
 			WARN_ON(1);
diff --git a/net/mac80211/mesh_plink.c b/net/mac80211/mesh_plink.c
index a829470dd59e..7fdf7afcc2bc 100644
--- a/net/mac80211/mesh_plink.c
+++ b/net/mac80211/mesh_plink.c
@@ -442,7 +442,7 @@ static void mesh_sta_info_init(struct ieee80211_sub_if_data *sdata,
 		changed |= IEEE80211_RC_BW_CHANGED;
 
 	ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
-					    elems->vht_cap_elem, sta);
+					    elems->vht_cap_elem, sta, 0);
 
 	ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband, elems->he_cap,
 					  elems->he_cap_len,
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index dbd8b816487b..c88ddbf2112a 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -3570,7 +3570,8 @@ static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
 
 	if (elems->vht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
-						    elems->vht_cap_elem, sta);
+						    elems->vht_cap_elem,
+						    sta, 0);
 
 	if (elems->he_operation && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
 	    elems->he_cap) {
@@ -4375,7 +4376,8 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
 	}
 
 	if (sta && elems->opmode_notif)
-		ieee80211_vht_handle_opmode(sdata, sta, *elems->opmode_notif,
+		ieee80211_vht_handle_opmode(sdata, sta, 0,
+					    *elems->opmode_notif,
 					    rx_status->band);
 	mutex_unlock(&local->sta_mtx);
 
diff --git a/net/mac80211/rate.c b/net/mac80211/rate.c
index 638474e631f4..91e63528c321 100644
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -37,7 +37,7 @@ void rate_control_rate_init(struct sta_info *sta)
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_chanctx_conf *chanctx_conf;
 
-	ieee80211_sta_set_rx_nss(sta);
+	ieee80211_sta_set_rx_nss(sta, 0);
 
 	if (!ref)
 		return;
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index a4a989695100..c0a28b9d400d 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -3399,7 +3399,7 @@ ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
 			rx->sta->sta.bandwidth = new_bw;
 			sband = rx->local->hw.wiphy->bands[status->band];
 			sta_opmode.bw =
-				ieee80211_sta_rx_bw_to_chan_width(rx->sta);
+				ieee80211_sta_rx_bw_to_chan_width(rx->sta, 0);
 			sta_opmode.changed = STA_OPMODE_MAX_BW_CHANGED;
 
 			rate_control_rate_update(local, sband, rx->sta,
diff --git a/net/mac80211/tdls.c b/net/mac80211/tdls.c
index 601011867929..614d16023508 100644
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@ -308,7 +308,7 @@ ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,
 	/* IEEE802.11ac-2013 Table E-4 */
 	u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };
 	struct cfg80211_chan_def uc = sta->tdls_chandef;
-	enum nl80211_chan_width max_width = ieee80211_sta_cap_chan_bw(sta);
+	enum nl80211_chan_width max_width = ieee80211_sta_cap_chan_bw(sta, 0);
 	int i;
 
 	/* only support upgrading non-narrow channels up to 80Mhz */
* Unmerged path net/mac80211/vht.c
