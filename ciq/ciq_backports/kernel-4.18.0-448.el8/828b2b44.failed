ipv4: Multipath hashing on inner L3 needs to consider inner IPv6 pkts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Stephen Suryaputra <ssuryaextr@gmail.com>
commit 828b2b442145cbe94fe3ca0e34a47f64b0f322ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/828b2b44.failed

Commit 363887a2cdfe ("ipv4: Support multipath hashing on inner IP pkts
for GRE tunnel") supports multipath policy value of 2, Layer 3 or inner
Layer 3 if present, but it only considers inner IPv4. There is a use
case of IPv6 is tunneled by IPv4 GRE, thus add the ability to hash on
inner IPv6 addresses.

Fixes: 363887a2cdfe ("ipv4: Support multipath hashing on inner IP pkts for GRE tunnel")
	Signed-off-by: Stephen Suryaputra <ssuryaextr@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 828b2b442145cbe94fe3ca0e34a47f64b0f322ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/route.c
diff --cc net/ipv4/route.c
index 5ad19572d74a,abaa7f9371e5..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1945,6 -1962,36 +1945,39 @@@ int fib_multipath_hash(const struct ne
  			hash_keys.basic.ip_proto = fl4->flowi4_proto;
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 	case 2:
+ 		memset(&hash_keys, 0, sizeof(hash_keys));
+ 		/* skb is currently provided only when forwarding */
+ 		if (skb) {
+ 			struct flow_keys keys;
+ 
+ 			skb_flow_dissect_flow_keys(skb, &keys, 0);
+ 			/* Inner can be v4 or v6 */
+ 			if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
+ 				hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 				hash_keys.addrs.v4addrs.src = keys.addrs.v4addrs.src;
+ 				hash_keys.addrs.v4addrs.dst = keys.addrs.v4addrs.dst;
+ 			} else if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {
+ 				hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+ 				hash_keys.addrs.v6addrs.src = keys.addrs.v6addrs.src;
+ 				hash_keys.addrs.v6addrs.dst = keys.addrs.v6addrs.dst;
+ 				hash_keys.tags.flow_label = keys.tags.flow_label;
+ 				hash_keys.basic.ip_proto = keys.basic.ip_proto;
+ 			} else {
+ 				/* Same as case 0 */
+ 				hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 				ip_multipath_l3_keys(skb, &hash_keys);
+ 			}
+ 		} else {
+ 			/* Same as case 0 */
+ 			hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 			hash_keys.addrs.v4addrs.src = fl4->saddr;
+ 			hash_keys.addrs.v4addrs.dst = fl4->daddr;
+ 		}
+ 		break;
++>>>>>>> 828b2b442145 (ipv4: Multipath hashing on inner L3 needs to consider inner IPv6 pkts)
  	}
  	mhash = flow_hash_from_keys(&hash_keys);
  
* Unmerged path net/ipv4/route.c
