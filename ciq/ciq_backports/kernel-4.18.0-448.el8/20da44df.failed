RDMA/mlx5: Drop in-driver verbs object creations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 20da44dfe8eff5b61685e394dec690a5d9dc36ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/20da44df.failed

There is no real value in bypassing IB/core APIs for creating standard
objects with standard types. The open-coded variant didn't have any
restrack task management calls and caused to such objects to be not
present when running rdmatoool.

Link: https://lore.kernel.org/r/f745590e5fb7d56f90fdb25f64ee3983ba17e1e4.1627040189.git.leonro@nvidia.com
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 20da44dfe8eff5b61685e394dec690a5d9dc36ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 6d2d441e7487,60dfc666d33a..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2809,23 -2802,13 +2809,21 @@@ static int mlx5_ib_dev_res_init(struct 
  	if (!MLX5_CAP_GEN(dev->mdev, xrc))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	mutex_init(&devr->mutex);
 +
 +	devr->p0 = rdma_zalloc_drv_obj(ibdev, ib_pd);
 +	if (!devr->p0)
 +		return -ENOMEM;
- 
- 	devr->p0->device  = ibdev;
- 	devr->p0->uobject = NULL;
- 	atomic_set(&devr->p0->usecnt, 0);
- 
- 	ret = mlx5_ib_alloc_pd(devr->p0, NULL);
- 	if (ret)
- 		goto error0;
- 
- 	devr->c0 = rdma_zalloc_drv_obj(ibdev, ib_cq);
- 	if (!devr->c0) {
- 		ret = -ENOMEM;
++=======
+ 	devr->p0 = ib_alloc_pd(ibdev, 0);
+ 	if (IS_ERR(devr->p0))
+ 		return PTR_ERR(devr->p0);
++>>>>>>> 20da44dfe8ef (RDMA/mlx5: Drop in-driver verbs object creations)
+ 
+ 	devr->c0 = ib_create_cq(ibdev, NULL, NULL, NULL, &cq_attr);
+ 	if (IS_ERR(devr->c0)) {
+ 		ret = PTR_ERR(devr->c0);
  		goto error1;
  	}
  
diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c
index 97b7d702a1a4..a9819c40a140 100644
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@ -1027,7 +1027,8 @@ struct ib_srq *ib_create_srq_user(struct ib_pd *pd,
 	}
 	if (srq->srq_type == IB_SRQT_XRC) {
 		srq->ext.xrc.xrcd = srq_init_attr->ext.xrc.xrcd;
-		atomic_inc(&srq->ext.xrc.xrcd->usecnt);
+		if (srq->ext.xrc.xrcd)
+			atomic_inc(&srq->ext.xrc.xrcd->usecnt);
 	}
 	atomic_inc(&pd->usecnt);
 
@@ -1038,7 +1039,7 @@ struct ib_srq *ib_create_srq_user(struct ib_pd *pd,
 	if (ret) {
 		rdma_restrack_put(&srq->res);
 		atomic_dec(&srq->pd->usecnt);
-		if (srq->srq_type == IB_SRQT_XRC)
+		if (srq->srq_type == IB_SRQT_XRC && srq->ext.xrc.xrcd)
 			atomic_dec(&srq->ext.xrc.xrcd->usecnt);
 		if (ib_srq_has_cq(srq->srq_type))
 			atomic_dec(&srq->ext.cq->usecnt);
@@ -1082,7 +1083,7 @@ int ib_destroy_srq_user(struct ib_srq *srq, struct ib_udata *udata)
 		return ret;
 
 	atomic_dec(&srq->pd->usecnt);
-	if (srq->srq_type == IB_SRQT_XRC)
+	if (srq->srq_type == IB_SRQT_XRC && srq->ext.xrc.xrcd)
 		atomic_dec(&srq->ext.xrc.xrcd->usecnt);
 	if (ib_srq_has_cq(srq->srq_type))
 		atomic_dec(&srq->ext.cq->usecnt);
* Unmerged path drivers/infiniband/hw/mlx5/main.c
