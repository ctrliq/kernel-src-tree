mm: proc: Invalidate TLB after clearing soft-dirty page state

jira LE-1907
cve CVE-2022-39188
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Will Deacon <will@kernel.org>
commit 912efa17e5121693dfbadae29768f4144a3f9e62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/912efa17.failed

Since commit 0758cd830494 ("asm-generic/tlb: avoid potential double
flush"), TLB invalidation is elided in tlb_finish_mmu() if no entries
were batched via the tlb_remove_*() functions. Consequently, the
page-table modifications performed by clear_refs_write() in response to
a write to /proc/<pid>/clear_refs do not perform TLB invalidation.
Although this is fine when simply aging the ptes, in the case of
clearing the "soft-dirty" state we can end up with entries where
pte_write() is false, yet a writable mapping remains in the TLB.

Fix this by avoiding the mmu_gather API altogether: managing both the
'tlb_flush_pending' flag on the 'mm_struct' and explicit TLB
invalidation for the sort-dirty path, much like mprotect() does already.

Fixes: 0758cd830494 ("asm-generic/tlb: avoid potential double flush‚Äù)
	Signed-off-by: Will Deacon <will@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Yu Zhao <yuzhao@google.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
Link: https://lkml.kernel.org/r/20210127235347.1402-2-will@kernel.org
(cherry picked from commit 912efa17e5121693dfbadae29768f4144a3f9e62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index 3945b2d54401,3cec6fbef725..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -1143,60 -1245,31 +1142,72 @@@ static ssize_t clear_refs_write(struct 
  			 * resident set size to this mm's current rss value.
  			 */
  			reset_mm_hiwater_rss(mm);
 -			goto out_unlock;
 +			mmap_write_unlock(mm);
 +			goto out_mm;
  		}
  
++<<<<<<< HEAD
 +		if (mmap_read_lock_killable(mm)) {
 +			count = -EINTR;
 +			goto out_mm;
 +		}
 +		tlb_gather_mmu(&tlb, mm, 0, -1);
++=======
++>>>>>>> 912efa17e512 (mm: proc: Invalidate TLB after clearing soft-dirty page state)
  		if (type == CLEAR_REFS_SOFT_DIRTY) {
  			for (vma = mm->mmap; vma; vma = vma->vm_next) {
  				if (!(vma->vm_flags & VM_SOFTDIRTY))
  					continue;
 -				vma->vm_flags &= ~VM_SOFTDIRTY;
 -				vma_set_page_prot(vma);
 +				mmap_read_unlock(mm);
 +				if (mmap_write_lock_killable(mm)) {
 +					count = -EINTR;
 +					goto out_mm;
 +				}
 +				/*
 +				 * Avoid to modify vma->vm_flags
 +				 * without locked ops while the
 +				 * coredump reads the vm_flags.
 +				 */
 +				if (!mmget_still_valid(mm)) {
 +					/*
 +					 * Silently return "count"
 +					 * like if get_task_mm()
 +					 * failed. FIXME: should this
 +					 * function have returned
 +					 * -ESRCH if get_task_mm()
 +					 * failed like if
 +					 * get_proc_task() fails?
 +					 */
 +					mmap_write_unlock(mm);
 +					goto out_mm;
 +				}
 +				for (vma = mm->mmap; vma; vma = vma->vm_next) {
 +					vma->vm_flags &= ~VM_SOFTDIRTY;
 +					vma_set_page_prot(vma);
 +				}
 +				mmap_write_downgrade(mm);
 +				break;
  			}
  
+ 			inc_tlb_flush_pending(mm);
  			mmu_notifier_range_init(&range, MMU_NOTIFY_SOFT_DIRTY,
  						0, NULL, mm, 0, -1UL);
  			mmu_notifier_invalidate_range_start(&range);
  		}
  		walk_page_range(mm, 0, mm->highest_vm_end, &clear_refs_walk_ops,
  				&cp);
- 		if (type == CLEAR_REFS_SOFT_DIRTY)
+ 		if (type == CLEAR_REFS_SOFT_DIRTY) {
  			mmu_notifier_invalidate_range_end(&range);
++<<<<<<< HEAD
 +		tlb_finish_mmu(&tlb, 0, -1);
 +		mmap_read_unlock(mm);
++=======
+ 			flush_tlb_mm(mm);
+ 			dec_tlb_flush_pending(mm);
+ 		}
+ out_unlock:
+ 		mmap_write_unlock(mm);
++>>>>>>> 912efa17e512 (mm: proc: Invalidate TLB after clearing soft-dirty page state)
  out_mm:
  		mmput(mm);
  	}
* Unmerged path fs/proc/task_mmu.c
