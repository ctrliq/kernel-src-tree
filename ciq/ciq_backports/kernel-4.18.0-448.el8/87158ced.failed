net/mlx5: Support enable_rdma devlink dev param

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Parav Pandit <parav@nvidia.com>
commit 87158cedf00ef225ae111dba96973b172086420e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/87158ced.failed

Enable user to disable RDMA auxiliary device so that when it is not
required, user can disable it.

For example,

$ devlink dev param set pci/0000:06:00.0 \
              name enable_rdma value false cmode driverinit
$ devlink dev reload pci/0000:06:00.0

At this point devlink instance do not create auxiliary device
mlx5_core.rdma.2 for the RDMA functionality.

	Signed-off-by: Parav Pandit <parav@nvidia.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 87158cedf00ef225ae111dba96973b172086420e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index 9dee693eb638,f247ffb325a9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -609,6 -596,115 +609,118 @@@ static void mlx5_devlink_set_params_ini
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ static const struct devlink_param enable_eth_param =
+ 	DEVLINK_PARAM_GENERIC(ENABLE_ETH, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, NULL);
+ 
+ static int mlx5_devlink_eth_param_register(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	union devlink_param_value value;
+ 	int err;
+ 
+ 	if (!mlx5_eth_supported(dev))
+ 		return 0;
+ 
+ 	err = devlink_param_register(devlink, &enable_eth_param);
+ 	if (err)
+ 		return err;
+ 
+ 	value.vbool = true;
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH,
+ 					   value);
+ 	devlink_param_publish(devlink, &enable_eth_param);
+ 	return 0;
+ }
+ 
+ static void mlx5_devlink_eth_param_unregister(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 
+ 	if (!mlx5_eth_supported(dev))
+ 		return;
+ 
+ 	devlink_param_unpublish(devlink, &enable_eth_param);
+ 	devlink_param_unregister(devlink, &enable_eth_param);
+ }
+ 
+ static int mlx5_devlink_enable_rdma_validate(struct devlink *devlink, u32 id,
+ 					     union devlink_param_value val,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	bool new_state = val.vbool;
+ 
+ 	if (new_state && !mlx5_rdma_supported(dev))
+ 		return -EOPNOTSUPP;
+ 	return 0;
+ }
+ 
+ static const struct devlink_param enable_rdma_param =
+ 	DEVLINK_PARAM_GENERIC(ENABLE_RDMA, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, mlx5_devlink_enable_rdma_validate);
+ 
+ static int mlx5_devlink_rdma_param_register(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	union devlink_param_value value;
+ 	int err;
+ 
+ 	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND) || MLX5_ESWITCH_MANAGER(dev))
+ 		return 0;
+ 
+ 	err = devlink_param_register(devlink, &enable_rdma_param);
+ 	if (err)
+ 		return err;
+ 
+ 	value.vbool = true;
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,
+ 					   value);
+ 	devlink_param_publish(devlink, &enable_rdma_param);
+ 	return 0;
+ }
+ 
+ static void mlx5_devlink_rdma_param_unregister(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 
+ 	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND) || MLX5_ESWITCH_MANAGER(dev))
+ 		return;
+ 
+ 	devlink_param_unpublish(devlink, &enable_rdma_param);
+ 	devlink_param_unregister(devlink, &enable_rdma_param);
+ }
+ 
+ static int mlx5_devlink_auxdev_params_register(struct devlink *devlink)
+ {
+ 	int err;
+ 
+ 	err = mlx5_devlink_eth_param_register(devlink);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5_devlink_rdma_param_register(devlink);
+ 	if (err)
+ 		goto rdma_err;
+ 
+ 	return 0;
+ 
+ rdma_err:
+ 	mlx5_devlink_eth_param_unregister(devlink);
+ 	return err;
+ }
+ 
+ static void mlx5_devlink_auxdev_params_unregister(struct devlink *devlink)
+ {
+ 	mlx5_devlink_rdma_param_unregister(devlink);
+ 	mlx5_devlink_eth_param_unregister(devlink);
+ }
+ 
++>>>>>>> 87158cedf00e (net/mlx5: Support enable_rdma devlink dev param)
  #define MLX5_TRAP_DROP(_id, _group_id)					\
  	DEVLINK_TRAP_GENERIC(DROP, DROP, _id,				\
  			     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id, \
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index ca6363198a67,e0eb6fd5378c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -277,4 -272,8 +277,11 @@@ static inline u32 mlx5_sriov_get_vf_tot
  
  	return MLX5_CAP_GEN_MAX(dev, num_total_dynamic_vf_msix);
  }
++<<<<<<< HEAD
++=======
+ 
+ bool mlx5_eth_supported(struct mlx5_core_dev *dev);
+ bool mlx5_rdma_supported(struct mlx5_core_dev *dev);
+ 
++>>>>>>> 87158cedf00e (net/mlx5: Support enable_rdma devlink dev param)
  #endif /* __MLX5_CORE_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/dev.c b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
index 20bb37266254..ab89a060d46a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/dev.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
@@ -170,7 +170,7 @@ static bool is_mp_supported(struct mlx5_core_dev *dev)
 	return true;
 }
 
-static bool is_ib_supported(struct mlx5_core_dev *dev)
+bool mlx5_rdma_supported(struct mlx5_core_dev *dev)
 {
 	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))
 		return false;
@@ -187,6 +187,17 @@ static bool is_ib_supported(struct mlx5_core_dev *dev)
 	return true;
 }
 
+static bool is_ib_enabled(struct mlx5_core_dev *dev)
+{
+	union devlink_param_value val;
+	int err;
+
+	err = devlink_param_driverinit_value_get(priv_to_devlink(dev),
+						 DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,
+						 &val);
+	return err ? false : val.vbool;
+}
+
 enum {
 	MLX5_INTERFACE_PROTOCOL_ETH,
 	MLX5_INTERFACE_PROTOCOL_ETH_REP,
@@ -205,7 +216,8 @@ static const struct mlx5_adev_device {
 	[MLX5_INTERFACE_PROTOCOL_VNET] = { .suffix = "vnet",
 					   .is_supported = &is_vnet_supported },
 	[MLX5_INTERFACE_PROTOCOL_IB] = { .suffix = "rdma",
-					 .is_supported = &is_ib_supported },
+					 .is_supported = &mlx5_rdma_supported,
+					 .is_enabled = &is_ib_enabled },
 	[MLX5_INTERFACE_PROTOCOL_ETH] = { .suffix = "eth",
 					  .is_supported = &is_eth_supported },
 	[MLX5_INTERFACE_PROTOCOL_ETH_REP] = { .suffix = "eth-rep",
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
