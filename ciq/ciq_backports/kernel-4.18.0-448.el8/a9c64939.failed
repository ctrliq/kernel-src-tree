net/sched: act_skbedit: Add extack messages for offload failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ido Schimmel <idosch@nvidia.com>
commit a9c64939b669b3c83cc54738d1986430e6beaff2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a9c64939.failed

For better error reporting to user space, add extack messages when
skbedit action offload fails.

Example:

 # echo 1 > /sys/kernel/tracing/events/netlink/netlink_extack/enable

 # tc filter add dev dummy0 ingress pref 1 proto all matchall skip_sw action skbedit queue_mapping 1234
 Error: cls_matchall: Failed to setup flow action.
 We have an error talking to the kernel

 # cat /sys/kernel/tracing/trace_pipe
       tc-185     [002] b..1.    31.802414: netlink_extack: msg=act_skbedit: Offload not supported when "queue_mapping" option is used
       tc-185     [002] .....    31.802418: netlink_extack: msg=cls_matchall: Failed to setup flow action

 # tc filter add dev dummy0 ingress pref 1 proto all matchall skip_sw action skbedit inheritdsfield
 Error: cls_matchall: Failed to setup flow action.
 We have an error talking to the kernel

 # cat /sys/kernel/tracing/trace_pipe
       tc-187     [002] b..1.    45.985145: netlink_extack: msg=act_skbedit: Offload not supported when "inheritdsfield" option is used
       tc-187     [002] .....    45.985160: netlink_extack: msg=cls_matchall: Failed to setup flow action

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: Petr Machata <petrm@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a9c64939b669b3c83cc54738d1986430e6beaff2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_skbedit.c
diff --cc net/sched/act_skbedit.c
index 15e1b9646bf0,92d0dc754207..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -338,6 -327,49 +338,52 @@@ static size_t tcf_skbedit_get_fill_size
  		+ nla_total_size_64bit(sizeof(u64)); /* TCA_SKBEDIT_FLAGS */
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_skbedit_offload_act_setup(struct tc_action *act, void *entry_data,
+ 					 u32 *index_inc, bool bind,
+ 					 struct netlink_ext_ack *extack)
+ {
+ 	if (bind) {
+ 		struct flow_action_entry *entry = entry_data;
+ 
+ 		if (is_tcf_skbedit_mark(act)) {
+ 			entry->id = FLOW_ACTION_MARK;
+ 			entry->mark = tcf_skbedit_mark(act);
+ 		} else if (is_tcf_skbedit_ptype(act)) {
+ 			entry->id = FLOW_ACTION_PTYPE;
+ 			entry->ptype = tcf_skbedit_ptype(act);
+ 		} else if (is_tcf_skbedit_priority(act)) {
+ 			entry->id = FLOW_ACTION_PRIORITY;
+ 			entry->priority = tcf_skbedit_priority(act);
+ 		} else if (is_tcf_skbedit_queue_mapping(act)) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Offload not supported when \"queue_mapping\" option is used");
+ 			return -EOPNOTSUPP;
+ 		} else if (is_tcf_skbedit_inheritdsfield(act)) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Offload not supported when \"inheritdsfield\" option is used");
+ 			return -EOPNOTSUPP;
+ 		} else {
+ 			NL_SET_ERR_MSG_MOD(extack, "Unsupported skbedit option offload");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		*index_inc = 1;
+ 	} else {
+ 		struct flow_offload_action *fl_action = entry_data;
+ 
+ 		if (is_tcf_skbedit_mark(act))
+ 			fl_action->id = FLOW_ACTION_MARK;
+ 		else if (is_tcf_skbedit_ptype(act))
+ 			fl_action->id = FLOW_ACTION_PTYPE;
+ 		else if (is_tcf_skbedit_priority(act))
+ 			fl_action->id = FLOW_ACTION_PRIORITY;
+ 		else
+ 			return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a9c64939b669 (net/sched: act_skbedit: Add extack messages for offload failure)
  static struct tc_action_ops act_skbedit_ops = {
  	.kind		=	"skbedit",
  	.id		=	TCA_ID_SKBEDIT,
diff --git a/include/net/tc_act/tc_skbedit.h b/include/net/tc_act/tc_skbedit.h
index ffc432e426ef..7c82693134de 100644
--- a/include/net/tc_act/tc_skbedit.h
+++ b/include/net/tc_act/tc_skbedit.h
@@ -105,4 +105,16 @@ static inline u32 tcf_skbedit_priority(const struct tc_action *a)
 	return priority;
 }
 
+/* Return true iff action is queue_mapping */
+static inline bool is_tcf_skbedit_queue_mapping(const struct tc_action *a)
+{
+	return is_tcf_skbedit_with_flag(a, SKBEDIT_F_QUEUE_MAPPING);
+}
+
+/* Return true iff action is inheritdsfield */
+static inline bool is_tcf_skbedit_inheritdsfield(const struct tc_action *a)
+{
+	return is_tcf_skbedit_with_flag(a, SKBEDIT_F_INHERITDSFIELD);
+}
+
 #endif /* __NET_TC_SKBEDIT_H */
* Unmerged path net/sched/act_skbedit.c
