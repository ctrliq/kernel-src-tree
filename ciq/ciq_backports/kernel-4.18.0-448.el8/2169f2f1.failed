ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Simon Trimmer <simont@opensource.cirrus.com>
commit 2169f2f15185f9393b1c16eac6e7c7d4adb6279b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2169f2f1.failed

As preparation for moving the generic DSP support out of ASoC pass the
firmware names used when loading files as parameters as the generic code
can't refer directly to the array specific to wm_adsp. The code
remaining in wm_adsp.c doesn't need to change, it can continue to use
the string arrays directly.

	Signed-off-by: Simon Trimmer <simont@opensource.cirrus.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20210913160057.103842-13-simont@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 2169f2f15185f9393b1c16eac6e7c7d4adb6279b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
diff --cc sound/soc/codecs/wm_adsp.c
index c1b5ea3b5718,c2e1eb8ff357..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -1417,22 -1413,12 +1417,22 @@@ static int wm_adsp_create_control(struc
  	const char *region_name;
  	int ret;
  
 -	if (cs_ctl->flags & WMFW_CTL_FLAG_SYS)
 -		return 0;
 +	list_for_each_entry(ctl, &dsp->ctl_list, list) {
- 		if (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&
++		if (ctl->fw_name == dsp->fw_name &&
 +		    ctl->alg_region.alg == alg_region->alg &&
 +		    ctl->alg_region.type == alg_region->type) {
 +			if ((!subname && !ctl->subname) ||
 +			    (subname && !strncmp(ctl->subname, subname, ctl->subname_len))) {
 +				if (!ctl->enabled)
 +					ctl->enabled = 1;
 +				return 0;
 +			}
 +		}
 +	}
  
 -	region_name = cs_dsp_mem_region_name(cs_ctl->alg_region.type);
 +	region_name = wm_adsp_mem_region_name(alg_region->type);
  	if (!region_name) {
 -		adsp_err(dsp, "Unknown region type: %d\n", cs_ctl->alg_region.type);
 +		adsp_err(dsp, "Unknown region type: %d\n", alg_region->type);
  		return -EINVAL;
  	}
  
@@@ -1473,8 -1458,8 +1473,9 @@@
  	ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);
  	if (!ctl)
  		return -ENOMEM;
- 	ctl->fw_name = wm_adsp_fw_text[dsp->fw];
 -	ctl->cs_ctl = cs_ctl;
+ 
++	ctl->fw_name = dsp->fw_name;
 +	ctl->alg_region = *alg_region;
  	ctl->name = kmemdup(name, strlen(name) + 1, GFP_KERNEL);
  	if (!ctl->name) {
  		ret = -ENOMEM;
@@@ -1801,7 -1837,7 +1802,11 @@@ static bool wm_halo_validate_version(st
  	}
  }
  
++<<<<<<< HEAD
 +static int wm_adsp_load(struct wm_adsp *dsp)
++=======
+ static int cs_dsp_load(struct wm_adsp *dsp, const char *fw_file_name)
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  {
  	LIST_HEAD(buf_list);
  	const struct firmware *firmware;
@@@ -2004,15 -2040,14 +2009,19 @@@ out
  }
  
  /*
 - * Find cs_dsp_coeff_ctl with input name as its subname
 + * Find wm_coeff_ctl with input name as its subname
   * If not found, return NULL
   */
 -static struct cs_dsp_coeff_ctl *cs_dsp_get_ctl(struct wm_adsp *dsp,
 -					       const char *name, int type,
 -					       unsigned int alg)
 -{
 +static struct wm_coeff_ctl *wm_adsp_get_ctl(struct wm_adsp *dsp,
 +					     const char *name, int type,
 +					     unsigned int alg)
 +{
++<<<<<<< HEAD
 +	struct wm_coeff_ctl *pos, *rslt = NULL;
 +	const char *fw_txt = wm_adsp_fw_text[dsp->fw];
++=======
+ 	struct cs_dsp_coeff_ctl *pos, *rslt = NULL;
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  
  	list_for_each_entry(pos, &dsp->ctl_list, list) {
  		if (!pos->subname)
@@@ -2087,13 -2125,13 +2096,13 @@@ int wm_adsp_read_ctl(struct wm_adsp *ds
  }
  EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
  
 -static void cs_dsp_ctl_fixup_base(struct wm_adsp *dsp,
 -				  const struct cs_dsp_alg_region *alg_region)
 +static void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,
 +				  const struct wm_adsp_alg_region *alg_region)
  {
 -	struct cs_dsp_coeff_ctl *ctl;
 +	struct wm_coeff_ctl *ctl;
  
  	list_for_each_entry(ctl, &dsp->ctl_list, list) {
- 		if (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&
+ 		if (ctl->fw_name == dsp->fw_name &&
  		    alg_region->alg == ctl->alg_region.alg &&
  		    alg_region->type == ctl->alg_region.type) {
  			ctl->alg_region.base = alg_region->base;
@@@ -2544,7 -2582,7 +2553,11 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int wm_adsp_load_coeff(struct wm_adsp *dsp)
++=======
+ static int cs_dsp_load_coeff(struct wm_adsp *dsp, const char *fw_file_name)
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  {
  	LIST_HEAD(buf_list);
  	struct regmap *regmap = dsp->regmap;
@@@ -2788,107 -2837,71 +2801,152 @@@ int wm_adsp1_init(struct wm_adsp *dsp
  }
  EXPORT_SYMBOL_GPL(wm_adsp1_init);
  
++<<<<<<< HEAD
 +int wm_adsp1_event(struct snd_soc_dapm_widget *w,
 +		   struct snd_kcontrol *kcontrol,
 +		   int event)
++=======
+ static int cs_dsp_adsp1_power_up(struct wm_adsp *dsp, const char *fw_file_name, const char *fw_name)
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  {
 -	unsigned int val;
 +	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 +	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 +	struct wm_adsp *dsp = &dsps[w->shift];
 +	struct wm_coeff_ctl *ctl;
  	int ret;
 +	unsigned int val;
 +
 +	dsp->component = component;
  
  	mutex_lock(&dsp->pwr_lock);
  
++<<<<<<< HEAD
 +	switch (event) {
 +	case SND_SOC_DAPM_POST_PMU:
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
++=======
+ 	dsp->fw_name = fw_name;
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  
 -	/*
 -	 * For simplicity set the DSP clock rate to be the
 -	 * SYSCLK rate rather than making it configurable.
 -	 */
 -	if (dsp->sysclk_reg) {
 -		ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
 -		if (ret != 0) {
 -			cs_dsp_err(dsp, "Failed to read SYSCLK state: %d\n", ret);
 -			goto err_mutex;
 -		}
 +		/*
 +		 * For simplicity set the DSP clock rate to be the
 +		 * SYSCLK rate rather than making it configurable.
 +		 */
 +		if (dsp->sysclk_reg) {
 +			ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Failed to read SYSCLK state: %d\n",
 +				ret);
 +				goto err_mutex;
 +			}
  
 -		val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
 +			val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
  
 -		ret = regmap_update_bits(dsp->regmap,
 -					 dsp->base + ADSP1_CONTROL_31,
 -					 ADSP1_CLK_SEL_MASK, val);
 -		if (ret != 0) {
 -			cs_dsp_err(dsp, "Failed to set clock rate: %d\n", ret);
 -			goto err_mutex;
 +			ret = regmap_update_bits(dsp->regmap,
 +						 dsp->base + ADSP1_CONTROL_31,
 +						 ADSP1_CLK_SEL_MASK, val);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Failed to set clock rate: %d\n",
 +					 ret);
 +				goto err_mutex;
 +			}
  		}
 +
 +		ret = wm_adsp_load(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		ret = wm_adsp1_setup_algs(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		ret = wm_adsp_load_coeff(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		/* Initialize caches for enabled and unset controls */
 +		ret = wm_coeff_init_control_caches(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		/* Sync set controls */
 +		ret = wm_coeff_sync_controls(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		dsp->booted = true;
 +
 +		/* Start the core running */
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_CORE_ENA | ADSP1_START,
 +				   ADSP1_CORE_ENA | ADSP1_START);
 +
 +		dsp->running = true;
 +		break;
 +
 +	case SND_SOC_DAPM_PRE_PMD:
 +		dsp->running = false;
 +		dsp->booted = false;
 +
 +		/* Halt the core */
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_CORE_ENA | ADSP1_START, 0);
 +
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
 +				   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
 +
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_SYS_ENA, 0);
 +
 +		list_for_each_entry(ctl, &dsp->ctl_list, list)
 +			ctl->enabled = 0;
 +
 +
 +		wm_adsp_free_alg_regions(dsp);
 +		break;
 +
 +	default:
 +		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	ret = cs_dsp_load(dsp, fw_file_name);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_adsp1_setup_algs(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_load_coeff(dsp, fw_file_name);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Initialize caches for enabled and unset controls */
+ 	ret = cs_dsp_coeff_init_control_caches(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Sync set controls */
+ 	ret = cs_dsp_coeff_sync_controls(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	dsp->booted = true;
+ 
+ 	/* Start the core running */
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_CORE_ENA | ADSP1_START,
+ 			   ADSP1_CORE_ENA | ADSP1_START);
+ 
+ 	dsp->running = true;
+ 
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  	mutex_unlock(&dsp->pwr_lock);
  
  	return 0;
@@@ -2898,6 -2911,59 +2956,62 @@@ err_ena
  			   ADSP1_SYS_ENA, 0);
  err_mutex:
  	mutex_unlock(&dsp->pwr_lock);
++<<<<<<< HEAD
++=======
+ 	return ret;
+ }
+ 
+ static void cs_dsp_adsp1_power_down(struct wm_adsp *dsp)
+ {
+ 	struct cs_dsp_coeff_ctl *ctl;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	dsp->running = false;
+ 	dsp->booted = false;
+ 
+ 	/* Halt the core */
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_CORE_ENA | ADSP1_START, 0);
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
+ 			   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_SYS_ENA, 0);
+ 
+ 	list_for_each_entry(ctl, &dsp->ctl_list, list)
+ 		ctl->enabled = 0;
+ 
+ 	cs_dsp_free_alg_regions(dsp);
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ }
+ 
+ int wm_adsp1_event(struct snd_soc_dapm_widget *w,
+ 		   struct snd_kcontrol *kcontrol,
+ 		   int event)
+ {
+ 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+ 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
+ 	struct wm_adsp *dsp = &dsps[w->shift];
+ 	int ret = 0;
+ 
+ 	dsp->component = component;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		ret = cs_dsp_adsp1_power_up(dsp,
+ 					    wm_adsp_fw[dsp->fw].file,
+ 					    wm_adsp_fw_text[dsp->fw]);
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		cs_dsp_adsp1_power_down(dsp);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  
  	return ret;
  }
@@@ -3161,6 -3176,100 +3275,103 @@@ static void wm_halo_stop_watchdog(struc
  			   HALO_WDT_EN_MASK, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void cs_dsp_power_up(struct wm_adsp *dsp, const char *fw_file_name,
+ 			    const char *fw_name)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	dsp->fw_name = fw_name;
+ 
+ 	if (dsp->ops->enable_memory) {
+ 		ret = dsp->ops->enable_memory(dsp);
+ 		if (ret != 0)
+ 			goto err_mutex;
+ 	}
+ 
+ 	if (dsp->ops->enable_core) {
+ 		ret = dsp->ops->enable_core(dsp);
+ 		if (ret != 0)
+ 			goto err_mem;
+ 	}
+ 
+ 	ret = cs_dsp_load(dsp, fw_file_name);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = dsp->ops->setup_algs(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_load_coeff(dsp, fw_file_name);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Initialize caches for enabled and unset controls */
+ 	ret = cs_dsp_coeff_init_control_caches(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	if (dsp->ops->disable_core)
+ 		dsp->ops->disable_core(dsp);
+ 
+ 	dsp->booted = true;
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	return;
+ 
+ err_ena:
+ 	if (dsp->ops->disable_core)
+ 		dsp->ops->disable_core(dsp);
+ err_mem:
+ 	if (dsp->ops->disable_memory)
+ 		dsp->ops->disable_memory(dsp);
+ err_mutex:
+ 	mutex_unlock(&dsp->pwr_lock);
+ }
+ 
+ static void cs_dsp_power_down(struct wm_adsp *dsp)
+ {
+ 	struct cs_dsp_coeff_ctl *ctl;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	cs_dsp_debugfs_clear(dsp);
+ 
+ 	dsp->fw_id = 0;
+ 	dsp->fw_id_version = 0;
+ 
+ 	dsp->booted = false;
+ 
+ 	if (dsp->ops->disable_memory)
+ 		dsp->ops->disable_memory(dsp);
+ 
+ 	list_for_each_entry(ctl, &dsp->ctl_list, list)
+ 		ctl->enabled = 0;
+ 
+ 	cs_dsp_free_alg_regions(dsp);
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	cs_dsp_dbg(dsp, "Shutdown complete\n");
+ }
+ 
+ static void wm_adsp_boot_work(struct work_struct *work)
+ {
+ 	struct wm_adsp *dsp = container_of(work,
+ 					   struct wm_adsp,
+ 					   boot_work);
+ 
+ 	cs_dsp_power_up(dsp,
+ 			wm_adsp_fw[dsp->fw].file,
+ 			wm_adsp_fw_text[dsp->fw]);
+ }
+ 
++>>>>>>> 2169f2f15185 (ASoC: wm_adsp: Pass firmware names as parameters when starting DSP core)
  int wm_adsp_early_event(struct snd_soc_dapm_widget *w,
  			struct snd_kcontrol *kcontrol, int event)
  {
* Unmerged path sound/soc/codecs/wm_adsp.c
diff --git a/sound/soc/codecs/wm_adsp.h b/sound/soc/codecs/wm_adsp.h
index f22131d9cc29..5b716b889a0c 100644
--- a/sound/soc/codecs/wm_adsp.h
+++ b/sound/soc/codecs/wm_adsp.h
@@ -74,6 +74,7 @@ struct wm_adsp {
 
 	struct list_head alg_regions;
 
+	const char *fw_name;
 	unsigned int fw_id;
 	unsigned int fw_id_version;
 	unsigned int fw_vendor_id;
