iommu/vt-d: Fix kdump kernels boot failure with scalable mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 0c5f6c0d8201a809a6585b07b6263e9db2c874a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0c5f6c0d.failed

The translation table copying code for kdump kernels is currently based
on the extended root/context entry formats of ECS mode defined in older
VT-d v2.5, and doesn't handle the scalable mode formats. This causes
the kexec capture kernel boot failure with DMAR faults if the IOMMU was
enabled in scalable mode by the previous kernel.

The ECS mode has already been deprecated by the VT-d spec since v3.0 and
Intel IOMMU driver doesn't support this mode as there's no real hardware
implementation. Hence this converts ECS checking in copying table code
into scalable mode.

The existing copying code consumes a bit in the context entry as a mark
of copied entry. It needs to work for the old format as well as for the
extended context entries. As it's hard to find such a common bit for both
legacy and scalable mode context entries. This replaces it with a per-
IOMMU bitmap.

Fixes: 7373a8cc38197 ("iommu/vt-d: Setup context and enable RID2PASID support")
	Cc: stable@vger.kernel.org
	Reported-by: Jerry Snitselaar <jsnitsel@redhat.com>
	Tested-by: Wen Jin <wen.jin@intel.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20220817011035.3250131-1-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 0c5f6c0d8201a809a6585b07b6263e9db2c874a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel/iommu.c
#	include/linux/intel-iommu.h
diff --cc drivers/iommu/intel/iommu.c
index 0da3626cffb5,b9d058c27568..000000000000
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@@ -1994,7 -1683,10 +1989,14 @@@ static void free_dmar_iommu(struct inte
  		iommu->domain_ids = NULL;
  	}
  
++<<<<<<< HEAD
 +	g_iommus[iommu->seq_id] = NULL;
++=======
+ 	if (iommu->copied_tables) {
+ 		bitmap_free(iommu->copied_tables);
+ 		iommu->copied_tables = NULL;
+ 	}
++>>>>>>> 0c5f6c0d8201 (iommu/vt-d: Fix kdump kernels boot failure with scalable mode)
  
  	/* free context mapping */
  	free_context_table(iommu);
diff --cc include/linux/intel-iommu.h
index 7782dcefe6a9,74b0e19e23ee..000000000000
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@@ -602,7 -577,7 +600,11 @@@ struct intel_iommu 
  
  #ifdef CONFIG_INTEL_IOMMU
  	unsigned long 	*domain_ids; /* bitmap of domains */
++<<<<<<< HEAD:include/linux/intel-iommu.h
 +	struct dmar_domain ***domains; /* ptr to domains */
++=======
+ 	unsigned long	*copied_tables; /* bitmap of copied tables */
++>>>>>>> 0c5f6c0d8201 (iommu/vt-d: Fix kdump kernels boot failure with scalable mode):drivers/iommu/intel/iommu.h
  	spinlock_t	lock; /* protect context, domain ids */
  	struct root_entry *root_entry; /* virtual address */
  
* Unmerged path drivers/iommu/intel/iommu.c
* Unmerged path include/linux/intel-iommu.h
