gve: Add optional metadata descriptor type GVE_TXD_MTD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Willem de Bruijn <willemb@google.com>
commit 497dbb2b97a0642ecd478d441643bf26804d5f96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/497dbb2b.failed

Allow drivers to pass metadata along with packet data to the device.
Introduce a new metadata descriptor type

* GVE_TXD_MTD

This descriptor is optional. If present it immediate follows the
packet descriptor and precedes the segment descriptor.

This descriptor may be repeated. Multiple metadata descriptors may
follow. There are no immediate uses for this, this is for future
proofing. At present devices allow only 1 MTD descriptor.

The lower four bits of the type_flags field encode GVE_TXD_MTD.
The upper four bits of the type_flags field encodes a *sub*type.

Introduce one such metadata descriptor subtype

* GVE_MTD_SUBTYPE_PATH

This shares path information with the device for network failure
discovery and robust response:

Linux derives ipv6 flowlabel and ECMP multipath from sk->sk_txhash,
and updates this field on error with sk_rethink_txhash. Allow the host
stack to do the same. Pass the tx_hash value if set. Also communicate
whether the path hash is set, or more exactly, what its type is. Define
two common types

  GVE_MTD_PATH_HASH_NONE
  GVE_MTD_PATH_HASH_L4

Concrete examples of error conditions that are resolved are
mentioned in the commits that add sk_rethink_txhash calls. Such as
commit 7788174e8726 ("tcp: change IPv6 flow-label upon receiving
spurious retransmission").

Experimental results mirror what the theory suggests: where IPv6
FlowLabel is included in path selection (e.g., LAG/ECMP), flowlabel
rotation on TCP timeout avoids the vast majority of TCP disconnects
that would otherwise have occurred during link failures in long-haul
backbones, when an alternative path is available.

Rotation can be applied to various bad connection signals, such as
timeouts and spurious retransmissions. In aggregate, such flow level
signals can help locate network issues. Define initial common states:

  GVE_MTD_PATH_STATE_DEFAULT
  GVE_MTD_PATH_STATE_TIMEOUT
  GVE_MTD_PATH_STATE_CONGESTION
  GVE_MTD_PATH_STATE_RETRANSMIT

	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David Awogbemila <awogbemila@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 497dbb2b97a0642ecd478d441643bf26804d5f96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/google/gve/gve_tx.c
diff --cc drivers/net/ethernet/google/gve/gve_tx.c
index 6559c232a86a,4888bf05fbed..000000000000
--- a/drivers/net/ethernet/google/gve/gve_tx.c
+++ b/drivers/net/ethernet/google/gve/gve_tx.c
@@@ -284,11 -296,28 +284,36 @@@ static inline int gve_skb_fifo_bytes_re
  	return bytes;
  }
  
++<<<<<<< HEAD
 +/* The most descriptors we could need are 3 - 1 for the headers, 1 for
 + * the beginning of the payload at the end of the FIFO, and 1 if the
 + * payload wraps to the beginning of the FIFO.
 + */
 +#define MAX_TX_DESC_NEEDED	3
++=======
+ /* The most descriptors we could need is MAX_SKB_FRAGS + 4 :
+  * 1 for each skb frag
+  * 1 for the skb linear portion
+  * 1 for when tcp hdr needs to be in separate descriptor
+  * 1 if the payload wraps to the beginning of the FIFO
+  * 1 for metadata descriptor
+  */
+ #define MAX_TX_DESC_NEEDED	(MAX_SKB_FRAGS + 4)
+ static void gve_tx_unmap_buf(struct device *dev, struct gve_tx_buffer_state *info)
+ {
+ 	if (info->skb) {
+ 		dma_unmap_single(dev, dma_unmap_addr(info, dma),
+ 				 dma_unmap_len(info, len),
+ 				 DMA_TO_DEVICE);
+ 		dma_unmap_len_set(info, len, 0);
+ 	} else {
+ 		dma_unmap_page(dev, dma_unmap_addr(info, dma),
+ 			       dma_unmap_len(info, len),
+ 			       DMA_TO_DEVICE);
+ 		dma_unmap_len_set(info, len, 0);
+ 	}
+ }
++>>>>>>> 497dbb2b97a0 (gve: Add optional metadata descriptor type GVE_TXD_MTD)
  
  /* Check if sufficient resources (descriptor ring space, FIFO space) are
   * available to transmit the given number of bytes.
@@@ -452,9 -507,105 +496,108 @@@ static int gve_tx_add_skb(struct gve_tx
  		copy_offset += info->iov[i].iov_len;
  	}
  
- 	return 1 + payload_nfrags;
+ 	return 1 + mtd_desc_nr + payload_nfrags;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int gve_tx_add_skb_no_copy(struct gve_priv *priv, struct gve_tx_ring *tx,
+ 				  struct sk_buff *skb)
+ {
+ 	const struct skb_shared_info *shinfo = skb_shinfo(skb);
+ 	int hlen, num_descriptors, l4_hdr_offset;
+ 	union gve_tx_desc *pkt_desc, *mtd_desc, *seg_desc;
+ 	struct gve_tx_buffer_state *info;
+ 	int mtd_desc_nr = !!skb->l4_hash;
+ 	bool is_gso = skb_is_gso(skb);
+ 	u32 idx = tx->req & tx->mask;
+ 	u64 addr;
+ 	u32 len;
+ 	int i;
+ 
+ 	info = &tx->info[idx];
+ 	pkt_desc = &tx->desc[idx];
+ 
+ 	l4_hdr_offset = skb_checksum_start_offset(skb);
+ 	/* If the skb is gso, then we want only up to the tcp header in the first segment
+ 	 * to efficiently replicate on each segment otherwise we want the linear portion
+ 	 * of the skb (which will contain the checksum because skb->csum_start and
+ 	 * skb->csum_offset are given relative to skb->head) in the first segment.
+ 	 */
+ 	hlen = is_gso ? l4_hdr_offset + tcp_hdrlen(skb) : skb_headlen(skb);
+ 	len = skb_headlen(skb);
+ 
+ 	info->skb =  skb;
+ 
+ 	addr = dma_map_single(tx->dev, skb->data, len, DMA_TO_DEVICE);
+ 	if (unlikely(dma_mapping_error(tx->dev, addr))) {
+ 		tx->dma_mapping_error++;
+ 		goto drop;
+ 	}
+ 	dma_unmap_len_set(info, len, len);
+ 	dma_unmap_addr_set(info, dma, addr);
+ 
+ 	num_descriptors = 1 + shinfo->nr_frags;
+ 	if (hlen < len)
+ 		num_descriptors++;
+ 	if (mtd_desc_nr)
+ 		num_descriptors++;
+ 
+ 	gve_tx_fill_pkt_desc(pkt_desc, skb, is_gso, l4_hdr_offset,
+ 			     num_descriptors, hlen, addr);
+ 
+ 	if (mtd_desc_nr) {
+ 		idx = (idx + 1) & tx->mask;
+ 		mtd_desc = &tx->desc[idx];
+ 		gve_tx_fill_mtd_desc(mtd_desc, skb);
+ 	}
+ 
+ 	if (hlen < len) {
+ 		/* For gso the rest of the linear portion of the skb needs to
+ 		 * be in its own descriptor.
+ 		 */
+ 		len -= hlen;
+ 		addr += hlen;
+ 		idx = (idx + 1) & tx->mask;
+ 		seg_desc = &tx->desc[idx];
+ 		gve_tx_fill_seg_desc(seg_desc, skb, is_gso, len, addr);
+ 	}
+ 
+ 	for (i = 0; i < shinfo->nr_frags; i++) {
+ 		const skb_frag_t *frag = &shinfo->frags[i];
+ 
+ 		idx = (idx + 1) & tx->mask;
+ 		seg_desc = &tx->desc[idx];
+ 		len = skb_frag_size(frag);
+ 		addr = skb_frag_dma_map(tx->dev, frag, 0, len, DMA_TO_DEVICE);
+ 		if (unlikely(dma_mapping_error(tx->dev, addr))) {
+ 			tx->dma_mapping_error++;
+ 			goto unmap_drop;
+ 		}
+ 		tx->info[idx].skb = NULL;
+ 		dma_unmap_len_set(&tx->info[idx], len, len);
+ 		dma_unmap_addr_set(&tx->info[idx], dma, addr);
+ 
+ 		gve_tx_fill_seg_desc(seg_desc, skb, is_gso, len, addr);
+ 	}
+ 
+ 	return num_descriptors;
+ 
+ unmap_drop:
+ 	i += num_descriptors - shinfo->nr_frags;
+ 	while (i--) {
+ 		/* Skip metadata descriptor, if set */
+ 		if (i == 1 && mtd_desc_nr == 1)
+ 			continue;
+ 		idx--;
+ 		gve_tx_unmap_buf(tx->dev, &tx->info[idx & tx->mask]);
+ 	}
+ drop:
+ 	tx->dropped_pkt++;
+ 	return 0;
  }
  
++>>>>>>> 497dbb2b97a0 (gve: Add optional metadata descriptor type GVE_TXD_MTD)
  netdev_tx_t gve_tx(struct sk_buff *skb, struct net_device *dev)
  {
  	struct gve_priv *priv = netdev_priv(dev);
diff --git a/drivers/net/ethernet/google/gve/gve.h b/drivers/net/ethernet/google/gve/gve.h
index 4775214c4d98..a0130f3bfbaf 100644
--- a/drivers/net/ethernet/google/gve/gve.h
+++ b/drivers/net/ethernet/google/gve/gve.h
@@ -203,6 +203,7 @@ struct gve_rx_ring {
 /* A TX desc ring entry */
 union gve_tx_desc {
 	struct gve_tx_pkt_desc pkt; /* first desc for a packet */
+	struct gve_tx_mtd_desc mtd; /* optional metadata descriptor */
 	struct gve_tx_seg_desc seg; /* subsequent descs for a packet */
 };
 
diff --git a/drivers/net/ethernet/google/gve/gve_desc.h b/drivers/net/ethernet/google/gve/gve_desc.h
index a1c0aaa60139..373463b7dcf2 100644
--- a/drivers/net/ethernet/google/gve/gve_desc.h
+++ b/drivers/net/ethernet/google/gve/gve_desc.h
@@ -31,6 +31,14 @@ struct gve_tx_pkt_desc {
 	__be64	seg_addr;  /* Base address (see note) of this segment */
 } __packed;
 
+struct gve_tx_mtd_desc {
+	u8      type_flags;     /* type is lower 4 bits, subtype upper  */
+	u8      path_state;     /* state is lower 4 bits, hash type upper */
+	__be16  reserved0;
+	__be32  path_hash;
+	__be64  reserved1;
+} __packed;
+
 struct gve_tx_seg_desc {
 	u8	type_flags;	/* type is lower 4 bits, flags upper	*/
 	u8	l3_offset;	/* TSO: 2 byte units to start of IPH	*/
@@ -44,6 +52,7 @@ struct gve_tx_seg_desc {
 #define	GVE_TXD_STD		(0x0 << 4) /* Std with Host Address	*/
 #define	GVE_TXD_TSO		(0x1 << 4) /* TSO with Host Address	*/
 #define	GVE_TXD_SEG		(0x2 << 4) /* Seg with Host Address	*/
+#define	GVE_TXD_MTD		(0x3 << 4) /* Metadata			*/
 
 /* GVE Transmit Descriptor Flags for Std Pkts */
 #define	GVE_TXF_L4CSUM	BIT(0)	/* Need csum offload */
@@ -52,6 +61,17 @@ struct gve_tx_seg_desc {
 /* GVE Transmit Descriptor Flags for TSO Segs */
 #define	GVE_TXSF_IPV6	BIT(1)	/* IPv6 TSO */
 
+/* GVE Transmit Descriptor Options for MTD Segs */
+#define GVE_MTD_SUBTYPE_PATH		0
+
+#define GVE_MTD_PATH_STATE_DEFAULT	0
+#define GVE_MTD_PATH_STATE_TIMEOUT	1
+#define GVE_MTD_PATH_STATE_CONGESTION	2
+#define GVE_MTD_PATH_STATE_RETRANSMIT	3
+
+#define GVE_MTD_PATH_HASH_NONE         (0x0 << 4)
+#define GVE_MTD_PATH_HASH_L4           (0x1 << 4)
+
 /* GVE Receive Packet Descriptor */
 /* The start of an ethernet packet comes 2 bytes into the rx buffer.
  * gVNIC adds this padding so that both the DMA and the L3/4 protocol header
* Unmerged path drivers/net/ethernet/google/gve/gve_tx.c
