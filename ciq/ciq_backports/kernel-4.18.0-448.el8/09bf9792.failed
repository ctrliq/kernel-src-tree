net/mlx5e: TC, Move pedit_headers_action to parse_attr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 09bf97923224fea7f3633648b64867a934d627f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/09bf9792.failed

Move pedit_headers_action from flow parse_state to flow parse_attr.
In a follow up commit we are going to have multiple attr per flow
and pedit_headers_action are unique per attr.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 09bf97923224fea7f3633648b64867a934d627f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index d73114e91e9a,e4677f1a8341..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -3061,91 -2993,8 +3062,90 @@@ static int offload_pedit_fields(struct 
  
  static const struct pedit_headers zero_masks = {};
  
 +static int
 +parse_pedit_to_modify_hdr(struct mlx5e_priv *priv,
 +			  const struct flow_action_entry *act, int namespace,
 +			  struct mlx5e_tc_flow_parse_attr *parse_attr,
 +			  struct pedit_headers_action *hdrs,
 +			  struct netlink_ext_ack *extack)
 +{
 +	u8 cmd = (act->id == FLOW_ACTION_MANGLE) ? 0 : 1;
 +	int err = -EOPNOTSUPP;
 +	u32 mask, val, offset;
 +	u8 htype;
 +
 +	htype = act->mangle.htype;
 +	err = -EOPNOTSUPP; /* can't be all optimistic */
 +
 +	if (htype == FLOW_ACT_MANGLE_UNSPEC) {
 +		NL_SET_ERR_MSG_MOD(extack, "legacy pedit isn't offloaded");
 +		goto out_err;
 +	}
 +
 +	if (!mlx5e_mod_hdr_max_actions(priv->mdev, namespace)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "The pedit offload action is not supported");
 +		goto out_err;
 +	}
 +
 +	mask = act->mangle.mask;
 +	val = act->mangle.val;
 +	offset = act->mangle.offset;
 +
 +	err = set_pedit_val(htype, ~mask, val, offset, &hdrs[cmd], extack);
 +	if (err)
 +		goto out_err;
 +
 +	hdrs[cmd].pedits++;
 +
 +	return 0;
 +out_err:
 +	return err;
 +}
 +
 +static int
 +parse_pedit_to_reformat(const struct flow_action_entry *act,
 +			struct mlx5e_tc_flow_parse_attr *parse_attr,
 +			struct netlink_ext_ack *extack)
 +{
 +	u32 mask, val, offset;
 +	u32 *p;
 +
 +	if (act->id != FLOW_ACTION_MANGLE) {
 +		NL_SET_ERR_MSG_MOD(extack, "Unsupported action id");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (act->mangle.htype != FLOW_ACT_MANGLE_HDR_TYPE_ETH) {
 +		NL_SET_ERR_MSG_MOD(extack, "Only Ethernet modification is supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	mask = ~act->mangle.mask;
 +	val = act->mangle.val;
 +	offset = act->mangle.offset;
 +	p = (u32 *)&parse_attr->eth;
 +	*(p + (offset >> 2)) |= (val & mask);
 +
 +	return 0;
 +}
 +
 +static int parse_tc_pedit_action(struct mlx5e_priv *priv,
 +				 const struct flow_action_entry *act, int namespace,
 +				 struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				 struct pedit_headers_action *hdrs,
 +				 struct mlx5e_tc_flow *flow,
 +				 struct netlink_ext_ack *extack)
 +{
 +	if (flow && flow_flag_test(flow, L3_TO_L2_DECAP))
 +		return parse_pedit_to_reformat(act, parse_attr, extack);
 +
 +	return parse_pedit_to_modify_hdr(priv, act, namespace,
 +					 parse_attr, hdrs, extack);
 +}
 +
  static int alloc_tc_pedit_action(struct mlx5e_priv *priv, int namespace,
  				 struct mlx5e_tc_flow_parse_attr *parse_attr,
- 				 struct pedit_headers_action *hdrs,
  				 u32 *action_flags,
  				 struct netlink_ext_ack *extack)
  {
@@@ -3603,10 -3328,9 +3601,9 @@@ actions_prepare_mod_hdr_actions(struct 
  	    !hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits)
  		return 0;
  
 -	ns_type = mlx5e_get_flow_namespace(flow);
 +	ns_type = get_flow_name_space(flow);
  
- 	err = alloc_tc_pedit_action(priv, ns_type, parse_attr, hdrs,
- 				    &attr->action, extack);
+ 	err = alloc_tc_pedit_action(priv, ns_type, parse_attr, &attr->action, extack);
  	if (err)
  		return err;
  
@@@ -3651,130 -3375,26 +3648,140 @@@ parse_tc_nic_actions(struct mlx5e_priv 
  		     struct mlx5e_tc_flow *flow,
  		     struct netlink_ext_ack *extack)
  {
 -	struct mlx5e_tc_act_parse_state *parse_state;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
  	struct mlx5_flow_attr *attr = flow->attr;
++<<<<<<< HEAD
 +	struct pedit_headers_action hdrs[2] = {};
 +	const struct flow_action_entry *act;
 +	struct mlx5_nic_flow_attr *nic_attr;
 +	bool clear_action;
 +	u32 action = 0;
 +	int err, i;
++=======
+ 	int err;
++>>>>>>> 09bf97923224 (net/mlx5e: TC, Move pedit_headers_action to parse_attr)
  
  	err = flow_action_supported(flow_action, extack);
  	if (err)
  		return err;
  
 -	attr->nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
 +	nic_attr = attr->nic_attr;
 +	nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
  	parse_attr = attr->parse_attr;
++<<<<<<< HEAD
++=======
+ 	parse_state = &parse_attr->parse_state;
+ 	mlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);
+ 	parse_state->ct_priv = get_ct_priv(priv);
++>>>>>>> 09bf97923224 (net/mlx5e: TC, Move pedit_headers_action to parse_attr)
  
 -	err = parse_tc_actions(parse_state, flow_action);
 -	if (err)
 -		return err;
 +	flow_action_for_each(i, act, flow_action) {
 +		switch (act->id) {
 +		case FLOW_ACTION_ACCEPT:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_KERNEL,
 +						    parse_attr, hdrs, NULL, extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_KERNEL,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags,
 +						   extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
 +		case FLOW_ACTION_REDIRECT: {
 +			struct net_device *peer_dev = act->dev;
 +
 +			if (priv->netdev->netdev_ops == peer_dev->netdev_ops &&
 +			    same_hw_devs(priv, netdev_priv(peer_dev))) {
 +				parse_attr->mirred_ifindex[0] = peer_dev->ifindex;
 +				flow_flag_set(flow, HAIRPIN);
 +				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "device is not on same HW, can't offload");
 +				netdev_warn(priv->netdev, "device %s not on same HW, can't offload\n",
 +					    peer_dev->name);
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_MARK: {
 +			u32 mark = act->mark;
 +
 +			if (mark & ~MLX5E_TC_FLOW_ID_MASK) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Bad flow mark - only 16 bit is supported");
 +				return -EINVAL;
 +			}
 +
 +			nic_attr->flow_tag = mark;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 +			}
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
 +			break;
 +		case FLOW_ACTION_CT:
 +			clear_action = act->ct.action & TCA_CT_ACT_CLEAR;
 +
 +			/* It's redundant to do ct clear more than once. */
 +			if (clear_action && attr->ct_clear)
 +				break;
 +
 +			err = mlx5_tc_ct_parse_action(get_ct_priv(priv), attr,
 +						      &parse_attr->mod_hdr_acts,
 +						      act, extack);
 +			if (err)
 +				return err;
 +
 +			flow_flag_set(flow, CT);
 +			attr->ct_clear = clear_action;
 +			break;
 +		default:
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "The offload action is not supported in NIC action");
 +			return -EOPNOTSUPP;
 +		}
 +	}
 +
 +	attr->action = action;
 +
 +	if (attr->dest_chain && parse_attr->mirred_ifindex[0]) {
 +		NL_SET_ERR_MSG(extack, "Mirroring goto chain rules isn't supported");
 +		return -EOPNOTSUPP;
 +	}
  
- 	err = actions_prepare_mod_hdr_actions(priv, flow, attr, hdrs, extack);
+ 	err = actions_prepare_mod_hdr_actions(priv, flow, attr, extack);
  	if (err)
  		return err;
  
@@@ -4065,28 -3489,17 +4072,32 @@@ int mlx5e_set_fwd_to_int_port_actions(s
  	return 0;
  }
  
 -static int
 -parse_tc_fdb_actions(struct mlx5e_priv *priv,
 -		     struct flow_action *flow_action,
 -		     struct mlx5e_tc_flow *flow,
 -		     struct netlink_ext_ack *extack)
 +static int parse_tc_fdb_actions(struct mlx5e_priv *priv,
 +				struct flow_action *flow_action,
 +				struct mlx5e_tc_flow *flow,
 +				struct netlink_ext_ack *extack)
  {
 -	struct mlx5e_tc_act_parse_state *parse_state;
 +	struct pedit_headers_action hdrs[2] = {};
 +	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5e_sample_attr sample_attr = {};
 +	const struct ip_tunnel_info *info = NULL;
  	struct mlx5_flow_attr *attr = flow->attr;
 +	int ifindexes[MLX5_MAX_FLOW_FWD_VPORTS];
 +	bool ft_flow = mlx5e_is_ft_flow(flow);
 +	const struct flow_action_entry *act;
  	struct mlx5_esw_flow_attr *esw_attr;
++<<<<<<< HEAD
 +	bool encap = false, decap = false;
 +	u32 action = attr->action;
 +	int err, i, if_count = 0;
 +	bool ptype_host = false;
 +	bool mpls_push = false;
 +	bool clear_action;
++=======
+ 	int err;
++>>>>>>> 09bf97923224 (net/mlx5e: TC, Move pedit_headers_action to parse_attr)
  
  	err = flow_action_supported(flow_action, extack);
  	if (err)
@@@ -4094,350 -3507,13 +4105,356 @@@
  
  	esw_attr = attr->esw_attr;
  	parse_attr = attr->parse_attr;
++<<<<<<< HEAD
++=======
+ 	parse_state = &parse_attr->parse_state;
+ 	mlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);
+ 	parse_state->ct_priv = get_ct_priv(priv);
++>>>>>>> 09bf97923224 (net/mlx5e: TC, Move pedit_headers_action to parse_attr)
  
 -	err = parse_tc_actions(parse_state, flow_action);
 -	if (err)
 -		return err;
 +	flow_action_for_each(i, act, flow_action) {
 +		switch (act->id) {
 +		case FLOW_ACTION_PTYPE:
 +			if (act->ptype != PACKET_HOST) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "skbedit ptype is only supported with type host");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			ptype_host = true;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_TRAP:
 +			if (!flow_offload_has_one_action(flow_action)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "action trap is supported as a sole action only");
 +				return -EOPNOTSUPP;
 +			}
 +			action |= (MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				   MLX5_FLOW_CONTEXT_ACTION_COUNT);
 +			attr->flags |= MLX5_ESW_ATTR_FLAG_SLOW_PATH;
 +			break;
 +		case FLOW_ACTION_MPLS_PUSH:
 +			if (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,
 +							reformat_l2_to_l3_tunnel) ||
 +			    act->mpls_push.proto != htons(ETH_P_MPLS_UC)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls push is supported only for mpls_uc protocol");
 +				return -EOPNOTSUPP;
 +			}
 +			mpls_push = true;
 +			break;
 +		case FLOW_ACTION_MPLS_POP:
 +			/* we only support mpls pop if it is the first action
 +			 * and the filter net device is bareudp. Subsequent
 +			 * actions can be pedit and the last can be mirred
 +			 * egress redirect.
 +			 */
 +			if (i) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls pop supported only as first action");
 +				return -EOPNOTSUPP;
 +			}
 +			if (!netif_is_bareudp(parse_attr->filter_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls pop supported only on bareudp devices");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			parse_attr->eth.h_proto = act->mpls_pop.proto;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
 +			flow_flag_set(flow, L3_TO_L2_DECAP);
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_FDB,
 +						    parse_attr, hdrs, flow, extack);
 +			if (err)
 +				return err;
 +
 +			if (!flow_flag_test(flow, L3_TO_L2_DECAP)) {
 +				action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +				esw_attr->split_count = esw_attr->out_count;
 +			}
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags, extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
 +		case FLOW_ACTION_REDIRECT_INGRESS: {
 +			struct net_device *out_dev;
 +
 +			out_dev = act->dev;
 +			if (!out_dev)
 +				return -EOPNOTSUPP;
 +
 +			if (!netif_is_ovs_master(out_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to ingress is supported only for OVS internal ports");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (netif_is_ovs_master(parse_attr->filter_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to ingress is not supported from internal port");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (!ptype_host) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to int port ingress requires ptype=host action");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (esw_attr->out_count) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to int port ingress is supported only as single destination");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +
 +			err = mlx5e_set_fwd_to_int_port_actions(priv, attr, out_dev->ifindex,
 +								MLX5E_TC_INT_PORT_INGRESS,
 +								&action, esw_attr->out_count);
 +			if (err)
 +				return err;
 +
 +			esw_attr->out_count++;
 +
 +			break;
 +		}
 +		case FLOW_ACTION_REDIRECT:
 +		case FLOW_ACTION_MIRRED: {
 +			struct mlx5e_priv *out_priv;
 +			struct net_device *out_dev;
 +
 +			out_dev = act->dev;
 +			if (!out_dev) {
 +				/* out_dev is NULL when filters with
 +				 * non-existing mirred device are replayed to
 +				 * the driver.
 +				 */
 +				return -EINVAL;
 +			}
 +
 +			if (mpls_push && !netif_is_bareudp(out_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls is supported only through a bareudp device");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (ft_flow && out_dev == priv->netdev) {
 +				/* Ignore forward to self rules generated
 +				 * by adding both mlx5 devs to the flow table
 +				 * block on a normal nft offload setup.
 +				 */
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (esw_attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "can't support more output ports, can't offload forwarding");
 +				netdev_warn(priv->netdev,
 +					    "can't support more than %d output ports, can't offload forwarding\n",
 +					    esw_attr->out_count);
 +				return -EOPNOTSUPP;
 +			}
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			if (encap) {
 +				parse_attr->mirred_ifindex[esw_attr->out_count] =
 +					out_dev->ifindex;
 +				parse_attr->tun_info[esw_attr->out_count] =
 +					mlx5e_dup_tun_info(info);
 +				if (!parse_attr->tun_info[esw_attr->out_count])
 +					return -ENOMEM;
 +				encap = false;
 +				esw_attr->dests[esw_attr->out_count].flags |=
 +					MLX5_ESW_DEST_ENCAP;
 +				esw_attr->out_count++;
 +				/* attr->dests[].rep is resolved when we
 +				 * handle encap
 +				 */
 +			} else if (netdev_port_same_parent_id(priv->netdev, out_dev)) {
 +				struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +				struct net_device *uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
 +
 +				if (is_duplicated_output_device(priv->netdev,
 +								out_dev,
 +								ifindexes,
 +								if_count,
 +								extack))
 +					return -EOPNOTSUPP;
 +
 +				ifindexes[if_count] = out_dev->ifindex;
 +				if_count++;
 +
 +				out_dev = get_fdb_out_dev(uplink_dev, out_dev);
 +				if (!out_dev)
 +					return -ENODEV;
 +
 +				if (is_vlan_dev(out_dev)) {
 +					err = add_vlan_push_action(priv, attr,
 +								   &out_dev,
 +								   &action, extack);
 +					if (err)
 +						return err;
 +				}
 +
 +				if (is_vlan_dev(parse_attr->filter_dev)) {
 +					err = add_vlan_pop_action(priv, attr,
 +								  &action, extack);
 +					if (err)
 +						return err;
 +				}
 +
 +				if (netif_is_macvlan(out_dev))
 +					out_dev = macvlan_dev_real_dev(out_dev);
 +
 +				err = verify_uplink_forwarding(priv, flow, out_dev, extack);
 +				if (err)
 +					return err;
 +
 +				if (!mlx5e_is_valid_eswitch_fwd_dev(priv, out_dev)) {
 +					NL_SET_ERR_MSG_MOD(extack,
 +							   "devices are not on same switch HW, can't offload forwarding");
 +					return -EOPNOTSUPP;
 +				}
 +
 +				if (same_vf_reps(priv, out_dev)) {
 +					NL_SET_ERR_MSG_MOD(extack,
 +							   "can't forward from a VF to itself");
 +					return -EOPNOTSUPP;
 +				}
 +
 +				out_priv = netdev_priv(out_dev);
 +				rpriv = out_priv->ppriv;
 +				esw_attr->dests[esw_attr->out_count].rep = rpriv->rep;
 +				esw_attr->dests[esw_attr->out_count].mdev = out_priv->mdev;
 +				esw_attr->out_count++;
 +			} else if (netif_is_ovs_master(out_dev)) {
 +				err = mlx5e_set_fwd_to_int_port_actions(priv, attr,
 +									out_dev->ifindex,
 +									MLX5E_TC_INT_PORT_EGRESS,
 +									&action,
 +									esw_attr->out_count);
 +				if (err)
 +					return err;
 +
 +				esw_attr->out_count++;
 +			} else if (parse_attr->filter_dev != priv->netdev) {
 +				/* All mlx5 devices are called to configure
 +				 * high level device filters. Therefore, the
 +				 * *attempt* to  install a filter on invalid
 +				 * eswitch should not trigger an explicit error
 +				 */
 +				return -EINVAL;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "devices are not on same switch HW, can't offload forwarding");
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_TUNNEL_ENCAP:
 +			info = act->tunnel;
 +			if (info) {
 +				encap = true;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Zero tunnel attributes is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			break;
 +		case FLOW_ACTION_VLAN_PUSH:
 +		case FLOW_ACTION_VLAN_POP:
 +			if (act->id == FLOW_ACTION_VLAN_PUSH &&
 +			    (action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP)) {
 +				/* Replace vlan pop+push with vlan modify */
 +				action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +				err = add_vlan_rewrite_action(priv,
 +							      MLX5_FLOW_NAMESPACE_FDB,
 +							      act, parse_attr, hdrs,
 +							      &action, extack);
 +			} else {
 +				err = parse_tc_vlan_action(priv, act, esw_attr, &action, extack);
 +			}
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_FDB,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_TUNNEL_DECAP:
 +			decap = true;
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
 +			break;
 +		case FLOW_ACTION_CT:
 +			if (flow_flag_test(flow, SAMPLE)) {
 +				NL_SET_ERR_MSG_MOD(extack, "Sample action with connection tracking is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			clear_action = act->ct.action & TCA_CT_ACT_CLEAR;
 +
 +			/* It's redundant to do ct clear more than once. */
 +			if (clear_action && attr->ct_clear)
 +				break;
 +
 +			err = mlx5_tc_ct_parse_action(get_ct_priv(priv), attr,
 +						      &parse_attr->mod_hdr_acts,
 +						      act, extack);
 +			if (err)
 +				return err;
 +
 +			flow_flag_set(flow, CT);
 +			esw_attr->split_count = esw_attr->out_count;
 +			attr->ct_clear = clear_action;
 +			break;
 +		case FLOW_ACTION_SAMPLE:
 +			if (flow_flag_test(flow, CT)) {
 +				NL_SET_ERR_MSG_MOD(extack, "Sample action with connection tracking is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +			sample_attr.rate = act->sample.rate;
 +			sample_attr.group_num = act->sample.psample_group->group_num;
 +			if (act->sample.truncate)
 +				sample_attr.trunc_size = act->sample.trunc_size;
 +			flow_flag_set(flow, SAMPLE);
 +			break;
 +		default:
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "The offload action is not supported in FDB action");
 +			return -EOPNOTSUPP;
 +		}
 +	}
  
  	/* Forward to/from internal port can only have 1 dest */
  	if ((netif_is_ovs_master(parse_attr->filter_dev) || esw_attr->dest_int_port) &&
@@@ -4447,21 -3523,7 +4464,25 @@@
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_GEN(esw->dev, prio_tag_required) &&
 +	    action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP) {
 +		/* For prio tag mode, replace vlan pop with rewrite vlan prio
 +		 * tag rewrite.
 +		 */
 +		action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +		err = add_vlan_prio_tag_rewrite_action(priv, parse_attr, hdrs,
 +						       &action, extack);
 +		if (err)
 +			return err;
 +	}
 +
 +	attr->action = action;
 +
 +	err = actions_prepare_mod_hdr_actions(priv, flow, attr, hdrs, extack);
++=======
+ 	err = actions_prepare_mod_hdr_actions(priv, flow, attr, extack);
++>>>>>>> 09bf97923224 (net/mlx5e: TC, Move pedit_headers_action to parse_attr)
  	if (err)
  		return err;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
index b689701ac7d8..f59e6976b3cf 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
@@ -34,6 +34,7 @@ struct mlx5e_tc_flow_parse_attr {
 	const struct ip_tunnel_info *tun_info[MLX5_MAX_FLOW_FWD_VPORTS];
 	struct net_device *filter_dev;
 	struct mlx5_flow_spec spec;
+	struct pedit_headers_action hdrs[__PEDIT_CMD_MAX];
 	struct mlx5e_tc_mod_hdr_acts mod_hdr_acts;
 	int mirred_ifindex[MLX5_MAX_FLOW_FWD_VPORTS];
 	struct ethhdr eth;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
