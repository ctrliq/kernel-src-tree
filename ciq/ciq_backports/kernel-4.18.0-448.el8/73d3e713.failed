ath11k: Add QMI changes for WCN6750

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
commit 73d3e71306fe864d9667e8d37f731e93a91e2040
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/73d3e713.failed

In the case of WCN6750, FW doesn't request for DDR memory
via QMI, instead it uses a fixed 12MB reserved Memory region
in the DDR which is called as MSA region. As a result, QMI
message sequence is not same as other ath11k supported devices.

Also, M3 firmware will be bundled into the FW and will be
downloaded to the target as part of Q6 boot.

This is the QMI flow in the case of WCN6750,

1) QMI firmware indication REQ/RESP
2) QMI host capability REQ/RESP
3) QMI target capability REQ/RESP
4) QMI device info REQ/RESP
5) QMI BDF download
6) QMI FW ready

Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1
Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-00192-QCAHKSWPL_SILICONZ-1

	Signed-off-by: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
	Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
Link: https://lore.kernel.org/r/20220429170502.20080-7-quic_mpubbise@quicinc.com
(cherry picked from commit 73d3e71306fe864d9667e8d37f731e93a91e2040)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/ath11k/core.c
#	drivers/net/wireless/ath/ath11k/hw.h
diff --cc drivers/net/wireless/ath/ath11k/core.c
index 241b5e0c8d3f,64cf87fd6a7f..000000000000
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@@ -102,6 -102,14 +102,17 @@@ static const struct ath11k_hw_params at
  		.dbr_debug_support = true,
  		.global_reset = false,
  		.bios_sar_capa = NULL,
++<<<<<<< HEAD
++=======
+ 		.m3_fw_support = false,
+ 		.fixed_bdf_addr = true,
+ 		.fixed_mem_region = true,
+ 		.static_window_map = false,
+ 		.hybrid_bus_type = false,
+ 		.dp_window_idx = 0,
+ 		.ce_window_idx = 0,
+ 		.fixed_fw_mem = false,
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  	},
  	{
  		.hw_rev = ATH11K_HW_IPQ6018_HW10,
@@@ -170,6 -177,14 +181,17 @@@
  		.dbr_debug_support = true,
  		.global_reset = false,
  		.bios_sar_capa = NULL,
++<<<<<<< HEAD
++=======
+ 		.m3_fw_support = false,
+ 		.fixed_bdf_addr = true,
+ 		.fixed_mem_region = true,
+ 		.static_window_map = false,
+ 		.hybrid_bus_type = false,
+ 		.dp_window_idx = 0,
+ 		.ce_window_idx = 0,
+ 		.fixed_fw_mem = false,
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  	},
  	{
  		.name = "qca6390 hw2.0",
@@@ -237,6 -251,14 +259,17 @@@
  		.dbr_debug_support = false,
  		.global_reset = true,
  		.bios_sar_capa = NULL,
++<<<<<<< HEAD
++=======
+ 		.m3_fw_support = true,
+ 		.fixed_bdf_addr = false,
+ 		.fixed_mem_region = false,
+ 		.static_window_map = false,
+ 		.hybrid_bus_type = false,
+ 		.dp_window_idx = 0,
+ 		.ce_window_idx = 0,
+ 		.fixed_fw_mem = false,
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  	},
  	{
  		.name = "qcn9074 hw1.0",
@@@ -304,6 -325,14 +337,17 @@@
  		.dbr_debug_support = true,
  		.global_reset = false,
  		.bios_sar_capa = NULL,
++<<<<<<< HEAD
++=======
+ 		.m3_fw_support = true,
+ 		.fixed_bdf_addr = false,
+ 		.fixed_mem_region = false,
+ 		.static_window_map = true,
+ 		.hybrid_bus_type = false,
+ 		.dp_window_idx = 3,
+ 		.ce_window_idx = 2,
+ 		.fixed_fw_mem = false,
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  	},
  	{
  		.name = "wcn6855 hw2.0",
@@@ -371,6 -399,14 +415,17 @@@
  		.dbr_debug_support = false,
  		.global_reset = true,
  		.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,
++<<<<<<< HEAD
++=======
+ 		.m3_fw_support = true,
+ 		.fixed_bdf_addr = false,
+ 		.fixed_mem_region = false,
+ 		.static_window_map = false,
+ 		.hybrid_bus_type = false,
+ 		.dp_window_idx = 0,
+ 		.ce_window_idx = 0,
+ 		.fixed_fw_mem = false,
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  	},
  	{
  		.name = "wcn6855 hw2.1",
@@@ -437,6 -472,84 +492,87 @@@
  		.dbr_debug_support = false,
  		.global_reset = true,
  		.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,
++<<<<<<< HEAD
++=======
+ 		.m3_fw_support = true,
+ 		.fixed_bdf_addr = false,
+ 		.fixed_mem_region = false,
+ 		.static_window_map = false,
+ 		.hybrid_bus_type = false,
+ 		.dp_window_idx = 0,
+ 		.ce_window_idx = 0,
+ 		.fixed_fw_mem = false,
+ 	},
+ 	{
+ 		.name = "wcn6750 hw1.0",
+ 		.hw_rev = ATH11K_HW_WCN6750_HW10,
+ 		.fw = {
+ 			.dir = "WCN6750/hw1.0",
+ 			.board_size = 256 * 1024,
+ 			.cal_offset = 128 * 1024,
+ 		},
+ 		.max_radios = 1,
+ 		.bdf_addr = 0x4B0C0000,
+ 		.ring_mask = &ath11k_hw_ring_mask_qca6390,
+ 		.internal_sleep_clock = false,
+ 		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_WCN6750,
+ 		.host_ce_config = ath11k_host_ce_config_qca6390,
+ 		.ce_count = 9,
+ 		.target_ce_config = ath11k_target_ce_config_wlan_qca6390,
+ 		.target_ce_count = 9,
+ 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,
+ 		.svc_to_ce_map_len = 14,
+ 		.rfkill_pin = 0,
+ 		.rfkill_cfg = 0,
+ 		.rfkill_on_level = 0,
+ 		.single_pdev_only = true,
+ 		.rxdma1_enable = false,
+ 		.num_rxmda_per_pdev = 1,
+ 		.rx_mac_buf_ring = true,
+ 		.vdev_start_delay = true,
+ 		.htt_peer_map_v2 = false,
+ 
+ 		.spectral = {
+ 			.fft_sz = 0,
+ 			.fft_pad_sz = 0,
+ 			.summary_pad_sz = 0,
+ 			.fft_hdr_len = 0,
+ 			.max_fft_bins = 0,
+ 		},
+ 
+ 		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
+ 					BIT(NL80211_IFTYPE_AP),
+ 		.supports_monitor = false,
+ 		.supports_shadow_regs = true,
+ 		.idle_ps = true,
+ 		.supports_sta_ps = true,
+ 		.cold_boot_calib = false,
+ 		.fw_mem_mode = 0,
+ 		.num_vdevs = 16 + 1,
+ 		.num_peers = 512,
+ 		.supports_suspend = false,
+ 		.supports_regdb = true,
+ 		.fix_l1ss = false,
+ 		.credit_flow = true,
+ 		.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,
+ 		.hal_params = &ath11k_hw_hal_params_qca6390,
+ 		.supports_dynamic_smps_6ghz = false,
+ 		.alloc_cacheable_memory = false,
+ 		.supports_rssi_stats = true,
+ 		.fw_wmi_diag_event = false,
+ 		.current_cc_support = true,
+ 		.dbr_debug_support = false,
+ 		.global_reset = false,
+ 		.bios_sar_capa = NULL,
+ 		.m3_fw_support = false,
+ 		.fixed_bdf_addr = false,
+ 		.fixed_mem_region = false,
+ 		.static_window_map = true,
+ 		.hybrid_bus_type = true,
+ 		.dp_window_idx = 1,
+ 		.ce_window_idx = 2,
+ 		.fixed_fw_mem = true,
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  	},
  };
  
diff --cc drivers/net/wireless/ath/ath11k/hw.h
index 29546d8de738,b5a4758a6bc5..000000000000
--- a/drivers/net/wireless/ath/ath11k/hw.h
+++ b/drivers/net/wireless/ath/ath11k/hw.h
@@@ -196,6 -196,14 +196,17 @@@ struct ath11k_hw_params 
  	bool dbr_debug_support;
  	bool global_reset;
  	const struct cfg80211_sar_capa *bios_sar_capa;
++<<<<<<< HEAD
++=======
+ 	bool m3_fw_support;
+ 	bool fixed_bdf_addr;
+ 	bool fixed_mem_region;
+ 	bool static_window_map;
+ 	bool hybrid_bus_type;
+ 	u8 dp_window_idx;
+ 	u8 ce_window_idx;
+ 	bool fixed_fw_mem;
++>>>>>>> 73d3e71306fe (ath11k: Add QMI changes for WCN6750)
  };
  
  struct ath11k_hw_ops {
* Unmerged path drivers/net/wireless/ath/ath11k/core.c
* Unmerged path drivers/net/wireless/ath/ath11k/hw.h
diff --git a/drivers/net/wireless/ath/ath11k/qmi.c b/drivers/net/wireless/ath/ath11k/qmi.c
index 0f74aea74a57..47e2f286ce98 100644
--- a/drivers/net/wireless/ath/ath11k/qmi.c
+++ b/drivers/net/wireless/ath/ath11k/qmi.c
@@ -1798,10 +1798,6 @@ static int ath11k_qmi_fw_ind_register_send(struct ath11k_base *ab)
 	req->client_id = QMI_WLANFW_CLIENT_ID;
 	req->fw_ready_enable_valid = 1;
 	req->fw_ready_enable = 1;
-	req->request_mem_enable_valid = 1;
-	req->request_mem_enable = 1;
-	req->fw_mem_ready_enable_valid = 1;
-	req->fw_mem_ready_enable = 1;
 	req->cal_done_enable_valid = 1;
 	req->cal_done_enable = 1;
 	req->fw_init_done_enable_valid = 1;
@@ -1810,6 +1806,17 @@ static int ath11k_qmi_fw_ind_register_send(struct ath11k_base *ab)
 	req->pin_connect_result_enable_valid = 0;
 	req->pin_connect_result_enable = 0;
 
+	/* WCN6750 doesn't request for DDR memory via QMI,
+	 * instead it uses a fixed 12MB reserved memory
+	 * region in DDR.
+	 */
+	if (!ab->hw_params.fixed_fw_mem) {
+		req->request_mem_enable_valid = 1;
+		req->request_mem_enable = 1;
+		req->fw_mem_ready_enable_valid = 1;
+		req->fw_mem_ready_enable = 1;
+	}
+
 	ret = qmi_txn_init(handle, &txn,
 			   qmi_wlanfw_ind_register_resp_msg_v01_ei, resp);
 	if (ret < 0)
@@ -2835,27 +2842,6 @@ ath11k_qmi_driver_event_post(struct ath11k_qmi *qmi,
 	return 0;
 }
 
-static int ath11k_qmi_event_server_arrive(struct ath11k_qmi *qmi)
-{
-	struct ath11k_base *ab = qmi->ab;
-	int ret;
-
-	ret = ath11k_qmi_fw_ind_register_send(ab);
-	if (ret < 0) {
-		ath11k_warn(ab, "failed to send qmi firmware indication: %d\n",
-			    ret);
-		return ret;
-	}
-
-	ret = ath11k_qmi_host_cap_send(ab);
-	if (ret < 0) {
-		ath11k_warn(ab, "failed to send qmi host cap: %d\n", ret);
-		return ret;
-	}
-
-	return ret;
-}
-
 static int ath11k_qmi_event_mem_request(struct ath11k_qmi *qmi)
 {
 	struct ath11k_base *ab = qmi->ab;
@@ -2897,9 +2883,33 @@ static int ath11k_qmi_event_load_bdf(struct ath11k_qmi *qmi)
 		return ret;
 	}
 
-	ret = ath11k_qmi_wlanfw_m3_info_send(ab);
+	return 0;
+}
+
+static int ath11k_qmi_event_server_arrive(struct ath11k_qmi *qmi)
+{
+	struct ath11k_base *ab = qmi->ab;
+	int ret;
+
+	ret = ath11k_qmi_fw_ind_register_send(ab);
+	if (ret < 0) {
+		ath11k_warn(ab, "failed to send qmi firmware indication: %d\n",
+			    ret);
+		return ret;
+	}
+
+	ret = ath11k_qmi_host_cap_send(ab);
 	if (ret < 0) {
-		ath11k_warn(ab, "failed to send qmi m3 info req: %d\n", ret);
+		ath11k_warn(ab, "failed to send qmi host cap: %d\n", ret);
+		return ret;
+	}
+
+	if (!ab->hw_params.fixed_fw_mem)
+		return ret;
+
+	ret = ath11k_qmi_event_load_bdf(qmi);
+	if (ret < 0) {
+		ath11k_warn(ab, "qmi failed to download BDF:%d\n", ret);
 		return ret;
 	}
 
@@ -3099,8 +3109,18 @@ static void ath11k_qmi_driver_event_work(struct work_struct *work)
 			break;
 		case ATH11K_QMI_EVENT_FW_MEM_READY:
 			ret = ath11k_qmi_event_load_bdf(qmi);
-			if (ret < 0)
+			if (ret < 0) {
 				set_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags);
+				break;
+			}
+
+			ret = ath11k_qmi_wlanfw_m3_info_send(ab);
+			if (ret < 0) {
+				ath11k_warn(ab,
+					    "failed to send qmi m3 info req: %d\n", ret);
+				set_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags);
+			}
+
 			break;
 		case ATH11K_QMI_EVENT_FW_READY:
 			clear_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags);
