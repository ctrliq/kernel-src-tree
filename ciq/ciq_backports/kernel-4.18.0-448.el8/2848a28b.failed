drivers/base/node: consolidate node device subsystem initialization in node_dev_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author David Hildenbrand <david@redhat.com>
commit 2848a28b0a6052a4c8450397d2647d7d8e3f6f06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2848a28b.failed

...  and call node_dev_init() after memory_dev_init() from driver_init(),
so before any of the existing arch/subsys calls.  All online nodes should
be known at that point: early during boot, arch code determines node and
zone ranges and sets the relevant nodes online; usually this happens in
setup_arch().

This is in line with memory_dev_init(), which initializes the memory
device subsystem and creates all memory block devices.

Similar to memory_dev_init(), panic() if anything goes wrong, we don't
want to continue with such basic initialization errors.

The important part is that node_dev_init() gets called after
memory_dev_init() and after cpu_dev_init(), but before any of the relevant
archs call register_cpu() to register the new cpu device under the node
device.  The latter should be the case for the current users of
topology_init().

Link: https://lkml.kernel.org/r/20220203105212.30385-1-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Tested-by: Anatoly Pugachev <matorola@gmail.com> (sparc64)
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Mike Rapoport <rppt@kernel.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will@kernel.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Paul Walmsley <paul.walmsley@sifive.com>
	Cc: Palmer Dabbelt <palmer@dabbelt.com>
	Cc: Albert Ou <aou@eecs.berkeley.edu>
	Cc: Heiko Carstens <hca@linux.ibm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Cc: Rich Felker <dalias@libc.org>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2848a28b0a6052a4c8450397d2647d7d8e3f6f06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/sysfs.c
#	arch/riscv/kernel/setup.c
#	arch/s390/kernel/numa.c
#	arch/sh/kernel/topology.c
diff --cc arch/powerpc/kernel/sysfs.c
index da9996922a88,2069bbb90a9a..000000000000
--- a/arch/powerpc/kernel/sysfs.c
+++ b/arch/powerpc/kernel/sysfs.c
@@@ -1117,14 -1110,6 +1117,17 @@@ EXPORT_SYMBOL_GPL(cpu_remove_dev_attr_g
  /* NUMA stuff */
  
  #ifdef CONFIG_NUMA
++<<<<<<< HEAD
 +static void register_nodes(void)
 +{
 +	int i;
 +
 +	for (i = 0; i < MAX_NUMNODES; i++)
 +		register_one_node(i);
 +}
 +
++=======
++>>>>>>> 2848a28b0a60 (drivers/base/node: consolidate node device subsystem initialization in node_dev_init())
  int sysfs_add_device_to_node(struct device *dev, int nid)
  {
  	struct node *node = node_devices[nid];
@@@ -1139,13 -1124,6 +1142,16 @@@ void sysfs_remove_device_from_node(stru
  	sysfs_remove_link(&node->dev.kobj, kobject_name(&dev->kobj));
  }
  EXPORT_SYMBOL_GPL(sysfs_remove_device_from_node);
++<<<<<<< HEAD
 +
 +#else
 +static void register_nodes(void)
 +{
 +	return;
 +}
 +
++=======
++>>>>>>> 2848a28b0a60 (drivers/base/node: consolidate node device subsystem initialization in node_dev_init())
  #endif
  
  /* Only valid if CPU is present. */
diff --cc arch/riscv/kernel/setup.c
index f0d2070866d4,834eb652a7b9..000000000000
--- a/arch/riscv/kernel/setup.c
+++ b/arch/riscv/kernel/setup.c
@@@ -220,3 -297,30 +220,33 @@@ void __init setup_arch(char **cmdline_p
  	riscv_fill_hwcap();
  }
  
++<<<<<<< HEAD
++=======
+ static int __init topology_init(void)
+ {
+ 	int i, ret;
+ 
+ 	for_each_possible_cpu(i) {
+ 		struct cpu *cpu = &per_cpu(cpu_devices, i);
+ 
+ 		cpu->hotpluggable = cpu_has_hotplug(i);
+ 		ret = register_cpu(cpu, i);
+ 		if (unlikely(ret))
+ 			pr_warn("Warning: %s: register_cpu %d failed (%d)\n",
+ 			       __func__, i, ret);
+ 	}
+ 
+ 	return 0;
+ }
+ subsys_initcall(topology_init);
+ 
+ void free_initmem(void)
+ {
+ 	if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX))
+ 		set_kernel_memory(lm_alias(__init_begin), lm_alias(__init_end),
+ 				  IS_ENABLED(CONFIG_64BIT) ?
+ 					set_memory_rw : set_memory_rw_nx);
+ 
+ 	free_initmem_default(POISON_FREE_INITMEM);
+ }
++>>>>>>> 2848a28b0a60 (drivers/base/node: consolidate node device subsystem initialization in node_dev_init())
diff --cc arch/sh/kernel/topology.c
index c82912a61d74,2d2a7509b565..000000000000
--- a/arch/sh/kernel/topology.c
+++ b/arch/sh/kernel/topology.c
@@@ -49,11 -46,6 +49,14 @@@ static int __init topology_init(void
  {
  	int i, ret;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_NEED_MULTIPLE_NODES
 +	for_each_online_node(i)
 +		register_one_node(i);
 +#endif
 +
++=======
++>>>>>>> 2848a28b0a60 (drivers/base/node: consolidate node device subsystem initialization in node_dev_init())
  	for_each_present_cpu(i) {
  		struct cpu *c = &per_cpu(cpu_devices, i);
  
* Unmerged path arch/s390/kernel/numa.c
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index d3484e986fbe..2b474d84e487 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -402,9 +402,6 @@ static int __init topology_init(void)
 {
 	int i;
 
-	for_each_online_node(i)
-		register_one_node(i);
-
 	for_each_possible_cpu(i) {
 		struct cpu *cpu = &per_cpu(cpu_data.cpu, i);
 		cpu->hotpluggable = cpu_can_disable(i);
diff --git a/arch/ia64/kernel/topology.c b/arch/ia64/kernel/topology.c
index e311ee13e61d..323170cfadc9 100644
--- a/arch/ia64/kernel/topology.c
+++ b/arch/ia64/kernel/topology.c
@@ -75,16 +75,6 @@ static int __init topology_init(void)
 {
 	int i, err = 0;
 
-#ifdef CONFIG_NUMA
-	/*
-	 * MCD - Do we want to register all ONLINE nodes, or all POSSIBLE nodes?
-	 */
-	for_each_online_node(i) {
-		if ((err = register_one_node(i)))
-			goto out;
-	}
-#endif
-
 	sysfs_cpus = kcalloc(NR_CPUS, sizeof(struct ia64_cpu), GFP_KERNEL);
 	if (!sysfs_cpus)
 		panic("kzalloc in topology_init failed - NR_CPUS too big?");
diff --git a/arch/mips/kernel/topology.c b/arch/mips/kernel/topology.c
index cd3e1f82e1a5..2acf61fb2cee 100644
--- a/arch/mips/kernel/topology.c
+++ b/arch/mips/kernel/topology.c
@@ -12,11 +12,6 @@ static int __init topology_init(void)
 {
 	int i, ret;
 
-#ifdef CONFIG_NUMA
-	for_each_online_node(i)
-		register_one_node(i);
-#endif /* CONFIG_NUMA */
-
 	for_each_present_cpu(i) {
 		struct cpu *c = &per_cpu(cpu_devices, i);
 
* Unmerged path arch/powerpc/kernel/sysfs.c
* Unmerged path arch/riscv/kernel/setup.c
* Unmerged path arch/s390/kernel/numa.c
* Unmerged path arch/sh/kernel/topology.c
diff --git a/arch/sparc/kernel/sysfs.c b/arch/sparc/kernel/sysfs.c
index 6d60d416f0dd..f19487e4cc71 100644
--- a/arch/sparc/kernel/sysfs.c
+++ b/arch/sparc/kernel/sysfs.c
@@ -244,22 +244,10 @@ static void __init check_mmu_stats(void)
 		mmu_stats_supported = 1;
 }
 
-static void register_nodes(void)
-{
-#ifdef CONFIG_NUMA
-	int i;
-
-	for (i = 0; i < MAX_NUMNODES; i++)
-		register_one_node(i);
-#endif
-}
-
 static int __init topology_init(void)
 {
 	int cpu, ret;
 
-	register_nodes();
-
 	check_mmu_stats();
 
 	for_each_possible_cpu(cpu) {
diff --git a/arch/x86/kernel/topology.c b/arch/x86/kernel/topology.c
index 12cbe2b88c0f..030a257783d2 100644
--- a/arch/x86/kernel/topology.c
+++ b/arch/x86/kernel/topology.c
@@ -160,11 +160,6 @@ static int __init topology_init(void)
 {
 	int i;
 
-#ifdef CONFIG_NUMA
-	for_each_online_node(i)
-		register_one_node(i);
-#endif
-
 	for_each_present_cpu(i)
 		arch_register_cpu(i);
 
diff --git a/drivers/base/init.c b/drivers/base/init.c
index 4883e2c3938c..a3809fff4b73 100644
--- a/drivers/base/init.c
+++ b/drivers/base/init.c
@@ -34,6 +34,7 @@ void __init driver_init(void)
 	auxiliary_bus_init();
 	cpu_dev_init();
 	memory_dev_init();
+	node_dev_init();
 	container_dev_init();
 	of_core_init();
 }
diff --git a/drivers/base/node.c b/drivers/base/node.c
index c69b28522c92..db6a55b95d4b 100644
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@ -1067,26 +1067,30 @@ static const struct attribute_group *cpu_root_attr_groups[] = {
 };
 
 #define NODE_CALLBACK_PRI	2	/* lower than SLAB */
-static int __init register_node_type(void)
+void __init node_dev_init(void)
 {
-	int ret;
+	static struct notifier_block node_memory_callback_nb = {
+		.notifier_call = node_memory_callback,
+		.priority = NODE_CALLBACK_PRI,
+	};
+	int ret, i;
 
  	BUILD_BUG_ON(ARRAY_SIZE(node_state_attr) != NR_NODE_STATES);
  	BUILD_BUG_ON(ARRAY_SIZE(node_state_attrs)-1 != NR_NODE_STATES);
 
 	ret = subsys_system_register(&node_subsys, cpu_root_attr_groups);
-	if (!ret) {
-		static struct notifier_block node_memory_callback_nb = {
-			.notifier_call = node_memory_callback,
-			.priority = NODE_CALLBACK_PRI,
-		};
-		register_hotmemory_notifier(&node_memory_callback_nb);
-	}
+	if (ret)
+		panic("%s() failed to register subsystem: %d\n", __func__, ret);
+
+	register_hotmemory_notifier(&node_memory_callback_nb);
 
 	/*
-	 * Note:  we're not going to unregister the node class if we fail
-	 * to register the node state class attribute files.
+	 * Create all node devices, which will properly link the node
+	 * to applicable memory block devices and already created cpu devices.
 	 */
-	return ret;
+	for_each_online_node(i) {
+		ret = register_one_node(i);
+		if (ret)
+			panic("%s() failed to add node: %d\n", __func__, ret);
+	}
 }
-postcore_initcall(register_node_type);
diff --git a/include/linux/node.h b/include/linux/node.h
index 8e5a29897936..44a0360c67bb 100644
--- a/include/linux/node.h
+++ b/include/linux/node.h
@@ -112,6 +112,7 @@ static inline void link_mem_sections(int nid, unsigned long start_pfn,
 
 extern void unregister_node(struct node *node);
 #ifdef CONFIG_NUMA
+extern void node_dev_init(void);
 /* Core of the node registration - only memory hotplug should use this */
 extern int __register_one_node(int nid);
 
@@ -149,6 +150,9 @@ extern void register_hugetlbfs_with_node(node_registration_func_t doregister,
 					 node_registration_func_t unregister);
 #endif
 #else
+static inline void node_dev_init(void)
+{
+}
 static inline int __register_one_node(int nid)
 {
 	return 0;
