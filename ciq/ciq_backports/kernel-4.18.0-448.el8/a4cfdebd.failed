ASoC: SOF: Intel: HDA: Set up sof_ipc4_fw_data for IPC4

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit a4cfdebdfe62e276f7626eb55b859fe16dcc28ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a4cfdebd.failed

Allocate the sof_ipc4_fw_data struct for IPC4 and set the fw header offset
for the platforms which will be used by the core when loading the firmware
image.

The core expects that the "private" field in struct snd_sof_dev (which is
unused today with IPC3) is used to save this data.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220511171648.1622993-6-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit a4cfdebdfe62e276f7626eb55b859fe16dcc28ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/apl.c
#	sound/soc/sof/intel/cnl.c
#	sound/soc/sof/intel/tgl.c
diff --cc sound/soc/sof/intel/apl.c
index 4dc643dd7756,0cea280a6d2d..000000000000
--- a/sound/soc/sof/intel/apl.c
+++ b/sound/soc/sof/intel/apl.c
@@@ -26,113 -28,62 +28,128 @@@ static const struct snd_sof_debugfs_ma
  };
  
  /* apollolake ops */
 -struct snd_sof_dsp_ops sof_apl_ops;
 -EXPORT_SYMBOL_NS(sof_apl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);
 -
 -int sof_apl_ops_init(struct snd_sof_dev *sdev)
 -{
 -	/* common defaults */
 -	memcpy(&sof_apl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));
 -
 +struct snd_sof_dsp_ops sof_apl_ops = {
  	/* probe/remove/shutdown */
 -	sof_apl_ops.shutdown	= hda_dsp_shutdown;
 -
 -	if (sdev->pdata->ipc_type == SOF_IPC) {
 -		/* doorbell */
 -		sof_apl_ops.irq_thread	= hda_dsp_ipc_irq_thread;
 -
 -		/* ipc */
 -		sof_apl_ops.send_msg	= hda_dsp_ipc_send_msg;
 -	}
 -
 +	.probe		= hda_dsp_probe,
 +	.remove		= hda_dsp_remove,
 +	.shutdown	= hda_dsp_shutdown,
 +
 +	/* Register IO */
 +	.write		= sof_io_write,
 +	.read		= sof_io_read,
 +	.write64	= sof_io_write64,
 +	.read64		= sof_io_read64,
 +
 +	/* Block IO */
 +	.block_read	= sof_block_read,
 +	.block_write	= sof_block_write,
 +
++<<<<<<< HEAD
 +	/* Mailbox IO */
 +	.mailbox_read	= sof_mailbox_read,
 +	.mailbox_write	= sof_mailbox_write,
++=======
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		struct sof_ipc4_fw_data *ipc4_data;
+ 
+ 		sdev->private = devm_kzalloc(sdev->dev, sizeof(*ipc4_data), GFP_KERNEL);
+ 		if (!sdev->private)
+ 			return -ENOMEM;
+ 
+ 		ipc4_data = sdev->private;
+ 		ipc4_data->manifest_fw_hdr_offset = SOF_MAN4_FW_HDR_OFFSET;
+ 
+ 		/* doorbell */
+ 		sof_apl_ops.irq_thread	= hda_dsp_ipc4_irq_thread;
++>>>>>>> a4cfdebdfe62 (ASoC: SOF: Intel: HDA: Set up sof_ipc4_fw_data for IPC4)
 +
 +	/* doorbell */
 +	.irq_thread	= hda_dsp_ipc_irq_thread,
 +
 +	/* ipc */
 +	.send_msg	= hda_dsp_ipc_send_msg,
 +	.fw_ready	= sof_fw_ready,
 +	.get_mailbox_offset = hda_dsp_ipc_get_mailbox_offset,
 +	.get_window_offset = hda_dsp_ipc_get_window_offset,
  
 -		/* ipc */
 -		sof_apl_ops.send_msg	= hda_dsp_ipc4_send_msg;
 -	}
 +	.ipc_msg_data	= hda_ipc_msg_data,
 +	.set_stream_data_offset = hda_set_stream_data_offset,
  
 -	/* set DAI driver ops */
 -	hda_set_dai_drv_ops(sdev, &sof_apl_ops);
 +	/* machine driver */
 +	.machine_select = hda_machine_select,
 +	.machine_register = sof_machine_register,
 +	.machine_unregister = sof_machine_unregister,
 +	.set_mach_params = hda_set_mach_params,
  
  	/* debug */
 -	sof_apl_ops.debug_map	= apl_dsp_debugfs;
 -	sof_apl_ops.debug_map_count	= ARRAY_SIZE(apl_dsp_debugfs);
 -	sof_apl_ops.ipc_dump	= hda_ipc_dump;
 +	.debug_map	= apl_dsp_debugfs,
 +	.debug_map_count	= ARRAY_SIZE(apl_dsp_debugfs),
 +	.dbg_dump	= hda_dsp_dump,
 +	.ipc_dump	= hda_ipc_dump,
 +	.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,
 +
 +	/* stream callbacks */
 +	.pcm_open	= hda_dsp_pcm_open,
 +	.pcm_close	= hda_dsp_pcm_close,
 +	.pcm_hw_params	= hda_dsp_pcm_hw_params,
 +	.pcm_hw_free	= hda_dsp_stream_hw_free,
 +	.pcm_trigger	= hda_dsp_pcm_trigger,
 +	.pcm_pointer	= hda_dsp_pcm_pointer,
 +	.pcm_ack	= hda_dsp_pcm_ack,
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_PROBES)
 +	/* probe callbacks */
 +	.probe_assign	= hda_probe_compr_assign,
 +	.probe_free	= hda_probe_compr_free,
 +	.probe_set_params	= hda_probe_compr_set_params,
 +	.probe_trigger	= hda_probe_compr_trigger,
 +	.probe_pointer	= hda_probe_compr_pointer,
 +#endif
 +
 +	/* firmware loading */
 +	.load_firmware = snd_sof_load_firmware_raw,
  
  	/* firmware run */
 -	sof_apl_ops.run = hda_dsp_cl_boot_firmware;
 +	.run = hda_dsp_cl_boot_firmware,
  
  	/* pre/post fw run */
 -	sof_apl_ops.post_fw_run = hda_dsp_post_fw_run;
 +	.pre_fw_run = hda_dsp_pre_fw_run,
 +	.post_fw_run = hda_dsp_post_fw_run,
  
 -	/* dsp core get/put */
 -	sof_apl_ops.core_get = hda_dsp_core_get;
 +	/* parse platform specific extended manifest */
 +	.parse_platform_ext_manifest = hda_dsp_ext_man_get_cavs_config_data,
  
 -	return 0;
 +	/* dsp core get/put */
 +	.core_get = hda_dsp_core_get,
 +
 +	/* trace callback */
 +	.trace_init = hda_dsp_trace_init,
 +	.trace_release = hda_dsp_trace_release,
 +	.trace_trigger = hda_dsp_trace_trigger,
 +
 +	/* DAI drivers */
 +	.drv		= skl_dai,
 +	.num_drv	= SOF_SKL_NUM_DAIS,
 +
 +	/* PM */
 +	.suspend		= hda_dsp_suspend,
 +	.resume			= hda_dsp_resume,
 +	.runtime_suspend	= hda_dsp_runtime_suspend,
 +	.runtime_resume		= hda_dsp_runtime_resume,
 +	.runtime_idle		= hda_dsp_runtime_idle,
 +	.set_hw_params_upon_resume = hda_dsp_set_hw_params_upon_resume,
 +	.set_power_state	= hda_dsp_set_power_state,
 +
 +	/* ALSA HW info flags */
 +	.hw_info =	SNDRV_PCM_INFO_MMAP |
 +			SNDRV_PCM_INFO_MMAP_VALID |
 +			SNDRV_PCM_INFO_INTERLEAVED |
 +			SNDRV_PCM_INFO_PAUSE |
 +			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
 +
 +	.dsp_arch_ops = &sof_xtensa_arch_ops,
  };
 -EXPORT_SYMBOL_NS(sof_apl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);
 +EXPORT_SYMBOL(sof_apl_ops);
  
  const struct sof_intel_dsp_desc apl_chip_info = {
  	/* Apollolake */
diff --cc sound/soc/sof/intel/cnl.c
index 7477c9aee374,cd6e5f8a5eb4..000000000000
--- a/sound/soc/sof/intel/cnl.c
+++ b/sound/soc/sof/intel/cnl.c
@@@ -15,6 -15,9 +15,12 @@@
   * Hardware interface for audio DSP on Cannonlake.
   */
  
++<<<<<<< HEAD
++=======
+ #include <sound/sof/ext_manifest4.h>
+ #include <sound/sof/ipc4/header.h>
+ #include "../ipc4-priv.h"
++>>>>>>> a4cfdebdfe62 (ASoC: SOF: Intel: HDA: Set up sof_ipc4_fw_data for IPC4)
  #include "../ops.h"
  #include "hda.h"
  #include "hda-ipc.h"
@@@ -244,113 -325,63 +250,135 @@@ void cnl_ipc_dump(struct snd_sof_dev *s
  }
  
  /* cannonlake ops */
 -struct snd_sof_dsp_ops sof_cnl_ops;
 -EXPORT_SYMBOL_NS(sof_cnl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);
 +struct snd_sof_dsp_ops sof_cnl_ops = {
 +	/* probe/remove/shutdown */
 +	.probe		= hda_dsp_probe,
 +	.remove		= hda_dsp_remove,
 +	.shutdown	= hda_dsp_shutdown,
  
 -int sof_cnl_ops_init(struct snd_sof_dev *sdev)
 -{
 -	/* common defaults */
 -	memcpy(&sof_cnl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));
 +	/* Register IO */
 +	.write		= sof_io_write,
 +	.read		= sof_io_read,
 +	.write64	= sof_io_write64,
 +	.read64		= sof_io_read64,
  
 -	/* probe/remove/shutdown */
 -	sof_cnl_ops.shutdown	= hda_dsp_shutdown;
 +	/* Block IO */
 +	.block_read	= sof_block_read,
 +	.block_write	= sof_block_write,
  
 -	/* ipc */
 -	if (sdev->pdata->ipc_type == SOF_IPC) {
 -		/* doorbell */
 -		sof_cnl_ops.irq_thread	= cnl_ipc_irq_thread;
 +	/* Mailbox IO */
 +	.mailbox_read	= sof_mailbox_read,
 +	.mailbox_write	= sof_mailbox_write,
  
 -		/* ipc */
 -		sof_cnl_ops.send_msg	= cnl_ipc_send_msg;
 -	}
 +	/* doorbell */
 +	.irq_thread	= cnl_ipc_irq_thread,
  
 +	/* ipc */
 +	.send_msg	= cnl_ipc_send_msg,
 +	.fw_ready	= sof_fw_ready,
 +	.get_mailbox_offset = hda_dsp_ipc_get_mailbox_offset,
 +	.get_window_offset = hda_dsp_ipc_get_window_offset,
 +
 +	.ipc_msg_data	= hda_ipc_msg_data,
 +	.set_stream_data_offset = hda_set_stream_data_offset,
 +
++<<<<<<< HEAD
 +	/* machine driver */
 +	.machine_select = hda_machine_select,
 +	.machine_register = sof_machine_register,
 +	.machine_unregister = sof_machine_unregister,
 +	.set_mach_params = hda_set_mach_params,
++=======
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		struct sof_ipc4_fw_data *ipc4_data;
+ 
+ 		sdev->private = devm_kzalloc(sdev->dev, sizeof(*ipc4_data), GFP_KERNEL);
+ 		if (!sdev->private)
+ 			return -ENOMEM;
+ 
+ 		ipc4_data = sdev->private;
+ 		ipc4_data->manifest_fw_hdr_offset = SOF_MAN4_FW_HDR_OFFSET;
+ 
+ 		/* doorbell */
+ 		sof_cnl_ops.irq_thread	= cnl_ipc4_irq_thread;
+ 
+ 		/* ipc */
+ 		sof_cnl_ops.send_msg	= cnl_ipc4_send_msg;
+ 	}
+ 
+ 	/* set DAI driver ops */
+ 	hda_set_dai_drv_ops(sdev, &sof_cnl_ops);
++>>>>>>> a4cfdebdfe62 (ASoC: SOF: Intel: HDA: Set up sof_ipc4_fw_data for IPC4)
  
  	/* debug */
 -	sof_cnl_ops.debug_map	= cnl_dsp_debugfs;
 -	sof_cnl_ops.debug_map_count	= ARRAY_SIZE(cnl_dsp_debugfs);
 -	sof_cnl_ops.ipc_dump	= cnl_ipc_dump;
 +	.debug_map	= cnl_dsp_debugfs,
 +	.debug_map_count	= ARRAY_SIZE(cnl_dsp_debugfs),
 +	.dbg_dump	= hda_dsp_dump,
 +	.ipc_dump	= cnl_ipc_dump,
 +	.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,
 +
 +	/* stream callbacks */
 +	.pcm_open	= hda_dsp_pcm_open,
 +	.pcm_close	= hda_dsp_pcm_close,
 +	.pcm_hw_params	= hda_dsp_pcm_hw_params,
 +	.pcm_hw_free	= hda_dsp_stream_hw_free,
 +	.pcm_trigger	= hda_dsp_pcm_trigger,
 +	.pcm_pointer	= hda_dsp_pcm_pointer,
 +	.pcm_ack	= hda_dsp_pcm_ack,
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_PROBES)
 +	/* probe callbacks */
 +	.probe_assign	= hda_probe_compr_assign,
 +	.probe_free	= hda_probe_compr_free,
 +	.probe_set_params	= hda_probe_compr_set_params,
 +	.probe_trigger	= hda_probe_compr_trigger,
 +	.probe_pointer	= hda_probe_compr_pointer,
 +#endif
 +
 +	/* firmware loading */
 +	.load_firmware = snd_sof_load_firmware_raw,
  
  	/* pre/post fw run */
 -	sof_cnl_ops.post_fw_run = hda_dsp_post_fw_run;
 +	.pre_fw_run = hda_dsp_pre_fw_run,
 +	.post_fw_run = hda_dsp_post_fw_run,
  
 -	/* firmware run */
 -	sof_cnl_ops.run = hda_dsp_cl_boot_firmware;
 +	/* parse platform specific extended manifest */
 +	.parse_platform_ext_manifest = hda_dsp_ext_man_get_cavs_config_data,
  
  	/* dsp core get/put */
 -	sof_cnl_ops.core_get = hda_dsp_core_get;
 +	.core_get = hda_dsp_core_get,
  
 -	return 0;
 +	/* firmware run */
 +	.run = hda_dsp_cl_boot_firmware,
 +
 +	/* trace callback */
 +	.trace_init = hda_dsp_trace_init,
 +	.trace_release = hda_dsp_trace_release,
 +	.trace_trigger = hda_dsp_trace_trigger,
 +
 +	/* DAI drivers */
 +	.drv		= skl_dai,
 +	.num_drv	= SOF_SKL_NUM_DAIS,
 +
 +	/* PM */
 +	.suspend		= hda_dsp_suspend,
 +	.resume			= hda_dsp_resume,
 +	.runtime_suspend	= hda_dsp_runtime_suspend,
 +	.runtime_resume		= hda_dsp_runtime_resume,
 +	.runtime_idle		= hda_dsp_runtime_idle,
 +	.set_hw_params_upon_resume = hda_dsp_set_hw_params_upon_resume,
 +	.set_power_state	= hda_dsp_set_power_state,
 +
 +	/* ALSA HW info flags */
 +	.hw_info =	SNDRV_PCM_INFO_MMAP |
 +			SNDRV_PCM_INFO_MMAP_VALID |
 +			SNDRV_PCM_INFO_INTERLEAVED |
 +			SNDRV_PCM_INFO_PAUSE |
 +			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
 +
 +	.dsp_arch_ops = &sof_xtensa_arch_ops,
  };
 -EXPORT_SYMBOL_NS(sof_cnl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);
 +EXPORT_SYMBOL(sof_cnl_ops);
  
  const struct sof_intel_dsp_desc cnl_chip_info = {
  	/* Cannonlake */
diff --cc sound/soc/sof/intel/tgl.c
index fceb528ed5d9,1ddc492f1b13..000000000000
--- a/sound/soc/sof/intel/tgl.c
+++ b/sound/soc/sof/intel/tgl.c
@@@ -61,114 -61,63 +63,129 @@@ static int tgl_dsp_core_put(struct snd_
  }
  
  /* Tigerlake ops */
 -struct snd_sof_dsp_ops sof_tgl_ops;
 -EXPORT_SYMBOL_NS(sof_tgl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);
 -
 -int sof_tgl_ops_init(struct snd_sof_dev *sdev)
 -{
 -	/* common defaults */
 -	memcpy(&sof_tgl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));
 -
 +struct snd_sof_dsp_ops sof_tgl_ops = {
  	/* probe/remove/shutdown */
 -	sof_tgl_ops.shutdown	= hda_dsp_shutdown;
 +	.probe		= hda_dsp_probe,
 +	.remove		= hda_dsp_remove,
 +	.shutdown	= hda_dsp_shutdown,
  
 -	if (sdev->pdata->ipc_type == SOF_IPC) {
 -		/* doorbell */
 -		sof_tgl_ops.irq_thread	= cnl_ipc_irq_thread;
 +	/* Register IO */
 +	.write		= sof_io_write,
 +	.read		= sof_io_read,
 +	.write64	= sof_io_write64,
 +	.read64		= sof_io_read64,
  
 -		/* ipc */
 -		sof_tgl_ops.send_msg	= cnl_ipc_send_msg;
 -	}
 +	/* Block IO */
 +	.block_read	= sof_block_read,
 +	.block_write	= sof_block_write,
  
++<<<<<<< HEAD
 +	/* Mailbox IO */
 +	.mailbox_read	= sof_mailbox_read,
 +	.mailbox_write	= sof_mailbox_write,
++=======
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		struct sof_ipc4_fw_data *ipc4_data;
+ 
+ 		sdev->private = devm_kzalloc(sdev->dev, sizeof(*ipc4_data), GFP_KERNEL);
+ 		if (!sdev->private)
+ 			return -ENOMEM;
+ 
+ 		ipc4_data = sdev->private;
+ 		ipc4_data->manifest_fw_hdr_offset = SOF_MAN4_FW_HDR_OFFSET;
+ 
+ 		/* doorbell */
+ 		sof_tgl_ops.irq_thread	= cnl_ipc4_irq_thread;
++>>>>>>> a4cfdebdfe62 (ASoC: SOF: Intel: HDA: Set up sof_ipc4_fw_data for IPC4)
  
 -		/* ipc */
 -		sof_tgl_ops.send_msg	= cnl_ipc4_send_msg;
 -	}
 +	/* doorbell */
 +	.irq_thread	= cnl_ipc_irq_thread,
  
 -	/* set DAI driver ops */
 -	hda_set_dai_drv_ops(sdev, &sof_tgl_ops);
 +	/* ipc */
 +	.send_msg	= cnl_ipc_send_msg,
 +	.fw_ready	= sof_fw_ready,
 +	.get_mailbox_offset = hda_dsp_ipc_get_mailbox_offset,
 +	.get_window_offset = hda_dsp_ipc_get_window_offset,
 +
 +	.ipc_msg_data	= hda_ipc_msg_data,
 +	.set_stream_data_offset = hda_set_stream_data_offset,
 +
 +	/* machine driver */
 +	.machine_select = hda_machine_select,
 +	.machine_register = sof_machine_register,
 +	.machine_unregister = sof_machine_unregister,
 +	.set_mach_params = hda_set_mach_params,
  
  	/* debug */
 -	sof_tgl_ops.debug_map	= tgl_dsp_debugfs;
 -	sof_tgl_ops.debug_map_count	= ARRAY_SIZE(tgl_dsp_debugfs);
 -	sof_tgl_ops.ipc_dump	= cnl_ipc_dump;
 +	.debug_map	= tgl_dsp_debugfs,
 +	.debug_map_count	= ARRAY_SIZE(tgl_dsp_debugfs),
 +	.dbg_dump	= hda_dsp_dump,
 +	.ipc_dump	= cnl_ipc_dump,
 +	.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,
 +
 +	/* stream callbacks */
 +	.pcm_open	= hda_dsp_pcm_open,
 +	.pcm_close	= hda_dsp_pcm_close,
 +	.pcm_hw_params	= hda_dsp_pcm_hw_params,
 +	.pcm_hw_free	= hda_dsp_stream_hw_free,
 +	.pcm_trigger	= hda_dsp_pcm_trigger,
 +	.pcm_pointer	= hda_dsp_pcm_pointer,
 +	.pcm_ack	= hda_dsp_pcm_ack,
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_PROBES)
 +	/* probe callbacks */
 +	.probe_assign	= hda_probe_compr_assign,
 +	.probe_free	= hda_probe_compr_free,
 +	.probe_set_params	= hda_probe_compr_set_params,
 +	.probe_trigger	= hda_probe_compr_trigger,
 +	.probe_pointer	= hda_probe_compr_pointer,
 +#endif
 +
 +	/* firmware loading */
 +	.load_firmware = snd_sof_load_firmware_raw,
  
  	/* pre/post fw run */
 -	sof_tgl_ops.post_fw_run = hda_dsp_post_fw_run;
 +	.pre_fw_run = hda_dsp_pre_fw_run,
 +	.post_fw_run = hda_dsp_post_fw_run,
  
 -	/* firmware run */
 -	sof_tgl_ops.run = hda_dsp_cl_boot_firmware_iccmax;
 +	/* parse platform specific extended manifest */
 +	.parse_platform_ext_manifest = hda_dsp_ext_man_get_cavs_config_data,
  
  	/* dsp core get/put */
 -	sof_tgl_ops.core_get = tgl_dsp_core_get;
 -	sof_tgl_ops.core_put = tgl_dsp_core_put;
 +	.core_get = tgl_dsp_core_get,
 +	.core_put = tgl_dsp_core_put,
 +
 +	/* firmware run */
 +	.run = hda_dsp_cl_boot_firmware_iccmax,
 +
 +	/* trace callback */
 +	.trace_init = hda_dsp_trace_init,
 +	.trace_release = hda_dsp_trace_release,
 +	.trace_trigger = hda_dsp_trace_trigger,
 +
 +	/* DAI drivers */
 +	.drv		= skl_dai,
 +	.num_drv	= SOF_SKL_NUM_DAIS,
 +
 +	/* PM */
 +	.suspend		= hda_dsp_suspend,
 +	.resume			= hda_dsp_resume,
 +	.runtime_suspend	= hda_dsp_runtime_suspend,
 +	.runtime_resume		= hda_dsp_runtime_resume,
 +	.runtime_idle		= hda_dsp_runtime_idle,
 +	.set_hw_params_upon_resume = hda_dsp_set_hw_params_upon_resume,
 +	.set_power_state	= hda_dsp_set_power_state,
 +
 +	/* ALSA HW info flags */
 +	.hw_info =	SNDRV_PCM_INFO_MMAP |
 +			SNDRV_PCM_INFO_MMAP_VALID |
 +			SNDRV_PCM_INFO_INTERLEAVED |
 +			SNDRV_PCM_INFO_PAUSE |
 +			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
  
 -	return 0;
 +	.dsp_arch_ops = &sof_xtensa_arch_ops,
  };
 -EXPORT_SYMBOL_NS(sof_tgl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);
 +EXPORT_SYMBOL(sof_tgl_ops);
  
  const struct sof_intel_dsp_desc tgl_chip_info = {
  	/* Tigerlake , Alderlake */
* Unmerged path sound/soc/sof/intel/apl.c
* Unmerged path sound/soc/sof/intel/cnl.c
* Unmerged path sound/soc/sof/intel/tgl.c
