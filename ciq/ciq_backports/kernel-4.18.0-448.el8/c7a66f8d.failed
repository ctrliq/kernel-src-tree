flow_offload: add process to update action stats from hardware

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Baowen Zheng <baowen.zheng@corigine.com>
commit c7a66f8d8a946edafb38150480145ab9801e4e52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c7a66f8d.failed

When collecting stats for actions update them using both
hardware and software counters.

Stats update process should not run in context of preempt_disable.

	Signed-off-by: Baowen Zheng <baowen.zheng@corigine.com>
	Signed-off-by: Louis Peens <louis.peens@corigine.com>
	Signed-off-by: Simon Horman <simon.horman@corigine.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c7a66f8d8a946edafb38150480145ab9801e4e52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index c4b1bd9de693,f9186f283488..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -135,8 -131,178 +135,180 @@@ static void free_tcf(struct tc_action *
  	kfree(p);
  }
  
++<<<<<<< HEAD
++=======
+ static void offload_action_hw_count_set(struct tc_action *act,
+ 					u32 hw_count)
+ {
+ 	act->in_hw_count = hw_count;
+ }
+ 
+ static unsigned int tcf_offload_act_num_actions_single(struct tc_action *act)
+ {
+ 	if (is_tcf_pedit(act))
+ 		return tcf_pedit_nkeys(act);
+ 	else
+ 		return 1;
+ }
+ 
+ static bool tc_act_skip_hw(u32 flags)
+ {
+ 	return (flags & TCA_ACT_FLAGS_SKIP_HW) ? true : false;
+ }
+ 
+ static bool tc_act_skip_sw(u32 flags)
+ {
+ 	return (flags & TCA_ACT_FLAGS_SKIP_SW) ? true : false;
+ }
+ 
+ static bool tc_act_in_hw(struct tc_action *act)
+ {
+ 	return !!act->in_hw_count;
+ }
+ 
+ /* SKIP_HW and SKIP_SW are mutually exclusive flags. */
+ static bool tc_act_flags_valid(u32 flags)
+ {
+ 	flags &= TCA_ACT_FLAGS_SKIP_HW | TCA_ACT_FLAGS_SKIP_SW;
+ 
+ 	return flags ^ (TCA_ACT_FLAGS_SKIP_HW | TCA_ACT_FLAGS_SKIP_SW);
+ }
+ 
+ static int offload_action_init(struct flow_offload_action *fl_action,
+ 			       struct tc_action *act,
+ 			       enum offload_act_command  cmd,
+ 			       struct netlink_ext_ack *extack)
+ {
+ 	fl_action->extack = extack;
+ 	fl_action->command = cmd;
+ 	fl_action->index = act->tcfa_index;
+ 
+ 	if (act->ops->offload_act_setup)
+ 		return act->ops->offload_act_setup(act, fl_action, NULL, false);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static int tcf_action_offload_cmd(struct flow_offload_action *fl_act,
+ 				  u32 *hw_count,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	int err;
+ 
+ 	err = flow_indr_dev_setup_offload(NULL, NULL, TC_SETUP_ACT,
+ 					  fl_act, NULL, NULL);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (hw_count)
+ 		*hw_count = err;
+ 
+ 	return 0;
+ }
+ 
+ /* offload the tc action after it is inserted */
+ static int tcf_action_offload_add(struct tc_action *action,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	bool skip_sw = tc_act_skip_sw(action->tcfa_flags);
+ 	struct tc_action *actions[TCA_ACT_MAX_PRIO] = {
+ 		[0] = action,
+ 	};
+ 	struct flow_offload_action *fl_action;
+ 	u32 in_hw_count = 0;
+ 	int num, err = 0;
+ 
+ 	if (tc_act_skip_hw(action->tcfa_flags))
+ 		return 0;
+ 
+ 	num = tcf_offload_act_num_actions_single(action);
+ 	fl_action = offload_action_alloc(num);
+ 	if (!fl_action)
+ 		return -ENOMEM;
+ 
+ 	err = offload_action_init(fl_action, action, FLOW_ACT_REPLACE, extack);
+ 	if (err)
+ 		goto fl_err;
+ 
+ 	err = tc_setup_action(&fl_action->action, actions);
+ 	if (err) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Failed to setup tc actions for offload\n");
+ 		goto fl_err;
+ 	}
+ 
+ 	err = tcf_action_offload_cmd(fl_action, &in_hw_count, extack);
+ 	if (!err)
+ 		offload_action_hw_count_set(action, in_hw_count);
+ 
+ 	if (skip_sw && !tc_act_in_hw(action))
+ 		err = -EINVAL;
+ 
+ 	tc_cleanup_offload_action(&fl_action->action);
+ 
+ fl_err:
+ 	kfree(fl_action);
+ 
+ 	return err;
+ }
+ 
+ int tcf_action_update_hw_stats(struct tc_action *action)
+ {
+ 	struct flow_offload_action fl_act = {};
+ 	int err;
+ 
+ 	if (!tc_act_in_hw(action))
+ 		return -EOPNOTSUPP;
+ 
+ 	err = offload_action_init(&fl_act, action, FLOW_ACT_STATS, NULL);
+ 	if (err)
+ 		return err;
+ 
+ 	err = tcf_action_offload_cmd(&fl_act, NULL, NULL);
+ 	if (!err) {
+ 		preempt_disable();
+ 		tcf_action_stats_update(action, fl_act.stats.bytes,
+ 					fl_act.stats.pkts,
+ 					fl_act.stats.drops,
+ 					fl_act.stats.lastused,
+ 					true);
+ 		preempt_enable();
+ 		action->used_hw_stats = fl_act.stats.used_hw_stats;
+ 		action->used_hw_stats_valid = true;
+ 	} else {
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(tcf_action_update_hw_stats);
+ 
+ static int tcf_action_offload_del(struct tc_action *action)
+ {
+ 	struct flow_offload_action fl_act = {};
+ 	u32 in_hw_count = 0;
+ 	int err = 0;
+ 
+ 	if (!tc_act_in_hw(action))
+ 		return 0;
+ 
+ 	err = offload_action_init(&fl_act, action, FLOW_ACT_DESTROY, NULL);
+ 	if (err)
+ 		return err;
+ 
+ 	err = tcf_action_offload_cmd(&fl_act, &in_hw_count, NULL);
+ 	if (err)
+ 		return err;
+ 
+ 	if (action->in_hw_count != in_hw_count)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c7a66f8d8a94 (flow_offload: add process to update action stats from hardware)
  static void tcf_action_cleanup(struct tc_action *p)
  {
 -	tcf_action_offload_del(p);
  	if (p->ops->cleanup)
  		p->ops->cleanup(p);
  
diff --git a/include/net/act_api.h b/include/net/act_api.h
index b5b624c7e488..171415c6fd99 100644
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@ -240,6 +240,7 @@ void tcf_action_update_stats(struct tc_action *a, u64 bytes, u64 packets,
 			     u64 drops, bool hw);
 int tcf_action_copy_stats(struct sk_buff *, struct tc_action *, int);
 
+int tcf_action_update_hw_stats(struct tc_action *action);
 int tcf_action_check_ctrlact(int action, struct tcf_proto *tp,
 			     struct tcf_chain **handle,
 			     struct netlink_ext_ack *newchain);
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index 09413867d820..09817dcf80a9 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -266,18 +266,20 @@ tcf_exts_hw_stats_update(const struct tcf_exts *exts,
 #ifdef CONFIG_NET_CLS_ACT
 	int i;
 
-	preempt_disable();
-
 	for (i = 0; i < exts->nr_actions; i++) {
 		struct tc_action *a = exts->actions[i];
 
-		tcf_action_stats_update(a, bytes, packets, drops,
-					lastuse, true);
-		a->used_hw_stats = used_hw_stats;
-		a->used_hw_stats_valid = used_hw_stats_valid;
-	}
+		/* if stats from hw, just skip */
+		if (tcf_action_update_hw_stats(a)) {
+			preempt_disable();
+			tcf_action_stats_update(a, bytes, packets, drops,
+						lastuse, true);
+			preempt_enable();
 
-	preempt_enable();
+			a->used_hw_stats = used_hw_stats;
+			a->used_hw_stats_valid = used_hw_stats_valid;
+		}
+	}
 #endif
 }
 
* Unmerged path net/sched/act_api.c
