s390/vtime: Use the generic IRQ entry accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Frederic Weisbecker <frederic@kernel.org>
commit 2b91ec9f551b56751cde48792f1c0a1130358844
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2b91ec9f.failed

s390 has its own version of IRQ entry accounting because it doesn't
account the idle time the same way the other architectures do. Only
the actual idle sleep time is accounted as idle time, the rest of the
idle task execution is accounted as system time.

Make the generic IRQ entry accounting aware of architectures that have
their own way of accounting idle time and convert s390 to use it.

This prepares s390 to get involved in further consolidations of IRQ
time accounting.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201202115732.27827-3-frederic@kernel.org

(cherry picked from commit 2b91ec9f551b56751cde48792f1c0a1130358844)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/Kconfig
diff --cc arch/s390/Kconfig
index 53b3712d90ef,6f1fdcd3b5db..000000000000
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@@ -168,9 -180,19 +168,15 @@@ config S39
  	select HAVE_RSEQ
  	select HAVE_SYSCALL_TRACEPOINTS
  	select HAVE_VIRT_CPU_ACCOUNTING
++<<<<<<< HEAD
++=======
+ 	select HAVE_VIRT_CPU_ACCOUNTING_IDLE
+ 	select IOMMU_HELPER		if PCI
+ 	select IOMMU_SUPPORT		if PCI
++>>>>>>> 2b91ec9f551b (s390/vtime: Use the generic IRQ entry accounting)
  	select MODULES_USE_ELF_RELA
 -	select NEED_DMA_MAP_STATE	if PCI
 -	select NEED_SG_DMA_LENGTH	if PCI
  	select OLD_SIGACTION
  	select OLD_SIGSUSPEND3
 -	select PCI_DOMAINS		if PCI
 -	select PCI_MSI			if PCI
 -	select PCI_MSI_ARCH_FALLBACKS	if PCI_MSI
 -	select SET_FS
  	select SPARSE_IRQ
  	select SYSCTL_EXCEPTION_TRACE
  	select THREAD_INFO_IN_TASK
diff --git a/arch/Kconfig b/arch/Kconfig
index 1e486125c2eb..8a4a583bfb01 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -692,6 +692,12 @@ config HAVE_CONTEXT_TRACKING
 config HAVE_VIRT_CPU_ACCOUNTING
 	bool
 
+config HAVE_VIRT_CPU_ACCOUNTING_IDLE
+	bool
+	help
+	  Architecture has its own way to account idle CPU time and therefore
+	  doesn't implement vtime_account_idle().
+
 config ARCH_HAS_SCALED_CPUTIME
 	bool
 
@@ -706,7 +712,6 @@ config HAVE_VIRT_CPU_ACCOUNTING_GEN
 	  some 32-bit arches may require multiple accesses, so proper
 	  locking is needed to protect against concurrent accesses.
 
-
 config HAVE_IRQ_TIME_ACCOUNTING
 	bool
 	help
* Unmerged path arch/s390/Kconfig
diff --git a/arch/s390/include/asm/vtime.h b/arch/s390/include/asm/vtime.h
index 3622d4ebc73a..fac6a67988eb 100644
--- a/arch/s390/include/asm/vtime.h
+++ b/arch/s390/include/asm/vtime.h
@@ -2,7 +2,6 @@
 #ifndef _S390_VTIME_H
 #define _S390_VTIME_H
 
-#define __ARCH_HAS_VTIME_ACCOUNT
 #define __ARCH_HAS_VTIME_TASK_SWITCH
 
 #endif /* _S390_VTIME_H */
diff --git a/arch/s390/kernel/vtime.c b/arch/s390/kernel/vtime.c
index 0d6593f42845..c42801bf2ae8 100644
--- a/arch/s390/kernel/vtime.c
+++ b/arch/s390/kernel/vtime.c
@@ -247,10 +247,6 @@ void vtime_account_kernel(struct task_struct *tsk)
 }
 EXPORT_SYMBOL_GPL(vtime_account_kernel);
 
-void vtime_account_irq_enter(struct task_struct *tsk)
-__attribute__((alias("vtime_account_kernel")));
-
-
 /*
  * Sorted add to a list. List is linear searched until first bigger
  * element is found.
diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c
index f39744545731..f022fe0d0622 100644
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@ -418,23 +418,14 @@ void vtime_task_switch(struct task_struct *prev)
 }
 # endif
 
-/*
- * Archs that account the whole time spent in the idle task
- * (outside irq) as idle time can rely on this and just implement
- * vtime_account_kernel() and vtime_account_idle(). Archs that
- * have other meaning of the idle time (s390 only includes the
- * time spent by the CPU when it's in low power mode) must override
- * vtime_account().
- */
-#ifndef __ARCH_HAS_VTIME_ACCOUNT
 void vtime_account_irq_enter(struct task_struct *tsk)
 {
-	if (!in_interrupt() && is_idle_task(tsk))
+	if (!IS_ENABLED(CONFIG_HAVE_VIRT_CPU_ACCOUNTING_IDLE) &&
+	    !in_interrupt() && is_idle_task(tsk))
 		vtime_account_idle(tsk);
 	else
 		vtime_account_kernel(tsk);
 }
-#endif /* __ARCH_HAS_VTIME_ACCOUNT */
 
 void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,
 		    u64 *ut, u64 *st)
