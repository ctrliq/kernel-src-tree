net/mlx5e: Test CT and SAMPLE on flow attr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 84ba8062e383c4a4f8f6388d1cfc87328f2a6115
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/84ba8062.failed

Currently the mlx5_flow object contains a single mlx5_attr instance.
However, multi table actions (e.g. CT) instantiate multiple attr instances.
Prepare for multiple attr instances by testing for CT or SAMPLE flag on attr
flags instead of flow flag.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Reviewed-by: Chris Mi <cmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 84ba8062e383c4a4f8f6388d1cfc87328f2a6115)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index e11d6f95f302,31fdc8192879..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1161,26 -1206,12 +1213,29 @@@ mlx5e_tc_offload_fdb_rules(struct mlx5_
  			   struct mlx5_flow_spec *spec,
  			   struct mlx5_flow_attr *attr)
  {
- 	struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts;
  	struct mlx5_flow_handle *rule;
  
 -	if (attr->flags & MLX5_ATTR_FLAG_SLOW_PATH)
 +	if (attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH)
  		return mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
  
++<<<<<<< HEAD
 +	if (flow_flag_test(flow, CT)) {
 +		mod_hdr_acts = &attr->parse_attr->mod_hdr_acts;
 +
 +		rule = mlx5_tc_ct_flow_offload(get_ct_priv(flow->priv),
 +					       flow, spec, attr,
 +					       mod_hdr_acts);
 +#if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
 +	} else if (flow_flag_test(flow, SAMPLE)) {
 +		rule = mlx5e_tc_sample_offload(get_sample_priv(flow->priv), spec, attr,
 +					       mlx5e_tc_get_flow_tun_id(flow));
 +#endif
 +	} else {
 +		rule = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
 +	}
++=======
+ 	rule = mlx5e_tc_rule_offload(flow->priv, flow, spec, attr);
++>>>>>>> 84ba8062e383 (net/mlx5e: Test CT and SAMPLE on flow attr)
  
  	if (IS_ERR(rule))
  		return rule;
@@@ -1205,21 -1235,13 +1259,30 @@@ void mlx5e_tc_unoffload_fdb_rules(struc
  {
  	flow_flag_clear(flow, OFFLOADED);
  
++<<<<<<< HEAD
 +	if (attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH)
 +		goto offload_rule_0;
++=======
+ 	if (attr->flags & MLX5_ATTR_FLAG_SLOW_PATH)
+ 		return mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
++>>>>>>> 84ba8062e383 (net/mlx5e: Test CT and SAMPLE on flow attr)
  
  	if (attr->esw_attr->split_count)
  		mlx5_eswitch_del_fwd_rule(esw, flow->rule[1], attr);
  
++<<<<<<< HEAD
 +	if (flow_flag_test(flow, CT))
 +		mlx5_tc_ct_delete_flow(get_ct_priv(flow->priv), flow, attr);
 +#if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
 +	else if (flow_flag_test(flow, SAMPLE))
 +		mlx5e_tc_sample_unoffload(get_sample_priv(flow->priv), flow->rule[0], attr);
 +#endif
 +	else
 +offload_rule_0:
 +		mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
++=======
+ 	mlx5e_tc_rule_unoffload(flow->priv, flow, attr);
++>>>>>>> 84ba8062e383 (net/mlx5e: Test CT and SAMPLE on flow attr)
  }
  
  struct mlx5_flow_handle *
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index fb629ee12aff,722702be7e91..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -90,6 -89,23 +90,26 @@@ struct mlx5_flow_attr 
  	};
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	MLX5_ATTR_FLAG_VLAN_HANDLED  = BIT(0),
+ 	MLX5_ATTR_FLAG_SLOW_PATH     = BIT(1),
+ 	MLX5_ATTR_FLAG_NO_IN_PORT    = BIT(2),
+ 	MLX5_ATTR_FLAG_SRC_REWRITE   = BIT(3),
+ 	MLX5_ATTR_FLAG_SAMPLE        = BIT(4),
+ 	MLX5_ATTR_FLAG_ACCEPT        = BIT(5),
+ 	MLX5_ATTR_FLAG_CT            = BIT(6),
+ };
+ 
+ /* Returns true if any of the flags that require skipping further TC/NF processing are set. */
+ static inline bool
+ mlx5e_tc_attr_flags_skip(u32 attr_flags)
+ {
+ 	return attr_flags & (MLX5_ATTR_FLAG_SLOW_PATH | MLX5_ATTR_FLAG_ACCEPT);
+ }
+ 
++>>>>>>> 84ba8062e383 (net/mlx5e: Test CT and SAMPLE on flow attr)
  struct mlx5_rx_tun_attr {
  	u16 decap_vport;
  	union {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 44eb1654e679,2b31d8bbd1b8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -464,10 -463,11 +464,16 @@@ esw_setup_dests(struct mlx5_flow_destin
  
  	if (!mlx5_eswitch_termtbl_required(esw, attr, flow_act, spec) &&
  	    esw_src_port_rewrite_supported(esw))
 -		attr->flags |= MLX5_ATTR_FLAG_SRC_REWRITE;
 +		attr->flags |= MLX5_ESW_ATTR_FLAG_SRC_REWRITE;
  
++<<<<<<< HEAD
 +	if (attr->flags & MLX5_ESW_ATTR_FLAG_SAMPLE) {
 +		esw_setup_sampler_dest(dest, flow_act, attr, *i);
++=======
+ 	if (attr->flags & MLX5_ATTR_FLAG_SAMPLE &&
+ 	    !(attr->flags & MLX5_ATTR_FLAG_SLOW_PATH)) {
+ 		esw_setup_sampler_dest(dest, flow_act, attr->sample_attr.sampler_id, *i);
++>>>>>>> 84ba8062e383 (net/mlx5e: Test CT and SAMPLE on flow attr)
  		(*i)++;
  	} else if (attr->dest_ft) {
  		esw_setup_ft_dest(dest, flow_act, esw, attr, spec, *i);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
index 31b4e39be2d3..9e0e229cf164 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
@@ -101,6 +101,7 @@ mlx5e_tc_post_act_add(struct mlx5e_post_act *post_act, struct mlx5_flow_attr *at
 	post_attr->inner_match_level = MLX5_MATCH_NONE;
 	post_attr->outer_match_level = MLX5_MATCH_NONE;
 	post_attr->action &= ~(MLX5_FLOW_CONTEXT_ACTION_DECAP);
+	post_attr->flags &= ~MLX5_ATTR_FLAG_SAMPLE;
 
 	handle->ns_type = post_act->ns_type;
 	/* Splits were handled before post action */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
index b689701ac7d8..6fb672525044 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
@@ -107,6 +107,17 @@ struct mlx5e_tc_flow {
 	struct mlx5_flow_attr *attr;
 };
 
+struct mlx5_flow_handle *
+mlx5e_tc_rule_offload(struct mlx5e_priv *priv,
+		      struct mlx5e_tc_flow *flow,
+		      struct mlx5_flow_spec *spec,
+		      struct mlx5_flow_attr *attr);
+
+void
+mlx5e_tc_rule_unoffload(struct mlx5e_priv *priv,
+			struct mlx5e_tc_flow *flow,
+			struct mlx5_flow_attr *attr);
+
 u8 mlx5e_tc_get_ip_version(struct mlx5_flow_spec *spec, bool outer);
 
 struct mlx5_flow_handle *
@@ -165,6 +176,7 @@ struct mlx5_flow_handle *
 mlx5e_tc_offload_to_slow_path(struct mlx5_eswitch *esw,
 			      struct mlx5e_tc_flow *flow,
 			      struct mlx5_flow_spec *spec);
+
 void mlx5e_tc_unoffload_fdb_rules(struct mlx5_eswitch *esw,
 				  struct mlx5e_tc_flow *flow,
 				  struct mlx5_flow_attr *attr);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
