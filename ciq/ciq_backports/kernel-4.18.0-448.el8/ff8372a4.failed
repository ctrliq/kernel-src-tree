net: skb: move enum skb_drop_reason to standalone header file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit ff8372a467fa28752610f57a6512c5365413faa2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ff8372a4.failed

As the skb drop reasons are getting more and more, move the enum
'skb_drop_reason' and related function to the standalone header
'dropreason.h', as Jakub Kicinski suggested.

	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit ff8372a467fa28752610f57a6512c5365413faa2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 4150b3abe191,82edf0359ab3..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -39,57 -36,74 +39,66 @@@
  #include <linux/splice.h>
  #include <linux/in6.h>
  #include <linux/if_packet.h>
 -#include <linux/llist.h>
  #include <net/flow.h>
++<<<<<<< HEAD
++=======
+ #include <net/page_pool.h>
+ #if IS_ENABLED(CONFIG_NF_CONNTRACK)
+ #include <linux/netfilter/nf_conntrack_common.h>
+ #endif
+ #include <net/net_debug.h>
+ #include <net/dropreason.h>
++>>>>>>> ff8372a467fa (net: skb: move enum skb_drop_reason to standalone header file)
  
 -/**
 - * DOC: skb checksums
 - *
 - * The interface for checksum offload between the stack and networking drivers
 +#include <linux/rh_kabi.h>
 +
 +/* The interface for checksum offload between the stack and networking drivers
   * is as follows...
   *
 - * IP checksum related features
 - * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 + * A. IP checksum related features
   *
   * Drivers advertise checksum offload capabilities in the features of a device.
 - * From the stack's point of view these are capabilities offered by the driver.
 - * A driver typically only advertises features that it is capable of offloading
 + * From the stack's point of view these are capabilities offered by the driver,
 + * a driver typically only advertises features that it is capable of offloading
   * to its device.
   *
 - * .. flat-table:: Checksum related device features
 - *   :widths: 1 10
 - *
 - *   * - %NETIF_F_HW_CSUM
 - *     - The driver (or its device) is able to compute one
 - *	 IP (one's complement) checksum for any combination
 - *	 of protocols or protocol layering. The checksum is
 - *	 computed and set in a packet per the CHECKSUM_PARTIAL
 - *	 interface (see below).
 - *
 - *   * - %NETIF_F_IP_CSUM
 - *     - Driver (device) is only able to checksum plain
 - *	 TCP or UDP packets over IPv4. These are specifically
 - *	 unencapsulated packets of the form IPv4|TCP or
 - *	 IPv4|UDP where the Protocol field in the IPv4 header
 - *	 is TCP or UDP. The IPv4 header may contain IP options.
 - *	 This feature cannot be set in features for a device
 - *	 with NETIF_F_HW_CSUM also set. This feature is being
 - *	 DEPRECATED (see below).
 - *
 - *   * - %NETIF_F_IPV6_CSUM
 - *     - Driver (device) is only able to checksum plain
 - *	 TCP or UDP packets over IPv6. These are specifically
 - *	 unencapsulated packets of the form IPv6|TCP or
 - *	 IPv6|UDP where the Next Header field in the IPv6
 - *	 header is either TCP or UDP. IPv6 extension headers
 - *	 are not supported with this feature. This feature
 - *	 cannot be set in features for a device with
 - *	 NETIF_F_HW_CSUM also set. This feature is being
 - *	 DEPRECATED (see below).
 - *
 - *   * - %NETIF_F_RXCSUM
 - *     - Driver (device) performs receive checksum offload.
 - *	 This flag is only used to disable the RX checksum
 - *	 feature for a device. The stack will accept receive
 - *	 checksum indication in packets received on a device
 - *	 regardless of whether NETIF_F_RXCSUM is set.
 - *
 - * Checksumming of received packets by device
 - * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 - *
 - * Indication of checksum verification is set in &sk_buff.ip_summed.
 - * Possible values are:
 - *
 - * - %CHECKSUM_NONE
 + * The checksum related features are:
 + *
 + *	NETIF_F_HW_CSUM	- The driver (or its device) is able to compute one
 + *			  IP (one's complement) checksum for any combination
 + *			  of protocols or protocol layering. The checksum is
 + *			  computed and set in a packet per the CHECKSUM_PARTIAL
 + *			  interface (see below).
 + *
 + *	NETIF_F_IP_CSUM - Driver (device) is only able to checksum plain
 + *			  TCP or UDP packets over IPv4. These are specifically
 + *			  unencapsulated packets of the form IPv4|TCP or
 + *			  IPv4|UDP where the Protocol field in the IPv4 header
 + *			  is TCP or UDP. The IPv4 header may contain IP options
 + *			  This feature cannot be set in features for a device
 + *			  with NETIF_F_HW_CSUM also set. This feature is being
 + *			  DEPRECATED (see below).
 + *
 + *	NETIF_F_IPV6_CSUM - Driver (device) is only able to checksum plain
 + *			  TCP or UDP packets over IPv6. These are specifically
 + *			  unencapsulated packets of the form IPv6|TCP or
 + *			  IPv4|UDP where the Next Header field in the IPv6
 + *			  header is either TCP or UDP. IPv6 extension headers
 + *			  are not supported with this feature. This feature
 + *			  cannot be set in features for a device with
 + *			  NETIF_F_HW_CSUM also set. This feature is being
 + *			  DEPRECATED (see below).
 + *
 + *	NETIF_F_RXCSUM - Driver (device) performs receive checksum offload.
 + *			 This flag is used only used to disable the RX checksum
 + *			 feature for a device. The stack will accept receive
 + *			 checksum indication in packets received on a device
 + *			 regardless of whether NETIF_F_RXCSUM is set.
 + *
 + * B. Checksumming of received packets by device. Indication of checksum
 + *    verification is in set skb->ip_summed. Possible values are:
 + *
 + * CHECKSUM_NONE:
   *
   *   Device did not checksum this packet e.g. due to lack of capabilities.
   *   The packet contains full (though not verified) checksum in packet but
@@@ -311,30 -338,6 +320,33 @@@ struct sk_buff_head 
  
  struct sk_buff;
  
++<<<<<<< HEAD
 +/* The reason of skb drop, which is used in kfree_skb_reason().
 + * en...maybe they should be splited by group?
 + *
 + * Each item here should also be in 'TRACE_SKB_DROP_REASON', which is
 + * used to translate the reason to string.
 + */
 +enum skb_drop_reason {
 +	SKB_DROP_REASON_NOT_SPECIFIED,
 +	SKB_DROP_REASON_MAX,
 +};
 +
 +#define SKB_DR_INIT(name, reason)				\
 +	enum skb_drop_reason name = SKB_DROP_REASON_##reason
 +#define SKB_DR(name)						\
 +	SKB_DR_INIT(name, NOT_SPECIFIED)
 +#define SKB_DR_SET(name, reason)				\
 +	(name = SKB_DROP_REASON_##reason)
 +#define SKB_DR_OR(name, reason)					\
 +	do {							\
 +		if (name == SKB_DROP_REASON_NOT_SPECIFIED ||	\
 +		    name == SKB_NOT_DROPPED_YET)		\
 +			SKB_DR_SET(name, reason);		\
 +	} while (0)
 +
++=======
++>>>>>>> ff8372a467fa (net: skb: move enum skb_drop_reason to standalone header file)
  /* To allow 64K frame to be packed as single skb without frag_list we
   * require 64K/PAGE_SIZE pages plus 1 additional page to allow for
   * buffers which do not start on a page boundary.
* Unmerged path include/linux/skbuff.h
diff --git a/include/net/dropreason.h b/include/net/dropreason.h
new file mode 100644
index 000000000000..ecd18b7b1364
--- /dev/null
+++ b/include/net/dropreason.h
@@ -0,0 +1,184 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _LINUX_DROPREASON_H
+#define _LINUX_DROPREASON_H
+
+/* The reason of skb drop, which is used in kfree_skb_reason().
+ * en...maybe they should be splited by group?
+ *
+ * Each item here should also be in 'TRACE_SKB_DROP_REASON', which is
+ * used to translate the reason to string.
+ */
+enum skb_drop_reason {
+	SKB_NOT_DROPPED_YET = 0,
+	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+					 * host (interface is in promisc
+					 * mode)
+					 */
+	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+					 * IP header (see
+					 * IPSTATS_MIB_INHDRERRORS)
+					 */
+	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+					 * see the document for rp_filter
+					 * in ip-sysctl.rst for more
+					 * information
+					 */
+	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+						  * is multicast, but L3 is
+						  * unicast.
+						  */
+	SKB_DROP_REASON_XFRM_POLICY,	/* xfrm policy check failed */
+	SKB_DROP_REASON_IP_NOPROTO,	/* no support for IP protocol */
+	SKB_DROP_REASON_SOCKET_RCVBUFF,	/* socket receive buff is full */
+	SKB_DROP_REASON_PROTO_MEM,	/* proto memory limition, such as
+					 * udp packet drop out of
+					 * udp_memory_allocated.
+					 */
+	SKB_DROP_REASON_TCP_MD5NOTFOUND,	/* no MD5 hash and one
+						 * expected, corresponding
+						 * to LINUX_MIB_TCPMD5NOTFOUND
+						 */
+	SKB_DROP_REASON_TCP_MD5UNEXPECTED,	/* MD5 hash and we're not
+						 * expecting one, corresponding
+						 * to LINUX_MIB_TCPMD5UNEXPECTED
+						 */
+	SKB_DROP_REASON_TCP_MD5FAILURE,	/* MD5 hash and its wrong,
+					 * corresponding to
+					 * LINUX_MIB_TCPMD5FAILURE
+					 */
+	SKB_DROP_REASON_SOCKET_BACKLOG,	/* failed to add skb to socket
+					 * backlog (see
+					 * LINUX_MIB_TCPBACKLOGDROP)
+					 */
+	SKB_DROP_REASON_TCP_FLAGS,	/* TCP flags invalid */
+	SKB_DROP_REASON_TCP_ZEROWINDOW,	/* TCP receive window size is zero,
+					 * see LINUX_MIB_TCPZEROWINDOWDROP
+					 */
+	SKB_DROP_REASON_TCP_OLD_DATA,	/* the TCP data reveived is already
+					 * received before (spurious retrans
+					 * may happened), see
+					 * LINUX_MIB_DELAYEDACKLOST
+					 */
+	SKB_DROP_REASON_TCP_OVERWINDOW,	/* the TCP data is out of window,
+					 * the seq of the first byte exceed
+					 * the right edges of receive
+					 * window
+					 */
+	SKB_DROP_REASON_TCP_OFOMERGE,	/* the data of skb is already in
+					 * the ofo queue, corresponding to
+					 * LINUX_MIB_TCPOFOMERGE
+					 */
+	SKB_DROP_REASON_TCP_RFC7323_PAWS, /* PAWS check, corresponding to
+					   * LINUX_MIB_PAWSESTABREJECTED
+					   */
+	SKB_DROP_REASON_TCP_INVALID_SEQUENCE, /* Not acceptable SEQ field */
+	SKB_DROP_REASON_TCP_RESET,	/* Invalid RST packet */
+	SKB_DROP_REASON_TCP_INVALID_SYN, /* Incoming packet has unexpected SYN flag */
+	SKB_DROP_REASON_TCP_CLOSE,	/* TCP socket in CLOSE state */
+	SKB_DROP_REASON_TCP_FASTOPEN,	/* dropped by FASTOPEN request socket */
+	SKB_DROP_REASON_TCP_OLD_ACK,	/* TCP ACK is old, but in window */
+	SKB_DROP_REASON_TCP_TOO_OLD_ACK, /* TCP ACK is too old */
+	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA, /* TCP ACK for data we haven't sent yet */
+	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE, /* pruned from TCP OFO queue */
+	SKB_DROP_REASON_TCP_OFO_DROP,	/* data already in receive queue */
+	SKB_DROP_REASON_IP_OUTNOROUTES,	/* route lookup failed */
+	SKB_DROP_REASON_BPF_CGROUP_EGRESS,	/* dropped by
+						 * BPF_PROG_TYPE_CGROUP_SKB
+						 * eBPF program
+						 */
+	SKB_DROP_REASON_IPV6DISABLED,	/* IPv6 is disabled on the device */
+	SKB_DROP_REASON_NEIGH_CREATEFAIL,	/* failed to create neigh
+						 * entry
+						 */
+	SKB_DROP_REASON_NEIGH_FAILED,	/* neigh entry in failed state */
+	SKB_DROP_REASON_NEIGH_QUEUEFULL,	/* arp_queue for neigh
+						 * entry is full
+						 */
+	SKB_DROP_REASON_NEIGH_DEAD,	/* neigh entry is dead */
+	SKB_DROP_REASON_TC_EGRESS,	/* dropped in TC egress HOOK */
+	SKB_DROP_REASON_QDISC_DROP,	/* dropped by qdisc when packet
+					 * outputting (failed to enqueue to
+					 * current qdisc)
+					 */
+	SKB_DROP_REASON_CPU_BACKLOG,	/* failed to enqueue the skb to
+					 * the per CPU backlog queue. This
+					 * can be caused by backlog queue
+					 * full (see netdev_max_backlog in
+					 * net.rst) or RPS flow limit
+					 */
+	SKB_DROP_REASON_XDP,		/* dropped by XDP in input path */
+	SKB_DROP_REASON_TC_INGRESS,	/* dropped in TC ingress HOOK */
+	SKB_DROP_REASON_UNHANDLED_PROTO,	/* protocol not implemented
+						 * or not supported
+						 */
+	SKB_DROP_REASON_SKB_CSUM,	/* sk_buff checksum computation
+					 * error
+					 */
+	SKB_DROP_REASON_SKB_GSO_SEG,	/* gso segmentation error */
+	SKB_DROP_REASON_SKB_UCOPY_FAULT,	/* failed to copy data from
+						 * user space, e.g., via
+						 * zerocopy_sg_from_iter()
+						 * or skb_orphan_frags_rx()
+						 */
+	SKB_DROP_REASON_DEV_HDR,	/* device driver specific
+					 * header/metadata is invalid
+					 */
+	/* the device is not ready to xmit/recv due to any of its data
+	 * structure that is not up/ready/initialized, e.g., the IFF_UP is
+	 * not set, or driver specific tun->tfiles[txq] is not initialized
+	 */
+	SKB_DROP_REASON_DEV_READY,
+	SKB_DROP_REASON_FULL_RING,	/* ring buffer is full */
+	SKB_DROP_REASON_NOMEM,		/* error due to OOM */
+	SKB_DROP_REASON_HDR_TRUNC,      /* failed to trunc/extract the header
+					 * from networking data, e.g., failed
+					 * to pull the protocol header from
+					 * frags via pskb_may_pull()
+					 */
+	SKB_DROP_REASON_TAP_FILTER,     /* dropped by (ebpf) filter directly
+					 * attached to tun/tap, e.g., via
+					 * TUNSETFILTEREBPF
+					 */
+	SKB_DROP_REASON_TAP_TXFILTER,	/* dropped by tx filter implemented
+					 * at tun/tap, e.g., check_filter()
+					 */
+	SKB_DROP_REASON_ICMP_CSUM,	/* ICMP checksum error */
+	SKB_DROP_REASON_INVALID_PROTO,	/* the packet doesn't follow RFC
+					 * 2211, such as a broadcasts
+					 * ICMP_TIMESTAMP
+					 */
+	SKB_DROP_REASON_IP_INADDRERRORS,	/* host unreachable, corresponding
+						 * to IPSTATS_MIB_INADDRERRORS
+						 */
+	SKB_DROP_REASON_IP_INNOROUTES,	/* network unreachable, corresponding
+					 * to IPSTATS_MIB_INADDRERRORS
+					 */
+	SKB_DROP_REASON_PKT_TOO_BIG,	/* packet size is too big (maybe exceed
+					 * the MTU)
+					 */
+	SKB_DROP_REASON_MAX,
+};
+
+#define SKB_DR_INIT(name, reason)				\
+	enum skb_drop_reason name = SKB_DROP_REASON_##reason
+#define SKB_DR(name)						\
+	SKB_DR_INIT(name, NOT_SPECIFIED)
+#define SKB_DR_SET(name, reason)				\
+	(name = SKB_DROP_REASON_##reason)
+#define SKB_DR_OR(name, reason)					\
+	do {							\
+		if (name == SKB_DROP_REASON_NOT_SPECIFIED ||	\
+		    name == SKB_NOT_DROPPED_YET)		\
+			SKB_DR_SET(name, reason);		\
+	} while (0)
+
+#endif
