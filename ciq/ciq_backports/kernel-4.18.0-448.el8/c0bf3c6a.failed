mptcp: move subflow cleanup in mptcp_destroy_common()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit c0bf3c6aa444a5ef44acc57ef6cfa53fd4fc1c9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c0bf3c6a.failed

If the mptcp socket creation fails due to a CGROUP_INET_SOCK_CREATE
eBPF program, the MPTCP protocol ends-up leaking all the subflows:
the related cleanup happens in __mptcp_destroy_sock() that is not
invoked in such code path.

Address the issue moving the subflow sockets cleanup in the
mptcp_destroy_common() helper, which is invoked in every msk cleanup
path.

Additionally get rid of the intermediate list_splice_init step, which
is an unneeded relic from the past.

The issue is present since before the reported root cause commit, but
any attempt to backport the fix before that hash will require a complete
rewrite.

Fixes: e16163b6e2 ("mptcp: refactor shutdown and close")
	Reported-by: Nguyen Dinh Phi <phind.uet@gmail.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
Co-developed-by: Nguyen Dinh Phi <phind.uet@gmail.com>
	Signed-off-by: Nguyen Dinh Phi <phind.uet@gmail.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c0bf3c6aa444a5ef44acc57ef6cfa53fd4fc1c9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 8a96c9d60dca,07fcc86e1fc9..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -2689,26 -2775,13 +2687,33 @@@ static void __mptcp_destroy_sock(struc
  
  	might_sleep();
  
++<<<<<<< HEAD
 +	/* be sure to always acquire the join list lock, to sync vs
 +	 * mptcp_finish_join().
 +	 */
 +	spin_lock_bh(&msk->join_list_lock);
 +	list_splice_tail_init(&msk->join_list, &msk->conn_list);
 +	spin_unlock_bh(&msk->join_list_lock);
 +	list_splice_init(&msk->conn_list, &conn_list);
 +
 +	sk_stop_timer(sk, &msk->sk.icsk_retransmit_timer);
 +	sk_stop_timer(sk, &sk->sk_timer);
 +	msk->pm.status = 0;
 +
 +	list_for_each_entry_safe(subflow, tmp, &conn_list, node) {
 +		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
 +		__mptcp_close_ssk(sk, ssk, subflow);
 +	}
 +
++=======
+ 	mptcp_stop_timer(sk);
+ 	sk_stop_timer(sk, &sk->sk_timer);
+ 	msk->pm.status = 0;
+ 
++>>>>>>> c0bf3c6aa444 (mptcp: move subflow cleanup in mptcp_destroy_common())
  	sk->sk_prot->destroy(sk);
  
 -	WARN_ON_ONCE(msk->rmem_fwd_alloc);
 +	WARN_ON_ONCE(msk->wmem_reserved);
  	WARN_ON_ONCE(msk->rmem_released);
  	sk_stream_kill_queues(sk);
  	xfrm_sk_free_policy(sk);
@@@ -2791,18 -2870,37 +2796,51 @@@ static void mptcp_copy_inaddrs(struct s
  
  static int mptcp_disconnect(struct sock *sk, int flags)
  {
++<<<<<<< HEAD
 +	struct mptcp_subflow_context *subflow;
++=======
++>>>>>>> c0bf3c6aa444 (mptcp: move subflow cleanup in mptcp_destroy_common())
  	struct mptcp_sock *msk = mptcp_sk(sk);
  
 -	inet_sk_state_store(sk, TCP_CLOSE);
 +	mptcp_do_flush_join_list(msk);
 +
++<<<<<<< HEAD
 +	mptcp_for_each_subflow(msk, subflow) {
 +		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
  
 +		lock_sock(ssk);
 +		tcp_disconnect(ssk, flags);
 +		release_sock(ssk);
 +	}
++=======
+ 	mptcp_stop_timer(sk);
+ 	sk_stop_timer(sk, &sk->sk_timer);
+ 
+ 	if (mptcp_sk(sk)->token)
+ 		mptcp_event(MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL);
+ 
+ 	/* msk->subflow is still intact, the following will not free the first
+ 	 * subflow
+ 	 */
+ 	mptcp_destroy_common(msk, MPTCP_CF_FASTCLOSE);
+ 	msk->last_snd = NULL;
+ 	WRITE_ONCE(msk->flags, 0);
+ 	msk->cb_flags = 0;
+ 	msk->push_pending = 0;
+ 	msk->recovery = false;
+ 	msk->can_ack = false;
+ 	msk->fully_established = false;
+ 	msk->rcv_data_fin = false;
+ 	msk->snd_data_fin_enable = false;
+ 	msk->rcv_fastclose = false;
+ 	msk->use_64bit_ack = false;
+ 	WRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk)));
+ 	mptcp_pm_data_reset(msk);
+ 	mptcp_ca_reset(sk);
+ 
+ 	sk->sk_shutdown = 0;
+ 	sk_error_report(sk);
++>>>>>>> c0bf3c6aa444 (mptcp: move subflow cleanup in mptcp_destroy_common())
  	return 0;
  }
  
@@@ -2939,12 -3040,25 +2978,16 @@@ void mptcp_destroy_common(struct mptcp_
  
  	__mptcp_clear_xmit(sk);
  
+ 	/* join list will be eventually flushed (with rst) at sock lock release time */
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node)
+ 		__mptcp_close_ssk(sk, mptcp_subflow_tcp_sock(subflow), subflow, flags);
+ 
  	/* move to sk_receive_queue, sk_stream_kill_queues will purge it */
 -	mptcp_data_lock(sk);
  	skb_queue_splice_tail_init(&msk->receive_queue, &sk->sk_receive_queue);
 -	__skb_queue_purge(&sk->sk_receive_queue);
 -	skb_rbtree_purge(&msk->out_of_order_queue);
 -	mptcp_data_unlock(sk);
  
 -	/* move all the rx fwd alloc into the sk_mem_reclaim_final in
 -	 * inet_sock_destruct() will dispose it
 -	 */
 -	sk->sk_forward_alloc += msk->rmem_fwd_alloc;
 -	msk->rmem_fwd_alloc = 0;
 +	skb_rbtree_purge(&msk->out_of_order_queue);
  	mptcp_token_destroy(msk);
  	mptcp_pm_free_anno_list(msk);
 -	mptcp_free_local_addr_list(msk);
  }
  
  static void mptcp_destroy(struct sock *sk)
* Unmerged path net/mptcp/protocol.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index 5692024234ee..f0e14496d0cd 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -655,7 +655,7 @@ static inline void mptcp_write_space(struct sock *sk)
 	}
 }
 
-void mptcp_destroy_common(struct mptcp_sock *msk);
+void mptcp_destroy_common(struct mptcp_sock *msk, unsigned int flags);
 
 #define MPTCP_TOKEN_MAX_RETRIES	4
 
diff --git a/net/mptcp/subflow.c b/net/mptcp/subflow.c
index 0baf49c03770..743017321672 100644
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@ -570,7 +570,8 @@ static void mptcp_sock_destruct(struct sock *sk)
 		sock_orphan(sk);
 	}
 
-	mptcp_destroy_common(mptcp_sk(sk));
+	/* We don't need to clear msk->subflow, as it's still NULL at this point */
+	mptcp_destroy_common(mptcp_sk(sk), 0);
 	inet_sock_destruct(sk);
 }
 
