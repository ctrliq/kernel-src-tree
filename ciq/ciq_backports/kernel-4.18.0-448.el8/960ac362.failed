s390/pci: allow zPCI zbus without a function zero

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 960ac362648780469b2f5584bb8cff540444d119
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/960ac362.failed

Currently the zPCI code blocks PCI bus creation and probing of a zPCI zbus
unless there is a PCI function with devfn 0. This is always the case for
the PCI functions with hidden RID, but may keep PCI functions from a
multi-function PCI device with RID information invisible until the function
0 becomes visible. Worse, as a PCI bus is necessary to even present a PCI
hotplug slot, even that remains invisible.

With the probing of these so-called isolated PCI functions enabled for s390
in common code, this restriction is no longer necessary. On network cards
with multiple ports and a PF per port this also allows using each port on
its own while still providing the physical PCI topology information in the
devfn needed to associate VFs with their parent PF.

Link: https://lore.kernel.org/r/20220628143100.3228092-6-schnelle@linux.ibm.com
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
(cherry picked from commit 960ac362648780469b2f5584bb8cff540444d119)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_bus.c
diff --cc arch/s390/pci/pci_bus.c
index be52bf47165d,6a8da1b742ae..000000000000
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@@ -29,25 -30,183 +29,204 @@@ static LIST_HEAD(zbus_list)
  static DEFINE_MUTEX(zbus_list_lock);
  static int zpci_nb_devices;
  
++<<<<<<< HEAD
 +/* zpci_bus_scan
 + * @zbus: the zbus holding the zdevices
 + * @ops: the pci operations
 + *
 + * The domain number must be set before pci_scan_root_bus is called.
 + * This function can be called once the domain is known, hence
 + * when the function_0 is dicovered.
 + */
 +static int zpci_bus_scan(struct zpci_bus *zbus, int domain, struct pci_ops *ops)
++=======
+ /* zpci_bus_prepare_device - Prepare a zPCI function for scanning
+  * @zdev: the zPCI function to be prepared
+  *
+  * The PCI resources for the function are set up and added to its zbus and the
+  * function is enabled. The function must be added to a zbus which must have
+  * a PCI bus created. If an error occurs the zPCI function is not enabled.
+  *
+  * Return: 0 on success, an error code otherwise
+  */
+ static int zpci_bus_prepare_device(struct zpci_dev *zdev)
+ {
+ 	struct resource_entry *window, *n;
+ 	struct resource *res;
+ 	int rc;
+ 
+ 	if (!zdev_enabled(zdev)) {
+ 		rc = zpci_enable_device(zdev);
+ 		if (rc)
+ 			return rc;
+ 		rc = zpci_dma_init_device(zdev);
+ 		if (rc) {
+ 			zpci_disable_device(zdev);
+ 			return rc;
+ 		}
+ 	}
+ 
+ 	if (!zdev->has_resources) {
+ 		zpci_setup_bus_resources(zdev, &zdev->zbus->resources);
+ 		resource_list_for_each_entry_safe(window, n, &zdev->zbus->resources) {
+ 			res = window->res;
+ 			pci_bus_add_resource(zdev->zbus->bus, res, 0);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* zpci_bus_scan_device - Scan a single device adding it to the PCI core
+  * @zdev: the zdev to be scanned
+  *
+  * Scans the PCI function making it available to the common PCI code.
+  *
+  * Return: 0 on success, an error value otherwise
+  */
+ int zpci_bus_scan_device(struct zpci_dev *zdev)
+ {
+ 	struct pci_dev *pdev;
+ 	int rc;
+ 
+ 	rc = zpci_bus_prepare_device(zdev);
+ 	if (rc)
+ 		return rc;
+ 
+ 	pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
+ 	if (!pdev)
+ 		return -ENODEV;
+ 
+ 	pci_bus_add_device(pdev);
+ 	pci_lock_rescan_remove();
+ 	pci_bus_add_devices(zdev->zbus->bus);
+ 	pci_unlock_rescan_remove();
+ 
+ 	return 0;
+ }
+ 
+ /* zpci_bus_remove_device - Removes the given zdev from the PCI core
+  * @zdev: the zdev to be removed from the PCI core
+  * @set_error: if true the device's error state is set to permanent failure
+  *
+  * Sets a zPCI device to a configured but offline state; the zPCI
+  * device is still accessible through its hotplug slot and the zPCI
+  * API but is removed from the common code PCI bus, making it
+  * no longer available to drivers.
+  */
+ void zpci_bus_remove_device(struct zpci_dev *zdev, bool set_error)
+ {
+ 	struct zpci_bus *zbus = zdev->zbus;
+ 	struct pci_dev *pdev;
+ 
+ 	if (!zdev->zbus->bus)
+ 		return;
+ 
+ 	pdev = pci_get_slot(zbus->bus, zdev->devfn);
+ 	if (pdev) {
+ 		if (set_error)
+ 			pdev->error_state = pci_channel_io_perm_failure;
+ 		if (pdev->is_virtfn) {
+ 			zpci_iov_remove_virtfn(pdev, zdev->vfn);
+ 			/* balance pci_get_slot */
+ 			pci_dev_put(pdev);
+ 			return;
+ 		}
+ 		pci_stop_and_remove_bus_device_locked(pdev);
+ 		/* balance pci_get_slot */
+ 		pci_dev_put(pdev);
+ 	}
+ }
+ 
+ /* zpci_bus_scan_bus - Scan all configured zPCI functions on the bus
+  * @zbus: the zbus to be scanned
+  *
+  * Enables and scans all PCI functions on the bus making them available to the
+  * common PCI code. If there is no function 0 on the zbus nothing is scanned. If
+  * a function does not have a slot yet because it was added to the zbus before
+  * function 0 the slot is created. If a PCI function fails to be initialized
+  * an error will be returned but attempts will still be made for all other
+  * functions on the bus.
+  *
+  * Return: 0 on success, an error value otherwise
+  */
+ int zpci_bus_scan_bus(struct zpci_bus *zbus)
+ {
+ 	struct zpci_dev *zdev;
+ 	int devfn, rc, ret = 0;
+ 
+ 	for (devfn = 0; devfn < ZPCI_FUNCTIONS_PER_BUS; devfn++) {
+ 		zdev = zbus->function[devfn];
+ 		if (zdev && zdev->state == ZPCI_FN_STATE_CONFIGURED) {
+ 			rc = zpci_bus_prepare_device(zdev);
+ 			if (rc)
+ 				ret = -EIO;
+ 		}
+ 	}
+ 
+ 	pci_lock_rescan_remove();
+ 	pci_scan_child_bus(zbus->bus);
+ 	pci_bus_add_devices(zbus->bus);
+ 	pci_unlock_rescan_remove();
+ 
+ 	return ret;
+ }
+ 
+ /* zpci_bus_scan_busses - Scan all registered busses
+  *
+  * Scan all available zbusses
+  *
+  */
+ void zpci_bus_scan_busses(void)
+ {
+ 	struct zpci_bus *zbus = NULL;
+ 
+ 	mutex_lock(&zbus_list_lock);
+ 	list_for_each_entry(zbus, &zbus_list, bus_next) {
+ 		zpci_bus_scan_bus(zbus);
+ 		cond_resched();
+ 	}
+ 	mutex_unlock(&zbus_list_lock);
+ }
+ 
+ /* zpci_bus_create_pci_bus - Create the PCI bus associated with this zbus
+  * @zbus: the zbus holding the zdevices
+  * @fr: PCI root function that will determine the bus's domain, and bus speeed
+  * @ops: the pci operations
+  *
+  * The PCI function @fr determines the domain (its UID), multifunction property
+  * and maximum bus speed of the entire bus.
+  *
+  * Return: 0 on success, an error code otherwise
+  */
+ static int zpci_bus_create_pci_bus(struct zpci_bus *zbus, struct zpci_dev *fr, struct pci_ops *ops)
++>>>>>>> 960ac3626487 (s390/pci: allow zPCI zbus without a function zero)
  {
  	struct pci_bus *bus;
 -	int domain;
 +	int rc;
  
++<<<<<<< HEAD
 +	rc = zpci_alloc_domain(domain);
 +	if (rc < 0)
 +		return rc;
 +	zbus->domain_nr = rc;
 +
 +	bus = pci_scan_root_bus(NULL, ZPCI_BUS_NR, ops, zbus, &zbus->resources);
++=======
+ 	domain = zpci_alloc_domain((u16)fr->uid);
+ 	if (domain < 0)
+ 		return domain;
+ 
+ 	zbus->domain_nr = domain;
+ 	zbus->multifunction = fr->rid_available;
+ 	zbus->max_bus_speed = fr->max_bus_speed;
+ 
+ 	/*
+ 	 * Note that the zbus->resources are taken over and zbus->resources
+ 	 * is empty after a successful call
+ 	 */
+ 	bus = pci_create_root_bus(NULL, ZPCI_BUS_NR, ops, zbus, &zbus->resources);
++>>>>>>> 960ac3626487 (s390/pci: allow zPCI zbus without a function zero)
  	if (!bus) {
  		zpci_free_domain(zbus->domain_nr);
  		return -EFAULT;
@@@ -205,51 -302,33 +384,73 @@@ void pcibios_bus_add_device(struct pci_
  
  static int zpci_bus_add_device(struct zpci_bus *zbus, struct zpci_dev *zdev)
  {
++<<<<<<< HEAD
 +	struct pci_bus *bus;
 +	struct resource_entry *window, *n;
 +	struct resource *res;
 +	struct pci_dev *pdev;
 +	int rc;
 +
 +	bus = zbus->bus;
 +	if (!bus)
 +		return -EINVAL;
 +
 +	pdev = pci_get_slot(bus, zdev->devfn);
 +	if (pdev) {
 +		/* Device is already known. */
 +		pci_dev_put(pdev);
 +		return 0;
 +	}
 +
 +	rc = zpci_init_slot(zdev);
 +	if (rc)
 +		return rc;
 +	zdev->has_hp_slot = 1;
 +
 +	resource_list_for_each_entry_safe(window, n, &zbus->resources) {
 +		res = window->res;
 +		pci_bus_add_resource(bus, res, 0);
 +	}
 +
 +	pdev = pci_scan_single_device(bus, zdev->devfn);
 +	if (pdev)
 +		pci_bus_add_device(pdev);
++=======
+ 	int rc = -EINVAL;
+ 
+ 	if (zbus->function[zdev->devfn]) {
+ 		pr_err("devfn %04x is already assigned\n", zdev->devfn);
+ 		return rc;
+ 	}
+ 
+ 	zdev->zbus = zbus;
+ 	zbus->function[zdev->devfn] = zdev;
+ 	zpci_nb_devices++;
+ 
+ 	if (zbus->multifunction && !zdev->rid_available) {
+ 		WARN_ONCE(1, "rid_available not set for multifunction\n");
+ 		goto error;
+ 	}
+ 	rc = zpci_init_slot(zdev);
+ 	if (rc)
+ 		goto error;
+ 	zdev->has_hp_slot = 1;
++>>>>>>> 960ac3626487 (s390/pci: allow zPCI zbus without a function zero)
  
  	return 0;
 +}
  
 -error:
 -	zbus->function[zdev->devfn] = NULL;
 -	zdev->zbus = NULL;
 -	zpci_nb_devices--;
 -	return rc;
 +static void zpci_bus_add_devices(struct zpci_bus *zbus)
 +{
 +	int i;
 +
 +	for (i = 1; i < ZPCI_FUNCTIONS_PER_BUS; i++)
 +		if (zbus->function[i])
 +			zpci_bus_add_device(zbus, zbus->function[i]);
 +
 +	pci_lock_rescan_remove();
 +	pci_bus_add_devices(zbus->bus);
 +	pci_unlock_rescan_remove();
  }
  
  int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops)
@@@ -276,45 -354,19 +477,56 @@@
  			return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	zdev->zbus = zbus;
 +	if (zbus->function[zdev->devfn]) {
 +		pr_err("devfn %04x is already assigned\n", zdev->devfn);
 +		goto error; /* rc already set */
++=======
+ 	if (!zbus->bus) {
+ 		/* The UID of the first PCI function registered with a zpci_bus
+ 		 * is used as the domain number for that bus. Currently there
+ 		 * is exactly one zpci_bus per domain.
+ 		 */
+ 		rc = zpci_bus_create_pci_bus(zbus, zdev, ops);
+ 		if (rc)
+ 			goto error;
++>>>>>>> 960ac3626487 (s390/pci: allow zPCI zbus without a function zero)
  	}
 +	zbus->function[zdev->devfn] = zdev;
  
 -	rc = zpci_bus_add_device(zbus, zdev);
 -	if (rc)
 -		goto error;
 +	zpci_setup_bus_resources(zdev, &zbus->resources);
 +
 +	if (zbus->bus) {
 +		if (!zbus->multifunction) {
 +			WARN_ONCE(1, "zbus is not multifunction\n");
 +			goto error_bus;
 +		}
 +		if (!zdev->rid_available) {
 +			WARN_ONCE(1, "rid_available not set for multifunction\n");
 +			goto error_bus;
 +		}
 +		rc = zpci_bus_add_device(zbus, zdev);
 +		if (rc)
 +			goto error_bus;
 +	} else if (zdev->devfn == 0) {
 +		if (zbus->multifunction && !zdev->rid_available) {
 +			WARN_ONCE(1, "rid_available not set on function 0 for multifunction\n");
 +			goto error_bus;
 +		}
 +		rc = zpci_bus_scan(zbus, (u16)zdev->uid, ops);
 +		if (rc)
 +			goto error_bus;
 +		zpci_bus_add_devices(zbus);
 +		rc = zpci_init_slot(zdev);
 +		if (rc)
 +			goto error_bus;
 +		zdev->has_hp_slot = 1;
 +		zbus->multifunction = zdev->rid_available;
 +		zbus->max_bus_speed = zdev->max_bus_speed;
 +	} else {
 +		zbus->multifunction = 1;
 +	}
  
  	return 0;
  
* Unmerged path arch/s390/pci/pci_bus.c
