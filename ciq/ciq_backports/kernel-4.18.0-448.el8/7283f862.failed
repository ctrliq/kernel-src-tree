drm: Implement DRM aperture helpers under video/

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Thomas Zimmermann <tzimmermann@suse.de>
commit 7283f862bd991c8657e9bf1c02db772fcf018f13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7283f862.failed

Implement DRM's aperture helpers under video/ for sharing with other
sub-systems. Remove DRM-isms from the interface. The helpers track
the ownership of framebuffer apertures and provide hand-over from
firmware, such as EFI and VESA, to native graphics drivers.

Other subsystems, such as fbdev and vfio, also have to maintain ownership
of framebuffer apertures. Moving DRM's aperture helpers to a more public
location allows all subsystems to interact with each other and share a
common implementation.

The aperture helpers are selected by the various firmware drivers within
DRM and fbdev, and the VGA text-console driver.

The original DRM interface is kept in place for use by DRM drivers.

v3:
	* prefix all interfaces with aperture_ (Javier)
	* rework and simplify documentation (Javier)
	* rename struct dev_aperture to struct aperture_range
	* rebase onto latest DRM
	* update MAINTAINERS entry

	Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
	Reviewed-by: Javier Martinez Canillas <javierm@redhat.com>
	Tested-by: Laszlo Ersek <lersek@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20220622140134.12763-3-tzimmermann@suse.de
(cherry picked from commit 7283f862bd991c8657e9bf1c02db772fcf018f13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/driver-api/index.rst
#	MAINTAINERS
#	drivers/gpu/drm/drm_aperture.c
#	drivers/gpu/drm/tiny/Kconfig
#	drivers/video/console/Kconfig
#	drivers/video/fbdev/Kconfig
diff --cc Documentation/driver-api/index.rst
index c7d1c01ae255,d3a58f77328e..000000000000
--- a/Documentation/driver-api/index.rst
+++ b/Documentation/driver-api/index.rst
@@@ -24,9 -26,11 +24,14 @@@ available subsections can be seen below
     device_link
     component
     message-based
++<<<<<<< HEAD
 +   sound
++=======
+    infiniband
+    aperture
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
     frame-buffer
     regulator
 -   reset
     iio/index
     input
     usb/index
diff --cc MAINTAINERS
index dcc666c41762,6a66d91e02a2..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -4723,6 -6473,18 +4723,21 @@@ S:	Orphan / Obsolet
  F:	drivers/gpu/drm/savage/
  F:	include/uapi/drm/savage_drm.h
  
++<<<<<<< HEAD
++=======
+ DRM DRIVER FOR FIRMWARE FRAMEBUFFERS
+ M:	Thomas Zimmermann <tzimmermann@suse.de>
+ M:	Javier Martinez Canillas <javierm@redhat.com>
+ L:	dri-devel@lists.freedesktop.org
+ S:	Maintained
+ T:	git git://anongit.freedesktop.org/drm/drm-misc
+ F:	drivers/gpu/drm/drm_aperture.c
+ F:	drivers/gpu/drm/tiny/simpledrm.c
+ F:	drivers/video/aperture.c
+ F:	include/drm/drm_aperture.h
+ F:	include/linux/aperture.h
+ 
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
  DRM DRIVER FOR SIS VIDEO CARDS
  S:	Orphan / Obsolete
  F:	drivers/gpu/drm/sis/
diff --cc drivers/gpu/drm/drm_aperture.c
index 9335d9d6cf9a,fdb7d5c17ba1..000000000000
--- a/drivers/gpu/drm/drm_aperture.c
+++ b/drivers/gpu/drm/drm_aperture.c
@@@ -283,29 -171,9 +167,33 @@@ EXPORT_SYMBOL(devm_aperture_acquire_fro
   * 0 on success, or a negative errno code otherwise
   */
  int drm_aperture_remove_conflicting_framebuffers(resource_size_t base, resource_size_t size,
 -						 bool primary, const struct drm_driver *req_driver)
 +						 bool primary, const char *name)
  {
++<<<<<<< HEAD
 +#if IS_REACHABLE(CONFIG_FB)
 +	struct apertures_struct *a;
 +	int ret;
 +
 +	a = alloc_apertures(1);
 +	if (!a)
 +		return -ENOMEM;
 +
 +	a->ranges[0].base = base;
 +	a->ranges[0].size = size;
 +
 +	ret = remove_conflicting_framebuffers(a, name, primary);
 +	kfree(a);
 +
 +	if (ret)
 +		return ret;
 +#endif
 +
 +	drm_aperture_detach_drivers(base, size);
 +
 +	return 0;
++=======
+ 	return aperture_remove_conflicting_devices(base, size, primary, req_driver->name);
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
  }
  EXPORT_SYMBOL(drm_aperture_remove_conflicting_framebuffers);
  
@@@ -321,28 -189,9 +209,32 @@@
   * Returns:
   * 0 on success, or a negative errno code otherwise
   */
 -int drm_aperture_remove_conflicting_pci_framebuffers(struct pci_dev *pdev,
 -						     const struct drm_driver *req_driver)
 +int drm_aperture_remove_conflicting_pci_framebuffers(struct pci_dev *pdev, const char *name)
  {
++<<<<<<< HEAD
 +	resource_size_t base, size;
 +	int bar, ret = 0;
 +
 +	for (bar = 0; bar < PCI_STD_NUM_BARS; ++bar) {
 +		if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM))
 +			continue;
 +		base = pci_resource_start(pdev, bar);
 +		size = pci_resource_len(pdev, bar);
 +		drm_aperture_detach_drivers(base, size);
 +	}
 +
 +	/*
 +	 * WARNING: Apparently we must kick fbdev drivers before vgacon,
 +	 * otherwise the vga fbdev driver falls over.
 +	 */
 +#if IS_REACHABLE(CONFIG_FB)
 +	ret = remove_conflicting_pci_framebuffers(pdev, name);
 +#endif
 +	if (ret == 0)
 +		ret = vga_remove_vgacon(pdev);
 +	return ret;
++=======
+ 	return aperture_remove_conflicting_pci_devices(pdev, req_driver->name);
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
  }
  EXPORT_SYMBOL(drm_aperture_remove_conflicting_pci_framebuffers);
diff --cc drivers/gpu/drm/tiny/Kconfig
index d46f95d9196d,027cd87c3d0d..000000000000
--- a/drivers/gpu/drm/tiny/Kconfig
+++ b/drivers/gpu/drm/tiny/Kconfig
@@@ -38,9 -51,25 +38,14 @@@ config DRM_GM12U32
  	 This is a KMS driver for projectors which use the GM12U320 chipset
  	 for video transfer over USB2/3, such as the Acer C120 mini projector.
  
 -config DRM_PANEL_MIPI_DBI
 -	tristate "DRM support for MIPI DBI compatible panels"
 -	depends on DRM && SPI
 -	select DRM_KMS_HELPER
 -	select DRM_GEM_CMA_HELPER
 -	select DRM_MIPI_DBI
 -	select BACKLIGHT_CLASS_DEVICE
 -	select VIDEOMODE_HELPERS
 -	help
 -	  Say Y here if you want to enable support for MIPI DBI compatible
 -	  panels. The controller command setup can be provided using a
 -	  firmware file. For more information see
 -	  https://github.com/notro/panel-mipi-dbi/wiki.
 -	  To compile this driver as a module, choose M here.
 -
  config DRM_SIMPLEDRM
  	tristate "Simple framebuffer driver"
++<<<<<<< HEAD
 +	depends on DRM
++=======
+ 	depends on DRM && MMU
+ 	select APERTURE_HELPERS
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
  	select DRM_GEM_SHMEM_HELPER
  	select DRM_KMS_HELPER
  	help
diff --cc drivers/video/console/Kconfig
index 40d5fea8513c,22cea5082ac4..000000000000
--- a/drivers/video/console/Kconfig
+++ b/drivers/video/console/Kconfig
@@@ -8,7 -9,8 +8,12 @@@ config VGA_CONSOL
  	bool "VGA text console" if EXPERT || !X86
  	depends on !4xx && !PPC_8xx && !SPARC && !M68K && !PARISC &&  !SUPERH && \
  		(!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER) && \
++<<<<<<< HEAD
 +		!ARM64 && !ARC && !MICROBLAZE && !OPENRISC && !NDS32 && !S390
++=======
+ 		!ARM64 && !ARC && !MICROBLAZE && !OPENRISC && !S390 && !UML
+ 	select APERTURE_HELPERS if (DRM || FB || VFIO_PCI_CORE)
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
  	default y
  	help
  	  Saying Y here will allow you to use Linux in text mode through a
diff --cc drivers/video/fbdev/Kconfig
index 81e13c911027,cfc55273dc5d..000000000000
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@@ -2295,8 -2191,10 +2299,15 @@@ config FB_HYPER
  	  This framebuffer driver supports Microsoft Hyper-V Synthetic Video.
  
  config FB_SIMPLE
++<<<<<<< HEAD
 +	bool "Simple framebuffer support"
 +	depends on (FB = y)
++=======
+ 	tristate "Simple framebuffer support"
+ 	depends on FB
+ 	depends on !DRM_SIMPLEDRM
+ 	select APERTURE_HELPERS
++>>>>>>> 7283f862bd99 (drm: Implement DRM aperture helpers under video/)
  	select FB_CFB_FILLRECT
  	select FB_CFB_COPYAREA
  	select FB_CFB_IMAGEBLIT
diff --git a/Documentation/driver-api/aperture.rst b/Documentation/driver-api/aperture.rst
new file mode 100644
index 000000000000..d173f4e7a7d9
--- /dev/null
+++ b/Documentation/driver-api/aperture.rst
@@ -0,0 +1,13 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+Managing Ownership of the Framebuffer Aperture
+==============================================
+
+.. kernel-doc:: drivers/video/aperture.c
+   :doc: overview
+
+.. kernel-doc:: include/linux/aperture.h
+   :internal:
+
+.. kernel-doc:: drivers/video/aperture.c
+   :export:
* Unmerged path Documentation/driver-api/index.rst
* Unmerged path MAINTAINERS
* Unmerged path drivers/gpu/drm/drm_aperture.c
* Unmerged path drivers/gpu/drm/tiny/Kconfig
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 83d3d271ca15..afa17505d8a8 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -4,6 +4,12 @@
 
 menu "Graphics support"
 
+config APERTURE_HELPERS
+	bool
+	help
+	  Support tracking and hand-over of aperture ownership. Required
+	  by graphics drivers for firmware-provided framebuffers.
+
 if HAS_IOMEM
 
 config HAVE_FB_ATMEL
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index df7650adede9..5bb6b452cc83 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -1,4 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_APERTURE_HELPERS)    += aperture.o
 obj-$(CONFIG_VGASTATE)            += vgastate.o
 obj-$(CONFIG_HDMI)                += hdmi.o
 
diff --git a/drivers/video/aperture.c b/drivers/video/aperture.c
new file mode 100644
index 000000000000..538f2d40acda
--- /dev/null
+++ b/drivers/video/aperture.c
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: MIT
+
+#include <linux/aperture.h>
+#include <linux/device.h>
+#include <linux/fb.h> /* for old fbdev helpers */
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/vgaarb.h>
+
+/**
+ * DOC: overview
+ *
+ * A graphics device might be supported by different drivers, but only one
+ * driver can be active at any given time. Many systems load a generic
+ * graphics drivers, such as EFI-GOP or VESA, early during the boot process.
+ * During later boot stages, they replace the generic driver with a dedicated,
+ * hardware-specific driver. To take over the device the dedicated driver
+ * first has to remove the generic driver. Aperture functions manage
+ * ownership of framebuffer memory and hand-over between drivers.
+ *
+ * Graphics drivers should call aperture_remove_conflicting_devices()
+ * at the top of their probe function. The function removes any generic
+ * driver that is currently associated with the given framebuffer memory.
+ * An example for a graphics device on the platform bus is shown below.
+ *
+ * .. code-block:: c
+ *
+ *	static int example_probe(struct platform_device *pdev)
+ *	{
+ *		struct resource *mem;
+ *		resource_size_t base, size;
+ *		int ret;
+ *
+ *		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ *		if (!mem)
+ *			return -ENODEV;
+ *		base = mem->start;
+ *		size = resource_size(mem);
+ *
+ *		ret = aperture_remove_conflicting_devices(base, size, false, "example");
+ *		if (ret)
+ *			return ret;
+ *
+ *		// Initialize the hardware
+ *		...
+ *
+ *		return 0;
+ *	}
+ *
+ *	static const struct platform_driver example_driver = {
+ *		.probe = example_probe,
+ *		...
+ *	};
+ *
+ * The given example reads the platform device's I/O-memory range from the
+ * device instance. An active framebuffer will be located within this range.
+ * The call to aperture_remove_conflicting_devices() releases drivers that
+ * have previously claimed ownership of the range and are currently driving
+ * output on the framebuffer. If successful, the new driver can take over
+ * the device.
+ *
+ * While the given example uses a platform device, the aperture helpers work
+ * with every bus that has an addressable framebuffer. In the case of PCI,
+ * device drivers can also call aperture_remove_conflicting_pci_devices() and
+ * let the function detect the apertures automatically. Device drivers without
+ * knowledge of the framebuffer's location can call
+ * aperture_remove_all_conflicting_devices(), which removes all known devices.
+ *
+ * Drivers that are susceptible to being removed by other drivers, such as
+ * generic EFI or VESA drivers, have to register themselves as owners of their
+ * framebuffer apertures. Ownership of the framebuffer memory is achieved
+ * by calling devm_aperture_acquire_for_platform_device(). If successful, the
+ * driveris the owner of the framebuffer range. The function fails if the
+ * framebuffer is already owned by another driver. See below for an example.
+ *
+ * .. code-block:: c
+ *
+ *	static int generic_probe(struct platform_device *pdev)
+ *	{
+ *		struct resource *mem;
+ *		resource_size_t base, size;
+ *
+ *		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ *		if (!mem)
+ *			return -ENODEV;
+ *		base = mem->start;
+ *		size = resource_size(mem);
+ *
+ *		ret = devm_aperture_acquire_for_platform_device(pdev, base, size);
+ *		if (ret)
+ *			return ret;
+ *
+ *		// Initialize the hardware
+ *		...
+ *
+ *		return 0;
+ *	}
+ *
+ *	static int generic_remove(struct platform_device *)
+ *	{
+ *		// Hot-unplug the device
+ *		...
+ *
+ *		return 0;
+ *	}
+ *
+ *	static const struct platform_driver generic_driver = {
+ *		.probe = generic_probe,
+ *		.remove = generic_remove,
+ *		...
+ *	};
+ *
+ * The similar to the previous example, the generic driver claims ownership
+ * of the framebuffer memory from its probe function. This will fail if the
+ * memory range, or parts of it, is already owned by another driver.
+ *
+ * If successful, the generic driver is now subject to forced removal by
+ * another driver. This only works for platform drivers that support hot
+ * unplugging. When a driver calls aperture_remove_conflicting_devices()
+ * et al for the registered framebuffer range, the aperture helpers call
+ * platform_device_unregister() and the generic driver unloads itself. The
+ * generic driver also has to provide a remove function to make this work.
+ * Once hot unplugged fro mhardware, it may not access the device's
+ * registers, framebuffer memory, ROM, etc afterwards.
+ */
+
+struct aperture_range {
+	struct device *dev;
+	resource_size_t base;
+	resource_size_t size;
+	struct list_head lh;
+	void (*detach)(struct device *dev);
+};
+
+static LIST_HEAD(apertures);
+static DEFINE_MUTEX(apertures_lock);
+
+static bool overlap(resource_size_t base1, resource_size_t end1,
+		    resource_size_t base2, resource_size_t end2)
+{
+	return (base1 < end2) && (end1 > base2);
+}
+
+static void devm_aperture_acquire_release(void *data)
+{
+	struct aperture_range *ap = data;
+	bool detached = !ap->dev;
+
+	if (detached)
+		return;
+
+	mutex_lock(&apertures_lock);
+	list_del(&ap->lh);
+	mutex_unlock(&apertures_lock);
+}
+
+static int devm_aperture_acquire(struct device *dev,
+				 resource_size_t base, resource_size_t size,
+				 void (*detach)(struct device *))
+{
+	size_t end = base + size;
+	struct list_head *pos;
+	struct aperture_range *ap;
+
+	mutex_lock(&apertures_lock);
+
+	list_for_each(pos, &apertures) {
+		ap = container_of(pos, struct aperture_range, lh);
+		if (overlap(base, end, ap->base, ap->base + ap->size)) {
+			mutex_unlock(&apertures_lock);
+			return -EBUSY;
+		}
+	}
+
+	ap = devm_kzalloc(dev, sizeof(*ap), GFP_KERNEL);
+	if (!ap) {
+		mutex_unlock(&apertures_lock);
+		return -ENOMEM;
+	}
+
+	ap->dev = dev;
+	ap->base = base;
+	ap->size = size;
+	ap->detach = detach;
+	INIT_LIST_HEAD(&ap->lh);
+
+	list_add(&ap->lh, &apertures);
+
+	mutex_unlock(&apertures_lock);
+
+	return devm_add_action_or_reset(dev, devm_aperture_acquire_release, ap);
+}
+
+static void aperture_detach_platform_device(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	/*
+	 * Remove the device from the device hierarchy. This is the right thing
+	 * to do for firmware-based DRM drivers, such as EFI, VESA or VGA. After
+	 * the new driver takes over the hardware, the firmware device's state
+	 * will be lost.
+	 *
+	 * For non-platform devices, a new callback would be required.
+	 *
+	 * If the aperture helpers ever need to handle native drivers, this call
+	 * would only have to unplug the DRM device, so that the hardware device
+	 * stays around after detachment.
+	 */
+	platform_device_unregister(pdev);
+}
+
+/**
+ * devm_aperture_acquire_for_platform_device - Acquires ownership of an aperture
+ *                                             on behalf of a platform device.
+ * @pdev:	the platform device to own the aperture
+ * @base:	the aperture's byte offset in physical memory
+ * @size:	the aperture size in bytes
+ *
+ * Installs the given device as the new owner of the aperture. The function
+ * expects the aperture to be provided by a platform device. If another
+ * driver takes over ownership of the aperture, aperture helpers will then
+ * unregister the platform device automatically. All acquired apertures are
+ * released automatically when the underlying device goes away.
+ *
+ * The function fails if the aperture, or parts of it, is currently
+ * owned by another device. To evict current owners, callers should use
+ * remove_conflicting_devices() et al. before calling this function.
+ *
+ * Returns:
+ * 0 on success, or a negative errno value otherwise.
+ */
+int devm_aperture_acquire_for_platform_device(struct platform_device *pdev,
+					      resource_size_t base,
+					      resource_size_t size)
+{
+	return devm_aperture_acquire(&pdev->dev, base, size, aperture_detach_platform_device);
+}
+EXPORT_SYMBOL(devm_aperture_acquire_for_platform_device);
+
+static void aperture_detach_devices(resource_size_t base, resource_size_t size)
+{
+	resource_size_t end = base + size;
+	struct list_head *pos, *n;
+
+	mutex_lock(&apertures_lock);
+
+	list_for_each_safe(pos, n, &apertures) {
+		struct aperture_range *ap = container_of(pos, struct aperture_range, lh);
+		struct device *dev = ap->dev;
+
+		if (WARN_ON_ONCE(!dev))
+			continue;
+
+		if (!overlap(base, end, ap->base, ap->base + ap->size))
+			continue;
+
+		ap->dev = NULL; /* detach from device */
+		list_del(&ap->lh);
+
+		ap->detach(dev);
+	}
+
+	mutex_unlock(&apertures_lock);
+}
+
+/**
+ * aperture_remove_conflicting_devices - remove devices in the given range
+ * @base: the aperture's base address in physical memory
+ * @size: aperture size in bytes
+ * @primary: also kick vga16fb if present; only relevant for VGA devices
+ * @name: a descriptive name of the requesting driver
+ *
+ * This function removes devices that own apertures within @base and @size.
+ *
+ * Returns:
+ * 0 on success, or a negative errno code otherwise
+ */
+int aperture_remove_conflicting_devices(resource_size_t base, resource_size_t size,
+					bool primary, const char *name)
+{
+#if IS_REACHABLE(CONFIG_FB)
+	struct apertures_struct *a;
+	int ret;
+
+	a = alloc_apertures(1);
+	if (!a)
+		return -ENOMEM;
+
+	a->ranges[0].base = base;
+	a->ranges[0].size = size;
+
+	ret = remove_conflicting_framebuffers(a, name, primary);
+	kfree(a);
+
+	if (ret)
+		return ret;
+#endif
+
+	aperture_detach_devices(base, size);
+
+	return 0;
+}
+EXPORT_SYMBOL(aperture_remove_conflicting_devices);
+
+/**
+ * aperture_remove_conflicting_pci_devices - remove existing framebuffers for PCI devices
+ * @pdev: PCI device
+ * @name: a descriptive name of the requesting driver
+ *
+ * This function removes devices that own apertures within any of @pdev's
+ * memory bars. The function assumes that PCI device with shadowed ROM
+ * drives a primary display and therefore kicks out vga16fb as well.
+ *
+ * Returns:
+ * 0 on success, or a negative errno code otherwise
+ */
+int aperture_remove_conflicting_pci_devices(struct pci_dev *pdev, const char *name)
+{
+	resource_size_t base, size;
+	int bar, ret;
+
+	/*
+	 * WARNING: Apparently we must kick fbdev drivers before vgacon,
+	 * otherwise the vga fbdev driver falls over.
+	 */
+#if IS_REACHABLE(CONFIG_FB)
+	ret = remove_conflicting_pci_framebuffers(pdev, name);
+	if (ret)
+		return ret;
+#endif
+	ret = vga_remove_vgacon(pdev);
+	if (ret)
+		return ret;
+
+	for (bar = 0; bar < PCI_STD_NUM_BARS; ++bar) {
+		if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM))
+			continue;
+		base = pci_resource_start(pdev, bar);
+		size = pci_resource_len(pdev, bar);
+		aperture_detach_devices(base, size);
+	}
+
+	return 0;
+
+}
+EXPORT_SYMBOL(aperture_remove_conflicting_pci_devices);
* Unmerged path drivers/video/console/Kconfig
* Unmerged path drivers/video/fbdev/Kconfig
diff --git a/include/linux/aperture.h b/include/linux/aperture.h
new file mode 100644
index 000000000000..442f15a57cad
--- /dev/null
+++ b/include/linux/aperture.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: MIT */
+
+#ifndef _LINUX_APERTURE_H_
+#define _LINUX_APERTURE_H_
+
+#include <linux/types.h>
+
+struct pci_dev;
+struct platform_device;
+
+#if defined(CONFIG_APERTURE_HELPERS)
+int devm_aperture_acquire_for_platform_device(struct platform_device *pdev,
+					      resource_size_t base,
+					      resource_size_t size);
+
+int aperture_remove_conflicting_devices(resource_size_t base, resource_size_t size,
+					bool primary, const char *name);
+
+int aperture_remove_conflicting_pci_devices(struct pci_dev *pdev, const char *name);
+#else
+static inline int devm_aperture_acquire_for_platform_device(struct platform_device *pdev,
+							    resource_size_t base,
+							    resource_size_t size)
+{
+	return 0;
+}
+
+static inline int aperture_remove_conflicting_devices(resource_size_t base, resource_size_t size,
+						      bool primary, const char *name)
+{
+	return 0;
+}
+
+static inline int aperture_remove_conflicting_pci_devices(struct pci_dev *pdev, const char *name)
+{
+	return 0;
+}
+#endif
+
+/**
+ * aperture_remove_all_conflicting_devices - remove all existing framebuffers
+ * @primary: also kick vga16fb if present; only relevant for VGA devices
+ * @name: a descriptive name of the requesting driver
+ *
+ * This function removes all graphics device drivers. Use this function on systems
+ * that can have their framebuffer located anywhere in memory.
+ *
+ * Returns:
+ * 0 on success, or a negative errno code otherwise
+ */
+static inline int aperture_remove_all_conflicting_devices(bool primary, const char *name)
+{
+	return aperture_remove_conflicting_devices(0, (resource_size_t)-1, primary, name);
+}
+
+#endif
