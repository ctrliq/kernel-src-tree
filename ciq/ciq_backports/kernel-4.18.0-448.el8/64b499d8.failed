irqchip/gic-v3: Configure SGIs as standard interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Marc Zyngier <maz@kernel.org>
commit 64b499d8df40dadb1818ad9f74c4546951b37a8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/64b499d8.failed

Change the way we deal with GICv3 SGIs by turning them into proper
IRQs, and calling into the arch code to register the interrupt range
instead of a callback.

	Reviewed-by: Valentin Schneider <valentin.schneider@arm.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
(cherry picked from commit 64b499d8df40dadb1818ad9f74c4546951b37a8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/irqchip/irq-gic-v3.c
diff --cc drivers/irqchip/irq-gic-v3.c
index c0f767695b67,84ceb6334e72..000000000000
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@@ -703,38 -658,18 +708,38 @@@ static asmlinkage void __exception_irq_
  		gic_arch_enable_irqs();
  	}
  
++<<<<<<< HEAD
 +	/* Treat anything but SGIs in a uniform way */
 +	if (likely(irqnr > 15)) {
 +		int err;
 +
 +		if (static_branch_likely(&supports_deactivate_key))
 +			gic_write_eoir(irqnr);
 +		else
 +			isb();
 +
 +		err = handle_domain_irq(gic_data.domain, irqnr, regs);
 +		if (err) {
 +			WARN_ONCE(true, "Unexpected interrupt received!\n");
 +			gic_deactivate_unhandled(irqnr);
 +		}
 +		return;
 +	}
 +	if (irqnr < 16) {
++=======
+ 	/* Check for special IDs first */
+ 	if ((irqnr >= 1020 && irqnr <= 1023))
+ 		return;
+ 
+ 	if (static_branch_likely(&supports_deactivate_key))
++>>>>>>> 64b499d8df40 (irqchip/gic-v3: Configure SGIs as standard interrupts)
  		gic_write_eoir(irqnr);
- 		if (static_branch_likely(&supports_deactivate_key))
- 			gic_write_dir(irqnr);
- #ifdef CONFIG_SMP
- 		/*
- 		 * Unlike GICv2, we don't need an smp_rmb() here.
- 		 * The control dependency from gic_read_iar to
- 		 * the ISB in gic_write_eoir is enough to ensure
- 		 * that any shared data read by handle_IPI will
- 		 * be read after the ACK.
- 		 */
- 		handle_IPI(irqnr, regs);
- #else
- 		WARN_ONCE(true, "Unexpected SGI received!\n");
- #endif
+ 	else
+ 		isb();
+ 
+ 	if (handle_domain_irq(gic_data.domain, irqnr, regs)) {
+ 		WARN_ONCE(true, "Unexpected interrupt received!\n");
+ 		gic_deactivate_unhandled(irqnr);
  	}
  }
  
@@@ -1310,9 -1249,11 +1330,15 @@@ static struct irq_chip gic_chip = 
  	.irq_eoi		= gic_eoi_irq,
  	.irq_set_type		= gic_set_type,
  	.irq_set_affinity	= gic_set_affinity,
 +	.irq_retrigger          = gic_retrigger,
  	.irq_get_irqchip_state	= gic_irq_get_irqchip_state,
  	.irq_set_irqchip_state	= gic_irq_set_irqchip_state,
++<<<<<<< HEAD
++=======
+ 	.irq_nmi_setup		= gic_irq_nmi_setup,
+ 	.irq_nmi_teardown	= gic_irq_nmi_teardown,
+ 	.ipi_send_mask		= gic_ipi_send_mask,
++>>>>>>> 64b499d8df40 (irqchip/gic-v3: Configure SGIs as standard interrupts)
  	.flags			= IRQCHIP_SET_TYPE_MASKED |
  				  IRQCHIP_SKIP_SET_WAKE |
  				  IRQCHIP_MASK_ON_SUSPEND,
@@@ -1329,6 -1269,9 +1355,12 @@@ static struct irq_chip gic_eoimode1_chi
  	.irq_get_irqchip_state	= gic_irq_get_irqchip_state,
  	.irq_set_irqchip_state	= gic_irq_set_irqchip_state,
  	.irq_set_vcpu_affinity	= gic_irq_set_vcpu_affinity,
++<<<<<<< HEAD
++=======
+ 	.irq_nmi_setup		= gic_irq_nmi_setup,
+ 	.irq_nmi_teardown	= gic_irq_nmi_teardown,
+ 	.ipi_send_mask		= gic_ipi_send_mask,
++>>>>>>> 64b499d8df40 (irqchip/gic-v3: Configure SGIs as standard interrupts)
  	.flags			= IRQCHIP_SET_TYPE_MASKED |
  				  IRQCHIP_SKIP_SET_WAKE |
  				  IRQCHIP_MASK_ON_SUSPEND,
* Unmerged path drivers/irqchip/irq-gic-v3.c
