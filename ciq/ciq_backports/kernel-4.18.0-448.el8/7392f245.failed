drm/format-helper: Fix XRGB888 to monochrome conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Geert Uytterhoeven <geert@linux-m68k.org>
commit 7392f2459eefcdab1d998af002d2b8b16fe4a2fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7392f245.failed

The conversion functions drm_fb_xrgb8888_to_mono() and
drm_fb_gray8_to_mono_line() do not behave correctly when the
horizontal boundaries of the clip rectangle are not multiples of 8:
  a. When x1 % 8 != 0, the calculated pitch is not correct,
  b. When x2 % 8 != 0, the pixel data for the last byte is wrong.

Simplify the code and fix (a) by:
  1. Removing start_offset, and always storing the first pixel in the
     first bit of the monochrome destination buffer.
     Drivers that require the first pixel in a byte to be located at an
     x-coordinate that is a multiple of 8 can always align the clip
     rectangle before calling drm_fb_xrgb8888_to_mono().
     Note that:
       - The ssd130x driver does not need the alignment, as the
	 monochrome buffer is a temporary format,
       - The repaper driver always updates the full screen, so the clip
	 rectangle is always aligned.
  2. Passing the number of pixels to drm_fb_gray8_to_mono_line(),
     instead of the number of bytes, and the number of pixels in the
     last byte.

Fix (b) by explicitly setting the target bit, instead of always setting
bit 7 and shifting the value in each loop iteration.

Remove the bogus pitch check, which operates on bytes instead of pixels,
and triggers when e.g. flashing the cursor on a text console with a font
that is 8 pixels wide.

Drop the confusing comment about scanlines, as a pitch in bytes always
contains a multiple of 8 pixels.

While at it, use the drm_rect_height() helper instead of open-coding the
same operation.

Update the comments accordingly.

Fixes: bcf8b616deb87941 ("drm/format-helper: Add drm_fb_xrgb8888_to_mono_reversed()")
	Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Acked-by: Javier Martinez Canillas <javierm@redhat.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Javier Martinez Canillas <javierm@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20220317081830.1211400-3-geert@linux-m68k.org
(cherry picked from commit 7392f2459eefcdab1d998af002d2b8b16fe4a2fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_format_helper.c
diff --cc drivers/gpu/drm/drm_format_helper.c
index 0e885cd34107,e085f855a199..000000000000
--- a/drivers/gpu/drm/drm_format_helper.c
+++ b/drivers/gpu/drm/drm_format_helper.c
@@@ -398,36 -592,92 +398,115 @@@ int drm_fb_blit_rect_dstclip(void __iom
  
  	return -EINVAL;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(drm_fb_blit_rect_dstclip);
++=======
+ EXPORT_SYMBOL(drm_fb_blit_toio);
+ 
+ 
+ static void drm_fb_gray8_to_mono_line(u8 *dst, const u8 *src, unsigned int pixels)
+ {
+ 	while (pixels) {
+ 		unsigned int i, bits = min(pixels, 8U);
+ 		u8 byte = 0;
+ 
+ 		for (i = 0; i < bits; i++, pixels--) {
+ 			if (*src++ >= 128)
+ 				byte |= BIT(i);
+ 		}
+ 		*dst++ = byte;
+ 	}
+ }
++>>>>>>> 7392f2459eef (drm/format-helper: Fix XRGB888 to monochrome conversion)
  
  /**
 - * drm_fb_xrgb8888_to_mono - Convert XRGB8888 to monochrome
 - * @dst: monochrome destination buffer (0=black, 1=white)
 - * @dst_pitch: Number of bytes between two consecutive scanlines within dst
 - * @src: XRGB8888 source buffer
 - * @fb: DRM framebuffer
 - * @clip: Clip rectangle area to copy
 + * drm_fb_blit_dstclip - Copy framebuffer to display memory
 + * @dst:	The display memory to copy to
 + * @dst_pitch:	Number of bytes between two consecutive scanlines within dst
 + * @dst_format:	FOURCC code of the display's color format
 + * @vmap:	The framebuffer memory to copy from
 + * @fb:		The framebuffer to copy from
   *
 - * DRM doesn't have native monochrome support.
 - * Such drivers can announce the commonly supported XR24 format to userspace
 - * and use this function to convert to the native format.
 + * This function copies a full framebuffer to display memory. If the formats
 + * of the display and the framebuffer mismatch, the copy function will
 + * attempt to convert between them.
   *
++<<<<<<< HEAD
 + * See drm_fb_blit_rect_dstclip() for more inforamtion.
 + *
 + * Returns:
 + * 0 on success, or a negative error code otherwise.
++=======
+  * This function uses drm_fb_xrgb8888_to_gray8() to convert to grayscale and
+  * then the result is converted from grayscale to monochrome.
+  *
+  * The first pixel (upper left corner of the clip rectangle) will be converted
+  * and copied to the first bit (LSB) in the first byte of the monochrome
+  * destination buffer.
+  * If the caller requires that the first pixel in a byte must be located at an
+  * x-coordinate that is a multiple of 8, then the caller must take care itself
+  * of supplying a suitable clip rectangle.
++>>>>>>> 7392f2459eef (drm/format-helper: Fix XRGB888 to monochrome conversion)
   */
 -void drm_fb_xrgb8888_to_mono(void *dst, unsigned int dst_pitch, const void *vaddr,
 -			     const struct drm_framebuffer *fb, const struct drm_rect *clip)
 +int drm_fb_blit_dstclip(void __iomem *dst, unsigned int dst_pitch,
 +			uint32_t dst_format, void *vmap,
 +			struct drm_framebuffer *fb)
  {
++<<<<<<< HEAD
 +	struct drm_rect fullscreen = {
 +		.x1 = 0,
 +		.x2 = fb->width,
 +		.y1 = 0,
 +		.y2 = fb->height,
 +	};
 +	return drm_fb_blit_rect_dstclip(dst, dst_pitch, dst_format, vmap, fb,
 +					&fullscreen);
++=======
+ 	unsigned int linepixels = drm_rect_width(clip);
+ 	unsigned int lines = drm_rect_height(clip);
+ 	unsigned int cpp = fb->format->cpp[0];
+ 	unsigned int len_src32 = linepixels * cpp;
+ 	struct drm_device *dev = fb->dev;
+ 	unsigned int y;
+ 	u8 *mono = dst, *gray8;
+ 	u32 *src32;
+ 
+ 	if (drm_WARN_ON(dev, fb->format->format != DRM_FORMAT_XRGB8888))
+ 		return;
+ 
+ 	/*
+ 	 * The mono destination buffer contains 1 bit per pixel
+ 	 */
+ 	if (!dst_pitch)
+ 		dst_pitch = DIV_ROUND_UP(linepixels, 8);
+ 
+ 	/*
+ 	 * The cma memory is write-combined so reads are uncached.
+ 	 * Speed up by fetching one line at a time.
+ 	 *
+ 	 * Also, format conversion from XR24 to monochrome are done
+ 	 * line-by-line but are converted to 8-bit grayscale as an
+ 	 * intermediate step.
+ 	 *
+ 	 * Allocate a buffer to be used for both copying from the cma
+ 	 * memory and to store the intermediate grayscale line pixels.
+ 	 */
+ 	src32 = kmalloc(len_src32 + linepixels, GFP_KERNEL);
+ 	if (!src32)
+ 		return;
+ 
+ 	gray8 = (u8 *)src32 + len_src32;
+ 
+ 	vaddr += clip_offset(clip, fb->pitches[0], cpp);
+ 	for (y = 0; y < lines; y++) {
+ 		src32 = memcpy(src32, vaddr, len_src32);
+ 		drm_fb_xrgb8888_to_gray8_line(gray8, src32, linepixels);
+ 		drm_fb_gray8_to_mono_line(mono, gray8, linepixels);
+ 		vaddr += fb->pitches[0];
+ 		mono += dst_pitch;
+ 	}
+ 
+ 	kfree(src32);
++>>>>>>> 7392f2459eef (drm/format-helper: Fix XRGB888 to monochrome conversion)
  }
 -EXPORT_SYMBOL(drm_fb_xrgb8888_to_mono);
 +EXPORT_SYMBOL(drm_fb_blit_dstclip);
* Unmerged path drivers/gpu/drm/drm_format_helper.c
