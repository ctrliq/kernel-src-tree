flow_offload: add reoffload process to update hw_count

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Baowen Zheng <baowen.zheng@corigine.com>
commit 13926d19a11e303f12571df61b7bb64f17cb4561
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/13926d19.failed

Add reoffload process to update hw_count when driver
is inserted or removed.

We will delete the action if it is with skip_sw flag and
not offloaded to any hardware in reoffload process.

When reoffloading actions, we still offload the actions
that are added independent of filters.

	Signed-off-by: Baowen Zheng <baowen.zheng@corigine.com>
	Signed-off-by: Louis Peens <louis.peens@corigine.com>
	Signed-off-by: Simon Horman <simon.horman@corigine.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 13926d19a11e303f12571df61b7bb64f17cb4561)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	net/sched/act_api.c
diff --cc include/net/act_api.h
index b5b624c7e488,0f5f69deb3ce..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -240,6 -254,9 +241,12 @@@ void tcf_action_update_stats(struct tc_
  			     u64 drops, bool hw);
  int tcf_action_copy_stats(struct sk_buff *, struct tc_action *, int);
  
++<<<<<<< HEAD
++=======
+ int tcf_action_update_hw_stats(struct tc_action *action);
+ int tcf_action_reoffload_cb(flow_indr_block_bind_cb_t *cb,
+ 			    void *cb_priv, bool add);
++>>>>>>> 13926d19a11e (flow_offload: add reoffload process to update hw_count)
  int tcf_action_check_ctrlact(int action, struct tcf_proto *tp,
  			     struct tcf_chain **handle,
  			     struct netlink_ext_ack *newchain);
diff --cc net/sched/act_api.c
index f274ee42a202,99f998be2040..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -135,8 -131,237 +135,239 @@@ static void free_tcf(struct tc_action *
  	kfree(p);
  }
  
++<<<<<<< HEAD
++=======
+ static void offload_action_hw_count_set(struct tc_action *act,
+ 					u32 hw_count)
+ {
+ 	act->in_hw_count = hw_count;
+ }
+ 
+ static void offload_action_hw_count_inc(struct tc_action *act,
+ 					u32 hw_count)
+ {
+ 	act->in_hw_count += hw_count;
+ }
+ 
+ static void offload_action_hw_count_dec(struct tc_action *act,
+ 					u32 hw_count)
+ {
+ 	act->in_hw_count = act->in_hw_count > hw_count ?
+ 			   act->in_hw_count - hw_count : 0;
+ }
+ 
+ static unsigned int tcf_offload_act_num_actions_single(struct tc_action *act)
+ {
+ 	if (is_tcf_pedit(act))
+ 		return tcf_pedit_nkeys(act);
+ 	else
+ 		return 1;
+ }
+ 
+ static bool tc_act_skip_hw(u32 flags)
+ {
+ 	return (flags & TCA_ACT_FLAGS_SKIP_HW) ? true : false;
+ }
+ 
+ static bool tc_act_skip_sw(u32 flags)
+ {
+ 	return (flags & TCA_ACT_FLAGS_SKIP_SW) ? true : false;
+ }
+ 
+ static bool tc_act_in_hw(struct tc_action *act)
+ {
+ 	return !!act->in_hw_count;
+ }
+ 
+ /* SKIP_HW and SKIP_SW are mutually exclusive flags. */
+ static bool tc_act_flags_valid(u32 flags)
+ {
+ 	flags &= TCA_ACT_FLAGS_SKIP_HW | TCA_ACT_FLAGS_SKIP_SW;
+ 
+ 	return flags ^ (TCA_ACT_FLAGS_SKIP_HW | TCA_ACT_FLAGS_SKIP_SW);
+ }
+ 
+ static int offload_action_init(struct flow_offload_action *fl_action,
+ 			       struct tc_action *act,
+ 			       enum offload_act_command  cmd,
+ 			       struct netlink_ext_ack *extack)
+ {
+ 	fl_action->extack = extack;
+ 	fl_action->command = cmd;
+ 	fl_action->index = act->tcfa_index;
+ 
+ 	if (act->ops->offload_act_setup)
+ 		return act->ops->offload_act_setup(act, fl_action, NULL, false);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static int tcf_action_offload_cmd_ex(struct flow_offload_action *fl_act,
+ 				     u32 *hw_count)
+ {
+ 	int err;
+ 
+ 	err = flow_indr_dev_setup_offload(NULL, NULL, TC_SETUP_ACT,
+ 					  fl_act, NULL, NULL);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (hw_count)
+ 		*hw_count = err;
+ 
+ 	return 0;
+ }
+ 
+ static int tcf_action_offload_cmd_cb_ex(struct flow_offload_action *fl_act,
+ 					u32 *hw_count,
+ 					flow_indr_block_bind_cb_t *cb,
+ 					void *cb_priv)
+ {
+ 	int err;
+ 
+ 	err = cb(NULL, NULL, cb_priv, TC_SETUP_ACT, NULL, fl_act, NULL);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (hw_count)
+ 		*hw_count = 1;
+ 
+ 	return 0;
+ }
+ 
+ static int tcf_action_offload_cmd(struct flow_offload_action *fl_act,
+ 				  u32 *hw_count,
+ 				  flow_indr_block_bind_cb_t *cb,
+ 				  void *cb_priv)
+ {
+ 	return cb ? tcf_action_offload_cmd_cb_ex(fl_act, hw_count,
+ 						 cb, cb_priv) :
+ 		    tcf_action_offload_cmd_ex(fl_act, hw_count);
+ }
+ 
+ static int tcf_action_offload_add_ex(struct tc_action *action,
+ 				     struct netlink_ext_ack *extack,
+ 				     flow_indr_block_bind_cb_t *cb,
+ 				     void *cb_priv)
+ {
+ 	bool skip_sw = tc_act_skip_sw(action->tcfa_flags);
+ 	struct tc_action *actions[TCA_ACT_MAX_PRIO] = {
+ 		[0] = action,
+ 	};
+ 	struct flow_offload_action *fl_action;
+ 	u32 in_hw_count = 0;
+ 	int num, err = 0;
+ 
+ 	if (tc_act_skip_hw(action->tcfa_flags))
+ 		return 0;
+ 
+ 	num = tcf_offload_act_num_actions_single(action);
+ 	fl_action = offload_action_alloc(num);
+ 	if (!fl_action)
+ 		return -ENOMEM;
+ 
+ 	err = offload_action_init(fl_action, action, FLOW_ACT_REPLACE, extack);
+ 	if (err)
+ 		goto fl_err;
+ 
+ 	err = tc_setup_action(&fl_action->action, actions);
+ 	if (err) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Failed to setup tc actions for offload\n");
+ 		goto fl_err;
+ 	}
+ 
+ 	err = tcf_action_offload_cmd(fl_action, &in_hw_count, cb, cb_priv);
+ 	if (!err)
+ 		cb ? offload_action_hw_count_inc(action, in_hw_count) :
+ 		     offload_action_hw_count_set(action, in_hw_count);
+ 
+ 	if (skip_sw && !tc_act_in_hw(action))
+ 		err = -EINVAL;
+ 
+ 	tc_cleanup_offload_action(&fl_action->action);
+ 
+ fl_err:
+ 	kfree(fl_action);
+ 
+ 	return err;
+ }
+ 
+ /* offload the tc action after it is inserted */
+ static int tcf_action_offload_add(struct tc_action *action,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	return tcf_action_offload_add_ex(action, extack, NULL, NULL);
+ }
+ 
+ int tcf_action_update_hw_stats(struct tc_action *action)
+ {
+ 	struct flow_offload_action fl_act = {};
+ 	int err;
+ 
+ 	if (!tc_act_in_hw(action))
+ 		return -EOPNOTSUPP;
+ 
+ 	err = offload_action_init(&fl_act, action, FLOW_ACT_STATS, NULL);
+ 	if (err)
+ 		return err;
+ 
+ 	err = tcf_action_offload_cmd(&fl_act, NULL, NULL, NULL);
+ 	if (!err) {
+ 		preempt_disable();
+ 		tcf_action_stats_update(action, fl_act.stats.bytes,
+ 					fl_act.stats.pkts,
+ 					fl_act.stats.drops,
+ 					fl_act.stats.lastused,
+ 					true);
+ 		preempt_enable();
+ 		action->used_hw_stats = fl_act.stats.used_hw_stats;
+ 		action->used_hw_stats_valid = true;
+ 	} else {
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(tcf_action_update_hw_stats);
+ 
+ static int tcf_action_offload_del_ex(struct tc_action *action,
+ 				     flow_indr_block_bind_cb_t *cb,
+ 				     void *cb_priv)
+ {
+ 	struct flow_offload_action fl_act = {};
+ 	u32 in_hw_count = 0;
+ 	int err = 0;
+ 
+ 	if (!tc_act_in_hw(action))
+ 		return 0;
+ 
+ 	err = offload_action_init(&fl_act, action, FLOW_ACT_DESTROY, NULL);
+ 	if (err)
+ 		return err;
+ 
+ 	err = tcf_action_offload_cmd(&fl_act, &in_hw_count, cb, cb_priv);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (!cb && action->in_hw_count != in_hw_count)
+ 		return -EINVAL;
+ 
+ 	/* do not need to update hw state when deleting action */
+ 	if (cb && in_hw_count)
+ 		offload_action_hw_count_dec(action, in_hw_count);
+ 
+ 	return 0;
+ }
+ 
+ static int tcf_action_offload_del(struct tc_action *action)
+ {
+ 	return tcf_action_offload_del_ex(action, NULL, NULL);
+ }
+ 
++>>>>>>> 13926d19a11e (flow_offload: add reoffload process to update hw_count)
  static void tcf_action_cleanup(struct tc_action *p)
  {
 -	tcf_action_offload_del(p);
  	if (p->ops->cleanup)
  		p->ops->cleanup(p);
  
* Unmerged path include/net/act_api.h
diff --git a/net/core/flow_offload.c b/net/core/flow_offload.c
index 6beaea13564a..3c4e8ec6c68b 100644
--- a/net/core/flow_offload.c
+++ b/net/core/flow_offload.c
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <net/act_api.h>
 #include <net/flow_offload.h>
 #include <linux/rtnetlink.h>
 #include <linux/mutex.h>
@@ -397,6 +398,8 @@ int flow_indr_dev_register(flow_indr_block_bind_cb_t *cb, void *cb_priv)
 	existing_qdiscs_register(cb, cb_priv);
 	mutex_unlock(&flow_indr_block_lock);
 
+	tcf_action_reoffload_cb(cb, cb_priv, true);
+
 	return 0;
 }
 EXPORT_SYMBOL(flow_indr_dev_register);
@@ -449,6 +452,7 @@ void flow_indr_dev_unregister(flow_indr_block_bind_cb_t *cb, void *cb_priv,
 	__flow_block_indr_cleanup(release, cb_priv, &cleanup_list);
 	mutex_unlock(&flow_indr_block_lock);
 
+	tcf_action_reoffload_cb(cb, cb_priv, false);
 	flow_block_indr_notify(&cleanup_list);
 	kfree(indr_dev);
 }
* Unmerged path net/sched/act_api.c
