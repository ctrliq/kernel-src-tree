ASoC: SOF: Intel: hda: init NHLT for IPC4

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 1da51943725f29000ae4d2be3b3b4bf8309d99a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1da51943.failed

Init and save the BIOS NHLT as part of the IPC4 FW data.
Add a kernel module param to override the BIOS NHLT with the NHLT from
the topology. Also, add the ops_free callback for all HDA platforms to
free the NHLT.

Co-developed-by: Jaska Uimonen <jaska.uimonen@linux.intel.com>
	Signed-off-by: Jaska Uimonen <jaska.uimonen@linux.intel.com>
	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20220609032643.916882-19-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 1da51943725f29000ae4d2be3b3b4bf8309d99a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda-dai.c
#	sound/soc/sof/intel/hda.h
#	sound/soc/sof/intel/pci-apl.c
#	sound/soc/sof/intel/pci-cnl.c
#	sound/soc/sof/intel/pci-icl.c
#	sound/soc/sof/intel/pci-tgl.c
diff --cc sound/soc/sof/intel/hda-dai.c
index 4276d8a58f6f,228079a52c3d..000000000000
--- a/sound/soc/sof/intel/hda-dai.c
+++ b/sound/soc/sof/intel/hda-dai.c
@@@ -10,16 -10,25 +10,32 @@@
  
  #include <sound/pcm_params.h>
  #include <sound/hdaudio_ext.h>
++<<<<<<< HEAD
++=======
+ #include <sound/intel-nhlt.h>
+ #include <sound/sof/ipc4/header.h>
+ #include <uapi/sound/sof/header.h>
+ #include "../ipc4-priv.h"
+ #include "../ipc4-topology.h"
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  #include "../sof-priv.h"
  #include "../sof-audio.h"
  #include "hda.h"
  
+ /*
+  * The default method is to fetch NHLT from BIOS. With this parameter set
+  * it is possible to override that with NHLT in the SOF topology manifest.
+  */
+ static bool hda_use_tplg_nhlt;
+ module_param_named(sof_use_tplg_nhlt, hda_use_tplg_nhlt, bool, 0444);
+ MODULE_PARM_DESC(sof_use_tplg_nhlt, "SOF topology nhlt override");
+ 
  #if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)
  
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_PROBES)
 +#include "../sof-probes.h"
 +#endif
 +
  struct hda_pipe_params {
  	u32 ch;
  	u32 s_freq;
@@@ -643,6 -713,120 +659,123 @@@ static const struct snd_soc_dai_ops ssp
  	.shutdown = ssp_dai_shutdown,
  };
  
++<<<<<<< HEAD
++=======
+ static int ipc4_be_dai_trigger(struct snd_pcm_substream *substream,
+ 			       int cmd, struct snd_soc_dai *dai)
+ {
+ 	struct snd_sof_widget *pipe_widget;
+ 	struct sof_ipc4_pipeline *pipeline;
+ 	struct snd_sof_widget *swidget;
+ 	struct snd_soc_dapm_widget *w;
+ 	struct snd_sof_dev *sdev;
+ 	int ret;
+ 
+ 	w = snd_soc_dai_get_widget(dai, substream->stream);
+ 	swidget = w->dobj.private;
+ 	pipe_widget = swidget->pipe_widget;
+ 	pipeline = pipe_widget->private;
+ 	sdev = snd_soc_component_get_drvdata(swidget->scomp);
+ 
+ 	switch (cmd) {
+ 	case SNDRV_PCM_TRIGGER_SUSPEND:
+ 	case SNDRV_PCM_TRIGGER_STOP:
+ 		ret = sof_ipc4_set_pipeline_state(sdev, swidget->pipeline_id,
+ 						  SOF_IPC4_PIPE_PAUSED);
+ 		if (ret < 0)
+ 			return ret;
+ 		pipeline->state = SOF_IPC4_PIPE_PAUSED;
+ 
+ 		ret = sof_ipc4_set_pipeline_state(sdev, swidget->pipeline_id,
+ 						  SOF_IPC4_PIPE_RESET);
+ 		if (ret < 0)
+ 			return ret;
+ 		pipeline->state = SOF_IPC4_PIPE_RESET;
+ 		break;
+ 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+ 		ret = sof_ipc4_set_pipeline_state(sdev, swidget->pipeline_id,
+ 						  SOF_IPC4_PIPE_PAUSED);
+ 		if (ret < 0)
+ 			return ret;
+ 		pipeline->state = SOF_IPC4_PIPE_PAUSED;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct snd_soc_dai_ops ipc4_dmic_dai_ops = {
+ 	.trigger = ipc4_be_dai_trigger,
+ };
+ 
+ static const struct snd_soc_dai_ops ipc4_ssp_dai_ops = {
+ 	.trigger = ipc4_be_dai_trigger,
+ };
+ 
+ void hda_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops)
+ {
+ 	int i;
+ 
+ 	switch (sdev->pdata->ipc_type) {
+ 	case SOF_IPC:
+ 		for (i = 0; i < ops->num_drv; i++) {
+ 			if (strstr(ops->drv[i].name, "SSP")) {
+ 				ops->drv[i].ops = &ipc3_ssp_dai_ops;
+ 				continue;
+ 			}
+ #if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)
+ 			if (strstr(ops->drv[i].name, "iDisp") ||
+ 			    strstr(ops->drv[i].name, "Analog") ||
+ 			    strstr(ops->drv[i].name, "Digital"))
+ 				ops->drv[i].ops = &ipc3_hda_dai_ops;
+ #endif
+ 		}
+ 		break;
+ 	case SOF_INTEL_IPC4:
+ 	{
+ 		struct sof_ipc4_fw_data *ipc4_data = sdev->private;
+ 
+ 		for (i = 0; i < ops->num_drv; i++) {
+ 			if (strstr(ops->drv[i].name, "DMIC")) {
+ 				ops->drv[i].ops = &ipc4_dmic_dai_ops;
+ 				continue;
+ 			}
+ 			if (strstr(ops->drv[i].name, "SSP")) {
+ 				ops->drv[i].ops = &ipc4_ssp_dai_ops;
+ 				continue;
+ 			}
+ #if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)
+ 			if (strstr(ops->drv[i].name, "iDisp") ||
+ 			    strstr(ops->drv[i].name, "Analog") ||
+ 			    strstr(ops->drv[i].name, "Digital"))
+ 				ops->drv[i].ops = &ipc4_hda_dai_ops;
+ #endif
+ 		}
+ 
+ 		if (!hda_use_tplg_nhlt)
+ 			ipc4_data->nhlt = intel_nhlt_init(sdev->dev);
+ 
+ 		break;
+ 	}
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ void hda_ops_free(struct snd_sof_dev *sdev)
+ {
+ 	if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {
+ 		struct sof_ipc4_fw_data *ipc4_data = sdev->private;
+ 
+ 		if (!hda_use_tplg_nhlt)
+ 			intel_nhlt_free(ipc4_data->nhlt);
+ 	}
+ }
+ EXPORT_SYMBOL_NS(hda_ops_free, SND_SOC_SOF_INTEL_HDA_COMMON);
+ 
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  /*
   * common dai driver for skl+ platforms.
   * some products who use this DAI array only physically have a subset of
diff --cc sound/soc/sof/intel/hda.h
index 1ed56c3ec7e2,59181468e05e..000000000000
--- a/sound/soc/sof/intel/hda.h
+++ b/sound/soc/sof/intel/hda.h
@@@ -763,4 -762,13 +763,16 @@@ int hda_ctrl_dai_widget_free(struct snd
  
  extern int sof_hda_position_quirk;
  
++<<<<<<< HEAD
++=======
+ void hda_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops);
+ void hda_ops_free(struct snd_sof_dev *sdev);
+ 
+ /* IPC4 */
+ irqreturn_t cnl_ipc4_irq_thread(int irq, void *context);
+ int cnl_ipc4_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg);
+ irqreturn_t hda_dsp_ipc4_irq_thread(int irq, void *context);
+ int hda_dsp_ipc4_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg);
+ 
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  #endif
diff --cc sound/soc/sof/intel/pci-apl.c
index 519a40d8b1eb,998e219011f0..000000000000
--- a/sound/soc/sof/intel/pci-apl.c
+++ b/sound/soc/sof/intel/pci-apl.c
@@@ -43,6 -43,8 +43,11 @@@ static const struct sof_dev_desc bxt_de
  	},
  	.nocodec_tplg_filename = "sof-apl-nocodec.tplg",
  	.ops = &sof_apl_ops,
++<<<<<<< HEAD
++=======
+ 	.ops_init = sof_apl_ops_init,
+ 	.ops_free = hda_ops_free,
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  };
  
  static const struct sof_dev_desc glk_desc = {
diff --cc sound/soc/sof/intel/pci-cnl.c
index 7221243b6615,c797356f7028..000000000000
--- a/sound/soc/sof/intel/pci-cnl.c
+++ b/sound/soc/sof/intel/pci-cnl.c
@@@ -71,6 -72,8 +71,11 @@@ static const struct sof_dev_desc cfl_de
  	},
  	.nocodec_tplg_filename = "sof-cnl-nocodec.tplg",
  	.ops = &sof_cnl_ops,
++<<<<<<< HEAD
++=======
+ 	.ops_init = sof_cnl_ops_init,
+ 	.ops_free = hda_ops_free,
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  };
  
  static const struct sof_dev_desc cml_desc = {
diff --cc sound/soc/sof/intel/pci-icl.c
index f8cdf3aa3703,48f24f8ace26..000000000000
--- a/sound/soc/sof/intel/pci-icl.c
+++ b/sound/soc/sof/intel/pci-icl.c
@@@ -44,6 -44,8 +44,11 @@@ static const struct sof_dev_desc icl_de
  	},
  	.nocodec_tplg_filename = "sof-icl-nocodec.tplg",
  	.ops = &sof_icl_ops,
++<<<<<<< HEAD
++=======
+ 	.ops_init = sof_icl_ops_init,
+ 	.ops_free = hda_ops_free,
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  };
  
  static const struct sof_dev_desc jsl_desc = {
diff --cc sound/soc/sof/intel/pci-tgl.c
index 716c22579802,ccc44ba3ad94..000000000000
--- a/sound/soc/sof/intel/pci-tgl.c
+++ b/sound/soc/sof/intel/pci-tgl.c
@@@ -71,6 -72,8 +71,11 @@@ static const struct sof_dev_desc tglh_d
  	},
  	.nocodec_tplg_filename = "sof-tgl-nocodec.tplg",
  	.ops = &sof_tgl_ops,
++<<<<<<< HEAD
++=======
+ 	.ops_init = sof_tgl_ops_init,
+ 	.ops_free = hda_ops_free,
++>>>>>>> 1da51943725f (ASoC: SOF: Intel: hda: init NHLT for IPC4)
  };
  
  static const struct sof_dev_desc ehl_desc = {
* Unmerged path sound/soc/sof/intel/hda-dai.c
* Unmerged path sound/soc/sof/intel/hda.h
* Unmerged path sound/soc/sof/intel/pci-apl.c
* Unmerged path sound/soc/sof/intel/pci-cnl.c
* Unmerged path sound/soc/sof/intel/pci-icl.c
* Unmerged path sound/soc/sof/intel/pci-tgl.c
diff --git a/sound/soc/sof/ipc4-priv.h b/sound/soc/sof/ipc4-priv.h
index 3a1b97e93a7d..124f1a6bd211 100644
--- a/sound/soc/sof/ipc4-priv.h
+++ b/sound/soc/sof/ipc4-priv.h
@@ -17,11 +17,13 @@
  * @manifest_fw_hdr_offset: FW header offset in the manifest
  * @num_fw_modules : Number of modules in base FW
  * @fw_modules: Array of base FW modules
+ * @nhlt: NHLT table either from the BIOS or the topology manifest
  */
 struct sof_ipc4_fw_data {
 	u32 manifest_fw_hdr_offset;
 	int num_fw_modules;
 	void *fw_modules;
+	void *nhlt;
 };
 
 #endif
