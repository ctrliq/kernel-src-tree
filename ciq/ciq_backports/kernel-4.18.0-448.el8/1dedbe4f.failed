ASoC: SOF: Switch to IPC generic firmware tracing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit 1dedbe4f223cac603e871d91133b9aa3136fbc21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1dedbe4f.failed

Introduce new, generic API for firmware tracing with sof_fw_trace_ prefix
and switch to use it.
At the same time the old IPC3 code can be dropped from trace.c, which is
now a generic wrapper for the firmware tracing ops.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220516104711.26115-5-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 1dedbe4f223cac603e871d91133b9aa3136fbc21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc.c
#	sound/soc/sof/ipc3.c
#	sound/soc/sof/pm.c
#	sound/soc/sof/trace.c
diff --cc sound/soc/sof/ipc.c
index ed366c99fce2,c5aef5fc056b..000000000000
--- a/sound/soc/sof/ipc.c
+++ b/sound/soc/sof/ipc.c
@@@ -1016,6 -155,41 +1016,44 @@@ struct snd_sof_ipc *snd_sof_ipc_init(st
  
  	init_waitqueue_head(&msg->waitq);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Use IPC3 ops as it is the only available version now. With the addition of new IPC
+ 	 * versions, this will need to be modified to use the selected version at runtime.
+ 	 */
+ 	ipc->ops = &ipc3_ops;
+ 	ops = ipc->ops;
+ 
+ 	/* check for mandatory ops */
+ 	if (!ops->tx_msg || !ops->rx_msg || !ops->set_get_data || !ops->get_reply) {
+ 		dev_err(sdev->dev, "Missing IPC message handling ops\n");
+ 		return NULL;
+ 	}
+ 
+ 	if (!ops->fw_loader || !ops->fw_loader->validate ||
+ 	    !ops->fw_loader->parse_ext_manifest) {
+ 		dev_err(sdev->dev, "Missing IPC firmware loading ops\n");
+ 		return NULL;
+ 	}
+ 
+ 	if (!ops->pcm) {
+ 		dev_err(sdev->dev, "Missing IPC PCM ops\n");
+ 		return NULL;
+ 	}
+ 
+ 	if (!ops->tplg || !ops->tplg->widget || !ops->tplg->control) {
+ 		dev_err(sdev->dev, "Missing IPC topology ops\n");
+ 		return NULL;
+ 	}
+ 
+ 	if (ops->fw_tracing && (!ops->fw_tracing->init || !ops->fw_tracing->suspend ||
+ 				!ops->fw_tracing->resume)) {
+ 		dev_err(sdev->dev, "Missing firmware tracing ops\n");
+ 		return NULL;
+ 	}
+ 
++>>>>>>> 1dedbe4f223c (ASoC: SOF: Switch to IPC generic firmware tracing)
  	return ipc;
  }
  EXPORT_SYMBOL(snd_sof_ipc_init);
diff --cc sound/soc/sof/pm.c
index 1e40cb6e8b58,18eb327a57f0..000000000000
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@@ -116,11 -102,18 +116,20 @@@ static int sof_resume(struct device *de
  
  	/*
  	 * Nothing further to be done for platforms that support the low power
 -	 * D0 substate. Resume trace and return when resuming from
 -	 * low-power D0 substate
 +	 * D0 substate.
  	 */
  	if (!runtime_resume && sof_ops(sdev)->set_power_state &&
++<<<<<<< HEAD
 +	    old_state == SOF_DSP_PM_D0)
++=======
+ 	    old_state == SOF_DSP_PM_D0) {
+ 		ret = sof_fw_trace_resume(sdev);
+ 		if (ret < 0)
+ 			/* non fatal */
+ 			dev_warn(sdev->dev,
+ 				 "failed to enable trace after resume %d\n", ret);
++>>>>>>> 1dedbe4f223c (ASoC: SOF: Switch to IPC generic firmware tracing)
  		return 0;
 -	}
  
  	sof_set_fw_state(sdev, SOF_FW_BOOT_PREPARE);
  
@@@ -205,16 -204,25 +214,23 @@@ static int sof_suspend(struct device *d
  	}
  
  	target_state = snd_sof_dsp_power_target(sdev);
 -	pm_state.event = target_state;
  
  	/* Skip to platform-specific suspend if DSP is entering D0 */
++<<<<<<< HEAD
 +	if (target_state == SOF_DSP_PM_D0)
++=======
+ 	if (target_state == SOF_DSP_PM_D0) {
+ 		sof_fw_trace_suspend(sdev, pm_state);
+ 		/* Notify clients not managed by pm framework about core suspend */
+ 		sof_suspend_clients(sdev, pm_state);
++>>>>>>> 1dedbe4f223c (ASoC: SOF: Switch to IPC generic firmware tracing)
  		goto suspend;
 -	}
  
 -	if (tplg_ops->tear_down_all_pipelines)
 -		tplg_ops->tear_down_all_pipelines(sdev, false);
 +	sof_tear_down_pipelines(sdev, false);
  
  	/* suspend DMA trace */
- 	snd_sof_trace_suspend(sdev, pm_state);
+ 	sof_fw_trace_suspend(sdev, pm_state);
  
 -	/* Notify clients not managed by pm framework about core suspend */
 -	sof_suspend_clients(sdev, pm_state);
 -
  #if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)
  	/* cache debugfs contents during runtime suspend */
  	if (runtime_suspend)
diff --cc sound/soc/sof/trace.c
index 0ccb567c6429,6f662642d611..000000000000
--- a/sound/soc/sof/trace.c
+++ b/sound/soc/sof/trace.c
@@@ -1,634 -1,51 +1,592 @@@
- // SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
- //
- // This file is provided under a dual BSD/GPLv2 license.  When using or
- // redistributing this file, you may do so under either license.
- //
- // Copyright(c) 2018 Intel Corporation. All rights reserved.
- //
- // Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
+ // SPDX-License-Identifier: GPL-2.0-only
  //
+ // Copyright(c) 2022 Intel Corporation. All rights reserved.
  
- #include <linux/debugfs.h>
- #include <linux/sched/signal.h>
  #include "sof-priv.h"
- #include "sof-audio.h"
- #include "ops.h"
- #include "sof-utils.h"
  
- #define TRACE_FILTER_ELEMENTS_PER_ENTRY 4
- #define TRACE_FILTER_MAX_CONFIG_STRING_LENGTH 1024
- 
- static int trace_filter_append_elem(struct snd_sof_dev *sdev, uint32_t key, uint32_t value,
- 				    struct sof_ipc_trace_filter_elem *elem_list,
- 				    int capacity, int *counter)
+ int sof_fw_trace_init(struct snd_sof_dev *sdev)
  {
++<<<<<<< HEAD
 +	if (*counter >= capacity)
 +		return -ENOMEM;
 +
 +	elem_list[*counter].key = key;
 +	elem_list[*counter].value = value;
 +	++*counter;
 +
 +	return 0;
 +}
 +
 +static int trace_filter_parse_entry(struct snd_sof_dev *sdev, const char *line,
 +				    struct sof_ipc_trace_filter_elem *elem,
 +				    int capacity, int *counter)
 +{
 +	int len = strlen(line);
 +	int cnt = *counter;
 +	uint32_t uuid_id;
 +	int log_level;
 +	int pipe_id;
 +	int comp_id;
 +	int read;
 +	int ret;
 +
 +	/* ignore empty content */
 +	ret = sscanf(line, " %n", &read);
 +	if (!ret && read == len)
 +		return len;
 +
 +	ret = sscanf(line, " %d %x %d %d %n", &log_level, &uuid_id, &pipe_id, &comp_id, &read);
 +	if (ret != TRACE_FILTER_ELEMENTS_PER_ENTRY || read != len) {
 +		dev_err(sdev->dev, "error: invalid trace filter entry '%s'\n", line);
 +		return -EINVAL;
 +	}
 +
 +	if (uuid_id > 0) {
 +		ret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_BY_UUID,
 +					       uuid_id, elem, capacity, &cnt);
 +		if (ret)
 +			return ret;
 +	}
 +	if (pipe_id >= 0) {
 +		ret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_BY_PIPE,
 +					       pipe_id, elem, capacity, &cnt);
 +		if (ret)
 +			return ret;
 +	}
 +	if (comp_id >= 0) {
 +		ret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_BY_COMP,
 +					       comp_id, elem, capacity, &cnt);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	ret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_SET_LEVEL |
 +				       SOF_IPC_TRACE_FILTER_ELEM_FIN,
 +				       log_level, elem, capacity, &cnt);
 +	if (ret)
 +		return ret;
 +
 +	/* update counter only when parsing whole entry passed */
 +	*counter = cnt;
 +
 +	return len;
 +}
 +
 +static int trace_filter_parse(struct snd_sof_dev *sdev, char *string,
 +			      int *out_elem_cnt,
 +			      struct sof_ipc_trace_filter_elem **out)
 +{
 +	static const char entry_delimiter[] = ";";
 +	char *entry = string;
 +	int capacity = 0;
 +	int entry_len;
 +	int cnt = 0;
 +
 +	/*
 +	 * Each entry contains at least 1, up to TRACE_FILTER_ELEMENTS_PER_ENTRY
 +	 * IPC elements, depending on content. Calculate IPC elements capacity
 +	 * for the input string where each element is set.
 +	 */
 +	while (entry) {
 +		capacity += TRACE_FILTER_ELEMENTS_PER_ENTRY;
 +		entry = strchr(entry + 1, entry_delimiter[0]);
 +	}
 +	*out = kmalloc(capacity * sizeof(**out), GFP_KERNEL);
 +	if (!*out)
 +		return -ENOMEM;
 +
 +	/* split input string by ';', and parse each entry separately in trace_filter_parse_entry */
 +	while ((entry = strsep(&string, entry_delimiter))) {
 +		entry_len = trace_filter_parse_entry(sdev, entry, *out, capacity, &cnt);
 +		if (entry_len < 0) {
 +			dev_err(sdev->dev, "error: %s failed for '%s', %d\n", __func__, entry,
 +				entry_len);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	*out_elem_cnt = cnt;
 +
 +	return 0;
 +}
 +
 +static int sof_ipc_trace_update_filter(struct snd_sof_dev *sdev, int num_elems,
 +				       struct sof_ipc_trace_filter_elem *elems)
 +{
 +	struct sof_ipc_trace_filter *msg;
 +	struct sof_ipc_reply reply;
 +	size_t size;
 +	int ret;
 +
 +	size = struct_size(msg, elems, num_elems);
 +	if (size > SOF_IPC_MSG_MAX_SIZE)
 +		return -EINVAL;
 +
 +	msg = kmalloc(size, GFP_KERNEL);
 +	if (!msg)
 +		return -ENOMEM;
 +
 +	msg->hdr.size = size;
 +	msg->hdr.cmd = SOF_IPC_GLB_TRACE_MSG | SOF_IPC_TRACE_FILTER_UPDATE;
 +	msg->elem_cnt = num_elems;
 +	memcpy(&msg->elems[0], elems, num_elems * sizeof(*elems));
 +
 +	ret = pm_runtime_get_sync(sdev->dev);
 +	if (ret < 0 && ret != -EACCES) {
 +		pm_runtime_put_noidle(sdev->dev);
 +		dev_err(sdev->dev, "error: enabling device failed: %d\n", ret);
 +		goto error;
 +	}
 +	ret = sof_ipc_tx_message(sdev->ipc, msg->hdr.cmd, msg, msg->hdr.size,
 +				 &reply, sizeof(reply));
 +	pm_runtime_mark_last_busy(sdev->dev);
 +	pm_runtime_put_autosuspend(sdev->dev);
 +
 +error:
 +	kfree(msg);
 +	return ret ? ret : reply.error;
 +}
 +
 +static ssize_t sof_dfsentry_trace_filter_write(struct file *file, const char __user *from,
 +					       size_t count, loff_t *ppos)
 +{
 +	struct snd_sof_dfsentry *dfse = file->private_data;
 +	struct sof_ipc_trace_filter_elem *elems = NULL;
 +	struct snd_sof_dev *sdev = dfse->sdev;
 +	loff_t pos = 0;
 +	int num_elems;
 +	char *string;
 +	int ret;
 +
 +	if (count > TRACE_FILTER_MAX_CONFIG_STRING_LENGTH) {
 +		dev_err(sdev->dev, "%s too long input, %zu > %d\n", __func__, count,
 +			TRACE_FILTER_MAX_CONFIG_STRING_LENGTH);
 +		return -EINVAL;
 +	}
 +
 +	string = kmalloc(count + 1, GFP_KERNEL);
 +	if (!string)
 +		return -ENOMEM;
 +
 +	/* assert null termination */
 +	string[count] = 0;
 +	ret = simple_write_to_buffer(string, count, &pos, from, count);
 +	if (ret < 0)
 +		goto error;
 +
 +	ret = trace_filter_parse(sdev, string, &num_elems, &elems);
 +	if (ret < 0) {
 +		dev_err(sdev->dev, "error: fail in trace_filter_parse, %d\n", ret);
 +		goto error;
 +	}
 +
 +	if (num_elems) {
 +		ret = sof_ipc_trace_update_filter(sdev, num_elems, elems);
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "error: fail in sof_ipc_trace_update_filter %d\n", ret);
 +			goto error;
 +		}
 +	}
 +	ret = count;
 +error:
 +	kfree(string);
 +	kfree(elems);
 +	return ret;
 +}
 +
 +static const struct file_operations sof_dfs_trace_filter_fops = {
 +	.open = simple_open,
 +	.write = sof_dfsentry_trace_filter_write,
 +	.llseek = default_llseek,
 +};
 +
 +static int trace_debugfs_filter_create(struct snd_sof_dev *sdev)
 +{
 +	struct snd_sof_dfsentry *dfse;
 +
 +	dfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);
 +	if (!dfse)
 +		return -ENOMEM;
 +
 +	dfse->sdev = sdev;
 +	dfse->type = SOF_DFSENTRY_TYPE_BUF;
 +
 +	debugfs_create_file("filter", 0200, sdev->debugfs_root, dfse,
 +			    &sof_dfs_trace_filter_fops);
 +	/* add to dfsentry list */
 +	list_add(&dfse->list, &sdev->dfsentry_list);
 +
 +	return 0;
 +}
 +
 +static size_t sof_trace_avail(struct snd_sof_dev *sdev,
 +			      loff_t pos, size_t buffer_size)
 +{
 +	loff_t host_offset = READ_ONCE(sdev->host_offset);
 +
 +	/*
 +	 * If host offset is less than local pos, it means write pointer of
 +	 * host DMA buffer has been wrapped. We should output the trace data
 +	 * at the end of host DMA buffer at first.
 +	 */
 +	if (host_offset < pos)
 +		return buffer_size - pos;
 +
 +	/* If there is available trace data now, it is unnecessary to wait. */
 +	if (host_offset > pos)
 +		return host_offset - pos;
 +
 +	return 0;
 +}
 +
 +static size_t sof_wait_trace_avail(struct snd_sof_dev *sdev,
 +				   loff_t pos, size_t buffer_size)
 +{
 +	wait_queue_entry_t wait;
 +	size_t ret = sof_trace_avail(sdev, pos, buffer_size);
 +
 +	/* data immediately available */
 +	if (ret)
 +		return ret;
 +
 +	if (sdev->dtrace_state != SOF_DTRACE_ENABLED && sdev->dtrace_draining) {
 +		/*
 +		 * tracing has ended and all traces have been
 +		 * read by client, return EOF
 +		 */
 +		sdev->dtrace_draining = false;
 +		return 0;
 +	}
 +
 +	/* wait for available trace data from FW */
 +	init_waitqueue_entry(&wait, current);
 +	set_current_state(TASK_INTERRUPTIBLE);
 +	add_wait_queue(&sdev->trace_sleep, &wait);
 +
 +	if (!signal_pending(current)) {
 +		/* set timeout to max value, no error code */
 +		schedule_timeout(MAX_SCHEDULE_TIMEOUT);
 +	}
 +	remove_wait_queue(&sdev->trace_sleep, &wait);
 +
 +	return sof_trace_avail(sdev, pos, buffer_size);
 +}
 +
 +static ssize_t sof_dfsentry_trace_read(struct file *file, char __user *buffer,
 +				       size_t count, loff_t *ppos)
 +{
 +	struct snd_sof_dfsentry *dfse = file->private_data;
 +	struct snd_sof_dev *sdev = dfse->sdev;
 +	unsigned long rem;
 +	loff_t lpos = *ppos;
 +	size_t avail, buffer_size = dfse->size;
 +	u64 lpos_64;
 +
 +	/* make sure we know about any failures on the DSP side */
 +	sdev->dtrace_error = false;
 +
 +	/* check pos and count */
 +	if (lpos < 0)
 +		return -EINVAL;
 +	if (!count)
 +		return 0;
 +
 +	/* check for buffer wrap and count overflow */
 +	lpos_64 = lpos;
 +	lpos = do_div(lpos_64, buffer_size);
 +
 +	/* get available count based on current host offset */
 +	avail = sof_wait_trace_avail(sdev, lpos, buffer_size);
 +	if (sdev->dtrace_error) {
 +		dev_err(sdev->dev, "error: trace IO error\n");
 +		return -EIO;
 +	}
 +
 +	/* make sure count is <= avail */
 +	if (count > avail)
 +		count = avail;
 +
 +	/*
 +	 * make sure that all trace data is available for the CPU as the trace
 +	 * data buffer might be allocated from non consistent memory.
 +	 * Note: snd_dma_buffer_sync() is called for normal audio playback and
 +	 *	 capture streams also.
 +	 */
 +	snd_dma_buffer_sync(&sdev->dmatb, SNDRV_DMA_SYNC_CPU);
 +	/* copy available trace data to debugfs */
 +	rem = copy_to_user(buffer, ((u8 *)(dfse->buf) + lpos), count);
 +	if (rem)
 +		return -EFAULT;
 +
 +	*ppos += count;
 +
 +	/* move debugfs reading position */
 +	return count;
 +}
 +
 +static int sof_dfsentry_trace_release(struct inode *inode, struct file *file)
 +{
 +	struct snd_sof_dfsentry *dfse = inode->i_private;
 +	struct snd_sof_dev *sdev = dfse->sdev;
 +
 +	/* avoid duplicate traces at next open */
 +	if (sdev->dtrace_state != SOF_DTRACE_ENABLED)
 +		sdev->host_offset = 0;
 +
 +	return 0;
 +}
 +
 +static const struct file_operations sof_dfs_trace_fops = {
 +	.open = simple_open,
 +	.read = sof_dfsentry_trace_read,
 +	.llseek = default_llseek,
 +	.release = sof_dfsentry_trace_release,
 +};
 +
 +static int trace_debugfs_create(struct snd_sof_dev *sdev)
 +{
 +	struct snd_sof_dfsentry *dfse;
 +	int ret;
 +
 +	if (!sdev)
 +		return -EINVAL;
 +
 +	ret = trace_debugfs_filter_create(sdev);
 +	if (ret < 0)
 +		dev_err(sdev->dev, "error: fail in %s, %d", __func__, ret);
 +
 +	dfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);
 +	if (!dfse)
 +		return -ENOMEM;
 +
 +	dfse->type = SOF_DFSENTRY_TYPE_BUF;
 +	dfse->buf = sdev->dmatb.area;
 +	dfse->size = sdev->dmatb.bytes;
 +	dfse->sdev = sdev;
 +
 +	dfse->dfsentry = debugfs_create_file("trace", 0444, sdev->debugfs_root,
 +					     dfse, &sof_dfs_trace_fops);
 +	if (!dfse->dfsentry) {
 +		/* can't rely on debugfs, only log error and keep going */
 +		dev_err(sdev->dev,
 +			"error: cannot create debugfs entry for trace\n");
 +	}
 +
 +	return 0;
 +}
 +
 +static int snd_sof_enable_trace(struct snd_sof_dev *sdev)
 +{
 +	struct sof_ipc_fw_ready *ready = &sdev->fw_ready;
 +	struct sof_ipc_fw_version *v = &ready->version;
 +	struct sof_ipc_dma_trace_params_ext params;
 +	struct sof_ipc_reply ipc_reply;
 +	int ret;
 +
 +	if (!sdev->dtrace_is_supported)
 +		return 0;
 +
 +	if (sdev->dtrace_state == SOF_DTRACE_ENABLED || !sdev->dma_trace_pages)
 +		return -EINVAL;
 +
 +	if (sdev->dtrace_state == SOF_DTRACE_STOPPED)
 +		goto start;
 +
 +	/* set IPC parameters */
 +	params.hdr.cmd = SOF_IPC_GLB_TRACE_MSG;
 +	/* PARAMS_EXT is only supported from ABI 3.7.0 onwards */
 +	if (v->abi_version >= SOF_ABI_VER(3, 7, 0)) {
 +		params.hdr.size = sizeof(struct sof_ipc_dma_trace_params_ext);
 +		params.hdr.cmd |= SOF_IPC_TRACE_DMA_PARAMS_EXT;
 +		params.timestamp_ns = ktime_get(); /* in nanosecond */
 +	} else {
 +		params.hdr.size = sizeof(struct sof_ipc_dma_trace_params);
 +		params.hdr.cmd |= SOF_IPC_TRACE_DMA_PARAMS;
 +	}
 +	params.buffer.phy_addr = sdev->dmatp.addr;
 +	params.buffer.size = sdev->dmatb.bytes;
 +	params.buffer.pages = sdev->dma_trace_pages;
 +	params.stream_tag = 0;
 +
 +	sdev->host_offset = 0;
 +	sdev->dtrace_draining = false;
 +
 +	ret = snd_sof_dma_trace_init(sdev, &params);
 +	if (ret < 0) {
 +		dev_err(sdev->dev,
 +			"error: fail in snd_sof_dma_trace_init %d\n", ret);
 +		return ret;
 +	}
 +	dev_dbg(sdev->dev, "%s: stream_tag: %d\n", __func__, params.stream_tag);
 +
 +	/* send IPC to the DSP */
 +	ret = sof_ipc_tx_message(sdev->ipc,
 +				 params.hdr.cmd, &params, sizeof(params),
 +				 &ipc_reply, sizeof(ipc_reply));
 +	if (ret < 0) {
 +		dev_err(sdev->dev,
 +			"error: can't set params for DMA for trace %d\n", ret);
 +		goto trace_release;
 +	}
 +
 +start:
 +	ret = snd_sof_dma_trace_trigger(sdev, SNDRV_PCM_TRIGGER_START);
 +	if (ret < 0) {
 +		dev_err(sdev->dev,
 +			"error: snd_sof_dma_trace_trigger: start: %d\n", ret);
 +		goto trace_release;
 +	}
 +
 +	sdev->dtrace_state = SOF_DTRACE_ENABLED;
 +
 +	return 0;
 +
 +trace_release:
 +	snd_sof_dma_trace_release(sdev);
 +	return ret;
 +}
 +
 +int snd_sof_init_trace(struct snd_sof_dev *sdev)
 +{
 +	int ret;
 +
 +	/* dtrace is only supported with SOF_IPC */
 +	if (sdev->pdata->ipc_type != SOF_IPC)
 +		sdev->dtrace_is_supported = false;
 +
 +	if (!sdev->dtrace_is_supported)
- 		return 0;
- 
- 	/* set false before start initialization */
- 	sdev->dtrace_state = SOF_DTRACE_DISABLED;
++=======
+ 	if (!sdev->ipc->ops->fw_tracing) {
+ 		dev_info(sdev->dev, "Firmware tracing is not available\n");
+ 		sdev->fw_trace_is_supported = false;
  
- 	/* allocate trace page table buffer */
- 	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev,
- 				  PAGE_SIZE, &sdev->dmatp);
- 	if (ret < 0) {
- 		dev_err(sdev->dev,
- 			"error: can't alloc page table for trace %d\n", ret);
- 		return ret;
++>>>>>>> 1dedbe4f223c (ASoC: SOF: Switch to IPC generic firmware tracing)
+ 		return 0;
  	}
  
- 	/* allocate trace data buffer */
- 	ret = snd_dma_alloc_dir_pages(SNDRV_DMA_TYPE_DEV_SG, sdev->dev,
- 				      DMA_FROM_DEVICE, DMA_BUF_SIZE_FOR_TRACE,
- 				      &sdev->dmatb);
- 	if (ret < 0) {
- 		dev_err(sdev->dev,
- 			"error: can't alloc buffer for trace %d\n", ret);
- 		goto page_err;
- 	}
+ 	return sdev->ipc->ops->fw_tracing->init(sdev);
+ }
  
- 	/* create compressed page table for audio firmware */
- 	ret = snd_sof_create_page_table(sdev->dev, &sdev->dmatb,
- 					sdev->dmatp.area, sdev->dmatb.bytes);
- 	if (ret < 0)
- 		goto table_err;
+ void sof_fw_trace_free(struct snd_sof_dev *sdev)
+ {
+ 	if (!sdev->fw_trace_is_supported || !sdev->ipc->ops->fw_tracing)
+ 		return;
  
- 	sdev->dma_trace_pages = ret;
- 	dev_dbg(sdev->dev, "%s: dma_trace_pages: %d\n",
- 		__func__, sdev->dma_trace_pages);
+ 	if (sdev->ipc->ops->fw_tracing->free)
+ 		sdev->ipc->ops->fw_tracing->free(sdev);
+ }
  
- 	if (sdev->first_boot) {
- 		ret = trace_debugfs_create(sdev);
- 		if (ret < 0)
- 			goto table_err;
- 	}
+ void sof_fw_trace_fw_crashed(struct snd_sof_dev *sdev)
+ {
+ 	if (!sdev->fw_trace_is_supported)
+ 		return;
  
- 	init_waitqueue_head(&sdev->trace_sleep);
+ 	if (sdev->ipc->ops->fw_tracing->fw_crashed)
+ 		sdev->ipc->ops->fw_tracing->fw_crashed(sdev);
+ }
  
- 	ret = snd_sof_enable_trace(sdev);
- 	if (ret < 0)
- 		goto table_err;
+ void sof_fw_trace_suspend(struct snd_sof_dev *sdev, pm_message_t pm_state)
+ {
+ 	if (!sdev->fw_trace_is_supported)
+ 		return;
  
- 	return 0;
- table_err:
- 	sdev->dma_trace_pages = 0;
- 	snd_dma_free_pages(&sdev->dmatb);
- page_err:
- 	snd_dma_free_pages(&sdev->dmatp);
- 	return ret;
+ 	sdev->ipc->ops->fw_tracing->suspend(sdev, pm_state);
  }
- EXPORT_SYMBOL(snd_sof_init_trace);
  
- int snd_sof_trace_update_pos(struct snd_sof_dev *sdev,
- 			     struct sof_ipc_dma_trace_posn *posn)
+ int sof_fw_trace_resume(struct snd_sof_dev *sdev)
  {
 -	if (!sdev->fw_trace_is_supported)
 +	if (!sdev->dtrace_is_supported)
  		return 0;
  
- 	if (sdev->dtrace_state == SOF_DTRACE_ENABLED &&
- 	    sdev->host_offset != posn->host_offset) {
- 		sdev->host_offset = posn->host_offset;
- 		wake_up(&sdev->trace_sleep);
- 	}
- 
- 	if (posn->overflow != 0)
- 		dev_err(sdev->dev,
- 			"error: DSP trace buffer overflow %u bytes. Total messages %d\n",
- 			posn->overflow, posn->messages);
- 
- 	return 0;
+ 	return sdev->ipc->ops->fw_tracing->resume(sdev);
  }
++<<<<<<< HEAD
 +
 +/* an error has occurred within the DSP that prevents further trace */
 +void snd_sof_trace_notify_for_error(struct snd_sof_dev *sdev)
 +{
 +	if (!sdev->dtrace_is_supported)
 +		return;
 +
 +	if (sdev->dtrace_state == SOF_DTRACE_ENABLED) {
 +		sdev->dtrace_error = true;
 +		wake_up(&sdev->trace_sleep);
 +	}
 +}
 +EXPORT_SYMBOL(snd_sof_trace_notify_for_error);
 +
 +static void snd_sof_release_trace(struct snd_sof_dev *sdev, bool only_stop)
 +{
 +	struct sof_ipc_fw_ready *ready = &sdev->fw_ready;
 +	struct sof_ipc_fw_version *v = &ready->version;
 +	struct sof_ipc_cmd_hdr hdr;
 +	struct sof_ipc_reply ipc_reply;
 +	int ret;
 +
 +	if (!sdev->dtrace_is_supported || sdev->dtrace_state == SOF_DTRACE_DISABLED)
 +		return;
 +
 +	ret = snd_sof_dma_trace_trigger(sdev, SNDRV_PCM_TRIGGER_STOP);
 +	if (ret < 0)
 +		dev_err(sdev->dev,
 +			"error: snd_sof_dma_trace_trigger: stop: %d\n", ret);
 +	sdev->dtrace_state = SOF_DTRACE_STOPPED;
 +
 +	/*
 +	 * stop and free trace DMA in the DSP. TRACE_DMA_FREE is only supported from
 +	 * ABI 3.20.0 onwards
 +	 */
 +	if (v->abi_version >= SOF_ABI_VER(3, 20, 0)) {
 +		hdr.size = sizeof(hdr);
 +		hdr.cmd = SOF_IPC_GLB_TRACE_MSG | SOF_IPC_TRACE_DMA_FREE;
 +
 +		ret = sof_ipc_tx_message(sdev->ipc, hdr.cmd, &hdr, hdr.size,
 +					 &ipc_reply, sizeof(ipc_reply));
 +		if (ret < 0)
 +			dev_err(sdev->dev, "DMA_TRACE_FREE failed with error: %d\n", ret);
 +	}
 +
 +	if (only_stop)
 +		goto out;
 +
 +	ret = snd_sof_dma_trace_release(sdev);
 +	if (ret < 0)
 +		dev_err(sdev->dev,
 +			"error: fail in snd_sof_dma_trace_release %d\n", ret);
 +
 +	sdev->dtrace_state = SOF_DTRACE_DISABLED;
 +
 +out:
 +	sdev->dtrace_draining = true;
 +	wake_up(&sdev->trace_sleep);
 +}
 +
 +void snd_sof_trace_suspend(struct snd_sof_dev *sdev, pm_message_t pm_state)
 +{
 +	snd_sof_release_trace(sdev, pm_state.event == SOF_DSP_PM_D0);
 +}
 +EXPORT_SYMBOL(snd_sof_trace_suspend);
 +
 +int snd_sof_trace_resume(struct snd_sof_dev *sdev)
 +{
 +	return snd_sof_enable_trace(sdev);
 +}
 +EXPORT_SYMBOL(snd_sof_trace_resume);
 +
 +void snd_sof_free_trace(struct snd_sof_dev *sdev)
 +{
 +	if (!sdev->dtrace_is_supported)
 +		return;
 +
 +	/* release trace */
 +	snd_sof_release_trace(sdev, false);
 +
 +	if (sdev->dma_trace_pages) {
 +		snd_dma_free_pages(&sdev->dmatb);
 +		snd_dma_free_pages(&sdev->dmatp);
 +		sdev->dma_trace_pages = 0;
 +	}
 +}
 +EXPORT_SYMBOL(snd_sof_free_trace);
++=======
++>>>>>>> 1dedbe4f223c (ASoC: SOF: Switch to IPC generic firmware tracing)
* Unmerged path sound/soc/sof/ipc3.c
diff --git a/sound/soc/sof/core.c b/sound/soc/sof/core.c
index fa6262450759..a90d31f03c2e 100644
--- a/sound/soc/sof/core.c
+++ b/sound/soc/sof/core.c
@@ -234,12 +234,11 @@ static int sof_probe_continue(struct snd_sof_dev *sdev)
 	if (sof_debug_check_flag(SOF_DBG_ENABLE_TRACE)) {
 		sdev->dtrace_is_supported = true;
 
-		/* init DMA trace */
-		ret = snd_sof_init_trace(sdev);
+		/* init firmware tracing */
+		ret = sof_fw_trace_init(sdev);
 		if (ret < 0) {
 			/* non fatal */
-			dev_warn(sdev->dev,
-				 "warning: failed to initialize trace %d\n",
+			dev_warn(sdev->dev, "failed to initialize firmware tracing %d\n",
 				 ret);
 		}
 	} else {
@@ -282,7 +281,7 @@ static int sof_probe_continue(struct snd_sof_dev *sdev)
 	return 0;
 
 fw_trace_err:
-	snd_sof_free_trace(sdev);
+	sof_fw_trace_free(sdev);
 fw_run_err:
 	snd_sof_fw_unload(sdev);
 fw_load_err:
@@ -412,7 +411,7 @@ int snd_sof_device_remove(struct device *dev)
 	snd_sof_machine_unregister(sdev, pdata);
 
 	if (sdev->fw_state > SOF_FW_BOOT_NOT_STARTED) {
-		snd_sof_free_trace(sdev);
+		sof_fw_trace_free(sdev);
 		ret = snd_sof_dsp_power_down_notify(sdev);
 		if (ret < 0)
 			dev_warn(dev, "error: %d failed to prepare DSP for device removal",
diff --git a/sound/soc/sof/debug.c b/sound/soc/sof/debug.c
index c576b602e51e..854391c8a914 100644
--- a/sound/soc/sof/debug.c
+++ b/sound/soc/sof/debug.c
@@ -1019,6 +1019,6 @@ void snd_sof_handle_fw_exception(struct snd_sof_dev *sdev)
 	snd_sof_ipc_dump(sdev);
 	snd_sof_dsp_dbg_dump(sdev, "Firmware exception",
 			     SOF_DBG_DUMP_REGS | SOF_DBG_DUMP_MBOX);
-	snd_sof_trace_notify_for_error(sdev);
+	sof_fw_trace_fw_crashed(sdev);
 }
 EXPORT_SYMBOL(snd_sof_handle_fw_exception);
* Unmerged path sound/soc/sof/ipc.c
* Unmerged path sound/soc/sof/ipc3.c
diff --git a/sound/soc/sof/ops.c b/sound/soc/sof/ops.c
index 235e2ef72178..ff066de4ceb9 100644
--- a/sound/soc/sof/ops.c
+++ b/sound/soc/sof/ops.c
@@ -177,7 +177,7 @@ void snd_sof_dsp_panic(struct snd_sof_dev *sdev, u32 offset, bool non_recoverabl
 		snd_sof_dsp_dbg_dump(sdev, "DSP panic!",
 				     SOF_DBG_DUMP_REGS | SOF_DBG_DUMP_MBOX);
 		sof_set_fw_state(sdev, SOF_FW_CRASHED);
-		snd_sof_trace_notify_for_error(sdev);
+		sof_fw_trace_fw_crashed(sdev);
 	} else {
 		snd_sof_dsp_dbg_dump(sdev,
 				     "DSP panic (recovery will be attempted)",
* Unmerged path sound/soc/sof/pm.c
diff --git a/sound/soc/sof/sof-priv.h b/sound/soc/sof/sof-priv.h
index 0972440dcebe..1994cc9892cf 100644
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@ -583,27 +583,26 @@ static inline void snd_sof_ipc_process_reply(struct snd_sof_dev *sdev, u32 msg_i
 /*
  * Trace/debug
  */
-int snd_sof_init_trace(struct snd_sof_dev *sdev);
-void snd_sof_free_trace(struct snd_sof_dev *sdev);
 int snd_sof_dbg_init(struct snd_sof_dev *sdev);
 void snd_sof_free_debug(struct snd_sof_dev *sdev);
 int snd_sof_debugfs_buf_item(struct snd_sof_dev *sdev,
 			     void *base, size_t size,
 			     const char *name, mode_t mode);
-int snd_sof_trace_update_pos(struct snd_sof_dev *sdev,
-			     struct sof_ipc_dma_trace_posn *posn);
-void snd_sof_trace_notify_for_error(struct snd_sof_dev *sdev);
 void sof_print_oops_and_stack(struct snd_sof_dev *sdev, const char *level,
 			      u32 panic_code, u32 tracep_code, void *oops,
 			      struct sof_ipc_panic_info *panic_info,
 			      void *stack, size_t stack_words);
-void snd_sof_trace_suspend(struct snd_sof_dev *sdev, pm_message_t pm_state);
-int snd_sof_trace_resume(struct snd_sof_dev *sdev);
 void snd_sof_handle_fw_exception(struct snd_sof_dev *sdev);
 int snd_sof_dbg_memory_info_init(struct snd_sof_dev *sdev);
 int snd_sof_debugfs_add_region_item_iomem(struct snd_sof_dev *sdev,
 		enum snd_sof_fw_blk_type blk_type, u32 offset, size_t size,
 		const char *name, enum sof_debugfs_access_type access_type);
+/* Firmware tracing */
+int sof_fw_trace_init(struct snd_sof_dev *sdev);
+void sof_fw_trace_free(struct snd_sof_dev *sdev);
+void sof_fw_trace_fw_crashed(struct snd_sof_dev *sdev);
+void sof_fw_trace_suspend(struct snd_sof_dev *sdev, pm_message_t pm_state);
+int sof_fw_trace_resume(struct snd_sof_dev *sdev);
 
 /*
  * DSP Architectures.
* Unmerged path sound/soc/sof/trace.c
