md/raid5: Move stripe_request_ctx up

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Logan Gunthorpe <logang@deltatee.com>
commit df6b0e205d1fe3fe1f2e9aaee9fc396b64e1c293
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/df6b0e20.failed

Move stripe_request_ctx up. No functional changes intended.

This will be necessary in the next patch to release the batch_last
in the context before sleeping.

	Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
	Signed-off-by: Song Liu <song@kernel.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit df6b0e205d1fe3fe1f2e9aaee9fc396b64e1c293)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 402cdd6bb213,44df461362b2..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -763,6 -755,51 +763,54 @@@ static bool has_failed(struct r5conf *c
  	return degraded > conf->max_degraded;
  }
  
++<<<<<<< HEAD
++=======
+ enum stripe_result {
+ 	STRIPE_SUCCESS = 0,
+ 	STRIPE_RETRY,
+ 	STRIPE_SCHEDULE_AND_RETRY,
+ 	STRIPE_FAIL,
+ };
+ 
+ struct stripe_request_ctx {
+ 	/* a reference to the last stripe_head for batching */
+ 	struct stripe_head *batch_last;
+ 
+ 	/* first sector in the request */
+ 	sector_t first_sector;
+ 
+ 	/* last sector in the request */
+ 	sector_t last_sector;
+ 
+ 	/*
+ 	 * bitmap to track stripe sectors that have been added to stripes
+ 	 * add one to account for unaligned requests
+ 	 */
+ 	DECLARE_BITMAP(sectors_to_do, RAID5_MAX_REQ_STRIPES + 1);
+ 
+ 	/* the request had REQ_PREFLUSH, cleared after the first stripe_head */
+ 	bool do_flush;
+ };
+ 
+ /*
+  * Block until another thread clears R5_INACTIVE_BLOCKED or
+  * there are fewer than 3/4 the maximum number of active stripes
+  * and there is an inactive stripe available.
+  */
+ static bool is_inactive_blocked(struct r5conf *conf, int hash)
+ {
+ 	int active = atomic_read(&conf->active_stripes);
+ 
+ 	if (list_empty(conf->inactive_list + hash))
+ 		return false;
+ 
+ 	if (!test_bit(R5_INACTIVE_BLOCKED, &conf->cache_state))
+ 		return true;
+ 
+ 	return active < (conf->max_nr_stripes * 3 / 4);
+ }
+ 
++>>>>>>> df6b0e205d1f (md/raid5: Move stripe_request_ctx up)
  struct stripe_head *
  raid5_get_active_stripe(struct r5conf *conf, sector_t sector,
  			int previous, int noblock, int noquiesce)
* Unmerged path drivers/md/raid5.c
