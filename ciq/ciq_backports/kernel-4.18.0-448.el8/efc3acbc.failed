fbcon: Maintain a private array of fb_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Daniel Vetter <daniel.vetter@ffwll.ch>
commit efc3acbc105af79bce2ccf97a6159255b7cf6b38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/efc3acbc.failed

Accessing the one in fbmem.c without taking the right locks is a bad
idea. Instead maintain our own private copy, which is fully protected
by console_lock() (like everything else in fbcon.c). That copy is
serialized through fbcon_fb_registered/unregistered() calls.

Also this means we do not need to hold a full fb_info reference, which
is nice because doing so would mean a refcount loop between the
console and the fb_info. But it's also not nice since it means
console_lock() must be held absolutely everywhere. Well strictly
speaking we could still try to do some refcounting games again by
calling get_fb_info before we drop the console_lock. But things will
get tricky.

	Acked-by: Sam Ravnborg <sam@ravnborg.org>
	Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Claudio Suarez <cssk@net-c.es>
	Cc: Du Cheng <ducheng2@gmail.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20220405210335.3434130-18-daniel.vetter@ffwll.ch
(cherry picked from commit efc3acbc105af79bce2ccf97a6159255b7cf6b38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/video/fbdev/core/fbcon.c
diff --cc drivers/video/fbdev/core/fbcon.c
index 1a25ce50a9fd,6a7d470beec7..000000000000
--- a/drivers/video/fbdev/core/fbcon.c
+++ b/drivers/video/fbdev/core/fbcon.c
@@@ -117,6 -113,13 +120,16 @@@ int fbcon_num_registered_fb
  static signed char con2fb_map[MAX_NR_CONSOLES];
  static signed char con2fb_map_boot[MAX_NR_CONSOLES];
  
++<<<<<<< HEAD
++=======
+ static struct fb_info *fbcon_info_from_console(int console)
+ {
+ 	WARN_CONSOLE_UNLOCKED();
+ 
+ 	return fbcon_registered_fb[con2fb_map[console]];
+ }
+ 
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  static int logo_lines;
  /* logo_shown is an index to vc_cons when >= 0; otherwise follows FBCON_LOGO
     enums.  */
@@@ -841,9 -819,9 +854,9 @@@ static int set_con2fb_map(int unit, in
  {
  	struct vc_data *vc = vc_cons[unit].d;
  	int oldidx = con2fb_map[unit];
- 	struct fb_info *info = registered_fb[newidx];
+ 	struct fb_info *info = fbcon_registered_fb[newidx];
  	struct fb_info *oldinfo = NULL;
 -	int found, err = 0, show_logo;
 +	int found, err = 0;
  
  	WARN_CONSOLE_UNLOCKED();
  
@@@ -957,9 -933,9 +970,9 @@@ static const char *fbcon_startup(void
  		return display_desc;
  	/*
  	 * Instead of blindly using registered_fb[0], we use info_idx, set by
 -	 * fbcon_fb_registered();
 +	 * fb_console_init();
  	 */
- 	info = registered_fb[info_idx];
+ 	info = fbcon_registered_fb[info_idx];
  	if (!info)
  		return NULL;
  	
@@@ -1211,6 -1143,27 +1224,30 @@@ static void fbcon_free_font(struct fbco
  
  static void set_vc_hi_font(struct vc_data *vc, bool set);
  
++<<<<<<< HEAD
++=======
+ static void fbcon_release_all(void)
+ {
+ 	struct fb_info *info;
+ 	int i, j, mapped;
+ 
+ 	fbcon_for_each_registered_fb(i) {
+ 		mapped = 0;
+ 		info = fbcon_registered_fb[i];
+ 
+ 		for (j = first_fb_vc; j <= last_fb_vc; j++) {
+ 			if (con2fb_map[j] == i) {
+ 				mapped = 1;
+ 				con2fb_map[j] = -1;
+ 			}
+ 		}
+ 
+ 		if (mapped)
+ 			fbcon_release(info);
+ 	}
+ }
+ 
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  static void fbcon_deinit(struct vc_data *vc)
  {
  	struct fbcon_display *p = &fb_display[vc->vc_num];
@@@ -2267,9 -2096,9 +2304,15 @@@ static int fbcon_switch(struct vc_data 
  	 *
  	 * info->currcon = vc->vc_num;
  	 */
++<<<<<<< HEAD
 +	for (i = 0; i < FB_MAX; i++) {
 +		if (registered_fb[i] != NULL && registered_fb[i]->fbcon_par) {
 +			struct fbcon_ops *o = registered_fb[i]->fbcon_par;
++=======
+ 	fbcon_for_each_registered_fb(i) {
+ 		if (fbcon_registered_fb[i]->fbcon_par) {
+ 			struct fbcon_ops *o = fbcon_registered_fb[i]->fbcon_par;
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  
  			o->currcon = vc->vc_num;
  		}
@@@ -3159,10 -2827,15 +3202,18 @@@ void fbcon_fb_unregistered(struct fb_in
  {
  	int i, idx;
  
 -	console_lock();
 +	WARN_CONSOLE_UNLOCKED();
  
++<<<<<<< HEAD
 +	if (deferred_takeover)
++=======
+ 	fbcon_registered_fb[info->node] = NULL;
+ 	fbcon_num_registered_fb--;
+ 
+ 	if (deferred_takeover) {
+ 		console_unlock();
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  		return;
 -	}
  
  	idx = info->node;
  	for (i = first_fb_vc; i <= last_fb_vc; i++) {
@@@ -3173,11 -2846,9 +3224,17 @@@
  	if (idx == info_idx) {
  		info_idx = -1;
  
++<<<<<<< HEAD
 +		for (i = 0; i < FB_MAX; i++) {
 +			if (registered_fb[i] != NULL) {
 +				info_idx = i;
 +				break;
 +			}
++=======
+ 		fbcon_for_each_registered_fb(i) {
+ 			info_idx = i;
+ 			break;
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  		}
  	}
  
@@@ -3191,8 -2862,9 +3248,8 @@@
  	if (primary_device == idx)
  		primary_device = -1;
  
- 	if (!num_registered_fb)
+ 	if (!fbcon_num_registered_fb)
  		do_unregister_con_driver(&fb_con);
 -	console_unlock();
  }
  
  void fbcon_remap_all(struct fb_info *info)
@@@ -3255,8 -2932,14 +3312,11 @@@ int fbcon_fb_registered(struct fb_info 
  {
  	int ret = 0, i, idx;
  
 -	if (!lockless_register_fb)
 -		console_lock();
 -	else
 -		atomic_inc(&ignore_console_lock_warning);
 +	WARN_CONSOLE_UNLOCKED();
  
+ 	fbcon_registered_fb[info->node] = info;
+ 	fbcon_num_registered_fb++;
+ 
  	idx = info->node;
  	fbcon_select_primary(info);
  
@@@ -3364,58 -3048,28 +3424,71 @@@ static void fbcon_get_requirement(struc
  	}
  }
  
 -int fbcon_set_con2fb_map_ioctl(void __user *argp)
 +static int fbcon_event_notify(struct notifier_block *self,
 +			      unsigned long action, void *data)
  {
 -	struct fb_con2fbmap con2fb;
 -	int ret;
 +	struct fb_event *event = data;
 +	struct fb_info *info = event->info;
 +	struct fb_videomode *mode;
 +	struct fb_con2fbmap *con2fb;
 +	struct fb_blit_caps *caps;
 +	int idx, ret = 0;
  
++<<<<<<< HEAD
 +	switch(action) {
 +	case FB_EVENT_SUSPEND:
 +		fbcon_suspended(info);
 +		break;
 +	case FB_EVENT_RESUME:
 +		fbcon_resumed(info);
 +		break;
 +	case FB_EVENT_MODE_CHANGE:
 +		fbcon_modechanged(info);
 +		break;
 +	case FB_EVENT_MODE_CHANGE_ALL:
 +		fbcon_set_all_vcs(info);
 +		break;
 +	case FB_EVENT_MODE_DELETE:
 +		mode = event->data;
 +		ret = fbcon_mode_deleted(info, mode);
 +		break;
 +	case FB_EVENT_FB_UNBIND:
 +		idx = info->node;
 +		ret = fbcon_fb_unbind(idx);
 +		break;
 +	case FB_EVENT_SET_CONSOLE_MAP:
 +		/* called with console lock held */
 +		con2fb = event->data;
 +		ret = set_con2fb_map(con2fb->console - 1,
 +				     con2fb->framebuffer, 1);
 +		break;
 +	case FB_EVENT_GET_CONSOLE_MAP:
 +		con2fb = event->data;
 +		con2fb->framebuffer = con2fb_map[con2fb->console - 1];
 +		break;
 +	case FB_EVENT_BLANK:
 +		fbcon_fb_blanked(info, *(int *)event->data);
 +		break;
 +	case FB_EVENT_NEW_MODELIST:
 +		fbcon_new_modelist(info);
 +		break;
 +	case FB_EVENT_GET_REQ:
 +		caps = event->data;
 +		fbcon_get_requirement(info, caps);
 +		break;
++=======
+ 	if (copy_from_user(&con2fb, argp, sizeof(con2fb)))
+ 		return -EFAULT;
+ 	if (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)
+ 		return -EINVAL;
+ 	if (con2fb.framebuffer >= FB_MAX)
+ 		return -EINVAL;
+ 	if (!fbcon_registered_fb[con2fb.framebuffer])
+ 		request_module("fb%d", con2fb.framebuffer);
+ 	if (!fbcon_registered_fb[con2fb.framebuffer]) {
+ 		return -EINVAL;
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  	}
 -
 -	console_lock();
 -	ret = set_con2fb_map(con2fb.console - 1,
 -			     con2fb.framebuffer, 1);
 -	console_unlock();
 -
  	return ret;
  }
  
@@@ -3613,10 -3276,11 +3686,18 @@@ static void fbcon_register_existing_fbs
  
  	console_lock();
  
++<<<<<<< HEAD
 +	for (i = 0; i < FB_MAX; i++) {
 +		if (registered_fb[i])
 +			fbcon_fb_registered(registered_fb[i]);
 +	}
++=======
+ 	deferred_takeover = false;
+ 	logo_shown = FBCON_LOGO_DONTSHOW;
+ 
+ 	fbcon_for_each_registered_fb(i)
+ 		fbcon_fb_registered(fbcon_registered_fb[i]);
++>>>>>>> efc3acbc105a (fbcon: Maintain a private array of fb_info)
  
  	console_unlock();
  }
* Unmerged path drivers/video/fbdev/core/fbcon.c
