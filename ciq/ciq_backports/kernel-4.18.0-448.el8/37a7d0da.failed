wifi: mac80211: sort trace.h file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 37a7d0dae3111c431b81959ca13cf5effdf9e929
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/37a7d0da.failed

This used to be sorted by driver methods, APIs and internal
functions, but got added to in the wrong sections. Fix that
by ordering the file properly again.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 37a7d0dae3111c431b81959ca13cf5effdf9e929)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/trace.h
diff --cc net/mac80211/trace.h
index 17e7760d8348,295db57a76a2..000000000000
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@@ -2443,455 -2945,6 +2899,458 @@@ TRACE_EVENT(stop_queue
  	)
  );
  
++<<<<<<< HEAD
 +TRACE_EVENT(drv_set_default_unicast_key,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 int key_idx),
 +
 +	TP_ARGS(local, sdata, key_idx),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		__field(int, key_idx)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		__entry->key_idx = key_idx;
 +	),
 +
 +	TP_printk(LOCAL_PR_FMT VIF_PR_FMT " key_idx:%d",
 +		  LOCAL_PR_ARG, VIF_PR_ARG, __entry->key_idx)
 +);
 +
 +TRACE_EVENT(api_radar_detected,
 +	TP_PROTO(struct ieee80211_local *local),
 +
 +	TP_ARGS(local),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT " radar detected",
 +		LOCAL_PR_ARG
 +	)
 +);
 +
 +TRACE_EVENT(drv_channel_switch_beacon,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct cfg80211_chan_def *chandef),
 +
 +	TP_ARGS(local, sdata, chandef),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		CHANDEF_ENTRY
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		CHANDEF_ASSIGN(chandef);
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT " channel switch to " CHANDEF_PR_FMT,
 +		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG
 +	)
 +);
 +
 +TRACE_EVENT(drv_pre_channel_switch,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_channel_switch *ch_switch),
 +
 +	TP_ARGS(local, sdata, ch_switch),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		CHANDEF_ENTRY
 +		__field(u64, timestamp)
 +		__field(u32, device_timestamp)
 +		__field(bool, block_tx)
 +		__field(u8, count)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		CHANDEF_ASSIGN(&ch_switch->chandef)
 +		__entry->timestamp = ch_switch->timestamp;
 +		__entry->device_timestamp = ch_switch->device_timestamp;
 +		__entry->block_tx = ch_switch->block_tx;
 +		__entry->count = ch_switch->count;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT " prepare channel switch to "
 +		CHANDEF_PR_FMT  " count:%d block_tx:%d timestamp:%llu",
 +		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->count,
 +		__entry->block_tx, __entry->timestamp
 +	)
 +);
 +
 +DEFINE_EVENT(local_sdata_evt, drv_post_channel_switch,
 +	     TP_PROTO(struct ieee80211_local *local,
 +		      struct ieee80211_sub_if_data *sdata),
 +	     TP_ARGS(local, sdata)
 +);
 +
 +DEFINE_EVENT(local_sdata_evt, drv_abort_channel_switch,
 +	     TP_PROTO(struct ieee80211_local *local,
 +		      struct ieee80211_sub_if_data *sdata),
 +	     TP_ARGS(local, sdata)
 +);
 +
 +TRACE_EVENT(drv_channel_switch_rx_beacon,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_channel_switch *ch_switch),
 +
 +	TP_ARGS(local, sdata, ch_switch),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		CHANDEF_ENTRY
 +		__field(u64, timestamp)
 +		__field(u32, device_timestamp)
 +		__field(bool, block_tx)
 +		__field(u8, count)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		CHANDEF_ASSIGN(&ch_switch->chandef)
 +		__entry->timestamp = ch_switch->timestamp;
 +		__entry->device_timestamp = ch_switch->device_timestamp;
 +		__entry->block_tx = ch_switch->block_tx;
 +		__entry->count = ch_switch->count;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT
 +		" received a channel switch beacon to "
 +		CHANDEF_PR_FMT  " count:%d block_tx:%d timestamp:%llu",
 +		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->count,
 +		__entry->block_tx, __entry->timestamp
 +	)
 +);
 +
 +TRACE_EVENT(drv_get_txpower,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 int dbm, int ret),
 +
 +	TP_ARGS(local, sdata, dbm, ret),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		__field(int, dbm)
 +		__field(int, ret)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		__entry->dbm = dbm;
 +		__entry->ret = ret;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT " dbm:%d ret:%d",
 +		LOCAL_PR_ARG, VIF_PR_ARG, __entry->dbm, __entry->ret
 +	)
 +);
 +
 +TRACE_EVENT(drv_tdls_channel_switch,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_sta *sta, u8 oper_class,
 +		 struct cfg80211_chan_def *chandef),
 +
 +	TP_ARGS(local, sdata, sta, oper_class, chandef),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		STA_ENTRY
 +		__field(u8, oper_class)
 +		CHANDEF_ENTRY
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		STA_ASSIGN;
 +		__entry->oper_class = oper_class;
 +		CHANDEF_ASSIGN(chandef)
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT " tdls channel switch to"
 +		CHANDEF_PR_FMT  " oper_class:%d " STA_PR_FMT,
 +		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->oper_class,
 +		STA_PR_ARG
 +	)
 +);
 +
 +TRACE_EVENT(drv_tdls_cancel_channel_switch,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_sta *sta),
 +
 +	TP_ARGS(local, sdata, sta),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		STA_ENTRY
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		STA_ASSIGN;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT
 +		" tdls cancel channel switch with " STA_PR_FMT,
 +		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
 +	)
 +);
 +
 +TRACE_EVENT(drv_tdls_recv_channel_switch,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_tdls_ch_sw_params *params),
 +
 +	TP_ARGS(local, sdata, params),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		__field(u8, action_code)
 +		STA_ENTRY
 +		CHANDEF_ENTRY
 +		__field(u32, status)
 +		__field(bool, peer_initiator)
 +		__field(u32, timestamp)
 +		__field(u16, switch_time)
 +		__field(u16, switch_timeout)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		STA_NAMED_ASSIGN(params->sta);
 +		CHANDEF_ASSIGN(params->chandef)
 +		__entry->peer_initiator = params->sta->tdls_initiator;
 +		__entry->action_code = params->action_code;
 +		__entry->status = params->status;
 +		__entry->timestamp = params->timestamp;
 +		__entry->switch_time = params->switch_time;
 +		__entry->switch_timeout = params->switch_timeout;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT " received tdls channel switch packet"
 +		" action:%d status:%d time:%d switch time:%d switch"
 +		" timeout:%d initiator: %d chan:" CHANDEF_PR_FMT STA_PR_FMT,
 +		LOCAL_PR_ARG, VIF_PR_ARG, __entry->action_code, __entry->status,
 +		__entry->timestamp, __entry->switch_time,
 +		__entry->switch_timeout, __entry->peer_initiator,
 +		CHANDEF_PR_ARG, STA_PR_ARG
 +	)
 +);
 +
 +TRACE_EVENT(drv_wake_tx_queue,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct txq_info *txq),
 +
 +	TP_ARGS(local, sdata, txq),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		STA_ENTRY
 +		__field(u8, ac)
 +		__field(u8, tid)
 +	),
 +
 +	TP_fast_assign(
 +		struct ieee80211_sta *sta = txq->txq.sta;
 +
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		STA_ASSIGN;
 +		__entry->ac = txq->txq.ac;
 +		__entry->tid = txq->txq.tid;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " ac:%d tid:%d",
 +		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->ac, __entry->tid
 +	)
 +);
 +
 +TRACE_EVENT(drv_get_ftm_responder_stats,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct cfg80211_ftm_responder_stats *ftm_stats),
 +
 +	TP_ARGS(local, sdata, ftm_stats),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT VIF_PR_FMT,
 +		LOCAL_PR_ARG, VIF_PR_ARG
 +	)
 +);
 +
 +DEFINE_EVENT(local_sdata_addr_evt, drv_update_vif_offload,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata),
 +	TP_ARGS(local, sdata)
 +);
 +
 +DECLARE_EVENT_CLASS(sta_flag_evt,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_sta *sta, bool enabled),
 +
 +	TP_ARGS(local, sdata, sta, enabled),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		VIF_ENTRY
 +		STA_ENTRY
 +		__field(bool, enabled)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		VIF_ASSIGN;
 +		STA_ASSIGN;
 +		__entry->enabled = enabled;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " enabled:%d",
 +		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->enabled
 +	)
 +);
 +
 +DEFINE_EVENT(sta_flag_evt, drv_sta_set_4addr,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_sta *sta, bool enabled),
 +
 +	TP_ARGS(local, sdata, sta, enabled)
 +);
 +
 +DEFINE_EVENT(sta_flag_evt, drv_sta_set_decap_offload,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sub_if_data *sdata,
 +		 struct ieee80211_sta *sta, bool enabled),
 +
 +	TP_ARGS(local, sdata, sta, enabled)
 +);
 +
 +TRACE_EVENT(drv_add_twt_setup,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sta *sta,
 +		 struct ieee80211_twt_setup *twt,
 +		 struct ieee80211_twt_params *twt_agrt),
 +
 +	TP_ARGS(local, sta, twt, twt_agrt),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		STA_ENTRY
 +		__field(u8, dialog_token)
 +		__field(u8, control)
 +		__field(__le16, req_type)
 +		__field(__le64, twt)
 +		__field(u8, duration)
 +		__field(__le16, mantissa)
 +		__field(u8, channel)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		STA_ASSIGN;
 +		__entry->dialog_token = twt->dialog_token;
 +		__entry->control = twt->control;
 +		__entry->req_type = twt_agrt->req_type;
 +		__entry->twt = twt_agrt->twt;
 +		__entry->duration = twt_agrt->min_twt_dur;
 +		__entry->mantissa = twt_agrt->mantissa;
 +		__entry->channel = twt_agrt->channel;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT STA_PR_FMT
 +		" token:%d control:0x%02x req_type:0x%04x"
 +		" twt:%llu duration:%d mantissa:%d channel:%d",
 +		LOCAL_PR_ARG, STA_PR_ARG, __entry->dialog_token,
 +		__entry->control, le16_to_cpu(__entry->req_type),
 +		le64_to_cpu(__entry->twt), __entry->duration,
 +		le16_to_cpu(__entry->mantissa), __entry->channel
 +	)
 +);
 +
 +TRACE_EVENT(drv_twt_teardown_request,
 +	TP_PROTO(struct ieee80211_local *local,
 +		 struct ieee80211_sta *sta, u8 flowid),
 +
 +	TP_ARGS(local, sta, flowid),
 +
 +	TP_STRUCT__entry(
 +		LOCAL_ENTRY
 +		STA_ENTRY
 +		__field(u8, flowid)
 +	),
 +
 +	TP_fast_assign(
 +		LOCAL_ASSIGN;
 +		STA_ASSIGN;
 +		__entry->flowid = flowid;
 +	),
 +
 +	TP_printk(
 +		LOCAL_PR_FMT STA_PR_FMT " flowid:%d",
 +		LOCAL_PR_ARG, STA_PR_ARG, __entry->flowid
 +	)
 +);
 +
++=======
++>>>>>>> 37a7d0dae311 (wifi: mac80211: sort trace.h file)
  #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
  
  #undef TRACE_INCLUDE_PATH
* Unmerged path net/mac80211/trace.h
