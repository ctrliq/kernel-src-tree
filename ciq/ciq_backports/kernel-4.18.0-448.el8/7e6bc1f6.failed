netfilter: nf_tables: stricter validation of element data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7e6bc1f6.failed

Make sure element data type and length do not mismatch the one specified
by the set declaration.

Fixes: 7d7402642eaf ("netfilter: nf_tables: variable sized set element keys / data")
	Reported-by: Hugues ANGUELKOV <hanguelkov@randorisec.fr>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index cbb745cabd11,d6b59beab3a9..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4849,6 -5208,72 +4849,75 @@@ static int nft_setelem_parse_key(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
+ 				  struct nft_data_desc *desc,
+ 				  struct nft_data *data,
+ 				  struct nlattr *attr)
+ {
+ 	u32 dtype;
+ 	int err;
+ 
+ 	err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (set->dtype == NFT_DATA_VERDICT)
+ 		dtype = NFT_DATA_VERDICT;
+ 	else
+ 		dtype = NFT_DATA_VALUE;
+ 
+ 	if (dtype != desc->type ||
+ 	    set->dlen != desc->len) {
+ 		nft_data_release(data, desc->type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void *nft_setelem_catchall_get(const struct net *net,
+ 				      const struct nft_set *set)
+ {
+ 	struct nft_set_elem_catchall *catchall;
+ 	u8 genmask = nft_genmask_cur(net);
+ 	struct nft_set_ext *ext;
+ 	void *priv = NULL;
+ 
+ 	list_for_each_entry_rcu(catchall, &set->catchall_list, list) {
+ 		ext = nft_set_elem_ext(set, catchall->elem);
+ 		if (!nft_set_elem_active(ext, genmask) ||
+ 		    nft_set_elem_expired(ext))
+ 			continue;
+ 
+ 		priv = catchall->elem;
+ 		break;
+ 	}
+ 
+ 	return priv;
+ }
+ 
+ static int nft_setelem_get(struct nft_ctx *ctx, struct nft_set *set,
+ 			   struct nft_set_elem *elem, u32 flags)
+ {
+ 	void *priv;
+ 
+ 	if (!(flags & NFT_SET_ELEM_CATCHALL)) {
+ 		priv = set->ops->get(ctx->net, set, elem, flags);
+ 		if (IS_ERR(priv))
+ 			return PTR_ERR(priv);
+ 	} else {
+ 		priv = nft_setelem_catchall_get(ctx->net, set);
+ 		if (!priv)
+ 			return -ENOENT;
+ 	}
+ 	elem->priv = priv;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 7e6bc1f6cabc (netfilter: nf_tables: stricter validation of element data)
  static int nft_get_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr)
  {
* Unmerged path net/netfilter/nf_tables_api.c
