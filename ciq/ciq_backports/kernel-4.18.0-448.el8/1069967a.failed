ASoC: SOF: sof-client: Add support for clients not managed by pm framework

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit 1069967afe1e6b728061682ff99ec534a55a5613
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1069967a.failed

Some SOF client can be of 'passive' type, meaning that they do not handle
PM framework callbacks by themselves but rely on the auxiliary driver's
suspend and resume callbacks to be notified about the core's suspend or
resume event.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Link: https://lore.kernel.org/r/20220210150525.30756-7-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 1069967afe1e6b728061682ff99ec534a55a5613)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/sof-client.c
#	sound/soc/sof/sof-priv.h
diff --cc sound/soc/sof/sof-priv.h
index d19b259a3cba,39bbba5aeab2..000000000000
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@@ -617,4 -643,56 +617,59 @@@ int sof_stream_pcm_close(struct snd_sof
  			 struct snd_pcm_substream *substream);
  
  int sof_machine_check(struct snd_sof_dev *sdev);
++<<<<<<< HEAD
++=======
+ 
+ /* SOF client support */
+ #if IS_ENABLED(CONFIG_SND_SOC_SOF_CLIENT)
+ int sof_client_dev_register(struct snd_sof_dev *sdev, const char *name, u32 id,
+ 			    const void *data, size_t size);
+ void sof_client_dev_unregister(struct snd_sof_dev *sdev, const char *name, u32 id);
+ int sof_register_clients(struct snd_sof_dev *sdev);
+ void sof_unregister_clients(struct snd_sof_dev *sdev);
+ void sof_client_ipc_rx_dispatcher(struct snd_sof_dev *sdev, void *msg_buf);
+ void sof_client_fw_state_dispatcher(struct snd_sof_dev *sdev);
+ int sof_suspend_clients(struct snd_sof_dev *sdev, pm_message_t state);
+ int sof_resume_clients(struct snd_sof_dev *sdev);
+ #else /* CONFIG_SND_SOC_SOF_CLIENT */
+ static inline int sof_client_dev_register(struct snd_sof_dev *sdev, const char *name,
+ 					  u32 id, const void *data, size_t size)
+ {
+ 	return 0;
+ }
+ 
+ static inline void sof_client_dev_unregister(struct snd_sof_dev *sdev,
+ 					     const char *name, u32 id)
+ {
+ }
+ 
+ static inline int sof_register_clients(struct snd_sof_dev *sdev)
+ {
+ 	return 0;
+ }
+ 
+ static inline  void sof_unregister_clients(struct snd_sof_dev *sdev)
+ {
+ }
+ 
+ static inline void sof_client_ipc_rx_dispatcher(struct snd_sof_dev *sdev, void *msg_buf)
+ {
+ }
+ 
+ static inline void sof_client_fw_state_dispatcher(struct snd_sof_dev *sdev)
+ {
+ }
+ 
+ static inline int sof_suspend_clients(struct snd_sof_dev *sdev, pm_message_t state)
+ {
+ 	return 0;
+ }
+ 
+ static inline int sof_resume_clients(struct snd_sof_dev *sdev)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_SND_SOC_SOF_CLIENT */
+ 
++>>>>>>> 1069967afe1e (ASoC: SOF: sof-client: Add support for clients not managed by pm framework)
  #endif
* Unmerged path sound/soc/sof/sof-client.c
diff --git a/sound/soc/sof/pm.c b/sound/soc/sof/pm.c
index 197a88695fef..7300ecadabd9 100644
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@ -167,6 +167,9 @@ static int sof_resume(struct device *dev, bool runtime_resume)
 		return ret;
 	}
 
+	/* Notify clients not managed by pm framework about core resume */
+	sof_resume_clients(sdev);
+
 	/* notify DSP of system resume */
 	ret = sof_send_pm_ctx_ipc(sdev, SOF_IPC_PM_CTX_RESTORE);
 	if (ret < 0)
@@ -180,6 +183,7 @@ static int sof_resume(struct device *dev, bool runtime_resume)
 static int sof_suspend(struct device *dev, bool runtime_suspend)
 {
 	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
+	pm_message_t pm_state;
 	u32 target_state = 0;
 	int ret;
 
@@ -205,16 +209,23 @@ static int sof_suspend(struct device *dev, bool runtime_suspend)
 	}
 
 	target_state = snd_sof_dsp_power_target(sdev);
+	pm_state.event = target_state;
 
 	/* Skip to platform-specific suspend if DSP is entering D0 */
-	if (target_state == SOF_DSP_PM_D0)
+	if (target_state == SOF_DSP_PM_D0) {
+		/* Notify clients not managed by pm framework about core suspend */
+		sof_suspend_clients(sdev, pm_state);
 		goto suspend;
+	}
 
 	sof_tear_down_pipelines(sdev, false);
 
 	/* release trace */
 	snd_sof_release_trace(sdev);
 
+	/* Notify clients not managed by pm framework about core suspend */
+	sof_suspend_clients(sdev, pm_state);
+
 #if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)
 	/* cache debugfs contents during runtime suspend */
 	if (runtime_suspend)
* Unmerged path sound/soc/sof/sof-client.c
* Unmerged path sound/soc/sof/sof-priv.h
