mm: do page fault accounting in handle_mm_fault

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Xu <peterx@redhat.com>
commit bce617edecada007aee8610fbe2c14d10b8de2f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/bce617ed.failed

Patch series "mm: Page fault accounting cleanups", v5.

This is v5 of the pf accounting cleanup series.  It originates from Gerald
Schaefer's report on an issue a week ago regarding to incorrect page fault
accountings for retried page fault after commit 4064b9827063 ("mm: allow
VM_FAULT_RETRY for multiple times"):

  https://lore.kernel.org/lkml/20200610174811.44b94525@thinkpad/

What this series did:

  - Correct page fault accounting: we do accounting for a page fault
    (no matter whether it's from #PF handling, or gup, or anything else)
    only with the one that completed the fault.  For example, page fault
    retries should not be counted in page fault counters.  Same to the
    perf events.

  - Unify definition of PERF_COUNT_SW_PAGE_FAULTS: currently this perf
    event is used in an adhoc way across different archs.

    Case (1): for many archs it's done at the entry of a page fault
    handler, so that it will also cover e.g.  errornous faults.

    Case (2): for some other archs, it is only accounted when the page
    fault is resolved successfully.

    Case (3): there're still quite some archs that have not enabled
    this perf event.

    Since this series will touch merely all the archs, we unify this
    perf event to always follow case (1), which is the one that makes most
    sense.  And since we moved the accounting into handle_mm_fault, the
    other two MAJ/MIN perf events are well taken care of naturally.

  - Unify definition of "major faults": the definition of "major
    fault" is slightly changed when used in accounting (not
    VM_FAULT_MAJOR).  More information in patch 1.

  - Always account the page fault onto the one that triggered the page
    fault.  This does not matter much for #PF handlings, but mostly for
    gup.  More information on this in patch 25.

Patchset layout:

Patch 1:     Introduced the accounting in handle_mm_fault(), not enabled.
Patch 2-23:  Enable the new accounting for arch #PF handlers one by one.
Patch 24:    Enable the new accounting for the rest outliers (gup, iommu, etc.)
Patch 25:    Cleanup GUP task_struct pointer since it's not needed any more

This patch (of 25):

This is a preparation patch to move page fault accountings into the
general code in handle_mm_fault().  This includes both the per task
flt_maj/flt_min counters, and the major/minor page fault perf events.  To
do this, the pt_regs pointer is passed into handle_mm_fault().

PERF_COUNT_SW_PAGE_FAULTS should still be kept in per-arch page fault
handlers.

So far, all the pt_regs pointer that passed into handle_mm_fault() is
NULL, which means this patch should have no intented functional change.

	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Albert Ou <aou@eecs.berkeley.edu>
	Cc: Alexander Gordeev <agordeev@linux.ibm.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Cain <bcain@codeaurora.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Cc: Greentime Hu <green.hu@gmail.com>
	Cc: Guo Ren <guoren@kernel.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Helge Deller <deller@gmx.de>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
	Cc: James E.J. Bottomley <James.Bottomley@HansenPartnership.com>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Ley Foon Tan <ley.foon.tan@intel.com>
	Cc: "Luck, Tony" <tony.luck@intel.com>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Nick Hu <nickhu@andestech.com>
	Cc: Palmer Dabbelt <palmer@dabbelt.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Paul Walmsley <paul.walmsley@sifive.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Richard Henderson <rth@twiddle.net>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Stafford Horne <shorne@gmail.com>
	Cc: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Vincent Chen <deanbo422@gmail.com>
	Cc: Vineet Gupta <vgupta@synopsys.com>
	Cc: Will Deacon <will@kernel.org>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
Link: http://lkml.kernel.org/r/20200707225021.200906-1-peterx@redhat.com
Link: http://lkml.kernel.org/r/20200707225021.200906-2-peterx@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bce617edecada007aee8610fbe2c14d10b8de2f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/mm/fault.c
#	arch/csky/mm/fault.c
#	drivers/iommu/intel/svm.c
diff --cc arch/arc/mm/fault.c
index db6913094be3,587dea524e6b..000000000000
--- a/arch/arc/mm/fault.c
+++ b/arch/arc/mm/fault.c
@@@ -137,20 -117,44 +137,35 @@@ good_area
  	}
  
  	/*
 -	 * vm_area is good, now check permissions for this memory access
 +	 * If for any reason at all we couldn't handle the fault,
 +	 * make sure we exit gracefully rather than endlessly redo
 +	 * the fault.
  	 */
++<<<<<<< HEAD
 +	fault = handle_mm_fault(vma, address, flags);
++=======
+ 	mask = VM_READ;
+ 	if (write)
+ 		mask = VM_WRITE;
+ 	if (exec)
+ 		mask = VM_EXEC;
+ 
+ 	if (!(vma->vm_flags & mask)) {
+ 		si_code = SEGV_ACCERR;
+ 		goto bad_area;
+ 	}
+ 
+ 	fault = handle_mm_fault(vma, address, flags, NULL);
++>>>>>>> bce617edecad (mm: do page fault accounting in handle_mm_fault)
  
 -	/* Quick path to respond to signals */
 -	if (fault_signal_pending(fault, regs)) {
 -		if (!user_mode(regs))
 -			goto no_context;
 -		return;
 -	}
 -
 -	/*
 -	 * Fault retry nuances, mmap_lock already relinquished by core mm
 -	 */
 -	if (unlikely((fault & VM_FAULT_RETRY) &&
 -		     (flags & FAULT_FLAG_ALLOW_RETRY))) {
 -		flags |= FAULT_FLAG_TRIED;
 -		goto retry;
 +	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */
 +	if (unlikely(fatal_signal_pending(current))) {
 +		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))
 +			up_read(&mm->mmap_sem);
 +		if (user_mode(regs))
 +			return;
  	}
  
 -bad_area:
 -	mmap_read_unlock(mm);
 -
 -	/*
 -	 * Major/minor page fault accounting
 -	 * (in case of retry we only land here once)
 -	 */
  	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
  
  	if (likely(!(fault & VM_FAULT_ERROR))) {
diff --cc drivers/iommu/intel/svm.c
index aef3cf79477f,5ae59a6ad681..000000000000
--- a/drivers/iommu/intel/svm.c
+++ b/drivers/iommu/intel/svm.c
@@@ -942,72 -812,125 +942,148 @@@ static irqreturn_t prq_event_thread(in
  
  	tail = dmar_readq(iommu->reg + DMAR_PQT_REG) & PRQ_RING_MASK;
  	head = dmar_readq(iommu->reg + DMAR_PQH_REG) & PRQ_RING_MASK;
 +	handled = (head != tail);
  	while (head != tail) {
 -		struct intel_svm_dev *sdev;
 -		struct vm_area_struct *vma;
 -		struct page_req_dsc *req;
 -		struct qi_desc resp;
 -		int result;
 -		vm_fault_t ret;
 -		u64 address;
 +		req = &iommu->prq[head / sizeof(*req)];
 +		address = (u64)req->addr << VTD_PAGE_SHIFT;
  
 -		handled = 1;
 +		if (unlikely(!req->pasid_present)) {
 +			pr_err("IOMMU: %s: Page request without PASID\n",
 +			       iommu->name);
 +bad_req:
 +			svm = NULL;
 +			sdev = NULL;
 +			handle_bad_prq_event(iommu, req, QI_RESP_INVALID);
 +			goto prq_advance;
 +		}
  
 -		req = &iommu->prq[head / sizeof(*req)];
 +		if (unlikely(!is_canonical_address(address))) {
 +			pr_err("IOMMU: %s: Address is not canonical\n",
 +			       iommu->name);
 +			goto bad_req;
 +		}
  
 -		result = QI_RESP_FAILURE;
 -		address = (u64)req->addr << VTD_PAGE_SHIFT;
 -		if (!req->pasid_present) {
 -			pr_err("%s: Page request without PASID: %08llx %08llx\n",
 -			       iommu->name, ((unsigned long long *)req)[0],
 -			       ((unsigned long long *)req)[1]);
 -			goto no_pasid;
 +		if (unlikely(req->pm_req && (req->rd_req | req->wr_req))) {
 +			pr_err("IOMMU: %s: Page request in Privilege Mode\n",
 +			       iommu->name);
 +			goto bad_req;
 +		}
 +
 +		if (unlikely(req->exe_req && req->rd_req)) {
 +			pr_err("IOMMU: %s: Execution request not supported\n",
 +			       iommu->name);
 +			goto bad_req;
  		}
  
 +		/* Drop Stop Marker message. No need for a response. */
 +		if (unlikely(req->lpig && !req->rd_req && !req->wr_req))
 +			goto prq_advance;
 +
  		if (!svm || svm->pasid != req->pasid) {
++<<<<<<< HEAD
++=======
+ 			rcu_read_lock();
+ 			svm = ioasid_find(NULL, req->pasid, NULL);
+ 			/* It *can't* go away, because the driver is not permitted
+ 			 * to unbind the mm while any page faults are outstanding.
+ 			 * So we only need RCU to protect the internal idr code. */
+ 			rcu_read_unlock();
+ 			if (IS_ERR_OR_NULL(svm)) {
+ 				pr_err("%s: Page request for invalid PASID %d: %08llx %08llx\n",
+ 				       iommu->name, req->pasid, ((unsigned long long *)req)[0],
+ 				       ((unsigned long long *)req)[1]);
+ 				goto no_pasid;
+ 			}
+ 		}
+ 
+ 		result = QI_RESP_INVALID;
+ 		/* Since we're using init_mm.pgd directly, we should never take
+ 		 * any faults on kernel addresses. */
+ 		if (!svm->mm)
+ 			goto bad_req;
+ 
+ 		/* If address is not canonical, return invalid response */
+ 		if (!is_canonical_address(address))
+ 			goto bad_req;
+ 
+ 		/* If the mm is already defunct, don't handle faults. */
+ 		if (!mmget_not_zero(svm->mm))
+ 			goto bad_req;
+ 
+ 		mmap_read_lock(svm->mm);
+ 		vma = find_extend_vma(svm->mm, address);
+ 		if (!vma || address < vma->vm_start)
+ 			goto invalid;
+ 
+ 		if (access_error(vma, req))
+ 			goto invalid;
+ 
+ 		ret = handle_mm_fault(vma, address,
+ 				      req->wr_req ? FAULT_FLAG_WRITE : 0,
+ 				      NULL);
+ 		if (ret & VM_FAULT_ERROR)
+ 			goto invalid;
+ 
+ 		result = QI_RESP_SUCCESS;
+ 	invalid:
+ 		mmap_read_unlock(svm->mm);
+ 		mmput(svm->mm);
+ 	bad_req:
+ 		/* Accounting for major/minor faults? */
+ 		rcu_read_lock();
+ 		list_for_each_entry_rcu(sdev, &svm->devs, list) {
+ 			if (sdev->sid == req->rid)
+ 				break;
+ 		}
+ 		/* Other devices can go away, but the drivers are not permitted
+ 		 * to unbind while any page faults might be in flight. So it's
+ 		 * OK to drop the 'lock' here now we have it. */
+ 		rcu_read_unlock();
+ 
+ 		if (WARN_ON(&sdev->list == &svm->devs))
+ 			sdev = NULL;
+ 
+ 		if (sdev && sdev->ops && sdev->ops->fault_cb) {
+ 			int rwxp = (req->rd_req << 3) | (req->wr_req << 2) |
+ 				(req->exe_req << 1) | (req->pm_req);
+ 			sdev->ops->fault_cb(sdev->dev, req->pasid, req->addr,
+ 					    req->priv_data, rwxp, result);
+ 		}
+ 		/* We get here in the error case where the PASID lookup failed,
+ 		   and these can be NULL. Do not use them below this point! */
+ 		sdev = NULL;
+ 		svm = NULL;
+ 	no_pasid:
+ 		if (req->lpig || req->priv_data_present) {
++>>>>>>> bce617edecad (mm: do page fault accounting in handle_mm_fault)
  			/*
 -			 * Per VT-d spec. v3.0 ch7.7, system software must
 -			 * respond with page group response if private data
 -			 * is present (PDP) or last page in group (LPIG) bit
 -			 * is set. This is an additional VT-d feature beyond
 -			 * PCI ATS spec.
 +			 * It can't go away, because the driver is not permitted
 +			 * to unbind the mm while any page faults are outstanding.
  			 */
 -			resp.qw0 = QI_PGRP_PASID(req->pasid) |
 -				QI_PGRP_DID(req->rid) |
 -				QI_PGRP_PASID_P(req->pasid_present) |
 -				QI_PGRP_PDP(req->pasid_present) |
 -				QI_PGRP_RESP_CODE(result) |
 -				QI_PGRP_RESP_TYPE;
 -			resp.qw1 = QI_PGRP_IDX(req->prg_index) |
 -				QI_PGRP_LPIG(req->lpig);
 -
 -			if (req->priv_data_present)
 -				memcpy(&resp.qw2, req->priv_data,
 -				       sizeof(req->priv_data));
 -			resp.qw2 = 0;
 -			resp.qw3 = 0;
 -			qi_submit_sync(iommu, &resp, 1, 0);
 +			svm = pasid_private_find(req->pasid);
 +			if (IS_ERR_OR_NULL(svm) || (svm->flags & SVM_FLAG_SUPERVISOR_MODE))
 +				goto bad_req;
 +		}
 +
 +		if (!sdev || sdev->sid != req->rid) {
 +			sdev = svm_lookup_device_by_sid(svm, req->rid);
 +			if (!sdev)
 +				goto bad_req;
  		}
 +
 +		sdev->prq_seq_number++;
 +
 +		/*
 +		 * If prq is to be handled outside iommu driver via receiver of
 +		 * the fault notifiers, we skip the page response here.
 +		 */
 +		if (intel_svm_prq_report(iommu, sdev->dev, req))
 +			handle_bad_prq_event(iommu, req, QI_RESP_INVALID);
 +
 +		trace_prq_report(iommu, sdev->dev, req->qw_0, req->qw_1,
 +				 req->priv_data[0], req->priv_data[1],
 +				 sdev->prq_seq_number);
 +prq_advance:
  		head = (head + sizeof(*req)) & PRQ_RING_MASK;
  	}
  
* Unmerged path arch/csky/mm/fault.c
diff --git a/arch/alpha/mm/fault.c b/arch/alpha/mm/fault.c
index d73dc473fbb9..4d4dfddeeeb9 100644
--- a/arch/alpha/mm/fault.c
+++ b/arch/alpha/mm/fault.c
@@ -148,7 +148,7 @@ do_page_fault(unsigned long address, unsigned long mmcsr,
 	/* If for any reason at all we couldn't handle the fault,
 	   make sure we exit gracefully rather than endlessly redo
 	   the fault.  */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
* Unmerged path arch/arc/mm/fault.c
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index f4ea4c62c613..b7c2f3c8a9fb 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -240,7 +240,7 @@ __do_page_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,
 		goto out;
 	}
 
-	return handle_mm_fault(vma, addr & PAGE_MASK, flags);
+	return handle_mm_fault(vma, addr & PAGE_MASK, flags, NULL);
 
 check_stack:
 	/* Don't allow expansion below FIRST_USER_ADDRESS */
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index 4b9c60b9ef8f..38e1c3140d5a 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -455,7 +455,7 @@ static vm_fault_t __do_page_fault(struct mm_struct *mm, unsigned long addr,
 	 */
 	if (!(vma->vm_flags & vm_flags))
 		return VM_FAULT_BADACCESS;
-	return handle_mm_fault(vma, addr & PAGE_MASK, mm_flags);
+	return handle_mm_fault(vma, addr & PAGE_MASK, mm_flags, NULL);
 }
 
 static bool is_el0_instruction_abort(unsigned int esr)
* Unmerged path arch/csky/mm/fault.c
diff --git a/arch/hexagon/mm/vm_fault.c b/arch/hexagon/mm/vm_fault.c
index eb263e61daf4..b4e00036b75c 100644
--- a/arch/hexagon/mm/vm_fault.c
+++ b/arch/hexagon/mm/vm_fault.c
@@ -102,7 +102,7 @@ void do_page_fault(unsigned long address, long cause, struct pt_regs *regs)
 		break;
 	}
 
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/ia64/mm/fault.c b/arch/ia64/mm/fault.c
index a9d55ad8d67b..f3fe25cadbb9 100644
--- a/arch/ia64/mm/fault.c
+++ b/arch/ia64/mm/fault.c
@@ -161,7 +161,7 @@ ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *re
 	 * sure we exit gracefully rather than endlessly redo the
 	 * fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/m68k/mm/fault.c b/arch/m68k/mm/fault.c
index 9b6163c05a75..4252f68a97df 100644
--- a/arch/m68k/mm/fault.c
+++ b/arch/m68k/mm/fault.c
@@ -135,7 +135,7 @@ int do_page_fault(struct pt_regs *regs, unsigned long address,
 	 * the fault.
 	 */
 
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 	pr_debug("handle_mm_fault returns %x\n", fault);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
diff --git a/arch/microblaze/mm/fault.c b/arch/microblaze/mm/fault.c
index 202ad6a494f5..6523dd928a94 100644
--- a/arch/microblaze/mm/fault.c
+++ b/arch/microblaze/mm/fault.c
@@ -215,7 +215,7 @@ void do_page_fault(struct pt_regs *regs, unsigned long address,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index c6c649690877..545f682610e2 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -152,7 +152,7 @@ static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/nds32/mm/fault.c b/arch/nds32/mm/fault.c
index b740534b152c..9bd35d6c934f 100644
--- a/arch/nds32/mm/fault.c
+++ b/arch/nds32/mm/fault.c
@@ -204,7 +204,7 @@ void do_page_fault(unsigned long entry, unsigned long addr,
 	 * the fault.
 	 */
 
-	fault = handle_mm_fault(vma, addr, flags);
+	fault = handle_mm_fault(vma, addr, flags, NULL);
 
 	/*
 	 * If we need to retry but a fatal signal is pending, handle the
diff --git a/arch/nios2/mm/fault.c b/arch/nios2/mm/fault.c
index 24fd84cf6006..c7be92a8ae64 100644
--- a/arch/nios2/mm/fault.c
+++ b/arch/nios2/mm/fault.c
@@ -132,7 +132,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long cause,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/openrisc/mm/fault.c b/arch/openrisc/mm/fault.c
index dc4dbafc1d83..1f8d68d1557d 100644
--- a/arch/openrisc/mm/fault.c
+++ b/arch/openrisc/mm/fault.c
@@ -163,7 +163,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long address,
 	 * the fault.
 	 */
 
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/parisc/mm/fault.c b/arch/parisc/mm/fault.c
index c8e8b7c05558..23f3a0466ecc 100644
--- a/arch/parisc/mm/fault.c
+++ b/arch/parisc/mm/fault.c
@@ -301,7 +301,7 @@ void do_page_fault(struct pt_regs *regs, unsigned long code,
 	 * fault.
 	 */
 
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/arch/powerpc/mm/copro_fault.c b/arch/powerpc/mm/copro_fault.c
index 87edde9d31ab..86ec0bf9cc3e 100644
--- a/arch/powerpc/mm/copro_fault.c
+++ b/arch/powerpc/mm/copro_fault.c
@@ -77,7 +77,7 @@ int copro_handle_mm_fault(struct mm_struct *mm, unsigned long ea,
 	}
 
 	ret = 0;
-	*flt = handle_mm_fault(vma, ea, is_write ? FAULT_FLAG_WRITE : 0);
+	*flt = handle_mm_fault(vma, ea, is_write ? FAULT_FLAG_WRITE : 0, NULL);
 	if (unlikely(*flt & VM_FAULT_ERROR)) {
 		if (*flt & VM_FAULT_OOM) {
 			ret = -ENOMEM;
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index 8dce601f125c..523958404142 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -602,7 +602,7 @@ static int __do_page_fault(struct pt_regs *regs, unsigned long address,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	major |= fault & VM_FAULT_MAJOR;
 
diff --git a/arch/riscv/mm/fault.c b/arch/riscv/mm/fault.c
index 88401d5125bc..7374877a5e52 100644
--- a/arch/riscv/mm/fault.c
+++ b/arch/riscv/mm/fault.c
@@ -120,7 +120,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, addr, flags);
+	fault = handle_mm_fault(vma, addr, flags, NULL);
 
 	/*
 	 * If we need to retry but a fatal signal is pending, handle the
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 0a355616545d..725cfaae65e1 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -513,7 +513,7 @@ static inline vm_fault_t do_exception(struct pt_regs *regs, int access)
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 	if (fault_signal_pending(fault, regs)) {
 		fault = VM_FAULT_SIGNAL;
 		if (flags & FAULT_FLAG_RETRY_NOWAIT)
diff --git a/arch/sh/mm/fault.c b/arch/sh/mm/fault.c
index 6defd2c6d9b1..885915b820cb 100644
--- a/arch/sh/mm/fault.c
+++ b/arch/sh/mm/fault.c
@@ -481,7 +481,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if (unlikely(fault & (VM_FAULT_RETRY | VM_FAULT_ERROR)))
 		if (mm_fault_error(regs, error_code, address, fault))
diff --git a/arch/sparc/mm/fault_32.c b/arch/sparc/mm/fault_32.c
index b0440b0edd97..6d9d2b74ac74 100644
--- a/arch/sparc/mm/fault_32.c
+++ b/arch/sparc/mm/fault_32.c
@@ -235,7 +235,7 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
@@ -405,7 +405,7 @@ static void force_user_fault(unsigned long address, int write)
 		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
 	}
-	switch (handle_mm_fault(vma, address, flags)) {
+	switch (handle_mm_fault(vma, address, flags, NULL)) {
 	case VM_FAULT_SIGBUS:
 	case VM_FAULT_OOM:
 		goto do_sigbus;
diff --git a/arch/sparc/mm/fault_64.c b/arch/sparc/mm/fault_64.c
index 8f8a604c1300..f3aa868b33ae 100644
--- a/arch/sparc/mm/fault_64.c
+++ b/arch/sparc/mm/fault_64.c
@@ -433,7 +433,7 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 			goto bad_area;
 	}
 
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		goto exit_exception;
diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c
index cced82946042..3c0079c7ace1 100644
--- a/arch/um/kernel/trap.c
+++ b/arch/um/kernel/trap.c
@@ -74,7 +74,7 @@ int handle_page_fault(unsigned long address, unsigned long ip,
 	do {
 		vm_fault_t fault;
 
-		fault = handle_mm_fault(vma, address, flags);
+		fault = handle_mm_fault(vma, address, flags, NULL);
 
 		if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 			goto out_nosemaphore;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index b63f70b6ee4c..0f6a43fc176b 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1434,7 +1434,7 @@ void do_user_addr_fault(struct pt_regs *regs,
 	 * userland). The return to userland is identified whenever
 	 * FAULT_FLAG_USER|FAULT_FLAG_KILLABLE are both set in flags.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 	major |= fault & VM_FAULT_MAJOR;
 
 	/* Quick path to respond to signals */
diff --git a/arch/xtensa/mm/fault.c b/arch/xtensa/mm/fault.c
index 2ab0e0dcd166..447fbafde34a 100644
--- a/arch/xtensa/mm/fault.c
+++ b/arch/xtensa/mm/fault.c
@@ -108,7 +108,7 @@ void do_page_fault(struct pt_regs *regs)
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(vma, address, flags);
+	fault = handle_mm_fault(vma, address, flags, NULL);
 
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
diff --git a/drivers/iommu/amd/iommu_v2.c b/drivers/iommu/amd/iommu_v2.c
index 1c160d4d7d2b..7d1fe03818a3 100644
--- a/drivers/iommu/amd/iommu_v2.c
+++ b/drivers/iommu/amd/iommu_v2.c
@@ -516,7 +516,7 @@ static void do_fault(struct work_struct *work)
 	if (access_error(vma, fault))
 		goto out;
 
-	ret = handle_mm_fault(vma, address, flags);
+	ret = handle_mm_fault(vma, address, flags, NULL);
 out:
 	mmap_read_unlock(mm);
 
* Unmerged path drivers/iommu/intel/svm.c
diff --git a/include/linux/mm.h b/include/linux/mm.h
index e3b1a16638a0..bf9da0327814 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -40,6 +40,7 @@ struct file_ra_state;
 struct user_struct;
 struct writeback_control;
 struct bdi_writeback;
+struct pt_regs;
 
 void init_mm_internals(void);
 
@@ -1615,7 +1616,8 @@ int invalidate_inode_page(struct page *page);
 
 #ifdef CONFIG_MMU
 extern vm_fault_t handle_mm_fault(struct vm_area_struct *vma,
-			unsigned long address, unsigned int flags);
+				  unsigned long address, unsigned int flags,
+				  struct pt_regs *regs);
 extern int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,
 			    unsigned long address, unsigned int fault_flags,
 			    bool *unlocked);
@@ -1625,7 +1627,8 @@ void unmap_mapping_range(struct address_space *mapping,
 		loff_t const holebegin, loff_t const holelen, int even_cows);
 #else
 static inline vm_fault_t handle_mm_fault(struct vm_area_struct *vma,
-		unsigned long address, unsigned int flags)
+					 unsigned long address, unsigned int flags,
+					 struct pt_regs *regs)
 {
 	/* should never happen if there's no MMU */
 	BUG();
diff --git a/mm/gup.c b/mm/gup.c
index b6ca92e3db6b..9e6f2686668d 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -1101,7 +1101,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 		VM_BUG_ON(*flags & FOLL_NOUNSHARE);
 	}
 
-	ret = handle_mm_fault(vma, address, fault_flags);
+	ret = handle_mm_fault(vma, address, fault_flags, NULL);
 	if (ret & VM_FAULT_ERROR) {
 		int err = vm_fault_to_errno(ret, *flags);
 
@@ -1456,7 +1456,7 @@ int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,
 	    fatal_signal_pending(current))
 		return -EINTR;
 
-	ret = handle_mm_fault(vma, address, fault_flags);
+	ret = handle_mm_fault(vma, address, fault_flags, NULL);
 	major |= ret & VM_FAULT_MAJOR;
 	if (ret & VM_FAULT_ERROR) {
 		int err = vm_fault_to_errno(ret, 0);
diff --git a/mm/hmm.c b/mm/hmm.c
index 31720b84103b..d0c908b26006 100644
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@ -84,7 +84,8 @@ static int hmm_vma_fault(unsigned long addr, unsigned long end,
 	}
 
 	for (; addr < end; addr += PAGE_SIZE)
-		if (handle_mm_fault(vma, addr, fault_flags) & VM_FAULT_ERROR)
+		if (handle_mm_fault(vma, addr, fault_flags, NULL) &
+		    VM_FAULT_ERROR)
 			return -EFAULT;
 	return -EBUSY;
 }
diff --git a/mm/ksm.c b/mm/ksm.c
index 256526925e41..c355a8e14137 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -480,7 +480,8 @@ static int break_ksm(struct vm_area_struct *vma, unsigned long addr)
 			break;
 		if (PageKsm(page))
 			ret = handle_mm_fault(vma, addr,
-					FAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);
+					      FAULT_FLAG_WRITE | FAULT_FLAG_REMOTE,
+					      NULL);
 		else
 			ret = VM_FAULT_WRITE;
 		put_page(page);
diff --git a/mm/memory.c b/mm/memory.c
index 68de93d31a4b..a40b06547f8f 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -69,6 +69,8 @@
 #include <linux/dax.h>
 #include <linux/oom.h>
 #include <linux/numa.h>
+#include <linux/perf_event.h>
+#include <linux/ptrace.h>
 
 #include <asm/io.h>
 #include <asm/mmu_context.h>
@@ -4399,6 +4401,64 @@ static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,
 	return handle_pte_fault(&vmf);
 }
 
+/**
+ * mm_account_fault - Do page fault accountings
+ *
+ * @regs: the pt_regs struct pointer.  When set to NULL, will skip accounting
+ *        of perf event counters, but we'll still do the per-task accounting to
+ *        the task who triggered this page fault.
+ * @address: the faulted address.
+ * @flags: the fault flags.
+ * @ret: the fault retcode.
+ *
+ * This will take care of most of the page fault accountings.  Meanwhile, it
+ * will also include the PERF_COUNT_SW_PAGE_FAULTS_[MAJ|MIN] perf counter
+ * updates.  However note that the handling of PERF_COUNT_SW_PAGE_FAULTS should
+ * still be in per-arch page fault handlers at the entry of page fault.
+ */
+static inline void mm_account_fault(struct pt_regs *regs,
+				    unsigned long address, unsigned int flags,
+				    vm_fault_t ret)
+{
+	bool major;
+
+	/*
+	 * We don't do accounting for some specific faults:
+	 *
+	 * - Unsuccessful faults (e.g. when the address wasn't valid).  That
+	 *   includes arch_vma_access_permitted() failing before reaching here.
+	 *   So this is not a "this many hardware page faults" counter.  We
+	 *   should use the hw profiling for that.
+	 *
+	 * - Incomplete faults (VM_FAULT_RETRY).  They will only be counted
+	 *   once they're completed.
+	 */
+	if (ret & (VM_FAULT_ERROR | VM_FAULT_RETRY))
+		return;
+
+	/*
+	 * We define the fault as a major fault when the final successful fault
+	 * is VM_FAULT_MAJOR, or if it retried (which implies that we couldn't
+	 * handle it immediately previously).
+	 */
+	major = (ret & VM_FAULT_MAJOR) || (flags & FAULT_FLAG_TRIED);
+
+	/*
+	 * If the fault is done for GUP, regs will be NULL, and we will skip
+	 * the fault accounting.
+	 */
+	if (!regs)
+		return;
+
+	if (major) {
+		current->maj_flt++;
+		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);
+	} else {
+		current->min_flt++;
+		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);
+	}
+}
+
 /*
  * By the time we get here, we already hold the mm semaphore
  *
@@ -4406,7 +4466,7 @@ static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,
  * return value.  See filemap_fault() and __lock_page_or_retry().
  */
 vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,
-		unsigned int flags)
+			   unsigned int flags, struct pt_regs *regs)
 {
 	vm_fault_t ret;
 
@@ -4447,6 +4507,8 @@ vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,
 			mem_cgroup_oom_synchronize(false);
 	}
 
+	mm_account_fault(regs, address, flags, ret);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(handle_mm_fault);
