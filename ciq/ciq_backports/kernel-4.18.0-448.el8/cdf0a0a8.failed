wifi: cfg80211: clean up links appropriately

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit cdf0a0a80c841cfede6926d417a8756ea4c52d26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/cdf0a0a8.failed

This was missing earlier, we need to remove links when
interfaces are being destroyed, and we also need to
stop (AP) operations when a link is being destroyed.
Address these issues to remove many warnings that will
otherwise appear in mac80211.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit cdf0a0a80c841cfede6926d417a8756ea4c52d26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 7060846918e1,d774e9a95492..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -15379,6 -15668,199 +15379,202 @@@ static int nl80211_set_fils_aad(struct 
  	return rdev_set_fils_aad(rdev, dev, &fils_aad);
  }
  
++<<<<<<< HEAD
++=======
+ static int nl80211_add_link(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	unsigned int link_id = nl80211_link_id(info->attrs);
+ 	struct net_device *dev = info->user_ptr[1];
+ 	struct wireless_dev *wdev = dev->ieee80211_ptr;
+ 	int ret;
+ 
+ 	if (!(wdev->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))
+ 		return -EINVAL;
+ 
+ 	switch (wdev->iftype) {
+ 	case NL80211_IFTYPE_AP:
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!info->attrs[NL80211_ATTR_MAC] ||
+ 	    !is_valid_ether_addr(nla_data(info->attrs[NL80211_ATTR_MAC])))
+ 		return -EINVAL;
+ 
+ 	wdev_lock(wdev);
+ 	wdev->valid_links |= BIT(link_id);
+ 	ether_addr_copy(wdev->links[link_id].addr,
+ 			nla_data(info->attrs[NL80211_ATTR_MAC]));
+ 
+ 	ret = rdev_add_intf_link(rdev, wdev, link_id);
+ 	if (ret) {
+ 		wdev->valid_links &= ~BIT(link_id);
+ 		eth_zero_addr(wdev->links[link_id].addr);
+ 	}
+ 	wdev_unlock(wdev);
+ 
+ 	return ret;
+ }
+ 
+ static int nl80211_remove_link(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	unsigned int link_id = nl80211_link_id(info->attrs);
+ 	struct net_device *dev = info->user_ptr[1];
+ 	struct wireless_dev *wdev = dev->ieee80211_ptr;
+ 
+ 	/* cannot remove if there's no link */
+ 	if (!info->attrs[NL80211_ATTR_MLO_LINK_ID])
+ 		return -EINVAL;
+ 
+ 	switch (wdev->iftype) {
+ 	case NL80211_IFTYPE_AP:
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	wdev_lock(wdev);
+ 	cfg80211_remove_link(wdev, link_id);
+ 	wdev_unlock(wdev);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ nl80211_add_mod_link_station(struct sk_buff *skb, struct genl_info *info,
+ 			     bool add)
+ {
+ 	struct link_station_parameters params = {};
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct net_device *dev = info->user_ptr[1];
+ 	int err;
+ 
+ 	if ((add && !rdev->ops->add_link_station) ||
+ 	    (!add && !rdev->ops->mod_link_station))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (add && !info->attrs[NL80211_ATTR_MAC])
+ 		return -EINVAL;
+ 
+ 	if (add && !info->attrs[NL80211_ATTR_MLD_ADDR])
+ 		return -EINVAL;
+ 
+ 	if (add && !info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])
+ 		return -EINVAL;
+ 
+ 	if (info->attrs[NL80211_ATTR_MLD_ADDR])
+ 		params.mld_mac = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);
+ 
+ 	if (info->attrs[NL80211_ATTR_MAC]) {
+ 		params.link_mac = nla_data(info->attrs[NL80211_ATTR_MAC]);
+ 		if (!is_valid_ether_addr(params.link_mac))
+ 			return -EINVAL;
+ 	}
+ 
+ 	if (!info->attrs[NL80211_ATTR_MLO_LINK_ID])
+ 		return -EINVAL;
+ 
+ 	params.link_id = nla_get_u8(info->attrs[NL80211_ATTR_MLO_LINK_ID]);
+ 
+ 	if (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {
+ 		params.supported_rates =
+ 			nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);
+ 		params.supported_rates_len =
+ 			nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);
+ 	}
+ 
+ 	if (info->attrs[NL80211_ATTR_HT_CAPABILITY])
+ 		params.ht_capa =
+ 			nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);
+ 
+ 	if (info->attrs[NL80211_ATTR_VHT_CAPABILITY])
+ 		params.vht_capa =
+ 			nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);
+ 
+ 	if (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {
+ 		params.he_capa =
+ 			nla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);
+ 		params.he_capa_len =
+ 			nla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);
+ 
+ 		if (info->attrs[NL80211_ATTR_EHT_CAPABILITY]) {
+ 			params.eht_capa =
+ 				nla_data(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);
+ 			params.eht_capa_len =
+ 				nla_len(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);
+ 
+ 			if (!ieee80211_eht_capa_size_ok((const u8 *)params.he_capa,
+ 							(const u8 *)params.eht_capa,
+ 							params.eht_capa_len))
+ 				return -EINVAL;
+ 		}
+ 	}
+ 
+ 	if (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])
+ 		params.he_6ghz_capa =
+ 			nla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);
+ 
+ 	if (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {
+ 		params.opmode_notif_used = true;
+ 		params.opmode_notif =
+ 			nla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);
+ 	}
+ 
+ 	err = nl80211_parse_sta_txpower_setting(info, &params.txpwr,
+ 						&params.txpwr_set);
+ 	if (err)
+ 		return err;
+ 
+ 	wdev_lock(dev->ieee80211_ptr);
+ 	if (add)
+ 		err = rdev_add_link_station(rdev, dev, &params);
+ 	else
+ 		err = rdev_mod_link_station(rdev, dev, &params);
+ 	wdev_unlock(dev->ieee80211_ptr);
+ 
+ 	return err;
+ }
+ 
+ static int
+ nl80211_add_link_station(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	return nl80211_add_mod_link_station(skb, info, true);
+ }
+ 
+ static int
+ nl80211_modify_link_station(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	return nl80211_add_mod_link_station(skb, info, false);
+ }
+ 
+ static int
+ nl80211_remove_link_station(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct link_station_del_parameters params = {};
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct net_device *dev = info->user_ptr[1];
+ 	int ret;
+ 
+ 	if (!rdev->ops->del_link_station)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!info->attrs[NL80211_ATTR_MLD_ADDR] ||
+ 	    !info->attrs[NL80211_ATTR_MLO_LINK_ID])
+ 		return -EINVAL;
+ 
+ 	params.mld_mac = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);
+ 	params.link_id = nla_get_u8(info->attrs[NL80211_ATTR_MLO_LINK_ID]);
+ 
+ 	wdev_lock(dev->ieee80211_ptr);
+ 	ret = rdev_del_link_station(rdev, dev, &params);
+ 	wdev_unlock(dev->ieee80211_ptr);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> cdf0a0a80c84 (wifi: cfg80211: clean up links appropriately)
  #define NL80211_FLAG_NEED_WIPHY		0x01
  #define NL80211_FLAG_NEED_NETDEV	0x02
  #define NL80211_FLAG_NEED_RTNL		0x04
diff --git a/net/wireless/core.c b/net/wireless/core.c
index f08d4b3bb148..5532dd152cba 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -342,7 +342,7 @@ void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev)
 
 			wiphy_lock(&rdev->wiphy);
 			cfg80211_leave(rdev, wdev);
-			rdev_del_virtual_intf(rdev, wdev);
+			cfg80211_remove_virtual_intf(rdev, wdev);
 			wiphy_unlock(&rdev->wiphy);
 		}
 	}
@@ -1419,6 +1419,7 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
 	case NETDEV_GOING_DOWN:
 		wiphy_lock(&rdev->wiphy);
 		cfg80211_leave(rdev, wdev);
+		cfg80211_remove_links(wdev);
 		wiphy_unlock(&rdev->wiphy);
 		break;
 	case NETDEV_DOWN:
diff --git a/net/wireless/core.h b/net/wireless/core.h
index de29999a1dc9..d4f68ff383c2 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -561,4 +561,9 @@ void cfg80211_release_pmsr(struct wireless_dev *wdev, u32 portid);
 void cfg80211_pmsr_wdev_down(struct wireless_dev *wdev);
 void cfg80211_pmsr_free_wk(struct work_struct *work);
 
+void cfg80211_remove_link(struct wireless_dev *wdev, unsigned int link_id);
+void cfg80211_remove_links(struct wireless_dev *wdev);
+int cfg80211_remove_virtual_intf(struct cfg80211_registered_device *rdev,
+				 struct wireless_dev *wdev);
+
 #endif /* __NET_WIRELESS_CORE_H */
* Unmerged path net/wireless/nl80211.c
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 2eda097aee7f..a5d6809a8a38 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -2417,3 +2417,46 @@ bool cfg80211_iftype_allowed(struct wiphy *wiphy, enum nl80211_iftype iftype,
 	return false;
 }
 EXPORT_SYMBOL(cfg80211_iftype_allowed);
+
+void cfg80211_remove_link(struct wireless_dev *wdev, unsigned int link_id)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+
+	ASSERT_WDEV_LOCK(wdev);
+
+	switch (wdev->iftype) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		__cfg80211_stop_ap(rdev, wdev->netdev, link_id, true);
+		break;
+	default:
+		/* per-link not relevant */
+		break;
+	}
+
+	wdev->valid_links &= ~BIT(link_id);
+
+	rdev_del_intf_link(rdev, wdev, link_id);
+
+	eth_zero_addr(wdev->links[link_id].addr);
+}
+
+void cfg80211_remove_links(struct wireless_dev *wdev)
+{
+	unsigned int link_id;
+
+	wdev_lock(wdev);
+	if (wdev->valid_links) {
+		for_each_valid_link(wdev, link_id)
+			cfg80211_remove_link(wdev, link_id);
+	}
+	wdev_unlock(wdev);
+}
+
+int cfg80211_remove_virtual_intf(struct cfg80211_registered_device *rdev,
+				 struct wireless_dev *wdev)
+{
+	cfg80211_remove_links(wdev);
+
+	return rdev_del_virtual_intf(rdev, wdev);
+}
