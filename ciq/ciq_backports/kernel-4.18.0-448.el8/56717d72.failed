ASoC: wm_adsp: Remove the wmfw_add_ctl helper function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit 56717d72f7a811799e8d138ff3d49325272c5cf6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/56717d72.failed

The helper function wmfw_add_ctl is only called from one place and that
place is a function with only 2 lines of code. Merge the helper function
into the work function to simplify the code.

	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20211117132300.1290-1-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 56717d72f7a811799e8d138ff3d49325272c5cf6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
diff --cc sound/soc/codecs/wm_adsp.c
index c1b5ea3b5718,404717e30f44..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -1272,17 -537,20 +1272,26 @@@ static unsigned int wmfw_convert_flags(
  	return out;
  }
  
- static int wmfw_add_ctl(struct wm_adsp *dsp, struct wm_coeff_ctl *ctl)
+ static void wm_adsp_ctl_work(struct work_struct *work)
  {
++<<<<<<< HEAD
++=======
+ 	struct wm_coeff_ctl *ctl = container_of(work,
+ 						struct wm_coeff_ctl,
+ 						work);
+ 	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
+ 	struct wm_adsp *dsp = container_of(cs_ctl->dsp,
+ 					   struct wm_adsp,
+ 					   cs_dsp);
++>>>>>>> 56717d72f7a8 (ASoC: wm_adsp: Remove the wmfw_add_ctl helper function)
  	struct snd_kcontrol_new *kcontrol;
- 	int ret;
  
 +	if (!ctl || !ctl->name)
 +		return -EINVAL;
 +
  	kcontrol = kzalloc(sizeof(*kcontrol), GFP_KERNEL);
  	if (!kcontrol)
- 		return -ENOMEM;
+ 		return;
  
  	kcontrol->name = ctl->name;
  	kcontrol->info = wm_coeff_info;
@@@ -1308,110 -576,15 +1317,111 @@@
  		break;
  	}
  
- 	ret = snd_soc_add_component_controls(dsp->component, kcontrol, 1);
- 	if (ret < 0)
- 		goto err_kcontrol;
+ 	snd_soc_add_component_controls(dsp->component, kcontrol, 1);
  
  	kfree(kcontrol);
++<<<<<<< HEAD
 +
 +	return 0;
 +
 +err_kcontrol:
 +	kfree(kcontrol);
 +	return ret;
 +}
 +
 +static int wm_coeff_init_control_caches(struct wm_adsp *dsp)
 +{
 +	struct wm_coeff_ctl *ctl;
 +	int ret;
 +
 +	list_for_each_entry(ctl, &dsp->ctl_list, list) {
 +		if (!ctl->enabled || ctl->set)
 +			continue;
 +		if (ctl->flags & WMFW_CTL_FLAG_VOLATILE)
 +			continue;
 +
 +		/*
 +		 * For readable controls populate the cache from the DSP memory.
 +		 * For non-readable controls the cache was zero-filled when
 +		 * created so we don't need to do anything.
 +		 */
 +		if (!ctl->flags || (ctl->flags & WMFW_CTL_FLAG_READABLE)) {
 +			ret = wm_coeff_read_ctrl_raw(ctl, ctl->cache, ctl->len);
 +			if (ret < 0)
 +				return ret;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int wm_coeff_sync_controls(struct wm_adsp *dsp)
 +{
 +	struct wm_coeff_ctl *ctl;
 +	int ret;
 +
 +	list_for_each_entry(ctl, &dsp->ctl_list, list) {
 +		if (!ctl->enabled)
 +			continue;
 +		if (ctl->set && !(ctl->flags & WMFW_CTL_FLAG_VOLATILE)) {
 +			ret = wm_coeff_write_ctrl_raw(ctl, ctl->cache,
 +						      ctl->len);
 +			if (ret < 0)
 +				return ret;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static void wm_adsp_signal_event_controls(struct wm_adsp *dsp,
 +					  unsigned int event)
 +{
 +	struct wm_coeff_ctl *ctl;
 +	int ret;
 +
 +	list_for_each_entry(ctl, &dsp->ctl_list, list) {
 +		if (ctl->type != WMFW_CTL_TYPE_HOSTEVENT)
 +			continue;
 +
 +		if (!ctl->enabled)
 +			continue;
 +
 +		ret = wm_coeff_write_acked_control(ctl, event);
 +		if (ret)
 +			adsp_warn(dsp,
 +				  "Failed to send 0x%x event to alg 0x%x (%d)\n",
 +				  event, ctl->alg_region.alg, ret);
 +	}
 +}
 +
 +static void wm_adsp_ctl_work(struct work_struct *work)
 +{
 +	struct wm_coeff_ctl *ctl = container_of(work,
 +						struct wm_coeff_ctl,
 +						work);
 +
 +	wmfw_add_ctl(ctl->dsp, ctl);
++=======
++>>>>>>> 56717d72f7a8 (ASoC: wm_adsp: Remove the wmfw_add_ctl helper function)
 +}
 +
 +static void wm_adsp_free_ctl_blk(struct wm_coeff_ctl *ctl)
 +{
 +	cancel_work_sync(&ctl->work);
 +
 +	kfree(ctl->cache);
 +	kfree(ctl->name);
 +	kfree(ctl->subname);
 +	kfree(ctl);
  }
  
 -static int wm_adsp_control_add(struct cs_dsp_coeff_ctl *cs_ctl)
 +static int wm_adsp_create_control(struct wm_adsp *dsp,
 +				  const struct wm_adsp_alg_region *alg_region,
 +				  unsigned int offset, unsigned int len,
 +				  const char *subname, unsigned int subname_len,
 +				  unsigned int flags, unsigned int type)
  {
 -	struct wm_adsp *dsp = container_of(cs_ctl->dsp, struct wm_adsp, cs_dsp);
 -	struct cs_dsp *cs_dsp = &dsp->cs_dsp;
  	struct wm_coeff_ctl *ctl;
  	char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
  	const char *region_name;
* Unmerged path sound/soc/codecs/wm_adsp.c
