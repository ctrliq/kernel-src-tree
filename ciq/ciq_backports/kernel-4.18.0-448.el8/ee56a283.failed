x86/sgx: Improve comments for sgx_encl_lookup/alloc_backing()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Kristen Carlson Accardi <kristen.c.accardi@intel.com>
commit ee56a283988d739c25d2d00ffb22707cb487ab47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ee56a283.failed

Modify the comments for sgx_encl_lookup_backing() and for
sgx_encl_alloc_backing() to indicate that they take a reference
which must be dropped with a call to sgx_encl_put_backing().
Make sgx_encl_lookup_backing() static for now, and change the
name of sgx_encl_get_backing() to __sgx_encl_get_backing() to
make it more clear that sgx_encl_get_backing() is an internal
function.

	Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/all/YtUs3MKLzFg+rqEV@zn.tnic/
(cherry picked from commit ee56a283988d739c25d2d00ffb22707cb487ab47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/sgx/encl.c
#	arch/x86/kernel/cpu/sgx/encl.h
diff --cc arch/x86/kernel/cpu/sgx/encl.c
index deeb84bc1e67,f40d64206ded..000000000000
--- a/arch/x86/kernel/cpu/sgx/encl.c
+++ b/arch/x86/kernel/cpu/sgx/encl.c
@@@ -930,7 -929,7 +933,11 @@@ static struct page *sgx_encl_get_backin
   *   0 on success,
   *   -errno otherwise.
   */
++<<<<<<< HEAD
 +int sgx_encl_get_backing(struct sgx_encl *encl, unsigned long page_index,
++=======
+ static int __sgx_encl_get_backing(struct sgx_encl *encl, unsigned long page_index,
++>>>>>>> ee56a283988d (x86/sgx: Improve comments for sgx_encl_lookup/alloc_backing())
  			 struct sgx_backing *backing)
  {
  	pgoff_t page_pcmd_off = sgx_encl_get_backing_page_pcmd_offset(encl, page_index);
@@@ -954,6 -953,111 +961,114 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * When called from ksgxd, returns the mem_cgroup of a struct mm stored
+  * in the enclave's mm_list. When not called from ksgxd, just returns
+  * the mem_cgroup of the current task.
+  */
+ static struct mem_cgroup *sgx_encl_get_mem_cgroup(struct sgx_encl *encl)
+ {
+ 	struct mem_cgroup *memcg = NULL;
+ 	struct sgx_encl_mm *encl_mm;
+ 	int idx;
+ 
+ 	/*
+ 	 * If called from normal task context, return the mem_cgroup
+ 	 * of the current task's mm. The remainder of the handling is for
+ 	 * ksgxd.
+ 	 */
+ 	if (!current_is_ksgxd())
+ 		return get_mem_cgroup_from_mm(current->mm);
+ 
+ 	/*
+ 	 * Search the enclave's mm_list to find an mm associated with
+ 	 * this enclave to charge the allocation to.
+ 	 */
+ 	idx = srcu_read_lock(&encl->srcu);
+ 
+ 	list_for_each_entry_rcu(encl_mm, &encl->mm_list, list) {
+ 		if (!mmget_not_zero(encl_mm->mm))
+ 			continue;
+ 
+ 		memcg = get_mem_cgroup_from_mm(encl_mm->mm);
+ 
+ 		mmput_async(encl_mm->mm);
+ 
+ 		break;
+ 	}
+ 
+ 	srcu_read_unlock(&encl->srcu, idx);
+ 
+ 	/*
+ 	 * In the rare case that there isn't an mm associated with
+ 	 * the enclave, set memcg to the current active mem_cgroup.
+ 	 * This will be the root mem_cgroup if there is no active
+ 	 * mem_cgroup.
+ 	 */
+ 	if (!memcg)
+ 		return get_mem_cgroup_from_mm(NULL);
+ 
+ 	return memcg;
+ }
+ 
+ /**
+  * sgx_encl_alloc_backing() - create a new backing storage page
+  * @encl:	an enclave pointer
+  * @page_index:	enclave page index
+  * @backing:	data for accessing backing storage for the page
+  *
+  * When called from ksgxd, sets the active memcg from one of the
+  * mms in the enclave's mm_list prior to any backing page allocation,
+  * in order to ensure that shmem page allocations are charged to the
+  * enclave.  Create a backing page for loading data back into an EPC page with
+  * ELDU.  This function takes a reference on a new backing page which
+  * must be dropped with a corresponding call to sgx_encl_put_backing().
+  *
+  * Return:
+  *   0 on success,
+  *   -errno otherwise.
+  */
+ int sgx_encl_alloc_backing(struct sgx_encl *encl, unsigned long page_index,
+ 			   struct sgx_backing *backing)
+ {
+ 	struct mem_cgroup *encl_memcg = sgx_encl_get_mem_cgroup(encl);
+ 	struct mem_cgroup *memcg = set_active_memcg(encl_memcg);
+ 	int ret;
+ 
+ 	ret = __sgx_encl_get_backing(encl, page_index, backing);
+ 
+ 	set_active_memcg(memcg);
+ 	mem_cgroup_put(encl_memcg);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * sgx_encl_lookup_backing() - retrieve an existing backing storage page
+  * @encl:	an enclave pointer
+  * @page_index:	enclave page index
+  * @backing:	data for accessing backing storage for the page
+  *
+  * Retrieve a backing page for loading data back into an EPC page with ELDU.
+  * It is the caller's responsibility to ensure that it is appropriate to use
+  * sgx_encl_lookup_backing() rather than sgx_encl_alloc_backing(). If lookup is
+  * not used correctly, this will cause an allocation which is not accounted for.
+  * This function takes a reference on an existing backing page which must be
+  * dropped with a corresponding call to sgx_encl_put_backing().
+  *
+  * Return:
+  *   0 on success,
+  *   -errno otherwise.
+  */
+ static int sgx_encl_lookup_backing(struct sgx_encl *encl, unsigned long page_index,
+ 			   struct sgx_backing *backing)
+ {
+ 	return __sgx_encl_get_backing(encl, page_index, backing);
+ }
+ 
++>>>>>>> ee56a283988d (x86/sgx: Improve comments for sgx_encl_lookup/alloc_backing())
  /**
   * sgx_encl_put_backing() - Unpin the backing storage
   * @backing:	data for accessing backing storage for the page
diff --cc arch/x86/kernel/cpu/sgx/encl.h
index 57cc23602bbb,f94ff14c9486..000000000000
--- a/arch/x86/kernel/cpu/sgx/encl.h
+++ b/arch/x86/kernel/cpu/sgx/encl.h
@@@ -106,8 -106,9 +106,13 @@@ int sgx_encl_may_map(struct sgx_encl *e
  void sgx_encl_release(struct kref *ref);
  int sgx_encl_mm_add(struct sgx_encl *encl, struct mm_struct *mm);
  const cpumask_t *sgx_encl_cpumask(struct sgx_encl *encl);
++<<<<<<< HEAD
 +int sgx_encl_get_backing(struct sgx_encl *encl, unsigned long page_index,
 +			 struct sgx_backing *backing);
++=======
+ int sgx_encl_alloc_backing(struct sgx_encl *encl, unsigned long page_index,
+ 			   struct sgx_backing *backing);
++>>>>>>> ee56a283988d (x86/sgx: Improve comments for sgx_encl_lookup/alloc_backing())
  void sgx_encl_put_backing(struct sgx_backing *backing);
  int sgx_encl_test_and_clear_young(struct mm_struct *mm,
  				  struct sgx_encl_page *page);
* Unmerged path arch/x86/kernel/cpu/sgx/encl.c
* Unmerged path arch/x86/kernel/cpu/sgx/encl.h
