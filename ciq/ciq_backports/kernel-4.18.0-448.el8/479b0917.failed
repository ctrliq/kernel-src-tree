scsi: lpfc: Create a sysfs entry called lpfc_xcvr_data for transceiver info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Justin Tee <justin.tee@broadcom.com>
commit 479b0917e4477f49df2e3be454aac3cfa5dec171
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/479b0917.failed

The DUMP_MEMORY mailbox command is implemented for page A0 and A2 to
retrieve transceiver information from firmware.

The mailbox command output is then formatted to print raw data values for
userspace to parse via sysfs.

	Signed-off-by: Justin Tee <justin.tee@broadcom.com>
Link: https://lore.kernel.org/r/20221017164323.14536-4-justintee8345@gmail.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 479b0917e4477f49df2e3be454aac3cfa5dec171)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_attr.c
diff --cc drivers/scsi/lpfc/lpfc_attr.c
index 5c6b3b9787fa,030ad1d59cbd..000000000000
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@@ -6202,127 -5969,126 +6319,250 @@@ LPFC_ATTR_RW(vmid_priority_tagging, LPF
  	     LPFC_VMID_PRIO_TAG_ALL_TARGETS,
  	     "Enable Priority Tagging VMID support");
  
++<<<<<<< HEAD
 +struct device_attribute *lpfc_hba_attrs[] = {
 +	&dev_attr_nvme_info,
 +	&dev_attr_scsi_stat,
 +	&dev_attr_bg_info,
 +	&dev_attr_bg_guard_err,
 +	&dev_attr_bg_apptag_err,
 +	&dev_attr_bg_reftag_err,
 +	&dev_attr_info,
 +	&dev_attr_serialnum,
 +	&dev_attr_modeldesc,
 +	&dev_attr_modelname,
 +	&dev_attr_programtype,
 +	&dev_attr_portnum,
 +	&dev_attr_fwrev,
 +	&dev_attr_hdw,
 +	&dev_attr_option_rom_version,
 +	&dev_attr_link_state,
 +	&dev_attr_num_discovered_ports,
 +	&dev_attr_menlo_mgmt_mode,
 +	&dev_attr_lpfc_drvr_version,
 +	&dev_attr_lpfc_enable_fip,
 +	&dev_attr_lpfc_temp_sensor,
 +	&dev_attr_lpfc_log_verbose,
 +	&dev_attr_lpfc_lun_queue_depth,
 +	&dev_attr_lpfc_tgt_queue_depth,
 +	&dev_attr_lpfc_hba_queue_depth,
 +	&dev_attr_lpfc_peer_port_login,
 +	&dev_attr_lpfc_nodev_tmo,
 +	&dev_attr_lpfc_devloss_tmo,
 +	&dev_attr_lpfc_enable_fc4_type,
 +	&dev_attr_lpfc_fcp_class,
 +	&dev_attr_lpfc_use_adisc,
 +	&dev_attr_lpfc_first_burst_size,
 +	&dev_attr_lpfc_ack0,
 +	&dev_attr_lpfc_xri_rebalancing,
 +	&dev_attr_lpfc_topology,
 +	&dev_attr_lpfc_scan_down,
 +	&dev_attr_lpfc_link_speed,
 +	&dev_attr_lpfc_fcp_io_sched,
 +	&dev_attr_lpfc_ns_query,
 +	&dev_attr_lpfc_fcp2_no_tgt_reset,
 +	&dev_attr_lpfc_cr_delay,
 +	&dev_attr_lpfc_cr_count,
 +	&dev_attr_lpfc_multi_ring_support,
 +	&dev_attr_lpfc_multi_ring_rctl,
 +	&dev_attr_lpfc_multi_ring_type,
 +	&dev_attr_lpfc_fdmi_on,
 +	&dev_attr_lpfc_enable_SmartSAN,
 +	&dev_attr_lpfc_max_luns,
 +	&dev_attr_lpfc_enable_npiv,
 +	&dev_attr_lpfc_fcf_failover_policy,
 +	&dev_attr_lpfc_enable_rrq,
 +	&dev_attr_lpfc_fcp_wait_abts_rsp,
 +	&dev_attr_nport_evt_cnt,
 +	&dev_attr_board_mode,
 +	&dev_attr_max_vpi,
 +	&dev_attr_used_vpi,
 +	&dev_attr_max_rpi,
 +	&dev_attr_used_rpi,
 +	&dev_attr_max_xri,
 +	&dev_attr_used_xri,
 +	&dev_attr_npiv_info,
 +	&dev_attr_issue_reset,
 +	&dev_attr_lpfc_poll,
 +	&dev_attr_lpfc_poll_tmo,
 +	&dev_attr_lpfc_task_mgmt_tmo,
 +	&dev_attr_lpfc_use_msi,
 +	&dev_attr_lpfc_nvme_oas,
 +	&dev_attr_lpfc_nvme_embed_cmd,
 +	&dev_attr_lpfc_fcp_imax,
 +	&dev_attr_lpfc_force_rscn,
 +	&dev_attr_lpfc_cq_poll_threshold,
 +	&dev_attr_lpfc_cq_max_proc_limit,
 +	&dev_attr_lpfc_fcp_cpu_map,
 +	&dev_attr_lpfc_fcp_mq_threshold,
 +	&dev_attr_lpfc_hdw_queue,
 +	&dev_attr_lpfc_irq_chann,
 +	&dev_attr_lpfc_suppress_rsp,
 +	&dev_attr_lpfc_nvmet_mrq,
 +	&dev_attr_lpfc_nvmet_mrq_post,
 +	&dev_attr_lpfc_nvme_enable_fb,
 +	&dev_attr_lpfc_nvmet_fb_size,
 +	&dev_attr_lpfc_enable_bg,
 +	&dev_attr_lpfc_enable_hba_reset,
 +	&dev_attr_lpfc_enable_hba_heartbeat,
 +	&dev_attr_lpfc_EnableXLane,
 +	&dev_attr_lpfc_XLanePriority,
 +	&dev_attr_lpfc_xlane_lun,
 +	&dev_attr_lpfc_xlane_tgt,
 +	&dev_attr_lpfc_xlane_vpt,
 +	&dev_attr_lpfc_xlane_lun_state,
 +	&dev_attr_lpfc_xlane_lun_status,
 +	&dev_attr_lpfc_xlane_priority,
 +	&dev_attr_lpfc_sg_seg_cnt,
 +	&dev_attr_lpfc_max_scsicmpl_time,
 +	&dev_attr_lpfc_stat_data_ctrl,
 +	&dev_attr_lpfc_aer_support,
 +	&dev_attr_lpfc_aer_state_cleanup,
 +	&dev_attr_lpfc_sriov_nr_virtfn,
 +	&dev_attr_lpfc_req_fw_upgrade,
 +	&dev_attr_lpfc_suppress_link_up,
 +	&dev_attr_iocb_hw,
 +	&dev_attr_pls,
 +	&dev_attr_pt,
 +	&dev_attr_txq_hw,
 +	&dev_attr_txcmplq_hw,
 +	&dev_attr_lpfc_sriov_hw_max_virtfn,
 +	&dev_attr_protocol,
 +	&dev_attr_lpfc_xlane_supported,
 +	&dev_attr_lpfc_enable_mds_diags,
 +	&dev_attr_lpfc_ras_fwlog_buffsize,
 +	&dev_attr_lpfc_ras_fwlog_level,
 +	&dev_attr_lpfc_ras_fwlog_func,
 +	&dev_attr_lpfc_enable_bbcr,
 +	&dev_attr_lpfc_enable_dpp,
 +	&dev_attr_lpfc_enable_mi,
 +	&dev_attr_cmf_info,
 +	&dev_attr_lpfc_max_vmid,
 +	&dev_attr_lpfc_vmid_inactivity_timeout,
 +	&dev_attr_lpfc_vmid_app_header,
 +	&dev_attr_lpfc_vmid_priority_tagging,
++=======
+ static struct attribute *lpfc_hba_attrs[] = {
+ 	&dev_attr_nvme_info.attr,
+ 	&dev_attr_scsi_stat.attr,
+ 	&dev_attr_bg_info.attr,
+ 	&dev_attr_bg_guard_err.attr,
+ 	&dev_attr_bg_apptag_err.attr,
+ 	&dev_attr_bg_reftag_err.attr,
+ 	&dev_attr_info.attr,
+ 	&dev_attr_serialnum.attr,
+ 	&dev_attr_modeldesc.attr,
+ 	&dev_attr_modelname.attr,
+ 	&dev_attr_programtype.attr,
+ 	&dev_attr_portnum.attr,
+ 	&dev_attr_fwrev.attr,
+ 	&dev_attr_hdw.attr,
+ 	&dev_attr_option_rom_version.attr,
+ 	&dev_attr_link_state.attr,
+ 	&dev_attr_num_discovered_ports.attr,
+ 	&dev_attr_lpfc_drvr_version.attr,
+ 	&dev_attr_lpfc_enable_fip.attr,
+ 	&dev_attr_lpfc_temp_sensor.attr,
+ 	&dev_attr_lpfc_log_verbose.attr,
+ 	&dev_attr_lpfc_lun_queue_depth.attr,
+ 	&dev_attr_lpfc_tgt_queue_depth.attr,
+ 	&dev_attr_lpfc_hba_queue_depth.attr,
+ 	&dev_attr_lpfc_peer_port_login.attr,
+ 	&dev_attr_lpfc_nodev_tmo.attr,
+ 	&dev_attr_lpfc_devloss_tmo.attr,
+ 	&dev_attr_lpfc_enable_fc4_type.attr,
+ 	&dev_attr_lpfc_fcp_class.attr,
+ 	&dev_attr_lpfc_use_adisc.attr,
+ 	&dev_attr_lpfc_first_burst_size.attr,
+ 	&dev_attr_lpfc_ack0.attr,
+ 	&dev_attr_lpfc_xri_rebalancing.attr,
+ 	&dev_attr_lpfc_topology.attr,
+ 	&dev_attr_lpfc_scan_down.attr,
+ 	&dev_attr_lpfc_link_speed.attr,
+ 	&dev_attr_lpfc_fcp_io_sched.attr,
+ 	&dev_attr_lpfc_ns_query.attr,
+ 	&dev_attr_lpfc_fcp2_no_tgt_reset.attr,
+ 	&dev_attr_lpfc_cr_delay.attr,
+ 	&dev_attr_lpfc_cr_count.attr,
+ 	&dev_attr_lpfc_multi_ring_support.attr,
+ 	&dev_attr_lpfc_multi_ring_rctl.attr,
+ 	&dev_attr_lpfc_multi_ring_type.attr,
+ 	&dev_attr_lpfc_fdmi_on.attr,
+ 	&dev_attr_lpfc_enable_SmartSAN.attr,
+ 	&dev_attr_lpfc_max_luns.attr,
+ 	&dev_attr_lpfc_enable_npiv.attr,
+ 	&dev_attr_lpfc_fcf_failover_policy.attr,
+ 	&dev_attr_lpfc_enable_rrq.attr,
+ 	&dev_attr_lpfc_fcp_wait_abts_rsp.attr,
+ 	&dev_attr_nport_evt_cnt.attr,
+ 	&dev_attr_board_mode.attr,
+ 	&dev_attr_lpfc_xcvr_data.attr,
+ 	&dev_attr_max_vpi.attr,
+ 	&dev_attr_used_vpi.attr,
+ 	&dev_attr_max_rpi.attr,
+ 	&dev_attr_used_rpi.attr,
+ 	&dev_attr_max_xri.attr,
+ 	&dev_attr_used_xri.attr,
+ 	&dev_attr_npiv_info.attr,
+ 	&dev_attr_issue_reset.attr,
+ 	&dev_attr_lpfc_poll.attr,
+ 	&dev_attr_lpfc_poll_tmo.attr,
+ 	&dev_attr_lpfc_task_mgmt_tmo.attr,
+ 	&dev_attr_lpfc_use_msi.attr,
+ 	&dev_attr_lpfc_nvme_oas.attr,
+ 	&dev_attr_lpfc_nvme_embed_cmd.attr,
+ 	&dev_attr_lpfc_fcp_imax.attr,
+ 	&dev_attr_lpfc_force_rscn.attr,
+ 	&dev_attr_lpfc_cq_poll_threshold.attr,
+ 	&dev_attr_lpfc_cq_max_proc_limit.attr,
+ 	&dev_attr_lpfc_fcp_cpu_map.attr,
+ 	&dev_attr_lpfc_fcp_mq_threshold.attr,
+ 	&dev_attr_lpfc_hdw_queue.attr,
+ 	&dev_attr_lpfc_irq_chann.attr,
+ 	&dev_attr_lpfc_suppress_rsp.attr,
+ 	&dev_attr_lpfc_nvmet_mrq.attr,
+ 	&dev_attr_lpfc_nvmet_mrq_post.attr,
+ 	&dev_attr_lpfc_nvme_enable_fb.attr,
+ 	&dev_attr_lpfc_nvmet_fb_size.attr,
+ 	&dev_attr_lpfc_enable_bg.attr,
+ 	&dev_attr_lpfc_enable_hba_reset.attr,
+ 	&dev_attr_lpfc_enable_hba_heartbeat.attr,
+ 	&dev_attr_lpfc_EnableXLane.attr,
+ 	&dev_attr_lpfc_XLanePriority.attr,
+ 	&dev_attr_lpfc_xlane_lun.attr,
+ 	&dev_attr_lpfc_xlane_tgt.attr,
+ 	&dev_attr_lpfc_xlane_vpt.attr,
+ 	&dev_attr_lpfc_xlane_lun_state.attr,
+ 	&dev_attr_lpfc_xlane_lun_status.attr,
+ 	&dev_attr_lpfc_xlane_priority.attr,
+ 	&dev_attr_lpfc_sg_seg_cnt.attr,
+ 	&dev_attr_lpfc_max_scsicmpl_time.attr,
+ 	&dev_attr_lpfc_aer_support.attr,
+ 	&dev_attr_lpfc_aer_state_cleanup.attr,
+ 	&dev_attr_lpfc_sriov_nr_virtfn.attr,
+ 	&dev_attr_lpfc_req_fw_upgrade.attr,
+ 	&dev_attr_lpfc_suppress_link_up.attr,
+ 	&dev_attr_iocb_hw.attr,
+ 	&dev_attr_pls.attr,
+ 	&dev_attr_pt.attr,
+ 	&dev_attr_txq_hw.attr,
+ 	&dev_attr_txcmplq_hw.attr,
+ 	&dev_attr_lpfc_sriov_hw_max_virtfn.attr,
+ 	&dev_attr_protocol.attr,
+ 	&dev_attr_lpfc_xlane_supported.attr,
+ 	&dev_attr_lpfc_enable_mds_diags.attr,
+ 	&dev_attr_lpfc_ras_fwlog_buffsize.attr,
+ 	&dev_attr_lpfc_ras_fwlog_level.attr,
+ 	&dev_attr_lpfc_ras_fwlog_func.attr,
+ 	&dev_attr_lpfc_enable_bbcr.attr,
+ 	&dev_attr_lpfc_enable_dpp.attr,
+ 	&dev_attr_lpfc_enable_mi.attr,
+ 	&dev_attr_cmf_info.attr,
+ 	&dev_attr_lpfc_max_vmid.attr,
+ 	&dev_attr_lpfc_vmid_inactivity_timeout.attr,
+ 	&dev_attr_lpfc_vmid_app_header.attr,
+ 	&dev_attr_lpfc_vmid_priority_tagging.attr,
++>>>>>>> 479b0917e447 (scsi: lpfc: Create a sysfs entry called lpfc_xcvr_data for transceiver info)
  	NULL,
  };
  
* Unmerged path drivers/scsi/lpfc/lpfc_attr.c
diff --git a/drivers/scsi/lpfc/lpfc_crtn.h b/drivers/scsi/lpfc/lpfc_crtn.h
index f3efd979fbb5..39545cbdb266 100644
--- a/drivers/scsi/lpfc/lpfc_crtn.h
+++ b/drivers/scsi/lpfc/lpfc_crtn.h
@@ -666,3 +666,6 @@ int lpfc_issue_els_qfpa(struct lpfc_vport *vport);
 
 void lpfc_sli_rpi_release(struct lpfc_vport *vport,
 			  struct lpfc_nodelist *ndlp);
+
+int lpfc_get_sfp_info_wait(struct lpfc_hba *phba,
+			   struct lpfc_rdp_context *rdp_context);
diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c
index 45f7974bc4d8..a070af884df3 100644
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@ -6946,6 +6946,134 @@ lpfc_get_rdp_info(struct lpfc_hba *phba, struct lpfc_rdp_context *rdp_context)
 	return 1;
 }
 
+int lpfc_get_sfp_info_wait(struct lpfc_hba *phba,
+			   struct lpfc_rdp_context *rdp_context)
+{
+	LPFC_MBOXQ_t *mbox = NULL;
+	int rc;
+	struct lpfc_dmabuf *mp;
+	struct lpfc_dmabuf *mpsave;
+	void *virt;
+	MAILBOX_t *mb;
+
+	mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
+	if (!mbox) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_MBOX | LOG_ELS,
+				"7205 failed to allocate mailbox memory");
+		return 1;
+	}
+
+	if (lpfc_sli4_dump_page_a0(phba, mbox))
+		goto sfp_fail;
+	mp = mbox->ctx_buf;
+	mpsave = mp;
+	virt = mp->virt;
+	if (phba->sli_rev < LPFC_SLI_REV4) {
+		mb = &mbox->u.mb;
+		mb->un.varDmp.cv = 1;
+		mb->un.varDmp.co = 1;
+		mb->un.varWords[2] = 0;
+		mb->un.varWords[3] = DMP_SFF_PAGE_A0_SIZE / 4;
+		mb->un.varWords[4] = 0;
+		mb->un.varWords[5] = 0;
+		mb->un.varWords[6] = 0;
+		mb->un.varWords[7] = 0;
+		mb->un.varWords[8] = 0;
+		mb->un.varWords[9] = 0;
+		mb->un.varWords[10] = 0;
+		mbox->in_ext_byte_len = DMP_SFF_PAGE_A0_SIZE;
+		mbox->out_ext_byte_len = DMP_SFF_PAGE_A0_SIZE;
+		mbox->mbox_offset_word = 5;
+		mbox->ctx_buf = virt;
+	} else {
+		bf_set(lpfc_mbx_memory_dump_type3_length,
+		       &mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A0_SIZE);
+		mbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);
+		mbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);
+	}
+	mbox->vport = phba->pport;
+	mbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;
+
+	rc = lpfc_sli_issue_mbox_wait(phba, mbox, 30);
+	if (rc == MBX_NOT_FINISHED) {
+		rc = 1;
+		goto error;
+	}
+
+	if (phba->sli_rev == LPFC_SLI_REV4)
+		mp = (struct lpfc_dmabuf *)(mbox->ctx_buf);
+	else
+		mp = mpsave;
+
+	if (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {
+		rc = 1;
+		goto error;
+	}
+
+	lpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a0,
+			     DMP_SFF_PAGE_A0_SIZE);
+
+	memset(mbox, 0, sizeof(*mbox));
+	memset(mp->virt, 0, DMP_SFF_PAGE_A2_SIZE);
+	INIT_LIST_HEAD(&mp->list);
+
+	/* save address for completion */
+	mbox->ctx_buf = mp;
+	mbox->vport = phba->pport;
+
+	bf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_DUMP_MEMORY);
+	bf_set(lpfc_mbx_memory_dump_type3_type,
+	       &mbox->u.mqe.un.mem_dump_type3, DMP_LMSD);
+	bf_set(lpfc_mbx_memory_dump_type3_link,
+	       &mbox->u.mqe.un.mem_dump_type3, phba->sli4_hba.physical_port);
+	bf_set(lpfc_mbx_memory_dump_type3_page_no,
+	       &mbox->u.mqe.un.mem_dump_type3, DMP_PAGE_A2);
+	if (phba->sli_rev < LPFC_SLI_REV4) {
+		mb = &mbox->u.mb;
+		mb->un.varDmp.cv = 1;
+		mb->un.varDmp.co = 1;
+		mb->un.varWords[2] = 0;
+		mb->un.varWords[3] = DMP_SFF_PAGE_A2_SIZE / 4;
+		mb->un.varWords[4] = 0;
+		mb->un.varWords[5] = 0;
+		mb->un.varWords[6] = 0;
+		mb->un.varWords[7] = 0;
+		mb->un.varWords[8] = 0;
+		mb->un.varWords[9] = 0;
+		mb->un.varWords[10] = 0;
+		mbox->in_ext_byte_len = DMP_SFF_PAGE_A2_SIZE;
+		mbox->out_ext_byte_len = DMP_SFF_PAGE_A2_SIZE;
+		mbox->mbox_offset_word = 5;
+		mbox->ctx_buf = virt;
+	} else {
+		bf_set(lpfc_mbx_memory_dump_type3_length,
+		       &mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A2_SIZE);
+		mbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);
+		mbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);
+	}
+
+	mbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;
+	rc = lpfc_sli_issue_mbox_wait(phba, mbox, 30);
+	if (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {
+		rc = 1;
+		goto error;
+	}
+	rc = 0;
+
+	lpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a2,
+			     DMP_SFF_PAGE_A2_SIZE);
+
+error:
+	mbox->ctx_buf = mpsave;
+	lpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);
+
+	return rc;
+
+sfp_fail:
+	mempool_free(mbox, phba->mbox_mem_pool);
+	return 1;
+}
+
 /*
  * lpfc_els_rcv_rdp - Process an unsolicited RDP ELS.
  * @vport: pointer to a host virtual N_Port data structure.
diff --git a/drivers/scsi/lpfc/lpfc_hw4.h b/drivers/scsi/lpfc/lpfc_hw4.h
index 6595df8e6063..1a94d3b88a53 100644
--- a/drivers/scsi/lpfc/lpfc_hw4.h
+++ b/drivers/scsi/lpfc/lpfc_hw4.h
@@ -3126,7 +3126,8 @@ struct lpfc_mbx_memory_dump_type3 {
 #define SFF_LENGTH_COPPER		18
 #define SSF_LENGTH_50UM_OM3		19
 #define SSF_VENDOR_NAME			20
-#define SSF_VENDOR_OUI			36
+#define SSF_TRANSCEIVER2		36
+#define SSF_VENDOR_OUI			37
 #define SSF_VENDOR_PN			40
 #define SSF_VENDOR_REV			56
 #define SSF_WAVELENGTH_B1		60
@@ -3245,7 +3246,7 @@ struct sff_trasnceiver_codes_byte6 {
 
 struct sff_trasnceiver_codes_byte7 {
 	uint8_t fc_sp_100MB:1;   /*  100 MB/sec */
-	uint8_t reserve:1;
+	uint8_t speed_chk_ecc:1;
 	uint8_t fc_sp_200mb:1;   /*  200 MB/sec */
 	uint8_t fc_sp_3200MB:1;  /* 3200 MB/sec */
 	uint8_t fc_sp_400MB:1;   /*  400 MB/sec */
