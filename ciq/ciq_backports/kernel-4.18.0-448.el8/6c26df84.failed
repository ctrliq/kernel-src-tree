selftests: cgroup: return -errno from cg_read()/cg_write() on failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Yosry Ahmed <yosryahmed@google.com>
commit 6c26df84e1f2f9181c0741865105a53537da842c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6c26df84.failed

Currently, cg_read()/cg_write() returns 0 on success and -1 on failure.
Modify them to return the -errno on failure.

Link: https://lkml.kernel.org/r/20220425190040.2475377-3-yosryahmed@google.com
	Signed-off-by: Yosry Ahmed <yosryahmed@google.com>
	Acked-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Acked-by: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Chen Wandun <chenwandun@huawei.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Greg Thelen <gthelen@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: "Michal Koutn" <mkoutny@suse.com>
	Cc: Shuah Khan <shuah@kernel.org>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Vaibhav Jain <vaibhav@linux.ibm.com>
	Cc: Wei Xu <weixugc@google.com>
	Cc: Yu Zhao <yuzhao@google.com>
	Cc: Zefan Li <lizefan.x@bytedance.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 6c26df84e1f2f9181c0741865105a53537da842c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/cgroup/cgroup_util.c
diff --cc tools/testing/selftests/cgroup/cgroup_util.c
index 4cb8e4717357,e6f3679cdcc0..000000000000
--- a/tools/testing/selftests/cgroup/cgroup_util.c
+++ b/tools/testing/selftests/cgroup/cgroup_util.c
@@@ -15,7 -17,9 +15,8 @@@
  #include <unistd.h>
  
  #include "cgroup_util.h"
 -#include "../clone3/clone3_selftests.h"
  
+ /* Returns read len on success, or -errno on failure. */
  static ssize_t read_text(const char *path, char *buf, size_t max_len)
  {
  	ssize_t len;
@@@ -74,6 -72,17 +69,20 @@@ char *cg_name_indexed(const char *root
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ char *cg_control(const char *cgroup, const char *control)
+ {
+ 	size_t len = strlen(cgroup) + strlen(control) + 2;
+ 	char *ret = malloc(len);
+ 
+ 	snprintf(ret, len, "%s/%s", cgroup, control);
+ 
+ 	return ret;
+ }
+ 
+ /* Returns 0 on success, or -errno on failure. */
++>>>>>>> 6c26df84e1f2 (selftests: cgroup: return -errno from cg_read()/cg_write() on failure)
  int cg_read(const char *cgroup, const char *control, char *buf, size_t len)
  {
  	char path[PATH_MAX];
@@@ -148,6 -156,23 +156,26 @@@ long cg_read_key_long(const char *cgrou
  	return atol(ptr + strlen(key));
  }
  
++<<<<<<< HEAD
++=======
+ long cg_read_lc(const char *cgroup, const char *control)
+ {
+ 	char buf[PAGE_SIZE];
+ 	const char delim[] = "\n";
+ 	char *line;
+ 	long cnt = 0;
+ 
+ 	if (cg_read(cgroup, control, buf, sizeof(buf)))
+ 		return -1;
+ 
+ 	for (line = strtok(buf, delim); line; line = strtok(NULL, delim))
+ 		cnt++;
+ 
+ 	return cnt;
+ }
+ 
+ /* Returns 0 on success, or -errno on failure. */
++>>>>>>> 6c26df84e1f2 (selftests: cgroup: return -errno from cg_read()/cg_write() on failure)
  int cg_write(const char *cgroup, const char *control, char *buf)
  {
  	char path[PATH_MAX];
@@@ -358,3 -527,106 +383,109 @@@ int set_oom_adj_score(int pid, int scor
  	close(fd);
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ ssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size)
+ {
+ 	char path[PATH_MAX];
+ 
+ 	if (!pid)
+ 		snprintf(path, sizeof(path), "/proc/%s/%s",
+ 			 thread ? "thread-self" : "self", item);
+ 	else
+ 		snprintf(path, sizeof(path), "/proc/%d/%s", pid, item);
+ 
+ 	size = read_text(path, buf, size);
+ 	return size < 0 ? -1 : size;
+ }
+ 
+ int proc_read_strstr(int pid, bool thread, const char *item, const char *needle)
+ {
+ 	char buf[PAGE_SIZE];
+ 
+ 	if (proc_read_text(pid, thread, item, buf, sizeof(buf)) < 0)
+ 		return -1;
+ 
+ 	return strstr(buf, needle) ? 0 : -1;
+ }
+ 
+ int clone_into_cgroup_run_wait(const char *cgroup)
+ {
+ 	int cgroup_fd;
+ 	pid_t pid;
+ 
+ 	cgroup_fd =  dirfd_open_opath(cgroup);
+ 	if (cgroup_fd < 0)
+ 		return -1;
+ 
+ 	pid = clone_into_cgroup(cgroup_fd);
+ 	close_prot_errno(cgroup_fd);
+ 	if (pid < 0)
+ 		return -1;
+ 
+ 	if (pid == 0)
+ 		exit(EXIT_SUCCESS);
+ 
+ 	/*
+ 	 * We don't care whether this fails. We only care whether the initial
+ 	 * clone succeeded.
+ 	 */
+ 	(void)clone_reap(pid, WEXITED);
+ 	return 0;
+ }
+ 
+ static int __prepare_for_wait(const char *cgroup, const char *filename)
+ {
+ 	int fd, ret = -1;
+ 
+ 	fd = inotify_init1(0);
+ 	if (fd == -1)
+ 		return fd;
+ 
+ 	ret = inotify_add_watch(fd, cg_control(cgroup, filename), IN_MODIFY);
+ 	if (ret == -1) {
+ 		close(fd);
+ 		fd = -1;
+ 	}
+ 
+ 	return fd;
+ }
+ 
+ int cg_prepare_for_wait(const char *cgroup)
+ {
+ 	return __prepare_for_wait(cgroup, "cgroup.events");
+ }
+ 
+ int memcg_prepare_for_wait(const char *cgroup)
+ {
+ 	return __prepare_for_wait(cgroup, "memory.events");
+ }
+ 
+ int cg_wait_for(int fd)
+ {
+ 	int ret = -1;
+ 	struct pollfd fds = {
+ 		.fd = fd,
+ 		.events = POLLIN,
+ 	};
+ 
+ 	while (true) {
+ 		ret = poll(&fds, 1, 10000);
+ 
+ 		if (ret == -1) {
+ 			if (errno == EINTR)
+ 				continue;
+ 
+ 			break;
+ 		}
+ 
+ 		if (ret > 0 && fds.revents & POLLIN) {
+ 			ret = 0;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
++>>>>>>> 6c26df84e1f2 (selftests: cgroup: return -errno from cg_read()/cg_write() on failure)
* Unmerged path tools/testing/selftests/cgroup/cgroup_util.c
