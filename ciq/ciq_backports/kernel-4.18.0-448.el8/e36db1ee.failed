net/mlx5e: Add pedit to tc action infra

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit e36db1ee7a88f415f5fcd95158fbbbf0cae63532
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/e36db1ee.failed

Add parsing support by implementing struct mlx5e_tc_act
for this action.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit e36db1ee7a88f415f5fcd95158fbbbf0cae63532)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 478a0ab6470d,47513edd2c86..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -46,6 -46,11 +46,14 @@@ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     +
  					en/tc_tun_vxlan.o en/tc_tun_gre.o en/tc_tun_geneve.o \
  					en/tc_tun_mplsoudp.o diag/en_tc_tracepoint.o \
  					en/tc/post_act.o en/tc/int_port.o
++<<<<<<< HEAD
++=======
+ 
+ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     += en/tc/act/act.o en/tc/act/drop.o en/tc/act/trap.o \
+ 					en/tc/act/accept.o en/tc/act/mark.o en/tc/act/goto.o \
+ 					en/tc/act/tun.o en/tc/act/csum.o en/tc/act/pedit.o
+ 
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  mlx5_core-$(CONFIG_MLX5_TC_CT)	     += en/tc_ct.o
  mlx5_core-$(CONFIG_MLX5_TC_SAMPLE)   += en/tc/sample.o
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index abcf89c03680,0bea8c90cd77..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -40,8 -40,6 +40,11 @@@
  #include <linux/refcount.h>
  #include <linux/completion.h>
  #include <linux/if_macvlan.h>
++<<<<<<< HEAD
 +#include <net/tc_act/tc_pedit.h>
 +#include <net/tc_act/tc_csum.h>
++=======
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  #include <net/psample.h>
  #include <net/arp.h>
  #include <net/ipv6_stubs.h>
@@@ -62,6 -60,8 +65,11 @@@
  #include "en/mod_hdr.h"
  #include "en/tc_tun_encap.h"
  #include "en/tc/sample.h"
++<<<<<<< HEAD
++=======
+ #include "en/tc/act/act.h"
+ #include "en/tc/act/pedit.h"
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  #include "lib/devcom.h"
  #include "lib/geneve.h"
  #include "lib/fs_chains.h"
@@@ -3478,42 -3258,28 +3356,59 @@@ parse_tc_nic_actions(struct mlx5e_priv 
  		     struct mlx5e_tc_flow *flow,
  		     struct netlink_ext_ack *extack)
  {
 -	struct mlx5e_tc_act_parse_state *parse_state;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
  	struct mlx5_flow_attr *attr = flow->attr;
++<<<<<<< HEAD
 +	struct pedit_headers_action hdrs[2] = {};
 +	const struct flow_action_entry *act;
 +	struct mlx5_nic_flow_attr *nic_attr;
 +	bool clear_action;
 +	u32 action = 0;
++=======
+ 	enum mlx5_flow_namespace_type ns_type;
+ 	const struct flow_action_entry *act;
+ 	struct pedit_headers_action *hdrs;
+ 	struct mlx5e_tc_act *tc_act;
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  	int err, i;
  
  	err = flow_action_supported(flow_action, extack);
  	if (err)
  		return err;
  
 -	attr->nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
 +	nic_attr = attr->nic_attr;
 +	nic_attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
  	parse_attr = attr->parse_attr;
++<<<<<<< HEAD
 +
 +	flow_action_for_each(i, act, flow_action) {
 +		switch (act->id) {
 +		case FLOW_ACTION_ACCEPT:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_KERNEL,
 +						    parse_attr, hdrs, NULL, extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +			break;
++=======
+ 	parse_state = &parse_attr->parse_state;
+ 	mlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);
+ 	ns_type = mlx5e_get_flow_namespace(flow);
+ 	hdrs = parse_state->hdrs;
+ 
+ 	flow_action_for_each(i, act, flow_action) {
+ 		switch (act->id) {
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  		case FLOW_ACTION_VLAN_MANGLE:
  			err = add_vlan_rewrite_action(priv,
  						      MLX5_FLOW_NAMESPACE_KERNEL,
@@@ -3897,8 -3638,8 +3792,7 @@@ static int parse_tc_fdb_actions(struct 
  				struct mlx5e_tc_flow *flow,
  				struct netlink_ext_ack *extack)
  {
- 	struct pedit_headers_action hdrs[2] = {};
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct mlx5e_tc_act_parse_state *parse_state;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	struct mlx5e_sample_attr sample_attr = {};
@@@ -3906,10 -3646,11 +3800,15 @@@
  	struct mlx5_flow_attr *attr = flow->attr;
  	int ifindexes[MLX5_MAX_FLOW_FWD_VPORTS];
  	bool ft_flow = mlx5e_is_ft_flow(flow);
 -	enum mlx5_flow_namespace_type ns_type;
  	const struct flow_action_entry *act;
  	struct mlx5_esw_flow_attr *esw_attr;
++<<<<<<< HEAD
 +	bool encap = false, decap = false;
 +	u32 action = attr->action;
++=======
+ 	struct pedit_headers_action *hdrs;
+ 	struct mlx5e_tc_act *tc_act;
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  	int err, i, if_count = 0;
  	bool ptype_host = false;
  	bool mpls_push = false;
@@@ -3921,6 -3661,10 +3820,13 @@@
  
  	esw_attr = attr->esw_attr;
  	parse_attr = attr->parse_attr;
++<<<<<<< HEAD
++=======
+ 	parse_state = &parse_attr->parse_state;
+ 	mlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);
+ 	ns_type = mlx5e_get_flow_namespace(flow);
+ 	hdrs = parse_state->hdrs;
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  
  	flow_action_for_each(i, act, flow_action) {
  		switch (act->id) {
@@@ -3975,27 -3705,9 +3881,30 @@@
  			}
  
  			parse_attr->eth.h_proto = act->mpls_pop.proto;
 -			attr->action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
  			flow_flag_set(flow, L3_TO_L2_DECAP);
  			break;
++<<<<<<< HEAD
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_FDB,
 +						    parse_attr, hdrs, flow, extack);
 +			if (err)
 +				return err;
 +
 +			if (!flow_flag_test(flow, L3_TO_L2_DECAP)) {
 +				action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +				esw_attr->split_count = esw_attr->out_count;
 +			}
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags, extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
++=======
++>>>>>>> e36db1ee7a88 (net/mlx5e: Add pedit to tc action infra)
  		case FLOW_ACTION_REDIRECT_INGRESS: {
  			struct net_device *out_dev;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
new file mode 100644
index 000000000000..79addbbef087
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
@@ -0,0 +1,165 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+#include <linux/if_vlan.h>
+#include "act.h"
+#include "pedit.h"
+#include "en/tc_priv.h"
+#include "en/mod_hdr.h"
+
+static int pedit_header_offsets[] = {
+	[FLOW_ACT_MANGLE_HDR_TYPE_ETH] = offsetof(struct pedit_headers, eth),
+	[FLOW_ACT_MANGLE_HDR_TYPE_IP4] = offsetof(struct pedit_headers, ip4),
+	[FLOW_ACT_MANGLE_HDR_TYPE_IP6] = offsetof(struct pedit_headers, ip6),
+	[FLOW_ACT_MANGLE_HDR_TYPE_TCP] = offsetof(struct pedit_headers, tcp),
+	[FLOW_ACT_MANGLE_HDR_TYPE_UDP] = offsetof(struct pedit_headers, udp),
+};
+
+#define pedit_header(_ph, _htype) ((void *)(_ph) + pedit_header_offsets[_htype])
+
+static int
+set_pedit_val(u8 hdr_type, u32 mask, u32 val, u32 offset,
+	      struct pedit_headers_action *hdrs,
+	      struct netlink_ext_ack *extack)
+{
+	u32 *curr_pmask, *curr_pval;
+
+	curr_pmask = (u32 *)(pedit_header(&hdrs->masks, hdr_type) + offset);
+	curr_pval  = (u32 *)(pedit_header(&hdrs->vals, hdr_type) + offset);
+
+	if (*curr_pmask & mask) { /* disallow acting twice on the same location */
+		NL_SET_ERR_MSG_MOD(extack,
+				   "curr_pmask and new mask same. Acting twice on same location");
+		goto out_err;
+	}
+
+	*curr_pmask |= mask;
+	*curr_pval  |= (val & mask);
+
+	return 0;
+
+out_err:
+	return -EOPNOTSUPP;
+}
+
+static int
+parse_pedit_to_modify_hdr(struct mlx5e_priv *priv,
+			  const struct flow_action_entry *act, int namespace,
+			  struct mlx5e_tc_flow_parse_attr *parse_attr,
+			  struct pedit_headers_action *hdrs,
+			  struct netlink_ext_ack *extack)
+{
+	u8 cmd = (act->id == FLOW_ACTION_MANGLE) ? 0 : 1;
+	u8 htype = act->mangle.htype;
+	int err = -EOPNOTSUPP;
+	u32 mask, val, offset;
+
+	if (htype == FLOW_ACT_MANGLE_UNSPEC) {
+		NL_SET_ERR_MSG_MOD(extack, "legacy pedit isn't offloaded");
+		goto out_err;
+	}
+
+	if (!mlx5e_mod_hdr_max_actions(priv->mdev, namespace)) {
+		NL_SET_ERR_MSG_MOD(extack, "The pedit offload action is not supported");
+		goto out_err;
+	}
+
+	mask = act->mangle.mask;
+	val = act->mangle.val;
+	offset = act->mangle.offset;
+
+	err = set_pedit_val(htype, ~mask, val, offset, &hdrs[cmd], extack);
+	if (err)
+		goto out_err;
+
+	hdrs[cmd].pedits++;
+
+	return 0;
+out_err:
+	return err;
+}
+
+static int
+parse_pedit_to_reformat(const struct flow_action_entry *act,
+			struct mlx5e_tc_flow_parse_attr *parse_attr,
+			struct netlink_ext_ack *extack)
+{
+	u32 mask, val, offset;
+	u32 *p;
+
+	if (act->id != FLOW_ACTION_MANGLE) {
+		NL_SET_ERR_MSG_MOD(extack, "Unsupported action id");
+		return -EOPNOTSUPP;
+	}
+
+	if (act->mangle.htype != FLOW_ACT_MANGLE_HDR_TYPE_ETH) {
+		NL_SET_ERR_MSG_MOD(extack, "Only Ethernet modification is supported");
+		return -EOPNOTSUPP;
+	}
+
+	mask = ~act->mangle.mask;
+	val = act->mangle.val;
+	offset = act->mangle.offset;
+	p = (u32 *)&parse_attr->eth;
+	*(p + (offset >> 2)) |= (val & mask);
+
+	return 0;
+}
+
+int
+mlx5e_tc_act_pedit_parse_action(struct mlx5e_priv *priv,
+				const struct flow_action_entry *act, int namespace,
+				struct mlx5e_tc_flow_parse_attr *parse_attr,
+				struct pedit_headers_action *hdrs,
+				struct mlx5e_tc_flow *flow,
+				struct netlink_ext_ack *extack)
+{
+	if (flow && flow_flag_test(flow, L3_TO_L2_DECAP))
+		return parse_pedit_to_reformat(act, parse_attr, extack);
+
+	return parse_pedit_to_modify_hdr(priv, act, namespace, parse_attr, hdrs, extack);
+}
+
+static bool
+tc_act_can_offload_pedit(struct mlx5e_tc_act_parse_state *parse_state,
+			 const struct flow_action_entry *act,
+			 int act_index)
+{
+	return true;
+}
+
+static int
+tc_act_parse_pedit(struct mlx5e_tc_act_parse_state *parse_state,
+		   const struct flow_action_entry *act,
+		   struct mlx5e_priv *priv,
+		   struct mlx5_flow_attr *attr)
+{
+	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
+	struct mlx5e_tc_flow *flow = parse_state->flow;
+	enum mlx5_flow_namespace_type ns_type;
+	int err;
+
+	ns_type = mlx5e_get_flow_namespace(flow);
+
+	err = mlx5e_tc_act_pedit_parse_action(flow->priv, act, ns_type,
+					      attr->parse_attr, parse_state->hdrs,
+					      flow, parse_state->extack);
+	if (err)
+		return err;
+
+	if (flow_flag_test(flow, L3_TO_L2_DECAP))
+		goto out;
+
+	attr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+
+	if (ns_type == MLX5_FLOW_NAMESPACE_FDB)
+		esw_attr->split_count = esw_attr->out_count;
+
+out:
+	return 0;
+}
+
+struct mlx5e_tc_act mlx5e_tc_act_pedit = {
+	.can_offload = tc_act_can_offload_pedit,
+	.parse_action = tc_act_parse_pedit,
+};
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.h
new file mode 100644
index 000000000000..da8ab03af58f
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved. */
+
+#ifndef __MLX5_EN_TC_ACT_PEDIT_H__
+#define __MLX5_EN_TC_ACT_PEDIT_H__
+
+#include "en_tc.h"
+
+struct pedit_headers {
+	struct ethhdr   eth;
+	struct vlan_hdr vlan;
+	struct iphdr    ip4;
+	struct ipv6hdr  ip6;
+	struct tcphdr   tcp;
+	struct udphdr   udp;
+};
+
+struct pedit_headers_action {
+	struct pedit_headers vals;
+	struct pedit_headers masks;
+	u32 pedits;
+};
+
+int
+mlx5e_tc_act_pedit_parse_action(struct mlx5e_priv *priv,
+				const struct flow_action_entry *act, int namespace,
+				struct mlx5e_tc_flow_parse_attr *parse_attr,
+				struct pedit_headers_action *hdrs,
+				struct mlx5e_tc_flow *flow,
+				struct netlink_ext_ack *extack);
+
+#endif /* __MLX5_EN_TC_ACT_PEDIT_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
index b689701ac7d8..8f6a68d3a565 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
@@ -116,6 +116,7 @@ mlx5e_tc_offload_fdb_rules(struct mlx5_eswitch *esw,
 			   struct mlx5_flow_attr *attr);
 
 bool mlx5e_is_offloaded_flow(struct mlx5e_tc_flow *flow);
+int mlx5e_get_flow_namespace(struct mlx5e_tc_flow *flow);
 
 static inline void __flow_flag_set(struct mlx5e_tc_flow *flow, unsigned long flag)
 {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
