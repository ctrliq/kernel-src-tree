KVM: selftests: Use getcpu() instead of sched_getcpu() in rseq_test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Gavin Shan <gshan@redhat.com>
commit 0fcc102923dee97bf33bd199d5b26a6735e16097
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0fcc1029.failed

sched_getcpu() is glibc dependent and it can simply return the CPU
ID from the registered rseq information, as Florian Weimer pointed.
In this case, it's pointless to compare the return value from
sched_getcpu() and that fetched from the registered rseq information.

Fix the issue by replacing sched_getcpu() with getcpu(), as Florian
suggested. The comments are modified accordingly by replacing
"sched_getcpu()" with "getcpu()".

	Reported-by: Yihuang Yu <yihyu@redhat.com>
	Suggested-by: Florian Weimer <fweimer@redhat.com>
	Suggested-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Suggested-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Gavin Shan <gshan@redhat.com>
Message-Id: <20220810104114.6838-3-gshan@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0fcc102923dee97bf33bd199d5b26a6735e16097)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/rseq_test.c
diff --cc tools/testing/selftests/kvm/rseq_test.c
index d7a7e760adc8,fac248a43666..000000000000
--- a/tools/testing/selftests/kvm/rseq_test.c
+++ b/tools/testing/selftests/kvm/rseq_test.c
@@@ -51,12 -41,16 +51,25 @@@ static void guest_code(void
  		GUEST_SYNC(0);
  }
  
++<<<<<<< HEAD
 +static void sys_rseq(int flags)
 +{
 +	int r;
 +
 +	r = syscall(__NR_rseq, &__rseq, sizeof(__rseq), flags, RSEQ_SIG);
 +	TEST_ASSERT(!r, "rseq failed, errno = %d (%s)", errno, strerror(errno));
++=======
+ /*
+  * We have to perform direct system call for getcpu() because it's
+  * not available until glic 2.29.
+  */
+ static void sys_getcpu(unsigned *cpu)
+ {
+ 	int r;
+ 
+ 	r = syscall(__NR_getcpu, cpu, NULL, NULL);
+ 	TEST_ASSERT(!r, "getcpu failed, errno = %d (%s)", errno, strerror(errno));
++>>>>>>> 0fcc102923de (KVM: selftests: Use getcpu() instead of sched_getcpu() in rseq_test)
  }
  
  static int next_cpu(int cpu)
@@@ -254,13 -248,13 +267,18 @@@ int main(int argc, char *argv[]
  			snapshot = atomic_read(&seq_cnt) & ~1;
  
  			/*
- 			 * Ensure reading sched_getcpu() and rseq.cpu_id
- 			 * complete in a single "no migration" window, i.e. are
- 			 * not reordered across the seq_cnt reads.
+ 			 * Ensure calling getcpu() and reading rseq.cpu_id complete
+ 			 * in a single "no migration" window, i.e. are not reordered
+ 			 * across the seq_cnt reads.
  			 */
  			smp_rmb();
++<<<<<<< HEAD
 +			cpu = sched_getcpu();
 +			rseq_cpu = READ_ONCE(__rseq.cpu_id);
++=======
+ 			sys_getcpu(&cpu);
+ 			rseq_cpu = rseq_current_cpu_raw();
++>>>>>>> 0fcc102923de (KVM: selftests: Use getcpu() instead of sched_getcpu() in rseq_test)
  			smp_rmb();
  		} while (snapshot != atomic_read(&seq_cnt));
  
* Unmerged path tools/testing/selftests/kvm/rseq_test.c
