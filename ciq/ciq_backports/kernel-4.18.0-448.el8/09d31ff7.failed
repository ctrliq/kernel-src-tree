s390/vfio-ap: hot plug/unplug of AP devices when probed/removed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 09d31ff78793ff007ec3b0a26000fcf29ad4928b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/09d31ff7.failed

When an AP queue device is probed or removed, if the mediated device is
attached to a KVM guest, the mediated device's adapter, domain and
control domain bitmaps must be filtered to update the guest's APCB and if
any changes are detected, the guest's APCB must then be hot plugged into
the guest to reflect those changes to the guest.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit 09d31ff78793ff007ec3b0a26000fcf29ad4928b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,8346ad4f1942..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -1383,4 -1764,71 +1383,74 @@@ int vfio_ap_mdev_register(void
  void vfio_ap_mdev_unregister(void)
  {
  	mdev_unregister_device(&matrix_dev->device);
++<<<<<<< HEAD
++=======
+ 	mdev_unregister_driver(&vfio_ap_matrix_driver);
+ }
+ 
+ int vfio_ap_mdev_probe_queue(struct ap_device *apdev)
+ {
+ 	int ret;
+ 	struct vfio_ap_queue *q;
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 
+ 	ret = sysfs_create_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	if (ret)
+ 		return ret;
+ 
+ 	q = kzalloc(sizeof(*q), GFP_KERNEL);
+ 	if (!q)
+ 		return -ENOMEM;
+ 
+ 	q->apqn = to_ap_queue(&apdev->device)->qid;
+ 	q->saved_isc = VFIO_AP_ISC_INVALID;
+ 	matrix_mdev = get_update_locks_by_apqn(q->apqn);
+ 
+ 	if (matrix_mdev) {
+ 		vfio_ap_mdev_link_queue(matrix_mdev, q);
+ 
+ 		if (vfio_ap_mdev_filter_matrix(matrix_mdev->matrix.apm,
+ 					       matrix_mdev->matrix.aqm,
+ 					       matrix_mdev))
+ 			vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 	}
+ 	dev_set_drvdata(&apdev->device, q);
+ 	release_update_locks_for_mdev(matrix_mdev);
+ 
+ 	return 0;
+ }
+ 
+ void vfio_ap_mdev_remove_queue(struct ap_device *apdev)
+ {
+ 	unsigned long apid, apqi;
+ 	struct vfio_ap_queue *q;
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 
+ 	sysfs_remove_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	q = dev_get_drvdata(&apdev->device);
+ 	get_update_locks_for_queue(q);
+ 	matrix_mdev = q->matrix_mdev;
+ 
+ 	if (matrix_mdev) {
+ 		vfio_ap_unlink_queue_fr_mdev(q);
+ 
+ 		apid = AP_QID_CARD(q->apqn);
+ 		apqi = AP_QID_QUEUE(q->apqn);
+ 
+ 		/*
+ 		 * If the queue is assigned to the guest's APCB, then remove
+ 		 * the adapter's APID from the APCB and hot it into the guest.
+ 		 */
+ 		if (test_bit_inv(apid, matrix_mdev->shadow_apcb.apm) &&
+ 		    test_bit_inv(apqi, matrix_mdev->shadow_apcb.aqm)) {
+ 			clear_bit_inv(apid, matrix_mdev->shadow_apcb.apm);
+ 			vfio_ap_mdev_update_guest_apcb(matrix_mdev);
+ 		}
+ 	}
+ 
+ 	vfio_ap_mdev_reset_queue(q, 1);
+ 	dev_set_drvdata(&apdev->device, NULL);
+ 	kfree(q);
+ 	release_update_locks_for_mdev(matrix_mdev);
++>>>>>>> 09d31ff78793 (s390/vfio-ap: hot plug/unplug of AP devices when probed/removed)
  }
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
