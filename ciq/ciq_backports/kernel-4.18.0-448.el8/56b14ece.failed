netfilter: conntrack: re-fetch conntrack after insertion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Florian Westphal <fw@strlen.de>
commit 56b14ecec97f39118bf85c9ac2438c5a949509ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/56b14ece.failed

In case the conntrack is clashing, insertion can free skb->_nfct and
set skb->_nfct to the already-confirmed entry.

This wasn't found before because the conntrack entry and the extension
space used to free'd after an rcu grace period, plus the race needs
events enabled to trigger.

	Reported-by: <syzbot+793a590957d9c1b96620@syzkaller.appspotmail.com>
Fixes: 71d8c47fc653 ("netfilter: conntrack: introduce clash resolution on insertion race")
Fixes: 2ad9d7747c10 ("netfilter: conntrack: free extension area immediately")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 56b14ecec97f39118bf85c9ac2438c5a949509ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_core.h
diff --cc include/net/netfilter/nf_conntrack_core.h
index b781bf7fc142,37866c8386e2..000000000000
--- a/include/net/netfilter/nf_conntrack_core.h
+++ b/include/net/netfilter/nf_conntrack_core.h
@@@ -57,9 -58,14 +57,18 @@@ static inline int nf_conntrack_confirm(
  	int ret = NF_ACCEPT;
  
  	if (ct) {
- 		if (!nf_ct_is_confirmed(ct))
+ 		if (!nf_ct_is_confirmed(ct)) {
  			ret = __nf_conntrack_confirm(skb);
++<<<<<<< HEAD
 +		if (likely(ret == NF_ACCEPT))
++=======
+ 
+ 			if (ret == NF_ACCEPT)
+ 				ct = (struct nf_conn *)skb_nfct(skb);
+ 		}
+ 
+ 		if (ret == NF_ACCEPT && nf_ct_ecache_exist(ct))
++>>>>>>> 56b14ecec97f (netfilter: conntrack: re-fetch conntrack after insertion)
  			nf_ct_deliver_cached_events(ct);
  	}
  	return ret;
* Unmerged path include/net/netfilter/nf_conntrack_core.h
