wifi: mac80211: mlme: do IEEE80211_STA_RESET_SIGNAL_AVE per link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 42ed6748afa45fb3f540a5fd83595eee050c48fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/42ed6748.failed

Remove the IEEE80211_STA_RESET_SIGNAL_AVE flag and use
a bool instead, but invert the polarity (now calling it
tracking_signal_avg) so we don't have to initialize it,
and put that into the link instead.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 42ed6748afa45fb3f540a5fd83595eee050c48fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ieee80211_i.h
#	net/mac80211/mlme.c
diff --cc net/mac80211/ieee80211_i.h
index 9f2fe5f6d317,711129edd923..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -361,16 -361,21 +361,19 @@@ enum ieee80211_sta_flags 
  	IEEE80211_STA_MFP_ENABLED	= BIT(6),
  	IEEE80211_STA_UAPSD_ENABLED	= BIT(7),
  	IEEE80211_STA_NULLFUNC_ACKED	= BIT(8),
++<<<<<<< HEAD
 +	IEEE80211_STA_RESET_SIGNAL_AVE	= BIT(9),
 +	IEEE80211_STA_DISABLE_40MHZ	= BIT(10),
 +	IEEE80211_STA_DISABLE_VHT	= BIT(11),
 +	IEEE80211_STA_DISABLE_80P80MHZ	= BIT(12),
 +	IEEE80211_STA_DISABLE_160MHZ	= BIT(13),
++=======
++>>>>>>> 42ed6748afa4 (wifi: mac80211: mlme: do IEEE80211_STA_RESET_SIGNAL_AVE per link)
  	IEEE80211_STA_DISABLE_WMM	= BIT(14),
  	IEEE80211_STA_ENABLE_RRM	= BIT(15),
 -};
 -
 -typedef u32 __bitwise ieee80211_conn_flags_t;
 -
 -enum ieee80211_conn_flags {
 -	IEEE80211_CONN_DISABLE_HT	= (__force ieee80211_conn_flags_t)BIT(0),
 -	IEEE80211_CONN_DISABLE_40MHZ	= (__force ieee80211_conn_flags_t)BIT(1),
 -	IEEE80211_CONN_DISABLE_VHT	= (__force ieee80211_conn_flags_t)BIT(2),
 -	IEEE80211_CONN_DISABLE_80P80MHZ	= (__force ieee80211_conn_flags_t)BIT(3),
 -	IEEE80211_CONN_DISABLE_160MHZ	= (__force ieee80211_conn_flags_t)BIT(4),
 -	IEEE80211_CONN_DISABLE_HE	= (__force ieee80211_conn_flags_t)BIT(5),
 -	IEEE80211_CONN_DISABLE_EHT	= (__force ieee80211_conn_flags_t)BIT(6),
 -	IEEE80211_CONN_DISABLE_320MHZ	= (__force ieee80211_conn_flags_t)BIT(7),
 +	IEEE80211_STA_DISABLE_HE	= BIT(16),
 +	IEEE80211_STA_DISABLE_EHT	= BIT(17),
 +	IEEE80211_STA_DISABLE_320MHZ	= BIT(18),
  };
  
  struct ieee80211_mgd_auth_data {
@@@ -903,6 -872,108 +906,111 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	ieee80211_conn_flags_t conn_flags;
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool have_beacon;
+ 	bool tracking_signal_avg;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ 
+ 	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
+ 
+ 	struct ieee80211_bss_conf *conf;
+ };
+ 
++>>>>>>> 42ed6748afa4 (wifi: mac80211: mlme: do IEEE80211_STA_RESET_SIGNAL_AVE per link)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
diff --cc net/mac80211/mlme.c
index 6cd411ed25d6,8cd275c3be70..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -2513,19 -2520,21 +2511,24 @@@ static void ieee80211_set_disassoc(stru
  	sdata->vif.bss_conf.dtim_period = 0;
  	sdata->vif.bss_conf.beacon_rate = NULL;
  
++<<<<<<< HEAD
 +	ifmgd->have_beacon = false;
++=======
+ 	sdata->deflink.u.mgd.have_beacon = false;
+ 	sdata->deflink.u.mgd.tracking_signal_avg = false;
++>>>>>>> 42ed6748afa4 (wifi: mac80211: mlme: do IEEE80211_STA_RESET_SIGNAL_AVE per link)
  
  	ifmgd->flags = 0;
 -	sdata->deflink.u.mgd.conn_flags = 0;
  	mutex_lock(&local->mtx);
 -	ieee80211_link_release_channel(&sdata->deflink);
 +	ieee80211_vif_release_channel(sdata);
  
  	sdata->vif.bss_conf.csa_active = false;
 -	sdata->deflink.u.mgd.csa_waiting_bcn = false;
 -	sdata->deflink.u.mgd.csa_ignored_same_chan = false;
 -	if (sdata->deflink.csa_block_tx) {
 +	ifmgd->csa_waiting_bcn = false;
 +	ifmgd->csa_ignored_same_chan = false;
 +	if (sdata->csa_block_tx) {
  		ieee80211_wake_vif_queues(local, sdata,
  					  IEEE80211_QUEUE_STOP_REASON_CSA);
 -		sdata->deflink.csa_block_tx = false;
 +		sdata->csa_block_tx = false;
  	}
  	mutex_unlock(&local->mtx);
  
@@@ -4035,22 -4051,23 +4038,31 @@@ static void ieee80211_handle_beacon_sig
  {
  	/* Track average RSSI from the Beacon frames of the current AP */
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_RESET_SIGNAL_AVE) {
 +		ifmgd->flags &= ~IEEE80211_STA_RESET_SIGNAL_AVE;
 +		ewma_beacon_signal_init(&ifmgd->ave_beacon_signal);
 +		ifmgd->last_cqm_event_signal = 0;
 +		ifmgd->count_beacon_signal = 1;
 +		ifmgd->last_ave_beacon_signal = 0;
++=======
+ 	if (!sdata->deflink.u.mgd.tracking_signal_avg) {
+ 		sdata->deflink.u.mgd.tracking_signal_avg = true;
+ 		ewma_beacon_signal_init(&sdata->deflink.u.mgd.ave_beacon_signal);
+ 		sdata->deflink.u.mgd.last_cqm_event_signal = 0;
+ 		sdata->deflink.u.mgd.count_beacon_signal = 1;
+ 		sdata->deflink.u.mgd.last_ave_beacon_signal = 0;
++>>>>>>> 42ed6748afa4 (wifi: mac80211: mlme: do IEEE80211_STA_RESET_SIGNAL_AVE per link)
  	} else {
 -		sdata->deflink.u.mgd.count_beacon_signal++;
 +		ifmgd->count_beacon_signal++;
  	}
  
 -	ewma_beacon_signal_add(&sdata->deflink.u.mgd.ave_beacon_signal,
 -			       -rx_status->signal);
 +	ewma_beacon_signal_add(&ifmgd->ave_beacon_signal, -rx_status->signal);
  
  	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 -	    sdata->deflink.u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 -		int sig = -ewma_beacon_signal_read(&sdata->deflink.u.mgd.ave_beacon_signal);
 -		int last_sig = sdata->deflink.u.mgd.last_ave_beacon_signal;
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_sig = ifmgd->last_ave_beacon_signal;
  		struct ieee80211_event event = {
  			.type = RSSI_EVENT,
  		};
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/mlme.c
