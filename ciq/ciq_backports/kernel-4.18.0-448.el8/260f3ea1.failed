s390/vfio-ap: move probe and remove callbacks to vfio_ap_ops.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 260f3ea141382386e97611e7c2029bc013088ab1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/260f3ea1.failed

Let's move the probe and remove callbacks into the vfio_ap_ops.c
file to keep all code related to managing queues in a single file. This
way, all functions related to queue management can be removed from the
vfio_ap_private.h header file defining the public interfaces for the
vfio_ap device driver.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit 260f3ea141382386e97611e7c2029bc013088ab1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_drv.c
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_drv.c
index 9c7986bc5344,1ff6e3dbbffe..000000000000
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@@ -44,122 -43,9 +41,125 @@@ static struct ap_device_id ap_queue_ids
  	{ /* end of sibling */ },
  };
  
++<<<<<<< HEAD
 +MODULE_DEVICE_TABLE(vfio_ap, ap_queue_ids);
 +
 +static struct ap_matrix_mdev *vfio_ap_mdev_for_queue(struct vfio_ap_queue *q)
 +{
 +	struct ap_matrix_mdev *matrix_mdev;
 +	unsigned long apid = AP_QID_CARD(q->apqn);
 +	unsigned long apqi = AP_QID_QUEUE(q->apqn);
 +
 +	list_for_each_entry(matrix_mdev, &matrix_dev->mdev_list, node) {
 +		if (test_bit_inv(apid, matrix_mdev->matrix.apm) &&
 +		    test_bit_inv(apqi, matrix_mdev->matrix.aqm))
 +			return matrix_mdev;
 +	}
 +
 +	return NULL;
 +}
 +
 +static ssize_t status_show(struct device *dev,
 +			   struct device_attribute *attr,
 +			   char *buf)
 +{
 +	ssize_t nchars = 0;
 +	struct vfio_ap_queue *q;
 +	struct ap_matrix_mdev *matrix_mdev;
 +	struct ap_device *apdev = to_ap_dev(dev);
 +
 +	mutex_lock(&matrix_dev->lock);
 +	q = dev_get_drvdata(&apdev->device);
 +	matrix_mdev = vfio_ap_mdev_for_queue(q);
 +
 +	if (matrix_mdev) {
 +		if (matrix_mdev->kvm)
 +			nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
 +					   AP_QUEUE_IN_USE);
 +		else
 +			nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
 +					   AP_QUEUE_ASSIGNED);
 +	} else {
 +		nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
 +				   AP_QUEUE_UNASSIGNED);
 +	}
 +
 +	mutex_unlock(&matrix_dev->lock);
 +
 +	return nchars;
 +}
 +
 +static DEVICE_ATTR_RO(status);
 +
 +static struct attribute *vfio_queue_attrs[] = {
 +	&dev_attr_status.attr,
 +	NULL,
 +};
 +
 +static const struct attribute_group vfio_queue_attr_group = {
 +	.attrs = vfio_queue_attrs,
 +};
 +
 +/**
 + * vfio_ap_queue_dev_probe: Allocate a vfio_ap_queue structure and associate it
 + *			    with the device as driver_data.
 + *
 + * @apdev: the AP device being probed
 + *
 + * Return: returns 0 if the probe succeeded; otherwise, returns an error if
 + *	   storage could not be allocated for a vfio_ap_queue object or the
 + *	   sysfs 'status' attribute could not be created for the queue device.
 + */
 +static int vfio_ap_queue_dev_probe(struct ap_device *apdev)
 +{
 +	int ret;
 +	struct vfio_ap_queue *q;
 +
 +	q = kzalloc(sizeof(*q), GFP_KERNEL);
 +	if (!q)
 +		return -ENOMEM;
 +
 +	mutex_lock(&matrix_dev->lock);
 +	dev_set_drvdata(&apdev->device, q);
 +	q->apqn = to_ap_queue(&apdev->device)->qid;
 +	q->saved_isc = VFIO_AP_ISC_INVALID;
 +
 +	ret = sysfs_create_group(&apdev->device.kobj, &vfio_queue_attr_group);
 +	if (ret) {
 +		dev_set_drvdata(&apdev->device, NULL);
 +		kfree(q);
 +	}
 +
 +	mutex_unlock(&matrix_dev->lock);
 +
 +	return ret;
 +}
 +
 +/**
 + * vfio_ap_queue_dev_remove: Free the associated vfio_ap_queue structure.
 + *
 + * @apdev: the AP device being removed
 + *
 + * Takes the matrix lock to avoid actions on this device while doing the remove.
 + */
 +static void vfio_ap_queue_dev_remove(struct ap_device *apdev)
 +{
 +	struct vfio_ap_queue *q;
 +
 +	mutex_lock(&matrix_dev->lock);
 +	sysfs_remove_group(&apdev->device.kobj, &vfio_queue_attr_group);
 +	q = dev_get_drvdata(&apdev->device);
 +	vfio_ap_mdev_reset_queue(q, 1);
 +	dev_set_drvdata(&apdev->device, NULL);
 +	kfree(q);
 +	mutex_unlock(&matrix_dev->lock);
 +}
 +
++=======
++>>>>>>> 260f3ea14138 (s390/vfio-ap: move probe and remove callbacks to vfio_ap_ops.c)
  static struct ap_driver vfio_ap_drv = {
- 	.probe = vfio_ap_queue_dev_probe,
- 	.remove = vfio_ap_queue_dev_remove,
+ 	.probe = vfio_ap_mdev_probe_queue,
+ 	.remove = vfio_ap_mdev_remove_queue,
  	.ids = ap_queue_ids,
  };
  
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,32d276c85079..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -24,8 -26,13 +24,16 @@@
  #define VFIO_AP_MDEV_TYPE_HWVIRT "passthrough"
  #define VFIO_AP_MDEV_NAME_HWVIRT "VFIO AP Passthrough Device"
  
++<<<<<<< HEAD
 +static int vfio_ap_mdev_reset_queues(struct mdev_device *mdev);
++=======
+ #define AP_QUEUE_ASSIGNED "assigned"
+ #define AP_QUEUE_UNASSIGNED "unassigned"
+ #define AP_QUEUE_IN_USE "in use"
+ 
+ static int vfio_ap_mdev_reset_queues(struct ap_matrix_mdev *matrix_mdev);
++>>>>>>> 260f3ea14138 (s390/vfio-ap: move probe and remove callbacks to vfio_ap_ops.c)
  static struct vfio_ap_queue *vfio_ap_find_queue(int apqn);
 -static const struct vfio_device_ops vfio_ap_matrix_dev_ops;
  
  /**
   * vfio_ap_get_queue - retrieve a queue with a specific APQN from a list
@@@ -1362,15 -1456,78 +1370,90 @@@ static ssize_t vfio_ap_mdev_ioctl(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops vfio_ap_matrix_ops = {
 +	.owner			= THIS_MODULE,
 +	.supported_type_groups	= vfio_ap_mdev_type_groups,
 +	.mdev_attr_groups	= vfio_ap_mdev_attr_groups,
 +	.create			= vfio_ap_mdev_create,
 +	.remove			= vfio_ap_mdev_remove,
 +	.open			= vfio_ap_mdev_open,
 +	.release		= vfio_ap_mdev_release,
 +	.ioctl			= vfio_ap_mdev_ioctl,
++=======
+ static struct ap_matrix_mdev *vfio_ap_mdev_for_queue(struct vfio_ap_queue *q)
+ {
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 	unsigned long apid = AP_QID_CARD(q->apqn);
+ 	unsigned long apqi = AP_QID_QUEUE(q->apqn);
+ 
+ 	list_for_each_entry(matrix_mdev, &matrix_dev->mdev_list, node) {
+ 		if (test_bit_inv(apid, matrix_mdev->matrix.apm) &&
+ 		    test_bit_inv(apqi, matrix_mdev->matrix.aqm))
+ 			return matrix_mdev;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static ssize_t status_show(struct device *dev,
+ 			   struct device_attribute *attr,
+ 			   char *buf)
+ {
+ 	ssize_t nchars = 0;
+ 	struct vfio_ap_queue *q;
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 	struct ap_device *apdev = to_ap_dev(dev);
+ 
+ 	mutex_lock(&matrix_dev->lock);
+ 	q = dev_get_drvdata(&apdev->device);
+ 	matrix_mdev = vfio_ap_mdev_for_queue(q);
+ 
+ 	if (matrix_mdev) {
+ 		if (matrix_mdev->kvm)
+ 			nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
+ 					   AP_QUEUE_IN_USE);
+ 		else
+ 			nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
+ 					   AP_QUEUE_ASSIGNED);
+ 	} else {
+ 		nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
+ 				   AP_QUEUE_UNASSIGNED);
+ 	}
+ 
+ 	mutex_unlock(&matrix_dev->lock);
+ 
+ 	return nchars;
+ }
+ 
+ static DEVICE_ATTR_RO(status);
+ 
+ static struct attribute *vfio_queue_attrs[] = {
+ 	&dev_attr_status.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group vfio_queue_attr_group = {
+ 	.attrs = vfio_queue_attrs,
+ };
+ 
+ static const struct vfio_device_ops vfio_ap_matrix_dev_ops = {
+ 	.open_device = vfio_ap_mdev_open_device,
+ 	.close_device = vfio_ap_mdev_close_device,
+ 	.ioctl = vfio_ap_mdev_ioctl,
+ };
+ 
+ static struct mdev_driver vfio_ap_matrix_driver = {
+ 	.driver = {
+ 		.name = "vfio_ap_mdev",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 		.dev_groups = vfio_ap_mdev_attr_groups,
+ 	},
+ 	.probe = vfio_ap_mdev_probe,
+ 	.remove = vfio_ap_mdev_remove,
+ 	.supported_type_groups = vfio_ap_mdev_type_groups,
++>>>>>>> 260f3ea14138 (s390/vfio-ap: move probe and remove callbacks to vfio_ap_ops.c)
  };
  
  int vfio_ap_mdev_register(void)
@@@ -1383,4 -1553,40 +1466,39 @@@
  void vfio_ap_mdev_unregister(void)
  {
  	mdev_unregister_device(&matrix_dev->device);
 -	mdev_unregister_driver(&vfio_ap_matrix_driver);
  }
+ 
+ int vfio_ap_mdev_probe_queue(struct ap_device *apdev)
+ {
+ 	int ret;
+ 	struct vfio_ap_queue *q;
+ 
+ 	ret = sysfs_create_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	if (ret)
+ 		return ret;
+ 
+ 	q = kzalloc(sizeof(*q), GFP_KERNEL);
+ 	if (!q)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&matrix_dev->lock);
+ 	q->apqn = to_ap_queue(&apdev->device)->qid;
+ 	q->saved_isc = VFIO_AP_ISC_INVALID;
+ 	dev_set_drvdata(&apdev->device, q);
+ 	mutex_unlock(&matrix_dev->lock);
+ 
+ 	return 0;
+ }
+ 
+ void vfio_ap_mdev_remove_queue(struct ap_device *apdev)
+ {
+ 	struct vfio_ap_queue *q;
+ 
+ 	mutex_lock(&matrix_dev->lock);
+ 	sysfs_remove_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	q = dev_get_drvdata(&apdev->device);
+ 	vfio_ap_mdev_reset_queue(q, 1);
+ 	dev_set_drvdata(&apdev->device, NULL);
+ 	kfree(q);
+ 	mutex_unlock(&matrix_dev->lock);
+ }
* Unmerged path drivers/s390/crypto/vfio_ap_drv.c
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
diff --git a/drivers/s390/crypto/vfio_ap_private.h b/drivers/s390/crypto/vfio_ap_private.h
index 2b06b4ffd2fd..c1d66269bc70 100644
--- a/drivers/s390/crypto/vfio_ap_private.h
+++ b/drivers/s390/crypto/vfio_ap_private.h
@@ -117,7 +117,8 @@ struct vfio_ap_queue {
 
 int vfio_ap_mdev_register(void);
 void vfio_ap_mdev_unregister(void);
-int vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q,
-			     unsigned int retry);
+
+int vfio_ap_mdev_probe_queue(struct ap_device *queue);
+void vfio_ap_mdev_remove_queue(struct ap_device *queue);
 
 #endif /* _VFIO_AP_PRIVATE_H_ */
