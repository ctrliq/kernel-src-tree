ASoC: SOF: Make sof_widget_setup/free IPC agnostic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 051744b1bf0b13f63af5de3c296d04ab0cc6117c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/051744b1.failed

Add 3 new topology IPC ops for widget_setup, widget_free and dai_config
in order to make the pipeline management code IPC agnostic and implement
the ops for IPC3.

Use the newly introduced tplg dai_config op to configure the DAI during
BE DAI hw_params and hw_free.

Also, in preparation for IPC4, modify BE hw_params callback to skip
setting up the DAI widget. All widgets will be set up during FW
hw_params and the DAI_CONFIG IPC should be sent only if the widget
use_count is > 0. With setting up/freeing removed from the BE hw_params,
remove the configured flag as it is no longer needed.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20220317175044.1752400-3-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 051744b1bf0b13f63af5de3c296d04ab0cc6117c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda-dai.c
#	sound/soc/sof/intel/hda.c
#	sound/soc/sof/intel/hda.h
#	sound/soc/sof/ipc3-topology.c
#	sound/soc/sof/sof-audio.c
#	sound/soc/sof/sof-audio.h
diff --cc sound/soc/sof/intel/hda-dai.c
index 97bf291cb5b8,f9cb9f1f0237..000000000000
--- a/sound/soc/sof/intel/hda-dai.c
+++ b/sound/soc/sof/intel/hda-dai.c
@@@ -215,9 -172,9 +176,15 @@@ static int hda_link_dai_widget_update(s
  
  	/* set up/free DAI widget and send DAI_CONFIG IPC */
  	if (widget_setup)
++<<<<<<< HEAD
 +		return hda_ctrl_dai_widget_setup(w);
 +
 +	return hda_ctrl_dai_widget_free(w);
++=======
+ 		return hda_ctrl_dai_widget_setup(w, SOF_DAI_CONFIG_FLAGS_2_STEP_STOP, &data);
+ 
+ 	return hda_ctrl_dai_widget_free(w, SOF_DAI_CONFIG_FLAGS_NONE, &data);
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  }
  
  static int hda_link_hw_params(struct snd_pcm_substream *substream,
@@@ -485,19 -419,10 +429,16 @@@ static int ssp_dai_setup_or_free(struc
  	else
  		w = dai->capture_widget;
  
- 	swidget = w->dobj.private;
- 	component = swidget->scomp;
- 	sdev = snd_soc_component_get_drvdata(component);
- 	v = &sdev->fw_ready.version;
- 
- 	/* DAI_CONFIG IPC during hw_params is not supported in older firmware */
- 	if (v->abi_version < SOF_ABI_VER(3, 18, 0))
- 		return 0;
- 
  	if (setup)
++<<<<<<< HEAD
 +		return hda_ctrl_dai_widget_setup(w);
 +
 +	return hda_ctrl_dai_widget_free(w);
++=======
+ 		return hda_ctrl_dai_widget_setup(w, SOF_DAI_CONFIG_FLAGS_NONE, NULL);
+ 
+ 	return hda_ctrl_dai_widget_free(w, SOF_DAI_CONFIG_FLAGS_NONE, NULL);
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  }
  
  static int ssp_dai_startup(struct snd_pcm_substream *substream,
diff --cc sound/soc/sof/intel/hda.c
index 175a01918118,019f8d6b91d4..000000000000
--- a/sound/soc/sof/intel/hda.c
+++ b/sound/soc/sof/intel/hda.c
@@@ -41,7 -41,8 +41,12 @@@
  #define EXCEPT_MAX_HDR_SIZE	0x400
  #define HDA_EXT_ROM_STATUS_SIZE 8
  
++<<<<<<< HEAD
 +int hda_ctrl_dai_widget_setup(struct snd_soc_dapm_widget *w)
++=======
+ int hda_ctrl_dai_widget_setup(struct snd_soc_dapm_widget *w, unsigned int quirk_flags,
+ 			      struct snd_sof_dai_config_data *data)
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  {
  	struct snd_sof_widget *swidget = w->dobj.private;
  	struct snd_soc_component *component = swidget->scomp;
@@@ -59,49 -56,26 +60,66 @@@
  		return -EINVAL;
  	}
  
- 	private = sof_dai->private;
- 	if (!private->dai_config) {
- 		dev_err(sdev->dev, "%s: No config for DAI %s\n", __func__, w->name);
- 		return -EINVAL;
- 	}
+ 	if (tplg_ops->dai_config) {
+ 		unsigned int flags;
  
++<<<<<<< HEAD
 +	/* DAI already configured, reset it before reconfiguring it */
 +	if (sof_dai->configured) {
 +		ret = hda_ctrl_dai_widget_free(w);
 +		if (ret < 0)
++=======
+ 		/* set HW_PARAMS flag along with quirks */
+ 		flags = SOF_DAI_CONFIG_FLAGS_HW_PARAMS |
+ 			quirk_flags << SOF_DAI_CONFIG_FLAGS_QUIRK_SHIFT;
+ 
+ 		ret = tplg_ops->dai_config(sdev, swidget, flags, data);
+ 		if (ret < 0) {
+ 			dev_err(sdev->dev, "%s: DAI config failed for widget %s\n", __func__,
+ 				w->name);
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  			return ret;
+ 		}
  	}
  
++<<<<<<< HEAD
 +	config = &private->dai_config[sof_dai->current_config];
 +
 +	/*
 +	 * For static pipelines, the DAI widget would already be set up and calling
 +	 * sof_widget_setup() simply returns without doing anything.
 +	 * For dynamic pipelines, the DAI widget will be set up now.
 +	 */
 +	ret = sof_widget_setup(sdev, swidget);
 +	if (ret < 0) {
 +		dev_err(sdev->dev, "error: failed setting up DAI widget %s\n", w->name);
 +		return ret;
 +	}
 +
 +	/* set HW_PARAMS flag */
 +	config->flags = FIELD_PREP(SOF_DAI_CONFIG_FLAGS_MASK, SOF_DAI_CONFIG_FLAGS_HW_PARAMS);
 +
 +	/* send DAI_CONFIG IPC */
 +	ret = sof_ipc_tx_message(sdev->ipc, config->hdr.cmd, config, config->hdr.size,
 +				 &reply, sizeof(reply));
 +	if (ret < 0) {
 +		dev_err(sdev->dev, "error: failed setting DAI config for %s\n", w->name);
 +		return ret;
 +	}
 +
 +	sof_dai->configured = true;
 +
 +	return 0;
 +}
 +
 +int hda_ctrl_dai_widget_free(struct snd_soc_dapm_widget *w)
++=======
+ 	return 0;
+ }
+ 
+ int hda_ctrl_dai_widget_free(struct snd_soc_dapm_widget *w, unsigned int quirk_flags,
+ 			     struct snd_sof_dai_config_data *data)
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  {
  	struct snd_sof_widget *swidget = w->dobj.private;
  	struct snd_soc_component *component = swidget->scomp;
@@@ -119,33 -88,21 +132,45 @@@
  		return -EINVAL;
  	}
  
- 	private = sof_dai->private;
- 	if (!private->dai_config) {
- 		dev_err(sdev->dev, "%s: No config for DAI %s\n", __func__, w->name);
- 		return -EINVAL;
+ 	if (tplg_ops->dai_config) {
+ 		unsigned int flags;
+ 		int ret;
+ 
+ 		/* set HW_FREE flag along with any quirks */
+ 		flags = SOF_DAI_CONFIG_FLAGS_HW_FREE |
+ 			quirk_flags << SOF_DAI_CONFIG_FLAGS_QUIRK_SHIFT;
+ 
+ 		ret = tplg_ops->dai_config(sdev, swidget, flags, data);
+ 		if (ret < 0)
+ 			dev_err(sdev->dev, "%s: DAI config failed for widget '%s'\n", __func__,
+ 				w->name);
  	}
  
++<<<<<<< HEAD
 +	/* nothing to do if hw_free() is called without restarting the stream after resume. */
 +	if (!sof_dai->configured)
 +		return 0;
 +
 +	config = &private->dai_config[sof_dai->current_config];
 +
 +	/* set HW_FREE flag */
 +	config->flags = FIELD_PREP(SOF_DAI_CONFIG_FLAGS_MASK, SOF_DAI_CONFIG_FLAGS_HW_FREE);
 +
 +	ret = sof_ipc_tx_message(sdev->ipc, config->hdr.cmd, config, config->hdr.size,
 +				 &reply, sizeof(reply));
 +	if (ret < 0)
 +		dev_err(sdev->dev, "error: failed resetting DAI config for %s\n", w->name);
 +
 +	/*
 +	 * Reset the configured_flag and free the widget even if the IPC fails to keep
 +	 * the widget use_count balanced
 +	 */
 +	sof_dai->configured = false;
 +
 +	return sof_widget_free(sdev, swidget);
++=======
+ 	return 0;
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  }
  
  #if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)
@@@ -160,45 -117,6 +185,48 @@@ static int sdw_clock_stop_quirks = SDW_
  module_param(sdw_clock_stop_quirks, int, 0444);
  MODULE_PARM_DESC(sdw_clock_stop_quirks, "SOF SoundWire clock stop quirks");
  
++<<<<<<< HEAD
 +static int sdw_dai_config_ipc(struct snd_sof_dev *sdev,
 +			      struct snd_soc_dapm_widget *w,
 +			      int link_id, int alh_stream_id, int dai_id, bool setup)
 +{
 +	struct snd_sof_widget *swidget = w->dobj.private;
 +	struct sof_dai_private_data *private;
 +	struct sof_ipc_dai_config *config;
 +	struct snd_sof_dai *sof_dai;
 +
 +	if (!swidget) {
 +		dev_err(sdev->dev, "error: No private data for widget %s\n", w->name);
 +		return -EINVAL;
 +	}
 +
 +	sof_dai = swidget->private;
 +
 +	if (!sof_dai || !sof_dai->private) {
 +		dev_err(sdev->dev, "%s: No private data for DAI %s\n", __func__, w->name);
 +		return -EINVAL;
 +	}
 +
 +	private = sof_dai->private;
 +	if (!private->dai_config) {
 +		dev_err(sdev->dev, "%s: No config for DAI %s\n", __func__, w->name);
 +		return -EINVAL;
 +	}
 +
 +	config = &private->dai_config[sof_dai->current_config];
 +
 +	/* update config with link and stream ID */
 +	config->dai_index = (link_id << 8) | dai_id;
 +	config->alh.stream_id = alh_stream_id;
 +
 +	if (setup)
 +		return hda_ctrl_dai_widget_setup(w);
 +
 +	return hda_ctrl_dai_widget_free(w);
 +}
 +
++=======
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  static int sdw_params_stream(struct device *dev,
  			     struct sdw_intel_stream_params_data *params_data)
  {
diff --cc sound/soc/sof/intel/hda.h
index 75ec47ada23c,05e5e158614a..000000000000
--- a/sound/soc/sof/intel/hda.h
+++ b/sound/soc/sof/intel/hda.h
@@@ -16,6 -16,8 +16,11 @@@
  #include <sound/compress_driver.h>
  #include <sound/hda_codec.h>
  #include <sound/hdaudio_ext.h>
++<<<<<<< HEAD
++=======
+ #include "../sof-client-probes.h"
+ #include "../sof-audio.h"
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  #include "shim.h"
  
  /* PCI registers */
@@@ -739,8 -731,10 +744,15 @@@ int hda_pci_intel_probe(struct pci_dev 
  
  struct snd_sof_dai;
  struct sof_ipc_dai_config;
++<<<<<<< HEAD
 +int hda_ctrl_dai_widget_setup(struct snd_soc_dapm_widget *w);
 +int hda_ctrl_dai_widget_free(struct snd_soc_dapm_widget *w);
++=======
+ int hda_ctrl_dai_widget_setup(struct snd_soc_dapm_widget *w, unsigned int quirk_flags,
+ 			      struct snd_sof_dai_config_data *data);
+ int hda_ctrl_dai_widget_free(struct snd_soc_dapm_widget *w, unsigned int quirk_flags,
+ 			     struct snd_sof_dai_config_data *data);
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  
  #define SOF_HDA_POSITION_QUIRK_USE_SKYLAKE_LEGACY	(0) /* previous implementation */
  #define SOF_HDA_POSITION_QUIRK_USE_DPIB_REGISTERS	(1) /* recommended if VC0 only */
diff --cc sound/soc/sof/sof-audio.c
index 59867de987af,7aa4ac313de3..000000000000
--- a/sound/soc/sof/sof-audio.c
+++ b/sound/soc/sof/sof-audio.c
@@@ -27,31 -27,6 +27,34 @@@ static int sof_kcontrol_setup(struct sn
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int sof_dai_config_setup(struct snd_sof_dev *sdev, struct snd_sof_dai *dai)
 +{
 +	struct sof_dai_private_data *private = dai->private;
 +	struct sof_ipc_dai_config *config;
 +	struct sof_ipc_reply reply;
 +	int ret;
 +
 +	config = &private->dai_config[dai->current_config];
 +	if (!config) {
 +		dev_err(sdev->dev, "error: no config for DAI %s\n", dai->name);
 +		return -EINVAL;
 +	}
 +
 +	/* set NONE flag to clear all previous settings */
 +	config->flags = FIELD_PREP(SOF_DAI_CONFIG_FLAGS_MASK, SOF_DAI_CONFIG_FLAGS_NONE);
 +
 +	ret = sof_ipc_tx_message(sdev->ipc, config->hdr.cmd, config, config->hdr.size,
 +				 &reply, sizeof(reply));
 +
 +	if (ret < 0)
 +		dev_err(sdev->dev, "error: failed to set dai config for %s\n", dai->name);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  static int sof_widget_kcontrol_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)
  {
  	struct snd_sof_control *scontrol;
diff --cc sound/soc/sof/sof-audio.h
index bde86e078e08,19386184d8f3..000000000000
--- a/sound/soc/sof/sof-audio.h
+++ b/sound/soc/sof/sof-audio.h
@@@ -30,9 -30,21 +30,14 @@@
  
  #define WIDGET_IS_DAI(id) ((id) == snd_soc_dapm_dai_in || (id) == snd_soc_dapm_dai_out)
  
 -/*
 - * Volume fractional word length define to 16 sets
 - * the volume linear gain value to use Qx.16 format
 - */
 -#define VOLUME_FWL	16
 -
  struct snd_sof_widget;
  struct snd_sof_route;
 -struct snd_sof_control;
  
+ struct snd_sof_dai_config_data {
+ 	int dai_index;
+ 	int dai_data; /* contains DAI-specific information */
+ };
+ 
  /**
   * struct sof_ipc_tplg_widget_ops - IPC-specific ops for topology widgets
   * @ipc_setup: Function pointer for setting up widget IPC params
@@@ -59,11 -71,24 +64,30 @@@ struct sof_ipc_tplg_widget_ops 
   * @token_list: List of all tokens supported by the IPC version. The size of the token_list
   *		array should be SOF_TOKEN_COUNT. The unused elements in the array will be
   *		initialized to 0.
++<<<<<<< HEAD
++=======
+  * @control_setup: Function pointer for setting up kcontrol IPC-specific data
+  * @control_free: Function pointer for freeing kcontrol IPC-specific data
+  * @pipeline_complete: Function pointer for pipeline complete IPC
+  * @widget_setup: Function pointer for setting up setup in the DSP
+  * @widget_free: Function pointer for freeing widget in the DSP
+  * @dai_config: Function pointer for sending DAI config IPC to the DSP
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
   */
  struct sof_ipc_tplg_ops {
  	const struct sof_ipc_tplg_widget_ops *widget;
  	int (*route_setup)(struct snd_sof_dev *sdev, struct snd_sof_route *sroute);
  	const struct sof_token_info *token_list;
++<<<<<<< HEAD
++=======
+ 	int (*control_setup)(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol);
+ 	int (*control_free)(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol);
+ 	int (*pipeline_complete)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	int (*widget_setup)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	int (*widget_free)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	int (*dai_config)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,
+ 			  unsigned int flags, struct snd_sof_dai_config_data *data);
++>>>>>>> 051744b1bf0b (ASoC: SOF: Make sof_widget_setup/free IPC agnostic)
  };
  
  /** struct snd_sof_tuple - Tuple info
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/intel/hda-dai.c
* Unmerged path sound/soc/sof/intel/hda.c
* Unmerged path sound/soc/sof/intel/hda.h
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/sof-audio.c
* Unmerged path sound/soc/sof/sof-audio.h
