tests/cgroup: move cg_wait_for(), cg_prepare_for_wait()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Christian Brauner <christian.brauner@ubuntu.com>
commit 8075e4f6c9904189ea04a853b5480451ec74e67d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8075e4f6.failed

as they will be used by the tests for cgroup killing.

Link: https://lore.kernel.org/r/20210503143922.3093755-4-brauner@kernel.org
	Cc: Tejun Heo <tj@kernel.org>
	Cc: cgroups@vger.kernel.org
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Roman Gushchin <guro@fb.com>
	Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 8075e4f6c9904189ea04a853b5480451ec74e67d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/cgroup/cgroup_util.c
#	tools/testing/selftests/cgroup/cgroup_util.h
#	tools/testing/selftests/cgroup/test_freezer.c
diff --cc tools/testing/selftests/cgroup/cgroup_util.c
index 4cb8e4717357,623cec04ad42..000000000000
--- a/tools/testing/selftests/cgroup/cgroup_util.c
+++ b/tools/testing/selftests/cgroup/cgroup_util.c
@@@ -358,3 -534,96 +360,99 @@@ int set_oom_adj_score(int pid, int scor
  	close(fd);
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ ssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size)
+ {
+ 	char path[PATH_MAX];
+ 
+ 	if (!pid)
+ 		snprintf(path, sizeof(path), "/proc/%s/%s",
+ 			 thread ? "thread-self" : "self", item);
+ 	else
+ 		snprintf(path, sizeof(path), "/proc/%d/%s", pid, item);
+ 
+ 	return read_text(path, buf, size);
+ }
+ 
+ int proc_read_strstr(int pid, bool thread, const char *item, const char *needle)
+ {
+ 	char buf[PAGE_SIZE];
+ 
+ 	if (proc_read_text(pid, thread, item, buf, sizeof(buf)) < 0)
+ 		return -1;
+ 
+ 	return strstr(buf, needle) ? 0 : -1;
+ }
+ 
+ int clone_into_cgroup_run_wait(const char *cgroup)
+ {
+ 	int cgroup_fd;
+ 	pid_t pid;
+ 
+ 	cgroup_fd =  dirfd_open_opath(cgroup);
+ 	if (cgroup_fd < 0)
+ 		return -1;
+ 
+ 	pid = clone_into_cgroup(cgroup_fd);
+ 	close_prot_errno(cgroup_fd);
+ 	if (pid < 0)
+ 		return -1;
+ 
+ 	if (pid == 0)
+ 		exit(EXIT_SUCCESS);
+ 
+ 	/*
+ 	 * We don't care whether this fails. We only care whether the initial
+ 	 * clone succeeded.
+ 	 */
+ 	(void)clone_reap(pid, WEXITED);
+ 	return 0;
+ }
+ 
+ int cg_prepare_for_wait(const char *cgroup)
+ {
+ 	int fd, ret = -1;
+ 
+ 	fd = inotify_init1(0);
+ 	if (fd == -1)
+ 		return fd;
+ 
+ 	ret = inotify_add_watch(fd, cg_control(cgroup, "cgroup.events"),
+ 				IN_MODIFY);
+ 	if (ret == -1) {
+ 		close(fd);
+ 		fd = -1;
+ 	}
+ 
+ 	return fd;
+ }
+ 
+ int cg_wait_for(int fd)
+ {
+ 	int ret = -1;
+ 	struct pollfd fds = {
+ 		.fd = fd,
+ 		.events = POLLIN,
+ 	};
+ 
+ 	while (true) {
+ 		ret = poll(&fds, 1, 10000);
+ 
+ 		if (ret == -1) {
+ 			if (errno == EINTR)
+ 				continue;
+ 
+ 			break;
+ 		}
+ 
+ 		if (ret > 0 && fds.revents & POLLIN) {
+ 			ret = 0;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
++>>>>>>> 8075e4f6c990 (tests/cgroup: move cg_wait_for(), cg_prepare_for_wait())
diff --cc tools/testing/selftests/cgroup/cgroup_util.h
index cabd43fd137a,82e59cdf16e7..000000000000
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@@ -40,3 -46,13 +40,16 @@@ extern int alloc_pagecache(int fd, size
  extern int alloc_anon(const char *cgroup, void *arg);
  extern int is_swap_enabled(void);
  extern int set_oom_adj_score(int pid, int score);
++<<<<<<< HEAD
++=======
+ extern int cg_wait_for_proc_count(const char *cgroup, int count);
+ extern int cg_killall(const char *cgroup);
+ extern ssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size);
+ extern int proc_read_strstr(int pid, bool thread, const char *item, const char *needle);
+ extern pid_t clone_into_cgroup(int cgroup_fd);
+ extern int clone_reap(pid_t pid, int options);
+ extern int clone_into_cgroup_run_wait(const char *cgroup);
+ extern int dirfd_open_opath(const char *dir);
+ extern int cg_prepare_for_wait(const char *cgroup);
+ extern int cg_wait_for(int fd);
++>>>>>>> 8075e4f6c990 (tests/cgroup: move cg_wait_for(), cg_prepare_for_wait())
* Unmerged path tools/testing/selftests/cgroup/test_freezer.c
* Unmerged path tools/testing/selftests/cgroup/cgroup_util.c
* Unmerged path tools/testing/selftests/cgroup/cgroup_util.h
* Unmerged path tools/testing/selftests/cgroup/test_freezer.c
