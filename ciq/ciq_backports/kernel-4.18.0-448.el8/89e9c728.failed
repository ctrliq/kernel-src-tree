ipv6: Remove __ipv6_only_sock().

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Kuniyuki Iwashima <kuniyu@amazon.co.jp>
commit 89e9c7280075f6733b22dd0740daeddeb1256ebf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/89e9c728.failed

Since commit 9fe516ba3fb2 ("inet: move ipv6only in sock_common"),
ipv6_only_sock() and __ipv6_only_sock() are the same macro.  Let's
remove the one.

	Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.co.jp>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 89e9c7280075f6733b22dd0740daeddeb1256ebf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ipv6.h
#	net/ipv6/tcp_ipv6.c
diff --cc include/linux/ipv6.h
index 7639062049c2,ec5ca392eaa3..000000000000
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@@ -349,19 -340,7 +349,23 @@@ static inline struct raw6_sock *raw6_sk
  	return (struct raw6_sock *)sk;
  }
  
++<<<<<<< HEAD
 +static inline void inet_sk_copy_descendant(struct sock *sk_to,
 +					   const struct sock *sk_from)
 +{
 +	int ancestor_size = sizeof(struct inet_sock);
 +
 +	if (sk_from->sk_family == PF_INET6)
 +		ancestor_size += sizeof(struct ipv6_pinfo);
 +
 +	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);
 +}
 +
 +#define __ipv6_only_sock(sk)	(sk->sk_ipv6only)
 +#define ipv6_only_sock(sk)	(__ipv6_only_sock(sk))
++=======
+ #define ipv6_only_sock(sk)	(sk->sk_ipv6only)
++>>>>>>> 89e9c7280075 (ipv6: Remove __ipv6_only_sock().)
  #define ipv6_sk_rxinfo(sk)	((sk)->sk_family == PF_INET6 && \
  				 inet6_sk(sk)->rxopt.bits.rxinfo)
  
diff --cc net/ipv6/tcp_ipv6.c
index 8cdff0ded837,54277de7474b..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -222,9 -230,7 +222,13 @@@ static int tcp_v6_connect(struct sock *
  		u32 exthdrlen = icsk->icsk_ext_hdr_len;
  		struct sockaddr_in sin;
  
++<<<<<<< HEAD
 +		SOCK_DEBUG(sk, "connect: ipv4 mapped\n");
 +
 +		if (__ipv6_only_sock(sk))
++=======
+ 		if (ipv6_only_sock(sk))
++>>>>>>> 89e9c7280075 (ipv6: Remove __ipv6_only_sock().)
  			return -ENETUNREACH;
  
  		sin.sin_family = AF_INET;
* Unmerged path include/linux/ipv6.h
diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c
index 286685762518..bab4ed05be0f 100644
--- a/net/dccp/ipv6.c
+++ b/net/dccp/ipv6.c
@@ -885,7 +885,7 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 
 		SOCK_DEBUG(sk, "connect: ipv4 mapped\n");
 
-		if (__ipv6_only_sock(sk))
+		if (ipv6_only_sock(sk))
 			return -ENETUNREACH;
 
 		sin.sin_family = AF_INET;
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index f9523502a5da..588689f83192 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -148,7 +148,7 @@ int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr,
 	int			err;
 
 	if (usin->sin6_family == AF_INET) {
-		if (__ipv6_only_sock(sk))
+		if (ipv6_only_sock(sk))
 			return -EAFNOSUPPORT;
 		err = __ip4_datagram_connect(sk, uaddr, addr_len);
 		goto ipv4_connected;
@@ -181,7 +181,7 @@ int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr,
 	if (addr_type & IPV6_ADDR_MAPPED) {
 		struct sockaddr_in sin;
 
-		if (__ipv6_only_sock(sk)) {
+		if (ipv6_only_sock(sk)) {
 			err = -ENETUNREACH;
 			goto out;
 		}
* Unmerged path net/ipv6/tcp_ipv6.c
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 8083aac3d992..a3e583b1e9ae 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1168,7 +1168,7 @@ static int udpv6_pre_connect(struct sock *sk, struct sockaddr *uaddr,
 	 * bytes that are out of the bound specified by user in addr_len.
 	 */
 	if (uaddr->sa_family == AF_INET) {
-		if (__ipv6_only_sock(sk))
+		if (ipv6_only_sock(sk))
 			return -EAFNOSUPPORT;
 		return udp_pre_connect(sk, uaddr, addr_len);
 	}
@@ -1406,7 +1406,7 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 			msg->msg_name = &sin;
 			msg->msg_namelen = sizeof(sin);
 do_udp_sendmsg:
-			if (__ipv6_only_sock(sk))
+			if (ipv6_only_sock(sk))
 				return -ENETUNREACH;
 			return udp_sendmsg(sk, msg, len);
 		}
diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index c7768f55501f..df1051f72453 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -941,7 +941,7 @@ static int sctp_inet6_af_supported(sa_family_t family, struct sctp_sock *sp)
 		return 1;
 	/* v4-mapped-v6 addresses */
 	case AF_INET:
-		if (!__ipv6_only_sock(sctp_opt2sk(sp)))
+		if (!ipv6_only_sock(sctp_opt2sk(sp)))
 			return 1;
 		/* fallthru */
 	default:
@@ -967,7 +967,7 @@ static int sctp_inet6_cmp_addr(const union sctp_addr *addr1,
 		return 0;
 
 	/* If the socket is IPv6 only, v4 addrs will not match */
-	if (__ipv6_only_sock(sk) && af1 != af2)
+	if (ipv6_only_sock(sk) && af1 != af2)
 		return 0;
 
 	/* Today, wildcard AF_INET/AF_INET6. */
