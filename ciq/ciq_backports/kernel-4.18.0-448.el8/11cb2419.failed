s390/vfio-ap: manage link between queue struct and matrix mdev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 11cb2419fafe67f5ab965e2958475bce43c1529a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/11cb2419.failed

Let's create links between each queue device bound to the vfio_ap device
driver and the matrix mdev to which the queue's APQN is assigned. The idea
is to facilitate efficient retrieval of the objects representing the queue
devices and matrix mdevs as well as to verify that a queue assigned to
a matrix mdev is bound to the driver.

The links will be created as follows:

 * When the queue device is probed, if its APQN is assigned to a matrix
   mdev, the structures representing the queue device and the matrix mdev
   will be linked.

 * When an adapter or domain is assigned to a matrix mdev, for each new
   APQN assigned that references a queue device bound to the vfio_ap
   device driver, the structures representing the queue device and the
   matrix mdev will be linked.

The links will be removed as follows:

 * When the queue device is removed, if its APQN is assigned to a matrix
   mdev, the link from the structure representing the matrix mdev to the
   structure representing the queue will be removed. Since the storage
   allocated for the vfio_ap_queue will be freed, there is no need to
   remove the link to the matrix_mdev to which the queue's APQN is
   assigned.

 * When an adapter or domain is unassigned from a matrix mdev, for each
   APQN unassigned that references a queue device bound to the vfio_ap
   device driver, the structures representing the queue device and the
   matrix mdev will be unlinked.

 * When an mdev is removed, the link from any queues assigned to the mdev
   to the mdev will be removed.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit 11cb2419fafe67f5ab965e2958475bce43c1529a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
#	drivers/s390/crypto/vfio_ap_private.h
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,9bed11aa0ea6..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -24,21 -26,24 +24,19 @@@
  #define VFIO_AP_MDEV_TYPE_HWVIRT "passthrough"
  #define VFIO_AP_MDEV_NAME_HWVIRT "VFIO AP Passthrough Device"
  
 -#define AP_QUEUE_ASSIGNED "assigned"
 -#define AP_QUEUE_UNASSIGNED "unassigned"
 -#define AP_QUEUE_IN_USE "in use"
 -
 -static int vfio_ap_mdev_reset_queues(struct ap_matrix_mdev *matrix_mdev);
 +static int vfio_ap_mdev_reset_queues(struct mdev_device *mdev);
  static struct vfio_ap_queue *vfio_ap_find_queue(int apqn);
 -static const struct vfio_device_ops vfio_ap_matrix_dev_ops;
  
  /**
-  * vfio_ap_get_queue - retrieve a queue with a specific APQN from a list
-  * @matrix_mdev: the associated mediated matrix
-  * @apqn: The queue APQN
+  * vfio_ap_mdev_get_queue - retrieve a queue with a specific APQN from a
+  *			    hash table of queues assigned to a matrix mdev
+  * @matrix_mdev: the matrix mdev
+  * @apqn: The APQN of a queue device
   *
-  * Retrieve a queue with a specific APQN from the list of the
-  * devices of the vfio_ap_drv.
-  * Verify that the APID and the APQI are set in the matrix.
-  *
-  * Return: the pointer to the associated vfio_ap_queue
+  * Return: the pointer to the vfio_ap_queue struct representing the queue or
+  *	   NULL if the queue is not assigned to @matrix_mdev
   */
- static struct vfio_ap_queue *vfio_ap_get_queue(
+ static struct vfio_ap_queue *vfio_ap_mdev_get_queue(
  					struct ap_matrix_mdev *matrix_mdev,
  					int apqn)
  {
@@@ -291,12 -408,21 +285,20 @@@ static int handle_pqap(struct kvm_vcpu 
  				   struct ap_matrix_mdev, pqap_hook);
  
  	/* If the there is no guest using the mdev, there is nothing to do */
 -	if (!matrix_mdev->kvm) {
 -		vfio_ap_le_guid_to_be_uuid(&matrix_mdev->mdev->uuid, uuid);
 -		VFIO_AP_DBF_WARN("%s: mdev %08lx-%04lx-%04lx-%04lx-%04lx%08lx not in use: apqn=0x%04x\n",
 -				 __func__, uuid[0],  uuid[1], uuid[2],
 -				 uuid[3], uuid[4], uuid[5], apqn);
 +	if (!matrix_mdev->kvm)
  		goto out_unlock;
 -	}
  
++<<<<<<< HEAD
 +	q = vfio_ap_get_queue(matrix_mdev, apqn);
 +	if (!q)
++=======
+ 	q = vfio_ap_mdev_get_queue(matrix_mdev, apqn);
+ 	if (!q) {
+ 		VFIO_AP_DBF_WARN("%s: Queue %02x.%04x not bound to the vfio_ap driver\n",
+ 				 __func__, AP_QID_CARD(apqn),
+ 				 AP_QID_QUEUE(apqn));
++>>>>>>> 11cb2419fafe (s390/vfio-ap: manage link between queue struct and matrix mdev)
  		goto out_unlock;
 -	}
  
  	status = vcpu->run->s.regs.gprs[1];
  
@@@ -337,31 -463,99 +339,91 @@@ static int vfio_ap_mdev_create(struct k
  
  	matrix_mdev->mdev = mdev;
  	vfio_ap_matrix_init(&matrix_dev->info, &matrix_mdev->matrix);
 +	mdev_set_drvdata(mdev, matrix_mdev);
  	matrix_mdev->pqap_hook = handle_pqap;
+ 	hash_init(matrix_mdev->qtable.queues);
+ 	dev_set_drvdata(&mdev->dev, matrix_mdev);
  	mutex_lock(&matrix_dev->lock);
  	list_add(&matrix_mdev->node, &matrix_dev->mdev_list);
  	mutex_unlock(&matrix_dev->lock);
  
 -	ret = vfio_register_emulated_iommu_dev(&matrix_mdev->vdev);
 -	if (ret)
 -		goto err_list;
 -	dev_set_drvdata(&mdev->dev, matrix_mdev);
  	return 0;
 -
 -err_list:
 -	mutex_lock(&matrix_dev->lock);
 -	list_del(&matrix_mdev->node);
 -	mutex_unlock(&matrix_dev->lock);
 -	vfio_uninit_group_dev(&matrix_mdev->vdev);
 -	kfree(matrix_mdev);
 -err_dec_available:
 -	atomic_inc(&matrix_dev->available_instances);
 -	return ret;
  }
  
++<<<<<<< HEAD
 +static int vfio_ap_mdev_remove(struct mdev_device *mdev)
++=======
+ static void vfio_ap_mdev_link_queue(struct ap_matrix_mdev *matrix_mdev,
+ 				    struct vfio_ap_queue *q)
+ {
+ 	if (q) {
+ 		q->matrix_mdev = matrix_mdev;
+ 		hash_add(matrix_mdev->qtable.queues, &q->mdev_qnode, q->apqn);
+ 	}
+ }
+ 
+ static void vfio_ap_mdev_link_apqn(struct ap_matrix_mdev *matrix_mdev, int apqn)
+ {
+ 	struct vfio_ap_queue *q;
+ 
+ 	q = vfio_ap_find_queue(apqn);
+ 	vfio_ap_mdev_link_queue(matrix_mdev, q);
+ }
+ 
+ static void vfio_ap_unlink_queue_fr_mdev(struct vfio_ap_queue *q)
+ {
+ 	hash_del(&q->mdev_qnode);
+ }
+ 
+ static void vfio_ap_unlink_mdev_fr_queue(struct vfio_ap_queue *q)
+ {
+ 	q->matrix_mdev = NULL;
+ }
+ 
+ static void vfio_ap_mdev_unlink_queue(struct vfio_ap_queue *q)
+ {
+ 	vfio_ap_unlink_queue_fr_mdev(q);
+ 	vfio_ap_unlink_mdev_fr_queue(q);
+ }
+ 
+ static void vfio_ap_mdev_unlink_fr_queues(struct ap_matrix_mdev *matrix_mdev)
+ {
+ 	struct vfio_ap_queue *q;
+ 	unsigned long apid, apqi;
+ 
+ 	for_each_set_bit_inv(apid, matrix_mdev->matrix.apm, AP_DEVICES) {
+ 		for_each_set_bit_inv(apqi, matrix_mdev->matrix.aqm,
+ 				     AP_DOMAINS) {
+ 			q = vfio_ap_mdev_get_queue(matrix_mdev,
+ 						   AP_MKQID(apid, apqi));
+ 			if (q)
+ 				q->matrix_mdev = NULL;
+ 		}
+ 	}
+ }
+ 
+ static void vfio_ap_mdev_remove(struct mdev_device *mdev)
++>>>>>>> 11cb2419fafe (s390/vfio-ap: manage link between queue struct and matrix mdev)
  {
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(&mdev->dev);
 -
 -	vfio_unregister_group_dev(&matrix_mdev->vdev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
  	mutex_lock(&matrix_dev->lock);
++<<<<<<< HEAD
 +	vfio_ap_mdev_reset_queues(mdev);
++=======
+ 	vfio_ap_mdev_reset_queues(matrix_mdev);
+ 	vfio_ap_mdev_unlink_fr_queues(matrix_mdev);
++>>>>>>> 11cb2419fafe (s390/vfio-ap: manage link between queue struct and matrix mdev)
  	list_del(&matrix_mdev->node);
 -	mutex_unlock(&matrix_dev->lock);
 -	vfio_uninit_group_dev(&matrix_mdev->vdev);
  	kfree(matrix_mdev);
 +	mdev_set_drvdata(mdev, NULL);
  	atomic_inc(&matrix_dev->available_instances);
 +	mutex_unlock(&matrix_dev->lock);
 +
 +	return 0;
  }
  
 -static ssize_t name_show(struct mdev_type *mtype,
 -			 struct mdev_type_attribute *attr, char *buf)
 +static ssize_t name_show(struct kobject *kobj, struct device *dev, char *buf)
  {
  	return sprintf(buf, "%s\n", VFIO_AP_MDEV_NAME_HWVIRT);
  }
@@@ -1241,28 -1446,20 +1354,21 @@@ free_resources
  	return ret;
  }
  
 -static int vfio_ap_mdev_reset_queues(struct ap_matrix_mdev *matrix_mdev)
 +static int vfio_ap_mdev_reset_queues(struct mdev_device *mdev)
  {
- 	int ret;
- 	int rc = 0;
- 	unsigned long apid, apqi;
+ 	int ret, loop_cursor, rc = 0;
  	struct vfio_ap_queue *q;
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
- 	for_each_set_bit_inv(apid, matrix_mdev->matrix.apm,
- 			     matrix_mdev->matrix.apm_max + 1) {
- 		for_each_set_bit_inv(apqi, matrix_mdev->matrix.aqm,
- 				     matrix_mdev->matrix.aqm_max + 1) {
- 			q = vfio_ap_find_queue(AP_MKQID(apid, apqi));
- 			ret = vfio_ap_mdev_reset_queue(q, 1);
- 			/*
- 			 * Regardless whether a queue turns out to be busy, or
- 			 * is not operational, we need to continue resetting
- 			 * the remaining queues.
- 			 */
- 			if (ret)
- 				rc = ret;
- 		}
+ 	hash_for_each(matrix_mdev->qtable.queues, loop_cursor, q, mdev_qnode) {
+ 		ret = vfio_ap_mdev_reset_queue(q, 1);
+ 		/*
+ 		 * Regardless whether a queue turns out to be busy, or
+ 		 * is not operational, we need to continue resetting
+ 		 * the remaining queues.
+ 		 */
+ 		if (ret)
+ 			rc = ret;
  	}
  
  	return rc;
@@@ -1383,4 -1643,67 +1489,70 @@@ int vfio_ap_mdev_register(void
  void vfio_ap_mdev_unregister(void)
  {
  	mdev_unregister_device(&matrix_dev->device);
++<<<<<<< HEAD
++=======
+ 	mdev_unregister_driver(&vfio_ap_matrix_driver);
+ }
+ 
+ /*
+  * vfio_ap_queue_link_mdev
+  *
+  * @q: The queue to link with the matrix mdev.
+  *
+  * Links @q with the matrix mdev to which the queue's APQN is assigned.
+  */
+ static void vfio_ap_queue_link_mdev(struct vfio_ap_queue *q)
+ {
+ 	unsigned long apid = AP_QID_CARD(q->apqn);
+ 	unsigned long apqi = AP_QID_QUEUE(q->apqn);
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 
+ 	list_for_each_entry(matrix_mdev, &matrix_dev->mdev_list, node) {
+ 		if (test_bit_inv(apid, matrix_mdev->matrix.apm) &&
+ 		    test_bit_inv(apqi, matrix_mdev->matrix.aqm)) {
+ 			vfio_ap_mdev_link_queue(matrix_mdev, q);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ int vfio_ap_mdev_probe_queue(struct ap_device *apdev)
+ {
+ 	int ret;
+ 	struct vfio_ap_queue *q;
+ 
+ 	ret = sysfs_create_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	if (ret)
+ 		return ret;
+ 
+ 	q = kzalloc(sizeof(*q), GFP_KERNEL);
+ 	if (!q)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&matrix_dev->lock);
+ 	q->apqn = to_ap_queue(&apdev->device)->qid;
+ 	q->saved_isc = VFIO_AP_ISC_INVALID;
+ 	vfio_ap_queue_link_mdev(q);
+ 	dev_set_drvdata(&apdev->device, q);
+ 	mutex_unlock(&matrix_dev->lock);
+ 
+ 	return 0;
+ }
+ 
+ void vfio_ap_mdev_remove_queue(struct ap_device *apdev)
+ {
+ 	struct vfio_ap_queue *q;
+ 
+ 	mutex_lock(&matrix_dev->lock);
+ 	sysfs_remove_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	q = dev_get_drvdata(&apdev->device);
+ 
+ 	if (q->matrix_mdev)
+ 		vfio_ap_unlink_queue_fr_mdev(q);
+ 
+ 	vfio_ap_mdev_reset_queue(q, 1);
+ 	dev_set_drvdata(&apdev->device, NULL);
+ 	kfree(q);
+ 	mutex_unlock(&matrix_dev->lock);
++>>>>>>> 11cb2419fafe (s390/vfio-ap: manage link between queue struct and matrix mdev)
  }
diff --cc drivers/s390/crypto/vfio_ap_private.h
index 2b06b4ffd2fd,44d2eeb795a0..000000000000
--- a/drivers/s390/crypto/vfio_ap_private.h
+++ b/drivers/s390/crypto/vfio_ap_private.h
@@@ -18,6 -18,8 +18,11 @@@
  #include <linux/delay.h>
  #include <linux/mutex.h>
  #include <linux/kvm_host.h>
++<<<<<<< HEAD
++=======
+ #include <linux/vfio.h>
+ #include <linux/hashtable.h>
++>>>>>>> 11cb2419fafe (s390/vfio-ap: manage link between queue struct and matrix mdev)
  
  #include "ap_bus.h"
  
@@@ -88,11 -97,12 +102,12 @@@ struct ap_queue_table 
   * @pqap_hook:	the function pointer to the interception handler for the
   *		PQAP(AQIC) instruction.
   * @mdev:	the mediated device
+  * @qtable:	table of queues (struct vfio_ap_queue) assigned to the mdev
   */
  struct ap_matrix_mdev {
 -	struct vfio_device vdev;
  	struct list_head node;
  	struct ap_matrix matrix;
 +	struct notifier_block group_notifier;
  	struct notifier_block iommu_notifier;
  	struct kvm *kvm;
  	crypto_hook pqap_hook;
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
* Unmerged path drivers/s390/crypto/vfio_ap_private.h
