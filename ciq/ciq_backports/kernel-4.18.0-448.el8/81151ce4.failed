wifi: mac80211: support MLO authentication/association with one link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 81151ce462e533551f3284bfdb8e0f461c9220e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/81151ce4.failed

It might seem a bit pointless to do a multi-link operation
connection with just a single link, but this is already a
big change, so for now, limit MLO connections to a single
link.

Extending that to multiple links will require
 * work on parsing the multi-link element with STA profile
   properly, including element fragmentation;
 * checking the per-link status in the multi-link element
 * implementing logic to have active/inactive links to let
   drivers decide which links should be active;
 * implementing multicast RX deduplication;
 * and likely more.

For now this is still useful since it lets us do multi-link
connections for the purposes of testing APIs and the higher
layers such as wpa_supplicant.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 81151ce462e533551f3284bfdb8e0f461c9220e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
#	net/mac80211/tx.c
#	net/wireless/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,e4e501f2713e..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -767,26 -753,561 +767,580 @@@ static void ieee80211_add_eht_ie(struc
  	ieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + eht_cap_size);
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_assoc_add_rates(struct sk_buff *skb,
+ 				      enum nl80211_chan_width width,
+ 				      struct ieee80211_supported_band *sband,
+ 				      struct ieee80211_mgd_assoc_data *assoc_data)
+ {
+ 	unsigned int shift = ieee80211_chanwidth_get_shift(width);
+ 	unsigned int rates_len, supp_rates_len;
+ 	u32 rates = 0;
+ 	int i, count;
+ 	u8 *pos;
+ 
+ 	if (assoc_data->supp_rates_len) {
+ 		/*
+ 		 * Get all rates supported by the device and the AP as
+ 		 * some APs don't like getting a superset of their rates
+ 		 * in the association request (e.g. D-Link DAP 1353 in
+ 		 * b-only mode)...
+ 		 */
+ 		rates_len = ieee80211_parse_bitrates(width, sband,
+ 						     assoc_data->supp_rates,
+ 						     assoc_data->supp_rates_len,
+ 						     &rates);
+ 	} else {
+ 		/*
+ 		 * In case AP not provide any supported rates information
+ 		 * before association, we send information element(s) with
+ 		 * all rates that we support.
+ 		 */
+ 		rates_len = sband->n_bitrates;
+ 		for (i = 0; i < sband->n_bitrates; i++)
+ 			rates |= BIT(i);
+ 	}
+ 
+ 	supp_rates_len = rates_len;
+ 	if (supp_rates_len > 8)
+ 		supp_rates_len = 8;
+ 
+ 	pos = skb_put(skb, supp_rates_len + 2);
+ 	*pos++ = WLAN_EID_SUPP_RATES;
+ 	*pos++ = supp_rates_len;
+ 
+ 	count = 0;
+ 	for (i = 0; i < sband->n_bitrates; i++) {
+ 		if (BIT(i) & rates) {
+ 			int rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
+ 						5 * (1 << shift));
+ 			*pos++ = (u8)rate;
+ 			if (++count == 8)
+ 				break;
+ 		}
+ 	}
+ 
+ 	if (rates_len > count) {
+ 		pos = skb_put(skb, rates_len - count + 2);
+ 		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+ 		*pos++ = rates_len - count;
+ 
+ 		for (i++; i < sband->n_bitrates; i++) {
+ 			if (BIT(i) & rates) {
+ 				int rate;
+ 
+ 				rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
+ 						    5 * (1 << shift));
+ 				*pos++ = (u8)rate;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static size_t ieee80211_add_before_ht_elems(struct sk_buff *skb,
+ 					    const u8 *elems,
+ 					    size_t elems_len,
+ 					    size_t offset)
+ {
+ 	size_t noffset;
+ 
+ 	static const u8 before_ht[] = {
+ 		WLAN_EID_SSID,
+ 		WLAN_EID_SUPP_RATES,
+ 		WLAN_EID_EXT_SUPP_RATES,
+ 		WLAN_EID_PWR_CAPABILITY,
+ 		WLAN_EID_SUPPORTED_CHANNELS,
+ 		WLAN_EID_RSN,
+ 		WLAN_EID_QOS_CAPA,
+ 		WLAN_EID_RRM_ENABLED_CAPABILITIES,
+ 		WLAN_EID_MOBILITY_DOMAIN,
+ 		WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
+ 		WLAN_EID_RIC_DATA,		/* reassoc only */
+ 		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+ 	};
+ 	static const u8 after_ric[] = {
+ 		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+ 		WLAN_EID_HT_CAPABILITY,
+ 		WLAN_EID_BSS_COEX_2040,
+ 		/* luckily this is almost always there */
+ 		WLAN_EID_EXT_CAPABILITY,
+ 		WLAN_EID_QOS_TRAFFIC_CAPA,
+ 		WLAN_EID_TIM_BCAST_REQ,
+ 		WLAN_EID_INTERWORKING,
+ 		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
+ 		WLAN_EID_VHT_CAPABILITY,
+ 		WLAN_EID_OPMODE_NOTIF,
+ 	};
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	noffset = ieee80211_ie_split_ric(elems, elems_len,
+ 					 before_ht,
+ 					 ARRAY_SIZE(before_ht),
+ 					 after_ric,
+ 					 ARRAY_SIZE(after_ric),
+ 					 offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_add_before_vht_elems(struct sk_buff *skb,
+ 					     const u8 *elems,
+ 					     size_t elems_len,
+ 					     size_t offset)
+ {
+ 	static const u8 before_vht[] = {
+ 		/*
+ 		 * no need to list the ones split off before HT
+ 		 * or generated here
+ 		 */
+ 		WLAN_EID_BSS_COEX_2040,
+ 		WLAN_EID_EXT_CAPABILITY,
+ 		WLAN_EID_QOS_TRAFFIC_CAPA,
+ 		WLAN_EID_TIM_BCAST_REQ,
+ 		WLAN_EID_INTERWORKING,
+ 		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
+ 	};
+ 	size_t noffset;
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
+ 	noffset = ieee80211_ie_split(elems, elems_len,
+ 				     before_vht, ARRAY_SIZE(before_vht),
+ 				     offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_add_before_he_elems(struct sk_buff *skb,
+ 					    const u8 *elems,
+ 					    size_t elems_len,
+ 					    size_t offset)
+ {
+ 	static const u8 before_he[] = {
+ 		/*
+ 		 * no need to list the ones split off before VHT
+ 		 * or generated here
+ 		 */
+ 		WLAN_EID_OPMODE_NOTIF,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
+ 		/* 11ai elements */
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
+ 		/* TODO: add 11ah/11aj/11ak elements */
+ 	};
+ 	size_t noffset;
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
+ 	noffset = ieee80211_ie_split(elems, elems_len,
+ 				     before_he, ARRAY_SIZE(before_he),
+ 				     offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ #define PRESENT_ELEMS_MAX	8
+ #define PRESENT_ELEM_EXT_OFFS	0x100
+ 
+ static void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,
+ 					struct sk_buff *skb, u16 capab,
+ 					const struct element *ext_capa,
+ 					const u16 *present_elems);
+ 
+ static size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,
+ 					 struct sk_buff *skb, u16 *capab,
+ 					 const struct element *ext_capa,
+ 					 const u8 *extra_elems,
+ 					 size_t extra_elems_len,
+ 					 unsigned int link_id,
+ 					 struct ieee80211_link_data *link,
+ 					 u16 *present_elems)
+ {
+ 	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
+ 	struct ieee80211_channel *chan = cbss->channel;
+ 	const struct ieee80211_sband_iftype_data *iftd;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_supported_band *sband;
+ 	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	enum ieee80211_smps_mode smps_mode;
+ 	u16 orig_capab = *capab;
+ 	size_t offset = 0;
+ 	int present_elems_len = 0;
+ 	u8 *pos;
+ 	int i;
+ 
+ #define ADD_PRESENT_ELEM(id) do {					\
+ 	/* need a last for termination - we use 0 == SSID */		\
+ 	if (!WARN_ON(present_elems_len >= PRESENT_ELEMS_MAX - 1))	\
+ 		present_elems[present_elems_len++] = (id);		\
+ } while (0)
+ #define ADD_PRESENT_EXT_ELEM(id) ADD_PRESENT_ELEM(PRESENT_ELEM_EXT_OFFS | (id))
+ 
+ 	if (link)
+ 		smps_mode = link->smps_mode;
+ 	else if (sdata->u.mgd.powersave)
+ 		smps_mode = IEEE80211_SMPS_DYNAMIC;
+ 	else
+ 		smps_mode = IEEE80211_SMPS_OFF;
+ 
+ 	if (link) {
+ 		/*
+ 		 * 5/10 MHz scenarios are only viable without MLO, in which
+ 		 * case this pointer should be used ... All of this is a bit
+ 		 * unclear though, not sure this even works at all.
+ 		 */
+ 		rcu_read_lock();
+ 		chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
+ 		if (chanctx_conf)
+ 			width = chanctx_conf->def.width;
+ 		rcu_read_unlock();
+ 	}
+ 
+ 	sband = local->hw.wiphy->bands[chan->band];
+ 	iftd = ieee80211_get_sband_iftype_data(sband, iftype);
+ 
+ 	if (sband->band == NL80211_BAND_2GHZ) {
+ 		*capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
+ 		*capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;
+ 	}
+ 
+ 	if ((cbss->capability & WLAN_CAPABILITY_SPECTRUM_MGMT) &&
+ 	    ieee80211_hw_check(&local->hw, SPECTRUM_MGMT))
+ 		*capab |= WLAN_CAPABILITY_SPECTRUM_MGMT;
+ 
+ 	if (sband->band != NL80211_BAND_S1GHZ)
+ 		ieee80211_assoc_add_rates(skb, width, sband, assoc_data);
+ 
+ 	if (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT ||
+ 	    *capab & WLAN_CAPABILITY_RADIO_MEASURE) {
+ 		struct cfg80211_chan_def chandef = {
+ 			.width = width,
+ 			.chan = chan,
+ 		};
+ 
+ 		pos = skb_put(skb, 4);
+ 		*pos++ = WLAN_EID_PWR_CAPABILITY;
+ 		*pos++ = 2;
+ 		*pos++ = 0; /* min tx power */
+ 		 /* max tx power */
+ 		*pos++ = ieee80211_chandef_max_power(&chandef);
+ 		ADD_PRESENT_ELEM(WLAN_EID_PWR_CAPABILITY);
+ 	}
+ 
+ 	/*
+ 	 * Per spec, we shouldn't include the list of channels if we advertise
+ 	 * support for extended channel switching, but we've always done that;
+ 	 * (for now?) apply this restriction only on the (new) 6 GHz band.
+ 	 */
+ 	if (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT &&
+ 	    (sband->band != NL80211_BAND_6GHZ ||
+ 	     !ext_capa || ext_capa->datalen < 1 ||
+ 	     !(ext_capa->data[0] & WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING))) {
+ 		/* TODO: get this in reg domain format */
+ 		pos = skb_put(skb, 2 * sband->n_channels + 2);
+ 		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
+ 		*pos++ = 2 * sband->n_channels;
+ 		for (i = 0; i < sband->n_channels; i++) {
+ 			int cf = sband->channels[i].center_freq;
+ 
+ 			*pos++ = ieee80211_frequency_to_channel(cf);
+ 			*pos++ = 1; /* one channel in the subband*/
+ 		}
+ 		ADD_PRESENT_ELEM(WLAN_EID_SUPPORTED_CHANNELS);
+ 	}
+ 
+ 	/* if present, add any custom IEs that go before HT */
+ 	offset = ieee80211_add_before_ht_elems(skb, extra_elems,
+ 					       extra_elems_len,
+ 					       offset);
+ 
+ 	if (sband->band != NL80211_BAND_6GHZ &&
+ 	    !(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT)) {
+ 		ieee80211_add_ht_ie(sdata, skb,
+ 				    assoc_data->link[link_id].ap_ht_param,
+ 				    sband, chan, smps_mode,
+ 				    assoc_data->link[link_id].conn_flags);
+ 		ADD_PRESENT_ELEM(WLAN_EID_HT_CAPABILITY);
+ 	}
+ 
+ 	/* if present, add any custom IEs that go before VHT */
+ 	offset = ieee80211_add_before_vht_elems(skb, extra_elems,
+ 						extra_elems_len,
+ 						offset);
+ 
+ 	if (sband->band != NL80211_BAND_6GHZ &&
+ 	    !(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
+ 		bool mu_mimo_owner =
+ 			ieee80211_add_vht_ie(sdata, skb, sband,
+ 					     &assoc_data->link[link_id].ap_vht_cap,
+ 					     assoc_data->link[link_id].conn_flags);
+ 
+ 		if (link)
+ 			link->conf->mu_mimo_owner = mu_mimo_owner;
+ 		ADD_PRESENT_ELEM(WLAN_EID_VHT_CAPABILITY);
+ 	}
+ 
+ 	/*
+ 	 * If AP doesn't support HT, mark HE and EHT as disabled.
+ 	 * If on the 5GHz band, make sure it supports VHT.
+ 	 */
+ 	if (assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT ||
+ 	    (sband->band == NL80211_BAND_5GHZ &&
+ 	     assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		assoc_data->link[link_id].conn_flags |=
+ 			IEEE80211_CONN_DISABLE_HE |
+ 			IEEE80211_CONN_DISABLE_EHT;
+ 
+ 	/* if present, add any custom IEs that go before HE */
+ 	offset = ieee80211_add_before_he_elems(skb, extra_elems,
+ 					       extra_elems_len,
+ 					       offset);
+ 
+ 	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HE)) {
+ 		ieee80211_add_he_ie(sdata, skb, sband,
+ 				    assoc_data->link[link_id].conn_flags);
+ 		ADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_HE_CAPABILITY);
+ 	}
+ 
+ 	/*
+ 	 * careful - need to know about all the present elems before
+ 	 * calling ieee80211_assoc_add_ml_elem(), so add this one if
+ 	 * we're going to put it after the ML element
+ 	 */
+ 	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
+ 		ADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_EHT_CAPABILITY);
+ 
+ 	if (link_id == assoc_data->assoc_link_id)
+ 		ieee80211_assoc_add_ml_elem(sdata, skb, orig_capab, ext_capa,
+ 					    present_elems);
+ 
+ 	/* crash if somebody gets it wrong */
+ 	present_elems = NULL;
+ 
+ 	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
+ 		ieee80211_add_eht_ie(sdata, skb, sband);
+ 
+ 	if (sband->band == NL80211_BAND_S1GHZ) {
+ 		ieee80211_add_aid_request_ie(sdata, skb);
+ 		ieee80211_add_s1g_capab_ie(sdata, &sband->s1g_cap, skb);
+ 	}
+ 
+ 	if (iftd && iftd->vendor_elems.data && iftd->vendor_elems.len)
+ 		skb_put_data(skb, iftd->vendor_elems.data, iftd->vendor_elems.len);
+ 
+ 	if (link)
+ 		link->u.mgd.conn_flags = assoc_data->link[link_id].conn_flags;
+ 
+ 	return offset;
+ }
+ 
+ static void ieee80211_add_non_inheritance_elem(struct sk_buff *skb,
+ 					       const u16 *outer,
+ 					       const u16 *inner)
+ {
+ 	unsigned int skb_len = skb->len;
+ 	bool added = false;
+ 	int i, j;
+ 	u8 *len, *list_len = NULL;
+ 
+ 	skb_put_u8(skb, WLAN_EID_EXTENSION);
+ 	len = skb_put(skb, 1);
+ 	skb_put_u8(skb, WLAN_EID_EXT_NON_INHERITANCE);
+ 
+ 	for (i = 0; i < PRESENT_ELEMS_MAX && outer[i]; i++) {
+ 		u16 elem = outer[i];
+ 		bool have_inner = false;
+ 		bool at_extension = false;
+ 
+ 		/* should at least be sorted in the sense of normal -> ext */
+ 		WARN_ON(at_extension && elem < PRESENT_ELEM_EXT_OFFS);
+ 
+ 		/* switch to extension list */
+ 		if (!at_extension && elem >= PRESENT_ELEM_EXT_OFFS) {
+ 			at_extension = true;
+ 			if (!list_len)
+ 				skb_put_u8(skb, 0);
+ 			list_len = NULL;
+ 		}
+ 
+ 		for (j = 0; j < PRESENT_ELEMS_MAX && inner[j]; j++) {
+ 			if (elem == inner[j]) {
+ 				have_inner = true;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (have_inner)
+ 			continue;
+ 
+ 		if (!list_len) {
+ 			list_len = skb_put(skb, 1);
+ 			*list_len = 0;
+ 		}
+ 		*list_len += 1;
+ 		skb_put_u8(skb, (u8)elem);
+ 	}
+ 
+ 	if (!added)
+ 		skb_trim(skb, skb_len);
+ 	else
+ 		*len = skb->len - skb_len - 2;
+ }
+ 
+ static void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,
+ 					struct sk_buff *skb, u16 capab,
+ 					const struct element *ext_capa,
+ 					const u16 *outer_present_elems)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_multi_link_elem *ml_elem;
+ 	struct ieee80211_mle_basic_common_info *common;
+ 	const struct wiphy_iftype_ext_capab *ift_ext_capa;
+ 	__le16 eml_capa = 0, mld_capa_ops = 0;
+ 	unsigned int link_id;
+ 	u8 *ml_elem_len;
+ 	void *capab_pos;
+ 
+ 	if (!sdata->vif.valid_links)
+ 		return;
+ 
+ 	ift_ext_capa = cfg80211_get_iftype_ext_capa(local->hw.wiphy,
+ 						    ieee80211_vif_type_p2p(&sdata->vif));
+ 	if (ift_ext_capa) {
+ 		eml_capa = cpu_to_le16(ift_ext_capa->eml_capabilities);
+ 		mld_capa_ops = cpu_to_le16(ift_ext_capa->mld_capa_and_ops);
+ 	}
+ 
+ 	skb_put_u8(skb, WLAN_EID_EXTENSION);
+ 	ml_elem_len = skb_put(skb, 1);
+ 	skb_put_u8(skb, WLAN_EID_EXT_EHT_MULTI_LINK);
+ 	ml_elem = skb_put(skb, sizeof(*ml_elem));
+ 	ml_elem->control =
+ 		cpu_to_le16(IEEE80211_ML_CONTROL_TYPE_BASIC |
+ 			    IEEE80211_MLC_BASIC_PRES_EML_CAPA |
+ 			    IEEE80211_MLC_BASIC_PRES_MLD_CAPA_OP);
+ 	common = skb_put(skb, sizeof(*common));
+ 	common->len = sizeof(*common) +
+ 		      2 + /* EML capabilities */
+ 		      2;  /* MLD capa/ops */
+ 	memcpy(common->mld_mac_addr, sdata->vif.addr, ETH_ALEN);
+ 	skb_put_data(skb, &eml_capa, sizeof(eml_capa));
+ 	/* need indication from userspace to support this */
+ 	mld_capa_ops &= ~cpu_to_le16(IEEE80211_MLD_CAP_OP_TID_TO_LINK_MAP_NEG_SUPP);
+ 	skb_put_data(skb, &mld_capa_ops, sizeof(mld_capa_ops));
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		u16 link_present_elems[PRESENT_ELEMS_MAX] = {};
+ 		const u8 *extra_elems;
+ 		size_t extra_elems_len;
+ 		size_t extra_used;
+ 		u8 *subelem_len = NULL;
+ 		__le16 ctrl;
+ 
+ 		if (!assoc_data->link[link_id].bss ||
+ 		    link_id == assoc_data->assoc_link_id)
+ 			continue;
+ 
+ 		extra_elems = assoc_data->link[link_id].elems;
+ 		extra_elems_len = assoc_data->link[link_id].elems_len;
+ 
+ 		skb_put_u8(skb, IEEE80211_MLE_SUBELEM_PER_STA_PROFILE);
+ 		subelem_len = skb_put(skb, 1);
+ 
+ 		ctrl = cpu_to_le16(link_id |
+ 				   IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE |
+ 				   IEEE80211_MLE_STA_CONTROL_STA_MAC_ADDR_PRESENT);
+ 		skb_put_data(skb, &ctrl, sizeof(ctrl));
+ 		skb_put_u8(skb, 1 + ETH_ALEN); /* STA Info Length */
+ 		skb_put_data(skb, assoc_data->link[link_id].addr,
+ 			     ETH_ALEN);
+ 		/*
+ 		 * Now add the contents of the (re)association request,
+ 		 * but the "listen interval" and "current AP address"
+ 		 * (if applicable) are skipped. So we only have
+ 		 * the capability field (remember the position and fill
+ 		 * later), followed by the elements added below by
+ 		 * calling ieee80211_assoc_link_elems().
+ 		 */
+ 		capab_pos = skb_put(skb, 2);
+ 
+ 		extra_used = ieee80211_assoc_link_elems(sdata, skb, &capab,
+ 							ext_capa,
+ 							extra_elems,
+ 							extra_elems_len,
+ 							link_id, NULL,
+ 							link_present_elems);
+ 		if (extra_elems)
+ 			skb_put_data(skb, extra_elems + extra_used,
+ 				     extra_elems_len - extra_used);
+ 
+ 		put_unaligned_le16(capab, capab_pos);
+ 
+ 		ieee80211_add_non_inheritance_elem(skb, outer_present_elems,
+ 						   link_present_elems);
+ 
+ 		ieee80211_fragment_element(skb, subelem_len);
+ 	}
+ 
+ 	ieee80211_fragment_element(skb, ml_elem_len);
+ }
+ 
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
  {
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
++<<<<<<< HEAD
 +	struct sk_buff *skb;
 +	struct ieee80211_mgmt *mgmt;
 +	u8 *pos, qos_info, *ie_start;
 +	size_t offset = 0, noffset;
 +	int i, count, rates_len, supp_rates_len, shift;
 +	u16 capab;
 +	struct ieee80211_supported_band *sband;
 +	struct ieee80211_chanctx_conf *chanctx_conf;
 +	struct ieee80211_channel *chan;
 +	u32 rates = 0;
++=======
+ 	struct ieee80211_link_data *link;
+ 	struct sk_buff *skb;
+ 	struct ieee80211_mgmt *mgmt;
+ 	u8 *pos, qos_info, *ie_start;
+ 	size_t offset, noffset;
+ 	u16 capab = WLAN_CAPABILITY_ESS, link_capab;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	__le16 listen_int;
  	struct element *ext_capa = NULL;
  	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
- 	const struct ieee80211_sband_iftype_data *iftd;
  	struct ieee80211_prep_tx_info info = {};
++<<<<<<< HEAD
++=======
+ 	unsigned int link_id, n_links = 0;
+ 	u16 present_elems[PRESENT_ELEMS_MAX] = {};
+ 	const u8 *bssid;
+ 	void *capab_pos;
+ 	size_t size;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	int ret;
  
  	/* we know it's writable, cast away the const */
@@@ -797,101 -1318,119 +1351,183 @@@
  
  	sdata_assert_lock(sdata);
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 +	if (WARN_ON(!chanctx_conf)) {
 +		rcu_read_unlock();
 +		return -EINVAL;
 +	}
 +	chan = chanctx_conf->def.chan;
 +	rcu_read_unlock();
 +	sband = local->hw.wiphy->bands[chan->band];
 +	shift = ieee80211_vif_get_shift(&sdata->vif);
 +
 +	if (assoc_data->supp_rates_len) {
 +		/*
 +		 * Get all rates supported by the device and the AP as
 +		 * some APs don't like getting a superset of their rates
 +		 * in the association request (e.g. D-Link DAP 1353 in
 +		 * b-only mode)...
 +		 */
 +		rates_len = ieee80211_parse_bitrates(&chanctx_conf->def, sband,
 +						     assoc_data->supp_rates,
 +						     assoc_data->supp_rates_len,
 +						     &rates);
 +	} else {
 +		/*
 +		 * In case AP not provide any supported rates information
 +		 * before association, we send information element(s) with
 +		 * all rates that we support.
 +		 */
 +		rates_len = 0;
 +		for (i = 0; i < sband->n_bitrates; i++) {
 +			rates |= BIT(i);
 +			rates_len++;
 +		}
 +	}
- 
- 	iftd = ieee80211_get_sband_iftype_data(sband, iftype);
- 
++=======
+ 	size = local->hw.extra_tx_headroom +
+ 	       sizeof(*mgmt) + /* bit too much but doesn't matter */
+ 	       2 + assoc_data->ssid_len + /* SSID */
+ 	       assoc_data->ie_len + /* extra IEs */
+ 	       (assoc_data->fils_kek_len ? 16 /* AES-SIV */ : 0) +
+ 	       9; /* WMM */
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
+ 		const struct ieee80211_sband_iftype_data *iftd;
+ 		struct ieee80211_supported_band *sband;
+ 
++<<<<<<< HEAD
 +	skb = alloc_skb(local->hw.extra_tx_headroom +
 +			sizeof(*mgmt) + /* bit too much but doesn't matter */
 +			2 + assoc_data->ssid_len + /* SSID */
 +			4 + rates_len + /* (extended) rates */
 +			4 + /* power capability */
 +			2 + 2 * sband->n_channels + /* supported channels */
 +			2 + sizeof(struct ieee80211_ht_cap) + /* HT */
 +			2 + sizeof(struct ieee80211_vht_cap) + /* VHT */
 +			2 + 1 + sizeof(struct ieee80211_he_cap_elem) + /* HE */
 +				sizeof(struct ieee80211_he_mcs_nss_supp) +
 +				IEEE80211_HE_PPE_THRES_MAX_LEN +
 +			2 + 1 + sizeof(struct ieee80211_he_6ghz_capa) +
 +			2 + 1 + sizeof(struct ieee80211_eht_cap_elem) + /* EHT */
++=======
+ 		if (!cbss)
+ 			continue;
+ 
+ 		sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
+ 		n_links++;
+ 		/* add STA profile elements length */
+ 		size += assoc_data->link[link_id].elems_len;
+ 		/* and supported rates length */
+ 		size += 4 + sband->n_bitrates;
+ 		/* supported channels */
+ 		size += 2 + 2 * sband->n_channels;
+ 
+ 		iftd = ieee80211_get_sband_iftype_data(sband, iftype);
+ 		if (iftd)
+ 			size += iftd->vendor_elems.len;
+ 
+ 		/* power capability */
+ 		size += 4;
+ 
+ 		/* HT, VHT, HE, EHT */
+ 		size += 2 + sizeof(struct ieee80211_ht_cap);
+ 		size += 2 + sizeof(struct ieee80211_vht_cap);
+ 		size += 2 + 1 + sizeof(struct ieee80211_he_cap_elem) +
+ 			sizeof(struct ieee80211_he_mcs_nss_supp) +
+ 			IEEE80211_HE_PPE_THRES_MAX_LEN;
+ 
+ 		if (sband->band == NL80211_BAND_6GHZ)
+ 			size += 2 + 1 + sizeof(struct ieee80211_he_6ghz_capa);
+ 
+ 		size += 2 + 1 + sizeof(struct ieee80211_eht_cap_elem) +
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  			sizeof(struct ieee80211_eht_mcs_nss_supp) +
- 			IEEE80211_EHT_PPE_THRES_MAX_LEN +
- 			assoc_data->ie_len + /* extra IEs */
- 			(assoc_data->fils_kek_len ? 16 /* AES-SIV */ : 0) +
- 			9 + /* WMM */
- 			(iftd ? iftd->vendor_elems.len : 0),
- 			GFP_KERNEL);
+ 			IEEE80211_EHT_PPE_THRES_MAX_LEN;
+ 
+ 		/* non-inheritance element */
+ 		size += 2 + 2 + PRESENT_ELEMS_MAX;
+ 
+ 		/* should be the same across all BSSes */
+ 		if (cbss->capability & WLAN_CAPABILITY_PRIVACY)
+ 			capab |= WLAN_CAPABILITY_PRIVACY;
+ 	}
+ 
+ 	if (sdata->vif.valid_links) {
+ 		/* consider the multi-link element with STA profile */
+ 		size += sizeof(struct ieee80211_multi_link_elem);
+ 		/* max common info field in basic multi-link element */
+ 		size += sizeof(struct ieee80211_mle_basic_common_info) +
+ 			2 + /* capa & op */
+ 			2; /* EML capa */
+ 
+ 		/*
+ 		 * The capability elements were already considered above;
+ 		 * note this over-estimates a bit because there's no
+ 		 * STA profile for the assoc link.
+ 		 */
+ 		size += (n_links - 1) *
+ 			(1 + 1 + /* subelement ID/length */
+ 			 2 + /* STA control */
+ 			 1 + ETH_ALEN + 2 /* STA Info field */);
+ 	}
+ 
+ 	link = sdata_dereference(sdata->link[assoc_data->assoc_link_id], sdata);
+ 	if (WARN_ON(!link))
+ 		return -EINVAL;
+ 
+ 	if (WARN_ON(!assoc_data->link[assoc_data->assoc_link_id].bss))
+ 		return -EINVAL;
+ 
+ 	bssid = assoc_data->link[assoc_data->assoc_link_id].bss->bssid;
+ 
+ 	skb = alloc_skb(size, GFP_KERNEL);
  	if (!skb)
  		return -ENOMEM;
  
  	skb_reserve(skb, local->hw.extra_tx_headroom);
  
++<<<<<<< HEAD
 +	capab = WLAN_CAPABILITY_ESS;
 +
 +	if (sband->band == NL80211_BAND_2GHZ) {
 +		capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
 +		capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;
 +	}
 +
 +	if (assoc_data->capability & WLAN_CAPABILITY_PRIVACY)
 +		capab |= WLAN_CAPABILITY_PRIVACY;
 +
 +	if ((assoc_data->capability & WLAN_CAPABILITY_SPECTRUM_MGMT) &&
 +	    ieee80211_hw_check(&local->hw, SPECTRUM_MGMT))
 +		capab |= WLAN_CAPABILITY_SPECTRUM_MGMT;
 +
++=======
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	if (ifmgd->flags & IEEE80211_STA_ENABLE_RRM)
  		capab |= WLAN_CAPABILITY_RADIO_MEASURE;
  
 -	/* Set MBSSID support for HE AP if needed */
 -	if (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&
 -	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
 -	    ext_capa && ext_capa->datalen >= 3)
 -		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
 -
  	mgmt = skb_put_zero(skb, 24);
- 	memcpy(mgmt->da, assoc_data->bss->bssid, ETH_ALEN);
- 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
- 	memcpy(mgmt->bssid, assoc_data->bss->bssid, ETH_ALEN);
+ 	memcpy(mgmt->da, bssid, ETH_ALEN);
+ 	memcpy(mgmt->sa, link->conf->addr, ETH_ALEN);
+ 	memcpy(mgmt->bssid, bssid, ETH_ALEN);
  
- 	listen_int = cpu_to_le16(sband->band == NL80211_BAND_S1GHZ ?
+ 	listen_int = cpu_to_le16(assoc_data->s1g ?
  			ieee80211_encode_usf(local->hw.conf.listen_interval) :
  			local->hw.conf.listen_interval);
- 	if (!is_zero_ether_addr(assoc_data->prev_bssid)) {
+ 	if (!is_zero_ether_addr(assoc_data->prev_ap_addr)) {
  		skb_put(skb, 10);
  		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
  						  IEEE80211_STYPE_REASSOC_REQ);
 -		capab_pos = &mgmt->u.reassoc_req.capab_info;
 +		mgmt->u.reassoc_req.capab_info = cpu_to_le16(capab);
  		mgmt->u.reassoc_req.listen_interval = listen_int;
- 		memcpy(mgmt->u.reassoc_req.current_ap, assoc_data->prev_bssid,
- 		       ETH_ALEN);
+ 		memcpy(mgmt->u.reassoc_req.current_ap,
+ 		       assoc_data->prev_ap_addr, ETH_ALEN);
  		info.subtype = IEEE80211_STYPE_REASSOC_REQ;
  	} else {
  		skb_put(skb, 4);
@@@ -909,205 -1448,17 +1545,217 @@@
  	*pos++ = assoc_data->ssid_len;
  	memcpy(pos, assoc_data->ssid, assoc_data->ssid_len);
  
++<<<<<<< HEAD
 +	if (sband->band == NL80211_BAND_S1GHZ)
 +		goto skip_rates;
++=======
+ 	/* add the elements for the assoc (main) link */
+ 	link_capab = capab;
+ 	offset = ieee80211_assoc_link_elems(sdata, skb, &link_capab,
+ 					    ext_capa,
+ 					    assoc_data->ie,
+ 					    assoc_data->ie_len,
+ 					    assoc_data->assoc_link_id, link,
+ 					    present_elems);
+ 	put_unaligned_le16(link_capab, capab_pos);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
 +
 +	/* add all rates which were marked to be used above */
 +	supp_rates_len = rates_len;
 +	if (supp_rates_len > 8)
 +		supp_rates_len = 8;
 +
 +	pos = skb_put(skb, supp_rates_len + 2);
 +	*pos++ = WLAN_EID_SUPP_RATES;
 +	*pos++ = supp_rates_len;
 +
 +	count = 0;
 +	for (i = 0; i < sband->n_bitrates; i++) {
 +		if (BIT(i) & rates) {
 +			int rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
 +						5 * (1 << shift));
 +			*pos++ = (u8) rate;
 +			if (++count == 8)
 +				break;
 +		}
 +	}
 +
 +	if (rates_len > count) {
 +		pos = skb_put(skb, rates_len - count + 2);
 +		*pos++ = WLAN_EID_EXT_SUPP_RATES;
 +		*pos++ = rates_len - count;
 +
 +		for (i++; i < sband->n_bitrates; i++) {
 +			if (BIT(i) & rates) {
 +				int rate;
 +				rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
 +						    5 * (1 << shift));
 +				*pos++ = (u8) rate;
 +			}
 +		}
 +	}
 +
 +skip_rates:
 +	if (capab & WLAN_CAPABILITY_SPECTRUM_MGMT ||
 +	    capab & WLAN_CAPABILITY_RADIO_MEASURE) {
 +		pos = skb_put(skb, 4);
 +		*pos++ = WLAN_EID_PWR_CAPABILITY;
 +		*pos++ = 2;
 +		*pos++ = 0; /* min tx power */
 +		 /* max tx power */
 +		*pos++ = ieee80211_chandef_max_power(&chanctx_conf->def);
 +	}
 +
 +	/*
 +	 * Per spec, we shouldn't include the list of channels if we advertise
 +	 * support for extended channel switching, but we've always done that;
 +	 * (for now?) apply this restriction only on the (new) 6 GHz band.
 +	 */
 +	if (capab & WLAN_CAPABILITY_SPECTRUM_MGMT &&
 +	    (sband->band != NL80211_BAND_6GHZ ||
 +	     !ext_capa || ext_capa->datalen < 1 ||
 +	     !(ext_capa->data[0] & WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING))) {
 +		/* TODO: get this in reg domain format */
 +		pos = skb_put(skb, 2 * sband->n_channels + 2);
 +		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
 +		*pos++ = 2 * sband->n_channels;
 +		for (i = 0; i < sband->n_channels; i++) {
 +			int cf = sband->channels[i].center_freq;
 +
 +			*pos++ = ieee80211_frequency_to_channel(cf);
 +			*pos++ = 1; /* one channel in the subband*/
 +		}
 +	}
  
 -	/* if present, add any custom non-vendor IEs */
 +	/* Set MBSSID support for HE AP if needed */
 +	if (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) && assoc_data->ie_len &&
 +	    ext_capa && ext_capa->datalen >= 3)
 +		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
 +
 +	/* if present, add any custom IEs that go before HT */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_ht[] = {
 +			WLAN_EID_SSID,
 +			WLAN_EID_SUPP_RATES,
 +			WLAN_EID_EXT_SUPP_RATES,
 +			WLAN_EID_PWR_CAPABILITY,
 +			WLAN_EID_SUPPORTED_CHANNELS,
 +			WLAN_EID_RSN,
 +			WLAN_EID_QOS_CAPA,
 +			WLAN_EID_RRM_ENABLED_CAPABILITIES,
 +			WLAN_EID_MOBILITY_DOMAIN,
 +			WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
 +			WLAN_EID_RIC_DATA,		/* reassoc only */
 +			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 +		};
 +		static const u8 after_ric[] = {
 +			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 +			WLAN_EID_HT_CAPABILITY,
 +			WLAN_EID_BSS_COEX_2040,
 +			/* luckily this is almost always there */
 +			WLAN_EID_EXT_CAPABILITY,
 +			WLAN_EID_QOS_TRAFFIC_CAPA,
 +			WLAN_EID_TIM_BCAST_REQ,
 +			WLAN_EID_INTERWORKING,
 +			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
 +			WLAN_EID_VHT_CAPABILITY,
 +			WLAN_EID_OPMODE_NOTIF,
 +		};
 +
 +		noffset = ieee80211_ie_split_ric(assoc_data->ie,
 +						 assoc_data->ie_len,
 +						 before_ht,
 +						 ARRAY_SIZE(before_ht),
 +						 after_ric,
 +						 ARRAY_SIZE(after_ric),
 +						 offset);
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	if (WARN_ON_ONCE((ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +			 !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +
 +	if (sband->band != NL80211_BAND_6GHZ &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
 +		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
 +				    sband, chan, sdata->smps_mode);
 +
 +	/* if present, add any custom IEs that go before VHT */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_vht[] = {
 +			/*
 +			 * no need to list the ones split off before HT
 +			 * or generated here
 +			 */
 +			WLAN_EID_BSS_COEX_2040,
 +			WLAN_EID_EXT_CAPABILITY,
 +			WLAN_EID_QOS_TRAFFIC_CAPA,
 +			WLAN_EID_TIM_BCAST_REQ,
 +			WLAN_EID_INTERWORKING,
 +			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
 +		};
 +
 +		/* RIC already taken above, so no need to handle here anymore */
 +		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
 +					     before_vht, ARRAY_SIZE(before_vht),
 +					     offset);
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	/* if present, add any custom IEs that go before HE */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_he[] = {
 +			/*
 +			 * no need to list the ones split off before VHT
 +			 * or generated here
 +			 */
 +			WLAN_EID_OPMODE_NOTIF,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
 +			/* 11ai elements */
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
 +			/* TODO: add 11ah/11aj/11ak elements */
 +		};
 +
 +		/* RIC already taken above, so no need to handle here anymore */
 +		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
 +					     before_he, ARRAY_SIZE(before_he),
 +					     offset);
 +		pos = skb_put(skb, noffset - offset);
 +		memcpy(pos, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	if (sband->band != NL80211_BAND_6GHZ &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_add_vht_ie(sdata, skb, sband,
 +				     &assoc_data->ap_vht_cap);
 +
 +	/*
 +	 * If AP doesn't support HT, mark HE and EHT as disabled.
 +	 * If on the 5GHz band, make sure it supports VHT.
 +	 */
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT ||
 +	    (sband->band == NL80211_BAND_5GHZ &&
 +	     ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +			        IEEE80211_STA_DISABLE_EHT;
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		ieee80211_add_he_ie(sdata, skb, sband);
 +
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
 +			ieee80211_add_eht_ie(sdata, skb, sband);
 +	}
 +
 +	/* if present, add any custom non-vendor IEs that go after HE */
  	if (assoc_data->ie_len) {
  		noffset = ieee80211_ie_split_vendor(assoc_data->ie,
  						    assoc_data->ie_len,
@@@ -2289,24 -2649,23 +2937,33 @@@ static u32 ieee80211_handle_bss_capabil
  	return changed;
  }
  
 -static u32 ieee80211_link_set_associated(struct ieee80211_link_data *link,
 -					 struct cfg80211_bss *cbss)
 +static void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,
 +				     struct cfg80211_bss *cbss,
 +				     u32 bss_info_changed)
  {
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 -	struct ieee80211_bss_conf *bss_conf = link->conf;
  	struct ieee80211_bss *bss = (void *)cbss->priv;
++<<<<<<< HEAD
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +
 +	bss_info_changed |= BSS_CHANGED_ASSOC;
 +	bss_info_changed |= ieee80211_handle_bss_capability(link,
 +		bss_conf->assoc_capability, bss->has_erp_value, bss->erp_value);
++=======
+ 	u32 changed = BSS_CHANGED_QOS;
+ 
+ 	/* not really used in MLO */
+ 	sdata->u.mgd.beacon_timeout =
+ 		usecs_to_jiffies(ieee80211_tu_to_usec(beacon_loss_count *
+ 						      bss_conf->beacon_int));
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
 -	changed |= ieee80211_handle_bss_capability(link,
 -						   bss_conf->assoc_capability,
 -						   bss->has_erp_value,
 -						   bss->erp_value);
 +	sdata->u.mgd.beacon_timeout = usecs_to_jiffies(ieee80211_tu_to_usec(
 +		beacon_loss_count * bss_conf->beacon_int));
 +
 +	sdata->u.mgd.associated = true;
 +	sdata->u.mgd.assoc_bss = cbss;
 +	memcpy(sdata->u.mgd.bssid, cbss->bssid, ETH_ALEN);
  
  	ieee80211_check_rate_mask(link);
  
@@@ -2335,12 -2695,7 +2992,9 @@@
  		rcu_read_unlock();
  	}
  
- 	/* just to be sure */
- 	ieee80211_stop_poll(sdata);
- 
- 	ieee80211_led_assoc(local, 1);
- 
- 	if (sdata->u.mgd.have_beacon) {
++<<<<<<< HEAD
++=======
+ 	if (link->u.mgd.have_beacon) {
  		/*
  		 * If the AP is buggy we may get here with no DTIM period
  		 * known, so assume it's 1 which is the only safe assumption
@@@ -2358,21 -2713,82 +3012,112 @@@
  	/* Tell the driver to monitor connection quality (if supported) */
  	if (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI &&
  	    bss_conf->cqm_rssi_thold)
- 		bss_info_changed |= BSS_CHANGED_CQM;
+ 		changed |= BSS_CHANGED_CQM;
+ 
+ 	return changed;
+ }
+ 
+ static void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,
+ 				     struct ieee80211_mgd_assoc_data *assoc_data,
+ 				     u64 changed[IEEE80211_MLD_MAX_NUM_LINKS])
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 	u64 vif_changed = BSS_CHANGED_ASSOC;
+ 	unsigned int link_id;
+ 
+ 	sdata->u.mgd.associated = true;
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
+ 		struct ieee80211_link_data *link;
+ 
+ 		if (!cbss)
+ 			continue;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (WARN_ON(!link))
+ 			return;
+ 
+ 		changed[link_id] |= ieee80211_link_set_associated(link, cbss);
+ 	}
+ 
+ 	memcpy(sdata->vif.cfg.ap_addr, assoc_data->ap_addr, ETH_ALEN);
+ 
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
+ 	/* just to be sure */
+ 	ieee80211_stop_poll(sdata);
+ 
+ 	ieee80211_led_assoc(local, 1);
+ 
 -	vif_cfg->assoc = 1;
++	if (sdata->u.mgd.have_beacon) {
++		/*
++		 * If the AP is buggy we may get here with no DTIM period
++		 * known, so assume it's 1 which is the only safe assumption
++		 * in that case, although if the TIM IE is broken powersave
++		 * probably just won't work at all.
++		 */
++		bss_conf->dtim_period = sdata->u.mgd.dtim_period ?: 1;
++		bss_conf->beacon_rate = bss->beacon_rate;
++		bss_info_changed |= BSS_CHANGED_BEACON_INFO;
++	} else {
++		bss_conf->beacon_rate = NULL;
++		bss_conf->dtim_period = 0;
++	}
++
++	bss_conf->assoc = 1;
++
++	/* Tell the driver to monitor connection quality (if supported) */
++	if (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI &&
++	    bss_conf->cqm_rssi_thold)
++		bss_info_changed |= BSS_CHANGED_CQM;
  
  	/* Enable ARP filtering */
++<<<<<<< HEAD
 +	if (bss_conf->arp_addr_cnt)
 +		bss_info_changed |= BSS_CHANGED_ARP_FILTER;
++=======
+ 	if (vif_cfg->arp_addr_cnt)
+ 		vif_changed |= BSS_CHANGED_ARP_FILTER;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
+ 
+ 	if (sdata->vif.valid_links) {
+ 		for (link_id = 0;
+ 		     link_id < IEEE80211_MLD_MAX_NUM_LINKS;
+ 		     link_id++) {
+ 			struct ieee80211_link_data *link;
+ 			struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
+ 
+ 			if (!cbss)
+ 				continue;
+ 
+ 			link = sdata_dereference(sdata->link[link_id], sdata);
+ 			if (WARN_ON(!link))
+ 				return;
+ 
+ 			ieee80211_link_info_change_notify(sdata, link,
+ 							  changed[link_id]);
  
- 	ieee80211_bss_info_change_notify(sdata, bss_info_changed);
+ 			ieee80211_recalc_smps(sdata, link);
+ 		}
+ 
+ 		ieee80211_vif_cfg_change_notify(sdata, vif_changed);
+ 	} else {
+ 		ieee80211_bss_info_change_notify(sdata,
+ 						 vif_changed | changed[0]);
+ 	}
  
  	mutex_lock(&local->iflist_mtx);
  	ieee80211_recalc_ps(local);
  	mutex_unlock(&local->iflist_mtx);
  
++<<<<<<< HEAD
 +	ieee80211_recalc_smps(sdata);
++=======
+ 	/* leave this here to not change ordering in non-MLO cases */
+ 	if (!sdata->vif.valid_links)
+ 		ieee80211_recalc_smps(sdata, &sdata->deflink);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	ieee80211_recalc_ps_vif(sdata);
  
  	netif_carrier_on(sdata->dev);
@@@ -2384,7 -2800,7 +3129,11 @@@ static void ieee80211_set_disassoc(stru
  {
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  	struct ieee80211_local *local = sdata->local;
++<<<<<<< HEAD
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
++=======
+ 	unsigned int link_id;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	u32 changed = 0;
  	struct ieee80211_prep_tx_info info = {
  		.subtype = stype,
@@@ -2443,9 -2862,9 +3192,15 @@@
  			drv_mgd_prepare_tx(sdata->local, sdata, &info);
  		}
  
++<<<<<<< HEAD
 +		ieee80211_send_deauth_disassoc(sdata, ifmgd->bssid,
 +					       ifmgd->bssid, stype, reason,
 +					       tx, frame_buf);
++=======
+ 		ieee80211_send_deauth_disassoc(sdata, sdata->vif.cfg.ap_addr,
+ 					       sdata->vif.cfg.ap_addr, stype,
+ 					       reason, tx, frame_buf);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	}
  
  	/* flush out frame - make sure the deauth was actually sent */
@@@ -2454,10 -2873,11 +3209,18 @@@
  
  	drv_mgd_complete_tx(sdata->local, sdata, &info);
  
++<<<<<<< HEAD
 +	/* clear bssid only after building the needed mgmt frames */
 +	eth_zero_addr(ifmgd->bssid);
 +
 +	sdata->vif.bss_conf.ssid_len = 0;
++=======
+ 	/* clear AP addr only after building the needed mgmt frames */
+ 	eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 	eth_zero_addr(sdata->vif.cfg.ap_addr);
+ 
+ 	sdata->vif.cfg.ssid_len = 0;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	/* remove AP and TDLS peers */
  	sta_info_flush(sdata);
@@@ -2514,19 -2940,30 +3279,31 @@@
  	sdata->vif.bss_conf.dtim_period = 0;
  	sdata->vif.bss_conf.beacon_rate = NULL;
  
 -	sdata->deflink.u.mgd.have_beacon = false;
 -	sdata->deflink.u.mgd.tracking_signal_avg = false;
 -	sdata->deflink.u.mgd.disable_wmm_tracking = false;
 +	ifmgd->have_beacon = false;
  
  	ifmgd->flags = 0;
 -	sdata->deflink.u.mgd.conn_flags = 0;
  	mutex_lock(&local->mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_release_channel(sdata);
++=======
+ 
+ 	for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 		struct ieee80211_link_data *link;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (!link)
+ 			continue;
+ 		ieee80211_link_release_channel(link);
+ 	}
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	sdata->vif.bss_conf.csa_active = false;
 -	sdata->deflink.u.mgd.csa_waiting_bcn = false;
 -	sdata->deflink.u.mgd.csa_ignored_same_chan = false;
 -	if (sdata->deflink.csa_block_tx) {
 +	ifmgd->csa_waiting_bcn = false;
 +	ifmgd->csa_ignored_same_chan = false;
 +	if (sdata->csa_block_tx) {
  		ieee80211_wake_vif_queues(local, sdata,
  					  IEEE80211_QUEUE_STOP_REASON_CSA);
 -		sdata->deflink.csa_block_tx = false;
 +		sdata->csa_block_tx = false;
  	}
  	mutex_unlock(&local->mtx);
  
@@@ -2534,9 -2971,12 +3311,18 @@@
  	memset(ifmgd->tx_tspec, 0, sizeof(ifmgd->tx_tspec));
  	cancel_delayed_work_sync(&ifmgd->tx_tspec_wk);
  
++<<<<<<< HEAD
 +	bss_conf->pwr_reduction = 0;
 +	bss_conf->tx_pwr_env_num = 0;
 +	memset(bss_conf->tx_pwr_env, 0, sizeof(bss_conf->tx_pwr_env));
++=======
+ 	sdata->vif.bss_conf.pwr_reduction = 0;
+ 	sdata->vif.bss_conf.tx_pwr_env_num = 0;
+ 	memset(sdata->vif.bss_conf.tx_pwr_env, 0,
+ 	       sizeof(sdata->vif.bss_conf.tx_pwr_env));
+ 
+ 	ieee80211_vif_set_links(sdata, 0);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  }
  
  static void ieee80211_reset_ap_probe(struct ieee80211_sub_if_data *sdata)
@@@ -2772,11 -3219,11 +3558,11 @@@ struct sk_buff *ieee80211_ap_probereq_g
  	sdata_assert_lock(sdata);
  
  	if (ifmgd->associated)
 -		cbss = sdata->deflink.u.mgd.bss;
 +		cbss = ifmgd->assoc_bss;
  	else if (ifmgd->auth_data)
  		cbss = ifmgd->auth_data->bss;
- 	else if (ifmgd->assoc_data)
- 		cbss = ifmgd->assoc_data->bss;
+ 	else if (ifmgd->assoc_data && ifmgd->assoc_data->link[0].bss)
+ 		cbss = ifmgd->assoc_data->link[0].bss;
  	else
  		return NULL;
  
@@@ -2830,14 -3277,30 +3616,38 @@@ static void __ieee80211_disconnect(stru
  		return;
  	}
  
++<<<<<<< HEAD
 +	tx = !sdata->csa_block_tx;
++=======
+ 	/* in MLO assume we have a link where we can TX the frame */
+ 	tx = sdata->vif.valid_links || !sdata->deflink.csa_block_tx;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	if (!ifmgd->driver_disconnect) {
+ 		unsigned int link_id;
+ 
  		/*
  		 * AP is probably out of range (or not reachable for another
- 		 * reason) so remove the bss struct for that AP.
+ 		 * reason) so remove the bss structs for that AP. In the case
+ 		 * of multi-link, it's not clear that all of them really are
+ 		 * out of range, but if they weren't the driver likely would
+ 		 * have switched to just have a single link active?
  		 */
++<<<<<<< HEAD
 +		cfg80211_unlink_bss(local->hw.wiphy, ifmgd->assoc_bss);
++=======
+ 		for (link_id = 0;
+ 		     link_id < ARRAY_SIZE(sdata->link);
+ 		     link_id++) {
+ 			struct ieee80211_link_data *link;
+ 
+ 			link = sdata_dereference(sdata->link[link_id], sdata);
+ 			if (!link)
+ 				continue;
+ 			cfg80211_unlink_bss(local->hw.wiphy, link->u.mgd.bss);
+ 			link->u.mgd.bss = NULL;
+ 		}
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	}
  
  	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
@@@ -2952,14 -3415,19 +3762,24 @@@ static void ieee80211_destroy_auth_data
  		 * which is not relevant anymore.
  		 */
  		del_timer_sync(&sdata->u.mgd.timer);
- 		sta_info_destroy_addr(sdata, auth_data->bss->bssid);
+ 		sta_info_destroy_addr(sdata, auth_data->ap_addr);
  
++<<<<<<< HEAD
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 		/* other links are destroyed */
+ 		sdata->deflink.u.mgd.conn_flags = 0;
+ 		eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		sdata->u.mgd.flags = 0;
  		mutex_lock(&sdata->local->mtx);
 -		ieee80211_link_release_channel(&sdata->deflink);
 +		ieee80211_vif_release_channel(sdata);
  		mutex_unlock(&sdata->local->mtx);
+ 
+ 		ieee80211_vif_set_links(sdata, 0);
  	}
  
  	cfg80211_put_bss(sdata->local->hw.wiphy, auth_data->bss);
@@@ -2988,10 -3456,12 +3808,10 @@@ static void ieee80211_destroy_assoc_dat
  		 * which is not relevant anymore.
  		 */
  		del_timer_sync(&sdata->u.mgd.timer);
- 		sta_info_destroy_addr(sdata, assoc_data->bss->bssid);
+ 		sta_info_destroy_addr(sdata, assoc_data->ap_addr);
  
 -		sdata->deflink.u.mgd.conn_flags = 0;
 -		eth_zero_addr(sdata->deflink.u.mgd.bssid);
 -		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
 -						  BSS_CHANGED_BSSID);
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
  		sdata->u.mgd.flags = 0;
  		sdata->vif.bss_conf.mu_mimo_owner = false;
  
@@@ -3043,10 -3524,10 +3874,14 @@@ static void ieee80211_auth_challenge(st
  			    auth_data->key_idx, tx_flags);
  }
  
 -static bool ieee80211_mark_sta_auth(struct ieee80211_sub_if_data *sdata)
 +static bool ieee80211_mark_sta_auth(struct ieee80211_sub_if_data *sdata,
 +				    const u8 *bssid)
  {
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
++<<<<<<< HEAD
++=======
+ 	const u8 *ap_addr = ifmgd->auth_data->ap_addr;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	struct sta_info *sta;
  	bool result = true;
  
@@@ -3260,11 -3738,9 +4092,15 @@@ static void ieee80211_rx_mgmt_deauth(st
  	}
  
  	if (ifmgd->associated &&
++<<<<<<< HEAD
 +	    ether_addr_equal(mgmt->bssid, ifmgd->bssid)) {
 +		const u8 *bssid = ifmgd->bssid;
 +
++=======
+ 	    ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr)) {
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		sdata_info(sdata, "deauthenticated from %pM (Reason: %u=%s)\n",
- 			   bssid, reason_code,
+ 			   sdata->vif.cfg.ap_addr, reason_code,
  			   ieee80211_get_reason_code_string(reason_code));
  
  		ieee80211_set_disassoc(sdata, 0, 0, false, NULL);
@@@ -3303,7 -3777,7 +4137,11 @@@ static void ieee80211_rx_mgmt_disassoc(
  		return;
  
  	if (!ifmgd->associated ||
++<<<<<<< HEAD
 +	    !ether_addr_equal(mgmt->bssid, ifmgd->bssid))
++=======
+ 	    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		return;
  
  	reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
@@@ -3417,49 -3891,39 +4255,66 @@@ static bool ieee80211_twt_bcast_support
  			IEEE80211_HE_MAC_CAP2_BCAST_TWT);
  }
  
 -static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,
 -					struct link_sta_info *link_sta,
 -					struct cfg80211_bss *cbss,
 -					struct ieee80211_mgmt *mgmt,
 -					const u8 *elem_start,
 -					unsigned int elem_len,
 -					u64 *changed)
 +static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
 +				    struct cfg80211_bss *cbss,
 +				    struct ieee80211_mgmt *mgmt, size_t len,
 +				    struct ieee802_11_elems *elems)
  {
 -	struct ieee80211_sub_if_data *sdata = link->sdata;
 -	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
 -	struct ieee80211_bss_conf *bss_conf = link->conf;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  	struct ieee80211_local *local = sdata->local;
 -	struct ieee80211_elems_parse_params parse_params = {
 -		.start = elem_start,
++<<<<<<< HEAD
 +	struct ieee80211_supported_band *sband;
 +	struct sta_info *sta;
 +	u16 capab_info, aid;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +	const struct cfg80211_bss_ies *bss_ies = NULL;
 +	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
++=======
++	struct ieee80211_elems_parse_params parse_params = {
++		.start = elem_start,
+ 		.len = elem_len,
+ 		.bss = cbss,
+ 		.link_id = link == &sdata->deflink ? -1 : link->link_id,
+ 	};
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
  	bool is_s1g = cbss->channel->band == NL80211_BAND_S1GHZ;
 -	const struct cfg80211_bss_ies *bss_ies = NULL;
 -	struct ieee80211_supported_band *sband;
 -	struct ieee802_11_elems *elems;
 -	u16 capab_info;
 +	u32 changed = 0;
 +	int err;
  	bool ret;
  
++<<<<<<< HEAD
++=======
+ 	elems = ieee802_11_parse_elems_full(&parse_params);
+ 	if (!elems)
+ 		return false;
+ 
+ 	/* FIXME: use from STA profile element after parsing that */
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
  
 +	if (elems->aid_resp)
 +		aid = le16_to_cpu(elems->aid_resp->aid);
 +	else if (is_s1g)
 +		aid = 0; /* TODO */
 +	else
 +		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
 +
 +	/*
 +	 * The 5 MSB of the AID field are reserved
 +	 * (802.11-2016 9.4.1.8 AID field)
 +	 */
 +	aid &= 0x7ff;
 +
 +	ifmgd->broken_ap = false;
 +
 +	if (aid == 0 || aid > IEEE80211_MAX_AID) {
 +		sdata_info(sdata, "invalid AID value %d (out of range), turn off PS\n",
 +			   aid);
 +		aid = 0;
 +		ifmgd->broken_ap = true;
 +	}
 +
  	if (!is_s1g && !elems->supp_rates) {
  		sdata_info(sdata, "no SuppRates element in AssocResp\n");
  		ret = false;
@@@ -3696,27 -4143,741 +4551,744 @@@
  	}
  
  	/*
- 	 * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data
- 	 * in their association response, so ignore that data for our own
- 	 * configuration. If it changed since the last beacon, we'll get the
- 	 * next beacon and update then.
+ 	 * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data
+ 	 * in their association response, so ignore that data for our own
+ 	 * configuration. If it changed since the last beacon, we'll get the
+ 	 * next beacon and update then.
+ 	 */
+ 
+ 	/*
+ 	 * If an operating mode notification IE is present, override the
+ 	 * NSS calculation (that would be done in rate_control_rate_init())
+ 	 * and use the # of streams from that element.
+ 	 */
+ 	if (elems->opmode_notif &&
+ 	    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {
+ 		u8 nss;
+ 
+ 		nss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;
+ 		nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
+ 		nss += 1;
 -		link_sta->pub->rx_nss = nss;
++		sta->sta.rx_nss = nss;
+ 	}
+ 
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Always handle WMM once after association regardless
+ 	 * of the first value the AP uses. Setting -1 here has
+ 	 * that effect because the AP values is an unsigned
+ 	 * 4-bit value.
+ 	 */
+ 	link->u.mgd.wmm_last_param_set = -1;
+ 	link->u.mgd.mu_edca_last_param_set = -1;
+ 
+ 	if (link->u.mgd.disable_wmm_tracking) {
+ 		ieee80211_set_wmm_default(link, false, false);
+ 	} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 					     elems->wmm_param_len,
+ 					     elems->mu_edca_param_set)) {
+ 		/* still enable QoS since we might have HT/VHT */
+ 		ieee80211_set_wmm_default(link, false, true);
+ 		/* disable WMM tracking in this case to disable
+ 		 * tracking WMM parameter changes in the beacon if
+ 		 * the parameters weren't actually valid. Doing so
+ 		 * avoids changing parameters very strangely when
+ 		 * the AP is going back and forth between valid and
+ 		 * invalid parameters.
+ 		 */
+ 		link->u.mgd.disable_wmm_tracking = true;
+ 	}
+ 
+ 	if (elems->max_idle_period_ie) {
+ 		bss_conf->max_idle_period =
+ 			le16_to_cpu(elems->max_idle_period_ie->max_idle_period);
+ 		bss_conf->protected_keep_alive =
+ 			!!(elems->max_idle_period_ie->idle_options &
+ 			   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);
+ 		*changed |= BSS_CHANGED_KEEP_ALIVE;
+ 	} else {
+ 		bss_conf->max_idle_period = 0;
+ 		bss_conf->protected_keep_alive = false;
+ 	}
+ 
+ 	/* set assoc capability (AID was already set earlier),
+ 	 * ieee80211_set_associated() will tell the driver */
+ 	bss_conf->assoc_capability = capab_info;
+ 
+ 	ret = true;
+ out:
+ 	kfree(elems);
+ 	kfree(bss_ies);
+ 	return ret;
+ }
+ 
+ static int ieee80211_mgd_setup_link_sta(struct ieee80211_link_data *link,
+ 					struct sta_info *sta,
+ 					struct ieee80211_link_sta *link_sta,
+ 					struct cfg80211_bss *cbss)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	u32 rates = 0, basic_rates = 0;
+ 	bool have_higher_than_11mbit = false;
+ 	int min_rate = INT_MAX, min_rate_index = -1;
+ 	/* this is clearly wrong for MLO but we'll just remove it later */
+ 	int shift = ieee80211_vif_get_shift(&sdata->vif);
+ 	struct ieee80211_supported_band *sband;
+ 
+ 	memcpy(link_sta->addr, cbss->bssid, ETH_ALEN);
+ 
+ 	/* TODO: S1G Basic Rate Set is expressed elsewhere */
+ 	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
+ 		ieee80211_s1g_sta_rate_init(sta);
+ 		return 0;
+ 	}
+ 
+ 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
+ 	ieee80211_get_rates(sband, bss->supp_rates, bss->supp_rates_len,
+ 			    &rates, &basic_rates, &have_higher_than_11mbit,
+ 			    &min_rate, &min_rate_index, shift);
+ 
+ 	/*
+ 	 * This used to be a workaround for basic rates missing
+ 	 * in the association response frame. Now that we no
+ 	 * longer use the basic rates from there, it probably
+ 	 * doesn't happen any more, but keep the workaround so
+ 	 * in case some *other* APs are buggy in different ways
+ 	 * we can connect -- with a warning.
+ 	 * Allow this workaround only in case the AP provided at least
+ 	 * one rate.
+ 	 */
+ 	if (min_rate_index < 0) {
+ 		link_info(link, "No legacy rates in association response\n");
+ 		return -EINVAL;
+ 	} else if (!basic_rates) {
+ 		link_info(link, "No basic rates, using min rate instead\n");
+ 		basic_rates = BIT(min_rate_index);
+ 	}
+ 
+ 	if (rates)
+ 		link_sta->supp_rates[cbss->channel->band] = rates;
+ 	else
+ 		link_info(link, "No rates found, keeping mandatory only\n");
+ 
+ 	link->conf->basic_rates = basic_rates;
+ 
+ 	/* cf. IEEE 802.11 9.2.12 */
+ 	link->operating_11g_mode = sband->band == NL80211_BAND_2GHZ &&
+ 				   have_higher_than_11mbit;
+ 
+ 	return 0;
+ }
+ 
+ static u8 ieee80211_max_rx_chains(struct ieee80211_link_data *link,
+ 				  struct cfg80211_bss *cbss)
+ {
+ 	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
+ 	const struct element *ht_cap_elem, *vht_cap_elem;
+ 	const struct cfg80211_bss_ies *ies;
+ 	const struct ieee80211_ht_cap *ht_cap;
+ 	const struct ieee80211_vht_cap *vht_cap;
+ 	const struct ieee80211_he_cap_elem *he_cap;
+ 	const struct element *he_cap_elem;
+ 	u16 mcs_80_map, mcs_160_map;
+ 	int i, mcs_nss_size;
+ 	bool support_160;
+ 	u8 chains = 1;
+ 
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)
+ 		return chains;
+ 
+ 	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
+ 	if (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {
+ 		ht_cap = (void *)ht_cap_elem->data;
+ 		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
+ 		/*
+ 		 * TODO: use "Tx Maximum Number Spatial Streams Supported" and
+ 		 *	 "Tx Unequal Modulation Supported" fields.
+ 		 */
+ 	}
+ 
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
+ 		return chains;
+ 
+ 	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
+ 	if (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {
+ 		u8 nss;
+ 		u16 tx_mcs_map;
+ 
+ 		vht_cap = (void *)vht_cap_elem->data;
+ 		tx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
+ 		for (nss = 8; nss > 0; nss--) {
+ 			if (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=
+ 					IEEE80211_VHT_MCS_NOT_SUPPORTED)
+ 				break;
+ 		}
+ 		/* TODO: use "Tx Highest Supported Long GI Data Rate" field? */
+ 		chains = max(chains, nss);
+ 	}
+ 
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)
+ 		return chains;
+ 
+ 	ies = rcu_dereference(cbss->ies);
+ 	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
+ 					     ies->data, ies->len);
+ 
+ 	if (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))
+ 		return chains;
+ 
+ 	/* skip one byte ext_tag_id */
+ 	he_cap = (void *)(he_cap_elem->data + 1);
+ 	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
+ 
+ 	/* invalid HE IE */
+ 	if (he_cap_elem->datalen < 1 + mcs_nss_size + sizeof(*he_cap))
+ 		return chains;
+ 
+ 	/* mcs_nss is right after he_cap info */
+ 	he_mcs_nss_supp = (void *)(he_cap + 1);
+ 
+ 	mcs_80_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
+ 
+ 	for (i = 7; i >= 0; i--) {
+ 		u8 mcs_80 = mcs_80_map >> (2 * i) & 3;
+ 
+ 		if (mcs_80 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
+ 			chains = max_t(u8, chains, i + 1);
+ 			break;
+ 		}
+ 	}
+ 
+ 	support_160 = he_cap->phy_cap_info[0] &
+ 		      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
+ 
+ 	if (!support_160)
+ 		return chains;
+ 
+ 	mcs_160_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_160);
+ 	for (i = 7; i >= 0; i--) {
+ 		u8 mcs_160 = mcs_160_map >> (2 * i) & 3;
+ 
+ 		if (mcs_160 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
+ 			chains = max_t(u8, chains, i + 1);
+ 			break;
+ 		}
+ 	}
+ 
+ 	return chains;
+ }
+ 
+ static bool
+ ieee80211_verify_peer_he_mcs_support(struct ieee80211_sub_if_data *sdata,
+ 				     const struct cfg80211_bss_ies *ies,
+ 				     const struct ieee80211_he_operation *he_op)
+ {
+ 	const struct element *he_cap_elem;
+ 	const struct ieee80211_he_cap_elem *he_cap;
+ 	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
+ 	u16 mcs_80_map_tx, mcs_80_map_rx;
+ 	u16 ap_min_req_set;
+ 	int mcs_nss_size;
+ 	int nss;
+ 
+ 	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
+ 					     ies->data, ies->len);
+ 
+ 	/* invalid HE IE */
+ 	if (!he_cap_elem || he_cap_elem->datalen < 1 + sizeof(*he_cap)) {
+ 		sdata_info(sdata,
+ 			   "Invalid HE elem, Disable HE\n");
+ 		return false;
+ 	}
+ 
+ 	/* skip one byte ext_tag_id */
+ 	he_cap = (void *)(he_cap_elem->data + 1);
+ 	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
+ 
+ 	/* invalid HE IE */
+ 	if (he_cap_elem->datalen < 1 + sizeof(*he_cap) + mcs_nss_size) {
+ 		sdata_info(sdata,
+ 			   "Invalid HE elem with nss size, Disable HE\n");
+ 		return false;
+ 	}
+ 
+ 	/* mcs_nss is right after he_cap info */
+ 	he_mcs_nss_supp = (void *)(he_cap + 1);
+ 
+ 	mcs_80_map_tx = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
+ 	mcs_80_map_rx = le16_to_cpu(he_mcs_nss_supp->rx_mcs_80);
+ 
+ 	/* P802.11-REVme/D0.3
+ 	 * 27.1.1 Introduction to the HE PHY
+ 	 * ...
+ 	 * An HE STA shall support the following features:
+ 	 * ...
+ 	 * Single spatial stream HE-MCSs 0 to 7 (transmit and receive) in all
+ 	 * supported channel widths for HE SU PPDUs
+ 	 */
+ 	if ((mcs_80_map_tx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 	    (mcs_80_map_rx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED) {
+ 		sdata_info(sdata,
+ 			   "Missing mandatory rates for 1 Nss, rx 0x%x, tx 0x%x, disable HE\n",
+ 			   mcs_80_map_tx, mcs_80_map_rx);
+ 		return false;
+ 	}
+ 
+ 	if (!he_op)
+ 		return true;
+ 
+ 	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
+ 
+ 	/*
+ 	 * Apparently iPhone 13 (at least iOS version 15.3.1) sets this to all
+ 	 * zeroes, which is nonsense, and completely inconsistent with itself
+ 	 * (it doesn't have 8 streams). Accept the settings in this case anyway.
+ 	 */
+ 	if (!ap_min_req_set)
+ 		return true;
+ 
+ 	/* make sure the AP is consistent with itself
+ 	 *
+ 	 * P802.11-REVme/D0.3
+ 	 * 26.17.1 Basic HE BSS operation
+ 	 *
+ 	 * A STA that is operating in an HE BSS shall be able to receive and
+ 	 * transmit at each of the <HE-MCS, NSS> tuple values indicated by the
+ 	 * Basic HE-MCS And NSS Set field of the HE Operation parameter of the
+ 	 * MLME-START.request primitive and shall be able to receive at each of
+ 	 * the <HE-MCS, NSS> tuple values indicated by the Supported HE-MCS and
+ 	 * NSS Set field in the HE Capabilities parameter of the MLMESTART.request
+ 	 * primitive
+ 	 */
+ 	for (nss = 8; nss > 0; nss--) {
+ 		u8 ap_op_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
+ 		u8 ap_rx_val;
+ 		u8 ap_tx_val;
+ 
+ 		if (ap_op_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
+ 			continue;
+ 
+ 		ap_rx_val = (mcs_80_map_rx >> (2 * (nss - 1))) & 3;
+ 		ap_tx_val = (mcs_80_map_tx >> (2 * (nss - 1))) & 3;
+ 
+ 		if (ap_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 		    ap_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 		    ap_rx_val < ap_op_val || ap_tx_val < ap_op_val) {
+ 			sdata_info(sdata,
+ 				   "Invalid rates for %d Nss, rx %d, tx %d oper %d, disable HE\n",
+ 				   nss, ap_rx_val, ap_rx_val, ap_op_val);
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool
+ ieee80211_verify_sta_he_mcs_support(struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_supported_band *sband,
+ 				    const struct ieee80211_he_operation *he_op)
+ {
+ 	const struct ieee80211_sta_he_cap *sta_he_cap =
+ 		ieee80211_get_he_iftype_cap(sband,
+ 					    ieee80211_vif_type_p2p(&sdata->vif));
+ 	u16 ap_min_req_set;
+ 	int i;
+ 
+ 	if (!sta_he_cap || !he_op)
+ 		return false;
+ 
+ 	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
+ 
+ 	/*
+ 	 * Apparently iPhone 13 (at least iOS version 15.3.1) sets this to all
+ 	 * zeroes, which is nonsense, and completely inconsistent with itself
+ 	 * (it doesn't have 8 streams). Accept the settings in this case anyway.
+ 	 */
+ 	if (!ap_min_req_set)
+ 		return true;
+ 
+ 	/* Need to go over for 80MHz, 160MHz and for 80+80 */
+ 	for (i = 0; i < 3; i++) {
+ 		const struct ieee80211_he_mcs_nss_supp *sta_mcs_nss_supp =
+ 			&sta_he_cap->he_mcs_nss_supp;
+ 		u16 sta_mcs_map_rx =
+ 			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i]);
+ 		u16 sta_mcs_map_tx =
+ 			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i + 1]);
+ 		u8 nss;
+ 		bool verified = true;
+ 
+ 		/*
+ 		 * For each band there is a maximum of 8 spatial streams
+ 		 * possible. Each of the sta_mcs_map_* is a 16-bit struct built
+ 		 * of 2 bits per NSS (1-8), with the values defined in enum
+ 		 * ieee80211_he_mcs_support. Need to make sure STA TX and RX
+ 		 * capabilities aren't less than the AP's minimum requirements
+ 		 * for this HE BSS per SS.
+ 		 * It is enough to find one such band that meets the reqs.
+ 		 */
+ 		for (nss = 8; nss > 0; nss--) {
+ 			u8 sta_rx_val = (sta_mcs_map_rx >> (2 * (nss - 1))) & 3;
+ 			u8 sta_tx_val = (sta_mcs_map_tx >> (2 * (nss - 1))) & 3;
+ 			u8 ap_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
+ 
+ 			if (ap_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
+ 				continue;
+ 
+ 			/*
+ 			 * Make sure the HE AP doesn't require MCSs that aren't
+ 			 * supported by the client as required by spec
+ 			 *
+ 			 * P802.11-REVme/D0.3
+ 			 * 26.17.1 Basic HE BSS operation
+ 			 *
+ 			 * An HE STA shall not attempt to join * (MLME-JOIN.request primitive)
+ 			 * a BSS, unless it supports (i.e., is able to both transmit and
+ 			 * receive using) all of the <HE-MCS, NSS> tuples in the basic
+ 			 * HE-MCS and NSS set.
+ 			 */
+ 			if (sta_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 			    sta_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
+ 			    (ap_val > sta_rx_val) || (ap_val > sta_tx_val)) {
+ 				verified = false;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (verified)
+ 			return true;
+ 	}
+ 
+ 	/* If here, STA doesn't meet AP's HE min requirements */
+ 	return false;
+ }
+ 
+ static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
+ 				  struct ieee80211_link_data *link,
+ 				  struct cfg80211_bss *cbss,
+ 				  ieee80211_conn_flags_t *conn_flags)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	const struct ieee80211_ht_cap *ht_cap = NULL;
+ 	const struct ieee80211_ht_operation *ht_oper = NULL;
+ 	const struct ieee80211_vht_operation *vht_oper = NULL;
+ 	const struct ieee80211_he_operation *he_oper = NULL;
+ 	const struct ieee80211_eht_operation *eht_oper = NULL;
+ 	const struct ieee80211_s1g_oper_ie *s1g_oper = NULL;
+ 	struct ieee80211_supported_band *sband;
+ 	struct cfg80211_chan_def chandef;
+ 	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
+ 	bool is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	struct ieee802_11_elems *elems;
+ 	const struct cfg80211_bss_ies *ies;
+ 	int ret;
+ 	u32 i;
+ 	bool have_80mhz;
+ 
+ 	rcu_read_lock();
+ 
+ 	ies = rcu_dereference(cbss->ies);
+ 	elems = ieee802_11_parse_elems(ies->data, ies->len, false, cbss);
+ 	if (!elems) {
+ 		rcu_read_unlock();
+ 		return -ENOMEM;
+ 	}
+ 
+ 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 
+ 	*conn_flags &= ~(IEEE80211_CONN_DISABLE_40MHZ |
+ 			 IEEE80211_CONN_DISABLE_80P80MHZ |
+ 			 IEEE80211_CONN_DISABLE_160MHZ);
+ 
+ 	/* disable HT/VHT/HE if we don't support them */
+ 	if (!sband->ht_cap.ht_supported && !is_6ghz) {
+ 		mlme_dbg(sdata, "HT not supported, disabling HT/VHT/HE/EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!sband->vht_cap.vht_supported && is_5ghz) {
+ 		mlme_dbg(sdata, "VHT not supported, disabling VHT/HE/EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!ieee80211_get_he_iftype_cap(sband,
+ 					 ieee80211_vif_type_p2p(&sdata->vif))) {
+ 		mlme_dbg(sdata, "HE not supported, disabling HE and EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!ieee80211_get_eht_iftype_cap(sband,
+ 					  ieee80211_vif_type_p2p(&sdata->vif))) {
+ 		mlme_dbg(sdata, "EHT not supported, disabling EHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!(*conn_flags & IEEE80211_CONN_DISABLE_HT) && !is_6ghz) {
+ 		ht_oper = elems->ht_operation;
+ 		ht_cap = elems->ht_cap_elem;
+ 
+ 		if (!ht_cap) {
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			ht_oper = NULL;
+ 		}
+ 	}
+ 
+ 	if (!(*conn_flags & IEEE80211_CONN_DISABLE_VHT) && !is_6ghz) {
+ 		vht_oper = elems->vht_operation;
+ 		if (vht_oper && !ht_oper) {
+ 			vht_oper = NULL;
+ 			sdata_info(sdata,
+ 				   "AP advertised VHT without HT, disabling HT/VHT/HE\n");
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 		}
+ 
+ 		if (!elems->vht_cap_elem) {
+ 			sdata_info(sdata,
+ 				   "bad VHT capabilities, disabling VHT\n");
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			vht_oper = NULL;
+ 		}
+ 	}
+ 
+ 	if (!(*conn_flags & IEEE80211_CONN_DISABLE_HE)) {
+ 		he_oper = elems->he_operation;
+ 
+ 		if (link && is_6ghz) {
+ 			struct ieee80211_bss_conf *bss_conf;
+ 			u8 j = 0;
+ 
+ 			bss_conf = link->conf;
+ 
+ 			if (elems->pwr_constr_elem)
+ 				bss_conf->pwr_reduction = *elems->pwr_constr_elem;
+ 
+ 			BUILD_BUG_ON(ARRAY_SIZE(bss_conf->tx_pwr_env) !=
+ 				     ARRAY_SIZE(elems->tx_pwr_env));
+ 
+ 			for (i = 0; i < elems->tx_pwr_env_num; i++) {
+ 				if (elems->tx_pwr_env_len[i] >
+ 				    sizeof(bss_conf->tx_pwr_env[j]))
+ 					continue;
+ 
+ 				bss_conf->tx_pwr_env_num++;
+ 				memcpy(&bss_conf->tx_pwr_env[j], elems->tx_pwr_env[i],
+ 				       elems->tx_pwr_env_len[i]);
+ 				j++;
+ 			}
+ 		}
+ 
+ 		if (!ieee80211_verify_peer_he_mcs_support(sdata, ies, he_oper) ||
+ 		    !ieee80211_verify_sta_he_mcs_support(sdata, sband, he_oper))
+ 			*conn_flags |= IEEE80211_CONN_DISABLE_HE |
+ 				       IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	/*
+ 	 * EHT requires HE to be supported as well. Specifically for 6 GHz
+ 	 * channels, the operation channel information can only be deduced from
+ 	 * both the 6 GHz operation information (from the HE operation IE) and
+ 	 * EHT operation.
+ 	 */
+ 	if (!(*conn_flags &
+ 			(IEEE80211_CONN_DISABLE_HE |
+ 			 IEEE80211_CONN_DISABLE_EHT)) &&
+ 	    he_oper) {
+ 		const struct cfg80211_bss_ies *cbss_ies;
+ 		const u8 *eht_oper_ie;
+ 
+ 		cbss_ies = rcu_dereference(cbss->ies);
+ 		eht_oper_ie = cfg80211_find_ext_ie(WLAN_EID_EXT_EHT_OPERATION,
+ 						   cbss_ies->data, cbss_ies->len);
+ 		if (eht_oper_ie && eht_oper_ie[1] >=
+ 		    1 + sizeof(struct ieee80211_eht_operation))
+ 			eht_oper = (void *)(eht_oper_ie + 3);
+ 		else
+ 			eht_oper = NULL;
+ 	}
+ 
+ 	/* Allow VHT if at least one channel on the sband supports 80 MHz */
+ 	have_80mhz = false;
+ 	for (i = 0; i < sband->n_channels; i++) {
+ 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+ 						IEEE80211_CHAN_NO_80MHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
+ 		break;
+ 	}
+ 
+ 	if (!have_80mhz) {
+ 		sdata_info(sdata, "80 MHz not supported, disabling VHT\n");
+ 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 	}
+ 
+ 	if (sband->band == NL80211_BAND_S1GHZ) {
+ 		s1g_oper = elems->s1g_oper;
+ 		if (!s1g_oper)
+ 			sdata_info(sdata,
+ 				   "AP missing S1G operation element?\n");
+ 	}
+ 
+ 	*conn_flags |=
+ 		ieee80211_determine_chantype(sdata, link, *conn_flags,
+ 					     sband,
+ 					     cbss->channel,
+ 					     bss->vht_cap_info,
+ 					     ht_oper, vht_oper,
+ 					     he_oper, eht_oper,
+ 					     s1g_oper,
+ 					     &chandef, false);
+ 
+ 	if (link)
+ 		link->needed_rx_chains =
+ 			min(ieee80211_max_rx_chains(link, cbss),
+ 			    local->rx_chains);
+ 
+ 	rcu_read_unlock();
+ 	/* the element data was RCU protected so no longer valid anyway */
+ 	kfree(elems);
+ 	elems = NULL;
+ 
+ 	if (*conn_flags & IEEE80211_CONN_DISABLE_HE && is_6ghz) {
+ 		sdata_info(sdata, "Rejecting non-HE 6/7 GHz connection");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!link)
+ 		return 0;
+ 
+ 	/* will change later if needed */
+ 	link->smps_mode = IEEE80211_SMPS_OFF;
+ 
+ 	mutex_lock(&local->mtx);
+ 	/*
+ 	 * If this fails (possibly due to channel context sharing
+ 	 * on incompatible channels, e.g. 80+80 and 160 sharing the
+ 	 * same control channel) try to use a smaller bandwidth.
+ 	 */
+ 	ret = ieee80211_link_use_channel(link, &chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
+ 
+ 	/* don't downgrade for 5 and 10 MHz channels, though. */
+ 	if (chandef.width == NL80211_CHAN_WIDTH_5 ||
+ 	    chandef.width == NL80211_CHAN_WIDTH_10)
+ 		goto out;
+ 
+ 	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
+ 		*conn_flags |=
+ 			ieee80211_chandef_downgrade(&chandef);
+ 		ret = ieee80211_link_use_channel(link, &chandef,
+ 						 IEEE80211_CHANCTX_SHARED);
+ 	}
+  out:
+ 	mutex_unlock(&local->mtx);
+ 	return ret;
+ }
+ 
+ static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
+ 				    struct ieee80211_mgmt *mgmt,
+ 				    struct ieee802_11_elems *elems,
+ 				    const u8 *elem_start, unsigned int elem_len)
+ {
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id;
+ 	struct sta_info *sta;
+ 	u64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};
+ 	int err;
+ 
+ 	mutex_lock(&sdata->local->sta_mtx);
+ 	/*
+ 	 * station info was already allocated and inserted before
+ 	 * the association and should be available to us
  	 */
+ 	sta = sta_info_get(sdata, assoc_data->ap_addr);
+ 	if (WARN_ON(!sta))
+ 		goto out_err;
  
- 	/*
- 	 * If an operating mode notification IE is present, override the
- 	 * NSS calculation (that would be done in rate_control_rate_init())
- 	 * and use the # of streams from that element.
- 	 */
- 	if (elems->opmode_notif &&
- 	    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {
- 		u8 nss;
+ 	if (sdata->vif.valid_links) {
+ 		u16 valid_links = 0;
  
- 		nss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;
- 		nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
- 		nss += 1;
- 		sta->sta.rx_nss = nss;
+ 		for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 			if (!assoc_data->link[link_id].bss)
+ 				continue;
+ 			valid_links |= BIT(link_id);
+ 
+ 			if (link_id != assoc_data->assoc_link_id) {
+ 				err = ieee80211_sta_allocate_link(sta, link_id);
+ 				if (err)
+ 					goto out_err;
+ 			}
+ 		}
+ 
+ 		ieee80211_vif_set_links(sdata, valid_links);
+ 	}
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 		struct link_sta_info *link_sta;
+ 
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (WARN_ON(!link))
+ 			goto out_err;
+ 
+ 		if (sdata->vif.valid_links)
+ 			link_info(link,
+ 				  "local address %pM, AP link address %pM\n",
+ 				  link->conf->addr,
+ 				  assoc_data->link[link_id].bss->bssid);
+ 
+ 		link_sta = rcu_dereference_protected(sta->link[link_id],
+ 						     lockdep_is_held(&local->sta_mtx));
+ 		if (WARN_ON(!link_sta))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_prep_channel(sdata, link,
+ 						     assoc_data->link[link_id].bss,
+ 						     &link->u.mgd.conn_flags);
+ 			if (err)
+ 				goto out_err;
+ 		}
+ 
+ 		err = ieee80211_mgd_setup_link_sta(link, sta, link_sta->pub,
+ 						   assoc_data->link[link_id].bss);
+ 		if (err)
+ 			goto out_err;
+ 
+ 		if (!ieee80211_assoc_config_link(link, link_sta,
+ 						 assoc_data->link[link_id].bss,
+ 						 mgmt, elem_start, elem_len,
+ 						 &changed[link_id]))
+ 			goto out_err;
+ 
+ 		if (link_id != assoc_data->assoc_link_id) {
+ 			err = ieee80211_sta_activate_link(sta, link_id);
+ 			if (err)
+ 				goto out_err;
+ 		}
  	}
  
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	rate_control_rate_init(sta);
  
  	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
@@@ -3747,49 -4909,7 +5319,53 @@@
  
  	mutex_unlock(&sdata->local->sta_mtx);
  
++<<<<<<< HEAD
 +	/*
 +	 * Always handle WMM once after association regardless
 +	 * of the first value the AP uses. Setting -1 here has
 +	 * that effect because the AP values is an unsigned
 +	 * 4-bit value.
 +	 */
 +	ifmgd->wmm_last_param_set = -1;
 +	ifmgd->mu_edca_last_param_set = -1;
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_WMM) {
 +		ieee80211_set_wmm_default(sdata, false, false);
 +	} else if (!ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
 +					     elems->wmm_param_len,
 +					     elems->mu_edca_param_set)) {
 +		/* still enable QoS since we might have HT/VHT */
 +		ieee80211_set_wmm_default(sdata, false, true);
 +		/* set the disable-WMM flag in this case to disable
 +		 * tracking WMM parameter changes in the beacon if
 +		 * the parameters weren't actually valid. Doing so
 +		 * avoids changing parameters very strangely when
 +		 * the AP is going back and forth between valid and
 +		 * invalid parameters.
 +		 */
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_WMM;
 +	}
 +	changed |= BSS_CHANGED_QOS;
 +
 +	if (elems->max_idle_period_ie) {
 +		bss_conf->max_idle_period =
 +			le16_to_cpu(elems->max_idle_period_ie->max_idle_period);
 +		bss_conf->protected_keep_alive =
 +			!!(elems->max_idle_period_ie->idle_options &
 +			   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);
 +		changed |= BSS_CHANGED_KEEP_ALIVE;
 +	} else {
 +		bss_conf->max_idle_period = 0;
 +		bss_conf->protected_keep_alive = false;
 +	}
 +
 +	/* set assoc capability (AID was already set earlier),
 +	 * ieee80211_set_associated() will tell the driver */
 +	bss_conf->assoc_capability = capab_info;
 +	ieee80211_set_associated(sdata, cbss, changed);
++=======
+ 	ieee80211_set_associated(sdata, assoc_data, changed);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	/*
  	 * If we're using 4-addr mode, let the AP know that we're
@@@ -3819,15 -4939,19 +5395,21 @@@ static void ieee80211_rx_mgmt_assoc_res
  	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
  	u16 capab_info, status_code, aid;
  	struct ieee802_11_elems *elems;
 -	int ac;
 -	const u8 *elem_start;
 -	unsigned int elem_len;
 +	int ac, uapsd_queues = -1;
 +	u8 *pos;
  	bool reassoc;
- 	struct cfg80211_bss *cbss;
  	struct ieee80211_event event = {
  		.type = MLME_EVENT,
  		.u.mlme.data = ASSOC_EVENT,
  	};
  	struct ieee80211_prep_tx_info info = {};
++<<<<<<< HEAD
++=======
+ 	struct cfg80211_rx_assoc_resp resp = {
+ 		.uapsd_queues = -1,
+ 	};
+ 	unsigned int link_id;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	sdata_assert_lock(sdata);
  
@@@ -3850,12 -4973,10 +5431,19 @@@
  	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
  	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
  	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
++<<<<<<< HEAD
 +	pos = mgmt->u.assoc_resp.variable;
 +	aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
 +	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
 +		pos = (u8 *) mgmt->u.s1g_assoc_resp.variable;
 +		aid = 0; /* TODO */
 +	}
++=======
+ 	if (assoc_data->s1g)
+ 		elem_start = mgmt->u.s1g_assoc_resp.variable;
+ 	else
+ 		elem_start = mgmt->u.assoc_resp.variable;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	/*
  	 * Note: this may not be perfect, AP might misbehave - if
@@@ -3866,19 -4987,34 +5454,44 @@@
  	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
  				 IEEE80211_STYPE_ASSOC_REQ;
  
++<<<<<<< HEAD
++=======
+ 	if (assoc_data->fils_kek_len &&
+ 	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
+ 		return;
+ 
+ 	elem_len = len - (elem_start - (u8 *)mgmt);
+ 	elems = ieee802_11_parse_elems(elem_start, elem_len, false, NULL);
+ 	if (!elems)
+ 		goto notify_driver;
+ 
+ 	if (elems->aid_resp)
+ 		aid = le16_to_cpu(elems->aid_resp->aid);
+ 	else if (assoc_data->s1g)
+ 		aid = 0; /* TODO */
+ 	else
+ 		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+ 
+ 	/*
+ 	 * The 5 MSB of the AID field are reserved
+ 	 * (802.11-2016 9.4.1.8 AID field)
+ 	 */
+ 	aid &= 0x7ff;
+ 
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	sdata_info(sdata,
  		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
- 		   reassoc ? "Rea" : "A", mgmt->sa,
+ 		   reassoc ? "Rea" : "A", assoc_data->ap_addr,
  		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
  
 -	ifmgd->broken_ap = false;
 +	if (assoc_data->fils_kek_len &&
 +	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
 +		return;
 +
 +	elems = ieee802_11_parse_elems(pos, len - (pos - (u8 *)mgmt), false,
 +				       assoc_data->bss);
 +	if (!elems)
 +		goto notify_driver;
  
  	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
  	    elems->timeout_int &&
@@@ -3908,7 -5043,49 +5520,53 @@@
  		event.u.mlme.reason = status_code;
  		drv_event_callback(sdata->local, sdata, &event);
  	} else {
++<<<<<<< HEAD
 +		if (!ieee80211_assoc_success(sdata, cbss, mgmt, len, elems)) {
++=======
+ 		if (aid == 0 || aid > IEEE80211_MAX_AID) {
+ 			sdata_info(sdata,
+ 				   "invalid AID value %d (out of range), turn off PS\n",
+ 				   aid);
+ 			aid = 0;
+ 			ifmgd->broken_ap = true;
+ 		}
+ 
+ 		if (sdata->vif.valid_links) {
+ 			if (!elems->multi_link) {
+ 				sdata_info(sdata,
+ 					   "MLO association with %pM but no multi-link element in response!\n",
+ 					   assoc_data->ap_addr);
+ 				goto abandon_assoc;
+ 			}
+ 
+ 			if (le16_get_bits(elems->multi_link->control,
+ 					  IEEE80211_ML_CONTROL_TYPE) !=
+ 					IEEE80211_ML_CONTROL_TYPE_BASIC) {
+ 				sdata_info(sdata,
+ 					   "bad multi-link element (control=0x%x)\n",
+ 					   le16_to_cpu(elems->multi_link->control));
+ 				goto abandon_assoc;
+ 			} else {
+ 				struct ieee80211_mle_basic_common_info *common;
+ 
+ 				common = (void *)elems->multi_link->variable;
+ 
+ 				if (memcmp(assoc_data->ap_addr,
+ 					   common->mld_mac_addr, ETH_ALEN)) {
+ 					sdata_info(sdata,
+ 						   "AP MLD MAC address mismatch: got %pM expected %pM\n",
+ 						   common->mld_mac_addr,
+ 						   assoc_data->ap_addr);
+ 					goto abandon_assoc;
+ 				}
+ 			}
+ 		}
+ 
+ 		sdata->vif.cfg.aid = aid;
+ 
+ 		if (!ieee80211_assoc_success(sdata, mgmt, elems,
+ 					     elem_start, elem_len)) {
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  			/* oops -- internal error -- send timeout for now */
  			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
  			goto notify_driver;
@@@ -3917,30 -5094,49 +5575,70 @@@
  		drv_event_callback(sdata->local, sdata, &event);
  		sdata_info(sdata, "associated\n");
  
++<<<<<<< HEAD
 +		/*
 +		 * destroy assoc_data afterwards, as otherwise an idle
 +		 * recalc after assoc_data is NULL but before associated
 +		 * is set can cause the interface to go idle
 +		 */
 +		ieee80211_destroy_assoc_data(sdata, ASSOC_SUCCESS);
 +
 +		/* get uapsd queues configuration */
 +		uapsd_queues = 0;
 +		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 +			if (sdata->tx_conf[ac].uapsd)
 +				uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
 +
 +		info.success = 1;
 +	}
 +
 +	cfg80211_rx_assoc_resp(sdata->dev, cbss, (u8 *)mgmt, len, uapsd_queues,
 +			       ifmgd->assoc_req_ies, ifmgd->assoc_req_ies_len);
++=======
+ 		info.success = 1;
+ 	}
+ 
+ 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
+ 		struct ieee80211_link_data *link;
+ 
+ 		link = sdata_dereference(sdata->link[link_id], sdata);
+ 		if (!link)
+ 			continue;
+ 		if (!assoc_data->link[link_id].bss)
+ 			continue;
+ 		resp.links[link_id].bss = assoc_data->link[link_id].bss;
+ 		resp.links[link_id].addr = link->conf->addr;
+ 
+ 		/* get uapsd queues configuration - same for all links */
+ 		resp.uapsd_queues = 0;
+ 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+ 			if (link->tx_conf[ac].uapsd)
+ 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+ 	}
+ 
+ 	ieee80211_destroy_assoc_data(sdata,
+ 				     status_code == WLAN_STATUS_SUCCESS ?
+ 					ASSOC_SUCCESS :
+ 					ASSOC_REJECTED);
+ 
+ 	resp.buf = (u8 *)mgmt;
+ 	resp.len = len;
+ 	resp.req_ies = ifmgd->assoc_req_ies;
+ 	resp.req_ies_len = ifmgd->assoc_req_ies_len;
+ 	if (sdata->vif.valid_links)
+ 		resp.ap_mld_addr = assoc_data->ap_addr;
+ 	cfg80211_rx_assoc_resp(sdata->dev, &resp);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  notify_driver:
  	drv_mgd_complete_tx(sdata->local, sdata, &info);
  	kfree(elems);
+ 	return;
+ abandon_assoc:
+ 	ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
+ 	goto notify_driver;
  }
  
 -static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
 +static void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,
  				  struct ieee80211_mgmt *mgmt, size_t len,
  				  struct ieee80211_rx_status *rx_status)
  {
@@@ -5037,6 -6260,31 +6736,34 @@@ void ieee80211_sta_setup_sdata(struct i
  	ifmgd->orig_teardown_skb = NULL;
  }
  
++<<<<<<< HEAD
++=======
+ void ieee80211_mgd_setup_link(struct ieee80211_link_data *link)
+ {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	unsigned int link_id = link->link_id;
+ 
+ 	link->u.mgd.p2p_noa_index = -1;
+ 	link->u.mgd.conn_flags = 0;
+ 	link->conf->bssid = link->u.mgd.bssid;
+ 
+ 	INIT_WORK(&link->u.mgd.request_smps_work,
+ 		  ieee80211_request_smps_mgd_work);
+ 	if (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
+ 	else
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_OFF;
+ 
+ 	INIT_WORK(&link->u.mgd.chswitch_work, ieee80211_chswitch_work);
+ 	timer_setup(&link->u.mgd.chswitch_timer, ieee80211_chswitch_timer, 0);
+ 
+ 	if (sdata->u.mgd.assoc_data)
+ 		ether_addr_copy(link->conf->addr,
+ 				sdata->u.mgd.assoc_data->link[link_id].addr);
+ }
+ 
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  /* scan finished notification */
  void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
  {
@@@ -5051,550 -6299,90 +6778,591 @@@
  	rcu_read_unlock();
  }
  
 -static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
 -			       u8 *dtim_count, u8 *dtim_period)
 +static u8 ieee80211_max_rx_chains(struct ieee80211_sub_if_data *sdata,
 +				  struct cfg80211_bss *cbss)
  {
 -	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
 -	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
 -					 ies->len);
 -	const struct ieee80211_tim_ie *tim = NULL;
 -	const struct ieee80211_bssid_index *idx;
 -	bool valid = tim_ie && tim_ie[1] >= 2;
 -
 -	if (valid)
 -		tim = (void *)(tim_ie + 2);
 +	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	const struct element *ht_cap_elem, *vht_cap_elem;
 +	const struct cfg80211_bss_ies *ies;
 +	const struct ieee80211_ht_cap *ht_cap;
 +	const struct ieee80211_vht_cap *vht_cap;
 +	const struct ieee80211_he_cap_elem *he_cap;
 +	const struct element *he_cap_elem;
 +	u16 mcs_80_map, mcs_160_map;
 +	int i, mcs_nss_size;
 +	bool support_160;
 +	u8 chains = 1;
  
 -	if (dtim_count)
 -		*dtim_count = valid ? tim->dtim_count : 0;
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT)
 +		return chains;
  
 -	if (dtim_period)
 -		*dtim_period = valid ? tim->dtim_period : 0;
 +	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
 +	if (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {
 +		ht_cap = (void *)ht_cap_elem->data;
 +		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
 +		/*
 +		 * TODO: use "Tx Maximum Number Spatial Streams Supported" and
 +		 *	 "Tx Unequal Modulation Supported" fields.
 +		 */
 +	}
  
 -	/* Check if value is overridden by non-transmitted profile */
 -	if (!idx_ie || idx_ie[1] < 3)
 -		return valid;
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_VHT)
 +		return chains;
  
 -	idx = (void *)(idx_ie + 2);
 +	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
 +	if (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {
 +		u8 nss;
 +		u16 tx_mcs_map;
  
 -	if (dtim_count)
 -		*dtim_count = idx->dtim_count;
 +		vht_cap = (void *)vht_cap_elem->data;
 +		tx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
 +		for (nss = 8; nss > 0; nss--) {
 +			if (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=
 +					IEEE80211_VHT_MCS_NOT_SUPPORTED)
 +				break;
 +		}
 +		/* TODO: use "Tx Highest Supported Long GI Data Rate" field? */
 +		chains = max(chains, nss);
 +	}
  
 -	if (dtim_period)
 -		*dtim_period = idx->dtim_period;
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HE)
 +		return chains;
  
 -	return true;
 -}
 +	ies = rcu_dereference(cbss->ies);
 +	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
 +					     ies->data, ies->len);
  
 -static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 -				     struct cfg80211_bss *cbss, s8 link_id,
 -				     const u8 *ap_mld_addr, bool assoc,
 -				     bool override)
 -{
 -	struct ieee80211_local *local = sdata->local;
 -	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 -	struct ieee80211_bss *bss = (void *)cbss->priv;
 -	struct sta_info *new_sta = NULL;
 -	struct ieee80211_link_data *link;
 -	bool have_sta = false;
 -	bool mlo;
 -	int err;
 +	if (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))
 +		return chains;
  
 -	if (link_id >= 0) {
 -		mlo = true;
 -		if (WARN_ON(!ap_mld_addr))
 -			return -EINVAL;
 -		err = ieee80211_vif_set_links(sdata, BIT(link_id));
 -	} else {
 -		if (WARN_ON(ap_mld_addr))
 -			return -EINVAL;
 -		ap_mld_addr = cbss->bssid;
 -		err = ieee80211_vif_set_links(sdata, 0);
 -		link_id = 0;
 -		mlo = false;
 -	}
 +	/* skip one byte ext_tag_id */
 +	he_cap = (void *)(he_cap_elem->data + 1);
 +	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
  
 -	if (err)
 -		return err;
 +	/* invalid HE IE */
 +	if (he_cap_elem->datalen < 1 + mcs_nss_size + sizeof(*he_cap))
 +		return chains;
  
 -	link = sdata_dereference(sdata->link[link_id], sdata);
 -	if (WARN_ON(!link)) {
 -		err = -ENOLINK;
 -		goto out_err;
 -	}
 +	/* mcs_nss is right after he_cap info */
 +	he_mcs_nss_supp = (void *)(he_cap + 1);
  
 -	if (mlo && !is_valid_ether_addr(link->conf->addr))
 -		eth_random_addr(link->conf->addr);
 +	mcs_80_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
  
 -	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data)) {
 -		err = -EINVAL;
 -		goto out_err;
 -	}
 +	for (i = 7; i >= 0; i--) {
 +		u8 mcs_80 = mcs_80_map >> (2 * i) & 3;
  
 -	/* If a reconfig is happening, bail out */
 -	if (local->in_reconfig) {
 -		err = -EBUSY;
 -		goto out_err;
 +		if (mcs_80 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
 +			chains = max_t(u8, chains, i + 1);
 +			break;
 +		}
 +	}
 +
 +	support_160 = he_cap->phy_cap_info[0] &
 +		      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
 +
 +	if (!support_160)
 +		return chains;
 +
 +	mcs_160_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_160);
 +	for (i = 7; i >= 0; i--) {
 +		u8 mcs_160 = mcs_160_map >> (2 * i) & 3;
 +
 +		if (mcs_160 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
 +			chains = max_t(u8, chains, i + 1);
 +			break;
 +		}
 +	}
 +
 +	return chains;
 +}
 +
 +static bool
 +ieee80211_verify_peer_he_mcs_support(struct ieee80211_sub_if_data *sdata,
 +				     const struct cfg80211_bss_ies *ies,
 +				     const struct ieee80211_he_operation *he_op)
 +{
 +	const struct element *he_cap_elem;
 +	const struct ieee80211_he_cap_elem *he_cap;
 +	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
 +	u16 mcs_80_map_tx, mcs_80_map_rx;
 +	u16 ap_min_req_set;
 +	int mcs_nss_size;
 +	int nss;
 +
 +	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
 +					     ies->data, ies->len);
 +
 +	/* invalid HE IE */
 +	if (!he_cap_elem || he_cap_elem->datalen < 1 + sizeof(*he_cap)) {
 +		sdata_info(sdata,
 +			   "Invalid HE elem, Disable HE\n");
 +		return false;
 +	}
 +
 +	/* skip one byte ext_tag_id */
 +	he_cap = (void *)(he_cap_elem->data + 1);
 +	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
 +
 +	/* invalid HE IE */
 +	if (he_cap_elem->datalen < 1 + sizeof(*he_cap) + mcs_nss_size) {
 +		sdata_info(sdata,
 +			   "Invalid HE elem with nss size, Disable HE\n");
 +		return false;
 +	}
 +
 +	/* mcs_nss is right after he_cap info */
 +	he_mcs_nss_supp = (void *)(he_cap + 1);
 +
 +	mcs_80_map_tx = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
 +	mcs_80_map_rx = le16_to_cpu(he_mcs_nss_supp->rx_mcs_80);
 +
 +	/* P802.11-REVme/D0.3
 +	 * 27.1.1 Introduction to the HE PHY
 +	 * ...
 +	 * An HE STA shall support the following features:
 +	 * ...
 +	 * Single spatial stream HE-MCSs 0 to 7 (transmit and receive) in all
 +	 * supported channel widths for HE SU PPDUs
 +	 */
 +	if ((mcs_80_map_tx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED ||
 +	    (mcs_80_map_rx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED) {
 +		sdata_info(sdata,
 +			   "Missing mandatory rates for 1 Nss, rx 0x%x, tx 0x%x, disable HE\n",
 +			   mcs_80_map_tx, mcs_80_map_rx);
 +		return false;
 +	}
 +
 +	if (!he_op)
 +		return true;
 +
 +	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
 +
 +	/* make sure the AP is consistent with itself
 +	 *
 +	 * P802.11-REVme/D0.3
 +	 * 26.17.1 Basic HE BSS operation
 +	 *
 +	 * A STA that is operating in an HE BSS shall be able to receive and
 +	 * transmit at each of the <HE-MCS, NSS> tuple values indicated by the
 +	 * Basic HE-MCS And NSS Set field of the HE Operation parameter of the
 +	 * MLME-START.request primitive and shall be able to receive at each of
 +	 * the <HE-MCS, NSS> tuple values indicated by the Supported HE-MCS and
 +	 * NSS Set field in the HE Capabilities parameter of the MLMESTART.request
 +	 * primitive
 +	 */
 +	for (nss = 8; nss > 0; nss--) {
 +		u8 ap_op_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
 +		u8 ap_rx_val;
 +		u8 ap_tx_val;
 +
 +		if (ap_op_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
 +			continue;
 +
 +		ap_rx_val = (mcs_80_map_rx >> (2 * (nss - 1))) & 3;
 +		ap_tx_val = (mcs_80_map_tx >> (2 * (nss - 1))) & 3;
 +
 +		if (ap_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
 +		    ap_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
 +		    ap_rx_val < ap_op_val || ap_tx_val < ap_op_val) {
 +			sdata_info(sdata,
 +				   "Invalid rates for %d Nss, rx %d, tx %d oper %d, disable HE\n",
 +				   nss, ap_rx_val, ap_rx_val, ap_op_val);
 +			return false;
 +		}
 +	}
 +
 +	return true;
 +}
 +
 +static bool
 +ieee80211_verify_sta_he_mcs_support(struct ieee80211_sub_if_data *sdata,
 +				    struct ieee80211_supported_band *sband,
 +				    const struct ieee80211_he_operation *he_op)
 +{
 +	const struct ieee80211_sta_he_cap *sta_he_cap =
 +		ieee80211_get_he_iftype_cap(sband,
 +					    ieee80211_vif_type_p2p(&sdata->vif));
 +	u16 ap_min_req_set;
 +	int i;
 +
 +	if (!sta_he_cap || !he_op)
 +		return false;
 +
 +	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
 +
 +	/* Need to go over for 80MHz, 160MHz and for 80+80 */
 +	for (i = 0; i < 3; i++) {
 +		const struct ieee80211_he_mcs_nss_supp *sta_mcs_nss_supp =
 +			&sta_he_cap->he_mcs_nss_supp;
 +		u16 sta_mcs_map_rx =
 +			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i]);
 +		u16 sta_mcs_map_tx =
 +			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i + 1]);
 +		u8 nss;
 +		bool verified = true;
 +
 +		/*
 +		 * For each band there is a maximum of 8 spatial streams
 +		 * possible. Each of the sta_mcs_map_* is a 16-bit struct built
 +		 * of 2 bits per NSS (1-8), with the values defined in enum
 +		 * ieee80211_he_mcs_support. Need to make sure STA TX and RX
 +		 * capabilities aren't less than the AP's minimum requirements
 +		 * for this HE BSS per SS.
 +		 * It is enough to find one such band that meets the reqs.
 +		 */
 +		for (nss = 8; nss > 0; nss--) {
 +			u8 sta_rx_val = (sta_mcs_map_rx >> (2 * (nss - 1))) & 3;
 +			u8 sta_tx_val = (sta_mcs_map_tx >> (2 * (nss - 1))) & 3;
 +			u8 ap_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
 +
 +			if (ap_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
 +				continue;
 +
 +			/*
 +			 * Make sure the HE AP doesn't require MCSs that aren't
 +			 * supported by the client as required by spec
 +			 *
 +			 * P802.11-REVme/D0.3
 +			 * 26.17.1 Basic HE BSS operation
 +			 *
 +			 * An HE STA shall not attempt to join * (MLME-JOIN.request primitive)
 +			 * a BSS, unless it supports (i.e., is able to both transmit and
 +			 * receive using) all of the <HE-MCS, NSS> tuples in the basic
 +			 * HE-MCS and NSS set.
 +			 */
 +			if (sta_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
 +			    sta_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
 +			    (ap_val > sta_rx_val) || (ap_val > sta_tx_val)) {
 +				verified = false;
 +				break;
 +			}
 +		}
 +
 +		if (verified)
 +			return true;
 +	}
 +
 +	/* If here, STA doesn't meet AP's HE min requirements */
 +	return false;
 +}
 +
 +static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
 +				  struct cfg80211_bss *cbss)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	const struct ieee80211_ht_cap *ht_cap = NULL;
 +	const struct ieee80211_ht_operation *ht_oper = NULL;
 +	const struct ieee80211_vht_operation *vht_oper = NULL;
 +	const struct ieee80211_he_operation *he_oper = NULL;
 +	const struct ieee80211_eht_operation *eht_oper = NULL;
 +	const struct ieee80211_s1g_oper_ie *s1g_oper = NULL;
 +	struct ieee80211_supported_band *sband;
 +	struct cfg80211_chan_def chandef;
 +	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
 +	bool is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;
 +	struct ieee80211_bss *bss = (void *)cbss->priv;
 +	struct ieee802_11_elems *elems;
 +	const struct cfg80211_bss_ies *ies;
 +	int ret;
 +	u32 i;
 +	bool have_80mhz;
 +
 +	rcu_read_lock();
 +
 +	ies = rcu_dereference(cbss->ies);
 +	elems = ieee802_11_parse_elems(ies->data, ies->len, false, cbss);
 +	if (!elems) {
 +		rcu_read_unlock();
 +		return -ENOMEM;
 +	}
 +
 +	sband = local->hw.wiphy->bands[cbss->channel->band];
 +
 +	ifmgd->flags &= ~(IEEE80211_STA_DISABLE_40MHZ |
 +			  IEEE80211_STA_DISABLE_80P80MHZ |
 +			  IEEE80211_STA_DISABLE_160MHZ);
 +
 +	/* disable HT/VHT/HE if we don't support them */
 +	if (!sband->ht_cap.ht_supported && !is_6ghz) {
 +		mlme_dbg(sdata, "HT not supported, disabling HT/VHT/HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (!sband->vht_cap.vht_supported && is_5ghz) {
 +		mlme_dbg(sdata, "VHT not supported, disabling VHT/HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (!ieee80211_get_he_iftype_cap(sband,
 +					 ieee80211_vif_type_p2p(&sdata->vif))) {
 +		mlme_dbg(sdata, "HE not supported, disabling HE and EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (!ieee80211_get_eht_iftype_cap(sband,
 +					  ieee80211_vif_type_p2p(&sdata->vif))) {
 +		mlme_dbg(sdata, "EHT not supported, disabling EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT) && !is_6ghz) {
 +		ht_oper = elems->ht_operation;
 +		ht_cap = elems->ht_cap_elem;
 +
 +		if (!ht_cap) {
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +			ht_oper = NULL;
 +		}
 +	}
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) && !is_6ghz) {
 +		vht_oper = elems->vht_operation;
 +		if (vht_oper && !ht_oper) {
 +			vht_oper = NULL;
 +			sdata_info(sdata,
 +				   "AP advertised VHT without HT, disabling HT/VHT/HE\n");
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +		}
 +
 +		if (!elems->vht_cap_elem) {
 +			sdata_info(sdata,
 +				   "bad VHT capabilities, disabling VHT\n");
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +			vht_oper = NULL;
 +		}
 +	}
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		he_oper = elems->he_operation;
 +
 +		if (is_6ghz) {
 +			struct ieee80211_bss_conf *bss_conf;
 +			u8 i, j = 0;
 +
 +			bss_conf = &sdata->vif.bss_conf;
 +
 +			if (elems->pwr_constr_elem)
 +				bss_conf->pwr_reduction = *elems->pwr_constr_elem;
 +
 +			BUILD_BUG_ON(ARRAY_SIZE(bss_conf->tx_pwr_env) !=
 +				     ARRAY_SIZE(elems->tx_pwr_env));
 +
 +			for (i = 0; i < elems->tx_pwr_env_num; i++) {
 +				if (elems->tx_pwr_env_len[i] >
 +				    sizeof(bss_conf->tx_pwr_env[j]))
 +					continue;
 +
 +				bss_conf->tx_pwr_env_num++;
 +				memcpy(&bss_conf->tx_pwr_env[j], elems->tx_pwr_env[i],
 +				       elems->tx_pwr_env_len[i]);
 +				j++;
 +			}
 +		}
 +
 +		if (!ieee80211_verify_peer_he_mcs_support(sdata, ies, he_oper) ||
 +		    !ieee80211_verify_sta_he_mcs_support(sdata, sband, he_oper))
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +				        IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	/*
 +	 * EHT requires HE to be supported as well. Specifically for 6 GHz
 +	 * channels, the operation channel information can only be deduced from
 +	 * both the 6 GHz operation information (from the HE operation IE) and
 +	 * EHT operation.
 +	 */
 +	if (!(ifmgd->flags & (IEEE80211_STA_DISABLE_HE |
 +			      IEEE80211_STA_DISABLE_EHT)) && he_oper) {
 +		const struct cfg80211_bss_ies *ies;
 +		const u8 *eht_oper_ie;
 +
 +		ies = rcu_dereference(cbss->ies);
 +		eht_oper_ie = cfg80211_find_ext_ie(WLAN_EID_EXT_EHT_OPERATION,
 +						   ies->data, ies->len);
 +		if (eht_oper_ie && eht_oper_ie[1] >=
 +		    1 + sizeof(struct ieee80211_eht_operation))
 +			eht_oper = (void *)(eht_oper_ie + 3);
 +		else
 +			eht_oper = NULL;
 +	}
 +
 +	/* Allow VHT if at least one channel on the sband supports 80 MHz */
 +	have_80mhz = false;
 +	for (i = 0; i < sband->n_channels; i++) {
 +		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
 +						IEEE80211_CHAN_NO_80MHZ))
 +			continue;
 +
 +		have_80mhz = true;
 +		break;
 +	}
 +
 +	if (!have_80mhz) {
 +		sdata_info(sdata, "80 MHz not supported, disabling VHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +	}
 +
 +	if (sband->band == NL80211_BAND_S1GHZ) {
 +		s1g_oper = elems->s1g_oper;
 +		if (!s1g_oper)
 +			sdata_info(sdata,
 +				   "AP missing S1G operation element?\n");
 +	}
 +
 +	ifmgd->flags |= ieee80211_determine_chantype(sdata, sband,
 +						     cbss->channel,
 +						     bss->vht_cap_info,
 +						     ht_oper, vht_oper,
 +						     he_oper, eht_oper,
 +						     s1g_oper,
 +						     &chandef, false);
 +
 +	sdata->needed_rx_chains = min(ieee80211_max_rx_chains(sdata, cbss),
 +				      local->rx_chains);
 +
 +	rcu_read_unlock();
 +	/* the element data was RCU protected so no longer valid anyway */
 +	kfree(elems);
 +	elems = NULL;
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HE && is_6ghz) {
 +		sdata_info(sdata, "Rejecting non-HE 6/7 GHz connection");
 +		return -EINVAL;
 +	}
 +
 +	/* will change later if needed */
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +
 +	mutex_lock(&local->mtx);
 +	/*
 +	 * If this fails (possibly due to channel context sharing
 +	 * on incompatible channels, e.g. 80+80 and 160 sharing the
 +	 * same control channel) try to use a smaller bandwidth.
 +	 */
 +	ret = ieee80211_vif_use_channel(sdata, &chandef,
 +					IEEE80211_CHANCTX_SHARED);
 +
 +	/* don't downgrade for 5 and 10 MHz channels, though. */
 +	if (chandef.width == NL80211_CHAN_WIDTH_5 ||
 +	    chandef.width == NL80211_CHAN_WIDTH_10)
 +		goto out;
 +
 +	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
 +		ifmgd->flags |= ieee80211_chandef_downgrade(&chandef);
 +		ret = ieee80211_vif_use_channel(sdata, &chandef,
 +						IEEE80211_CHANCTX_SHARED);
 +	}
 + out:
 +	mutex_unlock(&local->mtx);
 +	return ret;
 +}
 +
 +static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
 +			       u8 *dtim_count, u8 *dtim_period)
 +{
 +	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
 +	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
 +					 ies->len);
 +	const struct ieee80211_tim_ie *tim = NULL;
 +	const struct ieee80211_bssid_index *idx;
 +	bool valid = tim_ie && tim_ie[1] >= 2;
 +
 +	if (valid)
 +		tim = (void *)(tim_ie + 2);
 +
 +	if (dtim_count)
 +		*dtim_count = valid ? tim->dtim_count : 0;
 +
 +	if (dtim_period)
 +		*dtim_period = valid ? tim->dtim_period : 0;
 +
 +	/* Check if value is overridden by non-transmitted profile */
 +	if (!idx_ie || idx_ie[1] < 3)
 +		return valid;
 +
 +	idx = (void *)(idx_ie + 2);
 +
 +	if (dtim_count)
 +		*dtim_count = idx->dtim_count;
 +
 +	if (dtim_period)
 +		*dtim_period = idx->dtim_period;
 +
 +	return true;
 +}
 +
 +static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
- 				     struct cfg80211_bss *cbss, bool assoc,
++				     struct cfg80211_bss *cbss, s8 link_id,
++				     const u8 *ap_mld_addr, bool assoc,
 +				     bool override)
 +{
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_bss *bss = (void *)cbss->priv;
 +	struct sta_info *new_sta = NULL;
++<<<<<<< HEAD
 +	struct ieee80211_supported_band *sband;
++=======
++	struct ieee80211_link_data *link;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
 +	bool have_sta = false;
++	bool mlo;
 +	int err;
 +
++<<<<<<< HEAD
 +	sband = local->hw.wiphy->bands[cbss->channel->band];
 +
 +	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data))
 +		return -EINVAL;
++=======
++	if (link_id >= 0) {
++		mlo = true;
++		if (WARN_ON(!ap_mld_addr))
++			return -EINVAL;
++		err = ieee80211_vif_set_links(sdata, BIT(link_id));
++	} else {
++		if (WARN_ON(ap_mld_addr))
++			return -EINVAL;
++		ap_mld_addr = cbss->bssid;
++		err = ieee80211_vif_set_links(sdata, 0);
++		link_id = 0;
++		mlo = false;
++	}
++
++	if (err)
++		return err;
++
++	link = sdata_dereference(sdata->link[link_id], sdata);
++	if (WARN_ON(!link)) {
++		err = -ENOLINK;
++		goto out_err;
++	}
++
++	if (mlo && !is_valid_ether_addr(link->conf->addr))
++		eth_random_addr(link->conf->addr);
++
++	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data)) {
++		err = -EINVAL;
++		goto out_err;
++	}
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
 +
 +	/* If a reconfig is happening, bail out */
- 	if (local->in_reconfig)
- 		return -EBUSY;
++	if (local->in_reconfig) {
++		err = -EBUSY;
++		goto out_err;
+ 	}
  
  	if (assoc) {
  		rcu_read_lock();
@@@ -5622,72 -6418,34 +7398,96 @@@
  	 * it might need the new channel for that.
  	 */
  	if (new_sta) {
 +		u32 rates = 0, basic_rates = 0;
 +		bool have_higher_than_11mbit = false;
 +		int min_rate = INT_MAX, min_rate_index = -1;
  		const struct cfg80211_bss_ies *ies;
++<<<<<<< HEAD
 +		int shift = ieee80211_vif_get_shift(&sdata->vif);
 +
 +		/* TODO: S1G Basic Rate Set is expressed elsewhere */
 +		if (cbss->channel->band == NL80211_BAND_S1GHZ) {
 +			ieee80211_s1g_sta_rate_init(new_sta);
 +			goto skip_rates;
++=======
+ 		struct ieee80211_link_sta *link_sta;
+ 
+ 		rcu_read_lock();
+ 		link_sta = rcu_dereference(new_sta->sta.link[link_id]);
+ 		if (WARN_ON(!link_sta)) {
+ 			rcu_read_unlock();
+ 			sta_info_free(local, new_sta);
+ 			err = -EINVAL;
+ 			goto out_err;
+ 		}
+ 
+ 		err = ieee80211_mgd_setup_link_sta(link, new_sta,
+ 						   link_sta, cbss);
+ 		if (err) {
+ 			rcu_read_unlock();
+ 			sta_info_free(local, new_sta);
+ 			goto out_err;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
 +		}
 +
 +		ieee80211_get_rates(sband, bss->supp_rates,
 +				    bss->supp_rates_len,
 +				    &rates, &basic_rates,
 +				    &have_higher_than_11mbit,
 +				    &min_rate, &min_rate_index,
 +				    shift);
 +
 +		/*
 +		 * This used to be a workaround for basic rates missing
 +		 * in the association response frame. Now that we no
 +		 * longer use the basic rates from there, it probably
 +		 * doesn't happen any more, but keep the workaround so
 +		 * in case some *other* APs are buggy in different ways
 +		 * we can connect -- with a warning.
 +		 * Allow this workaround only in case the AP provided at least
 +		 * one rate.
 +		 */
 +		if (min_rate_index < 0) {
 +			sdata_info(sdata,
 +				   "No legacy rates in association response\n");
 +
 +			sta_info_free(local, new_sta);
 +			return -EINVAL;
 +		} else if (!basic_rates) {
 +			sdata_info(sdata,
 +				   "No basic rates, using min rate instead\n");
 +			basic_rates = BIT(min_rate_index);
  		}
  
 -		memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
 +		if (rates)
 +			new_sta->sta.supp_rates[cbss->channel->band] = rates;
 +		else
 +			sdata_info(sdata,
 +				   "No rates found, keeping mandatory only\n");
 +
 +		sdata->vif.bss_conf.basic_rates = basic_rates;
 +
 +		/* cf. IEEE 802.11 9.2.12 */
 +		if (cbss->channel->band == NL80211_BAND_2GHZ &&
 +		    have_higher_than_11mbit)
 +			sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
 +		else
 +			sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
 +
 +skip_rates:
 +		memcpy(ifmgd->bssid, cbss->bssid, ETH_ALEN);
  
  		/* set timing information */
++<<<<<<< HEAD
 +		sdata->vif.bss_conf.beacon_int = cbss->beacon_interval;
 +		rcu_read_lock();
++=======
+ 		link->conf->beacon_int = cbss->beacon_interval;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		ies = rcu_dereference(cbss->beacon_ies);
  		if (ies) {
 -			link->conf->sync_tsf = ies->tsf;
 -			link->conf->sync_device_ts =
 +			sdata->vif.bss_conf.sync_tsf = ies->tsf;
 +			sdata->vif.bss_conf.sync_device_ts =
  				bss->device_ts_beacon;
  
  			ieee80211_get_dtim(ies,
@@@ -5736,10 -6496,10 +7536,10 @@@
  			sdata_info(sdata,
  				   "failed to insert STA entry for the AP (error %d)\n",
  				   err);
- 			return err;
+ 			goto out_err;
  		}
  	} else
 -		WARN_ON_ONCE(!ether_addr_equal(link->u.mgd.bssid, cbss->bssid));
 +		WARN_ON_ONCE(!ether_addr_equal(ifmgd->bssid, cbss->bssid));
  
  	/* Cancel scan to ensure that nothing interferes with connection */
  	if (local->scanning)
@@@ -5862,7 -6629,7 +7669,11 @@@ int ieee80211_mgd_auth(struct ieee80211
  
  		sdata_info(sdata,
  			   "disconnect from AP %pM for new auth to %pM\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid, req->bss->bssid);
++=======
+ 			   sdata->vif.cfg.ap_addr, auth_data->ap_addr);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
  				       WLAN_REASON_UNSPECIFIED,
  				       false, frame_buf);
@@@ -5890,33 -6658,198 +7702,224 @@@
  	return 0;
  
   err_clear:
++<<<<<<< HEAD
 +	eth_zero_addr(ifmgd->bssid);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
 +	ifmgd->auth_data = NULL;
 +	mutex_lock(&sdata->local->mtx);
 +	ieee80211_vif_release_channel(sdata);
 +	mutex_unlock(&sdata->local->mtx);
++=======
+ 	if (!sdata->vif.valid_links) {
+ 		eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID);
+ 		mutex_lock(&sdata->local->mtx);
+ 		ieee80211_link_release_channel(&sdata->deflink);
+ 		mutex_unlock(&sdata->local->mtx);
+ 	}
+ 	ifmgd->auth_data = NULL;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	kfree(auth_data);
  	return err;
  }
  
++<<<<<<< HEAD
 +int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
 +			struct cfg80211_assoc_request *req)
 +{
 +	bool is_6ghz = req->bss->channel->band == NL80211_BAND_6GHZ;
 +	bool is_5ghz = req->bss->channel->band == NL80211_BAND_5GHZ;
++=======
+ static ieee80211_conn_flags_t
+ ieee80211_setup_assoc_link(struct ieee80211_sub_if_data *sdata,
+ 			   struct ieee80211_mgd_assoc_data *assoc_data,
+ 			   struct cfg80211_assoc_request *req,
+ 			   ieee80211_conn_flags_t conn_flags,
+ 			   unsigned int link_id)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	const struct cfg80211_bss_ies *beacon_ies;
+ 	struct ieee80211_supported_band *sband;
+ 	const struct element *ht_elem, *vht_elem;
+ 	struct ieee80211_link_data *link;
+ 	struct cfg80211_bss *cbss;
+ 	struct ieee80211_bss *bss;
+ 	bool is_5ghz, is_6ghz;
+ 
+ 	cbss = assoc_data->link[link_id].bss;
+ 	if (WARN_ON(!cbss))
+ 		return 0;
+ 
+ 	bss = (void *)cbss->priv;
+ 
+ 	sband = local->hw.wiphy->bands[cbss->channel->band];
+ 	if (WARN_ON(!sband))
+ 		return 0;
+ 
+ 	link = sdata_dereference(sdata->link[link_id], sdata);
+ 	if (WARN_ON(!link))
+ 		return 0;
+ 
+ 	is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;
+ 	is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
+ 
+ 	/* for MLO connections assume advertising all rates is OK */
+ 	if (!req->ap_mld_addr) {
+ 		assoc_data->supp_rates = bss->supp_rates;
+ 		assoc_data->supp_rates_len = bss->supp_rates_len;
+ 	}
+ 
+ 	/* copy and link elems for the STA profile */
+ 	if (req->links[link_id].elems_len) {
+ 		memcpy(assoc_data->ie_pos, req->links[link_id].elems,
+ 		       req->links[link_id].elems_len);
+ 		assoc_data->link[link_id].elems = assoc_data->ie_pos;
+ 		assoc_data->link[link_id].elems_len = req->links[link_id].elems_len;
+ 		assoc_data->ie_pos += req->links[link_id].elems_len;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	ht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_OPERATION);
+ 	if (ht_elem && ht_elem->datalen >= sizeof(struct ieee80211_ht_operation))
+ 		assoc_data->link[link_id].ap_ht_param =
+ 			((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;
+ 	else if (!is_6ghz)
+ 		conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 	vht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
+ 	if (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {
+ 		memcpy(&assoc_data->link[link_id].ap_vht_cap, vht_elem->data,
+ 		       sizeof(struct ieee80211_vht_cap));
+ 	} else if (is_5ghz) {
+ 		link_info(link,
+ 			  "VHT capa missing/short, disabling VHT/HE/EHT\n");
+ 		conn_flags |= IEEE80211_CONN_DISABLE_VHT |
+ 			      IEEE80211_CONN_DISABLE_HE |
+ 			      IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	link->u.mgd.beacon_crc_valid = false;
+ 	link->u.mgd.dtim_period = 0;
+ 	link->u.mgd.have_beacon = false;
+ 
+ 	/* override HT/VHT configuration only if the AP and we support it */
+ 	if (!(conn_flags & IEEE80211_CONN_DISABLE_HT)) {
+ 		struct ieee80211_sta_ht_cap sta_ht_cap;
+ 
+ 		memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
+ 		ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
+ 	}
+ 
+ 	rcu_read_lock();
+ 	beacon_ies = rcu_dereference(cbss->beacon_ies);
+ 	if (beacon_ies) {
+ 		const struct element *elem;
+ 		u8 dtim_count = 0;
+ 
+ 		ieee80211_get_dtim(beacon_ies, &dtim_count,
+ 				   &link->u.mgd.dtim_period);
+ 
+ 		sdata->deflink.u.mgd.have_beacon = true;
+ 
+ 		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
+ 			link->conf->sync_tsf = beacon_ies->tsf;
+ 			link->conf->sync_device_ts = bss->device_ts_beacon;
+ 			link->conf->sync_dtim_count = dtim_count;
+ 		}
+ 
+ 		elem = cfg80211_find_ext_elem(WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION,
+ 					      beacon_ies->data, beacon_ies->len);
+ 		if (elem && elem->datalen >= 3)
+ 			link->conf->profile_periodicity = elem->data[2];
+ 		else
+ 			link->conf->profile_periodicity = 0;
+ 
+ 		elem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,
+ 					  beacon_ies->data, beacon_ies->len);
+ 		if (elem && elem->datalen >= 11 &&
+ 		    (elem->data[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
+ 			link->conf->ema_ap = true;
+ 		else
+ 			link->conf->ema_ap = false;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	if (bss->corrupt_data) {
+ 		char *corrupt_type = "data";
+ 
+ 		if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_BEACON) {
+ 			if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP)
+ 				corrupt_type = "beacon and probe response";
+ 			else
+ 				corrupt_type = "beacon";
+ 		} else if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP) {
+ 			corrupt_type = "probe response";
+ 		}
+ 		sdata_info(sdata, "associating to AP %pM with corrupt %s\n",
+ 			   cbss->bssid, corrupt_type);
+ 	}
+ 
+ 	if (link->u.mgd.req_smps == IEEE80211_SMPS_AUTOMATIC) {
+ 		if (sdata->u.mgd.powersave)
+ 			link->smps_mode = IEEE80211_SMPS_DYNAMIC;
+ 		else
+ 			link->smps_mode = IEEE80211_SMPS_OFF;
+ 	} else {
+ 		link->smps_mode = link->u.mgd.req_smps;
+ 	}
+ 
+ 	return conn_flags;
+ }
+ 
+ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
+ 			struct cfg80211_assoc_request *req)
+ {
+ 	unsigned int assoc_link_id = req->link_id < 0 ? 0 : req->link_id;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
- 	struct ieee80211_bss *bss = (void *)req->bss->priv;
  	struct ieee80211_mgd_assoc_data *assoc_data;
++<<<<<<< HEAD
 +	const struct cfg80211_bss_ies *beacon_ies;
 +	struct ieee80211_supported_band *sband;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 +	const struct element *ssid_elem, *ht_elem, *vht_elem;
 +	int i, err;
 +	bool override = false;
++=======
+ 	const struct element *ssid_elem;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 	ieee80211_conn_flags_t conn_flags = 0;
+ 	struct ieee80211_link_data *link;
+ 	struct cfg80211_bss *cbss;
+ 	struct ieee80211_bss *bss;
+ 	bool override;
+ 	int i, err;
+ 	size_t size = sizeof(*assoc_data) + req->ie_len;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
- 	assoc_data = kzalloc(sizeof(*assoc_data) + req->ie_len, GFP_KERNEL);
+ 	for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++)
+ 		size += req->links[i].elems_len;
+ 
+ 	if (req->ap_mld_addr) {
+ 		for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
+ 			if (!req->links[i].bss)
+ 				continue;
+ 			if (i == assoc_link_id)
+ 				continue;
+ 			/*
+ 			 * For now, support only a single link in MLO, we
+ 			 * don't have the necessary parsing of the multi-
+ 			 * link element in the association response, etc.
+ 			 */
+ 			sdata_info(sdata,
+ 				   "refusing MLO association with >1 links\n");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	assoc_data = kzalloc(size, GFP_KERNEL);
  	if (!assoc_data)
  		return -ENOMEM;
  
@@@ -5929,16 -6864,37 +7934,41 @@@
  	}
  	memcpy(assoc_data->ssid, ssid_elem->data, ssid_elem->datalen);
  	assoc_data->ssid_len = ssid_elem->datalen;
 -	memcpy(vif_cfg->ssid, assoc_data->ssid, assoc_data->ssid_len);
 -	vif_cfg->ssid_len = assoc_data->ssid_len;
 +	memcpy(bss_conf->ssid, assoc_data->ssid, assoc_data->ssid_len);
 +	bss_conf->ssid_len = assoc_data->ssid_len;
  	rcu_read_unlock();
  
+ 	if (req->ap_mld_addr) {
+ 		for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
+ 			if (!req->links[i].bss)
+ 				continue;
+ 			link = sdata_dereference(sdata->link[i], sdata);
+ 			if (link)
+ 				ether_addr_copy(assoc_data->link[i].addr,
+ 						link->conf->addr);
+ 			else
+ 				eth_random_addr(assoc_data->link[i].addr);
+ 		}
+ 	} else {
+ 		memcpy(assoc_data->link[0].addr, sdata->vif.addr, ETH_ALEN);
+ 	}
+ 
+ 	assoc_data->s1g = cbss->channel->band == NL80211_BAND_S1GHZ;
+ 
+ 	memcpy(assoc_data->ap_addr,
+ 	       req->ap_mld_addr ?: req->bss->bssid,
+ 	       ETH_ALEN);
+ 
  	if (ifmgd->associated) {
  		u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
  
  		sdata_info(sdata,
  			   "disconnect from AP %pM for new assoc to %pM\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid, req->bss->bssid);
++=======
+ 			   sdata->vif.cfg.ap_addr, assoc_data->ap_addr);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
  				       WLAN_REASON_UNSPECIFIED,
  				       false, frame_buf);
@@@ -5963,14 -6919,14 +7993,23 @@@
  		bool match;
  
  		/* keep sta info, bssid if matching */
++<<<<<<< HEAD
 +		match = ether_addr_equal(ifmgd->bssid, req->bss->bssid);
++=======
+ 		match = ether_addr_equal(ifmgd->auth_data->ap_addr,
+ 					 assoc_data->ap_addr);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		ieee80211_destroy_auth_data(sdata, match);
  	}
  
  	/* prepare assoc data */
  
++<<<<<<< HEAD
 +	ifmgd->beacon_crc_valid = false;
 +
++=======
+ 	bss = (void *)cbss->priv;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	assoc_data->wmm = bss->wmm_used &&
  			  (local->hw.queues >= IEEE80211_NUM_ACS);
  
@@@ -6006,6 -6960,28 +8045,31 @@@
  			    "disabling HT/VHT/HE as WMM/QoS is not supported by the AP\n");
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (req->flags & ASSOC_REQ_DISABLE_HT) {
+ 		mlme_dbg(sdata, "HT disabled by flag, disabling HT/VHT/HE\n");
+ 		conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (req->flags & ASSOC_REQ_DISABLE_VHT) {
+ 		mlme_dbg(sdata, "VHT disabled by flag, disabling VHT\n");
+ 		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 	}
+ 
+ 	if (req->flags & ASSOC_REQ_DISABLE_HE) {
+ 		mlme_dbg(sdata, "HE disabled by flag, disabling HE/EHT\n");
+ 		conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (req->flags & ASSOC_REQ_DISABLE_EHT)
+ 		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	memcpy(&ifmgd->ht_capa, &req->ht_capa, sizeof(ifmgd->ht_capa));
  	memcpy(&ifmgd->ht_capa_mask, &req->ht_capa_mask,
  	       sizeof(ifmgd->ht_capa_mask));
@@@ -6038,30 -7017,37 +8105,64 @@@
  		memcpy(assoc_data->fils_nonces, req->fils_nonces,
  		       2 * FILS_NONCE_LEN);
  
++<<<<<<< HEAD
 +	assoc_data->bss = req->bss;
 +	assoc_data->capability = req->bss->capability;
 +	assoc_data->supp_rates = bss->supp_rates;
 +	assoc_data->supp_rates_len = bss->supp_rates_len;
 +
 +	rcu_read_lock();
 +	ht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_HT_OPERATION);
 +	if (ht_elem && ht_elem->datalen >= sizeof(struct ieee80211_ht_operation))
 +		assoc_data->ap_ht_param =
 +			((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;
 +	else if (!is_6ghz)
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +	vht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_VHT_CAPABILITY);
 +	if (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {
 +		memcpy(&assoc_data->ap_vht_cap, vht_elem->data,
 +		       sizeof(struct ieee80211_vht_cap));
 +	} else if (is_5ghz) {
 +		sdata_info(sdata,
 +			   "VHT capa missing/short, disabling VHT/HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT |
 +				IEEE80211_STA_DISABLE_HE |
 +				IEEE80211_STA_DISABLE_EHT;
 +	}
 +	rcu_read_unlock();
++=======
+ 	/* default timeout */
+ 	assoc_data->timeout = jiffies;
+ 	assoc_data->timeout_started = true;
+ 
+ 	assoc_data->assoc_link_id = assoc_link_id;
+ 
+ 	if (req->ap_mld_addr) {
+ 		for (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {
+ 			assoc_data->link[i].conn_flags = conn_flags;
+ 			assoc_data->link[i].bss = req->links[i].bss;
+ 		}
+ 
+ 		/* if there was no authentication, set up the link */
+ 		err = ieee80211_vif_set_links(sdata, BIT(assoc_link_id));
+ 		if (err)
+ 			goto err_clear;
+ 	} else {
+ 		assoc_data->link[0].conn_flags = conn_flags;
+ 		assoc_data->link[0].bss = cbss;
+ 	}
+ 
+ 	link = sdata_dereference(sdata->link[assoc_link_id], sdata);
+ 	if (WARN_ON(!link)) {
+ 		err = -EINVAL;
+ 		goto err_clear;
+ 	}
+ 
+ 	conn_flags |= ieee80211_setup_assoc_link(sdata, assoc_data, req,
+ 						 conn_flags, assoc_link_id);
+ 	override = link->u.mgd.conn_flags != conn_flags;
+ 	link->u.mgd.conn_flags |= conn_flags;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
  	if (WARN((sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD) &&
  		 ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK),
@@@ -6105,118 -7091,47 +8206,138 @@@
  	sdata->control_port_no_preauth = req->crypto.control_port_no_preauth;
  
  	/* kick off associate process */
 +
  	ifmgd->assoc_data = assoc_data;
 +	ifmgd->dtim_period = 0;
 +	ifmgd->have_beacon = false;
 +
 +	/* override HT/VHT configuration only if the AP and we support it */
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
 +		struct ieee80211_sta_ht_cap sta_ht_cap;
 +
 +		if (req->flags & ASSOC_REQ_DISABLE_HT)
 +			override = true;
 +
 +		memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
 +		ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
 +
 +		/* check for 40 MHz disable override */
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_40MHZ) &&
 +		    sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&
 +		    !(sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))
 +			override = true;
  
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
 +		    req->flags & ASSOC_REQ_DISABLE_VHT)
 +			override = true;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_HT) {
 +		mlme_dbg(sdata, "HT disabled by flag, disabling HT/VHT/HE\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_VHT) {
 +		mlme_dbg(sdata, "VHT disabled by flag, disabling VHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_HE) {
 +		mlme_dbg(sdata, "HE disabled by flag, disabling HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
++<<<<<<< HEAD
 +	if (req->flags & ASSOC_REQ_DISABLE_EHT)
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 	for (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {
+ 		if (!assoc_data->link[i].bss)
+ 			continue;
+ 		if (i == assoc_data->assoc_link_id)
+ 			continue;
+ 		/* only calculate the flags, hence link == NULL */
+ 		err = ieee80211_prep_channel(sdata, NULL, assoc_data->link[i].bss,
+ 					     &assoc_data->link[i].conn_flags);
+ 		if (err)
+ 			goto err_clear;
+ 	}
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
- 	err = ieee80211_prep_connection(sdata, req->bss, true, override);
+ 	err = ieee80211_prep_connection(sdata, cbss, req->link_id,
+ 					req->ap_mld_addr, true, override);
  	if (err)
  		goto err_clear;
  
++<<<<<<< HEAD
 +	if (ifmgd->req_smps == IEEE80211_SMPS_AUTOMATIC) {
 +		if (ifmgd->powersave)
 +			sdata->smps_mode = IEEE80211_SMPS_DYNAMIC;
 +		else
 +			sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	} else {
 +		sdata->smps_mode = ifmgd->req_smps;
 +	}
++=======
+ 	assoc_data->link[assoc_data->assoc_link_id].conn_flags =
+ 		link->u.mgd.conn_flags;
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  
 -	if (ieee80211_hw_check(&sdata->local->hw, NEED_DTIM_BEFORE_ASSOC)) {
 -		const struct cfg80211_bss_ies *beacon_ies;
 +	rcu_read_lock();
 +	beacon_ies = rcu_dereference(req->bss->beacon_ies);
  
 -		rcu_read_lock();
 -		beacon_ies = rcu_dereference(req->bss->beacon_ies);
 +	if (ieee80211_hw_check(&sdata->local->hw, NEED_DTIM_BEFORE_ASSOC) &&
 +	    !beacon_ies) {
 +		/*
 +		 * Wait up to one beacon interval ...
 +		 * should this be more if we miss one?
 +		 */
 +		sdata_info(sdata, "waiting for beacon from %pM\n",
 +			   ifmgd->bssid);
 +		assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
 +		assoc_data->timeout_started = true;
 +		assoc_data->need_beacon = true;
 +	} else if (beacon_ies) {
 +		const struct element *elem;
 +		u8 dtim_count = 0;
  
 -		if (beacon_ies) {
 -			/*
 -			 * Wait up to one beacon interval ...
 -			 * should this be more if we miss one?
 -			 */
 -			sdata_info(sdata, "waiting for beacon from %pM\n",
 -				   link->u.mgd.bssid);
 -			assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
 -			assoc_data->timeout_started = true;
 -			assoc_data->need_beacon = true;
 +		ieee80211_get_dtim(beacon_ies, &dtim_count,
 +				   &ifmgd->dtim_period);
 +
 +		ifmgd->have_beacon = true;
 +		assoc_data->timeout = jiffies;
 +		assoc_data->timeout_started = true;
 +
 +		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
 +			sdata->vif.bss_conf.sync_tsf = beacon_ies->tsf;
 +			sdata->vif.bss_conf.sync_device_ts =
 +				bss->device_ts_beacon;
 +			sdata->vif.bss_conf.sync_dtim_count = dtim_count;
  		}
 -		rcu_read_unlock();
 +
 +		elem = cfg80211_find_ext_elem(WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION,
 +					      beacon_ies->data, beacon_ies->len);
 +		if (elem && elem->datalen >= 3)
 +			sdata->vif.bss_conf.profile_periodicity = elem->data[2];
 +		else
 +			sdata->vif.bss_conf.profile_periodicity = 0;
 +
 +		elem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,
 +					  beacon_ies->data, beacon_ies->len);
 +		if (elem && elem->datalen >= 11 &&
 +		    (elem->data[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
 +			sdata->vif.bss_conf.ema_ap = true;
 +		else
 +			sdata->vif.bss_conf.ema_ap = false;
 +	} else {
 +		assoc_data->timeout = jiffies;
 +		assoc_data->timeout_started = true;
  	}
 +	rcu_read_unlock();
  
  	run_again(sdata, assoc_data->timeout);
  
diff --cc net/mac80211/tx.c
index c3e516ffdc16,34dae26646a6..000000000000
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@@ -2477,7 -2478,7 +2477,11 @@@ int ieee80211_lookup_ra_sta(struct ieee
  
  		}
  
++<<<<<<< HEAD
 +		sta = sta_info_get(sdata, sdata->u.mgd.bssid);
++=======
+ 		sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  		if (!sta)
  			return -ENOLINK;
  		break;
diff --cc net/wireless/mlme.c
index 54121647d29f,defce1530115..000000000000
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@@ -28,29 -27,45 +28,54 @@@ void cfg80211_rx_assoc_resp(struct net_
  	struct wireless_dev *wdev = dev->ieee80211_ptr;
  	struct wiphy *wiphy = wdev->wiphy;
  	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 -	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)data->buf;
 -	struct cfg80211_connect_resp_params cr = {
 -		.timeout_reason = NL80211_TIMEOUT_UNSPECIFIED,
 -		.req_ie = data->req_ies,
 -		.req_ie_len = data->req_ies_len,
 -		.resp_ie = mgmt->u.assoc_resp.variable,
 -		.resp_ie_len = data->len -
 -			       offsetof(struct ieee80211_mgmt,
 -					u.assoc_resp.variable),
 -		.status = le16_to_cpu(mgmt->u.assoc_resp.status_code),
 -		.ap_mld_addr = data->ap_mld_addr,
 -	};
 -	unsigned int link_id;
 -
 +	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
 +	struct cfg80211_connect_resp_params cr;
 +	const u8 *resp_ie = mgmt->u.assoc_resp.variable;
 +	size_t resp_ie_len = len - offsetof(struct ieee80211_mgmt,
 +					    u.assoc_resp.variable);
 +
++<<<<<<< HEAD
 +	if (bss->channel->band == NL80211_BAND_S1GHZ) {
 +		resp_ie = (u8 *)&mgmt->u.s1g_assoc_resp.variable;
 +		resp_ie_len = len - offsetof(struct ieee80211_mgmt,
 +					     u.s1g_assoc_resp.variable);
++=======
+ 	for (link_id = 0; link_id < ARRAY_SIZE(data->links); link_id++) {
+ 		cr.links[link_id].bss = data->links[link_id].bss;
+ 		if (!cr.links[link_id].bss)
+ 			continue;
+ 		cr.links[link_id].bssid = data->links[link_id].bss->bssid;
+ 		cr.links[link_id].addr = data->links[link_id].addr;
+ 		/* need to have local link addresses for MLO connections */
+ 		WARN_ON(cr.ap_mld_addr && !cr.links[link_id].addr);
+ 
+ 		printk(KERN_CRIT "BSS pointer 0x%lx\n", (unsigned long)cr.links[link_id].bss);
+ 		BUG_ON(!cr.links[link_id].bss->channel);
+ 
+ 		if (cr.links[link_id].bss->channel->band == NL80211_BAND_S1GHZ) {
+ 			WARN_ON(link_id);
+ 			cr.resp_ie = (u8 *)&mgmt->u.s1g_assoc_resp.variable;
+ 			cr.resp_ie_len = data->len -
+ 					 offsetof(struct ieee80211_mgmt,
+ 						  u.s1g_assoc_resp.variable);
+ 		}
+ 
+ 		if (cr.ap_mld_addr)
+ 			cr.valid_links |= BIT(link_id);
++>>>>>>> 81151ce462e5 (wifi: mac80211: support MLO authentication/association with one link)
  	}
  
 -	trace_cfg80211_send_rx_assoc(dev, data);
 +	memset(&cr, 0, sizeof(cr));
 +	cr.status = (int)le16_to_cpu(mgmt->u.assoc_resp.status_code);
 +	cr.bssid = mgmt->bssid;
 +	cr.bss = bss;
 +	cr.req_ie = req_ies;
 +	cr.req_ie_len = req_ies_len;
 +	cr.resp_ie = resp_ie;
 +	cr.resp_ie_len = resp_ie_len;
 +	cr.timeout_reason = NL80211_TIMEOUT_UNSPECIFIED;
 +
 +	trace_cfg80211_send_rx_assoc(dev, bss);
  
  	/*
  	 * This is a bit of a hack, we don't notify userspace of
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 1d0fde5d1620..4544aad9f2bb 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -385,37 +385,55 @@ struct ieee80211_mgd_auth_data {
 	bool peer_confirmed;
 	bool timeout_started;
 
+	u8 ap_addr[ETH_ALEN] __aligned(2);
+
 	u16 sae_trans, sae_status;
 	size_t data_len;
 	u8 data[];
 };
 
 struct ieee80211_mgd_assoc_data {
-	struct cfg80211_bss *bss;
+	struct {
+		struct cfg80211_bss *bss;
+
+		u8 addr[ETH_ALEN] __aligned(2);
+
+		u8 ap_ht_param;
+
+		struct ieee80211_vht_cap ap_vht_cap;
+
+		size_t elems_len;
+		u8 *elems; /* pointing to inside ie[] below */
+
+		ieee80211_conn_flags_t conn_flags;
+	} link[IEEE80211_MLD_MAX_NUM_LINKS];
+
+	u8 ap_addr[ETH_ALEN] __aligned(2);
+
+	/* this is for a workaround, so we use it only for non-MLO */
 	const u8 *supp_rates;
+	u8 supp_rates_len;
 
 	unsigned long timeout;
 	int tries;
 
-	u16 capability;
-	u8 prev_bssid[ETH_ALEN];
+	u8 prev_ap_addr[ETH_ALEN];
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
 	u8 ssid_len;
-	u8 supp_rates_len;
 	bool wmm, uapsd;
 	bool need_beacon;
 	bool synced;
 	bool timeout_started;
+	bool s1g;
 
-	u8 ap_ht_param;
-
-	struct ieee80211_vht_cap ap_vht_cap;
+	unsigned int assoc_link_id;
 
 	u8 fils_nonces[2 * FILS_NONCE_LEN];
 	u8 fils_kek[FILS_MAX_KEK_LEN];
 	size_t fils_kek_len;
 
 	size_t ie_len;
+	u8 *ie_pos; /* used to fill ie[] with link[].elems */
 	u8 ie[];
 };
 
* Unmerged path net/mac80211/mlme.c
* Unmerged path net/mac80211/tx.c
* Unmerged path net/wireless/mlme.c
