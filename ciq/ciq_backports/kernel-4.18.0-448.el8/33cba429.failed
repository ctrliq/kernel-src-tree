net: ipv4: use kfree_skb_reason() in ip_rcv_core()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit 33cba42985c8144eef78d618fc1e51aaa074b169
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/33cba429.failed

Replace kfree_skb() with kfree_skb_reason() in ip_rcv_core(). Three new
drop reasons are introduced:

SKB_DROP_REASON_OTHERHOST
SKB_DROP_REASON_IP_CSUM
SKB_DROP_REASON_IP_INHDR

	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 33cba42985c8144eef78d618fc1e51aaa074b169)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/trace/events/skb.h
#	net/ipv4/ip_input.c
diff --cc include/linux/skbuff.h
index 6050fa383222,8e82130b3c52..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,22 +318,26 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
++>>>>>>> 33cba42985c8 (net: ipv4: use kfree_skb_reason() in ip_rcv_core())
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/trace/events/skb.h
index 294c61bbe44b,f2b1778485f0..000000000000
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@@ -11,6 -11,15 +11,18 @@@
  
  #define TRACE_SKB_DROP_REASON					\
  	EM(SKB_DROP_REASON_NOT_SPECIFIED, NOT_SPECIFIED)	\
++<<<<<<< HEAD
++=======
+ 	EM(SKB_DROP_REASON_NO_SOCKET, NO_SOCKET)		\
+ 	EM(SKB_DROP_REASON_PKT_TOO_SMALL, PKT_TOO_SMALL)	\
+ 	EM(SKB_DROP_REASON_TCP_CSUM, TCP_CSUM)			\
+ 	EM(SKB_DROP_REASON_SOCKET_FILTER, SOCKET_FILTER)	\
+ 	EM(SKB_DROP_REASON_UDP_CSUM, UDP_CSUM)			\
+ 	EM(SKB_DROP_REASON_NETFILTER_DROP, NETFILTER_DROP)	\
+ 	EM(SKB_DROP_REASON_OTHERHOST, OTHERHOST)		\
+ 	EM(SKB_DROP_REASON_IP_CSUM, IP_CSUM)			\
+ 	EM(SKB_DROP_REASON_IP_INHDR, IP_INHDR)			\
++>>>>>>> 33cba42985c8 (net: ipv4: use kfree_skb_reason() in ip_rcv_core())
  	EMe(SKB_DROP_REASON_MAX, MAX)
  
  #undef EM
diff --cc net/ipv4/ip_input.c
index 17dd51970d0a,7be18de32e16..000000000000
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@@ -414,20 -415,38 +414,26 @@@ drop_error
  /*
   * 	Main IP Receive routine.
   */
 -static struct sk_buff *ip_rcv_core(struct sk_buff *skb, struct net *net)
 +int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
  {
  	const struct iphdr *iph;
++<<<<<<< HEAD
 +	struct net *net;
++=======
+ 	int drop_reason;
++>>>>>>> 33cba42985c8 (net: ipv4: use kfree_skb_reason() in ip_rcv_core())
  	u32 len;
  
  	/* When the interface is in promisc. mode, drop all the crap
  	 * that it receives, do not try to analyse it.
  	 */
- 	if (skb->pkt_type == PACKET_OTHERHOST)
+ 	if (skb->pkt_type == PACKET_OTHERHOST) {
+ 		drop_reason = SKB_DROP_REASON_OTHERHOST;
  		goto drop;
+ 	}
  
 +
 +	net = dev_net(dev);
  	__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb->len);
  
  	skb = skb_share_check(skb, GFP_ATOMIC);
@@@ -497,16 -518,136 +505,19 @@@
  	if (!skb_sk_is_prefetched(skb))
  		skb_orphan(skb);
  
 -	return skb;
 +	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
 +		       net, NULL, skb, dev, NULL,
 +		       ip_rcv_finish);
  
  csum_error:
+ 	drop_reason = SKB_DROP_REASON_IP_CSUM;
  	__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);
  inhdr_error:
+ 	if (drop_reason == SKB_DROP_REASON_NOT_SPECIFIED)
+ 		drop_reason = SKB_DROP_REASON_IP_INHDR;
  	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);
  drop:
- 	kfree_skb(skb);
+ 	kfree_skb_reason(skb, drop_reason);
  out:
 -	return NULL;
 -}
 -
 -/*
 - * IP receive entry point
 - */
 -int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 -	   struct net_device *orig_dev)
 -{
 -	struct net *net = dev_net(dev);
 -
 -	skb = ip_rcv_core(skb, net);
 -	if (skb == NULL)
 -		return NET_RX_DROP;
 -
 -	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
 -		       net, NULL, skb, dev, NULL,
 -		       ip_rcv_finish);
 -}
 -
 -static void ip_sublist_rcv_finish(struct list_head *head)
 -{
 -	struct sk_buff *skb, *next;
 -
 -	list_for_each_entry_safe(skb, next, head, list) {
 -		skb_list_del_init(skb);
 -		dst_input(skb);
 -	}
 -}
 -
 -static struct sk_buff *ip_extract_route_hint(const struct net *net,
 -					     struct sk_buff *skb, int rt_type)
 -{
 -	if (fib4_has_custom_rules(net) || rt_type == RTN_BROADCAST)
 -		return NULL;
 -
 -	return skb;
 -}
 -
 -static void ip_list_rcv_finish(struct net *net, struct sock *sk,
 -			       struct list_head *head)
 -{
 -	struct sk_buff *skb, *next, *hint = NULL;
 -	struct dst_entry *curr_dst = NULL;
 -	struct list_head sublist;
 -
 -	INIT_LIST_HEAD(&sublist);
 -	list_for_each_entry_safe(skb, next, head, list) {
 -		struct net_device *dev = skb->dev;
 -		struct dst_entry *dst;
 -
 -		skb_list_del_init(skb);
 -		/* if ingress device is enslaved to an L3 master device pass the
 -		 * skb to its handler for processing
 -		 */
 -		skb = l3mdev_ip_rcv(skb);
 -		if (!skb)
 -			continue;
 -		if (ip_rcv_finish_core(net, sk, skb, dev, hint) == NET_RX_DROP)
 -			continue;
 -
 -		dst = skb_dst(skb);
 -		if (curr_dst != dst) {
 -			hint = ip_extract_route_hint(net, skb,
 -					       ((struct rtable *)dst)->rt_type);
 -
 -			/* dispatch old sublist */
 -			if (!list_empty(&sublist))
 -				ip_sublist_rcv_finish(&sublist);
 -			/* start new sublist */
 -			INIT_LIST_HEAD(&sublist);
 -			curr_dst = dst;
 -		}
 -		list_add_tail(&skb->list, &sublist);
 -	}
 -	/* dispatch final sublist */
 -	ip_sublist_rcv_finish(&sublist);
 -}
 -
 -static void ip_sublist_rcv(struct list_head *head, struct net_device *dev,
 -			   struct net *net)
 -{
 -	NF_HOOK_LIST(NFPROTO_IPV4, NF_INET_PRE_ROUTING, net, NULL,
 -		     head, dev, NULL, ip_rcv_finish);
 -	ip_list_rcv_finish(net, NULL, head);
 -}
 -
 -/* Receive a list of IP packets */
 -void ip_list_rcv(struct list_head *head, struct packet_type *pt,
 -		 struct net_device *orig_dev)
 -{
 -	struct net_device *curr_dev = NULL;
 -	struct net *curr_net = NULL;
 -	struct sk_buff *skb, *next;
 -	struct list_head sublist;
 -
 -	INIT_LIST_HEAD(&sublist);
 -	list_for_each_entry_safe(skb, next, head, list) {
 -		struct net_device *dev = skb->dev;
 -		struct net *net = dev_net(dev);
 -
 -		skb_list_del_init(skb);
 -		skb = ip_rcv_core(skb, net);
 -		if (skb == NULL)
 -			continue;
 -
 -		if (curr_dev != dev || curr_net != net) {
 -			/* dispatch old sublist */
 -			if (!list_empty(&sublist))
 -				ip_sublist_rcv(&sublist, curr_dev, curr_net);
 -			/* start new sublist */
 -			INIT_LIST_HEAD(&sublist);
 -			curr_dev = dev;
 -			curr_net = net;
 -		}
 -		list_add_tail(&skb->list, &sublist);
 -	}
 -	/* dispatch final sublist */
 -	if (!list_empty(&sublist))
 -		ip_sublist_rcv(&sublist, curr_dev, curr_net);
 +	return NET_RX_DROP;
  }
* Unmerged path include/linux/skbuff.h
* Unmerged path include/trace/events/skb.h
* Unmerged path net/ipv4/ip_input.c
