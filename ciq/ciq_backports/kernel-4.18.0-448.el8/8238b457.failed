wait_on_bit: add an acquire memory barrier

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 8238b4579866b7c1bb99883cfe102a43db5506ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8238b457.failed

There are several places in the kernel where wait_on_bit is not followed
by a memory barrier (for example, in drivers/md/dm-bufio.c:new_read).

On architectures with weak memory ordering, it may happen that memory
accesses that follow wait_on_bit are reordered before wait_on_bit and
they may return invalid data.

Fix this class of bugs by introducing a new function "test_bit_acquire"
that works like test_bit, but has acquire memory ordering semantics.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Acked-by: Will Deacon <will@kernel.org>
	Cc: stable@vger.kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8238b4579866b7c1bb99883cfe102a43db5506ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/atomic_bitops.txt
#	include/asm-generic/bitops/generic-non-atomic.h
#	include/asm-generic/bitops/instrumented-non-atomic.h
#	include/asm-generic/bitops/non-atomic.h
#	include/asm-generic/bitops/non-instrumented-non-atomic.h
#	include/linux/bitops.h
diff --cc Documentation/atomic_bitops.txt
index be70b32c95d9,edea4656c5c0..000000000000
--- a/Documentation/atomic_bitops.txt
+++ b/Documentation/atomic_bitops.txt
@@@ -58,13 -58,11 +58,18 @@@ Like with atomic_t, the rule of thumb i
  
   - RMW operations that have a return value are fully ordered.
  
++<<<<<<< HEAD
 + - RMW operations that are conditional are unordered on FAILURE,
 +   otherwise the above rules apply. In the case of test_and_{}_bit() operations,
 +   if the bit in memory is unchanged by the operation then it is deemed to have
 +   failed.
++=======
+  - RMW operations that are conditional are fully ordered.
++>>>>>>> 8238b4579866 (wait_on_bit: add an acquire memory barrier)
  
- Except for a successful test_and_set_bit_lock() which has ACQUIRE semantics and
- clear_bit_unlock() which has RELEASE semantics.
+ Except for a successful test_and_set_bit_lock() which has ACQUIRE semantics,
+ clear_bit_unlock() which has RELEASE semantics and test_bit_acquire which has
+ ACQUIRE semantics.
  
  Since a platform only has a single means of achieving atomic operations
  the same barriers as for atomic_t are used, see atomic_t.txt.
diff --cc include/asm-generic/bitops/non-atomic.h
index 7e10c4b50c5d,71f8d54a5195..000000000000
--- a/include/asm-generic/bitops/non-atomic.h
+++ b/include/asm-generic/bitops/non-atomic.h
@@@ -2,108 -2,19 +2,113 @@@
  #ifndef _ASM_GENERIC_BITOPS_NON_ATOMIC_H_
  #define _ASM_GENERIC_BITOPS_NON_ATOMIC_H_
  
 -#include <asm-generic/bitops/generic-non-atomic.h>
 +#include <asm/types.h>
  
 -#define arch___set_bit generic___set_bit
 -#define arch___clear_bit generic___clear_bit
 -#define arch___change_bit generic___change_bit
 +/**
 + * __set_bit - Set a bit in memory
 + * @nr: the bit to set
 + * @addr: the address to start counting from
 + *
 + * Unlike set_bit(), this function is non-atomic and may be reordered.
 + * If it's called on the same region of memory simultaneously, the effect
 + * may be that only one operation succeeds.
 + */
 +static inline void __set_bit(int nr, volatile unsigned long *addr)
 +{
 +	unsigned long mask = BIT_MASK(nr);
 +	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
  
 -#define arch___test_and_set_bit generic___test_and_set_bit
 -#define arch___test_and_clear_bit generic___test_and_clear_bit
 -#define arch___test_and_change_bit generic___test_and_change_bit
 +	*p  |= mask;
 +}
  
++<<<<<<< HEAD
 +static inline void __clear_bit(int nr, volatile unsigned long *addr)
 +{
 +	unsigned long mask = BIT_MASK(nr);
 +	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
++=======
+ #define arch_test_bit generic_test_bit
+ #define arch_test_bit_acquire generic_test_bit_acquire
++>>>>>>> 8238b4579866 (wait_on_bit: add an acquire memory barrier)
  
 -#include <asm-generic/bitops/non-instrumented-non-atomic.h>
 +	*p &= ~mask;
 +}
 +
 +/**
 + * __change_bit - Toggle a bit in memory
 + * @nr: the bit to change
 + * @addr: the address to start counting from
 + *
 + * Unlike change_bit(), this function is non-atomic and may be reordered.
 + * If it's called on the same region of memory simultaneously, the effect
 + * may be that only one operation succeeds.
 + */
 +static inline void __change_bit(int nr, volatile unsigned long *addr)
 +{
 +	unsigned long mask = BIT_MASK(nr);
 +	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
 +
 +	*p ^= mask;
 +}
 +
 +/**
 + * __test_and_set_bit - Set a bit and return its old value
 + * @nr: Bit to set
 + * @addr: Address to count from
 + *
 + * This operation is non-atomic and can be reordered.
 + * If two examples of this operation race, one can appear to succeed
 + * but actually fail.  You must protect multiple accesses with a lock.
 + */
 +static inline int __test_and_set_bit(int nr, volatile unsigned long *addr)
 +{
 +	unsigned long mask = BIT_MASK(nr);
 +	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
 +	unsigned long old = *p;
 +
 +	*p = old | mask;
 +	return (old & mask) != 0;
 +}
 +
 +/**
 + * __test_and_clear_bit - Clear a bit and return its old value
 + * @nr: Bit to clear
 + * @addr: Address to count from
 + *
 + * This operation is non-atomic and can be reordered.
 + * If two examples of this operation race, one can appear to succeed
 + * but actually fail.  You must protect multiple accesses with a lock.
 + */
 +static inline int __test_and_clear_bit(int nr, volatile unsigned long *addr)
 +{
 +	unsigned long mask = BIT_MASK(nr);
 +	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
 +	unsigned long old = *p;
 +
 +	*p = old & ~mask;
 +	return (old & mask) != 0;
 +}
 +
 +/* WARNING: non atomic and it can be reordered! */
 +static inline int __test_and_change_bit(int nr,
 +					    volatile unsigned long *addr)
 +{
 +	unsigned long mask = BIT_MASK(nr);
 +	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
 +	unsigned long old = *p;
 +
 +	*p = old ^ mask;
 +	return (old & mask) != 0;
 +}
 +
 +/**
 + * test_bit - Determine whether a bit is set
 + * @nr: bit number to test
 + * @addr: Address to start counting from
 + */
 +static inline int test_bit(int nr, const volatile unsigned long *addr)
 +{
 +	return 1UL & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG-1)));
 +}
  
  #endif /* _ASM_GENERIC_BITOPS_NON_ATOMIC_H_ */
diff --cc include/linux/bitops.h
index d4bc94e2a7c2,3b89c64bcfd8..000000000000
--- a/include/linux/bitops.h
+++ b/include/linux/bitops.h
@@@ -19,6 -27,41 +19,44 @@@ extern unsigned int __sw_hweight32(unsi
  extern unsigned long __sw_hweight64(__u64 w);
  
  /*
++<<<<<<< HEAD
++=======
+  * Defined here because those may be needed by architecture-specific static
+  * inlines.
+  */
+ 
+ #include <asm-generic/bitops/generic-non-atomic.h>
+ 
+ /*
+  * Many architecture-specific non-atomic bitops contain inline asm code and due
+  * to that the compiler can't optimize them to compile-time expressions or
+  * constants. In contrary, generic_*() helpers are defined in pure C and
+  * compilers optimize them just well.
+  * Therefore, to make `unsigned long foo = 0; __set_bit(BAR, &foo)` effectively
+  * equal to `unsigned long foo = BIT(BAR)`, pick the generic C alternative when
+  * the arguments can be resolved at compile time. That expression itself is a
+  * constant and doesn't bring any functional changes to the rest of cases.
+  * The casts to `uintptr_t` are needed to mitigate `-Waddress` warnings when
+  * passing a bitmap from .bss or .data (-> `!!addr` is always true).
+  */
+ #define bitop(op, nr, addr)						\
+ 	((__builtin_constant_p(nr) &&					\
+ 	  __builtin_constant_p((uintptr_t)(addr) != (uintptr_t)NULL) &&	\
+ 	  (uintptr_t)(addr) != (uintptr_t)NULL &&			\
+ 	  __builtin_constant_p(*(const unsigned long *)(addr))) ?	\
+ 	 const##op(nr, addr) : op(nr, addr))
+ 
+ #define __set_bit(nr, addr)		bitop(___set_bit, nr, addr)
+ #define __clear_bit(nr, addr)		bitop(___clear_bit, nr, addr)
+ #define __change_bit(nr, addr)		bitop(___change_bit, nr, addr)
+ #define __test_and_set_bit(nr, addr)	bitop(___test_and_set_bit, nr, addr)
+ #define __test_and_clear_bit(nr, addr)	bitop(___test_and_clear_bit, nr, addr)
+ #define __test_and_change_bit(nr, addr)	bitop(___test_and_change_bit, nr, addr)
+ #define test_bit(nr, addr)		bitop(_test_bit, nr, addr)
+ #define test_bit_acquire(nr, addr)	bitop(_test_bit_acquire, nr, addr)
+ 
+ /*
++>>>>>>> 8238b4579866 (wait_on_bit: add an acquire memory barrier)
   * Include this here because some architectures need generic_ffs/fls in
   * scope
   */
* Unmerged path include/asm-generic/bitops/generic-non-atomic.h
* Unmerged path include/asm-generic/bitops/instrumented-non-atomic.h
* Unmerged path include/asm-generic/bitops/non-instrumented-non-atomic.h
* Unmerged path Documentation/atomic_bitops.txt
diff --git a/arch/x86/include/asm/bitops.h b/arch/x86/include/asm/bitops.h
index 802d0255c932..9c02c6913b04 100644
--- a/arch/x86/include/asm/bitops.h
+++ b/arch/x86/include/asm/bitops.h
@@ -212,6 +212,20 @@ static __no_kcsan_or_inline bool constant_test_bit(long nr, const volatile unsig
 		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
 }
 
+static __always_inline bool constant_test_bit_acquire(long nr, const volatile unsigned long *addr)
+{
+	bool oldbit;
+
+	asm volatile("testb %2,%1"
+		     CC_SET(nz)
+		     : CC_OUT(nz) (oldbit)
+		     : "m" (((unsigned char *)addr)[nr >> 3]),
+		       "i" (1 << (nr & 7))
+		     :"memory");
+
+	return oldbit;
+}
+
 static __always_inline bool variable_test_bit(long nr, volatile const unsigned long *addr)
 {
 	bool oldbit;
@@ -229,6 +243,13 @@ static __always_inline bool variable_test_bit(long nr, volatile const unsigned l
 	 ? constant_test_bit((nr), (addr))	\
 	 : variable_test_bit((nr), (addr)))
 
+static __always_inline bool
+arch_test_bit_acquire(unsigned long nr, const volatile unsigned long *addr)
+{
+	return __builtin_constant_p(nr) ? constant_test_bit_acquire(nr, addr) :
+					  variable_test_bit(nr, addr);
+}
+
 /**
  * __ffs - find first set bit in word
  * @word: The word to search
* Unmerged path include/asm-generic/bitops/generic-non-atomic.h
* Unmerged path include/asm-generic/bitops/instrumented-non-atomic.h
* Unmerged path include/asm-generic/bitops/non-atomic.h
* Unmerged path include/asm-generic/bitops/non-instrumented-non-atomic.h
* Unmerged path include/linux/bitops.h
diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h
index 8fab480a8e4e..16a83d1d3832 100644
--- a/include/linux/buffer_head.h
+++ b/include/linux/buffer_head.h
@@ -155,7 +155,7 @@ static __always_inline int buffer_uptodate(const struct buffer_head *bh)
 	 * make it consistent with folio_test_uptodate
 	 * pairs with smp_mb__before_atomic in set_buffer_uptodate
 	 */
-	return (smp_load_acquire(&bh->b_state) & (1UL << BH_Uptodate)) != 0;
+	return test_bit_acquire(BH_Uptodate, &bh->b_state);
 }
 
 #define bh_offset(bh)		((unsigned long)(bh)->b_data & ~PAGE_MASK)
diff --git a/include/linux/wait_bit.h b/include/linux/wait_bit.h
index 7dec36aecbd9..7725b7579b78 100644
--- a/include/linux/wait_bit.h
+++ b/include/linux/wait_bit.h
@@ -71,7 +71,7 @@ static inline int
 wait_on_bit(unsigned long *word, int bit, unsigned mode)
 {
 	might_sleep();
-	if (!test_bit(bit, word))
+	if (!test_bit_acquire(bit, word))
 		return 0;
 	return out_of_line_wait_on_bit(word, bit,
 				       bit_wait,
@@ -96,7 +96,7 @@ static inline int
 wait_on_bit_io(unsigned long *word, int bit, unsigned mode)
 {
 	might_sleep();
-	if (!test_bit(bit, word))
+	if (!test_bit_acquire(bit, word))
 		return 0;
 	return out_of_line_wait_on_bit(word, bit,
 				       bit_wait_io,
@@ -123,7 +123,7 @@ wait_on_bit_timeout(unsigned long *word, int bit, unsigned mode,
 		    unsigned long timeout)
 {
 	might_sleep();
-	if (!test_bit(bit, word))
+	if (!test_bit_acquire(bit, word))
 		return 0;
 	return out_of_line_wait_on_bit_timeout(word, bit,
 					       bit_wait_timeout,
@@ -151,7 +151,7 @@ wait_on_bit_action(unsigned long *word, int bit, wait_bit_action_f *action,
 		   unsigned mode)
 {
 	might_sleep();
-	if (!test_bit(bit, word))
+	if (!test_bit_acquire(bit, word))
 		return 0;
 	return out_of_line_wait_on_bit(word, bit, action, mode);
 }
diff --git a/kernel/sched/wait_bit.c b/kernel/sched/wait_bit.c
index 5a22245bb8fb..d12e8e4d1c6c 100644
--- a/kernel/sched/wait_bit.c
+++ b/kernel/sched/wait_bit.c
@@ -46,7 +46,7 @@ __wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_
 		prepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);
 		if (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))
 			ret = (*action)(&wbq_entry->key, mode);
-	} while (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);
+	} while (test_bit_acquire(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);
 
 	finish_wait(wq_head, &wbq_entry->wq_entry);
 
