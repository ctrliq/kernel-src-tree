cgroup: account for memory_localevents in test_memcg_oom_group_leaf_events()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author David Vernet <void@manifault.com>
commit 72b1e03aa7255094d15752952a7e56c5f39b6e37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/72b1e03a.failed

The test_memcg_oom_group_leaf_events() testcase in the cgroup memcg tests
validates that processes in a group that perform allocations exceeding
memory.oom.group are killed.  It also validates that the
memory.events.oom_kill events are properly propagated in this case.

Commit 06e11c907ea4 ("kselftests: memcg: update the oom group leaf events
test") fixed test_memcg_oom_group_leaf_events() to account for the fact
that the memory.events.oom_kill events in a child cgroup is propagated up
to its parent.  This behavior can actually be configured by the
memory_localevents mount option, so this patch updates the testcase to
properly account for the possible presence of this mount option.

Link: https://lkml.kernel.org/r/20220423155619.3669555-4-void@manifault.com
	Signed-off-by: David Vernet <void@manifault.com>
	Acked-by: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Tejun Heo <tj@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 72b1e03aa7255094d15752952a7e56c5f39b6e37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/cgroup/test_memcontrol.c
diff --cc tools/testing/selftests/cgroup/test_memcontrol.c
index 10053377ccef,31d5c3f9b2b2..000000000000
--- a/tools/testing/selftests/cgroup/test_memcontrol.c
+++ b/tools/testing/selftests/cgroup/test_memcontrol.c
@@@ -20,6 -21,9 +20,12 @@@
  #include "../kselftest.h"
  #include "cgroup_util.h"
  
++<<<<<<< HEAD
++=======
+ static bool has_localevents;
+ static bool has_recursiveprot;
+ 
++>>>>>>> 72b1e03aa725 (cgroup: account for memory_localevents in test_memcg_oom_group_leaf_events())
  /*
   * This test creates two nested cgroups with and without enabling
   * the memory controller.
@@@ -1316,6 -1410,16 +1328,19 @@@ int main(int argc, char **argv
  		if (cg_write(root, "cgroup.subtree_control", "+memory"))
  			ksft_exit_skip("Failed to set memory controller\n");
  
++<<<<<<< HEAD
++=======
+ 	proc_status = proc_mount_contains("memory_recursiveprot");
+ 	if (proc_status < 0)
+ 		ksft_exit_skip("Failed to query cgroup mount option\n");
+ 	has_recursiveprot = proc_status;
+ 
+ 	proc_status = proc_mount_contains("memory_localevents");
+ 	if (proc_status < 0)
+ 		ksft_exit_skip("Failed to query cgroup mount option\n");
+ 	has_localevents = proc_status;
+ 
++>>>>>>> 72b1e03aa725 (cgroup: account for memory_localevents in test_memcg_oom_group_leaf_events())
  	for (i = 0; i < ARRAY_SIZE(tests); i++) {
  		switch (tests[i].fn(root)) {
  		case KSFT_PASS:
* Unmerged path tools/testing/selftests/cgroup/test_memcontrol.c
