x86/fault: Don't send SIGSEGV twice on SEGV_PKUERR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jiashuo Liang <liangjs@pku.edu.cn>
commit 5405b42c2f08efe67b531799ba2fdb35bac93e70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/5405b42c.failed

__bad_area_nosemaphore() calls both force_sig_pkuerr() and
force_sig_fault() when handling SEGV_PKUERR. This does not cause
problems because the second signal is filtered by the legacy_queue()
check in __send_signal() because in both cases, the signal is SIGSEGV,
the second one seeing that the first one is already pending.

This causes the kernel to do unnecessary work so send the signal only
once for SEGV_PKUERR.

 [ bp: Massage commit message. ]

Fixes: 9db812dbb29d ("signal/x86: Call force_sig_pkuerr from __bad_area_nosemaphore")
	Suggested-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Jiashuo Liang <liangjs@pku.edu.cn>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
Link: https://lkml.kernel.org/r/20210601085203.40214-1-liangjs@pku.edu.cn
(cherry picked from commit 5405b42c2f08efe67b531799ba2fdb35bac93e70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/fault.c
diff --cc arch/x86/mm/fault.c
index b63f70b6ee4c,6bda7f67d737..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -879,10 -805,41 +879,32 @@@ __bad_area_nosemaphore(struct pt_regs *
  		return;
  	}
  
 -	/*
 -	 * User mode accesses just cause a SIGSEGV.
 -	 * It's possible to have interrupts off here:
 -	 */
 -	local_irq_enable();
 -
 -	/*
 -	 * Valid to do another page fault here because this one came
 -	 * from user space:
 -	 */
 -	if (is_prefetch(regs, error_code, address))
 +	if (is_f00f_bug(regs, address))
  		return;
  
++<<<<<<< HEAD
 +	no_context(regs, error_code, address, SIGSEGV, si_code);
++=======
+ 	if (is_errata100(regs, address))
+ 		return;
+ 
+ 	sanitize_error_code(address, &error_code);
+ 
+ 	if (fixup_vdso_exception(regs, X86_TRAP_PF, error_code, address))
+ 		return;
+ 
+ 	if (likely(show_unhandled_signals))
+ 		show_signal_msg(regs, error_code, address, tsk);
+ 
+ 	set_signal_archinfo(address, error_code);
+ 
+ 	if (si_code == SEGV_PKUERR)
+ 		force_sig_pkuerr((void __user *)address, pkey);
+ 	else
+ 		force_sig_fault(SIGSEGV, si_code, (void __user *)address);
+ 
+ 	local_irq_disable();
++>>>>>>> 5405b42c2f08 (x86/fault: Don't send SIGSEGV twice on SEGV_PKUERR)
  }
  
  static noinline void
* Unmerged path arch/x86/mm/fault.c
