xfs: factor out forced iclog flushes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Dave Chinner <dchinner@redhat.com>
commit 45eddb414047c366744cc60dd6cef7c7e58c6ab9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/45eddb41.failed

We force iclogs in several places - we need them all to have the
same cache flush semantics, so start by factoring out the iclog
force into a common helper.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit 45eddb414047c366744cc60dd6cef7c7e58c6ab9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log.c
diff --cc fs/xfs/xfs_log.c
index 06474c360c0a,184c68ea62bb..000000000000
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@@ -791,10 -779,26 +791,31 @@@ xfs_log_mount_cancel
  }
  
  /*
++<<<<<<< HEAD
 + * Wait for the iclog to be written disk, or return an error if the log has been
 + * shut down.
++=======
+  * Flush out the iclog to disk ensuring that device caches are flushed and
+  * the iclog hits stable storage before any completion waiters are woken.
+  */
+ static inline int
+ xlog_force_iclog(
+ 	struct xlog_in_core	*iclog)
+ {
+ 	atomic_inc(&iclog->ic_refcnt);
+ 	if (iclog->ic_state == XLOG_STATE_ACTIVE)
+ 		xlog_state_switch_iclogs(iclog->ic_log, iclog, 0);
+ 	return xlog_state_release_iclog(iclog->ic_log, iclog, 0);
+ }
+ 
+ /*
+  * Wait for the iclog and all prior iclogs to be written disk as required by the
+  * log force state machine. Waiting on ic_force_wait ensures iclog completions
+  * have been ordered and callbacks run before we are woken here, hence
+  * guaranteeing that all the iclogs up to this one are on stable storage.
++>>>>>>> 45eddb414047 (xfs: factor out forced iclog flushes)
   */
 -int
 +static int
  xlog_wait_on_iclog(
  	struct xlog_in_core	*iclog)
  		__releases(iclog->ic_log->l_icloglock)
@@@ -876,13 -877,8 +897,18 @@@ out_err
  
  	spin_lock(&log->l_icloglock);
  	iclog = log->l_iclog;
++<<<<<<< HEAD
 +	atomic_inc(&iclog->ic_refcnt);
 +	if (iclog->ic_state == XLOG_STATE_ACTIVE)
 +		xlog_state_switch_iclogs(log, iclog, 0);
 +	else
 +		ASSERT(iclog->ic_state == XLOG_STATE_WANT_SYNC ||
 +		       iclog->ic_state == XLOG_STATE_IOERROR);
 +	error = xlog_state_release_iclog(log, iclog);
++=======
+ 	iclog->ic_flags |= (XLOG_ICL_NEED_FLUSH | XLOG_ICL_NEED_FUA);
+ 	error = xlog_force_iclog(iclog);
++>>>>>>> 45eddb414047 (xfs: factor out forced iclog flushes)
  	xlog_wait_on_iclog(iclog);
  
  	if (tic) {
@@@ -3233,17 -3205,9 +3259,14 @@@ xfs_log_force
  		iclog = iclog->ic_prev;
  	} else if (iclog->ic_state == XLOG_STATE_ACTIVE) {
  		if (atomic_read(&iclog->ic_refcnt) == 0) {
- 			/*
- 			 * We are the only one with access to this iclog.
- 			 *
- 			 * Flush it out now.  There should be a roundoff of zero
- 			 * to show that someone has already taken care of the
- 			 * roundoff from the previous sync.
- 			 */
- 			atomic_inc(&iclog->ic_refcnt);
+ 			/* We have exclusive access to this iclog. */
  			lsn = be64_to_cpu(iclog->ic_header.h_lsn);
++<<<<<<< HEAD
 +			xlog_state_switch_iclogs(log, iclog, 0);
 +			if (xlog_state_release_iclog(log, iclog))
++=======
+ 			if (xlog_force_iclog(iclog))
++>>>>>>> 45eddb414047 (xfs: factor out forced iclog flushes)
  				goto out_error;
  
  			if (be64_to_cpu(iclog->ic_header.h_lsn) != lsn)
@@@ -3321,9 -3285,7 +3344,13 @@@ xlog_force_lsn
  					&log->l_icloglock);
  			return -EAGAIN;
  		}
++<<<<<<< HEAD
 +		atomic_inc(&iclog->ic_refcnt);
 +		xlog_state_switch_iclogs(log, iclog, 0);
 +		if (xlog_state_release_iclog(log, iclog))
++=======
+ 		if (xlog_force_iclog(iclog))
++>>>>>>> 45eddb414047 (xfs: factor out forced iclog flushes)
  			goto out_error;
  		if (log_flushed)
  			*log_flushed = 1;
* Unmerged path fs/xfs/xfs_log.c
