wifi: mac80211: mlme: refactor assoc req element building

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 978420c2105ca903f8eb563106ea0f676a170ab6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/978420c2.failed

For MLO, we will need to build these elements per link, so
factor out the code that does this, returning the capability,
to simplify building the multi-link element in the future.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 978420c2105ca903f8eb563106ea0f676a170ab6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,150dd211466e..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -767,6 -753,330 +767,333 @@@ static void ieee80211_add_eht_ie(struc
  	ieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + eht_cap_size);
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_assoc_add_rates(struct sk_buff *skb,
+ 				      enum nl80211_chan_width width,
+ 				      struct ieee80211_supported_band *sband,
+ 				      struct ieee80211_mgd_assoc_data *assoc_data)
+ {
+ 	unsigned int shift = ieee80211_chanwidth_get_shift(width);
+ 	unsigned int rates_len, supp_rates_len;
+ 	u32 rates = 0;
+ 	int i, count;
+ 	u8 *pos;
+ 
+ 	if (assoc_data->supp_rates_len) {
+ 		/*
+ 		 * Get all rates supported by the device and the AP as
+ 		 * some APs don't like getting a superset of their rates
+ 		 * in the association request (e.g. D-Link DAP 1353 in
+ 		 * b-only mode)...
+ 		 */
+ 		rates_len = ieee80211_parse_bitrates(width, sband,
+ 						     assoc_data->supp_rates,
+ 						     assoc_data->supp_rates_len,
+ 						     &rates);
+ 	} else {
+ 		/*
+ 		 * In case AP not provide any supported rates information
+ 		 * before association, we send information element(s) with
+ 		 * all rates that we support.
+ 		 */
+ 		rates_len = sband->n_bitrates;
+ 		for (i = 0; i < sband->n_bitrates; i++)
+ 			rates |= BIT(i);
+ 	}
+ 
+ 	supp_rates_len = rates_len;
+ 	if (supp_rates_len > 8)
+ 		supp_rates_len = 8;
+ 
+ 	pos = skb_put(skb, supp_rates_len + 2);
+ 	*pos++ = WLAN_EID_SUPP_RATES;
+ 	*pos++ = supp_rates_len;
+ 
+ 	count = 0;
+ 	for (i = 0; i < sband->n_bitrates; i++) {
+ 		if (BIT(i) & rates) {
+ 			int rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
+ 						5 * (1 << shift));
+ 			*pos++ = (u8)rate;
+ 			if (++count == 8)
+ 				break;
+ 		}
+ 	}
+ 
+ 	if (rates_len > count) {
+ 		pos = skb_put(skb, rates_len - count + 2);
+ 		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+ 		*pos++ = rates_len - count;
+ 
+ 		for (i++; i < sband->n_bitrates; i++) {
+ 			if (BIT(i) & rates) {
+ 				int rate;
+ 
+ 				rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
+ 						    5 * (1 << shift));
+ 				*pos++ = (u8)rate;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static size_t ieee80211_add_before_ht_elems(struct sk_buff *skb,
+ 					    const u8 *elems,
+ 					    size_t elems_len,
+ 					    size_t offset)
+ {
+ 	size_t noffset;
+ 
+ 	static const u8 before_ht[] = {
+ 		WLAN_EID_SSID,
+ 		WLAN_EID_SUPP_RATES,
+ 		WLAN_EID_EXT_SUPP_RATES,
+ 		WLAN_EID_PWR_CAPABILITY,
+ 		WLAN_EID_SUPPORTED_CHANNELS,
+ 		WLAN_EID_RSN,
+ 		WLAN_EID_QOS_CAPA,
+ 		WLAN_EID_RRM_ENABLED_CAPABILITIES,
+ 		WLAN_EID_MOBILITY_DOMAIN,
+ 		WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
+ 		WLAN_EID_RIC_DATA,		/* reassoc only */
+ 		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+ 	};
+ 	static const u8 after_ric[] = {
+ 		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+ 		WLAN_EID_HT_CAPABILITY,
+ 		WLAN_EID_BSS_COEX_2040,
+ 		/* luckily this is almost always there */
+ 		WLAN_EID_EXT_CAPABILITY,
+ 		WLAN_EID_QOS_TRAFFIC_CAPA,
+ 		WLAN_EID_TIM_BCAST_REQ,
+ 		WLAN_EID_INTERWORKING,
+ 		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
+ 		WLAN_EID_VHT_CAPABILITY,
+ 		WLAN_EID_OPMODE_NOTIF,
+ 	};
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	noffset = ieee80211_ie_split_ric(elems, elems_len,
+ 					 before_ht,
+ 					 ARRAY_SIZE(before_ht),
+ 					 after_ric,
+ 					 ARRAY_SIZE(after_ric),
+ 					 offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_add_before_vht_elems(struct sk_buff *skb,
+ 					     const u8 *elems,
+ 					     size_t elems_len,
+ 					     size_t offset)
+ {
+ 	static const u8 before_vht[] = {
+ 		/*
+ 		 * no need to list the ones split off before HT
+ 		 * or generated here
+ 		 */
+ 		WLAN_EID_BSS_COEX_2040,
+ 		WLAN_EID_EXT_CAPABILITY,
+ 		WLAN_EID_QOS_TRAFFIC_CAPA,
+ 		WLAN_EID_TIM_BCAST_REQ,
+ 		WLAN_EID_INTERWORKING,
+ 		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
+ 	};
+ 	size_t noffset;
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
+ 	noffset = ieee80211_ie_split(elems, elems_len,
+ 				     before_vht, ARRAY_SIZE(before_vht),
+ 				     offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_add_before_he_elems(struct sk_buff *skb,
+ 					    const u8 *elems,
+ 					    size_t elems_len,
+ 					    size_t offset)
+ {
+ 	static const u8 before_he[] = {
+ 		/*
+ 		 * no need to list the ones split off before VHT
+ 		 * or generated here
+ 		 */
+ 		WLAN_EID_OPMODE_NOTIF,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
+ 		/* 11ai elements */
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
+ 		/* TODO: add 11ah/11aj/11ak elements */
+ 	};
+ 	size_t noffset;
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
+ 	noffset = ieee80211_ie_split(elems, elems_len,
+ 				     before_he, ARRAY_SIZE(before_he),
+ 				     offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,
+ 					 struct sk_buff *skb, u16 *capab,
+ 					 const struct element *ext_capa,
+ 					 const u8 *extra_elems,
+ 					 size_t extra_elems_len,
+ 					 struct ieee80211_link_data *link)
+ {
+ 	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
+ 	struct cfg80211_bss *cbss = assoc_data->bss;
+ 	struct ieee80211_channel *chan = cbss->channel;
+ 	const struct ieee80211_sband_iftype_data *iftd;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_supported_band *sband;
+ 	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	size_t offset = 0;
+ 	u8 *pos;
+ 	int i;
+ 
+ 	/*
+ 	 * 5/10 MHz scenarios are only viable without MLO, in which
+ 	 * case this pointer should be used ... All of this is a bit
+ 	 * unclear though, not sure this even works at all.
+ 	 */
+ 	rcu_read_lock();
+ 	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
+ 	if (chanctx_conf)
+ 		width = chanctx_conf->def.width;
+ 	rcu_read_unlock();
+ 
+ 	sband = local->hw.wiphy->bands[chan->band];
+ 	iftd = ieee80211_get_sband_iftype_data(sband, iftype);
+ 
+ 	if (sband->band == NL80211_BAND_2GHZ) {
+ 		*capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
+ 		*capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;
+ 	}
+ 
+ 	if ((cbss->capability & WLAN_CAPABILITY_SPECTRUM_MGMT) &&
+ 	    ieee80211_hw_check(&local->hw, SPECTRUM_MGMT))
+ 		*capab |= WLAN_CAPABILITY_SPECTRUM_MGMT;
+ 
+ 	if (sband->band != NL80211_BAND_S1GHZ)
+ 		ieee80211_assoc_add_rates(skb, width, sband, assoc_data);
+ 
+ 	if (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT ||
+ 	    *capab & WLAN_CAPABILITY_RADIO_MEASURE) {
+ 		struct cfg80211_chan_def chandef = {
+ 			.width = width,
+ 			.chan = chan,
+ 		};
+ 
+ 		pos = skb_put(skb, 4);
+ 		*pos++ = WLAN_EID_PWR_CAPABILITY;
+ 		*pos++ = 2;
+ 		*pos++ = 0; /* min tx power */
+ 		 /* max tx power */
+ 		*pos++ = ieee80211_chandef_max_power(&chandef);
+ 	}
+ 
+ 	/*
+ 	 * Per spec, we shouldn't include the list of channels if we advertise
+ 	 * support for extended channel switching, but we've always done that;
+ 	 * (for now?) apply this restriction only on the (new) 6 GHz band.
+ 	 */
+ 	if (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT &&
+ 	    (sband->band != NL80211_BAND_6GHZ ||
+ 	     !ext_capa || ext_capa->datalen < 1 ||
+ 	     !(ext_capa->data[0] & WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING))) {
+ 		/* TODO: get this in reg domain format */
+ 		pos = skb_put(skb, 2 * sband->n_channels + 2);
+ 		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
+ 		*pos++ = 2 * sband->n_channels;
+ 		for (i = 0; i < sband->n_channels; i++) {
+ 			int cf = sband->channels[i].center_freq;
+ 
+ 			*pos++ = ieee80211_frequency_to_channel(cf);
+ 			*pos++ = 1; /* one channel in the subband*/
+ 		}
+ 	}
+ 
+ 	/* if present, add any custom IEs that go before HT */
+ 	offset = ieee80211_add_before_ht_elems(skb, extra_elems,
+ 					       extra_elems_len,
+ 					       offset);
+ 
+ 	if (sband->band != NL80211_BAND_6GHZ &&
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
+ 		ieee80211_add_ht_ie(sdata, skb,
+ 				    assoc_data->ap_ht_param,
+ 				    sband, chan, link->smps_mode,
+ 				    link->u.mgd.conn_flags);
+ 
+ 	/* if present, add any custom IEs that go before VHT */
+ 	offset = ieee80211_add_before_vht_elems(skb, extra_elems,
+ 						extra_elems_len,
+ 						offset);
+ 
+ 	if (sband->band != NL80211_BAND_6GHZ &&
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		link->conf->mu_mimo_owner =
+ 			ieee80211_add_vht_ie(sdata, skb, sband,
+ 					     &assoc_data->ap_vht_cap,
+ 					     link->u.mgd.conn_flags);
+ 
+ 	/*
+ 	 * If AP doesn't support HT, mark HE and EHT as disabled.
+ 	 * If on the 5GHz band, make sure it supports VHT.
+ 	 */
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT ||
+ 	    (sband->band == NL80211_BAND_5GHZ &&
+ 	     link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		link->u.mgd.conn_flags |=
+ 			IEEE80211_CONN_DISABLE_HE |
+ 			IEEE80211_CONN_DISABLE_EHT;
+ 
+ 	/* if present, add any custom IEs that go before HE */
+ 	offset = ieee80211_add_before_he_elems(skb, extra_elems,
+ 					       extra_elems_len,
+ 					       offset);
+ 
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE))
+ 		ieee80211_add_he_ie(sdata, skb, sband,
+ 				    link->u.mgd.conn_flags);
+ 
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT))
+ 		ieee80211_add_eht_ie(sdata, skb, sband);
+ 
+ 	if (sband->band == NL80211_BAND_S1GHZ) {
+ 		ieee80211_add_aid_request_ie(sdata, skb);
+ 		ieee80211_add_s1g_capab_ie(sdata, &sband->s1g_cap, skb);
+ 	}
+ 
+ 	if (iftd && iftd->vendor_elems.data && iftd->vendor_elems.len)
+ 		skb_put_data(skb, iftd->vendor_elems.data, iftd->vendor_elems.len);
+ 
+ 	return offset;
+ }
+ 
++>>>>>>> 978420c2105c (wifi: mac80211: mlme: refactor assoc req element building)
  static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
  {
  	struct ieee80211_local *local = sdata->local;
@@@ -775,9 -1086,8 +1103,14 @@@
  	struct sk_buff *skb;
  	struct ieee80211_mgmt *mgmt;
  	u8 *pos, qos_info, *ie_start;
++<<<<<<< HEAD
 +	size_t offset = 0, noffset;
 +	int i, count, rates_len, supp_rates_len, shift;
 +	u16 capab;
++=======
+ 	size_t offset, noffset;
+ 	u16 capab = WLAN_CAPABILITY_ESS;
++>>>>>>> 978420c2105c (wifi: mac80211: mlme: refactor assoc req element building)
  	struct ieee80211_supported_band *sband;
  	struct ieee80211_chanctx_conf *chanctx_conf;
  	struct ieee80211_channel *chan;
@@@ -787,6 -1096,7 +1120,10 @@@
  	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
  	const struct ieee80211_sband_iftype_data *iftd;
  	struct ieee80211_prep_tx_info info = {};
++<<<<<<< HEAD
++=======
+ 	void *capab_pos;
++>>>>>>> 978420c2105c (wifi: mac80211: mlme: refactor assoc req element building)
  	int ret;
  
  	/* we know it's writable, cast away the const */
@@@ -909,205 -1189,15 +1241,217 @@@
  	*pos++ = assoc_data->ssid_len;
  	memcpy(pos, assoc_data->ssid, assoc_data->ssid_len);
  
++<<<<<<< HEAD
 +	if (sband->band == NL80211_BAND_S1GHZ)
 +		goto skip_rates;
 +
 +	/* add all rates which were marked to be used above */
 +	supp_rates_len = rates_len;
 +	if (supp_rates_len > 8)
 +		supp_rates_len = 8;
 +
 +	pos = skb_put(skb, supp_rates_len + 2);
 +	*pos++ = WLAN_EID_SUPP_RATES;
 +	*pos++ = supp_rates_len;
 +
 +	count = 0;
 +	for (i = 0; i < sband->n_bitrates; i++) {
 +		if (BIT(i) & rates) {
 +			int rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
 +						5 * (1 << shift));
 +			*pos++ = (u8) rate;
 +			if (++count == 8)
 +				break;
 +		}
 +	}
 +
 +	if (rates_len > count) {
 +		pos = skb_put(skb, rates_len - count + 2);
 +		*pos++ = WLAN_EID_EXT_SUPP_RATES;
 +		*pos++ = rates_len - count;
 +
 +		for (i++; i < sband->n_bitrates; i++) {
 +			if (BIT(i) & rates) {
 +				int rate;
 +				rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
 +						    5 * (1 << shift));
 +				*pos++ = (u8) rate;
 +			}
 +		}
 +	}
 +
 +skip_rates:
 +	if (capab & WLAN_CAPABILITY_SPECTRUM_MGMT ||
 +	    capab & WLAN_CAPABILITY_RADIO_MEASURE) {
 +		pos = skb_put(skb, 4);
 +		*pos++ = WLAN_EID_PWR_CAPABILITY;
 +		*pos++ = 2;
 +		*pos++ = 0; /* min tx power */
 +		 /* max tx power */
 +		*pos++ = ieee80211_chandef_max_power(&chanctx_conf->def);
 +	}
 +
 +	/*
 +	 * Per spec, we shouldn't include the list of channels if we advertise
 +	 * support for extended channel switching, but we've always done that;
 +	 * (for now?) apply this restriction only on the (new) 6 GHz band.
 +	 */
 +	if (capab & WLAN_CAPABILITY_SPECTRUM_MGMT &&
 +	    (sband->band != NL80211_BAND_6GHZ ||
 +	     !ext_capa || ext_capa->datalen < 1 ||
 +	     !(ext_capa->data[0] & WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING))) {
 +		/* TODO: get this in reg domain format */
 +		pos = skb_put(skb, 2 * sband->n_channels + 2);
 +		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
 +		*pos++ = 2 * sband->n_channels;
 +		for (i = 0; i < sband->n_channels; i++) {
 +			int cf = sband->channels[i].center_freq;
 +
 +			*pos++ = ieee80211_frequency_to_channel(cf);
 +			*pos++ = 1; /* one channel in the subband*/
 +		}
 +	}
 +
 +	/* Set MBSSID support for HE AP if needed */
 +	if (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) && assoc_data->ie_len &&
 +	    ext_capa && ext_capa->datalen >= 3)
 +		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
 +
 +	/* if present, add any custom IEs that go before HT */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_ht[] = {
 +			WLAN_EID_SSID,
 +			WLAN_EID_SUPP_RATES,
 +			WLAN_EID_EXT_SUPP_RATES,
 +			WLAN_EID_PWR_CAPABILITY,
 +			WLAN_EID_SUPPORTED_CHANNELS,
 +			WLAN_EID_RSN,
 +			WLAN_EID_QOS_CAPA,
 +			WLAN_EID_RRM_ENABLED_CAPABILITIES,
 +			WLAN_EID_MOBILITY_DOMAIN,
 +			WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
 +			WLAN_EID_RIC_DATA,		/* reassoc only */
 +			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 +		};
 +		static const u8 after_ric[] = {
 +			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 +			WLAN_EID_HT_CAPABILITY,
 +			WLAN_EID_BSS_COEX_2040,
 +			/* luckily this is almost always there */
 +			WLAN_EID_EXT_CAPABILITY,
 +			WLAN_EID_QOS_TRAFFIC_CAPA,
 +			WLAN_EID_TIM_BCAST_REQ,
 +			WLAN_EID_INTERWORKING,
 +			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
 +			WLAN_EID_VHT_CAPABILITY,
 +			WLAN_EID_OPMODE_NOTIF,
 +		};
 +
 +		noffset = ieee80211_ie_split_ric(assoc_data->ie,
 +						 assoc_data->ie_len,
 +						 before_ht,
 +						 ARRAY_SIZE(before_ht),
 +						 after_ric,
 +						 ARRAY_SIZE(after_ric),
 +						 offset);
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	if (WARN_ON_ONCE((ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +			 !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +
 +	if (sband->band != NL80211_BAND_6GHZ &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
 +		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
 +				    sband, chan, sdata->smps_mode);
 +
 +	/* if present, add any custom IEs that go before VHT */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_vht[] = {
 +			/*
 +			 * no need to list the ones split off before HT
 +			 * or generated here
 +			 */
 +			WLAN_EID_BSS_COEX_2040,
 +			WLAN_EID_EXT_CAPABILITY,
 +			WLAN_EID_QOS_TRAFFIC_CAPA,
 +			WLAN_EID_TIM_BCAST_REQ,
 +			WLAN_EID_INTERWORKING,
 +			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
 +		};
 +
 +		/* RIC already taken above, so no need to handle here anymore */
 +		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
 +					     before_vht, ARRAY_SIZE(before_vht),
 +					     offset);
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	/* if present, add any custom IEs that go before HE */
 +	if (assoc_data->ie_len) {
 +		static const u8 before_he[] = {
 +			/*
 +			 * no need to list the ones split off before VHT
 +			 * or generated here
 +			 */
 +			WLAN_EID_OPMODE_NOTIF,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
 +			/* 11ai elements */
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
 +			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
 +			/* TODO: add 11ah/11aj/11ak elements */
 +		};
 +
 +		/* RIC already taken above, so no need to handle here anymore */
 +		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
 +					     before_he, ARRAY_SIZE(before_he),
 +					     offset);
 +		pos = skb_put(skb, noffset - offset);
 +		memcpy(pos, assoc_data->ie + offset, noffset - offset);
 +		offset = noffset;
 +	}
 +
 +	if (sband->band != NL80211_BAND_6GHZ &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_add_vht_ie(sdata, skb, sband,
 +				     &assoc_data->ap_vht_cap);
 +
 +	/*
 +	 * If AP doesn't support HT, mark HE and EHT as disabled.
 +	 * If on the 5GHz band, make sure it supports VHT.
 +	 */
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT ||
 +	    (sband->band == NL80211_BAND_5GHZ &&
 +	     ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +			        IEEE80211_STA_DISABLE_EHT;
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		ieee80211_add_he_ie(sdata, skb, sband);
 +
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
 +			ieee80211_add_eht_ie(sdata, skb, sband);
 +	}
 +
 +	/* if present, add any custom non-vendor IEs that go after HE */
++=======
+ 	/* add the elements for the assoc (main) link */
+ 	offset = ieee80211_assoc_link_elems(sdata, skb, &capab,
+ 					    ext_capa,
+ 					    assoc_data->ie,
+ 					    assoc_data->ie_len,
+ 					    link);
+ 	put_unaligned_le16(capab, capab_pos);
+ 
+ 	/* if present, add any custom non-vendor IEs */
++>>>>>>> 978420c2105c (wifi: mac80211: mlme: refactor assoc req element building)
  	if (assoc_data->ie_len) {
  		noffset = ieee80211_ie_split_vendor(assoc_data->ie,
  						    assoc_data->ie_len,
* Unmerged path net/mac80211/mlme.c
