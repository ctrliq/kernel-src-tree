ASoC: cs35l41: Move cs35l41 exit hibernate function into shared code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit 94e0bc317ad241c022a6bb311b3a28b4d51ea8b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/94e0bc31.failed

CS35L41 HDA Driver will support hibernation using DSP firmware,
move the exit hibernate function into shared code so this can
be reused.

	Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
	Signed-off-by: Vitaly Rodionov <vitalyr@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20220525131638.5512-10-vitalyr@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 94e0bc317ad241c022a6bb311b3a28b4d51ea8b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/cs35l41.h
#	sound/soc/codecs/cs35l41-lib.c
#	sound/soc/codecs/cs35l41.c
diff --cc include/sound/cs35l41.h
index 1f1e3c6c9be1,7759f2e14d96..000000000000
--- a/include/sound/cs35l41.h
+++ b/include/sound/cs35l41.h
@@@ -27,8 -780,111 +27,111 @@@ struct cs35l41_platform_data 
  	int bst_ipk;
  	int bst_cap;
  	int dout_hiz;
 -	struct cs35l41_gpio_cfg gpio1;
 -	struct cs35l41_gpio_cfg gpio2;
 -	unsigned int spk_pos;
 -
 -	enum cs35l41_boost_type bst_type;
 +	struct cs35l41_irq_cfg irq_config1;
 +	struct cs35l41_irq_cfg irq_config2;
  };
  
++<<<<<<< HEAD
++=======
+ struct cs35l41_otp_packed_element_t {
+ 	u32 reg;
+ 	u8 shift;
+ 	u8 size;
+ };
+ 
+ struct cs35l41_otp_map_element_t {
+ 	u32 id;
+ 	u32 num_elements;
+ 	const struct cs35l41_otp_packed_element_t *map;
+ 	u32 bit_offset;
+ 	u32 word_offset;
+ };
+ 
+ enum cs35l41_cspl_mbox_status {
+ 	CSPL_MBOX_STS_RUNNING = 0,
+ 	CSPL_MBOX_STS_PAUSED = 1,
+ 	CSPL_MBOX_STS_RDY_FOR_REINIT = 2,
+ };
+ 
+ enum cs35l41_cspl_mbox_cmd {
+ 	CSPL_MBOX_CMD_NONE = 0,
+ 	CSPL_MBOX_CMD_PAUSE = 1,
+ 	CSPL_MBOX_CMD_RESUME = 2,
+ 	CSPL_MBOX_CMD_REINIT = 3,
+ 	CSPL_MBOX_CMD_STOP_PRE_REINIT = 4,
+ 	CSPL_MBOX_CMD_HIBERNATE = 5,
+ 	CSPL_MBOX_CMD_OUT_OF_HIBERNATE = 6,
+ 	CSPL_MBOX_CMD_UNKNOWN_CMD = -1,
+ 	CSPL_MBOX_CMD_INVALID_SEQUENCE = -2,
+ };
+ 
+ /*
+  * IRQs
+  */
+ #define CS35L41_IRQ(_irq, _name, _hand)		\
+ 	{					\
+ 		.irq = CS35L41_ ## _irq ## _IRQ,\
+ 		.name = _name,			\
+ 		.handler = _hand,		\
+ 	}
+ 
+ struct cs35l41_irq {
+ 	int irq;
+ 	const char *name;
+ 	irqreturn_t (*handler)(int irq, void *data);
+ };
+ 
+ #define CS35L41_REG_IRQ(_reg, _irq)					\
+ 	[CS35L41_ ## _irq ## _IRQ] = {					\
+ 		.reg_offset = (CS35L41_ ## _reg) - CS35L41_IRQ1_STATUS1,\
+ 		.mask = CS35L41_ ## _irq ## _MASK			\
+ 	}
+ 
+ /* (0x0000E010) CS35L41_IRQ1_STATUS1 */
+ #define CS35L41_BST_OVP_ERR_SHIFT		6
+ #define CS35L41_BST_OVP_ERR_MASK		BIT(CS35L41_BST_OVP_ERR_SHIFT)
+ #define CS35L41_BST_DCM_UVP_ERR_SHIFT		7
+ #define CS35L41_BST_DCM_UVP_ERR_MASK		BIT(CS35L41_BST_DCM_UVP_ERR_SHIFT)
+ #define CS35L41_BST_SHORT_ERR_SHIFT		8
+ #define CS35L41_BST_SHORT_ERR_MASK		BIT(CS35L41_BST_SHORT_ERR_SHIFT)
+ #define CS35L41_TEMP_WARN_SHIFT			15
+ #define CS35L41_TEMP_WARN_MASK			BIT(CS35L41_TEMP_WARN_SHIFT)
+ #define CS35L41_TEMP_ERR_SHIFT			17
+ #define CS35L41_TEMP_ERR_MASK			BIT(CS35L41_TEMP_ERR_SHIFT)
+ #define CS35L41_AMP_SHORT_ERR_SHIFT		31
+ #define CS35L41_AMP_SHORT_ERR_MASK		BIT(CS35L41_AMP_SHORT_ERR_SHIFT)
+ 
+ enum cs35l41_irq_list {
+ 	CS35L41_BST_OVP_ERR_IRQ,
+ 	CS35L41_BST_DCM_UVP_ERR_IRQ,
+ 	CS35L41_BST_SHORT_ERR_IRQ,
+ 	CS35L41_TEMP_WARN_IRQ,
+ 	CS35L41_TEMP_ERR_IRQ,
+ 	CS35L41_AMP_SHORT_ERR_IRQ,
+ 
+ 	CS35L41_NUM_IRQ
+ };
+ 
+ extern struct regmap_config cs35l41_regmap_i2c;
+ extern struct regmap_config cs35l41_regmap_spi;
+ 
+ int cs35l41_test_key_unlock(struct device *dev, struct regmap *regmap);
+ int cs35l41_test_key_lock(struct device *dev, struct regmap *regmap);
+ int cs35l41_otp_unpack(struct device *dev, struct regmap *regmap);
+ int cs35l41_register_errata_patch(struct device *dev, struct regmap *reg, unsigned int reg_revid);
+ int cs35l41_set_channels(struct device *dev, struct regmap *reg,
+ 			 unsigned int tx_num, unsigned int *tx_slot,
+ 			 unsigned int rx_num, unsigned int *rx_slot);
+ int cs35l41_gpio_config(struct regmap *regmap, struct cs35l41_hw_cfg *hw_cfg);
+ void cs35l41_configure_cs_dsp(struct device *dev, struct regmap *reg, struct cs_dsp *dsp);
+ int cs35l41_set_cspl_mbox_cmd(struct device *dev, struct regmap *regmap,
+ 			      enum cs35l41_cspl_mbox_cmd cmd);
+ int cs35l41_write_fs_errata(struct device *dev, struct regmap *regmap);
+ int cs35l41_exit_hibernate(struct device *dev, struct regmap *regmap);
+ int cs35l41_init_boost(struct device *dev, struct regmap *regmap,
+ 		       struct cs35l41_hw_cfg *hw_cfg);
+ bool cs35l41_safe_reset(struct regmap *regmap, enum cs35l41_boost_type b_type);
+ int cs35l41_global_enable(struct regmap *regmap, enum cs35l41_boost_type b_type, int enable);
+ 
++>>>>>>> 94e0bc317ad2 (ASoC: cs35l41: Move cs35l41 exit hibernate function into shared code)
  #endif /* __CS35L41_H */
diff --cc sound/soc/codecs/cs35l41.c
index 25c67931882a,be7d02517739..000000000000
--- a/sound/soc/codecs/cs35l41.c
+++ b/sound/soc/codecs/cs35l41.c
@@@ -1425,6 -1326,108 +1425,111 @@@ void cs35l41_remove(struct cs35l41_priv
  }
  EXPORT_SYMBOL_GPL(cs35l41_remove);
  
++<<<<<<< HEAD
++=======
+ static int __maybe_unused cs35l41_runtime_suspend(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "Runtime suspend\n");
+ 
+ 	if (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)
+ 		return 0;
+ 
+ 	dev_dbg(cs35l41->dev, "Enter hibernate\n");
+ 
+ 	cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
+ 	regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0088);
+ 	regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0188);
+ 
+ 	// Don't wait for ACK since bus activity would wake the device
+ 	regmap_write(cs35l41->regmap, CS35L41_DSP_VIRT1_MBOX_1,
+ 		     CSPL_MBOX_CMD_HIBERNATE);
+ 
+ 	regcache_cache_only(cs35l41->regmap, true);
+ 	regcache_mark_dirty(cs35l41->regmap);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_runtime_resume(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	dev_dbg(cs35l41->dev, "Runtime resume\n");
+ 
+ 	if (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)
+ 		return 0;
+ 
+ 	regcache_cache_only(cs35l41->regmap, false);
+ 
+ 	ret = cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Test key needs to be unlocked to allow the OTP settings to re-apply */
+ 	cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);
+ 	ret = regcache_sync(cs35l41->regmap);
+ 	cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);
+ 	if (ret) {
+ 		dev_err(cs35l41->dev, "Failed to restore register cache: %d\n", ret);
+ 		return ret;
+ 	}
+ 	cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_suspend(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "System suspend, disabling IRQ\n");
+ 	disable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_suspend_noirq(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "Late system suspend, reenabling IRQ\n");
+ 	enable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_resume_noirq(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "Early system resume, disabling IRQ\n");
+ 	disable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused cs35l41_sys_resume(struct device *dev)
+ {
+ 	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	dev_dbg(cs35l41->dev, "System resume, reenabling IRQ\n");
+ 	enable_irq(cs35l41->irq);
+ 
+ 	return 0;
+ }
+ 
+ const struct dev_pm_ops cs35l41_pm_ops = {
+ 	SET_RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume, NULL)
+ 
+ 	SET_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend, cs35l41_sys_resume)
+ 	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend_noirq, cs35l41_sys_resume_noirq)
+ };
+ EXPORT_SYMBOL_GPL(cs35l41_pm_ops);
+ 
++>>>>>>> 94e0bc317ad2 (ASoC: cs35l41: Move cs35l41 exit hibernate function into shared code)
  MODULE_DESCRIPTION("ASoC CS35L41 driver");
  MODULE_AUTHOR("David Rhodes, Cirrus Logic Inc, <david.rhodes@cirrus.com>");
  MODULE_LICENSE("GPL");
* Unmerged path sound/soc/codecs/cs35l41-lib.c
* Unmerged path include/sound/cs35l41.h
* Unmerged path sound/soc/codecs/cs35l41-lib.c
* Unmerged path sound/soc/codecs/cs35l41.c
