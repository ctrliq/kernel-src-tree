fuse: lock inode unconditionally in fuse_fallocate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 44361e8cf9ddb23f17bdcc40ca944abf32e83e79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/44361e8c.failed

file_modified() must be called with inode lock held.  fuse_fallocate()
didn't lock the inode in case of just FALLOC_KEEP_SIZE flags value, which
resulted in a kernel Warning in notify_change().

Lock the inode unconditionally, like all other fallocate implementations
do.

	Reported-by: Pengfei Xu <pengfei.xu@intel.com>
Reported-and-tested-by: syzbot+462da39f0667b357c4b6@syzkaller.appspotmail.com
Fixes: 4a6f278d4827 ("fuse: add file_modified() to fallocate")
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 44361e8cf9ddb23f17bdcc40ca944abf32e83e79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index 09067e3a2be8,89f4741728ba..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -3321,33 -2963,31 +3321,51 @@@ static long fuse_file_fallocate(struct 
  		.mode = mode
  	};
  	int err;
++<<<<<<< HEAD
 +	bool lock_inode = !(mode & FALLOC_FL_KEEP_SIZE) ||
 +			   (mode & FALLOC_FL_PUNCH_HOLE);
 +
 +	bool block_faults = FUSE_IS_DAX(inode) && lock_inode;
++=======
+ 	bool block_faults = FUSE_IS_DAX(inode) &&
+ 		(!(mode & FALLOC_FL_KEEP_SIZE) ||
+ 		 (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)));
++>>>>>>> 44361e8cf9dd (fuse: lock inode unconditionally in fuse_fallocate())
  
 -	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |
 -		     FALLOC_FL_ZERO_RANGE))
 +	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))
  		return -EOPNOTSUPP;
  
  	if (fm->fc->no_fallocate)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (lock_inode) {
 +		inode_lock(inode);
 +		if (block_faults) {
 +			down_write(&fi->i_mmap_sem);
 +			err = fuse_dax_break_layouts(inode, 0, 0);
 +			if (err)
 +				goto out;
 +		}
 +
 +		if (mode & FALLOC_FL_PUNCH_HOLE) {
 +			loff_t endbyte = offset + length - 1;
++=======
+ 	inode_lock(inode);
+ 	if (block_faults) {
+ 		filemap_invalidate_lock(inode->i_mapping);
+ 		err = fuse_dax_break_layouts(inode, 0, 0);
+ 		if (err)
+ 			goto out;
+ 	}
  
- 			err = fuse_writeback_range(inode, offset, endbyte);
- 			if (err)
- 				goto out;
- 		}
+ 	if (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) {
+ 		loff_t endbyte = offset + length - 1;
++>>>>>>> 44361e8cf9dd (fuse: lock inode unconditionally in fuse_fallocate())
+ 
+ 		err = fuse_writeback_range(inode, offset, endbyte);
+ 		if (err)
+ 			goto out;
  	}
  
  	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
@@@ -3395,11 -3033,12 +3413,10 @@@ out
  		clear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);
  
  	if (block_faults)
 -		filemap_invalidate_unlock(inode->i_mapping);
 +		up_write(&fi->i_mmap_sem);
  
- 	if (lock_inode)
- 		inode_unlock(inode);
+ 	inode_unlock(inode);
  
 -	fuse_flush_time_update(inode);
 -
  	return err;
  }
  
* Unmerged path fs/fuse/file.c
