wifi: mac80211: RCU-ify link STA pointers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit c71420db653aba30a234d1e4cf86dde376e604fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c71420db.failed

We need to be able to access these in a race-free way under
traffic while adding/removing them, so RCU-ify the pointers.
This requires passing a link_sta to a lot of functions so
we don't have to do the RCU handling everywhere.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit c71420db653aba30a234d1e4cf86dde376e604fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/mac80211.h
#	net/mac80211/cfg.c
#	net/mac80211/chan.c
#	net/mac80211/eht.c
#	net/mac80211/he.c
#	net/mac80211/ht.c
#	net/mac80211/ibss.c
#	net/mac80211/ieee80211_i.h
#	net/mac80211/iface.c
#	net/mac80211/mesh_plink.c
#	net/mac80211/mlme.c
#	net/mac80211/rate.c
#	net/mac80211/rx.c
#	net/mac80211/sta_info.c
#	net/mac80211/sta_info.h
#	net/mac80211/tdls.c
#	net/mac80211/vht.c
diff --cc include/net/mac80211.h
index 7ae1aa619f5c,27f24ac0426d..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -2129,6 -2199,10 +2129,13 @@@ struct ieee80211_sta 
  
  	struct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];
  
++<<<<<<< HEAD
++=======
+ 	u16 valid_links;
+ 	struct ieee80211_link_sta deflink;
+ 	struct ieee80211_link_sta __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
+ 
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	/* must be last */
  	u8 drv_priv[] __aligned(sizeof(void *));
  };
diff --cc net/mac80211/cfg.c
index 0990954e0931,b387f5f4fef0..000000000000
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@@ -1738,19 -1771,21 +1738,33 @@@ static int sta_apply_parameters(struct 
  
  	if (params->ht_capa)
  		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
++<<<<<<< HEAD
 +						  params->ht_capa, sta);
++=======
+ 						  params->ht_capa,
+ 						  &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	/* VHT can override some HT caps such as the A-MSDU max length */
  	if (params->vht_capa)
  		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
++<<<<<<< HEAD
 +						    params->vht_capa, sta);
++=======
+ 						    params->vht_capa,
+ 						    &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	if (params->he_capa)
  		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
  						  (void *)params->he_capa,
  						  params->he_capa_len,
  						  (void *)params->he_6ghz_capa,
++<<<<<<< HEAD
 +						  sta);
++=======
+ 						  &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	if (params->eht_capa)
  		ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
@@@ -1758,13 -1793,14 +1772,22 @@@
  						    params->he_capa_len,
  						    params->eht_capa,
  						    params->eht_capa_len,
++<<<<<<< HEAD
 +						    sta);
++=======
+ 						    &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	if (params->opmode_notif_used) {
  		/* returned value is only needed for rc update, but the
  		 * rc isn't initialized here yet, so ignore it
  		 */
++<<<<<<< HEAD
 +		__ieee80211_vht_handle_opmode(sdata, sta, params->opmode_notif,
++=======
+ 		__ieee80211_vht_handle_opmode(sdata, &sta->deflink,
+ 					      params->opmode_notif,
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  					      sband->band);
  	}
  
diff --cc net/mac80211/chan.c
index 37035c3e5f8a,6853b563fb6c..000000000000
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@@ -193,13 -204,23 +193,30 @@@ ieee80211_find_reservation_chanctx(stru
  	return NULL;
  }
  
 -static enum nl80211_chan_width ieee80211_get_sta_bw(struct sta_info *sta,
 -						    unsigned int link_id)
 +static enum nl80211_chan_width ieee80211_get_sta_bw(struct sta_info *sta)
  {
++<<<<<<< HEAD
 +	enum ieee80211_sta_rx_bandwidth width = ieee80211_sta_cap_rx_bw(sta);
++=======
+ 	enum ieee80211_sta_rx_bandwidth width;
+ 	struct link_sta_info *link_sta;
+ 
+ 	link_sta = rcu_dereference(sta->link[link_id]);
+ 
+ 	/* no effect if this STA has no presence on this link */
+ 	if (!link_sta)
+ 		return NL80211_CHAN_WIDTH_20_NOHT;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
+ 
+ 	width = ieee80211_sta_cap_rx_bw(link_sta);
  
  	switch (width) {
  	case IEEE80211_STA_RX_BW_20:
++<<<<<<< HEAD
 +		if (sta->sta.ht_cap.ht_supported)
++=======
+ 		if (link_sta->pub->ht_cap.ht_supported)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  			return NL80211_CHAN_WIDTH_20;
  		else
  			return NL80211_CHAN_WIDTH_20_NOHT;
@@@ -368,24 -417,36 +385,53 @@@ static void ieee80211_chan_bw_change(st
  		if (!ieee80211_sdata_running(sta->sdata))
  			continue;
  
++<<<<<<< HEAD
 +		if (rcu_access_pointer(sta->sdata->vif.bss_conf.chanctx_conf) !=
 +		    &ctx->conf)
 +			continue;
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sta->sdata->link); link_id++) {
+ 			struct ieee80211_bss_conf *link_conf =
+ 				sdata->vif.link_conf[link_id];
+ 			struct link_sta_info *link_sta;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
 -			if (!link_conf)
 -				continue;
 +		new_sta_bw = ieee80211_sta_cur_vht_bw(sta);
  
 -			if (rcu_access_pointer(link_conf->chanctx_conf) != &ctx->conf)
 -				continue;
 +		/* nothing change */
 +		if (new_sta_bw == sta->sta.bandwidth)
 +			continue;
  
++<<<<<<< HEAD
 +		/* vif changed to narrow BW and narrow BW for station wasn't
 +		 * requested or vise versa */
 +		if ((new_sta_bw < sta->sta.bandwidth) == !narrowed)
 +			continue;
 +
 +		sta->sta.bandwidth = new_sta_bw;
 +		rate_control_rate_update(local, sband, sta,
 +					 IEEE80211_RC_BW_CHANGED);
++=======
+ 			link_sta = rcu_dereference(sta->link[link_id]);
+ 			if (!link_sta)
+ 				continue;
+ 
+ 			new_sta_bw = ieee80211_sta_cur_vht_bw(link_sta);
+ 
+ 			/* nothing change */
+ 			if (new_sta_bw == link_sta->pub->bandwidth)
+ 				continue;
+ 
+ 			/* vif changed to narrow BW and narrow BW for station wasn't
+ 			 * requested or vise versa */
+ 			if ((new_sta_bw < link_sta->pub->bandwidth) == !narrowed)
+ 				continue;
+ 
+ 			link_sta->pub->bandwidth = new_sta_bw;
+ 			rate_control_rate_update(local, sband, sta, link_id,
+ 						 IEEE80211_RC_BW_CHANGED);
+ 		}
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	}
  	rcu_read_unlock();
  }
diff --cc net/mac80211/eht.c
index 364ad0ef7692,31e20a342f21..000000000000
--- a/net/mac80211/eht.c
+++ b/net/mac80211/eht.c
@@@ -12,9 -12,10 +12,16 @@@ ieee80211_eht_cap_ie_to_sta_eht_cap(str
  				    struct ieee80211_supported_band *sband,
  				    const u8 *he_cap_ie, u8 he_cap_len,
  				    const struct ieee80211_eht_cap_elem *eht_cap_ie_elem,
++<<<<<<< HEAD
 +				    u8 eht_cap_len, struct sta_info *sta)
 +{
 +	struct ieee80211_sta_eht_cap *eht_cap = &sta->sta.eht_cap;
++=======
+ 				    u8 eht_cap_len,
+ 				    struct link_sta_info *link_sta)
+ {
+ 	struct ieee80211_sta_eht_cap *eht_cap = &link_sta->pub->eht_cap;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	struct ieee80211_he_cap_elem *he_cap_ie_elem = (void *)he_cap_ie;
  	u8 eht_ppe_size = 0;
  	u8 mcs_nss_size;
@@@ -71,6 -72,6 +78,11 @@@
  
  	eht_cap->has_eht = true;
  
++<<<<<<< HEAD
 +	sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(sta);
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
++=======
+ 	link_sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(link_sta);
+ 	link_sta->pub->bandwidth = ieee80211_sta_cur_vht_bw(link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  }
diff --cc net/mac80211/he.c
index c05af7018f79,d9228fd3f77a..000000000000
--- a/net/mac80211/he.c
+++ b/net/mac80211/he.c
@@@ -10,8 -10,9 +10,13 @@@
  
  static void
  ieee80211_update_from_he_6ghz_capa(const struct ieee80211_he_6ghz_capa *he_6ghz_capa,
++<<<<<<< HEAD
 +				   struct sta_info *sta)
++=======
+ 				   struct link_sta_info *link_sta)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  {
+ 	struct sta_info *sta = link_sta->sta;
  	enum ieee80211_smps_mode smps_mode;
  
  	if (sta->sdata->vif.type == NL80211_IFTYPE_AP ||
@@@ -49,7 -50,7 +54,11 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	sta->sta.he_6ghz_capa = *he_6ghz_capa;
++=======
+ 	link_sta->pub->he_6ghz_capa = *he_6ghz_capa;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  }
  
  static void ieee80211_he_mcs_disable(__le16 *he_mcs)
@@@ -108,9 -109,9 +117,15 @@@ ieee80211_he_cap_ie_to_sta_he_cap(struc
  				  struct ieee80211_supported_band *sband,
  				  const u8 *he_cap_ie, u8 he_cap_len,
  				  const struct ieee80211_he_6ghz_capa *he_6ghz_capa,
++<<<<<<< HEAD
 +				  struct sta_info *sta)
 +{
 +	struct ieee80211_sta_he_cap *he_cap = &sta->sta.he_cap;
++=======
+ 				  struct link_sta_info *link_sta)
+ {
+ 	struct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	struct ieee80211_sta_he_cap own_he_cap;
  	struct ieee80211_he_cap_elem *he_cap_ie_elem = (void *)he_cap_ie;
  	u8 he_ppe_size;
@@@ -153,11 -154,11 +168,19 @@@
  
  	he_cap->has_he = true;
  
++<<<<<<< HEAD
 +	sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(sta);
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
 +
 +	if (sband->band == NL80211_BAND_6GHZ && he_6ghz_capa)
 +		ieee80211_update_from_he_6ghz_capa(he_6ghz_capa, sta);
++=======
+ 	link_sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(link_sta);
+ 	link_sta->pub->bandwidth = ieee80211_sta_cur_vht_bw(link_sta);
+ 
+ 	if (sband->band == NL80211_BAND_6GHZ && he_6ghz_capa)
+ 		ieee80211_update_from_he_6ghz_capa(he_6ghz_capa, link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	ieee80211_he_mcs_intersection(&own_he_cap.he_mcs_nss_supp.rx_mcs_80,
  				      &he_cap->he_mcs_nss_supp.rx_mcs_80,
diff --cc net/mac80211/ht.c
index 2eb7641f5556,2eb3a409b70f..000000000000
--- a/net/mac80211/ht.c
+++ b/net/mac80211/ht.c
@@@ -138,8 -138,9 +138,13 @@@ void ieee80211_apply_htcap_overrides(st
  bool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,
  				       struct ieee80211_supported_band *sband,
  				       const struct ieee80211_ht_cap *ht_cap_ie,
++<<<<<<< HEAD
 +				       struct sta_info *sta)
++=======
+ 				       struct link_sta_info *link_sta)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  {
+ 	struct sta_info *sta = link_sta->sta;
  	struct ieee80211_sta_ht_cap ht_cap, own_cap;
  	u8 ampdu_info, tx_mcs_set_cap;
  	int i, max_tx_streams;
@@@ -243,11 -244,11 +248,19 @@@
  		sta->sta.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_HT_3839;
  
   apply:
++<<<<<<< HEAD
 +	changed = memcmp(&sta->sta.ht_cap, &ht_cap, sizeof(ht_cap));
 +
 +	memcpy(&sta->sta.ht_cap, &ht_cap, sizeof(ht_cap));
 +
 +	switch (sdata->vif.bss_conf.chandef.width) {
++=======
+ 	changed = memcmp(&link_sta->pub->ht_cap, &ht_cap, sizeof(ht_cap));
+ 
+ 	memcpy(&link_sta->pub->ht_cap, &ht_cap, sizeof(ht_cap));
+ 
+ 	switch (sdata->vif.link_conf[link_sta->link_id]->chandef.width) {
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	default:
  		WARN_ON_ONCE(1);
  		fallthrough;
@@@ -264,9 -265,9 +277,15 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	sta->sta.bandwidth = bw;
 +
 +	sta->cur_max_bandwidth =
++=======
+ 	link_sta->pub->bandwidth = bw;
+ 
+ 	link_sta->cur_max_bandwidth =
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  		ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
  				IEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;
  
diff --cc net/mac80211/ibss.c
index cfd5e16e19ac,65b6255c6747..000000000000
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@@ -1051,7 -1051,7 +1051,11 @@@ static void ieee80211_update_sta_info(s
  		memcpy(&htcap_ie, elems->ht_cap_elem, sizeof(htcap_ie));
  		rates_updated |= ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
  								   &htcap_ie,
++<<<<<<< HEAD
 +								   sta);
++=======
+ 								   &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  		if (elems->vht_operation && elems->vht_cap_elem &&
  		    sdata->u.ibss.chandef.width != NL80211_CHAN_WIDTH_20 &&
@@@ -1068,8 -1068,9 +1072,14 @@@
  						   &chandef);
  			memcpy(&cap_ie, elems->vht_cap_elem, sizeof(cap_ie));
  			ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
++<<<<<<< HEAD
 +							    &cap_ie, sta);
 +			if (memcmp(&cap, &sta->sta.vht_cap, sizeof(cap)))
++=======
+ 							    &cap_ie,
+ 							    &sta->deflink);
+ 			if (memcmp(&cap, &sta->sta.deflink.vht_cap, sizeof(cap)))
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  				rates_updated |= true;
  		}
  
diff --cc net/mac80211/ieee80211_i.h
index be4db4fb3d33,46f4e89825a0..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -2031,7 -2061,7 +2031,11 @@@ void ieee80211_apply_htcap_overrides(st
  bool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,
  				       struct ieee80211_supported_band *sband,
  				       const struct ieee80211_ht_cap *ht_cap_ie,
++<<<<<<< HEAD
 +				       struct sta_info *sta);
++=======
+ 				       struct link_sta_info *link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
  			  const u8 *da, u16 tid,
  			  u16 initiator, u16 reason_code);
@@@ -2087,27 -2117,31 +2091,52 @@@ voi
  ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
  				    struct ieee80211_supported_band *sband,
  				    const struct ieee80211_vht_cap *vht_cap_ie,
++<<<<<<< HEAD
 +				    struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta);
 +void ieee80211_sta_set_rx_nss(struct sta_info *sta);
 +enum ieee80211_sta_rx_bandwidth
 +ieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width);
 +enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta);
++=======
+ 				    struct link_sta_info *link_sta);
+ enum ieee80211_sta_rx_bandwidth
+ ieee80211_sta_cap_rx_bw(struct link_sta_info *link_sta);
+ enum ieee80211_sta_rx_bandwidth
+ ieee80211_sta_cur_vht_bw(struct link_sta_info *link_sta);
+ void ieee80211_sta_set_rx_nss(struct link_sta_info *link_sta);
+ enum ieee80211_sta_rx_bandwidth
+ ieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width);
+ enum nl80211_chan_width
+ ieee80211_sta_cap_chan_bw(struct link_sta_info *link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  void ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,
 -				 unsigned int link_id,
  				 struct ieee80211_mgmt *mgmt);
  u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +                                  struct sta_info *sta, u8 opmode,
 +				  enum nl80211_band band);
 +void ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
 +				 struct sta_info *sta, u8 opmode,
 +				 enum nl80211_band band);
++=======
+ 				  struct link_sta_info *sta,
+ 				  u8 opmode, enum nl80211_band band);
+ void ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
+ 				 struct link_sta_info *sta,
+ 				 u8 opmode, enum nl80211_band band);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  void ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,
  				      struct ieee80211_sta_vht_cap *vht_cap);
  void ieee80211_get_vht_mask_from_cap(__le16 vht_cap,
  				     u16 vht_mask[NL80211_VHT_NSS_MAX]);
  enum nl80211_chan_width
++<<<<<<< HEAD
 +ieee80211_sta_rx_bw_to_chan_width(struct sta_info *sta);
++=======
+ ieee80211_sta_rx_bw_to_chan_width(struct link_sta_info *sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  /* HE */
  void
@@@ -2115,7 -2149,7 +2144,11 @@@ ieee80211_he_cap_ie_to_sta_he_cap(struc
  				  struct ieee80211_supported_band *sband,
  				  const u8 *he_cap_ie, u8 he_cap_len,
  				  const struct ieee80211_he_6ghz_capa *he_6ghz_capa,
++<<<<<<< HEAD
 +				  struct sta_info *sta);
++=======
+ 				  struct link_sta_info *link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  void
  ieee80211_he_spr_ie_to_bss_conf(struct ieee80211_vif *vif,
  				const struct ieee80211_he_spr *he_spr_ie_elem);
@@@ -2524,5 -2560,6 +2557,10 @@@ ieee80211_eht_cap_ie_to_sta_eht_cap(str
  				    struct ieee80211_supported_band *sband,
  				    const u8 *he_cap_ie, u8 he_cap_len,
  				    const struct ieee80211_eht_cap_elem *eht_cap_ie_elem,
++<<<<<<< HEAD
 +				    u8 eht_cap_len, struct sta_info *sta);
++=======
+ 				    u8 eht_cap_len,
+ 				    struct link_sta_info *link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  #endif /* IEEE80211_I_H */
diff --cc net/mac80211/iface.c
index 2581d6c14d3a,0cf5a395d925..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -1401,8 -1525,9 +1401,14 @@@ static void ieee80211_iface_process_skb
  			sta = sta_info_get_bss(sdata, mgmt->sa);
  
  			if (sta)
++<<<<<<< HEAD
 +				ieee80211_vht_handle_opmode(sdata, sta, opmode,
 +							    band);
++=======
+ 				ieee80211_vht_handle_opmode(sdata,
+ 							    &sta->deflink,
+ 							    opmode, band);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  			mutex_unlock(&local->sta_mtx);
  			break;
diff --cc net/mac80211/mesh_plink.c
index a829470dd59e,55bed9ce98fe..000000000000
--- a/net/mac80211/mesh_plink.c
+++ b/net/mac80211/mesh_plink.c
@@@ -433,23 -433,25 +433,37 @@@ static void mesh_sta_info_init(struct i
  		goto out;
  	sta->mesh->processed_beacon = true;
  
 -	if (sta->sta.deflink.supp_rates[sband->band] != rates)
 +	if (sta->sta.supp_rates[sband->band] != rates)
  		changed |= IEEE80211_RC_SUPP_RATES_CHANGED;
 -	sta->sta.deflink.supp_rates[sband->band] = rates;
 +	sta->sta.supp_rates[sband->band] = rates;
  
  	if (ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
++<<<<<<< HEAD
 +					      elems->ht_cap_elem, sta))
 +		changed |= IEEE80211_RC_BW_CHANGED;
 +
 +	ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
 +					    elems->vht_cap_elem, sta);
++=======
+ 					      elems->ht_cap_elem,
+ 					      &sta->deflink))
+ 		changed |= IEEE80211_RC_BW_CHANGED;
+ 
+ 	ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
+ 					    elems->vht_cap_elem,
+ 					    &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband, elems->he_cap,
  					  elems->he_cap_len,
  					  elems->he_6ghz_capa,
++<<<<<<< HEAD
 +					  sta);
++=======
+ 					  &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
 -	if (bw != sta->sta.deflink.bandwidth)
 +	if (bw != sta->sta.bandwidth)
  		changed |= IEEE80211_RC_BW_CHANGED;
  
  	/* HT peer is operating 20MHz-only */
diff --cc net/mac80211/mlme.c
index dbd8b816487b,01a72d1fcfcc..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -3566,11 -3566,13 +3566,21 @@@ static bool ieee80211_assoc_success(str
  	/* Set up internal HT/VHT capabilities */
  	if (elems->ht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
  		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
++<<<<<<< HEAD
 +						  elems->ht_cap_elem, sta);
 +
 +	if (elems->vht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
 +						    elems->vht_cap_elem, sta);
++=======
+ 						  elems->ht_cap_elem,
+ 						  &sta->deflink);
+ 
+ 	if (elems->vht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
+ 		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
+ 						    elems->vht_cap_elem,
+ 						    &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	if (elems->he_operation && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
  	    elems->he_cap) {
@@@ -3578,9 -3580,9 +3588,13 @@@
  						  elems->he_cap,
  						  elems->he_cap_len,
  						  elems->he_6ghz_capa,
++<<<<<<< HEAD
 +						  sta);
++=======
+ 						  &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
 -		bss_conf->he_support = sta->sta.deflink.he_cap.has_he;
 +		bss_conf->he_support = sta->sta.he_cap.has_he;
  		if (elems->rsnx && elems->rsnx_len &&
  		    (elems->rsnx[0] & WLAN_RSNX_CAPA_PROTECTED_TWT) &&
  		    wiphy_ext_feature_isset(local->hw.wiphy,
@@@ -3598,9 -3600,9 +3612,13 @@@
  							    elems->he_cap_len,
  							    elems->eht_cap,
  							    elems->eht_cap_len,
++<<<<<<< HEAD
 +							    sta);
++=======
+ 							    &sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
 -			bss_conf->eht_support = sta->sta.deflink.eht_cap.has_eht;
 +			bss_conf->eht_support = sta->sta.eht_cap.has_eht;
  		} else {
  			bss_conf->eht_support = false;
  		}
@@@ -4375,7 -4379,9 +4393,13 @@@ static void ieee80211_rx_mgmt_beacon(st
  	}
  
  	if (sta && elems->opmode_notif)
++<<<<<<< HEAD
 +		ieee80211_vht_handle_opmode(sdata, sta, *elems->opmode_notif,
++=======
+ 		ieee80211_vht_handle_opmode(sdata,
+ 					    &sta->deflink,
+ 					    *elems->opmode_notif,
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  					    rx_status->band);
  	mutex_unlock(&local->sta_mtx);
  
diff --cc net/mac80211/rate.c
index b20b8b79f902,7947e9a162a9..000000000000
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@@ -37,7 -37,7 +37,11 @@@ void rate_control_rate_init(struct sta_
  	struct ieee80211_supported_band *sband;
  	struct ieee80211_chanctx_conf *chanctx_conf;
  
++<<<<<<< HEAD
 +	ieee80211_sta_set_rx_nss(sta);
++=======
+ 	ieee80211_sta_set_rx_nss(&sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	if (!ref)
  		return;
diff --cc net/mac80211/rx.c
index 3722053af051,d017ad14d7db..000000000000
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@@ -3387,22 -3391,22 +3387,34 @@@ ieee80211_rx_h_action(struct ieee80211_
  			if (chanwidth == IEEE80211_HT_CHANWIDTH_20MHZ)
  				max_bw = IEEE80211_STA_RX_BW_20;
  			else
++<<<<<<< HEAD
 +				max_bw = ieee80211_sta_cap_rx_bw(rx->sta);
 +
 +			/* set cur_max_bandwidth and recalc sta bw */
 +			rx->sta->cur_max_bandwidth = max_bw;
 +			new_bw = ieee80211_sta_cur_vht_bw(rx->sta);
++=======
+ 				max_bw = ieee80211_sta_cap_rx_bw(&rx->sta->deflink);
+ 
+ 			/* set cur_max_bandwidth and recalc sta bw */
+ 			rx->sta->deflink.cur_max_bandwidth = max_bw;
+ 			new_bw = ieee80211_sta_cur_vht_bw(&rx->sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
 -			if (rx->sta->sta.deflink.bandwidth == new_bw)
 +			if (rx->sta->sta.bandwidth == new_bw)
  				goto handled;
  
 -			rx->sta->sta.deflink.bandwidth = new_bw;
 +			rx->sta->sta.bandwidth = new_bw;
  			sband = rx->local->hw.wiphy->bands[status->band];
  			sta_opmode.bw =
++<<<<<<< HEAD
 +				ieee80211_sta_rx_bw_to_chan_width(rx->sta);
++=======
+ 				ieee80211_sta_rx_bw_to_chan_width(&rx->sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  			sta_opmode.changed = STA_OPMODE_MAX_BW_CHANGED;
  
 -			rate_control_rate_update(local, sband, rx->sta, 0,
 +			rate_control_rate_update(local, sband, rx->sta,
  						 IEEE80211_RC_BW_CHANGED);
  			cfg80211_sta_opmode_change_notify(sdata->dev,
  							  rx->sta->addr,
diff --cc net/mac80211/sta_info.c
index f2be4a7c4886,1f4189e08675..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -64,6 -64,12 +64,15 @@@
   * freed before they are done using it.
   */
  
++<<<<<<< HEAD
++=======
+ struct sta_link_alloc {
+ 	struct link_sta_info info;
+ 	struct ieee80211_link_sta sta;
+ 	struct rcu_head rcu_head;
+ };
+ 
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  static const struct rhashtable_params sta_rht_params = {
  	.nelem_hint = 3, /* start small */
  	.automatic_shrinking = true,
@@@ -245,6 -251,34 +254,37 @@@ struct sta_info *sta_info_get_by_idx(st
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static void sta_info_free_link(struct link_sta_info *link_sta)
+ {
+ 	free_percpu(link_sta->pcpu_rx_stats);
+ }
+ 
+ static void sta_remove_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct sta_link_alloc *alloc = NULL;
+ 	struct link_sta_info *link_sta;
+ 
+ 	link_sta = rcu_dereference_protected(sta->link[link_id],
+ 					     lockdep_is_held(&sta->local->sta_mtx));
+ 
+ 	if (WARN_ON(!link_sta))
+ 		return;
+ 
+ 	if (link_sta != &sta->deflink)
+ 		alloc = container_of(link_sta, typeof(*alloc), info);
+ 
+ 	sta->sta.valid_links &= ~BIT(link_id);
+ 	RCU_INIT_POINTER(sta->link[link_id], NULL);
+ 	RCU_INIT_POINTER(sta->sta.link[link_id], NULL);
+ 	if (alloc) {
+ 		sta_info_free_link(&alloc->info);
+ 		kfree_rcu(alloc, rcu_head);
+ 	}
+ }
+ 
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  /**
   * sta_info_free - free STA
   *
@@@ -333,8 -377,45 +373,48 @@@ static int sta_prepare_rate_control(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int sta_info_alloc_link(struct ieee80211_local *local,
+ 			       struct link_sta_info *link_info,
+ 			       gfp_t gfp)
+ {
+ 	struct ieee80211_hw *hw = &local->hw;
+ 	int i;
+ 
+ 	if (ieee80211_hw_check(hw, USES_RSS)) {
+ 		link_info->pcpu_rx_stats =
+ 			alloc_percpu_gfp(struct ieee80211_sta_rx_stats, gfp);
+ 		if (!link_info->pcpu_rx_stats)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	link_info->rx_stats.last_rx = jiffies;
+ 	u64_stats_init(&link_info->rx_stats.syncp);
+ 
+ 	ewma_signal_init(&link_info->rx_stats_avg.signal);
+ 	ewma_avg_signal_init(&link_info->status_stats.avg_ack_signal);
+ 	for (i = 0; i < ARRAY_SIZE(link_info->rx_stats_avg.chain_signal); i++)
+ 		ewma_signal_init(&link_info->rx_stats_avg.chain_signal[i]);
+ 
+ 	return 0;
+ }
+ 
+ static void sta_info_add_link(struct sta_info *sta,
+ 			      unsigned int link_id,
+ 			      struct link_sta_info *link_info,
+ 			      struct ieee80211_link_sta *link_sta)
+ {
+ 	link_info->sta = sta;
+ 	link_info->link_id = link_id;
+ 	link_info->pub = link_sta;
+ 	rcu_assign_pointer(sta->link[link_id], link_info);
+ 	rcu_assign_pointer(sta->sta.link[link_id], link_sta);
+ }
+ 
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 -				const u8 *addr, int link_id, gfp_t gfp)
 +				const u8 *addr, gfp_t gfp)
  {
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_hw *hw = &local->hw;
@@@ -2602,3 -2653,79 +2682,82 @@@ void ieee80211_sta_set_expected_through
  
  	sta_update_codel_params(sta, thr);
  }
++<<<<<<< HEAD
++=======
+ 
+ int ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct sta_link_alloc *alloc;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	/* must represent an MLD from the start */
+ 	if (WARN_ON(!sta->sta.valid_links))
+ 		return -EINVAL;
+ 
+ 	if (WARN_ON(sta->sta.valid_links & BIT(link_id) ||
+ 		    sta->link[link_id]))
+ 		return -EBUSY;
+ 
+ 	alloc = kzalloc(sizeof(*alloc), GFP_KERNEL);
+ 	if (!alloc)
+ 		return -ENOMEM;
+ 
+ 	ret = sta_info_alloc_link(sdata->local, &alloc->info, GFP_KERNEL);
+ 	if (ret) {
+ 		kfree(alloc);
+ 		return ret;
+ 	}
+ 
+ 	sta_info_add_link(sta, link_id, &alloc->info, &alloc->sta);
+ 
+ 	return 0;
+ }
+ 
+ int ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct link_sta_info *link_sta;
+ 	u16 old_links = sta->sta.valid_links;
+ 	u16 new_links = old_links | BIT(link_id);
+ 	int ret;
+ 
+ 	link_sta = rcu_dereference_protected(sta->link[link_id],
+ 					     lockdep_is_held(&sdata->local->sta_mtx));
+ 
+ 	if (WARN_ON(old_links == new_links || !link_sta))
+ 		return -EINVAL;
+ 
+ 	sta->sta.valid_links = new_links;
+ 
+ 	if (!test_sta_flag(sta, WLAN_STA_INSERTED))
+ 		return 0;
+ 
+ 	ret = drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				   old_links, new_links);
+ 	if (ret) {
+ 		sta->sta.valid_links = old_links;
+ 		sta_remove_link(sta, link_id);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ void ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	sta->sta.valid_links &= ~BIT(link_id);
+ 
+ 	if (test_sta_flag(sta, WLAN_STA_INSERTED))
+ 		drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				     sta->sta.valid_links,
+ 				     sta->sta.valid_links & ~BIT(link_id));
+ 
+ 	sta_remove_link(sta, link_id);
+ }
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
diff --cc net/mac80211/sta_info.h
index addc78b398f0,27c96c04b13f..000000000000
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@@ -484,6 -484,89 +484,92 @@@ struct ieee80211_fragment_cache 
  #define STA_SLOW_THRESHOLD 6000 /* 6 Mbps */
  
  /**
++<<<<<<< HEAD
++=======
+  * struct link_sta_info - Link STA information
+  * All link specific sta info are stored here for reference. This can be
+  * a single entry for non-MLD STA or multiple entries for MLD STA
+  * @addr: Link MAC address - Can be same as MLD STA mac address and is always
+  *	same for non-MLD STA. This is used as key for searching link STA
+  * @link_id: Link ID uniquely identifying the link STA. This is 0 for non-MLD
+  *	and set to the corresponding vif LinkId for MLD STA
+  * @sta: Points to the STA info
+  * @gtk: group keys negotiated with this station, if any
+  * @tx_stats: TX statistics
+  * @tx_stats.packets: # of packets transmitted
+  * @tx_stats.bytes: # of bytes in all packets transmitted
+  * @tx_stats.last_rate: last TX rate
+  * @tx_stats.msdu: # of transmitted MSDUs per TID
+  * @rx_stats: RX statistics
+  * @rx_stats_avg: averaged RX statistics
+  * @rx_stats_avg.signal: averaged signal
+  * @rx_stats_avg.chain_signal: averaged per-chain signal
+  * @pcpu_rx_stats: per-CPU RX statistics, assigned only if the driver needs
+  *	this (by advertising the USES_RSS hw flag)
+  * @status_stats: TX status statistics
+  * @status_stats.filtered: # of filtered frames
+  * @status_stats.retry_failed: # of frames that failed after retry
+  * @status_stats.retry_count: # of retries attempted
+  * @status_stats.lost_packets: # of lost packets
+  * @status_stats.last_pkt_time: timestamp of last ACKed packet
+  * @status_stats.msdu_retries: # of MSDU retries
+  * @status_stats.msdu_failed: # of failed MSDUs
+  * @status_stats.last_ack: last ack timestamp (jiffies)
+  * @status_stats.last_ack_signal: last ACK signal
+  * @status_stats.ack_signal_filled: last ACK signal validity
+  * @status_stats.avg_ack_signal: average ACK signal
+  * @pub: public (driver visible) link STA data
+  * TODO Move other link params from sta_info as required for MLD operation
+  */
+ struct link_sta_info {
+ 	u8 addr[ETH_ALEN];
+ 	u8 link_id;
+ 
+ 	/* TODO rhash head/node for finding link_sta based on addr */
+ 
+ 	struct sta_info *sta;
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_sta_rx_stats __percpu *pcpu_rx_stats;
+ 
+ 	/* Updated from RX path only, no locking requirements */
+ 	struct ieee80211_sta_rx_stats rx_stats;
+ 	struct {
+ 		struct ewma_signal signal;
+ 		struct ewma_signal chain_signal[IEEE80211_MAX_CHAINS];
+ 	} rx_stats_avg;
+ 
+ 	/* Updated from TX status path only, no locking requirements */
+ 	struct {
+ 		unsigned long filtered;
+ 		unsigned long retry_failed, retry_count;
+ 		unsigned int lost_packets;
+ 		unsigned long last_pkt_time;
+ 		u64 msdu_retries[IEEE80211_NUM_TIDS + 1];
+ 		u64 msdu_failed[IEEE80211_NUM_TIDS + 1];
+ 		unsigned long last_ack;
+ 		s8 last_ack_signal;
+ 		bool ack_signal_filled;
+ 		struct ewma_avg_signal avg_ack_signal;
+ 	} status_stats;
+ 
+ 	/* Updated from TX path only, no locking requirements */
+ 	struct {
+ 		u64 packets[IEEE80211_NUM_ACS];
+ 		u64 bytes[IEEE80211_NUM_ACS];
+ 		struct ieee80211_tx_rate last_rate;
+ 		struct rate_info last_rate_info;
+ 		u64 msdu[IEEE80211_NUM_TIDS + 1];
+ 	} tx_stats;
+ 
+ 	enum ieee80211_sta_rx_bandwidth cur_max_bandwidth;
+ 
+ 	struct ieee80211_link_sta *pub;
+ };
+ 
+ /**
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
   * struct sta_info - STA information
   *
   * This structure collects information about a station that
@@@ -675,6 -710,9 +761,12 @@@ struct sta_info 
  
  	struct ieee80211_fragment_cache frags;
  
++<<<<<<< HEAD
++=======
+ 	struct link_sta_info deflink;
+ 	struct link_sta_info __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
+ 
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	/* keep last! */
  	struct ieee80211_sta sta;
  };
diff --cc net/mac80211/tdls.c
index 601011867929,c531fa17f426..000000000000
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@@ -308,7 -308,8 +308,12 @@@ ieee80211_tdls_chandef_vht_upgrade(stru
  	/* IEEE802.11ac-2013 Table E-4 */
  	u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };
  	struct cfg80211_chan_def uc = sta->tdls_chandef;
++<<<<<<< HEAD
 +	enum nl80211_chan_width max_width = ieee80211_sta_cap_chan_bw(sta);
++=======
+ 	enum nl80211_chan_width max_width =
+ 		ieee80211_sta_cap_chan_bw(&sta->deflink);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	int i;
  
  	/* only support upgrading non-narrow channels up to 80Mhz */
@@@ -1268,10 -1269,10 +1273,17 @@@ static void iee80211_tdls_recalc_chanct
  			enum ieee80211_sta_rx_bandwidth bw;
  
  			bw = ieee80211_chan_width_to_rx_bw(conf->def.width);
++<<<<<<< HEAD
 +			bw = min(bw, ieee80211_sta_cap_rx_bw(sta));
 +			if (bw != sta->sta.bandwidth) {
 +				sta->sta.bandwidth = bw;
 +				rate_control_rate_update(local, sband, sta,
++=======
+ 			bw = min(bw, ieee80211_sta_cap_rx_bw(&sta->deflink));
+ 			if (bw != sta->sta.deflink.bandwidth) {
+ 				sta->sta.deflink.bandwidth = bw;
+ 				rate_control_rate_update(local, sband, sta, 0,
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  							 IEEE80211_RC_BW_CHANGED);
  				/*
  				 * if a TDLS peer BW was updated, we need to
diff --cc net/mac80211/vht.c
index bc39bec42e54,fa14627b499a..000000000000
--- a/net/mac80211/vht.c
+++ b/net/mac80211/vht.c
@@@ -116,16 -116,16 +116,26 @@@ voi
  ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
  				    struct ieee80211_supported_band *sband,
  				    const struct ieee80211_vht_cap *vht_cap_ie,
++<<<<<<< HEAD
 +				    struct sta_info *sta)
 +{
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
++=======
+ 				    struct link_sta_info *link_sta)
+ {
+ 	struct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	struct ieee80211_sta_vht_cap own_cap;
  	u32 cap_info, i;
  	bool have_80mhz;
  
  	memset(vht_cap, 0, sizeof(*vht_cap));
  
++<<<<<<< HEAD
 +	if (!sta->sta.ht_cap.ht_supported)
++=======
+ 	if (!link_sta->pub->ht_cap.ht_supported)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  		return;
  
  	if (!vht_cap_ie || !sband->vht_cap.vht_supported)
@@@ -295,10 -296,10 +306,17 @@@
  	switch (vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {
  	case IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:
  	case IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:
++<<<<<<< HEAD
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +		break;
 +	default:
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
++=======
+ 		link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
+ 		break;
+ 	default:
+ 		link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  		if (!(vht_cap->vht_mcs.tx_highest &
  				cpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE)))
@@@ -310,17 -311,22 +328,29 @@@
  		 * above) between 160 and 80+80 yet.
  		 */
  		if (cap_info & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK)
++<<<<<<< HEAD
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +	}
 +
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
++=======
+ 			link_sta->cur_max_bandwidth =
+ 				IEEE80211_STA_RX_BW_160;
+ 	}
  
+ 	link_sta->pub->bandwidth = ieee80211_sta_cur_vht_bw(link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
+ 
+ 	/*
+ 	 * FIXME - should the amsdu len be per link? store per link
+ 	 * and maintain a minimum?
+ 	 */
  	switch (vht_cap->cap & IEEE80211_VHT_CAP_MAX_MPDU_MASK) {
  	case IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:
- 		sta->sta.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_11454;
+ 		link_sta->sta->sta.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_11454;
  		break;
  	case IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:
- 		sta->sta.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_7991;
+ 		link_sta->sta->sta.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_7991;
  		break;
  	case IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895:
  	default:
@@@ -330,11 -336,15 +360,23 @@@
  }
  
  /* FIXME: move this to some better location - parses HE/EHT now */
++<<<<<<< HEAD
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta)
 +{
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
 +	struct ieee80211_sta_he_cap *he_cap = &sta->sta.he_cap;
 +	struct ieee80211_sta_eht_cap *eht_cap = &sta->sta.eht_cap;
++=======
+ enum ieee80211_sta_rx_bandwidth
+ ieee80211_sta_cap_rx_bw(struct link_sta_info *link_sta)
+ {
+ 	unsigned int link_id = link_sta->link_id;
+ 	struct ieee80211_sub_if_data *sdata = link_sta->sta->sdata;
+ 	struct ieee80211_bss_conf *link_conf = sdata->vif.link_conf[link_id];
+ 	struct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;
+ 	struct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;
+ 	struct ieee80211_sta_eht_cap *eht_cap = &link_sta->pub->eht_cap;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	u32 cap_width;
  
  	if (he_cap->has_he) {
@@@ -369,7 -377,7 +411,11 @@@
  	}
  
  	if (!vht_cap->vht_supported)
++<<<<<<< HEAD
 +		return sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++=======
+ 		return link_sta->pub->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  				IEEE80211_STA_RX_BW_40 :
  				IEEE80211_STA_RX_BW_20;
  
@@@ -390,16 -398,17 +436,30 @@@
  	return IEEE80211_STA_RX_BW_80;
  }
  
++<<<<<<< HEAD
 +enum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta)
 +{
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
 +	u32 cap_width;
 +
 +	if (!vht_cap->vht_supported) {
 +		if (!sta->sta.ht_cap.ht_supported)
 +			return NL80211_CHAN_WIDTH_20_NOHT;
 +
 +		return sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++=======
+ enum nl80211_chan_width
+ ieee80211_sta_cap_chan_bw(struct link_sta_info *link_sta)
+ {
+ 	struct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;
+ 	u32 cap_width;
+ 
+ 	if (!vht_cap->vht_supported) {
+ 		if (!link_sta->pub->ht_cap.ht_supported)
+ 			return NL80211_CHAN_WIDTH_20_NOHT;
+ 
+ 		return link_sta->pub->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  				NL80211_CHAN_WIDTH_40 : NL80211_CHAN_WIDTH_20;
  	}
  
@@@ -414,15 -423,17 +474,28 @@@
  }
  
  enum nl80211_chan_width
++<<<<<<< HEAD
 +ieee80211_sta_rx_bw_to_chan_width(struct sta_info *sta)
 +{
 +	enum ieee80211_sta_rx_bandwidth cur_bw = sta->sta.bandwidth;
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
++=======
+ ieee80211_sta_rx_bw_to_chan_width(struct link_sta_info *link_sta)
+ {
+ 	enum ieee80211_sta_rx_bandwidth cur_bw =
+ 		link_sta->pub->bandwidth;
+ 	struct ieee80211_sta_vht_cap *vht_cap =
+ 		&link_sta->pub->vht_cap;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	u32 cap_width;
  
  	switch (cur_bw) {
  	case IEEE80211_STA_RX_BW_20:
++<<<<<<< HEAD
 +		if (!sta->sta.ht_cap.ht_supported)
++=======
+ 		if (!link_sta->pub->ht_cap.ht_supported)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  			return NL80211_CHAN_WIDTH_20_NOHT;
  		else
  			return NL80211_CHAN_WIDTH_20;
@@@ -466,14 -477,17 +539,29 @@@ ieee80211_chan_width_to_rx_bw(enum nl80
  }
  
  /* FIXME: rename/move - this deals with everything not just VHT */
++<<<<<<< HEAD
 +enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta)
 +{
 +	struct ieee80211_sub_if_data *sdata = sta->sdata;
++=======
+ enum ieee80211_sta_rx_bandwidth
+ ieee80211_sta_cur_vht_bw(struct link_sta_info *link_sta)
+ {
+ 	struct sta_info *sta = link_sta->sta;
+ 	struct ieee80211_bss_conf *link_conf =
+ 		sta->sdata->vif.link_conf[link_sta->link_id];
+ 	enum nl80211_chan_width bss_width = link_conf->chandef.width;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	enum ieee80211_sta_rx_bandwidth bw;
 +	enum nl80211_chan_width bss_width = sdata->vif.bss_conf.chandef.width;
  
++<<<<<<< HEAD
 +	bw = ieee80211_sta_cap_rx_bw(sta);
 +	bw = min(bw, sta->cur_max_bandwidth);
++=======
+ 	bw = ieee80211_sta_cap_rx_bw(link_sta);
+ 	bw = min(bw, link_sta->cur_max_bandwidth);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  	/* Don't consider AP's bandwidth for TDLS peers, section 11.23.1 of
  	 * IEEE80211-2016 specification makes higher bandwidth operation
@@@ -495,18 -509,18 +583,31 @@@
  	return bw;
  }
  
++<<<<<<< HEAD
 +void ieee80211_sta_set_rx_nss(struct sta_info *sta)
++=======
+ void ieee80211_sta_set_rx_nss(struct link_sta_info *link_sta)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  {
  	u8 ht_rx_nss = 0, vht_rx_nss = 0, he_rx_nss = 0, eht_rx_nss = 0, rx_nss;
  	bool support_160;
  
  	/* if we received a notification already don't overwrite it */
++<<<<<<< HEAD
 +	if (sta->sta.rx_nss)
 +		return;
 +
 +	if (sta->sta.eht_cap.has_eht) {
 +		int i;
 +		const u8 *rx_nss_mcs = (void *)&sta->sta.eht_cap.eht_mcs_nss_supp;
++=======
+ 	if (link_sta->pub->rx_nss)
+ 		return;
+ 
+ 	if (link_sta->pub->eht_cap.has_eht) {
+ 		int i;
+ 		const u8 *rx_nss_mcs = (void *)&link_sta->pub->eht_cap.eht_mcs_nss_supp;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  		/* get the max nss for EHT over all possible bandwidths and mcs */
  		for (i = 0; i < sizeof(struct ieee80211_eht_mcs_nss_supp); i++)
@@@ -515,10 -529,10 +616,17 @@@
  						       IEEE80211_EHT_MCS_NSS_RX));
  	}
  
++<<<<<<< HEAD
 +	if (sta->sta.he_cap.has_he) {
 +		int i;
 +		u8 rx_mcs_80 = 0, rx_mcs_160 = 0;
 +		const struct ieee80211_sta_he_cap *he_cap = &sta->sta.he_cap;
++=======
+ 	if (link_sta->pub->he_cap.has_he) {
+ 		int i;
+ 		u8 rx_mcs_80 = 0, rx_mcs_160 = 0;
+ 		const struct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  		u16 mcs_160_map =
  			le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);
  		u16 mcs_80_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80);
@@@ -549,23 -563,23 +657,42 @@@
  			he_rx_nss = rx_mcs_80;
  	}
  
++<<<<<<< HEAD
 +	if (sta->sta.ht_cap.ht_supported) {
 +		if (sta->sta.ht_cap.mcs.rx_mask[0])
 +			ht_rx_nss++;
 +		if (sta->sta.ht_cap.mcs.rx_mask[1])
 +			ht_rx_nss++;
 +		if (sta->sta.ht_cap.mcs.rx_mask[2])
 +			ht_rx_nss++;
 +		if (sta->sta.ht_cap.mcs.rx_mask[3])
++=======
+ 	if (link_sta->pub->ht_cap.ht_supported) {
+ 		if (link_sta->pub->ht_cap.mcs.rx_mask[0])
+ 			ht_rx_nss++;
+ 		if (link_sta->pub->ht_cap.mcs.rx_mask[1])
+ 			ht_rx_nss++;
+ 		if (link_sta->pub->ht_cap.mcs.rx_mask[2])
+ 			ht_rx_nss++;
+ 		if (link_sta->pub->ht_cap.mcs.rx_mask[3])
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  			ht_rx_nss++;
  		/* FIXME: consider rx_highest? */
  	}
  
++<<<<<<< HEAD
 +	if (sta->sta.vht_cap.vht_supported) {
 +		int i;
 +		u16 rx_mcs_map;
 +
 +		rx_mcs_map = le16_to_cpu(sta->sta.vht_cap.vht_mcs.rx_mcs_map);
++=======
+ 	if (link_sta->pub->vht_cap.vht_supported) {
+ 		int i;
+ 		u16 rx_mcs_map;
+ 
+ 		rx_mcs_map = le16_to_cpu(link_sta->pub->vht_cap.vht_mcs.rx_mcs_map);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  
  		for (i = 7; i >= 0; i--) {
  			u8 mcs = (rx_mcs_map >> (2 * i)) & 3;
@@@ -581,12 -595,12 +708,21 @@@
  	rx_nss = max(vht_rx_nss, ht_rx_nss);
  	rx_nss = max(he_rx_nss, rx_nss);
  	rx_nss = max(eht_rx_nss, rx_nss);
++<<<<<<< HEAD
 +	sta->sta.rx_nss = max_t(u8, 1, rx_nss);
 +}
 +
 +u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
 +				  struct sta_info *sta, u8 opmode,
 +				  enum nl80211_band band)
++=======
+ 	link_sta->pub->rx_nss = max_t(u8, 1, rx_nss);
+ }
+ 
+ u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
+ 				  struct link_sta_info *link_sta,
+ 				  u8 opmode, enum nl80211_band band)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  {
  	enum ieee80211_sta_rx_bandwidth new_bw;
  	struct sta_opmode_info sta_opmode = {};
@@@ -601,8 -615,8 +737,13 @@@
  	nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
  	nss += 1;
  
++<<<<<<< HEAD
 +	if (sta->sta.rx_nss != nss) {
 +		sta->sta.rx_nss = nss;
++=======
+ 	if (link_sta->pub->rx_nss != nss) {
+ 		link_sta->pub->rx_nss = nss;
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  		sta_opmode.rx_nss = nss;
  		changed |= IEEE80211_RC_NSS_CHANGED;
  		sta_opmode.changed |= STA_OPMODE_N_SS_CHANGED;
@@@ -611,28 -625,28 +752,53 @@@
  	switch (opmode & IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK) {
  	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ:
  		/* ignore IEEE80211_OPMODE_NOTIF_BW_160_80P80 must not be set */
++<<<<<<< HEAD
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_20;
 +		break;
 +	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ:
 +		/* ignore IEEE80211_OPMODE_NOTIF_BW_160_80P80 must not be set */
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_40;
 +		break;
 +	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ:
 +		if (opmode & IEEE80211_OPMODE_NOTIF_BW_160_80P80)
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +		else
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
 +		break;
 +	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ:
 +		/* legacy only, no longer used by newer spec */
 +		sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +		break;
 +	}
 +
 +	new_bw = ieee80211_sta_cur_vht_bw(sta);
 +	if (new_bw != sta->sta.bandwidth) {
 +		sta->sta.bandwidth = new_bw;
 +		sta_opmode.bw = ieee80211_sta_rx_bw_to_chan_width(sta);
++=======
+ 		link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_20;
+ 		break;
+ 	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ:
+ 		/* ignore IEEE80211_OPMODE_NOTIF_BW_160_80P80 must not be set */
+ 		link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_40;
+ 		break;
+ 	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ:
+ 		if (opmode & IEEE80211_OPMODE_NOTIF_BW_160_80P80)
+ 			link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
+ 		else
+ 			link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;
+ 		break;
+ 	case IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ:
+ 		/* legacy only, no longer used by newer spec */
+ 		link_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
+ 		break;
+ 	}
+ 
+ 	new_bw = ieee80211_sta_cur_vht_bw(link_sta);
+ 	if (new_bw != link_sta->pub->bandwidth) {
+ 		link_sta->pub->bandwidth = new_bw;
+ 		sta_opmode.bw = ieee80211_sta_rx_bw_to_chan_width(link_sta);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  		changed |= IEEE80211_RC_BW_CHANGED;
  		sta_opmode.changed |= STA_OPMODE_MAX_BW_CHANGED;
  	}
@@@ -682,17 -697,19 +848,32 @@@ void ieee80211_update_mu_groups(struct 
  EXPORT_SYMBOL_GPL(ieee80211_update_mu_groups);
  
  void ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
++<<<<<<< HEAD
 +				 struct sta_info *sta, u8 opmode,
 +				 enum nl80211_band band)
++=======
+ 				 struct link_sta_info *link_sta,
+ 				 u8 opmode, enum nl80211_band band)
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  {
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_supported_band *sband = local->hw.wiphy->bands[band];
  
++<<<<<<< HEAD
 +	u32 changed = __ieee80211_vht_handle_opmode(sdata, sta, opmode, band);
 +
 +	if (changed > 0) {
 +		ieee80211_recalc_min_chandef(sdata);
 +		rate_control_rate_update(local, sband, sta, changed);
++=======
+ 	u32 changed = __ieee80211_vht_handle_opmode(sdata, link_sta,
+ 						    opmode, band);
+ 
+ 	if (changed > 0) {
+ 		ieee80211_recalc_min_chandef(sdata);
+ 		rate_control_rate_update(local, sband, link_sta->sta,
+ 					 link_sta->link_id, changed);
++>>>>>>> c71420db653a (wifi: mac80211: RCU-ify link STA pointers)
  	}
  }
  
* Unmerged path include/net/mac80211.h
* Unmerged path net/mac80211/cfg.c
* Unmerged path net/mac80211/chan.c
* Unmerged path net/mac80211/eht.c
* Unmerged path net/mac80211/he.c
* Unmerged path net/mac80211/ht.c
* Unmerged path net/mac80211/ibss.c
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/iface.c
* Unmerged path net/mac80211/mesh_plink.c
* Unmerged path net/mac80211/mlme.c
* Unmerged path net/mac80211/rate.c
* Unmerged path net/mac80211/rx.c
* Unmerged path net/mac80211/sta_info.c
* Unmerged path net/mac80211/sta_info.h
* Unmerged path net/mac80211/tdls.c
* Unmerged path net/mac80211/vht.c
