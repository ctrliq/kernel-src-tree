ASoC: SOF: loader: Remove snd_sof_parse_module_memcpy() as it is not used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit 910bd536d3f72d9c39e5ec08e946c11f9bcdc532
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/910bd536.failed

The snd_sof_parse_module_memcpy() is no longer used and we have the
implementation of it in ipc3-loader.c which is a default mode to load
module(s) with IPC3 if the snd_sof_load_firmware_memcpy() is used for
loading the firmware.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Link: https://lore.kernel.org/r/20220425221129.124615-10-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 910bd536d3f72d9c39e5ec08e946c11f9bcdc532)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/loader.c
diff --cc sound/soc/sof/loader.c
index b0d192749734,8672dcc9cc1e..000000000000
--- a/sound/soc/sof/loader.c
+++ b/sound/soc/sof/loader.c
@@@ -14,460 -14,6 +14,461 @@@
  #include "sof-priv.h"
  #include "ops.h"
  
++<<<<<<< HEAD
 +static int get_ext_windows(struct snd_sof_dev *sdev,
 +			   const struct sof_ipc_ext_data_hdr *ext_hdr)
 +{
 +	const struct sof_ipc_window *w =
 +		container_of(ext_hdr, struct sof_ipc_window, ext_hdr);
 +
 +	if (w->num_windows == 0 || w->num_windows > SOF_IPC_MAX_ELEMS)
 +		return -EINVAL;
 +
 +	if (sdev->info_window) {
 +		if (memcmp(sdev->info_window, w, ext_hdr->hdr.size)) {
 +			dev_err(sdev->dev, "error: mismatch between window descriptor from extended manifest and mailbox");
 +			return -EINVAL;
 +		}
 +		return 0;
 +	}
 +
 +	/* keep a local copy of the data */
 +	sdev->info_window = devm_kmemdup(sdev->dev, w, ext_hdr->hdr.size,
 +					 GFP_KERNEL);
 +	if (!sdev->info_window)
 +		return -ENOMEM;
 +
 +	return 0;
 +}
 +
 +static int get_cc_info(struct snd_sof_dev *sdev,
 +		       const struct sof_ipc_ext_data_hdr *ext_hdr)
 +{
 +	int ret;
 +
 +	const struct sof_ipc_cc_version *cc =
 +		container_of(ext_hdr, struct sof_ipc_cc_version, ext_hdr);
 +
 +	if (sdev->cc_version) {
 +		if (memcmp(sdev->cc_version, cc, cc->ext_hdr.hdr.size)) {
 +			dev_err(sdev->dev, "error: receive diverged cc_version descriptions");
 +			return -EINVAL;
 +		}
 +		return 0;
 +	}
 +
 +	dev_dbg(sdev->dev, "Firmware info: used compiler %s %d:%d:%d%s used optimization flags %s\n",
 +		cc->name, cc->major, cc->minor, cc->micro, cc->desc,
 +		cc->optim);
 +
 +	/* create read-only cc_version debugfs to store compiler version info */
 +	/* use local copy of the cc_version to prevent data corruption */
 +	if (sdev->first_boot) {
 +		sdev->cc_version = devm_kmalloc(sdev->dev, cc->ext_hdr.hdr.size,
 +						GFP_KERNEL);
 +
 +		if (!sdev->cc_version)
 +			return -ENOMEM;
 +
 +		memcpy(sdev->cc_version, cc, cc->ext_hdr.hdr.size);
 +		ret = snd_sof_debugfs_buf_item(sdev, sdev->cc_version,
 +					       cc->ext_hdr.hdr.size,
 +					       "cc_version", 0444);
 +
 +		/* errors are only due to memory allocation, not debugfs */
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "error: snd_sof_debugfs_buf_item failed\n");
 +			return ret;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int ext_man_get_fw_version(struct snd_sof_dev *sdev,
 +				  const struct sof_ext_man_elem_header *hdr)
 +{
 +	const struct sof_ext_man_fw_version *v =
 +		container_of(hdr, struct sof_ext_man_fw_version, hdr);
 +
 +	memcpy(&sdev->fw_ready.version, &v->version, sizeof(v->version));
 +	sdev->fw_ready.flags = v->flags;
 +
 +	/* log ABI versions and check FW compatibility */
 +	return snd_sof_ipc_valid(sdev);
 +}
 +
 +static int ext_man_get_windows(struct snd_sof_dev *sdev,
 +			       const struct sof_ext_man_elem_header *hdr)
 +{
 +	const struct sof_ext_man_window *w;
 +
 +	w = container_of(hdr, struct sof_ext_man_window, hdr);
 +
 +	return get_ext_windows(sdev, &w->ipc_window.ext_hdr);
 +}
 +
 +static int ext_man_get_cc_info(struct snd_sof_dev *sdev,
 +			       const struct sof_ext_man_elem_header *hdr)
 +{
 +	const struct sof_ext_man_cc_version *cc;
 +
 +	cc = container_of(hdr, struct sof_ext_man_cc_version, hdr);
 +
 +	return get_cc_info(sdev, &cc->cc_version.ext_hdr);
 +}
 +
 +static int ext_man_get_dbg_abi_info(struct snd_sof_dev *sdev,
 +				    const struct sof_ext_man_elem_header *hdr)
 +{
 +	const struct ext_man_dbg_abi *dbg_abi =
 +		container_of(hdr, struct ext_man_dbg_abi, hdr);
 +
 +	if (sdev->first_boot)
 +		dev_dbg(sdev->dev,
 +			"Firmware: DBG_ABI %d:%d:%d\n",
 +			SOF_ABI_VERSION_MAJOR(dbg_abi->dbg_abi.abi_dbg_version),
 +			SOF_ABI_VERSION_MINOR(dbg_abi->dbg_abi.abi_dbg_version),
 +			SOF_ABI_VERSION_PATCH(dbg_abi->dbg_abi.abi_dbg_version));
 +
 +	return 0;
 +}
 +
 +static int ext_man_get_config_data(struct snd_sof_dev *sdev,
 +				   const struct sof_ext_man_elem_header *hdr)
 +{
 +	const struct sof_ext_man_config_data *config =
 +		container_of(hdr, struct sof_ext_man_config_data, hdr);
 +	const struct sof_config_elem *elem;
 +	int elems_counter;
 +	int elems_size;
 +	int ret = 0;
 +	int i;
 +
 +	/* calculate elements counter */
 +	elems_size = config->hdr.size - sizeof(struct sof_ext_man_elem_header);
 +	elems_counter = elems_size / sizeof(struct sof_config_elem);
 +
 +	dev_dbg(sdev->dev, "%s can hold up to %d config elements\n",
 +		__func__, elems_counter);
 +
 +	for (i = 0; i < elems_counter; ++i) {
 +		elem = &config->elems[i];
 +		dev_dbg(sdev->dev, "%s get index %d token %d val %d\n",
 +			__func__, i, elem->token, elem->value);
 +		switch (elem->token) {
 +		case SOF_EXT_MAN_CONFIG_EMPTY:
 +			/* unused memory space is zero filled - mapped to EMPTY elements */
 +			break;
 +		case SOF_EXT_MAN_CONFIG_IPC_MSG_SIZE:
 +			/* TODO: use ipc msg size from config data */
 +			break;
 +		case SOF_EXT_MAN_CONFIG_MEMORY_USAGE_SCAN:
 +			if (sdev->first_boot && elem->value)
 +				ret = snd_sof_dbg_memory_info_init(sdev);
 +			break;
 +		default:
 +			dev_info(sdev->dev, "Unknown firmware configuration token %d value %d",
 +				 elem->token, elem->value);
 +			break;
 +		}
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "error: processing sof_ext_man_config_data failed for token %d value 0x%x, %d\n",
 +				elem->token, elem->value, ret);
 +			return ret;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static ssize_t snd_sof_ext_man_size(const struct firmware *fw)
 +{
 +	const struct sof_ext_man_header *head;
 +
 +	head = (struct sof_ext_man_header *)fw->data;
 +
 +	/*
 +	 * assert fw size is big enough to contain extended manifest header,
 +	 * it prevents from reading unallocated memory from `head` in following
 +	 * step.
 +	 */
 +	if (fw->size < sizeof(*head))
 +		return -EINVAL;
 +
 +	/*
 +	 * When fw points to extended manifest,
 +	 * then first u32 must be equal SOF_EXT_MAN_MAGIC_NUMBER.
 +	 */
 +	if (head->magic == SOF_EXT_MAN_MAGIC_NUMBER)
 +		return head->full_size;
 +
 +	/* otherwise given fw don't have an extended manifest */
 +	return 0;
 +}
 +
 +/* parse extended FW manifest data structures */
 +static int snd_sof_fw_ext_man_parse(struct snd_sof_dev *sdev,
 +				    const struct firmware *fw)
 +{
 +	const struct sof_ext_man_elem_header *elem_hdr;
 +	const struct sof_ext_man_header *head;
 +	ssize_t ext_man_size;
 +	ssize_t remaining;
 +	uintptr_t iptr;
 +	int ret = 0;
 +
 +	head = (struct sof_ext_man_header *)fw->data;
 +	remaining = head->full_size - head->header_size;
 +	ext_man_size = snd_sof_ext_man_size(fw);
 +
 +	/* Assert firmware starts with extended manifest */
 +	if (ext_man_size <= 0)
 +		return ext_man_size;
 +
 +	/* incompatible version */
 +	if (SOF_EXT_MAN_VERSION_INCOMPATIBLE(SOF_EXT_MAN_VERSION,
 +					     head->header_version)) {
 +		dev_err(sdev->dev, "error: extended manifest version 0x%X differ from used 0x%X\n",
 +			head->header_version, SOF_EXT_MAN_VERSION);
 +		return -EINVAL;
 +	}
 +
 +	/* get first extended manifest element header */
 +	iptr = (uintptr_t)fw->data + head->header_size;
 +
 +	while (remaining > sizeof(*elem_hdr)) {
 +		elem_hdr = (struct sof_ext_man_elem_header *)iptr;
 +
 +		dev_dbg(sdev->dev, "found sof_ext_man header type %d size 0x%X\n",
 +			elem_hdr->type, elem_hdr->size);
 +
 +		if (elem_hdr->size < sizeof(*elem_hdr) ||
 +		    elem_hdr->size > remaining) {
 +			dev_err(sdev->dev, "error: invalid sof_ext_man header size, type %d size 0x%X\n",
 +				elem_hdr->type, elem_hdr->size);
 +			return -EINVAL;
 +		}
 +
 +		/* process structure data */
 +		switch (elem_hdr->type) {
 +		case SOF_EXT_MAN_ELEM_FW_VERSION:
 +			ret = ext_man_get_fw_version(sdev, elem_hdr);
 +			break;
 +		case SOF_EXT_MAN_ELEM_WINDOW:
 +			ret = ext_man_get_windows(sdev, elem_hdr);
 +			break;
 +		case SOF_EXT_MAN_ELEM_CC_VERSION:
 +			ret = ext_man_get_cc_info(sdev, elem_hdr);
 +			break;
 +		case SOF_EXT_MAN_ELEM_DBG_ABI:
 +			ret = ext_man_get_dbg_abi_info(sdev, elem_hdr);
 +			break;
 +		case SOF_EXT_MAN_ELEM_CONFIG_DATA:
 +			ret = ext_man_get_config_data(sdev, elem_hdr);
 +			break;
 +		case SOF_EXT_MAN_ELEM_PLATFORM_CONFIG_DATA:
 +			ret = snd_sof_dsp_parse_platform_ext_manifest(sdev, elem_hdr);
 +			break;
 +		default:
 +			dev_info(sdev->dev, "unknown sof_ext_man header type %d size 0x%X\n",
 +				 elem_hdr->type, elem_hdr->size);
 +			break;
 +		}
 +
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "error: failed to parse sof_ext_man header type %d size 0x%X\n",
 +				elem_hdr->type, elem_hdr->size);
 +			return ret;
 +		}
 +
 +		remaining -= elem_hdr->size;
 +		iptr += elem_hdr->size;
 +	}
 +
 +	if (remaining) {
 +		dev_err(sdev->dev, "error: sof_ext_man header is inconsistent\n");
 +		return -EINVAL;
 +	}
 +
 +	return ext_man_size;
 +}
 +
 +/* generic module parser for mmaped DSPs */
 +int snd_sof_parse_module_memcpy(struct snd_sof_dev *sdev,
 +				struct snd_sof_mod_hdr *module)
 +{
 +	struct snd_sof_blk_hdr *block;
 +	int count, ret;
 +	u32 offset;
 +	size_t remaining;
 +
 +	dev_dbg(sdev->dev, "new module size 0x%x blocks 0x%x type 0x%x\n",
 +		module->size, module->num_blocks, module->type);
 +
 +	block = (struct snd_sof_blk_hdr *)((u8 *)module + sizeof(*module));
 +
 +	/* module->size doesn't include header size */
 +	remaining = module->size;
 +	for (count = 0; count < module->num_blocks; count++) {
 +		/* check for wrap */
 +		if (remaining < sizeof(*block)) {
 +			dev_err(sdev->dev, "error: not enough data remaining\n");
 +			return -EINVAL;
 +		}
 +
 +		/* minus header size of block */
 +		remaining -= sizeof(*block);
 +
 +		if (block->size == 0) {
 +			dev_warn(sdev->dev,
 +				 "warning: block %d size zero\n", count);
 +			dev_warn(sdev->dev, " type 0x%x offset 0x%x\n",
 +				 block->type, block->offset);
 +			continue;
 +		}
 +
 +		switch (block->type) {
 +		case SOF_FW_BLK_TYPE_RSRVD0:
 +		case SOF_FW_BLK_TYPE_ROM...SOF_FW_BLK_TYPE_RSRVD14:
 +			continue;	/* not handled atm */
 +		case SOF_FW_BLK_TYPE_IRAM:
 +		case SOF_FW_BLK_TYPE_DRAM:
 +		case SOF_FW_BLK_TYPE_SRAM:
 +			offset = block->offset;
 +			break;
 +		default:
 +			dev_err(sdev->dev, "error: bad type 0x%x for block 0x%x\n",
 +				block->type, count);
 +			return -EINVAL;
 +		}
 +
 +		dev_dbg(sdev->dev,
 +			"block %d type 0x%x size 0x%x ==>  offset 0x%x\n",
 +			count, block->type, block->size, offset);
 +
 +		/* checking block->size to avoid unaligned access */
 +		if (block->size % sizeof(u32)) {
 +			dev_err(sdev->dev, "error: invalid block size 0x%x\n",
 +				block->size);
 +			return -EINVAL;
 +		}
 +		ret = snd_sof_dsp_block_write(sdev, block->type, offset,
 +					      block + 1, block->size);
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "error: write to block type 0x%x failed\n",
 +				block->type);
 +			return ret;
 +		}
 +
 +		if (remaining < block->size) {
 +			dev_err(sdev->dev, "error: not enough data remaining\n");
 +			return -EINVAL;
 +		}
 +
 +		/* minus body size of block */
 +		remaining -= block->size;
 +		/* next block */
 +		block = (struct snd_sof_blk_hdr *)((u8 *)block + sizeof(*block)
 +			+ block->size);
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL(snd_sof_parse_module_memcpy);
 +
 +static int check_header(struct snd_sof_dev *sdev, const struct firmware *fw,
 +			size_t fw_offset)
 +{
 +	struct snd_sof_fw_header *header;
 +	size_t fw_size = fw->size - fw_offset;
 +
 +	if (fw->size <= fw_offset) {
 +		dev_err(sdev->dev, "error: firmware size must be greater than firmware offset\n");
 +		return -EINVAL;
 +	}
 +
 +	/* Read the header information from the data pointer */
 +	header = (struct snd_sof_fw_header *)(fw->data + fw_offset);
 +
 +	/* verify FW sig */
 +	if (strncmp(header->sig, SND_SOF_FW_SIG, SND_SOF_FW_SIG_SIZE) != 0) {
 +		dev_err(sdev->dev, "error: invalid firmware signature\n");
 +		return -EINVAL;
 +	}
 +
 +	/* check size is valid */
 +	if (fw_size != header->file_size + sizeof(*header)) {
 +		dev_err(sdev->dev, "error: invalid filesize mismatch got 0x%zx expected 0x%zx\n",
 +			fw_size, header->file_size + sizeof(*header));
 +		return -EINVAL;
 +	}
 +
 +	dev_dbg(sdev->dev, "header size=0x%x modules=0x%x abi=0x%x size=%zu\n",
 +		header->file_size, header->num_modules,
 +		header->abi, sizeof(*header));
 +
 +	return 0;
 +}
 +
 +static int load_modules(struct snd_sof_dev *sdev, const struct firmware *fw,
 +			size_t fw_offset)
 +{
 +	struct snd_sof_fw_header *header;
 +	struct snd_sof_mod_hdr *module;
 +	int (*load_module)(struct snd_sof_dev *sof_dev,
 +			   struct snd_sof_mod_hdr *hdr);
 +	int ret, count;
 +	size_t remaining;
 +
 +	header = (struct snd_sof_fw_header *)(fw->data + fw_offset);
 +	load_module = sof_ops(sdev)->load_module;
 +	if (!load_module)
 +		return -EINVAL;
 +
 +	/* parse each module */
 +	module = (struct snd_sof_mod_hdr *)(fw->data + fw_offset +
 +					    sizeof(*header));
 +	remaining = fw->size - sizeof(*header) - fw_offset;
 +	/* check for wrap */
 +	if (remaining > fw->size) {
 +		dev_err(sdev->dev, "error: fw size smaller than header size\n");
 +		return -EINVAL;
 +	}
 +
 +	for (count = 0; count < header->num_modules; count++) {
 +		/* check for wrap */
 +		if (remaining < sizeof(*module)) {
 +			dev_err(sdev->dev, "error: not enough data remaining\n");
 +			return -EINVAL;
 +		}
 +
 +		/* minus header size of module */
 +		remaining -= sizeof(*module);
 +
 +		/* module */
 +		ret = load_module(sdev, module);
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "error: invalid module %d\n", count);
 +			return ret;
 +		}
 +
 +		if (remaining < module->size) {
 +			dev_err(sdev->dev, "error: not enough data remaining\n");
 +			return -EINVAL;
 +		}
 +
 +		/* minus body size of module */
 +		remaining -=  module->size;
 +		module = (struct snd_sof_mod_hdr *)((u8 *)module
 +			+ sizeof(*module) + module->size);
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 910bd536d3f7 (ASoC: SOF: loader: Remove snd_sof_parse_module_memcpy() as it is not used)
  int snd_sof_load_firmware_raw(struct snd_sof_dev *sdev)
  {
  	struct snd_sof_pdata *plat_data = sdev->pdata;
* Unmerged path sound/soc/sof/loader.c
diff --git a/sound/soc/sof/sof-priv.h b/sound/soc/sof/sof-priv.h
index 538862b12104..2e5e3a3bde18 100644
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@ -549,8 +549,6 @@ extern struct snd_compress_ops sof_compressed_ops;
 int snd_sof_load_firmware_raw(struct snd_sof_dev *sdev);
 int snd_sof_load_firmware_memcpy(struct snd_sof_dev *sdev);
 int snd_sof_run_firmware(struct snd_sof_dev *sdev);
-int snd_sof_parse_module_memcpy(struct snd_sof_dev *sdev,
-				struct snd_sof_mod_hdr *module);
 void snd_sof_fw_unload(struct snd_sof_dev *sdev);
 
 /*
