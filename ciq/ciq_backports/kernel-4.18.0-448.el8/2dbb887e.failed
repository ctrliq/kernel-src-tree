x86/entry: Add kernel IBRS implementation

jira LE-1907
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23825
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 2dbb887e875b1de3ca8f40ddf26bcfe55798c609
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2dbb887e.failed

Implement Kernel IBRS - currently the only known option to mitigate RSB
underflow speculation issues on Skylake hardware.

Note: since IBRS_ENTER requires fuller context established than
UNTRAIN_RET, it must be placed after it. However, since UNTRAIN_RET
itself implies a RET, it must come after IBRS_ENTER. This means
IBRS_ENTER needs to also move UNTRAIN_RET.

Note 2: KERNEL_IBRS is sub-optimal for XenPV.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 2dbb887e875b1de3ca8f40ddf26bcfe55798c609)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/calling.h
#	arch/x86/entry/entry_64.S
#	arch/x86/entry/entry_64_compat.S
diff --cc arch/x86/entry/calling.h
index 6d27bb2e8649,074d04e434de..000000000000
--- a/arch/x86/entry/calling.h
+++ b/arch/x86/entry/calling.h
@@@ -6,6 -6,9 +6,12 @@@
  #include <asm/percpu.h>
  #include <asm/asm-offsets.h>
  #include <asm/processor-flags.h>
++<<<<<<< HEAD
++=======
+ #include <asm/ptrace-abi.h>
+ #include <asm/msr.h>
+ #include <asm/nospec-branch.h>
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  /*
  
diff --cc arch/x86/entry/entry_64.S
index cd89e5040553,f4384a29086f..000000000000
--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@@ -121,6 -95,7 +121,10 @@@ SYM_CODE_START(entry_SYSCALL_64
  	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
  
  SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)
++<<<<<<< HEAD
++=======
+ 	ANNOTATE_NOENDBR
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  	/* Construct struct pt_regs on stack */
  	pushq	$__USER_DS				/* pt_regs->ss */
@@@ -131,18 -106,19 +135,29 @@@
  SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)
  	pushq	%rax					/* pt_regs->orig_ax */
  
 +	IBRS_ENTRY
  	PUSH_AND_CLEAR_REGS rax=$-ENOSYS
  
 +	TRACE_IRQS_OFF
 +
  	/* IRQs are off. */
++<<<<<<< HEAD
 +	movq	%rax, %rdi
 +	movq	%rsp, %rsi
++=======
+ 	movq	%rsp, %rdi
+ 	/* Sign extend the lower 32bit as syscall numbers are treated as int */
+ 	movslq	%eax, %rsi
+ 
+ 	/* clobbers %rax, make sure it is after saving the syscall nr */
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
+ 
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  	call	do_syscall_64		/* returns with IRQs disabled */
  
 +	TRACE_IRQS_IRETQ		/* we're about to change IF */
 +
  	/*
  	 * Try to use SYSRET instead of IRET if we're returning to
  	 * a completely clean 64-bit userspace context.  If we're not,
@@@ -215,9 -196,8 +230,14 @@@
  	 * perf profiles. Nothing jumps here.
  	 */
  syscall_return_via_sysret:
++<<<<<<< HEAD
 +	/* rcx and r11 are already restored (see code above) */
 +	IBRS_EXIT
 +	POP_REGS pop_rdi=0 skip_r11rcx=1
++=======
+ 	IBRS_EXIT
+ 	POP_REGS pop_rdi=0
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  	/*
  	 * Now all regs are restored except RSP and RDI.
@@@ -625,45 -562,55 +645,46 @@@ SYM_CODE_END(\asmsym
  .endm
  #endif
  
 -/*
 - * Double fault entry. Straight paranoid. No checks from which context
 - * this comes because for the espfix induced #DF this would do the wrong
 - * thing.
 - */
 -.macro idtentry_df vector asmsym cfunc
 -SYM_CODE_START(\asmsym)
 -	UNWIND_HINT_IRET_REGS offset=8
 -	ENDBR
 -	ASM_CLAC
 -	cld
 -
 -	/* paranoid_entry returns GS information for paranoid_exit in EBX. */
 -	call	paranoid_entry
 -	UNWIND_HINT_REGS
 -
 -	movq	%rsp, %rdi		/* pt_regs pointer into first argument */
 -	movq	ORIG_RAX(%rsp), %rsi	/* get error code into 2nd argument*/
 -	movq	$-1, ORIG_RAX(%rsp)	/* no syscall to restart */
 -	call	\cfunc
 -
 -	/* For some configurations \cfunc ends up being a noreturn. */
 -	REACHABLE
 -
 -	jmp	paranoid_exit
 -
 -_ASM_NOKPROBE(\asmsym)
 -SYM_CODE_END(\asmsym)
 -.endm
 +/* Interrupt entry/exit. */
  
  /*
 - * Include the defines which emit the idt entries which are shared
 - * shared between 32 and 64 bit and emit the __irqentry_text_* markers
 - * so the stacktrace boundary checks work.
 + * The interrupt stubs push (~vector+0x80) onto the stack and
 + * then jump to common_spurious/interrupt.
   */
 -	.align 16
 -	.globl __irqentry_text_start
 -__irqentry_text_start:
 +common_spurious:
 +	addq	$-0x80, (%rsp)			/* Adjust vector to [-256, -1] range */
 +	call	interrupt_entry
 +	UNWIND_HINT_REGS indirect=1
 +	call	smp_spurious_interrupt		/* rdi points to pt_regs */
 +	jmp	ret_from_intr
 +END(common_spurious)
 +_ASM_NOKPROBE(common_spurious)
 +
 +/* common_interrupt is a hotpath. Align it */
 +	.p2align CONFIG_X86_L1_CACHE_SHIFT
 +common_interrupt:
 +	addq	$-0x80, (%rsp)			/* Adjust vector to [-256, -1] range */
 +	call	interrupt_entry
 +	UNWIND_HINT_REGS indirect=1
 +	call	do_IRQ	/* rdi points to pt_regs */
 +	/* 0(%rsp): old RSP */
 +ret_from_intr:
 +	DISABLE_INTERRUPTS(CLBR_ANY)
 +	TRACE_IRQS_OFF
 +
 +	LEAVE_IRQ_STACK
  
 -#include <asm/idtentry.h>
 +	testb	$3, CS(%rsp)
 +	jz	retint_kernel
  
 -	.align 16
 -	.globl __irqentry_text_end
 -__irqentry_text_end:
 -	ANNOTATE_NOENDBR
 +	/* Interrupt came from user space */
 +GLOBAL(retint_user)
 +	mov	%rsp,%rdi
 +	call	prepare_exit_to_usermode
 +	TRACE_IRQS_IRETQ
  
 -SYM_CODE_START_LOCAL(common_interrupt_return)
  SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)
+ 	IBRS_EXIT
  #ifdef CONFIG_DEBUG_ENTRY
  	/* Assert that pt_regs indicates user mode. */
  	testb	$3, CS(%rsp)
@@@ -1236,10 -897,12 +1257,13 @@@ idtentry machine_check		do_mce			has_er
   *              1 -> no SWAPGS on exit
   *
   *     Y        GSBASE value at entry, must be restored in paranoid_exit
+  *
+  * R14 - old CR3
+  * R15 - old SPEC_CTRL
   */
 -SYM_CODE_START_LOCAL(paranoid_entry)
 +ENTRY(paranoid_entry)
  	UNWIND_HINT_FUNC
 +	cld
  	PUSH_AND_CLEAR_REGS save_ret=1
  	ENCODE_FRAME_POINTER 8
  
@@@ -1271,7 -943,7 +1295,11 @@@
  	 * is needed here.
  	 */
  	SAVE_AND_SET_GSBASE scratch_reg=%rax save_reg=%rbx
++<<<<<<< HEAD
 +	jmp	.Librs_entry
++=======
+ 	jmp .Lparanoid_gsbase_done
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  .Lparanoid_entry_checkgs:
  	/* EBX = 1 -> kernel GSBASE active, no restore required */
@@@ -1298,11 -960,20 +1326,28 @@@
  
  	/* EBX = 0 -> SWAPGS required on exit */
  	xorl	%ebx, %ebx
++<<<<<<< HEAD
 +
 +.Librs_entry:
 +	IBRS_ENTRY_SAVE_AND_CLOBBER  save_reg=%r13d
 +	ret
 +END(paranoid_entry)
++=======
+ 	swapgs
+ .Lparanoid_kernel_gsbase:
+ 	FENCE_SWAPGS_KERNEL_ENTRY
+ .Lparanoid_gsbase_done:
+ 
+ 	/*
+ 	 * Once we have CR3 and %GS setup save and set SPEC_CTRL. Just like
+ 	 * CR3 above, keep the old value in a callee saved register.
+ 	 */
+ 	IBRS_ENTER save_reg=%r15
+ 	UNTRAIN_RET
+ 
+ 	RET
+ SYM_CODE_END(paranoid_entry)
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  /*
   * "Paranoid" exit path from exception stack.  This is invoked
@@@ -1322,13 -993,19 +1367,26 @@@
   *              1 -> no SWAPGS on exit
   *
   *     Y        User space GSBASE, must be restored unconditionally
+  *
+  * R14 - old CR3
+  * R15 - old SPEC_CTRL
   */
 -SYM_CODE_START_LOCAL(paranoid_exit)
 +ENTRY(paranoid_exit)
  	UNWIND_HINT_REGS
++<<<<<<< HEAD
 +	DISABLE_INTERRUPTS(CLBR_ANY)
 +	TRACE_IRQS_OFF
 +	IBRS_EXIT_RESTORE_CLOBBER save_reg=%r13d
 +	TRACE_IRQS_IRETQ
++=======
+ 
+ 	/*
+ 	 * Must restore IBRS state before both CR3 and %GS since we need access
+ 	 * to the per-CPU x86_spec_ctrl_shadow variable.
+ 	 */
+ 	IBRS_EXIT save_reg=%r15
+ 
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  	/*
  	 * The order of operations is important. RESTORE_CR3 requires
  	 * kernel GSBASE.
@@@ -1375,31 -1049,15 +1433,37 @@@ ENTRY(error_entry
  	FENCE_SWAPGS_USER_ENTRY
  	/* We have user CR3.  Change to kernel CR3. */
  	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax
++<<<<<<< HEAD
 +	IBRS_ENTRY_CLOBBER
++=======
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
 -	leaq	8(%rsp), %rdi			/* arg0 = pt_regs pointer */
  .Lerror_entry_from_usermode_after_swapgs:
+ 
  	/* Put us onto the real thread stack. */
 +	popq	%r12				/* save return addr in %12 */
 +	movq	%rsp, %rdi			/* arg0 = pt_regs pointer */
  	call	sync_regs
 -	RET
 +	movq	%rax, %rsp			/* switch stack */
 +	ENCODE_FRAME_POINTER
 +	pushq	%r12
 +
 +	/*
 +	 * We need to tell lockdep that IRQs are off.  We can't do this until
 +	 * we fix gsbase, and we should do it before enter_from_user_mode
 +	 * (which can take locks).
 +	 */
 +	TRACE_IRQS_OFF
 +	CALL_enter_from_user_mode
 +	ret
 +
 +.Lerror_entry_done_lfence:
 +	FENCE_SWAPGS_KERNEL_ENTRY
 +.Lerror_entry_done:
 +	TRACE_IRQS_OFF
 +	ret
  
  	/*
  	 * There are two places in the kernel that can potentially fault with
@@@ -1438,10 -1101,11 +1502,15 @@@
  	 * We came from an IRET to user mode, so we have user
  	 * gsbase and CR3.  Switch to kernel gsbase and CR3:
  	 */
 -	swapgs
 +	SWAPGS
  	FENCE_SWAPGS_USER_ENTRY
  	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax
++<<<<<<< HEAD
 +	IBRS_ENTRY
++=======
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  	/*
  	 * Pretend that the exception came from user mode: set up pt_regs
@@@ -1545,9 -1209,11 +1614,12 @@@ SYM_CODE_START(nmi
  	UNWIND_HINT_IRET_REGS
  	pushq   $-1		/* pt_regs->orig_ax */
  	PUSH_AND_CLEAR_REGS rdx=(%rdx)
 +	IBRS_ENTRY_CLOBBER
  	ENCODE_FRAME_POINTER
  
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
+ 
  	/*
  	 * At this point we no longer need to worry about stack damage
  	 * due to nesting -- we're on the normal thread stack and we're
@@@ -1766,12 -1434,14 +1838,19 @@@ end_repeat_nmi
  	call	paranoid_entry
  	UNWIND_HINT_REGS
  
 +	/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */
  	movq	%rsp, %rdi
  	movq	$-1, %rsi
 -	call	exc_nmi
 +	call	do_nmi
  
++<<<<<<< HEAD
 +	IBRS_EXIT_RESTORE_CLOBBER save_reg=%r13d
++=======
+ 	/* Always restore stashed SPEC_CTRL value (see paranoid_entry) */
+ 	IBRS_EXIT save_reg=%r15
+ 
+ 	/* Always restore stashed CR3 value (see paranoid_entry) */
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  	RESTORE_CR3 scratch_reg=%r15 save_reg=%r14
  
  	/*
diff --cc arch/x86/entry/entry_64_compat.S
index 662090976770,bcb89d23ac0e..000000000000
--- a/arch/x86/entry/entry_64_compat.S
+++ b/arch/x86/entry/entry_64_compat.S
@@@ -56,7 -60,20 +57,24 @@@ SYM_FUNC_START(entry_SYSENTER_compat
  
  	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
  
++<<<<<<< HEAD
 +	IBRS_ENTRY
++=======
+ 	/* Construct struct pt_regs on stack */
+ 	pushq	$__USER32_DS		/* pt_regs->ss */
+ 	pushq	$0			/* pt_regs->sp = 0 (placeholder) */
+ 
+ 	/*
+ 	 * Push flags.  This is nasty.  First, interrupts are currently
+ 	 * off, but we need pt_regs->flags to have IF set.  Second, if TS
+ 	 * was set in usermode, it's still set, and we're singlestepping
+ 	 * through this code.  do_SYSENTER_32() will fix up IF.
+ 	 */
+ 	pushfq				/* pt_regs->flags (except IF = 0) */
+ 	pushq	$__USER32_CS		/* pt_regs->cs */
+ 	pushq	$0			/* pt_regs->ip = 0 (placeholder) */
+ SYM_INNER_LABEL(entry_SYSENTER_compat_after_hwframe, SYM_L_GLOBAL)
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  	/*
  	 * User tracing code (ptrace or signal handlers) might assume that
@@@ -67,48 -84,15 +85,51 @@@
  	 */
  	movl	%eax, %eax
  
 -	pushq	%rax			/* pt_regs->orig_ax */
 -	PUSH_AND_CLEAR_REGS rax=$-ENOSYS
 -	UNWIND_HINT_REGS
 +	/* Construct struct pt_regs on stack */
 +	pushq	$__USER32_DS		/* pt_regs->ss */
 +	pushq	%rbp			/* pt_regs->sp (stashed in bp) */
  
 +	/*
 +	 * Push flags.  This is nasty.  First, interrupts are currently
 +	 * off, but we need pt_regs->flags to have IF set.  Second, even
 +	 * if TF was set when SYSENTER started, it's clear by now.  We fix
 +	 * that later using TIF_SINGLESTEP.
 +	 */
 +	pushfq				/* pt_regs->flags (except IF = 0) */
 +	orl	$X86_EFLAGS_IF, (%rsp)	/* Fix saved flags */
 +	pushq	$__USER32_CS		/* pt_regs->cs */
 +	pushq	$0			/* pt_regs->ip = 0 (placeholder) */
 +	pushq	%rax			/* pt_regs->orig_ax */
 +	pushq	%rdi			/* pt_regs->di */
 +	pushq	%rsi			/* pt_regs->si */
 +	pushq	%rdx			/* pt_regs->dx */
 +	pushq	%rcx			/* pt_regs->cx */
 +	pushq	$-ENOSYS		/* pt_regs->ax */
 +	pushq   $0			/* pt_regs->r8  = 0 */
 +	xorl	%r8d, %r8d		/* nospec   r8 */
 +	pushq   $0			/* pt_regs->r9  = 0 */
 +	xorl	%r9d, %r9d		/* nospec   r9 */
 +	pushq   $0			/* pt_regs->r10 = 0 */
 +	xorl	%r10d, %r10d		/* nospec   r10 */
 +	pushq   $0			/* pt_regs->r11 = 0 */
 +	xorl	%r11d, %r11d		/* nospec   r11 */
 +	pushq   %rbx                    /* pt_regs->rbx */
 +	xorl	%ebx, %ebx		/* nospec   rbx */
 +	pushq   %rbp                    /* pt_regs->rbp (will be overwritten) */
 +	xorl	%ebp, %ebp		/* nospec   rbp */
 +	pushq   $0			/* pt_regs->r12 = 0 */
 +	xorl	%r12d, %r12d		/* nospec   r12 */
 +	pushq   $0			/* pt_regs->r13 = 0 */
 +	xorl	%r13d, %r13d		/* nospec   r13 */
 +	pushq   $0			/* pt_regs->r14 = 0 */
 +	xorl	%r14d, %r14d		/* nospec   r14 */
 +	pushq   $0			/* pt_regs->r15 = 0 */
 +	xorl	%r15d, %r15d		/* nospec   r15 */
  	cld
  
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
+ 
  	/*
  	 * SYSENTER doesn't filter flags, so we need to clear NT and AC
  	 * ourselves.  To save a few cycles, we can check whether
@@@ -212,9 -193,8 +233,13 @@@ SYM_CODE_START(entry_SYSCALL_compat
  	/* Switch to the kernel stack */
  	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
  
 +	IBRS_ENTRY
 +
  SYM_INNER_LABEL(entry_SYSCALL_compat_safe_stack, SYM_L_GLOBAL)
++<<<<<<< HEAD
++=======
+ 	ANNOTATE_NOENDBR
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  	/* Construct struct pt_regs on stack */
  	pushq	$__USER32_DS		/* pt_regs->ss */
@@@ -225,41 -205,12 +250,44 @@@
  SYM_INNER_LABEL(entry_SYSCALL_compat_after_hwframe, SYM_L_GLOBAL)
  	movl	%eax, %eax		/* discard orig_ax high bits */
  	pushq	%rax			/* pt_regs->orig_ax */
 -	PUSH_AND_CLEAR_REGS rcx=%rbp rax=$-ENOSYS
 -	UNWIND_HINT_REGS
 +	pushq	%rdi			/* pt_regs->di */
 +	pushq	%rsi			/* pt_regs->si */
 +	xorl	%esi, %esi		/* nospec   si */
 +	pushq	%rdx			/* pt_regs->dx */
 +	xorl	%edx, %edx		/* nospec   dx */
 +	pushq	%rbp			/* pt_regs->cx (stashed in bp) */
 +	xorl	%ecx, %ecx		/* nospec   cx */
 +	pushq	$-ENOSYS		/* pt_regs->ax */
 +	pushq   $0			/* pt_regs->r8  = 0 */
 +	xorl	%r8d, %r8d		/* nospec   r8 */
 +	pushq   $0			/* pt_regs->r9  = 0 */
 +	xorl	%r9d, %r9d		/* nospec   r9 */
 +	pushq   $0			/* pt_regs->r10 = 0 */
 +	xorl	%r10d, %r10d		/* nospec   r10 */
 +	pushq   $0			/* pt_regs->r11 = 0 */
 +	xorl	%r11d, %r11d		/* nospec   r11 */
 +	pushq   %rbx                    /* pt_regs->rbx */
 +	xorl	%ebx, %ebx		/* nospec   rbx */
 +	pushq   %rbp                    /* pt_regs->rbp (will be overwritten) */
 +	xorl	%ebp, %ebp		/* nospec   rbp */
 +	pushq   $0			/* pt_regs->r12 = 0 */
 +	xorl	%r12d, %r12d		/* nospec   r12 */
 +	pushq   $0			/* pt_regs->r13 = 0 */
 +	xorl	%r13d, %r13d		/* nospec   r13 */
 +	pushq   $0			/* pt_regs->r14 = 0 */
 +	xorl	%r14d, %r14d		/* nospec   r14 */
 +	pushq   $0			/* pt_regs->r15 = 0 */
 +	xorl	%r15d, %r15d		/* nospec   r15 */
 +
 +	/*
 +	 * User mode is traced as though IRQs are on, and SYSENTER
 +	 * turned them off.
 +	 */
 +	TRACE_IRQS_OFF
  
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
+ 
  	movq	%rsp, %rdi
  	call	do_fast_syscall_32
  	/* XEN PV guests always use IRET path */
@@@ -268,8 -219,14 +296,19 @@@
  
  	/* Opportunistic SYSRET */
  sysret32_from_system_call:
++<<<<<<< HEAD
 +	TRACE_IRQS_ON			/* User mode traces as IRQs on. */
 +	IBRS_EXIT_CLOBBER
++=======
+ 	/*
+ 	 * We are not going to return to userspace from the trampoline
+ 	 * stack. So let's erase the thread stack right now.
+ 	 */
+ 	STACKLEAK_ERASE
+ 
+ 	IBRS_EXIT
+ 
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  	movq	RBX(%rsp), %rbx		/* pt_regs->rbx */
  	movq	RBP(%rsp), %rbp		/* pt_regs->rbp */
  	movq	EFLAGS(%rsp), %r11	/* pt_regs->flags (in r11) */
@@@ -360,57 -324,31 +399,67 @@@ SYM_CODE_START(entry_INT80_compat
  
  	/* switch to thread stack expects orig_ax and rdi to be pushed */
  	pushq	%rax			/* pt_regs->orig_ax */
 +	pushq	%rdi			/* pt_regs->di */
  
  	/* Need to switch before accessing the thread stack. */
 -	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax
 -
 -	/* In the Xen PV case we already run on the thread stack. */
 -	ALTERNATIVE "", "jmp .Lint80_keep_stack", X86_FEATURE_XENPV
 -
 -	movq	%rsp, %rax
 +	SWITCH_TO_KERNEL_CR3 scratch_reg=%rdi
 +	movq	%rsp, %rdi
  	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
  
 -	pushq	5*8(%rax)		/* regs->ss */
 -	pushq	4*8(%rax)		/* regs->rsp */
 -	pushq	3*8(%rax)		/* regs->eflags */
 -	pushq	2*8(%rax)		/* regs->cs */
 -	pushq	1*8(%rax)		/* regs->ip */
 -	pushq	0*8(%rax)		/* regs->orig_ax */
 -.Lint80_keep_stack:
 +	IBRS_ENTRY
  
++<<<<<<< HEAD
 +	pushq	6*8(%rdi)		/* regs->ss */
 +	pushq	5*8(%rdi)		/* regs->rsp */
 +	pushq	4*8(%rdi)		/* regs->eflags */
 +	pushq	3*8(%rdi)		/* regs->cs */
 +	pushq	2*8(%rdi)		/* regs->ip */
 +	pushq	1*8(%rdi)		/* regs->orig_ax */
++=======
+ 	PUSH_AND_CLEAR_REGS rax=$-ENOSYS
+ 	UNWIND_HINT_REGS
 -
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
 +
 +	pushq	(%rdi)			/* pt_regs->di */
 +	pushq	%rsi			/* pt_regs->si */
 +	xorl	%esi, %esi		/* nospec   si */
 +	pushq	%rdx			/* pt_regs->dx */
 +	xorl	%edx, %edx		/* nospec   dx */
 +	pushq	%rcx			/* pt_regs->cx */
 +	xorl	%ecx, %ecx		/* nospec   cx */
 +	pushq	$-ENOSYS		/* pt_regs->ax */
 +	pushq   %r8			/* pt_regs->r8 */
 +	xorl	%r8d, %r8d		/* nospec   r8 */
 +	pushq   %r9			/* pt_regs->r9 */
 +	xorl	%r9d, %r9d		/* nospec   r9 */
 +	pushq   %r10			/* pt_regs->r10*/
 +	xorl	%r10d, %r10d		/* nospec   r10 */
 +	pushq   %r11			/* pt_regs->r11 */
 +	xorl	%r11d, %r11d		/* nospec   r11 */
 +	pushq   %rbx                    /* pt_regs->rbx */
 +	xorl	%ebx, %ebx		/* nospec   rbx */
 +	pushq   %rbp                    /* pt_regs->rbp */
 +	xorl	%ebp, %ebp		/* nospec   rbp */
 +	pushq   %r12                    /* pt_regs->r12 */
 +	xorl	%r12d, %r12d		/* nospec   r12 */
 +	pushq   %r13                    /* pt_regs->r13 */
 +	xorl	%r13d, %r13d		/* nospec   r13 */
 +	pushq   %r14                    /* pt_regs->r14 */
 +	xorl	%r14d, %r14d		/* nospec   r14 */
 +	pushq   %r15                    /* pt_regs->r15 */
 +	xorl	%r15d, %r15d		/* nospec   r15 */
  	cld
  
++<<<<<<< HEAD
 +	/*
 +	 * User mode is traced as though IRQs are on, and the interrupt
 +	 * gate turned them off.
 +	 */
 +	TRACE_IRQS_OFF
++=======
+ 	IBRS_ENTER
+ 	UNTRAIN_RET
++>>>>>>> 2dbb887e875b (x86/entry: Add kernel IBRS implementation)
  
  	movq	%rsp, %rdi
  	call	do_int80_syscall_32
* Unmerged path arch/x86/entry/calling.h
* Unmerged path arch/x86/entry/entry_64.S
* Unmerged path arch/x86/entry/entry_64_compat.S
diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h
index 05564117439b..2a0f85d3bad1 100644
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@ -202,7 +202,7 @@
 #define X86_FEATURE_PROC_FEEDBACK	( 7*32+ 9) /* AMD ProcFeedbackInterface */
 /* FREE!                                ( 7*32+10) */
 #define X86_FEATURE_PTI			( 7*32+11) /* Kernel Page Table Isolation enabled */
-/* FREE!				( 7*32+12) */
+#define X86_FEATURE_KERNEL_IBRS		( 7*32+12) /* "" Set/clear IBRS on kernel entry/exit */
 /* FREE!				( 7*32+13) */
 #define X86_FEATURE_INTEL_PPIN		( 7*32+14) /* Intel Processor Inventory Number */
 #define X86_FEATURE_CDP_L2		( 7*32+15) /* Code and Data Prioritization L2 */
