wifi: mac80211: move IEEE80211_SDATA_OPERATING_GMODE to link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 39eac2de0098c3ac3e9c35cfdc924543f1f67acc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/39eac2de.failed

The flag here is currently per interface, but the way we
set and clear it means it should be per link, so change
it.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 39eac2de0098c3ac3e9c35cfdc924543f1f67acc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ieee80211_i.h
#	net/mac80211/ocb.c
diff --cc net/mac80211/ieee80211_i.h
index fef9c92d74a2,baaff4c7a79c..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -903,6 -866,117 +901,120 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	ieee80211_conn_flags_t conn_flags;
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool tdls_chan_switch_prohibited;
+ 
+ 	bool have_beacon;
+ 	bool tracking_signal_avg;
+ 	bool disable_wmm_tracking;
+ 	bool operating_11g_mode;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 	struct timer_list chswitch_timer;
+ 	struct work_struct chswitch_work;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 
+ 	bool operating_11g_mode;
+ 
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ 
+ 	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
+ 
+ 	struct ieee80211_bss_conf *conf;
+ };
+ 
++>>>>>>> 39eac2de0098 (wifi: mac80211: move IEEE80211_SDATA_OPERATING_GMODE to link)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
diff --cc net/mac80211/ocb.c
index 1b28b4d92936,8664fee699e9..000000000000
--- a/net/mac80211/ocb.c
+++ b/net/mac80211/ocb.c
@@@ -181,13 -181,13 +181,19 @@@ int ieee80211_ocb_join(struct ieee80211
  	if (ifocb->joined == true)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	sdata->needed_rx_chains = sdata->local->rx_chains;
++=======
+ 	sdata->deflink.operating_11g_mode = true;
+ 	sdata->deflink.smps_mode = IEEE80211_SMPS_OFF;
+ 	sdata->deflink.needed_rx_chains = sdata->local->rx_chains;
++>>>>>>> 39eac2de0098 (wifi: mac80211: move IEEE80211_SDATA_OPERATING_GMODE to link)
  
  	mutex_lock(&sdata->local->mtx);
 -	err = ieee80211_link_use_channel(&sdata->deflink, &setup->chandef,
 -					 IEEE80211_CHANCTX_SHARED);
 +	err = ieee80211_vif_use_channel(sdata, &setup->chandef,
 +					IEEE80211_CHANCTX_SHARED);
  	mutex_unlock(&sdata->local->mtx);
  	if (err)
  		return err;
diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c
index 4765ade4ebf5..616b7d7a298e 100644
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@ -351,10 +351,8 @@ static void __ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
 	bss_change |= BSS_CHANGED_ERP_SLOT;
 
 	/* cf. IEEE 802.11 9.2.12 */
-	if (chan->band == NL80211_BAND_2GHZ && have_higher_than_11mbit)
-		sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
-	else
-		sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
+	sdata->deflink.operating_11g_mode =
+		chan->band == NL80211_BAND_2GHZ && have_higher_than_11mbit;
 
 	ieee80211_set_wmm_default(sdata, true, false);
 
* Unmerged path net/mac80211/ieee80211_i.h
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 446accddbebd..751b502db66f 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -5672,11 +5672,8 @@ static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 		sdata->vif.bss_conf.basic_rates = basic_rates;
 
 		/* cf. IEEE 802.11 9.2.12 */
-		if (cbss->channel->band == NL80211_BAND_2GHZ &&
-		    have_higher_than_11mbit)
-			sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
-		else
-			sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
+		link->operating_11g_mode = sband->band == NL80211_BAND_2GHZ &&
+					   have_higher_than_11mbit;
 
 skip_rates:
 		memcpy(ifmgd->bssid, cbss->bssid, ETH_ALEN);
* Unmerged path net/mac80211/ocb.c
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 245049905763..22c34b248c8d 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -149,7 +149,7 @@ static __le16 ieee80211_duration(struct ieee80211_tx_data *tx,
 		case NL80211_BAND_2GHZ:
 		case NL80211_BAND_LC: {
 			u32 flag;
-			if (tx->sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+			if (tx->sdata->deflink.operating_11g_mode)
 				flag = IEEE80211_RATE_MANDATORY_G;
 			else
 				flag = IEEE80211_RATE_MANDATORY_B;
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index a81a9800c4ed..093044379c90 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -191,7 +191,7 @@ __le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
 	if (vif) {
 		sdata = vif_to_sdata(vif);
 		short_preamble = sdata->vif.bss_conf.use_short_preamble;
-		if (sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+		if (sdata->deflink.operating_11g_mode)
 			erp = rate->flags & IEEE80211_RATE_ERP_G;
 		shift = ieee80211_vif_get_shift(vif);
 	}
@@ -225,7 +225,7 @@ __le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
 	if (vif) {
 		sdata = vif_to_sdata(vif);
 		short_preamble = sdata->vif.bss_conf.use_short_preamble;
-		if (sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+		if (sdata->deflink.operating_11g_mode)
 			erp = rate->flags & IEEE80211_RATE_ERP_G;
 		shift = ieee80211_vif_get_shift(vif);
 	}
@@ -268,7 +268,7 @@ __le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
 	if (vif) {
 		sdata = vif_to_sdata(vif);
 		short_preamble = sdata->vif.bss_conf.use_short_preamble;
-		if (sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+		if (sdata->deflink.operating_11g_mode)
 			erp = rate->flags & IEEE80211_RATE_ERP_G;
 		shift = ieee80211_vif_get_shift(vif);
 	}
@@ -1615,7 +1615,7 @@ void ieee80211_set_wmm_default(struct ieee80211_sub_if_data *sdata,
 	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 	use_11b = (chanctx_conf &&
 		   chanctx_conf->def.chan->band == NL80211_BAND_2GHZ) &&
-		 !(sdata->flags & IEEE80211_SDATA_OPERATING_GMODE);
+		 !link->operating_11g_mode;
 	rcu_read_unlock();
 
 	is_ocb = (sdata->vif.type == NL80211_IFTYPE_OCB);
