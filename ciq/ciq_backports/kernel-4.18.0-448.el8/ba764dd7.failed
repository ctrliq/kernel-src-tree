s390/pci: refactor zpci_create_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit ba764dd703feacb5a9c410d191af1b6cfbe96845
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ba764dd7.failed

Currently zpci_create_device() is only called in clp_add_pci_device()
which allocates the memory for the struct zpci_dev being created. There
is little separation of concerns as only both functions together can
create a zpci_dev and the only CLP specific code in
clp_add_pci_device() is a call to clp_query_pci_fn().

Improve this by removing clp_add_pci_device() and refactor
zpci_create_device() such that it alone creates and initializes the
zpci_dev given the FID and Function Handle. For this we need to make
clp_query_pci_fn() non-static. While at it remove the function handle
parameter since we can just take that from the zpci_dev. Also move
adding to the zpci_list to after the zdev has been fully created which
eliminates a window where a partially initialized zdev can be found by
get_zdev_by_fid().

	Acked-by: Pierre Morel <pmorel@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit ba764dd703feacb5a9c410d191af1b6cfbe96845)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci_clp.c
diff --cc arch/s390/include/asm/pci.h
index 4f768fcec21b,053fe8b8dec7..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -209,10 -210,9 +209,14 @@@ int zpci_unregister_ioat(struct zpci_de
  void zpci_remove_reserved_devices(void);
  
  /* CLP */
 -int clp_setup_writeback_mio(void);
  int clp_scan_pci_devices(void);
++<<<<<<< HEAD
 +int clp_rescan_pci_devices(void);
 +int clp_rescan_pci_devices_simple(u32 *fid);
 +int clp_add_pci_device(u32, u32, int);
++=======
+ int clp_query_pci_fn(struct zpci_dev *zdev);
++>>>>>>> ba764dd703fe (s390/pci: refactor zpci_create_device())
  int clp_enable_fh(struct zpci_dev *, u8);
  int clp_disable_fh(struct zpci_dev *);
  int clp_get_state(u32 fid, enum zpci_state *state);
diff --cc arch/s390/pci/pci_clp.c
index 1294ab5a9a22,d3331596ddbe..000000000000
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@@ -212,40 -212,7 +212,44 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +int clp_add_pci_device(u32 fid, u32 fh, int configured)
 +{
 +	struct zpci_dev *zdev;
 +	int rc = -ENOMEM;
 +
 +	zpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, configured);
 +	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
 +	if (!zdev)
 +		goto error;
 +
 +	zdev->fh = fh;
 +	zdev->fid = fid;
 +
 +	/* Query function properties and update zdev */
 +	rc = clp_query_pci_fn(zdev, fh);
 +	if (rc)
 +		goto error;
 +
 +	if (configured)
 +		zdev->state = ZPCI_FN_STATE_CONFIGURED;
 +	else
 +		zdev->state = ZPCI_FN_STATE_STANDBY;
 +
 +	rc = zpci_create_device(zdev);
 +	if (rc)
 +		goto error;
 +	return 0;
 +
 +error:
 +	zpci_dbg(0, "add fid:%x, rc:%d\n", fid, rc);
 +	kfree(zdev);
 +	return rc;
 +}
 +
++=======
+ static int clp_refresh_fh(u32 fid);
++>>>>>>> ba764dd703fe (s390/pci: refactor zpci_create_device())
  /*
   * Enable/Disable a given PCI function and update its function handle if
   * necessary
@@@ -374,27 -374,9 +378,27 @@@ static void __clp_add(struct clp_fh_lis
  
  	zdev = get_zdev_by_fid(entry->fid);
  	if (!zdev)
- 		clp_add_pci_device(entry->fid, entry->fh, entry->config_state);
+ 		zpci_create_device(entry->fid, entry->fh, entry->config_state);
  }
  
 +static void __clp_update(struct clp_fh_list_entry *entry, void *data)
 +{
 +	struct zpci_dev *zdev;
 +	u32 *fid = data;
 +
 +	if (!entry->vendor_id)
 +		return;
 +
 +	if (fid && *fid != entry->fid)
 +		return;
 +
 +	zdev = get_zdev_by_fid(entry->fid);
 +	if (!zdev)
 +		return;
 +
 +	zdev->fh = entry->fh;
 +}
 +
  int clp_scan_pci_devices(void)
  {
  	struct clp_req_rsp_list_pci *rrb;
* Unmerged path arch/s390/include/asm/pci.h
diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c
index d206caf84217..7cbb856d57e2 100644
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -736,43 +736,68 @@ void zpci_remove_device(struct zpci_dev *zdev)
 	}
 }
 
-int zpci_create_device(struct zpci_dev *zdev)
+/**
+ * zpci_create_device() - Create a new zpci_dev and add it to the zbus
+ * @fid: Function ID of the device to be created
+ * @fh: Current Function Handle of the device to be created
+ * @state: Initial state after creation either Standby or Configured
+ *
+ * Creates a new zpci device and adds it to its, possibly newly created, zbus
+ * as well as zpci_list.
+ *
+ * Returns: 0 on success, an error value otherwise
+ */
+int zpci_create_device(u32 fid, u32 fh, enum zpci_state state)
 {
+	struct zpci_dev *zdev;
 	int rc;
 
-	kref_init(&zdev->kref);
+	zpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, state);
+	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
+	if (!zdev)
+		return -ENOMEM;
 
-	spin_lock(&zpci_list_lock);
-	list_add_tail(&zdev->entry, &zpci_list);
-	spin_unlock(&zpci_list_lock);
+	/* FID and Function Handle are the static/dynamic identifiers */
+	zdev->fid = fid;
+	zdev->fh = fh;
 
-	rc = zpci_init_iommu(zdev);
+	/* Query function properties and update zdev */
+	rc = clp_query_pci_fn(zdev);
 	if (rc)
-		goto out;
+		goto error;
+	zdev->state =  state;
 
+	kref_init(&zdev->kref);
 	mutex_init(&zdev->lock);
+
+	rc = zpci_init_iommu(zdev);
+	if (rc)
+		goto error;
+
 	if (zdev->state == ZPCI_FN_STATE_CONFIGURED) {
 		rc = zpci_enable_device(zdev);
 		if (rc)
-			goto out_destroy_iommu;
+			goto error_destroy_iommu;
 	}
 
 	rc = zpci_bus_device_register(zdev, &pci_root_ops);
 	if (rc)
-		goto out_disable;
+		goto error_disable;
+
+	spin_lock(&zpci_list_lock);
+	list_add_tail(&zdev->entry, &zpci_list);
+	spin_unlock(&zpci_list_lock);
 
 	return 0;
 
-out_disable:
+error_disable:
 	if (zdev->state == ZPCI_FN_STATE_ONLINE)
 		zpci_disable_device(zdev);
-
-out_destroy_iommu:
+error_destroy_iommu:
 	zpci_destroy_iommu(zdev);
-out:
-	spin_lock(&zpci_list_lock);
-	list_del(&zdev->entry);
-	spin_unlock(&zpci_list_lock);
+error:
+	zpci_dbg(0, "add fid:%x, rc:%d\n", fid, rc);
+	kfree(zdev);
 	return rc;
 }
 
* Unmerged path arch/s390/pci/pci_clp.c
diff --git a/arch/s390/pci/pci_event.c b/arch/s390/pci/pci_event.c
index b32a8575da86..865e712d54fc 100644
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -89,7 +89,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 	switch (ccdf->pec) {
 	case 0x0301: /* Reserved|Standby -> Configured */
 		if (!zdev) {
-			ret = clp_add_pci_device(ccdf->fid, ccdf->fh, 1);
+			zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_CONFIGURED);
 			break;
 		}
 		/* the configuration request may be stale */
@@ -116,7 +116,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 		break;
 	case 0x0302: /* Reserved -> Standby */
 		if (!zdev) {
-			clp_add_pci_device(ccdf->fid, ccdf->fh, 0);
+			zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_STANDBY);
 			break;
 		}
 		zdev->fh = ccdf->fh;
