drm/i915/gt: Serialize GRDOM access between multiple engine resets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Chris Wilson <chris@chris-wilson.co.uk>
commit 336561a914fc0c6f1218228718f633b31b7af1c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/336561a9.failed

Don't allow two engines to be reset in parallel, as they would both
try to select a reset bit (and send requests to common registers)
and wait on that register, at the same time. Serialize control of
the reset requests/acks using the uncore->lock, which will also ensure
that no other GT state changes at the same time as the actual reset.

	Cc: stable@vger.kernel.org # v4.4 and upper
	Reported-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
	Acked-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
	Reviewed-by: Andi Shyti <andi.shyti@intel.com>
	Reviewed-by: Andrzej Hajda <andrzej.hajda@intel.com>
	Acked-by: Thomas Hellstr√∂m <thomas.hellstrom@linux.intel.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/e0a2d894e77aed7c2e36b0d1abdc7dbac3011729.1657639152.git.mchehab@kernel.org
(cherry picked from commit 336561a914fc0c6f1218228718f633b31b7af1c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gt/intel_reset.c
diff --cc drivers/gpu/drm/i915/gt/intel_reset.c
index 72251638d4ea,c68d36fb5bbd..000000000000
--- a/drivers/gpu/drm/i915/gt/intel_reset.c
+++ b/drivers/gpu/drm/i915/gt/intel_reset.c
@@@ -309,17 -300,10 +309,17 @@@ static int gen6_hw_domain_reset(struct 
  	return err;
  }
  
- static int gen6_reset_engines(struct intel_gt *gt,
- 			      intel_engine_mask_t engine_mask,
- 			      unsigned int retry)
+ static int __gen6_reset_engines(struct intel_gt *gt,
+ 				intel_engine_mask_t engine_mask,
+ 				unsigned int retry)
  {
 +	static const u32 hw_engine_mask[] = {
 +		[RCS0]  = GEN6_GRDOM_RENDER,
 +		[BCS0]  = GEN6_GRDOM_BLT,
 +		[VCS0]  = GEN6_GRDOM_MEDIA,
 +		[VCS1]  = GEN8_GRDOM_MEDIA2,
 +		[VECS0] = GEN6_GRDOM_VECS,
 +	};
  	struct intel_engine_cs *engine;
  	u32 hw_mask;
  
@@@ -504,20 -501,10 +518,20 @@@ static void gen11_unlock_sfc(struct int
  	rmw_clear_fw(uncore, sfc_lock.lock_reg, sfc_lock.lock_bit);
  }
  
- static int gen11_reset_engines(struct intel_gt *gt,
- 			       intel_engine_mask_t engine_mask,
- 			       unsigned int retry)
+ static int __gen11_reset_engines(struct intel_gt *gt,
+ 				 intel_engine_mask_t engine_mask,
+ 				 unsigned int retry)
  {
 +	static const u32 hw_engine_mask[] = {
 +		[RCS0]  = GEN11_GRDOM_RENDER,
 +		[BCS0]  = GEN11_GRDOM_BLT,
 +		[VCS0]  = GEN11_GRDOM_MEDIA,
 +		[VCS1]  = GEN11_GRDOM_MEDIA2,
 +		[VCS2]  = GEN11_GRDOM_MEDIA3,
 +		[VCS3]  = GEN11_GRDOM_MEDIA4,
 +		[VECS0] = GEN11_GRDOM_VECS,
 +		[VECS1] = GEN11_GRDOM_VECS2,
 +	};
  	struct intel_engine_cs *engine;
  	intel_engine_mask_t tmp;
  	u32 reset_mask, unlock_mask = 0;
@@@ -633,10 -622,19 +650,22 @@@ static int gen8_reset_engines(struct in
  		 */
  	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Wa_22011100796:dg2, whenever Full soft reset is required,
+ 	 * reset all individual engines firstly, and then do a full soft reset.
+ 	 *
+ 	 * This is best effort, so ignore any error from the initial reset.
+ 	 */
+ 	if (IS_DG2(gt->i915) && engine_mask == ALL_ENGINES)
+ 		__gen11_reset_engines(gt, gt->info.engine_mask, 0);
+ 
++>>>>>>> 336561a914fc (drm/i915/gt: Serialize GRDOM access between multiple engine resets)
  	if (GRAPHICS_VER(gt->i915) >= 11)
- 		ret = gen11_reset_engines(gt, engine_mask, retry);
+ 		ret = __gen11_reset_engines(gt, engine_mask, retry);
  	else
- 		ret = gen6_reset_engines(gt, engine_mask, retry);
+ 		ret = __gen6_reset_engines(gt, engine_mask, retry);
  
  skip_reset:
  	for_each_engine_masked(engine, gt, engine_mask, tmp)
* Unmerged path drivers/gpu/drm/i915/gt/intel_reset.c
