net/mlx5e: TC, Split pedit offloads verify from alloc_tc_pedit_action()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 918ed7bf76267e43863205e0d61a949c301f367b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/918ed7bf.failed

Split pedit verify part into a new subfunction for better
maintainability.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 918ed7bf76267e43863205e0d61a949c301f367b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index d73114e91e9a,5eb5f6ec2f0d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -3061,108 -2993,17 +3061,116 @@@ static int offload_pedit_fields(struct 
  
  static const struct pedit_headers zero_masks = {};
  
++<<<<<<< HEAD
 +static int
 +parse_pedit_to_modify_hdr(struct mlx5e_priv *priv,
 +			  const struct flow_action_entry *act, int namespace,
 +			  struct mlx5e_tc_flow_parse_attr *parse_attr,
 +			  struct pedit_headers_action *hdrs,
 +			  struct netlink_ext_ack *extack)
 +{
 +	u8 cmd = (act->id == FLOW_ACTION_MANGLE) ? 0 : 1;
 +	int err = -EOPNOTSUPP;
 +	u32 mask, val, offset;
 +	u8 htype;
 +
 +	htype = act->mangle.htype;
 +	err = -EOPNOTSUPP; /* can't be all optimistic */
 +
 +	if (htype == FLOW_ACT_MANGLE_UNSPEC) {
 +		NL_SET_ERR_MSG_MOD(extack, "legacy pedit isn't offloaded");
 +		goto out_err;
 +	}
 +
 +	if (!mlx5e_mod_hdr_max_actions(priv->mdev, namespace)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "The pedit offload action is not supported");
 +		goto out_err;
 +	}
 +
 +	mask = act->mangle.mask;
 +	val = act->mangle.val;
 +	offset = act->mangle.offset;
 +
 +	err = set_pedit_val(htype, ~mask, val, offset, &hdrs[cmd], extack);
 +	if (err)
 +		goto out_err;
 +
 +	hdrs[cmd].pedits++;
 +
 +	return 0;
 +out_err:
 +	return err;
 +}
 +
 +static int
 +parse_pedit_to_reformat(const struct flow_action_entry *act,
 +			struct mlx5e_tc_flow_parse_attr *parse_attr,
 +			struct netlink_ext_ack *extack)
 +{
 +	u32 mask, val, offset;
 +	u32 *p;
 +
 +	if (act->id != FLOW_ACTION_MANGLE) {
 +		NL_SET_ERR_MSG_MOD(extack, "Unsupported action id");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (act->mangle.htype != FLOW_ACT_MANGLE_HDR_TYPE_ETH) {
 +		NL_SET_ERR_MSG_MOD(extack, "Only Ethernet modification is supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	mask = ~act->mangle.mask;
 +	val = act->mangle.val;
 +	offset = act->mangle.offset;
 +	p = (u32 *)&parse_attr->eth;
 +	*(p + (offset >> 2)) |= (val & mask);
 +
 +	return 0;
 +}
 +
 +static int parse_tc_pedit_action(struct mlx5e_priv *priv,
 +				 const struct flow_action_entry *act, int namespace,
 +				 struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				 struct pedit_headers_action *hdrs,
 +				 struct mlx5e_tc_flow *flow,
 +				 struct netlink_ext_ack *extack)
 +{
 +	if (flow && flow_flag_test(flow, L3_TO_L2_DECAP))
 +		return parse_pedit_to_reformat(act, parse_attr, extack);
 +
 +	return parse_pedit_to_modify_hdr(priv, act, namespace,
 +					 parse_attr, hdrs, extack);
 +}
 +
 +static int alloc_tc_pedit_action(struct mlx5e_priv *priv, int namespace,
 +				 struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				 struct pedit_headers_action *hdrs,
 +				 u32 *action_flags,
 +				 struct netlink_ext_ack *extack)
++=======
+ static int verify_offload_pedit_fields(struct mlx5e_priv *priv,
+ 				       struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				       struct netlink_ext_ack *extack)
++>>>>>>> 918ed7bf7626 (net/mlx5e: TC, Split pedit offloads verify from alloc_tc_pedit_action())
  {
  	struct pedit_headers *cmd_masks;
- 	int err;
  	u8 cmd;
  
++<<<<<<< HEAD
 +	err = offload_pedit_fields(priv, namespace, hdrs, parse_attr,
 +				   action_flags, extack);
 +	if (err < 0)
 +		goto out_dealloc_parsed_actions;
 +
++=======
++>>>>>>> 918ed7bf7626 (net/mlx5e: TC, Split pedit offloads verify from alloc_tc_pedit_action())
  	for (cmd = 0; cmd < __PEDIT_CMD_MAX; cmd++) {
 -		cmd_masks = &parse_attr->hdrs[cmd].masks;
 +		cmd_masks = &hdrs[cmd].masks;
  		if (memcmp(cmd_masks, &zero_masks, sizeof(zero_masks))) {
 -			NL_SET_ERR_MSG_MOD(extack, "attempt to offload an unsupported field");
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "attempt to offload an unsupported field");
  			netdev_warn(priv->netdev, "attempt to offload an unsupported field (cmd %d)\n", cmd);
  			print_hex_dump(KERN_WARNING, "mask: ", DUMP_PREFIX_ADDRESS,
  				       16, 1, cmd_masks, sizeof(zero_masks), true);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
