s390/vfio-ap: bypass unnecessary processing of AP resources

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 1918f2b20c3de73ef6f644979896e20a2e7dbb2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/1918f2b2.failed

It is not necessary to go through the process of validation, linking of
queues to mdev and vice versa and filtering the APQNs assigned to the
matrix mdev to build an AP configuration for a guest if an adapter or
domain being assigned is already assigned to the matrix mdev. Likewise, it
is not necessary to proceed through the process the unassignment of an
adapter, domain or control domain if it is not assigned to the matrix mdev.

Since it is not necessary to process assignment of a resource already
assigned or process unassignment of a resource that is been assigned,
this patch will bypass all assignment/unassignment operations for an
adapter, domain or control domain under these circumstances.

Not only is assignment of a duplicate adapter or domain unnecessary, it
will also cause a hang situation when removing the matrix mdev to which it is
assigned. The reason is because the same vfio_ap_queue objects with an
APQN containing the APID of the adapter or APQI of the domain being
assigned will get added multiple times to the hashtable that holds them.
This results in the pprev and next pointers of the hlist_node (mdev_qnode
field in the vfio_ap_queue object) pointing to the queue object itself
resulting in an interminable loop when the mdev is removed and the queue
table is iterated to reset the queues.

	Cc: stable@vger.kernel.org
Fixes: 11cb2419fafe ("s390/vfio-ap: manage link between queue struct and matrix mdev")
	Reported-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
	Signed-off-by: Halil Pasic <pasic@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 1918f2b20c3de73ef6f644979896e20a2e7dbb2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,ee82207b4e60..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -616,14 -984,10 +616,21 @@@ static ssize_t assign_adapter_store(str
  		goto done;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Set the bit in the AP mask (APM) corresponding to the AP adapter
 +	 * number (APID). The bits in the mask, from most significant to least
 +	 * significant bit, correspond to APIDs 0-255.
 +	 */
 +	ret = vfio_ap_mdev_verify_queues_reserved_for_apid(matrix_mdev, apid);
 +	if (ret)
 +		goto done;
++=======
+ 	if (test_bit_inv(apid, matrix_mdev->matrix.apm)) {
+ 		ret = count;
+ 		goto done;
+ 	}
++>>>>>>> 1918f2b20c3d (s390/vfio-ap: bypass unnecessary processing of AP resources)
  
  	set_bit_inv(apid, matrix_mdev->matrix.apm);
  
@@@ -684,10 -1114,16 +691,15 @@@ static ssize_t unassign_adapter_store(s
  		goto done;
  	}
  
+ 	if (!test_bit_inv(apid, matrix_mdev->matrix.apm)) {
+ 		ret = count;
+ 		goto done;
+ 	}
+ 
  	clear_bit_inv((unsigned long)apid, matrix_mdev->matrix.apm);
 -	vfio_ap_mdev_hot_unplug_adapter(matrix_mdev, apid);
  	ret = count;
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(unassign_adapter);
@@@ -768,9 -1193,10 +780,16 @@@ static ssize_t assign_domain_store(stru
  		goto done;
  	}
  
++<<<<<<< HEAD
 +	ret = vfio_ap_mdev_verify_queues_reserved_for_apqi(matrix_mdev, apqi);
 +	if (ret)
 +		goto done;
++=======
+ 	if (test_bit_inv(apqi, matrix_mdev->matrix.aqm)) {
+ 		ret = count;
+ 		goto done;
+ 	}
++>>>>>>> 1918f2b20c3d (s390/vfio-ap: bypass unnecessary processing of AP resources)
  
  	set_bit_inv(apqi, matrix_mdev->matrix.aqm);
  
@@@ -832,7 -1301,13 +851,12 @@@ static ssize_t unassign_domain_store(st
  		goto done;
  	}
  
+ 	if (!test_bit_inv(apqi, matrix_mdev->matrix.aqm)) {
+ 		ret = count;
+ 		goto done;
+ 	}
+ 
  	clear_bit_inv((unsigned long)apqi, matrix_mdev->matrix.aqm);
 -	vfio_ap_mdev_hot_unplug_domain(matrix_mdev, apqi);
  	ret = count;
  
  done:
@@@ -934,10 -1403,21 +963,15 @@@ static ssize_t unassign_control_domain_
  		goto done;
  	}
  
+ 	if (!test_bit_inv(domid, matrix_mdev->matrix.adm)) {
+ 		ret = count;
+ 		goto done;
+ 	}
+ 
  	clear_bit_inv(domid, matrix_mdev->matrix.adm);
 -
 -	if (test_bit_inv(domid, matrix_mdev->shadow_apcb.adm)) {
 -		clear_bit_inv(domid, matrix_mdev->shadow_apcb.adm);
 -		vfio_ap_mdev_update_guest_apcb(matrix_mdev);
 -	}
 -
  	ret = count;
  done:
 -	release_update_locks_for_mdev(matrix_mdev);
 +	mutex_unlock(&matrix_dev->lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(unassign_control_domain);
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
