md/raid5: Don't read ->active_stripes if it's not needed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Logan Gunthorpe <logang@deltatee.com>
commit f9287c3e93f00d3236c4c81bf76dae43afd903b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f9287c3e.failed

The atomic_read() is not needed in many cases so only do
the read after the first checks are done.

	Suggested-by: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
	Signed-off-by: Song Liu <song@kernel.org>
(cherry picked from commit f9287c3e93f00d3236c4c81bf76dae43afd903b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 74dbb79ad46f,e0514bda7695..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -763,9 -755,53 +763,59 @@@ static bool has_failed(struct r5conf *c
  	return degraded > conf->max_degraded;
  }
  
++<<<<<<< HEAD
 +struct stripe_head *
 +raid5_get_active_stripe(struct r5conf *conf, sector_t sector,
 +			int previous, int noblock, int noquiesce)
++=======
+ enum stripe_result {
+ 	STRIPE_SUCCESS = 0,
+ 	STRIPE_RETRY,
+ 	STRIPE_SCHEDULE_AND_RETRY,
+ 	STRIPE_FAIL,
+ };
+ 
+ struct stripe_request_ctx {
+ 	/* a reference to the last stripe_head for batching */
+ 	struct stripe_head *batch_last;
+ 
+ 	/* first sector in the request */
+ 	sector_t first_sector;
+ 
+ 	/* last sector in the request */
+ 	sector_t last_sector;
+ 
+ 	/*
+ 	 * bitmap to track stripe sectors that have been added to stripes
+ 	 * add one to account for unaligned requests
+ 	 */
+ 	DECLARE_BITMAP(sectors_to_do, RAID5_MAX_REQ_STRIPES + 1);
+ 
+ 	/* the request had REQ_PREFLUSH, cleared after the first stripe_head */
+ 	bool do_flush;
+ };
+ 
+ /*
+  * Block until another thread clears R5_INACTIVE_BLOCKED or
+  * there are fewer than 3/4 the maximum number of active stripes
+  * and there is an inactive stripe available.
+  */
+ static bool is_inactive_blocked(struct r5conf *conf, int hash)
+ {
+ 	if (list_empty(conf->inactive_list + hash))
+ 		return false;
+ 
+ 	if (!test_bit(R5_INACTIVE_BLOCKED, &conf->cache_state))
+ 		return true;
+ 
+ 	return (atomic_read(&conf->active_stripes) <
+ 		(conf->max_nr_stripes * 3 / 4));
+ }
+ 
+ struct stripe_head *raid5_get_active_stripe(struct r5conf *conf,
+ 		struct stripe_request_ctx *ctx, sector_t sector,
+ 		unsigned int flags)
++>>>>>>> f9287c3e93f0 (md/raid5: Don't read ->active_stripes if it's not needed)
  {
  	struct stripe_head *sh;
  	int hash = stripe_hash_locks_hash(conf, sector);
* Unmerged path drivers/md/raid5.c
