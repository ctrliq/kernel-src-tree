ASoC: SOF: topology: Add ops for setting up and tearing down pipelines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 31cd6e469364c42c9c929750991c51e83a95e80b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/31cd6e46.failed

Introduce two new ops, set_up_all_pipelines and tear_down_all_pipelines
in struct ipc_tplg_ops and define these for IPC3.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20220317175044.1752400-19-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 31cd6e469364c42c9c929750991c51e83a95e80b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc3-topology.c
#	sound/soc/sof/pm.c
#	sound/soc/sof/sof-audio.c
#	sound/soc/sof/sof-audio.h
diff --cc sound/soc/sof/pm.c
index 197a88695fef,1c319582ca6f..000000000000
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@@ -86,6 -70,8 +86,11 @@@ static void sof_cache_debugfs(struct sn
  static int sof_resume(struct device *dev, bool runtime_resume)
  {
  	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
++<<<<<<< HEAD
++=======
+ 	const struct sof_ipc_pm_ops *pm_ops = sdev->ipc->ops->pm;
+ 	const struct sof_ipc_tplg_ops *tplg_ops = sdev->ipc->ops->tplg;
++>>>>>>> 31cd6e469364 (ASoC: SOF: topology: Add ops for setting up and tearing down pipelines)
  	u32 old_state = sdev->dsp_power_state.state;
  	int ret;
  
@@@ -159,20 -145,23 +164,20 @@@
  	}
  
  	/* restore pipelines */
- 	ret = sof_set_up_pipelines(sdev, false);
- 	if (ret < 0) {
- 		dev_err(sdev->dev,
- 			"error: failed to restore pipeline after resume %d\n",
- 			ret);
- 		return ret;
+ 	if (tplg_ops->set_up_all_pipelines) {
+ 		ret = tplg_ops->set_up_all_pipelines(sdev, false);
+ 		if (ret < 0) {
+ 			dev_err(sdev->dev, "Failed to restore pipeline after resume %d\n", ret);
+ 			return ret;
+ 		}
  	}
  
 -	/* Notify clients not managed by pm framework about core resume */
 -	sof_resume_clients(sdev);
 -
  	/* notify DSP of system resume */
 -	if (pm_ops && pm_ops->ctx_restore) {
 -		ret = pm_ops->ctx_restore(sdev);
 -		if (ret < 0)
 -			dev_err(sdev->dev, "ctx_restore IPC error during resume: %d\n", ret);
 -	}
 +	ret = sof_send_pm_ctx_ipc(sdev, SOF_IPC_PM_CTX_RESTORE);
 +	if (ret < 0)
 +		dev_err(sdev->dev,
 +			"error: ctx_restore ipc error during resume %d\n",
 +			ret);
  
  	return ret;
  }
@@@ -180,6 -169,9 +185,12 @@@
  static int sof_suspend(struct device *dev, bool runtime_suspend)
  {
  	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
++<<<<<<< HEAD
++=======
+ 	const struct sof_ipc_pm_ops *pm_ops = sdev->ipc->ops->pm;
+ 	const struct sof_ipc_tplg_ops *tplg_ops = sdev->ipc->ops->tplg;
+ 	pm_message_t pm_state;
++>>>>>>> 31cd6e469364 (ASoC: SOF: topology: Add ops for setting up and tearing down pipelines)
  	u32 target_state = 0;
  	int ret;
  
@@@ -205,12 -197,17 +216,13 @@@
  	}
  
  	target_state = snd_sof_dsp_power_target(sdev);
 -	pm_state.event = target_state;
  
  	/* Skip to platform-specific suspend if DSP is entering D0 */
 -	if (target_state == SOF_DSP_PM_D0) {
 -		/* Notify clients not managed by pm framework about core suspend */
 -		sof_suspend_clients(sdev, pm_state);
 +	if (target_state == SOF_DSP_PM_D0)
  		goto suspend;
 -	}
  
- 	sof_tear_down_pipelines(sdev, false);
+ 	if (tplg_ops->tear_down_all_pipelines)
+ 		tplg_ops->tear_down_all_pipelines(sdev, false);
  
  	/* release trace */
  	snd_sof_release_trace(sdev);
diff --cc sound/soc/sof/sof-audio.c
index 59867de987af,b4ee65cf9841..000000000000
--- a/sound/soc/sof/sof-audio.c
+++ b/sound/soc/sof/sof-audio.c
@@@ -608,101 -498,20 +608,104 @@@ int sof_set_hw_params_upon_resume(struc
  	return snd_sof_dsp_hw_params_upon_resume(sdev);
  }
  
 -int sof_pcm_stream_free(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream,
 -			struct snd_sof_pcm *spcm, int dir, bool free_widget_list)
++<<<<<<< HEAD
 +int sof_set_up_pipelines(struct snd_sof_dev *sdev, bool verify)
  {
 -	const struct sof_ipc_pcm_ops *pcm_ops = sdev->ipc->ops->pcm;
 +	struct sof_ipc_fw_version *v = &sdev->fw_ready.version;
 +	struct snd_sof_widget *swidget;
 +	struct snd_sof_route *sroute;
  	int ret;
  
 -	/* Send PCM_FREE IPC to reset pipeline */
 -	if (pcm_ops->hw_free && spcm->prepared[substream->stream]) {
 -		ret = pcm_ops->hw_free(sdev->component, substream);
 +	/* restore pipeline components */
 +	list_for_each_entry(swidget, &sdev->widget_list, list) {
 +		/* only set up the widgets belonging to static pipelines */
 +		if (!verify && swidget->dynamic_pipeline_widget)
 +			continue;
 +
 +		/*
 +		 * For older firmware, skip scheduler widgets in this loop,
 +		 * sof_widget_setup() will be called in the 'complete pipeline' loop
 +		 */
 +		if (v->abi_version < SOF_ABI_VER(3, 19, 0) &&
 +		    swidget->id == snd_soc_dapm_scheduler)
 +			continue;
 +
 +		/* update DAI config. The IPC will be sent in sof_widget_setup() */
 +		if (WIDGET_IS_DAI(swidget->id)) {
 +			struct snd_sof_dai *dai = swidget->private;
 +			struct sof_dai_private_data *private = dai->private;
 +			struct sof_ipc_dai_config *config;
 +
 +			if (!dai || !private || !private->dai_config)
 +				continue;
 +
 +			config = private->dai_config;
 +			/*
 +			 * The link DMA channel would be invalidated for running
 +			 * streams but not for streams that were in the PAUSED
 +			 * state during suspend. So invalidate it here before setting
 +			 * the dai config in the DSP.
 +			 */
 +			if (config->type == SOF_DAI_INTEL_HDA)
 +				config->hda.link_dma_ch = DMA_CHAN_INVALID;
 +		}
 +
 +		ret = sof_widget_setup(sdev, swidget);
  		if (ret < 0)
  			return ret;
  	}
  
 -	spcm->prepared[substream->stream] = false;
 +	/* restore pipeline connections */
 +	list_for_each_entry(sroute, &sdev->route_list, list) {
 +
 +		/* only set up routes belonging to static pipelines */
 +		if (!verify && (sroute->src_widget->dynamic_pipeline_widget ||
 +				sroute->sink_widget->dynamic_pipeline_widget))
 +			continue;
 +
 +		ret = sof_route_setup_ipc(sdev, sroute);
 +		if (ret < 0) {
 +			dev_err(sdev->dev, "%s: restore pipeline connections failed\n", __func__);
 +			return ret;
 +		}
 +	}
 +
 +	/* complete pipeline */
 +	list_for_each_entry(swidget, &sdev->widget_list, list) {
 +		switch (swidget->id) {
 +		case snd_soc_dapm_scheduler:
 +			/* only complete static pipelines */
 +			if (!verify && swidget->dynamic_pipeline_widget)
 +				continue;
 +
 +			if (v->abi_version < SOF_ABI_VER(3, 19, 0)) {
 +				ret = sof_widget_setup(sdev, swidget);
 +				if (ret < 0)
 +					return ret;
 +			}
 +
 +			swidget->complete =
 +				snd_sof_complete_pipeline(sdev, swidget);
 +			break;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 31cd6e469364 (ASoC: SOF: topology: Add ops for setting up and tearing down pipelines)
 +int sof_pcm_stream_free(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream,
 +			struct snd_sof_pcm *spcm, int dir, bool free_widget_list)
 +{
 +	int ret;
 +
 +	/* Send PCM_FREE IPC to reset pipeline */
 +	ret = sof_pcm_dsp_pcm_free(substream, sdev, spcm);
 +	if (ret < 0)
 +		return ret;
  
  	/* stop the DMA */
  	ret = snd_sof_pcm_platform_hw_free(sdev, substream);
diff --cc sound/soc/sof/sof-audio.h
index d620c73a2a23,b9a9956b5baa..000000000000
--- a/sound/soc/sof/sof-audio.h
+++ b/sound/soc/sof/sof-audio.h
@@@ -82,12 -111,29 +82,35 @@@ struct sof_ipc_tplg_widget_ops 
   * @token_list: List of all tokens supported by the IPC version. The size of the token_list
   *		array should be SOF_TOKEN_COUNT. The unused elements in the array will be
   *		initialized to 0.
++<<<<<<< HEAD
++=======
+  * @control_setup: Function pointer for setting up kcontrol IPC-specific data
+  * @control_free: Function pointer for freeing kcontrol IPC-specific data
+  * @pipeline_complete: Function pointer for pipeline complete IPC
+  * @widget_setup: Function pointer for setting up setup in the DSP
+  * @widget_free: Function pointer for freeing widget in the DSP
+  * @dai_config: Function pointer for sending DAI config IPC to the DSP
+  * @set_up_all_pipelines: Function pointer for setting up all topology pipelines
+  * @tear_down_all_pipelines: Function pointer for tearing down all topology pipelines
++>>>>>>> 31cd6e469364 (ASoC: SOF: topology: Add ops for setting up and tearing down pipelines)
   */
  struct sof_ipc_tplg_ops {
  	const struct sof_ipc_tplg_widget_ops *widget;
 -	const struct sof_ipc_tplg_control_ops *control;
 +	const struct ipc_tplg_control_ops *control;
  	int (*route_setup)(struct snd_sof_dev *sdev, struct snd_sof_route *sroute);
  	const struct sof_token_info *token_list;
++<<<<<<< HEAD
++=======
+ 	int (*control_setup)(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol);
+ 	int (*control_free)(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol);
+ 	int (*pipeline_complete)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	int (*widget_setup)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	int (*widget_free)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget);
+ 	int (*dai_config)(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,
+ 			  unsigned int flags, struct snd_sof_dai_config_data *data);
+ 	int (*set_up_all_pipelines)(struct snd_sof_dev *sdev, bool verify);
+ 	int (*tear_down_all_pipelines)(struct snd_sof_dev *sdev, bool verify);
++>>>>>>> 31cd6e469364 (ASoC: SOF: topology: Add ops for setting up and tearing down pipelines)
  };
  
  /** struct snd_sof_tuple - Tuple info
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/pm.c
* Unmerged path sound/soc/sof/sof-audio.c
* Unmerged path sound/soc/sof/sof-audio.h
diff --git a/sound/soc/sof/topology.c b/sound/soc/sof/topology.c
index a127d3d2eab7..56f9e551cb94 100644
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@ -3507,29 +3507,15 @@ static int sof_route_load(struct snd_soc_component *scomp, int index,
 	    sink_swidget->id == snd_soc_dapm_output)
 		goto err;
 
-	/*
-	 * For virtual routes, both sink and source are not
-	 * buffer. Since only buffer linked to component is supported by
-	 * FW, others are reported as error, add check in route function,
-	 * do not send it to FW when both source and sink are not buffer
-	 */
-	if (source_swidget->id != snd_soc_dapm_buffer &&
-	    sink_swidget->id != snd_soc_dapm_buffer) {
-		dev_dbg(scomp->dev, "warning: neither Linked source component %s nor sink component %s is of buffer type, ignoring link\n",
-			route->source, route->sink);
-		goto err;
-	} else {
-		sroute->route = route;
-		dobj->private = sroute;
-		sroute->src_widget = source_swidget;
-		sroute->sink_widget = sink_swidget;
+	sroute->route = route;
+	dobj->private = sroute;
+	sroute->src_widget = source_swidget;
+	sroute->sink_widget = sink_swidget;
 
-		/* add route to route list */
-		list_add(&sroute->list, &sdev->route_list);
-
-		return 0;
-	}
+	/* add route to route list */
+	list_add(&sroute->list, &sdev->route_list);
 
+	return 0;
 err:
 	kfree(sroute);
 	return ret;
@@ -3621,21 +3607,28 @@ static int sof_complete(struct snd_soc_component *scomp)
 
 	/* verify topology components loading including dynamic pipelines */
 	if (sof_debug_check_flag(SOF_DBG_VERIFY_TPLG)) {
-		ret = sof_set_up_pipelines(sdev, true);
-		if (ret < 0) {
-			dev_err(sdev->dev, "error: topology verification failed %d\n", ret);
-			return ret;
-		}
+		if (ipc_tplg_ops->set_up_all_pipelines && ipc_tplg_ops->tear_down_all_pipelines) {
+			ret = ipc_tplg_ops->set_up_all_pipelines(sdev, true);
+			if (ret < 0) {
+				dev_err(sdev->dev, "Failed to set up all topology pipelines: %d\n",
+					ret);
+				return ret;
+			}
 
-		ret = sof_tear_down_pipelines(sdev, true);
-		if (ret < 0) {
-			dev_err(sdev->dev, "error: topology tear down pipelines failed %d\n", ret);
-			return ret;
+			ret = ipc_tplg_ops->tear_down_all_pipelines(sdev, true);
+			if (ret < 0) {
+				dev_err(sdev->dev, "Failed to tear down topology pipelines: %d\n",
+					ret);
+				return ret;
+			}
 		}
 	}
 
 	/* set up static pipelines */
-	return sof_set_up_pipelines(sdev, false);
+	if (ipc_tplg_ops->set_up_all_pipelines)
+		return ipc_tplg_ops->set_up_all_pipelines(sdev, false);
+
+	return 0;
 }
 
 /* manifest - optional to inform component of manifest */
