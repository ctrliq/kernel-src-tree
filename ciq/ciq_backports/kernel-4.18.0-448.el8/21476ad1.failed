wifi: mac80211: implement callbacks for <add/mod/del>_link_station

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Shaul Triebitz <shaul.triebitz@intel.com>
commit 21476ad16d3ca3687a474556c67d4789ef85a5df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/21476ad1.failed

Implement callbacks for cfg80211 add_link_station, mod_link_station,
and del_link_station API.

	Signed-off-by: Shaul Triebitz <shaul.triebitz@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 21476ad16d3ca3687a474556c67d4789ef85a5df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/sta_info.c
#	net/mac80211/sta_info.h
diff --cc net/mac80211/sta_info.c
index d25b297851c4,a4fa0ce7bd92..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -2604,3 -2662,99 +2604,102 @@@ void ieee80211_sta_set_expected_through
  
  	sta_update_codel_params(sta, thr);
  }
++<<<<<<< HEAD
++=======
+ 
+ int ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct sta_link_alloc *alloc;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	/* must represent an MLD from the start */
+ 	if (WARN_ON(!sta->sta.valid_links))
+ 		return -EINVAL;
+ 
+ 	if (WARN_ON(sta->sta.valid_links & BIT(link_id) ||
+ 		    sta->link[link_id]))
+ 		return -EBUSY;
+ 
+ 	alloc = kzalloc(sizeof(*alloc), GFP_KERNEL);
+ 	if (!alloc)
+ 		return -ENOMEM;
+ 
+ 	ret = sta_info_alloc_link(sdata->local, &alloc->info, GFP_KERNEL);
+ 	if (ret) {
+ 		kfree(alloc);
+ 		return ret;
+ 	}
+ 
+ 	sta_info_add_link(sta, link_id, &alloc->info, &alloc->sta);
+ 
+ 	return 0;
+ }
+ 
+ static int link_sta_info_hash_add(struct ieee80211_local *local,
+ 				  struct link_sta_info *link_sta)
+ {
+ 	return rhltable_insert(&local->link_sta_hash,
+ 			       &link_sta->link_hash_node,
+ 			       link_sta_rht_params);
+ }
+ 
+ void ieee80211_sta_free_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	lockdep_assert_held(&sta->sdata->local->sta_mtx);
+ 
+ 	sta_remove_link(sta, link_id, false);
+ }
+ 
+ int ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct link_sta_info *link_sta;
+ 	u16 old_links = sta->sta.valid_links;
+ 	u16 new_links = old_links | BIT(link_id);
+ 	int ret;
+ 
+ 	link_sta = rcu_dereference_protected(sta->link[link_id],
+ 					     lockdep_is_held(&sdata->local->sta_mtx));
+ 
+ 	if (WARN_ON(old_links == new_links || !link_sta))
+ 		return -EINVAL;
+ 
+ 	sta->sta.valid_links = new_links;
+ 
+ 	if (!test_sta_flag(sta, WLAN_STA_INSERTED)) {
+ 		ret = 0;
+ 		goto hash;
+ 	}
+ 
+ 	ret = drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				   old_links, new_links);
+ 	if (ret) {
+ 		sta->sta.valid_links = old_links;
+ 		sta_remove_link(sta, link_id, false);
+ 	}
+ 
+ hash:
+ 	link_sta_info_hash_add(sdata->local, link_sta);
+ 
+ 	return ret;
+ }
+ 
+ void ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	sta->sta.valid_links &= ~BIT(link_id);
+ 
+ 	if (test_sta_flag(sta, WLAN_STA_INSERTED))
+ 		drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				     sta->sta.valid_links,
+ 				     sta->sta.valid_links & ~BIT(link_id));
+ 
+ 	sta_remove_link(sta, link_id, true);
+ }
++>>>>>>> 21476ad16d3c (wifi: mac80211: implement callbacks for <add/mod/del>_link_station)
diff --cc net/mac80211/sta_info.h
index addc78b398f0,ea0eeee808a5..000000000000
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@@ -854,7 -898,11 +854,15 @@@ u32 sta_get_expected_throughput(struct 
  
  void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
  			  unsigned long exp_time);
++<<<<<<< HEAD
 +u8 sta_info_tx_streams(struct sta_info *sta);
++=======
+ 
+ int ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id);
+ void ieee80211_sta_free_link(struct sta_info *sta, unsigned int link_id);
+ int ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id);
+ void ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id);
++>>>>>>> 21476ad16d3c (wifi: mac80211: implement callbacks for <add/mod/del>_link_station)
  
  void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta);
  void ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta);
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f176465a1e43..9776ab33f735 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -4531,6 +4531,111 @@ static void ieee80211_del_intf_link(struct wiphy *wiphy,
 	ieee80211_vif_set_links(sdata, wdev->valid_links);
 }
 
+static int sta_add_link_station(struct ieee80211_local *local,
+				struct ieee80211_sub_if_data *sdata,
+				struct link_station_parameters *params)
+{
+	struct sta_info *sta;
+	int ret;
+
+	sta = sta_info_get_bss(sdata, params->mld_mac);
+	if (!sta)
+		return -ENOENT;
+
+	if (sta->sta.valid_links & BIT(params->link_id))
+		return -EALREADY;
+
+	ret = ieee80211_sta_allocate_link(sta, params->link_id);
+	if (ret)
+		return ret;
+
+	ret = sta_link_apply_parameters(local, sta, params);
+	if (ret) {
+		ieee80211_sta_free_link(sta, params->link_id);
+		return ret;
+	}
+
+	/* ieee80211_sta_activate_link frees the link upon failure */
+	return ieee80211_sta_activate_link(sta, params->link_id);
+}
+
+static int
+ieee80211_add_link_station(struct wiphy *wiphy, struct net_device *dev,
+			   struct link_station_parameters *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	int ret;
+
+	mutex_lock(&sdata->local->sta_mtx);
+	ret = sta_add_link_station(local, sdata, params);
+	mutex_unlock(&sdata->local->sta_mtx);
+
+	return ret;
+}
+
+static int sta_mod_link_station(struct ieee80211_local *local,
+				struct ieee80211_sub_if_data *sdata,
+				struct link_station_parameters *params)
+{
+	struct sta_info *sta;
+
+	sta = sta_info_get_bss(sdata, params->mld_mac);
+	if (!sta)
+		return -ENOENT;
+
+	if (!(sta->sta.valid_links & BIT(params->link_id)))
+		return -EINVAL;
+
+	return sta_link_apply_parameters(local, sta, params);
+}
+
+static int
+ieee80211_mod_link_station(struct wiphy *wiphy, struct net_device *dev,
+			   struct link_station_parameters *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	int ret;
+
+	mutex_lock(&sdata->local->sta_mtx);
+	ret = sta_mod_link_station(local, sdata, params);
+	mutex_unlock(&sdata->local->sta_mtx);
+
+	return ret;
+}
+
+static int sta_del_link_station(struct ieee80211_sub_if_data *sdata,
+				struct link_station_del_parameters *params)
+{
+	struct sta_info *sta;
+
+	sta = sta_info_get_bss(sdata, params->mld_mac);
+	if (!sta)
+		return -ENOENT;
+
+	if (!(sta->sta.valid_links & BIT(params->link_id)))
+		return -EINVAL;
+
+	ieee80211_sta_remove_link(sta, params->link_id);
+
+	return 0;
+}
+
+static int
+ieee80211_del_link_station(struct wiphy *wiphy, struct net_device *dev,
+			   struct link_station_del_parameters *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	int ret;
+
+	mutex_lock(&sdata->local->sta_mtx);
+	ret = sta_del_link_station(sdata, params);
+	mutex_unlock(&sdata->local->sta_mtx);
+
+	return ret;
+}
+
 const struct cfg80211_ops mac80211_config_ops = {
 	.add_virtual_intf = ieee80211_add_iface,
 	.del_virtual_intf = ieee80211_del_iface,
@@ -4638,4 +4743,7 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.set_radar_background = ieee80211_set_radar_background,
 	.add_intf_link = ieee80211_add_intf_link,
 	.del_intf_link = ieee80211_del_intf_link,
+	.add_link_station = ieee80211_add_link_station,
+	.mod_link_station = ieee80211_mod_link_station,
+	.del_link_station = ieee80211_del_link_station,
 };
* Unmerged path net/mac80211/sta_info.c
* Unmerged path net/mac80211/sta_info.h
