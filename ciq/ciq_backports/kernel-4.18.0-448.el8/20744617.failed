ASoC: SOF: topology: cleanup dailinks on widget unload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 20744617bdbafe2e7fb7bf5401f616e24bde4471
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/20744617.failed

We set the cpu_dai capture_ or playback_widget on widget_ready but
never clear them, which leads to failures when unloading/reloading a
topology in modprobe/rmmod tests

BugLink: https://github.com/thesofproject/linux/issues/3535
Fixes: 311ce4fe7637 ("ASoC: SOF: Add support for loading topologies")
	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20220406191606.254576-1-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 20744617bdbafe2e7fb7bf5401f616e24bde4471)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/topology.c
index 98443c24c00a,5953d1050cc9..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -1530,150 -1070,44 +1530,191 @@@ static int sof_connect_dai_widget(struc
  	return 0;
  }
  
 -static void sof_disconnect_dai_widget(struct snd_soc_component *scomp,
 -				      struct snd_soc_dapm_widget *w)
++<<<<<<< HEAD
 +/**
 + * sof_comp_alloc - allocate and initialize buffer for a new component
 + * @swidget: pointer to struct snd_sof_widget containing extended data
 + * @ipc_size: IPC payload size that will be updated depending on valid
 + *  extended data.
 + * @index: ID of the pipeline the component belongs to
 + *
 + * Return: The pointer to the new allocated component, NULL if failed.
 + */
 +static struct sof_ipc_comp *sof_comp_alloc(struct snd_sof_widget *swidget, size_t *ipc_size,
 +					   int index)
 +{
 +	struct sof_ipc_comp *comp;
 +	size_t total_size = *ipc_size;
 +	size_t ext_size = sizeof(swidget->uuid);
 +
 +	/* only non-zero UUID is valid */
 +	if (!guid_is_null(&swidget->uuid))
 +		total_size += ext_size;
 +
 +	comp = kzalloc(total_size, GFP_KERNEL);
 +	if (!comp)
 +		return NULL;
 +
 +	/* configure comp new IPC message */
 +	comp->hdr.size = total_size;
 +	comp->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;
 +	comp->id = swidget->comp_id;
 +	comp->pipeline_id = index;
 +	comp->core = swidget->core;
 +
 +	/* handle the extended data if needed */
 +	if (total_size > *ipc_size) {
 +		/* append extended data to the end of the component */
 +		memcpy((u8 *)comp + *ipc_size, &swidget->uuid, ext_size);
 +		comp->ext_data_length = ext_size;
 +	}
 +
 +	/* update ipc_size and return */
 +	*ipc_size = total_size;
 +	return comp;
 +}
 +
 +static int sof_widget_load_dai(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw,
 +			       struct snd_sof_dai *dai)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_dai_private_data *dai_data;
 +	struct sof_ipc_comp_dai *comp_dai;
 +	size_t ipc_size = sizeof(*comp_dai);
 +	int ret;
 +
 +	dai_data = kzalloc(sizeof(*dai_data), GFP_KERNEL);
 +	if (!dai_data)
 +		return -ENOMEM;
 +
 +	comp_dai = (struct sof_ipc_comp_dai *)
 +		   sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!comp_dai) {
 +		ret = -ENOMEM;
 +		goto free;
 +	}
 +
 +	/* configure dai IPC message */
 +	comp_dai->comp.type = SOF_COMP_DAI;
 +	comp_dai->config.hdr.size = sizeof(comp_dai->config);
 +
 +	ret = sof_parse_tokens(scomp, comp_dai, dai_tokens,
 +			       ARRAY_SIZE(dai_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dai tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto free;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &comp_dai->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dai.cfg tokens failed %d\n",
 +			private->size);
 +		goto free;
 +	}
 +
 +	dev_dbg(scomp->dev, "dai %s: type %d index %d\n",
 +		swidget->widget->name, comp_dai->type, comp_dai->dai_index);
 +	sof_dbg_comp_config(scomp, &comp_dai->config);
 +
 +	if (dai) {
 +		dai->scomp = scomp;
 +		dai_data->comp_dai = comp_dai;
 +		dai->private = dai_data;
 +	}
 +
 +	return 0;
 +
 +free:
 +	kfree(dai_data);
 +	return ret;
 +}
 +
 +/*
 + * Buffer topology
 + */
 +
 +static int sof_widget_load_buffer(struct snd_soc_component *scomp, int index,
 +				  struct snd_sof_widget *swidget,
 +				  struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_buffer *buffer;
 +	int ret;
 +
 +	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
 +	if (!buffer)
 +		return -ENOMEM;
 +
 +	/* configure dai IPC message */
 +	buffer->comp.hdr.size = sizeof(*buffer);
 +	buffer->comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_BUFFER_NEW;
 +	buffer->comp.id = swidget->comp_id;
 +	buffer->comp.type = SOF_COMP_BUFFER;
 +	buffer->comp.pipeline_id = index;
 +	buffer->comp.core = swidget->core;
 +
 +	ret = sof_parse_tokens(scomp, buffer, buffer_tokens,
 +			       ARRAY_SIZE(buffer_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse buffer tokens failed %d\n",
 +			private->size);
 +		kfree(buffer);
 +		return ret;
 +	}
 +
 +	dev_dbg(scomp->dev, "buffer %s: size %d caps 0x%x\n",
 +		swidget->widget->name, buffer->size, buffer->caps);
 +
 +	swidget->private = buffer;
 +
 +	return 0;
++=======
++static void sof_disconnect_dai_widget(struct snd_soc_component *scomp,
++				      struct snd_soc_dapm_widget *w)
+ {
+ 	struct snd_soc_card *card = scomp->card;
+ 	struct snd_soc_pcm_runtime *rtd;
+ 	struct snd_soc_dai *cpu_dai;
+ 	int i;
+ 
+ 	if (!w->sname)
+ 		return;
+ 
+ 	list_for_each_entry(rtd, &card->rtd_list, list) {
+ 		/* does stream match DAI link ? */
+ 		if (!rtd->dai_link->stream_name ||
+ 		    strcmp(w->sname, rtd->dai_link->stream_name))
+ 			continue;
+ 
+ 		switch (w->id) {
+ 		case snd_soc_dapm_dai_out:
+ 			for_each_rtd_cpu_dais(rtd, i, cpu_dai) {
+ 				if (cpu_dai->capture_widget == w) {
+ 					cpu_dai->capture_widget = NULL;
+ 					break;
+ 				}
+ 			}
+ 			break;
+ 		case snd_soc_dapm_dai_in:
+ 			for_each_rtd_cpu_dais(rtd, i, cpu_dai) {
+ 				if (cpu_dai->playback_widget == w) {
+ 					cpu_dai->playback_widget = NULL;
+ 					break;
+ 				}
+ 			}
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
++>>>>>>> 20744617bdba (ASoC: SOF: topology: cleanup dailinks on widget unload)
  }
  
  /* bind PCM ID to host component ID */
@@@ -1900,665 -1365,39 +1941,671 @@@ static int sof_widget_load_mux(struct s
  	return 0;
  }
  
 -static int sof_widget_unload(struct snd_soc_component *scomp,
 -			     struct snd_soc_dobj *dobj)
 +/*
 + * PGA Topology
 + */
 +
 +static int sof_widget_load_pga(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
  {
  	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 -	const struct sof_ipc_tplg_ops *ipc_tplg_ops = sdev->ipc->ops->tplg;
 -	const struct sof_ipc_tplg_widget_ops *widget_ops = ipc_tplg_ops->widget;
 -	const struct snd_kcontrol_new *kc;
 -	struct snd_soc_dapm_widget *widget;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_volume *volume;
  	struct snd_sof_control *scontrol;
 -	struct snd_sof_widget *swidget;
 -	struct soc_mixer_control *sm;
 -	struct soc_bytes_ext *sbe;
 -	struct snd_sof_dai *dai;
 -	struct soc_enum *se;
 -	int ret = 0;
 -	int i;
 +	size_t ipc_size = sizeof(*volume);
 +	int min_step;
 +	int max_step;
 +	int ret;
  
 -	swidget = dobj->private;
 -	if (!swidget)
 -		return 0;
 +	volume = (struct sof_ipc_comp_volume *)
 +		 sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!volume)
 +		return -ENOMEM;
  
 -	widget = swidget->widget;
 +	if (!le32_to_cpu(tw->num_kcontrols)) {
 +		dev_err(scomp->dev, "error: invalid kcontrol count %d for volume\n",
 +			tw->num_kcontrols);
 +		ret = -EINVAL;
 +		goto err;
 +	}
  
 -	switch (swidget->id) {
 -	case snd_soc_dapm_dai_in:
 -	case snd_soc_dapm_dai_out:
 -		dai = swidget->private;
 +	/* configure volume IPC message */
 +	volume->comp.type = SOF_COMP_VOLUME;
 +	volume->config.hdr.size = sizeof(volume->config);
  
 -		if (dai)
 +	ret = sof_parse_tokens(scomp, volume, volume_tokens,
 +			       ARRAY_SIZE(volume_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +	ret = sof_parse_tokens(scomp, &volume->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &volume->config);
 +
 +	swidget->private = volume;
 +
 +	list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
 +		if (scontrol->comp_id == swidget->comp_id &&
 +		    scontrol->volume_table) {
 +			min_step = scontrol->min_volume_step;
 +			max_step = scontrol->max_volume_step;
 +			volume->min_value = scontrol->volume_table[min_step];
 +			volume->max_value = scontrol->volume_table[max_step];
 +			volume->channels = scontrol->num_channels;
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +err:
 +	kfree(volume);
 +	return ret;
 +}
 +
 +/*
 + * SRC Topology
 + */
 +
 +static int sof_widget_load_src(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_src *src;
 +	size_t ipc_size = sizeof(*src);
 +	int ret;
 +
 +	src = (struct sof_ipc_comp_src *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!src)
 +		return -ENOMEM;
 +
 +	/* configure src IPC message */
 +	src->comp.type = SOF_COMP_SRC;
 +	src->config.hdr.size = sizeof(src->config);
 +
 +	ret = sof_parse_tokens(scomp, src, src_tokens,
 +			       ARRAY_SIZE(src_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &src->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "src %s: source rate %d sink rate %d\n",
 +		swidget->widget->name, src->source_rate, src->sink_rate);
 +	sof_dbg_comp_config(scomp, &src->config);
 +
 +	swidget->private = src;
 +
 +	return 0;
 +err:
 +	kfree(src);
 +	return ret;
 +}
 +
 +/*
 + * ASRC Topology
 + */
 +
 +static int sof_widget_load_asrc(struct snd_soc_component *scomp, int index,
 +				struct snd_sof_widget *swidget,
 +				struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_asrc *asrc;
 +	size_t ipc_size = sizeof(*asrc);
 +	int ret;
 +
 +	asrc = (struct sof_ipc_comp_asrc *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!asrc)
 +		return -ENOMEM;
 +
 +	/* configure ASRC IPC message */
 +	asrc->comp.type = SOF_COMP_ASRC;
 +	asrc->config.hdr.size = sizeof(asrc->config);
 +
 +	ret = sof_parse_tokens(scomp, asrc, asrc_tokens,
 +			       ARRAY_SIZE(asrc_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &asrc->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "asrc %s: source rate %d sink rate %d "
 +		"asynch %d operation %d\n",
 +		swidget->widget->name, asrc->source_rate, asrc->sink_rate,
 +		asrc->asynchronous_mode, asrc->operation_mode);
 +	sof_dbg_comp_config(scomp, &asrc->config);
 +
 +	swidget->private = asrc;
 +
 +	return 0;
 +err:
 +	kfree(asrc);
 +	return ret;
 +}
 +
 +/*
 + * Signal Generator Topology
 + */
 +
 +static int sof_widget_load_siggen(struct snd_soc_component *scomp, int index,
 +				  struct snd_sof_widget *swidget,
 +				  struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_tone *tone;
 +	size_t ipc_size = sizeof(*tone);
 +	int ret;
 +
 +	tone = (struct sof_ipc_comp_tone *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!tone)
 +		return -ENOMEM;
 +
 +	/* configure siggen IPC message */
 +	tone->comp.type = SOF_COMP_TONE;
 +	tone->config.hdr.size = sizeof(tone->config);
 +
 +	ret = sof_parse_tokens(scomp, tone, tone_tokens,
 +			       ARRAY_SIZE(tone_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse tone tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &tone->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse tone.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "tone %s: frequency %d amplitude %d\n",
 +		swidget->widget->name, tone->frequency, tone->amplitude);
 +	sof_dbg_comp_config(scomp, &tone->config);
 +
 +	swidget->private = tone;
 +
 +	return 0;
 +err:
 +	kfree(tone);
 +	return ret;
 +}
 +
 +static int sof_get_control_data(struct snd_soc_component *scomp,
 +				struct snd_soc_dapm_widget *widget,
 +				struct sof_widget_data *wdata,
 +				size_t *size)
 +{
 +	const struct snd_kcontrol_new *kc;
 +	struct soc_mixer_control *sm;
 +	struct soc_bytes_ext *sbe;
 +	struct soc_enum *se;
 +	int i;
 +
 +	*size = 0;
 +
 +	for (i = 0; i < widget->num_kcontrols; i++) {
 +		kc = &widget->kcontrol_news[i];
 +
 +		switch (widget->dobj.widget.kcontrol_type[i]) {
 +		case SND_SOC_TPLG_TYPE_MIXER:
 +			sm = (struct soc_mixer_control *)kc->private_value;
 +			wdata[i].control = sm->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_BYTES:
 +			sbe = (struct soc_bytes_ext *)kc->private_value;
 +			wdata[i].control = sbe->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_ENUM:
 +			se = (struct soc_enum *)kc->private_value;
 +			wdata[i].control = se->dobj.private;
 +			break;
 +		default:
 +			dev_err(scomp->dev, "error: unknown kcontrol type %u in widget %s\n",
 +				widget->dobj.widget.kcontrol_type[i],
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		if (!wdata[i].control) {
 +			dev_err(scomp->dev, "error: no scontrol for widget %s\n",
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		wdata[i].pdata = wdata[i].control->control_data->data;
 +		if (!wdata[i].pdata)
 +			return -EINVAL;
 +
 +		/* make sure data is valid - data can be updated at runtime */
 +		if (widget->dobj.widget.kcontrol_type[i] == SND_SOC_TPLG_TYPE_BYTES &&
 +		    wdata[i].pdata->magic != SOF_ABI_MAGIC)
 +			return -EINVAL;
 +
 +		*size += wdata[i].pdata->size;
 +
 +		/* get data type */
 +		switch (wdata[i].control->control_data->cmd) {
 +		case SOF_CTRL_CMD_VOLUME:
 +		case SOF_CTRL_CMD_ENUM:
 +		case SOF_CTRL_CMD_SWITCH:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_VALUE;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_VALUE_CHAN_SET;
 +			break;
 +		case SOF_CTRL_CMD_BINARY:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_DATA;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_DATA_SET;
 +			break;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_process_load(struct snd_soc_component *scomp, int index,
 +			    struct snd_sof_widget *swidget,
 +			    struct snd_soc_tplg_dapm_widget *tw,
 +			    int type)
 +{
 +	struct snd_soc_dapm_widget *widget = swidget->widget;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process *process;
 +	struct sof_widget_data *wdata = NULL;
 +	size_t ipc_data_size = 0;
 +	size_t ipc_size;
 +	int offset = 0;
 +	int ret;
 +	int i;
 +
 +	/* allocate struct for widget control data sizes and types */
 +	if (widget->num_kcontrols) {
 +		wdata = kcalloc(widget->num_kcontrols,
 +				sizeof(*wdata),
 +				GFP_KERNEL);
 +
 +		if (!wdata)
 +			return -ENOMEM;
 +
 +		/* get possible component controls and get size of all pdata */
 +		ret = sof_get_control_data(scomp, widget, wdata,
 +					   &ipc_data_size);
 +
 +		if (ret < 0)
 +			goto out;
 +	}
 +
 +	ipc_size = sizeof(struct sof_ipc_comp_process) + ipc_data_size;
 +
 +	/* we are exceeding max ipc size, config needs to be sent separately */
 +	if (ipc_size > SOF_IPC_MSG_MAX_SIZE) {
 +		ipc_size -= ipc_data_size;
 +		ipc_data_size = 0;
 +	}
 +
 +	process = (struct sof_ipc_comp_process *)
 +		  sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!process) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* configure iir IPC message */
 +	process->comp.type = type;
 +	process->config.hdr.size = sizeof(process->config);
 +
 +	ret = sof_parse_tokens(scomp, &process->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &process->config);
 +
 +	/*
 +	 * found private data in control, so copy it.
 +	 * get possible component controls - get size of all pdata,
 +	 * then memcpy with headers
 +	 */
 +	if (ipc_data_size) {
 +		for (i = 0; i < widget->num_kcontrols; i++) {
 +			memcpy(&process->data[offset],
 +			       wdata[i].pdata->data,
 +			       wdata[i].pdata->size);
 +			offset += wdata[i].pdata->size;
 +		}
 +	}
 +
 +	process->size = ipc_data_size;
 +	swidget->private = process;
 +err:
 +	if (ret < 0)
 +		kfree(process);
 +out:
 +	kfree(wdata);
 +	return ret;
 +}
 +
 +/*
 + * Processing Component Topology - can be "effect", "codec", or general
 + * "processing".
 + */
 +
 +static int sof_widget_load_process(struct snd_soc_component *scomp, int index,
 +				   struct snd_sof_widget *swidget,
 +				   struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process config;
 +	int ret;
 +
 +	/* check we have some tokens - we need at least process type */
 +	if (le32_to_cpu(private->size) == 0) {
 +		dev_err(scomp->dev, "error: process tokens not found\n");
 +		return -EINVAL;
 +	}
 +
 +	memset(&config, 0, sizeof(config));
 +	config.comp.core = swidget->core;
 +
 +	/* get the process token */
 +	ret = sof_parse_tokens(scomp, &config, process_tokens,
 +			       ARRAY_SIZE(process_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	/* now load process specific data and send IPC */
 +	ret = sof_process_load(scomp, index, swidget, tw, find_process_comp_type(config.type));
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: process loading failed\n");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_widget_bind_event(struct snd_soc_component *scomp,
 +				 struct snd_sof_widget *swidget,
 +				 u16 event_type)
 +{
 +	struct sof_ipc_comp *ipc_comp;
 +
 +	/* validate widget event type */
 +	switch (event_type) {
 +	case SOF_KEYWORD_DETECT_DAPM_EVENT:
 +		/* only KEYWORD_DETECT comps should handle this */
 +		if (swidget->id != snd_soc_dapm_effect)
 +			break;
 +
 +		ipc_comp = swidget->private;
 +		if (ipc_comp && ipc_comp->type != SOF_COMP_KEYWORD_DETECT)
 +			break;
 +
 +		/* bind event to keyword detect comp */
 +		return snd_soc_tplg_widget_bind_event(swidget->widget,
 +						      sof_kwd_events,
 +						      ARRAY_SIZE(sof_kwd_events),
 +						      event_type);
 +	default:
 +		break;
 +	}
 +
 +	dev_err(scomp->dev,
 +		"error: invalid event type %d for widget %s\n",
 +		event_type, swidget->widget->name);
 +	return -EINVAL;
 +}
 +
 +/* external widget init - used for any driver specific init */
 +static int sof_widget_ready(struct snd_soc_component *scomp, int index,
 +			    struct snd_soc_dapm_widget *w,
 +			    struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_sof_widget *swidget;
 +	struct snd_sof_dai *dai;
 +	struct sof_ipc_comp comp = {
 +		.core = SOF_DSP_PRIMARY_CORE,
 +	};
 +	int ret = 0;
 +
 +	swidget = kzalloc(sizeof(*swidget), GFP_KERNEL);
 +	if (!swidget)
 +		return -ENOMEM;
 +
 +	swidget->scomp = scomp;
 +	swidget->widget = w;
 +	swidget->comp_id = sdev->next_comp_id++;
 +	swidget->complete = 0;
 +	swidget->id = w->id;
 +	swidget->pipeline_id = index;
 +	swidget->private = NULL;
 +
 +	dev_dbg(scomp->dev, "tplg: ready widget id %d pipe %d type %d name : %s stream %s\n",
 +		swidget->comp_id, index, swidget->id, tw->name,
 +		strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 +			? tw->sname : "none");
 +
 +	ret = sof_parse_tokens(scomp, &comp, core_tokens,
 +			       ARRAY_SIZE(core_tokens), tw->priv.array,
 +			       le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing core tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		comp.core = SOF_DSP_PRIMARY_CORE;
 +
 +	swidget->core = comp.core;
 +
 +	ret = sof_parse_tokens(scomp, swidget, comp_ext_tokens, ARRAY_SIZE(comp_ext_tokens),
 +			       tw->priv.array, le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing comp_ext_tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	/* handle any special case widgets */
 +	switch (w->id) {
 +	case snd_soc_dapm_dai_in:
 +	case snd_soc_dapm_dai_out:
 +		dai = kzalloc(sizeof(*dai), GFP_KERNEL);
 +		if (!dai) {
 +			kfree(swidget);
 +			return -ENOMEM;
 +		}
 +
 +		ret = sof_widget_load_dai(scomp, index, swidget, tw, dai);
 +		if (!ret)
 +			ret = sof_connect_dai_widget(scomp, w, tw, dai);
 +		if (ret < 0) {
 +			kfree(dai);
 +			break;
 +		}
 +		list_add(&dai->list, &sdev->dai_list);
 +		swidget->private = dai;
 +		break;
 +	case snd_soc_dapm_mixer:
 +		ret = sof_widget_load_mixer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_pga:
 +		ret = sof_widget_load_pga(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_buffer:
 +		ret = sof_widget_load_buffer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_scheduler:
 +		ret = sof_widget_load_pipeline(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_aif_out:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_CAPTURE, tw);
 +		break;
 +	case snd_soc_dapm_aif_in:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_PLAYBACK, tw);
 +		break;
 +	case snd_soc_dapm_src:
 +		ret = sof_widget_load_src(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_asrc:
 +		ret = sof_widget_load_asrc(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_siggen:
 +		ret = sof_widget_load_siggen(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_effect:
 +		ret = sof_widget_load_process(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_mux:
 +	case snd_soc_dapm_demux:
 +		ret = sof_widget_load_mux(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_switch:
 +	case snd_soc_dapm_dai_link:
 +	case snd_soc_dapm_kcontrol:
 +	default:
 +		dev_dbg(scomp->dev, "widget type %d name %s not handled\n", swidget->id, tw->name);
 +		break;
 +	}
 +
 +	/* check IPC reply */
 +	if (ret < 0) {
 +		dev_err(scomp->dev,
 +			"error: failed to add widget id %d type %d name : %s stream %s\n",
 +			tw->shift, swidget->id, tw->name,
 +			strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 +				? tw->sname : "none");
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	/* bind widget to external event */
 +	if (tw->event_type) {
 +		ret = sof_widget_bind_event(scomp, swidget,
 +					    le16_to_cpu(tw->event_type));
 +		if (ret) {
 +			dev_err(scomp->dev, "error: widget event binding failed\n");
 +			kfree(swidget->private);
 +			kfree(swidget);
 +			return ret;
 +		}
 +	}
 +
 +	w->dobj.private = swidget;
 +	list_add(&swidget->list, &sdev->widget_list);
 +	return ret;
 +}
 +
 +static int sof_route_unload(struct snd_soc_component *scomp,
 +			    struct snd_soc_dobj *dobj)
 +{
 +	struct snd_sof_route *sroute;
 +
 +	sroute = dobj->private;
 +	if (!sroute)
 +		return 0;
 +
 +	/* free sroute and its private data */
 +	kfree(sroute->private);
 +	list_del(&sroute->list);
 +	kfree(sroute);
 +
 +	return 0;
 +}
 +
 +static int sof_widget_unload(struct snd_soc_component *scomp,
 +			     struct snd_soc_dobj *dobj)
 +{
 +	const struct snd_kcontrol_new *kc;
 +	struct snd_soc_dapm_widget *widget;
 +	struct snd_sof_control *scontrol;
 +	struct snd_sof_widget *swidget;
 +	struct soc_mixer_control *sm;
 +	struct soc_bytes_ext *sbe;
 +	struct snd_sof_dai *dai;
 +	struct soc_enum *se;
 +	int ret = 0;
 +	int i;
 +
 +	swidget = dobj->private;
 +	if (!swidget)
 +		return 0;
 +
 +	widget = swidget->widget;
 +
 +	switch (swidget->id) {
 +	case snd_soc_dapm_dai_in:
 +	case snd_soc_dapm_dai_out:
 +		dai = swidget->private;
 +
 +		if (dai) {
 +			struct sof_dai_private_data *dai_data = dai->private;
 +
 +			kfree(dai_data->comp_dai);
 +			kfree(dai_data->dai_config);
 +			kfree(dai_data);
  			list_del(&dai->list);
++<<<<<<< HEAD
 +		}
++=======
+ 
+ 		sof_disconnect_dai_widget(scomp, widget);
+ 
++>>>>>>> 20744617bdba (ASoC: SOF: topology: cleanup dailinks on widget unload)
  		break;
  	default:
  		break;
* Unmerged path sound/soc/sof/topology.c
