wifi: mac80211: mlme: track AP (MLD) address separately

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit b65567b03c9502e67bed6707cb53a4c730c2bee2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b65567b0.failed

To prepare a bit more for MLO in the client code,
track the AP's address (for now only the BSSID, but
will track the AP MLD's address later) separately
from the per-link BSSID.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit b65567b03c9502e67bed6707cb53a4c730c2bee2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/mac80211.h
#	net/mac80211/mlme.c
diff --cc include/net/mac80211.h
index f38672457468,36eba96a1012..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -1710,6 -1708,46 +1710,49 @@@ enum ieee80211_offload_flags 
  };
  
  /**
++<<<<<<< HEAD
++=======
+  * struct ieee80211_vif_cfg - interface configuration
+  * @assoc: association status
+  * @ibss_joined: indicates whether this station is part of an IBSS or not
+  * @ibss_creator: indicates if a new IBSS network is being created
+  * @ps: power-save mode (STA only). This flag is NOT affected by
+  *	offchannel/dynamic_ps operations.
+  * @aid: association ID number, valid only when @assoc is true
+  * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The
+  *	may filter ARP queries targeted for other addresses than listed here.
+  *	The driver must allow ARP queries targeted for all address listed here
+  *	to pass through. An empty list implies no ARP queries need to pass.
+  * @arp_addr_cnt: Number of addresses currently on the list. Note that this
+  *	may be larger than %IEEE80211_BSS_ARP_ADDR_LIST_LEN (the arp_addr_list
+  *	array size), it's up to the driver what to do in that case.
+  * @ssid: The SSID of the current vif. Valid in AP and IBSS mode.
+  * @ssid_len: Length of SSID given in @ssid.
+  * @s1g: BSS is S1G BSS (affects Association Request format).
+  * @idle: This interface is idle. There's also a global idle flag in the
+  *	hardware config which may be more appropriate depending on what
+  *	your driver/device needs to do.
+  * @ap_addr: AP MLD address, or BSSID for non-MLO connections
+  *	(station mode only)
+  */
+ struct ieee80211_vif_cfg {
+ 	/* association related data */
+ 	bool assoc, ibss_joined;
+ 	bool ibss_creator;
+ 	bool ps;
+ 	u16 aid;
+ 
+ 	__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];
+ 	int arp_addr_cnt;
+ 	u8 ssid[IEEE80211_MAX_SSID_LEN];
+ 	size_t ssid_len;
+ 	bool s1g;
+ 	bool idle;
+ 	u8 ap_addr[ETH_ALEN] __aligned(2);
+ };
+ 
+ /**
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
   * struct ieee80211_vif - per-interface data
   *
   * Data in this structure is continually present for driver
diff --cc net/mac80211/mlme.c
index 6cd411ed25d6,a2e8fe9b43ab..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -1805,7 -1808,7 +1805,11 @@@ static bool ieee80211_powersave_allowed
  		return false;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	sta = sta_info_get(sdata, mgd->bssid);
++=======
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  	if (sta)
  		authorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);
  	rcu_read_unlock();
@@@ -2304,8 -2311,9 +2308,14 @@@ static void ieee80211_set_associated(st
  		beacon_loss_count * bss_conf->beacon_int));
  
  	sdata->u.mgd.associated = true;
++<<<<<<< HEAD
 +	sdata->u.mgd.assoc_bss = cbss;
 +	memcpy(sdata->u.mgd.bssid, cbss->bssid, ETH_ALEN);
++=======
+ 	sdata->deflink.u.mgd.bss = cbss;
+ 	memcpy(sdata->deflink.u.mgd.bssid, cbss->bssid, ETH_ALEN);
+ 	memcpy(sdata->vif.cfg.ap_addr, cbss->bssid, ETH_ALEN);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  
  	ieee80211_check_rate_mask(sdata);
  
@@@ -2454,9 -2462,10 +2464,14 @@@ static void ieee80211_set_disassoc(stru
  	drv_mgd_complete_tx(sdata->local, sdata, &info);
  
  	/* clear bssid only after building the needed mgmt frames */
 -	eth_zero_addr(sdata->deflink.u.mgd.bssid);
 +	eth_zero_addr(ifmgd->bssid);
  
++<<<<<<< HEAD
 +	sdata->vif.bss_conf.ssid_len = 0;
++=======
+ 	eth_zero_addr(sdata->vif.cfg.ap_addr);
+ 	sdata->vif.cfg.ssid_len = 0;
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  
  	/* remove AP and TDLS peers */
  	sta_info_flush(sdata);
@@@ -2645,7 -2655,7 +2660,11 @@@ static void ieee80211_mlme_send_probe_r
  static void ieee80211_mgd_probe_ap_send(struct ieee80211_sub_if_data *sdata)
  {
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
++<<<<<<< HEAD
 +	u8 *dst = ifmgd->bssid;
++=======
+ 	u8 *dst = sdata->vif.cfg.ap_addr;
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  	u8 unicast_limit = max(1, max_probe_tries - 3);
  	struct sta_info *sta;
  
@@@ -2874,13 -2884,13 +2893,21 @@@ static void ieee80211_beacon_connection
  
  	if (ifmgd->connection_loss) {
  		sdata_info(sdata, "Connection to AP %pM lost\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid);
++=======
+ 			   sdata->vif.cfg.ap_addr);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  		__ieee80211_disconnect(sdata);
  		ifmgd->connection_loss = false;
  	} else if (ifmgd->driver_disconnect) {
  		sdata_info(sdata,
  			   "Driver requested disconnection from AP %pM\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid);
++=======
+ 			   sdata->vif.cfg.ap_addr);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  		__ieee80211_disconnect(sdata);
  		ifmgd->driver_disconnect = false;
  	} else {
@@@ -4860,10 -4883,11 +4887,14 @@@ static void ieee80211_sta_conn_mon_time
  	struct sta_info *sta;
  	unsigned long timeout;
  
 -	if (sdata->vif.bss_conf.csa_active &&
 -	    !sdata->deflink.u.mgd.csa_waiting_bcn)
 +	if (sdata->vif.bss_conf.csa_active && !ifmgd->csa_waiting_bcn)
  		return;
  
++<<<<<<< HEAD
 +	sta = sta_info_get(sdata, ifmgd->bssid);
++=======
+ 	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  	if (!sta)
  		return;
  
@@@ -4959,7 -4983,7 +4990,11 @@@ void ieee80211_mgd_quiesce(struct ieee8
  			.bssid = bssid,
  		};
  
++<<<<<<< HEAD
 +		memcpy(bssid, ifmgd->bssid, ETH_ALEN);
++=======
+ 		memcpy(bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  		ieee80211_mgd_deauth(sdata, &req);
  	}
  
@@@ -5865,7 -5911,7 +5900,11 @@@ int ieee80211_mgd_auth(struct ieee80211
  
  		sdata_info(sdata,
  			   "disconnect from AP %pM for new auth to %pM\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid, req->bss->bssid);
++=======
+ 			   sdata->vif.cfg.ap_addr, req->bss->bssid);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
  				       WLAN_REASON_UNSPECIFIED,
  				       false, frame_buf);
@@@ -5941,7 -5988,7 +5980,11 @@@ int ieee80211_mgd_assoc(struct ieee8021
  
  		sdata_info(sdata,
  			   "disconnect from AP %pM for new assoc to %pM\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid, req->bss->bssid);
++=======
+ 			   sdata->vif.cfg.ap_addr, req->bss->bssid);
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
  				       WLAN_REASON_UNSPECIFIED,
  				       false, frame_buf);
@@@ -6297,7 -6346,7 +6340,11 @@@ int ieee80211_mgd_deauth(struct ieee802
  	}
  
  	if (ifmgd->associated &&
++<<<<<<< HEAD
 +	    ether_addr_equal(ifmgd->bssid, req->bssid)) {
++=======
+ 	    ether_addr_equal(sdata->vif.cfg.ap_addr, req->bssid)) {
++>>>>>>> b65567b03c95 (wifi: mac80211: mlme: track AP (MLD) address separately)
  		sdata_info(sdata,
  			   "deauthenticating from %pM by local choice (Reason: %u=%s)\n",
  			   req->bssid, req->reason_code,
* Unmerged path include/net/mac80211.h
* Unmerged path net/mac80211/mlme.c
