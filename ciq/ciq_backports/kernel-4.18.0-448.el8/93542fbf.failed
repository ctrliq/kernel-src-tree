scsi: make sure that request queue queiesce and unquiesce balanced

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 93542fbfa7b726d053c01a9399577c03968c4f6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/93542fbf.failed

For fixing queue quiesce race between driver and block layer(elevator
switch, update nr_requests, ...), we need to support concurrent quiesce
and unquiesce, which requires the two call balanced.

It isn't easy to audit that in all scsi drivers, especially the two may
be called from different contexts, so do it in scsi core with one
per-device atomic variable to balance quiesce and unquiesce.

	Reported-by: Yi Zhang <yi.zhang@redhat.com>
Fixes: e70feb8b3e68 ("blk-mq: support concurrent queue quiesce/unquiesce")
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
Link: https://lore.kernel.org/r/20211109071144.181581-4-ming.lei@redhat.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 93542fbfa7b726d053c01a9399577c03968c4f6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/scsi/scsi_device.h
diff --cc include/scsi/scsi_device.h
index bc66c92b6e86,d1c6fc83b1e3..000000000000
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@@ -202,11 -203,12 +202,16 @@@ struct scsi_device 
  	unsigned broken_fua:1;		/* Don't set FUA bit */
  	unsigned lun_in_cdb:1;		/* Store LUN bits in CDB[1] */
  	unsigned unmap_limit_for_ws:1;	/* Use the UNMAP limit for WRITE SAME */
 -	unsigned rpm_autosuspend:1;	/* Enable runtime autosuspend at device
 -					 * creation time */
 -	unsigned ignore_media_change:1; /* Ignore MEDIA CHANGE on resume */
  
++<<<<<<< HEAD
 +	RH_KABI_FILL_HOLE(unsigned set_dbd_for_ms:1) /* Set "DBD" field in mode sense */
 +	RH_KABI_FILL_HOLE(unsigned offline_already:1) /* Device offline message logged */
 +	RH_KABI_FILL_HOLE(unsigned ignore_media_change:1) /* Ignore MEDIA CHANGE on resume */
 +	RH_KABI_FILL_HOLE(unsigned silence_suspend:1)	/* Do not print runtime PM related messages */
++=======
+ 	unsigned int queue_stopped;	/* request queue is quiesced */
+ 	bool offline_already;		/* Device offline message logged */
++>>>>>>> 93542fbfa7b7 (scsi: make sure that request queue queiesce and unquiesce balanced)
  
  	atomic_t disk_events_disable_depth; /* disable depth for disk events */
  
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 212da47dc1b6..b32930c9d4ea 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2667,6 +2667,32 @@ static int __scsi_internal_device_block_nowait(struct scsi_device *sdev)
 	return 0;
 }
 
+void scsi_start_queue(struct scsi_device *sdev)
+{
+	if (cmpxchg(&sdev->queue_stopped, 1, 0))
+		blk_mq_unquiesce_queue(sdev->request_queue);
+}
+
+static void scsi_stop_queue(struct scsi_device *sdev, bool nowait)
+{
+	/*
+	 * The atomic variable of ->queue_stopped covers that
+	 * blk_mq_quiesce_queue* is balanced with blk_mq_unquiesce_queue.
+	 *
+	 * However, we still need to wait until quiesce is done
+	 * in case that queue has been stopped.
+	 */
+	if (!cmpxchg(&sdev->queue_stopped, 0, 1)) {
+		if (nowait)
+			blk_mq_quiesce_queue_nowait(sdev->request_queue);
+		else
+			blk_mq_quiesce_queue(sdev->request_queue);
+	} else {
+		if (!nowait)
+			blk_mq_wait_quiesce_done(sdev->request_queue);
+	}
+}
+
 /**
  * scsi_internal_device_block_nowait - try to transition to the SDEV_BLOCK state
  * @sdev: device to block
@@ -2691,7 +2717,7 @@ int scsi_internal_device_block_nowait(struct scsi_device *sdev)
 	 * request queue.
 	 */
 	if (!ret)
-		blk_mq_quiesce_queue_nowait(sdev->request_queue);
+		scsi_stop_queue(sdev, true);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(scsi_internal_device_block_nowait);
@@ -2718,19 +2744,12 @@ static int scsi_internal_device_block(struct scsi_device *sdev)
 	mutex_lock(&sdev->state_mutex);
 	err = __scsi_internal_device_block_nowait(sdev);
 	if (err == 0)
-		blk_mq_quiesce_queue(sdev->request_queue);
+		scsi_stop_queue(sdev, false);
 	mutex_unlock(&sdev->state_mutex);
 
 	return err;
 }
 
-void scsi_start_queue(struct scsi_device *sdev)
-{
-	struct request_queue *q = sdev->request_queue;
-
-	blk_mq_unquiesce_queue(q);
-}
-
 /**
  * scsi_internal_device_unblock_nowait - resume a device after a block request
  * @sdev:	device to resume
* Unmerged path include/scsi/scsi_device.h
