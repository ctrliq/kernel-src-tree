s390/ap: uevent on apmask/aqpmask change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit d9b38e9d0fd3be59122af56a299f84c951453598
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d9b38e9d.failed

This patch introduces user space notifications for changes
on the apmask or aqmask attributes. So it could be possible
to write a udev rule to load/unload the vfio_ap kernel module
based on changes of these masks.

On chance of the apmask or aqmask an AP change event will
be produced with an uevent environment variable showing
the new APMASK or AQMASK mask.

So a change on the apmask triggers an uvevent like this:

  KERNEL[490.160396] change   /devices/ap (ap)
  ACTION=change
  DEVPATH=/devices/ap
  SUBSYSTEM=ap
  APMASK=0xffffffdfffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  SEQNUM=13367

and a change on the aqmask looks like this:

  KERNEL[283.217642] change   /devices/ap (ap)
  ACTION=change
  DEVPATH=/devices/ap
  SUBSYSTEM=ap
  AQMASK=0xfbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  SEQNUM=13348

Only real changes to the masks are processed - the old and
new masks are compared and no action is done if the values
are equal (and thus no uevent). The emit of the uevent is
the very last action done when a mask change is processed.
However, there is no guarantee that all unbind/bind actions
caused by the apmask/aqmask changes are completed when the
apmask/aqmask change uevent is received in userspace.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Tested-by: Thomas Huth <thuth@redhat.com>
	Reviewed-by: JÃ¼rgen Christ <jchrist@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit d9b38e9d0fd3be59122af56a299f84c951453598)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 2a615a843237,dc37732412d7..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1415,9 -1327,68 +1433,28 @@@ static ssize_t apmask_show(struct bus_t
  static ssize_t apmask_store(struct bus_type *bus, const char *buf,
  			    size_t count)
  {
++<<<<<<< HEAD
 +	int rc;
 +
 +	rc = ap_parse_mask_str(buf, ap_perms.apm, AP_DEVICES, &ap_perms_mutex);
++=======
+ 	int rc, changes = 0;
+ 	DECLARE_BITMAP(newapm, AP_DEVICES);
+ 
+ 	if (mutex_lock_interruptible(&ap_perms_mutex))
+ 		return -ERESTARTSYS;
+ 
+ 	rc = ap_parse_bitmap_str(buf, ap_perms.apm, AP_DEVICES, newapm);
+ 	if (rc)
+ 		goto done;
+ 
+ 	changes = memcmp(ap_perms.apm, newapm, APMASKSIZE);
+ 	if (changes)
+ 		rc = apmask_commit(newapm);
+ 
+ done:
+ 	mutex_unlock(&ap_perms_mutex);
++>>>>>>> d9b38e9d0fd3 (s390/ap: uevent on apmask/aqpmask change)
  	if (rc)
  		return rc;
  
@@@ -1446,9 -1420,68 +1486,28 @@@ static ssize_t aqmask_show(struct bus_t
  static ssize_t aqmask_store(struct bus_type *bus, const char *buf,
  			    size_t count)
  {
++<<<<<<< HEAD
 +	int rc;
 +
 +	rc = ap_parse_mask_str(buf, ap_perms.aqm, AP_DOMAINS, &ap_perms_mutex);
++=======
+ 	int rc, changes = 0;
+ 	DECLARE_BITMAP(newaqm, AP_DOMAINS);
+ 
+ 	if (mutex_lock_interruptible(&ap_perms_mutex))
+ 		return -ERESTARTSYS;
+ 
+ 	rc = ap_parse_bitmap_str(buf, ap_perms.aqm, AP_DOMAINS, newaqm);
+ 	if (rc)
+ 		goto done;
+ 
+ 	changes = memcmp(ap_perms.aqm, newaqm, APMASKSIZE);
+ 	if (changes)
+ 		rc = aqmask_commit(newaqm);
+ 
+ done:
+ 	mutex_unlock(&ap_perms_mutex);
++>>>>>>> d9b38e9d0fd3 (s390/ap: uevent on apmask/aqpmask change)
  	if (rc)
  		return rc;
  
* Unmerged path drivers/s390/crypto/ap_bus.c
