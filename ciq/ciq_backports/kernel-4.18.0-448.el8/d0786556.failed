s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit d0786556caa1a9b63a7bee321546c6cac1e84e96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d0786556.failed

The matrix_dev->lock mutex is being renamed to matrix_dev->mdevs_lock to
better reflect its purpose, which is to control access to the state of the
mediated devices under the control of the vfio_ap device driver.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit d0786556caa1a9b63a7bee321546c6cac1e84e96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index 69b05ef08538,6f091cd602d3..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -278,15 -387,25 +278,26 @@@ static int handle_pqap(struct kvm_vcpu 
  			       .response_code = AP_RESPONSE_Q_NOT_AVAIL, };
  	struct ap_matrix_mdev *matrix_mdev;
  
 -	apqn = vcpu->run->s.regs.gprs[0] & 0xffff;
 -
  	/* If we do not use the AIV facility just go to userland */
 -	if (!(vcpu->arch.sie_block->eca & ECA_AIV)) {
 -		VFIO_AP_DBF_WARN("%s: AIV facility not installed: apqn=0x%04x, eca=0x%04x\n",
 -				 __func__, apqn, vcpu->arch.sie_block->eca);
 -
 +	if (!(vcpu->arch.sie_block->eca & ECA_AIV))
  		return -EOPNOTSUPP;
 -	}
  
++<<<<<<< HEAD
 +	apqn = vcpu->run->s.regs.gprs[0] & 0xffff;
 +	mutex_lock(&matrix_dev->lock);
++=======
+ 	mutex_lock(&matrix_dev->mdevs_lock);
+ 
+ 	if (!vcpu->kvm->arch.crypto.pqap_hook) {
+ 		VFIO_AP_DBF_WARN("%s: PQAP(AQIC) hook not registered with the vfio_ap driver: apqn=0x%04x\n",
+ 				 __func__, apqn);
+ 
+ 		goto out_unlock;
+ 	}
++>>>>>>> d0786556caa1 (s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock)
  
 +	if (!vcpu->kvm->arch.crypto.pqap_hook)
 +		goto out_unlock;
  	matrix_mdev = container_of(vcpu->kvm->arch.crypto.pqap_hook,
  				   struct ap_matrix_mdev, pqap_hook);
  
@@@ -337,31 -527,100 +348,60 @@@ static int vfio_ap_mdev_create(struct k
  
  	matrix_mdev->mdev = mdev;
  	vfio_ap_matrix_init(&matrix_dev->info, &matrix_mdev->matrix);
 +	mdev_set_drvdata(mdev, matrix_mdev);
  	matrix_mdev->pqap_hook = handle_pqap;
++<<<<<<< HEAD
 +	mutex_lock(&matrix_dev->lock);
++=======
+ 	vfio_ap_matrix_init(&matrix_dev->info, &matrix_mdev->shadow_apcb);
+ 	hash_init(matrix_mdev->qtable.queues);
+ 	dev_set_drvdata(&mdev->dev, matrix_mdev);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
++>>>>>>> d0786556caa1 (s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock)
  	list_add(&matrix_mdev->node, &matrix_dev->mdev_list);
- 	mutex_unlock(&matrix_dev->lock);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
  
 -	ret = vfio_register_emulated_iommu_dev(&matrix_mdev->vdev);
 -	if (ret)
 -		goto err_list;
 -	dev_set_drvdata(&mdev->dev, matrix_mdev);
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_list:
+ 	mutex_lock(&matrix_dev->mdevs_lock);
+ 	list_del(&matrix_mdev->node);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
+ 	vfio_uninit_group_dev(&matrix_mdev->vdev);
+ 	kfree(matrix_mdev);
+ err_dec_available:
+ 	atomic_inc(&matrix_dev->available_instances);
+ 	return ret;
++>>>>>>> d0786556caa1 (s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock)
  }
  
 -static void vfio_ap_mdev_link_queue(struct ap_matrix_mdev *matrix_mdev,
 -				    struct vfio_ap_queue *q)
 -{
 -	if (q) {
 -		q->matrix_mdev = matrix_mdev;
 -		hash_add(matrix_mdev->qtable.queues, &q->mdev_qnode, q->apqn);
 -	}
 -}
 -
 -static void vfio_ap_mdev_link_apqn(struct ap_matrix_mdev *matrix_mdev, int apqn)
 +static int vfio_ap_mdev_remove(struct mdev_device *mdev)
  {
 -	struct vfio_ap_queue *q;
 -
 -	q = vfio_ap_find_queue(apqn);
 -	vfio_ap_mdev_link_queue(matrix_mdev, q);
 -}
 -
 -static void vfio_ap_unlink_queue_fr_mdev(struct vfio_ap_queue *q)
 -{
 -	hash_del(&q->mdev_qnode);
 -}
 -
 -static void vfio_ap_unlink_mdev_fr_queue(struct vfio_ap_queue *q)
 -{
 -	q->matrix_mdev = NULL;
 -}
 -
 -static void vfio_ap_mdev_unlink_queue(struct vfio_ap_queue *q)
 -{
 -	vfio_ap_unlink_queue_fr_mdev(q);
 -	vfio_ap_unlink_mdev_fr_queue(q);
 -}
 -
 -static void vfio_ap_mdev_unlink_fr_queues(struct ap_matrix_mdev *matrix_mdev)
 -{
 -	struct vfio_ap_queue *q;
 -	unsigned long apid, apqi;
 -
 -	for_each_set_bit_inv(apid, matrix_mdev->matrix.apm, AP_DEVICES) {
 -		for_each_set_bit_inv(apqi, matrix_mdev->matrix.aqm,
 -				     AP_DOMAINS) {
 -			q = vfio_ap_mdev_get_queue(matrix_mdev,
 -						   AP_MKQID(apid, apqi));
 -			if (q)
 -				q->matrix_mdev = NULL;
 -		}
 -	}
 -}
 -
 -static void vfio_ap_mdev_remove(struct mdev_device *mdev)
 -{
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(&mdev->dev);
 -
 -	vfio_unregister_group_dev(&matrix_mdev->vdev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
++<<<<<<< HEAD
 +	mutex_lock(&matrix_dev->lock);
 +	vfio_ap_mdev_reset_queues(mdev);
 +	list_del(&matrix_mdev->node);
++=======
+ 	mutex_lock(&matrix_dev->mdevs_lock);
+ 	vfio_ap_mdev_reset_queues(matrix_mdev);
+ 	vfio_ap_mdev_unlink_fr_queues(matrix_mdev);
+ 	list_del(&matrix_mdev->node);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
+ 	vfio_uninit_group_dev(&matrix_mdev->vdev);
++>>>>>>> d0786556caa1 (s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock)
  	kfree(matrix_mdev);
 +	mdev_set_drvdata(mdev, NULL);
  	atomic_inc(&matrix_dev->available_instances);
 +	mutex_unlock(&matrix_dev->lock);
 +
 +	return 0;
  }
  
 -static ssize_t name_show(struct mdev_type *mtype,
 -			 struct mdev_type_attribute *attr, char *buf)
 +static ssize_t name_show(struct kobject *kobj, struct device *dev, char *buf)
  {
  	return sprintf(buf, "%s\n", VFIO_AP_MDEV_NAME_HWVIRT);
  }
@@@ -596,10 -785,11 +636,10 @@@ static ssize_t assign_adapter_store(str
  {
  	int ret;
  	unsigned long apid;
 -	DECLARE_BITMAP(apm_delta, AP_DEVICES);
 -
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  
  	/* If the KVM guest is running, disallow assignment of adapter */
  	if (matrix_mdev->kvm) {
@@@ -616,28 -806,22 +656,28 @@@
  		goto done;
  	}
  
 +	/*
 +	 * Set the bit in the AP mask (APM) corresponding to the AP adapter
 +	 * number (APID). The bits in the mask, from most significant to least
 +	 * significant bit, correspond to APIDs 0-255.
 +	 */
 +	ret = vfio_ap_mdev_verify_queues_reserved_for_apid(matrix_mdev, apid);
 +	if (ret)
 +		goto done;
 +
  	set_bit_inv(apid, matrix_mdev->matrix.apm);
  
 -	ret = vfio_ap_mdev_validate_masks(matrix_mdev);
 -	if (ret) {
 -		clear_bit_inv(apid, matrix_mdev->matrix.apm);
 -		goto done;
 -	}
 +	ret = vfio_ap_mdev_verify_no_sharing(matrix_mdev);
 +	if (ret)
 +		goto share_err;
  
 -	vfio_ap_mdev_link_adapter(matrix_mdev, apid);
 -	memset(apm_delta, 0, sizeof(apm_delta));
 -	set_bit_inv(apid, apm_delta);
 -	vfio_ap_mdev_filter_matrix(apm_delta,
 -				   matrix_mdev->matrix.aqm, matrix_mdev);
  	ret = count;
 +	goto done;
 +
 +share_err:
 +	clear_bit_inv(apid, matrix_mdev->matrix.apm);
  done:
- 	mutex_unlock(&matrix_dev->lock);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
  
  	return ret;
  }
@@@ -664,10 -862,9 +704,10 @@@ static ssize_t unassign_adapter_store(s
  {
  	int ret;
  	unsigned long apid;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  
  	/* If the KVM guest is running, disallow unassignment of adapter */
  	if (matrix_mdev->kvm) {
@@@ -685,9 -882,14 +725,9 @@@
  	}
  
  	clear_bit_inv((unsigned long)apid, matrix_mdev->matrix.apm);
 -	vfio_ap_mdev_unlink_adapter(matrix_mdev, apid);
 -
 -	if (test_bit_inv(apid, matrix_mdev->shadow_apcb.apm))
 -		clear_bit_inv(apid, matrix_mdev->shadow_apcb.apm);
 -
  	ret = count;
  done:
- 	mutex_unlock(&matrix_dev->lock);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(unassign_adapter);
@@@ -748,11 -940,11 +788,11 @@@ static ssize_t assign_domain_store(stru
  {
  	int ret;
  	unsigned long apqi;
 -	DECLARE_BITMAP(aqm_delta, AP_DOMAINS);
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  	unsigned long max_apqi = matrix_mdev->matrix.aqm_max;
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  
  	/* If the KVM guest is running, disallow assignment of domain */
  	if (matrix_mdev->kvm) {
@@@ -768,23 -960,22 +808,23 @@@
  		goto done;
  	}
  
 +	ret = vfio_ap_mdev_verify_queues_reserved_for_apqi(matrix_mdev, apqi);
 +	if (ret)
 +		goto done;
 +
  	set_bit_inv(apqi, matrix_mdev->matrix.aqm);
  
 -	ret = vfio_ap_mdev_validate_masks(matrix_mdev);
 -	if (ret) {
 -		clear_bit_inv(apqi, matrix_mdev->matrix.aqm);
 -		goto done;
 -	}
 +	ret = vfio_ap_mdev_verify_no_sharing(matrix_mdev);
 +	if (ret)
 +		goto share_err;
  
 -	vfio_ap_mdev_link_domain(matrix_mdev, apqi);
 -	memset(aqm_delta, 0, sizeof(aqm_delta));
 -	set_bit_inv(apqi, aqm_delta);
 -	vfio_ap_mdev_filter_matrix(matrix_mdev->matrix.apm, aqm_delta,
 -				   matrix_mdev);
  	ret = count;
 +	goto done;
 +
 +share_err:
 +	clear_bit_inv(apqi, matrix_mdev->matrix.aqm);
  done:
- 	mutex_unlock(&matrix_dev->lock);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
  
  	return ret;
  }
@@@ -812,10 -1016,9 +852,10 @@@ static ssize_t unassign_domain_store(st
  {
  	int ret;
  	unsigned long apqi;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  
  	/* If the KVM guest is running, disallow unassignment of domain */
  	if (matrix_mdev->kvm) {
@@@ -861,10 -1069,9 +901,10 @@@ static ssize_t assign_control_domain_st
  {
  	int ret;
  	unsigned long id;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  
  	/* If the KVM guest is running, disallow assignment of control domain */
  	if (matrix_mdev->kvm) {
@@@ -887,9 -1094,10 +927,9 @@@
  	 * number of control domains that can be assigned.
  	 */
  	set_bit_inv(id, matrix_mdev->matrix.adm);
 -	vfio_ap_mdev_filter_cdoms(matrix_mdev);
  	ret = count;
  done:
- 	mutex_unlock(&matrix_dev->lock);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(assign_control_domain);
@@@ -914,11 -1122,10 +954,11 @@@ static ssize_t unassign_control_domain_
  {
  	int ret;
  	unsigned long domid;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  	unsigned long max_domid =  matrix_mdev->matrix.adm_max;
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  
  	/* If a KVM guest is running, disallow unassignment of control domain */
  	if (matrix_mdev->kvm) {
@@@ -935,9 -1142,13 +975,9 @@@
  	}
  
  	clear_bit_inv(domid, matrix_mdev->matrix.adm);
 -
 -	if (test_bit_inv(domid, matrix_mdev->shadow_apcb.adm))
 -		clear_bit_inv(domid, matrix_mdev->shadow_apcb.adm);
 -
  	ret = count;
  done:
- 	mutex_unlock(&matrix_dev->lock);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
  	return ret;
  }
  static DEVICE_ATTR_WO(unassign_control_domain);
@@@ -950,11 -1161,10 +990,11 @@@ static ssize_t control_domains_show(str
  	int nchars = 0;
  	int n;
  	char *bufpos = buf;
 -	struct ap_matrix_mdev *matrix_mdev = dev_get_drvdata(dev);
 +	struct mdev_device *mdev = mdev_from_dev(dev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  	unsigned long max_domid = matrix_mdev->matrix.adm_max;
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  	for_each_set_bit_inv(id, matrix_mdev->matrix.adm, max_domid + 1) {
  		n = sprintf(bufpos, "%04lx\n", id);
  		bufpos += n;
@@@ -1077,13 -1279,12 +1117,13 @@@ static int vfio_ap_mdev_set_kvm(struct 
  
  		kvm_get_kvm(kvm);
  		matrix_mdev->kvm = kvm;
 -		kvm_arch_crypto_set_masks(kvm, matrix_mdev->shadow_apcb.apm,
 -					  matrix_mdev->shadow_apcb.aqm,
 -					  matrix_mdev->shadow_apcb.adm);
 +		kvm_arch_crypto_set_masks(kvm,
 +					  matrix_mdev->matrix.apm,
 +					  matrix_mdev->matrix.aqm,
 +					  matrix_mdev->matrix.adm);
  
  		mutex_unlock(&kvm->lock);
- 		mutex_unlock(&matrix_dev->lock);
+ 		mutex_unlock(&matrix_dev->mdevs_lock);
  	}
  
  	return 0;
@@@ -1142,10 -1336,10 +1182,10 @@@ static void vfio_ap_mdev_unset_kvm(stru
  		up_write(&kvm->arch.crypto.pqap_hook_rwsem);
  
  		mutex_lock(&kvm->lock);
- 		mutex_lock(&matrix_dev->lock);
+ 		mutex_lock(&matrix_dev->mdevs_lock);
  
  		kvm_arch_crypto_clear_masks(kvm);
 -		vfio_ap_mdev_reset_queues(matrix_mdev);
 +		vfio_ap_mdev_reset_queues(matrix_mdev->mdev);
  		kvm_put_kvm(kvm);
  		matrix_mdev->kvm = NULL;
  
@@@ -1330,16 -1489,17 +1370,16 @@@ static int vfio_ap_mdev_get_device_info
  	info.num_regions = 0;
  	info.num_irqs = 0;
  
 -	return copy_to_user((void __user *)arg, &info, minsz) ? -EFAULT : 0;
 +	return copy_to_user((void __user *)arg, &info, minsz);
  }
  
 -static ssize_t vfio_ap_mdev_ioctl(struct vfio_device *vdev,
 +static ssize_t vfio_ap_mdev_ioctl(struct mdev_device *mdev,
  				    unsigned int cmd, unsigned long arg)
  {
 -	struct ap_matrix_mdev *matrix_mdev =
 -		container_of(vdev, struct ap_matrix_mdev, vdev);
  	int ret;
 +	struct ap_matrix_mdev *matrix_mdev;
  
- 	mutex_lock(&matrix_dev->lock);
+ 	mutex_lock(&matrix_dev->mdevs_lock);
  	switch (cmd) {
  	case VFIO_DEVICE_GET_INFO:
  		ret = vfio_ap_mdev_get_device_info(arg);
@@@ -1362,15 -1516,78 +1402,90 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static const struct mdev_parent_ops vfio_ap_matrix_ops = {
 +	.owner			= THIS_MODULE,
 +	.supported_type_groups	= vfio_ap_mdev_type_groups,
 +	.mdev_attr_groups	= vfio_ap_mdev_attr_groups,
 +	.create			= vfio_ap_mdev_create,
 +	.remove			= vfio_ap_mdev_remove,
 +	.open			= vfio_ap_mdev_open,
 +	.release		= vfio_ap_mdev_release,
 +	.ioctl			= vfio_ap_mdev_ioctl,
++=======
+ static struct ap_matrix_mdev *vfio_ap_mdev_for_queue(struct vfio_ap_queue *q)
+ {
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 	unsigned long apid = AP_QID_CARD(q->apqn);
+ 	unsigned long apqi = AP_QID_QUEUE(q->apqn);
+ 
+ 	list_for_each_entry(matrix_mdev, &matrix_dev->mdev_list, node) {
+ 		if (test_bit_inv(apid, matrix_mdev->matrix.apm) &&
+ 		    test_bit_inv(apqi, matrix_mdev->matrix.aqm))
+ 			return matrix_mdev;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static ssize_t status_show(struct device *dev,
+ 			   struct device_attribute *attr,
+ 			   char *buf)
+ {
+ 	ssize_t nchars = 0;
+ 	struct vfio_ap_queue *q;
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 	struct ap_device *apdev = to_ap_dev(dev);
+ 
+ 	mutex_lock(&matrix_dev->mdevs_lock);
+ 	q = dev_get_drvdata(&apdev->device);
+ 	matrix_mdev = vfio_ap_mdev_for_queue(q);
+ 
+ 	if (matrix_mdev) {
+ 		if (matrix_mdev->kvm)
+ 			nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
+ 					   AP_QUEUE_IN_USE);
+ 		else
+ 			nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
+ 					   AP_QUEUE_ASSIGNED);
+ 	} else {
+ 		nchars = scnprintf(buf, PAGE_SIZE, "%s\n",
+ 				   AP_QUEUE_UNASSIGNED);
+ 	}
+ 
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
+ 
+ 	return nchars;
+ }
+ 
+ static DEVICE_ATTR_RO(status);
+ 
+ static struct attribute *vfio_queue_attrs[] = {
+ 	&dev_attr_status.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group vfio_queue_attr_group = {
+ 	.attrs = vfio_queue_attrs,
+ };
+ 
+ static const struct vfio_device_ops vfio_ap_matrix_dev_ops = {
+ 	.open_device = vfio_ap_mdev_open_device,
+ 	.close_device = vfio_ap_mdev_close_device,
+ 	.ioctl = vfio_ap_mdev_ioctl,
+ };
+ 
+ static struct mdev_driver vfio_ap_matrix_driver = {
+ 	.driver = {
+ 		.name = "vfio_ap_mdev",
+ 		.owner = THIS_MODULE,
+ 		.mod_name = KBUILD_MODNAME,
+ 		.dev_groups = vfio_ap_mdev_attr_groups,
+ 	},
+ 	.probe = vfio_ap_mdev_probe,
+ 	.remove = vfio_ap_mdev_remove,
+ 	.supported_type_groups = vfio_ap_mdev_type_groups,
++>>>>>>> d0786556caa1 (s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock)
  };
  
  int vfio_ap_mdev_register(void)
@@@ -1383,4 -1613,78 +1498,81 @@@
  void vfio_ap_mdev_unregister(void)
  {
  	mdev_unregister_device(&matrix_dev->device);
++<<<<<<< HEAD
++=======
+ 	mdev_unregister_driver(&vfio_ap_matrix_driver);
+ }
+ 
+ /*
+  * vfio_ap_queue_link_mdev
+  *
+  * @q: The queue to link with the matrix mdev.
+  *
+  * Links @q with the matrix mdev to which the queue's APQN is assigned.
+  */
+ static void vfio_ap_queue_link_mdev(struct vfio_ap_queue *q)
+ {
+ 	unsigned long apid = AP_QID_CARD(q->apqn);
+ 	unsigned long apqi = AP_QID_QUEUE(q->apqn);
+ 	struct ap_matrix_mdev *matrix_mdev;
+ 
+ 	list_for_each_entry(matrix_mdev, &matrix_dev->mdev_list, node) {
+ 		if (test_bit_inv(apid, matrix_mdev->matrix.apm) &&
+ 		    test_bit_inv(apqi, matrix_mdev->matrix.aqm)) {
+ 			vfio_ap_mdev_link_queue(matrix_mdev, q);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ int vfio_ap_mdev_probe_queue(struct ap_device *apdev)
+ {
+ 	int ret;
+ 	struct vfio_ap_queue *q;
+ 
+ 	ret = sysfs_create_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	if (ret)
+ 		return ret;
+ 
+ 	q = kzalloc(sizeof(*q), GFP_KERNEL);
+ 	if (!q)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&matrix_dev->mdevs_lock);
+ 	q->apqn = to_ap_queue(&apdev->device)->qid;
+ 	q->saved_isc = VFIO_AP_ISC_INVALID;
+ 	vfio_ap_queue_link_mdev(q);
+ 	if (q->matrix_mdev) {
+ 		vfio_ap_mdev_filter_matrix(q->matrix_mdev->matrix.apm,
+ 					   q->matrix_mdev->matrix.aqm,
+ 					   q->matrix_mdev);
+ 	}
+ 	dev_set_drvdata(&apdev->device, q);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
+ 
+ 	return 0;
+ }
+ 
+ void vfio_ap_mdev_remove_queue(struct ap_device *apdev)
+ {
+ 	unsigned long apid;
+ 	struct vfio_ap_queue *q;
+ 
+ 	mutex_lock(&matrix_dev->mdevs_lock);
+ 	sysfs_remove_group(&apdev->device.kobj, &vfio_queue_attr_group);
+ 	q = dev_get_drvdata(&apdev->device);
+ 
+ 	if (q->matrix_mdev) {
+ 		vfio_ap_unlink_queue_fr_mdev(q);
+ 
+ 		apid = AP_QID_CARD(q->apqn);
+ 		if (test_bit_inv(apid, q->matrix_mdev->shadow_apcb.apm))
+ 			clear_bit_inv(apid, q->matrix_mdev->shadow_apcb.apm);
+ 	}
+ 
+ 	vfio_ap_mdev_reset_queue(q, 1);
+ 	dev_set_drvdata(&apdev->device, NULL);
+ 	kfree(q);
+ 	mutex_unlock(&matrix_dev->mdevs_lock);
++>>>>>>> d0786556caa1 (s390/vfio-ap: rename matrix_dev->lock mutex to matrix_dev->mdevs_lock)
  }
diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index 9c7986bc5344..bb5497436088 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -212,7 +212,7 @@ static int vfio_ap_matrix_dev_create(void)
 			goto matrix_alloc_err;
 	}
 
-	mutex_init(&matrix_dev->lock);
+	mutex_init(&matrix_dev->mdevs_lock);
 	INIT_LIST_HEAD(&matrix_dev->mdev_list);
 
 	dev_set_name(&matrix_dev->device, "%s", VFIO_AP_DEV_NAME);
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
diff --git a/drivers/s390/crypto/vfio_ap_private.h b/drivers/s390/crypto/vfio_ap_private.h
index 2b06b4ffd2fd..7b1b7cc23a0b 100644
--- a/drivers/s390/crypto/vfio_ap_private.h
+++ b/drivers/s390/crypto/vfio_ap_private.h
@@ -31,7 +31,7 @@
  * @available_instances: number of mediated matrix devices that can be created
  * @info:	the struct containing the output from the PQAP(QCI) instruction
  * @mdev_list:	the list of mediated matrix devices created
- * @lock:	mutex for locking the AP matrix device. This lock will be
+ * @mdevs_lock: mutex for locking the AP matrix device. This lock will be
  *		taken every time we fiddle with state managed by the vfio_ap
  *		driver, be it using @mdev_list or writing the state of a
  *		single ap_matrix_mdev device. It's quite coarse but we don't
@@ -43,7 +43,7 @@ struct ap_matrix_dev {
 	atomic_t available_instances;
 	struct ap_config_info info;
 	struct list_head mdev_list;
-	struct mutex lock;
+	struct mutex mdevs_lock; /* serializes access to each ap_matrix_mdev */
 	struct ap_driver  *vfio_ap_drv;
 };
 
