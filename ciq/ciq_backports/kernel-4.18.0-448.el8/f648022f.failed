NFS: Convert readdir page cache to use a cookie based index

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit f648022faa68ef76058aa121d1aa3a967d59cae8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f648022f.failed

Instead of using a linear index to address the pages, use the cookie of
the first entry, since that is what we use to match the page anyway.

This allows us to avoid re-reading the entire cache on a seekdir() type
of operation. The latter is very common when re-exporting NFS, and is a
major performance drain.

The change does affect our duplicate cookie detection, since we can no
longer rely on the page index as a linear offset for detecting whether
we looped backwards. However since we no longer do a linear search
through all the pages on each call to nfs_readdir(), this is less of a
concern than it was previously.
The other downside is that invalidate_mapping_pages() no longer can use
the page index to avoid clearing pages that have been read. A subsequent
patch will restore the functionality this provides to the 'ls -l'
heuristic.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit f648022faa68ef76058aa121d1aa3a967d59cae8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/dir.c
#	include/linux/nfs_fs.h
diff --cc fs/nfs/dir.c
index ce0607cf0a27,8c2552d89310..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -155,11 -157,10 +156,9 @@@ struct nfs_readdir_descriptor 
  	struct page	*page;
  	struct dir_context *ctx;
  	pgoff_t		page_index;
 -	pgoff_t		page_index_max;
  	u64		dir_cookie;
  	u64		last_cookie;
- 	u64		dup_cookie;
  	loff_t		current_index;
- 	loff_t		prev_index;
  
  	__be32		verf[NFS_DIR_VERIFIER_SIZE];
  	unsigned long	dir_verifier;
@@@ -167,7 -168,8 +166,12 @@@
  	unsigned long	gencount;
  	unsigned long	attr_gencount;
  	unsigned int	cache_entry_index;
++<<<<<<< HEAD
 +	signed char duped;
++=======
+ 	unsigned int	buffer_fills;
+ 	unsigned int	dtsize;
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  	bool plus;
  	bool eob;
  	bool eof;
@@@ -882,27 -919,21 +886,42 @@@ static int nfs_readdir_xdr_to_array(str
  	if (!pages)
  		goto out;
  
++<<<<<<< HEAD
 +	do {
 +		unsigned int pglen;
 +		status = nfs_readdir_xdr_filler(desc, verf_arg, entry->cookie,
 +						pages, dtsize,
 +						verf_res);
 +		if (status < 0)
 +			break;
 +
 +		pglen = status;
 +		if (pglen == 0) {
 +			nfs_readdir_page_set_eof(page);
 +			break;
 +		}
 +
 +		verf_arg = verf_res;
++=======
+ 	change_attr = inode_peek_iversion_raw(inode);
+ 	status = nfs_readdir_xdr_filler(desc, verf_arg, entry->cookie, pages,
+ 					dtsize, verf_res);
+ 	if (status < 0)
+ 		goto free_pages;
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  
 -	pglen = status;
 -	if (pglen != 0)
  		status = nfs_readdir_page_filler(desc, entry, pages, pglen,
++<<<<<<< HEAD
 +						 arrays, narrays);
 +	} while (!status && nfs_readdir_page_needs_filling(page) &&
 +		page_mapping(page));
++=======
+ 						 arrays, narrays, change_attr);
+ 	else
+ 		nfs_readdir_page_set_eof(page);
+ 	desc->buffer_fills++;
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  
 -free_pages:
  	nfs_readdir_free_pages(pages, array_size);
  out:
  	nfs_free_fattr(entry->fattr);
@@@ -951,9 -991,12 +972,15 @@@ static int find_and_lock_cache_page(str
  					       &desc->page, 1);
  		if (res < 0) {
  			nfs_readdir_page_unlock_and_put_cached(desc);
 -			trace_nfs_readdir_cache_fill_done(inode, res);
  			if (res == -EBADCOOKIE || res == -ENOTSYNC) {
  				invalidate_inode_pages2(desc->file->f_mapping);
++<<<<<<< HEAD
 +				desc->page_index = 0;
++=======
+ 				nfs_readdir_rewind_search(desc);
+ 				trace_nfs_readdir_invalidate_cache_range(
+ 					inode, 0, MAX_LFS_FILESIZE);
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  				return -EAGAIN;
  			}
  			return res;
@@@ -965,9 -1008,10 +992,13 @@@
  		    memcmp(nfsi->cookieverf, verf, sizeof(nfsi->cookieverf))) {
  			memcpy(nfsi->cookieverf, verf,
  			       sizeof(nfsi->cookieverf));
- 			invalidate_inode_pages2_range(desc->file->f_mapping,
- 						      desc->page_index_max + 1,
+ 			invalidate_inode_pages2_range(desc->file->f_mapping, 1,
  						      -1);
++<<<<<<< HEAD
++=======
+ 			trace_nfs_readdir_invalidate_cache_range(
+ 				inode, 1, MAX_LFS_FILESIZE);
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  		}
  	}
  	res = nfs_readdir_search_array(desc);
@@@ -1068,9 -1105,16 +1092,16 @@@ static int uncached_readdir(struct nfs_
  	desc->page_index = 0;
  	desc->cache_entry_index = 0;
  	desc->last_cookie = desc->dir_cookie;
++<<<<<<< HEAD
 +	desc->duped = 0;
++=======
+ 	desc->page_index_max = 0;
+ 
+ 	trace_nfs_readdir_uncached(desc->file, desc->verf, desc->last_cookie,
+ 				   -1, desc->dtsize);
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  
  	status = nfs_readdir_xdr_to_array(desc, desc->verf, verf, arrays, sz);
 -	if (status < 0) {
 -		trace_nfs_readdir_uncached_done(file_inode(desc->file), status);
 -		goto out_free;
 -	}
  
  	for (i = 0; !desc->eob && i < sz && arrays[i]; i++) {
  		desc->page = arrays[i];
@@@ -1082,11 -1137,28 +1113,34 @@@
  	for (i = 0; i < sz && arrays[i]; i++)
  		nfs_readdir_page_array_free(arrays[i]);
  out:
++<<<<<<< HEAD
++=======
+ 	if (!nfs_readdir_use_cookie(desc->file))
+ 		nfs_readdir_rewind_search(desc);
+ 	desc->page_index_max = -1;
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  	kfree(arrays);
  	dfprintk(DIRCACHE, "NFS: %s: returns %d\n", __func__, status);
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ #define NFS_READDIR_CACHE_MISS_THRESHOLD (16UL)
+ 
+ static void nfs_readdir_handle_cache_misses(struct inode *inode,
+ 					    struct nfs_readdir_descriptor *desc,
+ 					    unsigned int cache_misses)
+ {
+ 	if (desc->ctx->pos == 0 ||
+ 	    cache_misses <= NFS_READDIR_CACHE_MISS_THRESHOLD)
+ 		return;
+ 	if (invalidate_mapping_pages(inode->i_mapping, 0, -1) == 0)
+ 		return;
+ 	trace_nfs_readdir_invalidate_cache_range(inode, 0, MAX_LFS_FILESIZE);
+ }
+ 
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  /* The file offset position represents the dirent entry number.  A
     last cookie cache takes care of the common case of reading the
     whole directory.
@@@ -1098,7 -1170,7 +1152,11 @@@ static int nfs_readdir(struct file *fil
  	struct nfs_inode *nfsi = NFS_I(inode);
  	struct nfs_open_dir_context *dir_ctx = file->private_data;
  	struct nfs_readdir_descriptor *desc;
++<<<<<<< HEAD
 +	pgoff_t page_index;
++=======
+ 	unsigned int cache_hits, cache_misses;
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  	int res;
  
  	dfprintk(FILE, "NFS: readdir(%pD2) starting at cookie %llu\n",
@@@ -1138,9 -1210,8 +1193,14 @@@
  		goto out_free;
  	}
  
++<<<<<<< HEAD
 +	if (test_and_clear_bit(NFS_INO_FORCE_READDIR, &nfsi->flags) &&
 +	    list_is_singular(&nfsi->open_files))
 +		invalidate_mapping_pages(inode->i_mapping, page_index + 1, -1);
++=======
+ 	desc->plus = nfs_use_readdirplus(inode, ctx, cache_hits, cache_misses);
+ 	nfs_readdir_handle_cache_misses(inode, desc, cache_misses);
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  
  	do {
  		res = readdir_search_pagecache(desc);
@@@ -1159,9 -1230,7 +1219,8 @@@
  			break;
  		}
  		if (res == -ETOOSMALL && desc->plus) {
 +			clear_bit(NFS_INO_ADVISE_RDPLUS, &nfsi->flags);
  			nfs_zap_caches(inode);
- 			desc->page_index = 0;
  			desc->plus = false;
  			desc->eof = false;
  			continue;
diff --cc include/linux/nfs_fs.h
index f07136abc22c,42aad886d3c0..000000000000
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@@ -102,11 -104,13 +102,14 @@@ struct nfs_open_dir_context 
  	unsigned long attr_gencount;
  	__be32	verf[NFS_DIR_VERIFIER_SIZE];
  	__u64 dir_cookie;
- 	__u64 dup_cookie;
  	__u64 last_cookie;
  	pgoff_t page_index;
++<<<<<<< HEAD
 +	signed char duped;
++=======
+ 	unsigned int dtsize;
++>>>>>>> f648022faa68 (NFS: Convert readdir page cache to use a cookie based index)
  	bool eof;
 -	struct rcu_head rcu_head;
  };
  
  /*
diff --git a/fs/nfs/Kconfig b/fs/nfs/Kconfig
index 3204c00c6449..9555178d0702 100644
--- a/fs/nfs/Kconfig
+++ b/fs/nfs/Kconfig
@@ -3,6 +3,10 @@ config NFS_FS
 	depends on INET && FILE_LOCKING && MULTIUSER
 	select LOCKD
 	select SUNRPC
+	select CRYPTO
+	select CRYPTO_HASH
+	select XXHASH
+	select CRYPTO_XXHASH
 	select NFS_ACL_SUPPORT if NFS_V3_ACL
 	help
 	  Choose Y here if you want to access files residing on other
* Unmerged path fs/nfs/dir.c
* Unmerged path include/linux/nfs_fs.h
