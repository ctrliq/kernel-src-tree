wifi: mac80211: mlme: refactor ieee80211_set_associated()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 5d3a341c0dd21f14eb97cea3754621d8aa1637de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/5d3a341c.failed

Split out much of the code in ieee80211_set_associated()
into a new ieee80211_link_set_associated() which can be
called per link later for MLO.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 5d3a341c0dd21f14eb97cea3754621d8aa1637de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,308a8fe50212..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -2289,28 -2388,27 +2289,46 @@@ static u32 ieee80211_handle_bss_capabil
  	return changed;
  }
  
- static void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,
- 				     struct cfg80211_bss *cbss,
- 				     u32 bss_info_changed)
+ static u32 ieee80211_link_set_associated(struct ieee80211_link_data *link,
+ 					 struct cfg80211_bss *cbss)
  {
++<<<<<<< HEAD
 +	struct ieee80211_bss *bss = (void *)cbss->priv;
 +	struct ieee80211_local *local = sdata->local;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_bss_conf *bss_conf = link->conf;
+ 	struct ieee80211_bss *bss = (void *)cbss->priv;
+ 	u32 changed = 0;
++>>>>>>> 5d3a341c0dd2 (wifi: mac80211: mlme: refactor ieee80211_set_associated())
  
- 	bss_info_changed |= BSS_CHANGED_ASSOC;
- 	bss_info_changed |= ieee80211_handle_bss_capability(link,
- 		bss_conf->assoc_capability, bss->has_erp_value, bss->erp_value);
+ 	sdata->u.mgd.beacon_timeout =
+ 		usecs_to_jiffies(ieee80211_tu_to_usec(beacon_loss_count *
+ 						      bss_conf->beacon_int));
  
++<<<<<<< HEAD
 +	sdata->u.mgd.beacon_timeout = usecs_to_jiffies(ieee80211_tu_to_usec(
 +		beacon_loss_count * bss_conf->beacon_int));
 +
 +	sdata->u.mgd.associated = true;
 +	sdata->u.mgd.assoc_bss = cbss;
 +	memcpy(sdata->u.mgd.bssid, cbss->bssid, ETH_ALEN);
 +
 +	ieee80211_check_rate_mask(link);
 +
 +	sdata->u.mgd.flags |= IEEE80211_STA_RESET_SIGNAL_AVE;
++=======
+ 	changed |= ieee80211_handle_bss_capability(link,
+ 						   bss_conf->assoc_capability,
+ 						   bss->has_erp_value,
+ 						   bss->erp_value);
+ 
+ 	ieee80211_check_rate_mask(link);
+ 
+ 	link->u.mgd.bss = cbss;
+ 	memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
++>>>>>>> 5d3a341c0dd2 (wifi: mac80211: mlme: refactor ieee80211_set_associated())
  
  	if (sdata->vif.p2p ||
  	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
@@@ -2327,43 -2425,60 +2345,74 @@@
  					(u8 *) &bss_conf->p2p_noa_attr,
  					sizeof(bss_conf->p2p_noa_attr));
  			if (ret >= 2) {
 -				link->u.mgd.p2p_noa_index =
 +				sdata->u.mgd.p2p_noa_index =
  					bss_conf->p2p_noa_attr.index;
- 				bss_info_changed |= BSS_CHANGED_P2P_PS;
+ 				changed |= BSS_CHANGED_P2P_PS;
  			}
  		}
  		rcu_read_unlock();
  	}
  
++<<<<<<< HEAD
 +	/* just to be sure */
 +	ieee80211_stop_poll(sdata);
 +
 +	ieee80211_led_assoc(local, 1);
 +
 +	if (sdata->u.mgd.have_beacon) {
++=======
+ 	if (link->u.mgd.have_beacon) {
++>>>>>>> 5d3a341c0dd2 (wifi: mac80211: mlme: refactor ieee80211_set_associated())
  		/*
  		 * If the AP is buggy we may get here with no DTIM period
  		 * known, so assume it's 1 which is the only safe assumption
  		 * in that case, although if the TIM IE is broken powersave
  		 * probably just won't work at all.
  		 */
 -		bss_conf->dtim_period = link->u.mgd.dtim_period ?: 1;
 +		bss_conf->dtim_period = sdata->u.mgd.dtim_period ?: 1;
  		bss_conf->beacon_rate = bss->beacon_rate;
- 		bss_info_changed |= BSS_CHANGED_BEACON_INFO;
+ 		changed |= BSS_CHANGED_BEACON_INFO;
  	} else {
  		bss_conf->beacon_rate = NULL;
  		bss_conf->dtim_period = 0;
  	}
  
++<<<<<<< HEAD
 +	bss_conf->assoc = 1;
 +
++=======
++>>>>>>> 5d3a341c0dd2 (wifi: mac80211: mlme: refactor ieee80211_set_associated())
  	/* Tell the driver to monitor connection quality (if supported) */
  	if (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI &&
  	    bss_conf->cqm_rssi_thold)
- 		bss_info_changed |= BSS_CHANGED_CQM;
+ 		changed |= BSS_CHANGED_CQM;
+ 
+ 	return changed;
+ }
+ 
+ static void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,
+ 				     struct cfg80211_bss *cbss,
+ 				     u32 bss_info_changed)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
+ 
+ 	bss_info_changed |= BSS_CHANGED_ASSOC;
+ 	bss_info_changed |= ieee80211_link_set_associated(link, cbss);
+ 
+ 	sdata->u.mgd.associated = true;
+ 	memcpy(sdata->vif.cfg.ap_addr, cbss->bssid, ETH_ALEN);
+ 
+ 	/* just to be sure */
+ 	ieee80211_stop_poll(sdata);
+ 
+ 	ieee80211_led_assoc(local, 1);
+ 
+ 	vif_cfg->assoc = 1;
  
  	/* Enable ARP filtering */
 -	if (vif_cfg->arp_addr_cnt)
 +	if (bss_conf->arp_addr_cnt)
  		bss_info_changed |= BSS_CHANGED_ARP_FILTER;
  
  	ieee80211_bss_info_change_notify(sdata, bss_info_changed);
* Unmerged path net/mac80211/mlme.c
