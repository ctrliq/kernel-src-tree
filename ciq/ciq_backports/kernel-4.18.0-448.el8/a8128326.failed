net/mlx5e: Use multi table support for CT and sample actions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Roi Dayan <roid@nvidia.com>
commit a81283263bb0c38b52fce6d599c2434a8d232dd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a8128326.failed

CT and sample actions use post actions for their implementation.
Flag those actions as multi table actions so the post act infrastructure
will handle the post actions allocation.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a81283263bb0c38b52fce6d599c2434a8d232dd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
index efc81bec5b80,32abc91adf23..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
@@@ -126,7 -126,7 +126,11 @@@ mlx5e_tc_post_act_add(struct mlx5e_post
  	post_attr->ft = post_act->ft;
  	post_attr->inner_match_level = MLX5_MATCH_NONE;
  	post_attr->outer_match_level = MLX5_MATCH_NONE;
++<<<<<<< HEAD
 +	post_attr->action &= ~(MLX5_FLOW_CONTEXT_ACTION_DECAP);
++=======
+ 	post_attr->action &= ~MLX5_FLOW_CONTEXT_ACTION_DECAP;
++>>>>>>> a81283263bb0 (net/mlx5e: Use multi table support for CT and sample actions)
  
  	handle->ns_type = post_act->ns_type;
  	/* Splits were handled before post action */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c
index ff4b4f8a5a9d,fd4504518578..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c
@@@ -492,10 -467,8 +467,9 @@@ del_post_rule(struct mlx5_eswitch *esw
  struct mlx5_flow_handle *
  mlx5e_tc_sample_offload(struct mlx5e_tc_psample *tc_psample,
  			struct mlx5_flow_spec *spec,
 -			struct mlx5_flow_attr *attr)
 +			struct mlx5_flow_attr *attr,
 +			u32 tunnel_id)
  {
- 	struct mlx5e_post_act_handle *post_act_handle = NULL;
  	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
  	struct mlx5_esw_flow_attr *pre_esw_attr;
  	struct mlx5_mapped_obj restore_obj = {};
@@@ -528,12 -502,6 +502,15 @@@
  
  		ft = mlx5e_tc_post_act_get_ft(tc_psample->post_act);
  		default_tbl_id = ft->id;
++<<<<<<< HEAD
 +		post_act_handle = mlx5e_tc_post_act_add(tc_psample->post_act, attr);
 +		if (IS_ERR(post_act_handle)) {
 +			err = PTR_ERR(post_act_handle);
 +			goto err_post_act;
 +		}
 +		sample_flow->post_act_handle = post_act_handle;
++=======
++>>>>>>> a81283263bb0 (net/mlx5e: Use multi table support for CT and sample actions)
  	} else {
  		err = add_post_rule(esw, sample_flow, spec, attr, &default_tbl_id);
  		if (err)
@@@ -585,8 -555,8 +563,13 @@@
  	pre_attr->outer_match_level = attr->outer_match_level;
  	pre_attr->chain = attr->chain;
  	pre_attr->prio = attr->prio;
++<<<<<<< HEAD
 +	pre_attr->sample_attr = attr->sample_attr;
 +	sample_attr->sampler_id = sample_flow->sampler->sampler_id;
++=======
+ 	pre_attr->ft = attr->ft;
+ 	pre_attr->sample_attr = *sample_attr;
++>>>>>>> a81283263bb0 (net/mlx5e: Use multi table support for CT and sample actions)
  	pre_esw_attr = pre_attr->esw_attr;
  	pre_esw_attr->in_mdev = esw_attr->in_mdev;
  	pre_esw_attr->in_rep = esw_attr->in_rep;
@@@ -637,11 -604,9 +617,9 @@@ mlx5e_tc_sample_unoffload(struct mlx5e_
  	mlx5_eswitch_del_offloaded_rule(esw, sample_flow->pre_rule, sample_flow->pre_attr);
  
  	sample_restore_put(tc_psample, sample_flow->restore);
 -	mapping_remove(esw->offloads.reg_c0_obj_pool, attr->sample_attr.restore_obj_id);
 +	mapping_remove(esw->offloads.reg_c0_obj_pool, attr->sample_attr->restore_obj_id);
  	sampler_put(tc_psample, sample_flow->sampler);
- 	if (sample_flow->post_act_handle)
- 		mlx5e_tc_post_act_del(tc_psample->post_act, sample_flow->post_act_handle);
- 	else
+ 	if (sample_flow->post_rule)
  		del_post_rule(esw, sample_flow, attr);
  
  	kfree(sample_flow->pre_attr);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index bdde5fe4e17e,875e77af0ae6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@@ -1778,14 -1816,6 +1777,17 @@@ __mlx5_tc_ct_flow_offload(struct mlx5_t
  	}
  	ct_flow->ft = ft;
  
++<<<<<<< HEAD
 +	handle = mlx5e_tc_post_act_add(ct_priv->post_act, attr);
 +	if (IS_ERR(handle)) {
 +		err = PTR_ERR(handle);
 +		ct_dbg("Failed to allocate post action handle");
 +		goto err_post_act_handle;
 +	}
 +	ct_flow->post_act_handle = handle;
 +
++=======
++>>>>>>> a81283263bb0 (net/mlx5e: Use multi table support for CT and sample actions)
  	/* Base flow attributes of both rules on original rule attribute */
  	ct_flow->pre_ct_attr = mlx5_alloc_flow_attr(ct_priv->ns_type);
  	if (!ct_flow->pre_ct_attr) {
@@@ -1831,12 -1856,10 +1828,16 @@@
  	 */
  	if ((pre_ct_attr->action & MLX5_FLOW_CONTEXT_ACTION_DECAP) &&
  	    attr->chain == 0) {
++<<<<<<< HEAD
 +		u32 tun_id = mlx5e_tc_get_flow_tun_id(flow);
 +
 +		err = mlx5e_tc_match_to_reg_set(priv->mdev, &pre_mod_acts,
++=======
+ 		err = mlx5e_tc_match_to_reg_set(priv->mdev, pre_mod_acts,
++>>>>>>> a81283263bb0 (net/mlx5e: Use multi table support for CT and sample actions)
  						ct_priv->ns_type,
  						TUNNEL_TO_REG,
 -						attr->tunnel_id);
 +						tun_id);
  		if (err) {
  			ct_dbg("Failed to set tunnel register mapping");
  			goto err_mapping;
@@@ -1980,15 -1933,11 +1979,12 @@@ __mlx5_tc_ct_delete_flow(struct mlx5_tc
  	struct mlx5_flow_attr *pre_ct_attr = ct_flow->pre_ct_attr;
  	struct mlx5e_priv *priv = netdev_priv(ct_priv->netdev);
  
 -	mlx5_tc_rule_delete(priv, ct_flow->pre_ct_rule, pre_ct_attr);
 +	mlx5_tc_rule_delete(priv, ct_flow->pre_ct_rule,
 +			    pre_ct_attr);
  	mlx5_modify_header_dealloc(priv->mdev, pre_ct_attr->modify_hdr);
  
- 	if (ct_flow->post_act_handle) {
- 		mlx5_chains_put_chain_mapping(ct_priv->chains, ct_flow->chain_mapping);
- 		mlx5e_tc_post_act_del(ct_priv->post_act, ct_flow->post_act_handle);
- 		mlx5_tc_ct_del_ft_cb(ct_priv, ct_flow->ft);
- 	}
+ 	mlx5_chains_put_chain_mapping(ct_priv->chains, ct_flow->chain_mapping);
+ 	mlx5_tc_ct_del_ft_cb(ct_priv, ct_flow->ft);
  
  	kfree(ct_flow->pre_ct_attr);
  	kfree(ct_flow);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.h
new file mode 100644
index 000000000000..3efb3a15c5d2
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved. */
+
+#ifndef __MLX5_EN_TC_ACT_SAMPLE_H__
+#define __MLX5_EN_TC_ACT_SAMPLE_H__
+
+#include <net/flow_offload.h>
+#include "en/tc_priv.h"
+
+bool
+mlx5e_tc_act_sample_is_multi_table(struct mlx5_core_dev *mdev,
+				   struct mlx5_flow_attr *attr);
+
+#endif /* __MLX5_EN_TC_ACT_SAMPLE_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
