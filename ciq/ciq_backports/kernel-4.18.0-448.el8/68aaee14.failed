mm: memcontrol: fix potential oom_lock recursion deadlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 68aaee147e597b495622b7c9038e5922c7c61f57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/68aaee14.failed

syzbot is reporting GFP_KERNEL allocation with oom_lock held when
reporting memcg OOM [1].  If this allocation triggers the global OOM
situation then the system can livelock because the GFP_KERNEL
allocation with oom_lock held cannot trigger the global OOM killer
because __alloc_pages_may_oom() fails to hold oom_lock.

Fix this problem by removing the allocation from memory_stat_format()
completely, and pass static buffer when calling from memcg OOM path.

Note that the caller holding filesystem lock was the trigger for syzbot
to report this locking dependency.  Doing GFP_KERNEL allocation with
filesystem lock held can deadlock the system even without involving OOM
situation.

Link: https://syzkaller.appspot.com/bug?extid=2d2aeadc6ce1e1f11d45 [1]
Link: https://lkml.kernel.org/r/86afb39f-8c65-bec2-6cfc-c5e3cd600c0b@I-love.SAKURA.ne.jp
Fixes: c8713d0b23123759 ("mm: memcontrol: dump memory.stat during cgroup OOM")
	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Reported-by: syzbot <syzbot+2d2aeadc6ce1e1f11d45@syzkaller.appspotmail.com>
	Suggested-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Roman Gushchin <roman.gushchin@linux.dev>
	Cc: Shakeel Butt <shakeelb@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 68aaee147e597b495622b7c9038e5922c7c61f57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 413502fb22c9,b69979c9ced5..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1442,7 -1467,30 +1442,34 @@@ static inline unsigned long memcg_page_
  	return memcg_page_state(memcg, item) * memcg_page_state_unit(item);
  }
  
++<<<<<<< HEAD
 +static char *memory_stat_format(struct mem_cgroup *memcg)
++=======
+ /* Subset of vm_event_item to report for memcg event stats */
+ static const unsigned int memcg_vm_event_stat[] = {
+ 	PGSCAN_KSWAPD,
+ 	PGSCAN_DIRECT,
+ 	PGSTEAL_KSWAPD,
+ 	PGSTEAL_DIRECT,
+ 	PGFAULT,
+ 	PGMAJFAULT,
+ 	PGREFILL,
+ 	PGACTIVATE,
+ 	PGDEACTIVATE,
+ 	PGLAZYFREE,
+ 	PGLAZYFREED,
+ #if defined(CONFIG_MEMCG_KMEM) && defined(CONFIG_ZSWAP)
+ 	ZSWPIN,
+ 	ZSWPOUT,
+ #endif
+ #ifdef CONFIG_TRANSPARENT_HUGEPAGE
+ 	THP_FAULT_ALLOC,
+ 	THP_COLLAPSE_ALLOC,
+ #endif
+ };
+ 
+ static void memory_stat_format(struct mem_cgroup *memcg, char *buf, int bufsize)
++>>>>>>> 68aaee147e59 (mm: memcontrol: fix potential oom_lock recursion deadlock)
  {
  	struct seq_buf s;
  	int i;
* Unmerged path mm/memcontrol.c
