PCI/ACPI: negotiate CXL _OSC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Vishal Verma <vishal.l.verma@intel.com>
commit 56368029d93bbb3246ee2e03268fa6dd9754be05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/56368029.failed

Add full support for negotiating _OSC as defined in the CXL 2.0 spec, as
applicable to CXL-enabled platforms. Advertise support for the CXL
features we support - 'CXL 2.0 port/device register access', 'Protocol
Error Reporting', and 'CXL Native Hot Plug'. Request control for 'CXL
Memory Error Reporting'. The requests are dependent on CONFIG_* based
prerequisites, and prior PCI enabling, similar to how the standard PCI
_OSC bits are determined.

The CXL specification does not define any additional constraints on
the hotplug flow beyond PCIe native hotplug, so a kernel that supports
native PCIe hotplug, supports CXL hotplug. For error handling protocol
and link errors just use PCIe AER. There is nascent support for
amending AER events with CXL specific status [1], but there's
otherwise no additional OS responsibility for CXL errors beyond PCIe
AER. CXL Memory Errors behave the same as typical memory errors so
CONFIG_MEMORY_FAILURE is sufficient to indicate support to platform
firmware.

[1]: https://lore.kernel.org/linux-cxl/164740402242.3912056.8303625392871313860.stgit@dwillia2-desk3.amr.corp.intel.com/

	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: Robert Moore <robert.moore@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Davidlohr Bueso <dave@stgolabs.net>
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
Link: https://lore.kernel.org/r/20220413073618.291335-4-vishal.l.verma@intel.com
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 56368029d93bbb3246ee2e03268fa6dd9754be05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/pci_root.c
#	include/linux/acpi.h
diff --cc drivers/acpi/pci_root.c
index eec159e03acb,c82ad63fffed..000000000000
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@@ -223,7 -232,9 +247,13 @@@ static acpi_status acpi_pci_run_osc(str
  
  	status = acpi_run_osc(root->device->handle, &context);
  	if (ACPI_SUCCESS(status)) {
++<<<<<<< HEAD
 +		*retval = *((u32 *)(context.ret.pointer + 8));
++=======
+ 		*pci_control = acpi_osc_ctx_get_pci_control(&context);
+ 		if (is_cxl(root))
+ 			*cxl_control = acpi_osc_ctx_get_cxl_control(&context);
++>>>>>>> 56368029d93b (PCI/ACPI: negotiate CXL _OSC)
  		kfree(context.ret.pointer);
  	}
  	return status;
diff --cc include/linux/acpi.h
index 19fe38e45f30,378a431666b3..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -623,6 -614,29 +625,32 @@@ extern u32 osc_sb_native_usb4_control
  #define OSC_PCI_EXPRESS_LTR_CONTROL		0x00000020
  #define OSC_PCI_EXPRESS_DPC_CONTROL		0x00000080
  
++<<<<<<< HEAD
++=======
+ /* CXL _OSC: Capabilities DWORD 4: Support Field */
+ #define OSC_CXL_1_1_PORT_REG_ACCESS_SUPPORT	0x00000001
+ #define OSC_CXL_2_0_PORT_DEV_REG_ACCESS_SUPPORT	0x00000002
+ #define OSC_CXL_PROTOCOL_ERR_REPORTING_SUPPORT	0x00000004
+ #define OSC_CXL_NATIVE_HP_SUPPORT		0x00000008
+ 
+ /* CXL _OSC: Capabilities DWORD 5: Control Field */
+ #define OSC_CXL_ERROR_REPORTING_CONTROL		0x00000001
+ 
+ static inline u32 acpi_osc_ctx_get_pci_control(struct acpi_osc_context *context)
+ {
+ 	u32 *ret = context->ret.pointer;
+ 
+ 	return ret[OSC_CONTROL_DWORD];
+ }
+ 
+ static inline u32 acpi_osc_ctx_get_cxl_control(struct acpi_osc_context *context)
+ {
+ 	u32 *ret = context->ret.pointer;
+ 
+ 	return ret[OSC_EXT_CONTROL_DWORD];
+ }
+ 
++>>>>>>> 56368029d93b (PCI/ACPI: negotiate CXL _OSC)
  #define ACPI_GSB_ACCESS_ATTRIB_QUICK		0x00000002
  #define ACPI_GSB_ACCESS_ATTRIB_SEND_RCV         0x00000004
  #define ACPI_GSB_ACCESS_ATTRIB_BYTE		0x00000006
@@@ -997,6 -1024,26 +1025,29 @@@ static inline int acpi_get_local_addres
  	return -ENODEV;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int acpi_register_wakeup_handler(int wake_irq,
+ 	bool (*wakeup)(void *context), void *context)
+ {
+ 	return -ENXIO;
+ }
+ 
+ static inline void acpi_unregister_wakeup_handler(
+ 	bool (*wakeup)(void *context), void *context) { }
+ 
+ struct acpi_osc_context;
+ static inline u32 acpi_osc_ctx_get_pci_control(struct acpi_osc_context *context)
+ {
+ 	return 0;
+ }
+ 
+ static inline u32 acpi_osc_ctx_get_cxl_control(struct acpi_osc_context *context)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> 56368029d93b (PCI/ACPI: negotiate CXL _OSC)
  #endif	/* !CONFIG_ACPI */
  
  #ifdef CONFIG_ACPI_HOTPLUG_IOAPIC
* Unmerged path drivers/acpi/pci_root.c
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index b31f03f6728e..9933c61c81ba 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -603,8 +603,10 @@ struct acpi_pci_root {
 	int bridge_type;
 	struct resource secondary;	/* downstream bus range */
 
-	u32 osc_support_set;	/* _OSC state of support bits */
-	u32 osc_control_set;	/* _OSC state of control bits */
+	u32 osc_support_set;		/* _OSC state of support bits */
+	u32 osc_control_set;		/* _OSC state of control bits */
+	u32 osc_ext_support_set;	/* _OSC state of extended support bits */
+	u32 osc_ext_control_set;	/* _OSC state of extended control bits */
 	phys_addr_t mcfg_addr;
 };
 
* Unmerged path include/linux/acpi.h
