KVM: emulate: do not adjust size of fastop and setcc subroutines

jira LE-1907
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23825
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 79629181607e801c0b41b8790ac4ee2eb5d7bc3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/79629181.failed

Instead of doing complicated calculations to find the size of the subroutines
(which are even more complicated because they need to be stringified into
an asm statement), just hardcode to 16.

It is less dense for a few combinations of IBT/SLS/retbleed, but it has
the advantage of being really simple.

	Cc: stable@vger.kernel.org # 5.15.x: 84e7051c0bc1: x86/kvm: fix FASTOP_SIZE when return thunks are enabled
	Cc: stable@vger.kernel.org
	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 79629181607e801c0b41b8790ac4ee2eb5d7bc3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/emulate.c
diff --cc arch/x86/kvm/emulate.c
index 728f143c512c,f8382abe22ff..000000000000
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@@ -188,9 -189,6 +188,12 @@@
  #define X8(x...) X4(x), X4(x)
  #define X16(x...) X8(x), X8(x)
  
++<<<<<<< HEAD
 +#define NR_FASTOP (ilog2(sizeof(ulong)) + 1)
 +#define FASTOP_SIZE 8
 +
++=======
++>>>>>>> 79629181607e (KVM: emulate: do not adjust size of fastop and setcc subroutines)
  struct opcode {
  	u64 flags;
  	u8 intercept;
@@@ -433,16 -440,12 +442,20 @@@ static int fastop(struct x86_emulate_ct
  /*
   * Depending on .config the SETcc functions look like:
   *
 - * ENDBR			[4 bytes; CONFIG_X86_KERNEL_IBT]
 - * SETcc %al			[3 bytes]
 - * RET | JMP __x86_return_thunk	[1,5 bytes; CONFIG_RETHUNK]
 - * INT3				[1 byte; CONFIG_SLS]
 + * SETcc %al   [3 bytes]
 + * RET         [1 byte]
 + * INT3        [1 byte; CONFIG_SLS]
 + *
 + * Which gives possible sizes 4 or 5.  When rounded up to the
 + * next power-of-two alignment they become 4 or 8.
   */
++<<<<<<< HEAD
 +#define SETCC_LENGTH	(4 + IS_ENABLED(CONFIG_SLS))
 +#define SETCC_ALIGN	(4 << IS_ENABLED(CONFIG_SLS))
 +static_assert(SETCC_LENGTH <= SETCC_ALIGN);
++=======
+ #define SETCC_ALIGN	16
++>>>>>>> 79629181607e (KVM: emulate: do not adjust size of fastop and setcc subroutines)
  
  #define FOP_SETCC(op) \
  	".align " __stringify(SETCC_ALIGN) " \n\t" \
* Unmerged path arch/x86/kvm/emulate.c
