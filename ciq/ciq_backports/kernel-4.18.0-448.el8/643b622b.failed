net: tcp: add skb drop reasons to tcp_v{4,6}_inbound_md5_hash()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit 643b622b51f1f0015e0a80f90b4ef9032e6ddb1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/643b622b.failed

Pass the address of drop reason to tcp_v4_inbound_md5_hash() and
tcp_v6_inbound_md5_hash() to store the reasons for skb drops when this
function fails. Therefore, the drop reason can be passed to
kfree_skb_reason() when the skb needs to be freed.

Following drop reasons are added:

SKB_DROP_REASON_TCP_MD5NOTFOUND
SKB_DROP_REASON_TCP_MD5UNEXPECTED
SKB_DROP_REASON_TCP_MD5FAILURE

SKB_DROP_REASON_TCP_MD5* above correspond to LINUX_MIB_TCPMD5*

	Reviewed-by: Mengen Sun <mengensun@tencent.com>
	Reviewed-by: Hao Peng <flyingpeng@tencent.com>
	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 643b622b51f1f0015e0a80f90b4ef9032e6ddb1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/trace/events/skb.h
#	net/ipv6/tcp_ipv6.c
diff --cc include/linux/skbuff.h
index 6050fa383222,46678eb587ff..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -318,7 -314,50 +318,54 @@@ struct sk_buff
   * used to translate the reason to string.
   */
  enum skb_drop_reason {
++<<<<<<< HEAD
 +	SKB_DROP_REASON_NOT_SPECIFIED,
++=======
+ 	SKB_DROP_REASON_NOT_SPECIFIED,	/* drop reason is not specified */
+ 	SKB_DROP_REASON_NO_SOCKET,	/* socket not found */
+ 	SKB_DROP_REASON_PKT_TOO_SMALL,	/* packet size is too small */
+ 	SKB_DROP_REASON_TCP_CSUM,	/* TCP checksum error */
+ 	SKB_DROP_REASON_SOCKET_FILTER,	/* dropped by socket filter */
+ 	SKB_DROP_REASON_UDP_CSUM,	/* UDP checksum error */
+ 	SKB_DROP_REASON_NETFILTER_DROP,	/* dropped by netfilter */
+ 	SKB_DROP_REASON_OTHERHOST,	/* packet don't belong to current
+ 					 * host (interface is in promisc
+ 					 * mode)
+ 					 */
+ 	SKB_DROP_REASON_IP_CSUM,	/* IP checksum error */
+ 	SKB_DROP_REASON_IP_INHDR,	/* there is something wrong with
+ 					 * IP header (see
+ 					 * IPSTATS_MIB_INHDRERRORS)
+ 					 */
+ 	SKB_DROP_REASON_IP_RPFILTER,	/* IP rpfilter validate failed.
+ 					 * see the document for rp_filter
+ 					 * in ip-sysctl.rst for more
+ 					 * information
+ 					 */
+ 	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST, /* destination address of L2
+ 						  * is multicast, but L3 is
+ 						  * unicast.
+ 						  */
+ 	SKB_DROP_REASON_XFRM_POLICY,	/* xfrm policy check failed */
+ 	SKB_DROP_REASON_IP_NOPROTO,	/* no support for IP protocol */
+ 	SKB_DROP_REASON_SOCKET_RCVBUFF,	/* socket receive buff is full */
+ 	SKB_DROP_REASON_PROTO_MEM,	/* proto memory limition, such as
+ 					 * udp packet drop out of
+ 					 * udp_memory_allocated.
+ 					 */
+ 	SKB_DROP_REASON_TCP_MD5NOTFOUND,	/* no MD5 hash and one
+ 						 * expected, corresponding
+ 						 * to LINUX_MIB_TCPMD5NOTFOUND
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5UNEXPECTED,	/* MD5 hash and we're not
+ 						 * expecting one, corresponding
+ 						 * to LINUX_MIB_TCPMD5UNEXPECTED
+ 						 */
+ 	SKB_DROP_REASON_TCP_MD5FAILURE,	/* MD5 hash and its wrong,
+ 					 * corresponding to
+ 					 * LINUX_MIB_TCPMD5FAILURE
+ 					 */
++>>>>>>> 643b622b51f1 (net: tcp: add skb drop reasons to tcp_v{4,6}_inbound_md5_hash())
  	SKB_DROP_REASON_MAX,
  };
  
diff --cc include/trace/events/skb.h
index 294c61bbe44b,46c06b0be850..000000000000
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@@ -11,6 -11,26 +11,29 @@@
  
  #define TRACE_SKB_DROP_REASON					\
  	EM(SKB_DROP_REASON_NOT_SPECIFIED, NOT_SPECIFIED)	\
++<<<<<<< HEAD
++=======
+ 	EM(SKB_DROP_REASON_NO_SOCKET, NO_SOCKET)		\
+ 	EM(SKB_DROP_REASON_PKT_TOO_SMALL, PKT_TOO_SMALL)	\
+ 	EM(SKB_DROP_REASON_TCP_CSUM, TCP_CSUM)			\
+ 	EM(SKB_DROP_REASON_SOCKET_FILTER, SOCKET_FILTER)	\
+ 	EM(SKB_DROP_REASON_UDP_CSUM, UDP_CSUM)			\
+ 	EM(SKB_DROP_REASON_NETFILTER_DROP, NETFILTER_DROP)	\
+ 	EM(SKB_DROP_REASON_OTHERHOST, OTHERHOST)		\
+ 	EM(SKB_DROP_REASON_IP_CSUM, IP_CSUM)			\
+ 	EM(SKB_DROP_REASON_IP_INHDR, IP_INHDR)			\
+ 	EM(SKB_DROP_REASON_IP_RPFILTER, IP_RPFILTER)		\
+ 	EM(SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST,		\
+ 	   UNICAST_IN_L2_MULTICAST)				\
+ 	EM(SKB_DROP_REASON_XFRM_POLICY, XFRM_POLICY)		\
+ 	EM(SKB_DROP_REASON_IP_NOPROTO, IP_NOPROTO)		\
+ 	EM(SKB_DROP_REASON_SOCKET_RCVBUFF, SOCKET_RCVBUFF)	\
+ 	EM(SKB_DROP_REASON_PROTO_MEM, PROTO_MEM)		\
+ 	EM(SKB_DROP_REASON_TCP_MD5NOTFOUND, TCP_MD5NOTFOUND)	\
+ 	EM(SKB_DROP_REASON_TCP_MD5UNEXPECTED,			\
+ 	   TCP_MD5UNEXPECTED)					\
+ 	EM(SKB_DROP_REASON_TCP_MD5FAILURE, TCP_MD5FAILURE)	\
++>>>>>>> 643b622b51f1 (net: tcp: add skb drop reasons to tcp_v{4,6}_inbound_md5_hash())
  	EMe(SKB_DROP_REASON_MAX, MAX)
  
  #undef EM
diff --cc net/ipv6/tcp_ipv6.c
index 8cdff0ded837,1262b790b146..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -746,11 -816,12 +749,12 @@@ static bool tcp_v6_inbound_md5_hash(con
  				      NULL, skb);
  
  	if (genhash || memcmp(hash_location, newhash, 16) != 0) {
+ 		*reason = SKB_DROP_REASON_TCP_MD5FAILURE;
  		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);
 -		net_info_ratelimited("MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u L3 index %d\n",
 +		net_info_ratelimited("MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\n",
  				     genhash ? "failed" : "mismatch",
  				     &ip6h->saddr, ntohs(th->source),
 -				     &ip6h->daddr, ntohs(th->dest), l3index);
 +				     &ip6h->daddr, ntohs(th->dest));
  		return true;
  	}
  #endif
@@@ -1605,19 -1743,27 +1610,23 @@@ process
  			return 0;
  		}
  	}
 -
 -	if (static_branch_unlikely(&ip6_min_hopcount)) {
 -		/* min_hopcount can be changed concurrently from do_ipv6_setsockopt() */
 -		if (hdr->hop_limit < READ_ONCE(tcp_inet6_sk(sk)->min_hopcount)) {
 -			__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
 -			goto discard_and_relse;
 -		}
 +	if (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {
 +		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
 +		goto discard_and_relse;
  	}
  
 -	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {
 -		drop_reason = SKB_DROP_REASON_XFRM_POLICY;
++<<<<<<< HEAD
 +	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
  		goto discard_and_relse;
 -	}
  
 +	if (tcp_v6_inbound_md5_hash(sk, skb, dif, sdif))
++=======
+ 	if (tcp_v6_inbound_md5_hash(sk, skb, dif, sdif, &drop_reason))
++>>>>>>> 643b622b51f1 (net: tcp: add skb drop reasons to tcp_v{4,6}_inbound_md5_hash())
  		goto discard_and_relse;
  
 -	if (tcp_filter(sk, skb)) {
 -		drop_reason = SKB_DROP_REASON_SOCKET_FILTER;
 +	if (tcp_filter(sk, skb))
  		goto discard_and_relse;
 -	}
  	th = (const struct tcphdr *)skb->data;
  	hdr = ipv6_hdr(skb);
  	tcp_v6_fill_cb(skb, hdr, th);
* Unmerged path include/linux/skbuff.h
* Unmerged path include/trace/events/skb.h
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 46d2e6848354..7d220cb8dcb9 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -1318,7 +1318,8 @@ EXPORT_SYMBOL(tcp_v4_md5_hash_skb);
 /* Called with rcu_read_lock() */
 static bool tcp_v4_inbound_md5_hash(const struct sock *sk,
 				    const struct sk_buff *skb,
-				    int dif, int sdif)
+				    int dif, int sdif,
+				    enum skb_drop_reason *reason)
 {
 #ifdef CONFIG_TCP_MD5SIG
 	/*
@@ -1346,11 +1347,13 @@ static bool tcp_v4_inbound_md5_hash(const struct sock *sk,
 		return false;
 
 	if (hash_expected && !hash_location) {
+		*reason = SKB_DROP_REASON_TCP_MD5NOTFOUND;
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);
 		return true;
 	}
 
 	if (!hash_expected && hash_location) {
+		*reason = SKB_DROP_REASON_TCP_MD5UNEXPECTED;
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);
 		return true;
 	}
@@ -1363,6 +1366,7 @@ static bool tcp_v4_inbound_md5_hash(const struct sock *sk,
 				      NULL, skb);
 
 	if (genhash || memcmp(hash_location, newhash, 16) != 0) {
+		*reason = SKB_DROP_REASON_TCP_MD5FAILURE;
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);
 		net_info_ratelimited("MD5 Hash failed for (%pI4, %d)->(%pI4, %d)%s\n",
 				     &iph->saddr, ntohs(th->source),
@@ -1860,6 +1864,7 @@ static void tcp_v4_fill_cb(struct sk_buff *skb, const struct iphdr *iph,
 int tcp_v4_rcv(struct sk_buff *skb)
 {
 	struct net *net = dev_net(skb->dev);
+	enum skb_drop_reason drop_reason;
 	int sdif = inet_sdif(skb);
 	int dif = inet_iif(skb);
 	const struct iphdr *iph;
@@ -1910,7 +1915,8 @@ int tcp_v4_rcv(struct sk_buff *skb)
 		struct sock *nsk;
 
 		sk = req->rsk_listener;
-		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))) {
+		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb, dif, sdif,
+						     &drop_reason))) {
 			sk_drops_add(sk, skb);
 			reqsk_put(req);
 			goto discard_it;
@@ -1972,7 +1978,7 @@ int tcp_v4_rcv(struct sk_buff *skb)
 		goto discard_and_relse;
 	}
 
-	if (tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))
+	if (tcp_v4_inbound_md5_hash(sk, skb, dif, sdif, &drop_reason))
 		goto discard_and_relse;
 
 	nf_reset(skb);
* Unmerged path net/ipv6/tcp_ipv6.c
