net: skb: prevent the split of kfree_skb_reason() by gcc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit c205cc7534a97f2d6fbd2a23a94ed7c036c6e2aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c205cc75.failed

Sometimes, gcc will optimize the function by spliting it to two or
more functions. In this case, kfree_skb_reason() is splited to
kfree_skb_reason and kfree_skb_reason.part.0. However, the
function/tracepoint trace_kfree_skb() in it needs the return address
of kfree_skb_reason().

This split makes the call chains becomes:
  kfree_skb_reason() -> kfree_skb_reason.part.0 -> trace_kfree_skb()

which makes the return address that passed to trace_kfree_skb() be
kfree_skb().

Therefore, introduce '__fix_address', which is the combination of
'__noclone' and 'noinline', and apply it to kfree_skb_reason() to
prevent to from being splited or made inline.

(Is it better to simply apply '__noclone oninline' to kfree_skb_reason?
I'm thinking maybe other functions have the same problems)

Meanwhile, wrap 'skb_unref()' with 'unlikely()', as the compiler thinks
it is likely return true and splits kfree_skb_reason().

	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c205cc7534a97f2d6fbd2a23a94ed7c036c6e2aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler_attributes.h
* Unmerged path include/linux/compiler_attributes.h
* Unmerged path include/linux/compiler_attributes.h
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 4150b3abe191..dda975e4da06 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1116,7 +1116,8 @@ static inline bool skb_unref(struct sk_buff *skb)
 	return true;
 }
 
-void kfree_skb_reason(struct sk_buff *skb, enum skb_drop_reason reason);
+void __fix_address
+kfree_skb_reason(struct sk_buff *skb, enum skb_drop_reason reason);
 
 /**
  *	kfree_skb - free an sk_buff with 'NOT_SPECIFIED' reason
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index d7c555eb9bac..23117c89e754 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -758,9 +758,10 @@ EXPORT_SYMBOL(__kfree_skb);
  *	hit zero. Meanwhile, pass the drop reason to 'kfree_skb'
  *	tracepoint.
  */
-void kfree_skb_reason(struct sk_buff *skb, enum skb_drop_reason reason)
+void __fix_address
+kfree_skb_reason(struct sk_buff *skb, enum skb_drop_reason reason)
 {
-	if (!skb_unref(skb))
+	if (unlikely(!skb_unref(skb)))
 		return;
 
 	DEBUG_NET_WARN_ON_ONCE(reason <= 0 || reason >= SKB_DROP_REASON_MAX);
