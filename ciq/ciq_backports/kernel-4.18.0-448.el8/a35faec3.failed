drm/amdgpu: Off by one in dm_dmub_outbox1_low_irq()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit a35faec3db0e13aac8ea720bc1a3503081dd5a3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a35faec3.failed

The > ARRAY_SIZE() should be >= ARRAY_SIZE() to prevent an out of bounds
access.

Fixes: e27c41d5b068 ("drm/amd/display: Support for DMUB HPD interrupt handling")
	Reviewed-by: Harry Wentland <harry.wentland@amd.com>
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit a35faec3db0e13aac8ea720bc1a3503081dd5a3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
diff --cc drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 085a5ad87ab0,5ea5e14b83c8..000000000000
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@@ -634,22 -761,50 +634,63 @@@ static void dm_dmub_outbox1_low_irq(voi
  	struct amdgpu_display_manager *dm = &adev->dm;
  	struct dmcub_trace_buf_entry entry = { 0 };
  	uint32_t count = 0;
 -	struct dmub_hpd_work *dmub_hpd_wrk;
 -	struct dc_link *plink = NULL;
  
 -	if (dc_enable_dmub_notifications(adev->dm.dc) &&
 -		irq_params->irq_src == DC_IRQ_SOURCE_DMCUB_OUTBOX) {
 +	if (dc_enable_dmub_notifications(adev->dm.dc)) {
 +		if (irq_params->irq_src == DC_IRQ_SOURCE_DMCUB_OUTBOX) {
 +			do {
 +				dc_stat_get_dmub_notification(adev->dm.dc, &notify);
 +			} while (notify.pending_notification);
 +
++<<<<<<< HEAD
 +			if (adev->dm.dmub_notify)
 +				memcpy(adev->dm.dmub_notify, &notify, sizeof(struct dmub_notification));
 +			if (notify.type == DMUB_NOTIFICATION_AUX_REPLY)
 +				complete(&adev->dm.dmub_aux_transfer_done);
 +			// TODO : HPD Implementation
  
 +		} else {
 +			DRM_ERROR("DM: Failed to receive correct outbox IRQ !");
 +		}
++=======
+ 		do {
+ 			dc_stat_get_dmub_notification(adev->dm.dc, &notify);
+ 			if (notify.type >= ARRAY_SIZE(dm->dmub_thread_offload)) {
+ 				DRM_ERROR("DM: notify type %d invalid!", notify.type);
+ 				continue;
+ 			}
+ 			if (!dm->dmub_callback[notify.type]) {
+ 				DRM_DEBUG_DRIVER("DMUB notification skipped, no handler: type=%d\n", notify.type);
+ 				continue;
+ 			}
+ 			if (dm->dmub_thread_offload[notify.type] == true) {
+ 				dmub_hpd_wrk = kzalloc(sizeof(*dmub_hpd_wrk), GFP_ATOMIC);
+ 				if (!dmub_hpd_wrk) {
+ 					DRM_ERROR("Failed to allocate dmub_hpd_wrk");
+ 					return;
+ 				}
+ 				dmub_hpd_wrk->dmub_notify = kzalloc(sizeof(struct dmub_notification), GFP_ATOMIC);
+ 				if (!dmub_hpd_wrk->dmub_notify) {
+ 					kfree(dmub_hpd_wrk);
+ 					DRM_ERROR("Failed to allocate dmub_hpd_wrk->dmub_notify");
+ 					return;
+ 				}
+ 				INIT_WORK(&dmub_hpd_wrk->handle_hpd_work, dm_handle_hpd_work);
+ 				if (dmub_hpd_wrk->dmub_notify)
+ 					memcpy(dmub_hpd_wrk->dmub_notify, &notify, sizeof(struct dmub_notification));
+ 				dmub_hpd_wrk->adev = adev;
+ 				if (notify.type == DMUB_NOTIFICATION_HPD) {
+ 					plink = adev->dm.dc->links[notify.link_index];
+ 					if (plink) {
+ 						plink->hpd_status =
+ 							notify.hpd_status == DP_HPD_PLUG;
+ 					}
+ 				}
+ 				queue_work(adev->dm.delayed_hpd_wq, &dmub_hpd_wrk->handle_hpd_work);
+ 			} else {
+ 				dm->dmub_callback[notify.type](adev, &notify);
+ 			}
+ 		} while (notify.pending_notification);
++>>>>>>> a35faec3db0e (drm/amdgpu: Off by one in dm_dmub_outbox1_low_irq())
  	}
  
  
* Unmerged path drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
