ACPI: bus: Avoid non-ACPI device objects in walks over children

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 10fa1b2cdc899ab471000968af56215bf3c90d8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/10fa1b2c.failed

When walking the children of an ACPI device, take extra care to avoid
using to_acpi_device() on the ones that are not ACPI devices, because
that may lead to out-of-bounds access and memory corruption.

While at it, make the function passed to acpi_dev_for_each_child()
take a struct acpi_device pointer argument (instead of a struct device
one), so it is more straightforward to use.

Fixes: b7dd6298db81 ("ACPI: PM: Introduce acpi_dev_power_up_children_with_adr()")
	Reported-by: kernel test robot <oliver.sang@intel.com>
BugLink: https://lore.kernel.org/lkml/20220420064725.GB16310@xsang-OptiPlex-9020/
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 10fa1b2cdc899ab471000968af56215bf3c90d8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/bus.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/bus.c
index b4d279cc20e0,fe0000eb7cae..000000000000
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@@ -1095,7 -1063,38 +1095,42 @@@ struct bus_type acpi_bus_type = 
  	.remove		= acpi_device_remove,
  	.uevent		= acpi_device_uevent,
  };
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(acpi_bus_type);
++=======
+ 
+ int acpi_bus_for_each_dev(int (*fn)(struct device *, void *), void *data)
+ {
+ 	return bus_for_each_dev(&acpi_bus_type, NULL, data, fn);
+ }
+ EXPORT_SYMBOL_GPL(acpi_bus_for_each_dev);
+ 
+ struct acpi_dev_walk_context {
+ 	int (*fn)(struct acpi_device *, void *);
+ 	void *data;
+ };
+ 
+ static int acpi_dev_for_one_check(struct device *dev, void *context)
+ {
+ 	struct acpi_dev_walk_context *adwc = context;
+ 
+ 	if (dev->bus != &acpi_bus_type)
+ 		return 0;
+ 
+ 	return adwc->fn(to_acpi_device(dev), adwc->data);
+ }
+ 
+ int acpi_dev_for_each_child(struct acpi_device *adev,
+ 			    int (*fn)(struct acpi_device *, void *), void *data)
+ {
+ 	struct acpi_dev_walk_context adwc = {
+ 		.fn = fn,
+ 		.data = data,
+ 	};
+ 
+ 	return device_for_each_child(&adev->dev, &adwc, acpi_dev_for_one_check);
+ }
++>>>>>>> 10fa1b2cdc89 (ACPI: bus: Avoid non-ACPI device objects in walks over children)
  
  /* --------------------------------------------------------------------------
                               Initialization/Cleanup
diff --cc include/acpi/acpi_bus.h
index 3a9fb37489d2,772590e2eddb..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -489,6 -480,10 +489,13 @@@ void acpi_initialize_hp_context(struct 
  /* acpi_device.dev.bus == &acpi_bus_type */
  extern struct bus_type acpi_bus_type;
  
++<<<<<<< HEAD
++=======
+ int acpi_bus_for_each_dev(int (*fn)(struct device *, void *), void *data);
+ int acpi_dev_for_each_child(struct acpi_device *adev,
+ 			    int (*fn)(struct acpi_device *, void *), void *data);
+ 
++>>>>>>> 10fa1b2cdc89 (ACPI: bus: Avoid non-ACPI device objects in walks over children)
  /*
   * Events
   * ------
* Unmerged path drivers/acpi/bus.c
diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 18fa99c3ea69..c15df6c1ce73 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -437,11 +437,8 @@ bool acpi_bus_power_manageable(acpi_handle handle)
 }
 EXPORT_SYMBOL(acpi_bus_power_manageable);
 
-static int acpi_power_up_if_adr_present(struct device *dev, void *not_used)
+static int acpi_power_up_if_adr_present(struct acpi_device *adev, void *not_used)
 {
-	struct acpi_device *adev;
-
-	adev = to_acpi_device(dev);
 	if (!(adev->flags.power_manageable && adev->pnp.type.bus_address))
 		return 0;
 
* Unmerged path include/acpi/acpi_bus.h
