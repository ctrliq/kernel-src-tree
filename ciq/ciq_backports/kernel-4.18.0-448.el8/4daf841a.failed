net: ipv6: add skb drop reasons to ip6_rcv_core()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Menglong Dong <imagedong@tencent.com>
commit 4daf841a2ef3b2e987894c8107d309ce2b67c202
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/4daf841a.failed

Replace kfree_skb() used in ip6_rcv_core() with kfree_skb_reason().
No new drop reasons are added.

Seems now we use 'SKB_DROP_REASON_IP_INHDR' for too many case during
ipv6 header parse or check, just like what 'IPSTATS_MIB_INHDRERRORS'
do. Will it be too general and hard to know what happened?

	Signed-off-by: Menglong Dong <imagedong@tencent.com>
	Reviewed-by: Jiang Biao <benbjiang@tencent.com>
	Reviewed-by: Hao Peng <flyingpeng@tencent.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4daf841a2ef3b2e987894c8107d309ce2b67c202)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_input.c
diff --cc net/ipv6/ip6_input.c
index 608648d94275,1b925ecb26e9..000000000000
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@@ -75,16 -76,84 +75,23 @@@ int ip6_rcv_finish(struct net *net, str
  	return dst_input(skb);
  }
  
 -static void ip6_sublist_rcv_finish(struct list_head *head)
 -{
 -	struct sk_buff *skb, *next;
 -
 -	list_for_each_entry_safe(skb, next, head, list) {
 -		skb_list_del_init(skb);
 -		dst_input(skb);
 -	}
 -}
 -
 -static bool ip6_can_use_hint(const struct sk_buff *skb,
 -			     const struct sk_buff *hint)
 -{
 -	return hint && !skb_dst(skb) &&
 -	       ipv6_addr_equal(&ipv6_hdr(hint)->daddr, &ipv6_hdr(skb)->daddr);
 -}
 -
 -static struct sk_buff *ip6_extract_route_hint(const struct net *net,
 -					      struct sk_buff *skb)
 -{
 -	if (fib6_routes_require_src(net) || fib6_has_custom_rules(net))
 -		return NULL;
 -
 -	return skb;
 -}
 -
 -static void ip6_list_rcv_finish(struct net *net, struct sock *sk,
 -				struct list_head *head)
 -{
 -	struct sk_buff *skb, *next, *hint = NULL;
 -	struct dst_entry *curr_dst = NULL;
 -	struct list_head sublist;
 -
 -	INIT_LIST_HEAD(&sublist);
 -	list_for_each_entry_safe(skb, next, head, list) {
 -		struct dst_entry *dst;
 -
 -		skb_list_del_init(skb);
 -		/* if ingress device is enslaved to an L3 master device pass the
 -		 * skb to its handler for processing
 -		 */
 -		skb = l3mdev_ip6_rcv(skb);
 -		if (!skb)
 -			continue;
 -
 -		if (ip6_can_use_hint(skb, hint))
 -			skb_dst_copy(skb, hint);
 -		else
 -			ip6_rcv_finish_core(net, sk, skb);
 -		dst = skb_dst(skb);
 -		if (curr_dst != dst) {
 -			hint = ip6_extract_route_hint(net, skb);
 -
 -			/* dispatch old sublist */
 -			if (!list_empty(&sublist))
 -				ip6_sublist_rcv_finish(&sublist);
 -			/* start new sublist */
 -			INIT_LIST_HEAD(&sublist);
 -			curr_dst = dst;
 -		}
 -		list_add_tail(&skb->list, &sublist);
 -	}
 -	/* dispatch final sublist */
 -	ip6_sublist_rcv_finish(&sublist);
 -}
 -
 -static struct sk_buff *ip6_rcv_core(struct sk_buff *skb, struct net_device *dev,
 -				    struct net *net)
 +int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
  {
+ 	enum skb_drop_reason reason;
  	const struct ipv6hdr *hdr;
  	u32 pkt_len;
  	struct inet6_dev *idev;
 +	struct net *net = dev_net(skb->dev);
  
  	if (skb->pkt_type == PACKET_OTHERHOST) {
++<<<<<<< HEAD
 +		kfree_skb(skb);
 +		return NET_RX_DROP;
++=======
+ 		dev_core_stats_rx_otherhost_dropped_inc(skb->dev);
+ 		kfree_skb_reason(skb, SKB_DROP_REASON_OTHERHOST);
+ 		return NULL;
++>>>>>>> 4daf841a2ef3 (net: ipv6: add skb drop reasons to ip6_rcv_core())
  	}
  
  	rcu_read_lock();
@@@ -211,18 -286,71 +224,79 @@@
  	if (!skb_sk_is_prefetched(skb))
  		skb_orphan(skb);
  
 -	return skb;
 +	return NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,
 +		       net, NULL, skb, dev, NULL,
 +		       ip6_rcv_finish);
  err:
  	__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);
+ 	SKB_DR_OR(reason, IP_INHDR);
  drop:
  	rcu_read_unlock();
++<<<<<<< HEAD
 +	kfree_skb(skb);
 +	return NET_RX_DROP;
++=======
+ 	kfree_skb_reason(skb, reason);
+ 	return NULL;
+ }
+ 
+ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
+ {
+ 	struct net *net = dev_net(skb->dev);
+ 
+ 	skb = ip6_rcv_core(skb, dev, net);
+ 	if (skb == NULL)
+ 		return NET_RX_DROP;
+ 	return NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,
+ 		       net, NULL, skb, dev, NULL,
+ 		       ip6_rcv_finish);
+ }
+ 
+ static void ip6_sublist_rcv(struct list_head *head, struct net_device *dev,
+ 			    struct net *net)
+ {
+ 	NF_HOOK_LIST(NFPROTO_IPV6, NF_INET_PRE_ROUTING, net, NULL,
+ 		     head, dev, NULL, ip6_rcv_finish);
+ 	ip6_list_rcv_finish(net, NULL, head);
+ }
+ 
+ /* Receive a list of IPv6 packets */
+ void ipv6_list_rcv(struct list_head *head, struct packet_type *pt,
+ 		   struct net_device *orig_dev)
+ {
+ 	struct net_device *curr_dev = NULL;
+ 	struct net *curr_net = NULL;
+ 	struct sk_buff *skb, *next;
+ 	struct list_head sublist;
+ 
+ 	INIT_LIST_HEAD(&sublist);
+ 	list_for_each_entry_safe(skb, next, head, list) {
+ 		struct net_device *dev = skb->dev;
+ 		struct net *net = dev_net(dev);
+ 
+ 		skb_list_del_init(skb);
+ 		skb = ip6_rcv_core(skb, dev, net);
+ 		if (skb == NULL)
+ 			continue;
+ 
+ 		if (curr_dev != dev || curr_net != net) {
+ 			/* dispatch old sublist */
+ 			if (!list_empty(&sublist))
+ 				ip6_sublist_rcv(&sublist, curr_dev, curr_net);
+ 			/* start new sublist */
+ 			INIT_LIST_HEAD(&sublist);
+ 			curr_dev = dev;
+ 			curr_net = net;
+ 		}
+ 		list_add_tail(&skb->list, &sublist);
+ 	}
+ 	/* dispatch final sublist */
+ 	if (!list_empty(&sublist))
+ 		ip6_sublist_rcv(&sublist, curr_dev, curr_net);
++>>>>>>> 4daf841a2ef3 (net: ipv6: add skb drop reasons to ip6_rcv_core())
  }
  
 +INDIRECT_CALLABLE_DECLARE(int udpv6_rcv(struct sk_buff *));
  INDIRECT_CALLABLE_DECLARE(int tcp_v6_rcv(struct sk_buff *));
  
  /*
* Unmerged path net/ipv6/ip6_input.c
