ice: Add support for PPPoE hardware offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Marcin Szycik <marcin.szycik@linux.intel.com>
commit cd8efeeed16e8ecf30071583865f3f468db9e854
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/cd8efeee.failed

Add support for creating PPPoE filters in switchdev mode. Add support
for parsing PPPoE and PPP-specific tc options: pppoe_sid and ppp_proto.

Example filter:
tc filter add dev $PF1 ingress protocol ppp_ses prio 1 flower pppoe_sid \
    1234 ppp_proto ip skip_sw action mirred egress redirect dev $VF1_PR

Changes in iproute2 are required to use the new fields.

ICE COMMS DDP package is required to create a filter as it contains PPPoE
profiles. Added a warning message when loaded DDP package does not contain
required profiles.

	Signed-off-by: Marcin Szycik <marcin.szycik@linux.intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit cd8efeeed16e8ecf30071583865f3f468db9e854)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_protocol_type.h
#	drivers/net/ethernet/intel/ice/ice_switch.c
#	drivers/net/ethernet/intel/ice/ice_tc_lib.c
#	drivers/net/ethernet/intel/ice/ice_tc_lib.h
diff --cc drivers/net/ethernet/intel/ice/ice.h
index 570a42554ed0,36b440b1aaff..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -52,9 -52,7 +52,13 @@@
  #include <net/udp_tunnel.h>
  #include <net/vxlan.h>
  #include <net/gtp.h>
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_DCB)
 +#include <scsi/iscsi_proto.h>
 +#endif /* CONFIG_DCB */
++=======
+ #include <linux/ppp_defs.h>
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  #include "ice_devids.h"
  #include "ice_type.h"
  #include "ice_txrx.h"
diff --cc drivers/net/ethernet/intel/ice/ice_protocol_type.h
index 3f64300b0e14,560efc7654c7..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_protocol_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_protocol_type.h
@@@ -43,6 -43,9 +43,12 @@@ enum ice_protocol_type 
  	ICE_NVGRE,
  	ICE_GTP,
  	ICE_GTP_NO_PAY,
++<<<<<<< HEAD
++=======
+ 	ICE_PPPOE,
+ 	ICE_VLAN_EX,
+ 	ICE_VLAN_IN,
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  	ICE_VXLAN_GPE,
  	ICE_SCTP_IL,
  	ICE_PROTOCOL_LAST
@@@ -107,11 -110,13 +113,12 @@@ enum ice_prot_id 
  #define ICE_TCP_IL_HW		49
  #define ICE_UDP_ILOS_HW		53
  #define ICE_GRE_OF_HW		64
+ #define ICE_PPPOE_HW		103
  
  #define ICE_UDP_OF_HW	52 /* UDP Tunnels */
 -#define ICE_META_DATA_ID_HW 255 /* this is used for tunnel and VLAN type */
 +#define ICE_META_DATA_ID_HW 255 /* this is used for tunnel type */
  
  #define ICE_MDID_SIZE 2
 -
  #define ICE_TUN_FLAG_MDID 21
  #define ICE_TUN_FLAG_MDID_OFF (ICE_MDID_SIZE * ICE_TUN_FLAG_MDID)
  #define ICE_TUN_FLAG_MASK 0xFF
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 7b15835f7479,4a6a8334a0e0..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -30,6 -30,20 +30,23 @@@ static const u8 dummy_eth_header[DUMMY_
  							0x2, 0, 0, 0, 0, 0,
  							0x81, 0, 0, 0};
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	ICE_PKT_OUTER_IPV6	= BIT(0),
+ 	ICE_PKT_TUN_GTPC	= BIT(1),
+ 	ICE_PKT_TUN_GTPU	= BIT(2),
+ 	ICE_PKT_TUN_NVGRE	= BIT(3),
+ 	ICE_PKT_TUN_UDP		= BIT(4),
+ 	ICE_PKT_INNER_IPV6	= BIT(5),
+ 	ICE_PKT_INNER_TCP	= BIT(6),
+ 	ICE_PKT_INNER_UDP	= BIT(7),
+ 	ICE_PKT_GTP_NOPAY	= BIT(8),
+ 	ICE_PKT_KMALLOC		= BIT(9),
+ 	ICE_PKT_PPPOE		= BIT(10),
+ };
+ 
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  struct ice_dummy_pkt_offsets {
  	enum ice_protocol_type type;
  	u16 offset; /* ICE_PROTOCOL_LAST indicates end of list */
@@@ -1215,18 -1110,210 +1232,225 @@@ static const u8 dummy_ipv6_gtp_packet[
  	0x00, 0x00,
  };
  
++<<<<<<< HEAD
 +#define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr) + \
 +	 (DUMMY_ETH_HDR_LEN * \
 +	  sizeof(((struct ice_sw_rule_lkup_rx_tx *)0)->hdr[0])))
 +#define ICE_SW_RULE_RX_TX_NO_HDR_SIZE \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr))
 +#define ICE_SW_RULE_LG_ACT_SIZE(n) \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lg_act.act) + \
 +	 ((n) * sizeof(((struct ice_sw_rule_lg_act *)0)->act[0])))
 +#define ICE_SW_RULE_VSI_LIST_SIZE(n) \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.vsi_list.vsi) + \
 +	 ((n) * sizeof(((struct ice_sw_rule_vsi_list *)0)->vsi[0])))
++=======
+ ICE_DECLARE_PKT_OFFSETS(pppoe_ipv4_tcp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_PPPOE,		14 },
+ 	{ ICE_IPV4_OFOS,	22 },
+ 	{ ICE_TCP_IL,		42 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(pppoe_ipv4_tcp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x88, 0x64,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x11, 0x00, 0x00, 0x00, /* ICE_PPPOE 14 */
+ 	0x00, 0x16,
+ 
+ 	0x00, 0x21,		/* PPP Link Layer 20 */
+ 
+ 	0x45, 0x00, 0x00, 0x28, /* ICE_IPV4_OFOS 22 */
+ 	0x00, 0x01, 0x00, 0x00,
+ 	0x00, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_TCP_IL 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00,		/* 2 bytes for 4 bytes alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(pppoe_ipv4_udp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_PPPOE,		14 },
+ 	{ ICE_IPV4_OFOS,	22 },
+ 	{ ICE_UDP_ILOS,		42 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(pppoe_ipv4_udp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x88, 0x64,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x11, 0x00, 0x00, 0x00, /* ICE_PPPOE 14 */
+ 	0x00, 0x16,
+ 
+ 	0x00, 0x21,		/* PPP Link Layer 20 */
+ 
+ 	0x45, 0x00, 0x00, 0x1c, /* ICE_IPV4_OFOS 22 */
+ 	0x00, 0x01, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_UDP_ILOS 42 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00,		/* 2 bytes for 4 bytes alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(pppoe_ipv6_tcp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_PPPOE,		14 },
+ 	{ ICE_IPV6_OFOS,	22 },
+ 	{ ICE_TCP_IL,		62 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(pppoe_ipv6_tcp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x88, 0x64,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x11, 0x00, 0x00, 0x00, /* ICE_PPPOE 14 */
+ 	0x00, 0x2a,
+ 
+ 	0x00, 0x57,		/* PPP Link Layer 20 */
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* ICE_IPV6_OFOS 22 */
+ 	0x00, 0x14, 0x06, 0x00, /* Next header is TCP */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_TCP_IL 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00,		/* 2 bytes for 4 bytes alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(pppoe_ipv6_udp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_ETYPE_OL,		12 },
+ 	{ ICE_PPPOE,		14 },
+ 	{ ICE_IPV6_OFOS,	22 },
+ 	{ ICE_UDP_ILOS,		62 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(pppoe_ipv6_udp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x88, 0x64,		/* ICE_ETYPE_OL 12 */
+ 
+ 	0x11, 0x00, 0x00, 0x00, /* ICE_PPPOE 14 */
+ 	0x00, 0x2a,
+ 
+ 	0x00, 0x57,		/* PPP Link Layer 20 */
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* ICE_IPV6_OFOS 22 */
+ 	0x00, 0x08, 0x11, 0x00, /* Next header UDP*/
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_UDP_ILOS 62 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00,		/* 2 bytes for 4 bytes alignment */
+ };
+ 
+ static const struct ice_dummy_pkt_profile ice_dummy_pkt_profiles[] = {
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPU | ICE_PKT_OUTER_IPV6 |
+ 				  ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPU | ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU),
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPC | ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPC),
+ 	ICE_PKT_PROFILE(pppoe_ipv6_udp, ICE_PKT_PPPOE | ICE_PKT_OUTER_IPV6 |
+ 					ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(pppoe_ipv6_tcp, ICE_PKT_PPPOE | ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(pppoe_ipv4_udp, ICE_PKT_PPPOE | ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(pppoe_ipv4_tcp, ICE_PKT_PPPOE),
+ 	ICE_PKT_PROFILE(gre_ipv6_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6 |
+ 				      ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_ipv6_udp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(gre_udp, ICE_PKT_TUN_NVGRE),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_tcp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6 |
+ 					  ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_tcp, ICE_PKT_TUN_UDP | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_udp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(udp_tun_udp, ICE_PKT_TUN_UDP),
+ 	ICE_PKT_PROFILE(udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(udp, ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(tcp_ipv6, ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(tcp, 0),
+ };
+ 
+ #define ICE_SW_RULE_RX_TX_HDR_SIZE(s, l)	struct_size((s), hdr_data, (l))
+ #define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s)	\
+ 	ICE_SW_RULE_RX_TX_HDR_SIZE((s), DUMMY_ETH_HDR_LEN)
+ #define ICE_SW_RULE_RX_TX_NO_HDR_SIZE(s)	\
+ 	ICE_SW_RULE_RX_TX_HDR_SIZE((s), 0)
+ #define ICE_SW_RULE_LG_ACT_SIZE(s, n)		struct_size((s), act, (n))
+ #define ICE_SW_RULE_VSI_LIST_SIZE(s, n)		struct_size((s), vsi, (n))
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  
  /* this is a recipe to profile association bitmap */
  static DECLARE_BITMAP(recipe_to_profile[ICE_MAX_NUM_RECIPES],
@@@ -4493,6 -4634,9 +4717,12 @@@ static const struct ice_prot_ext_tbl_en
  	{ ICE_NVGRE,		{ 0, 2, 4, 6 } },
  	{ ICE_GTP,		{ 8, 10, 12, 14, 16, 18, 20, 22 } },
  	{ ICE_GTP_NO_PAY,	{ 8, 10, 12, 14 } },
++<<<<<<< HEAD
++=======
+ 	{ ICE_PPPOE,		{ 0, 2, 4, 6 } },
+ 	{ ICE_VLAN_EX,          { 2, 0 } },
+ 	{ ICE_VLAN_IN,          { 2, 0 } },
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  };
  
  static struct ice_protocol_entry ice_prot_id_tbl[ICE_PROTOCOL_LAST] = {
@@@ -4513,6 -4657,9 +4743,12 @@@
  	{ ICE_NVGRE,		ICE_GRE_OF_HW },
  	{ ICE_GTP,		ICE_UDP_OF_HW },
  	{ ICE_GTP_NO_PAY,	ICE_UDP_ILOS_HW },
++<<<<<<< HEAD
++=======
+ 	{ ICE_PPPOE,		ICE_PPPOE_HW },
+ 	{ ICE_VLAN_EX,          ICE_VLAN_OF_HW },
+ 	{ ICE_VLAN_IN,          ICE_VLAN_OL_HW },
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  };
  
  /**
@@@ -5462,178 -5731,26 +5698,188 @@@ ice_find_dummy_packet(struct ice_adv_lk
  				cpu_to_be16(ICE_IPV6_ETHER_ID) &&
  			 lkups[i].m_u.ethertype.ethtype_id ==
  				cpu_to_be16(0xFFFF))
 -			match |= ICE_PKT_INNER_IPV6;
 +			inner_ipv6 = true;
  		else if (lkups[i].type == ICE_IPV6_IL)
 -			match |= ICE_PKT_INNER_IPV6;
 +			inner_ipv6 = true;
  		else if (lkups[i].type == ICE_GTP_NO_PAY)
++<<<<<<< HEAD
 +			gtp_no_pay = true;
++=======
+ 			match |= ICE_PKT_GTP_NOPAY;
+ 		else if (lkups[i].type == ICE_PPPOE) {
+ 			match |= ICE_PKT_PPPOE;
+ 			if (lkups[i].h_u.pppoe_hdr.ppp_prot_id ==
+ 			    htons(PPP_IPV6))
+ 				match |= ICE_PKT_OUTER_IPV6;
+ 		}
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  	}
  
 -	while (ret->match && (match & ret->match) != ret->match)
 -		ret++;
 +	if (tun_type == ICE_SW_TUN_GTPU) {
 +		if (outer_ipv6) {
 +			if (gtp_no_pay) {
 +				*pkt = dummy_ipv6_gtp_packet;
 +				*pkt_len = sizeof(dummy_ipv6_gtp_packet);
 +				*offsets = dummy_ipv6_gtp_no_pay_packet_offsets;
 +			} else if (inner_ipv6) {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv6_gtpu_ipv6_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv6_gtpu_ipv6_udp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv6_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv6_gtpu_ipv6_tcp_packet;
 +					*pkt_len = sizeof(dummy_ipv6_gtpu_ipv6_tcp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv6_tcp_packet_offsets;
 +				}
 +			} else {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv6_gtpu_ipv4_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv6_gtpu_ipv4_udp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv4_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv6_gtpu_ipv4_tcp_packet;
 +				*pkt_len = sizeof(dummy_ipv6_gtpu_ipv4_tcp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv4_tcp_packet_offsets;
 +				}
 +			}
 +		} else {
 +			if (gtp_no_pay) {
 +				*pkt = dummy_ipv4_gtpu_ipv4_packet;
 +				*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_packet);
 +				*offsets = dummy_ipv4_gtp_no_pay_packet_offsets;
 +			} else if (inner_ipv6) {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv4_gtpu_ipv6_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv6_udp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv6_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv4_gtpu_ipv6_tcp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv6_tcp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv6_tcp_packet_offsets;
 +				}
 +			} else {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv4_gtpu_ipv4_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_udp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv4_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv4_gtpu_ipv4_tcp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_tcp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv4_tcp_packet_offsets;
 +				}
 +			}
 +		}
 +		return;
 +	}
  
 -	if (vlan_count != 0)
 -		ret = ice_dummy_packet_add_vlan(ret, vlan_count);
 +	if (tun_type == ICE_SW_TUN_GTPC) {
 +		if (outer_ipv6) {
 +			*pkt = dummy_ipv6_gtp_packet;
 +			*pkt_len = sizeof(dummy_ipv6_gtp_packet);
 +			*offsets = dummy_ipv6_gtp_no_pay_packet_offsets;
 +		} else {
 +			*pkt = dummy_ipv4_gtpu_ipv4_packet;
 +			*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_packet);
 +			*offsets = dummy_ipv4_gtp_no_pay_packet_offsets;
 +		}
 +		return;
 +	}
  
 -	return ret;
 +	if (tun_type == ICE_SW_TUN_NVGRE) {
 +		if (inner_tcp && inner_ipv6) {
 +			*pkt = dummy_gre_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_tcp_packet);
 +			*offsets = dummy_gre_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_tcp) {
 +			*pkt = dummy_gre_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_tcp_packet);
 +			*offsets = dummy_gre_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_ipv6) {
 +			*pkt = dummy_gre_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_udp_packet);
 +			*offsets = dummy_gre_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_gre_udp_packet;
 +		*pkt_len = sizeof(dummy_gre_udp_packet);
 +		*offsets = dummy_gre_udp_packet_offsets;
 +		return;
 +	}
 +
 +	if (tun_type == ICE_SW_TUN_VXLAN ||
 +	    tun_type == ICE_SW_TUN_GENEVE) {
 +		if (inner_tcp && inner_ipv6) {
 +			*pkt = dummy_udp_tun_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_tcp_packet);
 +			*offsets = dummy_udp_tun_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_tcp) {
 +			*pkt = dummy_udp_tun_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_tcp_packet);
 +			*offsets = dummy_udp_tun_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_ipv6) {
 +			*pkt = dummy_udp_tun_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_udp_packet);
 +			*offsets = dummy_udp_tun_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_tun_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_tun_udp_packet);
 +		*offsets = dummy_udp_tun_udp_packet_offsets;
 +		return;
 +	}
 +
 +	if (inner_udp && !outer_ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_packet);
 +			*offsets = dummy_vlan_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_packet);
 +		*offsets = dummy_udp_packet_offsets;
 +		return;
 +	} else if (inner_udp && outer_ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_ipv6_packet);
 +			*offsets = dummy_vlan_udp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_udp_ipv6_packet);
 +		*offsets = dummy_udp_ipv6_packet_offsets;
 +		return;
 +	} else if ((inner_tcp && outer_ipv6) || outer_ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_tcp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_tcp_ipv6_packet);
 +			*offsets = dummy_vlan_tcp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_tcp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_tcp_ipv6_packet);
 +		*offsets = dummy_tcp_ipv6_packet_offsets;
 +		return;
 +	}
 +
 +	if (vlan) {
 +		*pkt = dummy_vlan_tcp_packet;
 +		*pkt_len = sizeof(dummy_vlan_tcp_packet);
 +		*offsets = dummy_vlan_tcp_packet_offsets;
 +	} else {
 +		*pkt = dummy_tcp_packet;
 +		*pkt_len = sizeof(dummy_tcp_packet);
 +		*offsets = dummy_tcp_packet_offsets;
 +	}
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_tc_lib.c
index 9cff21f0acdb,a298862857a8..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_tc_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_tc_lib.c
@@@ -50,6 -50,15 +50,18 @@@ ice_tc_count_lkups(u32 flags, struct ic
  	if (flags & ICE_TC_FLWR_FIELD_VLAN)
  		lkups_cnt++;
  
++<<<<<<< HEAD
++=======
+ 	/* is CVLAN specified? */
+ 	if (flags & ICE_TC_FLWR_FIELD_CVLAN)
+ 		lkups_cnt++;
+ 
+ 	/* are PPPoE options specified? */
+ 	if (flags & (ICE_TC_FLWR_FIELD_PPPOE_SESSID |
+ 		     ICE_TC_FLWR_FIELD_PPP_PROTO))
+ 		lkups_cnt++;
+ 
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  	/* are IPv[4|6] fields specified? */
  	if (flags & (ICE_TC_FLWR_FIELD_DEST_IPV4 | ICE_TC_FLWR_FIELD_SRC_IPV4 |
  		     ICE_TC_FLWR_FIELD_DEST_IPV6 | ICE_TC_FLWR_FIELD_SRC_IPV6))
@@@ -317,6 -348,35 +329,38 @@@ ice_tc_fill_rules(struct ice_hw *hw, u3
  		i++;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (flags & ICE_TC_FLWR_FIELD_CVLAN) {
+ 		list[i].type = ICE_VLAN_IN;
+ 		list[i].h_u.vlan_hdr.vlan = headers->cvlan_hdr.vlan_id;
+ 		list[i].m_u.vlan_hdr.vlan = cpu_to_be16(0xFFFF);
+ 		i++;
+ 	}
+ 
+ 	if (flags & (ICE_TC_FLWR_FIELD_PPPOE_SESSID |
+ 		     ICE_TC_FLWR_FIELD_PPP_PROTO)) {
+ 		struct ice_pppoe_hdr *vals, *masks;
+ 
+ 		vals = &list[i].h_u.pppoe_hdr;
+ 		masks = &list[i].m_u.pppoe_hdr;
+ 
+ 		list[i].type = ICE_PPPOE;
+ 
+ 		if (flags & ICE_TC_FLWR_FIELD_PPPOE_SESSID) {
+ 			vals->session_id = headers->pppoe_hdr.session_id;
+ 			masks->session_id = cpu_to_be16(0xFFFF);
+ 		}
+ 
+ 		if (flags & ICE_TC_FLWR_FIELD_PPP_PROTO) {
+ 			vals->ppp_prot_id = headers->pppoe_hdr.ppp_proto;
+ 			masks->ppp_prot_id = cpu_to_be16(0xFFFF);
+ 		}
+ 
+ 		i++;
+ 	}
+ 
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  	/* copy L3 (IPv[4|6]: src, dest) address */
  	if (flags & (ICE_TC_FLWR_FIELD_DEST_IPV4 |
  		     ICE_TC_FLWR_FIELD_SRC_IPV4)) {
@@@ -1059,8 -1147,52 +1129,24 @@@ ice_parse_cls_flower(struct net_device 
  				cpu_to_be16(match.key->vlan_id & VLAN_VID_MASK);
  		if (match.mask->vlan_priority)
  			headers->vlan_hdr.vlan_prio = match.key->vlan_priority;
 -		if (match.mask->vlan_tpid)
 -			headers->vlan_hdr.vlan_tpid = match.key->vlan_tpid;
 -	}
 -
 -	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {
 -		struct flow_match_vlan match;
 -
 -		if (!ice_is_dvm_ena(&vsi->back->hw)) {
 -			NL_SET_ERR_MSG_MOD(fltr->extack, "Double VLAN mode is not enabled");
 -			return -EINVAL;
 -		}
 -
 -		flow_rule_match_cvlan(rule, &match);
 -
 -		if (match.mask->vlan_id) {
 -			if (match.mask->vlan_id == VLAN_VID_MASK) {
 -				fltr->flags |= ICE_TC_FLWR_FIELD_CVLAN;
 -			} else {
 -				NL_SET_ERR_MSG_MOD(fltr->extack,
 -						   "Bad CVLAN mask");
 -				return -EINVAL;
 -			}
 -		}
 -
 -		headers->cvlan_hdr.vlan_id =
 -				cpu_to_be16(match.key->vlan_id & VLAN_VID_MASK);
 -		if (match.mask->vlan_priority)
 -			headers->cvlan_hdr.vlan_prio = match.key->vlan_priority;
  	}
  
+ 	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PPPOE)) {
+ 		struct flow_match_pppoe match;
+ 
+ 		flow_rule_match_pppoe(rule, &match);
+ 		n_proto_key = ice_tc_set_pppoe(&match, fltr, headers);
+ 
+ 		/* If ethertype equals ETH_P_PPP_SES, n_proto might be
+ 		 * overwritten by encapsulated protocol (ppp_proto field) or set
+ 		 * to 0. To correct this, flow_match_pppoe provides the type
+ 		 * field, which contains the actual ethertype (ETH_P_PPP_SES).
+ 		 */
+ 		headers->l2_key.n_proto = cpu_to_be16(n_proto_key);
+ 		headers->l2_mask.n_proto = cpu_to_be16(0xFFFF);
+ 		fltr->flags |= ICE_TC_FLWR_FIELD_ETH_TYPE_ID;
+ 	}
+ 
  	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {
  		struct flow_match_control match;
  
diff --cc drivers/net/ethernet/intel/ice/ice_tc_lib.h
index e25e958f4396,91cd3d3778c7..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_tc_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_tc_lib.h
@@@ -23,6 -23,9 +23,12 @@@
  #define ICE_TC_FLWR_FIELD_ENC_DST_MAC		BIT(16)
  #define ICE_TC_FLWR_FIELD_ETH_TYPE_ID		BIT(17)
  #define ICE_TC_FLWR_FIELD_ENC_OPTS		BIT(18)
++<<<<<<< HEAD
++=======
+ #define ICE_TC_FLWR_FIELD_CVLAN			BIT(19)
+ #define ICE_TC_FLWR_FIELD_PPPOE_SESSID		BIT(20)
+ #define ICE_TC_FLWR_FIELD_PPP_PROTO		BIT(21)
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  
  #define ICE_TC_FLOWER_MASK_32   0xFFFFFFFF
  
@@@ -40,8 -43,14 +46,13 @@@ struct ice_tc_flower_action 
  struct ice_tc_vlan_hdr {
  	__be16 vlan_id; /* Only last 12 bits valid */
  	u16 vlan_prio; /* Only last 3 bits valid (valid values: 0..7) */
 -	__be16 vlan_tpid;
  };
  
+ struct ice_tc_pppoe_hdr {
+ 	__be16 session_id;
+ 	__be16 ppp_proto;
+ };
+ 
  struct ice_tc_l2_hdr {
  	u8 dst_mac[ETH_ALEN];
  	u8 src_mac[ETH_ALEN];
@@@ -81,6 -90,8 +92,11 @@@ struct ice_tc_flower_lyr_2_4_hdrs 
  	struct ice_tc_l2_hdr l2_key;
  	struct ice_tc_l2_hdr l2_mask;
  	struct ice_tc_vlan_hdr vlan_hdr;
++<<<<<<< HEAD
++=======
+ 	struct ice_tc_vlan_hdr cvlan_hdr;
+ 	struct ice_tc_pppoe_hdr pppoe_hdr;
++>>>>>>> cd8efeeed16e (ice: Add support for PPPoE hardware offload)
  	/* L3 (IPv4[6]) layer fields with their mask */
  	struct ice_tc_l3_hdr l3_key;
  	struct ice_tc_l3_hdr l3_mask;
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
diff --git a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
index 3b4ddb8c0864..e43c3aa7aa80 100644
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
@@ -1860,8 +1860,11 @@ ice_get_sw_fv_list(struct ice_hw *hw, struct ice_prot_lkup_ext *lkups,
 			}
 		}
 	} while (fv);
-	if (list_empty(fv_list))
+	if (list_empty(fv_list)) {
+		dev_warn(ice_hw_to_dev(hw), "Required profiles not found in currently loaded DDP package");
 		return -EIO;
+	}
+
 	return 0;
 
 err:
* Unmerged path drivers/net/ethernet/intel/ice/ice_protocol_type.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_tc_lib.h
