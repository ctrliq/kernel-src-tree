drm/amdkfd:Fix fw version for 10.3.6

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jesse Zhang <Jesse.Zhang@amd.com>
commit a956a11ee669d069047525c8ec897b4c21a9cda1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/a956a11e.failed

fix fw error when loading fw for 10.3.6

	Signed-off-by: Jesse Zhang <Jesse.Zhang@amd.com>
	Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
	Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
	Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
	Cc: stable@vger.kernel.org # 5.18.x
(cherry picked from commit a956a11ee669d069047525c8ec897b4c21a9cda1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdkfd/kfd_device.c
diff --cc drivers/gpu/drm/amd/amdkfd/kfd_device.c
index 900ea693c71c,bf4200457772..000000000000
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
@@@ -642,25 -61,354 +642,323 @@@ static void kfd_gtt_sa_fini(struct kfd_
  
  static int kfd_resume(struct kfd_dev *kfd);
  
 -static void kfd_device_info_set_sdma_info(struct kfd_dev *kfd)
 +struct kfd_dev *kgd2kfd_probe(struct kgd_dev *kgd,
 +	struct pci_dev *pdev, unsigned int asic_type, bool vf)
  {
 -	uint32_t sdma_version = kfd->adev->ip_versions[SDMA0_HWIP][0];
 -
 -	switch (sdma_version) {
 -	case IP_VERSION(4, 0, 0):/* VEGA10 */
 -	case IP_VERSION(4, 0, 1):/* VEGA12 */
 -	case IP_VERSION(4, 1, 0):/* RAVEN */
 -	case IP_VERSION(4, 1, 1):/* RAVEN */
 -	case IP_VERSION(4, 1, 2):/* RENOIR */
 -	case IP_VERSION(5, 2, 1):/* VANGOGH */
 -	case IP_VERSION(5, 2, 3):/* YELLOW_CARP */
 -	case IP_VERSION(5, 2, 6):/* GC 10.3.6 */
 -	case IP_VERSION(5, 2, 7):/* GC 10.3.7 */
 -	case IP_VERSION(6, 0, 1):
 -		kfd->device_info.num_sdma_queues_per_engine = 2;
 -		break;
 -	case IP_VERSION(4, 2, 0):/* VEGA20 */
 -	case IP_VERSION(4, 2, 2):/* ARCTURUS */
 -	case IP_VERSION(4, 4, 0):/* ALDEBARAN */
 -	case IP_VERSION(5, 0, 0):/* NAVI10 */
 -	case IP_VERSION(5, 0, 1):/* CYAN_SKILLFISH */
 -	case IP_VERSION(5, 0, 2):/* NAVI14 */
 -	case IP_VERSION(5, 0, 5):/* NAVI12 */
 -	case IP_VERSION(5, 2, 0):/* SIENNA_CICHLID */
 -	case IP_VERSION(5, 2, 2):/* NAVY_FLOUNDER */
 -	case IP_VERSION(5, 2, 4):/* DIMGREY_CAVEFISH */
 -	case IP_VERSION(5, 2, 5):/* BEIGE_GOBY */
 -	case IP_VERSION(6, 0, 0):
 -	case IP_VERSION(6, 0, 2):
 -		kfd->device_info.num_sdma_queues_per_engine = 8;
 -		break;
 -	default:
 -		dev_warn(kfd_device,
 -			"Default sdma queue per engine(8) is set due to mismatch of sdma ip block(SDMA_HWIP:0x%x).\n",
 -			sdma_version);
 -		kfd->device_info.num_sdma_queues_per_engine = 8;
 +	struct kfd_dev *kfd;
 +	const struct kfd_device_info *device_info;
 +	const struct kfd2kgd_calls *f2g;
 +
 +	if (asic_type >= sizeof(kfd_supported_devices) / (sizeof(void *) * 2)
 +		|| asic_type >= sizeof(kfd2kgd_funcs) / sizeof(void *)) {
 +		dev_err(kfd_device, "asic_type %d out of range\n", asic_type);
 +		return NULL; /* asic_type out of range */
  	}
  
 -	switch (sdma_version) {
 -	case IP_VERSION(6, 0, 0):
 -	case IP_VERSION(6, 0, 1):
 -	case IP_VERSION(6, 0, 2):
 -		/* Reserve 1 for paging and 1 for gfx */
 -		kfd->device_info.num_reserved_sdma_queues_per_engine = 2;
 -		/* BIT(0)=engine-0 queue-0; BIT(1)=engine-1 queue-0; BIT(2)=engine-0 queue-1; ... */
 -		kfd->device_info.reserved_sdma_queues_bitmap = 0xFULL;
 -		break;
 -	default:
 -		break;
 -	}
 -}
 +	device_info = kfd_supported_devices[asic_type][vf];
 +	f2g = kfd2kgd_funcs[asic_type];
  
++<<<<<<< HEAD
 +	if (!device_info || !f2g) {
 +		dev_err(kfd_device, "%s %s not supported in kfd\n",
 +			amdgpu_asic_name[asic_type], vf ? "VF" : "");
++=======
+ static void kfd_device_info_set_event_interrupt_class(struct kfd_dev *kfd)
+ {
+ 	uint32_t gc_version = KFD_GC_VERSION(kfd);
+ 
+ 	switch (gc_version) {
+ 	case IP_VERSION(9, 0, 1): /* VEGA10 */
+ 	case IP_VERSION(9, 1, 0): /* RAVEN */
+ 	case IP_VERSION(9, 2, 1): /* VEGA12 */
+ 	case IP_VERSION(9, 2, 2): /* RAVEN */
+ 	case IP_VERSION(9, 3, 0): /* RENOIR */
+ 	case IP_VERSION(9, 4, 0): /* VEGA20 */
+ 	case IP_VERSION(9, 4, 1): /* ARCTURUS */
+ 	case IP_VERSION(9, 4, 2): /* ALDEBARAN */
+ 	case IP_VERSION(10, 3, 1): /* VANGOGH */
+ 	case IP_VERSION(10, 3, 3): /* YELLOW_CARP */
+ 	case IP_VERSION(10, 3, 6): /* GC 10.3.6 */
+ 	case IP_VERSION(10, 3, 7): /* GC 10.3.7 */
+ 	case IP_VERSION(10, 1, 3): /* CYAN_SKILLFISH */
+ 	case IP_VERSION(10, 1, 4):
+ 	case IP_VERSION(10, 1, 10): /* NAVI10 */
+ 	case IP_VERSION(10, 1, 2): /* NAVI12 */
+ 	case IP_VERSION(10, 1, 1): /* NAVI14 */
+ 	case IP_VERSION(10, 3, 0): /* SIENNA_CICHLID */
+ 	case IP_VERSION(10, 3, 2): /* NAVY_FLOUNDER */
+ 	case IP_VERSION(10, 3, 4): /* DIMGREY_CAVEFISH */
+ 	case IP_VERSION(10, 3, 5): /* BEIGE_GOBY */
+ 		kfd->device_info.event_interrupt_class = &event_interrupt_class_v9;
+ 		break;
+ 	case IP_VERSION(11, 0, 0):
+ 	case IP_VERSION(11, 0, 1):
+ 	case IP_VERSION(11, 0, 2):
+ 		kfd->device_info.event_interrupt_class = &event_interrupt_class_v11;
+ 		break;
+ 	default:
+ 		dev_warn(kfd_device, "v9 event interrupt handler is set due to "
+ 			"mismatch of gc ip block(GC_HWIP:0x%x).\n", gc_version);
+ 		kfd->device_info.event_interrupt_class = &event_interrupt_class_v9;
+ 	}
+ }
+ 
+ static void kfd_device_info_init(struct kfd_dev *kfd,
+ 				 bool vf, uint32_t gfx_target_version)
+ {
+ 	uint32_t gc_version = KFD_GC_VERSION(kfd);
+ 	uint32_t asic_type = kfd->adev->asic_type;
+ 
+ 	kfd->device_info.max_pasid_bits = 16;
+ 	kfd->device_info.max_no_of_hqd = 24;
+ 	kfd->device_info.num_of_watch_points = 4;
+ 	kfd->device_info.mqd_size_aligned = MQD_SIZE_ALIGNED;
+ 	kfd->device_info.gfx_target_version = gfx_target_version;
+ 
+ 	if (KFD_IS_SOC15(kfd)) {
+ 		kfd->device_info.doorbell_size = 8;
+ 		kfd->device_info.ih_ring_entry_size = 8 * sizeof(uint32_t);
+ 		kfd->device_info.supports_cwsr = true;
+ 
+ 		kfd_device_info_set_sdma_info(kfd);
+ 
+ 		kfd_device_info_set_event_interrupt_class(kfd);
+ 
+ 		/* Raven */
+ 		if (gc_version == IP_VERSION(9, 1, 0) ||
+ 		    gc_version == IP_VERSION(9, 2, 2))
+ 			kfd->device_info.needs_iommu_device = true;
+ 
+ 		if (gc_version < IP_VERSION(11, 0, 0)) {
+ 			/* Navi2x+, Navi1x+ */
+ 			if (gc_version == IP_VERSION(10, 3, 6))
+ 				kfd->device_info.no_atomic_fw_version = 14;
+ 			else if (gc_version >= IP_VERSION(10, 3, 0))
+ 				kfd->device_info.no_atomic_fw_version = 92;
+ 			else if (gc_version >= IP_VERSION(10, 1, 1))
+ 				kfd->device_info.no_atomic_fw_version = 145;
+ 
+ 			/* Navi1x+ */
+ 			if (gc_version >= IP_VERSION(10, 1, 1))
+ 				kfd->device_info.needs_pci_atomics = true;
+ 		}
+ 	} else {
+ 		kfd->device_info.doorbell_size = 4;
+ 		kfd->device_info.ih_ring_entry_size = 4 * sizeof(uint32_t);
+ 		kfd->device_info.event_interrupt_class = &event_interrupt_class_cik;
+ 		kfd->device_info.num_sdma_queues_per_engine = 2;
+ 
+ 		if (asic_type != CHIP_KAVERI &&
+ 		    asic_type != CHIP_HAWAII &&
+ 		    asic_type != CHIP_TONGA)
+ 			kfd->device_info.supports_cwsr = true;
+ 
+ 		if (asic_type == CHIP_KAVERI ||
+ 		    asic_type == CHIP_CARRIZO)
+ 			kfd->device_info.needs_iommu_device = true;
+ 
+ 		if (asic_type != CHIP_HAWAII && !vf)
+ 			kfd->device_info.needs_pci_atomics = true;
+ 	}
+ }
+ 
+ struct kfd_dev *kgd2kfd_probe(struct amdgpu_device *adev, bool vf)
+ {
+ 	struct kfd_dev *kfd = NULL;
+ 	const struct kfd2kgd_calls *f2g = NULL;
+ 	struct pci_dev *pdev = adev->pdev;
+ 	uint32_t gfx_target_version = 0;
+ 
+ 	switch (adev->asic_type) {
+ #ifdef KFD_SUPPORT_IOMMU_V2
+ #ifdef CONFIG_DRM_AMDGPU_CIK
+ 	case CHIP_KAVERI:
+ 		gfx_target_version = 70000;
+ 		if (!vf)
+ 			f2g = &gfx_v7_kfd2kgd;
+ 		break;
+ #endif
+ 	case CHIP_CARRIZO:
+ 		gfx_target_version = 80001;
+ 		if (!vf)
+ 			f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ #endif
+ #ifdef CONFIG_DRM_AMDGPU_CIK
+ 	case CHIP_HAWAII:
+ 		gfx_target_version = 70001;
+ 		if (!amdgpu_exp_hw_support)
+ 			pr_info(
+ 	"KFD support on Hawaii is experimental. See modparam exp_hw_support\n"
+ 				);
+ 		else if (!vf)
+ 			f2g = &gfx_v7_kfd2kgd;
+ 		break;
+ #endif
+ 	case CHIP_TONGA:
+ 		gfx_target_version = 80002;
+ 		if (!vf)
+ 			f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ 	case CHIP_FIJI:
+ 		gfx_target_version = 80003;
+ 		f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ 	case CHIP_POLARIS10:
+ 		gfx_target_version = 80003;
+ 		f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ 	case CHIP_POLARIS11:
+ 		gfx_target_version = 80003;
+ 		if (!vf)
+ 			f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ 	case CHIP_POLARIS12:
+ 		gfx_target_version = 80003;
+ 		if (!vf)
+ 			f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ 	case CHIP_VEGAM:
+ 		gfx_target_version = 80003;
+ 		if (!vf)
+ 			f2g = &gfx_v8_kfd2kgd;
+ 		break;
+ 	default:
+ 		switch (adev->ip_versions[GC_HWIP][0]) {
+ 		/* Vega 10 */
+ 		case IP_VERSION(9, 0, 1):
+ 			gfx_target_version = 90000;
+ 			f2g = &gfx_v9_kfd2kgd;
+ 			break;
+ #ifdef KFD_SUPPORT_IOMMU_V2
+ 		/* Raven */
+ 		case IP_VERSION(9, 1, 0):
+ 		case IP_VERSION(9, 2, 2):
+ 			gfx_target_version = 90002;
+ 			if (!vf)
+ 				f2g = &gfx_v9_kfd2kgd;
+ 			break;
+ #endif
+ 		/* Vega12 */
+ 		case IP_VERSION(9, 2, 1):
+ 			gfx_target_version = 90004;
+ 			if (!vf)
+ 				f2g = &gfx_v9_kfd2kgd;
+ 			break;
+ 		/* Renoir */
+ 		case IP_VERSION(9, 3, 0):
+ 			gfx_target_version = 90012;
+ 			if (!vf)
+ 				f2g = &gfx_v9_kfd2kgd;
+ 			break;
+ 		/* Vega20 */
+ 		case IP_VERSION(9, 4, 0):
+ 			gfx_target_version = 90006;
+ 			if (!vf)
+ 				f2g = &gfx_v9_kfd2kgd;
+ 			break;
+ 		/* Arcturus */
+ 		case IP_VERSION(9, 4, 1):
+ 			gfx_target_version = 90008;
+ 			f2g = &arcturus_kfd2kgd;
+ 			break;
+ 		/* Aldebaran */
+ 		case IP_VERSION(9, 4, 2):
+ 			gfx_target_version = 90010;
+ 			f2g = &aldebaran_kfd2kgd;
+ 			break;
+ 		/* Navi10 */
+ 		case IP_VERSION(10, 1, 10):
+ 			gfx_target_version = 100100;
+ 			if (!vf)
+ 				f2g = &gfx_v10_kfd2kgd;
+ 			break;
+ 		/* Navi12 */
+ 		case IP_VERSION(10, 1, 2):
+ 			gfx_target_version = 100101;
+ 			f2g = &gfx_v10_kfd2kgd;
+ 			break;
+ 		/* Navi14 */
+ 		case IP_VERSION(10, 1, 1):
+ 			gfx_target_version = 100102;
+ 			if (!vf)
+ 				f2g = &gfx_v10_kfd2kgd;
+ 			break;
+ 		/* Cyan Skillfish */
+ 		case IP_VERSION(10, 1, 3):
+ 		case IP_VERSION(10, 1, 4):
+ 			gfx_target_version = 100103;
+ 			if (!vf)
+ 				f2g = &gfx_v10_kfd2kgd;
+ 			break;
+ 		/* Sienna Cichlid */
+ 		case IP_VERSION(10, 3, 0):
+ 			gfx_target_version = 100300;
+ 			f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		/* Navy Flounder */
+ 		case IP_VERSION(10, 3, 2):
+ 			gfx_target_version = 100301;
+ 			f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		/* Van Gogh */
+ 		case IP_VERSION(10, 3, 1):
+ 			gfx_target_version = 100303;
+ 			if (!vf)
+ 				f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		/* Dimgrey Cavefish */
+ 		case IP_VERSION(10, 3, 4):
+ 			gfx_target_version = 100302;
+ 			f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		/* Beige Goby */
+ 		case IP_VERSION(10, 3, 5):
+ 			gfx_target_version = 100304;
+ 			f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		/* Yellow Carp */
+ 		case IP_VERSION(10, 3, 3):
+ 			gfx_target_version = 100305;
+ 			if (!vf)
+ 				f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		case IP_VERSION(10, 3, 6):
+ 			gfx_target_version = 100306;
+ 			if (!vf)
+ 				f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		case IP_VERSION(10, 3, 7):
+ 			gfx_target_version = 100307;
+ 			if (!vf)
+ 				f2g = &gfx_v10_3_kfd2kgd;
+ 			break;
+ 		case IP_VERSION(11, 0, 0):
+ 			gfx_target_version = 110000;
+ 			f2g = &gfx_v11_kfd2kgd;
+ 			break;
+ 		case IP_VERSION(11, 0, 1):
+ 			gfx_target_version = 110003;
+ 			f2g = &gfx_v11_kfd2kgd;
+ 			break;
+ 		case IP_VERSION(11, 0, 2):
+ 			gfx_target_version = 110002;
+ 			f2g = &gfx_v11_kfd2kgd;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	}
+ 
+ 	if (!f2g) {
+ 		if (adev->ip_versions[GC_HWIP][0])
+ 			dev_err(kfd_device, "GC IP %06x %s not supported in kfd\n",
+ 				adev->ip_versions[GC_HWIP][0], vf ? "VF" : "");
+ 		else
+ 			dev_err(kfd_device, "%s %s not supported in kfd\n",
+ 				amdgpu_asic_name[adev->asic_type], vf ? "VF" : "");
++>>>>>>> a956a11ee669 (drm/amdkfd:Fix fw version for 10.3.6)
  		return NULL;
  	}
  
* Unmerged path drivers/gpu/drm/amd/amdkfd/kfd_device.c
