tcp: add a missing nf_reset_ct() in 3WHS handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 6f0012e35160cd08a53e46e3b3bbf724b92dfe68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6f0012e3.failed

When the third packet of 3WHS connection establishment
contains payload, it is added into socket receive queue
without the XFRM check and the drop of connection tracking
context.

This means that if the data is left unread in the socket
receive queue, conntrack module can not be unloaded.

As most applications usually reads the incoming data
immediately after accept(), bug has been hiding for
quite a long time.

Commit 68822bdf76f1 ("net: generalize skb freeing
deferral to per-cpu lists") exposed this bug because
even if the application reads this data, the skb
with nfct state could stay in a per-cpu cache for
an arbitrary time, if said cpu no longer process RX softirqs.

Many thanks to Ilya Maximets for reporting this issue,
and for testing various patches:
https://lore.kernel.org/netdev/20220619003919.394622-1-i.maximets@ovn.org/

Note that I also added a missing xfrm4_policy_check() call,
although this is probably not a big issue, as the SYN
packet should have been dropped earlier.

Fixes: b59c270104f0 ("[NETFILTER]: Keep conntrack reference until IPsec policy checks are done")
	Reported-by: Ilya Maximets <i.maximets@ovn.org>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Florian Westphal <fw@strlen.de>
	Cc: Pablo Neira Ayuso <pablo@netfilter.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Tested-by: Ilya Maximets <i.maximets@ovn.org>
	Reviewed-by: Ilya Maximets <i.maximets@ovn.org>
Link: https://lore.kernel.org/r/20220623050436.1290307-1-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 6f0012e35160cd08a53e46e3b3bbf724b92dfe68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_ipv4.c
diff --cc net/ipv4/tcp_ipv4.c
index 95c80d8a7e12,da5a3c44c4fb..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1913,7 -1964,13 +1913,17 @@@ process
  		struct sock *nsk;
  
  		sk = req->rsk_listener;
++<<<<<<< HEAD
 +		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))) {
++=======
+ 		if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
+ 			drop_reason = SKB_DROP_REASON_XFRM_POLICY;
+ 		else
+ 			drop_reason = tcp_inbound_md5_hash(sk, skb,
+ 						   &iph->saddr, &iph->daddr,
+ 						   AF_INET, dif, sdif);
+ 		if (unlikely(drop_reason)) {
++>>>>>>> 6f0012e35160 (tcp: add a missing nf_reset_ct() in 3WHS handling)
  			sk_drops_add(sk, skb);
  			reqsk_put(req);
  			goto discard_it;
* Unmerged path net/ipv4/tcp_ipv4.c
