iommu/dma: Fix race condition during iova_domain initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Yunfei Wang <yf.wang@mediatek.com>
commit ac9a5d522bb80be50ea84965699e1c8257d745ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ac9a5d52.failed

When many devices share the same iova domain, iommu_dma_init_domain()
may be called at the same time. The checking of iovad->start_pfn will
all get false in iommu_dma_init_domain() and both enter init_iova_domain()
to do iovad initialization.

Fix this by protecting init_iova_domain() with iommu_dma_cookie->mutex.

Exception backtrace:
rb_insert_color(param1=0xFFFFFF80CD2BDB40, param3=1) + 64
init_iova_domain() + 180
iommu_setup_dma_ops() + 260
arch_setup_dma_ops() + 132
of_dma_configure_id() + 468
platform_dma_configure() + 32
really_probe() + 1168
driver_probe_device() + 268
__device_attach_driver() + 524
__device_attach() + 524
bus_probe_device() + 64
deferred_probe_work_func() + 260
process_one_work() + 580
worker_thread() + 1076
kthread() + 332
ret_from_fork() + 16

	Signed-off-by: Ning Li <ning.li@mediatek.com>
	Signed-off-by: Yunfei Wang <yf.wang@mediatek.com>
	Acked-by: Robin Murphy <robin.murphy@arm.com>
	Reviewed-by: Miles Chen <miles.chen@mediatek.com>
Link: https://lore.kernel.org/r/20220530120748.31733-1-yf.wang@mediatek.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit ac9a5d522bb80be50ea84965699e1c8257d745ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dma-iommu.c
diff --cc drivers/iommu/dma-iommu.c
index 223a46c79116,1910f4f1612b..000000000000
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@@ -379,17 -576,19 +384,27 @@@ static int iommu_dma_init_domain(struc
  	}
  
  	init_iova_domain(iovad, 1UL << order, base_pfn);
++<<<<<<< HEAD
++=======
+ 	ret = iova_domain_init_rcaches(iovad);
+ 	if (ret)
+ 		goto done_unlock;
 -
 -	/* If the FQ fails we can simply fall back to strict mode */
 -	if (domain->type == IOMMU_DOMAIN_DMA_FQ && iommu_dma_init_fq(domain))
 -		domain->type = IOMMU_DOMAIN_DMA;
++>>>>>>> ac9a5d522bb8 (iommu/dma: Fix race condition during iova_domain initialization)
 +
 +	if (!cookie->fq_domain && !dev_is_untrusted(dev) &&
 +	    domain->ops->flush_iotlb_all && !iommu_get_dma_strict(domain)) {
 +		if (init_iova_flush_queue(iovad, iommu_dma_flush_iotlb_all,
 +					  iommu_dma_entry_dtor))
 +			pr_warn("iova flush queue initialization failed\n");
 +		else
 +			cookie->fq_domain = domain;
 +	}
  
- 	return iova_reserve_iommu_regions(dev, domain);
+ 	ret = iova_reserve_iommu_regions(dev, domain);
+ 
+ done_unlock:
+ 	mutex_unlock(&cookie->mutex);
+ 	return ret;
  }
  
  /**
* Unmerged path drivers/iommu/dma-iommu.c
