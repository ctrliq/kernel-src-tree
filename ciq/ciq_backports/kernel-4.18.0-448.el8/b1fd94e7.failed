netfilter: use get_random_u32 instead of prandom

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Florian Westphal <fw@strlen.de>
commit b1fd94e704571f98b21027340eecf821b2bdffba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b1fd94e7.failed

bh might occur while updating per-cpu rnd_state from user context,
ie. local_out path.

BUG: using smp_processor_id() in preemptible [00000000] code: nginx/2725
caller is nft_ng_random_eval+0x24/0x54 [nft_numgen]
Call Trace:
 check_preemption_disabled+0xde/0xe0
 nft_ng_random_eval+0x24/0x54 [nft_numgen]

Use the random driver instead, this also avoids need for local prandom
state. Moreover, prandom now uses the random driver since d4150779e60f
("random32: use real rng for non-deterministic randomness").

Based on earlier patch from Pablo Neira.

Fixes: 6b2faee0ca91 ("netfilter: nft_meta: place prandom handling in a helper")
Fixes: 978d8f9055c3 ("netfilter: nft_numgen: add map lookups for numgen random operations")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b1fd94e704571f98b21027340eecf821b2bdffba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_numgen.c
diff --cc net/netfilter/nft_meta.c
index 49ed3c423a10,55d2d49c3425..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -28,20 -28,284 +29,296 @@@
  
  #include <uapi/linux/netfilter_bridge.h> /* NF_BR_PRE_ROUTING */
  
 -#define NFT_META_SECS_PER_MINUTE	60
 -#define NFT_META_SECS_PER_HOUR		3600
 -#define NFT_META_SECS_PER_DAY		86400
 -#define NFT_META_DAYS_PER_WEEK		7
 +struct nft_meta {
 +	enum nft_meta_keys	key:8;
 +	union {
 +		enum nft_registers	dreg:8;
 +		enum nft_registers	sreg:8;
 +	};
 +};
 +
++<<<<<<< HEAD
 +static DEFINE_PER_CPU(struct rnd_state, nft_prandom_state);
 +
 +#ifdef CONFIG_NF_TABLES_BRIDGE
 +#include "../bridge/br_private.h"
 +#endif
  
++=======
+ static u8 nft_meta_weekday(void)
+ {
+ 	time64_t secs = ktime_get_real_seconds();
+ 	unsigned int dse;
+ 	u8 wday;
+ 
+ 	secs -= NFT_META_SECS_PER_MINUTE * sys_tz.tz_minuteswest;
+ 	dse = div_u64(secs, NFT_META_SECS_PER_DAY);
+ 	wday = (4 + dse) % NFT_META_DAYS_PER_WEEK;
+ 
+ 	return wday;
+ }
+ 
+ static u32 nft_meta_hour(time64_t secs)
+ {
+ 	struct tm tm;
+ 
+ 	time64_to_tm(secs, 0, &tm);
+ 
+ 	return tm.tm_hour * NFT_META_SECS_PER_HOUR
+ 		+ tm.tm_min * NFT_META_SECS_PER_MINUTE
+ 		+ tm.tm_sec;
+ }
+ 
+ static noinline_for_stack void
+ nft_meta_get_eval_time(enum nft_meta_keys key,
+ 		       u32 *dest)
+ {
+ 	switch (key) {
+ 	case NFT_META_TIME_NS:
+ 		nft_reg_store64(dest, ktime_get_real_ns());
+ 		break;
+ 	case NFT_META_TIME_DAY:
+ 		nft_reg_store8(dest, nft_meta_weekday());
+ 		break;
+ 	case NFT_META_TIME_HOUR:
+ 		*dest = nft_meta_hour(ktime_get_real_seconds());
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static noinline bool
+ nft_meta_get_eval_pkttype_lo(const struct nft_pktinfo *pkt,
+ 			     u32 *dest)
+ {
+ 	const struct sk_buff *skb = pkt->skb;
+ 
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		if (ipv4_is_multicast(ip_hdr(skb)->daddr))
+ 			nft_reg_store8(dest, PACKET_MULTICAST);
+ 		else
+ 			nft_reg_store8(dest, PACKET_BROADCAST);
+ 		break;
+ 	case NFPROTO_IPV6:
+ 		nft_reg_store8(dest, PACKET_MULTICAST);
+ 		break;
+ 	case NFPROTO_NETDEV:
+ 		switch (skb->protocol) {
+ 		case htons(ETH_P_IP): {
+ 			int noff = skb_network_offset(skb);
+ 			struct iphdr *iph, _iph;
+ 
+ 			iph = skb_header_pointer(skb, noff,
+ 						 sizeof(_iph), &_iph);
+ 			if (!iph)
+ 				return false;
+ 
+ 			if (ipv4_is_multicast(iph->daddr))
+ 				nft_reg_store8(dest, PACKET_MULTICAST);
+ 			else
+ 				nft_reg_store8(dest, PACKET_BROADCAST);
+ 
+ 			break;
+ 		}
+ 		case htons(ETH_P_IPV6):
+ 			nft_reg_store8(dest, PACKET_MULTICAST);
+ 			break;
+ 		default:
+ 			WARN_ON_ONCE(1);
+ 			return false;
+ 		}
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static noinline bool
+ nft_meta_get_eval_skugid(enum nft_meta_keys key,
+ 			 u32 *dest,
+ 			 const struct nft_pktinfo *pkt)
+ {
+ 	struct sock *sk = skb_to_full_sk(pkt->skb);
+ 	struct socket *sock;
+ 
+ 	if (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))
+ 		return false;
+ 
+ 	read_lock_bh(&sk->sk_callback_lock);
+ 	sock = sk->sk_socket;
+ 	if (!sock || !sock->file) {
+ 		read_unlock_bh(&sk->sk_callback_lock);
+ 		return false;
+ 	}
+ 
+ 	switch (key) {
+ 	case NFT_META_SKUID:
+ 		*dest = from_kuid_munged(sock_net(sk)->user_ns,
+ 					 sock->file->f_cred->fsuid);
+ 		break;
+ 	case NFT_META_SKGID:
+ 		*dest =	from_kgid_munged(sock_net(sk)->user_ns,
+ 					 sock->file->f_cred->fsgid);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	read_unlock_bh(&sk->sk_callback_lock);
+ 	return true;
+ }
+ 
+ #ifdef CONFIG_CGROUP_NET_CLASSID
+ static noinline bool
+ nft_meta_get_eval_cgroup(u32 *dest, const struct nft_pktinfo *pkt)
+ {
+ 	struct sock *sk = skb_to_full_sk(pkt->skb);
+ 
+ 	if (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))
+ 		return false;
+ 
+ 	*dest = sock_cgroup_classid(&sk->sk_cgrp_data);
+ 	return true;
+ }
+ #endif
+ 
+ static noinline bool nft_meta_get_eval_kind(enum nft_meta_keys key,
+ 					    u32 *dest,
+ 					    const struct nft_pktinfo *pkt)
+ {
+ 	const struct net_device *in = nft_in(pkt), *out = nft_out(pkt);
+ 
+ 	switch (key) {
+ 	case NFT_META_IIFKIND:
+ 		if (!in || !in->rtnl_link_ops)
+ 			return false;
+ 		strncpy((char *)dest, in->rtnl_link_ops->kind, IFNAMSIZ);
+ 		break;
+ 	case NFT_META_OIFKIND:
+ 		if (!out || !out->rtnl_link_ops)
+ 			return false;
+ 		strncpy((char *)dest, out->rtnl_link_ops->kind, IFNAMSIZ);
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static void nft_meta_store_ifindex(u32 *dest, const struct net_device *dev)
+ {
+ 	*dest = dev ? dev->ifindex : 0;
+ }
+ 
+ static void nft_meta_store_ifname(u32 *dest, const struct net_device *dev)
+ {
+ 	strncpy((char *)dest, dev ? dev->name : "", IFNAMSIZ);
+ }
+ 
+ static bool nft_meta_store_iftype(u32 *dest, const struct net_device *dev)
+ {
+ 	if (!dev)
+ 		return false;
+ 
+ 	nft_reg_store16(dest, dev->type);
+ 	return true;
+ }
+ 
+ static bool nft_meta_store_ifgroup(u32 *dest, const struct net_device *dev)
+ {
+ 	if (!dev)
+ 		return false;
+ 
+ 	*dest = dev->group;
+ 	return true;
+ }
+ 
+ static bool nft_meta_get_eval_ifname(enum nft_meta_keys key, u32 *dest,
+ 				     const struct nft_pktinfo *pkt)
+ {
+ 	switch (key) {
+ 	case NFT_META_IIFNAME:
+ 		nft_meta_store_ifname(dest, nft_in(pkt));
+ 		break;
+ 	case NFT_META_OIFNAME:
+ 		nft_meta_store_ifname(dest, nft_out(pkt));
+ 		break;
+ 	case NFT_META_IIF:
+ 		nft_meta_store_ifindex(dest, nft_in(pkt));
+ 		break;
+ 	case NFT_META_OIF:
+ 		nft_meta_store_ifindex(dest, nft_out(pkt));
+ 		break;
+ 	case NFT_META_IFTYPE:
+ 		if (!nft_meta_store_iftype(dest, pkt->skb->dev))
+ 			return false;
+ 		break;
+ 	case __NFT_META_IIFTYPE:
+ 		if (!nft_meta_store_iftype(dest, nft_in(pkt)))
+ 			return false;
+ 		break;
+ 	case NFT_META_OIFTYPE:
+ 		if (!nft_meta_store_iftype(dest, nft_out(pkt)))
+ 			return false;
+ 		break;
+ 	case NFT_META_IIFGROUP:
+ 		if (!nft_meta_store_ifgroup(dest, nft_in(pkt)))
+ 			return false;
+ 		break;
+ 	case NFT_META_OIFGROUP:
+ 		if (!nft_meta_store_ifgroup(dest, nft_out(pkt)))
+ 			return false;
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ #ifdef CONFIG_IP_ROUTE_CLASSID
+ static noinline bool
+ nft_meta_get_eval_rtclassid(const struct sk_buff *skb, u32 *dest)
+ {
+ 	const struct dst_entry *dst = skb_dst(skb);
+ 
+ 	if (!dst)
+ 		return false;
+ 
+ 	*dest = dst->tclassid;
+ 	return true;
+ }
+ #endif
+ 
+ static noinline u32 nft_meta_get_eval_sdif(const struct nft_pktinfo *pkt)
+ {
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		return inet_sdif(pkt->skb);
+ 	case NFPROTO_IPV6:
+ 		return inet6_sdif(pkt->skb);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static noinline void
+ nft_meta_get_eval_sdifname(u32 *dest, const struct nft_pktinfo *pkt)
+ {
+ 	u32 sdif = nft_meta_get_eval_sdif(pkt);
+ 	const struct net_device *dev;
+ 
+ 	dev = sdif ? dev_get_by_index_rcu(nft_net(pkt), sdif) : NULL;
+ 	nft_meta_store_ifname(dest, dev);
+ }
+ 
++>>>>>>> b1fd94e70457 (netfilter: use get_random_u32 instead of prandom)
  void nft_meta_get_eval(const struct nft_expr *expr,
  		       struct nft_regs *regs,
  		       const struct nft_pktinfo *pkt)
@@@ -196,56 -374,35 +473,61 @@@
  	case NFT_META_CPU:
  		*dest = raw_smp_processor_id();
  		break;
 +	case NFT_META_IIFGROUP:
 +		if (in == NULL)
 +			goto err;
 +		*dest = in->group;
 +		break;
 +	case NFT_META_OIFGROUP:
 +		if (out == NULL)
 +			goto err;
 +		*dest = out->group;
 +		break;
  #ifdef CONFIG_CGROUP_NET_CLASSID
  	case NFT_META_CGROUP:
 -		if (!nft_meta_get_eval_cgroup(dest, pkt))
 +		sk = skb_to_full_sk(skb);
 +		if (!sk || !sk_fullsock(sk) ||
 +		    !net_eq(nft_net(pkt), sock_net(sk)))
  			goto err;
 +		*dest = sock_cgroup_classid(&sk->sk_cgrp_data);
  		break;
  #endif
++<<<<<<< HEAD
 +	case NFT_META_PRANDOM: {
 +		struct rnd_state *state = this_cpu_ptr(&nft_prandom_state);
 +		*dest = prandom_u32_state(state);
++=======
+ 	case NFT_META_PRANDOM:
+ 		*dest = get_random_u32();
++>>>>>>> b1fd94e70457 (netfilter: use get_random_u32 instead of prandom)
  		break;
 +	}
  #ifdef CONFIG_XFRM
  	case NFT_META_SECPATH:
 -		nft_reg_store8(dest, secpath_exists(skb));
 +		nft_reg_store8(dest, !!skb->sp);
  		break;
 +#endif
 +#ifdef CONFIG_NF_TABLES_BRIDGE
 +	case NFT_META_BRI_IIFNAME:
 +		if (in == NULL || (p = br_port_get_rcu(in)) == NULL)
 +			goto err;
 +		strncpy((char *)dest, p->br->dev->name, IFNAMSIZ);
 +		return;
 +	case NFT_META_BRI_OIFNAME:
 +		if (out == NULL || (p = br_port_get_rcu(out)) == NULL)
 +			goto err;
 +		strncpy((char *)dest, p->br->dev->name, IFNAMSIZ);
 +		return;
  #endif
  	case NFT_META_IIFKIND:
 -	case NFT_META_OIFKIND:
 -		if (!nft_meta_get_eval_kind(priv->key, dest, pkt))
 +		if (in == NULL || in->rtnl_link_ops == NULL)
  			goto err;
 +		strncpy((char *)dest, in->rtnl_link_ops->kind, IFNAMSIZ);
  		break;
 -	case NFT_META_TIME_NS:
 -	case NFT_META_TIME_DAY:
 -	case NFT_META_TIME_HOUR:
 -		nft_meta_get_eval_time(priv->key, dest);
 -		break;
 -	case NFT_META_SDIF:
 -		*dest = nft_meta_get_eval_sdif(pkt);
 -		break;
 -	case NFT_META_SDIFNAME:
 -		nft_meta_get_eval_sdifname(dest, pkt);
 +	case NFT_META_OIFKIND:
 +		if (out == NULL || out->rtnl_link_ops == NULL)
 +			goto err;
 +		strncpy((char *)dest, out->rtnl_link_ops->kind, IFNAMSIZ);
  		break;
  	default:
  		WARN_ON(1);
diff --cc net/netfilter/nft_numgen.c
index 3cc1b3dc3c3c,45d3dc9e96f2..000000000000
--- a/net/netfilter/nft_numgen.c
+++ b/net/netfilter/nft_numgen.c
@@@ -17,12 -14,10 +18,10 @@@
  #include <net/netfilter/nf_tables.h>
  #include <net/netfilter/nf_tables_core.h>
  
- static DEFINE_PER_CPU(struct rnd_state, nft_numgen_prandom_state);
- 
  struct nft_ng_inc {
 -	u8			dreg;
 +	enum nft_registers      dreg:8;
  	u32			modulus;
 -	atomic_t		*counter;
 +	atomic_t		counter;
  	u32			offset;
  };
  
@@@ -142,12 -164,8 +138,17 @@@ static int nft_ng_random_init(const str
  	if (priv->offset + priv->modulus - 1 < priv->offset)
  		return -EOVERFLOW;
  
++<<<<<<< HEAD
 +	prandom_init_once(&nft_numgen_prandom_state);
 +
 +	priv->dreg = nft_parse_register(tb[NFTA_NG_DREG]);
 +
 +	return nft_validate_register_store(ctx, priv->dreg, NULL,
 +					   NFT_DATA_VALUE, sizeof(u32));
++=======
+ 	return nft_parse_register_store(ctx, tb[NFTA_NG_DREG], &priv->dreg,
+ 					NULL, NFT_DATA_VALUE, sizeof(u32));
++>>>>>>> b1fd94e70457 (netfilter: use get_random_u32 instead of prandom)
  }
  
  static int nft_ng_random_dump(struct sk_buff *skb, const struct nft_expr *expr)
* Unmerged path net/netfilter/nft_meta.c
* Unmerged path net/netfilter/nft_numgen.c
