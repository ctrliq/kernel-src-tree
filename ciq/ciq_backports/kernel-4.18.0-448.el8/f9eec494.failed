ath11k: Add support for targets without trustzone

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
commit f9eec4947add999e1251bf14365a48a655b786a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f9eec494.failed

Add the support to attach WCN6750 and map iommu domain
for targets which do not have the support of TrustZone.

Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00573-QCAMSLSWPLZ-1
Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-00192-QCAHKSWPL_SILICONZ-1

	Signed-off-by: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
	Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
Link: https://lore.kernel.org/r/20220328062032.28881-1-quic_mpubbise@quicinc.com
(cherry picked from commit f9eec4947add999e1251bf14365a48a655b786a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/ath11k/ahb.c
diff --cc drivers/net/wireless/ath/ath11k/ahb.c
index c7ff98b317b6,fa11807f48a9..000000000000
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@@ -659,6 -688,243 +661,246 @@@ static int ath11k_core_get_rproc(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ath11k_ahb_setup_msi_resources(struct ath11k_base *ab)
+ {
+ 	struct platform_device *pdev = ab->pdev;
+ 	phys_addr_t msi_addr_pa;
+ 	dma_addr_t msi_addr_iova;
+ 	struct resource *res;
+ 	int int_prop;
+ 	int ret;
+ 	int i;
+ 
+ 	ret = ath11k_pcic_init_msi_config(ab);
+ 	if (ret) {
+ 		ath11k_err(ab, "failed to init msi config: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!res) {
+ 		ath11k_err(ab, "failed to fetch msi_addr\n");
+ 		return -ENOENT;
+ 	}
+ 
+ 	msi_addr_pa = res->start;
+ 	msi_addr_iova = dma_map_resource(ab->dev, msi_addr_pa, PAGE_SIZE,
+ 					 DMA_FROM_DEVICE, 0);
+ 	if (dma_mapping_error(ab->dev, msi_addr_iova))
+ 		return -ENOMEM;
+ 
+ 	ab->pci.msi.addr_lo = lower_32_bits(msi_addr_iova);
+ 	ab->pci.msi.addr_hi = upper_32_bits(msi_addr_iova);
+ 
+ 	ret = of_property_read_u32_index(ab->dev->of_node, "interrupts", 1, &int_prop);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ab->pci.msi.ep_base_data = int_prop + 32;
+ 
+ 	for (i = 0; i < ab->pci.msi.config->total_vectors; i++) {
+ 		res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+ 		if (!res)
+ 			return -ENODEV;
+ 
+ 		ab->pci.msi.irqs[i] = res->start;
+ 	}
+ 
+ 	set_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags);
+ 
+ 	return 0;
+ }
+ 
+ static int ath11k_ahb_setup_resources(struct ath11k_base *ab)
+ {
+ 	struct platform_device *pdev = ab->pdev;
+ 	struct resource *mem_res;
+ 	void __iomem *mem;
+ 
+ 	if (ab->hw_params.hybrid_bus_type)
+ 		return ath11k_ahb_setup_msi_resources(ab);
+ 
+ 	mem = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);
+ 	if (IS_ERR(mem)) {
+ 		dev_err(&pdev->dev, "ioremap error\n");
+ 		return PTR_ERR(mem);
+ 	}
+ 
+ 	ab->mem = mem;
+ 	ab->mem_len = resource_size(mem_res);
+ 
+ 	return 0;
+ }
+ 
+ static int ath11k_ahb_setup_msa_resources(struct ath11k_base *ab)
+ {
+ 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
+ 	struct device *dev = ab->dev;
+ 	struct device_node *node;
+ 	struct resource r;
+ 	int ret;
+ 
+ 	node = of_parse_phandle(dev->of_node, "memory-region", 0);
+ 	if (!node)
+ 		return -ENOENT;
+ 
+ 	ret = of_address_to_resource(node, 0, &r);
+ 	of_node_put(node);
+ 	if (ret) {
+ 		dev_err(dev, "failed to resolve msa fixed region\n");
+ 		return ret;
+ 	}
+ 
+ 	ab_ahb->fw.msa_paddr = r.start;
+ 	ab_ahb->fw.msa_size = resource_size(&r);
+ 
+ 	node = of_parse_phandle(dev->of_node, "memory-region", 1);
+ 	if (!node)
+ 		return -ENOENT;
+ 
+ 	ret = of_address_to_resource(node, 0, &r);
+ 	of_node_put(node);
+ 	if (ret) {
+ 		dev_err(dev, "failed to resolve ce fixed region\n");
+ 		return ret;
+ 	}
+ 
+ 	ab_ahb->fw.ce_paddr = r.start;
+ 	ab_ahb->fw.ce_size = resource_size(&r);
+ 
+ 	return 0;
+ }
+ 
+ static int ath11k_ahb_fw_resources_init(struct ath11k_base *ab)
+ {
+ 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
+ 	struct device *host_dev = ab->dev;
+ 	struct platform_device_info info = {0};
+ 	struct iommu_domain *iommu_dom;
+ 	struct platform_device *pdev;
+ 	struct device_node *node;
+ 	int ret;
+ 
+ 	/* Chipsets not requiring MSA need not initialize
+ 	 * MSA resources, return success in such cases.
+ 	 */
+ 	if (!ab->hw_params.fixed_fw_mem)
+ 		return 0;
+ 
+ 	ret = ath11k_ahb_setup_msa_resources(ab);
+ 	if (ret) {
+ 		ath11k_err(ab, "failed to setup msa resources\n");
+ 		return ret;
+ 	}
+ 
+ 	node = of_get_child_by_name(host_dev->of_node, "wifi-firmware");
+ 	if (!node) {
+ 		ab_ahb->fw.use_tz = true;
+ 		return 0;
+ 	}
+ 
+ 	info.fwnode = &node->fwnode;
+ 	info.parent = host_dev;
+ 	info.name = node->name;
+ 	info.dma_mask = DMA_BIT_MASK(32);
+ 
+ 	pdev = platform_device_register_full(&info);
+ 	if (IS_ERR(pdev)) {
+ 		of_node_put(node);
+ 		return PTR_ERR(pdev);
+ 	}
+ 
+ 	ret = of_dma_configure(&pdev->dev, node, true);
+ 	if (ret) {
+ 		ath11k_err(ab, "dma configure fail: %d\n", ret);
+ 		goto err_unregister;
+ 	}
+ 
+ 	ab_ahb->fw.dev = &pdev->dev;
+ 
+ 	iommu_dom = iommu_domain_alloc(&platform_bus_type);
+ 	if (!iommu_dom) {
+ 		ath11k_err(ab, "failed to allocate iommu domain\n");
+ 		ret = -ENOMEM;
+ 		goto err_unregister;
+ 	}
+ 
+ 	ret = iommu_attach_device(iommu_dom, ab_ahb->fw.dev);
+ 	if (ret) {
+ 		ath11k_err(ab, "could not attach device: %d\n", ret);
+ 		goto err_iommu_free;
+ 	}
+ 
+ 	ret = iommu_map(iommu_dom, ab_ahb->fw.msa_paddr,
+ 			ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size,
+ 			IOMMU_READ | IOMMU_WRITE);
+ 	if (ret) {
+ 		ath11k_err(ab, "failed to map firmware region: %d\n", ret);
+ 		goto err_iommu_detach;
+ 	}
+ 
+ 	ret = iommu_map(iommu_dom, ab_ahb->fw.ce_paddr,
+ 			ab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size,
+ 			IOMMU_READ | IOMMU_WRITE);
+ 	if (ret) {
+ 		ath11k_err(ab, "failed to map firmware CE region: %d\n", ret);
+ 		goto err_iommu_unmap;
+ 	}
+ 
+ 	ab_ahb->fw.use_tz = false;
+ 	ab_ahb->fw.iommu_domain = iommu_dom;
+ 	of_node_put(node);
+ 
+ 	return 0;
+ 
+ err_iommu_unmap:
+ 	iommu_unmap(iommu_dom, ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size);
+ 
+ err_iommu_detach:
+ 	iommu_detach_device(iommu_dom, ab_ahb->fw.dev);
+ 
+ err_iommu_free:
+ 	iommu_domain_free(iommu_dom);
+ 
+ err_unregister:
+ 	platform_device_unregister(pdev);
+ 	of_node_put(node);
+ 
+ 	return ret;
+ }
+ 
+ static int ath11k_ahb_fw_resource_deinit(struct ath11k_base *ab)
+ {
+ 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
+ 	struct iommu_domain *iommu;
+ 	size_t unmapped_size;
+ 
+ 	if (ab_ahb->fw.use_tz)
+ 		return 0;
+ 
+ 	iommu = ab_ahb->fw.iommu_domain;
+ 
+ 	unmapped_size = iommu_unmap(iommu, ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size);
+ 	if (unmapped_size != ab_ahb->fw.msa_size)
+ 		ath11k_err(ab, "failed to unmap firmware: %zu\n",
+ 			   unmapped_size);
+ 
+ 	unmapped_size = iommu_unmap(iommu, ab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size);
+ 	if (unmapped_size != ab_ahb->fw.ce_size)
+ 		ath11k_err(ab, "failed to unmap firmware CE memory: %zu\n",
+ 			   unmapped_size);
+ 
+ 	iommu_detach_device(iommu, ab_ahb->fw.dev);
+ 	iommu_domain_free(iommu);
+ 
+ 	platform_device_unregister(to_platform_device(ab_ahb->fw.dev));
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f9eec4947add (ath11k: Add support for targets without trustzone)
  static int ath11k_ahb_probe(struct platform_device *pdev)
  {
  	struct ath11k_base *ab;
* Unmerged path drivers/net/wireless/ath/ath11k/ahb.c
diff --git a/drivers/net/wireless/ath/ath11k/ahb.h b/drivers/net/wireless/ath/ath11k/ahb.h
index 51e6e4a5f686..58a945411c5b 100644
--- a/drivers/net/wireless/ath/ath11k/ahb.h
+++ b/drivers/net/wireless/ath/ath11k/ahb.h
@@ -12,6 +12,15 @@ struct ath11k_base;
 
 struct ath11k_ahb {
 	struct rproc *tgt_rproc;
+	struct {
+		struct device *dev;
+		struct iommu_domain *iommu_domain;
+		dma_addr_t msa_paddr;
+		u32 msa_size;
+		dma_addr_t ce_paddr;
+		u32 ce_size;
+		bool use_tz;
+	} fw;
 };
 
 static inline struct ath11k_ahb *ath11k_ahb_priv(struct ath11k_base *ab)
