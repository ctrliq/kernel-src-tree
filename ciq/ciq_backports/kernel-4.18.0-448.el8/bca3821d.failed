net/sched: act_mpls: Add extack messages for offload failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ido Schimmel <idosch@nvidia.com>
commit bca3821d19d9aa05cd8164e4f716150d6ef7e5a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/bca3821d.failed

For better error reporting to user space, add extack messages when mpls
action offload fails.

Example:

 # echo 1 > /sys/kernel/tracing/events/netlink/netlink_extack/enable

 # tc filter add dev dummy0 ingress pref 1 proto all matchall skip_sw action mpls dec_ttl
 Error: cls_matchall: Failed to setup flow action.
 We have an error talking to the kernel

 # cat /sys/kernel/tracing/trace_pipe
       tc-182     [000] b..1.    18.693915: netlink_extack: msg=act_mpls: Offload not supported when "dec_ttl" option is used
       tc-182     [000] .....    18.693921: netlink_extack: msg=cls_matchall: Failed to setup flow action

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: Petr Machata <petrm@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bca3821d19d9aa05cd8164e4f716150d6ef7e5a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_mpls.c
diff --cc net/sched/act_mpls.c
index 9789d894911b,adabeccb63e1..000000000000
--- a/net/sched/act_mpls.c
+++ b/net/sched/act_mpls.c
@@@ -385,6 -384,65 +385,68 @@@ static int tcf_mpls_search(struct net *
  	return tcf_idr_search(tn, a, index);
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_mpls_offload_act_setup(struct tc_action *act, void *entry_data,
+ 				      u32 *index_inc, bool bind,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	if (bind) {
+ 		struct flow_action_entry *entry = entry_data;
+ 
+ 		switch (tcf_mpls_action(act)) {
+ 		case TCA_MPLS_ACT_PUSH:
+ 			entry->id = FLOW_ACTION_MPLS_PUSH;
+ 			entry->mpls_push.proto = tcf_mpls_proto(act);
+ 			entry->mpls_push.label = tcf_mpls_label(act);
+ 			entry->mpls_push.tc = tcf_mpls_tc(act);
+ 			entry->mpls_push.bos = tcf_mpls_bos(act);
+ 			entry->mpls_push.ttl = tcf_mpls_ttl(act);
+ 			break;
+ 		case TCA_MPLS_ACT_POP:
+ 			entry->id = FLOW_ACTION_MPLS_POP;
+ 			entry->mpls_pop.proto = tcf_mpls_proto(act);
+ 			break;
+ 		case TCA_MPLS_ACT_MODIFY:
+ 			entry->id = FLOW_ACTION_MPLS_MANGLE;
+ 			entry->mpls_mangle.label = tcf_mpls_label(act);
+ 			entry->mpls_mangle.tc = tcf_mpls_tc(act);
+ 			entry->mpls_mangle.bos = tcf_mpls_bos(act);
+ 			entry->mpls_mangle.ttl = tcf_mpls_ttl(act);
+ 			break;
+ 		case TCA_MPLS_ACT_DEC_TTL:
+ 			NL_SET_ERR_MSG_MOD(extack, "Offload not supported when \"dec_ttl\" option is used");
+ 			return -EOPNOTSUPP;
+ 		case TCA_MPLS_ACT_MAC_PUSH:
+ 			NL_SET_ERR_MSG_MOD(extack, "Offload not supported when \"mac_push\" option is used");
+ 			return -EOPNOTSUPP;
+ 		default:
+ 			NL_SET_ERR_MSG_MOD(extack, "Unsupported MPLS mode offload");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		*index_inc = 1;
+ 	} else {
+ 		struct flow_offload_action *fl_action = entry_data;
+ 
+ 		switch (tcf_mpls_action(act)) {
+ 		case TCA_MPLS_ACT_PUSH:
+ 			fl_action->id = FLOW_ACTION_MPLS_PUSH;
+ 			break;
+ 		case TCA_MPLS_ACT_POP:
+ 			fl_action->id = FLOW_ACTION_MPLS_POP;
+ 			break;
+ 		case TCA_MPLS_ACT_MODIFY:
+ 			fl_action->id = FLOW_ACTION_MPLS_MANGLE;
+ 			break;
+ 		default:
+ 			return -EOPNOTSUPP;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> bca3821d19d9 (net/sched: act_mpls: Add extack messages for offload failure)
  static struct tc_action_ops act_mpls_ops = {
  	.kind		=	"mpls",
  	.id		=	TCA_ID_MPLS,
* Unmerged path net/sched/act_mpls.c
