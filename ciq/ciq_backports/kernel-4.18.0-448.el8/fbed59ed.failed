PCI: Split out next_ari_fn() from next_fn()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit fbed59ed8781d7eecd7f45cde0188cf24eeb5c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/fbed59ed.failed

In commit b1bd58e448f2 ("PCI: Consolidate "next-function" functions") the
next_fn() function subsumed the traditional and ARI-based next function
determination. This got rid of some needlessly complex function pointer
handling but also reduced the separation between these very different
methods of finding the next function. With the next_fn() cleaned up a bit
we can re-introduce this separation by moving out the ARI handling while
sticking with direct function calls.

Link: https://lore.kernel.org/r/20220628143100.3228092-3-schnelle@linux.ibm.com
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
(cherry picked from commit fbed59ed8781d7eecd7f45cde0188cf24eeb5c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/probe.c
diff --cc drivers/pci/probe.c
index 29fcfa96d49b,d62885519df3..000000000000
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@@ -2519,32 -2579,39 +2519,55 @@@ struct pci_dev *pci_scan_single_device(
  }
  EXPORT_SYMBOL(pci_scan_single_device);
  
++<<<<<<< HEAD
 +static unsigned next_fn(struct pci_bus *bus, struct pci_dev *dev, unsigned fn)
++=======
+ static int next_ari_fn(struct pci_bus *bus, struct pci_dev *dev, int fn)
++>>>>>>> fbed59ed8781 (PCI: Split out next_ari_fn() from next_fn())
  {
  	int pos;
  	u16 cap = 0;
 -	unsigned int next_fn;
 -
 +	unsigned next_fn;
 +
++<<<<<<< HEAD
 +	if (pci_ari_enabled(bus)) {
 +		if (!dev)
 +			return 0;
 +		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
 +		if (!pos)
 +			return 0;
 +
 +		pci_read_config_word(dev, pos + PCI_ARI_CAP, &cap);
 +		next_fn = PCI_ARI_CAP_NFN(cap);
 +		if (next_fn <= fn)
 +			return 0;	/* protect against malformed list */
++=======
+ 	if (!dev)
+ 		return -ENODEV;
  
- 		return next_fn;
- 	}
+ 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
+ 	if (!pos)
+ 		return -ENODEV;
++>>>>>>> fbed59ed8781 (PCI: Split out next_ari_fn() from next_fn())
+ 
+ 	pci_read_config_word(dev, pos + PCI_ARI_CAP, &cap);
+ 	next_fn = PCI_ARI_CAP_NFN(cap);
+ 	if (next_fn <= fn)
+ 		return -ENODEV;	/* protect against malformed list */
+ 
+ 	return next_fn;
+ }
+ 
+ static int next_fn(struct pci_bus *bus, struct pci_dev *dev, int fn)
+ {
+ 	if (pci_ari_enabled(bus))
+ 		return next_ari_fn(bus, dev, fn);
  
 -	if (fn >= 7)
 -		return -ENODEV;
 -	/* only multifunction devices may have more functions */
 -	if (dev && !dev->multifunction)
 -		return -ENODEV;
 +	/* dev may be NULL for non-contiguous multifunction devices */
 +	if (!dev || dev->multifunction)
 +		return (fn + 1) % 8;
  
 -	return fn + 1;
 +	return 0;
  }
  
  static int only_one_child(struct pci_bus *bus)
* Unmerged path drivers/pci/probe.c
