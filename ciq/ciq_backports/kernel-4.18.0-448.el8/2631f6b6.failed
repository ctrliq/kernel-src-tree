s390/pci: unify de-/configure for slots and events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 2631f6b6f22ca613238a416a09e3d2771def6f88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2631f6b6.failed

A zPCI event with PEC 0x0301 for an existing zPCI device goes through
the same actions as enable_slot(). Similarly a zPCI event with PEC
0x0303 does the same steps as disable_slot().
We can thus unify both actions as zpci_configure_device() respectively
zpci_deconfigure_device().

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 2631f6b6f22ca613238a416a09e3d2771def6f88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_event.c
#	drivers/pci/hotplug/s390_pci_hpc.c
diff --cc arch/s390/include/asm/pci.h
index 37481081a26c,c454dfb9fc4b..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -201,12 -200,12 +201,17 @@@ extern unsigned int s390_pci_no_rid
    Prototypes
  ----------------------------------------------------------------------------- */
  /* Base stuff */
 -int zpci_create_device(u32 fid, u32 fh, enum zpci_state state);
 -void zpci_remove_device(struct zpci_dev *zdev, bool set_error);
 +int zpci_create_device(struct zpci_dev *);
 +void zpci_remove_device(struct zpci_dev *zdev);
  int zpci_enable_device(struct zpci_dev *);
  int zpci_disable_device(struct zpci_dev *);
++<<<<<<< HEAD
 +void zpci_device_reserved(struct zpci_dev *zdev);
 +bool zpci_is_device_configured(struct zpci_dev *zdev);
++=======
+ int zpci_configure_device(struct zpci_dev *zdev, u32 fh);
+ int zpci_deconfigure_device(struct zpci_dev *zdev);
++>>>>>>> 2631f6b6f22c (s390/pci: unify de-/configure for slots and events)
  
  int zpci_register_ioat(struct zpci_dev *, u8, u64, u64, u64);
  int zpci_unregister_ioat(struct zpci_dev *, u8);
diff --cc arch/s390/pci/pci.c
index 6af47e2fa8a9,6d84ec8f1dd6..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -721,9 -678,17 +720,8 @@@ int zpci_disable_device(struct zpci_de
  	 */
  	return clp_disable_fh(zdev);
  }
- EXPORT_SYMBOL_GPL(zpci_disable_device);
  
 -/* zpci_remove_device - Removes the given zdev from the PCI core
 - * @zdev: the zdev to be removed from the PCI core
 - * @set_error: if true the device's error state is set to permanent failure
 - *
 - * Sets a zPCI device to a configured but offline state; the zPCI
 - * device is still accessible through its hotplug slot and the zPCI
 - * API but is removed from the common code PCI bus, making it
 - * no longer available to drivers.
 - */
 -void zpci_remove_device(struct zpci_dev *zdev, bool set_error)
 +void zpci_remove_device(struct zpci_dev *zdev)
  {
  	struct zpci_bus *zbus = zdev->zbus;
  	struct pci_dev *pdev;
@@@ -776,37 -777,91 +774,125 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +bool zpci_is_device_configured(struct zpci_dev *zdev)
 +{
 +	enum zpci_state state = zdev->state;
 +
 +	return state != ZPCI_FN_STATE_RESERVED &&
 +		state != ZPCI_FN_STATE_STANDBY;
 +}
 +
 +/**
 + * zpci_device_reserved() - Mark device as resverved
 + * @zdev: the zpci_dev that was reserved
 + *
 + * Handle the case that a given zPCI function was reserved by another system.
 + * After a call to this function the zpci_dev can not be found via
 + * get_zdev_by_fid() anymore but may still be accessible via existing
 + * references though it will not be functional anymore.
 + */
 +void zpci_device_reserved(struct zpci_dev *zdev)
 +{
 +	if (zdev->has_hp_slot)
 +		zpci_exit_slot(zdev);
 +	/*
 +	 * Remove device from zpci_list as it is going away. This also
 +	 * makes sure we ignore subsequent zPCI events for this device.
 +	 */
 +	spin_lock(&zpci_list_lock);
 +	list_del(&zdev->entry);
 +	spin_unlock(&zpci_list_lock);
 +	zdev->state = ZPCI_FN_STATE_RESERVED;
 +	zpci_dbg(3, "rsv fid:%x\n", zdev->fid);
 +	zpci_zdev_put(zdev);
++=======
+ /**
+  * zpci_configure_device() - Configure a zpci_dev
+  * @zdev: The zpci_dev to be configured
+  * @fh: The general function handle supplied by the platform
+  *
+  * Configuring a device includes the configuration itself, if not done by the
+  * platform, enabling, scanning and adding it to the common code PCI subsystem.
+  * If any failure occurs, the zpci_dev is left in Standby.
+  *
+  * Return: 0 on success, or an error code otherwise
+  */
+ int zpci_configure_device(struct zpci_dev *zdev, u32 fh)
+ {
+ 	struct pci_dev *pdev;
+ 	int rc;
+ 
+ 	zdev->fh = fh;
+ 	if (zdev->state != ZPCI_FN_STATE_CONFIGURED) {
+ 		rc = sclp_pci_configure(zdev->fid);
+ 		zpci_dbg(3, "conf fid:%x, rc:%d\n", zdev->fid, rc);
+ 		if (rc)
+ 			return rc;
+ 		zdev->state = ZPCI_FN_STATE_CONFIGURED;
+ 	}
+ 
+ 	rc = zpci_enable_device(zdev);
+ 	if (rc)
+ 		goto error;
+ 
+ 	/* the PCI function will be scanned once function 0 appears */
+ 	if (!zdev->zbus->bus)
+ 		return 0;
+ 
+ 	pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
+ 	if (!pdev)
+ 		goto error_disable;
+ 
+ 	pci_bus_add_device(pdev);
+ 	pci_lock_rescan_remove();
+ 	pci_bus_add_devices(zdev->zbus->bus);
+ 	pci_unlock_rescan_remove();
+ 	return 0;
+ 
+ error_disable:
+ 	zpci_disable_device(zdev);
+ error:
+ 	if (zdev->state == ZPCI_FN_STATE_CONFIGURED) {
+ 		rc = sclp_pci_deconfigure(zdev->fid);
+ 		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, rc);
+ 		if (!rc)
+ 			zdev->state = ZPCI_FN_STATE_STANDBY;
+ 	}
+ 	return rc;
+ }
+ 
+ /**
+  * zpci_deconfigure_device() - Deconfigure a zpci_dev
+  * @zdev: The zpci_dev to configure
+  *
+  * Deconfigure a zPCI function that is currently configured and possibly known
+  * to the common code PCI subsystem.
+  * If any failure occurs the device is left as is.
+  *
+  * Return: 0 on success, or an error code otherwise
+  */
+ int zpci_deconfigure_device(struct zpci_dev *zdev)
+ {
+ 	int rc;
+ 
+ 	if (zdev->zbus->bus)
+ 		zpci_remove_device(zdev, false);
+ 
+ 	if (zdev_enabled(zdev)) {
+ 		rc = zpci_disable_device(zdev);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	rc = sclp_pci_deconfigure(zdev->fid);
+ 	zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, rc);
+ 	if (rc)
+ 		return rc;
+ 	zdev->state = ZPCI_FN_STATE_STANDBY;
+ 
+ 	return 0;
++>>>>>>> 2631f6b6f22c (s390/pci: unify de-/configure for slots and events)
  }
  
  void zpci_release_device(struct kref *kref)
diff --cc arch/s390/pci/pci_event.c
index 4b2bb5dfb29a,2676df9816f0..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -76,12 -76,28 +76,15 @@@ void zpci_event_error(void *data
  static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
  {
  	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
++<<<<<<< HEAD
 +	struct pci_dev *pdev = NULL;
 +	enum zpci_state state;
 +	int ret;
++=======
++>>>>>>> 2631f6b6f22c (s390/pci: unify de-/configure for slots and events)
 +
 +	if (zdev && zdev->zbus->bus)
 +		pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
  
  	zpci_err("avail CCDF:\n");
  	zpci_err_hex(ccdf, sizeof(*ccdf));
@@@ -95,65 -111,24 +98,62 @@@
  		/* the configuration request may be stale */
  		if (zdev->state != ZPCI_FN_STATE_STANDBY)
  			break;
- 		zdev->fh = ccdf->fh;
  		zdev->state = ZPCI_FN_STATE_CONFIGURED;
- 		ret = zpci_enable_device(zdev);
- 		if (ret)
- 			break;
- 
- 		/* the PCI function will be scanned once function 0 appears */
- 		if (!zdev->zbus->bus)
- 			break;
- 
- 		pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
- 		if (!pdev)
- 			break;
- 
- 		pci_bus_add_device(pdev);
- 		pci_lock_rescan_remove();
- 		pci_bus_add_devices(zdev->zbus->bus);
- 		pci_unlock_rescan_remove();
+ 		zpci_configure_device(zdev, ccdf->fh);
  		break;
  	case 0x0302: /* Reserved -> Standby */
++<<<<<<< HEAD
 +		if (!zdev) {
 +			clp_add_pci_device(ccdf->fid, ccdf->fh, 0);
 +			break;
 +		}
 +		zdev->fh = ccdf->fh;
 +		break;
 +	case 0x0303: /* Deconfiguration requested */
 +		if (!zdev)
 +			break;
 +		if (pdev)
 +			zpci_remove_device(zdev);
 +
 +		ret = zpci_disable_device(zdev);
 +		if (ret)
 +			break;
 +
 +		ret = sclp_pci_deconfigure(zdev->fid);
 +		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
 +		if (!ret)
 +			zdev->state = ZPCI_FN_STATE_STANDBY;
 +
++=======
+ 		if (!zdev)
+ 			zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_STANDBY);
+ 		else
+ 			zdev->fh = ccdf->fh;
+ 		break;
+ 	case 0x0303: /* Deconfiguration requested */
+ 		if (zdev) {
+ 			zdev->fh = ccdf->fh;
+ 			zpci_deconfigure_device(zdev);
+ 		}
++>>>>>>> 2631f6b6f22c (s390/pci: unify de-/configure for slots and events)
  		break;
  	case 0x0304: /* Configured -> Standby|Reserved */
 -		if (zdev)
 -			zpci_event_hard_deconfigured(zdev, ccdf->fh);
 +		if (!zdev)
 +			break;
 +		if (pdev) {
 +			/* Give the driver a hint that the function is
 +			 * already unusable. */
 +			pdev->error_state = pci_channel_io_perm_failure;
 +			zpci_remove_device(zdev);
 +		}
 +
 +		zdev->fh = ccdf->fh;
 +		zpci_disable_device(zdev);
 +		zdev->state = ZPCI_FN_STATE_STANDBY;
 +		if (!clp_get_state(ccdf->fid, &state) &&
 +		    state == ZPCI_FN_STATE_RESERVED) {
 +			zpci_device_reserved(zdev);
 +		}
  		break;
  	case 0x0306: /* 0x308 or 0x302 for multiple devices */
  		zpci_remove_reserved_devices();
diff --cc drivers/pci/hotplug/s390_pci_hpc.c
index 8534cf105796,154532663a70..000000000000
--- a/drivers/pci/hotplug/s390_pci_hpc.c
+++ b/drivers/pci/hotplug/s390_pci_hpc.c
@@@ -20,34 -20,6 +20,37 @@@
  
  #define SLOT_NAME_SIZE	10
  
++<<<<<<< HEAD
 +static int zpci_fn_configured(enum zpci_state state)
 +{
 +	return state == ZPCI_FN_STATE_CONFIGURED ||
 +	       state == ZPCI_FN_STATE_ONLINE;
 +}
 +
 +static inline int zdev_configure(struct zpci_dev *zdev)
 +{
 +	int ret = sclp_pci_configure(zdev->fid);
 +
 +	zpci_dbg(3, "conf fid:%x, rc:%d\n", zdev->fid, ret);
 +	if (!ret)
 +		zdev->state = ZPCI_FN_STATE_CONFIGURED;
 +
 +	return ret;
 +}
 +
 +static inline int zdev_deconfigure(struct zpci_dev *zdev)
 +{
 +	int ret = sclp_pci_deconfigure(zdev->fid);
 +
 +	zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
 +	if (!ret)
 +		zdev->state = ZPCI_FN_STATE_STANDBY;
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 2631f6b6f22c (s390/pci: unify de-/configure for slots and events)
  static int enable_slot(struct hotplug_slot *hotplug_slot)
  {
  	struct zpci_dev *zdev = container_of(hotplug_slot, struct zpci_dev,
@@@ -83,9 -36,8 +67,8 @@@ static int disable_slot(struct hotplug_
  	struct zpci_dev *zdev = container_of(hotplug_slot, struct zpci_dev,
  					     hotplug_slot);
  	struct pci_dev *pdev;
- 	int rc;
  
 -	if (zdev->state != ZPCI_FN_STATE_CONFIGURED)
 +	if (!zpci_fn_configured(zdev->state))
  		return -EIO;
  
  	pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
@@@ -93,14 -45,9 +76,18 @@@
  		pci_dev_put(pdev);
  		return -EBUSY;
  	}
 -	pci_dev_put(pdev);
  
++<<<<<<< HEAD
 +	zpci_remove_device(zdev);
 +
 +	rc = zpci_disable_device(zdev);
 +	if (rc)
 +		return rc;
 +
 +	return zdev_deconfigure(zdev);
++=======
+ 	return zpci_deconfigure_device(zdev);
++>>>>>>> 2631f6b6f22c (s390/pci: unify de-/configure for slots and events)
  }
  
  static int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)
* Unmerged path arch/s390/include/asm/pci.h
* Unmerged path arch/s390/pci/pci.c
* Unmerged path arch/s390/pci/pci_event.c
* Unmerged path drivers/pci/hotplug/s390_pci_hpc.c
