s390/ap: fix error handling in __verify_queue_reservations()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 2f23256c0ea20627c91ea2d468cda945f68c3395
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2f23256c.failed

The AP bus's __verify_queue_reservations function increments the ref count
for the device driver passed in as a parameter, but fails to decrement it
before returning control to the caller. This will prevents any subsequent
removal of the module.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reported-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Harald Freudenberger <freude@linux.ibm.com>
Fixes: 4f8206b88286 ("s390/ap: driver callback to indicate resource in use")
Link: https://lore.kernel.org/r/20220706222619.602094-1-akrowiak@linux.ibm.com
	Cc: stable@vger.kernel.org
[agordeev@linux.ibm.com fixed description, added Fixes and Link]
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit 2f23256c0ea20627c91ea2d468cda945f68c3395)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 2a615a843237,0a9045b49c50..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1443,6 -1419,52 +1443,55 @@@ static ssize_t aqmask_show(struct bus_t
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int __verify_queue_reservations(struct device_driver *drv, void *data)
+ {
+ 	int rc = 0;
+ 	struct ap_driver *ap_drv = to_ap_drv(drv);
+ 	unsigned long *newaqm = (unsigned long *)data;
+ 
+ 	/*
+ 	 * increase the driver's module refcounter to be sure it is not
+ 	 * going away when we invoke the callback function.
+ 	 */
+ 	if (!try_module_get(drv->owner))
+ 		return 0;
+ 
+ 	if (ap_drv->in_use) {
+ 		rc = ap_drv->in_use(ap_perms.apm, newaqm);
+ 		if (rc)
+ 			rc = -EBUSY;
+ 	}
+ 
+ 	/* release the driver's module */
+ 	module_put(drv->owner);
+ 
+ 	return rc;
+ }
+ 
+ static int aqmask_commit(unsigned long *newaqm)
+ {
+ 	int rc;
+ 	unsigned long reserved[BITS_TO_LONGS(AP_DOMAINS)];
+ 
+ 	/*
+ 	 * Check if any bits in the aqmask have been set which will
+ 	 * result in queues being removed from non-default drivers
+ 	 */
+ 	if (bitmap_andnot(reserved, newaqm, ap_perms.aqm, AP_DOMAINS)) {
+ 		rc = bus_for_each_drv(&ap_bus_type, NULL, reserved,
+ 				      __verify_queue_reservations);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	memcpy(ap_perms.aqm, newaqm, AQMASKSIZE);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2f23256c0ea2 (s390/ap: fix error handling in __verify_queue_reservations())
  static ssize_t aqmask_store(struct bus_type *bus, const char *buf,
  			    size_t count)
  {
* Unmerged path drivers/s390/crypto/ap_bus.c
