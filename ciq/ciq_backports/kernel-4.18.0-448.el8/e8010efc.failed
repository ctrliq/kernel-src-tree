ASoC: wm_adsp: Minor clean and redundant code removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Charles Keepax <ckeepax@opensource.cirrus.com>
commit e8010efc7b83038d1c18abe1b8d171e3c7d4ed92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/e8010efc.failed

The cs_dsp core will return an error if passed a NULL cs_dsp struct so
there is no need for the wm_adsp_write|read_ctl functions to manually
check that. The cs_dsp core will also check the data is within bounds of
the control so the additional bounds check is redundant too. Simplify
things a bit by removing said code.

	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20220630101459.3442327-1-ckeepax@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit e8010efc7b83038d1c18abe1b8d171e3c7d4ed92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
diff --cc sound/soc/codecs/wm_adsp.c
index 3657fd0de5d5,cfaa45ede916..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -1523,1270 -662,225 +1523,1285 @@@ err_ctl
  	return ret;
  }
  
 -static void wm_adsp_control_remove(struct cs_dsp_coeff_ctl *cs_ctl)
 +struct wm_coeff_parsed_alg {
 +	int id;
 +	const u8 *name;
 +	int name_len;
 +	int ncoeff;
 +};
 +
 +struct wm_coeff_parsed_coeff {
 +	int offset;
 +	int mem_type;
 +	const u8 *name;
 +	int name_len;
 +	unsigned int ctl_type;
 +	int flags;
 +	int len;
 +};
 +
 +static int wm_coeff_parse_string(int bytes, const u8 **pos, const u8 **str)
  {
 -	struct wm_coeff_ctl *ctl = cs_ctl->priv;
 +	int length;
  
 -	cancel_work_sync(&ctl->work);
 +	switch (bytes) {
 +	case 1:
 +		length = **pos;
 +		break;
 +	case 2:
 +		length = le16_to_cpu(*((__le16 *)*pos));
 +		break;
 +	default:
 +		return 0;
 +	}
  
 -	kfree(ctl->name);
 -	kfree(ctl);
 +	if (str)
 +		*str = *pos + bytes;
 +
 +	*pos += ((length + bytes) + 3) & ~0x03;
 +
 +	return length;
  }
  
 -int wm_adsp_write_ctl(struct wm_adsp *dsp, const char *name, int type,
 -		      unsigned int alg, void *buf, size_t len)
 +static int wm_coeff_parse_int(int bytes, const u8 **pos)
  {
 -	struct cs_dsp_coeff_ctl *cs_ctl = cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg);
 -	struct wm_coeff_ctl *ctl;
 -	struct snd_kcontrol *kcontrol;
 -	char ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 -	int ret;
 +	int val = 0;
  
 -	ret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, buf, len);
 -	if (ret)
 -		return ret;
 +	switch (bytes) {
 +	case 2:
 +		val = le16_to_cpu(*((__le16 *)*pos));
 +		break;
 +	case 4:
 +		val = le32_to_cpu(*((__le32 *)*pos));
 +		break;
 +	default:
 +		break;
 +	}
  
 -	if (cs_ctl->flags & WMFW_CTL_FLAG_SYS)
 -		return 0;
 +	*pos += bytes;
  
 -	ctl = cs_ctl->priv;
 +	return val;
 +}
  
 -	if (dsp->component->name_prefix)
 -		snprintf(ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s %s",
 -			 dsp->component->name_prefix, ctl->name);
 -	else
 -		snprintf(ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s",
 -			 ctl->name);
 +static inline void wm_coeff_parse_alg(struct wm_adsp *dsp, const u8 **data,
 +				      struct wm_coeff_parsed_alg *blk)
 +{
 +	const struct wmfw_adsp_alg_data *raw;
  
 -	kcontrol = snd_soc_card_get_kcontrol(dsp->component->card, ctl_name);
 -	if (!kcontrol) {
 -		adsp_err(dsp, "Can't find kcontrol %s\n", ctl_name);
 -		return -EINVAL;
 -	}
 +	switch (dsp->fw_ver) {
 +	case 0:
 +	case 1:
 +		raw = (const struct wmfw_adsp_alg_data *)*data;
 +		*data = raw->data;
  
 -	snd_ctl_notify(dsp->component->card->snd_card,
 -		       SNDRV_CTL_EVENT_MASK_VALUE, &kcontrol->id);
 +		blk->id = le32_to_cpu(raw->id);
 +		blk->name = raw->name;
 +		blk->name_len = strlen(raw->name);
 +		blk->ncoeff = le32_to_cpu(raw->ncoeff);
 +		break;
 +	default:
 +		blk->id = wm_coeff_parse_int(sizeof(raw->id), data);
 +		blk->name_len = wm_coeff_parse_string(sizeof(u8), data,
 +						      &blk->name);
 +		wm_coeff_parse_string(sizeof(u16), data, NULL);
 +		blk->ncoeff = wm_coeff_parse_int(sizeof(raw->ncoeff), data);
 +		break;
 +	}
  
 -	return 0;
 +	adsp_dbg(dsp, "Algorithm ID: %#x\n", blk->id);
 +	adsp_dbg(dsp, "Algorithm name: %.*s\n", blk->name_len, blk->name);
 +	adsp_dbg(dsp, "# of coefficient descriptors: %#x\n", blk->ncoeff);
  }
 -EXPORT_SYMBOL_GPL(wm_adsp_write_ctl);
  
 -int wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,
 -		     unsigned int alg, void *buf, size_t len)
 +static inline void wm_coeff_parse_coeff(struct wm_adsp *dsp, const u8 **data,
 +					struct wm_coeff_parsed_coeff *blk)
  {
 -	return cs_dsp_coeff_read_ctrl(cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg),
 -				      0, buf, len);
 +	const struct wmfw_adsp_coeff_data *raw;
 +	const u8 *tmp;
 +	int length;
 +
 +	switch (dsp->fw_ver) {
 +	case 0:
 +	case 1:
 +		raw = (const struct wmfw_adsp_coeff_data *)*data;
 +		*data = *data + sizeof(raw->hdr) + le32_to_cpu(raw->hdr.size);
 +
 +		blk->offset = le16_to_cpu(raw->hdr.offset);
 +		blk->mem_type = le16_to_cpu(raw->hdr.type);
 +		blk->name = raw->name;
 +		blk->name_len = strlen(raw->name);
 +		blk->ctl_type = le16_to_cpu(raw->ctl_type);
 +		blk->flags = le16_to_cpu(raw->flags);
 +		blk->len = le32_to_cpu(raw->len);
 +		break;
 +	default:
 +		tmp = *data;
 +		blk->offset = wm_coeff_parse_int(sizeof(raw->hdr.offset), &tmp);
 +		blk->mem_type = wm_coeff_parse_int(sizeof(raw->hdr.type), &tmp);
 +		length = wm_coeff_parse_int(sizeof(raw->hdr.size), &tmp);
 +		blk->name_len = wm_coeff_parse_string(sizeof(u8), &tmp,
 +						      &blk->name);
 +		wm_coeff_parse_string(sizeof(u8), &tmp, NULL);
 +		wm_coeff_parse_string(sizeof(u16), &tmp, NULL);
 +		blk->ctl_type = wm_coeff_parse_int(sizeof(raw->ctl_type), &tmp);
 +		blk->flags = wm_coeff_parse_int(sizeof(raw->flags), &tmp);
 +		blk->len = wm_coeff_parse_int(sizeof(raw->len), &tmp);
 +
 +		*data = *data + sizeof(raw->hdr) + length;
 +		break;
 +	}
 +
 +	adsp_dbg(dsp, "\tCoefficient type: %#x\n", blk->mem_type);
 +	adsp_dbg(dsp, "\tCoefficient offset: %#x\n", blk->offset);
 +	adsp_dbg(dsp, "\tCoefficient name: %.*s\n", blk->name_len, blk->name);
 +	adsp_dbg(dsp, "\tCoefficient flags: %#x\n", blk->flags);
 +	adsp_dbg(dsp, "\tALSA control type: %#x\n", blk->ctl_type);
 +	adsp_dbg(dsp, "\tALSA control len: %#x\n", blk->len);
  }
 -EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
  
 -static void wm_adsp_release_firmware_files(struct wm_adsp *dsp,
 -					   const struct firmware *wmfw_firmware,
 -					   char *wmfw_filename,
 -					   const struct firmware *coeff_firmware,
 -					   char *coeff_filename)
 +static int wm_adsp_check_coeff_flags(struct wm_adsp *dsp,
 +				const struct wm_coeff_parsed_coeff *coeff_blk,
 +				unsigned int f_required,
 +				unsigned int f_illegal)
  {
 -	if (wmfw_firmware)
 -		release_firmware(wmfw_firmware);
 -	kfree(wmfw_filename);
 +	if ((coeff_blk->flags & f_illegal) ||
 +	    ((coeff_blk->flags & f_required) != f_required)) {
 +		adsp_err(dsp, "Illegal flags 0x%x for control type 0x%x\n",
 +			 coeff_blk->flags, coeff_blk->ctl_type);
 +		return -EINVAL;
 +	}
  
 -	if (coeff_firmware)
 -		release_firmware(coeff_firmware);
 -	kfree(coeff_filename);
 +	return 0;
  }
  
 -static int wm_adsp_request_firmware_file(struct wm_adsp *dsp,
 -					 const struct firmware **firmware, char **filename,
 -					 const char *dir, const char *system_name,
 -					 const char *asoc_component_prefix,
 -					 const char *filetype)
 +static int wm_adsp_parse_coeff(struct wm_adsp *dsp,
 +			       const struct wmfw_region *region)
  {
 -	struct cs_dsp *cs_dsp = &dsp->cs_dsp;
 -	char *s, c;
 -	int ret = 0;
 +	struct wm_adsp_alg_region alg_region = {};
 +	struct wm_coeff_parsed_alg alg_blk;
 +	struct wm_coeff_parsed_coeff coeff_blk;
 +	const u8 *data = region->data;
 +	int i, ret;
  
 -	if (system_name && asoc_component_prefix)
 -		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-%s.%s", dir, dsp->part,
 -				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
 -				      asoc_component_prefix, filetype);
 -	else if (system_name)
 -		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s.%s", dir, dsp->part,
 -				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
 -				      filetype);
 -	else
 -		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s.%s", dir, dsp->part, dsp->fwf_name,
 -				      wm_adsp_fw[dsp->fw].file, filetype);
 +	wm_coeff_parse_alg(dsp, &data, &alg_blk);
 +	for (i = 0; i < alg_blk.ncoeff; i++) {
 +		wm_coeff_parse_coeff(dsp, &data, &coeff_blk);
  
 -	if (*filename == NULL)
 -		return -ENOMEM;
 +		switch (coeff_blk.ctl_type) {
 +		case WMFW_CTL_TYPE_BYTES:
 +			break;
 +		case WMFW_CTL_TYPE_ACKED:
 +			if (coeff_blk.flags & WMFW_CTL_FLAG_SYS)
 +				continue;	/* ignore */
 +
 +			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
 +						WMFW_CTL_FLAG_VOLATILE |
 +						WMFW_CTL_FLAG_WRITEABLE |
 +						WMFW_CTL_FLAG_READABLE,
 +						0);
 +			if (ret)
 +				return -EINVAL;
 +			break;
 +		case WMFW_CTL_TYPE_HOSTEVENT:
 +			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
 +						WMFW_CTL_FLAG_SYS |
 +						WMFW_CTL_FLAG_VOLATILE |
 +						WMFW_CTL_FLAG_WRITEABLE |
 +						WMFW_CTL_FLAG_READABLE,
 +						0);
 +			if (ret)
 +				return -EINVAL;
 +			break;
 +		case WMFW_CTL_TYPE_HOST_BUFFER:
 +			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
 +						WMFW_CTL_FLAG_SYS |
 +						WMFW_CTL_FLAG_VOLATILE |
 +						WMFW_CTL_FLAG_READABLE,
 +						0);
 +			if (ret)
 +				return -EINVAL;
 +			break;
 +		default:
 +			adsp_err(dsp, "Unknown control type: %d\n",
 +				 coeff_blk.ctl_type);
 +			return -EINVAL;
 +		}
  
 -	/*
 -	 * Make sure that filename is lower-case and any non alpha-numeric
 -	 * characters except full stop and forward slash are replaced with
 -	 * hyphens.
 -	 */
 -	s = *filename;
 -	while (*s) {
 -		c = *s;
 -		if (isalnum(c))
 -			*s = tolower(c);
 -		else if ((c != '.') && (c != '/'))
 -			*s = '-';
 -		s++;
 -	}
 +		alg_region.type = coeff_blk.mem_type;
 +		alg_region.alg = alg_blk.id;
  
 -	ret = firmware_request_nowarn(firmware, *filename, cs_dsp->dev);
 -	if (ret != 0) {
 -		adsp_dbg(dsp, "Failed to request '%s'\n", *filename);
 -		kfree(*filename);
 -		*filename = NULL;
 +		ret = wm_adsp_create_control(dsp, &alg_region,
 +					     coeff_blk.offset,
 +					     coeff_blk.len,
 +					     coeff_blk.name,
 +					     coeff_blk.name_len,
 +					     coeff_blk.flags,
 +					     coeff_blk.ctl_type);
 +		if (ret < 0)
 +			adsp_err(dsp, "Failed to create control: %.*s, %d\n",
 +				 coeff_blk.name_len, coeff_blk.name, ret);
  	}
  
 -	return ret;
 +	return 0;
  }
  
 -static const char *cirrus_dir = "cirrus/";
 -static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,
 -					  const struct firmware **wmfw_firmware,
 -					  char **wmfw_filename,
 -					  const struct firmware **coeff_firmware,
 -					  char **coeff_filename)
 +static unsigned int wm_adsp1_parse_sizes(struct wm_adsp *dsp,
 +					 const char * const file,
 +					 unsigned int pos,
 +					 const struct firmware *firmware)
  {
 -	const char *system_name = dsp->system_name;
 -	const char *asoc_component_prefix = dsp->component->name_prefix;
 -	int ret = 0;
 +	const struct wmfw_adsp1_sizes *adsp1_sizes;
  
 -	if (system_name && asoc_component_prefix) {
 -		if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
 -						   cirrus_dir, system_name,
 -						   asoc_component_prefix, "wmfw")) {
 -			adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
 -			wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
 -						      cirrus_dir, system_name,
 -						      asoc_component_prefix, "bin");
 -			return 0;
 -		}
 -	}
 +	adsp1_sizes = (void *)&firmware->data[pos];
  
 -	if (system_name) {
 -		if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
 -						   cirrus_dir, system_name,
 -						   NULL, "wmfw")) {
 -			adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
 -			if (asoc_component_prefix)
 -				wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
 -							      cirrus_dir, system_name,
 -							      asoc_component_prefix, "bin");
 -
 -			if (!*coeff_firmware)
 -				wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
 -							      cirrus_dir, system_name,
 -							      NULL, "bin");
 -			return 0;
 -		}
 -	}
 +	adsp_dbg(dsp, "%s: %d DM, %d PM, %d ZM\n", file,
 +		 le32_to_cpu(adsp1_sizes->dm), le32_to_cpu(adsp1_sizes->pm),
 +		 le32_to_cpu(adsp1_sizes->zm));
  
 -	if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
 -					   "", NULL, NULL, "wmfw")) {
 -		adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
 -		wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
 -					      "", NULL, NULL, "bin");
 -		return 0;
 -	}
 +	return pos + sizeof(*adsp1_sizes);
 +}
  
 -	ret = wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
 -					    cirrus_dir, NULL, NULL, "wmfw");
 -	if (!ret) {
 -		adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
 -		wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
 -					      cirrus_dir, NULL, NULL, "bin");
 -		return 0;
 -	}
 +static unsigned int wm_adsp2_parse_sizes(struct wm_adsp *dsp,
 +					 const char * const file,
 +					 unsigned int pos,
 +					 const struct firmware *firmware)
 +{
 +	const struct wmfw_adsp2_sizes *adsp2_sizes;
  
 -	adsp_err(dsp, "Failed to request firmware <%s>%s-%s-%s<-%s<%s>>.wmfw\n",
 -		 cirrus_dir, dsp->part, dsp->fwf_name, wm_adsp_fw[dsp->fw].file,
 -		 system_name, asoc_component_prefix);
 +	adsp2_sizes = (void *)&firmware->data[pos];
  
 -	return -ENOENT;
 +	adsp_dbg(dsp, "%s: %d XM, %d YM %d PM, %d ZM\n", file,
 +		 le32_to_cpu(adsp2_sizes->xm), le32_to_cpu(adsp2_sizes->ym),
 +		 le32_to_cpu(adsp2_sizes->pm), le32_to_cpu(adsp2_sizes->zm));
 +
 +	return pos + sizeof(*adsp2_sizes);
  }
  
 -static int wm_adsp_common_init(struct wm_adsp *dsp)
 +static bool wm_adsp_validate_version(struct wm_adsp *dsp, unsigned int version)
  {
 -	char *p;
 +	switch (version) {
 +	case 0:
 +		adsp_warn(dsp, "Deprecated file format %d\n", version);
 +		return true;
 +	case 1:
 +	case 2:
 +		return true;
 +	default:
 +		return false;
 +	}
 +}
  
 -	INIT_LIST_HEAD(&dsp->compr_list);
 -	INIT_LIST_HEAD(&dsp->buffer_list);
 +static bool wm_halo_validate_version(struct wm_adsp *dsp, unsigned int version)
 +{
 +	switch (version) {
 +	case 3:
 +		return true;
 +	default:
 +		return false;
 +	}
 +}
  
 -	if (!dsp->fwf_name) {
 -		p = devm_kstrdup(dsp->cs_dsp.dev, dsp->cs_dsp.name, GFP_KERNEL);
 -		if (!p)
 -			return -ENOMEM;
 +static int wm_adsp_load(struct wm_adsp *dsp)
 +{
 +	LIST_HEAD(buf_list);
 +	const struct firmware *firmware;
 +	struct regmap *regmap = dsp->regmap;
 +	unsigned int pos = 0;
 +	const struct wmfw_header *header;
 +	const struct wmfw_adsp1_sizes *adsp1_sizes;
 +	const struct wmfw_footer *footer;
 +	const struct wmfw_region *region;
 +	const struct wm_adsp_region *mem;
 +	const char *region_name;
 +	char *file, *text = NULL;
 +	struct wm_adsp_buf *buf;
 +	unsigned int reg;
 +	int regions = 0;
 +	int ret, offset, type;
 +
 +	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +	if (file == NULL)
 +		return -ENOMEM;
  
 -		dsp->fwf_name = p;
 -		for (; *p != 0; ++p)
 -			*p = tolower(*p);
 +	snprintf(file, PAGE_SIZE, "%s-%s-%s.wmfw", dsp->part, dsp->fwf_name,
 +		 wm_adsp_fw[dsp->fw].file);
 +	file[PAGE_SIZE - 1] = '\0';
 +
 +	ret = request_firmware(&firmware, file, dsp->dev);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to request '%s'\n", file);
 +		goto out;
  	}
 +	ret = -EINVAL;
  
 -	return 0;
 -}
 +	pos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);
 +	if (pos >= firmware->size) {
 +		adsp_err(dsp, "%s: file too short, %zu bytes\n",
 +			 file, firmware->size);
 +		goto out_fw;
 +	}
  
 -int wm_adsp1_init(struct wm_adsp *dsp)
 -{
 -	int ret;
 +	header = (void *)&firmware->data[0];
  
 -	dsp->cs_dsp.client_ops = &wm_adsp1_client_ops;
 +	if (memcmp(&header->magic[0], "WMFW", 4) != 0) {
 +		adsp_err(dsp, "%s: invalid magic\n", file);
 +		goto out_fw;
 +	}
  
 -	ret = cs_dsp_adsp1_init(&dsp->cs_dsp);
 -	if (ret)
 -		return ret;
 +	if (!dsp->ops->validate_version(dsp, header->ver)) {
 +		adsp_err(dsp, "%s: unknown file format %d\n",
 +			 file, header->ver);
 +		goto out_fw;
 +	}
  
 -	return wm_adsp_common_init(dsp);
 -}
 -EXPORT_SYMBOL_GPL(wm_adsp1_init);
 +	adsp_info(dsp, "Firmware version: %d\n", header->ver);
 +	dsp->fw_ver = header->ver;
 +
 +	if (header->core != dsp->type) {
 +		adsp_err(dsp, "%s: invalid core %d != %d\n",
 +			 file, header->core, dsp->type);
 +		goto out_fw;
 +	}
 +
 +	pos = sizeof(*header);
 +	pos = dsp->ops->parse_sizes(dsp, file, pos, firmware);
 +
 +	footer = (void *)&firmware->data[pos];
 +	pos += sizeof(*footer);
 +
 +	if (le32_to_cpu(header->len) != pos) {
 +		adsp_err(dsp, "%s: unexpected header length %d\n",
 +			 file, le32_to_cpu(header->len));
 +		goto out_fw;
 +	}
 +
 +	adsp_dbg(dsp, "%s: timestamp %llu\n", file,
 +		 le64_to_cpu(footer->timestamp));
 +
 +	while (pos < firmware->size &&
 +	       sizeof(*region) < firmware->size - pos) {
 +		region = (void *)&(firmware->data[pos]);
 +		region_name = "Unknown";
 +		reg = 0;
 +		text = NULL;
 +		offset = le32_to_cpu(region->offset) & 0xffffff;
 +		type = be32_to_cpu(region->type) & 0xff;
 +
 +		switch (type) {
 +		case WMFW_NAME_TEXT:
 +			region_name = "Firmware name";
 +			text = kzalloc(le32_to_cpu(region->len) + 1,
 +				       GFP_KERNEL);
 +			break;
 +		case WMFW_ALGORITHM_DATA:
 +			region_name = "Algorithm";
 +			ret = wm_adsp_parse_coeff(dsp, region);
 +			if (ret != 0)
 +				goto out_fw;
 +			break;
 +		case WMFW_INFO_TEXT:
 +			region_name = "Information";
 +			text = kzalloc(le32_to_cpu(region->len) + 1,
 +				       GFP_KERNEL);
 +			break;
 +		case WMFW_ABSOLUTE:
 +			region_name = "Absolute";
 +			reg = offset;
 +			break;
 +		case WMFW_ADSP1_PM:
 +		case WMFW_ADSP1_DM:
 +		case WMFW_ADSP2_XM:
 +		case WMFW_ADSP2_YM:
 +		case WMFW_ADSP1_ZM:
 +		case WMFW_HALO_PM_PACKED:
 +		case WMFW_HALO_XM_PACKED:
 +		case WMFW_HALO_YM_PACKED:
 +			mem = wm_adsp_find_region(dsp, type);
 +			if (!mem) {
 +				adsp_err(dsp, "No region of type: %x\n", type);
 +				ret = -EINVAL;
 +				goto out_fw;
 +			}
 +
 +			region_name = wm_adsp_mem_region_name(type);
 +			reg = dsp->ops->region_to_reg(mem, offset);
 +			break;
 +		default:
 +			adsp_warn(dsp,
 +				  "%s.%d: Unknown region type %x at %d(%x)\n",
 +				  file, regions, type, pos, pos);
 +			break;
 +		}
 +
 +		adsp_dbg(dsp, "%s.%d: %d bytes at %d in %s\n", file,
 +			 regions, le32_to_cpu(region->len), offset,
 +			 region_name);
 +
 +		if (le32_to_cpu(region->len) >
 +		    firmware->size - pos - sizeof(*region)) {
 +			adsp_err(dsp,
 +				 "%s.%d: %s region len %d bytes exceeds file length %zu\n",
 +				 file, regions, region_name,
 +				 le32_to_cpu(region->len), firmware->size);
 +			ret = -EINVAL;
 +			goto out_fw;
 +		}
 +
 +		if (text) {
 +			memcpy(text, region->data, le32_to_cpu(region->len));
 +			adsp_info(dsp, "%s: %s\n", file, text);
 +			kfree(text);
 +			text = NULL;
 +		}
 +
 +		if (reg) {
 +			buf = wm_adsp_buf_alloc(region->data,
 +						le32_to_cpu(region->len),
 +						&buf_list);
 +			if (!buf) {
 +				adsp_err(dsp, "Out of memory\n");
 +				ret = -ENOMEM;
 +				goto out_fw;
 +			}
 +
 +			ret = regmap_raw_write_async(regmap, reg, buf->buf,
 +						     le32_to_cpu(region->len));
 +			if (ret != 0) {
 +				adsp_err(dsp,
 +					"%s.%d: Failed to write %d bytes at %d in %s: %d\n",
 +					file, regions,
 +					le32_to_cpu(region->len), offset,
 +					region_name, ret);
 +				goto out_fw;
 +			}
 +		}
 +
 +		pos += le32_to_cpu(region->len) + sizeof(*region);
 +		regions++;
 +	}
 +
 +	ret = regmap_async_complete(regmap);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to complete async write: %d\n", ret);
 +		goto out_fw;
 +	}
 +
 +	if (pos > firmware->size)
 +		adsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",
 +			  file, regions, pos - firmware->size);
 +
 +	wm_adsp_debugfs_save_wmfwname(dsp, file);
 +
 +out_fw:
 +	regmap_async_complete(regmap);
 +	wm_adsp_buf_free(&buf_list);
 +	release_firmware(firmware);
 +	kfree(text);
 +out:
 +	kfree(file);
 +
 +	return ret;
 +}
 +
 +/*
 + * Find wm_coeff_ctl with input name as its subname
 + * If not found, return NULL
 + */
 +static struct wm_coeff_ctl *wm_adsp_get_ctl(struct wm_adsp *dsp,
 +					     const char *name, int type,
 +					     unsigned int alg)
 +{
 +	struct wm_coeff_ctl *pos, *rslt = NULL;
 +	const char *fw_txt = wm_adsp_fw_text[dsp->fw];
 +
 +	list_for_each_entry(pos, &dsp->ctl_list, list) {
 +		if (!pos->subname)
 +			continue;
 +		if (strncmp(pos->subname, name, pos->subname_len) == 0 &&
 +		    pos->fw_name == fw_txt &&
 +		    pos->alg_region.alg == alg &&
 +		    pos->alg_region.type == type) {
 +			rslt = pos;
 +			break;
 +		}
 +	}
 +
 +	return rslt;
 +}
 +
 +int wm_adsp_write_ctl(struct wm_adsp *dsp, const char *name, int type,
 +		      unsigned int alg, void *buf, size_t len)
 +{
++<<<<<<< HEAD
++=======
++	struct cs_dsp_coeff_ctl *cs_ctl = cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg);
++>>>>>>> e8010efc7b83 (ASoC: wm_adsp: Minor clean and redundant code removal)
 +	struct wm_coeff_ctl *ctl;
 +	struct snd_kcontrol *kcontrol;
 +	char ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 +	int ret;
 +
++<<<<<<< HEAD
 +	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
 +	if (!ctl)
 +		return -EINVAL;
 +
 +	if (len > ctl->len)
 +		return -EINVAL;
 +
 +	ret = wm_coeff_write_ctrl(ctl, buf, len);
++=======
++	ret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, buf, len);
++>>>>>>> e8010efc7b83 (ASoC: wm_adsp: Minor clean and redundant code removal)
 +	if (ret)
 +		return ret;
 +
 +	if (ctl->flags & WMFW_CTL_FLAG_SYS)
 +		return 0;
 +
++	ctl = cs_ctl->priv;
++
 +	if (dsp->component->name_prefix)
 +		snprintf(ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s %s",
 +			 dsp->component->name_prefix, ctl->name);
 +	else
 +		snprintf(ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s",
 +			 ctl->name);
 +
 +	kcontrol = snd_soc_card_get_kcontrol(dsp->component->card, ctl_name);
 +	if (!kcontrol) {
 +		adsp_err(dsp, "Can't find kcontrol %s\n", ctl_name);
 +		return -EINVAL;
 +	}
 +
 +	snd_ctl_notify(dsp->component->card->snd_card,
 +		       SNDRV_CTL_EVENT_MASK_VALUE, &kcontrol->id);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(wm_adsp_write_ctl);
 +
 +int wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,
 +		     unsigned int alg, void *buf, size_t len)
 +{
++<<<<<<< HEAD
 +	struct wm_coeff_ctl *ctl;
 +
 +	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
 +	if (!ctl)
 +		return -EINVAL;
 +
 +	if (len > ctl->len)
 +		return -EINVAL;
 +
 +	return wm_coeff_read_ctrl(ctl, buf, len);
++=======
++	return cs_dsp_coeff_read_ctrl(cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg),
++				      0, buf, len);
++>>>>>>> e8010efc7b83 (ASoC: wm_adsp: Minor clean and redundant code removal)
 +}
 +EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
 +
 +static void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,
 +				  const struct wm_adsp_alg_region *alg_region)
 +{
 +	struct wm_coeff_ctl *ctl;
 +
 +	list_for_each_entry(ctl, &dsp->ctl_list, list) {
 +		if (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&
 +		    alg_region->alg == ctl->alg_region.alg &&
 +		    alg_region->type == ctl->alg_region.type) {
 +			ctl->alg_region.base = alg_region->base;
 +		}
 +	}
 +}
 +
 +static void *wm_adsp_read_algs(struct wm_adsp *dsp, size_t n_algs,
 +			       const struct wm_adsp_region *mem,
 +			       unsigned int pos, unsigned int len)
 +{
 +	void *alg;
 +	unsigned int reg;
 +	int ret;
 +	__be32 val;
 +
 +	if (n_algs == 0) {
 +		adsp_err(dsp, "No algorithms\n");
 +		return ERR_PTR(-EINVAL);
 +	}
 +
 +	if (n_algs > 1024) {
 +		adsp_err(dsp, "Algorithm count %zx excessive\n", n_algs);
 +		return ERR_PTR(-EINVAL);
 +	}
 +
 +	/* Read the terminator first to validate the length */
 +	reg = dsp->ops->region_to_reg(mem, pos + len);
 +
 +	ret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm list end: %d\n",
 +			ret);
 +		return ERR_PTR(ret);
 +	}
 +
 +	if (be32_to_cpu(val) != 0xbedead)
 +		adsp_warn(dsp, "Algorithm list end %x 0x%x != 0xbedead\n",
 +			  reg, be32_to_cpu(val));
 +
 +	/* Convert length from DSP words to bytes */
 +	len *= sizeof(u32);
 +
 +	alg = kzalloc(len, GFP_KERNEL | GFP_DMA);
 +	if (!alg)
 +		return ERR_PTR(-ENOMEM);
 +
 +	reg = dsp->ops->region_to_reg(mem, pos);
 +
 +	ret = regmap_raw_read(dsp->regmap, reg, alg, len);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm list: %d\n", ret);
 +		kfree(alg);
 +		return ERR_PTR(ret);
 +	}
 +
 +	return alg;
 +}
 +
 +static struct wm_adsp_alg_region *
 +	wm_adsp_find_alg_region(struct wm_adsp *dsp, int type, unsigned int id)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +
 +	list_for_each_entry(alg_region, &dsp->alg_regions, list) {
 +		if (id == alg_region->alg && type == alg_region->type)
 +			return alg_region;
 +	}
 +
 +	return NULL;
 +}
 +
 +static struct wm_adsp_alg_region *wm_adsp_create_region(struct wm_adsp *dsp,
 +							int type, __be32 id,
 +							__be32 base)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +
 +	alg_region = kzalloc(sizeof(*alg_region), GFP_KERNEL);
 +	if (!alg_region)
 +		return ERR_PTR(-ENOMEM);
 +
 +	alg_region->type = type;
 +	alg_region->alg = be32_to_cpu(id);
 +	alg_region->base = be32_to_cpu(base);
 +
 +	list_add_tail(&alg_region->list, &dsp->alg_regions);
 +
 +	if (dsp->fw_ver > 0)
 +		wm_adsp_ctl_fixup_base(dsp, alg_region);
 +
 +	return alg_region;
 +}
 +
 +static void wm_adsp_free_alg_regions(struct wm_adsp *dsp)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +
 +	while (!list_empty(&dsp->alg_regions)) {
 +		alg_region = list_first_entry(&dsp->alg_regions,
 +					      struct wm_adsp_alg_region,
 +					      list);
 +		list_del(&alg_region->list);
 +		kfree(alg_region);
 +	}
 +}
 +
 +static void wmfw_parse_id_header(struct wm_adsp *dsp,
 +				 struct wmfw_id_hdr *fw, int nalgs)
 +{
 +	dsp->fw_id = be32_to_cpu(fw->id);
 +	dsp->fw_id_version = be32_to_cpu(fw->ver);
 +
 +	adsp_info(dsp, "Firmware: %x v%d.%d.%d, %d algorithms\n",
 +		  dsp->fw_id, (dsp->fw_id_version & 0xff0000) >> 16,
 +		  (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,
 +		  nalgs);
 +}
 +
 +static void wmfw_v3_parse_id_header(struct wm_adsp *dsp,
 +				    struct wmfw_v3_id_hdr *fw, int nalgs)
 +{
 +	dsp->fw_id = be32_to_cpu(fw->id);
 +	dsp->fw_id_version = be32_to_cpu(fw->ver);
 +	dsp->fw_vendor_id = be32_to_cpu(fw->vendor_id);
 +
 +	adsp_info(dsp, "Firmware: %x vendor: 0x%x v%d.%d.%d, %d algorithms\n",
 +		  dsp->fw_id, dsp->fw_vendor_id,
 +		  (dsp->fw_id_version & 0xff0000) >> 16,
 +		  (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,
 +		  nalgs);
 +}
 +
 +static int wm_adsp_create_regions(struct wm_adsp *dsp, __be32 id, int nregions,
 +				const int *type, __be32 *base)
 +{
 +	struct wm_adsp_alg_region *alg_region;
 +	int i;
 +
 +	for (i = 0; i < nregions; i++) {
 +		alg_region = wm_adsp_create_region(dsp, type[i], id, base[i]);
 +		if (IS_ERR(alg_region))
 +			return PTR_ERR(alg_region);
 +	}
 +
 +	return 0;
 +}
 +
 +static int wm_adsp1_setup_algs(struct wm_adsp *dsp)
 +{
 +	struct wmfw_adsp1_id_hdr adsp1_id;
 +	struct wmfw_adsp1_alg_hdr *adsp1_alg;
 +	struct wm_adsp_alg_region *alg_region;
 +	const struct wm_adsp_region *mem;
 +	unsigned int pos, len;
 +	size_t n_algs;
 +	int i, ret;
 +
 +	mem = wm_adsp_find_region(dsp, WMFW_ADSP1_DM);
 +	if (WARN_ON(!mem))
 +		return -EINVAL;
 +
 +	ret = regmap_raw_read(dsp->regmap, mem->base, &adsp1_id,
 +			      sizeof(adsp1_id));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm info: %d\n",
 +			 ret);
 +		return ret;
 +	}
 +
 +	n_algs = be32_to_cpu(adsp1_id.n_algs);
 +
 +	wmfw_parse_id_header(dsp, &adsp1_id.fw, n_algs);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,
 +					   adsp1_id.fw.id, adsp1_id.zm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,
 +					   adsp1_id.fw.id, adsp1_id.dm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	/* Calculate offset and length in DSP words */
 +	pos = sizeof(adsp1_id) / sizeof(u32);
 +	len = (sizeof(*adsp1_alg) * n_algs) / sizeof(u32);
 +
 +	adsp1_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
 +	if (IS_ERR(adsp1_alg))
 +		return PTR_ERR(adsp1_alg);
 +
 +	for (i = 0; i < n_algs; i++) {
 +		adsp_info(dsp, "%d: ID %x v%d.%d.%d DM@%x ZM@%x\n",
 +			  i, be32_to_cpu(adsp1_alg[i].alg.id),
 +			  (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff0000) >> 16,
 +			  (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff00) >> 8,
 +			  be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff,
 +			  be32_to_cpu(adsp1_alg[i].dm),
 +			  be32_to_cpu(adsp1_alg[i].zm));
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,
 +						   adsp1_alg[i].alg.id,
 +						   adsp1_alg[i].dm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp1_alg[i + 1].dm);
 +				len -= be32_to_cpu(adsp1_alg[i].dm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region DM with ID %x\n",
 +					  be32_to_cpu(adsp1_alg[i].alg.id));
 +			}
 +		}
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,
 +						   adsp1_alg[i].alg.id,
 +						   adsp1_alg[i].zm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp1_alg[i + 1].zm);
 +				len -= be32_to_cpu(adsp1_alg[i].zm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region ZM with ID %x\n",
 +					  be32_to_cpu(adsp1_alg[i].alg.id));
 +			}
 +		}
 +	}
 +
 +out:
 +	kfree(adsp1_alg);
 +	return ret;
 +}
 +
 +static int wm_adsp2_setup_algs(struct wm_adsp *dsp)
 +{
 +	struct wmfw_adsp2_id_hdr adsp2_id;
 +	struct wmfw_adsp2_alg_hdr *adsp2_alg;
 +	struct wm_adsp_alg_region *alg_region;
 +	const struct wm_adsp_region *mem;
 +	unsigned int pos, len;
 +	size_t n_algs;
 +	int i, ret;
 +
 +	mem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);
 +	if (WARN_ON(!mem))
 +		return -EINVAL;
 +
 +	ret = regmap_raw_read(dsp->regmap, mem->base, &adsp2_id,
 +			      sizeof(adsp2_id));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm info: %d\n",
 +			 ret);
 +		return ret;
 +	}
 +
 +	n_algs = be32_to_cpu(adsp2_id.n_algs);
 +
 +	wmfw_parse_id_header(dsp, &adsp2_id.fw, n_algs);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,
 +					   adsp2_id.fw.id, adsp2_id.xm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,
 +					   adsp2_id.fw.id, adsp2_id.ym);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,
 +					   adsp2_id.fw.id, adsp2_id.zm);
 +	if (IS_ERR(alg_region))
 +		return PTR_ERR(alg_region);
 +
 +	/* Calculate offset and length in DSP words */
 +	pos = sizeof(adsp2_id) / sizeof(u32);
 +	len = (sizeof(*adsp2_alg) * n_algs) / sizeof(u32);
 +
 +	adsp2_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
 +	if (IS_ERR(adsp2_alg))
 +		return PTR_ERR(adsp2_alg);
 +
 +	for (i = 0; i < n_algs; i++) {
 +		adsp_info(dsp,
 +			  "%d: ID %x v%d.%d.%d XM@%x YM@%x ZM@%x\n",
 +			  i, be32_to_cpu(adsp2_alg[i].alg.id),
 +			  (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff0000) >> 16,
 +			  (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff00) >> 8,
 +			  be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff,
 +			  be32_to_cpu(adsp2_alg[i].xm),
 +			  be32_to_cpu(adsp2_alg[i].ym),
 +			  be32_to_cpu(adsp2_alg[i].zm));
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,
 +						   adsp2_alg[i].alg.id,
 +						   adsp2_alg[i].xm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp2_alg[i + 1].xm);
 +				len -= be32_to_cpu(adsp2_alg[i].xm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region XM with ID %x\n",
 +					  be32_to_cpu(adsp2_alg[i].alg.id));
 +			}
 +		}
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,
 +						   adsp2_alg[i].alg.id,
 +						   adsp2_alg[i].ym);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp2_alg[i + 1].ym);
 +				len -= be32_to_cpu(adsp2_alg[i].ym);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region YM with ID %x\n",
 +					  be32_to_cpu(adsp2_alg[i].alg.id));
 +			}
 +		}
 +
 +		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,
 +						   adsp2_alg[i].alg.id,
 +						   adsp2_alg[i].zm);
 +		if (IS_ERR(alg_region)) {
 +			ret = PTR_ERR(alg_region);
 +			goto out;
 +		}
 +		if (dsp->fw_ver == 0) {
 +			if (i + 1 < n_algs) {
 +				len = be32_to_cpu(adsp2_alg[i + 1].zm);
 +				len -= be32_to_cpu(adsp2_alg[i].zm);
 +				len *= 4;
 +				wm_adsp_create_control(dsp, alg_region, 0,
 +						     len, NULL, 0, 0,
 +						     WMFW_CTL_TYPE_BYTES);
 +			} else {
 +				adsp_warn(dsp, "Missing length info for region ZM with ID %x\n",
 +					  be32_to_cpu(adsp2_alg[i].alg.id));
 +			}
 +		}
 +	}
 +
 +out:
 +	kfree(adsp2_alg);
 +	return ret;
 +}
 +
 +static int wm_halo_create_regions(struct wm_adsp *dsp, __be32 id,
 +				  __be32 xm_base, __be32 ym_base)
 +{
 +	static const int types[] = {
 +		WMFW_ADSP2_XM, WMFW_HALO_XM_PACKED,
 +		WMFW_ADSP2_YM, WMFW_HALO_YM_PACKED
 +	};
 +	__be32 bases[] = { xm_base, xm_base, ym_base, ym_base };
 +
 +	return wm_adsp_create_regions(dsp, id, ARRAY_SIZE(types), types, bases);
 +}
 +
 +static int wm_halo_setup_algs(struct wm_adsp *dsp)
 +{
 +	struct wmfw_halo_id_hdr halo_id;
 +	struct wmfw_halo_alg_hdr *halo_alg;
 +	const struct wm_adsp_region *mem;
 +	unsigned int pos, len;
 +	size_t n_algs;
 +	int i, ret;
 +
 +	mem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);
 +	if (WARN_ON(!mem))
 +		return -EINVAL;
 +
 +	ret = regmap_raw_read(dsp->regmap, mem->base, &halo_id,
 +			      sizeof(halo_id));
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to read algorithm info: %d\n",
 +			 ret);
 +		return ret;
 +	}
 +
 +	n_algs = be32_to_cpu(halo_id.n_algs);
 +
 +	wmfw_v3_parse_id_header(dsp, &halo_id.fw, n_algs);
 +
 +	ret = wm_halo_create_regions(dsp, halo_id.fw.id,
 +				     halo_id.xm_base, halo_id.ym_base);
 +	if (ret)
 +		return ret;
 +
 +	/* Calculate offset and length in DSP words */
 +	pos = sizeof(halo_id) / sizeof(u32);
 +	len = (sizeof(*halo_alg) * n_algs) / sizeof(u32);
 +
 +	halo_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
 +	if (IS_ERR(halo_alg))
 +		return PTR_ERR(halo_alg);
 +
 +	for (i = 0; i < n_algs; i++) {
 +		adsp_info(dsp,
 +			  "%d: ID %x v%d.%d.%d XM@%x YM@%x\n",
 +			  i, be32_to_cpu(halo_alg[i].alg.id),
 +			  (be32_to_cpu(halo_alg[i].alg.ver) & 0xff0000) >> 16,
 +			  (be32_to_cpu(halo_alg[i].alg.ver) & 0xff00) >> 8,
 +			  be32_to_cpu(halo_alg[i].alg.ver) & 0xff,
 +			  be32_to_cpu(halo_alg[i].xm_base),
 +			  be32_to_cpu(halo_alg[i].ym_base));
 +
 +		ret = wm_halo_create_regions(dsp, halo_alg[i].alg.id,
 +					     halo_alg[i].xm_base,
 +					     halo_alg[i].ym_base);
 +		if (ret)
 +			goto out;
 +	}
 +
 +out:
 +	kfree(halo_alg);
 +	return ret;
 +}
 +
 +static int wm_adsp_load_coeff(struct wm_adsp *dsp)
 +{
 +	LIST_HEAD(buf_list);
 +	struct regmap *regmap = dsp->regmap;
 +	struct wmfw_coeff_hdr *hdr;
 +	struct wmfw_coeff_item *blk;
 +	const struct firmware *firmware;
 +	const struct wm_adsp_region *mem;
 +	struct wm_adsp_alg_region *alg_region;
 +	const char *region_name;
 +	int ret, pos, blocks, type, offset, reg;
 +	char *file;
 +	struct wm_adsp_buf *buf;
 +
 +	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +	if (file == NULL)
 +		return -ENOMEM;
 +
 +	snprintf(file, PAGE_SIZE, "%s-%s-%s.bin", dsp->part, dsp->fwf_name,
 +		 wm_adsp_fw[dsp->fw].file);
 +	file[PAGE_SIZE - 1] = '\0';
 +
 +	ret = request_firmware(&firmware, file, dsp->dev);
 +	if (ret != 0) {
 +		adsp_warn(dsp, "Failed to request '%s'\n", file);
 +		ret = 0;
 +		goto out;
 +	}
 +	ret = -EINVAL;
 +
 +	if (sizeof(*hdr) >= firmware->size) {
 +		adsp_err(dsp, "%s: file too short, %zu bytes\n",
 +			file, firmware->size);
 +		goto out_fw;
 +	}
 +
 +	hdr = (void *)&firmware->data[0];
 +	if (memcmp(hdr->magic, "WMDR", 4) != 0) {
 +		adsp_err(dsp, "%s: invalid magic\n", file);
 +		goto out_fw;
 +	}
 +
 +	switch (be32_to_cpu(hdr->rev) & 0xff) {
 +	case 1:
 +		break;
 +	default:
 +		adsp_err(dsp, "%s: Unsupported coefficient file format %d\n",
 +			 file, be32_to_cpu(hdr->rev) & 0xff);
 +		ret = -EINVAL;
 +		goto out_fw;
 +	}
 +
 +	adsp_dbg(dsp, "%s: v%d.%d.%d\n", file,
 +		(le32_to_cpu(hdr->ver) >> 16) & 0xff,
 +		(le32_to_cpu(hdr->ver) >>  8) & 0xff,
 +		le32_to_cpu(hdr->ver) & 0xff);
 +
 +	pos = le32_to_cpu(hdr->len);
 +
 +	blocks = 0;
 +	while (pos < firmware->size &&
 +	       sizeof(*blk) < firmware->size - pos) {
 +		blk = (void *)(&firmware->data[pos]);
 +
 +		type = le16_to_cpu(blk->type);
 +		offset = le16_to_cpu(blk->offset);
 +
 +		adsp_dbg(dsp, "%s.%d: %x v%d.%d.%d\n",
 +			 file, blocks, le32_to_cpu(blk->id),
 +			 (le32_to_cpu(blk->ver) >> 16) & 0xff,
 +			 (le32_to_cpu(blk->ver) >>  8) & 0xff,
 +			 le32_to_cpu(blk->ver) & 0xff);
 +		adsp_dbg(dsp, "%s.%d: %d bytes at 0x%x in %x\n",
 +			 file, blocks, le32_to_cpu(blk->len), offset, type);
 +
 +		reg = 0;
 +		region_name = "Unknown";
 +		switch (type) {
 +		case (WMFW_NAME_TEXT << 8):
 +		case (WMFW_INFO_TEXT << 8):
 +		case (WMFW_METADATA << 8):
 +			break;
 +		case (WMFW_ABSOLUTE << 8):
 +			/*
 +			 * Old files may use this for global
 +			 * coefficients.
 +			 */
 +			if (le32_to_cpu(blk->id) == dsp->fw_id &&
 +			    offset == 0) {
 +				region_name = "global coefficients";
 +				mem = wm_adsp_find_region(dsp, type);
 +				if (!mem) {
 +					adsp_err(dsp, "No ZM\n");
 +					break;
 +				}
 +				reg = dsp->ops->region_to_reg(mem, 0);
 +
 +			} else {
 +				region_name = "register";
 +				reg = offset;
 +			}
 +			break;
 +
 +		case WMFW_ADSP1_DM:
 +		case WMFW_ADSP1_ZM:
 +		case WMFW_ADSP2_XM:
 +		case WMFW_ADSP2_YM:
 +		case WMFW_HALO_XM_PACKED:
 +		case WMFW_HALO_YM_PACKED:
 +		case WMFW_HALO_PM_PACKED:
 +			adsp_dbg(dsp, "%s.%d: %d bytes in %x for %x\n",
 +				 file, blocks, le32_to_cpu(blk->len),
 +				 type, le32_to_cpu(blk->id));
 +
 +			mem = wm_adsp_find_region(dsp, type);
 +			if (!mem) {
 +				adsp_err(dsp, "No base for region %x\n", type);
 +				break;
 +			}
 +
 +			alg_region = wm_adsp_find_alg_region(dsp, type,
 +						le32_to_cpu(blk->id));
 +			if (alg_region) {
 +				reg = alg_region->base;
 +				reg = dsp->ops->region_to_reg(mem, reg);
 +				reg += offset;
 +			} else {
 +				adsp_err(dsp, "No %x for algorithm %x\n",
 +					 type, le32_to_cpu(blk->id));
 +			}
 +			break;
 +
 +		default:
 +			adsp_err(dsp, "%s.%d: Unknown region type %x at %d\n",
 +				 file, blocks, type, pos);
 +			break;
 +		}
 +
 +		if (reg) {
 +			if (le32_to_cpu(blk->len) >
 +			    firmware->size - pos - sizeof(*blk)) {
 +				adsp_err(dsp,
 +					 "%s.%d: %s region len %d bytes exceeds file length %zu\n",
 +					 file, blocks, region_name,
 +					 le32_to_cpu(blk->len),
 +					 firmware->size);
 +				ret = -EINVAL;
 +				goto out_fw;
 +			}
 +
 +			buf = wm_adsp_buf_alloc(blk->data,
 +						le32_to_cpu(blk->len),
 +						&buf_list);
 +			if (!buf) {
 +				adsp_err(dsp, "Out of memory\n");
 +				ret = -ENOMEM;
 +				goto out_fw;
 +			}
 +
 +			adsp_dbg(dsp, "%s.%d: Writing %d bytes at %x\n",
 +				 file, blocks, le32_to_cpu(blk->len),
 +				 reg);
 +			ret = regmap_raw_write_async(regmap, reg, buf->buf,
 +						     le32_to_cpu(blk->len));
 +			if (ret != 0) {
 +				adsp_err(dsp,
 +					"%s.%d: Failed to write to %x in %s: %d\n",
 +					file, blocks, reg, region_name, ret);
 +			}
 +		}
 +
 +		pos += (le32_to_cpu(blk->len) + sizeof(*blk) + 3) & ~0x03;
 +		blocks++;
 +	}
 +
 +	ret = regmap_async_complete(regmap);
 +	if (ret != 0)
 +		adsp_err(dsp, "Failed to complete async write: %d\n", ret);
 +
 +	if (pos > firmware->size)
 +		adsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",
 +			  file, blocks, pos - firmware->size);
 +
 +	wm_adsp_debugfs_save_binname(dsp, file);
 +
 +out_fw:
 +	regmap_async_complete(regmap);
 +	release_firmware(firmware);
 +	wm_adsp_buf_free(&buf_list);
 +out:
 +	kfree(file);
 +	return ret;
 +}
 +
 +static int wm_adsp_create_name(struct wm_adsp *dsp)
 +{
 +	char *p;
 +
 +	if (!dsp->name) {
 +		dsp->name = devm_kasprintf(dsp->dev, GFP_KERNEL, "DSP%d",
 +					   dsp->num);
 +		if (!dsp->name)
 +			return -ENOMEM;
 +	}
 +
 +	if (!dsp->fwf_name) {
 +		p = devm_kstrdup(dsp->dev, dsp->name, GFP_KERNEL);
 +		if (!p)
 +			return -ENOMEM;
 +
 +		dsp->fwf_name = p;
 +		for (; *p != 0; ++p)
 +			*p = tolower(*p);
 +	}
 +
 +	return 0;
 +}
 +
 +static int wm_adsp_common_init(struct wm_adsp *dsp)
 +{
 +	int ret;
 +
 +	ret = wm_adsp_create_name(dsp);
 +	if (ret)
 +		return ret;
 +
 +	INIT_LIST_HEAD(&dsp->alg_regions);
 +	INIT_LIST_HEAD(&dsp->ctl_list);
 +	INIT_LIST_HEAD(&dsp->compr_list);
 +	INIT_LIST_HEAD(&dsp->buffer_list);
 +
 +	mutex_init(&dsp->pwr_lock);
 +
 +	return 0;
 +}
 +
 +int wm_adsp1_init(struct wm_adsp *dsp)
 +{
 +	dsp->ops = &wm_adsp1_ops;
 +
 +	return wm_adsp_common_init(dsp);
 +}
 +EXPORT_SYMBOL_GPL(wm_adsp1_init);
  
  int wm_adsp1_event(struct snd_soc_dapm_widget *w,
  		   struct snd_kcontrol *kcontrol,
* Unmerged path sound/soc/codecs/wm_adsp.c
