PCI: vmd: Honor ACPI _OSC on PCIe features

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Kai-Heng Feng <kai.heng.feng@canonical.com>
commit 04b12ef163d10e348db664900ae7f611b83c7a0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/04b12ef1.failed

When Samsung PCIe Gen4 NVMe is connected to Intel ADL VMD, the
combination causes AER message flood and drags the system performance
down.

The issue doesn't happen when VMD mode is disabled in BIOS, since AER
isn't enabled by acpi_pci_root_create() . When VMD mode is enabled, AER
is enabled regardless of _OSC:
[    0.410076] acpi PNP0A08:00: _OSC: platform does not support [AER]
...
[    1.486704] pcieport 10000:e0:06.0: AER: enabled with IRQ 146

Since VMD is an aperture to regular PCIe root ports, honor ACPI _OSC to
disable PCIe features accordingly to resolve the issue.

	Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215027
Link: https://lore.kernel.org/r/20211203031541.1428904-1-kai.heng.feng@canonical.com
	Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 04b12ef163d10e348db664900ae7f611b83c7a0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/vmd.c
diff --cc drivers/pci/controller/vmd.c
index 6e122dfa3c2f,5c9211dee93e..000000000000
--- a/drivers/pci/controller/vmd.c
+++ b/drivers/pci/controller/vmd.c
@@@ -577,6 -646,70 +577,73 @@@ static int vmd_get_bus_number_start(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static irqreturn_t vmd_irq(int irq, void *data)
+ {
+ 	struct vmd_irq_list *irqs = data;
+ 	struct vmd_irq *vmdirq;
+ 	int idx;
+ 
+ 	idx = srcu_read_lock(&irqs->srcu);
+ 	list_for_each_entry_rcu(vmdirq, &irqs->irq_list, node)
+ 		generic_handle_irq(vmdirq->virq);
+ 	srcu_read_unlock(&irqs->srcu, idx);
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int vmd_alloc_irqs(struct vmd_dev *vmd)
+ {
+ 	struct pci_dev *dev = vmd->dev;
+ 	int i, err;
+ 
+ 	vmd->msix_count = pci_msix_vec_count(dev);
+ 	if (vmd->msix_count < 0)
+ 		return -ENODEV;
+ 
+ 	vmd->msix_count = pci_alloc_irq_vectors(dev, vmd->first_vec + 1,
+ 						vmd->msix_count, PCI_IRQ_MSIX);
+ 	if (vmd->msix_count < 0)
+ 		return vmd->msix_count;
+ 
+ 	vmd->irqs = devm_kcalloc(&dev->dev, vmd->msix_count, sizeof(*vmd->irqs),
+ 				 GFP_KERNEL);
+ 	if (!vmd->irqs)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < vmd->msix_count; i++) {
+ 		err = init_srcu_struct(&vmd->irqs[i].srcu);
+ 		if (err)
+ 			return err;
+ 
+ 		INIT_LIST_HEAD(&vmd->irqs[i].irq_list);
+ 		err = devm_request_irq(&dev->dev, pci_irq_vector(dev, i),
+ 				       vmd_irq, IRQF_NO_THREAD,
+ 				       vmd->name, &vmd->irqs[i]);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Since VMD is an aperture to regular PCIe root ports, only allow it to
+  * control features that the OS is allowed to control on the physical PCI bus.
+  */
+ static void vmd_copy_host_bridge_flags(struct pci_host_bridge *root_bridge,
+ 				       struct pci_host_bridge *vmd_bridge)
+ {
+ 	vmd_bridge->native_pcie_hotplug = root_bridge->native_pcie_hotplug;
+ 	vmd_bridge->native_shpc_hotplug = root_bridge->native_shpc_hotplug;
+ 	vmd_bridge->native_aer = root_bridge->native_aer;
+ 	vmd_bridge->native_pme = root_bridge->native_pme;
+ 	vmd_bridge->native_ltr = root_bridge->native_ltr;
+ 	vmd_bridge->native_dpc = root_bridge->native_dpc;
+ }
+ 
++>>>>>>> 04b12ef163d1 (PCI: vmd: Honor ACPI _OSC on PCIe features)
  static int vmd_enable_domain(struct vmd_dev *vmd, unsigned long features)
  {
  	struct pci_sysdata *sd = &vmd->sysdata;
@@@ -706,8 -847,12 +773,11 @@@
  		return -ENODEV;
  	}
  
+ 	vmd_copy_host_bridge_flags(pci_find_host_bridge(vmd->dev->bus),
+ 				   to_pci_host_bridge(vmd->bus->bridge));
+ 
  	vmd_attach_resources(vmd);
 -	if (vmd->irq_domain)
 -		dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
 +	dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
  
  	vmd_acpi_begin();
  
* Unmerged path drivers/pci/controller/vmd.c
