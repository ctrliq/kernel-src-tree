mm/memory_hotplug: remove CONFIG_MEMORY_HOTPLUG_SPARSE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author David Hildenbrand <david@redhat.com>
commit 50f9481ed9fb8a2d2a06a155634c7f9eeff9fa61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/50f9481e.failed

CONFIG_MEMORY_HOTPLUG depends on CONFIG_SPARSEMEM, so there is no need for
CONFIG_MEMORY_HOTPLUG_SPARSE anymore; adjust all instances to use
CONFIG_MEMORY_HOTPLUG and remove CONFIG_MEMORY_HOTPLUG_SPARSE.

Link: https://lkml.kernel.org/r/20210929143600.49379-3-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Acked-by: Shuah Khan <skhan@linuxfoundation.org>	[kselftest]
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Acked-by: Oscar Salvador <osalvador@suse.de>
	Cc: Alex Shi <alexs@kernel.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Jason Wang <jasowang@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: "Michael S. Tsirkin" <mst@redhat.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Mike Rapoport <rppt@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 50f9481ed9fb8a2d2a06a155634c7f9eeff9fa61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/virtio/Kconfig
#	include/linux/memory.h
#	mm/memory_hotplug.c
diff --cc drivers/virtio/Kconfig
index 28a2794652bc,3654def9915c..000000000000
--- a/drivers/virtio/Kconfig
+++ b/drivers/virtio/Kconfig
@@@ -75,6 -93,23 +75,26 @@@ config VIRTIO_BALLOO
  
  	 If unsure, say M.
  
++<<<<<<< HEAD
++=======
+ config VIRTIO_MEM
+ 	tristate "Virtio mem driver"
+ 	default m
+ 	depends on X86_64
+ 	depends on VIRTIO
+ 	depends on MEMORY_HOTPLUG
+ 	depends on MEMORY_HOTREMOVE
+ 	depends on CONTIG_ALLOC
+ 	help
+ 	 This driver provides access to virtio-mem paravirtualized memory
+ 	 devices, allowing to hotplug and hotunplug memory.
+ 
+ 	 This driver was only tested under x86-64, but should theoretically
+ 	 work on all architectures that support memory hotplug and hotremove.
+ 
+ 	 If unsure, say M.
+ 
++>>>>>>> 50f9481ed9fb (mm/memory_hotplug: remove CONFIG_MEMORY_HOTPLUG_SPARSE)
  config VIRTIO_INPUT
  	tristate "Virtio input driver"
  	depends on VIRTIO
diff --cc include/linux/memory.h
index b01c2c56d418,0328ec039c38..000000000000
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@@ -79,10 -126,19 +79,17 @@@ static inline int memory_notify(unsigne
  {
  	return 0;
  }
- #else
+ static inline int hotplug_memory_notifier(notifier_fn_t fn, int pri)
+ {
+ 	return 0;
+ }
+ /* These aren't inline functions due to a GCC bug. */
+ #define register_hotmemory_notifier(nb)    ({ (void)(nb); 0; })
+ #define unregister_hotmemory_notifier(nb)  ({ (void)(nb); })
+ #else /* CONFIG_MEMORY_HOTPLUG */
  extern int register_memory_notifier(struct notifier_block *nb);
  extern void unregister_memory_notifier(struct notifier_block *nb);
 -int create_memory_block_devices(unsigned long start, unsigned long size,
 -				unsigned long vmemmap_pages,
 -				struct memory_group *group);
 +int create_memory_block_devices(unsigned long start, unsigned long size);
  void remove_memory_block_devices(unsigned long start, unsigned long size);
  extern void memory_dev_init(void);
  extern int memory_notify(unsigned long val, void *v);
@@@ -91,10 -147,14 +98,21 @@@ typedef int (*walk_memory_blocks_func_t
  extern int walk_memory_blocks(unsigned long start, unsigned long size,
  			      void *arg, walk_memory_blocks_func_t func);
  extern int for_each_memory_block(void *arg, walk_memory_blocks_func_t func);
++<<<<<<< HEAD
 +#define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 +#endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 +
 +#ifdef CONFIG_MEMORY_HOTPLUG
++=======
+ 
+ extern int memory_group_register_static(int nid, unsigned long max_pages);
+ extern int memory_group_register_dynamic(int nid, unsigned long unit_pages);
+ extern int memory_group_unregister(int mgid);
+ struct memory_group *memory_group_find_by_id(int mgid);
+ typedef int (*walk_memory_groups_func_t)(struct memory_group *, void *);
+ int walk_dynamic_memory_groups(int nid, walk_memory_groups_func_t func,
+ 			       struct memory_group *excluded, void *arg);
++>>>>>>> 50f9481ed9fb (mm/memory_hotplug: remove CONFIG_MEMORY_HOTPLUG_SPARSE)
  #define hotplug_memory_notifier(fn, pri) ({		\
  	static __meminitdata struct notifier_block fn##_mem_nb =\
  		{ .notifier_call = fn, .priority = pri };\
@@@ -102,12 -162,7 +120,16 @@@
  })
  #define register_hotmemory_notifier(nb)		register_memory_notifier(nb)
  #define unregister_hotmemory_notifier(nb) 	unregister_memory_notifier(nb)
++<<<<<<< HEAD
 +#else
 +#define hotplug_memory_notifier(fn, pri)	({ 0; })
 +/* These aren't inline functions due to a GCC bug. */
 +#define register_hotmemory_notifier(nb)    ({ (void)(nb); 0; })
 +#define unregister_hotmemory_notifier(nb)  ({ (void)(nb); })
 +#endif
++=======
+ #endif	/* CONFIG_MEMORY_HOTPLUG */
++>>>>>>> 50f9481ed9fb (mm/memory_hotplug: remove CONFIG_MEMORY_HOTPLUG_SPARSE)
  
  /*
   * Kernel text modification mutex, used for code patching. Users of this lock
diff --cc mm/memory_hotplug.c
index 73cbc6ea1fee,fc07ce7b5842..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -139,123 -220,6 +139,126 @@@ static void release_memory_resource(str
  	kfree(res);
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
 +void get_page_bootmem(unsigned long info,  struct page *page,
 +		      unsigned long type)
 +{
 +	page->freelist = (void *)type;
 +	SetPagePrivate(page);
 +	set_page_private(page, info);
 +	page_ref_inc(page);
 +}
 +
 +void put_page_bootmem(struct page *page)
 +{
 +	unsigned long type;
 +
 +	type = (unsigned long) page->freelist;
 +	BUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||
 +	       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);
 +
 +	if (page_ref_dec_return(page) == 1) {
 +		page->freelist = NULL;
 +		ClearPagePrivate(page);
 +		set_page_private(page, 0);
 +		INIT_LIST_HEAD(&page->lru);
 +		free_reserved_page(page);
 +	}
 +}
 +
 +#ifdef CONFIG_HAVE_BOOTMEM_INFO_NODE
 +#ifndef CONFIG_SPARSEMEM_VMEMMAP
 +static void register_page_bootmem_info_section(unsigned long start_pfn)
 +{
 +	unsigned long mapsize, section_nr, i;
 +	struct mem_section *ms;
 +	struct page *page, *memmap;
 +	struct mem_section_usage *usage;
 +
 +	section_nr = pfn_to_section_nr(start_pfn);
 +	ms = __nr_to_section(section_nr);
 +
 +	/* Get section's memmap address */
 +	memmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);
 +
 +	/*
 +	 * Get page for the memmap's phys address
 +	 * XXX: need more consideration for sparse_vmemmap...
 +	 */
 +	page = virt_to_page(memmap);
 +	mapsize = sizeof(struct page) * PAGES_PER_SECTION;
 +	mapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;
 +
 +	/* remember memmap's page */
 +	for (i = 0; i < mapsize; i++, page++)
 +		get_page_bootmem(section_nr, page, SECTION_INFO);
 +
 +	usage = ms->usage;
 +	page = virt_to_page(usage);
 +
 +	mapsize = PAGE_ALIGN(mem_section_usage_size()) >> PAGE_SHIFT;
 +
 +	for (i = 0; i < mapsize; i++, page++)
 +		get_page_bootmem(section_nr, page, MIX_SECTION_INFO);
 +
 +}
 +#else /* CONFIG_SPARSEMEM_VMEMMAP */
 +static void register_page_bootmem_info_section(unsigned long start_pfn)
 +{
 +	unsigned long mapsize, section_nr, i;
 +	struct mem_section *ms;
 +	struct page *page, *memmap;
 +	struct mem_section_usage *usage;
 +
 +	section_nr = pfn_to_section_nr(start_pfn);
 +	ms = __nr_to_section(section_nr);
 +
 +	memmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);
 +
 +	register_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);
 +
 +	usage = ms->usage;
 +	page = virt_to_page(usage);
 +
 +	mapsize = PAGE_ALIGN(mem_section_usage_size()) >> PAGE_SHIFT;
 +
 +	for (i = 0; i < mapsize; i++, page++)
 +		get_page_bootmem(section_nr, page, MIX_SECTION_INFO);
 +}
 +#endif /* !CONFIG_SPARSEMEM_VMEMMAP */
 +
 +void __init register_page_bootmem_info_node(struct pglist_data *pgdat)
 +{
 +	unsigned long i, pfn, end_pfn, nr_pages;
 +	int node = pgdat->node_id;
 +	struct page *page;
 +
 +	nr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;
 +	page = virt_to_page(pgdat);
 +
 +	for (i = 0; i < nr_pages; i++, page++)
 +		get_page_bootmem(node, page, NODE_INFO);
 +
 +	pfn = pgdat->node_start_pfn;
 +	end_pfn = pgdat_end_pfn(pgdat);
 +
 +	/* register section info */
 +	for (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {
 +		/*
 +		 * Some platforms can assign the same pfn to multiple nodes - on
 +		 * node0 as well as nodeN.  To avoid registering a pfn against
 +		 * multiple nodes we check that this pfn does not already
 +		 * reside in some other nodes.
 +		 */
 +		if (pfn_valid(pfn) && (early_pfn_to_nid(pfn) == node))
 +			register_page_bootmem_info_section(pfn);
 +	}
 +}
 +#endif /* CONFIG_HAVE_BOOTMEM_INFO_NODE */
 +
++=======
++>>>>>>> 50f9481ed9fb (mm/memory_hotplug: remove CONFIG_MEMORY_HOTPLUG_SPARSE)
  static int check_pfn_span(unsigned long pfn, unsigned long nr_pages,
  		const char *reason)
  {
diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index e85390fb2d44..08b232fdddf0 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -42,7 +42,7 @@ struct machdep_calls {
 	void		(*iommu_save)(void);
 	void		(*iommu_restore)(void);
 #endif
-#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+#ifdef CONFIG_MEMORY_HOTPLUG
 	unsigned long	(*memory_block_size)(void);
 #endif
 #endif /* CONFIG_PPC64 */
diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index d4e16a193e69..758316156e53 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -816,7 +816,7 @@ void __init setup_per_cpu_areas(void)
 }
 #endif
 
-#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+#ifdef CONFIG_MEMORY_HOTPLUG
 unsigned long memory_block_size_bytes(void)
 {
 	if (ppc_md.memory_block_size)
diff --git a/arch/powerpc/platforms/powernv/setup.c b/arch/powerpc/platforms/powernv/setup.c
index af0ae186cee6..8eefa9880efd 100644
--- a/arch/powerpc/platforms/powernv/setup.c
+++ b/arch/powerpc/platforms/powernv/setup.c
@@ -403,7 +403,7 @@ static void pnv_kexec_cpu_down(int crash_shutdown, int secondary)
 }
 #endif /* CONFIG_KEXEC_CORE */
 
-#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+#ifdef CONFIG_MEMORY_HOTPLUG
 static unsigned long pnv_memory_block_size(void)
 {
 	/*
@@ -516,7 +516,7 @@ define_machine(powernv) {
 #ifdef CONFIG_KEXEC_CORE
 	.kexec_cpu_down		= pnv_kexec_cpu_down,
 #endif
-#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+#ifdef CONFIG_MEMORY_HOTPLUG
 	.memory_block_size	= pnv_memory_block_size,
 #endif
 };
diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 31a04152c2c4..ccde32531283 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -1072,7 +1072,7 @@ define_machine(pseries) {
 	.machine_kexec          = pSeries_machine_kexec,
 	.kexec_cpu_down         = pseries_kexec_cpu_down,
 #endif
-#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+#ifdef CONFIG_MEMORY_HOTPLUG
 	.memory_block_size	= pseries_memory_block_size,
 #endif
 };
diff --git a/drivers/base/Makefile b/drivers/base/Makefile
index 69690fe9569a..0fab7e1267fc 100644
--- a/drivers/base/Makefile
+++ b/drivers/base/Makefile
@@ -13,7 +13,7 @@ obj-y			+= power/
 obj-$(CONFIG_ISA_BUS_API)	+= isa.o
 obj-y				+= firmware_loader/
 obj-$(CONFIG_NUMA)	+= node.o
-obj-$(CONFIG_MEMORY_HOTPLUG_SPARSE) += memory.o
+obj-$(CONFIG_MEMORY_HOTPLUG) += memory.o
 ifeq ($(CONFIG_SYSFS),y)
 obj-$(CONFIG_MODULES)	+= module.o
 endif
diff --git a/drivers/base/node.c b/drivers/base/node.c
index c69b28522c92..8985d875c7c8 100644
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@ -631,7 +631,7 @@ static void node_device_release(struct device *dev)
 {
 	struct node *node = to_node(dev);
 
-#if defined(CONFIG_MEMORY_HOTPLUG_SPARSE) && defined(CONFIG_HUGETLBFS)
+#if defined(CONFIG_MEMORY_HOTPLUG) && defined(CONFIG_HUGETLBFS)
 	/*
 	 * We schedule the work only when a memory section is
 	 * onlined/offlined on this node. When we come here,
@@ -784,7 +784,7 @@ int unregister_cpu_under_node(unsigned int cpu, unsigned int nid)
 	return 0;
 }
 
-#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+#ifdef CONFIG_MEMORY_HOTPLUG
 static int __ref get_nid_for_pfn(unsigned long pfn)
 {
 	if (!pfn_valid_within(pfn))
@@ -962,10 +962,9 @@ static int node_memory_callback(struct notifier_block *self,
 	return NOTIFY_OK;
 }
 #endif	/* CONFIG_HUGETLBFS */
-#endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
+#endif /* CONFIG_MEMORY_HOTPLUG */
 
-#if !defined(CONFIG_MEMORY_HOTPLUG_SPARSE) || \
-    !defined(CONFIG_HUGETLBFS)
+#if !defined(CONFIG_MEMORY_HOTPLUG) || !defined(CONFIG_HUGETLBFS)
 static inline int node_memory_callback(struct notifier_block *self,
 				unsigned long action, void *arg)
 {
* Unmerged path drivers/virtio/Kconfig
* Unmerged path include/linux/memory.h
diff --git a/include/linux/node.h b/include/linux/node.h
index 8e5a29897936..bb21fd631b16 100644
--- a/include/linux/node.h
+++ b/include/linux/node.h
@@ -85,7 +85,7 @@ struct node {
 	struct device	dev;
 	struct list_head access_list;
 
-#if defined(CONFIG_MEMORY_HOTPLUG_SPARSE) && defined(CONFIG_HUGETLBFS)
+#if defined(CONFIG_MEMORY_HOTPLUG) && defined(CONFIG_HUGETLBFS)
 	struct work_struct	node_work;
 #endif
 #ifdef CONFIG_HMEM_REPORTING
@@ -98,7 +98,7 @@ struct memory_block;
 extern struct node *node_devices[];
 typedef  void (*node_registration_func_t)(struct node *);
 
-#if defined(CONFIG_MEMORY_HOTPLUG_SPARSE) && defined(CONFIG_NUMA)
+#if defined(CONFIG_MEMORY_HOTPLUG) && defined(CONFIG_NUMA)
 void link_mem_sections(int nid, unsigned long start_pfn,
 		       unsigned long end_pfn,
 		       enum meminit_context context);
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index be890e8aefe1..a72ba523b7dc 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -713,7 +713,7 @@ config DEBUG_MEMORY_INIT
 
 config MEMORY_NOTIFIER_ERROR_INJECT
 	tristate "Memory hotplug notifier error injection module"
-	depends on MEMORY_HOTPLUG_SPARSE && NOTIFIER_ERROR_INJECTION
+	depends on MEMORY_HOTPLUG && NOTIFIER_ERROR_INJECTION
 	help
 	  This option provides the ability to inject artificial errors to
 	  memory hotplug notifier chain callbacks.  It is controlled through
diff --git a/mm/Kconfig b/mm/Kconfig
index 16f09184d951..43b71ec5f998 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -160,10 +160,6 @@ config MEMORY_HOTPLUG
 	depends on 64BIT || BROKEN
 	select NUMA_KEEP_MEMINFO if NUMA
 
-config MEMORY_HOTPLUG_SPARSE
-	def_bool y
-	depends on SPARSEMEM && MEMORY_HOTPLUG
-
 config MEMORY_HOTPLUG_DEFAULT_ONLINE
         bool "Online the newly added memory blocks by default"
         depends on MEMORY_HOTPLUG
* Unmerged path mm/memory_hotplug.c
diff --git a/tools/testing/selftests/memory-hotplug/config b/tools/testing/selftests/memory-hotplug/config
index 2fde30191a47..3d47ba8be1b9 100644
--- a/tools/testing/selftests/memory-hotplug/config
+++ b/tools/testing/selftests/memory-hotplug/config
@@ -1,4 +1,3 @@
 CONFIG_MEMORY_HOTPLUG=y
-CONFIG_MEMORY_HOTPLUG_SPARSE=y
 CONFIG_NOTIFIER_ERROR_INJECTION=y
 CONFIG_MEMORY_NOTIFIER_ERROR_INJECT=m
