NFS: Don't ask for readdirplus unless it can help nfs_getattr()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit ad1e109a4109ce0cbdfebfbe1958d0c333166d5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ad1e109a.failed

If attribute caching is turned off, then use of readdirplus is not going
to help stat() performance.
Readdirplus also doesn't help if a file is being written to, since we
will have to flush those writes in order to sync the mtime/ctime.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit ad1e109a4109ce0cbdfebfbe1958d0c333166d5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
diff --cc fs/nfs/inode.c
index d40260446017,e51d86707fca..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -783,26 -780,32 +783,52 @@@ void nfs_setattr_update_inode(struct in
  }
  EXPORT_SYMBOL_GPL(nfs_setattr_update_inode);
  
+ /*
+  * Don't request help from readdirplus if the file is being written to,
+  * or if attribute caching is turned off
+  */
+ static bool nfs_getattr_readdirplus_enable(const struct inode *inode)
+ {
+ 	return nfs_server_capable(inode, NFS_CAP_READDIRPLUS) &&
+ 	       !nfs_have_writebacks(inode) && NFS_MAXATTRTIMEO(inode) > 5 * HZ;
+ }
+ 
  static void nfs_readdirplus_parent_cache_miss(struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct dentry *parent;
 +
 +	if (!nfs_server_capable(d_inode(dentry), NFS_CAP_READDIRPLUS))
 +		return;
 +	parent = dget_parent(dentry);
 +	nfs_force_use_readdirplus(d_inode(parent));
 +	dput(parent);
++=======
+ 	if (!IS_ROOT(dentry)) {
+ 		struct dentry *parent = dget_parent(dentry);
+ 		nfs_readdir_record_entry_cache_miss(d_inode(parent));
+ 		dput(parent);
+ 	}
++>>>>>>> ad1e109a4109 (NFS: Don't ask for readdirplus unless it can help nfs_getattr())
  }
  
  static void nfs_readdirplus_parent_cache_hit(struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct dentry *parent;
 +
 +	if (!nfs_server_capable(d_inode(dentry), NFS_CAP_READDIRPLUS))
 +		return;
 +	parent = dget_parent(dentry);
 +	nfs_advise_use_readdirplus(d_inode(parent));
 +	dput(parent);
++=======
+ 	if (!IS_ROOT(dentry)) {
+ 		struct dentry *parent = dget_parent(dentry);
+ 		nfs_readdir_record_entry_cache_hit(d_inode(parent));
+ 		dput(parent);
+ 	}
++>>>>>>> ad1e109a4109 (NFS: Don't ask for readdirplus unless it can help nfs_getattr())
  }
  
  static u32 nfs_get_valid_attrmask(struct inode *inode)
* Unmerged path fs/nfs/inode.c
