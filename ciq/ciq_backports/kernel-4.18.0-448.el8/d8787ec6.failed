wifi: mac80211: add vif link addition/removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit d8787ec6b4ef1857b827699eca6f5978d0aecd74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d8787ec6.failed

Add the necessary infrastructure, including a new driver
method, to add/remove links to/from an interface.

Also add the missing link address to bss_conf (which we
use as link_conf too), and fill it, in station mode for
now just randomly, in AP mode we get the address from
cfg80211 since the link must be created with an address
first.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit d8787ec6b4ef1857b827699eca6f5978d0aecd74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/mac80211.h
#	net/mac80211/driver-ops.h
#	net/mac80211/iface.c
#	net/mac80211/trace.h
diff --cc include/net/mac80211.h
index 7d4037ae5055,f221afdfa475..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -1707,8 -1740,12 +1709,14 @@@ enum ieee80211_offload_flags 
   * use during the life of a virtual interface.
   *
   * @type: type of this virtual interface
 - * @cfg: vif configuration, see &struct ieee80211_vif_cfg
   * @bss_conf: BSS configuration for this interface, either our own
   *	or the BSS we're associated to
++<<<<<<< HEAD
++=======
+  * @link_conf: in case of MLD, the per-link BSS configuration,
+  *	indexed by link ID
+  * @valid_links: bitmap of valid links, or 0 for non-MLO.
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
   * @addr: address of this interface
   * @p2p: indicates whether this AP or STA interface is a p2p
   *	interface, i.e. a GO or p2p-sta respectively
@@@ -1741,7 -1778,10 +1749,12 @@@
   */
  struct ieee80211_vif {
  	enum nl80211_iftype type;
 -	struct ieee80211_vif_cfg cfg;
  	struct ieee80211_bss_conf bss_conf;
++<<<<<<< HEAD
++=======
+ 	struct ieee80211_bss_conf *link_conf[IEEE80211_MLD_MAX_NUM_LINKS];
+ 	u16 valid_links;
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
  	u8 addr[ETH_ALEN] __aligned(2);
  	bool p2p;
  
@@@ -3932,6 -4030,15 +3945,18 @@@ struct ieee80211_prep_tx_info 
   *	radar channel.
   *	The caller is expected to set chandef pointer to NULL in order to
   *	disable background CAC/radar detection.
++<<<<<<< HEAD
++=======
+  * @net_fill_forward_path: Called from .ndo_fill_forward_path in order to
+  *	resolve a path for hardware flow offloading
+  * @change_vif_links: Change the valid links on an interface, note that while
+  *	removing the old link information is still valid (link_conf pointer),
+  *	but may immediately disappear after the function returns. The old or
+  *	new links bitmaps may be 0 if going from/to a non-MLO situation.
+  *	The @old[] array contains pointers to the old bss_conf structures
+  *	that were already removed, in case they're needed.
+  *	This callback can sleep.
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
   */
  struct ieee80211_ops {
  	void (*tx)(struct ieee80211_hw *hw,
@@@ -4262,6 -4377,15 +4287,18 @@@
  				     struct ieee80211_sta *sta, u8 flowid);
  	int (*set_radar_background)(struct ieee80211_hw *hw,
  				    struct cfg80211_chan_def *chandef);
++<<<<<<< HEAD
++=======
+ 	int (*net_fill_forward_path)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_vif *vif,
+ 				     struct ieee80211_sta *sta,
+ 				     struct net_device_path_ctx *ctx,
+ 				     struct net_device_path *path);
+ 	int (*change_vif_links)(struct ieee80211_hw *hw,
+ 				struct ieee80211_vif *vif,
+ 				u16 old_links, u16 new_links,
+ 				struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
  };
  
  /**
diff --cc net/mac80211/driver-ops.h
index 173a201d5e6d,c8133c84d7d5..000000000000
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@@ -1486,4 -1511,47 +1486,50 @@@ static inline void drv_twt_teardown_req
  	trace_drv_return_void(local);
  }
  
++<<<<<<< HEAD
++=======
+ static inline int drv_net_fill_forward_path(struct ieee80211_local *local,
+ 					    struct ieee80211_sub_if_data *sdata,
+ 					    struct ieee80211_sta *sta,
+ 					    struct net_device_path_ctx *ctx,
+ 					    struct net_device_path *path)
+ {
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	sdata = get_bss_sdata(sdata);
+ 	if (!check_sdata_in_driver(sdata))
+ 		return -EIO;
+ 
+ 	trace_drv_net_fill_forward_path(local, sdata, sta);
+ 	if (local->ops->net_fill_forward_path)
+ 		ret = local->ops->net_fill_forward_path(&local->hw,
+ 							&sdata->vif, sta,
+ 							ctx, path);
+ 	trace_drv_return_int(local, ret);
+ 
+ 	return ret;
+ }
+ 
+ static inline int drv_change_vif_links(struct ieee80211_local *local,
+ 				       struct ieee80211_sub_if_data *sdata,
+ 				       u16 old_links, u16 new_links,
+ 				       struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+ {
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	might_sleep();
+ 
+ 	if (!check_sdata_in_driver(sdata))
+ 		return -EIO;
+ 
+ 	trace_drv_change_vif_links(local, sdata, old_links, new_links);
+ 	if (local->ops->change_vif_links)
+ 		ret = local->ops->change_vif_links(&local->hw, &sdata->vif,
+ 						   old_links, new_links, old);
+ 	trace_drv_return_int(local, ret);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
  #endif /* __MAC80211_DRIVER_OPS */
diff --cc net/mac80211/iface.c
index 2581d6c14d3a,f118e7710fb1..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -954,6 -1019,65 +961,68 @@@ static void ieee80211_set_default_queue
  	sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
+ 				int link_id,
+ 				struct ieee80211_link_data *link,
+ 				struct ieee80211_bss_conf *link_conf)
+ {
+ 	bool deflink = link_id < 0;
+ 
+ 	if (link_id < 0)
+ 		link_id = 0;
+ 
+ 	sdata->vif.link_conf[link_id] = link_conf;
+ 	sdata->link[link_id] = link;
+ 
+ 	link->sdata = sdata;
+ 	link->link_id = link_id;
+ 
+ 	INIT_WORK(&link->csa_finalize_work,
+ 		  ieee80211_csa_finalize_work);
+ 	INIT_WORK(&link->color_change_finalize_work,
+ 		  ieee80211_color_change_finalize_work);
+ 	INIT_LIST_HEAD(&link->assigned_chanctx_list);
+ 	INIT_LIST_HEAD(&link->reserved_chanctx_list);
+ 	INIT_DELAYED_WORK(&link->dfs_cac_timer_work,
+ 			  ieee80211_dfs_cac_timer_work);
+ 
+ 	if (!deflink) {
+ 		switch (sdata->vif.type) {
+ 		case NL80211_IFTYPE_AP:
+ 			ether_addr_copy(link_conf->addr,
+ 					sdata->wdev.links[link_id].addr);
+ 			WARN_ON(!(sdata->wdev.valid_links & BIT(link_id)));
+ 			break;
+ 		case NL80211_IFTYPE_STATION:
+ 			eth_random_addr(link_conf->addr);
+ 			ether_addr_copy(sdata->wdev.links[link_id].addr,
+ 					link_conf->addr);
+ 			break;
+ 		default:
+ 			WARN_ON(1);
+ 		}
+ 	}
+ }
+ 
+ static void ieee80211_sdata_init(struct ieee80211_local *local,
+ 				 struct ieee80211_sub_if_data *sdata)
+ {
+ 	sdata->local = local;
+ 
+ 	/*
+ 	 * Initialize the default link, so we can use link_id 0 for non-MLD,
+ 	 * and that continues to work for non-MLD-aware drivers that use just
+ 	 * vif.bss_conf instead of vif.link_conf.
+ 	 *
+ 	 * Note that we never change this, so if link ID 0 isn't used in an
+ 	 * MLD connection, we get a separate allocation for it.
+ 	 */
+ 	ieee80211_link_init(sdata, -1, &sdata->deflink, &sdata->vif.bss_conf);
+ }
+ 
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
  int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
  {
  	struct ieee80211_sub_if_data *sdata;
diff --cc net/mac80211/trace.h
index 17e7760d8348,256ebab13cda..000000000000
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@@ -1972,6 -2018,470 +1972,473 @@@ DEFINE_EVENT(local_sdata_evt, drv_abort
  	TP_ARGS(local, sdata)
  );
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(drv_set_default_unicast_key,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 int key_idx),
+ 
+ 	TP_ARGS(local, sdata, key_idx),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(int, key_idx)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->key_idx = key_idx;
+ 	),
+ 
+ 	TP_printk(LOCAL_PR_FMT VIF_PR_FMT " key_idx:%d",
+ 		  LOCAL_PR_ARG, VIF_PR_ARG, __entry->key_idx)
+ );
+ 
+ TRACE_EVENT(drv_channel_switch_beacon,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct cfg80211_chan_def *chandef),
+ 
+ 	TP_ARGS(local, sdata, chandef),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		CHANDEF_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		CHANDEF_ASSIGN(chandef);
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " channel switch to " CHANDEF_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_pre_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_channel_switch *ch_switch),
+ 
+ 	TP_ARGS(local, sdata, ch_switch),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		CHANDEF_ENTRY
+ 		__field(u64, timestamp)
+ 		__field(u32, device_timestamp)
+ 		__field(bool, block_tx)
+ 		__field(u8, count)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		CHANDEF_ASSIGN(&ch_switch->chandef)
+ 		__entry->timestamp = ch_switch->timestamp;
+ 		__entry->device_timestamp = ch_switch->device_timestamp;
+ 		__entry->block_tx = ch_switch->block_tx;
+ 		__entry->count = ch_switch->count;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " prepare channel switch to "
+ 		CHANDEF_PR_FMT  " count:%d block_tx:%d timestamp:%llu",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->count,
+ 		__entry->block_tx, __entry->timestamp
+ 	)
+ );
+ 
+ DEFINE_EVENT(local_sdata_evt, drv_post_channel_switch,
+ 	     TP_PROTO(struct ieee80211_local *local,
+ 		      struct ieee80211_sub_if_data *sdata),
+ 	     TP_ARGS(local, sdata)
+ );
+ 
+ DEFINE_EVENT(local_sdata_evt, drv_abort_channel_switch,
+ 	     TP_PROTO(struct ieee80211_local *local,
+ 		      struct ieee80211_sub_if_data *sdata),
+ 	     TP_ARGS(local, sdata)
+ );
+ 
+ TRACE_EVENT(drv_channel_switch_rx_beacon,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_channel_switch *ch_switch),
+ 
+ 	TP_ARGS(local, sdata, ch_switch),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		CHANDEF_ENTRY
+ 		__field(u64, timestamp)
+ 		__field(u32, device_timestamp)
+ 		__field(bool, block_tx)
+ 		__field(u8, count)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		CHANDEF_ASSIGN(&ch_switch->chandef)
+ 		__entry->timestamp = ch_switch->timestamp;
+ 		__entry->device_timestamp = ch_switch->device_timestamp;
+ 		__entry->block_tx = ch_switch->block_tx;
+ 		__entry->count = ch_switch->count;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT
+ 		" received a channel switch beacon to "
+ 		CHANDEF_PR_FMT  " count:%d block_tx:%d timestamp:%llu",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->count,
+ 		__entry->block_tx, __entry->timestamp
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_get_txpower,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 int dbm, int ret),
+ 
+ 	TP_ARGS(local, sdata, dbm, ret),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(int, dbm)
+ 		__field(int, ret)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->dbm = dbm;
+ 		__entry->ret = ret;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " dbm:%d ret:%d",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->dbm, __entry->ret
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_tdls_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, u8 oper_class,
+ 		 struct cfg80211_chan_def *chandef),
+ 
+ 	TP_ARGS(local, sdata, sta, oper_class, chandef),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, oper_class)
+ 		CHANDEF_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->oper_class = oper_class;
+ 		CHANDEF_ASSIGN(chandef)
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " tdls channel switch to"
+ 		CHANDEF_PR_FMT  " oper_class:%d " STA_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, CHANDEF_PR_ARG, __entry->oper_class,
+ 		STA_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_tdls_cancel_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta),
+ 
+ 	TP_ARGS(local, sdata, sta),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT
+ 		" tdls cancel channel switch with " STA_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_tdls_recv_channel_switch,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_tdls_ch_sw_params *params),
+ 
+ 	TP_ARGS(local, sdata, params),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(u8, action_code)
+ 		STA_ENTRY
+ 		CHANDEF_ENTRY
+ 		__field(u32, status)
+ 		__field(bool, peer_initiator)
+ 		__field(u32, timestamp)
+ 		__field(u16, switch_time)
+ 		__field(u16, switch_timeout)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_NAMED_ASSIGN(params->sta);
+ 		CHANDEF_ASSIGN(params->chandef)
+ 		__entry->peer_initiator = params->sta->tdls_initiator;
+ 		__entry->action_code = params->action_code;
+ 		__entry->status = params->status;
+ 		__entry->timestamp = params->timestamp;
+ 		__entry->switch_time = params->switch_time;
+ 		__entry->switch_timeout = params->switch_timeout;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " received tdls channel switch packet"
+ 		" action:%d status:%d time:%d switch time:%d switch"
+ 		" timeout:%d initiator: %d chan:" CHANDEF_PR_FMT STA_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->action_code, __entry->status,
+ 		__entry->timestamp, __entry->switch_time,
+ 		__entry->switch_timeout, __entry->peer_initiator,
+ 		CHANDEF_PR_ARG, STA_PR_ARG
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_wake_tx_queue,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct txq_info *txq),
+ 
+ 	TP_ARGS(local, sdata, txq),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, ac)
+ 		__field(u8, tid)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		struct ieee80211_sta *sta = txq->txq.sta;
+ 
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->ac = txq->txq.ac;
+ 		__entry->tid = txq->txq.tid;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " ac:%d tid:%d",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->ac, __entry->tid
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_get_ftm_responder_stats,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct cfg80211_ftm_responder_stats *ftm_stats),
+ 
+ 	TP_ARGS(local, sdata, ftm_stats),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT,
+ 		LOCAL_PR_ARG, VIF_PR_ARG
+ 	)
+ );
+ 
+ DEFINE_EVENT(local_sdata_addr_evt, drv_update_vif_offload,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata),
+ 	TP_ARGS(local, sdata)
+ );
+ 
+ DECLARE_EVENT_CLASS(sta_flag_evt,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, bool enabled),
+ 
+ 	TP_ARGS(local, sdata, sta, enabled),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(bool, enabled)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->enabled = enabled;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " enabled:%d",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->enabled
+ 	)
+ );
+ 
+ DEFINE_EVENT(sta_flag_evt, drv_sta_set_4addr,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, bool enabled),
+ 
+ 	TP_ARGS(local, sdata, sta, enabled)
+ );
+ 
+ DEFINE_EVENT(sta_flag_evt, drv_sta_set_decap_offload,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta, bool enabled),
+ 
+ 	TP_ARGS(local, sdata, sta, enabled)
+ );
+ 
+ TRACE_EVENT(drv_add_twt_setup,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sta *sta,
+ 		 struct ieee80211_twt_setup *twt,
+ 		 struct ieee80211_twt_params *twt_agrt),
+ 
+ 	TP_ARGS(local, sta, twt, twt_agrt),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, dialog_token)
+ 		__field(u8, control)
+ 		__field(__le16, req_type)
+ 		__field(__le64, twt)
+ 		__field(u8, duration)
+ 		__field(__le16, mantissa)
+ 		__field(u8, channel)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->dialog_token = twt->dialog_token;
+ 		__entry->control = twt->control;
+ 		__entry->req_type = twt_agrt->req_type;
+ 		__entry->twt = twt_agrt->twt;
+ 		__entry->duration = twt_agrt->min_twt_dur;
+ 		__entry->mantissa = twt_agrt->mantissa;
+ 		__entry->channel = twt_agrt->channel;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT STA_PR_FMT
+ 		" token:%d control:0x%02x req_type:0x%04x"
+ 		" twt:%llu duration:%d mantissa:%d channel:%d",
+ 		LOCAL_PR_ARG, STA_PR_ARG, __entry->dialog_token,
+ 		__entry->control, le16_to_cpu(__entry->req_type),
+ 		le64_to_cpu(__entry->twt), __entry->duration,
+ 		le16_to_cpu(__entry->mantissa), __entry->channel
+ 	)
+ );
+ 
+ TRACE_EVENT(drv_twt_teardown_request,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sta *sta, u8 flowid),
+ 
+ 	TP_ARGS(local, sta, flowid),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		STA_ENTRY
+ 		__field(u8, flowid)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		STA_ASSIGN;
+ 		__entry->flowid = flowid;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT STA_PR_FMT " flowid:%d",
+ 		LOCAL_PR_ARG, STA_PR_ARG, __entry->flowid
+ 	)
+ );
+ 
+ DEFINE_EVENT(sta_event, drv_net_fill_forward_path,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 struct ieee80211_sta *sta),
+ 	TP_ARGS(local, sdata, sta)
+ );
+ 
+ TRACE_EVENT(drv_change_vif_links,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+ 		 u16 old_links, u16 new_links),
+ 
+ 	TP_ARGS(local, sdata, old_links, new_links),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		__field(u16, old_links)
+ 		__field(u16, new_links)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+ 		__entry->old_links = old_links;
+ 		__entry->new_links = new_links;
+ 	),
+ 
+ 	TP_printk(
+ 		LOCAL_PR_FMT VIF_PR_FMT " old_links:0x%04x, new_links:0x%04x\n",
+ 		LOCAL_PR_ARG, VIF_PR_ARG, __entry->old_links, __entry->new_links
+ 	)
+ );
+ 
++>>>>>>> d8787ec6b4ef (wifi: mac80211: add vif link addition/removal)
  /*
   * Tracing for API calls that drivers call.
   */
* Unmerged path include/net/mac80211.h
* Unmerged path net/mac80211/driver-ops.h
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 623c22b9af41..9ff6439b117a 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1979,6 +1979,9 @@ void ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata);
 int ieee80211_add_virtual_monitor(struct ieee80211_local *local);
 void ieee80211_del_virtual_monitor(struct ieee80211_local *local);
 
+int ieee80211_vif_set_links(struct ieee80211_sub_if_data *sdata,
+			    u16 new_links);
+
 bool __ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata);
 void ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata,
 			      bool update_bss);
* Unmerged path net/mac80211/iface.c
* Unmerged path net/mac80211/trace.h
