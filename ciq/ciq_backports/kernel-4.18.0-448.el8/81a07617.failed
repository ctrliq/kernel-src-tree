s390/pci: reset zdev->zbus on registration failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 81a076171e72dcb6545a8a508b800aec59d6e82b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/81a07617.failed

On failure to register a struct zpci_dev with a struct zpci_bus we left
a dangling pointer in zdev->zbus. As zpci_create_device() bails if
zpci_bus_device_register() fails this is of no consequence but still bad
practice.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 81a076171e72dcb6545a8a508b800aec59d6e82b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_bus.c
diff --cc arch/s390/pci/pci_bus.c
index be52bf47165d,3c9ad518712e..000000000000
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@@ -227,29 -318,58 +227,66 @@@ static int zpci_bus_add_device(struct z
  		return rc;
  	zdev->has_hp_slot = 1;
  
 -	if (zdev->devfn == 0 && zbus->multifunction) {
 -		/* Now that function 0 is there we can finally create the
 -		 * hotplug slots for those functions with devfn != 0 that have
 -		 * been parked in zbus->function[] waiting for us to be able to
 -		 * create the PCI bus.
 -		 */
 -		for  (devfn = 1; devfn < ZPCI_FUNCTIONS_PER_BUS; devfn++) {
 -			zdev = zbus->function[devfn];
 -			if (zdev && !zdev->has_hp_slot) {
 -				rc = zpci_init_slot(zdev);
 -				if (rc)
 -					return rc;
 -				zdev->has_hp_slot = 1;
 -			}
 -		}
 -
 +	resource_list_for_each_entry_safe(window, n, &zbus->resources) {
 +		res = window->res;
 +		pci_bus_add_resource(bus, res, 0);
  	}
  
++<<<<<<< HEAD
 +	pdev = pci_scan_single_device(bus, zdev->devfn);
 +	if (pdev)
 +		pci_bus_add_device(pdev);
++=======
+ 	return rc;
+ }
+ 
+ static int zpci_bus_add_device(struct zpci_bus *zbus, struct zpci_dev *zdev)
+ {
+ 	int rc = -EINVAL;
+ 
+ 	if (zbus->function[zdev->devfn]) {
+ 		pr_err("devfn %04x is already assigned\n", zdev->devfn);
+ 		return rc;
+ 	}
+ 	zdev->zbus = zbus;
+ 	zbus->function[zdev->devfn] = zdev;
+ 	zpci_nb_devices++;
+ 
+ 	if (zbus->bus) {
+ 		if (zbus->multifunction && !zdev->rid_available) {
+ 			WARN_ONCE(1, "rid_available not set for multifunction\n");
+ 			goto error;
+ 		}
+ 
+ 		zpci_bus_create_hotplug_slots(zdev);
+ 	} else {
+ 		/* Hotplug slot will be created once function 0 appears */
+ 		zbus->multifunction = 1;
+ 	}
++>>>>>>> 81a076171e72 (s390/pci: reset zdev->zbus on registration failure)
  
  	return 0;
 +}
 +
++<<<<<<< HEAD
 +static void zpci_bus_add_devices(struct zpci_bus *zbus)
 +{
 +	int i;
  
 +	for (i = 1; i < ZPCI_FUNCTIONS_PER_BUS; i++)
 +		if (zbus->function[i])
 +			zpci_bus_add_device(zbus, zbus->function[i]);
 +
 +	pci_lock_rescan_remove();
 +	pci_bus_add_devices(zbus->bus);
 +	pci_unlock_rescan_remove();
++=======
+ error:
+ 	zbus->function[zdev->devfn] = NULL;
+ 	zdev->zbus = NULL;
+ 	zpci_nb_devices--;
+ 	return rc;
++>>>>>>> 81a076171e72 (s390/pci: reset zdev->zbus on registration failure)
  }
  
  int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops)
* Unmerged path arch/s390/pci/pci_bus.c
