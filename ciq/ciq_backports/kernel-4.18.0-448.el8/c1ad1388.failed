ASoC: cs35l41: Read System Name from ACPI _SUB to identify firmware

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit c1ad138822a1be95a7a7b122521c2415583a0c26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/c1ad1388.failed

When loading firmware, wm_adsp uses a number of parameters to
determine the path of the firmware and tuning files to load.
One of these parameters is system_name.
Add support in cs35l41 to read this system name from the ACPI
_SUB ID in order to uniquely identify the firmware and tuning
mapped to a particular system.

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20220707151037.3901050-3-sbinding@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit c1ad138822a1be95a7a7b122521c2415583a0c26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/cs35l41.c
diff --cc sound/soc/codecs/cs35l41.c
index 25c67931882a,c223d83e02cf..000000000000
--- a/sound/soc/codecs/cs35l41.c
+++ b/sound/soc/codecs/cs35l41.c
@@@ -1185,59 -1088,86 +1186,130 @@@ static int cs35l41_handle_pdata(struct 
  	return 0;
  }
  
 -static int cs35l41_dsp_init(struct cs35l41_private *cs35l41)
 -{
 -	struct wm_adsp *dsp;
 -	int ret;
 +static const struct reg_sequence cs35l41_reva0_errata_patch[] = {
 +	{ 0x00000040,			 0x00005555 },
 +	{ 0x00000040,			 0x0000AAAA },
 +	{ 0x00003854,			 0x05180240 },
 +	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
 +	{ 0x00004310,			 0x00000000 },
 +	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
 +	{ CS35L41_OTP_TRIM_30,		 0x9091A1C8 },
 +	{ 0x00003014,			 0x0200EE0E },
 +	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
 +	{ 0x00000054,			 0x00000004 },
 +	{ CS35L41_IRQ1_DB3,		 0x00000000 },
 +	{ CS35L41_IRQ2_DB3,		 0x00000000 },
 +	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ 0x00000040,			 0x0000CCCC },
 +	{ 0x00000040,			 0x00003333 },
 +	{ CS35L41_PWR_CTRL2,		 0x00000000 },
 +	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
 +};
  
 -	dsp = &cs35l41->dsp;
 -	dsp->part = "cs35l41";
 -	dsp->fw = 9; /* 9 is WM_ADSP_FW_SPK_PROT in wm_adsp.c */
 -	dsp->toggle_preload = true;
 +static const struct reg_sequence cs35l41_revb0_errata_patch[] = {
 +	{ 0x00000040,			 0x00005555 },
 +	{ 0x00000040,			 0x0000AAAA },
 +	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
 +	{ 0x00004310,			 0x00000000 },
 +	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
 +	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
 +	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ 0x00000040,			 0x0000CCCC },
 +	{ 0x00000040,			 0x00003333 },
 +	{ CS35L41_PWR_CTRL2,		 0x00000000 },
 +	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
 +};
  
 -	cs35l41_configure_cs_dsp(cs35l41->dev, cs35l41->regmap, &dsp->cs_dsp);
 +static const struct reg_sequence cs35l41_revb2_errata_patch[] = {
 +	{ 0x00000040,			 0x00005555 },
 +	{ 0x00000040,			 0x0000AAAA },
 +	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
 +	{ 0x00004310,			 0x00000000 },
 +	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
 +	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
 +	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
 +	{ 0x00000040,			 0x0000CCCC },
 +	{ 0x00000040,			 0x00003333 },
 +	{ CS35L41_PWR_CTRL2,		 0x00000000 },
 +	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
 +};
  
++<<<<<<< HEAD
 +int cs35l41_probe(struct cs35l41_private *cs35l41,
 +		  struct cs35l41_platform_data *pdata)
++=======
+ 	ret = cs35l41_write_fs_errata(cs35l41->dev, cs35l41->regmap);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = wm_halo_init(dsp);
+ 	if (ret) {
+ 		dev_err(cs35l41->dev, "wm_halo_init failed: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX5_SRC,
+ 			   CS35L41_INPUT_SRC_VPMON);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_VPMON failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX6_SRC,
+ 			   CS35L41_INPUT_SRC_CLASSH);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_CLASSH failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX7_SRC,
+ 			   CS35L41_INPUT_SRC_TEMPMON);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_TEMPMON failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX8_SRC,
+ 			   CS35L41_INPUT_SRC_RSVD);
+ 	if (ret < 0) {
+ 		dev_err(cs35l41->dev, "Write INPUT_SRC_RSVD failed: %d\n", ret);
+ 		goto err_dsp;
+ 	}
+ 
+ 	return 0;
+ 
+ err_dsp:
+ 	wm_adsp2_remove(dsp);
+ 
+ 	return ret;
+ }
+ 
+ static int cs35l41_acpi_get_name(struct cs35l41_private *cs35l41)
+ {
+ 	acpi_handle handle = ACPI_HANDLE(cs35l41->dev);
+ 	const char *sub;
+ 
+ 	/* If there is no ACPI_HANDLE, there is no ACPI for this system, return 0 */
+ 	if (!handle)
+ 		return 0;
+ 
+ 	sub = acpi_get_subsystem_id(handle);
+ 	if (IS_ERR(sub)) {
+ 		/* If bad ACPI, return 0 and fallback to legacy firmware path, otherwise fail */
+ 		if (PTR_ERR(sub) == -ENODATA)
+ 			return 0;
+ 		else
+ 			return PTR_ERR(sub);
+ 	}
+ 
+ 	cs35l41->dsp.system_name = sub;
+ 	dev_dbg(cs35l41->dev, "Subsystem ID: %s\n", cs35l41->dsp.system_name);
+ 
+ 	return 0;
+ }
+ 
+ int cs35l41_probe(struct cs35l41_private *cs35l41, const struct cs35l41_hw_cfg *hw_cfg)
++>>>>>>> c1ad138822a1 (ASoC: cs35l41: Read System Name from ACPI _SUB to identify firmware)
  {
  	u32 regid, reg_revid, i, mtl_revid, int_status, chipid_match;
  	int irq_pol = 0;
@@@ -1396,6 -1295,21 +1468,24 @@@
  		goto err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	ret = cs35l41_acpi_get_name(cs35l41);
+ 	if (ret < 0)
+ 		goto err;
+ 
+ 	ret = cs35l41_dsp_init(cs35l41);
+ 	if (ret < 0)
+ 		goto err;
+ 
+ 	pm_runtime_set_autosuspend_delay(cs35l41->dev, 3000);
+ 	pm_runtime_use_autosuspend(cs35l41->dev);
+ 	pm_runtime_mark_last_busy(cs35l41->dev);
+ 	pm_runtime_set_active(cs35l41->dev);
+ 	pm_runtime_get_noresume(cs35l41->dev);
+ 	pm_runtime_enable(cs35l41->dev);
+ 
++>>>>>>> c1ad138822a1 (ASoC: cs35l41: Read System Name from ACPI _SUB to identify firmware)
  	ret = devm_snd_soc_register_component(cs35l41->dev,
  					      &soc_component_dev_cs35l41,
  					      cs35l41_dai, ARRAY_SIZE(cs35l41_dai));
@@@ -1419,7 -1341,16 +1509,16 @@@ EXPORT_SYMBOL_GPL(cs35l41_probe)
  
  void cs35l41_remove(struct cs35l41_private *cs35l41)
  {
 -	pm_runtime_get_sync(cs35l41->dev);
 -	pm_runtime_disable(cs35l41->dev);
 -
  	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1, 0xFFFFFFFF);
++<<<<<<< HEAD
++=======
+ 	kfree(cs35l41->dsp.system_name);
+ 	wm_adsp2_remove(&cs35l41->dsp);
+ 	cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
+ 
+ 	pm_runtime_put_noidle(cs35l41->dev);
+ 
++>>>>>>> c1ad138822a1 (ASoC: cs35l41: Read System Name from ACPI _SUB to identify firmware)
  	regulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
  	gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
  }
* Unmerged path sound/soc/codecs/cs35l41.c
