wifi: mac80211: mlme: first adjustments for MLO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 5bd5666d8ad88366789b344647529841f6dadd7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/5bd5666d.failed

Do the first adjustments in the client-side code to pass
the link pointer (instead of sdata) to most places etc.

This is just preparation, so the real MLO patches become
smaller.

Note that this isn't complete, notably there are still
quite a few references to sta->deflink and sta->sta.deflink.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 5bd5666d8ad88366789b344647529841f6dadd7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ieee80211_i.h
#	net/mac80211/mlme.c
diff --cc net/mac80211/ieee80211_i.h
index 9f2fe5f6d317,20b9979d1506..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -903,6 -870,110 +901,113 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	ieee80211_conn_flags_t conn_flags;
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool have_beacon;
+ 	bool tracking_signal_avg;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 	struct timer_list chswitch_timer;
+ 	struct work_struct chswitch_work;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ 
+ 	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
+ 
+ 	struct ieee80211_bss_conf *conf;
+ };
+ 
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
diff --cc net/mac80211/mlme.c
index 6cd411ed25d6,35c62e940946..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -142,8 -142,8 +142,13 @@@ static int ecw2cw(int ecw
  	return (1 << ecw) - 1;
  }
  
++<<<<<<< HEAD
 +static u32
 +ieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,
++=======
+ static ieee80211_conn_flags_t
+ ieee80211_determine_chantype(struct ieee80211_link_data *link,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			     struct ieee80211_supported_band *sband,
  			     struct ieee80211_channel *channel,
  			     u32 vht_cap_info,
@@@ -154,10 -154,11 +159,14 @@@
  			     const struct ieee80211_s1g_oper_ie *s1g_oper,
  			     struct cfg80211_chan_def *chandef, bool tracking)
  {
++<<<<<<< HEAD
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	struct cfg80211_chan_def vht_chandef;
  	struct ieee80211_sta_ht_cap sta_ht_cap;
 -	ieee80211_conn_flags_t ret;
 -	u32 ht_cfreq;
 +	u32 ht_cfreq, ret;
  
  	memset(chandef, 0, sizeof(struct cfg80211_chan_def));
  	chandef->chan = channel;
@@@ -248,7 -249,8 +257,12 @@@
  	}
  
  	vht_chandef = *chandef;
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE) && he_oper &&
++=======
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
+ 	    he_oper &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    (le32_to_cpu(he_oper->he_oper_params) &
  	     IEEE80211_HE_OPERATION_VHT_OPER_INFO)) {
  		struct ieee80211_vht_operation he_oper_vht_cap;
@@@ -263,28 -265,28 +277,40 @@@
  		if (!ieee80211_chandef_vht_oper(&sdata->local->hw, vht_cap_info,
  						&he_oper_vht_cap, ht_oper,
  						&vht_chandef)) {
++<<<<<<< HEAD
 +			if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE))
++=======
+ 			if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  				sdata_info(sdata,
  					   "HE AP VHT information is invalid, disabling HE\n");
 -			ret = IEEE80211_CONN_DISABLE_HE | IEEE80211_CONN_DISABLE_EHT;
 +			ret = IEEE80211_STA_DISABLE_HE | IEEE80211_STA_DISABLE_EHT;
  			goto out;
  		}
  	} else if (!ieee80211_chandef_vht_oper(&sdata->local->hw,
  					       vht_cap_info,
  					       vht_oper, ht_oper,
  					       &vht_chandef)) {
++<<<<<<< HEAD
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
++=======
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			sdata_info(sdata,
  				   "AP VHT information is invalid, disabling VHT\n");
 -		ret = IEEE80211_CONN_DISABLE_VHT;
 +		ret = IEEE80211_STA_DISABLE_VHT;
  		goto out;
  	}
  
  	if (!cfg80211_chandef_valid(&vht_chandef)) {
++<<<<<<< HEAD
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
++=======
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			sdata_info(sdata,
  				   "AP VHT information is invalid, disabling VHT\n");
 -		ret = IEEE80211_CONN_DISABLE_VHT;
 +		ret = IEEE80211_STA_DISABLE_VHT;
  		goto out;
  	}
  
@@@ -294,10 -296,10 +320,14 @@@
  	}
  
  	if (!cfg80211_chandef_compatible(chandef, &vht_chandef)) {
++<<<<<<< HEAD
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
++=======
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			sdata_info(sdata,
  				   "AP VHT information doesn't match HT, disabling VHT\n");
 -		ret = IEEE80211_CONN_DISABLE_VHT;
 +		ret = IEEE80211_STA_DISABLE_VHT;
  		goto out;
  	}
  
@@@ -317,18 -319,18 +347,26 @@@
  					   false, &eht_chandef);
  
  		if (!cfg80211_chandef_valid(&eht_chandef)) {
++<<<<<<< HEAD
 +			if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
++=======
+ 			if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  				sdata_info(sdata,
  					   "AP EHT information is invalid, disabling EHT\n");
 -			ret = IEEE80211_CONN_DISABLE_EHT;
 +			ret = IEEE80211_STA_DISABLE_EHT;
  			goto out;
  		}
  
  		if (!cfg80211_chandef_compatible(chandef, &eht_chandef)) {
++<<<<<<< HEAD
 +			if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
++=======
+ 			if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  				sdata_info(sdata,
  					   "AP EHT information is incompatible, disabling EHT\n");
 -			ret = IEEE80211_CONN_DISABLE_EHT;
 +			ret = IEEE80211_STA_DISABLE_EHT;
  			goto out;
  		}
  
@@@ -425,15 -428,15 +464,27 @@@ static int ieee80211_config_bw(struct i
  	int ret;
  
  	/* if HT was/is disabled, don't track any bandwidth changes */
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT || !ht_oper)
 +		return 0;
 +
 +	/* don't check VHT if we associated as non-VHT station */
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_VHT)
 +		vht_oper = NULL;
 +
 +	/* don't check HE if we associated as non-HE station */
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HE ||
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT || !ht_oper)
+ 		return 0;
+ 
+ 	/* don't check VHT if we associated as non-VHT station */
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
+ 		vht_oper = NULL;
+ 
+ 	/* don't check HE if we associated as non-HE station */
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE ||
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    !ieee80211_get_he_iftype_cap(sband,
  					 ieee80211_vif_type_p2p(&sdata->vif))) {
  		he_oper = NULL;
@@@ -441,7 -444,7 +492,11 @@@
  	}
  
  	/* don't check EHT if we associated as non-EHT station */
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_EHT ||
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT ||
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    !ieee80211_get_eht_iftype_cap(sband,
  					 ieee80211_vif_type_p2p(&sdata->vif)))
  		eht_oper = NULL;
@@@ -475,48 -478,48 +530,89 @@@
  	 * reasons) then switching to a 40 MHz channel now won't do us
  	 * any good -- we couldn't use it with the AP.
  	 */
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_80P80MHZ &&
 +	    chandef.width == NL80211_CHAN_WIDTH_80P80)
 +		flags |= ieee80211_chandef_downgrade(&chandef);
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_160MHZ &&
 +	    chandef.width == NL80211_CHAN_WIDTH_160)
 +		flags |= ieee80211_chandef_downgrade(&chandef);
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_40MHZ &&
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ &&
+ 	    chandef.width == NL80211_CHAN_WIDTH_80P80)
+ 		flags |= ieee80211_chandef_downgrade(&chandef);
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_160MHZ &&
+ 	    chandef.width == NL80211_CHAN_WIDTH_160)
+ 		flags |= ieee80211_chandef_downgrade(&chandef);
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_40MHZ &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    chandef.width > NL80211_CHAN_WIDTH_20)
  		flags |= ieee80211_chandef_downgrade(&chandef);
  
- 	if (cfg80211_chandef_identical(&chandef, &sdata->vif.bss_conf.chandef))
+ 	if (cfg80211_chandef_identical(&chandef, &link->conf->chandef))
  		return 0;
  
++<<<<<<< HEAD
 +	sdata_info(sdata,
 +		   "AP %pM changed bandwidth, new config is %d.%03d MHz, "
 +		   "width %d (%d.%03d/%d MHz)\n",
 +		   ifmgd->bssid, chandef.chan->center_freq,
 +		   chandef.chan->freq_offset, chandef.width,
 +		   chandef.center_freq1, chandef.freq1_offset,
 +		   chandef.center_freq2);
 +
 +	if (flags != (ifmgd->flags & (IEEE80211_STA_DISABLE_HT |
 +				      IEEE80211_STA_DISABLE_VHT |
 +				      IEEE80211_STA_DISABLE_HE |
 +				      IEEE80211_STA_DISABLE_EHT |
 +				      IEEE80211_STA_DISABLE_40MHZ |
 +				      IEEE80211_STA_DISABLE_80P80MHZ |
 +				      IEEE80211_STA_DISABLE_160MHZ |
 +				      IEEE80211_STA_DISABLE_320MHZ)) ||
 +	    !cfg80211_chandef_valid(&chandef)) {
 +		sdata_info(sdata,
 +			   "AP %pM changed caps/bw in a way we can't support (0x%x/0x%x) - disconnect\n",
 +			   ifmgd->bssid, flags, ifmgd->flags);
 +		return -EINVAL;
 +	}
 +
 +	ret = ieee80211_vif_change_bandwidth(sdata, &chandef, changed);
++=======
+ 	link_info(link,
+ 		  "AP %pM changed bandwidth, new config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\n",
+ 		  link->u.mgd.bssid, chandef.chan->center_freq,
+ 		  chandef.chan->freq_offset, chandef.width,
+ 		  chandef.center_freq1, chandef.freq1_offset,
+ 		  chandef.center_freq2);
+ 
+ 	if (flags != (link->u.mgd.conn_flags &
+ 				(IEEE80211_CONN_DISABLE_HT |
+ 				 IEEE80211_CONN_DISABLE_VHT |
+ 				 IEEE80211_CONN_DISABLE_HE |
+ 				 IEEE80211_CONN_DISABLE_EHT |
+ 				 IEEE80211_CONN_DISABLE_40MHZ |
+ 				 IEEE80211_CONN_DISABLE_80P80MHZ |
+ 				 IEEE80211_CONN_DISABLE_160MHZ |
+ 				 IEEE80211_CONN_DISABLE_320MHZ)) ||
+ 	    !cfg80211_chandef_valid(&chandef)) {
+ 		sdata_info(sdata,
+ 			   "AP %pM changed caps/bw in a way we can't support (0x%x/0x%x) - disconnect\n",
+ 			   link->u.mgd.bssid, flags, ifmgd->flags);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = ieee80211_link_change_bandwidth(link, &chandef, changed);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	if (ret) {
  		sdata_info(sdata,
  			   "AP %pM changed bandwidth to incompatible one - disconnect\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid);
++=======
+ 			   link->u.mgd.bssid);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return ret;
  	}
  
@@@ -564,7 -568,7 +661,11 @@@ static void ieee80211_add_ht_ie(struct 
  	 * capable of 40 MHz -- some broken APs will never fall
  	 * back to trying to transmit in 20 MHz.
  	 */
++<<<<<<< HEAD
 +	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_40MHZ) {
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_40MHZ) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
  		cap &= ~IEEE80211_HT_CAP_SGI_40;
  	}
@@@ -618,7 -623,7 +720,11 @@@ static void ieee80211_add_vht_ie(struc
  	/* determine capability flags */
  	cap = vht_cap.cap;
  
++<<<<<<< HEAD
 +	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_80P80MHZ) {
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		u32 bw = cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
  
  		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
@@@ -627,7 -632,7 +733,11 @@@
  			cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
  	}
  
++<<<<<<< HEAD
 +	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_160MHZ) {
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_160MHZ) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		cap &= ~IEEE80211_VHT_CAP_SHORT_GI_160;
  		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
  	}
@@@ -717,7 -723,7 +828,11 @@@ static void ieee80211_add_he_ie(struct 
  				      he_cap->he_cap_elem.phy_cap_info);
  	pos = skb_put(skb, he_cap_size);
  	pre_he_pos = pos;
++<<<<<<< HEAD
 +	pos = ieee80211_ie_build_he_cap(sdata->u.mgd.flags,
++=======
+ 	pos = ieee80211_ie_build_he_cap(link->u.mgd.conn_flags,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  					pos, he_cap, pos + he_cap_size);
  	/* trim excess if any */
  	skb_trim(skb, skb->len - (pre_he_pos + he_cap_size - pos));
@@@ -980,7 -985,7 +1097,11 @@@ skip_rates
  
  	/* Set MBSSID support for HE AP if needed */
  	if (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&
++<<<<<<< HEAD
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) && assoc_data->ie_len &&
++=======
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) && assoc_data->ie_len &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    ext_capa && ext_capa->datalen >= 3)
  		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
  
@@@ -1025,14 -1030,14 +1146,25 @@@
  		offset = noffset;
  	}
  
++<<<<<<< HEAD
 +	if (WARN_ON_ONCE((ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +			 !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +
 +	if (sband->band != NL80211_BAND_6GHZ &&
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
 +		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
 +				    sband, chan, sdata->smps_mode);
++=======
+ 	if (WARN_ON_ONCE((link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
+ 			 !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)))
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 
+ 	if (sband->band != NL80211_BAND_6GHZ &&
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
+ 		ieee80211_add_ht_ie(link, skb, assoc_data->ap_ht_param,
+ 				    sband, chan, link->smps_mode);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	/* if present, add any custom IEs that go before VHT */
  	if (assoc_data->ie_len) {
@@@ -1085,25 -1090,25 +1217,44 @@@
  	}
  
  	if (sband->band != NL80211_BAND_6GHZ &&
++<<<<<<< HEAD
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_add_vht_ie(sdata, skb, sband,
++=======
+ 	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		ieee80211_add_vht_ie(link, skb, sband,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  				     &assoc_data->ap_vht_cap);
  
  	/*
  	 * If AP doesn't support HT, mark HE and EHT as disabled.
  	 * If on the 5GHz band, make sure it supports VHT.
  	 */
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT ||
 +	    (sband->band == NL80211_BAND_5GHZ &&
 +	     ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +			        IEEE80211_STA_DISABLE_EHT;
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		ieee80211_add_he_ie(sdata, skb, sband);
 +
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
 +			ieee80211_add_eht_ie(sdata, skb, sband);
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT ||
+ 	    (sband->band == NL80211_BAND_5GHZ &&
+ 	     link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE |
+ 						   IEEE80211_CONN_DISABLE_EHT;
+ 
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)) {
+ 		ieee80211_add_he_ie(link, skb, sband);
+ 
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT))
+ 			ieee80211_add_eht_ie(link, skb, sband);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	/* if present, add any custom non-vendor IEs that go after HE */
@@@ -1275,16 -1281,16 +1427,27 @@@ static void ieee80211_chswitch_work(str
  	 * completed successfully
  	 */
  
++<<<<<<< HEAD
 +	if (sdata->reserved_chanctx) {
++=======
+ 	if (link->reserved_chanctx) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		/*
  		 * with multi-vif csa driver may call ieee80211_csa_finish()
  		 * many times while waiting for other interfaces to use their
  		 * reservations
  		 */
++<<<<<<< HEAD
 +		if (sdata->reserved_ready)
 +			goto out;
 +
 +		ret = ieee80211_vif_use_reserved_context(sdata);
++=======
+ 		if (link->reserved_ready)
+ 			goto out;
+ 
+ 		ret = ieee80211_link_use_reserved_context(link);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		if (ret) {
  			sdata_info(sdata,
  				   "failed to use reserved channel context, disconnecting (err=%d)\n",
@@@ -1297,8 -1303,8 +1460,13 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (!cfg80211_chandef_identical(&sdata->vif.bss_conf.chandef,
 +					&sdata->csa_chandef)) {
++=======
+ 	if (!cfg80211_chandef_identical(&link->conf->chandef,
+ 					&link->csa_chandef)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		sdata_info(sdata,
  			   "failed to finalize channel switch, disconnecting\n");
  		ieee80211_queue_work(&sdata->local->hw,
@@@ -1306,7 -1312,7 +1474,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ifmgd->csa_waiting_bcn = true;
++=======
+ 	link->u.mgd.csa_waiting_bcn = true;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	ieee80211_sta_reset_beacon_monitor(sdata);
  	ieee80211_sta_reset_conn_monitor(sdata);
@@@ -1325,21 -1332,21 +1498,36 @@@ static void ieee80211_chswitch_post_bea
  
  	sdata_assert_lock(sdata);
  
- 	WARN_ON(!sdata->vif.bss_conf.csa_active);
+ 	WARN_ON(!link->conf->csa_active);
  
++<<<<<<< HEAD
 +	if (sdata->csa_block_tx) {
 +		ieee80211_wake_vif_queues(local, sdata,
 +					  IEEE80211_QUEUE_STOP_REASON_CSA);
 +		sdata->csa_block_tx = false;
 +	}
 +
 +	sdata->vif.bss_conf.csa_active = false;
 +	ifmgd->csa_waiting_bcn = false;
++=======
+ 	if (link->csa_block_tx) {
+ 		ieee80211_wake_vif_queues(local, sdata,
+ 					  IEEE80211_QUEUE_STOP_REASON_CSA);
+ 		link->csa_block_tx = false;
+ 	}
+ 
+ 	link->conf->csa_active = false;
+ 	link->u.mgd.csa_waiting_bcn = false;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	/*
  	 * If the CSA IE is still present on the beacon after the switch,
  	 * we need to consider it as a new CSA (possibly to self).
  	 */
++<<<<<<< HEAD
 +	ifmgd->beacon_crc_valid = false;
++=======
+ 	link->u.mgd.beacon_crc_valid = false;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	ret = drv_post_channel_switch(sdata);
  	if (ret) {
@@@ -1350,7 -1357,7 +1538,11 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	cfg80211_ch_switch_notify(sdata->dev, &sdata->reserved_chandef);
++=======
+ 	cfg80211_ch_switch_notify(sdata->dev, &link->reserved_chandef, 0);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  }
  
  void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)
@@@ -1389,15 -1402,15 +1587,27 @@@ ieee80211_sta_abort_chanswitch(struct i
  	mutex_lock(&local->mtx);
  
  	mutex_lock(&local->chanctx_mtx);
++<<<<<<< HEAD
 +	ieee80211_vif_unreserve_chanctx(sdata);
 +	mutex_unlock(&local->chanctx_mtx);
 +
 +	if (sdata->csa_block_tx)
 +		ieee80211_wake_vif_queues(local, sdata,
 +					  IEEE80211_QUEUE_STOP_REASON_CSA);
 +
 +	sdata->csa_block_tx = false;
 +	sdata->vif.bss_conf.csa_active = false;
++=======
+ 	ieee80211_link_unreserve_chanctx(link);
+ 	mutex_unlock(&local->chanctx_mtx);
+ 
+ 	if (link->csa_block_tx)
+ 		ieee80211_wake_vif_queues(local, sdata,
+ 					  IEEE80211_QUEUE_STOP_REASON_CSA);
+ 
+ 	link->csa_block_tx = false;
+ 	link->conf->csa_active = false;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	mutex_unlock(&local->mtx);
  
@@@ -1410,9 -1423,10 +1620,14 @@@ ieee80211_sta_process_chanswitch(struc
  				 struct ieee802_11_elems *elems,
  				 bool beacon)
  {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
++<<<<<<< HEAD
 +	struct cfg80211_bss *cbss = ifmgd->assoc_bss;
++=======
+ 	struct cfg80211_bss *cbss = link->u.mgd.bss;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	struct ieee80211_chanctx_conf *conf;
  	struct ieee80211_chanctx *chanctx;
  	enum nl80211_band current_band;
@@@ -1433,8 -1447,8 +1648,13 @@@
  	bss = (void *)cbss->priv;
  	res = ieee80211_parse_ch_switch_ie(sdata, elems, current_band,
  					   bss->vht_cap_info,
++<<<<<<< HEAD
 +					   ifmgd->flags,
 +					   ifmgd->bssid, &csa_ie);
++=======
+ 					   link->u.mgd.conn_flags,
+ 					   link->u.mgd.bssid, &csa_ie);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	if (!res) {
  		ch_switch.timestamp = timestamp;
@@@ -1448,9 -1462,10 +1668,14 @@@
  	if (res < 0)
  		goto lock_and_drop_connection;
  
++<<<<<<< HEAD
 +	if (beacon && sdata->vif.bss_conf.csa_active && !ifmgd->csa_waiting_bcn) {
++=======
+ 	if (beacon && link->conf->csa_active &&
+ 	    !link->u.mgd.csa_waiting_bcn) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		if (res)
- 			ieee80211_sta_abort_chanswitch(sdata);
+ 			ieee80211_sta_abort_chanswitch(link);
  		else
  			drv_channel_switch_rx_beacon(sdata, &ch_switch);
  		return;
@@@ -1463,7 -1478,7 +1688,11 @@@
  	    csa_ie.chandef.chan->band) {
  		sdata_info(sdata,
  			   "AP %pM switches to different band (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid,
++=======
+ 			   link->u.mgd.bssid,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			   csa_ie.chandef.chan->center_freq,
  			   csa_ie.chandef.width, csa_ie.chandef.center_freq1,
  			   csa_ie.chandef.center_freq2);
@@@ -1476,7 -1491,7 +1705,11 @@@
  			   "AP %pM switches to unsupported channel "
  			   "(%d.%03d MHz, width:%d, CF1/2: %d.%03d/%d MHz), "
  			   "disconnecting\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid,
++=======
+ 			   link->u.mgd.bssid,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			   csa_ie.chandef.chan->center_freq,
  			   csa_ie.chandef.chan->freq_offset,
  			   csa_ie.chandef.width, csa_ie.chandef.center_freq1,
@@@ -1486,14 -1501,14 +1719,23 @@@
  	}
  
  	if (cfg80211_chandef_identical(&csa_ie.chandef,
- 				       &sdata->vif.bss_conf.chandef) &&
+ 				       &link->conf->chandef) &&
  	    (!csa_ie.mode || !beacon)) {
++<<<<<<< HEAD
 +		if (ifmgd->csa_ignored_same_chan)
 +			return;
 +		sdata_info(sdata,
 +			   "AP %pM tries to chanswitch to same channel, ignore\n",
 +			   ifmgd->bssid);
 +		ifmgd->csa_ignored_same_chan = true;
++=======
+ 		if (link->u.mgd.csa_ignored_same_chan)
+ 			return;
+ 		sdata_info(sdata,
+ 			   "AP %pM tries to chanswitch to same channel, ignore\n",
+ 			   link->u.mgd.bssid);
+ 		link->u.mgd.csa_ignored_same_chan = true;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return;
  	}
  
@@@ -1530,8 -1545,8 +1772,13 @@@
  		goto drop_connection;
  	}
  
++<<<<<<< HEAD
 +	res = ieee80211_vif_reserve_chanctx(sdata, &csa_ie.chandef,
 +					    chanctx->mode, false);
++=======
+ 	res = ieee80211_link_reserve_chanctx(link, &csa_ie.chandef,
+ 					     chanctx->mode, false);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	if (res) {
  		sdata_info(sdata,
  			   "failed to reserve channel context for channel switch, disconnecting (err=%d)\n",
@@@ -1540,13 -1555,13 +1787,23 @@@
  	}
  	mutex_unlock(&local->chanctx_mtx);
  
++<<<<<<< HEAD
 +	sdata->vif.bss_conf.csa_active = true;
 +	sdata->csa_chandef = csa_ie.chandef;
 +	sdata->csa_block_tx = csa_ie.mode;
 +	ifmgd->csa_ignored_same_chan = false;
 +	ifmgd->beacon_crc_valid = false;
 +
 +	if (sdata->csa_block_tx)
++=======
+ 	link->conf->csa_active = true;
+ 	link->csa_chandef = csa_ie.chandef;
+ 	link->csa_block_tx = csa_ie.mode;
+ 	link->u.mgd.csa_ignored_same_chan = false;
+ 	link->u.mgd.beacon_crc_valid = false;
+ 
+ 	if (link->csa_block_tx)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		ieee80211_stop_vif_queues(local, sdata,
  					  IEEE80211_QUEUE_STOP_REASON_CSA);
  	mutex_unlock(&local->mtx);
@@@ -1579,8 -1594,8 +1836,13 @@@
  	 * send a deauthentication frame. Those two fields will be
  	 * reset when the disconnection worker runs.
  	 */
++<<<<<<< HEAD
 +	sdata->vif.bss_conf.csa_active = true;
 +	sdata->csa_block_tx = csa_ie.mode;
++=======
+ 	link->conf->csa_active = true;
+ 	link->csa_block_tx = csa_ie.mode;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	ieee80211_queue_work(&local->hw, &ifmgd->csa_connection_drop_work);
  	mutex_unlock(&local->chanctx_mtx);
@@@ -1715,25 -1731,25 +1978,44 @@@ static u32 ieee80211_handle_pwr_constr(
  	    (!has_cisco_pwr || pwr_level_80211h <= pwr_level_cisco)) {
  		new_ap_level = pwr_level_80211h;
  
++<<<<<<< HEAD
 +		if (sdata->ap_power_level == new_ap_level)
++=======
+ 		if (link->ap_power_level == new_ap_level)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			return 0;
  
  		sdata_dbg(sdata,
  			  "Limiting TX power to %d (%d - %d) dBm as advertised by %pM\n",
  			  pwr_level_80211h, chan_pwr, pwr_reduction_80211h,
++<<<<<<< HEAD
 +			  sdata->u.mgd.bssid);
 +	} else {  /* has_cisco_pwr is always true here. */
 +		new_ap_level = pwr_level_cisco;
 +
 +		if (sdata->ap_power_level == new_ap_level)
++=======
+ 			  link->u.mgd.bssid);
+ 	} else {  /* has_cisco_pwr is always true here. */
+ 		new_ap_level = pwr_level_cisco;
+ 
+ 		if (link->ap_power_level == new_ap_level)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			return 0;
  
  		sdata_dbg(sdata,
  			  "Limiting TX power to %d dBm as advertised by %pM\n",
++<<<<<<< HEAD
 +			  pwr_level_cisco, sdata->u.mgd.bssid);
 +	}
 +
 +	sdata->ap_power_level = new_ap_level;
++=======
+ 			  pwr_level_cisco, link->u.mgd.bssid);
+ 	}
+ 
+ 	link->ap_power_level = new_ap_level;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	if (__ieee80211_recalc_txpower(sdata))
  		return BSS_CHANGED_TXPOWER;
  	return 0;
@@@ -1970,14 -1988,15 +2252,26 @@@ void ieee80211_dynamic_ps_timer(struct 
  void ieee80211_dfs_cac_timer_work(struct work_struct *work)
  {
  	struct delayed_work *delayed_work = to_delayed_work(work);
++<<<<<<< HEAD
 +	struct ieee80211_sub_if_data *sdata =
 +		container_of(delayed_work, struct ieee80211_sub_if_data,
 +			     dfs_cac_timer_work);
 +	struct cfg80211_chan_def chandef = sdata->vif.bss_conf.chandef;
 +
 +	mutex_lock(&sdata->local->mtx);
 +	if (sdata->wdev.cac_started) {
 +		ieee80211_vif_release_channel(sdata);
++=======
+ 	struct ieee80211_link_data *link =
+ 		container_of(delayed_work, struct ieee80211_link_data,
+ 			     dfs_cac_timer_work);
+ 	struct cfg80211_chan_def chandef = link->conf->chandef;
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 
+ 	mutex_lock(&sdata->local->mtx);
+ 	if (sdata->wdev.cac_started) {
+ 		ieee80211_link_release_channel(link);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		cfg80211_cac_event(sdata->dev, &chandef,
  				   NL80211_RADAR_CAC_FINISHED,
  				   GFP_KERNEL);
@@@ -2294,7 -2316,9 +2588,13 @@@ static void ieee80211_set_associated(st
  {
  	struct ieee80211_bss *bss = (void *)cbss->priv;
  	struct ieee80211_local *local = sdata->local;
++<<<<<<< HEAD
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
++=======
+ 	struct ieee80211_link_data *link = &sdata->deflink;
+ 	struct ieee80211_bss_conf *bss_conf = link->conf;
+ 	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	bss_info_changed |= BSS_CHANGED_ASSOC;
  	bss_info_changed |= ieee80211_handle_bss_capability(sdata,
@@@ -2304,8 -2328,9 +2604,14 @@@
  		beacon_loss_count * bss_conf->beacon_int));
  
  	sdata->u.mgd.associated = true;
++<<<<<<< HEAD
 +	sdata->u.mgd.assoc_bss = cbss;
 +	memcpy(sdata->u.mgd.bssid, cbss->bssid, ETH_ALEN);
++=======
+ 	link->u.mgd.bss = cbss;
+ 	memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
+ 	memcpy(sdata->vif.cfg.ap_addr, cbss->bssid, ETH_ALEN);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	ieee80211_check_rate_mask(sdata);
  
@@@ -2326,7 -2349,7 +2632,11 @@@
  					(u8 *) &bss_conf->p2p_noa_attr,
  					sizeof(bss_conf->p2p_noa_attr));
  			if (ret >= 2) {
++<<<<<<< HEAD
 +				sdata->u.mgd.p2p_noa_index =
++=======
+ 				link->u.mgd.p2p_noa_index =
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  					bss_conf->p2p_noa_attr.index;
  				bss_info_changed |= BSS_CHANGED_P2P_PS;
  			}
@@@ -2339,14 -2362,14 +2649,22 @@@
  
  	ieee80211_led_assoc(local, 1);
  
++<<<<<<< HEAD
 +	if (sdata->u.mgd.have_beacon) {
++=======
+ 	if (link->u.mgd.have_beacon) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		/*
  		 * If the AP is buggy we may get here with no DTIM period
  		 * known, so assume it's 1 which is the only safe assumption
  		 * in that case, although if the TIM IE is broken powersave
  		 * probably just won't work at all.
  		 */
++<<<<<<< HEAD
 +		bss_conf->dtim_period = sdata->u.mgd.dtim_period ?: 1;
++=======
+ 		bss_conf->dtim_period = link->u.mgd.dtim_period ?: 1;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		bss_conf->beacon_rate = bss->beacon_rate;
  		bss_info_changed |= BSS_CHANGED_BEACON_INFO;
  	} else {
@@@ -2400,7 -2424,7 +2719,11 @@@ static void ieee80211_set_disassoc(stru
  	ieee80211_stop_poll(sdata);
  
  	ifmgd->associated = false;
++<<<<<<< HEAD
 +	ifmgd->assoc_bss = NULL;
++=======
+ 	link->u.mgd.bss = NULL;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	netif_carrier_off(sdata->dev);
  
  	/*
@@@ -2438,12 -2462,12 +2761,21 @@@
  		 * driver requested so.
  		 */
  		if (ieee80211_hw_check(&local->hw, DEAUTH_NEED_MGD_TX_PREP) &&
++<<<<<<< HEAD
 +		    !ifmgd->have_beacon) {
 +			drv_mgd_prepare_tx(sdata->local, sdata, &info);
 +		}
 +
 +		ieee80211_send_deauth_disassoc(sdata, ifmgd->bssid,
 +					       ifmgd->bssid, stype, reason,
++=======
+ 		    !link->u.mgd.have_beacon) {
+ 			drv_mgd_prepare_tx(sdata->local, sdata, &info);
+ 		}
+ 
+ 		ieee80211_send_deauth_disassoc(sdata, link->u.mgd.bssid,
+ 					       link->u.mgd.bssid, stype, reason,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  					       tx, frame_buf);
  	}
  
@@@ -2454,9 -2478,10 +2786,13 @@@
  	drv_mgd_complete_tx(sdata->local, sdata, &info);
  
  	/* clear bssid only after building the needed mgmt frames */
++<<<<<<< HEAD
 +	eth_zero_addr(ifmgd->bssid);
++=======
+ 	eth_zero_addr(link->u.mgd.bssid);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
 -	eth_zero_addr(sdata->vif.cfg.ap_addr);
 -	sdata->vif.cfg.ssid_len = 0;
 +	sdata->vif.bss_conf.ssid_len = 0;
  
  	/* remove AP and TDLS peers */
  	sta_info_flush(sdata);
@@@ -2466,11 -2491,11 +2802,17 @@@
  
  	ieee80211_led_assoc(local, 0);
  	changed |= BSS_CHANGED_ASSOC;
 -	sdata->vif.cfg.assoc = false;
 +	sdata->vif.bss_conf.assoc = false;
  
++<<<<<<< HEAD
 +	ifmgd->p2p_noa_index = -1;
 +	memset(&sdata->vif.bss_conf.p2p_noa_attr, 0,
 +	       sizeof(sdata->vif.bss_conf.p2p_noa_attr));
++=======
+ 	link->u.mgd.p2p_noa_index = -1;
+ 	memset(&link->conf->p2p_noa_attr, 0,
+ 	       sizeof(link->conf->p2p_noa_attr));
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	/* on the next assoc, re-program HT/VHT parameters */
  	memset(&ifmgd->ht_capa, 0, sizeof(ifmgd->ht_capa));
@@@ -2479,23 -2504,23 +2821,27 @@@
  	memset(&ifmgd->vht_capa_mask, 0, sizeof(ifmgd->vht_capa_mask));
  
  	/* reset MU-MIMO ownership and group data */
- 	memset(sdata->vif.bss_conf.mu_group.membership, 0,
- 	       sizeof(sdata->vif.bss_conf.mu_group.membership));
- 	memset(sdata->vif.bss_conf.mu_group.position, 0,
- 	       sizeof(sdata->vif.bss_conf.mu_group.position));
+ 	memset(link->conf->mu_group.membership, 0,
+ 	       sizeof(link->conf->mu_group.membership));
+ 	memset(link->conf->mu_group.position, 0,
+ 	       sizeof(link->conf->mu_group.position));
  	changed |= BSS_CHANGED_MU_GROUPS;
- 	sdata->vif.bss_conf.mu_mimo_owner = false;
+ 	link->conf->mu_mimo_owner = false;
  
++<<<<<<< HEAD
 +	sdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;
++=======
+ 	link->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	del_timer_sync(&local->dynamic_ps_timer);
  	cancel_work_sync(&local->dynamic_ps_enable_work);
  
  	/* Disable ARP filtering */
 -	if (sdata->vif.cfg.arp_addr_cnt)
 +	if (sdata->vif.bss_conf.arp_addr_cnt)
  		changed |= BSS_CHANGED_ARP_FILTER;
  
- 	sdata->vif.bss_conf.qos = false;
+ 	link->conf->qos = false;
  	changed |= BSS_CHANGED_QOS;
  
  	/* The BSSID (not really interesting) and HT changed */
@@@ -2508,24 -2533,26 +2854,42 @@@
  	del_timer_sync(&sdata->u.mgd.conn_mon_timer);
  	del_timer_sync(&sdata->u.mgd.bcn_mon_timer);
  	del_timer_sync(&sdata->u.mgd.timer);
- 	del_timer_sync(&sdata->u.mgd.chswitch_timer);
+ 	del_timer_sync(&link->u.mgd.chswitch_timer);
  
- 	sdata->vif.bss_conf.dtim_period = 0;
- 	sdata->vif.bss_conf.beacon_rate = NULL;
+ 	link->conf->dtim_period = 0;
+ 	link->conf->beacon_rate = NULL;
  
++<<<<<<< HEAD
 +	ifmgd->have_beacon = false;
 +
 +	ifmgd->flags = 0;
 +	mutex_lock(&local->mtx);
 +	ieee80211_vif_release_channel(sdata);
 +
 +	sdata->vif.bss_conf.csa_active = false;
 +	ifmgd->csa_waiting_bcn = false;
 +	ifmgd->csa_ignored_same_chan = false;
 +	if (sdata->csa_block_tx) {
 +		ieee80211_wake_vif_queues(local, sdata,
 +					  IEEE80211_QUEUE_STOP_REASON_CSA);
 +		sdata->csa_block_tx = false;
++=======
+ 	link->u.mgd.have_beacon = false;
+ 	link->u.mgd.tracking_signal_avg = false;
+ 
+ 	ifmgd->flags = 0;
+ 	link->u.mgd.conn_flags = 0;
+ 	mutex_lock(&local->mtx);
+ 	ieee80211_link_release_channel(link);
+ 
+ 	link->conf->csa_active = false;
+ 	link->u.mgd.csa_waiting_bcn = false;
+ 	link->u.mgd.csa_ignored_same_chan = false;
+ 	if (link->csa_block_tx) {
+ 		ieee80211_wake_vif_queues(local, sdata,
+ 					  IEEE80211_QUEUE_STOP_REASON_CSA);
+ 		link->csa_block_tx = false;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  	mutex_unlock(&local->mtx);
  
@@@ -2869,12 -2903,9 +3240,15 @@@ static void ieee80211_beacon_connection
  			     u.mgd.beacon_connection_loss_work);
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  
++<<<<<<< HEAD
 +	if (ifmgd->associated)
 +		ifmgd->beacon_loss_count++;
 +
++=======
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	if (ifmgd->connection_loss) {
  		sdata_info(sdata, "Connection to AP %pM lost\n",
 -			   sdata->vif.cfg.ap_addr);
 +			   ifmgd->bssid);
  		__ieee80211_disconnect(sdata);
  		ifmgd->connection_loss = false;
  	} else if (ifmgd->driver_disconnect) {
@@@ -2953,11 -2986,14 +3329,19 @@@ static void ieee80211_destroy_auth_data
  		del_timer_sync(&sdata->u.mgd.timer);
  		sta_info_destroy_addr(sdata, auth_data->bss->bssid);
  
++<<<<<<< HEAD
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 		/* FIXME: other links are destroyed? */
+ 		sdata->deflink.u.mgd.conn_flags = 0;
+ 		eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		sdata->u.mgd.flags = 0;
  		mutex_lock(&sdata->local->mtx);
 -		ieee80211_link_release_channel(&sdata->deflink);
 +		ieee80211_vif_release_channel(sdata);
  		mutex_unlock(&sdata->local->mtx);
  	}
  
@@@ -2982,8 -3018,11 +3366,16 @@@ static void ieee80211_destroy_assoc_dat
  		del_timer_sync(&sdata->u.mgd.timer);
  		sta_info_destroy_addr(sdata, assoc_data->bss->bssid);
  
++<<<<<<< HEAD
 +		eth_zero_addr(sdata->u.mgd.bssid);
 +		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 		/* FIXME: other links are destroyed? */
+ 		sdata->deflink.u.mgd.conn_flags = 0;
+ 		eth_zero_addr(sdata->deflink.u.mgd.bssid);
+ 		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 						  BSS_CHANGED_BSSID);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		sdata->u.mgd.flags = 0;
  		sdata->vif.bss_conf.mu_mimo_owner = false;
  
@@@ -3476,9 -3516,9 +3869,15 @@@ static bool ieee80211_assoc_success(str
  	 */
  	if (!is_6ghz &&
  	    ((assoc_data->wmm && !elems->wmm_param) ||
++<<<<<<< HEAD
 +	     (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +	      (!elems->ht_cap_elem || !elems->ht_operation)) ||
 +	     (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
++=======
+ 	     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
+ 	      (!elems->ht_cap_elem || !elems->ht_operation)) ||
+ 	     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	      (!elems->vht_cap_elem || !elems->vht_operation)))) {
  		const struct cfg80211_bss_ies *ies;
  		struct ieee802_11_elems *bss_elems;
@@@ -3514,25 -3554,25 +3913,41 @@@
  		 * have to include the IEs in the (re)association response.
  		 */
  		if (!elems->ht_cap_elem && bss_elems->ht_cap_elem &&
++<<<<<<< HEAD
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
++=======
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			elems->ht_cap_elem = bss_elems->ht_cap_elem;
  			sdata_info(sdata,
  				   "AP bug: HT capability missing from AssocResp\n");
  		}
  		if (!elems->ht_operation && bss_elems->ht_operation &&
++<<<<<<< HEAD
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
++=======
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			elems->ht_operation = bss_elems->ht_operation;
  			sdata_info(sdata,
  				   "AP bug: HT operation missing from AssocResp\n");
  		}
  		if (!elems->vht_cap_elem && bss_elems->vht_cap_elem &&
++<<<<<<< HEAD
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)) {
++=======
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			elems->vht_cap_elem = bss_elems->vht_cap_elem;
  			sdata_info(sdata,
  				   "AP bug: VHT capa missing from AssocResp\n");
  		}
  		if (!elems->vht_operation && bss_elems->vht_operation &&
++<<<<<<< HEAD
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)) {
++=======
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			elems->vht_operation = bss_elems->vht_operation;
  			sdata_info(sdata,
  				   "AP bug: VHT operation missing from AssocResp\n");
@@@ -3545,7 -3585,7 +3960,11 @@@
  	 * We previously checked these in the beacon/probe response, so
  	 * they should be present here. This is just a safety net.
  	 */
++<<<<<<< HEAD
 +	if (!is_6ghz && !(ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
++=======
+ 	if (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    (!elems->wmm_param || !elems->ht_cap_elem || !elems->ht_operation)) {
  		sdata_info(sdata,
  			   "HT AP is missing WMM params or HT capability/operation\n");
@@@ -3553,7 -3593,7 +3972,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (!is_6ghz && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
++=======
+ 	if (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    (!elems->vht_cap_elem || !elems->vht_operation)) {
  		sdata_info(sdata,
  			   "VHT AP is missing VHT capability/operation\n");
@@@ -3561,7 -3601,7 +3984,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (is_6ghz && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
++=======
+ 	if (is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    !elems->he_6ghz_capa) {
  		sdata_info(sdata,
  			   "HE 6 GHz AP is missing HE 6 GHz band capability\n");
@@@ -3588,7 -3628,7 +4015,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
++=======
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    (!elems->he_cap || !elems->he_operation)) {
  		mutex_unlock(&sdata->local->sta_mtx);
  		sdata_info(sdata,
@@@ -3598,15 -3638,17 +4029,27 @@@
  	}
  
  	/* Set up internal HT/VHT capabilities */
++<<<<<<< HEAD
 +	if (elems->ht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
++=======
+ 	if (elems->ht_cap_elem && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
 -						  elems->ht_cap_elem,
 -						  &sta->deflink);
 +						  elems->ht_cap_elem, sta);
  
++<<<<<<< HEAD
 +	if (elems->vht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
++=======
+ 	if (elems->vht_cap_elem && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
 -						    elems->vht_cap_elem,
 -						    &sta->deflink);
 +						    elems->vht_cap_elem, sta);
  
++<<<<<<< HEAD
 +	if (elems->he_operation && !(ifmgd->flags & IEEE80211_STA_DISABLE_HE) &&
++=======
+ 	if (elems->he_operation && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	    elems->he_cap) {
  		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
  						  elems->he_cap,
@@@ -3623,10 -3665,10 +4066,14 @@@
  		else
  			bss_conf->twt_protected = false;
  
- 		changed |= ieee80211_recalc_twt_req(sdata, sta, elems);
+ 		changed |= ieee80211_recalc_twt_req(link, sta, elems);
  
  		if (elems->eht_operation && elems->eht_cap &&
++<<<<<<< HEAD
 +		    !(ifmgd->flags & IEEE80211_STA_DISABLE_EHT)) {
++=======
+ 		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
  							    elems->he_cap,
  							    elems->he_cap_len,
@@@ -3750,16 -3792,16 +4197,29 @@@
  	 * that effect because the AP values is an unsigned
  	 * 4-bit value.
  	 */
++<<<<<<< HEAD
 +	ifmgd->wmm_last_param_set = -1;
 +	ifmgd->mu_edca_last_param_set = -1;
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_WMM) {
 +		ieee80211_set_wmm_default(sdata, false, false);
 +	} else if (!ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
 +					     elems->wmm_param_len,
 +					     elems->mu_edca_param_set)) {
 +		/* still enable QoS since we might have HT/VHT */
 +		ieee80211_set_wmm_default(sdata, false, true);
++=======
+ 	link->u.mgd.wmm_last_param_set = -1;
+ 	link->u.mgd.mu_edca_last_param_set = -1;
+ 
+ 	if (ifmgd->flags & IEEE80211_STA_DISABLE_WMM) {
+ 		ieee80211_set_wmm_default(link, false, false);
+ 	} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,
+ 					     elems->wmm_param_len,
+ 					     elems->mu_edca_param_set)) {
+ 		/* still enable QoS since we might have HT/VHT */
+ 		ieee80211_set_wmm_default(link, false, true);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		/* set the disable-WMM flag in this case to disable
  		 * tracking WMM parameter changes in the beacon if
  		 * the parameters weren't actually valid. Doing so
@@@ -3996,10 -4040,10 +4458,14 @@@ static void ieee80211_rx_mgmt_probe_res
  	if (baselen > len)
  		return;
  
- 	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
  
  	if (ifmgd->associated &&
++<<<<<<< HEAD
 +	    ether_addr_equal(mgmt->bssid, ifmgd->bssid))
++=======
+ 	    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		ieee80211_reset_ap_probe(sdata);
  }
  
@@@ -4033,24 -4077,27 +4499,46 @@@ static void ieee80211_handle_beacon_sig
  					struct ieee80211_local *local,
  					struct ieee80211_rx_status *rx_status)
  {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 
  	/* Track average RSSI from the Beacon frames of the current AP */
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_RESET_SIGNAL_AVE) {
 +		ifmgd->flags &= ~IEEE80211_STA_RESET_SIGNAL_AVE;
 +		ewma_beacon_signal_init(&ifmgd->ave_beacon_signal);
 +		ifmgd->last_cqm_event_signal = 0;
 +		ifmgd->count_beacon_signal = 1;
 +		ifmgd->last_ave_beacon_signal = 0;
 +	} else {
 +		ifmgd->count_beacon_signal++;
 +	}
 +
 +	ewma_beacon_signal_add(&ifmgd->ave_beacon_signal, -rx_status->signal);
 +
 +	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_sig = ifmgd->last_ave_beacon_signal;
++=======
+ 	if (!link->u.mgd.tracking_signal_avg) {
+ 		link->u.mgd.tracking_signal_avg = true;
+ 		ewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);
+ 		link->u.mgd.last_cqm_event_signal = 0;
+ 		link->u.mgd.count_beacon_signal = 1;
+ 		link->u.mgd.last_ave_beacon_signal = 0;
+ 	} else {
+ 		link->u.mgd.count_beacon_signal++;
+ 	}
+ 
+ 	ewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,
+ 			       -rx_status->signal);
+ 
+ 	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_sig = link->u.mgd.last_ave_beacon_signal;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		struct ieee80211_event event = {
  			.type = RSSI_EVENT,
  		};
@@@ -4061,36 -4108,36 +4549,59 @@@
  		 */
  		if (sig > ifmgd->rssi_max_thold &&
  		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
++<<<<<<< HEAD
 +			ifmgd->last_ave_beacon_signal = sig;
++=======
+ 			link->u.mgd.last_ave_beacon_signal = sig;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			event.u.rssi.data = RSSI_EVENT_HIGH;
  			drv_event_callback(local, sdata, &event);
  		} else if (sig < ifmgd->rssi_min_thold &&
  			   (last_sig >= ifmgd->rssi_max_thold ||
  			   last_sig == 0)) {
++<<<<<<< HEAD
 +			ifmgd->last_ave_beacon_signal = sig;
++=======
+ 			link->u.mgd.last_ave_beacon_signal = sig;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			event.u.rssi.data = RSSI_EVENT_LOW;
  			drv_event_callback(local, sdata, &event);
  		}
  	}
  
  	if (bss_conf->cqm_rssi_thold &&
++<<<<<<< HEAD
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
 +	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_event = ifmgd->last_cqm_event_signal;
++=======
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
+ 	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		int thold = bss_conf->cqm_rssi_thold;
  		int hyst = bss_conf->cqm_rssi_hyst;
  
  		if (sig < thold &&
  		    (last_event == 0 || sig < last_event - hyst)) {
++<<<<<<< HEAD
 +			ifmgd->last_cqm_event_signal = sig;
++=======
+ 			link->u.mgd.last_cqm_event_signal = sig;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			ieee80211_cqm_rssi_notify(
  				&sdata->vif,
  				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
  				sig, GFP_KERNEL);
  		} else if (sig > thold &&
  			   (last_event == 0 || sig > last_event + hyst)) {
++<<<<<<< HEAD
 +			ifmgd->last_cqm_event_signal = sig;
++=======
+ 			link->u.mgd.last_cqm_event_signal = sig;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			ieee80211_cqm_rssi_notify(
  				&sdata->vif,
  				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
@@@ -4099,22 -4146,22 +4610,36 @@@
  	}
  
  	if (bss_conf->cqm_rssi_low &&
++<<<<<<< HEAD
 +	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
 +		int sig = -ewma_beacon_signal_read(&ifmgd->ave_beacon_signal);
 +		int last_event = ifmgd->last_cqm_event_signal;
++=======
+ 	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+ 		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
+ 		int last_event = link->u.mgd.last_cqm_event_signal;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		int low = bss_conf->cqm_rssi_low;
  		int high = bss_conf->cqm_rssi_high;
  
  		if (sig < low &&
  		    (last_event == 0 || last_event >= low)) {
++<<<<<<< HEAD
 +			ifmgd->last_cqm_event_signal = sig;
++=======
+ 			link->u.mgd.last_cqm_event_signal = sig;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			ieee80211_cqm_rssi_notify(
  				&sdata->vif,
  				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
  				sig, GFP_KERNEL);
  		} else if (sig > high &&
  			   (last_event == 0 || last_event <= high)) {
++<<<<<<< HEAD
 +			ifmgd->last_cqm_event_signal = sig;
++=======
+ 			link->u.mgd.last_cqm_event_signal = sig;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			ieee80211_cqm_rssi_notify(
  				&sdata->vif,
  				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
@@@ -4137,8 -4184,10 +4662,9 @@@ static void ieee80211_rx_mgmt_beacon(st
  				     struct ieee80211_hdr *hdr, size_t len,
  				     struct ieee80211_rx_status *rx_status)
  {
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
 -	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
  	struct ieee80211_mgmt *mgmt = (void *) hdr;
  	size_t baselen;
  	struct ieee802_11_elems *elems;
@@@ -4193,18 -4242,18 +4719,23 @@@
  		if (!elems)
  			return;
  
- 		ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
+ 		ieee80211_rx_bss_info(link, mgmt, len, rx_status);
  
  		if (elems->dtim_period)
++<<<<<<< HEAD
 +			ifmgd->dtim_period = elems->dtim_period;
 +		ifmgd->have_beacon = true;
++=======
+ 			link->u.mgd.dtim_period = elems->dtim_period;
+ 		link->u.mgd.have_beacon = true;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		ifmgd->assoc_data->need_beacon = false;
  		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
- 			sdata->vif.bss_conf.sync_tsf =
+ 			link->conf->sync_tsf =
  				le64_to_cpu(mgmt->u.beacon.timestamp);
- 			sdata->vif.bss_conf.sync_device_ts =
+ 			link->conf->sync_device_ts =
  				rx_status->device_timestamp;
- 			sdata->vif.bss_conf.sync_dtim_count = elems->dtim_count;
+ 			link->conf->sync_dtim_count = elems->dtim_count;
  		}
  
  		if (elems->mbssid_config_ie)
@@@ -4228,12 -4277,12 +4759,18 @@@
  	}
  
  	if (!ifmgd->associated ||
++<<<<<<< HEAD
 +	    !ieee80211_rx_our_beacon(bssid, ifmgd->assoc_bss))
 +		return;
 +	bssid = ifmgd->bssid;
++=======
+ 	    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))
+ 		return;
+ 	bssid = link->u.mgd.bssid;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
- 		ieee80211_handle_beacon_sig(sdata, ifmgd, bss_conf,
+ 		ieee80211_handle_beacon_sig(link, ifmgd, bss_conf,
  					    local, rx_status);
  
  	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
@@@ -4296,28 -4345,28 +4833,50 @@@
  					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
  					    (u8 *) &noa, sizeof(noa));
  		if (ret >= 2) {
++<<<<<<< HEAD
 +			if (sdata->u.mgd.p2p_noa_index != noa.index) {
 +				/* valid noa_attr and index changed */
 +				sdata->u.mgd.p2p_noa_index = noa.index;
++=======
+ 			if (link->u.mgd.p2p_noa_index != noa.index) {
+ 				/* valid noa_attr and index changed */
+ 				link->u.mgd.p2p_noa_index = noa.index;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
  				changed |= BSS_CHANGED_P2P_PS;
  				/*
  				 * make sure we update all information, the CRC
  				 * mechanism doesn't look at P2P attributes.
  				 */
++<<<<<<< HEAD
 +				ifmgd->beacon_crc_valid = false;
 +			}
 +		} else if (sdata->u.mgd.p2p_noa_index != -1) {
 +			/* noa_attr not found and we had valid noa_attr before */
 +			sdata->u.mgd.p2p_noa_index = -1;
 +			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
 +			changed |= BSS_CHANGED_P2P_PS;
 +			ifmgd->beacon_crc_valid = false;
 +		}
 +	}
 +
 +	if (ifmgd->csa_waiting_bcn)
 +		ieee80211_chswitch_post_beacon(sdata);
++=======
+ 				link->u.mgd.beacon_crc_valid = false;
+ 			}
+ 		} else if (link->u.mgd.p2p_noa_index != -1) {
+ 			/* noa_attr not found and we had valid noa_attr before */
+ 			link->u.mgd.p2p_noa_index = -1;
+ 			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
+ 			changed |= BSS_CHANGED_P2P_PS;
+ 			link->u.mgd.beacon_crc_valid = false;
+ 		}
+ 	}
+ 
+ 	if (link->u.mgd.csa_waiting_bcn)
+ 		ieee80211_chswitch_post_beacon(link);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	/*
  	 * Update beacon timing and dtim count on every beacon appearance. This
@@@ -4329,27 -4378,27 +4888,39 @@@
  	 */
  	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
  	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
- 		sdata->vif.bss_conf.sync_tsf =
+ 		link->conf->sync_tsf =
  			le64_to_cpu(mgmt->u.beacon.timestamp);
- 		sdata->vif.bss_conf.sync_device_ts =
+ 		link->conf->sync_device_ts =
  			rx_status->device_timestamp;
- 		sdata->vif.bss_conf.sync_dtim_count = elems->dtim_count;
+ 		link->conf->sync_dtim_count = elems->dtim_count;
  	}
  
++<<<<<<< HEAD
 +	if ((ncrc == ifmgd->beacon_crc && ifmgd->beacon_crc_valid) ||
 +	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
 +		goto free;
 +	ifmgd->beacon_crc = ncrc;
 +	ifmgd->beacon_crc_valid = true;
++=======
+ 	if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||
+ 	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
+ 		goto free;
+ 	link->u.mgd.beacon_crc = ncrc;
+ 	link->u.mgd.beacon_crc_valid = true;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
- 	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status);
+ 	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
  
- 	ieee80211_sta_process_chanswitch(sdata, rx_status->mactime,
+ 	ieee80211_sta_process_chanswitch(link, rx_status->mactime,
  					 rx_status->device_timestamp,
  					 elems, true);
  
  	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_WMM) &&
++<<<<<<< HEAD
 +	    ieee80211_sta_wmm_params(local, sdata, elems->wmm_param,
++=======
+ 	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  				     elems->wmm_param_len,
  				     elems->mu_edca_param_set))
  		changed |= BSS_CHANGED_QOS;
@@@ -4358,12 -4407,12 +4929,20 @@@
  	 * If we haven't had a beacon before, tell the driver about the
  	 * DTIM period (and beacon timing if desired) now.
  	 */
++<<<<<<< HEAD
 +	if (!ifmgd->have_beacon) {
++=======
+ 	if (!link->u.mgd.have_beacon) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		/* a few bogus AP send dtim_period = 0 or no TIM IE */
  		bss_conf->dtim_period = elems->dtim_period ?: 1;
  
  		changed |= BSS_CHANGED_BEACON_INFO;
++<<<<<<< HEAD
 +		ifmgd->have_beacon = true;
++=======
+ 		link->u.mgd.have_beacon = true;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  		mutex_lock(&local->iflist_mtx);
  		ieee80211_recalc_ps(local);
@@@ -4385,11 -4434,11 +4964,11 @@@
  				erp_valid, erp_value);
  
  	mutex_lock(&local->sta_mtx);
 -	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
 +	sta = sta_info_get(sdata, bssid);
  
- 	changed |= ieee80211_recalc_twt_req(sdata, sta, elems);
+ 	changed |= ieee80211_recalc_twt_req(link, sta, elems);
  
- 	if (ieee80211_config_bw(sdata, sta, elems->ht_cap_elem,
+ 	if (ieee80211_config_bw(link, sta, elems->ht_cap_elem,
  				elems->vht_cap_elem, elems->ht_operation,
  				elems->vht_operation, elems->he_operation,
  				elems->eht_operation,
@@@ -4409,7 -4458,8 +4988,12 @@@
  	}
  
  	if (sta && elems->opmode_notif)
++<<<<<<< HEAD
 +		ieee80211_vht_handle_opmode(sdata, sta, *elems->opmode_notif,
++=======
+ 		ieee80211_vht_handle_opmode(sdata, &sta->deflink,
+ 					    *elems->opmode_notif,
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  					    rx_status->band);
  	mutex_unlock(&local->sta_mtx);
  
@@@ -4419,7 -4469,7 +5003,11 @@@
  					       elems->pwr_constr_elem,
  					       elems->cisco_dtpc_elem);
  
++<<<<<<< HEAD
 +	ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 	ieee80211_link_info_change_notify(sdata, link, changed);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  free:
  	kfree(elems);
  }
@@@ -4838,9 -4891,12 +5428,17 @@@ static void ieee80211_sta_bcn_mon_timer
  {
  	struct ieee80211_sub_if_data *sdata =
  		from_timer(sdata, t, u.mgd.bcn_mon_timer);
 +	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
  
++<<<<<<< HEAD
 +	if (sdata->vif.bss_conf.csa_active && !ifmgd->csa_waiting_bcn)
++=======
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return;
  
  	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
@@@ -4860,10 -4916,14 +5458,18 @@@ static void ieee80211_sta_conn_mon_time
  	struct sta_info *sta;
  	unsigned long timeout;
  
++<<<<<<< HEAD
 +	if (sdata->vif.bss_conf.csa_active && !ifmgd->csa_waiting_bcn)
++=======
+ 	if (WARN_ON(sdata->vif.valid_links))
+ 		return;
+ 
+ 	if (sdata->vif.bss_conf.csa_active &&
+ 	    !sdata->deflink.u.mgd.csa_waiting_bcn)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return;
  
 -	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
 +	sta = sta_info_get(sdata, ifmgd->bssid);
  	if (!sta)
  		return;
  
@@@ -5003,11 -5063,21 +5609,10 @@@ void ieee80211_sta_restart(struct ieee8
  /* interface setup */
  void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
  {
 -	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 +	struct ieee80211_if_managed *ifmgd;
  
 +	ifmgd = &sdata->u.mgd;
  	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
- 	INIT_WORK(&ifmgd->chswitch_work, ieee80211_chswitch_work);
  	INIT_WORK(&ifmgd->beacon_connection_loss_work,
  		  ieee80211_beacon_connection_loss_work);
  	INIT_WORK(&ifmgd->csa_connection_drop_work,
@@@ -5039,6 -5100,25 +5643,28 @@@
  	ifmgd->orig_teardown_skb = NULL;
  }
  
++<<<<<<< HEAD
++=======
+ void ieee80211_mgd_setup_link(struct ieee80211_link_data *link)
+ {
+ 	struct ieee80211_local *local = link->sdata->local;
+ 
+ 	link->u.mgd.p2p_noa_index = -1;
+ 	link->u.mgd.conn_flags = 0;
+ 	link->conf->bssid = link->u.mgd.bssid;
+ 
+ 	INIT_WORK(&link->u.mgd.request_smps_work,
+ 		  ieee80211_request_smps_mgd_work);
+ 	if (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
+ 	else
+ 		link->u.mgd.req_smps = IEEE80211_SMPS_OFF;
+ 
+ 	INIT_WORK(&link->u.mgd.chswitch_work, ieee80211_chswitch_work);
+ 	timer_setup(&link->u.mgd.chswitch_timer, ieee80211_chswitch_timer, 0);
+ }
+ 
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  /* scan finished notification */
  void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
  {
@@@ -5069,7 -5148,7 +5695,11 @@@ static u8 ieee80211_max_rx_chains(struc
  	bool support_160;
  	u8 chains = 1;
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT)
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return chains;
  
  	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
@@@ -5082,7 -5161,7 +5712,11 @@@
  		 */
  	}
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_VHT)
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return chains;
  
  	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
@@@ -5101,7 -5180,7 +5735,11 @@@
  		chains = max(chains, nss);
  	}
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HE)
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		return chains;
  
  	ies = rcu_dereference(cbss->ies);
@@@ -5356,70 -5435,70 +5995,124 @@@ static int ieee80211_prep_channel(struc
  
  	sband = local->hw.wiphy->bands[cbss->channel->band];
  
++<<<<<<< HEAD
 +	ifmgd->flags &= ~(IEEE80211_STA_DISABLE_40MHZ |
 +			  IEEE80211_STA_DISABLE_80P80MHZ |
 +			  IEEE80211_STA_DISABLE_160MHZ);
++=======
+ 	link->u.mgd.conn_flags &= ~(IEEE80211_CONN_DISABLE_40MHZ |
+ 				    IEEE80211_CONN_DISABLE_80P80MHZ |
+ 				    IEEE80211_CONN_DISABLE_160MHZ);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	/* disable HT/VHT/HE if we don't support them */
  	if (!sband->ht_cap.ht_supported && !is_6ghz) {
  		mlme_dbg(sdata, "HT not supported, disabling HT/VHT/HE/EHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	if (!sband->vht_cap.vht_supported && is_5ghz) {
  		mlme_dbg(sdata, "VHT not supported, disabling VHT/HE/EHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	if (!ieee80211_get_he_iftype_cap(sband,
  					 ieee80211_vif_type_p2p(&sdata->vif))) {
  		mlme_dbg(sdata, "HE not supported, disabling HE and EHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	if (!ieee80211_get_eht_iftype_cap(sband,
  					  ieee80211_vif_type_p2p(&sdata->vif))) {
  		mlme_dbg(sdata, "EHT not supported, disabling EHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT) && !is_6ghz) {
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) && !is_6ghz) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		ht_oper = elems->ht_operation;
  		ht_cap = elems->ht_cap_elem;
  
  		if (!ht_cap) {
++<<<<<<< HEAD
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
++=======
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			ht_oper = NULL;
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) && !is_6ghz) {
++=======
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) && !is_6ghz) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		vht_oper = elems->vht_operation;
  		if (vht_oper && !ht_oper) {
  			vht_oper = NULL;
  			sdata_info(sdata,
  				   "AP advertised VHT without HT, disabling HT/VHT/HE\n");
++<<<<<<< HEAD
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		}
  
  		if (!elems->vht_cap_elem) {
  			sdata_info(sdata,
  				   "bad VHT capabilities, disabling VHT\n");
++<<<<<<< HEAD
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
++=======
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			vht_oper = NULL;
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
++=======
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		he_oper = elems->he_operation;
  
  		if (is_6ghz) {
@@@ -5448,8 -5527,8 +6141,13 @@@
  
  		if (!ieee80211_verify_peer_he_mcs_support(sdata, ies, he_oper) ||
  		    !ieee80211_verify_sta_he_mcs_support(sdata, sband, he_oper))
++<<<<<<< HEAD
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +				        IEEE80211_STA_DISABLE_EHT;
++=======
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE |
+ 						  IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	/*
@@@ -5458,8 -5537,10 +6156,15 @@@
  	 * both the 6 GHz operation information (from the HE operation IE) and
  	 * EHT operation.
  	 */
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & (IEEE80211_STA_DISABLE_HE |
 +			      IEEE80211_STA_DISABLE_EHT)) && he_oper) {
++=======
+ 	if (!(link->u.mgd.conn_flags &
+ 			(IEEE80211_CONN_DISABLE_HE |
+ 			 IEEE80211_CONN_DISABLE_EHT)) &&
+ 	    he_oper) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		const struct cfg80211_bss_ies *ies;
  		const u8 *eht_oper_ie;
  
@@@ -5486,7 -5567,7 +6191,11 @@@
  
  	if (!have_80mhz) {
  		sdata_info(sdata, "80 MHz not supported, disabling VHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	if (sband->band == NL80211_BAND_S1GHZ) {
@@@ -5496,29 -5577,30 +6205,51 @@@
  				   "AP missing S1G operation element?\n");
  	}
  
++<<<<<<< HEAD
 +	ifmgd->flags |= ieee80211_determine_chantype(sdata, sband,
 +						     cbss->channel,
 +						     bss->vht_cap_info,
 +						     ht_oper, vht_oper,
 +						     he_oper, eht_oper,
 +						     s1g_oper,
 +						     &chandef, false);
 +
 +	sdata->needed_rx_chains = min(ieee80211_max_rx_chains(sdata, cbss),
 +				      local->rx_chains);
++=======
+ 	link->u.mgd.conn_flags |=
+ 		ieee80211_determine_chantype(link, sband,
+ 					     cbss->channel,
+ 					     bss->vht_cap_info,
+ 					     ht_oper, vht_oper,
+ 					     he_oper, eht_oper,
+ 					     s1g_oper,
+ 					     &chandef, false);
+ 
+ 	link->needed_rx_chains =
+ 		min(ieee80211_max_rx_chains(link, cbss), local->rx_chains);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	rcu_read_unlock();
  	/* the element data was RCU protected so no longer valid anyway */
  	kfree(elems);
  	elems = NULL;
  
++<<<<<<< HEAD
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HE && is_6ghz) {
++=======
+ 	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE && is_6ghz) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		sdata_info(sdata, "Rejecting non-HE 6/7 GHz connection");
  		return -EINVAL;
  	}
  
  	/* will change later if needed */
++<<<<<<< HEAD
 +	sdata->smps_mode = IEEE80211_SMPS_OFF;
++=======
+ 	link->smps_mode = IEEE80211_SMPS_OFF;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	mutex_lock(&local->mtx);
  	/*
@@@ -5526,8 -5608,8 +6257,13 @@@
  	 * on incompatible channels, e.g. 80+80 and 160 sharing the
  	 * same control channel) try to use a smaller bandwidth.
  	 */
++<<<<<<< HEAD
 +	ret = ieee80211_vif_use_channel(sdata, &chandef,
 +					IEEE80211_CHANCTX_SHARED);
++=======
+ 	ret = ieee80211_link_use_channel(link, &chandef,
+ 					 IEEE80211_CHANCTX_SHARED);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	/* don't downgrade for 5 and 10 MHz channels, though. */
  	if (chandef.width == NL80211_CHAN_WIDTH_5 ||
@@@ -5535,9 -5617,10 +6271,16 @@@
  		goto out;
  
  	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
++<<<<<<< HEAD
 +		ifmgd->flags |= ieee80211_chandef_downgrade(&chandef);
 +		ret = ieee80211_vif_use_channel(sdata, &chandef,
 +						IEEE80211_CHANCTX_SHARED);
++=======
+ 		link->u.mgd.conn_flags |=
+ 			ieee80211_chandef_downgrade(&chandef);
+ 		ret = ieee80211_link_use_channel(link, &chandef,
+ 						 IEEE80211_CHANCTX_SHARED);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
   out:
  	mutex_unlock(&local->mtx);
@@@ -5667,7 -5754,7 +6414,11 @@@ static int ieee80211_prep_connection(st
  		}
  
  		if (rates)
++<<<<<<< HEAD
 +			new_sta->sta.supp_rates[cbss->channel->band] = rates;
++=======
+ 			link_sta->supp_rates[cbss->channel->band] = rates;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		else
  			sdata_info(sdata,
  				   "No rates found, keeping mandatory only\n");
@@@ -5682,10 -5769,10 +6433,14 @@@
  			sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
  
  skip_rates:
++<<<<<<< HEAD
 +		memcpy(ifmgd->bssid, cbss->bssid, ETH_ALEN);
++=======
+ 		memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  		/* set timing information */
- 		sdata->vif.bss_conf.beacon_int = cbss->beacon_interval;
+ 		link->conf->beacon_int = cbss->beacon_interval;
  		rcu_read_lock();
  		ies = rcu_dereference(cbss->beacon_ies);
  		if (ies) {
@@@ -5726,9 -5813,10 +6481,16 @@@
  		 * tell driver about BSSID, basic rates and timing
  		 * this was set up above, before setting the channel
  		 */
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata,
 +			BSS_CHANGED_BSSID | BSS_CHANGED_BASIC_RATES |
 +			BSS_CHANGED_BEACON_INT);
++=======
+ 		ieee80211_link_info_change_notify(sdata, link,
+ 						  BSS_CHANGED_BSSID |
+ 						  BSS_CHANGED_BASIC_RATES |
+ 						  BSS_CHANGED_BEACON_INT);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  		if (assoc)
  			sta_info_pre_move_state(new_sta, IEEE80211_STA_AUTH);
@@@ -5742,7 -5830,7 +6504,11 @@@
  			return err;
  		}
  	} else
++<<<<<<< HEAD
 +		WARN_ON_ONCE(!ether_addr_equal(ifmgd->bssid, cbss->bssid));
++=======
+ 		WARN_ON_ONCE(!ether_addr_equal(link->u.mgd.bssid, cbss->bssid));
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	/* Cancel scan to ensure that nothing interferes with connection */
  	if (local->scanning)
@@@ -5893,11 -5982,12 +6660,17 @@@ int ieee80211_mgd_auth(struct ieee80211
  	return 0;
  
   err_clear:
++<<<<<<< HEAD
 +	eth_zero_addr(ifmgd->bssid);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 	eth_zero_addr(link->u.mgd.bssid);
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_BSSID);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	ifmgd->auth_data = NULL;
  	mutex_lock(&sdata->local->mtx);
 -	ieee80211_link_release_channel(&sdata->deflink);
 +	ieee80211_vif_release_channel(sdata);
  	mutex_unlock(&sdata->local->mtx);
  	kfree(auth_data);
  	return err;
@@@ -5914,8 -6004,9 +6687,9 @@@ int ieee80211_mgd_assoc(struct ieee8021
  	struct ieee80211_mgd_assoc_data *assoc_data;
  	const struct cfg80211_bss_ies *beacon_ies;
  	struct ieee80211_supported_band *sband;
 -	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
 +	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
  	const struct element *ssid_elem, *ht_elem, *vht_elem;
+ 	struct ieee80211_link_data *link = &sdata->deflink;
  	int i, err;
  	bool override = false;
  
@@@ -5972,7 -6064,7 +6746,11 @@@
  
  	/* prepare assoc data */
  
++<<<<<<< HEAD
 +	ifmgd->beacon_crc_valid = false;
++=======
+ 	link->u.mgd.beacon_crc_valid = false;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	assoc_data->wmm = bss->wmm_used &&
  			  (local->hw.queues >= IEEE80211_NUM_ACS);
@@@ -5988,10 -6080,10 +6766,17 @@@
  		if (req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP40 ||
  		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP ||
  		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP104) {
++<<<<<<< HEAD
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +			ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 			link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  			netdev_info(sdata->dev,
  				    "disabling HT/VHT/HE due to WEP/TKIP use\n");
  		}
@@@ -6001,10 -6093,10 +6786,17 @@@
  
  	/* also disable HT/VHT/HE/EHT if the AP doesn't use WMM */
  	if (!bss->wmm_used) {
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		netdev_info(sdata->dev,
  			    "disabling HT/VHT/HE as WMM/QoS is not supported by the AP\n");
  	}
@@@ -6052,7 -6144,7 +6844,11 @@@
  		assoc_data->ap_ht_param =
  			((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;
  	else if (!is_6ghz)
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	vht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_VHT_CAPABILITY);
  	if (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {
  		memcpy(&assoc_data->ap_vht_cap, vht_elem->data,
@@@ -6060,9 -6152,9 +6856,15 @@@
  	} else if (is_5ghz) {
  		sdata_info(sdata,
  			   "VHT capa missing/short, disabling VHT/HE/EHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT |
 +				IEEE80211_STA_DISABLE_HE |
 +				IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT |
+ 				IEEE80211_CONN_DISABLE_HE |
+ 				IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  	rcu_read_unlock();
  
@@@ -6110,11 -6202,11 +6912,19 @@@
  	/* kick off associate process */
  
  	ifmgd->assoc_data = assoc_data;
++<<<<<<< HEAD
 +	ifmgd->dtim_period = 0;
 +	ifmgd->have_beacon = false;
 +
 +	/* override HT/VHT configuration only if the AP and we support it */
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
++=======
+ 	link->u.mgd.dtim_period = 0;
+ 	link->u.mgd.have_beacon = false;
+ 
+ 	/* override HT/VHT configuration only if the AP and we support it */
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		struct ieee80211_sta_ht_cap sta_ht_cap;
  
  		if (req->flags & ASSOC_REQ_DISABLE_HT)
@@@ -6124,49 -6216,49 +6934,87 @@@
  		ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
  
  		/* check for 40 MHz disable override */
++<<<<<<< HEAD
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_40MHZ) &&
++=======
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_40MHZ) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		    sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&
  		    !(sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))
  			override = true;
  
++<<<<<<< HEAD
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT) &&
++=======
+ 		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		    req->flags & ASSOC_REQ_DISABLE_VHT)
  			override = true;
  	}
  
  	if (req->flags & ASSOC_REQ_DISABLE_HT) {
  		mlme_dbg(sdata, "HT disabled by flag, disabling HT/VHT/HE\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	if (req->flags & ASSOC_REQ_DISABLE_VHT) {
  		mlme_dbg(sdata, "VHT disabled by flag, disabling VHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	if (req->flags & ASSOC_REQ_DISABLE_HE) {
  		mlme_dbg(sdata, "HE disabled by flag, disabling HE/EHT\n");
++<<<<<<< HEAD
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE;
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
 +	}
 +
 +	if (req->flags & ASSOC_REQ_DISABLE_EHT)
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_EHT;
++=======
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE;
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+ 	}
+ 
+ 	if (req->flags & ASSOC_REQ_DISABLE_EHT)
+ 		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_EHT;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  
  	err = ieee80211_prep_connection(sdata, req->bss, true, override);
  	if (err)
  		goto err_clear;
  
++<<<<<<< HEAD
 +	if (ifmgd->req_smps == IEEE80211_SMPS_AUTOMATIC) {
 +		if (ifmgd->powersave)
 +			sdata->smps_mode = IEEE80211_SMPS_DYNAMIC;
 +		else
 +			sdata->smps_mode = IEEE80211_SMPS_OFF;
 +	} else {
 +		sdata->smps_mode = ifmgd->req_smps;
++=======
+ 	if (link->u.mgd.req_smps == IEEE80211_SMPS_AUTOMATIC) {
+ 		if (ifmgd->powersave)
+ 			link->smps_mode = IEEE80211_SMPS_DYNAMIC;
+ 		else
+ 			link->smps_mode = IEEE80211_SMPS_OFF;
+ 	} else {
+ 		link->smps_mode = link->u.mgd.req_smps;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	}
  
  	rcu_read_lock();
@@@ -6179,7 -6271,7 +7027,11 @@@
  		 * should this be more if we miss one?
  		 */
  		sdata_info(sdata, "waiting for beacon from %pM\n",
++<<<<<<< HEAD
 +			   ifmgd->bssid);
++=======
+ 			   link->u.mgd.bssid);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
  		assoc_data->timeout_started = true;
  		assoc_data->need_beacon = true;
@@@ -6188,9 -6280,9 +7040,15 @@@
  		u8 dtim_count = 0;
  
  		ieee80211_get_dtim(beacon_ies, &dtim_count,
++<<<<<<< HEAD
 +				   &ifmgd->dtim_period);
 +
 +		ifmgd->have_beacon = true;
++=======
+ 				   &link->u.mgd.dtim_period);
+ 
+ 		link->u.mgd.have_beacon = true;
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  		assoc_data->timeout = jiffies;
  		assoc_data->timeout_started = true;
  
@@@ -6239,8 -6331,9 +7097,14 @@@
  
  	return 0;
   err_clear:
++<<<<<<< HEAD
 +	eth_zero_addr(ifmgd->bssid);
 +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
++=======
+ 	eth_zero_addr(link->u.mgd.bssid);
+ 	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
+ 					  BSS_CHANGED_BSSID);
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  	ifmgd->assoc_data = NULL;
   err_free:
  	kfree(assoc_data);
@@@ -6346,6 -6436,12 +7210,15 @@@ int ieee80211_mgd_disassoc(struct ieee8
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void ieee80211_mgd_stop_link(struct ieee80211_link_data *link)
+ {
+ 	cancel_work_sync(&link->u.mgd.request_smps_work);
+ 	cancel_work_sync(&link->u.mgd.chswitch_work);
+ }
+ 
++>>>>>>> 5bd5666d8ad8 (wifi: mac80211: mlme: first adjustments for MLO)
  void ieee80211_mgd_stop(struct ieee80211_sub_if_data *sdata)
  {
  	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
@@@ -6357,9 -6453,7 +7230,8 @@@
  	 */
  	cancel_work_sync(&ifmgd->monitor_work);
  	cancel_work_sync(&ifmgd->beacon_connection_loss_work);
 +	cancel_work_sync(&ifmgd->request_smps_work);
  	cancel_work_sync(&ifmgd->csa_connection_drop_work);
- 	cancel_work_sync(&ifmgd->chswitch_work);
  	cancel_delayed_work_sync(&ifmgd->tdls_peer_del_work);
  
  	sdata_lock(sdata);
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index 37035c3e5f8a..5555f65e527f 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -1084,7 +1084,7 @@ ieee80211_vif_chanctx_reservation_complete(struct ieee80211_sub_if_data *sdata)
 		break;
 	case NL80211_IFTYPE_STATION:
 		ieee80211_queue_work(&sdata->local->hw,
-				     &sdata->u.mgd.chswitch_work);
+				     &link->u.mgd.chswitch_work);
 		break;
 	case NL80211_IFTYPE_UNSPECIFIED:
 	case NL80211_IFTYPE_AP_VLAN:
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/mlme.c
