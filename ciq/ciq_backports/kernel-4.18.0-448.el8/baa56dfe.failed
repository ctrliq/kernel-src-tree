wifi: cfg80211: Fix validating BSS pointers in __cfg80211_connect_result

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Veerendranath Jakkam <quic_vjakkam@quicinc.com>
commit baa56dfe2cdad12edb2625b2d454e205943c3402
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/baa56dfe.failed

Driver's SME is allowed to fill either BSSID or BSS pointers in struct
cfg80211_connect_resp_params when indicating connect response but a
check in __cfg80211_connect_result() is giving unnecessary warning when
driver's SME fills only BSSID pointer and not BSS pointer in struct
cfg80211_connect_resp_params.

In case of mac80211 with auth/assoc path, it is always expected to fill
BSS pointers in struct cfg80211_connect_resp_params when calling
__cfg80211_connect_result() since cfg80211 must have hold BSS pointers
in cfg80211_mlme_assoc().

So, skip the check for the drivers which support cfg80211 connect
callback, for example with brcmfmac is one such driver which had the
warning:

WARNING: CPU: 5 PID: 514 at net/wireless/sme.c:786 __cfg80211_connect_result+0x2fc/0x5c0 [cfg80211]

	Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
Fixes: efbabc116500 ("cfg80211: Indicate MLO connection info in connect and roam callbacks")
	Signed-off-by: Veerendranath Jakkam <quic_vjakkam@quicinc.com>
[kvalo@kernel.org: add more info to the commit log]
	Signed-off-by: Kalle Valo <kvalo@kernel.org>
Link: https://lore.kernel.org/r/20220805135259.4126630-1-quic_vjakkam@quicinc.com
(cherry picked from commit baa56dfe2cdad12edb2625b2d454e205943c3402)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/sme.c
diff --cc net/wireless/sme.c
index 787e015cc122,27fb2a0c4052..000000000000
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@@ -735,21 -781,34 +735,49 @@@ void __cfg80211_connect_result(struct n
  	}
  #endif
  
++<<<<<<< HEAD
 +	if (!cr->bss && (cr->status == WLAN_STATUS_SUCCESS)) {
 +		WARN_ON_ONCE(!wiphy_to_rdev(wdev->wiphy)->ops->connect);
 +		cr->bss = cfg80211_get_bss(wdev->wiphy, NULL, cr->bssid,
 +					   wdev->ssid, wdev->ssid_len,
 +					   wdev->conn_bss_type,
 +					   IEEE80211_PRIVACY_ANY);
 +		if (cr->bss)
 +			cfg80211_hold_bss(bss_from_pub(cr->bss));
++=======
+ 	if (cr->status == WLAN_STATUS_SUCCESS) {
+ 		if (!wiphy_to_rdev(wdev->wiphy)->ops->connect) {
+ 			for_each_valid_link(cr, link) {
+ 				if (WARN_ON_ONCE(!cr->links[link].bss))
+ 					break;
+ 			}
+ 		}
+ 
+ 		for_each_valid_link(cr, link) {
+ 			if (cr->links[link].bss)
+ 				continue;
+ 
+ 			cr->links[link].bss =
+ 				cfg80211_get_bss(wdev->wiphy, NULL,
+ 						 cr->links[link].bssid,
+ 						 wdev->u.client.ssid,
+ 						 wdev->u.client.ssid_len,
+ 						 wdev->conn_bss_type,
+ 						 IEEE80211_PRIVACY_ANY);
+ 			if (!cr->links[link].bss) {
+ 				bss_not_found = true;
+ 				break;
+ 			}
+ 			cfg80211_hold_bss(bss_from_pub(cr->links[link].bss));
+ 		}
++>>>>>>> baa56dfe2cda (wifi: cfg80211: Fix validating BSS pointers in __cfg80211_connect_result)
  	}
  
 -	cfg80211_wdev_release_bsses(wdev);
 +	if (wdev->current_bss) {
 +		cfg80211_unhold_bss(wdev->current_bss);
 +		cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
 +		wdev->current_bss = NULL;
 +	}
  
  	if (cr->status != WLAN_STATUS_SUCCESS) {
  		kfree_sensitive(wdev->connect_keys);
* Unmerged path net/wireless/sme.c
