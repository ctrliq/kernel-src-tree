s390/pci: move zpci_remove_device() to bus code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 95b3a8b4014d82e79dc3ad03a1f8d6ee5f56b29d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/95b3a8b4.failed

The zpci_remove_device() function removes the device from the PCI common
code core which is an operation dealing primarily with the zbus and PCI
bus code. With that and to match an upcoming refactoring of the
symmetric scanning part move it to the bus code.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 95b3a8b4014d82e79dc3ad03a1f8d6ee5f56b29d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/include/asm/pci.h
index 37481081a26c,35dec33c2801..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -201,12 -200,11 +201,16 @@@ extern unsigned int s390_pci_no_rid
    Prototypes
  ----------------------------------------------------------------------------- */
  /* Base stuff */
++<<<<<<< HEAD
 +int zpci_create_device(struct zpci_dev *);
 +void zpci_remove_device(struct zpci_dev *zdev);
++=======
+ int zpci_create_device(u32 fid, u32 fh, enum zpci_state state);
++>>>>>>> 95b3a8b4014d (s390/pci: move zpci_remove_device() to bus code)
  int zpci_enable_device(struct zpci_dev *);
  int zpci_disable_device(struct zpci_dev *);
 -int zpci_configure_device(struct zpci_dev *zdev, u32 fh);
 -int zpci_deconfigure_device(struct zpci_dev *zdev);
 +void zpci_device_reserved(struct zpci_dev *zdev);
 +bool zpci_is_device_configured(struct zpci_dev *zdev);
  
  int zpci_register_ioat(struct zpci_dev *, u8, u64, u64, u64);
  int zpci_unregister_ioat(struct zpci_dev *, u8);
diff --cc arch/s390/pci/pci.c
index 6af47e2fa8a9,dd14641b2d20..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -721,30 -678,40 +721,45 @@@ int zpci_disable_device(struct zpci_de
  	 */
  	return clp_disable_fh(zdev);
  }
 +EXPORT_SYMBOL_GPL(zpci_disable_device);
 +
++<<<<<<< HEAD
 +void zpci_remove_device(struct zpci_dev *zdev)
 +{
 +	struct zpci_bus *zbus = zdev->zbus;
 +	struct pci_dev *pdev;
 +
 +	pdev = pci_get_slot(zbus->bus, zdev->devfn);
 +	if (pdev) {
 +		if (pdev->is_virtfn)
 +			return zpci_remove_virtfn(pdev, zdev->vfn);
 +		pci_stop_and_remove_bus_device_locked(pdev);
 +	}
 +}
  
 +int zpci_create_device(struct zpci_dev *zdev)
++=======
+ /**
+  * zpci_create_device() - Create a new zpci_dev and add it to the zbus
+  * @fid: Function ID of the device to be created
+  * @fh: Current Function Handle of the device to be created
+  * @state: Initial state after creation either Standby or Configured
+  *
+  * Creates a new zpci device and adds it to its, possibly newly created, zbus
+  * as well as zpci_list.
+  *
+  * Returns: 0 on success, an error value otherwise
+  */
+ int zpci_create_device(u32 fid, u32 fh, enum zpci_state state)
++>>>>>>> 95b3a8b4014d (s390/pci: move zpci_remove_device() to bus code)
  {
 -	struct zpci_dev *zdev;
  	int rc;
  
 -	zpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, state);
 -	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
 -	if (!zdev)
 -		return -ENOMEM;
 -
 -	/* FID and Function Handle are the static/dynamic identifiers */
 -	zdev->fid = fid;
 -	zdev->fh = fh;
 -
 -	/* Query function properties and update zdev */
 -	rc = clp_query_pci_fn(zdev);
 -	if (rc)
 -		goto error;
 -	zdev->state =  state;
 -
  	kref_init(&zdev->kref);
 -	mutex_init(&zdev->lock);
 +
 +	spin_lock(&zpci_list_lock);
 +	list_add_tail(&zdev->entry, &zpci_list);
 +	spin_unlock(&zpci_list_lock);
  
  	rc = zpci_init_iommu(zdev);
  	if (rc)
@@@ -776,51 -744,109 +791,63 @@@ out
  	return rc;
  }
  
 -/**
 - * zpci_configure_device() - Configure a zpci_dev
 - * @zdev: The zpci_dev to be configured
 - * @fh: The general function handle supplied by the platform
 - *
 - * Configuring a device includes the configuration itself, if not done by the
 - * platform, enabling, scanning and adding it to the common code PCI subsystem.
 - * If any failure occurs, the zpci_dev is left in Standby.
 - *
 - * Return: 0 on success, or an error code otherwise
 - */
 -int zpci_configure_device(struct zpci_dev *zdev, u32 fh)
 +bool zpci_is_device_configured(struct zpci_dev *zdev)
  {
 -	struct pci_dev *pdev;
 -	int rc;
 +	enum zpci_state state = zdev->state;
  
 -	zdev->fh = fh;
 -	if (zdev->state != ZPCI_FN_STATE_CONFIGURED) {
 -		rc = sclp_pci_configure(zdev->fid);
 -		zpci_dbg(3, "conf fid:%x, rc:%d\n", zdev->fid, rc);
 -		if (rc)
 -			return rc;
 -		zdev->state = ZPCI_FN_STATE_CONFIGURED;
 -	}
 -
 -	rc = zpci_enable_device(zdev);
 -	if (rc)
 -		goto error;
 -
 -	/* the PCI function will be scanned once function 0 appears */
 -	if (!zdev->zbus->bus)
 -		return 0;
 -
 -	pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
 -	if (!pdev)
 -		goto error_disable;
 -
 -	pci_bus_add_device(pdev);
 -	pci_lock_rescan_remove();
 -	pci_bus_add_devices(zdev->zbus->bus);
 -	pci_unlock_rescan_remove();
 -	return 0;
 -
 -error_disable:
 -	zpci_disable_device(zdev);
 -error:
 -	if (zdev->state == ZPCI_FN_STATE_CONFIGURED) {
 -		rc = sclp_pci_deconfigure(zdev->fid);
 -		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, rc);
 -		if (!rc)
 -			zdev->state = ZPCI_FN_STATE_STANDBY;
 -	}
 -	return rc;
++<<<<<<< HEAD
 +	return state != ZPCI_FN_STATE_RESERVED &&
 +		state != ZPCI_FN_STATE_STANDBY;
  }
++=======
++	if (zdev->zbus->bus)
++		zpci_bus_remove_device(zdev, false);
++>>>>>>> 95b3a8b4014d (s390/pci: move zpci_remove_device() to bus code)
  
  /**
 - * zpci_deconfigure_device() - Deconfigure a zpci_dev
 - * @zdev: The zpci_dev to configure
 + * zpci_device_reserved() - Mark device as resverved
 + * @zdev: the zpci_dev that was reserved
   *
 - * Deconfigure a zPCI function that is currently configured and possibly known
 - * to the common code PCI subsystem.
 - * If any failure occurs the device is left as is.
 - *
 - * Return: 0 on success, or an error code otherwise
 + * Handle the case that a given zPCI function was reserved by another system.
 + * After a call to this function the zpci_dev can not be found via
 + * get_zdev_by_fid() anymore but may still be accessible via existing
 + * references though it will not be functional anymore.
   */
 -int zpci_deconfigure_device(struct zpci_dev *zdev)
 +void zpci_device_reserved(struct zpci_dev *zdev)
  {
 -	int rc;
 -
 -	if (zdev->zbus->bus)
 -		zpci_bus_remove_device(zdev, false);
 -
 -	if (zdev_enabled(zdev)) {
 -		rc = zpci_disable_device(zdev);
 -		if (rc)
 -			return rc;
 -	}
 -
 -	rc = sclp_pci_deconfigure(zdev->fid);
 -	zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, rc);
 -	if (rc)
 -		return rc;
 -	zdev->state = ZPCI_FN_STATE_STANDBY;
 -
 -	return 0;
 +	if (zdev->has_hp_slot)
 +		zpci_exit_slot(zdev);
 +	/*
 +	 * Remove device from zpci_list as it is going away. This also
 +	 * makes sure we ignore subsequent zPCI events for this device.
 +	 */
 +	spin_lock(&zpci_list_lock);
 +	list_del(&zdev->entry);
 +	spin_unlock(&zpci_list_lock);
 +	zdev->state = ZPCI_FN_STATE_RESERVED;
 +	zpci_dbg(3, "rsv fid:%x\n", zdev->fid);
 +	zpci_zdev_put(zdev);
  }
  
  void zpci_release_device(struct kref *kref)
  {
  	struct zpci_dev *zdev = container_of(kref, struct zpci_dev, kref);
 -	int ret;
  
  	if (zdev->zbus->bus)
++<<<<<<< HEAD
 +		zpci_remove_device(zdev);
++=======
+ 		zpci_bus_remove_device(zdev, false);
+ 
+ 	if (zdev_enabled(zdev))
+ 		zpci_disable_device(zdev);
++>>>>>>> 95b3a8b4014d (s390/pci: move zpci_remove_device() to bus code)
  
  	switch (zdev->state) {
 +	case ZPCI_FN_STATE_ONLINE:
  	case ZPCI_FN_STATE_CONFIGURED:
 -		ret = sclp_pci_deconfigure(zdev->fid);
 -		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
 -		fallthrough;
 +		zpci_disable_device(zdev);
 +		/* fallthrough */
  	case ZPCI_FN_STATE_STANDBY:
  		if (zdev->has_hp_slot)
  			zpci_exit_slot(zdev);
diff --cc arch/s390/pci/pci_event.c
index 4b2bb5dfb29a,9455c5be8820..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -73,6 -73,28 +73,31 @@@ void zpci_event_error(void *data
  		__zpci_event_error(data);
  }
  
++<<<<<<< HEAD
++=======
+ static void zpci_event_hard_deconfigured(struct zpci_dev *zdev, u32 fh)
+ {
+ 	enum zpci_state state;
+ 	int rc;
+ 
+ 	zdev->fh = fh;
+ 	/* Give the driver a hint that the function is
+ 	 * already unusable.
+ 	 */
+ 	zpci_bus_remove_device(zdev, true);
+ 	if (zdev_enabled(zdev)) {
+ 		rc = zpci_disable_device(zdev);
+ 		if (rc)
+ 			return;
+ 	}
+ 	zdev->state = ZPCI_FN_STATE_STANDBY;
+ 	if (!clp_get_state(zdev->fid, &state) &&
+ 	    state == ZPCI_FN_STATE_RESERVED) {
+ 		zpci_zdev_put(zdev);
+ 	}
+ }
+ 
++>>>>>>> 95b3a8b4014d (s390/pci: move zpci_remove_device() to bus code)
  static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
  {
  	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
* Unmerged path arch/s390/include/asm/pci.h
* Unmerged path arch/s390/pci/pci.c
diff --git a/arch/s390/pci/pci_bus.c b/arch/s390/pci/pci_bus.c
index c93486a9989b..bb0fa0e697f4 100644
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@ -29,6 +29,39 @@ static LIST_HEAD(zbus_list);
 static DEFINE_SPINLOCK(zbus_list_lock);
 static int zpci_nb_devices;
 
+/* zpci_bus_remove_device - Removes the given zdev from the PCI core
+ * @zdev: the zdev to be removed from the PCI core
+ * @set_error: if true the device's error state is set to permanent failure
+ *
+ * Sets a zPCI device to a configured but offline state; the zPCI
+ * device is still accessible through its hotplug slot and the zPCI
+ * API but is removed from the common code PCI bus, making it
+ * no longer available to drivers.
+ */
+void zpci_bus_remove_device(struct zpci_dev *zdev, bool set_error)
+{
+	struct zpci_bus *zbus = zdev->zbus;
+	struct pci_dev *pdev;
+
+	if (!zdev->zbus->bus)
+		return;
+
+	pdev = pci_get_slot(zbus->bus, zdev->devfn);
+	if (pdev) {
+		if (set_error)
+			pdev->error_state = pci_channel_io_perm_failure;
+		if (pdev->is_virtfn) {
+			zpci_iov_remove_virtfn(pdev, zdev->vfn);
+			/* balance pci_get_slot */
+			pci_dev_put(pdev);
+			return;
+		}
+		pci_stop_and_remove_bus_device_locked(pdev);
+		/* balance pci_get_slot */
+		pci_dev_put(pdev);
+	}
+}
+
 /* zpci_bus_scan
  * @zbus: the zbus holding the zdevices
  * @ops: the pci operations
diff --git a/arch/s390/pci/pci_bus.h b/arch/s390/pci/pci_bus.h
index 8808ff0835b8..66c7cc75483e 100644
--- a/arch/s390/pci/pci_bus.h
+++ b/arch/s390/pci/pci_bus.h
@@ -11,6 +11,8 @@ int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops);
 void zpci_bus_device_unregister(struct zpci_dev *zdev);
 int zpci_bus_init(void);
 
+void zpci_bus_remove_device(struct zpci_dev *zdev, bool set_error);
+
 void zpci_release_device(struct kref *kref);
 static inline void zpci_zdev_put(struct zpci_dev *zdev)
 {
* Unmerged path arch/s390/pci/pci_event.c
