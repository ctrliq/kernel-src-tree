ASoC: SOF: ipc4-topology: Add support for parsing AIF_IN/AIF_OUT widgets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 2cabd02b60901f4ceda4daf8c194905259797702
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/2cabd02b.failed

Add support for parsing AIF_IN/AIF_OUT type widgets in IPC4. Add all the
new required token ID's for parsing these widgets to the list of tokens in
enum sof_tokens and the definitions of the token arrays corresponding to
each of the token ID's.

Also, upgrade the sof_widget_parse_tokens() function in the common
topology parser to be able to parse multiple sets of tokens for the
audio format and copier gateway config tokens.

Co-developed-by: Rander Wang <rander.wang@linux.intel.com>
	Signed-off-by: Rander Wang <rander.wang@linux.intel.com>
Co-developed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Paul Olaru <paul.olaru@oss.nxp.com>
Link: https://lore.kernel.org/r/20220609032643.916882-4-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 2cabd02b60901f4ceda4daf8c194905259797702)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc4-topology.c
#	sound/soc/sof/ipc4-topology.h
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/topology.c
index 9d9e8416c0b0,606dbca94246..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -1698,274 -1141,112 +1698,364 @@@ static int spcm_bind(struct snd_soc_com
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * PCM Topology
 + */
 +
 +static int sof_widget_load_pcm(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       enum sof_ipc_stream_direction dir,
 +			       struct snd_soc_tplg_dapm_widget *tw)
++=======
+ static int sof_get_token_value(u32 token_id, struct snd_sof_tuple *tuples, int num_tuples)
+ {
+ 	int i;
+ 
+ 	if (!tuples)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < num_tuples; i++) {
+ 		if (tuples[i].token == token_id)
+ 			return tuples[i].value.v;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int sof_widget_parse_tokens(struct snd_soc_component *scomp, struct snd_sof_widget *swidget,
+ 				   struct snd_soc_tplg_dapm_widget *tw,
+ 				   enum sof_tokens *object_token_list, int count)
++>>>>>>> 2cabd02b6090 (ASoC: SOF: ipc4-topology: Add support for parsing AIF_IN/AIF_OUT widgets)
  {
 -	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 -	const struct sof_ipc_tplg_ops *ipc_tplg_ops = sdev->ipc->ops->tplg;
 -	const struct sof_token_info *token_list = ipc_tplg_ops->token_list;
  	struct snd_soc_tplg_private *private = &tw->priv;
 -	int num_tuples = 0;
 -	int ret, i;
 +	struct sof_ipc_comp_host *host;
 +	size_t ipc_size = sizeof(*host);
 +	int ret;
  
 -	if (count > 0 && !object_token_list) {
 -		dev_err(scomp->dev, "No token list for widget %s\n", swidget->widget->name);
 -		return -EINVAL;
 +	host = (struct sof_ipc_comp_host *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!host)
 +		return -ENOMEM;
 +
++<<<<<<< HEAD
 +	/* configure host comp IPC message */
 +	host->comp.type = SOF_COMP_HOST;
 +	host->direction = dir;
 +	host->config.hdr.size = sizeof(host->config);
 +
 +	ret = sof_parse_tokens(scomp, host, pcm_tokens,
 +			       ARRAY_SIZE(pcm_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse host tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &host->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse host.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "loaded host %s\n", swidget->widget->name);
 +	sof_dbg_comp_config(scomp, &host->config);
 +
 +	swidget->private = host;
 +
 +	return 0;
 +err:
 +	kfree(host);
 +	return ret;
 +}
 +
 +/*
 + * Pipeline Topology
 + */
 +static int sof_widget_load_pipeline(struct snd_soc_component *scomp, int index,
 +				    struct snd_sof_widget *swidget,
 +				    struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_pipe_new *pipeline;
 +	struct snd_sof_widget *comp_swidget;
 +	int ret;
 +
 +	pipeline = kzalloc(sizeof(*pipeline), GFP_KERNEL);
 +	if (!pipeline)
 +		return -ENOMEM;
 +
 +	/* configure dai IPC message */
 +	pipeline->hdr.size = sizeof(*pipeline);
 +	pipeline->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_NEW;
 +	pipeline->pipeline_id = index;
 +	pipeline->comp_id = swidget->comp_id;
 +
 +	/* component at start of pipeline is our stream id */
 +	comp_swidget = snd_sof_find_swidget(scomp, tw->sname);
 +	if (!comp_swidget) {
 +		dev_err(scomp->dev, "error: widget %s refers to non existent widget %s\n",
 +			tw->name, tw->sname);
 +		ret = -EINVAL;
 +		goto err;
 +	}
 +
 +	pipeline->sched_id = comp_swidget->comp_id;
 +
 +	dev_dbg(scomp->dev, "tplg: pipeline id %d comp %d scheduling comp id %d\n",
 +		pipeline->pipeline_id, pipeline->comp_id, pipeline->sched_id);
 +
 +	ret = sof_parse_tokens(scomp, pipeline, sched_tokens,
 +			       ARRAY_SIZE(sched_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse pipeline tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, swidget, pipeline_tokens,
 +			       ARRAY_SIZE(pipeline_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dynamic pipeline token failed %d\n",
 +			private->size);
 +		goto err;
  	}
  
 -	/* calculate max size of tuples array */
 -	for (i = 0; i < count; i++)
 -		num_tuples += token_list[object_token_list[i]].count;
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		pipeline->core = SOF_DSP_PRIMARY_CORE;
  
 -	/* allocate memory for tuples array */
 -	swidget->tuples = kcalloc(num_tuples, sizeof(*swidget->tuples), GFP_KERNEL);
 -	if (!swidget->tuples)
 +	if (sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_OVERRIDE))
 +		swidget->dynamic_pipeline_widget =
 +			sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_ENABLE);
 +
 +	dev_dbg(scomp->dev, "pipeline %s: period %d pri %d mips %d core %d frames %d dynamic %d\n",
 +		swidget->widget->name, pipeline->period, pipeline->priority,
 +		pipeline->period_mips, pipeline->core, pipeline->frames_per_sched,
 +		swidget->dynamic_pipeline_widget);
 +
 +	swidget->core = pipeline->core;
 +	swidget->private = pipeline;
 +
 +	return 0;
 +err:
 +	kfree(pipeline);
 +	return ret;
 +}
 +
 +/*
 + * Mixer topology
 + */
 +
 +static int sof_widget_load_mixer(struct snd_soc_component *scomp, int index,
 +				 struct snd_sof_widget *swidget,
 +				 struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_mixer *mixer;
 +	size_t ipc_size = sizeof(*mixer);
 +	int ret;
 +
 +	mixer = (struct sof_ipc_comp_mixer *)
 +		sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!mixer)
 +		return -ENOMEM;
 +
 +	/* configure mixer IPC message */
 +	mixer->comp.type = SOF_COMP_MIXER;
 +	mixer->config.hdr.size = sizeof(mixer->config);
 +
 +	ret = sof_parse_tokens(scomp, &mixer->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse mixer.cfg tokens failed %d\n",
 +			private->size);
 +		kfree(mixer);
 +		return ret;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &mixer->config);
 +
 +	swidget->private = mixer;
 +
 +	return 0;
 +}
 +
 +/*
 + * Mux topology
 + */
 +static int sof_widget_load_mux(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_mux *mux;
 +	size_t ipc_size = sizeof(*mux);
 +	int ret;
 +
 +	mux = (struct sof_ipc_comp_mux *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!mux)
 +		return -ENOMEM;
 +
 +	/* configure mux IPC message */
 +	mux->comp.type = SOF_COMP_MUX;
 +	mux->config.hdr.size = sizeof(mux->config);
 +
 +	ret = sof_parse_tokens(scomp, &mux->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse mux.cfg tokens failed %d\n",
 +			private->size);
 +		kfree(mux);
 +		return ret;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &mux->config);
 +
 +	swidget->private = mux;
 +
 +	return 0;
 +}
 +
 +/*
 + * PGA Topology
 + */
 +
 +static int sof_widget_load_pga(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_volume *volume;
 +	struct snd_sof_control *scontrol;
 +	size_t ipc_size = sizeof(*volume);
 +	int min_step;
 +	int max_step;
 +	int ret;
 +
 +	volume = (struct sof_ipc_comp_volume *)
 +		 sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!volume)
  		return -ENOMEM;
  
 +	if (!le32_to_cpu(tw->num_kcontrols)) {
 +		dev_err(scomp->dev, "error: invalid kcontrol count %d for volume\n",
 +			tw->num_kcontrols);
 +		ret = -EINVAL;
 +		goto err;
 +	}
 +
 +	/* configure volume IPC message */
 +	volume->comp.type = SOF_COMP_VOLUME;
 +	volume->config.hdr.size = sizeof(volume->config);
 +
 +	ret = sof_parse_tokens(scomp, volume, volume_tokens,
 +			       ARRAY_SIZE(volume_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +	ret = sof_parse_tokens(scomp, &volume->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &volume->config);
 +
 +	swidget->private = volume;
 +
 +	list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
 +		if (scontrol->comp_id == swidget->comp_id &&
 +		    scontrol->volume_table) {
 +			min_step = scontrol->min_volume_step;
 +			max_step = scontrol->max_volume_step;
 +			volume->min_value = scontrol->volume_table[min_step];
 +			volume->max_value = scontrol->volume_table[max_step];
 +			volume->channels = scontrol->num_channels;
 +			break;
++=======
+ 	/* parse token list for widget */
+ 	for (i = 0; i < count; i++) {
+ 		int num_sets = 1;
+ 
+ 		if (object_token_list[i] >= SOF_TOKEN_COUNT) {
+ 			dev_err(scomp->dev, "Invalid token id %d for widget %s\n",
+ 				object_token_list[i], swidget->widget->name);
+ 			ret = -EINVAL;
+ 			goto err;
+ 		}
+ 
+ 		switch (object_token_list[i]) {
+ 		case SOF_COMP_EXT_TOKENS:
+ 			/* parse and save UUID in swidget */
+ 			ret = sof_parse_tokens(scomp, swidget,
+ 					       token_list[object_token_list[i]].tokens,
+ 					       token_list[object_token_list[i]].count,
+ 					       private->array, le32_to_cpu(private->size));
+ 			if (ret < 0) {
+ 				dev_err(scomp->dev, "Failed parsing %s for widget %s\n",
+ 					token_list[object_token_list[i]].name,
+ 					swidget->widget->name);
+ 				goto err;
+ 			}
+ 
+ 			continue;
+ 		case SOF_IN_AUDIO_FORMAT_TOKENS:
+ 		case SOF_OUT_AUDIO_FORMAT_TOKENS:
+ 		case SOF_COPIER_GATEWAY_CFG_TOKENS:
+ 		case SOF_AUDIO_FORMAT_BUFFER_SIZE_TOKENS:
+ 			num_sets = sof_get_token_value(SOF_TKN_COMP_NUM_AUDIO_FORMATS,
+ 						       swidget->tuples, swidget->num_tuples);
+ 
+ 			if (num_sets < 0) {
+ 				dev_err(sdev->dev, "Invalid audio format count for %s\n",
+ 					swidget->widget->name);
+ 				ret = num_sets;
+ 				goto err;
+ 			}
+ 
+ 			if (num_sets > 1) {
+ 				struct snd_sof_tuple *new_tuples;
+ 
+ 				num_tuples += token_list[object_token_list[i]].count * num_sets;
+ 				new_tuples = krealloc(swidget->tuples,
+ 						      sizeof(*new_tuples) * num_tuples, GFP_KERNEL);
+ 				if (!new_tuples) {
+ 					ret = -ENOMEM;
+ 					goto err;
+ 				}
+ 
+ 				swidget->tuples = new_tuples;
+ 			}
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 
+ 		/* copy one set of tuples per token ID into swidget->tuples */
+ 		ret = sof_copy_tuples(sdev, private->array, le32_to_cpu(private->size),
+ 				      object_token_list[i], num_sets, swidget->tuples,
+ 				      num_tuples, &swidget->num_tuples);
+ 		if (ret < 0) {
+ 			dev_err(scomp->dev, "Failed parsing %s for widget %s err: %d\n",
+ 				token_list[object_token_list[i]].name, swidget->widget->name, ret);
+ 			goto err;
++>>>>>>> 2cabd02b6090 (ASoC: SOF: ipc4-topology: Add support for parsing AIF_IN/AIF_OUT widgets)
  		}
  	}
  
@@@ -1975,109 -1256,138 +2065,110 @@@ err
  	return ret;
  }
  
 -/* external widget init - used for any driver specific init */
 -static int sof_widget_ready(struct snd_soc_component *scomp, int index,
 -			    struct snd_soc_dapm_widget *w,
 -			    struct snd_soc_tplg_dapm_widget *tw)
++<<<<<<< HEAD
 +/*
 + * SRC Topology
 + */
 +
 +static int sof_widget_load_src(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
  {
 -	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 -	const struct sof_ipc_tplg_ops *ipc_tplg_ops = sdev->ipc->ops->tplg;
 -	const struct sof_ipc_tplg_widget_ops *widget_ops = ipc_tplg_ops->widget;
 -	struct snd_sof_widget *swidget;
 -	struct snd_sof_dai *dai;
 -	enum sof_tokens *token_list;
 -	int token_list_size;
 -	int ret = 0;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_src *src;
 +	size_t ipc_size = sizeof(*src);
 +	int ret;
  
 -	swidget = kzalloc(sizeof(*swidget), GFP_KERNEL);
 -	if (!swidget)
 +	src = (struct sof_ipc_comp_src *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!src)
  		return -ENOMEM;
  
 -	swidget->scomp = scomp;
 -	swidget->widget = w;
 -	swidget->comp_id = sdev->next_comp_id++;
 -	swidget->complete = 0;
 -	swidget->id = w->id;
 -	swidget->pipeline_id = index;
 -	swidget->private = NULL;
 +	/* configure src IPC message */
 +	src->comp.type = SOF_COMP_SRC;
 +	src->config.hdr.size = sizeof(src->config);
  
 -	dev_dbg(scomp->dev, "tplg: ready widget id %d pipe %d type %d name : %s stream %s\n",
 -		swidget->comp_id, index, swidget->id, tw->name,
 -		strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 -			? tw->sname : "none");
 +	ret = sof_parse_tokens(scomp, src, src_tokens,
 +			       ARRAY_SIZE(src_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
  
 -	token_list = widget_ops[w->id].token_list;
 -	token_list_size = widget_ops[w->id].token_list_size;
 +	ret = sof_parse_tokens(scomp, &src->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
  
 -	/* handle any special case widgets */
 -	switch (w->id) {
 -	case snd_soc_dapm_dai_in:
 -	case snd_soc_dapm_dai_out:
 -		dai = kzalloc(sizeof(*dai), GFP_KERNEL);
 -		if (!dai) {
 -			kfree(swidget);
 -			return -ENOMEM;
 +	dev_dbg(scomp->dev, "src %s: source rate %d sink rate %d\n",
 +		swidget->widget->name, src->source_rate, src->sink_rate);
 +	sof_dbg_comp_config(scomp, &src->config);
  
 -		}
 +	swidget->private = src;
  
 -		ret = sof_widget_parse_tokens(scomp, swidget, tw, token_list, token_list_size);
 -		if (!ret)
 -			ret = sof_connect_dai_widget(scomp, w, tw, dai);
 -		if (ret < 0) {
 -			kfree(dai);
 -			break;
 -		}
 -		list_add(&dai->list, &sdev->dai_list);
 -		swidget->private = dai;
 -		break;
 -	case snd_soc_dapm_effect:
 -		/* check we have some tokens - we need at least process type */
 -		if (le32_to_cpu(tw->priv.size) == 0) {
 -			dev_err(scomp->dev, "error: process tokens not found\n");
 -			ret = -EINVAL;
 -			break;
 -		}
 -		ret = sof_widget_parse_tokens(scomp, swidget, tw, token_list, token_list_size);
 -		break;
 -	case snd_soc_dapm_pga:
 -		if (!le32_to_cpu(tw->num_kcontrols)) {
 -			dev_err(scomp->dev, "invalid kcontrol count %d for volume\n",
 -				tw->num_kcontrols);
 -			ret = -EINVAL;
 -			break;
 -		}
 +	return 0;
 +err:
 +	kfree(src);
 +	return ret;
 +}
  
 -		fallthrough;
 -	case snd_soc_dapm_mixer:
 -	case snd_soc_dapm_buffer:
 -	case snd_soc_dapm_scheduler:
 -	case snd_soc_dapm_aif_out:
 -	case snd_soc_dapm_aif_in:
 -	case snd_soc_dapm_src:
 -	case snd_soc_dapm_asrc:
 -	case snd_soc_dapm_siggen:
 -	case snd_soc_dapm_mux:
 -	case snd_soc_dapm_demux:
 -		ret = sof_widget_parse_tokens(scomp, swidget, tw,  token_list, token_list_size);
 -		break;
 -	case snd_soc_dapm_switch:
 -	case snd_soc_dapm_dai_link:
 -	case snd_soc_dapm_kcontrol:
 -	default:
 -		dev_dbg(scomp->dev, "widget type %d name %s not handled\n", swidget->id, tw->name);
 -		break;
 -	}
 +/*
 + * ASRC Topology
 + */
  
 -	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE)) {
 -		swidget->core = SOF_DSP_PRIMARY_CORE;
 -	} else {
 -		int core = sof_get_token_value(SOF_TKN_COMP_CORE_ID, swidget->tuples,
 -					       swidget->num_tuples);
 +static int sof_widget_load_asrc(struct snd_soc_component *scomp, int index,
 +				struct snd_sof_widget *swidget,
 +				struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_asrc *asrc;
 +	size_t ipc_size = sizeof(*asrc);
 +	int ret;
  
 -		if (core >= 0)
 -			swidget->core = core;
 -	}
 +	asrc = (struct sof_ipc_comp_asrc *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!asrc)
 +		return -ENOMEM;
  
 -	/* check token parsing reply */
 -	if (ret < 0) {
 -		dev_err(scomp->dev,
 -			"error: failed to add widget id %d type %d name : %s stream %s\n",
 -			tw->shift, swidget->id, tw->name,
 -			strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 -				? tw->sname : "none");
 -		kfree(swidget);
 -		return ret;
 +	/* configure ASRC IPC message */
 +	asrc->comp.type = SOF_COMP_ASRC;
 +	asrc->config.hdr.size = sizeof(asrc->config);
 +
 +	ret = sof_parse_tokens(scomp, asrc, asrc_tokens,
 +			       ARRAY_SIZE(asrc_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc tokens failed %d\n",
 +			private->size);
 +		goto err;
  	}
  
 -	/* bind widget to external event */
 -	if (tw->event_type) {
 -		if (widget_ops[w->id].bind_event) {
 -			ret = widget_ops[w->id].bind_event(scomp, swidget,
 -							   le16_to_cpu(tw->event_type));
 -			if (ret) {
 -				dev_err(scomp->dev, "widget event binding failed for %s\n",
 -					swidget->widget->name);
 -				kfree(swidget->private);
 -				kfree(swidget->tuples);
 -				kfree(swidget);
 -				return ret;
 -			}
 -		}
 +	ret = sof_parse_tokens(scomp, &asrc->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
  	}
  
 -	w->dobj.private = swidget;
 -	list_add(&swidget->list, &sdev->widget_list);
 +	dev_dbg(scomp->dev, "asrc %s: source rate %d sink rate %d "
 +		"asynch %d operation %d\n",
 +		swidget->widget->name, asrc->source_rate, asrc->sink_rate,
 +		asrc->asynchronous_mode, asrc->operation_mode);
 +	sof_dbg_comp_config(scomp, &asrc->config);
 +
 +	swidget->private = asrc;
 +
 +	return 0;
 +err:
 +	kfree(asrc);
  	return ret;
  }
  
@@@ -2160,932 -1456,33 +2251,934 @@@ static int sof_get_control_data(struct 
  			break;
  		case SND_SOC_TPLG_TYPE_ENUM:
  			se = (struct soc_enum *)kc->private_value;
 -			scontrol = se->dobj.private;
 +			wdata[i].control = se->dobj.private;
  			break;
 -		case SND_SOC_TPLG_TYPE_BYTES:
 -			sbe = (struct soc_bytes_ext *)kc->private_value;
 -			scontrol = sbe->dobj.private;
 +		default:
 +			dev_err(scomp->dev, "error: unknown kcontrol type %u in widget %s\n",
 +				widget->dobj.widget.kcontrol_type[i],
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		if (!wdata[i].control) {
 +			dev_err(scomp->dev, "error: no scontrol for widget %s\n",
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		wdata[i].pdata = wdata[i].control->control_data->data;
 +		if (!wdata[i].pdata)
 +			return -EINVAL;
 +
 +		/* make sure data is valid - data can be updated at runtime */
 +		if (widget->dobj.widget.kcontrol_type[i] == SND_SOC_TPLG_TYPE_BYTES &&
 +		    wdata[i].pdata->magic != SOF_ABI_MAGIC)
 +			return -EINVAL;
 +
 +		*size += wdata[i].pdata->size;
 +
 +		/* get data type */
 +		switch (wdata[i].control->control_data->cmd) {
 +		case SOF_CTRL_CMD_VOLUME:
 +		case SOF_CTRL_CMD_ENUM:
 +		case SOF_CTRL_CMD_SWITCH:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_VALUE;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_VALUE_CHAN_SET;
 +			break;
 +		case SOF_CTRL_CMD_BINARY:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_DATA;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_DATA_SET;
  			break;
  		default:
 -			dev_warn(scomp->dev, "unsupported kcontrol_type\n");
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_process_load(struct snd_soc_component *scomp, int index,
 +			    struct snd_sof_widget *swidget,
 +			    struct snd_soc_tplg_dapm_widget *tw,
 +			    int type)
 +{
 +	struct snd_soc_dapm_widget *widget = swidget->widget;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process *process;
 +	struct sof_widget_data *wdata = NULL;
 +	size_t ipc_data_size = 0;
 +	size_t ipc_size;
 +	int offset = 0;
 +	int ret;
 +	int i;
 +
 +	/* allocate struct for widget control data sizes and types */
 +	if (widget->num_kcontrols) {
 +		wdata = kcalloc(widget->num_kcontrols,
 +				sizeof(*wdata),
 +				GFP_KERNEL);
 +
 +		if (!wdata)
 +			return -ENOMEM;
 +
 +		/* get possible component controls and get size of all pdata */
 +		ret = sof_get_control_data(scomp, widget, wdata,
 +					   &ipc_data_size);
 +
 +		if (ret < 0)
  			goto out;
 +	}
 +
 +	ipc_size = sizeof(struct sof_ipc_comp_process) + ipc_data_size;
 +
 +	/* we are exceeding max ipc size, config needs to be sent separately */
 +	if (ipc_size > SOF_IPC_MSG_MAX_SIZE) {
 +		ipc_size -= ipc_data_size;
 +		ipc_data_size = 0;
 +	}
 +
 +	process = (struct sof_ipc_comp_process *)
 +		  sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!process) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* configure iir IPC message */
 +	process->comp.type = type;
 +	process->config.hdr.size = sizeof(process->config);
 +
 +	ret = sof_parse_tokens(scomp, &process->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &process->config);
 +
 +	/*
 +	 * found private data in control, so copy it.
 +	 * get possible component controls - get size of all pdata,
 +	 * then memcpy with headers
 +	 */
 +	if (ipc_data_size) {
 +		for (i = 0; i < widget->num_kcontrols; i++) {
 +			memcpy(&process->data[offset],
 +			       wdata[i].pdata->data,
 +			       wdata[i].pdata->size);
 +			offset += wdata[i].pdata->size;
  		}
 -		kfree(scontrol->ipc_control_data);
 -		list_del(&scontrol->list);
 -		kfree(scontrol->name);
 -		kfree(scontrol);
  	}
  
 -out:
 -	/* free IPC related data */
 -	if (widget_ops[swidget->id].ipc_free)
 -		widget_ops[swidget->id].ipc_free(swidget);
 +	process->size = ipc_data_size;
 +	swidget->private = process;
 +err:
 +	if (ret < 0)
 +		kfree(process);
 +out:
 +	kfree(wdata);
 +	return ret;
 +}
 +
 +/*
 + * Processing Component Topology - can be "effect", "codec", or general
 + * "processing".
 + */
 +
 +static int sof_widget_load_process(struct snd_soc_component *scomp, int index,
 +				   struct snd_sof_widget *swidget,
 +				   struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process config;
 +	int ret;
 +
 +	/* check we have some tokens - we need at least process type */
 +	if (le32_to_cpu(private->size) == 0) {
 +		dev_err(scomp->dev, "error: process tokens not found\n");
 +		return -EINVAL;
 +	}
 +
 +	memset(&config, 0, sizeof(config));
 +	config.comp.core = swidget->core;
 +
 +	/* get the process token */
 +	ret = sof_parse_tokens(scomp, &config, process_tokens,
 +			       ARRAY_SIZE(process_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	/* now load process specific data and send IPC */
 +	ret = sof_process_load(scomp, index, swidget, tw, find_process_comp_type(config.type));
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: process loading failed\n");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_widget_bind_event(struct snd_soc_component *scomp,
 +				 struct snd_sof_widget *swidget,
 +				 u16 event_type)
 +{
 +	struct sof_ipc_comp *ipc_comp;
 +
 +	/* validate widget event type */
 +	switch (event_type) {
 +	case SOF_KEYWORD_DETECT_DAPM_EVENT:
 +		/* only KEYWORD_DETECT comps should handle this */
 +		if (swidget->id != snd_soc_dapm_effect)
 +			break;
 +
 +		ipc_comp = swidget->private;
 +		if (ipc_comp && ipc_comp->type != SOF_COMP_KEYWORD_DETECT)
 +			break;
 +
 +		/* bind event to keyword detect comp */
 +		return snd_soc_tplg_widget_bind_event(swidget->widget,
 +						      sof_kwd_events,
 +						      ARRAY_SIZE(sof_kwd_events),
 +						      event_type);
 +	default:
 +		break;
 +	}
 +
 +	dev_err(scomp->dev,
 +		"error: invalid event type %d for widget %s\n",
 +		event_type, swidget->widget->name);
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> 2cabd02b6090 (ASoC: SOF: ipc4-topology: Add support for parsing AIF_IN/AIF_OUT widgets)
 +/* external widget init - used for any driver specific init */
 +static int sof_widget_ready(struct snd_soc_component *scomp, int index,
 +			    struct snd_soc_dapm_widget *w,
 +			    struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_sof_widget *swidget;
 +	struct snd_sof_dai *dai;
 +	struct sof_ipc_comp comp = {
 +		.core = SOF_DSP_PRIMARY_CORE,
 +	};
 +	int ret = 0;
 +
 +	swidget = kzalloc(sizeof(*swidget), GFP_KERNEL);
 +	if (!swidget)
 +		return -ENOMEM;
 +
 +	swidget->scomp = scomp;
 +	swidget->widget = w;
 +	swidget->comp_id = sdev->next_comp_id++;
 +	swidget->complete = 0;
 +	swidget->id = w->id;
 +	swidget->pipeline_id = index;
 +	swidget->private = NULL;
 +
 +	dev_dbg(scomp->dev, "tplg: ready widget id %d pipe %d type %d name : %s stream %s\n",
 +		swidget->comp_id, index, swidget->id, tw->name,
 +		strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 +			? tw->sname : "none");
 +
 +	ret = sof_parse_tokens(scomp, &comp, core_tokens,
 +			       ARRAY_SIZE(core_tokens), tw->priv.array,
 +			       le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing core tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		comp.core = SOF_DSP_PRIMARY_CORE;
 +
 +	swidget->core = comp.core;
 +
 +	ret = sof_parse_tokens(scomp, swidget, comp_ext_tokens, ARRAY_SIZE(comp_ext_tokens),
 +			       tw->priv.array, le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing comp_ext_tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	/* handle any special case widgets */
 +	switch (w->id) {
 +	case snd_soc_dapm_dai_in:
 +	case snd_soc_dapm_dai_out:
 +		dai = kzalloc(sizeof(*dai), GFP_KERNEL);
 +		if (!dai) {
 +			kfree(swidget);
 +			return -ENOMEM;
 +		}
 +
 +		ret = sof_widget_load_dai(scomp, index, swidget, tw, dai);
 +		if (!ret)
 +			ret = sof_connect_dai_widget(scomp, w, tw, dai);
 +		if (ret < 0) {
 +			kfree(dai);
 +			break;
 +		}
 +		list_add(&dai->list, &sdev->dai_list);
 +		swidget->private = dai;
 +		break;
 +	case snd_soc_dapm_mixer:
 +		ret = sof_widget_load_mixer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_pga:
 +		ret = sof_widget_load_pga(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_buffer:
 +		ret = sof_widget_load_buffer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_scheduler:
 +		ret = sof_widget_load_pipeline(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_aif_out:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_CAPTURE, tw);
 +		break;
 +	case snd_soc_dapm_aif_in:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_PLAYBACK, tw);
 +		break;
 +	case snd_soc_dapm_src:
 +		ret = sof_widget_load_src(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_asrc:
 +		ret = sof_widget_load_asrc(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_siggen:
 +		ret = sof_widget_load_siggen(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_effect:
 +		ret = sof_widget_load_process(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_mux:
 +	case snd_soc_dapm_demux:
 +		ret = sof_widget_load_mux(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_switch:
 +	case snd_soc_dapm_dai_link:
 +	case snd_soc_dapm_kcontrol:
 +	default:
 +		dev_dbg(scomp->dev, "widget type %d name %s not handled\n", swidget->id, tw->name);
 +		break;
 +	}
 +
 +	/* check IPC reply */
 +	if (ret < 0) {
 +		dev_err(scomp->dev,
 +			"error: failed to add widget id %d type %d name : %s stream %s\n",
 +			tw->shift, swidget->id, tw->name,
 +			strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 +				? tw->sname : "none");
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	/* bind widget to external event */
 +	if (tw->event_type) {
 +		ret = sof_widget_bind_event(scomp, swidget,
 +					    le16_to_cpu(tw->event_type));
 +		if (ret) {
 +			dev_err(scomp->dev, "error: widget event binding failed\n");
 +			kfree(swidget->private);
 +			kfree(swidget);
 +			return ret;
 +		}
 +	}
 +
 +	w->dobj.private = swidget;
 +	list_add(&swidget->list, &sdev->widget_list);
 +	return ret;
 +}
 +
 +static int sof_route_unload(struct snd_soc_component *scomp,
 +			    struct snd_soc_dobj *dobj)
 +{
 +	struct snd_sof_route *sroute;
 +
 +	sroute = dobj->private;
 +	if (!sroute)
 +		return 0;
 +
 +	/* free sroute and its private data */
 +	kfree(sroute->private);
 +	list_del(&sroute->list);
 +	kfree(sroute);
 +
 +	return 0;
 +}
 +
 +static int sof_widget_unload(struct snd_soc_component *scomp,
 +			     struct snd_soc_dobj *dobj)
 +{
 +	const struct snd_kcontrol_new *kc;
 +	struct snd_soc_dapm_widget *widget;
 +	struct snd_sof_control *scontrol;
 +	struct snd_sof_widget *swidget;
 +	struct soc_mixer_control *sm;
 +	struct soc_bytes_ext *sbe;
 +	struct snd_sof_dai *dai;
 +	struct soc_enum *se;
 +	int ret = 0;
 +	int i;
 +
 +	swidget = dobj->private;
 +	if (!swidget)
 +		return 0;
 +
 +	widget = swidget->widget;
 +
 +	switch (swidget->id) {
 +	case snd_soc_dapm_dai_in:
 +	case snd_soc_dapm_dai_out:
 +		dai = swidget->private;
 +
 +		if (dai) {
 +			struct sof_dai_private_data *dai_data = dai->private;
 +
 +			kfree(dai_data->comp_dai);
 +			kfree(dai_data->dai_config);
 +			kfree(dai_data);
 +			list_del(&dai->list);
 +		}
 +		break;
 +	default:
 +		break;
 +	}
 +	for (i = 0; i < widget->num_kcontrols; i++) {
 +		kc = &widget->kcontrol_news[i];
 +		switch (widget->dobj.widget.kcontrol_type[i]) {
 +		case SND_SOC_TPLG_TYPE_MIXER:
 +			sm = (struct soc_mixer_control *)kc->private_value;
 +			scontrol = sm->dobj.private;
 +			if (sm->max > 1)
 +				kfree(scontrol->volume_table);
 +			break;
 +		case SND_SOC_TPLG_TYPE_ENUM:
 +			se = (struct soc_enum *)kc->private_value;
 +			scontrol = se->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_BYTES:
 +			sbe = (struct soc_bytes_ext *)kc->private_value;
 +			scontrol = sbe->dobj.private;
 +			break;
 +		default:
 +			dev_warn(scomp->dev, "unsupported kcontrol_type\n");
 +			goto out;
 +		}
 +		kfree(scontrol->control_data);
 +		list_del(&scontrol->list);
 +		kfree(scontrol->name);
 +		kfree(scontrol);
 +	}
 +
 +out:
 +	/* free private value */
 +	kfree(swidget->private);
 +
 +	/* remove and free swidget object */
 +	list_del(&swidget->list);
 +	kfree(swidget);
 +
 +	return ret;
 +}
 +
 +/*
 + * DAI HW configuration.
 + */
 +
 +/* FE DAI - used for any driver specific init */
 +static int sof_dai_load(struct snd_soc_component *scomp, int index,
 +			struct snd_soc_dai_driver *dai_drv,
 +			struct snd_soc_tplg_pcm *pcm, struct snd_soc_dai *dai)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_stream_caps *caps;
 +	struct snd_soc_tplg_private *private = &pcm->priv;
 +	struct snd_sof_pcm *spcm;
 +	int stream;
 +	int ret;
 +
 +	/* nothing to do for BEs atm */
 +	if (!pcm)
 +		return 0;
 +
 +	spcm = kzalloc(sizeof(*spcm), GFP_KERNEL);
 +	if (!spcm)
 +		return -ENOMEM;
 +
 +	spcm->scomp = scomp;
 +
 +	for_each_pcm_streams(stream) {
 +		spcm->stream[stream].comp_id = COMP_ID_UNASSIGNED;
 +		if (pcm->compress)
 +			snd_sof_compr_init_elapsed_work(&spcm->stream[stream].period_elapsed_work);
 +		else
 +			snd_sof_pcm_init_elapsed_work(&spcm->stream[stream].period_elapsed_work);
 +	}
 +
 +	spcm->pcm = *pcm;
 +	dev_dbg(scomp->dev, "tplg: load pcm %s\n", pcm->dai_name);
 +
 +	dai_drv->dobj.private = spcm;
 +	list_add(&spcm->list, &sdev->pcm_list);
 +
 +	ret = sof_parse_tokens(scomp, spcm, stream_tokens,
 +			       ARRAY_SIZE(stream_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret) {
 +		dev_err(scomp->dev, "error: parse stream tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	/* do we need to allocate playback PCM DMA pages */
 +	if (!spcm->pcm.playback)
 +		goto capture;
 +
 +	stream = SNDRV_PCM_STREAM_PLAYBACK;
 +
 +	dev_vdbg(scomp->dev, "tplg: pcm %s stream tokens: playback d0i3:%d\n",
 +		 spcm->pcm.pcm_name, spcm->stream[stream].d0i3_compatible);
 +
 +	caps = &spcm->pcm.caps[stream];
 +
 +	/* allocate playback page table buffer */
 +	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev,
 +				  PAGE_SIZE, &spcm->stream[stream].page_table);
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: can't alloc page table for %s %d\n",
 +			caps->name, ret);
 +
 +		return ret;
 +	}
 +
 +	/* bind pcm to host comp */
 +	ret = spcm_bind(scomp, spcm, stream);
 +	if (ret) {
 +		dev_err(scomp->dev,
 +			"error: can't bind pcm to host\n");
 +		goto free_playback_tables;
 +	}
 +
 +capture:
 +	stream = SNDRV_PCM_STREAM_CAPTURE;
 +
 +	/* do we need to allocate capture PCM DMA pages */
 +	if (!spcm->pcm.capture)
 +		return ret;
 +
 +	dev_vdbg(scomp->dev, "tplg: pcm %s stream tokens: capture d0i3:%d\n",
 +		 spcm->pcm.pcm_name, spcm->stream[stream].d0i3_compatible);
 +
 +	caps = &spcm->pcm.caps[stream];
 +
 +	/* allocate capture page table buffer */
 +	ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev,
 +				  PAGE_SIZE, &spcm->stream[stream].page_table);
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: can't alloc page table for %s %d\n",
 +			caps->name, ret);
 +		goto free_playback_tables;
 +	}
 +
 +	/* bind pcm to host comp */
 +	ret = spcm_bind(scomp, spcm, stream);
 +	if (ret) {
 +		dev_err(scomp->dev,
 +			"error: can't bind pcm to host\n");
 +		snd_dma_free_pages(&spcm->stream[stream].page_table);
 +		goto free_playback_tables;
 +	}
 +
 +	return ret;
 +
 +free_playback_tables:
 +	if (spcm->pcm.playback)
 +		snd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].page_table);
 +
 +	return ret;
 +}
 +
 +static int sof_dai_unload(struct snd_soc_component *scomp,
 +			  struct snd_soc_dobj *dobj)
 +{
 +	struct snd_sof_pcm *spcm = dobj->private;
 +
 +	/* free PCM DMA pages */
 +	if (spcm->pcm.playback)
 +		snd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].page_table);
 +
 +	if (spcm->pcm.capture)
 +		snd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_CAPTURE].page_table);
 +
 +	/* remove from list and free spcm */
 +	list_del(&spcm->list);
 +	kfree(spcm);
 +
 +	return 0;
 +}
 +
 +static void sof_dai_set_format(struct snd_soc_tplg_hw_config *hw_config,
 +			       struct sof_ipc_dai_config *config)
 +{
 +	/* clock directions wrt codec */
 +	if (hw_config->bclk_provider == SND_SOC_TPLG_BCLK_CP) {
 +		/* codec is bclk provider */
 +		if (hw_config->fsync_provider == SND_SOC_TPLG_FSYNC_CP)
 +			config->format |= SOF_DAI_FMT_CBP_CFP;
 +		else
 +			config->format |= SOF_DAI_FMT_CBP_CFC;
 +	} else {
 +		/* codec is bclk consumer */
 +		if (hw_config->fsync_provider == SND_SOC_TPLG_FSYNC_CP)
 +			config->format |= SOF_DAI_FMT_CBC_CFP;
 +		else
 +			config->format |= SOF_DAI_FMT_CBC_CFC;
 +	}
 +
 +	/* inverted clocks ? */
 +	if (hw_config->invert_bclk) {
 +		if (hw_config->invert_fsync)
 +			config->format |= SOF_DAI_FMT_IB_IF;
 +		else
 +			config->format |= SOF_DAI_FMT_IB_NF;
 +	} else {
 +		if (hw_config->invert_fsync)
 +			config->format |= SOF_DAI_FMT_NB_IF;
 +		else
 +			config->format |= SOF_DAI_FMT_NB_NF;
 +	}
 +}
 +
 +/*
 + * Send IPC and set the same config for all DAIs with name matching the link
 + * name. Note that the function can only be used for the case that all DAIs
 + * have a common DAI config for now.
 + */
 +static int sof_set_dai_config_multi(struct snd_sof_dev *sdev, u32 size,
 +				    struct snd_soc_dai_link *link,
 +				    struct sof_ipc_dai_config *config,
 +				    int num_conf, int curr_conf)
 +{
 +	struct sof_dai_private_data *dai_data;
 +	struct snd_sof_dai *dai;
 +	int found = 0;
 +	int i;
 +
 +	list_for_each_entry(dai, &sdev->dai_list, list) {
 +		dai_data = dai->private;
 +		if (!dai->name)
 +			continue;
 +
 +		if (strcmp(link->name, dai->name) == 0) {
 +			/*
 +			 * the same dai config will be applied to all DAIs in
 +			 * the same dai link. We have to ensure that the ipc
 +			 * dai config's dai_index match to the component's
 +			 * dai_index.
 +			 */
 +			for (i = 0; i < num_conf; i++)
 +				config[i].dai_index = dai_data->comp_dai->dai_index;
 +
 +			dev_dbg(sdev->dev, "set DAI config for %s index %d\n",
 +				dai->name, config[curr_conf].dai_index);
 +
 +			dai->number_configs = num_conf;
 +			dai->current_config = curr_conf;
 +			dai_data->dai_config = kmemdup(config, size * num_conf, GFP_KERNEL);
 +			if (!dai_data->dai_config)
 +				return -ENOMEM;
 +
 +			found = 1;
 +		}
 +	}
 +
 +	/*
 +	 * machine driver may define a dai link with playback and capture
 +	 * dai enabled, but the dai link in topology would support both, one
 +	 * or none of them. Here print a warning message to notify user
 +	 */
 +	if (!found) {
 +		dev_warn(sdev->dev, "warning: failed to find dai for dai link %s",
 +			 link->name);
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_set_dai_config(struct snd_sof_dev *sdev, u32 size,
 +			      struct snd_soc_dai_link *link,
 +			      struct sof_ipc_dai_config *config)
 +{
 +	return sof_set_dai_config_multi(sdev, size, link, config, 1, 0);
 +}
 +
 +static int sof_link_ssp_load(struct snd_soc_component *scomp, int index,
 +			     struct snd_soc_dai_link *link,
 +			     struct snd_soc_tplg_link_config *cfg,
 +			     struct snd_soc_tplg_hw_config *hw_config,
 +			     struct sof_ipc_dai_config *config, int curr_conf)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_private *private = &cfg->priv;
 +	int num_conf = le32_to_cpu(cfg->num_hw_configs);
 +	u32 size = sizeof(*config);
 +	int ret;
 +	int i;
 +
 +	/*
 +	 * Parse common data, we should have 1 common data per hw_config.
 +	 */
 +	ret = sof_parse_token_sets(scomp, &config->ssp, ssp_tokens,
 +				   ARRAY_SIZE(ssp_tokens), private->array,
 +				   le32_to_cpu(private->size),
 +				   num_conf, size);
 +
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse ssp tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	/* process all possible hw configs */
 +	for (i = 0; i < num_conf; i++) {
 +
 +		/* handle master/slave and inverted clocks */
 +		sof_dai_set_format(&hw_config[i], &config[i]);
 +
 +		config[i].hdr.size = size;
 +
 +		/* copy differentiating hw configs to ipc structs */
 +		config[i].ssp.mclk_rate = le32_to_cpu(hw_config[i].mclk_rate);
 +		config[i].ssp.bclk_rate = le32_to_cpu(hw_config[i].bclk_rate);
 +		config[i].ssp.fsync_rate = le32_to_cpu(hw_config[i].fsync_rate);
 +		config[i].ssp.tdm_slots = le32_to_cpu(hw_config[i].tdm_slots);
 +		config[i].ssp.tdm_slot_width = le32_to_cpu(hw_config[i].tdm_slot_width);
 +		config[i].ssp.mclk_direction = hw_config[i].mclk_direction;
 +		config[i].ssp.rx_slots = le32_to_cpu(hw_config[i].rx_slots);
 +		config[i].ssp.tx_slots = le32_to_cpu(hw_config[i].tx_slots);
 +
 +		dev_dbg(scomp->dev, "tplg: config SSP%d fmt %#x mclk %d bclk %d fclk %d width (%d)%d slots %d mclk id %d quirks %d clks_control %#x\n",
 +			config[i].dai_index, config[i].format,
 +			config[i].ssp.mclk_rate, config[i].ssp.bclk_rate,
 +			config[i].ssp.fsync_rate, config[i].ssp.sample_valid_bits,
 +			config[i].ssp.tdm_slot_width, config[i].ssp.tdm_slots,
 +			config[i].ssp.mclk_id, config[i].ssp.quirks, config[i].ssp.clks_control);
 +
 +		/* validate SSP fsync rate and channel count */
 +		if (config[i].ssp.fsync_rate < 8000 || config[i].ssp.fsync_rate > 192000) {
 +			dev_err(scomp->dev, "error: invalid fsync rate for SSP%d\n",
 +				config[i].dai_index);
 +			return -EINVAL;
 +		}
 +
 +		if (config[i].ssp.tdm_slots < 1 || config[i].ssp.tdm_slots > 8) {
 +			dev_err(scomp->dev, "error: invalid channel count for SSP%d\n",
 +				config[i].dai_index);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	/* set config for all DAI's with name matching the link name */
 +	ret = sof_set_dai_config_multi(sdev, size, link, config, num_conf, curr_conf);
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: failed to save DAI config for SSP%d\n",
 +			config->dai_index);
 +
 +	return ret;
 +}
 +
 +static int sof_link_sai_load(struct snd_soc_component *scomp, int index,
 +			     struct snd_soc_dai_link *link,
 +			     struct snd_soc_tplg_link_config *cfg,
 +			     struct snd_soc_tplg_hw_config *hw_config,
 +			     struct sof_ipc_dai_config *config)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_private *private = &cfg->priv;
 +	u32 size = sizeof(*config);
 +	int ret;
 +
 +	/* handle master/slave and inverted clocks */
 +	sof_dai_set_format(hw_config, config);
 +
 +	/* init IPC */
 +	memset(&config->sai, 0, sizeof(struct sof_ipc_dai_sai_params));
 +	config->hdr.size = size;
 +
 +	ret = sof_parse_tokens(scomp, &config->sai, sai_tokens,
 +			       ARRAY_SIZE(sai_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse sai tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	config->sai.mclk_rate = le32_to_cpu(hw_config->mclk_rate);
 +	config->sai.bclk_rate = le32_to_cpu(hw_config->bclk_rate);
 +	config->sai.fsync_rate = le32_to_cpu(hw_config->fsync_rate);
 +	config->sai.mclk_direction = hw_config->mclk_direction;
 +
 +	config->sai.tdm_slots = le32_to_cpu(hw_config->tdm_slots);
 +	config->sai.tdm_slot_width = le32_to_cpu(hw_config->tdm_slot_width);
 +	config->sai.rx_slots = le32_to_cpu(hw_config->rx_slots);
 +	config->sai.tx_slots = le32_to_cpu(hw_config->tx_slots);
 +
 +	dev_info(scomp->dev,
 +		 "tplg: config SAI%d fmt 0x%x mclk %d width %d slots %d mclk id %d\n",
 +		config->dai_index, config->format,
 +		config->sai.mclk_rate, config->sai.tdm_slot_width,
 +		config->sai.tdm_slots, config->sai.mclk_id);
 +
 +	if (config->sai.tdm_slots < 1 || config->sai.tdm_slots > 8) {
 +		dev_err(scomp->dev, "error: invalid channel count for SAI%d\n",
 +			config->dai_index);
 +		return -EINVAL;
 +	}
 +
 +	/* set config for all DAI's with name matching the link name */
 +	ret = sof_set_dai_config(sdev, size, link, config);
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: failed to save DAI config for SAI%d\n",
 +			config->dai_index);
 +
 +	return ret;
 +}
 +
 +static int sof_link_esai_load(struct snd_soc_component *scomp, int index,
 +			      struct snd_soc_dai_link *link,
 +			      struct snd_soc_tplg_link_config *cfg,
 +			      struct snd_soc_tplg_hw_config *hw_config,
 +			      struct sof_ipc_dai_config *config)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_private *private = &cfg->priv;
 +	u32 size = sizeof(*config);
 +	int ret;
 +
 +	/* handle master/slave and inverted clocks */
 +	sof_dai_set_format(hw_config, config);
 +
 +	/* init IPC */
 +	memset(&config->esai, 0, sizeof(struct sof_ipc_dai_esai_params));
 +	config->hdr.size = size;
 +
 +	ret = sof_parse_tokens(scomp, &config->esai, esai_tokens,
 +			       ARRAY_SIZE(esai_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse esai tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	config->esai.mclk_rate = le32_to_cpu(hw_config->mclk_rate);
 +	config->esai.bclk_rate = le32_to_cpu(hw_config->bclk_rate);
 +	config->esai.fsync_rate = le32_to_cpu(hw_config->fsync_rate);
 +	config->esai.mclk_direction = hw_config->mclk_direction;
 +	config->esai.tdm_slots = le32_to_cpu(hw_config->tdm_slots);
 +	config->esai.tdm_slot_width = le32_to_cpu(hw_config->tdm_slot_width);
 +	config->esai.rx_slots = le32_to_cpu(hw_config->rx_slots);
 +	config->esai.tx_slots = le32_to_cpu(hw_config->tx_slots);
 +
 +	dev_info(scomp->dev,
 +		 "tplg: config ESAI%d fmt 0x%x mclk %d width %d slots %d mclk id %d\n",
 +		config->dai_index, config->format,
 +		config->esai.mclk_rate, config->esai.tdm_slot_width,
 +		config->esai.tdm_slots, config->esai.mclk_id);
 +
 +	if (config->esai.tdm_slots < 1 || config->esai.tdm_slots > 8) {
 +		dev_err(scomp->dev, "error: invalid channel count for ESAI%d\n",
 +			config->dai_index);
 +		return -EINVAL;
 +	}
 +
 +	/* set config for all DAI's with name matching the link name */
 +	ret = sof_set_dai_config(sdev, size, link, config);
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: failed to save DAI config for ESAI%d\n",
 +			config->dai_index);
 +
 +	return ret;
 +}
 +
 +static int sof_link_acp_dmic_load(struct snd_soc_component *scomp, int index,
 +				  struct snd_soc_dai_link *link,
 +				  struct snd_soc_tplg_link_config *cfg,
 +				  struct snd_soc_tplg_hw_config *hw_config,
 +				  struct sof_ipc_dai_config *config)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	u32 size = sizeof(*config);
 +	int ret;
 +
 +       /* handle master/slave and inverted clocks */
 +	sof_dai_set_format(hw_config, config);
 +
 +	/* init IPC */
 +	memset(&config->acpdmic, 0, sizeof(struct sof_ipc_dai_acp_params));
 +	config->hdr.size = size;
 +
 +	config->acpdmic.fsync_rate = le32_to_cpu(hw_config->fsync_rate);
 +	config->acpdmic.tdm_slots = le32_to_cpu(hw_config->tdm_slots);
 +
 +	dev_info(scomp->dev, "ACP_DMIC config ACP%d channel %d rate %d\n",
 +		 config->dai_index, config->acpdmic.tdm_slots,
 +		 config->acpdmic.fsync_rate);
 +
 +	/* set config for all DAI's with name matching the link name */
 +	ret = sof_set_dai_config(sdev, size, link, config);
 +	if (ret < 0)
 +		dev_err(scomp->dev, "ACP_DMIC failed to save DAI config for ACP%d\n",
 +			config->dai_index);
 +	return ret;
 +}
 +
 +static int sof_link_acp_bt_load(struct snd_soc_component *scomp, int index,
 +				struct snd_soc_dai_link *link,
 +				struct snd_soc_tplg_link_config *cfg,
 +				struct snd_soc_tplg_hw_config *hw_config,
 +				struct sof_ipc_dai_config *config)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	u32 size = sizeof(*config);
 +	int ret;
 +
 +	/* handle master/slave and inverted clocks */
 +	sof_dai_set_format(hw_config, config);
  
 -	kfree(swidget->tuples);
 +	/* init IPC */
 +	memset(&config->acpbt, 0, sizeof(struct sof_ipc_dai_acp_params));
 +	config->hdr.size = size;
  
 -	/* remove and free swidget object */
 -	list_del(&swidget->list);
 -	kfree(swidget);
 +	config->acpbt.fsync_rate = le32_to_cpu(hw_config->fsync_rate);
 +	config->acpbt.tdm_slots = le32_to_cpu(hw_config->tdm_slots);
  
 +	dev_info(scomp->dev, "ACP_BT config ACP%d channel %d rate %d\n",
 +		 config->dai_index, config->acpbt.tdm_slots,
 +		 config->acpbt.fsync_rate);
 +
 +	/* set config for all DAI's with name matching the link name */
 +	ret = sof_set_dai_config(sdev, size, link, config);
 +	if (ret < 0)
 +		dev_err(scomp->dev, "ACP_BT failed to save DAI config for ACP%d\n",
 +			config->dai_index);
  	return ret;
  }
  
* Unmerged path sound/soc/sof/ipc4-topology.c
* Unmerged path sound/soc/sof/ipc4-topology.h
* Unmerged path sound/soc/sof/ipc4-topology.c
* Unmerged path sound/soc/sof/ipc4-topology.h
diff --git a/sound/soc/sof/sof-audio.h b/sound/soc/sof/sof-audio.h
index 12d531df1752..9d83347111bc 100644
--- a/sound/soc/sof/sof-audio.h
+++ b/sound/soc/sof/sof-audio.h
@@ -130,6 +130,13 @@ enum sof_tokens {
 	SOF_AFE_TOKENS,
 	SOF_CORE_TOKENS,
 	SOF_COMP_EXT_TOKENS,
+	SOF_IN_AUDIO_FORMAT_TOKENS,
+	SOF_OUT_AUDIO_FORMAT_TOKENS,
+	SOF_AUDIO_FORMAT_BUFFER_SIZE_TOKENS,
+	SOF_COPIER_GATEWAY_CFG_TOKENS,
+	SOF_COPIER_TOKENS,
+	SOF_AUDIO_FMT_NUM_TOKENS,
+	SOF_COPIER_FORMAT_TOKENS,
 
 	/* this should be the last */
 	SOF_TOKEN_COUNT,
* Unmerged path sound/soc/sof/topology.c
