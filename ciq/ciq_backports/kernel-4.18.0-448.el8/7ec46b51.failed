irqchip/gic: Refactor SMP configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Marc Zyngier <maz@kernel.org>
commit 7ec46b519467852fc8eb83b6214ad568f8007846
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/7ec46b51.failed

As we are about to change quite a lot of the SMP support code,
let's start by moving it around so that it minimizes the amount
of #ifdefery.

	Reviewed-by: Valentin Schneider <valentin.schneider@arm.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
(cherry picked from commit 7ec46b519467852fc8eb83b6214ad568f8007846)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/irqchip/irq-gic.c
diff --cc drivers/irqchip/irq-gic.c
index 28a271f8e993,4ffd62af888f..000000000000
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@@ -317,33 -325,6 +317,36 @@@ static int gic_irq_set_vcpu_affinity(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SMP
 +static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 +			    bool force)
 +{
 +	void __iomem *reg = gic_dist_base(d) + GIC_DIST_TARGET + gic_irq(d);
 +	unsigned int cpu;
 +
 +	if (!force)
 +		cpu = cpumask_any_and(mask_val, cpu_online_mask);
 +	else
 +		cpu = cpumask_first(mask_val);
 +
 +	if (cpu >= NR_GIC_CPU_IF || cpu >= nr_cpu_ids)
 +		return -EINVAL;
 +
 +	writeb_relaxed(gic_cpu_map[cpu], reg);
 +	irq_data_update_effective_affinity(d, cpumask_of(cpu));
 +
 +	return IRQ_SET_MASK_OK_DONE;
 +}
 +#endif
 +
 +static int gic_retrigger(struct irq_data *data)
 +{
 +	return !gic_irq_set_irqchip_state(data, IRQCHIP_STATE_PENDING, true);
 +}
 +
++=======
++>>>>>>> 7ec46b519467 (irqchip/gic: Refactor SMP configuration)
  static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
  {
  	u32 irqstat, irqnr;
* Unmerged path drivers/irqchip/irq-gic.c
