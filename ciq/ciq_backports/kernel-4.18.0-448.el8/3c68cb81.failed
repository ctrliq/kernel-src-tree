wifi: mac80211: refactor adding custom elements

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 3c68cb81bf611f6c80ccb164556808d7e04cca89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/3c68cb81.failed

Rework the sorting of custom elements into the association
request by moving the elements before HT/VHT/HE to each
their own function. While at it, fix the placement of the
ones that should be between VHT and HE.

This doesn't fix the placement of elements that should be
between HE and EHT yet, a similar change might be needed
in the future.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 3c68cb81bf611f6c80ccb164556808d7e04cca89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 38beaaa3d3f9,0a6ed925aa47..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -767,6 -770,189 +767,192 @@@ static void ieee80211_add_eht_ie(struc
  	ieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + eht_cap_size);
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_assoc_add_rates(struct sk_buff *skb,
+ 				      enum nl80211_chan_width width,
+ 				      struct ieee80211_supported_band *sband,
+ 				      struct ieee80211_mgd_assoc_data *assoc_data)
+ {
+ 	unsigned int shift = ieee80211_chanwidth_get_shift(width);
+ 	unsigned int rates_len, supp_rates_len;
+ 	u32 rates = 0;
+ 	int i, count;
+ 	u8 *pos;
+ 
+ 	if (assoc_data->supp_rates_len) {
+ 		/*
+ 		 * Get all rates supported by the device and the AP as
+ 		 * some APs don't like getting a superset of their rates
+ 		 * in the association request (e.g. D-Link DAP 1353 in
+ 		 * b-only mode)...
+ 		 */
+ 		rates_len = ieee80211_parse_bitrates(width, sband,
+ 						     assoc_data->supp_rates,
+ 						     assoc_data->supp_rates_len,
+ 						     &rates);
+ 	} else {
+ 		/*
+ 		 * In case AP not provide any supported rates information
+ 		 * before association, we send information element(s) with
+ 		 * all rates that we support.
+ 		 */
+ 		rates_len = sband->n_bitrates;
+ 		for (i = 0; i < sband->n_bitrates; i++)
+ 			rates |= BIT(i);
+ 	}
+ 
+ 	supp_rates_len = rates_len;
+ 	if (supp_rates_len > 8)
+ 		supp_rates_len = 8;
+ 
+ 	pos = skb_put(skb, supp_rates_len + 2);
+ 	*pos++ = WLAN_EID_SUPP_RATES;
+ 	*pos++ = supp_rates_len;
+ 
+ 	count = 0;
+ 	for (i = 0; i < sband->n_bitrates; i++) {
+ 		if (BIT(i) & rates) {
+ 			int rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
+ 						5 * (1 << shift));
+ 			*pos++ = (u8)rate;
+ 			if (++count == 8)
+ 				break;
+ 		}
+ 	}
+ 
+ 	if (rates_len > count) {
+ 		pos = skb_put(skb, rates_len - count + 2);
+ 		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+ 		*pos++ = rates_len - count;
+ 
+ 		for (i++; i < sband->n_bitrates; i++) {
+ 			if (BIT(i) & rates) {
+ 				int rate;
+ 
+ 				rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
+ 						    5 * (1 << shift));
+ 				*pos++ = (u8)rate;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static size_t ieee80211_add_before_ht_elems(struct sk_buff *skb,
+ 					    const u8 *elems,
+ 					    size_t elems_len,
+ 					    size_t offset)
+ {
+ 	size_t noffset;
+ 
+ 	static const u8 before_ht[] = {
+ 		WLAN_EID_SSID,
+ 		WLAN_EID_SUPP_RATES,
+ 		WLAN_EID_EXT_SUPP_RATES,
+ 		WLAN_EID_PWR_CAPABILITY,
+ 		WLAN_EID_SUPPORTED_CHANNELS,
+ 		WLAN_EID_RSN,
+ 		WLAN_EID_QOS_CAPA,
+ 		WLAN_EID_RRM_ENABLED_CAPABILITIES,
+ 		WLAN_EID_MOBILITY_DOMAIN,
+ 		WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
+ 		WLAN_EID_RIC_DATA,		/* reassoc only */
+ 		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+ 	};
+ 	static const u8 after_ric[] = {
+ 		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+ 		WLAN_EID_HT_CAPABILITY,
+ 		WLAN_EID_BSS_COEX_2040,
+ 		/* luckily this is almost always there */
+ 		WLAN_EID_EXT_CAPABILITY,
+ 		WLAN_EID_QOS_TRAFFIC_CAPA,
+ 		WLAN_EID_TIM_BCAST_REQ,
+ 		WLAN_EID_INTERWORKING,
+ 		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
+ 		WLAN_EID_VHT_CAPABILITY,
+ 		WLAN_EID_OPMODE_NOTIF,
+ 	};
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	noffset = ieee80211_ie_split_ric(elems, elems_len,
+ 					 before_ht,
+ 					 ARRAY_SIZE(before_ht),
+ 					 after_ric,
+ 					 ARRAY_SIZE(after_ric),
+ 					 offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_add_before_vht_elems(struct sk_buff *skb,
+ 					     const u8 *elems,
+ 					     size_t elems_len,
+ 					     size_t offset)
+ {
+ 	static const u8 before_vht[] = {
+ 		/*
+ 		 * no need to list the ones split off before HT
+ 		 * or generated here
+ 		 */
+ 		WLAN_EID_BSS_COEX_2040,
+ 		WLAN_EID_EXT_CAPABILITY,
+ 		WLAN_EID_QOS_TRAFFIC_CAPA,
+ 		WLAN_EID_TIM_BCAST_REQ,
+ 		WLAN_EID_INTERWORKING,
+ 		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
+ 	};
+ 	size_t noffset;
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
+ 	noffset = ieee80211_ie_split(elems, elems_len,
+ 				     before_vht, ARRAY_SIZE(before_vht),
+ 				     offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
+ static size_t ieee80211_add_before_he_elems(struct sk_buff *skb,
+ 					    const u8 *elems,
+ 					    size_t elems_len,
+ 					    size_t offset)
+ {
+ 	static const u8 before_he[] = {
+ 		/*
+ 		 * no need to list the ones split off before VHT
+ 		 * or generated here
+ 		 */
+ 		WLAN_EID_OPMODE_NOTIF,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
+ 		/* 11ai elements */
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
+ 		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
+ 		/* TODO: add 11ah/11aj/11ak elements */
+ 	};
+ 	size_t noffset;
+ 
+ 	if (!elems_len)
+ 		return offset;
+ 
+ 	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
+ 	noffset = ieee80211_ie_split(elems, elems_len,
+ 				     before_he, ARRAY_SIZE(before_he),
+ 				     offset);
+ 	skb_put_data(skb, elems + offset, noffset - offset);
+ 
+ 	return noffset;
+ }
+ 
++>>>>>>> 3c68cb81bf61 (wifi: mac80211: refactor adding custom elements)
  static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
  {
  	struct ieee80211_local *local = sdata->local;
@@@ -985,125 -1108,49 +1171,54 @@@ skip_rates
  		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
  
  	/* if present, add any custom IEs that go before HT */
- 	if (assoc_data->ie_len) {
- 		static const u8 before_ht[] = {
- 			WLAN_EID_SSID,
- 			WLAN_EID_SUPP_RATES,
- 			WLAN_EID_EXT_SUPP_RATES,
- 			WLAN_EID_PWR_CAPABILITY,
- 			WLAN_EID_SUPPORTED_CHANNELS,
- 			WLAN_EID_RSN,
- 			WLAN_EID_QOS_CAPA,
- 			WLAN_EID_RRM_ENABLED_CAPABILITIES,
- 			WLAN_EID_MOBILITY_DOMAIN,
- 			WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
- 			WLAN_EID_RIC_DATA,		/* reassoc only */
- 			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
- 		};
- 		static const u8 after_ric[] = {
- 			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
- 			WLAN_EID_HT_CAPABILITY,
- 			WLAN_EID_BSS_COEX_2040,
- 			/* luckily this is almost always there */
- 			WLAN_EID_EXT_CAPABILITY,
- 			WLAN_EID_QOS_TRAFFIC_CAPA,
- 			WLAN_EID_TIM_BCAST_REQ,
- 			WLAN_EID_INTERWORKING,
- 			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
- 			WLAN_EID_VHT_CAPABILITY,
- 			WLAN_EID_OPMODE_NOTIF,
- 		};
- 
- 		noffset = ieee80211_ie_split_ric(assoc_data->ie,
- 						 assoc_data->ie_len,
- 						 before_ht,
- 						 ARRAY_SIZE(before_ht),
- 						 after_ric,
- 						 ARRAY_SIZE(after_ric),
- 						 offset);
- 		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
- 		offset = noffset;
- 	}
+ 	offset = ieee80211_add_before_ht_elems(skb, assoc_data->ie,
+ 					       assoc_data->ie_len,
+ 					       offset);
  
 -	if (WARN_ON_ONCE((link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
 -			 !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)))
 -		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_VHT;
 +	if (WARN_ON_ONCE((ifmgd->flags & IEEE80211_STA_DISABLE_HT) &&
 +			 !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT)))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
  
  	if (sband->band != NL80211_BAND_6GHZ &&
 -	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
 -		ieee80211_add_ht_ie(link, skb, assoc_data->ap_ht_param,
 -				    sband, chan, link->smps_mode);
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_HT))
 +		ieee80211_add_ht_ie(sdata, skb, assoc_data->ap_ht_param,
 +				    sband, chan, sdata->smps_mode);
  
  	/* if present, add any custom IEs that go before VHT */
- 	if (assoc_data->ie_len) {
- 		static const u8 before_vht[] = {
- 			/*
- 			 * no need to list the ones split off before HT
- 			 * or generated here
- 			 */
- 			WLAN_EID_BSS_COEX_2040,
- 			WLAN_EID_EXT_CAPABILITY,
- 			WLAN_EID_QOS_TRAFFIC_CAPA,
- 			WLAN_EID_TIM_BCAST_REQ,
- 			WLAN_EID_INTERWORKING,
- 			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
- 		};
- 
- 		/* RIC already taken above, so no need to handle here anymore */
- 		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
- 					     before_vht, ARRAY_SIZE(before_vht),
- 					     offset);
- 		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
- 		offset = noffset;
- 	}
- 
- 	/* if present, add any custom IEs that go before HE */
- 	if (assoc_data->ie_len) {
- 		static const u8 before_he[] = {
- 			/*
- 			 * no need to list the ones split off before VHT
- 			 * or generated here
- 			 */
- 			WLAN_EID_OPMODE_NOTIF,
- 			WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
- 			/* 11ai elements */
- 			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
- 			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
- 			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
- 			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
- 			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
- 			/* TODO: add 11ah/11aj/11ak elements */
- 		};
- 
- 		/* RIC already taken above, so no need to handle here anymore */
- 		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
- 					     before_he, ARRAY_SIZE(before_he),
- 					     offset);
- 		pos = skb_put(skb, noffset - offset);
- 		memcpy(pos, assoc_data->ie + offset, noffset - offset);
- 		offset = noffset;
- 	}
+ 	offset = ieee80211_add_before_vht_elems(skb, assoc_data->ie,
+ 						assoc_data->ie_len,
+ 						offset);
  
  	if (sband->band != NL80211_BAND_6GHZ &&
 -	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
 -		ieee80211_add_vht_ie(link, skb, sband,
 +	    !(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ieee80211_add_vht_ie(sdata, skb, sband,
  				     &assoc_data->ap_vht_cap);
  
  	/*
  	 * If AP doesn't support HT, mark HE and EHT as disabled.
  	 * If on the 5GHz band, make sure it supports VHT.
  	 */
 -	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT ||
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT ||
  	    (sband->band == NL80211_BAND_5GHZ &&
 -	     link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT))
 -		link->u.mgd.conn_flags |= IEEE80211_CONN_DISABLE_HE |
 -						   IEEE80211_CONN_DISABLE_EHT;
 -
 +	     ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HE |
 +			        IEEE80211_STA_DISABLE_EHT;
 +
++<<<<<<< HEAD
 +	if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HE)) {
 +		ieee80211_add_he_ie(sdata, skb, sband);
++=======
+ 	/* if present, add any custom IEs that go before HE */
+ 	offset = ieee80211_add_before_he_elems(skb, assoc_data->ie,
+ 					       assoc_data->ie_len,
+ 					       offset);
+ 
+ 	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)) {
+ 		ieee80211_add_he_ie(link, skb, sband);
++>>>>>>> 3c68cb81bf61 (wifi: mac80211: refactor adding custom elements)
  
 -		if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT))
 -			ieee80211_add_eht_ie(link, skb, sband);
 +		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_EHT))
 +			ieee80211_add_eht_ie(sdata, skb, sband);
  	}
  
  	/* if present, add any custom non-vendor IEs that go after HE */
* Unmerged path net/mac80211/mlme.c
