PCI: vmd: Disable MSI-X remapping when possible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jon Derrick <jonathan.derrick@intel.com>
commit ee81ee84f8739e584c9ccf113ba3c796187b7080
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ee81ee84.failed

VMD will retransmit child device MSI-X using its own MSI-X table and
requester-id. This limits the number of MSI-X available to the whole
child device domain to the number of VMD MSI-X interrupts.

Some VMD devices have a mode where this remapping can be disabled,
allowing child device interrupts to bypass processing with the VMD MSI-X
domain interrupt handler and going straight the child device interrupt
handler, allowing for better performance and scaling. The requester-id
still gets changed to the VMD endpoint's requester-id, and the interrupt
remapping handlers have been updated to properly set IRTE for child
device interrupts to the VMD endpoint's context.

Some VMD platforms have existing production BIOS which rely on MSI-X
remapping and won't explicitly program the MSI-X remapping bit. This
re-enables MSI-X remapping on unload.

Link: https://lore.kernel.org/r/20210210161315.316097-3-jonathan.derrick@intel.com
	Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Krzysztof Wilczy≈Ñski <kw@linux.com>
	Acked-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit ee81ee84f8739e584c9ccf113ba3c796187b7080)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/vmd.c
diff --cc drivers/pci/controller/vmd.c
index b16dbfce2e2e,e3fcdfec58b3..000000000000
--- a/drivers/pci/controller/vmd.c
+++ b/drivers/pci/controller/vmd.c
@@@ -55,6 -54,19 +56,22 @@@ enum vmd_features 
  	 * vendor-specific capability space
  	 */
  	VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP	= (1 << 2),
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Device may use MSI-X vector 0 for software triggering and will not
+ 	 * be used for MSI remapping
+ 	 */
+ 	VMD_FEAT_OFFSET_FIRST_VECTOR		= (1 << 3),
+ 
+ 	/*
+ 	 * Device can bypass remapping MSI-X transactions into its MSI-X table,
+ 	 * avoiding the requirement of a VMD MSI domain for child device
+ 	 * interrupt handling.
+ 	 */
+ 	VMD_FEAT_CAN_BYPASS_MSI_REMAP		= (1 << 4),
++>>>>>>> ee81ee84f873 (PCI: vmd: Disable MSI-X remapping when possible)
  };
  
  /*
@@@ -293,6 -314,50 +310,53 @@@ static struct msi_domain_info vmd_msi_d
  	.chip		= &vmd_msi_controller,
  };
  
++<<<<<<< HEAD
++=======
+ static void vmd_set_msi_remapping(struct vmd_dev *vmd, bool enable)
+ {
+ 	u16 reg;
+ 
+ 	pci_read_config_word(vmd->dev, PCI_REG_VMCONFIG, &reg);
+ 	reg = enable ? (reg & ~VMCONFIG_MSI_REMAP) :
+ 		       (reg | VMCONFIG_MSI_REMAP);
+ 	pci_write_config_word(vmd->dev, PCI_REG_VMCONFIG, reg);
+ }
+ 
+ static int vmd_create_irq_domain(struct vmd_dev *vmd)
+ {
+ 	struct fwnode_handle *fn;
+ 
+ 	fn = irq_domain_alloc_named_id_fwnode("VMD-MSI", vmd->sysdata.domain);
+ 	if (!fn)
+ 		return -ENODEV;
+ 
+ 	vmd->irq_domain = pci_msi_create_irq_domain(fn, &vmd_msi_domain_info, NULL);
+ 	if (!vmd->irq_domain) {
+ 		irq_domain_free_fwnode(fn);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vmd_remove_irq_domain(struct vmd_dev *vmd)
+ {
+ 	/*
+ 	 * Some production BIOS won't enable remapping between soft reboots.
+ 	 * Ensure remapping is restored before unloading the driver.
+ 	 */
+ 	if (!vmd->msix_count)
+ 		vmd_set_msi_remapping(vmd, true);
+ 
+ 	if (vmd->irq_domain) {
+ 		struct fwnode_handle *fn = vmd->irq_domain->fwnode;
+ 
+ 		irq_domain_remove(vmd->irq_domain);
+ 		irq_domain_free_fwnode(fn);
+ 	}
+ }
+ 
++>>>>>>> ee81ee84f873 (PCI: vmd: Disable MSI-X remapping when possible)
  static void __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,
  				  unsigned int devfn, int reg, int len)
  {
@@@ -641,23 -704,32 +705,47 @@@ static int vmd_enable_domain(struct vmd
  
  	sd->node = pcibus_to_node(vmd->dev->bus);
  
++<<<<<<< HEAD
 +	fn = irq_domain_alloc_named_id_fwnode("VMD-MSI", vmd->sysdata.domain);
 +	if (!fn)
 +		return -ENODEV;
 +
 +	vmd->irq_domain = pci_msi_create_irq_domain(fn, &vmd_msi_domain_info,
 +						    NULL);
 +
 +	if (!vmd->irq_domain) {
 +		irq_domain_free_fwnode(fn);
 +		return -ENODEV;
 +	}
 +
++=======
++>>>>>>> ee81ee84f873 (PCI: vmd: Disable MSI-X remapping when possible)
  	/*
- 	 * Override the irq domain bus token so the domain can be distinguished
- 	 * from a regular PCI/MSI domain.
+ 	 * Currently MSI remapping must be enabled in guest passthrough mode
+ 	 * due to some missing interrupt remapping plumbing. This is probably
+ 	 * acceptable because the guest is usually CPU-limited and MSI
+ 	 * remapping doesn't become a performance bottleneck.
  	 */
- 	irq_domain_update_bus_token(vmd->irq_domain, DOMAIN_BUS_VMD_MSI);
+ 	if (!(features & VMD_FEAT_CAN_BYPASS_MSI_REMAP) ||
+ 	    offset[0] || offset[1]) {
+ 		ret = vmd_alloc_irqs(vmd);
+ 		if (ret)
+ 			return ret;
+ 
+ 		vmd_set_msi_remapping(vmd, true);
+ 
+ 		ret = vmd_create_irq_domain(vmd);
+ 		if (ret)
+ 			return ret;
+ 
+ 		/*
+ 		 * Override the IRQ domain bus token so the domain can be
+ 		 * distinguished from a regular PCI/MSI domain.
+ 		 */
+ 		irq_domain_update_bus_token(vmd->irq_domain, DOMAIN_BUS_VMD_MSI);
+ 	} else {
+ 		vmd_set_msi_remapping(vmd, false);
+ 	}
  
  	pci_add_resource(&resources, &vmd->resources[0]);
  	pci_add_resource_offset(&resources, &vmd->resources[1], offset[0]);
@@@ -737,44 -792,12 +825,47 @@@ static int vmd_probe(struct pci_dev *de
  	    dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32)))
  		return -ENODEV;
  
 -	if (features & VMD_FEAT_OFFSET_FIRST_VECTOR)
 -		vmd->first_vec = 1;
 +	vmd->msix_count = pci_msix_vec_count(dev);
 +	if (vmd->msix_count < 0)
 +		return -ENODEV;
 +
++<<<<<<< HEAD
 +	vmd->msix_count = pci_alloc_irq_vectors(dev, 1, vmd->msix_count,
 +					PCI_IRQ_MSIX);
 +	if (vmd->msix_count < 0)
 +		return vmd->msix_count;
 +
 +	vmd->irqs = devm_kcalloc(&dev->dev, vmd->msix_count, sizeof(*vmd->irqs),
 +				 GFP_KERNEL);
 +	if (!vmd->irqs)
 +		return -ENOMEM;
  
 +	for (i = 0; i < vmd->msix_count; i++) {
 +		vmd->irqs[i] = devm_kzalloc(&dev->dev, sizeof(**vmd->irqs),
 +					    GFP_KERNEL);
 +		if (!vmd->irqs[i])
 +			return -ENOMEM;
 +	}
 +
 +	for (i = 0; i < vmd->msix_count; i++) {
 +		err = init_srcu_struct(&vmd->irqs[i]->srcu);
 +		if (err)
 +			return err;
 +
 +		INIT_LIST_HEAD(&vmd->irqs[i]->irq_list);
 +		vmd->irqs[i]->index = i;
 +		err = devm_request_irq(&dev->dev, pci_irq_vector(dev, i),
 +				       vmd_irq, IRQF_NO_THREAD,
 +				       "vmd", vmd->irqs[i]);
 +		if (err)
 +			return err;
 +	}
 +
++=======
++>>>>>>> ee81ee84f873 (PCI: vmd: Disable MSI-X remapping when possible)
  	spin_lock_init(&vmd->cfg_lock);
  	pci_set_drvdata(dev, vmd);
 -	err = vmd_enable_domain(vmd, features);
 +	err = vmd_enable_domain(vmd, (unsigned long) id->driver_data);
  	if (err)
  		return err;
  
@@@ -842,16 -863,20 +933,17 @@@ static const struct pci_device_id vmd_i
  		.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP,},
  	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_VMD_28C0),
  		.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW |
- 				VMD_FEAT_HAS_BUS_RESTRICTIONS,},
+ 				VMD_FEAT_HAS_BUS_RESTRICTIONS |
+ 				VMD_FEAT_CAN_BYPASS_MSI_REMAP,},
  	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x467f),
  		.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP |
 -				VMD_FEAT_HAS_BUS_RESTRICTIONS |
 -				VMD_FEAT_OFFSET_FIRST_VECTOR,},
 +				VMD_FEAT_HAS_BUS_RESTRICTIONS,},
  	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x4c3d),
  		.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP |
 -				VMD_FEAT_HAS_BUS_RESTRICTIONS |
 -				VMD_FEAT_OFFSET_FIRST_VECTOR,},
 +				VMD_FEAT_HAS_BUS_RESTRICTIONS,},
  	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_VMD_9A0B),
  		.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP |
 -				VMD_FEAT_HAS_BUS_RESTRICTIONS |
 -				VMD_FEAT_OFFSET_FIRST_VECTOR,},
 +				VMD_FEAT_HAS_BUS_RESTRICTIONS,},
  	{0,}
  };
  MODULE_DEVICE_TABLE(pci, vmd_ids);
* Unmerged path drivers/pci/controller/vmd.c
