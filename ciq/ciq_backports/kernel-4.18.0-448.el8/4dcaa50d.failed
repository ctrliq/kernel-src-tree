net/sched: act_mirred: Add extack message for offload failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ido Schimmel <idosch@nvidia.com>
commit 4dcaa50d02927f045c8653ba992aadc7c94ee71a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/4dcaa50d.failed

For better error reporting to user space, add an extack message when
mirred action offload fails.

Currently, the failure cannot be triggered, but add a message in case
the action is extended in the future to support more than ingress/egress
mirror/redirect.

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: Petr Machata <petrm@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4dcaa50d02927f045c8653ba992aadc7c94ee71a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_mirred.c
diff --cc net/sched/act_mirred.c
index de09f8f40c4c,ebb92fb072ab..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -453,6 -450,57 +453,60 @@@ static size_t tcf_mirred_get_fill_size(
  	return nla_total_size(sizeof(struct tc_mirred));
  }
  
++<<<<<<< HEAD
++=======
+ static void tcf_offload_mirred_get_dev(struct flow_action_entry *entry,
+ 				       const struct tc_action *act)
+ {
+ 	entry->dev = act->ops->get_dev(act, &entry->destructor);
+ 	if (!entry->dev)
+ 		return;
+ 	entry->destructor_priv = entry->dev;
+ }
+ 
+ static int tcf_mirred_offload_act_setup(struct tc_action *act, void *entry_data,
+ 					u32 *index_inc, bool bind,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	if (bind) {
+ 		struct flow_action_entry *entry = entry_data;
+ 
+ 		if (is_tcf_mirred_egress_redirect(act)) {
+ 			entry->id = FLOW_ACTION_REDIRECT;
+ 			tcf_offload_mirred_get_dev(entry, act);
+ 		} else if (is_tcf_mirred_egress_mirror(act)) {
+ 			entry->id = FLOW_ACTION_MIRRED;
+ 			tcf_offload_mirred_get_dev(entry, act);
+ 		} else if (is_tcf_mirred_ingress_redirect(act)) {
+ 			entry->id = FLOW_ACTION_REDIRECT_INGRESS;
+ 			tcf_offload_mirred_get_dev(entry, act);
+ 		} else if (is_tcf_mirred_ingress_mirror(act)) {
+ 			entry->id = FLOW_ACTION_MIRRED_INGRESS;
+ 			tcf_offload_mirred_get_dev(entry, act);
+ 		} else {
+ 			NL_SET_ERR_MSG_MOD(extack, "Unsupported mirred offload");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		*index_inc = 1;
+ 	} else {
+ 		struct flow_offload_action *fl_action = entry_data;
+ 
+ 		if (is_tcf_mirred_egress_redirect(act))
+ 			fl_action->id = FLOW_ACTION_REDIRECT;
+ 		else if (is_tcf_mirred_egress_mirror(act))
+ 			fl_action->id = FLOW_ACTION_MIRRED;
+ 		else if (is_tcf_mirred_ingress_redirect(act))
+ 			fl_action->id = FLOW_ACTION_REDIRECT_INGRESS;
+ 		else if (is_tcf_mirred_ingress_mirror(act))
+ 			fl_action->id = FLOW_ACTION_MIRRED_INGRESS;
+ 		else
+ 			return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4dcaa50d0292 (net/sched: act_mirred: Add extack message for offload failure)
  static struct tc_action_ops act_mirred_ops = {
  	.kind		=	"mirred",
  	.id		=	TCA_ID_MIRRED,
* Unmerged path net/sched/act_mirred.c
