net: extract a few internals from netdevice.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 6264f58ca0e54e41d63c2d00334a48bac28fbf30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6264f58c.failed

There's a number of functions and static variables used
under net/core/ but not from the outside. We currently
dump most of them into netdevice.h. That bad for many
reasons:
 - netdevice.h is very cluttered, hard to figure out
   what the APIs are;
 - netdevice.h is very long;
 - we have to touch netdevice.h more which causes expensive
   incremental builds.

Create a header under net/core/ and move some declarations.

The new header is also a bit of a catch-all but that's
fine, if we create more specific headers people will
likely over-think where their declaration fit best.
And end up putting them in netdevice.h, again.

More work should be done on splitting netdevice.h into more
targeted headers, but that'd be more time consuming so small
steps.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 6264f58ca0e54e41d63c2d00334a48bac28fbf30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/sock.c
#	net/core/sysctl_net_core.c
diff --cc include/linux/netdevice.h
index 379d8bad852d,7e7b2a72e473..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -57,9 -53,14 +57,17 @@@
  
  struct netpoll_info;
  struct device;
 -struct ethtool_ops;
  struct phy_device;
  struct dsa_port;
- 
++<<<<<<< HEAD
++
++=======
+ struct ip_tunnel_parm;
+ struct macsec_context;
+ struct macsec_ops;
+ struct netdev_name_node;
+ struct sd_flow_limit;
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  struct sfp_bus;
  /* 802.11 specific */
  struct wireless_dev;
@@@ -990,26 -1018,14 +998,34 @@@ struct dev_ifalias 
  	char ifalias[];
  };
  
 +struct netdev_net_notifier {
 +	struct list_head list;
 +	struct notifier_block *nb;
 +};
 +
 +struct net_device_ops_extended_rh {
 +};
  struct devlink;
 -struct tlsdev_ops;
  
 +
++<<<<<<< HEAD
 +struct netdev_name_node {
 +	struct hlist_node hlist;
 +	struct list_head list;
 +	struct net_device *dev;
 +	const char *name;
 +};
 +
 +int netdev_name_node_alt_create(struct net_device *dev, const char *name);
 +int netdev_name_node_alt_destroy(struct net_device *dev, const char *name);
 +
++=======
+ struct netdev_net_notifier {
+ 	struct list_head list;
+ 	struct notifier_block *nb;
+ };
+ 
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  /*
   * This structure defines the management hooks for network devices.
   * The following hooks can be defined; unless noted otherwise, they are
@@@ -2988,256 -2966,8 +3004,255 @@@ struct net_device *dev_get_by_index(str
  struct net_device *__dev_get_by_index(struct net *net, int ifindex);
  struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex);
  struct net_device *dev_get_by_napi_id(unsigned int napi_id);
- int netdev_get_name(struct net *net, char *name, int ifindex);
  int dev_restart(struct net_device *dev);
 +int skb_gro_receive(struct sk_buff *p, struct sk_buff *skb);
 +int skb_gro_receive_list(struct sk_buff *p, struct sk_buff *skb);
 +
 +static inline unsigned int skb_gro_offset(const struct sk_buff *skb)
 +{
 +	return NAPI_GRO_CB(skb)->data_offset;
 +}
 +
 +static inline unsigned int skb_gro_len(const struct sk_buff *skb)
 +{
 +	return skb->len - NAPI_GRO_CB(skb)->data_offset;
 +}
 +
 +static inline void skb_gro_pull(struct sk_buff *skb, unsigned int len)
 +{
 +	NAPI_GRO_CB(skb)->data_offset += len;
 +}
 +
 +static inline void *skb_gro_header_fast(struct sk_buff *skb,
 +					unsigned int offset)
 +{
 +	return NAPI_GRO_CB(skb)->frag0 + offset;
 +}
 +
 +static inline int skb_gro_header_hard(struct sk_buff *skb, unsigned int hlen)
 +{
 +	return NAPI_GRO_CB(skb)->frag0_len < hlen;
 +}
 +
 +static inline void skb_gro_frag0_invalidate(struct sk_buff *skb)
 +{
 +	NAPI_GRO_CB(skb)->frag0 = NULL;
 +	NAPI_GRO_CB(skb)->frag0_len = 0;
 +}
 +
 +static inline void *skb_gro_header_slow(struct sk_buff *skb, unsigned int hlen,
 +					unsigned int offset)
 +{
 +	if (!pskb_may_pull(skb, hlen))
 +		return NULL;
 +
 +	skb_gro_frag0_invalidate(skb);
 +	return skb->data + offset;
 +}
 +
 +static inline void *skb_gro_network_header(struct sk_buff *skb)
 +{
 +	return (NAPI_GRO_CB(skb)->frag0 ?: skb->data) +
 +	       skb_network_offset(skb);
 +}
 +
 +static inline void skb_gro_postpull_rcsum(struct sk_buff *skb,
 +					const void *start, unsigned int len)
 +{
 +	if (NAPI_GRO_CB(skb)->csum_valid)
 +		NAPI_GRO_CB(skb)->csum = csum_sub(NAPI_GRO_CB(skb)->csum,
 +						  csum_partial(start, len, 0));
 +}
 +
 +/* GRO checksum functions. These are logical equivalents of the normal
 + * checksum functions (in skbuff.h) except that they operate on the GRO
 + * offsets and fields in sk_buff.
 + */
 +
 +__sum16 __skb_gro_checksum_complete(struct sk_buff *skb);
 +
 +static inline bool skb_at_gro_remcsum_start(struct sk_buff *skb)
 +{
 +	return (NAPI_GRO_CB(skb)->gro_remcsum_start == skb_gro_offset(skb));
 +}
 +
 +static inline bool __skb_gro_checksum_validate_needed(struct sk_buff *skb,
 +						      bool zero_okay,
 +						      __sum16 check)
 +{
 +	return ((skb->ip_summed != CHECKSUM_PARTIAL ||
 +		skb_checksum_start_offset(skb) <
 +		 skb_gro_offset(skb)) &&
 +		!skb_at_gro_remcsum_start(skb) &&
 +		NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 +		(!zero_okay || check));
 +}
 +
 +static inline __sum16 __skb_gro_checksum_validate_complete(struct sk_buff *skb,
 +							   __wsum psum)
 +{
 +	if (NAPI_GRO_CB(skb)->csum_valid &&
 +	    !csum_fold(csum_add(psum, NAPI_GRO_CB(skb)->csum)))
 +		return 0;
 +
 +	NAPI_GRO_CB(skb)->csum = psum;
 +
 +	return __skb_gro_checksum_complete(skb);
 +}
 +
 +static inline void skb_gro_incr_csum_unnecessary(struct sk_buff *skb)
 +{
 +	if (NAPI_GRO_CB(skb)->csum_cnt > 0) {
 +		/* Consume a checksum from CHECKSUM_UNNECESSARY */
 +		NAPI_GRO_CB(skb)->csum_cnt--;
 +	} else {
 +		/* Update skb for CHECKSUM_UNNECESSARY and csum_level when we
 +		 * verified a new top level checksum or an encapsulated one
 +		 * during GRO. This saves work if we fallback to normal path.
 +		 */
 +		__skb_incr_checksum_unnecessary(skb);
 +	}
 +}
 +
 +#define __skb_gro_checksum_validate(skb, proto, zero_okay, check,	\
 +				    compute_pseudo)			\
 +({									\
 +	__sum16 __ret = 0;						\
 +	if (__skb_gro_checksum_validate_needed(skb, zero_okay, check))	\
 +		__ret = __skb_gro_checksum_validate_complete(skb,	\
 +				compute_pseudo(skb, proto));		\
 +	if (!__ret)							\
 +		skb_gro_incr_csum_unnecessary(skb);			\
 +	__ret;								\
 +})
 +
 +#define skb_gro_checksum_validate(skb, proto, compute_pseudo)		\
 +	__skb_gro_checksum_validate(skb, proto, false, 0, compute_pseudo)
 +
 +#define skb_gro_checksum_validate_zero_check(skb, proto, check,		\
 +					     compute_pseudo)		\
 +	__skb_gro_checksum_validate(skb, proto, true, check, compute_pseudo)
 +
 +#define skb_gro_checksum_simple_validate(skb)				\
 +	__skb_gro_checksum_validate(skb, 0, false, 0, null_compute_pseudo)
 +
 +static inline bool __skb_gro_checksum_convert_check(struct sk_buff *skb)
 +{
 +	return (NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 +		!NAPI_GRO_CB(skb)->csum_valid);
 +}
 +
 +static inline void __skb_gro_checksum_convert(struct sk_buff *skb,
 +					      __sum16 check, __wsum pseudo)
 +{
 +	NAPI_GRO_CB(skb)->csum = ~pseudo;
 +	NAPI_GRO_CB(skb)->csum_valid = 1;
 +}
 +
 +#define skb_gro_checksum_try_convert(skb, proto, check, compute_pseudo)	\
 +do {									\
 +	if (__skb_gro_checksum_convert_check(skb))			\
 +		__skb_gro_checksum_convert(skb, check,			\
 +					   compute_pseudo(skb, proto));	\
 +} while (0)
 +
 +struct gro_remcsum {
 +	int offset;
 +	__wsum delta;
 +};
 +
 +static inline void skb_gro_remcsum_init(struct gro_remcsum *grc)
 +{
 +	grc->offset = 0;
 +	grc->delta = 0;
 +}
 +
 +static inline void *skb_gro_remcsum_process(struct sk_buff *skb, void *ptr,
 +					    unsigned int off, size_t hdrlen,
 +					    int start, int offset,
 +					    struct gro_remcsum *grc,
 +					    bool nopartial)
 +{
 +	__wsum delta;
 +	size_t plen = hdrlen + max_t(size_t, offset + sizeof(u16), start);
 +
 +	BUG_ON(!NAPI_GRO_CB(skb)->csum_valid);
 +
 +	if (!nopartial) {
 +		NAPI_GRO_CB(skb)->gro_remcsum_start = off + hdrlen + start;
 +		return ptr;
 +	}
 +
 +	ptr = skb_gro_header_fast(skb, off);
 +	if (skb_gro_header_hard(skb, off + plen)) {
 +		ptr = skb_gro_header_slow(skb, off + plen, off);
 +		if (!ptr)
 +			return NULL;
 +	}
 +
 +	delta = remcsum_adjust(ptr + hdrlen, NAPI_GRO_CB(skb)->csum,
 +			       start, offset);
 +
 +	/* Adjust skb->csum since we changed the packet */
 +	NAPI_GRO_CB(skb)->csum = csum_add(NAPI_GRO_CB(skb)->csum, delta);
 +
 +	grc->offset = off + hdrlen + offset;
 +	grc->delta = delta;
 +
 +	return ptr;
 +}
 +
 +static inline void skb_gro_remcsum_cleanup(struct sk_buff *skb,
 +					   struct gro_remcsum *grc)
 +{
 +	void *ptr;
 +	size_t plen = grc->offset + sizeof(u16);
 +
 +	if (!grc->delta)
 +		return;
 +
 +	ptr = skb_gro_header_fast(skb, grc->offset);
 +	if (skb_gro_header_hard(skb, grc->offset + sizeof(u16))) {
 +		ptr = skb_gro_header_slow(skb, plen, grc->offset);
 +		if (!ptr)
 +			return;
 +	}
  
 +	remcsum_unadjust((__sum16 *)ptr, grc->delta);
 +}
 +
 +#ifdef CONFIG_XFRM_OFFLOAD
 +static inline void skb_gro_flush_final(struct sk_buff *skb, struct sk_buff *pp, int flush)
 +{
 +	if (PTR_ERR(pp) != -EINPROGRESS)
 +		NAPI_GRO_CB(skb)->flush |= flush;
 +}
 +static inline void skb_gro_flush_final_remcsum(struct sk_buff *skb,
 +					       struct sk_buff *pp,
 +					       int flush,
 +					       struct gro_remcsum *grc)
 +{
 +	if (PTR_ERR(pp) != -EINPROGRESS) {
 +		NAPI_GRO_CB(skb)->flush |= flush;
 +		skb_gro_remcsum_cleanup(skb, grc);
 +		skb->remcsum_offload = 0;
 +	}
 +}
 +#else
 +static inline void skb_gro_flush_final(struct sk_buff *skb, struct sk_buff *pp, int flush)
 +{
 +	NAPI_GRO_CB(skb)->flush |= flush;
 +}
 +static inline void skb_gro_flush_final_remcsum(struct sk_buff *skb,
 +					       struct sk_buff *pp,
 +					       int flush,
 +					       struct gro_remcsum *grc)
 +{
 +	NAPI_GRO_CB(skb)->flush |= flush;
 +	skb_gro_remcsum_cleanup(skb, grc);
 +	skb->remcsum_offload = 0;
 +}
 +#endif
  
  static inline int dev_hard_header(struct sk_buff *skb, struct net_device *dev,
  				  unsigned short type,
@@@ -3289,27 -3019,11 +3304,14 @@@ static inline bool dev_validate_header(
  	return false;
  }
  
 -static inline bool dev_has_header(const struct net_device *dev)
 +typedef int gifconf_func_t(struct net_device * dev, char __user * bufptr,
 +			   int len, int size);
 +int register_gifconf(unsigned int family, gifconf_func_t *gifconf);
 +static inline int unregister_gifconf(unsigned int family)
  {
 -	return dev->header_ops && dev->header_ops->create;
 +	return register_gifconf(family, NULL);
  }
  
- #ifdef CONFIG_NET_FLOW_LIMIT
- #define FLOW_LIMIT_HISTORY	(1 << 7)  /* must be ^2 and !overflow buckets */
- struct sd_flow_limit {
- 	u64			count;
- 	unsigned int		num_buckets;
- 	unsigned int		history_head;
- 	u16			history[FLOW_LIMIT_HISTORY];
- 	u8			buckets[];
- };
- 
- extern int netdev_flow_limit_table_len;
- #endif /* CONFIG_NET_FLOW_LIMIT */
- 
  /*
   * Incoming packets are placed on per-CPU queues
   */
@@@ -4029,20 -3769,12 +4024,15 @@@ int dev_get_mac_address(struct sockadd
  int dev_get_port_parent_id(struct net_device *dev,
  			   struct netdev_phys_item_id *ppid, bool recurse);
  bool netdev_port_same_parent_id(struct net_device *a, struct net_device *b);
++<<<<<<< HEAD
 +int dev_change_proto_down(struct net_device *dev, bool proto_down);
++=======
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  struct sk_buff *validate_xmit_skb_list(struct sk_buff *skb, struct net_device *dev, bool *again);
  struct sk_buff *dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
  				    struct netdev_queue *txq, int *ret);
  
- typedef int (*bpf_op_t)(struct net_device *dev, struct netdev_bpf *bpf);
- int dev_change_xdp_fd(struct net_device *dev, struct netlink_ext_ack *extack,
- 		      int fd, int expected_fd, u32 flags);
  int bpf_xdp_link_attach(const union bpf_attr *attr, struct bpf_prog *prog);
 -u8 dev_xdp_prog_count(struct net_device *dev);
  u32 dev_xdp_prog_id(struct net_device *dev, enum bpf_xdp_mode mode);
  
  int __dev_forward_skb(struct net_device *dev, struct sk_buff *skb);
@@@ -4096,22 -3857,72 +4086,58 @@@ static __always_inline int ____dev_forw
  bool dev_nit_active(struct net_device *dev);
  void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev);
  
++<<<<<<< HEAD
 +extern int		netdev_budget;
 +extern unsigned int	netdev_budget_usecs;
 +
 +/* Called by rtnetlink.c:rtnl_unlock() */
 +void netdev_run_todo(void);
 +
 +/**
 + *	dev_put - release reference to device
 + *	@dev: network device
 + *
 + * Release reference to device to allow it to be freed.
++=======
+ static inline void __dev_put(struct net_device *dev)
+ {
+ 	if (dev) {
+ #ifdef CONFIG_PCPU_DEV_REFCNT
+ 		this_cpu_dec(*dev->pcpu_refcnt);
+ #else
+ 		refcount_dec(&dev->dev_refcnt);
+ #endif
+ 	}
+ }
+ 
+ static inline void __dev_hold(struct net_device *dev)
+ {
+ 	if (dev) {
+ #ifdef CONFIG_PCPU_DEV_REFCNT
+ 		this_cpu_inc(*dev->pcpu_refcnt);
+ #else
+ 		refcount_inc(&dev->dev_refcnt);
+ #endif
+ 	}
+ }
+ 
+ static inline void __netdev_tracker_alloc(struct net_device *dev,
+ 					  netdevice_tracker *tracker,
+ 					  gfp_t gfp)
+ {
+ #ifdef CONFIG_NET_DEV_REFCNT_TRACKER
+ 	ref_tracker_alloc(&dev->refcnt_tracker, tracker, gfp);
+ #endif
+ }
+ 
+ /* netdev_tracker_alloc() can upgrade a prior untracked reference
+  * taken by dev_get_by_name()/dev_get_by_index() to a tracked one.
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
   */
 -static inline void netdev_tracker_alloc(struct net_device *dev,
 -					netdevice_tracker *tracker, gfp_t gfp)
 -{
 -#ifdef CONFIG_NET_DEV_REFCNT_TRACKER
 -	refcount_dec(&dev->refcnt_tracker.no_tracker);
 -	__netdev_tracker_alloc(dev, tracker, gfp);
 -#endif
 -}
 -
 -static inline void netdev_tracker_free(struct net_device *dev,
 -				       netdevice_tracker *tracker)
 -{
 -#ifdef CONFIG_NET_DEV_REFCNT_TRACKER
 -	ref_tracker_free(&dev->refcnt_tracker, tracker);
 -#endif
 -}
 -
 -static inline void dev_hold_track(struct net_device *dev,
 -				  netdevice_tracker *tracker, gfp_t gfp)
 -{
 -	if (dev) {
 -		__dev_hold(dev);
 -		__netdev_tracker_alloc(dev, tracker, gfp);
 -	}
 -}
 -
 -static inline void dev_put_track(struct net_device *dev,
 -				 netdevice_tracker *tracker)
 +static inline void dev_put(struct net_device *dev)
  {
  	if (dev) {
 -		netdev_tracker_free(dev, tracker);
 -		__dev_put(dev);
 +		this_cpu_dec(*dev->pcpu_refcnt);
  	}
  }
  
@@@ -4609,8 -4419,6 +4632,11 @@@ int dev_addr_add(struct net_device *dev
  		 unsigned char addr_type);
  int dev_addr_del(struct net_device *dev, const unsigned char *addr,
  		 unsigned char addr_type);
++<<<<<<< HEAD
 +void dev_addr_flush(struct net_device *dev);
 +int dev_addr_init(struct net_device *dev);
++=======
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  
  /* Functions used for unicast addresses handling */
  int dev_uc_add(struct net_device *dev, const unsigned char *addr);
@@@ -4717,14 -4525,23 +4742,17 @@@ void dev_fetch_sw_netstats(struct rtnl_
  void dev_get_tstats64(struct net_device *dev, struct rtnl_link_stats64 *s);
  
  extern int		netdev_max_backlog;
++<<<<<<< HEAD
 +extern int		netdev_tstamp_prequeue;
 +extern int		weight_p;
 +extern int		dev_weight_rx_bias;
 +extern int		dev_weight_tx_bias;
++=======
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  extern int		dev_rx_weight;
  extern int		dev_tx_weight;
 -extern int		gro_normal_batch;
 -
 -enum {
 -	NESTED_SYNC_IMM_BIT,
 -	NESTED_SYNC_TODO_BIT,
 -};
 -
 -#define __NESTED_SYNC_BIT(bit)	((u32)1 << (bit))
 -#define __NESTED_SYNC(name)	__NESTED_SYNC_BIT(NESTED_SYNC_ ## name ## _BIT)
 -
 -#define NESTED_SYNC_IMM		__NESTED_SYNC(IMM)
 -#define NESTED_SYNC_TODO	__NESTED_SYNC(TODO)
  
  struct netdev_nested_priv {
 -	unsigned char flags;
  	void *data;
  };
  
diff --cc net/core/sock.c
index c5d36a21facb,7000403eaeb2..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -145,6 -139,10 +145,13 @@@
  #include <net/tcp.h>
  #include <net/busy_poll.h>
  
++<<<<<<< HEAD
++=======
+ #include <linux/ethtool.h>
+ 
+ #include "dev.h"
+ 
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  static DEFINE_MUTEX(proto_list_mutex);
  static LIST_HEAD(proto_list);
  
diff --cc net/core/sysctl_net_core.c
index 85f525f4d8b1,8295e5877eb3..000000000000
--- a/net/core/sysctl_net_core.c
+++ b/net/core/sysctl_net_core.c
@@@ -22,7 -23,11 +22,15 @@@
  #include <net/busy_poll.h>
  #include <net/pkt_sched.h>
  
++<<<<<<< HEAD
 +static int two __maybe_unused = 2;
++=======
+ #include "dev.h"
+ 
+ static int two = 2;
+ static int three = 3;
+ static int int_3600 = 3600;
++>>>>>>> 6264f58ca0e5 (net: extract a few internals from netdevice.h)
  static int min_sndbuf = SOCK_MIN_SNDBUF;
  static int min_rcvbuf = SOCK_MIN_RCVBUF;
  static int max_skb_frags = MAX_SKB_FRAGS;
* Unmerged path include/linux/netdevice.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 60f0f5f733c1..73edca38c645 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -152,6 +152,7 @@
 #include <net/devlink.h>
 #include <linux/prandom.h>
 
+#include "dev.h"
 #include "net-sysfs.h"
 
 #include <linux/rh_flags.h>
diff --git a/net/core/dev.h b/net/core/dev.h
new file mode 100644
index 000000000000..27923df00637
--- /dev/null
+++ b/net/core/dev.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef _NET_CORE_DEV_H
+#define _NET_CORE_DEV_H
+
+#include <linux/types.h>
+
+struct net;
+struct net_device;
+struct netdev_bpf;
+struct netdev_phys_item_id;
+struct netlink_ext_ack;
+
+/* Random bits of netdevice that don't need to be exposed */
+#define FLOW_LIMIT_HISTORY	(1 << 7)  /* must be ^2 and !overflow buckets */
+struct sd_flow_limit {
+	u64			count;
+	unsigned int		num_buckets;
+	unsigned int		history_head;
+	u16			history[FLOW_LIMIT_HISTORY];
+	u8			buckets[];
+};
+
+extern int netdev_flow_limit_table_len;
+
+#ifdef CONFIG_PROC_FS
+int __init dev_proc_init(void);
+#else
+#define dev_proc_init() 0
+#endif
+
+void linkwatch_init_dev(struct net_device *dev);
+void linkwatch_forget_dev(struct net_device *dev);
+void linkwatch_run_queue(void);
+
+void dev_addr_flush(struct net_device *dev);
+int dev_addr_init(struct net_device *dev);
+void dev_addr_check(struct net_device *dev);
+
+/* sysctls not referred to from outside net/core/ */
+extern int		netdev_budget;
+extern unsigned int	netdev_budget_usecs;
+
+extern int		netdev_tstamp_prequeue;
+extern int		netdev_unregister_timeout_secs;
+extern int		weight_p;
+extern int		dev_weight_rx_bias;
+extern int		dev_weight_tx_bias;
+
+/* rtnl helpers */
+extern struct list_head net_todo_list;
+void netdev_run_todo(void);
+
+/* netdev management, shared between various uAPI entry points */
+struct netdev_name_node {
+	struct hlist_node hlist;
+	struct list_head list;
+	struct net_device *dev;
+	const char *name;
+};
+
+int netdev_get_name(struct net *net, char *name, int ifindex);
+int dev_change_name(struct net_device *dev, const char *newname);
+
+int netdev_name_node_alt_create(struct net_device *dev, const char *name);
+int netdev_name_node_alt_destroy(struct net_device *dev, const char *name);
+
+int dev_validate_mtu(struct net_device *dev, int mtu,
+		     struct netlink_ext_ack *extack);
+int dev_set_mtu_ext(struct net_device *dev, int mtu,
+		    struct netlink_ext_ack *extack);
+
+int dev_get_phys_port_id(struct net_device *dev,
+			 struct netdev_phys_item_id *ppid);
+int dev_get_phys_port_name(struct net_device *dev,
+			   char *name, size_t len);
+
+int dev_change_proto_down(struct net_device *dev, bool proto_down);
+void dev_change_proto_down_reason(struct net_device *dev, unsigned long mask,
+				  u32 value);
+
+typedef int (*bpf_op_t)(struct net_device *dev, struct netdev_bpf *bpf);
+int dev_change_xdp_fd(struct net_device *dev, struct netlink_ext_ack *extack,
+		      int fd, int expected_fd, u32 flags);
+
+int dev_change_tx_queue_len(struct net_device *dev, unsigned long new_len);
+void dev_set_group(struct net_device *dev, int new_group);
+int dev_change_carrier(struct net_device *dev, bool new_carrier);
+
+void __dev_set_rx_mode(struct net_device *dev);
+
+#endif
diff --git a/net/core/dev_addr_lists.c b/net/core/dev_addr_lists.c
index 973c0913840a..8c6e28ac3c87 100644
--- a/net/core/dev_addr_lists.c
+++ b/net/core/dev_addr_lists.c
@@ -16,6 +16,8 @@
 #include <linux/export.h>
 #include <linux/list.h>
 
+#include "dev.h"
+
 /*
  * General list handling functions
  */
diff --git a/net/core/dev_ioctl.c b/net/core/dev_ioctl.c
index 9b44185cd7e6..4e35ff0dd9f7 100644
--- a/net/core/dev_ioctl.c
+++ b/net/core/dev_ioctl.c
@@ -7,6 +7,8 @@
 #include <linux/wireless.h>
 #include <net/wext.h>
 
+#include "dev.h"
+
 /*
  *	Map an interface index to its name (SIOCGIFNAME)
  */
diff --git a/net/core/link_watch.c b/net/core/link_watch.c
index 12a57f9df72c..adab059137da 100644
--- a/net/core/link_watch.c
+++ b/net/core/link_watch.c
@@ -23,6 +23,7 @@
 #include <linux/bitops.h>
 #include <linux/types.h>
 
+#include "dev.h"
 
 enum lw_bits {
 	LW_URGENT = 0,
diff --git a/net/core/net-procfs.c b/net/core/net-procfs.c
index c714e6a9dad4..ec79b907a1a4 100644
--- a/net/core/net-procfs.c
+++ b/net/core/net-procfs.c
@@ -4,6 +4,8 @@
 #include <linux/seq_file.h>
 #include <net/wext.h>
 
+#include "dev.h"
+
 #define BUCKET_SPACE (32 - NETDEV_HASHBITS - 1)
 
 #define get_bucket(x) ((x) >> BUCKET_SPACE)
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 96d3519669ec..0fda59bf0bea 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -30,6 +30,7 @@
 #include <linux/of_net.h>
 #include <linux/cpu.h>
 
+#include "dev.h"
 #include "net-sysfs.h"
 
 #ifdef CONFIG_SYSFS
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 0a8ebe9b4f01..4a8992d6c626 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -58,6 +58,8 @@
 #include <net/rtnetlink.h>
 #include <net/net_namespace.h>
 
+#include "dev.h"
+
 #define RTNL_MAX_TYPE		50
 #define RTNL_SLAVE_MAX_TYPE	40
 
* Unmerged path net/core/sock.c
* Unmerged path net/core/sysctl_net_core.c
