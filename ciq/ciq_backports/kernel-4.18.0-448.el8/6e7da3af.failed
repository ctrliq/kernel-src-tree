fbcon: Move console_lock for register/unlink/unregister

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Daniel Vetter <daniel.vetter@ffwll.ch>
commit 6e7da3af008b72520f5318507f455f344b27f022
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/6e7da3af.failed

Ideally console_lock becomes an implementation detail of fbcon.c and
doesn't show up anywhere in fbmem.c. We're still pretty far from that,
but at least the register/unregister code is there now.

With this the do_fb_ioctl() handler is the only code in fbmem.c still
calling console_lock().

	Acked-by: Sam Ravnborg <sam@ravnborg.org>
	Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: Thomas Zimmermann <tzimmermann@suse.de>
	Cc: Du Cheng <ducheng2@gmail.com>
	Cc: Claudio Suarez <cssk@net-c.es>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Sam Ravnborg <sam@ravnborg.org>
	Cc: Zheyu Ma <zheyuma97@gmail.com>
	Cc: Guenter Roeck <linux@roeck-us.net>
	Cc: Alex Deucher <alexander.deucher@amd.com>
	Cc: Zhen Lei <thunder.leizhen@huawei.com>
	Cc: Xiyu Yang <xiyuyang19@fudan.edu.cn>
Link: https://patchwork.freedesktop.org/patch/msgid/20220405210335.3434130-15-daniel.vetter@ffwll.ch
(cherry picked from commit 6e7da3af008b72520f5318507f455f344b27f022)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/video/fbdev/core/fbcon.c
#	drivers/video/fbdev/core/fbmem.c
diff --cc drivers/video/fbdev/core/fbcon.c
index 1a25ce50a9fd,abb419a091c6..000000000000
--- a/drivers/video/fbdev/core/fbcon.c
+++ b/drivers/video/fbdev/core/fbcon.c
@@@ -3103,14 -2751,17 +3103,21 @@@ static inline int fbcon_unbind(void
  #endif /* CONFIG_VT_HW_CONSOLE_BINDING */
  
  /* called with console_lock held */
 -void fbcon_fb_unbind(struct fb_info *info)
 +static int fbcon_fb_unbind(int idx)
  {
 -	int i, new_idx = -1;
 -	int idx = info->node;
 +	int i, new_idx = -1, ret = 0;
  
- 	WARN_CONSOLE_UNLOCKED();
+ 	console_lock();
  
++<<<<<<< HEAD
 +	if (!fbcon_has_console_bind)
 +		return 0;
++=======
+ 	if (!fbcon_has_console_bind) {
+ 		console_unlock();
+ 		return;
+ 	}
++>>>>>>> 6e7da3af008b (fbcon: Move console_lock for register/unlink/unregister)
  
  	for (i = first_fb_vc; i <= last_fb_vc; i++) {
  		if (con2fb_map[i] != idx &&
@@@ -3148,10 -2794,10 +3155,14 @@@
  				}
  			}
  		}
 -		fbcon_unbind();
 +		ret = fbcon_unbind();
  	}
  
++<<<<<<< HEAD
 +	return ret;
++=======
+ 	console_unlock();
++>>>>>>> 6e7da3af008b (fbcon: Move console_lock for register/unlink/unregister)
  }
  
  /* called with console_lock held */
diff --cc drivers/video/fbdev/core/fbmem.c
index 32dffdd5addd,bdd00d381bbc..000000000000
--- a/drivers/video/fbdev/core/fbmem.c
+++ b/drivers/video/fbdev/core/fbmem.c
@@@ -1594,23 -1569,30 +1594,18 @@@ static int do_remove_conflicting_frameb
  
  			printk(KERN_INFO "fb%d: switching to %s from %s\n",
  			       i, name, registered_fb[i]->fix.id);
 -
 -			/*
 -			 * If we kick-out a firmware driver, we also want to remove
 -			 * the underlying platform device, such as simple-framebuffer,
 -			 * VESA, EFI, etc. A native driver will then be able to
 -			 * allocate the memory range.
 -			 *
 -			 * If it's not a platform device, at least print a warning. A
 -			 * fix would add code to remove the device from the system.
 -			 */
 -			if (dev_is_platform(device)) {
 -				registered_fb[i]->forced_out = true;
 -				platform_device_unregister(to_platform_device(device));
 -			} else {
 -				pr_warn("fb%d: cannot remove device\n", i);
 -				do_unregister_framebuffer(registered_fb[i]);
 -			}
 +			ret = do_unregister_framebuffer(registered_fb[i]);
 +			if (ret)
 +				return ret;
  		}
  	}
 +
 +	return 0;
  }
  
- static bool lockless_register_fb;
- module_param_named_unsafe(lockless_register_fb, lockless_register_fb, bool, 0400);
- MODULE_PARM_DESC(lockless_register_fb,
- 	"Lockless framebuffer registration for debugging [default=off]");
- 
  static int do_register_framebuffer(struct fb_info *fb_info)
  {
- 	int i, ret;
+ 	int i;
  	struct fb_videomode mode;
  
  	if (fb_check_foreignness(fb_info))
@@@ -1681,46 -1661,31 +1676,68 @@@
  	}
  #endif
  
 -	return fbcon_fb_registered(fb_info);
++<<<<<<< HEAD
 +	if (!lockless_register_fb)
 +		console_lock();
 +	lock_fb_info(fb_info);
 +	ret = fbcon_fb_registered(fb_info);
 +	unlock_fb_info(fb_info);
 +	if (!lockless_register_fb)
 +		console_unlock();
 +	return 0;
  }
  
 -static void unbind_console(struct fb_info *fb_info)
 +static int unbind_console(struct fb_info *fb_info)
  {
 +	struct fb_event event;
 +	int ret;
  	int i = fb_info->node;
  
 -	if (WARN_ON(i < 0 || i >= FB_MAX || registered_fb[i] != fb_info))
 -		return;
 +	if (i < 0 || i >= FB_MAX || registered_fb[i] != fb_info)
 +		return -EINVAL;
 +
 +	console_lock();
 +	lock_fb_info(fb_info);
 +	event.info = fb_info;
 +	ret = fb_notifier_call_chain(FB_EVENT_FB_UNBIND, &event);
 +	unlock_fb_info(fb_info);
 +	console_unlock();
 +
 +	return ret;
++=======
++	return fbcon_fb_registered(fb_info);
++>>>>>>> 6e7da3af008b (fbcon: Move console_lock for register/unlink/unregister)
 +}
 +
 +static int __unlink_framebuffer(struct fb_info *fb_info);
  
 +static int do_unregister_framebuffer(struct fb_info *fb_info)
 +{
 +	struct fb_event event;
 +	int ret;
 +
 +	ret = unbind_console(fb_info);
 +
++<<<<<<< HEAD
 +	if (ret)
 +		return -EINVAL;
++=======
+ 	fbcon_fb_unbind(fb_info);
+ }
+ 
+ static void unlink_framebuffer(struct fb_info *fb_info)
+ {
+ 	int i;
+ 
+ 	i = fb_info->node;
+ 	if (WARN_ON(i < 0 || i >= FB_MAX || registered_fb[i] != fb_info))
+ 		return;
+ 
+ 	if (!fb_info->dev)
+ 		return;
+ 
+ 	device_destroy(fb_class, MKDEV(FB_MAJOR, i));
++>>>>>>> 6e7da3af008b (fbcon: Move console_lock for register/unlink/unregister)
  
  	pm_vt_switch_unregister(fb_info->dev);
  
* Unmerged path drivers/video/fbdev/core/fbcon.c
* Unmerged path drivers/video/fbdev/core/fbmem.c
