wifi: mac80211: mlme: fix override calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 553a282cb25eb62fdda1f3425d48b12372366e03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/553a282c.failed

In my previous changes here, I neglected to take the old
conn_flags into account that might still be present from
the authentication, and thus ieee80211_setup_assoc_link()
can misbehave, as well as the override calculation being
wrong. Fix that by ORing in the old flags.

Fixes: 1845c1d4a455 ("wifi: mac80211: mlme: refactor assoc link setup")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 553a282cb25eb62fdda1f3425d48b12372366e03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index 446accddbebd,2d389e74c953..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -6038,30 -7021,39 +6038,46 @@@ int ieee80211_mgd_assoc(struct ieee8021
  		memcpy(assoc_data->fils_nonces, req->fils_nonces,
  		       2 * FILS_NONCE_LEN);
  
 -	/* default timeout */
 -	assoc_data->timeout = jiffies;
 -	assoc_data->timeout_started = true;
 -
 -	assoc_data->assoc_link_id = assoc_link_id;
 -
 -	if (req->ap_mld_addr) {
 -		for (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {
 -			assoc_data->link[i].conn_flags = conn_flags;
 -			assoc_data->link[i].bss = req->links[i].bss;
 -		}
 +	assoc_data->bss = req->bss;
 +	assoc_data->capability = req->bss->capability;
 +	assoc_data->supp_rates = bss->supp_rates;
 +	assoc_data->supp_rates_len = bss->supp_rates_len;
  
 -		/* if there was no authentication, set up the link */
 -		err = ieee80211_vif_set_links(sdata, BIT(assoc_link_id));
 -		if (err)
 -			goto err_clear;
 -	} else {
 -		assoc_data->link[0].conn_flags = conn_flags;
 -		assoc_data->link[0].bss = cbss;
 +	rcu_read_lock();
 +	ht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_HT_OPERATION);
 +	if (ht_elem && ht_elem->datalen >= sizeof(struct ieee80211_ht_operation))
 +		assoc_data->ap_ht_param =
 +			((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;
 +	else if (!is_6ghz)
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
 +	vht_elem = ieee80211_bss_get_elem(req->bss, WLAN_EID_VHT_CAPABILITY);
 +	if (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {
 +		memcpy(&assoc_data->ap_vht_cap, vht_elem->data,
 +		       sizeof(struct ieee80211_vht_cap));
 +	} else if (is_5ghz) {
 +		sdata_info(sdata,
 +			   "VHT capa missing/short, disabling VHT/HE/EHT\n");
 +		ifmgd->flags |= IEEE80211_STA_DISABLE_VHT |
 +				IEEE80211_STA_DISABLE_HE |
 +				IEEE80211_STA_DISABLE_EHT;
  	}
++<<<<<<< HEAD
 +	rcu_read_unlock();
++=======
+ 
+ 	link = sdata_dereference(sdata->link[assoc_link_id], sdata);
+ 	if (WARN_ON(!link)) {
+ 		err = -EINVAL;
+ 		goto err_clear;
+ 	}
+ 
+ 	/* keep old conn_flags from ieee80211_prep_channel() from auth */
+ 	conn_flags |= link->u.mgd.conn_flags;
+ 	conn_flags |= ieee80211_setup_assoc_link(sdata, assoc_data, req,
+ 						 conn_flags, assoc_link_id);
+ 	override = link->u.mgd.conn_flags != conn_flags;
+ 	link->u.mgd.conn_flags |= conn_flags;
++>>>>>>> 553a282cb25e (wifi: mac80211: mlme: fix override calculation)
  
  	if (WARN((sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD) &&
  		 ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK),
* Unmerged path net/mac80211/mlme.c
