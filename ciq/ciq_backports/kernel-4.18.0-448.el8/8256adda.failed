s390/pci: handle FH state mismatch only on disable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 8256adda1f44ea1ec763711aefcd25f8c0cf93f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/8256adda.failed

Instead of always treating CLP_RC_SETPCIFN_ALRDY as success and blindly
updating the function handle restrict this special handling to the
disable case by moving it into zpci_disable_device() and still treating
it as an error while also updating the function handle such that
a subsequent zpci_disable_device() succeeds or the caller can ignore the
error when aborting is not an option such as for zPCI event 0x304.
Also print this occurrence to the log such that an admin can tell why
a disable operation returned an error.

A mismatch between the state of the underlying device and our view of it
can naturally happen when the device suddenly enters the error state but
we haven't gotten the error notification yet, it must not happen on
enable though.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 8256adda1f44ea1ec763711aefcd25f8c0cf93f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_clp.c
diff --cc arch/s390/pci/pci_clp.c
index 45c5438cc74b,04147f28d159..000000000000
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@@ -212,41 -212,6 +212,44 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +int clp_add_pci_device(u32 fid, u32 fh, int configured)
 +{
 +	struct zpci_dev *zdev;
 +	int rc = -ENOMEM;
 +
 +	zpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, configured);
 +	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
 +	if (!zdev)
 +		goto error;
 +
 +	zdev->fh = fh;
 +	zdev->fid = fid;
 +
 +	/* Query function properties and update zdev */
 +	rc = clp_query_pci_fn(zdev, fh);
 +	if (rc)
 +		goto error;
 +
 +	if (configured)
 +		zdev->state = ZPCI_FN_STATE_CONFIGURED;
 +	else
 +		zdev->state = ZPCI_FN_STATE_STANDBY;
 +
 +	rc = zpci_create_device(zdev);
 +	if (rc)
 +		goto error;
 +	return 0;
 +
 +error:
 +	zpci_dbg(0, "add fid:%x, rc:%d\n", fid, rc);
 +	kfree(zdev);
 +	return rc;
 +}
 +
 +static int clp_refresh_fh(u32 fid);
++=======
++>>>>>>> 8256adda1f44 (s390/pci: handle FH state mismatch only on disable)
  /**
   * clp_set_pci_fn() - Execute a command on a PCI function
   * @zdev: Function that will be affected
diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h
index 37481081a26c..4f4dff84802b 100644
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -218,6 +218,7 @@ int clp_add_pci_device(u32, u32, int);
 int clp_enable_fh(struct zpci_dev *, u8);
 int clp_disable_fh(struct zpci_dev *);
 int clp_get_state(u32 fid, enum zpci_state *state);
+int clp_refresh_fh(u32 fid);
 
 /* UID */
 void update_uid_checking(bool new);
diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c
index 105423d600b5..7862b056eb50 100644
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -715,12 +715,25 @@ EXPORT_SYMBOL_GPL(zpci_enable_device);
 
 int zpci_disable_device(struct zpci_dev *zdev)
 {
+	int cc, rc = 0;
+
 	zpci_dma_exit_device(zdev);
 	/*
 	 * The zPCI function may already be disabled by the platform, this is
 	 * detected in clp_disable_fh() which becomes a no-op.
 	 */
-	return clp_disable_fh(zdev) ? -EIO : 0;
+	cc = clp_disable_fh(zdev);
+	if (cc == CLP_RC_SETPCIFN_ALRDY) {
+		pr_info("Disabling PCI function %08x had no effect as it was already disabled\n",
+			zdev->fid);
+		/* Function is already disabled - update handle */
+		rc = clp_refresh_fh(zdev->fid);
+		if (!rc)
+			rc = -EINVAL;
+	} else if (cc) {
+		rc = -EIO;
+	}
+	return rc;
 }
 EXPORT_SYMBOL_GPL(zpci_disable_device);
 
* Unmerged path arch/s390/pci/pci_clp.c
