device property: Add irq_get to fwnode operation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sakari Ailus <sakari.ailus@linux.intel.com>
commit 99c63707bafd15bcf97fbd6bef1c92d5bfa01d28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/99c63707.failed

Add irq_get() fwnode operation to implement fwnode_irq_get() through
fwnode operations, moving the code in fwnode_irq_get() to OF and ACPI
frameworks.

	Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Acked-by: Rob Herring <robh@kernel.org>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 99c63707bafd15bcf97fbd6bef1c92d5bfa01d28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/property.c
#	include/linux/fwnode.h
diff --cc drivers/of/property.c
index 1028b0a60417,9a50ad25906e..000000000000
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@@ -1355,11 -1461,26 +1355,30 @@@ static int of_link_property(struct devi
  		}
  		s++;
  	}
 -	return 0;
 +	return ret;
  }
  
++<<<<<<< HEAD
 +static int of_fwnode_add_links(struct fwnode_handle *fwnode,
 +			       struct device *dev)
++=======
+ static void __iomem *of_fwnode_iomap(struct fwnode_handle *fwnode, int index)
+ {
+ #ifdef CONFIG_OF_ADDRESS
+ 	return of_iomap(to_of_node(fwnode), index);
+ #else
+ 	return NULL;
+ #endif
+ }
+ 
+ static int of_fwnode_irq_get(const struct fwnode_handle *fwnode,
+ 			     unsigned int index)
+ {
+ 	return of_irq_get(to_of_node(fwnode), index);
+ }
+ 
+ static int of_fwnode_add_links(struct fwnode_handle *fwnode)
++>>>>>>> 99c63707bafd (device property: Add irq_get to fwnode operation)
  {
  	struct property *p;
  	struct device_node *con_np = to_of_node(fwnode);
@@@ -1393,6 -1517,8 +1412,11 @@@ const struct fwnode_operations of_fwnod
  	.graph_get_remote_endpoint = of_fwnode_graph_get_remote_endpoint,
  	.graph_get_port_parent = of_fwnode_graph_get_port_parent,
  	.graph_parse_endpoint = of_fwnode_graph_parse_endpoint,
++<<<<<<< HEAD
++=======
+ 	.iomap = of_fwnode_iomap,
+ 	.irq_get = of_fwnode_irq_get,
++>>>>>>> 99c63707bafd (device property: Add irq_get to fwnode operation)
  	.add_links = of_fwnode_add_links,
  };
  EXPORT_SYMBOL_GPL(of_fwnode_ops);
diff --cc include/linux/fwnode.h
index 006b5d37b7ec,6ab69871b06d..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -143,10 -148,9 +143,16 @@@ struct fwnode_operations 
  	(*graph_get_port_parent)(struct fwnode_handle *fwnode);
  	int (*graph_parse_endpoint)(const struct fwnode_handle *fwnode,
  				    struct fwnode_endpoint *endpoint);
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(int (*add_links)(struct fwnode_handle *fwnode,
 +			 struct device *dev))
 +	RH_KABI_EXTEND(const char *(*get_name)(const struct fwnode_handle *fwnode))
 +	RH_KABI_EXTEND(const char *(*get_name_prefix)(const struct fwnode_handle *fwnode))
++=======
+ 	void __iomem *(*iomap)(struct fwnode_handle *fwnode, int index);
+ 	int (*irq_get)(const struct fwnode_handle *fwnode, unsigned int index);
+ 	int (*add_links)(struct fwnode_handle *fwnode);
++>>>>>>> 99c63707bafd (device property: Add irq_get to fwnode operation)
  };
  
  #define fwnode_has_op(fwnode, op)				\
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index 5bac795c8905..786365366e56 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -1397,6 +1397,19 @@ static int acpi_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
 	return 0;
 }
 
+static int acpi_fwnode_irq_get(const struct fwnode_handle *fwnode,
+			       unsigned int index)
+{
+	struct resource res;
+	int ret;
+
+	ret = acpi_irq_get(ACPI_HANDLE_FWNODE(fwnode), index, &res);
+	if (ret)
+		return ret;
+
+	return res.start;
+}
+
 #define DECLARE_ACPI_FWNODE_OPS(ops) \
 	const struct fwnode_operations ops = {				\
 		.device_is_available = acpi_fwnode_device_is_available, \
@@ -1421,6 +1434,7 @@ static int acpi_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
 			acpi_graph_get_remote_endpoint,			\
 		.graph_get_port_parent = acpi_fwnode_get_parent,	\
 		.graph_parse_endpoint = acpi_fwnode_graph_parse_endpoint, \
+		.irq_get = acpi_fwnode_irq_get,				\
 	};								\
 	EXPORT_SYMBOL_GPL(ops)
 
diff --git a/drivers/base/property.c b/drivers/base/property.c
index abc5b5a3201c..796e07500e8b 100644
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@ -952,17 +952,7 @@ EXPORT_SYMBOL(fwnode_iomap);
  */
 int fwnode_irq_get(const struct fwnode_handle *fwnode, unsigned int index)
 {
-	struct resource res;
-	int ret;
-
-	if (is_of_node(fwnode))
-		return of_irq_get(to_of_node(fwnode), index);
-
-	ret = acpi_irq_get(ACPI_HANDLE_FWNODE(fwnode), index, &res);
-	if (ret)
-		return ret;
-
-	return res.start;
+	return fwnode_call_int_op(fwnode, irq_get, index);
 }
 EXPORT_SYMBOL(fwnode_irq_get);
 
* Unmerged path drivers/of/property.c
* Unmerged path include/linux/fwnode.h
