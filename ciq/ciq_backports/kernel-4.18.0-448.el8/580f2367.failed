NFS: Adjust the amount of readahead performed by NFS readdir

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 580f236737d13ee25d5b0b1d124f50014fe6833b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/580f2367.failed

The current NFS readdir code will always try to maximise the amount of
readahead it performs on the assumption that we can cache anything that
isn't immediately read by the process.
There are several cases where this assumption breaks down, including
when the 'ls -l' heuristic kicks in to try to force use of readdirplus
as a batch replacement for lookup/getattr.

This patch therefore tries to tone down the amount of readahead we
perform, and adjust it to try to match the amount of data being
requested by user space.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 580f236737d13ee25d5b0b1d124f50014fe6833b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/dir.c
diff --cc fs/nfs/dir.c
index 41b912eafef3,520dc3ec4aef..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -67,18 -69,18 +67,29 @@@ const struct address_space_operations n
  	.freepage = nfs_readdir_clear_array,
  };
  
++<<<<<<< HEAD
 +static struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir)
++=======
+ #define NFS_INIT_DTSIZE PAGE_SIZE
+ 
+ static struct nfs_open_dir_context *
+ alloc_nfs_open_dir_context(struct inode *dir)
++>>>>>>> 580f236737d1 (NFS: Adjust the amount of readahead performed by NFS readdir)
  {
  	struct nfs_inode *nfsi = NFS_I(dir);
  	struct nfs_open_dir_context *ctx;
 -
 -	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);
 +	ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
  	if (ctx != NULL) {
 +		ctx->duped = 0;
  		ctx->attr_gencount = nfsi->attr_gencount;
++<<<<<<< HEAD
 +		ctx->dir_cookie = 0;
 +		ctx->dup_cookie = 0;
 +		ctx->page_index = 0;
 +		ctx->eof = false;
++=======
+ 		ctx->dtsize = NFS_INIT_DTSIZE;
++>>>>>>> 580f236737d1 (NFS: Adjust the amount of readahead performed by NFS readdir)
  		spin_lock(&dir->i_lock);
  		if (list_empty(&nfsi->open_files) &&
  		    (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER))
* Unmerged path fs/nfs/dir.c
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index f07136abc22c..eb1b1d8d442e 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -105,6 +105,7 @@ struct nfs_open_dir_context {
 	__u64 dup_cookie;
 	__u64 last_cookie;
 	pgoff_t page_index;
+	unsigned int dtsize;
 	signed char duped;
 	bool eof;
 };
