net/mlx5e: TC, Reject forwarding from internal port to internal port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ariel Levkovich <lariel@nvidia.com>
commit f382a2413dae8c855226a72600812a4b37432c48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f382a241.failed

Reject TC rules that forward from internal port to internal port
as it is not supported.

This include rules that are explicitly have internal port as
the filter device as well as rules that apply on tunnel interfaces
as the route device for the tunnel interface can be an internal
port.

Fixes: 27484f7170ed ("net/mlx5e: Offload tc rules that redirect to ovs internal port")
	Signed-off-by: Ariel Levkovich <lariel@nvidia.com>
	Reviewed-by: Maor Dickman <maord@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Link: https://lore.kernel.org/r/20221026135153.154807-9-saeed@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit f382a2413dae8c855226a72600812a4b37432c48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c4faae57b873,73f91e54e9d0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -4076,28 -4056,18 +4076,33 @@@ int mlx5e_set_fwd_to_int_port_actions(s
  	return 0;
  }
  
 -static int
 -parse_tc_fdb_actions(struct mlx5e_priv *priv,
 -		     struct flow_action *flow_action,
 -		     struct mlx5e_tc_flow *flow,
 -		     struct netlink_ext_ack *extack)
 +static int parse_tc_fdb_actions(struct mlx5e_priv *priv,
 +				struct flow_action *flow_action,
 +				struct mlx5e_tc_flow *flow,
 +				struct netlink_ext_ack *extack)
  {
 -	struct mlx5e_tc_act_parse_state *parse_state;
 +	struct pedit_headers_action hdrs[2] = {};
 +	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5e_sample_attr sample_attr = {};
 +	const struct ip_tunnel_info *info = NULL;
  	struct mlx5_flow_attr *attr = flow->attr;
 +	int ifindexes[MLX5_MAX_FLOW_FWD_VPORTS];
 +	bool ft_flow = mlx5e_is_ft_flow(flow);
 +	const struct flow_action_entry *act;
  	struct mlx5_esw_flow_attr *esw_attr;
++<<<<<<< HEAD
 +	bool encap = false, decap = false;
 +	u32 action = attr->action;
 +	int err, i, if_count = 0;
 +	bool ptype_host = false;
 +	bool mpls_push = false;
 +	bool clear_action;
++=======
+ 	struct net_device *filter_dev;
+ 	int err;
++>>>>>>> f382a2413dae (net/mlx5e: TC, Reject forwarding from internal port to internal port)
  
  	err = flow_action_supported(flow_action, extack);
  	if (err)
@@@ -4105,374 -4075,32 +4110,393 @@@
  
  	esw_attr = attr->esw_attr;
  	parse_attr = attr->parse_attr;
++<<<<<<< HEAD
++=======
+ 	filter_dev = parse_attr->filter_dev;
+ 	parse_state = &parse_attr->parse_state;
+ 	mlx5e_tc_act_init_parse_state(parse_state, flow, flow_action, extack);
+ 	parse_state->ct_priv = get_ct_priv(priv);
++>>>>>>> f382a2413dae (net/mlx5e: TC, Reject forwarding from internal port to internal port)
  
 -	err = parse_tc_actions(parse_state, flow_action);
 -	if (err)
 -		return err;
 +	flow_action_for_each(i, act, flow_action) {
 +		switch (act->id) {
 +		case FLOW_ACTION_PTYPE:
 +			if (act->ptype != PACKET_HOST) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "skbedit ptype is only supported with type host");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			ptype_host = true;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_TRAP:
 +			if (!flow_offload_has_one_action(flow_action)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "action trap is supported as a sole action only");
 +				return -EOPNOTSUPP;
 +			}
 +			action |= (MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				   MLX5_FLOW_CONTEXT_ACTION_COUNT);
 +			attr->flags |= MLX5_ESW_ATTR_FLAG_SLOW_PATH;
 +			break;
 +		case FLOW_ACTION_MPLS_PUSH:
 +			if (!MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev,
 +							reformat_l2_to_l3_tunnel) ||
 +			    act->mpls_push.proto != htons(ETH_P_MPLS_UC)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls push is supported only for mpls_uc protocol");
 +				return -EOPNOTSUPP;
 +			}
 +			mpls_push = true;
 +			break;
 +		case FLOW_ACTION_MPLS_POP:
 +			/* we only support mpls pop if it is the first action
 +			 * and the filter net device is bareudp. Subsequent
 +			 * actions can be pedit and the last can be mirred
 +			 * egress redirect.
 +			 */
 +			if (i) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls pop supported only as first action");
 +				return -EOPNOTSUPP;
 +			}
 +			if (!netif_is_bareudp(parse_attr->filter_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls pop supported only on bareudp devices");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			parse_attr->eth.h_proto = act->mpls_pop.proto;
 +			action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
 +			flow_flag_set(flow, L3_TO_L2_DECAP);
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_FDB,
 +						    parse_attr, hdrs, flow, extack);
 +			if (err)
 +				return err;
 +
 +			if (!flow_flag_test(flow, L3_TO_L2_DECAP)) {
 +				action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +				esw_attr->split_count = esw_attr->out_count;
 +			}
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags, extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
 +		case FLOW_ACTION_REDIRECT_INGRESS: {
 +			struct net_device *out_dev;
 +
 +			out_dev = act->dev;
 +			if (!out_dev)
 +				return -EOPNOTSUPP;
 +
 +			if (!netif_is_ovs_master(out_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to ingress is supported only for OVS internal ports");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (netif_is_ovs_master(parse_attr->filter_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to ingress is not supported from internal port");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (!ptype_host) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to int port ingress requires ptype=host action");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (esw_attr->out_count) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "redirect to int port ingress is supported only as single destination");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +
 +			err = mlx5e_set_fwd_to_int_port_actions(priv, attr, out_dev->ifindex,
 +								MLX5E_TC_INT_PORT_INGRESS,
 +								&action, esw_attr->out_count);
 +			if (err)
 +				return err;
 +
 +			esw_attr->out_count++;
 +
 +			break;
 +		}
 +		case FLOW_ACTION_REDIRECT:
 +		case FLOW_ACTION_MIRRED: {
 +			struct mlx5e_priv *out_priv;
 +			struct net_device *out_dev;
 +
 +			out_dev = act->dev;
 +			if (!out_dev) {
 +				/* out_dev is NULL when filters with
 +				 * non-existing mirred device are replayed to
 +				 * the driver.
 +				 */
 +				return -EINVAL;
 +			}
 +
 +			if (mpls_push && !netif_is_bareudp(out_dev)) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "mpls is supported only through a bareudp device");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (ft_flow && out_dev == priv->netdev) {
 +				/* Ignore forward to self rules generated
 +				 * by adding both mlx5 devs to the flow table
 +				 * block on a normal nft offload setup.
 +				 */
 +				return -EOPNOTSUPP;
 +			}
 +
 +			if (esw_attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "can't support more output ports, can't offload forwarding");
 +				netdev_warn(priv->netdev,
 +					    "can't support more than %d output ports, can't offload forwarding\n",
 +					    esw_attr->out_count);
 +				return -EOPNOTSUPP;
 +			}
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			if (encap) {
 +				parse_attr->mirred_ifindex[esw_attr->out_count] =
 +					out_dev->ifindex;
 +				parse_attr->tun_info[esw_attr->out_count] =
 +					mlx5e_dup_tun_info(info);
 +				if (!parse_attr->tun_info[esw_attr->out_count])
 +					return -ENOMEM;
 +				encap = false;
 +				esw_attr->dests[esw_attr->out_count].flags |=
 +					MLX5_ESW_DEST_ENCAP;
 +				esw_attr->out_count++;
 +				/* attr->dests[].rep is resolved when we
 +				 * handle encap
 +				 */
 +			} else if (netdev_port_same_parent_id(priv->netdev, out_dev)) {
 +				struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +				struct net_device *uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
 +
 +				if (is_duplicated_output_device(priv->netdev,
 +								out_dev,
 +								ifindexes,
 +								if_count,
 +								extack))
 +					return -EOPNOTSUPP;
 +
 +				ifindexes[if_count] = out_dev->ifindex;
 +				if_count++;
 +
 +				out_dev = get_fdb_out_dev(uplink_dev, out_dev);
 +				if (!out_dev)
 +					return -ENODEV;
 +
 +				if (is_vlan_dev(out_dev)) {
 +					err = add_vlan_push_action(priv, attr,
 +								   &out_dev,
 +								   &action, extack);
 +					if (err)
 +						return err;
 +				}
 +
 +				if (is_vlan_dev(parse_attr->filter_dev)) {
 +					err = add_vlan_pop_action(priv, attr,
 +								  &action, extack);
 +					if (err)
 +						return err;
 +				}
 +
 +				if (netif_is_macvlan(out_dev))
 +					out_dev = macvlan_dev_real_dev(out_dev);
 +
 +				err = verify_uplink_forwarding(priv, flow, out_dev, extack);
 +				if (err)
 +					return err;
 +
 +				if (!mlx5e_is_valid_eswitch_fwd_dev(priv, out_dev)) {
 +					NL_SET_ERR_MSG_MOD(extack,
 +							   "devices are not on same switch HW, can't offload forwarding");
 +					return -EOPNOTSUPP;
 +				}
 +
 +				if (same_vf_reps(priv, out_dev)) {
 +					NL_SET_ERR_MSG_MOD(extack,
 +							   "can't forward from a VF to itself");
 +					return -EOPNOTSUPP;
 +				}
 +
 +				out_priv = netdev_priv(out_dev);
 +				rpriv = out_priv->ppriv;
 +				esw_attr->dests[esw_attr->out_count].rep = rpriv->rep;
 +				esw_attr->dests[esw_attr->out_count].mdev = out_priv->mdev;
 +				esw_attr->out_count++;
 +			} else if (netif_is_ovs_master(out_dev)) {
 +				err = mlx5e_set_fwd_to_int_port_actions(priv, attr,
 +									out_dev->ifindex,
 +									MLX5E_TC_INT_PORT_EGRESS,
 +									&action,
 +									esw_attr->out_count);
 +				if (err)
 +					return err;
 +
 +				esw_attr->out_count++;
 +			} else if (parse_attr->filter_dev != priv->netdev) {
 +				/* All mlx5 devices are called to configure
 +				 * high level device filters. Therefore, the
 +				 * *attempt* to  install a filter on invalid
 +				 * eswitch should not trigger an explicit error
 +				 */
 +				return -EINVAL;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "devices are not on same switch HW, can't offload forwarding");
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_TUNNEL_ENCAP:
 +			info = act->tunnel;
 +			if (info) {
 +				encap = true;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Zero tunnel attributes is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			break;
 +		case FLOW_ACTION_VLAN_PUSH:
 +		case FLOW_ACTION_VLAN_POP:
 +			if (act->id == FLOW_ACTION_VLAN_PUSH &&
 +			    (action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP)) {
 +				/* Replace vlan pop+push with vlan modify */
 +				action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +				err = add_vlan_rewrite_action(priv,
 +							      MLX5_FLOW_NAMESPACE_FDB,
 +							      act, parse_attr, hdrs,
 +							      &action, extack);
 +			} else {
 +				err = parse_tc_vlan_action(priv, act, esw_attr, &action, extack);
 +			}
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_FDB,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_TUNNEL_DECAP:
 +			decap = true;
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
 +			break;
 +		case FLOW_ACTION_CT:
 +			if (flow_flag_test(flow, SAMPLE)) {
 +				NL_SET_ERR_MSG_MOD(extack, "Sample action with connection tracking is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			clear_action = act->ct.action & TCA_CT_ACT_CLEAR;
 +
 +			/* It's redundant to do ct clear more than once. */
 +			if (clear_action && attr->ct_clear)
 +				break;
 +
 +			err = mlx5_tc_ct_parse_action(get_ct_priv(priv), attr,
 +						      &parse_attr->mod_hdr_acts,
 +						      act, extack);
 +			if (err)
 +				return err;
 +
 +			flow_flag_set(flow, CT);
 +			esw_attr->split_count = esw_attr->out_count;
 +			attr->ct_clear = clear_action;
 +			break;
 +		case FLOW_ACTION_SAMPLE:
 +			if (flow_flag_test(flow, CT)) {
 +				NL_SET_ERR_MSG_MOD(extack, "Sample action with connection tracking is not supported");
 +				return -EOPNOTSUPP;
 +			}
 +			sample_attr.rate = act->sample.rate;
 +			sample_attr.group_num = act->sample.psample_group->group_num;
 +			if (act->sample.truncate)
 +				sample_attr.trunc_size = act->sample.trunc_size;
 +			flow_flag_set(flow, SAMPLE);
 +			break;
 +		default:
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "The offload action is not supported in FDB action");
 +			return -EOPNOTSUPP;
 +		}
 +	}
  
  	/* Forward to/from internal port can only have 1 dest */
- 	if ((netif_is_ovs_master(parse_attr->filter_dev) || esw_attr->dest_int_port) &&
+ 	if ((netif_is_ovs_master(filter_dev) || esw_attr->dest_int_port) &&
  	    esw_attr->out_count > 1) {
  		NL_SET_ERR_MSG_MOD(extack,
  				   "Rules with internal port can have only one destination");
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_GEN(esw->dev, prio_tag_required) &&
 +	    action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP) {
 +		/* For prio tag mode, replace vlan pop with rewrite vlan prio
 +		 * tag rewrite.
 +		 */
 +		action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +		err = add_vlan_prio_tag_rewrite_action(priv, parse_attr, hdrs,
 +						       &action, extack);
 +		if (err)
 +			return err;
 +	}
 +
 +	attr->action = action;
 +
 +	err = actions_prepare_mod_hdr_actions(priv, flow, attr, hdrs, extack);
++=======
+ 	/* Forward from tunnel/internal port to internal port is not supported */
+ 	if ((mlx5e_get_tc_tun(filter_dev) || netif_is_ovs_master(filter_dev)) &&
+ 	    esw_attr->dest_int_port) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Forwarding from tunnel/internal port to internal port is not supported");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	err = actions_prepare_mod_hdr_actions(priv, flow, attr, extack);
++>>>>>>> f382a2413dae (net/mlx5e: TC, Reject forwarding from internal port to internal port)
  	if (err)
  		return err;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
