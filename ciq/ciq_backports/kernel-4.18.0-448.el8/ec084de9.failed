fs/writeback.c: use rcu_barrier() to wait for inflight wb switches going into workqueue when umount

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Jiufei Xue <jiufei.xue@linux.alibaba.com>
commit ec084de929e419e51bcdafaafe567d9e7d0273b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/ec084de9.failed

synchronize_rcu() didn't wait for call_rcu() callbacks, so inode wb
switch may not go to the workqueue after synchronize_rcu().  Thus
previous scheduled switches was not finished even flushing the
workqueue, which will cause a NULL pointer dereferenced followed below.

  VFS: Busy inodes after unmount of vdd. Self-destruct in 5 seconds.  Have a nice day...
  BUG: unable to handle kernel NULL pointer dereference at 0000000000000278
    evict+0xb3/0x180
    iput+0x1b0/0x230
    inode_switch_wbs_work_fn+0x3c0/0x6a0
    worker_thread+0x4e/0x490
    ? process_one_work+0x410/0x410
    kthread+0xe6/0x100
    ret_from_fork+0x39/0x50

Replace the synchronize_rcu() call with a rcu_barrier() to wait for all
pending callbacks to finish.  And inc isw_nr_in_flight after call_rcu()
in inode_switch_wbs() to make more sense.

Link: http://lkml.kernel.org/r/20190429024108.54150-1-jiufei.xue@linux.alibaba.com
	Signed-off-by: Jiufei Xue <jiufei.xue@linux.alibaba.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Suggested-by: Tejun Heo <tj@kernel.org>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ec084de929e419e51bcdafaafe567d9e7d0273b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs-writeback.c
diff --cc fs/fs-writeback.c
index bdfe97f24a88,b16645b417d9..000000000000
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@@ -541,7 -530,10 +539,14 @@@ static void inode_switch_wbs(struct ino
  	 * Let's continue after I_WB_SWITCH is guaranteed to be visible.
  	 */
  	call_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);
++<<<<<<< HEAD
 +	return;
++=======
+ 
+ 	atomic_inc(&isw_nr_in_flight);
+ 
+ 	goto out_unlock;
++>>>>>>> ec084de929e4 (fs/writeback.c: use rcu_barrier() to wait for inflight wb switches going into workqueue when umount)
  
  out_free:
  	if (isw->new_wb)
* Unmerged path fs/fs-writeback.c
