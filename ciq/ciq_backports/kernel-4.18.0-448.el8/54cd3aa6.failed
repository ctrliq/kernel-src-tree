xfs: remove ->b_offset handling for page backed buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 54cd3aa6f8102f4648190fc93eb5dd8603de9b52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/54cd3aa6.failed

->b_offset can only be non-zero for _XBF_KMEM backed buffers, so
remove all code dealing with it for page backed buffers.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
[dgc: modified to fit this patchset]
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>

(cherry picked from commit 54cd3aa6f8102f4648190fc93eb5dd8603de9b52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf.c
diff --cc fs/xfs/xfs_buf.c
index 8e788ff1151d,f901a74d6176..000000000000
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@@ -272,51 -272,30 +272,64 @@@ _xfs_buf_alloc
  	return 0;
  }
  
 -static void
 -xfs_buf_free_pages(
 -	struct xfs_buf	*bp)
 +/*
 + *	Allocate a page array capable of holding a specified number
 + *	of pages, and point the page buf at it.
 + */
 +STATIC int
 +_xfs_buf_get_pages(
 +	struct xfs_buf		*bp,
 +	int			page_count)
  {
++<<<<<<< HEAD
 +	/* Make sure that we have a page list */
 +	if (bp->b_pages == NULL) {
 +		bp->b_page_count = page_count;
 +		if (page_count <= XB_PAGES) {
 +			bp->b_pages = bp->b_page_array;
 +		} else {
 +			bp->b_pages = kmem_alloc(sizeof(struct page *) *
 +						 page_count, KM_NOFS);
 +			if (bp->b_pages == NULL)
 +				return -ENOMEM;
 +		}
 +		memset(bp->b_pages, 0, sizeof(struct page *) * page_count);
++=======
+ 	uint		i;
+ 
+ 	ASSERT(bp->b_flags & _XBF_PAGES);
+ 
+ 	if (xfs_buf_is_vmapped(bp))
+ 		vm_unmap_ram(bp->b_addr, bp->b_page_count);
+ 
+ 	for (i = 0; i < bp->b_page_count; i++) {
+ 		if (bp->b_pages[i])
+ 			__free_page(bp->b_pages[i]);
++>>>>>>> 54cd3aa6f810 (xfs: remove ->b_offset handling for page backed buffers)
  	}
 -	if (current->reclaim_state)
 -		current->reclaim_state->reclaimed_slab += bp->b_page_count;
 +	return 0;
 +}
  
 -	if (bp->b_pages != bp->b_page_array)
 +/*
 + *	Frees b_pages if it was allocated.
 + */
 +STATIC void
 +_xfs_buf_free_pages(
 +	struct xfs_buf	*bp)
 +{
 +	if (bp->b_pages != bp->b_page_array) {
  		kmem_free(bp->b_pages);
 -	bp->b_pages = NULL;
 -	bp->b_flags &= ~_XBF_PAGES;
 +		bp->b_pages = NULL;
 +	}
  }
  
 +/*
 + *	Releases the specified buffer.
 + *
 + * 	The modification state of any associated pages is left unchanged.
 + * 	The buffer must not be on any hash - use xfs_buf_rele instead for
 + * 	hashed and refcounted buffers
 + */
  static void
  xfs_buf_free(
  	struct xfs_buf		*bp)
* Unmerged path fs/xfs/xfs_buf.c
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index 459ca34f26f5..464dc548fa23 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -167,7 +167,8 @@ struct xfs_buf {
 	atomic_t		b_pin_count;	/* pin count */
 	atomic_t		b_io_remaining;	/* #outstanding I/O requests */
 	unsigned int		b_page_count;	/* size of page array */
-	unsigned int		b_offset;	/* page offset in first page */
+	unsigned int		b_offset;	/* page offset of b_addr,
+						   only for _XBF_KMEM buffers */
 	int			b_error;	/* error code on I/O */
 
 	/*
