wifi: mac80211: Support multi link in ieee80211_recalc_min_chandef()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Andrei Otcheretianski <andrei.otcheretianski@intel.com>
commit 0cbf348a9a790d5dfbfa1b5b463f09507e7594fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/0cbf348a.failed

Recalculate min channel context for the given or all interface
links, depending on the caller. For a station state change, we
need to recalculate all of them since we don't know which link
(or multiple) it might be on.

	Signed-off-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 0cbf348a9a790d5dfbfa1b5b463f09507e7594fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ieee80211_i.h
#	net/mac80211/vht.c
diff --cc net/mac80211/ieee80211_i.h
index fef9c92d74a2,877f2441b74b..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -2430,9 -2331,12 +2430,16 @@@ u32 ieee80211_sta_get_rates(struct ieee
  			    struct ieee802_11_elems *elems,
  			    enum nl80211_band band, u32 *basic_rates);
  int __ieee80211_request_smps_mgd(struct ieee80211_sub_if_data *sdata,
 -				 struct ieee80211_link_data *link,
  				 enum ieee80211_smps_mode smps_mode);
++<<<<<<< HEAD
 +void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata);
 +void ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata);
++=======
+ void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata,
+ 			   struct ieee80211_link_data *link);
+ void ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata,
+ 				  int link_id);
++>>>>>>> 0cbf348a9a79 (wifi: mac80211: Support multi link in ieee80211_recalc_min_chandef())
  
  size_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset);
  u8 *ieee80211_ie_build_ht_cap(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,
diff --cc net/mac80211/vht.c
index bc39bec42e54,b2b09d421e8b..000000000000
--- a/net/mac80211/vht.c
+++ b/net/mac80211/vht.c
@@@ -688,11 -727,13 +688,17 @@@ void ieee80211_vht_handle_opmode(struc
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_supported_band *sband = local->hw.wiphy->bands[band];
  
 -	u32 changed = __ieee80211_vht_handle_opmode(sdata, link_sta,
 -						    opmode, band);
 +	u32 changed = __ieee80211_vht_handle_opmode(sdata, sta, opmode, band);
  
  	if (changed > 0) {
++<<<<<<< HEAD
 +		ieee80211_recalc_min_chandef(sdata);
 +		rate_control_rate_update(local, sband, sta, changed);
++=======
+ 		ieee80211_recalc_min_chandef(sdata, link_sta->link_id);
+ 		rate_control_rate_update(local, sband, link_sta->sta,
+ 					 link_sta->link_id, changed);
++>>>>>>> 0cbf348a9a79 (wifi: mac80211: Support multi link in ieee80211_recalc_min_chandef())
  	}
  }
  
* Unmerged path net/mac80211/ieee80211_i.h
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index d25b297851c4..27e1e6fd714e 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -672,7 +672,7 @@ static int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)
 	 * change, this enables driver using the updated channel context right away.
 	 */
 	if (sta->sta_state >= IEEE80211_STA_ASSOC) {
-		ieee80211_recalc_min_chandef(sta->sdata);
+		ieee80211_recalc_min_chandef(sta->sdata, -1);
 		if (!sta->sta.support_p2p_ps)
 			ieee80211_recalc_p2p_go_ps_allowed(sta->sdata);
 	}
@@ -2047,7 +2047,7 @@ int sta_info_move_state(struct sta_info *sta,
 			set_bit(WLAN_STA_AUTH, &sta->_flags);
 		} else if (sta->sta_state == IEEE80211_STA_ASSOC) {
 			clear_bit(WLAN_STA_ASSOC, &sta->_flags);
-			ieee80211_recalc_min_chandef(sta->sdata);
+			ieee80211_recalc_min_chandef(sta->sdata, -1);
 			if (!sta->sta.support_p2p_ps)
 				ieee80211_recalc_p2p_go_ps_allowed(sta->sdata);
 		}
@@ -2056,7 +2056,7 @@ int sta_info_move_state(struct sta_info *sta,
 		if (sta->sta_state == IEEE80211_STA_AUTH) {
 			set_bit(WLAN_STA_ASSOC, &sta->_flags);
 			sta->assoc_at = ktime_get_boottime_ns();
-			ieee80211_recalc_min_chandef(sta->sdata);
+			ieee80211_recalc_min_chandef(sta->sdata, -1);
 			if (!sta->sta.support_p2p_ps)
 				ieee80211_recalc_p2p_go_ps_allowed(sta->sdata);
 		} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index b3a2e7d09e77..4668c1fe9d9b 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -2823,22 +2823,48 @@ void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata)
 	mutex_unlock(&local->chanctx_mtx);
 }
 
-void ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata)
+void ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata,
+				  int link_id)
 {
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_chanctx_conf *chanctx_conf;
 	struct ieee80211_chanctx *chanctx;
+	int i;
 
 	mutex_lock(&local->chanctx_mtx);
 
-	chanctx_conf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,
-						 lockdep_is_held(&local->chanctx_mtx));
+	for (i = 0; i < ARRAY_SIZE(sdata->vif.link_conf); i++) {
+		struct ieee80211_bss_conf *bss_conf;
 
-	if (WARN_ON_ONCE(!chanctx_conf))
-		goto unlock;
+		if (link_id >= 0 && link_id != i)
+			continue;
 
-	chanctx = container_of(chanctx_conf, struct ieee80211_chanctx, conf);
-	ieee80211_recalc_chanctx_min_def(local, chanctx);
+		rcu_read_lock();
+		bss_conf = rcu_dereference(sdata->vif.link_conf[i]);
+		if (!bss_conf) {
+			rcu_read_unlock();
+			continue;
+		}
+
+		chanctx_conf = rcu_dereference_protected(bss_conf->chanctx_conf,
+							 lockdep_is_held(&local->chanctx_mtx));
+		/*
+		 * Since we hold the chanctx_mtx (checked above)
+		 * we can take the chanctx_conf pointer out of the
+		 * RCU critical section, it cannot go away without
+		 * the mutex. Just the way we reached it could - in
+		 * theory - go away, but we don't really care and
+		 * it really shouldn't happen anyway.
+		 */
+		rcu_read_unlock();
+
+		if (WARN_ON_ONCE(!chanctx_conf))
+			goto unlock;
+
+		chanctx = container_of(chanctx_conf, struct ieee80211_chanctx,
+				       conf);
+		ieee80211_recalc_chanctx_min_def(local, chanctx);
+	}
  unlock:
 	mutex_unlock(&local->chanctx_mtx);
 }
* Unmerged path net/mac80211/vht.c
