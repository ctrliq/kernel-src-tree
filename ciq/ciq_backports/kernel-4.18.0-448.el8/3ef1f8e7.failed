net/mlx5e: SHAMPO, clean MLX5E_MAX_KLM_PER_WQE macro

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Ben Ben-Ishay <benishay@nvidia.com>
commit 3ef1f8e795ba0e41fca3229258cdacf5f5bd390e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/3ef1f8e7.failed

This commit reduces unused variable from MLX5E_MAX_KLM_PER_WQE macro that
introduced by commit d7b896acbdcb ("net/mlx5e: Add support to klm_umr_wqe").

	Signed-off-by: Ben Ben-Ishay <benishay@nvidia.com>
	Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 3ef1f8e795ba0e41fca3229258cdacf5f5bd390e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/params.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/params.c
index 2b2b3c5cdbd5,66180ffb4606..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/params.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/params.c
@@@ -620,17 -668,80 +620,82 @@@ static u8 mlx5e_get_rq_log_wq_sz(void *
  	return MLX5_GET(wq, wq, log_wq_sz);
  }
  
++<<<<<<< HEAD
 +static u8 mlx5e_build_icosq_log_wq_sz(struct mlx5e_params *params,
++=======
+ /* This function calculates the maximum number of headers entries that are needed
+  * per WQE, the formula is based on the size of the reservations and the
+  * restriction we have about max packets for reservation that is equal to max
+  * headers per reservation.
+  */
+ u32 mlx5e_shampo_hd_per_wqe(struct mlx5_core_dev *mdev,
+ 			    struct mlx5e_params *params,
+ 			    struct mlx5e_rq_param *rq_param)
+ {
+ 	int resv_size = BIT(mlx5e_shampo_get_log_rsrv_size(mdev, params)) * PAGE_SIZE;
+ 	u16 num_strides = BIT(mlx5e_mpwqe_get_log_num_strides(mdev, params, NULL));
+ 	int pkt_per_resv = BIT(mlx5e_shampo_get_log_pkt_per_rsrv(mdev, params));
+ 	u8 log_stride_sz = mlx5e_mpwqe_get_log_stride_size(mdev, params, NULL);
+ 	int wqe_size = BIT(log_stride_sz) * num_strides;
+ 	u32 hd_per_wqe;
+ 
+ 	/* Assumption: hd_per_wqe % 8 == 0. */
+ 	hd_per_wqe = (wqe_size / resv_size) * pkt_per_resv;
+ 	mlx5_core_dbg(mdev, "%s hd_per_wqe = %d rsrv_size = %d wqe_size = %d pkt_per_resv = %d\n",
+ 		      __func__, hd_per_wqe, resv_size, wqe_size, pkt_per_resv);
+ 	return hd_per_wqe;
+ }
+ 
+ /* This function calculates the maximum number of headers entries that are needed
+  * for the WQ, this value is uesed to allocate the header buffer in HW, thus
+  * must be a pow of 2.
+  */
+ u32 mlx5e_shampo_hd_per_wq(struct mlx5_core_dev *mdev,
+ 			   struct mlx5e_params *params,
+ 			   struct mlx5e_rq_param *rq_param)
+ {
+ 	void *wqc = MLX5_ADDR_OF(rqc, rq_param->rqc, wq);
+ 	int wq_size = BIT(MLX5_GET(wq, wqc, log_wq_sz));
+ 	u32 hd_per_wqe, hd_per_wq;
+ 
+ 	hd_per_wqe = mlx5e_shampo_hd_per_wqe(mdev, params, rq_param);
+ 	hd_per_wq = roundup_pow_of_two(hd_per_wqe * wq_size);
+ 	return hd_per_wq;
+ }
+ 
+ static u32 mlx5e_shampo_icosq_sz(struct mlx5_core_dev *mdev,
+ 				 struct mlx5e_params *params,
+ 				 struct mlx5e_rq_param *rq_param)
+ {
+ 	int max_num_of_umr_per_wqe, max_hd_per_wqe, max_klm_per_umr, rest;
+ 	void *wqc = MLX5_ADDR_OF(rqc, rq_param->rqc, wq);
+ 	int wq_size = BIT(MLX5_GET(wq, wqc, log_wq_sz));
+ 	u32 wqebbs;
+ 
+ 	max_klm_per_umr = MLX5E_MAX_KLM_PER_WQE;
+ 	max_hd_per_wqe = mlx5e_shampo_hd_per_wqe(mdev, params, rq_param);
+ 	max_num_of_umr_per_wqe = max_hd_per_wqe / max_klm_per_umr;
+ 	rest = max_hd_per_wqe % max_klm_per_umr;
+ 	wqebbs = MLX5E_KLM_UMR_WQEBBS(max_klm_per_umr) * max_num_of_umr_per_wqe;
+ 	if (rest)
+ 		wqebbs += MLX5E_KLM_UMR_WQEBBS(rest);
+ 	wqebbs *= wq_size;
+ 	return wqebbs;
+ }
+ 
+ static u8 mlx5e_build_icosq_log_wq_sz(struct mlx5_core_dev *mdev,
+ 				      struct mlx5e_params *params,
++>>>>>>> 3ef1f8e795ba (net/mlx5e: SHAMPO, clean MLX5E_MAX_KLM_PER_WQE macro)
  				      struct mlx5e_rq_param *rqp)
  {
 -	u32 wqebbs;
 -
 -	/* MLX5_WQ_TYPE_CYCLIC */
 -	if (params->rq_wq_type != MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ)
 +	switch (params->rq_wq_type) {
 +	case MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:
 +		return max_t(u8, MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE,
 +			     order_base_2(MLX5E_UMR_WQEBBS) +
 +			     mlx5e_get_rq_log_wq_sz(rqp->rqc));
 +	default: /* MLX5_WQ_TYPE_CYCLIC */
  		return MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE;
 -
 -	wqebbs = MLX5E_UMR_WQEBBS * BIT(mlx5e_get_rq_log_wq_sz(rqp->rqc));
 -	if (params->packet_merge.type == MLX5E_PACKET_MERGE_SHAMPO)
 -		wqebbs += mlx5e_shampo_icosq_sz(mdev, params, rqp);
 -	return max_t(u8, MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE, order_base_2(wqebbs));
 +	}
  }
  
  static u8 mlx5e_build_async_icosq_log_wq_sz(struct mlx5_core_dev *mdev)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index 66ea1cbed1c1,7e05d7592bce..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -499,6 -502,155 +499,158 @@@ static void mlx5e_post_rx_mpwqe(struct 
  	mlx5_wq_ll_update_db_record(wq);
  }
  
++<<<<<<< HEAD
++=======
+ /* This function returns the size of the continuous free space inside a bitmap
+  * that starts from first and no longer than len including circular ones.
+  */
+ static int bitmap_find_window(unsigned long *bitmap, int len,
+ 			      int bitmap_size, int first)
+ {
+ 	int next_one, count;
+ 
+ 	next_one = find_next_bit(bitmap, bitmap_size, first);
+ 	if (next_one == bitmap_size) {
+ 		if (bitmap_size - first >= len)
+ 			return len;
+ 		next_one = find_next_bit(bitmap, bitmap_size, 0);
+ 		count = next_one + bitmap_size - first;
+ 	} else {
+ 		count = next_one - first;
+ 	}
+ 
+ 	return min(len, count);
+ }
+ 
+ static void build_klm_umr(struct mlx5e_icosq *sq, struct mlx5e_umr_wqe *umr_wqe,
+ 			  __be32 key, u16 offset, u16 klm_len, u16 wqe_bbs)
+ {
+ 	memset(umr_wqe, 0, offsetof(struct mlx5e_umr_wqe, inline_klms));
+ 	umr_wqe->ctrl.opmod_idx_opcode =
+ 		cpu_to_be32((sq->pc << MLX5_WQE_CTRL_WQE_INDEX_SHIFT) |
+ 			     MLX5_OPCODE_UMR);
+ 	umr_wqe->ctrl.umr_mkey = key;
+ 	umr_wqe->ctrl.qpn_ds = cpu_to_be32((sq->sqn << MLX5_WQE_CTRL_QPN_SHIFT)
+ 					    | MLX5E_KLM_UMR_DS_CNT(klm_len));
+ 	umr_wqe->uctrl.flags = MLX5_UMR_TRANSLATION_OFFSET_EN | MLX5_UMR_INLINE;
+ 	umr_wqe->uctrl.xlt_offset = cpu_to_be16(offset);
+ 	umr_wqe->uctrl.xlt_octowords = cpu_to_be16(klm_len);
+ 	umr_wqe->uctrl.mkey_mask     = cpu_to_be64(MLX5_MKEY_MASK_FREE);
+ }
+ 
+ static int mlx5e_build_shampo_hd_umr(struct mlx5e_rq *rq,
+ 				     struct mlx5e_icosq *sq,
+ 				     u16 klm_entries, u16 index)
+ {
+ 	struct mlx5e_shampo_hd *shampo = rq->mpwqe.shampo;
+ 	u16 entries, pi, header_offset, err, wqe_bbs, new_entries;
+ 	u32 lkey = rq->mdev->mlx5e_res.hw_objs.mkey;
+ 	struct page *page = shampo->last_page;
+ 	u64 addr = shampo->last_addr;
+ 	struct mlx5e_dma_info *dma_info;
+ 	struct mlx5e_umr_wqe *umr_wqe;
+ 	int headroom, i;
+ 
+ 	headroom = rq->buff.headroom;
+ 	new_entries = klm_entries - (shampo->pi & (MLX5_UMR_KLM_ALIGNMENT - 1));
+ 	entries = ALIGN(klm_entries, MLX5_UMR_KLM_ALIGNMENT);
+ 	wqe_bbs = MLX5E_KLM_UMR_WQEBBS(entries);
+ 	pi = mlx5e_icosq_get_next_pi(sq, wqe_bbs);
+ 	umr_wqe = mlx5_wq_cyc_get_wqe(&sq->wq, pi);
+ 	build_klm_umr(sq, umr_wqe, shampo->key, index, entries, wqe_bbs);
+ 
+ 	for (i = 0; i < entries; i++, index++) {
+ 		dma_info = &shampo->info[index];
+ 		if (i >= klm_entries || (index < shampo->pi && shampo->pi - index <
+ 					 MLX5_UMR_KLM_ALIGNMENT))
+ 			goto update_klm;
+ 		header_offset = (index & (MLX5E_SHAMPO_WQ_HEADER_PER_PAGE - 1)) <<
+ 			MLX5E_SHAMPO_LOG_MAX_HEADER_ENTRY_SIZE;
+ 		if (!(header_offset & (PAGE_SIZE - 1))) {
+ 			err = mlx5e_page_alloc(rq, dma_info);
+ 			if (unlikely(err))
+ 				goto err_unmap;
+ 			addr = dma_info->addr;
+ 			page = dma_info->page;
+ 		} else {
+ 			dma_info->addr = addr + header_offset;
+ 			dma_info->page = page;
+ 		}
+ 
+ update_klm:
+ 		umr_wqe->inline_klms[i].bcount =
+ 			cpu_to_be32(MLX5E_RX_MAX_HEAD);
+ 		umr_wqe->inline_klms[i].key    = cpu_to_be32(lkey);
+ 		umr_wqe->inline_klms[i].va     =
+ 			cpu_to_be64(dma_info->addr + headroom);
+ 	}
+ 
+ 	sq->db.wqe_info[pi] = (struct mlx5e_icosq_wqe_info) {
+ 		.wqe_type	= MLX5E_ICOSQ_WQE_SHAMPO_HD_UMR,
+ 		.num_wqebbs	= wqe_bbs,
+ 		.shampo.len	= new_entries,
+ 	};
+ 
+ 	shampo->pi = (shampo->pi + new_entries) & (shampo->hd_per_wq - 1);
+ 	shampo->last_page = page;
+ 	shampo->last_addr = addr;
+ 	sq->pc += wqe_bbs;
+ 	sq->doorbell_cseg = &umr_wqe->ctrl;
+ 
+ 	return 0;
+ 
+ err_unmap:
+ 	while (--i >= 0) {
+ 		dma_info = &shampo->info[--index];
+ 		if (!(i & (MLX5E_SHAMPO_WQ_HEADER_PER_PAGE - 1))) {
+ 			dma_info->addr = ALIGN_DOWN(dma_info->addr, PAGE_SIZE);
+ 			mlx5e_page_release(rq, dma_info, true);
+ 		}
+ 	}
+ 	rq->stats->buff_alloc_err++;
+ 	return err;
+ }
+ 
+ static int mlx5e_alloc_rx_hd_mpwqe(struct mlx5e_rq *rq)
+ {
+ 	struct mlx5e_shampo_hd *shampo = rq->mpwqe.shampo;
+ 	u16 klm_entries, num_wqe, index, entries_before;
+ 	struct mlx5e_icosq *sq = rq->icosq;
+ 	int i, err, max_klm_entries, len;
+ 
+ 	max_klm_entries = MLX5E_MAX_KLM_PER_WQE;
+ 	klm_entries = bitmap_find_window(shampo->bitmap,
+ 					 shampo->hd_per_wqe,
+ 					 shampo->hd_per_wq, shampo->pi);
+ 	if (!klm_entries)
+ 		return 0;
+ 
+ 	klm_entries += (shampo->pi & (MLX5_UMR_KLM_ALIGNMENT - 1));
+ 	index = ALIGN_DOWN(shampo->pi, MLX5_UMR_KLM_ALIGNMENT);
+ 	entries_before = shampo->hd_per_wq - index;
+ 
+ 	if (unlikely(entries_before < klm_entries))
+ 		num_wqe = DIV_ROUND_UP(entries_before, max_klm_entries) +
+ 			  DIV_ROUND_UP(klm_entries - entries_before, max_klm_entries);
+ 	else
+ 		num_wqe = DIV_ROUND_UP(klm_entries, max_klm_entries);
+ 
+ 	for (i = 0; i < num_wqe; i++) {
+ 		len = (klm_entries > max_klm_entries) ? max_klm_entries :
+ 							klm_entries;
+ 		if (unlikely(index + len > shampo->hd_per_wq))
+ 			len = shampo->hd_per_wq - index;
+ 		err = mlx5e_build_shampo_hd_umr(rq, sq, len, index);
+ 		if (unlikely(err))
+ 			return err;
+ 		index = (index + len) & (rq->mpwqe.shampo->hd_per_wq - 1);
+ 		klm_entries -= len;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 3ef1f8e795ba (net/mlx5e: SHAMPO, clean MLX5E_MAX_KLM_PER_WQE macro)
  static int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, u16 ix)
  {
  	struct mlx5e_mpw_info *wi = &rq->mpwqe.info[ix];
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index e5a013977e60..8ce6132e997b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -168,7 +168,7 @@ struct page_pool;
 #define MLX5E_KLM_ENTRIES_PER_WQE(wqe_size)\
 	ALIGN_DOWN(MLX5E_KLM_MAX_ENTRIES_PER_WQE(wqe_size), MLX5_UMR_KLM_ALIGNMENT)
 
-#define MLX5E_MAX_KLM_PER_WQE(mdev) \
+#define MLX5E_MAX_KLM_PER_WQE \
 	MLX5E_KLM_ENTRIES_PER_WQE(MLX5E_TX_MPW_MAX_NUM_DS << MLX5_MKEY_BSF_OCTO_SIZE)
 
 #define MLX5E_MSG_LEVEL			NETIF_MSG_LINK
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/params.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
