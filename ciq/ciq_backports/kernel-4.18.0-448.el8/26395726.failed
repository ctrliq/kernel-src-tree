ice: switch: dynamically add VLAN headers to dummy packets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Martyna Szapar-Mudlaw <martyna.szapar-mudlaw@intel.com>
commit 263957263a0008508b34425dd69722e01e2e4554
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/26395726.failed

Enable the support of creating all kinds of declared dummy packets
with the VLAN tags by inserting VLAN headers (single VLAN and QinQ
cases) if needed.
Decrease the number of declared dummy packets and increase in the
possible packet's combinations for adding switch rules.

This change enables support of creating filters that match both on
VLAN + tunnels properties in switchdev.

	Signed-off-by: Martyna Szapar-Mudlaw <martyna.szapar-mudlaw@intel.com>
	Reviewed-by: Alexander Lobakin <alexandr.lobakin@intel.com>
	Tested-by: Sandeep Penigalapati <sandeep.penigalapati@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 263957263a0008508b34425dd69722e01e2e4554)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_switch.c
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 7b15835f7479,2d1274774987..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -30,12 -30,66 +30,73 @@@ static const u8 dummy_eth_header[DUMMY_
  							0x2, 0, 0, 0, 0, 0,
  							0x81, 0, 0, 0};
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	ICE_PKT_OUTER_IPV6	= BIT(0),
+ 	ICE_PKT_TUN_GTPC	= BIT(1),
+ 	ICE_PKT_TUN_GTPU	= BIT(2),
+ 	ICE_PKT_TUN_NVGRE	= BIT(3),
+ 	ICE_PKT_TUN_UDP		= BIT(4),
+ 	ICE_PKT_INNER_IPV6	= BIT(5),
+ 	ICE_PKT_INNER_TCP	= BIT(6),
+ 	ICE_PKT_INNER_UDP	= BIT(7),
+ 	ICE_PKT_GTP_NOPAY	= BIT(8),
+ 	ICE_PKT_KMALLOC		= BIT(9),
+ };
+ 
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  struct ice_dummy_pkt_offsets {
  	enum ice_protocol_type type;
  	u16 offset; /* ICE_PROTOCOL_LAST indicates end of list */
  };
  
++<<<<<<< HEAD
 +static const struct ice_dummy_pkt_offsets dummy_gre_tcp_packet_offsets[] = {
++=======
+ struct ice_dummy_pkt_profile {
+ 	const struct ice_dummy_pkt_offsets *offsets;
+ 	const u8 *pkt;
+ 	u32 match;
+ 	u16 pkt_len;
+ 	u16 offsets_len;
+ };
+ 
+ #define ICE_DECLARE_PKT_OFFSETS(type)					\
+ 	static const struct ice_dummy_pkt_offsets			\
+ 	ice_dummy_##type##_packet_offsets[]
+ 
+ #define ICE_DECLARE_PKT_TEMPLATE(type)					\
+ 	static const u8 ice_dummy_##type##_packet[]
+ 
+ #define ICE_PKT_PROFILE(type, m) {					\
+ 	.match		= (m),						\
+ 	.pkt		= ice_dummy_##type##_packet,			\
+ 	.pkt_len	= sizeof(ice_dummy_##type##_packet),		\
+ 	.offsets	= ice_dummy_##type##_packet_offsets,		\
+ 	.offsets_len	= sizeof(ice_dummy_##type##_packet_offsets),	\
+ }
+ 
+ ICE_DECLARE_PKT_OFFSETS(vlan) = {
+ 	{ ICE_VLAN_OFOS,        12 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(vlan) = {
+ 	0x81, 0x00, 0x00, 0x00, /* ICE_VLAN_OFOS 12 */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(qinq) = {
+ 	{ ICE_VLAN_EX,          12 },
+ 	{ ICE_VLAN_IN,          16 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(qinq) = {
+ 	0x91, 0x00, 0x00, 0x00, /* ICE_VLAN_EX 12 */
+ 	0x81, 0x00, 0x00, 0x00, /* ICE_VLAN_IN 16 */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(gre_tcp) = {
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  	{ ICE_MAC_OFOS,		0 },
  	{ ICE_ETYPE_OL,		12 },
  	{ ICE_IPV4_OFOS,	14 },
@@@ -476,40 -526,8 +537,43 @@@ static const u8 dummy_udp_packet[] = 
  	0x00, 0x00,	/* 2 bytes for 4 byte alignment */
  };
  
++<<<<<<< HEAD
 +/* offset info for MAC + VLAN + IPv4 + UDP dummy packet */
 +static const struct ice_dummy_pkt_offsets dummy_vlan_udp_packet_offsets[] = {
 +	{ ICE_MAC_OFOS,		0 },
 +	{ ICE_VLAN_OFOS,	12 },
 +	{ ICE_ETYPE_OL,		16 },
 +	{ ICE_IPV4_OFOS,	18 },
 +	{ ICE_UDP_ILOS,		38 },
 +	{ ICE_PROTOCOL_LAST,	0 },
 +};
 +
 +/* C-tag (801.1Q), IPv4:UDP dummy packet */
 +static const u8 dummy_vlan_udp_packet[] = {
 +	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x81, 0x00, 0x00, 0x00, /* ICE_VLAN_OFOS 12 */
 +
 +	0x08, 0x00,		/* ICE_ETYPE_OL 16 */
 +
 +	0x45, 0x00, 0x00, 0x1c, /* ICE_IPV4_OFOS 18 */
 +	0x00, 0x01, 0x00, 0x00,
 +	0x00, 0x11, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x00, 0x00, 0x00, 0x00, /* ICE_UDP_ILOS 38 */
 +	0x00, 0x08, 0x00, 0x00,
 +
 +	0x00, 0x00,	/* 2 bytes for 4 byte alignment */
 +};
 +
++=======
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  /* offset info for MAC + IPv4 + TCP dummy packet */
 -ICE_DECLARE_PKT_OFFSETS(tcp) = {
 +static const struct ice_dummy_pkt_offsets dummy_tcp_packet_offsets[] = {
  	{ ICE_MAC_OFOS,		0 },
  	{ ICE_ETYPE_OL,		12 },
  	{ ICE_IPV4_OFOS,	14 },
@@@ -540,42 -558,7 +604,46 @@@ static const u8 dummy_tcp_packet[] = 
  	0x00, 0x00,	/* 2 bytes for 4 byte alignment */
  };
  
++<<<<<<< HEAD
 +/* offset info for MAC + VLAN (C-tag, 802.1Q) + IPv4 + TCP dummy packet */
 +static const struct ice_dummy_pkt_offsets dummy_vlan_tcp_packet_offsets[] = {
 +	{ ICE_MAC_OFOS,		0 },
 +	{ ICE_VLAN_OFOS,	12 },
 +	{ ICE_ETYPE_OL,		16 },
 +	{ ICE_IPV4_OFOS,	18 },
 +	{ ICE_TCP_IL,		38 },
 +	{ ICE_PROTOCOL_LAST,	0 },
 +};
 +
 +/* C-tag (801.1Q), IPv4:TCP dummy packet */
 +static const u8 dummy_vlan_tcp_packet[] = {
 +	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x81, 0x00, 0x00, 0x00,	/* ICE_VLAN_OFOS 12 */
 +
 +	0x08, 0x00,		/* ICE_ETYPE_OL 16 */
 +
 +	0x45, 0x00, 0x00, 0x28, /* ICE_IPV4_OFOS 18 */
 +	0x00, 0x01, 0x00, 0x00,
 +	0x00, 0x06, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x00, 0x00, 0x00, 0x00, /* ICE_TCP_IL 38 */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x50, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x00, 0x00,	/* 2 bytes for 4 byte alignment */
 +};
 +
 +static const struct ice_dummy_pkt_offsets dummy_tcp_ipv6_packet_offsets[] = {
++=======
+ ICE_DECLARE_PKT_OFFSETS(tcp_ipv6) = {
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  	{ ICE_MAC_OFOS,		0 },
  	{ ICE_ETYPE_OL,		12 },
  	{ ICE_IPV6_OFOS,	14 },
@@@ -610,49 -593,8 +678,52 @@@ static const u8 dummy_tcp_ipv6_packet[
  	0x00, 0x00, /* 2 bytes for 4 byte alignment */
  };
  
++<<<<<<< HEAD
 +/* C-tag (802.1Q): IPv6 + TCP */
 +static const struct ice_dummy_pkt_offsets
 +dummy_vlan_tcp_ipv6_packet_offsets[] = {
 +	{ ICE_MAC_OFOS,		0 },
 +	{ ICE_VLAN_OFOS,	12 },
 +	{ ICE_ETYPE_OL,		16 },
 +	{ ICE_IPV6_OFOS,	18 },
 +	{ ICE_TCP_IL,		58 },
 +	{ ICE_PROTOCOL_LAST,	0 },
 +};
 +
 +/* C-tag (802.1Q), IPv6 + TCP dummy packet */
 +static const u8 dummy_vlan_tcp_ipv6_packet[] = {
 +	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x81, 0x00, 0x00, 0x00,	/* ICE_VLAN_OFOS 12 */
 +
 +	0x86, 0xDD,		/* ICE_ETYPE_OL 16 */
 +
 +	0x60, 0x00, 0x00, 0x00, /* ICE_IPV6_OFOS 18 */
 +	0x00, 0x14, 0x06, 0x00, /* Next header is TCP */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x00, 0x00, 0x00, 0x00, /* ICE_TCP_IL 58 */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x50, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x00, 0x00, /* 2 bytes for 4 byte alignment */
 +};
 +
++=======
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  /* IPv6 + UDP */
 -ICE_DECLARE_PKT_OFFSETS(udp_ipv6) = {
 +static const struct ice_dummy_pkt_offsets dummy_udp_ipv6_packet_offsets[] = {
  	{ ICE_MAC_OFOS,		0 },
  	{ ICE_ETYPE_OL,		12 },
  	{ ICE_IPV6_OFOS,	14 },
@@@ -688,47 -630,8 +759,50 @@@ static const u8 dummy_udp_ipv6_packet[
  	0x00, 0x00, /* 2 bytes for 4 byte alignment */
  };
  
++<<<<<<< HEAD
 +/* C-tag (802.1Q): IPv6 + UDP */
 +static const struct ice_dummy_pkt_offsets
 +dummy_vlan_udp_ipv6_packet_offsets[] = {
 +	{ ICE_MAC_OFOS,		0 },
 +	{ ICE_VLAN_OFOS,	12 },
 +	{ ICE_ETYPE_OL,		16 },
 +	{ ICE_IPV6_OFOS,	18 },
 +	{ ICE_UDP_ILOS,		58 },
 +	{ ICE_PROTOCOL_LAST,	0 },
 +};
 +
 +/* C-tag (802.1Q), IPv6 + UDP dummy packet */
 +static const u8 dummy_vlan_udp_ipv6_packet[] = {
 +	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x81, 0x00, 0x00, 0x00,/* ICE_VLAN_OFOS 12 */
 +
 +	0x86, 0xDD,		/* ICE_ETYPE_OL 16 */
 +
 +	0x60, 0x00, 0x00, 0x00, /* ICE_IPV6_OFOS 18 */
 +	0x00, 0x08, 0x11, 0x00, /* Next header UDP */
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00,
 +
 +	0x00, 0x00, 0x00, 0x00, /* ICE_UDP_ILOS 58 */
 +	0x00, 0x08, 0x00, 0x00,
 +
 +	0x00, 0x00, /* 2 bytes for 4 byte alignment */
 +};
 +
++=======
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  /* Outer IPv4 + Outer UDP + GTP + Inner IPv4 + Inner TCP */
 -ICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4_tcp) = {
 +static const
 +struct ice_dummy_pkt_offsets dummy_ipv4_gtpu_ipv4_tcp_packet_offsets[] = {
  	{ ICE_MAC_OFOS,		0 },
  	{ ICE_IPV4_OFOS,	14 },
  	{ ICE_UDP_OF,		34 },
@@@ -1215,18 -1109,57 +1289,72 @@@ static const u8 dummy_ipv6_gtp_packet[
  	0x00, 0x00,
  };
  
++<<<<<<< HEAD
 +#define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr) + \
 +	 (DUMMY_ETH_HDR_LEN * \
 +	  sizeof(((struct ice_sw_rule_lkup_rx_tx *)0)->hdr[0])))
 +#define ICE_SW_RULE_RX_TX_NO_HDR_SIZE \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr))
 +#define ICE_SW_RULE_LG_ACT_SIZE(n) \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lg_act.act) + \
 +	 ((n) * sizeof(((struct ice_sw_rule_lg_act *)0)->act[0])))
 +#define ICE_SW_RULE_VSI_LIST_SIZE(n) \
 +	(offsetof(struct ice_aqc_sw_rules_elem, pdata.vsi_list.vsi) + \
 +	 ((n) * sizeof(((struct ice_sw_rule_vsi_list *)0)->vsi[0])))
++=======
+ static const struct ice_dummy_pkt_profile ice_dummy_pkt_profiles[] = {
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPU | ICE_PKT_OUTER_IPV6 |
+ 				  ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPU | ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU),
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPC | ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPC),
+ 	ICE_PKT_PROFILE(gre_ipv6_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6 |
+ 				      ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_ipv6_udp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(gre_udp, ICE_PKT_TUN_NVGRE),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_tcp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6 |
+ 					  ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_tcp, ICE_PKT_TUN_UDP | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_udp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(udp_tun_udp, ICE_PKT_TUN_UDP),
+ 	ICE_PKT_PROFILE(udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(udp, ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(tcp_ipv6, ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(tcp, 0),
+ };
+ 
+ #define ICE_SW_RULE_RX_TX_HDR_SIZE(s, l)	struct_size((s), hdr_data, (l))
+ #define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE(s)	\
+ 	ICE_SW_RULE_RX_TX_HDR_SIZE((s), DUMMY_ETH_HDR_LEN)
+ #define ICE_SW_RULE_RX_TX_NO_HDR_SIZE(s)	\
+ 	ICE_SW_RULE_RX_TX_HDR_SIZE((s), 0)
+ #define ICE_SW_RULE_LG_ACT_SIZE(s, n)		struct_size((s), act, (n))
+ #define ICE_SW_RULE_VSI_LIST_SIZE(s, n)		struct_size((s), vsi, (n))
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  
  /* this is a recipe to profile association bitmap */
  static DECLARE_BITMAP(recipe_to_profile[ICE_MAX_NUM_RECIPES],
@@@ -5428,29 -5523,47 +5629,43 @@@ ice_dummy_packet_add_vlan(const struct 
   *	   structure per protocol header
   * @lkups_cnt: number of protocols
   * @tun_type: tunnel type
 - *
 - * Returns the &ice_dummy_pkt_profile corresponding to these lookup params.
 + * @pkt: dummy packet to fill according to filter match criteria
 + * @pkt_len: packet length of dummy packet
 + * @offsets: pointer to receive the pointer to the offsets for the packet
   */
 -static const struct ice_dummy_pkt_profile *
 +static void
  ice_find_dummy_packet(struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,
 -		      enum ice_sw_tunnel_type tun_type)
 +		      enum ice_sw_tunnel_type tun_type,
 +		      const u8 **pkt, u16 *pkt_len,
 +		      const struct ice_dummy_pkt_offsets **offsets)
  {
++<<<<<<< HEAD
 +	bool inner_tcp = false, inner_udp = false, outer_ipv6 = false;
 +	bool vlan = false, inner_ipv6 = false, gtp_no_pay = false;
++=======
+ 	const struct ice_dummy_pkt_profile *ret = ice_dummy_pkt_profiles;
+ 	u32 match = 0, vlan_count = 0;
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  	u16 i;
  
 -	switch (tun_type) {
 -	case ICE_SW_TUN_GTPC:
 -		match |= ICE_PKT_TUN_GTPC;
 -		break;
 -	case ICE_SW_TUN_GTPU:
 -		match |= ICE_PKT_TUN_GTPU;
 -		break;
 -	case ICE_SW_TUN_NVGRE:
 -		match |= ICE_PKT_TUN_NVGRE;
 -		break;
 -	case ICE_SW_TUN_GENEVE:
 -	case ICE_SW_TUN_VXLAN:
 -		match |= ICE_PKT_TUN_UDP;
 -		break;
 -	default:
 -		break;
 -	}
 -
  	for (i = 0; i < lkups_cnt; i++) {
  		if (lkups[i].type == ICE_UDP_ILOS)
 -			match |= ICE_PKT_INNER_UDP;
 +			inner_udp = true;
  		else if (lkups[i].type == ICE_TCP_IL)
 -			match |= ICE_PKT_INNER_TCP;
 +			inner_tcp = true;
  		else if (lkups[i].type == ICE_IPV6_OFOS)
++<<<<<<< HEAD
 +			outer_ipv6 = true;
 +		else if (lkups[i].type == ICE_VLAN_OFOS)
 +			vlan = true;
++=======
+ 			match |= ICE_PKT_OUTER_IPV6;
+ 		else if (lkups[i].type == ICE_VLAN_OFOS ||
+ 			 lkups[i].type == ICE_VLAN_EX)
+ 			vlan_count++;
+ 		else if (lkups[i].type == ICE_VLAN_IN)
+ 			vlan_count++;
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  		else if (lkups[i].type == ICE_ETYPE_OL &&
  			 lkups[i].h_u.ethertype.ethtype_id ==
  				cpu_to_be16(ICE_IPV6_ETHER_ID) &&
@@@ -5462,178 -5575,20 +5677,185 @@@
  				cpu_to_be16(ICE_IPV6_ETHER_ID) &&
  			 lkups[i].m_u.ethertype.ethtype_id ==
  				cpu_to_be16(0xFFFF))
 -			match |= ICE_PKT_INNER_IPV6;
 +			inner_ipv6 = true;
  		else if (lkups[i].type == ICE_IPV6_IL)
 -			match |= ICE_PKT_INNER_IPV6;
 +			inner_ipv6 = true;
  		else if (lkups[i].type == ICE_GTP_NO_PAY)
 -			match |= ICE_PKT_GTP_NOPAY;
 +			gtp_no_pay = true;
 +	}
 +
 +	if (tun_type == ICE_SW_TUN_GTPU) {
 +		if (outer_ipv6) {
 +			if (gtp_no_pay) {
 +				*pkt = dummy_ipv6_gtp_packet;
 +				*pkt_len = sizeof(dummy_ipv6_gtp_packet);
 +				*offsets = dummy_ipv6_gtp_no_pay_packet_offsets;
 +			} else if (inner_ipv6) {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv6_gtpu_ipv6_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv6_gtpu_ipv6_udp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv6_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv6_gtpu_ipv6_tcp_packet;
 +					*pkt_len = sizeof(dummy_ipv6_gtpu_ipv6_tcp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv6_tcp_packet_offsets;
 +				}
 +			} else {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv6_gtpu_ipv4_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv6_gtpu_ipv4_udp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv4_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv6_gtpu_ipv4_tcp_packet;
 +				*pkt_len = sizeof(dummy_ipv6_gtpu_ipv4_tcp_packet);
 +					*offsets = dummy_ipv6_gtpu_ipv4_tcp_packet_offsets;
 +				}
 +			}
 +		} else {
 +			if (gtp_no_pay) {
 +				*pkt = dummy_ipv4_gtpu_ipv4_packet;
 +				*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_packet);
 +				*offsets = dummy_ipv4_gtp_no_pay_packet_offsets;
 +			} else if (inner_ipv6) {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv4_gtpu_ipv6_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv6_udp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv6_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv4_gtpu_ipv6_tcp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv6_tcp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv6_tcp_packet_offsets;
 +				}
 +			} else {
 +				if (inner_udp) {
 +					*pkt = dummy_ipv4_gtpu_ipv4_udp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_udp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv4_udp_packet_offsets;
 +				} else {
 +					*pkt = dummy_ipv4_gtpu_ipv4_tcp_packet;
 +					*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_tcp_packet);
 +					*offsets = dummy_ipv4_gtpu_ipv4_tcp_packet_offsets;
 +				}
 +			}
 +		}
 +		return;
 +	}
 +
++<<<<<<< HEAD
 +	if (tun_type == ICE_SW_TUN_GTPC) {
 +		if (outer_ipv6) {
 +			*pkt = dummy_ipv6_gtp_packet;
 +			*pkt_len = sizeof(dummy_ipv6_gtp_packet);
 +			*offsets = dummy_ipv6_gtp_no_pay_packet_offsets;
 +		} else {
 +			*pkt = dummy_ipv4_gtpu_ipv4_packet;
 +			*pkt_len = sizeof(dummy_ipv4_gtpu_ipv4_packet);
 +			*offsets = dummy_ipv4_gtp_no_pay_packet_offsets;
 +		}
 +		return;
  	}
  
 -	while (ret->match && (match & ret->match) != ret->match)
 -		ret++;
 +	if (tun_type == ICE_SW_TUN_NVGRE) {
 +		if (inner_tcp && inner_ipv6) {
 +			*pkt = dummy_gre_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_tcp_packet);
 +			*offsets = dummy_gre_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_tcp) {
 +			*pkt = dummy_gre_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_tcp_packet);
 +			*offsets = dummy_gre_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_ipv6) {
 +			*pkt = dummy_gre_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_udp_packet);
 +			*offsets = dummy_gre_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_gre_udp_packet;
 +		*pkt_len = sizeof(dummy_gre_udp_packet);
 +		*offsets = dummy_gre_udp_packet_offsets;
 +		return;
 +	}
  
 +	if (tun_type == ICE_SW_TUN_VXLAN ||
 +	    tun_type == ICE_SW_TUN_GENEVE) {
 +		if (inner_tcp && inner_ipv6) {
 +			*pkt = dummy_udp_tun_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_tcp_packet);
 +			*offsets = dummy_udp_tun_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_tcp) {
 +			*pkt = dummy_udp_tun_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_tcp_packet);
 +			*offsets = dummy_udp_tun_tcp_packet_offsets;
 +			return;
 +		}
 +		if (inner_ipv6) {
 +			*pkt = dummy_udp_tun_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_udp_packet);
 +			*offsets = dummy_udp_tun_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_tun_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_tun_udp_packet);
 +		*offsets = dummy_udp_tun_udp_packet_offsets;
 +		return;
 +	}
 +
 +	if (inner_udp && !outer_ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_packet);
 +			*offsets = dummy_vlan_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_packet);
 +		*offsets = dummy_udp_packet_offsets;
 +		return;
 +	} else if (inner_udp && outer_ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_ipv6_packet);
 +			*offsets = dummy_vlan_udp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_udp_ipv6_packet);
 +		*offsets = dummy_udp_ipv6_packet_offsets;
 +		return;
 +	} else if ((inner_tcp && outer_ipv6) || outer_ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_tcp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_tcp_ipv6_packet);
 +			*offsets = dummy_vlan_tcp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_tcp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_tcp_ipv6_packet);
 +		*offsets = dummy_tcp_ipv6_packet_offsets;
 +		return;
 +	}
 +
 +	if (vlan) {
 +		*pkt = dummy_vlan_tcp_packet;
 +		*pkt_len = sizeof(dummy_vlan_tcp_packet);
 +		*offsets = dummy_vlan_tcp_packet_offsets;
 +	} else {
 +		*pkt = dummy_tcp_packet;
 +		*pkt_len = sizeof(dummy_tcp_packet);
 +		*offsets = dummy_tcp_packet_offsets;
 +	}
++=======
+ 	if (vlan_count != 0)
+ 		ret = ice_dummy_packet_add_vlan(ret, vlan_count);
+ 
+ 	return ret;
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  }
  
  /**
@@@ -6001,16 -5986,16 +6223,26 @@@ ice_add_adv_rule(struct ice_hw *hw, str
  				word_cnt++;
  	}
  
 -	if (!word_cnt)
 +	if (!word_cnt || word_cnt > ICE_MAX_CHAIN_WORDS)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	/* make sure that we can locate a dummy packet */
 +	ice_find_dummy_packet(lkups, lkups_cnt, rinfo->tun_type, &pkt, &pkt_len,
 +			      &pkt_offsets);
 +	if (!pkt) {
 +		status = -EINVAL;
 +		goto err_ice_add_adv_rule;
 +	}
++=======
+ 	if (word_cnt > ICE_MAX_CHAIN_WORDS)
+ 		return -ENOSPC;
+ 
+ 	/* locate a dummy packet */
+ 	profile = ice_find_dummy_packet(lkups, lkups_cnt, rinfo->tun_type);
+ 	if (IS_ERR(profile))
+ 		return PTR_ERR(profile);
++>>>>>>> 263957263a00 (ice: switch: dynamically add VLAN headers to dummy packets)
  
  	if (!(rinfo->sw_act.fltr_act == ICE_FWD_TO_VSI ||
  	      rinfo->sw_act.fltr_act == ICE_FWD_TO_Q ||
@@@ -6049,12 -6038,14 +6285,14 @@@
  			added_entry->rule_id = m_entry->rule_info.fltr_rule_id;
  			added_entry->vsi_handle = rinfo->sw_act.vsi_handle;
  		}
- 		return status;
+ 		goto free_pkt_profile;
  	}
 -	rule_buf_sz = ICE_SW_RULE_RX_TX_HDR_SIZE(s_rule, profile->pkt_len);
 +	rule_buf_sz = ICE_SW_RULE_RX_TX_NO_HDR_SIZE + pkt_len;
  	s_rule = kzalloc(rule_buf_sz, GFP_KERNEL);
- 	if (!s_rule)
- 		return -ENOMEM;
+ 	if (!s_rule) {
+ 		status = -ENOMEM;
+ 		goto free_pkt_profile;
+ 	}
  	if (!rinfo->flags_info.act_valid) {
  		act |= ICE_SINGLE_ACT_LAN_ENABLE;
  		act |= ICE_SINGLE_ACT_LB_ENABLE;
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
