crypto: api - allow algs only in specific constructions in FIPS mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Nicolai Stange <nstange@suse.de>
commit d6097b8d5d55f26cd2244e7e7f00a5a077772a91
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/d6097b8d.failed

Currently we do not distinguish between algorithms that fail on
the self-test vs. those which are disabled in FIPS mode (not allowed).
Both are marked as having failed the self-test.

Recently the need arose to allow the usage of certain algorithms only
as arguments to specific template instantiations in FIPS mode. For
example, standalone "dh" must be blocked, but e.g. "ffdhe2048(dh)" is
allowed. Other potential use cases include "cbcmac(aes)", which must
only be used with ccm(), or "ghash", which must be used only for
gcm().

This patch allows this scenario by adding a new flag FIPS_INTERNAL to
indicate those algorithms that are not FIPS-allowed. They can then be
used as template arguments only, i.e. when looked up via
crypto_grab_spawn() to be more specific. The FIPS_INTERNAL bit gets
propagated upwards recursively into the surrounding template
instances, until the construction eventually matches an explicit
testmgr entry with ->fips_allowed being set, if any.

The behaviour to skip !->fips_allowed self-test executions in FIPS
mode will be retained. Note that this effectively means that
FIPS_INTERNAL algorithms are handled very similarly to the INTERNAL
ones in this regard. It is expected that the FIPS_INTERNAL algorithms
will receive sufficient testing when the larger constructions they're
a part of, if any, get exercised by testmgr.

Note that as a side-effect of this patch algorithms which are not
FIPS-allowed will now return ENOENT instead of ELIBBAD. Hopefully
this is not an issue as some people were relying on this already.

Link: https://lore.kernel.org/r/YeEVSaMEVJb3cQkq@gondor.apana.org.au
Originally-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: Nicolai Stange <nstange@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit d6097b8d5d55f26cd2244e7e7f00a5a077772a91)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/algapi.c
diff --cc crypto/algapi.c
index 41fc6d2fd17e,53c5149e6abf..000000000000
--- a/crypto/algapi.c
+++ b/crypto/algapi.c
@@@ -578,8 -641,9 +587,14 @@@ int crypto_register_instance(struct cry
  		spawn->inst = inst;
  		spawn->registered = true;
  
++<<<<<<< HEAD
 +		if (spawn->dropref)
 +			crypto_mod_put(spawn->alg);
++=======
+ 		fips_internal |= spawn->alg->cra_flags;
+ 
+ 		crypto_mod_put(spawn->alg);
++>>>>>>> d6097b8d5d55 (crypto: api - allow algs only in specific constructions in FIPS mode)
  
  		spawn = next;
  	}
@@@ -631,10 -698,14 +648,17 @@@ int crypto_init_spawn(struct crypto_spa
  	if (WARN_ON_ONCE(inst == NULL))
  		return -EINVAL;
  
 -	/* Allow the result of crypto_attr_alg_name() to be passed directly */
 -	if (IS_ERR(name))
 -		return PTR_ERR(name);
 +	spawn->next = inst->spawns;
 +	inst->spawns = spawn;
  
++<<<<<<< HEAD
 +	spawn->mask = mask;
++=======
+ 	alg = crypto_find_alg(name, spawn->frontend,
+ 			      type | CRYPTO_ALG_FIPS_INTERNAL, mask);
+ 	if (IS_ERR(alg))
+ 		return PTR_ERR(alg);
++>>>>>>> d6097b8d5d55 (crypto: api - allow algs only in specific constructions in FIPS mode)
  
  	down_write(&crypto_alg_sem);
  	if (!crypto_is_moribund(alg)) {
* Unmerged path crypto/algapi.c
diff --git a/crypto/api.c b/crypto/api.c
index 731bf9a0003d..f2675a9882ae 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -186,6 +186,8 @@ static struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)
 	else if (crypto_is_test_larval(larval) &&
 		 !(alg->cra_flags & CRYPTO_ALG_TESTED))
 		alg = ERR_PTR(-EAGAIN);
+	else if (alg->cra_flags & CRYPTO_ALG_FIPS_INTERNAL)
+		alg = ERR_PTR(-EAGAIN);
 	else if (!crypto_mod_get(alg))
 		alg = ERR_PTR(-EAGAIN);
 	crypto_mod_put(&larval->alg);
@@ -196,6 +198,7 @@ static struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)
 static struct crypto_alg *crypto_alg_lookup(const char *name, u32 type,
 					    u32 mask)
 {
+	const u32 fips = CRYPTO_ALG_FIPS_INTERNAL;
 	struct crypto_alg *alg;
 	u32 test = 0;
 
@@ -203,8 +206,20 @@ static struct crypto_alg *crypto_alg_lookup(const char *name, u32 type,
 		test |= CRYPTO_ALG_TESTED;
 
 	down_read(&crypto_alg_sem);
-	alg = __crypto_alg_lookup(name, type | test, mask | test);
-	if (!alg && test) {
+	alg = __crypto_alg_lookup(name, (type | test) & ~fips,
+				  (mask | test) & ~fips);
+	if (alg) {
+		if (((type | mask) ^ fips) & fips)
+			mask |= fips;
+		mask &= fips;
+
+		if (!crypto_is_larval(alg) &&
+		    ((type ^ alg->cra_flags) & mask)) {
+			/* Algorithm is disallowed in FIPS mode. */
+			crypto_mod_put(alg);
+			alg = ERR_PTR(-ENOENT);
+		}
+	} else if (test) {
 		alg = __crypto_alg_lookup(name, type, mask);
 		if (alg && !crypto_is_larval(alg)) {
 			/* Test failed */
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index ca398fbe1280..9dd4e3c764e3 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -1640,8 +1640,8 @@ static inline int tcrypt_test(const char *alg)
 	pr_debug("testing %s\n", alg);
 
 	ret = alg_test(alg, alg, 0, 0);
-	/* non-fips algs return -EINVAL in fips mode */
-	if (fips_enabled && ret == -EINVAL)
+	/* non-fips algs return -EINVAL or -ECANCELED in fips mode */
+	if (fips_enabled && (ret == -EINVAL || ret == -ECANCELED))
 		ret = 0;
 	return ret;
 }
diff --git a/crypto/testmgr.c b/crypto/testmgr.c
index 7a403e4af8fe..144857b560fe 100644
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@ -3689,6 +3689,13 @@ static int alg_find_test(const char *alg)
 	return -1;
 }
 
+static int alg_fips_disabled(const char *driver, const char *alg)
+{
+	pr_info("alg: %s (%s) is disabled due to FIPS\n", alg, driver);
+
+	return -ECANCELED;
+}
+
 int alg_test(const char *driver, const char *alg, u32 type, u32 mask)
 {
 	int i;
@@ -3725,9 +3732,13 @@ int alg_test(const char *driver, const char *alg, u32 type, u32 mask)
 	if (i < 0 && j < 0)
 		goto notest;
 
-	if (fips_enabled && ((i >= 0 && !alg_test_descs[i].fips_allowed) ||
-			     (j >= 0 && !alg_test_descs[j].fips_allowed)))
-		goto non_fips_alg;
+	if (fips_enabled) {
+		if (j >= 0 && !alg_test_descs[j].fips_allowed)
+			return -EINVAL;
+
+		if (i >= 0 && !alg_test_descs[i].fips_allowed)
+			goto non_fips_alg;
+	}
 
 	rc = 0;
 	if (i >= 0)
@@ -3748,9 +3759,13 @@ int alg_test(const char *driver, const char *alg, u32 type, u32 mask)
 
 notest:
 	printk(KERN_INFO "alg: No test for %s (%s)\n", alg, driver);
+
+	if (type & CRYPTO_ALG_FIPS_INTERNAL)
+		return alg_fips_disabled(driver, alg);
+
 	return 0;
 non_fips_alg:
-	return -EINVAL;
+	return alg_fips_disabled(driver, alg);
 }
 
 #endif /* CONFIG_CRYPTO_MANAGER_DISABLE_TESTS */
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index f5706d3195a2..7decf63fc6f9 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -149,6 +149,15 @@
  */
 #define CRYPTO_ALG_ALLOCATES_MEMORY	0x00010000
 
+/*
+ * Mark an algorithm as a service implementation only usable by a
+ * template and never by a normal user of the kernel crypto API.
+ * This is intended to be used by algorithms that are themselves
+ * not FIPS-approved but may instead be used to implement parts of
+ * a FIPS-approved algorithm (e.g., dh vs. ffdhe2048(dh)).
+ */
+#define CRYPTO_ALG_FIPS_INTERNAL	0x00020000
+
 /*
  * Transform masks and values (for crt_flags).
  */
