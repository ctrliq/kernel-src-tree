wifi: mac80211: refactor some link setup code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 4b41b2ef9e0d044528062eddbf34589da95c01bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/4b41b2ef.failed

We don't need to setup lists and work structs every time
we switch the interface type, factor that out into a new
ieee80211_link_init() function and use it.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 4b41b2ef9e0d044528062eddbf34589da95c01bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/iface.c
diff --cc net/mac80211/iface.c
index 2581d6c14d3a,fa684d76a169..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -954,6 -1012,43 +954,46 @@@ static void ieee80211_set_default_queue
  	sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
+ 				unsigned int link_id,
+ 				struct ieee80211_link_data *link,
+ 				struct ieee80211_bss_conf *link_conf)
+ {
+ 	sdata->vif.link_conf[link_id] = link_conf;
+ 	sdata->link[link_id] = link;
+ 
+ 	link->sdata = sdata;
+ 	link->link_id = link_id;
+ 
+ 	INIT_WORK(&link->csa_finalize_work,
+ 		  ieee80211_csa_finalize_work);
+ 	INIT_WORK(&link->color_change_finalize_work,
+ 		  ieee80211_color_change_finalize_work);
+ 	INIT_LIST_HEAD(&link->assigned_chanctx_list);
+ 	INIT_LIST_HEAD(&link->reserved_chanctx_list);
+ 	INIT_DELAYED_WORK(&link->dfs_cac_timer_work,
+ 			  ieee80211_dfs_cac_timer_work);
+ }
+ 
+ static void ieee80211_sdata_init(struct ieee80211_local *local,
+ 				 struct ieee80211_sub_if_data *sdata)
+ {
+ 	sdata->local = local;
+ 
+ 	/*
+ 	 * Initialize the default link, so we can use link_id 0 for non-MLD,
+ 	 * and that continues to work for non-MLD-aware drivers that use just
+ 	 * vif.bss_conf instead of vif.link_conf.
+ 	 *
+ 	 * Note that we never change this, so if link ID 0 isn't used in an
+ 	 * MLD connection, we get a separate allocation for it.
+ 	 */
+ 	ieee80211_link_init(sdata, 0, &sdata->deflink, &sdata->vif.bss_conf);
+ }
+ 
++>>>>>>> 4b41b2ef9e0d (wifi: mac80211: refactor some link setup code)
  int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
  {
  	struct ieee80211_sub_if_data *sdata;
@@@ -1595,10 -1697,6 +1635,13 @@@ static void ieee80211_setup_sdata(struc
  	skb_queue_head_init(&sdata->status_queue);
  	INIT_WORK(&sdata->work, ieee80211_iface_work);
  	INIT_WORK(&sdata->recalc_smps, ieee80211_recalc_smps_work);
++<<<<<<< HEAD
 +	INIT_WORK(&sdata->csa_finalize_work, ieee80211_csa_finalize_work);
 +	INIT_WORK(&sdata->color_change_finalize_work, ieee80211_color_change_finalize_work);
 +	INIT_LIST_HEAD(&sdata->assigned_chanctx_list);
 +	INIT_LIST_HEAD(&sdata->reserved_chanctx_list);
++=======
++>>>>>>> 4b41b2ef9e0d (wifi: mac80211: refactor some link setup code)
  
  	switch (type) {
  	case NL80211_IFTYPE_P2P_GO:
@@@ -2014,8 -2113,6 +2057,11 @@@ int ieee80211_if_add(struct ieee80211_l
  
  	INIT_LIST_HEAD(&sdata->key_list);
  
++<<<<<<< HEAD
 +	INIT_DELAYED_WORK(&sdata->dfs_cac_timer_work,
 +			  ieee80211_dfs_cac_timer_work);
++=======
++>>>>>>> 4b41b2ef9e0d (wifi: mac80211: refactor some link setup code)
  	INIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,
  			  ieee80211_delayed_tailroom_dec);
  
* Unmerged path net/mac80211/iface.c
