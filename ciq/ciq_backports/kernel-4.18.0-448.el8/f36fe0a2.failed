wifi: mac80211: fix up link station creation/insertion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit f36fe0a2df03209f4d681fa954f20bfa4eefec45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/f36fe0a2.failed

When we create a station with a non-default link, then
we should have a link address, and we definitely need
to insert it into the link hash table on insertion.

Split the API into with and without link creation and
if it has a link, insert the link into the link hash
table on sta_info_insert().

Fixes: ba6ddab94fc6 ("wifi: mac80211: maintain link-sta hash table")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit f36fe0a2df03209f4d681fa954f20bfa4eefec45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/cfg.c
#	net/mac80211/sta_info.c
#	net/mac80211/sta_info.h
diff --cc net/mac80211/cfg.c
index 10637d509537,1cacd1e0fc85..000000000000
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@@ -1818,7 -1850,14 +1818,18 @@@ static int ieee80211_add_station(struc
  	    !sdata->u.mgd.associated)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
++=======
+ 	if (params->link_sta_params.link_id >= 0)
+ 		sta = sta_info_alloc_with_link(sdata, mac,
+ 					       params->link_sta_params.link_id,
+ 					       params->link_sta_params.link_mac,
+ 					       GFP_KERNEL);
+ 	else
+ 		sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
+ 
++>>>>>>> f36fe0a2df03 (wifi: mac80211: fix up link station creation/insertion)
  	if (!sta)
  		return -ENOMEM;
  
diff --cc net/mac80211/sta_info.c
index d25b297851c4,75122eced104..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -81,6 -96,22 +81,25 @@@ static int sta_info_hash_del(struct iee
  			       sta_rht_params);
  }
  
++<<<<<<< HEAD
++=======
+ static int link_sta_info_hash_add(struct ieee80211_local *local,
+ 				  struct link_sta_info *link_sta)
+ {
+ 	return rhltable_insert(&local->link_sta_hash,
+ 			       &link_sta->link_hash_node,
+ 			       link_sta_rht_params);
+ }
+ 
+ static int link_sta_info_hash_del(struct ieee80211_local *local,
+ 				  struct link_sta_info *link_sta)
+ {
+ 	return rhltable_remove(&local->link_sta_hash,
+ 			       &link_sta->link_hash_node,
+ 			       link_sta_rht_params);
+ }
+ 
++>>>>>>> f36fe0a2df03 (wifi: mac80211: fix up link station creation/insertion)
  static void __cleanup_single_sta(struct sta_info *sta)
  {
  	int ac, i;
@@@ -333,8 -437,47 +352,52 @@@ static int sta_prepare_rate_control(str
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 +				const u8 *addr, gfp_t gfp)
++=======
+ static int sta_info_alloc_link(struct ieee80211_local *local,
+ 			       struct link_sta_info *link_info,
+ 			       gfp_t gfp)
+ {
+ 	struct ieee80211_hw *hw = &local->hw;
+ 	int i;
+ 
+ 	if (ieee80211_hw_check(hw, USES_RSS)) {
+ 		link_info->pcpu_rx_stats =
+ 			alloc_percpu_gfp(struct ieee80211_sta_rx_stats, gfp);
+ 		if (!link_info->pcpu_rx_stats)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	link_info->rx_stats.last_rx = jiffies;
+ 	u64_stats_init(&link_info->rx_stats.syncp);
+ 
+ 	ewma_signal_init(&link_info->rx_stats_avg.signal);
+ 	ewma_avg_signal_init(&link_info->status_stats.avg_ack_signal);
+ 	for (i = 0; i < ARRAY_SIZE(link_info->rx_stats_avg.chain_signal); i++)
+ 		ewma_signal_init(&link_info->rx_stats_avg.chain_signal[i]);
+ 
+ 	return 0;
+ }
+ 
+ static void sta_info_add_link(struct sta_info *sta,
+ 			      unsigned int link_id,
+ 			      struct link_sta_info *link_info,
+ 			      struct ieee80211_link_sta *link_sta)
+ {
+ 	link_info->sta = sta;
+ 	link_info->link_id = link_id;
+ 	link_info->pub = link_sta;
+ 	rcu_assign_pointer(sta->link[link_id], link_info);
+ 	rcu_assign_pointer(sta->sta.link[link_id], link_sta);
+ }
+ 
+ static struct sta_info *
+ __sta_info_alloc(struct ieee80211_sub_if_data *sdata,
+ 		 const u8 *addr, int link_id, const u8 *link_addr,
+ 		 gfp_t gfp)
++>>>>>>> f36fe0a2df03 (wifi: mac80211: fix up link station creation/insertion)
  {
  	struct ieee80211_local *local = sdata->local;
  	struct ieee80211_hw *hw = &local->hw;
@@@ -2604,3 -2698,114 +2690,117 @@@ void ieee80211_sta_set_expected_through
  
  	sta_update_codel_params(sta, thr);
  }
++<<<<<<< HEAD
++=======
+ 
+ int ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct sta_link_alloc *alloc;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	/* must represent an MLD from the start */
+ 	if (WARN_ON(!sta->sta.valid_links))
+ 		return -EINVAL;
+ 
+ 	if (WARN_ON(sta->sta.valid_links & BIT(link_id) ||
+ 		    sta->link[link_id]))
+ 		return -EBUSY;
+ 
+ 	alloc = kzalloc(sizeof(*alloc), GFP_KERNEL);
+ 	if (!alloc)
+ 		return -ENOMEM;
+ 
+ 	ret = sta_info_alloc_link(sdata->local, &alloc->info, GFP_KERNEL);
+ 	if (ret) {
+ 		kfree(alloc);
+ 		return ret;
+ 	}
+ 
+ 	sta_info_add_link(sta, link_id, &alloc->info, &alloc->sta);
+ 
+ 	return 0;
+ }
+ 
+ void ieee80211_sta_free_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	lockdep_assert_held(&sta->sdata->local->sta_mtx);
+ 
+ 	sta_remove_link(sta, link_id, false);
+ }
+ 
+ int ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct link_sta_info *link_sta;
+ 	u16 old_links = sta->sta.valid_links;
+ 	u16 new_links = old_links | BIT(link_id);
+ 	int ret;
+ 
+ 	link_sta = rcu_dereference_protected(sta->link[link_id],
+ 					     lockdep_is_held(&sdata->local->sta_mtx));
+ 
+ 	if (WARN_ON(old_links == new_links || !link_sta))
+ 		return -EINVAL;
+ 
+ 	sta->sta.valid_links = new_links;
+ 
+ 	if (!test_sta_flag(sta, WLAN_STA_INSERTED)) {
+ 		ret = 0;
+ 		goto hash;
+ 	}
+ 
+ 	ret = drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				   old_links, new_links);
+ 	if (ret) {
+ 		sta->sta.valid_links = old_links;
+ 		sta_remove_link(sta, link_id, false);
+ 	}
+ 
+ hash:
+ 	link_sta_info_hash_add(sdata->local, link_sta);
+ 
+ 	return ret;
+ }
+ 
+ void ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id)
+ {
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 
+ 	lockdep_assert_held(&sdata->local->sta_mtx);
+ 
+ 	sta->sta.valid_links &= ~BIT(link_id);
+ 
+ 	if (test_sta_flag(sta, WLAN_STA_INSERTED))
+ 		drv_change_sta_links(sdata->local, sdata, &sta->sta,
+ 				     sta->sta.valid_links,
+ 				     sta->sta.valid_links & ~BIT(link_id));
+ 
+ 	sta_remove_link(sta, link_id, true);
+ }
+ 
+ void ieee80211_sta_set_max_amsdu_subframes(struct sta_info *sta,
+ 					   const u8 *ext_capab,
+ 					   unsigned int ext_capab_len)
+ {
+ 	u8 val;
+ 
+ 	sta->sta.max_amsdu_subframes = 0;
+ 
+ 	if (ext_capab_len < 8)
+ 		return;
+ 
+ 	/* The sender might not have sent the last bit, consider it to be 0 */
+ 	val = u8_get_bits(ext_capab[7], WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB);
+ 
+ 	/* we did get all the bits, take the MSB as well */
+ 	if (ext_capab_len >= 9)
+ 		val |= u8_get_bits(ext_capab[8],
+ 				   WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB) << 1;
+ 
+ 	if (val)
+ 		sta->sta.max_amsdu_subframes = 4 << val;
+ }
++>>>>>>> f36fe0a2df03 (wifi: mac80211: fix up link station creation/insertion)
diff --cc net/mac80211/sta_info.h
index addc78b398f0,2eb3a9452e07..000000000000
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@@ -797,6 -841,11 +797,14 @@@ struct sta_info *sta_info_get_by_idx(st
   */
  struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
  				const u8 *addr, gfp_t gfp);
++<<<<<<< HEAD
++=======
+ struct sta_info *sta_info_alloc_with_link(struct ieee80211_sub_if_data *sdata,
+ 					  const u8 *mld_addr,
+ 					  unsigned int link_id,
+ 					  const u8 *link_addr,
+ 					  gfp_t gfp);
++>>>>>>> f36fe0a2df03 (wifi: mac80211: fix up link station creation/insertion)
  
  void sta_info_free(struct ieee80211_local *local, struct sta_info *sta);
  
* Unmerged path net/mac80211/cfg.c
* Unmerged path net/mac80211/sta_info.c
* Unmerged path net/mac80211/sta_info.h
