wifi: mac80211: refactor some sta_info link handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 246b39e4a1ba5ad77edfb2f28d147abc5e2bb0a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/246b39e4.failed

Refactor the code a bit to initialize a link belonging
to a station, and (later) free all allocated links.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 246b39e4a1ba5ad77edfb2f28d147abc5e2bb0a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/sta_info.c
diff --cc net/mac80211/sta_info.c
index f2be4a7c4886,f20ce7bbcb39..000000000000
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@@ -287,7 -301,8 +301,12 @@@ void sta_info_free(struct ieee80211_loc
  #ifdef CONFIG_MAC80211_MESH
  	kfree(sta->mesh);
  #endif
++<<<<<<< HEAD
 +	free_percpu(sta->pcpu_rx_stats);
++=======
+ 
+ 	sta_info_free_links(sta);
++>>>>>>> 246b39e4a1ba (wifi: mac80211: refactor some sta_info link handling)
  	kfree(sta);
  }
  
@@@ -345,12 -394,11 +398,20 @@@ struct sta_info *sta_info_alloc(struct 
  	if (!sta)
  		return NULL;
  
++<<<<<<< HEAD
 +	if (ieee80211_hw_check(hw, USES_RSS)) {
 +		sta->pcpu_rx_stats =
 +			alloc_percpu_gfp(struct ieee80211_sta_rx_stats, gfp);
 +		if (!sta->pcpu_rx_stats)
 +			goto free;
 +	}
++=======
+ 	sta->local = local;
+ 	sta->sdata = sdata;
+ 
+ 	if (sta_info_init_link(sta, 0, &sta->deflink, &sta->sta.deflink, gfp))
+ 		return NULL;
++>>>>>>> 246b39e4a1ba (wifi: mac80211: refactor some sta_info link handling)
  
  	spin_lock_init(&sta->lock);
  	spin_lock_init(&sta->ps_lock);
@@@ -376,6 -424,8 +437,11 @@@
  	sta->sta.max_rx_aggregation_subframes =
  		local->hw.max_rx_aggregation_subframes;
  
++<<<<<<< HEAD
++=======
+ 	/* TODO link specific alloc and assignments for MLO Link STA */
+ 
++>>>>>>> 246b39e4a1ba (wifi: mac80211: refactor some sta_info link handling)
  	/* Extended Key ID needs to install keys for keyid 0 and 1 Rx-only.
  	 * The Tx path starts to use a key as soon as the key slot ptk_idx
  	 * references to is not NULL. To not use the initial Rx-only key
@@@ -385,11 -435,6 +451,14 @@@
  	BUILD_BUG_ON(ARRAY_SIZE(sta->ptk) <= INVALID_PTK_KEYIDX);
  	sta->ptk_idx = INVALID_PTK_KEYIDX;
  
++<<<<<<< HEAD
 +	sta->local = local;
 +	sta->sdata = sdata;
 +	sta->rx_stats.last_rx = jiffies;
 +
 +	u64_stats_init(&sta->rx_stats.syncp);
++=======
++>>>>>>> 246b39e4a1ba (wifi: mac80211: refactor some sta_info link handling)
  
  	ieee80211_init_frag_cache(&sta->frags);
  
@@@ -399,10 -444,6 +468,13 @@@
  	sta->reserved_tid = IEEE80211_TID_UNRESERVED;
  
  	sta->last_connected = ktime_get_seconds();
++<<<<<<< HEAD
 +	ewma_signal_init(&sta->rx_stats_avg.signal);
 +	ewma_avg_signal_init(&sta->status_stats.avg_ack_signal);
 +	for (i = 0; i < ARRAY_SIZE(sta->rx_stats_avg.chain_signal); i++)
 +		ewma_signal_init(&sta->rx_stats_avg.chain_signal[i]);
++=======
++>>>>>>> 246b39e4a1ba (wifi: mac80211: refactor some sta_info link handling)
  
  	if (local->ops->wake_tx_queue) {
  		void *txq_data;
@@@ -524,7 -565,7 +596,11 @@@ free_txq
  	if (sta->sta.txq[0])
  		kfree(to_txq_info(sta->sta.txq[0]));
  free:
++<<<<<<< HEAD
 +	free_percpu(sta->pcpu_rx_stats);
++=======
+ 	sta_info_free_links(sta);
++>>>>>>> 246b39e4a1ba (wifi: mac80211: refactor some sta_info link handling)
  #ifdef CONFIG_MAC80211_MESH
  	kfree(sta->mesh);
  #endif
* Unmerged path net/mac80211/sta_info.c
