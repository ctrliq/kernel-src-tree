s390/pci: add zpci_event_hard_deconfigured()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit dee60c0dbc837ddca8abcb868e53ca3e9d11ea4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/dee60c0d.failed

Extract the handling of PEC 0x0304 into a function and make sure we only
attempt to disable the function if it is enabled. Also check for errors
returned by zpci_disable_device() and leave the function alone if there
are any.

	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit dee60c0dbc837ddca8abcb868e53ca3e9d11ea4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/pci/pci_event.c
index 4b2bb5dfb29a,0474ff8c6dbd..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -76,13 -98,9 +98,17 @@@ static void zpci_event_hard_deconfigure
  static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
  {
  	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
++<<<<<<< HEAD
 +	struct pci_dev *pdev = NULL;
 +	enum zpci_state state;
++=======
+ 	struct pci_dev *pdev;
++>>>>>>> dee60c0dbc83 (s390/pci: add zpci_event_hard_deconfigured())
  	int ret;
  
 +	if (zdev && zdev->zbus->bus)
 +		pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
 +
  	zpci_err("avail CCDF:\n");
  	zpci_err_hex(ccdf, sizeof(*ccdf));
  
@@@ -138,22 -155,8 +164,27 @@@
  
  		break;
  	case 0x0304: /* Configured -> Standby|Reserved */
++<<<<<<< HEAD
 +		if (!zdev)
 +			break;
 +		if (pdev) {
 +			/* Give the driver a hint that the function is
 +			 * already unusable. */
 +			pdev->error_state = pci_channel_io_perm_failure;
 +			zpci_remove_device(zdev);
 +		}
 +
 +		zdev->fh = ccdf->fh;
 +		zpci_disable_device(zdev);
 +		zdev->state = ZPCI_FN_STATE_STANDBY;
 +		if (!clp_get_state(ccdf->fid, &state) &&
 +		    state == ZPCI_FN_STATE_RESERVED) {
 +			zpci_device_reserved(zdev);
 +		}
++=======
+ 		if (zdev)
+ 			zpci_event_hard_deconfigured(zdev, ccdf->fh);
++>>>>>>> dee60c0dbc83 (s390/pci: add zpci_event_hard_deconfigured())
  		break;
  	case 0x0306: /* 0x308 or 0x302 for multiple devices */
  		zpci_remove_reserved_devices();
* Unmerged path arch/s390/pci/pci_event.c
