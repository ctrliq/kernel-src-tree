wifi: mac80211: make channel context code MLO-aware

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit b4f85443c17c7edb49c82fc1d28d26860c8c850d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/b4f85443.failed

Make the channel context code MLO aware, along with some
functions that it uses, so that the chan.c file is now
MLD-clean and no longer uses deflink/bss_conf/etc.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit b4f85443c17c7edb49c82fc1d28d26860c8c850d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/silabs/wfx/sta.c
#	drivers/net/wireless/silabs/wfx/sta.h
#	net/mac80211/chan.c
#	net/mac80211/eht.c
#	net/mac80211/he.c
#	net/mac80211/ieee80211_i.h
#	net/mac80211/iface.c
#	net/mac80211/rx.c
#	net/mac80211/tdls.c
#	net/mac80211/util.c
#	net/mac80211/vht.c
diff --cc net/mac80211/chan.c
index 37035c3e5f8a,4f25660d0eeb..000000000000
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@@ -89,12 -97,12 +97,18 @@@ ieee80211_chanctx_reserved_chandef(stru
  
  	lockdep_assert_held(&local->chanctx_mtx);
  
- 	list_for_each_entry(sdata, &ctx->reserved_vifs,
+ 	list_for_each_entry(link, &ctx->reserved_links,
  			    reserved_chanctx_list) {
  		if (!compat)
++<<<<<<< HEAD
 +			compat = &sdata->reserved_chandef;
 +
 +		compat = cfg80211_chandef_compatible(&sdata->reserved_chandef,
++=======
+ 			compat = &link->reserved_chandef;
+ 
+ 		compat = cfg80211_chandef_compatible(&link->reserved_chandef,
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  						     compat);
  		if (!compat)
  			break;
@@@ -112,9 -120,12 +126,16 @@@ ieee80211_chanctx_non_reserved_chandef(
  
  	lockdep_assert_held(&local->chanctx_mtx);
  
- 	list_for_each_entry(sdata, &ctx->assigned_vifs,
+ 	list_for_each_entry(link, &ctx->assigned_links,
  			    assigned_chanctx_list) {
++<<<<<<< HEAD
 +		if (sdata->reserved_chanctx != NULL)
++=======
+ 		struct ieee80211_bss_conf *link_conf =
+ 			link->sdata->vif.link_conf[link->link_id];
+ 
+ 		if (link->reserved_chanctx)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  			continue;
  
  		if (!compat)
@@@ -199,7 -216,7 +226,11 @@@ static enum nl80211_chan_width ieee8021
  
  	switch (width) {
  	case IEEE80211_STA_RX_BW_20:
++<<<<<<< HEAD
 +		if (sta->sta.ht_cap.ht_supported)
++=======
+ 		if (sta->sta.link[link_id]->ht_cap.ht_supported)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  			return NL80211_CHAN_WIDTH_20;
  		else
  			return NL80211_CHAN_WIDTH_20_NOHT;
@@@ -368,24 -413,31 +427,46 @@@ static void ieee80211_chan_bw_change(st
  		if (!ieee80211_sdata_running(sta->sdata))
  			continue;
  
- 		if (rcu_access_pointer(sta->sdata->vif.bss_conf.chanctx_conf) !=
- 		    &ctx->conf)
- 			continue;
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sta->sdata->link); link_id++) {
+ 			struct ieee80211_bss_conf *link_conf =
+ 				sdata->vif.link_conf[link_id];
  
- 		new_sta_bw = ieee80211_sta_cur_vht_bw(sta);
+ 			if (!link_conf)
+ 				continue;
  
++<<<<<<< HEAD
 +		/* nothing change */
 +		if (new_sta_bw == sta->sta.bandwidth)
 +			continue;
 +
 +		/* vif changed to narrow BW and narrow BW for station wasn't
 +		 * requested or vise versa */
 +		if ((new_sta_bw < sta->sta.bandwidth) == !narrowed)
 +			continue;
 +
 +		sta->sta.bandwidth = new_sta_bw;
 +		rate_control_rate_update(local, sband, sta,
 +					 IEEE80211_RC_BW_CHANGED);
++=======
+ 			if (rcu_access_pointer(link_conf->chanctx_conf) != &ctx->conf)
+ 				continue;
+ 
+ 			new_sta_bw = ieee80211_sta_cur_vht_bw(sta, link_id);
+ 
+ 			/* nothing change */
+ 			if (new_sta_bw == sta->sta.link[link_id]->bandwidth)
+ 				continue;
+ 
+ 			/* vif changed to narrow BW and narrow BW for station wasn't
+ 			 * requested or vise versa */
+ 			if ((new_sta_bw < sta->sta.link[link_id]->bandwidth) == !narrowed)
+ 				continue;
+ 
+ 			sta->sta.link[link_id]->bandwidth = new_sta_bw;
+ 			rate_control_rate_update(local, sband, sta, link_id,
+ 						 IEEE80211_RC_BW_CHANGED);
+ 		}
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  	}
  	rcu_read_unlock();
  }
@@@ -508,9 -560,14 +589,20 @@@ bool ieee80211_is_radar_required(struc
  
  	rcu_read_lock();
  	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
++<<<<<<< HEAD
 +		if (sdata->radar_required) {
 +			rcu_read_unlock();
 +			return true;
++=======
+ 		unsigned int link_id;
+ 
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			if (sdata->link[link_id] &&
+ 			    sdata->link[link_id]->radar_required) {
+ 				rcu_read_unlock();
+ 				return true;
+ 			}
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  		}
  	}
  	rcu_read_unlock();
@@@ -531,15 -588,27 +623,34 @@@ ieee80211_chanctx_radar_required(struc
  
  	rcu_read_lock();
  	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+ 		unsigned int link_id;
+ 
  		if (!ieee80211_sdata_running(sdata))
  			continue;
++<<<<<<< HEAD
 +		if (rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) != conf)
 +			continue;
 +		if (!sdata->radar_required)
 +			continue;
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			struct ieee80211_bss_conf *link_conf =
+ 				sdata->vif.link_conf[link_id];
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
- 		required = true;
- 		break;
+ 			if (!link_conf)
+ 				continue;
+ 
+ 			if (rcu_access_pointer(link_conf->chanctx_conf) != conf)
+ 				continue;
+ 			if (!sdata->link[link_id]->radar_required)
+ 				continue;
+ 			required = true;
+ 			break;
+ 		}
+ 
+ 		if (required)
+ 			break;
  	}
  	rcu_read_unlock();
  
@@@ -781,9 -863,9 +905,9 @@@ static int ieee80211_assign_link_chanct
  	}
  
  out:
- 	rcu_assign_pointer(sdata->vif.bss_conf.chanctx_conf, conf);
+ 	rcu_assign_pointer(sdata->vif.link_conf[link_id]->chanctx_conf, conf);
  
 -	sdata->vif.cfg.idle = !conf;
 +	sdata->vif.bss_conf.idle = !conf;
  
  	if (curr_ctx && ieee80211_chanctx_num_assigned(local, curr_ctx) > 0) {
  		ieee80211_recalc_chanctx_chantype(local, curr_ctx);
@@@ -845,30 -918,42 +961,63 @@@ void ieee80211_recalc_smps_chanctx(stru
  		case NL80211_IFTYPE_OCB:
  			break;
  		default:
- 			WARN_ON_ONCE(1);
+ 			continue;
  		}
  
++<<<<<<< HEAD
 +		switch (sdata->smps_mode) {
 +		default:
 +			WARN_ONCE(1, "Invalid SMPS mode %d\n",
 +				  sdata->smps_mode);
 +			fallthrough;
 +		case IEEE80211_SMPS_OFF:
 +			needed_static = sdata->needed_rx_chains;
 +			needed_dynamic = sdata->needed_rx_chains;
 +			break;
 +		case IEEE80211_SMPS_DYNAMIC:
 +			needed_static = 1;
 +			needed_dynamic = sdata->needed_rx_chains;
 +			break;
 +		case IEEE80211_SMPS_STATIC:
 +			needed_static = 1;
 +			needed_dynamic = 1;
 +			break;
 +		}
++=======
+ 		for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
+ 			struct ieee80211_link_data *link = sdata->link[link_id];
+ 			struct ieee80211_bss_conf *link_conf =
+ 				sdata->vif.link_conf[link_id];
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
+ 
+ 			if (!link_conf)
+ 				continue;
+ 
+ 			if (rcu_access_pointer(link_conf->chanctx_conf) != &chanctx->conf)
+ 				continue;
  
- 		rx_chains_static = max(rx_chains_static, needed_static);
- 		rx_chains_dynamic = max(rx_chains_dynamic, needed_dynamic);
+ 			switch (link->smps_mode) {
+ 			default:
+ 				WARN_ONCE(1, "Invalid SMPS mode %d\n",
+ 					  link->smps_mode);
+ 				fallthrough;
+ 			case IEEE80211_SMPS_OFF:
+ 				needed_static = link->needed_rx_chains;
+ 				needed_dynamic = link->needed_rx_chains;
+ 				break;
+ 			case IEEE80211_SMPS_DYNAMIC:
+ 				needed_static = 1;
+ 				needed_dynamic = link->needed_rx_chains;
+ 				break;
+ 			case IEEE80211_SMPS_STATIC:
+ 				needed_static = 1;
+ 				needed_dynamic = 1;
+ 				break;
+ 			}
+ 
+ 			rx_chains_static = max(rx_chains_static, needed_static);
+ 			rx_chains_dynamic = max(rx_chains_dynamic, needed_dynamic);
+ 		}
  	}
  
  	/* Disable SMPS for the monitor interface */
@@@ -940,17 -1029,18 +1093,27 @@@ void ieee80211_link_copy_chanctx_to_vla
  	mutex_unlock(&local->chanctx_mtx);
  }
  
- int ieee80211_vif_unreserve_chanctx(struct ieee80211_sub_if_data *sdata)
+ int ieee80211_link_unreserve_chanctx(struct ieee80211_link_data *link)
  {
++<<<<<<< HEAD
 +	struct ieee80211_chanctx *ctx = sdata->reserved_chanctx;
++=======
+ 	struct ieee80211_sub_if_data *sdata = link->sdata;
+ 	struct ieee80211_chanctx *ctx = link->reserved_chanctx;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	lockdep_assert_held(&sdata->local->chanctx_mtx);
  
  	if (WARN_ON(!ctx))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	list_del(&sdata->reserved_chanctx_list);
 +	sdata->reserved_chanctx = NULL;
++=======
+ 	list_del(&link->reserved_chanctx_list);
+ 	link->reserved_chanctx = NULL;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	if (ieee80211_chanctx_refcount(sdata->local, ctx) == 0) {
  		if (ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER) {
@@@ -1062,11 -1153,11 +1226,19 @@@ int ieee80211_link_reserve_chanctx(stru
  		}
  	}
  
++<<<<<<< HEAD
 +	list_add(&sdata->reserved_chanctx_list, &new_ctx->reserved_vifs);
 +	sdata->reserved_chanctx = new_ctx;
 +	sdata->reserved_chandef = *chandef;
 +	sdata->reserved_radar_required = radar_required;
 +	sdata->reserved_ready = false;
++=======
+ 	list_add(&link->reserved_chanctx_list, &new_ctx->reserved_links);
+ 	link->reserved_chanctx = new_ctx;
+ 	link->reserved_chandef = *chandef;
+ 	link->reserved_radar_required = radar_required;
+ 	link->reserved_ready = false;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	return 0;
  }
@@@ -1080,7 -1173,7 +1254,11 @@@ ieee80211_link_chanctx_reservation_comp
  	case NL80211_IFTYPE_MESH_POINT:
  	case NL80211_IFTYPE_OCB:
  		ieee80211_queue_work(&sdata->local->hw,
++<<<<<<< HEAD
 +				     &sdata->csa_finalize_work);
++=======
+ 				     &link->csa_finalize_work);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  		break;
  	case NL80211_IFTYPE_STATION:
  		ieee80211_queue_work(&sdata->local->hw,
@@@ -1128,10 -1226,10 +1311,17 @@@ ieee80211_link_use_reserved_reassign(st
  	lockdep_assert_held(&local->mtx);
  	lockdep_assert_held(&local->chanctx_mtx);
  
++<<<<<<< HEAD
 +	new_ctx = sdata->reserved_chanctx;
 +	old_ctx = ieee80211_vif_get_chanctx(sdata);
 +
 +	if (WARN_ON(!sdata->reserved_ready))
++=======
+ 	new_ctx = link->reserved_chanctx;
+ 	old_ctx = ieee80211_link_get_chanctx(link);
+ 
+ 	if (WARN_ON(!link->reserved_ready))
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  		return -EBUSY;
  
  	if (WARN_ON(!new_ctx))
@@@ -1145,23 -1243,24 +1335,40 @@@
  		return -EINVAL;
  
  	chandef = ieee80211_chanctx_non_reserved_chandef(local, new_ctx,
++<<<<<<< HEAD
 +				&sdata->reserved_chandef);
 +	if (WARN_ON(!chandef))
 +		return -EINVAL;
 +
 +	if (sdata->vif.bss_conf.chandef.width != sdata->reserved_chandef.width)
 +		changed = BSS_CHANGED_BANDWIDTH;
 +
 +	ieee80211_vif_update_chandef(sdata, &sdata->reserved_chandef);
++=======
+ 				&link->reserved_chandef);
+ 	if (WARN_ON(!chandef))
+ 		return -EINVAL;
+ 
+ 	if (link_conf->chandef.width != link->reserved_chandef.width)
+ 		changed = BSS_CHANGED_BANDWIDTH;
+ 
+ 	ieee80211_link_update_chandef(link, &link->reserved_chandef);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	ieee80211_change_chanctx(local, new_ctx, old_ctx, chandef);
  
  	vif_chsw[0].vif = &sdata->vif;
  	vif_chsw[0].old_ctx = &old_ctx->conf;
  	vif_chsw[0].new_ctx = &new_ctx->conf;
+ 	vif_chsw[0].link_id = link->link_id;
  
++<<<<<<< HEAD
 +	list_del(&sdata->reserved_chanctx_list);
 +	sdata->reserved_chanctx = NULL;
++=======
+ 	list_del(&link->reserved_chanctx_list);
+ 	link->reserved_chanctx = NULL;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	err = drv_switch_vif_chanctx(local, vif_chsw, 1,
  				     CHANCTX_SWMODE_REASSIGN_VIF);
@@@ -1188,10 -1287,10 +1395,14 @@@
  	ieee80211_recalc_radar_chanctx(local, new_ctx);
  
  	if (changed)
++<<<<<<< HEAD
 +		ieee80211_bss_info_change_notify(sdata, changed);
++=======
+ 		ieee80211_link_info_change_notify(sdata, link_id, changed);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  out:
- 	ieee80211_vif_chanctx_reservation_complete(sdata);
+ 	ieee80211_link_chanctx_reservation_complete(link);
  	return err;
  }
  
@@@ -1203,10 -1304,10 +1416,17 @@@ ieee80211_link_use_reserved_assign(stru
  	const struct cfg80211_chan_def *chandef;
  	int err;
  
++<<<<<<< HEAD
 +	old_ctx = ieee80211_vif_get_chanctx(sdata);
 +	new_ctx = sdata->reserved_chanctx;
 +
 +	if (WARN_ON(!sdata->reserved_ready))
++=======
+ 	old_ctx = ieee80211_vif_get_chanctx(sdata, link_id);
+ 	new_ctx = link->reserved_chanctx;
+ 
+ 	if (WARN_ON(!link->reserved_ready))
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  		return -EINVAL;
  
  	if (WARN_ON(old_ctx))
@@@ -1220,16 -1321,16 +1440,25 @@@
  		return -EINVAL;
  
  	chandef = ieee80211_chanctx_non_reserved_chandef(local, new_ctx,
++<<<<<<< HEAD
 +				&sdata->reserved_chandef);
++=======
+ 				&link->reserved_chandef);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  	if (WARN_ON(!chandef))
  		return -EINVAL;
  
  	ieee80211_change_chanctx(local, new_ctx, new_ctx, chandef);
  
++<<<<<<< HEAD
 +	list_del(&sdata->reserved_chanctx_list);
 +	sdata->reserved_chanctx = NULL;
++=======
+ 	list_del(&link->reserved_chanctx_list);
+ 	link->reserved_chanctx = NULL;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
- 	err = ieee80211_assign_vif_chanctx(sdata, new_ctx);
+ 	err = ieee80211_assign_link_chanctx(link, new_ctx);
  	if (err) {
  		if (ieee80211_chanctx_refcount(local, new_ctx) == 0)
  			ieee80211_free_chanctx(local, new_ctx);
@@@ -1249,8 -1351,8 +1479,13 @@@ ieee80211_link_has_in_place_reservation
  
  	lockdep_assert_held(&sdata->local->chanctx_mtx);
  
++<<<<<<< HEAD
 +	new_ctx = sdata->reserved_chanctx;
 +	old_ctx = ieee80211_vif_get_chanctx(sdata);
++=======
+ 	new_ctx = link->reserved_chanctx;
+ 	old_ctx = ieee80211_link_get_chanctx(link);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	if (!old_ctx)
  		return false;
@@@ -1418,12 -1521,12 +1654,18 @@@ static int ieee80211_vif_use_reserved_s
  		n_reserved = 0;
  		n_ready = 0;
  
- 		list_for_each_entry(sdata, &ctx->replace_ctx->assigned_vifs,
+ 		list_for_each_entry(link, &ctx->replace_ctx->assigned_links,
  				    assigned_chanctx_list) {
  			n_assigned++;
++<<<<<<< HEAD
 +			if (sdata->reserved_chanctx) {
 +				n_reserved++;
 +				if (sdata->reserved_ready)
++=======
+ 			if (link->reserved_chanctx) {
+ 				n_reserved++;
+ 				if (link->reserved_ready)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  					n_ready++;
  			}
  		}
@@@ -1440,13 -1543,13 +1682,18 @@@
  		}
  
  		ctx->conf.radar_enabled = false;
- 		list_for_each_entry(sdata, &ctx->reserved_vifs,
+ 		list_for_each_entry(link, &ctx->reserved_links,
  				    reserved_chanctx_list) {
++<<<<<<< HEAD
 +			if (ieee80211_vif_has_in_place_reservation(sdata) &&
 +			    !sdata->reserved_ready)
++=======
+ 			if (ieee80211_link_has_in_place_reservation(link) &&
+ 			    !link->reserved_ready)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  				return -EAGAIN;
  
- 			old_ctx = ieee80211_vif_get_chanctx(sdata);
+ 			old_ctx = ieee80211_link_get_chanctx(link);
  			if (old_ctx) {
  				if (old_ctx->replace_state ==
  				    IEEE80211_CHANCTX_WILL_BE_REPLACED)
@@@ -1457,7 -1560,7 +1704,11 @@@
  				n_vifs_ctxless++;
  			}
  
++<<<<<<< HEAD
 +			if (sdata->reserved_radar_required)
++=======
+ 			if (link->reserved_radar_required)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  				ctx->conf.radar_enabled = true;
  		}
  	}
@@@ -1524,16 -1632,16 +1780,29 @@@
  
  			ieee80211_check_fast_xmit_iface(sdata);
  
++<<<<<<< HEAD
 +			sdata->radar_required = sdata->reserved_radar_required;
 +
 +			if (sdata->vif.bss_conf.chandef.width !=
 +			    sdata->reserved_chandef.width)
 +				changed = BSS_CHANGED_BANDWIDTH;
 +
 +			ieee80211_vif_update_chandef(sdata, &sdata->reserved_chandef);
 +			if (changed)
 +				ieee80211_bss_info_change_notify(sdata,
 +								 changed);
++=======
+ 			link->radar_required = link->reserved_radar_required;
+ 
+ 			if (link_conf->chandef.width != link->reserved_chandef.width)
+ 				changed = BSS_CHANGED_BANDWIDTH;
+ 
+ 			ieee80211_link_update_chandef(link, &link->reserved_chandef);
+ 			if (changed)
+ 				ieee80211_link_info_change_notify(sdata,
+ 								  link->link_id,
+ 								  changed);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  			ieee80211_recalc_txpower(sdata, false);
  		}
@@@ -1543,17 -1651,17 +1812,24 @@@
  		ieee80211_recalc_radar_chanctx(local, ctx);
  		ieee80211_recalc_chanctx_min_def(local, ctx);
  
- 		list_for_each_entry_safe(sdata, sdata_tmp, &ctx->reserved_vifs,
+ 		list_for_each_entry_safe(link, link_tmp, &ctx->reserved_links,
  					 reserved_chanctx_list) {
- 			if (ieee80211_vif_get_chanctx(sdata) != ctx)
+ 			if (ieee80211_link_get_chanctx(link) != ctx)
  				continue;
  
++<<<<<<< HEAD
 +			list_del(&sdata->reserved_chanctx_list);
 +			list_move(&sdata->assigned_chanctx_list,
 +				  &ctx->assigned_vifs);
 +			sdata->reserved_chanctx = NULL;
- 
- 			ieee80211_vif_chanctx_reservation_complete(sdata);
++=======
+ 			list_del(&link->reserved_chanctx_list);
+ 			list_move(&link->assigned_chanctx_list,
+ 				  &ctx->assigned_links);
+ 			link->reserved_chanctx = NULL;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
+ 
+ 			ieee80211_link_chanctx_reservation_complete(link);
  		}
  
  		/*
@@@ -1563,31 -1671,29 +1839,36 @@@
  		 * reservation for originally requested interface has already
  		 * succeeded at this point.
  		 */
- 		list_for_each_entry_safe(sdata, sdata_tmp, &ctx->reserved_vifs,
+ 		list_for_each_entry_safe(link, link_tmp, &ctx->reserved_links,
  					 reserved_chanctx_list) {
- 			if (WARN_ON(ieee80211_vif_has_in_place_reservation(
- 					sdata)))
+ 			if (WARN_ON(ieee80211_link_has_in_place_reservation(link)))
  				continue;
  
++<<<<<<< HEAD
 +			if (WARN_ON(sdata->reserved_chanctx != ctx))
 +				continue;
 +
 +			if (!sdata->reserved_ready)
++=======
+ 			if (WARN_ON(link->reserved_chanctx != ctx))
  				continue;
  
- 			if (ieee80211_vif_get_chanctx(sdata))
- 				err = ieee80211_vif_use_reserved_reassign(
- 						sdata);
+ 			if (!link->reserved_ready)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
+ 				continue;
+ 
+ 			if (ieee80211_link_get_chanctx(link))
+ 				err = ieee80211_link_use_reserved_reassign(link);
  			else
- 				err = ieee80211_vif_use_reserved_assign(sdata);
+ 				err = ieee80211_link_use_reserved_assign(link);
  
  			if (err) {
- 				sdata_info(sdata,
- 					   "failed to finalize (re-)assign reservation (err=%d)\n",
- 					   err);
- 				ieee80211_vif_unreserve_chanctx(sdata);
+ 				link_info(link,
+ 					  "failed to finalize (re-)assign reservation (err=%d)\n",
+ 					  err);
+ 				ieee80211_link_unreserve_chanctx(link);
  				cfg80211_stop_iface(local->hw.wiphy,
- 						    &sdata->wdev,
+ 						    &link->sdata->wdev,
  						    GFP_KERNEL);
  			}
  		}
@@@ -1642,21 -1753,19 +1928,31 @@@ static void __ieee80211_link_release_ch
  
  	ctx = container_of(conf, struct ieee80211_chanctx, conf);
  
++<<<<<<< HEAD
 +	if (sdata->reserved_chanctx) {
 +		if (sdata->reserved_chanctx->replace_state ==
 +		    IEEE80211_CHANCTX_REPLACES_OTHER &&
 +		    ieee80211_chanctx_num_reserved(local,
 +						   sdata->reserved_chanctx) > 1)
++=======
+ 	if (link->reserved_chanctx) {
+ 		if (link->reserved_chanctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER &&
+ 		    ieee80211_chanctx_num_reserved(local, link->reserved_chanctx) > 1)
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  			use_reserved_switch = true;
  
- 		ieee80211_vif_unreserve_chanctx(sdata);
+ 		ieee80211_link_unreserve_chanctx(link);
  	}
  
- 	ieee80211_assign_vif_chanctx(sdata, NULL);
+ 	ieee80211_assign_link_chanctx(link, NULL);
  	if (ieee80211_chanctx_refcount(local, ctx) == 0)
  		ieee80211_free_chanctx(local, ctx);
  
++<<<<<<< HEAD
 +	sdata->radar_required = false;
++=======
+ 	link->radar_required = false;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	/* Unreserving may ready an in-place reservation. */
  	if (use_reserved_switch)
@@@ -1686,7 -1797,7 +1984,11 @@@ int ieee80211_link_use_channel(struct i
  	if (ret > 0)
  		radar_detect_width = BIT(chandef->width);
  
++<<<<<<< HEAD
 +	sdata->radar_required = ret;
++=======
+ 	sdata->link[link_id]->radar_required = ret;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	ret = ieee80211_check_combinations(sdata, chandef, mode,
  					   radar_detect_width);
@@@ -1717,7 -1828,7 +2019,11 @@@
  	ieee80211_recalc_radar_chanctx(local, ctx);
   out:
  	if (ret)
++<<<<<<< HEAD
 +		sdata->radar_required = false;
++=======
+ 		link->radar_required = false;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	mutex_unlock(&local->chanctx_mtx);
  	return ret;
@@@ -1733,8 -1845,8 +2040,13 @@@ int ieee80211_link_use_reserved_context
  	lockdep_assert_held(&local->mtx);
  	lockdep_assert_held(&local->chanctx_mtx);
  
++<<<<<<< HEAD
 +	new_ctx = sdata->reserved_chanctx;
 +	old_ctx = ieee80211_vif_get_chanctx(sdata);
++=======
+ 	new_ctx = link->reserved_chanctx;
+ 	old_ctx = ieee80211_link_get_chanctx(link);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	if (WARN_ON(!new_ctx))
  		return -EINVAL;
@@@ -1743,10 -1855,10 +2055,17 @@@
  		    IEEE80211_CHANCTX_WILL_BE_REPLACED))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (WARN_ON(sdata->reserved_ready))
 +		return -EINVAL;
 +
 +	sdata->reserved_ready = true;
++=======
+ 	if (WARN_ON(link->reserved_ready))
+ 		return -EINVAL;
+ 
+ 	link->reserved_ready = true;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	if (new_ctx->replace_state == IEEE80211_CHANCTX_REPLACE_NONE) {
  		if (old_ctx)
diff --cc net/mac80211/eht.c
index 364ad0ef7692,2d9c6e845ce4..000000000000
--- a/net/mac80211/eht.c
+++ b/net/mac80211/eht.c
@@@ -71,6 -71,6 +71,11 @@@ ieee80211_eht_cap_ie_to_sta_eht_cap(str
  
  	eht_cap->has_eht = true;
  
++<<<<<<< HEAD
 +	sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(sta);
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
++=======
+ 	sta->deflink.cur_max_bandwidth = ieee80211_sta_cap_rx_bw(sta, 0);
+ 	sta->sta.deflink.bandwidth = ieee80211_sta_cur_vht_bw(sta, 0);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  }
diff --cc net/mac80211/he.c
index c05af7018f79,20448dda8c4d..000000000000
--- a/net/mac80211/he.c
+++ b/net/mac80211/he.c
@@@ -153,8 -153,8 +153,13 @@@ ieee80211_he_cap_ie_to_sta_he_cap(struc
  
  	he_cap->has_he = true;
  
++<<<<<<< HEAD
 +	sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(sta);
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
++=======
+ 	sta->deflink.cur_max_bandwidth = ieee80211_sta_cap_rx_bw(sta, 0);
+ 	sta->sta.deflink.bandwidth = ieee80211_sta_cur_vht_bw(sta, 0);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	if (sband->band == NL80211_BAND_6GHZ && he_6ghz_capa)
  		ieee80211_update_from_he_6ghz_capa(he_6ghz_capa, sta);
diff --cc net/mac80211/ieee80211_i.h
index aebf2fa517be,92ed1e3c2980..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -901,6 -855,103 +901,106 @@@ struct ieee80211_if_nan 
  	struct idr function_inst_ids;
  };
  
++<<<<<<< HEAD
++=======
+ struct ieee80211_link_data_managed {
+ 	u8 bssid[ETH_ALEN] __aligned(2);
+ 
+ 	u8 dtim_period;
+ 	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+ 				 driver_smps_mode; /* smps mode request */
+ 
+ 	s16 p2p_noa_index;
+ 
+ 	bool have_beacon;
+ 
+ 	bool csa_waiting_bcn;
+ 	bool csa_ignored_same_chan;
+ 
+ 	struct work_struct request_smps_work;
+ 	bool beacon_crc_valid;
+ 	u32 beacon_crc;
+ 	struct ewma_beacon_signal ave_beacon_signal;
+ 	int last_ave_beacon_signal;
+ 
+ 	/*
+ 	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+ 	 * to avoid generating less reliable cqm events that would be based
+ 	 * only on couple of received frames.
+ 	 */
+ 	unsigned int count_beacon_signal;
+ 
+ 	/* Number of times beacon loss was invoked. */
+ 	unsigned int beacon_loss_count;
+ 
+ 	/*
+ 	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+ 	 * that triggered a cqm event. 0 indicates that no event has been
+ 	 * generated for the current association.
+ 	 */
+ 	int last_cqm_event_signal;
+ 
+ 	int wmm_last_param_set;
+ 	int mu_edca_last_param_set;
+ 
+ 	struct cfg80211_bss *bss;
+ };
+ 
+ struct ieee80211_link_data_ap {
+ 	struct beacon_data __rcu *beacon;
+ 	struct probe_resp __rcu *probe_resp;
+ 	struct fils_discovery_data __rcu *fils_discovery;
+ 	struct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;
+ 
+ 	/* to be used after channel switch. */
+ 	struct cfg80211_beacon_data *next_beacon;
+ };
+ 
+ struct ieee80211_link_data {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	unsigned int link_id;
+ 
+ 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
+ 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
+ 
+ 	/* multicast keys only */
+ 	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +
+ 					NUM_DEFAULT_MGMT_KEYS +
+ 					NUM_DEFAULT_BEACON_KEYS];
+ 	struct ieee80211_key __rcu *default_multicast_key;
+ 	struct ieee80211_key __rcu *default_mgmt_key;
+ 	struct ieee80211_key __rcu *default_beacon_key;
+ 
+ 	struct airtime_info airtime[IEEE80211_NUM_ACS];
+ 
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+ 
+ 	struct work_struct color_change_finalize_work;
+ 
+ 	/* context reservation -- protected with chanctx_mtx */
+ 	struct ieee80211_chanctx *reserved_chanctx;
+ 	struct cfg80211_chan_def reserved_chandef;
+ 	bool reserved_radar_required;
+ 	bool reserved_ready;
+ 
+ 	u8 needed_rx_chains;
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
+ 
+ 	bool radar_required;
+ 	struct delayed_work dfs_cac_timer_work;
+ 
+ 	union {
+ 		struct ieee80211_link_data_managed mgd;
+ 		struct ieee80211_link_data_ap ap;
+ 	} u;
+ };
+ 
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  struct ieee80211_sub_if_data {
  	struct list_head list;
  
@@@ -949,23 -995,6 +1049,26 @@@
  	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
  	struct mac80211_qos_map __rcu *qos_map;
  
++<<<<<<< HEAD
 +	struct airtime_info airtime[IEEE80211_NUM_ACS];
 +
 +	struct work_struct csa_finalize_work;
 +	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
 +	struct cfg80211_chan_def csa_chandef;
 +
 +	struct work_struct color_change_finalize_work;
 +
 +	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
 +	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
 +
 +	/* context reservation -- protected with chanctx_mtx */
 +	struct ieee80211_chanctx *reserved_chanctx;
 +	struct cfg80211_chan_def reserved_chandef;
 +	bool reserved_radar_required;
 +	bool reserved_ready;
 +
++=======
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  	/* used to reconfigure hardware SM PS */
  	struct work_struct recalc_smps;
  
diff --cc net/mac80211/iface.c
index 2581d6c14d3a,1764068a18d1..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -954,6 -1012,24 +954,27 @@@ static void ieee80211_set_default_queue
  	sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_sdata_init(struct ieee80211_local *local,
+ 				 struct ieee80211_sub_if_data *sdata)
+ {
+ 	sdata->local = local;
+ 
+ 	/*
+ 	 * Initialize the default link, so we can use link_id 0 for non-MLD,
+ 	 * and that continues to work for non-MLD-aware drivers that use just
+ 	 * vif.bss_conf instead of vif.link_conf.
+ 	 *
+ 	 * Note that we never change this, so if link ID 0 isn't used in an
+ 	 * MLD connection, we get a separate allocation for it.
+ 	 */
+ 	sdata->vif.link_conf[0] = &sdata->vif.bss_conf;
+ 	sdata->link[0] = &sdata->deflink;
+ 	sdata->deflink.sdata = sdata;
+ }
+ 
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
  {
  	struct ieee80211_sub_if_data *sdata;
@@@ -1151,8 -1228,8 +1172,13 @@@ int ieee80211_do_open(struct wireless_d
  	switch (sdata->vif.type) {
  	case NL80211_IFTYPE_AP_VLAN:
  		/* no need to tell driver, but set carrier and chanctx */
++<<<<<<< HEAD
 +		if (rtnl_dereference(sdata->bss->beacon)) {
 +			ieee80211_vif_vlan_copy_chanctx(sdata);
++=======
+ 		if (sdata->bss->active) {
+ 			ieee80211_link_vlan_copy_chanctx(sdata->link[0]);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  			netif_carrier_on(dev);
  			ieee80211_set_vif_encap_ops(sdata);
  		} else {
@@@ -1595,10 -1678,12 +1621,19 @@@ static void ieee80211_setup_sdata(struc
  	skb_queue_head_init(&sdata->status_queue);
  	INIT_WORK(&sdata->work, ieee80211_iface_work);
  	INIT_WORK(&sdata->recalc_smps, ieee80211_recalc_smps_work);
++<<<<<<< HEAD
 +	INIT_WORK(&sdata->csa_finalize_work, ieee80211_csa_finalize_work);
 +	INIT_WORK(&sdata->color_change_finalize_work, ieee80211_color_change_finalize_work);
 +	INIT_LIST_HEAD(&sdata->assigned_chanctx_list);
 +	INIT_LIST_HEAD(&sdata->reserved_chanctx_list);
++=======
+ 	INIT_WORK(&sdata->deflink.csa_finalize_work,
+ 		  ieee80211_csa_finalize_work);
+ 	INIT_WORK(&sdata->deflink.color_change_finalize_work,
+ 		  ieee80211_color_change_finalize_work);
+ 	INIT_LIST_HEAD(&sdata->deflink.assigned_chanctx_list);
+ 	INIT_LIST_HEAD(&sdata->deflink.reserved_chanctx_list);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	switch (type) {
  	case NL80211_IFTYPE_P2P_GO:
diff --cc net/mac80211/rx.c
index a4a989695100,1774d0f9feaa..000000000000
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@@ -3387,16 -3391,16 +3387,21 @@@ ieee80211_rx_h_action(struct ieee80211_
  			if (chanwidth == IEEE80211_HT_CHANWIDTH_20MHZ)
  				max_bw = IEEE80211_STA_RX_BW_20;
  			else
- 				max_bw = ieee80211_sta_cap_rx_bw(rx->sta);
+ 				max_bw = ieee80211_sta_cap_rx_bw(rx->sta, 0);
  
  			/* set cur_max_bandwidth and recalc sta bw */
++<<<<<<< HEAD
 +			rx->sta->cur_max_bandwidth = max_bw;
 +			new_bw = ieee80211_sta_cur_vht_bw(rx->sta);
++=======
+ 			rx->sta->deflink.cur_max_bandwidth = max_bw;
+ 			new_bw = ieee80211_sta_cur_vht_bw(rx->sta, 0);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
 -			if (rx->sta->sta.deflink.bandwidth == new_bw)
 +			if (rx->sta->sta.bandwidth == new_bw)
  				goto handled;
  
 -			rx->sta->sta.deflink.bandwidth = new_bw;
 +			rx->sta->sta.bandwidth = new_bw;
  			sband = rx->local->hw.wiphy->bands[status->band];
  			sta_opmode.bw =
  				ieee80211_sta_rx_bw_to_chan_width(rx->sta);
diff --cc net/mac80211/tdls.c
index 601011867929,86a13ef31ef1..000000000000
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@@ -1268,10 -1268,10 +1268,17 @@@ static void iee80211_tdls_recalc_chanct
  			enum ieee80211_sta_rx_bandwidth bw;
  
  			bw = ieee80211_chan_width_to_rx_bw(conf->def.width);
++<<<<<<< HEAD
 +			bw = min(bw, ieee80211_sta_cap_rx_bw(sta));
 +			if (bw != sta->sta.bandwidth) {
 +				sta->sta.bandwidth = bw;
 +				rate_control_rate_update(local, sband, sta,
++=======
+ 			bw = min(bw, ieee80211_sta_cap_rx_bw(sta, 0));
+ 			if (bw != sta->sta.deflink.bandwidth) {
+ 				sta->sta.deflink.bandwidth = bw;
+ 				rate_control_rate_update(local, sband, sta, 0,
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  							 IEEE80211_RC_BW_CHANGED);
  				/*
  				 * if a TDLS peer BW was updated, we need to
diff --cc net/mac80211/util.c
index 92656e4fd0a1,4ec96170a679..000000000000
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@@ -4410,20 -4414,26 +4415,38 @@@ static u8 ieee80211_chanctx_radar_detec
  	if (WARN_ON(ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED))
  		return 0;
  
++<<<<<<< HEAD
 +	list_for_each_entry(sdata, &ctx->reserved_vifs, reserved_chanctx_list)
 +		if (sdata->reserved_radar_required)
 +			radar_detect |= BIT(sdata->reserved_chandef.width);
++=======
+ 	list_for_each_entry(link, &ctx->reserved_links, reserved_chanctx_list)
+ 		if (link->reserved_radar_required)
+ 			radar_detect |= BIT(link->reserved_chandef.width);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	/*
  	 * An in-place reservation context should not have any assigned vifs
  	 * until it replaces the other context.
  	 */
  	WARN_ON(ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER &&
- 		!list_empty(&ctx->assigned_vifs));
+ 		!list_empty(&ctx->assigned_links));
  
++<<<<<<< HEAD
 +	list_for_each_entry(sdata, &ctx->assigned_vifs, assigned_chanctx_list)
 +		if (sdata->radar_required)
 +			radar_detect |= BIT(sdata->vif.bss_conf.chandef.width);
++=======
+ 	list_for_each_entry(link, &ctx->assigned_links, assigned_chanctx_list) {
+ 		struct ieee80211_sub_if_data *sdata = link->sdata;
+ 
+ 		if (!link->radar_required)
+ 			continue;
+ 
+ 		radar_detect |=
+ 			BIT(sdata->vif.link_conf[link->link_id]->chandef.width);
+ 	}
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	return radar_detect;
  }
diff --cc net/mac80211/vht.c
index bc39bec42e54,27d260be9123..000000000000
--- a/net/mac80211/vht.c
+++ b/net/mac80211/vht.c
@@@ -310,10 -310,10 +310,14 @@@ ieee80211_vht_cap_ie_to_sta_vht_cap(str
  		 * above) between 160 and 80+80 yet.
  		 */
  		if (cap_info & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK)
 -			sta->deflink.cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
 +			sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;
  	}
  
++<<<<<<< HEAD
 +	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
++=======
+ 	sta->sta.deflink.bandwidth = ieee80211_sta_cur_vht_bw(sta, 0);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	switch (vht_cap->cap & IEEE80211_VHT_CAP_MAX_MPDU_MASK) {
  	case IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:
@@@ -330,11 -330,14 +334,20 @@@
  }
  
  /* FIXME: move this to some better location - parses HE/EHT now */
- enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta)
+ enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta,
+ 							unsigned int link_id)
  {
++<<<<<<< HEAD
 +	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
 +	struct ieee80211_sta_he_cap *he_cap = &sta->sta.he_cap;
 +	struct ieee80211_sta_eht_cap *eht_cap = &sta->sta.eht_cap;
++=======
+ 	struct ieee80211_bss_conf *link_conf = sta->sdata->vif.link_conf[link_id];
+ 	struct ieee80211_link_sta *link_sta = sta->sta.link[link_id];
+ 	struct ieee80211_sta_vht_cap *vht_cap = &link_sta->vht_cap;
+ 	struct ieee80211_sta_he_cap *he_cap = &link_sta->he_cap;
+ 	struct ieee80211_sta_eht_cap *eht_cap = &link_sta->eht_cap;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  	u32 cap_width;
  
  	if (he_cap->has_he) {
@@@ -369,7 -370,7 +380,11 @@@
  	}
  
  	if (!vht_cap->vht_supported)
++<<<<<<< HEAD
 +		return sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++=======
+ 		return link_sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  				IEEE80211_STA_RX_BW_40 :
  				IEEE80211_STA_RX_BW_20;
  
@@@ -466,14 -467,15 +481,20 @@@ ieee80211_chan_width_to_rx_bw(enum nl80
  }
  
  /* FIXME: rename/move - this deals with everything not just VHT */
- enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta)
+ enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta,
+ 							 unsigned int link_id)
  {
- 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct ieee80211_bss_conf *link_conf = sta->sdata->vif.link_conf[link_id];
+ 	enum nl80211_chan_width bss_width = link_conf->chandef.width;
  	enum ieee80211_sta_rx_bandwidth bw;
- 	enum nl80211_chan_width bss_width = sdata->vif.bss_conf.chandef.width;
  
++<<<<<<< HEAD
 +	bw = ieee80211_sta_cap_rx_bw(sta);
 +	bw = min(bw, sta->cur_max_bandwidth);
++=======
+ 	bw = ieee80211_sta_cap_rx_bw(sta, link_id);
+ 	bw = min(bw, sta->link[link_id]->cur_max_bandwidth);
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  
  	/* Don't consider AP's bandwidth for TDLS peers, section 11.23.1 of
  	 * IEEE80211-2016 specification makes higher bandwidth operation
@@@ -629,9 -631,9 +650,15 @@@ u32 __ieee80211_vht_handle_opmode(struc
  		break;
  	}
  
++<<<<<<< HEAD
 +	new_bw = ieee80211_sta_cur_vht_bw(sta);
 +	if (new_bw != sta->sta.bandwidth) {
 +		sta->sta.bandwidth = new_bw;
++=======
+ 	new_bw = ieee80211_sta_cur_vht_bw(sta, 0);
+ 	if (new_bw != sta->sta.deflink.bandwidth) {
+ 		sta->sta.deflink.bandwidth = new_bw;
++>>>>>>> b4f85443c17c (wifi: mac80211: make channel context code MLO-aware)
  		sta_opmode.bw = ieee80211_sta_rx_bw_to_chan_width(sta);
  		changed |= IEEE80211_RC_BW_CHANGED;
  		sta_opmode.changed |= STA_OPMODE_MAX_BW_CHANGED;
* Unmerged path drivers/net/wireless/silabs/wfx/sta.c
* Unmerged path drivers/net/wireless/silabs/wfx/sta.h
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index f0f1ea0cb75e..05a197d346c4 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -8911,6 +8911,7 @@ ath10k_mac_op_change_chanctx(struct ieee80211_hw *hw,
 static int
 ath10k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 				 struct ieee80211_vif *vif,
+				 unsigned int link_id,
 				 struct ieee80211_chanctx_conf *ctx)
 {
 	struct ath10k *ar = hw->priv;
@@ -8990,6 +8991,7 @@ ath10k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 static void
 ath10k_mac_op_unassign_vif_chanctx(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif,
+				   unsigned int link_id,
 				   struct ieee80211_chanctx_conf *ctx)
 {
 	struct ath10k *ar = hw->priv;
diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index 5ba7709f4e71..da24411c90c1 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -7061,6 +7061,7 @@ static int ath11k_start_vdev_delay(struct ieee80211_hw *hw,
 static int
 ath11k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 				 struct ieee80211_vif *vif,
+				 unsigned int link_id,
 				 struct ieee80211_chanctx_conf *ctx)
 {
 	struct ath11k *ar = hw->priv;
@@ -7150,6 +7151,7 @@ ath11k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 static void
 ath11k_mac_op_unassign_vif_chanctx(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif,
+				   unsigned int link_id,
 				   struct ieee80211_chanctx_conf *ctx)
 {
 	struct ath11k *ar = hw->priv;
diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
index 8bf9317fc2a8..9ec6ed676720 100644
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -2596,6 +2596,7 @@ static void ath9k_change_chanctx(struct ieee80211_hw *hw,
 
 static int ath9k_assign_vif_chanctx(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif,
+				    unsigned int link_id,
 				    struct ieee80211_chanctx_conf *conf)
 {
 	struct ath_softc *sc = hw->priv;
@@ -2627,6 +2628,7 @@ static int ath9k_assign_vif_chanctx(struct ieee80211_hw *hw,
 
 static void ath9k_unassign_vif_chanctx(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif,
+				       unsigned int link_id,
 				       struct ieee80211_chanctx_conf *conf)
 {
 	struct ath_softc *sc = hw->priv;
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
index dd359df49b3f..0e5d0f359794 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
@@ -4236,6 +4236,7 @@ static int __iwl_mvm_assign_vif_chanctx(struct iwl_mvm *mvm,
 }
 static int iwl_mvm_assign_vif_chanctx(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
+				      unsigned int link_id,
 				      struct ieee80211_chanctx_conf *ctx)
 {
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
@@ -4309,6 +4310,7 @@ static void __iwl_mvm_unassign_vif_chanctx(struct iwl_mvm *mvm,
 
 static void iwl_mvm_unassign_vif_chanctx(struct ieee80211_hw *hw,
 					 struct ieee80211_vif *vif,
+					 unsigned int link_id,
 					 struct ieee80211_chanctx_conf *ctx)
 {
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index bd7a5899132f..920f52f7bec6 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -2722,6 +2722,7 @@ static void mac80211_hwsim_change_chanctx(struct ieee80211_hw *hw,
 
 static int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,
 					     struct ieee80211_vif *vif,
+					     unsigned int link_id,
 					     struct ieee80211_chanctx_conf *ctx)
 {
 	hwsim_check_magic(vif);
@@ -2732,6 +2733,7 @@ static int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,
 
 static void mac80211_hwsim_unassign_vif_chanctx(struct ieee80211_hw *hw,
 						struct ieee80211_vif *vif,
+						unsigned int link_id,
 						struct ieee80211_chanctx_conf *ctx)
 {
 	hwsim_check_magic(vif);
* Unmerged path drivers/net/wireless/silabs/wfx/sta.c
* Unmerged path drivers/net/wireless/silabs/wfx/sta.h
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index f7f0a4367259..477aa7d8da77 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -4696,6 +4696,7 @@ static void wlcore_op_change_chanctx(struct ieee80211_hw *hw,
 
 static int wlcore_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif,
+					unsigned int link_id,
 					struct ieee80211_chanctx_conf *ctx)
 {
 	struct wl1271 *wl = hw->priv;
@@ -4745,6 +4746,7 @@ static int wlcore_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 
 static void wlcore_op_unassign_vif_chanctx(struct ieee80211_hw *hw,
 					   struct ieee80211_vif *vif,
+					   unsigned int link_id,
 					   struct ieee80211_chanctx_conf *ctx)
 {
 	struct wl1271 *wl = hw->priv;
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 7d4037ae5055..8d7656a2ca7f 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -261,11 +261,13 @@ enum ieee80211_chanctx_switch_mode {
  * done.
  *
  * @vif: the vif that should be switched from old_ctx to new_ctx
+ * @link_id: the link ID that's switching
  * @old_ctx: the old context to which the vif was assigned
  * @new_ctx: the new context to which the vif must be assigned
  */
 struct ieee80211_vif_chanctx_switch {
 	struct ieee80211_vif *vif;
+	unsigned int link_id;
 	struct ieee80211_chanctx_conf *old_ctx;
 	struct ieee80211_chanctx_conf *new_ctx;
 };
@@ -4160,9 +4162,11 @@ struct ieee80211_ops {
 			       u32 changed);
 	int (*assign_vif_chanctx)(struct ieee80211_hw *hw,
 				  struct ieee80211_vif *vif,
+				  unsigned int link_id,
 				  struct ieee80211_chanctx_conf *ctx);
 	void (*unassign_vif_chanctx)(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif,
+				     unsigned int link_id,
 				     struct ieee80211_chanctx_conf *ctx);
 	int (*switch_vif_chanctx)(struct ieee80211_hw *hw,
 				  struct ieee80211_vif_chanctx_switch *vifs,
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f7b5957d466a..50087ee1e18a 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -829,9 +829,10 @@ static int ieee80211_set_monitor_channel(struct wiphy *wiphy,
 		sdata = wiphy_dereference(local->hw.wiphy,
 					  local->monitor_sdata);
 		if (sdata) {
-			ieee80211_vif_release_channel(sdata);
-			ret = ieee80211_vif_use_channel(sdata, chandef,
-					IEEE80211_CHANCTX_EXCLUSIVE);
+			ieee80211_link_release_channel(sdata->link[0]);
+			ret = ieee80211_link_use_channel(sdata->link[0],
+							 chandef,
+							 IEEE80211_CHANCTX_EXCLUSIVE);
 		}
 	} else if (local->open_count == local->monitors) {
 		local->_oper_chandef = *chandef;
@@ -1171,10 +1172,12 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 	}
 
 	mutex_lock(&local->mtx);
-	err = ieee80211_vif_use_channel(sdata, &params->chandef,
-					IEEE80211_CHANCTX_SHARED);
+	err = ieee80211_link_use_channel(sdata->link[params->beacon.link_id],
+					 &params->chandef,
+					 IEEE80211_CHANCTX_SHARED);
 	if (!err)
-		ieee80211_vif_copy_chanctx_to_vlans(sdata, false);
+		ieee80211_link_copy_chanctx_to_vlans(sdata->link[params->beacon.link_id],
+						     false);
 	mutex_unlock(&local->mtx);
 	if (err) {
 		sdata->vif.bss_conf.beacon_int = prev_beacon_int;
@@ -1283,7 +1286,7 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 
 error:
 	mutex_lock(&local->mtx);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_release_channel(sdata->link[params->beacon.link_id]);
 	mutex_unlock(&local->mtx);
 
 	return err;
@@ -1416,8 +1419,8 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	ieee80211_purge_tx_queue(&local->hw, &sdata->u.ap.ps.bc_buf);
 
 	mutex_lock(&local->mtx);
-	ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_copy_chanctx_to_vlans(sdata->link[link_id], true);
+	ieee80211_link_release_channel(sdata->link[link_id]);
 	mutex_unlock(&local->mtx);
 
 	return 0;
@@ -2384,8 +2387,8 @@ static int ieee80211_join_mesh(struct wiphy *wiphy, struct net_device *dev,
 	sdata->needed_rx_chains = sdata->local->rx_chains;
 
 	mutex_lock(&sdata->local->mtx);
-	err = ieee80211_vif_use_channel(sdata, &setup->chandef,
-					IEEE80211_CHANCTX_SHARED);
+	err = ieee80211_link_use_channel(sdata->link[0], &setup->chandef,
+					 IEEE80211_CHANCTX_SHARED);
 	mutex_unlock(&sdata->local->mtx);
 	if (err)
 		return err;
@@ -2399,7 +2402,7 @@ static int ieee80211_leave_mesh(struct wiphy *wiphy, struct net_device *dev)
 
 	ieee80211_stop_mesh(sdata);
 	mutex_lock(&sdata->local->mtx);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_release_channel(sdata->link[0]);
 	kfree(sdata->u.mesh.ie);
 	mutex_unlock(&sdata->local->mtx);
 
@@ -3126,8 +3129,8 @@ static int ieee80211_start_radar_detection(struct wiphy *wiphy,
 	sdata->smps_mode = IEEE80211_SMPS_OFF;
 	sdata->needed_rx_chains = local->rx_chains;
 
-	err = ieee80211_vif_use_channel(sdata, chandef,
-					IEEE80211_CHANCTX_SHARED);
+	err = ieee80211_link_use_channel(sdata->link[0], chandef,
+					 IEEE80211_CHANCTX_SHARED);
 	if (err)
 		goto out_unlock;
 
@@ -3155,7 +3158,7 @@ static void ieee80211_end_cac(struct wiphy *wiphy,
 		cancel_delayed_work(&sdata->dfs_cac_timer_work);
 
 		if (sdata->wdev.cac_started) {
-			ieee80211_vif_release_channel(sdata);
+			ieee80211_link_release_channel(sdata->link[0]);
 			sdata->wdev.cac_started = false;
 		}
 	}
@@ -3358,7 +3361,7 @@ static int __ieee80211_csa_finalize(struct ieee80211_sub_if_data *sdata)
 		if (sdata->reserved_ready)
 			return 0;
 
-		return ieee80211_vif_use_reserved_context(sdata);
+		return ieee80211_link_use_reserved_context(sdata->link[0]);
 	}
 
 	if (!cfg80211_chandef_identical(&sdata->vif.bss_conf.chandef,
@@ -3623,16 +3626,16 @@ __ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
 	if (err)
 		goto out;
 
-	err = ieee80211_vif_reserve_chanctx(sdata, &params->chandef,
-					    chanctx->mode,
-					    params->radar_required);
+	err = ieee80211_link_reserve_chanctx(sdata->link[0], &params->chandef,
+					     chanctx->mode,
+					     params->radar_required);
 	if (err)
 		goto out;
 
 	/* if reservation is invalid then this will fail */
 	err = ieee80211_check_combinations(sdata, NULL, chanctx->mode, 0);
 	if (err) {
-		ieee80211_vif_unreserve_chanctx(sdata);
+		ieee80211_link_unreserve_chanctx(sdata->link[0]);
 		goto out;
 	}
 
@@ -3642,7 +3645,7 @@ __ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
 
 	err = ieee80211_set_csa_beacon(sdata, params, &changed);
 	if (err) {
-		ieee80211_vif_unreserve_chanctx(sdata);
+		ieee80211_link_unreserve_chanctx(sdata->link[0]);
 		goto out;
 	}
 
@@ -3899,9 +3902,9 @@ static int ieee80211_cfg_get_channel(struct wiphy *wiphy,
 	int ret = -ENODATA;
 
 	rcu_read_lock();
-	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
+	chanctx_conf = rcu_dereference(sdata->vif.link_conf[link_id]->chanctx_conf);
 	if (chanctx_conf) {
-		*chandef = sdata->vif.bss_conf.chandef;
+		*chandef = sdata->vif.link_conf[link_id]->chandef;
 		ret = 0;
 	} else if (local->open_count > 0 &&
 		   local->open_count == local->monitors &&
@@ -3957,7 +3960,8 @@ static int ieee80211_set_ap_chanwidth(struct wiphy *wiphy,
 	int ret;
 	u32 changed = 0;
 
-	ret = ieee80211_vif_change_bandwidth(sdata, chandef, &changed);
+	ret = ieee80211_link_change_bandwidth(sdata->link[link_id], chandef,
+					      &changed);
 	if (ret == 0)
 		ieee80211_bss_info_change_notify(sdata, changed);
 
* Unmerged path net/mac80211/chan.c
diff --git a/net/mac80211/debug.h b/net/mac80211/debug.h
index d90a8f9cc3fd..3302e8da0314 100644
--- a/net/mac80211/debug.h
+++ b/net/mac80211/debug.h
@@ -1,4 +1,8 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Portions
+ * Copyright (C) 2022 Intel Corporation
+ */
 #ifndef __MAC80211_DEBUG_H
 #define __MAC80211_DEBUG_H
 #include <net/cfg80211.h>
@@ -130,6 +134,16 @@ do {									\
 #define sdata_dbg(sdata, fmt, ...)					\
 	_sdata_dbg(1, sdata, fmt, ##__VA_ARGS__)
 
+#define link_info(link, fmt, ...)					\
+	_sdata_info((link)->sdata, "[link %d] " fmt, (link)->link_id,	\
+		    ##__VA_ARGS__)
+#define link_err(link, fmt, ...)					\
+	_sdata_err((link)->sdata, "[link %d] " fmt, (link)->link_id,	\
+		   ##__VA_ARGS__)
+#define link_dbg(link, fmt, ...)					\
+	_sdata_dbg(1, (link)->sdata, "[link %d] " fmt, (link)->link_id,	\
+		   ##__VA_ARGS__)
+
 #define ht_dbg(sdata, fmt, ...)						\
 	_sdata_dbg(MAC80211_HT_DEBUG,					\
 		   sdata, fmt, ##__VA_ARGS__)
diff --git a/net/mac80211/driver-ops.h b/net/mac80211/driver-ops.h
index 173a201d5e6d..05298df6ed43 100644
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -917,6 +917,7 @@ static inline void drv_change_chanctx(struct ieee80211_local *local,
 
 static inline int drv_assign_vif_chanctx(struct ieee80211_local *local,
 					 struct ieee80211_sub_if_data *sdata,
+					 unsigned int link_id,
 					 struct ieee80211_chanctx *ctx)
 {
 	int ret = 0;
@@ -924,11 +925,12 @@ static inline int drv_assign_vif_chanctx(struct ieee80211_local *local,
 	if (!check_sdata_in_driver(sdata))
 		return -EIO;
 
-	trace_drv_assign_vif_chanctx(local, sdata, ctx);
+	trace_drv_assign_vif_chanctx(local, sdata, link_id, ctx);
 	if (local->ops->assign_vif_chanctx) {
 		WARN_ON_ONCE(!ctx->driver_present);
 		ret = local->ops->assign_vif_chanctx(&local->hw,
 						     &sdata->vif,
+						     link_id,
 						     &ctx->conf);
 	}
 	trace_drv_return_int(local, ret);
@@ -938,6 +940,7 @@ static inline int drv_assign_vif_chanctx(struct ieee80211_local *local,
 
 static inline void drv_unassign_vif_chanctx(struct ieee80211_local *local,
 					    struct ieee80211_sub_if_data *sdata,
+					    unsigned int link_id,
 					    struct ieee80211_chanctx *ctx)
 {
 	might_sleep();
@@ -945,11 +948,12 @@ static inline void drv_unassign_vif_chanctx(struct ieee80211_local *local,
 	if (!check_sdata_in_driver(sdata))
 		return;
 
-	trace_drv_unassign_vif_chanctx(local, sdata, ctx);
+	trace_drv_unassign_vif_chanctx(local, sdata, link_id, ctx);
 	if (local->ops->unassign_vif_chanctx) {
 		WARN_ON_ONCE(!ctx->driver_present);
 		local->ops->unassign_vif_chanctx(&local->hw,
 						 &sdata->vif,
+						 link_id,
 						 &ctx->conf);
 	}
 	trace_drv_return_void(local);
* Unmerged path net/mac80211/eht.c
* Unmerged path net/mac80211/he.c
diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c
index cfd5e16e19ac..2da32eae0b7a 100644
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@ -301,8 +301,8 @@ static void __ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
 	radar_required = err;
 
 	mutex_lock(&local->mtx);
-	if (ieee80211_vif_use_channel(sdata, &chandef,
-				      ifibss->fixed_channel ?
+	if (ieee80211_link_use_channel(sdata->link[0], &chandef,
+				       ifibss->fixed_channel ?
 					IEEE80211_CHANCTX_SHARED :
 					IEEE80211_CHANCTX_EXCLUSIVE)) {
 		sdata_info(sdata, "Failed to join IBSS, no channel context\n");
@@ -371,7 +371,7 @@ static void __ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
 		RCU_INIT_POINTER(ifibss->presp, NULL);
 		kfree_rcu(presp, rcu_head);
 		mutex_lock(&local->mtx);
-		ieee80211_vif_release_channel(sdata);
+		ieee80211_link_release_channel(sdata->link[0]);
 		mutex_unlock(&local->mtx);
 		sdata_info(sdata, "Failed to join IBSS, driver failure: %d\n",
 			   err);
@@ -725,7 +725,7 @@ static void ieee80211_ibss_disconnect(struct ieee80211_sub_if_data *sdata)
 						BSS_CHANGED_IBSS);
 	drv_leave_ibss(local, sdata);
 	mutex_lock(&local->mtx);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_release_channel(sdata->link[0]);
 	mutex_unlock(&local->mtx);
 }
 
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/iface.c
diff --git a/net/mac80211/mesh_plink.c b/net/mac80211/mesh_plink.c
index a829470dd59e..17048bf6c471 100644
--- a/net/mac80211/mesh_plink.c
+++ b/net/mac80211/mesh_plink.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2008, 2009 open80211s Ltd.
- * Copyright (C) 2019, 2021 Intel Corporation
+ * Copyright (C) 2019, 2021-2022 Intel Corporation
  * Author:     Luis Carlos Cobo <luisca@cozybit.com>
  */
 #include <linux/gfp.h>
@@ -464,7 +464,7 @@ static void mesh_sta_info_init(struct ieee80211_sub_if_data *sdata,
 	if (!test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
 		rate_control_rate_init(sta);
 	else
-		rate_control_rate_update(local, sband, sta, changed);
+		rate_control_rate_update(local, sband, sta, 0, changed);
 out:
 	spin_unlock_bh(&sta->mesh->plink_lock);
 }
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index dbd8b816487b..423797290278 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -479,7 +479,7 @@ static int ieee80211_config_bw(struct ieee80211_sub_if_data *sdata,
 		return -EINVAL;
 	}
 
-	ret = ieee80211_vif_change_bandwidth(sdata, &chandef, changed);
+	ret = ieee80211_link_change_bandwidth(&sdata->deflink, &chandef, changed);
 
 	if (ret) {
 		sdata_info(sdata,
@@ -1251,7 +1251,7 @@ static void ieee80211_chswitch_work(struct work_struct *work)
 		if (sdata->reserved_ready)
 			goto out;
 
-		ret = ieee80211_vif_use_reserved_context(sdata);
+		ret = ieee80211_link_use_reserved_context(&sdata->deflink);
 		if (ret) {
 			sdata_info(sdata,
 				   "failed to use reserved channel context, disconnecting (err=%d)\n",
@@ -1356,7 +1356,7 @@ ieee80211_sta_abort_chanswitch(struct ieee80211_sub_if_data *sdata)
 	mutex_lock(&local->mtx);
 
 	mutex_lock(&local->chanctx_mtx);
-	ieee80211_vif_unreserve_chanctx(sdata);
+	ieee80211_link_unreserve_chanctx(&sdata->deflink);
 	mutex_unlock(&local->chanctx_mtx);
 
 	if (sdata->csa_block_tx)
@@ -1497,8 +1497,8 @@ ieee80211_sta_process_chanswitch(struct ieee80211_sub_if_data *sdata,
 		goto drop_connection;
 	}
 
-	res = ieee80211_vif_reserve_chanctx(sdata, &csa_ie.chandef,
-					    chanctx->mode, false);
+	res = ieee80211_link_reserve_chanctx(&sdata->deflink, &csa_ie.chandef,
+					     chanctx->mode, false);
 	if (res) {
 		sdata_info(sdata,
 			   "failed to reserve channel context for channel switch, disconnecting (err=%d)\n",
@@ -1943,7 +1943,7 @@ void ieee80211_dfs_cac_timer_work(struct work_struct *work)
 
 	mutex_lock(&sdata->local->mtx);
 	if (sdata->wdev.cac_started) {
-		ieee80211_vif_release_channel(sdata);
+		ieee80211_link_release_channel(&sdata->deflink);
 		cfg80211_cac_event(sdata->dev, &chandef,
 				   NL80211_RADAR_CAC_FINISHED,
 				   GFP_KERNEL);
@@ -2483,7 +2483,7 @@ static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,
 
 	ifmgd->flags = 0;
 	mutex_lock(&local->mtx);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_release_channel(&sdata->deflink);
 
 	sdata->vif.bss_conf.csa_active = false;
 	ifmgd->csa_waiting_bcn = false;
@@ -2923,7 +2923,7 @@ static void ieee80211_destroy_auth_data(struct ieee80211_sub_if_data *sdata,
 		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
 		sdata->u.mgd.flags = 0;
 		mutex_lock(&sdata->local->mtx);
-		ieee80211_vif_release_channel(sdata);
+		ieee80211_link_release_channel(&sdata->deflink);
 		mutex_unlock(&sdata->local->mtx);
 	}
 
@@ -2954,7 +2954,7 @@ static void ieee80211_destroy_assoc_data(struct ieee80211_sub_if_data *sdata,
 		sdata->vif.bss_conf.mu_mimo_owner = false;
 
 		mutex_lock(&sdata->local->mtx);
-		ieee80211_vif_release_channel(sdata);
+		ieee80211_link_release_channel(&sdata->deflink);
 		mutex_unlock(&sdata->local->mtx);
 
 		if (abandon)
@@ -5492,8 +5492,8 @@ static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
 	 * on incompatible channels, e.g. 80+80 and 160 sharing the
 	 * same control channel) try to use a smaller bandwidth.
 	 */
-	ret = ieee80211_vif_use_channel(sdata, &chandef,
-					IEEE80211_CHANCTX_SHARED);
+	ret = ieee80211_link_use_channel(&sdata->deflink, &chandef,
+					 IEEE80211_CHANCTX_SHARED);
 
 	/* don't downgrade for 5 and 10 MHz channels, though. */
 	if (chandef.width == NL80211_CHAN_WIDTH_5 ||
@@ -5502,8 +5502,8 @@ static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
 
 	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
 		ifmgd->flags |= ieee80211_chandef_downgrade(&chandef);
-		ret = ieee80211_vif_use_channel(sdata, &chandef,
-						IEEE80211_CHANCTX_SHARED);
+		ret = ieee80211_link_use_channel(&sdata->deflink, &chandef,
+						 IEEE80211_CHANCTX_SHARED);
 	}
  out:
 	mutex_unlock(&local->mtx);
@@ -5863,7 +5863,7 @@ int ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,
 	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
 	ifmgd->auth_data = NULL;
 	mutex_lock(&sdata->local->mtx);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_release_channel(&sdata->deflink);
 	mutex_unlock(&sdata->local->mtx);
 	kfree(auth_data);
 	return err;
diff --git a/net/mac80211/ocb.c b/net/mac80211/ocb.c
index 1b28b4d92936..f01d05049536 100644
--- a/net/mac80211/ocb.c
+++ b/net/mac80211/ocb.c
@@ -186,8 +186,8 @@ int ieee80211_ocb_join(struct ieee80211_sub_if_data *sdata,
 	sdata->needed_rx_chains = sdata->local->rx_chains;
 
 	mutex_lock(&sdata->local->mtx);
-	err = ieee80211_vif_use_channel(sdata, &setup->chandef,
-					IEEE80211_CHANCTX_SHARED);
+	err = ieee80211_link_use_channel(sdata->link[0], &setup->chandef,
+					 IEEE80211_CHANCTX_SHARED);
 	mutex_unlock(&sdata->local->mtx);
 	if (err)
 		return err;
@@ -229,7 +229,7 @@ int ieee80211_ocb_leave(struct ieee80211_sub_if_data *sdata)
 	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_OCB);
 
 	mutex_lock(&sdata->local->mtx);
-	ieee80211_vif_release_channel(sdata);
+	ieee80211_link_release_channel(sdata->link[0]);
 	mutex_unlock(&sdata->local->mtx);
 
 	skb_queue_purge(&sdata->skb_queue);
diff --git a/net/mac80211/rate.c b/net/mac80211/rate.c
index 638474e631f4..917a19da36a1 100644
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -90,14 +90,17 @@ void rate_control_tx_status(struct ieee80211_local *local,
 }
 
 void rate_control_rate_update(struct ieee80211_local *local,
-				    struct ieee80211_supported_band *sband,
-				    struct sta_info *sta, u32 changed)
+			      struct ieee80211_supported_band *sband,
+			      struct sta_info *sta, unsigned int link_id,
+			      u32 changed)
 {
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
 	struct ieee80211_chanctx_conf *chanctx_conf;
 
+	WARN_ON(link_id != 0);
+
 	if (ref && ref->ops->rate_update) {
 		rcu_read_lock();
 
@@ -113,6 +116,7 @@ void rate_control_rate_update(struct ieee80211_local *local,
 		spin_unlock_bh(&sta->rate_ctrl_lock);
 		rcu_read_unlock();
 	}
+
 	drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
 }
 
diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 79b44d3db171..fbc8bdb54c43 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -3,6 +3,7 @@
  * Copyright 2002-2005, Instant802 Networks, Inc.
  * Copyright 2005, Devicescape Software, Inc.
  * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
+ * Copyright (C) 2022 Intel Corporation
  */
 
 #ifndef IEEE80211_RATE_H
@@ -31,8 +32,10 @@ void rate_control_tx_status(struct ieee80211_local *local,
 
 void rate_control_rate_init(struct sta_info *sta);
 void rate_control_rate_update(struct ieee80211_local *local,
-				    struct ieee80211_supported_band *sband,
-				    struct sta_info *sta, u32 changed);
+			      struct ieee80211_supported_band *sband,
+			      struct sta_info *sta,
+			      unsigned int link_id,
+			      u32 changed);
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
 					   struct sta_info *sta, gfp_t gfp)
* Unmerged path net/mac80211/rx.c
* Unmerged path net/mac80211/tdls.c
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index 17e7760d8348..7d79a70a0e39 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -1592,6 +1592,7 @@ struct trace_chandef_entry {
 
 struct trace_switch_entry {
 	struct trace_vif_entry vif;
+	unsigned int link_id;
 	struct trace_chandef_entry old_chandef;
 	struct trace_chandef_entry new_chandef;
 } __packed;
@@ -1631,6 +1632,7 @@ TRACE_EVENT(drv_switch_vif_chanctx,
 
 				SWITCH_ENTRY_ASSIGN(vif.vif_type, vif->type);
 				SWITCH_ENTRY_ASSIGN(vif.p2p, vif->p2p);
+				SWITCH_ENTRY_ASSIGN(link_id, link_id);
 				strncpy(local_vifs[i].vif.vif_name,
 					sdata->name,
 					sizeof(local_vifs[i].vif.vif_name));
@@ -1671,40 +1673,45 @@ TRACE_EVENT(drv_switch_vif_chanctx,
 DECLARE_EVENT_CLASS(local_sdata_chanctx,
 	TP_PROTO(struct ieee80211_local *local,
 		 struct ieee80211_sub_if_data *sdata,
+		 unsigned int link_id,
 		 struct ieee80211_chanctx *ctx),
 
-	TP_ARGS(local, sdata, ctx),
+	TP_ARGS(local, sdata, link_id, ctx),
 
 	TP_STRUCT__entry(
 		LOCAL_ENTRY
 		VIF_ENTRY
 		CHANCTX_ENTRY
+		__field(unsigned int, link_id)
 	),
 
 	TP_fast_assign(
 		LOCAL_ASSIGN;
 		VIF_ASSIGN;
 		CHANCTX_ASSIGN;
+		__entry->link_id = link_id;
 	),
 
 	TP_printk(
-		LOCAL_PR_FMT VIF_PR_FMT CHANCTX_PR_FMT,
-		LOCAL_PR_ARG, VIF_PR_ARG, CHANCTX_PR_ARG
+		LOCAL_PR_FMT VIF_PR_FMT " link_id:%d" CHANCTX_PR_FMT,
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->link_id, CHANCTX_PR_ARG
 	)
 );
 
 DEFINE_EVENT(local_sdata_chanctx, drv_assign_vif_chanctx,
 	TP_PROTO(struct ieee80211_local *local,
 		 struct ieee80211_sub_if_data *sdata,
+		 unsigned int link_id,
 		 struct ieee80211_chanctx *ctx),
-	TP_ARGS(local, sdata, ctx)
+	TP_ARGS(local, sdata, link_id, ctx)
 );
 
 DEFINE_EVENT(local_sdata_chanctx, drv_unassign_vif_chanctx,
 	TP_PROTO(struct ieee80211_local *local,
 		 struct ieee80211_sub_if_data *sdata,
+		 unsigned int link_id,
 		 struct ieee80211_chanctx *ctx),
-	TP_ARGS(local, sdata, ctx)
+	TP_ARGS(local, sdata, link_id, ctx)
 );
 
 TRACE_EVENT(drv_start_ap,
* Unmerged path net/mac80211/util.c
* Unmerged path net/mac80211/vht.c
