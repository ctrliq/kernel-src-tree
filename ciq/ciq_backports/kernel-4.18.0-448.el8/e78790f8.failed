f2fs: fix retry logic in f2fs_write_cache_pages()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-448.el8
commit-author Sahitya Tummala <stummala@codeaurora.org>
commit e78790f84a5417287965a06cd4dea85df0743935
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-448.el8/e78790f8.failed

In case a compressed file is getting overwritten, the current retry
logic doesn't include the current page to be retried now as it sets
the new start index as 0 and new end index as writeback_index - 1.
This causes the corresponding cluster to be uncompressed and written
as normal pages without compression. Fix this by allowing writeback to
be retried for the current page as well (in case of compressed page
getting retried due to index mismatch with cluster index). So that
this cluster can be written compressed in case of overwrite.

Also, align f2fs_write_cache_pages() according to the change -
<64081362e8ff>("mm/page-writeback.c: fix range_cyclic writeback vs
writepages deadlock").

	Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
	Reviewed-by: Chao Yu <yuchao0@huawei.com>
	Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
(cherry picked from commit e78790f84a5417287965a06cd4dea85df0743935)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/f2fs/data.c
diff --cc fs/f2fs/data.c
index c1dbdc33dfa6,a65bfc07ddb9..000000000000
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@@ -1944,10 -2861,11 +1944,13 @@@ static int f2fs_write_cache_pages(struc
  	pgoff_t index;
  	pgoff_t end;		/* Inclusive */
  	pgoff_t done_index;
++<<<<<<< HEAD
 +	pgoff_t last_idx = ULONG_MAX;
 +	int cycled;
++=======
++>>>>>>> e78790f84a54 (f2fs: fix retry logic in f2fs_write_cache_pages())
  	int range_whole = 0;
 -	xa_mark_t tag;
 -	int nwritten = 0;
 -	int submitted = 0;
 -	int i;
 +	int tag;
  
  	pagevec_init(&pvec);
  
@@@ -2062,13 -3036,25 +2060,31 @@@ continue_unlock
  		pagevec_release(&pvec);
  		cond_resched();
  	}
++<<<<<<< HEAD
 +
 +	if (!cycled && !done) {
 +		cycled = 1;
++=======
+ #ifdef CONFIG_F2FS_FS_COMPRESSION
+ 	/* flush remained pages in compress cluster */
+ 	if (f2fs_compressed_file(inode) && !f2fs_cluster_is_empty(&cc)) {
+ 		ret = f2fs_write_multi_pages(&cc, &submitted, wbc, io_type);
+ 		nwritten += submitted;
+ 		wbc->nr_to_write -= submitted;
+ 		if (ret) {
+ 			done = 1;
+ 			retry = 0;
+ 		}
+ 	}
+ #endif
+ 	if (retry) {
++>>>>>>> e78790f84a54 (f2fs: fix retry logic in f2fs_write_cache_pages())
  		index = 0;
- 		end = writeback_index - 1;
+ 		end = -1;
  		goto retry;
  	}
+ 	if (wbc->range_cyclic && !done)
+ 		done_index = 0;
  	if (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))
  		mapping->writeback_index = done_index;
  
* Unmerged path fs/f2fs/data.c
