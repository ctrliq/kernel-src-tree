smb: client: fix TCP timers deadlock after rmmod

jira LE-3845
cve CVE-2024-54680
Rebuild_History Non-Buildable kernel-4.18.0-553.66.1.el8_10
commit-author Enzo Matsumiya <ematsumiya@suse.de>
commit e9f2517a3e18a54a3943c098d2226b245d488801
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.66.1.el8_10/e9f2517a.failed

Commit ef7134c7fc48 ("smb: client: Fix use-after-free of network namespace.")
fixed a netns UAF by manually enabled socket refcounting
(sk->sk_net_refcnt=1 and sock_inuse_add(net, 1)).

The reason the patch worked for that bug was because we now hold
references to the netns (get_net_track() gets a ref internally)
and they're properly released (internally, on __sk_destruct()),
but only because sk->sk_net_refcnt was set.

Problem:
(this happens regardless of CONFIG_NET_NS_REFCNT_TRACKER and regardless
if init_net or other)

Setting sk->sk_net_refcnt=1 *manually* and *after* socket creation is not
only out of cifs scope, but also technically wrong -- it's set conditionally
based on user (=1) vs kernel (=0) sockets.  And net/ implementations
seem to base their user vs kernel space operations on it.

e.g. upon TCP socket close, the TCP timers are not cleared because
sk->sk_net_refcnt=1:
(cf. commit 151c9c724d05 ("tcp: properly terminate timers for kernel sockets"))

net/ipv4/tcp.c:
    void tcp_close(struct sock *sk, long timeout)
    {
    	lock_sock(sk);
    	__tcp_close(sk, timeout);
    	release_sock(sk);
    	if (!sk->sk_net_refcnt)
    		inet_csk_clear_xmit_timers_sync(sk);
    	sock_put(sk);
    }

Which will throw a lockdep warning and then, as expected, deadlock on
tcp_write_timer().

A way to reproduce this is by running the reproducer from ef7134c7fc48
and then 'rmmod cifs'.  A few seconds later, the deadlock/lockdep
warning shows up.

Fix:
We shouldn't mess with socket internals ourselves, so do not set
sk_net_refcnt manually.

Also change __sock_create() to sock_create_kern() for explicitness.

As for non-init_net network namespaces, we deal with it the best way
we can -- hold an extra netns reference for server->ssocket and drop it
when it's released.  This ensures that the netns still exists whenever
we need to create/destroy server->ssocket, but is not directly tied to
it.

Fixes: ef7134c7fc48 ("smb: client: Fix use-after-free of network namespace.")
	Cc: stable@vger.kernel.org
	Signed-off-by: Enzo Matsumiya <ematsumiya@suse.de>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit e9f2517a3e18a54a3943c098d2226b245d488801)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index bd2ad3b69c7e,ddcc9e514a0e..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -842,10 -1041,9 +846,15 @@@ static void clean_demultiplex_info(stru
  		 */
  	}
  
++<<<<<<< HEAD:fs/cifs/connect.c
 +#ifdef CONFIG_CIFS_DFS_UPCALL
 +	kfree(server->origin_fullpath);
++=======
+ 	/* Release netns reference for this server. */
+ 	put_net(cifs_net_ns(server));
++>>>>>>> e9f2517a3e18 (smb: client: fix TCP timers deadlock after rmmod):fs/smb/client/connect.c
  	kfree(server->leaf_fullpath);
 +#endif
  	kfree(server);
  
  	length = atomic_dec_return(&tcpSesAllocCount);
@@@ -1593,11 -1856,14 +1605,18 @@@ out_err_crypto_release
  
  out_err:
  	if (tcp_ses) {
 -		if (SERVER_IS_CHAN(tcp_ses))
 +		if (CIFS_SERVER_IS_CHAN(tcp_ses))
  			cifs_put_tcp_session(tcp_ses->primary_server, false);
  		kfree(tcp_ses->hostname);
++<<<<<<< HEAD:fs/cifs/connect.c
 +		if (tcp_ses->ssocket)
++=======
+ 		kfree(tcp_ses->leaf_fullpath);
+ 		if (tcp_ses->ssocket) {
++>>>>>>> e9f2517a3e18 (smb: client: fix TCP timers deadlock after rmmod):fs/smb/client/connect.c
  			sock_release(tcp_ses->ssocket);
+ 			put_net(cifs_net_ns(tcp_ses));
+ 		}
  		kfree(tcp_ses);
  	}
  	return ERR_PTR(rc);
@@@ -2712,13 -3140,22 +2731,30 @@@ generic_ip_connect(struct TCP_Server_In
  	if (server->ssocket) {
  		socket = server->ssocket;
  	} else {
++<<<<<<< HEAD:fs/cifs/connect.c
 +		rc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,
 +				   IPPROTO_TCP, &server->ssocket, 1);
++=======
+ 		struct net *net = cifs_net_ns(server);
+ 
+ 		rc = sock_create_kern(net, sfamily, SOCK_STREAM, IPPROTO_TCP, &server->ssocket);
++>>>>>>> e9f2517a3e18 (smb: client: fix TCP timers deadlock after rmmod):fs/smb/client/connect.c
  		if (rc < 0) {
  			cifs_server_dbg(VFS, "Error %d creating socket\n", rc);
  			return rc;
  		}
  
++<<<<<<< HEAD:fs/cifs/connect.c
++=======
+ 		/*
+ 		 * Grab netns reference for the socket.
+ 		 *
+ 		 * It'll be released here, on error, or in clean_demultiplex_info() upon server
+ 		 * teardown.
+ 		 */
+ 		get_net(net);
+ 
++>>>>>>> e9f2517a3e18 (smb: client: fix TCP timers deadlock after rmmod):fs/smb/client/connect.c
  		/* BB other socket options to set KEEPALIVE, NODELAY? */
  		cifs_dbg(FYI, "Socket created\n");
  		socket = server->ssocket;
* Unmerged path fs/cifs/connect.c
