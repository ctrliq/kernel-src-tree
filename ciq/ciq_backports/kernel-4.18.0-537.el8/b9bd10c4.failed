s390/vfio-ap: do not reset queue removed from host config

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-537.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit b9bd10c43456d16abd97b717446f51afb3b88411
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-537.el8/b9bd10c4.failed

When a queue is unbound from the vfio_ap device driver, it is reset to
ensure its crypto data is not leaked when it is bound to another device
driver. If the queue is unbound due to the fact that the adapter or domain
was removed from the host's AP configuration, then attempting to reset it
will fail with response code 01 (APID not valid) getting returned from the
reset command. Let's ensure that the queue is assigned to the host's
configuration before resetting it.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: "Jason J. Herne" <jjherne@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
Fixes: eeb386aeb5b7 ("s390/vfio-ap: handle config changed and scan complete notification")
	Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20240115185441.31526-7-akrowiak@linux.ibm.com
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit b9bd10c43456d16abd97b717446f51afb3b88411)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index cc0a2dfafc79,983b3b16196c..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -2008,26 -2215,40 +2008,50 @@@ void vfio_ap_mdev_remove_queue(struct a
  	q = dev_get_drvdata(&apdev->device);
  	get_update_locks_for_queue(q);
  	matrix_mdev = q->matrix_mdev;
+ 	apid = AP_QID_CARD(q->apqn);
+ 	apqi = AP_QID_QUEUE(q->apqn);
  
  	if (matrix_mdev) {
++<<<<<<< HEAD
 +		vfio_ap_unlink_queue_fr_mdev(q);
 +
 +		apid = AP_QID_CARD(q->apqn);
 +		apqi = AP_QID_QUEUE(q->apqn);
 +
 +		/*
 +		 * If the queue is assigned to the guest's APCB, then remove
 +		 * the adapter's APID from the APCB and hot it into the guest.
 +		 */
++=======
+ 		/* If the queue is assigned to the guest's AP configuration */
++>>>>>>> b9bd10c43456 (s390/vfio-ap: do not reset queue removed from host config)
  		if (test_bit_inv(apid, matrix_mdev->shadow_apcb.apm) &&
  		    test_bit_inv(apqi, matrix_mdev->shadow_apcb.aqm)) {
 -			/*
 -			 * Since the queues are defined via a matrix of adapters
 -			 * and domains, it is not possible to hot unplug a
 -			 * single queue; so, let's unplug the adapter.
 -			 */
  			clear_bit_inv(apid, matrix_mdev->shadow_apcb.apm);
  			vfio_ap_mdev_update_guest_apcb(matrix_mdev);
 -			reset_queues_for_apid(matrix_mdev, apid);
 -			goto done;
  		}
  	}
  
++<<<<<<< HEAD
 +	vfio_ap_mdev_reset_queue(q);
 +	flush_work(&q->reset_work);
++=======
+ 	/*
+ 	 * If the queue is not in the host's AP configuration, then resetting
+ 	 * it will fail with response code 01, (APQN not valid); so, let's make
+ 	 * sure it is in the host's config.
+ 	 */
+ 	if (test_bit_inv(apid, (unsigned long *)matrix_dev->info.apm) &&
+ 	    test_bit_inv(apqi, (unsigned long *)matrix_dev->info.aqm)) {
+ 		vfio_ap_mdev_reset_queue(q);
+ 		flush_work(&q->reset_work);
+ 	}
+ 
+ done:
+ 	if (matrix_mdev)
+ 		vfio_ap_unlink_queue_fr_mdev(q);
+ 
++>>>>>>> b9bd10c43456 (s390/vfio-ap: do not reset queue removed from host config)
  	dev_set_drvdata(&apdev->device, NULL);
  	kfree(q);
  	release_update_locks_for_mdev(matrix_mdev);
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
