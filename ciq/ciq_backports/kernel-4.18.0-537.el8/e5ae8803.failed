cgroup/cpuset: Fix wrong check in update_parent_subparts_cpumask()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-537.el8
commit-author Waiman Long <longman@redhat.com>
commit e5ae8803847b80fe9d744a3174abe2b7bfed222a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-537.el8/e5ae8803.failed

It was found that the check to see if a partition could use up all
the cpus from the parent cpuset in update_parent_subparts_cpumask()
was incorrect. As a result, it is possible to leave parent with no
effective cpu left even if there are tasks in the parent cpuset. This
can lead to system panic as reported in [1].

Fix this probem by updating the check to fail the enabling the partition
if parent's effective_cpus is a subset of the child's cpus_allowed.

Also record the error code when an error happens in update_prstate()
and add a test case where parent partition and child have the same cpu
list and parent has task. Enabling partition in the child will fail in
this case.

[1] https://www.spinics.net/lists/cgroups/msg36254.html

Fixes: f0af1bfc27b5 ("cgroup/cpuset: Relax constraints to partition & cpus changes")
	Cc: stable@vger.kernel.org # v6.1
	Reported-by: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
	Signed-off-by: Waiman Long <longman@redhat.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit e5ae8803847b80fe9d744a3174abe2b7bfed222a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/cgroup/test_cpuset_prs.sh
* Unmerged path tools/testing/selftests/cgroup/test_cpuset_prs.sh
diff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c
index a5dd5c03f39d..a44d27f36d52 100644
--- a/kernel/cgroup/cpuset.c
+++ b/kernel/cgroup/cpuset.c
@@ -1333,7 +1333,7 @@ static int update_parent_subparts_cpumask(struct cpuset *cs, int cmd,
 		 * A parent can be left with no CPU as long as there is no
 		 * task directly associated with the parent partition.
 		 */
-		if (!cpumask_intersects(cs->cpus_allowed, parent->effective_cpus) &&
+		if (cpumask_subset(parent->effective_cpus, cs->cpus_allowed) &&
 		    partition_is_populated(parent, cs))
 			return PERR_NOCPUS;
 
@@ -2311,6 +2311,7 @@ static int update_prstate(struct cpuset *cs, int new_prs)
 		new_prs = -new_prs;
 	spin_lock_irq(&callback_lock);
 	cs->partition_root_state = new_prs;
+	WRITE_ONCE(cs->prs_err, err);
 	spin_unlock_irq(&callback_lock);
 	/*
 	 * Update child cpusets, if present.
* Unmerged path tools/testing/selftests/cgroup/test_cpuset_prs.sh
