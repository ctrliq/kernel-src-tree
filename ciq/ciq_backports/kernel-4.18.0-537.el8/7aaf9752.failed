net/mlx5e: Check netdev pointer before checking its net ns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-537.el8
commit-author Gavin Li <gavinl@nvidia.com>
commit 7aaf975238c47b710fcc4eca0da1e7902a53abe2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-537.el8/7aaf9752.failed

Previously, when comparing the net namespaces, the case where the netdev
doesn't exist wasn't taken into account, and therefore can cause a crash.
In such a case, the comparing function should return false, as there is no
netdev->net to compare the devlink->net to.

Furthermore, this will result in an attempt to enter switchdev mode
without a netdev to fail, and which is the desired result as there is no
meaning in switchdev mode without a net device.

Fixes: 662404b24a4c ("net/mlx5e: Block entering switchdev mode with ns inconsistency")
	Signed-off-by: Gavin Li <gavinl@nvidia.com>
	Reviewed-by: Gavi Teitz <gavi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 7aaf975238c47b710fcc4eca0da1e7902a53abe2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index bc606ca02a74,bb8bcb448ae9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -3310,14 -3653,48 +3310,26 @@@ static int esw_inline_mode_to_devlink(u
  
  static bool esw_offloads_devlink_ns_eq_netdev_ns(struct devlink *devlink)
  {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
  	struct net *devl_net, *netdev_net;
- 	struct mlx5_eswitch *esw;
+ 	bool ret = false;
  
++<<<<<<< HEAD
 +	esw = mlx5_devlink_eswitch_get(devlink);
 +	netdev_net = dev_net(esw->dev->mlx5e_res.uplink_netdev);
 +	devl_net = devlink_net(devlink);
 +
 +	return net_eq(devl_net, netdev_net);
++=======
+ 	mutex_lock(&dev->mlx5e_res.uplink_netdev_lock);
+ 	if (dev->mlx5e_res.uplink_netdev) {
+ 		netdev_net = dev_net(dev->mlx5e_res.uplink_netdev);
+ 		devl_net = devlink_net(devlink);
+ 		ret = net_eq(devl_net, netdev_net);
+ 	}
+ 	mutex_unlock(&dev->mlx5e_res.uplink_netdev_lock);
+ 	return ret;
 -}
 -
 -int mlx5_eswitch_block_mode(struct mlx5_core_dev *dev)
 -{
 -	struct mlx5_eswitch *esw = dev->priv.eswitch;
 -	int err;
 -
 -	if (!mlx5_esw_allowed(esw))
 -		return 0;
 -
 -	/* Take TC into account */
 -	err = mlx5_esw_try_lock(esw);
 -	if (err < 0)
 -		return err;
 -
 -	esw->offloads.num_block_mode++;
 -	mlx5_esw_unlock(esw);
 -	return 0;
 -}
 -
 -void mlx5_eswitch_unblock_mode(struct mlx5_core_dev *dev)
 -{
 -	struct mlx5_eswitch *esw = dev->priv.eswitch;
 -
 -	if (!mlx5_esw_allowed(esw))
 -		return;
 -
 -	down_write(&esw->mode_lock);
 -	esw->offloads.num_block_mode--;
 -	up_write(&esw->mode_lock);
++>>>>>>> 7aaf975238c4 (net/mlx5e: Check netdev pointer before checking its net ns)
  }
  
  int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
