s390/vfio-ap: reset queues associated with adapter for queue unbound from driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-537.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit f009cfa466558b7dfe97f167ba1875d6f9ea4c07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-537.el8/f009cfa4.failed

When a queue is unbound from the vfio_ap device driver, if that queue is
assigned to a guest's AP configuration, its associated adapter is removed
because queues are defined to a guest via a matrix of adapters and
domains; so, it is not possible to remove a single queue.

If an adapter is removed from the guest's AP configuration, all associated
queues must be reset to prevent leaking crypto data should any of them be
assigned to a different guest or device driver. The one caveat is that if
the queue is being removed because the adapter or domain has been removed
from the host's AP configuration, then an attempt to reset the queue will
fail with response code 01, AP-queue number not valid; so resetting these
queues should be skipped.

	Acked-by: Halil Pasic <pasic@linux.ibm.com>
	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
Fixes: 09d31ff78793 ("s390/vfio-ap: hot plug/unplug of AP devices when probed/removed")
	Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20240115185441.31526-6-akrowiak@linux.ibm.com
	Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
(cherry picked from commit f009cfa466558b7dfe97f167ba1875d6f9ea4c07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index cc0a2dfafc79,550c936c413d..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -894,6 -939,47 +894,50 @@@ static void vfio_ap_mdev_link_adapter(s
  				       AP_MKQID(apid, apqi));
  }
  
++<<<<<<< HEAD
++=======
+ static void collect_queues_to_reset(struct ap_matrix_mdev *matrix_mdev,
+ 				    unsigned long apid,
+ 				    struct list_head *qlist)
+ {
+ 	struct vfio_ap_queue *q;
+ 	unsigned long  apqi;
+ 
+ 	for_each_set_bit_inv(apqi, matrix_mdev->shadow_apcb.aqm, AP_DOMAINS) {
+ 		q = vfio_ap_mdev_get_queue(matrix_mdev, AP_MKQID(apid, apqi));
+ 		if (q)
+ 			list_add_tail(&q->reset_qnode, qlist);
+ 	}
+ }
+ 
+ static void reset_queues_for_apid(struct ap_matrix_mdev *matrix_mdev,
+ 				  unsigned long apid)
+ {
+ 	struct list_head qlist;
+ 
+ 	INIT_LIST_HEAD(&qlist);
+ 	collect_queues_to_reset(matrix_mdev, apid, &qlist);
+ 	vfio_ap_mdev_reset_qlist(&qlist);
+ }
+ 
+ static int reset_queues_for_apids(struct ap_matrix_mdev *matrix_mdev,
+ 				  unsigned long *apm_reset)
+ {
+ 	struct list_head qlist;
+ 	unsigned long apid;
+ 
+ 	if (bitmap_empty(apm_reset, AP_DEVICES))
+ 		return 0;
+ 
+ 	INIT_LIST_HEAD(&qlist);
+ 
+ 	for_each_set_bit_inv(apid, apm_reset, AP_DEVICES)
+ 		collect_queues_to_reset(matrix_mdev, apid, &qlist);
+ 
+ 	return vfio_ap_mdev_reset_qlist(&qlist);
+ }
+ 
++>>>>>>> f009cfa46655 (s390/vfio-ap: reset queues associated with adapter for queue unbound from driver)
  /**
   * assign_adapter_store - parses the APID from @buf and sets the
   * corresponding bit in the mediated matrix device's APM
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
