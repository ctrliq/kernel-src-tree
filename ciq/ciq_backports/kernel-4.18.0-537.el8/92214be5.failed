net/mlx5e: Update doorbell for port timestamping CQ before the software counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-537.el8
commit-author Rahul Rameshbabu <rrameshbabu@nvidia.com>
commit 92214be5979c0961a471b7eaaaeacab41bdf456c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-537.el8/92214be5.failed

Previously, mlx5e_ptp_poll_ts_cq would update the device doorbell with the
incremented consumer index after the relevant software counters in the
kernel were updated. In the mlx5e_sq_xmit_wqe context, this would lead to
either overrunning the device CQ or exceeding the expected software buffer
size in the device CQ if the device CQ size was greater than the software
buffer size. Update the relevant software counter only after updating the
device CQ consumer index in the port timestamping napi_poll context.

Log:
    mlx5_core 0000:08:00.0: cq_err_event_notifier:517:(pid 0): CQ error on CQN 0x487, syndrome 0x1
    mlx5_core 0000:08:00.0 eth2: mlx5e_cq_error_event: cqn=0x000487 event=0x04

Fixes: 1880bc4e4a96 ("net/mlx5e: Add TX port timestamp support")
	Signed-off-by: Rahul Rameshbabu <rrameshbabu@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Link: https://lore.kernel.org/r/20231114215846.5902-12-saeed@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 92214be5979c0961a471b7eaaaeacab41bdf456c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
index b0b429a0321e,af3928eddafd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
@@@ -79,48 -124,66 +79,50 @@@ void mlx5e_skb_cb_hwtstamp_handler(stru
  	memset(skb->cb, 0, sizeof(struct mlx5e_skb_cb_hwtstamp));
  }
  
 -static struct sk_buff *
 -mlx5e_ptp_metadata_map_lookup(struct mlx5e_ptp_metadata_map *map, u16 metadata)
 +#define PTP_WQE_CTR2IDX(val) ((val) & ptpsq->ts_cqe_ctr_mask)
 +
 +static bool mlx5e_ptp_ts_cqe_drop(struct mlx5e_ptpsq *ptpsq, u16 skb_ci, u16 skb_id)
  {
 -	return map->data[metadata];
 +	return (ptpsq->ts_cqe_ctr_mask && (skb_ci != skb_id));
  }
  
 -static struct sk_buff *
 -mlx5e_ptp_metadata_map_remove(struct mlx5e_ptp_metadata_map *map, u16 metadata)
 +static bool mlx5e_ptp_ts_cqe_ooo(struct mlx5e_ptpsq *ptpsq, u16 skb_id)
  {
 -	struct sk_buff *skb;
 +	u16 skb_ci = PTP_WQE_CTR2IDX(ptpsq->skb_fifo_cc);
 +	u16 skb_pi = PTP_WQE_CTR2IDX(ptpsq->skb_fifo_pc);
  
 -	skb = map->data[metadata];
 -	map->data[metadata] = NULL;
 +	if (PTP_WQE_CTR2IDX(skb_id - skb_ci) >= PTP_WQE_CTR2IDX(skb_pi - skb_ci))
 +		return true;
  
 -	return skb;
 +	return false;
  }
  
 -static bool mlx5e_ptp_metadata_map_unhealthy(struct mlx5e_ptp_metadata_map *map)
 +static void mlx5e_ptp_skb_fifo_ts_cqe_resync(struct mlx5e_ptpsq *ptpsq, u16 skb_ci,
 +					     u16 skb_id, int budget)
  {
 -	/* Considered beginning unhealthy state if size * 15 / 2^4 cannot be reclaimed. */
 -	return map->undelivered_counter > (map->capacity >> 4) * 15;
 -}
 +	struct skb_shared_hwtstamps hwts = {};
 +	struct sk_buff *skb;
  
 -static void mlx5e_ptpsq_mark_ts_cqes_undelivered(struct mlx5e_ptpsq *ptpsq,
 -						 ktime_t port_tstamp)
 -{
 -	struct mlx5e_ptp_port_ts_cqe_list *cqe_list = ptpsq->ts_cqe_pending_list;
 -	ktime_t timeout = ns_to_ktime(MLX5E_PTP_TS_CQE_UNDELIVERED_TIMEOUT);
 -	struct mlx5e_ptp_metadata_map *metadata_map = &ptpsq->metadata_map;
 -	struct mlx5e_ptp_port_ts_cqe_tracker *pos, *n;
 -
 -	spin_lock(&cqe_list->tracker_list_lock);
 -	list_for_each_entry_safe(pos, n, &cqe_list->tracker_list_head, entry) {
 -		struct sk_buff *skb =
 -			mlx5e_ptp_metadata_map_lookup(metadata_map, pos->metadata_id);
 -		ktime_t dma_tstamp = mlx5e_skb_cb_get_hwts(skb)->cqe_hwtstamp;
 -
 -		if (!dma_tstamp ||
 -		    ktime_after(ktime_add(dma_tstamp, timeout), port_tstamp))
 -			break;
 -
 -		metadata_map->undelivered_counter++;
 -		WARN_ON_ONCE(!pos->inuse);
 -		pos->inuse = false;
 -		list_del(&pos->entry);
 +	ptpsq->cq_stats->resync_event++;
 +
 +	while (skb_ci != skb_id) {
 +		skb = mlx5e_skb_fifo_pop(&ptpsq->skb_fifo);
 +		hwts.hwtstamp = mlx5e_skb_cb_get_hwts(skb)->cqe_hwtstamp;
 +		skb_tstamp_tx(skb, &hwts);
 +		ptpsq->cq_stats->resync_cqe++;
 +		napi_consume_skb(skb, budget);
 +		skb_ci = PTP_WQE_CTR2IDX(ptpsq->skb_fifo_cc);
  	}
 -	spin_unlock(&cqe_list->tracker_list_lock);
  }
  
 -#define PTP_WQE_CTR2IDX(val) ((val) & ptpsq->ts_cqe_ctr_mask)
 -
  static void mlx5e_ptp_handle_ts_cqe(struct mlx5e_ptpsq *ptpsq,
  				    struct mlx5_cqe64 *cqe,
+ 				    u8 *md_buff,
+ 				    u8 *md_buff_sz,
  				    int budget)
  {
 -	struct mlx5e_ptp_port_ts_cqe_list *pending_cqe_list = ptpsq->ts_cqe_pending_list;
 -	u8 metadata_id = PTP_WQE_CTR2IDX(be16_to_cpu(cqe->wqe_counter));
 -	bool is_err_cqe = !!MLX5E_RX_ERR_CQE(cqe);
 +	u16 skb_id = PTP_WQE_CTR2IDX(be16_to_cpu(cqe->wqe_counter));
 +	u16 skb_ci = PTP_WQE_CTR2IDX(ptpsq->skb_fifo_cc);
  	struct mlx5e_txqsq *sq = &ptpsq->txqsq;
  	struct sk_buff *skb;
  	ktime_t hwtstamp;
@@@ -146,14 -210,22 +148,24 @@@
  				      hwtstamp, ptpsq->cq_stats);
  	ptpsq->cq_stats->cqe++;
  
 -	mlx5e_ptpsq_mark_ts_cqes_undelivered(ptpsq, hwtstamp);
  out:
  	napi_consume_skb(skb, budget);
++<<<<<<< HEAD
++=======
+ 	md_buff[*md_buff_sz++] = metadata_id;
+ 	if (unlikely(mlx5e_ptp_metadata_map_unhealthy(&ptpsq->metadata_map)) &&
+ 	    !test_and_set_bit(MLX5E_SQ_STATE_RECOVERING, &sq->state))
+ 		queue_work(ptpsq->txqsq.priv->wq, &ptpsq->report_unhealthy_work);
++>>>>>>> 92214be5979c (net/mlx5e: Update doorbell for port timestamping CQ before the software counter)
  }
  
- static bool mlx5e_ptp_poll_ts_cq(struct mlx5e_cq *cq, int budget)
+ static bool mlx5e_ptp_poll_ts_cq(struct mlx5e_cq *cq, int napi_budget)
  {
  	struct mlx5e_ptpsq *ptpsq = container_of(cq, struct mlx5e_ptpsq, ts_cq);
- 	struct mlx5_cqwq *cqwq = &cq->wq;
+ 	int budget = min(napi_budget, MLX5E_TX_CQ_POLL_BUDGET);
+ 	u8 metadata_buff[MLX5E_TX_CQ_POLL_BUDGET];
+ 	u8 metadata_buff_sz = 0;
+ 	struct mlx5_cqwq *cqwq;
  	struct mlx5_cqe64 *cqe;
  	int work_done = 0;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/ptp.c
