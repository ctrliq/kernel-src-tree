s390/cmma: fix detection of DAT pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-537.el8
commit-author Heiko Carstens <hca@linux.ibm.com>
commit 44d93045247661acbd50b1629e62f415f2747577
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-537.el8/44d93045.failed

If the cmma no-dat feature is available the kernel page tables are walked
to identify and mark all pages which are used for address translation (all
region, segment, and page tables). In a subsequent loop all other pages are
marked as "no-dat" pages with the ESSA instruction.

This information is visible to the hypervisor, so that the hypervisor can
optimize purging of guest TLB entries. The initial loop however is
incorrect: only the first three of the four pages which belong to segment
and region tables will be marked as being used for DAT. The last page is
incorrectly marked as no-dat.

This can result in incorrect guest TLB flushes.

Fix this by simply marking all four pages.

	Cc: <stable@vger.kernel.org>
	Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 44d93045247661acbd50b1629e62f415f2747577)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/mm/page-states.c
diff --cc arch/s390/mm/page-states.c
index 82c5500dffd7,20c0b160efee..000000000000
--- a/arch/s390/mm/page-states.c
+++ b/arch/s390/mm/page-states.c
@@@ -136,8 -120,8 +136,13 @@@ static void mark_kernel_pud(p4d_t *p4d
  		if (pud_none(*pud) || pud_large(*pud))
  			continue;
  		if (!pud_folded(*pud)) {
++<<<<<<< HEAD
 +			page = virt_to_page(pud_val(*pud));
 +			for (i = 0; i < 3; i++)
++=======
+ 			page = phys_to_page(pud_val(*pud));
+ 			for (i = 0; i < 4; i++)
++>>>>>>> 44d930452476 (s390/cmma: fix detection of DAT pages)
  				set_bit(PG_arch_1, &page[i].flags);
  		}
  		mark_kernel_pmd(pud, addr, next);
@@@ -157,8 -141,8 +162,13 @@@ static void mark_kernel_p4d(pgd_t *pgd
  		if (p4d_none(*p4d))
  			continue;
  		if (!p4d_folded(*p4d)) {
++<<<<<<< HEAD
 +			page = virt_to_page(p4d_val(*p4d));
 +			for (i = 0; i < 3; i++)
++=======
+ 			page = phys_to_page(p4d_val(*p4d));
+ 			for (i = 0; i < 4; i++)
++>>>>>>> 44d930452476 (s390/cmma: fix detection of DAT pages)
  				set_bit(PG_arch_1, &page[i].flags);
  		}
  		mark_kernel_pud(p4d, addr, next);
@@@ -186,8 -170,8 +196,13 @@@ static void mark_kernel_pgd(void
  		if (pgd_none(*pgd))
  			continue;
  		if (!pgd_folded(*pgd)) {
++<<<<<<< HEAD
 +			page = virt_to_page(pgd_val(*pgd));
 +			for (i = 0; i < 3; i++)
++=======
+ 			page = phys_to_page(pgd_val(*pgd));
+ 			for (i = 0; i < 4; i++)
++>>>>>>> 44d930452476 (s390/cmma: fix detection of DAT pages)
  				set_bit(PG_arch_1, &page[i].flags);
  		}
  		mark_kernel_p4d(pgd, addr, next);
* Unmerged path arch/s390/mm/page-states.c
