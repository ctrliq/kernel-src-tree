ipv4: use RCU protection in __ip_rt_update_pmtu()

jira KERNEL-609
cve CVE-2025-21766
Rebuild_History Non-Buildable kernel-4.18.0-553.104.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 139512191bd06f1b496117c76372b2ce372c9a41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.104.1.el8_10/13951219.failed

__ip_rt_update_pmtu() must use RCU protection to make
sure the net structure it reads does not disappear.

Fixes: 2fbc6e89b2f1 ("ipv4: Update exception handling for multipath routes via same device")
Fixes: 1de6b15a434c ("Namespaceify min_pmtu sysctl")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
Link: https://patch.msgid.link/20250205155120.1676781-8-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 139512191bd06f1b496117c76372b2ce372c9a41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/route.c
diff --cc net/ipv4/route.c
index 60932d85f568,753704f75b2c..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1035,10 -1008,10 +1035,17 @@@ out:	kfree_skb_reason(skb, reason)
  static void __ip_rt_update_pmtu(struct rtable *rt, struct flowi4 *fl4, u32 mtu)
  {
  	struct dst_entry *dst = &rt->dst;
++<<<<<<< HEAD
 +	struct net *net = dev_net(dst->dev);
 +	u32 old_mtu = ipv4_mtu(dst);
 +	struct fib_result res;
 +	bool lock = false;
++=======
+ 	struct fib_result res;
+ 	bool lock = false;
+ 	struct net *net;
+ 	u32 old_mtu;
++>>>>>>> 139512191bd0 (ipv4: use RCU protection in __ip_rt_update_pmtu())
  
  	if (ip_mtu_locked(dst))
  		return;
@@@ -1046,24 -1019,39 +1053,53 @@@
  	if (old_mtu < mtu)
  		return;
  
++<<<<<<< HEAD
 +	if (mtu < ip_rt_min_pmtu) {
++=======
+ 	rcu_read_lock();
+ 	net = dev_net_rcu(dst->dev);
+ 	if (mtu < net->ipv4.ip_rt_min_pmtu) {
++>>>>>>> 139512191bd0 (ipv4: use RCU protection in __ip_rt_update_pmtu())
  		lock = true;
 -		mtu = min(old_mtu, net->ipv4.ip_rt_min_pmtu);
 +		mtu = min(old_mtu, ip_rt_min_pmtu);
  	}
  
  	if (rt->rt_pmtu == mtu && !lock &&
++<<<<<<< HEAD
 +	    time_before(jiffies, dst->expires - ip_rt_mtu_expires / 2))
 +		return;
++=======
+ 	    time_before(jiffies, dst->expires - net->ipv4.ip_rt_mtu_expires / 2))
+ 		goto out;
++>>>>>>> 139512191bd0 (ipv4: use RCU protection in __ip_rt_update_pmtu())
  
- 	rcu_read_lock();
  	if (fib_lookup(net, fl4, &res, 0) == 0) {
 -		struct fib_nh_common *nhc;
 +		struct fib_nh *nh;
  
  		fib_select_path(net, &res, fl4, NULL);
++<<<<<<< HEAD
 +		nh = &FIB_RES_NH(res);
 +		update_or_create_fnhe(nh, fl4->daddr, 0, mtu, lock,
 +				      jiffies + ip_rt_mtu_expires);
++=======
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
+ 		if (fib_info_num_path(res.fi) > 1) {
+ 			int nhsel;
+ 
+ 			for (nhsel = 0; nhsel < fib_info_num_path(res.fi); nhsel++) {
+ 				nhc = fib_info_nhc(res.fi, nhsel);
+ 				update_or_create_fnhe(nhc, fl4->daddr, 0, mtu, lock,
+ 						      jiffies + net->ipv4.ip_rt_mtu_expires);
+ 			}
+ 			goto out;
+ 		}
+ #endif /* CONFIG_IP_ROUTE_MULTIPATH */
+ 		nhc = FIB_RES_NHC(res);
+ 		update_or_create_fnhe(nhc, fl4->daddr, 0, mtu, lock,
+ 				      jiffies + net->ipv4.ip_rt_mtu_expires);
++>>>>>>> 139512191bd0 (ipv4: use RCU protection in __ip_rt_update_pmtu())
  	}
+ out:
  	rcu_read_unlock();
  }
  
* Unmerged path net/ipv4/route.c
