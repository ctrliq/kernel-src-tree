net: use dst_dev_rcu() in sk_setup_caps()

jira KERNEL-609
cve CVE-2025-40170
Rebuild_History Non-Buildable kernel-4.18.0-553.104.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 99a2ace61b211b0be861b07fbaa062fca4b58879
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.104.1.el8_10/99a2ace6.failed

Use RCU to protect accesses to dst->dev from sk_setup_caps()
and sk_dst_gso_max_size().

Also use dst_dev_rcu() in ip6_dst_mtu_maybe_forward(),
and ip_dst_mtu_maybe_forward().

ip4_dst_hoplimit() can use dst_dev_net_rcu().

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://patch.msgid.link/20250828195823.3958522-6-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 99a2ace61b211b0be861b07fbaa062fca4b58879)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
#	include/net/ip6_route.h
#	include/net/route.h
#	net/core/sock.c
diff --cc include/net/ip.h
index 7b302d367b31,6dbd2bf8fa9c..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -394,14 -466,43 +394,50 @@@ static inline bool ip_sk_ignore_df(cons
  static inline unsigned int ip_dst_mtu_maybe_forward(const struct dst_entry *dst,
  						    bool forwarding)
  {
++<<<<<<< HEAD
 +	struct net *net = dev_net(dst->dev);
 +
 +	if (net->ipv4.sysctl_ip_fwd_use_pmtu ||
++=======
+ 	const struct rtable *rt = dst_rtable(dst);
+ 	const struct net_device *dev;
+ 	unsigned int mtu, res;
+ 	struct net *net;
+ 
+ 	rcu_read_lock();
+ 
+ 	dev = dst_dev_rcu(dst);
+ 	net = dev_net_rcu(dev);
+ 	if (READ_ONCE(net->ipv4.sysctl_ip_fwd_use_pmtu) ||
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	    ip_mtu_locked(dst) ||
 -	    !forwarding) {
 -		mtu = rt->rt_pmtu;
 -		if (mtu && time_before(jiffies, READ_ONCE(rt->dst.expires)))
 -			goto out;
 -	}
 +	    !forwarding)
 +		return dst_mtu(dst);
  
++<<<<<<< HEAD
 +	return min(READ_ONCE(dst->dev->mtu), IP_MAX_MTU);
++=======
+ 	/* 'forwarding = true' case should always honour route mtu */
+ 	mtu = dst_metric_raw(dst, RTAX_MTU);
+ 	if (mtu)
+ 		goto out;
+ 
+ 	mtu = READ_ONCE(dev->mtu);
+ 
+ 	if (unlikely(ip_mtu_locked(dst))) {
+ 		if (rt->rt_uses_gateway && mtu > 576)
+ 			mtu = 576;
+ 	}
+ 
+ out:
+ 	mtu = min_t(unsigned int, mtu, IP_MAX_MTU);
+ 
+ 	res = mtu - lwtunnel_headroom(dst->lwtstate, mtu);
+ 
+ 	rcu_read_unlock();
+ 
+ 	return res;
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  }
  
  static inline unsigned int ip_skb_dst_mtu(struct sock *sk,
diff --cc include/net/ip6_route.h
index 655199bba065,59f48ca3abdf..000000000000
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@@ -294,16 -337,18 +294,20 @@@ static inline unsigned int ip6_dst_mtu_
  
  	mtu = IPV6_MIN_MTU;
  	rcu_read_lock();
++<<<<<<< HEAD
 +	idev = __in6_dev_get(dst->dev);
++=======
+ 	idev = __in6_dev_get(dst_dev_rcu(dst));
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	if (idev)
 -		mtu = READ_ONCE(idev->cnf.mtu6);
 +		mtu = idev->cnf.mtu6;
  	rcu_read_unlock();
  
 -out:
 -	return mtu - lwtunnel_headroom(dst->lwtstate, mtu);
 +	return mtu;
  }
  
 -u32 ip6_mtu_from_fib6(const struct fib6_result *res,
 -		      const struct in6_addr *daddr,
 -		      const struct in6_addr *saddr);
 +u32 ip6_mtu_from_fib6(struct fib6_info *f6i, struct in6_addr *daddr,
 +		      struct in6_addr *saddr);
  
  struct neighbour *ip6_neigh_lookup(const struct in6_addr *gw,
  				   struct net_device *dev, struct sk_buff *skb,
diff --cc include/net/route.h
index c1eb8e8e4b16,f90106f383c5..000000000000
--- a/include/net/route.h
+++ b/include/net/route.h
@@@ -353,10 -385,15 +353,21 @@@ static inline int inet_iif(const struc
  static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
  {
  	int hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);
 +	struct net *net = dev_net(dst->dev);
  
++<<<<<<< HEAD
 +	if (hoplimit == 0)
 +		hoplimit = net->ipv4.sysctl_ip_default_ttl;
++=======
+ 	if (hoplimit == 0) {
+ 		const struct net *net;
+ 
+ 		rcu_read_lock();
+ 		net = dst_dev_net_rcu(dst);
+ 		hoplimit = READ_ONCE(net->ipv4.sysctl_ip_default_ttl);
+ 		rcu_read_unlock();
+ 	}
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	return hoplimit;
  }
  
diff --cc net/core/sock.c
index 035494526dd7,9a8290fcc35d..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -2021,33 -2578,59 +2021,71 @@@ out
  }
  EXPORT_SYMBOL_GPL(sk_clone_lock);
  
++<<<<<<< HEAD
 +void sk_free_unlock_clone(struct sock *sk)
 +{
 +	/* It is still raw copy of parent, so invalidate
 +	 * destructor and make plain sk_free() */
 +	sk->sk_destruct = NULL;
 +	bh_unlock_sock(sk);
 +	sk_free(sk);
++=======
+ static u32 sk_dst_gso_max_size(struct sock *sk, const struct net_device *dev)
+ {
+ 	bool is_ipv6 = false;
+ 	u32 max_size;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	is_ipv6 = (sk->sk_family == AF_INET6 &&
+ 		   !ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr));
+ #endif
+ 	/* pairs with the WRITE_ONCE() in netif_set_gso(_ipv4)_max_size() */
+ 	max_size = is_ipv6 ? READ_ONCE(dev->gso_max_size) :
+ 			READ_ONCE(dev->gso_ipv4_max_size);
+ 	if (max_size > GSO_LEGACY_MAX_SIZE && !sk_is_tcp(sk))
+ 		max_size = GSO_LEGACY_MAX_SIZE;
+ 
+ 	return max_size - (MAX_TCP_HEADER + 1);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  }
 +EXPORT_SYMBOL_GPL(sk_free_unlock_clone);
  
  void sk_setup_caps(struct sock *sk, struct dst_entry *dst)
  {
+ 	const struct net_device *dev;
  	u32 max_segs = 1;
  
++<<<<<<< HEAD
 +	sk->sk_route_caps = dst->dev->features | sk->sk_route_forced_caps;
++=======
+ 	rcu_read_lock();
+ 	dev = dst_dev_rcu(dst);
+ 	sk->sk_route_caps = dev->features;
+ 	if (sk_is_tcp(sk)) {
+ 		struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 		sk->sk_route_caps |= NETIF_F_GSO;
+ 		icsk->icsk_ack.dst_quick_ack = dst_metric(dst, RTAX_QUICKACK);
+ 	}
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  	if (sk->sk_route_caps & NETIF_F_GSO)
  		sk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;
 -	if (unlikely(sk->sk_gso_disabled))
 -		sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
 +	sk->sk_route_caps &= ~sk->sk_route_nocaps;
  	if (sk_can_gso(sk)) {
  		if (dst->header_len && !xfrm_dst_offload_ok(dst)) {
  			sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
  		} else {
  			sk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;
++<<<<<<< HEAD
 +			/* pairs with the WRITE_ONCE() in netif_set_gso_max_size() */
 +			sk->sk_gso_max_size = READ_ONCE(dst->dev->gso_max_size);
 +			/* pairs with the WRITE_ONCE() in netif_set_gso_max_segs() */
 +			max_segs = max_t(u32, READ_ONCE(dst->dev->gso_max_segs), 1);
++=======
+ 			sk->sk_gso_max_size = sk_dst_gso_max_size(sk, dev);
+ 			/* pairs with the WRITE_ONCE() in netif_set_gso_max_segs() */
+ 			max_segs = max_t(u32, READ_ONCE(dev->gso_max_segs), 1);
++>>>>>>> 99a2ace61b21 (net: use dst_dev_rcu() in sk_setup_caps())
  		}
  	}
  	sk->sk_gso_max_segs = max_segs;
* Unmerged path include/net/ip.h
* Unmerged path include/net/ip6_route.h
* Unmerged path include/net/route.h
* Unmerged path net/core/sock.c
