ipv4: use RCU protection in ip_dst_mtu_maybe_forward()

jira KERNEL-609
Rebuild_History Non-Buildable kernel-4.18.0-553.104.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 071d8012869b6af352acca346ade13e7be90a49f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.104.1.el8_10/071d8012.failed

ip_dst_mtu_maybe_forward() must use RCU protection to make
sure the net structure it reads does not disappear.

Fixes: f87c10a8aa1e8 ("ipv4: introduce ip_dst_mtu_maybe_forward and protect forwarding path against pmtu spoofing")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Link: https://patch.msgid.link/20250205155120.1676781-4-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 071d8012869b6af352acca346ade13e7be90a49f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
diff --cc include/net/ip.h
index 7b302d367b31,ba7b43447775..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -394,14 -470,41 +394,48 @@@ static inline bool ip_sk_ignore_df(cons
  static inline unsigned int ip_dst_mtu_maybe_forward(const struct dst_entry *dst,
  						    bool forwarding)
  {
++<<<<<<< HEAD
 +	struct net *net = dev_net(dst->dev);
 +
 +	if (net->ipv4.sysctl_ip_fwd_use_pmtu ||
++=======
+ 	const struct rtable *rt = dst_rtable(dst);
+ 	unsigned int mtu, res;
+ 	struct net *net;
+ 
+ 	rcu_read_lock();
+ 
+ 	net = dev_net_rcu(dst->dev);
+ 	if (READ_ONCE(net->ipv4.sysctl_ip_fwd_use_pmtu) ||
++>>>>>>> 071d8012869b (ipv4: use RCU protection in ip_dst_mtu_maybe_forward())
  	    ip_mtu_locked(dst) ||
 -	    !forwarding) {
 -		mtu = rt->rt_pmtu;
 -		if (mtu && time_before(jiffies, rt->dst.expires))
 -			goto out;
 -	}
 +	    !forwarding)
 +		return dst_mtu(dst);
  
++<<<<<<< HEAD
 +	return min(READ_ONCE(dst->dev->mtu), IP_MAX_MTU);
++=======
+ 	/* 'forwarding = true' case should always honour route mtu */
+ 	mtu = dst_metric_raw(dst, RTAX_MTU);
+ 	if (mtu)
+ 		goto out;
+ 
+ 	mtu = READ_ONCE(dst->dev->mtu);
+ 
+ 	if (unlikely(ip_mtu_locked(dst))) {
+ 		if (rt->rt_uses_gateway && mtu > 576)
+ 			mtu = 576;
+ 	}
+ 
+ out:
+ 	mtu = min_t(unsigned int, mtu, IP_MAX_MTU);
+ 
+ 	res = mtu - lwtunnel_headroom(dst->lwtstate, mtu);
+ 
+ 	rcu_read_unlock();
+ 
+ 	return res;
++>>>>>>> 071d8012869b (ipv4: use RCU protection in ip_dst_mtu_maybe_forward())
  }
  
  static inline unsigned int ip_skb_dst_mtu(struct sock *sk,
* Unmerged path include/net/ip.h
