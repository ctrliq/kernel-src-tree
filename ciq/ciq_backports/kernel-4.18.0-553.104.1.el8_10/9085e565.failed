ipv6: use RCU in ip6_xmit()

jira KERNEL-609
cve CVE-2025-40135
Rebuild_History Non-Buildable kernel-4.18.0-553.104.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 9085e56501d93af9f2d7bd16f7fcfacdde47b99c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.104.1.el8_10/9085e565.failed

Use RCU in ip6_xmit() in order to use dst_dev_rcu() to prevent
possible UAF.

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://patch.msgid.link/20250828195823.3958522-4-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9085e56501d93af9f2d7bd16f7fcfacdde47b99c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index f4f534042ec2,e234640433d6..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -243,35 -266,38 +243,60 @@@ bool ip6_autoflowlabel(struct net *net
   * which are using proper atomic operations or spinlocks.
   */
  int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 -	     __u32 mark, struct ipv6_txoptions *opt, int tclass, u32 priority)
 +	     __u32 mark, struct ipv6_txoptions *opt, int tclass)
  {
- 	struct net *net = sock_net(sk);
  	const struct ipv6_pinfo *np = inet6_sk(sk);
  	struct in6_addr *first_hop = &fl6->daddr;
  	struct dst_entry *dst = skb_dst(skb);
++<<<<<<< HEAD
++=======
+ 	struct inet6_dev *idev = ip6_dst_idev(dst);
+ 	struct hop_jumbo_hdr *hop_jumbo;
+ 	int hoplen = sizeof(*hop_jumbo);
+ 	struct net *net = sock_net(sk);
++>>>>>>> 9085e56501d9 (ipv6: use RCU in ip6_xmit())
  	unsigned int head_room;
+ 	struct net_device *dev;
  	struct ipv6hdr *hdr;
  	u8  proto = fl6->flowi6_proto;
  	int seg_len = skb->len;
- 	int hlimit = -1;
+ 	int ret, hlimit = -1;
  	u32 mtu;
  
++<<<<<<< HEAD
 +	head_room = sizeof(struct ipv6hdr) + LL_RESERVED_SPACE(dst->dev);
 +	if (opt)
 +		head_room += opt->opt_nflen + opt->opt_flen;
 +
 +	if (unlikely(skb_headroom(skb) < head_room)) {
 +		struct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);
 +		if (!skb2) {
 +			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
 +				      IPSTATS_MIB_OUTDISCARDS);
 +			kfree_skb(skb);
 +			return -ENOBUFS;
 +		}
 +		if (skb->sk)
 +			skb_set_owner_w(skb2, skb->sk);
 +		consume_skb(skb);
 +		skb = skb2;
++=======
+ 	rcu_read_lock();
+ 
+ 	dev = dst_dev_rcu(dst);
+ 	head_room = sizeof(struct ipv6hdr) + hoplen + LL_RESERVED_SPACE(dev);
+ 	if (opt)
+ 		head_room += opt->opt_nflen + opt->opt_flen;
+ 
+ 	if (unlikely(head_room > skb_headroom(skb))) {
+ 		/* idev stays alive while we hold rcu_read_lock(). */
+ 		skb = skb_expand_head(skb, head_room);
+ 		if (!skb) {
+ 			IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
+ 			ret = -ENOBUFS;
+ 			goto unlock;
+ 		}
++>>>>>>> 9085e56501d9 (ipv6: use RCU in ip6_xmit())
  	}
  
  	if (opt) {
@@@ -326,20 -367,24 +353,33 @@@
  		/* hooks should never assume socket lock is held.
  		 * we promote our socket to non const
  		 */
++<<<<<<< HEAD
 +		return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
 +			       net, (struct sock *)sk, skb, NULL, dst->dev,
 +			       dst_output);
 +	}
 +
 +	skb->dev = dst->dev;
++=======
+ 		ret = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
+ 			      net, (struct sock *)sk, skb, NULL, dev,
+ 			      dst_output);
+ 		goto unlock;
+ 	}
+ 
+ 	ret = -EMSGSIZE;
+ 	skb->dev = dev;
++>>>>>>> 9085e56501d9 (ipv6: use RCU in ip6_xmit())
  	/* ipv6_local_error() does not require socket lock,
  	 * we promote our socket to non const
  	 */
  	ipv6_local_error((struct sock *)sk, EMSGSIZE, fl6, mtu);
  
 -	IP6_INC_STATS(net, idev, IPSTATS_MIB_FRAGFAILS);
 +	IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_FRAGFAILS);
  	kfree_skb(skb);
- 	return -EMSGSIZE;
+ unlock:
+ 	rcu_read_unlock();
+ 	return ret;
  }
  EXPORT_SYMBOL(ip6_xmit);
  
* Unmerged path net/ipv6/ip6_output.c
