net: dst: introduce dst->dev_rcu

jira KERNEL-609
Rebuild_History Non-Buildable kernel-4.18.0-553.104.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit caedcc5b6df1b2e2b5f39079e3369c1d4d5c5f50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.104.1.el8_10/caedcc5b.failed

Followup of commit 88fe14253e18 ("net: dst: add four helpers
to annotate data-races around dst->dev").

We want to gradually add explicit RCU protection to dst->dev,
including lockdep support.

Add an union to alias dst->dev_rcu and dst->dev.

Add dst_dev_net_rcu() helper.

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://patch.msgid.link/20250828195823.3958522-2-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit caedcc5b6df1b2e2b5f39079e3369c1d4d5c5f50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/dst.h
#	net/core/dst.c
#	net/ipv4/route.c
diff --cc include/net/dst.h
index 2e3f79ea8bed,f8aa1239b4db..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -559,4 -566,50 +562,53 @@@ static inline void skb_dst_update_pmtu_
  		dst->ops->update_pmtu(dst, NULL, skb, mtu, false);
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct net_device *dst_dev(const struct dst_entry *dst)
+ {
+ 	return READ_ONCE(dst->dev);
+ }
+ 
+ static inline struct net_device *dst_dev_rcu(const struct dst_entry *dst)
+ {
+ 	return rcu_dereference(dst->dev_rcu);
+ }
+ 
+ static inline struct net *dst_dev_net_rcu(const struct dst_entry *dst)
+ {
+ 	return dev_net_rcu(dst_dev_rcu(dst));
+ }
+ 
+ static inline struct net_device *skb_dst_dev(const struct sk_buff *skb)
+ {
+ 	return dst_dev(skb_dst(skb));
+ }
+ 
+ static inline struct net_device *skb_dst_dev_rcu(const struct sk_buff *skb)
+ {
+ 	return dst_dev_rcu(skb_dst(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net(const struct sk_buff *skb)
+ {
+ 	return dev_net(skb_dst_dev(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net_rcu(const struct sk_buff *skb)
+ {
+ 	return dev_net_rcu(skb_dst_dev_rcu(skb));
+ }
+ 
+ struct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie);
+ void dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,
+ 			       struct sk_buff *skb, u32 mtu, bool confirm_neigh);
+ void dst_blackhole_redirect(struct dst_entry *dst, struct sock *sk,
+ 			    struct sk_buff *skb);
+ u32 *dst_blackhole_cow_metrics(struct dst_entry *dst, unsigned long old);
+ struct neighbour *dst_blackhole_neigh_lookup(const struct dst_entry *dst,
+ 					     struct sk_buff *skb,
+ 					     const void *daddr);
+ unsigned int dst_blackhole_mtu(const struct dst_entry *dst);
+ 
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  #endif /* _NET_DST_H */
diff --cc net/core/dst.c
index ff50f8aac797,e9d35f49c9e7..000000000000
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@@ -165,14 -145,14 +165,23 @@@ void dst_dev_put(struct dst_entry *dst
  {
  	struct net_device *dev = dst->dev;
  
 -	WRITE_ONCE(dst->obsolete, DST_OBSOLETE_DEAD);
 +	dst->obsolete = DST_OBSOLETE_DEAD;
  	if (dst->ops->ifdown)
++<<<<<<< HEAD
 +		dst->ops->ifdown(dst, dev, true);
 +	dst->input = dst_discard;
 +	dst->output = dst_discard_out;
 +	dst->dev = blackhole_netdev;
 +	dev_hold(dst->dev);
 +	dev_put(dev);
++=======
+ 		dst->ops->ifdown(dst, dev);
+ 	WRITE_ONCE(dst->input, dst_discard);
+ 	WRITE_ONCE(dst->output, dst_discard_out);
+ 	rcu_assign_pointer(dst->dev_rcu, blackhole_netdev);
+ 	netdev_ref_replace(dev, blackhole_netdev, &dst->dev_tracker,
+ 			   GFP_ATOMIC);
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  }
  EXPORT_SYMBOL(dst_dev_put);
  
diff --cc net/ipv4/route.c
index 60932d85f568,44382d175589..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1046,9 -1025,12 +1046,15 @@@ static void __ip_rt_update_pmtu(struct 
  	if (old_mtu < mtu)
  		return;
  
++<<<<<<< HEAD
 +	if (mtu < ip_rt_min_pmtu) {
++=======
+ 	rcu_read_lock();
+ 	net = dst_dev_net_rcu(dst);
+ 	if (mtu < net->ipv4.ip_rt_min_pmtu) {
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  		lock = true;
 -		mtu = min(old_mtu, net->ipv4.ip_rt_min_pmtu);
 +		mtu = min(old_mtu, ip_rt_min_pmtu);
  	}
  
  	if (rt->rt_pmtu == mtu && !lock &&
@@@ -1334,8 -1323,14 +1340,19 @@@ static void set_class_tag(struct rtabl
  static unsigned int ipv4_default_advmss(const struct dst_entry *dst)
  {
  	unsigned int header_size = sizeof(struct tcphdr) + sizeof(struct iphdr);
++<<<<<<< HEAD
 +	unsigned int advmss = max_t(unsigned int, ipv4_mtu(dst) - header_size,
 +				    ip_rt_min_advmss);
++=======
+ 	unsigned int advmss;
+ 	struct net *net;
+ 
+ 	rcu_read_lock();
+ 	net = dst_dev_net_rcu(dst);
+ 	advmss = max_t(unsigned int, ipv4_mtu(dst) - header_size,
+ 				   net->ipv4.ip_rt_min_advmss);
+ 	rcu_read_unlock();
++>>>>>>> caedcc5b6df1 (net: dst: introduce dst->dev_rcu)
  
  	return min(advmss, IPV4_MAX_PMTU - header_size);
  }
* Unmerged path include/net/dst.h
* Unmerged path net/core/dst.c
* Unmerged path net/ipv4/route.c
