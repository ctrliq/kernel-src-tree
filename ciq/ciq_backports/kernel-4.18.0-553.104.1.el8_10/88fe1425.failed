net: dst: add four helpers to annotate data-races around dst->dev

jira KERNEL-609
Rebuild_History Non-Buildable kernel-4.18.0-553.104.1.el8_10
commit-author Eric Dumazet <edumazet@google.com>
commit 88fe14253e181878c2ddb51a298ae8c468a63010
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.104.1.el8_10/88fe1425.failed

dst->dev is read locklessly in many contexts,
and written in dst_dev_put().

Fixing all the races is going to need many changes.

We probably will have to add full RCU protection.

Add three helpers to ease this painful process.

static inline struct net_device *dst_dev(const struct dst_entry *dst)
{
       return READ_ONCE(dst->dev);
}

static inline struct net_device *skb_dst_dev(const struct sk_buff *skb)
{
       return dst_dev(skb_dst(skb));
}

static inline struct net *skb_dst_dev_net(const struct sk_buff *skb)
{
       return dev_net(skb_dst_dev(skb));
}

static inline struct net *skb_dst_dev_net_rcu(const struct sk_buff *skb)
{
       return dev_net_rcu(skb_dst_dev(skb));
}

Fixes: 4a6ce2b6f2ec ("net: introduce a new function dst_dev_put()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: Kuniyuki Iwashima <kuniyu@google.com>
Link: https://patch.msgid.link/20250630121934.3399505-7-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 88fe14253e181878c2ddb51a298ae8c468a63010)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/dst.h
#	net/core/dst.c
#	net/core/sock.c
diff --cc include/net/dst.h
index 2e3f79ea8bed,00467c1b5093..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -559,4 -563,35 +559,38 @@@ static inline void skb_dst_update_pmtu_
  		dst->ops->update_pmtu(dst, NULL, skb, mtu, false);
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct net_device *dst_dev(const struct dst_entry *dst)
+ {
+ 	return READ_ONCE(dst->dev);
+ }
+ 
+ static inline struct net_device *skb_dst_dev(const struct sk_buff *skb)
+ {
+ 	return dst_dev(skb_dst(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net(const struct sk_buff *skb)
+ {
+ 	return dev_net(skb_dst_dev(skb));
+ }
+ 
+ static inline struct net *skb_dst_dev_net_rcu(const struct sk_buff *skb)
+ {
+ 	return dev_net_rcu(skb_dst_dev(skb));
+ }
+ 
+ struct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie);
+ void dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,
+ 			       struct sk_buff *skb, u32 mtu, bool confirm_neigh);
+ void dst_blackhole_redirect(struct dst_entry *dst, struct sock *sk,
+ 			    struct sk_buff *skb);
+ u32 *dst_blackhole_cow_metrics(struct dst_entry *dst, unsigned long old);
+ struct neighbour *dst_blackhole_neigh_lookup(const struct dst_entry *dst,
+ 					     struct sk_buff *skb,
+ 					     const void *daddr);
+ unsigned int dst_blackhole_mtu(const struct dst_entry *dst);
+ 
++>>>>>>> 88fe14253e18 (net: dst: add four helpers to annotate data-races around dst->dev)
  #endif /* _NET_DST_H */
diff --cc net/core/dst.c
index ff50f8aac797,e2de8b68c41d..000000000000
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@@ -165,14 -145,14 +165,23 @@@ void dst_dev_put(struct dst_entry *dst
  {
  	struct net_device *dev = dst->dev;
  
 -	WRITE_ONCE(dst->obsolete, DST_OBSOLETE_DEAD);
 +	dst->obsolete = DST_OBSOLETE_DEAD;
  	if (dst->ops->ifdown)
++<<<<<<< HEAD
 +		dst->ops->ifdown(dst, dev, true);
 +	dst->input = dst_discard;
 +	dst->output = dst_discard_out;
 +	dst->dev = blackhole_netdev;
 +	dev_hold(dst->dev);
 +	dev_put(dev);
++=======
+ 		dst->ops->ifdown(dst, dev);
+ 	WRITE_ONCE(dst->input, dst_discard);
+ 	WRITE_ONCE(dst->output, dst_discard_out);
+ 	WRITE_ONCE(dst->dev, blackhole_netdev);
+ 	netdev_ref_replace(dev, blackhole_netdev, &dst->dev_tracker,
+ 			   GFP_ATOMIC);
++>>>>>>> 88fe14253e18 (net: dst: add four helpers to annotate data-races around dst->dev)
  }
  EXPORT_SYMBOL(dst_dev_put);
  
@@@ -247,27 -229,56 +256,76 @@@ void __dst_destroy_metrics_generic(stru
  }
  EXPORT_SYMBOL(__dst_destroy_metrics_generic);
  
++<<<<<<< HEAD
 +static struct dst_ops md_dst_ops = {
 +	.family =		AF_UNSPEC,
++=======
+ struct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie)
+ {
+ 	return NULL;
+ }
+ 
+ u32 *dst_blackhole_cow_metrics(struct dst_entry *dst, unsigned long old)
+ {
+ 	return NULL;
+ }
+ 
+ struct neighbour *dst_blackhole_neigh_lookup(const struct dst_entry *dst,
+ 					     struct sk_buff *skb,
+ 					     const void *daddr)
+ {
+ 	return NULL;
+ }
+ 
+ void dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,
+ 			       struct sk_buff *skb, u32 mtu,
+ 			       bool confirm_neigh)
+ {
+ }
+ EXPORT_SYMBOL_GPL(dst_blackhole_update_pmtu);
+ 
+ void dst_blackhole_redirect(struct dst_entry *dst, struct sock *sk,
+ 			    struct sk_buff *skb)
+ {
+ }
+ EXPORT_SYMBOL_GPL(dst_blackhole_redirect);
+ 
+ unsigned int dst_blackhole_mtu(const struct dst_entry *dst)
+ {
+ 	unsigned int mtu = dst_metric_raw(dst, RTAX_MTU);
+ 
+ 	return mtu ? : dst_dev(dst)->mtu;
+ }
+ EXPORT_SYMBOL_GPL(dst_blackhole_mtu);
+ 
+ static struct dst_ops dst_blackhole_ops = {
+ 	.family		= AF_UNSPEC,
+ 	.neigh_lookup	= dst_blackhole_neigh_lookup,
+ 	.check		= dst_blackhole_check,
+ 	.cow_metrics	= dst_blackhole_cow_metrics,
+ 	.update_pmtu	= dst_blackhole_update_pmtu,
+ 	.redirect	= dst_blackhole_redirect,
+ 	.mtu		= dst_blackhole_mtu,
++>>>>>>> 88fe14253e18 (net: dst: add four helpers to annotate data-races around dst->dev)
  };
  
 +static int dst_md_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb)
 +{
 +	WARN_ONCE(1, "Attempting to call output on metadata dst\n");
 +	kfree_skb(skb);
 +	return 0;
 +}
 +
 +static int dst_md_discard(struct sk_buff *skb)
 +{
 +	WARN_ONCE(1, "Attempting to call input on metadata dst\n");
 +	kfree_skb(skb);
 +	return 0;
 +}
 +
  static void __metadata_dst_init(struct metadata_dst *md_dst,
  				enum metadata_type type, u8 optslen)
 +
  {
  	struct dst_entry *dst;
  
diff --cc net/core/sock.c
index 035494526dd7,8b7623c7d547..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -2021,33 -2569,56 +2021,60 @@@ out
  }
  EXPORT_SYMBOL_GPL(sk_clone_lock);
  
 -static u32 sk_dst_gso_max_size(struct sock *sk, struct dst_entry *dst)
 +void sk_free_unlock_clone(struct sock *sk)
  {
++<<<<<<< HEAD
 +	/* It is still raw copy of parent, so invalidate
 +	 * destructor and make plain sk_free() */
 +	sk->sk_destruct = NULL;
 +	bh_unlock_sock(sk);
 +	sk_free(sk);
++=======
+ 	bool is_ipv6 = false;
+ 	u32 max_size;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	is_ipv6 = (sk->sk_family == AF_INET6 &&
+ 		   !ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr));
+ #endif
+ 	/* pairs with the WRITE_ONCE() in netif_set_gso(_ipv4)_max_size() */
+ 	max_size = is_ipv6 ? READ_ONCE(dst_dev(dst)->gso_max_size) :
+ 			READ_ONCE(dst_dev(dst)->gso_ipv4_max_size);
+ 	if (max_size > GSO_LEGACY_MAX_SIZE && !sk_is_tcp(sk))
+ 		max_size = GSO_LEGACY_MAX_SIZE;
+ 
+ 	return max_size - (MAX_TCP_HEADER + 1);
++>>>>>>> 88fe14253e18 (net: dst: add four helpers to annotate data-races around dst->dev)
  }
 +EXPORT_SYMBOL_GPL(sk_free_unlock_clone);
  
  void sk_setup_caps(struct sock *sk, struct dst_entry *dst)
  {
  	u32 max_segs = 1;
  
++<<<<<<< HEAD
 +	sk->sk_route_caps = dst->dev->features | sk->sk_route_forced_caps;
++=======
+ 	sk->sk_route_caps = dst_dev(dst)->features;
+ 	if (sk_is_tcp(sk)) {
+ 		struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 		sk->sk_route_caps |= NETIF_F_GSO;
+ 		icsk->icsk_ack.dst_quick_ack = dst_metric(dst, RTAX_QUICKACK);
+ 	}
++>>>>>>> 88fe14253e18 (net: dst: add four helpers to annotate data-races around dst->dev)
  	if (sk->sk_route_caps & NETIF_F_GSO)
  		sk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;
 -	if (unlikely(sk->sk_gso_disabled))
 -		sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
 +	sk->sk_route_caps &= ~sk->sk_route_nocaps;
  	if (sk_can_gso(sk)) {
  		if (dst->header_len && !xfrm_dst_offload_ok(dst)) {
  			sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
  		} else {
  			sk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;
 -			sk->sk_gso_max_size = sk_dst_gso_max_size(sk, dst);
 +			/* pairs with the WRITE_ONCE() in netif_set_gso_max_size() */
 +			sk->sk_gso_max_size = READ_ONCE(dst->dev->gso_max_size);
  			/* pairs with the WRITE_ONCE() in netif_set_gso_max_segs() */
- 			max_segs = max_t(u32, READ_ONCE(dst->dev->gso_max_segs), 1);
+ 			max_segs = max_t(u32, READ_ONCE(dst_dev(dst)->gso_max_segs), 1);
  		}
  	}
  	sk->sk_gso_max_segs = max_segs;
* Unmerged path include/net/dst.h
* Unmerged path net/core/dst.c
* Unmerged path net/core/sock.c
