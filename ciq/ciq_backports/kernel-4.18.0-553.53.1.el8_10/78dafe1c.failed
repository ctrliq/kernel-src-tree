vsock: Orphan socket after transport release

jira LE-3064
cve CVE-2025-21756
Rebuild_History Non-Buildable kernel-4.18.0-553.53.1.el8_10
commit-author Michal Luczaj <mhal@rbox.co>
commit 78dafe1cf3afa02ed71084b350713b07e72a18fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.53.1.el8_10/78dafe1c.failed

During socket release, sock_orphan() is called without considering that it
sets sk->sk_wq to NULL. Later, if SO_LINGER is enabled, this leads to a
null pointer dereferenced in virtio_transport_wait_close().

Orphan the socket only after transport release.

Partially reverts the 'Fixes:' commit.

KASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f]
 lock_acquire+0x19e/0x500
 _raw_spin_lock_irqsave+0x47/0x70
 add_wait_queue+0x46/0x230
 virtio_transport_release+0x4e7/0x7f0
 __vsock_release+0xfd/0x490
 vsock_release+0x90/0x120
 __sock_release+0xa3/0x250
 sock_close+0x14/0x20
 __fput+0x35e/0xa90
 __x64_sys_close+0x78/0xd0
 do_syscall_64+0x93/0x1b0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

	Reported-by: syzbot+9d55b199192a4be7d02c@syzkaller.appspotmail.com
Closes: https://syzkaller.appspot.com/bug?extid=9d55b199192a4be7d02c
Fixes: fcdd2242c023 ("vsock: Keep the binding until socket destruction")
	Tested-by: Luigi Leonardi <leonardi@redhat.com>
	Reviewed-by: Luigi Leonardi <leonardi@redhat.com>
	Signed-off-by: Michal Luczaj <mhal@rbox.co>
Link: https://patch.msgid.link/20250210-vsock-linger-nullderef-v3-1-ef6244d02b54@rbox.co
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 78dafe1cf3afa02ed71084b350713b07e72a18fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/vmw_vsock/af_vsock.c
diff --cc net/vmw_vsock/af_vsock.c
index a7713138d061,53a081d49d28..000000000000
--- a/net/vmw_vsock/af_vsock.c
+++ b/net/vmw_vsock/af_vsock.c
@@@ -773,41 -804,51 +773,55 @@@ static struct sock *__vsock_create(stru
  	return sk;
  }
  
 -static bool sock_type_connectible(u16 type)
 -{
 -	return (type == SOCK_STREAM) || (type == SOCK_SEQPACKET);
 -}
 -
  static void __vsock_release(struct sock *sk, int level)
  {
 -	struct vsock_sock *vsk;
 -	struct sock *pending;
 -
 -	vsk = vsock_sk(sk);
 -	pending = NULL;	/* Compiler warning. */
 +	if (sk) {
 +		struct sock *pending;
 +		struct vsock_sock *vsk;
  
 -	/* When "level" is SINGLE_DEPTH_NESTING, use the nested
 -	 * version to avoid the warning "possible recursive locking
 -	 * detected". When "level" is 0, lock_sock_nested(sk, level)
 -	 * is the same as lock_sock(sk).
 -	 */
 -	lock_sock_nested(sk, level);
 +		vsk = vsock_sk(sk);
 +		pending = NULL;	/* Compiler warning. */
  
 +		/* When "level" is SINGLE_DEPTH_NESTING, use the nested
 +		 * version to avoid the warning "possible recursive locking
 +		 * detected". When "level" is 0, lock_sock_nested(sk, level)
 +		 * is the same as lock_sock(sk).
 +		 */
 +		lock_sock_nested(sk, level);
 +
++<<<<<<< HEAD
 +		if (vsk->transport)
 +			vsk->transport->release(vsk);
 +		else if (sk->sk_type == SOCK_STREAM)
 +			vsock_remove_sock(vsk);
++=======
+ 	/* Indicate to vsock_remove_sock() that the socket is being released and
+ 	 * can be removed from the bound_table. Unlike transport reassignment
+ 	 * case, where the socket must remain bound despite vsock_remove_sock()
+ 	 * being called from the transport release() callback.
+ 	 */
+ 	sock_set_flag(sk, SOCK_DEAD);
++>>>>>>> 78dafe1cf3af (vsock: Orphan socket after transport release)
  
 -	if (vsk->transport)
 -		vsk->transport->release(vsk);
 -	else if (sock_type_connectible(sk->sk_type))
 -		vsock_remove_sock(vsk);
 +		sock_orphan(sk);
 +		sk->sk_shutdown = SHUTDOWN_MASK;
  
++<<<<<<< HEAD
 +		skb_queue_purge(&sk->sk_receive_queue);
++=======
+ 	sock_orphan(sk);
+ 	sk->sk_shutdown = SHUTDOWN_MASK;
++>>>>>>> 78dafe1cf3af (vsock: Orphan socket after transport release)
  
 -	skb_queue_purge(&sk->sk_receive_queue);
 +		/* Clean up any sockets that never were accepted. */
 +		while ((pending = vsock_dequeue_accept(sk)) != NULL) {
 +			__vsock_release(pending, SINGLE_DEPTH_NESTING);
 +			sock_put(pending);
 +		}
  
 -	/* Clean up any sockets that never were accepted. */
 -	while ((pending = vsock_dequeue_accept(sk)) != NULL) {
 -		__vsock_release(pending, SINGLE_DEPTH_NESTING);
 -		sock_put(pending);
 +		release_sock(sk);
 +		sock_put(sk);
  	}
 -
 -	release_sock(sk);
 -	sock_put(sk);
  }
  
  static void vsock_sk_destruct(struct sock *sk)
* Unmerged path net/vmw_vsock/af_vsock.c
