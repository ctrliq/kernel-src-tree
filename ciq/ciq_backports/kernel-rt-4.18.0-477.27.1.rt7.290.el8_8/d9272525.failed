mm: avoid unnecessary page fault retires on shared memory types

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.27.1.rt7.290.el8_8
commit-author Peter Xu <peterx@redhat.com>
commit d92725256b4f22d084b813b37ddc394da79aacab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.27.1.rt7.290.el8_8/d9272525.failed

I observed that for each of the shared file-backed page faults, we're very
likely to retry one more time for the 1st write fault upon no page.  It's
because we'll need to release the mmap lock for dirty rate limit purpose
with balance_dirty_pages_ratelimited() (in fault_dirty_shared_page()).

Then after that throttling we return VM_FAULT_RETRY.

We did that probably because VM_FAULT_RETRY is the only way we can return
to the fault handler at that time telling it we've released the mmap lock.

However that's not ideal because it's very likely the fault does not need
to be retried at all since the pgtable was well installed before the
throttling, so the next continuous fault (including taking mmap read lock,
walk the pgtable, etc.) could be in most cases unnecessary.

It's not only slowing down page faults for shared file-backed, but also add
more mmap lock contention which is in most cases not needed at all.

To observe this, one could try to write to some shmem page and look at
"pgfault" value in /proc/vmstat, then we should expect 2 counts for each
shmem write simply because we retried, and vm event "pgfault" will capture
that.

To make it more efficient, add a new VM_FAULT_COMPLETED return code just to
show that we've completed the whole fault and released the lock.  It's also
a hint that we should very possibly not need another fault immediately on
this page because we've just completed it.

This patch provides a ~12% perf boost on my aarch64 test VM with a simple
program sequentially dirtying 400MB shmem file being mmap()ed and these are
the time it needs:

  Before: 650.980 ms (+-1.94%)
  After:  569.396 ms (+-1.38%)

I believe it could help more than that.

We need some special care on GUP and the s390 pgfault handler (for gmap
code before returning from pgfault), the rest changes in the page fault
handlers should be relatively straightforward.

Another thing to mention is that mm_account_fault() does take this new
fault as a generic fault to be accounted, unlike VM_FAULT_RETRY.

I explicitly didn't touch hmm_vma_fault() and break_ksm() because they do
not handle VM_FAULT_RETRY even with existing code, so I'm literally keeping
them as-is.

Link: https://lkml.kernel.org/r/20220530183450.42886-1-peterx@redhat.com
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: Vineet Gupta <vgupta@kernel.org>
	Acked-by: Guo Ren <guoren@kernel.org>
	Acked-by: Max Filippov <jcmvbkbc@gmail.com>
	Acked-by: Christian Borntraeger <borntraeger@linux.ibm.com>
	Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Reviewed-by: Alistair Popple <apopple@nvidia.com>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Acked-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>	[arm part]
	Acked-by: Heiko Carstens <hca@linux.ibm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Stafford Horne <shorne@gmail.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: Johannes Berg <johannes@sipsolutions.net>
	Cc: Brian Cain <bcain@quicinc.com>
	Cc: Richard Henderson <rth@twiddle.net>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Janosch Frank <frankja@linux.ibm.com>
	Cc: Albert Ou <aou@eecs.berkeley.edu>
	Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Sven Schnelle <svens@linux.ibm.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Alexander Gordeev <agordeev@linux.ibm.com>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Will Deacon <will@kernel.org>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Nicholas Piggin <npiggin@gmail.com>
	Cc: Palmer Dabbelt <palmer@dabbelt.com>
	Cc: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
	Cc: Paul Walmsley <paul.walmsley@sifive.com>
	Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Dinh Nguyen <dinguyen@kernel.org>
	Cc: Rich Felker <dalias@libc.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Helge Deller <deller@gmx.de>
	Cc: Yoshinori Sato <ysato@users.osdn.me>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit d92725256b4f22d084b813b37ddc394da79aacab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mm/fault.c
#	arch/csky/mm/fault.c
#	arch/mips/mm/fault.c
#	arch/riscv/mm/fault.c
#	arch/sh/mm/fault.c
diff --cc arch/arm/mm/fault.c
index f4ea4c62c613,46cccd6bf705..000000000000
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@@ -318,27 -322,12 +318,35 @@@ retry
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Major/minor page fault accounting is only done on the
 +	 * initial attempt. If we go through a retry, it is extremely
 +	 * likely that the page will be found in page cache at that point.
 +	 */
 +
 +	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);
 +	if (!(fault & VM_FAULT_ERROR) && flags & FAULT_FLAG_ALLOW_RETRY) {
 +		if (fault & VM_FAULT_MAJOR) {
 +			tsk->maj_flt++;
 +			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,
 +					regs, addr);
 +		} else {
 +			tsk->min_flt++;
 +			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,
 +					regs, addr);
 +		}
++=======
+ 	/* The fault is fully completed (including releasing mmap lock) */
+ 	if (fault & VM_FAULT_COMPLETED)
+ 		return 0;
+ 
+ 	if (!(fault & VM_FAULT_ERROR)) {
++>>>>>>> d92725256b4f (mm: avoid unnecessary page fault retires on shared memory types)
  		if (fault & VM_FAULT_RETRY) {
 +			/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk
 +			* of starvation. */
 +			flags &= ~FAULT_FLAG_ALLOW_RETRY;
  			flags |= FAULT_FLAG_TRIED;
  			goto retry;
  		}
diff --cc arch/mips/mm/fault.c
index c6c649690877,a27045f5a556..000000000000
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@@ -152,12 -154,18 +152,19 @@@ good_area
  	 * make sure we exit gracefully rather than endlessly redo
  	 * the fault.
  	 */
 -	fault = handle_mm_fault(vma, address, flags, regs);
 +	fault = handle_mm_fault(vma, address, flags);
  
 -	if (fault_signal_pending(fault, regs)) {
 -		if (!user_mode(regs))
 -			goto no_context;
 +	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
  		return;
 -	}
  
++<<<<<<< HEAD
 +	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
++=======
+ 	/* The fault is fully completed (including releasing mmap lock) */
+ 	if (fault & VM_FAULT_COMPLETED)
+ 		return;
+ 
++>>>>>>> d92725256b4f (mm: avoid unnecessary page fault retires on shared memory types)
  	if (unlikely(fault & VM_FAULT_ERROR)) {
  		if (fault & VM_FAULT_OOM)
  			goto out_of_memory;
diff --cc arch/riscv/mm/fault.c
index 88401d5125bc,f2fbd1400b7c..000000000000
--- a/arch/riscv/mm/fault.c
+++ b/arch/riscv/mm/fault.c
@@@ -124,163 -320,34 +124,183 @@@ good_area
  
  	/*
  	 * If we need to retry but a fatal signal is pending, handle the
 -	 * signal first. We do not need to release the mmap_lock because it
 +	 * signal first. We do not need to release the mmap_sem because it
  	 * would already be released in __lock_page_or_retry in mm/filemap.c.
  	 */
 -	if (fault_signal_pending(fault, regs))
 +	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(tsk))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	/* The fault is fully completed (including releasing mmap lock) */
+ 	if (fault & VM_FAULT_COMPLETED)
+ 		return;
+ 
+ 	if (unlikely(fault & VM_FAULT_RETRY)) {
+ 		flags |= FAULT_FLAG_TRIED;
+ 
+ 		/*
+ 		 * No need to mmap_read_unlock(mm) as we would
+ 		 * have already released it in __lock_page_or_retry
+ 		 * in mm/filemap.c.
+ 		 */
+ 		goto retry;
+ 	}
+ 
+ 	mmap_read_unlock(mm);
+ 
++>>>>>>> d92725256b4f (mm: avoid unnecessary page fault retires on shared memory types)
  	if (unlikely(fault & VM_FAULT_ERROR)) {
 -		tsk->thread.bad_cause = cause;
 -		mm_fault_error(regs, addr, fault);
 +		if (fault & VM_FAULT_OOM)
 +			goto out_of_memory;
 +		else if (fault & VM_FAULT_SIGBUS)
 +			goto do_sigbus;
 +		BUG();
 +	}
 +
 +	/*
 +	 * Major/minor page fault accounting is only done on the
 +	 * initial attempt. If we go through a retry, it is extremely
 +	 * likely that the page will be found in page cache at that point.
 +	 */
 +	if (flags & FAULT_FLAG_ALLOW_RETRY) {
 +		if (fault & VM_FAULT_MAJOR) {
 +			tsk->maj_flt++;
 +			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,
 +				      1, regs, addr);
 +		} else {
 +			tsk->min_flt++;
 +			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,
 +				      1, regs, addr);
 +		}
 +		if (fault & VM_FAULT_RETRY) {
 +			/*
 +			 * Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk
 +			 * of starvation.
 +			 */
 +			flags &= ~(FAULT_FLAG_ALLOW_RETRY);
 +			flags |= FAULT_FLAG_TRIED;
 +
 +			/*
 +			 * No need to up_read(&mm->mmap_sem) as we would
 +			 * have already released it in __lock_page_or_retry
 +			 * in mm/filemap.c.
 +			 */
 +			goto retry;
 +		}
 +	}
 +
 +	up_read(&mm->mmap_sem);
 +	return;
 +
 +	/*
 +	 * Something tried to access memory that isn't in our memory map.
 +	 * Fix it, but check if it's kernel or user first.
 +	 */
 +bad_area:
 +	up_read(&mm->mmap_sem);
 +	/* User mode accesses just cause a SIGSEGV */
 +	if (user_mode(regs)) {
 +		do_trap(regs, SIGSEGV, code, addr, tsk);
  		return;
  	}
 +
 +no_context:
 +	/* Are we prepared to handle this kernel fault? */
 +	if (fixup_exception(regs))
 +		return;
 +
 +	/*
 +	 * Oops. The kernel tried to access some bad page. We'll have to
 +	 * terminate things with extreme prejudice.
 +	 */
 +	bust_spinlocks(1);
 +	pr_alert("Unable to handle kernel %s at virtual address " REG_FMT "\n",
 +		(addr < PAGE_SIZE) ? "NULL pointer dereference" :
 +		"paging request", addr);
 +	die(regs, "Oops");
 +	do_exit(SIGKILL);
 +
 +	/*
 +	 * We ran out of memory, call the OOM killer, and return the userspace
 +	 * (which will retry the fault, or kill us if we got oom-killed).
 +	 */
 +out_of_memory:
 +	up_read(&mm->mmap_sem);
 +	if (!user_mode(regs))
 +		goto no_context;
 +	pagefault_out_of_memory();
  	return;
 +
 +do_sigbus:
 +	up_read(&mm->mmap_sem);
 +	/* Kernel mode? Handle exceptions or die */
 +	if (!user_mode(regs))
 +		goto no_context;
 +	do_trap(regs, SIGBUS, BUS_ADRERR, addr, tsk);
 +	return;
 +
 +vmalloc_fault:
 +	{
 +		pgd_t *pgd, *pgd_k;
 +		pud_t *pud, *pud_k;
 +		p4d_t *p4d, *p4d_k;
 +		pmd_t *pmd, *pmd_k;
 +		pte_t *pte_k;
 +		int index;
 +
 +		if (user_mode(regs))
 +			goto bad_area;
 +
 +		/*
 +		 * Synchronize this task's top level page-table
 +		 * with the 'reference' page table.
 +		 *
 +		 * Do _not_ use "tsk->active_mm->pgd" here.
 +		 * We might be inside an interrupt in the middle
 +		 * of a task switch.
 +		 *
 +		 * Note: Use the old spbtr name instead of using the current
 +		 * satp name to support binutils 2.29 which doesn't know about
 +		 * the privileged ISA 1.10 yet.
 +		 */
 +		index = pgd_index(addr);
 +		pgd = (pgd_t *)pfn_to_virt(csr_read(sptbr)) + index;
 +		pgd_k = init_mm.pgd + index;
 +
 +		if (!pgd_present(*pgd_k))
 +			goto no_context;
 +		set_pgd(pgd, *pgd_k);
 +
 +		p4d = p4d_offset(pgd, addr);
 +		p4d_k = p4d_offset(pgd_k, addr);
 +		if (!p4d_present(*p4d_k))
 +			goto no_context;
 +
 +		pud = pud_offset(p4d, addr);
 +		pud_k = pud_offset(p4d_k, addr);
 +		if (!pud_present(*pud_k))
 +			goto no_context;
 +
 +		/*
 +		 * Since the vmalloc area is global, it is unnecessary
 +		 * to copy individual PTEs
 +		 */
 +		pmd = pmd_offset(pud, addr);
 +		pmd_k = pmd_offset(pud_k, addr);
 +		if (!pmd_present(*pmd_k))
 +			goto no_context;
 +		set_pmd(pmd, *pmd_k);
 +
 +		/*
 +		 * Make sure the actual PTE exists as well to
 +		 * catch kernel vmalloc-area accesses to non-mapped
 +		 * addresses. If we don't do this, this will just
 +		 * silently loop forever.
 +		 */
 +		pte_k = pte_offset_kernel(pmd_k, addr);
 +		if (!pte_present(*pte_k))
 +			goto no_context;
 +		return;
 +	}
  }
 -NOKPROBE_SYMBOL(do_page_fault);
diff --cc arch/sh/mm/fault.c
index a6204b0b1a3e,acd2f5e50bfc..000000000000
--- a/arch/sh/mm/fault.c
+++ b/arch/sh/mm/fault.c
@@@ -487,28 -485,20 +487,37 @@@ good_area
  		if (mm_fault_error(regs, error_code, address, fault))
  			return;
  
++<<<<<<< HEAD
 +	if (flags & FAULT_FLAG_ALLOW_RETRY) {
 +		if (fault & VM_FAULT_MAJOR) {
 +			tsk->maj_flt++;
 +			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,
 +				      regs, address);
 +		} else {
 +			tsk->min_flt++;
 +			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,
 +				      regs, address);
 +		}
 +		if (fault & VM_FAULT_RETRY) {
 +			flags &= ~FAULT_FLAG_ALLOW_RETRY;
 +			flags |= FAULT_FLAG_TRIED;
++=======
+ 	/* The fault is fully completed (including releasing mmap lock) */
+ 	if (fault & VM_FAULT_COMPLETED)
+ 		return;
+ 
+ 	if (fault & VM_FAULT_RETRY) {
+ 		flags |= FAULT_FLAG_TRIED;
 -
 -		/*
 -		 * No need to mmap_read_unlock(mm) as we would
 -		 * have already released it in __lock_page_or_retry
 -		 * in mm/filemap.c.
 -		 */
 -		goto retry;
++>>>>>>> d92725256b4f (mm: avoid unnecessary page fault retires on shared memory types)
 +
 +			/*
 +			 * No need to up_read(&mm->mmap_sem) as we would
 +			 * have already released it in __lock_page_or_retry
 +			 * in mm/filemap.c.
 +			 */
 +			goto retry;
 +		}
  	}
  
 -	mmap_read_unlock(mm);
 +	up_read(&mm->mmap_sem);
  }
* Unmerged path arch/csky/mm/fault.c
diff --git a/arch/alpha/mm/fault.c b/arch/alpha/mm/fault.c
index d73dc473fbb9..0891632a53da 100644
--- a/arch/alpha/mm/fault.c
+++ b/arch/alpha/mm/fault.c
@@ -153,6 +153,10 @@ do_page_fault(unsigned long address, unsigned long mmcsr,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
diff --git a/arch/arc/mm/fault.c b/arch/arc/mm/fault.c
index db6913094be3..db01a1bd054c 100644
--- a/arch/arc/mm/fault.c
+++ b/arch/arc/mm/fault.c
@@ -188,6 +188,10 @@ void do_page_fault(unsigned long address, struct pt_regs *regs)
 	/* no man's land */
 	BUG();
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	/*
 	 * Something tried to access memory that isn't in our memory map..
 	 * Fix it, but check if it's kernel or user first..
* Unmerged path arch/arm/mm/fault.c
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index 1ba01ace6ef9..2136197b4b08 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -553,6 +553,10 @@ static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,
 		return 0;
 	}
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return 0;
+
 	if (fault & VM_FAULT_RETRY) {
 		if (mm_flags & FAULT_FLAG_ALLOW_RETRY) {
 			mm_flags |= FAULT_FLAG_TRIED;
* Unmerged path arch/csky/mm/fault.c
diff --git a/arch/hexagon/mm/vm_fault.c b/arch/hexagon/mm/vm_fault.c
index eb263e61daf4..7be9b7c0b1c5 100644
--- a/arch/hexagon/mm/vm_fault.c
+++ b/arch/hexagon/mm/vm_fault.c
@@ -107,6 +107,10 @@ void do_page_fault(unsigned long address, long cause, struct pt_regs *regs)
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	/* The most common case -- we are done. */
 	if (likely(!(fault & VM_FAULT_ERROR))) {
 		if (flags & FAULT_FLAG_ALLOW_RETRY) {
diff --git a/arch/ia64/mm/fault.c b/arch/ia64/mm/fault.c
index a9d55ad8d67b..ae86a4972db3 100644
--- a/arch/ia64/mm/fault.c
+++ b/arch/ia64/mm/fault.c
@@ -166,6 +166,10 @@ ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *re
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		/*
 		 * We ran out of memory, or some other thing happened
diff --git a/arch/m68k/mm/fault.c b/arch/m68k/mm/fault.c
index 9b6163c05a75..10044f123def 100644
--- a/arch/m68k/mm/fault.c
+++ b/arch/m68k/mm/fault.c
@@ -141,6 +141,10 @@ int do_page_fault(struct pt_regs *regs, unsigned long address,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return 0;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return 0;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
diff --git a/arch/microblaze/mm/fault.c b/arch/microblaze/mm/fault.c
index 202ad6a494f5..cb70f101d1d3 100644
--- a/arch/microblaze/mm/fault.c
+++ b/arch/microblaze/mm/fault.c
@@ -220,6 +220,10 @@ void do_page_fault(struct pt_regs *regs, unsigned long address,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
* Unmerged path arch/mips/mm/fault.c
diff --git a/arch/nios2/mm/fault.c b/arch/nios2/mm/fault.c
index 24fd84cf6006..4d06b3b4c44b 100644
--- a/arch/nios2/mm/fault.c
+++ b/arch/nios2/mm/fault.c
@@ -137,6 +137,10 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long cause,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
diff --git a/arch/openrisc/mm/fault.c b/arch/openrisc/mm/fault.c
index dc4dbafc1d83..b25caae9d38c 100644
--- a/arch/openrisc/mm/fault.c
+++ b/arch/openrisc/mm/fault.c
@@ -168,6 +168,10 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long address,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
diff --git a/arch/parisc/mm/fault.c b/arch/parisc/mm/fault.c
index c8e8b7c05558..6b2a61b75340 100644
--- a/arch/parisc/mm/fault.c
+++ b/arch/parisc/mm/fault.c
@@ -306,6 +306,10 @@ void do_page_fault(struct pt_regs *regs, unsigned long code,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		/*
 		 * We hit a shared mapping outside of the file, or some
diff --git a/arch/powerpc/mm/copro_fault.c b/arch/powerpc/mm/copro_fault.c
index dd0cd0ac405e..b5d0aeef52ce 100644
--- a/arch/powerpc/mm/copro_fault.c
+++ b/arch/powerpc/mm/copro_fault.c
@@ -78,6 +78,11 @@ int copro_handle_mm_fault(struct mm_struct *mm, unsigned long ea,
 
 	ret = 0;
 	*flt = handle_mm_fault(vma, ea, is_write ? FAULT_FLAG_WRITE : 0, NULL);
+
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (*flt & VM_FAULT_COMPLETED)
+		return 0;
+
 	if (unlikely(*flt & VM_FAULT_ERROR)) {
 		if (*flt & VM_FAULT_OOM) {
 			ret = -ENOMEM;
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index 288e47193ab3..b1067f3f833a 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -624,6 +624,10 @@ static int __do_page_fault(struct pt_regs *regs, unsigned long address,
 	if (fault_signal_pending(fault, regs))
 		return user_mode(regs) ? 0 : SIGBUS;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		goto out;
+
 	/*
 	 * Handle the retry right now, the mmap_lock has been released in that
 	 * case.
@@ -640,6 +644,7 @@ static int __do_page_fault(struct pt_regs *regs, unsigned long address,
 	if (unlikely(fault & VM_FAULT_ERROR))
 		return mm_fault_error(regs, address, fault);
 
+out:
 	/*
 	 * Major/minor page fault accounting.
 	 */
* Unmerged path arch/riscv/mm/fault.c
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 35778ce3ae24..0589166be07c 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -522,6 +522,17 @@ static inline vm_fault_t do_exception(struct pt_regs *regs, int access)
 			goto out_up;
 		goto out;
 	}
+
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED) {
+		if (gmap) {
+			mmap_read_lock(mm);
+			goto out_gmap;
+		}
+		fault = 0;
+		goto out;
+	}
+
 	if (unlikely(fault & VM_FAULT_ERROR))
 		goto out_up;
 
@@ -541,6 +552,7 @@ static inline vm_fault_t do_exception(struct pt_regs *regs, int access)
 			goto retry;
 		}
 	}
+out_gmap:
 	if (IS_ENABLED(CONFIG_PGSTE) && gmap) {
 		address =  __gmap_link(gmap, current->thread.gmap_addr,
 				       address);
* Unmerged path arch/sh/mm/fault.c
diff --git a/arch/sparc/mm/fault_32.c b/arch/sparc/mm/fault_32.c
index b0440b0edd97..b673ea8e759c 100644
--- a/arch/sparc/mm/fault_32.c
+++ b/arch/sparc/mm/fault_32.c
@@ -240,6 +240,10 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
diff --git a/arch/sparc/mm/fault_64.c b/arch/sparc/mm/fault_64.c
index 8f8a604c1300..a82f2d8f3838 100644
--- a/arch/sparc/mm/fault_64.c
+++ b/arch/sparc/mm/fault_64.c
@@ -438,6 +438,10 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		goto exit_exception;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		goto lock_released;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
@@ -472,6 +476,7 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 	}
 	up_read(&mm->mmap_sem);
 
+lock_released:
 	mm_rss = get_mm_rss(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE)
 	mm_rss -= (mm->context.thp_pte_count * (HPAGE_SIZE / PAGE_SIZE));
diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c
index eb03c74541ae..8262065705a9 100644
--- a/arch/um/kernel/trap.c
+++ b/arch/um/kernel/trap.c
@@ -79,6 +79,10 @@ int handle_page_fault(unsigned long address, unsigned long ip,
 		if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 			goto out_nosemaphore;
 
+		/* The fault is fully completed (including releasing mmap lock) */
+		if (fault & VM_FAULT_COMPLETED)
+			return 0;
+
 		if (unlikely(fault & VM_FAULT_ERROR)) {
 			if (fault & VM_FAULT_OOM) {
 				goto out_of_memory;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 322898ed670a..9303c09e3c35 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1444,6 +1444,10 @@ void do_user_addr_fault(struct pt_regs *regs,
 		return;
 	}
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	/*
 	 * If we need to retry the mmap_lock has already been released,
 	 * and if there is a fatal signal pending there is no guarantee
diff --git a/arch/xtensa/mm/fault.c b/arch/xtensa/mm/fault.c
index 2ab0e0dcd166..3a99bf781fb2 100644
--- a/arch/xtensa/mm/fault.c
+++ b/arch/xtensa/mm/fault.c
@@ -113,6 +113,10 @@ void do_page_fault(struct pt_regs *regs)
 	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
 		return;
 
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 22721ebdfe52..7349c5f407bd 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -754,6 +754,7 @@ typedef RH_KABI_ADD_MODIFIER(__bitwise unsigned) int vm_fault_t;
  * @VM_FAULT_NEEDDSYNC:		->fault did not modify page tables and needs
  *				fsync() to complete (for synchronous page faults
  *				in DAX)
+ * @VM_FAULT_COMPLETED:		->fault completed, meanwhile mmap lock released
  * @VM_FAULT_HINDEX_MASK:	mask HINDEX value
  *
  */
@@ -771,6 +772,7 @@ enum vm_fault_reason {
 	VM_FAULT_FALLBACK       = (__force vm_fault_t)0x000800,
 	VM_FAULT_DONE_COW       = (__force vm_fault_t)0x001000,
 	VM_FAULT_NEEDDSYNC      = (__force vm_fault_t)0x002000,
+	VM_FAULT_COMPLETED      = (__force vm_fault_t)0x004000,
 	VM_FAULT_HINDEX_MASK    = (__force vm_fault_t)0x0f0000,
 };
 
diff --git a/mm/gup.c b/mm/gup.c
index 5ecaf24a4019..f4255b3ed8ad 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -1117,6 +1117,25 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	}
 
 	ret = handle_mm_fault(vma, address, fault_flags, NULL);
+
+	if (ret & VM_FAULT_COMPLETED) {
+		/*
+		 * With FAULT_FLAG_RETRY_NOWAIT we'll never release the
+		 * mmap lock in the page fault handler. Sanity check this.
+		 */
+		WARN_ON_ONCE(fault_flags & FAULT_FLAG_RETRY_NOWAIT);
+		if (locked)
+			*locked = 0;
+		/*
+		 * We should do the same as VM_FAULT_RETRY, but let's not
+		 * return -EBUSY since that's not reflecting the reality of
+		 * what has happened - we've just fully completed a page
+		 * fault, with the mmap lock released.  Use -EAGAIN to show
+		 * that we want to take the mmap lock _again_.
+		 */
+		return -EAGAIN;
+	}
+
 	if (ret & VM_FAULT_ERROR) {
 		int err = vm_fault_to_errno(ret, *flags);
 
@@ -1341,6 +1360,7 @@ static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 			case 0:
 				goto retry;
 			case -EBUSY:
+			case -EAGAIN:
 				ret = 0;
 				/* FALLTHRU */
 			case -EFAULT:
@@ -1471,6 +1491,18 @@ int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,
 		return -EINTR;
 
 	ret = handle_mm_fault(vma, address, fault_flags, NULL);
+
+	if (ret & VM_FAULT_COMPLETED) {
+		/*
+		 * NOTE: it's a pity that we need to retake the lock here
+		 * to pair with the unlock() in the callers. Ideally we
+		 * could tell the callers so they do not need to unlock.
+		 */
+		mmap_read_lock(mm);
+		*unlocked = true;
+		return 0;
+	}
+
 	if (ret & VM_FAULT_ERROR) {
 		int err = vm_fault_to_errno(ret, 0);
 
@@ -1537,7 +1569,7 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 			/* VM_FAULT_RETRY couldn't trigger, bypass */
 			return ret;
 
-		/* VM_FAULT_RETRY cannot return errors */
+		/* VM_FAULT_RETRY or VM_FAULT_COMPLETED cannot return errors */
 		if (!*locked) {
 			BUG_ON(ret < 0);
 			BUG_ON(ret >= nr_pages);
diff --git a/mm/memory.c b/mm/memory.c
index 36a918d2e9eb..adde484f34e5 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2512,7 +2512,7 @@ static vm_fault_t fault_dirty_shared_page(struct vm_fault *vmf)
 		balance_dirty_pages_ratelimited(mapping);
 		if (fpin) {
 			fput(fpin);
-			return VM_FAULT_RETRY;
+			return VM_FAULT_COMPLETED;
 		}
 	}
 
