gfs2: Fix freeze consistency check in gfs2_trans_add_meta

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-477.27.1.rt7.290.el8_8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 2cbd80642b76480c9b0697297af917d9388a0b46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-477.27.1.rt7.290.el8_8/2cbd8064.failed

Function gfs2_trans_add_meta() checks for the SDF_FROZEN flag to make
sure that no buffers are added to a transaction while the filesystem is
frozen.  With the recent freeze/thaw rework, the SDF_FROZEN flag is
cleared after thaw_super() is called, which is sufficient for
serializing freeze/thaw.

However, other filesystem operations started after thaw_super() may now
be calling gfs2_trans_add_meta() before the SDF_FROZEN flag is cleared,
which will trigger the SDF_FROZEN check in gfs2_trans_add_meta().  Fix
that by checking the s_writers.frozen state instead.

In addition, make sure not to call gfs2_assert_withdraw() with the
sd_log_lock spin lock held.  Check for a withdrawn filesystem before
checking for a frozen filesystem, and don't pin/add buffers to the
current transaction in case of a failure in either case.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 2cbd80642b76480c9b0697297af917d9388a0b46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/trans.c
diff --cc fs/gfs2/trans.c
index d4cda4f24672,7e835be7032d..000000000000
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@@ -236,7 -234,7 +237,11 @@@ void gfs2_trans_add_meta(struct gfs2_gl
  	struct gfs2_bufdata *bd;
  	struct gfs2_meta_header *mh;
  	struct gfs2_trans *tr = current->journal_info;
++<<<<<<< HEAD
 +	enum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);
++=======
+ 	bool withdraw = false;
++>>>>>>> 2cbd80642b76 (gfs2: Fix freeze consistency check in gfs2_trans_add_meta)
  
  	lock_buffer(bh);
  	if (buffer_pinned(bh)) {
@@@ -270,10 -268,6 +275,13 @@@
  		       (unsigned long long)bd->bd_bh->b_blocknr);
  		BUG();
  	}
++<<<<<<< HEAD
 +	if (unlikely(state == SFS_FROZEN)) {
 +		fs_info(sdp, "GFS2:adding buf while frozen\n");
 +		gfs2_assert_withdraw(sdp, 0);
 +	}
++=======
++>>>>>>> 2cbd80642b76 (gfs2: Fix freeze consistency check in gfs2_trans_add_meta)
  	if (unlikely(gfs2_withdrawn(sdp))) {
  		fs_info(sdp, "GFS2:adding buf while withdrawn! 0x%llx\n",
  			(unsigned long long)bd->bd_bh->b_blocknr);
* Unmerged path fs/gfs2/trans.c
