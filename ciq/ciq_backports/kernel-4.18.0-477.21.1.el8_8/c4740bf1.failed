iomap: switch iomap_seek_data to use iomap_iter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.21.1.el8_8
commit-author Christoph Hellwig <hch@lst.de>
commit c4740bf1edad559c10b1d33c72e885b920bf6029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.21.1.el8_8/c4740bf1.failed

Rewrite iomap_seek_data to use iomap_iter.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit c4740bf1edad559c10b1d33c72e885b920bf6029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/seek.c
diff --cc fs/iomap/seek.c
index 89f61d93c0bc,a845c012b50c..000000000000
--- a/fs/iomap/seek.c
+++ b/fs/iomap/seek.c
@@@ -163,50 -56,49 +163,88 @@@ iomap_seek_hole(struct inode *inode, lo
  }
  EXPORT_SYMBOL_GPL(iomap_seek_hole);
  
++<<<<<<< HEAD
 +static loff_t
 +iomap_seek_data_actor(struct inode *inode, loff_t offset, loff_t length,
 +		      void *data, struct iomap *iomap, struct iomap *srcmap)
 +{
 +	switch (iomap->type) {
 +	case IOMAP_HOLE:
 +		return length;
 +	case IOMAP_UNWRITTEN:
 +		offset = page_cache_seek_hole_data(inode, offset, length,
 +						   SEEK_DATA);
 +		if (offset < 0)
 +			return length;
 +		/*FALLTHRU*/
++=======
+ static loff_t iomap_seek_data_iter(const struct iomap_iter *iter,
+ 		loff_t *hole_pos)
+ {
+ 	loff_t length = iomap_length(iter);
+ 
+ 	switch (iter->iomap.type) {
+ 	case IOMAP_HOLE:
+ 		return length;
+ 	case IOMAP_UNWRITTEN:
+ 		*hole_pos = mapping_seek_hole_data(iter->inode->i_mapping,
+ 				iter->pos, iter->pos + length, SEEK_DATA);
+ 		if (*hole_pos < 0)
+ 			return length;
+ 		return 0;
++>>>>>>> c4740bf1edad (iomap: switch iomap_seek_data to use iomap_iter)
  	default:
- 		*(loff_t *)data = offset;
+ 		*hole_pos = iter->pos;
  		return 0;
  	}
  }
  
  loff_t
- iomap_seek_data(struct inode *inode, loff_t offset, const struct iomap_ops *ops)
+ iomap_seek_data(struct inode *inode, loff_t pos, const struct iomap_ops *ops)
  {
  	loff_t size = i_size_read(inode);
++<<<<<<< HEAD
 +	loff_t length = size - offset;
 +	loff_t ret;
++=======
+ 	struct iomap_iter iter = {
+ 		.inode	= inode,
+ 		.pos	= pos,
+ 		.flags	= IOMAP_REPORT,
+ 	};
+ 	int ret;
++>>>>>>> c4740bf1edad (iomap: switch iomap_seek_data to use iomap_iter)
  
  	/* Nothing to be found before or beyond the end of the file. */
- 	if (offset < 0 || offset >= size)
+ 	if (pos < 0 || pos >= size)
  		return -ENXIO;
  
++<<<<<<< HEAD
 +	while (length > 0) {
 +		ret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,
 +				  &offset, iomap_seek_data_actor);
 +		if (ret < 0)
 +			return ret;
 +		if (ret == 0)
 +			break;
 +
 +		offset += ret;
 +		length -= ret;
 +	}
 +
 +	if (length <= 0)
 +		return -ENXIO;
 +	return offset;
++=======
+ 	iter.len = size - pos;
+ 	while ((ret = iomap_iter(&iter, ops)) > 0)
+ 		iter.processed = iomap_seek_data_iter(&iter, &pos);
+ 	if (ret < 0)
+ 		return ret;
+ 	if (iter.len) /* found data before EOF */
+ 		return pos;
+ 	/* We've reached the end of the file without finding data */
+ 	return -ENXIO;
++>>>>>>> c4740bf1edad (iomap: switch iomap_seek_data to use iomap_iter)
  }
  EXPORT_SYMBOL_GPL(iomap_seek_data);
* Unmerged path fs/iomap/seek.c
