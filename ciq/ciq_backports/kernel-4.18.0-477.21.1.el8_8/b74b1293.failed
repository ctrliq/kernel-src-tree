iomap: rework unshare flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.21.1.el8_8
commit-author Christoph Hellwig <hch@lst.de>
commit b74b1293e6cae70bade491067f15b9d33e040cad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.21.1.el8_8/b74b1293.failed

Instead of another internal flags namespace inside of buffered-io.c,
just pass a UNSHARE hint in the main iomap flags field.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit b74b1293e6cae70bade491067f15b9d33e040cad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/buffered-io.c
diff --cc fs/iomap/buffered-io.c
index a9fecbda715a,a0ef7ebe9209..000000000000
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@@ -581,12 -536,12 +577,17 @@@ iomap_read_page_sync(loff_t block_start
  	return submit_bio_wait(&bio);
  }
  
++<<<<<<< HEAD
 +static int
 +__iomap_write_begin(struct inode *inode, loff_t pos, unsigned len, int flags,
 +		struct page *page, struct iomap *srcmap)
++=======
+ static int __iomap_write_begin(struct iomap_iter *iter, loff_t pos,
+ 		unsigned len, struct page *page)
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  {
 -	struct iomap *srcmap = iomap_iter_srcmap(iter);
 -	struct iomap_page *iop = iomap_page_create(iter->inode, page);
 -	loff_t block_size = i_blocksize(iter->inode);
 +	struct iomap_page *iop = iomap_page_create(inode, page);
 +	loff_t block_size = i_blocksize(inode);
  	loff_t block_start = round_down(pos, block_size);
  	loff_t block_end = round_up(pos + len, block_size);
  	unsigned from = offset_in_page(pos), to = from + len, poff, plen;
@@@ -606,8 -561,8 +607,13 @@@
  		    (to <= poff || to >= poff + plen))
  			continue;
  
++<<<<<<< HEAD
 +		if (iomap_block_needs_zeroing(inode, srcmap, block_start)) {
 +			if (WARN_ON_ONCE(flags & IOMAP_WRITE_F_UNSHARE))
++=======
+ 		if (iomap_block_needs_zeroing(iter, block_start)) {
+ 			if (WARN_ON_ONCE(iter->flags & IOMAP_UNSHARE))
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  				return -EIO;
  			zero_user_segments(page, poff, from, to, poff + plen);
  		} else {
@@@ -649,11 -591,11 +655,16 @@@ static int iomap_write_begin_inline(str
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +iomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,
 +		struct page **pagep, struct iomap *iomap, struct iomap *srcmap)
++=======
+ static int iomap_write_begin(struct iomap_iter *iter, loff_t pos, unsigned len,
+ 		struct page **pagep)
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  {
 -	const struct iomap_page_ops *page_ops = iter->iomap.page_ops;
 -	struct iomap *srcmap = iomap_iter_srcmap(iter);
 +	const struct iomap_page_ops *page_ops = iomap->page_ops;
  	struct page *page;
  	int status = 0;
  
@@@ -679,12 -620,11 +690,16 @@@
  	}
  
  	if (srcmap->type == IOMAP_INLINE)
 -		status = iomap_write_begin_inline(iter, page);
 -	else if (srcmap->flags & IOMAP_F_BUFFER_HEAD)
 +		status = iomap_write_begin_inline(inode, page, srcmap);
 +	else if (iomap->flags & IOMAP_F_BUFFER_HEAD)
  		status = __block_write_begin_int(page, pos, len, NULL, srcmap);
  	else
++<<<<<<< HEAD
 +		status = __iomap_write_begin(inode, pos, len, flags, page,
 +				srcmap);
++=======
+ 		status = __iomap_write_begin(iter, pos, len, page);
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  
  	if (unlikely(status))
  		goto out_unlock;
@@@ -833,8 -755,7 +848,12 @@@ again
  			break;
  		}
  
++<<<<<<< HEAD
 +		status = iomap_write_begin(iter->inode, pos, bytes, 0, &page,
 +					   iomap, srcmap);
++=======
+ 		status = iomap_write_begin(iter, pos, bytes, &page);
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  		if (unlikely(status))
  			break;
  
@@@ -912,8 -832,7 +931,12 @@@ static loff_t iomap_unshare_iter(struc
  		unsigned long bytes = min_t(loff_t, PAGE_SIZE - offset, length);
  		struct page *page;
  
++<<<<<<< HEAD
 +		status = iomap_write_begin(iter->inode, pos, bytes,
 +				IOMAP_WRITE_F_UNSHARE, &page, iomap, srcmap);
++=======
+ 		status = iomap_write_begin(iter, pos, bytes, &page);
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  		if (unlikely(status))
  			return status;
  
@@@ -960,7 -877,7 +983,11 @@@ static s64 iomap_zero(struct inode *ino
  	unsigned offset = offset_in_page(pos);
  	unsigned bytes = min_t(u64, PAGE_SIZE - offset, length);
  
++<<<<<<< HEAD
 +	status = iomap_write_begin(inode, pos, bytes, 0, &page, iomap, srcmap);
++=======
+ 	status = iomap_write_begin(iter, pos, bytes, &page);
++>>>>>>> b74b1293e6ca (iomap: rework unshare flag)
  	if (status)
  		return status;
  
* Unmerged path fs/iomap/buffered-io.c
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 293e72d14e21..998ee85f183e 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -143,6 +143,7 @@ struct iomap_page_ops {
 #define IOMAP_DIRECT		(1 << 4) /* direct I/O */
 #define IOMAP_NOWAIT		(1 << 5) /* do not block */
 #define IOMAP_OVERWRITE_ONLY	(1 << 6) /* only pure overwrites allowed */
+#define IOMAP_UNSHARE		(1 << 7) /* unshare_file_range */
 
 struct iomap_ops {
 	/*
