iomap: switch readahead and readpage to use iomap_iter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.21.1.el8_8
commit-author Christoph Hellwig <hch@lst.de>
commit f6d480006cea3fa1188931fe9751255f13365c4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.21.1.el8_8/f6d48000.failed

Switch the page cache read functions to use iomap_iter instead of
iomap_apply.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit f6d480006cea3fa1188931fe9751255f13365c4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/buffered-io.c
diff --cc fs/iomap/buffered-io.c
index 79f4f312beda,32d80350bb55..000000000000
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@@ -256,14 -241,14 +256,15 @@@ static inline bool iomap_block_needs_ze
  		pos >= i_size_read(inode);
  }
  
- static loff_t
- iomap_readpage_actor(struct inode *inode, loff_t pos, loff_t length, void *data,
- 		struct iomap *iomap, struct iomap *srcmap)
+ static loff_t iomap_readpage_iter(struct iomap_iter *iter,
+ 		struct iomap_readpage_ctx *ctx, loff_t offset)
  {
- 	struct iomap_readpage_ctx *ctx = data;
+ 	struct iomap *iomap = &iter->iomap;
+ 	loff_t pos = iter->pos + offset;
+ 	loff_t length = iomap_length(iter) - offset;
  	struct page *page = ctx->cur_page;
  	struct iomap_page *iop;
 +	bool is_contig = false;
  	loff_t orig_pos = pos;
  	unsigned poff, plen;
  	sector_t sector;
@@@ -420,25 -390,19 +420,38 @@@ static loff_t iomap_readahead_iter(stru
   */
  void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
  {
++<<<<<<< HEAD
 +	struct inode *inode = rac->mapping->host;
 +	loff_t pos = readahead_pos(rac);
 +	loff_t length = readahead_length(rac);
++=======
+ 	struct iomap_iter iter = {
+ 		.inode	= rac->mapping->host,
+ 		.pos	= readahead_pos(rac),
+ 		.len	= readahead_length(rac),
+ 	};
++>>>>>>> f6d480006cea (iomap: switch readahead and readpage to use iomap_iter)
  	struct iomap_readpage_ctx ctx = {
  		.rac	= rac,
  	};
  
- 	trace_iomap_readahead(inode, readahead_count(rac));
+ 	trace_iomap_readahead(rac->mapping->host, readahead_count(rac));
  
++<<<<<<< HEAD
 +	while (length > 0) {
 +		loff_t ret = iomap_apply(inode, pos, length, 0, ops,
 +				&ctx, iomap_readahead_actor);
 +		if (ret <= 0) {
 +			WARN_ON_ONCE(ret == 0);
 +			break;
 +		}
 +		pos += ret;
 +		length -= ret;
 +	}
++=======
+ 	while (iomap_iter(&iter, ops) > 0)
+ 		iter.processed = iomap_readahead_iter(&iter, &ctx);
++>>>>>>> f6d480006cea (iomap: switch readahead and readpage to use iomap_iter)
  
  	if (ctx.bio)
  		submit_bio(ctx.bio);
* Unmerged path fs/iomap/buffered-io.c
