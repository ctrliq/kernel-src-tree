block: make sure local irq is disabled when calling __blkcg_rstat_flush

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.21.1.el8_8
commit-author Ming Lei <ming.lei@redhat.com>
commit 9c39b7a905d84b7da5f59d80f2e455853fea7217
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.21.1.el8_8/9c39b7a9.failed

When __blkcg_rstat_flush() is called from cgroup_rstat_flush*() code
path, interrupt is always disabled.

When we start to flush blkcg per-cpu stats list in __blkg_release()
for avoiding to leak blkcg_gq's reference in commit 20cb1c2fb756
("blk-cgroup: Flush stats before releasing blkcg_gq"), local irq
isn't disabled yet, then lockdep warning may be triggered because
the dependent cgroup locks may be acquired from irq(soft irq) handler.

Fix the issue by disabling local irq always.

Fixes: 20cb1c2fb756 ("blk-cgroup: Flush stats before releasing blkcg_gq")
	Reported-by: Shinichiro Kawasaki <shinichiro.kawasaki@wdc.com>
Closes: https://lore.kernel.org/linux-block/pz2wzwnmn5tk3pwpskmjhli6g3qly7eoknilb26of376c7kwxy@qydzpvt6zpis/T/#u
	Cc: stable@vger.kernel.org
	Cc: Jay Shin <jaeshin@redhat.com>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Waiman Long <longman@redhat.com>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Waiman Long <longman@redhat.com>
Link: https://lore.kernel.org/r/20230622084249.1208005-1-ming.lei@redhat.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9c39b7a905d84b7da5f59d80f2e455853fea7217)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-cgroup.c
diff --cc block/blk-cgroup.c
index 36ee546380a3,dce1548a7a0c..000000000000
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@@ -839,11 -970,8 +839,12 @@@ static void blkcg_rstat_flush(struct cg
  	struct llist_head *lhead = per_cpu_ptr(blkcg->lhead, cpu);
  	struct llist_node *lnode;
  	struct blkg_iostat_set *bisc, *next_bisc;
+ 	unsigned long flags;
  
 +	/* Root-level stats are sourced from system-wide IO stats */
 +	if (!cgroup_parent(css->cgroup))
 +		return;
 +
  	rcu_read_lock();
  
  	lnode = llist_del_all(lhead);
@@@ -851,6 -979,14 +852,17 @@@
  		goto out;
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * For covering concurrent parent blkg update from blkg_release().
+ 	 *
+ 	 * When flushing from cgroup, cgroup_rstat_lock is always held, so
+ 	 * this lock won't cause contention most of time.
+ 	 */
+ 	raw_spin_lock_irqsave(&blkg_stat_lock, flags);
+ 
+ 	/*
++>>>>>>> 9c39b7a905d8 (block: make sure local irq is disabled when calling __blkcg_rstat_flush)
  	 * Iterate only the iostat_cpu's queued in the lockless list.
  	 */
  	llist_for_each_entry_safe(bisc, next_bisc, lnode, lnode) {
@@@ -873,9 -1009,8 +885,13 @@@
  		if (parent && parent->parent)
  			blkcg_iostat_update(parent, &blkg->iostat.cur,
  					    &blkg->iostat.last);
 +		percpu_ref_put(&blkg->refcnt);
  	}
++<<<<<<< HEAD
 +
++=======
+ 	raw_spin_unlock_irqrestore(&blkg_stat_lock, flags);
++>>>>>>> 9c39b7a905d8 (block: make sure local irq is disabled when calling __blkcg_rstat_flush)
  out:
  	rcu_read_unlock();
  }
* Unmerged path block/blk-cgroup.c
