iomap: constify iomap_iter_srcmap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-477.21.1.el8_8
commit-author Christoph Hellwig <hch@lst.de>
commit fad0a1ab34f777bd8a95c6cebd70ee899b6e159e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-477.21.1.el8_8/fad0a1ab.failed

The srcmap returned from iomap_iter_srcmap is never modified, so mark
the iomap returned from it const and constify a lot of code that never
modifies the iomap.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
(cherry picked from commit fad0a1ab34f777bd8a95c6cebd70ee899b6e159e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/buffered-io.c
diff --cc fs/iomap/buffered-io.c
index a9fecbda715a,9cc5798423d1..000000000000
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@@ -222,10 -205,11 +222,18 @@@ struct iomap_readpage_ctx 
  	struct readahead_control *rac;
  };
  
++<<<<<<< HEAD
 +static loff_t iomap_read_inline_data(struct inode *inode, struct page *page,
 +		const struct iomap *iomap)
 +{
 +	size_t size = i_size_read(inode) - iomap->offset;
++=======
+ static loff_t iomap_read_inline_data(const struct iomap_iter *iter,
+ 		struct page *page)
+ {
+ 	const struct iomap *iomap = iomap_iter_srcmap(iter);
+ 	size_t size = i_size_read(iter->inode) - iomap->offset;
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  	size_t poff = offset_in_page(iomap->offset);
  	void *addr;
  
@@@ -248,22 -234,24 +256,41 @@@
  	return PAGE_SIZE - poff;
  }
  
++<<<<<<< HEAD
 +static inline bool iomap_block_needs_zeroing(struct inode *inode,
 +		struct iomap *iomap, loff_t pos)
 +{
 +	return iomap->type != IOMAP_MAPPED ||
 +		(iomap->flags & IOMAP_F_NEW) ||
 +		pos >= i_size_read(inode);
 +}
 +
 +static loff_t
 +iomap_readpage_actor(struct inode *inode, loff_t pos, loff_t length, void *data,
 +		struct iomap *iomap, struct iomap *srcmap)
 +{
 +	struct iomap_readpage_ctx *ctx = data;
++=======
+ static inline bool iomap_block_needs_zeroing(const struct iomap_iter *iter,
+ 		loff_t pos)
+ {
+ 	const struct iomap *srcmap = iomap_iter_srcmap(iter);
+ 
+ 	return srcmap->type != IOMAP_MAPPED ||
+ 		(srcmap->flags & IOMAP_F_NEW) ||
+ 		pos >= i_size_read(iter->inode);
+ }
+ 
+ static loff_t iomap_readpage_iter(const struct iomap_iter *iter,
+ 		struct iomap_readpage_ctx *ctx, loff_t offset)
+ {
+ 	const struct iomap *iomap = &iter->iomap;
+ 	loff_t pos = iter->pos + offset;
+ 	loff_t length = iomap_length(iter) - offset;
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  	struct page *page = ctx->cur_page;
  	struct iomap_page *iop;
 +	bool is_contig = false;
  	loff_t orig_pos = pos;
  	unsigned poff, plen;
  	sector_t sector;
@@@ -378,11 -352,10 +405,16 @@@ iomap_readpage(struct page *page, cons
  }
  EXPORT_SYMBOL_GPL(iomap_readpage);
  
++<<<<<<< HEAD
 +static loff_t
 +iomap_readahead_actor(struct inode *inode, loff_t pos, loff_t length,
 +		void *data, struct iomap *iomap, struct iomap *srcmap)
++=======
+ static loff_t iomap_readahead_iter(const struct iomap_iter *iter,
+ 		struct iomap_readpage_ctx *ctx)
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  {
 -	loff_t length = iomap_length(iter);
 +	struct iomap_readpage_ctx *ctx = data;
  	loff_t done, ret;
  
  	for (done = 0; done < length; done += ret) {
@@@ -581,12 -536,12 +613,21 @@@ iomap_read_page_sync(loff_t block_start
  	return submit_bio_wait(&bio);
  }
  
++<<<<<<< HEAD
 +static int
 +__iomap_write_begin(struct inode *inode, loff_t pos, unsigned len, int flags,
 +		struct page *page, struct iomap *srcmap)
 +{
 +	struct iomap_page *iop = iomap_page_create(inode, page);
 +	loff_t block_size = i_blocksize(inode);
++=======
+ static int __iomap_write_begin(const struct iomap_iter *iter, loff_t pos,
+ 		unsigned len, struct page *page)
+ {
+ 	const struct iomap *srcmap = iomap_iter_srcmap(iter);
+ 	struct iomap_page *iop = iomap_page_create(iter->inode, page);
+ 	loff_t block_size = i_blocksize(iter->inode);
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  	loff_t block_start = round_down(pos, block_size);
  	loff_t block_end = round_up(pos + len, block_size);
  	unsigned from = offset_in_page(pos), to = from + len, poff, plen;
@@@ -622,21 -577,8 +663,26 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void __iomap_put_folio(struct iomap *iomap, struct inode *inode,
 +			      loff_t pos, size_t ret, struct page *page)
 +{
 +	const struct iomap_page_ops *page_ops = iomap->page_ops;
 +
 +	if (page_ops && page_ops->page_done)
 +		page_ops->page_done(inode, pos, ret, page);
 +	else if (page) {
 +		unlock_page(page);
 +		put_page(page);
 +	}
 +}
 +
 +static int iomap_write_begin_inline(struct inode *inode,
 +		struct page *page, struct iomap *srcmap)
++=======
+ static int iomap_write_begin_inline(const struct iomap_iter *iter,
+ 		struct page *page)
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  {
  	int ret;
  
@@@ -649,11 -591,11 +695,19 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +iomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,
 +		struct page **pagep, struct iomap *iomap, struct iomap *srcmap)
 +{
 +	const struct iomap_page_ops *page_ops = iomap->page_ops;
++=======
+ static int iomap_write_begin(const struct iomap_iter *iter, loff_t pos,
+ 		unsigned len, struct page **pagep)
+ {
+ 	const struct iomap_page_ops *page_ops = iter->iomap.page_ops;
+ 	const struct iomap *srcmap = iomap_iter_srcmap(iter);
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  	struct page *page;
  	int status = 0;
  
@@@ -747,9 -666,10 +801,16 @@@ static size_t __iomap_write_end(struct 
  	return copied;
  }
  
++<<<<<<< HEAD
 +static size_t iomap_write_end_inline(struct inode *inode, struct page *page,
 +		struct iomap *iomap, loff_t pos, size_t copied)
 +{
++=======
+ static size_t iomap_write_end_inline(const struct iomap_iter *iter,
+ 		struct page *page, loff_t pos, size_t copied)
+ {
+ 	const struct iomap *iomap = &iter->iomap;
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  	void *addr;
  
  	WARN_ON_ONCE(!PageUptodate(page));
@@@ -765,11 -685,12 +826,17 @@@
  }
  
  /* Returns the number of bytes copied.  May be 0.  Cannot be an errno. */
 -static size_t iomap_write_end(struct iomap_iter *iter, loff_t pos, size_t len,
 -		size_t copied, struct page *page)
 +static size_t iomap_write_end(struct inode *inode, loff_t pos, size_t len,
 +		size_t copied, struct page *page, struct iomap *iomap,
 +		struct iomap *srcmap)
  {
++<<<<<<< HEAD
 +	loff_t old_size = inode->i_size;
++=======
+ 	const struct iomap_page_ops *page_ops = iter->iomap.page_ops;
+ 	const struct iomap *srcmap = iomap_iter_srcmap(iter);
+ 	loff_t old_size = iter->inode->i_size;
++>>>>>>> fad0a1ab34f7 (iomap: constify iomap_iter_srcmap)
  	size_t ret;
  
  	if (srcmap->type == IOMAP_INLINE) {
* Unmerged path fs/iomap/buffered-io.c
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 293e72d14e21..b6e657df3fd1 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -217,7 +217,7 @@ static inline u64 iomap_length(const struct iomap_iter *iter)
  * for a given operation, which may or may no be identical to the destination
  * map in &i->iomap.
  */
-static inline struct iomap *iomap_iter_srcmap(struct iomap_iter *i)
+static inline const struct iomap *iomap_iter_srcmap(const struct iomap_iter *i)
 {
 	if (i->srcmap.type != IOMAP_HOLE)
 		return &i->srcmap;
