ice: switch: convert packet template match code to rodata

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.10.1.el8_7
commit-author Alexander Lobakin <alexandr.lobakin@intel.com>
commit e33163a40d1a1f7fead2ce26f9b75da6b581a49e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.10.1.el8_7/e33163a4.failed

Trade text size for rodata size and replace tons of nested if-elses
to the const mask match based structs. The almost entire
ice_find_dummy_packet() now becomes just one plain while-increment
loop. The order in ice_dummy_pkt_profiles[] should be same with the
if-elses order previously, as masks become less and less strict
through the array to follow the original code flow.
Apart from removing 80 locs of 4-level if-elses, it brings a solid
text size optimization:

add/remove: 0/1 grow/shrink: 1/1 up/down: 2/-1058 (-1056)
Function                                     old     new   delta
ice_fill_adv_dummy_packet                    289     291      +2
ice_adv_add_update_vsi_list                  201       -    -201
ice_add_adv_rule                            2950    2093    -857
Total: Before=414512, After=413456, chg -0.25%
add/remove: 53/52 grow/shrink: 0/0 up/down: 4660/-3988 (672)
RO Data                                      old     new   delta
ice_dummy_pkt_profiles                         -     672    +672
Total: Before=37895, After=38567, chg +1.77%

	Signed-off-by: Alexander Lobakin <alexandr.lobakin@intel.com>
	Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Tested-by: Marcin Szycik <marcin.szycik@linux.intel.com>
	Tested-by: Sandeep Penigalapati <sandeep.penigalapati@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit e33163a40d1a1f7fead2ce26f9b75da6b581a49e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_switch.c
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 309bf07c29ba,496250f9f8fc..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -35,7 -48,28 +48,32 @@@ struct ice_dummy_pkt_offsets 
  	u16 offset; /* ICE_PROTOCOL_LAST indicates end of list */
  };
  
++<<<<<<< HEAD
 +static const struct ice_dummy_pkt_offsets dummy_gre_tcp_packet_offsets[] = {
++=======
+ struct ice_dummy_pkt_profile {
+ 	const struct ice_dummy_pkt_offsets *offsets;
+ 	const u8 *pkt;
+ 	u32 match;
+ 	u16 pkt_len;
+ };
+ 
+ #define ICE_DECLARE_PKT_OFFSETS(type)				\
+ 	static const struct ice_dummy_pkt_offsets		\
+ 	ice_dummy_##type##_packet_offsets[]
+ 
+ #define ICE_DECLARE_PKT_TEMPLATE(type)				\
+ 	static const u8 ice_dummy_##type##_packet[]
+ 
+ #define ICE_PKT_PROFILE(type, m) {				\
+ 	.match		= (m),					\
+ 	.pkt		= ice_dummy_##type##_packet,		\
+ 	.pkt_len	= sizeof(ice_dummy_##type##_packet),	\
+ 	.offsets	= ice_dummy_##type##_packet_offsets,	\
+ }
+ 
+ ICE_DECLARE_PKT_OFFSETS(gre_tcp) = {
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  	{ ICE_MAC_OFOS,		0 },
  	{ ICE_ETYPE_OL,		12 },
  	{ ICE_IPV4_OFOS,	14 },
@@@ -726,6 -754,534 +764,537 @@@ static const u8 dummy_vlan_udp_ipv6_pac
  	0x00, 0x00, /* 2 bytes for 4 byte alignment */
  };
  
++<<<<<<< HEAD
++=======
+ /* Outer IPv4 + Outer UDP + GTP + Inner IPv4 + Inner TCP */
+ ICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4_tcp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV4_IL,		62 },
+ 	{ ICE_TCP_IL,		82 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv4_tcp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x58, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x44, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x34, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x28, /* IP 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 82 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ /* Outer IPv4 + Outer UDP + GTP + Inner IPv4 + Inner UDP */
+ ICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4_udp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV4_IL,		62 },
+ 	{ ICE_UDP_ILOS,		82 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv4_udp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x4c, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x38, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x28, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x1c, /* IP 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 82 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ /* Outer IPv6 + Outer UDP + GTP + Inner IPv4 + Inner TCP */
+ ICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv6_tcp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV6_IL,		62 },
+ 	{ ICE_TCP_IL,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv6_tcp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x6c, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x58, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x48, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 62 */
+ 	0x00, 0x14, 0x06, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 102 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv6_udp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV6_IL,		62 },
+ 	{ ICE_UDP_ILOS,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv6_udp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x60, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x4c, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x3c, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 62 */
+ 	0x00, 0x08, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 102 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv4_tcp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV4_IL,		82 },
+ 	{ ICE_TCP_IL,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv4_tcp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x44, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x44, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x34, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x28, /* IP 82 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 102 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv4_udp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV4_IL,		82 },
+ 	{ ICE_UDP_ILOS,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv4_udp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x38, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x38, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x28, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x1c, /* IP 82 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 102 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv6_tcp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV6_IL,		82 },
+ 	{ ICE_TCP_IL,		122 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv6_tcp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x58, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x58, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x48, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 82 */
+ 	0x00, 0x14, 0x06, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 122 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv6_gtpu_ipv6_udp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV6_IL,		82 },
+ 	{ ICE_UDP_ILOS,		122 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv6_gtpu_ipv6_udp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x4c, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x4c, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x3c, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 82 */
+ 	0x00, 0x08, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 122 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv4_gtpu_ipv4) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP_NO_PAY,	42 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv4_gtpu_ipv4) = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x44, /* ICE_IPV4_OFOS 14 */
+ 	0x00, 0x00, 0x40, 0x00,
+ 	0x40, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x68, 0x08, 0x68, /* ICE_UDP_OF 34 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x28, /* ICE_GTP 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* PDU Session extension header */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x14, /* ICE_IPV4_IL 62 */
+ 	0x00, 0x00, 0x40, 0x00,
+ 	0x40, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00,
+ };
+ 
+ ICE_DECLARE_PKT_OFFSETS(ipv6_gtp) = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP_NO_PAY,	62 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ ICE_DECLARE_PKT_TEMPLATE(ipv6_gtp) = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* ICE_IPV6_OFOS 14 */
+ 	0x00, 0x6c, 0x11, 0x00, /* Next header UDP*/
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x68, 0x08, 0x68, /* ICE_UDP_OF 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x30, 0x00, 0x00, 0x28, /* ICE_GTP 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00,
+ };
+ 
+ static const struct ice_dummy_pkt_profile ice_dummy_pkt_profiles[] = {
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPU | ICE_PKT_OUTER_IPV6 |
+ 				  ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv6_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPU | ICE_PKT_GTP_NOPAY),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6 |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv6_tcp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_udp, ICE_PKT_TUN_GTPU |
+ 					    ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4_tcp, ICE_PKT_TUN_GTPU),
+ 	ICE_PKT_PROFILE(ipv6_gtp, ICE_PKT_TUN_GTPC | ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(ipv4_gtpu_ipv4, ICE_PKT_TUN_GTPC),
+ 	ICE_PKT_PROFILE(gre_ipv6_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6 |
+ 				      ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_tcp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(gre_ipv6_udp, ICE_PKT_TUN_NVGRE | ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(gre_udp, ICE_PKT_TUN_NVGRE),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_tcp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6 |
+ 					  ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_tcp, ICE_PKT_TUN_UDP | ICE_PKT_INNER_TCP),
+ 	ICE_PKT_PROFILE(udp_tun_ipv6_udp, ICE_PKT_TUN_UDP |
+ 					  ICE_PKT_INNER_IPV6),
+ 	ICE_PKT_PROFILE(udp_tun_udp, ICE_PKT_TUN_UDP),
+ 	ICE_PKT_PROFILE(vlan_udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP |
+ 				       ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(udp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(vlan_udp, ICE_PKT_INNER_UDP | ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(udp, ICE_PKT_INNER_UDP),
+ 	ICE_PKT_PROFILE(vlan_tcp_ipv6, ICE_PKT_OUTER_IPV6 | ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(tcp_ipv6, ICE_PKT_OUTER_IPV6),
+ 	ICE_PKT_PROFILE(vlan_tcp, ICE_PKT_VLAN),
+ 	ICE_PKT_PROFILE(tcp, 0),
+ };
+ 
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  #define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE \
  	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr) + \
  	 (DUMMY_ETH_HDR_LEN * \
@@@ -5013,138 -5568,66 +5582,191 @@@ err_free_lkup_exts
   *	   structure per protocol header
   * @lkups_cnt: number of protocols
   * @tun_type: tunnel type
 - *
 - * Returns the &ice_dummy_pkt_profile corresponding to these lookup params.
 + * @pkt: dummy packet to fill according to filter match criteria
 + * @pkt_len: packet length of dummy packet
 + * @offsets: pointer to receive the pointer to the offsets for the packet
   */
++<<<<<<< HEAD
 +static void
++=======
+ static const struct ice_dummy_pkt_profile *
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  ice_find_dummy_packet(struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,
 -		      enum ice_sw_tunnel_type tun_type)
 +		      enum ice_sw_tunnel_type tun_type,
 +		      const u8 **pkt, u16 *pkt_len,
 +		      const struct ice_dummy_pkt_offsets **offsets)
  {
++<<<<<<< HEAD
 +	bool tcp = false, udp = false, ipv6 = false, vlan = false;
 +	bool ipv6_il = false;
++=======
+ 	const struct ice_dummy_pkt_profile *ret = ice_dummy_pkt_profiles;
+ 	u32 match = 0;
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  	u16 i;
  
+ 	switch (tun_type) {
+ 	case ICE_SW_TUN_GTPC:
+ 		match |= ICE_PKT_TUN_GTPC;
+ 		break;
+ 	case ICE_SW_TUN_GTPU:
+ 		match |= ICE_PKT_TUN_GTPU;
+ 		break;
+ 	case ICE_SW_TUN_NVGRE:
+ 		match |= ICE_PKT_TUN_NVGRE;
+ 		break;
+ 	case ICE_SW_TUN_GENEVE:
+ 	case ICE_SW_TUN_VXLAN:
+ 		match |= ICE_PKT_TUN_UDP;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
  	for (i = 0; i < lkups_cnt; i++) {
  		if (lkups[i].type == ICE_UDP_ILOS)
++<<<<<<< HEAD
 +			udp = true;
 +		else if (lkups[i].type == ICE_TCP_IL)
 +			tcp = true;
 +		else if (lkups[i].type == ICE_IPV6_OFOS)
 +			ipv6 = true;
++=======
+ 			match |= ICE_PKT_INNER_UDP;
+ 		else if (lkups[i].type == ICE_TCP_IL)
+ 			match |= ICE_PKT_INNER_TCP;
+ 		else if (lkups[i].type == ICE_IPV6_OFOS)
+ 			match |= ICE_PKT_OUTER_IPV6;
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  		else if (lkups[i].type == ICE_VLAN_OFOS)
- 			vlan = true;
+ 			match |= ICE_PKT_VLAN;
  		else if (lkups[i].type == ICE_ETYPE_OL &&
  			 lkups[i].h_u.ethertype.ethtype_id ==
  				cpu_to_be16(ICE_IPV6_ETHER_ID) &&
  			 lkups[i].m_u.ethertype.ethtype_id ==
  				cpu_to_be16(0xFFFF))
++<<<<<<< HEAD
 +			ipv6 = true;
++=======
+ 			match |= ICE_PKT_OUTER_IPV6;
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  		else if (lkups[i].type == ICE_ETYPE_IL &&
  			 lkups[i].h_u.ethertype.ethtype_id ==
  				cpu_to_be16(ICE_IPV6_ETHER_ID) &&
  			 lkups[i].m_u.ethertype.ethtype_id ==
  				cpu_to_be16(0xFFFF))
++<<<<<<< HEAD
 +			ipv6_il = true;
 +	}
 +
 +	if (tun_type == ICE_SW_TUN_NVGRE) {
 +		if (tcp && ipv6_il) {
 +			*pkt = dummy_gre_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_tcp_packet);
 +			*offsets = dummy_gre_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (tcp) {
 +			*pkt = dummy_gre_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_tcp_packet);
 +			*offsets = dummy_gre_tcp_packet_offsets;
 +			return;
 +		}
 +		if (ipv6_il) {
 +			*pkt = dummy_gre_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_udp_packet);
 +			*offsets = dummy_gre_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_gre_udp_packet;
 +		*pkt_len = sizeof(dummy_gre_udp_packet);
 +		*offsets = dummy_gre_udp_packet_offsets;
 +		return;
 +	}
 +
 +	if (tun_type == ICE_SW_TUN_VXLAN ||
 +	    tun_type == ICE_SW_TUN_GENEVE) {
 +		if (tcp && ipv6_il) {
 +			*pkt = dummy_udp_tun_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_tcp_packet);
 +			*offsets = dummy_udp_tun_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (tcp) {
 +			*pkt = dummy_udp_tun_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_tcp_packet);
 +			*offsets = dummy_udp_tun_tcp_packet_offsets;
 +			return;
 +		}
 +		if (ipv6_il) {
 +			*pkt = dummy_udp_tun_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_udp_packet);
 +			*offsets = dummy_udp_tun_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_tun_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_tun_udp_packet);
 +		*offsets = dummy_udp_tun_udp_packet_offsets;
 +		return;
 +	}
 +
 +	if (udp && !ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_packet);
 +			*offsets = dummy_vlan_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_packet);
 +		*offsets = dummy_udp_packet_offsets;
 +		return;
 +	} else if (udp && ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_ipv6_packet);
 +			*offsets = dummy_vlan_udp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_udp_ipv6_packet);
 +		*offsets = dummy_udp_ipv6_packet_offsets;
 +		return;
 +	} else if ((tcp && ipv6) || ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_tcp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_tcp_ipv6_packet);
 +			*offsets = dummy_vlan_tcp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_tcp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_tcp_ipv6_packet);
 +		*offsets = dummy_tcp_ipv6_packet_offsets;
 +		return;
 +	}
 +
 +	if (vlan) {
 +		*pkt = dummy_vlan_tcp_packet;
 +		*pkt_len = sizeof(dummy_vlan_tcp_packet);
 +		*offsets = dummy_vlan_tcp_packet_offsets;
 +	} else {
 +		*pkt = dummy_tcp_packet;
 +		*pkt_len = sizeof(dummy_tcp_packet);
 +		*offsets = dummy_tcp_packet_offsets;
 +	}
++=======
+ 			match |= ICE_PKT_INNER_IPV6;
+ 		else if (lkups[i].type == ICE_IPV6_IL)
+ 			match |= ICE_PKT_INNER_IPV6;
+ 		else if (lkups[i].type == ICE_GTP_NO_PAY)
+ 			match |= ICE_PKT_GTP_NOPAY;
+ 	}
+ 
+ 	while (ret->match && (match & ret->match) != ret->match)
+ 		ret++;
+ 
+ 	return ret;
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  }
  
  /**
@@@ -5478,12 -5963,11 +6100,17 @@@ ice_add_adv_rule(struct ice_hw *hw, str
  		 struct ice_rule_query_data *added_entry)
  {
  	struct ice_adv_fltr_mgmt_list_entry *m_entry, *adv_fltr = NULL;
 +	u16 rid = 0, i, pkt_len, rule_buf_sz, vsi_handle;
 +	const struct ice_dummy_pkt_offsets *pkt_offsets;
  	struct ice_aqc_sw_rules_elem *s_rule = NULL;
++<<<<<<< HEAD
++=======
+ 	const struct ice_dummy_pkt_profile *profile;
+ 	u16 rid = 0, i, rule_buf_sz, vsi_handle;
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  	struct list_head *rule_head;
  	struct ice_switch_info *sw;
 +	const u8 *pkt = NULL;
  	u16 word_cnt;
  	u32 act = 0;
  	int status;
@@@ -5558,7 -6037,7 +6185,11 @@@
  		}
  		return status;
  	}
++<<<<<<< HEAD
 +	rule_buf_sz = ICE_SW_RULE_RX_TX_NO_HDR_SIZE + pkt_len;
++=======
+ 	rule_buf_sz = ICE_SW_RULE_RX_TX_NO_HDR_SIZE + profile->pkt_len;
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  	s_rule = kzalloc(rule_buf_sz, GFP_KERNEL);
  	if (!s_rule)
  		return -ENOMEM;
@@@ -5618,8 -6097,7 +6249,12 @@@
  	s_rule->pdata.lkup_tx_rx.recipe_id = cpu_to_le16(rid);
  	s_rule->pdata.lkup_tx_rx.act = cpu_to_le32(act);
  
++<<<<<<< HEAD
 +	status = ice_fill_adv_dummy_packet(lkups, lkups_cnt, s_rule, pkt,
 +					   pkt_len, pkt_offsets);
++=======
+ 	status = ice_fill_adv_dummy_packet(lkups, lkups_cnt, s_rule, profile);
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  	if (status)
  		goto err_ice_add_adv_rule;
  
@@@ -5627,7 -6105,7 +6262,11 @@@
  	    rinfo->tun_type != ICE_SW_TUN_AND_NON_TUN) {
  		status = ice_fill_adv_packet_tun(hw, rinfo->tun_type,
  						 s_rule->pdata.lkup_tx_rx.hdr,
++<<<<<<< HEAD
 +						 pkt_offsets);
++=======
+ 						 profile->offsets);
++>>>>>>> e33163a40d1a (ice: switch: convert packet template match code to rodata)
  		if (status)
  			goto err_ice_add_adv_rule;
  	}
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
