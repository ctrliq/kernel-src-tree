vfio/type1: Unpin zero pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.10.1.el8_7
commit-author Alex Williamson <alex.williamson@redhat.com>
commit 873aefb376bbc0ed1dd2381ea1d6ec88106fdbd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.10.1.el8_7/873aefb3.failed

There's currently a reference count leak on the zero page.  We increment
the reference via pin_user_pages_remote(), but the page is later handled
as an invalid/reserved page, therefore it's not accounted against the
user and not unpinned by our put_pfn().

Introducing special zero page handling in put_pfn() would resolve the
leak, but without accounting of the zero page, a single user could
still create enough mappings to generate a reference count overflow.

The zero page is always resident, so for our purposes there's no reason
to keep it pinned.  Therefore, add a loop to walk pages returned from
pin_user_pages_remote() and unpin any zero pages.

	Cc: stable@vger.kernel.org
	Reported-by: Luboslav Pivarc <lpivarc@redhat.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
Link: https://lore.kernel.org/r/166182871735.3518559.8884121293045337358.stgit@omen
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit 873aefb376bbc0ed1dd2381ea1d6ec88106fdbd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio_iommu_type1.c
diff --cc drivers/vfio/vfio_iommu_type1.c
index ac0224f7c47f,8706482665d1..000000000000
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@@ -467,11 -555,22 +467,30 @@@ static int vaddr_get_pfn(struct mm_stru
  		flags |= FOLL_WRITE;
  
  	mmap_read_lock(mm);
++<<<<<<< HEAD
 +	ret = pin_user_pages_remote(NULL, mm, vaddr, 1, flags | FOLL_LONGTERM,
 +				    page, NULL, NULL);
 +	if (ret == 1) {
 +		*pfn = page_to_pfn(page[0]);
 +		ret = 0;
++=======
+ 	ret = pin_user_pages_remote(mm, vaddr, npages, flags | FOLL_LONGTERM,
+ 				    pages, NULL, NULL);
+ 	if (ret > 0) {
+ 		int i;
+ 
+ 		/*
+ 		 * The zero page is always resident, we don't need to pin it
+ 		 * and it falls into our invalid/reserved test so we don't
+ 		 * unpin in put_pfn().  Unpin all zero pages in the batch here.
+ 		 */
+ 		for (i = 0 ; i < ret; i++) {
+ 			if (unlikely(is_zero_pfn(page_to_pfn(pages[i]))))
+ 				unpin_user_page(pages[i]);
+ 		}
+ 
+ 		*pfn = page_to_pfn(pages[0]);
++>>>>>>> 873aefb376bb (vfio/type1: Unpin zero pages)
  		goto done;
  	}
  
* Unmerged path drivers/vfio/vfio_iommu_type1.c
