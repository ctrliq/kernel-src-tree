ice: switch: use a struct to pass packet template params

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.10.1.el8_7
commit-author Alexander Lobakin <alexandr.lobakin@intel.com>
commit 1b699f81dba78c724f6f94b02f01e216b64bf88b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.10.1.el8_7/1b699f81.failed

ice_find_dummy_packet() contains a lot of boilerplate code and a
nice room for copy-paste mistakes.
Instead of passing 3 separate pointers back and forth to get packet
template (dummy) params, directly return a structure containing
them. Then, use a macro to compose compound literals and avoid code
duplication on return path.
Now, dummy packet type/name is needed only once to return a full
correct triple pkt-pkt_len-offsets, and those are all one-liners.
dummy_ipv4_gtpu_ipv4_packet_offsets is just moved around and renamed
(as well as dummy_ipv6_gtp_packet_offsets) with no function changes.

	Signed-off-by: Alexander Lobakin <alexandr.lobakin@intel.com>
	Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
	Tested-by: Marcin Szycik <marcin.szycik@linux.intel.com>
	Tested-by: Sandeep Penigalapati <sandeep.penigalapati@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 1b699f81dba78c724f6f94b02f01e216b64bf88b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_switch.c
diff --cc drivers/net/ethernet/intel/ice/ice_switch.c
index 309bf07c29ba,4697eb8b4c66..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@@ -726,6 -740,495 +740,498 @@@ static const u8 dummy_vlan_udp_ipv6_pac
  	0x00, 0x00, /* 2 bytes for 4 byte alignment */
  };
  
++<<<<<<< HEAD
++=======
+ /* Outer IPv4 + Outer UDP + GTP + Inner IPv4 + Inner TCP */
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv4_gtpu_ipv4_tcp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV4_IL,		62 },
+ 	{ ICE_TCP_IL,		82 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv4_gtpu_ipv4_tcp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x58, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x44, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x34, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x28, /* IP 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 82 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ /* Outer IPv4 + Outer UDP + GTP + Inner IPv4 + Inner UDP */
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv4_gtpu_ipv4_udp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV4_IL,		62 },
+ 	{ ICE_UDP_ILOS,		82 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv4_gtpu_ipv4_udp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x4c, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x38, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x28, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x1c, /* IP 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 82 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ /* Outer IPv6 + Outer UDP + GTP + Inner IPv4 + Inner TCP */
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv4_gtpu_ipv6_tcp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV6_IL,		62 },
+ 	{ ICE_TCP_IL,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv4_gtpu_ipv6_tcp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x6c, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x58, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x48, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 62 */
+ 	0x00, 0x14, 0x06, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 102 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv4_gtpu_ipv6_udp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP,		42 },
+ 	{ ICE_IPV6_IL,		62 },
+ 	{ ICE_UDP_ILOS,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv4_gtpu_ipv6_udp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x60, /* IP 14 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 34 */
+ 	0x00, 0x4c, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x3c, /* ICE_GTP Header 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 62 */
+ 	0x00, 0x08, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 102 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv6_gtpu_ipv4_tcp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV4_IL,		82 },
+ 	{ ICE_TCP_IL,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv6_gtpu_ipv4_tcp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x44, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x44, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x34, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x28, /* IP 82 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x06, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 102 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv6_gtpu_ipv4_udp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV4_IL,		82 },
+ 	{ ICE_UDP_ILOS,		102 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv6_gtpu_ipv4_udp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x38, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x38, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x28, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x1c, /* IP 82 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 102 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv6_gtpu_ipv6_tcp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV6_IL,		82 },
+ 	{ ICE_TCP_IL,		122 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv6_gtpu_ipv6_tcp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x58, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x58, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x48, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 82 */
+ 	0x00, 0x14, 0x06, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* TCP 122 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x50, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv6_gtpu_ipv6_udp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP,		62 },
+ 	{ ICE_IPV6_IL,		82 },
+ 	{ ICE_UDP_ILOS,		122 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv6_gtpu_ipv6_udp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* Ethernet 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 14 */
+ 	0x00, 0x4c, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x08, 0x68, /* UDP 54 */
+ 	0x00, 0x4c, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x3c, /* ICE_GTP Header 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* GTP_PDUSession_ExtensionHeader 74 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* IPv6 82 */
+ 	0x00, 0x08, 0x11, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00, 0x00, 0x00, /* UDP 122 */
+ 	0x00, 0x08, 0x00, 0x00,
+ 
+ 	0x00, 0x00, /* 2 bytes for 4 byte alignment */
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv4_gtpu_ipv4_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV4_OFOS,	14 },
+ 	{ ICE_UDP_OF,		34 },
+ 	{ ICE_GTP_NO_PAY,	42 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv4_gtpu_ipv4_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x08, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x44, /* ICE_IPV4_OFOS 14 */
+ 	0x00, 0x00, 0x40, 0x00,
+ 	0x40, 0x11, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x68, 0x08, 0x68, /* ICE_UDP_OF 34 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x34, 0xff, 0x00, 0x28, /* ICE_GTP 42 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x85,
+ 
+ 	0x02, 0x00, 0x00, 0x00, /* PDU Session extension header */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x45, 0x00, 0x00, 0x14, /* ICE_IPV4_IL 62 */
+ 	0x00, 0x00, 0x40, 0x00,
+ 	0x40, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00,
+ };
+ 
+ static const
+ struct ice_dummy_pkt_offsets dummy_ipv6_gtp_packet_offsets[] = {
+ 	{ ICE_MAC_OFOS,		0 },
+ 	{ ICE_IPV6_OFOS,	14 },
+ 	{ ICE_UDP_OF,		54 },
+ 	{ ICE_GTP_NO_PAY,	62 },
+ 	{ ICE_PROTOCOL_LAST,	0 },
+ };
+ 
+ static const u8 dummy_ipv6_gtp_packet[] = {
+ 	0x00, 0x00, 0x00, 0x00, /* ICE_MAC_OFOS 0 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x86, 0xdd,
+ 
+ 	0x60, 0x00, 0x00, 0x00, /* ICE_IPV6_OFOS 14 */
+ 	0x00, 0x6c, 0x11, 0x00, /* Next header UDP*/
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x08, 0x68, 0x08, 0x68, /* ICE_UDP_OF 54 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x30, 0x00, 0x00, 0x28, /* ICE_GTP 62 */
+ 	0x00, 0x00, 0x00, 0x00,
+ 
+ 	0x00, 0x00,
+ };
+ 
++>>>>>>> 1b699f81dba7 (ice: switch: use a struct to pass packet template params)
  #define ICE_SW_RULE_RX_TX_ETH_HDR_SIZE \
  	(offsetof(struct ice_aqc_sw_rules_elem, pdata.lkup_tx_rx.hdr) + \
  	 (DUMMY_ETH_HDR_LEN * \
@@@ -5013,18 -5515,15 +5519,15 @@@ err_free_lkup_exts
   *	   structure per protocol header
   * @lkups_cnt: number of protocols
   * @tun_type: tunnel type
-  * @pkt: dummy packet to fill according to filter match criteria
-  * @pkt_len: packet length of dummy packet
-  * @offsets: pointer to receive the pointer to the offsets for the packet
+  *
+  * Returns the &ice_dummy_pkt_profile corresponding to these lookup params.
   */
- static void
+ static struct ice_dummy_pkt_profile
  ice_find_dummy_packet(struct ice_adv_lkup_elem *lkups, u16 lkups_cnt,
- 		      enum ice_sw_tunnel_type tun_type,
- 		      const u8 **pkt, u16 *pkt_len,
- 		      const struct ice_dummy_pkt_offsets **offsets)
+ 		      enum ice_sw_tunnel_type tun_type)
  {
 -	bool inner_tcp = false, inner_udp = false, outer_ipv6 = false;
 -	bool vlan = false, inner_ipv6 = false, gtp_no_pay = false;
 +	bool tcp = false, udp = false, ipv6 = false, vlan = false;
 +	bool ipv6_il = false;
  	u16 i;
  
  	for (i = 0; i < lkups_cnt; i++) {
@@@ -5047,104 -5546,96 +5550,185 @@@
  				cpu_to_be16(ICE_IPV6_ETHER_ID) &&
  			 lkups[i].m_u.ethertype.ethtype_id ==
  				cpu_to_be16(0xFFFF))
++<<<<<<< HEAD
 +			ipv6_il = true;
 +	}
 +
 +	if (tun_type == ICE_SW_TUN_NVGRE) {
 +		if (tcp && ipv6_il) {
 +			*pkt = dummy_gre_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_tcp_packet);
 +			*offsets = dummy_gre_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (tcp) {
 +			*pkt = dummy_gre_tcp_packet;
 +			*pkt_len = sizeof(dummy_gre_tcp_packet);
 +			*offsets = dummy_gre_tcp_packet_offsets;
 +			return;
 +		}
 +		if (ipv6_il) {
 +			*pkt = dummy_gre_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_gre_ipv6_udp_packet);
 +			*offsets = dummy_gre_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_gre_udp_packet;
 +		*pkt_len = sizeof(dummy_gre_udp_packet);
 +		*offsets = dummy_gre_udp_packet_offsets;
 +		return;
++=======
+ 			inner_ipv6 = true;
+ 		else if (lkups[i].type == ICE_IPV6_IL)
+ 			inner_ipv6 = true;
+ 		else if (lkups[i].type == ICE_GTP_NO_PAY)
+ 			gtp_no_pay = true;
+ 	}
+ 
+ 	if (tun_type == ICE_SW_TUN_GTPU) {
+ 		if (outer_ipv6) {
+ 			if (gtp_no_pay) {
+ 				return ICE_PKT_PROFILE(ipv6_gtp);
+ 			} else if (inner_ipv6) {
+ 				if (inner_udp)
+ 					return ICE_PKT_PROFILE(ipv6_gtpu_ipv6_udp);
+ 				else
+ 					return ICE_PKT_PROFILE(ipv6_gtpu_ipv6_tcp);
+ 			} else {
+ 				if (inner_udp)
+ 					return ICE_PKT_PROFILE(ipv6_gtpu_ipv4_udp);
+ 				else
+ 					return ICE_PKT_PROFILE(ipv6_gtpu_ipv4_tcp);
+ 			}
+ 		} else {
+ 			if (gtp_no_pay) {
+ 				return ICE_PKT_PROFILE(ipv4_gtpu_ipv4);
+ 			} else if (inner_ipv6) {
+ 				if (inner_udp)
+ 					return ICE_PKT_PROFILE(ipv4_gtpu_ipv6_udp);
+ 				else
+ 					return ICE_PKT_PROFILE(ipv4_gtpu_ipv6_tcp);
+ 			} else {
+ 				if (inner_udp)
+ 					return ICE_PKT_PROFILE(ipv4_gtpu_ipv4_udp);
+ 				else
+ 					return ICE_PKT_PROFILE(ipv4_gtpu_ipv4_tcp);
+ 			}
+ 		}
+ 	}
+ 
+ 	if (tun_type == ICE_SW_TUN_GTPC) {
+ 		if (outer_ipv6)
+ 			return ICE_PKT_PROFILE(ipv6_gtp);
+ 		else
+ 			return ICE_PKT_PROFILE(ipv4_gtpu_ipv4);
+ 	}
+ 
+ 	if (tun_type == ICE_SW_TUN_NVGRE) {
+ 		if (inner_tcp && inner_ipv6)
+ 			return ICE_PKT_PROFILE(gre_ipv6_tcp);
+ 		else if (inner_tcp)
+ 			return ICE_PKT_PROFILE(gre_tcp);
+ 		else if (inner_ipv6)
+ 			return ICE_PKT_PROFILE(gre_ipv6_udp);
+ 		else
+ 			return ICE_PKT_PROFILE(gre_udp);
++>>>>>>> 1b699f81dba7 (ice: switch: use a struct to pass packet template params)
  	}
  
  	if (tun_type == ICE_SW_TUN_VXLAN ||
  	    tun_type == ICE_SW_TUN_GENEVE) {
++<<<<<<< HEAD
 +		if (tcp && ipv6_il) {
 +			*pkt = dummy_udp_tun_ipv6_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_tcp_packet);
 +			*offsets = dummy_udp_tun_ipv6_tcp_packet_offsets;
 +			return;
 +		}
 +		if (tcp) {
 +			*pkt = dummy_udp_tun_tcp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_tcp_packet);
 +			*offsets = dummy_udp_tun_tcp_packet_offsets;
 +			return;
 +		}
 +		if (ipv6_il) {
 +			*pkt = dummy_udp_tun_ipv6_udp_packet;
 +			*pkt_len = sizeof(dummy_udp_tun_ipv6_udp_packet);
 +			*offsets = dummy_udp_tun_ipv6_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_tun_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_tun_udp_packet);
 +		*offsets = dummy_udp_tun_udp_packet_offsets;
 +		return;
 +	}
 +
 +	if (udp && !ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_packet);
 +			*offsets = dummy_vlan_udp_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_packet;
 +		*pkt_len = sizeof(dummy_udp_packet);
 +		*offsets = dummy_udp_packet_offsets;
 +		return;
 +	} else if (udp && ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_udp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_udp_ipv6_packet);
 +			*offsets = dummy_vlan_udp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_udp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_udp_ipv6_packet);
 +		*offsets = dummy_udp_ipv6_packet_offsets;
 +		return;
 +	} else if ((tcp && ipv6) || ipv6) {
 +		if (vlan) {
 +			*pkt = dummy_vlan_tcp_ipv6_packet;
 +			*pkt_len = sizeof(dummy_vlan_tcp_ipv6_packet);
 +			*offsets = dummy_vlan_tcp_ipv6_packet_offsets;
 +			return;
 +		}
 +		*pkt = dummy_tcp_ipv6_packet;
 +		*pkt_len = sizeof(dummy_tcp_ipv6_packet);
 +		*offsets = dummy_tcp_ipv6_packet_offsets;
 +		return;
++=======
+ 		if (inner_tcp && inner_ipv6)
+ 			return ICE_PKT_PROFILE(udp_tun_ipv6_tcp);
+ 		else if (inner_tcp)
+ 			return ICE_PKT_PROFILE(udp_tun_tcp);
+ 		else if (inner_ipv6)
+ 			return ICE_PKT_PROFILE(udp_tun_ipv6_udp);
+ 		else
+ 			return ICE_PKT_PROFILE(udp_tun_udp);
  	}
  
- 	if (vlan) {
- 		*pkt = dummy_vlan_tcp_packet;
- 		*pkt_len = sizeof(dummy_vlan_tcp_packet);
- 		*offsets = dummy_vlan_tcp_packet_offsets;
- 	} else {
- 		*pkt = dummy_tcp_packet;
- 		*pkt_len = sizeof(dummy_tcp_packet);
- 		*offsets = dummy_tcp_packet_offsets;
+ 	if (inner_udp && !outer_ipv6) {
+ 		if (vlan)
+ 			return ICE_PKT_PROFILE(vlan_udp);
+ 		else
+ 			return ICE_PKT_PROFILE(udp);
+ 	} else if (inner_udp && outer_ipv6) {
+ 		if (vlan)
+ 			return ICE_PKT_PROFILE(vlan_udp_ipv6);
+ 		else
+ 			return ICE_PKT_PROFILE(udp_ipv6);
+ 	} else if ((inner_tcp && outer_ipv6) || outer_ipv6) {
+ 		if (vlan)
+ 			return ICE_PKT_PROFILE(vlan_tcp_ipv6);
+ 		else
+ 			return ICE_PKT_PROFILE(tcp_ipv6);
++>>>>>>> 1b699f81dba7 (ice: switch: use a struct to pass packet template params)
  	}
+ 
+ 	if (vlan)
+ 		return ICE_PKT_PROFILE(vlan_tcp);
+ 
+ 	return ICE_PKT_PROFILE(tcp);
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_switch.c
