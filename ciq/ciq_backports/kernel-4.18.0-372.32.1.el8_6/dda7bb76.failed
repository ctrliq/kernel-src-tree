x86/alternative: Support not-feature

jira LE-1907
cve CVE-2022-23825
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-4.18.0-372.32.1.el8_6
commit-author Juergen Gross <jgross@suse.com>
commit dda7bb76484978316bb412a353789ebc5901de36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.32.1.el8_6/dda7bb76.failed

Add support for alternative patching for the case a feature is not
present on the current CPU. For users of ALTERNATIVE() and friends, an
inverted feature is specified by applying the ALT_NOT() macro to it,
e.g.:

  ALTERNATIVE(old, new, ALT_NOT(feature));

Committer note:

The decision to encode the NOT-bit in the feature bit itself is because
a future change which would make objtool generate such alternative
calls, would keep the code in objtool itself fairly simple.

Also, this allows for the alternative macros to support the NOT feature
without having to change them.

Finally, the u16 cpuid member encoding the X86_FEATURE_ flags is not an
ABI so if more bits are needed, cpuid itself can be enlarged or a flags
field can be added to struct alt_instr after having considered the size
growth in either cases.

	Signed-off-by: Juergen Gross <jgross@suse.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210311142319.4723-6-jgross@suse.com
(cherry picked from commit dda7bb76484978316bb412a353789ebc5901de36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/alternative.h
#	arch/x86/kernel/alternative.c
diff --cc arch/x86/include/asm/alternative.h
index 0e1856c8f446,649e56f70889..000000000000
--- a/arch/x86/include/asm/alternative.h
+++ b/arch/x86/include/asm/alternative.h
@@@ -2,12 -2,16 +2,22 @@@
  #ifndef _ASM_X86_ALTERNATIVE_H
  #define _ASM_X86_ALTERNATIVE_H
  
++<<<<<<< HEAD
++=======
+ #include <linux/types.h>
+ #include <linux/stringify.h>
+ #include <asm/asm.h>
+ 
+ #define ALTINSTR_FLAG_INV	(1 << 15)
+ #define ALT_NOT(feat)		((feat) | ALTINSTR_FLAG_INV)
+ 
++>>>>>>> dda7bb764849 (x86/alternative: Support not-feature)
  #ifndef __ASSEMBLY__
  
 +#include <linux/types.h>
  #include <linux/stddef.h>
 +#include <linux/stringify.h>
 +#include <asm/asm.h>
  
  /*
   * Alternative inline assembly for SMP.
diff --cc arch/x86/kernel/alternative.c
index 4fce58044a3f,133b549dc091..000000000000
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@@ -380,13 -387,22 +380,32 @@@ void __init_or_module noinline apply_al
  	 * order.
  	 */
  	for (a = start; a < end; a++) {
++<<<<<<< HEAD
 +		int insnbuf_sz = 0;
 +
 +		instr = (u8 *)&a->instr_offset + a->instr_offset;
 +		replacement = (u8 *)&a->repl_offset + a->repl_offset;
 +		BUG_ON(a->instrlen > sizeof(insnbuf));
 +		BUG_ON(a->cpuid >= (NCAPINTS + NBUGINTS) * 32);
 +		if (!boot_cpu_has(a->cpuid)) {
++=======
+ 		int insn_buff_sz = 0;
+ 		/* Mask away "NOT" flag bit for feature to test. */
+ 		u16 feature = a->cpuid & ~ALTINSTR_FLAG_INV;
+ 
+ 		instr = (u8 *)&a->instr_offset + a->instr_offset;
+ 		replacement = (u8 *)&a->repl_offset + a->repl_offset;
+ 		BUG_ON(a->instrlen > sizeof(insn_buff));
+ 		BUG_ON(feature >= (NCAPINTS + NBUGINTS) * 32);
+ 
+ 		/*
+ 		 * Patch if either:
+ 		 * - feature is present
+ 		 * - feature not present but ALTINSTR_FLAG_INV is set to mean,
+ 		 *   patch if feature is *NOT* present.
+ 		 */
+ 		if (!boot_cpu_has(feature) == !(a->cpuid & ALTINSTR_FLAG_INV)) {
++>>>>>>> dda7bb764849 (x86/alternative: Support not-feature)
  			if (a->padlen > 1)
  				optimize_nops(a, instr);
  
* Unmerged path arch/x86/include/asm/alternative.h
* Unmerged path arch/x86/kernel/alternative.c
