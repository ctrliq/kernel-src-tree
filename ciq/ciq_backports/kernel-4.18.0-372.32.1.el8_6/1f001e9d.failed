x86/ftrace: Use alternative RET encoding

jira LE-1907
cve CVE-2022-23825
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-4.18.0-372.32.1.el8_6
commit-author Peter Zijlstra <peterz@infradead.org>
commit 1f001e9da6bbf482311e45e48f53c2bd2179e59c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.32.1.el8_6/1f001e9d.failed

Use the return thunk in ftrace trampolines, if needed.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 1f001e9da6bbf482311e45e48f53c2bd2179e59c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/ftrace.c
diff --cc arch/x86/kernel/ftrace.c
index 65f676625c82,24b9fa89aa27..000000000000
--- a/arch/x86/kernel/ftrace.c
+++ b/arch/x86/kernel/ftrace.c
@@@ -739,6 -301,8 +739,11 @@@ union ftrace_op_code_union 
  	} __attribute__((packed));
  };
  
++<<<<<<< HEAD
++=======
+ #define RET_SIZE		(IS_ENABLED(CONFIG_RETPOLINE) ? 5 : 1 + IS_ENABLED(CONFIG_SLS))
+ 
++>>>>>>> 1f001e9da6bb (x86/ftrace: Use alternative RET encoding)
  static unsigned long
  create_trampoline(struct ftrace_ops *ops, unsigned int *tramp_size)
  {
@@@ -782,18 -352,27 +787,40 @@@
  	npages = DIV_ROUND_UP(*tramp_size, PAGE_SIZE);
  
  	/* Copy ftrace_caller onto the trampoline memory */
++<<<<<<< HEAD
 +	ret = probe_kernel_read(trampoline, (void *)start_offset, size);
 +	if (WARN_ON(ret < 0)) {
 +		tramp_free(trampoline, *tramp_size);
 +		return 0;
++=======
+ 	ret = copy_from_kernel_nofault(trampoline, (void *)start_offset, size);
+ 	if (WARN_ON(ret < 0))
+ 		goto fail;
+ 
+ 	ip = trampoline + size;
+ 	if (cpu_feature_enabled(X86_FEATURE_RETHUNK))
+ 		__text_gen_insn(ip, JMP32_INSN_OPCODE, ip, &__x86_return_thunk, JMP32_INSN_SIZE);
+ 	else
+ 		memcpy(ip, retq, sizeof(retq));
+ 
+ 	/* No need to test direct calls on created trampolines */
+ 	if (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {
+ 		/* NOP the jnz 1f; but make sure it's a 2 byte jnz */
+ 		ip = trampoline + (jmp_offset - start_offset);
+ 		if (WARN_ON(*(char *)ip != 0x75))
+ 			goto fail;
+ 		ret = copy_from_kernel_nofault(ip, x86_nops[2], 2);
+ 		if (ret < 0)
+ 			goto fail;
++>>>>>>> 1f001e9da6bb (x86/ftrace: Use alternative RET encoding)
  	}
  
 +	ip = (unsigned long)trampoline + size;
 +
 +	/* The trampoline ends with a jmp to ftrace_epilogue */
 +	jmp = ftrace_jmp_replace(ip, (unsigned long)ftrace_epilogue);
 +	memcpy(trampoline + size, jmp, MCOUNT_INSN_SIZE);
 +
  	/*
  	 * The address of the ftrace_ops that is used for this trampoline
  	 * is stored at the end of the trampoline. This will be used to
* Unmerged path arch/x86/kernel/ftrace.c
