x86/speculation: Remove x86_spec_ctrl_mask

jira LE-1907
cve CVE-2022-23825
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-4.18.0-372.32.1.el8_6
commit-author Josh Poimboeuf <jpoimboe@kernel.org>
commit acac5e98ef8d638a411cfa2ee676c87e1973f126
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-372.32.1.el8_6/acac5e98.failed

This mask has been made redundant by kvm_spec_ctrl_test_value().  And it
doesn't even work when MSR interception is disabled, as the guest can
just write to SPEC_CTRL directly.

	Signed-off-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit acac5e98ef8d638a411cfa2ee676c87e1973f126)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index ff842ff87312,efff8b9f1bbd..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -54,10 -56,34 +54,36 @@@ EXPORT_SYMBOL_GPL(x86_spec_ctrl_base)
  static DEFINE_MUTEX(spec_ctrl_mutex);
  
  /*
++<<<<<<< HEAD
 + * The vendor and possibly platform specific bits which can be modified in
 + * x86_spec_ctrl_base.
 + */
 +static u64 __ro_after_init x86_spec_ctrl_mask = SPEC_CTRL_IBRS;
++=======
+  * Keep track of the SPEC_CTRL MSR value for the current task, which may differ
+  * from x86_spec_ctrl_base due to STIBP/SSB in __speculation_ctrl_update().
+  */
+ void write_spec_ctrl_current(u64 val, bool force)
+ {
+ 	if (this_cpu_read(x86_spec_ctrl_current) == val)
+ 		return;
+ 
+ 	this_cpu_write(x86_spec_ctrl_current, val);
+ 
+ 	/*
+ 	 * When KERNEL_IBRS this MSR is written on return-to-user, unless
+ 	 * forced the update can be delayed until that time.
+ 	 */
+ 	if (force || !cpu_feature_enabled(X86_FEATURE_KERNEL_IBRS))
+ 		wrmsrl(MSR_IA32_SPEC_CTRL, val);
+ }
+ 
+ u64 spec_ctrl_current(void)
+ {
+ 	return this_cpu_read(x86_spec_ctrl_current);
+ }
+ EXPORT_SYMBOL_GPL(spec_ctrl_current);
++>>>>>>> acac5e98ef8d (x86/speculation: Remove x86_spec_ctrl_mask)
  
  /*
   * AMD specific MSR info for Speculative Store Bypass control.
@@@ -107,13 -140,6 +133,16 @@@ void __init check_bugs(void
  	if (boot_cpu_has(X86_FEATURE_MSR_SPEC_CTRL))
  		rdmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
  
++<<<<<<< HEAD
 +	/* Allow STIBP in MSR_SPEC_CTRL if supported */
 +	if (boot_cpu_has(X86_FEATURE_STIBP))
 +		x86_spec_ctrl_mask |= SPEC_CTRL_STIBP;
 +
 +	/* IBRS initialization */
 +	spec_ctrl_init();
 +
++=======
++>>>>>>> acac5e98ef8d (x86/speculation: Remove x86_spec_ctrl_mask)
  	/* Select the proper CPU mitigations before patching alternatives: */
  	spectre_v1_select_mitigation();
  	spectre_v2_select_mitigation();
@@@ -160,28 -198,10 +189,34 @@@
  void
  x86_virt_spec_ctrl(u64 guest_spec_ctrl, u64 guest_virt_spec_ctrl, bool setguest)
  {
++<<<<<<< HEAD
 +	u64 msrval, guestval, hostval = x86_spec_ctrl_base;
++=======
+ 	u64 msrval, guestval = guest_spec_ctrl, hostval = spec_ctrl_current();
++>>>>>>> acac5e98ef8d (x86/speculation: Remove x86_spec_ctrl_mask)
  	struct thread_info *ti = current_thread_info();
  
- 	/* Is MSR_SPEC_CTRL implemented ? */
  	if (static_cpu_has(X86_FEATURE_MSR_SPEC_CTRL)) {
++<<<<<<< HEAD
 +		/*
 +		 * Restrict guest_spec_ctrl to supported values. Clear the
 +		 * modifiable bits in the host base value and or the
 +		 * modifiable bits from the guest value.
 +		 */
 +		guestval = hostval & ~x86_spec_ctrl_mask;
 +		guestval |= guest_spec_ctrl & x86_spec_ctrl_mask;
 +
 +		/* SSBD controlled in MSR_SPEC_CTRL */
 +		if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||
 +		    static_cpu_has(X86_FEATURE_AMD_SSBD))
 +			hostval |= ssbd_tif_to_spec_ctrl(ti->flags);
 +
 +		/* Conditional STIBP enabled? */
 +		if (static_branch_unlikely(&switch_to_cond_stibp))
 +			hostval |= stibp_tif_to_spec_ctrl(ti->flags);
 +
++=======
++>>>>>>> acac5e98ef8d (x86/speculation: Remove x86_spec_ctrl_mask)
  		if (hostval != guestval) {
  			msrval = setguest ? guestval : hostval;
  			wrmsrl(MSR_IA32_SPEC_CTRL, msrval);
* Unmerged path arch/x86/kernel/cpu/bugs.c
