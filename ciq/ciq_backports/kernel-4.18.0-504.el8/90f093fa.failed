rseq, ptrace: Add PTRACE_GET_RSEQ_CONFIGURATION request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Piotr Figiel <figiel@google.com>
commit 90f093fa8ea48e5d991332cee160b761423d55c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/90f093fa.failed

For userspace checkpoint and restore (C/R) a way of getting process state
containing RSEQ configuration is needed.

There are two ways this information is going to be used:
 - to re-enable RSEQ for threads which had it enabled before C/R
 - to detect if a thread was in a critical section during C/R

Since C/R preserves TLS memory and addresses RSEQ ABI will be restored
using the address registered before C/R.

Detection whether the thread is in a critical section during C/R is needed
to enforce behavior of RSEQ abort during C/R. Attaching with ptrace()
before registers are dumped itself doesn't cause RSEQ abort.
Restoring the instruction pointer within the critical section is
problematic because rseq_cs may get cleared before the control is passed
to the migrated application code leading to RSEQ invariants not being
preserved. C/R code will use RSEQ ABI address to find the abort handler
to which the instruction pointer needs to be set.

To achieve above goals expose the RSEQ ABI address and the signature value
with the new ptrace request PTRACE_GET_RSEQ_CONFIGURATION.

This new ptrace request can also be used by debuggers so they are aware
of stops within restartable sequences in progress.

	Signed-off-by: Piotr Figiel <figiel@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Michal Miroslaw <emmir@google.com>
	Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Acked-by: Oleg Nesterov <oleg@redhat.com>
Link: https://lkml.kernel.org/r/20210226135156.1081606-1-figiel@google.com
(cherry picked from commit 90f093fa8ea48e5d991332cee160b761423d55c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/ptrace.h
#	kernel/ptrace.c
diff --cc include/uapi/linux/ptrace.h
index d5a1b8a492b9,3747bf816f9a..000000000000
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@@ -73,6 -73,52 +73,55 @@@ struct seccomp_metadata 
  	__u64 flags;		/* Output: filter's flags */
  };
  
++<<<<<<< HEAD
++=======
+ #define PTRACE_GET_SYSCALL_INFO		0x420e
+ #define PTRACE_SYSCALL_INFO_NONE	0
+ #define PTRACE_SYSCALL_INFO_ENTRY	1
+ #define PTRACE_SYSCALL_INFO_EXIT	2
+ #define PTRACE_SYSCALL_INFO_SECCOMP	3
+ 
+ struct ptrace_syscall_info {
+ 	__u8 op;	/* PTRACE_SYSCALL_INFO_* */
+ 	__u8 pad[3];
+ 	__u32 arch;
+ 	__u64 instruction_pointer;
+ 	__u64 stack_pointer;
+ 	union {
+ 		struct {
+ 			__u64 nr;
+ 			__u64 args[6];
+ 		} entry;
+ 		struct {
+ 			__s64 rval;
+ 			__u8 is_error;
+ 		} exit;
+ 		struct {
+ 			__u64 nr;
+ 			__u64 args[6];
+ 			__u32 ret_data;
+ 		} seccomp;
+ 	};
+ };
+ 
+ #define PTRACE_GET_RSEQ_CONFIGURATION	0x420f
+ 
+ struct ptrace_rseq_configuration {
+ 	__u64 rseq_abi_pointer;
+ 	__u32 rseq_abi_size;
+ 	__u32 signature;
+ 	__u32 flags;
+ 	__u32 pad;
+ };
+ 
+ /*
+  * These values are stored in task->ptrace_message
+  * by tracehook_report_syscall_* to describe the current syscall-stop.
+  */
+ #define PTRACE_EVENTMSG_SYSCALL_ENTRY	1
+ #define PTRACE_EVENTMSG_SYSCALL_EXIT	2
+ 
++>>>>>>> 90f093fa8ea4 (rseq, ptrace: Add PTRACE_GET_RSEQ_CONFIGURATION request)
  /* Read signals from a shared (process wide) queue */
  #define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)
  
diff --cc kernel/ptrace.c
index a05674ac0d15,c71270a1677c..000000000000
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@@ -29,8 -30,10 +29,13 @@@
  #include <linux/hw_breakpoint.h>
  #include <linux/cn_proc.h>
  #include <linux/compat.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sched/signal.h>
+ #include <linux/minmax.h>
++>>>>>>> 90f093fa8ea4 (rseq, ptrace: Add PTRACE_GET_RSEQ_CONFIGURATION request)
  
 -#include <asm/syscall.h>	/* for syscall_get_* */
 +#include <linux/rh_tasklist_lock.h>
  
  /*
   * Access another process' address space via ptrace.
* Unmerged path include/uapi/linux/ptrace.h
* Unmerged path kernel/ptrace.c
