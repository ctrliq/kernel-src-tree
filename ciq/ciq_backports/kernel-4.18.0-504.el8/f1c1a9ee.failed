fork: Move memcg_charge_kernel_stack() into CONFIG_VMAP_STACK

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit f1c1a9ee00e4c53c9ccc03ec1aff4792948a25eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/f1c1a9ee.failed

memcg_charge_kernel_stack() is only used in the CONFIG_VMAP_STACK case.

Move memcg_charge_kernel_stack() into the CONFIG_VMAP_STACK block and
invoke it from within alloc_thread_stack_node().

	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Andy Lutomirski <luto@kernel.org>
Link: https://lore.kernel.org/r/20220217102406.3697941-6-bigeasy@linutronix.de

(cherry picked from commit f1c1a9ee00e4c53c9ccc03ec1aff4792948a25eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/fork.c
diff --cc kernel/fork.c
index 2fc87f72c8b1,ac63e7fa8816..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -206,7 -211,33 +206,37 @@@ static int free_vm_stack_cache(unsigne
  	return 0;
  }
  
++<<<<<<< HEAD
 +static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)
++=======
+ static int memcg_charge_kernel_stack(struct task_struct *tsk)
+ {
+ 	struct vm_struct *vm = task_stack_vm_area(tsk);
+ 	int i;
+ 	int ret;
+ 
+ 	BUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);
+ 	BUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);
+ 
+ 	for (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {
+ 		ret = memcg_kmem_charge_page(vm->pages[i], GFP_KERNEL, 0);
+ 		if (ret)
+ 			goto err;
+ 	}
+ 	return 0;
+ err:
+ 	/*
+ 	 * If memcg_kmem_charge_page() fails, page's memory cgroup pointer is
+ 	 * NULL, and memcg_kmem_uncharge_page() in free_thread_stack() will
+ 	 * ignore this page.
+ 	 */
+ 	for (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++)
+ 		memcg_kmem_uncharge_page(vm->pages[i], 0);
+ 	return ret;
+ }
+ 
+ static int alloc_thread_stack_node(struct task_struct *tsk, int node)
++>>>>>>> f1c1a9ee00e4 (fork: Move memcg_charge_kernel_stack() into CONFIG_VMAP_STACK)
  {
  	void *stack;
  	int i;
@@@ -225,9 -256,14 +255,14 @@@
  		/* Clear stale pointers from reused stack. */
  		memset(s->addr, 0, THREAD_SIZE);
  
+ 		if (memcg_charge_kernel_stack(tsk)) {
+ 			vfree(s->addr);
+ 			return -ENOMEM;
+ 		}
+ 
  		tsk->stack_vm_area = s;
  		tsk->stack = s->addr;
 -		return 0;
 +		return s->addr;
  	}
  
  	/*
@@@ -240,7 -276,13 +275,17 @@@
  				     THREADINFO_GFP & ~__GFP_ACCOUNT,
  				     PAGE_KERNEL,
  				     0, node, __builtin_return_address(0));
++<<<<<<< HEAD
 +
++=======
+ 	if (!stack)
+ 		return -ENOMEM;
+ 
+ 	if (memcg_charge_kernel_stack(tsk)) {
+ 		vfree(stack);
+ 		return -ENOMEM;
+ 	}
++>>>>>>> f1c1a9ee00e4 (fork: Move memcg_charge_kernel_stack() into CONFIG_VMAP_STACK)
  	/*
  	 * We can't call find_vm_area() in interrupt context, and
  	 * free_thread_stack() can be called in interrupt context,
@@@ -891,33 -907,14 +906,36 @@@ static struct task_struct *dup_task_str
  	if (!tsk)
  		return NULL;
  
 -	err = arch_dup_task_struct(tsk, orig);
 -	if (err)
 -		goto free_tsk;
 +	/*
 +	 * RHEL: before proceeding, we need to make tsk->task_struct_rh = NULL,
 +	 * otherwise the error paths below, if taken, might end up causing
 +	 * a double-free for RHEL-only task_struct_rh extention object.
 +	 */
 +	WRITE_ONCE(tsk->task_struct_rh, NULL);
  
 -	err = alloc_thread_stack_node(tsk, node);
 -	if (err)
 +	stack = alloc_thread_stack_node(tsk, node);
 +	if (!stack)
  		goto free_tsk;
  
++<<<<<<< HEAD
 +	if (memcg_charge_kernel_stack(tsk))
 +		goto free_stack;
 +
 +	stack_vm_area = task_stack_vm_area(tsk);
 +
 +	err = arch_dup_task_struct(tsk, orig);
 +
 +	/*
 +	 * arch_dup_task_struct() clobbers the stack-related fields.  Make
 +	 * sure they're properly initialized before using any stack-related
 +	 * functions again.
 +	 */
 +	tsk->stack = stack;
 +#ifdef CONFIG_VMAP_STACK
 +	tsk->stack_vm_area = stack_vm_area;
 +#endif
++=======
++>>>>>>> f1c1a9ee00e4 (fork: Move memcg_charge_kernel_stack() into CONFIG_VMAP_STACK)
  #ifdef CONFIG_THREAD_INFO_IN_TASK
  	refcount_set(&tsk->stack_refcount, 1);
  #endif
* Unmerged path kernel/fork.c
