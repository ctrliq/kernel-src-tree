regmap: Add FSI bus support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Eddie James <eajames@linux.ibm.com>
commit bf0d29fb51ff5e6c13097dbfed7b99e0e35b4a15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/bf0d29fb.failed

Add regmap support for the FSI bus.

	Signed-off-by: Eddie James <eajames@linux.ibm.com>
Link: https://lore.kernel.org/r/20221102205148.1334459-2-eajames@linux.ibm.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit bf0d29fb51ff5e6c13097dbfed7b99e0e35b4a15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/Kconfig
#	include/linux/regmap.h
diff --cc drivers/base/regmap/Kconfig
index 9d98c1879897,cd4bb642b9de..000000000000
--- a/drivers/base/regmap/Kconfig
+++ b/drivers/base/regmap/Kconfig
@@@ -4,7 -4,7 +4,11 @@@
  # subsystems should select the appropriate symbols.
  
  config REGMAP
++<<<<<<< HEAD
 +	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_W1 || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ || REGMAP_SOUNDWIRE || REGMAP_SOUNDWIRE_MBQ || REGMAP_MDIO)
++=======
+ 	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_W1 || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ || REGMAP_SOUNDWIRE || REGMAP_SOUNDWIRE_MBQ || REGMAP_SCCB || REGMAP_I3C || REGMAP_SPI_AVMM || REGMAP_MDIO || REGMAP_FSI)
++>>>>>>> bf0d29fb51ff (regmap: Add FSI bus support)
  	select IRQ_DOMAIN if REGMAP_IRQ
  	select MDIO_BUS if REGMAP_MDIO
  	bool
@@@ -50,3 -53,19 +54,22 @@@ config REGMAP_SOUNDWIR
  config REGMAP_SOUNDWIRE_MBQ
  	tristate
  	depends on SOUNDWIRE
++<<<<<<< HEAD
++=======
+ 
+ config REGMAP_SCCB
+ 	tristate
+ 	depends on I2C
+ 
+ config REGMAP_I3C
+ 	tristate
+ 	depends on I3C
+ 
+ config REGMAP_SPI_AVMM
+ 	tristate
+ 	depends on SPI
+ 
+ config REGMAP_FSI
+ 	tristate
+ 	depends on FSI
++>>>>>>> bf0d29fb51ff (regmap: Add FSI bus support)
diff --cc include/linux/regmap.h
index c7b0fb463f09,e477112fb1c7..000000000000
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@@ -25,7 -23,10 +25,12 @@@
  struct module;
  struct clk;
  struct device;
++<<<<<<< HEAD
++=======
+ struct device_node;
+ struct fsi_device;
++>>>>>>> bf0d29fb51ff (regmap: Add FSI bus support)
  struct i2c_client;
 -struct i3c_device;
  struct irq_domain;
  struct mdio_device;
  struct slim_device;
@@@ -608,6 -625,14 +613,17 @@@ struct regmap *__regmap_init_sdw_mbq(st
  				     const struct regmap_config *config,
  				     struct lock_class_key *lock_key,
  				     const char *lock_name);
++<<<<<<< HEAD
++=======
+ struct regmap *__regmap_init_spi_avmm(struct spi_device *spi,
+ 				      const struct regmap_config *config,
+ 				      struct lock_class_key *lock_key,
+ 				      const char *lock_name);
+ struct regmap *__regmap_init_fsi(struct fsi_device *fsi_dev,
+ 				 const struct regmap_config *config,
+ 				 struct lock_class_key *lock_key,
+ 				 const char *lock_name);
++>>>>>>> bf0d29fb51ff (regmap: Add FSI bus support)
  
  struct regmap *__devm_regmap_init(struct device *dev,
  				  const struct regmap_bus *bus,
@@@ -661,6 -690,19 +677,22 @@@ struct regmap *__devm_regmap_init_slimb
  				 const struct regmap_config *config,
  				 struct lock_class_key *lock_key,
  				 const char *lock_name);
++<<<<<<< HEAD
++=======
+ struct regmap *__devm_regmap_init_i3c(struct i3c_device *i3c,
+ 				 const struct regmap_config *config,
+ 				 struct lock_class_key *lock_key,
+ 				 const char *lock_name);
+ struct regmap *__devm_regmap_init_spi_avmm(struct spi_device *spi,
+ 					   const struct regmap_config *config,
+ 					   struct lock_class_key *lock_key,
+ 					   const char *lock_name);
+ struct regmap *__devm_regmap_init_fsi(struct fsi_device *fsi_dev,
+ 				      const struct regmap_config *config,
+ 				      struct lock_class_key *lock_key,
+ 				      const char *lock_name);
+ 
++>>>>>>> bf0d29fb51ff (regmap: Add FSI bus support)
  /*
   * Wrapper for regmap_init macros to include a unique lockdep key and name
   * for each call. No-op if CONFIG_LOCKDEP is not set.
@@@ -860,7 -915,33 +892,20 @@@ bool regmap_ac97_default_volatile(struc
  	__regmap_lockdep_wrapper(__regmap_init_sdw_mbq, #config,		\
  				sdw, config)
  
 -/**
 - * regmap_init_spi_avmm() - Initialize register map for Intel SPI Slave
 - * to AVMM Bus Bridge
 - *
 - * @spi: Device that will be interacted with
 - * @config: Configuration for register map
 - *
 - * The return value will be an ERR_PTR() on error or a valid pointer
 - * to a struct regmap.
 - */
 -#define regmap_init_spi_avmm(spi, config)					\
 -	__regmap_lockdep_wrapper(__regmap_init_spi_avmm, #config,		\
 -				 spi, config)
  
+ /**
+  * regmap_init_fsi() - Initialise register map
+  *
+  * @fsi_dev: Device that will be interacted with
+  * @config: Configuration for register map
+  *
+  * The return value will be an ERR_PTR() on error or a valid pointer to
+  * a struct regmap.
+  */
+ #define regmap_init_fsi(fsi_dev, config)				\
+ 	__regmap_lockdep_wrapper(__regmap_init_fsi, #config, fsi_dev,	\
+ 				 config)
+ 
  /**
   * devm_regmap_init() - Initialise managed register map
   *
@@@ -1046,6 -1141,50 +1091,53 @@@
  #define devm_regmap_init_slimbus(slimbus, config)			\
  	__regmap_lockdep_wrapper(__devm_regmap_init_slimbus, #config,	\
  				slimbus, config)
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * devm_regmap_init_i3c() - Initialise managed register map
+  *
+  * @i3c: Device that will be interacted with
+  * @config: Configuration for register map
+  *
+  * The return value will be an ERR_PTR() on error or a valid pointer
+  * to a struct regmap.  The regmap will be automatically freed by the
+  * device management code.
+  */
+ #define devm_regmap_init_i3c(i3c, config)				\
+ 	__regmap_lockdep_wrapper(__devm_regmap_init_i3c, #config,	\
+ 				i3c, config)
+ 
+ /**
+  * devm_regmap_init_spi_avmm() - Initialize register map for Intel SPI Slave
+  * to AVMM Bus Bridge
+  *
+  * @spi: Device that will be interacted with
+  * @config: Configuration for register map
+  *
+  * The return value will be an ERR_PTR() on error or a valid pointer
+  * to a struct regmap.  The map will be automatically freed by the
+  * device management code.
+  */
+ #define devm_regmap_init_spi_avmm(spi, config)				\
+ 	__regmap_lockdep_wrapper(__devm_regmap_init_spi_avmm, #config,	\
+ 				 spi, config)
+ 
+ /**
+  * devm_regmap_init_fsi() - Initialise managed register map
+  *
+  * @fsi_dev: Device that will be interacted with
+  * @config: Configuration for register map
+  *
+  * The return value will be an ERR_PTR() on error or a valid pointer
+  * to a struct regmap.  The regmap will be automatically freed by the
+  * device management code.
+  */
+ #define devm_regmap_init_fsi(fsi_dev, config)				\
+ 	__regmap_lockdep_wrapper(__devm_regmap_init_fsi, #config,	\
+ 				 fsi_dev, config)
+ 
++>>>>>>> bf0d29fb51ff (regmap: Add FSI bus support)
  int regmap_mmio_attach_clk(struct regmap *map, struct clk *clk);
  void regmap_mmio_detach_clk(struct regmap *map);
  void regmap_exit(struct regmap *map);
* Unmerged path drivers/base/regmap/Kconfig
diff --git a/drivers/base/regmap/Makefile b/drivers/base/regmap/Makefile
index f0b4a945af65..6a96ad594538 100644
--- a/drivers/base/regmap/Makefile
+++ b/drivers/base/regmap/Makefile
@@ -17,3 +17,4 @@ obj-$(CONFIG_REGMAP_W1) += regmap-w1.o
 obj-$(CONFIG_REGMAP_SOUNDWIRE) += regmap-sdw.o
 obj-$(CONFIG_REGMAP_SOUNDWIRE_MBQ) += regmap-sdw-mbq.o
 obj-$(CONFIG_REGMAP_MDIO) += regmap-mdio.o
+obj-$(CONFIG_REGMAP_FSI) += regmap-fsi.o
diff --git a/drivers/base/regmap/regmap-fsi.c b/drivers/base/regmap/regmap-fsi.c
new file mode 100644
index 000000000000..3d2f3cb31d5e
--- /dev/null
+++ b/drivers/base/regmap/regmap-fsi.c
@@ -0,0 +1,231 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Register map access API - FSI support
+//
+// Copyright 2022 IBM Corp
+//
+// Author: Eddie James <eajames@linux.ibm.com>
+
+#include <linux/fsi.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+
+#include "internal.h"
+
+static int regmap_fsi32_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	u32 v;
+	int ret;
+
+	ret = fsi_slave_read(context, reg, &v, sizeof(v));
+	if (ret)
+		return ret;
+
+	*val = v;
+	return 0;
+}
+
+static int regmap_fsi32_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	u32 v = val;
+
+	return fsi_slave_write(context, reg, &v, sizeof(v));
+}
+
+static const struct regmap_bus regmap_fsi32 = {
+	.reg_write = regmap_fsi32_reg_write,
+	.reg_read = regmap_fsi32_reg_read,
+};
+
+static int regmap_fsi32le_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	__be32 v;
+	int ret;
+
+	ret = fsi_slave_read(context, reg, &v, sizeof(v));
+	if (ret)
+		return ret;
+
+	*val = be32_to_cpu(v);
+	return 0;
+}
+
+static int regmap_fsi32le_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	__be32 v = cpu_to_be32(val);
+
+	return fsi_slave_write(context, reg, &v, sizeof(v));
+}
+
+static const struct regmap_bus regmap_fsi32le = {
+	.reg_write = regmap_fsi32le_reg_write,
+	.reg_read = regmap_fsi32le_reg_read,
+};
+
+static int regmap_fsi16_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	u16 v;
+	int ret;
+
+	ret = fsi_slave_read(context, reg, &v, sizeof(v));
+	if (ret)
+		return ret;
+
+	*val = v;
+	return 0;
+}
+
+static int regmap_fsi16_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	u16 v;
+
+	if (val > 0xffff)
+		return -EINVAL;
+
+	v = val;
+	return fsi_slave_write(context, reg, &v, sizeof(v));
+}
+
+static const struct regmap_bus regmap_fsi16 = {
+	.reg_write = regmap_fsi16_reg_write,
+	.reg_read = regmap_fsi16_reg_read,
+};
+
+static int regmap_fsi16le_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	__be16 v;
+	int ret;
+
+	ret = fsi_slave_read(context, reg, &v, sizeof(v));
+	if (ret)
+		return ret;
+
+	*val = be16_to_cpu(v);
+	return 0;
+}
+
+static int regmap_fsi16le_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	__be16 v;
+
+	if (val > 0xffff)
+		return -EINVAL;
+
+	v = cpu_to_be16(val);
+	return fsi_slave_write(context, reg, &v, sizeof(v));
+}
+
+static const struct regmap_bus regmap_fsi16le = {
+	.reg_write = regmap_fsi16le_reg_write,
+	.reg_read = regmap_fsi16le_reg_read,
+};
+
+static int regmap_fsi8_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	u8 v;
+	int ret;
+
+	ret = fsi_slave_read(context, reg, &v, sizeof(v));
+	if (ret)
+		return ret;
+
+	*val = v;
+	return 0;
+}
+
+static int regmap_fsi8_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	u8 v;
+
+	if (val > 0xff)
+		return -EINVAL;
+
+	v = val;
+	return fsi_slave_write(context, reg, &v, sizeof(v));
+}
+
+static const struct regmap_bus regmap_fsi8 = {
+	.reg_write = regmap_fsi8_reg_write,
+	.reg_read = regmap_fsi8_reg_read,
+};
+
+static const struct regmap_bus *regmap_get_fsi_bus(struct fsi_device *fsi_dev,
+						   const struct regmap_config *config)
+{
+	const struct regmap_bus *bus = NULL;
+
+	if (config->reg_bits == 8 || config->reg_bits == 16 || config->reg_bits == 32) {
+		switch (config->val_bits) {
+		case 8:
+			bus = &regmap_fsi8;
+			break;
+		case 16:
+			switch (regmap_get_val_endian(&fsi_dev->dev, NULL, config)) {
+			case REGMAP_ENDIAN_LITTLE:
+#ifdef __LITTLE_ENDIAN
+			case REGMAP_ENDIAN_NATIVE:
+#endif
+				bus = &regmap_fsi16le;
+				break;
+			case REGMAP_ENDIAN_DEFAULT:
+			case REGMAP_ENDIAN_BIG:
+#ifdef __BIG_ENDIAN
+			case REGMAP_ENDIAN_NATIVE:
+#endif
+				bus = &regmap_fsi16;
+				break;
+			default:
+				break;
+			}
+			break;
+		case 32:
+			switch (regmap_get_val_endian(&fsi_dev->dev, NULL, config)) {
+			case REGMAP_ENDIAN_LITTLE:
+#ifdef __LITTLE_ENDIAN
+			case REGMAP_ENDIAN_NATIVE:
+#endif
+				bus = &regmap_fsi32le;
+				break;
+			case REGMAP_ENDIAN_DEFAULT:
+			case REGMAP_ENDIAN_BIG:
+#ifdef __BIG_ENDIAN
+			case REGMAP_ENDIAN_NATIVE:
+#endif
+				bus = &regmap_fsi32;
+				break;
+			default:
+				break;
+			}
+			break;
+		}
+	}
+
+	return bus ?: ERR_PTR(-EOPNOTSUPP);
+}
+
+struct regmap *__regmap_init_fsi(struct fsi_device *fsi_dev, const struct regmap_config *config,
+				 struct lock_class_key *lock_key, const char *lock_name)
+{
+	const struct regmap_bus *bus = regmap_get_fsi_bus(fsi_dev, config);
+
+	if (IS_ERR(bus))
+		return ERR_CAST(bus);
+
+	return __regmap_init(&fsi_dev->dev, bus, fsi_dev->slave, config, lock_key, lock_name);
+}
+EXPORT_SYMBOL_GPL(__regmap_init_fsi);
+
+struct regmap *__devm_regmap_init_fsi(struct fsi_device *fsi_dev,
+				      const struct regmap_config *config,
+				      struct lock_class_key *lock_key, const char *lock_name)
+{
+	const struct regmap_bus *bus = regmap_get_fsi_bus(fsi_dev, config);
+
+	if (IS_ERR(bus))
+		return ERR_CAST(bus);
+
+	return __devm_regmap_init(&fsi_dev->dev, bus, fsi_dev->slave, config, lock_key, lock_name);
+}
+EXPORT_SYMBOL_GPL(__devm_regmap_init_fsi);
+
+MODULE_LICENSE("GPL");
* Unmerged path include/linux/regmap.h
