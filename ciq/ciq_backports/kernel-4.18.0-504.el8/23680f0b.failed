driver core: make struct class.dev_uevent() take a const *

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 23680f0b7d7f67a935adb38058110d2d81bbe6ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/23680f0b.failed

The dev_uevent() in struct class should not be modifying the device that
is passed into it, so mark it as a const * and propagate the function
signature changes out into all relevant subsystems that use this
callback.

	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Luis Chamberlain <mcgrof@kernel.org>
	Cc: Russ Weight <russell.h.weight@intel.com>
	Cc: Jean Delvare <jdelvare@suse.com>
	Cc: Johan Hovold <johan@kernel.org>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: Leon Romanovsky <leon@kernel.org>
	Cc: Karsten Keil <isdn@linux-pingi.de>
	Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
	Cc: Keith Busch <kbusch@kernel.org>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Sagi Grimberg <sagi@grimberg.me>
	Cc: Dominik Brodowski <linux@dominikbrodowski.net>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Jakub Kicinski <kuba@kernel.org>
	Cc: Paolo Abeni <pabeni@redhat.com>
	Cc: Johannes Berg <johannes@sipsolutions.net>
	Cc: Wolfram Sang <wsa+renesas@sang-engineering.com>
	Cc: Raed Salem <raeds@nvidia.com>
	Cc: Chen Zhongjin <chenzhongjin@huawei.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Avihai Horon <avihaih@nvidia.com>
	Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
	Cc: Alan Stern <stern@rowland.harvard.edu>
	Cc: Colin Ian King <colin.i.king@gmail.com>
	Cc: Geert Uytterhoeven <geert+renesas@glider.be>
	Cc: Jakob Koschel <jakobkoschel@gmail.com>
	Cc: Antoine Tenart <atenart@kernel.org>
	Cc: Frederic Weisbecker <frederic@kernel.org>
	Cc: Wang Yufen <wangyufen@huawei.com>
	Cc: linux-block@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Cc: linux-media@vger.kernel.org
	Cc: linux-nvme@lists.infradead.org
	Cc: linux-pm@vger.kernel.org
	Cc: linux-rdma@vger.kernel.org
	Cc: linux-usb@vger.kernel.org
	Cc: linux-wireless@vger.kernel.org
	Cc: netdev@vger.kernel.org
	Acked-by: Sebastian Reichel <sre@kernel.org>
	Acked-by: Rafael J. Wysocki <rafael@kernel.org>
Link: https://lore.kernel.org/r/20221123122523.1332370-1-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 23680f0b7d7f67a935adb38058110d2d81bbe6ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/genhd.c
#	drivers/base/firmware_loader/sysfs.h
#	drivers/gnss/core.c
#	drivers/power/supply/power_supply_sysfs.c
#	include/linux/device/class.h
diff --cc block/genhd.c
index 027a6f99af1b,3f1124713442..000000000000
--- a/block/genhd.c
+++ b/block/genhd.c
@@@ -1574,21 -1149,48 +1574,32 @@@ static void disk_release(struct device 
  	struct gendisk *disk = dev_to_disk(dev);
  
  	might_sleep();
 -	WARN_ON_ONCE(disk_live(disk));
 -
 -	/*
 -	 * To undo the all initialization from blk_mq_init_allocated_queue in
 -	 * case of a probe failure where add_disk is never called we have to
 -	 * call blk_mq_exit_queue here. We can't do this for the more common
 -	 * teardown case (yet) as the tagset can be gone by the time the disk
 -	 * is released once it was added.
 -	 */
 -	if (queue_is_mq(disk->queue) &&
 -	    test_bit(GD_OWNS_QUEUE, &disk->state) &&
 -	    !test_bit(GD_ADDED, &disk->state))
 -		blk_mq_exit_queue(disk->queue);
  
 -	blkcg_exit_disk(disk);
 -
 -	bioset_exit(&disk->bio_split);
 +	if (disk->queue)
 +		blk_mq_cancel_work_sync(disk->queue);
  
 +	blk_free_devt(dev->devt);
  	disk_release_events(disk);
  	kfree(disk->random);
 -	disk_free_zone_bitmaps(disk);
 -	xa_destroy(&disk->part_tbl);
 -
 -	disk->queue->disk = NULL;
 -	blk_put_queue(disk->queue);
 -
 -	if (test_bit(GD_ADDED, &disk->state) && disk->fops->free_disk)
 -		disk->fops->free_disk(disk);
 -
 -	iput(disk->part0->bd_inode);	/* frees the disk */
 +	disk_replace_part_tbl(disk, NULL);
 +	hd_free_part(&disk->part0);
 +	if (disk->queue)
 +		blk_put_queue(disk->queue);
 +	kfree(disk);
  }
++<<<<<<< HEAD
++=======
+ 
+ static int block_uevent(const struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	const struct gendisk *disk = dev_to_disk(dev);
+ 
+ 	return add_uevent_var(env, "DISKSEQ=%llu", disk->diskseq);
+ }
+ 
++>>>>>>> 23680f0b7d7f (driver core: make struct class.dev_uevent() take a const *)
  struct class block_class = {
  	.name		= "block",
 -	.dev_uevent	= block_uevent,
  };
  
  static char *block_devnode(struct device *dev, umode_t *mode,
diff --cc drivers/base/firmware_loader/sysfs.h
index 47416d611193,fd0b4ad9bdbb..000000000000
--- a/drivers/base/firmware_loader/sysfs.h
+++ b/drivers/base/firmware_loader/sysfs.h
@@@ -63,7 -80,11 +63,15 @@@ struct fw_sysfs 
  	struct firmware *fw;
  	void *fw_upload_priv;
  };
++<<<<<<< HEAD
 +#define to_fw_sysfs(__dev)	container_of_const(__dev, struct fw_sysfs, dev)
++=======
+ 
+ static inline struct fw_sysfs *to_fw_sysfs(const struct device *dev)
+ {
+ 	return container_of(dev, struct fw_sysfs, dev);
+ }
++>>>>>>> 23680f0b7d7f (driver core: make struct class.dev_uevent() take a const *)
  
  void __fw_load_abort(struct fw_priv *fw_priv);
  
diff --cc drivers/power/supply/power_supply_sysfs.c
index d055704dfed4,6ca7d3985a40..000000000000
--- a/drivers/power/supply/power_supply_sysfs.c
+++ b/drivers/power/supply/power_supply_sysfs.c
@@@ -354,35 -407,62 +354,51 @@@ void power_supply_init_attrs(struct dev
  
  	dev_type->groups = power_supply_attr_groups;
  
 -	for (i = 0; i < ARRAY_SIZE(power_supply_attrs); i++) {
 -		struct device_attribute *attr;
 -
 -		if (!power_supply_attrs[i].prop_name) {
 -			pr_warn("%s: Property %d skipped because it is missing from power_supply_attrs\n",
 -				__func__, i);
 -			sprintf(power_supply_attrs[i].attr_name, "_err_%d", i);
 -		} else {
 -			str_to_lower(power_supply_attrs[i].attr_name);
 -		}
 -
 -		attr = &power_supply_attrs[i].dev_attr;
 -
 -		attr->attr.name = power_supply_attrs[i].attr_name;
 -		attr->show = power_supply_show_property;
 -		attr->store = power_supply_store_property;
 -		__power_supply_attrs[i] = &attr->attr;
 -	}
 +	for (i = 0; i < ARRAY_SIZE(power_supply_attrs); i++)
 +		__power_supply_attrs[i] = &power_supply_attrs[i].attr;
  }
  
++<<<<<<< HEAD
 +static char *kstruprdup(const char *str, gfp_t gfp)
++=======
+ static int add_prop_uevent(const struct device *dev, struct kobj_uevent_env *env,
+ 			   enum power_supply_property prop, char *prop_buf)
++>>>>>>> 23680f0b7d7f (driver core: make struct class.dev_uevent() take a const *)
  {
 -	int ret = 0;
 -	struct power_supply_attr *pwr_attr;
 -	struct device_attribute *dev_attr;
 -	char *line;
 +	char *ret, *ustr;
  
 -	pwr_attr = &power_supply_attrs[prop];
 -	dev_attr = &pwr_attr->dev_attr;
 +	ustr = ret = kmalloc(strlen(str) + 1, gfp);
  
++<<<<<<< HEAD
 +	if (!ret)
 +		return NULL;
++=======
+ 	ret = power_supply_show_property((struct device *)dev, dev_attr, prop_buf);
+ 	if (ret == -ENODEV || ret == -ENODATA) {
+ 		/*
+ 		 * When a battery is absent, we expect -ENODEV. Don't abort;
+ 		 * send the uevent with at least the PRESENT=0 property
+ 		 */
+ 		return 0;
+ 	}
++>>>>>>> 23680f0b7d7f (driver core: make struct class.dev_uevent() take a const *)
  
 -	if (ret < 0)
 -		return ret;
 +	while (*str)
 +		*ustr++ = toupper(*str++);
  
 -	line = strchr(prop_buf, '\n');
 -	if (line)
 -		*line = 0;
 +	*ustr = 0;
  
 -	return add_uevent_var(env, "POWER_SUPPLY_%s=%s",
 -			      pwr_attr->prop_name, prop_buf);
 +	return ret;
  }
  
- int power_supply_uevent(struct device *dev, struct kobj_uevent_env *env)
+ int power_supply_uevent(const struct device *dev, struct kobj_uevent_env *env)
  {
- 	struct power_supply *psy = dev_get_drvdata(dev);
+ 	const struct power_supply *psy = dev_get_drvdata(dev);
  	int ret = 0, j;
  	char *prop_buf;
 +	char *attrname;
 +
 +	dev_dbg(dev, "uevent\n");
  
  	if (!psy || !psy->desc) {
  		dev_dbg(dev, "No power supply yet\n");
* Unmerged path drivers/gnss/core.c
* Unmerged path include/linux/device/class.h
* Unmerged path block/genhd.c
diff --git a/drivers/base/firmware_loader/sysfs.c b/drivers/base/firmware_loader/sysfs.c
index 2f38d64566a3..50fd3fc7d24b 100644
--- a/drivers/base/firmware_loader/sysfs.c
+++ b/drivers/base/firmware_loader/sysfs.c
@@ -66,7 +66,7 @@ static struct attribute *firmware_class_attrs[] = {
 };
 ATTRIBUTE_GROUPS(firmware_class);
 
-static int do_firmware_uevent(struct fw_sysfs *fw_sysfs, struct kobj_uevent_env *env)
+static int do_firmware_uevent(const struct fw_sysfs *fw_sysfs, struct kobj_uevent_env *env)
 {
 	if (add_uevent_var(env, "FIRMWARE=%s", fw_sysfs->fw_priv->fw_name))
 		return -ENOMEM;
@@ -78,9 +78,9 @@ static int do_firmware_uevent(struct fw_sysfs *fw_sysfs, struct kobj_uevent_env
 	return 0;
 }
 
-static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int firmware_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);
+	const struct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);
 	int err = 0;
 
 	mutex_lock(&fw_lock);
* Unmerged path drivers/base/firmware_loader/sysfs.h
diff --git a/drivers/firmware/dmi-id.c b/drivers/firmware/dmi-id.c
index 624a11cb07e2..fde74cd9fe88 100644
--- a/drivers/firmware/dmi-id.c
+++ b/drivers/firmware/dmi-id.c
@@ -147,7 +147,7 @@ static const struct attribute_group* sys_dmi_attribute_groups[] = {
 	NULL
 };
 
-static int dmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int dmi_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	ssize_t len;
 
* Unmerged path drivers/gnss/core.c
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index 6ba8c74d6427..ea41b9ae0a29 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -511,7 +511,7 @@ static void ib_device_release(struct device *device)
 	kfree_rcu(dev, rcu_head);
 }
 
-static int ib_device_uevent(struct device *device,
+static int ib_device_uevent(const struct device *device,
 			    struct kobj_uevent_env *env)
 {
 	if (add_uevent_var(env, "NAME=%s", dev_name(device)))
diff --git a/drivers/isdn/mISDN/core.c b/drivers/isdn/mISDN/core.c
index faf505462a4f..b21c0c2174db 100644
--- a/drivers/isdn/mISDN/core.c
+++ b/drivers/isdn/mISDN/core.c
@@ -148,9 +148,9 @@ static struct attribute *mISDN_attrs[] = {
 };
 ATTRIBUTE_GROUPS(mISDN);
 
-static int mISDN_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int mISDN_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mISDNdevice *mdev = dev_to_mISDN(dev);
+	const struct mISDNdevice *mdev = dev_to_mISDN(dev);
 
 	if (!mdev)
 		return 0;
diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
index f4df52e902fa..8d7788b8d63e 100644
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -995,9 +995,9 @@ void dvb_module_release(struct i2c_client *client)
 EXPORT_SYMBOL_GPL(dvb_module_release);
 #endif
 
-static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int dvb_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+	const struct dvb_device *dvbdev = dev_get_drvdata(dev);
 
 	add_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);
 	add_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 665bac340c71..817234959062 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -4290,9 +4290,9 @@ void nvme_remove_namespaces(struct nvme_ctrl *ctrl)
 }
 EXPORT_SYMBOL_GPL(nvme_remove_namespaces);
 
-static int nvme_class_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int nvme_class_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct nvme_ctrl *ctrl =
+	const struct nvme_ctrl *ctrl =
 		container_of(dev, struct nvme_ctrl, ctrl_device);
 	struct nvmf_ctrl_options *opts = ctrl->opts;
 	int ret;
diff --git a/drivers/pcmcia/cs.c b/drivers/pcmcia/cs.c
index 8c8caec3a72c..75b7c36f90f9 100644
--- a/drivers/pcmcia/cs.c
+++ b/drivers/pcmcia/cs.c
@@ -815,10 +815,10 @@ int pcmcia_reset_card(struct pcmcia_socket *skt)
 EXPORT_SYMBOL(pcmcia_reset_card);
 
 
-static int pcmcia_socket_uevent(struct device *dev,
+static int pcmcia_socket_uevent(const struct device *dev,
 				struct kobj_uevent_env *env)
 {
-	struct pcmcia_socket *s = container_of(dev, struct pcmcia_socket, dev);
+	const struct pcmcia_socket *s = container_of(dev, struct pcmcia_socket, dev);
 
 	if (add_uevent_var(env, "SOCKET_NO=%u", s->sock))
 		return -ENOMEM;
diff --git a/drivers/power/supply/power_supply.h b/drivers/power/supply/power_supply.h
index cc439fd89d8d..2c3d2d12b5f1 100644
--- a/drivers/power/supply/power_supply.h
+++ b/drivers/power/supply/power_supply.h
@@ -17,7 +17,7 @@ struct power_supply;
 #ifdef CONFIG_SYSFS
 
 extern void power_supply_init_attrs(struct device_type *dev_type);
-extern int power_supply_uevent(struct device *dev, struct kobj_uevent_env *env);
+extern int power_supply_uevent(const struct device *dev, struct kobj_uevent_env *env);
 
 #else
 
* Unmerged path drivers/power/supply/power_supply_sysfs.c
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 7cf34beb50df..4490200e78f4 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1564,9 +1564,9 @@ static const struct attribute_group *usb_udc_attr_groups[] = {
 	NULL,
 };
 
-static int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int usb_udc_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
-	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
+	const struct usb_udc	*udc = container_of(dev, struct usb_udc, dev);
 	int			ret;
 
 	ret = add_uevent_var(env, "USB_UDC_NAME=%s", udc->gadget->name);
* Unmerged path include/linux/device/class.h
diff --git a/include/linux/mISDNif.h b/include/linux/mISDNif.h
index a7330eb3ec64..ca4a5f24dfd6 100644
--- a/include/linux/mISDNif.h
+++ b/include/linux/mISDNif.h
@@ -587,7 +587,7 @@ extern struct mISDNclock *mISDN_register_clock(char *, int, clockctl_func_t *,
 						void *);
 extern void	mISDN_unregister_clock(struct mISDNclock *);
 
-static inline struct mISDNdevice *dev_to_mISDN(struct device *dev)
+static inline struct mISDNdevice *dev_to_mISDN(const struct device *dev)
 {
 	if (dev)
 		return dev_get_drvdata(dev);
diff --git a/net/atm/atm_sysfs.c b/net/atm/atm_sysfs.c
index 39b94ca5f65d..078296b4e5b8 100644
--- a/net/atm/atm_sysfs.c
+++ b/net/atm/atm_sysfs.c
@@ -114,9 +114,9 @@ static struct device_attribute *atm_attrs[] = {
 };
 
 
-static int atm_uevent(struct device *cdev, struct kobj_uevent_env *env)
+static int atm_uevent(const struct device *cdev, struct kobj_uevent_env *env)
 {
-	struct atm_dev *adev;
+	const struct atm_dev *adev;
 
 	if (!cdev)
 		return -ENODEV;
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 266339842aac..904da8b2816c 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -1925,9 +1925,9 @@ const struct kobj_ns_type_operations net_ns_type_operations = {
 };
 EXPORT_SYMBOL_GPL(net_ns_type_operations);
 
-static int netdev_uevent(struct device *d, struct kobj_uevent_env *env)
+static int netdev_uevent(const struct device *d, struct kobj_uevent_env *env)
 {
-	struct net_device *dev = to_net_dev(d);
+	const struct net_device *dev = to_net_dev(d);
 	int retval;
 
 	/* pass interface to uevent. */
diff --git a/net/rfkill/core.c b/net/rfkill/core.c
index df9e7c410ca1..2ef43dd75563 100644
--- a/net/rfkill/core.c
+++ b/net/rfkill/core.c
@@ -844,7 +844,7 @@ static void rfkill_release(struct device *dev)
 	kfree(rfkill);
 }
 
-static int rfkill_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int rfkill_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)
 {
 	struct rfkill *rfkill = to_rfkill(dev);
 	unsigned long flags;
