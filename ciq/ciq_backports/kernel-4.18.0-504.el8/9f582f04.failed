media: uvcvideo: Check for INACTIVE in uvc_ctrl_is_accessible()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Hans Verkuil <hverkuil-cisco@xs4all.nl>
commit 9f582f0418ed1c18f92c9e4628075d6ec9a7d9fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/9f582f04.failed

Check for inactive controls in uvc_ctrl_is_accessible().

Use the new value for the master_id controls if present, otherwise
use the existing value to determine if it is OK to set the control.
Doing this here avoids attempting to set an inactive control, which
will return an error from the USB device, which returns an invalid
errorcode.

This fixes:
  warn: v4l2-test-controls.cpp(483): s_ctrl returned EIO
  warn: v4l2-test-controls.cpp(483): s_ctrl returned EIO
test VIDIOC_G/S_CTRL: OK
  warn: v4l2-test-controls.cpp(739): s_ext_ctrls returned EIO
  warn: v4l2-test-controls.cpp(739): s_ext_ctrls returned EIO
  warn: v4l2-test-controls.cpp(816): s_ext_ctrls returned EIO
test VIDIOC_G/S/TRY_EXT_CTRLS: OK

Tested with:
v4l2-ctl -c auto_exposure=1
OK
v4l2-ctl -c exposure_time_absolute=251
OK
v4l2-ctl -c auto_exposure=3
OK
v4l2-ctl -c exposure_time_absolute=251
VIDIOC_S_EXT_CTRLS: failed: Input/output error
exposure_time_absolute: Input/output error
ERROR
v4l2-ctl -c auto_exposure=3,exposure_time_absolute=251,auto_exposure=1
v4l2-ctl -C auto_exposure,exposure_time_absolute  
auto_exposure: 1
exposure_time_absolute: 251

	Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Reviewed-by: Ricardo Ribalda <ribalda@chromium.org>
	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
(cherry picked from commit 9f582f0418ed1c18f92c9e4628075d6ec9a7d9fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
#	drivers/media/usb/uvc/uvc_v4l2.c
#	drivers/media/usb/uvc/uvcvideo.h
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index 0b5a224748c7,6f5aaaf09ee0..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -1114,6 -1085,82 +1114,85 @@@ static int uvc_query_v4l2_class(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Check if control @v4l2_id can be accessed by the given control @ioctl
+  * (VIDIOC_G_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS or VIDIOC_S_EXT_CTRLS).
+  *
+  * For set operations on slave controls, check if the master's value is set to
+  * manual, either in the others controls set in the same ioctl call, or from
+  * the master's current value. This catches VIDIOC_S_EXT_CTRLS calls that set
+  * both the master and slave control, such as for instance setting
+  * auto_exposure=1, exposure_time_absolute=251.
+  */
+ int uvc_ctrl_is_accessible(struct uvc_video_chain *chain, u32 v4l2_id,
+ 			   const struct v4l2_ext_controls *ctrls,
+ 			   unsigned long ioctl)
+ {
+ 	struct uvc_control_mapping *master_map = NULL;
+ 	struct uvc_control *master_ctrl = NULL;
+ 	struct uvc_control_mapping *mapping;
+ 	struct uvc_control *ctrl;
+ 	bool read = ioctl == VIDIOC_G_EXT_CTRLS;
+ 	s32 val;
+ 	int ret;
+ 	int i;
+ 
+ 	if (__uvc_query_v4l2_class(chain, v4l2_id, 0) >= 0)
+ 		return -EACCES;
+ 
+ 	ctrl = uvc_find_control(chain, v4l2_id, &mapping);
+ 	if (!ctrl)
+ 		return -EINVAL;
+ 
+ 	if (!(ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) && read)
+ 		return -EACCES;
+ 
+ 	if (!(ctrl->info.flags & UVC_CTRL_FLAG_SET_CUR) && !read)
+ 		return -EACCES;
+ 
+ 	if (ioctl != VIDIOC_S_EXT_CTRLS || !mapping->master_id)
+ 		return 0;
+ 
+ 	/*
+ 	 * Iterate backwards in cases where the master control is accessed
+ 	 * multiple times in the same ioctl. We want the last value.
+ 	 */
+ 	for (i = ctrls->count - 1; i >= 0; i--) {
+ 		if (ctrls->controls[i].id == mapping->master_id)
+ 			return ctrls->controls[i].value ==
+ 					mapping->master_manual ? 0 : -EACCES;
+ 	}
+ 
+ 	__uvc_find_control(ctrl->entity, mapping->master_id, &master_map,
+ 			   &master_ctrl, 0);
+ 
+ 	if (!master_ctrl || !(master_ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR))
+ 		return 0;
+ 
+ 	ret = __uvc_ctrl_get(chain, master_ctrl, master_map, &val);
+ 	if (ret >= 0 && val != mapping->master_manual)
+ 		return -EACCES;
+ 
+ 	return 0;
+ }
+ 
+ static const char *uvc_map_get_name(const struct uvc_control_mapping *map)
+ {
+ 	const char *name;
+ 
+ 	if (map->name)
+ 		return map->name;
+ 
+ 	name = v4l2_ctrl_get_name(map->id);
+ 	if (name)
+ 		return name;
+ 
+ 	return "Unknown Control";
+ }
+ 
++>>>>>>> 9f582f0418ed (media: uvcvideo: Check for INACTIVE in uvc_ctrl_is_accessible())
  static int __uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
  	struct uvc_control *ctrl,
  	struct uvc_control_mapping *mapping,
diff --cc drivers/media/usb/uvc/uvc_v4l2.c
index 858db1c4a9be,4187e59680bb..000000000000
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@@ -1000,6 -1009,25 +1000,28 @@@ static int uvc_ioctl_query_ext_ctrl(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int uvc_ctrl_check_access(struct uvc_video_chain *chain,
+ 				 struct v4l2_ext_controls *ctrls,
+ 				 unsigned long ioctl)
+ {
+ 	struct v4l2_ext_control *ctrl = ctrls->controls;
+ 	unsigned int i;
+ 	int ret = 0;
+ 
+ 	for (i = 0; i < ctrls->count; ++ctrl, ++i) {
+ 		ret = uvc_ctrl_is_accessible(chain, ctrl->id, ctrls, ioctl);
+ 		if (ret)
+ 			break;
+ 	}
+ 
+ 	ctrls->error_idx = ioctl == VIDIOC_TRY_EXT_CTRLS ? i : ctrls->count;
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 9f582f0418ed (media: uvcvideo: Check for INACTIVE in uvc_ctrl_is_accessible())
  static int uvc_ioctl_g_ext_ctrls(struct file *file, void *fh,
  				 struct v4l2_ext_controls *ctrls)
  {
diff --cc drivers/media/usb/uvc/uvcvideo.h
index f8cb9a4a588e,8c0df94374c9..000000000000
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@@ -777,6 -777,9 +777,12 @@@ static inline int uvc_ctrl_rollback(str
  
  int uvc_ctrl_get(struct uvc_video_chain *chain, struct v4l2_ext_control *xctrl);
  int uvc_ctrl_set(struct uvc_fh *handle, struct v4l2_ext_control *xctrl);
++<<<<<<< HEAD
++=======
+ int uvc_ctrl_is_accessible(struct uvc_video_chain *chain, u32 v4l2_id,
+ 			   const struct v4l2_ext_controls *ctrls,
+ 			   unsigned long ioctl);
++>>>>>>> 9f582f0418ed (media: uvcvideo: Check for INACTIVE in uvc_ctrl_is_accessible())
  
  int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
  		      struct uvc_xu_control_query *xqry);
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
* Unmerged path drivers/media/usb/uvc/uvc_v4l2.c
* Unmerged path drivers/media/usb/uvc/uvcvideo.h
