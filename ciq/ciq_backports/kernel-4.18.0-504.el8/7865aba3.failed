fork: Don't assign the stack pointer in dup_task_struct()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit 7865aba3ade4cf30f0ac08e015550084a50d9afb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/7865aba3.failed

All four versions of alloc_thread_stack_node() assign now
task_struct::stack in case the allocation was successful.

Let alloc_thread_stack_node() return an error code instead of the stack
pointer and remove the stack assignment in dup_task_struct().

	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Andy Lutomirski <luto@kernel.org>
Link: https://lore.kernel.org/r/20220217102406.3697941-5-bigeasy@linutronix.de

(cherry picked from commit 7865aba3ade4cf30f0ac08e015550084a50d9afb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/fork.c
diff --cc kernel/fork.c
index 2fc87f72c8b1,875bd43f02ca..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -881,8 -893,6 +879,11 @@@ bool dup_rh_task_struct(struct task_str
  static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
  {
  	struct task_struct *tsk;
++<<<<<<< HEAD
 +	unsigned long *stack;
 +	struct vm_struct *stack_vm_area;
++=======
++>>>>>>> 7865aba3ade4 (fork: Don't assign the stack pointer in dup_task_struct())
  	int err;
  
  	if (node == NUMA_NO_NODE)
@@@ -891,33 -901,17 +892,36 @@@
  	if (!tsk)
  		return NULL;
  
 -	err = arch_dup_task_struct(tsk, orig);
 -	if (err)
 -		goto free_tsk;
 +	/*
 +	 * RHEL: before proceeding, we need to make tsk->task_struct_rh = NULL,
 +	 * otherwise the error paths below, if taken, might end up causing
 +	 * a double-free for RHEL-only task_struct_rh extention object.
 +	 */
 +	WRITE_ONCE(tsk->task_struct_rh, NULL);
  
- 	stack = alloc_thread_stack_node(tsk, node);
- 	if (!stack)
+ 	err = alloc_thread_stack_node(tsk, node);
+ 	if (err)
  		goto free_tsk;
  
  	if (memcg_charge_kernel_stack(tsk))
  		goto free_stack;
  
++<<<<<<< HEAD
 +	stack_vm_area = task_stack_vm_area(tsk);
 +
 +	err = arch_dup_task_struct(tsk, orig);
 +
 +	/*
 +	 * arch_dup_task_struct() clobbers the stack-related fields.  Make
 +	 * sure they're properly initialized before using any stack-related
 +	 * functions again.
 +	 */
 +	tsk->stack = stack;
 +#ifdef CONFIG_VMAP_STACK
 +	tsk->stack_vm_area = stack_vm_area;
 +#endif
++=======
++>>>>>>> 7865aba3ade4 (fork: Don't assign the stack pointer in dup_task_struct())
  #ifdef CONFIG_THREAD_INFO_IN_TASK
  	refcount_set(&tsk->stack_refcount, 1);
  #endif
* Unmerged path kernel/fork.c
