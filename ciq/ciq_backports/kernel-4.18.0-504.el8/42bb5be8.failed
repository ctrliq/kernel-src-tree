driver core: device_get_devnode() should take a const *

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 42bb5be8936f40a1d0e618766645e7fd0cbfe591
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/42bb5be8.failed

device_get_devnode() should take a constant * to struct device as it
does not modify it in any way, so modify the function definition to do
this and move it out of device.h as it does not need to be exposed to
the whole kernel tree.

	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Won Chung <wonchung@google.com>
	Acked-by: Rafael J. Wysocki <rafael@kernel.org>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Acked-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/20230111113018.459199-8-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 42bb5be8936f40a1d0e618766645e7fd0cbfe591)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/base.h
#	include/linux/device.h
diff --cc drivers/base/base.h
index 68753d592f4c,2208af509ce8..000000000000
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@@ -145,6 -157,10 +145,13 @@@ void device_driver_detach(struct devic
  extern int devres_release_all(struct device *dev);
  extern void device_block_probing(void);
  extern void device_unblock_probing(void);
++<<<<<<< HEAD
++=======
+ extern void deferred_probe_extend_timeout(void);
+ extern void driver_deferred_probe_trigger(void);
+ const char *device_get_devnode(const struct device *dev, umode_t *mode,
+ 			       kuid_t *uid, kgid_t *gid, const char **tmp);
++>>>>>>> 42bb5be8936f (driver core: device_get_devnode() should take a const *)
  
  /* /sys/devices directory */
  extern struct kset *devices_kset;
diff --cc include/linux/device.h
index a1a70f61fd6c,90aaf308c259..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1663,28 -888,26 +1663,51 @@@ static inline bool dev_removable_is_val
  /*
   * High level routines for use by the bus drivers
   */
++<<<<<<< HEAD
 +extern int __must_check device_register(struct device *dev);
 +extern void device_unregister(struct device *dev);
 +extern void device_initialize(struct device *dev);
 +extern int __must_check device_add(struct device *dev);
 +extern void device_del(struct device *dev);
 +extern int device_for_each_child(struct device *dev, void *data,
 +		     int (*fn)(struct device *dev, void *data));
 +extern int device_for_each_child_reverse(struct device *dev, void *data,
 +		     int (*fn)(struct device *dev, void *data));
 +extern struct device *device_find_child(struct device *dev, void *data,
 +				int (*match)(struct device *dev, void *data));
 +extern struct device *device_find_child_by_name(struct device *parent,
 +						const char *name);
 +extern struct device *device_find_any_child(struct device *parent);
 +extern int device_rename(struct device *dev, const char *new_name);
 +extern int device_move(struct device *dev, struct device *new_parent,
 +		       enum dpm_order dpm_order);
 +extern int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);
 +extern const char *device_get_devnode(struct device *dev,
 +				      umode_t *mode, kuid_t *uid, kgid_t *gid,
 +				      const char **tmp);
 +extern int device_is_dependent(struct device *dev, void *target);
++=======
+ int __must_check device_register(struct device *dev);
+ void device_unregister(struct device *dev);
+ void device_initialize(struct device *dev);
+ int __must_check device_add(struct device *dev);
+ void device_del(struct device *dev);
+ int device_for_each_child(struct device *dev, void *data,
+ 			  int (*fn)(struct device *dev, void *data));
+ int device_for_each_child_reverse(struct device *dev, void *data,
+ 				  int (*fn)(struct device *dev, void *data));
+ struct device *device_find_child(struct device *dev, void *data,
+ 				 int (*match)(struct device *dev, void *data));
+ struct device *device_find_child_by_name(struct device *parent,
+ 					 const char *name);
+ struct device *device_find_any_child(struct device *parent);
+ 
+ int device_rename(struct device *dev, const char *new_name);
+ int device_move(struct device *dev, struct device *new_parent,
+ 		enum dpm_order dpm_order);
+ int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);
+ int device_is_dependent(struct device *dev, void *target);
++>>>>>>> 42bb5be8936f (driver core: device_get_devnode() should take a const *)
  
  static inline bool device_supports_offline(struct device *dev)
  {
* Unmerged path drivers/base/base.h
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 119464862c48..96956cdf2d60 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3652,7 +3652,7 @@ static struct device *next_device(struct klist_iter *i)
  * a name. This memory is returned in tmp and needs to be
  * freed by the caller.
  */
-const char *device_get_devnode(struct device *dev,
+const char *device_get_devnode(const struct device *dev,
 			       umode_t *mode, kuid_t *uid, kgid_t *gid,
 			       const char **tmp)
 {
* Unmerged path include/linux/device.h
