PM: domains: Allow a genpd consumer to require a synced power off

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit a9236a0aa7d7f52a974cc7eaa971fae92aa477c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/a9236a0a.failed

Some genpd providers doesn't ensure that it has turned off at hardware.
This is fine until the consumer really requires during some special
scenarios that the power domain collapse at hardware before it is
turned ON again.

An example is the reset sequence of Adreno GPU which requires that the
'gpucc cx gdsc' power domain should move to OFF state in hardware at
least once before turning in ON again to clear the internal state.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Akhil P Oommen <quic_akhilpo@quicinc.com>
	Reviewed-by: Bjorn Andersson <andersson@kernel.org>
	Signed-off-by: Bjorn Andersson <andersson@kernel.org>
Link: https://lore.kernel.org/r/20230102161757.v5.1.I3e6b1f078ad0f1ca9358c573daa7b70ec132cdbe@changeid
(cherry picked from commit a9236a0aa7d7f52a974cc7eaa971fae92aa477c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/domain.c
#	include/linux/pm_domain.h
diff --cc drivers/base/power/domain.c
index 3858ada6ecf2,84662d338188..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -496,6 -494,56 +496,59 @@@ void dev_pm_genpd_set_next_wakeup(struc
  }
  EXPORT_SYMBOL_GPL(dev_pm_genpd_set_next_wakeup);
  
++<<<<<<< HEAD
++=======
+ /**
+  * dev_pm_genpd_get_next_hrtimer - Return the next_hrtimer for the genpd
+  * @dev: A device that is attached to the genpd.
+  *
+  * This routine should typically be called for a device, at the point of when a
+  * GENPD_NOTIFY_PRE_OFF notification has been sent for it.
+  *
+  * Returns the aggregated value of the genpd's next hrtimer or KTIME_MAX if no
+  * valid value have been set.
+  */
+ ktime_t dev_pm_genpd_get_next_hrtimer(struct device *dev)
+ {
+ 	struct generic_pm_domain *genpd;
+ 
+ 	genpd = dev_to_genpd_safe(dev);
+ 	if (!genpd)
+ 		return KTIME_MAX;
+ 
+ 	if (genpd->gd)
+ 		return genpd->gd->next_hrtimer;
+ 
+ 	return KTIME_MAX;
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_genpd_get_next_hrtimer);
+ 
+ /*
+  * dev_pm_genpd_synced_poweroff - Next power off should be synchronous
+  *
+  * @dev: A device that is attached to the genpd.
+  *
+  * Allows a consumer of the genpd to notify the provider that the next power off
+  * should be synchronous.
+  *
+  * It is assumed that the users guarantee that the genpd wouldn't be detached
+  * while this routine is getting called.
+  */
+ void dev_pm_genpd_synced_poweroff(struct device *dev)
+ {
+ 	struct generic_pm_domain *genpd;
+ 
+ 	genpd = dev_to_genpd_safe(dev);
+ 	if (!genpd)
+ 		return;
+ 
+ 	genpd_lock(genpd);
+ 	genpd->synced_poweroff = true;
+ 	genpd_unlock(genpd);
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_genpd_synced_poweroff);
+ 
++>>>>>>> a9236a0aa7d7 (PM: domains: Allow a genpd consumer to require a synced power off)
  static int _genpd_power_on(struct generic_pm_domain *genpd, bool timed)
  {
  	unsigned int state_idx = genpd->state_idx;
diff --cc include/linux/pm_domain.h
index 6f175988b8ed,f776fb93eaa0..000000000000
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@@ -233,6 -235,8 +234,11 @@@ int dev_pm_genpd_set_performance_state(
  int dev_pm_genpd_add_notifier(struct device *dev, struct notifier_block *nb);
  int dev_pm_genpd_remove_notifier(struct device *dev);
  void dev_pm_genpd_set_next_wakeup(struct device *dev, ktime_t next);
++<<<<<<< HEAD
++=======
+ ktime_t dev_pm_genpd_get_next_hrtimer(struct device *dev);
+ void dev_pm_genpd_synced_poweroff(struct device *dev);
++>>>>>>> a9236a0aa7d7 (PM: domains: Allow a genpd consumer to require a synced power off)
  
  extern struct dev_power_governor simple_qos_governor;
  extern struct dev_power_governor pm_domain_always_on_gov;
@@@ -294,6 -298,13 +300,16 @@@ static inline int dev_pm_genpd_remove_n
  static inline void dev_pm_genpd_set_next_wakeup(struct device *dev, ktime_t next)
  { }
  
++<<<<<<< HEAD
++=======
+ static inline ktime_t dev_pm_genpd_get_next_hrtimer(struct device *dev)
+ {
+ 	return KTIME_MAX;
+ }
+ static inline void dev_pm_genpd_synced_poweroff(struct device *dev)
+ { }
+ 
++>>>>>>> a9236a0aa7d7 (PM: domains: Allow a genpd consumer to require a synced power off)
  #define simple_qos_governor		(*(struct dev_power_governor *)(NULL))
  #define pm_domain_always_on_gov		(*(struct dev_power_governor *)(NULL))
  #endif
* Unmerged path drivers/base/power/domain.c
* Unmerged path include/linux/pm_domain.h
