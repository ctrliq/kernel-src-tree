media: uvcvideo: Use standard names for menus

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Ricardo Ribalda <ribalda@chromium.org>
commit 716c330433e3ad6074d057092b98c09a989e17d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/716c3304.failed

Instead of duplicating the menu info, use the one from the core.
Also, do not use extra memory for 1:1 mappings.

	Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Ricardo Ribalda <ribalda@chromium.org>
	Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
(cherry picked from commit 716c330433e3ad6074d057092b98c09a989e17d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index 96f0d04388ee,ee58f0db2763..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -1313,11 -1416,8 +1343,16 @@@ int uvc_query_v4l2_menu(struct uvc_vide
  		goto done;
  	}
  
++<<<<<<< HEAD
 +	menu_info = &mapping->menu_info[query_menu->index];
 +
 +	if (mapping->data_type == UVC_CTRL_DATA_TYPE_BITMASK &&
 +	    (ctrl->info.flags & UVC_CTRL_FLAG_GET_RES)) {
 +		s32 bitmap;
++=======
+ 	if (mapping->data_type == UVC_CTRL_DATA_TYPE_BITMASK) {
+ 		int mask;
++>>>>>>> 716c330433e3 (media: uvcvideo: Use standard names for menus)
  
  		if (!ctrl->cached) {
  			ret = uvc_ctrl_populate_cache(chain, ctrl);
@@@ -1325,9 -1425,13 +1360,19 @@@
  				goto done;
  		}
  
++<<<<<<< HEAD
 +		bitmap = mapping->get(mapping, UVC_GET_RES,
 +				      uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));
 +		if (!(bitmap & menu_info->value)) {
++=======
+ 		mask = uvc_mapping_get_menu_value(mapping, query_menu->index);
+ 		if (mask < 0) {
+ 			ret = mask;
+ 			goto done;
+ 		}
+ 
+ 		if (!(uvc_get_ctrl_bitmap(ctrl, mapping) & mask)) {
++>>>>>>> 716c330433e3 (media: uvcvideo: Use standard names for menus)
  			ret = -EINVAL;
  			goto done;
  		}
@@@ -2219,16 -2365,37 +2270,47 @@@ static int __uvc_ctrl_add_mapping(struc
  	 * this could be optimized.
  	 */
  	map = kmemdup(mapping, sizeof(*mapping), GFP_KERNEL);
 -	if (!map)
 +	if (map == NULL)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&map->ev_subs);
 +
 +	size = sizeof(*mapping->menu_info) * fls(mapping->menu_mask);
 +	map->menu_info = kmemdup(mapping->menu_info, size, GFP_KERNEL);
 +	if (map->menu_info == NULL) {
 +		kfree(map);
 +		return -ENOMEM;
++=======
+ 	map->name = NULL;
+ 	map->menu_names = NULL;
+ 	map->menu_mapping = NULL;
+ 
+ 	/* For UVCIOC_CTRL_MAP custom control */
+ 	if (mapping->name) {
+ 		map->name = kstrdup(mapping->name, GFP_KERNEL);
+ 		if (!map->name)
+ 			goto err_nomem;
+ 	}
+ 
+ 	INIT_LIST_HEAD(&map->ev_subs);
+ 
+ 	if (mapping->menu_mapping && mapping->menu_mask) {
+ 		size = sizeof(mapping->menu_mapping[0])
+ 		       * fls(mapping->menu_mask);
+ 		map->menu_mapping = kmemdup(mapping->menu_mapping, size,
+ 					    GFP_KERNEL);
+ 		if (!map->menu_mapping)
+ 			goto err_nomem;
+ 	}
+ 	if (mapping->menu_names && mapping->menu_mask) {
+ 		size = sizeof(mapping->menu_names[0])
+ 		       * fls(mapping->menu_mask);
+ 		map->menu_names = kmemdup(mapping->menu_names, size,
+ 					  GFP_KERNEL);
+ 		if (!map->menu_names)
+ 			goto err_nomem;
++>>>>>>> 716c330433e3 (media: uvcvideo: Use standard names for menus)
  	}
  
  	if (map->get == NULL)
@@@ -2246,9 -2413,17 +2328,19 @@@
  
  	list_add_tail(&map->list, &ctrl->info.mappings);
  	uvc_dbg(chain->dev, CONTROL, "Adding mapping '%s' to control %pUl/%u\n",
 -		uvc_map_get_name(map), ctrl->info.entity,
 -		ctrl->info.selector);
 +		map->name, ctrl->info.entity, ctrl->info.selector);
  
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_nomem:
+ 	kfree(map->menu_names);
+ 	kfree(map->menu_mapping);
+ 	kfree(map->name);
+ 	kfree(map);
+ 	return -ENOMEM;
++>>>>>>> 716c330433e3 (media: uvcvideo: Use standard names for menus)
  }
  
  int uvc_ctrl_add_mapping(struct uvc_video_chain *chain,
@@@ -2570,7 -2745,9 +2662,13 @@@ static void uvc_ctrl_cleanup_mappings(s
  
  	list_for_each_entry_safe(mapping, nm, &ctrl->info.mappings, list) {
  		list_del(&mapping->list);
++<<<<<<< HEAD
 +		kfree(mapping->menu_info);
++=======
+ 		kfree(mapping->menu_names);
+ 		kfree(mapping->menu_mapping);
+ 		kfree(mapping->name);
++>>>>>>> 716c330433e3 (media: uvcvideo: Use standard names for menus)
  		kfree(mapping);
  	}
  }
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
diff --git a/drivers/media/usb/uvc/uvc_v4l2.c b/drivers/media/usb/uvc/uvc_v4l2.c
index 598584053114..2b5715dcb209 100644
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@ -26,14 +26,84 @@
 
 #include "uvcvideo.h"
 
+static int uvc_control_add_xu_mapping(struct uvc_video_chain *chain,
+				      struct uvc_control_mapping *map,
+				      const struct uvc_xu_control_mapping *xmap)
+{
+	unsigned int i;
+	size_t size;
+	int ret;
+
+	/*
+	 * Prevent excessive memory consumption, as well as integer
+	 * overflows.
+	 */
+	if (xmap->menu_count == 0 ||
+	    xmap->menu_count > UVC_MAX_CONTROL_MENU_ENTRIES)
+		return -EINVAL;
+
+	map->menu_names = NULL;
+	map->menu_mapping = NULL;
+
+	map->menu_mask = BIT_MASK(xmap->menu_count);
+
+	size = xmap->menu_count * sizeof(*map->menu_mapping);
+	map->menu_mapping = kzalloc(size, GFP_KERNEL);
+	if (!map->menu_mapping) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	for (i = 0; i < xmap->menu_count ; i++) {
+		if (copy_from_user((u32 *)&map->menu_mapping[i],
+				   &xmap->menu_info[i].value,
+				   sizeof(map->menu_mapping[i]))) {
+			ret = -EACCES;
+			goto done;
+		}
+	}
+
+	/*
+	 * Always use the standard naming if available, otherwise copy the
+	 * names supplied by userspace.
+	 */
+	if (!v4l2_ctrl_get_menu(map->id)) {
+		size = xmap->menu_count * sizeof(map->menu_names[0]);
+		map->menu_names = kzalloc(size, GFP_KERNEL);
+		if (!map->menu_names) {
+			ret = -ENOMEM;
+			goto done;
+		}
+
+		for (i = 0; i < xmap->menu_count ; i++) {
+			/* sizeof(names[i]) - 1: to take care of \0 */
+			if (copy_from_user((char *)map->menu_names[i],
+					   xmap->menu_info[i].name,
+					   sizeof(map->menu_names[i]) - 1)) {
+				ret = -EACCES;
+				goto done;
+			}
+		}
+	}
+
+	ret = uvc_ctrl_add_mapping(chain, map);
+
+done:
+	kfree(map->menu_names);
+	map->menu_names = NULL;
+	kfree(map->menu_mapping);
+	map->menu_mapping = NULL;
+
+	return ret;
+}
+
 /* ------------------------------------------------------------------------
  * UVC ioctls
  */
-static int uvc_ioctl_ctrl_map(struct uvc_video_chain *chain,
-	struct uvc_xu_control_mapping *xmap)
+static int uvc_ioctl_xu_ctrl_map(struct uvc_video_chain *chain,
+				 struct uvc_xu_control_mapping *xmap)
 {
 	struct uvc_control_mapping *map;
-	unsigned int size;
 	int ret;
 
 	map = kzalloc(sizeof(*map), GFP_KERNEL);
@@ -53,39 +123,20 @@ static int uvc_ioctl_ctrl_map(struct uvc_video_chain *chain,
 	case V4L2_CTRL_TYPE_INTEGER:
 	case V4L2_CTRL_TYPE_BOOLEAN:
 	case V4L2_CTRL_TYPE_BUTTON:
+		ret = uvc_ctrl_add_mapping(chain, map);
 		break;
 
 	case V4L2_CTRL_TYPE_MENU:
-		/*
-		 * Prevent excessive memory consumption, as well as integer
-		 * overflows.
-		 */
-		if (xmap->menu_count == 0 ||
-		    xmap->menu_count > UVC_MAX_CONTROL_MENU_ENTRIES) {
-			ret = -EINVAL;
-			goto free_map;
-		}
-
-		size = xmap->menu_count * sizeof(*map->menu_info);
-		map->menu_info = memdup_user(xmap->menu_info, size);
-		if (IS_ERR(map->menu_info)) {
-			ret = PTR_ERR(map->menu_info);
-			goto free_map;
-		}
-
-		map->menu_mask = GENMASK(xmap->menu_count - 1, 0);
+		ret = uvc_control_add_xu_mapping(chain, map, xmap);
 		break;
 
 	default:
 		uvc_dbg(chain->dev, CONTROL,
 			"Unsupported V4L2 control type %u\n", xmap->v4l2_type);
 		ret = -ENOTTY;
-		goto free_map;
+		break;
 	}
 
-	ret = uvc_ctrl_add_mapping(chain, map);
-
-	kfree(map->menu_info);
 free_map:
 	kfree(map);
 
@@ -1277,7 +1328,7 @@ static long uvc_ioctl_default(struct file *file, void *fh, bool valid_prio,
 	switch (cmd) {
 	/* Dynamic controls. */
 	case UVCIOC_CTRL_MAP:
-		return uvc_ioctl_ctrl_map(chain, arg);
+		return uvc_ioctl_xu_ctrl_map(chain, arg);
 
 	case UVCIOC_CTRL_QUERY:
 		return uvc_xu_ctrl_query(chain, arg);
@@ -1390,7 +1441,7 @@ static long uvc_v4l2_compat_ioctl32(struct file *file,
 		ret = uvc_v4l2_get_xu_mapping(&karg.xmap, up);
 		if (ret)
 			return ret;
-		ret = uvc_ioctl_ctrl_map(handle->chain, &karg.xmap);
+		ret = uvc_ioctl_xu_ctrl_map(handle->chain, &karg.xmap);
 		if (ret)
 			return ret;
 		ret = uvc_v4l2_put_xu_mapping(&karg.xmap, up);
diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
index ef01fe44dd3b..72f16170d364 100644
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@ -113,7 +113,8 @@ struct uvc_control_mapping {
 	enum v4l2_ctrl_type v4l2_type;
 	u32 data_type;
 
-	const struct uvc_menu_info *menu_info;
+	const u32 *menu_mapping;
+	const char (*menu_names)[UVC_MENU_NAME_LEN];
 	unsigned long menu_mask;
 
 	u32 master_id;
diff --git a/include/uapi/linux/uvcvideo.h b/include/uapi/linux/uvcvideo.h
index f80f05b3c423..21233b4e712f 100644
--- a/include/uapi/linux/uvcvideo.h
+++ b/include/uapi/linux/uvcvideo.h
@@ -36,9 +36,11 @@
 	 UVC_CTRL_FLAG_GET_MAX | UVC_CTRL_FLAG_GET_RES | \
 	 UVC_CTRL_FLAG_GET_DEF)
 
+#define UVC_MENU_NAME_LEN 32
+
 struct uvc_menu_info {
 	__u32 value;
-	__u8 name[32];
+	__u8 name[UVC_MENU_NAME_LEN];
 };
 
 struct uvc_xu_control_mapping {
