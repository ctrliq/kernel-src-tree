driver core: create bus_is_registered()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 63b823d7d3cd275c3347233f95bdf966a595dbc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/63b823d7.failed

A local function to the driver core to determine if a bus really is
registered with the kernel or not.  To be used only by the driver core
code, as part of the driver registration path as it's not really "safe"
because the bus could be unregistered instantly after being called.

	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
Link: https://lore.kernel.org/r/20230208111330.439504-17-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 63b823d7d3cd275c3347233f95bdf966a595dbc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/base.h
diff --cc drivers/base/base.h
index dde75e81f0d3,726a12a244c0..000000000000
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@@ -131,6 -145,8 +131,11 @@@ struct kobject *virtual_device_parent(s
  extern int bus_add_device(struct device *dev);
  extern void bus_probe_device(struct device *dev);
  extern void bus_remove_device(struct device *dev);
++<<<<<<< HEAD
++=======
+ void bus_notify(struct device *dev, enum bus_notifier_event value);
+ bool bus_is_registered(const struct bus_type *bus);
++>>>>>>> 63b823d7d3cd (driver core: create bus_is_registered())
  
  extern int bus_add_driver(struct device_driver *drv);
  extern void bus_remove_driver(struct device_driver *drv);
* Unmerged path drivers/base/base.h
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 9276fb51f7b7..f0597c7c269f 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -1316,6 +1316,22 @@ struct device_driver *driver_find(const char *name, struct bus_type *bus)
 }
 EXPORT_SYMBOL_GPL(driver_find);
 
+/*
+ * Warning, the value could go to "removed" instantly after calling this function, so be very
+ * careful when calling it...
+ */
+bool bus_is_registered(const struct bus_type *bus)
+{
+	struct subsys_private *sp = bus_to_subsys(bus);
+	bool is_initialized = false;
+
+	if (sp) {
+		is_initialized = true;
+		subsys_put(sp);
+	}
+	return is_initialized;
+}
+
 int __init buses_init(void)
 {
 	bus_kset = kset_create_and_add("bus", &bus_uevent_ops, NULL);
diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 62e7ec8e9fe6..d6991e55c64d 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -223,7 +223,7 @@ int driver_register(struct device_driver *drv)
 	int ret;
 	struct device_driver *other;
 
-	if (!drv->bus->p) {
+	if (!bus_is_registered(drv->bus)) {
 		pr_err("Driver '%s' was unable to register with bus_type '%s' because the bus was not initialized.\n",
 			   drv->name, drv->bus->name);
 		return -EINVAL;
