media: v4l2-common: add bayer formats in v4l2_format_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Helen Fornazier <helen.koike@collabora.com>
commit d82b921a7a8a00ec31ba76287245ec663534df9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/d82b921a.failed

Add bayer format information in struct v4l2_format_info table.

	Signed-off-by: Helen Koike <helen.koike@collabora.com>
	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
(cherry picked from commit d82b921a7a8a00ec31ba76287245ec663534df9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/v4l2-core/v4l2-common.c
diff --cc drivers/media/v4l2-core/v4l2-common.c
index e0e7a9a9518d,b5778b2ffa27..000000000000
--- a/drivers/media/v4l2-core/v4l2-common.c
+++ b/drivers/media/v4l2-core/v4l2-common.c
@@@ -445,88 -446,188 +445,189 @@@ int v4l2_s_parm_cap(struct video_devic
  }
  EXPORT_SYMBOL_GPL(v4l2_s_parm_cap);
  
 -const struct v4l2_format_info *v4l2_format_info(u32 format)
 +/*
 + * Simplify a fraction using a simple continued fraction decomposition. The
 + * idea here is to convert fractions such as 333333/10000000 to 1/30 using
 + * 32 bit arithmetic only. The algorithm is not perfect and relies upon two
 + * arbitrary parameters to remove non-significative terms from the simple
 + * continued fraction decomposition. Using 8 and 333 for n_terms and threshold
 + * respectively seems to give nice results.
 + */
 +void v4l2_simplify_fraction(u32 *numerator, u32 *denominator,
 +		unsigned int n_terms, unsigned int threshold)
  {
 -	static const struct v4l2_format_info formats[] = {
 -		/* RGB formats */
 -		{ .format = V4L2_PIX_FMT_BGR24,   .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_RGB24,   .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_HSV24,   .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_BGR32,   .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_XBGR32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_RGB32,   .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_XRGB32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_HSV32,   .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_ARGB32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_ABGR32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_GREY,    .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -
 -		/* YUV packed formats */
 -		{ .format = V4L2_PIX_FMT_YUYV,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_YVYU,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_UYVY,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_VYUY,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -
 -		/* YUV planar formats */
 -		{ .format = V4L2_PIX_FMT_NV12,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
 -		{ .format = V4L2_PIX_FMT_NV21,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
 -		{ .format = V4L2_PIX_FMT_NV16,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_NV61,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_NV24,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_NV42,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 +	u32 *an;
 +	u32 x, y, r;
 +	unsigned int i, n;
  
 +	an = kmalloc_array(n_terms, sizeof(*an), GFP_KERNEL);
 +	if (an == NULL)
 +		return;
 +
 +	/*
 +	 * Convert the fraction to a simple continued fraction. See
 +	 * https://en.wikipedia.org/wiki/Continued_fraction
 +	 * Stop if the current term is bigger than or equal to the given
 +	 * threshold.
 +	 */
 +	x = *numerator;
 +	y = *denominator;
 +
++<<<<<<< HEAD
 +	for (n = 0; n < n_terms && y != 0; ++n) {
 +		an[n] = x / y;
 +		if (an[n] >= threshold) {
 +			if (n < 2)
 +				n++;
 +			break;
++=======
+ 		{ .format = V4L2_PIX_FMT_YUV410,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 4 },
+ 		{ .format = V4L2_PIX_FMT_YVU410,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 4 },
+ 		{ .format = V4L2_PIX_FMT_YUV411P, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YUV420,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YVU420,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YUV422P, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		/* YUV planar formats, non contiguous variant */
+ 		{ .format = V4L2_PIX_FMT_YUV420M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YVU420M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YUV422M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVU422M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YUV444M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVU444M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 1, .vdiv = 1 },
+ 
+ 		{ .format = V4L2_PIX_FMT_NV12M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV21M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV16M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_NV61M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		/* Bayer RGB formats */
+ 		{ .format = V4L2_PIX_FMT_SBGGR8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 	};
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(formats); ++i)
+ 		if (formats[i].format == format)
+ 			return &formats[i];
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(v4l2_format_info);
+ 
+ static inline unsigned int v4l2_format_block_width(const struct v4l2_format_info *info, int plane)
+ {
+ 	if (!info->block_w[plane])
+ 		return 1;
+ 	return info->block_w[plane];
+ }
+ 
+ static inline unsigned int v4l2_format_block_height(const struct v4l2_format_info *info, int plane)
+ {
+ 	if (!info->block_h[plane])
+ 		return 1;
+ 	return info->block_h[plane];
+ }
+ 
+ int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,
+ 			 int pixelformat, int width, int height)
+ {
+ 	const struct v4l2_format_info *info;
+ 	struct v4l2_plane_pix_format *plane;
+ 	int i;
+ 
+ 	info = v4l2_format_info(pixelformat);
+ 	if (!info)
+ 		return -EINVAL;
+ 
+ 	pixfmt->width = width;
+ 	pixfmt->height = height;
+ 	pixfmt->pixelformat = pixelformat;
+ 	pixfmt->num_planes = info->mem_planes;
+ 
+ 	if (info->mem_planes == 1) {
+ 		plane = &pixfmt->plane_fmt[0];
+ 		plane->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
+ 		plane->sizeimage = 0;
+ 
+ 		for (i = 0; i < info->comp_planes; i++) {
+ 			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+ 			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+ 			unsigned int aligned_width;
+ 			unsigned int aligned_height;
+ 
+ 			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
+ 			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
+ 
+ 			plane->sizeimage += info->bpp[i] *
+ 				DIV_ROUND_UP(aligned_width, hdiv) *
+ 				DIV_ROUND_UP(aligned_height, vdiv);
++>>>>>>> d82b921a7a8a (media: v4l2-common: add bayer formats in v4l2_format_info)
  		}
 -	} else {
 -		for (i = 0; i < info->comp_planes; i++) {
 -			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -			unsigned int aligned_width;
 -			unsigned int aligned_height;
  
 -			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
 -
 -			plane = &pixfmt->plane_fmt[i];
 -			plane->bytesperline =
 -				info->bpp[i] * DIV_ROUND_UP(aligned_width, hdiv);
 -			plane->sizeimage =
 -				plane->bytesperline * DIV_ROUND_UP(aligned_height, vdiv);
 -		}
 +		r = x - an[n] * y;
 +		x = y;
 +		y = r;
  	}
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt_mp);
 -
 -int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, int pixelformat, int width, int height)
 -{
 -	const struct v4l2_format_info *info;
 -	int i;
 -
 -	info = v4l2_format_info(pixelformat);
 -	if (!info)
 -		return -EINVAL;
 -
 -	/* Single planar API cannot be used for multi plane formats. */
 -	if (info->mem_planes > 1)
 -		return -EINVAL;
  
 -	pixfmt->width = width;
 -	pixfmt->height = height;
 -	pixfmt->pixelformat = pixelformat;
 -	pixfmt->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
 -	pixfmt->sizeimage = 0;
 +	/* Expand the simple continued fraction back to an integer fraction. */
 +	x = 0;
 +	y = 1;
  
 -	for (i = 0; i < info->comp_planes; i++) {
 -		unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -		unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -		unsigned int aligned_width;
 -		unsigned int aligned_height;
 +	for (i = n; i > 0; --i) {
 +		r = y;
 +		y = an[i-1] * y + x;
 +		x = r;
 +	}
  
 -		aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -		aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
 +	*numerator = y;
 +	*denominator = x;
 +	kfree(an);
 +}
 +EXPORT_SYMBOL_GPL(v4l2_simplify_fraction);
  
 -		pixfmt->sizeimage += info->bpp[i] *
 -			DIV_ROUND_UP(aligned_width, hdiv) *
 -			DIV_ROUND_UP(aligned_height, vdiv);
 +/*
 + * Convert a fraction to a frame interval in 100ns multiples. The idea here is
 + * to compute numerator / denominator * 10000000 using 32 bit fixed point
 + * arithmetic only.
 + */
 +u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator)
 +{
 +	u32 multiplier;
 +
 +	/* Saturate the result if the operation would overflow. */
 +	if (denominator == 0 ||
 +	    numerator/denominator >= ((u32)-1)/10000000)
 +		return (u32)-1;
 +
 +	/*
 +	 * Divide both the denominator and the multiplier by two until
 +	 * numerator * multiplier doesn't overflow. If anyone knows a better
 +	 * algorithm please let me know.
 +	 */
 +	multiplier = 10000000;
 +	while (numerator > ((u32)-1)/multiplier) {
 +		multiplier /= 2;
 +		denominator /= 2;
  	}
 -	return 0;
 +
 +	return denominator ? numerator * multiplier / denominator : 0;
  }
 -EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt);
 +EXPORT_SYMBOL_GPL(v4l2_fraction_to_interval);
* Unmerged path drivers/media/v4l2-core/v4l2-common.c
