driver core: fw_devlink: Print full path and name of fwnode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 0c058fb94ae0e2a68639f4569de1c3abf5df7ad7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/0c058fb9.failed

Some of the log messages were printing just the fwnode name. While it's
short, it's not always uniquely identifiable in system. So print the
full path and name to make debugging easier.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20230225065443.278284-1-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 0c058fb94ae0e2a68639f4569de1c3abf5df7ad7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
diff --cc drivers/base/core.c
index b0263a91a9d2,6878dfcbf0d6..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -1031,18 -1056,20 +1031,31 @@@ int device_links_check_suppliers(struc
  	 * Device waiting for supplier to become available is not allowed to
  	 * probe.
  	 */
++<<<<<<< HEAD
 +        mutex_lock(&fwnode_link_lock);
 +	if (dev->fwnode && !list_empty(&dev->fwnode->suppliers) &&
 +	    !fw_devlink_is_permissive()) {
 +		sup_fw = list_first_entry(&dev->fwnode->suppliers,
 +					  struct fwnode_link,
 +					  c_hook)->supplier;
 +		dev_err_probe(dev, -EPROBE_DEFER, "wait for supplier %pfwP\n",
 +			      sup_fw);
 +		mutex_unlock(&fwnode_link_lock);
 +		return -EPROBE_DEFER;
++=======
+ 	mutex_lock(&fwnode_link_lock);
+ 	sup_fw = fwnode_links_check_suppliers(dev->fwnode);
+ 	if (sup_fw) {
+ 		if (!dev_is_best_effort(dev)) {
+ 			fwnode_ret = -EPROBE_DEFER;
+ 			dev_err_probe(dev, -EPROBE_DEFER,
+ 				    "wait for supplier %pfwf\n", sup_fw);
+ 		} else {
+ 			fwnode_ret = -EAGAIN;
+ 		}
++>>>>>>> 0c058fb94ae0 (driver core: fw_devlink: Print full path and name of fwnode)
  	}
  	mutex_unlock(&fwnode_link_lock);
 -	if (fwnode_ret == -EPROBE_DEFER)
 -		return fwnode_ret;
  
  	device_links_write_lock();
  
* Unmerged path drivers/base/core.c
