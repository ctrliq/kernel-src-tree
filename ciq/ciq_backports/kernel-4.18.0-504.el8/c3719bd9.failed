cacheinfo: Use RISC-V's init_cache_level() as generic OF implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Pierre Gondois <pierre.gondois@arm.com>
commit c3719bd9eeb2edf84bd263d662e36ca0ba262a23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/c3719bd9.failed

RISC-V's implementation of init_of_cache_level() is following
the Devicetree Specification v0.3 regarding caches, cf.:
- s3.7.3 'Internal (L1) Cache Properties'
- s3.8 'Multi-level and Shared Cache Nodes'

Allow reusing the implementation by moving it.

Also make 'levels', 'leaves' and 'level' unsigned int.

	Signed-off-by: Pierre Gondois <pierre.gondois@arm.com>
	Reviewed-by: Conor Dooley <conor.dooley@microchip.com>
	Acked-by: Palmer Dabbelt <palmer@rivosinc.com>
Link: https://lore.kernel.org/r/20230104183033.755668-2-pierre.gondois@arm.com
	Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
(cherry picked from commit c3719bd9eeb2edf84bd263d662e36ca0ba262a23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/riscv/kernel/cacheinfo.c
diff --cc arch/riscv/kernel/cacheinfo.c
index 0bc86e5f8f3f,440a3df5944c..000000000000
--- a/arch/riscv/kernel/cacheinfo.c
+++ b/arch/riscv/kernel/cacheinfo.c
@@@ -22,52 -70,55 +22,56 @@@ static void ci_leaf_init(struct cachein
  {
  	this_leaf->level = level;
  	this_leaf->type = type;
 -	this_leaf->size = size;
 -	this_leaf->number_of_sets = sets;
 -	this_leaf->coherency_line_size = line_size;
 -
 -	/*
 -	 * If the cache is fully associative, there is no need to
 -	 * check the other properties.
 -	 */
 -	if (sets == 1)
 -		return;
 -
 -	/*
 -	 * Set the ways number for n-ways associative, make sure
 -	 * all properties are big than zero.
 -	 */
 -	if (sets > 0 && size > 0 && line_size > 0)
 -		this_leaf->ways_of_associativity = (size / sets) / line_size;
 +	/* not a sector cache */
 +	this_leaf->physical_line_partition = 1;
 +	/* TODO: Add to DTS */
 +	this_leaf->attributes =
 +		CACHE_WRITE_BACK
 +		| CACHE_READ_ALLOCATE
 +		| CACHE_WRITE_ALLOCATE;
  }
  
 -static void fill_cacheinfo(struct cacheinfo **this_leaf,
 -			   struct device_node *node, unsigned int level)
 +static int __init_cache_level(unsigned int cpu)
  {
 -	unsigned int size, sets, line_size;
 -
 -	if (!of_property_read_u32(node, "cache-size", &size) &&
 -	    !of_property_read_u32(node, "cache-block-size", &line_size) &&
 -	    !of_property_read_u32(node, "cache-sets", &sets)) {
 -		ci_leaf_init((*this_leaf)++, CACHE_TYPE_UNIFIED, level, size, sets, line_size);
 -	}
++<<<<<<< HEAD
 +	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
 +	struct device_node *np = of_cpu_device_node_get(cpu);
 +	int levels = 0, leaves = 0, level;
  
 -	if (!of_property_read_u32(node, "i-cache-size", &size) &&
 -	    !of_property_read_u32(node, "i-cache-sets", &sets) &&
 -	    !of_property_read_u32(node, "i-cache-block-size", &line_size)) {
 -		ci_leaf_init((*this_leaf)++, CACHE_TYPE_INST, level, size, sets, line_size);
 -	}
 +	if (of_property_read_bool(np, "cache-size"))
 +		++leaves;
 +	if (of_property_read_bool(np, "i-cache-size"))
 +		++leaves;
 +	if (of_property_read_bool(np, "d-cache-size"))
 +		++leaves;
 +	if (leaves > 0)
 +		levels = 1;
  
 -	if (!of_property_read_u32(node, "d-cache-size", &size) &&
 -	    !of_property_read_u32(node, "d-cache-sets", &sets) &&
 -	    !of_property_read_u32(node, "d-cache-block-size", &line_size)) {
 -		ci_leaf_init((*this_leaf)++, CACHE_TYPE_DATA, level, size, sets, line_size);
 +	while ((np = of_find_next_cache_node(np))) {
 +		if (!of_device_is_compatible(np, "cache"))
 +			break;
 +		if (of_property_read_u32(np, "cache-level", &level))
 +			break;
 +		if (level <= levels)
 +			break;
 +		if (of_property_read_bool(np, "cache-size"))
 +			++leaves;
 +		if (of_property_read_bool(np, "i-cache-size"))
 +			++leaves;
 +		if (of_property_read_bool(np, "d-cache-size"))
 +			++leaves;
 +		levels = level;
  	}
 -}
  
 -int init_cache_level(unsigned int cpu)
 -{
 +	this_cpu_ci->num_levels = levels;
 +	this_cpu_ci->num_leaves = leaves;
 +	return 0;
++=======
+ 	return init_of_cache_level(cpu);
++>>>>>>> c3719bd9eeb2 (cacheinfo: Use RISC-V's init_cache_level() as generic OF implementation)
  }
  
 -int populate_cache_leaves(unsigned int cpu)
 +static int __populate_cache_leaves(unsigned int cpu)
  {
  	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
  	struct cacheinfo *this_leaf = this_cpu_ci->info_list;
* Unmerged path arch/riscv/kernel/cacheinfo.c
diff --git a/drivers/base/cacheinfo.c b/drivers/base/cacheinfo.c
index af78a16b124e..6fe3f774fb47 100644
--- a/drivers/base/cacheinfo.c
+++ b/drivers/base/cacheinfo.c
@@ -235,8 +235,52 @@ static int cache_setup_of_node(unsigned int cpu)
 
 	return 0;
 }
+
+int init_of_cache_level(unsigned int cpu)
+{
+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+	struct device_node *np = of_cpu_device_node_get(cpu);
+	struct device_node *prev = NULL;
+	unsigned int levels = 0, leaves = 0, level;
+
+	if (of_property_read_bool(np, "cache-size"))
+		++leaves;
+	if (of_property_read_bool(np, "i-cache-size"))
+		++leaves;
+	if (of_property_read_bool(np, "d-cache-size"))
+		++leaves;
+	if (leaves > 0)
+		levels = 1;
+
+	prev = np;
+	while ((np = of_find_next_cache_node(np))) {
+		of_node_put(prev);
+		prev = np;
+		if (!of_device_is_compatible(np, "cache"))
+			break;
+		if (of_property_read_u32(np, "cache-level", &level))
+			break;
+		if (level <= levels)
+			break;
+		if (of_property_read_bool(np, "cache-size"))
+			++leaves;
+		if (of_property_read_bool(np, "i-cache-size"))
+			++leaves;
+		if (of_property_read_bool(np, "d-cache-size"))
+			++leaves;
+		levels = level;
+	}
+
+	of_node_put(np);
+	this_cpu_ci->num_levels = levels;
+	this_cpu_ci->num_leaves = leaves;
+
+	return 0;
+}
+
 #else
 static inline int cache_setup_of_node(unsigned int cpu) { return 0; }
+int init_of_cache_level(unsigned int cpu) { return 0; }
 #endif
 
 int __weak cache_setup_acpi(unsigned int cpu)
diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 4e1991815e78..51b0699dc617 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -99,6 +99,7 @@ int func(unsigned int cpu)					\
 
 struct cpu_cacheinfo *get_cpu_cacheinfo(unsigned int cpu);
 int init_cache_level(unsigned int cpu);
+int init_of_cache_level(unsigned int cpu);
 int populate_cache_leaves(unsigned int cpu);
 int cache_setup_acpi(unsigned int cpu);
 bool last_level_cache_is_valid(unsigned int cpu);
