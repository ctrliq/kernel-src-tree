media: v4l2-common: Add an helper to apply frmsize constraints

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Boris Brezillon <boris.brezillon@collabora.com>
commit 32cddf9c94d81c4cd3c63fd1fe8ea9b98feac7e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/32cddf9c.failed

The rockchip VPU driver is open-coding this logic which seems pretty
generic. Let's provide an helper to apply the min/max and alignment
constraints on width/height.

	Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
(cherry picked from commit 32cddf9c94d81c4cd3c63fd1fe8ea9b98feac7e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/v4l2-core/v4l2-common.c
#	include/media/v4l2-common.h
diff --cc drivers/media/v4l2-core/v4l2-common.c
index e0e7a9a9518d,f8ad1c580a3e..000000000000
--- a/drivers/media/v4l2-core/v4l2-common.c
+++ b/drivers/media/v4l2-core/v4l2-common.c
@@@ -445,88 -446,206 +455,206 @@@ int v4l2_s_parm_cap(struct video_devic
  }
  EXPORT_SYMBOL_GPL(v4l2_s_parm_cap);
  
 -const struct v4l2_format_info *v4l2_format_info(u32 format)
 +/*
 + * Simplify a fraction using a simple continued fraction decomposition. The
 + * idea here is to convert fractions such as 333333/10000000 to 1/30 using
 + * 32 bit arithmetic only. The algorithm is not perfect and relies upon two
 + * arbitrary parameters to remove non-significative terms from the simple
 + * continued fraction decomposition. Using 8 and 333 for n_terms and threshold
 + * respectively seems to give nice results.
 + */
 +void v4l2_simplify_fraction(u32 *numerator, u32 *denominator,
 +		unsigned int n_terms, unsigned int threshold)
  {
 -	static const struct v4l2_format_info formats[] = {
 -		/* RGB formats */
 -		{ .format = V4L2_PIX_FMT_BGR24,   .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_RGB24,   .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_HSV24,   .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_BGR32,   .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_XBGR32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_RGB32,   .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_XRGB32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_HSV32,   .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_ARGB32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_ABGR32,  .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_GREY,    .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -
 -		/* YUV packed formats */
 -		{ .format = V4L2_PIX_FMT_YUYV,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_YVYU,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_UYVY,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_VYUY,    .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -
 -		/* YUV planar formats */
 -		{ .format = V4L2_PIX_FMT_NV12,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
 -		{ .format = V4L2_PIX_FMT_NV21,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
 -		{ .format = V4L2_PIX_FMT_NV16,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_NV61,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_NV24,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 -		{ .format = V4L2_PIX_FMT_NV42,    .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 1, .vdiv = 1 },
 +	u32 *an;
 +	u32 x, y, r;
 +	unsigned int i, n;
 +
 +	an = kmalloc_array(n_terms, sizeof(*an), GFP_KERNEL);
 +	if (an == NULL)
 +		return;
  
 +	/*
 +	 * Convert the fraction to a simple continued fraction. See
 +	 * https://en.wikipedia.org/wiki/Continued_fraction
 +	 * Stop if the current term is bigger than or equal to the given
 +	 * threshold.
 +	 */
 +	x = *numerator;
 +	y = *denominator;
 +
++<<<<<<< HEAD
 +	for (n = 0; n < n_terms && y != 0; ++n) {
 +		an[n] = x / y;
 +		if (an[n] >= threshold) {
 +			if (n < 2)
 +				n++;
 +			break;
++=======
+ 		{ .format = V4L2_PIX_FMT_YUV410,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 4 },
+ 		{ .format = V4L2_PIX_FMT_YVU410,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 4 },
+ 		{ .format = V4L2_PIX_FMT_YUV411P, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 4, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YUV420,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YVU420,  .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YUV422P, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		/* YUV planar formats, non contiguous variant */
+ 		{ .format = V4L2_PIX_FMT_YUV420M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YVU420M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_YUV422M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVU422M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YUV444M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_YVU444M, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .hdiv = 1, .vdiv = 1 },
+ 
+ 		{ .format = V4L2_PIX_FMT_NV12M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV21M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2 },
+ 		{ .format = V4L2_PIX_FMT_NV16M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_NV61M,   .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1 },
+ 
+ 		/* Bayer RGB formats */
+ 		{ .format = V4L2_PIX_FMT_SBGGR8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10ALAW8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB10DPCM8,	.mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SBGGR12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGBRG12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SGRBG12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 		{ .format = V4L2_PIX_FMT_SRGGB12,	.mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .hdiv = 1, .vdiv = 1 },
+ 	};
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(formats); ++i)
+ 		if (formats[i].format == format)
+ 			return &formats[i];
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(v4l2_format_info);
+ 
+ static inline unsigned int v4l2_format_block_width(const struct v4l2_format_info *info, int plane)
+ {
+ 	if (!info->block_w[plane])
+ 		return 1;
+ 	return info->block_w[plane];
+ }
+ 
+ static inline unsigned int v4l2_format_block_height(const struct v4l2_format_info *info, int plane)
+ {
+ 	if (!info->block_h[plane])
+ 		return 1;
+ 	return info->block_h[plane];
+ }
+ 
+ void v4l2_apply_frmsize_constraints(u32 *width, u32 *height,
+ 				    const struct v4l2_frmsize_stepwise *frmsize)
+ {
+ 	if (!frmsize)
+ 		return;
+ 
+ 	/*
+ 	 * Clamp width/height to meet min/max constraints and round it up to
+ 	 * macroblock alignment.
+ 	 */
+ 	*width = clamp_roundup(*width, frmsize->min_width, frmsize->max_width,
+ 			       frmsize->step_width);
+ 	*height = clamp_roundup(*height, frmsize->min_height, frmsize->max_height,
+ 				frmsize->step_height);
+ }
+ EXPORT_SYMBOL_GPL(v4l2_apply_frmsize_constraints);
+ 
+ int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,
+ 			u32 pixelformat, u32 width, u32 height)
+ {
+ 	const struct v4l2_format_info *info;
+ 	struct v4l2_plane_pix_format *plane;
+ 	int i;
+ 
+ 	info = v4l2_format_info(pixelformat);
+ 	if (!info)
+ 		return -EINVAL;
+ 
+ 	pixfmt->width = width;
+ 	pixfmt->height = height;
+ 	pixfmt->pixelformat = pixelformat;
+ 	pixfmt->num_planes = info->mem_planes;
+ 
+ 	if (info->mem_planes == 1) {
+ 		plane = &pixfmt->plane_fmt[0];
+ 		plane->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
+ 		plane->sizeimage = 0;
+ 
+ 		for (i = 0; i < info->comp_planes; i++) {
+ 			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+ 			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+ 			unsigned int aligned_width;
+ 			unsigned int aligned_height;
+ 
+ 			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
+ 			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
+ 
+ 			plane->sizeimage += info->bpp[i] *
+ 				DIV_ROUND_UP(aligned_width, hdiv) *
+ 				DIV_ROUND_UP(aligned_height, vdiv);
++>>>>>>> 32cddf9c94d8 (media: v4l2-common: Add an helper to apply frmsize constraints)
  		}
 -	} else {
 -		for (i = 0; i < info->comp_planes; i++) {
 -			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -			unsigned int aligned_width;
 -			unsigned int aligned_height;
 -
 -			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
  
 -			plane = &pixfmt->plane_fmt[i];
 -			plane->bytesperline =
 -				info->bpp[i] * DIV_ROUND_UP(aligned_width, hdiv);
 -			plane->sizeimage =
 -				plane->bytesperline * DIV_ROUND_UP(aligned_height, vdiv);
 -		}
 +		r = x - an[n] * y;
 +		x = y;
 +		y = r;
  	}
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt_mp);
  
 -int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,
 -		     u32 width, u32 height)
 -{
 -	const struct v4l2_format_info *info;
 -	int i;
 -
 -	info = v4l2_format_info(pixelformat);
 -	if (!info)
 -		return -EINVAL;
 +	/* Expand the simple continued fraction back to an integer fraction. */
 +	x = 0;
 +	y = 1;
  
 -	/* Single planar API cannot be used for multi plane formats. */
 -	if (info->mem_planes > 1)
 -		return -EINVAL;
 +	for (i = n; i > 0; --i) {
 +		r = y;
 +		y = an[i-1] * y + x;
 +		x = r;
 +	}
  
 -	pixfmt->width = width;
 -	pixfmt->height = height;
 -	pixfmt->pixelformat = pixelformat;
 -	pixfmt->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
 -	pixfmt->sizeimage = 0;
 +	*numerator = y;
 +	*denominator = x;
 +	kfree(an);
 +}
 +EXPORT_SYMBOL_GPL(v4l2_simplify_fraction);
  
 -	for (i = 0; i < info->comp_planes; i++) {
 -		unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -		unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -		unsigned int aligned_width;
 -		unsigned int aligned_height;
 +/*
 + * Convert a fraction to a frame interval in 100ns multiples. The idea here is
 + * to compute numerator / denominator * 10000000 using 32 bit fixed point
 + * arithmetic only.
 + */
 +u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator)
 +{
 +	u32 multiplier;
  
 -		aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -		aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
 +	/* Saturate the result if the operation would overflow. */
 +	if (denominator == 0 ||
 +	    numerator/denominator >= ((u32)-1)/10000000)
 +		return (u32)-1;
  
 -		pixfmt->sizeimage += info->bpp[i] *
 -			DIV_ROUND_UP(aligned_width, hdiv) *
 -			DIV_ROUND_UP(aligned_height, vdiv);
 +	/*
 +	 * Divide both the denominator and the multiplier by two until
 +	 * numerator * multiplier doesn't overflow. If anyone knows a better
 +	 * algorithm please let me know.
 +	 */
 +	multiplier = 10000000;
 +	while (numerator > ((u32)-1)/multiplier) {
 +		multiplier /= 2;
 +		denominator /= 2;
  	}
 -	return 0;
 +
 +	return denominator ? numerator * multiplier / denominator : 0;
  }
 -EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt);
 +EXPORT_SYMBOL_GPL(v4l2_fraction_to_interval);
diff --cc include/media/v4l2-common.h
index 2caeac8e35d6,e826b154bc35..000000000000
--- a/include/media/v4l2-common.h
+++ b/include/media/v4l2-common.h
@@@ -384,8 -387,44 +384,50 @@@ int v4l2_g_parm_cap(struct video_devic
  int v4l2_s_parm_cap(struct video_device *vdev,
  		    struct v4l2_subdev *sd, struct v4l2_streamparm *a);
  
++<<<<<<< HEAD
 +void v4l2_simplify_fraction(u32 *numerator, u32 *denominator,
 +		unsigned int n_terms, unsigned int threshold);
 +u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator);
++=======
+ /* Compare two v4l2_fract structs */
+ #define V4L2_FRACT_COMPARE(a, OP, b)			\
+ 	((u64)(a).numerator * (b).denominator OP	\
+ 	(u64)(b).numerator * (a).denominator)
+ 
+ /* ------------------------------------------------------------------------- */
+ 
+ /* Pixel format and FourCC helpers */
+ 
+ /**
+  * struct v4l2_format_info - information about a V4L2 format
+  * @format: 4CC format identifier (V4L2_PIX_FMT_*)
+  * @mem_planes: Number of memory planes, which includes the alpha plane (1 to 4).
+  * @comp_planes: Number of component planes, which includes the alpha plane (1 to 4).
+  * @bpp: Array of per-plane bytes per pixel
+  * @hdiv: Horizontal chroma subsampling factor
+  * @vdiv: Vertical chroma subsampling factor
+  * @block_w: Per-plane macroblock pixel width (optional)
+  * @block_h: Per-plane macroblock pixel height (optional)
+  */
+ struct v4l2_format_info {
+ 	u32 format;
+ 	u8 mem_planes;
+ 	u8 comp_planes;
+ 	u8 bpp[4];
+ 	u8 hdiv;
+ 	u8 vdiv;
+ 	u8 block_w[4];
+ 	u8 block_h[4];
+ };
+ 
+ const struct v4l2_format_info *v4l2_format_info(u32 format);
+ 
+ void v4l2_apply_frmsize_constraints(u32 *width, u32 *height,
+ 				    const struct v4l2_frmsize_stepwise *frmsize);
+ int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,
+ 		     u32 width, u32 height);
+ int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt, u32 pixelformat,
+ 			u32 width, u32 height);
++>>>>>>> 32cddf9c94d8 (media: v4l2-common: Add an helper to apply frmsize constraints)
  
  #endif /* V4L2_COMMON_H_ */
* Unmerged path drivers/media/v4l2-core/v4l2-common.c
* Unmerged path include/media/v4l2-common.h
