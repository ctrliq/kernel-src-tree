xhci: host: potential NULL dereference in xhci_generic_plat_probe()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Dan Carpenter <error27@gmail.com>
commit 77191db5ba7bd321fbbf4315675ee774a2b5a362
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/77191db5.failed

It's possible to exit the loop with "sysdev" set to NULL.  In that
case we should use "&pdev->dev".

Fixes: ec5499d338ec ("xhci: split out rcar/rz support from xhci-plat.c")
	Signed-off-by: Dan Carpenter <error27@gmail.com>
	Acked-by: Arnd Bergmann <arnd@arndb.de>
Link: https://lore.kernel.org/r/Y+T4kTcJwRwxNHJq@kili
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 77191db5ba7bd321fbbf4315675ee774a2b5a362)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-plat.c
diff --cc drivers/usb/host/xhci-plat.c
index c5fc175a5fd1,b9f9625467d6..000000000000
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@@ -400,8 -343,50 +400,53 @@@ disable_runtime
  
  	return ret;
  }
 -EXPORT_SYMBOL_GPL(xhci_plat_probe);
  
++<<<<<<< HEAD
 +static int xhci_plat_remove(struct platform_device *dev)
++=======
+ static int xhci_generic_plat_probe(struct platform_device *pdev)
+ {
+ 	const struct xhci_plat_priv *priv_match;
+ 	struct device *sysdev;
+ 	int ret;
+ 
+ 	/*
+ 	 * sysdev must point to a device that is known to the system firmware
+ 	 * or PCI hardware. We handle these three cases here:
+ 	 * 1. xhci_plat comes from firmware
+ 	 * 2. xhci_plat is child of a device from firmware (dwc3-plat)
+ 	 * 3. xhci_plat is grandchild of a pci device (dwc3-pci)
+ 	 */
+ 	for (sysdev = &pdev->dev; sysdev; sysdev = sysdev->parent) {
+ 		if (is_of_node(sysdev->fwnode) ||
+ 			is_acpi_device_node(sysdev->fwnode))
+ 			break;
+ #ifdef CONFIG_PCI
+ 		else if (sysdev->bus == &pci_bus_type)
+ 			break;
+ #endif
+ 	}
+ 
+ 	if (!sysdev)
+ 		sysdev = &pdev->dev;
+ 
+ 	if (WARN_ON(!sysdev->dma_mask)) {
+ 		/* Platform did not initialize dma_mask */
+ 		ret = dma_coerce_mask_and_coherent(sysdev, DMA_BIT_MASK(64));
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (pdev->dev.of_node)
+ 		priv_match = of_device_get_match_data(&pdev->dev);
+ 	else
+ 		priv_match = dev_get_platdata(&pdev->dev);
+ 
+ 	return xhci_plat_probe(pdev, sysdev, priv_match);
+ }
+ 
+ int xhci_plat_remove(struct platform_device *dev)
++>>>>>>> 77191db5ba7b (xhci: host: potential NULL dereference in xhci_generic_plat_probe())
  {
  	struct usb_hcd	*hcd = platform_get_drvdata(dev);
  	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
* Unmerged path drivers/usb/host/xhci-plat.c
