driver core: make struct device_type.devnode() take a const *

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit a9b12f8b4e3309c4c25d39e7ab818943b9c48c1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/a9b12f8b.failed

The devnode() callback in struct device_type should not be modifying the
device that is passed into it, so mark it as a const * and propagate the
function signature changes out into all relevant subsystems that use
this callback.

	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Alison Schofield <alison.schofield@intel.com>
	Cc: Vishal Verma <vishal.l.verma@intel.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Ben Widawsky <bwidawsk@kernel.org>
	Cc: Jeremy Kerr <jk@ozlabs.org>
	Cc: Joel Stanley <joel@jms.id.au>
	Cc: Alistar Popple <alistair@popple.id.au>
	Cc: Eddie James <eajames@linux.ibm.com>
	Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
	Cc: Jilin Yuan <yuanjilin@cdjrlc.com>
	Cc: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Cc: Alan Stern <stern@rowland.harvard.edu>
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
	Cc: Won Chung <wonchung@google.com>
	Acked-by: Dan Williams <dan.j.williams@intel.com>
	Acked-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Acked-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/20230111113018.459199-7-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a9b12f8b4e3309c4c25d39e7ab818943b9c48c1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cxl/core/memdev.c
#	drivers/fsi/fsi-core.c
#	include/linux/device.h
diff --cc drivers/fsi/fsi-core.c
index 4c03d6933646,0b927c9f4267..000000000000
--- a/drivers/fsi/fsi-core.c
+++ b/drivers/fsi/fsi-core.c
@@@ -659,11 -693,303 +659,305 @@@ static struct device_node *fsi_slave_fi
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t cfam_read(struct file *filep, char __user *buf, size_t count,
+ 			 loff_t *offset)
+ {
+ 	struct fsi_slave *slave = filep->private_data;
+ 	size_t total_len, read_len;
+ 	loff_t off = *offset;
+ 	ssize_t rc;
+ 
+ 	if (off < 0)
+ 		return -EINVAL;
+ 
+ 	if (off > 0xffffffff || count > 0xffffffff || off + count > 0xffffffff)
+ 		return -EINVAL;
+ 
+ 	for (total_len = 0; total_len < count; total_len += read_len) {
+ 		__be32 data;
+ 
+ 		read_len = min_t(size_t, count, 4);
+ 		read_len -= off & 0x3;
+ 
+ 		rc = fsi_slave_read(slave, off, &data, read_len);
+ 		if (rc)
+ 			goto fail;
+ 		rc = copy_to_user(buf + total_len, &data, read_len);
+ 		if (rc) {
+ 			rc = -EFAULT;
+ 			goto fail;
+ 		}
+ 		off += read_len;
+ 	}
+ 	rc = count;
+  fail:
+ 	*offset = off;
+ 	return rc;
+ }
+ 
+ static ssize_t cfam_write(struct file *filep, const char __user *buf,
+ 			  size_t count, loff_t *offset)
+ {
+ 	struct fsi_slave *slave = filep->private_data;
+ 	size_t total_len, write_len;
+ 	loff_t off = *offset;
+ 	ssize_t rc;
+ 
+ 
+ 	if (off < 0)
+ 		return -EINVAL;
+ 
+ 	if (off > 0xffffffff || count > 0xffffffff || off + count > 0xffffffff)
+ 		return -EINVAL;
+ 
+ 	for (total_len = 0; total_len < count; total_len += write_len) {
+ 		__be32 data;
+ 
+ 		write_len = min_t(size_t, count, 4);
+ 		write_len -= off & 0x3;
+ 
+ 		rc = copy_from_user(&data, buf + total_len, write_len);
+ 		if (rc) {
+ 			rc = -EFAULT;
+ 			goto fail;
+ 		}
+ 		rc = fsi_slave_write(slave, off, &data, write_len);
+ 		if (rc)
+ 			goto fail;
+ 		off += write_len;
+ 	}
+ 	rc = count;
+  fail:
+ 	*offset = off;
+ 	return rc;
+ }
+ 
+ static loff_t cfam_llseek(struct file *file, loff_t offset, int whence)
+ {
+ 	switch (whence) {
+ 	case SEEK_CUR:
+ 		break;
+ 	case SEEK_SET:
+ 		file->f_pos = offset;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return offset;
+ }
+ 
+ static int cfam_open(struct inode *inode, struct file *file)
+ {
+ 	struct fsi_slave *slave = container_of(inode->i_cdev, struct fsi_slave, cdev);
+ 
+ 	file->private_data = slave;
+ 
+ 	return 0;
+ }
+ 
+ static const struct file_operations cfam_fops = {
+ 	.owner		= THIS_MODULE,
+ 	.open		= cfam_open,
+ 	.llseek		= cfam_llseek,
+ 	.read		= cfam_read,
+ 	.write		= cfam_write,
+ };
+ 
+ static ssize_t send_term_store(struct device *dev,
+ 			       struct device_attribute *attr,
+ 			       const char *buf, size_t count)
+ {
+ 	struct fsi_slave *slave = to_fsi_slave(dev);
+ 	struct fsi_master *master = slave->master;
+ 
+ 	if (!master->term)
+ 		return -ENODEV;
+ 
+ 	master->term(master, slave->link, slave->id);
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR_WO(send_term);
+ 
+ static ssize_t slave_send_echo_show(struct device *dev,
+ 				    struct device_attribute *attr,
+ 				    char *buf)
+ {
+ 	struct fsi_slave *slave = to_fsi_slave(dev);
+ 
+ 	return sprintf(buf, "%u\n", slave->t_send_delay);
+ }
+ 
+ static ssize_t slave_send_echo_store(struct device *dev,
+ 		struct device_attribute *attr, const char *buf, size_t count)
+ {
+ 	struct fsi_slave *slave = to_fsi_slave(dev);
+ 	struct fsi_master *master = slave->master;
+ 	unsigned long val;
+ 	int rc;
+ 
+ 	if (kstrtoul(buf, 0, &val) < 0)
+ 		return -EINVAL;
+ 
+ 	if (val < 1 || val > 16)
+ 		return -EINVAL;
+ 
+ 	if (!master->link_config)
+ 		return -ENXIO;
+ 
+ 	/* Current HW mandates that send and echo delay are identical */
+ 	slave->t_send_delay = val;
+ 	slave->t_echo_delay = val;
+ 
+ 	rc = fsi_slave_set_smode(slave);
+ 	if (rc < 0)
+ 		return rc;
+ 	if (master->link_config)
+ 		master->link_config(master, slave->link,
+ 				    slave->t_send_delay,
+ 				    slave->t_echo_delay);
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(send_echo_delays, 0600,
+ 		   slave_send_echo_show, slave_send_echo_store);
+ 
+ static ssize_t chip_id_show(struct device *dev,
+ 			    struct device_attribute *attr,
+ 			    char *buf)
+ {
+ 	struct fsi_slave *slave = to_fsi_slave(dev);
+ 
+ 	return sprintf(buf, "%d\n", slave->chip_id);
+ }
+ 
+ static DEVICE_ATTR_RO(chip_id);
+ 
+ static ssize_t cfam_id_show(struct device *dev,
+ 			    struct device_attribute *attr,
+ 			    char *buf)
+ {
+ 	struct fsi_slave *slave = to_fsi_slave(dev);
+ 
+ 	return sprintf(buf, "0x%x\n", slave->cfam_id);
+ }
+ 
+ static DEVICE_ATTR_RO(cfam_id);
+ 
+ static struct attribute *cfam_attr[] = {
+ 	&dev_attr_send_echo_delays.attr,
+ 	&dev_attr_chip_id.attr,
+ 	&dev_attr_cfam_id.attr,
+ 	&dev_attr_send_term.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group cfam_attr_group = {
+ 	.attrs = cfam_attr,
+ };
+ 
+ static const struct attribute_group *cfam_attr_groups[] = {
+ 	&cfam_attr_group,
+ 	NULL,
+ };
+ 
+ static char *cfam_devnode(const struct device *dev, umode_t *mode,
+ 			  kuid_t *uid, kgid_t *gid)
+ {
+ 	const struct fsi_slave *slave = to_fsi_slave(dev);
+ 
+ #ifdef CONFIG_FSI_NEW_DEV_NODE
+ 	return kasprintf(GFP_KERNEL, "fsi/cfam%d", slave->cdev_idx);
+ #else
+ 	return kasprintf(GFP_KERNEL, "cfam%d", slave->cdev_idx);
+ #endif
+ }
+ 
+ static const struct device_type cfam_type = {
+ 	.name = "cfam",
+ 	.devnode = cfam_devnode,
+ 	.groups = cfam_attr_groups
+ };
+ 
+ static char *fsi_cdev_devnode(const struct device *dev, umode_t *mode,
+ 			      kuid_t *uid, kgid_t *gid)
+ {
+ #ifdef CONFIG_FSI_NEW_DEV_NODE
+ 	return kasprintf(GFP_KERNEL, "fsi/%s", dev_name(dev));
+ #else
+ 	return kasprintf(GFP_KERNEL, "%s", dev_name(dev));
+ #endif
+ }
+ 
+ const struct device_type fsi_cdev_type = {
+ 	.name = "fsi-cdev",
+ 	.devnode = fsi_cdev_devnode,
+ };
+ EXPORT_SYMBOL_GPL(fsi_cdev_type);
+ 
+ /* Backward compatible /dev/ numbering in "old style" mode */
+ static int fsi_adjust_index(int index)
+ {
+ #ifdef CONFIG_FSI_NEW_DEV_NODE
+ 	return index;
+ #else
+ 	return index + 1;
+ #endif
+ }
+ 
+ static int __fsi_get_new_minor(struct fsi_slave *slave, enum fsi_dev_type type,
+ 			       dev_t *out_dev, int *out_index)
+ {
+ 	int cid = slave->chip_id;
+ 	int id;
+ 
+ 	/* Check if we qualify for legacy numbering */
+ 	if (cid >= 0 && cid < 16 && type < 4) {
+ 		/* Try reserving the legacy number */
+ 		id = (cid << 4) | type;
+ 		id = ida_simple_get(&fsi_minor_ida, id, id + 1, GFP_KERNEL);
+ 		if (id >= 0) {
+ 			*out_index = fsi_adjust_index(cid);
+ 			*out_dev = fsi_base_dev + id;
+ 			return 0;
+ 		}
+ 		/* Other failure */
+ 		if (id != -ENOSPC)
+ 			return id;
+ 		/* Fallback to non-legacy allocation */
+ 	}
+ 	id = ida_simple_get(&fsi_minor_ida, FSI_CHAR_LEGACY_TOP,
+ 			    FSI_CHAR_MAX_DEVICES, GFP_KERNEL);
+ 	if (id < 0)
+ 		return id;
+ 	*out_index = fsi_adjust_index(id);
+ 	*out_dev = fsi_base_dev + id;
+ 	return 0;
+ }
+ 
+ int fsi_get_new_minor(struct fsi_device *fdev, enum fsi_dev_type type,
+ 		      dev_t *out_dev, int *out_index)
+ {
+ 	return __fsi_get_new_minor(fdev->slave, type, out_dev, out_index);
+ }
+ EXPORT_SYMBOL_GPL(fsi_get_new_minor);
+ 
+ void fsi_free_minor(dev_t dev)
+ {
+ 	ida_simple_remove(&fsi_minor_ida, MINOR(dev));
+ }
+ EXPORT_SYMBOL_GPL(fsi_free_minor);
+ 
++>>>>>>> a9b12f8b4e33 (driver core: make struct device_type.devnode() take a const *)
  static int fsi_slave_init(struct fsi_master *master, int link, uint8_t id)
  {
 -	uint32_t cfam_id;
 +	uint32_t chip_id, llmode;
  	struct fsi_slave *slave;
  	uint8_t crc;
 -	__be32 data, llmode, slbus;
  	int rc;
  
  	/* Currently, we only support single slaves on a link, and use the
diff --cc include/linux/device.h
index a1a70f61fd6c,318861000b83..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -819,8 -88,8 +819,13 @@@ extern void class_destroy(struct class 
  struct device_type {
  	const char *name;
  	const struct attribute_group **groups;
++<<<<<<< HEAD
 +	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 +	char *(*devnode)(struct device *dev, umode_t *mode,
++=======
+ 	int (*uevent)(const struct device *dev, struct kobj_uevent_env *env);
+ 	char *(*devnode)(const struct device *dev, umode_t *mode,
++>>>>>>> a9b12f8b4e33 (driver core: make struct device_type.devnode() take a const *)
  			 kuid_t *uid, kgid_t *gid);
  	void (*release)(struct device *dev);
  
* Unmerged path drivers/cxl/core/memdev.c
diff --git a/block/genhd.c b/block/genhd.c
index 027a6f99af1b..dc930145a20e 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -1591,7 +1591,7 @@ struct class block_class = {
 	.name		= "block",
 };
 
-static char *block_devnode(struct device *dev, umode_t *mode,
+static char *block_devnode(const struct device *dev, umode_t *mode,
 			   kuid_t *uid, kgid_t *gid)
 {
 	struct gendisk *disk = dev_to_disk(dev);
* Unmerged path drivers/cxl/core/memdev.c
* Unmerged path drivers/fsi/fsi-core.c
diff --git a/drivers/hwtracing/intel_th/core.c b/drivers/hwtracing/intel_th/core.c
index c9ac3dc65113..f7fd6bd63cdf 100644
--- a/drivers/hwtracing/intel_th/core.c
+++ b/drivers/hwtracing/intel_th/core.c
@@ -185,11 +185,11 @@ static struct device_type intel_th_source_device_type = {
 	.release	= intel_th_device_release,
 };
 
-static char *intel_th_output_devnode(struct device *dev, umode_t *mode,
+static char *intel_th_output_devnode(const struct device *dev, umode_t *mode,
 				     kuid_t *uid, kgid_t *gid)
 {
-	struct intel_th_device *thdev = to_intel_th_device(dev);
-	struct intel_th *th = to_intel_th(thdev);
+	const struct intel_th_device *thdev = to_intel_th_device(dev);
+	const struct intel_th *th = to_intel_th(thdev);
 	char *node;
 
 	if (thdev->id >= 0)
diff --git a/drivers/hwtracing/intel_th/intel_th.h b/drivers/hwtracing/intel_th/intel_th.h
index 5fe694708b7a..878defd7cdb3 100644
--- a/drivers/hwtracing/intel_th/intel_th.h
+++ b/drivers/hwtracing/intel_th/intel_th.h
@@ -202,7 +202,7 @@ struct intel_th_driver {
  * INTEL_TH_SWITCH and INTEL_TH_SOURCE are children of the intel_th device.
  */
 static inline struct intel_th_device *
-to_intel_th_parent(struct intel_th_device *thdev)
+to_intel_th_parent(const struct intel_th_device *thdev)
 {
 	struct device *parent = thdev->dev.parent;
 
@@ -212,7 +212,7 @@ to_intel_th_parent(struct intel_th_device *thdev)
 	return to_intel_th_device(parent);
 }
 
-static inline struct intel_th *to_intel_th(struct intel_th_device *thdev)
+static inline struct intel_th *to_intel_th(const struct intel_th_device *thdev)
 {
 	if (thdev->type == INTEL_TH_OUTPUT)
 		thdev = to_intel_th_parent(thdev);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 2550e9123cb0..69e85a5965bc 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -505,10 +505,10 @@ static const struct dev_pm_ops usb_device_pm_ops = {
 #endif	/* CONFIG_PM */
 
 
-static char *usb_devnode(struct device *dev,
+static char *usb_devnode(const struct device *dev,
 			 umode_t *mode, kuid_t *uid, kgid_t *gid)
 {
-	struct usb_device *usb_dev;
+	const struct usb_device *usb_dev;
 
 	usb_dev = to_usb_device(dev);
 	return kasprintf(GFP_KERNEL, "bus/usb/%03d/%03d",
* Unmerged path include/linux/device.h
