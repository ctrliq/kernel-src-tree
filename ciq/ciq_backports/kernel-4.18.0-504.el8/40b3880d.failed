driver core: platform: simplify __platform_driver_probe()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 40b3880dc29b89c39139eba11eba2b3107dc2e38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/40b3880d.failed

__platform_driver_probe() pokes around in some bus and driver private
lists and locks in a way that is not needed at all.  The code only wants
to know if a device was bound to the driver that was registered, so walk
all devices on the bus to see if there was a match.  If there is not a
match, return an error.  This is the same logic as was originally
present, but just done in a simpler and more obvious way that is not a
layering violation.

	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
Link: https://lore.kernel.org/r/20230131082459.301603-2-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 40b3880dc29b89c39139eba11eba2b3107dc2e38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/platform.c
diff --cc drivers/base/platform.c
index 59069a0e6a44,77510e4f47de..000000000000
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@@ -882,22 -939,21 +889,27 @@@ int __init_or_module __platform_driver_
  
  	/* temporary section violation during probe() */
  	drv->probe = probe;
 -	retval = __platform_driver_register(drv, module);
 -	if (retval)
 -		return retval;
 +	retval = code = __platform_driver_register(drv, module);
  
- 	/*
- 	 * Fixup that section violation, being paranoid about code scanning
- 	 * the list of drivers in order to probe new devices.  Check to see
- 	 * if the probe was successful, and make sure any forced probes of
- 	 * new devices fail.
- 	 */
- 	spin_lock(&drv->driver.bus->p->klist_drivers.k_lock);
+ 	/* Force all new probes of this driver to fail */
  	drv->probe = platform_probe_fail;
++<<<<<<< HEAD
 +	if (code == 0 && list_empty(&drv->driver.p->klist_devices.k_list))
 +		retval = -ENODEV;
 +	spin_unlock(&drv->driver.bus->p->klist_drivers.k_lock);
 +
 +	if (code != retval)
++=======
+ 
+ 	/* Walk all platform devices and see if any actually bound to this driver.
+ 	 * If not, return an error as the device should have done so by now.
+ 	 */
+ 	if (!bus_for_each_dev(&platform_bus_type, NULL, &drv->driver, is_bound_to_driver)) {
+ 		retval = -ENODEV;
++>>>>>>> 40b3880dc29b (driver core: platform: simplify __platform_driver_probe())
  		platform_driver_unregister(drv);
+ 	}
+ 
  	return retval;
  }
  EXPORT_SYMBOL_GPL(__platform_driver_probe);
* Unmerged path drivers/base/platform.c
