driver core: fw_devlink: Allow marking a fwnode link as being part of a cycle

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 6a6dfdf8b3ff337be5a447e9f4e71969f18370ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/6a6dfdf8.failed

To improve detection and handling of dependency cycles, we need to be
able to mark fwnode links as being part of cycles. fwnode links marked
as being part of a cycle should not block their consumers from probing.

Fixes: 2de9d8e0d2fe ("driver core: fw_devlink: Improve handling of cyclic dependencies")
	Signed-off-by: Saravana Kannan <saravanak@google.com>
	Tested-by: Colin Foster <colin.foster@in-advantage.com>
	Tested-by: Sudeep Holla <sudeep.holla@arm.com>
	Tested-by: Douglas Anderson <dianders@chromium.org>
	Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
	Tested-by: Luca Weiss <luca.weiss@fairphone.com> # qcom/sm7225-fairphone-fp4
Link: https://lore.kernel.org/r/20230207014207.1678715-7-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6a6dfdf8b3ff337be5a447e9f4e71969f18370ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/fwnode.h
diff --cc drivers/base/core.c
index 0963706ae718,6639f90cf301..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -1005,6 -1051,27 +1021,30 @@@ static void device_links_missing_suppli
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static bool dev_is_best_effort(struct device *dev)
+ {
+ 	return (fw_devlink_best_effort && dev->can_match) ||
+ 		(dev->fwnode && (dev->fwnode->flags & FWNODE_FLAG_BEST_EFFORT));
+ }
+ 
+ static struct fwnode_handle *fwnode_links_check_suppliers(
+ 						struct fwnode_handle *fwnode)
+ {
+ 	struct fwnode_link *link;
+ 
+ 	if (!fwnode || fw_devlink_is_permissive())
+ 		return NULL;
+ 
+ 	list_for_each_entry(link, &fwnode->suppliers, c_hook)
+ 		if (!(link->flags & FWLINK_FLAG_CYCLE))
+ 			return link->supplier;
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 6a6dfdf8b3ff (driver core: fw_devlink: Allow marking a fwnode link as being part of a cycle)
  /**
   * device_links_check_suppliers - Check presence of supplier drivers.
   * @dev: Consumer device.
@@@ -1031,18 -1098,20 +1071,31 @@@ int device_links_check_suppliers(struc
  	 * Device waiting for supplier to become available is not allowed to
  	 * probe.
  	 */
++<<<<<<< HEAD
 +        mutex_lock(&fwnode_link_lock);
 +	if (dev->fwnode && !list_empty(&dev->fwnode->suppliers) &&
 +	    !fw_devlink_is_permissive()) {
 +		sup_fw = list_first_entry(&dev->fwnode->suppliers,
 +					  struct fwnode_link,
 +					  c_hook)->supplier;
 +		dev_err_probe(dev, -EPROBE_DEFER, "wait for supplier %pfwP\n",
 +			      sup_fw);
 +		mutex_unlock(&fwnode_link_lock);
 +		return -EPROBE_DEFER;
++=======
+ 	mutex_lock(&fwnode_link_lock);
+ 	sup_fw = fwnode_links_check_suppliers(dev->fwnode);
+ 	if (sup_fw) {
+ 		if (!dev_is_best_effort(dev)) {
+ 			fwnode_ret = -EPROBE_DEFER;
+ 			dev_err_probe(dev, -EPROBE_DEFER,
+ 				    "wait for supplier %pfwP\n", sup_fw);
+ 		} else {
+ 			fwnode_ret = -EAGAIN;
+ 		}
++>>>>>>> 6a6dfdf8b3ff (driver core: fw_devlink: Allow marking a fwnode link as being part of a cycle)
  	}
  	mutex_unlock(&fwnode_link_lock);
 -	if (fwnode_ret == -EPROBE_DEFER)
 -		return fwnode_ret;
  
  	device_links_write_lock();
  
diff --cc include/linux/fwnode.h
index e281c738cb77,fdf2ee0285b7..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -36,16 -35,25 +36,28 @@@ struct device
  #define FWNODE_FLAG_NOT_DEVICE			BIT(1)
  #define FWNODE_FLAG_INITIALIZED			BIT(2)
  #define FWNODE_FLAG_NEEDS_CHILD_BOUND_ON_ADD	BIT(3)
++<<<<<<< HEAD
++=======
+ #define FWNODE_FLAG_BEST_EFFORT			BIT(4)
+ #define FWNODE_FLAG_VISITED			BIT(5)
++>>>>>>> 6a6dfdf8b3ff (driver core: fw_devlink: Allow marking a fwnode link as being part of a cycle)
  
  struct fwnode_handle {
  	struct fwnode_handle *secondary;
  	const struct fwnode_operations *ops;
 -	struct device *dev;
 -	struct list_head suppliers;
 -	struct list_head consumers;
 -	u8 flags;
 +	RH_KABI_EXTEND(struct device *dev)
 +	RH_KABI_EXTEND(struct list_head suppliers)
 +	RH_KABI_EXTEND(struct list_head consumers)
 +	RH_KABI_EXTEND(u8 flags)
  };
  
+ /*
+  * fwnode link flags
+  *
+  * CYCLE:	The fwnode link is part of a cycle. Don't defer probe.
+  */
+ #define FWLINK_FLAG_CYCLE			BIT(0)
+ 
  struct fwnode_link {
  	struct fwnode_handle *supplier;
  	struct list_head s_hook;
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/fwnode.h
