cpuidle, ARM: OMAP2+: powerdomain: Remove trace_.*_rcuidle()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit db8f50861da6b1129b744da3998587a5cceeffeb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/db8f5086.failed

OMAP was the one and only user.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Tested-by: Tony Lindgren <tony@atomide.com>
	Tested-by: Ulf Hansson <ulf.hansson@linaro.org>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Frederic Weisbecker <frederic@kernel.org>
Link: https://lore.kernel.org/r/20230112195541.782536366@infradead.org
(cherry picked from commit db8f50861da6b1129b744da3998587a5cceeffeb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/runtime.c
diff --cc drivers/base/power/runtime.c
index 62e0fbdf9463,98f7b3d7d669..000000000000
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@@ -736,16 -765,18 +736,16 @@@ static int rpm_resume(struct device *de
  	struct device *parent = NULL;
  	int retval = 0;
  
- 	trace_rpm_resume_rcuidle(dev, rpmflags);
+ 	trace_rpm_resume(dev, rpmflags);
  
   repeat:
 -	if (dev->power.runtime_error) {
 +	if (dev->power.runtime_error)
  		retval = -EINVAL;
 -	} else if (dev->power.disable_depth > 0) {
 -		if (dev->power.runtime_status == RPM_ACTIVE &&
 -		    dev->power.last_status == RPM_ACTIVE)
 -			retval = 1;
 -		else
 -			retval = -EACCES;
 -	}
 +	else if (dev->power.disable_depth == 1 && dev->power.is_suspended
 +	    && dev->power.runtime_status == RPM_ACTIVE)
 +		retval = 1;
 +	else if (dev->power.disable_depth > 0)
 +		retval = -EACCES;
  	if (retval)
  		goto out;
  
@@@ -1052,6 -1091,7 +1052,10 @@@ int __pm_runtime_idle(struct device *de
  		if (retval < 0) {
  			return retval;
  		} else if (retval > 0) {
++<<<<<<< HEAD
++=======
+ 			trace_rpm_usage(dev, rpmflags);
++>>>>>>> db8f50861da6 (cpuidle, ARM: OMAP2+: powerdomain: Remove trace_.*_rcuidle())
  			return 0;
  		}
  	}
@@@ -1089,6 -1129,7 +1093,10 @@@ int __pm_runtime_suspend(struct device 
  		if (retval < 0) {
  			return retval;
  		} else if (retval > 0) {
++<<<<<<< HEAD
++=======
+ 			trace_rpm_usage(dev, rpmflags);
++>>>>>>> db8f50861da6 (cpuidle, ARM: OMAP2+: powerdomain: Remove trace_.*_rcuidle())
  			return 0;
  		}
  	}
@@@ -1169,6 -1212,7 +1177,10 @@@ int pm_runtime_get_if_active(struct dev
  	} else {
  		retval = atomic_inc_not_zero(&dev->power.usage_count);
  	}
++<<<<<<< HEAD
++=======
+ 	trace_rpm_usage(dev, 0);
++>>>>>>> db8f50861da6 (cpuidle, ARM: OMAP2+: powerdomain: Remove trace_.*_rcuidle())
  	spin_unlock_irqrestore(&dev->power.lock, flags);
  
  	return retval;
@@@ -1526,6 -1575,8 +1538,11 @@@ void pm_runtime_allow(struct device *de
  	ret = rpm_drop_usage_count(dev);
  	if (ret == 0)
  		rpm_idle(dev, RPM_AUTO | RPM_ASYNC);
++<<<<<<< HEAD
++=======
+ 	else if (ret > 0)
+ 		trace_rpm_usage(dev, RPM_AUTO | RPM_ASYNC);
++>>>>>>> db8f50861da6 (cpuidle, ARM: OMAP2+: powerdomain: Remove trace_.*_rcuidle())
  
   out:
  	spin_unlock_irq(&dev->power.lock);
@@@ -1593,6 -1645,8 +1610,11 @@@ static void update_autosuspend(struct d
  		if (!old_use || old_delay >= 0) {
  			atomic_inc(&dev->power.usage_count);
  			rpm_resume(dev, 0);
++<<<<<<< HEAD
++=======
+ 		} else {
+ 			trace_rpm_usage(dev, 0);
++>>>>>>> db8f50861da6 (cpuidle, ARM: OMAP2+: powerdomain: Remove trace_.*_rcuidle())
  		}
  	}
  
diff --git a/arch/arm/mach-omap2/powerdomain.c b/arch/arm/mach-omap2/powerdomain.c
index 1a0f69c0a376..503f9dc070b8 100644
--- a/arch/arm/mach-omap2/powerdomain.c
+++ b/arch/arm/mach-omap2/powerdomain.c
@@ -190,9 +190,9 @@ static int _pwrdm_state_switch(struct powerdomain *pwrdm, int flag)
 			trace_state = (PWRDM_TRACE_STATES_FLAG |
 				       ((next & OMAP_POWERSTATE_MASK) << 8) |
 				       ((prev & OMAP_POWERSTATE_MASK) << 0));
-			trace_power_domain_target_rcuidle(pwrdm->name,
-							  trace_state,
-							  raw_smp_processor_id());
+			trace_power_domain_target(pwrdm->name,
+						  trace_state,
+						  raw_smp_processor_id());
 		}
 		break;
 	default:
@@ -544,8 +544,8 @@ int pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)
 
 	if (arch_pwrdm && arch_pwrdm->pwrdm_set_next_pwrst) {
 		/* Trace the pwrdm desired target state */
-		trace_power_domain_target_rcuidle(pwrdm->name, pwrst,
-						  raw_smp_processor_id());
+		trace_power_domain_target(pwrdm->name, pwrst,
+					  raw_smp_processor_id());
 		/* Program the pwrdm desired target state */
 		ret = arch_pwrdm->pwrdm_set_next_pwrst(pwrdm, pwrst);
 	}
* Unmerged path drivers/base/power/runtime.c
