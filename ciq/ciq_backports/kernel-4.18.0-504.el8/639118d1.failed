mm: kill is_memblock_offlined()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Kefeng Wang <wangkefeng.wang@huawei.com>
commit 639118d1571f70b1157b4bb5ac574b0ab0f38099
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/639118d1.failed

Directly check state of struct memory_block, no need a single function.

Link: https://lkml.kernel.org/r/20220827112043.187028-1-wangkefeng.wang@huawei.com
	Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Reviewed-by: Anshuman Khandual <anshuman.khandual@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 639118d1571f70b1157b4bb5ac574b0ab0f38099)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memory_hotplug.h
#	mm/memory_hotplug.c
diff --cc include/linux/memory_hotplug.h
index d7c2cc0edad2,54675791bc50..000000000000
--- a/include/linux/memory_hotplug.h
+++ b/include/linux/memory_hotplug.h
@@@ -11,9 -11,10 +11,13 @@@ struct page
  struct zone;
  struct pglist_data;
  struct mem_section;
++<<<<<<< HEAD
 +struct memory_block;
++=======
+ struct memory_group;
++>>>>>>> 639118d1571f (mm: kill is_memblock_offlined())
  struct resource;
  struct vmem_altmap;
 -struct dev_pagemap;
  
  #ifdef CONFIG_HAVE_ARCH_NODEDATA_EXTENSION
  /*
@@@ -344,9 -332,9 +348,8 @@@ extern void move_pfn_range_to_zone(stru
  extern void remove_pfn_range_from_zone(struct zone *zone,
  				       unsigned long start_pfn,
  				       unsigned long nr_pages);
- extern bool is_memblock_offlined(struct memory_block *mem);
  extern int sparse_add_section(int nid, unsigned long pfn,
 -		unsigned long nr_pages, struct vmem_altmap *altmap,
 -		struct dev_pagemap *pgmap);
 +		unsigned long nr_pages, struct vmem_altmap *altmap);
  extern void sparse_remove_section(struct mem_section *ms,
  		unsigned long pfn, unsigned long nr_pages,
  		unsigned long map_offset, struct vmem_altmap *altmap);
diff --cc mm/memory_hotplug.c
index 3bbe8225fb59,dc727aee4ad3..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1628,9 -1969,10 +1628,16 @@@ failed_removal
  
  static int check_memblock_offlined_cb(struct memory_block *mem, void *arg)
  {
++<<<<<<< HEAD
 +	int ret = !is_memblock_offlined(mem);
 +
 +	if (unlikely(ret)) {
++=======
+ 	int *nid = arg;
+ 
+ 	*nid = mem->nid;
+ 	if (unlikely(mem->state != MEM_OFFLINE)) {
++>>>>>>> 639118d1571f (mm: kill is_memblock_offlined())
  		phys_addr_t beginpa, endpa;
  
  		beginpa = PFN_PHYS(section_nr_to_pfn(mem->start_section_nr));
diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index 5a9c680d8341..a0c42b8605d1 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -796,12 +796,6 @@ void remove_memory_block_devices(unsigned long start, unsigned long size)
 	}
 }
 
-/* return true if the memory block is offlined, otherwise, return false */
-bool is_memblock_offlined(struct memory_block *mem)
-{
-	return mem->state == MEM_OFFLINE;
-}
-
 static struct attribute *memory_root_attrs[] = {
 #ifdef CONFIG_ARCH_MEMORY_PROBE
 	&dev_attr_probe.attr,
* Unmerged path include/linux/memory_hotplug.h
* Unmerged path mm/memory_hotplug.c
