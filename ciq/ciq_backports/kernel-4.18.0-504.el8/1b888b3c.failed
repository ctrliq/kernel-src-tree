media: v4l: Add a helper for obtaining the link frequency

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Sakari Ailus <sakari.ailus@linux.intel.com>
commit 1b888b3cebef2de3936167e95652830145040b78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/1b888b3c.failed

Add a helper for obtaining the link frequency from transmitter drivers.

	Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
(cherry picked from commit 1b888b3cebef2de3936167e95652830145040b78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/v4l2-core/v4l2-common.c
#	include/media/v4l2-common.h
diff --cc drivers/media/v4l2-core/v4l2-common.c
index e0e7a9a9518d,78007dba4677..000000000000
--- a/drivers/media/v4l2-core/v4l2-common.c
+++ b/drivers/media/v4l2-core/v4l2-common.c
@@@ -465,68 -340,137 +465,105 @@@ void v4l2_simplify_fraction(u32 *numera
  		return;
  
  	/*
 -	 * Clamp width/height to meet min/max constraints and round it up to
 -	 * macroblock alignment.
 +	 * Convert the fraction to a simple continued fraction. See
 +	 * https://en.wikipedia.org/wiki/Continued_fraction
 +	 * Stop if the current term is bigger than or equal to the given
 +	 * threshold.
  	 */
 -	*width = clamp_roundup(*width, frmsize->min_width, frmsize->max_width,
 -			       frmsize->step_width);
 -	*height = clamp_roundup(*height, frmsize->min_height, frmsize->max_height,
 -				frmsize->step_height);
 -}
 -EXPORT_SYMBOL_GPL(v4l2_apply_frmsize_constraints);
 -
 -int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,
 -			u32 pixelformat, u32 width, u32 height)
 -{
 -	const struct v4l2_format_info *info;
 -	struct v4l2_plane_pix_format *plane;
 -	int i;
 -
 -	info = v4l2_format_info(pixelformat);
 -	if (!info)
 -		return -EINVAL;
 -
 -	pixfmt->width = width;
 -	pixfmt->height = height;
 -	pixfmt->pixelformat = pixelformat;
 -	pixfmt->num_planes = info->mem_planes;
 -
 -	if (info->mem_planes == 1) {
 -		plane = &pixfmt->plane_fmt[0];
 -		plane->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
 -		plane->sizeimage = 0;
 +	x = *numerator;
 +	y = *denominator;
 +
 +	for (n = 0; n < n_terms && y != 0; ++n) {
 +		an[n] = x / y;
 +		if (an[n] >= threshold) {
 +			if (n < 2)
 +				n++;
 +			break;
 +		}
  
 -		for (i = 0; i < info->comp_planes; i++) {
 -			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -			unsigned int aligned_width;
 -			unsigned int aligned_height;
 +		r = x - an[n] * y;
 +		x = y;
 +		y = r;
 +	}
  
 -			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
 +	/* Expand the simple continued fraction back to an integer fraction. */
 +	x = 0;
 +	y = 1;
  
 -			plane->sizeimage += info->bpp[i] *
 -				DIV_ROUND_UP(aligned_width, hdiv) *
 -				DIV_ROUND_UP(aligned_height, vdiv);
 -		}
 -	} else {
 -		for (i = 0; i < info->comp_planes; i++) {
 -			unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -			unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -			unsigned int aligned_width;
 -			unsigned int aligned_height;
 -
 -			aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -			aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
 -
 -			plane = &pixfmt->plane_fmt[i];
 -			plane->bytesperline =
 -				info->bpp[i] * DIV_ROUND_UP(aligned_width, hdiv);
 -			plane->sizeimage =
 -				plane->bytesperline * DIV_ROUND_UP(aligned_height, vdiv);
 -		}
 +	for (i = n; i > 0; --i) {
 +		r = y;
 +		y = an[i-1] * y + x;
 +		x = r;
  	}
 -	return 0;
 +
 +	*numerator = y;
 +	*denominator = x;
 +	kfree(an);
  }
 -EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt_mp);
 +EXPORT_SYMBOL_GPL(v4l2_simplify_fraction);
  
 -int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,
 -		     u32 width, u32 height)
 +/*
 + * Convert a fraction to a frame interval in 100ns multiples. The idea here is
 + * to compute numerator / denominator * 10000000 using 32 bit fixed point
 + * arithmetic only.
 + */
 +u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator)
  {
 -	const struct v4l2_format_info *info;
 -	int i;
 -
 -	info = v4l2_format_info(pixelformat);
 -	if (!info)
 -		return -EINVAL;
 -
 -	/* Single planar API cannot be used for multi plane formats. */
 -	if (info->mem_planes > 1)
 -		return -EINVAL;
 +	u32 multiplier;
  
 -	pixfmt->width = width;
 -	pixfmt->height = height;
 -	pixfmt->pixelformat = pixelformat;
 -	pixfmt->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0];
 -	pixfmt->sizeimage = 0;
 +	/* Saturate the result if the operation would overflow. */
 +	if (denominator == 0 ||
 +	    numerator/denominator >= ((u32)-1)/10000000)
 +		return (u32)-1;
  
 -	for (i = 0; i < info->comp_planes; i++) {
 -		unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
 -		unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
 -		unsigned int aligned_width;
 -		unsigned int aligned_height;
 -
 -		aligned_width = ALIGN(width, v4l2_format_block_width(info, i));
 -		aligned_height = ALIGN(height, v4l2_format_block_height(info, i));
 -
 -		pixfmt->sizeimage += info->bpp[i] *
 -			DIV_ROUND_UP(aligned_width, hdiv) *
 -			DIV_ROUND_UP(aligned_height, vdiv);
 +	/*
 +	 * Divide both the denominator and the multiplier by two until
 +	 * numerator * multiplier doesn't overflow. If anyone knows a better
 +	 * algorithm please let me know.
 +	 */
 +	multiplier = 10000000;
 +	while (numerator > ((u32)-1)/multiplier) {
 +		multiplier /= 2;
 +		denominator /= 2;
  	}
 -	return 0;
 +
 +	return denominator ? numerator * multiplier / denominator : 0;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(v4l2_fraction_to_interval);
++=======
+ EXPORT_SYMBOL_GPL(v4l2_fill_pixfmt);
+ 
+ s64 v4l2_get_link_rate(struct v4l2_ctrl_handler *handler, unsigned int mul,
+ 		       unsigned int div)
+ {
+ 	struct v4l2_ctrl *ctrl;
+ 	s64 freq;
+ 
+ 	ctrl = v4l2_ctrl_find(handler, V4L2_CID_LINK_FREQ);
+ 	if (ctrl) {
+ 		struct v4l2_querymenu qm = { .id = V4L2_CID_LINK_FREQ };
+ 		int ret;
+ 
+ 		qm.index = v4l2_ctrl_g_ctrl(ctrl);
+ 
+ 		ret = v4l2_querymenu(handler, &qm);
+ 		if (ret)
+ 			return -ENOENT;
+ 
+ 		freq = qm.value;
+ 	} else {
+ 		if (!mul || !div)
+ 			return -ENOENT;
+ 
+ 		ctrl = v4l2_ctrl_find(handler, V4L2_CID_PIXEL_RATE);
+ 		if (!ctrl)
+ 			return -ENOENT;
+ 
+ 		freq = div_u64(v4l2_ctrl_g_ctrl_int64(ctrl) * mul, div);
+ 	}
+ 
+ 	return freq > 0 ? freq : -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(v4l2_get_link_rate);
++>>>>>>> 1b888b3cebef (media: v4l: Add a helper for obtaining the link frequency)
diff --cc include/media/v4l2-common.h
index 2caeac8e35d6,be36cbdcc1bd..000000000000
--- a/include/media/v4l2-common.h
+++ b/include/media/v4l2-common.h
@@@ -384,8 -448,145 +384,151 @@@ int v4l2_g_parm_cap(struct video_devic
  int v4l2_s_parm_cap(struct video_device *vdev,
  		    struct v4l2_subdev *sd, struct v4l2_streamparm *a);
  
++<<<<<<< HEAD
 +void v4l2_simplify_fraction(u32 *numerator, u32 *denominator,
 +		unsigned int n_terms, unsigned int threshold);
 +u32 v4l2_fraction_to_interval(u32 numerator, u32 denominator);
++=======
+ /* Compare two v4l2_fract structs */
+ #define V4L2_FRACT_COMPARE(a, OP, b)			\
+ 	((u64)(a).numerator * (b).denominator OP	\
+ 	(u64)(b).numerator * (a).denominator)
+ 
+ /* ------------------------------------------------------------------------- */
+ 
+ /* Pixel format and FourCC helpers */
+ 
+ /**
+  * enum v4l2_pixel_encoding - specifies the pixel encoding value
+  *
+  * @V4L2_PIXEL_ENC_UNKNOWN:	Pixel encoding is unknown/un-initialized
+  * @V4L2_PIXEL_ENC_YUV:		Pixel encoding is YUV
+  * @V4L2_PIXEL_ENC_RGB:		Pixel encoding is RGB
+  * @V4L2_PIXEL_ENC_BAYER:	Pixel encoding is Bayer
+  */
+ enum v4l2_pixel_encoding {
+ 	V4L2_PIXEL_ENC_UNKNOWN = 0,
+ 	V4L2_PIXEL_ENC_YUV = 1,
+ 	V4L2_PIXEL_ENC_RGB = 2,
+ 	V4L2_PIXEL_ENC_BAYER = 3,
+ };
+ 
+ /**
+  * struct v4l2_format_info - information about a V4L2 format
+  * @format: 4CC format identifier (V4L2_PIX_FMT_*)
+  * @pixel_enc: Pixel encoding (see enum v4l2_pixel_encoding above)
+  * @mem_planes: Number of memory planes, which includes the alpha plane (1 to 4).
+  * @comp_planes: Number of component planes, which includes the alpha plane (1 to 4).
+  * @bpp: Array of per-plane bytes per pixel
+  * @hdiv: Horizontal chroma subsampling factor
+  * @vdiv: Vertical chroma subsampling factor
+  * @block_w: Per-plane macroblock pixel width (optional)
+  * @block_h: Per-plane macroblock pixel height (optional)
+  */
+ struct v4l2_format_info {
+ 	u32 format;
+ 	u8 pixel_enc;
+ 	u8 mem_planes;
+ 	u8 comp_planes;
+ 	u8 bpp[4];
+ 	u8 hdiv;
+ 	u8 vdiv;
+ 	u8 block_w[4];
+ 	u8 block_h[4];
+ };
+ 
+ static inline bool v4l2_is_format_rgb(const struct v4l2_format_info *f)
+ {
+ 	return f && f->pixel_enc == V4L2_PIXEL_ENC_RGB;
+ }
+ 
+ static inline bool v4l2_is_format_yuv(const struct v4l2_format_info *f)
+ {
+ 	return f && f->pixel_enc == V4L2_PIXEL_ENC_YUV;
+ }
+ 
+ static inline bool v4l2_is_format_bayer(const struct v4l2_format_info *f)
+ {
+ 	return f && f->pixel_enc == V4L2_PIXEL_ENC_BAYER;
+ }
+ 
+ const struct v4l2_format_info *v4l2_format_info(u32 format);
+ void v4l2_apply_frmsize_constraints(u32 *width, u32 *height,
+ 				    const struct v4l2_frmsize_stepwise *frmsize);
+ int v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,
+ 		     u32 width, u32 height);
+ int v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt, u32 pixelformat,
+ 			u32 width, u32 height);
+ 
+ /**
+  * v4l2_get_link_rate - Get link rate from transmitter
+  *
+  * @handler: The transmitter's control handler
+  * @mul: The multiplier between pixel rate and link frequency. Bits per pixel on
+  *	 D-PHY, samples per clock on parallel. 0 otherwise.
+  * @div: The divisor between pixel rate and link frequency. Number of data lanes
+  *	 times two on D-PHY, 1 on parallel. 0 otherwise.
+  *
+  * This function is intended for obtaining the link frequency from the
+  * transmitter sub-devices. It returns the link rate, either from the
+  * V4L2_CID_LINK_FREQ control implemented by the transmitter, or value
+  * calculated based on the V4L2_CID_PIXEL_RATE implemented by the transmitter.
+  *
+  * Returns link frequency on success, otherwise a negative error code:
+  *	-ENOENT: Link frequency or pixel rate control not found
+  *	-EINVAL: Invalid link frequency value
+  */
+ s64 v4l2_get_link_rate(struct v4l2_ctrl_handler *handler, unsigned int mul,
+ 		       unsigned int div);
+ 
+ static inline u64 v4l2_buffer_get_timestamp(const struct v4l2_buffer *buf)
+ {
+ 	/*
+ 	 * When the timestamp comes from 32-bit user space, there may be
+ 	 * uninitialized data in tv_usec, so cast it to u32.
+ 	 * Otherwise allow invalid input for backwards compatibility.
+ 	 */
+ 	return buf->timestamp.tv_sec * NSEC_PER_SEC +
+ 		(u32)buf->timestamp.tv_usec * NSEC_PER_USEC;
+ }
+ 
+ static inline void v4l2_buffer_set_timestamp(struct v4l2_buffer *buf,
+ 					     u64 timestamp)
+ {
+ 	struct timespec64 ts = ns_to_timespec64(timestamp);
+ 
+ 	buf->timestamp.tv_sec  = ts.tv_sec;
+ 	buf->timestamp.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
+ }
+ 
+ static inline bool v4l2_is_colorspace_valid(__u32 colorspace)
+ {
+ 	return colorspace > V4L2_COLORSPACE_DEFAULT &&
+ 	       colorspace <= V4L2_COLORSPACE_DCI_P3;
+ }
+ 
+ static inline bool v4l2_is_xfer_func_valid(__u32 xfer_func)
+ {
+ 	return xfer_func > V4L2_XFER_FUNC_DEFAULT &&
+ 	       xfer_func <= V4L2_XFER_FUNC_SMPTE2084;
+ }
+ 
+ static inline bool v4l2_is_ycbcr_enc_valid(__u8 ycbcr_enc)
+ {
+ 	return ycbcr_enc > V4L2_YCBCR_ENC_DEFAULT &&
+ 	       ycbcr_enc <= V4L2_YCBCR_ENC_SMPTE240M;
+ }
+ 
+ static inline bool v4l2_is_hsv_enc_valid(__u8 hsv_enc)
+ {
+ 	return hsv_enc == V4L2_HSV_ENC_180 || hsv_enc == V4L2_HSV_ENC_256;
+ }
+ 
+ static inline bool v4l2_is_quant_valid(__u8 quantization)
+ {
+ 	return quantization == V4L2_QUANTIZATION_FULL_RANGE ||
+ 	       quantization == V4L2_QUANTIZATION_LIM_RANGE;
+ }
++>>>>>>> 1b888b3cebef (media: v4l: Add a helper for obtaining the link frequency)
  
  #endif /* V4L2_COMMON_H_ */
* Unmerged path drivers/media/v4l2-core/v4l2-common.c
* Unmerged path include/media/v4l2-common.h
