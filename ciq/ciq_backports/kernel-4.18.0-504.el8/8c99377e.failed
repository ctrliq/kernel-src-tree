driver core: bus: add bus_get_dev_root() function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 8c99377e614f8abfd881c34611002b2af5ab1ee8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/8c99377e.failed

Instead of poking around in the struct bus_type directly for the
dev_root pointer, provide a function to return it properly reference
counted, if it is present in the bus.  This will be needed to move the
pointer out of struct bus_type in the future.

Use the function in the driver core code at the same time it is
introduced to verify that it works properly.

	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
Link: https://lore.kernel.org/r/20230209093556.19132-1-gregkh@linuxfoundation.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8c99377e614f8abfd881c34611002b2af5ab1ee8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/bus.c
#	include/linux/device/bus.h
diff --cc drivers/base/bus.c
index 6c57d75a8b45,def1e009ad9d..000000000000
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@@ -1316,6 -1318,42 +1316,45 @@@ struct device_driver *driver_find(cons
  }
  EXPORT_SYMBOL_GPL(driver_find);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Warning, the value could go to "removed" instantly after calling this function, so be very
+  * careful when calling it...
+  */
+ bool bus_is_registered(const struct bus_type *bus)
+ {
+ 	struct subsys_private *sp = bus_to_subsys(bus);
+ 	bool is_initialized = false;
+ 
+ 	if (sp) {
+ 		is_initialized = true;
+ 		subsys_put(sp);
+ 	}
+ 	return is_initialized;
+ }
+ 
+ /**
+  * bus_get_dev_root - return a pointer to the "device root" of a bus
+  * @bus: bus to return the device root of.
+  *
+  * If a bus has a "device root" structure, return it, WITH THE REFERENCE
+  * COUNT INCREMENTED.
+  *
+  * Note, when finished with the device, a call to put_device() is required.
+  *
+  * If the device root is not present (or bus is not a valid pointer), NULL
+  * will be returned.
+  */
+ struct device *bus_get_dev_root(const struct bus_type *bus)
+ {
+ 	if (bus)
+ 		return get_device(bus->dev_root);
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(bus_get_dev_root);
+ 
++>>>>>>> 8c99377e614f (driver core: bus: add bus_get_dev_root() function)
  int __init buses_init(void)
  {
  	bus_kset = kset_create_and_add("bus", &bus_uevent_ops, NULL);
* Unmerged path include/linux/device/bus.h
* Unmerged path drivers/base/bus.c
diff --git a/drivers/base/core.c b/drivers/base/core.c
index c20dc40d93df..be6505e71d69 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3063,8 +3063,9 @@ static DEFINE_MUTEX(gdp_mutex);
 static struct kobject *get_device_parent(struct device *dev,
 					 struct device *parent)
 {
+	struct kobject *kobj = NULL;
+
 	if (dev->class) {
-		struct kobject *kobj = NULL;
 		struct kobject *parent_kobj;
 		struct kobject *k;
 
@@ -3112,8 +3113,15 @@ static struct kobject *get_device_parent(struct device *dev,
 	}
 
 	/* subsystems can specify a default root directory for their devices */
-	if (!parent && dev->bus && dev->bus->dev_root)
-		return &dev->bus->dev_root->kobj;
+	if (!parent && dev->bus) {
+		struct device *dev_root = bus_get_dev_root(dev->bus);
+
+		if (dev_root) {
+			kobj = &dev_root->kobj;
+			put_device(dev_root);
+			return kobj;
+		}
+	}
 
 	if (parent)
 		return &parent->kobj;
diff --git a/drivers/base/cpu.c b/drivers/base/cpu.c
index 2adb3e646da2..6c376b0eb25e 100644
--- a/drivers/base/cpu.c
+++ b/drivers/base/cpu.c
@@ -609,9 +609,13 @@ static const struct attribute_group cpu_root_vulnerabilities_group = {
 
 static void __init cpu_register_vulnerabilities(void)
 {
-	if (sysfs_create_group(&cpu_subsys.dev_root->kobj,
-			       &cpu_root_vulnerabilities_group))
-		pr_err("Unable to register CPU vulnerabilities\n");
+	struct device *dev = bus_get_dev_root(&cpu_subsys);
+
+	if (dev) {
+		if (sysfs_create_group(&dev->kobj, &cpu_root_vulnerabilities_group))
+			pr_err("Unable to register CPU vulnerabilities\n");
+		put_device(dev);
+	}
 }
 
 #else
* Unmerged path include/linux/device/bus.h
