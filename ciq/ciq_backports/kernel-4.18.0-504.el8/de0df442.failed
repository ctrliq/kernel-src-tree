cacheinfo: Check 'cache-unified' property to count cache leaves

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Pierre Gondois <pierre.gondois@arm.com>
commit de0df442ee49cb1f6ee58f3fec5dcb5e5eb70aab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/de0df442.failed

The DeviceTree Specification v0.3 specifies that the cache node
'[d-|i-|]cache-size' property is required. The 'cache-unified'
property is specifies whether the cache level is separate
or unified.

If the cache-size property is missing, no cache leaves is accounted.
This can lead to a 'BUG: KASAN: slab-out-of-bounds' [1] bug.

Check 'cache-unified' property and always account for at least
one cache leaf when parsing the device tree.

[1] https://lore.kernel.org/all/0f19cb3f-d6cf-4032-66d2-dedc9d09a0e3@linaro.org/

	Reported-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
	Signed-off-by: Pierre Gondois <pierre.gondois@arm.com>
	Tested-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
Link: https://lore.kernel.org/r/20230104183033.755668-4-pierre.gondois@arm.com
	Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
(cherry picked from commit de0df442ee49cb1f6ee58f3fec5dcb5e5eb70aab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/cacheinfo.c
diff --cc drivers/base/cacheinfo.c
index af78a16b124e,9ad4403f2dab..000000000000
--- a/drivers/base/cacheinfo.c
+++ b/drivers/base/cacheinfo.c
@@@ -235,8 -229,71 +235,73 @@@ static int cache_setup_of_node(unsigne
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int of_count_cache_leaves(struct device_node *np)
+ {
+ 	unsigned int leaves = 0;
+ 
+ 	if (of_property_read_bool(np, "cache-size"))
+ 		++leaves;
+ 	if (of_property_read_bool(np, "i-cache-size"))
+ 		++leaves;
+ 	if (of_property_read_bool(np, "d-cache-size"))
+ 		++leaves;
+ 
+ 	if (!leaves) {
+ 		/* The '[i-|d-|]cache-size' property is required, but
+ 		 * if absent, fallback on the 'cache-unified' property.
+ 		 */
+ 		if (of_property_read_bool(np, "cache-unified"))
+ 			return 1;
+ 		else
+ 			return 2;
+ 	}
+ 
+ 	return leaves;
+ }
+ 
+ int init_of_cache_level(unsigned int cpu)
+ {
+ 	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+ 	struct device_node *np = of_cpu_device_node_get(cpu);
+ 	struct device_node *prev = NULL;
+ 	unsigned int levels = 0, leaves, level;
+ 
+ 	leaves = of_count_cache_leaves(np);
+ 	if (leaves > 0)
+ 		levels = 1;
+ 
+ 	prev = np;
+ 	while ((np = of_find_next_cache_node(np))) {
+ 		of_node_put(prev);
+ 		prev = np;
+ 		if (!of_device_is_compatible(np, "cache"))
+ 			goto err_out;
+ 		if (of_property_read_u32(np, "cache-level", &level))
+ 			goto err_out;
+ 		if (level <= levels)
+ 			goto err_out;
+ 
+ 		leaves += of_count_cache_leaves(np);
+ 		levels = level;
+ 	}
+ 
+ 	of_node_put(np);
+ 	this_cpu_ci->num_levels = levels;
+ 	this_cpu_ci->num_leaves = leaves;
+ 
+ 	return 0;
+ 
+ err_out:
+ 	of_node_put(np);
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> de0df442ee49 (cacheinfo: Check 'cache-unified' property to count cache leaves)
  #else
  static inline int cache_setup_of_node(unsigned int cpu) { return 0; }
 -int init_of_cache_level(unsigned int cpu) { return 0; }
  #endif
  
  int __weak cache_setup_acpi(unsigned int cpu)
* Unmerged path drivers/base/cacheinfo.c
