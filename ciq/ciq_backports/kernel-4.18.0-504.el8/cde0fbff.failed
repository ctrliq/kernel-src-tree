cacheinfo: Check cache properties are present in DT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Pierre Gondois <pierre.gondois@arm.com>
commit cde0fbff07eff7e4e0e85fa053fe19a24c86b1e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/cde0fbff.failed

If a Device Tree (DT) is used, the presence of cache properties is
assumed. Not finding any is not considered. For arm64 platforms,
cache information can be fetched from the clidr_el1 register.
Checking whether cache information is available in the DT
allows to switch to using clidr_el1.

init_of_cache_level()
\-of_count_cache_leaves()
will assume there a 2 cache leaves (L1 data/instruction caches), which
can be different from clidr_el1 information.

cache_setup_of_node() tries to read cache properties in the DT.
If there are none, this is considered a success. Knowing no
information was available would allow to switch to using clidr_el1.

Fixes: de0df442ee49 ("cacheinfo: Check 'cache-unified' property to count cache leaves")
	Reported-by: Alexandre Ghiti <alexghiti@rivosinc.com>
Link: https://lore.kernel.org/all/20230404-hatred-swimmer-6fecdf33b57a@spud/
	Signed-off-by: Pierre Gondois <pierre.gondois@arm.com>
	Reviewed-by: Conor Dooley <conor.dooley@microchip.com>
Link: https://lore.kernel.org/r/20230414081453.244787-3-pierre.gondois@arm.com
	Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
(cherry picked from commit cde0fbff07eff7e4e0e85fa053fe19a24c86b1e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/cacheinfo.c
diff --cc drivers/base/cacheinfo.c
index b49bb02ab981,f16e5a82f0f3..000000000000
--- a/drivers/base/cacheinfo.c
+++ b/drivers/base/cacheinfo.c
@@@ -235,8 -236,95 +243,97 @@@ static int cache_setup_of_node(unsigne
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static bool of_check_cache_nodes(struct device_node *np)
+ {
+ 	struct device_node *next;
+ 
+ 	if (of_property_present(np, "cache-size")   ||
+ 	    of_property_present(np, "i-cache-size") ||
+ 	    of_property_present(np, "d-cache-size") ||
+ 	    of_property_present(np, "cache-unified"))
+ 		return true;
+ 
+ 	next = of_find_next_cache_node(np);
+ 	if (next) {
+ 		of_node_put(next);
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static int of_count_cache_leaves(struct device_node *np)
+ {
+ 	unsigned int leaves = 0;
+ 
+ 	if (of_property_read_bool(np, "cache-size"))
+ 		++leaves;
+ 	if (of_property_read_bool(np, "i-cache-size"))
+ 		++leaves;
+ 	if (of_property_read_bool(np, "d-cache-size"))
+ 		++leaves;
+ 
+ 	if (!leaves) {
+ 		/* The '[i-|d-|]cache-size' property is required, but
+ 		 * if absent, fallback on the 'cache-unified' property.
+ 		 */
+ 		if (of_property_read_bool(np, "cache-unified"))
+ 			return 1;
+ 		else
+ 			return 2;
+ 	}
+ 
+ 	return leaves;
+ }
+ 
+ int init_of_cache_level(unsigned int cpu)
+ {
+ 	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+ 	struct device_node *np = of_cpu_device_node_get(cpu);
+ 	struct device_node *prev = NULL;
+ 	unsigned int levels = 0, leaves, level;
+ 
+ 	if (!of_check_cache_nodes(np)) {
+ 		of_node_put(np);
+ 		return -ENOENT;
+ 	}
+ 
+ 	leaves = of_count_cache_leaves(np);
+ 	if (leaves > 0)
+ 		levels = 1;
+ 
+ 	prev = np;
+ 	while ((np = of_find_next_cache_node(np))) {
+ 		of_node_put(prev);
+ 		prev = np;
+ 		if (!of_device_is_compatible(np, "cache"))
+ 			goto err_out;
+ 		if (of_property_read_u32(np, "cache-level", &level))
+ 			goto err_out;
+ 		if (level <= levels)
+ 			goto err_out;
+ 
+ 		leaves += of_count_cache_leaves(np);
+ 		levels = level;
+ 	}
+ 
+ 	of_node_put(np);
+ 	this_cpu_ci->num_levels = levels;
+ 	this_cpu_ci->num_leaves = leaves;
+ 
+ 	return 0;
+ 
+ err_out:
+ 	of_node_put(np);
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> cde0fbff07ef (cacheinfo: Check cache properties are present in DT)
  #else
  static inline int cache_setup_of_node(unsigned int cpu) { return 0; }
 -int init_of_cache_level(unsigned int cpu) { return 0; }
  #endif
  
  int __weak cache_setup_acpi(unsigned int cpu)
* Unmerged path drivers/base/cacheinfo.c
