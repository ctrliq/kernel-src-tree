efi/efivars: Expose RT service availability via efivars abstraction

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit f88814cc2578c121e6edef686365036db72af0ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/f88814cc.failed

Commit

  bf67fad19e493b ("efi: Use more granular check for availability for variable services")

introduced a check into the efivarfs, efi-pstore and other drivers that
aborts loading of the module if not all three variable runtime services
(GetVariable, SetVariable and GetNextVariable) are supported. However, this
results in efivarfs being unavailable entirely if only SetVariable support
is missing, which is only needed if you want to make any modifications.
Also, efi-pstore and the sysfs EFI variable interface could be backed by
another implementation of the 'efivars' abstraction, in which case it is
completely irrelevant which services are supported by the EFI firmware.

So make the generic 'efivars' abstraction dependent on the availibility of
the GetVariable and GetNextVariable EFI runtime services, and add a helper
'efivar_supports_writes()' to find out whether the currently active efivars
abstraction supports writes (and wire it up to the availability of
SetVariable for the generic one).

Then, use the efivar_supports_writes() helper to decide whether to permit
efivarfs to be mounted read-write, and whether to enable efi-pstore or the
sysfs EFI variable interface altogether.

Fixes: bf67fad19e493b ("efi: Use more granular check for availability for variable services")
	Reported-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
	Acked-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
	Tested-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit f88814cc2578c121e6edef686365036db72af0ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi-pstore.c
#	drivers/firmware/efi/efi.c
#	drivers/firmware/efi/efivars.c
#	fs/efivarfs/super.c
diff --cc drivers/firmware/efi/efi-pstore.c
index 5e53e74f3dd7,feb7fe6f2da7..000000000000
--- a/drivers/firmware/efi/efi-pstore.c
+++ b/drivers/firmware/efi/efi-pstore.c
@@@ -354,10 -356,7 +354,14 @@@ static struct pstore_info efi_pstore_in
  
  static __init int efivars_pstore_init(void)
  {
++<<<<<<< HEAD
 +	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 +		return 0;
 +
 +	if (!efivars_kobject())
++=======
+ 	if (!efivars_kobject() || !efivar_supports_writes())
++>>>>>>> f88814cc2578 (efi/efivars: Expose RT service availability via efivars abstraction)
  		return 0;
  
  	if (efivars_pstore_disable)
diff --cc drivers/firmware/efi/efi.c
index af2bcb2c0beb,fdd1db025dbf..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -369,12 -384,14 +371,17 @@@ static int __init efisubsys_init(void
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	error = generic_ops_register();
 +	if (error)
 +		goto err_put;
 +
 +	if (efi_enabled(EFI_RUNTIME_SERVICES))
++=======
+ 	if (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE |
+ 				      EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME)) {
++>>>>>>> f88814cc2578 (efi/efivars: Expose RT service availability via efivars abstraction)
  		efivar_ssdt_load();
 -		error = generic_ops_register();
 -		if (error)
 -			goto err_put;
 -		platform_device_register_simple("efivars", 0, NULL, 0);
 -	}
  
  	error = sysfs_create_group(efi_kobj, &efi_subsys_attr_group);
  	if (error) {
@@@ -399,7 -419,9 +406,13 @@@
  err_remove_group:
  	sysfs_remove_group(efi_kobj, &efi_subsys_attr_group);
  err_unregister:
++<<<<<<< HEAD
 +	generic_ops_unregister();
++=======
+ 	if (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE |
+ 				      EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME))
+ 		generic_ops_unregister();
++>>>>>>> f88814cc2578 (efi/efivars: Expose RT service availability via efivars abstraction)
  err_put:
  	kobject_put(efi_kobj);
  	return error;
diff --cc drivers/firmware/efi/efivars.c
index 1c65f5ac4368,dcea137142b3..000000000000
--- a/drivers/firmware/efi/efivars.c
+++ b/drivers/firmware/efi/efivars.c
@@@ -742,11 -680,8 +742,14 @@@ int efivars_sysfs_init(void
  	struct kobject *parent_kobj = efivars_kobject();
  	int error = 0;
  
++<<<<<<< HEAD
 +	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 +		return -ENODEV;
 +
++=======
++>>>>>>> f88814cc2578 (efi/efivars: Expose RT service availability via efivars abstraction)
  	/* No efivars has been registered yet */
- 	if (!parent_kobj)
+ 	if (!parent_kobj || !efivar_supports_writes())
  		return 0;
  
  	printk(KERN_INFO "EFI Variables Facility v%s %s\n", EFIVARS_VERSION,
diff --cc fs/efivarfs/super.c
index 124f1aa9ab03,28bb5689333a..000000000000
--- a/fs/efivarfs/super.c
+++ b/fs/efivarfs/super.c
@@@ -255,9 -255,6 +258,12 @@@ static struct file_system_type efivarfs
  
  static __init int efivarfs_init(void)
  {
++<<<<<<< HEAD
 +	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 +		return -ENODEV;
 +
++=======
++>>>>>>> f88814cc2578 (efi/efivars: Expose RT service availability via efivars abstraction)
  	if (!efivars_kobject())
  		return -ENODEV;
  
* Unmerged path drivers/firmware/efi/efi-pstore.c
* Unmerged path drivers/firmware/efi/efi.c
* Unmerged path drivers/firmware/efi/efivars.c
diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c
index 2d7acbca09f2..a91442a114dd 100644
--- a/drivers/firmware/efi/vars.c
+++ b/drivers/firmware/efi/vars.c
@@ -1242,3 +1242,9 @@ int efivars_unregister(struct efivars *efivars)
 	return rv;
 }
 EXPORT_SYMBOL_GPL(efivars_unregister);
+
+int efivar_supports_writes(void)
+{
+	return __efivars && __efivars->ops->set_variable;
+}
+EXPORT_SYMBOL_GPL(efivar_supports_writes);
* Unmerged path fs/efivarfs/super.c
diff --git a/include/linux/efi.h b/include/linux/efi.h
index e2fbef660b6e..f6159b0c767e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1788,6 +1788,7 @@ int efivars_register(struct efivars *efivars,
 int efivars_unregister(struct efivars *efivars);
 struct kobject *efivars_kobject(void);
 
+int efivar_supports_writes(void);
 int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),
 		void *data, bool duplicates, struct list_head *head);
 
