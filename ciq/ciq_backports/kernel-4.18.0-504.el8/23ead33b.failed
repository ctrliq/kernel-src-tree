device property: Constify fwnode connection match APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-504.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 23ead33bc6ed62abc9adc5fe27b9911e2ef5d209
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-504.el8/23ead33b.failed

The fwnode and device parameters are not altered in the fwnode
connection match APIs, constify them.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Acked-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Reviewed-by: Sakari Ailus <sakari.ailus@linux.intel.com>
Link: https://lore.kernel.org/r/20221004092129.19412-3-andriy.shevchenko@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 23ead33bc6ed62abc9adc5fe27b9911e2ef5d209)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
#	include/linux/property.h
diff --cc drivers/base/property.c
index f24b2b05c5ae,58b8158add5c..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -1298,3 -1212,142 +1298,145 @@@ const void *device_get_match_data(cons
  	return fwnode_call_ptr_op(dev_fwnode(dev), device_get_match_data, dev);
  }
  EXPORT_SYMBOL_GPL(device_get_match_data);
++<<<<<<< HEAD
++=======
+ 
+ static unsigned int fwnode_graph_devcon_matches(const struct fwnode_handle *fwnode,
+ 						const char *con_id, void *data,
+ 						devcon_match_fn_t match,
+ 						void **matches,
+ 						unsigned int matches_len)
+ {
+ 	struct fwnode_handle *node;
+ 	struct fwnode_handle *ep;
+ 	unsigned int count = 0;
+ 	void *ret;
+ 
+ 	fwnode_graph_for_each_endpoint(fwnode, ep) {
+ 		if (matches && count >= matches_len) {
+ 			fwnode_handle_put(ep);
+ 			break;
+ 		}
+ 
+ 		node = fwnode_graph_get_remote_port_parent(ep);
+ 		if (!fwnode_device_is_available(node)) {
+ 			fwnode_handle_put(node);
+ 			continue;
+ 		}
+ 
+ 		ret = match(node, con_id, data);
+ 		fwnode_handle_put(node);
+ 		if (ret) {
+ 			if (matches)
+ 				matches[count] = ret;
+ 			count++;
+ 		}
+ 	}
+ 	return count;
+ }
+ 
+ static unsigned int fwnode_devcon_matches(const struct fwnode_handle *fwnode,
+ 					  const char *con_id, void *data,
+ 					  devcon_match_fn_t match,
+ 					  void **matches,
+ 					  unsigned int matches_len)
+ {
+ 	struct fwnode_handle *node;
+ 	unsigned int count = 0;
+ 	unsigned int i;
+ 	void *ret;
+ 
+ 	for (i = 0; ; i++) {
+ 		if (matches && count >= matches_len)
+ 			break;
+ 
+ 		node = fwnode_find_reference(fwnode, con_id, i);
+ 		if (IS_ERR(node))
+ 			break;
+ 
+ 		ret = match(node, NULL, data);
+ 		fwnode_handle_put(node);
+ 		if (ret) {
+ 			if (matches)
+ 				matches[count] = ret;
+ 			count++;
+ 		}
+ 	}
+ 
+ 	return count;
+ }
+ 
+ /**
+  * fwnode_connection_find_match - Find connection from a device node
+  * @fwnode: Device node with the connection
+  * @con_id: Identifier for the connection
+  * @data: Data for the match function
+  * @match: Function to check and convert the connection description
+  *
+  * Find a connection with unique identifier @con_id between @fwnode and another
+  * device node. @match will be used to convert the connection description to
+  * data the caller is expecting to be returned.
+  */
+ void *fwnode_connection_find_match(const struct fwnode_handle *fwnode,
+ 				   const char *con_id, void *data,
+ 				   devcon_match_fn_t match)
+ {
+ 	unsigned int count;
+ 	void *ret;
+ 
+ 	if (!fwnode || !match)
+ 		return NULL;
+ 
+ 	count = fwnode_graph_devcon_matches(fwnode, con_id, data, match, &ret, 1);
+ 	if (count)
+ 		return ret;
+ 
+ 	count = fwnode_devcon_matches(fwnode, con_id, data, match, &ret, 1);
+ 	return count ? ret : NULL;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_connection_find_match);
+ 
+ /**
+  * fwnode_connection_find_matches - Find connections from a device node
+  * @fwnode: Device node with the connection
+  * @con_id: Identifier for the connection
+  * @data: Data for the match function
+  * @match: Function to check and convert the connection description
+  * @matches: (Optional) array of pointers to fill with matches
+  * @matches_len: Length of @matches
+  *
+  * Find up to @matches_len connections with unique identifier @con_id between
+  * @fwnode and other device nodes. @match will be used to convert the
+  * connection description to data the caller is expecting to be returned
+  * through the @matches array.
+  * If @matches is NULL @matches_len is ignored and the total number of resolved
+  * matches is returned.
+  *
+  * Return: Number of matches resolved, or negative errno.
+  */
+ int fwnode_connection_find_matches(const struct fwnode_handle *fwnode,
+ 				   const char *con_id, void *data,
+ 				   devcon_match_fn_t match,
+ 				   void **matches, unsigned int matches_len)
+ {
+ 	unsigned int count_graph;
+ 	unsigned int count_ref;
+ 
+ 	if (!fwnode || !match)
+ 		return -EINVAL;
+ 
+ 	count_graph = fwnode_graph_devcon_matches(fwnode, con_id, data, match,
+ 						  matches, matches_len);
+ 
+ 	if (matches) {
+ 		matches += count_graph;
+ 		matches_len -= count_graph;
+ 	}
+ 
+ 	count_ref = fwnode_devcon_matches(fwnode, con_id, data, match,
+ 					  matches, matches_len);
+ 
+ 	return count_graph + count_ref;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_connection_find_matches);
++>>>>>>> 23ead33bc6ed (device property: Constify fwnode connection match APIs)
diff --cc include/linux/property.h
index bd3c1d282eed,8d82775a901a..000000000000
--- a/include/linux/property.h
+++ b/include/linux/property.h
@@@ -438,6 -442,25 +438,28 @@@ unsigned int fwnode_graph_get_endpoint_
  int fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
  				struct fwnode_endpoint *endpoint);
  
++<<<<<<< HEAD
++=======
+ typedef void *(*devcon_match_fn_t)(const struct fwnode_handle *fwnode, const char *id,
+ 				   void *data);
+ 
+ void *fwnode_connection_find_match(const struct fwnode_handle *fwnode,
+ 				   const char *con_id, void *data,
+ 				   devcon_match_fn_t match);
+ 
+ static inline void *device_connection_find_match(const struct device *dev,
+ 						 const char *con_id, void *data,
+ 						 devcon_match_fn_t match)
+ {
+ 	return fwnode_connection_find_match(dev_fwnode(dev), con_id, data, match);
+ }
+ 
+ int fwnode_connection_find_matches(const struct fwnode_handle *fwnode,
+ 				   const char *con_id, void *data,
+ 				   devcon_match_fn_t match,
+ 				   void **matches, unsigned int matches_len);
+ 
++>>>>>>> 23ead33bc6ed (device property: Constify fwnode connection match APIs)
  /* -------------------------------------------------------------------------- */
  /* Software fwnode support - when HW description is incomplete or missing */
  
* Unmerged path drivers/base/property.c
diff --git a/drivers/usb/roles/class.c b/drivers/usb/roles/class.c
index 32e6d19f7011..eacb46ec2ab3 100644
--- a/drivers/usb/roles/class.c
+++ b/drivers/usb/roles/class.c
@@ -87,7 +87,7 @@ enum usb_role usb_role_switch_get_role(struct usb_role_switch *sw)
 }
 EXPORT_SYMBOL_GPL(usb_role_switch_get_role);
 
-static void *usb_role_switch_match(struct fwnode_handle *fwnode, const char *id,
+static void *usb_role_switch_match(const struct fwnode_handle *fwnode, const char *id,
 				   void *data)
 {
 	struct device *dev;
diff --git a/drivers/usb/typec/mux.c b/drivers/usb/typec/mux.c
index 941735c73161..c7177ddd4f12 100644
--- a/drivers/usb/typec/mux.c
+++ b/drivers/usb/typec/mux.c
@@ -32,8 +32,8 @@ static int switch_fwnode_match(struct device *dev, const void *fwnode)
 	return device_match_fwnode(dev, fwnode);
 }
 
-static void *typec_switch_match(struct fwnode_handle *fwnode, const char *id,
-				void *data)
+static void *typec_switch_match(const struct fwnode_handle *fwnode,
+				const char *id, void *data)
 {
 	struct device *dev;
 
@@ -262,8 +262,8 @@ static int mux_fwnode_match(struct device *dev, const void *fwnode)
 	return device_match_fwnode(dev, fwnode);
 }
 
-static void *typec_mux_match(struct fwnode_handle *fwnode, const char *id,
-			     void *data)
+static void *typec_mux_match(const struct fwnode_handle *fwnode,
+			     const char *id, void *data)
 {
 	const struct typec_altmode_desc *desc = data;
 	struct device *dev;
diff --git a/drivers/usb/typec/retimer.c b/drivers/usb/typec/retimer.c
index 3a4146ea6e7c..0481e82f6bbc 100644
--- a/drivers/usb/typec/retimer.c
+++ b/drivers/usb/typec/retimer.c
@@ -22,7 +22,7 @@ static int retimer_fwnode_match(struct device *dev, const void *fwnode)
 	return is_typec_retimer(dev) && device_match_fwnode(dev, fwnode);
 }
 
-static void *typec_retimer_match(struct fwnode_handle *fwnode, const char *id, void *data)
+static void *typec_retimer_match(const struct fwnode_handle *fwnode, const char *id, void *data)
 {
 	struct device *dev;
 
* Unmerged path include/linux/property.h
