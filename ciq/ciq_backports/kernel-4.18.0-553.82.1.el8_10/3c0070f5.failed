cifs: prevent data race in smb2_reconnect()

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit 3c0070f54b3128de498c2dd9934a21f0dd867111
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/3c0070f5.failed

Make sure to get an up-to-date TCP_Server_Info::nr_targets value prior
to waiting the server to be reconnected in smb2_reconnect().  It is
set in cifs_tcp_ses_needs_reconnect() and protected by
TCP_Server_Info::srv_lock.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 3c0070f54b3128de498c2dd9934a21f0dd867111)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/smb2pdu.c
index b72fbca5ee79,2d5c3df2277d..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -180,57 -243,11 +239,64 @@@ smb2_reconnect(__le16 smb2_command, str
  	    (!tcon->ses->server) || !server)
  		return -EIO;
  
+ 	rc = wait_for_server_reconnect(server, smb2_command, tcon->retry);
+ 	if (rc)
+ 		return rc;
+ 
  	ses = tcon->ses;
++<<<<<<< HEAD
 +	retries = server->nr_targets;
 +
 +	/*
 +	 * Give demultiplex thread up to 10 seconds to each target available for
 +	 * reconnect -- should be greater than cifs socket timeout which is 7
 +	 * seconds.
 +	 */
 +	while (server->tcpStatus == CifsNeedReconnect) {
 +		/*
 +		 * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE
 +		 * here since they are implicitly done when session drops.
 +		 */
 +		switch (smb2_command) {
 +		/*
 +		 * BB Should we keep oplock break and add flush to exceptions?
 +		 */
 +		case SMB2_TREE_DISCONNECT:
 +		case SMB2_CANCEL:
 +		case SMB2_CLOSE:
 +		case SMB2_OPLOCK_BREAK:
 +			return -EAGAIN;
 +		}
 +
 +		rc = wait_event_interruptible_timeout(server->response_q,
 +						      (server->tcpStatus != CifsNeedReconnect),
 +						      10 * HZ);
 +		if (rc < 0) {
 +			cifs_dbg(FYI, "%s: aborting reconnect due to a received signal by the process\n",
 +				 __func__);
 +			return -ERESTARTSYS;
 +		}
 +
 +		/* are we still trying to reconnect? */
 +		if (server->tcpStatus != CifsNeedReconnect)
 +			break;
 +
 +		if (retries && --retries)
 +			continue;
 +
 +		/*
 +		 * on "soft" mounts we wait once. Hard mounts keep
 +		 * retrying until process is killed or server comes
 +		 * back on-line
 +		 */
 +		if (!tcon->retry) {
 +			cifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");
 +			return -EHOSTDOWN;
 +		}
 +		retries = server->nr_targets;
 +	}
++=======
++>>>>>>> 3c0070f54b31 (cifs: prevent data race in smb2_reconnect())
  
  	spin_lock(&ses->chan_lock);
  	if (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {
* Unmerged path fs/cifs/smb2pdu.c
