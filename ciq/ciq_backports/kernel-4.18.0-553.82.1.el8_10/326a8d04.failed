cifs: do all necessary checks for credits within or before locking

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 326a8d04f147e2bf393f6f9cdb74126ee6900607
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/326a8d04.failed

All the server credits and in-flight info is protected by req_lock.
Once the req_lock is held, and we've determined that we have enough
credits to continue, this lock cannot be dropped till we've made the
changes to credits and in-flight count.

However, we used to drop the lock in order to avoid deadlock with
the recent srv_lock. This could cause the checks already made to be
invalidated.

Fixed it by moving the server status check to before locking req_lock.

Fixes: d7d7a66aacd6 ("cifs: avoid use of global locks for high contention data")
	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 326a8d04f147e2bf393f6f9cdb74126ee6900607)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2ops.c
#	fs/cifs/transport.c
diff --cc fs/cifs/smb2ops.c
index 84d71fd3fc8e,3696d4ce0df3..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -220,11 -235,6 +230,14 @@@ smb2_wait_mtu_credits(struct TCP_Server
  				return rc;
  			spin_lock(&server->req_lock);
  		} else {
++<<<<<<< HEAD:fs/cifs/smb2ops.c
 +			if (server->tcpStatus == CifsExiting) {
 +				spin_unlock(&server->req_lock);
 +				return -ENOENT;
 +			}
 +
++=======
++>>>>>>> 326a8d04f147 (cifs: do all necessary checks for credits within or before locking):fs/smb/client/smb2ops.c
  			scredits = server->credits;
  			/* can deadlock with reopen */
  			if (scredits <= 8) {
diff --cc fs/cifs/transport.c
index 47baadcf6627,f280502a2aee..000000000000
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@@ -579,11 -557,6 +589,14 @@@ wait_for_free_credits(struct TCP_Server
  				return -ERESTARTSYS;
  			spin_lock(&server->req_lock);
  		} else {
++<<<<<<< HEAD:fs/cifs/transport.c
 +			if (server->tcpStatus == CifsExiting) {
 +				spin_unlock(&server->req_lock);
 +				return -ENOENT;
 +			}
 +
++=======
++>>>>>>> 326a8d04f147 (cifs: do all necessary checks for credits within or before locking):fs/smb/client/transport.c
  			/*
  			 * For normal commands, reserve the last MAX_COMPOUND
  			 * credits to compound requests.
* Unmerged path fs/cifs/smb2ops.c
* Unmerged path fs/cifs/transport.c
