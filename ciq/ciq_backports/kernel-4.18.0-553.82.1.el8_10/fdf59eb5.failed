smb3: cleanup and clarify status of tree connections

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Steve French <stfrench@microsoft.com>
commit fdf59eb548e51bce81382c39f1a5fd4cb9403b78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/fdf59eb5.failed

Currently the way the tid (tree connection) status is tracked
is confusing.  The same enum is used for structs cifs_tcon
and cifs_ses and TCP_Server_info, but each of these three has
different states that they transition among.  The current
code also unnecessarily uses camelCase.

Convert from use of statusEnum to a new tid_status_enum for
tree connections.  The valid states for a tid are:

        TID_NEW = 0,
        TID_GOOD,
        TID_EXITING,
        TID_NEED_RECON,
        TID_NEED_TCON,
        TID_IN_TCON,
        TID_NEED_FILES_INVALIDATE, /* unused, considering removing in future */
        TID_IN_FILES_INVALIDATE

It also removes CifsNeedTcon, CifsInTcon, CifsNeedFilesInvalidate and
CifsInFilesInvalidate from the statusEnum used for session and
TCP_Server_Info since they are not relevant for those.

A follow on patch will fix the places where we use the
tcon->need_reconnect flag to be more consistent with the tid->status.

Also fixes a bug that was:
	Reported-by: kernel test robot <lkp@intel.com>
	Reviewed-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit fdf59eb548e51bce81382c39f1a5fd4cb9403b78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsglob.h
#	fs/cifs/cifssmb.c
#	fs/cifs/connect.c
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/cifsglob.h
index bfe603df9494,cd9127510a55..000000000000
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@@ -115,7 -111,22 +115,26 @@@ enum statusEnum 
  	CifsGood,
  	CifsExiting,
  	CifsNeedReconnect,
++<<<<<<< HEAD
 +	CifsNeedNegotiate
++=======
+ 	CifsNeedNegotiate,
+ 	CifsInNegotiate,
+ 	CifsNeedSessSetup,
+ 	CifsInSessSetup,
+ };
+ 
+ /* associated with each tree connection to the server */
+ enum tid_status_enum {
+ 	TID_NEW = 0,
+ 	TID_GOOD,
+ 	TID_EXITING,
+ 	TID_NEED_RECON,
+ 	TID_NEED_TCON,
+ 	TID_IN_TCON,
+ 	TID_NEED_FILES_INVALIDATE, /* currently unused */
+ 	TID_IN_FILES_INVALIDATE
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  };
  
  enum securityEnum {
diff --cc fs/cifs/cifssmb.c
index 141047242013,aca9338b0877..000000000000
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@@ -89,6 -73,15 +89,18 @@@ cifs_mark_open_files_invalid(struct cif
  	struct list_head *tmp;
  	struct list_head *tmp1;
  
++<<<<<<< HEAD
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if ((tcon->ses->status != CifsGood) || (tcon->status != TID_NEED_RECON)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return;
+ 	}
+ 	tcon->status = TID_IN_FILES_INVALIDATE;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  	/* list all files open on tree connection and mark them invalid */
  	spin_lock(&tcon->open_file_lock);
  	list_for_each_safe(tmp, tmp1, &tcon->openFileList) {
@@@ -105,6 -98,11 +117,14 @@@
  	memset(tcon->crfid.fid, 0, sizeof(struct cifs_fid));
  	mutex_unlock(&tcon->crfid.fid_mutex);
  
++<<<<<<< HEAD
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->status == TID_IN_FILES_INVALIDATE)
+ 		tcon->status = TID_NEED_TCON;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  	/*
  	 * BB Add call to invalidate_inodes(sb) for all superblocks mounted
  	 * to this tcon.
@@@ -136,7 -134,8 +156,12 @@@ cifs_reconnect_tcon(struct cifs_tcon *t
  	 * only tree disconnect, open, and write, (and ulogoff which does not
  	 * have tcon) are allowed as we start force umount
  	 */
++<<<<<<< HEAD
 +	if (tcon->tidStatus == CifsExiting) {
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->status == TID_EXITING) {
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  		if (smb_command != SMB_COM_WRITE_ANDX &&
  		    smb_command != SMB_COM_OPEN_ANDX &&
  		    smb_command != SMB_COM_TREE_DISCONNECT) {
diff --cc fs/cifs/connect.c
index 7aabd597027d,ee3b7c15e884..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -196,19 -228,25 +196,24 @@@ static void cifs_mark_tcp_ses_conns_for
  	spin_lock(&cifs_tcp_ses_lock);
  	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
  		spin_lock(&ses->chan_lock);
 -		if (!mark_smb_session && cifs_chan_needs_reconnect(ses, server))
 +		if (cifs_chan_needs_reconnect(ses, server))
  			goto next_session;
  
 -		if (mark_smb_session)
 -			CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);
 -		else
 -			cifs_chan_set_need_reconnect(ses, server);
 +		cifs_chan_set_need_reconnect(ses, server);
  
  		/* If all channels need reconnect, then tcon needs reconnect */
 -		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
  			goto next_session;
  
 -		ses->status = CifsNeedReconnect;
 +		num_sessions++;
  
 -		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 +		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
++<<<<<<< HEAD
++=======
+ 			tcon->status = TID_NEED_RECON;
+ 		}
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
  
@@@ -4320,9 -4483,22 +4325,23 @@@ int cifs_tree_connect(const unsigned in
  	char *tree;
  	struct dfs_info3_param ref = {0};
  
++<<<<<<< HEAD
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->ses->status != CifsGood ||
+ 	    (tcon->status != TID_NEW &&
+ 	    tcon->status != TID_NEED_TCON)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 	tcon->status = TID_IN_TCON;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  	tree = kzalloc(MAX_TREE_SIZE, GFP_KERNEL);
 -	if (!tree) {
 -		rc = -ENOMEM;
 -		goto out;
 -	}
 +	if (!tree)
 +		return -ENOMEM;
  
  	if (tcon->ipc) {
  		scnprintf(tree, MAX_TREE_SIZE, "\\\\%s\\IPC$", server->hostname);
@@@ -4350,13 -4530,52 +4369,58 @@@ out
  	kfree(tree);
  	cifs_put_tcp_super(sb);
  
++<<<<<<< HEAD
++=======
+ 	if (rc) {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (tcon->status == TID_IN_TCON)
+ 			tcon->status = TID_NEED_TCON;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 	} else {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (tcon->status == TID_IN_TCON)
+ 			tcon->status = TID_GOOD;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		tcon->need_reconnect = false;
+ 	}
+ 
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  	return rc;
  }
  #else
  int cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)
  {
 -	int rc;
  	const struct smb_version_operations *ops = tcon->ses->server->ops;
  
++<<<<<<< HEAD
 +	return ops->tree_connect(xid, tcon->ses, tcon->treeName, tcon, nlsc);
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->ses->status != CifsGood ||
+ 	    (tcon->status != TID_NEW &&
+ 	    tcon->status != TID_NEED_TCON)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 	tcon->status = TID_IN_TCON;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
+ 	rc = ops->tree_connect(xid, tcon->ses, tcon->treeName, tcon, nlsc);
+ 	if (rc) {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (tcon->status == TID_IN_TCON)
+ 			tcon->status = TID_NEED_TCON;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 	} else {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (tcon->status == TID_IN_TCON)
+ 			tcon->status = TID_GOOD;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		tcon->need_reconnect = false;
+ 	}
+ 
+ 	return rc;
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  }
  #endif
diff --cc fs/cifs/smb2pdu.c
index fdd9bd57531e,1b7ad0c09566..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -162,7 -162,8 +162,12 @@@ smb2_reconnect(__le16 smb2_command, str
  	if (smb2_command == SMB2_TREE_CONNECT || smb2_command == SMB2_IOCTL)
  		return 0;
  
++<<<<<<< HEAD
 +	if (tcon->tidStatus == CifsExiting) {
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->status == TID_EXITING) {
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  		/*
  		 * only tree disconnect, open, and write,
  		 * (and ulogoff which does not have tcon)
@@@ -3849,13 -3846,43 +3854,47 @@@ void smb2_reconnect_server(struct work_
  			cifs_put_tcon(tcon);
  	}
  
++<<<<<<< HEAD
 +	cifs_dbg(FYI, "Reconnecting tcons finished\n");
++=======
+ 	if (!ses_exist)
+ 		goto done;
+ 
+ 	/* allocate a dummy tcon struct used for reconnect */
+ 	tcon = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);
+ 	if (!tcon) {
+ 		resched = true;
+ 		list_for_each_entry_safe(ses, ses2, &tmp_ses_list, rlist) {
+ 			list_del_init(&ses->rlist);
+ 			cifs_put_smb_ses(ses);
+ 		}
+ 		goto done;
+ 	}
+ 
+ 	tcon->status = TID_GOOD;
+ 	tcon->retry = false;
+ 	tcon->need_reconnect = false;
+ 
+ 	/* now reconnect sessions for necessary channels */
+ 	list_for_each_entry_safe(ses, ses2, &tmp_ses_list, rlist) {
+ 		tcon->ses = ses;
+ 		rc = smb2_reconnect(SMB2_INTERNAL_CMD, tcon, server);
+ 		if (rc)
+ 			resched = true;
+ 		list_del_init(&ses->rlist);
+ 		cifs_put_smb_ses(ses);
+ 	}
+ 	kfree(tcon);
+ 
+ done:
+ 	cifs_dbg(FYI, "Reconnecting tcons and channels finished\n");
++>>>>>>> fdf59eb548e5 (smb3: cleanup and clarify status of tree connections)
  	if (resched)
  		queue_delayed_work(cifsiod_wq, &server->reconnect, 2 * HZ);
 -	mutex_unlock(&pserver->reconnect_mutex);
 +	mutex_unlock(&server->reconnect_mutex);
  
  	/* now we can safely release srv struct */
 -	if (tcon_exist || ses_exist)
 +	if (tcon_exist)
  		cifs_put_tcp_session(server, 1);
  }
  
diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c
index f8f3b7014863..f1275f79001a 100644
--- a/fs/cifs/cifs_debug.c
+++ b/fs/cifs/cifs_debug.c
@@ -109,7 +109,7 @@ static void cifs_debug_tcon(struct seq_file *m, struct cifs_tcon *tcon)
 		   le32_to_cpu(tcon->fsDevInfo.DeviceCharacteristics),
 		   le32_to_cpu(tcon->fsAttrInfo.Attributes),
 		   le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength),
-		   tcon->tidStatus);
+		   tcon->status);
 	if (dev_type == FILE_DEVICE_DISK)
 		seq_puts(m, " type: DISK ");
 	else if (dev_type == FILE_DEVICE_CD_ROM)
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f5278aec90bb..01418acdd33f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -682,14 +682,14 @@ static void cifs_umount_begin(struct super_block *sb)
 	tcon = cifs_sb_master_tcon(cifs_sb);
 
 	spin_lock(&cifs_tcp_ses_lock);
-	if ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {
+	if ((tcon->tc_count > 1) || (tcon->status == TID_EXITING)) {
 		/* we have other mounts to same share or we have
 		   already tried to force umount this and woken up
 		   all waiting network requests, nothing to do */
 		spin_unlock(&cifs_tcp_ses_lock);
 		return;
 	} else if (tcon->tc_count == 1)
-		tcon->tidStatus = CifsExiting;
+		tcon->status = TID_EXITING;
 	spin_unlock(&cifs_tcp_ses_lock);
 
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
* Unmerged path fs/cifs/cifsglob.h
* Unmerged path fs/cifs/cifssmb.c
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
index 4d5f12505aa8..ddc04e83e939 100644
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -115,7 +115,7 @@ tconInfoAlloc(void)
 	}
 
 	atomic_inc(&tconInfoAllocCount);
-	ret_buf->tidStatus = CifsNew;
+	ret_buf->status = TID_NEW;
 	++ret_buf->tc_count;
 	INIT_LIST_HEAD(&ret_buf->openFileList);
 	INIT_LIST_HEAD(&ret_buf->tcon_list);
* Unmerged path fs/cifs/smb2pdu.c
