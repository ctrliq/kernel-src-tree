cifs: use the least loaded channel for sending requests

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit ea90708d3cf3d0d92c02afe445ad463fb3c6bf10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/ea90708d.failed

Till now, we've used a simple round robin approach to
distribute the requests between the channels. This does
not work well if the channels consume the requests at
different speeds, even if the advertised speeds are the
same.

This change will allow the client to pick the channel
with least number of requests currently in-flight. This
will disregard the link speed, and select a channel
based on the current load of the channels.

For cases when all the channels are equally loaded,
fall back to the old round robin method.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit ea90708d3cf3d0d92c02afe445ad463fb3c6bf10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/transport.c
diff --cc fs/cifs/transport.c
index 8dc65d79be8f,b42050c68e6c..000000000000
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@@ -1045,15 -1015,31 +1048,43 @@@ struct TCP_Server_Info *cifs_pick_chann
  		return NULL;
  
  	spin_lock(&ses->chan_lock);
++<<<<<<< HEAD
 +	/* round robin */
 +pick_another:
 +	if (ses->chan_count > 1 &&
 +	    !CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {
 +		index = (uint)atomic_inc_return(&ses->chan_seq);
 +		index %= ses->chan_count;
 +
 +		if (CIFS_CHAN_NEEDS_RECONNECT(ses, index))
 +			goto pick_another;
++=======
+ 	for (i = 0; i < ses->chan_count; i++) {
+ 		server = ses->chans[i].server;
+ 		if (!server)
+ 			continue;
+ 
+ 		/*
+ 		 * strictly speaking, we should pick up req_lock to read
+ 		 * server->in_flight. But it shouldn't matter much here if we
+ 		 * race while reading this data. The worst that can happen is
+ 		 * that we could use a channel that's not least loaded. Avoiding
+ 		 * taking the lock could help reduce wait time, which is
+ 		 * important for this function
+ 		 */
+ 		if (server->in_flight < min_in_flight) {
+ 			min_in_flight = server->in_flight;
+ 			index = i;
+ 		}
+ 		if (server->in_flight > max_in_flight)
+ 			max_in_flight = server->in_flight;
+ 	}
+ 
+ 	/* if all channels are equally loaded, fall back to round-robin */
+ 	if (min_in_flight == max_in_flight) {
+ 		index = (uint)atomic_inc_return(&ses->chan_seq);
+ 		index %= ses->chan_count;
++>>>>>>> ea90708d3cf3 (cifs: use the least loaded channel for sending requests)
  	}
  	spin_unlock(&ses->chan_lock);
  
* Unmerged path fs/cifs/transport.c
