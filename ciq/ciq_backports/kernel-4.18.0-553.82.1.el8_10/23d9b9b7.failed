cifs: avoid unnecessary iteration of tcp sessions

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 23d9b9b757e8007204d8f71448ab55d5ef2ae8e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/23d9b9b7.failed

In a few places, we do unnecessary iterations of
tcp sessions, even when the server struct is provided.

The change avoids it and uses the server struct provided.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 23d9b9b757e8007204d8f71448ab55d5ef2ae8e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2misc.c
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/smb2misc.c
index a3424673fd30,572293c18e16..000000000000
--- a/fs/cifs/smb2misc.c
+++ b/fs/cifs/smb2misc.c
@@@ -621,48 -622,42 +621,56 @@@ smb2_is_valid_lease_break(char *buffer
  
  	cifs_dbg(FYI, "Checking for lease break\n");
  
+ 	/* If server is a channel, select the primary channel */
+ 	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+ 
  	/* look up tcon based on tid & uid */
  	spin_lock(&cifs_tcp_ses_lock);
- 	list_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {
- 		list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
- 			list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
- 				spin_lock(&tcon->open_file_lock);
- 				cifs_stats_inc(
- 				    &tcon->stats.cifs_stats.num_oplock_brks);
- 				if (smb2_tcon_has_lease(tcon, rsp)) {
- 					spin_unlock(&tcon->open_file_lock);
- 					spin_unlock(&cifs_tcp_ses_lock);
- 					return true;
- 				}
- 				open = smb2_tcon_find_pending_open_lease(tcon,
- 									 rsp);
- 				if (open) {
- 					__u8 lease_key[SMB2_LEASE_KEY_SIZE];
- 					struct tcon_link *tlink;
- 
- 					tlink = cifs_get_tlink(open->tlink);
- 					memcpy(lease_key, open->lease_key,
- 					       SMB2_LEASE_KEY_SIZE);
- 					spin_unlock(&tcon->open_file_lock);
- 					spin_unlock(&cifs_tcp_ses_lock);
- 					smb2_queue_pending_open_break(tlink,
- 								      lease_key,
- 								      rsp->NewLeaseState);
- 					return true;
- 				}
+ 	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+ 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
+ 			spin_lock(&tcon->open_file_lock);
+ 			cifs_stats_inc(
+ 				       &tcon->stats.cifs_stats.num_oplock_brks);
+ 			if (smb2_tcon_has_lease(tcon, rsp)) {
  				spin_unlock(&tcon->open_file_lock);
+ 				spin_unlock(&cifs_tcp_ses_lock);
+ 				return true;
+ 			}
+ 			open = smb2_tcon_find_pending_open_lease(tcon,
+ 								 rsp);
+ 			if (open) {
+ 				__u8 lease_key[SMB2_LEASE_KEY_SIZE];
+ 				struct tcon_link *tlink;
  
++<<<<<<< HEAD
 +				if (tcon->crfid.is_valid &&
 +				    !memcmp(rsp->LeaseKey,
 +					    tcon->crfid.fid->lease_key,
 +					    SMB2_LEASE_KEY_SIZE)) {
 +					INIT_WORK(&tcon->crfid.lease_break,
 +						  smb2_cached_lease_break);
 +					queue_work(cifsiod_wq,
 +						   &tcon->crfid.lease_break);
 +					spin_unlock(&cifs_tcp_ses_lock);
 +					return true;
 +				}
++=======
+ 				tlink = cifs_get_tlink(open->tlink);
+ 				memcpy(lease_key, open->lease_key,
+ 				       SMB2_LEASE_KEY_SIZE);
+ 				spin_unlock(&tcon->open_file_lock);
+ 				spin_unlock(&cifs_tcp_ses_lock);
+ 				smb2_queue_pending_open_break(tlink,
+ 							      lease_key,
+ 							      rsp->NewLeaseState);
+ 				return true;
+ 			}
+ 			spin_unlock(&tcon->open_file_lock);
+ 
+ 			if (cached_dir_lease_break(tcon, rsp->LeaseKey)) {
+ 				spin_unlock(&cifs_tcp_ses_lock);
+ 				return true;
++>>>>>>> 23d9b9b757e8 (cifs: avoid unnecessary iteration of tcp sessions)
  			}
  		}
  	}
diff --cc fs/cifs/smb2ops.c
index 162fb4b62346,880cd494afea..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -4415,16 -4272,19 +4416,31 @@@ smb2_get_enc_key(struct TCP_Server_Inf
  	struct cifs_ses *ses;
  	u8 *ses_enc_key;
  
+ 	/* If server is a channel, select the primary channel */
+ 	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+ 
  	spin_lock(&cifs_tcp_ses_lock);
++<<<<<<< HEAD
 +	list_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {
 +		list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
 +			if (ses->Suid == ses_id) {
 +				ses_enc_key = enc ? ses->smb3encryptionkey :
 +					ses->smb3decryptionkey;
 +				memcpy(key, ses_enc_key, SMB3_ENC_DEC_KEY_SIZE);
 +				spin_unlock(&cifs_tcp_ses_lock);
 +				return 0;
 +			}
++=======
+ 	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+ 		if (ses->Suid == ses_id) {
+ 			spin_lock(&ses->ses_lock);
+ 			ses_enc_key = enc ? ses->smb3encryptionkey :
+ 				ses->smb3decryptionkey;
+ 			memcpy(key, ses_enc_key, SMB3_ENC_DEC_KEY_SIZE);
+ 			spin_unlock(&ses->ses_lock);
+ 			spin_unlock(&cifs_tcp_ses_lock);
+ 			return 0;
++>>>>>>> 23d9b9b757e8 (cifs: avoid unnecessary iteration of tcp sessions)
  		}
  	}
  	spin_unlock(&cifs_tcp_ses_lock);
* Unmerged path fs/cifs/smb2misc.c
* Unmerged path fs/cifs/smb2ops.c
diff --git a/fs/cifs/smb2transport.c b/fs/cifs/smb2transport.c
index 5eda4666cf82..7c9f93edcc1d 100644
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@ -81,18 +81,19 @@ static
 int smb2_get_sign_key(__u64 ses_id, struct TCP_Server_Info *server, u8 *key)
 {
 	struct cifs_chan *chan;
+	struct TCP_Server_Info *pserver;
 	struct cifs_ses *ses = NULL;
-	struct TCP_Server_Info *it = NULL;
 	int i;
 	int rc = 0;
 
 	spin_lock(&cifs_tcp_ses_lock);
 
-	list_for_each_entry(it, &cifs_tcp_ses_list, tcp_ses_list) {
-		list_for_each_entry(ses, &it->smb_ses_list, smb_ses_list) {
-			if (ses->Suid == ses_id)
-				goto found;
-		}
+	/* If server is a channel, select the primary channel */
+	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+
+	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+		if (ses->Suid == ses_id)
+			goto found;
 	}
 	cifs_server_dbg(VFS, "%s: Could not find session 0x%llx\n",
 			__func__, ses_id);
