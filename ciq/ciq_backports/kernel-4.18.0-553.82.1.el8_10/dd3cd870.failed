cifs: use new enum for ses_status

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit dd3cd8709ed5f4ae8998e0cd44c05bd26bc879e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/dd3cd870.failed

ses->status today shares statusEnum with server->tcpStatus.
This has been confusing, and tcon->status has deviated to use
a new enum. Follow suit and use new enum for ses_status as well.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit dd3cd8709ed5f4ae8998e0cd44c05bd26bc879e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsglob.h
#	fs/cifs/cifssmb.c
#	fs/cifs/connect.c
#	fs/cifs/smb2pdu.c
#	fs/cifs/smb2transport.c
#	fs/cifs/transport.c
diff --cc fs/cifs/cifsglob.h
index bfe603df9494,711cf51ac14f..000000000000
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@@ -115,7 -112,29 +115,33 @@@ enum statusEnum 
  	CifsGood,
  	CifsExiting,
  	CifsNeedReconnect,
++<<<<<<< HEAD
 +	CifsNeedNegotiate
++=======
+ 	CifsNeedNegotiate,
+ 	CifsInNegotiate,
+ };
+ 
+ /* associated with each smb session */
+ enum ses_status_enum {
+ 	SES_NEW = 0,
+ 	SES_GOOD,
+ 	SES_EXITING,
+ 	SES_NEED_RECON,
+ 	SES_IN_SETUP
+ };
+ 
+ /* associated with each tree connection to the server */
+ enum tid_status_enum {
+ 	TID_NEW = 0,
+ 	TID_GOOD,
+ 	TID_EXITING,
+ 	TID_NEED_RECON,
+ 	TID_NEED_TCON,
+ 	TID_IN_TCON,
+ 	TID_NEED_FILES_INVALIDATE, /* currently unused */
+ 	TID_IN_FILES_INVALIDATE
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  };
  
  enum securityEnum {
@@@ -929,7 -937,7 +955,11 @@@ struct cifs_ses 
  	struct mutex session_mutex;
  	struct TCP_Server_Info *server;	/* pointer to server info */
  	int ses_count;		/* reference counter */
++<<<<<<< HEAD
 +	enum statusEnum status;  /* updates protected by GlobalMid_Lock */
++=======
+ 	enum ses_status_enum ses_status;  /* updates protected by cifs_tcp_ses_lock */
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
  	char *serverOS;		/* name of operating system underlying server */
  	char *serverNOS;	/* name of network operating system of server */
diff --cc fs/cifs/cifssmb.c
index 141047242013,6371b9eebdad..000000000000
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@@ -89,6 -73,15 +89,18 @@@ cifs_mark_open_files_invalid(struct cif
  	struct list_head *tmp;
  	struct list_head *tmp1;
  
++<<<<<<< HEAD
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if ((tcon->ses->ses_status != SES_GOOD) || (tcon->status != TID_NEED_RECON)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return;
+ 	}
+ 	tcon->status = TID_IN_FILES_INVALIDATE;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  	/* list all files open on tree connection and mark them invalid */
  	spin_lock(&tcon->open_file_lock);
  	list_for_each_safe(tmp, tmp1, &tcon->openFileList) {
diff --cc fs/cifs/connect.c
index b65c3401b8e7,df4bcc581559..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -196,19 -228,25 +196,23 @@@ static void cifs_mark_tcp_ses_conns_for
  	spin_lock(&cifs_tcp_ses_lock);
  	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
  		spin_lock(&ses->chan_lock);
 -		if (!mark_smb_session && cifs_chan_needs_reconnect(ses, server))
 +		if (cifs_chan_needs_reconnect(ses, server))
  			goto next_session;
  
 -		if (mark_smb_session)
 -			CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);
 -		else
 -			cifs_chan_set_need_reconnect(ses, server);
 +		cifs_chan_set_need_reconnect(ses, server);
  
  		/* If all channels need reconnect, then tcon needs reconnect */
 -		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
  			goto next_session;
  
++<<<<<<< HEAD
 +		num_sessions++;
++=======
+ 		ses->ses_status = SES_NEED_RECON;
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  
 -		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 +		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
 -			tcon->status = TID_NEED_RECON;
 -		}
  		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
  
@@@ -1767,14 -1828,10 +1771,14 @@@ cifs_find_smb_ses(struct TCP_Server_Inf
  
  	spin_lock(&cifs_tcp_ses_lock);
  	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
- 		if (ses->status == CifsExiting)
+ 		if (ses->ses_status == SES_EXITING)
  			continue;
 -		if (!match_session(ses, ctx))
 +		spin_lock(&ses->chan_lock);
 +		if (!match_session(ses, ctx)) {
 +			spin_unlock(&ses->chan_lock);
  			continue;
 +		}
 +		spin_unlock(&ses->chan_lock);
  		++ses->ses_count;
  		spin_unlock(&cifs_tcp_ses_lock);
  		return ses;
@@@ -1808,10 -1864,9 +1812,16 @@@ void cifs_put_smb_ses(struct cifs_ses *
  	/* ses_count can never go negative */
  	WARN_ON(ses->ses_count < 0);
  
++<<<<<<< HEAD
 +	spin_lock(&GlobalMid_Lock);
 +	if (ses->status == CifsGood)
 +		ses->status = CifsExiting;
 +	spin_unlock(&GlobalMid_Lock);
++=======
+ 	if (ses->ses_status == SES_GOOD)
+ 		ses->ses_status = SES_EXITING;
+ 	spin_unlock(&cifs_tcp_ses_lock);
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  
  	cifs_free_ipc(ses);
  
@@@ -2024,9 -2090,8 +2034,9 @@@ cifs_get_smb_ses(struct TCP_Server_Inf
  	ses = cifs_find_smb_ses(server, ctx);
  	if (ses) {
  		cifs_dbg(FYI, "Existing smb sess found (status=%d)\n",
- 			 ses->status);
+ 			 ses->ses_status);
  
 +		mutex_lock(&ses->session_mutex);
  		spin_lock(&ses->chan_lock);
  		if (cifs_chan_needs_reconnect(ses, server)) {
  			spin_unlock(&ses->chan_lock);
@@@ -3942,6 -4000,16 +3952,19 @@@ cifs_setup_session(const unsigned int x
  	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
  	spin_unlock(&ses->chan_lock);
  
++<<<<<<< HEAD
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (ses->ses_status == SES_EXITING) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 
+ 	if (!is_binding)
+ 		ses->ses_status = SES_IN_SETUP;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  	if (!is_binding) {
  		ses->capabilities = server->capabilities;
  		if (!linuxExtEnabled)
@@@ -3962,8 -4030,22 +3985,25 @@@
  	if (server->ops->sess_setup)
  		rc = server->ops->sess_setup(xid, ses, server, nls_info);
  
 -	if (rc) {
 +	if (rc)
  		cifs_server_dbg(VFS, "Send error in SessSetup = %d\n", rc);
++<<<<<<< HEAD
++=======
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (ses->ses_status == SES_IN_SETUP)
+ 			ses->ses_status = SES_NEED_RECON;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 	} else {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (ses->ses_status == SES_IN_SETUP)
+ 			ses->ses_status = SES_GOOD;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 
+ 		spin_lock(&ses->chan_lock);
+ 		cifs_chan_clear_need_reconnect(ses, server);
+ 		spin_unlock(&ses->chan_lock);
+ 	}
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  
  	return rc;
  }
@@@ -4327,9 -4507,22 +4367,23 @@@ int cifs_tree_connect(const unsigned in
  	char *tree;
  	struct dfs_info3_param ref = {0};
  
++<<<<<<< HEAD
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->ses->ses_status != SES_GOOD ||
+ 	    (tcon->status != TID_NEW &&
+ 	    tcon->status != TID_NEED_TCON)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 	tcon->status = TID_IN_TCON;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  	tree = kzalloc(MAX_TREE_SIZE, GFP_KERNEL);
 -	if (!tree) {
 -		rc = -ENOMEM;
 -		goto out;
 -	}
 +	if (!tree)
 +		return -ENOMEM;
  
  	if (tcon->ipc) {
  		scnprintf(tree, MAX_TREE_SIZE, "\\\\%s\\IPC$", server->hostname);
@@@ -4362,8 -4572,34 +4416,37 @@@ out
  #else
  int cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)
  {
 -	int rc;
  	const struct smb_version_operations *ops = tcon->ses->server->ops;
  
++<<<<<<< HEAD
 +	return ops->tree_connect(xid, tcon->ses, tcon->treeName, tcon, nlsc);
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (tcon->ses->ses_status != SES_GOOD ||
+ 	    (tcon->status != TID_NEW &&
+ 	    tcon->status != TID_NEED_TCON)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 	tcon->status = TID_IN_TCON;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
+ 	rc = ops->tree_connect(xid, tcon->ses, tcon->treeName, tcon, nlsc);
+ 	if (rc) {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (tcon->status == TID_IN_TCON)
+ 			tcon->status = TID_NEED_TCON;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 	} else {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (tcon->status == TID_IN_TCON)
+ 			tcon->status = TID_GOOD;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		tcon->need_reconnect = false;
+ 	}
+ 
+ 	return rc;
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  }
  #endif
diff --cc fs/cifs/smb2pdu.c
index fdd9bd57531e,084be3a90198..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -176,7 -178,8 +176,12 @@@ smb2_reconnect(__le16 smb2_command, str
  			return -ENODEV;
  		}
  	}
++<<<<<<< HEAD
 +	if ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||
++=======
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 	if ((!tcon->ses) || (tcon->ses->ses_status == SES_EXITING) ||
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  	    (!tcon->ses->server) || !server)
  		return -EIO;
  
diff --cc fs/cifs/smb2transport.c
index 24dcef8d497b,55e79f6ee78d..000000000000
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@@ -764,21 -775,28 +764,27 @@@ smb2_get_mid_entry(struct cifs_ses *ses
  	}
  
  	if (server->tcpStatus == CifsNeedNegotiate &&
 -	   shdr->Command != SMB2_NEGOTIATE) {
 -		spin_unlock(&cifs_tcp_ses_lock);
 +	   shdr->Command != SMB2_NEGOTIATE)
  		return -EAGAIN;
 -	}
  
- 	if (ses->status == CifsNew) {
+ 	if (ses->ses_status == SES_NEW) {
  		if ((shdr->Command != SMB2_SESSION_SETUP) &&
 -		    (shdr->Command != SMB2_NEGOTIATE)) {
 -			spin_unlock(&cifs_tcp_ses_lock);
 +		    (shdr->Command != SMB2_NEGOTIATE))
  			return -EAGAIN;
 -		}
  		/* else ok - we are setting up session */
  	}
  
++<<<<<<< HEAD
 +	if (ses->status == CifsExiting) {
 +		if (shdr->Command != SMB2_LOGOFF)
++=======
+ 	if (ses->ses_status == SES_EXITING) {
+ 		if (shdr->Command != SMB2_LOGOFF) {
+ 			spin_unlock(&cifs_tcp_ses_lock);
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  			return -EAGAIN;
 -		}
  		/* else ok - we are shutting down the session */
  	}
 -	spin_unlock(&cifs_tcp_ses_lock);
  
  	*mid = smb2_mid_entry_alloc(shdr, server);
  	if (*mid == NULL)
diff --cc fs/cifs/transport.c
index d1b683a97883,05eca41e3b1e..000000000000
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@@ -719,30 -725,27 +719,35 @@@ cifs_wait_mtu_credits(struct TCP_Server
  static int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,
  			struct mid_q_entry **ppmidQ)
  {
++<<<<<<< HEAD
 +	if (ses->server->tcpStatus == CifsExiting) {
 +		return -ENOENT;
 +	}
 +
 +	if (ses->server->tcpStatus == CifsNeedReconnect) {
 +		cifs_dbg(FYI, "tcp session dead - return to caller to retry\n");
 +		return -EAGAIN;
 +	}
 +
 +	if (ses->status == CifsNew) {
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (ses->ses_status == SES_NEW) {
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  		if ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&
 -			(in_buf->Command != SMB_COM_NEGOTIATE)) {
 -			spin_unlock(&cifs_tcp_ses_lock);
 +			(in_buf->Command != SMB_COM_NEGOTIATE))
  			return -EAGAIN;
 -		}
  		/* else ok - we are setting up session */
  	}
  
- 	if (ses->status == CifsExiting) {
+ 	if (ses->ses_status == SES_EXITING) {
  		/* check if SMB session is bad because we are setting it up */
 -		if (in_buf->Command != SMB_COM_LOGOFF_ANDX) {
 -			spin_unlock(&cifs_tcp_ses_lock);
 +		if (in_buf->Command != SMB_COM_LOGOFF_ANDX)
  			return -EAGAIN;
 -		}
  		/* else ok - we are shutting down session */
  	}
 -	spin_unlock(&cifs_tcp_ses_lock);
  
 -	*ppmidQ = AllocMidQEntry(in_buf, ses->server);
 +	*ppmidQ = alloc_mid(in_buf, ses->server);
  	if (*ppmidQ == NULL)
  		return -ENOMEM;
  	spin_lock(&GlobalMid_Lock);
@@@ -1189,7 -1186,10 +1194,14 @@@ compound_send_recv(const unsigned int x
  	/*
  	 * Compounding is never used during session establish.
  	 */
++<<<<<<< HEAD
 +	if ((ses->status == CifsNew) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if ((ses->ses_status == SES_NEW) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  		mutex_lock(&server->srv_mutex);
  		smb311_update_preauth_hash(ses, server, rqst[0].rq_iov, rqst[0].rq_nvec);
  		mutex_unlock(&server->srv_mutex);
@@@ -1257,7 -1259,8 +1269,12 @@@
  	/*
  	 * Compounding is never used during session establish.
  	 */
++<<<<<<< HEAD
 +	if ((ses->status == CifsNew) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if ((ses->ses_status == SES_NEW) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {
++>>>>>>> dd3cd8709ed5 (cifs: use new enum for ses_status)
  		struct kvec iov = {
  			.iov_base = resp_iov[0].iov_base,
  			.iov_len = resp_iov[0].iov_len
diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c
index f8f3b7014863..cca257d08558 100644
--- a/fs/cifs/cifs_debug.c
+++ b/fs/cifs/cifs_debug.c
@@ -396,7 +396,7 @@ static int cifs_debug_data_proc_show(struct seq_file *m, void *v)
 				(ses->serverNOS == NULL)) {
 				seq_printf(m, "\n\t%d) Address: %s Uses: %d Capability: 0x%x\tSession Status: %d ",
 					i, ses->ip_addr, ses->ses_count,
-					ses->capabilities, ses->status);
+					ses->capabilities, ses->ses_status);
 				if (ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST)
 					seq_printf(m, "Guest ");
 				else if (ses->session_flags & SMB2_SESSION_FLAG_IS_NULL)
@@ -408,7 +408,7 @@ static int cifs_debug_data_proc_show(struct seq_file *m, void *v)
 					"\n\tSMB session status: %d ",
 				i, ses->ip_addr, ses->serverDomain,
 				ses->ses_count, ses->serverOS, ses->serverNOS,
-				ses->capabilities, ses->status);
+				ses->capabilities, ses->ses_status);
 			}
 
 			seq_printf(m, "\n\tSecurity type: %s ",
* Unmerged path fs/cifs/cifsglob.h
* Unmerged path fs/cifs/cifssmb.c
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
index 4d5f12505aa8..467d15ba2c9f 100644
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -69,7 +69,7 @@ sesInfoAlloc(void)
 	ret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);
 	if (ret_buf) {
 		atomic_inc(&sesInfoAllocCount);
-		ret_buf->status = CifsNew;
+		ret_buf->ses_status = SES_NEW;
 		++ret_buf->ses_count;
 		INIT_LIST_HEAD(&ret_buf->smb_ses_list);
 		INIT_LIST_HEAD(&ret_buf->tcon_list);
* Unmerged path fs/cifs/smb2pdu.c
* Unmerged path fs/cifs/smb2transport.c
* Unmerged path fs/cifs/transport.c
