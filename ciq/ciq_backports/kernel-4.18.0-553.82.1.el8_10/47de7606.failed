cifs: update tcpStatus during negotiate and sess setup

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 47de760655f329ce4b3d3e6276557220956d8c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/47de7606.failed

Till the end of SMB session setup, update tcpStatus and
avoid updating session status field. There was a typo in
cifs_setup_session, which caused ses->status to be updated
instead. This was causing issues during reconnect.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 47de760655f329ce4b3d3e6276557220956d8c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 9047b33cdff7,bcba3324cb4b..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3935,6 -3902,15 +3935,18 @@@ cifs_setup_session(const unsigned int x
  	int rc = -ENOSYS;
  	bool is_binding = false;
  
++<<<<<<< HEAD
++=======
+ 	/* only send once per connect */
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (server->tcpStatus != CifsNeedSessSetup) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 	server->tcpStatus = CifsInSessSetup;
+ 	spin_unlock(&cifs_tcp_ses_lock);
+ 
++>>>>>>> 47de760655f3 (cifs: update tcpStatus during negotiate and sess setup)
  	spin_lock(&ses->chan_lock);
  	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
  	spin_unlock(&ses->chan_lock);
@@@ -3959,8 -3935,24 +3971,27 @@@
  	if (server->ops->sess_setup)
  		rc = server->ops->sess_setup(xid, ses, server, nls_info);
  
 -	if (rc) {
 +	if (rc)
  		cifs_server_dbg(VFS, "Send error in SessSetup = %d\n", rc);
++<<<<<<< HEAD
++=======
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (server->tcpStatus == CifsInSessSetup)
+ 			server->tcpStatus = CifsNeedSessSetup;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 	} else {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (server->tcpStatus == CifsInSessSetup)
+ 			server->tcpStatus = CifsGood;
+ 		/* Even if one channel is active, session is in good state */
+ 		ses->status = CifsGood;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 
+ 		spin_lock(&ses->chan_lock);
+ 		cifs_chan_clear_need_reconnect(ses, server);
+ 		spin_unlock(&ses->chan_lock);
+ 	}
++>>>>>>> 47de760655f3 (cifs: update tcpStatus during negotiate and sess setup)
  
  	return rc;
  }
* Unmerged path fs/cifs/connect.c
