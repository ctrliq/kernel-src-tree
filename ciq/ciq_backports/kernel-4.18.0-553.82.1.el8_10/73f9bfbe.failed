cifs: maintain a state machine for tcp/smb/tcon sessions

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 73f9bfbe3d818bb52266d5c9f3ba57d97842ffe7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/73f9bfbe.failed

If functions like cifs_negotiate_protocol, cifs_setup_session,
cifs_tree_connect are called in parallel on different channels,
each of these will be execute the requests. This maybe unnecessary
in some cases, and only the first caller may need to do the work.

This is achieved by having more states for the tcp/smb/tcon session
status fields. And tracking the state of reconnection based on the
state machine.

For example:
for tcp connections:
CifsNew/CifsNeedReconnect ->
  CifsNeedNegotiate ->
    CifsInNegotiate ->
      CifsNeedSessSetup ->
        CifsInSessSetup ->
          CifsGood

for smb sessions:
CifsNew/CifsNeedReconnect ->
  CifsGood

for tcon:
CifsNew/CifsNeedReconnect ->
  CifsInFilesInvalidate ->
    CifsNeedTcon ->
      CifsInTcon ->
        CifsGood

If any channel reconnect sees that it's in the middle of
transition to CifsGood, then they can skip the function.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 73f9bfbe3d818bb52266d5c9f3ba57d97842ffe7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/sess.c
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/connect.c
index aa59bbf815c2,a408187c7002..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -196,19 -196,25 +196,22 @@@ static void cifs_mark_tcp_ses_conns_for
  	spin_lock(&cifs_tcp_ses_lock);
  	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
  		spin_lock(&ses->chan_lock);
 -		if (!mark_smb_session && cifs_chan_needs_reconnect(ses, server))
 +		if (cifs_chan_needs_reconnect(ses, server))
  			goto next_session;
  
 -		if (mark_smb_session)
 -			CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);
 -		else
 -			cifs_chan_set_need_reconnect(ses, server);
 +		cifs_chan_set_need_reconnect(ses, server);
  
  		/* If all channels need reconnect, then tcon needs reconnect */
 -		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
  			goto next_session;
  
+ 		ses->status = CifsNeedReconnect;
  		num_sessions++;
  
- 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
+ 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
  			tcon->need_reconnect = true;
+ 			tcon->tidStatus = CifsNeedReconnect;
+ 		}
  		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
  
@@@ -3913,12 -3881,12 +3919,18 @@@ cifs_negotiate_protocol(const unsigned 
  
  	rc = server->ops->negotiate(xid, ses, server);
  	if (rc == 0) {
++<<<<<<< HEAD
 +		spin_lock(&GlobalMid_Lock);
 +		if (server->tcpStatus == CifsNeedNegotiate)
 +			server->tcpStatus = CifsGood;
++=======
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (server->tcpStatus == CifsInNegotiate)
+ 			server->tcpStatus = CifsNeedSessSetup;
++>>>>>>> 73f9bfbe3d81 (cifs: maintain a state machine for tcp/smb/tcon sessions)
  		else
  			rc = -EHOSTDOWN;
 -		spin_unlock(&cifs_tcp_ses_lock);
 +		spin_unlock(&GlobalMid_Lock);
  	}
  
  	return rc;
diff --cc fs/cifs/sess.c
index 1b56022e96fb,d12490e12be5..000000000000
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@@ -1056,9 -1053,10 +1057,14 @@@ sess_establish_session(struct sess_dat
  	spin_unlock(&ses->chan_lock);
  
  	/* Even if one channel is active, session is in good state */
++<<<<<<< HEAD
 +	spin_lock(&GlobalMid_Lock);
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	server->tcpStatus = CifsGood;
++>>>>>>> 73f9bfbe3d81 (cifs: maintain a state machine for tcp/smb/tcon sessions)
  	ses->status = CifsGood;
 -	spin_unlock(&cifs_tcp_ses_lock);
 +	spin_unlock(&GlobalMid_Lock);
  
  	return 0;
  }
diff --cc fs/cifs/smb2pdu.c
index fdd9bd57531e,2725e62470e4..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -255,11 -256,13 +249,10 @@@ smb2_reconnect(__le16 smb2_command, str
  	 * and the server never sends an answer the socket will be closed
  	 * and tcpStatus set to reconnect.
  	 */
 -	spin_lock(&cifs_tcp_ses_lock);
  	if (server->tcpStatus == CifsNeedReconnect) {
 -		spin_unlock(&cifs_tcp_ses_lock);
  		rc = -EHOSTDOWN;
- 		mutex_unlock(&ses->session_mutex);
  		goto out;
  	}
 -	spin_unlock(&cifs_tcp_ses_lock);
  
  	/*
  	 * need to prevent multiple threads trying to simultaneously
@@@ -1389,9 -1389,10 +1382,14 @@@ SMB2_sess_establish_session(struct SMB2
  	spin_unlock(&ses->chan_lock);
  
  	/* Even if one channel is active, session is in good state */
++<<<<<<< HEAD
 +	spin_lock(&GlobalMid_Lock);
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	server->tcpStatus = CifsGood;
++>>>>>>> 73f9bfbe3d81 (cifs: maintain a state machine for tcp/smb/tcon sessions)
  	ses->status = CifsGood;
 -	spin_unlock(&cifs_tcp_ses_lock);
 +	spin_unlock(&GlobalMid_Lock);
  
  	return rc;
  }
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bfe603df9494..696f34984725 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -115,7 +115,13 @@ enum statusEnum {
 	CifsGood,
 	CifsExiting,
 	CifsNeedReconnect,
-	CifsNeedNegotiate
+	CifsNeedNegotiate,
+	CifsInNegotiate,
+	CifsNeedSessSetup,
+	CifsInSessSetup,
+	CifsNeedTcon,
+	CifsInTcon,
+	CifsInFilesInvalidate
 };
 
 enum securityEnum {
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 141047242013..350a0960010a 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -89,6 +89,16 @@ cifs_mark_open_files_invalid(struct cifs_tcon *tcon)
 	struct list_head *tmp;
 	struct list_head *tmp1;
 
+	/* only send once per connect */
+	spin_lock(&cifs_tcp_ses_lock);
+	if (tcon->ses->status != CifsGood ||
+	    tcon->tidStatus != CifsNeedReconnect) {
+		spin_unlock(&cifs_tcp_ses_lock);
+		return;
+	}
+	tcon->tidStatus = CifsInFilesInvalidate;
+	spin_unlock(&cifs_tcp_ses_lock);
+
 	/* list all files open on tree connection and mark them invalid */
 	spin_lock(&tcon->open_file_lock);
 	list_for_each_safe(tmp, tmp1, &tcon->openFileList) {
@@ -105,6 +115,11 @@ cifs_mark_open_files_invalid(struct cifs_tcon *tcon)
 	memset(tcon->crfid.fid, 0, sizeof(struct cifs_fid));
 	mutex_unlock(&tcon->crfid.fid_mutex);
 
+	spin_lock(&cifs_tcp_ses_lock);
+	if (tcon->tidStatus == CifsInFilesInvalidate)
+		tcon->tidStatus = CifsNeedTcon;
+	spin_unlock(&cifs_tcp_ses_lock);
+
 	/*
 	 * BB Add call to invalidate_inodes(sb) for all superblocks mounted
 	 * to this tcon.
@@ -191,12 +206,6 @@ cifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)
 
 	nls_codepage = load_nls_default();
 
-	/*
-	 * need to prevent multiple threads trying to simultaneously
-	 * reconnect the same SMB session
-	 */
-	mutex_lock(&ses->session_mutex);
-
 	/*
 	 * Recheck after acquire mutex. If another thread is negotiating
 	 * and the server never sends an answer the socket will be closed
@@ -204,7 +213,6 @@ cifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)
 	 */
 	if (server->tcpStatus == CifsNeedReconnect) {
 		rc = -EHOSTDOWN;
-		mutex_unlock(&ses->session_mutex);
 		goto out;
 	}
 
@@ -221,11 +229,11 @@ cifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)
 			goto skip_sess_setup;
 
 		rc = -EHOSTDOWN;
-		mutex_unlock(&ses->session_mutex);
 		goto out;
 	}
 	spin_unlock(&ses->chan_lock);
 
+	mutex_lock(&ses->session_mutex);
 	rc = cifs_negotiate_protocol(0, ses, server);
 	if (!rc)
 		rc = cifs_setup_session(0, ses, server, nls_codepage);
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/sess.c
* Unmerged path fs/cifs/smb2pdu.c
