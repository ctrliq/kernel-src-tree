cifs: fix race condition with delayed threads

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 50bd7d5a647bdf533575111c5335f49707c2ce2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/50bd7d5a.failed

On failure to create a new channel, first cancel the
delayed threads, which could try to search for this
channel, and not find it.

The other option was to put the tcp session for the
channel first, before decrementing chan_count. But
that would leave a reference to the tcp session, when
it has been freed already.

So going with the former option and cancelling the
delayed works first, before rolling back the channel.

Fixes: aa45dadd34e4 ("cifs: change iface_list from array to sorted linked list")
	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Acked-by: Enzo Matsumiya <ematsumiya@suse.de>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 50bd7d5a647bdf533575111c5335f49707c2ce2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/sess.c
diff --cc fs/cifs/sess.c
index 6a745143a3f1,02c8b2906196..000000000000
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@@ -429,8 -470,18 +429,16 @@@ cifs_ses_add_channel(struct cifs_sb_inf
  	if (!rc)
  		rc = cifs_setup_session(xid, ses, chan->server, cifs_sb->local_nls);
  
 -	mutex_unlock(&ses->session_mutex);
 -
  out:
  	if (rc && chan->server) {
+ 		/*
+ 		 * we should avoid race with these delayed works before we
+ 		 * remove this channel
+ 		 */
+ 		cancel_delayed_work_sync(&chan->server->echo);
+ 		cancel_delayed_work_sync(&chan->server->resolve);
+ 		cancel_delayed_work_sync(&chan->server->reconnect);
+ 
  		spin_lock(&ses->chan_lock);
  		/* we rely on all bits beyond chan_count to be clear */
  		cifs_chan_clear_need_reconnect(ses, chan->server);
@@@ -441,12 -492,9 +449,15 @@@
  		 */
  		WARN_ON(ses->chan_count < 1);
  		spin_unlock(&ses->chan_lock);
- 	}
  
++<<<<<<< HEAD
 +	mutex_unlock(&ses->session_mutex);
 +
 +	if (rc && chan->server)
++=======
++>>>>>>> 50bd7d5a647b (cifs: fix race condition with delayed threads)
  		cifs_put_tcp_session(chan->server, 0);
+ 	}
  
  	return rc;
  }
* Unmerged path fs/cifs/sess.c
