cifs: avoid races in parallel reconnects in smb1

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Paulo Alcantara <pc@manguebit.com>
commit 6cc041e90c178955219dcee4030bd5423f800f10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/6cc041e9.failed

Prevent multiple threads of doing negotiate, session setup and tree
connect by holding @ses->session_mutex in cifs_reconnect_tcon() while
reconnecting session and tcon.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
	Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 6cc041e90c178955219dcee4030bd5423f800f10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifssmb.c
diff --cc fs/cifs/cifssmb.c
index 9d8d1d5da728,c9d57ba84be4..000000000000
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@@ -118,8 -71,7 +118,12 @@@ cifs_reconnect_tcon(struct cifs_tcon *t
  	int rc;
  	struct cifs_ses *ses;
  	struct TCP_Server_Info *server;
++<<<<<<< HEAD
 +	struct nls_table *nls_codepage;
 +	int retries;
++=======
+ 	struct nls_table *nls_codepage = NULL;
++>>>>>>> 6cc041e90c17 (cifs: avoid races in parallel reconnects in smb1)
  
  	/*
  	 * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for
@@@ -145,42 -97,12 +149,49 @@@
  			return -ENODEV;
  		}
  	}
 -	spin_unlock(&tcon->tc_lock);
  
++<<<<<<< HEAD
 +	retries = server->nr_targets;
 +
 +	/*
 +	 * Give demultiplex thread up to 10 seconds to each target available for
 +	 * reconnect -- should be greater than cifs socket timeout which is 7
 +	 * seconds.
 +	 */
 +	while (server->tcpStatus == CifsNeedReconnect) {
 +		rc = wait_event_interruptible_timeout(server->response_q,
 +						      (server->tcpStatus != CifsNeedReconnect),
 +						      10 * HZ);
 +		if (rc < 0) {
 +			cifs_dbg(FYI, "%s: aborting reconnect due to a received signal by the process\n",
 +				 __func__);
 +			return -ERESTARTSYS;
 +		}
 +
 +		/* are we still trying to reconnect? */
 +		if (server->tcpStatus != CifsNeedReconnect)
 +			break;
 +
 +		if (retries && --retries)
 +			continue;
 +
 +		/*
 +		 * on "soft" mounts we wait once. Hard mounts keep
 +		 * retrying until process is killed or server comes
 +		 * back on-line
 +		 */
 +		if (!tcon->retry) {
 +			cifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");
 +			return -EHOSTDOWN;
 +		}
 +		retries = server->nr_targets;
 +	}
++=======
+ again:
+ 	rc = cifs_wait_for_server_reconnect(server, tcon->retry);
+ 	if (rc)
+ 		return rc;
++>>>>>>> 6cc041e90c17 (cifs: avoid races in parallel reconnects in smb1)
  
  	spin_lock(&ses->chan_lock);
  	if (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {
@@@ -189,25 -111,26 +200,34 @@@
  	}
  	spin_unlock(&ses->chan_lock);
  
- 	nls_codepage = load_nls_default();
- 
+ 	mutex_lock(&ses->session_mutex);
 +	/*
 +	 * need to prevent multiple threads trying to simultaneously
 +	 * reconnect the same SMB session
 +	 */
 +	mutex_lock(&ses->session_mutex);
 +
  	/*
  	 * Recheck after acquire mutex. If another thread is negotiating
  	 * and the server never sends an answer the socket will be closed
  	 * and tcpStatus set to reconnect.
  	 */
 -	spin_lock(&server->srv_lock);
  	if (server->tcpStatus == CifsNeedReconnect) {
++<<<<<<< HEAD
++=======
+ 		spin_unlock(&server->srv_lock);
+ 		mutex_lock(&ses->session_mutex);
+ 
+ 		if (tcon->retry)
+ 			goto again;
++>>>>>>> 6cc041e90c17 (cifs: avoid races in parallel reconnects in smb1)
  		rc = -EHOSTDOWN;
 +		mutex_unlock(&ses->session_mutex);
  		goto out;
  	}
 -	spin_unlock(&server->srv_lock);
  
+ 	nls_codepage = load_nls_default();
+ 
  	/*
  	 * need to prevent multiple threads trying to simultaneously
  	 * reconnect the same SMB session
@@@ -220,7 -146,6 +243,10 @@@
  		if (tcon->need_reconnect)
  			goto skip_sess_setup;
  
++<<<<<<< HEAD
 +		rc = -EHOSTDOWN;
++=======
++>>>>>>> 6cc041e90c17 (cifs: avoid races in parallel reconnects in smb1)
  		mutex_unlock(&ses->session_mutex);
  		goto out;
  	}
* Unmerged path fs/cifs/cifssmb.c
