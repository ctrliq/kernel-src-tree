cifs: fix session state check in reconnect to avoid use-after-free issue

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Winston Wen <wentao@uniontech.com>
commit 99f280700b4cc02d5f141b8d15f8e9fad0418f65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/99f28070.failed

Don't collect exiting session in smb2_reconnect_server(), because it
will be released soon.

Note that the exiting session will stay in server->smb_ses_list until
it complete the cifs_free_ipc() and logoff() and then delete itself
from the list.

	Signed-off-by: Winston Wen <wentao@uniontech.com>
	Reviewed-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 99f280700b4cc02d5f141b8d15f8e9fad0418f65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/smb2pdu.c
index 4261a90e8093,e04766fe6f80..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -3799,22 -3776,36 +3799,35 @@@ void smb2_reconnect_server(struct work_
  {
  	struct TCP_Server_Info *server = container_of(work,
  					struct TCP_Server_Info, reconnect.work);
 -	struct TCP_Server_Info *pserver;
 -	struct cifs_ses *ses, *ses2;
 +	struct cifs_ses *ses;
  	struct cifs_tcon *tcon, *tcon2;
 -	struct list_head tmp_list, tmp_ses_list;
 -	bool tcon_exist = false, ses_exist = false;
 -	bool tcon_selected = false;
 +	struct list_head tmp_list;
 +	int tcon_exist = false;
  	int rc;
 -	bool resched = false;
 +	int resched = false;
  
 -	/* If server is a channel, select the primary channel */
 -	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
  
  	/* Prevent simultaneous reconnects that can corrupt tcon->rlist list */
 -	mutex_lock(&pserver->reconnect_mutex);
 +	mutex_lock(&server->reconnect_mutex);
  
  	INIT_LIST_HEAD(&tmp_list);
 -	INIT_LIST_HEAD(&tmp_ses_list);
 -	cifs_dbg(FYI, "Reconnecting tcons and channels\n");
 +	cifs_dbg(FYI, "Need negotiate, reconnecting tcons\n");
  
  	spin_lock(&cifs_tcp_ses_lock);
++<<<<<<< HEAD:fs/cifs/smb2pdu.c
 +	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
++=======
+ 	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+ 		spin_lock(&ses->ses_lock);
+ 		if (ses->ses_status == SES_EXITING) {
+ 			spin_unlock(&ses->ses_lock);
+ 			continue;
+ 		}
+ 		spin_unlock(&ses->ses_lock);
+ 
+ 		tcon_selected = false;
+ 
++>>>>>>> 99f280700b4c (cifs: fix session state check in reconnect to avoid use-after-free issue):fs/smb/client/smb2pdu.c
  		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
  			if (tcon->need_reconnect || tcon->need_reopen_files) {
  				tcon->tc_count++;
* Unmerged path fs/cifs/smb2pdu.c
