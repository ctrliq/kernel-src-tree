cifs: avoid race during socket reconnect between send and recv

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit bda487ac4bebf871255cc6f23e16f702cea0ca7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/bda487ac.failed

When a TCP connection gets reestablished by the sender in cifs_reconnect,
There is a chance for race condition with demultiplex thread waiting in
cifs_readv_from_socket on the old socket. It will now return -ECONNRESET.

This condition is handled by comparing socket pointer before and after
sock_recvmsg. If the socket pointer has changed, we should not call
cifs_reconnect again, but instead retry with new socket.

Also fixed another bug in my prev mchan commits.
We should always reestablish session (even if binding) on a channel
that needs reconnection.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit bda487ac4bebf871255cc6f23e16f702cea0ca7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/connect.c
index aa59bbf815c2,1dafaf7c4e5e..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -169,10 -166,13 +169,10 @@@ static void cifs_resolve_server(struct 
   * Mark all sessions and tcons for reconnect.
   *
   * @server needs to be previously set to CifsNeedReconnect.
 - *
   */
 -static void
 -cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,
 -				      bool mark_smb_session)
 +static void cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server)
  {
- 	unsigned int num_sessions = 0;
+ 	struct TCP_Server_Info *pserver;
  	struct cifs_ses *ses;
  	struct cifs_tcon *tcon;
  	struct mid_q_entry *mid, *nmid;
@@@ -202,13 -201,15 +201,17 @@@
  		cifs_chan_set_need_reconnect(ses, server);
  
  		/* If all channels need reconnect, then tcon needs reconnect */
 -		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
  			goto next_session;
  
++<<<<<<< HEAD
 +		num_sessions++;
++=======
+ 		ses->status = CifsNeedReconnect;
++>>>>>>> bda487ac4beb (cifs: avoid race during socket reconnect between send and recv)
  
 -		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 +		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
 -			tcon->tidStatus = CifsNeedReconnect;
 -		}
  		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
  
diff --cc fs/cifs/smb2pdu.c
index fdd9bd57531e,8d471df69c59..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -273,8 -276,6 +273,11 @@@ smb2_reconnect(__le16 smb2_command, str
  		if (tcon->need_reconnect)
  			goto skip_sess_setup;
  
++<<<<<<< HEAD
 +		rc = -EHOSTDOWN;
 +		mutex_unlock(&ses->session_mutex);
++=======
++>>>>>>> bda487ac4beb (cifs: avoid race during socket reconnect between send and recv)
  		goto out;
  	}
  	spin_unlock(&ses->chan_lock);
@@@ -3869,9 -3857,11 +3872,9 @@@ SMB2_echo(struct TCP_Server_Info *serve
  				 .rq_nvec = 1 };
  	unsigned int total_len;
  
- 	cifs_dbg(FYI, "In echo request\n");
+ 	cifs_dbg(FYI, "In echo request for conn_id %lld\n", server->conn_id);
  
 -	spin_lock(&cifs_tcp_ses_lock);
  	if (server->tcpStatus == CifsNeedNegotiate) {
 -		spin_unlock(&cifs_tcp_ses_lock);
  		/* No need to send echo on newly established connections */
  		mod_delayed_work(cifsiod_wq, &server->reconnect, 0);
  		return rc;
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/smb2pdu.c
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index 680bba1f6d90..d50cbc8e2844 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -1045,18 +1045,9 @@ struct TCP_Server_Info *cifs_pick_channel(struct cifs_ses *ses)
 	if (!ses)
 		return NULL;
 
-	spin_lock(&ses->chan_lock);
 	/* round robin */
-pick_another:
-	if (ses->chan_count > 1 &&
-	    !CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {
-		index = (uint)atomic_inc_return(&ses->chan_seq);
-		index %= ses->chan_count;
-
-		if (CIFS_CHAN_NEEDS_RECONNECT(ses, index))
-			goto pick_another;
-	}
-	spin_unlock(&ses->chan_lock);
+	index = (uint)atomic_inc_return(&ses->chan_seq);
+	index %= ses->chan_count;
 
 	return ses->chans[index].server;
 }
