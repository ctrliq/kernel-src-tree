cifs: missing lock when updating session status

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Steve French <stfrench@microsoft.com>
commit 943fb67b090212f1d3789eb7796b1c9045c62fd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/943fb67b.failed

Coverity noted a place where we were not grabbing
the ses_lock when setting (and checking) ses_status.

Addresses-Coverity: 1536833 ("Data race condition (MISSING_LOCK)")
	Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
	Reviewed-by: Bharath SM <bharathsm@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 943fb67b090212f1d3789eb7796b1c9045c62fd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 86456687828e,7bfef741f758..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -1810,14 -1916,13 +1810,24 @@@ void cifs_put_smb_ses(struct cifs_ses *
  	/* ses_count can never go negative */
  	WARN_ON(ses->ses_count < 0);
  
++<<<<<<< HEAD
 +	spin_lock(&GlobalMid_Lock);
 +	if (ses->status == CifsGood)
 +		ses->status = CifsExiting;
 +	spin_unlock(&GlobalMid_Lock);
 +
 +	cifs_free_ipc(ses);
 +
 +	if (ses->status == CifsExiting && server->ops->logoff) {
++=======
+ 	spin_lock(&ses->ses_lock);
+ 	if (ses->ses_status == SES_GOOD)
+ 		ses->ses_status = SES_EXITING;
+ 
+ 	if (ses->ses_status == SES_EXITING && server->ops->logoff) {
+ 		spin_unlock(&ses->ses_lock);
+ 		cifs_free_ipc(ses);
++>>>>>>> 943fb67b0902 (cifs: missing lock when updating session status)
  		xid = get_xid();
  		rc = server->ops->logoff(xid, ses);
  		if (rc)
* Unmerged path fs/cifs/connect.c
