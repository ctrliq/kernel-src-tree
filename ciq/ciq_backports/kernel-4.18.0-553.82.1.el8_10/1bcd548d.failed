cifs: prevent data race in cifs_reconnect_tcon()

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Paulo Alcantara <pc@manguebit.com>
commit 1bcd548d935a33c6fc58331405eb1b82fd6150de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/1bcd548d.failed

Make sure to get an up-to-date TCP_Server_Info::nr_targets value prior
to waiting the server to be reconnected in cifs_reconnect_tcon().  It
is set in cifs_tcp_ses_needs_reconnect() and protected by
TCP_Server_Info::srv_lock.

Create a new cifs_wait_for_server_reconnect() helper that can be used
by both SMB2+ and CIFS reconnect code.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 1bcd548d935a33c6fc58331405eb1b82fd6150de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifssmb.c
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/cifssmb.c
index 9d8d1d5da728,a43c78396dd8..000000000000
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@@ -145,42 -99,11 +144,48 @@@ cifs_reconnect_tcon(struct cifs_tcon *t
  			return -ENODEV;
  		}
  	}
 -	spin_unlock(&tcon->tc_lock);
  
++<<<<<<< HEAD
 +	retries = server->nr_targets;
 +
 +	/*
 +	 * Give demultiplex thread up to 10 seconds to each target available for
 +	 * reconnect -- should be greater than cifs socket timeout which is 7
 +	 * seconds.
 +	 */
 +	while (server->tcpStatus == CifsNeedReconnect) {
 +		rc = wait_event_interruptible_timeout(server->response_q,
 +						      (server->tcpStatus != CifsNeedReconnect),
 +						      10 * HZ);
 +		if (rc < 0) {
 +			cifs_dbg(FYI, "%s: aborting reconnect due to a received signal by the process\n",
 +				 __func__);
 +			return -ERESTARTSYS;
 +		}
 +
 +		/* are we still trying to reconnect? */
 +		if (server->tcpStatus != CifsNeedReconnect)
 +			break;
 +
 +		if (retries && --retries)
 +			continue;
 +
 +		/*
 +		 * on "soft" mounts we wait once. Hard mounts keep
 +		 * retrying until process is killed or server comes
 +		 * back on-line
 +		 */
 +		if (!tcon->retry) {
 +			cifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");
 +			return -EHOSTDOWN;
 +		}
 +		retries = server->nr_targets;
 +	}
++=======
+ 	rc = cifs_wait_for_server_reconnect(server, tcon->retry);
+ 	if (rc)
+ 		return rc;
++>>>>>>> 1bcd548d935a (cifs: prevent data race in cifs_reconnect_tcon())
  
  	spin_lock(&ses->chan_lock);
  	if (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {
diff --cc fs/cifs/smb2pdu.c
index b72fbca5ee79,0e53265e1462..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -180,57 -183,31 +180,84 @@@ smb2_reconnect(__le16 smb2_command, str
  	    (!tcon->ses->server) || !server)
  		return -EIO;
  
++<<<<<<< HEAD
++=======
+ 	spin_lock(&server->srv_lock);
+ 	if (server->tcpStatus == CifsNeedReconnect) {
+ 		/*
+ 		 * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE
+ 		 * here since they are implicitly done when session drops.
+ 		 */
+ 		switch (smb2_command) {
+ 		/*
+ 		 * BB Should we keep oplock break and add flush to exceptions?
+ 		 */
+ 		case SMB2_TREE_DISCONNECT:
+ 		case SMB2_CANCEL:
+ 		case SMB2_CLOSE:
+ 		case SMB2_OPLOCK_BREAK:
+ 			spin_unlock(&server->srv_lock);
+ 			return -EAGAIN;
+ 		}
+ 	}
+ 	spin_unlock(&server->srv_lock);
+ 
+ 	rc = cifs_wait_for_server_reconnect(server, tcon->retry);
+ 	if (rc)
+ 		return rc;
+ 
++>>>>>>> 1bcd548d935a (cifs: prevent data race in cifs_reconnect_tcon())
  	ses = tcon->ses;
 +	retries = server->nr_targets;
 +
 +	/*
 +	 * Give demultiplex thread up to 10 seconds to each target available for
 +	 * reconnect -- should be greater than cifs socket timeout which is 7
 +	 * seconds.
 +	 */
 +	while (server->tcpStatus == CifsNeedReconnect) {
 +		/*
 +		 * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE
 +		 * here since they are implicitly done when session drops.
 +		 */
 +		switch (smb2_command) {
 +		/*
 +		 * BB Should we keep oplock break and add flush to exceptions?
 +		 */
 +		case SMB2_TREE_DISCONNECT:
 +		case SMB2_CANCEL:
 +		case SMB2_CLOSE:
 +		case SMB2_OPLOCK_BREAK:
 +			return -EAGAIN;
 +		}
 +
 +		rc = wait_event_interruptible_timeout(server->response_q,
 +						      (server->tcpStatus != CifsNeedReconnect),
 +						      10 * HZ);
 +		if (rc < 0) {
 +			cifs_dbg(FYI, "%s: aborting reconnect due to a received signal by the process\n",
 +				 __func__);
 +			return -ERESTARTSYS;
 +		}
 +
 +		/* are we still trying to reconnect? */
 +		if (server->tcpStatus != CifsNeedReconnect)
 +			break;
 +
 +		if (retries && --retries)
 +			continue;
 +
 +		/*
 +		 * on "soft" mounts we wait once. Hard mounts keep
 +		 * retrying until process is killed or server comes
 +		 * back on-line
 +		 */
 +		if (!tcon->retry) {
 +			cifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");
 +			return -EHOSTDOWN;
 +		}
 +		retries = server->nr_targets;
 +	}
  
  	spin_lock(&ses->chan_lock);
  	if (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
index 76582fa73223..7a472287534a 100644
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -656,6 +656,7 @@ static inline int cifs_create_options(struct cifs_sb_info *cifs_sb, int options)
 
 struct super_block *cifs_get_tcon_super(struct cifs_tcon *tcon);
 void cifs_put_tcon_super(struct super_block *sb);
+int cifs_wait_for_server_reconnect(struct TCP_Server_Info *server, bool retry);
 
 static inline void release_mid(struct mid_q_entry *mid)
 {
* Unmerged path fs/cifs/cifssmb.c
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
index 8fdd91a0addb..662ba1cea923 100644
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -1159,3 +1159,47 @@ int cifs_update_super_prepath(struct cifs_sb_info *cifs_sb, char *prefix)
 	return 0;
 }
 #endif
+
+int cifs_wait_for_server_reconnect(struct TCP_Server_Info *server, bool retry)
+{
+	int timeout = 10;
+	int rc;
+
+	spin_lock(&server->srv_lock);
+	if (server->tcpStatus != CifsNeedReconnect) {
+		spin_unlock(&server->srv_lock);
+		return 0;
+	}
+	timeout *= server->nr_targets;
+	spin_unlock(&server->srv_lock);
+
+	/*
+	 * Give demultiplex thread up to 10 seconds to each target available for
+	 * reconnect -- should be greater than cifs socket timeout which is 7
+	 * seconds.
+	 *
+	 * On "soft" mounts we wait once. Hard mounts keep retrying until
+	 * process is killed or server comes back on-line.
+	 */
+	do {
+		rc = wait_event_interruptible_timeout(server->response_q,
+						      (server->tcpStatus != CifsNeedReconnect),
+						      timeout * HZ);
+		if (rc < 0) {
+			cifs_dbg(FYI, "%s: aborting reconnect due to received signal\n",
+				 __func__);
+			return -ERESTARTSYS;
+		}
+
+		/* are we still trying to reconnect? */
+		spin_lock(&server->srv_lock);
+		if (server->tcpStatus != CifsNeedReconnect) {
+			spin_unlock(&server->srv_lock);
+			return 0;
+		}
+		spin_unlock(&server->srv_lock);
+	} while (retry);
+
+	cifs_dbg(FYI, "%s: gave up waiting on reconnect\n", __func__);
+	return -EHOSTDOWN;
+}
* Unmerged path fs/cifs/smb2pdu.c
