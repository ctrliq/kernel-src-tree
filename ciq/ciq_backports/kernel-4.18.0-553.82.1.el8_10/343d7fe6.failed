smb: client: fix use-after-free of signing key

jira LE-4669
cve CVE-2024-53179
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Paulo Alcantara <pc@manguebit.com>
commit 343d7fe6df9e247671440a932b6a73af4fa86d95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/343d7fe6.failed

Customers have reported use-after-free in @ses->auth_key.response with
SMB2.1 + sign mounts which occurs due to following race:

task A                         task B
cifs_mount()
 dfs_mount_share()
  get_session()
   cifs_mount_get_session()    cifs_send_recv()
    cifs_get_smb_ses()          compound_send_recv()
     cifs_setup_session()        smb2_setup_request()
      kfree_sensitive()           smb2_calc_signature()
                                   crypto_shash_setkey() *UAF*

Fix this by ensuring that we have a valid @ses->auth_key.response by
checking whether @ses->ses_status is SES_GOOD or SES_EXITING with
@ses->ses_lock held.  After commit 24a9799aa8ef ("smb: client: fix UAF
in smb2_reconnect_server()"), we made sure to call ->logoff() only
when @ses was known to be good (e.g. valid ->auth_key.response), so
it's safe to access signing key when @ses->ses_status == SES_EXITING.

	Cc: stable@vger.kernel.org
	Reported-by: Jay Shin <jaeshin@redhat.com>
	Signed-off-by: Paulo Alcantara (Red Hat) <pc@manguebit.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 343d7fe6df9e247671440a932b6a73af4fa86d95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2transport.c
diff --cc fs/cifs/smb2transport.c
index c6bf79f874d4,475b36c27f65..000000000000
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@@ -78,13 -74,14 +78,13 @@@ err
  
  
  static
- int smb2_get_sign_key(__u64 ses_id, struct TCP_Server_Info *server, u8 *key)
+ int smb3_get_sign_key(__u64 ses_id, struct TCP_Server_Info *server, u8 *key)
  {
  	struct cifs_chan *chan;
 -	struct TCP_Server_Info *pserver;
  	struct cifs_ses *ses = NULL;
 +	struct TCP_Server_Info *it = NULL;
  	int i;
  	int rc = 0;
 -	bool is_binding = false;
  
  	spin_lock(&cifs_tcp_ses_lock);
  
@@@ -225,16 -261,16 +250,30 @@@ smb2_calc_signature(struct smb_rqst *rq
  	unsigned char *sigptr = smb2_signature;
  	struct kvec *iov = rqst->rq_iov;
  	struct smb2_hdr *shdr = (struct smb2_hdr *)iov[0].iov_base;
++<<<<<<< HEAD:fs/cifs/smb2transport.c
 +	struct cifs_ses *ses;
 +	struct shash_desc *shash;
 +	struct crypto_shash *hash;
 +	struct sdesc *sdesc = NULL;
++=======
+ 	struct shash_desc *shash = NULL;
++>>>>>>> 343d7fe6df9e (smb: client: fix use-after-free of signing key):fs/smb/client/smb2transport.c
  	struct smb_rqst drqst;
+ 	__u64 sid = le64_to_cpu(shdr->SessionId);
+ 	u8 key[SMB2_NTLMV2_SESSKEY_SIZE];
  
++<<<<<<< HEAD:fs/cifs/smb2transport.c
 +	ses = smb2_find_smb_ses(server, le64_to_cpu(shdr->SessionId));
 +	if (unlikely(!ses)) {
 +		cifs_server_dbg(VFS, "%s: Could not find session\n", __func__);
 +		return -ENOENT;
++=======
+ 	rc = smb2_get_sign_key(server, sid, key);
+ 	if (unlikely(rc)) {
+ 		cifs_server_dbg(FYI, "%s: [sesid=0x%llx] couldn't find signing key: %d\n",
+ 				__func__, sid, rc);
+ 		return rc;
++>>>>>>> 343d7fe6df9e (smb: client: fix use-after-free of signing key):fs/smb/client/smb2transport.c
  	}
  
  	memset(smb2_signature, 0x0, SMB2_HMACSHA256_SIZE);
@@@ -247,14 -283,11 +286,18 @@@
  					"%s: sha256 alloc failed\n", __func__);
  			goto out;
  		}
 +		shash = &sdesc->shash;
  	} else {
 -		shash = server->secmech.hmacsha256;
 +		hash = server->secmech.hmacsha256;
 +		shash = &server->secmech.sdeschmacsha256->shash;
  	}
  
++<<<<<<< HEAD:fs/cifs/smb2transport.c
 +	rc = crypto_shash_setkey(hash, ses->auth_key.response,
 +			SMB2_NTLMV2_SESSKEY_SIZE);
++=======
+ 	rc = crypto_shash_setkey(shash->tfm, key, sizeof(key));
++>>>>>>> 343d7fe6df9e (smb: client: fix use-after-free of signing key):fs/smb/client/smb2transport.c
  	if (rc) {
  		cifs_server_dbg(VFS,
  				"%s: Could not update with response\n",
@@@ -295,9 -328,7 +338,13 @@@
  
  out:
  	if (allocate_crypto)
++<<<<<<< HEAD:fs/cifs/smb2transport.c
 +		cifs_free_hash(&hash, &sdesc);
 +	if (ses)
 +		cifs_put_smb_ses(ses);
++=======
+ 		cifs_free_hash(&shash);
++>>>>>>> 343d7fe6df9e (smb: client: fix use-after-free of signing key):fs/smb/client/smb2transport.c
  	return rc;
  }
  
diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h
index 7fe6780e742d..fa38497d7d67 100644
--- a/fs/cifs/smb2proto.h
+++ b/fs/cifs/smb2proto.h
@@ -37,8 +37,6 @@ extern struct mid_q_entry *smb2_setup_request(struct cifs_ses *ses,
 					      struct smb_rqst *rqst);
 extern struct mid_q_entry *smb2_setup_async_request(
 			struct TCP_Server_Info *server, struct smb_rqst *rqst);
-extern struct cifs_ses *smb2_find_smb_ses(struct TCP_Server_Info *server,
-					   __u64 ses_id);
 extern struct cifs_tcon *smb2_find_smb_tcon(struct TCP_Server_Info *server,
 						__u64 ses_id, __u32  tid);
 extern int smb2_calc_signature(struct smb_rqst *rqst,
* Unmerged path fs/cifs/smb2transport.c
