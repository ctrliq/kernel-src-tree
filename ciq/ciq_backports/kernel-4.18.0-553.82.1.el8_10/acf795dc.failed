ext4: convert to exclusive lock while inserting delalloc extents

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Zhang Yi <yi.zhang@huawei.com>
commit acf795dc161f3cf481db20f05db4250714e375e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/acf795dc.failed

ext4_da_map_blocks() only hold i_data_sem in shared mode and i_rwsem
when inserting delalloc extents, it could be raced by another querying
path of ext4_map_blocks() without i_rwsem, .e.g buffered read path.
Suppose we buffered read a file containing just a hole, and without any
cached extents tree, then it is raced by another delayed buffered write
to the same area or the near area belongs to the same hole, and the new
delalloc extent could be overwritten to a hole extent.

 pread()                           pwrite()
  filemap_read_folio()
   ext4_mpage_readpages()
    ext4_map_blocks()
     down_read(i_data_sem)
     ext4_ext_determine_hole()
     //find hole
     ext4_ext_put_gap_in_cache()
      ext4_es_find_extent_range()
      //no delalloc extent
                                    ext4_da_map_blocks()
                                     down_read(i_data_sem)
                                     ext4_insert_delayed_block()
                                     //insert delalloc extent
      ext4_es_insert_extent()
      //overwrite delalloc extent to hole

This race could lead to inconsistent delalloc extents tree and
incorrect reserved space counter. Fix this by converting to hold
i_data_sem in exclusive mode when adding a new delalloc extent in
ext4_da_map_blocks().

	Cc: stable@vger.kernel.org
	Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
	Suggested-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Jan Kara <jack@suse.cz>
Link: https://lore.kernel.org/r/20240127015825.1608160-3-yi.zhang@huaweicloud.com
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit acf795dc161f3cf481db20f05db4250714e375e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 49ebe49ee7e4,b040337501e3..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -1878,12 -1702,9 +1878,16 @@@ static int ext4_da_map_blocks(struct in
  		  (unsigned long) map->m_lblk);
  
  	/* Lookup extent status tree firstly */
++<<<<<<< HEAD
 +	if (ext4_es_lookup_extent(inode, iblock, &es)) {
 +		if (ext4_es_is_hole(&es)) {
 +			retval = 0;
 +			down_read(&EXT4_I(inode)->i_data_sem);
++=======
+ 	if (ext4_es_lookup_extent(inode, iblock, NULL, &es)) {
+ 		if (ext4_es_is_hole(&es))
++>>>>>>> acf795dc161f (ext4: convert to exclusive lock while inserting delalloc extents)
  			goto add_delayed;
- 		}
  
  		/*
  		 * Delayed extent could be allocated by fallocate.
@@@ -1925,27 -1746,11 +1929,35 @@@
  		retval = ext4_ext_map_blocks(NULL, inode, map, 0);
  	else
  		retval = ext4_ind_map_blocks(NULL, inode, map, 0);
++<<<<<<< HEAD
 +
 +add_delayed:
 +	if (retval == 0) {
 +		int ret;
 +
 +		/*
 +		 * XXX: __block_prepare_write() unmaps passed block,
 +		 * is it OK?
 +		 */
 +
 +		ret = ext4_insert_delayed_block(inode, map->m_lblk);
 +		if (ret != 0) {
 +			retval = ret;
 +			goto out_unlock;
 +		}
 +
 +		map_bh(bh, inode->i_sb, invalid_block);
 +		set_buffer_new(bh);
 +		set_buffer_delay(bh);
 +	} else if (retval > 0) {
 +		int ret;
++=======
+ 	if (retval < 0) {
+ 		up_read(&EXT4_I(inode)->i_data_sem);
+ 		return retval;
+ 	}
+ 	if (retval > 0) {
++>>>>>>> acf795dc161f (ext4: convert to exclusive lock while inserting delalloc extents)
  		unsigned int status;
  
  		if (unlikely(retval != map->m_len)) {
@@@ -1958,15 -1763,23 +1970,36 @@@
  
  		status = map->m_flags & EXT4_MAP_UNWRITTEN ?
  				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
++<<<<<<< HEAD
 +		ret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,
 +					    map->m_pblk, status);
 +		if (ret != 0)
 +			retval = ret;
++=======
+ 		ext4_es_insert_extent(inode, map->m_lblk, map->m_len,
+ 				      map->m_pblk, status);
+ 		up_read(&EXT4_I(inode)->i_data_sem);
+ 		return retval;
++>>>>>>> acf795dc161f (ext4: convert to exclusive lock while inserting delalloc extents)
  	}
+ 	up_read(&EXT4_I(inode)->i_data_sem);
  
++<<<<<<< HEAD
 +out_unlock:
 +	up_read((&EXT4_I(inode)->i_data_sem));
 +
++=======
+ add_delayed:
+ 	down_write(&EXT4_I(inode)->i_data_sem);
+ 	retval = ext4_insert_delayed_block(inode, map->m_lblk);
+ 	up_write(&EXT4_I(inode)->i_data_sem);
+ 	if (retval)
+ 		return retval;
+ 
+ 	map_bh(bh, inode->i_sb, invalid_block);
+ 	set_buffer_new(bh);
+ 	set_buffer_delay(bh);
++>>>>>>> acf795dc161f (ext4: convert to exclusive lock while inserting delalloc extents)
  	return retval;
  }
  
* Unmerged path fs/ext4/inode.c
