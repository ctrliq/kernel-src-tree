cifs: update ip_addr for ses only for primary chan setup

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit e77978de4765229e09c8fabcf4f8419ff367317f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/e77978de.failed

We update ses->ip_addr whenever we do a session setup.
But this should happen only for primary channel in mchan
scenario.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit e77978de4765229e09c8fabcf4f8419ff367317f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 6d6e98007d5e,61872db5d775..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3978,12 -3708,43 +3978,44 @@@ cifs_setup_session(const unsigned int x
  		   struct nls_table *nls_info)
  {
  	int rc = -ENOSYS;
++<<<<<<< HEAD
 +	bool is_binding = false;
 +
++=======
+ 	struct TCP_Server_Info *pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
+ 	struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&pserver->dstaddr;
+ 	struct sockaddr_in *addr = (struct sockaddr_in *)&pserver->dstaddr;
+ 	bool is_binding = false;
+ 
+ 	spin_lock(&ses->ses_lock);
+ 	if (ses->ses_status != SES_GOOD &&
+ 	    ses->ses_status != SES_NEW &&
+ 	    ses->ses_status != SES_NEED_RECON) {
+ 		spin_unlock(&ses->ses_lock);
+ 		return 0;
+ 	}
+ 
+ 	/* only send once per connect */
++>>>>>>> e77978de4765 (cifs: update ip_addr for ses only for primary chan setup)
  	spin_lock(&ses->chan_lock);
 -	if (CIFS_ALL_CHANS_GOOD(ses) ||
 -	    cifs_chan_in_reconnect(ses, server)) {
 -		spin_unlock(&ses->chan_lock);
 -		spin_unlock(&ses->ses_lock);
 -		return 0;
 -	}
  	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
 -	cifs_chan_set_in_reconnect(ses, server);
  	spin_unlock(&ses->chan_lock);
  
++<<<<<<< HEAD
++=======
+ 	if (!is_binding)
+ 		ses->ses_status = SES_IN_SETUP;
+ 	spin_unlock(&ses->ses_lock);
+ 
+ 	/* update ses ip_addr only for primary chan */
+ 	if (server == pserver) {
+ 		if (server->dstaddr.ss_family == AF_INET6)
+ 			scnprintf(ses->ip_addr, sizeof(ses->ip_addr), "%pI6", &addr6->sin6_addr);
+ 		else
+ 			scnprintf(ses->ip_addr, sizeof(ses->ip_addr), "%pI4", &addr->sin_addr);
+ 	}
+ 
++>>>>>>> e77978de4765 (cifs: update ip_addr for ses only for primary chan setup)
  	if (!is_binding) {
  		ses->capabilities = server->capabilities;
  		if (!linuxExtEnabled)
* Unmerged path fs/cifs/connect.c
