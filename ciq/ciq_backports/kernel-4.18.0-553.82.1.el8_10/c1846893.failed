cifs: update dstaddr whenever channel iface is updated

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit c1846893991f3b4ec8a0cc12219ada153f0814d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/c1846893.failed

When the server interface info changes (more common in clustered
servers like Azure Files), the per-channel iface gets updated.
However, this did not update the corresponding dstaddr. As a result
these channels will still connect (or try connecting) to older addresses.

Fixes: b54034a73baf ("cifs: during reconnect, update interface if necessary")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit c1846893991f3b4ec8a0cc12219ada153f0814d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/sess.c
diff --cc fs/cifs/sess.c
index f27026148ee7,ec0db32c7d98..000000000000
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@@ -274,45 -419,36 +274,52 @@@ cifs_chan_update_iface(struct cifs_ses 
  		cifs_dbg(FYI, "replacing iface: %pIS with %pIS\n",
  			 &old_iface->sockaddr,
  			 &iface->sockaddr);
 -
 -		old_iface->num_channels--;
 -		if (old_iface->weight_fulfilled)
 -			old_iface->weight_fulfilled--;
 -		iface->num_channels++;
 -		iface->weight_fulfilled++;
 -
  		kref_put(&old_iface->refcount, release_iface);
 -	} else if (!chan_index) {
 -		/* special case: update interface for primary channel */
 -		cifs_dbg(FYI, "referencing primary channel iface: %pIS\n",
 -			 &iface->sockaddr);
 -		iface->num_channels++;
 -		iface->weight_fulfilled++;
 +	} else if (old_iface) {
 +		cifs_dbg(FYI, "releasing ref to iface: %pIS\n",
 +			 &old_iface->sockaddr);
 +		kref_put(&old_iface->refcount, release_iface);
 +	} else {
 +		WARN_ON(!iface);
 +		cifs_dbg(FYI, "adding new iface: %pIS\n", &iface->sockaddr);
  	}
 +
  	spin_unlock(&ses->iface_lock);
  
 -	spin_lock(&ses->chan_lock);
 -	chan_index = cifs_ses_get_chan_index(ses, server);
 -	if (chan_index == CIFS_INVAL_CHAN_INDEX) {
 -		spin_unlock(&ses->chan_lock);
 -		return;
 +	/* No iface is found. if secondary chan, drop connection */
 +	if (!iface && CIFS_SERVER_IS_CHAN(server)) {
 +		cifs_put_tcp_session(server, false);
 +		ses->chans[chan_index].server = NULL;
  	}
  
 -	ses->chans[chan_index].iface = iface;
 +	return rc;
 +}
 +
 +/*
 + * If server is a channel of ses, return the corresponding enclosing
 + * cifs_chan otherwise return NULL.
 + */
 +struct cifs_chan *
 +cifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server)
 +{
 +	int i;
 +
 +	spin_lock(&ses->chan_lock);
 +	for (i = 0; i < ses->chan_count; i++) {
 +		if (ses->chans[i].server == server) {
 +			spin_unlock(&ses->chan_lock);
 +			return &ses->chans[i];
 +		}
 +	}
  	spin_unlock(&ses->chan_lock);
++<<<<<<< HEAD:fs/cifs/sess.c
 +	return NULL;
++=======
+ 
+ 	spin_lock(&server->srv_lock);
+ 	memcpy(&server->dstaddr, &iface->sockaddr, sizeof(server->dstaddr));
+ 	spin_unlock(&server->srv_lock);
++>>>>>>> c1846893991f (cifs: update dstaddr whenever channel iface is updated):fs/smb/client/sess.c
  }
  
  static int
* Unmerged path fs/cifs/sess.c
