cifs: cifs_ses_mark_for_reconnect should also update reconnect bits

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit ba978e83255a759a4a07257a46ca6396a8b81787
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/ba978e83.failed

Recent restructuring of cifs_reconnect introduced a helper func
named cifs_ses_mark_for_reconnect, which updates the state of tcp
session for all the channels of a session for reconnect.

However, this does not update the session state and chans_need_reconnect
bitmask. This change fixes that.

Also, cifs_mark_tcp_sess_for_reconnect should mark set the bitmask
for all channels when the whole session is marked for reconnect.
Fixed that here too.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit ba978e83255a759a4a07257a46ca6396a8b81787)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifs_swn.c
#	fs/cifs/cifsproto.h
#	fs/cifs/connect.c
#	fs/cifs/netmisc.c
#	fs/cifs/sess.c
diff --cc fs/cifs/cifs_swn.c
index bcbaf4e25f94,463ebe34892b..000000000000
--- a/fs/cifs/cifs_swn.c
+++ b/fs/cifs/cifs_swn.c
@@@ -500,10 -498,7 +500,14 @@@ static int cifs_swn_reconnect(struct ci
  		goto unlock;
  	}
  
++<<<<<<< HEAD
 +	spin_lock(&GlobalMid_Lock);
 +	if (tcon->ses->server->tcpStatus != CifsExiting)
 +		tcon->ses->server->tcpStatus = CifsNeedReconnect;
 +	spin_unlock(&GlobalMid_Lock);
++=======
+ 	cifs_reconnect(tcon->ses->server, false);
++>>>>>>> ba978e83255a (cifs: cifs_ses_mark_for_reconnect should also update reconnect bits)
  
  unlock:
  	mutex_unlock(&tcon->ses->server->srv_mutex);
diff --cc fs/cifs/cifsproto.h
index 081ad010ce30,d3701295402d..000000000000
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@@ -130,7 -131,11 +130,15 @@@ extern int SendReceiveBlockingLock(cons
  			struct smb_hdr *in_buf ,
  			struct smb_hdr *out_buf,
  			int *bytes_returned);
++<<<<<<< HEAD
 +extern int cifs_reconnect(struct TCP_Server_Info *server);
++=======
+ void
+ cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,
+ 				      bool mark_smb_session);
+ extern int cifs_reconnect(struct TCP_Server_Info *server,
+ 			  bool mark_smb_session);
++>>>>>>> ba978e83255a (cifs: cifs_ses_mark_for_reconnect should also update reconnect bits)
  extern int checkSMB(char *buf, unsigned int len, struct TCP_Server_Info *srvr);
  extern bool is_valid_oplock_break(char *, struct TCP_Server_Info *);
  extern bool backup_cred(struct cifs_sb_info *);
diff --cc fs/cifs/connect.c
index 9047b33cdff7,453aba3c2ad6..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -169,10 -166,13 +169,16 @@@ static void cifs_resolve_server(struct 
   * Mark all sessions and tcons for reconnect.
   *
   * @server needs to be previously set to CifsNeedReconnect.
 - *
   */
++<<<<<<< HEAD
 +static void cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server)
++=======
+ void
+ cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,
+ 				      bool mark_smb_session)
++>>>>>>> ba978e83255a (cifs: cifs_ses_mark_for_reconnect should also update reconnect bits)
  {
 -	struct TCP_Server_Info *pserver;
 +	unsigned int num_sessions = 0;
  	struct cifs_ses *ses;
  	struct cifs_tcon *tcon;
  	struct mid_q_entry *mid, *nmid;
@@@ -196,19 -193,25 +202,22 @@@
  	spin_lock(&cifs_tcp_ses_lock);
  	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
  		spin_lock(&ses->chan_lock);
 -		if (!mark_smb_session && cifs_chan_needs_reconnect(ses, server))
 +		if (cifs_chan_needs_reconnect(ses, server))
  			goto next_session;
  
- 		cifs_chan_set_need_reconnect(ses, server);
+ 		if (mark_smb_session)
+ 			CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);
+ 		else
+ 			cifs_chan_set_need_reconnect(ses, server);
  
  		/* If all channels need reconnect, then tcon needs reconnect */
 -		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
  			goto next_session;
  
 -		ses->status = CifsNeedReconnect;
 +		num_sessions++;
  
 -		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 +		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
 -			tcon->tidStatus = CifsNeedReconnect;
 -		}
  		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
  
@@@ -4309,6 -4376,32 +4318,35 @@@ static int tree_connect_dfs_target(cons
  out:
  	kfree(share);
  	kfree(prefix);
++<<<<<<< HEAD
++=======
+ 
+ 	return rc;
+ }
+ 
+ static int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,
+ 				   struct cifs_sb_info *cifs_sb, char *tree, bool islink,
+ 				   struct dfs_cache_tgt_list *tl)
+ {
+ 	int rc;
+ 	int num_links = 0;
+ 	struct TCP_Server_Info *server = tcon->ses->server;
+ 
+ 	do {
+ 		rc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, islink, tl);
+ 		if (!rc || rc != -EREMOTE)
+ 			break;
+ 	} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);
+ 	/*
+ 	 * If we couldn't tree connect to any targets from last referral path, then retry from
+ 	 * original referral path.
+ 	 */
+ 	if (rc && server->current_fullpath != server->origin_fullpath) {
+ 		server->current_fullpath = server->origin_fullpath;
+ 		cifs_reconnect(tcon->ses->server, true);
+ 	}
+ 
++>>>>>>> ba978e83255a (cifs: cifs_ses_mark_for_reconnect should also update reconnect bits)
  	dfs_cache_free_tgts(tl);
  	return rc;
  }
diff --cc fs/cifs/netmisc.c
index 33052a01b20e,ebe236b9d9f5..000000000000
--- a/fs/cifs/netmisc.c
+++ b/fs/cifs/netmisc.c
@@@ -909,10 -896,7 +909,14 @@@ map_and_check_smb_error(struct mid_q_en
  		if (class == ERRSRV && code == ERRbaduid) {
  			cifs_dbg(FYI, "Server returned 0x%x, reconnecting session...\n",
  				code);
++<<<<<<< HEAD
 +			spin_lock(&GlobalMid_Lock);
 +			if (mid->server->tcpStatus != CifsExiting)
 +				mid->server->tcpStatus = CifsNeedReconnect;
 +			spin_unlock(&GlobalMid_Lock);
++=======
+ 			cifs_reconnect(mid->server, false);
++>>>>>>> ba978e83255a (cifs: cifs_ses_mark_for_reconnect should also update reconnect bits)
  		}
  	}
  
diff --cc fs/cifs/sess.c
index 1b56022e96fb,15373a377a36..000000000000
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@@ -367,19 -366,6 +367,22 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +/* Mark all session channels for reconnect */
 +void cifs_ses_mark_for_reconnect(struct cifs_ses *ses)
 +{
 +	int i;
 +
 +	for (i = 0; i < ses->chan_count; i++) {
 +		spin_lock(&GlobalMid_Lock);
 +		if (ses->chans[i].server->tcpStatus != CifsExiting)
 +			ses->chans[i].server->tcpStatus = CifsNeedReconnect;
 +		spin_unlock(&GlobalMid_Lock);
 +	}
 +}
 +
++=======
++>>>>>>> ba978e83255a (cifs: cifs_ses_mark_for_reconnect should also update reconnect bits)
  static __u32 cifs_ssetup_hdr(struct cifs_ses *ses,
  			     struct TCP_Server_Info *server,
  			     SESSION_SETUP_ANDX *pSMB)
* Unmerged path fs/cifs/cifs_swn.c
* Unmerged path fs/cifs/cifsproto.h
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/dfs_cache.c b/fs/cifs/dfs_cache.c
index 17718cdb89bc..311f00348d90 100644
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@ -1383,7 +1383,7 @@ static void mark_for_reconnect_if_needed(struct cifs_tcon *tcon, struct dfs_cach
 	}
 
 	cifs_dbg(FYI, "%s: no cached or matched targets. mark dfs share for reconnect.\n", __func__);
-	cifs_ses_mark_for_reconnect(tcon->ses);
+	cifs_reconnect(tcon->ses->server, true);
 }
 
 /* Refresh dfs referral of tcon and mark it for reconnect if needed */
* Unmerged path fs/cifs/netmisc.c
* Unmerged path fs/cifs/sess.c
