cifs: avoid race conditions with parallel reconnects

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit bc962159e8e326af634a506508034a375bf2b858
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/bc962159.failed

When multiple processes/channels do reconnects in parallel
we used to return success immediately
negotiate/session-setup/tree-connect, causing race conditions
between processes that enter the function in parallel.
This caused several errors related to session not found to
show up during parallel reconnects.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit bc962159e8e326af634a506508034a375bf2b858)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/smb2pdu.c
#	fs/cifs/smb2transport.c
diff --cc fs/cifs/connect.c
index 86456687828e,c3162ef9c9e9..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -219,38 -212,58 +219,74 @@@ static void cifs_mark_tcp_ses_conns_for
  			cifs_chan_update_iface(ses, server);
  
  		spin_lock(&ses->chan_lock);
++<<<<<<< HEAD
 +		if (cifs_chan_needs_reconnect(ses, server))
 +			goto next_session;
++=======
+ 		if (!mark_smb_session && cifs_chan_needs_reconnect(ses, server)) {
+ 			spin_unlock(&ses->chan_lock);
+ 			continue;
+ 		}
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  
 -		if (mark_smb_session)
 -			CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);
 -		else
 -			cifs_chan_set_need_reconnect(ses, server);
 +		cifs_chan_set_need_reconnect(ses, server);
  
++<<<<<<< HEAD
 +		/* If all channels need reconnect, then tcon needs reconnect */
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +			goto next_session;
 +
 +		num_sessions++;
++=======
+ 		cifs_dbg(FYI, "%s: channel connect bitmap: 0x%lx\n",
+ 			 __func__, ses->chans_need_reconnect);
+ 
+ 		/* If all channels need reconnect, then tcon needs reconnect */
+ 		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {
+ 			spin_unlock(&ses->chan_lock);
+ 			continue;
+ 		}
+ 		spin_unlock(&ses->chan_lock);
+ 
+ 		spin_lock(&ses->ses_lock);
+ 		ses->ses_status = SES_NEED_RECON;
+ 		spin_unlock(&ses->ses_lock);
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  
 -		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 +		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
++<<<<<<< HEAD
 +		if (ses->tcon_ipc)
 +			ses->tcon_ipc->need_reconnect = true;
 +
 +next_session:
 +		spin_unlock(&ses->chan_lock);
++=======
+ 			spin_lock(&tcon->tc_lock);
+ 			tcon->status = TID_NEED_RECON;
+ 			spin_unlock(&tcon->tc_lock);
+ 		}
+ 		if (ses->tcon_ipc) {
+ 			ses->tcon_ipc->need_reconnect = true;
+ 			spin_lock(&ses->tcon_ipc->tc_lock);
+ 			ses->tcon_ipc->status = TID_NEED_RECON;
+ 			spin_unlock(&ses->tcon_ipc->tc_lock);
+ 		}
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  	}
  	spin_unlock(&cifs_tcp_ses_lock);
 -}
 -
 -static void
 -cifs_abort_connection(struct TCP_Server_Info *server)
 -{
 -	struct mid_q_entry *mid, *nmid;
 -	struct list_head retry_list;
 -
 -	server->maxBuf = 0;
 -	server->max_read = 0;
  
 +	if (num_sessions == 0)
 +		return;
 +	/*
 +	 * before reconnecting the tcp session, mark the smb session (uid)
 +	 * and the tid bad so they are not used until reconnected
 +	 */
 +	cifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n",
 +		 __func__);
  	/* do not want to be sending data on a socket we are freeing */
  	cifs_dbg(FYI, "%s: tearing down socket\n", __func__);
 -	cifs_server_lock(server);
 +	mutex_lock(&server->srv_mutex);
  	if (server->ssocket) {
  		cifs_dbg(FYI, "State: 0x%x Flags: 0x%lx\n", server->ssocket->state,
  			 server->ssocket->flags);
@@@ -3933,8 -3663,22 +3969,27 @@@ cifs_negotiate_protocol(const unsigned 
  		return -ENOSYS;
  
  	/* only send once per connect */
++<<<<<<< HEAD
 +	if (!server->ops->need_neg(server))
 +		return 0;
++=======
+ 	spin_lock(&server->srv_lock);
+ 	if (server->tcpStatus != CifsGood &&
+ 	    server->tcpStatus != CifsNew &&
+ 	    server->tcpStatus != CifsNeedNegotiate) {
+ 		spin_unlock(&server->srv_lock);
+ 		return -EHOSTDOWN;
+ 	}
+ 
+ 	if (!server->ops->need_neg(server) &&
+ 	    server->tcpStatus == CifsGood) {
+ 		spin_unlock(&server->srv_lock);
+ 		return 0;
+ 	}
+ 
+ 	server->tcpStatus = CifsInNegotiate;
+ 	spin_unlock(&server->srv_lock);
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  
  	rc = server->ops->negotiate(xid, ses, server);
  	if (rc == 0) {
@@@ -3955,9 -3704,33 +4010,34 @@@ cifs_setup_session(const unsigned int x
  		   struct nls_table *nls_info)
  {
  	int rc = -ENOSYS;
 -	struct TCP_Server_Info *pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
 -	struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&pserver->dstaddr;
 -	struct sockaddr_in *addr = (struct sockaddr_in *)&pserver->dstaddr;
  	bool is_binding = false;
  
++<<<<<<< HEAD
++	spin_lock(&ses->chan_lock);
++=======
+ 	spin_lock(&ses->ses_lock);
+ 	cifs_dbg(FYI, "%s: channel connect bitmap: 0x%lx\n",
+ 		 __func__, ses->chans_need_reconnect);
+ 
+ 	if (ses->ses_status != SES_GOOD &&
+ 	    ses->ses_status != SES_NEW &&
+ 	    ses->ses_status != SES_NEED_RECON) {
+ 		spin_unlock(&ses->ses_lock);
+ 		return -EHOSTDOWN;
+ 	}
+ 
+ 	/* only send once per connect */
  	spin_lock(&ses->chan_lock);
+ 	if (CIFS_ALL_CHANS_GOOD(ses)) {
+ 		if (ses->ses_status == SES_NEED_RECON)
+ 			ses->ses_status = SES_GOOD;
+ 		spin_unlock(&ses->chan_lock);
+ 		spin_unlock(&ses->ses_lock);
+ 		return 0;
+ 	}
+ 
+ 	cifs_chan_set_in_reconnect(ses, server);
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
  	spin_unlock(&ses->chan_lock);
  
diff --cc fs/cifs/smb2pdu.c
index b72fbca5ee79,a9fb95b7ef82..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -201,36 -197,18 +201,47 @@@ smb2_reconnect(__le16 smb2_command, str
  		case SMB2_CANCEL:
  		case SMB2_CLOSE:
  		case SMB2_OPLOCK_BREAK:
 -			spin_unlock(&server->srv_lock);
  			return -EAGAIN;
  		}
 +
 +		rc = wait_event_interruptible_timeout(server->response_q,
 +						      (server->tcpStatus != CifsNeedReconnect),
 +						      10 * HZ);
 +		if (rc < 0) {
 +			cifs_dbg(FYI, "%s: aborting reconnect due to a received signal by the process\n",
 +				 __func__);
 +			return -ERESTARTSYS;
 +		}
 +
 +		/* are we still trying to reconnect? */
 +		if (server->tcpStatus != CifsNeedReconnect)
 +			break;
 +
 +		if (retries && --retries)
 +			continue;
 +
 +		/*
 +		 * on "soft" mounts we wait once. Hard mounts keep
 +		 * retrying until process is killed or server comes
 +		 * back on-line
 +		 */
 +		if (!tcon->retry) {
 +			cifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");
 +			return -EHOSTDOWN;
 +		}
 +		retries = server->nr_targets;
  	}
++<<<<<<< HEAD
++=======
+ 	spin_unlock(&server->srv_lock);
+ 
+ again:
+ 	rc = cifs_wait_for_server_reconnect(server, tcon->retry);
+ 	if (rc)
+ 		return rc;
+ 
+ 	ses = tcon->ses;
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  
  	spin_lock(&ses->chan_lock);
  	if (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {
@@@ -244,22 -222,24 +255,32 @@@
  
  	nls_codepage = load_nls_default();
  
+ 	mutex_lock(&ses->session_mutex);
 +	/*
 +	 * need to prevent multiple threads trying to simultaneously reconnect
 +	 * the same SMB session
 +	 */
 +	mutex_lock(&ses->session_mutex);
 +
  	/*
  	 * Recheck after acquire mutex. If another thread is negotiating
  	 * and the server never sends an answer the socket will be closed
  	 * and tcpStatus set to reconnect.
  	 */
 -	spin_lock(&server->srv_lock);
  	if (server->tcpStatus == CifsNeedReconnect) {
++<<<<<<< HEAD
++=======
+ 		spin_unlock(&server->srv_lock);
+ 		mutex_unlock(&ses->session_mutex);
+ 
+ 		if (tcon->retry)
+ 			goto again;
+ 
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  		rc = -EHOSTDOWN;
 +		mutex_unlock(&ses->session_mutex);
  		goto out;
  	}
 -	spin_unlock(&server->srv_lock);
  
  	/*
  	 * need to prevent multiple threads trying to simultaneously
@@@ -273,7 -255,6 +296,10 @@@
  		if (tcon->need_reconnect)
  			goto skip_sess_setup;
  
++<<<<<<< HEAD
 +		rc = -EHOSTDOWN;
++=======
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  		mutex_unlock(&ses->session_mutex);
  		goto out;
  	}
@@@ -298,6 -278,10 +325,13 @@@
  	}
  
  skip_sess_setup:
++<<<<<<< HEAD
++=======
+ 	if (!tcon->need_reconnect) {
+ 		mutex_unlock(&ses->session_mutex);
+ 		goto out;
+ 	}
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  	cifs_mark_open_files_invalid(tcon);
  	if (tcon->use_persistent)
  		tcon->need_reopen_files = true;
diff --cc fs/cifs/smb2transport.c
index 5eda4666cf82,790acf65a092..000000000000
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@@ -81,10 -77,11 +81,11 @@@ stati
  int smb2_get_sign_key(__u64 ses_id, struct TCP_Server_Info *server, u8 *key)
  {
  	struct cifs_chan *chan;
 -	struct TCP_Server_Info *pserver;
  	struct cifs_ses *ses = NULL;
 +	struct TCP_Server_Info *it = NULL;
  	int i;
  	int rc = 0;
+ 	bool is_binding = false;
  
  	spin_lock(&cifs_tcp_ses_lock);
  
@@@ -100,14 -98,20 +101,28 @@@
  	goto out;
  
  found:
++<<<<<<< HEAD
 +	if (cifs_chan_needs_reconnect(ses, server) &&
 +	    !CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {
++=======
+ 	spin_lock(&ses->ses_lock);
+ 	spin_lock(&ses->chan_lock);
+ 
+ 	is_binding = (cifs_chan_needs_reconnect(ses, server) &&
+ 		      ses->ses_status == SES_GOOD);
+ 	if (is_binding) {
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  		/*
  		 * If we are in the process of binding a new channel
  		 * to an existing session, use the master connection
  		 * session key
  		 */
  		memcpy(key, ses->smb3signingkey, SMB3_SIGN_KEY_SIZE);
++<<<<<<< HEAD
++=======
+ 		spin_unlock(&ses->chan_lock);
+ 		spin_unlock(&ses->ses_lock);
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  		goto out;
  	}
  
@@@ -119,9 -123,13 +134,19 @@@
  		chan = ses->chans + i;
  		if (chan->server == server) {
  			memcpy(key, chan->signkey, SMB3_SIGN_KEY_SIZE);
++<<<<<<< HEAD
 +			goto out;
 +		}
 +	}
++=======
+ 			spin_unlock(&ses->chan_lock);
+ 			spin_unlock(&ses->ses_lock);
+ 			goto out;
+ 		}
+ 	}
+ 	spin_unlock(&ses->chan_lock);
+ 	spin_unlock(&ses->ses_lock);
++>>>>>>> bc962159e8e3 (cifs: avoid race conditions with parallel reconnects)
  
  	cifs_dbg(VFS,
  		 "%s: Could not find channel signing key for session 0x%llx\n",
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/smb2pdu.c
* Unmerged path fs/cifs/smb2transport.c
