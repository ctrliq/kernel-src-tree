cifs: cifs_chan_is_iface_active should be called with chan_lock held

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 7257bcf3bdc785eabc4eef1f329a59815b032508
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/7257bcf3.failed

cifs_chan_is_iface_active checks the channels of a session to see
if the associated iface is active. This should always happen
with chan_lock held. However, these two callers of this function
were missing this locking.

This change makes sure the function calls are protected with
proper locking.

Fixes: b54034a73baf ("cifs: during reconnect, update interface if necessary")
Fixes: fa1d0508bdd4 ("cifs: account for primary channel in the interface list")
	Cc: stable@vger.kernel.org
	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 7257bcf3bdc785eabc4eef1f329a59815b032508)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/connect.c
index ca2926c7b59e,dc9b95ca71e6..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -207,50 -211,88 +207,60 @@@ static void cifs_mark_tcp_ses_conns_for
  	 * before reconnecting the tcp session, mark the smb session (uid) and the tid bad so they
  	 * are not used until reconnected.
  	 */
 -	cifs_dbg(FYI, "%s: marking necessary sessions and tcons for reconnect\n", __func__);
 +	cifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n", __func__);
  
  	/* If server is a channel, select the primary channel */
 -	pserver = SERVER_IS_CHAN(server) ? server->primary_server : server;
 -
 -	/*
 -	 * if the server has been marked for termination, there is a
 -	 * chance that the remaining channels all need reconnect. To be
 -	 * on the safer side, mark the session and trees for reconnect
 -	 * for this scenario. This might cause a few redundant session
 -	 * setup and tree connect requests, but it is better than not doing
 -	 * a tree connect when needed, and all following requests failing
 -	 */
 -	if (server->terminate) {
 -		mark_smb_session = true;
 -		server = pserver;
 -	}
 +	pserver = CIFS_SERVER_IS_CHAN(server) ? server->primary_server : server;
  
  	spin_lock(&cifs_tcp_ses_lock);
 -	list_for_each_entry_safe(ses, nses, &pserver->smb_ses_list, smb_ses_list) {
 +	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
  		/* check if iface is still active */
- 		if (!cifs_chan_is_iface_active(ses, server))
- 			cifs_chan_update_iface(ses, server);
- 
  		spin_lock(&ses->chan_lock);
++<<<<<<< HEAD:fs/cifs/connect.c
 +		if (cifs_chan_needs_reconnect(ses, server))
 +			goto next_session;
++=======
+ 		if (!cifs_chan_is_iface_active(ses, server)) {
+ 			spin_unlock(&ses->chan_lock);
+ 			cifs_chan_update_iface(ses, server);
+ 			spin_lock(&ses->chan_lock);
+ 		}
+ 
+ 		if (!mark_smb_session && cifs_chan_needs_reconnect(ses, server)) {
+ 			spin_unlock(&ses->chan_lock);
+ 			continue;
+ 		}
++>>>>>>> 7257bcf3bdc7 (cifs: cifs_chan_is_iface_active should be called with chan_lock held):fs/smb/client/connect.c
  
 -		if (mark_smb_session)
 -			CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);
 -		else
 -			cifs_chan_set_need_reconnect(ses, server);
 -
 -		cifs_dbg(FYI, "%s: channel connect bitmap: 0x%lx\n",
 -			 __func__, ses->chans_need_reconnect);
 +		cifs_chan_set_need_reconnect(ses, server);
  
  		/* If all channels need reconnect, then tcon needs reconnect */
 -		if (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {
 -			spin_unlock(&ses->chan_lock);
 -			continue;
 -		}
 -		spin_unlock(&ses->chan_lock);
 +		if (!CIFS_ALL_CHANS_NEED_RECONNECT(ses))
 +			goto next_session;
  
 -		spin_lock(&ses->ses_lock);
 -		ses->ses_status = SES_NEED_RECON;
 -		spin_unlock(&ses->ses_lock);
 +		num_sessions++;
  
 -		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 +		list_for_each_entry(tcon, &ses->tcon_list, tcon_list)
  			tcon->need_reconnect = true;
 -			spin_lock(&tcon->tc_lock);
 -			tcon->status = TID_NEED_RECON;
 -			spin_unlock(&tcon->tc_lock);
 -
 -			cancel_delayed_work(&tcon->query_interfaces);
 -		}
 -		if (ses->tcon_ipc) {
 +		if (ses->tcon_ipc)
  			ses->tcon_ipc->need_reconnect = true;
 -			spin_lock(&ses->tcon_ipc->tc_lock);
 -			ses->tcon_ipc->status = TID_NEED_RECON;
 -			spin_unlock(&ses->tcon_ipc->tc_lock);
 -		}
 +
 +next_session:
 +		spin_unlock(&ses->chan_lock);
  	}
  	spin_unlock(&cifs_tcp_ses_lock);
 -}
 -
 -static void
 -cifs_abort_connection(struct TCP_Server_Info *server)
 -{
 -	struct mid_q_entry *mid, *nmid;
 -	struct list_head retry_list;
 -
 -	server->maxBuf = 0;
 -	server->max_read = 0;
  
 +	if (num_sessions == 0)
 +		return;
 +	/*
 +	 * before reconnecting the tcp session, mark the smb session (uid)
 +	 * and the tid bad so they are not used until reconnected
 +	 */
 +	cifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n",
 +		 __func__);
  	/* do not want to be sending data on a socket we are freeing */
  	cifs_dbg(FYI, "%s: tearing down socket\n", __func__);
 -	cifs_server_lock(server);
 +	mutex_lock(&server->srv_mutex);
  	if (server->ssocket) {
  		cifs_dbg(FYI, "State: 0x%x Flags: 0x%lx\n", server->ssocket->state,
  			 server->ssocket->flags);
diff --cc fs/cifs/smb2ops.c
index 06fe88efbf89,c8722e82274f..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -727,6 -783,16 +727,19 @@@ SMB3_request_interfaces(const unsigned 
  	if (rc)
  		goto out;
  
++<<<<<<< HEAD:fs/cifs/smb2ops.c
++=======
+ 	/* check if iface is still active */
+ 	spin_lock(&ses->chan_lock);
+ 	pserver = ses->chans[0].server;
+ 	if (pserver && !cifs_chan_is_iface_active(ses, pserver)) {
+ 		spin_unlock(&ses->chan_lock);
+ 		cifs_chan_update_iface(ses, pserver);
+ 		spin_lock(&ses->chan_lock);
+ 	}
+ 	spin_unlock(&ses->chan_lock);
+ 
++>>>>>>> 7257bcf3bdc7 (cifs: cifs_chan_is_iface_active should be called with chan_lock held):fs/smb/client/smb2ops.c
  out:
  	kfree(out_buf);
  	return rc;
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/smb2ops.c
