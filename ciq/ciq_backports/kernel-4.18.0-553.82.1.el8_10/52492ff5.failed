cifs: call helper functions for marking channels for reconnect

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 52492ff5c583036306bc422a83e246c971af387a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/52492ff5.failed

cifs_mark_tcp_ses_conns_for_reconnect helper function is now
meant to be used by any of the threads to mark a channel
(or all the channels) for reconnect.

Replace all such manual changes to tcpStatus to use this
helper function, which takes care that the right channels,
smb sessions and tcons are marked for reconnect.

Also includes one line minor change
	Reported-by: kernel test robot <lkp@intel.com>

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 52492ff5c583036306bc422a83e246c971af387a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifs_swn.c
#	fs/cifs/dfs_cache.c
#	fs/cifs/smb1ops.c
#	fs/cifs/transport.c
diff --cc fs/cifs/cifs_swn.c
index bcbaf4e25f94,cdce1609c5c2..000000000000
--- a/fs/cifs/cifs_swn.c
+++ b/fs/cifs/cifs_swn.c
@@@ -398,11 -396,11 +398,19 @@@ static int cifs_swn_resource_state_chan
  	switch (state) {
  	case CIFS_SWN_RESOURCE_STATE_UNAVAILABLE:
  		cifs_dbg(FYI, "%s: resource name '%s' become unavailable\n", __func__, name);
++<<<<<<< HEAD
 +		cifs_ses_mark_for_reconnect(swnreg->tcon->ses);
 +		break;
 +	case CIFS_SWN_RESOURCE_STATE_AVAILABLE:
 +		cifs_dbg(FYI, "%s: resource name '%s' become available\n", __func__, name);
 +		cifs_ses_mark_for_reconnect(swnreg->tcon->ses);
++=======
+ 		cifs_mark_tcp_ses_conns_for_reconnect(swnreg->tcon->ses->server, true);
+ 		break;
+ 	case CIFS_SWN_RESOURCE_STATE_AVAILABLE:
+ 		cifs_dbg(FYI, "%s: resource name '%s' become available\n", __func__, name);
+ 		cifs_mark_tcp_ses_conns_for_reconnect(swnreg->tcon->ses->server, true);
++>>>>>>> 52492ff5c583 (cifs: call helper functions for marking channels for reconnect)
  		break;
  	case CIFS_SWN_RESOURCE_STATE_UNKNOWN:
  		cifs_dbg(FYI, "%s: resource name '%s' changed to unknown state\n", __func__, name);
@@@ -500,10 -498,7 +508,14 @@@ static int cifs_swn_reconnect(struct ci
  		goto unlock;
  	}
  
++<<<<<<< HEAD
 +	spin_lock(&GlobalMid_Lock);
 +	if (tcon->ses->server->tcpStatus != CifsExiting)
 +		tcon->ses->server->tcpStatus = CifsNeedReconnect;
 +	spin_unlock(&GlobalMid_Lock);
++=======
+ 	cifs_mark_tcp_ses_conns_for_reconnect(tcon->ses->server, false);
++>>>>>>> 52492ff5c583 (cifs: call helper functions for marking channels for reconnect)
  
  unlock:
  	mutex_unlock(&tcon->ses->server->srv_mutex);
diff --cc fs/cifs/dfs_cache.c
index 17718cdb89bc,831f42458bf6..000000000000
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@@ -1383,7 -1355,7 +1383,11 @@@ static void mark_for_reconnect_if_neede
  	}
  
  	cifs_dbg(FYI, "%s: no cached or matched targets. mark dfs share for reconnect.\n", __func__);
++<<<<<<< HEAD
 +	cifs_ses_mark_for_reconnect(tcon->ses);
++=======
+ 	cifs_mark_tcp_ses_conns_for_reconnect(tcon->ses->server, true);
++>>>>>>> 52492ff5c583 (cifs: call helper functions for marking channels for reconnect)
  }
  
  /* Refresh dfs referral of tcon and mark it for reconnect if needed */
diff --cc fs/cifs/smb1ops.c
index 421cc9a7fbb1,b2fb7bd11936..000000000000
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@@ -237,6 -226,11 +237,14 @@@ cifs_get_next_mid(struct TCP_Server_Inf
  		cur_mid++;
  	}
  	spin_unlock(&GlobalMid_Lock);
++<<<<<<< HEAD
++=======
+ 
+ 	if (reconnect) {
+ 		cifs_mark_tcp_ses_conns_for_reconnect(server, false);
+ 	}
+ 
++>>>>>>> 52492ff5c583 (cifs: call helper functions for marking channels for reconnect)
  	return mid;
  }
  
diff --cc fs/cifs/transport.c
index 680bba1f6d90,a4c3e027cca2..000000000000
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@@ -417,9 -430,7 +417,13 @@@ unmask
  		 * be taken as the remainder of this one. We need to kill the
  		 * socket so the server throws away the partial SMB
  		 */
++<<<<<<< HEAD
 +		spin_lock(&GlobalMid_Lock);
 +		server->tcpStatus = CifsNeedReconnect;
 +		spin_unlock(&GlobalMid_Lock);
++=======
+ 		cifs_mark_tcp_ses_conns_for_reconnect(server, false);
++>>>>>>> 52492ff5c583 (cifs: call helper functions for marking channels for reconnect)
  		trace_smb3_partial_send_reconnect(server->CurrentMid,
  						  server->conn_id, server->hostname);
  	}
* Unmerged path fs/cifs/cifs_swn.c
* Unmerged path fs/cifs/dfs_cache.c
* Unmerged path fs/cifs/smb1ops.c
* Unmerged path fs/cifs/transport.c
