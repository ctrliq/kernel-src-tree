cifs: update cifs_ses::ip_addr after failover

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit af3a6d1018f02c6dc8388f1f3785a559c7ab5961
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/af3a6d10.failed

cifs_ses::ip_addr wasn't being updated in cifs_session_setup() when
reconnecting SMB sessions thus returning wrong value in
/proc/fs/cifs/DebugData.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Cc: stable@kernel.org
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit af3a6d1018f02c6dc8388f1f3785a559c7ab5961)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index da8070d13e58,fa29c9aae24b..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3969,12 -4025,39 +3969,31 @@@ cifs_setup_session(const unsigned int x
  		   struct nls_table *nls_info)
  {
  	int rc = -ENOSYS;
+ 	struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;
+ 	struct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;
  	bool is_binding = false;
  
++<<<<<<< HEAD
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (server->dstaddr.ss_family == AF_INET6)
+ 		scnprintf(ses->ip_addr, sizeof(ses->ip_addr), "%pI6", &addr6->sin6_addr);
+ 	else
+ 		scnprintf(ses->ip_addr, sizeof(ses->ip_addr), "%pI4", &addr->sin_addr);
+ 
+ 	if (ses->ses_status != SES_GOOD &&
+ 	    ses->ses_status != SES_NEW &&
+ 	    ses->ses_status != SES_NEED_RECON) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 		return 0;
+ 	}
+ 
+ 	/* only send once per connect */
++>>>>>>> af3a6d1018f0 (cifs: update cifs_ses::ip_addr after failover)
  	spin_lock(&ses->chan_lock);
 -	if (CIFS_ALL_CHANS_GOOD(ses) ||
 -	    cifs_chan_in_reconnect(ses, server)) {
 -		spin_unlock(&ses->chan_lock);
 -		spin_unlock(&cifs_tcp_ses_lock);
 -		return 0;
 -	}
  	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
 -	cifs_chan_set_in_reconnect(ses, server);
  	spin_unlock(&ses->chan_lock);
  
 -	if (!is_binding)
 -		ses->ses_status = SES_IN_SETUP;
 -	spin_unlock(&cifs_tcp_ses_lock);
 -
  	if (!is_binding) {
  		ses->capabilities = server->capabilities;
  		if (!linuxExtEnabled)
* Unmerged path fs/cifs/connect.c
