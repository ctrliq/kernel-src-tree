cifs: fix potential race with cifsd thread

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Paulo Alcantara <pc@cjr.nz>
commit 687127c81ad32c8900a3fedbc7ed8f686ca95855
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/687127c8.failed

To avoid racing with demultiplex thread while it is handling data on
socket, use cifs_signal_cifsd_for_reconnect() helper for marking
current server to reconnect and let the demultiplex thread handle the
rest.

Fixes: dca65818c80c ("cifs: use a different reconnect helper for non-cifsd threads")
	Reviewed-by: Enzo Matsumiya <ematsumiya@suse.de>
	Reviewed-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 687127c81ad32c8900a3fedbc7ed8f686ca95855)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/netmisc.c
diff --cc fs/cifs/connect.c
index 7aabd597027d,3ca06bd88b6e..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -4305,6 -4442,32 +4305,35 @@@ static int tree_connect_dfs_target(cons
  out:
  	kfree(share);
  	kfree(prefix);
++<<<<<<< HEAD
++=======
+ 
+ 	return rc;
+ }
+ 
+ static int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,
+ 				   struct cifs_sb_info *cifs_sb, char *tree, bool islink,
+ 				   struct dfs_cache_tgt_list *tl)
+ {
+ 	int rc;
+ 	int num_links = 0;
+ 	struct TCP_Server_Info *server = tcon->ses->server;
+ 
+ 	do {
+ 		rc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, islink, tl);
+ 		if (!rc || rc != -EREMOTE)
+ 			break;
+ 	} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);
+ 	/*
+ 	 * If we couldn't tree connect to any targets from last referral path, then retry from
+ 	 * original referral path.
+ 	 */
+ 	if (rc && server->current_fullpath != server->origin_fullpath) {
+ 		server->current_fullpath = server->origin_fullpath;
+ 		cifs_signal_cifsd_for_reconnect(server, true);
+ 	}
+ 
++>>>>>>> 687127c81ad3 (cifs: fix potential race with cifsd thread)
  	dfs_cache_free_tgts(tl);
  	return rc;
  }
diff --cc fs/cifs/netmisc.c
index 33052a01b20e,235aa1b395eb..000000000000
--- a/fs/cifs/netmisc.c
+++ b/fs/cifs/netmisc.c
@@@ -909,10 -896,7 +909,14 @@@ map_and_check_smb_error(struct mid_q_en
  		if (class == ERRSRV && code == ERRbaduid) {
  			cifs_dbg(FYI, "Server returned 0x%x, reconnecting session...\n",
  				code);
++<<<<<<< HEAD
 +			spin_lock(&GlobalMid_Lock);
 +			if (mid->server->tcpStatus != CifsExiting)
 +				mid->server->tcpStatus = CifsNeedReconnect;
 +			spin_unlock(&GlobalMid_Lock);
++=======
+ 			cifs_signal_cifsd_for_reconnect(mid->server, false);
++>>>>>>> 687127c81ad3 (cifs: fix potential race with cifsd thread)
  		}
  	}
  
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/netmisc.c
