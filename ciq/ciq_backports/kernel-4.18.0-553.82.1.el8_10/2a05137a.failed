cifs: mark sessions for reconnection in helper function

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 2a05137a0575b7d1006bdf4c1beeee9e391e22a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/2a05137a.failed

Today we have the code to mark connections and sessions
(and tcons) for reconnect clubbed with the code to close
the socket and abort all mids in the same function.

Sometimes, we need to mark connections and sessions
outside cifsd thread. So as a part of this change, I'm
splitting this function into two different functions and
calling them one after the other in cifs_reconnect.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 2a05137a0575b7d1006bdf4c1beeee9e391e22a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 7aabd597027d,053cb449eb16..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -169,21 -166,16 +169,24 @@@ static void cifs_resolve_server(struct 
   * Mark all sessions and tcons for reconnect.
   *
   * @server needs to be previously set to CifsNeedReconnect.
 - *
   */
 -void
 -cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,
 -				      bool mark_smb_session)
 +static void cifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server)
  {
 -	struct TCP_Server_Info *pserver;
 +	unsigned int num_sessions = 0;
  	struct cifs_ses *ses;
  	struct cifs_tcon *tcon;
++<<<<<<< HEAD
 +	struct mid_q_entry *mid, *nmid;
 +	struct list_head retry_list;
 +	struct TCP_Server_Info *pserver;
  
 +	server->maxBuf = 0;
 +	server->max_read = 0;
++=======
++>>>>>>> 2a05137a0575 (cifs: mark sessions for reconnection in helper function)
 +
 +	cifs_dbg(FYI, "Mark tcp session as need reconnect\n");
 +	trace_smb3_reconnect(server->CurrentMid, server->conn_id, server->hostname);
  	/*
  	 * before reconnecting the tcp session, mark the smb session (uid) and the tid bad so they
  	 * are not used until reconnected.
@@@ -216,15 -214,17 +219,25 @@@ next_session
  		spin_unlock(&ses->chan_lock);
  	}
  	spin_unlock(&cifs_tcp_ses_lock);
+ }
+ 
+ static void
+ cifs_abort_connection(struct TCP_Server_Info *server)
+ {
+ 	struct mid_q_entry *mid, *nmid;
+ 	struct list_head retry_list;
+ 
+ 	server->maxBuf = 0;
+ 	server->max_read = 0;
  
 +	if (num_sessions == 0)
 +		return;
 +	/*
 +	 * before reconnecting the tcp session, mark the smb session (uid)
 +	 * and the tid bad so they are not used until reconnected
 +	 */
 +	cifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n",
 +		 __func__);
  	/* do not want to be sending data on a socket we are freeing */
  	cifs_dbg(FYI, "%s: tearing down socket\n", __func__);
  	mutex_lock(&server->srv_mutex);
@@@ -302,8 -313,10 +315,10 @@@ static int __cifs_reconnect(struct TCP_
  	if (!cifs_tcp_ses_needs_reconnect(server, 1))
  		return 0;
  
 -	cifs_mark_tcp_ses_conns_for_reconnect(server, mark_smb_session);
 +	cifs_mark_tcp_ses_conns_for_reconnect(server);
  
+ 	cifs_abort_connection(server);
+ 
  	do {
  		try_to_freeze();
  		mutex_lock(&server->srv_mutex);
@@@ -423,8 -439,10 +438,10 @@@ static int reconnect_dfs_server(struct 
  	if (!cifs_tcp_ses_needs_reconnect(server, num_targets))
  		return 0;
  
 -	cifs_mark_tcp_ses_conns_for_reconnect(server, mark_smb_session);
 +	cifs_mark_tcp_ses_conns_for_reconnect(server);
  
+ 	cifs_abort_connection(server);
+ 
  	do {
  		try_to_freeze();
  		mutex_lock(&server->srv_mutex);
* Unmerged path fs/cifs/connect.c
