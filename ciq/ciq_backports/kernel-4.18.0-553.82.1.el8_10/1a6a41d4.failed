cifs: do not use tcpStatus after negotiate completes

jira LE-4669
Rebuild_History Non-Buildable kernel-4.18.0-553.82.1.el8_10
commit-author Shyam Prasad N <sprasad@microsoft.com>
commit 1a6a41d4cedd9b302e2200e6f0e3c44dbbe13689
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.82.1.el8_10/1a6a41d4.failed

Recent changes to multichannel to allow channel reconnects to
work in parallel and independent of each other did so by
making use of tcpStatus for the connection, and status for the
session. However, this did not take into account the multiuser
scenario, where same connection is used by multiple connections.

However, tcpStatus should be tracked only till the end of
negotiate exchange, and not used for session setup. This change
fixes this.

	Signed-off-by: Shyam Prasad N <sprasad@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 1a6a41d4cedd9b302e2200e6f0e3c44dbbe13689)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/smb2pdu.c
#	fs/cifs/smb2transport.c
diff --cc fs/cifs/connect.c
index b65c3401b8e7,da1579fba496..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3919,8 -3968,11 +3919,13 @@@ cifs_negotiate_protocol(const unsigned 
  
  	rc = server->ops->negotiate(xid, ses, server);
  	if (rc == 0) {
++<<<<<<< HEAD
 +		spin_lock(&GlobalMid_Lock);
 +		if (server->tcpStatus == CifsNeedNegotiate)
++=======
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (server->tcpStatus == CifsInNegotiate)
++>>>>>>> 1a6a41d4cedd (cifs: do not use tcpStatus after negotiate completes)
  			server->tcpStatus = CifsGood;
  		else
  			rc = -EHOSTDOWN;
@@@ -3938,6 -3995,7 +3943,10 @@@ cifs_setup_session(const unsigned int x
  	int rc = -ENOSYS;
  	bool is_binding = false;
  
++<<<<<<< HEAD
++=======
+ 	/* only send once per connect */
++>>>>>>> 1a6a41d4cedd (cifs: do not use tcpStatus after negotiate completes)
  	spin_lock(&ses->chan_lock);
  	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
  	spin_unlock(&ses->chan_lock);
@@@ -3962,8 -4028,24 +3979,27 @@@
  	if (server->ops->sess_setup)
  		rc = server->ops->sess_setup(xid, ses, server, nls_info);
  
 -	if (rc) {
 +	if (rc)
  		cifs_server_dbg(VFS, "Send error in SessSetup = %d\n", rc);
++<<<<<<< HEAD
++=======
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (ses->status == CifsInSessSetup)
+ 			ses->status = CifsNeedSessSetup;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 	} else {
+ 		spin_lock(&cifs_tcp_ses_lock);
+ 		if (ses->status == CifsInSessSetup)
+ 			ses->status = CifsGood;
+ 		/* Even if one channel is active, session is in good state */
+ 		ses->status = CifsGood;
+ 		spin_unlock(&cifs_tcp_ses_lock);
+ 
+ 		spin_lock(&ses->chan_lock);
+ 		cifs_chan_clear_need_reconnect(ses, server);
+ 		spin_unlock(&ses->chan_lock);
+ 	}
++>>>>>>> 1a6a41d4cedd (cifs: do not use tcpStatus after negotiate completes)
  
  	return rc;
  }
diff --cc fs/cifs/smb2pdu.c
index fdd9bd57531e,f5321a3500f3..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -3869,9 -3896,12 +3869,16 @@@ SMB2_echo(struct TCP_Server_Info *serve
  				 .rq_nvec = 1 };
  	unsigned int total_len;
  
 -	cifs_dbg(FYI, "In echo request for conn_id %lld\n", server->conn_id);
 +	cifs_dbg(FYI, "In echo request\n");
  
++<<<<<<< HEAD
 +	if (server->tcpStatus == CifsNeedNegotiate) {
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (server->ops->need_neg &&
+ 	    server->ops->need_neg(server)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
++>>>>>>> 1a6a41d4cedd (cifs: do not use tcpStatus after negotiate completes)
  		/* No need to send echo on newly established connections */
  		mod_delayed_work(cifsiod_wq, &server->reconnect, 0);
  		return rc;
diff --cc fs/cifs/smb2transport.c
index 24dcef8d497b,01b732641edb..000000000000
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@@ -638,8 -640,13 +638,15 @@@ smb2_sign_rqst(struct smb_rqst *rqst, s
  
  	if (!is_signed)
  		return 0;
++<<<<<<< HEAD
 +	if (server->tcpStatus == CifsNeedNegotiate)
++=======
+ 	spin_lock(&cifs_tcp_ses_lock);
+ 	if (server->ops->need_neg &&
+ 	    server->ops->need_neg(server)) {
+ 		spin_unlock(&cifs_tcp_ses_lock);
++>>>>>>> 1a6a41d4cedd (cifs: do not use tcpStatus after negotiate completes)
  		return 0;
 -	}
 -	spin_unlock(&cifs_tcp_ses_lock);
  	if (!is_binding && !server->session_estab) {
  		strncpy(shdr->Signature, "BSRSPYL", 8);
  		return 0;
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/smb2pdu.c
* Unmerged path fs/cifs/smb2transport.c
