netfilter: nf_tables: fix out of memory error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Florian Westphal <fw@strlen.de>
commit 5e1be4cdc98c989d5387ce94ff15b5ad06a5b681
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/5e1be4cd.failed

Several instances of pipapo_resize() don't propagate allocation failures,
this causes a crash when fault injection is enabled for gfp_kernel slabs.

Fixes: 3c4287f62044 ("nf_tables: Add set type for arbitrary concatenation of ranges")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
(cherry picked from commit 5e1be4cdc98c989d5387ce94ff15b5ad06a5b681)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_set_pipapo.c
diff --cc net/netfilter/nft_set_pipapo.c
index 23ddedcfadc7,6af9c9ed4b5c..000000000000
--- a/net/netfilter/nft_set_pipapo.c
+++ b/net/netfilter/nft_set_pipapo.c
@@@ -850,9 -902,9 +850,13 @@@ static void pipapo_bucket_set(struct nf
  static int pipapo_insert(struct nft_pipapo_field *f, const uint8_t *k,
  			 int mask_bits)
  {
++<<<<<<< HEAD
 +	int rule = f->rules++, group, ret;
++=======
+ 	int rule = f->rules, group, ret, bit_offset = 0;
++>>>>>>> 5e1be4cdc98c (netfilter: nf_tables: fix out of memory error handling)
  
- 	ret = pipapo_resize(f, f->rules - 1, f->rules);
+ 	ret = pipapo_resize(f, f->rules, f->rules + 1);
  	if (ret)
  		return ret;
  
@@@ -1143,15 -1233,15 +1151,18 @@@ static int nft_pipapo_insert(const stru
  		rulemap[i].to = f->rules;
  
  		ret = memcmp(start, end,
 -			     f->groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));
 -		if (!ret)
 -			ret = pipapo_insert(f, start, f->groups * f->bb);
 -		else
 -			ret = pipapo_expand(f, start, end, f->groups * f->bb);
 +			     f->groups / NFT_PIPAPO_GROUPS_PER_BYTE);
 +		if (!ret) {
 +			ret = pipapo_insert(f, start,
 +					    f->groups * NFT_PIPAPO_GROUP_BITS);
 +		} else {
 +			ret = pipapo_expand(f, start, end,
 +					    f->groups * NFT_PIPAPO_GROUP_BITS);
 +		}
  
+ 		if (ret < 0)
+ 			return ret;
+ 
  		if (f->bsize > bsize_max)
  			bsize_max = f->bsize;
  
* Unmerged path net/netfilter/nft_set_pipapo.c
