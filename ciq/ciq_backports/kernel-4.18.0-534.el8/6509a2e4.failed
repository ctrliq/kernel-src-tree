netfilter: nf_tables: set backend .flush always succeeds

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6509a2e410c3cb36c78a0a85c6102debe171337e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/6509a2e4.failed

.flush is always successful since this results from iterating over the
set elements to toggle mark the element as inactive in the next
generation.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6509a2e410c3cb36c78a0a85c6102debe171337e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_set_hash.c
#	net/netfilter/nft_set_rbtree.c
diff --cc net/netfilter/nft_set_hash.c
index 037a2a90e4be,e758b887ad86..000000000000
--- a/net/netfilter/nft_set_hash.c
+++ b/net/netfilter/nft_set_hash.c
@@@ -190,20 -190,14 +190,24 @@@ static void nft_rhash_activate(const st
  	struct nft_rhash_elem *he = elem->priv;
  
  	nft_set_elem_change_active(net, set, &he->ext);
 +	nft_set_elem_clear_busy(&he->ext);
  }
  
- static bool nft_rhash_flush(const struct net *net,
+ static void nft_rhash_flush(const struct net *net,
  			    const struct nft_set *set, void *priv)
  {
  	struct nft_rhash_elem *he = priv;
  
++<<<<<<< HEAD
 +	if (!nft_set_elem_mark_busy(&he->ext) ||
 +	    !nft_is_active(net, &he->ext)) {
 +		nft_set_elem_change_active(net, set, &he->ext);
 +		return true;
 +	}
 +	return false;
++=======
+ 	nft_set_elem_change_active(net, set, &he->ext);
++>>>>>>> 6509a2e410c3 (netfilter: nf_tables: set backend .flush always succeeds)
  }
  
  static void *nft_rhash_deactivate(const struct net *net,
diff --cc net/netfilter/nft_set_rbtree.c
index c80ee6034fca,60ff591eb265..000000000000
--- a/net/netfilter/nft_set_rbtree.c
+++ b/net/netfilter/nft_set_rbtree.c
@@@ -376,20 -533,14 +376,24 @@@ static void nft_rbtree_activate(const s
  	struct nft_rbtree_elem *rbe = elem->priv;
  
  	nft_set_elem_change_active(net, set, &rbe->ext);
 +	nft_set_elem_clear_busy(&rbe->ext);
  }
  
- static bool nft_rbtree_flush(const struct net *net,
+ static void nft_rbtree_flush(const struct net *net,
  			     const struct nft_set *set, void *priv)
  {
  	struct nft_rbtree_elem *rbe = priv;
  
++<<<<<<< HEAD
 +	if (!nft_set_elem_mark_busy(&rbe->ext) ||
 +	    !nft_is_active(net, &rbe->ext)) {
 +		nft_set_elem_change_active(net, set, &rbe->ext);
 +		return true;
 +	}
 +	return false;
++=======
+ 	nft_set_elem_change_active(net, set, &rbe->ext);
++>>>>>>> 6509a2e410c3 (netfilter: nf_tables: set backend .flush always succeeds)
  }
  
  static void *nft_rbtree_deactivate(const struct net *net,
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index bb3d5316c6d5..a94a0f8510e0 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -374,7 +374,7 @@ struct nft_set_ops {
 	void *				(*deactivate)(const struct net *net,
 						      const struct nft_set *set,
 						      const struct nft_set_elem *elem);
-	bool				(*flush)(const struct net *net,
+	void				(*flush)(const struct net *net,
 						 const struct nft_set *set,
 						 void *priv);
 	void				(*remove)(const struct net *net,
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 4dd3d2e4449b..514e3283843d 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -5803,17 +5803,13 @@ static int nft_flush_set(const struct nft_ctx *ctx,
 			 struct nft_set_elem *elem)
 {
 	struct nft_trans *trans;
-	int err;
 
 	trans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,
 				    sizeof(struct nft_trans_elem), GFP_ATOMIC);
 	if (!trans)
 		return -ENOMEM;
 
-	if (!set->ops->flush(ctx->net, set, elem->priv)) {
-		err = -ENOENT;
-		goto err1;
-	}
+	set->ops->flush(ctx->net, set, elem->priv);
 	set->ndeact++;
 
 	nft_setelem_data_deactivate(ctx->net, set, elem);
@@ -5822,9 +5818,6 @@ static int nft_flush_set(const struct nft_ctx *ctx,
 	list_add_tail(&trans->list, &ctx->net->nft.commit_list);
 
 	return 0;
-err1:
-	kfree(trans);
-	return err;
 }
 
 static int nf_tables_delsetelem(struct net *net, struct sock *nlsk,
diff --git a/net/netfilter/nft_set_bitmap.c b/net/netfilter/nft_set_bitmap.c
index b127826b5d7f..ba9acdb055cd 100644
--- a/net/netfilter/nft_set_bitmap.c
+++ b/net/netfilter/nft_set_bitmap.c
@@ -176,7 +176,7 @@ static void nft_bitmap_activate(const struct net *net,
 	nft_set_elem_change_active(net, set, &be->ext);
 }
 
-static bool nft_bitmap_flush(const struct net *net,
+static void nft_bitmap_flush(const struct net *net,
 			     const struct nft_set *set, void *_be)
 {
 	struct nft_bitmap *priv = nft_set_priv(set);
@@ -188,8 +188,6 @@ static bool nft_bitmap_flush(const struct net *net,
 	/* Enter 10 state, similar to deactivation. */
 	priv->bitmap[idx] &= ~(genmask << off);
 	nft_set_elem_change_active(net, set, &be->ext);
-
-	return true;
 }
 
 static void *nft_bitmap_deactivate(const struct net *net,
* Unmerged path net/netfilter/nft_set_hash.c
diff --git a/net/netfilter/nft_set_pipapo.c b/net/netfilter/nft_set_pipapo.c
index e50a3f58f77b..ebbd0ba015fa 100644
--- a/net/netfilter/nft_set_pipapo.c
+++ b/net/netfilter/nft_set_pipapo.c
@@ -1640,14 +1640,12 @@ static void *nft_pipapo_deactivate(const struct net *net,
  *
  * Return: true if element was found and deactivated.
  */
-static bool nft_pipapo_flush(const struct net *net, const struct nft_set *set,
+static void nft_pipapo_flush(const struct net *net, const struct nft_set *set,
 			     void *elem)
 {
 	struct nft_pipapo_elem *e = elem;
 
 	nft_set_elem_change_active(net, set, &e->ext);
-
-	return true;
 }
 
 /**
* Unmerged path net/netfilter/nft_set_rbtree.c
