nfsd: lock_rename() needs both directories to live on the same fs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 1aee9158bc978f91701c5992e395efbc6da2de3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/1aee9158.failed

... checking that after lock_rename() is too late.  Incidentally,
NFSv2 had no nfserr_xdev...

Fixes: aa387d6ce153 "nfsd: fix EXDEV checking in rename"
	Cc: stable@vger.kernel.org # v3.9+
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Acked-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 1aee9158bc978f91701c5992e395efbc6da2de3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/vfs.c
diff --cc fs/nfsd/vfs.c
index 104d8ebd33d5,02f5fcaad03f..000000000000
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@@ -1760,6 -1788,13 +1760,16 @@@ nfsd_rename(struct svc_rqst *rqstp, str
  	if (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	err = (rqstp->rq_vers == 2) ? nfserr_acces : nfserr_xdev;
+ 	if (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)
+ 		goto out;
+ 	if (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)
+ 		goto out;
+ 
+ retry:
++>>>>>>> 1aee9158bc97 (nfsd: lock_rename() needs both directories to live on the same fs)
  	host_err = fh_want_write(ffhp);
  	if (host_err) {
  		err = nfserrno(host_err);
@@@ -1793,17 -1829,33 +1803,47 @@@
  	if (ndentry == trap)
  		goto out_dput_new;
  
++<<<<<<< HEAD
 +	host_err = -EXDEV;
 +	if (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)
 +		goto out_dput_new;
 +	if (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)
 +		goto out_dput_new;
 +
 +	host_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);
 +	if (!host_err) {
 +		host_err = commit_metadata(tfhp);
 +		if (!host_err)
 +			host_err = commit_metadata(ffhp);
++=======
+ 	if ((ndentry->d_sb->s_export_op->flags & EXPORT_OP_CLOSE_BEFORE_UNLINK) &&
+ 	    nfsd_has_cached_files(ndentry)) {
+ 		close_cached = true;
+ 		goto out_dput_old;
+ 	} else {
+ 		struct renamedata rd = {
+ 			.old_mnt_idmap	= &nop_mnt_idmap,
+ 			.old_dir	= fdir,
+ 			.old_dentry	= odentry,
+ 			.new_mnt_idmap	= &nop_mnt_idmap,
+ 			.new_dir	= tdir,
+ 			.new_dentry	= ndentry,
+ 		};
+ 		int retries;
+ 
+ 		for (retries = 1;;) {
+ 			host_err = vfs_rename(&rd);
+ 			if (host_err != -EAGAIN || !retries--)
+ 				break;
+ 			if (!nfsd_wait_for_delegreturn(rqstp, d_inode(odentry)))
+ 				break;
+ 		}
+ 		if (!host_err) {
+ 			host_err = commit_metadata(tfhp);
+ 			if (!host_err)
+ 				host_err = commit_metadata(ffhp);
+ 		}
++>>>>>>> 1aee9158bc97 (nfsd: lock_rename() needs both directories to live on the same fs)
  	}
   out_dput_new:
  	dput(ndentry);
* Unmerged path fs/nfsd/vfs.c
