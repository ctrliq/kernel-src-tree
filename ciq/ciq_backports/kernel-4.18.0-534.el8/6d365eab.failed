netfilter: nft_set_pipapo: stop GC iteration if GC transaction allocation fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6d365eabce3c018a80f6e0379b17df2abb17405e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/6d365eab.failed

nft_trans_gc_queue_sync() enqueues the GC transaction and it allocates a
new one. If this allocation fails, then stop this GC sync run and retry
later.

Fixes: 5f68718b34a5 ("netfilter: nf_tables: GC transaction API to avoid race with control plane")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6d365eabce3c018a80f6e0379b17df2abb17405e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_set_pipapo.c
diff --cc net/netfilter/nft_set_pipapo.c
index 23ddedcfadc7,c0dcc40de358..000000000000
--- a/net/netfilter/nft_set_pipapo.c
+++ b/net/netfilter/nft_set_pipapo.c
@@@ -1463,13 -1587,20 +1463,22 @@@ static void pipapo_gc(const struct nft_
  		f--;
  		i--;
  		e = f->mt[rulemap[i].to].e;
 -
 -		/* synchronous gc never fails, there is no need to set on
 -		 * NFT_SET_ELEM_DEAD_BIT.
 -		 */
 -		if (nft_set_elem_expired(&e->ext)) {
 +		if (nft_set_elem_expired(&e->ext) &&
 +		    !nft_set_elem_mark_busy(&e->ext)) {
  			priv->dirty = true;
++<<<<<<< HEAD
++=======
+ 
+ 			gc = nft_trans_gc_queue_sync(gc, GFP_ATOMIC);
+ 			if (!gc)
+ 				return;
+ 
+ 			nft_pipapo_gc_deactivate(net, set, e);
++>>>>>>> 6d365eabce3c (netfilter: nft_set_pipapo: stop GC iteration if GC transaction allocation fails)
  			pipapo_drop(m, rulemap);
 -			nft_trans_gc_elem_add(gc, e);
 +
 +			rcu_barrier();
 +			nft_set_elem_destroy(set, e, true);
  
  			/* And check again current first rule, which is now the
  			 * first we haven't checked.
* Unmerged path net/netfilter/nft_set_pipapo.c
