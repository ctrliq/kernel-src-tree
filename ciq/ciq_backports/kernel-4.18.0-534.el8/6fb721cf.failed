netfilter: nf_tables: honor NLM_F_CREATE and NLM_F_EXCL in event notification

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6fb721cf781808ee2ca5e737fb0592cc68de3381
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/6fb721cf.failed

Include the NLM_F_CREATE and NLM_F_EXCL flags in netlink event
notifications, otherwise userspace cannot distiguish between create and
add commands.

Fixes: 96518518cc41 ("netfilter: add nftables")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6fb721cf781808ee2ca5e737fb0592cc68de3381)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index c52a1dd1b5bc,c0851fec11d4..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -759,7 -778,9 +759,8 @@@ static void nft_notify_enqueue(struct s
  
  static void nf_tables_table_notify(const struct nft_ctx *ctx, int event)
  {
 -	struct nftables_pernet *nft_net;
  	struct sk_buff *skb;
+ 	u16 flags = 0;
  	int err;
  
  	if (!ctx->report &&
@@@ -1492,7 -1565,9 +1496,8 @@@ nla_put_failure
  
  static void nf_tables_chain_notify(const struct nft_ctx *ctx, int event)
  {
 -	struct nftables_pernet *nft_net;
  	struct sk_buff *skb;
+ 	u16 flags = 0;
  	int err;
  
  	if (!ctx->report &&
@@@ -2776,9 -2945,20 +2784,23 @@@ static void nf_tables_rule_notify(cons
  	if (skb == NULL)
  		goto err;
  
++<<<<<<< HEAD
++=======
+ 	if (event == NFT_MSG_NEWRULE &&
+ 	    !list_is_first(&rule->list, &ctx->chain->rules) &&
+ 	    !list_is_last(&rule->list, &ctx->chain->rules)) {
+ 		prule = list_prev_entry(rule, list);
+ 		handle = prule->handle;
+ 	}
+ 	if (ctx->flags & (NLM_F_APPEND | NLM_F_REPLACE))
+ 		flags |= NLM_F_APPEND;
+ 	if (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))
+ 		flags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);
+ 
++>>>>>>> 6fb721cf7818 (netfilter: nf_tables: honor NLM_F_CREATE and NLM_F_EXCL in event notification)
  	err = nf_tables_fill_rule_info(skb, ctx->net, ctx->portid, ctx->seq,
 -				       event, flags, ctx->family, ctx->table,
 -				       ctx->chain, rule, handle);
 +				       event, 0, ctx->family, ctx->table,
 +				       ctx->chain, rule, NULL);
  	if (err < 0) {
  		kfree_skb(skb);
  		goto err;
@@@ -3809,8 -3966,10 +3831,14 @@@ static void nf_tables_set_notify(const 
  				 const struct nft_set *set, int event,
  			         gfp_t gfp_flags)
  {
++<<<<<<< HEAD
 +	struct sk_buff *skb;
++=======
+ 	struct nftables_pernet *nft_net = nft_pernet(ctx->net);
++>>>>>>> 6fb721cf7818 (netfilter: nf_tables: honor NLM_F_CREATE and NLM_F_EXCL in event notification)
  	u32 portid = ctx->portid;
+ 	struct sk_buff *skb;
+ 	u16 flags = 0;
  	int err;
  
  	if (!ctx->report &&
@@@ -5008,8 -5259,9 +5039,8 @@@ static int nf_tables_getsetelem(struct 
  static void nf_tables_setelem_notify(const struct nft_ctx *ctx,
  				     const struct nft_set *set,
  				     const struct nft_set_elem *elem,
- 				     int event, u16 flags)
+ 				     int event)
  {
 -	struct nftables_pernet *nft_net;
  	struct net *net = ctx->net;
  	u32 portid = ctx->portid;
  	struct sk_buff *skb;
@@@ -6486,8 -6953,9 +6521,8 @@@ static int nf_tables_delobj(struct net 
  
  void nft_obj_notify(struct net *net, const struct nft_table *table,
  		    struct nft_object *obj, u32 portid, u32 seq, int event,
- 		    int family, int report, gfp_t gfp)
+ 		    u16 flags, int family, int report, gfp_t gfp)
  {
 -	struct nftables_pernet *nft_net = nft_pernet(net);
  	struct sk_buff *skb;
  	int err;
  	char *buf = kasprintf(gfp, "%s:%u",
@@@ -7139,9 -7773,12 +7175,10 @@@ err_fill_flowtable_info
  
  static void nf_tables_flowtable_notify(struct nft_ctx *ctx,
  				       struct nft_flowtable *flowtable,
 -				       struct list_head *hook_list,
  				       int event)
  {
 -	struct nftables_pernet *nft_net = nft_pernet(ctx->net);
  	struct sk_buff *skb;
+ 	u16 flags = 0;
  	int err;
  
  	if (!ctx->report &&
@@@ -7152,9 -7789,12 +7189,17 @@@
  	if (skb == NULL)
  		goto err;
  
+ 	if (ctx->flags & (NLM_F_CREATE | NLM_F_EXCL))
+ 		flags |= ctx->flags & (NLM_F_CREATE | NLM_F_EXCL);
+ 
  	err = nf_tables_fill_flowtable_info(skb, ctx->net, ctx->portid,
++<<<<<<< HEAD
 +					    ctx->seq, event, 0,
 +					    ctx->family, flowtable);
++=======
+ 					    ctx->seq, event, flags,
+ 					    ctx->family, flowtable, hook_list);
++>>>>>>> 6fb721cf7818 (netfilter: nf_tables: honor NLM_F_CREATE and NLM_F_EXCL in event notification)
  	if (err < 0) {
  		kfree_skb(skb);
  		goto err;
@@@ -7990,10 -8668,10 +8035,10 @@@ static int nf_tables_commit(struct net 
  		case NFT_MSG_NEWSETELEM:
  			te = (struct nft_trans_elem *)trans->data;
  
 -			nft_setelem_activate(net, te->set, &te->elem);
 +			te->set->ops->activate(net, te->set, &te->elem);
  			nf_tables_setelem_notify(&trans->ctx, te->set,
  						 &te->elem,
- 						 NFT_MSG_NEWSETELEM, 0);
+ 						 NFT_MSG_NEWSETELEM);
  			nft_trans_destroy(trans);
  			break;
  		case NFT_MSG_DELSETELEM:
@@@ -8001,10 -8679,12 +8046,19 @@@
  
  			nf_tables_setelem_notify(&trans->ctx, te->set,
  						 &te->elem,
++<<<<<<< HEAD
 +						 NFT_MSG_DELSETELEM, 0);
 +			te->set->ops->remove(net, te->set, &te->elem);
 +			atomic_dec(&te->set->nelems);
 +			te->set->ndeact--;
++=======
+ 						 NFT_MSG_DELSETELEM);
+ 			nft_setelem_remove(net, te->set, &te->elem);
+ 			if (!nft_setelem_is_catchall(te->set, &te->elem)) {
+ 				atomic_dec(&te->set->nelems);
+ 				te->set->ndeact--;
+ 			}
++>>>>>>> 6fb721cf7818 (netfilter: nf_tables: honor NLM_F_CREATE and NLM_F_EXCL in event notification)
  			break;
  		case NFT_MSG_NEWOBJ:
  			if (nft_trans_obj_update(trans)) {
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index afd104d4fe75..b506b6bdb4cf 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -1168,7 +1168,7 @@ struct nft_object *nft_obj_lookup(const struct net *net,
 
 void nft_obj_notify(struct net *net, const struct nft_table *table,
 		    struct nft_object *obj, u32 portid, u32 seq,
-		    int event, int family, int report, gfp_t gfp);
+		    int event, u16 flags, int family, int report, gfp_t gfp);
 
 /**
  *	struct nft_object_type - stateful object type
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_quota.c b/net/netfilter/nft_quota.c
index e0c6e843cb22..cf5cf49681d7 100644
--- a/net/netfilter/nft_quota.c
+++ b/net/netfilter/nft_quota.c
@@ -63,7 +63,7 @@ static void nft_quota_obj_eval(struct nft_object *obj,
 	if (overquota &&
 	    !test_and_set_bit(NFT_QUOTA_DEPLETED_BIT, &priv->flags))
 		nft_obj_notify(nft_net(pkt), obj->key.table, obj, 0, 0,
-			       NFT_MSG_NEWOBJ, nft_pf(pkt), 0, GFP_ATOMIC);
+			       NFT_MSG_NEWOBJ, 0, nft_pf(pkt), 0, GFP_ATOMIC);
 }
 
 static int nft_quota_do_init(const struct nlattr * const tb[],
