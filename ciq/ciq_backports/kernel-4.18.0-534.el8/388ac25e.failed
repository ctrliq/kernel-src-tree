crypto: tcrypt - remove all multibuffer ahash tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Tianjia Zhang <tianjia.zhang@linux.alibaba.com>
commit 388ac25efc8ce3bf9768ce7bf24268d6fac285d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/388ac25e.failed

The multibuffer algorithms was removed already in 2018, so it is
necessary to clear the test code left by tcrypt.

	Suggested-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: Tianjia Zhang <tianjia.zhang@linux.alibaba.com>
	Acked-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 388ac25efc8ce3bf9768ce7bf24268d6fac285d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/tcrypt.c
diff --cc crypto/tcrypt.c
index 9dd4e3c764e3,2a808e843de5..000000000000
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@@ -710,198 -724,6 +710,201 @@@ static inline int do_one_ahash_op(struc
  	return crypto_wait_req(ret, wait);
  }
  
++<<<<<<< HEAD
 +struct test_mb_ahash_data {
 +	struct scatterlist sg[XBUFSIZE];
 +	char result[64];
 +	struct ahash_request *req;
 +	struct crypto_wait wait;
 +	char *xbuf[XBUFSIZE];
 +};
 +
 +static inline int do_mult_ahash_op(struct test_mb_ahash_data *data, u32 num_mb,
 +				   int *rc)
 +{
 +	int i, err = 0;
 +
 +	/* Fire up a bunch of concurrent requests */
 +	for (i = 0; i < num_mb; i++)
 +		rc[i] = crypto_ahash_digest(data[i].req);
 +
 +	/* Wait for all requests to finish */
 +	for (i = 0; i < num_mb; i++) {
 +		rc[i] = crypto_wait_req(rc[i], &data[i].wait);
 +
 +		if (rc[i]) {
 +			pr_info("concurrent request %d error %d\n", i, rc[i]);
 +			err = rc[i];
 +		}
 +	}
 +
 +	return err;
 +}
 +
 +static int test_mb_ahash_jiffies(struct test_mb_ahash_data *data, int blen,
 +				 int secs, u32 num_mb)
 +{
 +	unsigned long start, end;
 +	int bcount;
 +	int ret = 0;
 +	int *rc;
 +
 +	rc = kcalloc(num_mb, sizeof(*rc), GFP_KERNEL);
 +	if (!rc)
 +		return -ENOMEM;
 +
 +	for (start = jiffies, end = start + secs * HZ, bcount = 0;
 +	     time_before(jiffies, end); bcount++) {
 +		ret = do_mult_ahash_op(data, num_mb, rc);
 +		if (ret)
 +			goto out;
 +	}
 +
 +	pr_cont("%d operations in %d seconds (%ld bytes)\n",
 +		bcount * num_mb, secs, (long)bcount * blen * num_mb);
 +
 +out:
 +	kfree(rc);
 +	return ret;
 +}
 +
 +static int test_mb_ahash_cycles(struct test_mb_ahash_data *data, int blen,
 +				u32 num_mb)
 +{
 +	unsigned long cycles = 0;
 +	int ret = 0;
 +	int i;
 +	int *rc;
 +
 +	rc = kcalloc(num_mb, sizeof(*rc), GFP_KERNEL);
 +	if (!rc)
 +		return -ENOMEM;
 +
 +	/* Warm-up run. */
 +	for (i = 0; i < 4; i++) {
 +		ret = do_mult_ahash_op(data, num_mb, rc);
 +		if (ret)
 +			goto out;
 +	}
 +
 +	/* The real thing. */
 +	for (i = 0; i < 8; i++) {
 +		cycles_t start, end;
 +
 +		start = get_cycles();
 +		ret = do_mult_ahash_op(data, num_mb, rc);
 +		end = get_cycles();
 +
 +		if (ret)
 +			goto out;
 +
 +		cycles += end - start;
 +	}
 +
 +	pr_cont("1 operation in %lu cycles (%d bytes)\n",
 +		(cycles + 4) / (8 * num_mb), blen);
 +
 +out:
 +	kfree(rc);
 +	return ret;
 +}
 +
 +static void test_mb_ahash_speed(const char *algo, unsigned int secs,
 +				struct hash_speed *speed, u32 num_mb)
 +{
 +	struct test_mb_ahash_data *data;
 +	struct crypto_ahash *tfm;
 +	unsigned int i, j, k;
 +	int ret;
 +
 +	data = kcalloc(num_mb, sizeof(*data), GFP_KERNEL);
 +	if (!data)
 +		return;
 +
 +	tfm = crypto_alloc_ahash(algo, 0, 0);
 +	if (IS_ERR(tfm)) {
 +		pr_err("failed to load transform for %s: %ld\n",
 +			algo, PTR_ERR(tfm));
 +		goto free_data;
 +	}
 +
 +	for (i = 0; i < num_mb; ++i) {
 +		if (testmgr_alloc_buf(data[i].xbuf))
 +			goto out;
 +
 +		crypto_init_wait(&data[i].wait);
 +
 +		data[i].req = ahash_request_alloc(tfm, GFP_KERNEL);
 +		if (!data[i].req) {
 +			pr_err("alg: hash: Failed to allocate request for %s\n",
 +			       algo);
 +			goto out;
 +		}
 +
 +		ahash_request_set_callback(data[i].req, 0, crypto_req_done,
 +					   &data[i].wait);
 +
 +		sg_init_table(data[i].sg, XBUFSIZE);
 +		for (j = 0; j < XBUFSIZE; j++) {
 +			sg_set_buf(data[i].sg + j, data[i].xbuf[j], PAGE_SIZE);
 +			memset(data[i].xbuf[j], 0xff, PAGE_SIZE);
 +		}
 +	}
 +
 +	pr_info("\ntesting speed of multibuffer %s (%s)\n", algo,
 +		get_driver_name(crypto_ahash, tfm));
 +
 +	for (i = 0; speed[i].blen != 0; i++) {
 +		/* For some reason this only tests digests. */
 +		if (speed[i].blen != speed[i].plen)
 +			continue;
 +
 +		if (speed[i].blen > XBUFSIZE * PAGE_SIZE) {
 +			pr_err("template (%u) too big for tvmem (%lu)\n",
 +			       speed[i].blen, XBUFSIZE * PAGE_SIZE);
 +			goto out;
 +		}
 +
 +		if (speed[i].klen)
 +			crypto_ahash_setkey(tfm, tvmem[0], speed[i].klen);
 +
 +		for (k = 0; k < num_mb; k++)
 +			ahash_request_set_crypt(data[k].req, data[k].sg,
 +						data[k].result, speed[i].blen);
 +
 +		pr_info("test%3u "
 +			"(%5u byte blocks,%5u bytes per update,%4u updates): ",
 +			i, speed[i].blen, speed[i].plen,
 +			speed[i].blen / speed[i].plen);
 +
 +		if (secs)
 +			ret = test_mb_ahash_jiffies(data, speed[i].blen, secs,
 +						    num_mb);
 +		else
 +			ret = test_mb_ahash_cycles(data, speed[i].blen, num_mb);
 +
 +
 +		if (ret) {
 +			pr_err("At least one hashing failed ret=%d\n", ret);
 +			break;
 +		}
 +	}
 +
 +out:
 +	for (k = 0; k < num_mb; ++k)
 +		ahash_request_free(data[k].req);
 +
 +	for (k = 0; k < num_mb; ++k)
 +		testmgr_free_buf(data[k].xbuf);
 +
 +	crypto_free_ahash(tfm);
 +
 +free_data:
 +	kfree(data);
 +}
 +
++=======
++>>>>>>> 388ac25efc8c (crypto: tcrypt - remove all multibuffer ahash tests)
  static int test_ahash_jiffies_digest(struct ahash_request *req, int blen,
  				     char *out, int secs)
  {
@@@ -2477,27 -2375,11 +2480,33 @@@ static int do_test(const char *alg, u3
  	case 421:
  		test_ahash_speed("sha3-512", sec, generic_hash_speed_template);
  		if (mode > 400 && mode < 500) break;
 -		fallthrough;
 +		/* fall through */
  	case 422:
++<<<<<<< HEAD
 +		test_mb_ahash_speed("sha1", sec, generic_hash_speed_template,
 +				    num_mb);
 +		if (mode > 400 && mode < 500) break;
 +		/* fall through */
 +	case 423:
 +		test_mb_ahash_speed("sha256", sec, generic_hash_speed_template,
 +				    num_mb);
 +		if (mode > 400 && mode < 500) break;
 +		/* fall through */
 +	case 424:
 +		test_mb_ahash_speed("sha512", sec, generic_hash_speed_template,
 +				    num_mb);
 +		if (mode > 400 && mode < 500) break;
 +		/* fall through */
 +	case 425:
 +		test_mb_ahash_speed("sm3", sec, generic_hash_speed_template,
 +				    num_mb);
 +		if (mode > 400 && mode < 500) break;
 +		/* fall through */
++=======
+ 		test_ahash_speed("sm3", sec, generic_hash_speed_template);
+ 		if (mode > 400 && mode < 500) break;
+ 		fallthrough;
++>>>>>>> 388ac25efc8c (crypto: tcrypt - remove all multibuffer ahash tests)
  	case 499:
  		break;
  
* Unmerged path crypto/tcrypt.c
