netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6a33d8b73dfac0a41f3877894b38082bd0c9a5bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/6a33d8b7.failed

Netlink event path is missing a synchronization point with GC
transactions. Add GC sequence number update to netns release path and
netlink event path, any GC transaction losing race will be discarded.

Fixes: 5f68718b34a5 ("netfilter: nf_tables: GC transaction API to avoid race with control plane")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Signed-off-by: Florian Westphal <fw@strlen.de>
(cherry picked from commit 6a33d8b73dfac0a41f3877894b38082bd0c9a5bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 65617e020aff,8ac4dd8be1a2..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -7866,9 -9725,42 +7866,42 @@@ static void nf_tables_commit_audit_log(
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void nft_set_commit_update(struct list_head *set_update_list)
+ {
+ 	struct nft_set *set, *next;
+ 
+ 	list_for_each_entry_safe(set, next, set_update_list, pending_update) {
+ 		list_del_init(&set->pending_update);
+ 
+ 		if (!set->ops->commit)
+ 			continue;
+ 
+ 		set->ops->commit(set);
+ 	}
+ }
+ 
+ static unsigned int nft_gc_seq_begin(struct nftables_pernet *nft_net)
+ {
+ 	unsigned int gc_seq;
+ 
+ 	/* Bump gc counter, it becomes odd, this is the busy mark. */
+ 	gc_seq = READ_ONCE(nft_net->gc_seq);
+ 	WRITE_ONCE(nft_net->gc_seq, ++gc_seq);
+ 
+ 	return gc_seq;
+ }
+ 
+ static void nft_gc_seq_end(struct nftables_pernet *nft_net, unsigned int gc_seq)
+ {
+ 	WRITE_ONCE(nft_net->gc_seq, ++gc_seq);
+ }
+ 
++>>>>>>> 6a33d8b73dfa (netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path)
  static int nf_tables_commit(struct net *net, struct sk_buff *skb)
  {
 -	struct nftables_pernet *nft_net = nft_pernet(net);
  	struct nft_trans *trans, *next;
 -	unsigned int base_seq, gc_seq;
 -	LIST_HEAD(set_update_list);
  	struct nft_trans_elem *te;
  	struct nft_chain *chain;
  	struct nft_table *table;
@@@ -7921,7 -9838,9 +7954,13 @@@
  	while (++base_seq == 0)
  		;
  
++<<<<<<< HEAD
 +	WRITE_ONCE(net->nft.base_seq, base_seq);
++=======
+ 	WRITE_ONCE(nft_net->base_seq, base_seq);
+ 
+ 	gc_seq = nft_gc_seq_begin(nft_net);
++>>>>>>> 6a33d8b73dfa (netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path)
  
  	/* step 3. Start new generation, rules_gen_X now in use. */
  	net->nft.gencursor = nft_gencursor_next(net);
@@@ -8062,9 -10047,13 +8101,15 @@@
  		}
  	}
  
 -	nft_set_commit_update(&set_update_list);
 -
  	nft_commit_notify(net, NETLINK_CB(skb).portid);
  	nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);
++<<<<<<< HEAD
 +	nf_tables_commit_audit_log(&adl, net->nft.base_seq);
++=======
+ 	nf_tables_commit_audit_log(&adl, nft_net->base_seq);
+ 
+ 	nft_gc_seq_end(nft_net, gc_seq);
++>>>>>>> 6a33d8b73dfa (netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path)
  	nf_tables_commit_release(net);
  
  	return 0;
@@@ -8880,15 -11045,71 +8925,71 @@@ static void __nft_release_tables(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_rcv_nl_event(struct notifier_block *this, unsigned long event,
+ 			    void *ptr)
+ {
+ 	struct nft_table *table, *to_delete[8];
+ 	struct nftables_pernet *nft_net;
+ 	struct netlink_notify *n = ptr;
+ 	struct net *net = n->net;
+ 	unsigned int deleted;
+ 	bool restart = false;
+ 	unsigned int gc_seq;
+ 
+ 	if (event != NETLINK_URELEASE || n->protocol != NETLINK_NETFILTER)
+ 		return NOTIFY_DONE;
+ 
+ 	nft_net = nft_pernet(net);
+ 	deleted = 0;
+ 	mutex_lock(&nft_net->commit_mutex);
+ 
+ 	gc_seq = nft_gc_seq_begin(nft_net);
+ 
+ 	if (!list_empty(&nf_tables_destroy_list))
+ 		rcu_barrier();
+ again:
+ 	list_for_each_entry(table, &nft_net->tables, list) {
+ 		if (nft_table_has_owner(table) &&
+ 		    n->portid == table->nlpid) {
+ 			__nft_release_hook(net, table);
+ 			list_del_rcu(&table->list);
+ 			to_delete[deleted++] = table;
+ 			if (deleted >= ARRAY_SIZE(to_delete))
+ 				break;
+ 		}
+ 	}
+ 	if (deleted) {
+ 		restart = deleted >= ARRAY_SIZE(to_delete);
+ 		synchronize_rcu();
+ 		while (deleted)
+ 			__nft_release_table(net, to_delete[--deleted]);
+ 
+ 		if (restart)
+ 			goto again;
+ 	}
+ 	nft_gc_seq_end(nft_net, gc_seq);
+ 
+ 	mutex_unlock(&nft_net->commit_mutex);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block nft_nl_notifier = {
+ 	.notifier_call  = nft_rcv_nl_event,
+ };
+ 
++>>>>>>> 6a33d8b73dfa (netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path)
  static int __net_init nf_tables_init_net(struct net *net)
  {
 -	struct nftables_pernet *nft_net = nft_pernet(net);
 -
 -	INIT_LIST_HEAD(&nft_net->tables);
 -	INIT_LIST_HEAD(&nft_net->commit_list);
 -	INIT_LIST_HEAD(&nft_net->binding_list);
 -	INIT_LIST_HEAD(&nft_net->module_list);
 -	INIT_LIST_HEAD(&nft_net->notify_list);
 -	mutex_init(&nft_net->commit_mutex);
 -	nft_net->base_seq = 1;
 -	nft_net->gc_seq = 0;
 +	INIT_LIST_HEAD(&net->nft.tables);
 +	INIT_LIST_HEAD(&net->nft.commit_list);
 +	INIT_LIST_HEAD(&net->nft_module_list);
 +	INIT_LIST_HEAD(&net->nft_notify_list);
 +	mutex_init(&net->nft_commit_mutex);
 +	net->nft.base_seq = 1;
 +	net->nft.validate_state = NFT_VALIDATE_SKIP;
  
  	return 0;
  }
@@@ -8902,15 -11125,30 +9003,43 @@@ static void __net_exit nf_tables_pre_ex
  
  static void __net_exit nf_tables_exit_net(struct net *net)
  {
++<<<<<<< HEAD
 +	mutex_lock(&net->nft_commit_mutex);
 +	if (!list_empty(&net->nft.commit_list) ||
 +	    !list_empty(&net->nft_module_list))
++=======
+ 	struct nftables_pernet *nft_net = nft_pernet(net);
+ 	unsigned int gc_seq;
+ 
+ 	mutex_lock(&nft_net->commit_mutex);
+ 
+ 	gc_seq = nft_gc_seq_begin(nft_net);
+ 
+ 	if (!list_empty(&nft_net->commit_list) ||
+ 	    !list_empty(&nft_net->module_list))
++>>>>>>> 6a33d8b73dfa (netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path)
  		__nf_tables_abort(net, NFNL_ABORT_NONE);
+ 
  	__nft_release_tables(net);
++<<<<<<< HEAD
 +	mutex_unlock(&net->nft_commit_mutex);
 +	WARN_ON_ONCE(!list_empty(&net->nft.tables));
 +	WARN_ON_ONCE(!list_empty(&net->nft_module_list));
 +	WARN_ON_ONCE(!list_empty(&net->nft_notify_list));
++=======
+ 
+ 	nft_gc_seq_end(nft_net, gc_seq);
+ 
+ 	mutex_unlock(&nft_net->commit_mutex);
+ 	WARN_ON_ONCE(!list_empty(&nft_net->tables));
+ 	WARN_ON_ONCE(!list_empty(&nft_net->module_list));
+ 	WARN_ON_ONCE(!list_empty(&nft_net->notify_list));
+ }
+ 
+ static void nf_tables_exit_batch(struct list_head *net_exit_list)
+ {
+ 	flush_work(&trans_gc_work);
++>>>>>>> 6a33d8b73dfa (netfilter: nf_tables: fix GC transaction races with netns and netlink event exit path)
  }
  
  static struct pernet_operations nf_tables_net_ops = {
* Unmerged path net/netfilter/nf_tables_api.c
