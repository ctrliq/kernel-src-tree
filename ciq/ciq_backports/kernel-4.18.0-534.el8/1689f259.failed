netfilter: nf_tables: report use refcount overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 1689f25924ada8fe14a4a82c38925d04994c7142
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/1689f259.failed

Overflow use refcount checks are not complete.

Add helper function to deal with object reference counter tracking.
Report -EMFILE in case UINT_MAX is reached.

nft_use_dec() splats in case that reference counter underflows,
which should not ever happen.

Add nft_use_inc_restore() and nft_use_dec_restore() which are used
to restore reference counter from error and abort paths.

Use u32 in nft_flowtable and nft_object since helper functions cannot
work on bitfields.

Remove the few early incomplete checks now that the helper functions
are in place and used to check for refcount overflow.

Fixes: 96518518cc41 ("netfilter: add nftables")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 1689f25924ada8fe14a4a82c38925d04994c7142)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_immediate.c
diff --cc net/netfilter/nf_tables_api.c
index 00094f01c4f1,86b3c4de7f40..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -204,6 -211,62 +204,65 @@@ static void nft_set_trans_unbind(const 
  	return __nft_set_trans_bind(ctx, set, false);
  }
  
++<<<<<<< HEAD
++=======
+ static void __nft_chain_trans_bind(const struct nft_ctx *ctx,
+ 				   struct nft_chain *chain, bool bind)
+ {
+ 	struct nftables_pernet *nft_net;
+ 	struct net *net = ctx->net;
+ 	struct nft_trans *trans;
+ 
+ 	if (!nft_chain_binding(chain))
+ 		return;
+ 
+ 	nft_net = nft_pernet(net);
+ 	list_for_each_entry_reverse(trans, &nft_net->commit_list, list) {
+ 		switch (trans->msg_type) {
+ 		case NFT_MSG_NEWCHAIN:
+ 			if (nft_trans_chain(trans) == chain)
+ 				nft_trans_chain_bound(trans) = bind;
+ 			break;
+ 		case NFT_MSG_NEWRULE:
+ 			if (trans->ctx.chain == chain)
+ 				nft_trans_rule_bound(trans) = bind;
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static void nft_chain_trans_bind(const struct nft_ctx *ctx,
+ 				 struct nft_chain *chain)
+ {
+ 	__nft_chain_trans_bind(ctx, chain, true);
+ }
+ 
+ int nf_tables_bind_chain(const struct nft_ctx *ctx, struct nft_chain *chain)
+ {
+ 	if (!nft_chain_binding(chain))
+ 		return 0;
+ 
+ 	if (nft_chain_binding(ctx->chain))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (chain->bound)
+ 		return -EBUSY;
+ 
+ 	if (!nft_use_inc(&chain->use))
+ 		return -EMFILE;
+ 
+ 	chain->bound = true;
+ 	nft_chain_trans_bind(ctx, chain);
+ 
+ 	return 0;
+ }
+ 
+ void nf_tables_unbind_chain(const struct nft_ctx *ctx, struct nft_chain *chain)
+ {
+ 	__nft_chain_trans_bind(ctx, chain, false);
+ }
+ 
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  static int nft_netdev_register_hooks(struct net *net,
  				     struct list_head *hook_list)
  {
@@@ -489,8 -642,11 +548,8 @@@ static int nft_delset(const struct nft_
  	if (err < 0)
  		return err;
  
 -	if (set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
 -		nft_map_deactivate(ctx, set);
 -
  	nft_deactivate_next(ctx->net, set);
- 	ctx->table->use--;
+ 	nft_use_dec(&ctx->table->use);
  
  	return err;
  }
@@@ -1999,19 -2392,21 +2058,16 @@@ static int nf_tables_addchain(struct nf
  	struct nft_table *table = ctx->table;
  	struct nft_base_chain *basechain;
  	struct net *net = ctx->net;
 -	char name[NFT_NAME_MAXLEN];
 -	struct nft_rule_blob *blob;
  	struct nft_trans *trans;
  	struct nft_chain *chain;
 +	struct nft_rule **rules;
  	int err;
  
- 	if (table->use == UINT_MAX)
- 		return -EOVERFLOW;
- 
  	if (nla[NFTA_CHAIN_HOOK]) {
  		struct nft_stats __percpu *stats = NULL;
 -		struct nft_chain_hook hook = {};
 +		struct nft_chain_hook hook;
  
 -		if (flags & NFT_CHAIN_BINDING)
 -			return -EOPNOTSUPP;
 -
 -		err = nft_chain_parse_hook(net, NULL, nla, &hook, family, flags,
 -					   extack);
 +		err = nft_chain_parse_hook(net, nla, &hook, family, true);
  		if (err < 0)
  			return err;
  
@@@ -2069,8 -2491,13 +2125,13 @@@
  
  	err = nf_tables_register_hook(net, table, chain);
  	if (err < 0)
 -		goto err_destroy_chain;
 +		goto err1;
  
+ 	if (!nft_use_inc(&table->use)) {
+ 		err = -EMFILE;
+ 		goto err_use;
+ 	}
+ 
  	trans = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);
  	if (IS_ERR(trans)) {
  		err = PTR_ERR(trans);
@@@ -2084,15 -2511,16 +2145,20 @@@
  	err = nft_chain_add(table, chain);
  	if (err < 0) {
  		nft_trans_destroy(trans);
 -		goto err_unregister_hook;
 +		goto err2;
  	}
  
- 	table->use++;
- 
  	return 0;
++<<<<<<< HEAD
 +err2:
++=======
+ 
+ err_unregister_hook:
+ 	nft_use_dec_restore(&table->use);
+ err_use:
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  	nf_tables_unregister_hook(net, table, chain);
 -err_destroy_chain:
 +err1:
  	nf_tables_chain_destroy(ctx);
  
  	return err;
@@@ -3238,7 -3938,16 +3301,20 @@@ static int nf_tables_newrule(struct ne
  		}
  	}
  
++<<<<<<< HEAD
 +	if (nlh->nlmsg_flags & NLM_F_REPLACE) {
++=======
+ 	if (!nft_use_inc(&chain->use)) {
+ 		err = -EMFILE;
+ 		goto err_release_rule;
+ 	}
+ 
+ 	if (info->nlh->nlmsg_flags & NLM_F_REPLACE) {
+ 		err = nft_delrule(&ctx, old_rule);
+ 		if (err < 0)
+ 			goto err_destroy_flow_rule;
+ 
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  		trans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);
  		if (trans == NULL) {
  			err = -ENOMEM;
@@@ -3270,8 -3973,7 +3346,12 @@@
  				list_add_rcu(&rule->list, &chain->rules);
  		}
  	}
++<<<<<<< HEAD
 +	kvfree(info);
 +	chain->use++;
++=======
+ 	kvfree(expr_info);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  
  	if (flow)
  		nft_trans_flow_rule(trans) = flow;
@@@ -3280,7 -3982,9 +3360,8 @@@
  		return nft_table_validate(net, table);
  
  	return 0;
 -
  err_destroy_flow_rule:
+ 	nft_use_dec_restore(&chain->use);
  	if (flow)
  		nft_flow_rule_destroy(flow);
  err_release_rule:
@@@ -4219,14 -5018,20 +4300,29 @@@ static int nf_tables_newset(struct net 
  	size = 0;
  	if (ops->privsize != NULL)
  		size = ops->privsize(nla, &desc);
++<<<<<<< HEAD
++=======
+ 	alloc_size = sizeof(*set) + size + udlen;
+ 	if (alloc_size < size || alloc_size > INT_MAX)
+ 		return -ENOMEM;
+ 
+ 	if (!nft_use_inc(&table->use))
+ 		return -EMFILE;
+ 
+ 	set = kvzalloc(alloc_size, GFP_KERNEL_ACCOUNT);
+ 	if (!set) {
+ 		err = -ENOMEM;
+ 		goto err_alloc;
+ 	}
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
 +
 +	set = kvzalloc(sizeof(*set) + size + udlen, GFP_KERNEL);
 +	if (!set) {
 +		err = -ENOMEM;
 +		goto err1;
 +	}
  
 -	name = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL_ACCOUNT);
 +	name = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);
  	if (!name) {
  		err = -ENOMEM;
  		goto err_set_name;
@@@ -4324,8 -5099,9 +4420,14 @@@ err_set_init
  	kfree(set->name);
  err_set_name:
  	kvfree(set);
++<<<<<<< HEAD
 +err1:
 +	module_put(to_set_type(ops)->owner);
++=======
+ err_alloc:
+ 	nft_use_dec_restore(&table->use);
+ 
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  	return err;
  }
  
@@@ -4403,15 -5203,43 +4505,12 @@@ static int nf_tables_bind_check_setelem
  					   set->dlen);
  }
  
 -static int nf_tables_bind_check_setelem(const struct nft_ctx *ctx,
 -					struct nft_set *set,
 -					const struct nft_set_iter *iter,
 -					struct nft_set_elem *elem)
 +int nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,
 +		       struct nft_set_binding *binding)
  {
 -	return nft_setelem_data_validate(ctx, set, elem);
 -}
 -
 -static int nft_set_catchall_bind_check(const struct nft_ctx *ctx,
 -				       struct nft_set *set)
 -{
 -	u8 genmask = nft_genmask_next(ctx->net);
 -	struct nft_set_elem_catchall *catchall;
 -	struct nft_set_elem elem;
 -	struct nft_set_ext *ext;
 -	int ret = 0;
 -
 -	list_for_each_entry_rcu(catchall, &set->catchall_list, list) {
 -		ext = nft_set_elem_ext(set, catchall->elem);
 -		if (!nft_set_elem_active(ext, genmask))
 -			continue;
 -
 -		elem.priv = catchall->elem;
 -		ret = nft_setelem_data_validate(ctx, set, &elem);
 -		if (ret < 0)
 -			break;
 -	}
 -
 -	return ret;
 -}
 -
 -int nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,
 -		       struct nft_set_binding *binding)
 -{
 -	struct nft_set_binding *i;
 -	struct nft_set_iter iter;
 +	struct nft_set_binding *i;
 +	struct nft_set_iter iter;
  
- 	if (set->use == UINT_MAX)
- 		return -EOVERFLOW;
- 
  	if (!list_empty(&set->bindings) && nft_set_is_anonymous(set))
  		return -EBUSY;
  
@@@ -4461,10 -5339,14 +4562,10 @@@ EXPORT_SYMBOL_GPL(nf_tables_unbind_set)
  
  void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)
  {
 -	if (nft_set_is_anonymous(set)) {
 -		if (set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
 -			nft_map_activate(ctx, set);
 -
 +	if (nft_set_is_anonymous(set))
  		nft_clear(ctx->net, set);
 -	}
  
- 	set->use++;
+ 	nft_use_inc_restore(&set->use);
  }
  EXPORT_SYMBOL_GPL(nf_tables_activate_set);
  
@@@ -4480,18 -5362,25 +4581,32 @@@ void nf_tables_deactivate_set(const str
  		else
  			list_del_rcu(&binding->list);
  
- 		set->use--;
+ 		nft_use_dec(&set->use);
  		break;
  	case NFT_TRANS_PREPARE:
 -		if (nft_set_is_anonymous(set)) {
 -			if (set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
 -				nft_map_deactivate(ctx, set);
 -
 +		if (nft_set_is_anonymous(set))
  			nft_deactivate_next(ctx->net, set);
++<<<<<<< HEAD
 +
 +		set->use--;
 +		return;
 +	case NFT_TRANS_ABORT:
 +	case NFT_TRANS_RELEASE:
 +		set->use--;
 +		/* fall through */
++=======
+ 		}
+ 		nft_use_dec(&set->use);
+ 		return;
+ 	case NFT_TRANS_ABORT:
+ 	case NFT_TRANS_RELEASE:
+ 		if (nft_set_is_anonymous(set) &&
+ 		    set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
+ 			nft_map_deactivate(ctx, set);
+ 
+ 		nft_use_dec(&set->use);
+ 		fallthrough;
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  	default:
  		nf_tables_unbind_set(ctx, set, binding,
  				     phase == NFT_TRANS_COMMIT);
@@@ -5532,7 -6749,15 +5655,14 @@@ static int nft_add_set_elem(struct nft_
  	ext = nft_set_elem_ext(set, elem.priv);
  	if (flags)
  		*nft_set_ext_flags(ext) = flags;
++<<<<<<< HEAD
++=======
+ 
+ 	if (obj)
+ 		*nft_set_ext_obj(ext) = obj;
+ 
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  	if (ulen > 0) {
 -		if (nft_set_ext_check(&tmpl, NFT_SET_EXT_USERDATA, ulen) < 0) {
 -			err = -EINVAL;
 -			goto err_elem_free;
 -		}
  		udata = nft_set_ext_userdata(ext);
  		udata->len = ulen - 1;
  		nla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);
@@@ -5587,18 -6815,18 +5717,25 @@@
  	return 0;
  
  err_set_full:
 -	nft_setelem_remove(ctx->net, set, &elem);
 +	set->ops->remove(ctx->net, set, &elem);
  err_element_clash:
  	kfree(trans);
++<<<<<<< HEAD
 +err_elem_expr:
 +	if (obj)
 +		obj->use--;
 +
++=======
+ err_elem_free:
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  	nf_tables_set_elem_destroy(ctx, set, elem.priv);
  err_parse_data:
  	if (nla[NFTA_SET_ELEM_DATA] != NULL)
 -		nft_data_release(&elem.data.val, desc.type);
 +		nft_data_release(&data, desc.type);
  err_parse_key_end:
+ 	if (obj)
+ 		nft_use_dec_restore(&obj->use);
+ 
  	nft_data_release(&elem.key_end.val, NFT_DATA_VALUE);
  err_parse_key:
  	nft_data_release(&elem.key.val, NFT_DATA_VALUE);
@@@ -5666,7 -6905,8 +5803,12 @@@ void nft_data_hold(const struct nft_dat
  		switch (data->verdict.code) {
  		case NFT_JUMP:
  		case NFT_GOTO:
++<<<<<<< HEAD
 +			data->verdict.chain->use++;
++=======
+ 			chain = data->verdict.chain;
+ 			nft_use_inc_restore(&chain->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			break;
  		}
  	}
@@@ -5681,12 -6921,12 +5823,12 @@@ static void nft_set_elem_activate(cons
  	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
  		nft_data_hold(nft_set_ext_data(ext), set->dtype);
  	if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))
- 		(*nft_set_ext_obj(ext))->use++;
+ 		nft_use_inc_restore(&(*nft_set_ext_obj(ext))->use);
  }
  
 -static void nft_setelem_data_deactivate(const struct net *net,
 -					const struct nft_set *set,
 -					struct nft_set_elem *elem)
 +static void nft_set_elem_deactivate(const struct net *net,
 +				    const struct nft_set *set,
 +				    struct nft_set_elem *elem)
  {
  	const struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);
  
@@@ -6170,11 -7474,16 +6312,16 @@@ static int nf_tables_newobj(struct net 
  		return nf_tables_updobj(&ctx, type, nla[NFTA_OBJ_DATA], obj);
  	}
  
 -	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);
 +	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
  
+ 	if (!nft_use_inc(&table->use))
+ 		return -EMFILE;
+ 
  	type = nft_obj_type_get(net, objtype);
- 	if (IS_ERR(type))
- 		return PTR_ERR(type);
+ 	if (IS_ERR(type)) {
+ 		err = PTR_ERR(type);
+ 		goto err_type;
+ 	}
  
  	obj = nft_obj_init(&ctx, type, nla[NFTA_OBJ_DATA]);
  	if (IS_ERR(obj)) {
@@@ -6197,12 -7514,12 +6344,12 @@@
  	err = rhltable_insert(&nft_objname_ht, &obj->rhlhead,
  			      nft_objname_ht_params);
  	if (err < 0)
 -		goto err_obj_ht;
 +		goto err4;
  
  	list_add_tail_rcu(&obj->list, &table->objects);
- 	table->use++;
+ 
  	return 0;
 -err_obj_ht:
 +err4:
  	/* queued in transaction log */
  	INIT_LIST_HEAD(&obj->list);
  	return err;
@@@ -6212,8 -7531,11 +6359,11 @@@ err2
  	if (obj->ops->destroy)
  		obj->ops->destroy(&ctx, obj);
  	kfree(obj);
 -err_init:
 +err1:
  	module_put(type->owner);
+ err_type:
+ 	nft_use_dec_restore(&table->use);
+ 
  	return err;
  }
  
@@@ -6598,8 -7937,8 +6748,13 @@@ void nf_tables_deactivate_flowtable(con
  	case NFT_TRANS_PREPARE:
  	case NFT_TRANS_ABORT:
  	case NFT_TRANS_RELEASE:
++<<<<<<< HEAD
 +		flowtable->use--;
 +		/* fall through */
++=======
+ 		nft_use_dec(&flowtable->use);
+ 		fallthrough;
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  	default:
  		return;
  	}
@@@ -6825,14 -8284,21 +6980,25 @@@ static int nf_tables_newflowtable(struc
  			return -EEXIST;
  		}
  
 -		nft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);
 -
 -		return nft_flowtable_update(&ctx, info->nlh, flowtable, extack);
 +		return 0;
  	}
  
 -	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);
 +	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
  
++<<<<<<< HEAD
 +	flowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL);
 +	if (!flowtable)
 +		return -ENOMEM;
++=======
+ 	if (!nft_use_inc(&table->use))
+ 		return -EMFILE;
+ 
+ 	flowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL_ACCOUNT);
+ 	if (!flowtable) {
+ 		err = -ENOMEM;
+ 		goto flowtable_alloc;
+ 	}
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  
  	flowtable->table = table;
  	flowtable->handle = nf_tables_alloc_handle(table);
@@@ -7985,14 -9736,23 +8153,31 @@@ static int nf_tables_commit(struct net 
  				nft_flow_rule_destroy(nft_trans_flow_rule(trans));
  			break;
  		case NFT_MSG_NEWSET:
 -			if (nft_trans_set_update(trans)) {
 -				struct nft_set *set = nft_trans_set(trans);
 +			nft_clear(net, nft_trans_set(trans));
 +			/* This avoids hitting -EBUSY when deleting the table
 +			 * from the transaction.
 +			 */
 +			if (nft_set_is_anonymous(nft_trans_set(trans)) &&
 +			    !list_empty(&nft_trans_set(trans)->bindings))
 +				trans->ctx.table->use--;
  
++<<<<<<< HEAD
++=======
+ 				WRITE_ONCE(set->timeout, nft_trans_set_timeout(trans));
+ 				WRITE_ONCE(set->gc_int, nft_trans_set_gc_int(trans));
+ 
+ 				if (nft_trans_set_size(trans))
+ 					WRITE_ONCE(set->size, nft_trans_set_size(trans));
+ 			} else {
+ 				nft_clear(net, nft_trans_set(trans));
+ 				/* This avoids hitting -EBUSY when deleting the table
+ 				 * from the transaction.
+ 				 */
+ 				if (nft_set_is_anonymous(nft_trans_set(trans)) &&
+ 				    !list_empty(&nft_trans_set(trans)->bindings))
+ 					nft_use_dec(&trans->ctx.table->use);
+ 			}
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			nf_tables_set_notify(&trans->ctx, nft_trans_set(trans),
  					     NFT_MSG_NEWSET, GFP_KERNEL);
  			nft_trans_destroy(trans);
@@@ -8144,7 -9977,11 +8329,15 @@@ static int __nf_tables_abort(struct ne
  				kfree(nft_trans_chain_name(trans));
  				nft_trans_destroy(trans);
  			} else {
++<<<<<<< HEAD
 +				trans->ctx.table->use--;
++=======
+ 				if (nft_trans_chain_bound(trans)) {
+ 					nft_trans_destroy(trans);
+ 					break;
+ 				}
+ 				nft_use_dec_restore(&trans->ctx.table->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  				nft_chain_del(trans->ctx.chain);
  				nf_tables_unregister_hook(trans->ctx.net,
  							  trans->ctx.table,
@@@ -8152,12 -9989,22 +8345,31 @@@
  			}
  			break;
  		case NFT_MSG_DELCHAIN:
++<<<<<<< HEAD
 +			trans->ctx.table->use++;
 +			nft_clear(trans->ctx.net, trans->ctx.chain);
 +			nft_trans_destroy(trans);
 +			break;
 +		case NFT_MSG_NEWRULE:
 +			trans->ctx.chain->use--;
++=======
+ 		case NFT_MSG_DESTROYCHAIN:
+ 			if (nft_trans_chain_update(trans)) {
+ 				list_splice(&nft_trans_chain_hooks(trans),
+ 					    &nft_trans_basechain(trans)->hook_list);
+ 			} else {
+ 				nft_use_inc_restore(&trans->ctx.table->use);
+ 				nft_clear(trans->ctx.net, trans->ctx.chain);
+ 			}
+ 			nft_trans_destroy(trans);
+ 			break;
+ 		case NFT_MSG_NEWRULE:
+ 			if (nft_trans_rule_bound(trans)) {
+ 				nft_trans_destroy(trans);
+ 				break;
+ 			}
+ 			nft_use_dec_restore(&trans->ctx.chain->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			list_del_rcu(&nft_trans_rule(trans)->list);
  			nft_rule_expr_deactivate(&trans->ctx,
  						 nft_trans_rule(trans),
@@@ -8166,7 -10013,8 +8378,12 @@@
  				nft_flow_rule_destroy(nft_trans_flow_rule(trans));
  			break;
  		case NFT_MSG_DELRULE:
++<<<<<<< HEAD
 +			trans->ctx.chain->use++;
++=======
+ 		case NFT_MSG_DESTROYRULE:
+ 			nft_use_inc_restore(&trans->ctx.chain->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			nft_clear(trans->ctx.net, nft_trans_rule(trans));
  			nft_rule_expr_activate(&trans->ctx, nft_trans_rule(trans));
  			if (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)
@@@ -8175,7 -10023,11 +8392,15 @@@
  			nft_trans_destroy(trans);
  			break;
  		case NFT_MSG_NEWSET:
++<<<<<<< HEAD
 +			trans->ctx.table->use--;
++=======
+ 			if (nft_trans_set_update(trans)) {
+ 				nft_trans_destroy(trans);
+ 				break;
+ 			}
+ 			nft_use_dec_restore(&trans->ctx.table->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			if (nft_trans_set_bound(trans)) {
  				nft_trans_destroy(trans);
  				break;
@@@ -8183,8 -10035,12 +8408,13 @@@
  			list_del_rcu(&nft_trans_set(trans)->list);
  			break;
  		case NFT_MSG_DELSET:
++<<<<<<< HEAD
 +			trans->ctx.table->use++;
++=======
+ 		case NFT_MSG_DESTROYSET:
+ 			nft_use_inc_restore(&trans->ctx.table->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			nft_clear(trans->ctx.net, nft_trans_set(trans));
 -			if (nft_trans_set(trans)->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
 -				nft_map_activate(&trans->ctx, nft_trans_set(trans));
 -
  			nft_trans_destroy(trans);
  			break;
  		case NFT_MSG_NEWSETELEM:
@@@ -8215,19 -10085,31 +8445,46 @@@
  			}
  			break;
  		case NFT_MSG_DELOBJ:
++<<<<<<< HEAD
 +			trans->ctx.table->use++;
++=======
+ 		case NFT_MSG_DESTROYOBJ:
+ 			nft_use_inc_restore(&trans->ctx.table->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			nft_clear(trans->ctx.net, nft_trans_obj(trans));
  			nft_trans_destroy(trans);
  			break;
  		case NFT_MSG_NEWFLOWTABLE:
++<<<<<<< HEAD
 +			trans->ctx.table->use--;
 +			list_del_rcu(&nft_trans_flowtable(trans)->list);
 +			nft_unregister_flowtable_net_hooks(net,
 +					nft_trans_flowtable(trans));
 +			break;
 +		case NFT_MSG_DELFLOWTABLE:
 +			trans->ctx.table->use++;
 +			nft_clear(trans->ctx.net, nft_trans_flowtable(trans));
++=======
+ 			if (nft_trans_flowtable_update(trans)) {
+ 				nft_unregister_flowtable_net_hooks(net,
+ 						&nft_trans_flowtable_hooks(trans));
+ 			} else {
+ 				nft_use_dec_restore(&trans->ctx.table->use);
+ 				list_del_rcu(&nft_trans_flowtable(trans)->list);
+ 				nft_unregister_flowtable_net_hooks(net,
+ 						&nft_trans_flowtable(trans)->hook_list);
+ 			}
+ 			break;
+ 		case NFT_MSG_DELFLOWTABLE:
+ 		case NFT_MSG_DESTROYFLOWTABLE:
+ 			if (nft_trans_flowtable_update(trans)) {
+ 				list_splice(&nft_trans_flowtable_hooks(trans),
+ 					    &nft_trans_flowtable(trans)->hook_list);
+ 			} else {
+ 				nft_use_inc_restore(&trans->ctx.table->use);
+ 				nft_clear(trans->ctx.net, nft_trans_flowtable(trans));
+ 			}
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  			nft_trans_destroy(trans);
  			break;
  		}
@@@ -8622,8 -10551,14 +8879,17 @@@ static int nft_verdict_init(const struc
  			return PTR_ERR(chain);
  		if (nft_is_base_chain(chain))
  			return -EOPNOTSUPP;
++<<<<<<< HEAD
++=======
+ 		if (nft_chain_is_bound(chain))
+ 			return -EINVAL;
+ 		if (desc->flags & NFT_DATA_DESC_SETELEM &&
+ 		    chain->flags & NFT_CHAIN_BINDING)
+ 			return -EINVAL;
+ 		if (!nft_use_inc(&chain->use))
+ 			return -EMFILE;
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  
- 		chain->use++;
  		data->verdict.chain = chain;
  		break;
  	}
@@@ -8638,7 -10573,10 +8904,12 @@@ static void nft_verdict_uninit(const st
  	switch (data->verdict.code) {
  	case NFT_JUMP:
  	case NFT_GOTO:
++<<<<<<< HEAD
 +		data->verdict.chain->use--;
++=======
+ 		chain = data->verdict.chain;
+ 		nft_use_dec(&chain->use);
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  		break;
  	}
  }
@@@ -8836,52 -10793,116 +9107,101 @@@ static void __nft_release_tables(struc
  		.family	= NFPROTO_NETDEV,
  	};
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(table, nt, &net->nft.tables, list) {
 +		ctx.family = table->family;
 +		ctx.table = table;
 +		list_for_each_entry(chain, &table->chains, list) {
 +			ctx.chain = chain;
 +			list_for_each_entry_safe(rule, nr, &chain->rules, list) {
 +				list_del(&rule->list);
 +				chain->use--;
 +				nf_tables_rule_release(&ctx, rule);
 +			}
 +		}
 +		list_for_each_entry_safe(flowtable, nf, &table->flowtables, list) {
 +			list_del(&flowtable->list);
 +			table->use--;
 +			nf_tables_flowtable_destroy(flowtable);
 +		}
 +		list_for_each_entry_safe(set, ns, &table->sets, list) {
 +			list_del(&set->list);
 +			table->use--;
 +			nft_set_destroy(&ctx, set);
 +		}
 +		list_for_each_entry_safe(obj, ne, &table->objects, list) {
 +			nft_obj_del(obj);
 +			table->use--;
 +			nft_obj_destroy(&ctx, obj);
 +		}
 +		list_for_each_entry_safe(chain, nc, &table->chains, list) {
 +			ctx.chain = chain;
 +			nft_chain_del(chain);
 +			table->use--;
 +			nf_tables_chain_destroy(&ctx);
 +		}
++=======
+ 	ctx.family = table->family;
+ 	ctx.table = table;
+ 	list_for_each_entry(chain, &table->chains, list) {
+ 		ctx.chain = chain;
+ 		list_for_each_entry_safe(rule, nr, &chain->rules, list) {
+ 			list_del(&rule->list);
+ 			nft_use_dec(&chain->use);
+ 			nf_tables_rule_release(&ctx, rule);
+ 		}
+ 	}
+ 	list_for_each_entry_safe(flowtable, nf, &table->flowtables, list) {
+ 		list_del(&flowtable->list);
+ 		nft_use_dec(&table->use);
+ 		nf_tables_flowtable_destroy(flowtable);
+ 	}
+ 	list_for_each_entry_safe(set, ns, &table->sets, list) {
+ 		list_del(&set->list);
+ 		nft_use_dec(&table->use);
+ 		if (set->flags & (NFT_SET_MAP | NFT_SET_OBJECT))
+ 			nft_map_deactivate(&ctx, set);
+ 
+ 		nft_set_destroy(&ctx, set);
+ 	}
+ 	list_for_each_entry_safe(obj, ne, &table->objects, list) {
+ 		nft_obj_del(obj);
+ 		nft_use_dec(&table->use);
+ 		nft_obj_destroy(&ctx, obj);
+ 	}
+ 	list_for_each_entry_safe(chain, nc, &table->chains, list) {
+ 		ctx.chain = chain;
+ 		nft_chain_del(chain);
+ 		nft_use_dec(&table->use);
+ 		nf_tables_chain_destroy(&ctx);
+ 	}
+ 	nf_tables_table_destroy(&ctx);
+ }
+ 
+ static void __nft_release_tables(struct net *net)
+ {
+ 	struct nftables_pernet *nft_net = nft_pernet(net);
+ 	struct nft_table *table, *nt;
+ 
+ 	list_for_each_entry_safe(table, nt, &nft_net->tables, list) {
+ 		if (nft_table_has_owner(table))
+ 			continue;
+ 
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  		list_del(&table->list);
 -
 -		__nft_release_table(net, table);
 -	}
 -}
 -
 -static int nft_rcv_nl_event(struct notifier_block *this, unsigned long event,
 -			    void *ptr)
 -{
 -	struct nft_table *table, *to_delete[8];
 -	struct nftables_pernet *nft_net;
 -	struct netlink_notify *n = ptr;
 -	struct net *net = n->net;
 -	unsigned int deleted;
 -	bool restart = false;
 -
 -	if (event != NETLINK_URELEASE || n->protocol != NETLINK_NETFILTER)
 -		return NOTIFY_DONE;
 -
 -	nft_net = nft_pernet(net);
 -	deleted = 0;
 -	mutex_lock(&nft_net->commit_mutex);
 -	if (!list_empty(&nf_tables_destroy_list))
 -		rcu_barrier();
 -again:
 -	list_for_each_entry(table, &nft_net->tables, list) {
 -		if (nft_table_has_owner(table) &&
 -		    n->portid == table->nlpid) {
 -			__nft_release_hook(net, table);
 -			list_del_rcu(&table->list);
 -			to_delete[deleted++] = table;
 -			if (deleted >= ARRAY_SIZE(to_delete))
 -				break;
 -		}
 -	}
 -	if (deleted) {
 -		restart = deleted >= ARRAY_SIZE(to_delete);
 -		synchronize_rcu();
 -		while (deleted)
 -			__nft_release_table(net, to_delete[--deleted]);
 -
 -		if (restart)
 -			goto again;
 +		nf_tables_table_destroy(&ctx);
  	}
 -	mutex_unlock(&nft_net->commit_mutex);
 -
 -	return NOTIFY_DONE;
  }
  
 -static struct notifier_block nft_nl_notifier = {
 -	.notifier_call  = nft_rcv_nl_event,
 -};
 -
  static int __net_init nf_tables_init_net(struct net *net)
  {
 -	struct nftables_pernet *nft_net = nft_pernet(net);
 -
 -	INIT_LIST_HEAD(&nft_net->tables);
 -	INIT_LIST_HEAD(&nft_net->commit_list);
 -	INIT_LIST_HEAD(&nft_net->binding_list);
 -	INIT_LIST_HEAD(&nft_net->module_list);
 -	INIT_LIST_HEAD(&nft_net->notify_list);
 -	mutex_init(&nft_net->commit_mutex);
 -	nft_net->base_seq = 1;
 +	INIT_LIST_HEAD(&net->nft.tables);
 +	INIT_LIST_HEAD(&net->nft.commit_list);
 +	INIT_LIST_HEAD(&net->nft_module_list);
 +	INIT_LIST_HEAD(&net->nft_notify_list);
 +	mutex_init(&net->nft_commit_mutex);
 +	net->nft.base_seq = 1;
 +	net->nft.validate_state = NFT_VALIDATE_SKIP;
  
  	return 0;
  }
diff --cc net/netfilter/nft_immediate.c
index 0e14b4367e37,407d7197f75b..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -77,6 -130,43 +77,46 @@@ static void nft_immediate_deactivate(co
  				     enum nft_trans_phase phase)
  {
  	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
++=======
+ 	const struct nft_data *data = &priv->data;
+ 	struct nft_ctx chain_ctx;
+ 	struct nft_chain *chain;
+ 	struct nft_rule *rule;
+ 
+ 	if (priv->dreg == NFT_REG_VERDICT) {
+ 		switch (data->verdict.code) {
+ 		case NFT_JUMP:
+ 		case NFT_GOTO:
+ 			chain = data->verdict.chain;
+ 			if (!nft_chain_binding(chain))
+ 				break;
+ 
+ 			chain_ctx = *ctx;
+ 			chain_ctx.chain = chain;
+ 
+ 			list_for_each_entry(rule, &chain->rules, list)
+ 				nft_rule_expr_deactivate(&chain_ctx, rule, phase);
+ 
+ 			switch (phase) {
+ 			case NFT_TRANS_PREPARE_ERROR:
+ 				nf_tables_unbind_chain(ctx, chain);
+ 				fallthrough;
+ 			case NFT_TRANS_PREPARE:
+ 				nft_deactivate_next(ctx->net, chain);
+ 				break;
+ 			default:
+ 				nft_chain_del(chain);
+ 				chain->bound = false;
+ 				nft_use_dec(&chain->table->use);
+ 				break;
+ 			}
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  
  	if (phase == NFT_TRANS_COMMIT)
  		return;
@@@ -84,7 -174,53 +124,57 @@@
  	return nft_data_release(&priv->data, nft_dreg_to_type(priv->dreg));
  }
  
++<<<<<<< HEAD
 +static int nft_immediate_dump(struct sk_buff *skb, const struct nft_expr *expr)
++=======
+ static void nft_immediate_destroy(const struct nft_ctx *ctx,
+ 				  const struct nft_expr *expr)
+ {
+ 	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
+ 	const struct nft_data *data = &priv->data;
+ 	struct nft_rule *rule, *n;
+ 	struct nft_ctx chain_ctx;
+ 	struct nft_chain *chain;
+ 
+ 	if (priv->dreg != NFT_REG_VERDICT)
+ 		return;
+ 
+ 	switch (data->verdict.code) {
+ 	case NFT_JUMP:
+ 	case NFT_GOTO:
+ 		chain = data->verdict.chain;
+ 
+ 		if (!nft_chain_binding(chain))
+ 			break;
+ 
+ 		/* Rule construction failed, but chain is already bound:
+ 		 * let the transaction records release this chain and its rules.
+ 		 */
+ 		if (chain->bound) {
+ 			nft_use_dec(&chain->use);
+ 			break;
+ 		}
+ 
+ 		/* Rule has been deleted, release chain and its rules. */
+ 		chain_ctx = *ctx;
+ 		chain_ctx.chain = chain;
+ 
+ 		nft_use_dec(&chain->use);
+ 		list_for_each_entry_safe(rule, n, &chain->rules, list) {
+ 			nft_use_dec(&chain->use);
+ 			list_del(&rule->list);
+ 			nf_tables_rule_destroy(&chain_ctx, rule);
+ 		}
+ 		nf_tables_chain_destroy(&chain_ctx);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static int nft_immediate_dump(struct sk_buff *skb,
+ 			      const struct nft_expr *expr, bool reset)
++>>>>>>> 1689f25924ad (netfilter: nf_tables: report use refcount overflow)
  {
  	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
  
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index afd104d4fe75..90089652f154 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -1076,6 +1076,29 @@ int __nft_release_basechain(struct nft_ctx *ctx);
 
 unsigned int nft_do_chain(struct nft_pktinfo *pkt, void *priv);
 
+static inline bool nft_use_inc(u32 *use)
+{
+	if (*use == UINT_MAX)
+		return false;
+
+	(*use)++;
+
+	return true;
+}
+
+static inline void nft_use_dec(u32 *use)
+{
+	WARN_ON_ONCE((*use)-- == 0);
+}
+
+/* For error and abort path: restore use counter to previous state. */
+static inline void nft_use_inc_restore(u32 *use)
+{
+	WARN_ON_ONCE(!nft_use_inc(use));
+}
+
+#define nft_use_dec_restore	nft_use_dec
+
 /**
  *	struct nft_table - nf_tables table
  *
@@ -1145,8 +1168,8 @@ struct nft_object {
 	struct list_head		list;
 	struct rhlist_head		rhlhead;
 	struct nft_object_hash_key	key;
-	u32				genmask:2,
-					use:30;
+	u32				genmask:2;
+	u32				use;
 	u64				handle;
 	/* runtime data below here */
 	const struct nft_object_ops	*ops ____cacheline_aligned;
@@ -1246,8 +1269,8 @@ struct nft_flowtable {
 	char				*name;
 	int				hooknum;
 	int				ops_len;
-	u32				genmask:2,
-					use:30;
+	u32				genmask:2;
+	u32				use;
 	u64				handle;
 	/* runtime data below here */
 	struct list_head		hook_list ____cacheline_aligned;
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_flow_offload.c b/net/netfilter/nft_flow_offload.c
index 5aac5c994c8f..66619fd61ae7 100644
--- a/net/netfilter/nft_flow_offload.c
+++ b/net/netfilter/nft_flow_offload.c
@@ -169,8 +169,10 @@ static int nft_flow_offload_init(const struct nft_ctx *ctx,
 	if (IS_ERR(flowtable))
 		return PTR_ERR(flowtable);
 
+	if (!nft_use_inc(&flowtable->use))
+		return -EMFILE;
+
 	priv->flowtable = flowtable;
-	flowtable->use++;
 
 	return nf_ct_netns_get(ctx->net, ctx->family);
 }
@@ -189,7 +191,7 @@ static void nft_flow_offload_activate(const struct nft_ctx *ctx,
 {
 	struct nft_flow_offload *priv = nft_expr_priv(expr);
 
-	priv->flowtable->use++;
+	nft_use_inc_restore(&priv->flowtable->use);
 }
 
 static void nft_flow_offload_destroy(const struct nft_ctx *ctx,
* Unmerged path net/netfilter/nft_immediate.c
diff --git a/net/netfilter/nft_objref.c b/net/netfilter/nft_objref.c
index 54e0f94498da..b04f92607f66 100644
--- a/net/netfilter/nft_objref.c
+++ b/net/netfilter/nft_objref.c
@@ -44,8 +44,10 @@ static int nft_objref_init(const struct nft_ctx *ctx,
 	if (IS_ERR(obj))
 		return -ENOENT;
 
+	if (!nft_use_inc(&obj->use))
+		return -EMFILE;
+
 	nft_objref_priv(expr) = obj;
-	obj->use++;
 
 	return 0;
 }
@@ -74,7 +76,7 @@ static void nft_objref_deactivate(const struct nft_ctx *ctx,
 	if (phase == NFT_TRANS_COMMIT)
 		return;
 
-	obj->use--;
+	nft_use_dec(&obj->use);
 }
 
 static void nft_objref_activate(const struct nft_ctx *ctx,
@@ -82,7 +84,7 @@ static void nft_objref_activate(const struct nft_ctx *ctx,
 {
 	struct nft_object *obj = nft_objref_priv(expr);
 
-	obj->use++;
+	nft_use_inc_restore(&obj->use);
 }
 
 static struct nft_expr_type nft_objref_type;
