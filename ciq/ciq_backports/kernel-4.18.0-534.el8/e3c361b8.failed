netfilter: nf_tables: fix nft_trans type confusion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-534.el8
commit-author Florian Westphal <fw@strlen.de>
commit e3c361b8acd636f5fe80c02849ca175201edf10c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-534.el8/e3c361b8.failed

nft_trans_FOO objects all share a common nft_trans base structure, but
trailing fields depend on the real object size. Access is only safe after
trans->msg_type check.

Check for rule type first.  Found by code inspection.

Fixes: 1a94e38d254b ("netfilter: nf_tables: add NFTA_RULE_ID attribute")
	Signed-off-by: Florian Westphal <fw@strlen.de>
(cherry picked from commit e3c361b8acd636f5fe80c02849ca175201edf10c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 65617e020aff,dc5675962de4..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3305,9 -3863,8 +3305,13 @@@ static struct nft_rule *nft_rule_lookup
  	u32 id = ntohl(nla_get_be32(nla));
  	struct nft_trans *trans;
  
++<<<<<<< HEAD
 +	list_for_each_entry(trans, &net->nft.commit_list, list) {
 +		struct nft_rule *rule = nft_trans_rule(trans);
 +
++=======
+ 	list_for_each_entry(trans, &nft_net->commit_list, list) {
++>>>>>>> e3c361b8acd6 (netfilter: nf_tables: fix nft_trans type confusion)
  		if (trans->msg_type == NFT_MSG_NEWRULE &&
  		    trans->ctx.chain == chain &&
  		    id == nft_trans_rule_id(trans))
* Unmerged path net/netfilter/nf_tables_api.c
