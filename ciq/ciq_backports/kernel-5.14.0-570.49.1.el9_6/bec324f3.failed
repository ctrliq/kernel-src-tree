ceph: fix race condition where r_parent becomes stale before sending message

jira LE-4311
Rebuild_History Non-Buildable kernel-5.14.0-570.49.1.el9_6
Rebuild_CHGLOG: - ceph: fix client race condition where r_parent becomes stale before sending message (Alex Markuze) [RHEL-114962]
Rebuild_FUZZ: 95.60%
commit-author Alex Markuze <amarkuze@redhat.com>
commit bec324f33d1ed346394b2eee25bf6dbf3511f727
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.49.1.el9_6/bec324f3.failed

When the parent directory's i_rwsem is not locked, req->r_parent may become
stale due to concurrent operations (e.g. rename) between dentry lookup and
message creation. Validate that r_parent matches the encoded parent inode
and update to the correct inode if a mismatch is detected.

[ idryomov: folded a follow-up fix from Alex to drop extra reference
  from ceph_get_reply_dir() in ceph_fill_trace():

  ceph_get_reply_dir() may return a different, referenced inode when
  r_parent is stale and the parent directory lock is not held.
  ceph_fill_trace() used that inode but failed to drop the reference
  when it differed from req->r_parent, leaking an inode reference.

  Keep the directory inode in a local variable and iput() it at
  function end if it does not match req->r_parent. ]

	Cc: stable@vger.kernel.org
	Signed-off-by: Alex Markuze <amarkuze@redhat.com>
	Reviewed-by: Viacheslav Dubeyko <Slava.Dubeyko@ibm.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit bec324f33d1ed346394b2eee25bf6dbf3511f727)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/inode.c
diff --cc fs/ceph/inode.c
index 34cfeb0fba9e,f67025465de0..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -1488,14 -1567,16 +1534,20 @@@ int ceph_fill_trace(struct super_block 
  	struct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;
  	struct inode *in = NULL;
  	struct ceph_vino tvino, dvino;
++<<<<<<< HEAD
 +	struct ceph_fs_client *fsc = ceph_sb_to_client(sb);
++=======
+ 	struct ceph_fs_client *fsc = ceph_sb_to_fs_client(sb);
+ 	struct ceph_client *cl = fsc->client;
+ 	struct inode *parent_dir = NULL;
++>>>>>>> bec324f33d1e (ceph: fix race condition where r_parent becomes stale before sending message)
  	int err = 0;
  
 -	doutc(cl, "%p is_dentry %d is_target %d\n", req,
 -	      rinfo->head->is_dentry, rinfo->head->is_target);
 +	dout("fill_trace %p is_dentry %d is_target %d\n", req,
 +	     rinfo->head->is_dentry, rinfo->head->is_target);
  
  	if (!rinfo->head->is_target && !rinfo->head->is_dentry) {
 -		doutc(cl, "reply is empty!\n");
 +		dout("fill_trace reply is empty!\n");
  		if (rinfo->head->result == 0 && req->r_parent)
  			ceph_invalidate_dir_request(req);
  		return 0;
@@@ -1557,11 -1645,11 +1616,11 @@@ retry_lookup
  
  			if (!dn) {
  				dn = d_alloc(parent, &dname);
 -				doutc(cl, "d_alloc %p '%.*s' = %p\n", parent,
 -				      dname.len, dname.name, dn);
 +				dout("d_alloc %p '%.*s' = %p\n", parent,
 +				     dname.len, dname.name, dn);
  				if (!dn) {
  					dput(parent);
- 					ceph_fname_free_buffer(dir, &oname);
+ 					ceph_fname_free_buffer(parent_dir, &oname);
  					err = -ENOMEM;
  					goto done;
  				}
@@@ -1574,9 -1662,9 +1633,15 @@@
  			} else if (d_really_is_positive(dn) &&
  				   (ceph_ino(d_inode(dn)) != tvino.ino ||
  				    ceph_snap(d_inode(dn)) != tvino.snap)) {
++<<<<<<< HEAD
 +				dout(" dn %p points to wrong inode %p\n",
 +				     dn, d_inode(dn));
 +				ceph_dir_clear_ordered(dir);
++=======
+ 				doutc(cl, " dn %p points to wrong inode %p\n",
+ 				      dn, d_inode(dn));
+ 				ceph_dir_clear_ordered(parent_dir);
++>>>>>>> bec324f33d1e (ceph: fix race condition where r_parent becomes stale before sending message)
  				d_delete(dn);
  				dput(dn);
  				goto retry_lookup;
@@@ -1763,7 -1848,10 +1828,14 @@@
  					    &dvino, ptvino);
  	}
  done:
++<<<<<<< HEAD
 +	dout("fill_trace done err=%d\n", err);
++=======
+ 	/* Drop extra ref from ceph_get_reply_dir() if it returned a new inode */
+ 	if (unlikely(!IS_ERR_OR_NULL(parent_dir) && parent_dir != req->r_parent))
+ 		iput(parent_dir);
+ 	doutc(cl, "done err=%d\n", err);
++>>>>>>> bec324f33d1e (ceph: fix race condition where r_parent becomes stale before sending message)
  	return err;
  }
  
* Unmerged path fs/ceph/inode.c
