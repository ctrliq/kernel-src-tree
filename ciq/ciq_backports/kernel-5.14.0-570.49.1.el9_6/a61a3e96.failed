selftests: tls: add tests for zero-length records

jira LE-4311
cve CVE-2025-39682
Rebuild_History Non-Buildable kernel-5.14.0-570.49.1.el9_6
commit-author Jakub Kicinski <kuba@kernel.org>
commit a61a3e961baff65b0a49f862fe21ce304f279b24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.49.1.el9_6/a61a3e96.failed

Test various combinations of zero-length records.
Unfortunately, kernel cannot be coerced into producing those,
so hardcode the ciphertext messages in the test.

	Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Link: https://patch.msgid.link/20250820021952.143068-2-kuba@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit a61a3e961baff65b0a49f862fe21ce304f279b24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/net/tls.c
diff --cc tools/testing/selftests/net/tls.c
index 6f573be09e01,0f5640d8dc7f..000000000000
--- a/tools/testing/selftests/net/tls.c
+++ b/tools/testing/selftests/net/tls.c
@@@ -1599,6 -1682,778 +1611,781 @@@ TEST_F(tls, recv_efault
  		EXPECT_EQ(memcmp(rec2, recv_mem + 9, ret - 9), 0);
  }
  
++<<<<<<< HEAD
++=======
+ #define TLS_RECORD_TYPE_HANDSHAKE      0x16
+ /* key_update, length 1, update_not_requested */
+ static const char key_update_msg[] = "\x18\x00\x00\x01\x00";
+ static void tls_send_keyupdate(struct __test_metadata *_metadata, int fd)
+ {
+ 	size_t len = sizeof(key_update_msg);
+ 
+ 	EXPECT_EQ(tls_send_cmsg(fd, TLS_RECORD_TYPE_HANDSHAKE,
+ 				(char *)key_update_msg, len, 0),
+ 		  len);
+ }
+ 
+ static void tls_recv_keyupdate(struct __test_metadata *_metadata, int fd, int flags)
+ {
+ 	char buf[100];
+ 
+ 	EXPECT_EQ(tls_recv_cmsg(_metadata, fd, TLS_RECORD_TYPE_HANDSHAKE, buf, sizeof(buf), flags),
+ 		  sizeof(key_update_msg));
+ 	EXPECT_EQ(memcmp(buf, key_update_msg, sizeof(key_update_msg)), 0);
+ }
+ 
+ /* set the key to 0 then 1 for RX, immediately to 1 for TX */
+ TEST_F(tls_basic, rekey_rx)
+ {
+ 	struct tls_crypto_info_keys tls12_0, tls12_1;
+ 	char const *test_str = "test_message";
+ 	int send_len = strlen(test_str) + 1;
+ 	char buf[20];
+ 	int ret;
+ 
+ 	if (self->notls)
+ 		return;
+ 
+ 	tls_crypto_info_init(TLS_1_3_VERSION, TLS_CIPHER_AES_GCM_128,
+ 			     &tls12_0, 0);
+ 	tls_crypto_info_init(TLS_1_3_VERSION, TLS_CIPHER_AES_GCM_128,
+ 			     &tls12_1, 1);
+ 
+ 	ret = setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12_1, tls12_1.len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12_0, tls12_0.len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12_1, tls12_1.len);
+ 	EXPECT_EQ(ret, 0);
+ 
+ 	EXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str, send_len), 0);
+ }
+ 
+ /* set the key to 0 then 1 for TX, immediately to 1 for RX */
+ TEST_F(tls_basic, rekey_tx)
+ {
+ 	struct tls_crypto_info_keys tls12_0, tls12_1;
+ 	char const *test_str = "test_message";
+ 	int send_len = strlen(test_str) + 1;
+ 	char buf[20];
+ 	int ret;
+ 
+ 	if (self->notls)
+ 		return;
+ 
+ 	tls_crypto_info_init(TLS_1_3_VERSION, TLS_CIPHER_AES_GCM_128,
+ 			     &tls12_0, 0);
+ 	tls_crypto_info_init(TLS_1_3_VERSION, TLS_CIPHER_AES_GCM_128,
+ 			     &tls12_1, 1);
+ 
+ 	ret = setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12_0, tls12_0.len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12_1, tls12_1.len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12_1, tls12_1.len);
+ 	EXPECT_EQ(ret, 0);
+ 
+ 	EXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str, send_len), 0);
+ }
+ 
+ TEST_F(tls_basic, disconnect)
+ {
+ 	char const *test_str = "test_message";
+ 	int send_len = strlen(test_str) + 1;
+ 	struct tls_crypto_info_keys key;
+ 	struct sockaddr_in addr;
+ 	char buf[20];
+ 	int ret;
+ 
+ 	if (self->notls)
+ 		return;
+ 
+ 	tls_crypto_info_init(TLS_1_3_VERSION, TLS_CIPHER_AES_GCM_128,
+ 			     &key, 0);
+ 
+ 	ret = setsockopt(self->fd, SOL_TLS, TLS_TX, &key, key.len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	/* Pre-queue the data so that setsockopt parses it but doesn't
+ 	 * dequeue it from the TCP socket. recvmsg would dequeue.
+ 	 */
+ 	EXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);
+ 
+ 	ret = setsockopt(self->cfd, SOL_TLS, TLS_RX, &key, key.len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	addr.sin_family = AF_UNSPEC;
+ 	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+ 	addr.sin_port = 0;
+ 	ret = connect(self->cfd, &addr, sizeof(addr));
+ 	EXPECT_EQ(ret, -1);
+ 	EXPECT_EQ(errno, EOPNOTSUPP);
+ 
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);
+ }
+ 
+ TEST_F(tls, rekey)
+ {
+ 	char const *test_str_1 = "test_message_before_rekey";
+ 	char const *test_str_2 = "test_message_after_rekey";
+ 	struct tls_crypto_info_keys tls12;
+ 	int send_len;
+ 	char buf[100];
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	/* initial send/recv */
+ 	send_len = strlen(test_str_1) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_1, send_len, 0), send_len);
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str_1, send_len), 0);
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	/* send after rekey */
+ 	send_len = strlen(test_str_2) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_2, send_len, 0), send_len);
+ 
+ 	/* can't receive the KeyUpdate without a control message */
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), -1);
+ 
+ 	/* get KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 
+ 	/* recv blocking -> -EKEYEXPIRED */
+ 	EXPECT_EQ(recv(self->cfd, buf, sizeof(buf), 0), -1);
+ 	EXPECT_EQ(errno, EKEYEXPIRED);
+ 
+ 	/* recv non-blocking -> -EKEYEXPIRED */
+ 	EXPECT_EQ(recv(self->cfd, buf, sizeof(buf), MSG_DONTWAIT), -1);
+ 	EXPECT_EQ(errno, EKEYEXPIRED);
+ 
+ 	/* update RX key */
+ 	EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ 
+ 	/* recv after rekey */
+ 	EXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);
+ 	EXPECT_EQ(memcmp(buf, test_str_2, send_len), 0);
+ }
+ 
+ TEST_F(tls, rekey_fail)
+ {
+ 	char const *test_str_1 = "test_message_before_rekey";
+ 	char const *test_str_2 = "test_message_after_rekey";
+ 	struct tls_crypto_info_keys tls12;
+ 	int send_len;
+ 	char buf[100];
+ 
+ 	/* initial send/recv */
+ 	send_len = strlen(test_str_1) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_1, send_len, 0), send_len);
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str_1, send_len), 0);
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION) {
+ 		/* just check that rekey is not supported and return */
+ 		tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 		EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), -1);
+ 		EXPECT_EQ(errno, EBUSY);
+ 		return;
+ 	}
+ 
+ 	/* successful update */
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	/* invalid update: change of version */
+ 	tls_crypto_info_init(TLS_1_2_VERSION, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	/* invalid update (RX socket): change of version */
+ 	tls_crypto_info_init(TLS_1_2_VERSION, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	/* invalid update: change of cipher */
+ 	if (variant->cipher_type == TLS_CIPHER_AES_GCM_256)
+ 		tls_crypto_info_init(variant->tls_version, TLS_CIPHER_CHACHA20_POLY1305, &tls12, 1);
+ 	else
+ 		tls_crypto_info_init(variant->tls_version, TLS_CIPHER_AES_GCM_256, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	/* send after rekey, the invalid updates shouldn't have an effect */
+ 	send_len = strlen(test_str_2) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_2, send_len, 0), send_len);
+ 
+ 	/* can't receive the KeyUpdate without a control message */
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), -1);
+ 
+ 	/* get KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 
+ 	/* recv blocking -> -EKEYEXPIRED */
+ 	EXPECT_EQ(recv(self->cfd, buf, sizeof(buf), 0), -1);
+ 	EXPECT_EQ(errno, EKEYEXPIRED);
+ 
+ 	/* recv non-blocking -> -EKEYEXPIRED */
+ 	EXPECT_EQ(recv(self->cfd, buf, sizeof(buf), MSG_DONTWAIT), -1);
+ 	EXPECT_EQ(errno, EKEYEXPIRED);
+ 
+ 	/* update RX key */
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ 
+ 	/* recv after rekey */
+ 	EXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);
+ 	EXPECT_EQ(memcmp(buf, test_str_2, send_len), 0);
+ }
+ 
+ TEST_F(tls, rekey_peek)
+ {
+ 	char const *test_str_1 = "test_message_before_rekey";
+ 	struct tls_crypto_info_keys tls12;
+ 	int send_len;
+ 	char buf[100];
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	send_len = strlen(test_str_1) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_1, send_len, 0), send_len);
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	EXPECT_EQ(recv(self->cfd, buf, sizeof(buf), MSG_PEEK), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str_1, send_len), 0);
+ 
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str_1, send_len), 0);
+ 
+ 	/* can't receive the KeyUpdate without a control message */
+ 	EXPECT_EQ(recv(self->cfd, buf, send_len, MSG_PEEK), -1);
+ 
+ 	/* peek KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, MSG_PEEK);
+ 
+ 	/* get KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 
+ 	/* update RX key */
+ 	EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ }
+ 
+ TEST_F(tls, splice_rekey)
+ {
+ 	int send_len = TLS_PAYLOAD_MAX_LEN / 2;
+ 	char mem_send[TLS_PAYLOAD_MAX_LEN];
+ 	char mem_recv[TLS_PAYLOAD_MAX_LEN];
+ 	struct tls_crypto_info_keys tls12;
+ 	int p[2];
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	memrnd(mem_send, sizeof(mem_send));
+ 
+ 	ASSERT_GE(pipe(p), 0);
+ 	EXPECT_EQ(send(self->fd, mem_send, send_len, 0), send_len);
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	EXPECT_EQ(send(self->fd, mem_send, send_len, 0), send_len);
+ 
+ 	EXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, TLS_PAYLOAD_MAX_LEN, 0), send_len);
+ 	EXPECT_EQ(read(p[0], mem_recv, send_len), send_len);
+ 	EXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);
+ 
+ 	/* can't splice the KeyUpdate */
+ 	EXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, TLS_PAYLOAD_MAX_LEN, 0), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	/* peek KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, MSG_PEEK);
+ 
+ 	/* get KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 
+ 	/* can't splice before updating the key */
+ 	EXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, TLS_PAYLOAD_MAX_LEN, 0), -1);
+ 	EXPECT_EQ(errno, EKEYEXPIRED);
+ 
+ 	/* update RX key */
+ 	EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ 
+ 	EXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, TLS_PAYLOAD_MAX_LEN, 0), send_len);
+ 	EXPECT_EQ(read(p[0], mem_recv, send_len), send_len);
+ 	EXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);
+ }
+ 
+ TEST_F(tls, rekey_peek_splice)
+ {
+ 	char const *test_str_1 = "test_message_before_rekey";
+ 	struct tls_crypto_info_keys tls12;
+ 	int send_len;
+ 	char buf[100];
+ 	char mem_recv[TLS_PAYLOAD_MAX_LEN];
+ 	int p[2];
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	ASSERT_GE(pipe(p), 0);
+ 
+ 	send_len = strlen(test_str_1) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_1, send_len, 0), send_len);
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	EXPECT_EQ(recv(self->cfd, buf, sizeof(buf), MSG_PEEK), send_len);
+ 	EXPECT_EQ(memcmp(buf, test_str_1, send_len), 0);
+ 
+ 	EXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, TLS_PAYLOAD_MAX_LEN, 0), send_len);
+ 	EXPECT_EQ(read(p[0], mem_recv, send_len), send_len);
+ 	EXPECT_EQ(memcmp(mem_recv, test_str_1, send_len), 0);
+ }
+ 
+ TEST_F(tls, rekey_getsockopt)
+ {
+ 	struct tls_crypto_info_keys tls12;
+ 	struct tls_crypto_info_keys tls12_get;
+ 	socklen_t len;
+ 
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 0);
+ 
+ 	len = tls12.len;
+ 	EXPECT_EQ(getsockopt(self->fd, SOL_TLS, TLS_TX, &tls12_get, &len), 0);
+ 	EXPECT_EQ(len, tls12.len);
+ 	EXPECT_EQ(memcmp(&tls12_get, &tls12, tls12.len), 0);
+ 
+ 	len = tls12.len;
+ 	EXPECT_EQ(getsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12_get, &len), 0);
+ 	EXPECT_EQ(len, tls12.len);
+ 	EXPECT_EQ(memcmp(&tls12_get, &tls12, tls12.len), 0);
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 	EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ 
+ 	len = tls12.len;
+ 	EXPECT_EQ(getsockopt(self->fd, SOL_TLS, TLS_TX, &tls12_get, &len), 0);
+ 	EXPECT_EQ(len, tls12.len);
+ 	EXPECT_EQ(memcmp(&tls12_get, &tls12, tls12.len), 0);
+ 
+ 	len = tls12.len;
+ 	EXPECT_EQ(getsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12_get, &len), 0);
+ 	EXPECT_EQ(len, tls12.len);
+ 	EXPECT_EQ(memcmp(&tls12_get, &tls12, tls12.len), 0);
+ }
+ 
+ TEST_F(tls, rekey_poll_pending)
+ {
+ 	char const *test_str = "test_message_after_rekey";
+ 	struct tls_crypto_info_keys tls12;
+ 	struct pollfd pfd = { };
+ 	int send_len;
+ 	int ret;
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	/* get KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 
+ 	/* send immediately after rekey */
+ 	send_len = strlen(test_str) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);
+ 
+ 	/* key hasn't been updated, expect cfd to be non-readable */
+ 	pfd.fd = self->cfd;
+ 	pfd.events = POLLIN;
+ 	EXPECT_EQ(poll(&pfd, 1, 0), 0);
+ 
+ 	ret = fork();
+ 	ASSERT_GE(ret, 0);
+ 
+ 	if (ret) {
+ 		int pid2, status;
+ 
+ 		/* wait before installing the new key */
+ 		sleep(1);
+ 
+ 		/* update RX key while poll() is sleeping */
+ 		EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ 
+ 		pid2 = wait(&status);
+ 		EXPECT_EQ(pid2, ret);
+ 		EXPECT_EQ(status, 0);
+ 	} else {
+ 		pfd.fd = self->cfd;
+ 		pfd.events = POLLIN;
+ 		EXPECT_EQ(poll(&pfd, 1, 5000), 1);
+ 
+ 		exit(!__test_passed(_metadata));
+ 	}
+ }
+ 
+ TEST_F(tls, rekey_poll_delay)
+ {
+ 	char const *test_str = "test_message_after_rekey";
+ 	struct tls_crypto_info_keys tls12;
+ 	struct pollfd pfd = { };
+ 	int send_len;
+ 	int ret;
+ 
+ 	if (variant->tls_version != TLS_1_3_VERSION)
+ 		return;
+ 
+ 	/* update TX key */
+ 	tls_send_keyupdate(_metadata, self->fd);
+ 	tls_crypto_info_init(variant->tls_version, variant->cipher_type, &tls12, 1);
+ 	EXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);
+ 
+ 	/* get KeyUpdate */
+ 	tls_recv_keyupdate(_metadata, self->cfd, 0);
+ 
+ 	ret = fork();
+ 	ASSERT_GE(ret, 0);
+ 
+ 	if (ret) {
+ 		int pid2, status;
+ 
+ 		/* wait before installing the new key */
+ 		sleep(1);
+ 
+ 		/* update RX key while poll() is sleeping */
+ 		EXPECT_EQ(setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);
+ 
+ 		sleep(1);
+ 		send_len = strlen(test_str) + 1;
+ 		EXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);
+ 
+ 		pid2 = wait(&status);
+ 		EXPECT_EQ(pid2, ret);
+ 		EXPECT_EQ(status, 0);
+ 	} else {
+ 		pfd.fd = self->cfd;
+ 		pfd.events = POLLIN;
+ 		EXPECT_EQ(poll(&pfd, 1, 5000), 1);
+ 		exit(!__test_passed(_metadata));
+ 	}
+ }
+ 
+ struct raw_rec {
+ 	unsigned int plain_len;
+ 	unsigned char plain_data[100];
+ 	unsigned int cipher_len;
+ 	unsigned char cipher_data[128];
+ };
+ 
+ /* TLS 1.2, AES_CCM, data, seqno:0, plaintext: 'Hello world' */
+ static const struct raw_rec id0_data_l11 = {
+ 	.plain_len = 11,
+ 	.plain_data = {
+ 		0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f,
+ 		0x72, 0x6c, 0x64,
+ 	},
+ 	.cipher_len = 40,
+ 	.cipher_data = {
+ 		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0xa2, 0x33,
+ 		0xde, 0x8d, 0x94, 0xf0, 0x29, 0x6c, 0xb1, 0xaf,
+ 		0x6a, 0x75, 0xb2, 0x93, 0xad, 0x45, 0xd5, 0xfd,
+ 		0x03, 0x51, 0x57, 0x8f, 0xf9, 0xcc, 0x3b, 0x42,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, ctrl, seqno:0, plaintext: '' */
+ static const struct raw_rec id0_ctrl_l0 = {
+ 	.plain_len = 0,
+ 	.plain_data = {
+ 	},
+ 	.cipher_len = 29,
+ 	.cipher_data = {
+ 		0x16, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x38, 0x7b,
+ 		0xa6, 0x1c, 0xdd, 0xa7, 0x19, 0x33, 0xab, 0xae,
+ 		0x88, 0xe1, 0xd2, 0x08, 0x4f,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, data, seqno:0, plaintext: '' */
+ static const struct raw_rec id0_data_l0 = {
+ 	.plain_len = 0,
+ 	.plain_data = {
+ 	},
+ 	.cipher_len = 29,
+ 	.cipher_data = {
+ 		0x17, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x00, 0xc5, 0x37, 0x90,
+ 		0x70, 0x45, 0x89, 0xfb, 0x5c, 0xc7, 0x89, 0x03,
+ 		0x68, 0x80, 0xd3, 0xd8, 0xcc,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, data, seqno:1, plaintext: 'Hello world' */
+ static const struct raw_rec id1_data_l11 = {
+ 	.plain_len = 11,
+ 	.plain_data = {
+ 		0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f,
+ 		0x72, 0x6c, 0x64,
+ 	},
+ 	.cipher_len = 40,
+ 	.cipher_data = {
+ 		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x1a, 0x9c,
+ 		0xd0, 0xa8, 0x9a, 0xd6, 0x69, 0xd6, 0x1a, 0xe3,
+ 		0xb5, 0x1f, 0x0d, 0x2c, 0xe2, 0x97, 0x46, 0xff,
+ 		0x2b, 0xcc, 0x5a, 0xc4, 0xa3, 0xb9, 0xef, 0xba,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, ctrl, seqno:1, plaintext: '' */
+ static const struct raw_rec id1_ctrl_l0 = {
+ 	.plain_len = 0,
+ 	.plain_data = {
+ 	},
+ 	.cipher_len = 29,
+ 	.cipher_data = {
+ 		0x16, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x01, 0x3e, 0xf0, 0xfe,
+ 		0xee, 0xd9, 0xe2, 0x5d, 0xc7, 0x11, 0x4c, 0xe6,
+ 		0xb4, 0x7e, 0xef, 0x40, 0x2b,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, data, seqno:1, plaintext: '' */
+ static const struct raw_rec id1_data_l0 = {
+ 	.plain_len = 0,
+ 	.plain_data = {
+ 	},
+ 	.cipher_len = 29,
+ 	.cipher_data = {
+ 		0x17, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x01, 0xce, 0xfc, 0x86,
+ 		0xc8, 0xf0, 0x55, 0xf9, 0x47, 0x3f, 0x74, 0xdc,
+ 		0xc9, 0xbf, 0xfe, 0x5b, 0xb1,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, ctrl, seqno:2, plaintext: 'Hello world' */
+ static const struct raw_rec id2_ctrl_l11 = {
+ 	.plain_len = 11,
+ 	.plain_data = {
+ 		0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f,
+ 		0x72, 0x6c, 0x64,
+ 	},
+ 	.cipher_len = 40,
+ 	.cipher_data = {
+ 		0x16, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x02, 0xe5, 0x3d, 0x19,
+ 		0x3d, 0xca, 0xb8, 0x16, 0xb6, 0xff, 0x79, 0x87,
+ 		0x2a, 0x04, 0x11, 0x3d, 0xf8, 0x64, 0x5f, 0x36,
+ 		0x8b, 0xa8, 0xee, 0x4c, 0x6d, 0x62, 0xa5, 0x00,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, data, seqno:2, plaintext: 'Hello world' */
+ static const struct raw_rec id2_data_l11 = {
+ 	.plain_len = 11,
+ 	.plain_data = {
+ 		0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f,
+ 		0x72, 0x6c, 0x64,
+ 	},
+ 	.cipher_len = 40,
+ 	.cipher_data = {
+ 		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x02, 0xe5, 0x3d, 0x19,
+ 		0x3d, 0xca, 0xb8, 0x16, 0xb6, 0xff, 0x79, 0x87,
+ 		0x8e, 0xa1, 0xd0, 0xcd, 0x33, 0xb5, 0x86, 0x2b,
+ 		0x17, 0xf1, 0x52, 0x2a, 0x55, 0x62, 0x65, 0x11,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, ctrl, seqno:2, plaintext: '' */
+ static const struct raw_rec id2_ctrl_l0 = {
+ 	.plain_len = 0,
+ 	.plain_data = {
+ 	},
+ 	.cipher_len = 29,
+ 	.cipher_data = {
+ 		0x16, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x02, 0xdc, 0x5c, 0x0e,
+ 		0x41, 0xdd, 0xba, 0xd3, 0xcc, 0xcf, 0x6d, 0xd9,
+ 		0x06, 0xdb, 0x79, 0xe5, 0x5d,
+ 	},
+ };
+ 
+ /* TLS 1.2, AES_CCM, data, seqno:2, plaintext: '' */
+ static const struct raw_rec id2_data_l0 = {
+ 	.plain_len = 0,
+ 	.plain_data = {
+ 	},
+ 	.cipher_len = 29,
+ 	.cipher_data = {
+ 		0x17, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x02, 0xc3, 0xca, 0x26,
+ 		0x22, 0xe4, 0x25, 0xfb, 0x5f, 0x6d, 0xbf, 0x83,
+ 		0x30, 0x48, 0x69, 0x1a, 0x47,
+ 	},
+ };
+ 
+ FIXTURE(zero_len)
+ {
+ 	int fd, cfd;
+ 	bool notls;
+ };
+ 
+ FIXTURE_VARIANT(zero_len)
+ {
+ 	const struct raw_rec *recs[4];
+ 	ssize_t recv_ret[4];
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, data_data_data)
+ {
+ 	.recs = { &id0_data_l11, &id1_data_l11, &id2_data_l11, },
+ 	.recv_ret = { 33, -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, data_0ctrl_data)
+ {
+ 	.recs = { &id0_data_l11, &id1_ctrl_l0, &id2_data_l11, },
+ 	.recv_ret = { 11, 0, 11, -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, 0data_0data_0data)
+ {
+ 	.recs = { &id0_data_l0, &id1_data_l0, &id2_data_l0, },
+ 	.recv_ret = { -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, 0data_0data_ctrl)
+ {
+ 	.recs = { &id0_data_l0, &id1_data_l0, &id2_ctrl_l11, },
+ 	.recv_ret = { 0, 11, -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, 0data_0data_0ctrl)
+ {
+ 	.recs = { &id0_data_l0, &id1_data_l0, &id2_ctrl_l0, },
+ 	.recv_ret = { 0, 0, -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, 0ctrl_0ctrl_0ctrl)
+ {
+ 	.recs = { &id0_ctrl_l0, &id1_ctrl_l0, &id2_ctrl_l0, },
+ 	.recv_ret = { 0, 0, 0, -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, 0data_0data_data)
+ {
+ 	.recs = { &id0_data_l0, &id1_data_l0, &id2_data_l11, },
+ 	.recv_ret = { 11, -EAGAIN, },
+ };
+ 
+ FIXTURE_VARIANT_ADD(zero_len, data_0data_0data)
+ {
+ 	.recs = { &id0_data_l11, &id1_data_l0, &id2_data_l0, },
+ 	.recv_ret = { 11, -EAGAIN, },
+ };
+ 
+ FIXTURE_SETUP(zero_len)
+ {
+ 	struct tls_crypto_info_keys tls12;
+ 	int ret;
+ 
+ 	tls_crypto_info_init(TLS_1_2_VERSION, TLS_CIPHER_AES_CCM_128,
+ 			     &tls12, 0);
+ 
+ 	ulp_sock_pair(_metadata, &self->fd, &self->cfd, &self->notls);
+ 	if (self->notls)
+ 		return;
+ 
+ 	/* Don't install keys on fd, we'll send raw records */
+ 	ret = setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len);
+ 	ASSERT_EQ(ret, 0);
+ }
+ 
+ FIXTURE_TEARDOWN(zero_len)
+ {
+ 	close(self->fd);
+ 	close(self->cfd);
+ }
+ 
+ TEST_F(zero_len, test)
+ {
+ 	const struct raw_rec *const *rec;
+ 	unsigned char buf[128];
+ 	int rec_off;
+ 	int i;
+ 
+ 	for (i = 0; i < 4 && variant->recs[i]; i++)
+ 		EXPECT_EQ(send(self->fd, variant->recs[i]->cipher_data,
+ 			       variant->recs[i]->cipher_len, 0),
+ 			  variant->recs[i]->cipher_len);
+ 
+ 	rec = &variant->recs[0];
+ 	rec_off = 0;
+ 	for (i = 0; i < 4; i++) {
+ 		int j, ret;
+ 
+ 		ret = variant->recv_ret[i] >= 0 ? variant->recv_ret[i] : -1;
+ 		EXPECT_EQ(__tls_recv_cmsg(_metadata, self->cfd, NULL,
+ 					  buf, sizeof(buf), MSG_DONTWAIT), ret);
+ 		if (ret == -1)
+ 			EXPECT_EQ(errno, -variant->recv_ret[i]);
+ 		if (variant->recv_ret[i] == -EAGAIN)
+ 			break;
+ 
+ 		for (j = 0; j < ret; j++) {
+ 			while (rec_off == (*rec)->plain_len) {
+ 				rec++;
+ 				rec_off = 0;
+ 			}
+ 			EXPECT_EQ(buf[j], (*rec)->plain_data[rec_off]);
+ 			rec_off++;
+ 		}
+ 	}
+ };
+ 
++>>>>>>> a61a3e961baf (selftests: tls: add tests for zero-length records)
  FIXTURE(tls_err)
  {
  	int fd, cfd;
* Unmerged path tools/testing/selftests/net/tls.c
