sched: Rename task_running() to task_on_cpu()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-497.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 0b9d46fc5ef7a457cc635b30b010081228cb81ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-497.el8/0b9d46fc.failed

There is some ambiguity about task_running() in that it is unrelated
to TASK_RUNNING but instead tests ->on_cpu. As such, rename the thing
task_on_cpu().

	Suggested-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/Yxhkhn55uHZx+NGl@hirez.programming.kicks-ass.net
(cherry picked from commit 0b9d46fc5ef7a457cc635b30b010081228cb81ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core_sched.c
#	kernel/sched/fair.c
#	kernel/sched/rt.c
diff --cc kernel/sched/fair.c
index 958a2ec53f32,4e5b171b1171..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -7688,8 -7935,8 +7688,13 @@@ int can_migrate_task(struct task_struc
  	/* Record that we found at least one task that could run on dst_cpu */
  	env->flags &= ~LBF_ALL_PINNED;
  
++<<<<<<< HEAD
 +	if (task_running(env->src_rq, p)) {
 +		schedstat_inc(p->se.statistics.nr_failed_migrations_running);
++=======
+ 	if (task_on_cpu(env->src_rq, p)) {
+ 		schedstat_inc(p->stats.nr_failed_migrations_running);
++>>>>>>> 0b9d46fc5ef7 (sched: Rename task_running() to task_on_cpu())
  		return 0;
  	}
  
diff --cc kernel/sched/rt.c
index 234cbb61d892,d869bcf898cc..000000000000
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@@ -2217,12 -2458,14 +2217,23 @@@ skip
   */
  static void task_woken_rt(struct rq *rq, struct task_struct *p)
  {
++<<<<<<< HEAD
 +	if (!task_running(rq, p) &&
 +	    !test_tsk_need_resched(rq->curr) &&
 +	    p->nr_cpus_allowed > 1 &&
 +	    (dl_task(rq->curr) || rt_task(rq->curr)) &&
 +	    (rq->curr->nr_cpus_allowed < 2 ||
 +	     rq->curr->prio <= p->prio))
++=======
+ 	bool need_to_push = !task_on_cpu(rq, p) &&
+ 			    !test_tsk_need_resched(rq->curr) &&
+ 			    p->nr_cpus_allowed > 1 &&
+ 			    (dl_task(rq->curr) || rt_task(rq->curr)) &&
+ 			    (rq->curr->nr_cpus_allowed < 2 ||
+ 			     rq->curr->prio <= p->prio);
+ 
+ 	if (need_to_push)
++>>>>>>> 0b9d46fc5ef7 (sched: Rename task_running() to task_on_cpu())
  		push_rt_tasks(rq);
  }
  
* Unmerged path kernel/sched/core_sched.c
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index ae048de81060..8fb9e011e72c 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1589,7 +1589,7 @@ static int affine_move_task(struct rq *rq, struct task_struct *p, struct rq_flag
 		return -EINVAL;
 	}
 
-	if (task_running(rq, p) || READ_ONCE(p->__state) == TASK_WAKING) {
+	if (task_on_cpu(rq, p) || READ_ONCE(p->__state) == TASK_WAKING) {
 		/*
 		 * MIGRATE_ENABLE gets here because 'p == current', but for
 		 * anything else we cannot do is_migration_disabled(), punt
@@ -1940,11 +1940,11 @@ unsigned long wait_task_inactive(struct task_struct *p, unsigned int match_state
 		 *
 		 * NOTE! Since we don't hold any locks, it's not
 		 * even sure that "rq" stays as the right runqueue!
-		 * But we don't care, since "task_running()" will
+		 * But we don't care, since "task_on_cpu()" will
 		 * return false if the runqueue has changed and p
 		 * is actually now running somewhere else!
 		 */
-		while (task_running(rq, p)) {
+		while (task_on_cpu(rq, p)) {
 			if (match_state && unlikely(READ_ONCE(p->__state) != match_state))
 				return 0;
 			cpu_relax();
@@ -1957,7 +1957,7 @@ unsigned long wait_task_inactive(struct task_struct *p, unsigned int match_state
 		 */
 		rq = task_rq_lock(p, &rf);
 		trace_sched_wait_task(p);
-		running = task_running(rq, p);
+		running = task_on_cpu(rq, p);
 		queued = task_on_rq_queued(p);
 		ncsw = 0;
 		if (!match_state || READ_ONCE(p->__state) == match_state)
@@ -6292,7 +6292,7 @@ int __sched yield_to(struct task_struct *p, bool preempt)
 	if (curr->sched_class != p->sched_class)
 		goto out_unlock;
 
-	if (task_running(p_rq, p) || !task_is_running(p))
+	if (task_on_cpu(p_rq, p) || !task_is_running(p))
 		goto out_unlock;
 
 	yielded = curr->sched_class->yield_to_task(rq, p);
* Unmerged path kernel/sched/core_sched.c
diff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c
index bfeffe5c46f0..efbd3a5f0e86 100644
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@ -1916,7 +1916,7 @@ static void task_fork_dl(struct task_struct *p)
 
 static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)
 {
-	if (!task_running(rq, p) &&
+	if (!task_on_cpu(rq, p) &&
 	    cpumask_test_cpu(cpu, &p->cpus_mask))
 		return 1;
 	return 0;
@@ -2068,7 +2068,7 @@ static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)
 		if (double_lock_balance(rq, later_rq)) {
 			if (unlikely(task_rq(task) != rq ||
 				     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||
-				     task_running(rq, task) ||
+				     task_on_cpu(rq, task) ||
 				     !dl_task(task) ||
 				     !task_on_rq_queued(task))) {
 				double_unlock_balance(rq, later_rq);
@@ -2303,7 +2303,7 @@ static void pull_dl_task(struct rq *this_rq)
  */
 static void task_woken_dl(struct rq *rq, struct task_struct *p)
 {
-	if (!task_running(rq, p) &&
+	if (!task_on_cpu(rq, p) &&
 	    !test_tsk_need_resched(rq->curr) &&
 	    p->nr_cpus_allowed > 1 &&
 	    dl_task(rq->curr) &&
* Unmerged path kernel/sched/fair.c
* Unmerged path kernel/sched/rt.c
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 73b3a9a64bda..0a615d098eeb 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1751,7 +1751,7 @@ static inline int task_current(struct rq *rq, struct task_struct *p)
 	return rq->curr == p;
 }
 
-static inline int task_running(struct rq *rq, struct task_struct *p)
+static inline int task_on_cpu(struct rq *rq, struct task_struct *p)
 {
 #ifdef CONFIG_SMP
 	return p->on_cpu;
