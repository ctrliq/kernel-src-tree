tcp: enforce receive buffer memory limits by allowing the tcp window to shrink

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-527.el8
commit-author mfreemon@cloudflare.com <mfreemon@cloudflare.com>
commit b650d953cd391595e536153ce30b4aab385643ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-527.el8/b650d953.failed

Under certain circumstances, the tcp receive buffer memory limit
set by autotuning (sk_rcvbuf) is increased due to incoming data
packets as a result of the window not closing when it should be.
This can result in the receive buffer growing all the way up to
tcp_rmem[2], even for tcp sessions with a low BDP.

To reproduce:  Connect a TCP session with the receiver doing
nothing and the sender sending small packets (an infinite loop
of socket send() with 4 bytes of payload with a sleep of 1 ms
in between each send()).  This will cause the tcp receive buffer
to grow all the way up to tcp_rmem[2].

As a result, a host can have individual tcp sessions with receive
buffers of size tcp_rmem[2], and the host itself can reach tcp_mem
limits, causing the host to go into tcp memory pressure mode.

The fundamental issue is the relationship between the granularity
of the window scaling factor and the number of byte ACKed back
to the sender.  This problem has previously been identified in
RFC 7323, appendix F [1].

The Linux kernel currently adheres to never shrinking the window.

In addition to the overallocation of memory mentioned above, the
current behavior is functionally incorrect, because once tcp_rmem[2]
is reached when no remediations remain (i.e. tcp collapse fails to
free up any more memory and there are no packets to prune from the
out-of-order queue), the receiver will drop in-window packets
resulting in retransmissions and an eventual timeout of the tcp
session.  A receive buffer full condition should instead result
in a zero window and an indefinite wait.

In practice, this problem is largely hidden for most flows.  It
is not applicable to mice flows.  Elephant flows can send data
fast enough to "overrun" the sk_rcvbuf limit (in a single ACK),
triggering a zero window.

But this problem does show up for other types of flows.  Examples
are websockets and other type of flows that send small amounts of
data spaced apart slightly in time.  In these cases, we directly
encounter the problem described in [1].

RFC 7323, section 2.4 [2], says there are instances when a retracted
window can be offered, and that TCP implementations MUST ensure
that they handle a shrinking window, as specified in RFC 1122,
section 4.2.2.16 [3].  All prior RFCs on the topic of tcp window
management have made clear that sender must accept a shrunk window
from the receiver, including RFC 793 [4] and RFC 1323 [5].

This patch implements the functionality to shrink the tcp window
when necessary to keep the right edge within the memory limit by
autotuning (sk_rcvbuf).  This new functionality is enabled with
the new sysctl: net.ipv4.tcp_shrink_window

Additional information can be found at:
https://blog.cloudflare.com/unbounded-memory-usage-by-tcp-for-receive-buffers-and-how-we-fixed-it/

[1] https://www.rfc-editor.org/rfc/rfc7323#appendix-F
[2] https://www.rfc-editor.org/rfc/rfc7323#section-2.4
[3] https://www.rfc-editor.org/rfc/rfc1122#page-91
[4] https://www.rfc-editor.org/rfc/rfc793
[5] https://www.rfc-editor.org/rfc/rfc1323

	Signed-off-by: Mike Freemon <mfreemon@cloudflare.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b650d953cd391595e536153ce30b4aab385643ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/ipv4.h
#	net/ipv4/sysctl_net_ipv4.c
#	net/ipv4/tcp_ipv4.c
#	net/ipv4/tcp_output.c
diff --cc include/net/netns/ipv4.h
index 661348f23ea5,f00374718159..000000000000
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@@ -53,20 -58,20 +53,25 @@@ struct netns_ipv4 
  	struct mutex		ra_mutex;
  #ifdef CONFIG_IP_MULTIPLE_TABLES
  	struct fib_rules_ops	*rules_ops;
 +	bool			fib_has_custom_rules;
 +	unsigned int		fib_rules_require_fldissect;
  	struct fib_table __rcu	*fib_main;
  	struct fib_table __rcu	*fib_default;
 -	unsigned int		fib_rules_require_fldissect;
 -	bool			fib_has_custom_rules;
  #endif
  	bool			fib_has_custom_local_routes;
++<<<<<<< HEAD
++=======
+ 	bool			fib_offload_disabled;
+ 	u8			sysctl_tcp_shrink_window;
++>>>>>>> b650d953cd39 (tcp: enforce receive buffer memory limits by allowing the tcp window to shrink)
  #ifdef CONFIG_IP_ROUTE_CLASSID
 -	atomic_t		fib_num_tclassid_users;
 +	int			fib_num_tclassid_users;
  #endif
  	struct hlist_head	*fib_table_hash;
 +	bool			fib_offload_disabled;
  	struct sock		*fibnl;
  
 +	struct sock  * __percpu	*icmp_sk;
  	struct sock		*mc_autojoin_sk;
  
  	struct inet_peer_base	*peers;
diff --cc net/ipv4/sysctl_net_ipv4.c
index 7d340868e1df,2afb0870648b..000000000000
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@@ -1271,6 -1421,74 +1271,77 @@@ static struct ctl_table ipv4_net_table[
  		.proc_handler	= proc_dointvec_minmax,
  		.extra1		= SYSCTL_ONE
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.procname	= "fib_notify_on_flag_change",
+ 		.data		= &init_net.ipv4.sysctl_fib_notify_on_flag_change,
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1		= SYSCTL_ZERO,
+ 		.extra2		= SYSCTL_TWO,
+ 	},
+ 	{
+ 		.procname       = "tcp_plb_enabled",
+ 		.data           = &init_net.ipv4.sysctl_tcp_plb_enabled,
+ 		.maxlen         = sizeof(u8),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dou8vec_minmax,
+ 		.extra1         = SYSCTL_ZERO,
+ 		.extra2         = SYSCTL_ONE,
+ 	},
+ 	{
+ 		.procname       = "tcp_plb_idle_rehash_rounds",
+ 		.data           = &init_net.ipv4.sysctl_tcp_plb_idle_rehash_rounds,
+ 		.maxlen         = sizeof(u8),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dou8vec_minmax,
+ 		.extra2		= &tcp_plb_max_rounds,
+ 	},
+ 	{
+ 		.procname       = "tcp_plb_rehash_rounds",
+ 		.data           = &init_net.ipv4.sysctl_tcp_plb_rehash_rounds,
+ 		.maxlen         = sizeof(u8),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dou8vec_minmax,
+ 		.extra2         = &tcp_plb_max_rounds,
+ 	},
+ 	{
+ 		.procname       = "tcp_plb_suspend_rto_sec",
+ 		.data           = &init_net.ipv4.sysctl_tcp_plb_suspend_rto_sec,
+ 		.maxlen         = sizeof(u8),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dou8vec_minmax,
+ 	},
+ 	{
+ 		.procname       = "tcp_plb_cong_thresh",
+ 		.data           = &init_net.ipv4.sysctl_tcp_plb_cong_thresh,
+ 		.maxlen         = sizeof(int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec_minmax,
+ 		.extra1         = SYSCTL_ZERO,
+ 		.extra2         = &tcp_plb_max_cong_thresh,
+ 	},
+ 	{
+ 		.procname	= "tcp_syn_linear_timeouts",
+ 		.data		= &init_net.ipv4.sysctl_tcp_syn_linear_timeouts,
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1		= SYSCTL_ZERO,
+ 		.extra2		= &tcp_syn_linear_timeouts_max,
+ 	},
+ 	{
+ 		.procname	= "tcp_shrink_window",
+ 		.data		= &init_net.ipv4.sysctl_tcp_shrink_window,
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1		= SYSCTL_ZERO,
+ 		.extra2		= SYSCTL_ONE,
+ 	},
++>>>>>>> b650d953cd39 (tcp: enforce receive buffer memory limits by allowing the tcp window to shrink)
  	{ }
  };
  
diff --cc net/ipv4/tcp_ipv4.c
index 9cfd4db9647c,9213804b034f..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -2848,11 -3280,10 +2848,17 @@@ static int __net_init tcp_sk_init(struc
  	else
  		net->ipv4.tcp_congestion_control = &tcp_reno;
  
++<<<<<<< HEAD
++=======
+ 	net->ipv4.sysctl_tcp_syn_linear_timeouts = 4;
+ 	net->ipv4.sysctl_tcp_shrink_window = 0;
+ 
++>>>>>>> b650d953cd39 (tcp: enforce receive buffer memory limits by allowing the tcp window to shrink)
  	return 0;
 +fail:
 +	tcp_sk_exit(net);
 +
 +	return res;
  }
  
  static void __net_exit tcp_sk_exit_batch(struct list_head *net_exit_list)
diff --cc net/ipv4/tcp_output.c
index 346f591a6630,2cb39b6dad02..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -304,7 -285,7 +307,11 @@@ static u16 tcp_select_window(struct soc
  	 * scaled window.
  	 */
  	if (!tp->rx_opt.rcv_wscale &&
++<<<<<<< HEAD
 +	    sock_net(sk)->ipv4.sysctl_tcp_workaround_signed_windows)
++=======
+ 	    READ_ONCE(net->ipv4.sysctl_tcp_workaround_signed_windows))
++>>>>>>> b650d953cd39 (tcp: enforce receive buffer memory limits by allowing the tcp window to shrink)
  		new_win = min(new_win, MAX_TCP_WINDOW);
  	else
  		new_win = min(new_win, (65535U << tp->rx_opt.rcv_wscale));
diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
index 20076bc0828a..65f0697ff69e 100644
--- a/Documentation/networking/ip-sysctl.txt
+++ b/Documentation/networking/ip-sysctl.txt
@@ -735,6 +735,21 @@ tcp_tw_reuse - INTEGER
 tcp_window_scaling - BOOLEAN
 	Enable window scaling as defined in RFC1323.
 
+tcp_shrink_window - BOOLEAN
+	This changes how the TCP receive window is calculated.
+
+	RFC 7323, section 2.4, says there are instances when a retracted
+	window can be offered, and that TCP implementations MUST ensure
+	that they handle a shrinking window, as specified in RFC 1122.
+
+	- 0 - Disabled.	The window is never shrunk.
+	- 1 - Enabled.	The window is shrunk when necessary to remain within
+			the memory limit set by autotuning (sk_rcvbuf).
+			This only occurs if a non-zero receive window
+			scaling factor is also in effect.
+
+	Default: 0
+
 tcp_wmem - vector of 3 INTEGERs: min, default, max
 	min: Amount of memory reserved for send buffers for TCP sockets.
 	Each TCP socket has rights to use it due to fact of its birth.
* Unmerged path include/net/netns/ipv4.h
* Unmerged path net/ipv4/sysctl_net_ipv4.c
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv4/tcp_output.c
