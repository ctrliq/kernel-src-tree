ALSA: hda - Replace with standard printk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: Replace with standard printk (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 87.67%
commit-author Takashi Iwai <tiwai@suse.de>
commit 4e76a8833fac8dc1735aa5be7d1b3c92c65e209e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4e76a883.failed

Use dev_err() and co for messages from HD-audio controller and codec
drivers.  The codec drivers are mostly bound with codec objects, so
some helper macros, codec_err(), codec_info(), etc, are provided.
They merely wrap the corresponding dev_xxx().

There are a few places still calling snd_printk() and its variants
as they are called without the codec or device context.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 4e76a8833fac8dc1735aa5be7d1b3c92c65e209e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_sysfs.c
* Unmerged path sound/pci/hda/hda_sysfs.c
diff --git a/sound/pci/hda/hda_auto_parser.c b/sound/pci/hda/hda_auto_parser.c
index 853c6a69e29e..6c3d2432551d 100644
--- a/sound/pci/hda/hda_auto_parser.c
+++ b/sound/pci/hda/hda_auto_parser.c
@@ -313,9 +313,9 @@ int snd_hda_parse_pin_defcfg(struct hda_codec *codec,
 		}
 
 		if (hsmic)
-			snd_printdd("Told to look for a headset mic, but didn't find any.\n");
+			codec_dbg(codec, "Told to look for a headset mic, but didn't find any.\n");
 		if (hpmic)
-			snd_printdd("Told to look for a headphone mic, but didn't find any.\n");
+			codec_dbg(codec, "Told to look for a headphone mic, but didn't find any.\n");
 	}
 
 	/* FIX-UP:
@@ -384,33 +384,33 @@ int snd_hda_parse_pin_defcfg(struct hda_codec *codec,
 	/*
 	 * debug prints of the parsed results
 	 */
-	snd_printd("autoconfig: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x) type:%s\n",
+	codec_info(codec, "autoconfig: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x) type:%s\n",
 		   cfg->line_outs, cfg->line_out_pins[0], cfg->line_out_pins[1],
 		   cfg->line_out_pins[2], cfg->line_out_pins[3],
 		   cfg->line_out_pins[4],
 		   cfg->line_out_type == AUTO_PIN_HP_OUT ? "hp" :
 		   (cfg->line_out_type == AUTO_PIN_SPEAKER_OUT ?
 		    "speaker" : "line"));
-	snd_printd("   speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+	codec_info(codec, "   speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
 		   cfg->speaker_outs, cfg->speaker_pins[0],
 		   cfg->speaker_pins[1], cfg->speaker_pins[2],
 		   cfg->speaker_pins[3], cfg->speaker_pins[4]);
-	snd_printd("   hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+	codec_info(codec, "   hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
 		   cfg->hp_outs, cfg->hp_pins[0],
 		   cfg->hp_pins[1], cfg->hp_pins[2],
 		   cfg->hp_pins[3], cfg->hp_pins[4]);
-	snd_printd("   mono: mono_out=0x%x\n", cfg->mono_out_pin);
+	codec_info(codec, "   mono: mono_out=0x%x\n", cfg->mono_out_pin);
 	if (cfg->dig_outs)
-		snd_printd("   dig-out=0x%x/0x%x\n",
+		codec_info(codec, "   dig-out=0x%x/0x%x\n",
 			   cfg->dig_out_pins[0], cfg->dig_out_pins[1]);
-	snd_printd("   inputs:\n");
+	codec_info(codec, "   inputs:\n");
 	for (i = 0; i < cfg->num_inputs; i++) {
-		snd_printd("     %s=0x%x\n",
+		codec_info(codec, "     %s=0x%x\n",
 			    hda_get_autocfg_input_label(codec, cfg, i),
 			    cfg->inputs[i].pin);
 	}
 	if (cfg->dig_in_pin)
-		snd_printd("   dig-in=0x%x\n", cfg->dig_in_pin);
+		codec_info(codec, "   dig-in=0x%x\n", cfg->dig_in_pin);
 
 	return 0;
 }
@@ -774,38 +774,33 @@ static void apply_fixup(struct hda_codec *codec, int id, int action, int depth)
 		case HDA_FIXUP_PINS:
 			if (action != HDA_FIXUP_ACT_PRE_PROBE || !fix->v.pins)
 				break;
-			snd_printdd(KERN_INFO SFX
-				    "%s: Apply pincfg for %s\n",
+			codec_dbg(codec, "%s: Apply pincfg for %s\n",
 				    codec->chip_name, modelname);
 			snd_hda_apply_pincfgs(codec, fix->v.pins);
 			break;
 		case HDA_FIXUP_VERBS:
 			if (action != HDA_FIXUP_ACT_PROBE || !fix->v.verbs)
 				break;
-			snd_printdd(KERN_INFO SFX
-				    "%s: Apply fix-verbs for %s\n",
+			codec_dbg(codec, "%s: Apply fix-verbs for %s\n",
 				    codec->chip_name, modelname);
 			snd_hda_add_verbs(codec, fix->v.verbs);
 			break;
 		case HDA_FIXUP_FUNC:
 			if (!fix->v.func)
 				break;
-			snd_printdd(KERN_INFO SFX
-				    "%s: Apply fix-func for %s\n",
+			codec_dbg(codec, "%s: Apply fix-func for %s\n",
 				    codec->chip_name, modelname);
 			fix->v.func(codec, fix, action);
 			break;
 		case HDA_FIXUP_PINCTLS:
 			if (action != HDA_FIXUP_ACT_PROBE || !fix->v.pins)
 				break;
-			snd_printdd(KERN_INFO SFX
-				    "%s: Apply pinctl for %s\n",
+			codec_dbg(codec, "%s: Apply pinctl for %s\n",
 				    codec->chip_name, modelname);
 			set_pin_targets(codec, fix->v.pins);
 			break;
 		default:
-			snd_printk(KERN_ERR SFX
-				   "%s: Invalid fixup type %d\n",
+			codec_err(codec, "%s: Invalid fixup type %d\n",
 				   codec->chip_name, fix->type);
 			break;
 		}
diff --git a/sound/pci/hda/hda_beep.c b/sound/pci/hda/hda_beep.c
index f0f711fa03d5..31b8a0bbd5f6 100644
--- a/sound/pci/hda/hda_beep.c
+++ b/sound/pci/hda/hda_beep.c
@@ -172,7 +172,7 @@ static int snd_hda_do_attach(struct hda_beep *beep)
 	err = input_register_device(input_dev);
 	if (err < 0) {
 		input_free_device(input_dev);
-		printk(KERN_INFO "hda_beep: unable to register input device\n");
+		codec_err(codec, "hda_beep: unable to register input device\n");
 		return err;
 	}
 	beep->dev = input_dev;
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 11666375682f..5ac826c0fb49 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -200,7 +200,7 @@ make_codec_cmd(struct hda_codec *codec, hda_nid_t nid, int flags,
 
 	if ((codec->addr & ~0xf) || (nid & ~0x7f) ||
 	    (verb & ~0xfff) || (parm & ~0xffff)) {
-		printk(KERN_ERR "hda-codec: out of range cmd %x:%x:%x:%x\n",
+		codec_err(codec, "hda-codec: out of range cmd %x:%x:%x:%x\n",
 		       codec->addr, nid, verb, parm);
 		return ~0;
 	}
@@ -248,8 +248,8 @@ static int codec_exec_verb(struct hda_codec *codec, unsigned int cmd,
 	snd_hda_power_down(codec);
 	if (!codec_in_pm(codec) && res && *res == -1 && bus->rirb_error) {
 		if (bus->response_reset) {
-			snd_printd("hda_codec: resetting BUS due to "
-				   "fatal communication error\n");
+			codec_dbg(codec,
+				  "resetting BUS due to fatal communication error\n");
 			trace_hda_bus_reset(bus);
 			bus->ops.bus_reset(bus);
 		}
@@ -474,8 +474,7 @@ int snd_hda_get_connections(struct hda_codec *codec, hda_nid_t nid,
 
 	if (len > 0 && conn_list) {
 		if (len > max_conns) {
-			snd_printk(KERN_ERR "hda_codec: "
-				   "Too many connections %d for NID 0x%x\n",
+			codec_err(codec, "Too many connections %d for NID 0x%x\n",
 				   len, nid);
 			return -EINVAL;
 		}
@@ -573,8 +572,8 @@ int snd_hda_get_raw_connections(struct hda_codec *codec, hda_nid_t nid,
 		range_val = !!(parm & (1 << (shift-1))); /* ranges */
 		val = parm & mask;
 		if (val == 0 && null_count++) {  /* no second chance */
-			snd_printdd("hda_codec: "
-				   "invalid CONNECT_LIST verb %x[%i]:%x\n",
+			codec_dbg(codec,
+				  "invalid CONNECT_LIST verb %x[%i]:%x\n",
 				    nid, i, parm);
 			return 0;
 		}
@@ -582,7 +581,7 @@ int snd_hda_get_raw_connections(struct hda_codec *codec, hda_nid_t nid,
 		if (range_val) {
 			/* ranges between the previous and this one */
 			if (!prev_nid || prev_nid >= val) {
-				snd_printk(KERN_WARNING "hda_codec: "
+				codec_warn(codec,
 					   "invalid dep_range_val %x:%x\n",
 					   prev_nid, val);
 				continue;
@@ -659,7 +658,7 @@ int snd_hda_get_conn_index(struct hda_codec *codec, hda_nid_t mux,
 	if (!recursive)
 		return -1;
 	if (recursive > 10) {
-		snd_printd("hda_codec: too deep connection for 0x%x\n", nid);
+		codec_dbg(codec, "too deep connection for 0x%x\n", nid);
 		return -1;
 	}
 	recursive++;
@@ -807,8 +806,7 @@ static int init_unsol_queue(struct hda_bus *bus)
 
 	unsol = kzalloc(sizeof(*unsol), GFP_KERNEL);
 	if (!unsol) {
-		snd_printk(KERN_ERR "hda_codec: "
-			   "can't allocate unsolicited queue\n");
+		dev_err(bus->card->dev, "can't allocate unsolicited queue\n");
 		return -ENOMEM;
 	}
 	INIT_WORK(&unsol->work, process_unsol_events);
@@ -880,7 +878,7 @@ int snd_hda_bus_new(struct snd_card *card,
 
 	bus = kzalloc(sizeof(*bus), GFP_KERNEL);
 	if (bus == NULL) {
-		snd_printk(KERN_ERR "can't allocate struct hda_bus\n");
+		dev_err(card->dev, "can't allocate struct hda_bus\n");
 		return -ENOMEM;
 	}
 
@@ -899,7 +897,7 @@ int snd_hda_bus_new(struct snd_card *card,
 		 "hd-audio%d", card->number);
 	bus->workq = create_singlethread_workqueue(bus->workq_name);
 	if (!bus->workq) {
-		snd_printk(KERN_ERR "cannot create workqueue %s\n",
+		dev_err(card->dev, "cannot create workqueue %s\n",
 			   bus->workq_name);
 		kfree(bus);
 		return -ENOMEM;
@@ -943,7 +941,7 @@ find_codec_preset(struct hda_codec *codec)
 	mutex_lock(&preset_mutex);
 	list_for_each_entry(tbl, &hda_preset_tables, list) {
 		if (!try_module_get(tbl->owner)) {
-			snd_printk(KERN_ERR "hda_codec: cannot module_get\n");
+			codec_err(codec, "cannot module_get\n");
 			continue;
 		}
 		for (preset = tbl->preset; preset->id; preset++) {
@@ -1431,14 +1429,15 @@ int snd_hda_codec_new(struct hda_bus *bus,
 		return -EINVAL;
 
 	if (bus->caddr_tbl[codec_addr]) {
-		snd_printk(KERN_ERR "hda_codec: "
-			   "address 0x%x is already occupied\n", codec_addr);
+		dev_err(bus->card->dev,
+			"address 0x%x is already occupied\n",
+			codec_addr);
 		return -EBUSY;
 	}
 
 	codec = kzalloc(sizeof(*codec), GFP_KERNEL);
 	if (codec == NULL) {
-		snd_printk(KERN_ERR "can't allocate struct hda_codec\n");
+		dev_err(bus->card->dev, "can't allocate struct hda_codec\n");
 		return -ENOMEM;
 	}
 
@@ -1507,7 +1506,7 @@ int snd_hda_codec_new(struct hda_bus *bus,
 
 	setup_fg_nodes(codec);
 	if (!codec->afg && !codec->mfg) {
-		snd_printdd("hda_codec: no AFG or MFG node found\n");
+		dev_err(bus->card->dev, "no AFG or MFG node found\n");
 		err = -ENODEV;
 		goto error;
 	}
@@ -1515,7 +1514,7 @@ int snd_hda_codec_new(struct hda_bus *bus,
 	fg = codec->afg ? codec->afg : codec->mfg;
 	err = read_widget_caps(codec, fg);
 	if (err < 0) {
-		snd_printk(KERN_ERR "hda_codec: cannot malloc\n");
+		dev_err(bus->card->dev, "cannot malloc\n");
 		goto error;
 	}
 	err = read_pin_defaults(codec);
@@ -1577,7 +1576,7 @@ int snd_hda_codec_update_widgets(struct hda_codec *codec)
 	fg = codec->afg ? codec->afg : codec->mfg;
 	err = read_widget_caps(codec, fg);
 	if (err < 0) {
-		snd_printk(KERN_ERR "hda_codec: cannot malloc\n");
+		codec_err(codec, "cannot malloc\n");
 		return err;
 	}
 
@@ -1654,7 +1653,7 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 #endif
 		}
 		if (!patch) {
-			printk(KERN_ERR "hda-codec: No codec parser is available\n");
+			codec_err(codec, "No codec parser is available\n");
 			return -ENODEV;
 		}
 	}
@@ -1738,9 +1737,9 @@ void snd_hda_codec_setup_stream(struct hda_codec *codec, hda_nid_t nid,
 	if (!nid)
 		return;
 
-	snd_printdd("hda_codec_setup_stream: "
-		    "NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",
-		    nid, stream_tag, channel_id, format);
+	codec_dbg(codec,
+		  "hda_codec_setup_stream: NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",
+		  nid, stream_tag, channel_id, format);
 	p = get_hda_cvt_setup(codec, nid);
 	if (!p)
 		return;
@@ -1787,7 +1786,7 @@ void __snd_hda_codec_cleanup_stream(struct hda_codec *codec, hda_nid_t nid,
 	if (codec->no_sticky_stream)
 		do_now = 1;
 
-	snd_printdd("hda_codec_cleanup_stream: NID=0x%x\n", nid);
+	codec_dbg(codec, "hda_codec_cleanup_stream: NID=0x%x\n", nid);
 	p = get_hda_cvt_setup(codec, nid);
 	if (p) {
 		/* here we just clear the active flag when do_now isn't set;
@@ -2309,9 +2308,9 @@ int snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol,
 	uinfo->value.integer.min = 0;
 	uinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);
 	if (!uinfo->value.integer.max) {
-		printk(KERN_WARNING "hda_codec: "
-		       "num_steps = 0 for NID=0x%x (ctl = %s)\n", nid,
-		       kcontrol->id.name);
+		codec_warn(codec,
+			   "num_steps = 0 for NID=0x%x (ctl = %s)\n",
+			   nid, kcontrol->id.name);
 		return -EINVAL;
 	}
 	return 0;
@@ -2585,8 +2584,8 @@ int snd_hda_add_nid(struct hda_codec *codec, struct snd_kcontrol *kctl,
 		item->nid = nid;
 		return 0;
 	}
-	printk(KERN_ERR "hda-codec: no NID for mapping control %s:%d:%d\n",
-	       kctl->id.name, kctl->id.index, index);
+	codec_err(codec, "no NID for mapping control %s:%d:%d\n",
+		  kctl->id.name, kctl->id.index, index);
 	return -EINVAL;
 }
 EXPORT_SYMBOL_HDA(snd_hda_add_nid);
@@ -2778,7 +2777,7 @@ static int get_kctl_0dB_offset(struct snd_kcontrol *kctl, int *step_to_check)
 			return -1;
 		if (*step_to_check && *step_to_check != step) {
 			snd_printk(KERN_ERR "hda_codec: Mismatching dB step for vmaster slave (%d!=%d)\n",
-				   *step_to_check, step);
+-				   *step_to_check, step);
 			return -1;
 		}
 		*step_to_check = step;
@@ -2848,7 +2847,7 @@ int __snd_hda_add_vmaster(struct hda_codec *codec, char *name,
 
 	err = map_slaves(codec, slaves, suffix, check_slave_present, NULL);
 	if (err != 1) {
-		snd_printdd("No slave found for %s\n", name);
+		codec_dbg(codec, "No slave found for %s\n", name);
 		return 0;
 	}
 	kctl = snd_ctl_make_virtual_master(name, tlv);
@@ -3514,7 +3513,7 @@ int snd_hda_create_dig_out_ctls(struct hda_codec *codec,
 
 	idx = find_empty_mixer_ctl_idx(codec, "IEC958 Playback Switch", idx);
 	if (idx < 0) {
-		printk(KERN_ERR "hda_codec: too many IEC958 outputs\n");
+		codec_err(codec, "too many IEC958 outputs\n");
 		return -EBUSY;
 	}
 	spdif = snd_array_new(&codec->spdif_out);
@@ -3718,7 +3717,7 @@ int snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid)
 
 	idx = find_empty_mixer_ctl_idx(codec, "IEC958 Capture Switch", 0);
 	if (idx < 0) {
-		printk(KERN_ERR "hda_codec: too many IEC958 inputs\n");
+		codec_err(codec, "too many IEC958 inputs\n");
 		return -EBUSY;
 	}
 	for (dig_mix = dig_in_ctls; dig_mix->name; dig_mix++) {
@@ -4145,12 +4144,13 @@ int snd_hda_build_controls(struct hda_bus *bus)
 	list_for_each_entry(codec, &bus->codec_list, list) {
 		int err = snd_hda_codec_build_controls(codec);
 		if (err < 0) {
-			printk(KERN_ERR "hda_codec: cannot build controls "
-			       "for #%d (error %d)\n", codec->addr, err);
+			codec_err(codec,
+				  "cannot build controls for #%d (error %d)\n",
+				  codec->addr, err);
 			err = snd_hda_codec_reset(codec);
 			if (err < 0) {
-				printk(KERN_ERR
-				       "hda_codec: cannot revert codec\n");
+				codec_err(codec,
+					  "cannot revert codec\n");
 				return err;
 			}
 		}
@@ -4321,7 +4321,7 @@ unsigned int snd_hda_calc_stream_format(unsigned int rate,
 		break;
 	default:
 		snd_printdd("invalid format width %d\n",
-			    snd_pcm_format_width(format));
+			  snd_pcm_format_width(format));
 		return 0;
 	}
 
@@ -4397,10 +4397,10 @@ int snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,
 				rates |= rate_bits[i].alsa_bits;
 		}
 		if (rates == 0) {
-			snd_printk(KERN_ERR "hda_codec: rates == 0 "
-				   "(nid=0x%x, val=0x%x, ovrd=%i)\n",
-					nid, val,
-					(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);
+			codec_err(codec,
+				  "rates == 0 (nid=0x%x, val=0x%x, ovrd=%i)\n",
+				  nid, val,
+				  (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);
 			return -EIO;
 		}
 		*ratesp = rates;
@@ -4460,12 +4460,11 @@ int snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,
 			bps = 8;
 		}
 		if (formats == 0) {
-			snd_printk(KERN_ERR "hda_codec: formats == 0 "
-				   "(nid=0x%x, val=0x%x, ovrd=%i, "
-				   "streams=0x%x)\n",
-					nid, val,
-					(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,
-					streams);
+			codec_err(codec,
+				  "formats == 0 (nid=0x%x, val=0x%x, ovrd=%i, streams=0x%x)\n",
+				  nid, val,
+				  (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,
+				  streams);
 			return -EIO;
 		}
 		if (formatsp)
@@ -4656,7 +4655,7 @@ static int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)
 	int i;
 
 	if (type >= HDA_PCM_NTYPES) {
-		snd_printk(KERN_WARNING "Invalid PCM type %d\n", type);
+		dev_err(bus->card->dev, "Invalid PCM type %d\n", type);
 		return -EINVAL;
 	}
 
@@ -4677,10 +4676,11 @@ static int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)
 	}
 #endif
 
-	snd_printk(KERN_WARNING "Too many %s devices\n",
+	dev_warn(bus->card->dev, "Too many %s devices\n",
 		snd_hda_pcm_type_name[type]);
 #ifndef CONFIG_SND_DYNAMIC_MINORS
-	snd_printk(KERN_WARNING "Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\n");
+	dev_warn(bus->card->dev,
+		 "Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\n");
 #endif
 	return -EAGAIN;
 }
@@ -4718,12 +4718,13 @@ int snd_hda_codec_build_pcms(struct hda_codec *codec)
 			return 0;
 		err = codec->patch_ops.build_pcms(codec);
 		if (err < 0) {
-			printk(KERN_ERR "hda_codec: cannot build PCMs"
-			       "for #%d (error %d)\n", codec->addr, err);
+			codec_err(codec,
+				  "cannot build PCMs for #%d (error %d)\n",
+				  codec->addr, err);
 			err = snd_hda_codec_reset(codec);
 			if (err < 0) {
-				printk(KERN_ERR
-				       "hda_codec: cannot revert codec\n");
+				codec_err(codec,
+					  "cannot revert codec\n");
 				return err;
 			}
 		}
@@ -4742,9 +4743,9 @@ int snd_hda_codec_build_pcms(struct hda_codec *codec)
 			cpcm->device = dev;
 			err = snd_hda_attach_pcm(codec, cpcm);
 			if (err < 0) {
-				printk(KERN_ERR "hda_codec: cannot attach "
-				       "PCM stream %d for codec #%d\n",
-				       dev, codec->addr);
+				codec_err(codec,
+					  "cannot attach PCM stream %d for codec #%d\n",
+					  dev, codec->addr);
 				continue; /* no fatal error */
 			}
 		}
@@ -4813,8 +4814,8 @@ int snd_hda_check_board_config(struct hda_codec *codec,
 		for (i = 0; i < num_configs; i++) {
 			if (models[i] &&
 			    !strcmp(codec->modelname, models[i])) {
-				snd_printd(KERN_INFO "hda_codec: model '%s' is "
-					   "selected\n", models[i]);
+				codec_info(codec, "model '%s' is selected\n",
+					   models[i]);
 				return i;
 			}
 		}
@@ -4836,10 +4837,9 @@ int snd_hda_check_board_config(struct hda_codec *codec,
 			sprintf(tmp, "#%d", tbl->value);
 			model = tmp;
 		}
-		snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
-			    "for config %x:%x (%s)\n",
-			    model, tbl->subvendor, tbl->subdevice,
-			    (tbl->name ? tbl->name : "Unknown device"));
+		codec_info(codec, "model '%s' is selected for config %x:%x (%s)\n",
+			   model, tbl->subvendor, tbl->subdevice,
+			   (tbl->name ? tbl->name : "Unknown device"));
 #endif
 		return tbl->value;
 	}
@@ -4897,10 +4897,9 @@ int snd_hda_check_board_codec_sid_config(struct hda_codec *codec,
 			sprintf(tmp, "#%d", tbl->value);
 			model = tmp;
 		}
-		snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
-			    "for config %x:%x (%s)\n",
-			    model, tbl->subvendor, tbl->subdevice,
-			    (tbl->name ? tbl->name : "Unknown device"));
+		codec_info(codec, "model '%s' is selected for config %x:%x (%s)\n",
+			   model, tbl->subvendor, tbl->subdevice,
+			   (tbl->name ? tbl->name : "Unknown device"));
 #endif
 		return tbl->value;
 	}
diff --git a/sound/pci/hda/hda_eld.c b/sound/pci/hda/hda_eld.c
index 79ca80f6c77a..46690a7f48f6 100644
--- a/sound/pci/hda/hda_eld.c
+++ b/sound/pci/hda/hda_eld.c
@@ -153,7 +153,7 @@ static unsigned int hdmi_get_eld_data(struct hda_codec *codec, hda_nid_t nid,
 	val = snd_hda_codec_read(codec, nid, 0,
 					AC_VERB_GET_HDMI_ELDD, byte_index);
 #ifdef BE_PARANOID
-	printk(KERN_INFO "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);
+	codec_info(codec, "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);
 #endif
 	return val;
 }
@@ -332,11 +332,11 @@ int snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,
 	size = snd_hdmi_get_eld_size(codec, nid);
 	if (size == 0) {
 		/* wfg: workaround for ASUS P5E-VM HDMI board */
-		snd_printd(KERN_INFO "HDMI: ELD buf size is 0, force 128\n");
+		codec_info(codec, "HDMI: ELD buf size is 0, force 128\n");
 		size = 128;
 	}
 	if (size < ELD_FIXED_BYTES || size > ELD_MAX_SIZE) {
-		snd_printd(KERN_INFO "HDMI: invalid ELD buf size %d\n", size);
+		codec_info(codec, "HDMI: invalid ELD buf size %d\n", size);
 		return -ERANGE;
 	}
 
@@ -348,8 +348,7 @@ int snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,
 		 * Just abort. The caller will repoll after a while.
 		 */
 		if (!(val & AC_ELDD_ELD_VALID)) {
-			snd_printd(KERN_INFO
-				  "HDMI: invalid ELD data byte %d\n", i);
+			codec_info(codec, "HDMI: invalid ELD data byte %d\n", i);
 			ret = -EINVAL;
 			goto error;
 		}
@@ -361,7 +360,7 @@ int snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,
 		 * correctly writes ELD content before setting ELD_valid bit.
 		 */
 		if (!val && !i) {
-			snd_printdd(KERN_INFO "HDMI: 0 ELD data\n");
+			codec_dbg(codec, "HDMI: 0 ELD data\n");
 			ret = -EINVAL;
 			goto error;
 		}
@@ -681,7 +680,7 @@ int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
 	spkalloc = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SPEAKER_ALLOCATION, 0);
 
 	if (spkalloc <= 0) {
-		snd_printd(KERN_INFO "HDMI ATI/AMD: no speaker allocation for ELD\n");
+		codec_info(codec, "HDMI ATI/AMD: no speaker allocation for ELD\n");
 		return -EINVAL;
 	}
 
@@ -722,7 +721,7 @@ int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
 		sink_desc_len = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
 
 		if (sink_desc_len > ELD_MAX_MNL) {
-			snd_printd(KERN_INFO "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",
+			codec_info(codec, "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",
 				   sink_desc_len);
 			sink_desc_len = ELD_MAX_MNL;
 		}
@@ -764,7 +763,7 @@ int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
 	}
 
 	if (pos == ELD_FIXED_BYTES + sink_desc_len) {
-		snd_printd(KERN_INFO "HDMI ATI/AMD: no audio descriptors for ELD\n");
+		codec_info(codec, "HDMI ATI/AMD: no audio descriptors for ELD\n");
 		return -EINVAL;
 	}
 
diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c
index 5820a74b5781..820a74325250 100644
--- a/sound/pci/hda/hda_generic.c
+++ b/sound/pci/hda/hda_generic.c
@@ -347,7 +347,8 @@ static bool is_ctl_associated(struct hda_codec *codec, hda_nid_t nid,
 	return is_ctl_used(codec, val, type);
 }
 
-static void print_nid_path(const char *pfx, struct nid_path *path)
+static void print_nid_path(struct hda_codec *codec,
+			   const char *pfx, struct nid_path *path)
 {
 	char buf[40];
 	int i;
@@ -359,7 +360,7 @@ static void print_nid_path(const char *pfx, struct nid_path *path)
 		sprintf(tmp, ":%02x", path->path[i]);
 		strlcat(buf, tmp, sizeof(buf));
 	}
-	snd_printdd("%s path: depth=%d %s\n", pfx, path->depth, buf);
+	codec_dbg(codec, "%s path: depth=%d %s\n", pfx, path->depth, buf);
 }
 
 /* called recursively */
@@ -1261,7 +1262,7 @@ static int try_assign_dacs(struct hda_codec *codec, int num_outs,
 			dac = dacs[i] = 0;
 			badness += bad->no_dac;
 		} else {
-			/* print_nid_path("output", path); */
+			/* print_nid_path(codec, "output", path); */
 			path->active = true;
 			path_idx[i] = snd_hda_get_path_idx(codec, path);
 			badness += assign_out_path_ctls(codec, path);
@@ -1388,7 +1389,7 @@ static int fill_multi_ios(struct hda_codec *codec,
 				badness++;
 				continue;
 			}
-			/* print_nid_path("multiio", path); */
+			/* print_nid_path(codec, "multiio", path); */
 			spec->multi_io[spec->multi_ios].pin = nid;
 			spec->multi_io[spec->multi_ios].dac = dac;
 			spec->out_paths[cfg->line_outs + spec->multi_ios] =
@@ -1445,7 +1446,7 @@ static bool map_singles(struct hda_codec *codec, int outs,
 		if (path) {
 			dacs[i] = dac;
 			found = true;
-			/* print_nid_path("output", path); */
+			/* print_nid_path(codec, "output", path); */
 			path->active = true;
 			path_idx[i] = snd_hda_get_path_idx(codec, path);
 		}
@@ -1483,7 +1484,7 @@ static int check_aamix_out_path(struct hda_codec *codec, int path_idx)
 	}
 	if (!path)
 		return 0;
-	/* print_nid_path("output-aamix", path); */
+	/* print_nid_path(codec, "output-aamix", path); */
 	path->active = false; /* unused as default */
 	return snd_hda_get_path_idx(codec, path);
 }
@@ -1700,7 +1701,7 @@ static int fill_and_eval_dacs(struct hda_codec *codec,
 #define DEBUG_BADNESS
 
 #ifdef DEBUG_BADNESS
-#define debug_badness	snd_printdd
+#define debug_badness(fmt, args...)	codec_dbg(codec, fmt, ##args)
 #else
 #define debug_badness(...)
 #endif
@@ -1713,7 +1714,7 @@ static inline void print_nid_path_idx(struct hda_codec *codec,
 
 	path = snd_hda_get_path_from_idx(codec, idx);
 	if (path)
-		print_nid_path(pfx, path);
+		print_nid_path(codec, pfx, path);
 }
 
 static void debug_show_configs(struct hda_codec *codec,
@@ -1781,7 +1782,7 @@ static void fill_all_dac_nids(struct hda_codec *codec)
 		if (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_AUD_OUT)
 			continue;
 		if (spec->num_all_dacs >= ARRAY_SIZE(spec->all_dacs)) {
-			snd_printk(KERN_ERR "hda: Too many DACs!\n");
+			codec_err(codec, "Too many DACs!\n");
 			break;
 		}
 		spec->all_dacs[spec->num_all_dacs++] = nid;
@@ -2430,7 +2431,7 @@ static int create_hp_mic(struct hda_codec *codec)
 	spec->hp_mic_pin = nid;
 	/* we can't handle auto-mic together with HP-mic */
 	spec->suppress_auto_mic = 1;
-	snd_printdd("hda-codec: Enable shared I/O jack on NID 0x%x\n", nid);
+	codec_dbg(codec, "Enable shared I/O jack on NID 0x%x\n", nid);
 	return 0;
 }
 
@@ -2884,7 +2885,7 @@ static int new_analog_input(struct hda_codec *codec, int input_idx,
 	path = snd_hda_add_new_path(codec, pin, mix_nid, 0);
 	if (!path)
 		return -EINVAL;
-	print_nid_path("loopback", path);
+	print_nid_path(codec, "loopback", path);
 	spec->loopback_paths[input_idx] = snd_hda_get_path_idx(codec, path);
 
 	idx = path->idx[path->depth - 1];
@@ -2912,7 +2913,7 @@ static int new_analog_input(struct hda_codec *codec, int input_idx,
 		path = snd_hda_add_new_path(codec, spec->mixer_nid,
 					    spec->mixer_merge_nid, 0);
 		if (path) {
-			print_nid_path("loopback-merge", path);
+			print_nid_path(codec, "loopback-merge", path);
 			path->active = true;
 			spec->loopback_merge_path =
 				snd_hda_get_path_idx(codec, path);
@@ -2991,7 +2992,7 @@ static int check_dyn_adc_switch(struct hda_codec *codec)
 			}
 		}
 
-		snd_printdd("hda-codec: enabling ADC switching\n");
+		codec_dbg(codec, "enabling ADC switching\n");
 		spec->dyn_adc_switch = 1;
 	} else if (nums != spec->num_adc_nids) {
 		/* shrink the invalid adcs and input paths */
@@ -3015,7 +3016,7 @@ static int check_dyn_adc_switch(struct hda_codec *codec)
 
 	if (imux->num_items == 1 ||
 	    (imux->num_items == 2 && spec->hp_mic)) {
-		snd_printdd("hda-codec: reducing to a single ADC\n");
+		codec_dbg(codec, "reducing to a single ADC\n");
 		spec->num_adc_nids = 1; /* reduce to a single ADC */
 	}
 
@@ -3046,7 +3047,7 @@ static int parse_capture_source(struct hda_codec *codec, hda_nid_t pin,
 		path = snd_hda_add_new_path(codec, pin, adc, anchor);
 		if (!path)
 			continue;
-		print_nid_path("input", path);
+		print_nid_path(codec, "input", path);
 		spec->input_paths[imux_idx][c] =
 			snd_hda_get_path_idx(codec, path);
 
@@ -3712,7 +3713,7 @@ static void parse_digital(struct hda_codec *codec)
 		path = snd_hda_add_new_path(codec, dig_nid, pin, 0);
 		if (!path)
 			continue;
-		print_nid_path("digout", path);
+		print_nid_path(codec, "digout", path);
 		path->active = true;
 		spec->digout_paths[i] = snd_hda_get_path_idx(codec, path);
 		set_pin_target(codec, pin, PIN_OUT, false);
@@ -3739,7 +3740,7 @@ static void parse_digital(struct hda_codec *codec)
 				continue;
 			path = snd_hda_add_new_path(codec, pin, dig_nid, 0);
 			if (path) {
-				print_nid_path("digin", path);
+				print_nid_path(codec, "digin", path);
 				path->active = true;
 				spec->dig_in_nid = dig_nid;
 				spec->digin_path = snd_hda_get_path_idx(codec, path);
@@ -4170,8 +4171,7 @@ static int check_auto_mute_availability(struct hda_codec *codec)
 		hda_nid_t nid = cfg->hp_pins[i];
 		if (!is_jack_detectable(codec, nid))
 			continue;
-		snd_printdd("hda-codec: Enable HP auto-muting on NID 0x%x\n",
-			    nid);
+		codec_dbg(codec, "Enable HP auto-muting on NID 0x%x\n", nid);
 		snd_hda_jack_detect_enable_callback(codec, nid, HDA_GEN_HP_EVENT,
 						    call_hp_automute);
 		spec->detect_hp = 1;
@@ -4183,7 +4183,7 @@ static int check_auto_mute_availability(struct hda_codec *codec)
 				hda_nid_t nid = cfg->line_out_pins[i];
 				if (!is_jack_detectable(codec, nid))
 					continue;
-				snd_printdd("hda-codec: Enable Line-Out auto-muting on NID 0x%x\n", nid);
+				codec_dbg(codec, "Enable Line-Out auto-muting on NID 0x%x\n", nid);
 				snd_hda_jack_detect_enable_callback(codec, nid,
 								    HDA_GEN_FRONT_EVENT,
 								    call_line_automute);
@@ -4303,7 +4303,7 @@ static int check_auto_mic_availability(struct hda_codec *codec)
 	spec->auto_mic = 1;
 	spec->num_adc_nids = 1;
 	spec->cur_mux[0] = spec->am_entry[0].idx;
-	snd_printdd("hda-codec: Enable auto-mic switch on NID 0x%x/0x%x/0x%x\n",
+	codec_dbg(codec, "Enable auto-mic switch on NID 0x%x/0x%x/0x%x\n",
 		    spec->am_entry[0].pin,
 		    spec->am_entry[1].pin,
 		    spec->am_entry[2].pin);
diff --git a/sound/pci/hda/hda_i915.c b/sound/pci/hda/hda_i915.c
index 76c13d5b3ca0..9d07e4edacdb 100644
--- a/sound/pci/hda/hda_i915.c
+++ b/sound/pci/hda/hda_i915.c
@@ -30,7 +30,7 @@ void hda_display_power(bool enable)
 	if (!get_power || !put_power)
 		return;
 
-	snd_printdd("HDA display power %s \n",
+	pr_debug("HDA display power %s \n",
 			enable ? "Enable" : "Disable");
 	if (enable)
 		get_power();
@@ -44,7 +44,7 @@ int hda_i915_init(void)
 
 	get_power = symbol_request(i915_request_power_well);
 	if (!get_power) {
-		snd_printk(KERN_WARNING "hda-i915: get_power symbol get fail\n");
+		pr_warn("hda-i915: get_power symbol get fail\n");
 		return -ENODEV;
 	}
 
@@ -55,7 +55,7 @@ int hda_i915_init(void)
 		return -ENODEV;
 	}
 
-	snd_printd("HDA driver get symbol successfully from i915 module\n");
+	pr_debug("HDA driver get symbol successfully from i915 module\n");
 
 	return err;
 }
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 5a3d4e2492c7..14b0a4944160 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -191,12 +191,6 @@ MODULE_SUPPORTED_DEVICE("{{Intel, ICH6},"
 			 "{ULI, M5461}}");
 MODULE_DESCRIPTION("Intel HDA driver");
 
-#ifdef CONFIG_SND_VERBOSE_PRINTK
-#define SFX	/* nop */
-#else
-#define SFX	"hda-intel "
-#endif
-
 #if defined(CONFIG_PM) && defined(CONFIG_VGA_SWITCHEROO)
 #if IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)
 #define SUPPORT_VGA_SWITCHEROO
@@ -766,7 +760,7 @@ static int azx_alloc_cmd_io(struct azx *chip)
 				  snd_dma_pci_data(chip->pci),
 				  PAGE_SIZE, &chip->rb);
 	if (err < 0) {
-		snd_printk(KERN_ERR SFX "%s: cannot allocate CORB/RIRB\n", pci_name(chip->pci));
+		dev_err(chip->card->dev, "cannot allocate CORB/RIRB\n");
 		return err;
 	}
 	mark_pages_wc(chip, &chip->rb, true);
@@ -897,10 +891,9 @@ static void azx_update_rirb(struct azx *chip)
 		res = le32_to_cpu(chip->rirb.buf[rp]);
 		addr = res_ex & 0xf;
 		if ((addr >= AZX_MAX_CODECS) || !(chip->codec_mask & (1 << addr))) {
-			snd_printk(KERN_ERR SFX "%s: spurious response %#x:%#x, rp = %d, wp = %d",
-				   pci_name(chip->pci),
-				   res, res_ex,
-				   chip->rirb.rp, wp);
+			dev_err(chip->card->dev, "spurious response %#x:%#x, rp = %d, wp = %d",
+				res, res_ex,
+				chip->rirb.rp, wp);
 			snd_BUG();
 		}
 		else if (res_ex & ICH6_RIRB_EX_UNSOL_EV)
@@ -910,10 +903,9 @@ static void azx_update_rirb(struct azx *chip)
 			smp_wmb();
 			chip->rirb.cmds[addr]--;
 		} else if (printk_ratelimit()) {
-			snd_printk(KERN_ERR SFX "%s: spurious response %#x:%#x, last cmd=%#08x\n",
-				   pci_name(chip->pci),
-				   res, res_ex,
-				   chip->last_cmd[addr]);
+			dev_err(chip->card->dev, "spurious response %#x:%#x, last cmd=%#08x\n",
+				res, res_ex,
+				chip->last_cmd[addr]);
 		}
 	}
 }
@@ -958,9 +950,9 @@ static unsigned int azx_rirb_get_response(struct hda_bus *bus,
 		return -1;
 
 	if (!chip->polling_mode && chip->poll_count < 2) {
-		snd_printdd(SFX "%s: azx_get_response timeout, "
-			   "polling the codec once: last cmd=0x%08x\n",
-			   pci_name(chip->pci), chip->last_cmd[addr]);
+		dev_dbg(chip->card->dev,
+			"azx_get_response timeout, polling the codec once: last cmd=0x%08x\n",
+			chip->last_cmd[addr]);
 		do_poll = 1;
 		chip->poll_count++;
 		goto again;
@@ -968,17 +960,17 @@ static unsigned int azx_rirb_get_response(struct hda_bus *bus,
 
 
 	if (!chip->polling_mode) {
-		snd_printk(KERN_WARNING SFX "%s: azx_get_response timeout, "
-			   "switching to polling mode: last cmd=0x%08x\n",
-			   pci_name(chip->pci), chip->last_cmd[addr]);
+		dev_warn(chip->card->dev,
+			 "azx_get_response timeout, switching to polling mode: last cmd=0x%08x\n",
+			 chip->last_cmd[addr]);
 		chip->polling_mode = 1;
 		goto again;
 	}
 
 	if (chip->msi) {
-		snd_printk(KERN_WARNING SFX "%s: No response from codec, "
-			   "disabling MSI: last cmd=0x%08x\n",
-			   pci_name(chip->pci), chip->last_cmd[addr]);
+		dev_warn(chip->card->dev,
+			 "No response from codec, disabling MSI: last cmd=0x%08x\n",
+			 chip->last_cmd[addr]);
 		free_irq(chip->irq, chip);
 		chip->irq = -1;
 		pci_disable_msi(chip->pci);
@@ -1007,9 +999,9 @@ static unsigned int azx_rirb_get_response(struct hda_bus *bus,
 		return -1; /* give a chance to retry */
 	}
 
-	snd_printk(KERN_ERR "hda_intel: azx_get_response timeout, "
-		   "switching to single_cmd mode: last cmd=0x%08x\n",
-		   chip->last_cmd[addr]);
+	dev_err(chip->card->dev,
+		"azx_get_response timeout, switching to single_cmd mode: last cmd=0x%08x\n",
+		chip->last_cmd[addr]);
 	chip->single_cmd = 1;
 	bus->response_reset = 0;
 	/* release CORB/RIRB */
@@ -1044,8 +1036,8 @@ static int azx_single_wait_for_response(struct azx *chip, unsigned int addr)
 		udelay(1);
 	}
 	if (printk_ratelimit())
-		snd_printd(SFX "%s: get_response timeout: IRS=0x%x\n",
-			   pci_name(chip->pci), azx_readw(chip, IRS));
+		dev_dbg(chip->card->dev, "get_response timeout: IRS=0x%x\n",
+			azx_readw(chip, IRS));
 	chip->rirb.res[addr] = -1;
 	return -EIO;
 }
@@ -1072,8 +1064,9 @@ static int azx_single_send_cmd(struct hda_bus *bus, u32 val)
 		udelay(1);
 	}
 	if (printk_ratelimit())
-		snd_printd(SFX "%s: send_cmd timeout: IRS=0x%x, val=0x%x\n",
-			   pci_name(chip->pci), azx_readw(chip, IRS), val);
+		dev_dbg(chip->card->dev,
+			"send_cmd timeout: IRS=0x%x, val=0x%x\n",
+			azx_readw(chip, IRS), val);
 	return -EIO;
 }
 
@@ -1185,7 +1178,7 @@ static int azx_reset(struct azx *chip, int full_reset)
       __skip:
 	/* check to see if controller is ready */
 	if (!azx_readb(chip, GCTL)) {
-		snd_printd(SFX "%s: azx_reset: controller not ready!\n", pci_name(chip->pci));
+		dev_dbg(chip->card->dev, "azx_reset: controller not ready!\n");
 		return -EBUSY;
 	}
 
@@ -1197,7 +1190,8 @@ static int azx_reset(struct azx *chip, int full_reset)
 	/* detect codecs */
 	if (!chip->codec_mask) {
 		chip->codec_mask = azx_readw(chip, STATESTS);
-		snd_printdd(SFX "%s: codec_mask = 0x%x\n", pci_name(chip->pci), chip->codec_mask);
+		dev_dbg(chip->card->dev, "codec_mask = 0x%x\n",
+			chip->codec_mask);
 	}
 
 	return 0;
@@ -1341,7 +1335,7 @@ static void azx_init_pci(struct azx *chip)
 	 * The PCI register TCSEL is defined in the Intel manuals.
 	 */
 	if (!(chip->driver_caps & AZX_DCAPS_NO_TCSEL)) {
-		snd_printdd(SFX "%s: Clearing TCSEL\n", pci_name(chip->pci));
+		dev_dbg(chip->card->dev, "Clearing TCSEL\n");
 		update_pci_byte(chip->pci, ICH6_PCIREG_TCSEL, 0x07, 0);
 	}
 
@@ -1349,7 +1343,8 @@ static void azx_init_pci(struct azx *chip)
 	 * we need to enable snoop.
 	 */
 	if (chip->driver_caps & AZX_DCAPS_ATI_SNOOP) {
-		snd_printdd(SFX "%s: Setting ATI snoop: %d\n", pci_name(chip->pci), azx_snoop(chip));
+		dev_dbg(chip->card->dev, "Setting ATI snoop: %d\n",
+			azx_snoop(chip));
 		update_pci_byte(chip->pci,
 				ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR, 0x07,
 				azx_snoop(chip) ? ATI_SB450_HDAUDIO_ENABLE_SNOOP : 0);
@@ -1357,7 +1352,8 @@ static void azx_init_pci(struct azx *chip)
 
 	/* For NVIDIA HDA, enable snoop */
 	if (chip->driver_caps & AZX_DCAPS_NVIDIA_SNOOP) {
-		snd_printdd(SFX "%s: Setting Nvidia snoop: %d\n", pci_name(chip->pci), azx_snoop(chip));
+		dev_dbg(chip->card->dev, "Setting Nvidia snoop: %d\n",
+			azx_snoop(chip));
 		update_pci_byte(chip->pci,
 				NVIDIA_HDA_TRANSREG_ADDR,
 				0x0f, NVIDIA_HDA_ENABLE_COHBITS);
@@ -1382,9 +1378,9 @@ static void azx_init_pci(struct azx *chip)
 			pci_read_config_word(chip->pci,
 				INTEL_SCH_HDA_DEVC, &snoop);
 		}
-		snd_printdd(SFX "%s: SCH snoop: %s\n",
-				pci_name(chip->pci), (snoop & INTEL_SCH_HDA_DEVC_NOSNOOP)
-				? "Disabled" : "Enabled");
+		dev_dbg(chip->card->dev, "SCH snoop: %s\n",
+			(snoop & INTEL_SCH_HDA_DEVC_NOSNOOP) ?
+			"Disabled" : "Enabled");
         }
 }
 
@@ -1544,8 +1540,8 @@ static int azx_setup_periods(struct azx *chip,
 				pos_align;
 		pos_adj = frames_to_bytes(runtime, pos_adj);
 		if (pos_adj >= period_bytes) {
-			snd_printk(KERN_WARNING SFX "%s: Too big adjustment %d\n",
-				   pci_name(chip->pci), bdl_pos_adj[chip->dev_index]);
+			dev_warn(chip->card->dev,"Too big adjustment %d\n",
+				 bdl_pos_adj[chip->dev_index]);
 			pos_adj = 0;
 		} else {
 			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
@@ -1572,8 +1568,8 @@ static int azx_setup_periods(struct azx *chip,
 	return 0;
 
  error:
-	snd_printk(KERN_ERR SFX "%s: Too many BDL entries: buffer=%d, period=%d\n",
-		   pci_name(chip->pci), azx_dev->bufsize, period_bytes);
+	dev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",
+		azx_dev->bufsize, period_bytes);
 	return -EINVAL;
 }
 
@@ -1670,7 +1666,7 @@ static int probe_codec(struct azx *chip, int addr)
 	mutex_unlock(&chip->bus->cmd_mutex);
 	if (res == -1)
 		return -EIO;
-	snd_printdd(SFX "%s: codec #%d probed OK\n", pci_name(chip->pci), addr);
+	dev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);
 	return 0;
 }
 
@@ -1708,8 +1704,8 @@ static int get_jackpoll_interval(struct azx *chip)
 	else
 		j = msecs_to_jiffies(i);
 	if (j == 0)
-		snd_printk(KERN_WARNING SFX
-			   "jackpoll_ms value out of range: %d\n", i);
+		dev_warn(chip->card->dev,
+			 "jackpoll_ms value out of range: %d\n", i);
 	return j;
 }
 
@@ -1752,7 +1748,7 @@ static int azx_codec_create(struct azx *chip, const char *model)
 		return err;
 
 	if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
-		snd_printd(SFX "%s: Enable delay in RIRB handling\n", pci_name(chip->pci));
+		dev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");
 		chip->bus->needs_damn_long_delay = 1;
 	}
 
@@ -1768,9 +1764,8 @@ static int azx_codec_create(struct azx *chip, const char *model)
 				/* Some BIOSen give you wrong codec addresses
 				 * that don't exist
 				 */
-				snd_printk(KERN_WARNING SFX
-					   "%s: Codec #%d probe error; "
-					   "disabling it...\n", pci_name(chip->pci), c);
+				dev_warn(chip->card->dev,
+					 "Codec #%d probe error; disabling it...\n", c);
 				chip->codec_mask &= ~(1 << c);
 				/* More badly, accessing to a non-existing
 				 * codec often screws up the controller chip,
@@ -1790,8 +1785,7 @@ static int azx_codec_create(struct azx *chip, const char *model)
 	 * access works around the stall.  Grrr...
 	 */
 	if (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {
-		snd_printd(SFX "%s: Enable sync_write for stable communication\n",
-			pci_name(chip->pci));
+		dev_dbg(chip->card->dev, "Enable sync_write for stable communication\n");
 		chip->bus->sync_write = 1;
 		chip->bus->allow_bus_reset = 1;
 	}
@@ -1809,7 +1803,7 @@ static int azx_codec_create(struct azx *chip, const char *model)
 		}
 	}
 	if (!codecs) {
-		snd_printk(KERN_ERR SFX "%s: no codecs initialized\n", pci_name(chip->pci));
+		dev_err(chip->card->dev, "no codecs initialized\n");
 		return -ENXIO;
 	}
 	return 0;
@@ -2166,9 +2160,9 @@ static int azx_pcm_prepare(struct snd_pcm_substream *substream)
 						hinfo->maxbps,
 						ctls);
 	if (!format_val) {
-		snd_printk(KERN_ERR SFX
-			   "%s: invalid format_val, rate=%d, ch=%d, format=%d\n",
-			   pci_name(chip->pci), runtime->rate, runtime->channels, runtime->format);
+		dev_err(chip->card->dev,
+			"invalid format_val, rate=%d, ch=%d, format=%d\n",
+			runtime->rate, runtime->channels, runtime->format);
 		err = -EINVAL;
 		goto unlock;
 	}
@@ -2176,8 +2170,8 @@ static int azx_pcm_prepare(struct snd_pcm_substream *substream)
 	bufsize = snd_pcm_lib_buffer_bytes(substream);
 	period_bytes = snd_pcm_lib_period_bytes(substream);
 
-	snd_printdd(SFX "%s: azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
-		    pci_name(chip->pci), bufsize, format_val);
+	dev_dbg(chip->card->dev, "azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
+		bufsize, format_val);
 
 	if (bufsize != azx_dev->bufsize ||
 	    period_bytes != azx_dev->period_bytes ||
@@ -2430,9 +2424,8 @@ static unsigned int azx_get_position(struct azx *chip,
 		pos = le32_to_cpu(*azx_dev->posbuf);
 		if (with_check && chip->position_fix[stream] == POS_FIX_AUTO) {
 			if (!pos || pos == (u32)-1) {
-				printk(KERN_WARNING
-				       "hda-intel: Invalid position buffer, "
-				       "using LPIB read method instead.\n");
+				dev_info(chip->card->dev,
+					 "Invalid position buffer, using LPIB read method instead.\n");
 				chip->position_fix[stream] = POS_FIX_LPIB;
 				pos = azx_sd_readl(azx_dev, SD_LPIB);
 			} else
@@ -2460,10 +2453,9 @@ static unsigned int azx_get_position(struct azx *chip,
 				delay += azx_dev->bufsize;
 		}
 		if (delay >= azx_dev->period_bytes) {
-			snd_printk(KERN_WARNING SFX
-				   "%s: Unstable LPIB (%d >= %d); "
-				   "disabling LPIB delay counting\n",
-				   pci_name(chip->pci), delay, azx_dev->period_bytes);
+			dev_info(chip->card->dev,
+				 "Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",
+				 delay, azx_dev->period_bytes);
 			delay = 0;
 			chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
 		}
@@ -2530,10 +2522,9 @@ static void azx_irq_pending_work(struct work_struct *work)
 	int i, pending, ok;
 
 	if (!chip->irq_pending_warned) {
-		printk(KERN_WARNING
-		       "hda-intel: IRQ timing workaround is activated "
-		       "for card #%d. Suggest a bigger bdl_pos_adj.\n",
-		       chip->card->number);
+		dev_info(chip->card->dev,
+			 "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
+			 chip->card->number);
 		chip->irq_pending_warned = 1;
 	}
 
@@ -2627,8 +2618,8 @@ azx_attach_pcm_stream(struct hda_bus *bus, struct hda_codec *codec,
 
 	list_for_each_entry(apcm, &chip->pcm_list, list) {
 		if (apcm->pcm->device == pcm_dev) {
-			snd_printk(KERN_ERR SFX "%s: PCM %d already exists\n",
-				   pci_name(chip->pci), pcm_dev);
+			dev_err(chip->card->dev, "PCM %d already exists\n",
+				pcm_dev);
 			return -EBUSY;
 		}
 	}
@@ -2708,8 +2699,9 @@ static int azx_acquire_irq(struct azx *chip, int do_disconnect)
 	if (request_irq(chip->pci->irq, azx_interrupt,
 			chip->msi ? 0 : IRQF_SHARED,
 			KBUILD_MODNAME, chip)) {
-		printk(KERN_ERR "hda-intel: unable to grab IRQ %d, "
-		       "disabling device\n", chip->pci->irq);
+		dev_err(chip->card->dev,
+			"unable to grab IRQ %d, disabling device\n",
+			chip->pci->irq);
 		if (do_disconnect)
 			snd_card_disconnect(chip->card);
 		return -1;
@@ -2966,8 +2958,8 @@ static int azx_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "hda-intel: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(chip->card->dev,
+			"pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}
@@ -3124,20 +3116,16 @@ static void azx_vs_set_state(struct pci_dev *pci,
 	if (!chip->bus) {
 		chip->disabled = disabled;
 		if (!disabled) {
-			snd_printk(KERN_INFO SFX
-				   "%s: Start delayed initialization\n",
-				   pci_name(chip->pci));
+			dev_info(chip->card->dev,
+				 "Start delayed initialization\n");
 			if (azx_probe_continue(chip) < 0) {
-				snd_printk(KERN_ERR SFX
-					   "%s: initialization error\n",
-					   pci_name(chip->pci));
+				dev_err(chip->card->dev, "initialization error\n");
 				chip->init_failed = true;
 			}
 		}
 	} else {
-		snd_printk(KERN_INFO SFX
-			   "%s: %s via VGA-switcheroo\n", pci_name(chip->pci),
-			   disabled ? "Disabling" : "Enabling");
+		dev_info(chip->card->dev, "%s via VGA-switcheroo\n",
+			 disabled ? "Disabling" : "Enabling");
 		if (disabled) {
 			pm_runtime_put_sync_suspend(&pci->dev);
 			azx_suspend(&pci->dev);
@@ -3147,8 +3135,8 @@ static void azx_vs_set_state(struct pci_dev *pci,
 			pci->current_state = PCI_D3cold;
 			chip->disabled = true;
 			if (snd_hda_lock_devices(chip->bus))
-				snd_printk(KERN_WARNING SFX "%s: Cannot lock devices!\n",
-					   pci_name(chip->pci));
+				dev_warn(chip->card->dev,
+					 "Cannot lock devices!\n");
 		} else {
 			snd_hda_unlock_devices(chip->bus);
 			pm_runtime_get_noresume(&pci->dev);
@@ -3178,9 +3166,8 @@ static void init_vga_switcheroo(struct azx *chip)
 {
 	struct pci_dev *p = get_bound_vga(chip->pci);
 	if (p) {
-		snd_printk(KERN_INFO SFX
-			   "%s: Handle VGA-switcheroo audio client\n",
-			   pci_name(chip->pci));
+		dev_info(chip->card->dev,
+			 "Handle VGA-switcheroo audio client\n");
 		chip->use_vga_switcheroo = 1;
 		pci_dev_put(p);
 	}
@@ -3371,20 +3358,19 @@ static int check_position_fix(struct azx *chip, int fix)
 
 	q = snd_pci_quirk_lookup(chip->pci, position_fix_list);
 	if (q) {
-		printk(KERN_INFO
-		       "hda_intel: position_fix set to %d "
-		       "for device %04x:%04x\n",
-		       q->value, q->subvendor, q->subdevice);
+		dev_info(chip->card->dev,
+			 "position_fix set to %d for device %04x:%04x\n",
+			 q->value, q->subvendor, q->subdevice);
 		return q->value;
 	}
 
 	/* Check VIA/ATI HD Audio Controller exist */
 	if (chip->driver_caps & AZX_DCAPS_POSFIX_VIA) {
-		snd_printd(SFX "%s: Using VIACOMBO position fix\n", pci_name(chip->pci));
+		dev_dbg(chip->card->dev, "Using VIACOMBO position fix\n");
 		return POS_FIX_VIACOMBO;
 	}
 	if (chip->driver_caps & AZX_DCAPS_POSFIX_LPIB) {
-		snd_printd(SFX "%s: Using LPIB position fix\n", pci_name(chip->pci));
+		dev_dbg(chip->card->dev, "Using LPIB position fix\n");
 		return POS_FIX_LPIB;
 	}
 	return POS_FIX_AUTO;
@@ -3422,10 +3408,9 @@ static void check_probe_mask(struct azx *chip, int dev)
 	if (chip->codec_probe_mask == -1) {
 		q = snd_pci_quirk_lookup(chip->pci, probe_mask_list);
 		if (q) {
-			printk(KERN_INFO
-			       "hda_intel: probe_mask set to 0x%x "
-			       "for device %04x:%04x\n",
-			       q->value, q->subvendor, q->subdevice);
+			dev_info(chip->card->dev,
+				 "probe_mask set to 0x%x for device %04x:%04x\n",
+				 q->value, q->subvendor, q->subdevice);
 			chip->codec_probe_mask = q->value;
 		}
 	}
@@ -3434,8 +3419,8 @@ static void check_probe_mask(struct azx *chip, int dev)
 	if (chip->codec_probe_mask != -1 &&
 	    (chip->codec_probe_mask & AZX_FORCE_CODEC_MASK)) {
 		chip->codec_mask = chip->codec_probe_mask & 0xff;
-		printk(KERN_INFO "hda_intel: codec_mask forced to 0x%x\n",
-		       chip->codec_mask);
+		dev_info(chip->card->dev, "codec_mask forced to 0x%x\n",
+			 chip->codec_mask);
 	}
 }
 
@@ -3467,16 +3452,16 @@ static void check_msi(struct azx *chip)
 	chip->msi = 1;	/* enable MSI as default */
 	q = snd_pci_quirk_lookup(chip->pci, msi_black_list);
 	if (q) {
-		printk(KERN_INFO
-		       "hda_intel: msi for device %04x:%04x set to %d\n",
-		       q->subvendor, q->subdevice, q->value);
+		dev_info(chip->card->dev,
+			 "msi for device %04x:%04x set to %d\n",
+			 q->subvendor, q->subdevice, q->value);
 		chip->msi = q->value;
 		return;
 	}
 
 	/* NVidia chipsets seem to cause troubles with MSI */
 	if (chip->driver_caps & AZX_DCAPS_NO_MSI) {
-		printk(KERN_INFO "hda_intel: Disabling MSI\n");
+		dev_info(chip->card->dev, "Disabling MSI\n");
 		chip->msi = 0;
 	}
 }
@@ -3508,8 +3493,8 @@ static void azx_check_snoop_available(struct azx *chip)
 	}
 
 	if (snoop != chip->snoop) {
-		snd_printk(KERN_INFO SFX "%s: Force to %s mode\n",
-			   pci_name(chip->pci), snoop ? "snoop" : "non-snoop");
+		dev_info(chip->card->dev, "Force to %s mode\n",
+			 snoop ? "snoop" : "non-snoop");
 		chip->snoop = snoop;
 	}
 }
@@ -3540,7 +3525,7 @@ static int azx_create(struct snd_card *card, struct pci_dev *pci,
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (!chip) {
-		snd_printk(KERN_ERR SFX "%s: Cannot allocate chip\n", pci_name(pci));
+		dev_err(card->dev, "Cannot allocate chip\n");
 		pci_disable_device(pci);
 		return -ENOMEM;
 	}
@@ -3588,8 +3573,7 @@ static int azx_create(struct snd_card *card, struct pci_dev *pci,
 
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0) {
-		snd_printk(KERN_ERR SFX "%s: Error creating device [card]!\n",
-		   pci_name(chip->pci));
+		dev_err(card->dev, "Error creating device [card]!\n");
 		azx_free(chip);
 		return err;
 	}
@@ -3628,7 +3612,7 @@ static int azx_first_init(struct azx *chip)
 	chip->addr = pci_resource_start(pci, 0);
 	chip->remap_addr = pci_ioremap_bar(pci, 0);
 	if (chip->remap_addr == NULL) {
-		snd_printk(KERN_ERR SFX "%s: ioremap error\n", pci_name(chip->pci));
+		dev_err(card->dev, "ioremap error\n");
 		return -ENXIO;
 	}
 
@@ -3643,7 +3627,7 @@ static int azx_first_init(struct azx *chip)
 	synchronize_irq(chip->irq);
 
 	gcap = azx_readw(chip, GCAP);
-	snd_printdd(SFX "%s: chipset global capabilities = 0x%x\n", pci_name(chip->pci), gcap);
+	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
 
 	/* disable SB600 64bit support for safety */
 	if (chip->pci->vendor == PCI_VENDOR_ID_ATI) {
@@ -3660,7 +3644,7 @@ static int azx_first_init(struct azx *chip)
 
 	/* disable 64bit DMA address on some devices */
 	if (chip->driver_caps & AZX_DCAPS_NO_64BIT) {
-		snd_printd(SFX "%s: Disabling 64bit DMA\n", pci_name(chip->pci));
+		dev_dbg(card->dev, "Disabling 64bit DMA\n");
 		gcap &= ~ICH6_GCAP_64OK;
 	}
 
@@ -3715,7 +3699,7 @@ static int azx_first_init(struct azx *chip)
 	chip->azx_dev = kcalloc(chip->num_streams, sizeof(*chip->azx_dev),
 				GFP_KERNEL);
 	if (!chip->azx_dev) {
-		snd_printk(KERN_ERR SFX "%s: cannot malloc azx_dev\n", pci_name(chip->pci));
+		dev_err(card->dev, "cannot malloc azx_dev\n");
 		return -ENOMEM;
 	}
 
@@ -3726,7 +3710,7 @@ static int azx_first_init(struct azx *chip)
 					  snd_dma_pci_data(chip->pci),
 					  BDL_SIZE, &chip->azx_dev[i].bdl);
 		if (err < 0) {
-			snd_printk(KERN_ERR SFX "%s: cannot allocate BDL\n", pci_name(chip->pci));
+			dev_err(card->dev, "cannot allocate BDL\n");
 			return -ENOMEM;
 		}
 		mark_pages_wc(chip, &chip->azx_dev[i].bdl, true);
@@ -3736,7 +3720,7 @@ static int azx_first_init(struct azx *chip)
 				  snd_dma_pci_data(chip->pci),
 				  chip->num_streams * 8, &chip->posbuf);
 	if (err < 0) {
-		snd_printk(KERN_ERR SFX "%s: cannot allocate posbuf\n", pci_name(chip->pci));
+		dev_err(card->dev, "cannot allocate posbuf\n");
 		return -ENOMEM;
 	}
 	mark_pages_wc(chip, &chip->posbuf, true);
@@ -3754,7 +3738,7 @@ static int azx_first_init(struct azx *chip)
 
 	/* codec detection */
 	if (!chip->codec_mask) {
-		snd_printk(KERN_ERR SFX "%s: no codecs found!\n", pci_name(chip->pci));
+		dev_err(card->dev, "no codecs found!\n");
 		return -ENODEV;
 	}
 
@@ -3790,8 +3774,7 @@ static void azx_firmware_cb(const struct firmware *fw, void *context)
 	struct pci_dev *pci = chip->pci;
 
 	if (!fw) {
-		snd_printk(KERN_ERR SFX "%s: Cannot load firmware, aborting\n",
-			   pci_name(chip->pci));
+		dev_err(card->dev, "Cannot load firmware, aborting\n");
 		goto error;
 	}
 
@@ -3828,7 +3811,7 @@ static int azx_probe(struct pci_dev *pci,
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
 	if (err < 0) {
-		snd_printk(KERN_ERR "hda-intel: Error creating card!\n");
+		dev_err(&pci->dev, "Error creating card!\n");
 		return err;
 	}
 
@@ -3841,15 +3824,13 @@ static int azx_probe(struct pci_dev *pci,
 
 	err = register_vga_switcheroo(chip);
 	if (err < 0) {
-		snd_printk(KERN_ERR SFX
-			   "%s: Error registering VGA-switcheroo client\n", pci_name(pci));
+		dev_err(card->dev, "Error registering VGA-switcheroo client\n");
 		goto out_free;
 	}
 
 	if (check_hdmi_disabled(pci)) {
-		snd_printk(KERN_INFO SFX "%s: VGA controller is disabled\n",
-			   pci_name(pci));
-		snd_printk(KERN_INFO SFX "%s: Delaying initialization\n", pci_name(pci));
+		dev_info(card->dev, "VGA controller is disabled\n");
+		dev_info(card->dev, "Delaying initialization\n");
 		chip->disabled = true;
 	}
 
@@ -3857,8 +3838,8 @@ static int azx_probe(struct pci_dev *pci,
 
 #ifdef CONFIG_SND_HDA_PATCH_LOADER
 	if (patch[dev] && *patch[dev]) {
-		snd_printk(KERN_ERR SFX "%s: Applying patch firmware '%s'\n",
-			   pci_name(pci), patch[dev]);
+		dev_info(card->dev, "Applying patch firmware '%s'\n",
+			 patch[dev]);
 		err = request_firmware_nowait(THIS_MODULE, true, patch[dev],
 					      &pci->dev, GFP_KERNEL, card,
 					      azx_firmware_cb);
@@ -3870,7 +3851,7 @@ static int azx_probe(struct pci_dev *pci,
 
 #ifndef CONFIG_SND_HDA_I915
 	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
-		snd_printk(KERN_ERR SFX "Haswell must build in CONFIG_SND_HDA_I915\n");
+		dev_err(card->dev, "Haswell must build in CONFIG_SND_HDA_I915\n");
 #endif
 
 	if (schedule_probe)
@@ -3897,7 +3878,8 @@ static int azx_probe_continue(struct azx *chip)
 #ifdef CONFIG_SND_HDA_I915
 		err = hda_i915_init();
 		if (err < 0) {
-			snd_printk(KERN_ERR SFX "Error request power-well from i915\n");
+			dev_err(chip->card->dev,
+				"Error request power-well from i915\n");
 			goto out_free;
 		}
 #endif
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index 31545923f6ac..0e3ad1a7959d 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -753,4 +753,11 @@ void snd_hdmi_write_eld_info(struct hdmi_eld *eld,
 #define SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE 80
 void snd_print_channel_allocation(int spk_alloc, char *buf, int buflen);
 
+/*
+ */
+#define codec_err(codec, fmt, args...) dev_err(&(codec)->dev, fmt, ##args)
+#define codec_warn(codec, fmt, args...) dev_warn(&(codec)->dev, fmt, ##args)
+#define codec_info(codec, fmt, args...) dev_info(&(codec)->dev, fmt, ##args)
+#define codec_dbg(codec, fmt, args...) dev_dbg(&(codec)->dev, fmt, ##args)
+
 #endif /* __SOUND_HDA_LOCAL_H */
* Unmerged path sound/pci/hda/hda_sysfs.c
diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c
index c7ea40f28ecc..092f2bd030bd 100644
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@ -867,7 +867,7 @@ static int chipio_write_data_multiple(struct hda_codec *codec,
 	int status = 0;
 
 	if (data == NULL) {
-		snd_printdd(KERN_ERR "chipio_write_data null ptr\n");
+		codec_dbg(codec, "chipio_write_data null ptr\n");
 		return -EINVAL;
 	}
 
@@ -1406,12 +1406,12 @@ static int dspio_scp(struct hda_codec *codec,
 		return -EINVAL;
 
 	if (dir == SCP_GET && reply == NULL) {
-		snd_printdd(KERN_ERR "dspio_scp get but has no buffer\n");
+		codec_dbg(codec, "dspio_scp get but has no buffer\n");
 		return -EINVAL;
 	}
 
 	if (reply != NULL && (reply_len == NULL || (*reply_len == 0))) {
-		snd_printdd(KERN_ERR "dspio_scp bad resp buf len parms\n");
+		codec_dbg(codec, "dspio_scp bad resp buf len parms\n");
 		return -EINVAL;
 	}
 
@@ -1429,7 +1429,7 @@ static int dspio_scp(struct hda_codec *codec,
 					sizeof(scp_reply), &ret_bytes);
 
 	if (status < 0) {
-		snd_printdd(KERN_ERR "dspio_scp: send scp msg failed\n");
+		codec_dbg(codec, "dspio_scp: send scp msg failed\n");
 		return status;
 	}
 
@@ -1448,17 +1448,17 @@ static int dspio_scp(struct hda_codec *codec,
 					/ sizeof(unsigned int);
 
 		if (*reply_len < ret_size*sizeof(unsigned int)) {
-			snd_printdd(KERN_ERR "reply too long for buf\n");
+			codec_dbg(codec, "reply too long for buf\n");
 			return -EINVAL;
 		} else if (ret_size != reply_data_size) {
-			snd_printdd(KERN_ERR "RetLen and HdrLen .NE.\n");
+			codec_dbg(codec, "RetLen and HdrLen .NE.\n");
 			return -EINVAL;
 		} else {
 			*reply_len = ret_size*sizeof(unsigned int);
 			memcpy(reply, scp_reply.data, *reply_len);
 		}
 	} else {
-		snd_printdd(KERN_ERR "reply ill-formed or errflag set\n");
+		codec_dbg(codec, "reply ill-formed or errflag set\n");
 		return -EIO;
 	}
 
@@ -1488,22 +1488,22 @@ static int dspio_alloc_dma_chan(struct hda_codec *codec, unsigned int *dma_chan)
 	int status = 0;
 	unsigned int size = sizeof(dma_chan);
 
-	snd_printdd(KERN_INFO "     dspio_alloc_dma_chan() -- begin\n");
+	codec_dbg(codec, "     dspio_alloc_dma_chan() -- begin\n");
 	status = dspio_scp(codec, MASTERCONTROL, MASTERCONTROL_ALLOC_DMA_CHAN,
 			SCP_GET, NULL, 0, dma_chan, &size);
 
 	if (status < 0) {
-		snd_printdd(KERN_INFO "dspio_alloc_dma_chan: SCP Failed\n");
+		codec_dbg(codec, "dspio_alloc_dma_chan: SCP Failed\n");
 		return status;
 	}
 
 	if ((*dma_chan + 1) == 0) {
-		snd_printdd(KERN_INFO "no free dma channels to allocate\n");
+		codec_dbg(codec, "no free dma channels to allocate\n");
 		return -EBUSY;
 	}
 
-	snd_printdd("dspio_alloc_dma_chan: chan=%d\n", *dma_chan);
-	snd_printdd(KERN_INFO "     dspio_alloc_dma_chan() -- complete\n");
+	codec_dbg(codec, "dspio_alloc_dma_chan: chan=%d\n", *dma_chan);
+	codec_dbg(codec, "     dspio_alloc_dma_chan() -- complete\n");
 
 	return status;
 }
@@ -1516,18 +1516,18 @@ static int dspio_free_dma_chan(struct hda_codec *codec, unsigned int dma_chan)
 	int status = 0;
 	unsigned int dummy = 0;
 
-	snd_printdd(KERN_INFO "     dspio_free_dma_chan() -- begin\n");
-	snd_printdd("dspio_free_dma_chan: chan=%d\n", dma_chan);
+	codec_dbg(codec, "     dspio_free_dma_chan() -- begin\n");
+	codec_dbg(codec, "dspio_free_dma_chan: chan=%d\n", dma_chan);
 
 	status = dspio_scp(codec, MASTERCONTROL, MASTERCONTROL_ALLOC_DMA_CHAN,
 			   SCP_SET, &dma_chan, sizeof(dma_chan), NULL, &dummy);
 
 	if (status < 0) {
-		snd_printdd(KERN_INFO "dspio_free_dma_chan: SCP Failed\n");
+		codec_dbg(codec, "dspio_free_dma_chan: SCP Failed\n");
 		return status;
 	}
 
-	snd_printdd(KERN_INFO "     dspio_free_dma_chan() -- complete\n");
+	codec_dbg(codec, "     dspio_free_dma_chan() -- complete\n");
 
 	return status;
 }
@@ -1575,14 +1575,14 @@ static int dsp_reset(struct hda_codec *codec)
 	unsigned int res;
 	int retry = 20;
 
-	snd_printdd("dsp_reset\n");
+	codec_dbg(codec, "dsp_reset\n");
 	do {
 		res = dspio_send(codec, VENDOR_DSPIO_DSP_INIT, 0);
 		retry--;
 	} while (res == -EIO && retry);
 
 	if (!retry) {
-		snd_printdd("dsp_reset timeout\n");
+		codec_dbg(codec, "dsp_reset timeout\n");
 		return -EIO;
 	}
 
@@ -1635,39 +1635,39 @@ static int dsp_dma_setup_common(struct hda_codec *codec,
 	unsigned int active;
 	bool code, yram;
 
-	snd_printdd(KERN_INFO "-- dsp_dma_setup_common() -- Begin ---------\n");
+	codec_dbg(codec, "-- dsp_dma_setup_common() -- Begin ---------\n");
 
 	if (dma_chan >= DSPDMAC_DMA_CFG_CHANNEL_COUNT) {
-		snd_printdd(KERN_ERR "dma chan num invalid\n");
+		codec_dbg(codec, "dma chan num invalid\n");
 		return -EINVAL;
 	}
 
 	if (dsp_is_dma_active(codec, dma_chan)) {
-		snd_printdd(KERN_ERR "dma already active\n");
+		codec_dbg(codec, "dma already active\n");
 		return -EBUSY;
 	}
 
 	dsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);
 
 	if (dsp_addx == INVALID_CHIP_ADDRESS) {
-		snd_printdd(KERN_ERR "invalid chip addr\n");
+		codec_dbg(codec, "invalid chip addr\n");
 		return -ENXIO;
 	}
 
 	chnl_prop = DSPDMAC_CHNLPROP_AC_MASK;
 	active = 0;
 
-	snd_printdd(KERN_INFO "   dsp_dma_setup_common()    start reg pgm\n");
+	codec_dbg(codec, "   dsp_dma_setup_common()    start reg pgm\n");
 
 	if (ovly) {
 		status = chipio_read(codec, DSPDMAC_CHNLPROP_INST_OFFSET,
 				     &chnl_prop);
 
 		if (status < 0) {
-			snd_printdd(KERN_ERR "read CHNLPROP Reg fail\n");
+			codec_dbg(codec, "read CHNLPROP Reg fail\n");
 			return status;
 		}
-		snd_printdd(KERN_INFO "dsp_dma_setup_common() Read CHNLPROP\n");
+		codec_dbg(codec, "dsp_dma_setup_common() Read CHNLPROP\n");
 	}
 
 	if (!code)
@@ -1679,20 +1679,20 @@ static int dsp_dma_setup_common(struct hda_codec *codec,
 
 	status = chipio_write(codec, DSPDMAC_CHNLPROP_INST_OFFSET, chnl_prop);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write CHNLPROP Reg fail\n");
+		codec_dbg(codec, "write CHNLPROP Reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write CHNLPROP\n");
+	codec_dbg(codec, "   dsp_dma_setup_common()    Write CHNLPROP\n");
 
 	if (ovly) {
 		status = chipio_read(codec, DSPDMAC_ACTIVE_INST_OFFSET,
 				     &active);
 
 		if (status < 0) {
-			snd_printdd(KERN_ERR "read ACTIVE Reg fail\n");
+			codec_dbg(codec, "read ACTIVE Reg fail\n");
 			return status;
 		}
-		snd_printdd(KERN_INFO "dsp_dma_setup_common() Read ACTIVE\n");
+		codec_dbg(codec, "dsp_dma_setup_common() Read ACTIVE\n");
 	}
 
 	active &= (~(1 << (DSPDMAC_ACTIVE_AAR_LOBIT + dma_chan))) &
@@ -1700,35 +1700,35 @@ static int dsp_dma_setup_common(struct hda_codec *codec,
 
 	status = chipio_write(codec, DSPDMAC_ACTIVE_INST_OFFSET, active);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write ACTIVE Reg fail\n");
+		codec_dbg(codec, "write ACTIVE Reg fail\n");
 		return status;
 	}
 
-	snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write ACTIVE\n");
+	codec_dbg(codec, "   dsp_dma_setup_common()    Write ACTIVE\n");
 
 	status = chipio_write(codec, DSPDMAC_AUDCHSEL_INST_OFFSET(dma_chan),
 			      port_map_mask);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write AUDCHSEL Reg fail\n");
+		codec_dbg(codec, "write AUDCHSEL Reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write AUDCHSEL\n");
+	codec_dbg(codec, "   dsp_dma_setup_common()    Write AUDCHSEL\n");
 
 	status = chipio_write(codec, DSPDMAC_IRQCNT_INST_OFFSET(dma_chan),
 			DSPDMAC_IRQCNT_BICNT_MASK | DSPDMAC_IRQCNT_CICNT_MASK);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write IRQCNT Reg fail\n");
+		codec_dbg(codec, "write IRQCNT Reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write IRQCNT\n");
+	codec_dbg(codec, "   dsp_dma_setup_common()    Write IRQCNT\n");
 
-	snd_printdd(
+	codec_dbg(codec,
 		   "ChipA=0x%x,DspA=0x%x,dmaCh=%u, "
 		   "CHSEL=0x%x,CHPROP=0x%x,Active=0x%x\n",
 		   chip_addx, dsp_addx, dma_chan,
 		   port_map_mask, chnl_prop, active);
 
-	snd_printdd(KERN_INFO "-- dsp_dma_setup_common() -- Complete ------\n");
+	codec_dbg(codec, "-- dsp_dma_setup_common() -- Complete ------\n");
 
 	return 0;
 }
@@ -1754,20 +1754,20 @@ static int dsp_dma_setup(struct hda_codec *codec,
 	const unsigned int max_dma_count = 1 << (DSPDMAC_XFRCNT_BCNT_HIBIT -
 						DSPDMAC_XFRCNT_BCNT_LOBIT + 1);
 
-	snd_printdd(KERN_INFO "-- dsp_dma_setup() -- Begin ---------\n");
+	codec_dbg(codec, "-- dsp_dma_setup() -- Begin ---------\n");
 
 	if (count > max_dma_count) {
-		snd_printdd(KERN_ERR "count too big\n");
+		codec_dbg(codec, "count too big\n");
 		return -EINVAL;
 	}
 
 	dsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);
 	if (dsp_addx == INVALID_CHIP_ADDRESS) {
-		snd_printdd(KERN_ERR "invalid chip addr\n");
+		codec_dbg(codec, "invalid chip addr\n");
 		return -ENXIO;
 	}
 
-	snd_printdd(KERN_INFO "   dsp_dma_setup()    start reg pgm\n");
+	codec_dbg(codec, "   dsp_dma_setup()    start reg pgm\n");
 
 	addr_field = dsp_addx << DSPDMAC_DMACFG_DBADR_LOBIT;
 	incr_field   = 0;
@@ -1784,10 +1784,10 @@ static int dsp_dma_setup(struct hda_codec *codec,
 	status = chipio_write(codec, DSPDMAC_DMACFG_INST_OFFSET(dma_chan),
 				dma_cfg);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write DMACFG Reg fail\n");
+		codec_dbg(codec, "write DMACFG Reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "   dsp_dma_setup()    Write DMACFG\n");
+	codec_dbg(codec, "   dsp_dma_setup()    Write DMACFG\n");
 
 	adr_ofs = (count - 1) << (DSPDMAC_DSPADROFS_BOFS_LOBIT +
 							(code ? 0 : 1));
@@ -1795,10 +1795,10 @@ static int dsp_dma_setup(struct hda_codec *codec,
 	status = chipio_write(codec, DSPDMAC_DSPADROFS_INST_OFFSET(dma_chan),
 				adr_ofs);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write DSPADROFS Reg fail\n");
+		codec_dbg(codec, "write DSPADROFS Reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "   dsp_dma_setup()    Write DSPADROFS\n");
+	codec_dbg(codec, "   dsp_dma_setup()    Write DSPADROFS\n");
 
 	base_cnt = (count - 1) << DSPDMAC_XFRCNT_BCNT_LOBIT;
 
@@ -1809,17 +1809,17 @@ static int dsp_dma_setup(struct hda_codec *codec,
 	status = chipio_write(codec,
 				DSPDMAC_XFRCNT_INST_OFFSET(dma_chan), xfr_cnt);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write XFRCNT Reg fail\n");
+		codec_dbg(codec, "write XFRCNT Reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "   dsp_dma_setup()    Write XFRCNT\n");
+	codec_dbg(codec, "   dsp_dma_setup()    Write XFRCNT\n");
 
-	snd_printdd(
+	codec_dbg(codec,
 		   "ChipA=0x%x, cnt=0x%x, DMACFG=0x%x, "
 		   "ADROFS=0x%x, XFRCNT=0x%x\n",
 		   chip_addx, count, dma_cfg, adr_ofs, xfr_cnt);
 
-	snd_printdd(KERN_INFO "-- dsp_dma_setup() -- Complete ---------\n");
+	codec_dbg(codec, "-- dsp_dma_setup() -- Complete ---------\n");
 
 	return 0;
 }
@@ -1833,17 +1833,17 @@ static int dsp_dma_start(struct hda_codec *codec,
 	unsigned int reg = 0;
 	int status = 0;
 
-	snd_printdd(KERN_INFO "-- dsp_dma_start() -- Begin ---------\n");
+	codec_dbg(codec, "-- dsp_dma_start() -- Begin ---------\n");
 
 	if (ovly) {
 		status = chipio_read(codec,
 				     DSPDMAC_CHNLSTART_INST_OFFSET, &reg);
 
 		if (status < 0) {
-			snd_printdd(KERN_ERR "read CHNLSTART reg fail\n");
+			codec_dbg(codec, "read CHNLSTART reg fail\n");
 			return status;
 		}
-		snd_printdd(KERN_INFO "-- dsp_dma_start()    Read CHNLSTART\n");
+		codec_dbg(codec, "-- dsp_dma_start()    Read CHNLSTART\n");
 
 		reg &= ~(DSPDMAC_CHNLSTART_EN_MASK |
 				DSPDMAC_CHNLSTART_DIS_MASK);
@@ -1852,10 +1852,10 @@ static int dsp_dma_start(struct hda_codec *codec,
 	status = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,
 			reg | (1 << (dma_chan + DSPDMAC_CHNLSTART_EN_LOBIT)));
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write CHNLSTART reg fail\n");
+		codec_dbg(codec, "write CHNLSTART reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "-- dsp_dma_start() -- Complete ---------\n");
+	codec_dbg(codec, "-- dsp_dma_start() -- Complete ---------\n");
 
 	return status;
 }
@@ -1869,17 +1869,17 @@ static int dsp_dma_stop(struct hda_codec *codec,
 	unsigned int reg = 0;
 	int status = 0;
 
-	snd_printdd(KERN_INFO "-- dsp_dma_stop() -- Begin ---------\n");
+	codec_dbg(codec, "-- dsp_dma_stop() -- Begin ---------\n");
 
 	if (ovly) {
 		status = chipio_read(codec,
 				     DSPDMAC_CHNLSTART_INST_OFFSET, &reg);
 
 		if (status < 0) {
-			snd_printdd(KERN_ERR "read CHNLSTART reg fail\n");
+			codec_dbg(codec, "read CHNLSTART reg fail\n");
 			return status;
 		}
-		snd_printdd(KERN_INFO "-- dsp_dma_stop()    Read CHNLSTART\n");
+		codec_dbg(codec, "-- dsp_dma_stop()    Read CHNLSTART\n");
 		reg &= ~(DSPDMAC_CHNLSTART_EN_MASK |
 				DSPDMAC_CHNLSTART_DIS_MASK);
 	}
@@ -1887,10 +1887,10 @@ static int dsp_dma_stop(struct hda_codec *codec,
 	status = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,
 			reg | (1 << (dma_chan + DSPDMAC_CHNLSTART_DIS_LOBIT)));
 	if (status < 0) {
-		snd_printdd(KERN_ERR "write CHNLSTART reg fail\n");
+		codec_dbg(codec, "write CHNLSTART reg fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "-- dsp_dma_stop() -- Complete ---------\n");
+	codec_dbg(codec, "-- dsp_dma_stop() -- Complete ---------\n");
 
 	return status;
 }
@@ -1973,17 +1973,17 @@ static int dsp_allocate_ports(struct hda_codec *codec,
 {
 	int status;
 
-	snd_printdd(KERN_INFO "     dsp_allocate_ports() -- begin\n");
+	codec_dbg(codec, "     dsp_allocate_ports() -- begin\n");
 
 	if ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {
-		snd_printdd(KERN_ERR "bad rate multiple\n");
+		codec_dbg(codec, "bad rate multiple\n");
 		return -EINVAL;
 	}
 
 	status = dsp_allocate_router_ports(codec, num_chans,
 					   rate_multi, 0, port_map);
 
-	snd_printdd(KERN_INFO "     dsp_allocate_ports() -- complete\n");
+	codec_dbg(codec, "     dsp_allocate_ports() -- complete\n");
 
 	return status;
 }
@@ -2000,7 +2000,7 @@ static int dsp_allocate_ports_format(struct hda_codec *codec,
 	unsigned int rate_multi = sample_rate_mul / sample_rate_div;
 
 	if ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {
-		snd_printdd(KERN_ERR "bad rate multiple\n");
+		codec_dbg(codec, "bad rate multiple\n");
 		return -EINVAL;
 	}
 
@@ -2018,14 +2018,14 @@ static int dsp_free_ports(struct hda_codec *codec)
 {
 	int status;
 
-	snd_printdd(KERN_INFO "     dsp_free_ports() -- begin\n");
+	codec_dbg(codec, "     dsp_free_ports() -- begin\n");
 
 	status = dsp_free_router_ports(codec);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "free router ports fail\n");
+		codec_dbg(codec, "free router ports fail\n");
 		return status;
 	}
-	snd_printdd(KERN_INFO "     dsp_free_ports() -- complete\n");
+	codec_dbg(codec, "     dsp_free_ports() -- complete\n");
 
 	return status;
 }
@@ -2091,8 +2091,6 @@ static int dma_set_state(struct dma_engine *dma, enum dma_state state)
 {
 	bool cmd;
 
-	snd_printdd("dma_set_state state=%d\n", state);
-
 	switch (state) {
 	case DMA_STATE_STOP:
 		cmd = false;
@@ -2195,7 +2193,7 @@ static int dspxfr_hci_write(struct hda_codec *codec,
 	unsigned int count;
 
 	if (fls == NULL || fls->chip_addr != g_chip_addr_magic_value) {
-		snd_printdd(KERN_ERR "hci_write invalid params\n");
+		codec_dbg(codec, "hci_write invalid params\n");
 		return -EINVAL;
 	}
 
@@ -2204,7 +2202,7 @@ static int dspxfr_hci_write(struct hda_codec *codec,
 	while (count >= 2) {
 		status = chipio_write(codec, data[0], data[1]);
 		if (status < 0) {
-			snd_printdd(KERN_ERR "hci_write chipio failed\n");
+			codec_dbg(codec, "hci_write chipio failed\n");
 			return status;
 		}
 		count -= 2;
@@ -2264,12 +2262,12 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 	}
 
 	if (hci_write && (!fls || is_last(fls))) {
-		snd_printdd("hci_write\n");
+		codec_dbg(codec, "hci_write\n");
 		return dspxfr_hci_write(codec, hci_write);
 	}
 
 	if (fls == NULL || dma_engine == NULL || port_map_mask == 0) {
-		snd_printdd("Invalid Params\n");
+		codec_dbg(codec, "Invalid Params\n");
 		return -EINVAL;
 	}
 
@@ -2285,7 +2283,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 	if (!UC_RANGE(chip_addx, words_to_write) &&
 	    !X_RANGE_ALL(chip_addx, words_to_write) &&
 	    !Y_RANGE_ALL(chip_addx, words_to_write)) {
-		snd_printdd("Invalid chip_addx Params\n");
+		codec_dbg(codec, "Invalid chip_addx Params\n");
 		return -EINVAL;
 	}
 
@@ -2295,7 +2293,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 	buffer_addx = dma_get_buffer_addr(dma_engine);
 
 	if (buffer_addx == NULL) {
-		snd_printdd(KERN_ERR "dma_engine buffer NULL\n");
+		codec_dbg(codec, "dma_engine buffer NULL\n");
 		return -EINVAL;
 	}
 
@@ -2308,7 +2306,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 			(num_chans * sample_rate_mul / sample_rate_div));
 
 	if (hda_frame_size_words == 0) {
-		snd_printdd(KERN_ERR "frmsz zero\n");
+		codec_dbg(codec, "frmsz zero\n");
 		return -EINVAL;
 	}
 
@@ -2316,14 +2314,14 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 				(unsigned int)(UC_RANGE(chip_addx, 1) ?
 				65536 : 32768));
 	buffer_size_words -= buffer_size_words % hda_frame_size_words;
-	snd_printdd(
+	codec_dbg(codec,
 		   "chpadr=0x%08x frmsz=%u nchan=%u "
 		   "rate_mul=%u div=%u bufsz=%u\n",
 		   chip_addx, hda_frame_size_words, num_chans,
 		   sample_rate_mul, sample_rate_div, buffer_size_words);
 
 	if (buffer_size_words < hda_frame_size_words) {
-		snd_printdd(KERN_ERR "dspxfr_one_seg:failed\n");
+		codec_dbg(codec, "dspxfr_one_seg:failed\n");
 		return -EINVAL;
 	}
 
@@ -2337,7 +2335,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 
 	while (words_to_write != 0) {
 		run_size_words = min(buffer_size_words, words_to_write);
-		snd_printdd("dspxfr (seg loop)cnt=%u rs=%u remainder=%u\n",
+		codec_dbg(codec, "dspxfr (seg loop)cnt=%u rs=%u remainder=%u\n",
 			    words_to_write, run_size_words, remainder_words);
 		dma_xfer(dma_engine, data, run_size_words*sizeof(u32));
 		if (!comm_dma_setup_done) {
@@ -2359,7 +2357,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 		if (status < 0)
 			return status;
 		if (!dsp_is_dma_active(codec, dma_chan)) {
-			snd_printdd(KERN_ERR "dspxfr:DMA did not start\n");
+			codec_dbg(codec, "dspxfr:DMA did not start\n");
 			return -EIO;
 		}
 		status = dma_set_state(dma_engine, DMA_STATE_RUN);
@@ -2391,7 +2389,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 		if (dma_active)
 			break;
 
-		snd_printdd(KERN_INFO "+++++ DMA complete\n");
+		codec_dbg(codec, "+++++ DMA complete\n");
 		dma_set_state(dma_engine, DMA_STATE_STOP);
 		status = dma_reset(dma_engine);
 
@@ -2465,7 +2463,7 @@ static int dspxfr_image(struct hda_codec *codec,
 					hda_format, &response);
 
 	if (status < 0) {
-		snd_printdd(KERN_ERR "set converter format fail\n");
+		codec_dbg(codec, "set converter format fail\n");
 		goto exit;
 	}
 
@@ -2480,7 +2478,7 @@ static int dspxfr_image(struct hda_codec *codec,
 	if (ovly) {
 		status = dspio_alloc_dma_chan(codec, &dma_chan);
 		if (status < 0) {
-			snd_printdd(KERN_ERR "alloc dmachan fail\n");
+			codec_dbg(codec, "alloc dmachan fail\n");
 			dma_chan = INVALID_DMA_CHANNEL;
 			goto exit;
 		}
@@ -2490,7 +2488,7 @@ static int dspxfr_image(struct hda_codec *codec,
 	status = dsp_allocate_ports_format(codec, hda_format,
 					&port_map_mask);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "alloc ports fail\n");
+		codec_dbg(codec, "alloc ports fail\n");
 		goto exit;
 	}
 
@@ -2498,13 +2496,13 @@ static int dspxfr_image(struct hda_codec *codec,
 	status = codec_set_converter_stream_channel(codec,
 			WIDGET_CHIP_CTRL, stream_id, 0, &response);
 	if (status < 0) {
-		snd_printdd(KERN_ERR "set stream chan fail\n");
+		codec_dbg(codec, "set stream chan fail\n");
 		goto exit;
 	}
 
 	while ((fls_data != NULL) && !is_last(fls_data)) {
 		if (!is_valid(fls_data)) {
-			snd_printdd(KERN_ERR "FLS check fail\n");
+			codec_dbg(codec, "FLS check fail\n");
 			status = -EINVAL;
 			goto exit;
 		}
@@ -2547,7 +2545,7 @@ exit:
  */
 static void dspload_post_setup(struct hda_codec *codec)
 {
-	snd_printdd(KERN_INFO "---- dspload_post_setup ------\n");
+	codec_dbg(codec, "---- dspload_post_setup ------\n");
 
 	/*set DSP speaker to 2.0 configuration*/
 	chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x18), 0x08080080);
@@ -2585,7 +2583,7 @@ static int dspload_image(struct hda_codec *codec,
 	unsigned int sample_rate;
 	unsigned short channels;
 
-	snd_printdd(KERN_INFO "---- dspload_image begin ------\n");
+	codec_dbg(codec, "---- dspload_image begin ------\n");
 	if (router_chans == 0) {
 		if (!ovly)
 			router_chans = DMA_TRANSFER_FRAME_SIZE_NWORDS;
@@ -2602,27 +2600,27 @@ static int dspload_image(struct hda_codec *codec,
 	}
 
 	do {
-		snd_printdd(KERN_INFO "Ready to program DMA\n");
+		codec_dbg(codec, "Ready to program DMA\n");
 		if (!ovly)
 			status = dsp_reset(codec);
 
 		if (status < 0)
 			break;
 
-		snd_printdd(KERN_INFO "dsp_reset() complete\n");
+		codec_dbg(codec, "dsp_reset() complete\n");
 		status = dspxfr_image(codec, fls, reloc, sample_rate, channels,
 				      ovly);
 
 		if (status < 0)
 			break;
 
-		snd_printdd(KERN_INFO "dspxfr_image() complete\n");
+		codec_dbg(codec, "dspxfr_image() complete\n");
 		if (autostart && !ovly) {
 			dspload_post_setup(codec);
 			status = dsp_set_run_state(codec);
 		}
 
-		snd_printdd(KERN_INFO "LOAD FINISHED\n");
+		codec_dbg(codec, "LOAD FINISHED\n");
 	} while (0);
 
 	return status;
@@ -3131,7 +3129,7 @@ static int ca0132_select_out(struct hda_codec *codec)
 	unsigned int tmp;
 	int err;
 
-	snd_printdd(KERN_INFO "ca0132_select_out\n");
+	codec_dbg(codec, "ca0132_select_out\n");
 
 	snd_hda_power_up(codec);
 
@@ -3149,7 +3147,7 @@ static int ca0132_select_out(struct hda_codec *codec)
 		spec->cur_out_type = SPEAKER_OUT;
 
 	if (spec->cur_out_type == SPEAKER_OUT) {
-		snd_printdd(KERN_INFO "ca0132_select_out speaker\n");
+		codec_dbg(codec, "ca0132_select_out speaker\n");
 		/*speaker out config*/
 		tmp = FLOAT_ONE;
 		err = dspio_set_uint_param(codec, 0x80, 0x04, tmp);
@@ -3182,7 +3180,7 @@ static int ca0132_select_out(struct hda_codec *codec)
 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
 				    pin_ctl | PIN_OUT);
 	} else {
-		snd_printdd(KERN_INFO "ca0132_select_out hp\n");
+		codec_dbg(codec, "ca0132_select_out hp\n");
 		/*headphone out config*/
 		tmp = FLOAT_ZERO;
 		err = dspio_set_uint_param(codec, 0x80, 0x04, tmp);
@@ -3287,7 +3285,7 @@ static int ca0132_select_mic(struct hda_codec *codec)
 	int jack_present;
 	int auto_jack;
 
-	snd_printdd(KERN_INFO "ca0132_select_mic\n");
+	codec_dbg(codec, "ca0132_select_mic\n");
 
 	snd_hda_power_up(codec);
 
@@ -3409,7 +3407,7 @@ static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val)
 			val = 0;
 	}
 
-	snd_printdd(KERN_INFO "ca0132_effect_set: nid=0x%x, val=%ld\n",
+	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
 		    nid, val);
 
 	on = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;
@@ -3431,7 +3429,7 @@ static int ca0132_pe_switch_set(struct hda_codec *codec)
 	hda_nid_t nid;
 	int i, ret = 0;
 
-	snd_printdd(KERN_INFO "ca0132_pe_switch_set: val=%ld\n",
+	codec_dbg(codec, "ca0132_pe_switch_set: val=%ld\n",
 		    spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);
 
 	i = OUT_EFFECT_START_NID - EFFECT_START_NID;
@@ -3477,7 +3475,7 @@ static int ca0132_cvoice_switch_set(struct hda_codec *codec)
 	int i, ret = 0;
 	unsigned int oldval;
 
-	snd_printdd(KERN_INFO "ca0132_cvoice_switch_set: val=%ld\n",
+	codec_dbg(codec, "ca0132_cvoice_switch_set: val=%ld\n",
 		    spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);
 
 	i = IN_EFFECT_START_NID - EFFECT_START_NID;
@@ -3607,7 +3605,7 @@ static int ca0132_voicefx_put(struct snd_kcontrol *kcontrol,
 	if (sel >= items)
 		return 0;
 
-	snd_printdd(KERN_INFO "ca0132_voicefx_put: sel=%d, preset=%s\n",
+	codec_dbg(codec, "ca0132_voicefx_put: sel=%d, preset=%s\n",
 		    sel, ca0132_voicefx_presets[sel].name);
 
 	/*
@@ -3678,7 +3676,7 @@ static int ca0132_switch_put(struct snd_kcontrol *kcontrol,
 	long *valp = ucontrol->value.integer.value;
 	int changed = 1;
 
-	snd_printdd(KERN_INFO "ca0132_switch_put: nid=0x%x, val=%ld\n",
+	codec_dbg(codec, "ca0132_switch_put: nid=0x%x, val=%ld\n",
 		    nid, *valp);
 
 	snd_hda_power_up(codec);
@@ -4141,7 +4139,7 @@ static void ca0132_set_dmic(struct hda_codec *codec, int enable)
 	u8 val;
 	unsigned int oldval;
 
-	snd_printdd(KERN_INFO "ca0132_set_dmic: enable=%d\n", enable);
+	codec_dbg(codec, "ca0132_set_dmic: enable=%d\n", enable);
 
 	oldval = stop_mic1(codec);
 	ca0132_set_vipsource(codec, 0);
@@ -4249,7 +4247,7 @@ static void ca0132_refresh_widget_caps(struct hda_codec *codec)
 	int i;
 	hda_nid_t nid;
 
-	snd_printdd(KERN_INFO "ca0132_refresh_widget_caps.\n");
+	codec_dbg(codec, "ca0132_refresh_widget_caps.\n");
 	nid = codec->start_nid;
 	for (i = 0; i < codec->num_nodes; i++, nid++)
 		codec->wcaps[i] = snd_hda_param_read(codec, nid,
@@ -4393,7 +4391,7 @@ static void ca0132_process_dsp_response(struct hda_codec *codec)
 {
 	struct ca0132_spec *spec = codec->spec;
 
-	snd_printdd(KERN_INFO "ca0132_process_dsp_response\n");
+	codec_dbg(codec, "ca0132_process_dsp_response\n");
 	if (spec->wait_scp) {
 		if (dspio_get_response_data(codec) >= 0)
 			spec->wait_scp = 0;
@@ -4412,7 +4410,7 @@ static void ca0132_unsol_event(struct hda_codec *codec, unsigned int res)
 		res = snd_hda_jack_get_action(codec,
 				(res >> AC_UNSOL_RES_TAG_SHIFT) & 0x3f);
 
-		snd_printdd(KERN_INFO "snd_hda_jack_get_action: 0x%x\n", res);
+		codec_dbg(codec, "snd_hda_jack_get_action: 0x%x\n", res);
 
 		switch (res) {
 		case UNSOL_TAG_HP:
@@ -4657,7 +4655,7 @@ static int patch_ca0132(struct hda_codec *codec)
 	struct ca0132_spec *spec;
 	int err;
 
-	snd_printdd("patch_ca0132\n");
+	codec_dbg(codec, "patch_ca0132\n");
 
 	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
 	if (!spec)
diff --git a/sound/pci/hda/patch_cmedia.c b/sound/pci/hda/patch_cmedia.c
index d782292b1ba9..061ea5965dd5 100644
--- a/sound/pci/hda/patch_cmedia.c
+++ b/sound/pci/hda/patch_cmedia.c
@@ -623,7 +623,7 @@ static int patch_cmi9880(struct hda_codec *codec)
 							cmi9880_models,
 							cmi9880_cfg_tbl);
 	if (spec->board_config < 0) {
-		snd_printdd(KERN_INFO "hda_codec: %s: BIOS auto-probing.\n",
+		codec_dbg(codec, "%s: BIOS auto-probing.\n",
 			    codec->chip_name);
 		spec->board_config = CMI_AUTO; /* try everything */
 	}
diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c
index 13a416060eb8..09d6d0db2b06 100644
--- a/sound/pci/hda/patch_conexant.c
+++ b/sound/pci/hda/patch_conexant.c
@@ -1900,7 +1900,8 @@ static void cxt5066_update_speaker(struct hda_codec *codec)
 	struct conexant_spec *spec = codec->spec;
 	unsigned int pinctl;
 
-	snd_printdd("CXT5066: update speaker, hp_present=%d, cur_eapd=%d\n",
+	codec_dbg(codec,
+		  "CXT5066: update speaker, hp_present=%d, cur_eapd=%d\n",
 		    spec->hp_present, spec->cur_eapd);
 
 	/* Port A (HP) */
@@ -1969,10 +1970,10 @@ static void cxt5066_vostro_automic(struct hda_codec *codec)
 
 	present = snd_hda_jack_detect(codec, 0x1a);
 	if (present) {
-		snd_printdd("CXT5066: external microphone detected\n");
+		codec_dbg(codec, "CXT5066: external microphone detected\n");
 		snd_hda_sequence_write(codec, ext_mic_present);
 	} else {
-		snd_printdd("CXT5066: external microphone absent\n");
+		codec_dbg(codec, "CXT5066: external microphone absent\n");
 		snd_hda_sequence_write(codec, ext_mic_absent);
 	}
 }
@@ -1997,10 +1998,10 @@ static void cxt5066_ideapad_automic(struct hda_codec *codec)
 
 	present = snd_hda_jack_detect(codec, 0x1b);
 	if (present) {
-		snd_printdd("CXT5066: external microphone detected\n");
+		codec_dbg(codec, "CXT5066: external microphone detected\n");
 		snd_hda_sequence_write(codec, ext_mic_present);
 	} else {
-		snd_printdd("CXT5066: external microphone absent\n");
+		codec_dbg(codec, "CXT5066: external microphone absent\n");
 		snd_hda_sequence_write(codec, ext_mic_absent);
 	}
 }
@@ -2012,7 +2013,7 @@ static void cxt5066_asus_automic(struct hda_codec *codec)
 	unsigned int present;
 
 	present = snd_hda_jack_detect(codec, 0x1b);
-	snd_printdd("CXT5066: external microphone present=%d\n", present);
+	codec_dbg(codec, "CXT5066: external microphone present=%d\n", present);
 	snd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_CONNECT_SEL,
 			    present ? 1 : 0);
 }
@@ -2024,7 +2025,7 @@ static void cxt5066_hp_laptop_automic(struct hda_codec *codec)
 	unsigned int present;
 
 	present = snd_hda_jack_detect(codec, 0x1b);
-	snd_printdd("CXT5066: external microphone present=%d\n", present);
+	codec_dbg(codec, "CXT5066: external microphone present=%d\n", present);
 	snd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_CONNECT_SEL,
 			    present ? 1 : 3);
 }
@@ -2063,13 +2064,13 @@ static void cxt5066_thinkpad_automic(struct hda_codec *codec)
 	ext_present = snd_hda_jack_detect(codec, 0x1b);
 	dock_present = snd_hda_jack_detect(codec, 0x1a);
 	if (ext_present) {
-		snd_printdd("CXT5066: external microphone detected\n");
+		codec_dbg(codec, "CXT5066: external microphone detected\n");
 		snd_hda_sequence_write(codec, ext_mic_present);
 	} else if (dock_present) {
-		snd_printdd("CXT5066: dock microphone detected\n");
+		codec_dbg(codec, "CXT5066: dock microphone detected\n");
 		snd_hda_sequence_write(codec, dock_mic_present);
 	} else {
-		snd_printdd("CXT5066: external microphone absent\n");
+		codec_dbg(codec, "CXT5066: external microphone absent\n");
 		snd_hda_sequence_write(codec, ext_mic_absent);
 	}
 }
@@ -2088,7 +2089,7 @@ static void cxt5066_hp_automute(struct hda_codec *codec)
 
 	spec->hp_present = portA ? HP_PRESENT_PORT_A : 0;
 	spec->hp_present |= portD ? HP_PRESENT_PORT_D : 0;
-	snd_printdd("CXT5066: hp automute portA=%x portD=%x present=%d\n",
+	codec_dbg(codec, "CXT5066: hp automute portA=%x portD=%x present=%d\n",
 		portA, portD, spec->hp_present);
 	cxt5066_update_speaker(codec);
 }
@@ -2113,7 +2114,7 @@ static void cxt5066_automic(struct hda_codec *codec)
 /* unsolicited event for jack sensing */
 static void cxt5066_unsol_event(struct hda_codec *codec, unsigned int res)
 {
-	snd_printdd("CXT5066: unsol event %x (%x)\n", res, res >> 26);
+	codec_dbg(codec, "CXT5066: unsol event %x (%x)\n", res, res >> 26);
 	switch (res >> 26) {
 	case CONEXANT_HP_EVENT:
 		cxt5066_hp_automute(codec);
@@ -2509,7 +2510,7 @@ static const struct hda_verb cxt5066_init_verbs_hp_laptop[] = {
 /* initialize jack-sensing, too */
 static int cxt5066_init(struct hda_codec *codec)
 {
-	snd_printdd("CXT5066: init\n");
+	codec_dbg(codec, "CXT5066: init\n");
 	conexant_init(codec);
 	if (codec->patch_ops.unsol_event) {
 		cxt5066_hp_automute(codec);
@@ -3401,8 +3402,7 @@ static int patch_conexant_auto(struct hda_codec *codec)
 	struct conexant_spec *spec;
 	int err;
 
-	printk(KERN_INFO "hda_codec: %s: BIOS auto-probing.\n",
-	       codec->chip_name);
+	codec_info(codec, "%s: BIOS auto-probing.\n", codec->chip_name);
 
 	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
 	if (!spec)
@@ -3474,7 +3474,7 @@ static int patch_conexant_auto(struct hda_codec *codec)
 	 * Better to make reset, then.
 	 */
 	if (!codec->bus->sync_write) {
-		snd_printd("hda_codec: "
+		codec_info(codec,
 			   "Enable sync_write for stable communication\n");
 		codec->bus->sync_write = 1;
 		codec->bus->allow_bus_reset = 1;
diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c
index 19ddab117e16..20716c6d5ecf 100644
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@ -353,40 +353,43 @@ static struct cea_channel_speaker_allocation channel_allocations[] = {
 #define get_pcm_rec(spec, idx) \
 	((struct hda_pcm *)snd_array_elem(&spec->pcm_rec, idx))
 
-static int pin_nid_to_pin_index(struct hdmi_spec *spec, hda_nid_t pin_nid)
+static int pin_nid_to_pin_index(struct hda_codec *codec, hda_nid_t pin_nid)
 {
+	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
 
 	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++)
 		if (get_pin(spec, pin_idx)->pin_nid == pin_nid)
 			return pin_idx;
 
-	snd_printk(KERN_WARNING "HDMI: pin nid %d not registered\n", pin_nid);
+	codec_warn(codec, "HDMI: pin nid %d not registered\n", pin_nid);
 	return -EINVAL;
 }
 
-static int hinfo_to_pin_index(struct hdmi_spec *spec,
+static int hinfo_to_pin_index(struct hda_codec *codec,
 			      struct hda_pcm_stream *hinfo)
 {
+	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
 
 	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++)
 		if (get_pcm_rec(spec, pin_idx)->stream == hinfo)
 			return pin_idx;
 
-	snd_printk(KERN_WARNING "HDMI: hinfo %p not registered\n", hinfo);
+	codec_warn(codec, "HDMI: hinfo %p not registered\n", hinfo);
 	return -EINVAL;
 }
 
-static int cvt_nid_to_cvt_index(struct hdmi_spec *spec, hda_nid_t cvt_nid)
+static int cvt_nid_to_cvt_index(struct hda_codec *codec, hda_nid_t cvt_nid)
 {
+	struct hdmi_spec *spec = codec->spec;
 	int cvt_idx;
 
 	for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++)
 		if (get_cvt(spec, cvt_idx)->cvt_nid == cvt_nid)
 			return cvt_idx;
 
-	snd_printk(KERN_WARNING "HDMI: cvt nid %d not registered\n", cvt_nid);
+	codec_warn(codec, "HDMI: cvt nid %d not registered\n", cvt_nid);
 	return -EINVAL;
 }
 
@@ -706,7 +709,7 @@ static void hdmi_debug_channel_mapping(struct hda_codec *codec,
 
 	for (i = 0; i < 8; i++) {
 		channel = spec->ops.pin_get_slot_channel(codec, pin_nid, i);
-		printk(KERN_DEBUG "HDMI: ASP channel %d => slot %d\n",
+		codec_dbg(codec, "HDMI: ASP channel %d => slot %d\n",
 						channel, i);
 	}
 #endif
@@ -755,8 +758,7 @@ static void hdmi_std_setup_channel_mapping(struct hda_codec *codec,
 		int channel = (slotsetup & 0xf0) >> 4;
 		err = spec->ops.pin_set_slot_channel(codec, pin_nid, hdmi_slot, channel);
 		if (err) {
-			snd_printdd(KERN_NOTICE
-				    "HDMI: channel mapping failed\n");
+			codec_dbg(codec, "HDMI: channel mapping failed\n");
 			break;
 		}
 	}
@@ -967,12 +969,12 @@ static void hdmi_debug_dip_size(struct hda_codec *codec, hda_nid_t pin_nid)
 	int size;
 
 	size = snd_hdmi_get_eld_size(codec, pin_nid);
-	printk(KERN_DEBUG "HDMI: ELD buf size is %d\n", size);
+	codec_dbg(codec, "HDMI: ELD buf size is %d\n", size);
 
 	for (i = 0; i < 8; i++) {
 		size = snd_hda_codec_read(codec, pin_nid, 0,
 						AC_VERB_GET_HDMI_DIP_SIZE, i);
-		printk(KERN_DEBUG "HDMI: DIP GP[%d] buf size is %d\n", i, size);
+		codec_dbg(codec, "HDMI: DIP GP[%d] buf size is %d\n", i, size);
 	}
 #endif
 }
@@ -994,12 +996,12 @@ static void hdmi_clear_dip_buffers(struct hda_codec *codec, hda_nid_t pin_nid)
 			hdmi_write_dip_byte(codec, pin_nid, 0x0);
 			hdmi_get_dip_index(codec, pin_nid, &pi, &bi);
 			if (pi != i)
-				snd_printd(KERN_INFO "dip index %d: %d != %d\n",
+				codec_dbg(codec, "dip index %d: %d != %d\n",
 						bi, pi, i);
 			if (bi == 0) /* byte index wrapped around */
 				break;
 		}
-		snd_printd(KERN_INFO
+		codec_dbg(codec,
 			"HDMI: DIP GP[%d] buf reported size=%d, written=%d\n",
 			i, size, j);
 	}
@@ -1080,7 +1082,7 @@ static void hdmi_pin_setup_infoframe(struct hda_codec *codec,
 		dp_ai->CC02_CT47	= active_channels - 1;
 		dp_ai->CA		= ca;
 	} else {
-		snd_printd("HDMI: unknown connection type at pin %d\n",
+		codec_dbg(codec, "HDMI: unknown connection type at pin %d\n",
 			    pin_nid);
 		return;
 	}
@@ -1092,8 +1094,8 @@ static void hdmi_pin_setup_infoframe(struct hda_codec *codec,
 	 */
 	if (!hdmi_infoframe_uptodate(codec, pin_nid, ai.bytes,
 					sizeof(ai))) {
-		snd_printdd("hdmi_pin_setup_infoframe: "
-			    "pin=%d channels=%d ca=0x%02x\n",
+		codec_dbg(codec,
+			  "hdmi_pin_setup_infoframe: pin=%d channels=%d ca=0x%02x\n",
 			    pin_nid,
 			    active_channels, ca);
 		hdmi_stop_infoframe_trans(codec, pin_nid);
@@ -1161,7 +1163,7 @@ static bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll);
 static void jack_callback(struct hda_codec *codec, struct hda_jack_tbl *jack)
 {
 	struct hdmi_spec *spec = codec->spec;
-	int pin_idx = pin_nid_to_pin_index(spec, jack->nid);
+	int pin_idx = pin_nid_to_pin_index(codec, jack->nid);
 	if (pin_idx < 0)
 		return;
 
@@ -1180,7 +1182,7 @@ static void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res)
 		return;
 	jack->jack_dirty = 1;
 
-	_snd_printd(SND_PR_VERBOSE,
+	codec_dbg(codec,
 		"HDMI hot plug event: Codec=%d Pin=%d Device=%d Inactive=%d Presence_Detect=%d ELD_Valid=%d\n",
 		codec->addr, jack->nid, dev_entry, !!(res & AC_UNSOL_RES_IA),
 		!!(res & AC_UNSOL_RES_PD), !!(res & AC_UNSOL_RES_ELDV));
@@ -1195,7 +1197,7 @@ static void hdmi_non_intrinsic_event(struct hda_codec *codec, unsigned int res)
 	int cp_state = !!(res & AC_UNSOL_RES_CP_STATE);
 	int cp_ready = !!(res & AC_UNSOL_RES_CP_READY);
 
-	printk(KERN_INFO
+	codec_info(codec,
 		"HDMI CP event: CODEC=%d TAG=%d SUBTAG=0x%x CP_STATE=%d CP_READY=%d\n",
 		codec->addr,
 		tag,
@@ -1217,7 +1219,7 @@ static void hdmi_unsol_event(struct hda_codec *codec, unsigned int res)
 	int subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;
 
 	if (!snd_hda_jack_tbl_get_from_tag(codec, tag)) {
-		snd_printd(KERN_INFO "Unexpected HDMI event tag 0x%x\n", tag);
+		codec_dbg(codec, "Unexpected HDMI event tag 0x%x\n", tag);
 		return;
 	}
 
@@ -1244,7 +1246,7 @@ static void haswell_verify_D0(struct hda_codec *codec,
 		msleep(40);
 		pwr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);
 		pwr = (pwr & AC_PWRST_ACTUAL) >> AC_PWRST_ACTUAL_SHIFT;
-		snd_printd("Haswell HDMI audio: Power for pin 0x%x is now D%d\n", nid, pwr);
+		codec_dbg(codec, "Haswell HDMI audio: Power for pin 0x%x is now D%d\n", nid, pwr);
 	}
 }
 
@@ -1274,8 +1276,8 @@ static int hdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,
 		else
 			new_pinctl |= AC_PINCTL_EPT_NATIVE;
 
-		snd_printdd("hdmi_pin_hbr_setup: "
-			    "NID=0x%x, %spinctl=0x%x\n",
+		codec_dbg(codec,
+			  "hdmi_pin_hbr_setup: NID=0x%x, %spinctl=0x%x\n",
 			    pin_nid,
 			    pinctl == new_pinctl ? "" : "new-",
 			    new_pinctl);
@@ -1302,7 +1304,7 @@ static int hdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
 	err = spec->ops.pin_hbr_setup(codec, pin_nid, is_hbr_format(format));
 
 	if (err) {
-		snd_printdd("hdmi_setup_stream: HBR is not supported\n");
+		codec_dbg(codec, "hdmi_setup_stream: HBR is not supported\n");
 		return err;
 	}
 
@@ -1389,7 +1391,8 @@ static void intel_not_share_assigned_cvt(struct hda_codec *codec,
 		for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {
 			per_cvt = get_cvt(spec, cvt_idx);
 			if (!per_cvt->assigned) {
-				snd_printdd("choose cvt %d for pin nid %d\n",
+				codec_dbg(codec,
+					  "choose cvt %d for pin nid %d\n",
 					cvt_idx, nid);
 				snd_hda_codec_write_cache(codec, nid, 0,
 					    AC_VERB_SET_CONNECT_SEL,
@@ -1416,7 +1419,7 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
 	int err;
 
 	/* Validate hinfo */
-	pin_idx = hinfo_to_pin_index(spec, hinfo);
+	pin_idx = hinfo_to_pin_index(codec, hinfo);
 	if (snd_BUG_ON(pin_idx < 0))
 		return -EINVAL;
 	per_pin = get_pin(spec, pin_idx);
@@ -1482,9 +1485,8 @@ static int hdmi_read_pin_conn(struct hda_codec *codec, int pin_idx)
 	hda_nid_t pin_nid = per_pin->pin_nid;
 
 	if (!(get_wcaps(codec, pin_nid) & AC_WCAP_CONN_LIST)) {
-		snd_printk(KERN_WARNING
-			   "HDMI: pin %d wcaps %#x "
-			   "does not support connection list\n",
+		codec_warn(codec,
+			   "HDMI: pin %d wcaps %#x does not support connection list\n",
 			   pin_nid, get_wcaps(codec, pin_nid));
 		return -EINVAL;
 	}
@@ -1527,7 +1529,7 @@ static bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll)
 	else
 		eld->eld_valid = false;
 
-	_snd_printd(SND_PR_VERBOSE,
+	codec_dbg(codec,
 		"HDMI status: Codec=%d Pin=%d Presence_Detect=%d ELD_Valid=%d\n",
 		codec->addr, pin_nid, pin_eld->monitor_present, eld->eld_valid);
 
@@ -1690,7 +1692,7 @@ static int hdmi_parse_codec(struct hda_codec *codec)
 
 	nodes = snd_hda_get_sub_nodes(codec, codec->afg, &nid);
 	if (!nid || nodes < 0) {
-		snd_printk(KERN_WARNING "HDMI: failed to get afg sub nodes\n");
+		codec_warn(codec, "HDMI: failed to get afg sub nodes\n");
 		return -EINVAL;
 	}
 
@@ -1744,7 +1746,7 @@ static int generic_hdmi_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
 {
 	hda_nid_t cvt_nid = hinfo->nid;
 	struct hdmi_spec *spec = codec->spec;
-	int pin_idx = hinfo_to_pin_index(spec, hinfo);
+	int pin_idx = hinfo_to_pin_index(codec, hinfo);
 	struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
 	hda_nid_t pin_nid = per_pin->pin_nid;
 	bool non_pcm;
@@ -1788,7 +1790,7 @@ static int hdmi_pcm_close(struct hda_pcm_stream *hinfo,
 	int pinctl;
 
 	if (hinfo->nid) {
-		cvt_idx = cvt_nid_to_cvt_index(spec, hinfo->nid);
+		cvt_idx = cvt_nid_to_cvt_index(codec, hinfo->nid);
 		if (snd_BUG_ON(cvt_idx < 0))
 			return -EINVAL;
 		per_cvt = get_cvt(spec, cvt_idx);
@@ -1797,7 +1799,7 @@ static int hdmi_pcm_close(struct hda_pcm_stream *hinfo,
 		per_cvt->assigned = 0;
 		hinfo->nid = 0;
 
-		pin_idx = hinfo_to_pin_index(spec, hinfo);
+		pin_idx = hinfo_to_pin_index(codec, hinfo);
 		if (snd_BUG_ON(pin_idx < 0))
 			return -EINVAL;
 		per_pin = get_pin(spec, pin_idx);
@@ -2211,7 +2213,7 @@ static void intel_haswell_fixup_connect_list(struct hda_codec *codec,
 		return;
 
 	/* override pins connection list */
-	snd_printdd("hdmi: haswell: override pin connection 0x%x\n", nid);
+	codec_dbg(codec, "hdmi: haswell: override pin connection 0x%x\n", nid);
 	snd_hda_override_conn_list(codec, nid, spec->num_cvts, spec->cvt_nids);
 }
 
@@ -3132,8 +3134,8 @@ static int atihdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,
 		else
 			hbr_ctl_new = hbr_ctl & ~ATI_HBR_ENABLE;
 
-		snd_printdd("atihdmi_pin_hbr_setup: "
-				"NID=0x%x, %shbr-ctl=0x%x\n",
+		codec_dbg(codec,
+			  "atihdmi_pin_hbr_setup: NID=0x%x, %shbr-ctl=0x%x\n",
 				pin_nid,
 				hbr_ctl == hbr_ctl_new ? "" : "new-",
 				hbr_ctl_new);
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index fffe74b482ac..ffb5c366d1ea 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -405,8 +405,8 @@ static int alc_auto_parse_customize_define(struct hda_codec *codec)
 	ass = snd_hda_codec_get_pincfg(codec, nid);
 
 	if (!(ass & 1)) {
-		printk(KERN_INFO "hda_codec: %s: SKU not ready 0x%08x\n",
-		       codec->chip_name, ass);
+		codec_info(codec, "%s: SKU not ready 0x%08x\n",
+			   codec->chip_name, ass);
 		return -1;
 	}
 
@@ -430,17 +430,17 @@ do_sku:
 	spec->cdefine.swap = (ass & 0x2) >> 1;
 	spec->cdefine.override = ass & 0x1;
 
-	snd_printd("SKU: Nid=0x%x sku_cfg=0x%08x\n",
+	codec_dbg(codec, "SKU: Nid=0x%x sku_cfg=0x%08x\n",
 		   nid, spec->cdefine.sku_cfg);
-	snd_printd("SKU: port_connectivity=0x%x\n",
+	codec_dbg(codec, "SKU: port_connectivity=0x%x\n",
 		   spec->cdefine.port_connectivity);
-	snd_printd("SKU: enable_pcbeep=0x%x\n", spec->cdefine.enable_pcbeep);
-	snd_printd("SKU: check_sum=0x%08x\n", spec->cdefine.check_sum);
-	snd_printd("SKU: customization=0x%08x\n", spec->cdefine.customization);
-	snd_printd("SKU: external_amp=0x%x\n", spec->cdefine.external_amp);
-	snd_printd("SKU: platform_type=0x%x\n", spec->cdefine.platform_type);
-	snd_printd("SKU: swap=0x%x\n", spec->cdefine.swap);
-	snd_printd("SKU: override=0x%x\n", spec->cdefine.override);
+	codec_dbg(codec, "SKU: enable_pcbeep=0x%x\n", spec->cdefine.enable_pcbeep);
+	codec_dbg(codec, "SKU: check_sum=0x%08x\n", spec->cdefine.check_sum);
+	codec_dbg(codec, "SKU: customization=0x%08x\n", spec->cdefine.customization);
+	codec_dbg(codec, "SKU: external_amp=0x%x\n", spec->cdefine.external_amp);
+	codec_dbg(codec, "SKU: platform_type=0x%x\n", spec->cdefine.platform_type);
+	codec_dbg(codec, "SKU: swap=0x%x\n", spec->cdefine.swap);
+	codec_dbg(codec, "SKU: override=0x%x\n", spec->cdefine.override);
 
 	return 0;
 }
@@ -499,8 +499,8 @@ static int alc_subsystem_id(struct hda_codec *codec, const hda_nid_t *ports)
 	if (codec->vendor_id == 0x10ec0260)
 		nid = 0x17;
 	ass = snd_hda_codec_get_pincfg(codec, nid);
-	snd_printd("realtek: No valid SSID, "
-		   "checking pincfg 0x%08x for NID 0x%x\n",
+	codec_dbg(codec,
+		  "realtek: No valid SSID, checking pincfg 0x%08x for NID 0x%x\n",
 		   ass, nid);
 	if (!(ass & 1))
 		return 0;
@@ -516,7 +516,7 @@ static int alc_subsystem_id(struct hda_codec *codec, const hda_nid_t *ports)
 	if (((ass >> 16) & 0xf) != tmp)
 		return 0;
 do_sku:
-	snd_printd("realtek: Enabling init ASM_ID=0x%04x CODEC_ID=%08x\n",
+	codec_dbg(codec, "realtek: Enabling init ASM_ID=0x%04x CODEC_ID=%08x\n",
 		   ass & 0xffff, codec->vendor_id);
 	/*
 	 * 0 : override
@@ -574,8 +574,8 @@ static void alc_ssid_check(struct hda_codec *codec, const hda_nid_t *ports)
 {
 	if (!alc_subsystem_id(codec, ports)) {
 		struct alc_spec *spec = codec->spec;
-		snd_printd("realtek: "
-			   "Enable default setup for auto mode as fallback\n");
+		codec_dbg(codec,
+			  "realtek: Enable default setup for auto mode as fallback\n");
 		spec->init_amp = ALC_INIT_DEFAULT;
 	}
 }
@@ -3165,7 +3165,8 @@ static void alc269_fixup_hp_mute_led(struct hda_codec *codec,
 		spec->gen.vmaster_mute.hook = alc269_fixup_mic_mute_hook;
 		spec->gen.vmaster_mute_enum = 1;
 		codec->power_filter = led_power_filter;
-		snd_printd("Detected mute LED for %x:%d\n", spec->mute_led_nid,
+		codec_dbg(codec,
+			  "Detected mute LED for %x:%d\n", spec->mute_led_nid,
 			   spec->mute_led_polarity);
 		break;
 	}
@@ -3291,7 +3292,7 @@ static void alc_headset_mode_unplugged(struct hda_codec *codec)
 		alc_write_coef_idx(codec, 0xb7, 0x802b);
 		break;
 	}
-	snd_printdd("Headset jack set to unplugged mode.\n");
+	codec_dbg(codec, "Headset jack set to unplugged mode.\n");
 }
 
 
@@ -3334,7 +3335,7 @@ static void alc_headset_mode_mic_in(struct hda_codec *codec, hda_nid_t hp_pin,
 		snd_hda_set_pin_ctl_cache(codec, mic_pin, PIN_VREF50);
 		break;
 	}
-	snd_printdd("Headset jack set to mic-in mode.\n");
+	codec_dbg(codec, "Headset jack set to mic-in mode.\n");
 }
 
 static void alc_headset_mode_default(struct hda_codec *codec)
@@ -3362,7 +3363,7 @@ static void alc_headset_mode_default(struct hda_codec *codec)
 		alc_write_coef_idx(codec, 0xb7, 0x802b);
 		break;
 	}
-	snd_printdd("Headset jack set to headphone (default) mode.\n");
+	codec_dbg(codec, "Headset jack set to headphone (default) mode.\n");
 }
 
 /* Iphone type */
@@ -3391,7 +3392,7 @@ static void alc_headset_mode_ctia(struct hda_codec *codec)
 		alc_write_coef_idx(codec, 0xc3, 0x0000);
 		break;
 	}
-	snd_printdd("Headset jack set to iPhone-style headset mode.\n");
+	codec_dbg(codec, "Headset jack set to iPhone-style headset mode.\n");
 }
 
 /* Nokia type */
@@ -3420,7 +3421,7 @@ static void alc_headset_mode_omtp(struct hda_codec *codec)
 		alc_write_coef_idx(codec, 0xc3, 0x0000);
 		break;
 	}
-	snd_printdd("Headset jack set to Nokia-style headset mode.\n");
+	codec_dbg(codec, "Headset jack set to Nokia-style headset mode.\n");
 }
 
 static void alc_determine_headset_type(struct hda_codec *codec)
@@ -3462,7 +3463,7 @@ static void alc_determine_headset_type(struct hda_codec *codec)
 		break;
 	}
 
-	snd_printdd("Headset jack detected iPhone-style headset: %s\n",
+	codec_dbg(codec, "Headset jack detected iPhone-style headset: %s\n",
 		    is_ctia ? "yes" : "no");
 	spec->current_headset_type = is_ctia ? ALC_HEADSET_TYPE_CTIA : ALC_HEADSET_TYPE_OMTP;
 }
@@ -4847,8 +4848,7 @@ static void alc272_fixup_mario(struct hda_codec *codec,
 				      (0x3b << AC_AMPCAP_NUM_STEPS_SHIFT) |
 				      (0x03 << AC_AMPCAP_STEP_SIZE_SHIFT) |
 				      (0 << AC_AMPCAP_MUTE_SHIFT)))
-		printk(KERN_WARNING
-		       "hda_codec: failed to override amp caps for NID 0x2\n");
+		codec_warn(codec, "failed to override amp caps for NID 0x2\n");
 }
 
 static const struct snd_pcm_chmap_elem asus_pcm_2_1_chmaps[] = {
diff --git a/sound/pci/hda/patch_si3054.c b/sound/pci/hda/patch_si3054.c
index 6679a5095e55..3208ad69583e 100644
--- a/sound/pci/hda/patch_si3054.c
+++ b/sound/pci/hda/patch_si3054.c
@@ -236,7 +236,7 @@ static int si3054_init(struct hda_codec *codec)
 	} while ((val & SI3054_MEI_READY) != SI3054_MEI_READY && wait_count--);
 
 	if((val&SI3054_MEI_READY) != SI3054_MEI_READY) {
-		snd_printk(KERN_ERR "si3054: cannot initialize. EXT MID = %04x\n", val);
+		codec_err(codec, "si3054: cannot initialize. EXT MID = %04x\n", val);
 		/* let's pray that this is no fatal error */
 		/* return -EACCES; */
 	}
@@ -247,7 +247,8 @@ static int si3054_init(struct hda_codec *codec)
 	SET_REG(codec, SI3054_LINE_CFG1,0x200);
 
 	if((GET_REG(codec,SI3054_LINE_STATUS) & (1<<6)) == 0) {
-		snd_printd("Link Frame Detect(FDT) is not ready (line status: %04x)\n",
+		codec_dbg(codec,
+			  "Link Frame Detect(FDT) is not ready (line status: %04x)\n",
 				GET_REG(codec,SI3054_LINE_STATUS));
 	}
 
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index 3bc29c9b2529..f3784808758e 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -296,7 +296,7 @@ static void stac_gpio_set(struct hda_codec *codec, unsigned int mask,
 {
 	unsigned int gpiostate, gpiomask, gpiodir;
 
-	snd_printdd("%s msk %x dir %x gpio %x\n", __func__, mask, dir_mask, data);
+	codec_dbg(codec, "%s msk %x dir %x gpio %x\n", __func__, mask, dir_mask, data);
 
 	gpiostate = snd_hda_codec_read(codec, codec->afg, 0,
 				       AC_VERB_GET_GPIO_DATA, 0);
@@ -359,7 +359,7 @@ static int stac_vrefout_set(struct hda_codec *codec,
 {
 	int error, pinctl;
 
-	snd_printdd("%s, nid %x ctl %x\n", __func__, nid, new_vref);
+	codec_dbg(codec, "%s, nid %x ctl %x\n", __func__, nid, new_vref);
 	pinctl = snd_hda_codec_read(codec, nid, 0,
 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 
@@ -2086,7 +2086,7 @@ static void stac92hd83xxx_fixup_hp(struct hda_codec *codec,
 	}
 
 	if (find_mute_led_cfg(codec, spec->default_polarity))
-		snd_printd("mute LED gpio %d polarity %d\n",
+		codec_dbg(codec, "mute LED gpio %d polarity %d\n",
 				spec->gpio_led,
 				spec->gpio_led_polarity);
 }
@@ -3077,7 +3077,7 @@ static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,
 	}
 
 	if (find_mute_led_cfg(codec, 1))
-		snd_printd("mute LED gpio %d polarity %d\n",
+		codec_dbg(codec, "mute LED gpio %d polarity %d\n",
 				spec->gpio_led,
 				spec->gpio_led_polarity);
 
@@ -4422,8 +4422,8 @@ static int patch_stac92hd73xx(struct hda_codec *codec)
 
 	num_dacs = snd_hda_get_num_conns(codec, 0x0a) - 1;
 	if (num_dacs < 3 || num_dacs > 5) {
-		printk(KERN_WARNING "hda_codec: Could not determine "
-		       "number of channels defaulting to DAC count\n");
+		codec_warn(codec,
+			   "Could not determine number of channels defaulting to DAC count\n");
 		num_dacs = 5;
 	}
 
diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c
index 8fe3b8c18ed4..6ba0b5517c40 100644
--- a/sound/pci/hda/thinkpad_helper.c
+++ b/sound/pci/hda/thinkpad_helper.c
@@ -63,7 +63,8 @@ static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,
 		if (!led_set_func)
 			led_set_func = symbol_request(tpacpi_led_set);
 		if (!led_set_func) {
-			snd_printk(KERN_WARNING "Failed to find thinkpad-acpi symbol tpacpi_led_set\n");
+			codec_warn(codec,
+				   "Failed to find thinkpad-acpi symbol tpacpi_led_set\n");
 			return;
 		}
 
@@ -75,7 +76,8 @@ static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) >= 0) {
 			if (spec->num_adc_nids > 1)
-				snd_printdd("Skipping micmute LED control due to several ADCs");
+				codec_dbg(codec,
+					  "Skipping micmute LED control due to several ADCs");
 			else {
 				spec->cap_sync_hook = update_tpacpi_micmute_led;
 				removefunc = false;
