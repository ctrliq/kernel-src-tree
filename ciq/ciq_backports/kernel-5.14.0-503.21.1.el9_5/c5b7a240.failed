gfs2: Only defer deletes when we have an iopen glock

jira LE-2290
Rebuild_History Non-Buildable kernel-5.14.0-503.21.1.el9_5
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit c5b7a2400edc458b22133d5e5394bea26eab1923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-503.21.1.el9_5/c5b7a240.failed

The mechanism to defer deleting unlinked inodes is tied to
delete_work_func(), which is tied to iopen glocks.  When we don't have
an iopen glock, we must carry out deletes immediately instead.

Fixes a NULL pointer dereference in gfs2_evict_inode().

Fixes: 8c21c2c71e66 ("gfs2: Call gfs2_queue_verify_delete from gfs2_evict_inode")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit c5b7a2400edc458b22133d5e5394bea26eab1923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index 245ffcb2e060,92a3b6ddafdc..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1504,11 -1498,20 +1504,28 @@@ static void gfs2_evict_inode(struct ino
  	if (!sdp->sd_jdesc)
  		goto out;
  
++<<<<<<< HEAD
 +	gfs2_holder_mark_uninitialized(&gh);
 +	ret = evict_should_delete(inode, &gh);
 +	if (ret == SHOULD_DEFER_EVICTION)
 +		goto out;
 +	if (ret == SHOULD_DELETE_DINODE)
++=======
+ 	behavior = evict_should_delete(inode, &gh);
+ 	if (behavior == EVICT_SHOULD_DEFER_DELETE &&
+ 	    !test_bit(SDF_KILL, &sdp->sd_flags)) {
+ 		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
+ 
+ 		if (io_gl) {
+ 			gfs2_glock_hold(io_gl);
+ 			if (!gfs2_queue_verify_delete(io_gl, true))
+ 				gfs2_glock_put(io_gl);
+ 			goto out;
+ 		}
+ 		behavior = EVICT_SHOULD_DELETE;
+ 	}
+ 	if (behavior == EVICT_SHOULD_DELETE)
++>>>>>>> c5b7a2400edc (gfs2: Only defer deletes when we have an iopen glock)
  		ret = evict_unlinked_inode(inode);
  	else
  		ret = evict_linked_inode(inode);
* Unmerged path fs/gfs2/super.c
