gfs2: Call gfs2_queue_verify_delete from gfs2_evict_inode

jira LE-2290
Rebuild_History Non-Buildable kernel-5.14.0-503.21.1.el9_5
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 8c21c2c71e668a5eed9fe9981a2306f9178e6c3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-503.21.1.el9_5/8c21c2c7.failed

Move calls to gfs2_queue_verify_delete() into gfs2_evict_inode().

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 8c21c2c71e668a5eed9fe9981a2306f9178e6c3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index 245ffcb2e060,340bc21de218..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1505,10 -1498,17 +1505,24 @@@ static void gfs2_evict_inode(struct ino
  		goto out;
  
  	gfs2_holder_mark_uninitialized(&gh);
++<<<<<<< HEAD
 +	ret = evict_should_delete(inode, &gh);
 +	if (ret == SHOULD_DEFER_EVICTION)
 +		goto out;
 +	if (ret == SHOULD_DELETE_DINODE)
++=======
+ 	behavior = evict_should_delete(inode, &gh);
+ 	if (behavior == EVICT_SHOULD_DEFER_DELETE &&
+ 	    !test_bit(SDF_KILL, &sdp->sd_flags)) {
+ 		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
+ 
+ 		gfs2_glock_hold(io_gl);
+ 		if (!gfs2_queue_verify_delete(io_gl, true))
+ 			gfs2_glock_put(io_gl);
+ 		goto out;
+ 	}
+ 	if (behavior == EVICT_SHOULD_DELETE)
++>>>>>>> 8c21c2c71e66 (gfs2: Call gfs2_queue_verify_delete from gfs2_evict_inode)
  		ret = evict_unlinked_inode(inode);
  	else
  		ret = evict_linked_inode(inode);
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 65d0f1b4bee1..737729a2c99a 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -971,10 +971,9 @@ static void gfs2_glock_poke(struct gfs2_glock *gl)
 	gfs2_holder_uninit(&gh);
 }
 
-static bool gfs2_try_evict(struct gfs2_glock *gl)
+static void gfs2_try_evict(struct gfs2_glock *gl)
 {
 	struct gfs2_inode *ip;
-	bool evicted = false;
 
 	/*
 	 * If there is contention on the iopen glock and we have an inode, try
@@ -1009,9 +1008,7 @@ static bool gfs2_try_evict(struct gfs2_glock *gl)
 			gfs2_glock_poke(ip->i_gl);
 			iput(&ip->i_inode);
 		}
-		evicted = !ip;
 	}
-	return evicted;
 }
 
 bool gfs2_queue_try_to_evict(struct gfs2_glock *gl)
@@ -1060,13 +1057,7 @@ static void delete_work_func(struct work_struct *work)
 		 * care about compatibility with such nodes, we can skip this
 		 * step entirely.
 		 */
-		if (gfs2_try_evict(gl)) {
-			if (!test_bit(SDF_KILL, &sdp->sd_flags)) {
-				gfs2_glock_hold(gl);
-				if (!gfs2_queue_verify_delete(gl, true))
-					gfs2_glock_put(gl);
-			}
-		}
+		gfs2_try_evict(gl);
 	}
 
 	if (verify_delete) {
* Unmerged path fs/gfs2/super.c
