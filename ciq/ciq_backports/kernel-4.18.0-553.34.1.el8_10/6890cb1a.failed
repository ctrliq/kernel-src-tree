x86/cpu/intel: Detect TME keyid bits before setting MTRR mask registers

jira LE-2289
Rebuild_History Non-Buildable kernel-4.18.0-553.34.1.el8_10
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 6890cb1ace350b4386c8aee1343dc3b3ddd214da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.34.1.el8_10/6890cb1a.failed

MKTME repurposes the high bit of physical address to key id for encryption
key and, even though MAXPHYADDR in CPUID[0x80000008] remains the same,
the valid bits in the MTRR mask register are based on the reduced number
of physical address bits.

detect_tme() in arch/x86/kernel/cpu/intel.c detects TME and subtracts
it from the total usable physical bits, but it is called too late.
Move the call to early_init_intel() so that it is called in setup_arch(),
before MTRRs are setup.

This fixes boot on TDX-enabled systems, which until now only worked with
"disable_mtrr_cleanup".  Without the patch, the values written to the
MTRRs mask registers were 52-bit wide (e.g. 0x000fffff_80000800) and
the writes failed; with the patch, the values are 46-bit wide, which
matches the reduced MAXPHYADDR that is shown in /proc/cpuinfo.

	Reported-by: Zixi Chen <zixchen@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Cc:stable@vger.kernel.org
Link: https://lore.kernel.org/all/20240131230902.1867092-3-pbonzini%40redhat.com
(cherry picked from commit 6890cb1ace350b4386c8aee1343dc3b3ddd214da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel.c
diff --cc arch/x86/kernel/cpu/intel.c
index dbe876ce744c,40dec9b56f87..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -217,179 -184,89 +217,265 @@@ static bool bad_spectre_microcode(struc
  	return false;
  }
  
++<<<<<<< HEAD
 +int intel_cpu_collect_info(struct ucode_cpu_info *uci)
 +{
 +	unsigned int val[2];
 +	unsigned int family, model;
 +	struct cpu_signature csig = { 0 };
 +	unsigned int eax, ebx, ecx, edx;
 +
 +	memset(uci, 0, sizeof(*uci));
 +
 +	eax = 0x00000001;
 +	ecx = 0;
 +	native_cpuid(&eax, &ebx, &ecx, &edx);
 +	csig.sig = eax;
 +
 +	family = x86_family(eax);
 +	model  = x86_model(eax);
 +
 +	if (model >= 5 || family > 6) {
 +		/* get processor flags from MSR 0x17 */
 +		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);
 +		csig.pf = 1 << ((val[1] >> 18) & 7);
 +	}
 +
 +	csig.rev = intel_get_microcode_revision();
 +
 +	uci->cpu_sig = csig;
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(intel_cpu_collect_info);
 +
 +/*
 + * Returns 1 if update has been found, 0 otherwise.
 + */
 +int intel_find_matching_signature(void *mc, unsigned int csig, int cpf)
 +{
 +	struct microcode_header_intel *mc_hdr = mc;
 +	struct extended_sigtable *ext_hdr;
 +	struct extended_signature *ext_sig;
 +	int i;
 +
 +	if (intel_cpu_signatures_match(csig, cpf, mc_hdr->sig, mc_hdr->pf))
 +		return 1;
 +
 +	/* Look for ext. headers: */
 +	if (get_totalsize(mc_hdr) <= get_datasize(mc_hdr) + MC_HEADER_SIZE)
 +		return 0;
 +
 +	ext_hdr = mc + get_datasize(mc_hdr) + MC_HEADER_SIZE;
 +	ext_sig = (void *)ext_hdr + EXT_HEADER_SIZE;
 +
 +	for (i = 0; i < ext_hdr->count; i++) {
 +		if (intel_cpu_signatures_match(csig, cpf, ext_sig->sig, ext_sig->pf))
 +			return 1;
 +		ext_sig++;
 +	}
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(intel_find_matching_signature);
 +
 +/**
 + * intel_microcode_sanity_check() - Sanity check microcode file.
 + * @mc: Pointer to the microcode file contents.
 + * @print_err: Display failure reason if true, silent if false.
 + * @hdr_type: Type of file, i.e. normal microcode file or In Field Scan file.
 + *            Validate if the microcode header type matches with the type
 + *            specified here.
 + *
 + * Validate certain header fields and verify if computed checksum matches
 + * with the one specified in the header.
 + *
 + * Return: 0 if the file passes all the checks, -EINVAL if any of the checks
 + * fail.
 + */
 +int intel_microcode_sanity_check(void *mc, bool print_err, int hdr_type)
 +{
 +	unsigned long total_size, data_size, ext_table_size;
 +	struct microcode_header_intel *mc_header = mc;
 +	struct extended_sigtable *ext_header = NULL;
 +	u32 sum, orig_sum, ext_sigcount = 0, i;
 +	struct extended_signature *ext_sig;
 +
 +	total_size = get_totalsize(mc_header);
 +	data_size = get_datasize(mc_header);
 +
 +	if (data_size + MC_HEADER_SIZE > total_size) {
 +		if (print_err)
 +			pr_err("Error: bad microcode data file size.\n");
 +		return -EINVAL;
 +	}
 +
 +	if (mc_header->ldrver != 1 || mc_header->hdrver != hdr_type) {
 +		if (print_err)
 +			pr_err("Error: invalid/unknown microcode update format. Header type %d\n",
 +			       mc_header->hdrver);
 +		return -EINVAL;
 +	}
 +
 +	ext_table_size = total_size - (MC_HEADER_SIZE + data_size);
 +	if (ext_table_size) {
 +		u32 ext_table_sum = 0;
 +		u32 *ext_tablep;
 +
 +		if (ext_table_size < EXT_HEADER_SIZE ||
 +		    ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {
 +			if (print_err)
 +				pr_err("Error: truncated extended signature table.\n");
 +			return -EINVAL;
 +		}
 +
 +		ext_header = mc + MC_HEADER_SIZE + data_size;
 +		if (ext_table_size != exttable_size(ext_header)) {
 +			if (print_err)
 +				pr_err("Error: extended signature table size mismatch.\n");
 +			return -EFAULT;
 +		}
 +
 +		ext_sigcount = ext_header->count;
 +
 +		/*
 +		 * Check extended table checksum: the sum of all dwords that
 +		 * comprise a valid table must be 0.
 +		 */
 +		ext_tablep = (u32 *)ext_header;
 +
 +		i = ext_table_size / sizeof(u32);
 +		while (i--)
 +			ext_table_sum += ext_tablep[i];
 +
 +		if (ext_table_sum) {
 +			if (print_err)
 +				pr_warn("Bad extended signature table checksum, aborting.\n");
 +			return -EINVAL;
 +		}
 +	}
 +
 +	/*
 +	 * Calculate the checksum of update data and header. The checksum of
 +	 * valid update data and header including the extended signature table
 +	 * must be 0.
 +	 */
 +	orig_sum = 0;
 +	i = (MC_HEADER_SIZE + data_size) / sizeof(u32);
 +	while (i--)
 +		orig_sum += ((u32 *)mc)[i];
 +
 +	if (orig_sum) {
 +		if (print_err)
 +			pr_err("Bad microcode data checksum, aborting.\n");
 +		return -EINVAL;
 +	}
 +
 +	if (!ext_table_size)
 +		return 0;
 +
 +	/*
 +	 * Check extended signature checksum: 0 => valid.
 +	 */
 +	for (i = 0; i < ext_sigcount; i++) {
 +		ext_sig = (void *)ext_header + EXT_HEADER_SIZE +
 +			  EXT_SIGNATURE_SIZE * i;
 +
 +		sum = (mc_header->sig + mc_header->pf + mc_header->cksum) -
 +		      (ext_sig->sig + ext_sig->pf + ext_sig->cksum);
 +		if (sum) {
 +			if (print_err)
 +				pr_err("Bad extended signature checksum, aborting.\n");
 +			return -EINVAL;
 +		}
 +	}
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(intel_microcode_sanity_check);
++=======
+ #define MSR_IA32_TME_ACTIVATE		0x982
+ 
+ /* Helpers to access TME_ACTIVATE MSR */
+ #define TME_ACTIVATE_LOCKED(x)		(x & 0x1)
+ #define TME_ACTIVATE_ENABLED(x)		(x & 0x2)
+ 
+ #define TME_ACTIVATE_POLICY(x)		((x >> 4) & 0xf)	/* Bits 7:4 */
+ #define TME_ACTIVATE_POLICY_AES_XTS_128	0
+ 
+ #define TME_ACTIVATE_KEYID_BITS(x)	((x >> 32) & 0xf)	/* Bits 35:32 */
+ 
+ #define TME_ACTIVATE_CRYPTO_ALGS(x)	((x >> 48) & 0xffff)	/* Bits 63:48 */
+ #define TME_ACTIVATE_CRYPTO_AES_XTS_128	1
+ 
+ /* Values for mktme_status (SW only construct) */
+ #define MKTME_ENABLED			0
+ #define MKTME_DISABLED			1
+ #define MKTME_UNINITIALIZED		2
+ static int mktme_status = MKTME_UNINITIALIZED;
+ 
+ static void detect_tme_early(struct cpuinfo_x86 *c)
+ {
+ 	u64 tme_activate, tme_policy, tme_crypto_algs;
+ 	int keyid_bits = 0, nr_keyids = 0;
+ 	static u64 tme_activate_cpu0 = 0;
+ 
+ 	rdmsrl(MSR_IA32_TME_ACTIVATE, tme_activate);
+ 
+ 	if (mktme_status != MKTME_UNINITIALIZED) {
+ 		if (tme_activate != tme_activate_cpu0) {
+ 			/* Broken BIOS? */
+ 			pr_err_once("x86/tme: configuration is inconsistent between CPUs\n");
+ 			pr_err_once("x86/tme: MKTME is not usable\n");
+ 			mktme_status = MKTME_DISABLED;
+ 
+ 			/* Proceed. We may need to exclude bits from x86_phys_bits. */
+ 		}
+ 	} else {
+ 		tme_activate_cpu0 = tme_activate;
+ 	}
+ 
+ 	if (!TME_ACTIVATE_LOCKED(tme_activate) || !TME_ACTIVATE_ENABLED(tme_activate)) {
+ 		pr_info_once("x86/tme: not enabled by BIOS\n");
+ 		mktme_status = MKTME_DISABLED;
+ 		return;
+ 	}
+ 
+ 	if (mktme_status != MKTME_UNINITIALIZED)
+ 		goto detect_keyid_bits;
+ 
+ 	pr_info("x86/tme: enabled by BIOS\n");
+ 
+ 	tme_policy = TME_ACTIVATE_POLICY(tme_activate);
+ 	if (tme_policy != TME_ACTIVATE_POLICY_AES_XTS_128)
+ 		pr_warn("x86/tme: Unknown policy is active: %#llx\n", tme_policy);
+ 
+ 	tme_crypto_algs = TME_ACTIVATE_CRYPTO_ALGS(tme_activate);
+ 	if (!(tme_crypto_algs & TME_ACTIVATE_CRYPTO_AES_XTS_128)) {
+ 		pr_err("x86/mktme: No known encryption algorithm is supported: %#llx\n",
+ 				tme_crypto_algs);
+ 		mktme_status = MKTME_DISABLED;
+ 	}
+ detect_keyid_bits:
+ 	keyid_bits = TME_ACTIVATE_KEYID_BITS(tme_activate);
+ 	nr_keyids = (1UL << keyid_bits) - 1;
+ 	if (nr_keyids) {
+ 		pr_info_once("x86/mktme: enabled by BIOS\n");
+ 		pr_info_once("x86/mktme: %d KeyIDs available\n", nr_keyids);
+ 	} else {
+ 		pr_info_once("x86/mktme: disabled by BIOS\n");
+ 	}
+ 
+ 	if (mktme_status == MKTME_UNINITIALIZED) {
+ 		/* MKTME is usable */
+ 		mktme_status = MKTME_ENABLED;
+ 	}
+ 
+ 	/*
+ 	 * KeyID bits effectively lower the number of physical address
+ 	 * bits.  Update cpuinfo_x86::x86_phys_bits accordingly.
+ 	 */
+ 	c->x86_phys_bits -= keyid_bits;
+ }
++>>>>>>> 6890cb1ace35 (x86/cpu/intel: Detect TME keyid bits before setting MTRR mask registers)
  
  static void early_init_intel(struct cpuinfo_x86 *c)
  {
* Unmerged path arch/x86/kernel/cpu/intel.c
