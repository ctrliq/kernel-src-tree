cleanup: Add conditional guard support

jira LE-3587
Rebuild_History Non-Buildable kernel-4.18.0-553.62.1.el8_10
commit-author Peter Zijlstra <peterz@infradead.org>
commit e4ab322fbaaaf84b23d6cb0e3317a7f68baf36dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.62.1.el8_10/e4ab322f.failed

Adds:

 - DEFINE_GUARD_COND() / DEFINE_LOCK_GUARD_1_COND() to extend existing
   guards with conditional lock primitives, eg. mutex_trylock(),
   mutex_lock_interruptible().

   nb. both primitives allow NULL 'locks', which cause the lock to
       fail (obviously).

 - extends scoped_guard() to not take the body when the the
   conditional guard 'fails'. eg.

     scoped_guard (mutex_intr, &task->signal_cred_guard_mutex) {
	...
     }

   will only execute the body when the mutex is held.

 - provides scoped_cond_guard(name, fail, args...); which extends
   scoped_guard() to do fail when the lock-acquire fails.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20231102110706.460851167%40infradead.org
(cherry picked from commit e4ab322fbaaaf84b23d6cb0e3317a7f68baf36dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cleanup.h
#	include/linux/mutex.h
#	include/linux/rwsem.h
#	include/linux/spinlock.h
diff --cc include/linux/mutex.h
index 997f1bb49f2b,95d11308f995..000000000000
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@@ -220,29 -220,8 +220,35 @@@ extern void mutex_unlock(struct mutex *
  
  extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
  
++<<<<<<< HEAD
 +/*
 + * These values are chosen such that FAIL and SUCCESS match the
 + * values of the regular mutex_trylock().
 + */
 +enum mutex_trylock_recursive_enum {
 +	MUTEX_TRYLOCK_FAILED    = 0,
 +	MUTEX_TRYLOCK_SUCCESS   = 1,
 +	MUTEX_TRYLOCK_RECURSIVE,
 +};
 +
 +/**
 + * mutex_trylock_recursive - trylock variant that allows recursive locking
 + * @lock: mutex to be locked
 + *
 + * This function should not be used, _ever_. It is purely for hysterical GEM
 + * raisins, and once those are gone this will be removed.
 + *
 + * Returns:
 + *  - MUTEX_TRYLOCK_FAILED    - trylock failed,
 + *  - MUTEX_TRYLOCK_SUCCESS   - lock acquired,
 + *  - MUTEX_TRYLOCK_RECURSIVE - we already owned the lock.
 + */
 +extern /* __deprecated */ __must_check enum mutex_trylock_recursive_enum
 +mutex_trylock_recursive(struct mutex *lock);
++=======
+ DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))
+ DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))
+ DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T) == 0)
++>>>>>>> e4ab322fbaaa (cleanup: Add conditional guard support)
  
  #endif /* __LINUX_MUTEX_H */
diff --cc include/linux/rwsem.h
index 897f14f3ab0d,9c29689ff505..000000000000
--- a/include/linux/rwsem.h
+++ b/include/linux/rwsem.h
@@@ -195,6 -202,13 +195,16 @@@ extern void up_read(struct rw_semaphor
   */
  extern void up_write(struct rw_semaphore *sem);
  
++<<<<<<< HEAD
++=======
+ DEFINE_GUARD(rwsem_read, struct rw_semaphore *, down_read(_T), up_read(_T))
+ DEFINE_GUARD_COND(rwsem_read, _try, down_read_trylock(_T))
+ DEFINE_GUARD_COND(rwsem_read, _intr, down_read_interruptible(_T) == 0)
+ 
+ DEFINE_GUARD(rwsem_write, struct rw_semaphore *, down_write(_T), up_write(_T))
+ DEFINE_GUARD_COND(rwsem_write, _try, down_write_trylock(_T))
+ 
++>>>>>>> e4ab322fbaaa (cleanup: Add conditional guard support)
  /*
   * downgrade write lock to read lock
   */
diff --cc include/linux/spinlock.h
index f7eafe0a7b5b,ceb56b39c70f..000000000000
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@@ -493,27 -503,50 +493,70 @@@ int __alloc_bucket_spinlocks(spinlock_
  
  void free_bucket_spinlocks(spinlock_t *locks);
  
 -DEFINE_LOCK_GUARD_1(raw_spinlock, raw_spinlock_t,
 -		    raw_spin_lock(_T->lock),
 -		    raw_spin_unlock(_T->lock))
 +/*
 + * RHEL8 qrwlock macros
 + */
 +#ifndef qrwlock_t
 +#define qrwlock_t	rwlock_t
 +#endif
  
++<<<<<<< HEAD
 +#ifndef qread_lock
 +#define qread_lock(l)	read_lock(l)
 +#endif
++=======
+ DEFINE_LOCK_GUARD_1_COND(raw_spinlock, _try, raw_spin_trylock(_T->lock))
+ 
+ DEFINE_LOCK_GUARD_1(raw_spinlock_nested, raw_spinlock_t,
+ 		    raw_spin_lock_nested(_T->lock, SINGLE_DEPTH_NESTING),
+ 		    raw_spin_unlock(_T->lock))
++>>>>>>> e4ab322fbaaa (cleanup: Add conditional guard support)
 +
 +#ifndef qread_unlock
 +#define qread_unlock(l)	read_unlock(l)
 +#endif
  
 -DEFINE_LOCK_GUARD_1(raw_spinlock_irq, raw_spinlock_t,
 -		    raw_spin_lock_irq(_T->lock),
 -		    raw_spin_unlock_irq(_T->lock))
++<<<<<<< HEAD
 +#ifndef qwrite_lock_irq
 +#define qwrite_lock_irq(l)	write_lock_irq(l)
 +#endif
 +
 +#ifndef qwrite_unlock_irq
 +#define qwrite_unlock_irq(l)	write_unlock_irq(l)
 +#endif
  
++=======
+ DEFINE_LOCK_GUARD_1_COND(raw_spinlock_irq, _try, raw_spin_trylock_irq(_T->lock))
+ 
+ DEFINE_LOCK_GUARD_1(raw_spinlock_irqsave, raw_spinlock_t,
+ 		    raw_spin_lock_irqsave(_T->lock, _T->flags),
+ 		    raw_spin_unlock_irqrestore(_T->lock, _T->flags),
+ 		    unsigned long flags)
+ 
+ DEFINE_LOCK_GUARD_1_COND(raw_spinlock_irqsave, _try,
+ 			 raw_spin_trylock_irqsave(_T->lock, _T->flags))
+ 
+ DEFINE_LOCK_GUARD_1(spinlock, spinlock_t,
+ 		    spin_lock(_T->lock),
+ 		    spin_unlock(_T->lock))
+ 
+ DEFINE_LOCK_GUARD_1_COND(spinlock, _try, spin_trylock(_T->lock))
+ 
+ DEFINE_LOCK_GUARD_1(spinlock_irq, spinlock_t,
+ 		    spin_lock_irq(_T->lock),
+ 		    spin_unlock_irq(_T->lock))
+ 
+ DEFINE_LOCK_GUARD_1_COND(spinlock_irq, _try,
+ 			 spin_trylock_irq(_T->lock))
+ 
+ DEFINE_LOCK_GUARD_1(spinlock_irqsave, spinlock_t,
+ 		    spin_lock_irqsave(_T->lock, _T->flags),
+ 		    spin_unlock_irqrestore(_T->lock, _T->flags),
+ 		    unsigned long flags)
+ 
+ DEFINE_LOCK_GUARD_1_COND(spinlock_irqsave, _try,
+ 			 spin_trylock_irqsave(_T->lock, _T->flags))
+ 
+ #undef __LINUX_INSIDE_SPINLOCK_H
++>>>>>>> e4ab322fbaaa (cleanup: Add conditional guard support)
  #endif /* __LINUX_SPINLOCK_H */
* Unmerged path include/linux/cleanup.h
* Unmerged path include/linux/cleanup.h
* Unmerged path include/linux/mutex.h
* Unmerged path include/linux/rwsem.h
* Unmerged path include/linux/spinlock.h
