s390/pci: Fix leak of struct zpci_dev when zpci_add_device() fails

jira LE-2349
Rebuild_History Non-Buildable kernel-4.18.0-553.40.1.el8_10
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 48796104c864cf4dafa80bd8c2ce88f9c92a65ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.40.1.el8_10/48796104.failed

Prior to commit 0467cdde8c43 ("s390/pci: Sort PCI functions prior to
creating virtual busses") the IOMMU was initialized and the device was
registered as part of zpci_create_device() with the struct zpci_dev
freed if either resulted in an error. With that commit this was moved
into a separate function called zpci_add_device().

While this new function logs when adding failed, it expects the caller
not to use and to free the struct zpci_dev on error. This difference
between it and zpci_create_device() was missed while changing the
callers and the incompletely initialized struct zpci_dev may get used in
zpci_scan_configured_device in the error path. This then leads to
a crash due to the device not being registered with the zbus. It was
also not freed in this case. Fix this by handling the error return of
zpci_add_device(). Since in this case the zdev was not added to the
zpci_list it can simply be discarded and freed. Also make this more
explicit by moving the kref_init() into zpci_add_device() and document
that zpci_zdev_get()/zpci_zdev_put() must be used after adding.

	Cc: stable@vger.kernel.org
Fixes: 0467cdde8c43 ("s390/pci: Sort PCI functions prior to creating virtual busses")
	Reviewed-by: Gerd Bayer <gbayer@linux.ibm.com>
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 48796104c864cf4dafa80bd8c2ce88f9c92a65ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/pci/pci.c
index 162ca752cec9,6a011d040dfe..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -884,10 -801,34 +885,41 @@@ struct zpci_dev *zpci_create_device(u3
  		goto error;
  	zdev->state =  state;
  
++<<<<<<< HEAD
 +	kref_init(&zdev->kref);
 +	mutex_init(&zdev->lock);
 +	mutex_init(&zdev->kzdev_lock);
 +
++=======
+ 	mutex_init(&zdev->state_lock);
+ 	mutex_init(&zdev->fmb_lock);
+ 	mutex_init(&zdev->kzdev_lock);
+ 
+ 	return zdev;
+ 
+ error:
+ 	zpci_dbg(0, "crt fid:%x, rc:%d\n", fid, rc);
+ 	kfree(zdev);
+ 	return ERR_PTR(rc);
+ }
+ 
+ /**
+  * zpci_add_device() - Add a previously created zPCI device to the zPCI subsystem
+  * @zdev: The zPCI device to be added
+  *
+  * A struct zpci_dev is added to the zPCI subsystem and to a virtual PCI bus creating
+  * a new one as necessary. A hotplug slot is created and events start to be handled.
+  * If successful from this point on zpci_zdev_get() and zpci_zdev_put() must be used.
+  * If adding the struct zpci_dev fails the device was not added and should be freed.
+  *
+  * Return: 0 on success, or an error code otherwise
+  */
+ int zpci_add_device(struct zpci_dev *zdev)
+ {
+ 	int rc;
+ 
+ 	zpci_dbg(1, "add fid:%x, fh:%x, c:%d\n", zdev->fid, zdev->fh, zdev->state);
++>>>>>>> 48796104c864 (s390/pci: Fix leak of struct zpci_dev when zpci_add_device() fails)
  	rc = zpci_init_iommu(zdev);
  	if (rc)
  		goto error;
@@@ -1168,6 -1105,50 +1201,53 @@@ bool zpci_is_enabled(void
  	return s390_pci_initialized;
  }
  
++<<<<<<< HEAD
++=======
+ static int zpci_cmp_rid(void *priv, const struct list_head *a,
+ 			const struct list_head *b)
+ {
+ 	struct zpci_dev *za = container_of(a, struct zpci_dev, entry);
+ 	struct zpci_dev *zb = container_of(b, struct zpci_dev, entry);
+ 
+ 	/*
+ 	 * PCI functions without RID available maintain original order
+ 	 * between themselves but sort before those with RID.
+ 	 */
+ 	if (za->rid == zb->rid)
+ 		return za->rid_available > zb->rid_available;
+ 	/*
+ 	 * PCI functions with RID sort by RID ascending.
+ 	 */
+ 	return za->rid > zb->rid;
+ }
+ 
+ static void zpci_add_devices(struct list_head *scan_list)
+ {
+ 	struct zpci_dev *zdev, *tmp;
+ 
+ 	list_sort(NULL, scan_list, &zpci_cmp_rid);
+ 	list_for_each_entry_safe(zdev, tmp, scan_list, entry) {
+ 		list_del_init(&zdev->entry);
+ 		if (zpci_add_device(zdev))
+ 			kfree(zdev);
+ 	}
+ }
+ 
+ int zpci_scan_devices(void)
+ {
+ 	LIST_HEAD(scan_list);
+ 	int rc;
+ 
+ 	rc = clp_scan_pci_devices(&scan_list);
+ 	if (rc)
+ 		return rc;
+ 
+ 	zpci_add_devices(&scan_list);
+ 	zpci_bus_scan_busses();
+ 	return 0;
+ }
+ 
++>>>>>>> 48796104c864 (s390/pci: Fix leak of struct zpci_dev when zpci_add_device() fails)
  static int __init pci_base_init(void)
  {
  	int rc;
diff --cc arch/s390/pci/pci_event.c
index b3961f1016ea,7f7b732b3f3e..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -328,6 -340,10 +328,13 @@@ static void __zpci_event_availability(s
  			zdev = zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_CONFIGURED);
  			if (IS_ERR(zdev))
  				break;
++<<<<<<< HEAD
++=======
+ 			if (zpci_add_device(zdev)) {
+ 				kfree(zdev);
+ 				break;
+ 			}
++>>>>>>> 48796104c864 (s390/pci: Fix leak of struct zpci_dev when zpci_add_device() fails)
  		} else {
  			/* the configuration request may be stale */
  			if (zdev->state != ZPCI_FN_STATE_STANDBY)
@@@ -337,10 -353,17 +344,22 @@@
  		zpci_scan_configured_device(zdev, ccdf->fh);
  		break;
  	case 0x0302: /* Reserved -> Standby */
++<<<<<<< HEAD
 +		if (!zdev)
 +			zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_STANDBY);
 +		else
++=======
+ 		if (!zdev) {
+ 			zdev = zpci_create_device(ccdf->fid, ccdf->fh, ZPCI_FN_STATE_STANDBY);
+ 			if (IS_ERR(zdev))
+ 				break;
+ 			if (zpci_add_device(zdev)) {
+ 				kfree(zdev);
+ 				break;
+ 			}
+ 		} else {
++>>>>>>> 48796104c864 (s390/pci: Fix leak of struct zpci_dev when zpci_add_device() fails)
  			zpci_update_fh(zdev, ccdf->fh);
 -		}
  		break;
  	case 0x0303: /* Deconfiguration requested */
  		if (zdev) {
* Unmerged path arch/s390/pci/pci.c
* Unmerged path arch/s390/pci/pci_event.c
