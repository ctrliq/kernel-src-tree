s390/pci: Allow allocation of more than 1 MSI interrupt

jira LE-2349
Rebuild_History Non-Buildable kernel-4.18.0-553.40.1.el8_10
commit-author Gerd Bayer <gbayer@linux.ibm.com>
commit ab42fcb511fd9d241bbab7cc3ca04e34e9fc0666
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.40.1.el8_10/ab42fcb5.failed

On a PCI adapter that provides up to 8 MSI interrupt sources the s390
implementation of PCI interrupts rejected to accommodate them, although
the underlying hardware is able to support that.

For MSI-X it is sufficient to allocate a single irq_desc per msi_desc,
but for MSI multiple irq descriptors are attached to and controlled by
a single msi descriptor. Add the appropriate loops to maintain multiple
irq descriptors and tie/untie them to/from the appropriate AIBV bit, if
a device driver allocates more than 1 MSI interrupt.

Common PCI code passes on requests to allocate a number of interrupt
vectors based on the device drivers' demand and the PCI functions'
capabilities. However, the root-complex of s390 systems support just a
limited number of interrupt vectors per PCI function.
Produce a kernel log message to inform about any architecture-specific
capping that might be done.

With this change, we had a PCI adapter successfully raising
interrupts to its device driver via all 8 sources.

Fixes: a384c8924a8b ("s390/PCI: Fix single MSI only check")
	Signed-off-by: Gerd Bayer <gbayer@linux.ibm.com>
	Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit ab42fcb511fd9d241bbab7cc3ca04e34e9fc0666)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_irq.c
diff --cc arch/s390/pci/pci_irq.c
index 192f3b104ae4,84482a921332..000000000000
--- a/arch/s390/pci/pci_irq.c
+++ b/arch/s390/pci/pci_irq.c
@@@ -302,34 -289,81 +302,83 @@@ int arch_setup_msi_irqs(struct pci_dev 
  			return -ENOMEM;
  
  		/* Wire up shortcut pointer */
 -		zpci_ibv[*bit] = zdev->aibv;
 +		zpci_ibv[bit] = zdev->aibv;
  		/* Each function has its own interrupt vector */
 -		*bit = 0;
 +		bit = 0;
  	}
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ int arch_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
+ {
+ 	unsigned int hwirq, msi_vecs, irqs_per_msi, i, cpu;
+ 	struct zpci_dev *zdev = to_zpci(pdev);
+ 	struct msi_desc *msi;
+ 	struct msi_msg msg;
+ 	unsigned long bit;
+ 	int cpu_addr;
+ 	int rc, irq;
+ 
+ 	zdev->aisb = -1UL;
+ 	zdev->msi_first_bit = -1U;
+ 
+ 	msi_vecs = min_t(unsigned int, nvec, zdev->max_msi);
+ 	if (msi_vecs < nvec) {
+ 		pr_info("%s requested %d irqs, allocate system limit of %d",
+ 			pci_name(pdev), nvec, zdev->max_msi);
+ 	}
  
- 	/* Request MSI interrupts */
+ 	rc = __alloc_airq(zdev, msi_vecs, &bit);
+ 	if (rc < 0)
+ 		return rc;
++>>>>>>> ab42fcb511fd (s390/pci: Allow allocation of more than 1 MSI interrupt)
+ 
+ 	/*
+ 	 * Request MSI interrupts:
+ 	 * When using MSI, nvec_used interrupt sources and their irq
+ 	 * descriptors are controlled through one msi descriptor.
+ 	 * Thus the outer loop over msi descriptors shall run only once,
+ 	 * while two inner loops iterate over the interrupt vectors.
+ 	 * When using MSI-X, each interrupt vector/irq descriptor
+ 	 * is bound to exactly one msi descriptor (nvec_used is one).
+ 	 * So the inner loops are executed once, while the outer iterates
+ 	 * over the MSI-X descriptors.
+ 	 */
  	hwirq = bit;
++<<<<<<< HEAD
 +	for_each_pci_msi_entry(msi, pdev) {
 +		rc = -EIO;
++=======
+ 	msi_for_each_desc(msi, &pdev->dev, MSI_DESC_NOTASSOCIATED) {
++>>>>>>> ab42fcb511fd (s390/pci: Allow allocation of more than 1 MSI interrupt)
  		if (hwirq - bit >= msi_vecs)
  			break;
- 		irq = __irq_alloc_descs(-1, 0, 1, 0, THIS_MODULE,
- 				(irq_delivery == DIRECTED) ?
- 				msi->affinity : NULL);
+ 		irqs_per_msi = min_t(unsigned int, msi_vecs, msi->nvec_used);
+ 		irq = __irq_alloc_descs(-1, 0, irqs_per_msi, 0, THIS_MODULE,
+ 					(irq_delivery == DIRECTED) ?
+ 					msi->affinity : NULL);
  		if (irq < 0)
  			return -ENOMEM;
- 		rc = irq_set_msi_desc(irq, msi);
- 		if (rc)
- 			return rc;
- 		irq_set_chip_and_handler(irq, &zpci_irq_chip,
- 					 handle_percpu_irq);
+ 
+ 		for (i = 0; i < irqs_per_msi; i++) {
+ 			rc = irq_set_msi_desc_off(irq, i, msi);
+ 			if (rc)
+ 				return rc;
+ 			irq_set_chip_and_handler(irq + i, &zpci_irq_chip,
+ 						 handle_percpu_irq);
+ 		}
+ 
  		msg.data = hwirq - bit;
  		if (irq_delivery == DIRECTED) {
 -			if (msi->affinity)
 -				cpu = cpumask_first(&msi->affinity->mask);
 -			else
 -				cpu = 0;
 -			cpu_addr = smp_cpu_get_cpu_address(cpu);
 -
  			msg.address_lo = zdev->msi_addr & 0xff0000ff;
 -			msg.address_lo |= (cpu_addr << 8);
 -
 +			msg.address_lo |= msi->affinity ?
 +				(cpumask_first(&msi->affinity->mask) << 8) : 0;
  			for_each_possible_cpu(cpu) {
- 				airq_iv_set_data(zpci_ibv[cpu], hwirq, irq);
+ 				for (i = 0; i < irqs_per_msi; i++)
+ 					airq_iv_set_data(zpci_ibv[cpu],
+ 							 hwirq + i, irq + i);
  			}
  		} else {
  			msg.address_lo = zdev->msi_addr & 0xffffffff;
@@@ -362,15 -398,11 +413,23 @@@ void arch_teardown_msi_irqs(struct pci_
  		return;
  
  	/* Release MSI interrupts */
++<<<<<<< HEAD
 +	for_each_pci_msi_entry(msi, pdev) {
 +		if (!msi->irq)
 +			continue;
 +		if (msi->msi_attrib.is_msix)
 +			__pci_msix_desc_mask_irq(msi, 1);
 +		else
 +			__pci_msi_desc_mask_irq(msi, 1, 1);
 +		irq_set_msi_desc(msi->irq, NULL);
 +		irq_free_desc(msi->irq);
++=======
+ 	msi_for_each_desc(msi, &pdev->dev, MSI_DESC_ASSOCIATED) {
+ 		for (i = 0; i < msi->nvec_used; i++) {
+ 			irq_set_msi_desc(msi->irq + i, NULL);
+ 			irq_free_desc(msi->irq + i);
+ 		}
++>>>>>>> ab42fcb511fd (s390/pci: Allow allocation of more than 1 MSI interrupt)
  		msi->msg.address_lo = 0;
  		msi->msg.address_hi = 0;
  		msi->msg.data = 0;
* Unmerged path arch/s390/pci/pci_irq.c
