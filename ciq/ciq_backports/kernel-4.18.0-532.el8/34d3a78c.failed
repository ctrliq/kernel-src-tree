bpf: Make per_cpu_ptr return rdonly PTR_TO_MEM.

jira LE-1907
cve CVE-2022-0500
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Hao Luo <haoluo@google.com>
commit 34d3a78c681e8e7844b43d1a2f4671a04249c821
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/34d3a78c.failed

Tag the return type of {per, this}_cpu_ptr with RDONLY_MEM. The
returned value of this pair of helpers is kernel object, which
can not be updated by bpf programs. Previously these two helpers
return PTR_OT_MEM for kernel objects of scalar type, which allows
one to directly modify the memory. Now with RDONLY_MEM tagging,
the verifier will reject programs that write into RDONLY_MEM.

Fixes: 63d9b80dcf2c ("bpf: Introducte bpf_this_cpu_ptr()")
Fixes: eaa6bcb71ef6 ("bpf: Introduce bpf_per_cpu_ptr()")
Fixes: 4976b718c355 ("bpf: Introduce pseudo_btf_id")
	Signed-off-by: Hao Luo <haoluo@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20211217003152.48334-8-haoluo@google.com
(cherry picked from commit 34d3a78c681e8e7844b43d1a2f4671a04249c821)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/helpers.c
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/helpers.c
index e4217825e297,6a65e2a62b01..000000000000
--- a/kernel/bpf/helpers.c
+++ b/kernel/bpf/helpers.c
@@@ -670,7 -682,7 +670,11 @@@ BPF_CALL_2(bpf_per_cpu_ptr, const void 
  const struct bpf_func_proto bpf_per_cpu_ptr_proto = {
  	.func		= bpf_per_cpu_ptr,
  	.gpl_only	= false,
++<<<<<<< HEAD
 +	.ret_type	= RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL,
++=======
+ 	.ret_type	= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,
++>>>>>>> 34d3a78c681e (bpf: Make per_cpu_ptr return rdonly PTR_TO_MEM.)
  	.arg1_type	= ARG_PTR_TO_PERCPU_BTF_ID,
  	.arg2_type	= ARG_ANYTHING,
  };
diff --cc kernel/bpf/verifier.c
index 627d7910d79e,f49b3d334f4e..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -6126,14 -6666,17 +6141,25 @@@ static int check_helper_call(struct bpf
  					tname, PTR_ERR(ret));
  				return -EINVAL;
  			}
 -			regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;
 +			regs[BPF_REG_0].type =
 +				fn->ret_type == RET_PTR_TO_MEM_OR_BTF_ID ?
 +				PTR_TO_MEM : PTR_TO_MEM_OR_NULL;
  			regs[BPF_REG_0].mem_size = tsize;
  		} else {
++<<<<<<< HEAD
 +			regs[BPF_REG_0].type =
 +				fn->ret_type == RET_PTR_TO_MEM_OR_BTF_ID ?
 +				PTR_TO_BTF_ID : PTR_TO_BTF_ID_OR_NULL;
++=======
+ 			/* MEM_RDONLY may be carried from ret_flag, but it
+ 			 * doesn't apply on PTR_TO_BTF_ID. Fold it, otherwise
+ 			 * it will confuse the check of PTR_TO_BTF_ID in
+ 			 * check_mem_access().
+ 			 */
+ 			ret_flag &= ~MEM_RDONLY;
+ 
+ 			regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;
++>>>>>>> 34d3a78c681e (bpf: Make per_cpu_ptr return rdonly PTR_TO_MEM.)
  			regs[BPF_REG_0].btf = meta.ret_btf;
  			regs[BPF_REG_0].btf_id = meta.ret_btf_id;
  		}
* Unmerged path kernel/bpf/helpers.c
* Unmerged path kernel/bpf/verifier.c
