bpf: Replace RET_XXX_OR_NULL with RET_XXX | PTR_MAYBE_NULL

jira LE-1907
cve CVE-2022-0500
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Hao Luo <haoluo@google.com>
commit 3c4807322660d4290ac9062c034aed6b87243861
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/3c480732.failed

We have introduced a new type to make bpf_ret composable, by
reserving high bits to represent flags.

One of the flag is PTR_MAYBE_NULL, which indicates a pointer
may be NULL. When applying this flag to ret_types, it means
the returned value could be a NULL pointer. This patch
switches the qualified arg_types to use this flag.
The ret_types changed in this patch include:

1. RET_PTR_TO_MAP_VALUE_OR_NULL
2. RET_PTR_TO_SOCKET_OR_NULL
3. RET_PTR_TO_TCP_SOCK_OR_NULL
4. RET_PTR_TO_SOCK_COMMON_OR_NULL
5. RET_PTR_TO_ALLOC_MEM_OR_NULL
6. RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL
7. RET_PTR_TO_BTF_ID_OR_NULL

This patch doesn't eliminate the use of these names, instead
it makes them aliases to 'RET_PTR_TO_XXX | PTR_MAYBE_NULL'.

	Signed-off-by: Hao Luo <haoluo@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20211217003152.48334-4-haoluo@google.com
(cherry picked from commit 3c4807322660d4290ac9062c034aed6b87243861)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/verifier.c
diff --cc include/linux/bpf.h
index 83377e4c1c34,975a1d5951bd..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -331,16 -382,28 +331,30 @@@ enum bpf_return_type 
  	RET_INTEGER,			/* function returns integer */
  	RET_VOID,			/* function doesn't return anything */
  	RET_PTR_TO_MAP_VALUE,		/* returns a pointer to map elem value */
- 	RET_PTR_TO_MAP_VALUE_OR_NULL,	/* returns a pointer to map elem value or NULL */
- 	RET_PTR_TO_SOCKET_OR_NULL,	/* returns a pointer to a socket or NULL */
- 	RET_PTR_TO_TCP_SOCK_OR_NULL,	/* returns a pointer to a tcp_sock or NULL */
- 	RET_PTR_TO_SOCK_COMMON_OR_NULL,	/* returns a pointer to a sock_common or NULL */
- 	RET_PTR_TO_ALLOC_MEM_OR_NULL,	/* returns a pointer to dynamically allocated memory or NULL */
- 	RET_PTR_TO_BTF_ID_OR_NULL,	/* returns a pointer to a btf_id or NULL */
- 	RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL, /* returns a pointer to a valid memory or a btf_id or NULL */
+ 	RET_PTR_TO_SOCKET,		/* returns a pointer to a socket */
+ 	RET_PTR_TO_TCP_SOCK,		/* returns a pointer to a tcp_sock */
+ 	RET_PTR_TO_SOCK_COMMON,		/* returns a pointer to a sock_common */
+ 	RET_PTR_TO_ALLOC_MEM,		/* returns a pointer to dynamically allocated memory */
  	RET_PTR_TO_MEM_OR_BTF_ID,	/* returns a pointer to a valid memory or a btf_id */
  	RET_PTR_TO_BTF_ID,		/* returns a pointer to a btf_id */
++<<<<<<< HEAD
++=======
+ 	__BPF_RET_TYPE_MAX,
+ 
+ 	/* Extended ret_types. */
+ 	RET_PTR_TO_MAP_VALUE_OR_NULL	= PTR_MAYBE_NULL | RET_PTR_TO_MAP_VALUE,
+ 	RET_PTR_TO_SOCKET_OR_NULL	= PTR_MAYBE_NULL | RET_PTR_TO_SOCKET,
+ 	RET_PTR_TO_TCP_SOCK_OR_NULL	= PTR_MAYBE_NULL | RET_PTR_TO_TCP_SOCK,
+ 	RET_PTR_TO_SOCK_COMMON_OR_NULL	= PTR_MAYBE_NULL | RET_PTR_TO_SOCK_COMMON,
+ 	RET_PTR_TO_ALLOC_MEM_OR_NULL	= PTR_MAYBE_NULL | RET_PTR_TO_ALLOC_MEM,
+ 	RET_PTR_TO_BTF_ID_OR_NULL	= PTR_MAYBE_NULL | RET_PTR_TO_BTF_ID,
+ 
+ 	/* This must be the last entry. Its purpose is to ensure the enum is
+ 	 * wide enough to hold the higher bits reserved for bpf_type_flag.
+ 	 */
+ 	__BPF_RET_TYPE_LIMIT	= BPF_TYPE_LIMIT,
++>>>>>>> 3c4807322660 (bpf: Replace RET_XXX_OR_NULL with RET_XXX | PTR_MAYBE_NULL)
  };
 -static_assert(__BPF_RET_TYPE_MAX <= BPF_BASE_TYPE_LIMIT);
  
  /* eBPF function prototype used by verifier to allow BPF_CALLs from eBPF programs
   * to in-kernel helper functions and for adjusting imm32 field in BPF_CALL
diff --cc kernel/bpf/verifier.c
index 627d7910d79e,ccc068c5c5f2..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -6087,7 -6632,10 +6088,14 @@@ static int check_helper_call(struct bpf
  			return -EINVAL;
  		}
  		regs[BPF_REG_0].map_ptr = meta.map_ptr;
++<<<<<<< HEAD
 +		if (fn->ret_type == RET_PTR_TO_MAP_VALUE) {
++=======
+ 		regs[BPF_REG_0].map_uid = meta.map_uid;
+ 		if (type_may_be_null(ret_type)) {
+ 			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;
+ 		} else {
++>>>>>>> 3c4807322660 (bpf: Replace RET_XXX_OR_NULL with RET_XXX | PTR_MAYBE_NULL)
  			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE;
  			if (map_value_has_spin_lock(meta.map_ptr))
  				regs[BPF_REG_0].id = ++env->id_gen;
* Unmerged path include/linux/bpf.h
diff --git a/kernel/bpf/helpers.c b/kernel/bpf/helpers.c
index e4217825e297..4234d4fe3d96 100644
--- a/kernel/bpf/helpers.c
+++ b/kernel/bpf/helpers.c
@@ -670,7 +670,7 @@ BPF_CALL_2(bpf_per_cpu_ptr, const void *, ptr, u32, cpu)
 const struct bpf_func_proto bpf_per_cpu_ptr_proto = {
 	.func		= bpf_per_cpu_ptr,
 	.gpl_only	= false,
-	.ret_type	= RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL,
+	.ret_type	= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL,
 	.arg1_type	= ARG_PTR_TO_PERCPU_BTF_ID,
 	.arg2_type	= ARG_ANYTHING,
 };
* Unmerged path kernel/bpf/verifier.c
