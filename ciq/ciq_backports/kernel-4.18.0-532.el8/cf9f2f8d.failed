bpf: Convert PTR_TO_MEM_OR_NULL to composable types.

jira LE-1907
cve CVE-2022-0500
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Hao Luo <haoluo@google.com>
commit cf9f2f8d62eca810afbd1ee6cc0800202b000e57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/cf9f2f8d.failed

Remove PTR_TO_MEM_OR_NULL and replace it with PTR_TO_MEM combined with
flag PTR_MAYBE_NULL.

	Signed-off-by: Hao Luo <haoluo@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20211217003152.48334-7-haoluo@google.com
(cherry picked from commit cf9f2f8d62eca810afbd1ee6cc0800202b000e57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
diff --cc include/linux/bpf.h
index 83377e4c1c34,567d83bf28f9..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -431,18 -494,25 +431,33 @@@ enum bpf_reg_type 
  	 * been checked for null. Used primarily to inform the verifier
  	 * an explicit null check is required for this struct.
  	 */
 +	PTR_TO_BTF_ID_OR_NULL,
  	PTR_TO_MEM,		 /* reg points to valid memory region */
 -	PTR_TO_BUF,		 /* reg points to a read/write buffer */
 +	PTR_TO_MEM_OR_NULL,	 /* reg points to valid memory region or NULL */
 +	PTR_TO_RDONLY_BUF,	 /* reg points to a readonly buffer */
 +	PTR_TO_RDONLY_BUF_OR_NULL, /* reg points to a readonly buffer or NULL */
 +	PTR_TO_RDWR_BUF,	 /* reg points to a read/write buffer */
 +	PTR_TO_RDWR_BUF_OR_NULL, /* reg points to a read/write buffer or NULL */
  	PTR_TO_PERCPU_BTF_ID,	 /* reg points to a percpu kernel variable */
  	PTR_TO_FUNC,		 /* reg points to a bpf program function */
 +	PTR_TO_MAP_KEY,		 /* reg points to a map element key */
  	__BPF_REG_TYPE_MAX,
++<<<<<<< HEAD
++=======
+ 
+ 	/* Extended reg_types. */
+ 	PTR_TO_MAP_VALUE_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_MAP_VALUE,
+ 	PTR_TO_SOCKET_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_SOCKET,
+ 	PTR_TO_SOCK_COMMON_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_SOCK_COMMON,
+ 	PTR_TO_TCP_SOCK_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_TCP_SOCK,
+ 	PTR_TO_BTF_ID_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_BTF_ID,
+ 
+ 	/* This must be the last entry. Its purpose is to ensure the enum is
+ 	 * wide enough to hold the higher bits reserved for bpf_type_flag.
+ 	 */
+ 	__BPF_REG_TYPE_LIMIT	= BPF_TYPE_LIMIT,
++>>>>>>> cf9f2f8d62ec (bpf: Convert PTR_TO_MEM_OR_NULL to composable types.)
  };
 -static_assert(__BPF_REG_TYPE_MAX <= BPF_BASE_TYPE_LIMIT);
  
  /* The information passed from prog-specific *_is_valid_access
   * back to the verifier.
* Unmerged path include/linux/bpf.h
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index 89da4652c9ca..e7fd1ba4626b 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -5665,7 +5665,7 @@ int btf_prepare_func_args(struct bpf_verifier_env *env, int subprog,
 				return -EINVAL;
 			}
 
-			reg->type = PTR_TO_MEM_OR_NULL;
+			reg->type = PTR_TO_MEM | PTR_MAYBE_NULL;
 			reg->id = ++env->id_gen;
 
 			continue;
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 627d7910d79e..bf1612f16d4f 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -12791,7 +12791,7 @@ static int do_check_common(struct bpf_verifier_env *env, int subprog)
 				mark_reg_known_zero(env, regs, i);
 			else if (regs[i].type == SCALAR_VALUE)
 				mark_reg_unknown(env, regs, i);
-			else if (regs[i].type == PTR_TO_MEM_OR_NULL) {
+			else if (base_type(regs[i].type) == PTR_TO_MEM) {
 				const u32 mem_size = regs[i].mem_size;
 
 				mark_reg_known_zero(env, regs, i);
