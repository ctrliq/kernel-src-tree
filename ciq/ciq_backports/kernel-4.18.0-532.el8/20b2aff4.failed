bpf: Introduce MEM_RDONLY flag

jira LE-1907
cve CVE-2022-0500
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Hao Luo <haoluo@google.com>
commit 20b2aff4bc15bda809f994761d5719827d66c0b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/20b2aff4.failed

This patch introduce a flag MEM_RDONLY to tag a reg value
pointing to read-only memory. It makes the following changes:

1. PTR_TO_RDWR_BUF -> PTR_TO_BUF
2. PTR_TO_RDONLY_BUF -> PTR_TO_BUF | MEM_RDONLY

	Signed-off-by: Hao Luo <haoluo@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20211217003152.48334-6-haoluo@google.com
(cherry picked from commit 20b2aff4bc15bda809f994761d5719827d66c0b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/btf.c
#	kernel/bpf/map_iter.c
#	kernel/bpf/verifier.c
#	net/core/bpf_sk_storage.c
#	net/core/sock_map.c
diff --cc include/linux/bpf.h
index 83377e4c1c34,126048110bdb..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -279,6 -297,32 +279,35 @@@ bool bpf_map_meta_equal(const struct bp
  
  extern const struct bpf_map_ops bpf_map_offload_ops;
  
++<<<<<<< HEAD
++=======
+ /* bpf_type_flag contains a set of flags that are applicable to the values of
+  * arg_type, ret_type and reg_type. For example, a pointer value may be null,
+  * or a memory is read-only. We classify types into two categories: base types
+  * and extended types. Extended types are base types combined with a type flag.
+  *
+  * Currently there are no more than 32 base types in arg_type, ret_type and
+  * reg_types.
+  */
+ #define BPF_BASE_TYPE_BITS	8
+ 
+ enum bpf_type_flag {
+ 	/* PTR may be NULL. */
+ 	PTR_MAYBE_NULL		= BIT(0 + BPF_BASE_TYPE_BITS),
+ 
+ 	/* MEM is read-only. */
+ 	MEM_RDONLY		= BIT(1 + BPF_BASE_TYPE_BITS),
+ 
+ 	__BPF_TYPE_LAST_FLAG	= MEM_RDONLY,
+ };
+ 
+ /* Max number of base types. */
+ #define BPF_BASE_TYPE_LIMIT	(1UL << BPF_BASE_TYPE_BITS)
+ 
+ /* Max number of all types. */
+ #define BPF_TYPE_LIMIT		(__BPF_TYPE_LAST_FLAG | (__BPF_TYPE_LAST_FLAG - 1))
+ 
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  /* function argument constraints */
  enum bpf_arg_type {
  	ARG_DONTCARE = 0,	/* unused argument in helper function */
@@@ -431,18 -494,26 +460,22 @@@ enum bpf_reg_type 
  	 * been checked for null. Used primarily to inform the verifier
  	 * an explicit null check is required for this struct.
  	 */
 +	PTR_TO_BTF_ID_OR_NULL,
  	PTR_TO_MEM,		 /* reg points to valid memory region */
++<<<<<<< HEAD
 +	PTR_TO_MEM_OR_NULL,	 /* reg points to valid memory region or NULL */
 +	PTR_TO_RDONLY_BUF,	 /* reg points to a readonly buffer */
 +	PTR_TO_RDONLY_BUF_OR_NULL, /* reg points to a readonly buffer or NULL */
 +	PTR_TO_RDWR_BUF,	 /* reg points to a read/write buffer */
 +	PTR_TO_RDWR_BUF_OR_NULL, /* reg points to a read/write buffer or NULL */
++=======
+ 	PTR_TO_BUF,		 /* reg points to a read/write buffer */
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  	PTR_TO_PERCPU_BTF_ID,	 /* reg points to a percpu kernel variable */
  	PTR_TO_FUNC,		 /* reg points to a bpf program function */
 +	PTR_TO_MAP_KEY,		 /* reg points to a map element key */
  	__BPF_REG_TYPE_MAX,
 -
 -	/* Extended reg_types. */
 -	PTR_TO_MAP_VALUE_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_MAP_VALUE,
 -	PTR_TO_SOCKET_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_SOCKET,
 -	PTR_TO_SOCK_COMMON_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_SOCK_COMMON,
 -	PTR_TO_TCP_SOCK_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_TCP_SOCK,
 -	PTR_TO_BTF_ID_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_BTF_ID,
 -	PTR_TO_MEM_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_MEM,
 -
 -	/* This must be the last entry. Its purpose is to ensure the enum is
 -	 * wide enough to hold the higher bits reserved for bpf_type_flag.
 -	 */
 -	__BPF_REG_TYPE_LIMIT	= BPF_TYPE_LIMIT,
  };
 -static_assert(__BPF_REG_TYPE_MAX <= BPF_BASE_TYPE_LIMIT);
  
  /* The information passed from prog-specific *_is_valid_access
   * back to the verifier.
diff --cc kernel/bpf/btf.c
index 89da4652c9ca,d1447b075c73..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -4753,10 -4940,12 +4753,17 @@@ bool btf_ctx_access(int off, int size, 
  	/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */
  	for (i = 0; i < prog->aux->ctx_arg_info_size; i++) {
  		const struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];
 -		u32 type, flag;
  
++<<<<<<< HEAD
 +		if (ctx_arg_info->offset == off &&
 +		    (ctx_arg_info->reg_type == PTR_TO_RDONLY_BUF_OR_NULL ||
 +		     ctx_arg_info->reg_type == PTR_TO_RDWR_BUF_OR_NULL)) {
++=======
+ 		type = base_type(ctx_arg_info->reg_type);
+ 		flag = type_flag(ctx_arg_info->reg_type);
+ 		if (ctx_arg_info->offset == off && type == PTR_TO_BUF &&
+ 		    (flag & PTR_MAYBE_NULL)) {
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  			info->reg_type = ctx_arg_info->reg_type;
  			return true;
  		}
diff --cc kernel/bpf/map_iter.c
index 6a9542af4212,b0fa190b0979..000000000000
--- a/kernel/bpf/map_iter.c
+++ b/kernel/bpf/map_iter.c
@@@ -174,9 -174,9 +174,15 @@@ static const struct bpf_iter_reg bpf_ma
  	.ctx_arg_info_size	= 2,
  	.ctx_arg_info		= {
  		{ offsetof(struct bpf_iter__bpf_map_elem, key),
++<<<<<<< HEAD
 +		  PTR_TO_RDONLY_BUF_OR_NULL },
 +		{ offsetof(struct bpf_iter__bpf_map_elem, value),
 +		  PTR_TO_RDWR_BUF_OR_NULL },
++=======
+ 		  PTR_TO_BUF | PTR_MAYBE_NULL | MEM_RDONLY },
+ 		{ offsetof(struct bpf_iter__bpf_map_elem, value),
+ 		  PTR_TO_BUF | PTR_MAYBE_NULL },
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  	},
  };
  
diff --cc kernel/bpf/verifier.c
index 627d7910d79e,e0a8a55ea3df..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -466,14 -450,16 +466,19 @@@ static bool reg_may_point_to_spin_lock(
  
  static bool reg_type_may_be_refcounted_or_null(enum bpf_reg_type type)
  {
 -	return base_type(type) == PTR_TO_SOCKET ||
 -		base_type(type) == PTR_TO_TCP_SOCK ||
 -		base_type(type) == PTR_TO_MEM;
 +	return type == PTR_TO_SOCKET ||
 +		type == PTR_TO_SOCKET_OR_NULL ||
 +		type == PTR_TO_TCP_SOCK ||
 +		type == PTR_TO_TCP_SOCK_OR_NULL ||
 +		type == PTR_TO_MEM ||
 +		type == PTR_TO_MEM_OR_NULL;
  }
  
+ static bool type_is_rdonly_mem(u32 type)
+ {
+ 	return type & MEM_RDONLY;
+ }
+ 
  static bool arg_type_may_be_refcounted(enum bpf_arg_type type)
  {
  	return type == ARG_PTR_TO_SOCK_COMMON;
@@@ -546,39 -527,54 +551,90 @@@ static bool is_cmpxchg_insn(const struc
  	       insn->imm == BPF_CMPXCHG;
  }
  
++<<<<<<< HEAD
 +/* string representation of 'enum bpf_reg_type' */
 +static const char * const reg_type_str[] = {
 +	[NOT_INIT]		= "?",
 +	[SCALAR_VALUE]		= "inv",
 +	[PTR_TO_CTX]		= "ctx",
 +	[CONST_PTR_TO_MAP]	= "map_ptr",
 +	[PTR_TO_MAP_VALUE]	= "map_value",
 +	[PTR_TO_MAP_VALUE_OR_NULL] = "map_value_or_null",
 +	[PTR_TO_STACK]		= "fp",
 +	[PTR_TO_PACKET]		= "pkt",
 +	[PTR_TO_PACKET_META]	= "pkt_meta",
 +	[PTR_TO_PACKET_END]	= "pkt_end",
 +	[PTR_TO_FLOW_KEYS]	= "flow_keys",
 +	[PTR_TO_SOCKET]		= "sock",
 +	[PTR_TO_SOCKET_OR_NULL] = "sock_or_null",
 +	[PTR_TO_SOCK_COMMON]	= "sock_common",
 +	[PTR_TO_SOCK_COMMON_OR_NULL] = "sock_common_or_null",
 +	[PTR_TO_TCP_SOCK]	= "tcp_sock",
 +	[PTR_TO_TCP_SOCK_OR_NULL] = "tcp_sock_or_null",
 +	[PTR_TO_TP_BUFFER]	= "tp_buffer",
 +	[PTR_TO_XDP_SOCK]	= "xdp_sock",
 +	[PTR_TO_BTF_ID]		= "ptr_",
 +	[PTR_TO_BTF_ID_OR_NULL]	= "ptr_or_null_",
 +	[PTR_TO_PERCPU_BTF_ID]	= "percpu_ptr_",
 +	[PTR_TO_MEM]		= "mem",
 +	[PTR_TO_MEM_OR_NULL]	= "mem_or_null",
 +	[PTR_TO_RDONLY_BUF]	= "rdonly_buf",
 +	[PTR_TO_RDONLY_BUF_OR_NULL] = "rdonly_buf_or_null",
 +	[PTR_TO_RDWR_BUF]	= "rdwr_buf",
 +	[PTR_TO_RDWR_BUF_OR_NULL] = "rdwr_buf_or_null",
 +	[PTR_TO_FUNC]		= "func",
 +	[PTR_TO_MAP_KEY]	= "map_key",
 +};
++=======
+ /* string representation of 'enum bpf_reg_type'
+  *
+  * Note that reg_type_str() can not appear more than once in a single verbose()
+  * statement.
+  */
+ static const char *reg_type_str(struct bpf_verifier_env *env,
+ 				enum bpf_reg_type type)
+ {
+ 	char postfix[16] = {0}, prefix[16] = {0};
+ 	static const char * const str[] = {
+ 		[NOT_INIT]		= "?",
+ 		[SCALAR_VALUE]		= "inv",
+ 		[PTR_TO_CTX]		= "ctx",
+ 		[CONST_PTR_TO_MAP]	= "map_ptr",
+ 		[PTR_TO_MAP_VALUE]	= "map_value",
+ 		[PTR_TO_STACK]		= "fp",
+ 		[PTR_TO_PACKET]		= "pkt",
+ 		[PTR_TO_PACKET_META]	= "pkt_meta",
+ 		[PTR_TO_PACKET_END]	= "pkt_end",
+ 		[PTR_TO_FLOW_KEYS]	= "flow_keys",
+ 		[PTR_TO_SOCKET]		= "sock",
+ 		[PTR_TO_SOCK_COMMON]	= "sock_common",
+ 		[PTR_TO_TCP_SOCK]	= "tcp_sock",
+ 		[PTR_TO_TP_BUFFER]	= "tp_buffer",
+ 		[PTR_TO_XDP_SOCK]	= "xdp_sock",
+ 		[PTR_TO_BTF_ID]		= "ptr_",
+ 		[PTR_TO_PERCPU_BTF_ID]	= "percpu_ptr_",
+ 		[PTR_TO_MEM]		= "mem",
+ 		[PTR_TO_BUF]		= "buf",
+ 		[PTR_TO_FUNC]		= "func",
+ 		[PTR_TO_MAP_KEY]	= "map_key",
+ 	};
+ 
+ 	if (type & PTR_MAYBE_NULL) {
+ 		if (base_type(type) == PTR_TO_BTF_ID ||
+ 		    base_type(type) == PTR_TO_PERCPU_BTF_ID)
+ 			strncpy(postfix, "or_null_", 16);
+ 		else
+ 			strncpy(postfix, "_or_null", 16);
+ 	}
+ 
+ 	if (type & MEM_RDONLY)
+ 		strncpy(prefix, "rdonly_", 16);
+ 
+ 	snprintf(env->type_str_buf, TYPE_STR_BUF_LEN, "%s%s%s",
+ 		 prefix, str[base_type(type)], postfix);
+ 	return env->type_str_buf;
+ }
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  
  static char slot_type_char[] = {
  	[STACK_INVALID]	= '?',
@@@ -2522,21 -2758,13 +2578,25 @@@ static bool is_spillable_regtype(enum b
  	case PTR_TO_FLOW_KEYS:
  	case CONST_PTR_TO_MAP:
  	case PTR_TO_SOCKET:
 +	case PTR_TO_SOCKET_OR_NULL:
  	case PTR_TO_SOCK_COMMON:
 +	case PTR_TO_SOCK_COMMON_OR_NULL:
  	case PTR_TO_TCP_SOCK:
 +	case PTR_TO_TCP_SOCK_OR_NULL:
  	case PTR_TO_XDP_SOCK:
  	case PTR_TO_BTF_ID:
++<<<<<<< HEAD
 +	case PTR_TO_BTF_ID_OR_NULL:
 +	case PTR_TO_RDONLY_BUF:
 +	case PTR_TO_RDONLY_BUF_OR_NULL:
 +	case PTR_TO_RDWR_BUF:
 +	case PTR_TO_RDWR_BUF_OR_NULL:
++=======
+ 	case PTR_TO_BUF:
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  	case PTR_TO_PERCPU_BTF_ID:
  	case PTR_TO_MEM:
 +	case PTR_TO_MEM_OR_NULL:
  	case PTR_TO_FUNC:
  	case PTR_TO_MAP_KEY:
  		return true;
@@@ -4228,22 -4514,28 +4288,36 @@@ static int check_mem_access(struct bpf_
  	} else if (reg->type == CONST_PTR_TO_MAP) {
  		err = check_ptr_to_map_access(env, regs, regno, off, size, t,
  					      value_regno);
++<<<<<<< HEAD
 +	} else if (reg->type == PTR_TO_RDONLY_BUF) {
 +		if (t == BPF_WRITE) {
 +			verbose(env, "R%d cannot write into %s\n",
 +				regno, reg_type_str[reg->type]);
 +			return -EACCES;
++=======
+ 	} else if (base_type(reg->type) == PTR_TO_BUF) {
+ 		bool rdonly_mem = type_is_rdonly_mem(reg->type);
+ 		const char *buf_info;
+ 		u32 *max_access;
+ 
+ 		if (rdonly_mem) {
+ 			if (t == BPF_WRITE) {
+ 				verbose(env, "R%d cannot write into %s\n",
+ 					regno, reg_type_str(env, reg->type));
+ 				return -EACCES;
+ 			}
+ 			buf_info = "rdonly";
+ 			max_access = &env->prog->aux->max_rdonly_access;
+ 		} else {
+ 			buf_info = "rdwr";
+ 			max_access = &env->prog->aux->max_rdwr_access;
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  		}
+ 
  		err = check_buffer_access(env, reg, regno, off, size, false,
- 					  "rdonly",
- 					  &env->prog->aux->max_rdonly_access);
- 		if (!err && value_regno >= 0)
- 			mark_reg_unknown(env, regs, value_regno);
- 	} else if (reg->type == PTR_TO_RDWR_BUF) {
- 		err = check_buffer_access(env, reg, regno, off, size, false,
- 					  "rdwr",
- 					  &env->prog->aux->max_rdwr_access);
- 		if (!err && t == BPF_READ && value_regno >= 0)
+ 					  buf_info, max_access);
+ 
+ 		if (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))
  			mark_reg_unknown(env, regs, value_regno);
  	} else {
  		verbose(env, "R%d invalid mem access '%s'\n", regno,
diff --cc net/core/bpf_sk_storage.c
index 903bd4b8d209,ea61dfe19c86..000000000000
--- a/net/core/bpf_sk_storage.c
+++ b/net/core/bpf_sk_storage.c
@@@ -929,7 -929,7 +929,11 @@@ static struct bpf_iter_reg bpf_sk_stora
  		{ offsetof(struct bpf_iter__bpf_sk_storage_map, sk),
  		  PTR_TO_BTF_ID_OR_NULL },
  		{ offsetof(struct bpf_iter__bpf_sk_storage_map, value),
++<<<<<<< HEAD
 +		  PTR_TO_RDWR_BUF_OR_NULL },
++=======
+ 		  PTR_TO_BUF | PTR_MAYBE_NULL },
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  	},
  	.seq_info		= &iter_seq_info,
  };
diff --cc net/core/sock_map.c
index a12337bdfb02,9618ab6d7cc9..000000000000
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
@@@ -1587,7 -1564,7 +1587,11 @@@ static struct bpf_iter_reg sock_map_ite
  	.ctx_arg_info_size	= 2,
  	.ctx_arg_info		= {
  		{ offsetof(struct bpf_iter__sockmap, key),
++<<<<<<< HEAD
 +		  PTR_TO_RDONLY_BUF_OR_NULL },
++=======
+ 		  PTR_TO_BUF | PTR_MAYBE_NULL | MEM_RDONLY },
++>>>>>>> 20b2aff4bc15 (bpf: Introduce MEM_RDONLY flag)
  		{ offsetof(struct bpf_iter__sockmap, sk),
  		  PTR_TO_BTF_ID_OR_NULL },
  	},
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/btf.c
* Unmerged path kernel/bpf/map_iter.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path net/core/bpf_sk_storage.c
* Unmerged path net/core/sock_map.c
