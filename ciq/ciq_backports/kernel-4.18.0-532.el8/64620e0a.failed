bpf: Fix out of bounds access for ringbuf helpers

jira LE-1907
cve CVE-2021-4204
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 64620e0a1e712a778095bd35cbb277dc2259281f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/64620e0a.failed

Both bpf_ringbuf_submit() and bpf_ringbuf_discard() have ARG_PTR_TO_ALLOC_MEM
in their bpf_func_proto definition as their first argument. They both expect
the result from a prior bpf_ringbuf_reserve() call which has a return type of
RET_PTR_TO_ALLOC_MEM_OR_NULL.

Meaning, after a NULL check in the code, the verifier will promote the register
type in the non-NULL branch to a PTR_TO_MEM and in the NULL branch to a known
zero scalar. Generally, pointer arithmetic on PTR_TO_MEM is allowed, so the
latter could have an offset.

The ARG_PTR_TO_ALLOC_MEM expects a PTR_TO_MEM register type. However, the non-
zero result from bpf_ringbuf_reserve() must be fed into either bpf_ringbuf_submit()
or bpf_ringbuf_discard() but with the original offset given it will then read
out the struct bpf_ringbuf_hdr mapping.

The verifier missed to enforce a zero offset, so that out of bounds access
can be triggered which could be used to escalate privileges if unprivileged
BPF was enabled (disabled by default in kernel).

Fixes: 457f44363a88 ("bpf: Implement BPF ring buffer and verifier support for it")
	Reported-by: <tr3e.wang@gmail.com> (SecCoder Security Lab)
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 64620e0a1e712a778095bd35cbb277dc2259281f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 627d7910d79e,c72c57a6684f..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -4918,10 -5306,32 +4918,36 @@@ static int check_func_arg(struct bpf_ve
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	if (type == PTR_TO_CTX) {
 +		err = check_ctx_reg(env, reg, regno);
++=======
+ 	switch ((u32)type) {
+ 	case SCALAR_VALUE:
+ 	/* Pointer types where reg offset is explicitly allowed: */
+ 	case PTR_TO_PACKET:
+ 	case PTR_TO_PACKET_META:
+ 	case PTR_TO_MAP_KEY:
+ 	case PTR_TO_MAP_VALUE:
+ 	case PTR_TO_MEM:
+ 	case PTR_TO_MEM | MEM_RDONLY:
+ 	case PTR_TO_BUF:
+ 	case PTR_TO_BUF | MEM_RDONLY:
+ 	case PTR_TO_STACK:
+ 		/* Some of the argument types nevertheless require a
+ 		 * zero register offset.
+ 		 */
+ 		if (arg_type == ARG_PTR_TO_ALLOC_MEM)
+ 			goto force_off_check;
+ 		break;
+ 	/* All the rest must be rejected: */
+ 	default:
+ force_off_check:
+ 		err = __check_ptr_off_reg(env, reg, regno,
+ 					  type == PTR_TO_BTF_ID);
++>>>>>>> 64620e0a1e71 (bpf: Fix out of bounds access for ringbuf helpers)
  		if (err < 0)
  			return err;
 -		break;
  	}
  
  skip_type_check:
* Unmerged path kernel/bpf/verifier.c
