bpf: Check PTR_TO_MEM | MEM_RDONLY in check_helper_mem_access

jira LE-1907
cve CVE-2022-0500
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Kumar Kartikeya Dwivedi <memxor@gmail.com>
commit 97e6d7dab1ca4648821c790a2b7913d6d5d549db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/97e6d7da.failed

The commit being fixed was aiming to disallow users from incorrectly
obtaining writable pointer to memory that is only meant to be read. This
is enforced now using a MEM_RDONLY flag.

For instance, in case of global percpu variables, when the BTF type is
not struct (e.g. bpf_prog_active), the verifier marks register type as
PTR_TO_MEM | MEM_RDONLY from bpf_this_cpu_ptr or bpf_per_cpu_ptr
helpers. However, when passing such pointer to kfunc, global funcs, or
BPF helpers, in check_helper_mem_access, there is no expectation
MEM_RDONLY flag will be set, hence it is checked as pointer to writable
memory. Later, verifier sets up argument type of global func as
PTR_TO_MEM | PTR_MAYBE_NULL, so user can use a global func to get around
the limitations imposed by this flag.

This check will also cover global non-percpu variables that may be
introduced in kernel BTF in future.

Also, we update the log message for PTR_TO_BUF case to be similar to
PTR_TO_MEM case, so that the reason for error is clear to user.

Fixes: 34d3a78c681e ("bpf: Make per_cpu_ptr return rdonly PTR_TO_MEM.")
	Reviewed-by: Hao Luo <haoluo@google.com>
	Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: https://lore.kernel.org/r/20220319080827.73251-3-memxor@gmail.com
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 97e6d7dab1ca4648821c790a2b7913d6d5d549db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 627d7910d79e,d953e62b5268..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -4511,18 -4881,21 +4518,33 @@@ static int check_helper_mem_access(stru
  		return check_mem_region_access(env, regno, reg->off,
  					       access_size, reg->mem_size,
  					       zero_size_allowed);
++<<<<<<< HEAD
 +	case PTR_TO_RDONLY_BUF:
 +		if (meta && meta->raw_mode)
 +			return -EACCES;
++=======
+ 	case PTR_TO_BUF:
+ 		if (type_is_rdonly_mem(reg->type)) {
+ 			if (meta && meta->raw_mode) {
+ 				verbose(env, "R%d cannot write into %s\n", regno,
+ 					reg_type_str(env, reg->type));
+ 				return -EACCES;
+ 			}
+ 
+ 			max_access = &env->prog->aux->max_rdonly_access;
+ 		} else {
+ 			max_access = &env->prog->aux->max_rdwr_access;
+ 		}
++>>>>>>> 97e6d7dab1ca (bpf: Check PTR_TO_MEM | MEM_RDONLY in check_helper_mem_access)
 +		return check_buffer_access(env, reg, regno, reg->off,
 +					   access_size, zero_size_allowed,
 +					   "rdonly",
 +					   &env->prog->aux->max_rdonly_access);
 +	case PTR_TO_RDWR_BUF:
  		return check_buffer_access(env, reg, regno, reg->off,
  					   access_size, zero_size_allowed,
 -					   max_access);
 +					   "rdwr",
 +					   &env->prog->aux->max_rdwr_access);
  	case PTR_TO_STACK:
  		return check_stack_range_initialized(
  				env,
* Unmerged path kernel/bpf/verifier.c
