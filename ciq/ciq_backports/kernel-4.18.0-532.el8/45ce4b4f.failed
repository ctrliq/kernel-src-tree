bpf: Fix crash due to out of bounds access into reg2btf_ids.

jira LE-1907
cve CVE-2022-0500
Rebuild_History Non-Buildable kernel-4.18.0-532.el8
commit-author Kumar Kartikeya Dwivedi <memxor@gmail.com>
commit 45ce4b4f9009102cd9f581196d480a59208690c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-532.el8/45ce4b4f.failed

When commit e6ac2450d6de ("bpf: Support bpf program calling kernel function") added
kfunc support, it defined reg2btf_ids as a cheap way to translate the verifier
reg type to the appropriate btf_vmlinux BTF ID, however
commit c25b2ae13603 ("bpf: Replace PTR_TO_XXX_OR_NULL with PTR_TO_XXX | PTR_MAYBE_NULL")
moved the __BPF_REG_TYPE_MAX from the last member of bpf_reg_type enum to after
the base register types, and defined other variants using type flag
composition. However, now, the direct usage of reg->type to index into
reg2btf_ids may no longer fall into __BPF_REG_TYPE_MAX range, and hence lead to
out of bounds access and kernel crash on dereference of bad pointer.

Fixes: c25b2ae13603 ("bpf: Replace PTR_TO_XXX_OR_NULL with PTR_TO_XXX | PTR_MAYBE_NULL")
	Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20220216201943.624869-1-memxor@gmail.com
(cherry picked from commit 45ce4b4f9009102cd9f581196d480a59208690c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/btf.c
diff --cc kernel/bpf/btf.c
index 89da4652c9ca,3e23b3fa79ff..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -5440,7 -5675,21 +5440,25 @@@ static int btf_check_func_arg_match(str
  
  		ref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);
  		ref_tname = btf_name_by_offset(btf, ref_t->name_off);
++<<<<<<< HEAD
 +		if (btf_is_kernel(btf)) {
++=======
+ 		if (btf_get_prog_ctx_type(log, btf, t,
+ 					  env->prog->type, i)) {
+ 			/* If function expects ctx type in BTF check that caller
+ 			 * is passing PTR_TO_CTX.
+ 			 */
+ 			if (reg->type != PTR_TO_CTX) {
+ 				bpf_log(log,
+ 					"arg#%d expected pointer to ctx, but got %s\n",
+ 					i, btf_type_str(t));
+ 				return -EINVAL;
+ 			}
+ 			if (check_ptr_off_reg(env, reg, regno))
+ 				return -EINVAL;
+ 		} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID ||
+ 			   (reg2btf_ids[base_type(reg->type)] && !type_flag(reg->type)))) {
++>>>>>>> 45ce4b4f9009 (bpf: Fix crash due to out of bounds access into reg2btf_ids.)
  			const struct btf_type *reg_ref_t;
  			const struct btf *reg_btf;
  			const char *reg_ref_tname;
@@@ -5456,14 -5705,9 +5474,18 @@@
  			if (reg->type == PTR_TO_BTF_ID) {
  				reg_btf = reg->btf;
  				reg_ref_id = reg->btf_id;
 -			} else {
 +			} else if (reg2btf_ids[reg->type]) {
  				reg_btf = btf_vmlinux;
++<<<<<<< HEAD
 +				reg_ref_id = *reg2btf_ids[reg->type];
 +			} else {
 +				bpf_log(log, "kernel function %s args#%d expected pointer to %s %s but R%d is not a pointer to btf_id\n",
 +					func_name, i,
 +					btf_type_str(ref_t), ref_tname, regno);
 +				return -EINVAL;
++=======
+ 				reg_ref_id = *reg2btf_ids[base_type(reg->type)];
++>>>>>>> 45ce4b4f9009 (bpf: Fix crash due to out of bounds access into reg2btf_ids.)
  			}
  
  			reg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,
* Unmerged path kernel/bpf/btf.c
