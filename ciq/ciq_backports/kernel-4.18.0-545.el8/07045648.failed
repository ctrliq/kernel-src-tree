ceph: always check dir caps asynchronously

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-545.el8
commit-author Xiubo Li <xiubli@redhat.com>
commit 07045648c07c5632e0dfd5ce084d3cd0cec0258a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-545.el8/07045648.failed

The MDS will issue the 'Fr' caps for async dirop, while there is
buggy in kclient and it could miss releasing the async dirop caps,
which is 'Fsxr'. And then the MDS will complain with:

"[WRN] client.xxx isn't responding to mclientcaps(revoke) ..."

So when releasing the dirop async requests or when they fail we
should always make sure that being revoked caps could be released.

Link: https://tracker.ceph.com/issues/50223
	Signed-off-by: Xiubo Li <xiubli@redhat.com>
	Reviewed-by: Milind Changire <mchangir@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 07045648c07c5632e0dfd5ce084d3cd0cec0258a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/mds_client.c
diff --cc fs/ceph/mds_client.c
index 99b68cd627d3,f71bb9c9569f..000000000000
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@@ -3704,15 -4261,15 +3704,20 @@@ void ceph_mdsc_release_dir_caps(struct 
  	}
  }
  
- void ceph_mdsc_release_dir_caps_no_check(struct ceph_mds_request *req)
+ void ceph_mdsc_release_dir_caps_async(struct ceph_mds_request *req)
  {
 -	struct ceph_client *cl = req->r_mdsc->fsc->client;
  	int dcaps;
  
  	dcaps = xchg(&req->r_dir_caps, 0);
  	if (dcaps) {
++<<<<<<< HEAD
 +		dout("releasing r_dir_caps=%s\n", ceph_cap_string(dcaps));
 +		ceph_put_cap_refs_no_check_caps(ceph_inode(req->r_parent),
 +						dcaps);
++=======
+ 		doutc(cl, "releasing r_dir_caps=%s\n", ceph_cap_string(dcaps));
+ 		ceph_put_cap_refs_async(ceph_inode(req->r_parent), dcaps);
++>>>>>>> 07045648c07c (ceph: always check dir caps asynchronously)
  	}
  }
  
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index b45313271f21..bf12f6e55ec9 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -3052,7 +3052,6 @@ static int ceph_try_drop_cap_snap(struct ceph_inode_info *ci,
 
 enum put_cap_refs_mode {
 	PUT_CAP_REFS_SYNC = 0,
-	PUT_CAP_REFS_NO_CHECK,
 	PUT_CAP_REFS_ASYNC,
 };
 
@@ -3167,11 +3166,6 @@ void ceph_put_cap_refs_async(struct ceph_inode_info *ci, int had)
 	__ceph_put_cap_refs(ci, had, PUT_CAP_REFS_ASYNC);
 }
 
-void ceph_put_cap_refs_no_check_caps(struct ceph_inode_info *ci, int had)
-{
-	__ceph_put_cap_refs(ci, had, PUT_CAP_REFS_NO_CHECK);
-}
-
 /*
  * Release @nr WRBUFFER refs on dirty pages for the given @snapc snap
  * context.  Adjust per-snap dirty page accounting as appropriate.
* Unmerged path fs/ceph/mds_client.c
diff --git a/fs/ceph/mds_client.h b/fs/ceph/mds_client.h
index e4ae1dd12a63..f825d66f5507 100644
--- a/fs/ceph/mds_client.h
+++ b/fs/ceph/mds_client.h
@@ -508,7 +508,7 @@ extern int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,
 				struct inode *dir,
 				struct ceph_mds_request *req);
 extern void ceph_mdsc_release_dir_caps(struct ceph_mds_request *req);
-extern void ceph_mdsc_release_dir_caps_no_check(struct ceph_mds_request *req);
+extern void ceph_mdsc_release_dir_caps_async(struct ceph_mds_request *req);
 static inline void ceph_mdsc_get_request(struct ceph_mds_request *req)
 {
 	kref_get(&req->r_kref);
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index 25bb105aa45f..235560e82431 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -1199,8 +1199,6 @@ extern void ceph_take_cap_refs(struct ceph_inode_info *ci, int caps,
 extern void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps);
 extern void ceph_put_cap_refs(struct ceph_inode_info *ci, int had);
 extern void ceph_put_cap_refs_async(struct ceph_inode_info *ci, int had);
-extern void ceph_put_cap_refs_no_check_caps(struct ceph_inode_info *ci,
-					    int had);
 extern void ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,
 				       struct ceph_snap_context *snapc);
 extern void __ceph_remove_capsnap(struct inode *inode,
