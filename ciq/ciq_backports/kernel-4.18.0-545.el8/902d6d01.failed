ceph: always queue a writeback when revoking the Fb caps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-545.el8
commit-author Xiubo Li <xiubli@redhat.com>
commit 902d6d013f75b68f31d208c6f3ff9cdca82648a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-545.el8/902d6d01.failed

In case there is 'Fw' dirty caps and 'CHECK_CAPS_FLUSH' is set we
will always ignore queue a writeback. Queue a writeback is very
important because it will block kclient flushing the snapcaps to
MDS and which will block MDS waiting for revoking the 'Fb' caps.

Link: https://tracker.ceph.com/issues/50223
	Signed-off-by: Xiubo Li <xiubli@redhat.com>
	Reviewed-by: Milind Changire <mchangir@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 902d6d013f75b68f31d208c6f3ff9cdca82648a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index b45313271f21,bce3a840f15c..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -2027,12 -2150,36 +2027,36 @@@ retry
  			cap_used &= ~ci->i_auth_cap->issued;
  
  		revoking = cap->implemented & ~cap->issued;
 -		doutc(cl, " mds%d cap %p used %s issued %s implemented %s revoking %s\n",
 -		      cap->mds, cap, ceph_cap_string(cap_used),
 -		      ceph_cap_string(cap->issued),
 -		      ceph_cap_string(cap->implemented),
 -		      ceph_cap_string(revoking));
 +		dout(" mds%d cap %p used %s issued %s implemented %s revoking %s\n",
 +		     cap->mds, cap, ceph_cap_string(cap_used),
 +		     ceph_cap_string(cap->issued),
 +		     ceph_cap_string(cap->implemented),
 +		     ceph_cap_string(revoking));
  
+ 		/* completed revocation? going down and there are no caps? */
+ 		if (revoking) {
+ 			if ((revoking & cap_used) == 0) {
+ 				doutc(cl, "completed revocation of %s\n",
+ 				      ceph_cap_string(cap->implemented & ~cap->issued));
+ 				goto ack;
+ 			}
+ 
+ 			/*
+ 			 * If the "i_wrbuffer_ref" was increased by mmap or generic
+ 			 * cache write just before the ceph_check_caps() is called,
+ 			 * the Fb capability revoking will fail this time. Then we
+ 			 * must wait for the BDI's delayed work to flush the dirty
+ 			 * pages and to release the "i_wrbuffer_ref", which will cost
+ 			 * at most 5 seconds. That means the MDS needs to wait at
+ 			 * most 5 seconds to finished the Fb capability's revocation.
+ 			 *
+ 			 * Let's queue a writeback for it.
+ 			 */
+ 			if (S_ISREG(inode->i_mode) && ci->i_wrbuffer_ref &&
+ 			    (revoking & CEPH_CAP_FILE_BUFFER))
+ 				queue_writeback = true;
+ 		}
+ 
  		if (cap == ci->i_auth_cap &&
  		    (cap->issued & CEPH_CAP_FILE_WR)) {
  			/* request larger max_size from MDS? */
@@@ -2060,30 -2207,6 +2084,33 @@@
  			}
  		}
  
++<<<<<<< HEAD
 +		/* completed revocation? going down and there are no caps? */
 +		if (revoking) {
 +			if ((revoking & cap_used) == 0) {
 +				dout("completed revocation of %s\n",
 +				      ceph_cap_string(cap->implemented & ~cap->issued));
 +				goto ack;
 +			}
 +
 +			/*
 +			 * If the "i_wrbuffer_ref" was increased by mmap or generic
 +			 * cache write just before the ceph_check_caps() is called,
 +			 * the Fb capability revoking will fail this time. Then we
 +			 * must wait for the BDI's delayed work to flush the dirty
 +			 * pages and to release the "i_wrbuffer_ref", which will cost
 +			 * at most 5 seconds. That means the MDS needs to wait at
 +			 * most 5 seconds to finished the Fb capability's revocation.
 +			 *
 +			 * Let's queue a writeback for it.
 +			 */
 +			if (S_ISREG(inode->i_mode) && ci->i_wrbuffer_ref &&
 +			    (revoking & CEPH_CAP_FILE_BUFFER))
 +				queue_writeback = true;
 +		}
 +
++=======
++>>>>>>> 902d6d013f75 (ceph: always queue a writeback when revoking the Fb caps)
  		/* want more caps from mds? */
  		if (want & ~cap->mds_wanted) {
  			if (want & ~(cap->mds_wanted | cap->issued))
* Unmerged path fs/ceph/caps.c
