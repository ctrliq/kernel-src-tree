RDMA/uverbs: Use uverbs_request() for request copying

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 3c2c20947ddbb897a1459f149509ac03e35043e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3c2c2094.failed

This function properly zero-extends, and zero-checks if the user
buffer is not the same size as the kernel command struct.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 3c2c20947ddbb897a1459f149509ac03e35043e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,173b8e83782e..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -47,12 -47,64 +47,68 @@@
  #include "uverbs.h"
  #include "core_priv.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * Copy a response to userspace. If the provided 'resp' is larger than the
+  * user buffer it is silently truncated. If the user provided a larger buffer
+  * then the trailing portion is zero filled.
+  *
+  * These semantics are intended to support future extension of the output
+  * structures.
+  */
+ static int uverbs_response(struct uverbs_attr_bundle *attrs, const void *resp,
+ 			   size_t resp_len)
+ {
+ 	u8 __user *cur = attrs->ucore.outbuf + resp_len;
+ 	u8 __user *end = attrs->ucore.outbuf + attrs->ucore.outlen;
+ 	int ret;
+ 
+ 	if (copy_to_user(attrs->ucore.outbuf, resp,
+ 			 min(attrs->ucore.outlen, resp_len)))
+ 		return -EFAULT;
+ 
+ 	/* Zero fill any extra memory that user space might have provided */
+ 	for (; cur < end; cur++) {
+ 		ret = put_user(0, cur);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy a request from userspace. If the provided 'req' is larger than the
+  * user buffer then the user buffer is zero extended into the 'req'. If 'req'
+  * is smaller than the user buffer then the uncopied bytes in the user buffer
+  * must be zero.
+  */
+ static int uverbs_request(struct uverbs_attr_bundle *attrs, void *req,
+ 			  size_t req_len)
+ {
+ 	if (copy_from_user(req, attrs->ucore.inbuf,
+ 			   min(attrs->ucore.inlen, req_len)))
+ 		return -EFAULT;
+ 
+ 	if (attrs->ucore.inlen < req_len) {
+ 		memset(req + attrs->ucore.inlen, 0,
+ 		       req_len - attrs->ucore.inlen);
+ 	} else if (attrs->ucore.inlen > req_len) {
+ 		if (!ib_is_buffer_cleared(attrs->ucore.inbuf + req_len,
+ 					  attrs->ucore.inlen - req_len))
+ 			return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  static struct ib_uverbs_completion_event_file *
 -_ib_uverbs_lookup_comp_file(s32 fd, const struct uverbs_attr_bundle *attrs)
 +ib_uverbs_lookup_comp_file(int fd, struct ib_ucontext *context)
  {
 -	struct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 -					       fd, attrs);
 +	struct ib_uobject *uobj = uobj_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 +						fd, context);
 +	struct ib_uobject_file *uobj_file;
  
  	if (IS_ERR(uobj))
  		return (void *)uobj;
@@@ -76,15 -128,20 +132,21 @@@ ssize_t ib_uverbs_get_context(struct ib
  	struct ib_ucontext		 *ucontext;
  	struct file			 *filp;
  	struct ib_rdmacg_object		 cg_obj;
 -	struct ib_device *ib_dev;
  	int ret;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
 -	mutex_lock(&file->ucontext_lock);
 -	ib_dev = srcu_dereference(file->device->ib_dev,
 -				  &file->device->disassociate_srcu);
 -	if (!ib_dev) {
 -		ret = -EIO;
 -		goto err;
 -	}
 +	mutex_lock(&file->mutex);
  
  	if (file->ucontext) {
  		ret = -EINVAL;
@@@ -227,20 -275,21 +289,26 @@@ ssize_t ib_uverbs_query_device(struct i
  {
  	struct ib_uverbs_query_device      cmd;
  	struct ib_uverbs_query_device_resp resp;
++<<<<<<< HEAD
++=======
+ 	struct ib_ucontext *ucontext;
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
 -	ucontext = ib_uverbs_get_ucontext(attrs);
 -	if (IS_ERR(ucontext))
 -		return PTR_ERR(ucontext);
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	memset(&resp, 0, sizeof resp);
 -	copy_query_dev_fields(ucontext, &resp, &ucontext->device->attrs);
 +	copy_query_dev_fields(file, ib_dev, &resp, &ib_dev->attrs);
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
  }
  
  /*
@@@ -273,12 -320,17 +341,13 @@@ ssize_t ib_uverbs_query_port(struct ib_
  	struct ib_uverbs_query_port_resp resp;
  	struct ib_port_attr              attr;
  	int                              ret;
 -	struct ib_ucontext *ucontext;
 -	struct ib_device *ib_dev;
  
 -	ucontext = ib_uverbs_get_ucontext(attrs);
 -	if (IS_ERR(ucontext))
 -		return PTR_ERR(ucontext);
 -	ib_dev = ucontext->device;
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	ret = ib_query_port(ib_dev, cmd.port_num, &attr);
  	if (ret)
@@@ -334,19 -380,13 +403,20 @@@ ssize_t ib_uverbs_alloc_pd(struct ib_uv
  	struct ib_uobject             *uobj;
  	struct ib_pd                  *pd;
  	int                            ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_PD, attrs, &ib_dev);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
 +	uobj  = uobj_alloc(UVERBS_OBJECT_PD, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -384,18 -421,17 +454,20 @@@ err
  	return ret;
  }
  
 -static int ib_uverbs_dealloc_pd(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_dealloc_pd(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf,
 +			     int in_len, int out_len)
  {
  	struct ib_uverbs_dealloc_pd cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, file,
 +				    in_len);
  }
  
  struct xrcd_table_entry {
@@@ -497,19 -531,13 +569,20 @@@ ssize_t ib_uverbs_open_xrcd(struct ib_u
  	struct inode                   *inode = NULL;
  	int				ret = 0;
  	int				new_xrcd = 0;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	mutex_lock(&ibudev->xrcd_tree_mutex);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
 +	mutex_lock(&file->device->xrcd_tree_mutex);
  
  	if (cmd.fd != -1) {
  		/* search for file descriptor */
@@@ -606,21 -632,20 +679,23 @@@ err_tree_mutex_unlock
  	return ret;
  }
  
 -static int ib_uverbs_close_xrcd(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_close_xrcd(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_close_xrcd cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, file,
 +				    in_len);
  }
  
 -int ib_uverbs_dealloc_xrcd(struct ib_uobject *uobject,
 +int ib_uverbs_dealloc_xrcd(struct ib_uverbs_device *dev,
  			   struct ib_xrcd *xrcd,
  			   enum rdma_remove_reason why)
  {
@@@ -653,18 -679,12 +728,19 @@@ ssize_t ib_uverbs_reg_mr(struct ib_uver
  	struct ib_pd                *pd;
  	struct ib_mr                *mr;
  	int                          ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
  	if ((cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))
  		return -EINVAL;
  
@@@ -749,16 -763,9 +825,22 @@@ ssize_t ib_uverbs_rereg_mr(struct ib_uv
  	int                          ret;
  	struct ib_uobject	    *uobj;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof(cmd)))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
 +
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
  
  	if (cmd.flags & ~IB_MR_REREG_SUPPORTED || !cmd.flags)
  		return -EINVAL;
@@@ -827,40 -831,35 +909,43 @@@ put_uobjs
  	return ret;
  }
  
 -static int ib_uverbs_dereg_mr(struct uverbs_attr_bundle *attrs,
 -			      const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_dereg_mr(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
  {
  	struct ib_uverbs_dereg_mr cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, file,
 +				    in_len);
  }
  
 -static int ib_uverbs_alloc_mw(struct uverbs_attr_bundle *attrs,
 -			      const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_alloc_mw(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
  {
  	struct ib_uverbs_alloc_mw      cmd;
  	struct ib_uverbs_alloc_mw_resp resp;
  	struct ib_uobject             *uobj;
  	struct ib_pd                  *pd;
  	struct ib_mw                  *mw;
 +	struct ib_udata		       udata;
  	int                            ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof(cmd)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_MW, attrs, &ib_dev);
 +	uobj  = uobj_alloc(UVERBS_OBJECT_MW, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -911,37 -902,35 +996,40 @@@ err_free
  	return ret;
  }
  
 -static int ib_uverbs_dealloc_mw(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_dealloc_mw(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_dealloc_mw cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof(cmd)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, file,
 +				    in_len);
  }
  
 -static int ib_uverbs_create_comp_channel(struct uverbs_attr_bundle *attrs,
 -					 const char __user *buf, int in_len,
 -					 int out_len)
 +ssize_t ib_uverbs_create_comp_channel(struct ib_uverbs_file *file,
 +				      struct ib_device *ib_dev,
 +				      const char __user *buf, int in_len,
 +				      int out_len)
  {
  	struct ib_uverbs_create_comp_channel	   cmd;
  	struct ib_uverbs_create_comp_channel_resp  resp;
  	struct ib_uobject			  *uobj;
  	struct ib_uverbs_completion_event_file	  *ev_file;
 -	struct ib_device *ib_dev;
 -	int ret;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, attrs, &ib_dev);
 +	uobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -1074,24 -1039,12 +1162,31 @@@ ssize_t ib_uverbs_create_cq(struct ib_u
  {
  	struct ib_uverbs_create_cq      cmd;
  	struct ib_uverbs_ex_create_cq	cmd_ex;
 +	struct ib_uverbs_create_cq_resp resp;
 +	struct ib_udata                 ucore;
 +	struct ib_udata                 uhw;
  	struct ib_ucq_object           *obj;
+ 	int ret;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof(cmd)))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
 +
 +	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
 +			     sizeof(cmd), sizeof(resp));
 +
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
  
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
@@@ -1166,15 -1095,11 +1261,16 @@@ ssize_t ib_uverbs_resize_cq(struct ib_u
  	struct ib_cq			*cq;
  	int				ret = -EINVAL;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
  	if (!cq)
  		return -EINVAL;
  
@@@ -1236,10 -1157,11 +1332,11 @@@ ssize_t ib_uverbs_poll_cq(struct ib_uve
  	struct ib_wc                   wc;
  	int                            ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
  	if (!cq)
  		return -EINVAL;
  
@@@ -1282,11 -1203,13 +1379,13 @@@ ssize_t ib_uverbs_req_notify_cq(struct 
  {
  	struct ib_uverbs_req_notify_cq cmd;
  	struct ib_cq                  *cq;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
  	if (!cq)
  		return -EINVAL;
  
@@@ -1306,15 -1227,14 +1405,20 @@@ ssize_t ib_uverbs_destroy_cq(struct ib_
  	struct ib_uverbs_destroy_cq      cmd;
  	struct ib_uverbs_destroy_cq_resp resp;
  	struct ib_uobject		*uobj;
 +	struct ib_cq               	*cq;
  	struct ib_ucq_object        	*obj;
++<<<<<<< HEAD
 +	int                        	 ret = -EINVAL;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_get_destroy(UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	uobj  = uobj_get_write(UVERBS_OBJECT_CQ, cmd.cq_handle,
 +			       file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -1636,24 -1520,12 +1740,29 @@@ ssize_t ib_uverbs_create_qp(struct ib_u
  {
  	struct ib_uverbs_create_qp      cmd;
  	struct ib_uverbs_ex_create_qp	cmd_ex;
++<<<<<<< HEAD
 +	struct ib_udata			ucore;
 +	struct ib_udata			uhw;
 +	ssize_t resp_size = sizeof(struct ib_uverbs_create_qp_resp);
 +	int				err;
 +
 +	if (out_len < resp_size)
 +		return -ENOSPC;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof(cmd)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 +	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
 +		   sizeof(cmd), resp_size);
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + resp_size,
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - resp_size);
 +
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
  	cmd_ex.pd_handle = cmd.pd_handle;
@@@ -1740,20 -1584,14 +1849,21 @@@ ssize_t ib_uverbs_open_qp(struct ib_uve
  	struct ib_qp                   *qp;
  	struct ib_qp_open_attr          attr;
  	int ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	obj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, attrs,
 -						 &ib_dev);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	obj  = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP,
 +						  file->ucontext);
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  
@@@ -2112,17 -1944,15 +2223,21 @@@ out
  	return ret;
  }
  
 -static int ib_uverbs_modify_qp(struct uverbs_attr_bundle *attrs,
 -			       const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
  {
  	struct ib_uverbs_ex_modify_qp cmd = {};
++<<<<<<< HEAD
 +	struct ib_udata udata;
++=======
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  	int ret;
  
- 	if (copy_from_user(&cmd.base, buf, sizeof(cmd.base)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd.base, sizeof(cmd.base));
+ 	if (ret)
+ 		return ret;
  
  	if (cmd.base.attr_mask &
  	    ~((IB_USER_LEGACY_LAST_QP_ATTR_MASK << 1) - 1))
@@@ -2184,15 -2002,13 +2299,20 @@@ ssize_t ib_uverbs_destroy_qp(struct ib_
  	struct ib_uverbs_destroy_qp_resp resp;
  	struct ib_uobject		*uobj;
  	struct ib_uqp_object        	*obj;
++<<<<<<< HEAD
 +	int                        	 ret = -EINVAL;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_get_destroy(UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
 +	memset(&resp, 0, sizeof resp);
 +
 +	uobj  = uobj_get_write(UVERBS_OBJECT_QP, cmd.qp_handle,
 +			       file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -2619,23 -2423,13 +2739,24 @@@ ssize_t ib_uverbs_create_ah(struct ib_u
  	struct ib_ah			*ah;
  	struct rdma_ah_attr		attr = {};
  	int ret;
 -	struct ib_device *ib_dev;
 +	struct ib_udata                   udata;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_AH, attrs, &ib_dev);
 +	if (!rdma_is_port_valid(ib_dev, cmd.attr.port_num))
 +		return -EINVAL;
 +
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	uobj  = uobj_alloc(UVERBS_OBJECT_AH, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -2696,23 -2492,22 +2817,25 @@@ err
  	return ret;
  }
  
 -static int ib_uverbs_destroy_ah(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_destroy_ah(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len, int out_len)
  {
  	struct ib_uverbs_destroy_ah cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, file,
 +				    in_len);
  }
  
 -static int ib_uverbs_attach_mcast(struct uverbs_attr_bundle *attrs,
 -				  const char __user *buf, int in_len,
 -				  int out_len)
 +ssize_t ib_uverbs_attach_mcast(struct ib_uverbs_file *file,
 +			       struct ib_device *ib_dev,
 +			       const char __user *buf, int in_len,
 +			       int out_len)
  {
  	struct ib_uverbs_attach_mcast cmd;
  	struct ib_qp                 *qp;
@@@ -2720,10 -2515,11 +2843,11 @@@
  	struct ib_uverbs_mcast_entry *mcast;
  	int                           ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
 +	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, file->ucontext);
  	if (!qp)
  		return -EINVAL;
  
@@@ -2771,10 -2566,11 +2895,11 @@@ ssize_t ib_uverbs_detach_mcast(struct i
  	int                           ret = -EINVAL;
  	bool                          found = false;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
 +	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, file->ucontext);
  	if (!qp)
  		return -EINVAL;
  
@@@ -3872,15 -3612,11 +3997,20 @@@ ssize_t ib_uverbs_create_srq(struct ib_
  {
  	struct ib_uverbs_create_srq      cmd;
  	struct ib_uverbs_create_xsrq     xcmd;
++<<<<<<< HEAD
 +	struct ib_uverbs_create_srq_resp resp;
 +	struct ib_udata                  udata;
  	int ret;
  
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
++=======
++	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
 +
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	memset(&xcmd, 0, sizeof(xcmd));
  	xcmd.response	 = cmd.response;
@@@ -3891,63 -3627,36 +4021,69 @@@
  	xcmd.max_sge	 = cmd.max_sge;
  	xcmd.srq_limit	 = cmd.srq_limit;
  
 -	return __uverbs_create_xsrq(attrs, &xcmd, &attrs->driver_udata);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &xcmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_create_xsrq(struct uverbs_attr_bundle *attrs,
 -				 const char __user *buf, int in_len,
 -				 int out_len)
 +ssize_t ib_uverbs_create_xsrq(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf, int in_len, int out_len)
  {
  	struct ib_uverbs_create_xsrq     cmd;
++<<<<<<< HEAD
 +	struct ib_uverbs_create_srq_resp resp;
 +	struct ib_udata                  udata;
 +	int ret;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return __uverbs_create_xsrq(attrs, &cmd, &attrs->driver_udata);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &cmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_modify_srq(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_modify_srq(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_modify_srq cmd;
 +	struct ib_udata             udata;
  	struct ib_srq              *srq;
  	struct ib_srq_attr          attr;
  	int                         ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
 +	ib_uverbs_init_udata(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,
 +		   out_len);
 +
 +	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, file->ucontext);
  	if (!srq)
  		return -EINVAL;
  
@@@ -3972,13 -3680,11 +4108,19 @@@ ssize_t ib_uverbs_query_srq(struct ib_u
  	struct ib_srq                   *srq;
  	int                             ret;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
 -	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
 +	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, file->ucontext);
  	if (!srq)
  		return -EINVAL;
  
@@@ -4010,13 -3712,13 +4152,18 @@@ ssize_t ib_uverbs_destroy_srq(struct ib
  	struct ib_uverbs_destroy_srq_resp resp;
  	struct ib_uobject		 *uobj;
  	struct ib_uevent_object        	 *obj;
++<<<<<<< HEAD
 +	int                         	  ret = -EINVAL;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_get_destroy(UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
 +	uobj  = uobj_get_write(UVERBS_OBJECT_SRQ, cmd.srq_handle,
 +			       file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
