scsi: qla2xxx: Add support for multiple fwdump templates/segments

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit a28d9e4ef99729d7e4db31d2dfeaf00755be4ab7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a28d9e4e.failed

This patch adds multipe firmware dump template and segments support for
ISP27XX/28XX.

	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a28d9e4ef99729d7e4db31d2dfeaf00755be4ab7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 046c47b82245,24fc0a51053a..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -2960,15 -3168,25 +2984,33 @@@ try_eft
  		eft_size = EFT_SIZE;
  	}
  
++<<<<<<< HEAD
 +	if (IS_QLA27XX(ha)) {
 +		if (!ha->fw_dump_template) {
 +			ql_log(ql_log_warn, vha, 0x00ba,
 +			    "Failed missing fwdump template\n");
 +			return;
++=======
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 		struct fwdt *fwdt = ha->fwdt;
+ 		uint j;
+ 
+ 		for (j = 0; j < 2; j++, fwdt++) {
+ 			if (!fwdt->template) {
+ 				ql_log(ql_log_warn, vha, 0x00ba,
+ 				    "-> fwdt%u no template\n", j);
+ 				continue;
+ 			}
+ 			ql_dbg(ql_dbg_init, vha, 0x00fa,
+ 			    "-> fwdt%u calculating fwdump size...\n", j);
+ 			fwdt->dump_size = qla27xx_fwdt_calculate_dump_size(
+ 			    vha, fwdt->template);
+ 			ql_dbg(ql_dbg_init, vha, 0x00fa,
+ 			    "-> fwdt%u calculated fwdump size = %#lx bytes\n",
+ 			    j, fwdt->dump_size);
+ 			dump_size += fwdt->dump_size;
++>>>>>>> a28d9e4ef997 (scsi: qla2xxx: Add support for multiple fwdump templates/segments)
  		}
- 		dump_size = qla27xx_fwdt_calculate_dump_size(vha);
- 		ql_dbg(ql_dbg_init, vha, 0x00fa,
- 		    "-> allocating fwdump (%x bytes)...\n", dump_size);
  		goto allocate;
  	}
  
@@@ -4172,11 -4412,11 +4217,11 @@@ qla2x00_nvram_config(scsi_qla_host_t *v
  	ql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010f,
  	    "Contents of NVRAM.\n");
  	ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0110,
 -	    nv, ha->nvram_size);
 +	    (uint8_t *)nv, ha->nvram_size);
  
  	/* Bad NVRAM data, set defaults parameters. */
- 	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' ||
- 	    nv->id[2] != 'P' || nv->id[3] != ' ' || nv->nvram_version < 1) {
+ 	if (chksum || memcmp("ISP ", nv->id, sizeof(nv->id)) ||
+ 	    nv->nvram_version < 1) {
  		/* Reset NVRAM data. */
  		ql_log(ql_log_warn, vha, 0x0064,
  		    "Inconsistent NVRAM "
@@@ -6718,12 -7020,11 +6763,11 @@@ qla24xx_nvram_config(scsi_qla_host_t *v
  	ql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x006a,
  	    "Contents of NVRAM\n");
  	ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010d,
 -	    nv, ha->nvram_size);
 +	    (uint8_t *)nv, ha->nvram_size);
  
  	/* Bad NVRAM data, set defaults parameters. */
- 	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P'
- 	    || nv->id[3] != ' ' ||
- 	    nv->nvram_version < cpu_to_le16(ICB_VERSION)) {
+ 	if (chksum || memcmp("ISP ", nv->id, sizeof(nv->id)) ||
+ 	    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {
  		/* Reset NVRAM data. */
  		ql_log(ql_log_warn, vha, 0x006b,
  		    "Inconsistent NVRAM detected: checksum=0x%x id=%c "
@@@ -7100,72 -7404,83 +7148,88 @@@ qla24xx_load_risc_flash(scsi_qla_host_
  			faddr += dlen;
  			risc_addr += dlen;
  			risc_size -= dlen;
- 			fragment++;
  		}
- 
- 		/* Next segment. */
- 		segments--;
  	}
  
++<<<<<<< HEAD
 +	if (!IS_QLA27XX(ha))
 +		return rval;
++=======
+ 	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
+ 		return QLA_SUCCESS;
++>>>>>>> a28d9e4ef997 (scsi: qla2xxx: Add support for multiple fwdump templates/segments)
+ 
+ 	templates = (risc_attr & BIT_9) ? 2 : 1;
+ 	ql_dbg(ql_dbg_init, vha, 0x0160, "-> templates = %u\n", templates);
+ 	for (j = 0; j < templates; j++, fwdt++) {
+ 		if (fwdt->template)
+ 			vfree(fwdt->template);
+ 		fwdt->template = NULL;
+ 		fwdt->length = 0;
+ 
+ 		qla24xx_read_flash_data(vha, dcode, faddr, 7);
+ 		risc_size = be32_to_cpu(dcode[2]);
+ 		ql_dbg(ql_dbg_init, vha, 0x0161,
+ 		    "-> fwdt%u template array at %#x (%#x dwords)\n",
+ 		    j, faddr, risc_size);
+ 		if (!risc_size || !~risc_size) {
+ 			ql_dbg(ql_dbg_init, vha, 0x0162,
+ 			    "-> fwdt%u failed to read array\n", j);
+ 			goto failed;
+ 		}
  
- 	if (ha->fw_dump_template)
- 		vfree(ha->fw_dump_template);
- 	ha->fw_dump_template = NULL;
- 	ha->fw_dump_template_len = 0;
- 
- 	ql_dbg(ql_dbg_init, vha, 0x0161,
- 	    "Loading fwdump template from %x\n", faddr);
- 	qla24xx_read_flash_data(vha, dcode, faddr, 7);
- 	risc_size = be32_to_cpu(dcode[2]);
- 	ql_dbg(ql_dbg_init, vha, 0x0162,
- 	    "-> array size %x dwords\n", risc_size);
- 	if (risc_size == 0 || risc_size == ~0)
- 		goto failed;
+ 		/* skip header and ignore checksum */
+ 		faddr += 7;
+ 		risc_size -= 8;
+ 
+ 		ql_dbg(ql_dbg_init, vha, 0x0163,
+ 		    "-> fwdt%u template allocate template %#x words...\n",
+ 		    j, risc_size);
+ 		fwdt->template = vmalloc(risc_size * sizeof(*dcode));
+ 		if (!fwdt->template) {
+ 			ql_log(ql_log_warn, vha, 0x0164,
+ 			    "-> fwdt%u failed allocate template.\n", j);
+ 			goto failed;
+ 		}
  
- 	dlen = (risc_size - 8) * sizeof(*dcode);
- 	ql_dbg(ql_dbg_init, vha, 0x0163,
- 	    "-> template allocating %x bytes...\n", dlen);
- 	ha->fw_dump_template = vmalloc(dlen);
- 	if (!ha->fw_dump_template) {
- 		ql_log(ql_log_warn, vha, 0x0164,
- 		    "Failed fwdump template allocate %x bytes.\n", risc_size);
- 		goto failed;
- 	}
+ 		dcode = fwdt->template;
+ 		qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
+ 		for (i = 0; i < risc_size; i++)
+ 			dcode[i] = le32_to_cpu(dcode[i]);
  
- 	faddr += 7;
- 	risc_size -= 8;
- 	dcode = ha->fw_dump_template;
- 	qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
- 	for (i = 0; i < risc_size; i++)
- 		dcode[i] = le32_to_cpu(dcode[i]);
+ 		if (!qla27xx_fwdt_template_valid(dcode)) {
+ 			ql_log(ql_log_warn, vha, 0x0165,
+ 			    "-> fwdt%u failed template validate\n", j);
+ 			goto failed;
+ 		}
  
- 	if (!qla27xx_fwdt_template_valid(dcode)) {
- 		ql_log(ql_log_warn, vha, 0x0165,
- 		    "Failed fwdump template validate\n");
- 		goto failed;
- 	}
+ 		dlen = qla27xx_fwdt_template_size(dcode);
+ 		ql_dbg(ql_dbg_init, vha, 0x0166,
+ 		    "-> fwdt%u template size %#lx bytes (%#lx words)\n",
+ 		    j, dlen, dlen / sizeof(*dcode));
+ 		if (dlen > risc_size * sizeof(*dcode)) {
+ 			ql_log(ql_log_warn, vha, 0x0167,
+ 			    "-> fwdt%u template exceeds array (%-lu bytes)\n",
+ 			    j, dlen - risc_size * sizeof(*dcode));
+ 			goto failed;
+ 		}
  
- 	dlen = qla27xx_fwdt_template_size(dcode);
- 	ql_dbg(ql_dbg_init, vha, 0x0166,
- 	    "-> template size %x bytes\n", dlen);
- 	if (dlen > risc_size * sizeof(*dcode)) {
- 		ql_log(ql_log_warn, vha, 0x0167,
- 		    "Failed fwdump template exceeds array by %zx bytes\n",
- 		    (size_t)(dlen - risc_size * sizeof(*dcode)));
- 		goto failed;
+ 		fwdt->length = dlen;
+ 		ql_dbg(ql_dbg_init, vha, 0x0168,
+ 		    "-> fwdt%u loaded template ok\n", j);
+ 
+ 		faddr += risc_size + 1;
  	}
- 	ha->fw_dump_template_len = dlen;
- 	return rval;
+ 
+ 	return QLA_SUCCESS;
  
  failed:
- 	ql_log(ql_log_warn, vha, 0x016d, "Failed fwdump template\n");
- 	if (ha->fw_dump_template)
- 		vfree(ha->fw_dump_template);
- 	ha->fw_dump_template = NULL;
- 	ha->fw_dump_template_len = 0;
- 	return rval;
+ 	if (fwdt->template)
+ 		vfree(fwdt->template);
+ 	fwdt->template = NULL;
+ 	fwdt->length = 0;
+ 
+ 	return QLA_SUCCESS;
  }
  
  #define QLA_FW_URL "http://ldriver.qlogic.com/firmware/"
@@@ -7273,42 -7588,32 +7337,53 @@@ static in
  qla24xx_load_risc_blob(scsi_qla_host_t *vha, uint32_t *srisc_addr)
  {
  	int	rval;
- 	int	segments, fragment;
- 	uint32_t *dcode, dlen;
- 	uint32_t risc_addr;
- 	uint32_t risc_size;
- 	uint32_t i;
+ 	uint templates, segments, fragment;
+ 	uint32_t *dcode;
+ 	ulong dlen;
+ 	uint32_t risc_addr, risc_size, risc_attr = 0;
+ 	ulong i;
+ 	uint j;
  	struct fw_blob *blob;
++<<<<<<< HEAD
 +	const uint32_t *fwcode;
 +	uint32_t fwclen;
++=======
+ 	uint32_t *fwcode;
++>>>>>>> a28d9e4ef997 (scsi: qla2xxx: Add support for multiple fwdump templates/segments)
  	struct qla_hw_data *ha = vha->hw;
  	struct req_que *req = ha->req_q_map[0];
+ 	struct fwdt *fwdt = ha->fwdt;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0090,
+ 	    "-> FW: Loading via request-firmware.\n");
  
- 	/* Load firmware blob. */
  	blob = qla2x00_request_firmware(vha);
  	if (!blob) {
- 		ql_log(ql_log_warn, vha, 0x0090,
- 		    "Firmware image unavailable.\n");
- 		ql_log(ql_log_warn, vha, 0x0091,
- 		    "Firmware images can be retrieved from: "
- 		    QLA_FW_URL ".\n");
+ 		ql_log(ql_log_warn, vha, 0x0092,
+ 		    "-> Firmware file not found.\n");
  
  		return QLA_FUNCTION_FAILED;
  	}
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_init, vha, 0x0092,
 +	    "FW: Loading via request-firmware.\n");
 +
 +	rval = QLA_SUCCESS;
 +
 +	segments = FA_RISC_CODE_SEGMENTS;
 +	dcode = (uint32_t *)req->ring;
 +	*srisc_addr = 0;
 +	fwcode = (uint32_t *)blob->fw->data;
 +	fwclen = 0;
 +
 +	/* Validate firmware image by checking version. */
 +	if (blob->fw->size < 8 * sizeof(uint32_t)) {
++=======
+ 	fwcode = (void *)blob->fw->data;
+ 	dcode = fwcode + 4;
+ 	if (qla24xx_risc_firmware_invalid(dcode)) {
++>>>>>>> a28d9e4ef997 (scsi: qla2xxx: Add support for multiple fwdump templates/segments)
  		ql_log(ql_log_fatal, vha, 0x0093,
  		    "Unable to verify integrity of firmware image (%zd).\n",
  		    blob->fw->size);
@@@ -7368,71 -7674,82 +7444,87 @@@
  			fwcode += dlen;
  			risc_addr += dlen;
  			risc_size -= dlen;
- 			fragment++;
  		}
- 
- 		/* Next segment. */
- 		segments--;
  	}
  
++<<<<<<< HEAD
 +	if (!IS_QLA27XX(ha))
 +		return rval;
++=======
+ 	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
+ 		return QLA_SUCCESS;
++>>>>>>> a28d9e4ef997 (scsi: qla2xxx: Add support for multiple fwdump templates/segments)
+ 
+ 	templates = (risc_attr & BIT_9) ? 2 : 1;
+ 	ql_dbg(ql_dbg_init, vha, 0x0170, "-> templates = %u\n", templates);
+ 	for (j = 0; j < templates; j++, fwdt++) {
+ 		if (fwdt->template)
+ 			vfree(fwdt->template);
+ 		fwdt->template = NULL;
+ 		fwdt->length = 0;
+ 
+ 		risc_size = be32_to_cpu(fwcode[2]);
+ 		ql_dbg(ql_dbg_init, vha, 0x0171,
+ 		    "-> fwdt%u template array at %#x (%#x dwords)\n",
+ 		    j, (uint32_t)((void *)fwcode - (void *)blob->fw->data),
+ 		    risc_size);
+ 		if (!risc_size || !~risc_size) {
+ 			ql_dbg(ql_dbg_init, vha, 0x0172,
+ 			    "-> fwdt%u failed to read array\n", j);
+ 			goto failed;
+ 		}
  
- 	if (ha->fw_dump_template)
- 		vfree(ha->fw_dump_template);
- 	ha->fw_dump_template = NULL;
- 	ha->fw_dump_template_len = 0;
- 
- 	ql_dbg(ql_dbg_init, vha, 0x171,
- 	    "Loading fwdump template from %x\n",
- 	    (uint32_t)((void *)fwcode - (void *)blob->fw->data));
- 	risc_size = be32_to_cpu(fwcode[2]);
- 	ql_dbg(ql_dbg_init, vha, 0x172,
- 	    "-> array size %x dwords\n", risc_size);
- 	if (risc_size == 0 || risc_size == ~0)
- 		goto failed;
+ 		/* skip header and ignore checksum */
+ 		fwcode += 7;
+ 		risc_size -= 8;
+ 
+ 		ql_dbg(ql_dbg_init, vha, 0x0173,
+ 		    "-> fwdt%u template allocate template %#x words...\n",
+ 		    j, risc_size);
+ 		fwdt->template = vmalloc(risc_size * sizeof(*dcode));
+ 		if (!fwdt->template) {
+ 			ql_log(ql_log_warn, vha, 0x0174,
+ 			    "-> fwdt%u failed allocate template.\n", j);
+ 			goto failed;
+ 		}
  
- 	dlen = (risc_size - 8) * sizeof(*fwcode);
- 	ql_dbg(ql_dbg_init, vha, 0x0173,
- 	    "-> template allocating %x bytes...\n", dlen);
- 	ha->fw_dump_template = vmalloc(dlen);
- 	if (!ha->fw_dump_template) {
- 		ql_log(ql_log_warn, vha, 0x0174,
- 		    "Failed fwdump template allocate %x bytes.\n", risc_size);
- 		goto failed;
- 	}
+ 		dcode = fwdt->template;
+ 		for (i = 0; i < risc_size; i++)
+ 			dcode[i] = le32_to_cpu(fwcode[i]);
  
- 	fwcode += 7;
- 	risc_size -= 8;
- 	dcode = ha->fw_dump_template;
- 	for (i = 0; i < risc_size; i++)
- 		dcode[i] = le32_to_cpu(fwcode[i]);
+ 		if (!qla27xx_fwdt_template_valid(dcode)) {
+ 			ql_log(ql_log_warn, vha, 0x0175,
+ 			    "-> fwdt%u failed template validate\n", j);
+ 			goto failed;
+ 		}
  
- 	if (!qla27xx_fwdt_template_valid(dcode)) {
- 		ql_log(ql_log_warn, vha, 0x0175,
- 		    "Failed fwdump template validate\n");
- 		goto failed;
- 	}
+ 		dlen = qla27xx_fwdt_template_size(dcode);
+ 		ql_dbg(ql_dbg_init, vha, 0x0176,
+ 		    "-> fwdt%u template size %#lx bytes (%#lx words)\n",
+ 		    j, dlen, dlen / sizeof(*dcode));
+ 		if (dlen > risc_size * sizeof(*dcode)) {
+ 			ql_log(ql_log_warn, vha, 0x0177,
+ 			    "-> fwdt%u template exceeds array (%-lu bytes)\n",
+ 			    j, dlen - risc_size * sizeof(*dcode));
+ 			goto failed;
+ 		}
  
- 	dlen = qla27xx_fwdt_template_size(dcode);
- 	ql_dbg(ql_dbg_init, vha, 0x0176,
- 	    "-> template size %x bytes\n", dlen);
- 	if (dlen > risc_size * sizeof(*fwcode)) {
- 		ql_log(ql_log_warn, vha, 0x0177,
- 		    "Failed fwdump template exceeds array by %zx bytes\n",
- 		    (size_t)(dlen - risc_size * sizeof(*fwcode)));
- 		goto failed;
+ 		fwdt->length = dlen;
+ 		ql_dbg(ql_dbg_init, vha, 0x0178,
+ 		    "-> fwdt%u loaded template ok\n", j);
+ 
+ 		fwcode += risc_size + 1;
  	}
- 	ha->fw_dump_template_len = dlen;
- 	return rval;
+ 
+ 	return QLA_SUCCESS;
  
  failed:
- 	ql_log(ql_log_warn, vha, 0x017d, "Failed fwdump template\n");
- 	if (ha->fw_dump_template)
- 		vfree(ha->fw_dump_template);
- 	ha->fw_dump_template = NULL;
- 	ha->fw_dump_template_len = 0;
- 	return rval;
+ 	if (fwdt->template)
+ 		vfree(fwdt->template);
+ 	fwdt->template = NULL;
+ 	fwdt->length = 0;
+ 
+ 	return QLA_SUCCESS;
  }
  
  int
@@@ -7681,12 -8013,11 +7773,11 @@@ qla81xx_nvram_config(scsi_qla_host_t *v
  	ql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0111,
  	    "Contents of NVRAM:\n");
  	ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0112,
 -	    nv, ha->nvram_size);
 +	    (uint8_t *)nv, ha->nvram_size);
  
  	/* Bad NVRAM data, set defaults parameters. */
- 	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P'
- 	    || nv->id[3] != ' ' ||
- 	    nv->nvram_version < cpu_to_le16(ICB_VERSION)) {
+ 	if (chksum || memcmp("ISP ", nv->id, sizeof(nv->id)) ||
+ 	    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {
  		/* Reset NVRAM data. */
  		ql_log(ql_log_info, vha, 0x0073,
  		    "Inconsistent NVRAM detected: checksum=0x%x id=%c "
diff --git a/drivers/scsi/qla2xxx/qla_bsg.c b/drivers/scsi/qla2xxx/qla_bsg.c
index 4a9fd8d944d6..b5e6c9930340 100644
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@ -84,8 +84,7 @@ qla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha,
 		return 0;
 	}
 
-	if (bcode[0] != 'H' || bcode[1] != 'Q' || bcode[2] != 'O' ||
-			bcode[3] != 'S') {
+	if (memcmp(bcode, "HQOS", 4)) {
 		/* Invalid FCP priority data header*/
 		ql_dbg(ql_dbg_user, vha, 0x7052,
 		    "Invalid FCP Priority data header. bcode=0x%x.\n",
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 824b13554ed2..fe71336d1d4d 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -3984,9 +3984,11 @@ struct qla_hw_data {
 	uint8_t		pep_version[3];
 
 	/* Firmware dump template */
-	void		*fw_dump_template;
-	uint32_t	fw_dump_template_len;
-	/* Firmware dump information. */
+	struct fwdt {
+		void *template;
+		ulong length;
+		ulong dump_size;
+	} fwdt[2];
 	struct qla2xxx_fw_dump *fw_dump;
 	uint32_t	fw_dump_len;
 	int		fw_dumped;
@@ -4028,7 +4030,6 @@ struct qla_hw_data {
 	uint16_t	product_id[4];
 
 	uint8_t		model_number[16+1];
-#define BINZERO		"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
 	char		model_desc[80];
 	uint8_t		adapter_id[16+1];
 
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index ca3f732c0824..aeb0fbc37cf2 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -608,7 +608,7 @@ extern void qla82xx_fw_dump(scsi_qla_host_t *, int);
 extern void qla8044_fw_dump(scsi_qla_host_t *, int);
 
 extern void qla27xx_fwdump(scsi_qla_host_t *, int);
-extern ulong qla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *);
+extern ulong qla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *, void *);
 extern int qla27xx_fwdt_template_valid(void *);
 extern ulong qla27xx_fwdt_template_size(void *);
 
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 9af7817f8d01..9f1571f3f63f 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -4415,6 +4415,9 @@ qla2x00_free_exchoffld_buffer(struct qla_hw_data *ha)
 static void
 qla2x00_free_fw_dump(struct qla_hw_data *ha)
 {
+	struct fwdt *fwdt = ha->fwdt;
+	uint j;
+
 	if (ha->fce)
 		dma_free_coherent(&ha->pdev->dev,
 		    FCE_SIZE, ha->fce, ha->fce_dma);
@@ -4425,8 +4428,6 @@ qla2x00_free_fw_dump(struct qla_hw_data *ha)
 
 	if (ha->fw_dump)
 		vfree(ha->fw_dump);
-	if (ha->fw_dump_template)
-		vfree(ha->fw_dump_template);
 
 	ha->fce = NULL;
 	ha->fce_dma = 0;
@@ -4437,8 +4438,13 @@ qla2x00_free_fw_dump(struct qla_hw_data *ha)
 	ha->fw_dump_reading = 0;
 	ha->fw_dump = NULL;
 	ha->fw_dump_len = 0;
-	ha->fw_dump_template = NULL;
-	ha->fw_dump_template_len = 0;
+
+	for (j = 0; j < 2; j++, fwdt++) {
+		if (fwdt->template)
+			vfree(fwdt->template);
+		fwdt->template = NULL;
+		fwdt->length = 0;
+	}
 }
 
 /*
diff --git a/drivers/scsi/qla2xxx/qla_sup.c b/drivers/scsi/qla2xxx/qla_sup.c
index 2a3055c799fb..e24019d60467 100644
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@ -2628,6 +2628,8 @@ qla25xx_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
 		goto slow_read;
 
 try_fast:
+	if (offset & 0xff)
+		goto slow_read;
 	optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
 	    &optrom_dma, GFP_KERNEL);
 	if (!optrom) {
diff --git a/drivers/scsi/qla2xxx/qla_tmpl.c b/drivers/scsi/qla2xxx/qla_tmpl.c
index 70f227f59050..74e05cef6ddb 100644
--- a/drivers/scsi/qla2xxx/qla_tmpl.c
+++ b/drivers/scsi/qla2xxx/qla_tmpl.c
@@ -38,7 +38,6 @@ qla27xx_insert32(uint32_t value, void *buf, ulong *len)
 static inline void
 qla27xx_insertbuf(void *mem, ulong size, void *buf, ulong *len)
 {
-
 	if (buf && mem && size) {
 		buf += *len;
 		memcpy(buf, mem, size);
@@ -816,23 +815,11 @@ qla27xx_walk_template(struct scsi_qla_host *vha,
 
 	if (count)
 		ql_dbg(ql_dbg_misc, vha, 0xd018,
-		    "%s: entry residual count (%lx)\n", __func__, count);
+		    "%s: entry count residual=+%lu\n", __func__, count);
 
 	if (ent)
 		ql_dbg(ql_dbg_misc, vha, 0xd019,
-		    "%s: missing end entry (%lx)\n", __func__, count);
-
-	if (buf && *len != vha->hw->fw_dump_len)
-		ql_dbg(ql_dbg_misc, vha, 0xd01b,
-		    "%s: length=%#lx residual=%+ld\n",
-		    __func__, *len, vha->hw->fw_dump_len - *len);
-
-	if (buf) {
-		ql_log(ql_log_warn, vha, 0xd015,
-		    "Firmware dump saved to temp buffer (%lu/%p)\n",
-		    vha->host_no, vha->hw->fw_dump);
-		qla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);
-	}
+		    "%s: missing end entry\n", __func__);
 }
 
 static void
@@ -855,8 +842,8 @@ qla27xx_driver_info(struct qla27xx_fwdt_template *tmp)
 }
 
 static void
-qla27xx_firmware_info(struct qla27xx_fwdt_template *tmp,
-	struct scsi_qla_host *vha)
+qla27xx_firmware_info(struct scsi_qla_host *vha,
+    struct qla27xx_fwdt_template *tmp)
 {
 	tmp->firmware_version[0] = vha->hw->fw_major_version;
 	tmp->firmware_version[1] = vha->hw->fw_minor_version;
@@ -873,7 +860,7 @@ ql27xx_edit_template(struct scsi_qla_host *vha,
 {
 	qla27xx_time_stamp(tmp);
 	qla27xx_driver_info(tmp);
-	qla27xx_firmware_info(tmp, vha);
+	qla27xx_firmware_info(vha, tmp);
 }
 
 static inline uint32_t
@@ -904,26 +891,26 @@ qla27xx_verify_template_header(struct qla27xx_fwdt_template *tmp)
 	return tmp->template_type == TEMPLATE_TYPE_FWDUMP;
 }
 
-static void
-qla27xx_execute_fwdt_template(struct scsi_qla_host *vha)
+static ulong
+qla27xx_execute_fwdt_template(struct scsi_qla_host *vha,
+    struct qla27xx_fwdt_template *tmp, void *buf)
 {
-	struct qla27xx_fwdt_template *tmp = vha->hw->fw_dump_template;
-	ulong len;
+	ulong len = 0;
 
 	if (qla27xx_fwdt_template_valid(tmp)) {
 		len = tmp->template_size;
-		tmp = memcpy(vha->hw->fw_dump, tmp, len);
+		tmp = memcpy(buf, tmp, len);
 		ql27xx_edit_template(vha, tmp);
-		qla27xx_walk_template(vha, tmp, tmp, &len);
-		vha->hw->fw_dump_len = len;
-		vha->hw->fw_dumped = 1;
+		qla27xx_walk_template(vha, tmp, buf, &len);
 	}
+
+	return len;
 }
 
 ulong
-qla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *vha)
+qla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *vha, void *p)
 {
-	struct qla27xx_fwdt_template *tmp = vha->hw->fw_dump_template;
+	struct qla27xx_fwdt_template *tmp = p;
 	ulong len = 0;
 
 	if (qla27xx_fwdt_template_valid(tmp)) {
@@ -972,17 +959,41 @@ qla27xx_fwdump(scsi_qla_host_t *vha, int hardware_locked)
 		spin_lock_irqsave(&vha->hw->hardware_lock, flags);
 #endif
 
-	if (!vha->hw->fw_dump)
-		ql_log(ql_log_warn, vha, 0xd01e, "fwdump buffer missing.\n");
-	else if (!vha->hw->fw_dump_template)
-		ql_log(ql_log_warn, vha, 0xd01f, "fwdump template missing.\n");
-	else if (vha->hw->fw_dumped)
-		ql_log(ql_log_warn, vha, 0xd300,
-		    "Firmware has been previously dumped (%p),"
-		    " -- ignoring request\n", vha->hw->fw_dump);
-	else {
-		QLA_FW_STOPPED(vha->hw);
-		qla27xx_execute_fwdt_template(vha);
+	if (!vha->hw->fw_dump) {
+		ql_log(ql_log_warn, vha, 0xd01e, "-> fwdump no buffer\n");
+	} else if (vha->hw->fw_dumped) {
+		ql_log(ql_log_warn, vha, 0xd01f,
+		    "-> Firmware already dumped (%p) -- ignoring request\n",
+		    vha->hw->fw_dump);
+	} else {
+		struct fwdt *fwdt = vha->hw->fwdt;
+		uint j;
+		ulong len;
+		void *buf = vha->hw->fw_dump;
+
+		for (j = 0; j < 2; j++, fwdt++, buf += len) {
+			ql_log(ql_log_warn, vha, 0xd011,
+			    "-> fwdt%u running...\n", j);
+			if (!fwdt->template) {
+				ql_log(ql_log_warn, vha, 0xd012,
+				    "-> fwdt%u no template\n", j);
+				break;
+			}
+			len = qla27xx_execute_fwdt_template(vha,
+			    fwdt->template, buf);
+			if (len != fwdt->dump_size) {
+				ql_log(ql_log_warn, vha, 0xd013,
+				    "-> fwdt%u fwdump residual=%+ld\n",
+				    j, fwdt->dump_size - len);
+			}
+		}
+		vha->hw->fw_dump_len = buf - (void *)vha->hw->fw_dump;
+		vha->hw->fw_dumped = 1;
+
+		ql_log(ql_log_warn, vha, 0xd015,
+		    "-> Firmware dump saved to buffer (%lu/%p) <%lx>\n",
+		    vha->host_no, vha->hw->fw_dump, vha->hw->fw_dump_cap_flags);
+		qla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);
 	}
 
 #ifndef __CHECKER__
