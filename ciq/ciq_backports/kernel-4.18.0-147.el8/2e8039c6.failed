IB/core: uverbs copy to struct or zero helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Michael Guralnik <michaelgur@mellanox.com>
commit 2e8039c656224b4a21e1947f45946d32a59bae53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/2e8039c6.failed

Add a helper to zero fill fields before copying data to
UVERBS_ATTR_STRUCT.

As UVERBS_ATTR_STRUCT can be used as an extensible struct, we want to make
sure that if the user supplies us with a struct that has new fields that
we are not aware of, we return them zeroed to the user.

This helper should be used when using UVERBS_ATTR_STRUCT for an extendable
data structure and there is a need to make sure that extended members of
the struct, that the kernel doesn't handle, are returned zeroed to the
user. This is needed due to the fact that UVERBS_ATTR_STRUCT allows
non-zero values for members after 'last' member.

	Signed-off-by: Michael Guralnik <michaelgur@mellanox.com>
	Reviewed-by: Majd Dibbiny <majd@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 2e8039c656224b4a21e1947f45946d32a59bae53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index 03065bad8dae,8c81ff698052..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -455,39 -591,174 +455,191 @@@ long ib_uverbs_ioctl(struct file *filp
  	struct ib_uverbs_ioctl_hdr __user *user_hdr =
  		(struct ib_uverbs_ioctl_hdr __user *)arg;
  	struct ib_uverbs_ioctl_hdr hdr;
 +	struct ib_device *ib_dev;
  	int srcu_key;
 -	int err;
 +	long err;
  
 -	if (unlikely(cmd != RDMA_VERBS_IOCTL))
 -		return -ENOIOCTLCMD;
 +	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 +	ib_dev = srcu_dereference(file->device->ib_dev,
 +				  &file->device->disassociate_srcu);
 +	if (!ib_dev) {
 +		err = -EIO;
 +		goto out;
 +	}
  
 -	err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
 -	if (err)
 -		return -EFAULT;
 +	if (cmd == RDMA_VERBS_IOCTL) {
 +		err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
  
 -	if (hdr.length > PAGE_SIZE ||
 -	    hdr.length != struct_size(&hdr, attrs, hdr.num_attrs))
 -		return -EINVAL;
 +		if (err || hdr.length > IB_UVERBS_MAX_CMD_SZ ||
 +		    hdr.length != sizeof(hdr) + hdr.num_attrs * sizeof(struct ib_uverbs_attr)) {
 +			err = -EINVAL;
 +			goto out;
 +		}
  
 -	if (hdr.reserved1 || hdr.reserved2)
 -		return -EPROTONOSUPPORT;
 +		if (hdr.reserved1 || hdr.reserved2) {
 +			err = -EPROTONOSUPPORT;
 +			goto out;
 +		}
  
 -	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 -	err = ib_uverbs_cmd_verbs(file, &hdr, user_hdr->attrs);
 +		err = ib_uverbs_cmd_verbs(ib_dev, file, &hdr,
 +					  (__user void *)arg + sizeof(hdr));
 +	} else {
 +		err = -ENOIOCTLCMD;
 +	}
 +out:
  	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 +
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits)
+ {
+ 	const struct uverbs_attr *attr;
+ 	u64 flags;
+ 
+ 	attr = uverbs_attr_get(attrs_bundle, idx);
+ 	/* Missing attribute means 0 flags */
+ 	if (IS_ERR(attr)) {
+ 		*to = 0;
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 * New userspace code should use 8 bytes to pass flags, but we
+ 	 * transparently support old userspaces that were using 4 bytes as
+ 	 * well.
+ 	 */
+ 	if (attr->ptr_attr.len == 8)
+ 		flags = attr->ptr_attr.data;
+ 	else if (attr->ptr_attr.len == 4)
+ 		flags = *(u32 *)&attr->ptr_attr.data;
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (flags & ~allowed_bits)
+ 		return -EINVAL;
+ 
+ 	*to = flags;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_get_flags64);
+ 
+ int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits)
+ {
+ 	u64 flags;
+ 	int ret;
+ 
+ 	ret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (flags > U32_MAX)
+ 		return -EINVAL;
+ 	*to = flags;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_get_flags32);
+ 
+ /*
+  * Fill a ib_udata struct (core or uhw) using the given attribute IDs.
+  * This is primarily used to convert the UVERBS_ATTR_UHW() into the
+  * ib_udata format used by the drivers.
+  */
+ void uverbs_fill_udata(struct uverbs_attr_bundle *bundle,
+ 		       struct ib_udata *udata, unsigned int attr_in,
+ 		       unsigned int attr_out)
+ {
+ 	struct bundle_priv *pbundle =
+ 		container_of(bundle, struct bundle_priv, bundle);
+ 	const struct uverbs_attr *in =
+ 		uverbs_attr_get(&pbundle->bundle, attr_in);
+ 	const struct uverbs_attr *out =
+ 		uverbs_attr_get(&pbundle->bundle, attr_out);
+ 
+ 	if (!IS_ERR(in)) {
+ 		udata->inlen = in->ptr_attr.len;
+ 		if (uverbs_attr_ptr_is_inline(in))
+ 			udata->inbuf =
+ 				&pbundle->user_attrs[in->ptr_attr.uattr_idx]
+ 					 .data;
+ 		else
+ 			udata->inbuf = u64_to_user_ptr(in->ptr_attr.data);
+ 	} else {
+ 		udata->inbuf = NULL;
+ 		udata->inlen = 0;
+ 	}
+ 
+ 	if (!IS_ERR(out)) {
+ 		udata->outbuf = u64_to_user_ptr(out->ptr_attr.data);
+ 		udata->outlen = out->ptr_attr.len;
+ 	} else {
+ 		udata->outbuf = NULL;
+ 		udata->outlen = 0;
+ 	}
+ }
+ 
+ int uverbs_copy_to(const struct uverbs_attr_bundle *bundle, size_t idx,
+ 		   const void *from, size_t size)
+ {
+ 	struct bundle_priv *pbundle =
+ 		container_of(bundle, struct bundle_priv, bundle);
+ 	const struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);
+ 	u16 flags;
+ 	size_t min_size;
+ 
+ 	if (IS_ERR(attr))
+ 		return PTR_ERR(attr);
+ 
+ 	min_size = min_t(size_t, attr->ptr_attr.len, size);
+ 	if (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))
+ 		return -EFAULT;
+ 
+ 	flags = pbundle->uattrs[attr->ptr_attr.uattr_idx].flags |
+ 		UVERBS_ATTR_F_VALID_OUTPUT;
+ 	if (put_user(flags,
+ 		     &pbundle->user_attrs[attr->ptr_attr.uattr_idx].flags))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_copy_to);
+ 
+ int _uverbs_get_const(s64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		      size_t idx, s64 lower_bound, u64 upper_bound,
+ 		      s64  *def_val)
+ {
+ 	const struct uverbs_attr *attr;
+ 
+ 	attr = uverbs_attr_get(attrs_bundle, idx);
+ 	if (IS_ERR(attr)) {
+ 		if ((PTR_ERR(attr) != -ENOENT) || !def_val)
+ 			return PTR_ERR(attr);
+ 
+ 		*to = *def_val;
+ 	} else {
+ 		*to = attr->ptr_attr.data;
+ 	}
+ 
+ 	if (*to < lower_bound || (*to > 0 && (u64)*to > upper_bound))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(_uverbs_get_const);
+ 
+ int uverbs_copy_to_struct_or_zero(const struct uverbs_attr_bundle *bundle,
+ 				  size_t idx, const void *from, size_t size)
+ {
+ 	const struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);
+ 
+ 	if (clear_user(u64_to_user_ptr(attr->ptr_attr.data),
+ 		       attr->ptr_attr.len))
+ 		return -EFAULT;
+ 	return uverbs_copy_to(bundle, idx, from, size);
+ }
++>>>>>>> 2e8039c65622 (IB/core: uverbs copy to struct or zero helper)
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,27da906beea7..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -547,55 -841,100 +547,89 @@@ static inline int _uverbs_copy_from_or_
  #define uverbs_copy_from_or_zero(to, attrs_bundle, idx)			      \
  	_uverbs_copy_from_or_zero(to, attrs_bundle, idx, sizeof(*to))
  
 -static inline struct ib_ucontext *
 -ib_uverbs_get_ucontext(const struct uverbs_attr_bundle *attrs)
 -{
 -	return ib_uverbs_get_ucontext_file(attrs->ufile);
 -}
 +/* =================================================
 + *	 Definitions -> Specs infrastructure
 + * =================================================
 + */
  
 +/*
 + * uverbs_alloc_spec_tree - Merges different common and driver specific feature
 + *	into one parsing tree that every uverbs command will be parsed upon.
 + *
 + * @num_trees: Number of trees in the array @trees.
 + * @trees: Array of pointers to tree root definitions to merge. Each such tree
 + *	   possibly contains objects, methods and attributes definitions.
 + *
 + * Returns:
 + *	uverbs_root_spec *: The root of the merged parsing tree.
 + *	On error, we return an error code. Error is checked via IS_ERR.
 + *
 + * The following merges could take place:
 + * a. Two trees representing the same method with different handler
 + *	-> We take the handler of the tree that its handler != NULL
 + *	   and its index in the trees array is greater. The incentive for that
 + *	   is that developers are expected to first merge common trees and then
 + *	   merge trees that gives specialized the behaviour.
 + * b. Two trees representing the same object with different
 + *    type_attrs (struct uverbs_obj_type):
 + *	-> We take the type_attrs of the tree that its type_attr != NULL
 + *	   and its index in the trees array is greater. This could be used
 + *	   in order to override the free function, allocation size, etc.
 + * c. Two trees representing the same method attribute (same id but possibly
 + *    different attributes):
 + *	-> ERROR (-ENOENT), we believe that's not the programmer's intent.
 + *
 + * An object without any methods is considered invalid and will abort the
 + * function with -ENOENT error.
 + */
  #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
++<<<<<<< HEAD
 +struct uverbs_root_spec *uverbs_alloc_spec_tree(unsigned int num_trees,
 +						const struct uverbs_object_tree_def **trees);
 +void uverbs_free_spec_tree(struct uverbs_root_spec *root);
++=======
+ int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits);
+ int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits);
+ int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle, size_t idx,
+ 		   const void *from, size_t size);
+ __malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size,
+ 			     gfp_t flags);
+ 
+ static inline __malloc void *uverbs_alloc(struct uverbs_attr_bundle *bundle,
+ 					  size_t size)
+ {
+ 	return _uverbs_alloc(bundle, size, GFP_KERNEL);
+ }
+ 
+ static inline __malloc void *uverbs_zalloc(struct uverbs_attr_bundle *bundle,
+ 					   size_t size)
+ {
+ 	return _uverbs_alloc(bundle, size, GFP_KERNEL | __GFP_ZERO);
+ }
+ int _uverbs_get_const(s64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		      size_t idx, s64 lower_bound, u64 upper_bound,
+ 		      s64 *def_val);
+ int uverbs_copy_to_struct_or_zero(const struct uverbs_attr_bundle *bundle,
+ 				  size_t idx, const void *from, size_t size);
++>>>>>>> 2e8039c65622 (IB/core: uverbs copy to struct or zero helper)
  #else
 -static inline int
 -uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		   size_t idx, u64 allowed_bits)
 -{
 -	return -EINVAL;
 -}
 -static inline int
 -uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		   size_t idx, u64 allowed_bits)
 -{
 -	return -EINVAL;
 -}
 -static inline int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle,
 -				 size_t idx, const void *from, size_t size)
 +static inline struct uverbs_root_spec *uverbs_alloc_spec_tree(unsigned int num_trees,
 +							      const struct uverbs_object_tree_def **trees)
  {
 -	return -EINVAL;
 -}
 -static inline __malloc void *uverbs_alloc(struct uverbs_attr_bundle *bundle,
 -					  size_t size)
 -{
 -	return ERR_PTR(-EINVAL);
 -}
 -static inline __malloc void *uverbs_zalloc(struct uverbs_attr_bundle *bundle,
 -					   size_t size)
 -{
 -	return ERR_PTR(-EINVAL);
 +	return NULL;
  }
 -static inline int
 -_uverbs_get_const(s64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		  size_t idx, s64 lower_bound, u64 upper_bound,
 -		  s64 *def_val)
 +
 +static inline void uverbs_free_spec_tree(struct uverbs_root_spec *root)
  {
 -	return -EINVAL;
  }
+ static inline int
+ uverbs_copy_to_struct_or_zero(const struct uverbs_attr_bundle *bundle,
+ 			      size_t idx, const void *from, size_t size)
+ {
+ 	return -EINVAL;
+ }
  #endif
  
 -#define uverbs_get_const(_to, _attrs_bundle, _idx)                             \
 -	({                                                                     \
 -		s64 _val;                                                      \
 -		int _ret = _uverbs_get_const(&_val, _attrs_bundle, _idx,       \
 -					     type_min(typeof(*_to)),           \
 -					     type_max(typeof(*_to)), NULL);    \
 -		(*_to) = _val;                                                 \
 -		_ret;                                                          \
 -	})
 -
 -#define uverbs_get_const_default(_to, _attrs_bundle, _idx, _default)           \
 -	({                                                                     \
 -		s64 _val;                                                      \
 -		s64 _def_val = _default;                                       \
 -		int _ret =                                                     \
 -			_uverbs_get_const(&_val, _attrs_bundle, _idx,          \
 -					  type_min(typeof(*_to)),              \
 -					  type_max(typeof(*_to)), &_def_val);  \
 -		(*_to) = _val;                                                 \
 -		_ret;                                                          \
 -	})
  #endif
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path include/rdma/uverbs_ioctl.h
