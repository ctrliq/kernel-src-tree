tools/testing/nvdimm: add Intel DSM 1.8 support for nfit_test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit ecaa4a97b3908be0bf3ad12181ae8c44d1816d40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ecaa4a97.failed

Adding test support for new Intel DSM from v1.8. The ability of simulating
master passphrase update and master secure erase have been added to
nfit_test.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit ecaa4a97b3908be0bf3ad12181ae8c44d1816d40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/nvdimm/test/nfit.c
diff --cc tools/testing/nvdimm/test/nfit.c
index 6c16ac36d482,9a8d0e432e99..000000000000
--- a/tools/testing/nvdimm/test/nfit.c
+++ b/tools/testing/nvdimm/test/nfit.c
@@@ -143,6 -142,13 +143,16 @@@ static u32 handle[] = 
  
  static unsigned long dimm_fail_cmd_flags[ARRAY_SIZE(handle)];
  static int dimm_fail_cmd_code[ARRAY_SIZE(handle)];
++<<<<<<< HEAD
++=======
+ struct nfit_test_sec {
+ 	u8 state;
+ 	u8 ext_state;
+ 	u8 passphrase[32];
+ 	u8 master_passphrase[32];
+ 	u64 overwrite_end_time;
+ } dimm_sec_info[NUM_DCR];
++>>>>>>> ecaa4a97b390 (tools/testing/nvdimm: add Intel DSM 1.8 support for nfit_test)
  
  static const struct nd_intel_smart smart_def = {
  	.flags = ND_INTEL_SMART_HEALTH_VALID
@@@ -936,6 -940,242 +946,245 @@@ static int override_return_code(int dim
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int nd_intel_test_cmd_security_status(struct nfit_test *t,
+ 		struct nd_intel_get_security_state *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	nd_cmd->status = 0;
+ 	nd_cmd->state = sec->state;
+ 	nd_cmd->extended_state = sec->ext_state;
+ 	dev_dbg(dev, "security state (%#x) returned\n", nd_cmd->state);
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_unlock_unit(struct nfit_test *t,
+ 		struct nd_intel_unlock_unit *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->state & ND_INTEL_SEC_STATE_LOCKED) ||
+ 			(sec->state & ND_INTEL_SEC_STATE_FROZEN)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "unlock unit: invalid state: %#x\n",
+ 				sec->state);
+ 	} else if (memcmp(nd_cmd->passphrase, sec->passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "unlock unit: invalid passphrase\n");
+ 	} else {
+ 		nd_cmd->status = 0;
+ 		sec->state = ND_INTEL_SEC_STATE_ENABLED;
+ 		dev_dbg(dev, "Unit unlocked\n");
+ 	}
+ 
+ 	dev_dbg(dev, "unlocking status returned: %#x\n", nd_cmd->status);
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_set_pass(struct nfit_test *t,
+ 		struct nd_intel_set_passphrase *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (sec->state & ND_INTEL_SEC_STATE_FROZEN) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "set passphrase: wrong security state\n");
+ 	} else if (memcmp(nd_cmd->old_pass, sec->passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "set passphrase: wrong passphrase\n");
+ 	} else {
+ 		memcpy(sec->passphrase, nd_cmd->new_pass,
+ 				ND_INTEL_PASSPHRASE_SIZE);
+ 		sec->state |= ND_INTEL_SEC_STATE_ENABLED;
+ 		nd_cmd->status = 0;
+ 		dev_dbg(dev, "passphrase updated\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_freeze_lock(struct nfit_test *t,
+ 		struct nd_intel_freeze_lock *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->state & ND_INTEL_SEC_STATE_ENABLED)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "freeze lock: wrong security state\n");
+ 	} else {
+ 		sec->state |= ND_INTEL_SEC_STATE_FROZEN;
+ 		nd_cmd->status = 0;
+ 		dev_dbg(dev, "security frozen\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_disable_pass(struct nfit_test *t,
+ 		struct nd_intel_disable_passphrase *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->state & ND_INTEL_SEC_STATE_ENABLED) ||
+ 			(sec->state & ND_INTEL_SEC_STATE_FROZEN)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "disable passphrase: wrong security state\n");
+ 	} else if (memcmp(nd_cmd->passphrase, sec->passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "disable passphrase: wrong passphrase\n");
+ 	} else {
+ 		memset(sec->passphrase, 0, ND_INTEL_PASSPHRASE_SIZE);
+ 		sec->state = 0;
+ 		dev_dbg(dev, "disable passphrase: done\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_secure_erase(struct nfit_test *t,
+ 		struct nd_intel_secure_erase *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->state & ND_INTEL_SEC_STATE_ENABLED) ||
+ 			(sec->state & ND_INTEL_SEC_STATE_FROZEN)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "secure erase: wrong security state\n");
+ 	} else if (memcmp(nd_cmd->passphrase, sec->passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "secure erase: wrong passphrase\n");
+ 	} else {
+ 		memset(sec->passphrase, 0, ND_INTEL_PASSPHRASE_SIZE);
+ 		memset(sec->master_passphrase, 0, ND_INTEL_PASSPHRASE_SIZE);
+ 		sec->state = 0;
+ 		sec->ext_state = ND_INTEL_SEC_ESTATE_ENABLED;
+ 		dev_dbg(dev, "secure erase: done\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_overwrite(struct nfit_test *t,
+ 		struct nd_intel_overwrite *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if ((sec->state & ND_INTEL_SEC_STATE_ENABLED) &&
+ 			memcmp(nd_cmd->passphrase, sec->passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "overwrite: wrong passphrase\n");
+ 		return 0;
+ 	}
+ 
+ 	memset(sec->passphrase, 0, ND_INTEL_PASSPHRASE_SIZE);
+ 	sec->state = ND_INTEL_SEC_STATE_OVERWRITE;
+ 	dev_dbg(dev, "overwrite progressing.\n");
+ 	sec->overwrite_end_time = get_jiffies_64() + 5 * HZ;
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_query_overwrite(struct nfit_test *t,
+ 		struct nd_intel_query_overwrite *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->state & ND_INTEL_SEC_STATE_OVERWRITE)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_OQUERY_SEQUENCE_ERR;
+ 		return 0;
+ 	}
+ 
+ 	if (time_is_before_jiffies64(sec->overwrite_end_time)) {
+ 		sec->overwrite_end_time = 0;
+ 		sec->state = 0;
+ 		sec->ext_state = ND_INTEL_SEC_ESTATE_ENABLED;
+ 		dev_dbg(dev, "overwrite is complete\n");
+ 	} else
+ 		nd_cmd->status = ND_INTEL_STATUS_OQUERY_INPROGRESS;
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_master_set_pass(struct nfit_test *t,
+ 		struct nd_intel_set_master_passphrase *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->ext_state & ND_INTEL_SEC_ESTATE_ENABLED)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_NOT_SUPPORTED;
+ 		dev_dbg(dev, "master set passphrase: in wrong state\n");
+ 	} else if (sec->ext_state & ND_INTEL_SEC_ESTATE_PLIMIT) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "master set passphrase: in wrong security state\n");
+ 	} else if (memcmp(nd_cmd->old_pass, sec->master_passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "master set passphrase: wrong passphrase\n");
+ 	} else {
+ 		memcpy(sec->master_passphrase, nd_cmd->new_pass,
+ 				ND_INTEL_PASSPHRASE_SIZE);
+ 		sec->ext_state = ND_INTEL_SEC_ESTATE_ENABLED;
+ 		dev_dbg(dev, "master passphrase: updated\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nd_intel_test_cmd_master_secure_erase(struct nfit_test *t,
+ 		struct nd_intel_master_secure_erase *nd_cmd,
+ 		unsigned int buf_len, int dimm)
+ {
+ 	struct device *dev = &t->pdev.dev;
+ 	struct nfit_test_sec *sec = &dimm_sec_info[dimm];
+ 
+ 	if (!(sec->ext_state & ND_INTEL_SEC_ESTATE_ENABLED)) {
+ 		nd_cmd->status = ND_INTEL_STATUS_NOT_SUPPORTED;
+ 		dev_dbg(dev, "master secure erase: in wrong state\n");
+ 	} else if (sec->ext_state & ND_INTEL_SEC_ESTATE_PLIMIT) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_STATE;
+ 		dev_dbg(dev, "master secure erase: in wrong security state\n");
+ 	} else if (memcmp(nd_cmd->passphrase, sec->master_passphrase,
+ 				ND_INTEL_PASSPHRASE_SIZE) != 0) {
+ 		nd_cmd->status = ND_INTEL_STATUS_INVALID_PASS;
+ 		dev_dbg(dev, "master secure erase: wrong passphrase\n");
+ 	} else {
+ 		/* we do not erase master state passphrase ever */
+ 		sec->ext_state = ND_INTEL_SEC_ESTATE_ENABLED;
+ 		memset(sec->passphrase, 0, ND_INTEL_PASSPHRASE_SIZE);
+ 		sec->state = 0;
+ 		dev_dbg(dev, "master secure erase: done\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
++>>>>>>> ecaa4a97b390 (tools/testing/nvdimm: add Intel DSM 1.8 support for nfit_test)
  static int get_dimm(struct nfit_mem *nfit_mem, unsigned int func)
  {
  	int i;
@@@ -983,6 -1223,46 +1232,49 @@@ static int nfit_test_ctl(struct nvdimm_
  				return i;
  
  			switch (func) {
++<<<<<<< HEAD
++=======
+ 			case NVDIMM_INTEL_GET_SECURITY_STATE:
+ 				rc = nd_intel_test_cmd_security_status(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_UNLOCK_UNIT:
+ 				rc = nd_intel_test_cmd_unlock_unit(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_SET_PASSPHRASE:
+ 				rc = nd_intel_test_cmd_set_pass(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_DISABLE_PASSPHRASE:
+ 				rc = nd_intel_test_cmd_disable_pass(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_FREEZE_LOCK:
+ 				rc = nd_intel_test_cmd_freeze_lock(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_SECURE_ERASE:
+ 				rc = nd_intel_test_cmd_secure_erase(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_OVERWRITE:
+ 				rc = nd_intel_test_cmd_overwrite(t,
+ 						buf, buf_len, i - t->dcr_idx);
+ 				break;
+ 			case NVDIMM_INTEL_QUERY_OVERWRITE:
+ 				rc = nd_intel_test_cmd_query_overwrite(t,
+ 						buf, buf_len, i - t->dcr_idx);
+ 				break;
+ 			case NVDIMM_INTEL_SET_MASTER_PASSPHRASE:
+ 				rc = nd_intel_test_cmd_master_set_pass(t,
+ 						buf, buf_len, i);
+ 				break;
+ 			case NVDIMM_INTEL_MASTER_SECURE_ERASE:
+ 				rc = nd_intel_test_cmd_master_secure_erase(t,
+ 						buf, buf_len, i);
+ 				break;
++>>>>>>> ecaa4a97b390 (tools/testing/nvdimm: add Intel DSM 1.8 support for nfit_test)
  			case ND_INTEL_ENABLE_LSS_STATUS:
  				rc = nd_intel_test_cmd_set_lss_status(t,
  						buf, buf_len);
@@@ -2210,6 -2502,20 +2514,23 @@@ static void nfit_test0_setup(struct nfi
  	set_bit(ND_INTEL_FW_FINISH_UPDATE, &acpi_desc->dimm_cmd_force_en);
  	set_bit(ND_INTEL_FW_FINISH_QUERY, &acpi_desc->dimm_cmd_force_en);
  	set_bit(ND_INTEL_ENABLE_LSS_STATUS, &acpi_desc->dimm_cmd_force_en);
++<<<<<<< HEAD
++=======
+ 	set_bit(NVDIMM_INTEL_GET_SECURITY_STATE,
+ 			&acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_SET_PASSPHRASE, &acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_DISABLE_PASSPHRASE,
+ 			&acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_UNLOCK_UNIT, &acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_FREEZE_LOCK, &acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_SECURE_ERASE, &acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_OVERWRITE, &acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_QUERY_OVERWRITE, &acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_SET_MASTER_PASSPHRASE,
+ 			&acpi_desc->dimm_cmd_force_en);
+ 	set_bit(NVDIMM_INTEL_MASTER_SECURE_ERASE,
+ 			&acpi_desc->dimm_cmd_force_en);
++>>>>>>> ecaa4a97b390 (tools/testing/nvdimm: add Intel DSM 1.8 support for nfit_test)
  }
  
  static void nfit_test1_setup(struct nfit_test *t)
* Unmerged path tools/testing/nvdimm/test/nfit.c
