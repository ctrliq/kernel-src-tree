libnvdimm/dimm: Fix security capability detection for non-Intel NVDIMMs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit 1cb95e072ede5e3d6a54eefd520db21b45985896
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1cb95e07.failed

Kees reports a crash with the following signature...

 RIP: 0010:nvdimm_visible+0x79/0x80
 [..]
 Call Trace:
  internal_create_group+0xf4/0x380
  sysfs_create_groups+0x46/0xb0
  device_add+0x331/0x680
  nd_async_device_register+0x15/0x60
  async_run_entry_fn+0x38/0x100

...when starting a QEMU environment with "label-less" DIMM. Without
labels QEMU does not publish any DSM methods. Without defined methods
the NVDIMM_FAMILY type is not established and the nfit driver will skip
registering security operations.

In that case the security state should be initialized to a negative
value in __nvdimm_create() and nvdimm_visible() should skip
interrogating the specific ops. However, since 'enum
nvdimm_security_state' was only defined to contain positive values the
"if (nvdimm->sec.state < 0)" check always fails.

Define a negative error state to allow negative state values to be
handled as expected.

Fixes: f2989396553a ("acpi/nfit, libnvdimm: Introduce nvdimm_security_ops")
	Reviewed-by: Dave Jiang <dave.jiang@intel.com>
	Reported-by: Kees Cook <keescook@chromium.org>
	Tested-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 1cb95e072ede5e3d6a54eefd520db21b45985896)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/libnvdimm.h
diff --cc include/linux/libnvdimm.h
index c0e66496e33c,7315977b64da..000000000000
--- a/include/linux/libnvdimm.h
+++ b/include/linux/libnvdimm.h
@@@ -155,6 -159,47 +155,50 @@@ static inline struct nd_blk_region_des
  
  }
  
++<<<<<<< HEAD
++=======
+ enum nvdimm_security_state {
+ 	NVDIMM_SECURITY_ERROR = -1,
+ 	NVDIMM_SECURITY_DISABLED,
+ 	NVDIMM_SECURITY_UNLOCKED,
+ 	NVDIMM_SECURITY_LOCKED,
+ 	NVDIMM_SECURITY_FROZEN,
+ 	NVDIMM_SECURITY_OVERWRITE,
+ };
+ 
+ #define NVDIMM_PASSPHRASE_LEN		32
+ #define NVDIMM_KEY_DESC_LEN		22
+ 
+ struct nvdimm_key_data {
+ 	u8 data[NVDIMM_PASSPHRASE_LEN];
+ };
+ 
+ enum nvdimm_passphrase_type {
+ 	NVDIMM_USER,
+ 	NVDIMM_MASTER,
+ };
+ 
+ struct nvdimm_security_ops {
+ 	enum nvdimm_security_state (*state)(struct nvdimm *nvdimm,
+ 			enum nvdimm_passphrase_type pass_type);
+ 	int (*freeze)(struct nvdimm *nvdimm);
+ 	int (*change_key)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *old_data,
+ 			const struct nvdimm_key_data *new_data,
+ 			enum nvdimm_passphrase_type pass_type);
+ 	int (*unlock)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data);
+ 	int (*disable)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data);
+ 	int (*erase)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data,
+ 			enum nvdimm_passphrase_type pass_type);
+ 	int (*overwrite)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data);
+ 	int (*query_overwrite)(struct nvdimm *nvdimm);
+ };
+ 
++>>>>>>> 1cb95e072ede (libnvdimm/dimm: Fix security capability detection for non-Intel NVDIMMs)
  void badrange_init(struct badrange *badrange);
  int badrange_add(struct badrange *badrange, u64 addr, u64 length);
  void badrange_forget(struct badrange *badrange, phys_addr_t start,
* Unmerged path include/linux/libnvdimm.h
