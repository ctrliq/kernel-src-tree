hv_netvsc: fix typos in code comments

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Adrian Vladu <avladu@cloudbasesolutions.com>
commit 52d3b4949192e93b948daaa40678fcd4b94bcbd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/52d3b494.failed

Fix all typos from hyperv netvsc code comments.

	Signed-off-by: Adrian Vladu <avladu@cloudbasesolutions.com>

	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Sasha Levin <sashal@kernel.org>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: "Alessandro Pilotti" <apilotti@cloudbasesolutions.com>
	Signed-off-by: Sasha Levin <sashal@kernel.org>
(cherry picked from commit 52d3b4949192e93b948daaa40678fcd4b94bcbd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
diff --cc drivers/net/hyperv/hyperv_net.h
index 42d284669b03,e859ae2e42d5..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -1161,6 -1179,25 +1161,28 @@@ enum ndis_per_pkt_info_type 
  	MAX_PER_PKT_INFO
  };
  
++<<<<<<< HEAD
++=======
+ enum rndis_per_pkt_info_interal_type {
+ 	RNDIS_PKTINFO_ID = 1,
+ 	/* Add more members here */
+ 
+ 	RNDIS_PKTINFO_MAX
+ };
+ 
+ #define RNDIS_PKTINFO_SUBALLOC BIT(0)
+ #define RNDIS_PKTINFO_1ST_FRAG BIT(1)
+ #define RNDIS_PKTINFO_LAST_FRAG BIT(2)
+ 
+ #define RNDIS_PKTINFO_ID_V1 1
+ 
+ struct rndis_pktinfo_id {
+ 	u8 ver;
+ 	u8 flag;
+ 	u16 pkt_id;
+ };
+ 
++>>>>>>> 52d3b4949192 (hv_netvsc: fix typos in code comments)
  struct ndis_pkt_8021q_info {
  	union {
  		struct {
* Unmerged path drivers/net/hyperv/hyperv_net.h
diff --git a/drivers/net/hyperv/netvsc.c b/drivers/net/hyperv/netvsc.c
index 1a942feab954..1d19c3226661 100644
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@ -1323,7 +1323,7 @@ void netvsc_channel_cb(void *context)
 	prefetch(hv_get_ring_buffer(rbi) + rbi->priv_read_index);
 
 	if (napi_schedule_prep(&nvchan->napi)) {
-		/* disable interupts from host */
+		/* disable interrupts from host */
 		hv_begin_read(rbi);
 
 		__napi_schedule_irqoff(&nvchan->napi);
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index 3637efeb27c6..5acbfe74b126 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -369,7 +369,7 @@ static u32 fill_pg_buf(struct page *page, u32 offset, u32 len,
 {
 	int j = 0;
 
-	/* Deal with compund pages by ignoring unused part
+	/* Deal with compound pages by ignoring unused part
 	 * of the page.
 	 */
 	page += (offset >> PAGE_SHIFT);
@@ -2091,7 +2091,7 @@ static int netvsc_register_vf(struct net_device *vf_netdev)
 	if (!netvsc_dev || rtnl_dereference(net_device_ctx->vf_netdev))
 		return NOTIFY_DONE;
 
-	/* if syntihetic interface is a different namespace,
+	/* if synthetic interface is a different namespace,
 	 * then move the VF to that namespace; join will be
 	 * done again in that context.
 	 */
@@ -2239,7 +2239,7 @@ static int netvsc_probe(struct hv_device *dev,
 	 * netvsc_probe() can't get rtnl lock and as a result vmbus_onoffer()
 	 * -> ... -> device_add() -> ... -> __device_attach() can't get
 	 * the device lock, so all the subchannels can't be processed --
-	 * finally netvsc_subchan_work() hangs for ever.
+	 * finally netvsc_subchan_work() hangs forever.
 	 */
 	rtnl_lock();
 
diff --git a/drivers/net/hyperv/rndis_filter.c b/drivers/net/hyperv/rndis_filter.c
index 53c6039bffb6..bbe08309a54e 100644
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@ -1117,7 +1117,7 @@ int rndis_set_subchannel(struct net_device *ndev,
 	wait_event(nvdev->subchan_open,
 		   atomic_read(&nvdev->open_chn) == nvdev->num_chn);
 
-	/* ignore failues from setting rss parameters, still have channels */
+	/* ignore failures from setting rss parameters, still have channels */
 	if (dev_info)
 		rndis_filter_set_rss_param(rdev, dev_info->rss_key);
 	else
