scsi: qla2xxx: Use mutex protection during qla2x00_sysfs_read_fw_dump()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Quinn Tran <quinn.tran@cavium.com>
commit a6b95d1c71e9adef5ab5ba77c42a50d0b7b409d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a6b95d1c.failed

Add mutex protection to prevent driver from freeing the FW dump buffer
while the extraction is in progress.

[mkp: commit desc]

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a6b95d1c71e9adef5ab5ba77c42a50d0b7b409d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 046c47b82245,61dddeee75a0..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -2994,35 -3234,53 +2994,56 @@@ allocate
  			    "Unable to allocate (%d KB) for firmware dump.\n",
  			    dump_size / 1024);
  		} else {
++<<<<<<< HEAD
 +			if (ha->fw_dump)
++=======
+ 			mutex_lock(&ha->optrom_mutex);
+ 			if (ha->fw_dumped) {
+ 				memcpy(fw_dump, ha->fw_dump, ha->fw_dump_len);
++>>>>>>> a6b95d1c71e9 (scsi: qla2xxx: Use mutex protection during qla2x00_sysfs_read_fw_dump())
  				vfree(ha->fw_dump);
 -				ha->fw_dump = fw_dump;
 -				ha->fw_dump_alloc_len =  dump_size;
 -				ql_dbg(ql_dbg_init, vha, 0x00c5,
 -				    "Re-Allocated (%d KB) and save firmware dump.\n",
 -				    dump_size / 1024);
 -			} else {
 -				if (ha->fw_dump)
 -					vfree(ha->fw_dump);
 -				ha->fw_dump = fw_dump;
 +			ha->fw_dump = fw_dump;
  
 -				ha->fw_dump_len = ha->fw_dump_alloc_len =
 -				    dump_size;
 -				ql_dbg(ql_dbg_init, vha, 0x00c5,
 -				    "Allocated (%d KB) for firmware dump.\n",
 -				    dump_size / 1024);
 +			ha->fw_dump_len = dump_size;
 +			ql_dbg(ql_dbg_init, vha, 0x00c5,
 +			    "Allocated (%d KB) for firmware dump.\n",
 +			    dump_size / 1024);
  
++<<<<<<< HEAD
 +			if (IS_QLA27XX(ha))
 +				return;
++=======
+ 				if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 					mutex_unlock(&ha->optrom_mutex);
+ 					return;
+ 				}
 -
 -				ha->fw_dump->signature[0] = 'Q';
 -				ha->fw_dump->signature[1] = 'L';
 -				ha->fw_dump->signature[2] = 'G';
 -				ha->fw_dump->signature[3] = 'C';
 -				ha->fw_dump->version = htonl(1);
 -
 -				ha->fw_dump->fixed_size = htonl(fixed_size);
 -				ha->fw_dump->mem_size = htonl(mem_size);
 -				ha->fw_dump->req_q_size = htonl(req_q_size);
 -				ha->fw_dump->rsp_q_size = htonl(rsp_q_size);
 -
 -				ha->fw_dump->eft_size = htonl(eft_size);
 -				ha->fw_dump->eft_addr_l =
 -				    htonl(LSD(ha->eft_dma));
 -				ha->fw_dump->eft_addr_h =
 -				    htonl(MSD(ha->eft_dma));
 -
++>>>>>>> a6b95d1c71e9 (scsi: qla2xxx: Use mutex protection during qla2x00_sysfs_read_fw_dump())
 +
 +			ha->fw_dump->signature[0] = 'Q';
 +			ha->fw_dump->signature[1] = 'L';
 +			ha->fw_dump->signature[2] = 'G';
 +			ha->fw_dump->signature[3] = 'C';
 +			ha->fw_dump->version = htonl(1);
 +
 +			ha->fw_dump->fixed_size = htonl(fixed_size);
 +			ha->fw_dump->mem_size = htonl(mem_size);
 +			ha->fw_dump->req_q_size = htonl(req_q_size);
 +			ha->fw_dump->rsp_q_size = htonl(rsp_q_size);
 +
 +			ha->fw_dump->eft_size = htonl(eft_size);
 +			ha->fw_dump->eft_addr_l = htonl(LSD(ha->eft_dma));
 +			ha->fw_dump->eft_addr_h = htonl(MSD(ha->eft_dma));
 +
++<<<<<<< HEAD
 +			ha->fw_dump->header_size =
 +				htonl(offsetof(struct qla2xxx_fw_dump, isp));
++=======
+ 				ha->fw_dump->header_size =
+ 					htonl(offsetof
+ 					    (struct qla2xxx_fw_dump, isp));
+ 			}
+ 			mutex_unlock(&ha->optrom_mutex);
++>>>>>>> a6b95d1c71e9 (scsi: qla2xxx: Use mutex protection during qla2x00_sysfs_read_fw_dump())
  		}
  	}
  }
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index 55925877df53..a409e8e0796c 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -29,24 +29,27 @@ qla2x00_sysfs_read_fw_dump(struct file *filp, struct kobject *kobj,
 	if (!(ha->fw_dump_reading || ha->mctp_dump_reading))
 		return 0;
 
+	mutex_lock(&ha->optrom_mutex);
 	if (IS_P3P_TYPE(ha)) {
 		if (off < ha->md_template_size) {
 			rval = memory_read_from_buffer(buf, count,
 			    &off, ha->md_tmplt_hdr, ha->md_template_size);
-			return rval;
+		} else {
+			off -= ha->md_template_size;
+			rval = memory_read_from_buffer(buf, count,
+			    &off, ha->md_dump, ha->md_dump_size);
 		}
-		off -= ha->md_template_size;
-		rval = memory_read_from_buffer(buf, count,
-		    &off, ha->md_dump, ha->md_dump_size);
-		return rval;
-	} else if (ha->mctp_dumped && ha->mctp_dump_reading)
-		return memory_read_from_buffer(buf, count, &off, ha->mctp_dump,
+	} else if (ha->mctp_dumped && ha->mctp_dump_reading) {
+		rval = memory_read_from_buffer(buf, count, &off, ha->mctp_dump,
 		    MCTP_DUMP_SIZE);
-	else if (ha->fw_dump_reading)
-		return memory_read_from_buffer(buf, count, &off, ha->fw_dump,
+	} else if (ha->fw_dump_reading) {
+		rval = memory_read_from_buffer(buf, count, &off, ha->fw_dump,
 					ha->fw_dump_len);
-	else
-		return 0;
+	} else {
+		rval = 0;
+	}
+	mutex_unlock(&ha->optrom_mutex);
+	return rval;
 }
 
 static ssize_t
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
