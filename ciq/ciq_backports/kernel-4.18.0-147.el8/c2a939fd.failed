RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit c2a939fda468bb5c4144a64fd2b9cbdad323bf68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c2a939fd.failed

This creates a consistent way to access the two core buffers across write
and write_ex handlers.

Remove the open coded ucore conversion in the write/ex compatibility
handlers.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit c2a939fda468bb5c4144a64fd2b9cbdad323bf68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_main.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,0dd69133096d..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -956,20 -887,15 +956,27 @@@ ssize_t ib_uverbs_create_comp_channel(s
  		return -EFAULT;
  	}
  
 -	return uobj_alloc_commit(uobj);
 +	uobj_alloc_commit(uobj);
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +static struct ib_ucq_object *create_cq(struct ib_uverbs_file *file,
 +					struct ib_device *ib_dev,
 +				       struct ib_udata *ucore,
 +				       struct ib_udata *uhw,
++=======
+ static struct ib_ucq_object *create_cq(struct uverbs_attr_bundle *attrs,
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  				       struct ib_uverbs_ex_create_cq *cmd,
  				       size_t cmd_sz,
 -				       int (*cb)(struct uverbs_attr_bundle *attrs,
 +				       int (*cb)(struct ib_uverbs_file *file,
  						 struct ib_ucq_object *obj,
  						 struct ib_uverbs_ex_create_cq_resp *resp,
++<<<<<<< HEAD
 +						 struct ib_udata *udata,
++=======
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  						 void *context),
  				       void *context)
  {
@@@ -1036,7 -960,7 +1043,11 @@@
  	cq->res.type = RDMA_RESTRACK_CQ;
  	rdma_restrack_add(&cq->res);
  
++<<<<<<< HEAD
 +	ret = cb(file, obj, &resp, ucore, context);
++=======
+ 	ret = cb(attrs, obj, &resp, context);
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	if (ret)
  		goto err_cb;
  
@@@ -1056,12 -982,12 +1067,12 @@@ err
  	return ERR_PTR(ret);
  }
  
 -static int ib_uverbs_create_cq_cb(struct uverbs_attr_bundle *attrs,
 +static int ib_uverbs_create_cq_cb(struct ib_uverbs_file *file,
  				  struct ib_ucq_object *obj,
  				  struct ib_uverbs_ex_create_cq_resp *resp,
- 				  struct ib_udata *ucore, void *context)
+ 				  void *context)
  {
- 	if (ib_copy_to_udata(ucore, &resp->base, sizeof(resp->base)))
+ 	if (ib_copy_to_udata(&attrs->ucore, &resp->base, sizeof(resp->base)))
  		return -EFAULT;
  
  	return 0;
@@@ -1074,48 -998,30 +1085,58 @@@ ssize_t ib_uverbs_create_cq(struct ib_u
  {
  	struct ib_uverbs_create_cq      cmd;
  	struct ib_uverbs_ex_create_cq	cmd_ex;
++<<<<<<< HEAD
 +	struct ib_uverbs_create_cq_resp resp;
 +	struct ib_udata                 ucore;
 +	struct ib_udata                 uhw;
++=======
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	struct ib_ucq_object           *obj;
  
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
 +
  	if (copy_from_user(&cmd, buf, sizeof(cmd)))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
 +			     sizeof(cmd), sizeof(resp));
 +
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
++=======
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
  	cmd_ex.cqe = cmd.cqe;
  	cmd_ex.comp_vector = cmd.comp_vector;
  	cmd_ex.comp_channel = cmd.comp_channel;
  
++<<<<<<< HEAD
 +	obj = create_cq(file, ib_dev, &ucore, &uhw, &cmd_ex,
++=======
+ 	obj = create_cq(attrs, &cmd_ex,
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  			offsetof(typeof(cmd_ex), comp_channel) +
 -				sizeof(cmd.comp_channel),
 -			ib_uverbs_create_cq_cb, NULL);
 -	return PTR_ERR_OR_ZERO(obj);
 +			sizeof(cmd.comp_channel), ib_uverbs_create_cq_cb,
 +			NULL);
 +
 +	if (IS_ERR(obj))
 +		return PTR_ERR(obj);
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_ex_create_cq_cb(struct uverbs_attr_bundle *attrs,
 +static int ib_uverbs_ex_create_cq_cb(struct ib_uverbs_file *file,
  				     struct ib_ucq_object *obj,
  				     struct ib_uverbs_ex_create_cq_resp *resp,
- 				     struct ib_udata *ucore, void *context)
+ 				     void *context)
  {
- 	if (ib_copy_to_udata(ucore, resp, resp->response_length))
+ 	if (ib_copy_to_udata(&attrs->ucore, resp, resp->response_length))
  		return -EFAULT;
  
  	return 0;
@@@ -1148,8 -1052,7 +1169,12 @@@ int ib_uverbs_ex_create_cq(struct ib_uv
  			     sizeof(resp.response_length)))
  		return -ENOSPC;
  
++<<<<<<< HEAD
 +	obj = create_cq(file, ib_dev, ucore, uhw, &cmd,
 +			min(ucore->inlen, sizeof(cmd)),
++=======
+ 	obj = create_cq(attrs, &cmd, min(ucore->inlen, sizeof(cmd)),
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  			ib_uverbs_ex_create_cq_cb, NULL);
  
  	return PTR_ERR_OR_ZERO(obj);
@@@ -1341,17 -1215,13 +1366,24 @@@ ssize_t ib_uverbs_destroy_cq(struct ib_
  	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
  		return -EFAULT;
  
 -	return 0;
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +static int create_qp(struct ib_uverbs_file *file,
 +		     struct ib_udata *ucore,
 +		     struct ib_udata *uhw,
 +		     struct ib_uverbs_ex_create_qp *cmd,
 +		     size_t cmd_sz,
 +		     int (*cb)(struct ib_uverbs_file *file,
 +			       struct ib_uverbs_ex_create_qp_resp *resp,
 +			       struct ib_udata *udata),
++=======
+ static int create_qp(struct uverbs_attr_bundle *attrs,
+ 		     struct ib_uverbs_ex_create_qp *cmd, size_t cmd_sz,
+ 		     int (*cb)(struct uverbs_attr_bundle *attrs,
+ 			       struct ib_uverbs_ex_create_qp_resp *resp),
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  		     void *context)
  {
  	struct ib_uqp_object		*obj;
@@@ -1573,7 -1446,7 +1605,11 @@@
  	resp.response_length = offsetof(typeof(resp), response_length) +
  			       sizeof(resp.response_length);
  
++<<<<<<< HEAD
 +	ret = cb(file, &resp, ucore);
++=======
+ 	ret = cb(attrs, &resp);
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	if (ret)
  		goto err_cb;
  
@@@ -1619,11 -1490,10 +1655,16 @@@ err_put
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_create_qp_cb(struct ib_uverbs_file *file,
 +				  struct ib_uverbs_ex_create_qp_resp *resp,
 +				  struct ib_udata *ucore)
++=======
+ static int ib_uverbs_create_qp_cb(struct uverbs_attr_bundle *attrs,
+ 				  struct ib_uverbs_ex_create_qp_resp *resp)
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  {
- 	if (ib_copy_to_udata(ucore, &resp->base, sizeof(resp->base)))
+ 	if (ib_copy_to_udata(&attrs->ucore, &resp->base, sizeof(resp->base)))
  		return -EFAULT;
  
  	return 0;
@@@ -1636,24 -1504,11 +1677,30 @@@ ssize_t ib_uverbs_create_qp(struct ib_u
  {
  	struct ib_uverbs_create_qp      cmd;
  	struct ib_uverbs_ex_create_qp	cmd_ex;
++<<<<<<< HEAD
 +	struct ib_udata			ucore;
 +	struct ib_udata			uhw;
 +	ssize_t resp_size = sizeof(struct ib_uverbs_create_qp_resp);
++=======
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	int				err;
  
 +	if (out_len < resp_size)
 +		return -ENOSPC;
 +
  	if (copy_from_user(&cmd, buf, sizeof(cmd)))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
 +		   sizeof(cmd), resp_size);
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + resp_size,
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - resp_size);
 +
++=======
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
  	cmd_ex.pd_handle = cmd.pd_handle;
@@@ -1669,22 -1524,20 +1716,33 @@@
  	cmd_ex.qp_type = cmd.qp_type;
  	cmd_ex.is_srq = cmd.is_srq;
  
++<<<<<<< HEAD
 +	err = create_qp(file, &ucore, &uhw, &cmd_ex,
 +			offsetof(typeof(cmd_ex), is_srq) +
 +			sizeof(cmd.is_srq), ib_uverbs_create_qp_cb,
 +			NULL);
++=======
+ 	err = create_qp(attrs, &cmd_ex,
+ 			offsetof(typeof(cmd_ex), is_srq) + sizeof(cmd.is_srq),
+ 			ib_uverbs_create_qp_cb, NULL);
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  
  	if (err)
  		return err;
  
 -	return 0;
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_ex_create_qp_cb(struct ib_uverbs_file *file,
 +				     struct ib_uverbs_ex_create_qp_resp *resp,
 +				     struct ib_udata *ucore)
++=======
+ static int ib_uverbs_ex_create_qp_cb(struct uverbs_attr_bundle *attrs,
+ 				     struct ib_uverbs_ex_create_qp_resp *resp)
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  {
- 	if (ib_copy_to_udata(ucore, resp, resp->response_length))
+ 	if (ib_copy_to_udata(&attrs->ucore, resp, resp->response_length))
  		return -EFAULT;
  
  	return 0;
@@@ -1717,7 -1568,7 +1775,11 @@@ int ib_uverbs_ex_create_qp(struct ib_uv
  			     sizeof(resp.response_length)))
  		return -ENOSPC;
  
++<<<<<<< HEAD
 +	err = create_qp(file, ucore, uhw, &cmd,
++=======
+ 	err = create_qp(attrs, &cmd,
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  			min(ucore->inlen, sizeof(cmd)),
  			ib_uverbs_ex_create_qp_cb, NULL);
  
diff --cc drivers/infiniband/core/uverbs_main.c
index 495189811c27,762a6acbff80..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -773,33 -691,75 +773,97 @@@ static ssize_t ib_uverbs_write(struct f
  
  	buf += sizeof(hdr);
  
++<<<<<<< HEAD
 +	if (!extended) {
 +		ret = uverbs_cmd_table[command](file, ib_dev, buf,
 +						hdr.in_words * 4,
 +						hdr.out_words * 4);
 +	} else {
 +		struct ib_udata ucore;
 +		struct ib_udata uhw;
 +
++=======
+ 	bundle.ufile = file;
+ 	if (!method_elm->is_ex) {
+ 		size_t in_len = hdr.in_words * 4 - sizeof(hdr);
+ 		size_t out_len = hdr.out_words * 4;
+ 		u64 response = 0;
+ 
+ 		if (method_elm->has_udata) {
+ 			bundle.driver_udata.inlen =
+ 				in_len - method_elm->req_size;
+ 			in_len = method_elm->req_size;
+ 			if (bundle.driver_udata.inlen)
+ 				bundle.driver_udata.inbuf = buf + in_len;
+ 			else
+ 				bundle.driver_udata.inbuf = NULL;
+ 		} else {
+ 			memset(&bundle.driver_udata, 0,
+ 			       sizeof(bundle.driver_udata));
+ 		}
+ 
+ 		if (method_elm->has_resp) {
+ 			/*
+ 			 * The macros check that if has_resp is set
+ 			 * then the command request structure starts
+ 			 * with a '__aligned u64 response' member.
+ 			 */
+ 			ret = get_user(response, (const u64 *)buf);
+ 			if (ret)
+ 				goto out_unlock;
+ 
+ 			if (method_elm->has_udata) {
+ 				bundle.driver_udata.outlen =
+ 					out_len - method_elm->resp_size;
+ 				out_len = method_elm->resp_size;
+ 				if (bundle.driver_udata.outlen)
+ 					bundle.driver_udata.outbuf =
+ 						u64_to_user_ptr(response +
+ 								out_len);
+ 				else
+ 					bundle.driver_udata.outbuf = NULL;
+ 			}
+ 		} else {
+ 			bundle.driver_udata.outlen = 0;
+ 			bundle.driver_udata.outbuf = NULL;
+ 		}
+ 
+ 		ib_uverbs_init_udata_buf_or_null(
+ 			&bundle.ucore, buf, u64_to_user_ptr(response),
+ 			in_len, out_len);
+ 
+ 		ret = method_elm->handler(&bundle, buf, in_len, out_len);
+ 	} else {
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  		buf += sizeof(ex_hdr);
  
- 		ib_uverbs_init_udata_buf_or_null(&ucore, buf,
+ 		ib_uverbs_init_udata_buf_or_null(&bundle.ucore, buf,
  					u64_to_user_ptr(ex_hdr.response),
  					hdr.in_words * 8, hdr.out_words * 8);
  
++<<<<<<< HEAD
 +		ib_uverbs_init_udata_buf_or_null(&uhw,
 +					buf + ucore.inlen,
 +					u64_to_user_ptr(ex_hdr.response) + ucore.outlen,
 +					ex_hdr.provider_in_words * 8,
 +					ex_hdr.provider_out_words * 8);
 +
 +		ret = uverbs_ex_cmd_table[command](file, ib_dev, &ucore, &uhw);
 +		ret = (ret) ? : count;
++=======
+ 		ib_uverbs_init_udata_buf_or_null(
+ 			&bundle.driver_udata, buf + bundle.ucore.inlen,
+ 			u64_to_user_ptr(ex_hdr.response) + bundle.ucore.outlen,
+ 			ex_hdr.provider_in_words * 8,
+ 			ex_hdr.provider_out_words * 8);
+ 
+ 		ret = method_elm->handler_ex(&bundle, &bundle.ucore);
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  	}
  
 -out_unlock:
 +out:
  	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 -	return (ret) ? : count;
 +	return ret;
  }
  
  static int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,9486a525afc1..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -359,28 -644,15 +359,37 @@@ struct uverbs_attr 
  	};
  };
  
++<<<<<<< HEAD
 +struct uverbs_attr_bundle_hash {
 +	/* if bit i is set, it means attrs[i] contains valid information */
 +	unsigned long *valid_bitmap;
 +	size_t num_attrs;
 +	/*
 +	 * arrays of attributes, each element corresponds to the specification
 +	 * of the attribute in the same index.
 +	 */
 +	struct uverbs_attr *attrs;
++=======
+ struct uverbs_attr_bundle {
+ 	struct ib_udata driver_udata;
+ 	struct ib_udata ucore;
+ 	struct ib_uverbs_file *ufile;
+ 	DECLARE_BITMAP(attr_present, UVERBS_API_ATTR_BKEY_LEN);
+ 	struct uverbs_attr attrs[];
++>>>>>>> c2a939fda468 (RDMA/uverbs: Use uverbs_attr_bundle to pass ucore for write/write_ex)
  };
  
 +struct uverbs_attr_bundle {
 +	size_t				num_buckets;
 +	struct uverbs_attr_bundle_hash  hash[];
 +};
 +
 +static inline bool uverbs_attr_is_valid_in_hash(const struct uverbs_attr_bundle_hash *attrs_hash,
 +						unsigned int idx)
 +{
 +	return test_bit(idx, attrs_hash->valid_bitmap);
 +}
 +
  static inline bool uverbs_attr_is_valid(const struct uverbs_attr_bundle *attrs_bundle,
  					unsigned int idx)
  {
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_main.c
* Unmerged path include/rdma/uverbs_ioctl.h
