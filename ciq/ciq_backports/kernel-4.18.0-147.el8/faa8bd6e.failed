libnvdimm/security: Fix nvdimm_security_state() state request selection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit faa8bd6e12e6aeea289d8e6ba74777b72a69434c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/faa8bd6e.failed

The input parameter should be enum nvdimm_passphrase_type instead of bool
for selection of master/user for selection of extended master passphrase
state or the regular user passphrase state.

Fixes: 89fa9d8ea7bdf ("...add Intel DSM 1.8 master passphrase support")
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit faa8bd6e12e6aeea289d8e6ba74777b72a69434c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/nd-core.h
diff --cc drivers/nvdimm/nd-core.h
index a5977b369651,e5ffd5733540..000000000000
--- a/drivers/nvdimm/nd-core.h
+++ b/drivers/nvdimm/nd-core.h
@@@ -42,8 -43,63 +42,58 @@@ struct nvdimm 
  	int id, num_flush;
  	struct resource *flush_wpq;
  	const char *dimm_id;
 -	struct {
 -		const struct nvdimm_security_ops *ops;
 -		enum nvdimm_security_state state;
 -		enum nvdimm_security_state ext_state;
 -		unsigned int overwrite_tmo;
 -		struct kernfs_node *overwrite_state;
 -	} sec;
 -	struct delayed_work dwork;
  };
  
++<<<<<<< HEAD
++=======
+ static inline enum nvdimm_security_state nvdimm_security_state(
+ 		struct nvdimm *nvdimm, enum nvdimm_passphrase_type ptype)
+ {
+ 	if (!nvdimm->sec.ops)
+ 		return -ENXIO;
+ 
+ 	return nvdimm->sec.ops->state(nvdimm, ptype);
+ }
+ int nvdimm_security_freeze(struct nvdimm *nvdimm);
+ #if IS_ENABLED(CONFIG_NVDIMM_KEYS)
+ int nvdimm_security_disable(struct nvdimm *nvdimm, unsigned int keyid);
+ int nvdimm_security_update(struct nvdimm *nvdimm, unsigned int keyid,
+ 		unsigned int new_keyid,
+ 		enum nvdimm_passphrase_type pass_type);
+ int nvdimm_security_erase(struct nvdimm *nvdimm, unsigned int keyid,
+ 		enum nvdimm_passphrase_type pass_type);
+ int nvdimm_security_overwrite(struct nvdimm *nvdimm, unsigned int keyid);
+ void nvdimm_security_overwrite_query(struct work_struct *work);
+ #else
+ static inline int nvdimm_security_disable(struct nvdimm *nvdimm,
+ 		unsigned int keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int nvdimm_security_update(struct nvdimm *nvdimm,
+ 		unsigned int keyid,
+ 		unsigned int new_keyid,
+ 		enum nvdimm_passphrase_type pass_type)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int nvdimm_security_erase(struct nvdimm *nvdimm,
+ 		unsigned int keyid,
+ 		enum nvdimm_passphrase_type pass_type)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int nvdimm_security_overwrite(struct nvdimm *nvdimm,
+ 		unsigned int keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline void nvdimm_security_overwrite_query(struct work_struct *work)
+ {
+ }
+ #endif
+ 
++>>>>>>> faa8bd6e12e6 (libnvdimm/security: Fix nvdimm_security_state() state request selection)
  /**
   * struct blk_alloc_info - tracking info for BLK dpa scanning
   * @nd_mapping: blk region mapping boundaries
* Unmerged path drivers/nvdimm/nd-core.h
