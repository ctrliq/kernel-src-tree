RDMA/uverbs: Use uverbs_request() and core for write_ex handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 29a29d18523235e749916a0154435f26f3238639
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/29a29d18.failed

The write_ex handlers have this horrible boilerplate in every function to
do the zero extend/zero check and min size checks. This is now handled in
the core code via the meta-data, and the zero checks are handled by
uverbs_request(). Replace all the occurrences.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 29a29d18523235e749916a0154435f26f3238639)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,7f8b0a7dcb17..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -47,12 -47,76 +47,80 @@@
  #include "uverbs.h"
  #include "core_priv.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * Copy a response to userspace. If the provided 'resp' is larger than the
+  * user buffer it is silently truncated. If the user provided a larger buffer
+  * then the trailing portion is zero filled.
+  *
+  * These semantics are intended to support future extension of the output
+  * structures.
+  */
+ static int uverbs_response(struct uverbs_attr_bundle *attrs, const void *resp,
+ 			   size_t resp_len)
+ {
+ 	u8 __user *cur = attrs->ucore.outbuf + resp_len;
+ 	u8 __user *end = attrs->ucore.outbuf + attrs->ucore.outlen;
+ 	int ret;
+ 
+ 	if (copy_to_user(attrs->ucore.outbuf, resp,
+ 			 min(attrs->ucore.outlen, resp_len)))
+ 		return -EFAULT;
+ 
+ 	/* Zero fill any extra memory that user space might have provided */
+ 	for (; cur < end; cur++) {
+ 		ret = put_user(0, cur);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy a request from userspace. If the provided 'req' is larger than the
+  * user buffer then the user buffer is zero extended into the 'req'. If 'req'
+  * is smaller than the user buffer then the uncopied bytes in the user buffer
+  * must be zero.
+  */
+ static int uverbs_request(struct uverbs_attr_bundle *attrs, void *req,
+ 			  size_t req_len)
+ {
+ 	if (copy_from_user(req, attrs->ucore.inbuf,
+ 			   min(attrs->ucore.inlen, req_len)))
+ 		return -EFAULT;
+ 
+ 	if (attrs->ucore.inlen < req_len) {
+ 		memset(req + attrs->ucore.inlen, 0,
+ 		       req_len - attrs->ucore.inlen);
+ 	} else if (attrs->ucore.inlen > req_len) {
+ 		if (!ib_is_buffer_cleared(attrs->ucore.inbuf + req_len,
+ 					  attrs->ucore.inlen - req_len))
+ 			return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Generate the value for the 'response_length' protocol used by write_ex.
+  * This is the number of bytes the kernel actually wrote. Userspace can use
+  * this to detect what structure members in the response the kernel
+  * understood.
+  */
+ static u32 uverbs_response_length(struct uverbs_attr_bundle *attrs,
+ 				  size_t resp_len)
+ {
+ 	return min_t(size_t, attrs->ucore.outlen, resp_len);
+ }
+ 
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  static struct ib_uverbs_completion_event_file *
 -_ib_uverbs_lookup_comp_file(s32 fd, const struct uverbs_attr_bundle *attrs)
 +ib_uverbs_lookup_comp_file(int fd, struct ib_ucontext *context)
  {
 -	struct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 -					       fd, attrs);
 +	struct ib_uobject *uobj = uobj_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 +						fd, context);
 +	struct ib_uobject_file *uobj_file;
  
  	if (IS_ERR(uobj))
  		return (void *)uobj;
@@@ -1029,9 -1019,7 +1097,13 @@@ static struct ib_ucq_object *create_cq(
  	memset(&resp, 0, sizeof resp);
  	resp.base.cq_handle = obj->uobject.id;
  	resp.base.cqe       = cq->cqe;
++<<<<<<< HEAD
 +
 +	resp.response_length = offsetof(typeof(resp), response_length) +
 +		sizeof(resp.response_length);
++=======
+ 	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  
  	cq->res.type = RDMA_RESTRACK_CQ;
  	rdma_restrack_add(&cq->res);
@@@ -1099,44 -1064,22 +1171,40 @@@ ssize_t ib_uverbs_create_cq(struct ib_u
  	cmd_ex.comp_vector = cmd.comp_vector;
  	cmd_ex.comp_channel = cmd.comp_channel;
  
 -	obj = create_cq(attrs, &cmd_ex,
 +	obj = create_cq(file, ib_dev, &ucore, &uhw, &cmd_ex,
  			offsetof(typeof(cmd_ex), comp_channel) +
 -				sizeof(cmd.comp_channel));
 -	return PTR_ERR_OR_ZERO(obj);
 +			sizeof(cmd.comp_channel), ib_uverbs_create_cq_cb,
 +			NULL);
 +
 +	if (IS_ERR(obj))
 +		return PTR_ERR(obj);
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_ex_create_cq(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +static int ib_uverbs_ex_create_cq_cb(struct ib_uverbs_file *file,
 +				     struct ib_ucq_object *obj,
 +				     struct ib_uverbs_ex_create_cq_resp *resp,
 +				     struct ib_udata *ucore, void *context)
 +{
 +	if (ib_copy_to_udata(ucore, resp, resp->response_length))
 +		return -EFAULT;
 +
 +	return 0;
 +}
 +
 +int ib_uverbs_ex_create_cq(struct ib_uverbs_file *file,
 +			 struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_create_cq_resp resp;
  	struct ib_uverbs_ex_create_cq  cmd;
  	struct ib_ucq_object           *obj;
- 	int err;
- 
- 	if (ucore->inlen < sizeof(cmd))
- 		return -EINVAL;
+ 	int ret;
  
- 	err = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));
- 	if (err)
- 		return err;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	if (cmd.comp_mask)
  		return -EINVAL;
@@@ -1144,14 -1087,7 +1212,18 @@@
  	if (cmd.reserved)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (ucore->outlen < (offsetof(typeof(resp), response_length) +
 +			     sizeof(resp.response_length)))
 +		return -ENOSPC;
 +
 +	obj = create_cq(file, ib_dev, ucore, uhw, &cmd,
 +			min(ucore->inlen, sizeof(cmd)),
 +			ib_uverbs_ex_create_cq_cb, NULL);
 +
++=======
+ 	obj = create_cq(attrs, &cmd, min(ucore->inlen, sizeof(cmd)));
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  	return PTR_ERR_OR_ZERO(obj);
  }
  
@@@ -1394,13 -1296,6 +1466,16 @@@ static int create_qp(struct ib_uverbs_f
  		attr.rwq_ind_tbl = ind_tbl;
  	}
  
++<<<<<<< HEAD
 +	if (cmd_sz > sizeof(*cmd) &&
 +	    !ib_is_udata_cleared(ucore, sizeof(*cmd),
 +				 cmd_sz - sizeof(*cmd))) {
 +		ret = -EOPNOTSUPP;
 +		goto err_put;
 +	}
 +
++=======
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  	if (ind_tbl && (cmd->max_recv_wr || cmd->max_recv_sge || cmd->is_srq)) {
  		ret = -EINVAL;
  		goto err_put;
@@@ -1569,11 -1466,9 +1644,15 @@@
  	resp.base.max_recv_wr     = attr.cap.max_recv_wr;
  	resp.base.max_send_wr     = attr.cap.max_send_wr;
  	resp.base.max_inline_data = attr.cap.max_inline_data;
++<<<<<<< HEAD
++=======
+ 	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  
 -	ret = uverbs_response(attrs, &resp, sizeof(resp));
 +	resp.response_length = offsetof(typeof(resp), response_length) +
 +			       sizeof(resp.response_length);
 +
 +	ret = cb(file, &resp, ucore);
  	if (ret)
  		goto err_cb;
  
@@@ -1669,43 -1538,19 +1748,38 @@@ ssize_t ib_uverbs_create_qp(struct ib_u
  	cmd_ex.qp_type = cmd.qp_type;
  	cmd_ex.is_srq = cmd.is_srq;
  
 -	return create_qp(attrs, &cmd_ex,
 -			 offsetof(typeof(cmd_ex), is_srq) + sizeof(cmd.is_srq));
 +	err = create_qp(file, &ucore, &uhw, &cmd_ex,
 +			offsetof(typeof(cmd_ex), is_srq) +
 +			sizeof(cmd.is_srq), ib_uverbs_create_qp_cb,
 +			NULL);
 +
 +	if (err)
 +		return err;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_ex_create_qp(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +static int ib_uverbs_ex_create_qp_cb(struct ib_uverbs_file *file,
 +				     struct ib_uverbs_ex_create_qp_resp *resp,
 +				     struct ib_udata *ucore)
 +{
 +	if (ib_copy_to_udata(ucore, resp, resp->response_length))
 +		return -EFAULT;
 +
 +	return 0;
 +}
 +
 +int ib_uverbs_ex_create_qp(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_create_qp_resp resp;
- 	struct ib_uverbs_ex_create_qp cmd = {0};
- 	int err;
- 
- 	if (ucore->inlen < (offsetof(typeof(cmd), comp_mask) +
- 			    sizeof(cmd.comp_mask)))
- 		return -EINVAL;
+ 	struct ib_uverbs_ex_create_qp cmd;
+ 	int ret;
  
- 	err = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
- 	if (err)
- 		return err;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	if (cmd.comp_mask & ~IB_UVERBS_CREATE_QP_SUP_COMP_MASK)
  		return -EINVAL;
@@@ -1713,23 -1558,11 +1787,27 @@@
  	if (cmd.reserved)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (ucore->outlen < (offsetof(typeof(resp), response_length) +
 +			     sizeof(resp.response_length)))
 +		return -ENOSPC;
 +
 +	err = create_qp(file, ucore, uhw, &cmd,
 +			min(ucore->inlen, sizeof(cmd)),
 +			ib_uverbs_ex_create_qp_cb, NULL);
 +
 +	if (err)
 +		return err;
 +
 +	return 0;
++=======
+ 	return create_qp(attrs, &cmd, min(ucore->inlen, sizeof(cmd)));
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  }
  
 -static int ib_uverbs_open_qp(struct uverbs_attr_bundle *attrs,
 -			     const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_open_qp(struct ib_uverbs_file *file,
 +			  struct ib_device *ib_dev,
 +			  const char __user *buf, int in_len, int out_len)
  {
  	struct ib_uverbs_open_qp        cmd;
  	struct ib_uverbs_create_qp_resp resp;
@@@ -2112,41 -1932,33 +2190,49 @@@ out
  	return ret;
  }
  
 -static int ib_uverbs_modify_qp(struct uverbs_attr_bundle *attrs,
 -			       const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
  {
++<<<<<<< HEAD
 +	struct ib_uverbs_ex_modify_qp cmd = {};
 +	struct ib_udata udata;
++=======
+ 	struct ib_uverbs_ex_modify_qp cmd;
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  	int ret;
  
 -	ret = uverbs_request(attrs, &cmd.base, sizeof(cmd.base));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd.base, buf, sizeof(cmd.base)))
 +		return -EFAULT;
  
  	if (cmd.base.attr_mask &
  	    ~((IB_USER_LEGACY_LAST_QP_ATTR_MASK << 1) - 1))
  		return -EOPNOTSUPP;
  
 -	return modify_qp(attrs, &cmd);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd.base), NULL,
 +		   in_len - sizeof(cmd.base) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len);
 +
 +	ret = modify_qp(file, &cmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_ex_modify_qp(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_modify_qp(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_modify_qp cmd = {};
+ 	struct ib_uverbs_ex_modify_qp cmd;
  	int ret;
  
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
+ 
  	/*
  	 * Last bit is reserved for extending the attr_mask by
  	 * using another field.
@@@ -2164,21 -1969,11 +2243,25 @@@
  	    ~((IB_USER_LAST_QP_ATTR_MASK << 1) - 1))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (ucore->inlen > sizeof(cmd)) {
 +		if (!ib_is_udata_cleared(ucore, sizeof(cmd),
 +					 ucore->inlen - sizeof(cmd)))
 +			return -EOPNOTSUPP;
 +	}
 +
 +	ret = modify_qp(file, &cmd, uhw);
 +
 +	return ret;
++=======
+ 	return modify_qp(attrs, &cmd);
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  }
  
 -static int ib_uverbs_destroy_qp(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_destroy_qp(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_destroy_qp      cmd;
  	struct ib_uverbs_destroy_qp_resp resp;
@@@ -3128,12 -2895,10 +3211,12 @@@ static int kern_spec_to_ib_spec(struct 
  		return kern_spec_to_ib_spec_filter(kern_spec, ib_spec);
  }
  
 -static int ib_uverbs_ex_create_wq(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_create_wq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_create_wq	  cmd = {};
+ 	struct ib_uverbs_ex_create_wq cmd;
  	struct ib_uverbs_ex_create_wq_resp resp = {};
  	struct ib_uwq_object           *obj;
  	int err = 0;
@@@ -3141,24 -2906,9 +3224,14 @@@
  	struct ib_pd *pd;
  	struct ib_wq *wq;
  	struct ib_wq_init_attr wq_init_attr = {};
++<<<<<<< HEAD
 +	size_t required_cmd_sz;
 +	size_t required_resp_len;
++=======
+ 	struct ib_device *ib_dev;
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  
- 	required_cmd_sz = offsetof(typeof(cmd), max_sge) + sizeof(cmd.max_sge);
- 	required_resp_len = offsetof(typeof(resp), wqn) + sizeof(resp.wqn);
- 
- 	if (ucore->inlen < required_cmd_sz)
- 		return -EINVAL;
- 
- 	if (ucore->outlen < required_resp_len)
- 		return -ENOSPC;
- 
- 	if (ucore->inlen > sizeof(cmd) &&
- 	    !ib_is_udata_cleared(ucore, sizeof(cmd),
- 				 ucore->inlen - sizeof(cmd)))
- 		return -EOPNOTSUPP;
- 
- 	err = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
+ 	err = uverbs_request(attrs, &cmd, sizeof(cmd));
  	if (err)
  		return err;
  
@@@ -3185,12 -2935,10 +3258,10 @@@
  	wq_init_attr.cq = cq;
  	wq_init_attr.max_sge = cmd.max_sge;
  	wq_init_attr.max_wr = cmd.max_wr;
 -	wq_init_attr.wq_context = attrs->ufile;
 +	wq_init_attr.wq_context = file;
  	wq_init_attr.wq_type = cmd.wq_type;
  	wq_init_attr.event_handler = ib_uverbs_wq_event_handler;
- 	if (ucore->inlen >= (offsetof(typeof(cmd), create_flags) +
- 			     sizeof(cmd.create_flags)))
- 		wq_init_attr.create_flags = cmd.create_flags;
+ 	wq_init_attr.create_flags = cmd.create_flags;
  	obj->uevent.events_reported = 0;
  	INIT_LIST_HEAD(&obj->uevent.event_list);
  
@@@ -3222,9 -2966,8 +3293,14 @@@
  	resp.max_sge = wq_init_attr.max_sge;
  	resp.max_wr = wq_init_attr.max_wr;
  	resp.wqn = wq->wq_num;
++<<<<<<< HEAD
 +	resp.response_length = required_resp_len;
 +	err = ib_copy_to_udata(ucore,
 +			       &resp, resp.response_length);
++=======
+ 	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
+ 	err = uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  	if (err)
  		goto err_copy;
  
@@@ -3245,12 -2987,10 +3321,12 @@@ err_uobj
  	return err;
  }
  
 -static int ib_uverbs_ex_destroy_wq(struct uverbs_attr_bundle *attrs,
 -				   struct ib_udata *ucore)
 +int ib_uverbs_ex_destroy_wq(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    struct ib_udata *ucore,
 +			    struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_destroy_wq	cmd = {};
+ 	struct ib_uverbs_ex_destroy_wq	cmd;
  	struct ib_uverbs_ex_destroy_wq_resp	resp = {};
  	struct ib_uobject		*uobj;
  	struct ib_uwq_object		*obj;
@@@ -3279,49 -3003,28 +3339,44 @@@
  	if (cmd.comp_mask)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	resp.response_length = required_resp_len;
 +	uobj  = uobj_get_write(UVERBS_OBJECT_WQ, cmd.wq_handle,
 +			       file->ucontext);
++=======
+ 	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
+ 	uobj = uobj_get_destroy(UVERBS_OBJECT_WQ, cmd.wq_handle, attrs);
++>>>>>>> 29a29d185232 (RDMA/uverbs: Use uverbs_request() and core for write_ex handlers)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
  	obj = container_of(uobj, struct ib_uwq_object, uevent.uobject);
 -	resp.events_reported = obj->uevent.events_reported;
 +	/*
 +	 * Make sure we don't free the memory in remove_commit as we still
 +	 * needs the uobject memory to create the response.
 +	 */
 +	uverbs_uobject_get(uobj);
  
 -	uobj_put_destroy(uobj);
 +	ret = uobj_remove_commit(uobj);
 +	resp.events_reported = obj->uevent.events_reported;
 +	uverbs_uobject_put(uobj);
 +	if (ret)
 +		return ret;
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	return ib_copy_to_udata(ucore, &resp, resp.response_length);
  }
  
 -static int ib_uverbs_ex_modify_wq(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_modify_wq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_modify_wq cmd = {};
+ 	struct ib_uverbs_ex_modify_wq cmd;
  	struct ib_wq *wq;
  	struct ib_wq_attr wq_attr = {};
- 	size_t required_cmd_sz;
  	int ret;
  
- 	required_cmd_sz = offsetof(typeof(cmd), curr_wq_state) + sizeof(cmd.curr_wq_state);
- 	if (ucore->inlen < required_cmd_sz)
- 		return -EINVAL;
- 
- 	if (ucore->inlen > sizeof(cmd) &&
- 	    !ib_is_udata_cleared(ucore, sizeof(cmd),
- 				 ucore->inlen - sizeof(cmd)))
- 		return -EOPNOTSUPP;
- 
- 	ret = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
  	if (ret)
  		return ret;
  
@@@ -3467,10 -3162,9 +3522,10 @@@ int ib_uverbs_ex_create_rwq_ind_table(s
  
  	resp.ind_tbl_handle = uobj->id;
  	resp.ind_tbl_num = rwq_ind_tbl->ind_tbl_num;
- 	resp.response_length = required_resp_len;
+ 	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
  
 -	err = uverbs_response(attrs, &resp, sizeof(resp));
 +	err = ib_copy_to_udata(ucore,
 +			       &resp, resp.response_length);
  	if (err)
  		goto err_copy;
  
@@@ -3495,26 -3188,13 +3550,15 @@@ err_free
  	return err;
  }
  
 -static int ib_uverbs_ex_destroy_rwq_ind_table(struct uverbs_attr_bundle *attrs,
 -					      struct ib_udata *ucore)
 +int ib_uverbs_ex_destroy_rwq_ind_table(struct ib_uverbs_file *file,
 +				       struct ib_device *ib_dev,
 +				       struct ib_udata *ucore,
 +				       struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_destroy_rwq_ind_table	cmd = {};
- 	int			ret;
- 	size_t required_cmd_sz;
- 
- 	required_cmd_sz = offsetof(typeof(cmd), ind_tbl_handle) + sizeof(cmd.ind_tbl_handle);
- 
- 	if (ucore->inlen < required_cmd_sz)
- 		return -EINVAL;
- 
- 	if (ucore->inlen > sizeof(cmd) &&
- 	    !ib_is_udata_cleared(ucore, sizeof(cmd),
- 				 ucore->inlen - sizeof(cmd)))
- 		return -EOPNOTSUPP;
+ 	struct ib_uverbs_ex_destroy_rwq_ind_table cmd;
+ 	int ret;
  
- 	ret = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
  	if (ret)
  		return ret;
  
@@@ -4159,32 -3769,17 +4200,20 @@@ int ib_uverbs_ex_query_device(struct ib
  	resp.max_dm_size = attr.max_dm_size;
  	resp.response_length += sizeof(resp.max_dm_size);
  end:
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	err = ib_copy_to_udata(ucore, &resp, resp.response_length);
 +	return err;
  }
  
 -static int ib_uverbs_ex_modify_cq(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_modify_cq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_modify_cq cmd = {};
+ 	struct ib_uverbs_ex_modify_cq cmd;
  	struct ib_cq *cq;
- 	size_t required_cmd_sz;
  	int ret;
  
- 	required_cmd_sz = offsetof(typeof(cmd), reserved) +
- 				sizeof(cmd.reserved);
- 	if (ucore->inlen < required_cmd_sz)
- 		return -EINVAL;
- 
- 	/* sanity checks */
- 	if (ucore->inlen > sizeof(cmd) &&
- 	    !ib_is_udata_cleared(ucore, sizeof(cmd),
- 				 ucore->inlen - sizeof(cmd)))
- 		return -EOPNOTSUPP;
- 
- 	ret = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
  	if (ret)
  		return ret;
  
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
