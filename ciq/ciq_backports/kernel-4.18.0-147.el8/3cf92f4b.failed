scsi: qla2xxx: cleanup trace buffer initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin Wilck <mwilck@suse.com>
commit 3cf92f4bfccbb3e378cd86dc46e09c2bc18cda26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3cf92f4b.failed

Avoid code duplication between qla2x00_alloc_offload_mem() and
qla2x00_alloc_fw_dump() by moving the FCE and EFT buffer allocation and
initialization to separate functions. Cleanly track failure and success by
making sure that the ha->eft, ha->fce and respective eft_dma, fce_dma
members are set if and only if the buffers are properly allocated and
initialized. Avoid pointless buffer reallocation.  Eliminate some goto
statements. Make sure the fce_enabled flag is cleared when the FCE buffer
is freed.

Fixes: ad0a0b01f088 ("scsi: qla2xxx: Fix Firmware dump size for Extended login and Exchange Offload")
Fixes: a28d9e4ef997 ("scsi: qla2xxx: Add support for multiple fwdump templates/segments")
	Cc: Joe Carnuccio <joe.carnuccio@cavium.com>
	Cc: Quinn Tran <qutran@marvell.com>
	Cc: Himanshu Madhani <hmadhani@marvell.com>
	Cc: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin Wilck <mwilck@suse.com>
	Tested-by: Himanshu Madhani <hmadhani@marvell.com>
	Reviewed-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3cf92f4bfccbb3e378cd86dc46e09c2bc18cda26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index d06269226348,4a89ec58fb41..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -2832,75 -3098,36 +2884,104 @@@ qla2x00_init_eft_trace(scsi_qla_host_t 
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (IS_FWI2_CAPABLE(ha)) {
 +		/* Allocate memory for Fibre Channel Event Buffer. */
 +		if (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&
 +		    !IS_QLA27XX(ha))
 +			goto try_eft;
 +
 +		if (ha->fce)
 +			dma_free_coherent(&ha->pdev->dev,
 +			    FCE_SIZE, ha->fce, ha->fce_dma);
 +
 +		/* Allocate memory for Fibre Channel Event Buffer. */
 +		tc = dma_zalloc_coherent(&ha->pdev->dev, FCE_SIZE, &tc_dma,
 +					 GFP_KERNEL);
 +		if (!tc) {
 +			ql_log(ql_log_warn, vha, 0x00be,
 +			    "Unable to allocate (%d KB) for FCE.\n",
 +			    FCE_SIZE / 1024);
 +			goto try_eft;
 +		}
 +
 +		rval = qla2x00_enable_fce_trace(vha, tc_dma, FCE_NUM_BUFFERS,
 +		    ha->fce_mb, &ha->fce_bufs);
 +		if (rval) {
 +			ql_log(ql_log_warn, vha, 0x00bf,
 +			    "Unable to initialize FCE (%d).\n", rval);
 +			dma_free_coherent(&ha->pdev->dev, FCE_SIZE, tc,
 +			    tc_dma);
 +			ha->flags.fce_enabled = 0;
 +			goto try_eft;
 +		}
 +		ql_dbg(ql_dbg_init, vha, 0x00c0,
 +		    "Allocate (%d KB) for FCE...\n", FCE_SIZE / 1024);
 +
 +		ha->flags.fce_enabled = 1;
 +		ha->fce_dma = tc_dma;
 +		ha->fce = tc;
 +
 +try_eft:
 +		if (ha->eft)
 +			dma_free_coherent(&ha->pdev->dev,
 +			    EFT_SIZE, ha->eft, ha->eft_dma);
 +
 +		/* Allocate memory for Extended Trace Buffer. */
 +		tc = dma_zalloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,
 +					 GFP_KERNEL);
 +		if (!tc) {
 +			ql_log(ql_log_warn, vha, 0x00c1,
 +			    "Unable to allocate (%d KB) for EFT.\n",
 +			    EFT_SIZE / 1024);
 +			goto eft_err;
 +		}
 +
 +		rval = qla2x00_enable_eft_trace(vha, tc_dma, EFT_NUM_BUFFERS);
 +		if (rval) {
 +			ql_log(ql_log_warn, vha, 0x00c2,
 +			    "Unable to initialize EFT (%d).\n", rval);
 +			dma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc,
 +			    tc_dma);
 +			goto eft_err;
 +		}
 +		ql_dbg(ql_dbg_init, vha, 0x00c3,
 +		    "Allocated (%d KB) EFT ...\n", EFT_SIZE / 1024);
 +
 +		ha->eft_dma = tc_dma;
 +		ha->eft = tc;
++=======
+ 	/* Allocate memory for Extended Trace Buffer. */
+ 	tc = dma_alloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,
+ 				GFP_KERNEL);
+ 	if (!tc) {
+ 		ql_log(ql_log_warn, vha, 0x00c1,
+ 		       "Unable to allocate (%d KB) for EFT.\n",
+ 		       EFT_SIZE / 1024);
+ 		return;
++>>>>>>> 3cf92f4bfccb (scsi: qla2xxx: cleanup trace buffer initialization)
  	}
  
- eft_err:
- 	return;
+ 	rval = qla2x00_enable_eft_trace(vha, tc_dma, EFT_NUM_BUFFERS);
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x00c2,
+ 		       "Unable to initialize EFT (%d).\n", rval);
+ 		dma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc, tc_dma);
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x00c3,
+ 	       "Allocated (%d KB) EFT ...\n", EFT_SIZE / 1024);
+ 
+ 	ha->eft_dma = tc_dma;
+ 	ha->eft = tc;
+ }
+ 
+ static void
+ qla2x00_alloc_offload_mem(scsi_qla_host_t *vha)
+ {
+ 	qla2x00_init_fce_trace(vha);
+ 	qla2x00_init_eft_trace(vha);
  }
  
  void
@@@ -2948,48 -3176,57 +3029,84 @@@ qla2x00_alloc_fw_dump(scsi_qla_host_t *
  		}
  		if (ha->tgt.atio_ring)
  			mq_size += ha->tgt.atio_q_length * sizeof(request_t);
++<<<<<<< HEAD
 +		/* Allocate memory for Fibre Channel Event Buffer. */
 +		if (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&
 +		    !IS_QLA27XX(ha))
 +			goto try_eft;
 +
 +		fce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;
 +try_eft:
 +		ql_dbg(ql_dbg_init, vha, 0x00c3,
 +		    "Allocated (%d KB) EFT ...\n", EFT_SIZE / 1024);
 +		eft_size = EFT_SIZE;
 +		ha->eft_dma = tc_dma;
 +		ha->eft = tc;
++=======
+ 
+ 		qla2x00_init_fce_trace(vha);
+ 		if (ha->fce)
+ 			fce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;
+ 		qla2x00_init_eft_trace(vha);
+ 		if (ha->eft)
+ 			eft_size = EFT_SIZE;
++>>>>>>> 3cf92f4bfccb (scsi: qla2xxx: cleanup trace buffer initialization)
  	}
  
 -	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 -		struct fwdt *fwdt = ha->fwdt;
 -		uint j;
 -
 -		for (j = 0; j < 2; j++, fwdt++) {
 -			if (!fwdt->template) {
 -				ql_log(ql_log_warn, vha, 0x00ba,
 -				    "-> fwdt%u no template\n", j);
 -				continue;
 -			}
 -			ql_dbg(ql_dbg_init, vha, 0x00fa,
 -			    "-> fwdt%u calculating fwdump size...\n", j);
 -			fwdt->dump_size = qla27xx_fwdt_calculate_dump_size(
 -			    vha, fwdt->template);
 -			ql_dbg(ql_dbg_init, vha, 0x00fa,
 -			    "-> fwdt%u calculated fwdump size = %#lx bytes\n",
 -			    j, fwdt->dump_size);
 -			dump_size += fwdt->dump_size;
 +	if (IS_QLA27XX(ha)) {
 +		if (!ha->fw_dump_template) {
 +			ql_log(ql_log_warn, vha, 0x00ba,
 +			    "Failed missing fwdump template\n");
 +			return;
  		}
++<<<<<<< HEAD
 +		dump_size = qla27xx_fwdt_calculate_dump_size(vha);
 +		ql_dbg(ql_dbg_init, vha, 0x00fa,
 +		    "-> allocating fwdump (%x bytes)...\n", dump_size);
 +		goto allocate;
 +	}
 +
 +	req_q_size = req->length * sizeof(request_t);
 +	rsp_q_size = rsp->length * sizeof(response_t);
 +	dump_size = offsetof(struct qla2xxx_fw_dump, isp);
 +	dump_size += fixed_size + mem_size + req_q_size + rsp_q_size + eft_size;
 +	ha->chain_offset = dump_size;
 +	dump_size += mq_size + fce_size;
 +
 +	if (ha->exchoffld_buf)
 +		dump_size += sizeof(struct qla2xxx_offld_chain) +
 +			ha->exchoffld_size;
 +	if (ha->exlogin_buf)
 +		dump_size += sizeof(struct qla2xxx_offld_chain) +
 +			ha->exlogin_size;
 +
 +allocate:
 +	if (!ha->fw_dump_len || dump_size != ha->fw_dump_len) {
++=======
+ 	} else {
+ 		req_q_size = req->length * sizeof(request_t);
+ 		rsp_q_size = rsp->length * sizeof(response_t);
+ 		dump_size = offsetof(struct qla2xxx_fw_dump, isp);
+ 		dump_size += fixed_size + mem_size + req_q_size + rsp_q_size
+ 			+ eft_size;
+ 		ha->chain_offset = dump_size;
+ 		dump_size += mq_size + fce_size;
+ 		if (ha->exchoffld_buf)
+ 			dump_size += sizeof(struct qla2xxx_offld_chain) +
+ 				ha->exchoffld_size;
+ 		if (ha->exlogin_buf)
+ 			dump_size += sizeof(struct qla2xxx_offld_chain) +
+ 				ha->exlogin_size;
+ 	}
+ 
+ 	if (!ha->fw_dump_len || dump_size > ha->fw_dump_alloc_len) {
+ 
+ 		ql_dbg(ql_dbg_init, vha, 0x00c5,
+ 		    "%s dump_size %d fw_dump_len %d fw_dump_alloc_len %d\n",
+ 		    __func__, dump_size, ha->fw_dump_len,
+ 		    ha->fw_dump_alloc_len);
+ 
++>>>>>>> 3cf92f4bfccb (scsi: qla2xxx: cleanup trace buffer initialization)
  		fw_dump = vmalloc(dump_size);
  		if (!fw_dump) {
  			ql_log(ql_log_warn, vha, 0x00c4,
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 9c7c364118a9..d4d402c823e4 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -4429,6 +4429,7 @@ qla2x00_free_fw_dump(struct qla_hw_data *ha)
 
 	ha->fce = NULL;
 	ha->fce_dma = 0;
+	ha->flags.fce_enabled = 0;
 	ha->eft = NULL;
 	ha->eft_dma = 0;
 	ha->fw_dumped = 0;
