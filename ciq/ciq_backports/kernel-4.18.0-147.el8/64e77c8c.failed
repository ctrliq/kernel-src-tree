acpi/nfit, libnvdimm: Add support for issue secure erase DSM to Intel nvdimm

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 64e77c8c047fb91ea8c7800c1238108a72f0bf9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/64e77c8c.failed

Add support to issue a secure erase DSM to the Intel nvdimm. The
required passphrase is acquired from an encrypted key in the kernel user
keyring. To trigger the action, "erase <keyid>" is written to the
"security" sysfs attribute.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 64e77c8c047fb91ea8c7800c1238108a72f0bf9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/intel.c
#	drivers/nvdimm/dimm_devs.c
#	drivers/nvdimm/nd-core.h
#	drivers/nvdimm/security.c
#	include/linux/libnvdimm.h
diff --cc drivers/nvdimm/dimm_devs.c
index 508dd405f84f,bc432b7c17b8..000000000000
--- a/drivers/nvdimm/dimm_devs.c
+++ b/drivers/nvdimm/dimm_devs.c
@@@ -370,6 -370,118 +370,121 @@@ static ssize_t available_slots_show(str
  }
  static DEVICE_ATTR_RO(available_slots);
  
++<<<<<<< HEAD
++=======
+ static ssize_t security_show(struct device *dev,
+ 		struct device_attribute *attr, char *buf)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	switch (nvdimm->sec.state) {
+ 	case NVDIMM_SECURITY_DISABLED:
+ 		return sprintf(buf, "disabled\n");
+ 	case NVDIMM_SECURITY_UNLOCKED:
+ 		return sprintf(buf, "unlocked\n");
+ 	case NVDIMM_SECURITY_LOCKED:
+ 		return sprintf(buf, "locked\n");
+ 	case NVDIMM_SECURITY_FROZEN:
+ 		return sprintf(buf, "frozen\n");
+ 	case NVDIMM_SECURITY_OVERWRITE:
+ 		return sprintf(buf, "overwrite\n");
+ 	}
+ 
+ 	return -ENOTTY;
+ }
+ 
+ #define OPS						\
+ 	C( OP_FREEZE,		"freeze",	1),	\
+ 	C( OP_DISABLE,		"disable",	2),	\
+ 	C( OP_UPDATE,		"update",	3),	\
+ 	C( OP_ERASE,		"erase",	2)
+ #undef C
+ #define C(a, b, c) a
+ enum nvdimmsec_op_ids { OPS };
+ #undef C
+ #define C(a, b, c) { b, c }
+ static struct {
+ 	const char *name;
+ 	int args;
+ } ops[] = { OPS };
+ #undef C
+ 
+ #define SEC_CMD_SIZE 32
+ #define KEY_ID_SIZE 10
+ 
+ static ssize_t __security_store(struct device *dev, const char *buf, size_t len)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 	ssize_t rc;
+ 	char cmd[SEC_CMD_SIZE+1], keystr[KEY_ID_SIZE+1],
+ 		nkeystr[KEY_ID_SIZE+1];
+ 	unsigned int key, newkey;
+ 	int i;
+ 
+ 	if (atomic_read(&nvdimm->busy))
+ 		return -EBUSY;
+ 
+ 	rc = sscanf(buf, "%"__stringify(SEC_CMD_SIZE)"s"
+ 			" %"__stringify(KEY_ID_SIZE)"s"
+ 			" %"__stringify(KEY_ID_SIZE)"s",
+ 			cmd, keystr, nkeystr);
+ 	if (rc < 1)
+ 		return -EINVAL;
+ 	for (i = 0; i < ARRAY_SIZE(ops); i++)
+ 		if (sysfs_streq(cmd, ops[i].name))
+ 			break;
+ 	if (i >= ARRAY_SIZE(ops))
+ 		return -EINVAL;
+ 	if (ops[i].args > 1)
+ 		rc = kstrtouint(keystr, 0, &key);
+ 	if (rc >= 0 && ops[i].args > 2)
+ 		rc = kstrtouint(nkeystr, 0, &newkey);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	if (i == OP_FREEZE) {
+ 		dev_dbg(dev, "freeze\n");
+ 		rc = nvdimm_security_freeze(nvdimm);
+ 	} else if (i == OP_DISABLE) {
+ 		dev_dbg(dev, "disable %u\n", key);
+ 		rc = nvdimm_security_disable(nvdimm, key);
+ 	} else if (i == OP_UPDATE) {
+ 		dev_dbg(dev, "update %u %u\n", key, newkey);
+ 		rc = nvdimm_security_update(nvdimm, key, newkey);
+ 	} else if (i == OP_ERASE) {
+ 		dev_dbg(dev, "erase %u\n", key);
+ 		rc = nvdimm_security_erase(nvdimm, key);
+ 	} else
+ 		return -EINVAL;
+ 
+ 	if (rc == 0)
+ 		rc = len;
+ 	return rc;
+ }
+ 
+ static ssize_t security_store(struct device *dev,
+ 		struct device_attribute *attr, const char *buf, size_t len)
+ 
+ {
+ 	ssize_t rc;
+ 
+ 	/*
+ 	 * Require all userspace triggered security management to be
+ 	 * done while probing is idle and the DIMM is not in active use
+ 	 * in any region.
+ 	 */
+ 	device_lock(dev);
+ 	nvdimm_bus_lock(dev);
+ 	wait_nvdimm_bus_probe_idle(dev);
+ 	rc = __security_store(dev, buf, len);
+ 	nvdimm_bus_unlock(dev);
+ 	device_unlock(dev);
+ 
+ 	return rc;
+ }
+ static DEVICE_ATTR_RW(security);
+ 
++>>>>>>> 64e77c8c047f (acpi/nfit, libnvdimm: Add support for issue secure erase DSM to Intel nvdimm)
  static struct attribute *nvdimm_attributes[] = {
  	&dev_attr_state.attr,
  	&dev_attr_flags.attr,
@@@ -378,8 -490,27 +493,28 @@@
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static umode_t nvdimm_visible(struct kobject *kobj, struct attribute *a, int n)
+ {
+ 	struct device *dev = container_of(kobj, typeof(*dev), kobj);
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	if (a != &dev_attr_security.attr)
+ 		return a->mode;
+ 	if (nvdimm->sec.state < 0)
+ 		return 0;
+ 	/* Are there any state mutation ops? */
+ 	if (nvdimm->sec.ops->freeze || nvdimm->sec.ops->disable
+ 			|| nvdimm->sec.ops->change_key
+ 			|| nvdimm->sec.ops->erase)
+ 		return a->mode;
+ 	return 0444;
+ }
+ 
++>>>>>>> 64e77c8c047f (acpi/nfit, libnvdimm: Add support for issue secure erase DSM to Intel nvdimm)
  struct attribute_group nvdimm_attribute_group = {
  	.attrs = nvdimm_attributes,
 -	.is_visible = nvdimm_visible,
  };
  EXPORT_SYMBOL_GPL(nvdimm_attribute_group);
  
diff --cc drivers/nvdimm/nd-core.h
index a5977b369651,b4b633ccfbe9..000000000000
--- a/drivers/nvdimm/nd-core.h
+++ b/drivers/nvdimm/nd-core.h
@@@ -42,8 -42,43 +42,42 @@@ struct nvdimm 
  	int id, num_flush;
  	struct resource *flush_wpq;
  	const char *dimm_id;
 -	struct {
 -		const struct nvdimm_security_ops *ops;
 -		enum nvdimm_security_state state;
 -	} sec;
  };
  
++<<<<<<< HEAD
++=======
+ static inline enum nvdimm_security_state nvdimm_security_state(
+ 		struct nvdimm *nvdimm)
+ {
+ 	if (!nvdimm->sec.ops)
+ 		return -ENXIO;
+ 
+ 	return nvdimm->sec.ops->state(nvdimm);
+ }
+ int nvdimm_security_freeze(struct nvdimm *nvdimm);
+ #if IS_ENABLED(CONFIG_NVDIMM_KEYS)
+ int nvdimm_security_disable(struct nvdimm *nvdimm, unsigned int keyid);
+ int nvdimm_security_update(struct nvdimm *nvdimm, unsigned int keyid,
+ 		unsigned int new_keyid);
+ int nvdimm_security_erase(struct nvdimm *nvdimm, unsigned int keyid);
+ #else
+ static inline int nvdimm_security_disable(struct nvdimm *nvdimm,
+ 		unsigned int keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int nvdimm_security_update(struct nvdimm *nvdimm, unsigned int keyid,
+ 		unsigned int new_keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int nvdimm_security_erase(struct nvdimm *nvdimm, unsigned int keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ 
++>>>>>>> 64e77c8c047f (acpi/nfit, libnvdimm: Add support for issue secure erase DSM to Intel nvdimm)
  /**
   * struct blk_alloc_info - tracking info for BLK dpa scanning
   * @nd_mapping: blk region mapping boundaries
diff --cc include/linux/libnvdimm.h
index c0e66496e33c,9a6cb7067dc7..000000000000
--- a/include/linux/libnvdimm.h
+++ b/include/linux/libnvdimm.h
@@@ -155,6 -155,35 +155,38 @@@ static inline struct nd_blk_region_des
  
  }
  
++<<<<<<< HEAD
++=======
+ enum nvdimm_security_state {
+ 	NVDIMM_SECURITY_DISABLED,
+ 	NVDIMM_SECURITY_UNLOCKED,
+ 	NVDIMM_SECURITY_LOCKED,
+ 	NVDIMM_SECURITY_FROZEN,
+ 	NVDIMM_SECURITY_OVERWRITE,
+ };
+ 
+ #define NVDIMM_PASSPHRASE_LEN		32
+ #define NVDIMM_KEY_DESC_LEN		22
+ 
+ struct nvdimm_key_data {
+ 	u8 data[NVDIMM_PASSPHRASE_LEN];
+ };
+ 
+ struct nvdimm_security_ops {
+ 	enum nvdimm_security_state (*state)(struct nvdimm *nvdimm);
+ 	int (*freeze)(struct nvdimm *nvdimm);
+ 	int (*change_key)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *old_data,
+ 			const struct nvdimm_key_data *new_data);
+ 	int (*unlock)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data);
+ 	int (*disable)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data);
+ 	int (*erase)(struct nvdimm *nvdimm,
+ 			const struct nvdimm_key_data *key_data);
+ };
+ 
++>>>>>>> 64e77c8c047f (acpi/nfit, libnvdimm: Add support for issue secure erase DSM to Intel nvdimm)
  void badrange_init(struct badrange *badrange);
  int badrange_add(struct badrange *badrange, u64 addr, u64 length);
  void badrange_forget(struct badrange *badrange, phys_addr_t start,
* Unmerged path drivers/acpi/nfit/intel.c
* Unmerged path drivers/nvdimm/security.c
* Unmerged path drivers/acpi/nfit/intel.c
* Unmerged path drivers/nvdimm/dimm_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path drivers/nvdimm/security.c
* Unmerged path include/linux/libnvdimm.h
