scsi: qla2xxx: Fix read offset in qla24xx_load_risc_flash()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Himanshu Madhani <hmadhani@marvell.com>
commit 1710ac17547ac8b5c44fbd74de41dee3fe26ee81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1710ac17.failed

This patch fixes regression introduced by commit f8f97b0c5b7f ("scsi:
qla2xxx: Cleanups for NVRAM/Flash read/write path") where flash read/write
routine cleanup left out code which resulted into checksum failure leading
to use-after-free stack during driver load.

Following stack trace is seen in the log file

qla2xxx [0000:00:00.0]-0005: : QLogic Fibre Channel HBA Driver: 10.01.00.16-k.
qla2xxx [0000:00:0b.0]-001d: : Found an ISP2532 irq 11 iobase 0x0000000000f47f03.
qla2xxx [0000:00:0b.0]-00cd:8: ISP Firmware failed checksum.
qla2xxx [0000:00:0b.0]-00cf:8: Setup chip ****FAILED****.
qla2xxx [0000:00:0b.0]-00d6:8: Failed to initialize adapter - Adapter flags 2.
==================================================================
BUG: KASAN: use-after-free in __list_del_entry_valid+0x15/0xd0
Read of size 8 at addr ffff8880ca05a490 by task modprobe/857

CPU: 0 PID: 857 Comm: modprobe Not tainted 5.1.0-rc1-dbg+ #4
Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
Call Trace:
  dump_stack+0x86/0xca
  print_address_description+0x6c/0x234
  ? __list_del_entry_valid+0x15/0xd0
  kasan_report.cold.3+0x1b/0x34
  ? __list_del_entry_valid+0x15/0xd0
  ? __kmem_cache_shutdown.cold.95+0xf5/0x176
  ? __list_del_entry_valid+0x15/0xd0
  __asan_load8+0x54/0x90
  __list_del_entry_valid+0x15/0xd0
  dma_pool_destroy+0x4f/0x260
  ? dma_free_attrs+0xb4/0xd0
  qla2x00_mem_free+0x529/0xcc0 [qla2xxx]
  ? kobject_put+0xdb/0x230
  qla2x00_probe_one+0x2b5e/0x45f0 [qla2xxx]
  ? qla2xxx_pci_error_detected+0x210/0x210 [qla2xxx]
  ? match_held_lock+0x20/0x240
  ? find_held_lock+0xca/0xf0
  ? mark_held_locks+0x86/0xb0
  ? _raw_spin_unlock_irqrestore+0x52/0x60
  ? __pm_runtime_resume+0x5b/0xb0
  ? lockdep_hardirqs_on+0x185/0x260
  ? _raw_spin_unlock_irqrestore+0x52/0x60
  ? trace_hardirqs_on+0x24/0x130
  ? preempt_count_sub+0x13/0xc0
  ? _raw_spin_unlock_irqrestore+0x3d/0x60
  pci_device_probe+0x154/0x1e0
  really_probe+0x17d/0x540
  ? device_driver_attach+0x90/0x90
  driver_probe_device+0x113/0x170
  ? device_driver_attach+0x90/0x90
  device_driver_attach+0x88/0x90
  __driver_attach+0xb5/0x190
  bus_for_each_dev+0xf8/0x160
  ? subsys_dev_iter_exit+0x10/0x10
  ? kasan_check_read+0x11/0x20
  ? preempt_count_sub+0x13/0xc0
  ? _raw_spin_unlock+0x2c/0x50
  driver_attach+0x26/0x30
  bus_add_driver+0x238/0x2f0
  driver_register+0xd7/0x150
  __pci_register_driver+0xd5/0xe0
  ? 0xffffffffa06c8000
  qla2x00_module_init+0x208/0x254 [qla2xxx]
  do_one_initcall+0xc0/0x3c9
  ? trace_event_raw_event_initcall_finish+0x150/0x150
  ? __kasan_kmalloc.constprop.5+0xc7/0xd0
  ? kasan_unpoison_shadow+0x35/0x50
  ? kasan_poison_shadow+0x2f/0x40
  ? __asan_register_globals+0x5a/0x70
  do_init_module+0x103/0x330
  load_module+0x36df/0x3b70
  ? fsnotify+0x611/0x640
  ? module_frob_arch_sections+0x20/0x20
  ? kernel_read+0x74/0xa0
  ? kasan_check_write+0x14/0x20
  ? kernel_read_file+0x25e/0x320
  ? do_mmap+0x42c/0x6c0
  __do_sys_finit_module+0x133/0x1c0
  ? __do_sys_finit_module+0x133/0x1c0
  ? __do_sys_init_module+0x210/0x210
  ? fput_many+0x1b/0xc0
  ? fput+0xe/0x10
  ? do_syscall_64+0x14/0x210
  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe
  __x64_sys_finit_module+0x3e/0x50
  do_syscall_64+0x72/0x210
  entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x7f8bd5c03219
Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 47 fc 0c 00 f7 d8 64 89 01 48
RSP: 002b:00007fff9d11de98 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000055ef21596b50 RCX: 00007f8bd5c03219
RDX: 0000000000000000 RSI: 000055ef21596570 RDI: 0000000000000004
RBP: 000055ef21596570 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000004 R11: 0000000000000246 R12: 0000000000000000
R13: 000055ef21596c80 R14: 0000000000040000 R15: 000055ef21596b50

Allocated by task 857:
  save_stack+0x43/0xd0
  __kasan_kmalloc.constprop.5+0xc7/0xd0
  kasan_kmalloc+0x9/0x10
  kmem_cache_alloc_trace+0x144/0x300
  dma_pool_create+0xb5/0x3b0
  qla2x00_mem_alloc+0xb98/0x1ad0 [qla2xxx]
  qla2x00_probe_one+0xe28/0x45f0 [qla2xxx]
  pci_device_probe+0x154/0x1e0
  really_probe+0x17d/0x540
  driver_probe_device+0x113/0x170
  device_driver_attach+0x88/0x90
  __driver_attach+0xb5/0x190
  bus_for_each_dev+0xf8/0x160
  driver_attach+0x26/0x30
  bus_add_driver+0x238/0x2f0
  driver_register+0xd7/0x150
  __pci_register_driver+0xd5/0xe0
  qla2x00_module_init+0x208/0x254 [qla2xxx]
  do_one_initcall+0xc0/0x3c9
  do_init_module+0x103/0x330
  load_module+0x36df/0x3b70
  __do_sys_finit_module+0x133/0x1c0
  __x64_sys_finit_module+0x3e/0x50
  do_syscall_64+0x72/0x210
  entry_SYSCALL_64_after_hwframe+0x49/0xbe

Freed by task 857:
  save_stack+0x43/0xd0
  __kasan_slab_free+0x139/0x190
  kasan_slab_free+0xe/0x10
  kfree+0xf0/0x2c0
  dma_pool_destroy+0x24c/0x260
  qla2x00_mem_free+0x529/0xcc0 [qla2xxx]
  qla2x00_free_device+0x167/0x1b0 [qla2xxx]
  qla2x00_probe_one+0x2b28/0x45f0 [qla2xxx]
  pci_device_probe+0x154/0x1e0
  really_probe+0x17d/0x540
  driver_probe_device+0x113/0x170
  device_driver_attach+0x88/0x90
  __driver_attach+0xb5/0x190
  bus_for_each_dev+0xf8/0x160
  driver_attach+0x26/0x30
  bus_add_driver+0x238/0x2f0
  driver_register+0xd7/0x150
  __pci_register_driver+0xd5/0xe0
  qla2x00_module_init+0x208/0x254 [qla2xxx]
  do_one_initcall+0xc0/0x3c9
  do_init_module+0x103/0x330
  load_module+0x36df/0x3b70
  __do_sys_finit_module+0x133/0x1c0
  __x64_sys_finit_module+0x3e/0x50
  do_syscall_64+0x72/0x210
  entry_SYSCALL_64_after_hwframe+0x49/0xbe

The buggy address belongs to the object at ffff8880ca05a400
  which belongs to the cache kmalloc-192 of size 192
The buggy address is located 144 bytes inside of
  192-byte region [ffff8880ca05a400, ffff8880ca05a4c0)
The buggy address belongs to the page:
page:ffffea0003281680 count:1 mapcount:0 mapping:ffff88811bf03380 index:0x0 compound_mapcount: 0
flags: 0x4000000000010200(slab|head)
raw: 4000000000010200 0000000000000000 0000000c00000001 ffff88811bf03380
raw: 0000000000000000 0000000080200020 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
  ffff8880ca05a380: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc
  ffff8880ca05a400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff8880ca05a480: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc
                          ^
  ffff8880ca05a500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  ffff8880ca05a580: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc
==================================================================

Fixes: f8f97b0c5b7f ("scsi: qla2xxx: Cleanups for NVRAM/Flash read/write path")
	Reported-by: Bart Van Assche <bvanassche@acm.org>
	Tested-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1710ac17547ac8b5c44fbd74de41dee3fe26ee81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 046c47b82245,948f20805111..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -7100,72 -7678,82 +7100,114 @@@ qla24xx_load_risc_flash(scsi_qla_host_
  			faddr += dlen;
  			risc_addr += dlen;
  			risc_size -= dlen;
 +			fragment++;
  		}
 +
 +		/* Next segment. */
 +		segments--;
  	}
  
 -	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 -		return QLA_SUCCESS;
 +	if (!IS_QLA27XX(ha))
 +		return rval;
  
 -	templates = (risc_attr & BIT_9) ? 2 : 1;
 -	ql_dbg(ql_dbg_init, vha, 0x0160, "-> templates = %u\n", templates);
 -	for (j = 0; j < templates; j++, fwdt++) {
 -		if (fwdt->template)
 -			vfree(fwdt->template);
 -		fwdt->template = NULL;
 -		fwdt->length = 0;
 -
 -		dcode = (void *)req->ring;
 -		qla24xx_read_flash_data(vha, dcode, faddr, 7);
 -		risc_size = be32_to_cpu(dcode[2]);
 -		ql_dbg(ql_dbg_init, vha, 0x0161,
 -		    "-> fwdt%u template array at %#x (%#x dwords)\n",
 -		    j, faddr, risc_size);
 -		if (!risc_size || !~risc_size) {
 -			ql_dbg(ql_dbg_init, vha, 0x0162,
 -			    "-> fwdt%u failed to read array\n", j);
 -			goto failed;
 -		}
 +	if (ha->fw_dump_template)
 +		vfree(ha->fw_dump_template);
 +	ha->fw_dump_template = NULL;
 +	ha->fw_dump_template_len = 0;
 +
 +	ql_dbg(ql_dbg_init, vha, 0x0161,
 +	    "Loading fwdump template from %x\n", faddr);
 +	qla24xx_read_flash_data(vha, dcode, faddr, 7);
 +	risc_size = be32_to_cpu(dcode[2]);
 +	ql_dbg(ql_dbg_init, vha, 0x0162,
 +	    "-> array size %x dwords\n", risc_size);
 +	if (risc_size == 0 || risc_size == ~0)
 +		goto failed;
  
++<<<<<<< HEAD
 +	dlen = (risc_size - 8) * sizeof(*dcode);
 +	ql_dbg(ql_dbg_init, vha, 0x0163,
 +	    "-> template allocating %x bytes...\n", dlen);
 +	ha->fw_dump_template = vmalloc(dlen);
 +	if (!ha->fw_dump_template) {
 +		ql_log(ql_log_warn, vha, 0x0164,
 +		    "Failed fwdump template allocate %x bytes.\n", risc_size);
 +		goto failed;
++=======
+ 		/* skip header and ignore checksum */
+ 		faddr += 7;
+ 		risc_size -= 8;
+ 
+ 		ql_dbg(ql_dbg_init, vha, 0x0163,
+ 		    "-> fwdt%u template allocate template %#x words...\n",
+ 		    j, risc_size);
+ 		fwdt->template = vmalloc(risc_size * sizeof(*dcode));
+ 		if (!fwdt->template) {
+ 			ql_log(ql_log_warn, vha, 0x0164,
+ 			    "-> fwdt%u failed allocate template.\n", j);
+ 			goto failed;
+ 		}
+ 
+ 		dcode = fwdt->template;
+ 		qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
+ 
+ 		if (!qla27xx_fwdt_template_valid(dcode)) {
+ 			ql_log(ql_log_warn, vha, 0x0165,
+ 			    "-> fwdt%u failed template validate\n", j);
+ 			goto failed;
+ 		}
+ 
+ 		dlen = qla27xx_fwdt_template_size(dcode);
+ 		ql_dbg(ql_dbg_init, vha, 0x0166,
+ 		    "-> fwdt%u template size %#lx bytes (%#lx words)\n",
+ 		    j, dlen, dlen / sizeof(*dcode));
+ 		if (dlen > risc_size * sizeof(*dcode)) {
+ 			ql_log(ql_log_warn, vha, 0x0167,
+ 			    "-> fwdt%u template exceeds array (%-lu bytes)\n",
+ 			    j, dlen - risc_size * sizeof(*dcode));
+ 			goto failed;
+ 		}
+ 
+ 		fwdt->length = dlen;
+ 		ql_dbg(ql_dbg_init, vha, 0x0168,
+ 		    "-> fwdt%u loaded template ok\n", j);
+ 
+ 		faddr += risc_size + 1;
++>>>>>>> 1710ac17547a (scsi: qla2xxx: Fix read offset in qla24xx_load_risc_flash())
  	}
  
 -	return QLA_SUCCESS;
 +	faddr += 7;
 +	risc_size -= 8;
 +	dcode = ha->fw_dump_template;
 +	qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
 +	for (i = 0; i < risc_size; i++)
 +		dcode[i] = le32_to_cpu(dcode[i]);
  
 -failed:
 -	if (fwdt->template)
 -		vfree(fwdt->template);
 -	fwdt->template = NULL;
 -	fwdt->length = 0;
 +	if (!qla27xx_fwdt_template_valid(dcode)) {
 +		ql_log(ql_log_warn, vha, 0x0165,
 +		    "Failed fwdump template validate\n");
 +		goto failed;
 +	}
  
 -	return QLA_SUCCESS;
 +	dlen = qla27xx_fwdt_template_size(dcode);
 +	ql_dbg(ql_dbg_init, vha, 0x0166,
 +	    "-> template size %x bytes\n", dlen);
 +	if (dlen > risc_size * sizeof(*dcode)) {
 +		ql_log(ql_log_warn, vha, 0x0167,
 +		    "Failed fwdump template exceeds array by %zx bytes\n",
 +		    (size_t)(dlen - risc_size * sizeof(*dcode)));
 +		goto failed;
 +	}
 +	ha->fw_dump_template_len = dlen;
 +	return rval;
 +
 +failed:
 +	ql_log(ql_log_warn, vha, 0x016d, "Failed fwdump template\n");
 +	if (ha->fw_dump_template)
 +		vfree(ha->fw_dump_template);
 +	ha->fw_dump_template = NULL;
 +	ha->fw_dump_template_len = 0;
 +	return rval;
  }
  
  #define QLA_FW_URL "http://ldriver.qlogic.com/firmware/"
@@@ -7296,19 -7884,9 +7338,25 @@@ qla24xx_load_risc_blob(scsi_qla_host_t 
  		return QLA_FUNCTION_FAILED;
  	}
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_init, vha, 0x0092,
 +	    "FW: Loading via request-firmware.\n");
 +
 +	rval = QLA_SUCCESS;
 +
 +	segments = FA_RISC_CODE_SEGMENTS;
 +	dcode = (uint32_t *)req->ring;
 +	*srisc_addr = 0;
 +	fwcode = (uint32_t *)blob->fw->data;
 +	fwclen = 0;
 +
 +	/* Validate firmware image by checking version. */
 +	if (blob->fw->size < 8 * sizeof(uint32_t)) {
++=======
+ 	fwcode = (void *)blob->fw->data;
+ 	dcode = fwcode;
+ 	if (qla24xx_risc_firmware_invalid(dcode)) {
++>>>>>>> 1710ac17547a (scsi: qla2xxx: Fix read offset in qla24xx_load_risc_flash())
  		ql_log(ql_log_fatal, vha, 0x0093,
  		    "Unable to verify integrity of firmware image (%zd).\n",
  		    blob->fw->size);
@@@ -7329,23 -7896,22 +7366,28 @@@
  		return QLA_FUNCTION_FAILED;
  	}
  
 -	dcode = (void *)req->ring;
 -	*srisc_addr = 0;
 -	segments = FA_RISC_CODE_SEGMENTS;
 -	for (j = 0; j < segments; j++) {
 -		ql_dbg(ql_dbg_init, vha, 0x0096,
 -		    "-> Loading segment %u...\n", j);
 +	while (segments && rval == QLA_SUCCESS) {
  		risc_addr = be32_to_cpu(fwcode[2]);
 +		*srisc_addr = *srisc_addr == 0 ? risc_addr : *srisc_addr;
  		risc_size = be32_to_cpu(fwcode[3]);
  
 -		if (!*srisc_addr) {
 -			*srisc_addr = risc_addr;
 -			risc_attr = be32_to_cpu(fwcode[9]);
 +		/* Validate firmware image size. */
 +		fwclen += risc_size * sizeof(uint32_t);
 +		if (blob->fw->size < fwclen) {
 +			ql_log(ql_log_fatal, vha, 0x0096,
 +			    "Unable to verify integrity of firmware image "
 +			    "(%zd).\n", blob->fw->size);
 +			return QLA_FUNCTION_FAILED;
  		}
  
++<<<<<<< HEAD
 +		fragment = 0;
 +		while (risc_size > 0 && rval == QLA_SUCCESS) {
 +			dlen = (uint32_t)(ha->fw_transfer_size >> 2);
++=======
+ 		dlen = ha->fw_transfer_size >> 2;
+ 		for (fragment = 0; risc_size; fragment++) {
++>>>>>>> 1710ac17547a (scsi: qla2xxx: Fix read offset in qla24xx_load_risc_flash())
  			if (dlen > risc_size)
  				dlen = risc_size;
  
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
