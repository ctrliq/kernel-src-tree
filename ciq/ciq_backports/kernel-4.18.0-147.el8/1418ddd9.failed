net/mlx5e: Duplicate offloaded TC eswitch rules under uplink LAG

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Aviv Heller <avivh@mellanox.com>
commit 1418ddd96afdb097ab9a2fe09c94e820d596321a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1418ddd9.failed

Under uplink LAG, packets that match a flow might arrive on both uplink
ports and transmitted through both as part of supporting aggregation and
high-availability.

When the netdevs representing the uplinks are set into LAG (bonding,
teaming), duplicate the TC flow offloading into each of the per-uplink
e-switches.

Duplication is not required if the source is the bond device, since in
this case it is assumed that the bond and the uplink netdevs share the
same TC block, and thus duplication will occur naturally by the stack.

Note that under encapsulation scheme, both flows will use the same
neighbour and hence both will contribute to the last-used feedback
towards the stack.

	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Signed-off-by: Rabie Loulou <rabiel@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 1418ddd96afdb097ab9a2fe09c94e820d596321a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c9ee89f4edb1,864f3b00d09d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2766,31 -2708,29 +2766,53 @@@ static struct rhashtable *get_tc_ht(str
  		return &priv->fs.tc.ht;
  }
  
++<<<<<<< HEAD
 +int mlx5e_configure_flower(struct mlx5e_priv *priv,
 +			   struct tc_cls_flower_offload *f, int flags)
++=======
+ static bool is_peer_flow_needed(struct mlx5e_tc_flow *flow)
+ {
+ 	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
+ 	bool is_rep_ingress = attr->in_rep->vport != FDB_UPLINK_VPORT &&
+ 			      flow->flags & MLX5E_TC_FLOW_INGRESS;
+ 	bool act_is_encap = !!(attr->action &
+ 			       MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT);
+ 	bool esw_paired = mlx5_devcom_is_paired(attr->in_mdev->priv.devcom,
+ 						MLX5_DEVCOM_ESW_OFFLOADS);
+ 
+ 	return esw_paired && mlx5_lag_is_active(attr->in_mdev) &&
+ 	       (is_rep_ingress || act_is_encap);
+ }
+ 
+ static int
+ mlx5e_alloc_flow(struct mlx5e_priv *priv, int attr_size,
+ 		 struct tc_cls_flower_offload *f, u16 flow_flags,
+ 		 struct mlx5e_tc_flow_parse_attr **__parse_attr,
+ 		 struct mlx5e_tc_flow **__flow)
++>>>>>>> 1418ddd96afd (net/mlx5e: Duplicate offloaded TC eswitch rules under uplink LAG)
  {
 +	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
 +	struct rhashtable *tc_ht = get_tc_ht(priv);
  	struct mlx5e_tc_flow *flow;
 -	int err;
 +	int attr_size, err = 0;
 +	u8 flow_flags = 0;
 +
 +	get_flags(flags, &flow_flags);
 +
 +	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
 +	if (flow) {
 +		netdev_warn_once(priv->netdev, "flow cookie %lx already exists, ignoring\n", f->cookie);
 +		return 0;
 +	}
 +
 +	if (esw && esw->mode == SRIOV_OFFLOADS) {
 +		flow_flags |= MLX5E_TC_FLOW_ESWITCH;
 +		attr_size  = sizeof(struct mlx5_esw_flow_attr);
 +	} else {
 +		flow_flags |= MLX5E_TC_FLOW_NIC;
 +		attr_size  = sizeof(struct mlx5_nic_flow_attr);
 +	}
  
  	flow = kzalloc(sizeof(*flow) + attr_size, GFP_KERNEL);
  	parse_attr = kvzalloc(sizeof(*parse_attr), GFP_KERNEL);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
